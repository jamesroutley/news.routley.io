<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bbenchoff.github.io/pages/FiniteAtari.html">Original</a>
    <h1>Finding Atari Games in Randomly Generated Data</h1>
    
    <div id="readability-page-1" class="page"><div>
        <!-- ── Finite Atari Machine banner ── -->


<p>
  Finding Atari Games in Randomly Generated Data
</p>

<p>
  TL;DR, <a href="https://github.com/bbenchoff/FiniteAtariMachine">here’s the GitHub repo</a>
</p>



<!-- ── Finite Atari Machine banner ── -->

<p>This project generated around 30 Billion individual 4kB files of random data. These files were winnowed down to about 10,000 through some heuristics gleaned from the complete collection of Atari ROM files. Finally, a classifier system scanned them using an Atari 2600 emulator to see if any of these random files were actually an Atari game. This project answers a question no one asked, no one wanted, and is a massive waste of resources: What if I shove a billion monkeys in a GPU and asked them to write a game for the Atari 2600?</p>

<p>Thanks to advances in GPUs, AI, and machine learning, we can now (very quickly) write a Python script that dumps garbage into 4KB ROMs and asks, <em>“does this look like a game?”</em>  This isn’t nostalgia, because my first console was an NES. This is about exploring something unimaginably vast and seeing if anything weird falls out.</p>

<h2 id="results-first">Results First</h2>

<p>Because no one reads below the fold, here’s an interactive emulator showcasing the most interesting Atari ROMs discovered. There’s no genetic algorithm here; just billions of random files run through an emulator. These are the best of the weird:</p>

<div>
  <p>
    <strong>WARNING: turn your volume down. There’s a bug in <a href="https://github.com/EmulatorJS/EmulatorJS">EmulatorJS</a>.</strong>
  </p>

  
</div>

<h2 id="problem-scope">Problem Scope</h2>

<p>Assume each Atari 2600 cartridge is a 4 kilobyte chunk of data. It’s a maximum of 4096 bytes, or 32,768 bits. That means there are $2^{32768}$ possible ROMs. For perspective:</p>

<ul>
  <li>That’s $10^{10159}$ potential Atari games.</li>
  <li>There are about $10^{20}$ grains of sand on Earth.</li>
  <li>And roughly $10^{80}$ protons in the visible universe.</li>
</ul>

<p>If you turned an entire datacenter of AI compute boxes onto this problem, it would likely take years before anything interesting was found. But with a little bit of smarts and actually reading a datasheet, the problem set is massively reduced. The basic search path to finding a ‘random’ Atari game would be to:</p>

<ol>
  <li>Generate a ROM, by dumping 4kB of data from /dev/random into a file.</li>
  <li>Run that file in an emulator</li>
  <li>Capture a screenshot or five</li>
  <li>Filter or score them with AI</li>
  <li>Save the best results for further investigation.</li>
</ol>

<p>This would work, if we had enough time to wait for black holes to devour the Universe. A better idea would be to front-load the pipeline with some simple checks to discard the absolute garbage before spinning up an emulator. It would help to know what a real Atari ROM would look like, simply to build some heuristics.</p>

<h2 id="heuristics">Heuristics</h2>

<p>I’m not going to emulate every possible ROM. I’m trying to find the <em>interesting</em> ones. This means filtering, and being smart about what we’re doing:</p>

<p><strong>Opcode Sanity</strong> The 6507 CPU (from here on out I’m calling it a 6502, to make you, specifically, angry) has 151 valid opcodes, and these opcodes are going to be all over the first half of the ROM. First I should check if there are a lot of opcodes in the data. These opcodes are:</p>

<p><code>
    0x00, 0x01, 0x05, 0x06, 0x08, 0x09, 0x0A, 0x0D, 0x0E, 0x10, 0x11, 0x15, 0x16, 0x18,
    0x19, 0x1D, 0x1E, 0x20, 0x21, 0x24, 0x25, 0x26, 0x28, 0x29, 0x2A, 0x2C, 0x2D, 0x2E,
    0x30, 0x31, 0x35, 0x36, 0x38, 0x39, 0x3D, 0x3E, 0x40, 0x41, 0x45, 0x46, 0x48, 0x49,
    0x4A, 0x4C, 0x4D, 0x4E, 0x50, 0x51, 0x55, 0x56, 0x58, 0x59, 0x5D, 0x5E, 0x60, 0x61,
    0x65, 0x66, 0x68, 0x69, 0x6A, 0x6C, 0x6D, 0x6E, 0x70, 0x71, 0x75, 0x76, 0x78, 0x79,
    0x7D, 0x7E, 0x81, 0x84, 0x85, 0x86, 0x88, 0x8A, 0x8C, 0x8D, 0x8E, 0x90, 0x91, 0x94,
    0x95, 0x96, 0x98, 0x99, 0x9A, 0x9D, 0xA0, 0xA1, 0xA2, 0xA4, 0xA5, 0xA6, 0xA8, 0xA9,
    0xAA, 0xAC, 0xAD, 0xAE, 0xB0, 0xB1, 0xB4, 0xB5, 0xB6, 0xB8, 0xB9, 0xBA, 0xBC, 0xBD,
    0xBE, 0xC0, 0xC1, 0xC4, 0xC5, 0xC6, 0xC8, 0xC9, 0xCA, 0xCC, 0xCD, 0xCE, 0xD0, 0xD1,
    0xD5, 0xD6, 0xD8, 0xD9, 0xDD, 0xDE, 0xE0, 0xE1, 0xE4, 0xE5, 0xE6, 0xE8, 0xE9, 0xEA,
    0xEC, 0xED, 0xEE, 0xF0, 0xF1, 0xF5, 0xF6, 0xF8, 0xF9, 0xFD, 0xFE
</code></p>

<p>Random data has about a 59% chance of being a valid opcode (151 out of 256 possible bytes). Real games should do much better than that. The structure of an Atari ROM has the first kilobyte as executable, with everything after that being data and graphics data. Analysing the full set commercial Atari ROMs reveals $&gt;$ 75% of the first kilobyte should be opcodes.</p>

<p><strong>Reset Vector Tomfoolery</strong> Atari ROMs need a valid reset vector to the code’s entry point. In other words, the last two bytes of the code should be between <code>0xF000</code> and <code>0xFFFF</code>. I can cheat on this by generating a 4k ROM minus two bytes, and then try every possible reset vector during emulation. <em>That’s only 4096 times as much work</em>.</p>

<p><strong>Input <em>and</em> Output?!</strong> I can look for access to the TIA (Television Interface Adapter) to see if it will output to the screen and the RIOT (RAM-I/O-Timer) to see if it will use any input or output. The TIA handles all graphics and sound, and does so with extremely specific patterns, discovered by looking at the patterns in all real Atari games. The pattern analysis revealed:</p>

<ul>
  <li>90% use zero page addressing (<code>STA $02</code>, <code>STX $06</code>, <code>STY $00</code>)</li>
  <li>80% are STA instructions, 10% STX, 10% STY</li>
  <li>Indexed addressing is common (<code>STA $00,X</code>, <code>STY $10,X</code>)</li>
  <li>WSYNC ($02) dominates - 18.8% of all TIA accesses (games constantly sync to the TV)</li>
</ul>

<p>The most critical TIA registers games actually use:
<code>
$02 (WSYNC) - 18.8% of accesses - TV synchronization
$1B (GRP0)  - 8.4% of accesses  - Player 0 graphics  
$1C (GRP1)  - 7.0% of accesses  - Player 1 graphics
$2A (HMOVE) - 4.9% of accesses  - Horizontal movement
$0E/$0F (PF1/PF2) - 7.8% combined - Playfield graphics
</code></p>

<p>Instead of blindly counting any store to the TIA range <code>$00-$2F</code>, I look for the specific instruction patterns real games use.</p>

<p>The RIOT registers are more complex due to memory mirroring. The Atari 2600 uses incomplete address decoding, causing the same hardware to appear at multiple addresses. The RIOT chip contains:</p>

<ul>
  <li>Timer registers: Canonical addresses <code>$0280-$0287</code>, but due to mirroring also appear at <code>$80-$87</code>, <code>$180-$187</code>, <code>$380-$387</code>, etc.</li>
  <li>I/O registers: Canonical addresses <code>$0294-$0297</code>, also mirrored at <code>$94-$97</code>, <code>$194-$197</code>, etc.</li>
</ul>

<p>In actual ROM files, you’ll find programmers using the shorter mirrored addresses because they’re more efficient. A typical instruction like <code>STA $80</code> (set timer) appears in the ROM as <code>85 80    ; STA $80 (zero page addressing)</code> rather than the wasteful <code>8D 80 02    ; STA $0280 (absolute addressing)</code>. My heuristics look for this.</p>

<p><strong>Branches and Jumps</strong> We’re looking for games here, and every game has loops and structure. These show up as branch instructions (for loops and conditionals) and jump instructions (for subroutines and major flow control). These show up as backwards branches (loops) and forward branches (conditionals).</p>

<ul>
  <li>Branch opcodes: <code>0x10, 0x30, 0x50, 0x70, 0x90, 0xB0, 0xD0, 0xF0</code></li>
  <li>Jump opcodes: <code>0x4C</code> (JMP absolute), <code>0x6C</code> (JMP indirect), <code>0x20</code> (JSR - jump to subroutine)</li>
</ul>

<p>Take all of this together, and we can assign some heuristics to validate what counts as a “game”.</p>

<h2 id="calibrating-against-reality">Calibrating Against Reality</h2>

<p>To validate these heuristics, I analyzed the <a href="https://archive.org/details/Atari2600FullRomCollectionReuploadByDataghost">Atari 2600 Full ROM Collection</a> from the Internet Archive - all 1,530 commercial Atari ROMs ever made. A Python script analyzed each ROM to count the incidence of these heuristics in commercial games.</p>

<h3 id="rom-characteristics-by-metric">ROM Characteristics by Metric</h3>

<p>Here’s what real Atari games actually look like:</p>

<table>
  <thead>
    <tr>
      <th>Metric</th>
      <th>Min</th>
      <th>5th %</th>
      <th>10th %</th>
      <th>25th %</th>
      <th>Median</th>
      <th>75th %</th>
      <th>90th %</th>
      <th>95th %</th>
      <th>Max</th>
      <th>Mean</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Valid Opcodes (%)</strong></td>
      <td>42.1%</td>
      <td>65.6%</td>
      <td>70.0%</td>
      <td>74.0%</td>
      <td>76.0%</td>
      <td>77.9%</td>
      <td>79.6%</td>
      <td>81.4%</td>
      <td>90.7%</td>
      <td>74.8%</td>
    </tr>
    <tr>
      <td><strong>TIA Accesses</strong></td>
      <td>12</td>
      <td><strong>93</strong></td>
      <td>118</td>
      <td>186</td>
      <td>282</td>
      <td>398</td>
      <td>567</td>
      <td>743</td>
      <td>2,847</td>
      <td><strong>341</strong></td>
    </tr>
    <tr>
      <td><strong>RIOT Accesses</strong></td>
      <td>3</td>
      <td><strong>34</strong></td>
      <td>47</td>
      <td>72</td>
      <td>111</td>
      <td>158</td>
      <td>219</td>
      <td>287</td>
      <td>891</td>
      <td><strong>134</strong></td>
    </tr>
    <tr>
      <td><strong>RIOT Timer Access</strong></td>
      <td>1</td>
      <td>22</td>
      <td>31</td>
      <td>51</td>
      <td>78</td>
      <td>115</td>
      <td>161</td>
      <td>211</td>
      <td>723</td>
      <td><strong>95</strong></td>
    </tr>
    <tr>
      <td><strong>RIOT I/O Access</strong></td>
      <td>0</td>
      <td>8</td>
      <td>12</td>
      <td>18</td>
      <td>28</td>
      <td>41</td>
      <td>58</td>
      <td>74</td>
      <td>201</td>
      <td><strong>33</strong></td>
    </tr>
    <tr>
      <td><strong>Branch Instructions</strong></td>
      <td>28</td>
      <td>177</td>
      <td>200</td>
      <td>296</td>
      <td>364</td>
      <td>528</td>
      <td>789</td>
      <td>1,066</td>
      <td>5,928</td>
      <td>457</td>
    </tr>
    <tr>
      <td><strong>Jump Instructions</strong></td>
      <td>3</td>
      <td>37</td>
      <td>54</td>
      <td>76</td>
      <td>111</td>
      <td>172</td>
      <td>260</td>
      <td>351</td>
      <td>1,495</td>
      <td>142</td>
    </tr>
    <tr>
      <td><strong>Unique Opcodes</strong></td>
      <td>29</td>
      <td>125</td>
      <td>129</td>
      <td>137</td>
      <td>143</td>
      <td>148</td>
      <td>151</td>
      <td>151</td>
      <td>151</td>
      <td>141</td>
    </tr>
  </tbody>
</table>

<h3 id="instruction-distribution">Instruction Distribution</h3>
<ul>
  <li><strong>STA (Store A)</strong>: 71.8% - Writing graphics data, colors, positions</li>
  <li><strong>STX (Store X)</strong>: 9.3% - Often used for indexed operations</li>
  <li><strong>STY (Store Y)</strong>: 8.5% - Similar to STX patterns</li>
  <li><strong>LDA (Load A)</strong>: 6.7% - Games also <em>read</em> from TIA (collision detection, etc.)</li>
  <li><strong>Other</strong>: 3.7% - Indexed addressing, absolute mode</li>
</ul>

<h3 id="addressing-modes">Addressing Modes</h3>
<ul>
  <li><strong>Zero page</strong>: 82.1% - <code>STA $02</code>, <code>STX $1B</code> (fastest, most common)</li>
  <li><strong>Zero page indexed</strong>: 13.2% - <code>STA $00,X</code>, <code>STY $10,X</code> (sprite positioning)</li>
  <li><strong>Absolute</strong>: 4.7% - <code>STA $001B</code> (rare, but exists)</li>
</ul>

<h3 id="most-accessed-tia-registers">Most Accessed TIA Registers</h3>
<div><div><pre><code>$02 (WSYNC) - 18.8% - TV horizontal sync (critical timing)
$1B (GRP0)  - 8.4%  - Player 0 graphics data
$1C (GRP1)  - 7.0%  - Player 1 graphics data  
$2A (HMOVE) - 4.9%  - Horizontal movement strobe
$0E (PF1)   - 4.1%  - Playfield graphics register 1
$0F (PF2)   - 3.7%  - Playfield graphics register 2
</code></pre></div></div>

<h3 id="riot-pattern-analysis">RIOT Pattern Analysis</h3>

<p>RIOT usage splits into two clear categories:</p>

<p><strong>Timer Operations (78% of RIOT usage)</strong></p>
<ul>
  <li><strong>Registers</strong>: <code>$80-$87</code> (1T, 8T, 64T, 1024T intervals plus timer read)</li>
  <li><strong>Purpose</strong>: Timing loops, delays, frame counting</li>
  <li><strong>Pattern</strong>: Write to set timer, read <code>$84</code> to check status</li>
</ul>

<p><strong>I/O Operations (22% of RIOT usage)</strong></p>
<ul>
  <li><strong>Registers</strong>: <code>$94-$97</code> (joystick/paddle inputs, console switches)</li>
  <li><strong>Purpose</strong>: Reading player input, detecting game reset</li>
  <li><strong>Pattern</strong>: Mostly reads (<code>LDA $94</code>), occasional writes for configuration</li>
</ul>

<h3 id="composite-scoring-updated">Composite Scoring (Updated)</h3>

<p>The corrected composite score uses realistic weights based on actual game analysis:</p>

<div><div><pre><code>Score = (Opcode Ratio × 0.25) + 
        (min(TIA_Accesses/150, 1.0) × 0.30) + 
        (min(RIOT_Accesses/50, 1.0) × 0.20) + 
        (min(Branches/200, 1.0) × 0.15) + 
        (min(Jumps/40, 1.0) × 0.10)
</code></pre></div></div>

<p>Real games scored between 0.393 and 1.004, with an average of 0.853. This composite score helps rank how “game-like” any ROM appears based on multiple characteristics rather than relying on a single metric. The weights prioritize opcodes and graphics capability (TIA) as the most important indicators, with control flow and I/O capability as secondary factors.</p>

<h2 id="mining-atari-games">Mining Atari Games</h2>

<p>The first implementation of this project was extremely simple – a single thread Python script that generated 4kB minus two bytes of random data, counted the number of branches, jumps, the number of valid opcodes, backwards branches (or a loop), and the number of vectors pointing to the ROM. This was very slow, around 300-400 ROMs checked per second.</p>

<p>This is a massively parallel search, though. My GTX 1070 (I know, except I exclusively play TF2, Rocket League, and Kerbal Space Program, <a href="https://bbenchoff.github.io/pages/SXM2PCIe.html">nvidia plz gib H200 + SXM5 PCIe carrier board</a>) has 1,920 CUDA cores compared to my CPU’s 20 cores. More importantly, each CUDA core can independently generate and analyze a ROM simultaneously. Instead of generating ROMs sequentially and passing them through a pipeline, I can generate a million ROMs in parallel, analyze them all at once, and only transfer the promising candidates back to the CPU.</p>

<p>The CUDA implementation moves all the heuristics directly onto the GPU. Each thread generates one 4KB ROM using CUDA’s random number generator, then immediately applies the same analysis pipeline: counting valid opcodes, detecting TIA/RIOT register accesses, finding branch patterns, and calculating the composite score. This was written with the the CuPy library:</p>

<div><div><pre><code><span>&#34;&#34;&#34;
CUDA Atari ROM Generator
&#34;&#34;&#34;</span>

<span>import</span> <span>cupy</span> <span>as</span> <span>cp</span>
<span>import</span> <span>numpy</span> <span>as</span> <span>np</span>
<span>import</span> <span>time</span>
<span>from</span> <span>pathlib</span> <span>import</span> <span>Path</span>

<span># Constants
</span><span>ROM_SIZE</span> <span>=</span> <span>4094</span>  <span># Reset vector tested later
</span><span>BATCH_SIZE</span> <span>=</span> <span>1024</span> <span>*</span> <span>256</span>

<span># Discovery thresholds based on observed patterns
</span><span>OPCODE_THRESHOLD</span> <span>=</span> <span>0.58</span>
<span>TIA_THRESHOLD</span> <span>=</span> <span>50</span>
<span>RIOT_THRESHOLD</span> <span>=</span> <span>13</span>
<span>BRANCH_THRESHOLD</span> <span>=</span> <span>150</span>
<span>JUMP_THRESHOLD</span> <span>=</span> <span>37</span>
<span>INSTRUCTION_VARIETY</span> <span>=</span> <span>100</span>
<span>MIN_SCORE</span> <span>=</span> <span>0.52</span>

<span># Valid 6502 opcodes (151 total)
</span><span>VALID_OPCODES</span> <span>=</span> <span>np</span><span>.</span><span>array</span><span>([</span>
    <span>0x00</span><span>,</span> <span>0x01</span><span>,</span> <span>0x05</span><span>,</span> <span>0x06</span><span>,</span> <span>0x08</span><span>,</span> <span>0x09</span><span>,</span> <span>0x0A</span><span>,</span> <span>0x0D</span><span>,</span> <span>0x0E</span><span>,</span> <span>0x10</span><span>,</span> <span>0x11</span><span>,</span> <span>0x15</span><span>,</span> <span>0x16</span><span>,</span> <span>0x18</span><span>,</span>
    <span>0x19</span><span>,</span> <span>0x1D</span><span>,</span> <span>0x1E</span><span>,</span> <span>0x20</span><span>,</span> <span>0x21</span><span>,</span> <span>0x24</span><span>,</span> <span>0x25</span><span>,</span> <span>0x26</span><span>,</span> <span>0x28</span><span>,</span> <span>0x29</span><span>,</span> <span>0x2A</span><span>,</span> <span>0x2C</span><span>,</span> <span>0x2D</span><span>,</span> <span>0x2E</span><span>,</span>
    <span>0x30</span><span>,</span> <span>0x31</span><span>,</span> <span>0x35</span><span>,</span> <span>0x36</span><span>,</span> <span>0x38</span><span>,</span> <span>0x39</span><span>,</span> <span>0x3D</span><span>,</span> <span>0x3E</span><span>,</span> <span>0x40</span><span>,</span> <span>0x41</span><span>,</span> <span>0x45</span><span>,</span> <span>0x46</span><span>,</span> <span>0x48</span><span>,</span> <span>0x49</span><span>,</span>
    <span>0x4A</span><span>,</span> <span>0x4C</span><span>,</span> <span>0x4D</span><span>,</span> <span>0x4E</span><span>,</span> <span>0x50</span><span>,</span> <span>0x51</span><span>,</span> <span>0x55</span><span>,</span> <span>0x56</span><span>,</span> <span>0x58</span><span>,</span> <span>0x59</span><span>,</span> <span>0x5D</span><span>,</span> <span>0x5E</span><span>,</span> <span>0x60</span><span>,</span> <span>0x61</span><span>,</span>
    <span>0x65</span><span>,</span> <span>0x66</span><span>,</span> <span>0x68</span><span>,</span> <span>0x69</span><span>,</span> <span>0x6A</span><span>,</span> <span>0x6C</span><span>,</span> <span>0x6D</span><span>,</span> <span>0x6E</span><span>,</span> <span>0x70</span><span>,</span> <span>0x71</span><span>,</span> <span>0x75</span><span>,</span> <span>0x76</span><span>,</span> <span>0x78</span><span>,</span> <span>0x79</span><span>,</span>
    <span>0x7D</span><span>,</span> <span>0x7E</span><span>,</span> <span>0x81</span><span>,</span> <span>0x84</span><span>,</span> <span>0x85</span><span>,</span> <span>0x86</span><span>,</span> <span>0x88</span><span>,</span> <span>0x8A</span><span>,</span> <span>0x8C</span><span>,</span> <span>0x8D</span><span>,</span> <span>0x8E</span><span>,</span> <span>0x90</span><span>,</span> <span>0x91</span><span>,</span> <span>0x94</span><span>,</span>
    <span>0x95</span><span>,</span> <span>0x96</span><span>,</span> <span>0x98</span><span>,</span> <span>0x99</span><span>,</span> <span>0x9A</span><span>,</span> <span>0x9D</span><span>,</span> <span>0xA0</span><span>,</span> <span>0xA1</span><span>,</span> <span>0xA2</span><span>,</span> <span>0xA4</span><span>,</span> <span>0xA5</span><span>,</span> <span>0xA6</span><span>,</span> <span>0xA8</span><span>,</span> <span>0xA9</span><span>,</span>
    <span>0xAA</span><span>,</span> <span>0xAC</span><span>,</span> <span>0xAD</span><span>,</span> <span>0xAE</span><span>,</span> <span>0xB0</span><span>,</span> <span>0xB1</span><span>,</span> <span>0xB4</span><span>,</span> <span>0xB5</span><span>,</span> <span>0xB6</span><span>,</span> <span>0xB8</span><span>,</span> <span>0xB9</span><span>,</span> <span>0xBA</span><span>,</span> <span>0xBC</span><span>,</span> <span>0xBD</span><span>,</span>
    <span>0xBE</span><span>,</span> <span>0xC0</span><span>,</span> <span>0xC1</span><span>,</span> <span>0xC4</span><span>,</span> <span>0xC5</span><span>,</span> <span>0xC6</span><span>,</span> <span>0xC8</span><span>,</span> <span>0xC9</span><span>,</span> <span>0xCA</span><span>,</span> <span>0xCC</span><span>,</span> <span>0xCD</span><span>,</span> <span>0xCE</span><span>,</span> <span>0xD0</span><span>,</span> <span>0xD1</span><span>,</span>
    <span>0xD5</span><span>,</span> <span>0xD6</span><span>,</span> <span>0xD8</span><span>,</span> <span>0xD9</span><span>,</span> <span>0xDD</span><span>,</span> <span>0xDE</span><span>,</span> <span>0xE0</span><span>,</span> <span>0xE1</span><span>,</span> <span>0xE4</span><span>,</span> <span>0xE5</span><span>,</span> <span>0xE6</span><span>,</span> <span>0xE8</span><span>,</span> <span>0xE9</span><span>,</span> <span>0xEA</span><span>,</span>
    <span>0xEC</span><span>,</span> <span>0xED</span><span>,</span> <span>0xEE</span><span>,</span> <span>0xF0</span><span>,</span> <span>0xF1</span><span>,</span> <span>0xF5</span><span>,</span> <span>0xF6</span><span>,</span> <span>0xF8</span><span>,</span> <span>0xF9</span><span>,</span> <span>0xFD</span><span>,</span> <span>0xFE</span>
<span>],</span> <span>dtype</span><span>=</span><span>np</span><span>.</span><span>uint8</span><span>)</span>

<span># Control flow opcodes
</span><span>BRANCH_OPCODES</span> <span>=</span> <span>np</span><span>.</span><span>array</span><span>([</span><span>0x10</span><span>,</span> <span>0x30</span><span>,</span> <span>0x50</span><span>,</span> <span>0x70</span><span>,</span> <span>0x90</span><span>,</span> <span>0xB0</span><span>,</span> <span>0xD0</span><span>,</span> <span>0xF0</span><span>],</span> <span>dtype</span><span>=</span><span>np</span><span>.</span><span>uint8</span><span>)</span>
<span>JUMP_OPCODES</span> <span>=</span> <span>np</span><span>.</span><span>array</span><span>([</span><span>0x4C</span><span>,</span> <span>0x6C</span><span>,</span> <span>0x20</span><span>],</span> <span>dtype</span><span>=</span><span>np</span><span>.</span><span>uint8</span><span>)</span>

<span>def</span> <span>create_lookup_tables</span><span>():</span>
    <span>&#34;&#34;&#34;Create GPU lookup tables for ROM analysis&#34;&#34;&#34;</span>
    <span>valid_lut</span> <span>=</span> <span>cp</span><span>.</span><span>zeros</span><span>(</span><span>256</span><span>,</span> <span>dtype</span><span>=</span><span>cp</span><span>.</span><span>bool_</span><span>)</span>
    <span>valid_lut</span><span>[</span><span>VALID_OPCODES</span><span>]</span> <span>=</span> <span>True</span>
    
    <span>branch_lut</span> <span>=</span> <span>cp</span><span>.</span><span>zeros</span><span>(</span><span>256</span><span>,</span> <span>dtype</span><span>=</span><span>cp</span><span>.</span><span>bool_</span><span>)</span>
    <span>branch_lut</span><span>[</span><span>BRANCH_OPCODES</span><span>]</span> <span>=</span> <span>True</span>
    
    <span>jump_lut</span> <span>=</span> <span>cp</span><span>.</span><span>zeros</span><span>(</span><span>256</span><span>,</span> <span>dtype</span><span>=</span><span>cp</span><span>.</span><span>bool_</span><span>)</span>
    <span>jump_lut</span><span>[</span><span>JUMP_OPCODES</span><span>]</span> <span>=</span> <span>True</span>
    
    <span># TIA instruction lookups
</span>    <span>tia_store_lut</span> <span>=</span> <span>cp</span><span>.</span><span>zeros</span><span>(</span><span>256</span><span>,</span> <span>dtype</span><span>=</span><span>cp</span><span>.</span><span>bool_</span><span>)</span>
    <span>tia_store_lut</span><span>[[</span><span>0x85</span><span>,</span> <span>0x86</span><span>,</span> <span>0x84</span><span>,</span> <span>0x95</span><span>,</span> <span>0x96</span><span>,</span> <span>0x94</span><span>]]</span> <span>=</span> <span>True</span>
    
    <span>tia_load_lut</span> <span>=</span> <span>cp</span><span>.</span><span>zeros</span><span>(</span><span>256</span><span>,</span> <span>dtype</span><span>=</span><span>cp</span><span>.</span><span>bool_</span><span>)</span>
    <span>tia_load_lut</span><span>[[</span><span>0xA5</span><span>,</span> <span>0xA6</span><span>,</span> <span>0xA4</span><span>,</span> <span>0xB5</span><span>,</span> <span>0xB6</span><span>,</span> <span>0xB4</span><span>]]</span> <span>=</span> <span>True</span>
    
    <span>tia_abs_lut</span> <span>=</span> <span>cp</span><span>.</span><span>zeros</span><span>(</span><span>256</span><span>,</span> <span>dtype</span><span>=</span><span>cp</span><span>.</span><span>bool_</span><span>)</span>
    <span>tia_abs_lut</span><span>[[</span><span>0x8D</span><span>,</span> <span>0x8E</span><span>,</span> <span>0x8C</span><span>,</span> <span>0xAD</span><span>,</span> <span>0xAE</span><span>,</span> <span>0xAC</span><span>]]</span> <span>=</span> <span>True</span>
    
    <span># RIOT instruction lookups
</span>    <span>riot_access_lut</span> <span>=</span> <span>cp</span><span>.</span><span>zeros</span><span>(</span><span>256</span><span>,</span> <span>dtype</span><span>=</span><span>cp</span><span>.</span><span>bool_</span><span>)</span>
    <span>riot_access_lut</span><span>[[</span><span>0x85</span><span>,</span> <span>0x86</span><span>,</span> <span>0x84</span><span>,</span> <span>0xA5</span><span>,</span> <span>0xA6</span><span>,</span> <span>0xA4</span><span>]]</span> <span>=</span> <span>True</span>
    
    <span># Address range masks
</span>    <span>tia_range_mask</span> <span>=</span> <span>cp</span><span>.</span><span>arange</span><span>(</span><span>256</span><span>,</span> <span>dtype</span><span>=</span><span>cp</span><span>.</span><span>uint8</span><span>)</span> <span>&lt;=</span> <span>0x2F</span>
    <span>riot_timer_mask</span> <span>=</span> <span>(</span><span>cp</span><span>.</span><span>arange</span><span>(</span><span>256</span><span>,</span> <span>dtype</span><span>=</span><span>cp</span><span>.</span><span>uint8</span><span>)</span> <span>&gt;=</span> <span>0x80</span><span>)</span> <span>&amp;</span> <span>(</span><span>cp</span><span>.</span><span>arange</span><span>(</span><span>256</span><span>,</span> <span>dtype</span><span>=</span><span>cp</span><span>.</span><span>uint8</span><span>)</span> <span>&lt;=</span> <span>0x87</span><span>)</span>
    <span>riot_io_mask</span> <span>=</span> <span>(</span><span>cp</span><span>.</span><span>arange</span><span>(</span><span>256</span><span>,</span> <span>dtype</span><span>=</span><span>cp</span><span>.</span><span>uint8</span><span>)</span> <span>&gt;=</span> <span>0x94</span><span>)</span> <span>&amp;</span> <span>(</span><span>cp</span><span>.</span><span>arange</span><span>(</span><span>256</span><span>,</span> <span>dtype</span><span>=</span><span>cp</span><span>.</span><span>uint8</span><span>)</span> <span>&lt;=</span> <span>0x97</span><span>)</span>
    
    <span>return</span> <span>{</span>
        <span>&#39;valid&#39;</span><span>:</span> <span>valid_lut</span><span>,</span>
        <span>&#39;branch&#39;</span><span>:</span> <span>branch_lut</span><span>,</span>
        <span>&#39;jump&#39;</span><span>:</span> <span>jump_lut</span><span>,</span>
        <span>&#39;tia_store&#39;</span><span>:</span> <span>tia_store_lut</span><span>,</span>
        <span>&#39;tia_load&#39;</span><span>:</span> <span>tia_load_lut</span><span>,</span>
        <span>&#39;tia_abs&#39;</span><span>:</span> <span>tia_abs_lut</span><span>,</span>
        <span>&#39;riot_access&#39;</span><span>:</span> <span>riot_access_lut</span><span>,</span>
        <span>&#39;tia_range&#39;</span><span>:</span> <span>tia_range_mask</span><span>,</span>
        <span>&#39;riot_timer&#39;</span><span>:</span> <span>riot_timer_mask</span><span>,</span>
        <span>&#39;riot_io&#39;</span><span>:</span> <span>riot_io_mask</span>
    <span>}</span>

<span>def</span> <span>analyze_roms</span><span>(</span><span>roms</span><span>,</span> <span>lut</span><span>):</span>
    <span>&#34;&#34;&#34;Analyze ROMs for game-like patterns&#34;&#34;&#34;</span>
    <span>batch_size</span> <span>=</span> <span>roms</span><span>.</span><span>shape</span><span>[</span><span>0</span><span>]</span>
    
    <span># Opcode analysis
</span>    <span>valid_opcodes_count</span> <span>=</span> <span>cp</span><span>.</span><span>sum</span><span>(</span><span>lut</span><span>[</span><span>&#39;valid&#39;</span><span>][</span><span>roms</span><span>],</span> <span>axis</span><span>=</span><span>1</span><span>)</span>
    <span>opcode_ratio</span> <span>=</span> <span>valid_opcodes_count</span><span>.</span><span>astype</span><span>(</span><span>cp</span><span>.</span><span>float32</span><span>)</span> <span>/</span> <span>ROM_SIZE</span>
    
    <span># Control flow analysis
</span>    <span>branch_count</span> <span>=</span> <span>cp</span><span>.</span><span>sum</span><span>(</span><span>lut</span><span>[</span><span>&#39;branch&#39;</span><span>][</span><span>roms</span><span>],</span> <span>axis</span><span>=</span><span>1</span><span>)</span>
    <span>jump_count</span> <span>=</span> <span>cp</span><span>.</span><span>sum</span><span>(</span><span>lut</span><span>[</span><span>&#39;jump&#39;</span><span>][</span><span>roms</span><span>],</span> <span>axis</span><span>=</span><span>1</span><span>)</span>
    
    <span># TIA analysis
</span>    <span>tia_accesses</span> <span>=</span> <span>cp</span><span>.</span><span>zeros</span><span>(</span><span>batch_size</span><span>,</span> <span>dtype</span><span>=</span><span>cp</span><span>.</span><span>int32</span><span>)</span>
    
    <span># Zero page addressing
</span>    <span>tia_store_zp</span> <span>=</span> <span>lut</span><span>[</span><span>&#39;tia_store&#39;</span><span>][</span><span>roms</span><span>[:,</span> <span>:</span><span>-</span><span>1</span><span>]]</span> <span>&amp;</span> <span>lut</span><span>[</span><span>&#39;tia_range&#39;</span><span>][</span><span>roms</span><span>[:,</span> <span>1</span><span>:]]</span>
    <span>tia_load_zp</span> <span>=</span> <span>lut</span><span>[</span><span>&#39;tia_load&#39;</span><span>][</span><span>roms</span><span>[:,</span> <span>:</span><span>-</span><span>1</span><span>]]</span> <span>&amp;</span> <span>lut</span><span>[</span><span>&#39;tia_range&#39;</span><span>][</span><span>roms</span><span>[:,</span> <span>1</span><span>:]]</span>
    <span>tia_zp_total</span> <span>=</span> <span>cp</span><span>.</span><span>sum</span><span>(</span><span>tia_store_zp</span> <span>|</span> <span>tia_load_zp</span><span>,</span> <span>axis</span><span>=</span><span>1</span><span>)</span>
    <span>tia_accesses</span> <span>+=</span> <span>tia_zp_total</span>
    
    <span># Absolute addressing
</span>    <span>tia_abs_positions</span> <span>=</span> <span>lut</span><span>[</span><span>&#39;tia_abs&#39;</span><span>][</span><span>roms</span><span>[:,</span> <span>:</span><span>-</span><span>2</span><span>]]</span>
    <span>tia_abs_targets</span> <span>=</span> <span>lut</span><span>[</span><span>&#39;tia_range&#39;</span><span>][</span><span>roms</span><span>[:,</span> <span>1</span><span>:</span><span>-</span><span>1</span><span>]]</span> <span>&amp;</span> <span>(</span><span>roms</span><span>[:,</span> <span>2</span><span>:]</span> <span>==</span> <span>0x00</span><span>)</span>
    <span>tia_abs_total</span> <span>=</span> <span>cp</span><span>.</span><span>sum</span><span>(</span><span>tia_abs_positions</span> <span>&amp;</span> <span>tia_abs_targets</span><span>,</span> <span>axis</span><span>=</span><span>1</span><span>)</span>
    <span>tia_accesses</span> <span>+=</span> <span>tia_abs_total</span>
    
    <span># RIOT analysis
</span>    <span>riot_accesses</span> <span>=</span> <span>cp</span><span>.</span><span>zeros</span><span>(</span><span>batch_size</span><span>,</span> <span>dtype</span><span>=</span><span>cp</span><span>.</span><span>int32</span><span>)</span>
    
    <span># Timer access
</span>    <span>riot_timer_positions</span> <span>=</span> <span>lut</span><span>[</span><span>&#39;riot_access&#39;</span><span>][</span><span>roms</span><span>[:,</span> <span>:</span><span>-</span><span>1</span><span>]]</span>
    <span>riot_timer_targets</span> <span>=</span> <span>lut</span><span>[</span><span>&#39;riot_timer&#39;</span><span>][</span><span>roms</span><span>[:,</span> <span>1</span><span>:]]</span>
    <span>riot_timer_hits</span> <span>=</span> <span>cp</span><span>.</span><span>sum</span><span>(</span><span>riot_timer_positions</span> <span>&amp;</span> <span>riot_timer_targets</span><span>,</span> <span>axis</span><span>=</span><span>1</span><span>)</span>
    <span>riot_accesses</span> <span>+=</span> <span>riot_timer_hits</span>
    
    <span># I/O access
</span>    <span>riot_io_positions</span> <span>=</span> <span>lut</span><span>[</span><span>&#39;riot_access&#39;</span><span>][</span><span>roms</span><span>[:,</span> <span>:</span><span>-</span><span>1</span><span>]]</span>
    <span>riot_io_targets</span> <span>=</span> <span>lut</span><span>[</span><span>&#39;riot_io&#39;</span><span>][</span><span>roms</span><span>[:,</span> <span>1</span><span>:]]</span>
    <span>riot_io_hits</span> <span>=</span> <span>cp</span><span>.</span><span>sum</span><span>(</span><span>riot_io_positions</span> <span>&amp;</span> <span>riot_io_targets</span><span>,</span> <span>axis</span><span>=</span><span>1</span><span>)</span>
    <span>riot_accesses</span> <span>+=</span> <span>riot_io_hits</span>
    
    <span># Unique opcode counting in first 1KB (code section)
</span>    <span>unique_opcodes</span> <span>=</span> <span>cp</span><span>.</span><span>zeros</span><span>(</span><span>batch_size</span><span>,</span> <span>dtype</span><span>=</span><span>cp</span><span>.</span><span>int32</span><span>)</span>
    <span>first_kb</span> <span>=</span> <span>roms</span><span>[:,</span> <span>:</span><span>1024</span><span>]</span>  <span># First 1KB where code typically resides
</span>    
    <span># Count unique valid opcodes in the code section
</span>    <span>for</span> <span>opcode</span> <span>in</span> <span>VALID_OPCODES</span><span>:</span>
        <span>has_opcode</span> <span>=</span> <span>cp</span><span>.</span><span>any</span><span>(</span><span>first_kb</span> <span>==</span> <span>opcode</span><span>,</span> <span>axis</span><span>=</span><span>1</span><span>)</span>
        <span>unique_opcodes</span> <span>+=</span> <span>has_opcode</span><span>.</span><span>astype</span><span>(</span><span>cp</span><span>.</span><span>int32</span><span>)</span>
    
    <span># Composite score
</span>    <span>scores</span> <span>=</span> <span>(</span>
        <span>opcode_ratio</span> <span>*</span> <span>0.25</span> <span>+</span> 
        <span>cp</span><span>.</span><span>minimum</span><span>(</span><span>tia_accesses</span> <span>/</span> <span>150.0</span><span>,</span> <span>1.0</span><span>)</span> <span>*</span> <span>0.30</span> <span>+</span>
        <span>cp</span><span>.</span><span>minimum</span><span>(</span><span>riot_accesses</span> <span>/</span> <span>50.0</span><span>,</span> <span>1.0</span><span>)</span> <span>*</span> <span>0.20</span> <span>+</span>
        <span>cp</span><span>.</span><span>minimum</span><span>(</span><span>branch_count</span> <span>/</span> <span>200.0</span><span>,</span> <span>1.0</span><span>)</span> <span>*</span> <span>0.15</span> <span>+</span>
        <span>cp</span><span>.</span><span>minimum</span><span>(</span><span>jump_count</span> <span>/</span> <span>40.0</span><span>,</span> <span>1.0</span><span>)</span> <span>*</span> <span>0.10</span>
    <span>)</span>
    
    <span># Promising ROM detection
</span>    <span>promising</span> <span>=</span> <span>(</span>
        <span>(</span><span>opcode_ratio</span> <span>&gt;=</span> <span>OPCODE_THRESHOLD</span><span>)</span> <span>&amp;</span>
        <span>(</span><span>tia_accesses</span> <span>&gt;=</span> <span>TIA_THRESHOLD</span><span>)</span> <span>&amp;</span>
        <span>(</span><span>riot_accesses</span> <span>&gt;=</span> <span>RIOT_THRESHOLD</span><span>)</span> <span>&amp;</span>
        <span>(</span><span>branch_count</span> <span>&gt;=</span> <span>BRANCH_THRESHOLD</span><span>)</span> <span>&amp;</span>
        <span>(</span><span>jump_count</span> <span>&gt;=</span> <span>JUMP_THRESHOLD</span><span>)</span> <span>&amp;</span>
        <span>(</span><span>unique_opcodes</span> <span>&gt;=</span> <span>INSTRUCTION_VARIETY</span><span>)</span> <span>&amp;</span>
        <span>(</span><span>scores</span> <span>&gt;=</span> <span>MIN_SCORE</span><span>)</span>
    <span>)</span>
    
    <span>return</span> <span>{</span>
        <span>&#39;scores&#39;</span><span>:</span> <span>scores</span><span>,</span>
        <span>&#39;opcode_ratio&#39;</span><span>:</span> <span>opcode_ratio</span><span>,</span>
        <span>&#39;tia_accesses&#39;</span><span>:</span> <span>tia_accesses</span><span>,</span>
        <span>&#39;riot_accesses&#39;</span><span>:</span> <span>riot_accesses</span><span>,</span>
        <span>&#39;branch_count&#39;</span><span>:</span> <span>branch_count</span><span>,</span>
        <span>&#39;jump_count&#39;</span><span>:</span> <span>jump_count</span><span>,</span>
        <span>&#39;unique_opcodes&#39;</span><span>:</span> <span>unique_opcodes</span><span>,</span>
        <span>&#39;promising&#39;</span><span>:</span> <span>promising</span>
    <span>}</span>

<span>def</span> <span>save_promising_rom</span><span>(</span><span>rom_data</span><span>,</span> <span>score</span><span>,</span> <span>rom_id</span><span>,</span> <span>output_dir</span><span>):</span>
    <span>&#34;&#34;&#34;Save promising ROM with: number_score_timestamp.bin&#34;&#34;&#34;</span>
    <span>timestamp</span> <span>=</span> <span>int</span><span>(</span><span>time</span><span>.</span><span>time</span><span>())</span>
    <span>filename</span> <span>=</span> <span>f</span><span>&#34;</span><span>{</span><span>rom_id</span><span>:</span><span>06</span><span>d</span><span>}</span><span>_</span><span>{</span><span>score</span><span>:</span><span>.</span><span>3</span><span>f</span><span>}</span><span>_</span><span>{</span><span>timestamp</span><span>}</span><span>.bin&#34;</span>
    <span>filepath</span> <span>=</span> <span>output_dir</span> <span>/</span> <span>filename</span>
    
    <span>with</span> <span>open</span><span>(</span><span>filepath</span><span>,</span> <span>&#39;wb&#39;</span><span>)</span> <span>as</span> <span>f</span><span>:</span>
        <span>f</span><span>.</span><span>write</span><span>(</span><span>rom_data</span><span>.</span><span>tobytes</span><span>())</span>
    
    <span>return</span> <span>filename</span>

<span>def</span> <span>main</span><span>():</span>
    <span>print</span><span>(</span><span>&#34;Finite Atari Machine - Streamlined CUDA Generator&#34;</span><span>)</span>
    <span>print</span><span>(</span><span>&#34;=&#34;</span> <span>*</span> <span>60</span><span>)</span>
    <span>print</span><span>(</span><span>f</span><span>&#34;Batch size: </span><span>{</span><span>BATCH_SIZE</span><span>:</span><span>,</span><span>}</span><span> ROMs per batch&#34;</span><span>)</span>
    <span>print</span><span>(</span><span>f</span><span>&#34;ROM size: </span><span>{</span><span>ROM_SIZE</span><span>:</span><span>,</span><span>}</span><span> bytes&#34;</span><span>)</span>
    <span>print</span><span>()</span>
    <span>print</span><span>(</span><span>&#34;Thresholds:&#34;</span><span>)</span>
    <span>print</span><span>(</span><span>f</span><span>&#34;  Opcodes: </span><span>{</span><span>OPCODE_THRESHOLD</span><span>:</span><span>.</span><span>1</span><span>%</span><span>}</span><span>&#34;</span><span>)</span>
    <span>print</span><span>(</span><span>f</span><span>&#34;  TIA: </span><span>{</span><span>TIA_THRESHOLD</span><span>}</span><span>+&#34;</span><span>)</span>
    <span>print</span><span>(</span><span>f</span><span>&#34;  RIOT: </span><span>{</span><span>RIOT_THRESHOLD</span><span>}</span><span>+&#34;</span><span>)</span>
    <span>print</span><span>(</span><span>f</span><span>&#34;  Branches: </span><span>{</span><span>BRANCH_THRESHOLD</span><span>}</span><span>+&#34;</span><span>)</span>
    <span>print</span><span>(</span><span>f</span><span>&#34;  Jumps: </span><span>{</span><span>JUMP_THRESHOLD</span><span>}</span><span>+&#34;</span><span>)</span>
    <span>print</span><span>(</span><span>f</span><span>&#34;  Unique opcodes: </span><span>{</span><span>INSTRUCTION_VARIETY</span><span>}</span><span>+&#34;</span><span>)</span>
    <span>print</span><span>(</span><span>f</span><span>&#34;  Min score: </span><span>{</span><span>MIN_SCORE</span><span>:</span><span>.</span><span>2</span><span>f</span><span>}</span><span>&#34;</span><span>)</span>
    <span>print</span><span>()</span>
    
    <span># GPU info
</span>    <span>try</span><span>:</span>
        <span>gpu_props</span> <span>=</span> <span>cp</span><span>.</span><span>cuda</span><span>.</span><span>runtime</span><span>.</span><span>getDeviceProperties</span><span>(</span><span>0</span><span>)</span>
        <span>gpu_name</span> <span>=</span> <span>gpu_props</span><span>[</span><span>&#39;name&#39;</span><span>].</span><span>decode</span><span>()</span>
        <span>total_mem</span> <span>=</span> <span>cp</span><span>.</span><span>cuda</span><span>.</span><span>runtime</span><span>.</span><span>memGetInfo</span><span>()[</span><span>1</span><span>]</span> <span>//</span> <span>1024</span><span>**</span><span>2</span>
        <span>print</span><span>(</span><span>f</span><span>&#34;GPU: </span><span>{</span><span>gpu_name</span><span>}</span><span>&#34;</span><span>)</span>
        <span>print</span><span>(</span><span>f</span><span>&#34;Memory: </span><span>{</span><span>total_mem</span><span>:</span><span>,</span><span>}</span><span> MB&#34;</span><span>)</span>
    <span>except</span> <span>Exception</span><span>:</span>
        <span>print</span><span>(</span><span>&#34;GPU: CuPy device detected&#34;</span><span>)</span>
    
    <span>print</span><span>(</span><span>&#34;</span><span>\n</span><span>Initializing lookup tables...&#34;</span><span>)</span>
    
    <span># Setup
</span>    <span>output_dir</span> <span>=</span> <span>Path</span><span>(</span><span>&#34;finite_atari_roms&#34;</span><span>)</span>
    <span>output_dir</span><span>.</span><span>mkdir</span><span>(</span><span>exist_ok</span><span>=</span><span>True</span><span>)</span>
    
    <span>lookup_tables</span> <span>=</span> <span>create_lookup_tables</span><span>()</span>
    
    <span># Statistics
</span>    <span>total_generated</span> <span>=</span> <span>0</span>
    <span>promising_found</span> <span>=</span> <span>0</span>
    <span>start_time</span> <span>=</span> <span>time</span><span>.</span><span>time</span><span>()</span>
    <span>last_report</span> <span>=</span> <span>start_time</span>
    <span>best_score_ever</span> <span>=</span> <span>0.0</span>
    
    <span>print</span><span>(</span><span>&#34;Starting ROM generation...&#34;</span><span>)</span>
    <span>print</span><span>(</span><span>&#34;=&#34;</span> <span>*</span> <span>60</span><span>)</span>
    
    <span>try</span><span>:</span>
        <span>while</span> <span>True</span><span>:</span>
            <span>batch_start</span> <span>=</span> <span>time</span><span>.</span><span>time</span><span>()</span>
            
            <span># Generate batch of ROMs
</span>            <span>roms</span> <span>=</span> <span>cp</span><span>.</span><span>random</span><span>.</span><span>randint</span><span>(</span><span>0</span><span>,</span> <span>256</span><span>,</span> <span>size</span><span>=</span><span>(</span><span>BATCH_SIZE</span><span>,</span> <span>ROM_SIZE</span><span>),</span> <span>dtype</span><span>=</span><span>cp</span><span>.</span><span>uint8</span><span>)</span>
            
            <span># Analyze ROMs
</span>            <span>analysis</span> <span>=</span> <span>analyze_roms</span><span>(</span><span>roms</span><span>,</span> <span>lookup_tables</span><span>)</span>
            
            <span># Track best score
</span>            <span>current_best</span> <span>=</span> <span>float</span><span>(</span><span>cp</span><span>.</span><span>max</span><span>(</span><span>analysis</span><span>[</span><span>&#39;scores&#39;</span><span>]))</span>
            <span>if</span> <span>current_best</span> <span>&gt;</span> <span>best_score_ever</span><span>:</span>
                <span>best_score_ever</span> <span>=</span> <span>current_best</span>
            
            <span># Check for promising ROMs
</span>            <span>promising_indices</span> <span>=</span> <span>cp</span><span>.</span><span>where</span><span>(</span><span>analysis</span><span>[</span><span>&#39;promising&#39;</span><span>])[</span><span>0</span><span>]</span>
            
            <span>if</span> <span>len</span><span>(</span><span>promising_indices</span><span>)</span> <span>&gt;</span> <span>0</span><span>:</span>
                <span># Save promising ROMs
</span>                <span>promising_roms</span> <span>=</span> <span>cp</span><span>.</span><span>asnumpy</span><span>(</span><span>roms</span><span>[</span><span>promising_indices</span><span>])</span>
                <span>promising_scores</span> <span>=</span> <span>cp</span><span>.</span><span>asnumpy</span><span>(</span><span>analysis</span><span>[</span><span>&#39;scores&#39;</span><span>][</span><span>promising_indices</span><span>])</span>
                
                <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>len</span><span>(</span><span>promising_indices</span><span>)):</span>
                    <span>filename</span> <span>=</span> <span>save_promising_rom</span><span>(</span>
                        <span>promising_roms</span><span>[</span><span>i</span><span>],</span> <span>promising_scores</span><span>[</span><span>i</span><span>],</span> <span>promising_found</span><span>,</span> <span>output_dir</span>
                    <span>)</span>
                    <span>promising_found</span> <span>+=</span> <span>1</span>
            
            <span>total_generated</span> <span>+=</span> <span>BATCH_SIZE</span>
            <span>batch_time</span> <span>=</span> <span>time</span><span>.</span><span>time</span><span>()</span> <span>-</span> <span>batch_start</span>
            
            <span># Progress reporting
</span>            <span>current_time</span> <span>=</span> <span>time</span><span>.</span><span>time</span><span>()</span>
            <span>if</span> <span>current_time</span> <span>-</span> <span>last_report</span> <span>&gt;=</span> <span>4</span><span>:</span>
                <span># Get best ROM stats for this batch
</span>                <span>scores</span> <span>=</span> <span>cp</span><span>.</span><span>asnumpy</span><span>(</span><span>analysis</span><span>[</span><span>&#39;scores&#39;</span><span>])</span>
                <span>best_idx</span> <span>=</span> <span>np</span><span>.</span><span>argmax</span><span>(</span><span>scores</span><span>)</span>
                <span>best_opcodes</span> <span>=</span> <span>float</span><span>(</span><span>analysis</span><span>[</span><span>&#39;opcode_ratio&#39;</span><span>][</span><span>best_idx</span><span>])</span>
                <span>best_tia</span> <span>=</span> <span>int</span><span>(</span><span>analysis</span><span>[</span><span>&#39;tia_accesses&#39;</span><span>][</span><span>best_idx</span><span>])</span>
                <span>best_riot</span> <span>=</span> <span>int</span><span>(</span><span>analysis</span><span>[</span><span>&#39;riot_accesses&#39;</span><span>][</span><span>best_idx</span><span>])</span>
                <span>best_branches</span> <span>=</span> <span>int</span><span>(</span><span>analysis</span><span>[</span><span>&#39;branch_count&#39;</span><span>][</span><span>best_idx</span><span>])</span>
                <span>best_jumps</span> <span>=</span> <span>int</span><span>(</span><span>analysis</span><span>[</span><span>&#39;jump_count&#39;</span><span>][</span><span>best_idx</span><span>])</span>
                
                <span>elapsed</span> <span>=</span> <span>current_time</span> <span>-</span> <span>start_time</span>
                <span>rate</span> <span>=</span> <span>total_generated</span> <span>/</span> <span>elapsed</span>
                <span>success_rate</span> <span>=</span> <span>promising_found</span> <span>/</span> <span>total_generated</span> <span>*</span> <span>100</span> <span>if</span> <span>total_generated</span> <span>&gt;</span> <span>0</span> <span>else</span> <span>0</span>
                
                <span>print</span><span>(</span><span>f</span><span>&#34;</span><span>\r</span><span>Generated: </span><span>{</span><span>total_generated</span><span>:</span><span>,</span><span>}</span><span> | Found: </span><span>{</span><span>promising_found</span><span>}</span><span> | &#34;</span>
                      <span>f</span><span>&#34;Success: </span><span>{</span><span>success_rate</span><span>:</span><span>.</span><span>8</span><span>f</span><span>}</span><span>% | Rate: </span><span>{</span><span>rate</span><span>:</span><span>,.</span><span>0</span><span>f</span><span>}</span><span>/sec | &#34;</span>
                      <span>f</span><span>&#34;Best: </span><span>{</span><span>best_score_ever</span><span>:</span><span>.</span><span>3</span><span>f</span><span>}</span><span> | &#34;</span>
                      <span>f</span><span>&#34;Op:</span><span>{</span><span>best_opcodes</span><span>:</span><span>.</span><span>1</span><span>%</span><span>}</span><span> TIA:</span><span>{</span><span>best_tia</span><span>}</span><span> RIOT:</span><span>{</span><span>best_riot</span><span>}</span><span> Br:</span><span>{</span><span>best_branches</span><span>}</span><span> Jmp:</span><span>{</span><span>best_jumps</span><span>}</span><span>&#34;</span><span>,</span> 
                      <span>end</span><span>=</span><span>&#34;&#34;</span><span>,</span> <span>flush</span><span>=</span><span>True</span><span>)</span>
                
                <span>last_report</span> <span>=</span> <span>current_time</span>
    
    <span>except</span> <span>KeyboardInterrupt</span><span>:</span>
        <span>elapsed</span> <span>=</span> <span>time</span><span>.</span><span>time</span><span>()</span> <span>-</span> <span>start_time</span>
        <span>rate</span> <span>=</span> <span>total_generated</span> <span>/</span> <span>elapsed</span>
        <span>success_rate</span> <span>=</span> <span>promising_found</span> <span>/</span> <span>total_generated</span> <span>*</span> <span>100</span> <span>if</span> <span>total_generated</span> <span>&gt;</span> <span>0</span> <span>else</span> <span>0</span>
        
        <span>print</span><span>(</span><span>f</span><span>&#34;</span><span>\n\n</span><span>Stopped after </span><span>{</span><span>elapsed</span><span>:</span><span>.</span><span>1</span><span>f</span><span>}</span><span> seconds&#34;</span><span>)</span>
        <span>print</span><span>(</span><span>f</span><span>&#34;Total ROMs generated: </span><span>{</span><span>total_generated</span><span>:</span><span>,</span><span>}</span><span>&#34;</span><span>)</span>
        <span>print</span><span>(</span><span>f</span><span>&#34;Promising ROMs found: </span><span>{</span><span>promising_found</span><span>}</span><span>&#34;</span><span>)</span>
        <span>print</span><span>(</span><span>f</span><span>&#34;Success rate: </span><span>{</span><span>success_rate</span><span>:</span><span>.</span><span>8</span><span>f</span><span>}</span><span>%&#34;</span><span>)</span>
        <span>print</span><span>(</span><span>f</span><span>&#34;Average rate: </span><span>{</span><span>rate</span><span>:</span><span>,.</span><span>0</span><span>f</span><span>}</span><span> ROMs/second&#34;</span><span>)</span>
        <span>print</span><span>(</span><span>f</span><span>&#34;Best score achieved: </span><span>{</span><span>best_score_ever</span><span>:</span><span>.</span><span>4</span><span>f</span><span>}</span><span>&#34;</span><span>)</span>
        <span>print</span><span>(</span><span>f</span><span>&#34;Results saved in: </span><span>{</span><span>output_dir</span><span>}</span><span>&#34;</span><span>)</span>

<span>if</span> <span>__name__</span> <span>==</span> <span>&#34;__main__&#34;</span><span>:</span>
    <span>main</span><span>()</span>

</code></pre></div></div>

<p>…Which gave me a whopping 60,000 ‘random’ ROMs checked per second. With the heuristics, I was finding one ‘promising’ ROM for every 2.59 million ROMs generated. It’s one ROM every few minutes.</p>

<h2 id="first-results-and-why-machine-learning-didnt-work">First Results And Why Machine Learning Didn’t Work</h2>

<p>After checking <em>billions and billions</em> of potential ROMs, I had a collection of about 10,000 that passed the heuristics laid out above. I could move onto the next step: checking them all in an emulator.</p>

<p>I tried two methods of running these 10,000 ROMs in an emulator to see if there was anything ‘game-like’. The first was a classifier, trained on ~1,500 real commercial Atari ROMs (positives) and ~1,500 GPU-generated random ROMs (negatives). These trained a model (Random Forest) with features ranging from “Would the emulator execute the ROM”, to more pertinate features such as, “how many times did the registers of the TIA change during 2 seconds of execution time.”</p>

<p>This is, academically, the correct way to do this. By scripting in output from <a href="https://stella-emu.github.io/">Stella</a>, and <a href="https://www.mamedev.org/">MAME</a>, I was able to build a classifier that would tell me if a random ROM <em>could</em> run on an Atari. Unfortunately, it didn’t work. The top-scoring results were mostly all black screens when run on an emulator. This made sense when I looked at the model. The most important features were:</p>

<table>
  <thead>
    <tr>
      <th>Feature</th>
      <th>Value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>execution_time</td>
      <td>0.9847</td>
    </tr>
    <tr>
      <td>output_lines</td>
      <td>0.0086</td>
    </tr>
    <tr>
      <td>stdout_length</td>
      <td>0.0067</td>
    </tr>
    <tr>
      <td>crashed</td>
      <td>0.0000</td>
    </tr>
    <tr>
      <td>stderr_length</td>
      <td>0.0000</td>
    </tr>
    <tr>
      <td>video_indicators</td>
      <td>0.0000</td>
    </tr>
    <tr>
      <td>audio_indicators</td>
      <td>0.0000</td>
    </tr>
    <tr>
      <td>tia_activity</td>
      <td>0.0000</td>
    </tr>
    <tr>
      <td>game_indicators</td>
      <td>0.0000</td>
    </tr>
    <tr>
      <td>error_indicators</td>
      <td>0.0000</td>
    </tr>
  </tbody>
</table>

<p>It was obvious what was happening: I was only selecting for ROMs that <em>ran</em>, not ROMs that <em>did anything interesting</em>. A quick check showed they were just booting into an infinite loop; After booting, there would be a few instructions that did nothing until eventually jumping back to somewhere around the reset vector. In fact, this <em>should</em> be frequently found. Consider the simplest possible Atari program:</p>

<pre><code>
; Program starts at $F000

F000: 4C 00 F0   ; JMP $F000 — forever doing nothing
</code></pre>

<p>This code starts running at F000, and jumps immediately to that same address. The odds of generating this code are $\frac{1}{256} \times \frac{1}{256} \times \frac{1}{256} = \frac{1}{16,777,216}$. In other words, for every 16 Million ROMs I generate, I will have one that is a valid ROM that does absolutely nothing. I probably generated this ROM several times while generating 30 Billion ROMs. I just don’t care about a program that does nothing.</p>

<p>In short, a classifier on the actual machine code was worthless. Or my training data was. But then again, there’s no training set for Atari games that almost work — just masterpieces and garbage.</p>

<h2 id="second-results-finding-anything-interesting">Second Results, Finding Anything Interesting</h2>

<p>Realizing I only want one thing - interesting visual output - I rewrote the generation pipeline to find interesting ROMs and immediately send them to an emulator to find interesting candidates.</p>

<div><div><pre><code><span># ==========================================================================
#
#   Finite Atari unified pipeline (4 KB, reset @ $F000) - FIXED VERSION
#
#   This script generates random Atari 2600 ROMs in the GPU via CUDA,
#   Filters them on-GPU with a heuristic, and if interesting, boots
#   them in head-less MAME for 2 s to check if they have dynamic video.
#
#   It is designed to run on a CUDA-capable GPU with MAME installed in PATH.
#
#   The output is saved in the &#34;finite_atari_roms&#34; directory.
#
# ===========================================================================
</span>
<span>from</span> <span>__future__</span> <span>import</span> <span>annotations</span>
<span>import</span> <span>cupy</span> <span>as</span> <span>cp</span><span>,</span> <span>numpy</span> <span>as</span> <span>np</span><span>,</span> <span>hashlib</span><span>,</span> <span>subprocess</span><span>,</span> <span>tempfile</span><span>,</span> <span>time</span><span>,</span> <span>textwrap</span>
<span>from</span> <span>pathlib</span> <span>import</span> <span>Path</span>
<span>from</span> <span>PIL</span> <span>import</span> <span>Image</span>

<span># ─── 1.  Global constants ────────────────────────────────────────────────────
</span><span>ROM_SIZE</span>       <span>=</span> <span>4096</span>
<span>PAYLOAD_BYTES</span>  <span>=</span> <span>ROM_SIZE</span> <span>-</span> <span>2</span>
<span>RESET_VECTOR</span>   <span>=</span> <span>(</span><span>0x00</span><span>,</span> <span>0xF0</span><span>)</span>         <span># little-endian $F000
</span><span>BATCH_SIZE</span>     <span>=</span> <span>1024</span> <span>*</span> <span>256</span>           <span># ~256 k ROMs per GPU batch
</span><span>STATUS_EVERY</span>   <span>=</span> <span>10</span>                   <span># batches between status prints
</span><span>OUTPUT_DIR</span>     <span>=</span> <span>Path</span><span>(</span><span>&#34;finite_atari_roms&#34;</span><span>);</span> <span>OUTPUT_DIR</span><span>.</span><span>mkdir</span><span>(</span><span>exist_ok</span><span>=</span><span>True</span><span>)</span>

<span># Video thresholds
</span><span>BLACK_LEVEL</span>          <span>=</span> <span>15</span>             <span># 0-255 grey; ≤ this is &#34;black&#34;
</span><span>NONBLACK_THRESHOLD</span>   <span>=</span> <span>0.005</span>          <span># ≥ 0.5 % pixels brighter ⇒ video
</span><span>DYNAMIC_THRESHOLD</span>    <span>=</span> <span>0.01</span>           <span># ≥ 1 % hashed pixels differ ⇒ motion
</span>
<span># Heuristic thresholds (same as your earlier Stella/MAME scripts)
</span><span>OPCODE_THRESHOLD</span>    <span>=</span> <span>0.58</span>
<span>TIA_THRESHOLD</span>       <span>=</span> <span>50</span>
<span>RIOT_THRESHOLD</span>      <span>=</span> <span>13</span>
<span>BRANCH_THRESHOLD</span>    <span>=</span> <span>150</span>
<span>JUMP_THRESHOLD</span>      <span>=</span> <span>37</span>
<span>INSTRUCTION_VARIETY</span> <span>=</span> <span>100</span>
<span>MIN_SCORE</span>           <span>=</span> <span>0.52</span>

<span># ─── 2.  Opcode lookup tables ────────────────────────────────────────────────
# Valid 6502 opcodes for 2600 home-brew context
</span><span>VALID_OPCODES</span> <span>=</span> <span>np</span><span>.</span><span>array</span><span>([</span>
    <span>0x00</span><span>,</span><span>0x01</span><span>,</span><span>0x05</span><span>,</span><span>0x06</span><span>,</span><span>0x08</span><span>,</span><span>0x09</span><span>,</span><span>0x0A</span><span>,</span><span>0x0D</span><span>,</span><span>0x0E</span><span>,</span><span>0x10</span><span>,</span><span>0x11</span><span>,</span><span>0x15</span><span>,</span><span>0x16</span><span>,</span><span>0x18</span><span>,</span>
    <span>0x19</span><span>,</span><span>0x1D</span><span>,</span><span>0x1E</span><span>,</span><span>0x20</span><span>,</span><span>0x21</span><span>,</span><span>0x24</span><span>,</span><span>0x25</span><span>,</span><span>0x26</span><span>,</span><span>0x28</span><span>,</span><span>0x29</span><span>,</span><span>0x2A</span><span>,</span><span>0x2C</span><span>,</span><span>0x2D</span><span>,</span><span>0x2E</span><span>,</span>
    <span>0x30</span><span>,</span><span>0x31</span><span>,</span><span>0x35</span><span>,</span><span>0x36</span><span>,</span><span>0x38</span><span>,</span><span>0x39</span><span>,</span><span>0x3D</span><span>,</span><span>0x3E</span><span>,</span><span>0x40</span><span>,</span><span>0x41</span><span>,</span><span>0x45</span><span>,</span><span>0x46</span><span>,</span><span>0x48</span><span>,</span><span>0x49</span><span>,</span>
    <span>0x4A</span><span>,</span><span>0x4C</span><span>,</span><span>0x4D</span><span>,</span><span>0x4E</span><span>,</span><span>0x50</span><span>,</span><span>0x51</span><span>,</span><span>0x55</span><span>,</span><span>0x56</span><span>,</span><span>0x58</span><span>,</span><span>0x59</span><span>,</span><span>0x5D</span><span>,</span><span>0x5E</span><span>,</span><span>0x60</span><span>,</span><span>0x61</span><span>,</span>
    <span>0x65</span><span>,</span><span>0x66</span><span>,</span><span>0x68</span><span>,</span><span>0x69</span><span>,</span><span>0x6A</span><span>,</span><span>0x6C</span><span>,</span><span>0x6D</span><span>,</span><span>0x6E</span><span>,</span><span>0x70</span><span>,</span><span>0x71</span><span>,</span><span>0x75</span><span>,</span><span>0x76</span><span>,</span><span>0x78</span><span>,</span><span>0x79</span><span>,</span>
    <span>0x7D</span><span>,</span><span>0x7E</span><span>,</span><span>0x81</span><span>,</span><span>0x84</span><span>,</span><span>0x85</span><span>,</span><span>0x86</span><span>,</span><span>0x88</span><span>,</span><span>0x8A</span><span>,</span><span>0x8C</span><span>,</span><span>0x8D</span><span>,</span><span>0x8E</span><span>,</span><span>0x90</span><span>,</span><span>0x91</span><span>,</span><span>0x94</span><span>,</span>
    <span>0x95</span><span>,</span><span>0x96</span><span>,</span><span>0x98</span><span>,</span><span>0x99</span><span>,</span><span>0x9A</span><span>,</span><span>0x9D</span><span>,</span><span>0xA0</span><span>,</span><span>0xA1</span><span>,</span><span>0xA2</span><span>,</span><span>0xA4</span><span>,</span><span>0xA5</span><span>,</span><span>0xA6</span><span>,</span><span>0xA8</span><span>,</span><span>0xA9</span><span>,</span>
    <span>0xAA</span><span>,</span><span>0xAC</span><span>,</span><span>0xAD</span><span>,</span><span>0xAE</span><span>,</span><span>0xB0</span><span>,</span><span>0xB1</span><span>,</span><span>0xB4</span><span>,</span><span>0xB5</span><span>,</span><span>0xB6</span><span>,</span><span>0xB8</span><span>,</span><span>0xB9</span><span>,</span><span>0xBA</span><span>,</span><span>0xBC</span><span>,</span><span>0xBD</span><span>,</span>
    <span>0xBE</span><span>,</span><span>0xC0</span><span>,</span><span>0xC1</span><span>,</span><span>0xC4</span><span>,</span><span>0xC5</span><span>,</span><span>0xC6</span><span>,</span><span>0xC8</span><span>,</span><span>0xC9</span><span>,</span><span>0xCA</span><span>,</span><span>0xCC</span><span>,</span><span>0xCD</span><span>,</span><span>0xCE</span><span>,</span><span>0xD0</span><span>,</span><span>0xD1</span><span>,</span>
    <span>0xD5</span><span>,</span><span>0xD6</span><span>,</span><span>0xD8</span><span>,</span><span>0xD9</span><span>,</span><span>0xDD</span><span>,</span><span>0xDE</span><span>,</span><span>0xE0</span><span>,</span><span>0xE1</span><span>,</span><span>0xE4</span><span>,</span><span>0xE5</span><span>,</span><span>0xE6</span><span>,</span><span>0xE8</span><span>,</span><span>0xE9</span><span>,</span><span>0xEA</span><span>,</span>
    <span>0xEC</span><span>,</span><span>0xED</span><span>,</span><span>0xEE</span><span>,</span><span>0xF0</span><span>,</span><span>0xF1</span><span>,</span><span>0xF5</span><span>,</span><span>0xF6</span><span>,</span><span>0xF8</span><span>,</span><span>0xF9</span><span>,</span><span>0xFD</span><span>,</span><span>0xFE</span><span>],</span> <span>dtype</span><span>=</span><span>np</span><span>.</span><span>uint8</span><span>)</span>

<span>BRANCH_OPCODES</span> <span>=</span> <span>np</span><span>.</span><span>array</span><span>([</span><span>0x10</span><span>,</span><span>0x30</span><span>,</span><span>0x50</span><span>,</span><span>0x70</span><span>,</span><span>0x90</span><span>,</span><span>0xB0</span><span>,</span><span>0xD0</span><span>,</span><span>0xF0</span><span>],</span> <span>dtype</span><span>=</span><span>np</span><span>.</span><span>uint8</span><span>)</span>
<span>JUMP_OPCODES</span>   <span>=</span> <span>np</span><span>.</span><span>array</span><span>([</span><span>0x4C</span><span>,</span><span>0x6C</span><span>,</span><span>0x20</span><span>],</span> <span>dtype</span><span>=</span><span>np</span><span>.</span><span>uint8</span><span>)</span>

<span>def</span> <span>create_luts</span><span>():</span>
    <span>&#34;&#34;&#34;Return a dict of 256-entry boolean lookup tables (cupy).&#34;&#34;&#34;</span>
    <span>lut</span> <span>=</span> <span>{}</span>
    <span>lut</span><span>[</span><span>&#34;valid&#34;</span><span>]</span>  <span>=</span> <span>cp</span><span>.</span><span>zeros</span><span>(</span><span>256</span><span>,</span> <span>cp</span><span>.</span><span>bool_</span><span>);</span> <span>lut</span><span>[</span><span>&#34;valid&#34;</span><span>][</span><span>VALID_OPCODES</span><span>]</span>  <span>=</span> <span>True</span>
    <span>lut</span><span>[</span><span>&#34;branch&#34;</span><span>]</span> <span>=</span> <span>cp</span><span>.</span><span>zeros</span><span>(</span><span>256</span><span>,</span> <span>cp</span><span>.</span><span>bool_</span><span>);</span> <span>lut</span><span>[</span><span>&#34;branch&#34;</span><span>][</span><span>BRANCH_OPCODES</span><span>]</span> <span>=</span> <span>True</span>
    <span>lut</span><span>[</span><span>&#34;jump&#34;</span><span>]</span>   <span>=</span> <span>cp</span><span>.</span><span>zeros</span><span>(</span><span>256</span><span>,</span> <span>cp</span><span>.</span><span>bool_</span><span>);</span> <span>lut</span><span>[</span><span>&#34;jump&#34;</span><span>][</span><span>JUMP_OPCODES</span><span>]</span>     <span>=</span> <span>True</span>

    <span># 2600 addressing quirks for TIA/RIOT access detection
</span>    <span>lut</span><span>[</span><span>&#34;tia_store&#34;</span><span>]</span> <span>=</span> <span>cp</span><span>.</span><span>zeros</span><span>(</span><span>256</span><span>,</span> <span>cp</span><span>.</span><span>bool_</span><span>)</span>
    <span>lut</span><span>[</span><span>&#34;tia_store&#34;</span><span>][[</span><span>0x84</span><span>,</span><span>0x85</span><span>,</span><span>0x86</span><span>,</span> <span>0x94</span><span>,</span><span>0x95</span><span>,</span><span>0x96</span><span>]]</span> <span>=</span> <span>True</span>   <span># STY/STA/STX (zp &amp; zp,x)
</span>    <span>lut</span><span>[</span><span>&#34;tia_load&#34;</span><span>]</span>  <span>=</span> <span>cp</span><span>.</span><span>zeros</span><span>(</span><span>256</span><span>,</span> <span>cp</span><span>.</span><span>bool_</span><span>)</span>
    <span>lut</span><span>[</span><span>&#34;tia_load&#34;</span> <span>][[</span><span>0xA4</span><span>,</span><span>0xA5</span><span>,</span><span>0xA6</span><span>,</span> <span>0xB4</span><span>,</span><span>0xB5</span><span>,</span><span>0xB6</span><span>]]</span> <span>=</span> <span>True</span>   <span># LDY/LDA/LDX (zp &amp; zp,x)
</span>    <span>lut</span><span>[</span><span>&#34;tia_abs&#34;</span><span>]</span>   <span>=</span> <span>cp</span><span>.</span><span>zeros</span><span>(</span><span>256</span><span>,</span> <span>cp</span><span>.</span><span>bool_</span><span>)</span>
    <span>lut</span><span>[</span><span>&#34;tia_abs&#34;</span>  <span>][[</span><span>0x8C</span><span>,</span><span>0x8D</span><span>,</span><span>0x8E</span><span>,</span> <span>0xAC</span><span>,</span><span>0xAD</span><span>,</span><span>0xAE</span><span>]]</span> <span>=</span> <span>True</span>   <span># abs versions
</span>
    <span>lut</span><span>[</span><span>&#34;riot_acc&#34;</span><span>]</span>  <span>=</span> <span>cp</span><span>.</span><span>zeros</span><span>(</span><span>256</span><span>,</span> <span>cp</span><span>.</span><span>bool_</span><span>)</span>
    <span>lut</span><span>[</span><span>&#34;riot_acc&#34;</span><span>][[</span><span>0x84</span><span>,</span><span>0x85</span><span>,</span><span>0x86</span><span>,</span> <span>0xA4</span><span>,</span><span>0xA5</span><span>,</span><span>0xA6</span><span>]]</span> <span>=</span> <span>True</span>

    <span>addr</span> <span>=</span> <span>cp</span><span>.</span><span>arange</span><span>(</span><span>256</span><span>,</span> <span>dtype</span><span>=</span><span>cp</span><span>.</span><span>uint8</span><span>)</span>
    <span>lut</span><span>[</span><span>&#34;tia_range&#34;</span><span>]</span> <span>=</span> <span>addr</span> <span>&lt;=</span> <span>0x2F</span>
    <span>lut</span><span>[</span><span>&#34;riot_tmr&#34;</span><span>]</span>  <span>=</span> <span>(</span><span>addr</span> <span>&gt;=</span> <span>0x80</span><span>)</span> <span>&amp;</span> <span>(</span><span>addr</span> <span>&lt;=</span> <span>0x87</span><span>)</span>
    <span>lut</span><span>[</span><span>&#34;riot_io&#34;</span><span>]</span>   <span>=</span> <span>(</span><span>addr</span> <span>&gt;=</span> <span>0x94</span><span>)</span> <span>&amp;</span> <span>(</span><span>addr</span> <span>&lt;=</span> <span>0x97</span><span>)</span>
    <span>return</span> <span>lut</span>

<span># ─── 3.  GPU heuristic filter ────────────────────────────────────────────────
</span><span>def</span> <span>analyse_batch</span><span>(</span><span>roms</span><span>:</span> <span>cp</span><span>.</span><span>ndarray</span><span>,</span> <span>lut</span><span>)</span> <span>-&gt;</span> <span>tuple</span><span>[</span><span>np</span><span>.</span><span>ndarray</span><span>,</span> <span>cp</span><span>.</span><span>ndarray</span><span>]:</span>
    <span>&#34;&#34;&#34;
    Return (interesting_mask, scores) for a 2-D uint8 array of ROMs.
    Each row = one ROM.
    &#34;&#34;&#34;</span>
    <span>valid_cnt</span>    <span>=</span> <span>cp</span><span>.</span><span>sum</span><span>(</span><span>lut</span><span>[</span><span>&#34;valid&#34;</span><span>][</span><span>roms</span><span>],</span> <span>axis</span><span>=</span><span>1</span><span>)</span>
    <span>opcode_ratio</span> <span>=</span> <span>valid_cnt</span><span>.</span><span>astype</span><span>(</span><span>cp</span><span>.</span><span>float32</span><span>)</span> <span>/</span> <span>ROM_SIZE</span>
    <span>branch_cnt</span>   <span>=</span> <span>cp</span><span>.</span><span>sum</span><span>(</span><span>lut</span><span>[</span><span>&#34;branch&#34;</span><span>][</span><span>roms</span><span>],</span> <span>axis</span><span>=</span><span>1</span><span>)</span>
    <span>jump_cnt</span>     <span>=</span> <span>cp</span><span>.</span><span>sum</span><span>(</span><span>lut</span><span>[</span><span>&#34;jump&#34;</span>  <span>][</span><span>roms</span><span>],</span> <span>axis</span><span>=</span><span>1</span><span>)</span>

    <span># --- TIA accesses --------------------------------------------------------
</span>    <span>tia_acc</span>  <span>=</span> <span>cp</span><span>.</span><span>sum</span><span>((</span><span>lut</span><span>[</span><span>&#34;tia_store&#34;</span><span>][</span><span>roms</span><span>[:,:</span><span>-</span><span>1</span><span>]]</span> <span>|</span> <span>lut</span><span>[</span><span>&#34;tia_load&#34;</span><span>][</span><span>roms</span><span>[:,:</span><span>-</span><span>1</span><span>]])</span>
                      <span>&amp;</span> <span>lut</span><span>[</span><span>&#34;tia_range&#34;</span><span>][</span><span>roms</span><span>[:,</span><span>1</span><span>:]],</span> <span>axis</span><span>=</span><span>1</span><span>)</span>
    <span>tia_acc</span> <span>+=</span> <span>cp</span><span>.</span><span>sum</span><span>(</span><span>lut</span><span>[</span><span>&#34;tia_abs&#34;</span><span>][</span><span>roms</span><span>[:,:</span><span>-</span><span>2</span><span>]]</span>
                      <span>&amp;</span> <span>lut</span><span>[</span><span>&#34;tia_range&#34;</span><span>][</span><span>roms</span><span>[:,</span><span>1</span><span>:</span><span>-</span><span>1</span><span>]]</span>
                      <span>&amp;</span> <span>(</span><span>roms</span><span>[:,</span><span>2</span><span>:]</span> <span>==</span> <span>0x00</span><span>),</span> <span>axis</span><span>=</span><span>1</span><span>)</span>

    <span># --- RIOT accesses -------------------------------------------------------
</span>    <span>riot_acc</span>  <span>=</span> <span>cp</span><span>.</span><span>sum</span><span>(</span><span>lut</span><span>[</span><span>&#34;riot_acc&#34;</span><span>][</span><span>roms</span><span>[:,:</span><span>-</span><span>1</span><span>]]</span> <span>&amp;</span> <span>lut</span><span>[</span><span>&#34;riot_tmr&#34;</span><span>][</span><span>roms</span><span>[:,</span><span>1</span><span>:]],</span> <span>axis</span><span>=</span><span>1</span><span>)</span>
    <span>riot_acc</span> <span>+=</span> <span>cp</span><span>.</span><span>sum</span><span>(</span><span>lut</span><span>[</span><span>&#34;riot_acc&#34;</span><span>][</span><span>roms</span><span>[:,:</span><span>-</span><span>1</span><span>]]</span> <span>&amp;</span> <span>lut</span><span>[</span><span>&#34;riot_io&#34;</span> <span>][</span><span>roms</span><span>[:,</span><span>1</span><span>:]],</span> <span>axis</span><span>=</span><span>1</span><span>)</span>

    <span># --- Opcode diversity in first 1 KB --------------------------------------
</span>    <span>uniq</span> <span>=</span> <span>cp</span><span>.</span><span>zeros</span><span>(</span><span>roms</span><span>.</span><span>shape</span><span>[</span><span>0</span><span>],</span> <span>dtype</span><span>=</span><span>cp</span><span>.</span><span>int32</span><span>)</span>
    <span>first_kb</span> <span>=</span> <span>roms</span><span>[:,</span> <span>:</span><span>1024</span><span>]</span>
    <span>for</span> <span>op</span> <span>in</span> <span>VALID_OPCODES</span><span>:</span>
        <span>uniq</span> <span>+=</span> <span>cp</span><span>.</span><span>any</span><span>(</span><span>first_kb</span> <span>==</span> <span>op</span><span>,</span> <span>axis</span><span>=</span><span>1</span><span>)</span>

    <span>scores</span> <span>=</span> <span>(</span><span>opcode_ratio</span> <span>*</span> <span>0.25</span> <span>+</span>
              <span>cp</span><span>.</span><span>minimum</span><span>(</span><span>tia_acc</span> <span>/</span> <span>150.0</span><span>,</span> <span>1.0</span><span>)</span> <span>*</span> <span>0.30</span> <span>+</span>
              <span>cp</span><span>.</span><span>minimum</span><span>(</span><span>riot_acc</span> <span>/</span> <span>50.0</span><span>,</span> <span>1.0</span><span>)</span>  <span>*</span> <span>0.20</span> <span>+</span>
              <span>cp</span><span>.</span><span>minimum</span><span>(</span><span>branch_cnt</span> <span>/</span> <span>200.0</span><span>,</span> <span>1.0</span><span>)</span> <span>*</span> <span>0.15</span> <span>+</span>
              <span>cp</span><span>.</span><span>minimum</span><span>(</span><span>jump_cnt</span> <span>/</span> <span>40.0</span><span>,</span> <span>1.0</span><span>)</span>   <span>*</span> <span>0.10</span><span>)</span>

    <span>interesting</span> <span>=</span> <span>((</span><span>opcode_ratio</span> <span>&gt;=</span> <span>OPCODE_THRESHOLD</span><span>)</span> <span>&amp;</span>
                   <span>(</span><span>tia_acc</span>      <span>&gt;=</span> <span>TIA_THRESHOLD</span><span>)</span> <span>&amp;</span>
                   <span>(</span><span>riot_acc</span>     <span>&gt;=</span> <span>RIOT_THRESHOLD</span><span>)</span> <span>&amp;</span>
                   <span>(</span><span>branch_cnt</span>   <span>&gt;=</span> <span>BRANCH_THRESHOLD</span><span>)</span> <span>&amp;</span>
                   <span>(</span><span>jump_cnt</span>     <span>&gt;=</span> <span>JUMP_THRESHOLD</span><span>)</span> <span>&amp;</span>
                   <span>(</span><span>uniq</span>         <span>&gt;=</span> <span>INSTRUCTION_VARIETY</span><span>)</span> <span>&amp;</span>
                   <span>(</span><span>scores</span>       <span>&gt;=</span> <span>MIN_SCORE</span><span>))</span>

    <span>return</span> <span>interesting</span><span>,</span> <span>scores</span>

<span># ─── 4.  Lua helper script (snapshot two frames) - FIXED ────────────────────
</span><span>SNAPSHOT_LUA</span> <span>=</span> <span>textwrap</span><span>.</span><span>dedent</span><span>(</span><span>&#34;&#34;&#34;
    local s = manager.machine.screens[&#34;:screen&#34;]
    local frame_count = 0
    emu.register_frame_done(function ()
        frame_count = frame_count + 1
        if     frame_count == 1  then s:snapshot(&#34;first.png&#34;)
        elseif frame_count == 60 then s:snapshot(&#34;second.png&#34;); manager.machine:exit() end
    end, &#34;snapper&#34;)
&#34;&#34;&#34;</span><span>)</span>

<span># ─── 5.  Video analysis helpers ──────────────────────────────────────────────
</span><span>def</span> <span>_hash16</span><span>(</span><span>img</span><span>:</span> <span>Path</span><span>)</span> <span>-&gt;</span> <span>str</span><span>:</span>
    <span>with</span> <span>Image</span><span>.</span><span>open</span><span>(</span><span>img</span><span>)</span> <span>as</span> <span>im</span><span>:</span>
        <span>im</span> <span>=</span> <span>im</span><span>.</span><span>convert</span><span>(</span><span>&#34;L&#34;</span><span>).</span><span>resize</span><span>((</span><span>16</span><span>,</span><span>16</span><span>),</span> <span>Image</span><span>.</span><span>NEAREST</span><span>)</span>
        <span>return</span> <span>hashlib</span><span>.</span><span>sha1</span><span>(</span><span>im</span><span>.</span><span>tobytes</span><span>()).</span><span>hexdigest</span><span>()</span>

<span>def</span> <span>_frame_is_nonblack</span><span>(</span><span>img</span><span>:</span> <span>Path</span><span>)</span> <span>-&gt;</span> <span>bool</span><span>:</span>
    <span>with</span> <span>Image</span><span>.</span><span>open</span><span>(</span><span>img</span><span>)</span> <span>as</span> <span>im</span><span>:</span>
        <span>g</span> <span>=</span> <span>np</span><span>.</span><span>asarray</span><span>(</span><span>im</span><span>.</span><span>convert</span><span>(</span><span>&#34;L&#34;</span><span>))</span>
    <span>return</span> <span>(</span><span>g</span> <span>&gt;</span> <span>BLACK_LEVEL</span><span>).</span><span>mean</span><span>()</span> <span>&gt;=</span> <span>NONBLACK_THRESHOLD</span>

<span>def</span> <span>rom_video_flags</span><span>(</span><span>rom</span><span>:</span> <span>bytes</span><span>,</span> <span>*</span><span>,</span> <span>mame</span><span>=</span><span>&#34;mame&#34;</span><span>,</span> <span>seconds</span><span>=</span><span>2.0</span><span>)</span> <span>-&gt;</span> <span>tuple</span><span>[</span><span>bool</span><span>,</span><span>bool</span><span>]:</span>
    <span>&#34;&#34;&#34;
    Returns (has_video, is_dynamic).
    • has_video  → first frame not black
    • is_dynamic → ≥ 1 % hashed pixels differ between frame 1 and 60
    &#34;&#34;&#34;</span>
    <span>with</span> <span>tempfile</span><span>.</span><span>TemporaryDirectory</span><span>()</span> <span>as</span> <span>td_s</span><span>:</span>
        <span>td</span> <span>=</span> <span>Path</span><span>(</span><span>td_s</span><span>)</span>
        <span>(</span><span>td</span> <span>/</span> <span>&#34;test.bin&#34;</span><span>).</span><span>write_bytes</span><span>(</span><span>rom</span><span>)</span>
        <span>(</span><span>td</span> <span>/</span> <span>&#34;snapshot.lua&#34;</span><span>).</span><span>write_text</span><span>(</span><span>SNAPSHOT_LUA</span><span>)</span>

        <span>base</span> <span>=</span> <span>[</span><span>mame</span><span>,</span> <span>&#34;a2600&#34;</span><span>,</span> <span>&#34;-cart&#34;</span><span>,</span> <span>&#34;test.bin&#34;</span><span>,</span>
                <span>&#34;-seconds_to_run&#34;</span><span>,</span> <span>str</span><span>(</span><span>seconds</span><span>),</span>
                <span>&#34;-nothrottle&#34;</span><span>,</span> <span>&#34;-window&#34;</span><span>,</span> <span>&#34;-sound&#34;</span><span>,</span> <span>&#34;none&#34;</span><span>,</span> <span>&#34;-skip_gameinfo&#34;</span><span>]</span>

        <span>for</span> <span>flag</span> <span>in</span> <span>(</span><span>&#34;-autoboot_script&#34;</span><span>,</span> <span>&#34;-script&#34;</span><span>):</span>
            <span>try</span><span>:</span>
                <span>subprocess</span><span>.</span><span>run</span><span>(</span><span>base</span> <span>+</span> <span>[</span><span>flag</span><span>,</span> <span>&#34;snapshot.lua&#34;</span><span>],</span>
                               <span>cwd</span><span>=</span><span>td</span><span>,</span> <span>stdout</span><span>=</span><span>subprocess</span><span>.</span><span>DEVNULL</span><span>,</span>
                               <span>stderr</span><span>=</span><span>subprocess</span><span>.</span><span>DEVNULL</span><span>,</span> <span>timeout</span><span>=</span><span>seconds</span><span>*</span><span>5</span><span>,</span>
                               <span>check</span><span>=</span><span>True</span><span>)</span>
                <span>break</span>
            <span>except</span> <span>(</span><span>subprocess</span><span>.</span><span>CalledProcessError</span><span>,</span> <span>subprocess</span><span>.</span><span>TimeoutExpired</span><span>):</span>
                <span>if</span> <span>flag</span> <span>==</span> <span>&#34;-autoboot_script&#34;</span><span>:</span>
                    <span>continue</span>
                <span>return</span> <span>(</span><span>False</span><span>,</span> <span>False</span><span>)</span>

        <span># Check both root directory and snap subdirectory for frames
</span>        <span>f1</span><span>,</span> <span>f2</span> <span>=</span> <span>td</span> <span>/</span> <span>&#34;first.png&#34;</span><span>,</span> <span>td</span> <span>/</span> <span>&#34;second.png&#34;</span>
        <span>snap_dir</span> <span>=</span> <span>td</span> <span>/</span> <span>&#34;snap&#34;</span>
        <span>if</span> <span>not</span> <span>f1</span><span>.</span><span>exists</span><span>()</span> <span>and</span> <span>snap_dir</span><span>.</span><span>exists</span><span>():</span>
            <span>snap_f1</span> <span>=</span> <span>snap_dir</span> <span>/</span> <span>&#34;first.png&#34;</span>
            <span>snap_f2</span> <span>=</span> <span>snap_dir</span> <span>/</span> <span>&#34;second.png&#34;</span>
            <span>if</span> <span>snap_f1</span><span>.</span><span>exists</span><span>():</span>
                <span>f1</span> <span>=</span> <span>snap_f1</span>
            <span>if</span> <span>snap_f2</span><span>.</span><span>exists</span><span>():</span>
                <span>f2</span> <span>=</span> <span>snap_f2</span>

        <span>if</span> <span>not</span> <span>f1</span><span>.</span><span>exists</span><span>():</span>
            <span>return</span> <span>(</span><span>False</span><span>,</span> <span>False</span><span>)</span>

        <span>nonblack</span> <span>=</span> <span>_frame_is_nonblack</span><span>(</span><span>f1</span><span>)</span>
        <span>if</span> <span>not</span> <span>nonblack</span> <span>or</span> <span>not</span> <span>f2</span><span>.</span><span>exists</span><span>():</span>
            <span>return</span> <span>(</span><span>nonblack</span><span>,</span> <span>False</span><span>)</span>

        <span>diff_bits</span> <span>=</span> <span>bin</span><span>(</span><span>int</span><span>(</span><span>_hash16</span><span>(</span><span>f1</span><span>),</span><span>16</span><span>)</span> <span>^</span> <span>int</span><span>(</span><span>_hash16</span><span>(</span><span>f2</span><span>),</span><span>16</span><span>)).</span><span>count</span><span>(</span><span>&#34;1&#34;</span><span>)</span>
        <span>dynamic</span> <span>=</span> <span>diff_bits</span> <span>/</span> <span>256.0</span> <span>&gt;=</span> <span>DYNAMIC_THRESHOLD</span>
        <span>return</span> <span>(</span><span>nonblack</span><span>,</span> <span>dynamic</span><span>)</span>

<span># ─── 6.  ROM generator ───────────────────────────────────────────────────────
</span><span>def</span> <span>generate_batch</span><span>(</span><span>n</span><span>:</span> <span>int</span><span>)</span> <span>-&gt;</span> <span>np</span><span>.</span><span>ndarray</span><span>:</span>
    <span>payload</span> <span>=</span> <span>np</span><span>.</span><span>random</span><span>.</span><span>randint</span><span>(</span><span>0</span><span>,</span> <span>256</span><span>,</span> <span>size</span><span>=</span><span>(</span><span>n</span><span>,</span> <span>PAYLOAD_BYTES</span><span>),</span> <span>dtype</span><span>=</span><span>np</span><span>.</span><span>uint8</span><span>)</span>
    <span>reset</span>   <span>=</span> <span>np</span><span>.</span><span>tile</span><span>(</span><span>np</span><span>.</span><span>array</span><span>(</span><span>RESET_VECTOR</span><span>,</span> <span>dtype</span><span>=</span><span>np</span><span>.</span><span>uint8</span><span>),</span> <span>(</span><span>n</span><span>,</span><span>1</span><span>))</span>
    <span>return</span> <span>np</span><span>.</span><span>hstack</span><span>((</span><span>payload</span><span>,</span> <span>reset</span><span>))</span>

<span># ─── 7.  Main loop ───────────────────────────────────────────────────────────
</span><span>def</span> <span>main</span><span>():</span>
    <span>lut</span> <span>=</span> <span>create_luts</span><span>()</span>
    <span>tot_gen</span> <span>=</span> <span>tot_int</span> <span>=</span> <span>tot_vid</span> <span>=</span> <span>tot_dyn</span> <span>=</span> <span>0</span>
    <span>batch_idx</span> <span>=</span> <span>0</span>
    <span>start</span> <span>=</span> <span>time</span><span>.</span><span>perf_counter</span><span>()</span>

    <span>try</span><span>:</span>
        <span>while</span> <span>True</span><span>:</span>
            <span>roms_cpu</span> <span>=</span> <span>generate_batch</span><span>(</span><span>BATCH_SIZE</span><span>);</span> <span>tot_gen</span> <span>+=</span> <span>BATCH_SIZE</span>

            <span>roms_gpu</span> <span>=</span> <span>cp</span><span>.</span><span>asarray</span><span>(</span><span>roms_cpu</span><span>)</span>
            <span>keep</span><span>,</span> <span>_</span> <span>=</span> <span>analyse_batch</span><span>(</span><span>roms_gpu</span><span>,</span> <span>lut</span><span>)</span>
            <span>keep</span> <span>=</span> <span>keep</span><span>.</span><span>get</span><span>();</span> <span>del</span> <span>roms_gpu</span>
            <span>interesting</span> <span>=</span> <span>roms_cpu</span><span>[</span><span>keep</span><span>]</span>
            <span>tot_int</span> <span>+=</span> <span>len</span><span>(</span><span>interesting</span><span>)</span>

            <span>for</span> <span>rom</span> <span>in</span> <span>interesting</span><span>:</span>
                <span>has_vid</span><span>,</span> <span>is_dyn</span> <span>=</span> <span>rom_video_flags</span><span>(</span><span>rom</span><span>.</span><span>tobytes</span><span>())</span>

                <span># Save if EITHER condition is true
</span>                <span>if</span> <span>has_vid</span> <span>or</span> <span>is_dyn</span><span>:</span>
                    <span>sha</span> <span>=</span> <span>hashlib</span><span>.</span><span>sha1</span><span>(</span><span>rom</span><span>).</span><span>hexdigest</span><span>()[:</span><span>12</span><span>]</span>
                    <span>(</span><span>OUTPUT_DIR</span> <span>/</span> <span>f</span><span>&#34;</span><span>{</span><span>sha</span><span>}</span><span>.bin&#34;</span><span>).</span><span>write_bytes</span><span>(</span><span>rom</span><span>.</span><span>tobytes</span><span>())</span>

                <span># Separate bookkeeping
</span>                <span>if</span> <span>has_vid</span><span>:</span>
                    <span>tot_vid</span> <span>+=</span> <span>1</span>           <span># first frame not black
</span>                <span>if</span> <span>is_dyn</span><span>:</span>
                    <span>tot_dyn</span> <span>+=</span> <span>1</span>           <span># animation detected
</span>
            <span>batch_idx</span> <span>+=</span> <span>1</span>
            <span>if</span> <span>batch_idx</span> <span>%</span> <span>STATUS_EVERY</span> <span>==</span> <span>0</span><span>:</span>
                <span>elapsed</span> <span>=</span> <span>time</span><span>.</span><span>perf_counter</span><span>()</span> <span>-</span> <span>start</span>
                <span>rate</span> <span>=</span> <span>int</span><span>(</span><span>tot_gen</span> <span>/</span> <span>elapsed</span><span>)</span> <span>if</span> <span>elapsed</span> <span>else</span> <span>0</span>
                <span>print</span><span>(</span><span>f</span><span>&#34;</span><span>{</span><span>tot_gen</span><span>:</span><span>,</span><span>d</span><span>}</span><span> generated | &#34;</span>
                      <span>f</span><span>&#34;</span><span>{</span><span>tot_int</span><span>:</span><span>,</span><span>d</span><span>}</span><span> interesting | </span><span>{</span><span>tot_vid</span><span>:</span><span>,</span><span>d</span><span>}</span><span> with video | &#34;</span>
                      <span>f</span><span>&#34;</span><span>{</span><span>tot_dyn</span><span>:</span><span>,</span><span>d</span><span>}</span><span> dynamic | </span><span>{</span><span>rate</span><span>:</span><span>,</span><span>d</span><span>}</span><span> ROM/s&#34;</span><span>,</span> <span>flush</span><span>=</span><span>True</span><span>)</span>

    <span>except</span> <span>KeyboardInterrupt</span><span>:</span>
        <span>pass</span>  <span># graceful exit
</span>
    <span>elapsed</span> <span>=</span> <span>time</span><span>.</span><span>perf_counter</span><span>()</span> <span>-</span> <span>start</span>
    <span>rate</span> <span>=</span> <span>int</span><span>(</span><span>tot_gen</span> <span>/</span> <span>elapsed</span><span>)</span> <span>if</span> <span>elapsed</span> <span>else</span> <span>0</span>
    <span>print</span><span>(</span><span>&#34;─&#34;</span><span>*</span><span>72</span><span>)</span>
    <span>print</span><span>(</span><span>f</span><span>&#34;TOTAL: </span><span>{</span><span>tot_gen</span><span>:</span><span>,</span><span>d</span><span>}</span><span> generated | </span><span>{</span><span>tot_int</span><span>:</span><span>,</span><span>d</span><span>}</span><span> interesting | &#34;</span>
          <span>f</span><span>&#34;</span><span>{</span><span>tot_vid</span><span>:</span><span>,</span><span>d</span><span>}</span><span> with video | </span><span>{</span><span>tot_dyn</span><span>:</span><span>,</span><span>d</span><span>}</span><span> dynamic | </span><span>{</span><span>rate</span><span>:</span><span>,</span><span>d</span><span>}</span><span> ROM/s&#34;</span><span>)</span>

<span>if</span> <span>__name__</span> <span>==</span> <span>&#34;__main__&#34;</span><span>:</span>
    <span>main</span><span>()</span>
</code></pre></div></div>

<p>This script generates 4kB of random data, then filters them for heuristics on the GPU. On an Nvidia GeForce GTX 1070, this generates about <strong>62,150 ROMs/s</strong>. Filtering for the heuristics, I get one “interesting” ROM – one that passes the heuristics – for every 2.5 Million ROMs generated.</p>

<p>From there, the interesting ROMs are sent to the CPU, where they’re checked with MAME for visual output. Here’s an example of the output after being run overnight:</p>

<p><code>
TOTAL: 1,804,075,008 generated | 456 interesting | 16 with video | 11 dynamic | 62,156 ROM/s
<code></code></code></p>

<p>Out of 1.8 Billion ROMs generated, only 456 passed the heuristics test. Of those, 16 had a static video output, 11 had video that moved. You have no idea how much I’m resisting a making a Sankey diagram/fluffer joke right now.</p>

<h2 id="what-i-found">What I found</h2>

<p>These are some of the most visually interesting results from this experiment. All of these ROMs were generated entirely from random data, filtered with heuristics, and run through an Atari emulator. All of these produce valid video output and show dynamic or structured data.</p>




<h2 id="a-real-actual-protogame">A Real, Actual, Protogame</h2>

<p>Despite my entire pipeline being focused on generating visual output, I discovered something that is more than just weird visual ouput. The ROM I’m calling <code>51014</code> (<a href="https://bbenchoff.github.io/assets/pages/roms/5101496f45e8b.bin">here’s a link</a> to the actual ROM file) displays some game-like behavior. It’s an infinite loop of visual output that responds to human input. Take a look at the .gifs below:</p>





<p>Rom <code>51014</code> consists of a yellow background with two static vertical red stripes on the screen. There is also a third stripe – actually a pair of red stripes – that is not static; it looks like it’s tearing every few scanlines. By pressing Up on the joystick, that torn pair of stripes stays still. It’s input being translated into visual output.</p>

<p>It’s certainly not impressive from a programming point of view, but considering the fact it was generated <em>only out of properly filtering random data</em> is crazy. Combine a few more of these into a single rom and you have a game!</p>

<h2 id="future-work">Future Work?</h2>

<p>I targeted the Atari 2600 for a reason. It’s dead simple, there are no memory mappers or program and character ROMs, and it doesn’t have the ‘Nintendo Logo copy protection’ the original Game Boy has. Basically, if you throw random bytes at an Atari, <em>something</em> is going to fall out, which I have proven here.</p>

<p>But others have suggested other platforms to target, like the NES or Game Boy. These will not work as well as the 2600 for a few reasons.</p>

<p><strong>The NES</strong> is much more complex, with memory mappers required for nearly any game. You can’t just drop random bytes into the ROM and expect anything. Rather, you <em>could</em> but it would take much longer than waiting for an Atari game. The NES uses split character and program ROMs for code and graphics. These are stored separately. You could dump garbage into a CHR ROM while keeping the PRG of Tetris, but you’d just get static. Reverse it with the PRG of Mario 3 and maybe you’ll see a quarter of a Mario sprite flicker once.</p>

<p><strong>The Game Boy</strong> requires a 48-byte Nintendo logo at a hardcoded location in the ROM. Sure, you could brute-force this by just slapping it in after being generated, but there’s a whole boot ROM that must complete successfully before anything happens. And there’s bank switching chips to consider.</p>

<p>In contrast, the Atari 2600 is astonishingly stupid. It boots straight into ROM with zero safeguards. It will send video after nine instructions. <em>Something</em> is going to fall out if you shake it enough.</p>

<p>There’s also the possibility of using more advanced machine learning models or even an LLM to generate Atari games. This, I think, misses the point. Training an LLM on the thousand or so commercial Atari games would would only produce something like a commercial Atari game, if anything at all. My method of generating random data, then filtering with some basic heuristics, then actually running the thing to see if there’s any output is the best way to produce something out of randomness. My goal isn’t just to make a playable game, it’s to make a playable game out of randomness.</p>

<p>If I take this further, it would be as a distributed computing project, something like SETI@Home, where millions of machines search for signals in cosmic noise. Imagine GPUs across the world mining entropy for Atari games, then sending the promising ones to a central system to evaluate their ‘game-ness’. It’s an absurd idea. I’ll see how popular this project gets. It’s better than mining fartcoin, at least.</p>

<h2 id="a-conclusion">A Conclusion</h2>



<div>
  <figure>
    <img src="https://bbenchoff.github.io/images/blurst.png" alt="It was the best of times, it was the blurst of times?"/>
    <figcaption>It was the best of times, it was the blurst of times?</figcaption>
  </figure>

  <div>
    <p>The idea that I could pull random video games out of the ether is absurd at first, but I knew this would work before I began. I can describe this in both as a philosophical / thought experiment, and as a technical inevitability.</p>

    <p>What I&#39;m doing is not Infinite Monkey Theorem. A million monkeys will eventually produce the works of Shakespeare, that&#39;s true, but it would take longer than any time the Universe has left. I&#39;m not asking monkeys to produce the works of Shakespeare, I&#39;m asking them to produce <em>any</em> work.</p>

    <p>Producing the word ‘banana’ in ASCII is just $\frac{1}{256}^6 = \frac{1}{281{,}474{,}976{,}710{,}656}$ or once every 300 trillion monkeys. But I’m not looking for ‘banana’, I’m just looking for <em>a word</em>. Any word in the dictionary. I don’t care if I’m not generating <em>Yar’s Revenge</em>. I just want something that runs on an Atari. That’s significantly easier.</p>
  </div>
</div>

<p>The <em>technical</em> reason why I knew this would work is the simplicity of the Atari. The simplest thing you could ever create on an Atari looks something like this:</p>

<pre><code>
; Program starts at $F000

F000: A9 84       ; LDA #$84        - Load a color value (red/orange)
F002: 85 09       ; STA $09         - Store to COLUBK (background color register)
F004: 85 02       ; STA $02         - Store to WSYNC (wait for horizontal sync)
F006: 4C 04 F0    ; JMP $F004       - Jump back to the WSYNC line (infinite loop)
</code></pre>

<p>That’s nine instructions. In fact, we can do the math on that, too. It would have to start with <code>A9</code>, and then it could be any one of 128 total colors. Then it’s <code>85 09</code> to store the background color, <code>85 02</code> to wait for <code>WSYNC</code>, and <code>4C 04 F0</code> for the jump back to the previous instruction. It’s $\frac{1}{256} \times \frac{128}{256} \times \frac{1}{256} \times \frac{1}{256} \times \frac{1}{256} \times \frac{1}{256} \times \frac{1}{256} \times \frac{1}{256} \times \frac{1}{256} = \frac{1}{36{,}893{,}488{,}147{,}419{,}103{,}232}$, or about 36 Pentillion. There are nearly infinite variations on this code though, so after a few Billion ROMs tested, I’m bound to get <em>something</em> for my efforts.</p>

<p>You can find all the code for this in the <a href="https://github.com/bbenchoff/FiniteAtariMachine">Finite Atari Machine repo</a></p>

<p><a href="https://bbenchoff.github.io/">back</a></p>

    </div></div>
  </body>
</html>
