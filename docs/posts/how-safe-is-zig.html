<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.scattered-thoughts.net/writing/how-safe-is-zig/">Original</a>
    <h1>How Safe Is Zig?</h1>
    
    <div id="readability-page-1" class="page"><article>
  <p>I keep seeing discussions that equate zigs level of memory safety with c, or occasionally with rust. Neither is particularly accurate. This is an attempt at a more detailed breakdown.</p>
<p>I&#39;m concerned mostly with security. In practice, it doesn&#39;t seem that any level of testing is sufficient to prevent vulnerabilities due to memory safety in large programs. So I&#39;m not covering tools like AddressSanitizer that are intended for testing and are <a href="https://www.openwall.com/lists/oss-security/2016/02/17/9">not recommended</a> for production use. Instead I&#39;ll focus on tools which can systematically rule out errors (eg compiler-inserted bounds checks completely prevent out-of-bounds heap read/write).</p>
<p>I&#39;m also focusing on software as it is typically shipped, ignoring eg bounds checking compilers like <a href="https://bellard.org/tcc/">tcc</a> or quarantining allocators like <a href="https://github.com/GrapheneOS/hardened_malloc">hardened_malloc</a> which are rarely used because of the performance overhead.</p>
<p>Finally, note the &#39;Updated&#39; date below the title. Zig in particular is still under rapid development and will likely change faster than this article updates. (See the <a href="https://github.com/ziglang/zig/issues/2301">tracking issue</a> for safety mechanisms).</p>
<p>Here are the issues against which c/zig/rust have systematic protection:</p>
<table><thead><tr><th>issue</th><th>c</th><th>zig (release-safe)</th><th>rust (release)</th></tr></thead><tbody>
<tr><td>out-of-bounds heap read/write</td><td>none</td><td>runtime</td><td>runtime</td></tr>
<tr><td>null pointer dereference</td><td>none</td><td>runtime⁰</td><td>runtime⁰</td></tr>
<tr><td><a href="https://cwe.mitre.org/data/definitions/843.html">type confusion</a></td><td>none</td><td>runtime, partial¹</td><td>runtime²</td></tr>
<tr><td>integer overflow</td><td>none</td><td>runtime</td><td>runtime³</td></tr>
<tr><td>use after free</td><td>none</td><td>none⁴</td><td>compile time</td></tr>
<tr><td>double free</td><td>none</td><td>none⁴</td><td>compile time</td></tr>
<tr><td>invalid stack read/write</td><td>none</td><td>none</td><td>compile time</td></tr>
<tr><td>uninitialized memory</td><td>none</td><td>none</td><td>compile time</td></tr>
<tr><td>data race</td><td>none</td><td>none</td><td>compile time</td></tr>
</tbody></table>
<ol start="0">
<li><em>optional types</em></li>
<li><em>tagged unions, doesn&#39;t protect against holding a pointer to value while changing tag</em></li>
<li><em>tagged unions</em></li>
<li><em>not by default, but available via compiler setting or by linting against unchecked arithmetic</em></li>
<li><em>optional protections exist but I expect the runtime overhead to be unacceptable in many domains - see discussion <a href="https://lobste.rs/s/v5y4jb/how_safe_is_zig#c_vddk9j">here</a> and <a href="https://twitter.com/tqbf/status/1374073476064116737">here</a></em></li>
</ol>
<p>There are two clear groups here:</p>
<ul>
<li><strong>Spatial memory safety</strong>. Mostly runtime mitigations. Nearly identical in both zig and rust. These are easy to implement and probably sufficiently non-controversial that any new systems language will have similar features.</li>
<li><strong>Temporal memory safety and data race safety</strong>. Mostly compile time mitigations. Unique to rust. These are novel, non-trivial to implement and add a significant amount of complexity to the language.</li>
</ul>
<p>So we can say that zigs spatial memory safety is roughly comparable to rust, and its temporal memory safety and data race safety are roughly comparable to c.</p>
<hr/>
<p>Zig also has some non-systematic improvements over c with regards to temporal memory safety:</p>
<ul>
<li>The standard library includes a set of allocators which don&#39;t reuse allocations, preventing use-after-free, and which catch double-free. It&#39;s <a href="https://lobste.rs/s/v5y4jb/how_safe_is_zig#c_l9voqf">not yet clear</a> how high the runtime and memory overhead will be. Similar allocators do exist for c and are not widely used, which makes me somewhat pessimistic, but I&#39;d be happy to be proved wrong.</li>
<li>In c unitialized variables are often used when they can&#39;t easily be initialized by a single expression. In zig it&#39;s possible to use a labeled block that returns the initial value, or to use an optional type and initialize it to null. Creating an unitialized variable also requires using the <code>undefined</code> keyword which helps flag such cases for review.</li>
<li>The pervasive allocator api makes it easier to use arena allocation or garbage-collected pools to simplify lifetime management.</li>
<li>Using <code>defer</code> and <code>errdefer</code> simplifies resource cleanup inside complicated control flow, reducing the possibility of mistakes.</li>
<li>Support for generics reduces the chances of casting mistakes.</li>
</ul>
<p>Zig also has a number of tools to help detect violations of temporal memory safety during testing. These are very helpful for development, but experience with c indicates that they won&#39;t be sufficient to eliminate vulnerabilities.</p>
<hr/>
<p>I tried looking at some public breakdowns of security issues from various projects written in c and c++ (mostly sourced from <a href="https://alexgaynor.net/2019/aug/12/introduction-to-memory-unsafety-for-vps-of-engineering/#how-common-are-vulnerabilities-due-to-memory-unsafety">Alex Gaynors handy summary</a>) to get a sense of the relative frequencies of different kinds of errors:</p>
<ul>
<li><a href="https://security.googleblog.com/2019/05/queue-hardening-enhancements.html">Android</a>: ~75% spatial vs ~15% temporal (just eyeballing the pie-chart)</li>
<li><a href="https://raw.githubusercontent.com/microsoft/MSRC-Security-Research/master/presentations/2019_02_BlueHatIL/2019_01%20-%20BlueHatIL%20-%20Trends%2C%20challenge%2C%20and%20shifts%20in%20software%20vulnerability%20mitigation.pdf">Windows</a>: Some of the categories don&#39;t map neatly to spatial vs temporal. If we assume that &#39;stack corruption&#39; is always temporal but &#39;heap corruption&#39; could go either way then we have 23-36% spatial vs 28-41% temporal for 2018. If we narrow down to exploited issues then it&#39;s 0% spatial vs 75% temporal.</li>
<li><a href="https://daniel.haxx.se/blog/2021/03/09/half-of-curls-vulnerabilities-are-c-mistakes/">Curl</a>: 45% spatial vs 7% temporal (the pie-chart breakdown is only for the 52% of security issues related to memory safety)</li>
<li><a href="https://docs.google.com/spreadsheets/d/1lkNJ0uQwbeC1ZTRrxdtuPLCIl7mlUreoKfSIgajnSyY/edit#gid=1869060786">0day in the wild</a>: Insufficient detail on most, but if we look just at those explicitly marked as &#39;use after free&#39; then we have 5/25 in 2020, 5/21 in 2019, 6/13 in 2018 etc so possibly &gt;50% temporal?</li>
</ul>
<p>This isn&#39;t a very clear picture. The percentages vary wildly between projects. The categories are sufficiently vague that I could be classifying them all wrong. Looking only at fixed issues tells us nothing about how easy they are to exploit, but looking at existing exploits limits us to a very small dataset. </p>
<p>It certainly seems like just fixing spatial memory safety (going from c to zig) is a non-trivial improvement. But I&#39;d like to better understand why actual exploits appear here to rely more often on violating temporal memory safety.</p>
<hr/>
<p>When does this matter? </p>
<p>Rust bears additional complexity and friction to buy temporal memory safety and data race safety. But sometimes we might be able to buy those more cheaply eg:</p>
<ul>
<li>Systems that can approach temporal memory safety by:
<ul>
<li>Never calling free (practical for many embedded programs, some command-line utilities, compilers etc)</li>
<li>Having very simple ownership and lifetime models (eg many games)</li>
<li>Making use of some specialized system for managing long-lived state (eg <a href="https://fossil-scm.org/home/doc/trunk/www/theory1.wiki">fossil&#39;s use of sqlite</a>, <a href="https://securityintelligence.com/memgc-use-after-free-exploit-mitigation-in-edge-and-ie-on-windows-10/">edge&#39;s use of memgc</a>)</li>
<li>Making use of fine-grained sandboxing (eg <a href="https://hacks.mozilla.org/2020/02/securing-firefox-with-webassembly/">rlbox</a>)</li>
</ul>
</li>
<li>Systems that can approach data race safety by:
<ul>
<li>Being single-threaded</li>
<li>Using an architecture with strictly controlled sharing (eg <a href="https://www.datadoghq.com/blog/engineering/introducing-glommio/">glommio</a>, <a href="https://github.com/TimelyDataflow/differential-dataflow">differential dataflow</a>)</li>
</ul>
</li>
</ul>
<p>Sometimes we might also just choose the bear the cost. For systems with low risk profiles (eg internal software that is never exposed to hostile input) we might decide that debugging the occasional use-after-free is preferable to adding development friction.</p>
<p>There are certainly systems though where none of the above are options. For example, the web spec pretty much mandates that browsers must have complicated ownership models, use pervasive sharing between threads and be constantly exposed to hostile inputs. In such cases it&#39;s hard to make an argument for zig, unless alongside some additional system of protection like <a href="https://securityintelligence.com/memgc-use-after-free-exploit-mitigation-in-edge-and-ie-on-windows-10/">memgc</a> or <a href="https://hacks.mozilla.org/2020/02/securing-firefox-with-webassembly/">rlbox</a>.</p>

</article></div>
  </body>
</html>
