<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nibblestew.blogspot.com/2023/10/could-we-make-c-arrays-memory.html">Original</a>
    <h1>Could we make C arrays memory safe? Probably not, but let&#39;s try</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-1617506013501928439" itemprop="description articleBody">
<h2>Preamble</h2><p>This is a project that I have wanted to implement for a long time. However it has become quite clear that I don&#39;t have the time to do it. Thus you get this blog post instead. If someone wants to try to do this on their own, feel free. If you succeed, it would improve computer security by a fair bit.</p><p>Nothing in this blog post is actually new. Similar ideas have been posted in research papers <a href="https://homes.cs.washington.edu/~mernst/pubs/array-indexing-issta2018.pdf">such as this one</a>. AFAICT no-one has done a full scale implementation for C.</p><p>Even if the scheme worked (it is entirely possible that it can not be feasibly implemented), it would still not make C a memory safe language by any stretch of the imagination. There are many other sources of memory unsafety in C. But it would make it somewhat safer, which would be a good thing all considered.</p><p>Suppose we have the following very simple C function:</p><p><span>int do_indexing(int *buf, const size_t bufsize, size_t index) {</span></p><p><span>    return buf[index];</span></p><p><span>}</span></p><p>Is this memory safe? Obviously not. There is no guarantee that the <span>index</span> variable points to a valid array entry (we assume that <span>bufsize</span> is always correct for simplicity). Let&#39;s do this then:</p><p><span>int do_indexing(int *buf, const size_t bufsize, size_t index) {</span></p><p><span>    if(index &lt; bufsize)</span></p><p><span>      return buf[index];</span></p><p><span>    return -1;</span></p><p><span>}</span></p><p>Assuming <span>bufsize</span> is a valid size of the array, then yes, this is memory safe (<span>size_t</span> is unsigned and is used to simplify the checking logic, signed integers behave the same but need two checks). What we want to achieve is to make the first version emit a compiler warning (or error) whereas the latter would not. First we need to tell the compiler that <span>bufsize</span> defines the array size. The GCC page on function attributes does not seem to provide such a thing, so let&#39;s invent our own magic syntax for it:</p><p><span>int do_indexing(int *buf, </span></p><p><span>    const size_t bufsize [[arraysize_of:buf]], </span></p><p><span>    size_t index);</span></p><p>We&#39;re going to leave this out in subsequent code samples for simplicity. This is just an attribute, it does not affect ABI, code generation or anything else.</p><p>Now the compiler can in fact verify that the latter example is safe. When <span>buf</span> is dereferenced we know that the value of <span>index</span> is nonnegative and less than the size of the array.</p><p>Similarly the compiler can diagnose that the first example can lead to a buffer overflow, because the value of <span>index</span> can be anything.</p><p>In other words, now we have a system where the programmer has to write a formal proof that the index is valid before being allowed to use it in a dereferencing operation. This has roughly the same basic idea as the borrow checker in Rust, where the programmer needs to provide a formal proof that they are the only one holding an object before being allowed to mutate it.</p><p>What this scheme requires is to know each variable&#39;s <i>domain</i>, that is, the range of possible values it could have. Then on every array dereference the domain of the index must not be wider than the domain of the array size variable. Let&#39;s go through the sample function step by step.</p><div><p><span>int do_indexing(int *buf, const size_t bufsize, size_t index) {</span></p><p><span>    // domain of bufsize: unknown</span></p><p><span>    // domain of index: unknown</span></p><p><span>    if(index &lt; bufsize)</span></p><p><span>      // domain of bufsize: not zero</span></p><p><span>      // domain of index: [0, bufsize)</span></p><p><span>      return buf[index]; // Index is formally valid.</span></p><p><span>    return -1;</span></p><p><span>}</span></p></div><p>After the check we know that <span>bufsize</span> is not zero (because there exists an integer smaller than it) and that index is valid.</p><p>The problem thus reduces to determining the worst possible domain a variable could hold. For example an if branch:</p><p><span>// Domain of index: [0, bufsize)</span></p><p><span>if(something())</span></p><p><span>    ++index;</span></p><p><span>//Domain of index: [1, bufsize+1)</span></p><p><span>return array[index]; // Error, index not valid</span></p><p>Loops with a known amount of iterations follow from this by assuming the worst case for both bounds:</p><p><span>// Domain of index: [a, b]</span></p><p><span>for(int i=0; i&lt;count; ++i) {</span></p><p><span>    if(something())</span></p><p><span>        ++index;</span></p><p><span>    else</span></p><p><span>        --index;</span></p><p><span>}</span></p><p><span>// Domain of index: [a-count, b+count]</span></p><p><span>// Detect underflow if a &lt; count.</span></p><p><span>// Detect overflow if b &gt;= MAX_SIZE_T - count</span></p><p>A loop that runs an unknown number of times is surprisingly even simpler.</p><div><p><span>// Domain of index: [a, b)</span></p><p><span>while(keep_going()) {</span></p><p><span>    if(something())</span></p><p><span>        ++index;</span></p><p><span>    else</span></p><p><span>        --index;</span></p><p><span>}</span></p><p><span>// Domain of index: unknown</span></p></div><p>The checker does not need to be able to determine what the true domain is. It can merely throw up its hands and require the developer to add the necessary checks between this block and any subsequent array indexing operations.</p><p>If you want to get even fancier, you could create a second pragma for the index value, like so:</p><div><p><span>int do_indexing(int *buf, </span></p><p><span>    const size_t bufsize [[arraysize_of:buf]], </span></p><p><span>    size_t index [[arrayindex_of:buf]]</span></p><p><span>);</span></p></div><p>You would only be allowed to call this function after formally proving that the domain of <span>index</span> is <span>[0, bufsize)</span>. This would give you array indexing operations that are both memory safe <i>and</i> fast as it can do the array dereferences without any runtime overhead (i.e. bounds checking). In theory you could also leave out the middle argument and still have safe dereferencing operations but a decent optimizer should be able to inline the function and optimize it out.</p><p>Suppose the value of <span>bufsize</span> is not constant and you do this:</p><p><span>// Domain of index: [0, bufsize]</span></p><p><span>shrink_buffer_by_one(&amp;buf, &amp;bufsize);</span></p><p><span>return buf[index]; // NOT SAFE</span></p><p>If the size of the array can change, then the domain might not be correct. In this case you&#39;d need to store that the max value is <span>bufsize</span> at an earlier point in the program, not the current value. A full implementation would get quite complicated quite quickly.</p>

</div></div>
  </body>
</html>
