<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nickdrozd.github.io/2023/10/27/python-eval.html">Original</a>
    <h1>`eval` should not be a built-in function</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>Python provides 70 or so <strong><em><a href="https://docs.python.org/3/library/functions.html">built-in functions</a></em></strong>. These are functions that are immediately available and do not need to be imported from a module. Built-ins provide <strong>basic, broadly-applicable</strong> functionality. For example: <code>print</code>, <code>range</code>, <code>len</code>, <code>abs</code>, <code>enumerate</code>, etc. Anyone who writes Python code will end up using some of these functions at some point.</p>

<p>One built-in function is not like the others: <a href="https://docs.python.org/3/library/functions.html#eval"><strong><code>eval</code></strong></a>. This function accepts a string argument and returns the value of the string when evaluated as Python code. Built-in functions ought to be basic and broadly-applicable. But <code>eval</code> is neither: it is at once <strong>extraordinarily powerful</strong> and <strong>practically useless</strong>. Not useless in the sense that it cannot be put to any use, because it certainly can be; but useless in the sense that it is almost certainly the wrong tool to use.<sup><a id="fnr.1" href="#fn.1" role="doc-backlink">1</a></sup></p>

<p>I can’t think of any reason why <code>eval</code> should be made immediately globally available to all Python programmers. Its inclusion as a built-in goes back at least as far as <strong><a href="https://docs.python.org/release/1.4/lib/node26.html#SECTION00330000000000000000">Python 1.4</a></strong> from 1996. The Python userbase back then must have been very different from what it is today. Perhaps it had a much higher percentage of hardcore programmers who had legitimate uses for <code>eval</code> as well as an understanding of why it should not be used. Or perhaps it was a bad idea at the time too.</p>

<p>To be clear, I am not advocating for getting rid of <code>eval</code>. It has its place in certain <strong>code-generation tasks</strong>. Libraries like Pytest and Pydantic and the standard <code>dataclass</code> module use it for things like dynamic class generation and runtime object introspection<sup><a id="fnr.2" href="#fn.2" role="doc-backlink">2</a></sup>.</p>

<p>Instead, what’s needed is some <strong>anti-discoverability</strong>. It’s too easy to just happen upon <code>eval</code>; and anyone who just happens upon <code>eval</code> definitely should not use it. Including it as a built-in creates the illusion that it is fine and reasonable to use the function casually. It shouldn’t be used casually, and there should be a <strong>daunting barrier</strong> to indicate this. The simplest way to do this would be require importing it from a scary-looking module, like one of the <a href="https://docs.python.org/3/library/language.html">Python language services</a>.</p>

<p><strong>Personally, I have found exactly one good use for <code>eval</code>.</strong> It had to do with code for representing arithmatic expressions. There was, for example, an <code>Exponent</code> class to represent expressions like <em>2<sup>3</sup></em>. I wanted this to be stringified as valid Python, as in <code>2 ** 3</code>. To verify this, I added some test code along the lines of:</p>

<figure><pre><code data-lang="python"><span>assert</span> <span>int</span><span>(</span><span>exp</span> <span>:</span><span>=</span> <span>Exponent</span><span>(</span><span>2</span><span>,</span> <span>3</span><span>))</span> <span>==</span> <span>eval</span><span>(</span><span>str</span><span>(</span><span>exp</span><span>))</span></code></pre></figure>

<p>Notice that this is a <em>code-generation task</em>: I am actually trying to create some Python code, and so it is reasonable to consider <code>eval</code>. Notice as well that this was only done in <strong>test code</strong>, where standards are generally a little looser.</p>

<p><strong>In the wild</strong> I’ve run across three uses of <code>eval</code>, each one terrible:</p>

<ol>
  <li>
    <p>Four functions were defined to get times: <code>days</code>, <code>weeks</code>, <code>months</code>, and <code>years</code>. A string argument <code>period</code> was passed in to determine which would be called. The appropriate time function was called as follows: <code>eval(period + &#39;()&#39;)</code>. <strong>Woof</strong>. A dramatically simpler and safer way is to stick the functions in a dictionary and then key in with the string argument.</p>
  </li>
  <li>
    <p>A list of file names was defined, along with a bunch of strings like <code>&#39;os.sep&#39;</code>. These strings were then all appended together, passed to <code>eval</code>, and then passed on to some path-manipulation functions. I never figured out what exactly it was doing, though it was nevertheless obvious that <code>eval</code> was not being used appropriately.</p>
  </li>
  <li>
    <p>A new report was added to a boring business web app. The report contained some fancy nested tables, and the tables were dynamically generated based on a query paremter, say <code>?name=business_asset</code>. The name <code>business_asset</code> was not statically available, but it was expected that at runtime there would be a variable called <code>business_asset</code>. And wouldn’t you know it, <code>eval(request.args.get(&#39;name&#39;))</code> was used to get that the value of that variable. Yes, <strong>the query parameter was passed directly into <code>eval</code></strong>, exactly the thing that everyone says to watch out for. In that situation, problems can arise if a user passes in a “name” like <code>&#39;__import__(&#34;os&#34;).listdir()&#39;</code> or something similar. (Although this use of <code>eval</code> was dangerous, I can see why it was done. This issue was fixed by replacing it with safe code, and that safe code turned out to be ugly and hard to understand.)</p>
  </li>
</ol>

<p>The change I am proposing probably would have prevented the first two of these three uses. The third one would have happened anyway – indeed, that use of <code>eval</code> was accompanied by a pragma comment: <strong><code># pylint: disable = eval-used</code></strong>.</p>



<p><sup><a id="fn.1" href="#fnr.1">1</a></sup> <code>exec</code> is a built-in function that is subtly different from <code>eval</code> in terms of how it is called, but identical in spirit. Everything said here about <code>eval</code> applies to <code>exec</code>. Actually, in Python 2 <code>exec</code> was a <em>statement</em> rather than a <em>function</em>, which is much worse.</p>

<p><sup><a id="fn.2" href="#fnr.2">2</a></sup> Even in those cases where it can be used, it may still not be the best choice. As Paul Graham once said, <em>“calling <code>eval</code> explicitly is like buying something in an airport gift-shop. Having waited till the last moment, you have to pay high prices for a limited selection of second-rate goods.”</em></p>

  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
