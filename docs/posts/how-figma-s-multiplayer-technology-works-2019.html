<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.figma.com/blog/how-figmas-multiplayer-technology-works/">Original</a>
    <h1>How Figma’s multiplayer technology works (2019)</h1>
    
    <div id="readability-page-1" class="page"><div><div colorscheme="[object Object]"><p>When we first started <a href="https://www.figma.com/blog/multiplayer-editing-in-figma/">building multiplayer functionality</a></p><p> in <a href="https://www.figma.com" target="_blank" rel="noreferrer">Figma</a> four years ago, we decided to develop our own solution. No other design tool offered this feature, and we didn’t want to use operational transforms (a.k.a. OTs), the standard multiplayer algorithm popularized by apps like Google Docs. As a startup we value the ability to ship features quickly, and OTs were unnecessarily complex for our problem space. So we built a custom multiplayer system that&#39;s simpler and easier to implement.</p><div><p><a href="https://www.figma.com/blog/introducing-figma-community/"><img src="data:image/jpeg;base64,/9j/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAAJABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAMGBQf/xAAnEAACAgEBBgcBAAAAAAAAAAACAwEEAAUGITEzc7EREjI2QWFxdP/EABYBAQEBAAAAAAAAAAAAAAAAAAQAAf/EAB8RAAEEAgIDAAAAAAAAAAAAAAEAAgMRBCESE2Gh0f/aAAwDAQACEQMRAD8A7lRpeRVtNtSyCJgQOfSz9j4xli7USCy1AUpVBQAkB+O/hEY+zyT6kZJbVe0rH9cd8Hiz2XxsHENAqvN/FZ0hjj7js79KjnazSVPemy1iGKZISJxx3Rvj6wzB1Hmq6QdsMYsabAK//9k=" alt="Figma logo surrounded by abstract UI elements" data-lqip="true"/><img data-loading="true" loading="lazy" alt="Figma logo surrounded by abstract UI elements" src="https://cdn.sanity.io/images/599r6htc/regionalized/4318861f261dfea4e4de7829e8a1ee1738833dd8-2120x1000.webp?w=2120&amp;h=1000&amp;q=75&amp;fit=max&amp;auto=format" srcset="https://cdn.sanity.io/images/599r6htc/regionalized/4318861f261dfea4e4de7829e8a1ee1738833dd8-2120x1000.webp?q=75&amp;fit=max&amp;auto=format&amp;dpr=0.5 1060w, https://cdn.sanity.io/images/599r6htc/regionalized/4318861f261dfea4e4de7829e8a1ee1738833dd8-2120x1000.webp?q=75&amp;fit=max&amp;auto=format&amp;dpr=0.75 1590w, https://cdn.sanity.io/images/599r6htc/regionalized/4318861f261dfea4e4de7829e8a1ee1738833dd8-2120x1000.webp?q=75&amp;fit=max&amp;auto=format&amp;dpr=2 2120w"/></a></p></div><p>At the time, we weren’t sure building this feature was the right product decision. No one was clamoring for a multiplayer design tool—if anything, people hated the idea. Designers worried that live collaborative editing would result in “hovering art directors” and “design by committee” catastrophes.</p><p>But ultimately, we had to do it because it just felt wrong not to offer multiplayer as a tool on the web. It eliminates the need to export, sync, or email copies of files and allows more people to take part in the design process (like copy-writers and developers). Just by having the right link, everyone can view the current status of a design project without interrupting the person doing the work.</p><p>Our bet paid off, and these days it’s obvious that multiplayer is the way all productivity tools on the web should work, not just design. But while we use products with live collaborative editing every day, there aren’t that many public case studies on these production systems.</p><p>We decided it was time to share a peek into how we did it at Figma, in the hopes of helping others. It should be a fun read for those who like seeing how computer science theory is applied in practice. We’ll cover a lot but each section builds upon the previous ones. By the end, you should hopefully have an understanding of the entire system.</p><h2 id="background-context-figma-s-setup-ots-and-more"><a href="#background-context-figma-s-setup-ots-and-more">Background context: Figma’s setup, OTs, and more</a></h2><p>Before talking about our multiplayer protocol, it&#39;s useful to have some context about how our multiplayer system is set up. We use a client/server architecture where Figma clients are web pages that talk with a cluster of servers over WebSockets. Our servers currently spin up a separate process for each multiplayer document which everyone editing that document connects to. If you’re interested in learning more, <a href="https://www.figma.com/blog/rust-in-production-at-figma/">this article</a></p><p> talks about how we scale our production multiplayer servers.</p><div><p><a href="https://www.figma.com/blog/rust-in-production-at-figma/"><img src="data:image/jpeg;base64,/9j/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAAJABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAQHCP/EACEQAAEEAgICAwAAAAAAAAAAAAIAAQMEBREGMQcSITNB/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/AMw4aOtLlaoXzcKpSC0hN+Dv5VE8sYridLHU5eNSi8zl6kIlvY67UvbtMWPqFAshCEH/2Q==" alt="Rust logo" data-lqip="true"/><img data-loading="true" loading="lazy" alt="Rust logo" src="https://cdn.sanity.io/images/599r6htc/regionalized/9b191bec39eaafd24d76dc589e4d68c54a7706dc-2120x1000.webp?w=2120&amp;h=1000&amp;q=75&amp;fit=max&amp;auto=format" srcset="https://cdn.sanity.io/images/599r6htc/regionalized/9b191bec39eaafd24d76dc589e4d68c54a7706dc-2120x1000.webp?q=75&amp;fit=max&amp;auto=format&amp;dpr=0.5 1060w, https://cdn.sanity.io/images/599r6htc/regionalized/9b191bec39eaafd24d76dc589e4d68c54a7706dc-2120x1000.webp?q=75&amp;fit=max&amp;auto=format&amp;dpr=0.75 1590w, https://cdn.sanity.io/images/599r6htc/regionalized/9b191bec39eaafd24d76dc589e4d68c54a7706dc-2120x1000.webp?q=75&amp;fit=max&amp;auto=format&amp;dpr=2 2120w"/></a></p></div><p>When a document is opened, the client starts by downloading a copy of the file. From that point on, updates to that document in both directions are synced over the WebSocket connection. Figma lets you go offline for an arbitrary amount of time and continue editing. When you come back online, the client downloads a fresh copy of the document, reapplies any offline edits on top of this latest state, and then continues syncing updates over a new WebSocket connection. This means that connecting and reconnecting are very simple and all of the complexity with multiplayer (which is what this blog post is about) is in dealing with updates to already connected documents.</p><p>It’s worth noting that we only use multiplayer for syncing changes to Figma documents. We also sync changes to a lot of other data (comments, users, teams, projects, etc.) but that is stored in Postgres, not our multiplayer system, and is synced with clients using a completely separate system that won’t be discussed in this article. Although these two systems are similar, they have separate implementations because of different tradeoffs around certain properties such as performance, offline availability, and security.</p><p>We didn&#39;t start with this setup though. When making a change this fundamental, it&#39;s important to be able to iterate quickly and experiment before committing to an approach. That&#39;s why we first created a prototype environment to test our ideas instead of working in the real codebase. This playground was a web page that simulated three clients connecting to a server and visualized the whole state of the system. It let us easily set up different scenarios around offline clients and bandwidth limited connections.</p><p>Once we figured out how we wanted to build our multiplayer system, it was straightforward to graft the ideas from our prototype onto our existing codebase. We used this prototype to quickly research and evaluate different collaborative algorithms and data structures.</p><div><figure><div><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsSAAALEgHS3X78AAABrklEQVQoz11RS5KqQBDk/tfxCC504e6NYYQLBUUaaL4N3Q0I5FTV6HzeogKiIyszKzMIwxBN08B7D2utfJ1ziOMYh8MB2+0W+/0e5/P5D44x0zRhGAYkSYLdbofNZoPgcrmgKApUVYUsy9C2LcZxlIW6rpHnOe73O6Io+g/X4EmE8zyLiNYap9MJwfV6RZZmSNOUlkKo5AFjGlL2WJYF67qi6zpxwURfuAhKfeGYbFlWcauUQpBmCmVdoSFnWudIHnfk9MYkDOLpOoO8yFARrhWcFmGdZ+j7ToQZx6KBymMUpoQdnJzZMDlNT4RlWeJ2u+EaXfDIItSmgqPMnPOSJw/vPJ9P+XI0AYN1XaB3Pan1EjgH7b2TE47HIz6O/3CLQyKs4bi0V3GM47zZHe+xuJSiC/0nbAa8Vd/vOcVh6PSeFjkO/3LGpXDOTCwnv0tR6hU2l0Kkg/8phYPn85iIh/+lOG+l6RX4KSVJuZRCnH2HTW74/Lc6N94SQUexeMnQSlHW9uKMMd+Eqk5RW4VhtpjoBHZgjBEAA+WcwaJs6WxbwM+DOB/HSchYFL8cfgKwMvf3omTo3AAAAABJRU5ErkJggg==" alt="A screenshot of our internal prototype" width="804" height="403" data-lqip="true"/><img data-loading="true" width="804" height="403" loading="lazy" alt="A screenshot of our internal prototype" src="https://cdn.sanity.io/images/599r6htc/regionalized/e8a6196bdd0f029131c81e45cc44e3dbf908e412-1500x751.png?rect=1,0,1498,751&amp;w=804&amp;h=403&amp;q=75&amp;fit=max&amp;auto=format" srcset="https://cdn.sanity.io/images/599r6htc/regionalized/e8a6196bdd0f029131c81e45cc44e3dbf908e412-1500x751.png?w=804&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=0.5 402w, https://cdn.sanity.io/images/599r6htc/regionalized/e8a6196bdd0f029131c81e45cc44e3dbf908e412-1500x751.png?w=804&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=0.75 603w, https://cdn.sanity.io/images/599r6htc/regionalized/e8a6196bdd0f029131c81e45cc44e3dbf908e412-1500x751.png?w=804&amp;q=75&amp;fit=max&amp;auto=format 804w, https://cdn.sanity.io/images/599r6htc/regionalized/e8a6196bdd0f029131c81e45cc44e3dbf908e412-1500x751.png?w=804&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=1.5 1206w, https://cdn.sanity.io/images/599r6htc/regionalized/e8a6196bdd0f029131c81e45cc44e3dbf908e412-1500x751.png?w=804&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=2 1498w"/></p></div><figcaption>A screenshot of our internal prototype</figcaption></figure></div><div><div><p><img src="data:image/jpeg;base64,/9j/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAAbABQDASIAAhEBAxEB/8QAGQAAAgMBAAAAAAAAAAAAAAAAAAYDBwgF/8QAJxAAAQMDAwQBBQAAAAAAAAAAAgEDBAAFEQYSMQcTQVEIISMyNEL/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/8QAFBEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEQMRAD8AsjqS2RalZaBREnVQMlwlLtxglDlGx3AcUOVHzSr1m1Dcrf1VQJYELLJisc0XAoK+/dTXPUbTN0SVGLvxlRFkkC52580DC20W3laKsO1aXiTbdHktyD2PAhpkU4VKKCmPkhcbVdp9seakDkVJt1Q/LavC0naNs9imNME5eHsI5hxOFIfVcPXJKd/JTXcuwU+tKj32JxKyqhhf5XFBsBrV1viMtx4k0uw0KAGV8JRWW4Nwl9j9hzlfNFB//9k=" alt="Douglas Engelbart" data-lqip="true"/><img data-loading="true" loading="lazy" alt="Douglas Engelbart" src="https://cdn.sanity.io/images/599r6htc/regionalized/49450fd4c6833ef369a4cfa5f65b3a6bf56bcc7e-440x604.jpg?w=440&amp;h=604&amp;q=75&amp;fit=max&amp;auto=format" srcset="https://cdn.sanity.io/images/599r6htc/regionalized/49450fd4c6833ef369a4cfa5f65b3a6bf56bcc7e-440x604.jpg?q=75&amp;fit=max&amp;auto=format&amp;dpr=0.5 220w, https://cdn.sanity.io/images/599r6htc/regionalized/49450fd4c6833ef369a4cfa5f65b3a6bf56bcc7e-440x604.jpg?q=75&amp;fit=max&amp;auto=format&amp;dpr=0.75 330w, https://cdn.sanity.io/images/599r6htc/regionalized/49450fd4c6833ef369a4cfa5f65b3a6bf56bcc7e-440x604.jpg?q=75&amp;fit=max&amp;auto=format&amp;dpr=2 440w"/></p><h6>Douglas Engelbart practicing for &#34;The Mother of All Demos&#34;</h6></div></div><h3 id="how-ots-and-crdts-informed-our-multiplayer"><a href="#how-ots-and-crdts-informed-our-multiplayer">How OTs and CRDTs informed our multiplayer approach</a></h3><p>Multiplayer technology has a rich history and has arguably been around at least since <a href="https://en.wikipedia.org/wiki/The_Mother_of_All_Demos" target="_blank" rel="noreferrer">Douglas Engelbart&#39;s demo in 1968</a>. Before we dive in too deep into how our own multiplayer system works, it’s worth a quick overview on the traditional approaches that informed ours: OTs and CRDTs.</p><div><div><h6>Critique of OT</h6><p>While the classic OT approach of defining operations through their offsets in the text seems to be simple and natural, <a href="https://en.wikipedia.org/wiki/Operational_transformation#Critique_of_OT" target="_blank" rel="noreferrer">real-world distributed systems raise serious issues</a>. Namely, that operations propagate with finite speed, states of participants are often different, thus the resulting combinations of states and operations are extremely hard to foresee and understand. As Li and Li put it, &#34;Due to the need to consider complicated case coverage, formal proofs are very complicated and error-prone, even for OT algorithms that only treat two characterwise primitives (insert and delete).&#34;</p></div></div><p>As mentioned earlier, OTs power most collaborative text-based apps such as Google Docs. They’re the most well-known technique but in researching them, we quickly realized they were overkill for what we wanted to achieve. They’re a great way of editing long text documents with low memory and performance overhead, but they are very complicated and hard to implement correctly. They result in a combinatorial explosion of possible states which is <a href="https://en.wikipedia.org/wiki/Operational_transformation#Critique_of_OT" target="_blank" rel="noreferrer">very difficult to reason about</a>.</p><p>Our primary goal when designing our multiplayer system was for it to be no more complex than necessary to get the job done. A simpler system is easier to reason about which then makes it easier to implement, debug, test, and maintain. Since Figma isn&#39;t a text editor, we didn&#39;t need the power of OTs and could get away with something less complicated.</p><div><div><h6>Conflict-free replicated data type</h6><div><p>In distributed computing, a <a href="https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type" target="_blank" rel="noreferrer">conflict-free replicated data type (CRDT)</a> is a data structure that is replicated across multiple computers in a network, with the following features:</p><ol><li>The application can update any replica independently, concurrently and without coordinating with other replicas.</li><li>An algorithm (itself part of the data type) automatically resolves any inconsistencies that might occur.</li><li>Although replicas may have different state at any particular point in time, they are guaranteed to eventually converge.</li></ol></div></div></div><p>Figma&#39;s tech is instead inspired by something called CRDTs, which stands for <a href="https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type" target="_blank" rel="noreferrer">conflict-free replicated data types</a>. CRDTs refer to a collection of different data structures commonly used in distributed systems. All CRDTs satisfy certain mathematical properties which guarantee eventual consistency. If no more updates are made, eventually everyone accessing the data structure will see the same thing. This constraint is required for correctness; we cannot allow two clients editing the same Figma document to diverge and never converge again.</p><p>There are many types of CRDTs. See <a href="https://github.com/pfrazee/crdt_notes/tree/68c5fe81ade109446a9f4c24e03290ec5493031f#portfolio-of-basic-crdts" target="_blank" rel="noreferrer">this list</a> for a good overview. Some examples:</p><ul><li><strong>Grow-only set:</strong> This is a set of elements. The only type of update is to add something to the set. Adding something twice is a no-op, so you can determine the contents of the set by just applying all of the updates in any order.</li><li><strong>Last-writer-wins register:</strong> This is a container for a single value. Updates can be implemented as a new value, a timestamp, and a peer ID. You can determine the value of the register by just taking the value of the latest update (using the peer ID to break a tie).</li></ul><p>Figma isn&#39;t using true CRDTs though. CRDTs are designed for decentralized systems where there is no single central authority to decide what the final state should be. There is some unavoidable performance and memory overhead with doing this. Since Figma is centralized (our server is the central authority), we can simplify our system by removing this extra overhead and benefit from a faster and leaner implementation.</p><p>It’s also worth noting that Figma&#39;s data structure isn&#39;t a single CRDT. Instead it&#39;s inspired by multiple separate CRDTs and uses them in combination to create the final data structure that represents a Figma document (described below).</p><p>Even if you have a client-server setup, CRDTs are still worth researching because they provide a well-studied, solid foundation to start with. Understanding them helps build intuition on how to create a correct system. From that point, it&#39;s possible to relax some of the requirements of CRDTs based on the needs of the application as we have done.</p><h3 id="how-a-figma-document-is-structured"><a href="#how-a-figma-document-is-structured">How a Figma document is structured</a></h3><p>Ok, so we want to sync updates to Figma documents using CRDTs. What does the structure of a Figma document even look like?</p><div><div><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAABSUlEQVQokYWR2W7FIAxEA0kgbMZsCYnJXfr/H1k1tLeVWqnnCQmPPR4Pwy8YY1JKRCwXiCilZIz9rvwDxpgQAhHXC0QUQvwvZhecc6VUKeW8KKUsy/K3mHM+TdP8RX9ba2utbxe1VmutEKL/cs6/G2mtETHnjIjGGCmlEEIp5ZyLFwDgnAsh9P2XZRnH8VPvvT+O436/55y11r39T+Z5NsZs2/Z8Pomo5/c533tPRC+xUspaCwBaayGElNJam3Pe9721RkT7vqeU+pgBEVtrj8ejlOKc897XWntO3nsAWNf1PM9aa4yxp3i73VJKxpgBAGqtrbUYo7nw3qeUAMBe9LExxu5oXVci6sWDc27bNiIKISilpmkax7FvK4QwxpRSjuMIIRhjuri11m1+2H7trJTinL8OPs+zc27f9/M8c84AEGMkop5cCOEdjxAf1XtuTDcAAAAASUVORK5CYII=" alt="DOM HTML tree" data-lqip="true"/><img data-loading="true" loading="lazy" alt="DOM HTML tree" src="https://cdn.sanity.io/images/599r6htc/regionalized/70a805a5416a06ccc4f5cb6096c4324a9d950b82-486x266.png?w=486&amp;h=266&amp;q=75&amp;fit=max&amp;auto=format" srcset="https://cdn.sanity.io/images/599r6htc/regionalized/70a805a5416a06ccc4f5cb6096c4324a9d950b82-486x266.png?q=75&amp;fit=max&amp;auto=format&amp;dpr=0.5 243w, https://cdn.sanity.io/images/599r6htc/regionalized/70a805a5416a06ccc4f5cb6096c4324a9d950b82-486x266.png?q=75&amp;fit=max&amp;auto=format&amp;dpr=0.75 365w, https://cdn.sanity.io/images/599r6htc/regionalized/70a805a5416a06ccc4f5cb6096c4324a9d950b82-486x266.png?q=75&amp;fit=max&amp;auto=format&amp;dpr=2 486w"/></p><h6>HTML DOM</h6><p>The <a href="https://www.w3schools.com/js/js_htmldom.asp#:~:text=The%20HTML%20DOM%20is%20a,to%20access%20all%20HTML%20elements" target="_blank" rel="noreferrer">HTML Document Object Model (DOM)</a> is a standard object model and programming interface for HTML. It defines: The HTML elements as objects, the properties of all HTML elements, the methods to access all HTML elements, and the events for all HTML elements.</p></div></div><p>Every Figma document is a tree of objects, similar to the HTML DOM. There is a single root object that represents the entire document. Underneath the root object are page objects, and underneath each page object is a hierarchy of objects representing the contents of the page. This tree is is presented in the layers panel on the left-hand side of the Figma editor.</p><p>Each object has an ID and a collection of properties with values. One way to think about this is by picturing the document as a two-level map: <code>Map&lt;ObjectID, Map&lt;Property, Value&gt;&gt;</code>. Another way to think about this is a database with rows that store <code>(ObjectID, Property, Value)</code> tuples. This means that adding new features to Figma usually just means adding new properties to objects.</p><h2 id="the-details-of-figma-s-multiplayer-system"><a href="#the-details-of-figma-s-multiplayer-system">The details of Figma’s multiplayer system</a></h2><p>For the rest of this post, we will talk about the details of Figma&#39;s multiplayer algorithm and how we solved some of the edge cases we encountered.</p><h3 id="syncing-object-properties"><a href="#syncing-object-properties">Syncing object properties</a></h3></div></div><div><div colorscheme="[object Object]"><p>Figma’s multiplayer servers keep track of the latest value that any client has sent for a given property on a given object. This means that two clients changing unrelated properties on the same object won’t conflict, and two clients changing the same property on unrelated objects also won’t conflict. A conflict happens when two clients change the same property on the same object, in which case the document will just end up with the last value that was sent to the server. This approach is similar to a last-writer-wins register in CRDT literature except we don’t need a timestamp because the server can define the order of events.</p><div><figure><div></div><figcaption>An animation showing two clients sending updates without any conflicts</figcaption></figure></div><p>An important consequence of this is that changes are atomic at the property value boundary. The eventually consistent value for a given property is always a value sent by one of the clients. This is why simultaneous editing of the same text value doesn’t work in Figma. If the text value is B and someone changes it to AB at the same time as someone else changes it to BC, the end result will be either AB or BC but never ABC. That’s ok with us because Figma is a design tool, not a text editor, and this use case isn’t one we’re optimizing for.</p><p>The most complicated part of this is how to handle conflicts on the client when there’s a conflicting change. Property changes on the client are always applied immediately instead of waiting for acknowledgement from the server since we want Figma to feel as responsive as possible. However, if we do this and we also apply every change from the server as it comes in, conflicting changes will sometimes “flicker” when older acknowledged values temporarily overwrite newer unacknowledged ones. We want to avoid this flickering behavior.</p><p>Intuitively, we want to show the user our best prediction of what the eventually-consistent value will be. Since our change we just sent hasn’t yet been acknowledged by the server but all changes coming from the server have been, our change is our best prediction because it’s the most recent change we know about in last-to-the-server order. So we want to discard incoming changes from the server that conflict with unacknowledged property changes.</p><div><figure><div></div><figcaption>An animation showing how to avoid “flickering” during a conflict between two clients</figcaption></figure></div><h3 id="syncing-object-creation-and-removal"><a href="#syncing-object-creation-and-removal">Syncing object creation and removal</a></h3><p>Creating a new object and removing an existing object are both explicit actions in our protocol. Objects cannot automatically be brought into existence by writing a property to an unassigned object ID. Removing an object deletes all data about it from the server including all of its properties.</p><p>Object creation in Figma is most similar to a last-writer-wins set in CRDT literature, where whether an object is in the set or not is just another last-writer-wins boolean property on that object. A big difference from this model is that Figma doesn’t store any properties of deleted objects on the server. That data is instead stored in the undo buffer of the client that performed the delete. If that client wants to undo the delete, then it’s also responsible for restoring all properties of the deleted objects. This helps keep long-lived documents from continuing to grow in size as they are edited.</p><p>This system relies on clients being able to generate new object IDs that are guaranteed to be unique. This can be easily accomplished by assigning every client a unique client ID and including that client ID as part of newly-created object IDs. That way no two clients will ever generate the same object ID. Note that we can’t solve this by having the server assign IDs to newly-created objects because object creation needs to be able to work offline.</p><h3 id="syncing-trees-of-objects"><a href="#syncing-trees-of-objects">Syncing trees of objects</a></h3><p>Arranging objects in an eventually-consistent tree structure is the most complicated part of our multiplayer system. The complexity comes from what to do about reparenting operations (moving an object from one parent to another). When designing the tree structure, we had two main goals in mind:</p><ul><li>Reparenting an object shouldn’t conflict with changes to unrelated properties on those objects. If someone is changing the object’s color while someone else is reparenting the object, those two operations should both succeed.</li><li>Two concurrent reparenting operations for the same object shouldn’t ever result in two copies of that object in separate places in the tree.</li></ul><p>Many approaches represent reparenting as deleting the object and recreating it somewhere else with a new ID, but that doesn&#39;t work for us because concurrent edits would be dropped when the object&#39;s identity changes. The approach we settled on was to represent the parent-child relationship by storing a link to the parent as a property on the child. That way object identity is preserved. We also don’t need to deal with the situation where an object somehow ends up with multiple parents that we might have if, say, we instead had each parent store links to its children.</p><p>However, we now have a new problem. Without any other restrictions, these parent links are just directed edges on a graph. There’s nothing to ensure that they have no cycles and form a valid tree. An example of this is a concurrent edit where one client makes A a child of B while another client makes B a child of A. Then A and B are both each other’s parent, which forms a cycle.</p><p>Figma’s multiplayer servers reject parent property updates that would cause a cycle, so this issue can’t happen on the server. But it can still happen on the client. Clients can’t reject changes from the server because the server is the ultimate authority on what the document looks like. So a client could end up in a state where it has both sent the server an unacknowledged change to parent A under B and also received a change from the server that parents B under A. The client’s change will be rejected in the future by the server because it will form a cycle, but the client doesn’t know it yet.</p><div><figure><div></div><figcaption>An animation of a reparenting conflict</figcaption></figure></div><p>Figma’s solution is to temporarily parent these objects to each other and remove them from the tree until the server rejects the client’s change and the object is reparented where it belongs. This solution isn’t great because the object temporarily disappears, but it’s a simple solution to a very rare temporary problem so we didn’t feel the need to try something more complicated here such as breaking these temporary cycles on the client.</p><p>To construct a tree we also need a way of determining the order of the children for a given parent. Figma uses a technique called “fractional indexing” to do this. At a high level, an object’s position in its parent’s array of children is represented as a fraction between 0 and 1 exclusive. The order of an object’s children is determined by sorting them by their positions. You can insert an object between two other objects by setting its position to the average of the positions of the two other objects.</p><div><figure><div></div><figcaption>An animation of reordering using fractional indexing</figcaption></figure></div><p>We’ve already written <a href="https://www.figma.com/blog/realtime-editing-of-ordered-sequences/#fractional-indexing">another article</a> that describes this technique in detail. The important part to mention here is that the parent link and this position must both be stored as a single property so they update atomically. It doesn’t make sense to continue to use the position from one parent when the parent is updated to point somewhere else.</p><div><p><a href="https://www.figma.com/blog/realtime-editing-of-ordered-sequences/#fractional-indexing"><img src="data:image/jpeg;base64,/9j/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAAJABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIEAwj/xAAgEAACAgEDBQAAAAAAAAAAAAABAgADEQQhURIxMoHR/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/EABYRAQEBAAAAAAAAAAAAAAAAAAABMf/aAAwDAQACEQMRAD8A5l0aVmliT0kDY8niNTWbHapMANtlpLX4+5v8guJdSoFzBTkZhFPeED//2Q==" alt="Various arrows with colored shapes on them and number values" data-lqip="true"/><img data-loading="true" loading="lazy" alt="Various arrows with colored shapes on them and number values" src="https://cdn.sanity.io/images/599r6htc/regionalized/cc54a8a0e37737bb221602eb57af2638a62ca9de-2120x1000.webp?w=2120&amp;h=1000&amp;q=75&amp;fit=max&amp;auto=format" srcset="https://cdn.sanity.io/images/599r6htc/regionalized/cc54a8a0e37737bb221602eb57af2638a62ca9de-2120x1000.webp?q=75&amp;fit=max&amp;auto=format&amp;dpr=0.5 1060w, https://cdn.sanity.io/images/599r6htc/regionalized/cc54a8a0e37737bb221602eb57af2638a62ca9de-2120x1000.webp?q=75&amp;fit=max&amp;auto=format&amp;dpr=0.75 1590w, https://cdn.sanity.io/images/599r6htc/regionalized/cc54a8a0e37737bb221602eb57af2638a62ca9de-2120x1000.webp?q=75&amp;fit=max&amp;auto=format&amp;dpr=2 2120w"/></a></p></div><h2 id="implementing-undo"><a href="#implementing-undo">Implementing undo</a></h2><p>Undo history has a natural definition for single-player mode, but undo in a multiplayer environment is inherently confusing. If other people have edited the same objects that you edited and then undo, what should happen? Should your earlier edits be applied over their later edits? What about redo?</p><p>We had a lot of trouble until we settled on a principle to help guide us: if you undo a lot, copy something, and redo back to the present (a common operation), the document should not change. This may seem obvious but the single-player implementation of redo means “put back what I did” which may end up overwriting what other people did next if you’re not careful. This is why in Figma an undo operation modifies redo history at the time of the undo, and likewise a redo operation modifies undo history at the time of the redo.</p><div><figure><div></div><figcaption>An animation showing undo and redo history modification</figcaption></figure></div><h2 id="the-big-takeaways"><a href="#the-big-takeaways">The big takeaways</a></h2><p>We&#39;ve covered a lot! This is the post we wished we could have read when we were first starting our research. It&#39;s one thing to learn about CRDTs in the abstract, but it&#39;s a different thing to find out how those ideas work in practice in a real production system.</p><p>Some of our main takeaways:</p><ul><li>CRDT literature can be relevant even if you&#39;re not creating a decentralized system</li><li>Multiplayer for a visual editor like ours wasn&#39;t as intimidating as we thought</li><li>Taking time to research and prototype in the beginning really paid off</li></ul><p>If you made it this far, you should now have enough information to make your own collaborative tree data structure. And even if your problem space isn&#39;t exactly like ours, I hope this post shows how CRDT research can be a great source of inspiration.</p><svg xmlns="http://www.w3.org/2000/svg" width="93" height="13" fill="none"><circle cx="6.5" cy="6.5" r="6.5" fill="currentColor"></circle><path fill="currentColor" d="M39.834 0h13v13h-13zM86.5 0 93 13H80z"></path></svg><p>Do you love thinking about collaborative editing, distributed systems, or building scalable services? <a href="https://www.figma.com/careers/">We’re hiring</a>!</p></div></div></div>
  </body>
</html>
