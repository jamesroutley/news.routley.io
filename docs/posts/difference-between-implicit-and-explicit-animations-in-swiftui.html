<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://holyswift.app/difference-between-implicit-and-explicit-animations-in-swiftui/">Original</a>
    <h1>Difference Between Implicit and Explicit Animations in SwiftUI</h1>
    
    <div id="readability-page-1" class="page"><div data-id="451a4a3f" data-element_type="widget" data-widget_type="theme-post-content.default"><div><p>Hallo vrijgezellen en getrouwden, Leo hier. Today let’s talk about something that I learned last week that are implicit and explicit animations in SwiftUI.</p><p>I know, I know… You are thinking: “Again is this guy talking about animations in SwiftUI”, but hold with me that I’m sure that you will learn something very interesting today.</p><p>Lately, I’ve been thinking a lot about writing about meta-programming, and I’m not talking about the new Macros in Swift. I’m thinking a lot about how your attitude counts way more as a developer than your hard skill in our daily jobs. I’m sure I wouldn’t be the best person to talk about that since it took more than a decade for me to feel mature talking about soft skills but hey I think now I’m pretty comfortable with mines.</p><p>One thing that was and kinda is still today is talking English all day long at my job. I feel so handicapped because my vocabulary is limited in English compared to my native language but that doesn’t stop me to do my best to over-communicating my ideas and make sure everyone understood what I was saying. </p><p>I’ve been writing about new stuff like the <a href="https://holyswift.app/the-one-swift-5-9-feature-to-start-using-now/">new expressions in Swift 5.9</a> and also I’ve been talking a lot about <a href="https://holyswift.app/judo-the-tool-to-unite-them-all/">new tools such as Judo</a>. One thing that I can share about my last discoveries is that the more I learn, the more certain about my ignorance I have. There is so much to learn out there.</p><p>Well, I think this will continue in another article because this one is about animation.</p><p><span>
<span>
SPONSOR
</span>
<span></span><p>If you’re a mid/senior iOS developer looking to improve your skills and salary level, join this 100% free online crash course. It&#39;s available only until July 30th, so<a onclick="tes" href="https://iosacademy.essentialdeveloper.com/p/ios-architect-crash-course-hs49d0/?utm_source=holyswift%26utm_campaign=essentialdeveloper" target="_blank" rel="nofollow"> click to get it now</a>!</p>
</span></p><p>No more talk, let’s get animated! But first…</p><h2>Painting of The Day</h2><p>The painting I chose today is called <strong>“The Peasant Dance” </strong>a 1568 art piece by <a href="https://www.wikiart.org/en/pieter-bruegel-the-elder">Pieter Bruegel the Elder</a>.</p><p>Pieter Bruegel the Elder was a pivotal Flemish painter from the 16th century, known for his vivid landscapes and scenes of peasant life. His unique perspective and artistry mark the transition between the Renaissance and Baroque periods.</p><p>His masterpieces, like “Hunters in the Snow” and “Peasant Wedding,” showcase a profound understanding of human nature and the rural life of the time. His works have left an enduring legacy, inspiring artists and authors for generations.</p><p>I chose this painting because of the animation that the artist tried to portray in the painting. Everyone is dancing, so they are moving around. Like our views in this article!</p><h2>The Problem – Animations Teleportation Bug in SwiftUI</h2><blockquote><p>You are trying to animate a view but some parts keep jumping around while other animate correctly.</p></blockquote><p>To understand that problem we need first what a <a href="https://developer.apple.com/documentation/swiftui/transaction">transaction</a> in SwiftUI is, let’s have a quick look.</p><h3>What is a Transaction in SwiftUI?</h3><p><strong>Transactions in SwiftUI</strong> are values that contain the context SwiftUI needs to understand when processing current state changes. They are especially important for holding the animation function used to calculate interpolation. Essentially, transactions provide the necessary information for SwiftUI to perform animations and other state-dependent changes in the app.</p><p>Transactions are generated whenever a state changes in a SwiftUI application. They are created based on whether the state change is initiated by explicit or implicit animation declarations and are then propagated throughout the required view hierarchy.</p><p>Transactions are implicitly passed down in the view hierarchy, similar to <strong>environment values</strong>. Their generation and dispatch is tied to the location and logic of explicit and implicit animations. Importantly, transactions cannot be generated or dispatched on their own; they are accompanying information for state changes.</p><p>They can be observed and manipulated using the<a href="https://developer.apple.com/documentation/swiftui/view/transaction(_:)"><strong> .transaction modifier in SwiftUI</strong></a>. For instance, you can use it to monitor and print the animation function or control how and when a new transaction is created. Is not the scope of this article to present that modifier but maybe in the future!</p><p>In the context of animations in SwiftUI, <strong>the transaction holds the animation settings for state changes and is passed down to views that are impacted by these state changes.</strong> When a state change occurs, animatable components (usually conforming to the Animatable protocol) get the context (transaction) of this state change, acquire the animation curve function from the transaction, and use it to calculate the interpolation for the animation.</p><p>Now you already know what a transaction is let’s set up the code for today’s example.</p><h2>Setting up the Code for Animations</h2><p>Copy and paste the simple example below: </p><div><pre data-setting="{&#34;mode&#34;:&#34;swift&#34;,&#34;mime&#34;:&#34;text/x-swift&#34;,&#34;theme&#34;:&#34;ambiance&#34;,&#34;lineNumbers&#34;:true,&#34;lineWrapping&#34;:false,&#34;styleActiveLine&#34;:true,&#34;readOnly&#34;:true,&#34;align&#34;:&#34;&#34;}">import SwiftUI

struct ContentView: View {
    
    @State var isExpanded = false
    
    var body: some View {
        VStack {
            Image(systemName: &#34;globe&#34;)
                .imageScale(.large)
                .foregroundStyle(.tint)
            
            Rectangle()
                .frame(height: isExpanded ? 500 : 100)
            
            Text(&#34;Hello, world!&#34;)
            
            Button {
                isExpanded.toggle()
            } label: {
                Text(&#34;Change Size&#34;)
            }.buttonStyle(.borderedProminent)

        }
        .padding()
    }
}

#Preview {
    ContentView()
}
</pre></div><p>This will create this view: </p><p><img data-lazyloaded="1" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMzUiIGhlaWdodD0iNDgwIiB2aWV3Qm94PSIwIDAgMjM1IDQ4MCI+PHJlY3Qgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6IDAuMTsiLz48L3N2Zz4=" decoding="async" data-src="https://holyswift.app/wp-content/uploads/2023/07/swiftui-animations-implicit-and-explicit-example-147x300.png" alt="swiftui animations implicit and explicit example tutorial learn" width="235" height="480" data-srcset="https://holyswift.app/wp-content/uploads/2023/07/swiftui-animations-implicit-and-explicit-example-147x300.png 147w, https://holyswift.app/wp-content/uploads/2023/07/swiftui-animations-implicit-and-explicit-example-502x1024.png 502w, https://holyswift.app/wp-content/uploads/2023/07/swiftui-animations-implicit-and-explicit-example.png 616w" data-sizes="(max-width: 235px) 100vw, 235px"/></p><p>When you tap the button “Change size” the size of the black rectangle will change accordingly. Right when the user taps the button the rectangle aggressively changes its size followed by the image and the “Hello world” text.</p><p>But that is not what we want. We want our rectangle to change its size with some beautiful animation. </p><p>The first thing that we will try is implicit animations and see the results. But what are implicit animations?</p><h2><strong>Implicit Animations in SwiftUI</strong></h2><p>Implicit animation in SwiftUI is declared with the <code>.animation</code> or <code>.transaction</code> modifier on view branches, indicating what transaction should be created when the state changes. The transaction can be seen as a context that SwiftUI uses to calculate animations when processing state changes.</p><p>When a state change occurs in the application, SwiftUI generates new transactions based on the declaration of implicit animation on the <strong>view branch</strong> that triggered the state change. <strong>These transactions</strong> are then propagated in the required view hierarchy, informing how the animatable components (usually conforming to the <code>Animatable</code> protocol) should interpolate during the state change.</p><p>Implicit animations, as the name suggests, <strong>are created and controlled implicitly by SwiftUI</strong> when certain conditions or state changes occur in the user interface. And that changes everything because you don’t have control over them.</p><p>And also, they can change behavior from one version of SwiftUI to another, so BE CAREFUL using this.</p><p>With that in mind let’s add an explicit animation to our view: </p><div><pre data-setting="{&#34;mode&#34;:&#34;swift&#34;,&#34;mime&#34;:&#34;text/x-swift&#34;,&#34;theme&#34;:&#34;ambiance&#34;,&#34;lineNumbers&#34;:true,&#34;lineWrapping&#34;:false,&#34;styleActiveLine&#34;:true,&#34;readOnly&#34;:true,&#34;align&#34;:&#34;&#34;}">import SwiftUI

struct ContentView: View {
    
    @State var isExpanded = false
    
    var body: some View {
        VStack {
            Image(systemName: &#34;globe&#34;)
                .imageScale(.large)
                .foregroundStyle(.tint)
            
            Rectangle()
                .frame(height: isExpanded ? 500 : 100)
                .animation(.default, value: isExpanded) // add explicit animation here!
            
            Text(&#34;Hello, world!&#34;)
            
            Button {
                isExpanded.toggle()
            } label: {
                Text(&#34;Change Size&#34;)
            }.buttonStyle(.borderedProminent)

        }
        .padding()
    }
}

#Preview {
    ContentView()
}
</pre></div><p>With this change, we could animate the height of our rectangle! That’s really cool, but <strong>something looks odd</strong>. Test the code above and try to discover yourself…</p><p>If you pay attention to the animation that the code below generates you will observe that the Image and the “Hello World” texts are jumping and not moving along with the rectangle resizing animation.</p><p>That is because of what we explained above about implicit animations. Because SwiftUI will add the animation transaction only to the view that the implicit animation happens, other views are not affected by that animate transaction this way not animating them.</p><p>There are several things that you can do to fix that. For example, if you want to <strong>stick with implicit animations, instead of putting the animation modifier in the Rectangle, you could add it to the VStack. </strong></p><p>Then SwiftUI engine would add that animation transaction to all its subviews check the code below:</p><div><pre data-setting="{&#34;mode&#34;:&#34;swift&#34;,&#34;mime&#34;:&#34;text/x-swift&#34;,&#34;theme&#34;:&#34;ambiance&#34;,&#34;lineNumbers&#34;:true,&#34;lineWrapping&#34;:false,&#34;styleActiveLine&#34;:true,&#34;readOnly&#34;:true,&#34;align&#34;:&#34;&#34;}">import SwiftUI

struct ContentView: View {
    
    @State var isExpanded = false
    
    var body: some View {
        VStack {
            Image(systemName: &#34;globe&#34;)
                .imageScale(.large)
                .foregroundStyle(.tint)
            
            Rectangle()
                .frame(height: isExpanded ? 500 : 100)
            
            Text(&#34;Hello, world!&#34;)
            
            Button {
                isExpanded.toggle()
            } label: {
                Text(&#34;Change Size&#34;)
            }.buttonStyle(.borderedProminent)

        }
        .animation(.default, value: isExpanded) // adding implicit animation here solves the jumping view problem too!
        .padding()
    }
}</pre></div><p>See now we are saying to SwiftUI engine to animate all the views that we want!</p><p>However, that could be cumbersome sometimes. Imagine that there are a lot of views involved and you don’t want to hunt around what view you should add the implicit animation to make your code work.</p><p>Now is when the <strong>Explicit Animations</strong> save the day!</p><h2><strong>Explicit Animation in SwiftUI</strong></h2><p>Explicit animation in SwiftUI is created through imperative programming using the global functions <code>withAnimation</code> or <code>withTransaction</code>.</p><p>In explicit animations, regardless of where the <code>withAnimation</code> function is executed, SwiftUI will start dispatching the transaction created by the explicit animation from the root view. No matter the location of the <strong>withAnimation</strong> function execution, <strong>SwiftUI will begin to send the transaction produced by the “explicit animation” starting from the root view</strong>.</p><p>This differs from implicit animations as they are created and controlled <strong>explicitly by the developer</strong>. For instance, if the developer wants an animation to occur in response to a button press (and not in response to a state change), they would use explicit animation.</p><p>Let’s check the example below:</p><div><pre data-setting="{&#34;mode&#34;:&#34;swift&#34;,&#34;mime&#34;:&#34;text/x-swift&#34;,&#34;theme&#34;:&#34;ambiance&#34;,&#34;lineNumbers&#34;:true,&#34;lineWrapping&#34;:false,&#34;styleActiveLine&#34;:true,&#34;readOnly&#34;:true,&#34;align&#34;:&#34;&#34;}">import SwiftUI

struct ContentView: View {
    
    @State var isExpanded = false
    
    var body: some View {
        VStack {
            Image(systemName: &#34;globe&#34;)
                .imageScale(.large)
                .foregroundStyle(.tint)
            
            Rectangle()
                .frame(height: isExpanded ? 500 : 100)
            
            Text(&#34;Hello, world!&#34;)
            
            Button {
                withAnimation { // add the withAnimation explicit animation block here!
                    isExpanded.toggle()
                }
            } label: {
                Text(&#34;Change Size&#34;)
            }.buttonStyle(.borderedProminent)

        }

        .padding()
    }
}

#Preview {
    ContentView()
}
</pre></div><p>And now all the views in the hierarchy have the same transaction with the same interpolation animation function. The animation looks great and we can go all happy to home. </p><p>And we are done!</p><h2>Summary – SwiftUI Animations Implicit Vs Explicit</h2><p>In conclusion, understanding <strong>transactions</strong> in SwiftUI is integral to effectively managing animations in your applications. As we’ve explored, transactions provide the necessary context for SwiftUI to process state changes and carry out the required animations. <strong>They are automatically generated and dispatched whenever a state changes, be it through explicit or implicit animations</strong>.</p><p>By understanding the <strong>distinction between implicit and explicit animations</strong>, and their interaction with transactions, you can exercise greater control over how your views animate. Whether it’s an image or a text field, you can decide how the state change impacts the animation of your elements and ensure a smoother, more intuitive user interface.</p><p>We hope this guide has been helpful in clarifying the role of transactions in SwiftUI and how they can be utilized to enhance your app’s animations.</p><p><strong>Keep experimenting</strong> and exploring these concepts further for creating more engaging and visually appealing apps with SwiftUI.</p><p><em>Fellow Apple Developers</em>, that’s all.</p><p>I hope you liked reading this article as much as I enjoyed writing it. If you want to support this blog you can <a href="https://www.buymeacoffee.com/holyswift" target="_blank" rel="noopener">Buy Me a Coffee</a> or say <em>hello on <a href="https://twitter.com/Leo_Pugliese" target="_blank" rel="noopener">Twitter</a></em>. I’m available on <a href="https://www.linkedin.com/in/leonardo-maia-pugliese/" target="_blank" rel="noopener">LinkedIn</a> or send me an e-mail through the <a href="https://holyswift.app/sponsorship/">contact page</a>.</p><p><a href="https://holyswift.app/sponsorship/">You can likewise <strong>sponsor</strong> this blog</a> so I can get my blog free of ad networks.</p><p>Thanks for the reading and… That’s all folks.</p><p>Image credit: <a href="https://www.wikiart.org/en/anders-zorn/a-portrait-of-the-daughters-of-ramon-subercasseaux">Featured Painting</a></p></div></div></div>
  </body>
</html>
