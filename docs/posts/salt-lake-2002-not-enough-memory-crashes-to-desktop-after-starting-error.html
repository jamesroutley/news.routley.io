<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.vogons.org/viewtopic.php?t=86172">Original</a>
    <h1>Salt Lake 2002 â€“ not enough memory/crashes to desktop after starting error</h1>
    
    <div id="readability-page-1" class="page"><div><p>Hi!</p>

<p>Here&#39;s the very short explanation of the two problems with their quick solutions, basically TL;DR:</p>

<ol data-type="decimal"><li><b><u>Not enough memory when installing:</u></b></li><li><b><u>Crashing to desktop after game launch:</u></b></li>
</ol>

<p>That was the TL;DR. Here are the technical details for anyone interested:</p>

<p><span><b><u>Not enough memory when installing</u></b></span></p>

<p>When the game installer queries your system for how much physical RAM it has, it uses an ancient, long deprecated Windows API called <a href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-globalmemorystatus">GlobalMemoryStatus</a> that basically <a href="https://en.wikipedia.org/wiki/4,294,967,295#In_computing">cannot count above 4GiB due to storing the result in a 32-bit integer</a>.</p>

<p>So if you have more RAM than 4GiB, this API will return a negative number due to integer overflow, <a href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-globalmemorystatus#remarks">as even Microsoft mentions in their API docs</a>. In turn, when the installer script receives this negative number from Windows and then compares it to 64MB (as that is the minimum memory requirement for the game), it will find that this negative amount of memory is less than that and will abort installation with the &#34;There is not enough memory available to install this application. Setup will now exit.&#34; error message.</p>

<p>The installer script was coded in a way that it unfortunately doesn&#39;t recognize when it has received an obviously bogus negative number for the available RAM. The game developers most probably didn&#39;t expect that the game would be run on systems using more than 4GiB of memory. And even if they did - and could have used the more future-proof API (<a href="https://learn.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-globalmemorystatusex">GlobalMemoryStatusEx</a>) which at the time was already available - they most probably opted for this one instead, because the newer API is not supported on Windows 95 and 98.</p>

<p>The installer is instructed to do these checks via its compiled InstallShield script (aka. InstallScript) file, which can be found on the disc as a file called <span>setup.inx</span>.</p>

<p>Here&#39;s a snippet of how this installer script looks like - it has to be decompiled from the <span>setup.inx</span> file using an InstallShield script decompiler tool, I&#39;ve used SID (<a href="https://github.com/tylerapplebaum/setupinxhacking">sexy installshield decompiler</a> by sn00pee):</p>

<p>You can find the code for the decompiled <span>setup.inx</span> file here:</p>

<p><span>function_0</span> is the entry point, this is where the prerequisite checks are done for the installer. On line 926 (or offset <span>@00004D99:0007</span>), there&#39;s this snippet:</p>
<div role="group" aria-label="Code" data-clipboard-source=""><pre><span><span aria-hidden="true">1</span><code role="code"><span role="text presentation">@00004D99:0007   label_4d99:<br/></span></code></span><span><span aria-hidden="true">2</span><code role="code"><span role="text presentation">@00004D9B:0021      GetSystemInfo(185, local_number1, local_string3);<br/></span></code></span><span><span aria-hidden="true">3</span><code role="code"><span role="text presentation">@00004DAC:0009      local_number6 = (local_number1 &lt; 64000);<br/></span></code></span><span><span aria-hidden="true">4</span><code role="code"><span role="text presentation">@00004DBB:0004      if(local_number6) then // ref index: 1<br/></span></code></span><span><span aria-hidden="true">5</span><code role="code"><span role="text presentation">@00004DC7:0021         function_234(&#34;ERROR_MEMORY&#34;);<br/></span></code></span><span><span aria-hidden="true">6</span><code role="code"><span role="text presentation">@00004DDC:0006         local_string12 = LASTRESULT;<br/></span></code></span><span><span aria-hidden="true">7</span><code role="code"><span role="text presentation">@00004DE6:0021         MessageBox(local_string12, -65534);<br/></span></code></span><span><span aria-hidden="true">8</span><code role="code"><span role="text presentation">@00004DF4:0002         abort;<br/></span></code></span><span><span aria-hidden="true">9</span><code role="code"><span role="text presentation">@00004DF8:000B      endif;<br/></span></code></span></pre></div>

<p><span>GetSystemInfo</span> being called with <span>185</span> as its first argument executes the following code:</p>
<div role="group" aria-label="Code" data-clipboard-source=""><pre><span><span aria-hidden="true">1</span><code role="code"><span role="text presentation">@0000A495:0005   label_a495:<br/></span></code></span><span><span aria-hidden="true">2</span><code role="code"><span role="text presentation">@0000A497:000D      local_number5 = (local_number1 = 185);<br/></span></code></span><span><span aria-hidden="true">3</span><code role="code"><span role="text presentation">@0000A4A6:0004      if(local_number5) then // ref index: 1<br/></span></code></span><span><span aria-hidden="true">4</span><code role="code"><span role="text presentation">@0000A4B2:0021         function_190(local_number2);<br/></span></code></span><span><span aria-hidden="true">5</span><code role="code"><span role="text presentation">@0000A4BB:0006         local_number3 = LASTRESULT;<br/></span></code></span><span><span aria-hidden="true">6</span><code role="code"><span role="text presentation">@0000A4C5:0005         goto label_aa2d;<br/></span></code></span><span><span aria-hidden="true">7</span><code role="code"><span role="text presentation">@0000A4CE:0005      endif;<br/></span></code></span></pre></div>

<p>Which in turn executes <span>function_190</span> and returns its result.</p>
<div role="group" aria-label="Code" data-clipboard-source=""><pre><span><span aria-hidden="true">1</span><code role="code"><span role="text presentation">@0000B3B4:0009   label_b3b4:<br/></span></code></span><span><span aria-hidden="true">2</span><code role="code"><span role="text presentation">@0000B3B6:0022   function NUMBER function_190(local_number1)<br/></span></code></span><span><span aria-hidden="true">3</span><code role="code"><span role="text presentation">@0000B3B6           NUMBER local_number2; <br/></span></code></span><span><span aria-hidden="true">4</span><code role="code"><span role="text presentation">@0000B3B6<br/></span></code></span><span><span aria-hidden="true">5</span><code role="code"><span role="text presentation">@0000B3B6           OBJECT local_object1; <br/></span></code></span><span><span aria-hidden="true">6</span><code role="code"><span role="text presentation">@0000B3B6        begin<br/></span></code></span><span><span aria-hidden="true">7</span><code role="code"><span role="text presentation">@0000B3BF:001A      local_number2 = &amp;local_object1;<br/></span></code></span><span><span aria-hidden="true">8</span><code role="code"><span role="text presentation">@0000B3C9:0020      GlobalMemoryStatus(local_number2); // dll: KERNEL32.dll<br/></span></code></span><span><span aria-hidden="true">9</span><code role="code"><span role="text presentation">@0000B3D2:0035      local_object1.nTotalPhys;<br/></span></code></span><span><span aria-hidden="true">10</span><code role="code"><span role="text presentation">@0000B3E6:0006      local_number2 = LASTRESULT;<br/></span></code></span><span><span aria-hidden="true">11</span><code role="code"><span role="text presentation">@0000B3F0:0011      local_number1 = (local_number2 / 1024);<br/></span></code></span><span><span aria-hidden="true">12</span><code role="code"><span role="text presentation">@0000B3FF:0027      // return coming<br/></span></code></span><span><span aria-hidden="true">13</span><code role="code"><span role="text presentation">@0000B403:0023      return 0;<br/></span></code></span><span><span aria-hidden="true">14</span><code role="code"><span role="text presentation">@0000B40C:0026   end; // checksum: 4d013b<br/></span></code></span></pre></div>

<p>The GlobalMemoryStatus call populates a struct (<span>local_object1</span>) with information about the machine&#39;s RAM. The <a href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/ns-winbase-memorystatus#:~:text=full%20memory%20use%29.-,dwTotalPhys,-The%20amount%20of"><span>nTotalPhys</span>/<span>dwTotalPhys</span></a> struct member contains the total physical memory present in the machine in bytes. The code divides it by 1024 to get the total RAM of the machine in kibibytes and then returns that value.</p>
<div role="group" aria-label="Code" data-clipboard-source=""><pre><span><span aria-hidden="true">1</span><code role="code"><span role="text presentation">@00004D99:0007   label_4d99:<br/></span></code></span><span><span aria-hidden="true">2</span><code role="code"><span role="text presentation">@00004D9B:0021      GetSystemInfo(185, local_number1, local_string3);<br/></span></code></span></pre></div>

<p>And then gets compared to 64 000 KiB (a little less than 64 MiB):</p>
<div role="group" aria-label="Code" data-clipboard-source=""><pre><span><span aria-hidden="true">1</span><code role="code"><span role="text presentation">@00004DAC:0009      local_number6 = (local_number1 &lt; 64000);<br/></span></code></span></pre></div>

<p>Since this comparison is done with signed numbers - and as already mentioned, <span>GlobalMemoryStatus</span> returns negative numbers if there are more than 4GiB of RAM - this if-statement will evaluate to true on modern machines with high RAM capacity. This will in turn show the message box with the &#34;not enough memory available&#34; message and abort the installation:</p>
<div role="group" aria-label="Code" data-clipboard-source=""><pre><span><span aria-hidden="true">1</span><code role="code"><span role="text presentation">@00004DBB:0004      if(local_number6) then // ref index: 1<br/></span></code></span><span><span aria-hidden="true">2</span><code role="code"><span role="text presentation">@00004DC7:0021         function_234(&#34;ERROR_MEMORY&#34;);<br/></span></code></span><span><span aria-hidden="true">3</span><code role="code"><span role="text presentation">@00004DDC:0006         local_string12 = LASTRESULT;<br/></span></code></span><span><span aria-hidden="true">4</span><code role="code"><span role="text presentation">@00004DE6:0021         MessageBox(local_string12, -65534);<br/></span></code></span><span><span aria-hidden="true">5</span><code role="code"><span role="text presentation">@00004DF4:0002         abort;<br/></span></code></span><span><span aria-hidden="true">6</span><code role="code"><span role="text presentation">@00004DF8:000B      endif;<br/></span></code></span></pre></div>

<p>Fixing this can be done easily with SID. Changing the comparison into something that would be far less likely to happen on an actual (modern) PC is what I&#39;ve opted for. The way I&#39;ve patched it is to change the less-than operator to an equals operator:</p>
<div role="group" aria-label="Code" data-clipboard-source=""><pre><span><span aria-hidden="true">1</span><code role="code"><span role="text presentation">@00004DAC:0009      local_number6 = (local_number1 = 64000);<br/></span></code></span></pre></div>

<p>This way the setup will only abort if someone has exactly 64000 KiB RAM available, which is very unlikely, as even if you were to have 64 megs of system memory installed, <span>function_190</span> would most probably return around 65536 KiB, thus it would pass the check.</p>

<p><span><b><u>Crashing to desktop after game launch</u></b></span></p>

<p>Now this one is trickier.</p>

<p>The crash itself is of type <span>EXCEPTION_ACCESS_VIOLATION</span> (error code <span>0xC0000005</span>), which means the program is trying to read or write memory at an invalid memory location. The crash logs also disclose what the address of the problematic instruction is: <span>0x00000000</span>. This means the application expects CPU instructions to be at memory address <span>0x00000000</span>, but since that is zero, it won&#39;t be able to execute any instructions from there and is going to just shut down itself.</p>

<p>Something on older machines definitely did prevent these crashes from happening, as I clearly remember playing this game on my old XP desktop PC without any issues.</p>

<p>Figuring this one out seemed harder, so I&#39;ve utilized the help of VirtualBox to create a clean virtualized environment for researching what exactly causes the crash. What also helped tremendously is that I&#39;ve noticed early on that beha_r&#39;s fixed EXE does not crash; the game can be played flawlessly when using it.</p>

<p>Initially I thought - like maybe yourself - that something about the OS version itself is the trigger for the crash. To confirm this assumption, I created a virtual machine with Windows XP SP3, and tried running the game in it. To my surprise, it still crashed!</p>

<p>I then started looking at different parameters I could change. After some experimenting, I found that the crash can be controlled with the amount of VRAM that is allocated for the virtual machine. When I allocated 128MiB, it was always crashing. With 64MiB, it pretty much never did.</p>

<p>The resolution the game is launched at also influences this. Lower resolutions need less VRAM to crash the game, while higher ones need more. Here&#39;s a little table that demonstrates the minimum necessary VRAM for the game to crash, based on the manual tests I&#39;ve done in my VM:</p>

<p>Any value at or above these VRAM values at the given resolution will crash the game. So basically if you want to run the game at 1024x768, just set your VM&#39;s VRAM capacity to 73MiB, and you&#39;ll be able to run the game just fine.</p>

<p>And with that, two questions arise - how the hell does more available VRAM in a GPU cause a crash like that? And how did beha_r fix it?</p>

<p>Since beha_r&#39;s fix has been available for a while now, I started looking for answers to the second question first.</p>

<p>Besides obviously patching out the function call responsible for the CD check, he also changed another function&#39;s stack. By reverting his CD check patch to only include the stack modification in the executable, I was able to confirm that this stack trick was indeed the one that actually fixed the crash.</p>

<div role="group" aria-label="Code" data-clipboard-source=""><pre><span><span aria-hidden="true">1</span><code role="code"><span role="text presentation">sub_531C30+0<br/></span></code></span><span><span aria-hidden="true">2</span><code role="code"><span role="text presentation">	prev.: mov eax, 108Ch<br/></span></code></span><span><span aria-hidden="true">3</span><code role="code"><span role="text presentation">	fixd.: mov eax, 1090h (+4)<br/></span></code></span><span><span aria-hidden="true">4</span><code role="code"><span role="text presentation"><br/></span></code></span><span><span aria-hidden="true">5</span><code role="code"><span role="text presentation">sub_531C30+203 (531E33)<br/></span></code></span><span><span aria-hidden="true">6</span><code role="code"><span role="text presentation">	prev.: add esp, 108Ch<br/></span></code></span><span><span aria-hidden="true">7</span><code role="code"><span role="text presentation">	fixd.: add esp, 1090h (+4)<br/></span></code></span><span><span aria-hidden="true">8</span><code role="code"><span role="text presentation"><br/></span></code></span><span><span aria-hidden="true">9</span><code role="code"><span role="text presentation">sub_531C30+214 (531E44)<br/></span></code></span><span><span aria-hidden="true">10</span><code role="code"><span role="text presentation">	prev.: add esp, 108Ch<br/></span></code></span><span><span aria-hidden="true">11</span><code role="code"><span role="text presentation">	fixd.: add esp, 1090h (+4)<br/></span></code></span></pre></div>

<p>So it seems more space is given to this function on the stack.</p>

<p>It did pay off eventually, as I was able to make sense of everything in its logic, allowing me to present it to you here in its full glory:</p>

<p>You could even compile this yourself using the DirectX 8 SDK if you replace the <span>this</span> references with constants and provide valid <span>IDirect3DDevice8</span> and <span>HWND</span> objects.</p>

<p>As you can see, this function is basically a VRAM capacity test. It returns the usable amount of video memory in MiB.</p>


<p>Ready?</p>


<p>Okay, here goes:</p>

<p>The game developers made two mistakes here, and the combination of these two mistakes causes the crash.</p>

<p>The first mistake: apparently they never expected (or didn&#39;t care) that GPUs could go beyond <span>512 * 128K == 64MiB</span> VRAM capacity. They relied on DirectX to eventually throw a <span>D3DERR_OUTOFVIDEOMEMORY</span> result when creating up to 512 surfaces and textures to properly calculate how much VRAM is available for them to use,</p>

<p>They thought 64MiB would be plenty for a VRAM overload test as most consumer graphics cards at the time of development (2001) had around 16-32MiB VRAM. Even the game&#39;s system requirements mention a 32MiB GPU for optimal performance. Interestingly, higher-end cards that had 128MiB VRAM had already come out in 2002, so this bug could have popped up for some people already only mere months after release.</p>

<p>Funnily enough, the usable VRAM amount this function calculates doesn&#39;t even appear to influence anything; it does get saved, but doesn&#39;t affect gameplay or playability/game stability whatsoever, even if it&#39;s 0. In fact, beha_r&#39;s fix makes the game believe it has 0 MiB usable VRAM, yet it still works fine.</p>

<p>However the other mistake is a much more severe one: they messed up the bounds checks for <b>BOTH</b> arrays. The dummy texture and surface arrays were both defined as capable of holding 512 pointers each, however their respective loops overrun both buffers with one extra iteration when too much VRAM is available.</p>

<div role="group" aria-label="Code" data-clipboard-source=""><pre><span><span aria-hidden="true">1</span><code role="code"><span role="text presentation">do {<br/></span></code></span><span><span aria-hidden="true">2</span><code role="code"><span role="text presentation">...<br/></span></code></span><span><span aria-hidden="true">3</span><code role="code"><span role="text presentation">} while ( numOfCreatedSurfaces &lt;= 512 &amp;&amp; !createResult );<br/></span></code></span></pre></div>

<p>Arrays in C/C++ are zero-indexed, meaning that <span>dummySurfaces</span>&#39; first item is <span>dummySurfaces[0]</span>, and its last item is <span>dummySurfaces[511]</span>, not <span>dummySurfaces[512]</span>; that one points beyond the end of the array. With each successful texture/surface creation, this index is incremented, however it gets incremented one additional time - so 513 times instead of the intended 512 - due to the less-or-equal (<span>&lt;=</span>) bounds check.</p>

<p>For the dummyTextures array, this isn&#39;t too big of a deal, the item <span>dummyTextures[512]</span> - which actually points to the 513th element of the array, thus is outside of it - only points to the next array&#39;s first item in memory, <span>dummySurfaces[0]</span>. That is overwritten by its own loop anyway later on.</p>

<p>The problem is with <span>dummySurfaces[512]</span>, as <span>dummySurfaces</span> is the last array in the function&#39;s stack. When this last array is overrun, beyond its very last item, the function&#39;s own return address on the stack is overwritten with a pointer to a blank surface.</p>

<p>Due to how the stack is structured, the return address goes after all the variables and buffers defined on the stack. It just so happens that the very last buffer defined on the stack is overrun, corrupting the return address that comes just right after it.</p>

<p>While this last +1 surface is NULL&#39;ed out, the original return address (that would tell the function where to go back after it finished executing) is lost forever and has been replaced with zeroes. That&#39;s why when the function finishes, it thinks it was called from <span>0x00000000</span>, so it tries to go there to continue execution, but as that is invalid memory, the game crashes with an <span>EXCEPTION_ACCESS_VIOLATION</span>.</p>

<p>(If you don&#39;t quite understand what all this return address stuff is about, <a href="https://www.youtube.com/watch?v=e46wHUjNDjE">watch this video</a>, it explains it much better than I do here.)</p>

<p>The developers most probably only tested the game with GPUs having up to 64MiB video RAM. In that case, no matter what resolution they run the game at, it will always run out of video memory when creating the 512 textures and surfaces, thus not reaching the problematic 513th iteration.</p>

<p>Now, you might be wondering: how does this relate to the game resolution and why the exact amount of VRAM &#34;needed&#34; to crash the game increases with higher resolutions? Well, I was kinda stumped on this for a longer time than I&#39;d like to admit, but the answer is painfully simple: the higher the resolution, the more VRAM <b>Windows itself and any other GPU-utilizing applications</b> use. The textures and surfaces always take up the same amount of VRAM; it&#39;s everything else (that the video memory is shared with) that needs more resources as the resolution is increased.</p>

<p>Going back to the code, we can see that the way this was fixed by beha_r is pretty straightforward and simple: he just created 4 bytes more space on the stack for that extra surface iteration to write into, making the last array be able to store 513 pointers instead of 512, sparing the function&#39;s return value from getting overwritten:</p>

<div role="group" aria-label="Code" data-clipboard-source=""><pre><span><span aria-hidden="true">1</span><code role="code"><span role="text presentation">  DDSURFACEDESC2 surfaceDescriptor; // [esp+5Ch] [ebp-1080h] BYREF<br/></span></code></span><span><span aria-hidden="true">2</span><code role="code"><span role="text presentation">  IDirect3DTexture8 *dummyTextures[512]; // [esp+D8h] [ebp-1004h] BYREF<br/></span></code></span><span><span aria-hidden="true">3</span><code role="code"><span role="text presentation">  IDirectDrawSurface7 *dummySurfaces[513]; // [esp+8D8h] [ebp-804h] BYREF<br/></span></code></span></pre></div>

<p>The <span>dummyTextures</span> buffer is still overflown, but since it overflows into the <span>dummySurfaces</span> buffer, it&#39;s not an issue. And <span>dummySurfaces</span> does not get overrun anymore.</p>

<p>In my opinion (and what most probably the devs intended as well), the best way to fix this would be to fix the do..while loops to not iterate over the buffer&#39;s bounds:</p>

<div role="group" aria-label="Code" data-clipboard-source=""><pre><span><span aria-hidden="true">1</span><code role="code"><span role="text presentation">do {<br/></span></code></span><span><span aria-hidden="true">2</span><code role="code"><span role="text presentation">...<br/></span></code></span><span><span aria-hidden="true">3</span><code role="code"><span role="text presentation">} while ( numOfCreatedSurfaces &lt; 512 &amp;&amp; !createResult );<br/></span></code></span></pre></div>

<p>Or better yet, since the return value of this function isn&#39;t even used that much and the game runs just fine even with a return value of 0, the entire function call could just be patched out. It&#39;s only called from one place. On modern systems, there are surely more than 64MiB graphics memory available anyway.</p>

<p>Before:</p>
<div role="group" aria-label="Code" data-clipboard-source=""><pre><span><span aria-hidden="true">1</span><code role="code"><span role="text presentation">.text:0052D863                 mov     ecx, esi<br/></span></code></span><span><span aria-hidden="true">2</span><code role="code"><span role="text presentation">.text:0052D865                 mov     [esi+604h], edi<br/></span></code></span><span><span aria-hidden="true">3</span><code role="code"><span role="text presentation">.text:0052D86B                 mov     [esi+608h], edi<br/></span></code></span><span><span aria-hidden="true">4</span><code role="code"><span role="text presentation">.text:0052D871                 call    sub_531C30 ; problematic VRAM-testing function call<br/></span></code></span><span><span aria-hidden="true">5</span><code role="code"><span role="text presentation">.text:0052D876                 cmp     eax, edi<br/></span></code></span><span><span aria-hidden="true">6</span><code role="code"><span role="text presentation">.text:0052D878                 mov     [esi+594h], eax<br/></span></code></span></pre></div>

<p>After:</p>
<div role="group" aria-label="Code" data-clipboard-source=""><pre><span><span aria-hidden="true">1</span><code role="code"><span role="text presentation">.text:0052D863                 mov     ecx, esi<br/></span></code></span><span><span aria-hidden="true">2</span><code role="code"><span role="text presentation">.text:0052D865                 mov     [esi+604h], edi<br/></span></code></span><span><span aria-hidden="true">3</span><code role="code"><span role="text presentation">.text:0052D86B                 mov     [esi+608h], edi<br/></span></code></span><span><span aria-hidden="true">4</span><code role="code"><span role="text presentation">.text:0052D871                 mov     eax, 40h ; function call completely patched out, program is told it has 64 MiB VRAM to use<br/></span></code></span><span><span aria-hidden="true">5</span><code role="code"><span role="text presentation">.text:0052D876                 cmp     eax, edi<br/></span></code></span><span><span aria-hidden="true">6</span><code role="code"><span role="text presentation">.text:0052D878                 mov     [esi+594h], eax<br/></span></code></span></pre></div>

<p>I patched the game executable in this fashion and didn&#39;t run into any issues. You can find it attached below or at the link above.</p>

<p>One could argue that the devs made a third mistake: they could&#39;ve just simply used DirectX&#39;s builtin VRAM-querying functions to get the available VRAM amount, such as <a href="https://learn.microsoft.com/en-us/windows/win32/api/d3d9/nf-d3d9-idirect3ddevice9-getavailabletexturemem"><span>GetAvailableTextureMem</span></a> or <a href="https://learn.microsoft.com/en-us/windows/win32/api/ddraw/nf-ddraw-idirectdraw7-getavailablevidmem"><span>GetAvailableVidMem</span></a> instead of trying to cram a bunch of blank textures and surfaces into the VRAM on each game startup. My guess would be that they went down this route as they deemed this more reliable than those functions? Not really sure.</p>

<p>Maybe some of the original developers like <a href="https://www.mobygames.com/person/54651/derek-pettigrew/">Derek Pettigrew</a> or <a href="https://www.mobygames.com/person/54652/simon-morris/">Simon Morris</a> could be asked if these guys are still around and someone were able to get a hold of them.</p>

<p>Either way, this was my analysis of the issue. The fixed EXE I&#39;ve attached and linked to patches out the VRAM-check function call shown above entirely. Maybe sparing that extra few milliseconds is valuable to someone, but otherwise, the beha_r patch should work just perfectly fine for everyone else. =)</p>

<p>Not sure if anyone will ever even read this as Salt Lake 2002 is quite an obscure game and it&#39;s not even that good.</p></div><p><small>Last edited by <span title="Moderator"><span role="text presentation"><span aria-hidden="true"></span>Dominus</span></span> on 2023-05-16, 07:09. Edited 2 times in total.</small>
															</p></div>
  </body>
</html>
