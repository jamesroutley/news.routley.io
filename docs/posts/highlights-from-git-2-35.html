<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.blog/2022-01-24-highlights-from-git-2-35/">Original</a>
    <h1>Highlights from Git 2.35</h1>
    
    <div id="readability-page-1" class="page"><p>The open source Git project just <a href="https://lore.kernel.org/git/xmqqee4x3pij.fsf@gitster.g/T/#u">released Git 2.35</a>, with features and bug fixes from over 93 contributors, 35 of them new. We last caught up with you on the latest in Git back <a href="https://github.blog/2021-11-15-highlights-from-git-2-34/">when 2.34 was released</a>. To celebrate this most recent release, here’s GitHub’s look at some of the most interesting features and changes introduced since last time.</p><div>
<li>When working on a complicated change, it can be useful to temporarily discard parts of your work in order to deal with them separately. To do this, we use the <code>git stash</code> tool, which stores away any changes to files tracked in your Git repository.
<p>Using <code>git stash</code> this way makes it really easy to store all accumulated changes for later use. But what if you only want to store part of your changes in the stash? You could use <code>git stash -p</code> and interactively select hunks to stash or keep. But what if you already did that via an earlier <code>git add -p</code>? Perhaps when you started, you thought you were ready to commit something, but by the time you finished staging everything, you realized that you actually needed to stash it all away and work on something else.</p>
<p><code>git stash</code>‘s new <code>--staged</code> mode makes it easy to stash away what you already have in the staging area, and nothing else. You can think of it like <code>git commit</code> (which only writes staged changes), but instead of creating a new commit, it writes a new entry to the stash. Then, when you’re ready, you can recover your changes (with <code>git stash pop</code>) and keep working.</p>
<p>[<a href="https://github.com/git/git/compare/9b96d91e94dabe32627eb1bf17edf057c6ef8e5c...a8a6e0682d1749b646aabbaad571ee5dc3634026">source</a>]</p>
</li>
<li>
<p><code>git log</code> has a rich set of <code>--format</code> options that you can use to customize the output of <code>git log</code>. These can be handy when sprucing up your terminal, but they are especially useful for making it easier to script around the output of <code>git log</code>.</p>
<p>In <a href="https://github.blog/2021-08-16-highlights-from-git-2-33/">our blog post covering Git 2.33</a>, we talked about a new <code>--format</code> specifier called <code>%(describe)</code>. This made it possible to include the output of <code>git describe</code> alongside the output of <code>git log</code>. When it was first released, you could pass additional options down through the <code>%(describe)</code> specifier, like matching or excluding certain tags by writing <code>--format=%(describe:match=&lt;foo&gt;,exclude=&lt;bar&gt;)</code>.</p>
<p>In 2.35, Git includes a couple of new ways to tweak the output of <code>git describe</code>. You can now control whether to use <a href="https://git-scm.com/book/en/v2/Git-Basics-Tagging#_creating_tags">lightweight tags</a>, and how many hexadecimal characters to use when abbreviating an object identifier.</p>
<p>You can try these out with <code>%(describe:tags=&lt;bool&gt;)</code> and <code>%(describe:abbrev=&lt;n&gt;)</code>, respectively. Here’s a goofy example that gives me the <code>git describe</code> output for the last 8 commits in my copy of <code>git.git</code>, using only non-release-candidate tags, and uses 13 characters to abbreviate their hashes:</p>
<pre><code>$ git log -8 --format=&#39;%(describe:exclude=*-rc*,abbrev=13)&#39;
v2.34.1-646-gaf4e5f569bc89
v2.34.1-644-g0330edb239c24
v2.33.1-641-g15f002812f858
v2.34.1-643-g2b95d94b056ab
v2.34.1-642-gb56bd95bbc8f7
v2.34.1-203-gffb9f2980902d
v2.34.1-640-gdf3c41adeb212
v2.34.1-639-g36b65715a4132
</code></pre>
<p>Which is much cleaner than this alternative way to combine <code>git log</code> and <code>git describe</code>:</p>
<pre><code>$ git log -8 --format=&#39;%H&#39; | xargs git describe --exclude=&#39;*-rc*&#39; --abbrev=13
</code></pre>
<p>[<a href="https://github.com/git/git/compare/832ec72c3e15820c3b728b3a56398655d7bb7cb3...eccd97d0b02a87db0b0e828dd4f0b441c5462a9c">source</a>]</p>
</li>
<li>
<p>In <a href="https://github.blog/2021-11-15-highlights-from-git-2-34/">our last post</a>, we talked about SSH signing: a new feature in Git that allows you to use the SSH key you likely already have in order to sign certain kinds of objects in Git.</p>
<p>This release includes a couple of new additions to SSH signing. Suppose you use SSH keys to sign objects in a project you work on. To track which SSH keys you trust, you use the <a href="https://man.openbsd.org/ssh-keygen.1#ALLOWED_SIGNERS">allowed signers</a> file to store the identities and public keys of signers you trust.</p>
<p>Now suppose that one of your collaborators rotates their key. What do you do? You could update their entry in the allowed signers file to point at their new key, but that would make it impossible to validate objects signed with the older key. You could store both keys, but that would mean that you would accept new objects signed with the old key.</p>
<p>Git 2.35 lets you take advantage of OpenSSH’s <code>valid-before</code> and <code>valid-after</code> directives by making sure that the object you’re verifying was signed using a signature that was valid when it was created. This allows individuals to rotate their SSH keys by keeping track of when each key was valid without invalidating any objects previously signed using an older key.</p>
<p>Git 2.35 also supports new key types in the <code>user.signingKey</code> configuration when you include the key verbatim (instead of storing the path of a file that contains the signing key). Previously, the rule for interpreting <code>user.signingKey</code> was to treat its value as a literal SSH key if it began with “ssh-“, and to treat it as filepath otherwise. You can now specify literal SSH keys with keytypes that don’t begin with “ssh-” (like <a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm">ECDSA</a> keys).</p>
<p>[<a href="https://github.com/git/git/compare/3770c21be99a1e387794ec21e9bfeb3c640376b6...50992f96c546ebdc0c149660f6baa948739888d9">source</a>, <a href="https://github.com/git/git/compare/d2f0b7275998ebeaa15e48ce0180c466e1d77ec4...3b4b5a793a36d1e92114ff929eb7d15d55d45a96">source</a>]</p>
</li>
<li>
<p>If you’ve ever dealt with a merge conflict, you know that accurately resolving conflicts takes some careful thinking. You may not have heard of Git’s <a href="https://git-scm.com/docs/git-config#Documentation/git-config.txt-mergeconflictStyle"><code>merge.conflictStyle</code> setting</a>, which makes resolving conflicts just a little bit easier.</p>
<p>The default value for this configuration is “merge”, which produces the merge conflict markers that you are likely familiar with. But there is a different mode, “diff3”, which shows the merge base in addition to the changes on either side.</p>
<p>Git 2.35 introduces a new mode, “zdiff3”, which zealously moves any lines in common at the beginning or end of a conflict <em>outside</em> of the conflicted area, which makes the conflict you have to resolve a little bit smaller.</p>
<p>For example, say I have a list with a placeholder comment, and I merge two branches that each add different content to fill in the placeholder. The usual merge conflict might look something like this:</p>
<pre><code>1,
foo,
bar,
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
=======
quux,
woot,
&gt;&gt;&gt;&gt;&gt;&gt;&gt; side
baz,
3,
</code></pre>
<p>Trying again with diff3-style conflict markers shows me the merge base (revealing a comment that I didn’t know was previously there) along with the full contents of either side, like so:</p>
<pre><code>1,
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
foo,
bar,
baz,
||||||| 60c6bd0
# add more here
=======
foo,
bar,
quux,
woot,
baz,
&gt;&gt;&gt;&gt;&gt;&gt;&gt; side
3,
</code></pre>
<p>The above gives us more detail, but notice that both sides add “foo” and, “bar” at the beginning and “baz” at the end. Trying one last time with zdiff3-style conflict markers moves the “foo” and “bar” outside of the conflicted region altogether. The result is both more accurate (since it includes the merge base) and more concise (since it handles redundant parts of the conflict for us).</p>
<pre><code>1,
foo,
bar,
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
||||||| 60c6bd0
# add more here
=======
quux,
woot,
&gt;&gt;&gt;&gt;&gt;&gt;&gt; side
baz,
3,
</code></pre>
<p>[<a href="https://github.com/git/git/compare/62329d336f5d427d8f08035798bf62cd7d8fd847...ddfc44a898a58311392a5329687a1813d6b94779">source</a>]</p>
</li>
<li>
<p>You may (or may not!) know that Git supports a handful of different algorithms for generating a diff. The usual algorithm (and the one you are likely already familiar with) is the <a href="https://blog.jcoglan.com/2017/02/12/the-myers-diff-algorithm-part-1/">Myers diff algorithm</a>. Another is the <a href="https://blog.jcoglan.com/2017/09/19/the-patience-diff-algorithm/"><code>--patience</code> diff algorithm</a> and its cousin <code>--histogram</code>. These can often lead to more human-readable diffs (for example, by avoiding a common issue where adding a new function starts the diff by adding a closing brace to the function immediately preceding the new one).</p>
<p>In Git 2.35, <code>--histogram</code> got a nice performance boost, which should make it faster in many cases. The details are too complicated to include in full here, but you can check out the reference below and see all of the improvements and juicy performance numbers.</p>
<p>[<a href="https://github.com/git/git/compare/69a9c10c95e28df457e33b3c7400b16caf2e2962...1e45db12141789c084e96a46adcf70858f05a1bc">source</a>]</p>
</li>
<li>
<p>If you’re a fan of performance improvements (and <code>diff</code> options!), here’s another one you might like. You may have heard of <code>git diff</code>‘s <code>--color-moved</code> option (if you haven’t, we talked about it back in our <a href="https://github.blog/2018-04-05-git-217-released/#coloring-moved-code">Highlights from Git 2.17</a>). You may not have heard of the related <code>--color-moved-ws</code>, which controls how whitespace is or isn’t ignored when colorizing diffs. You can think of it like the other space-ignoring options (like <code>--ignore-space-at-eol</code>, <code>--ignore-space-change</code>, or <code>--ignore-all-space</code>), but specifically for when you’re running diff in the <code>--color-moved</code> mode.</p>
<p>Like the above, Git 2.35 also includes a variety of performance improvement for <code>--color-moved-ws</code>. If you haven’t tried <code>--color-moved</code> yet, give it a try! If you already use it in your workflow, it should get faster just by upgrading to Git 2.35.</p>
<p>[<a href="https://github.com/git/git/compare/ead6767ad7f835f4802248371709c4506ad6a4f1...72962e8b3c3ea3a631166876b4668718103be4fe">source</a>]</p>
</li>
<li>
<p>Way back in our <a href="https://github.blog/2018-09-10-highlights-from-git-2-19">Highlights from Git 2.19</a>, we talked about how <a href="https://github.blog/2018-09-10-highlights-from-git-2-19/#user-content-git-greps-new-tricks">a new feature in <code>git grep</code></a> allowed the <code>git jump</code> addon to populate your editor with the exact locations of <code>git grep</code> matches.</p>
<p>In case you aren’t familiar with <a href="https://github.com/git/git/tree/v2.35.0/contrib/git-jump"><code>git jump</code></a>, here’s a quick refresher. <code>git jump</code> populates <a href="http://vimdoc.sourceforge.net/htmldoc/quickfix.html">Vim’s quickfix list</a> with the locations of merge conflicts, grep matches, or diff hunks (by running <code>git jump merge</code>, <code>git jump grep</code>, or <code>git jump diff</code>, respectively).</p>
<p>In Git 2.35, <code>git jump merge</code> learned how to narrow the set of merge conflicts using a pathspec. So if you’re working on resolving a big merge conflict, but you only want to work on a specific section, you can run:</p>
<pre><code>$ git jump merge -- foo
</code></pre>
<p>to only focus on conflicts in the <code>foo</code> directory. Alternatively, if you want to skip conflicts in a certain directory, you can use the special negative pathspec like so:</p>
<pre><code># Skip any conflicts in the Documentation directory for now.
$ git jump merge -- &#39;:^Documentation&#39;
</code></pre>
<p>[<a href="https://github.com/git/git/compare/a9c84980d0e55fa7802be4b02b12801ed7cd06d6...67ba13e5a4b27785391a0e1673d71e506edae13b">source</a>]</p>
</li>
<li>
<p>You might have heard of Git’s <a href="https://git-scm.com/docs/gitattributes#_filter">“clean” and “smudge” filters</a>, which allow users to specify how to “clean” files when staging, or “smudge” them when populating the working copy. <a href="https://git-lfs.github.com">Git LFS</a> makes extensive use of these filters to represent large files with stand-in “pointers.” Large files are converted to pointers when staging with the clean filter, and then back to large files when populating the working copy with the smudge filter.</p>
<p>Git has historically used the <code>size_t</code> and <code>unsigned long</code> types relatively interchangeably. This is understandable, since Git was originally written on Linux where these two types have the same width (and therefore, the same representable range of values).</p>
<p>But on Windows, which uses the <a href="https://en.wikipedia.org/wiki/64-bit_computing#64-bit_data_models">LLP64</a> data model, the <code>unsigned long</code> type is only 4 bytes wide, whereas <code>size_t</code> is 8 bytes wide. Because the clean and smudge filters had previously used <code>unsigned long</code>, this meant that they were unable to process files larger than 4GB in size on platforms conforming to LLP64.</p>
<p>The effort to standardize on the correct <code>size_t</code> type to represent object length continues in Git 2.35, which makes it possible for filters to handle files larger than 4GB, even on LLP64 platforms like Windows<sup id="fnref-62535-1"><a href="#fn-62535-1" title="Read footnote.">1</a></sup>.</p>
<p>[<a href="https://github.com/git/git/compare/ad1260b6c994f7c0f9c259bd39f39979f7f4ecc2...596b5e77c960cc57ad2e68407b298411ec5e8cb8">source</a>]</p>
</li>
<li>
<p>If you haven’t used Git in a patch-based workflow where patches are emailed back and forth, you may be unaware of the <code>git am</code> command, which extracts patches from a mailbox and applies them to your repository.</p>
<p>Previously, if you tried to <code>git am</code> an email which did not contain a patch, you would get dropped into a state like this:</p>
<pre><code>$ git am /path/to/mailbox
Applying: [...]
Patch is empty.
When you have resolved this problem, run &#34;git am --continue&#34;.
If you prefer to skip this patch, run &#34;git am --skip&#34; instead.
To restore the original branch and stop patching, run &#34;git am --abort&#34;.
</code></pre>
<p>This can often happen when you save the entire contents of a patch series, including its cover letter (the customary first email in a series, which contains a description of the patches to come but does not itself contain a patch) and try to apply it.</p>
<p>In Git 2.35, you can specify how <code>git am</code> will behave should it encounter an empty commit with <code>--empty=&lt;stop|drop|keep&gt;</code>. These options instruct <code>am</code> to either halt applying patches entirely, drop any empty patches, or apply them as-is (creating an empty commit, but retaining the log message). If you forgot to specify an <code>--empty</code> behavior but tried to apply an empty patch, you can run <code>git am --allow-empty</code> to apply the current patch as-is and continue.</p>
<p>[<a href="https://github.com/git/git/compare/da81d473fcfa67dfbcf0504d2b5225885e51e532...9e7e41bf19ed10469f9adb60669b1699c81b8ea6">source</a>]</p>
</li>
<li>
<p><a href="https://github.blog/2021-11-15-highlights-from-git-2-34/">Returning readers</a> may remember our discussion of the <a href="https://github.blog/2021-11-10-make-your-monorepo-feel-small-with-gits-sparse-index/">sparse index</a>, a Git features that improves performance in repositories that use sparse-checkout. The aforementioned link describes the feature in detail, but the high-level gist is that it stores a compacted form of the index that grows along with the size of your checkout rather than the size of your repository.</p>
<p>In 2.34, the sparse index was integrated into a handful of commands, including <code>git status</code>, <code>git add</code>, and <code>git commit</code>. In 2.35, command support for the sparse index grew to include integrations with <code>git reset</code>, <code>git diff</code>, <code>git blame</code>, <code>git fetch</code>, <code>git pull</code>, and a new mode of <code>git ls-files</code>.</p>
<p>[<a href="https://github.com/git/git/compare/4ee5cacc16ee7779017f207e496eeb75b0fa5721...f2a454e0a5e26c0f7b840970f69d195c37b16565">source</a>, <a href="https://github.com/git/git/compare/3f9d5059c66f45ac75dd701b0798d3891150c1e7...add4c864b60766174ad4f74ba7be17e66d61ef16">source</a>, <a href="https://github.com/git/git/compare/b48c69c3c8a0e6e44f31c70677ac40658d8f3439...408c51f0b4b5f978ab3676a7dc8efaffe459bdee">source</a>]</p>
</li>
<li>
<p>Speaking of sparse-checkout, the <code>git sparse-checkout</code> builtin has deprecated the <code>git sparse-checkout init</code> subcommand in favor of using <code>git sparse-checkout set</code>. All of the options that were previously available in the <code>init</code> subcommand are still available in the <code>set</code> subcommand. For example, you can enable cone-mode sparse-checkout and include the directory <code>foo</code> with this command:</p>
<pre><code>$ git sparse-checkout set --cone foo
</code></pre>
<p>[<a href="https://github.com/git/git/compare/4f4b18497aea75425506097de7225df8c7cf5c66...dfac9b609f86cd4f6ce896df9e1172d2a02cde48">source</a>]</p>
</li>
<li>
<p>Git stores references (such as branches and tags) in your repository in one of two ways: either “loose” as a file inside of <code>.git/refs</code> (like <code>.git/refs/heads/main</code>) or “packed” as an entry inside of the file at <code>.git/packed_refs</code>.</p>
<p>But for repositories with truly gigantic numbers of references, it can be inefficient to store them all together in a single file. The <a href="https://eclipse.googlesource.com/jgit/jgit/+/refs/heads/master/Documentation/technical/reftable.md">reftable</a> proposal outlines the alternative way that <a href="https://www.eclipse.org/jgit/">JGit</a> stores references in a block-oriented fashion. JGit has been using reftable for many years, but Git has not had its own implementation.</p>
<p>Reftable promises to improve reading and writing performance for repositories with a large number of references. Work has been underway for quite some time to bring an implementation of reftable to Git, and Git 2.35 comes with an initial import of the reftable backend. This new backend isn’t yet integrated with the refs, so you can’t start using reftable just yet, but we’ll keep you posted about any new developments in the future.</p>
<p>[<a href="https://github.com/git/git/compare/e773545c7fe7eca21b134847f4fc2cbc9547fa14...d860c86ba545920342cbc507fc34af461ab99152">source</a>]</p>
</li>
</div><p>That’s just a sample of changes from the latest release. For more, check out the release notes for <a href="https://github.com/git/git/blob/v2.35.0/Documentation/RelNotes/2.35.0.txt">2.35</a>, or <a href="https://github.com/git/git/tree/v2.35.0/Documentation/RelNotes">any previous version</a> in the Git repository.</p></div>
  </body>
</html>
