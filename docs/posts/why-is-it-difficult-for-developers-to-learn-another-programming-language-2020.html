<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://cacm.acm.org/magazines/2022/3/258915-here-we-go-again/fulltext">Original</a>
    <h1>Why is it difficult for developers to learn another programming language? (2020)</h1>
    
    <div id="readability-page-1" class="page"><div id="container">
<div id="layout">

<section>



<hr/>
<div id="articleFullText">



<div id="asset-42339">
<figure>
<img alt="code inside a word balloon" src="https://cacm.acm.org/system/assets/0004/2339/021622_Here-We-Go.large.jpg?1645022283&amp;1645022283" title="code inside a word balloon"/>
</figure>
</div>


<p>Once a programmer knows one language, they can leverage concepts and knowledge already learned, and easily pick up another programming language. But is that always the case? To understand if programmers have difficulty learning additional programming languages, we conducted an empirical study of Stack Overflow questions across 18 different programming languages. We hypothesized that previous knowledge could potentially interfere with learning a new programming language. From our inspection of 450 Stack Overflow questions, we found 276 instances of interference that occurred due to faulty assumptions originating from knowledge about a different language. To understand why these difficulties occurred, we conducted semistructured interviews with 16 professional programmers. The interviews revealed that programmers make failed attempts to relate a new programming language with what they already know. Our findings inform design implications for technical authors, toolsmiths, and language designers, such as designing documentation and automated tools that reduce interference, anticipating uncommon language transitions during language design, and welcoming programmers not just into a language, but its entire ecosystem.</p>

<p><a href="#PageTop">Back to Top</a></p>


<h3>1. Introduction</h3>
<p>Peter Norvig wrote a guide, <em>Python for Lisp Programmers</em>,<sup><a href="#R13">13</a></sup> to teach Python from the perspective of Lisp. We interviewed Peter regarding this transition and he described a few challenging aspects of switching to Python such as how lists are not treated as a linked list and solutions where he previously used macros required rethinking. When asked about the general problem of switching programming languages, he said, &#34;Most research is on beginners learning languages. For experts, it&#39;s quite different and we don&#39;t know that process. We just sort of assume if you&#39;re an expert you don&#39;t need any help. But I think that&#39;s not true!&#34; Peter believes that learning new languages is difficult—even for experts—despite their previous experience working with languages. Is Peter right?</p>
<p>Numerous stories on language transitions suggest that even experienced programmers experience difficulties. For example, a Java programmer who transitioned to Kotlin<sup><a href="#R24">24</a></sup> reports that differences such as reversed type notation and how classes in Kotlin are final by default, made the transition less smooth than expected: &#34;if you think that you can learn Kotlin quickly because you already know Java—you are wrong. Kotlin would throw you in the deep end.&#34; Similarly, a programmer experienced in C++ who switched to Rust<sup><a href="#R4">4</a></sup> found that Rust&#39;s borrow checker, &#34;forces a programmer to think differently.&#34; Transitions across radically different languages are especially difficult. For example, a Java programmer switched to Haskell<sup><a href="#R10">10</a></sup> and expressed that &#34;the easy things are often a bit harder to do in Haskell,&#34; and another programmer<sup><a href="#R16">16</a></sup> experienced in procedural languages warned that &#34;[lazy evaluation] can be a bit confusing to understand <em>how</em> it works in practice especially if you&#39;re still thinking like an imperative programmer.&#34; Even languages sharing the same runtime can be problematic: &#34;whenever I pick up CoffeeScript, I feel as if most of my understanding of JavaScript suddenly vanishes into thin air.&#34;<sup><a href="#R14">14</a></sup> From these stories, one common refrain occurs: previous programming knowledge is sometimes less helpful than expected, and can actively interfere with learning. This seems counterintuitive. Why can previous knowledge actually make learning harder and not easier? </p>
<p>In psychology and neuroscience, interference theory has helped explain the confusion that can occur when older information interacts with newer information.<sup><a href="#R23">23</a></sup> To illustrate, suppose the bread aisle of your favorite store was recently moved. You may reflexively start walking toward the old location due to <em>interference</em>—when previous knowledge disrupts recall of newly learned information. However, if you recently saw that the impossible burger was added to the store, using knowledge that frozen food can be found in the frozen section—and not a separate health aisle—is an example of <em>facilitation</em>, where your previous knowledge helps retrieval of new information. In the same vein, when a Java programmer is learning Kotlin, we postulate that their prior Java knowledge either facilitates or interferes with learning. The knowledge that Java is objected oriented and uses static typing facilitates their learning as Kotlin shares similar properties. The knowledge that Java classes are not <code>final</code> by default interferes with their learning because Kotlin classes are <code>final</code> by default.</p>
<p>If previous programming knowledge can be framed as a source of interference with new programming language acquisition, interference theory can explain why programming language learning can be difficult for experienced programmers. And when previous programming knowledge is not relevant, learning can also be difficult because this knowledge does not facilitate.</p>
<p>To investigate our hypothesis, we first looked for evidence that programmers could have difficulty learning another language due to interference from their previous knowledge. To this end, we conducted an empirical study examining questions posted on a popular question-and-answer site, Stack Overflow.<sup><a href="#FNA">a</a></sup> We analyzed 450 posts for 18 different programming languages and qualitatively coded each post, characterizing posts in terms of whether or not programmers made incorrect assumptions based on their previous programming knowledge. Then, to understand what learning strategies programmers used when learning another language—and why previous knowledge could interfere with this process—we interviewed 16 professional programmers who had recently switched to a new programming language.</p>
<p>We found that:</p>
<ul>
<li>Cross-language interference is a problem: 276 (61%) cross-language posts on Stack Overflow contained incorrect assumptions due to interference with previous language knowledge.</li>
<li>Based on our interviews, professional programmers primarily learned new languages on their own, using an opportunistic strategy that often involved relating the new language to previous language knowledge; however, this results in interference which harms their learning.</li>
<li>Learning a new language involves breaking down old habits, shifting one&#39;s mindset, dealing with little-to-no mapping to previous languages, searching for proper documentation, and retooling in a new environment. All together, these challenges make learning another language difficult.</li>
</ul>

<p><a href="#PageTop">Back to Top</a></p>


<h3>2. Methodology</h3>
<p>To explore how programmers learn a new language, and understand their potential sources of confusion, we conducted a mixed-method study through an empirical investigation of Stack Overflow posts across various languages and through semistructured interviews. We do so through the following research questions:</p>
<p><img alt="*" src="https://dl.acm.org/images/bullet.gif"/> <strong>2.1. Research questions</strong></p>
<ul>
<li><strong>RQ1: Does cross-language interference occur?</strong> We examined questions programmers had about programming languages on Stack Overflow for evidence of interference with previous programming knowledge.</li>
<li><strong>RQ2: How do experienced programmers learn new languages?</strong> To gain a better understanding of why cross-language interference occurs, we interviewed professional programmers on how they learn new languages.</li>
<li><strong>RQ3: What do experienced programmers find confusing in new languages?</strong> To examine the ways in which programmers mix a new language with their previous knowledge, we asked programmers about obstacles they faced, and surprises they encountered in their new languages.</li>
</ul>
<p><img alt="*" src="https://dl.acm.org/images/bullet.gif"/> <strong>2.2. Phase I: Study design for Stack Overflow</strong></p>
<p>To answer RQ1, we conducted a study using Stack Overflow posts.</p>
<p><strong>Data collection.</strong> To gather Stack Overflow questions, we used the SOTorrent<sup><a href="#R2">2</a></sup> data source from the 2019 MSR Mining Challenge. We queried 26 programming languages used previously by Erik<sup><a href="#FNB">b</a></sup> and Waren<sup><a href="#FNC">c</a></sup> in their investigation of popular language migrations, based on Google search keywords and GitHub repositories. We gathered Stack Overflow questions for each pair. To keep the analysis tractable, we considered only the association between the two languages, and not the direction of the possible interference. We used a stop-rule criteria to cover over 95% of total posts, which resulted in 15 out of the 26 language pairs as shown in <a href="https://dl.acm.org/cms/attachment/593ec58a-dd17-4685-9969-ef60bfc2c15a/t1.jpg" onclick="window.open(this.href, &#39;&#39;, &#39;resizable=yes,status=no,location=no,toolbar=no,menubar=no,fullscreen=no,scrollbars=no,dependent=no,width=760,height=649&#39;); return false;">Table 1</a>. The materials for the study are available online.<sup><a href="#FND">d</a></sup></p>
<p><a href="https://dl.acm.org/cms/attachment/593ec58a-dd17-4685-9969-ef60bfc2c15a/t1.jpg" onclick="window.open(this.href, &#39;&#39;, &#39;resizable=yes,status=no,location=no,toolbar=no,menubar=no,fullscreen=no,scrollbars=no,dependent=no,width=760,height=649&#39;); return false;"><img alt="t1.jpg" height="354" src="https://dl.acm.org/cms/attachment/593ec58a-dd17-4685-9969-ef60bfc2c15a/t1.jpg" width="415"/></a></p>
<p><strong>Query criteria.</strong> We used BigQuery<sup><a href="#FNE">e</a></sup> to query the SOTorrent database and used the following filtering criteria to capture potential posts where the programmers are asking questions about a new language (target) coming from a previous language (source):</p>
<ol>
<li>The question is tagged with both languages, or</li>
<li>The question is tagged with the source language but contains the text of the target language in the title or body, vice versa.</li>
</ol>
<p><strong>Analysis.</strong> To understand whether or not cross-language interference occurs, we performed a manual inspection of Stack Overflow posts (see <a href="https://dl.acm.org/cms/attachment/593ec58a-dd17-4685-9969-ef60bfc2c15a/t1.jpg" onclick="window.open(this.href, &#39;&#39;, &#39;resizable=yes,status=no,location=no,toolbar=no,menubar=no,fullscreen=no,scrollbars=no,dependent=no,width=760,height=649&#39;); return false;">Table 1</a>). We inspected a random sample of 30 posts for each pair to keep categorization tractable, as done in the works of Barik et al.<sup><a href="#R3">3</a></sup> We manually excluded posts that did not make any explicit connection between the languages of each pair, sampling another random post to replace it as necessary. Because the inclusion and exclusion criteria can have multiple interpretations, the first two coauthors labeled a random sample of 30 posts. This labeling had 100% agreement between the coauthors, and suggests a clear understanding of how to categorize posts. The two coauthors proceeded to label the rest of the Stack Overflow posts using two classifications:</p>
<ul>
<li><em>Correct:</em> The post makes a connection to a previous programming language with correct assumptions regarding the target language as revealed by the accepted answer, or</li>
<li><em>Incorrect:</em> The post makes a connection to a previous programming language with incorrect assumptions regarding the target language as revealed by the accepted answer.</li>
</ul>
<p>Next, we calculated and reached agreement on the interrater reliability (IRR) between the two coauthors (Cohen&#39;s <em>k</em> = 0.89). Disagreements on the classification—even after discussion—was reconciled by the first author. Finally, we calculated the percentage of correct and incorrect posts, using instances of correct and incorrect assumptions as evidence of cross-language interference and facilitation.</p>
<p><img alt="*" src="https://dl.acm.org/images/bullet.gif"/> <strong>2.3. Phase II: Study design for interviews with professional programmers</strong></p>
<p>To answer RQ2 and RQ3, we conducted semistructured interviews with professional programmers.</p>
<p><strong>Participants.</strong> We used <em>purposive sampling</em><sup><a href="#R21">21</a></sup> to recruit 16 professional programmers who were learning a new programming language within the past six months (see <a href="https://dl.acm.org/cms/attachment/3e6797d6-5700-4a0b-a3b0-8f46ee1b8819/t2.jpg" onclick="window.open(this.href, &#39;&#39;, &#39;resizable=yes,status=no,location=no,toolbar=no,menubar=no,fullscreen=no,scrollbars=no,dependent=no,width=758,height=561&#39;); return false;">Table 2</a>); these participants were still early in their learning process and working through their initial stumbling blocks in the new language. The participants (12 male, 4 female, self-reported) were from large software, technology, and data analytics companies with years of programming experience ranging from 5 to 31 years (μ = 12.8, <em>sd</em> = 6.6). There were a total of 14 unique language transitions. Before the interview, participants completed a background questionnaire asking them about their previous languages and an obstacle they have experienced although adapting to the new language.</p>
<p><a href="https://dl.acm.org/cms/attachment/3e6797d6-5700-4a0b-a3b0-8f46ee1b8819/t2.jpg" onclick="window.open(this.href, &#39;&#39;, &#39;resizable=yes,status=no,location=no,toolbar=no,menubar=no,fullscreen=no,scrollbars=no,dependent=no,width=758,height=561&#39;); return false;"><img alt="t2.jpg" height="307" src="https://dl.acm.org/cms/attachment/3e6797d6-5700-4a0b-a3b0-8f46ee1b8819/t2.jpg" width="415"/></a></p>
<p><strong>Protocol.</strong> We conducted semistructured interviews either onsite or remotely, within 60 min time blocks. Two of the authors conducted and recorded the interviews separately. All sessions were conducted with a single observer and a single programmer on the following topics: (1) participant background, (2) first steps, (3) obstacles, (4) learning process, and (5) general strategies. The background information from the questionnaire was used to tailor the questions for the participants. The semistructured interview format allowed the flexibility to ask questions impromptu and dig deeper into more specific obstacles. The recordings were later transcribed by the first author for analysis.</p>
<p><strong>Analysis.</strong> <em>RQ2: How do experienced programmers learn new languages?</em> To answer RQ2, we conducted inductive thematic analysis<sup><a href="#R9">9</a></sup> on the interview transcripts over multiple phases: transcribing interviews, generating open codes by labelling notable recurring statements made by the participants, identifying relationships between the codes, and organizing them into meaningful themes.</p>
<p><em>RQ3: What do experienced programmers find confusing in new languages?</em> To understand how programmers confuse language concepts, we selected themes from our analysis that highlighted interference due to previous programming knowledge.</p>

<p><a href="#PageTop">Back to Top</a></p>


<h3>3. Results</h3>
<p><img alt="*" src="https://dl.acm.org/images/bullet.gif"/> <strong>3.1. RQ1: Does cross-language interference occur?</strong></p>
<p>Cross-language interference occurs on Stack Overflow across various language pairs. We found a total of 276 instances of incorrect assumptions (see <a href="https://dl.acm.org/cms/attachment/593ec58a-dd17-4685-9969-ef60bfc2c15a/t1.jpg" onclick="window.open(this.href, &#39;&#39;, &#39;resizable=yes,status=no,location=no,toolbar=no,menubar=no,fullscreen=no,scrollbars=no,dependent=no,width=760,height=649&#39;); return false;">Table 1</a>), which is around 61% of the 450 posts inspected. There were a total of 174 posts with correctly stated assumptions, which is only around 39% of the total posts. It is important to note that this provides evidence of interference occurring but does not imply programmers have incorrect assumptions 61% of the time. The pair had the highest number of posts with incorrect assumptions, which reflects the Java programmer&#39;s confusion mentioned in Section 1. The next two pairs, and , also contained a high number of incorrect assumptions. However, there were other pairs such as <code>, </code>, and , which had a more even distribution of posts with correct and incorrect assumptions; this suggests easier transitions between the languages. Although reviewing the 450 Stack Overflow posts, we encountered instances where programming languages behaved in surprising ways for programmers. We highlight three examples, two of which involved interference between syntax and concepts, and one which involved facilitation—making it easier to use type inference.</p>
<p><span><strong>Interference: R ⇒ Python</strong><sup><a href="#FNF">f</a></sup></span></p>
<p>An R programmer is now using Python and its data processing library, Pandas. They are unable to successfully relate their previous knowledge about subsetting, in R, to Python: &#34;I&#39;m seriously confused. Maybe I&#39;m thinking too much in R terms and can&#39;t wrap my head around what&#39;s going on in Python.&#34;</p>
<p>They present the R expression they want to translate, as well as several attempted translations in Python:</p>
<blockquote>
<p><code># R</code></p>
<p><code>data[data$x &gt; value, y] &lt;- 1</code></p>
<p><code># Python</code></p>
<p><code>data[&#39;y&#39;] [data[&#39;x&#39;] &gt; value] = 1</code></p>
</blockquote>
<p>Several concepts in R interfered, but we will highlight the most significant: Python prevents assignment to copies of dataframes. In this case, the indexing operation <code>data [&#39;y&#39;]</code> returns a copy of the dataframe and setting the value with <code>[data [&#39;y&#39;] &gt; value] = 1</code> will not work as the R programmer expects. The knowledge that the equivalent R expression will set the value of 1 without any warnings interferes with Python&#39;s warning.</p>
<p><span><strong>Interference: PHP ⇒ JavaScript</strong><sup><a href="#FNG">g</a></sup></span></p>
<p>A PHP programmer who has switched to programming in JavaScript asks how to store transient information (sessions), such as application state about a user. Typically, PHP uses server-side session variables <code>($_SESSION)</code> for this purpose. Although related concepts, such as local storage and browser-based sessions exist, the programmer is warned that sessions cannot be safely and securely stored directly on the client—the programmer&#39;s knowledge about server-side sessions leads to a faulty assumption about their applicability in other programming contexts.</p>
<p><span><strong>Interference: Java ⇒ Kotlin</strong><sup><a href="#FNH">h</a></sup></span></p>
<p>A Java developer is learning Kotlin. They ask if the following Kotlin expression can be simplified:</p>
<blockquote>
<p><code>val boundsBuilder: LatLngBounds.Builder = LatLngBounds.Builder()</code></p>
</blockquote>
<p>The developer suspects their declaration is more verbose than it should be, given their knowledge of local variable type inference in Java. They assume the declaration can be simplified:</p>
<blockquote>
<p>val boundsBuilder = LatLngBounds.Builder()</p>
</blockquote>
<p>This is an example of facilitation—the accepted answer confirms that the developer can simplify the expression because Kotlin supports type inference, allowing for the explicit type declaration to be removed.</p>
<p>These examples illustrate how previous knowledge of language syntax and concepts interact with knowledge learned in a new language. In some cases, this results in interference, which harms a programmer&#39;s ability to grasp new syntax and concepts in the new language. In other cases, this results in facilitation, which helps programmers make meaningful connections to previous languages and helps them learn the new language.</p>
<p><span>Cross-language interference occurs across various language transitions on Stack Overflow posts. We found that 61% of the 450 posts contained incorrect assumptions about the target language, and only 39% contained correct assumptions.</span></p>
<p><img alt="*" src="https://dl.acm.org/images/bullet.gif"/> <strong>3.2. RQ2: How do experienced programmers learn new languages?</strong></p>
<p>In this section, we present the themes on how experienced programmers learn new languages.</p>
<p><strong>Programmers learned languages on their own.</strong> Programmers who switched teams lacked formal training for the new language and its associated technology stack, leaving learning to themselves. For example, when P1 switched from C# to Python for a new project, there was not any training involved and the onboarding process was, &#34;hey we want to get exposed to the Python world, go get started!&#34; Although some programmers were given training initially on the project, &#34;realistically for learning the new language [they] were pretty much on [their] own&#34; (P7). This forced programmers to watch &#34;language tutorial videos on Plural-sight&#34;<sup><a href="#FNI">i</a></sup> (P5) or read online documentation. Some programmers &#34;got initial tips from some folks from the team on what&#39;s what&#34; (P6), and when running into complex issues &#34;reached out to the group and said has somebody else hit this before?&#34; (P1).</p>
<p><strong>Just-in-time learning is a dominant strategy.</strong> To learn new languages, every programmer we interviewed used <em>just-in-time learning</em>,<sup><a href="#R8">8</a></sup> an opportunistic strategy focused on only learning features as needed. Given time constraints, programmers made use of immediately available resources such as online documentation, video tutorials, online searches, and available experts. Traditional resources such as programming language books were only used as a reference, because programmers &#34;just don&#39;t have time to do that&#34; (P5). Programmers were primarily concerned with completing tasks in a reasonable time and &#34;figuring out how to not burn tons of time on a single problem&#34; (P1). Quicker resources, such as cheat sheets, were preferred for language transitions. For example, the first thing P2 did was to make use of cheat sheets to help them transition from Python to Julia. P15 was also a fan of cheat sheets:</p>
<blockquote>
<p><em>It seems like if you were going from one framework to another, from one technology stack to another—even if you &#39;re not going from A to B, you &#39;re just starting off on B—there&#39;s probably a content cheat sheet that every dev needs to know.</em> (P15)</p>
</blockquote>
<p><strong>Programmers related, the new language to previous languages.</strong> To help accelerate the learning process, programmers generally tried to relate the new language to their previous languages. Programmers started by &#34;loosely taking ideas from working in another language&#34; (P14) or looking at existing code because &#34;it&#39;s already probably been written and it&#39;s out there somewhere or at least something close to it&#34; (P1). Although this learning strategy was useful for bootstrapping, some programmers started from scratch. For example, when moving from C# to Ruby, P11 described &#34;trying to be very conservative and mindful and trying not to map anything over, but just treating everything as something brand new.&#34; Similarly, P12 explained that they did not try to map things from Python when learning SAS &#34;mostly because the syntax was so new that every time [they] tried to do anything, [they] would have to go and google the syntax.&#34; P10 expressed a similar problem when learning about managing memory in Rust after years of using C#: &#34;there wasn&#39;t a clean way for me to just get there. I had to go and learn that stuff from scratch.&#34; These examples illustrate that programmers typically try to reuse knowledge (facilitation), but sometimes avoid doing so when it&#39;s more troublesome.</p>
<p><span>Programmers use an opportunistic learning strategy, relating syntax and concepts of the new language with their previous language. This offers expediency but causes interference when major differences exist between the two languages.</span></p>
<p><img alt="*" src="https://dl.acm.org/images/bullet.gif"/> <strong>3.3. RQ3: What do experienced programmers find confusing in new languages?</strong></p>
<p>In this section, we present the themes explaining how programmers confuse language concepts.</p>
<p><strong>Old habits die hard.</strong> Programmers had to constantly suppress old habits acquired from previous languages. For example, P3—who was used to Python—had trouble adapting to block delimiters in PHP, where &#34;it&#39;s near-impossible to figure out exactly which opening brace you&#39;re closing once your HTML/PHP gets to any complexity at all.&#34; Similarly, P15 realized that &#34;in Swift, the open curly bracket needs to be on the initial line of the method declaration and if you put it on the next line the method may not execute in an expected fashion.&#34; Differences such as 0 versus 1 indexing for lists between languages such as Python and R caused frustrations for P4: &#34;typing <code>a [1]</code> thinking that it&#39;s <code>a [0]</code>, and then wasting 5 min such as a complete fool not understanding why nothing makes sense.&#34; Programmers are able to resolve these small differences, but it still causes interference at the onset of learning a new language.</p>
<p><strong>Mindshifts are required when switching paradigms.</strong> Some language transitions required fundamental shifts in mindsets, or &#34;mindshifts.&#34;<sup><a href="#R1">1</a></sup> For example, when P2 transitioned from Python to Julia, they were constantly trying to make an object and realizing that &#34;there&#39;s no objects, there&#39;s only structs!&#34; With Julia, they needed to write more functional code, a shift from the object-oriented programming that they were used to in Python: &#34;it was just needing to shift that and realize I&#39;m never gonna write &#39;something-dot-something-else&#39; ever or rarely.&#34; P10 had to completely rethink the problems they solved in C# when switching to Rust due to the ownership feature for memory safety:</p>
<blockquote>
<p><em>A really fascinating thing about learning Rust was that when I went and started to do these things—things that I would reach for in C# that I knew would work—Rust wouldn&#39;t allow it and as a result I had to rethink the problem and re-implement it in a way where the ownership characteristics of that algorithm were very explicit.</em> (P10)</p>
</blockquote>
<p>Large paradigm shifts occurred for P5, P6, and P13—all transitioning from imperative or object-oriented coding to event-driven and asynchronous coding—forcing them to think differently. The programmers had to learn brand new concepts in JavaScript such as asynchronous programming or &#34;shadow and virtual DOMs&#34; (P13). P6 described how it was difficult making sense of asynchronous code because &#34;you got a whole bunch of <code>&#39;async/await</code> mode&#39; working in your mind and you have to convert it.&#34; To make matters worse, &#34;the most confusing part is there are a couple of ways to do asynchronous programming, with observables or promises&#34; (P13). For P5, the front-end coding in TypeScript was a big challenge because &#34;for the back-end, the code I think is more straightforward. You have the logic and most likely you know single places you&#39;ll handle it. It&#39;s not like the UI.&#34; Here, the interference issues aren&#39;t due to any particular syntax or concept but the way one solves problems in the new language.</p>
<p><strong>Learning a language is difficult when there is little to no mapping with previous languages.</strong> Programmers had a harder time learning the new language when there was little to no mapping of features to previous languages. For example, P12 could not make sense of some fundamental programming language features of SAS that were clear in Python, such as statements versus method parameters. They could not understand &#34;why some things are statements that affect a procedure, but aren&#39;t parameters&#34; and were &#34;still confused about the overall syntax and what is or isn&#39;t a statement&#34;—even after having worked in the language for a few weeks. A drastic example was P5, who experienced a big transition from C++ to TypeScript, resulting in <em>tech shock</em>: &#34;Everything is different! Not just the programming language—the IDE, source control, everything is different.&#34; Similarly, P13 found that concepts were challenging in JavaScript because they &#34;could not equate it back to C++.&#34;</p>
<p>In the extreme case, programmers were forced to learn completely foreign syntax or concept. For example, P9 had difficulty learning traits in Scala because they &#34;never had a language with traits before. Traits have a default implementation and understanding what would be performant and what wouldn&#39;t—and when to use what—that was the tricky part.&#34; P7 learned that for Python, &#34;the major difference is the multiple inheritance thing, that Python inherits from the C++ world, which supports multiple inheritance. In C# you can&#39;t do that.&#34; In another case, the difficulty was due to differences in memory management, for example, when P10—who previously used C#—was learning Rust:</p>
<blockquote>
<p><em>There&#39;s a very alien concept in Rust that is the borrow checker, which is the concept of having the compiler verify more things, and the way it does it is somewhat esoteric. That&#39;s very alien, and that&#39;s something that I think is really cool but it&#39;s also very rough at the moment and so that&#39;s kind of something that&#39;s been the biggest struggle when trying to learn Rust.</em> (P10)</p>
</blockquote>
<p>The lack of mapping caused a lot of confusion even within the same context. For example, P14, who switched from one data analysis language (R) to another (Python/Pandas), could not find an immediate equivalent for R&#39;s <code>spread</code> and <code>gather</code> functions: &#34;Pandas already had the functionality but it was more hidden using drop level and unstack. These were really hard to understand in Pandas—it was some pretty weird stuff.&#34; Similarly, P15, who switched from C# to Swift, was very surprised to learn how the user interface code and its graphical layout view in Xcode were connected: &#34;Knowing that you can&#39;t interact with a UI object straight out of the box from the code is very important. Once you draw the referencing outlet connection between View and Controller you can trigger methods and <code>get/set</code> properties as you&#39;d expect in the .NET world.&#34;</p>
<p><strong>Searching for the right terminology and code examples is difficult.</strong> We found that moving to a new programming language made it difficult to search for information about the language and its associated technologies. Programmers had trouble acquiring the vocabulary even before performing the search. For P12, the names for the same structures in Python were slightly different than SAS where a &#34;dataframe is data set, a row is an observation, a column is a variable.&#34; Searching was difficult because on the one hand, &#34;it&#39;s the breadth of the libraries that usually get you, you don&#39;t even know what exists, what to even look for to see if something is already there&#34; (P1). On the other hand, insufficient search results provided little to no facilitation. P4 had difficulty searching information for the Python library <code>seaborn</code>—compared to the equivalent R library <code>ggplot</code>—because &#34;for ggplot, if you google anything, you get like 100 hits, and the top ones are bound to be good due to Google selection of results. With seaborn, you get like 10 hits.&#34;</p>
<p>Even when programmers found documentation and code examples, they were either incomplete or lacking in detail. P2 was frustrated with the Julia documentation because &#34;it was so useless for figuring out the imports.&#34; Similarly, P12 expressed that the SAS documentation &#34;only tells you how to copy-paste and run a simple program, leaving you completely mystified as to how the execution and control flow of a SAS program works.&#34; This lead to frustration, especially when better documentation existed in previous languages: &#34;Xcode documentation samples were pretty good enough to where they would run. But the documentation, MSDN, and the available samples for creating Microsoft platform-based applications were tenfold deeper and richer and easier for to use.&#34; (P15)</p>
<p><strong>Retooling is a necessary and challenging first step.</strong> Finally, before programming in the new language, programmers faced difficulty retooling themselves in a new environment. This typically involved adapting to the discrepancies of the new integrated development environment (IDE) for programming in the language. Although programmers were able to adapt to basic features of IDEs (facilitation), there was interference when some aspects of the IDE differed from their previous IDEs. For example, P15 discovered that in Xcode &#34;build targets aren&#39;t &#39;Universal&#39; in definition (like .NET) and when terminologies are shared across platforms but don&#39;t implement the same notion, you&#39;re lost for days!&#34; Interestingly, for P9 there was interference when they tried building their Scala project in IntelliJ because the IDE attempted to support Scala, but continued presenting dialogs in the previous language:</p>
<blockquote>
<p><em>Part of the problem is IntelliJ is aimed at the Java developer and I&#39;m using SBT, which is from the Scala world. And it&#39;s sort of importing the SBT into the concepts in the IDE of IntelliJ. So I&#39;m looking at dialogs that are all about Java and which JDK and that doesn&#39;t map to what I wrote in the declarative SBT language.</em> (P9)</p>
</blockquote>
<p>Other concerns regarded either a lack of IDE features or learning new features that were distracting. P2 had been &#34;spoiled with Python and PyCharm&#34; and found it very difficult to find proper IDE support for Julia; they just wanted &#34;an IDE that does syntax highlighting and IntelliSense-like auto-completion.&#34; P1 found that learning a new feature—such as debuggers—are counterproductive &#34;because you&#39;re learning and debugging at the same time as opposed to just debugging once you&#39;re fluent.&#34; However, sometimes the transition to new tools in the language also benefited programmers:</p>
<blockquote>
<p><em>I think right now the build system for us, I think it&#39;s better since now we are using DevOps—a pipeline to build the code. It&#39;s very easy for us to even schedule the private build and also it&#39;s very easy for us to quickly get new things, check in the code, test it, and even build things on top of it.</em> (P5)</p>
</blockquote>
<p><span>Programmers confuse a new language&#39;s syntax and concepts with previous languages, leading to a number of issues such as trying to suppress old habits, wrestling with mapping issues, struggling to find and use proper documentation, retooling and shifting one&#39;s mindset for new paradigms.</span></p>

<p><a href="#PageTop">Back to Top</a></p>


<h3>4. Limitations</h3>
<p>Our mixed-methods approach of investigating Stack Overflow and conducting interviews introduces certain trade-offs and limitations.</p>
<p>Our sampling approach for Stack Overflow targets diversity (rather than representativeness) in order to identify evidence of interference across many different programming languages. The posts we examined on Stack Overflow as well as our interviews do not completely cover the set of all language transitions, as the full permutation space of language transitions is intractable. Our approach attempts to cover transitions that are most likely to occur in practice, which means we might miss other interference issues.</p>
<p>We used correct and incorrect assumptions as a proxy construct for facilitation and interference. Although this approach provided a useful, high-level characterization of the Stack Overflow posts, open coding—a more intricate qualitative coding technique—might have provided further insights. However, open coding is significantly more costly to execute, and we conducted semistructured interviews with experienced programmers to delve deeper into cross-language interference.</p>
<p>Finally, qualitative research involves not only the qualitative data under investigation but also a level of subjectivity and interpretation on the part of the researcher for framing and synthesizing the results. To support interpretive validity, we performed a single-event member check with our results: six participants who replied agreed with our presentation of the results and only wanted minor changes to their quotations. Other theories such as <em>notional machines</em>, could have also been used to identify and explain confusions when learning a programming language.<sup><a href="#R6">6</a></sup></p>

<p><a href="#PageTop">Back to Top</a></p>


<h3>5. Related Work</h3>
<p><strong>Novice misconceptions.</strong> Programmers often have misconceptions although learning new programming languages, but most studies have focused on novices. Swidan et al.<sup><a href="#R20">20</a></sup> propose &#34;intervention methods to counter those misconceptions as early as possible,&#34; but this work is primarily targeted to novices. Similarly, Kaczmarczyk et al.<sup><a href="#R12">12</a></sup> have examined misconceptions and how to measure them for novices. By contrast, the novelty of our work is toward experienced programmers who need to switch languages, and requires methods of learning distinct from those designed for novices. Our study investigated switching languages for experienced programmers and examined how knowledge of previous languages interferes when learning another language.</p>
<p><strong>Programming language transitions.</strong> There are a few studies on transitions between programming languages. Scholtz and Wiedenbeck<sup><a href="#R15">15</a></sup> studied experienced Pascal or C programmers writing a program in a new language, Icon, and found that they were strongly influenced by their knowledge of what would be appropriate in previous languages. Similarly, Uesbeck et al.<sup><a href="#R22">22</a></sup> studied the effect of using multiple languages (SQL and Java) in a controlled study, and although the results were inconclusive, the authors suggest that the randomized controlled trial methodology could be effective for studying the productivity costs associated with mixing languages. For interventions, Bower et al.<sup><a href="#R7">7</a></sup> explored a new teaching approach called Continual And Explicit Comparison (CAEC) to teach Java, using facilitation, to students who have knowledge of C++. They found that students benefited from the continual comparison of C++ concepts to Java. Shrestha et al.<sup><a href="#R17">17</a></sup> used a similar technique using a tool called Transfer Tutor to teach R from the perspective of Python; programmers who used the tool found the comparisons between the languages useful. We used the lens of interference theory to uncover interference issues in the modern context, examined numerous language transitions, and found other issues that have not been explored such as little to no mapping of language features (Subsection <em>Learning a language is difficult when there is little to no mapping with previous languages</em>) and retooling (Subsection <em>Retooling is a necessary and challenging first step</em>).</p>
<p><strong>Programming knowledge.</strong> Researchers have suggested that programming plans may not generalize across different languages, and that plans cannot represent the underlying deep structure of programs. <em>Programming plans</em> are schemas that are first instantiated and then its slots are filled with concrete values as a programmer builds an understanding of the code.<sup><a href="#R19">19</a></sup> For example, in the works of Bellamy and Gilmore,<sup><a href="#R5">5</a></sup> the authors examined the protocols generated from experts in different languages as they created programs, different programming language experts generated different types of representations. We believe our results provide further insight as to why plans may not generalize across languages: we found programmers tend to relate a new language to previous languages (Subsection <em>Programmers related, the new language to previous languages</em>) (reusing previous programming plans), but due to interference issues, the previous plans might either need significant modifications (Subsection <em>Learning a language is difficult when there is little to no mapping with previous languages</em>) or be replaced entirely (Subsection <em>Mindshifts are required when switching paradigms</em>), depending on how closely related the two languages are.</p>

<p><a href="#PageTop">Back to Top</a></p>


<h3>6. Discussion and Implications</h3>
<p>Our findings demonstrate that interference is a widespread phenomenon, forcing programmers to adopt suboptimal, opportunistic learning strategies. In Stack Overflow, instances of interference are found across all of the programming languages we investigated. Furthermore, in our interviews, participants reported that interference arises routinely as they learn a new language—for example, from having to suppress old habits from previous languages (Subsection <em>Old habits die hard</em>) or having to &#34;rethink the program&#34; (P10) due to a substantially different paradigm (Subsections <em>Mindshifts are required when switching paradigms</em> and <em>Learning a language is difficult when there is little to no mapping with previous languages</em>). As opposed to learning &#34;step-by-step&#34; (P5), experienced programmers in our study used opportunistic strategies to learn essentially &#34;on [their] own&#34; (P7) or &#34;learning through work&#34; (P13), for example, using online resources or asking teammates (Subsection <em>Just-in-time learning is a dominant strategy</em>). Unfortunately, these informal approaches to learning sometimes result in an incomplete lens for how the language works, resulting in &#34;unintentional bugs&#34; (P5) and other difficult-to-diagnose problems in the code when something does not work as expected.</p>
<p>In the remainder of this section, we present design implications for technical authors, toolsmiths, and programming language designers that can help reduce some of these interference issues for programmers.</p>
<p><strong>Implication I—Design documentation that reduces interference and supports knowledge transfer.</strong> Programmers in our study desired more accessible resources that leveraged the programming knowledge they already have (Subsections <em>Just-in-time learning is a dominant strategy</em> and <em>Programmers related, the new language to previous languages</em>). Such resources included &#34;cheat sheets,&#34; which present code snippets that map their familiar language to their new language (P2) and relate concepts they already know &#34;from working in another language&#34; (P14), to the new language tutorials, and even resorting to &#34;reading other people&#39;s code&#34; (P3, P15) to understand the programming language idioms. Our findings suggest that resources that teach languages through relating a new language to a known language are more useful and accessible to programmers than resources that present the new programming language in isolation.</p>
<p>However, these resources are handcrafted using the authors&#39; intuitions about potential misconceptions, and not necessarily the ones that programmers actually have. Although there is prior work on misconceptions about novice programmers,<sup><a href="#R12">12</a></sup> misconceptions experienced programmers have are comparatively understudied. Shrestha et al.<sup><a href="#R18">18</a></sup> presented three possible instrument designs that can be used for discovering and validating misconceptions when switching languages for experienced programmers. Such research is needed to make learning resources more effective and relevant to experienced programmers.</p>
<p><strong>Implication II—Build automated tools to provide on-demand feedback.</strong> Automated tools can help programmers avoid the context switch involved with reading technical documentation by providing information in their program environment as they work (Subsections <em>Just-in-time learning is a dominant strategy</em> and <em>Searching for the right terminology and code examples is difficult</em>). For example, Johnson et al.<sup><a href="#R11">11</a></sup> propose &#34;bespoke&#34; notification tools that provide adaptive feedback to the programmer based on the programmer&#39;s prior knowledge of programming languages and concepts. Python 3 adopts this idea of using prior programmer knowledge to assist programmers who come from a Python 2 background, through hard-coded error messages:</p>
<blockquote>
<p><code>&gt;&gt;&gt; print &#34;Hello&#34;</code></p>
<p><code>File &#34;&#34;, li</code></p>
<p><code>print &#34;Hello&#34;</code></p>
<p><code>^</code></p>
<p><code>SyntaxError: Missing parentheses in call to &#39;print&#39;.</code></p>
<p><code>Did you mean print (&#34;Hello&#34;)?</code></p>
</blockquote>
<p>The <code>SyntaxError</code> message makes the assumption that this error is due to a misconception (print as a statement) instilled from experience with Python 2. We can repurpose this idea generally to language transitions and help programmers more efficiently resolve error messages.</p>
<p><strong>Implication III—Be intentional about programming language syntax, semantics, and pragmatics.</strong> Certain programming languages anticipate that new adopters arrive through common pathways. We expect most new Rust users to come from systems programming languages such as C++, and we expect most new TypeScript users to come directly from JavaScript. For these users, intentionally designing language features by considering interference effects can reduce barriers (Subsections <em>Mindshifts are required when switching paradigms</em> and <em>Learning a language is difficult when there is little to no mapping with previous languages</em>) to adopting the new programming language.</p>
<p>However, designing programming languages for common pathways requires careful design. For example, the borrow checker—a compile-time feature that helps enforce safe memory management<sup><a href="#R25">25</a></sup>—presents a substantial barrier to new Rust users and is &#34;a very alien concept&#34; (P10). The borrow checker seems similar to existing models, such as &#34;resource acquisition is initialization&#34; (RAII), in C++, but ultimately functions differently enough that it can <em>interfere</em> with other programmers&#39; past knowledge. As another example, TypeScript is designed to providing static typing to JavaScript and reducing the need to rewrite code for a smoother transition. But providing this smooth transition has a costly consequence: &#34;the TypeScript type system is not statically sound by design.&#34;</p>
<p>To improve programming language usability, we need to consider how our language design decisions interfere or facilitate with our anticipated programmers&#39; prior knowledge.</p>
<p><strong>Implication IV—Support not only programming languages, but programming language ecosystems.</strong> Issues with interference when learning new programming languages are exasperated when new programming languages bring with them new programming language <em>ecosystems</em>—that is, &#34;everything is different, not just the programming language&#34; (P5), but the environment in which the programmer builds, edits, debugs, and tests their code (for example, <em>tech shock</em>, Subsection <em>Retooling is a necessary and challenging first step</em>).</p>
<p>To address these challenges, we recommend toolsmiths and language designers build tools to bootstrap programmers or unify the tooling environment. For example, React developers provide tool support to welcome programmers into the new ecosystem. Specifically, the <code>create-react-app</code><sup><a href="#R10">10</a>, <a href="#FNJ">j</a></sup> is an integrated toolchain that abstracts away the complexities of third-party library management, live-editing, optimization, and configuration. <code>create-react-app</code> allows the user to quickly and easily begin experimenting with the library until the programmer is comfortable enough to <em>eject</em> from the <code>create-react-app</code> toolchain. Rather than providing custom tool and editing experiences for IDEs, we recommend solutions such as the language server protocol (LSP),<sup><a href="#FNK">k</a></sup> which allows programming language support to be implemented and distributed independently of any given editor or IDE, as long as that IDE implements LSP.</p>
<p>In short, language designers should collaborate with tool designers so that programmers can more easily adopt new programming languages through editing environments that are already familiar to them.</p>

<p><a href="#PageTop">Back to Top</a></p>


<h3>7. Conclusion</h3>
<p>In this study, we conducted a mixed-method study to understand what impact previous programming language experience has on programmers. We conducted an empirical study of misconceptions found in Stack Overflow questions across 18 different programming languages and semistructured interviews with 16 professional programmers. From Stack Overflow, we found 276 instances of interference that occur across multiple languages. We then interviewed programmers who reported various challenges learning a new language—such as mixing up the syntax and concepts with their previous programming languages—due to interference. We discussed design implications for technical authors, toolsmiths, and language designers, such as designing documentation and building automated tools that reduce interference, anticipating uncommon language transitions during language design, and welcoming programmers not just into a language, but its entire ecosystem. To answer the question posed in the prelude, even professional programmers have difficulties with learning programming languages, and we should offer tools and techniques to help them learn more efficiently and effectively.</p>

<p><a href="#PageTop">Back to Top</a></p>


<h3>Acknowledgments</h3>
<p>This material is based in part upon work supported by the National Science Foundation under Grant Nos. 1559593, 1755762, and 1814798.</p>

<p><a href="#PageTop">Back to Top</a></p>

<div id="article-references"><h3>References</h3>
<p><a name="R1"></a>1. Armstrong, D.J., Hardgrave, B.C. Understanding mindshift learning: The transition to object-oriented development. <em>MIS Q. 31</em>, 3 (2007), 453–474.</p>
<p><a name="R2"></a>2. Baltes, S., Treude, C., Diehl, S. Sotorrent: Studying the origin, evolution, and usage of stack overflow code snippets. <em>CoRR</em>, abs/1809.02814 (2018).</p>
<p><a name="R3"></a>3. Barik, T., Ford, D., Murphy-Hill, E., Parnin, C. How should compilers explain problems to developers? In <em>Proceedings of the 2018 26<sup>th</sup> ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering</em> (2018), ESEC/FSE, New York, NY, USA, 633–643.</p>
<p><a name="R4"></a>4. Barragan, N. <em>My Experience with Learning Rust.</em> 2018.</p>

<p><a name="R5"></a>5. Bellamy, R. and D. Gilmore. Programming plans: internal or external structures. <em>Lines Thinking: Reflections Psychol. Thought 2</em>, (1990), 59–72.</p>
<p><a name="R6"></a>6. Berry, M., Kölling, M. The state of play: A notional machine for learning programming. In <em>Proceedings of the 2014 Conference on Innovation &amp; Technology in Computer Science Education</em> (2014), Association for Computing Machinery. New York, NY, USA, 21–26.</p>
<p><a name="R7"></a>7. Bower, M., McIver, A. Continual and explicit comparison to promote proactive facilitation during second computer language learning. In <em>Proceedings of the 16<sup>th</sup> Annual Joint Conference on Innovation and Technology in Computer Science Education</em>, ITiCSE &#39;11 (2011), Association for Computing Machinery. New York, NY, USA, 218–222.</p>
<p><a name="R8"></a>8. Brandt, J., Guo, P.J., Lewenstein, J., Dontcheva, M., Klemmer, S.R. Two studies of opportunistic programming: Interleaving web foraging, learning, and writing code. In <em>Proceedings of the SIGCHI Conference on Human Factors in Computing Systems</em> (2009), Association for Computing Machinery. New York, NY, USA, 1589–1598.</p>
<p><a name="R9"></a>9. Braun, V., Clarke, V., Hayfield, N., Terry, G. <em>Thematic Analysis.</em> Springer Singapore, Singapore, 2019, 843–860</p>
<p><a name="R10"></a>10. Coelho, L.P. <em>I Tried Haskell for 5 Years and Here&#39;s How It Was</em>, 2017.</p>
<p><a name="R11"></a>11. Johnson, B., Pandita, R., Murphy-Hill, E., Heckman, S. Bespoke tools: adapted to the concepts developers know. In <em>Proceedings of the 2015 10<sup>th</sup> Joint Meeting on Foundations of Software Engineering</em> (2015), ACM, New York, NY, USA, 878–881.</p>
<p><a name="R12"></a>12. Kaczmarczyk, L.C., Petrick, E.R., East, J.P., Herman, G.L. Identifying student misconceptions of programming. In <em>Proceedings of the 41<sup>st</sup> ACM Technical Symposium on Computer Science Education</em> (2010), ACM, New York, NY, USA, 107–111.</p>
<p><a name="R13"></a>13. Norvig, P. <em>Python for Lisp Programmers</em>, 2000.</p>
<p><a name="R14"></a>14. Paskvan, D. <em>Why Coffeescript?</em>, 2014.</p>
<p><a name="R15"></a>15. Scholtz, J., Wiedenbeck, S. Learning second and subsequent programming languages: A problem of transfer. <em>Int. J. Hum.–Comput. Interact. 2</em>, 1 (1990), 51–72.</p>
<p><a name="R16"></a>16. Shankar, H. Why Learning Functional Programming and Haskell In Particular Can Be Hard, 2011.</p>
<p><a name="R17"></a>17. Shrestha, N., Barik, T., Parnin, C. It&#39;s like python but: Towards supporting transfer of programming language knowledge. In <em>2018 IEEE Symposium on Visual Languages and Human-Centric Computing (VL/HCC)</em> (2018), IEEE, Manhattan, NY, U.S., 177–185.</p>
<p><a name="R18"></a>18. Shrestha, N., Parnin, C. Instrument designs for validating cross-language behavioral differences. In <em>2019 IEEE Symposium on Visual Languages and Human-Centric Computing (VL/HCC)</em> (2019), IEEE, 205–209.</p>
<p><a name="R19"></a>19. Soloway, E., Ehrlich, K., Bonar, J. Tapping into tacit programming knowledge. In <em>Proceedings of the 1982 Conference on Human Factors in Computing Systems</em>, CHI &#39;82 (1982), 52–57.</p>
<p><a name="R20"></a>20. Swidan, A., Hermans, F., Smit, M. Programming misconceptions for school students. In <em>Proceedings of the 2018 ACM Conference on International Computing Education Research</em> (2018), ACM, 151–159.</p>
<p><a name="R21"></a>21. Tongco, M.D.C. Purposive sampling as a tool for informant selection. <em>Ethnobotany Res. Appl. 5</em>, (2007), 147–158.</p>
<p><a name="R22"></a>22. Uesbeck, P.M., Stefik, A. A randomized controlled trial on the impact of polyglot programming in a database context. In T. Barik, J. Sunshine, S. Chasins, editors, <em>9<sup>th</sup> Workshop on Evaluation and Usability of Programming Languages and Tools (PLATEAU 2018)</em>, volume 67 of <em>OpenAccess Series in Informatics (OASIcs)</em> (2019), Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik, Dagstuhl, Germany, pages 1:1–1:8.</p>
<p><a name="R23"></a>23. Underwood, B.J. Interference and forgetting. <em>Psychol. Rev. 64</em>, 1 (1957), 49.</p>
<p><a name="R24"></a>24. Walacik, B. <em>From Java to Kotlin and Back Again</em>, 2018.</p>
<p><a name="R25"></a>25. Zeng, A., Crichton, W. Identifying barriers to adoption for rust through online discourse. In <em>9<sup>th</sup> Workshop on Evaluation and Usability of Programming Languages and Tools</em> (2019), Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik, Dagstuhl, Germany, 15.</p>
</div>

<p><a href="#PageTop">Back to Top</a></p>

<div id="article-authorinfo"><h3>Authors</h3>
<p><strong>Nischal Shrestha</strong> (<a href="mailto:nshrest@ncsu.edu">nshrest@ncsu.edu</a>), NC State University Raleigh, NC, USA.</p>
<p><strong>Colton Botta</strong> (<a href="mailto:cgbotta@ncsu.edu">cgbotta@ncsu.edu</a>), NC State University Raleigh, NC, USA.</p>
<p><strong>Titus Barik</strong> (<a href="mailto:titus.barik@microsoft.com">titus.barik@microsoft.com</a>), Microsoft Redmond, WA, USA.</p>
<p><strong>Chris Parnin</strong> (<a href="mailto:cjparnin@ncsu.edu">cjparnin@ncsu.edu</a>), NC State University Raleigh, NC, USA.</p>
</div>

<p><a href="#PageTop">Back to Top</a></p>



<div id="article-permission">
<hr/><p><strong>©2022 ACM  0001-0782/22/3</strong></p>
<p>Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and full citation on the first page. Copyright for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, to republish, to post on servers, or to redistribute to lists, requires prior specific permission and/or fee. Request permission to publish from <a href="mailto:permissions@acm.org">permissions@acm.org</a> or fax (212) 869-0481.</p>
</div>

<p>The Digital Library is published by the Association for Computing Machinery. Copyright © 2022 ACM, Inc.</p>


<hr/>

<p>
No entries found
</p>

</div>

<a href="https://cacm.acm.org/magazines/2022/3/258915-here-we-go-again/%20"></a>
</section>

</div>
</div></div>
  </body>
</html>
