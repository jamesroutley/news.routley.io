<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ntietz.com/blog/rust-iterators-and-threads/">Original</a>
    <h1>&#34;Help, iterators made my Rust program slower!&#34;</h1>
    
    <div id="readability-page-1" class="page"><div>
  

  <p><strong>Monday, September 18, 2023</strong></p>

  <p>Recently in a programming community I belong to, someone presented a problem.
They had a Rust program which was using threads and for loops.
When they updated the code to use iterators, it got dramatically slower.
Why did this happen?</p>
<p>For a Rust veteran, the problem might not be surprising, but it trips up a lot of people because of how iterators work.
Let&#39;s set the stage first with an example program.</p>
<p>Here&#39;s a program similar to what they presented originally.
Instead of doing real work, though, we&#39;ll just use sleeps.</p>
<pre data-lang="rust"><code data-lang="rust">use std::thread;
use std::time;

fn do_work(i: usize) -&gt; thread::JoinHandle&lt;()&gt; {
    thread::spawn(move || {
        let duration = time::Duration::from_millis(100);
        thread::sleep(duration);
        println!(&#34;thread {i} done&#34;);
    })
}

fn main() {
    let mut handles = Vec::new();

    for i in 0..10 {
        let handle = do_work(i);
        handles.push(handle);
    }

    for handle in handles {
        handle.join();
    }
}
</code></pre>
<p>When I run this one on my machine, it takes 103 milliseconds.</p>
<p>Now let&#39;s see it using iterators, in a way you might expect to work.</p>
<pre data-lang="rust"><code data-lang="rust">use std::thread;
use std::time;

fn do_work(i: usize) -&gt; thread::JoinHandle&lt;()&gt; {
    thread::spawn(move || {
        let duration = time::Duration::from_millis(100);
        thread::sleep(duration);
        println!(&#34;thread {i} done&#34;);
    })
}


fn main() {
    (0..10)
        .map(do_work)
        .for_each(|handle| {
            handle.join();
        });
}
</code></pre>
<p>And this one takes... 1008 milliseconds!
It takes 10 times longer.
It&#39;s easier to read in a lot of ways, because it doesn&#39;t require separately keeping track of the join handles, but it&#39;s so much slower.
Why?</p>
<p>The clue is in being nearly exactly 10 times longer.
That&#39;s suspiciously similar to the number of things we&#39;re iterating over for a good reason: because we have lost all parallelism here.</p>
<p>In Rust, <a href="https://doc.rust-lang.org/std/iter/index.html#laziness">iterators are lazy</a>, which means that nothing happens with them until <code>next</code> is called on it, or it&#39;s iterated over (same thing, really).
This lets you do really neat things, like create an infinite-length iterator which you zip with a finite-length iterator (this can be a way to implement <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.enumerate"><code>enumerate</code></a>).</p>
<p>The code above chains together a few iterators.
First, we have <code>(0..10)</code>, which creates a <code>Range</code>, which is an iterator over a particular range of numbers.
Then we call <code>.map</code> on it, which transforms it into an iterator which will have a number for each iteration and call <code>do_work</code> on that number.
The first iterator isn&#39;t evaluated, but is <em>transformed</em>: when evaluated, it won&#39;t create the numbers in one go, then the threads in another; it will just do all the work for each iteration one step at a time.
And then the final step is we call <code>for_each</code> on it.
This returns nothing and does iterate over the underlying iterator.
But as we&#39;ve noted, it doesn&#39;t collect the elements of the iterator then iterate over them: it applies its closure to each element individually in turn.</p>
<p>So here we&#39;re really doing this:</p>
<pre data-lang="rust"><code data-lang="rust">for i in 0..10 {
    let handle = do_work(i);
    handle.join();
}
</code></pre>
<p>And so because we create the handle then <em>immediately join it</em>, we never achieve any parallelism and it&#39;s much slower!</p>
<p>In this sort of program, for loops are pretty idiomatic.
But you can still write it with iterators if that&#39;s more your speed, you just have to do it a little differently.
Omitting the repeated definition of <code>do_work</code>, here&#39;s an example of that.</p>
<pre data-lang="rust"><code data-lang="rust">fn main() {
    let handles: Vec&lt;_&gt; = (0..10).map(do_work).collect();
    handles.into_iter().for_each(move |handle| {
        handle.join();
    });
}
</code></pre>
<p>This is admittedly much wordier.
But critically, it does allow using iterators here and still achieving parallelism.
The key is that creating the join handles, and joining on them, are separated into two distinct steps which each consume the underlying iterators.
(A side note: that last <code>for_each</code> would be <em>much</em> cleaner as a simple for loop, but I wanted to demonstrate this. Don&#39;t do this, probably.)</p>
<p>And there you have it!
If your code is a lot slower when you use iterators, this might be why.</p>


  <hr/>
  <p>
    If this post was enjoyable or useful for you, <strong>please share it!</strong>
    If you have comments, questions, or feedback, you can email <a href="mailto:me@ntietz.com">my personal email</a>.
    To get new posts, subscribe to the <a href="https://www.eff.org/newsletter">newsletter</a> or use the <a href="https://www.eff.org/atom.xml">RSS feed</a>.
  </p>
  <p>
  <i></i> Want to become a better programmer?
  <a href="https://www.recurse.com/scout/click?t=c9a1a9e2e7a2ffefd4af20020b4af1e6">Join the Recurse Center!</a>
</p>


</div></div>
  </body>
</html>
