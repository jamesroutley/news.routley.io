<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pikuma.com/blog/what-is-dos4gw-protected-mode">Original</a>
    <h1>DOS/4GW and Protected Mode (2021)</h1>
    
    <div id="readability-page-1" class="page"><p>MS-DOS game programmers had do deal with several limitations. In this article, we will explain some of these obstacles and learn how we used the DOS/4GW extender to unleash the power of the 32-bit world for DOS games.</p><div>
                        <p>If you ever played any big title game for MS-DOS in the 90&#39;s, I&#39;ll bet that one of the first things you saw was a message saying something about &#34;DOS/4GW.&#34;</p>
                        <p><img src="https://pikuma.com/images/blog/what-is-dos4gw-protected-mode/dos-4gw.png" alt="dos 4gw message"/></p>
                        <p>I didn&#39;t think much of this message when I was younger, but as I started learning about programming for the MS-DOS, things started to make a lot more sense.</p>
                        <p>I&#39;ll try to keep this article as short and as beginner-friendly as possible. The goal here is to put things into historical context so we understand what DOS/4GW really is.</p>
                        <p>We&#39;ll start our conversation by saying that DOS/4GW is a <a href="https://en.wikipedia.org/wiki/DOS_extender" target="_blank"><strong>DOS extender</strong></a>. That means DOS/4GW is a program responsible for adding some useful stuff on top of the vanilla DOS kernel you have installed on your system. And look, I know this does not really answer anything yet, but we&#39;ll get there.</p>
                        <p>Let&#39;s begin our journey trying to understand why DOS needs <i>extending</i> in the first place.</p>
                        <h3>Direct Hardware Access</h3>
                        <p>If you were a programmer back in the 80s, you probably noticed a shift in the way we think about software. Most new operating systems (Windows, OS/2, UNIX) added a protection shield between the programmer and the hardware. If your code had to access some machine hardware resource, you had to so via the operating system API.</p>
                        <p>These APIs were designed with more serious applications in mind, like databases or spreadsheets, so limiting hardware access was a pretty smart thing to do. The OS gives each application some resource and protects it from directly accessing the memory space of other applications.</p>
                        <p>Unfortunately, full direct access to hardware was something game developers relied on for performance-enhancement tricks. And since MS-DOS <strong>did</strong> allow direct hardware access, it got some attention from PC game programmers as a system of last resort. That being said, DOS programming came with its own set of limitations.</p>
                        <p>One of the most popular limitations was the fact that the maximum amount of memory available for DOS programs was just 640 kilobytes! Well, even less than that, since DOS itself and device drivers like HIMEM and EMM386 also used RAM.</p>
                        <h3>The IBM PC</h3>
                        <p>To understand this 640 KB limitation, we need to understand a little bit about how the original IBM PC was designed. The <a href="https://en.wikipedia.org/wiki/IBM_Personal_Computer" target="_blank">IBM Personal Computer</a> was the first computer released in the IBM PC line. It was powered by an <a href="https://en.wikipedia.org/wiki/Intel_8088" target="_blank">Intel 8088</a> processor, which was a cheaper version of the Intel 8086 CPU.</p>
                        <p><img src="https://pikuma.com/images/blog/what-is-dos4gw-protected-mode/ibm-pc.png" alt="ibm pc"/></p>
                        <p>The majority of modern personal computers are distant descendants of the IBM PC.</p>
                        <p>The 8088 processor had an <strong>8-bit</strong> external data bus and a <strong>one megabyte</strong> address range.</p>
                        <p>A complete <i>Memory Map</i> of the IBM PC can be found on the <a href="https://archive.org/details/bitsavers_ibmpcpc602renceAug81_17295874/page/n39/mode/2up" target="_blank">IBM PC Technical Reference</a>, but here is an extremely simplified view of the IBM PC memory layout:</p>
                        <p><img src="https://pikuma.com/images/blog/what-is-dos4gw-protected-mode/ibm-pc-memory-layout.png" alt="ibm pc memory layout"/></p>
                        <p>The original IBM PC could only visualize the first <strong>1 MB</strong> of addressable memory. And from this first megabyte, only the bottom 640 KB could be used by applications, leaving the other 384 KB reserved for things like display buffers, expansion, BIOS and ROM.</p>
                        <p><strong>Fun fact</strong>: As the legend goes, Bill Gates was at a computer trade show in 1981 and uttered the phrase <i>&#34;640K ough to be enough for anybody!&#34;</i>. The quote ran the world, but when asked about this years later, Gates denied ever saying it.</p>
                        <p>Just to put things into context, remember when I said that DOS allowed direct hardware access? I want you to pay attention to the address 0xA0000 that sits at the very start of the reserved upper part of our first 1 MB. The location 0xA0000 is mapped to the start of the EGA and VGA graphics buffers.</p>
                        <p>Since we have direct hardware access, if we wanted to paint a pixel on the display, all we had to do is treat the bytes from 0xA0000 as if they were a large array of bytes (char). When we assign values to the bytes in that array, the display driver will map and paint the correct pixels on the screen.</p>
                        <p>For example, we can create a <i>far pointer</i> that points to memory segment 0xA000. Using a far pointer is necessary to allow the C compiler to access the full 1 MB address range. We can even take advantage of the Borland macro MK_FP to &#34;make a far pointer&#34; for us.</p>
                        <div>
                            <div>
                                <table>
                                    <tbody>
                                        <tr>
                                            <td></td>
                                            <td>
                                                <div>
<pre>char far *screen = (char far *) MK_FP(0xA000, 0);
screen[0] = 14;

</pre>
                                                </div>
                                            </td>
                                            <td></td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                        <p>To paint the first pixel on the top-left of the display using <a href="https://en.wikipedia.org/wiki/Mode_13h" target="_blank"><i>mode 13h</i></a>, we could simply set a value to that memory address directly. In the example above, the number 14 is the value of a bright yellow color from the <a href="https://www.fountainware.com/EXPL/vga_color_palettes.htm" target="_blank">VGA palette</a>.</p>
                        <p><img src="https://pikuma.com/images/blog/what-is-dos4gw-protected-mode/screen-pixel.png" alt="vga ega ms dos"/></p>
                        <p>A mode 13h screen has 320x200 pixels/bytes (64 KB), where each byte is a color value bewteeen 0 and 255.</p>
                        <p>Was that easy or what? So easy it became illegal in most modern operating systems.</p>
                        <p>This processor mode where we can only visualize the first megabyte of addressable RAM is called “<a href="https://en.wikipedia.org/wiki/Real_mode" target="_blank"><strong>real mode</strong></a>.” The name comes from the fact that addresses in real mode always correspond to real locations in memory. This is a 20-bit segmented memory address space (giving us exactly 1 MB total) with unlimited direct software access to memory.</p>
                        <p><i>Real mode</i> provides <strong>no</strong> support for memory protection, multithreading, or running multiple processes at once.</p>
                        <p><strong>Fun fact</strong>: There were some DOS hacks that tried to poorly simulate multi-tasking. For example, a <a href="https://en.wikipedia.org/wiki/Terminate-and-stay-resident_program" target="_blank">terminate-and-stay-resident</a> program (or TSR) was a computer program running under DOS that uses a system call to return control to DOS as though it has finished, but remains in computer memory so it can be reactivated later. Needless to say, this was <strong>not</strong> 100% reliable.</p>
                        <h3>Overcoming the 640 KB Barrier</h3>
                        <p>After the success of the 8088, Intel began designing CPUs to compete with mainframes and minicomputers. One thing that these bigger machines had was larger memory address spaces.</p>
                        <div>
                            <p><a href="https://commons.wikimedia.org/wiki/File:KL_Intel_i286.jpg" target="_blank"><img src="https://pikuma.com/images/blog/what-is-dos4gw-protected-mode/intel-80286.png" alt="intel 80286"/></a></p>
                            <p>The next generation in the x86 line was the <a href="https://en.wikipedia.org/wiki/Intel_80286" target="_blank">Intel 80286</a>, released in February of 1982 with the IBM PC/AT. The 286 was a <strong>16-bit</strong> processor, which means that the 286 could now address up to 16 MB of RAM!</p>
                        </div>
                        <div>
                            <p>The next generation in the Intel x86 line provided even more power and larger address spaces. Both <a href="https://en.wikipedia.org/wiki/I386" target="_blank">386</a> and <a href="https://en.wikipedia.org/wiki/I486" target="_blank">486</a> were <strong>32-bit</strong> CPUs that could now address up to 2³² bytes of memory. In other words, these 32-bit CPUs could manage up to 4 GB of RAM!</p>
                            <p><a href="https://commons.wikimedia.org/wiki/File:KL_Intel_i386DX.jpg" target="_blank"><img src="https://pikuma.com/images/blog/what-is-dos4gw-protected-mode/intel-80386.png" alt="intel 386"/></a></p>
                        </div>
                        <p>That is a lot of RAM. A lot more than the 1 MB we have access to using <i>real mode</i>.</p>
                        <h3>Protected Mode</h3>
                        <p>We had to find a way to gain access to all the RAM address range that these new 16-bit and 32-bit machines allowed. To keep retro compatibility with earlier 8088 programs, Intel designed their new CPUs with <i>split personalities</i>.</p>
                        <p>We could either run the processor on &#34;real mode&#34;, where it could only directly access the first 1 MB of memory, or we could switch and have our CPU run &#34;<a href="https://en.wikipedia.org/wiki/Protected_mode" target="_blank"><strong>protected mode</strong></a>.&#34;</p>
                        <p>The 80286 was the first processor to introduce the idea of a protected mode. Running on this mode means we have access to special CPU super powers, like virtual memory, paging, safe multi-tasking, and access to <strong>extended memory</strong> (addresses above 1 MB).</p>
                        <p>Due to the enhancements added by protected mode, it has become widely adopted and has become the foundation for all subsequent enhancements to the x86 architecture.</p>
                        <p>There was just one small issue with protected mode. Compatibility! Protected mode was not compatible with older 8088 or 8086 chips. Intel had to find a way of making these new CPUs compatible with earlier x86 programs. After all, it would be market suicide to release a new CPU that could not run the 8088 programs users paid a lot of hard-earned money for. And here is where the split personalities of these CPUs come in handy.</p>
                        <p>When an x86 CPU is powered on, it begins executing instructions in <i>real mode</i> in order to maintain backward compatibility with earlier 8088 and 8086 programs. In real mode we have <strong>no</strong> memory protection, and DOS programs basically assume they are the only process running on that machine.</p>
                        <p>Newer 16 and 32-bit processors allowed DOS to switch to <i>protected mode</i>. When running on protected mode, an operating system can take advantage of paging, multi-tasking, virtual mode, segmented addressing, and different code privilege levels. But as we know, the classic MS-DOS was not a multi-tasking OS, had no support for multithreading, and could not take advantage of all these protected mode powers. Therefore, programmers started to write their own version of DOS kernel tools to handle these shortcomings.</p>
                        <h3>DOS Extenders</h3>
                        <p>To overcome this issue of having to write entire set of kernel tools to take advantage of protected mode, a special kind of middleware program appeared: the DOS <i>extender!</i></p>
                        <p><img src="https://pikuma.com/images/blog/what-is-dos4gw-protected-mode/wild-dos-extender.png" alt="dos extender"/></p>
                        <p>And they were super effective! These DOS extenders were basically just small OS kernel tools that provided several basic services, like multi-tasking, memory management, memory protection, basic networking support, etc. The extenders saved programmers from having to write all these functionalities from scratch, leaving them to focus exclusively on creating games.</p>
                        <p>One of the first DOS extenders was the one used by the <a href="http://www.delorie.com/djgpp/" target="_blank">DJGPP</a> compiler. DJGPP was a free port of GCC for DOS, and initially used a DOS extender called Go32.</p>
                        <p>Another famous DOS extender was <a href="" target="_blank">PMODE</a>, created by Thomas Pythel and becoming publicly available in 1994. I personally never used PMODE professionally, but I remember it was developed to be used with programs written in x86 assembly, specifically those using Borland&#39;s Turbo Assembler (TASM).</p>
                        <p><strong>Fun fact</strong>: PMODE was initially created to be used by the <a href="https://en.wikipedia.org/wiki/Demoscene" target="_blank"></a>demoscene, and it became very popular in that context. One of its major differences was its small footprint. PMODE was extremely compact compared to other extenders, increasing the final program executable by approximately 10 KB.</p>
                        <p>Arguably, the most famous DOS extenders were the ones developed by <a href="https://en.wikipedia.org/wiki/Tenberry_Software" target="_blank">Rational Systems</a>. The first extender from Rational targeted 80286 processors, allowing programs to address all of 16 megabytes of RAM of the 286. This extender was appropriately called <strong>DOS/16M</strong>.</p>
                        <p>The 32-bit version of Rational&#39;s extender was developed for 386 processors and higher. Since it targetted 32-bit machines, this extender could address up to 4 gigabytes of RAM, hence the name <strong>DOS/4G</strong>.</p>
                        <p>Cool! It looks like we are getting there. Now we know now what DOS/4G means. All we are missing is the &#34;W&#34; of DOS/4GW</p>
                        <h3>DOS/4GW</h3>
                        <p>Around 1994, I remember playing a game called <a href="https://en.wikipedia.org/wiki/TFX_(video_game)" target="_blank">TFX</a>. It was developed by British studio <i>Digital Image Design</i> and raised the bar of what I thought was possible in terms of 3D software rendering on MS-DOS.</p>
                        <p><img src="https://pikuma.com/images/blog/what-is-dos4gw-protected-mode/tfx.gif" alt="tfx game"/></p>
                        <p><i>Digital Image Design</i>&#39;s TFX pushing fast 3D polygons on MS-DOS via software.</p>
                        <p>In the <i>about screen</i>, the developers mentioned some important tools that they used to create the game. As you can see below, they are using Rational&#39;s DOS/4GW extender and also something called <a href="https://en.wikipedia.org/wiki/Watcom_C/C%2B%2B" target="_blank">Watcom C/C++</a> compiler.</p>
                        <p><img src="https://pikuma.com/images/blog/what-is-dos4gw-protected-mode/tfx-about.png" alt="tfx game dos4gw compiler"/></p>
                        <p><i>Digital Image Design</i> used the DOS/4GW extender and the Watcom C++ compiler in the development of TFX.</p>
                        <p>As you probably guessed by now, the <strong>W</strong> in DOS/4GW stands for &#34;Watcom.&#34;</p>
                        <p><a href="https://doomwiki.org/wiki/DOS/4GW" target="_blank">DOS/4GW</a> was a free, stripped-down version of DOS/4G that came with Watcom compilers. At build time, the Watcom compiler would link and bundle the DOS/4GW kernel and add it <i>before</i> the main program.</p>
                        <p>This is the reason why we always see the &#34;Rational DOS/4GW&#34; copyright banner before games start. Most games from 1992 to 1998, like <a href="https://en.wikipedia.org/wiki/Doom_(1993_video_game)" target="_blank">Doom</a>, <a href="https://en.wikipedia.org/wiki/Tomb_Raider_(1996_video_game)" target="_blank">Tomb Raider</a>, <a href="https://en.wikipedia.org/wiki/Duke_Nukem_3D" target="_blank">Duke Nukem 3D</a>, and <a href="https://en.wikipedia.org/wiki/TFX_(video_game)" target="_blank">TFX</a>, used the super powers of the DOS/4GW extender.</p>
                        <p><strong>Fun fact</strong>: The original <a href="" target="_blank">Wolfenstein 3D</a> engine, created by id Software, was developed using pure <i>real mode</i>. Apogee (the original publisher) wanted to release a sequel for Wolfenstein 3D, so to improve the quality of the final game and unleash 32-bit power, the Wolfenstein 3D engine had to be rewritten to take advantage of <i>protected mode.</i></p>
                        <div>
                            <p>Just a quick side note, since we are speaking of Doom and Wolfenstein 3D. If you like learning about retro programming, you should probably check out my lectures on <a href="https://pikuma.com/courses/raycasting-engine-tutorial-algorithm-javascript" target="_blank">Raycasting Engine Programming</a>. It&#39;s a good place to start learning more about retro game development and all these techniques that game programmers used back then.</p>
                            <p><a href="https://pikuma.com/courses/raycasting-engine-tutorial-algorithm-javascript" target="_blank"><img src="https://pikuma.com/images/blog/what-is-dos4gw-protected-mode/raycasting-course.png" alt="raycasting tutorial"/></a></p>
                        </div>
                        <p>You&#39;ll also hear people say that the DOS4/GW implements the <a href="https://en.wikipedia.org/wiki/DOS_Protected_Mode_Interface" target="_blank">DPMI</a> (DOS Protected Mode Interface). The DPMI is an API for DOS extenders, defining an specification for what extenders should implement and what functions they should expose. The DPMI originated when Microsoft was developing Windows 3.0, and it became an open specification soon after. Almost all modern DOS extenders are based on DPMI.</p>
                        <h3>Putting Everything Together</h3>
                        <p>So, just to make sure we are all on the same page, let&#39;s summarize everything we learned so far and try to glue all the pieces together.</p>
                        <p>First, MS-DOS will always boot up the computer in <i>real mode</i> for compatibility reasons. All applications that ran on DOS that need to take advantage of 32-bit power had to start in real mode and then switch to 32-bit <i>protected mode.</i></p>
                        <p>Your game (compiled with the Watcom compiler) would first execute DOS4GW.EXE, which would switch to protected mode and launch your main executable. DOS/4GW will sit between your program (running in protected mode) and legacy real mode resources, like BIOS, interrupt calls, etc.</p>
                        <p>Also, since your program runs in protected mode, it has all the benefit of using protected mode addressing, which allows addresses beyond the traditional 1 MB real mode limit.</p>
                        <p>DOS/4GW handles all that noise for us. We could basically just start writing our code as if we had a 32-bit operating system.</p>
                        <p>If you were a DOS programmer back then, this felt like magic!</p>
                        
                        <p>You can find me on <a href="https://twitter.com/pikuma" target="_blank">Twitter</a> or enroll in one of my <a href="https://pikuma.com/courses">lectures</a> on retro programming.</p>
                        <center><a href="https://pikuma.com/courses"><img src="https://pikuma.com/images/courses/boxes.jpg" width="100%"/></a></center>
                        <hr/>
                        
                    </div></div>
  </body>
</html>
