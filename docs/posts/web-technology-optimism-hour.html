<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://macwright.com/2022/11/18/optimism-updates.html">Original</a>
    <h1>Web technology optimism hour</h1>
    
    <div id="readability-page-1" class="page"><div><p><picture><source srcset="/images/2022-11-18-optimism-updates-computer-with-growing-vines.webp" type="image/webp"/><img alt="Computer with growing vines" src="https://devblogs.microsoft.com/images/2022-11-18-optimism-updates-computer-with-growing-vines.jpg"/></picture></p><p>It’s too easy lately to get into a very pessimistic mood about technology. Between the developer energy wasted on crypto, which has produced negative real-world value, the wider downturn in tech stocks, and the often-antagonistic interactions between developers on Twitter and elsewhere, the vibes can be bad.</p><p>But, amongst the chaos, there are some positive trends right now. Here are a things about software development for the web that are improving.</p><h3 id="the-backend-adopted-web-standards">The backend adopted web standards</h3><p>In the not-so-recent past, when I was writing server-side code, I’d have to use a module like <a href="https://www.npmjs.com/package/request">request</a> to handle HTTP requests, the <a href="https://nodejs.org/api/querystring.html">querystring</a> builtin or the <a href="https://www.npmjs.com/package/qs">qs</a> module for decoding query strings, and <a href="https://nodejs.org/api/url.html#legacy-url-api">url.parse()</a> for parsing URLs, and <a href="https://momentjs.com/">moment</a> to format dates in English.</p><p>Today, none of those problems require, or even really benefit from, using Node.js-specific modules. We have <a href="https://developer.mozilla.org/en-US/docs/Web/API/fetch"><code>fetch()</code></a> on the backend, and the <a href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams"><code>URLSearchParams</code></a> object for query strings, the <a href="https://developer.mozilla.org/en-US/docs/Web/API/URL"><code>URL</code></a> object for URL parsing, and the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl"><code>Intl</code></a> system for formatting dates, numbers, and lists.</p><p>These platform APIs are really good: they handle almost every need while also being user-friendly. And their standardization is a win overall: it means that, whether you’re writing code for a <a href="https://workers.cloudflare.com/">Cloudflare Worker</a>, <a href="https://bun.sh/">bun</a>, or <a href="https://deno.land/">deno</a>, you can use a lot of the same classes and methods.</p><h3 id="web-frameworks-fixed-some-of-their-performance-problems">Web frameworks fixed some of their performance problems</h3><p>In the two and a half years since I wrote <a href="https://macwright.com/2020/05/10/spa-fatigue.html">second-guessing the modern web</a>, framework developers have been chipping away at those problems.</p><p>Both <a href="https://remix.run/">Remix</a>, which went from a paid-product indie startup to a VC-backed startup to an acquisition by Shopify, and <a href="https://nextjs.org/">Next</a> have rolled out techniques to render more of the application on the backend. Next uses <a href="https://beta.nextjs.org/docs/rendering/fundamentals">React Server Rendering</a>, a very confusing but promising technology. Remix is pushing people to use patterns with React that can work without client-side JavaScript, in a way that mirrors some of the techniques from <a href="https://rubyonrails.org/">Ruby on Rails</a>, like “progressively enhancing” form submissions to use AJAX instead of full-page refreshes.</p><p><a href="https://astro.build/">Astro</a> is focusing on the “much less interactive” kinds of websites like CMS-driven blogs or marketing sites, for which React has always been absolute overkill. It lets those sites use sprinklings of React or other frontend framework tech. Mostly-static websites have always mostly suffered from being implemented in React, and they make easy targets for the anti-JavaScript-frameworks folks, but if people still want to use React or a similar tool for implementing them, better to do it in Astro than not.</p><p>There are also <em>many</em> React alternatives, like <a href="https://www.solidjs.com/">Solid</a>, <a href="https://svelte.dev/">Svelte</a>, and <a href="https://qwik.builder.io/">Quik</a>, which aim to improve upon React’s performance and bundle size, but it’s hard to say how that’ll end. So far I don’t think any of the alternatives have enough momentum to become the new standard. They’re great technology, but it’s a long tail of solutions outside of React and Vue.</p><h3 id="rust-and-go-based-tools-are-making-typescript-development-faster">Rust and Go based tools are making TypeScript development faster</h3><p>Modern web applications are written in TypeScript but the tooling around their development is increasingly tools in Rust and Go. We have <a href="https://esbuild.github.io/">esbuild</a> (Go) that replaces Babel and Webpack for Remix and other frameworks, <a href="https://swc.rs/">SWC</a> (Rust) that replaces Babel for Next.js and <a href="https://turbo.build/pack">Turbo.build</a> (Rust) that might eventually also replace Webpack. <a href="https://rome.tools/">Rome</a> (Rust) is trying to replace <a href="https://prettier.io/">prettier</a> for formatting files and, eventually the rest of the stack. The creator of SWC is also working on a <a href="https://github.com/dudykr/stc">replacement for the TypeScript compiler</a> in Rust.</p><p>Developing TypeScript applications is basically getting better in every way: cycles are faster, the tools are more helpful, and less configuration is needed to get a good result. The era of <a href="https://webpack.js.org/">Webpack</a> and <a href="https://babeljs.io/">Babel</a> were essential stepping stones to getting here, but this era is better.</p><h3 id="remix-rpc-and-better-approaches-to-doing-crud-with-web-apps">Remix, RPC and better approaches to doing CRUD with web apps</h3><p>What I think bugged me most back when I wrote about the problems with single-page apps was the absence of a plan for data: how frontend code would interact with the backend and do basic <a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</a> operations. It seemed like the stock answer was that there was a “backend team” that produced APIs that somehow the frontend team was able to “consume” in frontend applications, but in most cases this just never worked. The two pieces could never be fully isolated, and a lot of times this backend/frontend distinction inspired a <a href="https://en.wikipedia.org/wiki/Waterfall_model">waterfall development methodology</a> of designing APIs and hoping that they were the right ones, with expensive and slow cycles to update them when they inevitably didn’t fit the application’s needs.</p><p>This dynamic is certainly still happening, but we’re seeing some movements away from it. Remix <a href="https://remix.run/docs/en/v1/tutorials/blog#loading-data">integrated data loading and updating into each route</a> in a way that, again, distinctly reminds me of <a href="https://guides.rubyonrails.org/action_controller_overview.html#parameters">Rails’s controller system</a>. We’ve also got a resurgence of RPC systems for loading and updating data with <a href="https://blitzjs.com/">Blitz</a> and <a href="https://trpc.io/">trpc</a>. I’m rooting for both, and I’m <a href="https://www.placemark.io/post/the-application-stack-blitz">using Blitz for Placemark</a>, though <a href="https://npmtrends.com/@trpc/server-vs-blitz">trpc</a> is the one gaining steam.</p><h3 id="paas-is-back-in-fashion">PaaS is back in fashion</h3><p>I think there was an era recently when startups were strongly encouraged to use AWS, Google Cloud, or Azure, but at the same time those cloud services were an exceptionally bad fit for most startups. When you were building your platform using <a href="https://twitter.com/QuinnyPig/status/1531359545645076485">ClickOps</a> (clicking around the AWS console), Kubernetes, or CloudFormation, or whatever - it was negative ROI.</p><p>Companies were spending precious time building custom server setups that were worse than Heroku defaults. Heroku - a Platform as a Service, just let you run applications and not worry about networking or operating systems. It was a good level of abstraction, but it was nearly abandoned by its creators and wasn’t keeping up with web technology.</p><p>Thankfully, right as Heroku <a href="https://techcrunch.com/2022/08/25/heroku-announces-plans-to-eliminate-free-plans-blaming-fraud-and-abuse/">eliminated their free tier</a> and <a href="https://www.bleepingcomputer.com/news/security/heroku-admits-that-customer-credentials-were-stolen-in-cyberattack/">got hacked</a>, a new group of companies entered the ring to offer a similar level of abstraction but updated for 2022. <a href="https://render.com/">Render</a> might be the most similar to Heroku, then there’s <a href="https://railway.app/">Railway</a> and <a href="https://fly.io/">Fly</a> with more emphasis on “edge compute”, and <a href="https://www.flightcontrol.dev/">Flight Control</a> offering a thinner layer on top of AWS.</p><p>I think it turns out that configuring security groups and making decisions about regions and Ubuntu versions is not a good use of developers time, and that the AWS/Kubernetes standard was only really attractive to large companies with dedicated devops teams.</p><h3 id="the-apple-m1-fixed-computers">The Apple M1 fixed computers</h3><p>One more update. In <a href="https://macwright.com/2019/11/15/something-is-wrong-with-computers.html">2019, I wrote “Something is wrong with computers”</a>, about stagnating CPU, disk, and memory specifications for laptops. At least for Apple laptops, the subject of that post and the kind that I use, this has really changed.</p><p>In 2019, the maximum RAM ever configurable in a MacBook was 16GB. It’s now 64GB in the MacBook Pro with an M1 Max chip. The most storage configurable, ever, was 750 gigabytes, and in 2019 that number had decreased to 512GB. You can now get a MacBook pro with an 8TB disk. Clock speed is still around 3Ghz, but the M1 chips are <a href="https://browser.geekbench.com/v5/cpu/compare/18713402?baseline=18713668">dramatically faster than 2019’s</a>, with better battery time.</p></div></div>
  </body>
</html>
