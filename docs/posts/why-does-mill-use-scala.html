<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mill-build.org/mill/depth/why-scala.html">Original</a>
    <h1>Why does Mill use Scala?</h1>
    
    <div id="readability-page-1" class="page"><div>
<div>
<h3 id="_dynamic_classloading"><a href="#_dynamic_classloading"></a>Dynamic Classloading</h3>
<p>One often-under-appreciated facet of the Java Virtual Machine is its ability to do dynamic
classloading. This functionality is largely irrelevant in the backend-service space that Java
is often used in (where the entire codebase is present during deployment), and has largely
failed as a mechanism for running un-trusted potentially-malicious code in a safe sandbox
(see <a href="https://en.wikipedia.org/wiki/Java_applet">Applets</a>).</p>
<p>However, in the case of a build system, the need is different: you need to dynamically build,
load, and run a wide variety of mostly-trusted code. Most build systems do not provide any
hard security boundaries, and assume the code you get from your source control system is
not malicious. But build systems need to be pluggable, with the same build system
potentially being used to manage a wide variety of different tools and frameworks.</p>
<p>It is in this context that the JVM’s dynamic classloading shines, and Mill goes all in
dynamic classloading. Features like <a href="https://mill-build.org/mill/extending/import-ivy-plugins.html" class="page">import $ivy</a>,
<a href="https://mill-build.org/mill/extending/running-jvm-code.html" class="page">Running Dynamic JVM Code</a>, or the
<a href="https://mill-build.org/mill/extending/meta-build.html" class="page">Mill Meta-Build</a> would be difficult-to-impossible in
less-dynamic platforms like Go, Swift, Rust, or C++. Mill simultaneously takes advantage of
the Scala language’s <a href="#_static_typing">Static Typing</a>, while also leaning heavily on the
JVM’s dynamic nature: it uses classloader hierarchies, dynamic class loading and unloading,
isolated and partially-isolated classloaders, bytecode instrumentation, the whole works.
It wouldn’t be a stretch to say that a build tool like Mill could not be written on top of
any other platform than the JVM it runs on today.</p>
</div>
<div>
<h3 id="_huge_jvm_tooling_ecosystem"><a href="#_huge_jvm_tooling_ecosystem"></a>Huge JVM Tooling Ecosystem</h3>
<p>The JVM ecosystem is huge, not just for the Java language but also things like Kotlin, Scala,
Android, and so on. IDEs, debuggers, profilers, heap analyzers, if a software tool exists
you can bet there is an equivalent or integration with the JVM ecosystem.</p>
<p>From the perspective of IDE support, Mill is able to get (almost) full support for understanding
and navigating its <code>build.mill</code> files, basically for free: IntelliJ already has deep support
for understanding JVM code, classfiles, classpaths, the Scala language itself, and so on.
VSCode also works pretty well out-of-the-box with minimal modifications.</p>
<p>Apart from the IDE, the Java ecosystem has perhaps some of the best tooling available of
any programming ecosystem, both free and proprietary, and Mill makes heavy use of it. If
a build is stuck, you can use <code>jstack</code> to see what it is doing. If a build is slow or running
out of memory, you can hook it up to <a href="https://www.ej-technologies.com/jprofiler">JProfiler</a>
or <a href="https://www.yourkit.com/">Yourkit</a> to see what is taking up space.</p>
<p>Lastly there is the wealth of libraries: if something has a programming language integration,
there probably is one for Java, and Mill can make use of any Java libraries seamlessly
as part of the build using <a href="https://mill-build.org/mill/extending/import-ivy-plugins.html" class="page">import $ivy</a> or
<a href="https://mill-build.org/mill/extending/running-jvm-code.html" class="page">dynamic classloading</a>. With Mill, the ability to
directly import <em>any JVM artifact on the planet</em> without needing a purpose-built plugin
open ups an enormous about of possibilities: anything that can be done in the Java ecosystem
can be done as part of your Mill build with a
single <a href="https://mill-build.org/mill/extending/import-ivy-plugins.html" class="page">import $ivy</a>.</p>
</div>
<div>
<h3 id="_built_in_publishing_infrastructure"><a href="#_built_in_publishing_infrastructure"></a>Built-in Publishing Infrastructure</h3>
<p>The last major benefit Mill gets from running on the JVM is the publishing infrastructure:
primarily Sonatype’s <a href="https://central.sonatype.com/">Maven Central</a>. Mill has a rich and
constantly growing set of <a href="https://mill-build.org/mill/extending/thirdparty-plugins.html" class="page">Third-Party Plugins</a> that
are published on Maven Central for people to use, and anyone can easily
<a href="https://mill-build.org/mill/extending/writing-plugins.html" class="page">write and publish their own</a>. While Maven Central isn’t
perfect, it does a solid job as a package repository: hosting an enormous catalog of
artifacts for the Java community to build upon, with nice properties such as
<a href="https://central.sonatype.org/register/namespace/">namespacing</a>,
<a href="https://search.maven.org/">discoverability</a>,
<a href="https://central.sonatype.org/publish/requirements/immutability/">immutability</a>,
and <a href="https://central.sonatype.org/publish/requirements/#sign-files-with-gpgpgp">code signing</a>.
Apart from Maven Central itself, there is a wealth of other hosted or self-hosted JVM
package repositories available for you to choose.</p>
<p>Mill makes heavy use of Maven Central and the rest of the Java publishing infrastructure:
Mill’s own artifacts are all published on Maven Central, Mill builds can resolve any
artifact from Maven Central to use in your build, and anyone can publish their own plugins
to Maven Central for free. it is easy to
<a href="https://mill-build.org/mill/javalib/dependencies.html#_repository_config" class="page">configure alternate repositories</a>,
and Mill provides a wealth of <a href="https://mill-build.org/mill/fundamentals/library-deps.html" class="page">tools and techniques for
working with JVM dependencies</a>.</p>
<p>Most build tools end up with some half-baked plugin distribution model: downloading source
code off of Github, ad-hoc package formats or zip files, published artifacts that can be
sneakily changed or even deleted after the fact, and so on. Mill instead relies on
the widely-used publishing and distribution system that every JVM project already uses,
providing a predictable and well-designed publishing and artifact distribution experience
far beyond what can be provided by most other build tools.</p>
</div>
</div></div>
  </body>
</html>
