<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rischmann.fr/blog/how-i-built-zig-sqlite">Original</a>
    <h1>How I Built Zig-SQLite</h1>
    
    <div id="readability-page-1" class="page"><div>
            

            <nav>
                <ul>
                    <li><a href="#introduction">Introduction</a></li>
                    <li><a href="#why-build-a-wrapper">Why build a wrapper</a></li>
                    <li><a href="#what-is-comptime">What is <code>comptime</code></a></li>
                    <li><a href="#a-brief-demo-of-zig-sqlite">A brief demo of zig-sqlite</a></li>
                    <li><a href="#comptime-checked-bind-parameters">comptime-checked bind parameters</a></li>
                    <li>
                        <ul>
                            <li><a href="#number-of-bind-parameters">Number of bind parameters</a></li>
                            <li><a href="#type-of-parameters">Type of parameters</a></li>
                        </ul>
                    </li>
                    <li><a href="#read-a-row-of-data-into-a-type">Read a row of data into a type</a></li>
                    <li>
                        <ul>
                            <li><a href="#how-it-works">How it works</a></li>
                            <li><a href="#examples">Examples</a></li>
                        </ul>
                    </li>
                </ul>
            </nav>

            
            <p>I wrote and maintain <a href="https://github.com/vrischmann/zig-sqlite">zig-sqlite</a>, a Zig package that wraps the SQLite C API.</p>
            <p>Its goals are to use Zig’s features to augment SQLite’s capabilities and provide a idiomatic Zig API.</p>

            
            <p>Zig has <a href="https://ziglang.org/documentation/0.9.1/#C">excellent C interoperability</a> which means using SQLite is just one <a href="https://ziglang.org/documentation/0.9.1/#cInclude"><code>@cInclude</code></a> away, however using the
                “raw” SQLite API has some drawbacks in the context of a Zig project:</p>
            <ul>
                <li>Zig has <a href="https://ziglang.org/documentation/0.9.1/#Slices">slices</a>, C does not. This means you need to pass the array or slice pointer and its length to the SQLite functions.</li>
                <li>Zig structs can have methods, C structs can’t.</li>
                <li>Zig has native <a href="https://ziglang.org/documentation/0.9.1/#Errors">error sets</a>, C doesn’t.</li>
            </ul>
            <p>All of those issues can be fixed by introducing a Zig wrapper API.</p>
            <p>In addition, using Zig’s <a href="https://ziglang.org/documentation/0.9.1/#comptime">comptime</a> feature we can augment SQLite’s capabilities with:</p>
            <ul>
                <li>the ability to <em>type check </em>the bind parameters of a statement</li>
                <li>the ability to read a row of data into (almost) any type</li>
            </ul>
            <p>This blog post will focus on how I used <em>comptime </em>to implement these features.</p>

            
            <p>Let’s start by seing what <code>comptime</code> actually is.</p>
            <p><code>comptime</code> is Zig’s way of defining code that must evaluate to something known at <em>compile-time</em>.</p>
            <p>You can do a lot with this:</p>
            <ul>
                <li>combined with types as first-class citizens, you can create new types from comptime code (this is how <a href="https://ziglang.org/documentation/0.9.1/#Generic-Data-Structures">generics</a> are implemented)</li>
                <li>combined with <a href="https://ziglang.org/documentation/0.9.1/#typeInfo">type reflection</a>, you can create type-checked printf functions, JSON parser and more</li>
                <li><a href="https://ziglang.org/documentation/0.9.1/#Compile-Time-Variables">comptime vars</a> allow you to do complex computations at compile-time, for example you can imagine parsing some data at compile-time to generate a data structure
                    which will later be used at runtime.</li>
            </ul>
            <p>We use all of these capabilities in zig-sqlite.</p>

            
            <p>With all that in mind, this is how you use zig-sqlite today:</p>
            <pre>const std = @import(&#34;std&#34;);

const sqlite = @import(&#34;sqlite&#34;);

pub fn main() anyerror!void {
    var db = try sqlite.Db.init(.{
        .mode = sqlite.Db.Mode{ .Memory = {} },
        .open_flags = .{ .write = true },
    });
    defer db.deinit();

    try db.exec(&#34;CREATE TABLE user(id integer primary key, age integer, name text)&#34;, .{}, .{});

    const user_name: []const u8 = &#34;Vincent&#34;;

    // Insert some data
    try db.exec(
        &#34;INSERT INTO user(id, age, name) VALUES($id{usize}, $age{u32}, $name{[]const u8})&#34;,
        .{},
        .{ @as(usize, 10), @as(u32, 34), user_name },
    );
    try db.exec(
        &#34;INSERT INTO user(id, age, name) VALUES($id{usize}, $age{u32}, $name{[]const u8})&#34;,
        .{},
        .{ @as(usize, 20), @as(u32, 84), @as([]const u8, &#34;José&#34;) },
    );

    // Read one row into a struct
    const User = struct {
        id: usize,
        age: u32,
        name: []const u8,
    };
    const user_opt = try db.oneAlloc(
        User,
        std.testing.allocator,
        &#34;SELECT id, age, name FROM user WHERE name = $name{[]const u8}&#34;,
        .{},
        .{
            .name = user_name,
        },
    );

    // Read single integers; reuse the same prepared statement
    var stmt = try db.prepare(&#34;SELECT id FROM user WHERE age = $age{u32}&#34;);
    defer stmt.deinit();

    const id1 = try stmt.one(usize, .{}, .{@as(u32, 34)});
    stmt.reset();
    const id2 = try stmt.one(usize, .{}, .{@as(u32, 84)});
}</pre>
            <p>The code is not complete, full demo is available <a href="https://github.com/vrischmann/zig-sqlite-demo">here</a>.</p>
            <p>This showcases the features I want to talk about. I encourage you to play with the code (try to remove or change the type of a bind parameter).</p>

            
            <p>When you prepare a statement zig-sqlite creates a brand new type only for this prepared statement. This new type contains the <em>parsed query </em>which will be used to perform checks when you call either <code>iterator</code>, <code>exec</code>,
                <code>one</code> or <code>all</code> on a statement.</p>
            <p>This implies the query is known at compile-time; in my experience and my projects this is almost always the case.</p>
            <p>This is the trimmed code from zig-sqlite which creates this custom type (actual code <a href="https://github.com/vrischmann/zig-sqlite/blob/b357fb1a6d799bea07e4e4c3972565d87c579340/sqlite.zig#L1498-L1510">here</a>):</p>
            <pre>pub fn StatementType(comptime query: []const u8) type {
    return Statement(ParsedQuery(query));
}

pub fn Statement(comptime query: anytype) type {
    return struct {
        // NOTE: lots of code here, omitted for clarity
    };
}

const query = &#34;SELECT name FROM user WHERE age = $age{u32}&#34;;
var stmt: StatementType(query) = try db.prepare(query);</pre>
            <p>(If you’re wondering what <code>anytype</code> is, look <a href="https://ziglang.org/documentation/0.9.1/#toc-Function-Parameter-Type-Inference">here</a>).</p>
            <p>You can see how the statement type will be different for different queries.</p>
            <p>When you call <code>exec</code>, <code>one</code> or <code>all</code> zig-sqlite will use this data on the statement to do two things:</p>
            <ul>
                <li>check that the number of bind parameters provided is strictly identical to the number of bind markers in the query</li>
                <li>check that each bind parameter has the correct type according to the <em>type annotation </em>of the bind marker</li>
            </ul>

            <h2 id="number-of-bind-parameters">Number of bind parameters</h2>
            <p>The first check is straightforward: executing a SQL query which has for example 4 bind markers with any other number of bind parameters is never correct.</p>
            <p>With the query metadata in our statement type we can enforce this at compile-time.</p>
            <p>Let’s see what happens if we provide the wrong number of bind parameters.</p>
            <p>Given the following statement:</p>
            <pre>var stmt = try db.prepare(&#34;SELECT id FROM user WHERE age = $age{u32}&#34;);</pre>
            <p>Here’s what happens if we don’t respect the contract:</p>
            <pre>./third_party/zig-sqlite/sqlite.zig:2057:17: error: expected 1 bind parameters but got 2
                @compileError(comptime std.fmt.comptimePrint(&#34;expected {d} bind parameters but got {d}&#34;, .{
                ^
./third_party/zig-sqlite/sqlite.zig:2148:26: note: called from here
            try self.bind(.{}, values);
                         ^
./third_party/zig-sqlite/sqlite.zig:2194:41: note: called from here
            var iter = try self.iterator(Type, values);
                                        ^
./src/main.zig:43:29: note: called from here
    const id1 = try stmt.one(usize, .{}, .{ @as(u32, 34), @as(usize, 2000) });
                            ^
./src/main.zig:5:29: note: called from here
pub fn main() anyerror!void {</pre>
            <p>The error tells us that we expect exactly 1 bind parameter (because there is 1 bind marker) but we provided 2. We can also see directly in the error that we call <code>stmt.one</code> with a tuple of 2 values, which is the source of the compile
                error.
            </p>

            <h2 id="type-of-parameters">Type of parameters</h2>
            <p>The second check is more involved and depends on a <em>type annotation</em>.</p>
            <p>You might have already guessed with the demo code, zig-sqlite supports an “extended” version of SQL which allows a user to annotate a bind marker, instructing zig-sqlite to check that <em>all</em> values bound to this marker have this exact
                Zig type.</p>
            <p>Let’s go back to the example above:</p>
            <pre>var stmt = try db.prepare(&#34;SELECT id FROM user WHERE age = $age{u32}&#34;);</pre>
            <p>This annotates the bind marker <code>$age</code> with the Zig type <code>u32</code>. Now anytime this statement is executed the <code>$age</code> bind parameter <em>must </em>have been bound to a <code>u32</code>; it’s a compilation error
                if that’s not the case.</p>
            <p>Let’s see how it fails to compile when we try to pass a <code>u16</code> when a <code>u32</code> is expected:</p>
            <pre>_ = try stmt.one(usize, .{}, .{@as(u16, 34)});</pre>
            <p>Here is the error from the Zig compiler:</p>
            <pre>./third_party/zig-sqlite/sqlite.zig:2085:17: error: value type u16 is not the bind marker type u32
                @compileError(&#34;value type &#34; ++ @typeName(Actual) ++ &#34; is not the bind marker type &#34; ++ @typeName(Expected));
                ^
./third_party/zig-sqlite/sqlite.zig:2072:58: note: called from here
                        else =&gt; comptime assertMarkerType(struct_field.field_type, typ),
                                                         ^
./third_party/zig-sqlite/sqlite.zig:2148:26: note: called from here
            try self.bind(.{}, values);
                         ^
./third_party/zig-sqlite/sqlite.zig:2194:41: note: called from here
            var iter = try self.iterator(Type, values);
                                        ^
./src/main.zig:43:29: note: called from here
    const id1 = try stmt.one(usize, .{}, .{@as(u16, 34)});
                            ^
./src/main.zig:5:29: note: called from here
pub fn main() anyerror!void {</pre>
            <p>The first line tells us exactly what’s wrong: we try to bind a value of type <code>u16</code> where a value of type <code>u32</code> is expected.</p>

            
            <p>Thanks to Zig’s <em>type reflection </em>we can read a row of data into a user-provided type without needing to write any “mapping” function: we know the type we want to read (here the <code>User</code> struct) and can analyse it at compile-time.
                With this data we can call the appropriate internal “read” functions.</p>

            <h2 id="how-it-works">How it works</h2>
            <p>Let’s go back to the example in the demo:</p>
            <pre>const User = struct {
    id: usize,
    age: u32,
    name: []const u8,
};

const user_opt = try db.oneAlloc(
    User,
    std.testing.allocator,
    &#34;SELECT id, age, name FROM user WHERE name = $name{[]const u8}&#34;,
    .{},
    .{
        .name = user_name,
    },
);</pre>
            <p>Notice we pass the type as first parameter. This type is ultimately used to create an <a href="https://github.com/vrischmann/zig-sqlite/blob/f32017ea460d00f0dd3ac134f64131a1dab93b44/sqlite.zig#L1033-L1054"><code>Iterator</code></a> which is
                responsible for reading data when <a href="https://github.com/vrischmann/zig-sqlite/blob/f32017ea460d00f0dd3ac134f64131a1dab93b44/sqlite.zig#L1067"><code>next</code></a> or <a href="https://github.com/vrischmann/zig-sqlite/blob/f32017ea460d00f0dd3ac134f64131a1dab93b44/sqlite.zig#L1125"><code>nextAlloc</code></a>                is called.</p>
            <p>So the meat of the code is in the iterator and it starts in <a href="https://github.com/vrischmann/zig-sqlite/blob/f32017ea460d00f0dd3ac134f64131a1dab93b44/sqlite.zig#L1124-L1207"><code>nextAlloc</code></a>. The first step is to get the
                <em>type info </em>of the user type with <a href="https://ziglang.org/documentation/0.9.1/#typeInfo"><code>@typeInfo</code></a>: this returns a value of type <a href="https://github.com/ziglang/zig/blob/326b2aa27bdf43b695798192e415db995ee9918b/lib/std/builtin.zig#L193"><code>std.builtin.Type</code></a>                which is a tagged union we can analyse using a simple switch statement, for example:</p>
            <pre>switch (@typeInfo(UserType)) {
    .Int =&gt; processInt(),
    .Optional =&gt; processOptional(),
    .Array =&gt; processArray(),
    .Struct =&gt; processStruct(),
    else =&gt; @compileError(&#34;invalid type &#34; ++ @typeName(UserType)),
}</pre>
            <p>Of course not all types make sense in the context of our <code>nextAlloc</code> function (it makes no sense to read into a <code>ComptimeInt</code> (which is the type of a comptime integer) or <code>Fn</code> (which is the type of a function)
                for example).</p>
            <p>In our example we end up taking the <a href="https://github.com/vrischmann/zig-sqlite/blob/f32017ea460d00f0dd3ac134f64131a1dab93b44/sqlite.zig#L1199-L1204"><code>.Struct</code></a> prong which calls <a href="https://github.com/vrischmann/zig-sqlite/blob/f32017ea460d00f0dd3ac134f64131a1dab93b44/sqlite.zig#L1426-L1442"><code>readStruct</code></a>.
                The <code>std.builtin.Type.Struct</code> type contains the struct fields which we iterate over <em>at compile-time</em> using a <a href="https://ziglang.org/documentation/0.9.1/#inline-for"><code>inline for</code></a>.</p>
            <p>Next we call <a href="https://github.com/vrischmann/zig-sqlite/blob/f32017ea460d00f0dd3ac134f64131a1dab93b44/sqlite.zig#L1444-L1494"><code>readField</code></a> for each struct field, giving it the field <em>type</em> and its position in the
                struct fields slice. <code>readField</code> also uses <code>@typeInfo</code> to do its thing and ultimately it will end up calling a specific read function depending on the field type.</p>
            <p>In our example this would be:</p>
            <ul>
                <li>two calls to <a href="https://github.com/vrischmann/zig-sqlite/blob/f32017ea460d00f0dd3ac134f64131a1dab93b44/sqlite.zig#L1256-L1260"><code>readInt</code></a></li>
                <li>one call to <a href="https://github.com/vrischmann/zig-sqlite/blob/f32017ea460d00f0dd3ac134f64131a1dab93b44/sqlite.zig#L1299-L1348"><code>readBytes</code></a></li>
            </ul>
            <p>Finally the result of the <code>readField</code> call is <a href="https://github.com/vrischmann/zig-sqlite/blob/f32017ea460d00f0dd3ac134f64131a1dab93b44/sqlite.zig#L1438">assigned to the field</a> in the user type using <a href="https://ziglang.org/documentation/master/#field"><code>@field</code></a>.</p>
            <p>It’s important to remember that all these steps are done at <em>compile-time</em>; the code in the final binary would do something like this (not real code):</p>
            <pre>const user = User{
    .id = try stmt.readInt(usize, 1),
    .age = try stmt.readInt(u32, 2),
    .name = try stmt.readBytes([]const u8, std.testing.allocator, 3, .Text),
};</pre>

            <h2 id="examples">Examples</h2>
            <p>I already demoed this before but here’s reading into a struct:</p>
            <pre>const User = struct {
    id: usize,
    age: u32,
    name: []const u8,
};

const user_opt = try db.oneAlloc(
    User,
    std.testing.allocator,
    &#34;SELECT id, age, name FROM user WHERE name = $name{[]const u8}&#34;,
    .{},
    .{
        .name = user_name,
    },
);</pre>
            <p>You can also read a single type:</p>
            <pre>const age_opt = try db.one(usize, &#34;SELECT age FROM user WHERE name = $name{[]const u8}&#34;, .{}, .{
    .name = user_name,
});</pre>
            <p>Note we’re not using the <code>oneAlloc</code> method here since we don’t need to allocate memory when reading a simple integer.</p>
            <p>We also support reading into enums but this is a little more involved:</p>
            <pre>const Foo = enum(u7) {
    pub const BaseType = u16;

    low = 34,
    high = 84,
};

const foo_opt = try db.one(Foo, &#34;SELECT age FROM user WHERE name = $name{[]const u8}&#34;, .{}, .{
    .name = user_name,
});</pre>
            <p>The <code>BaseType</code> type is mandatory and tells zig-sqlite how to read the <em>underlying </em>column from SQLite. Here we first read a <code>u16</code> value.</p>
            <p>Next we convert the <code>u16</code> value to a <code>Foo</code> enum value.</p>
            <p>We can also use the <code>BaseType</code> to store the enum value as a string:</p>
            <pre>const Foo = enum {
    pub const BaseType = []const u8;

    low,
    high,
};

const user_opt = try db.oneAlloc(
    Foo,
    std.testing.allocator,
    &#34;SELECT name FROM user WHERE name = $name{[]const u8}&#34;,
    .{},
    .{
        .name = user_name,
    },
);</pre>
            <p>Now the stored value will be the enum <em>tag name</em> (here <code>low</code> or <code>high</code>). When the <code>BaseType</code> is a string we must use the <code>oneAlloc</code> function because reading a string requires allocation.</p>

            
            <p>Zig is my first real experience using powerful meta-programming and the experience has been mostly positive. Despite the general lack of documentation around Zig I didn’t have much trouble learning about <code>comptime</code> by looking at
                the existing source code in the standard library (specifically the <a href="https://github.com/ziglang/zig/blob/b08d32ceb5aac5b1ba73c84449c6afee630710bb/lib/std/fmt.zig#L73"><code>std.fmt.format</code></a> function and the <a href="https://github.com/ziglang/zig/blob/b08d32ceb5aac5b1ba73c84449c6afee630710bb/lib/std/json.zig#L1917-L1926">JSON parser</a>).
                If you’re interested in <code>comptime</code> I encourage you to look at the standard library too.</p>
            <p>I started this project in October 2020, it wasn’t always fun (I stumbled on quite a few compiler bugs) but I’m really happy with what I ended up with.</p>
        </div></div>
  </body>
</html>
