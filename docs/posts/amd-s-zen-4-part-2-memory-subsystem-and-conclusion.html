<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://chipsandcheese.com/2022/11/08/amds-zen-4-part-2-memory-subsystem-and-conclusion/">Original</a>
    <h1>AMD’s Zen 4, Part 2: Memory Subsystem and Conclusion</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>Please go through <a href="https://chipsandcheese.com/2022/11/05/amds-zen-4-part-1-frontend-and-execution-engine/">part 1</a> of our Zen 4 coverage, if you haven’t done so already. This article picks up where the previous one left off. To summarize, Zen 4 has made several moves in the frontend and execution engine meant to increase utilization of existing execution resources, which remain largely unchanged since Zen 3 and even Zen 2. Now, we’re going to look at the memory subsystem, from the data side’s perspective.</p>
<h2>Memory Execution</h2>
<p>Like Zen 3, Zen 4 uses three AGUs to calculate addresses for load and store instructions. These addresses, along with store data if applicable, are passed to the load/store unit. The load/store unit then has to face the complicated job of making sure memory accesses appear to execute in program order, while extracting as much performance as possible.</p>
<p>High performance means keeping a lot of operations in flight to hide memory access latency, and the load/store unit has to do its role by tracking pending memory operations. To do this, Zen 4 implements a large load queue. Since Zen 1, AMD’s load queue works differently than Intel’s. After a load operation receives data, the load queue is free to de-allocate it. A separate, larger structure is used to track load operations through to retirement. To differentiate these structures, we’ll call the larger structure a “load validation queue”, and the published load queue the “load execution queue”. Separating out these structures lets AMD keep 136 load operations in flight, way more than their published load queue size would suggest</p>
<div>
<figure><img data-attachment-id="11569" data-permalink="https://chipsandcheese.com/2022/11/08/amds-zen-4-part-2-memory-subsystem-and-conclusion/zen4_ldst-drawio/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_ldst.drawio.png?fit=706%2C421&amp;ssl=1" data-orig-size="706,421" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="zen4_ldst.drawio" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_ldst.drawio.png?fit=706%2C421&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_ldst.drawio.png?fit=688%2C410&amp;ssl=1" decoding="async" width="688" height="410" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_ldst.drawio.png?resize=688%2C410&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_ldst.drawio.png?resize=688%2C410&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></figure></div>
<p>Stores on Zen 4 have to be buffered in a relatively small 64 entry store queue. This store queue sees even more pressure with AVX-512 code, since a 512-bit store will consume two store queue entries.</p>
<p>Once memory operations are in their respective queues, the load/store unit has to make sure memory ordering is preserved. If an in-flight store has an address that overlaps with a newer load’s, the store’s data can be forwarded to the load. Like Zen 3, Zen 4 can do store forwarding with no latency. That is, a chain of dependent loads and stores will execute at 2 IPC. </p>
<p>However, terms and conditions may apply. The load and store addresses must match exactly. An extra 1 cycle latency penalty is assessed if the store crosses a 32 byte aligned boundary. The mechanism fails completely if the store crosses a 4 KB aligned page boundary.</p>

<p>Partial overlap cases where the load is completely contained within the store are handled with a latency of 6-7 cycles, which is a slight improvement over Zen 3’s 7-8 cycles. Store forwarding fails on both Zen generations if the load and store overlap, but the load can’t be completed with just data from the store. Zen 4 takes a 19 cycle penalty in this case, which probably corresponds with waiting for the store to retire and reading the data from L1D. In contrast, Zen 3 could handle the failure case in 18 cycles, but only if the store address is aligned to a 4 byte boundary. Otherwise, Zen 3 suffers a 25 cycle penalty, which Zen 4 avoids. To summarize reciprocal throughput for loads dependent on a store, for all the tested store forwarding cases:</p>
<figure><table><tbody><tr><td></td><td>Zen 4</td><td>Zen 3</td><td>Golden Cove</td><td>Bulldozer</td></tr><tr><td>Exact address match</td><td>1 cycle</td><td>1 cycle</td><td>0.5 cycles (2x load + 2x store per clock)</td><td>8 cycles</td></tr><tr><td>Exact address match, misaligned store</td><td>32B Boundary:</td><td>32B Boundary:</td><td>64B Boundary:</td><td>16B Boundary:</td></tr><tr><td>Store completely overlaps load</td><td>6-7 cycles</td><td>7-8 cycles</td><td>5-6 cycles</td><td>Same as failure case below</td></tr><tr><td>Store partially overlaps load (failed forwarding)</td><td>19 cycles</td><td>18 cycles (store is 4B aligned) or 25 cycles otherwise</td><td>19-20 cycles</td><td>36 cycles</td></tr><tr><td>4K Page Boundary Crossed</td><td>43-44 cycles</td><td>Load contained within store: 34-36 cycles</td><td>Load crosses page boundary: 27-28 cycles</td><td>Store crosses page boundary: 50-51 cycles</td></tr></tbody></table><figcaption>What’s Bulldozer doing here? Are we thinking of covering that later?</figcaption></figure>
<p>Zen 4 retains most of Zen 3’s store forwarding characteristics, and improves slightly on the most common cases. There’s a slight regression on the less common page boundary crossing cases. Crossing a page boundary while handling a store forwarding case is extremely expensive on both architectures. It’s even more expensive than on Zen 1 and Zen 2, and is best avoided.</p>
<p>Golden Cove’s store forwarding enjoys slightly lower latency than Zen 4 for most cases, except when the load and store both cross a 64B cacheline boundary. For exact address match cases, Golden Cove enjoys a throughput advantage rather than a latency one. With four AGUs, Golden Cove can generate addresses for two loads and two stores per cycle.</p>
<p>For more common, non-overlapping loads, Golden Cove continues to have an advantage because the L1D is accessed in larger chunks, and will suffer from fewer misaligned accesses. We like to think of memory accesses as being byte addressable and totally random. But in practice, caches are addressed in larger, aligned chunks. “Aligned” here means the memory address is a multiple of a specific size. For example, the low 5 bits of a 32 byte aligned memory address will be zero. A “misaligned” access crosses an alignment boundary, forcing the load/store unit to make two L1D lookups to satisfy the request.</p>
<div>
<figure><a href="https://chipsandcheese.com/zen4_align/"><img data-attachment-id="11590" data-permalink="https://chipsandcheese.com/zen4_align/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_align.png?fit=757%2C543&amp;ssl=1" data-orig-size="757,543" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="zen4_align" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_align.png?fit=757%2C543&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_align.png?fit=688%2C494&amp;ssl=1" decoding="async" width="688" height="494" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_align.png?resize=688%2C494&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_align.png?resize=688%2C494&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a></figure></div>
<p>Golden Cove’s L1D handles loads and stores in 64 byte, cacheline sized blocks. AMD’s L1D in contrast handles writes in 32 byte blocks, starting with Zen 2. A write that crosses the boundary between two 32B blocks on Zen 4, or 64B blocks on Golden Cove, takes two cycles to complete. Zen 4 improves over Zen 3, which could take 5 cycles to handle such a misaligned load, and could only get the 2 cycle case if the store was also 4B aligned. Golden Cove, Zen 3, and Zen 4 also see reduced throughput for loads crossing a 64B boundary, though that case is handled better because load throughput is higher in the first place.</p>
<p>Accesses that cross a 4 KB boundary introduce more complications, because virtual to physical address translations are usually handled in 4 KB pages. Handling such an access would require accessing two TLB entries as well. All Zen generations handle this case without any more difficulty than the regular misaligned load case, indicating that their TLBs can service multiple lookups per cycle. Intel’s Golden Cove and Ice Lake architectures do incur a minor penalty when handling loads that cross a 4K boundary. </p>
<figure><table><tbody><tr><td></td><td>Zen 4</td><td>Zen 3</td><td>Golden Cove</td><td>Server Ice Lake</td></tr><tr><td>Misaligned Load</td><td>1 cycle</td><td>1-2 cycles</td><td>1 cycle</td><td>1 cycle</td></tr><tr><td>Misaligned Store</td><td>2 cycles</td><td>2 cycles if 4B aligned, 5-6 cycles otherwise</td><td>2 cycles</td><td>2 cycles</td></tr><tr><td>Misaligned Load, 4K Page Boundary Crossed</td><td>1 cycle</td><td>1 cycle</td><td>3-4 cycles</td><td>4 cycles</td></tr><tr><td>Misaligned Store, 4K Page Boundary Crossed</td><td>33-34 cycles</td><td>25 cycles if 4B aligned</td><td>24 cycles</td><td>25 cycles</td></tr></tbody></table><figcaption>Reciprocal throughput for misaligned accesses</figcaption></figure>
<p>Writes carry massive penalties in all tested architectures. They’re especially heavy on Zen 4, even compared to prior Zen generations. I wonder if AMD found that split-page accesses were rare enough that a higher penalty was acceptable in exchange for higher clock speeds.</p>
<h2>Cache and Memory Performance</h2>
<p>Computing power has been steadily outpacing memory performance for the past three decades. CPUs in response have used increasingly complex cache setups to keep delivering performance increases. Intel and AMD’s high performance cores have settled on a triple level caching scheme. Each core gets a small L1 cache, and a modestly sized L2 cache to insulate it from L3 latency. The L3 cache is many megabytes in size, and shared across a set of cores.</p>
<h3>Latency with 2 MB Pages</h3>
<p>Let’s start by testing memory latency with 2 MB pages, to get an idea of the cache hierarchy from a single core’s point of view. Using 2 MB pages isn’t representative of how most applications will access memory, but it does make more efficient use of TLB capacity, and lets us look at cache latency and TLB penalty separately. </p>
<p>Zen 4’s caches closely resemble Zen 3’s. The biggest change is doubling L2 size to 1 MB, at the cost of 2 cycles of latency. That in turn also pushes L3 latency up two cycles.</p>
<div>
<figure><img data-attachment-id="11842" data-permalink="https://chipsandcheese.com/2022/11/08/amds-zen-4-part-2-memory-subsystem-and-conclusion/zen4_latency_cycles/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_latency_cycles.png?fit=1116%2C524&amp;ssl=1" data-orig-size="1116,524" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="zen4_latency_cycles" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_latency_cycles.png?fit=1116%2C524&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_latency_cycles.png?fit=688%2C323&amp;ssl=1" decoding="async" width="688" height="323" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_latency_cycles.png?resize=688%2C323&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_latency_cycles.png?w=1116&amp;ssl=1 1116w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_latency_cycles.png?resize=768%2C361&amp;ssl=1 768w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_latency_cycles.png?resize=688%2C323&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></figure></div>
<p>Intel’s Golden Cove has higher latency at all cache levels, though Intel’s core-private caches are slightly larger. Golden Cove’s L1D has 5 cycles of latency, or just one more cycle than Zen 4’s 4 cycles. One cycle might not seem like much, but that represents a 25% latency increase over AMD, and the L1D cache will be in the path of all memory accesses. The latency difference is smaller at L2, where Intel’s 1280 KB cache has 15 cycle latency against AMD’s 1024 KB, at 14 cycles. L2 will see far fewer accesses than L1, and a 1 cycle difference here is a much smaller difference percentage wise.</p>
<p>At L3, there’s a massive difference in latency. Intel does not run the ring at core clock, and has a longer ring that services two E-Core clusters as well as an iGPU. Golden Cove takes almost 20 more cycles to get data from its L3 than Zen 3 and Zen 4. So, Intel uses a larger L2 to shield the core from L3 latency, and gives Golden Cove massive reordering capacity to hide L3 latency. </p>
<div>
<figure><img data-attachment-id="11843" data-permalink="https://chipsandcheese.com/2022/11/08/amds-zen-4-part-2-memory-subsystem-and-conclusion/zen4_latency_ns/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_latency_ns.png?fit=1115%2C523&amp;ssl=1" data-orig-size="1115,523" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="zen4_latency_ns" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_latency_ns.png?fit=1115%2C523&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_latency_ns.png?fit=688%2C323&amp;ssl=1" decoding="async" width="688" height="323" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_latency_ns.png?resize=688%2C323&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_latency_ns.png?w=1115&amp;ssl=1 1115w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_latency_ns.png?resize=768%2C360&amp;ssl=1 768w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_latency_ns.png?resize=688%2C323&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></figure></div>
<p>If we look at true latency, Zen 4’s very high 5.7 GHz clock speed comes into play. We see incredibly low L1D latency at just 0.7 ns. L1D hitrate is typically over 80-90%, so most memory accesses will enjoy this very low latency. AMD’s new L2 is similarly impressive. Zen 4’s clock speed increase means that its L2 has slightly lower latency than the L2 in prior Zen generations. </p>
<p>Finally, AMD gets Zen 4’s L3 latency back down to the 8-9 ns range. Zen 3 had increased the amount of L3 accessible to a single core by unifying a L3 cache across eight cores and eight L3 slices, but incurred a latency penalty to do so. With Zen 4’s clock speed, L3 latency comes back down to Zen 2 levels, but with twice as much capacity. Zen 4’s L3 latency also pulls ahead of Zen 3’s V-Cache latency. However, Zen 3’s V-Cache variant holds a 3x advantage in cache capacity.</p>
<p>In memory, we see a reasonable latency of 73.35 ns with a 1 GB test size. We won’t pay too much attention to this because memory latency is highly dependent on the specific DDR setup that the user pairs with the CPU, and the distributed nature of our testing means it’s impossible to match memory setups even when platforms support the same memory types. Our Ryzen 7950X testbed was set up with DDR5-6000, which gave it better memory latency than our i7-12700K Golden Cove result, which used JEDEC DDR5-4800. In turn, my (Clam’s) personal Ryzen 3950X achieved slightly lower latency at 72.76 ns using DDR4-3333 16-18-18-38. In terms of latency, nothing is out of the ordinary.</p>
<h3>Latency with 4 KB Pages</h3>
<p>While 2 MB pages help efficiently use TLB capacity, most applications use 4 KB pages to reduce fragmentation and wasted memory. For example, if you’re buffering a packet that’s less than 2 KB in size, or caching a small file, mapping memory in 2 MB blocks could be quite wasteful. But tracking address translations at 4 KB granularity puts more pressure on TLB capacity. To improve performance, Zen 4 increases the L1 DTLB’s size from 64 entries to 72. The L2 TLB sees its entry count increased from 2048 to 3072. Zen 4 is therefore capable of caching address translations for 288 KB of memory with no latency overhead, or 12 MB with a slight 7-8 cycle penalty. </p>
<div>
<figure><a href="https://chipsandcheese.com/?attachment_id=11634"><img data-attachment-id="11634" data-permalink="https://chipsandcheese.com/2022/11/08/amds-zen-4-part-2-memory-subsystem-and-conclusion/zen4_4k_vs_2m_latency/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_4k_vs_2m_latency.png?fit=1115%2C524&amp;ssl=1" data-orig-size="1115,524" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="zen4_4k_vs_2m_latency" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_4k_vs_2m_latency.png?fit=1115%2C524&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_4k_vs_2m_latency.png?fit=688%2C323&amp;ssl=1" decoding="async" width="688" height="323" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_4k_vs_2m_latency.png?resize=688%2C323&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_4k_vs_2m_latency.png?w=1115&amp;ssl=1 1115w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_4k_vs_2m_latency.png?resize=768%2C361&amp;ssl=1 768w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_4k_vs_2m_latency.png?resize=688%2C323&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a></figure></div>
<p>Intel’s Golden Cove also has a 2048 entry L2 TLB, just like Zen 3 and Zen 2. Zen 4 therefore has even more of a latency advantage at larger test sizes. If we access the L3 cache on Zen 4, Zen 3, and Golden Cove using 4 KB pages but don’t exceed L2 TLB capacity, we see latencies of around 9.47 ns, 10.44 ns, and 13.72 ns respectively. Zen 4 and Zen 3 are both already ahead of Golden Cove by a significant margin, but we’re mainly seeing the difference in raw L3 latency here. </p>
<div>
<figure><a href="https://chipsandcheese.com/?attachment_id=11639"><img data-attachment-id="11639" data-permalink="https://chipsandcheese.com/2022/11/08/amds-zen-4-part-2-memory-subsystem-and-conclusion/zen4_4k_latency-2/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_4k_latency-2.png?fit=1115%2C524&amp;ssl=1" data-orig-size="1115,524" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="zen4_4k_latency-2" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_4k_latency-2.png?fit=1115%2C524&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_4k_latency-2.png?fit=688%2C323&amp;ssl=1" decoding="async" width="688" height="323" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_4k_latency-2.png?resize=688%2C323&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_4k_latency-2.png?w=1115&amp;ssl=1 1115w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_4k_latency-2.png?resize=768%2C361&amp;ssl=1 768w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_4k_latency-2.png?resize=688%2C323&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a></figure></div>
<p>At the 12 MB test size and larger, we start to see Zen 4’s larger L2 TLB come into play. Zen 3 and Golden Cove both have to start doing page walks as accesses spill out of the L2 TLB, which potentially incurs up to 4 extra memory accesses to figure out the physical address. All three architectures have separate page directory caches in their page walkers that cache entries in higher level paging structures, so they’re probably not doing too many extra accesses at test sizes that barely spill out of the L2 TLB. </p>
<p>Still, even a fast page walk is worse than grabbing a translation straight out of the L2 TLB, so the difference is clear. Zen 3’s L3 latency rises above 12 ns at the 12 MB test size, while Zen 4 stays at just below 10 ns. Golden Cove suffers more, with latency exceeding 15 ns even though we’re still well within the 12700K’s 25 MB L3’s capacity.</p>
<p>So, AMD has done an impressive job of improving cache access latency, in ways that headline cycle count numbers don’t fully capture. Zen 4’s higher clock speeds mean that actual latencies for the L1 and L3 caches have improved, while the L2 cache gets its capacity doubled with an extremely minor latency regression (2.44 ns on the 7950X versus 2.4 ns on the 5950X). Improved TLB capacity further improves latency in practice, by reducing virtual to physical address translation overhead for typical applications. All of this comes together to give Zen 4 a significant latency advantage over Golden Cove at all cache levels.</p>
<h3>Bandwidth, Single Core</h3>
<p>While memory access latency is important, bandwidth can be important too. Vectorized code can be particularly hungry for memory bandwidth. Despite adding AVX-512 support, AMD has not made significant adjustments to core-private caches. Per-cycle load bandwidth remains similar to that of Zen 3 and Zen 2. Zen 4’s larger L2 is a welcome addition, because it should reduce bandwidth demands on the shared L3. But improvements in L1 and L2 bandwidth come down to Zen 4’s clock speed increase.</p>
<p>L3 bandwidth from a single core has improved on Zen 4, with an average of 27 bytes per cycle compared to 24 bytes per cycle on Zen 3. That’s quite close to the theoretical bandwidth of the interface from each core to L3. AMD has probably beefed up the size of the queue between L2 and L3, to the extent that it’s almost big enough to completely absorb L3 latency.</p>
<div>
<figure><img data-attachment-id="11642" data-permalink="https://chipsandcheese.com/zen4_st_bw/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_st_bw.png?fit=1145%2C498&amp;ssl=1" data-orig-size="1145,498" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="zen4_st_bw" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_st_bw.png?fit=1145%2C498&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_st_bw.png?fit=688%2C299&amp;ssl=1" decoding="async" width="688" height="299" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_st_bw.png?resize=688%2C299&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_st_bw.png?w=1145&amp;ssl=1 1145w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_st_bw.png?resize=768%2C334&amp;ssl=1 768w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_st_bw.png?resize=688%2C299&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/><figcaption>Different memory setups were used, so don’t compare DRAM bandwidth. TGL data provided by cha0s, Golden Cove AVX-512 data is from CapFrameX</figcaption></figure></div>
<p>Intel has put a lot of emphasis on vector performance, and it shows. Golden Cove’s core-private caches can provide exceptional bandwidth, with the L1D handling three 256-bit loads per cycle, or two 512-bit loads per cycle. The latter is only possible with AVX-512, but Golden Cove holds a significant L1D bandwidth advantage even with AVX. This advantage persists in L2, where Intel has a 64 byte per cycle interface between L1D and L2. With AVX-512, Golden Cove has a staggering 40% bandwidth advantage over Zen 4, in L2 sized regions. AMD can’t achieve the same level of performance with AVX, because the <a href="https://github.com/travisdowns/uarch-bench/wiki/How-much-bandwidth-does-the-L2-have-to-give,-anyway%3F">L1D doesn’t have enough ports to handle a fill request from L2 and deliver full bandwidth to the core at the same time</a>. Still, Golden Cove can still beat Zen 4 with just AVX.</p>
<p>The situation flips around in L3, where AMD’s excellent L3 design can deliver almost as much bandwidth as their L2. Intel’s bandwidth in contrast drops like a rock. Golden Cove barely averages 20 bytes per cycle from L3 with no contention from other cores.</p>
<p>When test sizes spill out into DRAM, Zen 4 maintains very high bandwidth per-core. This suggests each Zen 4 core is able to track a lot of pending L3 misses, or more specifically, L2 misses. AMD only fills its L3 cache with lines evicted from L2 (hence the term “victim cache”), which means it does not prefetch into L3. That makes Zen 4’s L2 the last cache level capable of generating prefetch requests. By being able to generate requests to L3 and beyond based on the access pattern it’s seeing from L1 misses, the L2 can utilize more available memory level parallelism at its level, without being limited by memory level parallelism generated by L1 misses.</p>
<p>We can even estimate the L2 miss queue size with Little’s Law:</p>
<figure><table><tbody><tr><td>Core</td><td>Little’s Law Calculation (Queue length = throughput * latency)</td></tr><tr><td>7950X, Zen 4</td><td>(57.29 GB/s / 64B line per request) * (78.72 ns with 4K pages) = 70.45</td></tr><tr><td>5950X, Zen 3</td><td>(34.96 GB/s / 64B line per request) * (91.04 ns with 4K pages) = 49.72</td></tr><tr><td>3950X, Zen 2</td><td>(24.33 GB/s / 64B line per request) * (95.92 ns with 4K pages) = 36.46</td></tr></tbody></table></figure>
<p>Obviously this calculation isn’t perfect, because we tested with 4 KB pages out to very large test sizes, and didn’t make an attempt to estimate how often a page walk would result in requests to L3 and beyond. But it does suggest Zen 4 has more aggressive prefetching at L2, a deeper queue between L2 and L3, or both. </p>
<h3>Multi-Threaded Bandwidth</h3>
<p>With all threads loaded, Zen 4 achieves very high total bandwidth. That’s largely because it’s able to maintain a very high clock speed of over 4.8 GHz, judging by achieved L1D bandwidth. Because all levels of Zen 4’s cache hierarchy run at core clock, or at least at the speed of the fastest core in a cluster, the 7950X also enjoys increased L2 and L3 bandwidth even though the width of the buses between each cache level haven’t changed across Zen generations.</p>
<div>
<figure><img data-attachment-id="11651" data-permalink="https://chipsandcheese.com/zen4_mt_bw/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_mt_bw.png?fit=1145%2C498&amp;ssl=1" data-orig-size="1145,498" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="zen4_mt_bw" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_mt_bw.png?fit=1145%2C498&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_mt_bw.png?fit=688%2C299&amp;ssl=1" decoding="async" width="688" height="299" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_mt_bw.png?resize=688%2C299&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_mt_bw.png?w=1145&amp;ssl=1 1145w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_mt_bw.png?resize=768%2C334&amp;ssl=1 768w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_mt_bw.png?resize=688%2C299&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></figure></div>
<p>Intel’s Alder Lake is competitive against prior generations of AMD 16 core desktop CPUs. AMD had more “big” cores, but Golden Cove had wider buses to its L1D and L2 caches. But Zen 4’s higher clocks change that. Alder Lake can only match AMD’s L1D bandwidth if AVX-512 is in play, but that feature is of course not enabled. With or without AVX-512, Alder Lake can’t match Zen 4’s L2 bandwidth at all.</p>
<p>By splitting the L3 into clusters, AMD trades some cache capacity efficiency to make the bandwidth and latency problem easier to solve. For the past few Zen generations, AMD held a substantial L3 performance advantage over Intel. Zen 4 extends this further.</p>
<h3>DRAM Bandwidth</h3>
<p>Zen 4 also moves over to DDR5, which dramatically increases the memory subsystem’s theoretical bandwidth. We saw just above 50 GB/s of read bandwidth using a 5950X equipped with DDR4-3600, or just above 88% of theoretical DRAM bandwidth. Our DDR5-6000 equipped 7950X platform achieved 72.85 GB/s at the same 3 GB test size. On one hand, that’s a notable 43% increase in memory bandwidth. On the other, Zen 4 actually sees a decrease in memory bandwidth efficiency. A 128-bit DDR5-6000 bus can theoretically reach 96 GB/s, and we only achieved 76% of that.</p>
<p>One theory is that Zen 4’s DRAM bandwidth is limited by the link between the memory controller and fabric. AMD’s diagram shows that the link is 32 bytes per cycle wide in both directions.</p>
<div>
<figure><img data-attachment-id="11664" data-permalink="https://chipsandcheese.com/2022/11/08/amds-zen-4-part-2-memory-subsystem-and-conclusion/zen4_ciod_topo/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_ciod_topo.jpg?fit=800%2C450&amp;ssl=1" data-orig-size="800,450" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;1&#34;}" data-image-title="zen4_ciod_topo" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_ciod_topo.jpg?fit=800%2C450&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_ciod_topo.jpg?fit=688%2C387&amp;ssl=1" decoding="async" width="688" height="387" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_ciod_topo.jpg?resize=688%2C387&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_ciod_topo.jpg?w=800&amp;ssl=1 800w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_ciod_topo.jpg?resize=768%2C432&amp;ssl=1 768w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_ciod_topo.jpg?resize=688%2C387&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></figure></div>
<p>However, that is unlikely. FCLK in our testing was set to 2000 MHz. 32 bytes per cycle at 2000 MHz works out to 64 GB/s, which is well under what we were able to achieve. UCLK runs at 3000 MHz, or half of DDR transfer rate. 32 bytes per cycle at 3000 MHz should mean that full DDR bandwidth can be achieved in either direction. That does not rule out a bandwidth limitation at the link between Infinity Fabric and the memory controller, but it does suggest the link to fabric is wider than AMD’s diagram suggests. </p>
<p>Another related theory is that bandwidth can be improved if we mix reads and writes in a 1:1 ratio, since the link can deliver 32 bytes in each direction. However, mixing reads and writes introduces a different problem at the DRAM level. Unlike links to cache, the DRAM bus is not bidirectional and has to be explicitly switched between read and write modes. These switches are not free and force the memory bus to idle for a number of cycles, reducing achieved bandwidth. Therefore, we don’t see a significant bandwidth increase when using an access pattern that mixes reads and writes.</p>
<div>
<figure><img data-attachment-id="11672" data-permalink="https://chipsandcheese.com/2022/11/08/amds-zen-4-part-2-memory-subsystem-and-conclusion/zen4_bw_access_patterns/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_bw_access_patterns.png?fit=649%2C372&amp;ssl=1" data-orig-size="649,372" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="zen4_bw_access_patterns" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_bw_access_patterns.png?fit=649%2C372&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_bw_access_patterns.png?fit=649%2C372&amp;ssl=1" decoding="async" width="649" height="372" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_bw_access_patterns.png?resize=649%2C372&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_bw_access_patterns.png?resize=649%2C372&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/><figcaption>Memory bandwidth achieved using a variety of access patterns, with a 128-bit DDR5-6000 setup. The “add” and “copy” tests use a 1:1 mix of reads and writes.</figcaption></figure></div>
<p>With a read-modify-write access pattern, we see a 1% bandwidth increase, which is hardly even worth talking about. The write pattern is actually a 1:1 mix of reads and writes too, since each write operation (except in special cases) requires a cacheline to be read as well. That’s because the instruction might only modify part of the cacheline, and the CPU needs to merge the write with the existing cacheline contents. That read is known as a “read for ownership”, or a RFO, because it means the reading core owns the cacheline and has a guarantee that no one else can write to it. If we account for that by multiplying 36.86 GB/s of write bandwidth by two, we get 73.72 GB/s, which is again not very different from pure read bandwidth.</p>
<p>Other access patterns see significant drops, including the copy pattern with REP MOVSB. That test uses a microcoded string copy instruction that tells the CPU exactly how much data it needs to move, which lets it avoid RFOs. It therefore also features a 1:1 mix of reads and writes.</p>
<p>We do see some evidence that write bandwidth might be limited by the links between the CCDs and the IO die. AMD’s diagram shows that those links are 16 bytes per cycle wide. Across both CCDs, that works out to 64 GB/s at 2000 MHz FCLK. With special write instructions that avoid RFOs, we get extremely close to 64 GB/s, but not more. The REP STOSB instruction tells the CPU upfront how much data to set to a particular value, letting it avoid RFOs when it knows an entire cacheline will be overwritten. Non-temporal writes (with MOVNTPS) use a write-combining memory protocol that also avoids RFOs, and bypasses caches. Both methods reach within 1% of theoretical CCD to IO die write bandwidth. This is unlikely to be a limitation in most applications, where memory reads far outnumber memory writes.</p>
<p>As far as Zen 4’s read memory bandwidth goes, a fabric bandwidth limitation is unlikely. Instead, the new DDR5 memory controller seems to be less efficient than the old DDR4 one at extracting every last bit of bandwidth. Maybe it’s not scheduling requests as well and runs into secondary timings more. But the big picture is that Zen 4 enjoys a significant bandwidth advantage over prior Zen generations, thanks to DDR5 memory. AMD’s 16 core desktop Ryzen chips can become memory bandwidth bound, if given well threaded, vectorized loads. Even with reasonable cache hitrates, 16 cores can draw a lot of bandwidth, so DDR5’s bandwidth boost is appreciated. And even DDR5 bandwidth won’t be enough to feed 16 cores, so AMD continues to rely on effective caching to maintain a performance edge in well-threaded workloads.</p>
<h2>Conclusion</h2>
<p>As its name suggests, Zen 4 is the fourth installment in AMD’s line of Zen architectures. Like Zen 2, Zen 4 combines an architectural change with an improved process node to deliver a generational performance increase. At the same time, AMD reduces risk by avoiding more drastic changes while attempting to transition to a new process node. So, it’s not a surprise to see similar changes in a lot of areas, particularly with caching and register files, where improved density makes larger capacities feasible. </p>
<figure><table><tbody><tr><td>Area</td><td>Zen 4 over Zen 3</td><td>Zen 2 over Zen 1(+)</td><td>Comment</td></tr><tr><td>Branch Predictor</td><td>Large but unspecified improvements</td><td>TAGE predictor implemented for L2</td><td>Higher density probably allows for larger BTB structures</td></tr><tr><td>Op Cache</td><td>~68% op cache capacity increase</td><td>Capacity doubled from Zen 1, but L1i capacity halved</td><td>Higher density makes a op cache capacity increase feasible</td></tr><tr><td>Reordering Capacity</td><td>Vector registers extended to 512-bits to handle AVX-512</td><td>Vector registers extended to 256 bits </td><td>Higher density makes a large increase in register file capacity is acceptable</td></tr><tr><td>Scheduling and Execution</td><td>No scheduling capacity change</td><td>Integer scheduling queues get 16 entries, up from 14</td><td>Reduce risk by avoiding major scheduling layout changes</td></tr><tr><td>Vector Execution</td><td>No significant change to most commonly used execution units</td><td>128-bit FP and vector units get width doubled to 256 bits</td><td></td></tr><tr><td>L1D Bandwidth</td><td>No significant change. Still 2×256-bit load and 1×256-bit store</td><td>128-bit paths doubled to 256-bits wide, giving 2×256-bit load and 1×256-bit store</td><td></td></tr><tr><td>L2 TLB</td><td>50% capacity increase, from 2K entries to 3K</td><td>33% capacity increase, from 1.5K entries to 2K</td><td>TLBs are caches by another name, so again more density helps</td></tr><tr><td>L2</td><td>Capacity doubled to 1 MB at the cost of 2 clock cycles of latency</td><td>No change</td><td></td></tr></tbody></table></figure>
<p>However, Zen 4 does skip out on some areas, especially where vector execution is concerned. Compared to Zen 3, and even Zen 2, Zen 4 does not increase native vector execution width, and does not boost maximum L1D bandwidth. Zen 2 also made minor execution and scheduling changes over Zen 1, while Zen 4 keeps Zen 3’s configuration. The result is a claimed 13% IPC increase. Compared to the last two Zen generations, this might seem underwhelming. But 13% is comparable to the jump between <a href="https://www.anandtech.com/show/9483/intel-skylake-review-6700k-6600k-ddr4-ddr3-ipc-6th-generation/9">Ivy Bridge and Haswell</a>, which Anandtech puts at 11.2%. We also have to take performance per clock increases with clock speed in context.</p>
<figure><table><tbody><tr><td></td><td>Claimed IPC Improvement</td><td>Max Clock Speed</td><td>Clock Speed Increase * IPC Improvement</td></tr><tr><td>Zen 2 over Zen+</td><td>15%</td><td>4.7 GHz on 3950X (+9% over 2700X’s 4.3 GHz)</td><td>+25.3%</td></tr><tr><td>Zen 3 over Zen 2</td><td>19%</td><td>5.05 GHz on 5950X (+7.4% over 3950X)</td><td>+27.8%</td></tr><tr><td>Zen 4 over Zen 3</td><td>13%</td><td>5.7 GHz on 7950X (+12.8% over 5950X)</td><td>+27.4%</td></tr></tbody></table></figure>
<p>Performance increases are never about IPC increases alone, because clock speed matters as well. Performance generally scales almost linearly with clock speed increases, provided your caches are doing well enough to keep DRAM bottlenecks away. If you have a choice between increasing some structure sizes by 5%, or being able to clock the core 5% higher, you’re almost guaranteed to get higher overall performance by picking the latter option. AMD’s engineers probably avoided beefing up certain structures, like the schedulers and store queue, in favor of getting the core to clock higher. And Zen 4 did clock higher, by a large margin. The end result is an overall performance improvement that should be in line with what we got from previous Zen generations. Zen 4 carries this clock speed advantage to multithreaded workloads. Every Zen generation delivered strong all-core performance, and Zen 4 is no exception. Intel also pursued a similar strategy with Raptor Lake, which avoided major architectural changes. Instead, maximum clocks were pushed to 5.8 GHz with Thermal Velocity Boost, or 5.7 GHz with regular Turbo Boost 3.0.</p>
<p>Averaging IPC across a large set of workloads also obscures Zen 4’s AVX-512 advantage. Programs that use AVX-512 can get the same amount of work done with fewer instructions, thus achieving lower IPC, but higher performance per clock. I assume when AMD says IPC, they mean performance per clock, not specifically instructions per clock. In specific workloads that can take advantage of AVX-512, I expect Zen 4 to pull a large advantage over Zen 3. If 512-bit vectors are used, Zen 4 will have more effective scheduling capacity even though the size of the scheduler queue stays the same, because each scheduler entry will be tracking 512 bits worth of work. Even if longer vectors aren’t used, AVX-512 offers new instructions that again let the CPU get the same amount of work done with fewer instructions.</p>
<p>Other Zen 4 changes similarly focus on making better use of existing execution capacity. Raw execution throughput per cycle hasn’t really changed from Zen 2 to Zen 4, and cache bandwidth hasn’t increased either. That’s because AMD already had plenty of raw throughput in prior generations, and steady state execution throughput wasn’t a bottleneck in most applications. </p>
<div>
<figure><a href="https://chipsandcheese.com/?attachment_id=11739"><img data-attachment-id="11739" data-permalink="https://chipsandcheese.com/2022/11/08/amds-zen-4-part-2-memory-subsystem-and-conclusion/zen2_encode_fp_pipes/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen2_encode_fp_pipes.png?fit=625%2C339&amp;ssl=1" data-orig-size="625,339" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="zen2_encode_fp_pipes" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen2_encode_fp_pipes.png?fit=625%2C339&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen2_encode_fp_pipes.png?fit=625%2C339&amp;ssl=1" decoding="async" width="625" height="339" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen2_encode_fp_pipes.png?resize=625%2C339&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen2_encode_fp_pipes.png?resize=625%2C339&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a><figcaption>Execution unit capacity isn’t a bottleneck with libx264, even in spikes (very few stalls on FP scheduler filling up), but the ROB and integer registers did fill up and cause stalls from the backend side</figcaption></figure></div>
<p>Zen 4 therefore improves reordering capacity to help absorb bursts of demand for the execution units. Improved branch prediction helps better utilize both reordering capacity and execution unit throughput, by reducing wasted work. Zen 4 also tries to feed the execution units better by switching to DDR5, which provides a large bandwidth boost over DDR4. At the same time, AMD has given each core more memory level parallelism capabilities. The amount of DRAM bandwidth achievable with a single core to increases to over 57 GB/s, indicating very deep buffers to track pending cache misses. These deep buffers help absorb spikes in demand for cache and memory bandwidth. From the other direction, Zen 4’s larger L2 TLB and L2 cache help reduce average latency for instructions that access memory. Intel has pursued a similar strategy in <a href="https://chipsandcheese.com/2022/08/23/a-preview-of-raptor-lakes-improved-l2-caches/">Raptor Lake</a>, where P-core L2 size was increased from 1.25 MB to 2 MB at the cost of just one cycle of latency. </p>
<p>Zen 4 also aims to improve frontend width utilization instead of making everything wider. Zen 3 already had a very fast branch predictor, but Zen 4 takes it further. A bigger L1 BTB with a higher hitrate means the frontend spends fewer cycles idling after a taken branch, increasing frontend width utilization. Like prior Zen generations and many Intel architectures, Zen 4 is narrowest at the renamer, which remains 6-wide. I’m guessing AMD found they could improve performance more by increasing clocks than boosting core width. The renamer is probably a very timing sensitive bit of circuitry. Each instruction coming in could require two or more reads from the register alias tables, and modifications to register mappings have to be reflected immediately, for later instructions coming in within the same 6-wide group.</p>
<div>
<figure><img data-attachment-id="11769" data-permalink="https://chipsandcheese.com/2022/11/08/amds-zen-4-part-2-memory-subsystem-and-conclusion/zen2_av1_retirewidth/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen2_av1_retirewidth.png?fit=1184%2C513&amp;ssl=1" data-orig-size="1184,513" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="zen2_av1_retirewidth" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen2_av1_retirewidth.png?fit=1184%2C513&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen2_av1_retirewidth.png?fit=688%2C298&amp;ssl=1" decoding="async" width="688" height="298" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen2_av1_retirewidth.png?resize=688%2C298&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen2_av1_retirewidth.png?w=1184&amp;ssl=1 1184w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen2_av1_retirewidth.png?resize=768%2C333&amp;ssl=1 768w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen2_av1_retirewidth.png?resize=688%2C298&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/><figcaption>How do you really measure width utilization?</figcaption></figure></div>
<p>With all that in mind, I wonder how much AMD can squeeze out of a certain core width and set of execution resources. Some areas of the Zen 4 core look very light in comparison to competing Intel cores. For example, L1D bandwidth for vector loads and stores is only half of what Intel can achieve with AVX-512. Even when limited to 256-bit accesses with AVX, Golden Cove can still achieve more bandwidth per cycle than Zen 4. Of course, Intel can’t pack 16 Golden Cove cores into a chip and run them all at high clocks. Also, Intel managed to increase IPC by ridiculous amounts between Conroe and Skylake, even though both architectures (and everything in between) were 4-wide. I look forward to seeing what AMD and Intel both bring in future generations.</p>
<p>If you like our articles and journalism and you want to support us in our endeavors then consider heading over to our <a href="https://www.patreon.com/ChipsandCheese">Patreon</a> or our <a href="https://www.paypal.com/donate/?hosted_button_id=4EMPH66SBGVSQ">PayPal</a> if you want to toss a few bucks our way or if you would like to talk with the Chips and Cheese staff and the people behind the scenes then consider joining our <a href="https://discord.gg/TwVnRhxgY2">Discord</a>.</p>
<div>

<ul>
<li>
<p><img alt="clamchowder" src="https://secure.gravatar.com/avatar/83de286347cdfc84e1bb10146350467e?s=80&amp;d=identicon&amp;r=g" height="80" width="80" decoding="async" data-lazy-srcset="https://secure.gravatar.com/avatar/83de286347cdfc84e1bb10146350467e?s=160&amp;d=identicon&amp;r=g 2x" data-lazy-src="https://secure.gravatar.com/avatar/83de286347cdfc84e1bb10146350467e?s=80&amp;is-pending-load=1#038;d=identicon&amp;r=g" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/>
</p>

</li>
</ul>
</div>



</div></div>
  </body>
</html>
