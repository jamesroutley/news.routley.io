<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://iagoleal.com/posts/calculus-symbolic-ode/">Original</a>
    <h1>A lazy way to solve differential equations</h1>
    
    <div id="readability-page-1" class="page">
<header id="top-bar">
    <nav>
        <ul>
            
            
        </ul>
    </nav>
</header>
<p>Back at college I took some classes on solving differential equation.
My favorite were certainly those from the Physics department, because
they taught us all kinds of formulas, methods and series to actually
compute the solutions instead obsessing over regularity and convergence
issues<a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a>. A lot of the techniques, specially
those for equations with analytic coefficients, sometimes felt a bit
mechanical. In fact, it almost always goes like this: Get your equation,
Taylor expand everything, collect terms by indices and then solve the
recurrence relations to find Taylor series for the solution.</p>
<p>Well, some days ago <a href="https://www.joaopaixao.com/">João
Paixão</a> sent me a link to a paper from <span data-cites="calcStreams1998">D. Pavlovic and M. H. Escardó<a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a></span> called “Calculus in
Coinductive Form”. In it the authors show that if we look at Taylor
series as streams of real numbers, then solving these differential
equations become <em>as easy as writing them</em>!</p>
<p>Of course, I got really excited with the idea and had to turn it into
code. After all, that is the epitome of declarative programming! The
paper is really readable, and I urge you to take a look at it. There are
many mathematical details that I will not touch and even a whole
discussion on how these same techniques apply to Laplace transforms. As
an appetizer of what we are going to do, consider the initial value
problem</p>
<p><span>
  y&#39;&#39; = -x^2 y + 2 y&#39; + 4 \\
  y(0) = 0,\; y&#39;(0) = 1.
</span></p>
<p>By the end of this post we gonna be able to solve this differential
equation simply by writing the equivalent Haskell definition:</p>
<pre><code>y = 0 :&gt; 1 :&gt; (-x^2) * y + 2 * diff y + 4</code></pre>
<h2 id="calculus-with-infinite-lists">Calculus with Infinite Lists</h2>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span>{-# LANGUAGE DeriveFunctor, DeriveFoldable, NoMonomorphismRestriction #-}</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span>import</span> <span>Data.Foldable</span> (toList)</span></code></pre></div>
<p>First, a disclaimer: I will not deal with convergence issues in this
post. For us everything will be beautiful and perfect and analytic. Of
course, since ignoring these things makes a chill run down my spine,
let’s just agree that every time I say “smooth” I actually mean
“analytic in a big enough neighbourhood around whatever points we are
considering”. Nice, now it’s calculus time.</p>
<p>Our basic tool is the all too famous Fundamental Theorem of Calculus.
Consider a smooth function <span>f</span>; An
application of the FTC tells us that any smooth <span>f</span> is uniquely determined by its value at a
point <span>a</span> and its derivative:</p>
<p><span> f(a + x) = f(a) + \int_a^x f&#39;(t)
dt.</span></p>
<p>Ignoring all meaning behind the integral, derivative, evaluation etc.
we can view this as a recipe: smooth functions are equivalent to pairs
containing a number and another smooth function. I don’t know about you
but this sounds a lot like a recursive datatype to me!</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>Stream</span> a <span>=</span> a <span>:&gt;</span> <span>Stream</span> a</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> (<span>Functor</span>, <span>Foldable</span>)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span>infixr</span> <span>2</span> <span>:&gt;</span></span></code></pre></div>
<p>The <code>Stream a</code> datatype represents a list with an infinite
amount of elements. To see this all you have to do is unfold the
definition. In our context this means that a smooth function may be
represent by the infinite list of its derivatives at a point:</p>
<pre><code>f = f a :&gt; f&#39;
  = f a :&gt; f&#39; a :&gt; f&#39;&#39;
  = f a :&gt; f&#39; a :&gt; f&#39;&#39; a :&gt; f&#39;&#39;&#39;
  = ...</code></pre>
<p>Since the constructor <code>(:&gt;)</code> is our way to represent
the TFC, the above amounts to saying that we can represent a
(sufficiently regular) function by its Taylor series. That is, by
applying the TFC recursively to the derivatives of <span>f</span>, we get</p>
<p><span> f(a + x) = \sum_{k=0}^\infty f^{(k)}(a)
\frac{x^k}{k!}. </span></p>
<p>As expected, the info that actually depends on <span>f</span> are only its derivatives at <span>a</span>. In math, we represent this as a power
series but, by linear independence, this is completely equivalent to the
stream of its coefficients in the basis <span>\{x^k/k!\}</span>.</p>
<p>With this we’re done. Well… We’re not actually done, there is still a
lot of cool stuff I want to show you. Nevertheless, the definition above
is already enough to replicate the power series method of solving ODEs.
Don’t believe me? Let’s solve some familiar equations then.</p>
<p>The exponential function is the unique solution to <span>y&#39; = y</span>, <span>y(0) =
1</span>, which becomes the following recursion in Haskell:</p>

<p>Let’s check the starting coefficients of <code>ex</code> on ghci to
confirm that they match the derivative of <span>\exp</span> at zero: are exactly the derivatives of
the <span>\exp</span>:</p>
<pre><code>ghci&gt; take 10 (toList ex)
[1,1,1,1,1,1,1,1,1,1]</code></pre>
<p>The way to define sine and cosine as the solutions to a system of
ODEs in Haskell becomes a mutually recursive definition:</p>
<div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>sine   <span>=</span> <span>0</span> <span>:&gt;</span> cosine</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>cosine <span>=</span> <span>1</span> <span>:&gt;</span> <span>fmap</span> <span>negate</span> sine</span></code></pre></div>
<p>As expected, these streams follow the same alternating pattern of
<span>0, 1, 0, -1,\ldots</span> as the Taylor
coefficients.</p>
<pre><code>ghci&gt; take 10 (toList sine)
[0,1,0,-1,0,1,0,-1,0,1]
ghci&gt; take 10 (toList cosine)
[1,0,-1,0,1,0,-1,0,1,0]</code></pre>
<p>Even though we know how to calculate the Taylor coefficients they’re
only means to an end. The main reason one wants to solve differential
equations is to calculate <em>functions</em>, not series. Let’s then
hack a poor man’s function approximation for these Taylor expansions.
For simplicity, I will use a fixed amount of 100 coefficients. This
works for this demonstration but in any real program, it is better to
call upon some analysis to find out the right amount of terms for your
desired error estimate. Let’s then create a higher order function that
converts streams of real numbers into real valued functions.</p>
<div id="cb9"><pre><code><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span>-- | Turn a Stream f into a functional approximation</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span>--   of its Taylor series around a point a.</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span>-- That is, eval a f ≈ f(a + x)</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span>eval ::</span> <span>Fractional</span> a <span>=&gt;</span> a <span>-&gt;</span> <span>Stream</span> a <span>-&gt;</span> a <span>-&gt;</span> a</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>eval a f x <span>=</span> <span>foldr1</span> (\ fa f&#39; <span>-&gt;</span> fa <span>+</span> (x <span>-</span> a) <span>*</span> f&#39;) (<span>take</span> <span>100</span> taylor)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a> <span>where</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>  taylor      <span>=</span> <span>zipWith</span> (<span>/</span>) (toList f) factorials</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>  factorials  <span>=</span> <span>let</span> fats <span>=</span> <span>1</span> <span>:</span> <span>zipWith</span> (<span>*</span>) fats [<span>1</span><span>..</span>]</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>                <span>in</span> <span>fmap</span> <span>fromIntegral</span> fats</span></code></pre></div>
<p>With our evaluator in hand, it’s time to test our previous streams
into some well-known values:</p>
<pre><code>ghci&gt; eval 0 ex 0
1.0
ghci&gt; eval 0 ex 1
2.718281828459045
ghci&gt; fmap (eval 0 sine)   [0, pi/2, pi, 2*pi]
[0.0,1.0,0.0,0.0]
ghci&gt; fmap (eval 0 cosine) [0, pi/2, pi, 2*pi]
[1.0,0.0,-1.0,1.0]</code></pre>
<p>Quite nice, huh? Just a few lines of code and we already have the
power to solve and approximate some classical differential equations!
All thanks to Haskell’s laziness and the TFC. Our solver is done, but
the code still lacks a cleaner interface to manipulate streams and
represent differential equations. Let’s define some functions to
mitigate that.</p>
<p>From the previous discussion, we can get the derivative of a stream
simply by dropping the first term.</p>
<div id="cb11"><pre><code><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span>-- | Taylor series representation of the derivative.</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span>diff ::</span> <span>Stream</span> a <span>-&gt;</span> <span>Stream</span> a</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>diff (_ <span>:&gt;</span> f&#39;) <span>=</span> f&#39;</span></code></pre></div>
<p>It is possible to embed any constant as a stream with derivative
zero. Also, let’s define a stream <code>x</code> representing the
identity function<a href="#fn3" id="fnref3" role="doc-noteref"><sup>3</sup></a> in order to make our equations look
a bit nicer.</p>
<div id="cb12"><pre><code><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span>-- | Taylor series for the constant zero.</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span>zero ::</span> <span>Num</span> a <span>=&gt;</span> <span>Stream</span> a</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>zero <span>=</span> <span>0</span> <span>:&gt;</span> zero</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span>-- | Taylor series for the identity function `f x = x`.</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span>x ::</span> <span>Num</span> a <span>=&gt;</span> <span>Stream</span> a</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>x <span>=</span> <span>0</span> <span>:&gt;</span> <span>1</span> <span>:&gt;</span> zero</span></code></pre></div>
<p>Finally, our fellow mathematicians and physicists that perhaps may
use this code will certainly want to do arithmetical manipulations on
the series. We can achieve that with the traditional <code>Num</code>,
<code>Fractional</code> and <code>Floating</code> instances. As usual
with these Calculus posts, these instances correspond to the well-known
formulas for derivatives. Let’s start with the arithmetic classes.</p>
<div id="cb13"><pre><code><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span>instance</span> <span>Num</span> a <span>=&gt;</span> <span>Num</span> (<span>Stream</span> a) <span>where</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a> <span>-- Good ol&#39; linearity</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a> (<span>+</span>)  (fa <span>:&gt;</span> f&#39;)  (ga <span>:&gt;</span> g&#39;) <span>=</span> fa <span>+</span> ga <span>:&gt;</span> f&#39; <span>+</span> g&#39;</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a> (<span>-</span>)  (fa <span>:&gt;</span> f&#39;)  (ga <span>:&gt;</span> g&#39;) <span>=</span> fa <span>-</span> ga <span>:&gt;</span> f&#39; <span>-</span> g&#39;</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a> <span>negate</span> <span>=</span> <span>fmap</span> <span>negate</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a> <span>-- Leibniz rule applied to streams</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a> (<span>*</span>) f<span>@</span>(fa <span>:&gt;</span> f&#39;) g<span>@</span>(ga <span>:&gt;</span> g&#39;) <span>=</span> fa <span>*</span> ga <span>:&gt;</span> f&#39; <span>*</span> g <span>+</span> f <span>*</span> g&#39;</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a> <span>fromInteger</span> n <span>=</span> <span>fromInteger</span> n <span>:&gt;</span> zero</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a> <span>abs</span>    <span>=</span> <span>error</span> <span>&#34;Absolute value is not a smooth function&#34;</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a> <span>signum</span> <span>=</span> <span>error</span> <span>&#34;No well-defined sign for a series&#34;</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a><span>instance</span> <span>Fractional</span> a <span>=&gt;</span> <span>Fractional</span> (<span>Stream</span> a) <span>where</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a> <span>-- The division rule from Calculus. We assume g(0) ≠ 0</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a> (<span>/</span>) f<span>@</span>(fa <span>:&gt;</span> f&#39;) g<span>@</span>(ga <span>:&gt;</span> g&#39;) <span>=</span> fa <span>/</span> ga <span>:&gt;</span> (f&#39; <span>*</span> g <span>-</span> f <span>*</span> g&#39;) <span>/</span> g<span>^</span><span>2</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a> <span>fromRational</span> n <span>=</span> <span>fromRational</span> n <span>:&gt;</span> zero</span></code></pre></div>
<p>For the <code>Floating</code> instance, we will use the chain rule
and the fact that we know the derivatives for all methods in the class.
I recommend taking a look at the implementation we did in a <a href="https://iagoleal.com/posts/calculus-symbolic-ad">previous post for Dual numbers</a>.
They are strikingly similar, which is no coincidence of course. The main
idea is that applying an analytic <span>g</span> to
the stream of <span>f</span> if the same as
calculating the derivates for <span>g \circ
f</span>. Thus, all our <code>Floating</code> methods will look like
this:</p>
<pre><code>g f = g (f a) :&gt; g&#39; f * f&#39;</code></pre>
<p>This is Haskell, so we can turn this idea into a higher order
function taking both <code>g</code> and its derivative:</p>
<div id="cb15"><pre><code><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>analytic g g&#39; f<span>@</span>(fa <span>:&gt;</span> f&#39;) <span>=</span> g fa <span>:&gt;</span> g&#39; f <span>*</span> f&#39;</span></code></pre></div>
<div id="cb16"><pre><code><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span>instance</span> <span>Floating</span> a <span>=&gt;</span> <span>Floating</span> (<span>Stream</span> a) <span>where</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a> <span>pi</span> <span>=</span> <span>pi</span> <span>:&gt;</span> zero</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a> <span>exp</span>   <span>=</span> analytic <span>exp</span>   <span>exp</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a> <span>log</span>   <span>=</span> analytic <span>log</span>   <span>recip</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a> <span>sin</span>   <span>=</span> analytic <span>sin</span>   <span>cos</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a> <span>cos</span>   <span>=</span> analytic <span>cos</span>   (<span>negate</span> <span>.</span> <span>sin</span>)</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a> <span>asin</span>  <span>=</span> analytic <span>asin</span>  (\x <span>-&gt;</span> <span>1</span> <span>/</span> <span>sqrt</span> (<span>1</span> <span>-</span> x<span>^</span><span>2</span>))</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a> <span>acos</span>  <span>=</span> analytic <span>acos</span>  (\x <span>-&gt;</span> <span>-</span><span>1</span> <span>/</span> <span>sqrt</span> (<span>1</span> <span>-</span> x<span>^</span><span>2</span>))</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a> <span>atan</span>  <span>=</span> analytic <span>atan</span>  (\x <span>-&gt;</span> <span>1</span> <span>/</span> (<span>1</span> <span>+</span> x<span>^</span><span>2</span>))</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a> <span>sinh</span>  <span>=</span> analytic <span>sinh</span>  <span>cosh</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a> <span>cosh</span>  <span>=</span> analytic <span>cosh</span>  <span>sinh</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a> <span>asinh</span> <span>=</span> analytic <span>asinh</span> (\x <span>-&gt;</span> <span>1</span> <span>/</span> <span>sqrt</span> (x<span>^</span><span>2</span> <span>+</span> <span>1</span>))</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a> <span>acosh</span> <span>=</span> analytic <span>acosh</span> (\x <span>-&gt;</span> <span>1</span> <span>/</span> <span>sqrt</span> (x<span>^</span><span>2</span> <span>-</span> <span>1</span>))</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a> <span>atanh</span> <span>=</span> analytic <span>atanh</span> (\x <span>-&gt;</span> <span>1</span> <span>/</span> (<span>1</span> <span>-</span> x<span>^</span><span>2</span>))</span></code></pre></div>
<p>With all those instances, we can give power series the same
first-class numeric treatment that they receive in mathematics. For
example, do you want to approximate some complicated integral? Just use
the Stream <code>x</code> that we previously defined:</p>
<pre><code>ghci&gt; erf = 0 :&gt; exp (-x^2)
ghci&gt; take 10 (toList erf)
[0.0,1.0,-0.0,-2.0,0.0,12.0,0.0,-120.0,0.0,1680.0]</code></pre>
<p>Also, we’ve only dealt with linear equations until now but as long as
everything is analytic, these methods readily extend to non-linear
equations.</p>
<pre><code>ghci&gt; y = 0 :&gt; 1 :&gt; x^2 * cos (diff y) - x * sin y
ghci&gt; take 10 (toList y)
[0.0,1.0,0.0,0.0,-0.9193953882637205,0.0,4.0,20.069867797120825,-6.0,-265.9036412154172]</code></pre>
<p>Finally, we should discuss a couple caveats of this method. Solving
an ODE through a Taylor series can be slow… That is why, in practice,
this would only be used for the most well-behaved equations. There is
also the issue of convergence that we decided to ignore during this
post. Not all <code>Floating a =&gt; a -&gt; a</code> functions are
analytic everywhere and when this hypothesis doesn’t hold, the method
will just silently fail and return garbage such as <code>infinity</code>
or <code>NaN</code> for the coefficients. Nevertheless, this “automatic”
solution is pretty much equivalent to what one would do to solve this
kind of equation by hand, including these same issues. In fact, I would
even risk saying that the Haskell internals are much more optimized than
one could hope to be when solving by hand.</p>
<h2 id="this-is-indeed-an-automatic-method">This is indeed an automatic
method</h2>
<p>To sum everything up, I want to note a cool fact that I’ve only
realized after writing the entire post: there is a direct relationship
between this method of solving ODEs and forward-mode automatic
differentiation!</p>
<p>When working with <a href="https://iagoleal.com/posts/calculus-symbolic-ad">dual
numbers</a>, we define its numeric instances to obey <span>\varepsilon^2 = 0</span>, implying that for any
analytic function it satisfies</p>
<p><span> f(a + \varepsilon) = f(a) +
f&#39;(a)\varepsilon. </span></p>
<p>This is equivalent to Taylor expanding <span>f</span> around <span>a</span>
and truncating the series after the first order terms. However, nothing
really forces us to stop there! Since the derivative of an analytic
function is also analytic, we can again Taylor expand it to get the
second derivative and so on. By recursively repeating this procedure we
get the entire Taylor expansion. So, if instead of using a term <span>\varepsilon</span> that vanishes at second order, we
apply <span>f</span> to <span>a
+ x</span>, we get all derivatives of <span>f</span>
at <span>a</span>.</p>
<p>This is the same we have been doing all along with Streams; the only
difference being that we write <code>a :&gt; 1</code> to represent <span>a + x</span>. So, similarly with dual numbers, we
can define a procedure to calculate <em>all derivatives</em> of a
polymorphic <span>f</span> at the point <span>a</span> by applying <span>f</span> to a suitable Stream.</p>
<div id="cb19"><pre><code><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span>-- | A Stream with all derivatives of f at a.</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>diffs f a <span>=</span> f (a <span>:&gt;</span> <span>1</span>)</span></code></pre></div>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>This post gained life thanks to the enthusiasm of João Paixão and
Lucas Rufino. João sent me the paper and we three had some fun chats
about its significance, including becoming perplexed together about how
little code we actually needed to implement this.</p>
<h2 id="refs">References</h2>
<p>The <a href="https://hackage.haskell.org/package/ad-4.5.2/docs/Numeric-AD-Mode-Tower.html">Numeric.AD.Mode.Tower</a>
module of the <a href="https://hackage.haskell.org/package/ad">ad
package</a>.</p>
<div id="refs" role="doc-bibliography">
<p>
Pavlovic, D., and M. H. Escardó. <span>“Calculus in Coinductive
Form.”</span> In <em>Proceedings of the 13th Annual IEEE Symposium on
Logic in Computer Science</em>, 408. LICS ’98. USA: IEEE Computer
Society, 1998.
</p>
<p>
Rutten, Jan J. M. M. <span>“A Coinductive Calculus of Streams.”</span>
<em>Mathematical Structures in Computer Science</em> 15 (2005): 93–147.
</p>
</div>




</div>
  </body>
</html>
