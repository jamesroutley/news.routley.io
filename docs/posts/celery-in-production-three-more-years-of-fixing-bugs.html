<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ayushshanker.com/celery-long-post/">Original</a>
    <h1>Celery in production: Three more years of fixing bugs</h1>
    
    <div id="readability-page-1" class="page"><div>
            
<div>
    <main>
            <article>
    
    <div>
            <p>This post covers the various issues we faced with celery in production over the last year or so. An ex-team member had iterated on a bunch of celery issues around 3 years before this iteration and had blogged about his experience here: <a href="https://medium.com/squad-engineering/two-years-with-celery-in-production-bug-fix-edition-22238669601d">https://medium.com/squad-engineering/two-years-with-celery-in-production-bug-fix-edition-22238669601d</a></p><p>While that iteration fixed a lot of problems at that time, some problems had only gone hidden &amp; then reappeared a few months later. So it was given that a more definitive iteration would be required to fix the problems this time around.</p><h2 id="our-instances-would-always-be-on-high-ram-usage-and-manually-scaling-them-to-2x-or-4x-the-size-would-not-fix-the-problem">Our instances would always be on high RAM usage, and manually scaling them to 2x or 4x the size would not fix the problem</h2><p>This is so counter-intuitive, right? If I have an instance with 90% memory usage, doubling its resources should result in approx 45% memory usage. But the expected didn‚Äôt happen. We use AWS instances for celery workloads, so the team would scale up the instance in hopes of containing the memory requirement. The instance would still show 90-100% RAM usage so someone tried to change the instance type from c5 to t3 (c5 is for CPU bound tasks, and t3 is burstable CPU instance type for non-CPU bound workloads). This didn‚Äôt work either.</p><p><strong>The Solution: </strong>Whenever your celery processes (or any other, for that matter) takes a lot of RAM, your first response should be to gather a list of processes with resident &amp; shared memory usage. Without this data, you‚Äôre very likely to be shooting an arrow in the dark. So anyway I went ahead on the culprit server, which had 16 gigs of memory. A quick view of htop &amp; then sorted by memory usage showed that the process with max memory usage was using ~320MBs of memory. I already knew that our application takes ~280MBs when I run python manage.py shell, so it‚Äôs not a case of a few rogue celery processes taking too much RAM. Next, I ran </p><pre><code>$ ps aux | grep &#39;celery worker&#39; | wc -l
  52</code></pre><p>If you do the math, 280MB * 52 ~= 14.5GB. So once all the celery workers are launched, the instance is already around 90% full. But why does this not get fixed when I double the instance size? That‚Äôs because if you don‚Äôt specify <code>--concurrency</code> for each worker explicitly, it defaults to using the number of cores available as the default value for concurrency. This option controls how many children will be forked for each worker defined. So when you double the instance, you usually also double the CPUs in the instance, thus increasing the number of celery processes in the process. A similar thing happens when you switch from c5 to t3 instance, you get more (but much weaker) CPU cores.</p><p>The final solution was to explicitly specify the concurrency in the worker launch command: </p><pre><code>$ celery worker -A project (...) --concurrency=4</code></pre><h2 id="some-workers-were-using-4-5x-times-the-ram-taken-by-a-freshly-launched-child-worker-process">Some workers were using 4-5x times the RAM taken by a freshly launched child worker process</h2><p>Just by reading the description of the problem, you can tell that there‚Äôs a strong hint of memory leak here. I had seen in htop that the culprit workers were all at least a few hours old. This problem was new, not something we faced in last iteration. So why did this happen now? Well in the previous iteration (See ‚Äú<strong>Worker servers always had an unexplainably high CPU usage‚Äù </strong>section), we had removed the <strong>--max-memory-per-child</strong> flag from options, which now meant that the processes were not dying after regular intervals. So we made a mistake; while that setting was not working for us at that time, we should have changed it to a higher value than outright removing it.</p><p>So while this was easily fixable by re-introducing the <code>--max-memory-per-child</code> flag, at that time I had a script lying around that‚Äôd kill a process matching certain properties, like if it goes beyond a threshold in memory usage. The kill mechanism itself is first it tries to soft-kill (letting the running task complete), and then initiates hard kill if the process is still running after a timeout. This method is still inferior to using <code>--max-memory-per-child</code>, but probably better for us right now.</p><h2 id="instances-would-frequently-use-more-ram-than-they-should-be-using">Instances would frequently use more RAM than they should be using</h2><p>This is the same problem as section ‚Äú<strong>Worker servers always had an unexplainably high RAM usage</strong>‚Äù in <a href="https://medium.com/squad-engineering/two-years-with-celery-in-production-bug-fix-edition-22238669601d">https://medium.com/squad-engineering/two-years-with-celery-in-production-bug-fix-edition-22238669601d</a></p><p>We thought it had been fixed until it re-appeared weeks later üò£.</p><p>So this time we already knew what the problem was: child worker orphans that don‚Äôt die out once their master worker has been killed in the deployment process. Now we know that all orphans get ‚Äúadopted‚Äù by PID 1 once their parent die. So all I had to do was to write a small script that‚Äôd kill any celery worker process that had PID 1 as its immediate parent. We run our celery workers as multiple workers in each instance, all under supervisord which in turn is controlled by systemd.</p><p>Now, this is not the best way to solve this. Ideally, the service manager (supervisord) should be aware of all the forked children &amp; kill them when the parent is dead. A quick ¬†search tells that Systemd already does that, and is also available on the instance to be used. But we now generate the celery worker definitions from a YAML file into supervisord configs, and replacing supervisord with systemd would mean that I‚Äôll also have to change that YAML to config generator accordingly. That would‚Äôve taken more time than what I had then, so I decided to leave it this way. And it has been working fine till now with no issues so I won‚Äôt complain much either.</p><h2 id="a-few-celery-workers-would-hang-after-a-few-hours-of-usage-and-would-just-stop-consuming-any-more-tasks">A few celery workers would hang after a few hours of usage, and would just stop consuming any more tasks</h2><p>Let‚Äôs get you a little bit of background on our crons setup: Around the same time as the old blogpost, we switched from basic crond on a single large instance to celery beat with workers across multiple machines. We had migrated to <a href="https://healthchecks.io/">healthchecks.io</a> for alerting in case a scheduled cron misses its run.</p><!--kg-card-begin: html--><!--kg-card-end: html--><p>This looks familiar üßê</p><p>(see section ‚Äú<strong>Workers stayed idle, not consuming any tasks‚Äù</strong> in <a href="https://medium.com/squad-engineering/two-years-with-celery-in-production-bug-fix-edition-22238669601d" rel="noreferrer nofollow noopener">https://medium.com/squad-engineering/two-years-with-celery-in-production-bug-fix-edition-22238669601d</a>)</p><!--kg-card-begin: markdown--><ol>
<li>install python debug build of python: <code>sudo apt install python-dbg</code></li>
<li>install gdb: <code>sudo apt install gdb</code></li>
<li>take a core dump of the process: <code>sudo gcore $PID</code></li>
<li>launch the gdb attached to core dump: <code>gdb python core.$PID</code></li>
<li>inside the gdb, use <code>py-bt</code> to get python level backtrace &amp; <code>bt</code> for C level backtrace</li>
</ol>
<!--kg-card-end: markdown--><p>After I collected backtraces from all the idle workers, I found that all of them had a similar backtrace, of top few lines are</p><!--kg-card-begin: html--><!--kg-card-end: html--><p>and the corresponding C backtrace is</p><!--kg-card-begin: html-->
<!--kg-card-end: html--><p>It looks like urllib3 is waiting to acquire GIL before it could decompress the HTTP body chunk, possibly stuck in a deadlock. Not much I can do here, this looks like a ¬†bug - which won‚Äôt be fixed now that Python 2 has reached EOL. We eventually created a workaround for this that works this way:</p><ol><li>once every few seconds, when a celery worker picks a new task, it sends a heartbeat to a local redis instance</li><li>A cron checks redis &amp; kills whichever worker hasn&#39;t sent a heartbeat in last few minutes, and sends a SIGTERM followed by a SIGKILL.</li></ol><p>There&#39;s a bit more detail to this workaround, but that&#39;s a story for another time.</p><p>Also: it&#39;s easier to just use <a href="https://github.com/benfred/py-spy">py-spy</a> for this. </p><h2 id="io-vs-cpu-bound-tasks">IO vs CPU bound tasks</h2><p>We had some instances which were having high CPU usage, while there were others with very low CPU usage. This is not a problem in itself, but I wanted to have a better visibility of CPU bound vs IO bound load in each queue to be able to allocate infra accordingly. </p><ol><li><code><a href="https://docs.celeryproject.org/en/stable/userguide/signals.html#task-prerun" rel="noreferrer nofollow noopener">task_prerun</a> </code></li><li><code><a href="https://docs.celeryproject.org/en/stable/userguide/signals.html#task-postrun" rel="noreferrer nofollow noopener">task_postrun</a></code></li></ol><p>If I log the current clock time and CPU time at each of these signals, I can get the time taken by each task. I can then use the CPU time difference divided by clock time difference to get an approximate idea of CPU vs IO bound workload for each task. Let‚Äôs create the listeners:</p><!--kg-card-begin: html--><!--kg-card-end: html--><p>After the logs are collected, I‚Äôd run a script that would parse the above lines into something like:</p><!--kg-card-begin: html--><!--kg-card-end: html--><p>A plot of <code>cpu_time_difference</code> divided by <code>clock_time_difference</code> makes it clear which tasks are IO bound &amp; which are CPU bound. The IO bound tasks would peak around lower X-axis values. Here‚Äôs the plot from our system (I have defaced the actual task names with hex codes), where you can see that the IO bound tasks peak towards the left. (The Y axis is indicative of number of tasks).</p><figure><img src="https://ayushshanker.com/content/images/2021/06/4kh4r5Q5.png" alt="" srcset="https://ayushshanker.com/content/images/size/w600/2021/06/4kh4r5Q5.png 600w, https://ayushshanker.com/content/images/2021/06/4kh4r5Q5.png 941w" sizes="(min-width: 720px) 720px"/></figure><h2 id="use-gevent-as-worker-pool">Use Gevent as worker pool</h2><p>This is not a problem, but rather an optimization that I wanted to try out. We started using gevent as the pool option instead of the default prefork ¬†in some of our IO bound workers. This didn‚Äôt go well for because some libraries as well as application code were not thread-safe, causing some deadlocks &amp; other annoyances. So this was reverted within minutes in all but 1 worker whose only tasks were shooting webhooks, and that too was reverted days later because it was too unsafe to let it be on production. </p><ul><li>Celery has been one of the more unstable pieces in our infra over the years.</li><li>Supervisor should&#39;ve killed celery&#39;s forked workers once the parent dies. Either it is not reliable or we haven&#39;t been able to make this happen in at least a few attempts now. I&#39;m inclined to believe the former is true, but neither outcomes will look good for supervisord.</li><li>Verify if the bug is truly solved, or just dormant. Sometimes it may mean not closing the bug tracker issue before your changes have been running for few weeks in production.</li><li>Don&#39;t debug just by google/github searches. Brendan Gregg has written some great tips around performance debugging, some of which are relevant when debugging errors as well: <a href="http://www.brendangregg.com/methodology.html">http://www.brendangregg.com/methodology.html</a></li><li>There are too many thread-unsafe libraries in python ecosystem. It&#39;s also very easy to create your own thread unsafe code. As a result, gevent (or eventlet) will remain a pipedream except in very limited scenarios.</li></ul>
    </div>
        
</article>                            </main>
</div>
        </div></div>
  </body>
</html>
