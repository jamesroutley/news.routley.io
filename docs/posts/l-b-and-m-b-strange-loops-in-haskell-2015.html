<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/quchen/articles/blob/master/loeb-moeb.md">Original</a>
    <h1>Löb and möb: strange loops in Haskell (2015)</h1>
    
    <div id="readability-page-1" class="page"><div>

    <div data-target="readme-toc.content">
      
  


        <div id="readme">
    <article itemprop="text">
<p dir="auto">Every once in a while, people recognize <a href="https://en.wikipedia.org/wiki/Strange_loop" rel="nofollow">strange loops</a> in
unexpected places. This is one of them, in the form of a Haskell function.</p>
<h2 dir="auto"><a id="user-content-loeb" aria-hidden="true" href="#loeb"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>loeb</code></h2>
<p dir="auto"><code>loeb</code> is one of those functions in Haskell that are amazing, crazy, simple and
complicated in equal parts.</p>
<ol dir="auto">
<li>The implementation is very simple to write.</li>
<li>The implementation is hard to understand.</li>
<li>It is easy to use.</li>
<li>It is explainable.</li>
</ol>
<h3 dir="auto"><a id="user-content-implementation" aria-hidden="true" href="#implementation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Implementation</h3>
<p dir="auto">Feeling smart? Let&#39;s change that, here&#39;s <code>loeb</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="loeb :: Functor f =&gt; f (f a -&gt; a) -&gt; f a
loeb x = go where go = fmap ($ go) x"><pre><span>loeb</span> <span>::</span> <span><span>Functor</span></span> <span>f</span> <span>=&gt;</span> <span>f</span> (<span>f</span> <span>a</span> <span>-&gt;</span> <span>a</span>) <span>-&gt;</span> <span>f</span> <span>a</span>
loeb x <span>=</span> go <span>where</span> go <span>=</span> <span>fmap</span> (<span>$</span> go) x</pre></div>
<p dir="auto">That settles the first two points from above (the first one being accomplished
using trial-and-error typechecker abuse).</p>
<h3 dir="auto"><a id="user-content-what-loeb-does" aria-hidden="true" href="#what-loeb-does"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>What <code>loeb</code> does</h3>
<p dir="auto">Short version: <code>loeb</code> calculates a result in terms of itself, but with more
crazy than what you felt when you first heard about recursion.</p>
<p dir="auto">Long version: what is this thing useful for? It can be used to implement
spreadsheet-like behaviour if the functor is <code>[]</code>:</p>
<p dir="auto">Take a list of functions mapping lists to values, <code>fs :: [[a] -&gt; a]</code>. These
functions can each be applied to some other list <code>xs :: [a]</code>. For each function
<code>f</code> in <code>fs</code>, applying it to <code>xs</code> results in a value <code>r</code>; call this collection
of values <code>rs</code>. This in code form reads</p>
<div dir="auto" data-snippet-clipboard-copy-content="xs :: [a]
xs = [...]

fs :: [[a] -&gt; a]
fs = [...]

rs :: [a]
rs = [ f xs | f &lt;- fs ]  -- r = f xs"><pre><span>xs</span> <span>::</span> [<span>a</span>]
xs <span>=</span> [<span>...</span>]

<span>fs</span> <span>::</span> [[<span>a</span>] <span>-&gt;</span> <span>a</span>]
fs <span>=</span> [<span>...</span>]

<span>rs</span> <span>::</span> [<span>a</span>]
rs <span>=</span> [ f xs <span>|</span> f <span>&lt;-</span> fs ]  <span><span>--</span> r = f xs</span></pre></div>
<p dir="auto">This computes <code>rs</code> out of the given lists <code>xs</code> and <code>fs</code>.</p>
<p dir="auto">Now the crux: it is possible to not take <code>xs</code> as given, using <code>rs</code> instead. In
other words, the <code>f</code> are applied to the list of results they produce.</p>
<div dir="auto" data-snippet-clipboard-copy-content="fs :: [[a] -&gt; a]
fs = [...]

rs :: [a]
rs = [ f rs | f &lt;- fs ]"><pre><span>fs</span> <span>::</span> [[<span>a</span>] <span>-&gt;</span> <span>a</span>]
fs <span>=</span> [<span>...</span>]

<span>rs</span> <span>::</span> [<span>a</span>]
rs <span>=</span> [ f rs <span>|</span> f <span>&lt;-</span> fs ]</pre></div>
<p dir="auto">This of course relies heavily on laziness, as it computes <code>rs</code> in terms of
itself. Instead of having <code>fs</code> as its own definition, let&#39;s supply it as a
parameter to <code>rs</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="rs fs = [ f (rs fs) | f &lt;- fs ]"><pre>rs fs <span>=</span> [ f (rs fs) <span>|</span> f <span>&lt;-</span> fs ]</pre></div>
<p dir="auto">and as it turns out, <code>rs = loeb</code>. Therefore, <code>loeb</code> takes a list of functions,
and calculates the list of results they produce when applied to the list of
results they produce. Strange? Check! Loop? You bet!</p>
<p dir="auto">An example should make using it clearer:</p>
<div dir="auto" data-snippet-clipboard-copy-content="fs = [ const 1
     , succ . (!! 0)
     , succ . (!! 1)
     , succ . (!! 2)
     ]"><pre>fs <span>=</span> [ <span>const</span> <span>1</span>
     , <span>succ</span> <span>.</span> (<span>!!</span> <span>0</span>)
     , <span>succ</span> <span>.</span> (<span>!!</span> <span>1</span>)
     , <span>succ</span> <span>.</span> (<span>!!</span> <span>2</span>)
     ]</pre></div>
<p dir="auto">This describes a list where the list elements are defined in terms of the
previous result value. <code>const 1</code> is the first element of the function list, and
applied to the resulting list it is always <code>1</code>; therefore the resulting list&#39;s
first element is <code>1</code>. <code>succ . (!! 0)</code> applied to the resulting list can now be
calculated: the indexing results in the previously calculated <code>1</code>, and <code>succ</code>
makes it a <code>2</code>. The second result element will therefore be <code>2</code>. This pattern
repeats itself, resulting in</p>

<p dir="auto">The interesting part is that the order of the functions is not necessarily
left-to-right. The list elements can be swapped around, as long as the
circularity is still resolved (otherwise the function won&#39;t terminate):</p>
<div dir="auto" data-snippet-clipboard-copy-content="fs = [ succ . (!! 1)
     , succ . (!! 3)
     , succ . (!! 0)
     , const 1
     ]

loeb fs ==&gt; [3,2,4,1]"><pre>fs <span>=</span> [ <span>succ</span> <span>.</span> (<span>!!</span> <span>1</span>)
     , <span>succ</span> <span>.</span> (<span>!!</span> <span>3</span>)
     , <span>succ</span> <span>.</span> (<span>!!</span> <span>0</span>)
     , <span>const</span> <span>1</span>
     ]

loeb fs <span>==&gt;</span> [<span>3</span>,<span>2</span>,<span>4</span>,<span>1</span>]</pre></div>
<p dir="auto">So this is like a spreadsheet, right? One cell&#39;s value is known, and the other
cells refer to each other in some way. When the evaluation terminates, each
cell has a defined value. In a sense this is like a generalization of a fixed
point combinator.</p>
<h3 dir="auto"><a id="user-content-spreadsheets" aria-hidden="true" href="#spreadsheets"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Spreadsheets!</h3>
<p dir="auto">The lists mentioned above are a little like spreadsheets with only one line.
But there are other functors closer to the real thing, arrays for example!</p>
<div dir="auto" data-snippet-clipboard-copy-content="import Data.Array
import Data.List
import Control.Monad
import Text.Printf

loeb :: Functor f =&gt; f (f a -&gt; a) -&gt; f a
loeb x = go where go = fmap ($ go) x

-- Empty cell
e = val 0

-- Simple cell value
val = const

-- VAT of a cell&#39;s contents (10 %)
vat ix = (* 0.1) . (! ix)

-- Sum of the values at a list of indices
sum&#39; ixs = \arr -&gt; foldl&#39; (\acc ix -&gt; acc + arr ! ix) 0 ixs

spreadsheet = listArray ((0,0), (4,4))
--      Prices | VAT        | Effective prices + total
      [ val 1,   vat (0,0),   sum&#39; [(0,i) | i &lt;- [0..1]],   e,   e
      , val 3,   vat (1,0),   sum&#39; [(1,i) | i &lt;- [0..1]],   e,   e
      , val 5,   vat (2,0),   sum&#39; [(2,i) | i &lt;- [0..1]],   e,   e
      , val 2,   vat (3,0),   sum&#39; [(3,i) | i &lt;- [0..1]],   e,   e
      ,     e,           e,   sum&#39; [(i,2) | i &lt;- [0..3]],   e,   e
      ]

printArr :: Array (Int, Int) Double -&gt; IO ()
printArr arr =
      forM_ [0..4] $ \i -&gt; do
            forM_ [0..4] $ \j -&gt;
                  printf &#34;%4.1f   &#34; (arr ! (i,j))
            printf &#34;\n&#34;

main = printArr $ loeb spreadsheet"><pre><span>import</span> <span>Data.Array</span>
<span>import</span> <span>Data.List</span>
<span>import</span> <span>Control.Monad</span>
<span>import</span> <span>Text.Printf</span>

<span>loeb</span> <span>::</span> <span><span>Functor</span></span> <span>f</span> <span>=&gt;</span> <span>f</span> (<span>f</span> <span>a</span> <span>-&gt;</span> <span>a</span>) <span>-&gt;</span> <span>f</span> <span>a</span>
loeb x <span>=</span> go <span>where</span> go <span>=</span> <span>fmap</span> (<span>$</span> go) x

<span><span>--</span> Empty cell</span>
e <span>=</span> val <span>0</span>

<span><span>--</span> Simple cell value</span>
val <span>=</span> <span>const</span>

<span><span>--</span> VAT of a cell&#39;s contents (10 %)</span>
vat ix <span>=</span> (<span>*</span> <span>0.1</span>) <span>.</span> (<span>!</span> ix)

<span><span>--</span> Sum of the values at a list of indices</span>
sum&#39; ixs <span>=</span> <span>\</span>arr <span>-&gt;</span> foldl&#39; (<span>\</span>acc ix <span>-&gt;</span> acc <span>+</span> arr <span>!</span> ix) <span>0</span> ixs

spreadsheet <span>=</span> listArray ((<span>0</span>,<span>0</span>), (<span>4</span>,<span>4</span>))
<span><span>--</span>      Prices | VAT        | Effective prices + total</span>
      [ val <span>1</span>,   vat (<span>0</span>,<span>0</span>),   sum&#39; [(<span>0</span>,i) <span>|</span> i <span>&lt;-</span> [<span>0</span><span>..</span><span>1</span>]],   e,   e
      , val <span>3</span>,   vat (<span>1</span>,<span>0</span>),   sum&#39; [(<span>1</span>,i) <span>|</span> i <span>&lt;-</span> [<span>0</span><span>..</span><span>1</span>]],   e,   e
      , val <span>5</span>,   vat (<span>2</span>,<span>0</span>),   sum&#39; [(<span>2</span>,i) <span>|</span> i <span>&lt;-</span> [<span>0</span><span>..</span><span>1</span>]],   e,   e
      , val <span>2</span>,   vat (<span>3</span>,<span>0</span>),   sum&#39; [(<span>3</span>,i) <span>|</span> i <span>&lt;-</span> [<span>0</span><span>..</span><span>1</span>]],   e,   e
      ,     e,           e,   sum&#39; [(i,<span>2</span>) <span>|</span> i <span>&lt;-</span> [<span>0</span><span>..</span><span>3</span>]],   e,   e
      ]

<span>printArr</span> <span>::</span> <span>Array</span> (<span><span>Int</span></span>, <span><span>Int</span></span>) <span><span>Double</span></span> <span>-&gt;</span> <span><span>IO</span></span> <span>()</span>
printArr arr <span>=</span>
      forM_ [<span>0</span><span>..</span><span>4</span>] <span>$</span> <span>\</span>i <span>-&gt;</span> <span>do</span>
            forM_ [<span>0</span><span>..</span><span>4</span>] <span>$</span> <span>\</span>j <span>-&gt;</span>
                  printf <span><span>&#34;</span>%4.1f   <span>&#34;</span></span> (arr <span>!</span> (i,j))
            printf <span><span>&#34;</span><span>\n</span><span>&#34;</span></span>

main <span>=</span> printArr <span>$</span> loeb spreadsheet</pre></div>
<p dir="auto">Run it! The output will be</p>
<div data-snippet-clipboard-copy-content=" 1.0    0.1    1.1    0.0    0.0
 3.0    0.3    3.3    0.0    0.0
 5.0    0.5    5.5    0.0    0.0
 2.0    0.2    2.2    0.0    0.0
 0.0    0.0   12.1    0.0    0.0"><pre><code> 1.0    0.1    1.1    0.0    0.0
 3.0    0.3    3.3    0.0    0.0
 5.0    0.5    5.5    0.0    0.0
 2.0    0.2    2.2    0.0    0.0
 0.0    0.0   12.1    0.0    0.0
</code></pre></div>
<p dir="auto">where in the first column you&#39;ll see the prices (declared using <code>val</code> above),
the second column is the added tax to the price on its left, the third lists
the effective price, and below the effective prices there&#39;s the total sum you
have to pay in order to buy everything. Magic! :-)</p>
<h2 dir="auto"><a id="user-content-moeb" aria-hidden="true" href="#moeb"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>moeb</code></h2>
<p dir="auto"><code>moeb</code> is the result of playing around with <code>loeb</code>&#39;s definition: what if we
abstract over the <code>fmap</code> too? First and foremost, it makes the type signature
go crazy:</p>
<div dir="auto" data-snippet-clipboard-copy-content="-- [m]oeb = multi-loeb :-)
moeb :: (((a -&gt; b) -&gt; b) -&gt; c -&gt; a) -&gt; c -&gt; a
moeb f x = go where go = f ($ go) x"><pre><span><span>--</span> [m]oeb = multi-loeb :-)</span>
<span>moeb</span> <span>::</span> (((<span>a</span> <span>-&gt;</span> <span>b</span>) <span>-&gt;</span> <span>b</span>) <span>-&gt;</span> <span>c</span> <span>-&gt;</span> <span>a</span>) <span>-&gt;</span> <span>c</span> <span>-&gt;</span> <span>a</span>
moeb f x <span>=</span> go <span>where</span> go <span>=</span> f (<span>$</span> go) x</pre></div>
<p dir="auto"><code>loeb</code> can now be recovered as <code>moeb fmap</code>. But are there other parameters that
are useful for <code>f</code>? Well,</p>
<div dir="auto" data-snippet-clipboard-copy-content="moeb id x = id ($ moeb id x) x
          = ($ moeb id x) x
          = x (moeb id x)

-- This has the same form as
-- fix f = f (fix f)
==&gt; moeb id = fix"><pre>moeb <span>id</span> x <span>=</span> <span>id</span> (<span>$</span> moeb <span>id</span> x) x
          <span>=</span> (<span>$</span> moeb <span>id</span> x) x
          <span>=</span> x (moeb <span>id</span> x)

<span><span>--</span> This has the same form as</span>
<span><span>--</span> fix f = f (fix f)</span>
<span>==&gt;</span> moeb <span>id</span> <span>=</span> fix</pre></div>
<p dir="auto">This shows how <code>moeb</code> is a generalization of <code>fix</code>. Being a recursive function
itself, the converse is of course also true,</p>
<div dir="auto" data-snippet-clipboard-copy-content="moeb f x = fix (\go -&gt; f ($ go) x)"><pre>moeb f x <span>=</span> fix (<span>\</span>go <span>-&gt;</span> f (<span>$</span> go) x)</pre></div>
<p dir="auto">so <code>moeb</code> and <code>fix</code> are different flavours of the same kind of recursion.</p>
<p dir="auto">There are other functions that can be used as parameter to <code>moeb</code> such as
<code>traverse</code> and <code>foldMap</code>, but I don&#39;t know of any useful applications for them.</p>
</article>
  </div>

    </div>

  </div></div>
  </body>
</html>
