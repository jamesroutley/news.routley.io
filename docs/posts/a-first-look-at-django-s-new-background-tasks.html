<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://roam.be/notes/2025/a-first-look-at-djangos-new-background-tasks/">Original</a>
    <h1>A first look at Django&#39;s new background tasks</h1>
    
    <div id="readability-page-1" class="page"><div>
        
            <p>Django 6.0 introduces a built-in background tasks framework in <code>django.tasks</code>. But don&#39;t expect to phase out Celery, Huey or other preferred solutions just yet. </p>
<p>The <a href="https://docs.djangoproject.com/en/6.0/releases/6.0/#background-tasks">release notes</a> are quite clear on this:</p>
<blockquote>
<p>Django handles task creation and queuing, but <strong>does not provide a worker mechanism to run tasks.</strong>
Execution must be managed by external infrastructure, such as a separate process or service.</p>
</blockquote>
<p>The main purpose of the new <code>django.tasks</code> module is to <strong>provide a common API for task queues</strong> implementations. <a href="https://theorangeone.net/">Jake Howard</a> is the driving force behind this enhancement. Check out the introduction on <a href="https://forum.djangoproject.com/t/django-tasks-bringing-background-workers-in-to-django-core/32967">the Django forum</a>.</p>
<p>His reference implementation, and simultaneously a backport for earlier versions of Django, is available <a href="https://github.com/RealOrangeOne/django-tasks/">as <code>django-tasks</code> on GitHub</a>.</p>
<p>But let&#39;s ignore that and play with the more minimal version included in Django 6.0 instead. By creating our very own backend and worker.</p>
<h2>Our project: notifications</h2>
<p>We&#39;re going to create an app to send notifications to phones and other devices using <a href="https://ntfy.sh">ntfy.sh</a>. (<a href="https://roam.be/notes/2025/ping-me-using-ntfy-to-stay-updated/">I&#39;m a fan!</a>)</p>
<p>If you prefer to dive into the code yourself, check out <a href="https://github.com/roam/django-tasks-demo">the final version of the project on GitHub</a>.</p>
<p>All that&#39;s required to send a notification to your phone using nfty is:</p>
<ol>
<li><a href="https://ntfy.sh/signup">Register for an account</a></li>
<li>Create a topic.</li>
<li>Install the app for your phone and log in.</li>
<li>Send HTTP requests to <code>https://ntfy.sh/&lt;yourtopic&gt;</code></li>
</ol>
<p>The free version only provides public topics and messages. Meaning anyone can see the stuff you&#39;re sending <em>if</em> they subscribe to the topic. For our purpose we can simply create a topic with a randomized name, like a UUID.</p>
<p>The project&#39;s settings expect the URL from step 4 to be supplied as an environment variable. For example:</p>
<p><code>NTFY_URL=https://ntfy.sh/062519693d9c4913826f0a39aeea8a4c</code></p>
<p>Here&#39;s our function that does the heavy lifting:</p>
<div><pre><span></span><span>import</span><span> </span><span>httpx</span>
<span>from</span><span> </span><span>django.conf</span><span> </span><span>import</span> <span>settings</span>

<span>def</span><span> </span><span>send_notification</span><span>(</span><span>message</span><span>:</span> <span>str</span><span>,</span> <span>title</span><span>:</span> <span>str</span> <span>|</span> <span>None</span><span>):</span>
    <span># Pass the title if specified.</span>
    <span>headers</span> <span>=</span> <span>{</span><span>&#34;title&#34;</span><span>:</span> <span>title</span><span>}</span> <span>if</span> <span>title</span> <span>else</span> <span>{}</span>
    <span>httpx</span><span>.</span><span>post</span><span>(</span>
        <span>settings</span><span>.</span><span>NTFY_URL</span><span>,</span>
        <span>content</span><span>=</span><span>message</span><span>,</span>
        <span>headers</span><span>=</span><span>headers</span><span>,</span>
    <span>)</span>
</pre></div>
<p>Really. That&#39;s all there is to it to start sending and receiving notifications.</p>
<p><img src="https://roam.be/media/img/2025/ntfy-notifications.png" alt="Ntfy notifications"/></p>
<h2>A quick primer</h2>
<p>You really should have a look at the <a href="https://docs.djangoproject.com/en/6.0/topics/tasks/">Django documentation on the Task framework</a> for details, but we&#39;ll save you a bit of time and give a quick primer.</p>
<h3>Defining a task</h3>
<p>This is the main goal of the new framework: defining tasks using Django&#39;s standard API, rather than using task queue specific decorators, or other methods.</p>
<p>So here it goes:</p>
<div><pre><span></span><span># ...</span>
<span>from</span><span> </span><span>django.tasks</span><span> </span><span>import</span> <span>task</span>

<span>@task</span>
<span>def</span><span> </span><span>send_notification</span><span>(</span><span>message</span><span>:</span> <span>str</span><span>,</span> <span>title</span><span>:</span> <span>str</span> <span>|</span> <span>None</span><span>):</span>
    <span># ...as before</span>
</pre></div>
<p>Our function is now a task. In fact it&#39;s a <code>django.tasks.Task</code>. </p>
<p>You cannot call <code>send_notification</code> directly anymore. Tasks can only be run by using the <code>enqueue</code> method. It might not be the behavior you&#39;d expect or want, but this seems to be the best option. This design eliminates the possibility of accidentally invoking a task in-process, rather than in the background.</p>
<p>The <code>task</code> decorator allows you to specify the task&#39;s priority, queue name and backend name. You can override these settings with the <code>using</code> method, which returns a new <code>django.tasks.Task</code> instance.</p>
<p>If you need more control over task behavior, you can set <code>takes_context</code> to <code>True</code> in the decorator and add <code>context</code> as the first argument. This context currently provides you with access to the task result and thereby useful information like the number of attempts. </p>
<p>There&#39;s no way of defining retries and backoffs, or other fancy things you might expect from a full-blown task queue implementation. But that&#39;s <em>not</em> what this is. You can easily add your own retry logic by inspecting the task context if needed.</p>
<h3>Enqueuing a task</h3>
<p>Adding a task to the queue is easy:</p>
<div><pre><span></span><span>task_result</span> <span>=</span> <span>send_notification</span><span>.</span><span>enqueue</span><span>(</span>
    <span>message</span><span>=</span><span>&#34;Season&#39;s greeting!&#34;</span><span>,</span> 
    <span>title</span><span>=</span><span>&#34;Santa has something to tell you&#34;</span>
<span>)</span>
</pre></div>
<h3>Executing a task</h3>
<p>This is where things start to fall short. At least right now. Django 6.0 will ship with the <code>ImmediateBackend</code> and the <code>DummyBackend</code>. The first will execute the task immediately, while the latter will not execute the task at all. </p>
<p>Which is why our project includes a (demo) backend backed by the database and a worker process!</p>
<h3>Fetching the result</h3>
<p>If you&#39;re not going to wait around for the result, you can get a hold of it later on using its id. Simply call <code>get_result(result_id)</code> on your task. </p>
<p>Our project includes a view that&#39;s polled periodically for outstanding results using <a href="https://htmx.org/">htmx</a>. </p>
<p><img src="https://roam.be/media/img/2025/ui.png" alt="Project UI"/></p>
<p>The list underneath the form shows the results for each execution of our task. When the form&#39;s submitted, a new result is added to the top of the list. Htmx is instructed to keep polling for changes as long as the result&#39;s status isn&#39;t <code>FAILED</code> or <code>SUCCESSFUL</code>.</p>
<div><pre><span></span><span>def</span><span> </span><span>task_result</span><span>(</span><span>request</span><span>,</span> <span>result_id</span><span>,</span> <span>status</span><span>):</span>
    <span>result</span> <span>=</span> <span>send_notification</span><span>.</span><span>get_result</span><span>(</span><span>result_id</span><span>)</span>
    <span>if</span> <span>result</span><span>.</span><span>status</span> <span>==</span> <span>status</span><span>:</span>
        <span># No need to swap the result.</span>
        <span>return</span> <span>HttpResponse</span><span>(</span><span>status</span><span>=</span><span>204</span><span>)</span>
    <span>return</span> <span>TemplateResponse</span><span>(</span><span>request</span><span>,</span> <span>&#34;index.html#result&#34;</span><span>,</span> <span>{</span><span>&#34;result&#34;</span><span>:</span> <span>result</span><span>})</span>
</pre></div>
<p>Wondering what <code>index.html#results</code> is doing? Django 6.0 also introduces <a href="https://docs.djangoproject.com/en/6.0/releases/6.0/#template-partials">template partials</a>. In this case our view effectively sends a response containing only the template partial named <code>result</code>.</p>
<h2>Behind the scenes</h2>
<p>When you decorate a callable with <code>task</code>, the configured backend&#39;s <code>task_class</code> is used to wrap the callable. The default&#39;s <code>django.task.Task</code>.</p>
<p>That class&#39;s <code>enqueue</code> method will in turn invoke the configured backend&#39;s <code>enqueue</code> method.</p>
<p>Calling its <code>get_result</code> method is similar: call the configured backend&#39;s <code>get_result</code> method and pass on the result.</p>
<p>Since there&#39;s no workers, that&#39;s basically all a task backend needs to provide. Cool. Let&#39;s add one, shall we?</p>
<h2>A task database backend</h2>
<p>Our goals:</p>
<ul>
<li>A basic task backend, backed by our database.</li>
<li>We want to support &#34;automagic&#34; retries</li>
</ul>
<p>Our <code>enqueue</code> and <code>get_result</code> methods will return an instance of the default <code>django.tasks.TaskResult</code>. This determines the minimum amount of data we need to store, and we&#39;re going to do so in a model called <code>Task</code>.</p>
<h3>Models</h3>
<p>Let&#39;s create a first draft of our <code>Task</code> model, based on the properties of <code>TaskResult</code> and <code>Task</code> in <code>django.tasks</code> (the &#34;dataclasses&#34;):</p>
<div><pre><span></span><span>class</span><span> </span><span>Task</span><span>(</span><span>models</span><span>.</span><span>Model</span><span>):</span>
    <span>priority</span> <span>=</span> <span>models</span><span>.</span><span>IntegerField</span><span>(</span><span>default</span><span>=</span><span>0</span><span>)</span>
    <span>callable_path</span> <span>=</span> <span>models</span><span>.</span><span>CharField</span><span>(</span><span>max_length</span><span>=</span><span>255</span><span>)</span>
    <span>backend</span> <span>=</span> <span>models</span><span>.</span><span>CharField</span><span>(</span><span>max_length</span><span>=</span><span>200</span><span>)</span>
    <span>queue_name</span> <span>=</span> <span>models</span><span>.</span><span>CharField</span><span>(</span><span>max_length</span><span>=</span><span>100</span><span>)</span>
    <span>run_after</span> <span>=</span> <span>models</span><span>.</span><span>DateTimeField</span><span>(</span><span>null</span><span>=</span><span>True</span><span>,</span> <span>blank</span><span>=</span><span>True</span><span>)</span>
    <span>takes_context</span> <span>=</span> <span>models</span><span>.</span><span>BooleanField</span><span>(</span><span>default</span><span>=</span><span>False</span><span>)</span>
    <span># Stores args and kwargs</span>
    <span>arguments</span> <span>=</span> <span>models</span><span>.</span><span>JSONField</span><span>(</span><span>null</span><span>=</span><span>True</span><span>,</span> <span>blank</span><span>=</span><span>True</span><span>)</span>
    <span>status</span> <span>=</span> <span>models</span><span>.</span><span>CharField</span><span>(</span>
        <span>choices</span><span>=</span><span>TaskResultStatus</span><span>.</span><span>choices</span><span>,</span> <span>max_length</span><span>=</span><span>10</span><span>,</span> <span>default</span><span>=</span><span>TaskResultStatus</span><span>.</span><span>READY</span>
    <span>)</span>
    <span>enqueued_at</span> <span>=</span> <span>models</span><span>.</span><span>DateTimeField</span><span>()</span>
    <span>started_at</span> <span>=</span> <span>models</span><span>.</span><span>DateTimeField</span><span>(</span><span>blank</span><span>=</span><span>True</span><span>,</span> <span>null</span><span>=</span><span>True</span><span>)</span>
    <span>finished_at</span> <span>=</span> <span>models</span><span>.</span><span>DateTimeField</span><span>(</span><span>blank</span><span>=</span><span>True</span><span>,</span> <span>null</span><span>=</span><span>True</span><span>)</span>
    <span>last_attempted_at</span> <span>=</span> <span>models</span><span>.</span><span>DateTimeField</span><span>(</span><span>blank</span><span>=</span><span>True</span><span>,</span> <span>null</span><span>=</span><span>True</span><span>)</span>
    <span>return_value</span> <span>=</span> <span>models</span><span>.</span><span>JSONField</span><span>(</span><span>null</span><span>=</span><span>True</span><span>,</span> <span>blank</span><span>=</span><span>True</span><span>)</span>
</pre></div>
<p>What&#39;s missing? For one, the <code>TaskResult</code> also includes a list of encountered errors, and ids of the workers that processed the task. Something that we could <em>perhaps</em> ignore. </p>
<p>Except the <code>TaskResult.attempts</code> property is based on the number of worker ids. And if you&#39;re using the task context within a task, you&#39;re bound to be relying on that type of information.</p>
<p>We could add these details to the <code>Task</code> model by adding a <code>JSONField</code> for each. This is the current approach in the reference implementation. </p>
<p>But let&#39;s be more explicit in our approach and define models for these as well. We&#39;ll record each attempt to execute a task and its potential error, linking them to the task with a foreign key:</p>
<div><pre><span></span><span>class</span><span> </span><span>Error</span><span>(</span><span>models</span><span>.</span><span>Model</span><span>):</span>
    <span>exception_class_path</span> <span>=</span> <span>models</span><span>.</span><span>TextField</span><span>()</span>
    <span>traceback</span> <span>=</span> <span>models</span><span>.</span><span>TextField</span><span>()</span>

<span>class</span><span> </span><span>AttemptResultStatus</span><span>(</span><span>TextChoices</span><span>):</span>
    <span># Subset of TaskResultStatus.</span>
    <span>FAILED</span> <span>=</span> <span>TaskResultStatus</span><span>.</span><span>FAILED</span>
    <span>SUCCESSFUL</span> <span>=</span> <span>TaskResultStatus</span><span>.</span><span>SUCCESSFUL</span>

<span>class</span><span> </span><span>Attempt</span><span>(</span><span>models</span><span>.</span><span>Model</span><span>):</span>
    <span>task</span> <span>=</span> <span>models</span><span>.</span><span>ForeignKey</span><span>(</span><span>Task</span><span>,</span> <span>related_name</span><span>=</span><span>&#34;attempts&#34;</span><span>,</span> <span>on_delete</span><span>=</span><span>models</span><span>.</span><span>CASCADE</span><span>)</span>
    <span>error</span> <span>=</span> <span>models</span><span>.</span><span>OneToOneField</span><span>(</span>
        <span>Error</span><span>,</span> <span>related_name</span><span>=</span><span>&#34;attempt&#34;</span><span>,</span> <span>on_delete</span><span>=</span><span>models</span><span>.</span><span>CASCADE</span><span>,</span> <span>null</span><span>=</span><span>True</span><span>,</span> <span>blank</span><span>=</span><span>True</span>
    <span>)</span>
    <span>worker_id</span> <span>=</span> <span>models</span><span>.</span><span>CharField</span><span>(</span><span>max_length</span><span>=</span><span>MAX_LENGTH_WORKER_ID</span><span>)</span>
    <span>started_at</span> <span>=</span> <span>models</span><span>.</span><span>DateTimeField</span><span>()</span>
    <span>stopped_at</span> <span>=</span> <span>models</span><span>.</span><span>DateTimeField</span><span>(</span><span>blank</span><span>=</span><span>True</span><span>,</span> <span>null</span><span>=</span><span>True</span><span>)</span>
    <span>status</span> <span>=</span> <span>models</span><span>.</span><span>CharField</span><span>(</span>
        <span>choices</span><span>=</span><span>AttemptResultStatus</span><span>.</span><span>choices</span><span>,</span> <span>max_length</span><span>=</span><span>10</span><span>,</span> <span>blank</span><span>=</span><span>True</span>
    <span>)</span>
</pre></div>
<p>This setup ensures we have all necessary information to execute a task, plus we can provide every single bit of detail when a <code>TaskResult</code> is requested.</p>
<p>All fine and dandy, but we need to think about the worker&#39;s requirements as well. It needs to be able to: </p>
<ol>
<li>Quickly check for outstanding tasks</li>
<li>Claim one of those tasks</li>
<li>Process that task and either mark it as failed, successful or ready (to retry later)</li>
</ol>
<p>We could do all of that with how it&#39;s set up right now, but I&#39;d like to refine things a bit.</p>
<div><pre><span></span><span>class</span><span> </span><span>Task</span><span>(</span><span>models</span><span>.</span><span>Model</span><span>):</span>
    <span># ...</span>
    <span># This field is used to keep track of when to run a task (again).</span>
    <span># run_after remains unchanged after enqueueing.</span>
    <span>available_after</span> <span>=</span> <span>models</span><span>.</span><span>DateTimeField</span><span>()</span>
    <span># Denormalized count of attempts.</span>
    <span>attempt_count</span> <span>=</span> <span>models</span><span>.</span><span>IntegerField</span><span>(</span><span>default</span><span>=</span><span>0</span><span>)</span>
    <span># Set when a worker starts processing this task.</span>
    <span>worker_id</span> <span>=</span> <span>models</span><span>.</span><span>CharField</span><span>(</span><span>max_length</span><span>=</span><span>MAX_LENGTH_WORKER_ID</span><span>,</span> <span>blank</span><span>=</span><span>True</span><span>)</span>
    <span># ...</span>
</pre></div>
<p>The <code>available_after</code> field will contain the earliest time at which the task can be executed. If the task&#39;s <code>run_after</code> is specified (which can be done by using a task&#39;s... <code>using()</code> method), <code>available_after</code> is set to that value. Otherwise we&#39;re using the current datetime; all in UTC.</p>
<p>Once a task needs to be retried, <code>available_after</code> will be set to the next possible point in time the task can be executed. In other words: we can <strong>back off.</strong></p>
<p>The <code>attempt_count</code> field makes querying for available tasks a bit easier. Any tasks with an <code>attempt_count</code> greater than the maximum allowed value can be ignored. Yes, their status should have been set to <code>FAILED</code> which means they should be excluded by default, but we could change the configuration and tweak the maximum number of attempts.</p>
<p>The <code>worker_id</code> field is filled when a worker claims a task. This, among other things, prevents any other workers from picking up the task. Assuming the worker id is unique.</p>
<h3>Enqueueing and fetching a result</h3>
<p>Enqueueing a task could not be easier: create a <code>Task</code> <em>model instance</em> from the <code>Task</code> <em>dataclass instance</em>, save it, done! Well, at least after turning the end result into a <code>TaskResult</code>. </p>
<p>We use the string version of the model&#39;s database id as the id of the result.</p>
<p>Retrieving a result is likewise only a matter of loading the task and its attempts, and turning that into a <code>TaskResult</code>. </p>
<p>Here&#39;s a simplified version of our task backend as it stands:</p>
<div><pre><span></span><span>class</span><span> </span><span>DatabaseBackend</span><span>(</span><span>BaseTaskBackend</span><span>):</span>
    <span>supports_defer</span> <span>=</span> <span>True</span>
    <span>supports_async_task</span> <span>=</span> <span>False</span>
    <span>supports_get_result</span> <span>=</span> <span>True</span>
    <span>supports_priority</span> <span>=</span> <span>True</span>

    <span>def</span><span> </span><span>enqueue</span><span>(</span><span>self</span><span>,</span> <span>task</span><span>:</span> <span>Task</span><span>,</span> <span>args</span><span>,</span> <span>kwargs</span><span>):</span>
        <span>self</span><span>.</span><span>validate_task</span><span>(</span><span>task</span><span>)</span>
        <span>model</span> <span>=</span> <span>self</span><span>.</span><span>queue_store</span><span>.</span><span>enqueue</span><span>(</span><span>task</span><span>,</span> <span>args</span><span>,</span> <span>kwargs</span><span>)</span>
        <span>task_result</span> <span>=</span> <span>TaskResult</span><span>(</span>
            <span>task</span><span>=</span><span>task</span><span>,</span>
            <span>id</span><span>=</span><span>str</span><span>(</span><span>model</span><span>.</span><span>pk</span><span>),</span>
            <span># ...</span>
            <span># More properties being set</span>
            <span># ...</span>
        <span>)</span>
        <span>return</span> <span>task_result</span>

    <span>def</span><span> </span><span>get_result</span><span>(</span><span>self</span><span>,</span> <span>result_id</span><span>):</span>
        <span>return</span> <span>self</span><span>.</span><span>model_to_result</span><span>(</span>
            <span>self</span><span>.</span><span>queue_store</span><span>.</span><span>get</span><span>(</span><span>result_id</span><span>)</span>
        <span>)</span>

    <span>def</span><span> </span><span>model_to_result</span><span>(</span><span>self</span><span>,</span> <span>model</span><span>:</span> <span>models</span><span>.</span><span>Task</span><span>)</span> <span>-&gt;</span> <span>TaskResult</span><span>:</span>
        <span>...</span>
</pre></div>
<p>At lot of functionality is deferred to this <code>queue_store</code> property. Before we dive into that, we&#39;ll explain the configuration options for this backend.</p>
<h3>Configuration</h3>
<p>We want to be able to specify defaults for:</p>
<ul>
<li>the maximum number of attempts (retries)</li>
<li>the backoff factor; i.e. we&#39;ll back off using <code>math.pow(factor, attempts)</code></li>
</ul>
<p>These can be customized for each individual queue. So we end up with something like this in our <code>OPTIONS</code>:</p>
<div><pre><span></span><span>TASKS</span> <span>=</span> <span>{</span>
    <span>&#34;default&#34;</span><span>:</span> <span>{</span>
        <span>&#34;BACKEND&#34;</span><span>:</span> <span>&#34;messagecenter.dbtasks.backend.DatabaseBackend&#34;</span><span>,</span>
        <span>&#34;OPTIONS&#34;</span><span>:</span> <span>{</span>
            <span>&#34;queues&#34;</span><span>:</span> <span>{</span>
                <span>&#34;low_priority&#34;</span><span>:</span> <span>{</span>
                    <span>&#34;max_attempts&#34;</span><span>:</span> <span>5</span><span>,</span>
                <span>}</span>
            <span>},</span>
            <span>&#34;max_attempts&#34;</span><span>:</span> <span>10</span><span>,</span>
            <span>&#34;backoff_factor&#34;</span><span>:</span> <span>3</span><span>,</span>
            <span>&#34;purge&#34;</span><span>:</span> <span>{</span><span>&#34;finished&#34;</span><span>:</span> <span>&#34;10 days&#34;</span><span>,</span> <span>&#34;unfinished&#34;</span><span>:</span> <span>&#34;20 days&#34;</span><span>},</span>
        <span>},</span>
    <span>}</span>
<span>}</span>
</pre></div>
<p>A task added to the <code>low_priority</code> queue will be attempted up to five times, with a backoff factor of <code>3</code>. Other tasks will be attempted up to ten times with the same backoff factor.</p>
<h3>Queue store</h3>
<p>The <a href="https://github.com/roam/django-tasks-demo/blob/main/src/messagecenter/dbtasks/backend.py#L279"><code>QueueStore</code> class</a> is a companion of our backend. It&#39;s focus is on retrieving and enqueueing tasks, checking for tasks to execute and claiming tasks. </p>
<p>However the main reason it&#39;s included is to simplify the worker. As we&#39;ll see, the worker gets it&#39;s own copy of the queue store, <em>limited to the queues it needs to process.</em></p>
<h3>The worker</h3>
<p>The worker&#39;s job, at least in this project, is to provide information on outstanding tasks to the runner and to drive the processing of those tasks <em>by the backend</em>. Which means it looks like this:</p>
<div><pre><span></span><span>class</span><span> </span><span>Worker</span><span>:</span>
    <span>def</span><span> </span><span>__init__</span><span>(</span>
        <span>self</span><span>,</span>
        <span>id_</span><span>:</span> <span>str</span> <span>|</span> <span>None</span><span>,</span>
        <span>backend_name</span><span>:</span> <span>str</span><span>,</span>
        <span>only</span><span>:</span> <span>set</span><span>[</span><span>str</span><span>]</span> <span>|</span> <span>None</span><span>,</span>
        <span>excluding</span><span>:</span> <span>set</span><span>[</span><span>str</span><span>]</span> <span>|</span> <span>None</span><span>,</span>
    <span>):</span>
        <span># Grab the backend and its queue_store.</span>
        <span>self</span><span>.</span><span>backend</span> <span>=</span> <span>task_backends</span><span>[</span><span>backend_name</span><span>]</span>
        <span>queue_store</span><span>:</span> <span>QueueStore</span> <span>=</span> <span>self</span><span>.</span><span>backend</span><span>.</span><span>queue_store</span>
        <span># Limit the queue_store to the select queues.</span>
        <span>if</span> <span>only</span> <span>or</span> <span>excluding</span><span>:</span>
            <span>queue_store</span> <span>=</span> <span>queue_store</span><span>.</span><span>subset</span><span>(</span><span>only</span><span>=</span><span>only</span><span>,</span> <span>excluding</span><span>=</span><span>excluding</span><span>)</span>
        <span>self</span><span>.</span><span>queue_store</span> <span>=</span> <span>queue_store</span>
        <span># Use or create and id. &#34;Must&#34; be unique.</span>
        <span>self</span><span>.</span><span>id</span> <span>=</span> <span>(</span>
            <span>id_</span> <span>if</span> <span>id_</span> <span>else</span> <span>create_id</span><span>(</span><span>backend_name</span><span>,</span> <span>queues</span><span>=</span><span>queue_store</span><span>.</span><span>queue_names</span><span>)</span>
        <span>)</span>

    <span>def</span><span> </span><span>has_more</span><span>(</span><span>self</span><span>)</span> <span>-&gt;</span> <span>bool</span><span>:</span>
        <span>return</span> <span>self</span><span>.</span><span>queue_store</span><span>.</span><span>has_more</span><span>()</span>

    <span>def</span><span> </span><span>process</span><span>(</span><span>self</span><span>):</span>
        <span>with</span> <span>transaction</span><span>.</span><span>atomic</span><span>():</span>
            <span>tm</span> <span>=</span> <span>self</span><span>.</span><span>queue_store</span><span>.</span><span>claim_first_available</span><span>(</span><span>worker_id</span><span>=</span><span>self</span><span>.</span><span>id</span><span>)</span>
        <span>if</span> <span>tm</span> <span>is</span> <span>not</span> <span>None</span><span>:</span>
            <span>self</span><span>.</span><span>backend</span><span>.</span><span>process_task</span><span>(</span><span>tm</span><span>)</span>
</pre></div>
<p>All we need to do to have a functioning worker runner:</p>
<ol>
<li>Create an instance of the worker.</li>
<li>Ask it if there&#39;s tasks to execute using <code>has_more</code>.</li>
<li>If so: tell it to <code>process</code> the first available task. If not: go to 4.</li>
<li>Wait, then return to 2.</li>
</ol>
<p>That&#39;s what our <a href="https://github.com/roam/django-tasks-demo/blob/main/src/messagecenter/dbtasks/management/commands/dbtasks_worker.py"><code>dbtasks_worker</code> command</a> does.</p>
<h3>Claiming a task</h3>
<p>Our queue store provides a <code>peek</code> method which returns the id of the task in our queues with the most urgency; a combination of <code>available_after</code>, <code>priority</code> and <code>attempt_count</code>.</p>
<p>This lets the runner know whether there&#39;s more tasks to process. The next step is to claim one of those tasks. So we call <code>peek</code> again and if it returns a task id, we&#39;ll try to claim that particular task.</p>
<p>Here&#39;s a more basic, clearer version than the one included in our project&#39;s <code>QueueStore</code>:</p>
<div><pre><span></span><span>def</span><span> </span><span>claim_first_available</span><span>(</span>
    <span>self</span><span>,</span> <span>worker_id</span><span>:</span> <span>str</span><span>,</span> <span>attempts</span><span>:</span> <span>int</span> <span>=</span> <span>3</span>
<span>)</span> <span>-&gt;</span> <span>models</span><span>.</span><span>Task</span> <span>|</span> <span>None</span><span>:</span>
    <span>qs</span> <span>=</span> <span>models</span><span>.</span><span>Task</span><span>.</span><span>filter</span><span>(</span>
        <span>worker_id</span><span>=</span><span>&#34;&#34;</span><span>,</span> 
        <span>status</span><span>=</span><span>TaskResultStatus</span><span>.</span><span>READY</span><span>,</span>
    <span>)</span>
    <span>for</span> <span>_</span> <span>in</span> <span>range</span><span>(</span><span>attempts</span><span>):</span>
        <span>task_id</span> <span>=</span> <span>self</span><span>.</span><span>peek</span><span>()</span>
        <span>if</span> <span>not</span> <span>task_id</span><span>:</span>
            <span>return</span> <span>None</span>
        <span>count</span> <span>=</span> <span>qs</span><span>.</span><span>filter</span><span>(</span><span>pk</span><span>=</span><span>task_id</span><span>)</span><span>.</span><span>update</span><span>(</span>
            <span>worker_id</span><span>=</span><span>self</span><span>.</span><span>id_</span><span>,</span>
            <span>status</span><span>=</span><span>TaskResultStatus</span><span>.</span><span>RUNNING</span><span>,</span>
        <span>)</span>
        <span>if</span> <span>count</span><span>:</span>
            <span>return</span> <span>models</span><span>.</span><span>Task</span><span>.</span><span>objects</span><span>.</span><span>get</span><span>(</span><span>pk</span><span>=</span><span>task_id</span><span>)</span>
    <span>return</span> <span>None</span>
</pre></div>
<p>If the <code>count</code> is zero, we failed to claim the task. Otherwise we retrieve it from the database and can start processing. </p>
<p>The loop is included because we ended up here after trying to claim the task identified by <code>peek</code>. Which apparently has already been picked up by another worker. We might as well make the most of it and try to grab another task from the queue.</p>
<h3>Processing the task</h3>
<p>And finally the thing that actually does something!</p>
<p>The <code>process_task</code> method of our backend:</p>
<ol>
<li>Creates an <code>Attempt</code> and constructs the current <code>TaskResult</code>.</li>
<li>Executes the task, capturing anything extending <code>BaseException</code>, or returning the <code>return_value</code> of the task when everything went according to plan.</li>
<li>Either updates the <code>Task</code> model, the <code>Attempt</code> <em>and</em> the <code>TaskResult</code> with the final details of the successful execution, or with details about the failure to do so.</li>
<li>And in the latter case: check if the task can be retried.</li>
</ol>
<p>Again: if you want to dive into the details, have a look at <a href="https://github.com/roam/django-tasks-demo">the repository</a>.</p>
<h2>That&#39;s it</h2>
<p>Of course this demo project leaves out all the things you really need to think hard about. Like signals for the worker. Or database transaction logic. That&#39;s not to say it&#39;s impossible. Far from it. It just wasn&#39;t the goal of this article.</p>
<p>The inclusion of this functionality in Django will certainly allow new libraries or adapters for existing task queues to pop up. And we&#39;ll probably soon see some complaints that <code>django.tasks</code> isn&#39;t extensive enough.</p>
<p>Because, if you&#39;re currently using the more advanced functionality of your task queue, there&#39;s probably a few things you&#39;re missing in <code>django.tasks</code>.</p>
<h3>Complex orchestration</h3>
<p>Some task queue libraries, like Celery, provide ways of combining tasks. You can feed the result of one task into another, enqueue tasks for each item in a list, and so on.</p>
<p>It should be clear by now that supporting this kind of orchestration isn&#39;t the goal of <code>django.tasks</code>. And I don&#39;t mind at all. There&#39;s no feasible way of creating a unified API to support this. I&#39;ve had my share of problems with libraries that <em>do</em> claim to support it.</p>
<h3>Retry</h3>
<p>As mentioned before, there&#39;s currently no way to automatically retry a failed task, unless your backend does the heavy lifting. Like ours does. </p>
<p>Depending on your backend this might be easy enough to handle yourself. For example using a decorator:</p>
<div><pre><span></span><span>def</span><span> </span><span>retry</span><span>(</span><span>func</span><span>):</span>
    <span>@functools</span><span>.</span><span>wraps</span><span>(</span><span>func</span><span>)</span>
    <span>def</span><span> </span><span>wrapper</span><span>(</span><span>context</span><span>:</span> <span>TaskContext</span><span>,</span> <span>*</span><span>args</span><span>,</span> <span>**</span><span>kwargs</span><span>):</span>
        <span>try</span><span>:</span>
            <span>return</span> <span>func</span><span>(</span><span>context</span><span>,</span> <span>*</span><span>args</span><span>,</span> <span>**</span><span>kwargs</span><span>)</span>
        <span>except</span> <span>BaseException</span> <span>as</span> <span>e</span><span>:</span>
            <span>result</span> <span>=</span> <span>context</span><span>.</span><span>task_result</span>
            <span>backoff</span> <span>=</span> <span>math</span><span>.</span><span>pow</span><span>(</span><span>2</span><span>,</span> <span>result</span><span>.</span><span>attempts</span><span>)</span>
            <span>run_after</span> <span>=</span> <span>datetime</span><span>.</span><span>now</span><span>(</span><span>tz</span><span>=</span><span>UTC</span><span>)</span> <span>+</span> <span>timedelta</span><span>(</span><span>seconds</span><span>=</span><span>backoff</span><span>)</span>
            <span>result</span><span>.</span><span>task</span><span>.</span><span>using</span><span>(</span><span>run_after</span><span>=</span><span>run_after</span><span>)</span><span>.</span><span>enqueue</span><span>(</span><span>*</span><span>args</span><span>,</span> <span>**</span><span>kwargs</span><span>)</span>
            <span>raise</span> <span>e</span>
    <span>return</span> <span>wrapper</span>


<span>@task</span><span>(</span><span>takes_context</span><span>=</span><span>True</span><span>)</span>
<span>@retry</span>
<span>def</span><span> </span><span>send_email</span><span>(</span><span>context</span><span>:</span> <span>TaskContext</span><span>,</span> <span>to</span><span>:</span> <span>str</span><span>,</span> <span>subject</span><span>:</span> <span>str</span><span>,</span> <span>body</span><span>:</span> <span>str</span><span>):</span>
    <span># Do your thing </span>
    <span>...</span>
</pre></div>
<h3>An actual worker mechanism</h3>
<p>True. But the <a href="https://github.com/RealOrangeOne/django-tasks/">reference implementation</a> does provide actual workers. Be patient, or even better: start helping out!</p>
<h2>There is no perfect solution</h2>
<p>I reckon <code>django.tasks</code> will soon result in covering at least the most common 80% of use cases. Yes, its API is simple and limited, but to me that&#39;s more a benefit rather than a fault. I think this is as close as you can get to a standardized approach.</p>

        
    </div></div>
  </body>
</html>
