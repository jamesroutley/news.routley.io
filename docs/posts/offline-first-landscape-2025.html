<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://marcoapp.io/blog/offline-first-landscape">Original</a>
    <h1>Offline-First Landscape – 2025</h1>
    
    <div id="readability-page-1" class="page"><div data-framer-name="Content" data-framer-component-type="RichTextContainer"><h3>Introduction</h3><p>When we set out to build Marco, we knew we were committing to two very difficult requirements: (1) IMAP-based, not API-based, and (2) cross-platform – web, Mac, Windows, Android, iOS.</p><p>We had a handful of additional ancillary requirements. One of these was offline-first, and I can now say confidently that we drastically underestimated its complexity.</p><p>I mentioned in a <!--$--><a href="https://marcoapp.io/blog/marco-an-introduction" target="_blank" rel="noopener">previous blog post</a><!--/$--> that <!--$--><a href="https://missiveapp.com" target="_blank" rel="noopener">Missive</a><!--/$--> was my daily driver in the recent past. It lacks offline support though, and this is one of the major downfalls of the product.</p><p>At Marco we believe that full offline support is crucial. &#34;Managing your emails on an airplane with no wifi&#34; is an example use case we frequently come back to. You should be able to read, delete, respond, and organise your emails with no internet connection. When you land and connect to wifi, everything should seamlessly sync.</p><p>That said, Marco is not a simple todo app. Marco is not an application that starts with zero data and grows in size gradually, as is the case with user-generated content like Notion, etc.</p><p>Marco is an application that deals with hundreds of MB of data, and hundreds of thousands (or millions) of rows/entities.</p><p>Essentially this means we are instantly jumping into the top 1% of heavy-duty use cases for offline-first implementations. Over time we realised that this actually rules out almost all available offline-first options.</p><h3>Starting Point: WatermelonDB</h3><p>I spent about a week deeply investigating the offline-first options available to us, in August 2024.</p><p>We (perhaps naively) had committed to the idea that our offline-first architecture should be database-agnostic – the offline-first logic should &#34;end&#34; at the API layer. We did not want to manage sync tables or schemas in Postgres – we wanted to write API endpoints, and manage our database ourselves.</p><p>Here&#39;s a rundown of the initial offline-first options we looked at:</p><ol><li data-preset-tag="p"><p><!--$--><a href="https://watermelondb.dev/docs" target="_blank" rel="noopener">WatermelonDB</a><!--/$--></p><ul><li data-preset-tag="p"><p>FOSS, self-hosted</p></li><li data-preset-tag="p"><p>Database agnostic</p></li><li data-preset-tag="p"><p>Been around for ages, used in many production applications</p></li></ul></li><li data-preset-tag="p"><p><!--$--><a href="https://www.powersync.com/" target="_blank" rel="noopener">PowerSync</a><!--/$--></p><ul><li data-preset-tag="p"><p>Not quite FOSS, but has a free Self-Hosted Edition</p></li><li data-preset-tag="p"><p>Requires Postgres-level integration</p></li><li data-preset-tag="p"><p>Very complex architecture, requires both changes to Postgres _and_ a separate HA MongoDB deployment cluster</p></li><li data-preset-tag="p"><p>Appears to have been around quite awhile, but all their case studies are on demo/tiny/side projects</p></li></ul></li><li data-preset-tag="p"><p><!--$--><a href="https://electric-sql.com" target="_blank" rel="noopener">ElectricSQL</a><!--/$--></p><ul><li data-preset-tag="p"><p>Looked interesting, but was in the middle of a complete rewrite</p></li><li data-preset-tag="p"><p>Requires Postgres-level integration</p></li><li data-preset-tag="p"><p>New version only handles data sync one way – it does <em>not</em> handle mutations</p></li></ul></li></ol><p>There are <em>many</em> other options, including RxDB, MongoDB Atlas, Couchbase, and on and on. The three listed above are the options that we deeply investigated. As will become clear, we should have looked further at this stage.</p><p>We settled on WatermelonDB and built the initial alpha version of Marco on it. The backend implementation is rather simple: there is a &#34;pull&#34; endpoint to GET data, and a &#34;push&#34; endpoint to POST mutations.</p><p>It is important here to note that although Marco is a native application in some targets, it also must run in a web browser. While we may have access to a filesystem or &#34;true&#34; SQLite in native targets, our common denominator is web, where persistent storage options are very limited.</p><p>On the (web) frontend, Watermelon uses IndexedDB (as do essentially all other options – even the WASM SQLite options are usually SQLite-on-top-of-IndexedDB). However, it turns out Watermelon faces a serious problem that all other relational frontend databases face – IndexedDB performance is <em>terrible</em>. To solve this, Watermelon uses <!--$--><a href="https://watermelondb.dev/docs/Implementation/DatabaseAdapters#lokijs" target="_blank" rel="noopener">a LokiJS adapter</a><!--/$-->, which is literally just an in-memory database.</p><p>Yes, you heard that right. To get around IndexedDB performance issues, Watermelon uses LokiJS to... hold the entire database in memory. When your database size is 100MB+, this starts to become a serious problem.</p><p>Moreover, clients <em>must</em> pull data before they can push any new mutations, and mutations can easily be clobbered if the row has been updated on the backend before the frontend can push mutations.</p><p>On top of this, WatermelonDB is not as actively-maintained as it once was. Many issues and PRs are left without a response. For example, chunked initial syncing is not supported out of the box. We opened <!--$--><a href="https://github.com/Nozbe/WatermelonDB/pull/1866" target="_blank" rel="noopener">a PR</a><!--/$--> for this in early December, but it&#39;s still not been merged.</p><p>We got quite far along with the Marco alpha build, and then had a bit of a panic in November. Our confidence in our WatermelonDB-based offline-first approach was decreasing steadily. We began to seriously question if this technology could actually support a rock-solid, modern user experience.</p><p>We decided we needed to find something better.</p><h3>New Wave of Offline-First</h3><p>This time around, we threw out any preconceptions we had about Postgres, separation of concerns at the API layer, etc. We had completely open minds and desperately wanted to find the &#34;best&#34; solution, no matter what that might look like. We were now extremely clear on the fact that we had a &#34;tough&#34; offline-first use case, and needed some serious help.</p><p>We discovered a host of &#34;new wave&#34; offline first implementations. We talked with the founders/developers of these projects and found so many extremely intelligent and talented people working on what is a very tough problem.</p><p>The leaders in this new wave are:</p><ol><li data-preset-tag="p"><p><!--$--><a href="https://www.triplit.dev" target="_blank" rel="noopener">Triplit</a><!--/$--></p></li><li data-preset-tag="p"><p><!--$--><a href="https://www.instantdb.com" target="_blank" rel="noopener">InstantDB</a><!--/$--></p></li><li data-preset-tag="p"><p><!--$--><a href="https://www.convex.dev" target="_blank" rel="noopener">Convex</a><!--/$--></p></li></ol><p>While Triplit and InstantDB can be described as &#34;full stack databases&#34;, Convex is instead an entire backend solution, including API endpoints, etc. For this reason we excluded Convex, as it seems like a huge leap and essentially 100% lock-in.</p><h3>Problems with Triplit</h3><p>Our first (of several) rewrites was from WatermelonDB to Triplit. Both Triplit and InstantDB use triples to represent data – entities are stored as &#34;triples&#34; of (&lt;entity id&gt;, &lt;entity field&gt;, &lt;entity value&gt;). Such a representation makes syncing a straightforward affair.</p><p>Triplit&#39;s API and DX is best-in-class. However, although we desperately wanted to love the product, we found it unusable for our use case. The server-side implementation was eating gigabytes of RAM while sitting idle and would regularly OOM/crash. The client-side triples implementation would balloon 5MB of JSON into 1GB of SQLite.</p><p>We believe Triplit is a fantastic choice for any offline-first applications with relatively small storage needs. On top of this, we found the Triplit team to be incredibly talented and hard-working, and truly believe that by mid-2025, it will be a robust and capable product.</p><p>We absolutely love the developer experience with Triplit, and are rooting for the team to succeed!</p><p>But we need something which is reliable, highly performant, and battle-tested, <em>now</em>.</p><h3>Problems with InstantDB</h3><p>We next moved onto InstantDB, which can be considered a direct competitor to Triplit. Although both InstantDB and Triplit essentially solve the same problem, we found InstantDB to be a far worse implementation.</p><p>TypeScript types were non-existent. There was no sort/ordering by fields. There was no support for $like operators, and certainly no full text search. I believe some of these features have since been added – both teams are certainly scrambling to handle a million features and requests.</p><p>On the backend side of things, there are no webhooks, so it is impossible to respond to mutations in a scalable way. We would have had to build our own singleton subscriber microservice that then translated reactive queries into scalable webhooks. But reactive queries themselves are prone to dropped data, so we would need some sort of polling fallback... The backend story for InstantDB feels extremely incomplete.</p><p>Even looking past all of this, frontend queries that returned in 2-5ms with Watermelon+LokiJS were taking 200-500ms to return data with InstantDB. This is primarily because InstantDB is not optimistic, and was hitting network to fetch data with almost every request. There is no granular control as to what gets cached on the client side and what does not.</p><p>InstantDB is another promising product, and our understanding is that some teams are already building production applications on top of it. But it&#39;s simply too immature for our use case right now. There&#39;s essentially zero backend support, and the frontend UX felt like a massive downgrade coming from Watermelon.</p><h3>Problems with PowerSync</h3><p>Finally, to our great disappointment, we begrudgingly moved on to PowerSync. We were wary of PowerSync from the beginning, and our reluctance proved to be well-founded.</p><p>Although PowerSync is undoubtedly a mature product, and probably the most capable (on paper) of all options mentioned thus far, we hated every minute of working with it. The underlying tech might be the most production/enterprise friendly, but the DX is the worst by quite a margin.</p><p>There is a paid SaaS offering, but their pricing model would have made our use case prohibitively expensive. Therefore we needed to self-host PowerSync, which is quite a complex and expensive task in itself. Not only does it require Postgres-level integration, it also needs a HA MongoDB cluster, a lot of arcane yaml configuration, etc. It also required us to completely denormalise our Postgres tables, as relations are not properly supported across the sync buckets.</p><p>On the frontend side of things, PowerSync runs SQLite in WASM, and although the DX is fairly good, we found horrifying problems like off-by-one bugs in their Drizzle ORM integration, queries returning data <em>from local db</em> very slowly (100ms+), and long initialisation times (45s+ after login to Marco) with the UI view not updating until the sync fully completed.</p><h3>Why So Many Problems?</h3><p>There is a saying: if everyone is an asshole, maybe you&#39;re the asshole. Is the problem 5+ offline-first tools, or is it us?</p><p>Like with most things, the reality is &#34;a bit of both&#34;. As mentioned, Marco is an incredibly data-intensive application, and from day one, we were pushing these offline-first tools to their absolute limits.</p><p>However, we also found the practical limits of these tools to be way lower than one would expect.</p><p>What is the underlying cause? In my estimation, the root cause is that all of these offline-first tools for web are essentially hacks. Because of Marco&#39;s web deployment target, which becomes our common denominator, we <em>must</em> support offline-first in a web browser, and web browsers only really support KV storage via IndexedDB.</p><p>All attempts to implement relational or graph databases within a web browser are essentially hacks. PowerSync itself is WASM SQLite... <em>On top of IndexedDB</em>. Binary SQLite chunks are literally stored in IndexedDB.</p><p>There are essentially three different variables:</p><ol><li data-preset-tag="p"><p>The underlying (true) data store – this will always be IndexedDB for web implementations</p></li><li data-preset-tag="p"><p>How the data is represented for sync purposes</p></li><li data-preset-tag="p"><p>How the data is presented to developers</p></li></ol><p>The new wave of tools are attempting triples/graph implementations, but the story is the same. Browsers only give you a KV API, and anything on top of that will be built in userland and will suffer poor performance once you hit a certain scale. Although triples are easy to store and sync, when you try to jam a relational layer on top, the whole thing starts to fall apart.</p><p>To be absolutely clear: these relational and graph implementations on top of IndexedDB do not start to show their cracks unless you have 10s/100s of MB of data, or hundreds of thousands of rows/entities. But at a certain scale, performance grinds to a halt and they become unusable. For lesser use cases, Triplit and InstantDB offer exceptional DX and velocity, with almost no drawbacks.</p><p>At this point, we were starting to pull our hair out, and were wondering if we needed to build our own sync engine. Like many others, we&#39;re highly impressed with Linear, but are also aware that their sync engine was a monumental engineering effort.</p><p>We&#39;re only a team of two, and we have a <em>lot</em> to work on besides offline-first itself.</p><h3>Finally, A Solution</h3><p>Some time in early December, I came back across an option which I had glanced over before, but disregarded: <!--$--><a href="https://replicache.dev" target="_blank" rel="noopener">Replicache</a><!--/$-->.</p><p>I think we were initially put off by their strange pricing model and the fact that it&#39;s closed-source.</p><p>I am so glad we took another look.</p><p>In terms of backend implementation, Replicache is somewhat similar to WatermelonDB, in that you need to implement push and pull endpoints in your backend, and it is otherwise entirely database-agnostic.</p><p>The frontend is where the crucial difference lies – Replicache is <em>just</em> a KV store. It is a thin layer on top of IndexedDB that adds reactivity and some querying DX. That&#39;s it. You get raw <code>get</code> and <code>set</code> performance. Some performance benchmarks are outlined <!--$--><a href="https://doc.replicache.dev/concepts/performance" target="_blank" rel="noopener">here</a><!--/$-->. The perf is truly remarkable.</p><p>The drawback to this KV approach is that searching/sorting/ordering entities would require scanning through entire collections. This is obviously a non-starter. In other words, if we wanted to use Replicache, we would need to handle indexing and search on our own.</p><p>We&#39;ll post more detailed write-ups on our tech stack in the future, but a quick summary of where we landed on the frontend is: Replicache + <!--$--><a href="https://github.com/oramasearch/orama" target="_blank" rel="noopener">Orama</a><!--/$-->. This gives us sophisticated and battle-tested data sync with conflict resolution and rebasing, but also extremely flexible and powerful indexing, full-text search, and more.</p><p>At the time of writing (January 2025), the Replicache team have just made it completely free and open source. This is because they&#39;ve just released <!--$--><a href="https://zero.rocicorp.dev" target="_blank" rel="noopener">Zero</a><!--/$-->, which looks extraordinarily compelling and will likely jump into the #1 spot for any offline-first product available.</p><p>We&#39;re eager to try Zero once it&#39;s a bit more stable, but for now will build our product on the extremely capable and robust piece of software that is Replicache.</p><h3>Future of Offline-First</h3><p>We embarked on a long and rambling journey through essentially all prior art and work in the offline-first world. It&#39;s a very hard problem to solve.</p><p>The good news is that there are many new teams and projects actively and energetically working on this problem.</p><p>Imagine a world where, as a fullstack developer, you can read and write data from an SDK in both your backend and your frontend, and they magically sync with each other. All your apps are instantly responsive. All your apps work offline out of the box.</p><p>This is already possible today with Triplit or InstantDB, if your use case is reasonable. And things are only improving.</p><p>I believe 2025 will be a year where HTTP/REST APIs will start to feel antiquated. Don&#39;t share endpoints – share databases.</p></div></div>
  </body>
</html>
