<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/DrBubble/ArduinoOS">Original</a>
    <h1>ArduinoOS (2017)</h1>
    
    <div id="readability-page-1" class="page"><div id="user-content-id-sleep" dir="auto"> 

<p dir="auto">In order to pause your programm you can use:</p>

<p dir="auto">Do not use <code>delay</code> since it does not allow the operating system to execute other tasks in the meanwhile and will block the thread for that time. That means <code>delay(500)</code> will block for 1 second if 2 Threads are running and for 2 seconds if 4 threads are running.</p>
<div id="user-content-id-create-thread" dir="auto">

<p dir="auto">With <code>InitTask </code> a new thread can be created.</p>
<p dir="auto">Example:</p>
<div dir="auto" data-snippet-clipboard-copy-content="void mainThread()
{
    InitTask(secondThread);
}

void secondThread()
{

}"><pre><span>void</span> <span>mainThread</span>()
{
    <span>InitTask</span>(secondThread);
}

<span>void</span> <span>secondThread</span>()
{

}</pre></div>
<div id="user-content-id-operating-system-uptime" dir="auto">

<p dir="auto">To get the uptime of the operating system use <code>getElapsedMilliseconds</code> or <code>getElapsedTicks</code>.</p>
<div id="user-content-id-locks" dir="auto">

<p dir="auto">In order to keep your application thread safe you can use locks. With locks you can prevent an other thread to access a variable, function, ... in an unsafe state.</p>
<p dir="auto">Example for conflicting threads:</p>
<div dir="auto" data-snippet-clipboard-copy-content="void mainThread()
{
    InitTask(thread2);
    while (true)
    {
        Serial.println(&#34;Thread1&#34;);
    }
}

void thread2()
{
    while (true)
    {
        Serial.println(&#34;Thread2&#34;);
    }
}"><pre><span>void</span> <span>mainThread</span>()
{
    <span>InitTask</span>(thread2);
    <span>while</span> (<span>true</span>)
    {
        Serial.<span>println</span>(<span><span>&#34;</span>Thread1<span>&#34;</span></span>);
    }
}

<span>void</span> <span>thread2</span>()
{
    <span>while</span> (<span>true</span>)
    {
        Serial.<span>println</span>(<span><span>&#34;</span>Thread2<span>&#34;</span></span>);
    }
}</pre></div>
<p dir="auto">If you execute this code you will notice that it will output something strange like:</p>
<div data-snippet-clipboard-copy-content="1hrThd2adTh
Tadea
T
eared1hrThd2adTh
Tadea
T"><pre><code>1hrThd2adTh
Tadea
T
eared1hrThd2adTh
Tadea
T
</code></pre></div>
<p dir="auto">This is because while one thread is writing into the serial it will be interrupted by the other thread. In order to prevent this you can use locks. With the method <code>GetLockObject</code> you can create a instance of a lock object.</p>
<p dir="auto">Example:</p>
<div dir="auto" data-snippet-clipboard-copy-content="lock *serialLock = GetLockObject();"><pre>lock *serialLock = GetLockObject();</pre></div>
<p dir="auto">With <code>AquireLock(serialLock)</code> you can now lock the object. To release it use <code>ReleaseLock(serialLock)</code>.</p>
<p dir="auto">Example:</p>
<div dir="auto" data-snippet-clipboard-copy-content="void setup()
{
    Serial.begin(9600);
    KernelInitializer::InitializeKernel(mainThread);
}

lock *serialLock = GetLockObject();

void mainThread()
{
    InitTask(thread2);
    while (true)
    {
        AquireLock(serialLock);
        Serial.println(&#34;Thread1&#34;);
        ReleaseLock(serialLock);
    }
}

void thread2()
{
    while (true)
    {
        AquireLock(serialLock);
        Serial.println(&#34;Thread2&#34;);
        ReleaseLock(serialLock);
    }
}"><pre><span>void</span> <span>setup</span>()
{
    Serial.<span>begin</span>(<span>9600</span>);
    <span>KernelInitializer::InitializeKernel</span>(mainThread);
}

lock *serialLock = GetLockObject();

<span>void</span> <span>mainThread</span>()
{
    <span>InitTask</span>(thread2);
    <span>while</span> (<span>true</span>)
    {
        <span>AquireLock</span>(serialLock);
        Serial.<span>println</span>(<span><span>&#34;</span>Thread1<span>&#34;</span></span>);
        <span>ReleaseLock</span>(serialLock);
    }
}

<span>void</span> <span>thread2</span>()
{
    <span>while</span> (<span>true</span>)
    {
        <span>AquireLock</span>(serialLock);
        Serial.<span>println</span>(<span><span>&#34;</span>Thread2<span>&#34;</span></span>);
        <span>ReleaseLock</span>(serialLock);
    }
}</pre></div>
<p dir="auto">The output will now be like expected:</p>
<div data-snippet-clipboard-copy-content="Thread1
Thread2
Thread1
Thread2"><pre><code>Thread1
Thread2
Thread1
Thread2
</code></pre></div>
<div id="user-content-id-exceptions" dir="auto">

<p dir="auto">In order to make error handling more easy you can use exceptions. ArduinoOS provides simple integer based exceptions. To save memory there is no such thing as an error message. Uncaught exceptions will result in a <a href="#id-Kernel-Panic">KernelPanic</a> with the error <code>KERNEL_ERROR_UNHANDLED_EXCEPTION</code>.</p>
<div id="user-content-id-throw" dir="auto">

<p dir="auto">With <code>throw</code> a new exception can be thrown. This example throws an EXCEPTION_ILLEGAL_ARGUMENT_NULL. After the throw it will jump to the next catch that catches an exception of this type. If it does not get caught anywhere it will result in a <a href="#id-Kernel-Panic">KernelPanic</a> with the error <code>KERNEL_ERROR_UNHANDLED_EXCEPTION</code>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="throw(EXCEPTION_ILLEGAL_ARGUMENT_NULL);"><pre><span>throw</span>(EXCEPTION_ILLEGAL_ARGUMENT_NULL);</pre></div>
<div id="user-content-id-try-catch" dir="auto">

<p dir="auto">In order to catch exceptions use <code>try</code> and <code>catch</code>. If an exception gets thrown inside the try block it will jump into the catch block. After the catch block <code>clearException</code> must be called. If you forget this there will be a syntax error.</p>
<p dir="auto">Example:</p>
<div dir="auto" data-snippet-clipboard-copy-content="try
{
    // Try code
}
catch
{
    // Error handling code
}
clearException();"><pre><span>try</span>
{
    <span><span>//</span> Try code</span>
}
<span>catch</span>
{
    <span><span>//</span> Error handling code</span>
}
<span>clearException</span>();</pre></div>
<p dir="auto">It is important that <code>return</code> can <b>not</b> be called inside a try block or catch block. There is some stack memory to free after the try catch block. Usually this is done inside clearException(). When returning inside a try block or catch block this function will never be called. In order to still return use <code>retex</code>.</p>
<p dir="auto">Example:</p>
<div dir="auto" data-snippet-clipboard-copy-content="try
{
    retex(someFunction()); // Save return
}
catch
{
    retex(-1); // Save return
}
clearException();"><pre><span>try</span>
{
    <span>retex</span>(<span>someFunction</span>()); <span><span>//</span> Save return</span>
}
<span>catch</span>
{
    <span>retex</span>(-<span>1</span>); <span><span>//</span> Save return</span>
}
<span>clearException</span>();</pre></div>
<p dir="auto">In order to catch exceptions of an specific type use <code>catchType</code>.</p>
<p dir="auto">Example:</p>
<div dir="auto" data-snippet-clipboard-copy-content="try
{
    // Try code
}
catchType(EXCEPTION_ILLEGAL_ARGUMENT)
{
    // Handle exceptions of type ILLEGAL_ARGUMENT 
}
clearException();"><pre><span>try</span>
{
    <span><span>//</span> Try code</span>
}
<span>catchType</span>(EXCEPTION_ILLEGAL_ARGUMENT)
{
    <span><span>//</span> Handle exceptions of type ILLEGAL_ARGUMENT </span>
}
<span>clearException</span>();</pre></div>
<div id="user-content-id-derivation" dir="auto">

<p dir="auto">Derivation means that a exception can have child and parent exceptions. When a parent exception gets caught inside a <code>catchType</code> also it child exceptions will be. All exceptions are derived from <code>EXCEPTION</code>. Derivation is achieved by ranges starting with 50. The <b>0</b> at the end says it is a parent exception of all exceptions that have some other numbers instead of the 0. For example 5<b>0</b> is the parent exception from all exceptions from 5<b>1</b> to 5<b>9</b>.</p>
<p dir="auto">Examples:</p>
<pre>0 (EXCEPTION) is the parent from all
1-49 have no children
5<b>0</b> is parent from 5<b>1</b> to 5<b>9</b>.
1<b>00</b> is parent from 1<b>01</b> to 1<b>99</b>.
1<b>000</b> is parent from 1<b>001</b> to 1<b>999</b>.
127<b>0</b> is parent from 127<b>1</b> to 127<b>9</b>.
</pre>
<div id="user-content-id-exception-codes" dir="auto">

<pre>EXCEPTION = 0
EXCEPTION_OUT_OF_STACK = 1
EXCEPTION_OUT_OF_MEMORY = 2

EXCEPTION_NULL_POINTER = 10
EXCEPTION_UNHANDLED_EXCEPTION = 11
EXCEPTION_NOT_IMPLEMENTED = 12
EXCEPTION_NOT_SUPORTED = 13
EXCEPTION_INVALID_FORMAT = 14
EXCEPTION_ACCES_VIOLATION = 15
EXCEPTION_ACCES_TIMEOUT = 16
EXCEPTION_INVALID_OPERATION_EXCEPTION = 50
EXCEPTION_ARITHMETIC = 60
EXCEPTION_ARITHMETIC_DIVIDE_BY_ZERO = 61
EXCEPTION_BUFFER_OVERFLOW = 70
EXCEPTION_INDEX_OUT_OF_RANGE = 71
EXCEPTION_ASSERTION_ERROR = 80
EXCEPTION_ILLEGAL_ARGUMENT = 90
EXCEPTION_ILLEGAL_ARGUMENT_NULL = 91
EXCEPTION_ILLEGAL_ARGUMENT_TO_BIG = 92
EXCEPTION_ILLEGAL_ARGUMENT_TO_SMALL = 93
EXCEPTION_ILLEGAL_ARGUMENT_OUT_OF_RANGE = 94
EXCEPTION_ILLEGAL_ARGUMENT_FORMAT = 95
EXCEPTION_IO = 110
EXCEPTION_IO_EOF = 111
EXCEPTION_IO_ACCESS_DENIED = 112
EXCEPTION_IO_INVALID_DATA = 113
EXCEPTION_IO_FILE_NOT_FOUND = 114
EXCEPTION_IO_DIRECTORY_NOT_FOUND = 115
EXCEPTION_NOT_UNIQUE = 120
EXCEPTION_DUPLICATE_KEY = 121
</pre>
<div id="user-content-id-advanced" dir="auto">

<div id="user-content-id-error-handling" dir="auto">

<div id="user-content-id-kernel-panic" dir="auto">

<p dir="auto">In order to catch kernel errors there is the function <code>OnKernelPanic</code>. When this function gets called a kernel panic happened. A kernel panic is like a bluescreen in windows. When this function gets called the operating system is in an unstable state and stops its execution in order to prevent damage. Do not call any ArduinoOS functions inside this function. They will not work and their behavior is unpredictable. You can use this function for example to notify the user about the error code (LED, Serial, ...) or to reset the arduino.</p>
<p dir="auto">Error codes:</p>
<div data-snippet-clipboard-copy-content="KERNEL_ERROR_OUT_OF_STACK        = 1
KERNEL_ERROR_OUT_OF_MEMORY       = 2
KERNEL_ERROR_UNHANDLED_EXCEPTION = 3"><pre><code>KERNEL_ERROR_OUT_OF_STACK        = 1
KERNEL_ERROR_OUT_OF_MEMORY       = 2
KERNEL_ERROR_UNHANDLED_EXCEPTION = 3
</code></pre></div>
<p dir="auto">Example:</p>
<div dir="auto" data-snippet-clipboard-copy-content="void HandleKernelPanic(uint8_t errorCode)
{
    // User defined code for error handling
}

void setup()
{
    OnKernelPanic = HandleKernelPanic;
    KernelInitializer::InitializeKernel(mainThread);
}

void mainThread()
{
    // Provocates an out of memory error
    while (true)
    {
        InitTask(thread);
    }
}

void thread()
{
    while (true);
}"><pre><span>void</span> <span>HandleKernelPanic</span>(<span>uint8_t</span> errorCode)
{
    <span><span>//</span> User defined code for error handling</span>
}

<span>void</span> <span>setup</span>()
{
    OnKernelPanic = HandleKernelPanic;
    <span>KernelInitializer::InitializeKernel</span>(mainThread);
}

<span>void</span> <span>mainThread</span>()
{
    <span><span>//</span> Provocates an out of memory error</span>
    <span>while</span> (<span>true</span>)
    {
        <span>InitTask</span>(thread);
    }
}

<span>void</span> <span>thread</span>()
{
    <span>while</span> (<span>true</span>);
}</pre></div>
<div id="user-content-id-free-memory" dir="auto">

<p dir="auto">In order to get the free memory use the function <code>freeMemory</code>.</p>
<div id="user-content-id-free-stack" dir="auto">

<p dir="auto">In order to get the free stack use the function <code>freeStack</code>. Keep in mind that this function will require a bit of stack itself.</p>
<div id="user-content-id-stack" dir="auto">

<p dir="auto">A Stack is a data type which allows putting (push) data on it and then take (pop) it from up to down. For more information see <a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)" rel="nofollow">Wikipedia</a>. Various operations like calling functions require space on the stack. ArduinoOS will reserve stack space for every thread. In order to set the stack space use <code>InitTaskWithStackSize</code> or <code>InitTaskWithStackSizeAndArgument</code> when creating a new thread.</p>
<p dir="auto">Example:</p>
<div dir="auto" data-snippet-clipboard-copy-content="void mainThread()
{
    InitTaskWithStackSize(thread2, STACK_SIZE_LARGE);
}

void thread2()
{

}"><pre><span>void</span> <span>mainThread</span>()
{
    <span>InitTaskWithStackSize</span>(thread2, STACK_SIZE_LARGE);
}

<span>void</span> <span>thread2</span>()
{

}</pre></div>
<p dir="auto">The predefined stack size values are:</p>
<div data-snippet-clipboard-copy-content="STACK_SIZE_TINY = 64 bytes
STACK_SIZE_SMALL = 96 bytes
STACK_SIZE_MEDIUM = 128 bytes
STACK_SIZE_LARGE = 256 bytes
STACK_SIZE_GIANT = 512 bytes
STACK_SIZE_DEFAULT = 128 bytes"><pre><code>STACK_SIZE_TINY = 64 bytes
STACK_SIZE_SMALL = 96 bytes
STACK_SIZE_MEDIUM = 128 bytes
STACK_SIZE_LARGE = 256 bytes
STACK_SIZE_GIANT = 512 bytes
STACK_SIZE_DEFAULT = 128 bytes
</code></pre></div>
<p dir="auto">You can also pass you own stack size as an uint16_t. Keep in mind that this is not recommended for dying threads since the use of many different stack sizes can lead to stronger memory fragmentation. If a Thread with the stack size of 63 will be created 63 bytes of memory will be reserved. After that a second thread with 64 Bytes of reserved memory will be created. When the first thread gets destroyed 63 bytes of memory will be free before the second thread. If now a third thread with a stack size of 64 bytes will be created it can not be placed before the second thread since only 63 bytes of memory are free. So it will be placed after the second thread and will cause 63 bytes of memory to be wasted.</p>
<p dir="auto">The main thread gets a default stack size of STACK_SIZE_LARGE. It can passed as a second argument in <code>KernelInitializer::InitializeKernel</code>.</p>
<p dir="auto">Example:</p>
<div dir="auto" data-snippet-clipboard-copy-content="KernelInitializer::InitializeKernel(mainThread, STACK_SIZE_MEDIUM);"><pre><span>KernelInitializer::InitializeKernel</span>(mainThread, STACK_SIZE_MEDIUM);</pre></div>
<div id="user-content-id-thread-arguments" dir="auto">

<p dir="auto">In order to pass an argument to a thread use <code>InitTaskWithArgument</code> or <code>InitTaskWithStackSizeAndArgument</code>. The passed argument must be of type void*.</p>
<p dir="auto">Example:</p>
<div dir="auto" data-snippet-clipboard-copy-content="void mainThread()
{
    String *argument = new String(&#34;Hello World!&#34;);
    InitTaskWithArgument(thread2, argument);
}

void thread2(void* arg)
{
    String *argument = (String*)arg;
    delete argument;
}"><pre><span>void</span> <span>mainThread</span>()
{
    String *argument = <span>new</span> <span>String</span>(<span><span>&#34;</span>Hello World!<span>&#34;</span></span>);
    <span>InitTaskWithArgument</span>(thread2, argument);
}

<span>void</span> <span>thread2</span>(<span>void</span>* arg)
{
    String *argument = (String*)arg;
    <span>delete</span> argument;
}</pre></div>
<div id="user-content-id-kernel-tick-period" dir="auto">

<p dir="auto">The kernel tick period defines how many ticks should pass till a thread change gets initiated. 1000 ticks are 1 millisecond. So when the tick period is 1000 every millisecond a other thread gets executed. The default tick period is 2000. Keep in mind that <a href="#id-Operating-System-uptime">getElapsedMilliseconds</a> will return a wrong value if you defined a tick period that is not divisible through 1000 (1 ms). This function is used by the kernel internal which also leads to inaccurate sleep periods. In order to set the tick period pass it as 3rd argument to <code>KernelInitializer::InitializeKernel</code>.</p>
<p dir="auto">Example:</p>
<div dir="auto" data-snippet-clipboard-copy-content="void setup()
{
    KernelInitializer::InitializeKernel(mainThread, STACK_SIZE_LARGE, 2000l);
}"><pre><span>void</span> <span>setup</span>()
{
    <span>KernelInitializer::InitializeKernel</span>(mainThread, STACK_SIZE_LARGE, <span>2000l</span>);
}</pre></div>
<div id="user-content-id-hardware-abstraction" dir="auto">

<p dir="auto">In order to make it easy to use different Hardware ArduinoOS offers different abstract classes for easy usage.
Supported hardware:</p>
<ul dir="auto">
<li>LED</li>
<li>RGB-LED</li>
<li>Keypad</li>
<li>Motor</li>
<li>Piezo speaker</li>
<li>Servo</li>
</ul>
<p dir="auto">Example:</p>
<div dir="auto" data-snippet-clipboard-copy-content="#include &lt;RgbLed.h&gt;

void mainThread()
{
    RgbLed led(10, 11, 12);   // Creates a new led with the pins 10 (red), 11 (green), 12 (blue)
    led.SetRGB(50, 100, 255);
    while (true)
    {
        led.TurnOn();
        sleep(5000);
        led.TurnOff();
        sleep(5000);
    }
}"><pre>#<span>include</span> <span><span>&lt;</span>RgbLed.h<span>&gt;</span></span>

<span>void</span> <span>mainThread</span>()
{
    RgbLed <span>led</span>(<span>10</span>, <span>11</span>, <span>12</span>);   <span><span>//</span> Creates a new led with the pins 10 (red), 11 (green), 12 (blue)</span>
    led.<span>SetRGB</span>(<span>50</span>, <span>100</span>, <span>255</span>);
    <span>while</span> (<span>true</span>)
    {
        led.<span>TurnOn</span>();
        <span>sleep</span>(<span>5000</span>);
        led.<span>TurnOff</span>();
        <span>sleep</span>(<span>5000</span>);
    }
}</pre></div>
</div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div>
  </body>
</html>
