<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.scattered-thoughts.net/log/0056/">Original</a>
    <h1>0056: consulting, zest progress, existentialize, modular borrowing, do we understand sql, zjit updates, books</h1>
    
    <div id="readability-page-1" class="page"><article>
  <p>I&#39;m open for <a href="https://www.scattered-thoughts.net/consulting">consulting</a> for fall/winter/spring. Databases and query engines are most familiar but I&#39;m also spilling out into compilers. I&#39;ve had some good gigs lately doing general performance engineering too, and I think testing/fuzzing would also work well.</p>
<h2 id="zest-progress">zest progress</h2>
<p>I got really unstuck this month.</p>
<h3 id="namespaces">namespaces</h3>
<p>The decision I was been blocked on all summer was <a href="https://github.com/jamii/zest/blob/main/docs/decisions/0001-namespaces-and-imports.md">how namespaces should work</a>. I&#39;m glad I took a long time to think and talk it through because the <a href="https://github.com/jamii/zest/blob/main/docs/namespaces.md">final decision</a> ended up being very different from my initial inclinations, but now that I&#39;ve actually implemented it I can see that it was definitely the right choice. In particular, the way the internals naturally worked out ended up looking very <a href="https://github.com/jamii/zest/blob/main/docs/namespaces.md">salsa</a>-like, so I think it will be possible to build ide support in the same codebase by adding dependency tracking and evaluation timeouts.</p>
<h3 id="recursive-functions">recursive functions</h3>
<p>Namespaces also provide recursive functions. Recursive type inference isn&#39;t possible with the purely linear dataflow algorithm I&#39;m using so I had to add a tiny amount of backwards propagation. I wanted to do this only for return-type annotations on functions, but due to silly desugaring decisions I made earlier I can&#39;t actually separate those annotations from the body of the function. That is, given:</p>
<pre data-lang="zest"><code data-lang="zest"><span>is-even = (n /i64) /bool {
</span><span>  if {n == 0} true else if {n == 1} false else is-even(n - 2)
</span><span>}
</span></code></pre>
<p>I immediately desugar into:</p>
<pre data-lang="zest"><code data-lang="zest"><span>is-even = (n0) {
</span><span>  n = i64(n)
</span><span>  bool(
</span><span>    if {n == 0} true else if {n == 1} false else is-even(n - 2)
</span><span>  )
</span><span>}
</span></code></pre>
<p>Currently both of these will type-check, because I propagate information backwards from the entire body of the function to the return-type. But that can lead to type inference being quite sensitive to the details of how the function is written, or even the order in which functions are type-checked. Eg the following wouldn&#39;t type-check, because it hits the recursive call before propagating type information to the return-type:</p>
<pre data-lang="zest"><code data-lang="zest"><span>is-even = (n0) {
</span><span>  n = i64(n)
</span><span>  result = bool(
</span><span>    if {n == 0} true else if {n == 1} false else is-even(n - 2)
</span><span>  )
</span><span>  result
</span><span>}
</span></code></pre>
<p>So I want to make only the first example type-check, and for the second and third examples tell the programmer that they need to add an explicit return-type annotation. But doing that requires some annoying refactoring that I haven&#39;t gotten around to yet.</p>
<h3 id="moved-inlining">moved inlining</h3>
<p>Interpreted and compiled code have different calling conventions. The way I handle this at the moment is I generate a function with the compiled calling convention, and then also generate a wrapper function that handles the interpreter calling convention. The wrapper function then gets inlined during compilation.</p>
<p>Previously I was doing the inlining during codegen, but that caused issues with recursive type inference because there was an invisible extra function blocking the backwards propagation of return-type information. So I moved the inlining of wrapper functions into type inference instead and this ended up being much cleaner anyway.</p>
<h3 id="destination-types">destination types</h3>
<p>I added inference based on destination types - a form of bidirectional typing used heavily in zig.</p>
<pre data-lang="zest"><code data-lang="zest"><span>my-type = union[
</span><span>  a: i64,
</span><span>  b: string,
</span><span>]
</span><span>
</span><span>x /my-type = if {condition()} [a: 42] else [b: &#39;hey&#39;]
</span></code></pre>
<p>When the code above is being evaluated in the dynamically-typed interpreter and <code>condition()</code> evaluates to <code>true</code>, the expression returns the single-field struct <code>[a: 53]</code>. On assignment to <code>x</code> it is implicitly converted to <code>my-type</code>. All good.</p>
<p>But in type inference, we infer that the true branch of the expression has type <code>struct[a: i64]</code> and the false branch has type <code>struct[b: string]</code>. These two types are not compatible so an error is reported at compile time.</p>
<p>We could fix this by directly annotating the literals:</p>
<pre data-lang="zest"><code data-lang="zest"><span>x /my-type = if {condition()} [a: 42]/my-type else [b: &#39;hey&#39;]/my-type
</span></code></pre>
<p>This is effectively the solution used in rust and other ml-like languages where you have to import a type in order to use it&#39;s constructors. But instead, copying zig, during type inference we can notice that the result of the <code>if</code> expression will always be converted to <code>my-type</code> and push that conversion down through the <code>if</code> expression.</p>
<pre data-lang="zest"><code data-lang="zest"><span>// You write this code.
</span><span>x /my-type = if {condition()} [a: 42] else [b: &#39;hey&#39;]
</span><span>
</span><span>// Will be converted to this code during type inference.
</span><span>x /my-type = if {condition()} [a: 42]/my-type else [b: &#39;hey&#39;]/my-type
</span></code></pre>
<p>This is particularly nice when calling libary functions.</p>
<pre data-lang="zest"><code data-lang="zest"><span>// You write this code.
</span><span>foo([a: 42], [c: &#39;blah&#39;])
</span><span>
</span><span>// Will be converted to this code during type inference.
</span><span>my-type = %import(&#39;cool-library&#39;).my-type
</span><span>my-other-type = %import(&#39;cool-library&#39;).my-other-type
</span><span>foo([a: 42]/my-type, [c: &#39;blah&#39;]/my-other-type)
</span></code></pre>
<p>Note though that this never changes the behaviour of the program! The dynamic semantics were always going to do this conversion. But pushing the conversion down during inference allows more programs to succesfully type-check.</p>
<p>I also extended the implicit conversions to work recursively through types, so you can eg implictly convert <code>struct[x: u32]</code> to <code>struct[x: i64]</code>.</p>
<h3 id="dead-code-don-t-infer">dead code don&#39;t infer</h3>
<pre><code><span>f = (x) {
</span><span>  if %only(%repr-of(x) == i64) {
</span><span>    x + 1
</span><span>  } else {
</span><span>    x
</span><span>  }
</span><span>}
</span><span>
</span><span>f(42) // = 43
</span><span>f(&#39;foo&#39;) // = &#39;foo&#39;
</span></code></pre>
<p>Here is a silly function that adds 1 to integers, but returns values of other types unchanged. The <code>%only</code> is a (to-be-renamed) staging annotation - it says that this condition should be evaluated at compile-time.  When called with an i64 we only emit the true branch, and when called with other types we only emit the false branch.</p>
<p>I&#39;ve had that working for a while, but once I started writing real code I realized I was still type-checking both branches even though one of the results would be thrown away. In this case, this meant that <code>f(&#39;foo&#39;)</code> produced a type error for <code>string + i64</code> even though that branch is dead code.</p>
<p>I fixed that and now the function type-checks succesfully.</p>
<h3 id="iteration">iteration</h3>
<p>I&#39;ve gone for <a href="https://langdev.stackexchange.com/questions/2670/what-are-interior-iteration-and-exterior-iteration">internal iterators</a> because they work better with second-class references.</p>
<p>You can obviously iterate over lists (boring) but also over structs and unions.</p>
<pre data-lang="zest"><code data-lang="zest"><span>print-each = (x) {
</span><span>  %each(x, (i, k, v) {
</span><span>    print(%from-only(i))
</span><span>    print(&#39; = &#39;)
</span><span>    print(%from-only(k))
</span><span>    print(&#39; = &#39;)
</span><span>    print(v)
</span><span>    print(&#39;\n&#39;)
</span><span>  })
</span><span>}
</span><span>
</span><span>print-each([a: 42, b: &#39;hey&#39;])
</span><span>// prints:
</span><span>// 0 = &#39;a&#39; = 42
</span><span>// 1 = &#39;b&#39; = &#39;hey&#39;
</span><span>
</span><span>my-type = union[
</span><span>  a: i64,
</span><span>  b: string,
</span><span>]
</span><span>print-each([b: &#39;hey&#39;]/my-type)
</span><span>// prints:
</span><span>// 0 = &#39;b&#39; = &#39;hey&#39;
</span></code></pre>
<p>The IR in the interpreter is very inspired by wasm. Values are pushed and popped on the stack, which makes nested expressions very easy to handle. All other stack actions are expressed by moving values between local variables. Control flow is implicit - most instructions fall through to the next instruction. I like it.</p>
<p>But all of this made it very awkward to bake <code>%each</code> into the interpreter - it&#39;s a single instruction that contains backwards-branching control flow and makes function calls. But I didn&#39;t want to pay the (mostly type-check related) overhead of desugaring it into an actual loop with several variables and a dynamic field lookup.</p>
<p>My first pass at this required a bunch of ugly special cases spread through the interpreter, and when I came back to it a month later I couldn&#39;t remember how anything worked. My second approach was much nicer. I desugar into three consecutive instructions - <code>each_begin</code>, <code>each_body</code>, <code>each_end</code> - each of which only cost one byte in the IR. Execution goes like this:</p>
<ul>
<li>We start with <code>obj, fun</code> on the stack.</li>
<li><code>each_begin</code> adds the loop index <code>0</code> to the stack.</li>
<li><code>each_body</code>
<ul>
<li>Pops <code>obj, fun, index</code> from the stack.</li>
<li>If <code>index &gt; obj.len</code>, jumps to the instruction after <code>each_end</code>.</li>
<li>Puts <code>obj, fun, index+1, index, obj[index].key, obj[index].val</code> on the stack.</li>
<li>Calls <code>fun</code>.</li>
</ul>
</li>
<li><code>fun</code> returns to <code>each_end</code>.</li>
<li><code>each_end</code> jumps to <code>each_body</code>.</li>
</ul>
<p>I also switched <code>while</code> loops to a similar scheme.</p>
<h3 id="enforce-purity">enforce purity</h3>
<p>Anything that is evaluated at compile-time is not allowed to perform observable side-effects. I got around to actually enforcing this.</p>
<pre data-lang="zest"><code data-lang="zest"><span>namespace{
</span><span>  x = print(&#39;foo&#39;)
</span><span>}
</span><span>// Error: Tried to perform a side effect during pure evaluation: zest.Builtin.print
</span></code></pre>
<h3 id="self-hosted-runtime">self-hosted runtime</h3>
<p>To avoid having to duplicate a lot of functionality between the interpreter and compiler, I&#39;ve long planned to have a lot of the zest runtime be implemented in zest (swift and go both take this approach too). I&#39;m now actually loading the <a href="https://github.com/jamii/zest/blob/main/lib/runtime.zest">runtime</a> and making calls to it.</p>
<p>This required some replumbing because up until now all my code assumed that there was only a single source file to evaluate. Fortunately, the code is all written in a very <a href="https://www.dataorienteddesign.com/dodmain/">data-oriented</a> style, so the change was mostly just adding an extra id to a bunch of map lookups.</p>
<h3 id="list-and-any"><code>list</code> and <code>any</code></h3>
<p>Lists are created by conversion from structs.</p>
<pre data-lang="zest"><code data-lang="zest"><span>[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] /list[string]
</span></code></pre>
<p>They don&#39;t offer much else yet apart from iteration.</p>
<p>The <code>any</code> type offers type-erasure:</p>
<pre data-lang="zest"><code data-lang="zest"><span>things /list[any] = [42, &#39;foo&#39;, [a: 1, b: 2]]
</span><span>
</span><span>things.0 // = 42/any
</span><span>%repr-of(things.0) // = any
</span><span>%from-any(things.0) // = 42
</span><span>%repr-of(%from-any(things.0)) // = i64
</span></code></pre>
<p>While you can use <code>any</code> in typed code, it&#39;s obviously impossible to use <code>%from-any</code> because we can&#39;t know the return type. I plan to also add typed versions, so that all of the below would type-check:</p>
<pre><code><span>%repr-of-any(things.0) // = i64
</span><span>%from-any(things.0, type: i64) // = 42
</span><span>%from-any(things.0, type: string) // panics
</span></code></pre>
<h3 id="reflection">reflection</h3>
<p>I initially blindly copied the design of reflection from zig&#39;s TypeInfo. The builtin function <code>%reflect</code> would return a description of a type:</p>
<pre data-lang="zest"><code data-lang="zest"><span>// This must be in the same order as Repr
</span><span>reflection = union[
</span><span>  u32: struct[],
</span><span>  i64: struct[],
</span><span>  string: struct[],
</span><span>  struct: reflection-struct,
</span><span>  // etc...
</span><span>]
</span><span>
</span><span>reflection-struct = struct[
</span><span>  keys: list[any],
</span><span>  values: list[repr],
</span><span>]
</span></code></pre>
<p>For example:</p>
<pre data-lang="zest"><code data-lang="zest"><span>%reflect(struct[a: i64, b: string])
</span><span>
</span><span>// evaluates to:
</span><span>
</span><span>[&#39;struct&#39;: [
</span><span>  keys: [&#39;a&#39;, &#39;b&#39;] /list[any],
</span><span>  values: [i64, string] /list[repr],
</span><span>]]
</span></code></pre>
<p>This is why I added <code>list</code> and <code>any</code> this month! I thought I needed them.</p>
<p>In zig you could write a generic print function using reflection like this (slightly simplified):</p>
<pre data-lang="zig"><code data-lang="zig"><span>fun </span><span>print</span><span>(thing</span><span>:</span><span> anytype) </span><span>void </span><span>{
</span><span>    </span><span>switch </span><span>(</span><span>@typeInfo</span><span>(</span><span>@TypeOf</span><span>(thing))) {
</span><span>        .Struct </span><span>=&gt; |</span><span>sti</span><span>| </span><span>{
</span><span>            </span><span>printString</span><span>(</span><span>&#34;{&#34;</span><span>)</span><span>;
</span><span>            </span><span>inline for </span><span>(sti.fields</span><span>,</span><span> 0</span><span>..</span><span>) </span><span>|</span><span>field</span><span>,</span><span> ix</span><span>| </span><span>{
</span><span>                </span><span>if </span><span>(ix </span><span>!= </span><span>0</span><span>)  </span><span>printString</span><span>(</span><span>&#34;, &#34;</span><span>)</span><span>;
</span><span>                </span><span>printString</span><span>(</span><span>&#34;.&#34;</span><span>)</span><span>;
</span><span>                </span><span>printString</span><span>(field.name)</span><span>;
</span><span>                </span><span>printString</span><span>(</span><span>&#34; = &#34;</span><span>)</span><span>;
</span><span>                </span><span>print</span><span>(</span><span>@field</span><span>(thing</span><span>,</span><span> field.name))</span><span>;
</span><span>            }
</span><span>            </span><span>printString</span><span>(</span><span>&#34;}&#34;</span><span>)</span><span>;
</span><span>        }</span><span>,
</span><span>        </span><span>// etc...
</span><span>    }
</span><span>}
</span></code></pre>
<p>The equivalent code in zest (minus a bunch of annoying manual staging annotations) looked like:</p>
<pre data-lang="zest"><code data-lang="zest"><span>print = (x) {
</span><span>  t = %reflect(%repr-of(x))
</span><span>  if %union-has-key(t, &#39;struct&#39;) {
</span><span>    %print(&#39;[&#39;)
</span><span>    %each(t.struct.keys, (ix, _, key) {
</span><span>      if {ix != 0} %print(&#39;, &#39;)
</span><span>      print(%from-any(key))
</span><span>      %print(&#39;: &#39;)
</span><span>      print(x.{%from-any(key)})
</span><span>    })
</span><span>    %print(&#39;]&#39;)
</span><span>  } else {
</span><span>    // etc...
</span><span>  }
</span><span>}
</span></code></pre>
<p>But after writing a bunch of code in this style I decided that the whole <code>reflection</code> type feels like an unnecessary indirection. I wanted to stay closer to the ideal of <a href="https://www.scattered-thoughts.net/writing/the-shape-of-data/">thinking with syntax</a>.</p>
<p>One big difference between zig and zest is that in zig <code>struct</code> is just syntax, but in zest <code>struct</code> is a value in it&#39;s own right. And we can also iterate over structs directly, without needing a list of keys. So if we have a type like <code>struct[a: i64, b: string]</code> we can just skip the reflection entirely. All we need is a way to get at the individual pieces of the type:</p>
<pre><code><span>%unmake(struct[a: i64, b: string])
</span><span>
</span><span>// evaluates to
</span><span>[
</span><span>  struct,
</span><span>  [a: i64, b: string],
</span><span>]
</span></code></pre>
<p>Now the printing code (minus a bunch of annoying manual staging annotations) looks like:</p>
<pre data-lang="zest"><code data-lang="zest"><span>print = (x) {
</span><span>  [head, args] = %unmake(%repr-of(x))
</span><span>  if {head == struct} {
</span><span>    %print(&#39;[&#39;)
</span><span>    %each(x, (ix, key, value) {
</span><span>      if {ix != 0} %print(&#39;, &#39;)
</span><span>      print-key(key)
</span><span>      %print(&#39;: &#39;)
</span><span>      print(value)
</span><span>    })
</span><span>    %print(&#39;]&#39;)
</span><span>  } else {
</span><span>    // etc...
</span><span>  }
</span><span>}
</span></code></pre>
<p>Printing types is also easy because the arguments to type constructors are just regular structs:</p>
<pre data-lang="zest"><code data-lang="zest"><span>print-repr = (t) {
</span><span>  [head, args] = %unmake(t)
</span><span>  if {head == struct} {
</span><span>    %print(&#39;struct&#39;)
</span><span>  } else {
</span><span>    // etc...
</span><span>  }
</span><span>  print(args)
</span><span>}
</span></code></pre>
<p>This kind of parsimony of concepts make me feel like I&#39;m on the right track.</p>
<p>I do eventually want to have pattern matching, so the printing code would look even more direct, and we&#39;d get exhaustiveness checking too:</p>
<pre data-lang="zest"><code data-lang="zest"><span>print = (x) {
</span><span>  match(%repr-of(x),
</span><span>    (struct[..args]) {
</span><span>      %print(&#39;[&#39;)
</span><span>      %each(x, (ix, key, value) {
</span><span>        if {ix != 0} %print(&#39;, &#39;)
</span><span>        print-key(key)
</span><span>        %print(&#39;: &#39;)
</span><span>        print(value)
</span><span>      })
</span><span>      %print(&#39;]&#39;)
</span><span>    },
</span><span>    // etc...
</span><span>  )
</span><span>}
</span><span>
</span><span>print-repr = (t) {
</span><span>  match(t,
</span><span>    (struct[..args]) {
</span><span>      %print(&#39;struct&#39;)
</span><span>      print(args)
</span><span>    },
</span><span>    // etc...
</span><span>  )
</span><span>}
</span></code></pre>
<h3 id="function-namespace-validation-stubs">function/namespace validation stubs</h3>
<p>One of the ideals of zest is that any value can be printed and read back in to produce an equal value.</p>
<pre data-lang="zest"><code data-lang="zest"><span>f = (a) (b) a + b
</span><span>g = f(1)
</span><span>
</span><span>g
</span><span>// [a: 1]/fun[42, a: i64]
</span><span>
</span><span>to-string(g)
</span><span>// &#39;[a: 1]/fun[42, a: i64]`
</span><span>
</span><span>read(to-string(g))
</span><span>// [a: 1]/fun[42, a: i64]
</span><span>
</span><span>g == read(to-string(g))
</span><span>// true
</span></code></pre>
<p>But what if I make up an invalid function and then call it:</p>
<pre data-lang="zest"><code data-lang="zest"><span>h = read(&#39;[b: 1]/fun[99999, c: string]&#39;)
</span><span>h()
</span></code></pre>
<p>It&#39;s tempting to say that the call to <code>read</code> should throw an error, but then we can&#39;t read and manipulate data printed by other programs. So it has to be the call <code>h()</code> that throws the error. But then do we have to validate every function on every call? That would be expensive.</p>
<p>My solution for now is to add a bit to the function type tracking whether it is valid/unknown. When calling a function in dynamically-typed, if the bit is set to unknown then we do the validation. If validation succeeds, we set the bit to valid. If validation fails, we throw an error. (We don&#39;t set the bit to invalid, because we might later load the code needed for that function and try to call it again).</p>
<p>At compile-time we know the types of functions so we can do the validation immediately and then not need to check the bit at runtime in compiled code.</p>
<p>The actual validation code currently is just <code>panic(&#34;TODO&#34;)</code> because I don&#39;t actually need it yet, I just needed to make sure I had a solution.</p>
<p>You&#39;ll also notice at the moment I&#39;m using consecutive integer ids for functions (<code>fun[42, ...]</code>), which is obviously not going to work great when copying data between different programs. But I think I have a scheme worked out that allows using content-addressed hashes instead, that guarantees (up to cryptographic hash collision) that functions with the same type have the same code, while also preserving lazy compilation/imports/tree-shaking.</p>
<h3 id="printing">printing</h3>
<p>All of the features above were in service of being able to write a generic print function in the runtime, where all the reflection is staged away at compile-time. Behold it in all of it&#39;s work-in-progress glory:</p>
<pre data-lang="zest"><code data-lang="zest"><span>print = (x) {
</span><span>    if %only(%repr-of(x) == u32) {
</span><span>        %print(x)
</span><span>        %print(&#39;/u32&#39;)
</span><span>    } else if %only(%repr-of(x) == i64) {
</span><span>        %print(x)
</span><span>    } else if %only(%repr-of(x) == string) {
</span><span>        %print(&#39;\&#39;&#39;)
</span><span>        // TODO escape
</span><span>        %print(x)
</span><span>        %print(&#39;\&#39;&#39;)
</span><span>    } else if %only(%repr-of(x) == any) {
</span><span>        // TODO Need to be able to jump back into interpreter for unknown types.
</span><span>        %print(&#39;TODO/any&#39;)
</span><span>    } else {
</span><span>        unmade = %only(%unmake(%repr-of(x)))
</span><span>        head = %only(%from-only(unmade).0)
</span><span>        args = %only(%from-only(unmade).1)
</span><span>        if %only(%from-only(head) == struct) {
</span><span>            %print(&#39;[&#39;)
</span><span>            positional mut = 1
</span><span>            %each(x, (ix, key, value) {
</span><span>                if %only(%from-only(ix) &gt; 0) %print(&#39;, &#39;)
</span><span>                if %only(%from-only(key) != %from-only(ix)) { positional@ = 0 }
</span><span>                if {positional == 0} {
</span><span>                    print-key(%from-only(key))
</span><span>                    %print(&#39;: &#39;)
</span><span>                }
</span><span>                print(value)
</span><span>            })
</span><span>            %print(&#39;]&#39;)
</span><span>        } else if %only(%from-only(head) == union) {
</span><span>            %print(&#39;[&#39;)
</span><span>            %each(x, (ix, key, value) {
</span><span>                if %only(%from-only(key) != 0) {
</span><span>                    print-key(%from-only(key))
</span><span>                    %print(&#39;: &#39;)
</span><span>                }
</span><span>                print(value)
</span><span>            })
</span><span>            %print(&#39;]/&#39;)
</span><span>            print-repr(%only(%repr-of(x)))
</span><span>        } else if %only(%from-only(head) == list) {
</span><span>            %print(&#39;[TODO]/&#39;)
</span><span>            print-repr(%only(%repr-of(x)))
</span><span>        } else if %only(%from-only(head) == fun) {
</span><span>            print(%closure(x))
</span><span>            %print(&#39;/&#39;)
</span><span>            print-repr(%only(%repr-of(x)))
</span><span>        } else if %only(%from-only(head) == namespace) {
</span><span>            print(%closure(x))
</span><span>            %print(&#39;/&#39;)
</span><span>            print-repr(%only(%repr-of(x)))
</span><span>        } else if %only(%from-only(head) == only) {
</span><span>            %print(&#39;%only(&#39;)
</span><span>            print(%from-only(x))
</span><span>            %print(&#39;)&#39;)
</span><span>        } else {
</span><span>            %print(&#39;TODO/&#39;)
</span><span>            print-repr(%only(%repr-of(x)))
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span>print-repr = (x) {
</span><span>    if %only(%from-only(x) == u32) {
</span><span>        %print(&#39;u32&#39;)
</span><span>    } else if %only(%from-only(x) == i64) {
</span><span>        %print(&#39;i64&#39;)
</span><span>    } else if %only(%from-only(x) == string) {
</span><span>        %print(&#39;string&#39;)
</span><span>    } else if %only(%from-only(x) == any) {
</span><span>        %print(&#39;any&#39;)
</span><span>    } else if %only(%from-only(x) == repr) {
</span><span>        %print(&#39;repr&#39;)
</span><span>    } else if %only(%repr-of(x) == repr-kind) {
</span><span>        print-repr-kind(%only(x))
</span><span>    } else {
</span><span>        unmade = %only(%unmake(%from-only(x)))
</span><span>        head = %only(%from-only(unmade).0)
</span><span>        args = %only(%from-only(unmade).1)
</span><span>        print-repr-kind(head)
</span><span>        %print(&#39;[&#39;)
</span><span>        positional mut = 1
</span><span>        %each(args, (ix, key, value) {
</span><span>            if %only(%from-only(ix) &gt; 0) %print(&#39;, &#39;)
</span><span>            if %only(%from-only(key) != %from-only(ix)) { positional@ = 0 }
</span><span>            if {positional == 0} {
</span><span>                print-key(%from-only(key))
</span><span>                %print(&#39;: &#39;)
</span><span>            }
</span><span>            if %only(%repr-of(%from-only(value)) == repr) {
</span><span>                print-repr(value)
</span><span>            } else {
</span><span>                print(%from-only(value))
</span><span>            }
</span><span>        })
</span><span>        %print(&#39;]&#39;)
</span><span>    }
</span><span>}
</span><span>
</span><span>print-repr-kind = (x) {
</span><span>    if %only(%from-only(x) == struct) {
</span><span>        %print(&#39;struct&#39;)
</span><span>    } else if %only(%from-only(x) == union) {
</span><span>        %print(&#39;union&#39;)
</span><span>    } else if %only(%from-only(x) == list) {
</span><span>        %print(&#39;list&#39;)
</span><span>    } else if %only(%from-only(x) == fun) {
</span><span>        %print(&#39;fun&#39;)
</span><span>    } else if %only(%from-only(x) == namespace) {
</span><span>        %print(&#39;namespace&#39;)
</span><span>    } else if %only(%from-only(x) == only) {
</span><span>        %print(&#39;only&#39;)
</span><span>    } else {
</span><span>        panic(&#39;Unreachable&#39;)
</span><span>    }
</span><span>}
</span><span>
</span><span>print-key = (key) {
</span><span>    // TODO If key is a valid name then omit the quotes.
</span><span>    print(key)
</span><span>}
</span></code></pre>
<p>Everything boils down to <code>%print</code>, which is a builtin function that can only print strings and integers. It&#39;s injected into the compiled wasm by the javascript host:</p>
<pre data-lang="javascript"><code data-lang="javascript"><span>let </span><span>wasmInstance</span><span>;
</span><span>try </span><span>{
</span><span>  wasmInstance </span><span>= new </span><span>WebAssembly</span><span>.</span><span>Instance</span><span>(wasmModule</span><span>, </span><span>{
</span><span>    env</span><span>: </span><span>{
</span><span>      </span><span>print_u32</span><span>: </span><span>function </span><span>(</span><span>u32</span><span>) {
</span><span>        </span><span>var </span><span>enc </span><span>= new </span><span>TextEncoder</span><span>()</span><span>;
</span><span>        </span><span>writeAllSync</span><span>(Deno</span><span>.</span><span>stdout</span><span>, </span><span>enc</span><span>.</span><span>encode</span><span>(u32</span><span>.</span><span>toString</span><span>()))</span><span>;
</span><span>      }</span><span>,
</span><span>      </span><span>print_i64</span><span>: </span><span>function </span><span>(</span><span>i64</span><span>) {
</span><span>        </span><span>var </span><span>enc </span><span>= new </span><span>TextEncoder</span><span>()</span><span>;
</span><span>        </span><span>writeAllSync</span><span>(Deno</span><span>.</span><span>stdout</span><span>, </span><span>enc</span><span>.</span><span>encode</span><span>(i64</span><span>.</span><span>toString</span><span>()))</span><span>;
</span><span>      }</span><span>,
</span><span>      </span><span>print_string</span><span>: </span><span>function </span><span>(</span><span>ptr</span><span>, </span><span>len</span><span>) {
</span><span>        </span><span>let </span><span>str </span><span>= new </span><span>Uint8Array</span><span>(memory</span><span>.</span><span>buffer</span><span>, </span><span>ptr</span><span>, </span><span>len)</span><span>;
</span><span>        </span><span>writeAllSync</span><span>(Deno</span><span>.</span><span>stdout</span><span>, </span><span>str)</span><span>;
</span><span>      }</span><span>,
</span><span>    }</span><span>,
</span><span>  })</span><span>;
</span><span>} </span><span>catch </span><span>(error) {
</span><span>  </span><span>console</span><span>.</span><span>error</span><span>(error)</span><span>;
</span><span>}
</span></code></pre>
<p>If we call <code>print(42)</code>, all the reflection and staging compiles away and the remaining code is just:</p>
<pre data-lang="wat"><code data-lang="wat"><span>  (import &#34;env&#34; &#34;print_string&#34; (func (;2;) (type 3)))
</span><span>  (func (;6;) (type 2) (param i64)
</span><span>    (call 1
</span><span>      (local.get 0)))
</span></code></pre>
<p>Now that I have printing working in compiled code I can finally write tests that return non-integer values. It&#39;s starting to feel like an actual language!</p>
<h3 id="next">next</h3>
<p>Everything has been building towards printing for a while. Now that it&#39;s done I haven&#39;t decided yet what to work on next. But there are some obvious candidates.</p>
<h3 id="next-staging">next = staging?</h3>
<p>I wasn&#39;t sure how I wanted the developer experience of staging to feel, so for now I left it all manually annotated (<code>%only</code> and <code>%from-only</code>).</p>
<p>I also wanted to make sure that it fit smoothly into type inference rather than being a separate, parallel system (like rust&#39;s many type systems). So I implemented staging in terms of first-class values. <code>%only(1 + 1)</code> returns a value of type <code>only[2]</code>, a type which is only inhabited by the value <code>2</code> and whose runtime representation is zero-sized.</p>
<p>For mutable references I took the same approach. References are created with <code>@</code> and have type <code>ref[T]</code>. But you can never write code that observes these types, because during desugaring I automatically insert <code>%from-ref</code> around any expression that doesn&#39;t use the value mutably. We know at desugaring time which variables are <code>ref</code>s because they have to be annotated with <code>mut</code> or <code>ref</code> (depending on whether you are creating a new mutable location or assigning a new name to an existing location).</p>
<p>Having written some amount of staged code now, I think the exact same pattern would work for <code>only</code>. Variables that are known at compile-time would have to be annotated with <code>only</code> (or <code>const</code> or <code>#</code> or whatever, I haven&#39;t thought of a satisfying name/syntax yet). Expressions wrapped in <code>only{...}</code> would be evaluated at compile-time. Whenever an expression of type <code>only</code> is used in a non-<code>only</code> context, we would wrap it in <code>%from-only</code> during desugaring. Except in function calls, where <code>foo(only{...})</code> would pass the staged value to <code>foo</code> where it would either be used or unwrapped depending on how the parameters of <code>foo</code> are annotated (<code>foo = (x only) ...</code> vs <code>foo = (x) ...</code>).</p>
<p>It&#39;s always reassuring to see that same patterns come up for different subsystems.</p>
<p>A nice side-effect of this is that iterators can offer staged values and callees can decide whether they want to use them. Eg in <code>%each(thing, (i, k only, v) ...)</code> if <code>thing</code> is a big struct with type <code>[a: string, b: string, c: string, etc...]</code> then we&#39;ll we get specializations for the callee <code>[i: i64, k: only[a], v: string]</code>, <code>[i: i64, k: only[b], v: string]</code>, <code>[i: i64, k: only[c], v: string]</code> etc. But if we don&#39;t need the key to be a staged value then we can instead write <code>%each(thing, (i, k, v) ...)</code> and just get the one specialization <code>[i: i64, k: string, v: string]</code>.</p>
<p>One open question is whether I want to allow writing functions that behave differently depending on whether or not their arguments are staged? For example, for the builtin <code>%each(thing, (i, k, v) ...)</code>, if <code>thing</code> is a struct then <code>v</code> is a regular value, but if <code>thing</code> is a staged struct then <code>v</code> is a staged value. Maybe programmers will want to have the ability to write functions like that themselves. We could do this by adding an annotation <code>only?</code> that doesn&#39;t unwrap staged values, but also doesn&#39;t required them. But it&#39;s not clear how we&#39;d then write the body of the function. Do we write <code>only?{...}</code> in the body to indicate evaluating at compile-time if possible? Or do we have to write two different versions of the body? Needs some real examples to work with...</p>
<h3 id="next-allocation">next = allocation?</h3>
<p>At the moment there is no way to allocate new heap values in zest. (The only <code>list</code> values are ones that are baked into the executable during compile-time evaluation.)</p>
<p>I have an allocator in the runtime, and unsafe <code>%load</code> and <code>%store</code> primitives to touch memory. So I can build up lists and maps etc.</p>
<p>But I haven&#39;t figured out the rules for reference-counting yet.</p>
<p>I know that I don&#39;t want to increment refcounts on every use of a variable - that&#39;s expensive. But I also want the costs to be easily understandable from just looking at the code, which is in tension with the fancy schemes in languages like in <a href="https://xnning.github.io/papers/perceus.pdf">koka</a> or <a href="https://arxiv.org/pdf/1908.05647">lean</a>.</p>
<p>Also, unlike koka and lean, I have mutable references. I guarantee that anything pointed to by a mutable reference has refcount 1, so I need to be careful that maintaining that guarantee doesn&#39;t lead to surprising expenses.</p>
<p>I have an intuition that below is a reasonable set of rules, but I haven&#39;t put any effort into disproving it yet:</p>
<ul>
<li>
<ol>
<li>Whenever copying a value from a immutable location <em>higher</em> on the stack to an immutable location <em>lower</em> on the stack, &#39;lend&#39; the value (shallow copy).</li>
</ol>
</li>
<li>
<ol start="2">
<li>Whenever copying a value otherwise, &#39;share&#39; the value (shallow copy and increment refcounts for all pointers).</li>
</ol>
</li>
<li>3a) Whenever obtaining a mutable reference to the interior of a reference-counted value (eg <code>ref = value[i]@</code> ), &#39;steal&#39; the value first (if the refcount of the heap allocation is &gt;1 then copy the heap allocation).</li>
<li>3b) Whenever assigning a value to a mutable reference (eg <code>ref@ = value</code> ), &#39;steal&#39; the value first (if the refcount of the heap allocation is &gt;1 then copy the heap allocation).</li>
</ul>
<p>Rule 1 is important because it avoids the accidental copies of big structs that are a constant source of performance drag in zig and go.</p>
<p>I think that either 3a or 3b are sufficient to maintain the aliasing rules. But neither is optimal. Consider <code>list[i]@ = elem</code>. If <code>elem</code> is a non-reference-counted type (eg i64) then 3a has to do a refcount check whereas 3b has no overhead. But if <code>elem</code> is a reference-counted type (eg string) then 3b makes a copy of the string even if we never want to mutate it whereas 3a allows sharing the string.</p>
<p>Swift has some optimizations around 3a eg it will hoist the check out of a loop so it only happens once. But this is a) potentially fragile/non-obvious and b) doesn&#39;t pair well with internal iterators (ie where the loop body is in a different function).</p>
<p>Another complication is that I have equivalents of zigs PRO (pass function arguments by reference rather than by value) and RLS (in <code>x = foo()</code> pass a pointer to <code>x</code> as an argument to foo and write directly to it). (In zig the combination of the two is <a href="https://ziggit.dev/t/sycl-2023-attack-of-the-killer-features-by-martin-wickham/1306">dangerous</a>, but in zest I have alias tracking so I can statically prevent dangerous combinations.) This means that in function calls, I don&#39;t even want a shallow copy but instead just a pointer.</p>
<h2 id="existentialize-your-generics"><a href="https://dl.acm.org/doi/pdf/10.1145/3759426.3760975">Existentialize Your Generics</a></h2>
<p>Java-style generic erasure requires universal layouts, which causes a lot of indirection and memory overhead. Rust-style monomorphization allows type-specific layouts, but generates a lot of code, requires knowing all possible combinations of types at runtime, and cannot provide separate compilation.</p>
<p>Swift (at abi boundaries) use dictionary passing. This preserves separate compilaton without requiring universal layout. The paper has the tiniest possible evaluation of the performance cost vs monomorphization. It doesn&#39;t really feel informative.</p>
<h2 id="a-lightweight-type-and-effect-system-for-invalidation-safety"><a href="https://dl.acm.org/doi/pdf/10.1145/3763144">A Lightweight Type-and-Effect System for Invalidation Safety</a></h2>
<p>They&#39;ve developed a type system which can express (and infer) union/intersection/negation types. By adding effects, they can use negations to express carveouts in generic effects like &#39;this function may perform any effect except IO&#39;. By adding unique nominal types to each variable and adding those types to the effects of expressions that use those variables, they can express invalidation - &#39;this function may perform any effect <em>except</em> using the variable x&#39;. Any value that leaves a variables scope gets upcast to a type that doesn&#39;t include the variable effect - this can be used to prevent stack-allocated values escaping.</p>
<p>The result is they get a lot of the benefits of a rust-like borrowing system, but they built it out of type system features they were already using elsewhere. I&#39;m not fluent enough in type systems to be able to figure out if there are rough corners that they&#39;re not mentioning, but I am a sucker for parsimony of concepts.</p>
<h2 id="do-we-understand-sql"><a href="https://youtu.be/qiVUf9X6ItM?t=4357">Do we understand SQL?</a></h2>
<p>I just can&#39;t resist. Even more weird inconsistencies that I haven&#39;t thought of before.</p>
<h2 id="zjit-building-a-new-jit-compiler-for-ruby"><a href="https://www.youtube.com/watch?v=zPrSG2e10Ig">ZJIT: Building a New JIT Compiler for Ruby</a></h2>
<p>This mostly isn&#39;t new information if you&#39;ve been following zjit, but I was surprised that part of the motivation for zjit vs yjit was that compiling per method rather than per basic block means storing way less metadata, which means that your metadata isn&#39;t under so much pressure to be minimal/lossy.</p>
<h2 id="books">books</h2>
<p><a href="https://www.goodreads.com/book/show/56269147-dirtbag">Dirtbag: Essays</a>. I thought it would be an insight into the Bernie Sanders campaign. Instead it&#39;s 90% complaining about random people she worked with in the past and 10% celebrating her favorite twitter dunks.</p>
<p><a href="https://www.goodreads.com/book/show/20821304-rethinking-positive-thinking">Rethinking Positive Thinking: Inside the New Science of Motivation</a>. Scientists once did an experiment and you too can over-generalize from this blah blah blah...</p>
<p><a href="https://www.goodreads.com/book/show/59386092-the-path-of-aliveness">The Path of Aliveness: A Contemporary Zen Approach to Awakening Body and Mind</a>. I really wanted to finish reading this but it&#39;s all</p>
<blockquote>
<p>Water stands for emptiness. Conceptually, emptiness means activity, interdependence, and nonself. Each observable thing is the temporary manifestation of an undivided activity and not a self-same entity separate from other self-same entities. Conventionally we can speak of things, but ultimately they do not exist in the way our convention suggests. And our own self is no exception. Whatever I determine about myself in this moment may seem real and relevant, but it is only so in an ungraspable wave-like fashion.</p>
</blockquote>
<p>and there are only so many hours that I can spend being beaten over the head with the revelation that we don&#39;t have direct access to reality and that categories are an approximation before I start to wonder if the book has literally any other point to make.</p>

</article></div>
  </body>
</html>
