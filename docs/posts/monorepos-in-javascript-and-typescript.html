<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.robinwieruch.de/javascript-monorepos/">Original</a>
    <h1>Monorepos in JavaScript and TypeScript</h1>
    
    <div id="readability-page-1" class="page"><div itemscope="" itemprop="mainContentOfPage"><section itemscope="" itemtype="http://schema.org/Article"><meta itemprop="mainEntityOfPage" content="https://www.robinwieruch.de/javascript-monorepos/"/><article itemprop="articleBody"><p>This is a comprehensive tutorial on Monorepos in JavaScript/TypeScript --- which is using state of the art tools for these kind of architectures in frontend applications. You will learn about the following topics from this tutorial:</p><ul><li>What is a monorepo?</li><li>How to structure a monorepo architecture?</li><li>How to create a monorepo?</li><li>Which tools to use for a monorepo?</li><li>How to perform versioning in a monorepo?</li><li>How to create a CI pipeline for a monorepo?</li><li>How to run applications decoupled from the monorepo?</li></ul><p>I myself am extremely hyped about Monorepos these days, because they help me with my work as a freelance developer and my open source projects. When I started to use monorepos in JavaScript/TypeScript I must say it just felt natural to combine applications and packages this way. With this walkthrough, I hope to pass along my learnings in this space.</p><p><em>Shoutout to <!-- --><a href="https://twitter.com/leeerob" target="_blank" rel="noopener noreferrer">Lee Robinson</a> who inspired and <!-- --><a href="https://github.com/vercel/turborepo/tree/main/examples/design-system" target="_blank" rel="noopener noreferrer">helped</a> me tremendously to get started in this space. Another shoutout goes to <!-- --><a href="https://twitter.com/swyx" target="_blank" rel="noopener noreferrer">Shawn &#34;Swyx&#34; Wang</a> who made me aware of <!-- --><a href="https://www.swyx.io/turborepo-why" target="_blank" rel="noopener noreferrer">Turborepo</a> and to <!-- --><a href="https://twitter.com/wesbos" target="_blank" rel="noopener noreferrer">Wes Bos</a> &amp; <!-- --><a href="https://twitter.com/stolinski" target="_blank" rel="noopener noreferrer">Scott Tolinski</a> who had an <!-- --><a href="https://syntax.fm/show/426/monorepos-workspaces-pnpm-turborepo-more" target="_blank" rel="noopener noreferrer">episode</a> on SyntaxFM about Monorepos.<!-- --></em></p><p>When this tutorial becomes more practical, we will use React.js as framework of choice for creating applications and shared packages (UI components) within this monorepo. However, feel free to use your own framework of choice (e.g. Angular or Vue).</p><h2 id="table-of-contents"><a href="#table-of-contents" target="_blank" rel="noopener noreferrer" aria-label="table of contents permalink"><svg height="0" width="0"></svg></a>Table of Contents<!-- --></h2><ul><li><a href="#what-is-a-monorepo">What is a Monorepo</a></li><li><a href="#why-use-a-monorepo">Why use a Monorepo</a></li><li><a href="#structure-of-a-monorepo">Structure of a Monorepo</a></li><li><a href="#how-to-create-a-monorepo">How to create a Monorepo</a></li><li><a href="#workspaces-in-monorepos">Workspaces in Monorepos</a></li><li><a href="#monorepo-tools">Monorepo Tools</a></li><li><a href="#documentation-in-monorepos">Documentation in Monorepos</a></li><li><a href="#monorepos-vs-polyrepos-in-git">Monorepos vs Polyrepos in Git</a></li><li><a href="#versioning-with-monorepos">Versioning with Monorepos</a></li><li><a href="#continuous-integration-with-monorepos">Continuous Integration with Monorepos</a></li><li><a href="#monorepo-architecture">Monorepo Architecture</a></li><li><a href="#example-monorepos-as-incubators">Example: Monorepos as Incubators</a></li><li><a href="#monorepo-faq">Monorepo FAQ</a></li></ul><h2 id="what-is-a-monorepo"><a href="#what-is-a-monorepo" target="_blank" rel="noopener noreferrer" aria-label="what is a monorepo permalink"><svg height="0" width="0"></svg></a>What is a Monorepo<!-- --></h2><p>A monorepo is a project which contains smaller projects -- whereas each project can be anything from individual application to reusable package (e.g. functions, components). The practice of combining projects dates back to the early 2000 when it was called a <!-- --><em>shared codebase</em>.<!-- --></p><p>The name monorepo stems from the words mono (single) and repo (<!-- --><a href="https://en.wikipedia.org/wiki/Repository_(version_control)" target="_blank" rel="noopener noreferrer">repository</a>). While the former is self-explanatory, the latter comes from version control systems (e.g. git) where either projects:repositories are hosted in a n:n relationship (polyrepo) or a n:1 relationship (monorepo).<!-- --></p><p>Often a monorepo is mistaken for a monolith. However, in a monolithic application all smaller projects are combined into one large project. In contrast, a monorepo can combine its smaller projects into multiple projects.</p><p><span>
      <!-- --><span></span>
  <!-- --><picture>
          <!-- --><source srcset="/static/9de5ad46d31b733396ec808c0e4fadd8/f4e34/monorepo-monolith.webp 256w,/static/9de5ad46d31b733396ec808c0e4fadd8/bd5dd/monorepo-monolith.webp 512w,/static/9de5ad46d31b733396ec808c0e4fadd8/a9a89/monorepo-monolith.webp 1024w,/static/9de5ad46d31b733396ec808c0e4fadd8/e0593/monorepo-monolith.webp 1418w" sizes="(max-width: 1024px) 100vw, 1024px" type="image/webp"/>
          <!-- --><source srcset="/static/9de5ad46d31b733396ec808c0e4fadd8/6f3f2/monorepo-monolith.png 256w,/static/9de5ad46d31b733396ec808c0e4fadd8/01e7c/monorepo-monolith.png 512w,/static/9de5ad46d31b733396ec808c0e4fadd8/2bef9/monorepo-monolith.png 1024w,/static/9de5ad46d31b733396ec808c0e4fadd8/bb543/monorepo-monolith.png 1418w" sizes="(max-width: 1024px) 100vw, 1024px" type="image/png"/>
          <!-- --><img src="https://www.robinwieruch.de/static/9de5ad46d31b733396ec808c0e4fadd8/2bef9/monorepo-monolith.png" alt="monorepo monolith" title="monorepo monolith" loading="lazy" decoding="async"/>
        <!-- --></picture>
    <!-- --></span></p><p>Monorepos are popular for large scale codebases used by large companies such as <!-- --><a href="https://cacm.acm.org/magazines/2016/7/204032-why-google-stores-billions-of-lines-of-code-in-a-single-repository/fulltext" target="_blank" rel="noopener noreferrer">Google</a>:<!-- --></p><ul><li><em>&#34;The Google codebase includes approximately one billion files and has a history of approximately 35 million commits spanning Google&#39;s entire 18-year existence.&#34;</em> <!-- -->[2016]<!-- --></li><li><em>&#34;Google&#39;s codebase is shared by more than 25,000 Google software developers from dozens of offices in countries around the world. On a typical workday, they commit 16,000 changes to the codebase, and another 24,000 changes are committed by automated systems.&#34;</em> <!-- -->[2016]<!-- --></li></ul><p>However, these days monorepos become popular for any codebase which has multiple applications with a shared set of (in-house) packages ...</p><h2 id="why-use-a-monorepo"><a href="#why-use-a-monorepo" target="_blank" rel="noopener noreferrer" aria-label="why use a monorepo permalink"><svg height="0" width="0"></svg></a>Why use a Monorepo<!-- --></h2><p>There are two major advantages using a monorepo for a large scale codebase. First of all, shared packages can be used in multiple applications on a local machine without an online registry (e.g. npm). The developer experience improves tremendously here, because everything is in the same codebase without updating dependencies via third-parties. When a shared package gets updated, it gets immediately reflected in all applications which depend on it.</p><p>Second, it improves collaboration across codebases. Teams working on different projects can improve the codebases from other teams without working on multiple repositories. It also improves accessibility without worrying about different setups and introduces a more flexible ownership of the source code across teams. Another benefit is the refactoring of code across many projects.</p><h2 id="structure-of-a-monorepo"><a href="#structure-of-a-monorepo" target="_blank" rel="noopener noreferrer" aria-label="structure of a monorepo permalink"><svg height="0" width="0"></svg></a>Structure of a Monorepo<!-- --></h2><p>A monorepo can contain multiple applications (here: apps) whereas each application has access to shared set of packages. Bear in mind that this is already an opinionated monorepo structure:</p><pre><pre><p><span>- apps/</span></p><p><span>--- app-one</span></p><p><span>--- app-two</span></p><p><span>- packages/</span></p><p><span>--- package-one</span></p><p><span>--- package-two</span></p><p><span>--- package-three</span></p></pre></pre><p>A package, which is just a folder, can be anything from UI components (e.g. framework specific components) over functions (e.g. utilities) to configuration (e.g. ESLint, TypeScript):</p><pre><pre><p><span>- apps/</span></p><p><span>--- app-one</span></p><p><span>--- app-two</span></p><p><span>- packages/</span></p><p><span>--- ui</span></p><p><span>--- utilities</span></p><p><span>--- eslint-config</span></p><p><span>--- ts-config</span></p></pre></pre><p>A package can be a dependency of another package. For example, the <!-- --><em>ui</em> package may use functions from the <!-- --><em>utilities</em> package and therefore the <!-- --><em>ui</em> package depends on the <!-- --><em>utilities</em> package. Both, <!-- --><em>ui</em> and <!-- --><em>utilities</em> package, may use configuration from the other <!-- --><em>*<!-- -->-config<!-- --></em> packages.<!-- --></p><p>The <!-- --><em>apps</em> are usually not dependent on each other, instead they only opt-in <!-- --><em>packages</em>. If packages depend on each other, a monorepo pipeline (see <!-- --><strong>Monorepo Tools</strong>) can enforce scenarios like &#34;start <!-- --><em>ui</em> build only if the <!-- --><em>utilities</em> build finished successfully&#34;.<!-- --></p><p><span>
      <!-- --><span></span>
  <!-- --><picture>
          <!-- --><source srcset="/static/0953eeff573a8eecdc5e042880cab717/f4e34/monorepos-pipeline.webp 256w,/static/0953eeff573a8eecdc5e042880cab717/bd5dd/monorepos-pipeline.webp 512w,/static/0953eeff573a8eecdc5e042880cab717/a9a89/monorepos-pipeline.webp 1024w,/static/0953eeff573a8eecdc5e042880cab717/0abaa/monorepos-pipeline.webp 1536w,/static/0953eeff573a8eecdc5e042880cab717/6cb9c/monorepos-pipeline.webp 1927w" sizes="(max-width: 1024px) 100vw, 1024px" type="image/webp"/>
          <!-- --><source srcset="/static/0953eeff573a8eecdc5e042880cab717/6f3f2/monorepos-pipeline.png 256w,/static/0953eeff573a8eecdc5e042880cab717/01e7c/monorepos-pipeline.png 512w,/static/0953eeff573a8eecdc5e042880cab717/2bef9/monorepos-pipeline.png 1024w,/static/0953eeff573a8eecdc5e042880cab717/71c1d/monorepos-pipeline.png 1536w,/static/0953eeff573a8eecdc5e042880cab717/d126d/monorepos-pipeline.png 1927w" sizes="(max-width: 1024px) 100vw, 1024px" type="image/png"/>
          <!-- --><img src="https://www.robinwieruch.de/static/0953eeff573a8eecdc5e042880cab717/2bef9/monorepos-pipeline.png" alt="monorepos pipeline" title="monorepos pipeline" loading="lazy" decoding="async"/>
        <!-- --></picture>
    <!-- --></span></p><p>Since we are speaking about a JavaScript/TypeScript monorepo here, an <!-- --><em>app</em> can be a JavaScript or TypeScript application whereas only the TypeScript applications would make use of the shared <!-- --><em>ts-config</em> package (or create their own config or use a mix of both).<!-- --></p><p>Applications in <!-- --><em>apps</em> don&#39;t have to use shared <!-- --><em>packages</em> at all. It&#39;s opt-in and they can choose to use their internal implementations of UI components, functions, and configurations. However, if an application in <!-- --><em>apps</em> decides to use a package from <!-- --><em>packages</em> as dependency, they have to define it in their <!-- --><em>package.json</em> file:<!-- --></p><pre><pre><p><span>{</span><span></span></p><p><span>  </span><span>&#34;dependencies&#34;</span><span>:</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>&#34;ui&#34;</span><span>:</span><span> </span><span>&#34;*&#34;</span><span>,</span><span></span></p><p><span>    </span><span>&#34;utilities&#34;</span><span>:</span><span> </span><span>&#34;*&#34;</span><span>,</span><span></span></p><p><span>    </span><span>&#34;eslint-config&#34;</span><span>:</span><span> </span><span>&#34;*&#34;</span><span></span></p><p><span>  </span><span>}</span><span>,</span><span></span></p><p><span></span><span>}</span><span></span></p></pre></pre><p>Applications in <!-- --><em>apps</em> are their own entity and therefore can be anything from a SSR application (e.g. <!-- --><a itemprop="url" href="https://www.robinwieruch.de/react-libraries/">Next.js</a>) to a CSR application (e.g. <!-- --><a itemprop="url" href="https://www.robinwieruch.de/react-libraries/">CRA/Vite</a>).<!-- --></p><p>In other words: applications in <!-- --><em>apps</em> do not know about being an repo in a monorepo, they just define dependencies. The monorepo (see <!-- --><strong>Workspaces in Monorepos</strong>) decides then whether the dependency is taken from the monorepo (default) or from a registry (fallback, e.g. npm registry).<!-- --></p><p>Reversely, this means that an application can be used without being part of the monorepo as well. The only requirement is that all its dependencies (here: <!-- --><em>ui</em>, <!-- --><em>utilities</em>, <!-- --><em>eslint-config</em>) are published on a registry like npm, because when used as a standalone application there is no monorepo with shared dependencies anymore (see <!-- --><strong>Versioning with Monorepos</strong>).<!-- --></p><h2 id="how-to-create-a-monorepo"><a href="#how-to-create-a-monorepo" target="_blank" rel="noopener noreferrer" aria-label="how to create a monorepo permalink"><svg height="0" width="0"></svg></a>How to create a Monorepo<!-- --></h2><p>After all these learnings in theory about monorepos, we will walk through an example of a monorepo as a proof of concept. Therefore, we will create a monorepo with React applications (<!-- --><em>apps</em>) which use a shared set of components/configuration (<!-- --><em>packages</em>). However, none of the tools are tied to React, so you can adapt it to your own framework of choice (e.g. Angular or Vue).<!-- --></p><p>We will not create a monorepo from scratch though, because it would involve too many steps that would make this whole topic difficult to follow. Instead we will be using a starter monorepo. While using it, I will walk you through all the implementation details which went into it step by step.</p><p>Start off by cloning the <!-- --><a href="https://github.com/bigstair-monorepo/monorepo" target="_blank" rel="noopener noreferrer">monorepo starter</a> to your local machine:<!-- --></p><pre><pre><p><span>git clone git@github.com:bigstair-monorepo/monorepo.git</span></p></pre></pre><p>We are using yarn as alternative to npm here, not only for installing the dependencies, but also for using so called workspaces later on. In the next section (see <!-- --><strong>Workspaces in Monorepos</strong>), you will learn about workspaces and alternative workspaces tools in contrast to yarn workspaces. For now, navigate into the repository and install all the dependencies with yarn:<!-- --></p><pre><pre><p><span>cd monorepo</span></p><p><span>yarn install</span></p></pre></pre><p>While explaining other parts later, we will focus on the following content of the monorepo for now:</p><pre><pre><p><span>- apps/</span></p><p><span>--- docs</span></p><p><span>- packages/</span></p><p><span>--- bigstair-core</span></p><p><span>--- bigstair-map</span></p><p><span>--- eslint-config-bigstair</span></p><p><span>--- ts-config-bigstair</span></p></pre></pre><p>The monorepo comes with one &#34;built-in&#34; application called <!-- --><em>docs</em> in <!-- --><em>apps</em> for the documentation. Later we will integrate actual applications (see <!-- --><strong>Workspaces in Monorepos</strong>) next to the documentation.<!-- --></p><p>In addition, there are four <!-- --><em>packages</em> -- whereas two packages are shared UI components (here: <!-- --><em>bigstair-core</em> and <!-- --><em>bigstair-map</em>) and two packages are shared configurations (here: <!-- --><em>eslint-config-bigstair</em> and <!-- --><em>eslint-config-bigstair</em>).<!-- --></p><p>We are dealing with a fake company called <!-- --><em>bigstair</em> here which becomes important later (see <!-- --><strong>Versioning with Monorepos</strong>). For now, just think away the bigstair naming which may make it more approachable. Furthermore, we will not put much focus on the ESLint and TypeScript configurations. You can check out later how they are reused in <!-- --><em>packages</em> and <!-- --><em>apps</em>, but what&#39;s important to us are the actual applications and the actual shared packages:<!-- --></p><pre><pre><p><span>- apps/</span></p><p><span>--- docs</span></p><p><span>- packages/</span></p><p><span>--- core</span></p><p><span>--- map</span></p></pre></pre><p>For the two <!-- --><em>packages</em> imagine any JavaScript/TypeScript code that should be consumed in our <!-- --><em>apps</em>. For example, while the <!-- --><em>core</em> package could have baseline UI components like buttons, dropdowns, and dialogs, the <!-- --><em>map</em> package could have a reusable yet more complex Map component. From the <!-- --><em>apps</em> directory&#39;s perspective, the separate packages are just like libraries solving different problems. After all, this only shows that the packages folder can scale vertically the same way as the apps folder.<!-- --></p><hr/><p>To conclude this section, run the following command to run the <!-- --><em>apps/docs</em> application. We will discuss later (see <!-- --><strong>Monorepo Tools</strong>) why this command allows us to start a nested application in the apps folder in the first place:<!-- --></p><pre><pre><p><span>yarn dev</span></p></pre></pre><p>You should see a <!-- --><a href="https://storybook.js.org/" target="_blank" rel="noopener noreferrer">Storybook</a> that displays components from the <!-- --><em>core</em> and <!-- --><em>map</em> packages. In this case these components are only buttons (and not a map) for the sake of keeping it simple. If you check the <!-- --><em>core</em> and <!-- --><em>map</em> package&#39;s source code, you should find the implementation of these components:<!-- --></p><pre><pre><p><span>import</span><span> </span><span>*</span><span> </span><span>as</span><span> </span><span>React</span><span> </span><span>from</span><span> </span><span>&#39;react&#39;</span><span>;</span><span></span></p><p><span></span><span>export</span><span> </span><span>interface</span><span> </span><span>ButtonProps</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>children</span><span>:</span><span> </span><span>React</span><span>.</span><span>ReactNode</span><span>;</span><span></span></p><p><span></span><span>}</span><span></span></p><p><span></span><span>export</span><span> </span><span>function</span><span> </span><span>Button</span><span>(</span><span>props</span><span>:</span><span> </span><span>ButtonProps</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>return</span><span> </span><span>&lt;</span><span>button</span><span>&gt;</span><span>{</span><span>props</span><span>.</span><span>children</span><span>}</span><span>&lt;/</span><span>button</span><span>&gt;</span><span>;</span><span></span></p><p><span></span><span>}</span><span></span></p><p><span></span><span>Button</span><span>.</span><span>displayName</span><span> </span><span>=</span><span> </span><span>&#39;Button&#39;</span><span>;</span><span></span></p></pre></pre><p>Furthermore, the <!-- --><em>package.json</em> files of both packages define a <!-- --><code>name</code> property which are defined as dependencies in the <!-- --><em>docs</em> application&#39;s <!-- --><em>package.json</em>:<!-- --></p><pre><pre><p><span>&#34;dependencies&#34;</span><span>:</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>&#34;@bigstair/core&#34;</span><span>:</span><span> </span><span>&#34;*&#34;</span><span>,</span><span></span></p><p><span>  </span><span>&#34;@bigstair/map&#34;</span><span>:</span><span> </span><span>&#34;*&#34;</span><span>,</span><span></span></p><p><span>  </span><span>&#34;react&#34;</span><span>:</span><span> </span><span>&#34;18.0.0&#34;</span><span>,</span><span></span></p><p><span>  </span><span>&#34;react-dom&#34;</span><span>:</span><span> </span><span>&#34;18.0.0&#34;</span><span></span></p><p><span></span><span>}</span><span>,</span><span></span></p></pre></pre><p>If both packages would be available via the npm registry, the <!-- --><em>docs</em> application could install it from there. However, as mentioned earlier, since we are working in a monorepo setup with workspaces (see <!-- --><strong>Workspaces in Monorepos</strong>), the <!-- --><em>package.json</em> file of the <!-- --><em>docs</em> application checks first if these packages exist in the monorepo before using the npm registry as fallback.<!-- --></p><p>Last, check the implementation details of the <!-- --><em>docs</em> application. There you will see that it imports the packages like third-party libraries even though they are packages in the monorepo:<!-- --></p><pre><pre><p><span>import</span><span> </span><span>{</span><span> </span><span>Button</span><span> </span><span>}</span><span> </span><span>from</span><span> </span><span>&#39;@bigstair/core&#39;</span><span>;</span><span></span></p></pre></pre><p>This underpins again the fact that an application in <!-- --><em>apps</em> doesn&#39;t know that it plays a part in a monorepo (see <!-- --><strong>Incubating</strong>). If it wouldn&#39;t be in a monorepo (see <!-- --><strong>Hatching</strong>), it would just install the dependencies from the npm registry.<!-- --></p><h2 id="workspaces-in-monorepos"><a href="#workspaces-in-monorepos" target="_blank" rel="noopener noreferrer" aria-label="workspaces in monorepos permalink"><svg height="0" width="0"></svg></a>Workspaces in Monorepos<!-- --></h2><p>A monorepo, in our case, consists of multiple apps/packages working together. In the background, a tool called workspaces enables us to create a folder structure where <!-- --><em>apps</em> can use <!-- --><em>packages</em> as dependencies. In our case, we are using <!-- --><a href="https://yarnpkg.com/features/workspaces" target="_blank" rel="noopener noreferrer">yarn workspaces</a> to accomplish our goal. There are alternatives such as <!-- --><a href="https://docs.npmjs.com/cli/v7/using-npm/workspaces" target="_blank" rel="noopener noreferrer">npm workspaces</a> and <!-- --><a href="https://pnpm.io/workspaces" target="_blank" rel="noopener noreferrer">pnpm workspaces</a> too.<!-- --></p><p>A yarn workspace gets defined the following way in the top-level <!-- --><em>package.json</em> file:<!-- --></p><pre><pre><p><span>&#34;workspaces&#34;</span><span>:</span><span> </span><span>[</span><span></span></p><p><span>  </span><span>&#34;packages/*&#34;</span><span>,</span><span></span></p><p><span>  </span><span>&#34;apps/*&#34;</span><span></span></p><p><span></span><span>]</span><span>,</span><span></span></p></pre></pre><p>Since we already anticipate that we have multiple <!-- --><em>apps</em> and <!-- --><em>packages</em>, we can just point to the folder path and use a wildcard as subpath. This way, every folder in <!-- --><em>apps</em>/<!-- --><em>packages</em> with a <!-- --><em>package.json</em> file gets picked up. Now, if an application from <!-- --><em>apps</em> wants to include a package from <!-- --><em>packages</em>, it just has to use the <!-- --><code>name</code> property from the package&#39;s <!-- --><em>package.json</em> file as dependency in its own <!-- --><em>package.json</em> file (as we have seen before). Note that the structure of having <!-- --><em>apps</em> and <!-- --><em>packages</em> is already opinionated at this point.<!-- --></p><hr/><p>In practice, it&#39;s about multiple <!-- --><em>apps</em> which can opt-in local <!-- --><em>packages</em> as dependencies. However, so far we have only used the <!-- --><em>docs</em> application which uses our monorepo&#39;s <!-- --><em>packages</em>. Furthermore, the <!-- --><em>docs</em> application is just there for documentation of these packages. What we want are actual applications using the shared packages.<!-- --></p><p><span>
      <!-- --><span></span>
  <!-- --><picture>
          <!-- --><source srcset="/static/60cd627515ffa400b8ff5cdc07c132fc/f4e34/monorepos-workspaces.webp 256w,/static/60cd627515ffa400b8ff5cdc07c132fc/bd5dd/monorepos-workspaces.webp 512w,/static/60cd627515ffa400b8ff5cdc07c132fc/a9a89/monorepos-workspaces.webp 1024w,/static/60cd627515ffa400b8ff5cdc07c132fc/0abaa/monorepos-workspaces.webp 1536w,/static/60cd627515ffa400b8ff5cdc07c132fc/846bd/monorepos-workspaces.webp 1773w" sizes="(max-width: 1024px) 100vw, 1024px" type="image/webp"/>
          <!-- --><source srcset="/static/60cd627515ffa400b8ff5cdc07c132fc/6f3f2/monorepos-workspaces.png 256w,/static/60cd627515ffa400b8ff5cdc07c132fc/01e7c/monorepos-workspaces.png 512w,/static/60cd627515ffa400b8ff5cdc07c132fc/2bef9/monorepos-workspaces.png 1024w,/static/60cd627515ffa400b8ff5cdc07c132fc/71c1d/monorepos-workspaces.png 1536w,/static/60cd627515ffa400b8ff5cdc07c132fc/947d2/monorepos-workspaces.png 1773w" sizes="(max-width: 1024px) 100vw, 1024px" type="image/png"/>
          <!-- --><img src="https://www.robinwieruch.de/static/60cd627515ffa400b8ff5cdc07c132fc/2bef9/monorepos-workspaces.png" alt="monorepos workspaces" title="monorepos workspaces" loading="lazy" decoding="async"/>
        <!-- --></picture>
    <!-- --></span></p><p>Navigate into the <!-- --><em>apps</em> folder where we will clone two new applications into the monorepo. Afterward, navigate back again and install all new dependencies:<!-- --></p><pre><pre><p><span>cd apps</span></p><p><span>git clone git@github.com:bigstair-monorepo/app-vite-js.git</span></p><p><span>git clone git@github.com:bigstair-monorepo/app-vite-ts.git</span></p><p><span>cd ..</span></p><p><span>yarn install</span></p></pre></pre><p>Installing all dependencies is needed here for two things:</p><ul><li>First, the new applications in <!-- --><em>apps</em> need to install all their dependencies -- including the <!-- --><em>packages</em> which they define as dependencies as well.<!-- --></li><li>Second, with two new nested workspaces coming in, there may be new dependencies between <!-- --><em>apps</em> and <!-- --><em>packages</em> that need to be resolved in order to have all workspace working together.<!-- --></li></ul><p>Now when you start all <!-- --><em>apps</em> with <!-- --><code>yarn dev</code>, you should see the Storybook coming up in addition to two new React applications which uses the Button component from the <!-- --><em>packages</em>.<!-- --></p><hr/><p>Both cloned applications are React applications bootstrapped with <!-- --><a href="https://vitejs.dev/" target="_blank" rel="noopener noreferrer">Vite</a>. The only thing changed about the initial boilerplates is its dependencies in the <!-- --><em>package.json</em> where it defines the <!-- --><em>packages</em> from our workspaces as third-parties:<!-- --></p><pre><pre><p><span>&#34;dependencies&#34;</span><span>:</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>&#34;@bigstair/core&#34;</span><span>:</span><span> </span><span>&#34;*&#34;</span><span>,</span><span></span></p><p><span>  </span><span>&#34;@bigstair/map&#34;</span><span>:</span><span> </span><span>&#34;*&#34;</span><span>,</span><span></span></p><p><span>  ...</span></p><p><span></span><span>}</span><span></span></p></pre></pre><p>Afterward, they just use the shared components the same way as we did before in the <!-- --><em>docs</em>:<!-- --></p><pre><pre><p><span>import</span><span> </span><span>{</span><span> </span><span>Button</span><span> </span><span>}</span><span> </span><span>from</span><span> </span><span>&#39;@bigstair/core&#39;</span><span>;</span><span></span></p></pre></pre><p>Because we are working in a monorepo setup, to be more specific in workspace setup which enables this kind of linking between projects (here: <!-- --><em>apps</em> and <!-- --><em>packages</em>) in the first place, these dependencies are looked up from the workspaces before installing them from a registry like npm.<!-- --></p><p><span>
      <!-- --><span></span>
  <!-- --><picture>
          <!-- --><source srcset="/static/98e826be112f7d69da29acdf1bd52eaf/f4e34/monorepos-dependencies.webp 256w,/static/98e826be112f7d69da29acdf1bd52eaf/bd5dd/monorepos-dependencies.webp 512w,/static/98e826be112f7d69da29acdf1bd52eaf/a9a89/monorepos-dependencies.webp 1024w,/static/98e826be112f7d69da29acdf1bd52eaf/e3265/monorepos-dependencies.webp 1161w" sizes="(max-width: 1024px) 100vw, 1024px" type="image/webp"/>
          <!-- --><source srcset="/static/98e826be112f7d69da29acdf1bd52eaf/6f3f2/monorepos-dependencies.png 256w,/static/98e826be112f7d69da29acdf1bd52eaf/01e7c/monorepos-dependencies.png 512w,/static/98e826be112f7d69da29acdf1bd52eaf/2bef9/monorepos-dependencies.png 1024w,/static/98e826be112f7d69da29acdf1bd52eaf/129e9/monorepos-dependencies.png 1161w" sizes="(max-width: 1024px) 100vw, 1024px" type="image/png"/>
          <!-- --><img src="https://www.robinwieruch.de/static/98e826be112f7d69da29acdf1bd52eaf/2bef9/monorepos-dependencies.png" alt="monorepos dependencies" title="monorepos dependencies" loading="lazy" decoding="async"/>
        <!-- --></picture>
    <!-- --></span></p><p>As you can see, any JavaScript or TypeScript application can be bootstrapped in the <!-- --><em>apps</em> folder this way. Go ahead and create your own application, define the <!-- --><em>packages</em> as dependencies, <!-- --><code>yarn install</code> everything, and use the shared components from the <!-- --><em>packages</em> workspaces.<!-- --></p><hr/><p>At this point, you already have seen the global <!-- --><em>package.json</em> file in the top-level directory and local <!-- --><em>package.json</em> files for each project in <!-- --><em>apps</em> and <!-- --><em>packages</em>. The top-level <!-- --><em>package.json</em> file defines the workspaces in addition to global dependencies (e.g. eslint, prettier) which can be used in every nested workspace. In contrast, the nested <!-- --><em>package.json</em> files only define dependencies which are needed in the actual project.<!-- --></p><p>You have witnessed how workspaces already allow us to create a monorepo structure. However, while workspaces enable developers to link projects in a monorepo to each other, a dedicated monorepo tool comes with an improved developer experience. You have already seen one of these DX improvements when typing:</p><pre><pre><p><span>yarn dev</span></p></pre></pre><p>Executing this command from the top-level folder starts all of the projects in the monorepo which have a <!-- --><code>dev</code> script in their <!-- --><code>package.json</code> file. The same goes for several other commands:<!-- --></p><pre><pre><p><span>yarn lint</span></p><p><span>yarn build</span></p><p><span>yarn clean</span></p></pre></pre><p>If you check the top-level <!-- --><em>package.json</em> file, you will a bunch of overarching scripts:<!-- --></p><pre><pre><p><span>&#34;scripts&#34;</span><span>:</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>&#34;dev&#34;</span><span>:</span><span> </span><span>&#34;turbo run dev&#34;</span><span>,</span><span></span></p><p><span>  </span><span>&#34;lint&#34;</span><span>:</span><span> </span><span>&#34;turbo run lint&#34;</span><span>,</span><span></span></p><p><span>  </span><span>&#34;build&#34;</span><span>:</span><span> </span><span>&#34;turbo run build&#34;</span><span>,</span><span></span></p><p><span>  </span><span>&#34;clean&#34;</span><span>:</span><span> </span><span>&#34;turbo run clean&#34;</span><span>,</span><span></span></p><p><span>  ...</span></p><p><span></span><span>}</span><span>,</span><span></span></p><p><span></span><span>&#34;devDependencies&#34;</span><span>:</span><span> </span><span>{</span><span></span></p><p><span>  ...</span></p><p><span>  </span><span>&#34;turbo&#34;</span><span>:</span><span> </span><span>&#34;latest&#34;</span><span></span></p><p><span></span><span>}</span><span></span></p></pre></pre><p>A monorepo tool called <!-- --><a href="https://turborepo.org/" target="_blank" rel="noopener noreferrer">Turborepo</a> allows us to define these scripts. Alternative monorepo tools are <!-- --><a href="https://lerna.js.org/" target="_blank" rel="noopener noreferrer">Lerna</a> and <!-- --><a href="https://nx.dev/" target="_blank" rel="noopener noreferrer">Nx</a>. Turborepo comes with several configurations that allow you to execute the scripts for its nested workspaces in parallel (default), in order, or filtered:<!-- --></p><pre><pre><p><span>&#34;scripts&#34;</span><span>:</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>&#34;dev&#34;</span><span>:</span><span> </span><span>&#34;turbo run dev --filter=\&#34;docs\&#34;&#34;</span><span>,</span><span></span></p><p><span>  ...</span></p><p><span></span><span>}</span><span>,</span><span></span></p></pre></pre><p>In addition, you can create a <!-- --><em>turbo.json</em> file (open it yourself) to define a monorepo pipeline for all the scripts. For example, if one package has another package as dependency in the <!-- --><em>packages</em> workspace, then one could define in the pipeline for the build script that the former package has to wait for the build of the latter package.<!-- --></p><p><span>
      <!-- --><span></span>
  <!-- --><picture>
          <!-- --><source srcset="/static/0953eeff573a8eecdc5e042880cab717/f4e34/monorepos-pipeline.webp 256w,/static/0953eeff573a8eecdc5e042880cab717/bd5dd/monorepos-pipeline.webp 512w,/static/0953eeff573a8eecdc5e042880cab717/a9a89/monorepos-pipeline.webp 1024w,/static/0953eeff573a8eecdc5e042880cab717/0abaa/monorepos-pipeline.webp 1536w,/static/0953eeff573a8eecdc5e042880cab717/6cb9c/monorepos-pipeline.webp 1927w" sizes="(max-width: 1024px) 100vw, 1024px" type="image/webp"/>
          <!-- --><source srcset="/static/0953eeff573a8eecdc5e042880cab717/6f3f2/monorepos-pipeline.png 256w,/static/0953eeff573a8eecdc5e042880cab717/01e7c/monorepos-pipeline.png 512w,/static/0953eeff573a8eecdc5e042880cab717/2bef9/monorepos-pipeline.png 1024w,/static/0953eeff573a8eecdc5e042880cab717/71c1d/monorepos-pipeline.png 1536w,/static/0953eeff573a8eecdc5e042880cab717/d126d/monorepos-pipeline.png 1927w" sizes="(max-width: 1024px) 100vw, 1024px" type="image/png"/>
          <!-- --><img src="https://www.robinwieruch.de/static/0953eeff573a8eecdc5e042880cab717/2bef9/monorepos-pipeline.png" alt="monorepos pipeline" title="monorepos pipeline" loading="lazy" decoding="async"/>
        <!-- --></picture>
    <!-- --></span></p><p>Last but not least, Turborepo comes with advanced caching capabilities for files which work locally (default) and remotely. You can opt-out of local caching any time. You can check out Turborepo&#39;s documentation here, because this walkthrough does not go into any more detail here.</p><h2 id="documentation-in-monorepos"><a href="#documentation-in-monorepos" target="_blank" rel="noopener noreferrer" aria-label="documentation in monorepos permalink"><svg height="0" width="0"></svg></a>Documentation in Monorepos<!-- --></h2><p>Because many monorepos come with applications which access a shared set of packages, it&#39;s already the perfect architecture to have one dedicated application for documentation purposes which also gets access to the <!-- --><em>packages</em>.<!-- --></p><p><span>
      <!-- --><span></span>
  <!-- --><picture>
          <!-- --><source srcset="/static/aeb67db99f2a753b1b559656690a6df1/f4e34/monorepos-documentation.webp 256w,/static/aeb67db99f2a753b1b559656690a6df1/bd5dd/monorepos-documentation.webp 512w,/static/aeb67db99f2a753b1b559656690a6df1/a9a89/monorepos-documentation.webp 1024w,/static/aeb67db99f2a753b1b559656690a6df1/dde0f/monorepos-documentation.webp 1516w" sizes="(max-width: 1024px) 100vw, 1024px" type="image/webp"/>
          <!-- --><source srcset="/static/aeb67db99f2a753b1b559656690a6df1/6f3f2/monorepos-documentation.png 256w,/static/aeb67db99f2a753b1b559656690a6df1/01e7c/monorepos-documentation.png 512w,/static/aeb67db99f2a753b1b559656690a6df1/2bef9/monorepos-documentation.png 1024w,/static/aeb67db99f2a753b1b559656690a6df1/a8a6f/monorepos-documentation.png 1516w" sizes="(max-width: 1024px) 100vw, 1024px" type="image/png"/>
          <!-- --><img src="https://www.robinwieruch.de/static/aeb67db99f2a753b1b559656690a6df1/2bef9/monorepos-documentation.png" alt="monorepos documentation" title="monorepos documentation" loading="lazy" decoding="async"/>
        <!-- --></picture>
    <!-- --></span></p><p>Our initial setup of the monorepo already came with a <!-- --><em>docs</em> application which uses Storybook to document all of the package&#39;s UI components. However, if the shared packages are not UI components, you may want to have other tools for documenting concepts, usage, or APIs.<!-- --></p><p>From this &#34;minimal monorepo architecture&#34;, which comes with shared packages, documentation of the shared packages, and a proof of concept that the monorepo architecture works by reusing the packages in the documentation, one can extend the structure by adding more applications or packages to it as we have done in the <!-- --><strong>Workspaces in Monorepos</strong> section.<!-- --></p><h2 id="monorepos-vs-polyrepos-in-git"><a href="#monorepos-vs-polyrepos-in-git" target="_blank" rel="noopener noreferrer" aria-label="monorepos vs polyrepos in git permalink"><svg height="0" width="0"></svg></a>Monorepos vs Polyrepos in Git<!-- --></h2><p>If nothing speaks against it, one can host a monorepo with all its workspaces in a single Git repository. That&#39;s the prime definition of a monorepo after all. However, once a monorepo scales in size with multiple workspaces, there is <!-- --><em>maybe</em> (!) the need (see <!-- --><strong>Example: Monorepos as Incubators</strong>) for separating the monorepo into multiple Git repositories. That&#39;s what we already did with the <!-- --><em>apps</em> (except for <!-- --><em>docs</em>) in our monorepo walkthrough.<!-- --></p><p>There may be various ways to move from a single Git repository to multiple Git repositories for a monorepo -- essentially creating a polyrepo in disguise as a monorepo. In our case, we just used a top-level <!-- --><em>.gitignore</em> file which ignores two of the nested workspaces from the <!-- --><em>apps</em> which should have their dedicated Git repository.<!-- --></p><p><span>
      <!-- --><span></span>
  <!-- --><picture>
          <!-- --><source srcset="/static/71c65737c6185e95eac84323a4b7d973/f4e34/monorepos-git.webp 256w,/static/71c65737c6185e95eac84323a4b7d973/bd5dd/monorepos-git.webp 512w,/static/71c65737c6185e95eac84323a4b7d973/a9a89/monorepos-git.webp 1024w,/static/71c65737c6185e95eac84323a4b7d973/0abaa/monorepos-git.webp 1536w,/static/71c65737c6185e95eac84323a4b7d973/b33b6/monorepos-git.webp 1582w" sizes="(max-width: 1024px) 100vw, 1024px" type="image/webp"/>
          <!-- --><source srcset="/static/71c65737c6185e95eac84323a4b7d973/6f3f2/monorepos-git.png 256w,/static/71c65737c6185e95eac84323a4b7d973/01e7c/monorepos-git.png 512w,/static/71c65737c6185e95eac84323a4b7d973/2bef9/monorepos-git.png 1024w,/static/71c65737c6185e95eac84323a4b7d973/71c1d/monorepos-git.png 1536w,/static/71c65737c6185e95eac84323a4b7d973/35890/monorepos-git.png 1582w" sizes="(max-width: 1024px) 100vw, 1024px" type="image/png"/>
          <!-- --><img src="https://www.robinwieruch.de/static/71c65737c6185e95eac84323a4b7d973/2bef9/monorepos-git.png" alt="monorepos git" title="monorepos git" loading="lazy" decoding="async"/>
        <!-- --></picture>
    <!-- --></span></p><p>However, this way we always work on the latest version of all workspaces (here: <!-- --><em>apps</em> and <!-- --><em>packages</em>), because when cloning all nested workspaces into the monorepo or as standalone application, they just use the recent code. We get around this flaw when taking versioning into account next.<!-- --></p><h2 id="versioning-with-monorepos"><a href="#versioning-with-monorepos" target="_blank" rel="noopener noreferrer" aria-label="versioning with monorepos permalink"><svg height="0" width="0"></svg></a>Versioning with Monorepos<!-- --></h2><p>Applying versions, especially to shared <!-- --><em>packages</em> in a monorepo which may end up online in a package manager (e.g. npm registry) eventually, is not as straightforward as expected. There are multiple challenges like <!-- --><em>packages</em> can depend on each other, there is more than one package to keep an eye on, packages are nested folders in <!-- --><em>packages</em>, and each package has to have its own changelog and release process.<!-- --></p><p>In a monorepo setup, the <!-- --><em>packages</em> behave like dependencies, because the <!-- --><em>apps</em> are using them from the workspace setup (and not the registry). However, if an application does not want to use the recent version of a package in a workspace, it can define a more specific version of it:<!-- --></p><pre><pre><p><span>&#34;dependencies&#34;</span><span>:</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>&#34;@bigstair/core&#34;</span><span>:</span><span> </span><span>&#34;1.0.0&#34;</span><span>,</span><span></span></p><p><span>  </span><span>&#34;@bigstair/map&#34;</span><span>:</span><span> </span><span>&#34;1.0.0&#34;</span><span>,</span><span></span></p><p><span>  ...</span></p><p><span></span><span>}</span><span></span></p></pre></pre><p>In this case, if the version of the package in the workspace is different from the specified version, the install script will not use the workspace package but the registry instead. Therefore we need a way to create versions, changelogs, and releases for <!-- --><em>packages</em> while developing the monorepo.<!-- --></p><hr/><p>The <!-- --><a href="https://github.com/changesets/changesets" target="_blank" rel="noopener noreferrer">changesets</a> project is a popular tool for managing versions of multiple packages in a multi-package repositories (e.g. monorepo). Our monorepo setup already comes with an installation of changesets and scripts defined in the top-level <!-- --><em>package.json</em> file. We will walk through each of these changesets scripts step by step:<!-- --></p><pre><pre><p><span>&#34;scripts&#34;</span><span>:</span><span> </span><span>{</span><span></span></p><p><span>  ...</span></p><p><span>  </span><span>&#34;changeset-create&#34;</span><span>:</span><span> </span><span>&#34;changeset&#34;</span><span>,</span><span></span></p><p><span>  </span><span>&#34;changeset-apply&#34;</span><span>:</span><span> </span><span>&#34;changeset version&#34;</span><span>,</span><span></span></p><p><span>  </span><span>&#34;release&#34;</span><span>:</span><span> </span><span>&#34;turbo run build &amp;&amp; changeset publish&#34;</span><span></span></p><p><span></span><span>}</span><span>,</span><span></span></p></pre></pre><p>Versioning packages will include publishing them to a registry (e.g. npm). If you want to follow along, you need to perform the following steps as prerequisite:</p><ul><li>create an organization on <!-- --><a href="https://www.npmjs.com/" target="_blank" rel="noopener noreferrer">npm</a> which allows you to publish packages<!-- --></li><li>npm login on the command line</li><li>use the name of your organization instead of <!-- --><code>bigstair</code> everywhere in the source code<!-- --></li><li>verify with <!-- --><code>yarn install &amp;&amp; yarn dev</code> that everything still works as expected<!-- --></li></ul><p>Another prerequisite before we can version a package: We need to change one of our <!-- --><em>packages</em> first. Go into one of the UI packages and change the source code of the components. Afterward, the mission is to have the change reflected in the new version which gets published to npm.<!-- --></p><p><span>
      <!-- --><span></span>
  <!-- --><picture>
          <!-- --><source srcset="/static/979250214b5a99761393f0bd4df93551/f4e34/monorepos-versioning.webp 256w,/static/979250214b5a99761393f0bd4df93551/bd5dd/monorepos-versioning.webp 512w,/static/979250214b5a99761393f0bd4df93551/a9a89/monorepos-versioning.webp 1024w,/static/979250214b5a99761393f0bd4df93551/0abaa/monorepos-versioning.webp 1536w,/static/979250214b5a99761393f0bd4df93551/e7b51/monorepos-versioning.webp 1794w" sizes="(max-width: 1024px) 100vw, 1024px" type="image/webp"/>
          <!-- --><source srcset="/static/979250214b5a99761393f0bd4df93551/6f3f2/monorepos-versioning.png 256w,/static/979250214b5a99761393f0bd4df93551/01e7c/monorepos-versioning.png 512w,/static/979250214b5a99761393f0bd4df93551/2bef9/monorepos-versioning.png 1024w,/static/979250214b5a99761393f0bd4df93551/71c1d/monorepos-versioning.png 1536w,/static/979250214b5a99761393f0bd4df93551/e3729/monorepos-versioning.png 1794w" sizes="(max-width: 1024px) 100vw, 1024px" type="image/png"/>
          <!-- --><img src="https://www.robinwieruch.de/static/979250214b5a99761393f0bd4df93551/2bef9/monorepos-versioning.png" alt="monorepos versioning" title="monorepos versioning" loading="lazy" decoding="async"/>
        <!-- --></picture>
    <!-- --></span></p><ul><li><p>First, run <!-- --><code>yarn changeset-create</code> which enables you to create a changelog for changed packages. The prompt walks you through selecting a package (use spacebar), choosing the semver increment (major, minor, patch), and writing the actual changelog. If you check your repository afterward with <!-- --><code>git status</code>, you will see the changed source code in addition to a newly created changelog file. If packages depend on each other, the linked packages will get a version bump later too.<!-- --></p></li><li><p>Second, if the changelog file is okay, run <!-- --><code>yarn changeset-apply</code> which applies the changelog and the version to the actual package. You can check again with <!-- --><code>git status</code> and <!-- --><code>git diff</code> if everything looks as desired.<!-- --></p></li><li><p>Third, if everything looks okay, go ahead and release the updated packages to npm with <!-- --><code>yarn release</code>. After the release, veryfy on npm that your new version got published there.<!-- --></p></li></ul><p>Essentially that&#39;s everything to versioning your packages on your local machine. The next section takes it one step further by using continuous integration for the versioning (2) and publishing (3) steps.</p><h2 id="continuous-integration-with-monorepos"><a href="#continuous-integration-with-monorepos" target="_blank" rel="noopener noreferrer" aria-label="continuous integration with monorepos permalink"><svg height="0" width="0"></svg></a>Continuous Integration with Monorepos<!-- --></h2><p>The complexity of the Continuous Integration (CI) of a monorepo depends on how many repositories get managed on a version control platform like <!-- --><a href="https://github.com/rwieruch" target="_blank" rel="noopener noreferrer">GitHub</a>. In our case, all <!-- --><em>packages</em> are in the same repository (here they are part of the monorepo itself). Hence we only need to care about CI for this one repository, because in this section it&#39;s all about the release of the <!-- --><em>packages</em>.<!-- --></p><p>The example monorepo already uses GitHub Actions for the CI. Open the <!-- --><em>.github/workflows.release.yml</em> file which presents the following content for the GutHub Action:<!-- --></p><pre><pre><p><span>name</span><span>:</span><span> </span><span>Release</span><span></span></p><p><span></span><span>on</span><span>:</span><span></span></p><p><span>  </span><span>push</span><span>:</span><span></span></p><p><span>    </span><span>branches</span><span>:</span><span></span></p><p><span>      </span><span>-</span><span> main</span></p><p><span></span><span>concurrency</span><span>:</span><span> $</span><span>{</span><span>{</span><span> github</span><span>.</span><span>workflow</span><span> </span><span>}</span><span>}</span><span>-</span><span>$</span><span>{</span><span>{</span><span> github</span><span>.</span><span>ref</span><span> </span><span>}</span><span>}</span><span></span></p><p><span></span><span>jobs</span><span>:</span><span></span></p><p><span>  </span><span>release</span><span>:</span><span></span></p><p><span>    </span><span>name</span><span>:</span><span> </span><span>Release</span><span></span></p><p><span>    runs</span><span>-</span><span>on</span><span>:</span><span> ubuntu</span><span>-</span><span>latest</span></p><p><span>    </span><span>steps</span><span>:</span><span></span></p><p><span>      </span><span>-</span><span> name</span><span>:</span><span> </span><span>Checkout</span><span> </span><span>Repository</span><span></span></p><p><span>        </span><span>uses</span><span>:</span><span> actions</span><span>/</span><span>checkout@v2</span></p><p><span>        </span><span>with</span><span>:</span><span></span></p><p><span>          fetch</span><span>-</span><span>depth</span><span>:</span><span> </span><span>0</span><span></span></p><p><span>      </span><span>-</span><span> name</span><span>:</span><span> </span><span>Setup</span><span> </span><span>Node</span><span>.</span><span>js</span><span> </span><span>16</span><span>.</span><span>x</span><span></span></p><p><span>        </span><span>uses</span><span>:</span><span> actions</span><span>/</span><span>setup</span><span>-</span><span>node@v2</span></p><p><span>        </span><span>with</span><span>:</span><span></span></p><p><span>          node</span><span>-</span><span>version</span><span>:</span><span> </span><span>16</span><span>.</span><span>x</span><span></span></p><p><span>      </span><span>-</span><span> name</span><span>:</span><span> </span><span>Install</span><span> </span><span>Dependencies</span><span></span></p><p><span>        </span><span>run</span><span>:</span><span> yarn install</span></p><p><span>      </span><span>-</span><span> name</span><span>:</span><span> </span><span>Create</span><span> </span><span>Release</span><span> </span><span>Pull</span><span> </span><span>Request</span><span> or </span><span>Publish</span><span> to npm</span></p><p><span>        </span><span>id</span><span>:</span><span> changesets</span></p><p><span>        </span><span>uses</span><span>:</span><span> changesets</span><span>/</span><span>action@v1</span></p><p><span>        </span><span>with</span><span>:</span><span></span></p><p><span>          </span><span>publish</span><span>:</span><span> yarn release</span></p><p><span>        </span><span>env</span><span>:</span><span></span></p><p><span>          </span><span>GITHUB_TOKEN</span><span>:</span><span> $</span><span>{</span><span>{</span><span> secrets</span><span>.</span><span>GITHUB_TOKEN</span><span> </span><span>}</span><span>}</span><span></span></p><p><span>          </span><span>NPM_TOKEN</span><span>:</span><span> $</span><span>{</span><span>{</span><span> secrets</span><span>.</span><span>NPM_TOKEN</span><span> </span><span>}</span><span>}</span><span></span></p></pre></pre><p><em>Note: If this workflow should run on your own GitHub repository, you have to create a <!-- --><code>NPM_TOKEN</code> on npm and use it as repository secret on GitHub. Furthermore, you need enable the &#34;Allow GitHub Actions to create and approve pull requests&#34; for your organization/repository too.<!-- --></em></p><p><span>
      <!-- --><span></span>
  <!-- --><picture>
          <!-- --><source srcset="/static/8b08ccf0caaff7010d86ec391d6f4447/f4e34/monorepos-continuous-integration.webp 256w,/static/8b08ccf0caaff7010d86ec391d6f4447/bd5dd/monorepos-continuous-integration.webp 512w,/static/8b08ccf0caaff7010d86ec391d6f4447/a9a89/monorepos-continuous-integration.webp 1024w,/static/8b08ccf0caaff7010d86ec391d6f4447/0abaa/monorepos-continuous-integration.webp 1536w,/static/8b08ccf0caaff7010d86ec391d6f4447/e7b51/monorepos-continuous-integration.webp 1794w" sizes="(max-width: 1024px) 100vw, 1024px" type="image/webp"/>
          <!-- --><source srcset="/static/8b08ccf0caaff7010d86ec391d6f4447/6f3f2/monorepos-continuous-integration.png 256w,/static/8b08ccf0caaff7010d86ec391d6f4447/01e7c/monorepos-continuous-integration.png 512w,/static/8b08ccf0caaff7010d86ec391d6f4447/2bef9/monorepos-continuous-integration.png 1024w,/static/8b08ccf0caaff7010d86ec391d6f4447/71c1d/monorepos-continuous-integration.png 1536w,/static/8b08ccf0caaff7010d86ec391d6f4447/e3729/monorepos-continuous-integration.png 1794w" sizes="(max-width: 1024px) 100vw, 1024px" type="image/png"/>
          <!-- --><img src="https://www.robinwieruch.de/static/8b08ccf0caaff7010d86ec391d6f4447/2bef9/monorepos-continuous-integration.png" alt="monorepos continuous integration" title="monorepos continuous integration" loading="lazy" decoding="async"/>
        <!-- --></picture>
    <!-- --></span></p><p>Now again, change a component in one of the packages. Afterward, use <!-- --><code>yarn changeset-create</code> to create a changelog (and implicit semver version) locally. Next, push all your changes (source code change + changelog) to GitHub. From there the CI with GitHub actions takes over for your monorepo&#39;s packages. If the CI succeeds, it creates a new PR with the increased version and changelog. Once this PR gets merged, CI runs again and releases the package to npm.<!-- --></p><h2 id="monorepo-architecture"><a href="#monorepo-architecture" target="_blank" rel="noopener noreferrer" aria-label="monorepo architecture permalink"><svg height="0" width="0"></svg></a>Monorepo Architecture<!-- --></h2><p>Monorepos are becoming more popular these days, because they allow you to split your source code into multiple applications/packages (opinionated monorepo structure) while still being able to manage everything at one place. The first enabler for having a monorepo in the first place are <!-- --><strong>Workspaces</strong>. In our case we have been using yarn workspaces, but npm and pnpm come with workspaces as well.<!-- --></p><p>The second enabler are the overarching monorepo tools which allow one to run scripts in a more convenient way globally, to orchestrate scripts in a monorepo (e.g. pipelines in <!-- --><strong>Turborepo</strong>), or to cache executed scripts locally/remotely. Turborepo is one popular contender in this space. Lerna and Nx are two alternatives to it.<!-- --></p><p>If a monorepo is used in Git, one can optionally decide to split a single repository into multiple repositories (polyrepo in disguise as a monorepo). In our scenario we have been using a straightforward <!-- --><em>.gitignore</em> file. However, there may be other solution to this problem.<!-- --></p><p>In the case of versioning, <!-- --><strong>Changesets</strong> is a popular tool for creating changelogs, versions, and releases for a monorepo. It&#39;s the alternative to <!-- --><a href="https://github.com/semantic-release/semantic-release" target="_blank" rel="noopener noreferrer">semantic release</a> in the monorepo space.<!-- --></p><p>In conclusion, Workspaces, Turborepo, and Changesets are the perfect composition of monorepo tools to create, manage, and scale a monorepo in JavaScript/TypeScript.</p><h2 id="example-monorepos-as-incubators"><a href="#example-monorepos-as-incubators" target="_blank" rel="noopener noreferrer" aria-label="example monorepos as incubators permalink"><svg height="0" width="0"></svg></a>Example: Monorepos as Incubators<!-- --></h2><p>In my recent job as a freelance frontend developer, I had to set up a monorepo for a company. The company is a software house which develops applications for other companies. Over the years, they have developed packages (e.g. UI components) internally.</p><p><strong>The goal for the monorepo:</strong> being able to develop applications for clients side by side while being able to use shared packages with a great DX.<!-- --></p><p>It mentions great DX, because that&#39;s the important point for using a monorepo (see <!-- --><strong>Why use a Monorepo</strong>): Rather than installing the packages from npm, we can just change them within the scope of the monorepo and see the changes reflected in the applications. Otherwise we would have to go through the whole release + install cycle when adjusting a UI library.<!-- --></p><p><span>
      <!-- --><span></span>
  <!-- --><picture>
          <!-- --><source srcset="/static/f2e58ec129b2a2765700a2eac67c44ca/f4e34/monorepo-incubator.webp 256w,/static/f2e58ec129b2a2765700a2eac67c44ca/bd5dd/monorepo-incubator.webp 512w,/static/f2e58ec129b2a2765700a2eac67c44ca/a9a89/monorepo-incubator.webp 1024w,/static/f2e58ec129b2a2765700a2eac67c44ca/b2d4b/monorepo-incubator.webp 1152w" sizes="(max-width: 1024px) 100vw, 1024px" type="image/webp"/>
          <!-- --><source srcset="/static/f2e58ec129b2a2765700a2eac67c44ca/6f3f2/monorepo-incubator.png 256w,/static/f2e58ec129b2a2765700a2eac67c44ca/01e7c/monorepo-incubator.png 512w,/static/f2e58ec129b2a2765700a2eac67c44ca/2bef9/monorepo-incubator.png 1024w,/static/f2e58ec129b2a2765700a2eac67c44ca/4ad3a/monorepo-incubator.png 1152w" sizes="(max-width: 1024px) 100vw, 1024px" type="image/png"/>
          <!-- --><img src="https://www.robinwieruch.de/static/f2e58ec129b2a2765700a2eac67c44ca/2bef9/monorepo-incubator.png" alt="monorepo incubator" title="monorepo incubator" loading="lazy" decoding="async"/>
        <!-- --></picture>
    <!-- --></span></p><p>The process for incubating and hatching an application for a company is divided into two consecutive parts which I will explore in the following.</p><p><strong>Incubating:</strong> When on-boarding a new client to the monorepo, we/they create a repository via git from where we clone it into our monorepo. From there, we can opt-in shared packages from the monorepo as dependencies. The client can clone the repository any time as standalone project (without having to rely on the monorepo) while being able to install all dependencies from the registry, because of the mandatory versioning of the shared packages.<!-- --></p><p><strong>Hatching:</strong> Once a client gets off-boarded, we set a final version to all dependencies in their project&#39;s package.json. From there, it&#39;s their responsibility to upgrade the packages. Hence the automatically generated changelog of in-house packages on our end if a client decides to upgrade one of them.<!-- --></p><h2 id="monorepo-faq"><a href="#monorepo-faq" target="_blank" rel="noopener noreferrer" aria-label="monorepo faq permalink"><svg height="0" width="0"></svg></a>Monorepo FAQ<!-- --></h2><ul><li><p><strong>Are there Monorepos for Frontend and Backend?</strong> When working with a frontend and backend, they are are most often loosely coupled via an API. However, there are various aspects where frontend and backend can still use shared packages (type safe API interfaces, utility functions, server-side components). So it&#39;s totally possible to have a CSR React application, a SSR React application (e.g. Next.js), and an <!-- --><a itemprop="url" href="https://www.robinwieruch.de/node-express-server-rest-api/">Express application</a> side by side.<!-- --></p></li><li><p><strong>Are Monorepos the same as Monoliths?</strong> They are not. A monorepo <!-- --><em>can</em> produce one monolithic application, however there are more likely applications side by side which share the domain of the company or a set of packages but are not <!-- --><em>one</em> self-contained application (definition of monolithic). In the end, there just needs to be the requirement for sharing code across multiple projects.<!-- --></p></li><li><p><strong>Are there Monorepos for Microfrontends?</strong> Not anything that I can reference here, however, it&#39;s absolutely possible to create a user facing application and a admin facing application side by side in a monorepo where the developer decides whether both get stitched together as one monolith or whether they are standalone applications on different (sub)domains (e.g. my-application.com and admin.my-application.com).<!-- --></p></li></ul></article></section></div><p><label for="newsletter"><p><svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewBox="0 0 123.811 123.811"><path d="M29.85 106.463c3.2 3.2 7.5 5 12 5s8.8-1.8 12-5l64.799-64.8c6.5-6.5 7-17.2.7-23.9-6.6-7.1-17.7-7.2-24.399-.4l-46 46c-3.9 3.9-10.2 3.9-14.1 0l-5.9-6c-6.6-6.6-17.4-6.6-24 0-6.6 6.601-6.6 17.4 0 24l24.9 25.1z"></path></svg>Join 50.000+ Developers<!-- --></p><p><svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewBox="0 0 123.811 123.811"><path d="M29.85 106.463c3.2 3.2 7.5 5 12 5s8.8-1.8 12-5l64.799-64.8c6.5-6.5 7-17.2.7-23.9-6.6-7.1-17.7-7.2-24.399-.4l-46 46c-3.9 3.9-10.2 3.9-14.1 0l-5.9-6c-6.6-6.6-17.4-6.6-24 0-6.6 6.601-6.6 17.4 0 24l24.9 25.1z"></path></svg>Learn Web Development<!-- --></p><p><svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewBox="0 0 123.811 123.811"><path d="M29.85 106.463c3.2 3.2 7.5 5 12 5s8.8-1.8 12-5l64.799-64.8c6.5-6.5 7-17.2.7-23.9-6.6-7.1-17.7-7.2-24.399-.4l-46 46c-3.9 3.9-10.2 3.9-14.1 0l-5.9-6c-6.6-6.6-17.4-6.6-24 0-6.6 6.601-6.6 17.4 0 24l24.9 25.1z"></path></svg>Learn JavaScript<!-- --></p><p><svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewBox="0 0 123.811 123.811"><path d="M29.85 106.463c3.2 3.2 7.5 5 12 5s8.8-1.8 12-5l64.799-64.8c6.5-6.5 7-17.2.7-23.9-6.6-7.1-17.7-7.2-24.399-.4l-46 46c-3.9 3.9-10.2 3.9-14.1 0l-5.9-6c-6.6-6.6-17.4-6.6-24 0-6.6 6.601-6.6 17.4 0 24l24.9 25.1z"></path></svg>Access Tutorials, eBooks and Courses<!-- --></p><p><svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewBox="0 0 123.811 123.811"><path d="M29.85 106.463c3.2 3.2 7.5 5 12 5s8.8-1.8 12-5l64.799-64.8c6.5-6.5 7-17.2.7-23.9-6.6-7.1-17.7-7.2-24.399-.4l-46 46c-3.9 3.9-10.2 3.9-14.1 0l-5.9-6c-6.6-6.6-17.4-6.6-24 0-6.6 6.601-6.6 17.4 0 24l24.9 25.1z"></path></svg>Personal Development as a Software Engineer<!-- --></p><a href="https://www.getrevue.co/profile/rwieruch" target="_blank" rel="noopener noreferrer" role="link">Subscribe <!-- --><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 185.343 185.343" height="10px" width="10px"><path d="M51.707 185.343a10.692 10.692 0 01-7.593-3.149 10.724 10.724 0 010-15.175l74.352-74.347L44.114 18.32c-4.194-4.194-4.194-10.987 0-15.175 4.194-4.194 10.987-4.194 15.18 0l81.934 81.934c4.194 4.194 4.194 10.987 0 15.175l-81.934 81.939a10.678 10.678 0 01-7.587 3.15z" fill="#010002"></path></svg></a><small><small>View our<!-- --><a itemprop="url" href="https://www.robinwieruch.de/legal/">Privacy Policy</a>.<!-- --></small></small></label></p></div>
  </body>
</html>
