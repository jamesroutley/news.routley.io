<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.benburwell.com/posts/transactions-are-not-locks/">Original</a>
    <h1>Transactions Are Not Locks (2022)</h1>
    
    <div id="readability-page-1" class="page"><div>
  

  <p>
    Posted on <time datetime="2022-03-29">Tuesday March 29, 2022</time>
    
  </p>

  <p>One thing I wish I had understood better earlier on in my experience with
PostgreSQL is how transactions and locks can be used together to provide
serializable logic.</p>
<p>An easy way to illustrate this is with a simple bank account system. Suppose we
create an <code>accounts</code> table and populate it like this:</p>
<div><pre><code data-lang="sql"><span>create</span><span> </span><span>table</span><span> </span><span>accounts</span><span> </span><span>(</span><span>
</span><span>  </span><span>name</span><span> </span><span>text</span><span> </span><span>primary</span><span> </span><span>key</span><span>,</span><span>
</span><span>  </span><span>balance</span><span> </span><span>int</span><span> </span><span>not</span><span> </span><span>null</span><span>
</span><span></span><span>);</span><span>
</span><span></span><span>insert</span><span> </span><span>into</span><span> </span><span>accounts</span><span> </span><span>(</span><span>name</span><span>,</span><span> </span><span>balance</span><span>)</span><span> </span><span>values</span><span> </span><span>(</span><span>&#39;A&#39;</span><span>,</span><span> </span><span>10</span><span>),</span><span> </span><span>(</span><span>&#39;B&#39;</span><span>,</span><span> </span><span>0</span><span>);</span><span>
</span></code></pre></div><p>Now we have two bank accounts, <code>A</code> with a balance of $10, and <code>B</code> with a balance
of $0.</p>
<p>In order to be a <em>useful</em> bank, we want to be able to move money from one
account to another. In pseudocode, the way to move money from one account to
another might look something like:</p>
<pre><code>function moveMoney(from, to, amount):
  # Start a transaction.
  txn = db.begin()
  # Update the balances.
  txn.execute(&#39;update accounts set balance = balance - $amount where name = $from&#39;)
  txn.execute(&#39;update accounts set balance = balance + $amount where name = $to&#39;)
  # Commit the transaction.
  txn.commit()
</code></pre><p>We use a transaction here to make sure that either both updates succeed, or both
updates fail. In other words, we want to avoid the situation where money is
deducted from <code>A</code> but never deposited to <code>B</code>.</p>
<p>There’s another situation that we might want to avoid in our bank too: we might
want a rule that account balances can never be negative. To enforce this rule,
we can update our <code>moveMoney</code> function:</p>
<pre><code>function moveMoney(from, to, amount):
  # Moving a negative amount of money from A to B is equivalent to moving the
  # corresponding positive amount from B to A.
  if amount &lt; 0:
    moveMoney(to, from, -1*amount)
    return

  # Start a transaction so that all of our queries/updates succeed or fail as a
  # unit.
  txn = db.begin()

  # Make sure the $from account has a balance of at least $amount.
  currBalance = txn.query(&#39;select balance from accounts where name = $from&#39;)
  if currBalance &lt; amount:
    txn.rollback()
    throw exception

  # Move the money as before.
  txn.execute(&#39;update accounts set balance = balance - $amount where name = $from&#39;)
  txn.execute(&#39;update accounts set balance = balance + $amount where name = $to&#39;)

  # Commit the transaction.
  txn.commit()
</code></pre><p>But there’s a problem with this! Using a transaction only ensures that all of
the writes succeed or fail together, it does <em>not</em> provide any guarantees that
all of the statements in the transaction execute “at the same time” (i.e. the
transactions are not <em>serializable</em>).</p>
<h2 id="preventing-concurrency-bugs">Preventing concurrency bugs</h2>
<p>Let’s simulate two different actors calling <code>moveMoney(&#39;A&#39;, &#39;B&#39;, 10)</code>
concurrently, again with <code>A</code> having an initial balance of $10 and <code>B</code> having $0:</p>
<table>
<thead>
<tr>
<th>Actor 1</th>
<th>Actor 2</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>begin</code></td>
<td></td>
</tr>
<tr>
<td><code>select balance from accounts where name = &#39;A&#39;</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>begin</code></td>
</tr>
<tr>
<td></td>
<td><code>select balance from accounts where name = &#39;A&#39;</code></td>
</tr>
<tr>
<td><code>update accounts set balance = balance - 10 where name = &#39;A&#39;</code></td>
<td></td>
</tr>
<tr>
<td><code>update accounts set balance = balance + 10 where name = &#39;B&#39;</code></td>
<td></td>
</tr>
<tr>
<td><code>commit</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>update accounts set balance = balance - 10 where name = &#39;A&#39;</code></td>
</tr>
<tr>
<td></td>
<td><code>update accounts set balance = balance + 10 where name = &#39;B&#39;</code></td>
</tr>
<tr>
<td></td>
<td><code>commit</code></td>
</tr>
</tbody>
</table>
<p>Now, if we check the account balances, we can see a problem:</p>
<pre><code>postgres=# select * from accounts ;
 name | balance
------+---------
 A    |     -10
 B    |      20
</code></pre><p>Both actors read the initial balance as $10, and therefore allowed the
operations to proceed. The transaction is ensuring that $10 is deducted from <code>A</code>
<em>if and only if</em> $10 is deposited into <code>B</code>, but two transactions can still be
reading and making decisions based on the same data concurrently.</p>
<p>(PostgreSQL by default does <em>not</em> allow two transactions to <em>write</em> the same
data concurrently; after Actor 1 updates <code>A</code>’s balance, Actor 2 isn’t able to
update <code>A</code>’s balance until after the first transaction is committed or rolled
back.)</p>
<h2 id="check-constraints"><code>check</code> constraints</h2>
<p>There are a few ways we can fix this. One way would be to add a check
constraint:</p>
<div><pre><code data-lang="sql"><span>alter</span><span> </span><span>table</span><span> </span><span>accounts</span><span> </span><span>add</span><span> </span><span>constraint</span><span> </span><span>nonnegative_balance</span><span> </span><span>check</span><span> </span><span>(</span><span>balance</span><span> </span><span>&gt;=</span><span> </span><span>0</span><span>);</span><span>
</span></code></pre></div><p>With this constraint, Actor 2’s <code>update</code> will fail because the constraint would
be violated. In fact, we would no longer even need to check the previous balance
in our application code at all, because the database itself would ensure no
account’s balance ever goes below zero.</p>
<h2 id="table-locks">Table locks</h2>
<p>Another approach would be to use a lock. Before we start reading or writing data
from the <code>accounts</code> table, we can use a lock to ensure that our transaction has
exclusive access to that table until we roll back or commit:</p>
<div><pre><code data-lang="diff"> begin;
<span>+lock table accounts;
</span><span></span> select balance from accounts where name = &#39;A&#39;;
 update accounts set balance = balance - 10 where name = &#39;A&#39;;
 update accounts set balance = balance + 10 where name = &#39;B&#39;;
 commit;
</code></pre></div><p>The <code>lock table accounts</code> statement will not finish until no other transactions
have any locks on the <code>accounts</code> table, and will prevent all other transactions
from accessing the <code>accounts</code> table until our transaction is committed or rolled
back.</p>
<h2 id="row-locks">Row locks</h2>
<p>Locking the entire accounts table is an effective way to prevent overdrawing an
account, but it also needlessly slows down our banking program. If someone is
trying to move money from <code>A</code> to <code>B</code> while someone else is trying to move money
from <code>B</code> to <code>C</code>, the second person’s transaction won’t be able to start until
the first transaction completes, even though they’re touching different
accounts.</p>
<p>Luckily, rather than acquiring a lock on the entire table, we can just acquire a
lock on the row that we’re deducting money from. To do this, we can use <code>for update</code> at the end of our <code>select</code> statement:</p>
<div><pre><code data-lang="sql"><span>select</span><span> </span><span>balance</span><span> </span><span>from</span><span> </span><span>accounts</span><span> </span><span>where</span><span> </span><span>name</span><span> </span><span>=</span><span> </span><span>&#39;A&#39;</span><span> </span><span>for</span><span> </span><span>update</span><span>;</span><span>
</span></code></pre></div><p>Now, other transactions won’t be able to read this row until our transaction is
committed or rolled back (<code>for update</code> can only be used inside a transaction).</p>
<h2 id="transaction-isolation-levels">Transaction isolation levels</h2>
<p>One other way to ensure that we don’t overdraw an account is to change the
isolation level of the transaction:</p>
<div><pre><code data-lang="sql"><span>begin</span><span> </span><span>transaction</span><span> </span><span>isolation</span><span> </span><span>level</span><span> </span><span>serializable</span><span>;</span><span>
</span><span></span><span>select</span><span> </span><span>balance</span><span> </span><span>from</span><span> </span><span>accounts</span><span> </span><span>where</span><span> </span><span>name</span><span> </span><span>=</span><span> </span><span>&#39;A&#39;</span><span>;</span><span>
</span><span></span><span>update</span><span> </span><span>accounts</span><span> </span><span>set</span><span> </span><span>balance</span><span> </span><span>=</span><span> </span><span>balance</span><span> </span><span>-</span><span> </span><span>10</span><span> </span><span>where</span><span> </span><span>name</span><span> </span><span>=</span><span> </span><span>&#39;A&#39;</span><span>;</span><span>
</span><span></span><span>update</span><span> </span><span>accounts</span><span> </span><span>set</span><span> </span><span>balance</span><span> </span><span>=</span><span> </span><span>balance</span><span> </span><span>+</span><span> </span><span>10</span><span> </span><span>where</span><span> </span><span>name</span><span> </span><span>=</span><span> </span><span>&#39;B&#39;</span><span>;</span><span>
</span><span></span><span>commit</span><span>;</span><span>
</span></code></pre></div><p>The PostgreSQL manual has <a href="https://www.postgresql.org/docs/12/sql-set-transaction.html">a good description of <code>serializable</code></a>:</p>
<blockquote>
<p>If a pattern of reads and writes among concurrent serializable transactions
would create a situation which could not have occurred for any serial
(one-at-a-time) execution of those transactions, one of them will be rolled
back with a <code>serialization_failure</code> error.</p>
</blockquote>
<p>Where a row or table lock would prevent a second transaction from reading the
balance until the previous transaction committed, with <code>isolation level serializable</code> the second transaction would immediately fail with an error
message: “could not serialize access due to concurrent update.”</p>
<p>There’s a good explanation of the “serializable” consistency model—and how it
differs from other models—<a href="https://jepsen.io/consistency">on the Jepsen site</a>.</p>


  <hr/>

  

  


  
  

  
  
    
  



</div></div>
  </body>
</html>
