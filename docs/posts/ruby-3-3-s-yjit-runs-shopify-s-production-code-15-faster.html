<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://railsatscale.com/2023-09-18-ruby-3-3-s-yjit-runs-shopify-s-production-code-15-faster/">Original</a>
    <h1>Ruby 3.3&#39;s YJIT Runs Shopify&#39;s Production Code 15% Faster</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    

<p>Shopify deploys YJIT on business-critical services in production,
such as <a href="https://shopify.engineering/how-shopify-reduced-storefront-response-times-rewrite">Storefront Renderer</a>,
the software that powers all online storefronts on Shopify’s platform, and <a href="https://shopify.engineering/shopify-monolith">Shopify’s Monolith</a>.
As of the Ruby 3.2 release, YJIT sped up our Storefront Renderer by <a href="https://twitter.com/paracycle/status/1605706245955997697">10% on average</a>.</p>

<p>Storefront Renderer is a complex application. Your more reasonable-sized app might get better/worse results.
Here are some other YJIT performance results in production outside Shopify:</p>

<ul>
  <li>Discourse: <a href="https://blog.discourse.org/2023/05/running-ruby-3-2s-yjit-in-production-at-discourse/">15.8-19.6% speedup</a></li>
  <li>Lobsters: <a href="https://lobste.rs/s/m9ivcf/we_turned_lobste_rs_into_rails_benchmark#c_fkud5w">26% speedup</a></li>
  <li>CompanyCam: <a href="https://ruby.social/@mcphat/111075935007519631">20-40% speedup</a></li>
  <li>GMO Pepabo: <a href="https://shimoju.jp/2023/08/10/ruby-3-2-yjit-with-rails-6-1/">18% speedup</a> (in Japanese)</li>
  <li>Timee: <a href="https://tech.timee.co.jp/entry/2023/05/10/133000">10% speedup</a> (in Japanese)</li>
  <li>STORES: <a href="https://product.st.inc/entry/2023/05/31/130809">6.5-7.5% speedup</a> (in Japanese)</li>
  <li>MedPeer: <a href="https://tech.medpeer.co.jp/entry/2023/05/09/100000">2.8% speedup</a> (in Japanese)</li>
</ul>

<h2 id="performance-tips-for-production-deployments">Performance Tips for Production Deployments</h2>
<p>We sometimes hear people say YJIT doesn’t speed up their application or uses too much memory.
The following documentation covers some tips for tuning YJIT in such cases.</p>

<ul>
  <li><a href="https://github.com/ruby/ruby/blob/master/doc/yjit/yjit.md#performance-tips-for-production-deployments">Performance Tips for Production Deployments</a></li>
  <li><a href="https://github.com/ruby/ruby/blob/master/doc/yjit/yjit.md#saving-yjit-memory-usage">Saving YJIT Memory Usage</a></li>
</ul>

<p><a href="https://railsatscale.com/2023-06-05-monitoring-yjit-in-production/">Monitoring YJIT in Production</a>
might also help you get more insight.</p>


<p><a href="https://www.ruby-lang.org/en/news/2023/09/14/ruby-3-3-0-preview2-released/">Ruby 3.3.0-preview2 has been released</a>
on Sep 14th, 2023. We compared the performance of Ruby 3.2 YJIT, Ruby 3.3-preview2 YJIT, and Ruby 3.3-preview2 interpreter
on the Storefront Renderer. It’s a large-scale service with the following properties:</p>

<ul>
  <li>Depends on over 220 Ruby gems</li>
  <li>Over 4.5 million e-commerce sites are built with Shopify (source: <a href="https://builtwith.com/">builtwith.com</a>)</li>
  <li>Capable of serving over 75 million requests per minute, 3TB/minute of traffic</li>
  <li>1.27 million requests per second</li>
  <li>Processed over 197B$ in transaction volume in 2022</li>
</ul>

<h2 id="ruby-33-yjit-is-13-faster-than-ruby-32-yjit">Ruby 3.3 YJIT is 13% faster than Ruby 3.2 YJIT</h2>

<p>We deployed Ruby 3.2.2 YJIT and Ruby 3.3.0-preview2 YJIT to different clusters that receive an equal amount of traffic.
We compared their response times in a 24-hour window on a weekday.</p>

<p><img src="https://railsatscale.com/2023-09-18-ruby-3-3-s-yjit-runs-shopify-s-production-code-15-faster/3.2-3.3-yjit.png" alt="Ruby 3.3 YJIT vs Ruby 3.2 YJIT"/></p>

<p>The numbers and the graph show Ruby 3.3.0-preview2 YJIT’s average/p50/p90/p99 response time speedup ratio over
Ruby 3.2.2 YJIT’s. Higher is better for Ruby 3.3.0-preview2 YJIT.</p>

<p>This shows that Ruby 3.3.0-preview2 YJIT is 13% faster than Ruby 3.2.2 YJIT on average.
If you’re using Ruby 3.2 YJIT, upgrading Ruby to 3.3 should give you a 13% speedup.</p>

<h2 id="ruby-33-yjit-is-15-faster-than-the-ruby-33-interpreter">Ruby 3.3 YJIT is 15% faster than the Ruby 3.3 interpreter</h2>

<p>During the same 24-hour window, we also deployed Ruby 3.3.0-preview2 interpreter to another cluster.
We compared its performance against that of the cluster with Ruby 3.3.0-preview2 YJIT.</p>

<p><img src="https://railsatscale.com/2023-09-18-ruby-3-3-s-yjit-runs-shopify-s-production-code-15-faster/3.3-interp-yjit.png" alt="Ruby 3.3 YJIT vs Ruby 3.3 interpreter"/></p>

<p>The numbers and the graph show Ruby 3.3.0-preview2 YJIT’s average/p50/p90/p99 response time speedup ratio over
Ruby 3.3.0-preview2 interpreter’s. Higher is better for Ruby 3.3.0-preview2 YJIT.</p>

<p>When you run Ruby 3.3 interpreter, just enabling YJIT will give you a 15% speedup.</p>

<h2 id="why-is-it-faster">Why is it faster?</h2>

<h3 id="new-register-allocator">New register allocator</h3>

<p>The CRuby interpreter writes and reads temporary values on memory.
Ruby 3.2 YJIT used to work in the same way for compatibility reasons,
but Ruby 3.3 YJIT is able to allocate registers to those operations.
In general, accessing CPU registers is much faster than communicating with memory,
so Ruby code runs faster with the optimization.</p>

<h3 id="more-code-now-gets-jit-compiled">More code now gets JIT compiled</h3>

<p>Ruby 3.3 YJIT supports compiling more kinds of Ruby code than Ruby 3.2 YJIT.
When a method has optional arguments, Ruby 3.2 YJIT compiles only one combination of parameter precenses,
but Ruby 3.3 YJIT handles multiple combinations.
Ruby 3.2 YJIT does not compile code that is executed after <code>break</code>, <code>next</code>, <code>redo</code>, <code>retry</code>, etc.,
but Ruby 3.3 YJIT does.
Ruby 3.2 YJIT gives up compiling a method call when it does not support the method call type,
but Ruby 3.3 YJIT falls back to an implementation that can handle anything.</p>

<p>In a nutshell, more code runs on JIT with Ruby 3.3 YJIT than Ruby 3.2 YJIT, so it’s faster.</p>

<h2 id="towards-the-ruby-330-release">Towards the Ruby 3.3.0 release</h2>

<h3 id="reducing-memory-overhead">Reducing memory overhead</h3>
<p>Since Ruby 3.3.0-preview2 YJIT generates more code than Ruby 3.2.2 YJIT, this can result in YJIT having a higher memory overlead.
We put a lot of effort into making metadata more space-efficient, but it still uses more memory than Ruby 3.2.2 YJIT.
We’re looking into skipping compilation of paths that are less frequently executed.</p>

<h3 id="optimizing-method-calls">Optimizing method calls</h3>
<p>Ruby’s method calls are complex. YJIT code spends a lot of time bookkeeping frames for method calls.
We’re working on making any method calls faster by packing frame metadata into a single pointer
and lazily materializing its fields when necessary. Hopefully, it will greatly speed up method calls
as well as reducing the code size.</p>



<p>Ruby 3.2 YJIT has optimized the production workloads of Shopify and other companies.
We encourage you to enable YJIT in production.
Once Ruby 3.3 is released, it should make your application even faster.</p>



<p><a href="https://github.com/ruby/ruby/blob/master/doc/yjit/yjit.md#command-line-options">This document</a> explains how to enable YJIT.
As a reminder, the following links may help you troubleshoot performance problems with YJIT.</p>

<ul>
  <li><a href="https://github.com/ruby/ruby/blob/master/doc/yjit/yjit.md#performance-tips-for-production-deployments">Performance Tips for Production Deployments</a></li>
  <li><a href="https://github.com/ruby/ruby/blob/master/doc/yjit/yjit.md#saving-yjit-memory-usage">Saving YJIT Memory Usage</a></li>
  <li><a href="https://railsatscale.com/2023-06-05-monitoring-yjit-in-production/">Monitoring YJIT in Production</a></li>
</ul>

  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
