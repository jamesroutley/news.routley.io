<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rtpg.co/2025/06/28/checking-out-sys-remote-exec/">Original</a>
    <h1>Checking Out CPython 3.14&#39;s remote debugging protocol</h1>
    
    <div id="readability-page-1" class="page"><article><p><blog-tip>
From Python 3.14, <code>python -m pdb -p pid</code> lets you connect a <code>pdb</code> session to a running Python process. </blog-tip></p>
<p>The barrier to entry for writing general debugging tools for Python programs has always been quite low. Unlike many languages, you&#39;re rarely finding yourself working with weird internals. Instead, debugging tools can be built off of pretty straightforward knowledge of the language.</p>
<p>This is powered by the languages treating things like exception tracebacks as first class objects, standard library modules like <code>traceback</code>, and of course the power of <code>eval</code>/<code>exec</code>.</p>
<p>And thanks to this, tools like <code>pdb</code> can be provided out of the box, and easily customized by people without much (if any) understanding of the internals of the language.</p>
<p>Some might comment that the existence of things like <code>pdb</code> have prevented Python programmers from &#34;simply&#34; learning how to use more universal debuggers like <code>gdb</code>/<code>lldb</code>. But I believe that loads of excellent REPL-based debugging experimentation happens because People can simply write tools like <code>ipdb</code> or <code>pdb++</code> in Python.</p>
<p>There&#39;s always been a bit of a catch, though. Generally these debugging tools require you first to edit your program source.</p>
<p>You can easily stick a:</p>
<div><pre><span></span><code><span>import</span><span> </span><span>pdb</span>
<span>pdb</span><span>.</span><span>set_trace</span><span>()</span>
</code></pre></div>

<p>right in the middle of your program near a problematic spot, or even set up an exception handler beforehand to capture outright exceptions. </p>
<p>But if you haven&#39;t done this work beforehand, you&#39;ll likely end up needing to edit your source code somehow, restart your program, and then go into it.</p>
<p>There are tools that can work without restarting the program. Beyond language agnostic debugging tools, tools like <code>pyspy</code> can work on running processes. But they are often relying on tricks and needing to know very specific details about CPython to work.</p>
<p>Python 3.14 offers some new functionality to standardize injecting some Python code to a running process. This should reduce the need for a lot of hacks.</p>
<p><code>sys.remote_exec</code> takes a process ID of an existing Python process, along with the path of a Python script.</p>
<p>Calling <code>sys.remote_exec(pid, script_path)</code> will signal to the remote process that we want it to run the script at <code>script_path</code> &#34;soon&#34;.</p>
<div><pre><span></span><code><span># remote-script.py</span>
<span>print</span><span>(</span><span>&#34;Hello there&#34;</span><span>)</span>

<span># assuming that you have a Python process</span>
<span># running at PID 95000</span>

<span># inside a Python REPL</span>
<span>import</span><span> </span><span>sys</span>
<span>sys</span><span>.</span><span>remote_Exec</span><span>(</span><span>95000</span><span>,</span> <span>&#34;remote-script.py&#34;</span><span>)</span>

<span># process 95000, once it has the opportunity to,</span>
<span># will read the remote-script.py file, and execute</span>
<span># the Python code it finds.</span>

<span># over in the process 95000&#39;s standard output</span>
<span>Hello</span> <span>there</span>
</code></pre></div>

<hr/>
<p>What does this look like in practice with a &#34;real&#34; program?</p>
<div><pre><span></span><code><span># hello.py</span>
<span>import</span><span> </span><span>time</span>
<span>import</span><span> </span><span>os</span>

<span>total</span> <span>=</span> <span>0</span>


<span>def</span><span> </span><span>add_to_total</span><span>(</span><span>value</span><span>):</span>
    <span>global</span> <span>total</span>
    <span>total</span> <span>+=</span> <span>value</span>
    <span># simulate slowness</span>
    <span>time</span><span>.</span><span>sleep</span><span>(</span><span>value</span><span>)</span>


<span>def</span><span> </span><span>main</span><span>():</span>
    <span>print</span><span>(</span><span>&#34;Number adder&#34;</span><span>)</span>
    <span>print</span><span>(</span><span>f</span><span>&#34;</span><span>{</span><span>os</span><span>.</span><span>getpid</span><span>()</span><span>=}</span><span>&#34;</span><span>)</span>

    <span>global</span> <span>total</span>

    <span>while</span> <span>True</span><span>:</span>
        <span>result</span> <span>=</span> <span>input</span><span>(</span><span>&#34;Give me an integer &gt;&gt;&#34;</span><span>)</span>
        <span>try</span><span>:</span>
            <span>result</span> <span>=</span> <span>int</span><span>(</span><span>result</span><span>)</span>
            <span>add_to_total</span><span>(</span><span>result</span><span>)</span>
            <span>print</span><span>(</span><span>f</span><span>&#34;The total is now </span><span>{</span><span>total</span><span>}</span><span>&#34;</span><span>)</span>
        <span>except</span> <span>ValueError</span><span>:</span>
            <span>print</span><span>(</span><span>&#34;Invalid input&#34;</span><span>)</span>


<span>if</span> <span>__name__</span> <span>==</span> <span>&#34;__main__&#34;</span><span>:</span>
    <span>main</span><span>()</span>
</code></pre></div>

<p>This program takes some integers as input, and calculates a cumulative sum. A very basic client-server program where you might wonder &#34;... what is the program doing and why am I waiting so long?&#34;</p>
<p>Running the program starts a &#34;REPL&#34; taking integers to add them up, printing out the PID.</p>
<div><pre><span></span><code>[1] % uv run python hello.py
Number adder 
os.getpid()=95700
Give me an integer &gt;&gt;3
The total is now 3
Give me an integer &gt;&gt;
</code></pre></div>

<p>The program is now waiting for input.</p>
<p>Over in <code>remote-script.py</code> we&#39;ll put in some code that we want to inject into the process. Here, we will just print out the stack to see what the program is doing. </p>
<div><pre><span></span><code><span>print</span><span>(</span><span>&#34;Hi from remote-script.py!&#34;</span><span>)</span>

<span>from</span><span> </span><span>traceback</span><span> </span><span>import</span> <span>print_stack</span>

<span>print_stack</span><span>()</span>
</code></pre></div>

<p>With my original program still running, I&#39;ve opened a Python REPL in a different shell, and run <code>sys.remote_exec</code>, pointing at the PID of my number adding process.</p>
<div><pre><span></span><code><span>&gt;&gt;&gt;</span> <span>import</span><span> </span><span>sys</span>
<span>&gt;&gt;&gt;</span> <span>sys</span><span>.</span><span>remote_exec</span><span>(</span><span>95700</span><span>,</span> <span>&#34;remote-script.py&#34;</span><span>)</span>
</code></pre></div>

<p>The call to <code>sys.remote_exec</code> returns immediately, but the remote process at first didn&#39;t seem to do anything, still waiting on another integer from me:</p>


<p>But once I actually provide an integer and return from the <code>input</code> call, I will see that my remote script runs.</p>
<div><pre><span></span><code><span>Give</span><span> </span><span>me</span><span> </span><span>an</span><span> </span><span>integer</span><span> </span><span>&gt;&gt;</span><span>5</span>
<span>Hi</span><span> </span><span>from</span><span> </span><span>remote</span><span>-</span><span>script</span>.<span>py</span><span>!</span>
<span>  </span><span>File</span><span> </span><span>&#34;/Users/rtpg/proj/remote-exec-sample/hello.py&#34;</span>,<span> </span><span>line</span><span> </span><span>30</span>,<span> </span><span>in</span><span> </span><span>&lt;</span><span>module</span><span>&gt;</span>
<span>    </span><span>main</span><span>()</span>
<span>  </span><span>File</span><span> </span><span>&#34;/Users/rtpg/proj/remote-exec-sample/hello.py&#34;</span>,<span> </span><span>line</span><span> </span><span>20</span>,<span> </span><span>in</span><span> </span><span>main</span>
<span>    </span><span>result</span><span> </span><span>=</span><span> </span><span>input</span><span>(</span><span>&#34;Give me an integer &gt;&gt;&#34;</span><span>)</span>
<span>  </span><span>File</span><span> </span><span>&#34;&lt;string&gt;&#34;</span>,<span> </span><span>line</span><span> </span><span>6</span>,<span> </span><span>in</span><span> </span><span>&lt;</span><span>module</span><span>&gt;</span>
<span>The</span><span> </span><span>total</span><span> </span><span>is</span><span> </span><span>now</span><span> </span><span>8</span>
<span>Give</span><span> </span><span>me</span><span> </span><span>an</span><span> </span><span>integer</span><span> </span><span>&gt;&gt;</span>
</code></pre></div>

<p>This behavior illustrates a couple of things:</p>
<ul>
<li>the remote script execution kicked in on the return from the call to <code>input</code>. </li>
</ul>
<p>The high level idea is that CPython&#39;s interpreter checks to see if any remote execution has been requested at specific points in the interpreter&#39;s main loop. So if your Python program is just waiting on external input, it&#39;s likely you&#39;re not making any progress in Python land... and so your remote script won&#39;t execute.</p>
<ul>
<li>the remote script execution happpens within the context of whatever&#39;s running at the moment</li>
</ul>
<p>our remote script&#39;s call to <code>print_stack</code> printed out a trace where we were within our program&#39;s <code>main</code>, and then the last frame is our script running inline. This means that you can very easily grasp what your program is doing, instead of your script being run in an isolated way</p>
<hr/>
<p>Even with the fact that you need to make <em>some</em> forward progress to get remote execution, given that many cases you will eventually yield back to Python, you hopefully will get some information by the time your remote script executes.</p>
<p>In the following continuation, I add 40. My script then calls <code>time.sleep(40)</code>. When I call <code>sys.remote_exec</code> during that sleep, the back trace doesn&#39;t appear until the end of that <code>sleep</code> call. But it did appear! </p>
<div><pre><span></span><code>Give me an integer &gt;&gt;40
Hi from remote-script.py!
  File &#34;/Users/rtpg/proj/remote-exec-sample/hello.py&#34;, line 30, in &lt;module&gt;
    main()
  File &#34;/Users/rtpg/proj/remote-exec-sample/hello.py&#34;, line 23, in main
    add_to_total(result)
  File &#34;/Users/rtpg/proj/remote-exec-sample/hello.py&#34;, line 10, in add_to_total
    time.sleep(value)
  File &#34;&lt;string&gt;&#34;, line 6, in &lt;module&gt;
The total is now 48
</code></pre></div>

<p>At this point the world is your oyster.</p>
<p>You could go spelunking for data in the remote process:</p>
<div><pre><span></span><code><span># figure out the total</span>

<span>import</span><span> </span><span>__main__</span>

<span>print</span><span>(</span><span>f</span><span>&#34;script saw value of </span><span>{</span><span>__main__</span><span>.</span><span>total</span><span>}</span><span>&#34;</span><span>)</span>
</code></pre></div>

<p>You could use a library like <code>remote_pdb</code> to set up an interactive debugging sessional:</p>
<div><pre><span></span><code><span># with remote_pdb needing to be installed ahead of time</span>

<span>import</span><span> </span><span>remote_pdb</span>
<span>remote_pdb</span><span>.</span><span>set_trace</span><span>()</span>
</code></pre></div>

<p>with this, when you call <code>sys.remote_exec</code> you&#39;ll see a prompt like: </p>
<div><pre><span></span><code><span>RemotePdb</span><span> </span><span>session</span><span> </span><span>open</span><span> </span><span>at</span><span> </span><span>127</span>.<span>0</span>.<span>0</span>.<span>1</span>:<span>51509</span>,<span> </span><span>waiting</span><span> </span><span>for</span><span> </span><span>connection</span><span> </span>...
</code></pre></div>

<p>You can then connect to the <code>pdb</code> session with <code>netcat</code>, and have your interactive debugging session.</p>
<p>You might think that this is too many steps. If you&#39;re already on the same host, you can run <code>python -m pdb -p pid</code> to get a shell into a running process directly! To state the obvious, though: this will suspend your running process! Maybe not a great thing to do in production. </p>
<p><blog-warning>
Remember how we called <code>traceback.print_stack()</code> in our example? That <em>won&#39;t</em> suspend the running process! Scripts that dump state and do nothing else, when done carefully, pose a lot less risk to the running process.</blog-warning></p>
<p>But even without the CPython team showing up to build the debugger, you could build out something like support for <code>pdb -p pid</code> yourself!</p>
<p>Being able to do this kind of script injection in a fully supported way, thanks to CPython providing both the right kind of hooks and a reference implementation means that the barrier to entry for writing tools are lower than ever.</p>
<p>Some reading:</p>
<ul>
<li>
<p>The <a href="https://docs.python.org/3.14/howto/remote_debugging.html">remote debug attachment protocol HOWTO</a>. This describes what you need to do to implement something like <code>sys.remote_exec</code>. Valuable if you intend </p>
</li>
<li>
<p><a href="https://peps.python.org/pep-0768/">PEP 768 â€“ Safe external debugger interface for CPython</a>. This is the original PEP for this functionality. Includes links to existing hacks and details on how this works</p>
</li>
</ul></article></div>
  </body>
</html>
