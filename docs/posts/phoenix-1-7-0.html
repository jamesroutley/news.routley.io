<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.phoenixframework.org/blog/phoenix-1.7-final-released">Original</a>
    <h1>Phoenix 1.7.0</h1>
    
    <div id="readability-page-1" class="page"><div>

  <!-- Title -->
  

  <!-- Author -->
  <p>
    Posted on February 24th, 2023 by Chris McCord
  </p>

  <hr/>

  <!-- Post Content -->
  <p>
The final release of Phoenix 1.7 is out! Phoenix 1.7 packs a number of long-awaited new features like verified routes, Tailwind support, LiveView authentication generators, unified HEEx templates, LiveView Streams for optimized collections, and more. This is a backwards compatible release with a few deprecations. Most folks should be able to update just by changing a couple dependencies.</p>
<p>
<strong>Note</strong>: To generate a new 1.7 project, you’ll need to install the <code>phx.new</code> generator from hex:</p>
<pre><code>mix archive.install hex phx_new</code></pre>
<h2>
Verified Routes</h2>
<p>
Verified routes replace router helpers with a sigil-based (<code>~p</code>), compile-time verified approach.</p>
<blockquote>
  <p>
<strong>note</strong>: Verified routes make use of new Elixir 1.14 compiler features. Phoenix still supports older Elixir versions, but you’ll need to update to enjoy the new compile-time verification features.  </p>
</blockquote>
<p>
In practice this means where before you used autogenerated functions like:</p>
<pre><code><span>  </span><span># router</span><span>
  </span><span>get</span><span> </span><span>&#34;/oauth/callbacks/:id&#34;</span><span>,</span><span> </span><span>OAuthCallbackController</span><span>,</span><span> </span><span>:new</span><span>

  </span><span># usage</span><span>
  </span><span>MyRouter.Helpers</span><span>.</span><span>o_auth_callback_path</span><span data-group-id="7621315644-1">(</span><span>conn</span><span>,</span><span> </span><span>:new</span><span>,</span><span> </span><span>&#34;github&#34;</span><span data-group-id="7621315644-1">)</span><span>
  </span><span># =&gt; &#34;/oauth/callbacks/github&#34;</span><span>

  </span><span>MyRouter.Helpers</span><span>.</span><span>o_auth_callback_url</span><span data-group-id="7621315644-2">(</span><span>conn</span><span>,</span><span> </span><span>:new</span><span>,</span><span> </span><span>&#34;github&#34;</span><span data-group-id="7621315644-2">)</span><span>
  </span><span># =&gt; &#34;http://localhost:4000/oauth/callbacks/github&#34;</span></code></pre>
<p>
You can now do:</p>
<pre><code><span>  </span><span># router</span><span>
  </span><span>get</span><span> </span><span>&#34;/oauth/callbacks/:id&#34;</span><span>,</span><span> </span><span>OAuthCallbackController</span><span>,</span><span> </span><span>:new</span><span>

  </span><span># usage</span><span>
  </span><span>~p&#34;/oauth/callbacks/github&#34;</span><span>
  </span><span># =&gt; &#34;/oauth/callbacks/github&#34;</span><span>

  </span><span>url</span><span data-group-id="8376074092-1">(</span><span>~p&#34;/oauth/callbacks/github&#34;</span><span data-group-id="8376074092-1">)</span><span>
  </span><span># =&gt; &#34;http://localhost:4000/oauth/callbacks/github&#34;</span></code></pre>
<p>
This has a number of advantages. There’s no longer guesswork on which function was inflected – is it <code>Helpers.oauth_callback_path</code> or <code>o_auth_callback_path</code>, etc. You also no longer need to include the <code>%Plug.Conn{}</code>, or <code>%Phoenix.Socket{}</code>, or endpoint module everywhere when 99% of the time you know which endpoint configuration should be used.</p>
<p>
There is also now a 1:1 mapping between the routes you write in the router, and how you call them with <code>~p</code>. You simply write it as if you’re hard-coding strings everywhere in your app – except you don’t have maintenance issues that come with hardcoding strings. We can get the best of both worlds with ease of use and maintenance because <code>~p</code> is a compile-time verified against the routes in your router.</p>
<p>
For example, imagine we typo a route:</p>
<pre><code><span data-group-id="9664323496-out-1">&lt;</span><span>.link</span><span> </span><span>href</span><span>=</span><span data-group-id="9664323496-1">{</span><span>~p&#34;/userz/profile&#34;</span><span data-group-id="9664323496-1">}</span><span>&gt;</span><span>Profile</span><span data-group-id="9664323496-out-2">&lt;/</span><span>.link</span><span data-group-id="9664323496-out-2">&gt;</span></code></pre>
<p>
The compiler will dispatch all <code>~p</code>‘s at compile-time against your router, and let you know when it can’t find a matching route:</p>
<pre><code>    warning: no route path for AppWeb.Router matches &#34;/postz/#{post}&#34;
      lib/app_web/live/post_live.ex:100: AppWeb.PostLive.render/1</code></pre>
<p>
Dynamic “named params” are also simply interpolated like a regular string, instead of arbitrary function arguments:</p>
<pre><code><span>~p&#34;/posts/</span><span data-group-id="9249337929-1">#{</span><span>post</span><span>.</span><span>id</span><span data-group-id="9249337929-1">}</span><span>&#34;</span></code></pre>
<p>
Additionally, interpolated <code>~p</code> values are encoded via the <code>Phoenix.Param</code> protocol.
For example, a <code>%Post{}</code> struct in your application may derive the <code>Phoenix.Param</code>
protocol to generate slug-based paths rather than ID based ones. This allows you to
use <code>~p&#34;/posts/#{post}&#34;</code> rather than <code>~p&#34;/posts/#{post.slug}&#34;</code> throughout your
application.</p>
<p>
Query strings are also supported in verified routes, either in traditional query
string form:</p>
<pre><code><span>~p&#34;/posts?page=</span><span data-group-id="1578421033-1">#{</span><span>page</span><span data-group-id="1578421033-1">}</span><span>&#34;</span></code></pre>
<p>
Or as a keyword list or map of values:</p>
<pre><code><span>params</span><span> </span><span>=</span><span> </span><span data-group-id="6577928503-1">%{</span><span>page</span><span>:</span><span> </span><span>1</span><span>,</span><span> </span><span>direction</span><span>:</span><span> </span><span>&#34;asc&#34;</span><span data-group-id="6577928503-1">}</span><span>
</span><span>~p&#34;/posts?</span><span data-group-id="6577928503-2">#{</span><span>params</span><span data-group-id="6577928503-2">}</span><span>&#34;</span></code></pre>
<p>
Like path segments, query strings params are proper URL encoded and may be interpolated
directly into the <code>~p</code> string.</p>
<p>
Once you try out the new feature, you won’t be able to go back to router helpers. The new <code>phx.gen.html|live|json|auth</code> generators use verified routes.</p>
<h2>
Component-based Tailwind generators</h2>
<p>
Phoenix 1.7 ships with <a href="https://tailwindcss.com">TailwindCSS</a> by default, with no dependency on nodejs on the system. TailwindCSS is the best way I’ve found to style interfaces in my 20 years of web development. Its utility-first approach is far more maintainable and productive than any CSS system or framework I’ve used. It’s collocated approach also aligns perfectly within the function component and LiveView landscape.</p>
<p>
The Tailwind team also generously designed the new project landing page, CRUD pages, and authentication system pages for new projects, giving you a first-class and polished starting point for building out your apps.</p>
<p>
A new <code>phx.new</code> project will contain a <code>CoreComponents</code> module, housing a core set of UI components like tables, modals, forms, and data lists. The suite of Phoenix generators (<code>phx.gen.html|live|json|auth</code>) make use of the core components. This has a number of neat advantages.</p>
<p>
First, you can customize your core UI components to suit whatever needs, designs, and tastes that you have. If you want to use Bulma or Bootstrap instead of Tailwind – no problem! Simply replace the function definitions in <code>core_components.ex</code> with your framework/UI specific implementations and the generators continue to provide a great starting point for new features whether you’re a beginner, or seasoned expert building bespoke product features.</p>
<p>
In practice, the generators give you templates that make use of your core components, which look like this:</p>
<pre><code><span data-group-id="3591729030-out-1">&lt;</span><span>.header</span><span data-group-id="3591729030-out-1">&gt;</span><span>
  New Post
  </span><span data-group-id="3591729030-out-2">&lt;</span><span>:subtitle</span><span data-group-id="3591729030-out-2">&gt;</span><span>Use this form to manage post records in your database.</span><span data-group-id="3591729030-out-3">&lt;/</span><span>:subtitle</span><span data-group-id="3591729030-out-3">&gt;</span><span>
</span><span data-group-id="3591729030-out-4">&lt;/</span><span>.header</span><span data-group-id="3591729030-out-4">&gt;</span><span>

</span><span data-group-id="3591729030-out-5">&lt;</span><span>.simple_form</span><span> </span><span>for</span><span>=</span><span data-group-id="3591729030-1">{</span><span>@form</span><span data-group-id="3591729030-1">}</span><span> </span><span>action</span><span>=</span><span data-group-id="3591729030-2">{</span><span>~p&#34;/posts&#34;</span><span data-group-id="3591729030-2">}</span><span>&gt;</span><span>
  </span><span data-group-id="3591729030-out-6">&lt;</span><span>input</span><span> </span><span>field</span><span>=</span><span data-group-id="3591729030-3">{</span><span>@form</span><span data-group-id="3591729030-ex-1">[</span><span>:title</span><span data-group-id="3591729030-ex-1">]</span><span data-group-id="3591729030-3">}</span><span> </span><span>type</span><span>=</span><span>&#34;text&#34;</span><span> </span><span>label</span><span>=</span><span>&#34;Title&#34;</span><span> </span><span data-group-id="3591729030-out-6">/&gt;</span><span>
  </span><span data-group-id="3591729030-out-7">&lt;</span><span>input</span><span> </span><span>field</span><span>=</span><span data-group-id="3591729030-4">{</span><span>@form</span><span data-group-id="3591729030-ex-2">[</span><span>:views</span><span data-group-id="3591729030-ex-2">]</span><span data-group-id="3591729030-4">}</span><span> </span><span>type</span><span>=</span><span>&#34;number&#34;</span><span> </span><span>label</span><span>=</span><span>&#34;Views&#34;</span><span> </span><span data-group-id="3591729030-out-7">/&gt;</span><span>

  </span><span data-group-id="3591729030-out-8">&lt;</span><span>:actions</span><span data-group-id="3591729030-out-8">&gt;</span><span>
    </span><span data-group-id="3591729030-out-9">&lt;</span><span>.button</span><span data-group-id="3591729030-out-9">&gt;</span><span>Save Post</span><span data-group-id="3591729030-out-10">&lt;/</span><span>.button</span><span data-group-id="3591729030-out-10">&gt;</span><span>
  </span><span data-group-id="3591729030-out-11">&lt;/</span><span>:actions</span><span data-group-id="3591729030-out-11">&gt;</span><span>
</span><span data-group-id="3591729030-out-12">&lt;/</span><span>.simple_form</span><span data-group-id="3591729030-out-12">&gt;</span><span>

</span><span data-group-id="3591729030-out-13">&lt;</span><span>.back</span><span> </span><span>navigate</span><span>=</span><span data-group-id="3591729030-5">{</span><span>~p&#34;/posts&#34;</span><span data-group-id="3591729030-5">}</span><span data-group-id="3591729030-out-13">&gt;</span><span>Back to posts</span><span data-group-id="3591729030-out-5">&gt;</span><span data-group-id="3591729030-out-14">&lt;/</span><span>.back</span><span data-group-id="3591729030-out-14">&gt;</span></code></pre>
<p>
We love what the Tailwind team designed for new applications, but we also can’t wait to see the community release their own drop-in replacements for <code>core_components.ex</code> for various frameworks of choice.</p>
<h2>
Unified function components across Controllers and LiveViews</h2>
<p>
Function components provided by HEEx, with declarative assigns and slots, are massive step-change in the way we write HTML in Phoenix projects. Function components provide UI building blocks, allowing features to be encapsulated and better extended over the previous template approach in <code>Phoenix.View</code>. You get a more natural way to write dynamic markup, reusable UI that can be extended by the caller, and compile-time features to make writing HTML-based applications a truly first-class experience.</p>
<p>
Function components bring a new way to write HTML applications in Phoenix, with new sets of conventions. Additionally, users have struggled with how to marry controller-based <code>Phoenix.View</code> features with <code>Phoenix.LiveView</code> features in their applications. Users found themselves writing <code>render(&#34;table&#34;, user: user)</code> in controller-based templates, while their LiveViews made use of the new <code>&lt;.table rows={@users}&gt;</code> features. There was no great way to share the approaches in an application.</p>
<p>
For these reasons, the Phoenix team unified the HTML rendering approaches whether from a controller request, or a LiveView. This shift also allowed us to revisit conventions and align with the LiveView approach of collocating templates and app code together.</p>
<p>
New applications (and the phx generators), remove <code>Phoenix.View</code> as a dependency in favor of a new <code>Phoenix.Template</code> dependency, which uses function components as the basis for all rendering in the framework.</p>
<p>
Your controllers still look the same:</p>
<pre><code><span>defmodule</span><span> </span><span>AppWeb.UserController</span><span> </span><span data-group-id="9224728819-1">do</span><span>
  </span><span>use</span><span> </span><span>MyAppWeb</span><span>,</span><span> </span><span>:controller</span><span>

  </span><span>def</span><span> </span><span>index</span><span data-group-id="9224728819-2">(</span><span>conn</span><span>,</span><span> </span><span>_params</span><span data-group-id="9224728819-2">)</span><span> </span><span data-group-id="9224728819-3">do</span><span>
    </span><span>users</span><span> </span><span>=</span><span> </span><span>...</span><span>
    </span><span>render</span><span data-group-id="9224728819-4">(</span><span>conn</span><span>,</span><span> </span><span>:index</span><span>,</span><span> </span><span>users</span><span>:</span><span> </span><span>users</span><span data-group-id="9224728819-4">)</span><span>
  </span><span data-group-id="9224728819-3">end</span><span>
</span><span data-group-id="9224728819-1">end</span></code></pre>
<p>
But instead of the controller calling <code>AppWeb.UserView.render(&#34;index.html&#34;, assigns)</code>, we’ll now first look for an <code>index/1</code> function component on the view module, and call that for rendering if it exists. Additionally, we also renamed the inflected view module to look for <code>AppWeb.UserHTML</code>, or <code>AppWeb.UserJSON</code>, and so on for a view-per-format approach for rendering templates. This is all done in backwards compatible way, and is opt-in based on options to <code>use Phoenix.Controller</code>.</p>
<p>
All HTML rendering is then based on function components, which can be written directly in a module, or embedded from an external file with the new <code>embed_templates</code> macro provided by <code>Phoenix.Component</code>. Your <code>PageHTML</code> module in a new application looks like this:</p>
<pre><code><span>defmodule</span><span> </span><span>AppWeb.PageHTML</span><span> </span><span data-group-id="4046365788-1">do</span><span>
  </span><span>use</span><span> </span><span>AppWeb</span><span>,</span><span> </span><span>:html</span><span>

  </span><span>embed_templates</span><span> </span><span>&#34;page_html/*&#34;</span><span>
</span><span data-group-id="4046365788-1">end</span></code></pre>
<p>
The new directory structure will look something like this:</p>
<pre><code>lib/app_wb
├── controllers
│   ├── page_controller.ex
│   ├── page_html.ex
│   ├── error_html.ex
│   ├── error_json.ex
│   └── page_html
│       └── home.html.heex
├── live
│   ├── home_live.ex
├── components
│   ├── core_components.ex
│   ├── layouts.ex
│   └── layouts
│       ├── app.html.heex
│       └── root.html.heex
├── endpoint.ex
└── router.ex</code></pre>
<p>
Your controllers-based rendering or LiveView-based rendering now all share the same function components and layouts. Whether running <code>phx.gen.html</code>, <code>phx.gen.live</code>, or <code>phx.gen.auth</code>, the new generated templates all make use of your <code>components/core_components.ex</code> definitions.</p>
<p>
Additionally, we have collocated the view modules next to their controller files. This brings the same benefits of LiveView collocation – highly coupled files live together. Files that must change together now live together, whether writing LiveView or controller features.</p>
<p>
These changes were all about a better way to write HTML-based applications, but they also simplified rendering other formats, like JSON. For example, JSON based view modules follow the same conventions – Phoenix will first look for an <code>index/1</code> function when rendering the index template, before trying <code>render/2</code>. This allowed us to simplify JSON rendering in general and do away with concepts like <code>Phoenix.View.render_one|render_many</code>.</p>
<p>
For example, this is a JSON view generated by <code>phx.gen.json</code>:</p>
<pre><code><span>defmodule</span><span> </span><span>AppWeb.PostJSON</span><span> </span><span data-group-id="4031261121-1">do</span><span>
  </span><span>alias</span><span> </span><span>AppWeb.Blog.Post</span><span>

  </span><span>@doc</span><span> </span><span>&#34;&#34;&#34;
  Renders a list of posts.
  &#34;&#34;&#34;</span><span>
  </span><span>def</span><span> </span><span>index</span><span data-group-id="4031261121-2">(</span><span data-group-id="4031261121-3">%{</span><span>posts</span><span>:</span><span> </span><span>posts</span><span data-group-id="4031261121-3">}</span><span data-group-id="4031261121-2">)</span><span> </span><span data-group-id="4031261121-4">do</span><span>
    </span><span data-group-id="4031261121-5">%{</span><span>data</span><span>:</span><span> </span><span>for</span><span data-group-id="4031261121-6">(</span><span>post</span><span> </span><span>&lt;-</span><span> </span><span>posts</span><span>,</span><span> </span><span>do</span><span>:</span><span> </span><span>data</span><span data-group-id="4031261121-7">(</span><span>post</span><span data-group-id="4031261121-7">)</span><span data-group-id="4031261121-6">)</span><span data-group-id="4031261121-5">}</span><span>
  </span><span data-group-id="4031261121-4">end</span><span>

  </span><span>@doc</span><span> </span><span>&#34;&#34;&#34;
  Renders a single post.
  &#34;&#34;&#34;</span><span>
  </span><span>def</span><span> </span><span>show</span><span data-group-id="4031261121-8">(</span><span data-group-id="4031261121-9">%{</span><span>post</span><span>:</span><span> </span><span>post</span><span data-group-id="4031261121-9">}</span><span data-group-id="4031261121-8">)</span><span> </span><span data-group-id="4031261121-10">do</span><span>
    </span><span data-group-id="4031261121-11">%{</span><span>data</span><span>:</span><span> </span><span>data</span><span data-group-id="4031261121-12">(</span><span>post</span><span data-group-id="4031261121-12">)</span><span data-group-id="4031261121-11">}</span><span>
  </span><span data-group-id="4031261121-10">end</span><span>

  </span><span>defp</span><span> </span><span>data</span><span data-group-id="4031261121-13">(</span><span data-group-id="4031261121-14">%</span><span data-group-id="4031261121-14">Post</span><span data-group-id="4031261121-14">{</span><span data-group-id="4031261121-14">}</span><span> </span><span>=</span><span> </span><span>post</span><span data-group-id="4031261121-13">)</span><span> </span><span data-group-id="4031261121-15">do</span><span>
    </span><span data-group-id="4031261121-16">%{</span><span>
      </span><span>id</span><span>:</span><span> </span><span>post</span><span>.</span><span>id</span><span>,</span><span>
      </span><span>title</span><span>:</span><span> </span><span>post</span><span>.</span><span>title</span><span>
    </span><span data-group-id="4031261121-16">}</span><span>
  </span><span data-group-id="4031261121-15">end</span><span>
</span><span data-group-id="4031261121-1">end</span></code></pre>
<p>
Notice how it’s all simply regular Elixir functions – as it should be!</p>
<p>
These features provide a unified rendering model for applications going forward with a new and improved way to write UIs, but they are a deviation from previous practices. Most large, established applications are probably best served by continuing to depend on <code>Phoenix.View</code>.</p>
<h2>
LiveView Streams</h2>
<p>
LiveView now includes a streaming interface for managing large collections in the UI without having to store the collections in memory on the server. With a couple function calls you can insert new items into the UI, append or prepend dynamically, or re-order items without reloading the items on the server.</p>
<p>
The <code>phx.gen.live</code> live CRUD generator in Phoenix 1.7 uses streams to manage the your list of items. This allows data entry, updates, and deletes without ever needing to refetch the list of items after the initial load. Let’s see how.</p>
<p>
The following <code>PostLive.Index</code> module is generated when you run <code>mix phx.gen.live Blog Post posts title views:integer</code></p>
<pre><code><span>defmodule</span><span> </span><span>DemoWeb.PostLive.Index</span><span> </span><span data-group-id="0855649903-1">do</span><span>
  </span><span>use</span><span> </span><span>DemoWeb</span><span>,</span><span> </span><span>:live_view</span><span>

  </span><span>alias</span><span> </span><span>Demo.Blog</span><span>
  </span><span>alias</span><span> </span><span>Demo.Blog.Post</span><span>

  </span><span>@impl</span><span> </span><span>true</span><span>
  </span><span>def</span><span> </span><span>mount</span><span data-group-id="0855649903-2">(</span><span>_params</span><span>,</span><span> </span><span>_session</span><span>,</span><span> </span><span>socket</span><span data-group-id="0855649903-2">)</span><span> </span><span data-group-id="0855649903-3">do</span><span>
    </span><span data-group-id="0855649903-4">{</span><span>:ok</span><span>,</span><span> </span><span>stream</span><span data-group-id="0855649903-5">(</span><span>socket</span><span>,</span><span> </span><span>:posts</span><span>,</span><span> </span><span>Blog</span><span>.</span><span>list_posts</span><span data-group-id="0855649903-6">(</span><span data-group-id="0855649903-6">)</span><span data-group-id="0855649903-5">)</span><span data-group-id="0855649903-4">}</span><span>
  </span><span data-group-id="0855649903-3">end</span><span>

  </span><span>...</span><span>
</span><span data-group-id="0855649903-1">end</span></code></pre>
<p>
Notice how instead of the regular <code>assign(socket, :posts, Blog.list_posts())</code>, we have a new <code>stream/3</code> interface. This sets up the stream with the initial collection of posts. Then in the generated <code>index.html.heex</code> template, we consume the stream to render the posts table:</p>
<pre><code><span data-group-id="8572408869-out-1">&lt;</span><span>.table</span><span>
  </span><span>id</span><span>=</span><span>&#34;posts&#34;</span><span>
  </span><span>rows</span><span>=</span><span data-group-id="8572408869-1">{</span><span>@streams</span><span>.</span><span>posts</span><span data-group-id="8572408869-1">}</span><span>
  </span><span>row_click</span><span>=</span><span data-group-id="8572408869-2">{</span><span data-group-id="8572408869-ex-1">fn</span><span> </span><span data-group-id="8572408869-ex-2">{</span><span>_id</span><span>,</span><span> </span><span>post</span><span data-group-id="8572408869-ex-2">}</span><span> </span><span>-&gt;</span><span> </span><span>JS</span><span>.</span><span>navigate</span><span data-group-id="8572408869-ex-3">(</span><span>~p&#34;/posts/</span><span data-group-id="8572408869-ex-4">#{</span><span>post</span><span data-group-id="8572408869-ex-4">}</span><span>&#34;</span><span data-group-id="8572408869-ex-3">)</span><span> </span><span data-group-id="8572408869-ex-1">end</span><span data-group-id="8572408869-2">}</span><span>
</span><span data-group-id="8572408869-out-1">&gt;</span><span>
  </span><span data-group-id="8572408869-out-2">&lt;</span><span>:col</span><span> </span><span>:let</span><span>=</span><span data-group-id="8572408869-3">{</span><span data-group-id="8572408869-ex-5">{</span><span>_id</span><span>,</span><span> </span><span>post</span><span data-group-id="8572408869-ex-5">}</span><span data-group-id="8572408869-3">}</span><span> </span><span>label</span><span>=</span><span>&#34;Title&#34;</span><span data-group-id="8572408869-out-2">&gt;</span><span data-group-id="8572408869-4">&lt;%=</span><span> </span><span>post</span><span>.</span><span>title</span><span> </span><span data-group-id="8572408869-4">%&gt;</span><span data-group-id="8572408869-out-3">&lt;/</span><span>:col</span><span data-group-id="8572408869-out-3">&gt;</span><span>
  </span><span data-group-id="8572408869-out-4">&lt;</span><span>:col</span><span> </span><span>:let</span><span>=</span><span data-group-id="8572408869-5">{</span><span data-group-id="8572408869-ex-6">{</span><span>_id</span><span>,</span><span> </span><span>post</span><span data-group-id="8572408869-ex-6">}</span><span data-group-id="8572408869-5">}</span><span> </span><span>label</span><span>=</span><span>&#34;Views&#34;</span><span data-group-id="8572408869-out-4">&gt;</span><span data-group-id="8572408869-6">&lt;%=</span><span> </span><span>post</span><span>.</span><span>views</span><span> </span><span data-group-id="8572408869-6">%&gt;</span><span data-group-id="8572408869-out-5">&lt;/</span><span>:col</span><span data-group-id="8572408869-out-5">&gt;</span><span>
  </span><span data-group-id="8572408869-out-6">&lt;</span><span>:action</span><span> </span><span>:let</span><span>=</span><span data-group-id="8572408869-7">{</span><span data-group-id="8572408869-ex-7">{</span><span>_id</span><span>,</span><span> </span><span>post</span><span data-group-id="8572408869-ex-7">}</span><span data-group-id="8572408869-7">}</span><span data-group-id="8572408869-out-6">&gt;</span><span>
    </span><span data-group-id="8572408869-out-7">&lt;</span><span>div</span><span> </span><span>class</span><span>=</span><span>&#34;sr-only&#34;</span><span data-group-id="8572408869-out-7">&gt;</span><span>
      </span><span data-group-id="8572408869-out-8">&lt;</span><span>.link</span><span> </span><span>navigate</span><span>=</span><span data-group-id="8572408869-8">{</span><span>~p&#34;/posts/</span><span data-group-id="8572408869-ex-8">#{</span><span>post</span><span data-group-id="8572408869-ex-8">}</span><span>&#34;</span><span data-group-id="8572408869-8">}</span><span data-group-id="8572408869-out-8">&gt;</span><span>Show</span><span data-group-id="8572408869-out-9">&lt;/</span><span>.link</span><span data-group-id="8572408869-out-9">&gt;</span><span>
    </span><span data-group-id="8572408869-out-10">&lt;/</span><span>div</span><span data-group-id="8572408869-out-10">&gt;</span><span>
    </span><span data-group-id="8572408869-out-11">&lt;</span><span>.link</span><span> </span><span>patch</span><span>=</span><span data-group-id="8572408869-9">{</span><span>~p&#34;/posts/</span><span data-group-id="8572408869-ex-9">#{</span><span>post</span><span data-group-id="8572408869-ex-9">}</span><span>/edit&#34;</span><span data-group-id="8572408869-9">}</span><span data-group-id="8572408869-out-11">&gt;</span><span>Edit</span><span data-group-id="8572408869-out-12">&lt;/</span><span>.link</span><span data-group-id="8572408869-out-12">&gt;</span><span>
  </span><span data-group-id="8572408869-out-13">&lt;/</span><span>:action</span><span data-group-id="8572408869-out-13">&gt;</span><span>
  </span><span data-group-id="8572408869-out-14">&lt;</span><span>:action</span><span> </span><span>:let</span><span>=</span><span data-group-id="8572408869-10">{</span><span data-group-id="8572408869-ex-10">{</span><span>id</span><span>,</span><span> </span><span>post</span><span data-group-id="8572408869-ex-10">}</span><span data-group-id="8572408869-10">}</span><span data-group-id="8572408869-out-14">&gt;</span><span>
    </span><span data-group-id="8572408869-out-15">&lt;</span><span>.link</span><span>
      </span><span>phx-click</span><span>=</span><span data-group-id="8572408869-11">{</span><span>JS</span><span>.</span><span>push</span><span data-group-id="8572408869-ex-11">(</span><span>&#34;delete&#34;</span><span>,</span><span> </span><span>value</span><span>:</span><span> </span><span data-group-id="8572408869-ex-12">%{</span><span>id</span><span>:</span><span> </span><span>post</span><span>.</span><span>id</span><span data-group-id="8572408869-ex-12">}</span><span data-group-id="8572408869-ex-11">)</span><span> </span><span>|&gt;</span><span> </span><span>hide</span><span data-group-id="8572408869-ex-13">(</span><span>&#34;#</span><span data-group-id="8572408869-ex-14">#{</span><span>id</span><span data-group-id="8572408869-ex-14">}</span><span>&#34;</span><span data-group-id="8572408869-ex-13">)</span><span data-group-id="8572408869-11">}</span><span>
      </span><span>data-confirm</span><span>=</span><span>&#34;Are</span><span> </span><span>you</span><span> </span><span>sure?&#34;</span><span>
    </span><span data-group-id="8572408869-out-15">&gt;</span><span>
      Delete
    </span><span data-group-id="8572408869-out-16">&lt;/</span><span>.link</span><span data-group-id="8572408869-out-16">&gt;</span><span>
  </span><span data-group-id="8572408869-out-17">&lt;/</span><span>:action</span><span data-group-id="8572408869-out-17">&gt;</span><span>
</span><span data-group-id="8572408869-out-18">&lt;/</span><span>.table</span><span data-group-id="8572408869-out-18">&gt;</span></code></pre>
<p>
This looks very similar to the old template, but instead of accessing the bare <code>@posts</code> assign, we pass the <code>@stream.posts</code> to our table. When consuming a stream we also are passed the stream’s DOM id, along with the item.</p>
<p>
Back on the server, we can see how simple it is to insert new items into the table. When our generated <code>FormComponent</code> updates or saves a post via the form, we send a message pack to the parent <code>PostLive.Index</code> LiveView about the new or updated post:</p>
<p>
<code>PostLive.FormComponent</code>:</p>
<pre><code><span>defmodule</span><span> </span><span>DemoWeb.PostLive.FormComponent</span><span> </span><span data-group-id="6495226340-1">do</span><span>
  </span><span>...</span><span>
  </span><span>defp</span><span> </span><span>save_post</span><span data-group-id="6495226340-2">(</span><span>socket</span><span>,</span><span> </span><span>:new</span><span>,</span><span> </span><span>post_params</span><span data-group-id="6495226340-2">)</span><span> </span><span data-group-id="6495226340-3">do</span><span>
    </span><span>case</span><span> </span><span>Blog</span><span>.</span><span>create_post</span><span data-group-id="6495226340-4">(</span><span>post_params</span><span data-group-id="6495226340-4">)</span><span> </span><span data-group-id="6495226340-5">do</span><span>
      </span><span data-group-id="6495226340-6">{</span><span>:ok</span><span>,</span><span> </span><span>post</span><span data-group-id="6495226340-6">}</span><span> </span><span>-&gt;</span><span>
        </span><span>notify_parent</span><span data-group-id="6495226340-7">(</span><span data-group-id="6495226340-8">{</span><span>:saved</span><span>,</span><span> </span><span>post</span><span data-group-id="6495226340-8">}</span><span data-group-id="6495226340-7">)</span><span>

        </span><span data-group-id="6495226340-9">{</span><span>:noreply</span><span>,</span><span>
         </span><span>socket</span><span>
         </span><span>|&gt;</span><span> </span><span>put_flash</span><span data-group-id="6495226340-10">(</span><span>:info</span><span>,</span><span> </span><span>&#34;Post created successfully&#34;</span><span data-group-id="6495226340-10">)</span><span>
         </span><span>|&gt;</span><span> </span><span>push_patch</span><span data-group-id="6495226340-11">(</span><span>to</span><span>:</span><span> </span><span>socket</span><span>.</span><span>assigns</span><span>.</span><span>patch</span><span data-group-id="6495226340-11">)</span><span data-group-id="6495226340-9">}</span><span>

      </span><span data-group-id="6495226340-12">{</span><span>:error</span><span>,</span><span> </span><span data-group-id="6495226340-13">%</span><span data-group-id="6495226340-13">Ecto.Changeset</span><span data-group-id="6495226340-13">{</span><span data-group-id="6495226340-13">}</span><span> </span><span>=</span><span> </span><span>changeset</span><span data-group-id="6495226340-12">}</span><span> </span><span>-&gt;</span><span>
        </span><span data-group-id="6495226340-14">{</span><span>:noreply</span><span>,</span><span> </span><span>assign_form</span><span data-group-id="6495226340-15">(</span><span>socket</span><span>,</span><span> </span><span>changeset</span><span data-group-id="6495226340-15">)</span><span data-group-id="6495226340-14">}</span><span>
    </span><span data-group-id="6495226340-5">end</span><span>
  </span><span data-group-id="6495226340-3">end</span><span>

  </span><span>defp</span><span> </span><span>notify_parent</span><span data-group-id="6495226340-16">(</span><span>msg</span><span data-group-id="6495226340-16">)</span><span>,</span><span> </span><span>do</span><span>:</span><span> </span><span>send</span><span data-group-id="6495226340-17">(</span><span>self</span><span data-group-id="6495226340-18">(</span><span data-group-id="6495226340-18">)</span><span>,</span><span> </span><span data-group-id="6495226340-19">{</span><span>__MODULE__</span><span>,</span><span> </span><span>msg</span><span data-group-id="6495226340-19">}</span><span data-group-id="6495226340-17">)</span><span>
</span><span data-group-id="6495226340-1">end</span></code></pre>
<p>
Then we pick the message up in a <code>PostLive.Index</code> <code>handle_info</code> clause:</p>
<pre><code><span>@impl</span><span> </span><span>true</span><span>
</span><span>def</span><span> </span><span>handle_info</span><span data-group-id="0775111134-1">(</span><span data-group-id="0775111134-2">{</span><span>DemoWeb.PostLive.FormComponent</span><span>,</span><span> </span><span data-group-id="0775111134-3">{</span><span>:saved</span><span>,</span><span> </span><span>post</span><span data-group-id="0775111134-3">}</span><span data-group-id="0775111134-2">}</span><span>,</span><span> </span><span>socket</span><span data-group-id="0775111134-1">)</span><span> </span><span data-group-id="0775111134-4">do</span><span>
  </span><span data-group-id="0775111134-5">{</span><span>:noreply</span><span>,</span><span> </span><span>stream_insert</span><span data-group-id="0775111134-6">(</span><span>socket</span><span>,</span><span> </span><span>:posts</span><span>,</span><span> </span><span>post</span><span data-group-id="0775111134-6">)</span><span data-group-id="0775111134-5">}</span><span>
</span><span data-group-id="0775111134-4">end</span></code></pre>
<p>
So the form tells us it saved a post, and we simply <code>stream_insert</code> the post in our stream. That’s it! If a post already exists in the UI, it will be updated in place. Otherwise it is appended to the container by default. You can also prepend with <code>stream_insert(socket, :posts, post, at: 0)</code>, or pass any index to <code>:at</code> for arbitrary item insertion or re-ordering.</p>
<p>
Streams were one of the final building blocks on our way to LiveView 1.0 and I’m super happy where we landed.</p>
<h2>
New Form field datastructure</h2>
<p>
We’re all familiar with the Phoenix.HTML form primitives of <code>&lt;.form for={@changeset}&gt;</code>, where the form takes a datastructure that implements the <code>Phoenix.HTML.FormData</code> protocol and returns a <code>%Phoenix.HTML.Form{}</code>. One issue our approach had is the form datastructure couldn’t track individual form field changes. This made optimizations impossible in LiveView where we’d have to re-render and resend the form on any individual change. With the introduction of <code>Phoenix.HTML.FormData.to_form</code> and <code>Phoenix.Component.to_form</code>, we now have a <code>%Phoenix.HTML.FormField{}</code> datastructue for individual field changes.</p>
<p>
The new <code>phx.gen.live</code> generators and your <code>core_components.ex</code> take advantage of these new additions.</p>
<h2>
What’s Next for Phoenix and LiveView</h2>
<p>
The Phoenix generators make use of LiveViews latest features, and that will continue to expand. With streaming collections as the default, we can move towards more advanced out-of-the-box features for our live CRUD generators in <code>phx.gen.live</code>. For example, we plan to introduce synced UIs out-of-the-box for resources. The generated Phoenix form features will continue to evolve with the addition of new the <code>to_form</code> interface.</p>
<p>
For LiveView, <code>to_form</code> allowed us to ship the basis of optimized forms. Now an individual change to one form field will produce an optimized diff.</p>
<p>
Following this optimization work, the major remaining feature for LiveView 1.0 is an expanded form API that better supports dynamic forms inputs, wizard-style forms, and delegating form inputs to child LiveComponents.</p>
<h2>
Alternative Webserver Support</h2>
<p>
Thanks to work by Mat Trudel, we now have the basis for first-class webserver support in Plug and Phoenix, allowing other webservers like <a href="https://github.com/mtrudel/bandit">Bandit</a> to be swapped in Phoenix while enjoying all features like WebSockets, Channels, and LiveView. Stay tuned to the Bandit project if you’re interested in a pure Elixir HTTP server or give it a try in your own Phoenix projects!</p>
<h2>
What’s Next</h2>
<p>
As always, <a href="https://gist.github.com/chrismccord/00a6ea2a96bc57df0cce526bd20af8a7">step-by-step upgrade guides</a> are there to take your existing 1.6.x apps up to 1.7.</p>
<p>
The full changelog can be found <a href="https://github.com/phoenixframework/phoenix/blob/a8707baed3e67ffaaa1e3e8c2b2271291b57407c/CHANGELOG.md">here</a>.</p>
<p>
Find us on elixir slack or <a href="https://elixirforum.com">the forums</a> if you have issues.</p>
<p>
Happy coding!</p>
<p>
–Chris</p>

  <hr/>

      </div></div>
  </body>
</html>
