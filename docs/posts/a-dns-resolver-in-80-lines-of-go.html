<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jvns.ca/blog/2022/02/01/a-dns-resolver-in-80-lines-of-go/">Original</a>
    <h1>A DNS resolver in 80 lines of Go</h1>
    
    

<p>Hello! I wrote a comic last week called &ldquo;life of a DNS query&rdquo; that explains how
DNS resolvers work.</p>

<p>In this post, I want to explain how DNS resolvers work in a different way &ndash;
with a short Go program that does does the same thing described in the comic.
The main function (<code>resolve</code>) is actually just 20 lines, including comments.</p>

<p>The program is here: <a href="https://github.com/jvns/tiny-resolver/blob/main/resolve.go">https://github.com/jvns/tiny-resolver/blob/main/resolve.go</a></p>

<h3 id="what-s-a-dns-resolver">what&rsquo;s a DNS resolver?</h3>

<p>When your browser needs to make a DNS query, it asks a <strong>DNS resolvers</strong>. When
they start, DNS resolvers don&rsquo;t know any DNS records (except the IP addresses
of the root nameservers). But they <em>do</em> know how to find DNS records for you.</p>

<p>Here&rsquo;s the &ldquo;life of a DNS query&rdquo; comic, which explains how DNS resolvers find DNS records for you.</p>

<p><a href="https://wizardzines.com/comics/life-of-a-dns-query/">
<img src="https://wizardzines.com/comics/life-of-a-dns-query/life-of-a-dns-query.png">
</a></p>

<h3 id="we-ll-use-a-library-for-parsing-dns-packets">we&rsquo;ll use a library for parsing DNS packets.</h3>

<p>I&rsquo;m not going to write this completely from scratch &ndash; I think parsing DNS
packets is really interesting, but it&rsquo;s definitely more than 80 lines of
code, and I find that it kind of distracts from the algorithm.</p>

<p>So I&rsquo;ve used <a href="https://github.com/miekg/dns">https://github.com/miekg/dns</a> for creeting and parsing the DNS
packets.</p>

<h3 id="dns-responses-contain-4-sections">DNS responses contain 4 sections</h3>

<p>You might think of DNS queries as just being a question and an answer (&ldquo;what&rsquo;s
the IP for <code>example.com</code>? it&rsquo;s <code>93.184.216.34</code>!). But actually DNS responses
contain 4 sections, and we need to use all 4 sections to write our DNS
resolver. So let&rsquo;s explain what they are.</p>

<p>Here&rsquo;s the <code>Msg</code> struct from the <code>miekg/dns</code> library, which lists the sections.</p>

<pre><code>type Msg struct {
        MsgHdr
        Compress bool       `json:&quot;-&quot;` // If true, the message will be compressed when converted to wire format.
        Question []Question // Holds the RR(s) of the question section.
        Answer   []RR       // Holds the RR(s) of the answer section.
        Ns       []RR       // Holds the RR(s) of the authority section.
        Extra    []RR       // Holds the RR(s) of the additional section.
}
</code></pre>

<p><strong>Section 1: Question</strong>. This is the section you use when you&rsquo;re creating a
query. There&rsquo;s not much to it &ndash; it just has a query name (like <code>jvns.ca.</code>), a
type (like <code>A</code>, but encoded as an integer), and a class (which is always the
same these days, &ldquo;internet&rdquo;).</p>

<p>Here&rsquo;s what the Question struct <code>miekg/dns</code> looks like:</p>

<pre><code>type Question struct {
        Name   string `dns:&quot;cdomain-name&quot;` // &quot;cdomain-name&quot; specifies encoding (and may be compressed)
        Qtype  uint16
        Qclass uint16
}
</code></pre>

<p><strong>Section 2: Answer</strong>. When you make a request like this:</p>

<pre><code>$ dig +short google.com
93.184.216.34
</code></pre>

<p>the IP address <code>93.184.216.34</code> comes from the <strong>Answer</strong> section.</p>

<p>The Answer, Authority, and Additional sections all contain <strong>DNS records</strong>.
Different types of records have different formats, but they all contain a <strong>name</strong>, <strong>type</strong>, <strong>class</strong>, and <strong>TTL</strong></p>

<p>Here&rsquo;s what the shared header looks like in <code>miekg/dns</code>:</p>

<pre><code>type RR_Header struct {
        Name     string `dns:&quot;cdomain-name&quot;`
        Rrtype   uint16
        Class    uint16
        Ttl      uint32
        Rdlength uint16 // Length of data after header.
}
</code></pre>

<p>&ldquo;RR&rdquo; stands for &ldquo;Resource Record&rdquo;.</p>

<p><strong>Section 3: Authority</strong>. When a nameserver redirects you to another server
(&ldquo;ask <code>a.iana-servers.net</code> instead!&ldquo;), this is the section it uses. <code>miekg/dns</code>
calls this section <code>Ns</code> instead of <code>Authority</code>, I guess because it contains
<code>NS</code> records.</p>

<p>Here&rsquo;s an example of an record in the Authority section of a DNS response.</p>

<pre><code>$ dig +noall +authority @h.root-servers.net example.com 
com.			172800	IN	NS	a.gtld-servers.net.
com.			172800	IN	NS	b.gtld-servers.net.
</code></pre>

<p>The Authority section can also contain SOA records but that&rsquo;s not relevant to
this post so I&rsquo;m not going to talk about that.</p>

<p><strong>Section 4: Additional</strong>. This is where &ldquo;glue records&rdquo; live. What&rsquo;s a glue
record? Well, basically when a nameserver redirects you to another server,
often it&rsquo;ll include the IP address of that server as well.</p>

<p>Here are the glue records from the same query above.</p>

<pre><code>$ dig +noall +additional @h.root-servers.net example.com 
a.gtld-servers.net.	172800	IN	A	192.5.6.30
b.gtld-servers.net.	172800	IN	A	192.33.14.30
</code></pre>

<p>There are other things in the Additional section as well, not just glue
records, but they&rsquo;re not relevant to this blog post so I&rsquo;m not going to talk
about them.</p>

<h3 id="the-basic-resolve-function-is-pretty-short">the basic <code>resolve</code> function is pretty short</h3>

<p>Now that we&rsquo;ve talked about the different sections in a DNS response, I can explain the resolver code.</p>

<p>Let&rsquo;s jump into the main function for resolving a name to an IP address.</p>

<p><code>name</code> here is a domain name, like <code>example.com.</code>`</p>

<pre><code>func resolve(name string) net.IP {
   // We always start with a root nameserver
   nameserver := net.ParseIP(&quot;198.41.0.4&quot;)
   for {
      reply := dnsQuery(name, nameserver)
      if ip := getAnswer(reply); ip != nil { // look in the &quot;Answer&quot; section
         // Best case: we get an answer to our query  and we're done
         return ip
      } else if nsIP := getGlue(reply); nsIP != nil { // look in the &quot;Additional&quot; section
            // Second best: we get a &quot;glue record&quot; with the *IP address* of
            // another nameserver to query 
         nameserver = nsIP
      } else if domain := getNS(reply); domain != &quot;&quot; { // look in the &quot;Authority&quot; section
            // Third best: we get the *domain name* of another nameserver to
            // query, which we can look up the IP for
         nameserver = resolve(domain)
      } else {
         // If there's no A record we just panic, this is not a very good
         // resolver :)
         panic(&quot;something went wrong&quot;)
      }
   }
}
</code></pre>

<p>Here&rsquo;s what that <code>resolve</code> function is doing:
1. We start with the root nameserver
2. Then we do a loop:
    a. Query the nameserver and parse the response
    a. Look in the &ldquo;Answer&rdquo; section for a response. If we find one, we&rsquo;re done
    a. Look in the &ldquo;Additional&rdquo; section for a glue record. If we find one, use that as the nameserver for the next query
    a. Look in the &ldquo;Authority&rdquo; section for a nameserver domain. If we find one, look up its IP and then use that IP as the nameserver for the next query</p>

<p>That&rsquo;s basically the whole program. There are a few helper functions to get
records out of the DNS response and to make DNS queries but I don&rsquo;t think
they&rsquo;re that interesting so I won&rsquo;t explain them.</p>

<h3 id="the-output">the output</h3>

<p>The resolver prints out all DNS queries it made, and the record it used to figure out what query to make it next.</p>

<p>It prints out <code>dig -r @SERVER DOMAIN</code> for each query even though it&rsquo;s not
actually using <code>dig</code> to make the query just because I liked being able to run
the same query myself from the command line to see the response myself, for
debugging purposes.</p>

<p>Let&rsquo;s look at 3 examples of the output.</p>

<h3 id="example-1-jvns-ca">example 1: jvns.ca</h3>

<pre><code>$ go run resolve.go jvns.ca.
dig -r @198.41.0.4 jvns.ca.
   any.ca-servers.ca.	172800	IN	A	199.4.144.2
dig -r @199.4.144.2 jvns.ca.
   jvns.ca.	86400	IN	NS	art.ns.cloudflare.com.
dig -r @198.41.0.4 art.ns.cloudflare.com.
   a.gtld-servers.net.	172800	IN	A	192.5.6.30
dig -r @192.5.6.30 art.ns.cloudflare.com.
   ns3.cloudflare.com.	172800	IN	A	162.159.0.33
dig -r @162.159.0.33 art.ns.cloudflare.com.
   art.ns.cloudflare.com.	900	IN	A	173.245.59.102
dig -r @173.245.59.102 jvns.ca.
   jvns.ca.	256	IN	A	172.64.80.1
</code></pre>

<p>We can see it had to make 6 DNS queries, 3 to look up <code>jvns.ca</code> and 3 to look up <code>jvns.ca</code>&rsquo;s nameserver, <code>art.ns.cloudflare.com</code></p>

<h3 id="example-2-archive-org">example 2: archive.org</h3>

<pre><code>$ go run resolve.go archive.org.
dig -r @198.41.0.4 archive.org.
   a0.org.afilias-nst.info.	172800	IN	A	199.19.56.1
dig -r @199.19.56.1 archive.org.
   ns1.archive.org.	86400	IN	A	208.70.31.236
dig -r @208.70.31.236 archive.org.
   archive.org.	300	IN	A	207.241.224.2
Result: 207.241.224.2
</code></pre>

<p>This one only had to make 3 DNS queries. This is because there was a glue
record available for archive.org&rsquo;s nameserver (<code>ns1.archive.org.</code>).</p>

<h3 id="example-3-www-maths-ox-ac-uk">example 3: www.maths.ox.ac.uk</h3>

<p>One last example: let&rsquo;s look up <code>www.maths.ox.ac.uk</code>. There&rsquo;s a reason for this one, I promise!</p>

<pre><code>dig -r @198.41.0.4 www.maths.ox.ac.uk.
   dns1.nic.uk.	172800	IN	A	213.248.216.1
dig -r @213.248.216.1 www.maths.ox.ac.uk.
   ac.uk.	172800	IN	NS	ns0.ja.net.
dig -r @198.41.0.4 ns0.ja.net.
   e.gtld-servers.net.	172800	IN	A	192.12.94.30
dig -r @192.12.94.30 ns0.ja.net.
   ns0.ja.net.	172800	IN	A	128.86.1.20
dig -r @128.86.1.20 ns0.ja.net.
   ns0.ja.net.	86400	IN	A	128.86.1.20
dig -r @128.86.1.20 www.maths.ox.ac.uk.
   ns2.ja.net.	86400	IN	A	193.63.105.17
dig -r @193.63.105.17 www.maths.ox.ac.uk.
   www.maths.ox.ac.uk.	300	IN	A	129.67.184.128
Result: 129.67.184.128
</code></pre>

<p>This makes <strong>7</strong> DNS queries, which is more than <code>jvns.ca</code>, which only needed
6. Why does it make 7 DNS queries instead of 6?</p>

<p>Well, it&rsquo;s because there are 4 nameservers involved in resolving <code>www.maths.ox.ac.uk</code> instead of 3. They are:</p>

<ul>
<li>the <code>.</code> nameserver</li>
<li>the <code>uk.</code> nameserver</li>
<li>the <code>ac.uk.</code> nameserver</li>
<li>the <code>ox.ac.uk.</code> nameserver</li>
</ul>

<p>You could even imagine there being a 5th one (a <code>maths.ox.ac.uk.</code> nameserver), but there isn&rsquo;t in this case.</p>

<p>jvns.ca only involves 3 nameservers:</p>

<ul>
<li>the <code>.</code> nameserver</li>
<li>the <code>ca.</code> nameserver</li>
<li>the <code>jvns.ca.</code> nameserver</li>
</ul>

<h3 id="real-dns-resolvers-actually-make-more-queries-than-this">real DNS resolvers actually make more queries than this</h3>

<p>When my resolver resolves <code>reddit.com.</code>, it only makes 3 DNS queries.</p>

<pre><code>$ go run resolve.go reddit.com.
dig -r @198.41.0.4 reddit.com.
   e.gtld-servers.net.	172800	IN	A	192.12.94.30
dig -r @192.12.94.30 reddit.com.
   ns-378.awsdns-47.com.	172800	IN	A	205.251.193.122
dig -r @205.251.193.122 reddit.com.
   reddit.com.	300	IN	A	151.101.129.140
Result: 151.101.129.140
</code></pre>

<p>But when <code>unbound</code> (the actual DNS resolver that I have running on my laptop)
resolves reddit.com, it makes more DNS queries. I captured them with <code>tcpdump</code>
to see what they were.</p>

<p>This <code>tcpdump</code> output might be a little illegible because well, that&rsquo;s how
tcpdump is, but hopefully it makes some sense.</p>

<p>Unbound skips the first step, because it has the address of the <code>com.</code>
nameserver cached.  Then the next 2 queries <code>unbound</code> makes are exactly the
same as my tiny Go resolver, except that it sends its first query to
<code>k.gtld-servers.net</code> instead of <code>e.gtld-servers.net</code>:</p>

<pre><code>12:38:35.479222 wlp3s0 Out IP pomegranate.19946 &gt; k.gtld-servers.net.domain: 51686% [1au] A? reddit.com. (39)
12:38:35.757033 wlp3s0 Out IP pomegranate.29111 &gt; ns-378.awsdns-47.com.domain: 8859% [1au] A? reddit.com. (39)
</code></pre>

<p>But then it keeps making DNS queries, even after it&rsquo;s done resolving <code>reddit.com</code>:</p>

<pre><code>12:38:35.757033 wlp3s0 Out IP pomegranate.29111 &gt; ns-378.awsdns-47.com.domain: 8859% [1au] A? reddit.com. (39)
12:38:35.757396 wlp3s0 Out IP pomegranate.31913 &gt; ns-1775.awsdns-29.co.uk.domain: 54236% [1au] A? ns-378.awsdns-47.com. (49)
12:38:35.757761 wlp3s0 Out IP pomegranate.62059 &gt; g.gtld-servers.net.domain: 28793% [1au] A? awsdns-05.net. (42)
12:38:35.757955 wlp3s0 Out IP pomegranate.34743 &gt; b0.org.afilias-nst.org.domain: 24975% [1au] A? awsdns-00.org. (42)
12:38:35.758051 wlp3s0 Out IP pomegranate.8977 &gt; a0.org.afilias-nst.info.domain: 53387% [1au] A? awsdns-00.org. (42)
12:38:35.758285 wlp3s0 Out IP pomegranate.11376 &gt; j.gtld-servers.net.domain: 41181% [1au] A? awsdns-05.net. (42)
12:38:35.775497 wlp3s0 In  IP ns-378.awsdns-47.com.domain &gt; pomegranate.29111: 8859*-$ 4/4/1 A 151.101.1.140, A 151.101.129.140, A 151.101.65.140, A 151.101.193.140 (240)
12:38:35.775948 lo    In  IP localhost.domain &gt; localhost.34429: 4033 4/0/1 A 151.101.1.140, A 151.101.129.140, A 151.101.65.140, A 151.101.193.140 (103)
# now it's done -- it returned its DNS response!
# but it keeps making queries about reddit.com's nameservers...
12:38:35.843811 wlp3s0 Out IP pomegranate.44738 &gt; ns-706.awsdns-24.net.domain: 14817% [1au] A? ns-1029.awsdns-00.org. (50)
12:38:35.845563 wlp3s0 Out IP pomegranate.55655 &gt; ns-1027.awsdns-00.org.domain: 3120% [1au] A? ns-1029.awsdns-00.org. (50)
12:38:36.017618 wlp3s0 Out IP pomegranate.53397 &gt; ns-775.awsdns-32.net.domain: 32671% [1au] A? ns-557.awsdns-05.net. (49)
12:38:36.045151 wlp3s0 Out IP pomegranate.40525 &gt; ns-454.awsdns-56.com.domain: 20823% [1au] A? ns-557.awsdns-05.net. (49)
</code></pre>

<p>So that&rsquo;s kind of interesting. I guess it makes sense that unbound would want
to cache more nameserver addresses in case it needs them in the future. Or
maybe that&rsquo;s what the DNS specification says to do?</p>

<h3 id="is-this-a-recursive-program">is this a &ldquo;recursive&rdquo; program?</h3>

<p>DNS resolvers are often called &ldquo;recursive nameservers&rdquo;. I&rsquo;ve stopped using that
terminology myself in explanations, but as far as I can tell, this is because
the <code>resolve</code> function is often a recursive function.</p>

<p>And the <code>resolve</code> function I wrote is definitely recursive! But I ran this
program on 500 different domains, and these are the number of times it
recursed:</p>

<ol>
<li>Sometimes 0 times (the function never calls itself)</li>
<li>Sometimes 1 time (the function calls itself once, to look up the IP address of one nameserver)</li>
<li>Very rarely 2 times (like for example to resolve <code>abc.net.au.</code> right now it needs to look up <code>r.au.</code>, then <code>eur2.akam.net.</code> then <code>abc.net.au.</code>)</li>
<li>So far, never 3 times</li>
</ol>

<p>Maybe there&rsquo;s a domain that this function would recurse more than 2 times on, but I don&rsquo;t know.</p>

<p>You definitely <em>could</em> write this program in a way that recurses more, by
replacing the loop with more recursion. And then it would recurse 3 or 6 or 7
or 9 times, depending on the domain. But to me the loop feels easier to read so
I wrote it with a loop instead.</p>

<h3 id="a-bash-version-of-this-resolver">a bash version of this resolver</h3>

<p>I wanted to see if it was possible to write a DNS resolver in 10-15 lines of bash, similarly to <a href="https://gist.github.com/jvns/ea2e4d572b4e2285148b8e87f70eed73">this short &ldquo;run a container&rdquo; script</a></p>

<p>The program I came up with was kind of too long in the end (it&rsquo;s about 36 lines), but here it is anyway.</p>

<p><a href="https://github.com/jvns/tiny-resolver/blob/main/resolver.sh">https://github.com/jvns/tiny-resolver/blob/main/resolver.sh</a></p>

<p>The bash version is even more janky and uses <code>grep</code> in very questionable ways
but it did resolve every domain I tried which is cool.</p>

<p>It actually helped me write the Go resolver (which I actually started back in
November but got stuck on) because bash&rsquo;s limitations forced me to simplify the
design and simplifying it fixed a bug I was running into.</p>

<h3 id="how-is-this-different-from-a-real-dns-resolver">how is this different from a &ldquo;real&rdquo; DNS resolver?</h3>

<p>Obviously this is only 80 lines so there are a lot of differences between this
an a &ldquo;real&rdquo; DNS resolver. Here are a few:</p>

<ul>
<li>it only handles A records, not other record types</li>
<li>specifically it doesn&rsquo;t handle CNAME records</li>
<li>it always only returns one A record even if there are more</li>
<li>it has absolutely no ability to handle errors like &ldquo;there were no A records&rdquo; (the Go program just panics)</li>
<li>the way it handles the glue records is a bit sketchy, probably it should
check that they match the nameservers in the &ldquo;Authority&rdquo; section or
something.  It seems to work though.</li>
<li>DNS resolvers are usually servers, this is a command line program</li>
<li>it doesn&rsquo;t validate DNSSEC or whatever</li>
<li>it doesn&rsquo;t do caching</li>
<li>it doesn&rsquo;t try a different nameserver if one of the domain&rsquo;s nameservers isn&rsquo;t working and times out the DNS query</li>
<li>like we mentioned above, unbound seems to look up the addresses of all the nameservers for a domain</li>
<li>probably there are other bugs and ways it violates the DNS spec that I don&rsquo;t know about</li>
</ul>

<h3 id="tiny-versions-of-real-programs-are-fun">tiny versions of real programs are fun</h3>

<p>As usual I always learn something from writing tiny versions of real programs.
I&rsquo;ve written this program before but I think this version is better than the
first version I wrote.</p>

<p>In 2020 I ran a 2-day workshop with my friend Allison called &ldquo;Domain Name
Saturday&rdquo; where all the participants wrote DNS resolvers. Basically the idea
was that you implement the algorithm described in this post, as well as the
binary parsing pieces that the <code>miekg/dns</code> library handles here. At some point
I want to write up that workshop so that other people could run it, because it
was really fun.</p>

<p>One question I still have is &ndash; are there domains where the <code>resolve</code> function
would recurse 3 times or more on? Obviously you could manufacture such a domain
by making it intentionally have to go through a bunch of hoops, but.. do they
exist in the real world?</p>

  </body>
</html>
