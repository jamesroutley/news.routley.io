<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://flak.tedunangst.com/post/www-which-wasm-works">Original</a>
    <h1>Www which WASM works</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>We’ve gotten libjxl built for wasm. <a href="https://flak.tedunangst.com/post/on-building-jpeg-xl-for-wasm">It was a struggle</a>, but we got it done, and we’re ready to run it. WASM is a straightforward standard designed for ease of implementation, so this should be a walk in the park.<br/></p><h3>wazero</h3><p>Let’s start with <a href="https://github.com/tetratelabs/wazero">wazero: the zero dependency WebAssembly runtime for Go developers</a>. “Import wazero and extend your Go application with code written in any language!”</p><p>The initial download, install, whatever you call it goes smoothly enough. Start with one of their tiny examples, verify it works, then switch out the wasm file.</p><pre><code>import[17] memory[a.a]: invalid byte for limits: 0x3 != 0x00 or 0x01</code></pre><p>I don’t know what this means. Searching for “invalid byte” finds <a href="https://github.com/tetratelabs/wazero/blob/main/internal/wasm/binary/import.go#L46">one line</a>.</p><pre><code>err <span>=</span> fmt<span>.</span>Errorf<span>(</span><span>&#34;%w: invalid byte for importdesc: %#x&#34;</span><span>,</span> ErrInvalidByte<span>,</span> b<span>)</span></code></pre><p>Except that’s not an exact match. The <a href="https://github.com/tetratelabs/wazero/blob/main/internal/wasm/binary/limits.go#L39">real error line</a> is cleverly obfuscated and required searching for “for limits”. There’s a comment.</p><pre><code><span>// See https://www.w3.org/TR/2019/REC-wasm-core-1-20191205/#limits%E2%91%A6</span></code></pre><p>Sure enough, the standard says there is a flag of 0 or 1. Not 3. Or 0x3. Or 0x03.<br/></p><h3>wasmer</h3><p>Let’s try wasmer-go, <a href="https://github.com/wasmerio/wasmer-go">a complete and mature WebAssembly runtime for Go based on Wasmer</a>.</p><p>We have a new error!</p><pre><code>Validation error: threads must be enabled for shared memories (at offset 513)</code></pre><p>Let’s <a href="https://pkg.go.dev/github.com/wasmerio/wasmer-go/wasmer">browse the detailed API documentation full of examples</a>. Well, I can’t see any means to enable threads. The word thread doesn’t even appear on the page.</p><p>I feel like I’ve just been told to draw the rest of the owl.<br/></p><h3>wasmtime</h3><p>We’ve got one more wish, wasmtime-go. <a href="https://github.com/bytecodealliance/wasmtime-go">This Go library uses CGO to consume the C API of the Wasmtime project which is written in Rust</a>. No bragging about completeness. Good or bad sign?</p><p>The first sign of danger appears before we even run our code. Upon linking, we get this warning.</p><pre><code>/usr/bin/ld: warning: x86_64.o: missing .note.GNU-stack section implies executable stack</code></pre><p>Good grief, what demons is wasmtime summoning that it needs an executable stack in 2023? I guess it’s good that people only ever use wasmtime in their programs, and never mix in any other unsafe code.</p><p>A new error emerges when we run this demon spawn.</p><pre><code>Invalid input WebAssembly code at offset 513: threads must be enabled for shared memories</code></pre><p>But wasmtime has the long sought answer!</p><pre><code>config<span>.</span>SetWasmThreads<span>(</span><span>true</span><span>)</span></code></pre><p>And now we’re getting closer to running our wasm library. It’s parsed and processed and locked and loaded. But not actually runnable.</p><pre><code>expected 18 imports, found 0</code></pre><p>Fair enough, I need to provide a little runtime support. I think it would have saved some time had these requirements been documented, but once we see what’s missing it should be pretty easy to get back on track.</p><pre><code>    <span>for</span> _<span>,</span> imp <span>:=</span> <span>range</span> mod<span>.</span>Imports<span>(</span><span>)</span> <span>{</span>
        fmt<span>.</span>Printf<span>(</span><span>&#34;missing import: %s\n&#34;</span><span>,</span> <span>*</span>imp<span>.</span>Name<span>(</span><span>)</span><span>)</span>
    <span>}</span></code></pre><p>Let’s run this again.</p><pre><code>missing import: b
missing import: c
missing import: d
missing import: e
missing import: f
missing import: g
missing import: h
missing import: i
missing import: j
missing import: k
missing import: l
missing import: m
missing import: n
missing import: o
missing import: p
missing import: q
missing import: r
missing import: a</code></pre><p>Ah, I see now why they didn’t feel the need to document these imports. They’re so simple and obvious, it probably never occurred to anybody that this would benefit from documentation. I like that the list starts with “b” and ends with “a”.<br/></p><h3>web</h3><p>At this point I figured it would be a good idea to verify that the wasm we’re using works somewhere, <i>anywhere</i>. Back to the browser.</p><p>The libjxl wasm demo includes a little site builder, although it turns out to be pretty complicated. There’s python scripts and node scripts and packers and bundlers and uglifiers galore. It seems less like a demo of libjxl and more like a demo of every webdev tech around that just happens to use libjxl.</p><p>Ironically, for all that, there’s no web server included, so you need to bring your own static file http server. That part is easy. Then you discover the uglifier mispacked the bundle, or whatever, and the scripts don’t parse, but it was possible to salvage them. And then it still tries to load resources from netlify instead of localhost, because apparently they paid for the script, and they really want you to use their server. A few more ninja edits and we get an authentic error from the browser, that SharedArrayBuffer is not available. We need to edit the web server to add the necessary danger zone headers. (Wouldn’t it have been helpful to include a web server that does this, if we’re already requiring every other tool in the box?)</p><p>Eventually, though, this does run, and I was able to see a jxl file appear on my screen.<br/></p><h3>standards</h3><p>At this point I’ve confirmed that all the puzzle pieces are working, even if they don’t yet fit together as I’d hoped. People say the wonderful thing about standards is there’s so many to choose from, but I think that overlooks the true superpower of standards. They let people on the internet say, “It’s a standard. It just works.”<br/></p><h3>the owl</h3><p>Alright, let’s draw the rest of this fucking owl.</p><pre><code><span>func</span> b<span>(</span><span>)</span> <span>{</span>
<span>}</span>
<span>func</span> c<span>(</span><span>)</span> float64 <span>{</span>
    <span>return</span> <span>0</span>
<span>}</span>   
<span>func</span> d<span>(</span><span>)</span> <span>{</span>
<span>}</span>
<span>func</span> e<span>(</span><span>int32</span><span>,</span> <span>int32</span><span>,</span> <span>int32</span><span>,</span> <span>int32</span><span>)</span> <span>int32</span> <span>{</span>
    <span>return</span> <span>0</span>
<span>}</span>   
<span>func</span> f<span>(</span><span>int32</span><span>)</span> <span>{</span>
<span>}</span>   
<span>func</span> g<span>(</span><span>int32</span><span>,</span> <span>int32</span><span>,</span> <span>int32</span><span>)</span> <span>{</span>
<span>}</span>   
<span>func</span> h<span>(</span><span>int32</span><span>,</span> <span>int32</span><span>,</span> <span>int32</span><span>,</span> <span>int32</span><span>)</span> float64 <span>{</span>
    <span>return</span> <span>0</span>
<span>}</span>   
<span>func</span> i<span>(</span><span>int32</span><span>)</span> <span>{</span>
<span>}</span>   
<span>func</span> j<span>(</span><span>int32</span><span>)</span> <span>{</span>
<span>}</span>
<span>func</span> k<span>(</span><span>)</span> <span>{</span> 
<span>}</span>
<span>func</span> l<span>(</span><span>int32</span><span>)</span> <span>{</span>
<span>}</span>   
<span>func</span> m<span>(</span><span>int32</span><span>)</span> <span>{</span>
<span>}</span>   
<span>func</span> n<span>(</span><span>int32</span><span>,</span> <span>int32</span><span>,</span> <span>int32</span><span>,</span> <span>int32</span><span>,</span> <span>int32</span><span>)</span> <span>int32</span> <span>{</span>
    <span>return</span> <span>0</span>
<span>}</span>   
<span>func</span> o<span>(</span><span>int32</span><span>)</span> <span>int32</span> <span>{</span>
    <span>return</span> <span>0</span>
<span>}</span>   
<span>func</span> p<span>(</span><span>int32</span><span>,</span> <span>int32</span><span>,</span> <span>int32</span><span>)</span> <span>{</span>
<span>}</span>   
<span>func</span> q<span>(</span><span>int32</span><span>)</span> <span>int32</span> <span>{</span>
    <span>return</span> <span>0</span>
<span>}</span>   
<span>func</span> r<span>(</span><span>int32</span><span>,</span> <span>int32</span><span>,</span> <span>int32</span><span>,</span> <span>int32</span><span>)</span> <span>int32</span> <span>{</span>
    <span>return</span> <span>0</span>
<span>}</span>   
<span>func</span> a<span>(</span><span>int32</span><span>)</span> <span>int32</span> <span>{</span>
    <span>return</span> <span>0</span>
<span>}</span>   </code></pre><p>Just finish coloring in the lines, and... hahaha, no. Even if this were a good idea, it doesn’t work because “a” is a shared memory, and although wasmtime has let us enable threads for shared memory, it will not let us create a shared memory. We can <a href="https://pkg.go.dev/github.com/bytecodealliance/wasmtime-go/v12#Memory">create memory</a> but only of the boring unshared variety.<br/></p><h3>rewind</h3><p>At this point, I backed up and started over with a smaller C file. Like the little wasm examples that can add two 32-bit numbers in a mere thousand cycles. This does work. And we can incrementally add in assorted artifacts we find in the libjxl build directory until it works or breaks. </p><p>Cobble some code together from some other examples, write some glorious error oblivious C code and eventually we have a wasm file that can decode a jxl file and return to us the first four bytes of the resulting image. That’s not quite the whole image, but it’s something.<br/></p><h3>zero</h3><p>What if we try wazero again, now that we’ve left the cruel world of shared memory behind?</p><pre><code>invalid function[7]: invalid instruction 0xfe</code></pre><p>Never mind. We’re just gonna have to rock that exec stack for fun and profit.<br/></p><h3>epilogue</h3><p>I did eventually get a prototype working, that can decode jxl files and retrieve their data, sufficient for go to encode it as a jpeg which looks about the same. It’s pretty horrifying, but there’s hope that one day I will consider using a distant descendant of it.
</p></div></div>
  </body>
</html>
