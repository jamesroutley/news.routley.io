<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://buttondown.email/hillelwayne/archive/when-would-you-ever-want-bubblesort/">Original</a>
    <h1>When would you ever want bubblesort?</h1>
    
    <div id="readability-page-1" class="page"><div>

                

                
                    
                        <p>There are very few universal rules in software engineering, but there are are a lot of <em>near</em>-universal principles. Things like &#34;prefer composition to inheritance&#34; is near-universal. I love finding the rare situations where these principles don&#39;t hold, like where you do want <a href="https://buttondown.email/hillelwayne/archive/when-to-prefer-inheritance-to-composition/" target="_blank">inheritance over composition</a>. A similar near-universal principle is &#34;don&#39;t use <a href="https://en.wikipedia.org/wiki/Bubble_sort" target="_blank">bubblesort</a>&#34;. Some would even say it&#39;s a universal rule, with Donald Knuth writing &#34;bubble sort seems to have nothing to recommend it, except a catchy name and the fact that it leads to some interesting theoretical problems&#34;.<sup id="fnref:cite"><a href="#fn:cite">1</a></sup> But Knuth&#39;s <a href="https://en.wikipedia.org/wiki/Knuth_reward_check" target="_blank">been wrong before</a>, so let&#39;s see if this universal rule is only <em>near</em>-universal.</p>
<p>Theoretically, bubblesort is faster than quick or mergesort for small arrays. This makes it useful as part of a larger sorting strategy: most of the fast-in-principle sorting algorithms work by recursively sorting subpartitions of an array, ie if you apply quicksort to 2^20 random integers, at some point you&#39;re sorting 2^17 8-integer subpartitions. Switching over to bubblesort for those subpartitions would be a nice optimization. </p>
<p>Many production sorting algorithms do use a hybrid approach, but they overwhelmingly use <a href="https://en.wikipedia.org/wiki/Insertion_sort" target="_blank">insertion sort</a> instead. Insertion sort is very fast for small arrays and it&#39;s also <a href="https://nicknash.me/2012/10/12/knuths-wisdom/" target="_blank">better at using the hardware</a>. On some very particular hardwares bubblesort stills ends up better, like in this <a href="http://www.sci.utah.edu/~wald/Publications/2019/rtgems/ParticleSplatting.pdf" target="_blank">NVIDIA study</a>, but you probably don&#39;t have that hardware.</p>
<p>So that&#39;s one use-case, albeit one still dominated by a different algorithm. It&#39;s interesting that NVIDIA used it here because gamedev has a situation that&#39;s uniquely useful to bubblesort, based on two of its properties:</p>
<ol>
<li>While the algorithm is very slow overall, each individual step is very fast and easily suspendable.</li>
<li>Each swap leaves the array more ordered than it was before. Other sorts can move values <em>away</em> from their final positions in intermediate stages.</li>
</ol>
<p>This makes it really good when you want to do a fixed amount of sorting work per frame. Say you have a bunch of objects on a screen, where some objects can occlude others. You want to render the objects closest to the camera <em>first</em> because then you can determine which objects it hides, and then save time rendering those objects. There&#39;s no correctness cost for rendering objects out of order, just a potential performance cost. So while your array doesn&#39;t <em>need</em> to be ordered, the more ordered it is the happier you are. But you also can&#39;t spend too much time running a sorting algorithm, because you have a pretty strict realtime constraint. Bubble sort <a href="https://discussions.unity.com/t/depth-sorting-of-billboard-particles-how-can-i-do-it/5053" target="_blank">works pretty well here</a>. You can run it a little bit of a time at each frame and get a better ordering than when you started.</p>
<p>That reminds me of one last use-case I&#39;ve heard, apocryphally. Let&#39;s say you have a random collection of randomly-colored particles, and you want to animate them sorting into a rainbow spectrum. If you make each frame of the animation one pass of bubblesort, the particles will all move smoothly into the right positions. I couldn&#39;t find any examples in the wild, so with the help of GPT4 I hammered out a crappy visualization. Code is <a href="https://gist.github.com/hwayne/85488f755066d8aa57cd147875e97b72" target="_blank">here</a>, put it <a href="https://editor.p5js.org/" target="_blank">here</a>.</p>
<p>(After doing that I suspect this isn&#39;t actually done in practice, in favor of running a better sort to calculate each particles final displacement and then animating each particles moving directly, instead of waiting to move for each bubblesort pass. I haven&#39;t mocked out an example but I think that&#39;d look a lot smoother.)</p>
<p>So there you go, three niche use cases for bubblesort. You&#39;ll probably never need it.</p>
<hr/>
<h3>New Quanta Article!</h3>
<p>Okay so I didn&#39;t actually write this one, but I played a role in it happening! A while back a friend visited, and we were chatting about his job at quanta. At the time he was working on this <a href="https://www.quantamagazine.org/complexity-theorys-50-year-journey-to-the-limits-of-knowledge-20230817/" target="_blank">mammoth article on metacomplexity theory</a>, so naturally the topic of <a href="https://buttondown.email/hillelwayne/archive/problems-harder-than-np-complete/" target="_blank">problems harder than NP-complete</a> came up and I recommend he check out Petri net reachability. So he did, and then he wrote <a href="https://www.quantamagazine.org/an-easy-sounding-problem-yields-numbers-too-big-for-our-universe-20231204/" target="_blank">An Easy-Sounding Problem Yields Numbers Too Big for Our Universe</a>. Gosh this is so exciting! </p>

                    
                

                
                    <p><em>If you&#39;re reading this on the web, you can subscribe <a href="https://buttondown.email/hillelwayne" target="_blank">here</a>. Updates are 6x a month. My main website is <a href="https://www.hillelwayne.com" target="_blank">here</a>.</em></p>
                
            </div></div>
  </body>
</html>
