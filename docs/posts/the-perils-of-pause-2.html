<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://cipht.net/2023/11/30/perils-of-pause.html">Original</a>
    <h1>the perils of pause(2)</h1>
    
    <div id="readability-page-1" class="page"><div id="universe">
<div id="post">
<h2><a href="http://cipht.net/2023/11/30/perils-of-pause.html">the perils of pause(2)</a>
<span>
<time>November 30, 2023</time>
<span>[c, posix, coccinelle]</span>
</span>
</h2>
<p>
I recently had a bug in a simple program that has a form I&#39;ve seen a
lot in the last few years: loops and signal handling without masking.
The worst thing about these kinds of bugs is that they don&#39;t rear
their heads immediately – they fall into the class of &#34;huh, it&#39;s
blocked in a syscall and I&#39;m sure it should have woken up&#34; bugs.
Let&#39;s look at the problem and then how to lint it.
</p>
<div id="outline-container-org9c04bcd">
<h2 id="org9c04bcd"><span>1.</span> A common mistake</h2>
<div id="text-1">
<p>
I had some tooling for a test suite that would wait for a specified
signal, and then print the name of that signal on stdout. I did this
by setting up a signal handler, and then calling <code>pause()</code>, which
suspends the program until a signal is delivered (i.e., it always
returns <code>EINTR</code>). The program indicates to its cooperating programs
that it&#39;s ready for the signal by printing &#34;ok&#34;.
</p>
<div>
<pre><span>static</span> <span>sig_atomic_t</span> <span>got</span>;
<span>static</span> <span>void</span> <span>h</span><span>(</span><span>int</span> <span>n</span><span>)</span> <span>{</span> got = n; <span>}</span>
<span>//</span><span>...</span>
    <span>if</span> <span>(</span>sigaction<span>(</span>sig, &amp;<span>(</span><span>struct</span> <span>sigaction</span><span>){</span>.sa_handler=h<span>}</span>, <span>NULL</span><span>)</span><span>)</span>
        <span>abort</span><span>()</span>;
    write<span>(</span>1, <span>&#34;ok\n&#34;</span>, 3<span>)</span>;
    <span>do</span> <span>{</span> pause<span>()</span>; <span>}</span> <span>while</span> <span>(</span>sig != got<span>)</span>;
</pre>
</div>
<p>
Every so often, this program will just hang and the test would time
out. Worse yet, it&#39;s rare enough that I didn&#39;t really notice it when
I wrote the code.<sup><a id="fnr.1" href="#fn.1" role="doc-backlink">1</a></sup> (Why loop when we only expect one signal?
There are other signals that will interrupt <code>pause</code> unless you&#39;ve gone
out of your way to ignore them all; for example, <code>SIGTSTP</code>.)
</p>
<p>
One possible problematic execution is this:
</p>
<ul>
<li>we print ok;</li>
<li>before we get to <code>pause</code>, the other program sends the signal;</li>
<li>now <code>sig == got</code>, but we <code>pause</code> anyway, and wait for another
signal that will never come.</li>
</ul>
<p>
Another common execution with this pattern is this:
</p>
<ul>
<li>we <code>pause</code>, and get interrupted by some other signal;</li>
<li>we test <code>got</code> against our desired <code>sig</code> and see it hasn&#39;t
triggered;</li>
<li>now our desired signal is delivered, and <code>sig == got</code>, but we&#39;re
already past the test;</li>
<li>we <code>pause</code> again, and have to wait arbitrarily long (till some
other signal wakes us up).</li>
</ul>
<p>
This also happens often in loops with <code>poll</code> or <code>select</code>:
</p>
<div>
<pre><span>for</span> <span>(</span>;;<span>)</span> <span>{</span>
    <span>// </span><span>A) either there&#39;s fd activity, or we get EINTR</span>
    <span>int</span> <span>n_active</span> = poll<span>(</span>fds, n_fds, INFTIM<span>)</span>;
    <span>// </span><span>[...] handle fds</span>
    <span>// </span><span>B) check variables set by signal handler</span>
    ...
<span>}</span>
</pre>
</div>
<p>
We expect poll to get interrupted if there&#39;s a signal, however the
signal may arrive after the test at B but before we get back to A.
</p>
<p>
The solution in all these cases are signal masks, and calls that
manipulate them atomically. When a signal arrives while masked by the
process, it remains pending until the process unmasks it.
</p>
</div>
</div>
<div id="outline-container-org0dad157">
<h2 id="org0dad157"><span>2.</span> Masking versus disposition</h2>
<div id="text-2">
<p>
Something that&#39;s always confusing about this is that masking a signal
does not affect its disposition. &#34;Signal disposition&#34; is the action
associated with a signal, that is, what should happen when the signal
is delivered to the process: either a handler is called, the signal is
ignored, or a default action takes place.
</p>
<p>
Knowing that, you might set a mask for some signal whose disposition
is <code>SIG_DFL</code>, and see that it works fine, and then be confused when
this doesn&#39;t work for signals whose disposition is <code>SIG_IGN</code>. POSIX
says:
</p>
<blockquote>
<p>
If the action associated with a blocked signal is anything other than
to ignore the signal, and if that signal is generated for the thread,
the signal shall remain pending until it is unblocked, it is accepted
when it is selected and returned by a call to the sigwait() function,
or the action associated with it is set to ignore the signal.
— <a href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_04_01">POSIX.1-2017 System Interfaces 2.4.1 Signal generation and delivery</a>
</p>
</blockquote>
<p>
I noticed that OpenBSD has the slightly strange behavior of treating
signals whose default disposition is to stop or continue the program
as if they have the ignored disposition, so these signals need an
explicit handler. This is probably a bug? Although it means we could
have avoided looping in our initial example, so one could argue it&#39;s
the better behavior.
</p>
<p>
Also, signal disposition is per-process, while signal masks are
per-thread – but let&#39;s not get into that mess here. (An even bigger
mess is then what happens on <code>exec()</code> – dispositions are reset, but
masks are inherited, as well as pending signals!)
</p>
</div>
</div>
<div id="outline-container-orgb1d2070">
<h2 id="orgb1d2070"><span>3.</span> Alternatives that atomically unmask</h2>
<div id="text-3">
<p>
In the case of <code>pause(2)</code>, we can use <code>sigsuspend(2)</code>, or a few other
similar functions. If we need the signal handler, our code might look
like this:
</p>
<div>
<pre><span>if</span> <span>(</span>sigaction<span>(</span>sig, &amp;<span>(</span><span>struct</span> <span>sigaction</span><span>){</span>.sa_handler=h<span>}</span>, <span>NULL</span><span>)</span><span>)</span>
    <span>abort</span><span>()</span>;
<span>sigset_t</span> <span>set</span>, <span>prev</span>;
sigemptyset<span>(</span>&amp;set<span>)</span>;
sigaddset<span>(</span>&amp;set, sig<span>)</span>;
<span>sigprocmask</span><span>(</span>SIG_BLOCK, &amp;set, &amp;prev<span>)</span>;
write<span>(</span>1, <span>&#34;ok\n&#34;</span>, 3<span>)</span>;
<span>do</span> <span>{</span> sigsuspend<span>(</span>&amp;prev<span>)</span>; <span>}</span> <span>while</span> <span>(</span>sig != got<span>)</span>;
</pre>
</div>
<p>
but in this case, we are just waiting for this signal, and don&#39;t need
to take other action when it arrives, so <code>sigwait(2)</code>
suffices:
</p>
<div>
<pre><span>sigset_t</span> <span>set</span>, <span>prev</span>;
sigemptyset<span>(</span>&amp;set<span>)</span>;
sigaddset<span>(</span>&amp;set, sig<span>)</span>;
<span>sigprocmask</span><span>(</span>SIG_BLOCK, &amp;set, &amp;prev<span>)</span>;
write<span>(</span>1, <span>&#34;ok\n&#34;</span>, 3<span>)</span>;
<span>int</span> <span>got</span>;
<span>do</span> <span>{</span> sigwait<span>(</span>&amp;set, &amp;got<span>)</span>; <span>}</span> <span>while</span> <span>(</span>sig != got<span>)</span>;
</pre>
</div>
<p>
We might use <code>sigwaitinfo</code> or <code>sigtimedwait</code> if we need more details
than just the signal number. If we were certain no other signal could
arrive, we could avoid the loop entirely, but it&#39;s nice to protect
against cases you might not otherwise consider, like testing the
program interactively and hitting ^Z (sending SIGTSTP).
</p>
<p>
(Note that OpenBSD also lacks <code>sigwaitinfo</code> and <code>sigtimedwait</code>
presently.)
</p>
<p>
For <code>poll(2)</code> and <code>select(2)</code>, unmasking variants <code>ppoll(2)</code> and
<code>pselect(2)</code> exist for this reason. (Linux also has <code>signalfd(2)</code>,
which more naturally integrates with polling loops, but note it only
reads pending signals, so you still need to mask with <code>sigprocmask</code>,
and now you have to deal with reading <code>siginfo</code> out of a buffer. Oh,
and what you actually get out of the fd depends on which process is
reading…) There&#39;s also the classic <a href="https://cr.yp.to/docs/selfpipe.html">self-pipe trick</a>.
</p>
</div>
</div>
<div id="outline-container-orga6115fe">
<h2 id="orga6115fe"><span>4.</span> Linting</h2>
<div id="text-4">
<p>
This makes me wonder about some kind of review-level lints that only
apply to new code being added. Ideally we&#39;d flag any code which
accesses variables assigned from signal handlers and calls one of
these functions, in a loop.
</p>
<p>
Here&#39;s my attempt at partially doing this with coccinelle:
</p>
<div>
<pre><span>@@</span>
sig_atomic_t signal_handler_variable<span>;</span>
<span>@@</span>
<span>*   signal_handler_variable</span>
    <span>...</span>
<span>*   \(pause\|poll\|select\)(...)</span>

<span>@@</span>
sig_atomic_t signal_handler_variable<span>;</span>
<span>@@</span>
<span>*   \(pause\|poll\|select\)(...)</span>
    <span>...</span>
<span>*   signal_handler_variable</span>

</pre>
</div>
<p>
This will match any function that contains access to a <code>sig_atomic_t</code>
and a call to <code>pause</code>, <code>poll</code>, or <code>select</code>. If you save that as
<code>lint-pause.cocci</code>, you can check code with
</p>
<pre id="org06840cc">spatch --very-quiet --sp-file lint-pause.cocci path/to/c/files
</pre>
<p>
Note that I am just using <code>*</code> to print out match cases for brevity,
but you can add Python scripts to coccinelle rules for much
prettier/more elaborate reporting.
</p>
<p>
It&#39;s possible to do much more careful matching, like ensuring the poll
calls happen in a loop, or only matching polls with no timeout, but
this simple form is sufficient to catch interesting cases to examine
later. I also discovered while writing a more elaborate form that <code>do
{} while</code> matching was <a href="https://gitlab.inria.fr/coccinelle/coccinelle/-/merge_requests/190">only merged last year</a> and distributions tend to
carry older version of <code>spatch</code>.
</p>
<p>
Note that it only catches use of <code>sig_atomic_t</code>; while testing this, I
found some old code that just doesn&#39;t even use <code>volatile</code>; at some
point I may write a more elaborate script that flags all globals set
from any function passed to <code>sigaction</code>, but as a review reminder,
this simpler form suffices for my needs.
</p>
</div>
</div>
<div id="outline-container-org3c59b65">
<h2 id="org3c59b65"><span>5.</span> Conclusion</h2>
<div id="text-5">
<ul>
<li>dash had a bug of this flavor, and <a href="https://git.kernel.org/pub/scm/utils/dash/dash.git/commit/?id=3800d4934391b144fd261a7957aea72ced7d47ea">fixed it with sigsuspend</a>;</li>
<li>busybox ash and hush <a href="https://git.busybox.net/busybox/commit/shell/shell_common.c?id=a277506a64404e6c4472ff89c944c4f353db1c33">acknowledge that they have this bug</a>.</li>
</ul>
<p>
I notice that Kerrisk&#39;s LPI talks about pause in section 20.14, but
doesn&#39;t note its perils, except to indicate that other ways will be
investigated in section 22.9. There, Kerrisk introduces sigsuspend
and talks about exactly our problem with pause.
</p>
<p>
<a href="https://sourceware.org/glibc/manual/html_node/Pause-Problems.html">glibc&#39;s info page</a> talks about this extensively, so it&#39;s unfortunate
that, for example, <a href="https://man7.org/linux/man-pages/man2/pause.2.html">Linux&#39;s man page for pause(2)</a> contains no such
details.
</p>
<p>
Running the aforementioned coccinelle script across an arbitrary
corpus of packages I have on hand turns up a number of likely
instances of this bug, so this is still an issue worth keeping in
mind.
</p>
</div>
</div>


</div>
</div></div>
  </body>
</html>
