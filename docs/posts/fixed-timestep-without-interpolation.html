<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jakubtomsu.github.io/posts/fixed_timestep_without_interpolation/">Original</a>
    <h1>Fixed Timestep Without Interpolation</h1>
    
    <div id="readability-page-1" class="page"><div><p>Some time ago I wrote a <a href="https://jakubtomsu.github.io/posts/input_in_fixed_timestep/">blog post</a> about the tick setup in my engine, why and how I use fixed timestep update loops. It also explained how to actually use it in practice when dealing with input etc.</p><p>The general idea is this: the game would keep an accumulator timer and only simulate steps with a constant delta time, which is great for stability and predictability.</p><p>This was mostly inspired by server code for multiplayer games, so I naturally also implemented game state interpolation, which multiplayer games use as well. However I have some issues with regular interpolation, it adds unnecessary latency and it’s also annoying to implement.</p><p>Turns out there are other ways to do it! It’s possible to use the game tick to “predict” the render game state without explicitly writing any interpolation code. That’s what this post is about.</p><p>I also made a <a href="#demo">Demo</a> program which implements all of the different methods mentioned.</p><p>Here is what the <strong>old</strong> game loop looked like. The game kept track of the game state from the previous tick, and then used this for interpolation with the time remainder.</p><div><pre tabindex="0"><code data-lang="go"><span><span> 1</span><span><span>DELTA</span> <span>::</span> <span>1.0</span> <span>/</span> <span>60.0</span>
</span></span><span><span> 2</span><span>
</span></span><span><span> 3</span><span><span>accumulator</span><span>:</span> <span>f32</span>
</span></span><span><span> 4</span><span><span>game</span><span>:</span> <span>Game</span>
</span></span><span><span> 5</span><span><span>prev_game</span><span>:</span> <span>Game</span>
</span></span><span><span> 6</span><span><span>prev_time</span> <span>:=</span> <span>time</span><span>.</span><span>tick_now</span><span>()</span>
</span></span><span><span> 7</span><span>
</span></span><span><span> 8</span><span><span>for</span> <span>!</span><span>quit</span> <span>{</span>
</span></span><span><span> 9</span><span>    <span>frame_duration</span> <span>:=</span> <span>f32</span><span>(</span><span>time</span><span>.</span><span>duration_seconds</span><span>(</span><span>time</span><span>.</span><span>tick_since</span><span>(</span><span>prev_time</span><span>)))</span>
</span></span><span><span>10</span><span>    <span>prev_time</span> <span>=</span> <span>time</span><span>.</span><span>tick_now</span><span>()</span>
</span></span><span><span>11</span><span>    <span>accumulator</span> <span>+=</span> <span>frame_duration</span>
</span></span><span><span>12</span><span>    <span>for</span> <span>;</span><span>accumulator</span> <span>&gt;</span> <span>DELTA</span><span>;</span> <span>accumulator</span> <span>-=</span> <span>DELTA</span> <span>{</span>
</span></span><span><span>13</span><span>        <span>runtime</span><span>.</span><span>mem_copy_non_overlapping</span><span>(</span><span>&amp;</span><span>prev_game</span><span>,</span> <span>&amp;</span><span>game</span><span>,</span> <span>size_of</span><span>(</span><span>Game</span><span>))</span>
</span></span><span><span>14</span><span>        <span>game_tick</span><span>(</span><span>&amp;</span><span>game</span><span>,</span> <span>DELTA</span><span>)</span>
</span></span><span><span>15</span><span>    <span>}</span>
</span></span><span><span>16</span><span>    <span>// Remainder to go from fixed time to real time.
</span></span></span><span><span>17</span><span><span></span>    <span>// Always in 0..1 range.
</span></span></span><span><span>18</span><span><span></span>    <span>alpha</span> <span>:=</span> <span>accumulator</span> <span>/</span> <span>DELTA</span>
</span></span><span><span>19</span><span>    <span>// Interpolates between previous and current game state with the alpha factor.
</span></span></span><span><span>20</span><span><span></span>    <span>game_draw</span><span>(</span><span>game</span><span>,</span> <span>prev_game</span><span>,</span> <span>alpha</span><span>)</span>
</span></span><span><span>21</span><span><span>}</span>
</span></span></code></pre></div><p>The fundamental issue is that the fixed timestep simulation does as many timesteps as possible, however because the frame-rate is variable, the real time doesn’t always match the fixed time.</p><p>So the solution is very simple, after the fixed timestep simulation is done, we need to simulate one more additional tick with the remaining time. However this additional tick could mess up our game state, because the time step is no longer fixed - this is a problem especially for things like physics.</p><h2 id="render-tick">Render Tick</h2><p>For this reason we <strong>duplicate</strong> the entire game state into a new, temporary render-only game state, and simulate the tick on this one. That way the fixed timestep game state stays untouched. So we <strong>“predict”</strong> what’s gonna happen at a particular point in time between current fixed tick and the next one.</p><div><pre tabindex="0"><code data-lang="go"><span><span> 1</span><span><span>DELTA</span> <span>::</span> <span>1.0</span> <span>/</span> <span>60.0</span>
</span></span><span><span> 2</span><span>
</span></span><span><span> 3</span><span><span>accumulator</span><span>:</span> <span>f32</span>
</span></span><span><span> 4</span><span><span>game</span><span>:</span> <span>Game</span>
</span></span><span><span> 5</span><span><span>temp_game</span><span>:</span> <span>Game</span>
</span></span><span><span> 6</span><span><span>prev_time</span> <span>:=</span> <span>time</span><span>.</span><span>tick_now</span><span>()</span>
</span></span><span><span> 7</span><span>
</span></span><span><span> 8</span><span><span>for</span> <span>!</span><span>quit</span> <span>{</span>
</span></span><span><span> 9</span><span>    <span>frame_duration</span> <span>:=</span> <span>f32</span><span>(</span><span>time</span><span>.</span><span>duration_seconds</span><span>(</span><span>time</span><span>.</span><span>tick_since</span><span>(</span><span>prev_time</span><span>)))</span>
</span></span><span><span>10</span><span>    <span>prev_time</span> <span>=</span> <span>time</span><span>.</span><span>tick_now</span><span>()</span>
</span></span><span><span>11</span><span>    <span>accumulator</span> <span>+=</span> <span>frame_duration</span>
</span></span><span><span>12</span><span>    <span>for</span> <span>;</span><span>accumulator</span> <span>&gt;</span> <span>DELTA</span><span>;</span> <span>accumulator</span> <span>-=</span> <span>DELTA</span> <span>{</span>
</span></span><span><span>13</span><span>        <span>// Simulate the game state (without keeping previous game state!)
</span></span></span><span><span>14</span><span><span></span>        <span>game_tick</span><span>(</span><span>&amp;</span><span>game</span><span>,</span> <span>DELTA</span><span>)</span>
</span></span><span><span>15</span><span>    <span>}</span>
</span></span><span><span>16</span><span>    <span>// Remainder to go from fixed time to real time.
</span></span></span><span><span>17</span><span><span></span>    <span>// Always in 0..DELTA range.
</span></span></span><span><span>18</span><span><span></span>    <span>alpha</span> <span>:=</span> <span>accumulator</span>
</span></span><span><span>19</span><span>    <span>// &#34;Create&#34; a duplicate version of the game state so our
</span></span></span><span><span>20</span><span><span></span>    <span>// &#34;render tick&#34; doesn&#39;t affect the real game state.
</span></span></span><span><span>21</span><span><span></span>    <span>runtime</span><span>.</span><span>mem_copy_non_overlapping</span><span>(</span><span>&amp;</span><span>temp_game</span><span>,</span> <span>&amp;</span><span>game</span><span>,</span> <span>size_of</span><span>(</span><span>Game</span><span>))</span>
</span></span><span><span>22</span><span>    <span>// Simulate the temp state forward in time to match reality.
</span></span></span><span><span>23</span><span><span></span>    <span>game_tick</span><span>(</span><span>&amp;</span><span>temp_game</span><span>,</span> <span>alpha</span><span>)</span>
</span></span><span><span>24</span><span>    <span>// No need to do any interpolation now, just render the game state as it is.
</span></span></span><span><span>25</span><span><span></span>    <span>// It matches real time pretty much perfectly.
</span></span></span><span><span>26</span><span><span></span>    <span>game_draw</span><span>(</span><span>temp_game</span><span>)</span>
</span></span><span><span>27</span><span><span>}</span>
</span></span></code></pre></div><blockquote><p>Note:
This method probably won’t work very well in cases when <code>game_tick</code> can take a very significant amount of time, or the game state is gigantic, e.g. in a big AAA game which needs to run the physics engine and whatnot.</p></blockquote><h2 id="game-state-duplication">Game state duplication</h2><p>In a more traditional system with individually dynamically allocated objects this might be a bit of an issue.
Even if your language can do a <em>deep copy</em> of an object which holds the game state, the individual allocations could take a long time or it could make the GC sad.</p><p>In my case the <em>entire</em> game state is trivially copyable, because:</p><ol><li>I never store any pointers. ever. Only integer indexes or handles.</li><li>All of the datastructures are fixed size, no dynamic allocations.</li></ol><p>That means I can easily do <code>memcpy</code> and get a duplicate game state without any issues. This setup makes things a whole lot easier to deal with.</p><h2 id="what-about-input">What about input?</h2><p>Just like the last time, the <code>game_tick</code> needs to get the input from somewhere. This is easy, because the main update loop is pretty much the same like in the interpolation case! So the solution from my original post still applies, you can just use a separate <code>frame_input</code> and a <code>tick_input</code>.</p><p>But what about the temp render tick?</p><p>But I found re-applying the <code>tick_input</code> in exactly the same way as in the fixed update loop works decently well. You also want to clear the “pressed” and “released” flags from the input, because those were already applied in the fixed update loop. If you use my implementation from previous article you don’t need to do this directly, the fixed update loop does this on it’s own anyway.</p><p>So here is how to accumulate the input states every frame:</p><div><pre tabindex="0"><code data-lang="go"><span><span>1</span><span><span>tick_input</span><span>.</span><span>cursor</span> <span>=</span> <span>frame_input</span><span>.</span><span>cursor</span>
</span></span><span><span>2</span><span><span>// _accumulate_ temp flags instead of overwriting
</span></span></span><span><span>3</span><span><span></span><span>for</span> <span>flags</span><span>,</span> <span>action</span> <span>in</span> <span>frame_input</span><span>.</span><span>actions</span> <span>{</span>
</span></span><span><span>4</span><span>    <span>// Bitwise OR the bit flags
</span></span></span><span><span>5</span><span><span></span>    <span>tick_input</span><span>.</span><span>actions</span><span>[</span><span>action</span><span>]</span> <span>+=</span> <span>flags</span>
</span></span><span><span>6</span><span><span>}</span>
</span></span></code></pre></div><p>And this is how to apply it. Note how the temp flags are cleared after every tick, and all flags are cleared at the end of a frame when any tick happened.</p><div><pre tabindex="0"><code data-lang="go"><span><span>1</span><span><span>any_tick</span> <span>:=</span> <span>accumulator</span> <span>&gt;</span> <span>delta</span>
</span></span><span><span>2</span><span><span>for</span> <span>;</span><span>accumulator</span> <span>&gt;</span> <span>delta</span><span>;</span> <span>accumulator</span> <span>-=</span> <span>delta</span> <span>{</span>
</span></span><span><span>3</span><span>    <span>game_tick</span><span>(</span><span>&amp;</span><span>game</span><span>,</span> <span>tick_input</span><span>,</span> <span>delta</span><span>)</span>
</span></span><span><span>4</span><span>    <span>input_clear_temp</span><span>(</span><span>&amp;</span><span>tick_input</span><span>)</span>
</span></span><span><span>5</span><span><span>}</span>
</span></span><span><span>6</span><span><span>runtime</span><span>.</span><span>mem_copy_non_overlapping</span><span>(</span><span>&amp;</span><span>temp_game</span><span>,</span> <span>&amp;</span><span>game</span><span>,</span> <span>size_of</span><span>(</span><span>Game</span><span>))</span>
</span></span><span><span>7</span><span><span>game_tick</span><span>(</span><span>&amp;</span><span>temp_game</span><span>,</span> <span>tick_input</span><span>,</span> <span>accumulator</span><span>)</span>
</span></span><span><span>8</span><span><span>game_draw</span><span>(</span><span>temp_game</span><span>)</span>
</span></span><span><span>9</span><span><span>if</span> <span>any_tick</span> <span>do</span> <span>tick_input</span> <span>=</span> <span>{}</span>
</span></span></code></pre></div><p>(see the <a href="#demo">Demo</a> source code for the full implementation)</p><h2 id="different-tps-is-a-fundamentally-different-problem">Different TPS is a fundamentally different problem</h2><p>Something I’ve realized while working on this post and the Demo is how different the problem you’re trying to solve is, depending on your TPS. So here is what I think is a good way to roughly categorize it:</p><ul><li><p>~10 TPS: Here the way you render the in-between game states matters <em>a lot</em>. Latency from interpolation is <em>huge</em> but the predicted render ticks can be jittery because of different simulation results. And the exact way you accumulate inputs and how you pass them in the game matters a lot as well. This is completely unusable for any kind of real time action game.</p></li><li><p>30-60 TPS: This is the most common for regular games. In this case the render tick method works really well, because there is almost no jitter due to input sampling inaccuracies. But the smoothing is still very visible. The added latency from interpolation is not <em>that</em> noticeable. However if you’re making a fast-paced action game, you probably want to eliminate every millisecond of unnecessary latency.</p></li><li><p>~120+ TPS: At this point any kind of interpolation accounts for only a tiny fraction of a second. The only reason you might want to use it to remove some jitter, but it’s just not very significant.</p></li></ul><h3 id="accumulated-render-tick">Accumulated render tick</h3><p>In case you wanted to run only a very small number of fixed update ticks per second, the basic render tick method described above has some limitations. The temporary render tick always uses the last fixed tick, which means as your fixed delta increases your render tick might be doing a single, very large time step.</p><blockquote><p>This is not an issue in most singleplayer PC games. That’s because you <em>probably</em> want to simulate &gt;30 ticks per second anyway, for stability reasons and just because there’s no reason to push TPS lower.</p></blockquote><p>The solution is to copy game state into temp game state <em>only</em> if you simulated a fixed tick that frame. Otherwise you keep simulating the old temp game state. This also means you need to keep another separate remainder timer, because alpha is no longer valid for each render tick.</p><p>This is similar to client-side prediction in real-time multiplayer games.</p><p>One issue is jitter, the difference in frequency of input between fixed and predicted ticks is so significant the render game state can get out of sync. One solution is to interpolate to sync the game states instead of doing that instantly. Alternatively you could modify the render tick inputs to eliminate high frequency inputs, and maybe even completely disable “pressed” and “released” key events.</p><p>I don’t do this in my game, simply because I didn’t run into issues with the current, simpler approach. But I thought I should mention it anyway.</p><p>I wrote a small demo game in Odin and Raylib to demonstrate the different fixed timestep rendering methods.</p><p><strong>See the <a href="https://github.com/jakubtomsu/fixed-timestep-demo">Github Repository</a> for source code.</strong></p><p>Here is how the various simulation modes look like when running at 4 ticks per second. This is a very low TPS only for demonstration purposes.</p><p>Without any kind of smoothing at all the game is very choppy:</p><p><img src="https://jakubtomsu.github.io/posts/fixed_timestep_without_interpolation/no_smoothing.gif" alt="no smoohting"/></p><p>The regular interpolation looks smooth but it’s a bit delayed (the “onion skinning” shows the current game state drawn as green, previous as red):</p><p><img src="https://jakubtomsu.github.io/posts/fixed_timestep_without_interpolation/interpolated.gif" alt="inerpolation"/></p><p>This is the regular render tick method, it looks fairly smooth and importantly there is no lag:</p><p><img src="https://jakubtomsu.github.io/posts/fixed_timestep_without_interpolation/render_tick.gif" alt="render tick"/></p><p>Here is a very high TPS simulation just for comparison:</p><p><img src="https://jakubtomsu.github.io/posts/fixed_timestep_without_interpolation/reference.gif" alt="reference"/></p><h2 id="overview">Overview</h2><p>Let’s summarize the all the different methods from the demo and how they compare to each other. There is no clear winner, it depends on your engine, game and your circumstances.</p><ul><li><p>Interpolation: Always smooth. Needs a way to interpolate two game states, this can be a pain to implement. Always lags one tick behind - this means worse latency, especially with low TPS.</p></li><li><p>Render Tick: No added latency, matches real time “perfectly”. Very easy to implement, especially if your game state and tick is set up in a nice way. However the single render tick can get inaccurate with low TPS because each update step is linear.</p></li><li><p>Accumulated Render Tick: More accurate in low TPS simulations, however because of the input frequency is so different between the predicted and the fixed ticks it can get out of sync.</p></li></ul><blockquote><p>In my case, I’m making a fast paced singleplayer game and I have no issue setting the TPS to 30 or even 60. For this reason the Render Tick is by far the best fit.</p></blockquote><p>This isn’t related to the main topic of this post, because it applies to any kind of gameplay where the timestep is fixed (it doesn’t matter whether you use prediction or interpolation). But if your gameplay is deterministic, meaning you always get the same game state T+1 by simulating game state T with the same input, there is a neat trick to do game replay.</p><p>Regular replay systems would have to periodically store the game state, which ends up consuming a lot of memory, even if you try to compress it. But if your game is deterministic you only need to store the <em>starting</em> game state (or even just the starting settings to generate the game state), and then inputs for all the fixed timesteps. Then when you can just simulate the original game state N times to get any tick you want, once you need to do the replay.</p><p>By the way, this is what Media Molecule does in Dreams. The Trackmania racing games do this as well, to verify runs and make sure people aren’t cheating. Even their 3d physics engine is fully deterministic! very cool stuff.</p><blockquote><p>Notes:</p><ol><li>You need to make sure entities are always updated in the same order. This means deterministic O(1) datastructures like pools are your friend.</li><li>If you use random numbers then you need to make sure the seeds match at the start of every tick as well. You can probably get by storing only one seed along with the first</li><li>The stored replay gets invalidated once you change your gameplay logic, so this method is generally useful for debugging only.</li></ol></blockquote><p>Thank you for reading, I hope this can be useful in your engine/game project! Also let me know if you have any feedback, if you know how to improve any of the methods I explained here, or you know of an even better method:)</p><h2 id="credit">Credit</h2><p>After I published the original blog post, a number of people messaged me it helped them with use fixed timestep update loops in their game/engine as well. However some people complained specifically about the interpolation step, it can be kinda cumbersome to do, especially if you want to interpolate more properties than just the entity transform.</p><p>I was told about the render tick method by Radek Jurga on discord, a fellow handmade programmer. He uses it in his engine as well! And he found out about it from an old <a href="https://youtu.be/fdAOPHgW7qM?si=chCqgUTNoOLuHDvy">Jonathan Blow Q&amp;A stream</a> which is a much more in-depth explanation of this entire topic.</p></div></div>
  </body>
</html>
