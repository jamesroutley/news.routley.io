<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://xania.org/202512/01-xor-eax-eax">Original</a>
    <h1>Why xor eax, eax?</h1>
    
    <div id="readability-page-1" class="page"><div>
    <div>
        <h2>Why xor eax, eax?</h2>

        <p>Written by me, proof-read by an LLM.
</p>
<p>In <a href="https://youtu.be/7PFwUpXKLrg">one of my talks on assembly</a>, I show a list of the <a href="https://mattgodbolt.github.io/yow-conversational-asm/#/2/2">20 most executed instructions</a> on an average x86 Linux desktop. All the usual culprits are there, <code>mov</code>, <code>add</code>, <code>lea</code>, <code>sub</code>, <code>jmp</code>, <code>call</code> and so on, but the surprise interloper is <code>xor</code> - “eXclusive OR”. In my 6502 hacking days, the presence of an exclusive OR was a sure-fire indicator you’d either found the encryption part of the code, or some kind of sprite routine. It’s surprising then, that a Linux machine just minding its own business, would be executing so many.</p>
<p>That is, until you remember that compilers love to emit a <code>xor</code> when setting a register to zero:</p>


<p>We know that exclusive-OR-ing anything with itself generates zero, but why <em>does</em> the compiler emit this sequence? Is it just showing off?</p>
<p>In the example above, I’ve compiled with <code>-O2</code> and enabled <a href="https://godbolt.org">Compiler Explorer</a>’s “Compile to binary object” so you can view the machine code that the CPU sees, specifically:</p>
<div><pre><code><span>31 c0</span><span>           </span><span>xor</span><span> </span><span>eax</span><span>,</span><span> </span><span>eax</span>
<span>c3</span><span>              </span><span>ret</span>
</code></pre></div>

<p>If you change GCC’s optimisation level down to <code>-O1</code> you’ll see:</p>
<div><pre><code><span>b8 00 00 00 00</span><span>  </span><span>mov</span><span> </span><span>eax</span><span>,</span><span> </span><span>0x0</span>
<span>c3</span><span>              </span><span>ret</span>
</code></pre></div>

<p>The much clearer, more intention-revealing <code>mov eax, 0</code> to set the EAX register to zero takes up five bytes, compared to the two of the exclusive OR. By using a slightly more obscure instruction, we save three bytes every time we need to set a register to zero, which is a pretty common operation. Saving bytes makes the program smaller, and makes more efficient use of the instruction cache.</p>
<p>It gets better though! Since this is a <em>very</em> common operation, x86 CPUs spot this “zeroing idiom” early in the pipeline and can specifically optimise around it: the out-of-order tracking systems knows that the value of “eax” (or whichever register is being zeroed) does not depend on the previous value of eax, so it can allocate a fresh, dependency-free zero register renamer slot. And, having done that <em>it removes the operation from the execution queue</em> - that is the <code>xor</code> takes zero execution cycles!<sup id="fnref:retire"><a href="#fn:retire">1</a></sup> It’s essentially optimised out by the CPU!</p>
<p>You may wonder why you see <code>xor eax, eax</code> but never <code>xor rax, rax</code> (the 64-bit version), even when returning a <code>long</code>:</p>


<p>In this case, even though <code>rax</code> is needed to hold the full 64-bit <code>long</code> result, by writing to <code>eax</code>, we get a nice effect: Unlike other partial register writes, when writing to an <code>e</code> register like <code>eax</code>, the architecture zeros the top 32 bits for free. So <code>xor eax, eax</code> sets all 64 bits to zero.</p>
<p>Interestingly, when zeroing the “extended” numbered registers (like <code>r8</code>), GCC still uses the <code>d</code> (double width, ie 32-bit) variant:</p>


<p>Note how it’s <code>xor r8d, r8d</code> (the 32-bit variant) even though with the REX prefix (here <code>45</code>) it would be the same number of bytes to <code>xor r8, r8</code> the full width. Probably makes something easier in the compilers, as clang does this too.</p>
<p><code>xor eax, eax</code> saves you code space <em>and</em> execution time! Thanks compilers!</p>
<p><em>See <a href="https://youtu.be/eLjZ48gqbyg">the video</a> that accompanies this post.</em></p>
<hr/>
<p><em>This post is day 1 of <a href="https://xania.org/AoCO2025">Advent of Compiler Optimisations 2025</a>,
a 25-day series exploring how compilers transform our code.</em></p>
<p><em>This post was written by a human (<a href="https://xania.org/MattGodbolt">Matt Godbolt</a>) and reviewed and proof-read LLMs and humans.</em></p>
<p><em>Support Compiler Explorer on <a href="https://patreon.com/c/mattgodbolt">Patreon</a>
or <a href="https://github.com/sponsors/compiler-explorer">GitHub</a>,
or by buying CE products in the <a href="https://shop.compiler-explorer.com">Compiler Explorer Shop</a></em>.</p>

    </div>
</div></div>
  </body>
</html>
