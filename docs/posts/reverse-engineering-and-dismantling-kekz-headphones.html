<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nv1t.github.io/blog/kekz-headphones/">Original</a>
    <h1>Reverse Engineering and Dismantling Kekz Headphones</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>Close to a year ago, I stumbled upon the Kekz Headphones, which seemed like an interesting approach on the whole digital audio device space. They claimed to work without any internet connection and all of the content already on the headphones itself. They are On-Ear Headphones, which work by placing a small chip (I call them “Kekz” or “Cookie”) into a little nook on the side and it plays an audio story.
I was intrigued, because there were some speculations going around, how they operate with those “Kekz”-Chips.</p><p>I invite you to join me on a journey into the inner workings of those headphones. We will talk about accessing the encrypted files on the device, breaking the crypto and discovering disclosure of data from customers.</p><p>I sourced my headphones from “Kleinanzeigen” (something like craigslist, or facebook marketplace) to keep the research costs low and maybe get some cookies with it. I got the wonderful colour red.
<img src="https://nv1t.github.io/blog/img/2024/9fedcf0c1ac98650a8055d6744523e91.png" alt="Headphones opened up, PCBs hanging out, Kekz chips are lying to the left."/>
After opening up the headphones, you will have 2 PCBs which are connected by 7 wires. Two speakers and a battery. The chinese lettering in the silk layer is just the colour description of the wires itself. You don’t see any interesting breakout for anything here. The Pin-Row in the middle is for the NFC antenna on the other side of the board. You see two Vias with the label <code>DP</code> and <code>DM</code>, which is on the USB line. This will be interesting at a later stage.</p><p><img src="https://nv1t.github.io/blog/img/2024/9c2962c7adb42ddbf4c88bb9f44b7d7a.jpg" alt="PCB of one of the ears, which has the important chips on it. Description is in the text."/>
The first thing that stands out is a Jieli Chip, which appears to be the core component of the entire headset. These chips are mostly used in cheap Bluetooth hardware and are difficult to determine which version is currently running. From a quick search i think this Chip (<code>AC21BP0H733-51C8</code>) is probably some version of the <code>AC6951C</code>.</p><p>The chip on the bottom, <code>TSC9883</code>, is a NFC Reader IC, which I don’t care for.</p><p>It has two infrared proximity sensors to detect the ear and cookie insertion to prevent from reading a cookie more than once and stop when taking off the headphones.</p><p>On the right of the PCB you see an SD cardholder, which has a 32gb SD Card on the inside. The SD Card has a Fat32 Filesystem with 276 directories. There is an update, which ups that to around 369 directories. Each directory has multiple files with the extension <code>kez</code>, which are most likely encrypted.</p><p><img src="https://nv1t.github.io/blog/img/2024/87e3e2c1ef721f3e60733fc2e0e3149e.png" alt="Directory and Filelisting from the SD Card"/></p><p>Interestingly, I was looking at the SD Card before and I connected the headphones to the accompanied Windows Application. After the connection, the files were gone and I was kinda puzzled, until I found the following code in the application:</p><div><pre tabindex="0"><code data-lang="csharp"><span><span><span>public</span> <span>static</span> <span>void</span> HideFolders()
</span></span><span><span>{
</span></span><span><span>	<span>if</span> (Globals.Drive == <span>null</span>)
</span></span><span><span>	{
</span></span><span><span>		<span>throw</span> <span>new</span> Exception(<span>&#34;Drive not set&#34;</span>);
</span></span><span><span>	}
</span></span><span><span>	<span>string</span> drive = Globals.Drive;
</span></span><span><span>	<span>string</span>[] directories = Directory.GetDirectories(drive);
</span></span><span><span>	<span>for</span> (<span>int</span> i = <span>0</span>; i &lt; directories.Length; i++)
</span></span><span><span>	{
</span></span><span><span>		DirectoryInfo directoryInfo = <span>new</span> DirectoryInfo(directories[i]);
</span></span><span><span>		<span>if</span> (<span>int</span>.TryParse(directoryInfo.Name, <span>out</span> <span>var</span> _))
</span></span><span><span>		{
</span></span><span><span>			directoryInfo.Attributes |= FileAttributes.Hidden;
</span></span><span><span>		}
</span></span><span><span>	}
</span></span><span><span>	<span>new</span> FileInfo(Path.Combine(drive, <span>&#34;kekzId.json&#34;</span>)).Attributes |= FileAttributes.Hidden;
</span></span><span><span>}
</span></span></code></pre></div><p>They seem to set the hidden Attribute on the first connect, so the files are not easily discovered.</p><p>We have multiple options to attack this system. We can either try to dump the firmware of the main controller chip and reverse engineer that, or we understand, how a “Kekz” works.</p><p>As we currently have little information about the controller, and we haven’t looked into the NFC Communication yet, let’s first check the cookies themselves and go the easy route.</p><p>I have a <a href="https://proxmark.com/">Proxmark3</a> lying around and if we try to “just read” a Kekz, it will result in an error, as it seems to be locked:</p><pre tabindex="0"><code>[usb] pm3 --&gt; hf mfu info

[=] --- Tag Information --------------------------
[+]       TYPE: NTAG 213 144bytes (NT2H1311G0DU)

[=] --- Tag Counter
[=]        [02]: 00 00 00
[+]             - 00 tearing ( fail )

[=] --- Tag Signature
[=]     Elliptic curve parameters: NID_secp128r1
[=]              TAG IC Signature: 0000000000000000000000000000000000000000000000000000000000000000
[+]        Signature verification ( fail )

[=] --- Tag Version
[=]        Raw bytes: 00 53 04 02 01 00 0F 03
[=]        Vendor ID: 53, Shanghai Feiju Microelectronics Co. Ltd. China
[=]     Product type: NTAG
[=]  Product subtype: 02, 50pF
[=]    Major version: 01
[=]    Minor version: 00
[=]             Size: 0F, (256 &lt;-&gt; 128 bytes)
[=]    Protocol type: 03, ISO14443-3 Compliant
[?] Hint: try `hf mfu pwdgen -r` to get see known pwd gen algo suggestions
[=] ------------------------ Fingerprint -----------------------
[=] Reading tag memory...
[#] Cmd Error: 00
[#] Read block 0 error
[!] ⚠️  Failed reading card
[=] ------------------------------------------------------------

[=] Tag appears to be locked, try using a key to get more info
</code></pre><p>We could either Brute-Force (not sure, if this will result in a locked chip), or we can just sniff the communication between the headset and the cookie. By holding the proxmark near the reader of the headset and inserting a cookie, we will get the whole communication between the reader itself and this cookie, which reveals the authentication Key.</p><p><img src="https://nv1t.github.io/blog/img/2024/a1d514983cf67277c9e02790df905202.png" alt="Trace of the NFC communication with the password for the chips highlighted in a red box"/>
It then tries to read the 0 block and the 7th block. The 0 block is only the ID of the tag which bears no relevance. If we look into the 7th block and further, though, we can see a string “en002071696263”, if we dump the whole cookie. That is quite interesting.</p><pre tabindex="0"><code>[usb] pm3 --&gt; hf mfu dump -k FFFFFFFF
[+] TYPE: NTAG 213 144bytes (NT2H1311G0DU)
[+] Reading tag memory...

[=] MFU dump file information
[=] -------------------------------------------------------------
[...redacted...]
[=] -------------------------------------------------------------
[=] block#   | data        |lck| ascii
[=] ---------+-------------+---+------
[=]   0/0x00 | 53 BA 20 41 |   | S. A
[=]   1/0x01 | 46 70 00 01 |   | Fp..
[=]   2/0x02 | 37 48 00 00 |   | 7H..
[=]   3/0x03 | E1 10 12 00 | 0 | ....
[=]   4/0x04 | 01 03 A0 0C | 0 | ....
[=]   5/0x05 | 34 03 00 FE | 0 | 4...
[=]   6/0x06 | 00 00 00 00 | 0 | ....
[=]   7/0x07 | 65 6E 30 30 | 0 | en00
[=]   8/0x08 | 32 30 37 31 | 0 | 2071
[=]   9/0x09 | 36 39 36 32 | 0 | 6962
[=]  10/0x0A | 36 33 FE 00 | 0 | 63..
[...redacted...]
[=] ---------------------------------
[=] Using UID as filename
[+] saved 236 bytes to binary file /.proxmark3/files/hf-mfu-53BA2046700001-dump.bin
[+] saved 59 blocks to text file ./.proxmark3/files/hf-mfu-53BA2046700001-dump.eml
[+] saved to json file /.proxmark3/files/hf-mfu-53BA2046700001-dump.json
</code></pre><p>We can check our theory by copying over this string to another cookie, and you will discover, it works. Therefore, <strong>we can clone cookies now.</strong></p><p><img src="https://nv1t.github.io/blog/img/2024/8ca30bafd2e46943f989143f33dab0b8.png" alt="Image of a bunny and cat looking alike next to each other."/></p><p>Even if the outside looks different, it plays the same content and is a bunny by heart.</p><p>At this point, it is possible to read this string and build a database to decrypt all content. We just have access to the ones we have already seen.
As those tags are 13.35Mhz, is is also possible to write them by your Phones NFC (you will see this later on)</p><p>We have this weird string <code>en002071696263</code> which has something to do with playing the content and we know the content is probably one of those directories we did see earlier on the SD-card.</p><p>If we begin to delete one directory after the other, we can determine which directory has the desired content inside. For this cookie, the directory is <code>0020</code>. If we look into other cookies we will see the structure is:</p><table><thead><tr><th>Cookie</th><th>String</th></tr></thead><tbody><tr><td>Cookie Crew 1</td><td>en 0020 71696263</td></tr><tr><td>Cookie Crew 1</td><td>en 0020 71696263</td></tr><tr><td>Feuerwehrman Sam</td><td>en 0002 6161777a</td></tr><tr><td>Was ist Was</td><td>en 0031 67766172</td></tr><tr><td>Hotzenplotz</td><td>en 0006 73657463</td></tr></tbody></table><p>I can move those files to a directory <code>4444</code>, the files will be played, but garbage output. This means the <code>0020</code> is important for the decryption phase.
Renaming <code>0020</code> to something else will result in an “unbaked” Chip.
If i move the files to a directory <code>1020</code>, they will be played just fine, after rebranding the chip to <code>en102071696263</code></p><p>We could try more stuff to understand the encryption, but…let us recap</p><ol><li>the four integers number after <code>en</code> is the directory</li><li>they are partially important for the decryption.</li><li>four bytes in the end, we don’t know the purpose, but they are essential for decryption</li></ol><p>The only crux is, we only can decrypt stuff we have already seen, but i want to have an attack on everything.</p><p>We could brute force the 4 Bytes. Without any further assumption, this would be <code>255**4</code> possibilities, which is way to many.</p><p>But if we look into the last four bytes more closely, we can assume one last thing:
In our examples, the four bytes are hex representation for four small letters from the alphabet.</p><p>With this assumption, we can bring this down to <code>26**4</code>. That sounds more reasonable, but can we attack the crypto further?</p><p>Lucky for us, they published an application which can write a cookie named “Wunderkekz”. This App can encrypt arbitrary MP3 files to the correct <code>kez</code>-Fileformat. And more Lucky for us: it is written in csharp.</p><p>Therefore, we can take a look into the encryption routine (i translated it to python, variable naming directly from the original decompilation):</p><div><pre tabindex="0"><code data-lang="python"><span><span>str_crumb_hex <span>=</span> sys<span>.</span>argv[<span>3</span>] <span># #&#34;E9-F5-33-6B&#34; # Assuming this value based on your previous examples</span>
</span></span><span><span>directory_raw <span>=</span> sys<span>.</span>argv[<span>1</span>]
</span></span><span><span>filename_raw <span>=</span> sys<span>.</span>argv[<span>2</span>]
</span></span><span><span>
</span></span><span><span>directory <span>=</span> bytearray(directory_raw, <span>&#39;ascii&#39;</span>)
</span></span><span><span>filename <span>=</span> bytearray(filename_raw, <span>&#39;ascii&#39;</span>)
</span></span><span><span>array <span>=</span> str_crumb_hex<span>.</span>split(<span>&#39;-&#39;</span>)
</span></span><span><span>b, b2, b3, b4 <span>=</span> [int(value, <span>16</span>) <span>for</span> value <span>in</span> array]
</span></span><span><span>str_crumb_hex_unpacked <span>=</span> bytearray([b, b2, b3, b4])
</span></span><span><span>b5 <span>=</span> (str_crumb_hex_unpacked[<span>0</span>] <span>^</span> directory[<span>0</span>]) <span>&gt;&gt;</span> <span>4</span>
</span></span><span><span>b6 <span>=</span> (str_crumb_hex_unpacked[<span>1</span>] <span>^</span> directory[<span>1</span>]) <span>&gt;&gt;</span> <span>5</span>
</span></span><span><span>b7 <span>=</span> (str_crumb_hex_unpacked[<span>2</span>] <span>^</span> directory[<span>2</span>]) <span>&gt;&gt;</span> <span>3</span>
</span></span><span><span>b8 <span>=</span> (str_crumb_hex_unpacked[<span>3</span>] <span>^</span> directory[<span>3</span>]) <span>&gt;&gt;</span> <span>2</span>
</span></span><span><span>
</span></span><span><span>array3 <span>=</span> bytearray([b5, b6, b7, b8])
</span></span><span><span>
</span></span><span><span>b9 <span>=</span> (filename[<span>0</span>] <span>+</span> filename[<span>1</span>] <span>+</span> filename[<span>2</span>] <span>+</span> filename[<span>3</span>]) <span>%</span> <span>10</span> <span>-</span> <span>1</span>
</span></span><span><span><span>if</span> b9 <span>&gt;=</span> <span>9</span> <span>or</span> b9 <span>&lt;</span> <span>0</span>:
</span></span><span><span>    b9 <span>=</span> <span>6</span>
</span></span><span><span>
</span></span><span><span><span>with</span> open(<span>&#34;</span><span>%s</span><span>/</span><span>%s</span><span>.mp3&#34;</span> <span>%</span> (directory_raw,filename), <span>&#39;rb&#39;</span>) <span>as</span> file_stream:
</span></span><span><span>	array4 <span>=</span> bytearray(file_stream<span>.</span>read())
</span></span><span><span>	array5 <span>=</span> bytearray(len(array4))
</span></span><span><span>	<span>for</span> i <span>in</span> range(len(array4)):
</span></span><span><span>		array4[i] <span>^=</span> array3[i <span>%</span> <span>4</span>]
</span></span><span><span>		array5[i] <span>=</span> ((array4[i] <span>&gt;&gt;</span> (<span>8</span> <span>-</span> b9)) <span>|</span> (array4[i] <span>&lt;&lt;</span> b9)) <span>&amp;</span> <span>0xFF</span>
</span></span><span><span>
</span></span><span><span><span>with</span> open(<span>&#34;</span><span>%s</span><span>/</span><span>%s</span><span>.kez&#34;</span> <span>%</span> (directory_raw,filename),<span>&#39;wb&#39;</span>) <span>as</span> fh:
</span></span><span><span>	fh<span>.</span>write(array5)
</span></span></code></pre></div><ul><li>Opens the MP3 file for reading.</li><li>Reads the entire file into a byte array <code>array4</code>.</li><li>Creates a new byte array <code>array5</code> to hold the encrypted data.</li><li>Iterates through <code>array4</code>, performing the following operations on each byte:<ul><li>XORs the byte with an element of <code>array3</code> (which is some kind of key) (selected in a round-robin fashion).</li><li>Performs a bitwise rotation on the byte, using <code>b9</code> as the shift count, and stores the result in <code>array5</code>.</li></ul></li><li>Closes and disposes of the input file stream.</li></ul><p>As the shift and 4 Byte XOR key depends on the directory name and unknown 4 Byte Hex Key, we can pre calc a brute-force table which significantly limits the keyspace. We can safely assume the unknown 4-Byte Hex Key to be in a printable state.</p><p>This can be seen in the source code of the Kekz App As well (Source: <code>public static bool GenerateKekzCryptFiles</code>)</p><div><pre tabindex="0"><code data-lang="csharp"><span><span><span>string</span> s = RandomGenerator.RandomString(<span>4</span>, lowerCase: <span>true</span>);
</span></span><span><span>strCrumbHex = BitConverter.ToString(Encoding.ASCII.GetBytes(s));
</span></span></code></pre></div><p>The following factors reduce the keyspace significantly:</p><ol><li><strong>shifts reduces the keyspace down to 18 bits</strong>:<ul><li><strong><code>b5</code></strong> has 16 possible values (because it’s reduced to 4 bits after the shift).</li><li><strong><code>b6</code></strong> has 8 possible values (because it’s reduced to 3 bits after the shift).</li><li><strong><code>b7</code></strong> has 32 possible values (because it’s reduced to 5 bits after the shift).</li><li><strong><code>b8</code></strong> has 64 possible values (because it’s reduced to 6 bits after the shift).</li></ul></li><li><strong>XOR with the directory</strong>: Each character in the <code>directory</code> string has a limited value range from 48 (ASCII for ‘0’) to 57 (ASCII for ‘9’), or just 10 different possible values for each character.</li><li><strong>Collision</strong>: After the XOR and bit shifts, many different input values may end up producing the same result. The bit shifts cause significant information loss, and many different values could end up mapping to the same <code>b5, b6, b7, b8</code> combination, leading to a large number of collisions. These collisions reduce the number of unique keys generated.</li></ol><p>By writing all possible keys into a Dictionary, we don’t need to sort and uniq an array afterward.
This results in ~56 possible keys to decrypt the content.</p><div><pre tabindex="0"><code data-lang="python"><span><span>characters <span>=</span> <span>&#34;abcdefghijklmnopqrstuvwxyz&#34;</span>
</span></span><span><span>
</span></span><span><span><span>def</span> <span>keygen</span>(l):
</span></span><span><span>	<span>yield from</span> itertools<span>.</span>product(<span>*</span>([l] <span>*</span> <span>4</span>))
</span></span><span><span>
</span></span><span><span><span>def</span> <span>pre_calc_array3</span>(directory, filename):
</span></span><span><span>	ret <span>=</span> {}
</span></span><span><span>	<span>for</span> x <span>in</span> tqdm(keygen(characters),total<span>=</span>len(characters)<span>**</span><span>4</span>):
</span></span><span><span>		str_crumb_hex <span>=</span> <span>&#39;-&#39;</span><span>.</span>join([hex(ord(i))[<span>2</span>:] <span>for</span> i <span>in</span> x])
</span></span><span><span>		array <span>=</span> str_crumb_hex<span>.</span>split(<span>&#39;-&#39;</span>)
</span></span><span><span>		b, b2, b3, b4 <span>=</span> [int(value, <span>16</span>) <span>for</span> value <span>in</span> array]
</span></span><span><span>		str_crumb_hex_unpacked <span>=</span> bytearray([b, b2, b3, b4])
</span></span><span><span>		b5 <span>=</span> (str_crumb_hex_unpacked[<span>0</span>] <span>^</span> directory[<span>0</span>]) <span>&gt;&gt;</span> <span>4</span>
</span></span><span><span>		b6 <span>=</span> (str_crumb_hex_unpacked[<span>1</span>] <span>^</span> directory[<span>1</span>]) <span>&gt;&gt;</span> <span>5</span>
</span></span><span><span>		b7 <span>=</span> (str_crumb_hex_unpacked[<span>2</span>] <span>^</span> directory[<span>2</span>]) <span>&gt;&gt;</span> <span>3</span>
</span></span><span><span>		b8 <span>=</span> (str_crumb_hex_unpacked[<span>3</span>] <span>^</span> directory[<span>3</span>]) <span>&gt;&gt;</span> <span>2</span>
</span></span><span><span>		array3 <span>=</span> bytearray([b5, b6, b7, b8])
</span></span><span><span>
</span></span><span><span>		ret[<span>f</span><span>&#34;</span><span>{</span>array3[<span>0</span>]<span>}</span><span>,</span><span>{</span>array3[<span>1</span>]<span>}</span><span>,</span><span>{</span>array3[<span>2</span>]<span>}</span><span>,</span><span>{</span>array3[<span>3</span>]<span>}</span><span>&#34;</span>] <span>=</span> array3
</span></span><span><span>	<span>return</span> ret
</span></span></code></pre></div><p>Currently, i take one file, calculate the shift <code>b9</code> and decrypt the file multiple times for every possible key found from the <code>pre_calc_array3</code> method</p><div><pre tabindex="0"><code data-lang="python"><span><span>print(<span>&#34;Starting Brute Force&#34;</span>)
</span></span><span><span><span>for</span> i <span>in</span> tqdm(array3_poss):
</span></span><span><span>	na <span>=</span> i<span>.</span>replace(<span>&#39;,&#39;</span>,<span>&#39;-&#39;</span>)
</span></span><span><span>	array3 <span>=</span> array3_poss[i]
</span></span><span><span><span>#return True</span>
</span></span><span><span>	<span>with</span> open(<span>&#34;</span><span>%s</span><span>/</span><span>%s</span><span>/</span><span>%s</span><span>.kez&#34;</span> <span>%</span> (location,directory<span>.</span>decode(<span>&#39;utf-8&#39;</span>),filename<span>.</span>decode(<span>&#39;utf-8&#39;</span>)),<span>&#39;rb&#39;</span>) <span>as</span> fh:
</span></span><span><span>		array6 <span>=</span> bytearray(fh<span>.</span>read())
</span></span><span><span>		array4_reversed <span>=</span> bytearray(len(array6))
</span></span><span><span>		<span>for</span> i <span>in</span> range(len(array6)):
</span></span><span><span>			<span># Reverse the bitwise rotation</span>
</span></span><span><span>			array4_reversed[i] <span>=</span> ((array6[i] <span>&lt;&lt;</span> (<span>8</span> <span>-</span> b9)) <span>|</span> (array6[i] <span>&gt;&gt;</span> b9)) <span>&amp;</span> <span>0xFF</span>
</span></span><span><span>			<span># Reverse the XOR operation</span>
</span></span><span><span>			array4_reversed[i] <span>^=</span> array3[i <span>%</span> <span>4</span>]
</span></span><span><span>
</span></span><span><span>
</span></span><span><span>	<span>with</span> tempfile<span>.</span>NamedTemporaryFile(<span>&#39;wb&#39;</span>) <span>as</span> fh:
</span></span><span><span>		fh<span>.</span>write(array4_reversed)
</span></span><span><span>
</span></span><span><span>		returned_output <span>=</span> os<span>.</span>popen(<span>&#34;mpck -q </span><span>%s</span><span>&#34;</span> <span>%</span> (fh<span>.</span>name))<span>.</span>read()
</span></span><span><span>		<span>if</span> <span>&#34;: Ok&#34;</span> <span>in</span> returned_output:
</span></span><span><span>			<span>break</span>
</span></span><span><span><span>else</span>:
</span></span><span><span>	<span>return</span> <span>False</span>
</span></span></code></pre></div><p>The Main Problem relies on checking for a valid MP3 files. Because of the shift and the 4 byte xor key you need to check every MP3 Frame, which takes time on larger files.
I currently use an external tool called “<a href="https://github.com/Sjord/checkmate">checkmate</a>”. It has the most robust MP3 validity solution. It basically checks every Frame. (Maybe Fork and implement it in Python? )</p><h2 id="do-you-have-an-app-for-that">Do you have an App for that?</h2><p>I’ve created, for my use and not publication, a small application to read and write the Cookies with my mobile phone. “Kekzmonster” takes in QR Codes, or reads the cookie with NFC and can back up all cookies in my possession. It is not intended to unlock content, which i don’t own.</p><p><img src="https://nv1t.github.io/blog/img/2024/749b63fc6e776f7ce19aad16eca2d7dc.png" alt="Screenshot of my Application Kekzmonster."/></p><p>The Encryption/Decryption String can be written to any cookie with this application as well.</p><p>We can now encrypt, decrypt and brute force the cookie content, but you won’t get ny files onto or from the headset on your own, without opening up the headphones and accessing the SD Card. Connecting the headphones to an USB port only charges them and they are listed within Linux as HID Device:</p><pre tabindex="0"><code>Bus 003 Device 012: ID 33f5:0001 Kekz Gmbh kekz headphone
Device Descriptor:
  bLength                18
  bDescriptorType         1
  bcdUSB               1.10
  bDeviceClass            0
  bDeviceSubClass         0
  bDeviceProtocol         0
  bMaxPacketSize0        64
  idVendor           0x33f5
  idProduct          0x0001
  bcdDevice            1.00
  iManufacturer           1 Kekz Gmbh
  iProduct                2 kekz headphone
  iSerial                 3 2021082200001002
  bNumConfigurations      1
  Configuration Descriptor:
    bLength                 9
    bDescriptorType         2
    wTotalLength       0x0022
    bNumInterfaces          1
    bConfigurationValue     1
    iConfiguration          0
    bmAttributes         0x80
      (Bus Powered)
    MaxPower              100mA
    Interface Descriptor:
      bLength                 9
      bDescriptorType         4
      bInterfaceNumber        0
      bAlternateSetting       0
      bNumEndpoints           1
      bInterfaceClass         3 Human Interface Device
      bInterfaceSubClass      0
      bInterfaceProtocol      0
      iInterface              0
        HID Device Descriptor:
          bLength                 9
          bDescriptorType        33
          bcdHID               2.01
          bCountryCode            0 Not supported
          bNumDescriptors         1
          bDescriptorType        34 Report
          wDescriptorLength      27
         Report Descriptors:
           ** UNAVAILABLE **
      Endpoint Descriptor:
        bLength                 7
        bDescriptorType         5
        bEndpointAddress     0x82  EP 2 IN
        bmAttributes            3
          Transfer Type            Interrupt
          Synch Type               None
          Usage Type               Data
        wMaxPacketSize     0x0008  1x 8 bytes
        bInterval               1
Device Status:     0x0000
  (Bus Powered)
</code></pre><p>We talked about the two vias <code>DP</code> and <code>DM</code>. Interestingly, we are not finding any other connection to the chip, no UART, no JTAG, nothing.
Looking into Jie-li, they are pretty weird chips. The documentation and various sources, state they are programmed over the normal USB Data lines. There are two main methods to control them.</p><h2 id="signaling-dpdm-on-usb">Signaling DP/DM on USB</h2><p>The normal way to put the chip into DFU mode would be sending a custom pullup/pulldown over the <code>D+</code> and <code>D-</code>:
<img src="https://nv1t.github.io/blog/img/2024/ad221d82128b7872b20afc5731412ff7.png" alt=""/>
After this signal, <code>D+</code> and <code>D-</code> gets pulled to Ground for <code>2ms</code> and the device boots up into the DFU Mode with uboot.</p><p>There are special programmer to achieve this, but i’ve seen a post, where somebody build his/her own programmer with an arduino.</p><p>I tried to achieve this with a raspberry pi pico and couldn’t get the Chip into DFU mode. I even tried to use the special programmer for this, but still…no luck.</p><p>In addition, i thought, the windows application does some magic to connect them and read/write content of the headphones. How?! That has to work without any extra hardware and you don’t have such control over the USB data lines from an operating system application.</p><h2 id="hid-communication">HID Communication</h2><p>The other more convenient option for these chips are: they might have special commands over HID which reconnect them in different stages. These are not really documented and can be different for each chip, as it depends on the firmware (i think so, that is what i got in rough translations).</p><h3 id="dfu-mode">DFU Mode</h3><p>Using the Python HID Library, this is effortless. The important thing to know is the <code>dfu_payload</code> which get’s send to the device.</p><div><pre tabindex="0"><code data-lang="python"><span><span>dfu_payload <span>=</span> [<span>0</span>, <span>85</span>, <span>170</span>, <span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>170</span>, <span>85</span>]
</span></span><span><span>
</span></span><span><span>device <span>=</span> hid<span>.</span>device()
</span></span><span><span>
</span></span><span><span>device<span>.</span>open(vendor_id,product_id)
</span></span><span><span>print(<span>f</span><span>&#34;HID: Found Device: </span><span>{</span>device<span>.</span>get_manufacturer_string()<span>}</span><span> </span><span>{</span>device<span>.</span>get_product_string()<span>}</span><span>&#34;</span>)
</span></span><span><span>
</span></span><span><span>data <span>=</span> bytearray(byte_array_left_pad([<span>0</span>, <span>33</span>, <span>9</span>, <span>0</span>, <span>2</span>, <span>1</span>, <span>0</span>, <span>64</span>, <span>0</span>], <span>0</span>, <span>65</span>))
</span></span><span><span>buffer_payload <span>=</span> bytearray(byte_array_left_pad(dfu_payload, <span>0</span>, <span>65</span>))
</span></span><span><span>
</span></span><span><span>device<span>.</span>write(data)
</span></span><span><span>
</span></span><span><span><span>try</span>:
</span></span><span><span>	device<span>.</span>write(buffer_payload)
</span></span><span><span><span>except</span> <span>Exception</span>:
</span></span><span><span>	print(<span>&#34;</span><span>\n</span><span>Communication Error or DFU Success...&#34;</span>)
</span></span></code></pre></div><p>You can now flash new firmware on the chip.</p><h3 id="connecting-to-copy">Connecting to copy</h3><p>The same will go for the connection of the headphones as “normal USB Stick”. The payload is a little bit different:</p><div><pre tabindex="0"><code data-lang="python"><span><span>connect_payload <span>=</span> [<span>0</span>, <span>85</span>, <span>170</span>, <span>3</span>, <span>1</span>, <span>41</span>, <span>40</span>, <span>170</span>, <span>85</span>]
</span></span></code></pre></div><p>After sending this payload, the headphones disconnect and reconnect as a normal USB Stick.
Keep in mind, that if you run or ran the application, the files are with the Windows hidden attribute.</p><p>Success…we can now encrypt custom files, put them into custom directories and write our own cookies.</p><p><strong>We now fully pwn the headphones.</strong></p><p>Browsing through the source code of the application and website, i found other things, which are weren’t mentioned before.</p><h2 id="creating-a-list-of-all-public-cookies">Creating a list of all public cookies</h2><p>There are multiple cookies, which are not public yet, but as we know from above, we can decrypt all of them. Unfortunately, we have no idea, what is in those directories.
But, i found a pretty neat trick to generate a list of all already public cookies:</p><p>The Kekz Webshop is/was built upon a WordPress installation. Fortunately for us, the upload’s directory has directory listing enabled. I can download all images ever shown in this webshop.
<img src="https://nv1t.github.io/blog/img/2024/35e598415e4725d4c97b4ce7a5e14b80.png" alt="Directory Listing of the 2024/11 uploads directory of the Kekz store"/></p><p>These files are pretty important for us, because you see, every cookie has an ID, for “Raeuber Hotzenplotz”, it is 1-1.0066 and interestingly, the directory is “0006”.
<img src="https://nv1t.github.io/blog/img/2024/b45c09c7774d501681d013c89f0dd13c.png" alt="close Up Picture of a cookie with the ID highlighted with a red box"/>
If we look into all the images, we can see product images from the packaging as well. This packaging has a barcode with this ID as well.
<img src="https://nv1t.github.io/blog/img/2024/8f2f2a131f5e45e8890c7a60319f7cb8.png" alt="Partial Image of the back packaging of a cookie."/>
Therefore, we can automate downloading all images and scanning for barcodes and extracting the directory.</p><p><strong>With this information, we can determine about 1/3 of the content is officially released already in the shop.</strong></p><h2 id="moar-wunderkekze">Moar Wunderkekze</h2><p>Apparently the directories 0990 until 0996 are used for the WunderKekzChips, whereas Green, Orange and Purple are already in circulation.</p><p>Maybe the plan is to add more cookies to the mix.</p><div><pre tabindex="0"><code data-lang="csharp"><span><span><span>return</span> wChip <span>switch</span>
</span></span><span><span>{
</span></span><span><span>	WunderkekzChipEnum.Green =&gt; <span>&#34;0996&#34;</span>,
</span></span><span><span>	WunderkekzChipEnum.Orange =&gt; <span>&#34;0995&#34;</span>,
</span></span><span><span>	WunderkekzChipEnum.Purple =&gt; <span>&#34;0994&#34;</span>,
</span></span><span><span>	WunderkekzChipEnum.NineThree =&gt; <span>&#34;0993&#34;</span>,
</span></span><span><span>	WunderkekzChipEnum.NineTwo =&gt; <span>&#34;0992&#34;</span>,
</span></span><span><span>	WunderkekzChipEnum.NineOne =&gt; <span>&#34;0991&#34;</span>,
</span></span><span><span>	WunderkekzChipEnum.NineZero =&gt; <span>&#34;0990&#34;</span>,
</span></span><span><span>	_ =&gt; <span>&#34;0035&#34;</span>,
</span></span><span><span>};
</span></span></code></pre></div><h2 id="user-data-collection">User Data collection</h2><p>This topic is not so nice.</p><p>While looking through the application, i discovered some not so nice stuff, which wasn’t mentioned in the privacy policy anywhere (<a href="https://web.archive.org/web/20240305082206/https://store.kekz.com/datenschutzerklaerung/">Archive</a>). Point 1.10 about the Kekz App was added at a later stage, after my disclosure emails.</p><h3 id="id3-tags">ID3 Tags</h3><p>ID3 tags are metadata containers used to store information about an MP3 audio file, such as the song’s title, artist, album, and other details. They help media players and libraries organize and display information about the audio files. The ID3 tags are stored within the MP3 file itself.
If you are using an Wunderkekz from the Kekz company, and you use the standard windows application (because there is no other), the ID3 tags are uploaded to an Azure Cosmos database.</p><div><pre tabindex="0"><code data-lang="csharp"><span><span>WunderkekzUploadMetadata wunderkekzUploadMetadata = <span>new</span> WunderkekzUploadMetadata();
</span></span><span><span><span>try</span>
</span></span><span><span>{
</span></span><span><span>	FileInfo fileInfo = <span>new</span> FileInfo(path);
</span></span><span><span>	wunderkekzUploadMetadata.FileName = fileInfo.Name;
</span></span><span><span>	wunderkekzUploadMetadata.FileSize = fileInfo.Length;
</span></span><span><span>	wunderkekzUploadMetadata.EventId = Globals.CurrentEventId;
</span></span><span><span>	<span>using</span> TagLib.File file = TagLib.File.Create(path);
</span></span><span><span>	wunderkekzUploadMetadata.Id3Title = file.Tag.Title;
</span></span><span><span>	wunderkekzUploadMetadata.Id3Artist = file.Tag.FirstPerformer;
</span></span><span><span>	wunderkekzUploadMetadata.Id3Album = file.Tag.Album;
</span></span><span><span>	wunderkekzUploadMetadata.Id3Year = (<span>int</span>)file.Tag.Year;
</span></span><span><span>	wunderkekzUploadMetadata.Id3Track = (<span>int</span>)file.Tag.Track;
</span></span><span><span>	wunderkekzUploadMetadata.Id3Genre = file.Tag.FirstGenre;
</span></span><span><span>	wunderkekzUploadMetadata.Id3Comment = file.Tag.Comment;
</span></span><span><span>	<span>return</span> wunderkekzUploadMetadata;
</span></span><span><span>}
</span></span><span><span><span>catch</span> (Exception ex)
</span></span><span><span>{
</span></span><span><span>	Trace.WriteLine(ex.Message);
</span></span><span><span>	<span>return</span> wunderkekzUploadMetadata;
</span></span><span><span>}
</span></span></code></pre></div><h3 id="geolocation">Geolocation</h3><p>Furthermore, the application tries not only uploading the ID3 Tags, but also geolocation data, which is most likely gathered from Wi-Fi triangulation from windows itself.</p><p>The MainView calls a GeoLocation Service:</p><div><pre tabindex="0"><code data-lang="java"><span><span><span>public</span> async Task<span>&lt;</span>string<span>&gt;</span> <span>GetCurrentLocation</span>()
</span></span><span><span>{
</span></span><span><span>	string strLocation <span>=</span> <span>null</span>;
</span></span><span><span>	<span>try</span>
</span></span><span><span>	{
</span></span><span><span>		Location lastLocation <span>=</span> await Geolocation.<span>Default</span>.<span>GetLastKnownLocationAsync</span>();
</span></span><span><span>		Location location <span>=</span> (await Geolocation.<span>Default</span>.<span>GetLocationAsync</span>()) <span>??</span> lastLocation;
</span></span><span><span>		<span>if</span> (location <span>!=</span> <span>null</span>)
</span></span><span><span>		{
</span></span><span><span>			DefaultInterpolatedStringHandler defaultInterpolatedStringHandler <span>=</span> <span>new</span> DefaultInterpolatedStringHandler(1, 2);
</span></span><span><span>			defaultInterpolatedStringHandler.<span>AppendFormatted</span>(location.<span>Latitude</span>);
</span></span><span><span>			defaultInterpolatedStringHandler.<span>AppendLiteral</span>(<span>&#34;:&#34;</span>);
</span></span><span><span>			defaultInterpolatedStringHandler.<span>AppendFormatted</span>(location.<span>Longitude</span>);
</span></span><span><span>			strLocation <span>=</span> (Globals.<span>GeoData</span> <span>=</span> defaultInterpolatedStringHandler.<span>ToStringAndClear</span>());
</span></span><span><span>		}
</span></span><span><span>		<span>return</span> strLocation;
</span></span><span><span>	}
</span></span><span><span>	<span>catch</span> (Exception ex)
</span></span><span><span>	{
</span></span><span><span>		Console.<span>WriteLine</span>(ex.<span>Message</span>);
</span></span><span><span>		<span>return</span> strLocation;
</span></span><span><span>	}
</span></span><span><span>}
</span></span></code></pre></div><p>This is also save within the Cosmos DB as seen in already present locations:</p><div><pre tabindex="0"><code data-lang="json"><span><span>{
</span></span><span><span>  <span>&#34;id&#34;</span>: <span>&#34;29c01f2e-f4cd-4671-9257-a7432b15fc0d&#34;</span>,
</span></span><span><span>  <span>&#34;EventTypeId&#34;</span>: <span>&#34;1&#34;</span>,
</span></span><span><span>  <span>&#34;DeviceGuid&#34;</span>: <span>&#34;3cf4caf5-3f6e-4199-bbf0-ba1abe69a6e9&#34;</span>,
</span></span><span><span>  <span>&#34;WunderkekzId&#34;</span>: <span>&#34;994&#34;</span>,
</span></span><span><span>  <span>&#34;GeoLocation&#34;</span>: <span>&#34;48,xxxxxxxxxxxxxx:11,xxxxxxxxxxxxxx&#34;</span>,
</span></span><span><span>  <span>&#34;UploadedAt&#34;</span>: <span>&#34;2023-10-24T21:03:28.4478194+02:00&#34;</span>,
</span></span><span><span>  <span>&#34;_rid&#34;</span>: <span>&#34;E9MJAL2dw5WRAAAAAAAAAA==&#34;</span>,
</span></span><span><span>  <span>&#34;_self&#34;</span>: <span>&#34;dbs/E9MJAA==/colls/E9MJAL2dw5U=/docs/E9MJAL2dw5WRAAAAAAAAAA==/&#34;</span>,
</span></span><span><span>  <span>&#34;_etag&#34;</span>: <span>&#34;\&#34;3e009e56-0000-0d00-0000-653815010000\&#34;&#34;</span>,
</span></span><span><span>  <span>&#34;_attachments&#34;</span>: <span>&#34;attachments/&#34;</span>,
</span></span><span><span>  <span>&#34;_ts&#34;</span>: <span>1698174209</span>
</span></span><span><span>}
</span></span><span><span>{
</span></span><span><span>  <span>&#34;id&#34;</span>: <span>&#34;e3e1482f-1b62-4780-aff1-70593aa79d56&#34;</span>,
</span></span><span><span>  <span>&#34;EventTypeId&#34;</span>: <span>&#34;1&#34;</span>,
</span></span><span><span>  <span>&#34;DeviceGuid&#34;</span>: <span>&#34;a7bc4474-570d-4ece-b1f5-aa3e9a36c1ce&#34;</span>,
</span></span><span><span>  <span>&#34;WunderkekzId&#34;</span>: <span>&#34;995&#34;</span>,
</span></span><span><span>  <span>&#34;GeoLocation&#34;</span>: <span>&#34;48,xxxxxxxxxxxxxx:11,xxxxxxxxxxxxxx&#34;</span>,
</span></span><span><span>  <span>&#34;UploadedAt&#34;</span>: <span>&#34;2023-10-24T21:17:59.1191164+02:00&#34;</span>,
</span></span><span><span>  <span>&#34;_rid&#34;</span>: <span>&#34;E9MJAL2dw5WSAAAAAAAAAA==&#34;</span>,
</span></span><span><span>  <span>&#34;_self&#34;</span>: <span>&#34;dbs/E9MJAA==/colls/E9MJAL2dw5U=/docs/E9MJAL2dw5WSAAAAAAAAAA==/&#34;</span>,
</span></span><span><span>  <span>&#34;_etag&#34;</span>: <span>&#34;\&#34;3e009f58-0000-0d00-0000-653818690000\&#34;&#34;</span>,
</span></span><span><span>  <span>&#34;_attachments&#34;</span>: <span>&#34;attachments/&#34;</span>,
</span></span><span><span>  <span>&#34;_ts&#34;</span>: <span>1698175081</span>
</span></span><span><span>}
</span></span></code></pre></div><p>Because the Geolocation data is only cross-referenced with die Device GUID and not the content itself, the enforcement for regional content does not make sense in their newest copy of the privacy policy.</p><h3 id="pii-data">PII Data</h3><p>There is some PII Data involved, but i think those are just test data from some ordering processes. Even the headphones can only be cross-linked to the geolocation data and not the content played.
It could maybe be cross-referenced with the time, but haven’t checked into that, as the main concern is the data being public.</p><h3 id="who-is-special">Who is Special?</h3><p>In addition, the connection string to this Azure cosmos database is accessible within the Decompilation of the application itself and therefore is disclosed.</p><p>So everybody looking into the source code of the application can get information on usage of the headphones, location of some of the headphones and files listened too.</p><p><img src="https://nv1t.github.io/blog/img/2024/ddb71ee1385f009813e51273e8dd6d1d.png" alt="Heatmap of all Geolocation Data in Germany from the headphones usage"/>
There is some usage in Dublin as well, but only wanted to include the DACH Region.</p><p>Normalizing ID3 Tag Meta Data from various sources is really cumbersome. I tried, but i gave up pretty quickly, because it was just my own curiosity what kids are listening to these days. Let me say that: Bibi Blocksberg, Bibi &amp; Tina, Benjaming Bluemchen, Paw Patrol, Drei Fragezeichen, and various songs, are the all time favourits. (for the english speaking community: except Paw Patrol, are all Children Listening experiences from germany, which exist since 1970 or 1980)</p><p><strong>19.10.2023</strong>: i reached out to the CTO of Kekz, who told me, he developed the headphones, but is no longer associated with the company. To my knowledge, he forwarded the information to the CEOs.
Never heard back.</p><p><strong>27.02.2024</strong>: i reached out to the CEOs of Kekz (Adin and Carl) with my security concerns. Never heard back.
-&gt; A few weeks later, the privacy policy was changed to include the Kekz-App, therefore i conclude my email was read</p><ul><li>What is the full functionality of the Jieli-Chip? These chips are strange and challenging to identify. I only guessed which Chip it could be and got lucky with the HID Interface through the Windows Application</li><li>What does the other Jieli-Chip on the other PCB Do?</li><li>A full application to create a custom SD Card with a content manager to not only support the content already present on the Kekz Headphones, but furthermore all non-taken directories.</li><li>Are there more HID commands?</li><li>How good is the Geolocation Data sourced from a Laptop, which is probably triangulated Wifi Signals? Do the 30m-500m from the privacy policy hold up, or can it be narrowed down?</li><li>What is this PII Data in the Azure cosmos database?</li></ul><p>There are most likely more open questions on this one. You are welcome to research further on your own.</p><ul><li><strong>Kekz Information:</strong><ul><li><a href="https://futurezone.at/produkte/kekz-kopfhoerer-im-test-kinder-in-ihrer-eigenen-welt/401978339">https://futurezone.at/produkte/kekz-kopfhoerer-im-test-kinder-in-ihrer-eigenen-welt/401978339</a> (first article i have read about the Headphones)</li><li><a href="https://stadt-bremerhaven.de/kekz-drahtlose-kinderkopfhoerer-nach-dem-tonies-prinzip/">https://stadt-bremerhaven.de/kekz-drahtlose-kinderkopfhoerer-nach-dem-tonies-prinzip/</a> (Kekz article of Caschys blog, with wrong information in the comments on how they operate)</li><li><a href="https://store.kekz.com/haendlersuche/">https://store.kekz.com/haendlersuche/</a> (Kekz - Store search)</li><li><a href="https://apps.microsoft.com/detail/9NXL6Q53G5RX?hl=de-de&amp;gl=DE">https://apps.microsoft.com/detail/9NXL6Q53G5RX?hl=de-de&amp;gl=DE</a> (Kekz application)</li></ul></li><li><strong>Checking MP3s for validity:</strong><ul><li><a href="https://github.com/Sjord/checkmate">https://github.com/Sjord/checkmate</a> (checks every frame, but not python variant exists)</li><li><a href="https://peterextexia.com/blog/verifying-that-an-mp3-file-is-valid-in-python/">https://peterextexia.com/blog/verifying-that-an-mp3-file-is-valid-in-python/</a> (it kinda works, but get’s false positives and because some mp3 decode as valid, this does not work)</li></ul></li><li><strong>Jieli-Chip:</strong><ul><li><a href="https://www.zh-jieli.com/">https://www.zh-jieli.com/</a> (chip production)</li><li><a href="http://www.yunthinker.com/FileUpLoad/DownLoadInfosFile/637729990813300469.pdf">http://www.yunthinker.com/FileUpLoad/DownLoadInfosFile/637729990813300469.pdf</a> (potential Chip)</li><li><a href="https://github.com/christian-kramer/JieLi-AC690X-Familiarization">https://github.com/christian-kramer/JieLi-AC690X-Familiarization</a> (Adventures in figuring out how this incredibly ubiquitous, yet incredibly mysterious integrated circuit works.)</li><li><a href="https://github.com/kagaimiq/jl-uboot-tool/tree/main">https://github.com/kagaimiq/jl-uboot-tool/tree/main</a> (chip and protopcol description)</li><li><a href="https://github.com/kagaimiq/jielie/tree/main">https://github.com/kagaimiq/jielie/tree/main</a> (jielie nice!)</li><li><a href="https://el.jibun.atmarkit.co.jp/thousandiy/2022/09/18_bluetooth_audio_soc.html">https://el.jibun.atmarkit.co.jp/thousandiy/2022/09/18_bluetooth_audio_soc.html</a> (Which Chips are built into cheap Bluetooth Speaker)</li></ul></li><li><strong>Misc:</strong><ul><li><a href="https://www.luther-lawfirm.com/newsroom/blog/detail/reverse-engineering-nach-dem-geschaeftsgeheimnisgesetz-geschgehg-vertragliche-ausschlussmoeglichkeiten#:~:text=a%20GeschGehG%20ist%20das%20Reverse,Gegenst%C3%A4nden%20uneingeschr%C3%A4nkt%20erlaubt">https://www.luther-lawfirm.com/newsroom/blog/detail/reverse-engineering-nach-dem-geschaeftsgeheimnisgesetz-geschgehg-vertragliche-ausschlussmoeglichkeiten#:~:text=a%20GeschGehG%20ist%20das%20Reverse,Gegenst%C3%A4nden%20uneingeschr%C3%A4nkt%20erlaubt</a>. (Reverse Engineering Rechtliche Lage)</li></ul></li></ul></div></div></div>
  </body>
</html>
