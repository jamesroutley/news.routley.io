<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jank-lang.org/blog/2024-10-14-llvm-ir/">Original</a>
    <h1>Jank development update â€“ Moving to LLVM IR</h1>
    
    <div id="readability-page-1" class="page"><div><p>Hi everyone! It&#39;s been a few months since the last update and I&#39;m excited to outline what&#39;s been going on and what&#39;s upcoming for jank, the native Clojure dialect. Many thanks to Clojurists Together and my Github sponsors for the support. Let&#39;s get into it!</p><h2>Heart of Clojure</h2><p>In September, I flew from Seattle to Belgium to speak at Heart of Clojure. For the talk, I wanted to dig deep into the jank details, so I created a walk-through of implementing exception handling in jank. You can watch my talk <a href="https://www.youtube.com/watch?v=5ejOkeNCbXY">here</a>, or in the embed below.</p><p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="" frameborder="0" height="315" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube-nocookie.com/embed/5ejOkeNCbXY?si=j4BolMy6nj6_mVBY" title="YouTube video player" width="560"></iframe></p><h3>Announcement</h3><p>Part of my Heart of Clojure talk was an announcement that, starting in January 2025, <strong>I&#39;ll be quitting my job at EA to focus on jank full-time</strong>. Two years ago, I switched from full-time to part-time at EA in order to have more time for jank. Now, with the momentum we have, the interest I&#39;ve gathered, and the motivation backing this huge effort, I&#39;m taking things all the way.</p><p>I don&#39;t have funding figured out yet, though. It&#39;s hard for companies to invest in jank now when they&#39;re not using it, when it&#39;s not providing them value. So my goal is to get jank out there and start creating value in the native Clojure space. If using jank interests you and you want white glove support for onboarding jank once it&#39;s released, reach out to me.</p><h2>Mentoring</h2><p>On top of working on jank full-time, next year, I have joined the <a href="https://scicloj.github.io/docs/community/groups/open-source-mentoring/">SciCloj mentorship program</a> as a mentor and have two official mentees with whom I meet weekly (or at least once every two weeks) in order to help them learn to be compiler hackers by working on jank. This is in tandem with the other mentee I had prior to the SciCloj program.</p><p>What&#39;s so inspiring is that there were half a dozen interested people, who either reached out to me directly or went through the application process, and we had to pare down the list to just two for the sake of time. Each of those folks wants to push jank forward and learn something along the way.</p><h2>JIT compilation speeds</h2><p>Now, jumping into the development work which has happened in the past few months, it all starts with me looking into optimizing jank&#39;s startup time. You might think this is a small issue, given that jank needs more development tooling, improved error messages, better Clojure library support, etc. However, this is the crux of the problem.</p><p>jank is generating C++ from its AST right now. This has some great benefits, particularly since jank&#39;s runtime is implemented in C++. It allows us to take advantage of C++&#39;s type inference, overloading, templates, and virtual dispatch, whereas we&#39;d have none of those things if we were generating LLVM IR, machine code, or even C.</p><p>However, JIT compiling C++ as our primary codegen comes with on big problem: C++ is one of the slowest to compile languages there is. As a concrete example, in jank, <code>clojure.core</code> is about 4k (formatted) lines of jank code. This codegens to around 80k (formatted) lines of C++ code. On my beefy desktop machine, it takes 12 seconds to JIT compile all of that C++. This means that starting jank, with no other dependencies than <code>clojure.core</code>, takes 12 seconds.</p><p>To be fair, all of this disappears in AOT builds, where startup time is more like 50ms. But starting a REPL is something we do every day. If it takes 12 seconds now, how long will it take when you start a REPL for your company&#39;s large jank project? What if your machine is not as beefy? A brave user who recently compiled jank for WSL reported that it took a minute to JIT compile <code>clojure.core</code> for them.</p><p>So, this leads us to look for solutions. jank is already using a pre-compiled header to speed up JIT compilation. Before abandoning C++ codegen, I wanted to explore how we could pre-compile modules like <code>clojure.core</code>, too. Very pleasantly, the startup time improvements were great. jank went from 12 seconds to 0.3 seconds to start up, when <code>clojure.core</code> is pre-compiled as a C++20 module and then loaded in as a shared library.</p><figure></figure><p>There&#39;s a catch, though. It takes 2 full minutes to AOT compile <code>clojure.core</code> to a C++20 pre-compiled module. So, we&#39;re back to the same problem. jank could compile all of your dependencies to pre-compiled modules, but it may take 30 minutes to do so, even on a reasonable machine. For non-dependency code, your own source code, jank could use a compilation cache, but you&#39;ll still need to pay the JIT compilation cost whenever you do a clean build, whenever you eval a whole file from the REPL, etc.</p><p>Before digging deeper into this, I wanted to explore what things would look like in a world where we don&#39;t codegen C++.</p><h2>LLVM IR</h2><p>LLVM has support for JIT compiling its own intermediate representation (IR), which is basically a high level assembly language. Compared to generating C++, though, we run into some problems here:</p><ol><li>Calling into C++ is tough, since C++ uses name mangling and working C++ value types involves non-trivial IR</li><li>We can&#39;t do things like instantiate C++ templates, since those don&#39;t exist in IR land</li></ol><p>So we need to work with jank at a lower level. As I was designing this, in my brain, I realized that we just need a C API. jank has a C++ API, which is what we&#39;re currently using, but if we had a C API then we could just call into that from assembly. Heck, if we can just write out the C we want, translating that to assembly (or IR) is generally pretty easy. That&#39;s what I did. I took an example bit of Clojure code and I wrote out some equivalent C-ish code, using a made-up API:</p><h3>Clojure</h3><pre tabindex="0"><code><span><span>(</span><span>defn</span><span> say-hi [who]</span></span>
<span><span>  (</span><span>println</span><span> &#34;hi &#34;</span><span> who </span><span>&#34;!&#34;</span><span>))</span></span></code></pre><h3>C</h3><pre tabindex="0"><code><span><span>static</span><span> jank_object_ptr const_1 </span><span>=</span><span> jank_create_string</span><span>(</span><span>&#34;hi &#34;</span><span>);</span></span>
<span><span>static</span><span> jank_object_ptr const_2 </span><span>=</span><span> jank_create_string</span><span>(</span><span>&#34;!&#34;</span><span>);</span></span>
<span></span>
<span><span>jank_object_ptr </span><span>say_hi</span><span>(jank_object_ptr </span><span>who</span><span>)</span></span>
<span><span>{</span></span>
<span><span>  jank_object_ptr println_var </span><span>=</span><span> jank_var_intern</span><span>(</span><span>&#34;clojure.core&#34;</span><span>, </span><span>&#34;println&#34;</span><span>);</span></span>
<span><span>  jank_object_ptr println </span><span>=</span><span> jank_deref</span><span>(println_var);</span></span>
<span><span>  return</span><span> jank_call3</span><span>(println, const_1, who, const_2);</span></span>
<span><span>}</span></span>
<span></span>
<span><span>static</span><span> jank_object_ptr </span><span>fn_1</span><span>()</span></span>
<span><span>{</span></span>
<span><span>  jank_object_ptr say_hi_var </span><span>=</span><span> jank_var_intern</span><span>(</span><span>&#34;clojure.core&#34;</span><span>, </span><span>&#34;say-hi&#34;</span><span>);</span></span>
<span><span>  jank_object_ptr say_hi_obj </span><span>=</span><span> jank_create_function1</span><span>(</span><span>&amp;</span><span>say_hi);</span></span>
<span><span>  jank_var_bind_root</span><span>(say_hi_var, say_hi_obj);</span></span>
<span><span>  return</span><span> say_hi_var;</span></span>
<span><span>}</span></span></code></pre><p>This was motivating. Furthermore, <strong>after two weekends, I have the LLVM IR codegen almost entirely done!</strong> The only thing missing is codegen for closures (functions with captures) and <code>try</code> expressions, since those involve some extra work. I&#39;ll give an example of how this looks, with exactly the IR we&#39;re generating, before LLVM runs any optimization passes.</p><h3>Clojure</h3><pre tabindex="0"><code><span><span>(</span><span>let</span><span> [a </span><span>1</span></span>
<span><span>      b </span><span>&#34;meow&#34;</span><span>]</span></span>
<span><span>  (</span><span>println</span><span> b a))</span></span></code></pre><h3>LLVM IR</h3><pre tabindex="0"><code><span><span>; ModuleID = &#39;clojure.core-24&#39;</span></span>
<span><span>source_filename = </span><span>&#34;clojure.core-24&#34;</span></span>
<span></span>
<span><span>; Each C function we reference gets declared.</span></span>
<span><span>declare</span><span> ptr</span><span> @jank_create_integer</span><span>(</span><span>ptr</span><span>)</span></span>
<span><span>declare</span><span> ptr</span><span> @jank_create_string</span><span>(</span><span>ptr</span><span>)</span></span>
<span><span>declare</span><span> ptr</span><span> @jank_var_intern</span><span>(</span><span>ptr</span><span>, </span><span>ptr</span><span>)</span></span>
<span><span>declare</span><span> ptr</span><span> @jank_deref</span><span>(</span><span>ptr</span><span>)</span></span>
<span><span>declare</span><span> ptr</span><span> @jank_call2</span><span>(</span><span>ptr</span><span>, </span><span>ptr</span><span>, </span><span>ptr</span><span>)</span></span>
<span></span>
<span><span>; All constants and vars are lifted into internal</span></span>
<span><span>; globals and initialized once using a global ctor.</span></span>
<span><span>@int_1</span><span> = </span><span>internal</span><span> global</span><span> ptr</span><span> 0</span></span>
<span><span>@string_2025564121</span><span> = </span><span>internal</span><span> global</span><span> ptr</span><span> 0</span></span>
<span><span>@</span><span>0</span><span> = </span><span>private</span><span> unnamed_addr</span><span> constant</span><span> [</span><span>5</span><span> x </span><span>i8</span><span>] </span><span>c</span><span>&#34;meow</span><span>\00</span><span>&#34;</span><span>, </span><span>align</span><span> 1</span></span>
<span><span>@var_clojure.core_SLASH_println</span><span> = </span><span>internal</span><span> global</span><span> ptr</span><span> 0</span></span>
<span><span>@string_4144411177</span><span> = </span><span>internal</span><span> global</span><span> ptr</span><span> 0</span></span>
<span><span>@</span><span>1</span><span> = </span><span>private</span><span> unnamed_addr</span><span> constant</span><span> [</span><span>13</span><span> x </span><span>i8</span><span>] </span><span>c</span><span>&#34;clojure.core</span><span>\00</span><span>&#34;</span><span>, </span><span>align</span><span> 1</span></span>
<span><span>@string_4052785392</span><span> = </span><span>internal</span><span> global</span><span> ptr</span><span> 0</span></span>
<span><span>@</span><span>2</span><span> = </span><span>private</span><span> unnamed_addr</span><span> constant</span><span> [</span><span>8</span><span> x </span><span>i8</span><span>] </span><span>c</span><span>&#34;println</span><span>\00</span><span>&#34;</span><span>, </span><span>align</span><span> 1</span></span>
<span></span>
<span><span>; Our global ctor function. It boxes all our</span></span>
<span><span>; ints and strings while interning our vars.</span></span>
<span><span>define</span><span> void</span><span> @jank_global_init_23</span><span>() {</span></span>
<span><span>entry:</span></span>
<span><span>  %0</span><span> = </span><span>call</span><span> ptr</span><span> @jank_create_integer</span><span>(</span><span>i64</span><span> 1</span><span>)</span></span>
<span><span>  store</span><span> ptr</span><span> %0</span><span>, </span><span>ptr</span><span> @int_1</span><span>, </span><span>align</span><span> 8</span></span>
<span><span>  %1</span><span> = </span><span>call</span><span> ptr</span><span> @jank_create_string</span><span>(</span><span>ptr</span><span> @</span><span>0</span><span>)</span></span>
<span><span>  store</span><span> ptr</span><span> %1</span><span>, </span><span>ptr</span><span> @string_2025564121</span><span>, </span><span>align</span><span> 8</span></span>
<span><span>  %2</span><span> = </span><span>call</span><span> ptr</span><span> @jank_create_string</span><span>(</span><span>ptr</span><span> @</span><span>1</span><span>)</span></span>
<span><span>  store</span><span> ptr</span><span> %2</span><span>, </span><span>ptr</span><span> @string_4144411177</span><span>, </span><span>align</span><span> 8</span></span>
<span><span>  %3</span><span> = </span><span>call</span><span> ptr</span><span> @jank_create_string</span><span>(</span><span>ptr</span><span> @</span><span>2</span><span>)</span></span>
<span><span>  store</span><span> ptr</span><span> %3</span><span>, </span><span>ptr</span><span> @string_4052785392</span><span>, </span><span>align</span><span> 8</span></span>
<span><span>  %4</span><span> = </span><span>call</span><span> ptr</span><span> @jank_var_intern</span><span>(</span><span>ptr</span><span> %2</span><span>, </span><span>ptr</span><span> %3</span><span>)</span></span>
<span><span>  store</span><span> ptr</span><span> %4</span><span>, </span><span>ptr</span><span> @var_clojure.core_SLASH_println</span><span>, </span><span>align</span><span> 8</span></span>
<span><span>  ret</span><span> void</span></span>
<span><span>}</span></span>
<span></span>
<span><span>; Our effecting fn which does the work of the actual code.</span></span>
<span><span>; Here, that just means derefing the println var and calling it.</span></span>
<span><span>define</span><span> ptr</span><span> @repl_fn_22</span><span>() {</span></span>
<span><span>entry:</span></span>
<span><span>  %0</span><span> = </span><span>load</span><span> ptr</span><span>, </span><span>ptr</span><span> @int_1</span><span>, </span><span>align</span><span> 8</span></span>
<span><span>  %1</span><span> = </span><span>load</span><span> ptr</span><span>, </span><span>ptr</span><span> @string_2025564121</span><span>, </span><span>align</span><span> 8</span></span>
<span><span>  %2</span><span> = </span><span>load</span><span> ptr</span><span>, </span><span>ptr</span><span> @var_clojure.core_SLASH_println</span><span>, </span><span>align</span><span> 8</span></span>
<span><span>  %3</span><span> = </span><span>call</span><span> ptr</span><span> @jank_deref</span><span>(</span><span>ptr</span><span> %2</span><span>)</span></span>
<span><span>  %4</span><span> = </span><span>call</span><span> ptr</span><span> @jank_call2</span><span>(</span><span>ptr</span><span> %3</span><span>, </span><span>ptr</span><span> %1</span><span>, </span><span>ptr</span><span> %0</span><span>)</span></span>
<span><span>  ret</span><span> ptr</span><span> %4</span></span>
<span><span>}</span></span></code></pre><p>There&#39;s still more to do before I can get some real numbers for how long it takes to JIT compile LLVM IR, compared to C++. However, I&#39;m very optimistic. By using a C API, instead of our C++ API, handling codegen optimizations like unboxing ends up being even more complex, but we also have even more power.</p><h2>How this affects interop</h2><p>Currently, jank has two forms of native interop (one in each direction):</p><ol><li>A special <code>native/raw</code> form which allows embedding C++ within your jank code</li><li>The ability to require a C++ as though it&#39;s a Clojure namespace, where that C++ code then uses jank&#39;s runtime to register types/functions</li></ol><p>When we&#39;re generating C++, a <code>native/raw</code> just gets code-generated right into place. However, when we&#39;re generating IR, we can&#39;t sanely do that without involving a C++ compiler. This means that <code>native/raw</code> will need to go away, to move forward with IR. However, I think this may be a good move. If we buy into the second form of interop more strongly, we can rely on actual native source files to reach into the jank runtime and register their types/functions. Then, in the actual jank code, everything feels like Clojure.</p><p>This means that we still have a need for JIT compiling C++. Whenever you <code>require</code> a module from your jank code, which is backed by a C++ file, that code is JIT compiled. Generally, what the C++ code will do is register the necessary functions into the jank runtime so that way you can then drive the rest of your program with jank code. I think this is a happy medium, where we still have the full power of C++ at our disposal, but all of our jank code will result in IR, which will JIT compile much more quickly than C++.</p><p>This means the answer to the question of C++ or IR is: <strong>why not both?</strong></p><h2>jank as THE native Clojure dialect</h2><p>There&#39;s another reason which leads me to explore LLVM IR within jank. While jank is embracing modern C++, it doesn&#39;t need to be so tightly coupled to it. By using just the C ABI as our runtime library, everything can talk to jank. You could talk to jank from Ruby, Lua, Rust, and even Clojure JVM. Just as importantly, jank can JIT compile any LLVM IR, which means any language which compiles on the LLVM stack can then be JIT compiled into your jank program.</p><p>Just as jank can load C++ files as required namespaces, seamlessly, so too could it do the same for Rust, in the future. Furthermore, as the public interface for jank becomes C, the internal representation and implementation can change opaquely, which would also open the door for more Rust within the jank compiler.</p><p>In short, <em>any native work you want to do in Clojure</em> should be suited for jank. Your jank code can remain Clojure, but you can package C, C++, and later languages like Rust inside your jank projects and require then from your jank code. The jank compiler and runtime will handle JIT compilation and AOT compilation for you.</p><h2>Community update</h2><p>This has been a long update which hopefully created some more excitement for jank&#39;s direction. I want to wrap up with what the community has been up to recently, though, since that alone warrants celebration.</p><h3>Characters, scientific notation, and <code>to_code_string</code></h3><p><a href="https://github.com/Samy-33">Saket</a> has been improving jank&#39;s runtime character objects, which he originally implemented, to be more efficient and support Unicode. He also recently added scientific notation for floating point values, as well as an extension of jank&#39;s object concept to support <code>to_code_string</code>, which allows us to now implement <code>pr-str</code>.</p><p>At this point, Saket has the most knowledge of jank&#39;s internals, aside from me, so I&#39;ve been giving him heftier tasks and he&#39;s been super helpful.</p><h3>More robust escape sequences</h3><p>One of my SciCloj mentees, <a href="https://github.com/jianlingzhong">Jianling</a>, recently merged support for all of the ASCII escape sequences for jank&#39;s strings. Previously, we only had rudimentary support. Now he&#39;s working on support for hexadecimal, octal, and arbitrary radix literals, to further jank&#39;s syntax parity with Clojure.</p><h3>Nix build</h3><p>We have a newcomer to jank, <a href="https://github.com/haruki7049">Haruki</a>, helping to rework the build system and dependencies to allow for easy building with Nix! There&#39;s a draft PR <a href="https://github.com/jank-lang/jank/pull/94">here</a>. I&#39;m excited for this, since I&#39;m currently using NixOS and I need to do a lot of jank dev in a distrobox for easy building. This will also help with stable CI builds and ultimately getting jank into nixpkgs (the central package repo for Nix).</p><h3>LLVM 19 support</h3><p>The last JIT hard crash fix in LLVM is being backported to the 19.x branch, which means we should be able to start using Clang/LLVM binaries starting 19.2! This is going to drastically simplify the developer experience and allow for packaging jank using the system Clang/LLVM install. My <a href="https://github.com/llvm/llvm-project/issues/111068">backport ticket</a> has been closed as complete, though <a href="https://github.com/llvm/llvm-project/pull/111953">the PR</a> into the 19.x branch is still open.</p><h2>Summary</h2><p>More people are working on jank now than ever have; I expect this number to keep growing in the coming year. I&#39;ll see you folks at the Conj and, after that, in my next update during the holiday season, when I&#39;ll have some final numbers comparing jank&#39;s startup times with LLVM IR vs C++, as well as some updates on other things I&#39;ve been tackling.</p><h2>Would you like to join in?</h2><ol><li>Join the community on <a href="https://clojurians.slack.com/archives/C03SRH97FDK">Slack</a></li><li>Join the design discussions or pick up a ticket on <a href="https://github.com/jank-lang/jank">GitHub</a></li><li>Considering becoming a <a href="https://github.com/sponsors/jeaye">Sponsor</a> <span><i></i></span></li><li><strong>Hire me full-time to work on jank!</strong></li></ol></div></div>
  </body>
</html>
