<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/sockmaster27/svader">Original</a>
    <h1>Show HN: Svader â€“ Create GPU-rendered Svelte components</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text"><p dir="auto">
  <themed-picture data-catalyst-inline="true"><picture>
    <source media="(prefers-color-scheme: dark)" srcset="https://raw.githubusercontent.com/sockmaster27/svader/master/resources/logoDark.png"/>
    <img width="150" alt="Svader Logo" src="https://raw.githubusercontent.com/sockmaster27/svader/master/resources/logoLight.png"/>
  </picture></themed-picture>
</p>

<p dir="auto">Create GPU-rendered Svelte components with WebGL and WebGPU fragment shaders.</p>
<p dir="auto">Supports Svelte 4 and Svelte 5.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">What is a fragment shader?</h2><a id="user-content-what-is-a-fragment-shader" aria-label="Permalink: What is a fragment shader?" href="#what-is-a-fragment-shader"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">In short, a <em>fragment shader</em> can be written as a program that takes the coordinates of a pixel on the screen and returns the color that this pixel should have.
This program can be executed on the GPU, ensuring massive parallelism and speed.</p>
<p dir="auto">To learn more about how to write fragment shaders, check out <a href="https://thebookofshaders.com/" rel="nofollow">The Book of Shaders</a>.</p>
<p dir="auto">The following is a collection of examples all made using Svader. The live version of all of these can be previewed on <a href="https://svader.vercel.app/" rel="nofollow">svader.vercel.app</a>,
and the source code can be found in the <a href="https://github.com/sockmaster27/svader/tree/master/src/routes"><code>src/routes/</code></a> directory.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/sockmaster27/svader/master/resources/collage.png"><img src="https://raw.githubusercontent.com/sockmaster27/svader/master/resources/collage.png" alt="Shader example collage"/></a></p>

<div dir="auto" data-snippet-clipboard-copy-content="# npm
npm i -D svader

# pnpm
pnpm i -D svader

# Bun
bun i -D svader

# Yarn
yarn add -D svader"><pre><span><span>#</span> npm</span>
npm i -D svader

<span><span>#</span> pnpm</span>
pnpm i -D svader

<span><span>#</span> Bun</span>
bun i -D svader

<span><span>#</span> Yarn</span>
yarn add -D svader</pre></div>

<p dir="auto">To use a fragment shader component, you first need to decide whether to use WebGL or WebGPU.
If you&#39;re unsure about what to use, see the <a href="#webgl-vs-webgpu">WebGL vs. WebGPU</a> section.</p>

<ul dir="auto">
<li><a href="#webgl">WebGL</a>
<ul dir="auto">
<li><a href="#webgl-parameters">WebGL parameters</a>
<ul dir="auto">
<li><a href="#webgl-built-in-values">WebGL built-in values</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#webgpu">WebGPU</a>
<ul dir="auto">
<li><a href="#webgpu-parameters">WebGPU parameters</a>
<ul dir="auto">
<li><a href="#webgpu-built-in-values">WebGPU built-in values</a></li>
</ul>
</li>
</ul>
</li>
</ul>

<p dir="auto">The following is a minimal example of a WebGL fragment shader component.</p>
<p dir="auto"><a href="https://svelte.dev/repl/3e4a38bca5ca49fa94e1106a841063d5?version=5.1.10" rel="nofollow"><strong>View in REPL</strong></a></p>
<div dir="auto" data-snippet-clipboard-copy-content="&lt;script&gt;
    import { WebGlShader } from &#34;svader&#34;;

    const shaderCode = `#version 300 es

        precision mediump float;

        out vec4 fragColor;

        uniform vec2 u_resolution;
        uniform vec2 u_offset;

        void main() {
            vec2 pos = gl_FragCoord.xy + u_offset;
            vec2 st = pos / u_resolution;
            fragColor = vec4(st, 0.0, 1.0);
        }
    `;
&lt;/script&gt;

&lt;WebGlShader
    width=&#34;500px&#34;
    height=&#34;500px&#34;
    code={shaderCode}
    parameters={[
        {
            name: &#34;u_resolution&#34;,
            value: &#34;resolution&#34;,
        },
        {
            name: &#34;u_offset&#34;,
            value: &#34;offset&#34;,
        },
    ]}
&gt;
    &lt;div class=&#34;fallback&#34;&gt;WebGL not supported in this environment.&lt;/div&gt;
&lt;/WebGlShader&gt;"><pre>&lt;<span>script</span>&gt;<span></span>
<span>    <span>import</span> { <span>WebGlShader</span> } <span>from</span> <span><span>&#34;</span>svader<span>&#34;</span></span>;</span>
<span></span>
<span>    <span>const</span> <span>shaderCode</span> <span>=</span> <span><span>`</span>#version 300 es</span></span>
<span><span></span></span>
<span><span>        precision mediump float;</span></span>
<span><span></span></span>
<span><span>        out vec4 fragColor;</span></span>
<span><span></span></span>
<span><span>        uniform vec2 u_resolution;</span></span>
<span><span>        uniform vec2 u_offset;</span></span>
<span><span></span></span>
<span><span>        void main() {</span></span>
<span><span>            vec2 pos = gl_FragCoord.xy + u_offset;</span></span>
<span><span>            vec2 st = pos / u_resolution;</span></span>
<span><span>            fragColor = vec4(st, 0.0, 1.0);</span></span>
<span><span>        }</span></span>
<span><span>    <span>`</span></span>;</span>
<span></span>&lt;/<span>script</span>&gt;

&lt;<span>WebGlShader</span>
    <span>width</span>=<span><span>&#34;</span>500px<span>&#34;</span></span>
    <span>height</span>=<span><span>&#34;</span>500px<span>&#34;</span></span>
    <span>code</span>={<span>shaderCode</span>}
    <span>parameters</span>={[
        {
            name: <span><span>&#34;</span>u_resolution<span>&#34;</span></span>,
            value: <span><span>&#34;</span>resolution<span>&#34;</span></span>,
        },
        {
            name: <span><span>&#34;</span>u_offset<span>&#34;</span></span>,
            value: <span><span>&#34;</span>offset<span>&#34;</span></span>,
        },
    ]}
&gt;
    &lt;<span>div</span> <span>class</span>=<span><span>&#34;</span>fallback<span>&#34;</span></span>&gt;WebGL not supported in this environment.&lt;/<span>div</span>&gt;
&lt;/<span>WebGlShader</span>&gt;</pre></div>
<p dir="auto">This produces the following output:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/sockmaster27/svader/master/resources/debugShaderWebGl.png"><img src="https://raw.githubusercontent.com/sockmaster27/svader/master/resources/debugShaderWebGl.png" alt="Output of the WebGL shader"/></a></p>
<p dir="auto">Here, the <code>shaderCode</code> variable is a string containing the <a href="https://en.wikipedia.org/wiki/OpenGL_ES" rel="nofollow">GLES</a> shader code.
For simplicity, this is stored as a string, but it would typically be stored in a separate <code>myShader.frag</code> file.
When loading the shader from a file, it might be useful to know that the <code>code</code> property accepts both a <code>string</code> and a <code>Promise&lt;string&gt;</code>.</p>
<p dir="auto">What this code does is:</p>
<ol dir="auto">
<li>Add the given <code>u_offset</code> uniform to the 2D coordinates of the pixel given by <code>gl_FragCoord.xy</code>.</li>
<li>Divide the resulting coordinates entrywise by the <code>u_resolution</code> uniform to normalize the coordinates between 0 and 1.</li>
<li>Return the normalized coordinates as the color of the pixel, such that the <code>x</code> coordinate becomes the red channel and the <code>y</code> coordinate becomes the green channel. The blue channel is always set to 0, and the alpha (opacity) channel is always set to 1 (fully opaque).</li>
</ol>
<p dir="auto">In GLES, <em>uniforms</em> are inputs to the function, that are the same for every pixel on the screen.
These need to be passed in via the <code>parameters</code> property of the <code>&lt;WebGlShader&gt;</code> component.
In this case, we need to pass in two uniforms: <code>u_resolution</code> and <code>u_offset</code>.
Since these specific parameters are very commonly used, they are specially implemented in Svader
such that the <code>value</code> property of each parameter can simply be set to <code>&#34;resolution&#34;</code> and <code>&#34;offset&#34;</code> respectively.</p>
<p dir="auto">Lastly, the <code>&lt;WebGlShader&gt;</code> component accepts a fallback slot, which is rendered when the browser cannot render the shader.</p>

<p dir="auto">The <code>parameters</code> property is an array of objects with the following properties:</p>
<ul dir="auto">
<li>
<p dir="auto"><strong><code>name</code></strong>: The name of the uniform parameter, e.g. <code>&#34;my_uniform&#34;</code>.
This must match the name of the parameter in the shader code.</p>
</li>
<li>
<p dir="auto"><strong><code>type</code></strong>: The type of the uniform parameter as it is written in the shader code, e.g. <code>&#34;float&#34;</code>.
If the <code>value</code> property is a <a href="#webgl-built-in-values">built-in value</a>, such as <code>&#34;resolution&#34;</code>,
the <code>type</code> will be determined automatically and should not be set.</p>
</li>
<li>
<p dir="auto"><strong><code>value</code></strong>: The value of the uniform parameter, or a string specifying a <a href="#webgl-built-in-values">built-in value</a>.
If not a built-in value, the type of this property must correspond to the <code>type</code> property, such that:</p>
<ul dir="auto">
<li><strong><code>float</code>, <code>int</code>, <code>uint</code></strong> is a <code>number</code>,</li>
<li><strong><code>vecN</code>, <code>ivecN</code>, <code>uvecN</code></strong> is a <code>number[]</code> with a length of <code>N</code>, e.g. <code>vec2</code> -&gt; <code>[1.2, 3.4]</code>.</li>
<li><strong><code>matN</code></strong> is a <code>number[]</code> with a length of <code>N * N</code>, e.g. <code>mat2</code> -&gt; <code>[1, 2, 3, 4]</code>.</li>
</ul>
</li>
</ul>

<p dir="auto">Some types of uniforms are used very often. These are implemented in Svader itself, and referred to as <em>built-in values</em>.
To use these, the <code>value</code> property of the parameter object must be set to a string matching one of the following:</p>
<ul dir="auto">
<li>
<p dir="auto"><strong><code>&#34;resolution&#34;</code></strong>: A <code>vec2</code> of the canvas width and height in physical device pixels.</p>
</li>
<li>
<p dir="auto"><strong><code>&#34;scale&#34;</code></strong>: A <code>float</code> of the ratio between CSS pixels and physical device pixels, i.e. zoom level.
For example, if the browser has been zoomed to 150%, the <code>scale</code> parameter will be <code>1.5</code>.</p>
</li>
<li>
<p dir="auto"><strong><code>&#34;time&#34;</code></strong>: A <code>float</code> of the current time in seconds.
NOTE: Passing this parameter to the shader will cause it to rerender every frame.</p>
</li>
<li>
<p dir="auto"><strong><code>&#34;offset&#34;</code></strong>: A <code>vec2</code> to be added to the <code>gl_FragCoord.xy</code> of the fragment shader.
Sometimes the size of the canvas is limited by hardware.
To compensate for this, Svader creates a virtual canvas with a smaller cutout shifting around to cover the screen.
The <code>&#34;resolution&#34;</code> parameter is automatically adjusted to match the size of this virtual canvas, but for technical reasons,
the <code>gl_FragCoord.xy</code> cannot be adjusted from the outside.
Therefore, the <code>&#34;offset&#34;</code> parameter is provided to be manually added to these coordinates.</p>
</li>
</ul>

<p dir="auto">The following is a minimal example of a WebGPU fragment shader component.</p>
<p dir="auto"><a href="https://svelte.dev/repl/498446d091964bb199e6a88bce90feae?version=5.1.10" rel="nofollow"><strong>View in REPL</strong></a></p>
<div dir="auto" data-snippet-clipboard-copy-content="&lt;script&gt;
    import { WebGpuShader } from &#34;svader&#34;;

    const shaderCode = `
        @group(0) @binding(0) var&lt;uniform&gt; resolution: vec2f;
        @group(0) @binding(1) var&lt;uniform&gt; offset: vec2f;

        @fragment
        fn main(@builtin(position) raw_pos: vec4f) -&gt; @location(0) vec4f {
            let pos = raw_pos.xy + offset;
            let st = pos / resolution;
            return vec4f(st, 0.0, 1.0);
        }
    `;
&lt;/script&gt;

&lt;WebGpuShader
    width=&#34;500px&#34;
    height=&#34;500px&#34;
    code={shaderCode}
    parameters={[
        {
            label: &#34;Resolution&#34;,
            binding: 0,
            value: &#34;resolution&#34;,
        },
        {
            label: &#34;Offset&#34;,
            binding: 1,
            value: &#34;offset&#34;,
        },
    ]}
&gt;
    &lt;div class=&#34;fallback&#34;&gt;WebGPU not supported in this environment.&lt;/div&gt;
&lt;/WebGpuShader&gt;"><pre>&lt;<span>script</span>&gt;<span></span>
<span>    <span>import</span> { <span>WebGpuShader</span> } <span>from</span> <span><span>&#34;</span>svader<span>&#34;</span></span>;</span>
<span></span>
<span>    <span>const</span> <span>shaderCode</span> <span>=</span> <span><span>`</span></span></span>
<span><span>        @group(0) @binding(0) var&lt;uniform&gt; resolution: vec2f;</span></span>
<span><span>        @group(0) @binding(1) var&lt;uniform&gt; offset: vec2f;</span></span>
<span><span></span></span>
<span><span>        @fragment</span></span>
<span><span>        fn main(@builtin(position) raw_pos: vec4f) -&gt; @location(0) vec4f {</span></span>
<span><span>            let pos = raw_pos.xy + offset;</span></span>
<span><span>            let st = pos / resolution;</span></span>
<span><span>            return vec4f(st, 0.0, 1.0);</span></span>
<span><span>        }</span></span>
<span><span>    <span>`</span></span>;</span>
<span></span>&lt;/<span>script</span>&gt;

&lt;<span>WebGpuShader</span>
    <span>width</span>=<span><span>&#34;</span>500px<span>&#34;</span></span>
    <span>height</span>=<span><span>&#34;</span>500px<span>&#34;</span></span>
    <span>code</span>={<span>shaderCode</span>}
    <span>parameters</span>={[
        {
            label: <span><span>&#34;</span>Resolution<span>&#34;</span></span>,
            binding: <span>0</span>,
            value: <span><span>&#34;</span>resolution<span>&#34;</span></span>,
        },
        {
            label: <span><span>&#34;</span>Offset<span>&#34;</span></span>,
            binding: <span>1</span>,
            value: <span><span>&#34;</span>offset<span>&#34;</span></span>,
        },
    ]}
&gt;
    &lt;<span>div</span> <span>class</span>=<span><span>&#34;</span>fallback<span>&#34;</span></span>&gt;WebGPU not supported in this environment.&lt;/<span>div</span>&gt;
&lt;/<span>WebGpuShader</span>&gt;</pre></div>
<p dir="auto">This produces the following output:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/sockmaster27/svader/master/resources/debugShaderWebGpu.png"><img src="https://raw.githubusercontent.com/sockmaster27/svader/master/resources/debugShaderWebGpu.png" alt="Output of the WebGPU shader"/></a></p>
<p dir="auto">Here, the <code>shaderCode</code> variable is a string containing the <a href="https://google.github.io/tour-of-wgsl/" rel="nofollow">WGSL</a> shader code.
For simplicity, this is stored as a string, but it would typically be stored in a separate <code>myShader.wgsl</code> file.
When loading the shader from a file, it might be useful to know that the <code>code</code> property accepts both a <code>string</code> and a <code>Promise&lt;string&gt;</code>.</p>
<p dir="auto">What this code does is:</p>
<ol dir="auto">
<li>Add the given <code>offset</code> uniform variable to the 2D coordinates of the pixel given by <code>raw_pos.xy</code>.</li>
<li>Divide the resulting coordinates entrywise by the <code>resolution</code> uniform to normalize the coordinates between 0 and 1.</li>
<li>Return the normalized coordinates as the color of the pixel, such that the <code>x</code> coordinate becomes the red channel and the <code>y</code> coordinate becomes the green channel. The blue channel is always set to 0, and the alpha (opacity) channel is always set to 1 (fully opaque).</li>
</ol>
<p dir="auto">In WGSL, these <code>var&lt;uniform&gt;</code>s are the primary way to pass in parameters to the shader.
These need to be passed in via the <code>parameters</code> property of the <code>&lt;WebGpuShader&gt;</code> component.
In this case, we need to pass in two uniforms: <code>resolution</code> and <code>offset</code>.
Since these specific parameters are very commonly used, they are specially implemented in Svader
such that the <code>value</code> property of each parameter can simply be set to <code>&#34;resolution&#34;</code> and <code>&#34;offset&#34;</code> respectively.</p>
<p dir="auto">Lastly, the <code>&lt;WebGpuShader&gt;</code> component accepts a fallback slot, which is rendered when the browser cannot render the shader.</p>

<p dir="auto">The <code>parameters</code> property is an array of objects with the following properties:</p>
<ul dir="auto">
<li>
<p dir="auto"><strong><code>label</code></strong>: The name of the parameter to be used for debugging.
This does not have to correspond to the name of the parameter in the shader code.</p>
</li>
<li>
<p dir="auto"><strong><code>binding</code></strong>: An integer used to match the parameter to the variable in the shader code.
This has to match the <code>binding</code> property of the parameter in the shader code, e.g. for the variable declaration</p>
<div dir="auto" data-snippet-clipboard-copy-content="@group(0) @binding(42) var&lt;uniform&gt; my_variable: f32;"><pre>@<span>group</span>(<span>0</span>) @<span>binding</span>(<span>42</span>) <span>var</span>&lt;<span>uniform</span>&gt; <span>my_variable</span>: <span>f32</span>;</pre></div>
<p dir="auto">the <code>binding</code> property should be <code>42</code>.</p>
</li>
<li>
<p dir="auto"><strong><code>value</code></strong>: The value of the parameter, or a string specifying a <a href="#webgpu-built-in-values">built-in value</a>.
If not a built-in value, this parameter should be an <code>ArrayBuffer</code>/<code>ArrayBufferView</code>.
For example, to pass in a number to an <code>f32</code> parameter, it can be constructed like <code>new Float32Array([myNumberValue])</code>.</p>
</li>
<li>
<p dir="auto"><strong><code>storage</code></strong>: [Optional - defaults to <code>false</code>] Whether the parameter is a storage variable rather than a uniform variable.
This has to match the declaration in the shader code, e.g. for the variable declaration</p>
<div dir="auto" data-snippet-clipboard-copy-content="@group(0) @binding(0) var&lt;uniform&gt; my_variable: f32;"><pre>@<span>group</span>(<span>0</span>) @<span>binding</span>(<span>0</span>) <span>var</span>&lt;<span>uniform</span>&gt; <span>my_variable</span>: <span>f32</span>;</pre></div>
<p dir="auto">the <code>storage</code> property should be <code>false</code> or omitted, and for</p>
<div dir="auto" data-snippet-clipboard-copy-content="@group(0) @binding(0) var&lt;storage, read&gt; my_variable: f32;"><pre>@<span>group</span>(<span>0</span>) @<span>binding</span>(<span>0</span>) <span>var</span>&lt;<span>storage</span>, <span>read</span>&gt; <span>my_variable</span>: <span>f32</span>;</pre></div>
<p dir="auto">it should be <code>true</code>.
Note that Svader currently only supports <code>var&lt;storage, read&gt;</code> and not <code>var&lt;storage, read_write&gt;</code>.</p>
</li>
</ul>

<p dir="auto">Some types of inputs are used very often. These are implemented in Svader itself, and referred to as <em>built-in values</em>.
To use these, the <code>value</code> property of the parameter object must be set to a string matching one of the following:</p>
<ul dir="auto">
<li>
<p dir="auto"><strong><code>&#34;resolution&#34;</code></strong>: A <code>vec2f</code> of the canvas width and height in physical device pixels.</p>
</li>
<li>
<p dir="auto"><strong><code>&#34;scale&#34;</code></strong>: An <code>f32</code> of the ratio between CSS pixels and physical device pixels, i.e. zoom level.
For example, if the browser has been zoomed to 150%, the <code>scale</code> parameter will be <code>1.5</code>.</p>
</li>
<li>
<p dir="auto"><strong><code>&#34;time&#34;</code></strong>: An <code>f32</code> of the current time in seconds.
NOTE: Passing this parameter to the shader will cause it to rerender every frame.</p>
</li>
<li>
<p dir="auto"><strong><code>&#34;offset&#34;</code></strong>: A <code>vec2f</code> to be added to the <code>@builtin(position)</code> of the fragment shader.
Sometimes the size of the canvas is limited by hardware.
To compensate for this, Svader creates a virtual canvas with a smaller cutout shifting around to cover the screen.
The <code>&#34;resolution&#34;</code> parameter is automatically adjusted to match the size of this virtual canvas, but for technical reasons,
the <code>@builtin(position)</code> cannot be adjusted from the outside.
Therefore, the <code>&#34;offset&#34;</code> parameter is provided to be manually added to these coordinates.</p>
</li>
</ul>

<p dir="auto"><strong>For practical applications, default to using WebGL.</strong></p>
<p dir="auto">WebGL and WebGPU are both rendering APIs that allow web applications to render GPU-accelerated graphics.</p>
<p dir="auto">WebGL is the older of the two and is supported by <a href="https://caniuse.com/webgl" rel="nofollow">all modern browsers</a>.</p>
<p dir="auto">WebGPU is still in the experimental stage and is only supported in a <a href="https://caniuse.com/webgpu" rel="nofollow">few browsers</a>.
However, it supports certain features that WebGL does not. For example, as of writing, WebGL in Google Chrome only supports having 8 canvases active in the document at once, while WebGPU supports a practically unlimited number.</p>

<p dir="auto">Svader is licensed under the <a href="https://github.com/sockmaster27/svader/blob/master/LICENSE.md">MIT License</a>.</p>
</article></div></div>
  </body>
</html>
