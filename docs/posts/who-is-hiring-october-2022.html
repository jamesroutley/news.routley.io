<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://news.ycombinator.com/item?id=33068421">Original</a>
    <h1>Ask HN: Who is hiring? (October 2022)</h1>
    
    <div id="readability-page-1" class="page"><div>
    <article>
        <span>
            <time datetime="2022-09-29">29 Sep 2022</time>
        </span>
        
        
        <section>
            <!--kg-card-begin: markdown--><p><a href="https://age-encryption.org">age</a> is a file encryption format, tool, and library. It was made to replace one of the last remaining GnuPG use cases, but it was not made to <em>replace GnuPG</em> because in the last 20 years we learned that cryptographic tools work best when they are specialized and opinionated instead of flexible Swiss Army knives. How it went is that you&#39;d read <a href="https://latacora.micro.blog/2019/07/16/the-pgp-problem.html">The PGP Problem</a> on the Latacora blog, get convinced that you should use the right tool for the job, scroll to the &#34;Encrypting Files&#34; section, and it&#39;d say:</p>
<blockquote>
<p>This really is a problem. If you’re <em>not</em> making a backup, and you’re <em>not</em> archiving something offline for long-term storage, and you’re <em>not</em> encrypting in order to securely send the file to someone else, and you’re <em>not</em> encrypting virtual drives that you mount/unmount as needed to get work done, then there’s no one good tool that does this now.</p>
</blockquote>
<p>age was made to fill that gap. It&#39;s an annoying gap to fill, because the job is much more underspecified than, say, virtual drives or even backups. People mean different things for files, and even for encryption. They want to encrypt with a passphrase, with a symmetric key, with an asymmetric key, with KMS, with a YubiKey... We had a whole session at the High-Assurance Cryptography Workshop titled something along the lines of &#34;Encrypting files: what does it mean???&#34;.</p>
<p>Eventually what we targeted with age was whatever people were using <code>gpg -c</code> (password encryption) or <code>gpg -e</code> (public key encryption) for. We assumed by the time you dropped down to age you knew what problem you were trying to solve, and wanted a tool that would spare you the pain and risk of dealing with a myriad of legacy cryptographic options you don&#39;t care about. We made it a good UNIX tool, working on pipes, and put you in charge of key management, simplified down to copy-pastable short strings. We introduced <a href="https://github.com/FiloSottile/age/releases/tag/v1.1.0-rc.1">plugins</a> to support encrypting to whatever you want (<a href="https://github.com/str4d/age-plugin-yubikey">YubiKeys</a>, KMS, ...).</p>
<p>One thing we decided is that we&#39;d not include signing support. Signing introduces a whole dimension of complexity to the UX, to key management, and to the cryptographic design of a streamable seekable format. age is in the business of integrity and confidentiality, not authentication. This was <a href="https://github.com/FiloSottile/age/issues/51">hotly debated early on</a>, and still is <a href="https://twitter.com/FiloSottile/status/1475954548556673024">periodically</a>.</p>
<p>In short, while no one can modify an encrypted age file, anyone can replace it with a completely new encrypted file. (This is not actually strictly true, as we&#39;ll see later, but it&#39;s what age says on the tin to be conservative.)</p>
<p>Still, I kept thinking about it, and I am now considering a small backwards-compatible tweak that would introduce explicit support for authentication (not signing!) in age, based on the unadvertised authentication properties that age already has. I&#39;m looking for feedback, especially on the use cases (do you need it? do you not? what for? would this work for you?) so click the reply button or <a href="https://github.com/FiloSottile/age/discussions">open a discussion on GitHub</a>.</p>
<p>First, some background about what authentication is for, and what it is.</p>
<h2 id="what-doesnt-need-authentication">What doesn&#39;t need authentication</h2>
<p>There are a number of age use cases that don&#39;t need age to take care of authentication. They mostly match what age is used for today, which I find fairly reassuring.</p>
<h3 id="storing-secrets-next-to-code">Storing secrets next to code</h3>
<p>If you use something like <a href="https://major.io/2022/04/19/encrypted-gitops-secrets-with-flux-and-age/">SOPS</a> or just check age secrets into a git repository next to source code, you need an authentication story for the whole repository. Having authentication for the secrets will do nothing if the attacker can change the source code that decrypts and uses them.</p>
<p>That story can simply be &#34;we trust GitHub&#34; like most projects. Encrypting secrets with age will keep them confidential even if the project is Open Source, and anyone wanting to replace them will have to make a PR even if they can generate a new valid age file.</p>
<h3 id="local-password-store">Local password-store</h3>
<p>I use <a href="https://github.com/FiloSottile/passage">passage</a>, a <a href="https://www.passwordstore.org/">password-store</a> fork, with <a href="https://github.com/str4d/age-plugin-yubikey">age-plugin-yubikey</a> as my password manager. I don&#39;t need it to authenticate the secrets it decrypts: again, if an attacker can tamper with the encrypted secrets they can change the code that my laptop will run, and do much worse.</p>
<p>(Actually, I also obviously have full-disk encryption enabled, so the only reason I use passage instead of a <code>passwords.txt</code> file<sup><a href="#fn1" id="fnref1">[1]</a></sup> is that with age-plugin-yubikey each decryption requires a YubiKey physical touch. This way even if you compromise my laptop you can&#39;t exfiltrate all my secrets at once.)</p>
<p>I honestly didn&#39;t really get why you&#39;d use passage or password-store at all without a hardware key, which is part of why age doesn&#39;t have an agent yet, but I&#39;ve sort of come around to the &#34;secrets are synced to the cloud&#34; scenario. That use case <em>does</em> need authentication if you&#39;re worried about the attacker feeding you fake passwords.</p>
<h3 id="self-authenticating-data">Self-authenticating data</h3>
<p>If a file is self-authenticating, for example because it starts with a secret token, the attacker can&#39;t produce a new age file <em>that starts with that secret</em> without knowing it. This is because age uses AEADs and never produces unauthenticated output. &#34;Wait, did you just say age is authenticated?&#34; Yes, the term is overloaded and it&#39;s confusing. We&#39;ll talk more about the difference between authenticated-as-in-AEAD and authenticated-as-in-this-article later.</p>
<p>I know of companies in the payment processing space that use age like this. In fact, they probably got a security update by switching from unsigned PGP to age, because the mechanism that provides this kind of integrity in PGP, the &#34;Modification Detection Code&#34;, is/was optional, predates AEADs, and is sketchy at best.<sup><a href="#fn2" id="fnref2">[2]</a></sup></p>
<h3 id="encrypt-to-delete">Encrypt-to-delete</h3>
<p>Deleting bits from storage media is hard, especially in the era of SSDs and wear leveling. Instead, I often encrypt something with age, and just make sure the key never hits permanent storage. Key gone, data as good as deleted.</p>
<p>Here I am only worried about passive attacks, like someone who finds the drive in a dumpster or attached to a cloud VM, not about attackers with the ability to replace the file while I&#39;m working on it.</p>
<h2 id="what-does-need-authentication">What does need authentication</h2>
<p>Does this mean that no one could benefit from authentication? Nope, that&#39;s why we&#39;re here. I can think of at least one broad use case where lack of authentication is uncomfortable.</p>
<h3 id="cloud-backups">Cloud backups</h3>
<p>If you make a backup with age, and then store it in the cloud, age will prevent the cloud provider from inspecting the backups. However, the provider <em>can</em> replace the whole backup with something else. Maybe you&#39;ll notice while recovering it because your files are not in there, maybe you&#39;ll not and run some code from it that gives the cloud provider access that shouldn&#39;t have been available. Not great.</p>
<p>This generally extends to storing anything in the cloud encrypted with age (or with GnuPG without signing it).</p>
<h3 id="borderline-misuses">Borderline misuses</h3>
<p>Aside from untrusted remote storage, I could only come up with some contrived scenarios. If you were to use age as a way to protect a public API, like &#34;POST an age-encrypted file to this endpoint with your instructions&#34;, you&#39;d probably want it to provide authentication.</p>
<p>age is for <em>file encryption</em>, one could argue that this is misuse—there are better ways to build something like this than using age—but we&#39;re in the business of making safe tools, not another generation of footguns.</p>
<p>(There&#39;s a good chance I&#39;m overlooking some other use cases! I&#39;d like to know about them as I try to design a solution that works broadly. Hit the reply button, you know the drill.)</p>
<h2 id="authentication-vs-aeads">Authentication vs AEADs</h2>
<p>You might have heard that a selling point of age is that it uses AEADs, which expands to Authenticated Encryption with Additional Data. Doesn&#39;t that mean age is authenticated!?</p>
<p>No, that&#39;s about symmetric encryption. I know it&#39;s confusing. We&#39;re bad at naming things.</p>
<p>What using AEADs means is that if you encrypt this file</p>
<pre><code>The Magic Words are Squeamish Ossifrage.

We attack at dawn.
</code></pre>
<p>and the attacker knows the <code>We attack at dawn</code> part but not the first part, they can&#39;t tamper with it, flipping some bits, turning <code>dawn</code> into <code>dusk</code>. AEADs have Message Authentication Codes that ensure that whoever authored the whole message knew the symmetric key that allows decrypting it.</p>
<p>This is table stakes and in 2022 you should not use anything that doesn&#39;t do authenticated symmetric encryption.</p>
<p>What&#39;s tricky about AEADs is that they authenticate the whole message at once at the end. This is fine if your message is small enough. If your message is too big, like a multi-GB file, you will want to stream it rather than hold it all in memory, and might be tempted to output (&#34;release&#34;) plaintext as you decrypt it, before you get to and verify the MAC at the end. That&#39;s how you get attacks like <a href="https://efail.de/">EFail</a>. What age does is split the file into 64KiB chunks, encrypt each of them with an AEAD, and verify each of them before releasing its plaintext. The scheme it uses is called <a href="https://eprint.iacr.org/2015/189">STREAM</a>, but intuitively it&#39;s just about putting a counter in the AEAD nonce.</p>
<p>Anyway, AEADs operate at a lower level than asymmetric encryption. What this article is about is authenticated <em>asymmetric</em> encryption, where you get guarantees about who sent the whole message, not just about the message not being partially tampered with.</p>
<h2 id="authentication-vs-signing">Authentication vs signing</h2>
<p>Wait, &#34;guarantees about who sent the whole message&#34;... isn&#39;t that just signing? Well, no. Existing tools (<em>cough</em> gpg <em>cough</em>) trained us to consider them one and the same because the only way they provide sender authentication is via signing, but authentication is a more limited and easily achieved property. Signing is publicly verifiable: the recipient can go to a third party and prove that the sender sent the message by showing the signature and the sender&#39;s public key. Sender authentication proves <em>to the recipient</em> that the message was generated by the sender. There isn&#39;t necessarily a sender public key, and the recipient might be able to forge messages looking like they are from the sender (called &#34;key compromise impersonation&#34; if you don&#39;t like it, and &#34;deniability&#34; if you do).</p>
<p>Examples of schemes with sender authentication but without signing are the <a href="https://noiseprotocol.org/noise.html#one-way-handshake-patterns">Noise patterns K and X</a>, <a href="https://signal.org/docs/specifications/x3dh/">Signal&#39;s X3DH</a>, <a href="https://words.filippo.io/dispatches/nacl-api/">NaCl&#39;s box</a>, or <a href="https://libsodium.gitbook.io/doc/key_exchange">libsodium&#39;s key exchange APIs</a>.</p>
<p>Another difference is that while authentication can happen at the key exchange level, and the derived shared symmetric key can be used with STREAM as age does, signatures need to be necessarily computed over the whole message. This sets us back on making the format seekable and streamable: either we make an expensive asymmetric signature for every chunk, or we get fancy with signed Merkle trees, which anyway get us a streamable format only either in the encryption or in the decryption direction. (Or, like discussed above, we just stick a signature at the end and release unverified plaintext at decryption time, causing countless vulnerabilities.)</p>
<h3 id="on-combining-signing-and-encryption">On combining signing and encryption</h3>
<p>The common advice for people who need encryption and authentication is to combine age with a signing tool like signify or OpenSSH (which can sign files now!). Part of why I&#39;m thinking about age and authentication is that I am not very satisfied with that. Combining encryption and signing is actually kinda tricky and can&#39;t be done perfectly. This is also why we did not document recommended ways to do this.</p>
<p>If you <em>encrypt and then sign</em>, an attacker can strip your signature, replace it with their own, and make it look like they encrypted the file even if they don&#39;t actually know the contents.</p>
<p>If you <em>sign and then encrypt</em>, the recipient can decrypt the file, keep your signature, and encrypt it to a different recipient, making it look like you intended to send the file to them.</p>
<p>What you need to avoid both issues at the same time is a different cryptographic primitive called <em>signcryption</em>. The good (???) news is that no popular tool does signcryption, so you&#39;re probably not worse off by using signify and age.<sup><a href="#fn3" id="fnref3">[3]</a></sup></p>
<h2 id="age-is-already-authenticated">age is already authenticated!</h2>
<p>Here&#39;s the big reveal: age is already authenticated, sort of. <strong>You can&#39;t produce an age file that will decrypt with a given identity if you don&#39;t know its recipient.</strong><sup><a href="#fn4" id="fnref4">[4]</a></sup> (Read on for an important gotcha though, which is why this is not yet advertised.)</p>
<p>This means that if you need to make sure an attacker can&#39;t forge age encrypted files for you, you just need to keep the recipient string (<code>age1...</code>) secret from the attacker. For example, if you upload backups to cloud storage, simply make sure you don&#39;t upload the recipient string along with them.</p>
<p>It will be cryptographically impossible for the attacker to generate a file that age will successfully decrypt with the corresponding identity. This is easily shown with an information-theoretical argument: the age file key is encrypted with an AEAD; the key for that is derived with HKDF from the shared secret, the ephemeral key, <em>and the recipient</em>.<sup><a href="#fn5" id="fnref5">[5]</a></sup> Without knowledge of the recipient, the attacker can&#39;t produce a key that will cause the AEAD decryption to succeed. age is very simple, so it&#39;s also easy to show we don&#39;t have baked-in default private keys or NULL cipher modes, so the only identities that are accepted are the ones you specify on the command line.</p>
<p>It&#39;s not as straightforward to show that the recipient can&#39;t be extracted from an encrypted file or from an online decryption oracle, but there&#39;s literature about this that approaches it from the angle of anonymity: if it were possible to extract the recipient, it would be possible to deanonymize it, and they show that&#39;s not possible.</p>
<p>Whether this all holds depends on the recipient type. I am confident the property holds for the X25519 recipients, and that it would hold for a hypothetical <a href="https://words.filippo.io/dispatches/post-quantum-age/">Kyber768+X25519</a> one, but it&#39;s important not to advertise it as an age-wide property.</p>
<p>Note that unlike Noise/X3DH/NaCl<sup><a href="#fn6" id="fnref6">[6]</a></sup> this doesn&#39;t provide for multiple sender identities: the only authentication performed here is &#34;the sender knew the recipient for this identity&#34;. If you need to tell apart files encrypted by Server A and by Server B, you&#39;ll need to generate two separate keypairs, and give each of them a different one. Thankfully, age keypairs are cheap! This lets us avoid adding an extra knob in the UI for the sender&#39;s public/private key: when you use <code>-r</code> you&#39;re proving you know the recipient, and when you use <code>-i</code> you&#39;re saying you want the file to come from someone who knows the corresponding recipient. This might not be enough to, say, encrypt emails, but it&#39;s enough for all the use cases we discussed above.</p>
<h2 id="the-ux-issue">The UX issue</h2>
<p>The main issue with making this guarantee usable is that the recipient is supposed to be public, and now we&#39;re telling people to keep it secret.</p>
<p>I actually had a very hard time getting a cryptographer<sup><a href="#fn7" id="fnref7">[7]</a></sup> to confirm my understanding of the authentication properties, because they kept saying &#34;but the public key is public&#34; and I kept saying &#34;ok but imagine we didn&#39;t give it to the attacker&#34; and we kept going in a loop like that until I said &#34;alright there is no public key anywhere and let&#39;s call this curve point the super-secret sender key&#34;. It went ok from there.</p>
<p>The best idea I have so far is making a plugin called <code>authkey</code> for this, and then the recipients will look like <code>age1authkey1...</code> which might be enough? The alternative, which I am not a fan of, is introducing a new recipient format like <code>AGE-AUTH-KEY1...</code>. I&#39;m looking for feedback on this!</p>
<h2 id="the-multiple-recipients-issue">The multiple recipients issue</h2>
<p>It&#39;s not this simple though. There is also a gotcha that we need to fix with a technical tweak.</p>
<p>If you encrypt a file to Alice&#39;s recipient and to Bob&#39;s recipient (age supports <a href="https://github.com/FiloSottile/age/blob/main/README.md#multiple-recipients">multiple recipients</a>), and send it to both, you just gave a blank check to Alice and Bob to encrypt files to each other even if they don&#39;t know each other&#39;s recipients.</p>
<p>How that works is that Alice can take the file, derive the file key using her identity, and then use the file key to change the contents of the file, keeping the same header. That new file will still decrypt successfully with Bob&#39;s identity, but it was produced by Alice, who doesn&#39;t know Bob&#39;s recipient. Alice can even drop her stanza from the header and recompute the HMAC, and Bob wouldn&#39;t even know this happened.</p>
<p>This is too sharp an edge to leave it laying around, and it&#39;s why age doesn&#39;t say &#34;it&#39;s authenticated, just keep the recipient secret&#34; on the tin.</p>
<p>We encountered this before while designing age: the symmetric passphrase-encryption <em>scrypt</em> recipient type can&#39;t be used with multiple recipients, precisely for this reason. We figured that if you decrypt a file with a passphrase you have an expectation that whoever produced it knew the passphrase. That is, there is a sender authentication expectation embedded in the passphrase encryption UX. To stop an attack like the one above, we <a href="https://github.com/FiloSottile/age/blob/000e9311011084a3e80e5baddc62e44cf2f3d337/age.go#L114-L122">special-cased it</a>.</p>
<p>We can do the same thing with our special authenticated recipient type: enforce<sup><a href="#fn8" id="fnref8">[8]</a></sup> that when it&#39;s used, it&#39;s the only recipient of the file. Rather than adding a special case, I am thinking of extending the <a href="https://github.com/C2SP/C2SP/pull/5">plugin protocol</a> and <a href="https://pkg.go.dev/filippo.io/age#Recipient"><code>Recipient</code> interface</a> to let a recipient specify that it wants to provide authentication. This will also let us remove the scrypt special case and enable symmetric encryption plugins that are as good as the built-in scrypt recipient type 🙌</p>
<h2 id="age-authkey-plugin">age-authkey-plugin</h2>
<p>Summing up, bringing authentication to age should be as simple as</p>
<ol>
<li>adding a way for recipient implementations and plugins to signal they should only ever be used as the only recipient for any given file</li>
<li>making a plugin/built-in recipient type that flips that flag and has a clear name but otherwise looks exactly like the X25519 recipient type</li>
</ol>
<p>The plugin might not even need to implement the identity/decryption side:<sup><a href="#fn9" id="fnref9">[9]</a></sup> it can just produce files that decrypt with regular native age identities, as those already provide authentication as designed. This prevents the receiving side from checking for misuse, but as we said an attacker can just strip the other recipients from the file, and once a file is encrypted to multiple recipients the damage is done.</p>
<p>None of this is implemented yet, so please reach out with feedback on use-cases, UX, and cryptography design, whether positive or negative!</p>
<h2 id="the-picture">The picture</h2>
<p>Took this at 100ft with no filter, no flash, no custom white balancing, and no post-production. It was this eerie spot of bright red at a depth where only blue light can get. Apparently it&#39;s symbiotic bioluminescent bacteria. Anyway, it had <em>no right</em> to be that red that deep under the sea.</p>
<p><img src="https://words.filippo.io/content/images/2022/09/Newsletter---1.jpeg" alt="A red anemone with two clownfish, surrounded by deep blue reef." loading="lazy"/></p>
<p>If you want to stay up to date with my work on age, consider <a href="https://twitter.com/FiloSottile">following me on Twitter</a> or <a href="https://filippo.io/newsletter">subscribing to this newsletter</a> if you haven&#39;t already!</p>
<hr/>
<section>
<ol>
<li id="fn1"><p>Unpopular opinion: <code>passwords.txt</code> is <em>fine</em>. If you can extract files from my laptop you can probably get my cookies (depending on how the OS keychain is used), and certainly a number of authentication tokens, as well as pictures and private documents. <a href="https://xkcd.com/1200/">Relevant XKCD.</a> <a href="#fnref1">↩︎</a></p>
</li>
<li id="fn2"><p>As far as I can tell, MDCs are mandatory now, but <a href="https://crypto.stackexchange.com/questions/80098/what-does-modification-detection-code-mdc-in-openpgp-do">were optional for a long time</a>, meaning attackers could just strip them, generating only a warning that every user and application ignored. This is how <a href="https://efail.de/">EFail</a> happened. GnuPG also supports AEADs now, but again when dealing with a fragmented ecosystem full of weaker protocol options, who knows if the other side updated or not, and whether it&#39;s configured correctly or not. See the Authentication vs AEADs section for some more background about why all this matters. <a href="#fnref2">↩︎</a></p>
</li>
<li id="fn3"><p>It&#39;s especially vexing that GnuPG doesn&#39;t do signcryption because it totally could! Its UX already involves dealing with a sender key pair and a recipient key pair for each encrypt+sign operation, and its signatures span the whole message so safe streaming is already out the window. However, alas. <a href="#fnref3">↩︎</a></p>
</li>
<li id="fn4"><p>In age, an identity is a string commonly containing a private key like <code>AGE-SECRET-KEY-16DDVPME9RAUQYXULTUXG0L0L87W52H2C0M7PTEXSS9JKHSTR525QP7Z3SM</code> and a recipient is a string commonly containing a public key like <code>age1k5flf920mg7lderduqclc74m5aevha47rzk6x4xww48m9xzy93gs37q7c6</code>. <a href="#fnref4">↩︎</a></p>
</li>
<li id="fn5"><p>This doesn&#39;t even rely on X25519 itself having contributory behavior, which requires rejecting the all-zeroes output. The age spec and implementation still do that, but even if an implementation missed that check the HKDF derivation would still provide authentication. <a href="https://eprint.iacr.org/2019/526.pdf">Other protocols were not as lucky.</a> <a href="#fnref5">↩︎</a></p>
</li>
<li id="fn6"><p>X3DH does three DH exchanges, while here we do only the one. The second introduces sender identities, which we intentionally reject for UX/UI reasons. The third is about forward secrecy and it involves rotating pre-keys. It would be interesting to make a forward-secrecy plugin for age that uses some support server to store the pre-keys. We discussed this briefly at HACS and it might be worth writing up, but it&#39;s going to be another issue :) <a href="#fnref6">↩︎</a></p>
</li>
<li id="fn7"><p>&#34;Filippo, I thought you were a cryptographer?&#34; When talking with people who care about the difference, I&#39;m more properly a cryptography engineer, and I still occasionally get actual cryptographers to review my stuff if I&#39;m doing something weird. <a href="#fnref7">↩︎</a></p>
</li>
<li id="fn8"><p>This doesn&#39;t stop a malicious sender from bypassing the check and encrypting a file to multiple recipients anyway, but a malicious sender can just share the secret recipient string, so we&#39;re not defending against that, just against accidental &#34;misuse&#34;. (Or, more properly, unexpected behavior.) <a href="#fnref8">↩︎</a></p>
</li>
<li id="fn9"><p>This is something I&#39;m pretty happy about the <a href="https://github.com/C2SP/C2SP/pull/5">plugin protocol</a>: a plugin can implement only the recipient side and produce files that decrypt without the plugin, or just the identity side and decrypt files that were encrypted without the plugin. It enables things like agent forwarding to happen entirely behind a plugin. Or, if you have a hardware token or an API that supports X25519, you can make a plugin for it that doesn&#39;t require any special software on the encryption side. <a href="#fnref9">↩︎</a></p>
</li>
</ol>
</section>
<!--kg-card-end: markdown-->
        </section>
    </article>
</div></div>
  </body>
</html>
