<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://webkit.org/blog/13607/help-choose-from-options-for-css-nesting-syntax/">Original</a>
    <h1>Help choose the syntax for CSS Nesting</h1>
    
    <div id="readability-page-1" class="page"><div>
                                
                <p>The CSS Working Group is continuing a debate over the best way to define nesting in CSS. And if you are someone who writes CSS, we’d like your help.</p>
<p>Nesting is a super-popular feature of tools like <a href="https://sass-lang.com/">Sass</a>. It can save web developers time otherwise spent writing the same selectors over and over. And it can make code cleaner and easier to understand.</p>
<figure>
<div>
<h4>Unnested CSS</h4>
<pre><code>.class1 {
  color: green;
}
.class1 .class2 {
  border: 5px solid black;
}
</code></pre>
</div>
<div>
<h4>Nesting in Sass</h4>
<pre><code>.class1 {
  color: green;
  .class2 {
    border: 5px solid black;
  }
}
</code></pre>
</div>
</figure>
<p>Everyone wishes CSS nesting could use the same kind of simple syntax that Sass does. That’s impossible, however, because of the way browser parsing engines work. If they see a sequence like <code>element:pseudo</code>, they’ll parse the entire style rule as if it were a <code>property: value</code> declaration.</p>
<p>So, a lengthy discussion began about what to do instead. Earlier this summer, the CSSWG <a href="https://developer.chrome.com/blog/help-css-nesting/">debated between Option 1, Option 2 and Option 3</a>. Of those, Option 3 won. Since then, two more options have been proposed, Option 4 and Option 5. If you remember various details discussed across <a href="https://github.com/w3c/csswg-drafts/issues?q=is%3Aissue+label%3Acss-nesting-1+">53+ issues</a>, put all of those older ideas aside. At this point, we are only debating between Option 3, 4 and 5, as described in this article through the set of examples below.</p>
<p>To help us decide which option to choose, we’d like you to read these examples and answer a one-question survey.</p>
<p>Please look at these examples, consider how you write and maintain style sheets, and think deeply about which syntax you prefer. Then vote for the one you think is best.</p>
<p>In all three options, the <code>&amp;</code> symbol is a marker that means “put the selector that’s outside of the nest [here]”. For example…</p>
<figure>
<div>
<h4>This…</h4>
<pre><code>.foo {
  &amp; .bar {
    color: blue;
  }
}
</code></pre>
</div>
<div>
<h4>… becomes this.</h4>
<pre><code>.foo .bar {
  color: blue;
}
</code></pre>
</div>
</figure>
<figure>
<div>
<h4>And this…</h4>
<pre><code>.foo {
  .bar &amp; {
    color: blue;
  }
}
</code></pre>
</div>
<div>
<h4>… becomes this.</h4>
<pre><code>.bar .foo {
  color: blue;
}
</code></pre>
</div>
</figure>
<p>Got it?</p>
<p>In many of the following examples, the <code>&amp;</code> is optional. Some developers will use it because it helps make their code more readable. Other developers will opt to leave it out, especially when copying &amp; pasting code from unnested contexts. When the <code>&amp;</code> is left out, the outside selector is added at the beginning, as an ancestor. (When we surveyed authors, their opinions on use of optional <code>&amp;</code> were split 50/50.)</p>
<p>But here’s the key trick to Option 3 <em>(and only Option 3)</em> — if you are using an element selector (like <code>p</code>, <code>article</code>, or <code>div</code>), the <code>&amp;</code> is required. If you are using any other selector, like a class or ID, you can choose to leave the <code>&amp;</code> out. The easiest way to remember this: the selector can never begin with a letter. It must begin with a symbol. Some people in the CSSWG believe this will be easy to remember and do. Others wonder, given that style rules placed anywhere else in CSS don’t have such a syntactic restriction, if it will create confusion, tripping up developers in a way that is hard to debug.</p>
<p>As you compare the options, think about how your whole team will handle nested code. Think about what it might be like to copy &amp; paste code from one project to another. Which option will make it easy to code inside and outside a nested context? Which will make it easiest to read, write, and edit large quantities of CSS?</p>
<p>Which is best for the future of CSS? When people write CSS thirty years from now — long after today’s habits and expectations are completely forgotten, when future generations have never heard of Sass — which option will make writing this language easy and elegant?</p>
<p>Do be sure to read through <em>all</em> the examples. One option might stand out as your favorite in one example, and yet, have problems that you don’t like in another example.</p>
<h2>Comparing the Options</h2>
<ul>
<li><strong>Option 5:</strong> Top-level @nest: Nested style rules are declared in a dedicated, independent at-rule that accepts only style rules. Declarations can be nested using &amp; { .. }.</li>
<li><strong>Option 4:</strong> Postfix block: Style rules allow for an optional, second block after the declaration block that contains only style rules.</li>
<li><strong>Option 3:</strong> Non-letter start: Nested style rules can be added directly into a declaration block, but cannot start with a letter.</li>
</ul>
<h3>Example A: The Basics</h3>
<figure>
<div>
<h4>Unnested CSS</h4>
<pre><code>article {
  font-family: avenir;
}
article aside {
  font-size: 1rem;
}
</code></pre>
</div>
<div>
<h4>Option 5</h4>
<pre><code>@nest article {
  &amp; {
    font-family: avenir;
  }
  aside {
    font-size: 1rem;
  }
}
</code></pre>
</div>
<div>
<h4>Option 4</h4>
<pre><code>article {
  font-family: avenir;
} {
  aside {
    font-size: 1rem;
  }
}
</code></pre>
</div>
<div>
<h4>Option 3</h4>
<pre><code>article {
  font-family: avenir;
  &amp; aside {
    font-size: 1rem;
  }
}
</code></pre>
</div>
</figure>
<h3>Example B: With syntax variations</h3>
<p>There are a lot of different ways developers like to structure their CSS — using tabs vs spaces, putting the <code>{</code> <code>}</code> braces on the same line as a rule or on separate lines, ordering rules in a certain order. This will also be true when writing nested CSS. Example B articulates a few of the possible variations of how you might format nested code for each option. It’s totally up to your personal preference.</p>
<figure>
<div>
<h4>Unnested CSS</h4>
<pre><code>.foo {
  color: red;
}
.foo .bar {
  color: blue;
}
.foo p {
  color: yellow;
}
</code></pre>
</div>
<div>
<h4>Option 5</h4>
<pre><code>@nest .foo {
  &amp; {
    color: red;
  }
  .bar {
    color: blue;
  }
  p {
    color: yellow;
  }
}
</code></pre>
<p>Or you can use this syntax:</p>
<pre><code>@nest .foo {{
  color: red; }
  .bar {
    color: blue;
  }
  p {
    color: yellow;
  }
}
</code></pre>
</div>
<div>
<h4>Option 4</h4>
<pre><code>.foo {
  color: red;
} {
  .bar {
    color: blue;
  }
  p {
    color: yellow;
  }
}
</code></pre>
<p>Or you can format it like this:</p>
<pre><code>.foo {
  color: red; } {
  .bar {
    color: blue;
  }
  p {
    color: yellow;
  }
}
</code></pre>
</div>
<div>
<h4>Option 3</h4>
<pre><code>.foo {
  color: red;
  .bar {
    color: blue;
  }
  &amp; p {
    color: yellow;
  }
}
</code></pre>
<p>Or you can use this syntax:</p>
<pre><code>.foo {
  color: red;
  &amp; .bar {
    color: blue;
  }
  &amp; p {
    color: yellow;
  }
}
</code></pre>
</div>
</figure>
<h3>Example C: Re-nesting inside an element selector</h3>
<p>There is a situation for Option 3 where just using an <code>&amp;</code> is not enough — when we want the parent selectors referenced by <code>&amp;</code> to come <em>after</em> the nested selector. Since we can’t start with <code>&amp;</code>, we need to use something like <code>:is()</code> or <code>:where()</code> in order to start with a symbol instead of a letter.</p>
<figure>
<div>
<h4>Unnested CSS</h4>
<pre><code>a:hover {
  color: hotpink;
}
aside a:hover {
  color: red;
}
</code></pre>
</div>
<div>
<h4>Option 5</h4>
<pre><code>@nest a:hover {
  &amp; {
    color: hotpink;
  }
  aside &amp; {
    color: red;
  }
}
</code></pre>
</div>
<div>
<h4>Option 4</h4>
<pre><code>a:hover {
  color: hotpink;
} {
  aside &amp; {
    color: red;
  }
}
</code></pre>
</div>
<div>
<h4>Option 3</h4>
<pre><code>a:hover {
  color: hotpink;
  :is(aside) &amp; {
    color: red;
  }
}
</code></pre>
</div>
</figure>
<h3>Example D: Zero unnested declarations + various selectors</h3>
<figure>
<div>
<h4>Unnested CSS</h4>
<pre><code>:has(img) .product {
  margin-left: 1rem;
}
:has(img) h2 {
  font-size: 1.2rem;
}
:has(img) &gt; h3 {
  font-size: 1rem;
}
:has(img):hover {
  box-shadow: 10px 10px;
}
a:has(img) {
  border: none;
}
</code></pre>
</div>
<div>
<h4>Option 5</h4>
<pre><code>@nest :has(img) {
  .product {
    margin-left: 1rem;
  }
  h2 {
    font-size: 1.2rem;
  }
  &gt; h3 {
    font-size: 1rem;
  }
  &amp;:hover {
    box-shadow: 10px 10px;
  }
  a&amp; {
    border: none;
  }
}
</code></pre>
</div>
<div>
<h4>Option 4</h4>
<pre><code>:has(img) {} {
  .product {
    margin-left: 1rem;
  }
  h2 {
    font-size: 1.2rem;
  }
  &gt; h3 {
    font-size: 1rem;
  }
  &amp;:hover {
    box-shadow: 10px 10px;
  }
  a&amp; {
    border: none;
  }
}
</code></pre>
</div>
<div>
<h4>Option 3</h4>
<pre><code>:has(img) {
  .product {
    margin-left: 1rem;
  }
  &amp; h2 {
    font-size: 1.2rem;
  }
  &gt; h3 {
    font-size: 1rem;
  }
  &amp;:hover {
    box-shadow: 10px 10px;
  }
  :is(a&amp;) {
    border: none;
  }
}
</code></pre>
</div>
</figure>
<h3>Example E: Nesting inside of nesting</h3>
<figure>
<div>
<h4>Unnested CSS</h4>
<pre><code>table.colortable td {
  text-align: center;
}
table.colortable td .c {
  text-transform: uppercase;
}
table.colortable td:first-child,
table.colortable td:first-child + td {
  border: 1px solid black;
}
table.colortable th {
  text-align: center;
  background: black;
  color: white;
}
</code></pre>
</div>
<div>
<h4>Option 5</h4>
<pre><code>@nest table.colortable {
  @nest td {
    &amp; {
      text-align: center;
    }
    .c {
      text-transform: uppercase;
    }
    &amp;:first-child,
    &amp;:first-child + td {
       border: 1px solid black;
    }
  }
  th {
    text-align: center;
    background: black;
    color: white;
  }
}
</code></pre>
</div>
<div>
<h4>Option 4</h4>
<pre><code>table.colortable {} {
  td {
    text-align: center; }{
    .c {
      text-transform: uppercase;
    }
    &amp;:first-child,
    &amp;:first-child + td {
       border: 1px solid black;
    }
  }
  th {
    text-align: center;
    background: black;
    color: white;
  }
}
</code></pre>
</div>
<div>
<h4>Option 3</h4>
<pre><code>table.colortable {
  &amp; td {
    text-align: center;
    .c {
      text-transform: uppercase;
    }
    &amp;:first-child,
    &amp;:first-child + td {
       border: 1px solid black;
    }
  }
  &amp; th {
    text-align: center;
    background: black;
    color: white;
  }
}
</code></pre>
</div>
</figure>
<h3>Example F: Integration with Media Queries</h3>
<figure>
<div>
<h4>Unnested CSS</h4>
<pre><code>ol, ul {
  padding-left: 1em;
}

@media (max-width: 30em){
  .type ul,
  .type ol {
    padding-left: 0;
  }
}
</code></pre>
</div>
<div>
<h4>Option 5</h4>
<pre><code>@nest ol, ul {
  &amp; {
    padding-left: 1em;
  }
  @media (max-width: 30em){
    .type &amp; {
      padding-left: 0;
    }
  }
}
</code></pre>
</div>
<div>
<h4>Option 4</h4>
<pre><code>ol, ul {
  padding-left: 1em;
} {
  @media (max-width: 30em){
    .type &amp; {
      padding-left: 0;
    }
  }
}
</code></pre>
</div>
<div>
<h4>Option 3</h4>
<pre><code>ol, ul {
  padding-left: 1em;
  @media (max-width: 30em){
    .type &amp; {
      padding-left: 0;
    }
  }
}
</code></pre>
</div>
</figure>
<h3>Example G: Integration with Cascade Layers</h3>
<figure>
<div>
<h4>Unnested CSS</h4>
<pre><code>@layer base {
  html {
    width: 100%;
  }
  @layer support {
    html body {
      min-width: 100%;
    }
  }
}
</code></pre>
</div>
<div>
<h4>Option 5</h4>
<pre><code>@layer base {
  @nest html {
    &amp; {
      width: 100%;
    }
    @layer support {
      body {
        min-width: 100%;
      }
    }
  }
}
</code></pre>
</div>
<div>
<h4>Option 4</h4>
<pre><code>@layer base {
  html {
    width: 100%;
  } {
    @layer support {
      body {
        min-width: 100%;
      }
    }
  }
}
</code></pre>
</div>
<div>
<h4>Option 3</h4>
<pre><code>@layer base {
  html {
    width: 100%;
    @layer support {
      &amp; body {
        min-width: 100%;
      }
    }
  }
}
</code></pre>
</div>
</figure>
<p>Now that you’ve had a chance to absorb examples of the three options, and maybe play around with a few of your own, which do you believe should become the way CSS is written in the future?</p>
<div>
<div>
    <h3>Which option is best for the future of CSS?</h3>
    <ul>
                <li>
            
            
        </li>
            <li>
            
            
        </li>
            <li>
            
            
        </li>
        </ul>
</div>

<p>If you’d like to describe more about your thoughts, reply to <a href="https://twitter.com/webkit/status/1603510921447481364">@webkit on Twitter</a>, or <a href="https://front-end.social/@jensimmons/109519943983773398">@jensimmons@front-end.social on Mastodon</a>.</p>
<p>Thank you for your feedback. There’s a lot that goes into designing a programming language, not just the results of a survey like this. But knowing what web developers think after reading examples will help us with our ongoing discussions.</p>
<p>Please pass along this survey to other people you know who also write CSS, post it to social media, and help us get the word out. The more people who voice their opinion, the better.</p>
<p>We especially want to hear from developers working on a wide variety of projects — from websites to web apps, native apps to digital signage to printed books. Whether large and small projects, huge or tiny teams, brand-new or decades-old codebases. Built on any variety of frameworks, CMSes, build systems… dynamic or static, rendered server-side or client-side… there are a <em>lot</em> of ways people use CSS, all around the globe. We need to consider them all.</p>

                            </div>
        </div></div>
  </body>
</html>
