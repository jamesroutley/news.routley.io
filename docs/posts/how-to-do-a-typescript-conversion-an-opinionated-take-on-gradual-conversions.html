<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://v5.chriskrycho.com/journal/how-to-do-a-typescript-conversion/">Original</a>
    <h1>How to Do a TypeScript Conversion: an opinionated take on gradual conversions</h1>
    
    <div id="readability-page-1" class="page"><div>
      


<div>
   <p>
      <b><a href="https://v4.chriskrycho.com/2018/assumed-audiences.html">Assumed audience</a>:</b>
      Software developers working with JavaScript and TypeScript, or thinking about and working with gradual type systems in other languages. In particularly: I am not arguing <em>for</em> TypeScript or Python <code>types</code> or Ruby’s Sorbet etc.; I am talking to people who are already interested in adopting them.

   </p>
   
   
   <p>
      <b><a href="https://v5.chriskrycho.com/journal/epistemic-status/">Epistemic status</a>:</b>
      I led the conversion of a 150,000-line-of-code app to strictly-typed TypeScript back in 2017–2018, and was the primary “subject matter expert” for LinkedIn’s adoption of TypeScript across its millions of lines of library and application JavaScript.

   </p>
   
   
</div><p>One of the most common questions I get from people interested in converting their JavaScript applications to TypeScript is: <em>How should I approach this?</em> There are two approaches people tend to think of:</p>
<ul>
<li>
<p>A relatively relaxed approach: setting <code>compilerOptions.strict: false</code> initially, converting files as you touch them, and gradually increasing the robustness of the types by enabling individual strictness flags until you have them all turned on — or some combination of these.</p>
</li>
<li>
<p>A more rigorous approach: setting <code>compilerOptions.strict: true</code>, and very carefully converting the codebase in a<span></span> <span>“</span>leaves-first” order, where no module is converted without first having types for all of its dependencies. Making explicit what<span></span> <span>“</span>more rigorous” probably already implies: this is my preferred approach.</p>
</li>
</ul>
<p>Most developers (myself included, the first time I did this!) are <em>very</em> much tempted to do the<span></span> <span>“</span>just convert a file when you touch it, in loose mode or with lots of <code>// @ts-expect-error</code> and <code>any</code> scattered around” thing. It seems like the lowest-friction, fastest, easiest path:</p>
<ul>
<li>
<p>That pattern <em>usually</em> works with other kinds of migrations.</p>
</li>
<li>
<p>It feels more tractable, in that you can just do it<span></span> <span>“</span>as you go”.</p>
</li>
<li>
<p>It actually works pretty well for sufficiently-small codebases — it’s very good for &lt;1,000LOC and pretty good for &lt;10,000LOC.</p>
</li>
</ul>
<p>Accordingly, it is also the approach I see most often recommended to people starting out on converting a TypeScript codebase.</p>
<p>Unfortunately…</p>
<figure><img src="https://cdn.chriskrycho.com/images/Ackbar-trap.jpeg" alt="" title="image of Star Wars character Admiral Ackbar saying &#39;It’s a Trap!&#39;"/><figcaption>It’s a trap!</figcaption></figure>
<p>You will encounter two big problems when you take the more relaxed, intuitive, much-recommended approach. On smaller codebases, these problems may not matter all that much, but the bigger your codebase is, the more they will hurt.</p>
<p>First, you will end up having to propagate changes to various files over and over and over again:</p>
<ul>
<li>
<p>Each time you enable another strictness setting, you will see new type errors in many modules. The biggest of these will be <code>strictNullChecks</code> and <code>noImplicitAny</code>, but <em>all</em> of the strictness settings will catch things missed without them: that is why the settings exist, after all. These are not usually spurious errors, either. Thus, you will have to do <em>another</em> pass<span></span> <span>“</span>fixing the types” for the module each time you enable a new strictness setting.</p>
</li>
<li>
<p>If you convert a module but have not converted the modules it depends on, all the types from those dependency modules will be <code>any</code>. When you convert those files, you very often find mistakes in the way you were using their APIs. Just like with strictness settings, this means you often end up having to<span></span> <span>“</span>fix the types” for other modules each time you make this kind of change.</p>
</li>
</ul>
<section aria-label="Note" aria-role="note"><p>I scare-quoted<span></span> <span>“</span>fix the types” here because it is usually<span></span> <span>“</span>write the types and <em>fix the bugs</em><span></span><span>”</span>. As I have <a href="https://v5.chriskrycho.com/journal/is-typescript-good/">written before</a>:</p>
<blockquote>
<p>…in many cases the complexity was already present in the code base. The TypeScript conversion did not create that complexity: It exposed it. Real-world JavaScript code is often incredibly complicated — indeed, <em>clever</em> — in ways that only become obvious when we try to express in types the contracts the code already invisibly assumes. As a result, conversions from JavaScript require complex types far more than code written in TypeScript from the start. Much of the complexity is (permanently!) implicit in JavaScript, while writing out the contracts in TypeScript makes it explicit. That enables better choices: does this particular API actually warrant some complicated types, or should we just keep it simple? Usually: the latter.</p>
</blockquote>
<p>Even so, it can <em>feel</em> like we are just fixing TypeScript issues over and over again, and I think it is important to acknowledge that.</p>
</section>
<p>This kind of thing can be quite demoralizing at a personal level, as you work to<span></span> <span>“</span>fix types”, because you find yourself hitting the same pieces of code over and over again. It can also be difficult to communicate clearly to less technical team members, e.g. designers and product owners who can be quite reasonably confused about why we need to spend time on doing TypeScript things for this chunk of the codebase <em>again</em> — “Didn’t we do that a month ago?” Having to explain that<span></span> <span>“</span>Yes, we did, but not all the way” can be frustrating.</p>
<p>Second, and maybe even worse, you <em>cannot</em> rely on the things you have already converted actually being safe when taking this approach. They <em>feel</em> safer than JS types-wise because they are in TS… but they are not, because they have lots of <code>// @ts-expect-error</code> and <code>any</code> scattered around. It can end up being quite demoralizing and frustrating to have errors coming out of your<span></span> <span>“</span>but we already converted this!” modules. It also undermines a lot of the promises we make when justifying the investment to our management or partners:<span></span> <span>“</span>I thought the point of TypeScript was to fix these kinds of bugs, so why isn’t it doing that?” As with having to do multiple passes on the same files, having to answer<span></span> <span>“</span>Well, we converted this to TypeScript, but not all the way…” is deeply unsatisfying.</p>
<p>Finally, the problems described here scale exponentially in difficulty with the size of the codebase. With 1,000 lines of code, these problems are minor annoyances. With 10,000 lines of code, they are a bit of a hassle. With 100,000 lines of code, they are actively demoralizing. With 1,000,000 lines of code… you might just never finish. The friction never goes away, so it requires constant effort to keep it moving and get it across the finish line.</p>
<p>The more rigorous approach of setting <code>compilerOptions.strict: true</code> and walking the dependency graph in order means you never have to revisit the file because of increased strictness or newly-well-typed dependencies. What is more, there is a really big upside to the experience when you do a conversion this way. When all your dependencies are already strictly typed, every time you convert a new module it sits on a solid foundation. TypeScript itself can do a fair bit of the work of adding types for you via its code fixes, since it can use the information from the downstream <abbr title="application programming interface">API</abbr>s you call. For the parts you have to figure out on your own, you still have to check all the ways the module’s <abbr title="application programming interface">API</abbr>s are <em>used</em>, but you don’t have to check all the things it <em>uses</em>: the problem space is cut in half.</p>
<p>The net is a double win: every module you convert actuall delivers on type safety, and every module you touch gets easier because its foundation is safe. The process is like a flywheel: every bit of effort you apply speeds up the rest of the process.</p>
<p>This is not a free lunch. It generally requires more discipline and more explicit buy-in from stakeholders. Instead of<span></span> <span>“</span>just convert a file when you touch it (and usually leave it not-fully-converted)” you need to carve out some dedicated time to do the work by tackling a couple modules each week or something like that. Ultimately, though, it makes for a much better experience for everyone involved.</p>



   </div></div>
  </body>
</html>
