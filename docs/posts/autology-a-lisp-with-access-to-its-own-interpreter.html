<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/Kimbsy/autology">Original</a>
    <h1>Autology: A Lisp with access to its own interpreter</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">A hot take on Lisp metaprogramming, <code>Autology</code> is a Lisp with access
to its own interpreter.</p>

<p dir="auto">Autology is a functional interpreted Lisp language, written in Clojure.</p>
<p dir="auto">The Autology interpreter function is defined as a data structure which is available to the Autology program, it is bound to the variable <code>*i*</code>.</p>
<p dir="auto">Whenever an expression needs to be evaluated, Autology will retrieve the current value of <code>*i*</code> from the current lexically scoped execution environment and use it to evaluate the expression.</p>
<p dir="auto">By binding new values of <code>*i*</code> we can modify the behaviour of the Autology language while our program is running.</p>

<p dir="auto">Mainly for fun and to explore a neat idea.</p>
<p dir="auto">Autology is not a particularly useful language as-is, its very slow and resource intensive.</p>
<p dir="auto">Macros are the normal tool for Lisp languages to modify their syntax or behaviour, but these are normally only available at compile time. Autology allows dynamic rewriting of the language at runtime.</p>
<p dir="auto">Even other non-Lisp languages are able to define some form of Domain Specific Language to allow programmers to express problems more clearly, however these are generally quite restrictive in scope. Autology allows full ad-hoc re-writing of the syntax of the language, as well as defining new features or removing existing ones.</p>

<p dir="auto">Well to start with you might like to add functions to the language. Autology doesn&#39;t have them by default, but we can rebind the <code>*i*</code> symbol to a data structure representing a new interpreter function, one that does have functions.</p>
<div dir="auto" data-snippet-clipboard-copy-content="(bind (;; grab a copy of the `:atl/eval-list` section of the
       ;; interpreter which is responsible for evaluating lists.
       original (get-marker *i* :atl/eval-list)

       ;; define a case test+body for use when the list expression
       ;; starts with our function special form, in this case `λ`.
       λ-form (qu (λ (let [[_λ params body] e]
                       (fn [&amp; values]
                         (autology.core/evaluate
                          body
                          (reduce (fn [acc-env [s v]]
                                    (assoc acc-env s v))
                                  env
                                  (zipmap params values)))))))

       ;; rebind `*i*` to be a new interpreter with the
       ;; `:atl/eval-list` section replaced with a version that
       ;; includes our lambda handling special form.
       *i* (replace-marker *i* :atl/eval-list
                           (list :atl/eval-list
                                 (concat (butlast original)
                                         λ-form
                                         (list (last original)))))

       ;; We can now immediately define functions since the
       ;; interpreter will have already been updated to evaluate the
       ;; remaining bindings like this one.
       double (λ (n)
                 (+ n n)))

      ;; Finally we can invoke our new function!
      (double (double (double (double (double 1.3125))))))"><pre>(<span>bind</span> (<span>;;</span> grab a copy of the `:atl/eval-list` section of the
       <span><span>;</span>; interpreter which is responsible for evaluating lists.</span>
       original (<span>get-marker</span> *i* <span>:atl/eval-list</span>)

       <span><span>;</span>; define a case test+body for use when the list expression</span>
       <span><span>;</span>; starts with our function special form, in this case `λ`.</span>
       λ-form (<span>qu</span> (<span>λ</span> (<span>let</span> [[_λ params body] e]
                       (<span>fn</span> [&amp; values]
                         (<span>autology.core/evaluate</span>
                          body
                          (<span>reduce</span> (<span>fn</span> [acc-env [s v]]
                                    (<span>assoc</span> acc-env s v))
                                  env
                                  (<span>zipmap</span> params values)))))))

       <span><span>;</span>; rebind `*i*` to be a new interpreter with the</span>
       <span><span>;</span>; `:atl/eval-list` section replaced with a version that</span>
       <span><span>;</span>; includes our lambda handling special form.</span>
       *i* (<span>replace-marker</span> *i* <span>:atl/eval-list</span>
                           (<span>list</span> <span>:atl/eval-list</span>
                                 (<span>concat</span> (<span>butlast</span> original)
                                         λ-form
                                         (<span>list</span> (<span>last</span> original)))))

       <span><span>;</span>; We can now immediately define functions since the</span>
       <span><span>;</span>; interpreter will have already been updated to evaluate the</span>
       <span><span>;</span>; remaining bindings like this one.</span>
       double (<span>λ</span> (<span>n</span>)
                 (<span>+</span> n n)))

      <span><span>;</span>; Finally we can invoke our new function!</span>
      (<span>double</span> (<span>double</span> (<span>double</span> (<span>double</span> (<span>double</span> <span>1.3125</span>))))))</pre></div>
<p dir="auto">After that, pretty much anything you want!</p>
<ul dir="auto">
<li>Why not switch form applicative order evaluation to normal order evaluation?</li>
<li>Maybe modify the language so it uses a continuation passing style?</li>
<li>Define a metacircular Lisp inside your program which has access to it&#39;s own interpreter as well at the Autology interpreter.</li>
</ul>


</article></div></div>
  </body>
</html>
