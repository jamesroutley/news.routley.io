<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.openmymind.net/Zig-Quirks/">Original</a>
    <h1>Zig Quirks</h1>
    
    <div id="readability-page-1" class="page"><article><p>I&#39;ve been writing a lot of Zig lately (<a href="https://github.com/karlseguin/http.zig">http.zig</a>, <a href="https://github.com/karlseguin/log.zig">log.zig</a> and <a href="https://github.com/karlseguin/websocket.zig">websocket.zig</a>). I&#39;m still in the early stages of learning, and often run into things that either surprise me or I don&#39;t understand. I figure I&#39;m probably not the only one, so going through them might be useful.</p>

<p>Some of these things are probably really obvious to a lot of people.</p>

<h3>1 -  const Self = @This()</h3>
<p>Once you start looking at Zig source code, it won&#39;t be long until you see:</p>

<pre><code><span>const</span> Self <span>=</span> <span>@This</span><span>(</span><span>)</span><span>;</span></code></pre>

<p>First, functions that begin with <code>@</code>, like <code>@This()</code>, are builtin functions that are provided by the compiler. <code>@This()</code> returns the type of the inner most struct/enum/union. For example, the following prints &#34;true&#34;:</p>

<pre><code><span>const</span> <span>Tea</span> <span>=</span> <span>struct</span> <span>{</span></code></pre>

<p>This is often used in a method to specify the receiver:</p>

<pre><code><span>const</span> <span>Tea</span> <span>=</span> <span>struct</span> <span>{</span></code></pre>

<p>But this usage, while common, is superficial. We could just have easily written: <code>fn drink(self: *Tea) void {...}</code>.</p>

<p>Where it&#39;s really useful is when we have an anonymous structure:</p>

<pre><code><span>fn</span> <span>beverage</span><span>(</span><span>)</span> <span><span>type</span></span> <span>{</span></code></pre>

<p>This will print &#34;true&#34; followed by  &#34;false&#34;.</p>

<p>This example is contrived: why do we need an anonymous structure here? We don&#39;t, but this is the foundation for how Zig implements generics. For generics, we do something similar to the above (with the addition of passing a <code>type</code> to our function), and thus need <code>@This()</code> to reference the anonymous struct from within the anonymous struct.</p>

<h3>2 -  Files are Structures</h3>
<p>In Zig, files are structures.</p>

<p>Say we wanted a <code>Tea</code> structure. We could create a file named &#34;tea.zig&#34; and add the following:</p>

<pre><code></code></pre>

<p>Callers could then use our <code>Tea</code> structure like so:</p>

<pre><code><span>const</span> tea <span>=</span> <span>@import</span><span>(</span><span>&#34;tea.zig&#34;</span><span>)</span><span>;</span></code></pre>

<p>Or, with this superficial change:</p>

<pre><code></code></pre>

<p>Since files are structures, our <code>Tea</code> is actually nested inside of the implicitly created file structure. As an alternative, the full contents of tea.zig could be:</p>

<pre><code>full<span>:</span> <span><span>bool</span></span> <span>=</span> <span>true</span><span>,</span></code></pre>

<p>Which we could import with:</p>

<pre><code><span>const</span> Tea <span>=</span> <span>@import</span><span>(</span><span>&#34;tea.zig&#34;</span><span>)</span><span>;</span></code></pre>

<p>It looks weird, but if you imagine that the contents are wrapped in a <code>pub const default = struct { ... };</code> it makes sense. I was pretty confused the first time I saw one.</p>

<h3>3 - Naming Convention</h3>
<p>In general:</p>
<ul>
  <li>Functions are camelCase
  </li><li>Types are PascalCase
  </li><li>Variables are lowercase_with_underscores
</li></ul>

<p>The main exception to this rule are functions that returns types (most commonly used with generics). These are PascalCade.</p>

<p>Normally, file names are lowercase_with_underscore. However, files that expose a type directly (like our last tea example), follow the type naming rule. Thus, the file should have been called &#34;Tea.zig&#34;.</p>

<p>It&#39;s easy to follow but is more colorful than what I&#39;m used to.</p>

<h3>4 - .{...}</h3>
<p>You see <code>.{...}</code> throughout Zig code. This is an anonymous structure. The following compiles and prints &#34;keemun&#34;::</p>

<pre><code><span>pub</span> <span>fn</span> <span>main</span><span>(</span><span>)</span> <span><span>!</span><span>void</span></span> <span>{</span></code></pre>

<p>The above example actually has 2 anonymous structures. The first is the anonymous structure that we&#39;ve assigned to the <code>tea</code> variable. The other is the second parameter we passed to <code>print</code>: i.e <code>.{tea.type}</code>. This second version is a special type of anonymous structure with implicit field names. The field names are &#34;0&#34;, &#34;1&#34;, &#34;2&#34;, ... In Zig, this is called a tuple. We can confirm the implicit field names by accessing them directly:</p>

<pre><code><span>pub</span> <span>fn</span> <span>main</span><span>(</span><span>)</span> <span><span>!</span><span>void</span></span> <span>{</span></code></pre>

<p>The <code>@&#34;0&#34;</code> syntax is necessary because <code>0</code> and <code>1</code> aren&#39;t standard identifiers (i.e. they don&#39;t begin with a letter), and thus must be quoted.</p>

<p>Another place that you&#39;ll see the <code>.{...}</code> syntax is when the structure can be inferred. You&#39;ll commonly see this inside of a structure&#39;s <code>init</code> function:</p>

<pre><code><span>pub</span> <span>const</span> <span>Tea</span> <span>=</span> <span>struct</span> <span>{</span></code></pre>

<p>You also see it as a function parameter:</p>

<pre><code><span>var</span> server <span>=</span> httpz<span>.</span><span>Server</span><span>(</span><span>)</span><span>.</span><span>init</span><span>(</span>allocator<span>,</span> <span>.</span><span>{</span><span>}</span><span>)</span><span>;</span></code></pre>

<p>The second parameter is an <code>httpz.Config</code>, which Zig can infer. Zig requires that every field be initialized, but <code>httpz.Config</code> has default values for each field, so an empty struct intializer is fine. You could also specify one or more fields explicitly:</p>

<pre><code><span>var</span> server <span>=</span> httpz<span>.</span><span>Server</span><span>(</span><span>)</span><span>.</span><span>init</span><span>(</span>allocator<span>,</span> <span>.</span><span>{</span><span>.</span>port <span>=</span> <span>5040</span><span>}</span><span>)</span><span>;</span></code></pre>

<p>Zig&#39;s <code>.{...}</code> is like telling the compiler &#34;make this fit&#34;.</p>

<h3>5 - .field = value</h3>
<p>In the above code, we used <code>.full = true</code> and <code>.port = 5040</code>. This is how fields are set when a struct is initialized. I don&#39;t know if this was the intention, but it&#39;s actually consistent with how fields are generally set.</p>

<p>I think the following example shows how the  <code>.field = value</code> syntax makes sense:</p>

<pre><code><span>var</span> tea <span>=</span> <span>Tea</span><span>{</span><span>.</span>full <span>=</span> <span>true</span><span>}</span><span>;</span></code></pre>

<h3>6 - Private Struct Fields</h3>
<p>Speaking of structure fields, they&#39;re always public. Structures and functions are private by default with an option to make them public. But struct fields can only be public. The recommendation is to document allowed/proper usage of each field.</p>

<p>I don&#39;t want to editorialize this post too much, but it&#39;s already caused the type of issues that you&#39;d expect, and I think it&#39;ll only cause more difficulties in a 1.x world.</p>

<h3>7 - const *tmp</h3>
<p>Prior to Zig 0.10, the first line of this code:</p>

<pre><code><span>const</span> r <span>=</span> std<span>.</span>rand<span>.</span>DefaultPrng<span>.</span><span>init</span><span>(</span><span>0</span><span>)</span><span>.</span><span>random</span><span>(</span><span>)</span><span>;</span></code></pre>

<p>Would have been equivalent to:</p>

<pre><code><span>var</span> t <span>=</span> std<span>.</span>rand<span>.</span>DefaultPrng<span>.</span><span>init</span><span>(</span><span>0</span><span>)</span><span>;</span></code></pre>

<p>From 0.10 onward however, the same line is now equivalent to:</p>

<pre><code><span>const</span> t <span>=</span> std<span>.</span>rand<span>.</span>DefaultPrng<span>.</span><span>init</span><span>(</span><span>0</span><span>)</span><span>;</span></code></pre>

<p>Notice that <code>t</code> has gone from being a <code>var</code> to a <code>const</code>. The difference is important since <code>random()</code> requires a mutable value. In other words, our original code no longer works. You&#39;ll get an error saying that a <code>*rand.Xoshiro256</code> was expected, but a <code>*const rand.Xoshiro256</code> was found instead. To make it work, we need to split the original code and explicitly introduce the temporary variable as a <code>var</code>:</p>

<pre><code><span>var</span> t <span>=</span> std<span>.</span>rand<span>.</span>DefaultPrng<span>.</span><span>init</span><span>(</span><span>0</span><span>)</span><span>;</span></code></pre>

<h3>8 - comptime_int</h3>
<p>Zig has a powerful &#34;comptime&#34; feature that enables developers to do things at compile time. Logically, compile time execution can only operate on compile-time known data. To support this, Zig has a <code>comptime_int</code> and <code>comptime_float</code> type. Consider the following example:</p>

<pre><code><span>var</span> x <span>=</span> <span>0</span><span>;</span></code></pre>

<p>This won&#39;t compile. <code>x&#39;s</code>  type is inferred as being a <code>comptime_int</code> since the value, <code>0</code>, is known at compile time. The problem here is that a <code>comptime_int</code> must be a <code>const</code>. Of course, if we change the declaration to <code>const x = 0;</code> we&#39;ll get a different error because we&#39;re trying to add 2 to a <code>const</code>.</p>

<p>The solution is to explicitly define x as a <code>usize</code> (or some other runtime integer type, like <code>u64</code>):</p>

<pre><code><span>var</span> x<span>:</span> <span><span>usize</span></span> <span>=</span> <span>0</span><span>;</span></code></pre>

<h3>9 - std.testing.expectEqual</h3>
<p>Possibly the first test that you write will result in a surprising compilation error. Consider this code:</p>

<pre><code><span>fn</span> <span>add</span><span>(</span>a<span>:</span> <span><span>i64</span></span><span>,</span> b<span>:</span> <span><span>i64</span></span><span>)</span> <span><span>i64</span></span> <span>{</span></code></pre>

<p>If I showed you <code>expectEqual&#39;s</code> signature, can you tell why it doesn&#39;t compile:</p>

<pre><code><span>pub</span> <span>fn</span> <span>expectEqual</span><span>(</span>expected<span>:</span> <span>anytype</span><span>,</span> actual<span>:</span> <span>@TypeOf</span><span>(</span>expected<span>)</span><span>)</span> <span>!</span><span>void</span></code></pre>

<p>It might be hard to tell, but the &#34;actual&#34; value is coerced to the same type as the &#34;expected&#34; value. Our above &#34;add&#34; test fails to compile because an <code>i64</code> cannot be coereced to a <code>comptime_int</code>.</p>

<p>One simple solution is to swap our parameters:</p>
<pre><code><span>test</span> <span>&#34;add&#34;</span> <span>{</span></code></pre>

<p>And this <em>does</em> work, and a lot of people do this. The main downside is that the failure message has the expected and actual values mixed up.</p>

<p>The correct way to solve this is to cast our expected value to the actual type, using the <code>@as()</code> builtin:</p>

<pre><code><span>test</span> <span>&#34;add&#34;</span> <span>{</span></code></pre>

<p>Now, you might think this is only a problem with <code>comptime_int</code>, but you&#39;ll run into this over and over for other types as well. This test also doesn&#39;t compile:</p>

<pre><code><span>test</span> <span>&#34;hashmap: get&#34;</span> <span>{</span></code></pre>

<p>The return value of <code>get</code> is <code>?[]const u8</code>, which is an optional (aka nullable) string. But our expected value is [correctly] null and a <code>?[]const u8</code> cannot be coerced to <code>null</code>. To fix this, we must coerce <code>null</code> to a <code>?[]const u8</code>:</p>

<pre><code><span>try</span> std<span>.</span>testing<span>.</span><span>expectEqual</span><span>(</span><span>@as</span><span>(</span><span>?</span><span>[</span><span>]</span><span>const</span> <span>u8</span><span>,</span> <span>null</span><span>)</span><span>,</span> m<span>.</span><span>get</span><span>(</span><span>&#34;teg&#34;</span><span>)</span><span>)</span><span>;</span></code></pre>


<h3>10 - Shadowing</h3>
<p>The Zig documentation states that &#34;Identifiers are never allowed to &#34;hide&#34; other identifiers by using the same name.&#34; So if you have <code>const reader = @import(&#34;reader.zig&#34;);</code> at the top your file, you can&#39;t have anything else named <code>reader</code> in the same file.</p>

<p>You&#39;ll have to be more creative when coming up with variables that don&#39;t shadow existing ones (which, for me, generally means using more obscure names).</p>
</article></div>
  </body>
</html>
