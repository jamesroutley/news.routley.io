<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://vstinner.github.io/python30-listdir-undecodable-filenames.html">Original</a>
    <h1>The History and rationale of the Python 3 Unicode model for the operating system</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody"><p>Ten years ago, when Python 3.0 final was released, <tt>os.listdir(str)</tt>
<strong>ignored silently undecodable filenames</strong>:</p>
<pre>$ python3.0
&gt;&gt;&gt; os.mkdir(b&#39;x&#39;)
&gt;&gt;&gt; open(b&#39;x/nonascii\xff&#39;, &#39;w&#39;).close()
&gt;&gt;&gt; os.listdir(&#39;x&#39;)
[]
</pre>
<p>You had to use bytes to see all filenames:</p>
<pre>&gt;&gt;&gt; os.listdir(b&#39;x&#39;)
[b&#39;nonascii\xff&#39;]
</pre>
<p>If the locale is POSIX or C, listdir() ignored silently all non-ASCII
filenames.  Hopefully, <tt>os.listdir()</tt> accepts <tt>bytes</tt>, right? In fact, 4
months before the 3.0 final release, it was not the case.</p>
<p>Lying on the real content of a directory looks like a very bad idea. Well,
there is a rationale behind this design. Let me tell you this story which is
now 10 years old.</p>
<p><strong>This article is the first in a series of articles telling the history and
rationale of the Python 3 Unicode model for the operating system:</strong></p>
<ul>
<li><ol>
<li><a href="https://vstinner.github.io/python30-listdir-undecodable-filenames.html">Python 3.0 listdir() Bug on Undecodable Filenames</a></li>
</ol>
</li>
<li><ol start="2">
<li><a href="https://vstinner.github.io/pep-383.html">Python 3.1 surrogateescape error handler (PEP 383)</a></li>
</ol>
</li>
<li><ol start="3">
<li><a href="https://vstinner.github.io/painful-history-python-filesystem-encoding.html">Python 3.2 Painful History of the Filesystem Encoding</a></li>
</ol>
</li>
<li><ol start="4">
<li><a href="https://vstinner.github.io/python36-utf8-windows.html">Python 3.6 now uses UTF-8 on Windows</a></li>
</ol>
</li>
<li><ol start="5">
<li><a href="https://vstinner.github.io/posix-locale.html">Python 3.7 and the POSIX locale</a></li>
</ol>
</li>
<li><ol start="6">
<li><a href="https://vstinner.github.io/python37-new-utf8-mode.html">Python 3.7 UTF-8 Mode</a></li>
</ol>
</li>
</ul>
<div id="the-os-walk-bug">
<h2>The os.walk() bug</h2>
<p><a href="http://www.dailymail.co.uk/news/article-3592525/Classic-crashes-Incredible-black-white-photos-chaos-roads-early-days-automobile-beautiful-vintage-motors-smashing-trees-careering-canals-plummeting-bridges.html"><img alt="Boston Herald-Traveler photographer Leslie Jones had an eye for a dramatic scene, including when this seven-tonne dump truck plunged through the Warren Avenue bridge, in Boston" src="https://vstinner.github.io/images/car_accident_hole.jpg"/></a></p><p><a href="https://bugs.python.org/issue3187">bpo-3187</a>, june 2008: <strong>Helmut
Jarausch</strong> tested the <strong>first beta release of Python 3.0</strong> and reported a bug
on <tt>os.walk()</tt> when he tried to walk into his home directory:</p>
<pre>Traceback (most recent call last):
  File &#34;WalkBug.py&#34;, line 5, in &lt;module&gt;
    for Dir, SubDirs, Files in os.walk(&#39;/home/jarausch&#39;) :
  File &#34;/usr/local/lib/python3.0/os.py&#34;, line 278, in walk
    for x in walk(path, topdown, onerror, followlinks):
  File &#34;/usr/local/lib/python3.0/os.py&#34;, line 268, in walk
    if isdir(join(top, name)):
  File &#34;/usr/local/lib/python3.0/posixpath.py&#34;, line 64, in join
    if b.startswith(&#39;/&#39;):
TypeError: expected an object with the buffer interface
</pre>
<p>In Python 3.0b1, <tt>os.listdir(str)</tt> returned undecodable filenames as
<tt>bytes</tt>. The caller must be prepared to get filenames as two types: <tt>str</tt>
and <tt>bytes</tt>: it wasn&#39;t the case for <tt>os.walk()</tt> which failed with a
<tt>TypeError</tt>.</p>
<p><strong>At the first look, the bug seems trivial to fix. In fact, many solutions were
proposed, it will take 4 months and 79 messages to fix the bug</strong>.</p>
</div>
<div id="i-proposed-a-new-filename-class">
<h2>I proposed a new Filename class</h2>
<p>August 2008, <a href="https://bugs.python.org/issue3187#msg71612">my first comment proposed</a> to use a custom &#34;Filename&#34; type
to store the original <tt>bytes</tt> filename, but also gives a Unicode view of the
filename, in a single object, using an hypothetical <tt>myformat()</tt> function:</p>
<pre>class Filename:
    def __init__(self, orig):
        self.as_bytes = orig
        self.as_str = myformat(orig)
    def __str__(self):
        return self.as_str
    def __bytes__(self):
        return self.as_bytes
</pre>
<p><strong>Antoine Pitrou</strong> suggested to inherit from <tt>str</tt>:</p>
<blockquote>
I agree that logically it&#39;s the right solution. It&#39;s also the most
invasive. If that class is <strong>made a subclass of str</strong>, however, existing
code shouldn&#39;t break more than it currently does.</blockquote>
<p>I preferred to inherit from <tt>bytes</tt> for pratical reasons. Antoine noted that
the native type for filenames on Windows is <tt>str</tt>, and so inheriting from
<tt>bytes</tt> can be an issue on Windows.</p>
<p>Anyway, <a href="https://bugs.python.org/issue3187#msg71749">Guido van Rossum disliked the idea</a> (comment on InvalidFilename, a
variant of the class):</p>
<blockquote>
I&#39;m not interested in the InvalidFilename class; it&#39;s an API complification
that might seem right for your situation but <strong>will hinder most other
people</strong>.</blockquote>
</div>
<div id="guido-van-rossum-proposed-to-use-replace-error-handler">
<h2>Guido van Rossum proposed to use replace error handler</h2>
<p><strong>Guido van Rossum</strong> <a href="https://bugs.python.org/issue3187#msg71655">proposed to use the replace error handler</a> to prevent decoding error. For
example, <tt>b&#39;nonascii\xff&#39;</tt> is decoded as <tt>&#39;nonascii�&#39;</tt>.</p>
<p>The problem is that this filename cannot be used to read the file content using
<tt>open()</tt> or to remove the file using <tt>os.unlink()</tt>, since the operating
system doesn&#39;t know the Unicode filename containing the &#34;�&#34; character.</p>
<p>An important property is that <strong>encoding back the Unicode filename to bytes
must return the same original bytes filename</strong>.</p>
</div>
<div id="defer-the-choice-to-the-caller-pass-a-callback">
<h2>Defer the choice to the caller: pass a callback</h2>
<p>As no obvious choice arised, <a href="https://bugs.python.org/issue3187#msg71680">I proposed to use a callback to handle
undecodable filenames</a>.
Pseudo-code:</p>
<pre>def listdir(path, fallback_decoder=default_fallback_decoder):
    charset = sys.getfilesystemcharset()
    dir_fd = opendir(path)
    try:
        for bytesname in readdir(dir_fd):
            try:
                name = str(bytesname, charset)
            exept UnicodeDecodeError:
                name = fallback_decoder(bytesname)
            yield name
    finally:
        closedir(dir_fd)
</pre>
<p>The default behaviour is to raise an exception on decoding error:</p>
<pre>def default_fallback_decoder(name):
   raise
</pre>
<p>Example of callback returning the raw bytes string unchanged (Python 3.0 beta1
behaviour):</p>
<pre>def return_undecodable_unchanged(name):
   return name
</pre>
<p>Example to use a custom filename class:</p>
<pre>class Filename:
   ...

def filename_decoder(name):
   return Filename(name)
</pre>
<p><a href="https://bugs.python.org/issue3187#msg71699">Guido also disliked my callback idea</a>:</p>
<blockquote>
The callback variant is <strong>too complex</strong>; you could <strong>write it yourself by
using os.listdir() with a bytes argument</strong>.</blockquote>
</div>
<div id="emit-a-warning-on-undecodable-filename">
<h2>Emit a warning on undecodable filename</h2>
<p><a href="http://www.unicode.org/"><img alt="Warning: venoumous snakes" src="https://vstinner.github.io/images/warning_venomous_snakes.png"/></a></p><p>As ignoring undecodable filenames in <tt>os.listdir(str)</tt> slowly became the most
popular option, <strong>Benjamin Peterson</strong> <a href="https://bugs.python.org/issue3187#msg71700">proposed to emit a warning</a> if a filename cannot be decoded,
to ease debugging:</p>
<blockquote>
(...) I don&#39;t like the idea of silently losing the contents of a directory.
That&#39;s asking for difficult to discover bugs. Could Python emit a warning
in this case?</blockquote>
<p>Guido van Rossum <a href="https://bugs.python.org/issue3187#msg71705">liked the idea</a>:</p>
<blockquote>
This may be the best compromise yet.</blockquote>
<p><strong>Amaury Forgeot d&#39;Arc</strong> <a href="https://bugs.python.org/issue3187#msg73535">asked</a>:</p>
<blockquote>
Does the warning warn multiple times? IIRC the default behaviour is to warn
once.</blockquote>
<p><strong>Benjamin Peterson</strong> <a href="https://bugs.python.org/issue3187#msg73535">replied</a>:</p>
<blockquote>
<strong>Making a warning happen more than once is tricky because it requires
messing with the warnings filter.</strong> This of course takes away some of the
user&#39;s control which is one of the main reasons for using the Python
warning system in the first place.</blockquote>
<p>Because of this issue, the warning idea was abandonned.</p>
</div>
<div id="support-bytes-and-fix-os-listdir">
<h2>Support bytes and fix os.listdir()</h2>
<p>Guido repeated that the best workaround is to pass filenames as <tt>bytes</tt>,
which is the native type for filenames on Unix, but most functions only
accepted filenames as <tt>str</tt>.</p>
<p>I started to write multiple patches to support passing filenames as <tt>bytes</tt>:</p>
<ul>
<li><tt>posix_path_bytes.patch</tt>: enhance <tt>posixpath.join()</tt></li>
<li><tt>io_byte_filename.patch</tt>: enhance <tt>open()</tt></li>
<li><tt>fnmatch_bytes.patch</tt>: enhance <tt>fnmatch.filter()</tt></li>
<li><tt>glob1_bytes.patch</tt>: enhance <tt>glob.glob()</tt></li>
<li><tt>getcwd_bytes.patch</tt>: <tt>os.getcwd()</tt> returns bytes if unicode conversion fails</li>
<li><tt>merge_os_getcwd_getcwdu.patch</tt>: Remove <tt>os.getcwdu()</tt>;
<tt>os.getcwd(bytes=True)</tt> returns bytes</li>
<li><tt>os_getcwdb.patch</tt>: Fix <tt>os.getcwd()</tt> by using <tt>PyUnicode_Decode()</tt> and
add <tt>os.getcwdb()</tt> which returns <tt>bytes</tt></li>
</ul>
<p>Guido van Rossum created a <a href="https://codereview.appspot.com/3055">review on my combined patches</a>. Then I also combined my patches into a
single <tt>python3_bytes_filename.patch</tt> file.</p>
<p><strong>After one month of development, 6 versions of the combined patch, Guido
commited my big change</strong> as the <a href="https://github.com/python/cpython/commit/f0af3e30db9475ab68bcb1f1ce0b5581e214df76">commit f0af3e30</a>:</p>
<pre>commit f0af3e30db9475ab68bcb1f1ce0b5581e214df76
Author: Guido van Rossum &lt;guido@python.org&gt;
Date:   Thu Oct 2 18:55:37 2008 +0000

    Issue #3187: Better support for &#34;undecodable&#34; filenames.  Code by Victor
    Stinner, with small tweaks by GvR.

 Lib/fnmatch.py                |  27 ++++---
 Lib/genericpath.py            |   5 +-
 Lib/glob.py                   |  17 +++--
 Lib/io.py                     |  15 ++--
 Lib/posixpath.py              | 171 +++++++++++++++++++++++++++++++-----------
 Lib/test/test_fnmatch.py      |   9 +++
 Lib/test/test_posix.py        |   2 +-
 Lib/test/test_posixpath.py    | 150 ++++++++++++++++++++++++++++++++----
 Lib/test/test_unicode_file.py |   6 +-
 Misc/NEWS                     |  10 ++-
 Modules/posixmodule.c         |  90 +++++++++-------------
 11 files changed, 358 insertions(+), 144 deletions(-)
</pre>
<p>My change:</p>
<ul>
<li>Modify <tt>os.listdir(str)</tt> to <strong>ignore silently undecodable filenames</strong>,
instead of returning them as <tt>bytes</tt></li>
<li>Add <tt>os.getcwdb()</tt> function: similar to <tt>os.getcwd()</tt> but returns the
current working directory as <tt>bytes</tt>.</li>
<li>Support <tt>bytes</tt> paths:<ul>
<li><tt>fnmatch.filter()</tt></li>
<li><tt>glob.glob1()</tt></li>
<li><tt>glob.iglob()</tt></li>
<li><tt>open()</tt></li>
<li><tt>os.path.isabs()</tt></li>
<li><tt>os.path.issep()</tt></li>
<li><tt>os.path.join()</tt></li>
<li><tt>os.path.split()</tt></li>
<li><tt>os.path.splitext()</tt></li>
<li><tt>os.path.basename()</tt></li>
<li><tt>os.path.dirname()</tt></li>
<li><tt>os.path.splitdrive()</tt></li>
<li><tt>os.path.ismount()</tt></li>
<li><tt>os.path.expanduser()</tt></li>
<li><tt>os.path.expandvars()</tt></li>
<li><tt>os.path.normpath()</tt></li>
<li><tt>os.path.abspath()</tt></li>
<li><tt>os.path.realpath()</tt></li>
</ul>
</li>
</ul>
</div>
<div id="more-bytes-patches">
<h2>More bytes patches</h2>
<p>I looked if other functions accepted passing filenames as <tt>bytes</tt> and... I
was disappointed. It took me some years to fix the full Python standard
library. Example of issues between 2008 and 2010:</p>
<ul>
<li><a href="https://bugs.python.org/issue4035">bpo-4035</a>: Support bytes in <tt><span>os.exec*()</span></tt></li>
<li><a href="https://bugs.python.org/issue4036">bpo-4036</a>: Support bytes in <tt>subprocess.Popen()</tt></li>
<li><a href="https://bugs.python.org/issue8513">bpo-8513</a>: <tt>subprocess</tt>: support bytes program name (POSIX)</li>
<li><a href="https://bugs.python.org/issue8514">bpo-8514</a>: Add <tt>fsencode()</tt> functions to os module</li>
<li><a href="https://bugs.python.org/issue8603">bpo-8603</a>: Create a bytes version of <tt>os.environ</tt> and <tt>getenvb()</tt> -- Add <tt>os.environb</tt></li>
<li><a href="https://bugs.python.org/issue8412">bpo-8412</a>: <tt>os.system()</tt> doesn&#39;t support surrogates nor bytes</li>
<li><a href="https://bugs.python.org/issue8468">bpo-8468</a>: <tt>bz2</tt> module: support surrogates in filename, and bytes/bytearray filename</li>
<li><a href="https://bugs.python.org/issue8477">bpo-8477</a>: <tt>ssl</tt> module: support surrogates in filenames, and bytes/bytearray filenames</li>
<li><a href="https://bugs.python.org/issue8640">bpo-8640</a>: <tt>subprocess:</tt> canonicalize env to bytes on Unix (Python3)</li>
<li><a href="https://bugs.python.org/issue8776">bpo-8776</a>: Bytes version of <tt>sys.argv</tt> (REJECTED)</li>
</ul>
</div>
<div id="conclusion">
<h2>Conclusion</h2>
<p>At the first look, <strong>Helmut Jarausch</strong>&#39;s <tt>os.walk()</tt> bug looked trivial to
fix.</p>
<p>I proposed a <strong>new Filename class</strong> storing filenames as <tt>bytes</tt> and <tt>str</tt>,
but Guido van Rossum rejected the idea because this API complification
would <em>hinder most people</em>.</p>
<p>Guido van Rossum proposed to <strong>use the replace error handler</strong>, but decoded
filenames were not recognized by the operating system making them useless for
most cases.</p>
<p>I proposed to <strong>use callback to handle undecodable filenames</strong>, but Guido van
Rossum also rejected this idea because it was too complex and could be written
using os.listdir() with a bytes argument.</p>
<p>Benjamin Peterson proposed to <strong>emit a warning</strong> when a filename cannot be
decoded, but the idea was abandonned because of the warnings filters complexity
to emit the warning multiple times.</p>
<p>I wrote a big change modifying <tt>os.listdir()</tt> to ignore silently undecodable
filenames, but also modify a lot of functions to also accept filenames as
<tt>bytes</tt>.  I made further changes the following years to fix the full Python
standard library to accept <tt>bytes</tt>.</p>
<p>While it &#34;only&#34; took 4 months to fix the <tt>os.listdir(str)</tt> issue, <strong>this kind
of bugs will keep me busy the next 10 years</strong> (2008-2018)...</p>
<p><strong>This article is the first in a series of articles telling the history and
rationale of the Python 3 Unicode model for the operating system.</strong></p>
</div>
</div></div>
  </body>
</html>
