<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://cloud.google.com/blog/products/databases/alloydb-for-postgresql-columnar-engine">Original</a>
    <h1>AlloyDB for PostgreSQL under the hood: Columnar engine</h1>
    
    <div id="readability-page-1" class="page"><div><!----><!----><div><div><div><!----><!----><paragraph-block _nghost-c53=""><div _ngcontent-c53="" innerhtml="&lt;p&gt;Recently, at Google I/O, we &lt;a href=&#34;https://cloud.google.com/blog/products/databases/introducing-alloydb-for-postgresql&#34;&gt;announced AlloyDB for PostgreSQL&lt;/a&gt;, a fully-managed, PostgreSQL-compatible database for demanding, enterprise-grade transactional and analytical workloads. Imagine PostgreSQL plus the best of the cloud: elastic storage and compute, intelligent caching, and AI/ML-powered management. Further, AlloyDB delivers unmatched price-performance: In our performance tests, it&amp;#8217;s more than 4x faster on transactional workloads, and up to 100x faster on analytical queries than standard PostgreSQL, all with simple, predictable pricing. Designed for mission-critical applications, AlloyDB offers extensive data protection and an industry leading 99.99% availability SLA, inclusive of maintenance.&amp;#160;&lt;/p&gt;&lt;p&gt;Multiple innovations underpin the performance, and availability gains of AlloyDB for PostgreSQL. In the first part of our &amp;#8220;AlloyDB for PostgreSQL under the hood&#39;&#39; series, we discussed &lt;a href=&#34;https://cloud.google.com/blog/products/databases/alloydb-for-postgresql-intelligent-scalable-storage&#34;&gt;AlloyDB&amp;#8217;s intelligent storage layer&lt;/a&gt;, and today, we are covering AlloyDB&amp;#8217;s vectorized columnar execution engine, which enables analytical acceleration.&amp;#160;&lt;/p&gt;&lt;h3&gt;PostgreSQL and hybrid workload patterns&lt;/h3&gt;&lt;p&gt;General-purpose databases like PostgreSQL often support a wide variety of workloads. Some of those workloads are purely transactional in nature, and in the previous post, we discussed how our intelligent storage layer contributes to making AlloyDB more than 4x faster than standard PostgreSQL for such workloads based on our performance tests. However, PostgreSQL also has rich querying functionality that many users leverage both inside and outside of their applications. Analytical queries, i.e., queries involving scans, joins, and aggregations over a large amount of data, are a core part of many relational database workloads. These can include:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Queries within an application that serves end-users, for example: an ecommerce application that shows most popular products segmented by region based on recent sales across multiple properties&lt;/li&gt;&lt;li&gt;Real-time business insights for analysis that requires access to the most up-to-date data. For example: a recommendation engine in a retail application that shows suggested add-on purchases based on what the user has in their cart, the time of day, and historical purchase behavior&lt;/li&gt;&lt;li&gt;Ad-hoc querying, where a developer or user might need to query the database directly to answer a question, for example, running an audit on recent transactions for a regulator&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Tuning operational databases to perform well in these varying use cases can be difficult. Historically, users with these types of workloads have had to create indexes and optimize schemas to ensure sufficient query performance. This not only increases management complexity, but can also impact transactional performance. Slow query performance can also constrain what developers are able to deliver to their end users, and deter development of real-time business insights.&lt;/p&gt;&lt;p&gt;AlloyDB provides a better way. Powered by a columnar engine, AlloyDB performed up to 100x faster than standard PostgreSQL for analytical queries based on our performance tests, with no schema changes, application changes, or ETL required. This technology keeps frequently queried data in an in-memory, columnar format for faster scans, joins, and aggregations.&amp;#160;&lt;/p&gt;&lt;p&gt;The embedded machine learning in AlloyDB makes accessing this technology easier than ever. AlloyDB automatically organizes your data between row-based and columnar formats, choosing the right columns and tables based on learning your workload, and converting them to columnar format automatically. The query planner smartly chooses between columnar and row-based execution plans, so transactional performance is maintained. This allows AlloyDB to deliver excellent performance for a wide range of queries, with minimal management overhead.&lt;/p&gt;&lt;h3&gt;A refresher on column-oriented data representation&lt;/h3&gt;&lt;p&gt;Traditional databases are row-oriented and store data in fixed-sized blocks. This organization is optimal for access patterns that request information across a whole row, for example, when an application needs to look up information pertaining to a particular user. Row-oriented storage is optimized for these types of access patterns.&amp;#160;&lt;/p&gt;&lt;p&gt;Analytical queries require different access patterns. In order to answer analytical queries from a row-oriented data store, whole tables need to be scanned, reading through every column of every row, even though much of the data stored in the table is not relevant to answering the questions.&amp;#160;&lt;/p&gt;&lt;p&gt;Column-oriented data representation enables answering analytical questions faster, by keeping the values in a single column together. By focusing access to only the relevant columns, column-oriented databases can deliver faster responses to analytical queries.&lt;/p&gt;&lt;h3&gt;AlloyDB columnar engine&amp;#160;&lt;/h3&gt;&lt;p&gt;Google has a long history of innovation in large-scale data analytics, especially with services like BigQuery. These services offer fast, scalable query processing through the use of optimized, columnar data layouts, state-of-the-art query processing techniques, and hardware acceleration.&amp;#160;&lt;/p&gt;&lt;p&gt;AlloyDB embeds some of the same technological advancements directly into a PostgreSQL-compatible operational database. It combines a row-based format for transactional processing and storage with a columnar format and execution engine to provide the best of both worlds.&lt;/p&gt;&lt;p&gt;The columnar engine is a modern, vectorized query processing engine that efficiently processes chunks of columnar data by making optimal use of the system caches and vector processing instructions provided by today&#39;s CPUs.&lt;/p&gt;&lt;p&gt;Beyond leveraging the capabilities of modern hardware, the columnar engine includes several algorithmic optimizations to further speed up query processing. It makes use of column-specific metadata, such as minimum and maximum values, to speed up scans, and can perform other operations like aggregation directly on the relevant columns without materializing the results of a scan. Finally, hybrid execution combines both columnar and row-oriented query processing techniques where beneficial.&lt;/p&gt;&lt;h3&gt;Columnar data format&lt;/h3&gt;&lt;p&gt;The columnar engine intelligently determines the data format and metadata for each column; it learns from both the content of the column and the type of query operations that are executed. Learned metadata is used both to encode the data values efficiently and to accelerate query processing. For example, when a string column that has a small number of distinct values is used in filters, the columnar engine may decide to generate a list of the distinct values as metadata. This can then be used to accelerate both equality and range-based filters. As another example, the columnar engine may keep minimum and maximum values of a date column (for a given range of rows) as metadata; this may then be used to skip that range of rows when processing certain filters. In addition, the columnar engine may also use compression techniques to make efficient use of memory and speed up query processing.&amp;#160;&lt;/p&gt;&lt;h3&gt;Query acceleration&lt;/h3&gt;&lt;p&gt;The columnar engine transforms queries into a series of operations on columns and their metadata. Typically this involves first looking up the metadata to determine the most efficient type of operation to perform on an array of column values. These operations on column values, called vectorized operations, are designed to be executed using hardware-accelerated vectorized (SIMD) instructions that are available on modern CPUs.&lt;/p&gt;&lt;p&gt;The columnar engine can also perform table scan operations efficiently without fully materializing the result of the table scan; for example, if an aggregation operation needs to be performed after a table scan, it may use the result of evaluating the filters to directly perform vectorized aggregation operations on the relevant columns. Join operations are transparently accelerated using &lt;a href=&#34;https://en.wikipedia.org/wiki/Bloom_filter&#34; target=&#34;_blank&#34;&gt;bloom filters&lt;/a&gt;, depending on selectivity; this optimization uses the power of vectorized filtering to reduce the number of rows that need to be processed by the join operation.&lt;/p&gt;&lt;p&gt;Let&#39;s take a look at how some of these optimizations apply to a simple query involving a table scan based on a schema similar to the &lt;a href=&#34;https://en.wikipedia.org/wiki/Star_schema&#34; target=&#34;_blank&#34;&gt;Star Schema&lt;/a&gt; benchmark. This query scans the list of sales, filtering by shipping mode and date. The following figure illustrates how the table scan with two filters is executed. For the filter lo_shipmode = &amp;#8216;MAIL&amp;#8217;, the columnar engine first checks the column&amp;#8217;s metadata to see if the value &amp;#8216;MAIL&amp;#8217; is present in this dataset. If &amp;#8216;MAIL&amp;#8217; does occur, the columnar engine proceeds by searching using SIMD instructions. The resulting bitmap of passing rows is further filtered using the result set from the next filter.&amp;#160;&lt;/p&gt;&lt;p&gt;Alternatively, if the value &amp;#8216;MAIL&amp;#8217; had not occured in the column metadata, the columnar engine could have skipped searching a large number of values. Similarly, the columnar engine may also use min/max metadata on the lo_quantity column to skip some rows based on the range filter on that column.&lt;/p&gt;"><p>Recently, at Google I/O, we <a href="https://cloud.google.com/blog/products/databases/introducing-alloydb-for-postgresql" track-type="inline link" track-name="1" track-metadata-eventdetail="https://cloud.google.com/blog/products/databases/introducing-alloydb-for-postgresql" track-metadata-module="post">announced AlloyDB for PostgreSQL</a>, a fully-managed, PostgreSQL-compatible database for demanding, enterprise-grade transactional and analytical workloads. Imagine PostgreSQL plus the best of the cloud: elastic storage and compute, intelligent caching, and AI/ML-powered management. Further, AlloyDB delivers unmatched price-performance: In our performance tests, it’s more than 4x faster on transactional workloads, and up to 100x faster on analytical queries than standard PostgreSQL, all with simple, predictable pricing. Designed for mission-critical applications, AlloyDB offers extensive data protection and an industry leading 99.99% availability SLA, inclusive of maintenance. </p><p>Multiple innovations underpin the performance, and availability gains of AlloyDB for PostgreSQL. In the first part of our “AlloyDB for PostgreSQL under the hood&#39;&#39; series, we discussed <a href="https://cloud.google.com/blog/products/databases/alloydb-for-postgresql-intelligent-scalable-storage" track-type="inline link" track-name="2" track-metadata-eventdetail="https://cloud.google.com/blog/products/databases/alloydb-for-postgresql-intelligent-scalable-storage" track-metadata-module="post">AlloyDB’s intelligent storage layer</a>, and today, we are covering AlloyDB’s vectorized columnar execution engine, which enables analytical acceleration. </p><h3>PostgreSQL and hybrid workload patterns</h3><p>General-purpose databases like PostgreSQL often support a wide variety of workloads. Some of those workloads are purely transactional in nature, and in the previous post, we discussed how our intelligent storage layer contributes to making AlloyDB more than 4x faster than standard PostgreSQL for such workloads based on our performance tests. However, PostgreSQL also has rich querying functionality that many users leverage both inside and outside of their applications. Analytical queries, i.e., queries involving scans, joins, and aggregations over a large amount of data, are a core part of many relational database workloads. These can include:</p><ul><li>Queries within an application that serves end-users, for example: an ecommerce application that shows most popular products segmented by region based on recent sales across multiple properties</li><li>Real-time business insights for analysis that requires access to the most up-to-date data. For example: a recommendation engine in a retail application that shows suggested add-on purchases based on what the user has in their cart, the time of day, and historical purchase behavior</li><li>Ad-hoc querying, where a developer or user might need to query the database directly to answer a question, for example, running an audit on recent transactions for a regulator</li></ul><p>Tuning operational databases to perform well in these varying use cases can be difficult. Historically, users with these types of workloads have had to create indexes and optimize schemas to ensure sufficient query performance. This not only increases management complexity, but can also impact transactional performance. Slow query performance can also constrain what developers are able to deliver to their end users, and deter development of real-time business insights.</p><p>AlloyDB provides a better way. Powered by a columnar engine, AlloyDB performed up to 100x faster than standard PostgreSQL for analytical queries based on our performance tests, with no schema changes, application changes, or ETL required. This technology keeps frequently queried data in an in-memory, columnar format for faster scans, joins, and aggregations. </p><p>The embedded machine learning in AlloyDB makes accessing this technology easier than ever. AlloyDB automatically organizes your data between row-based and columnar formats, choosing the right columns and tables based on learning your workload, and converting them to columnar format automatically. The query planner smartly chooses between columnar and row-based execution plans, so transactional performance is maintained. This allows AlloyDB to deliver excellent performance for a wide range of queries, with minimal management overhead.</p><h3>A refresher on column-oriented data representation</h3><p>Traditional databases are row-oriented and store data in fixed-sized blocks. This organization is optimal for access patterns that request information across a whole row, for example, when an application needs to look up information pertaining to a particular user. Row-oriented storage is optimized for these types of access patterns. </p><p>Analytical queries require different access patterns. In order to answer analytical queries from a row-oriented data store, whole tables need to be scanned, reading through every column of every row, even though much of the data stored in the table is not relevant to answering the questions. </p><p>Column-oriented data representation enables answering analytical questions faster, by keeping the values in a single column together. By focusing access to only the relevant columns, column-oriented databases can deliver faster responses to analytical queries.</p><h3>AlloyDB columnar engine </h3><p>Google has a long history of innovation in large-scale data analytics, especially with services like BigQuery. These services offer fast, scalable query processing through the use of optimized, columnar data layouts, state-of-the-art query processing techniques, and hardware acceleration. </p><p>AlloyDB embeds some of the same technological advancements directly into a PostgreSQL-compatible operational database. It combines a row-based format for transactional processing and storage with a columnar format and execution engine to provide the best of both worlds.</p><p>The columnar engine is a modern, vectorized query processing engine that efficiently processes chunks of columnar data by making optimal use of the system caches and vector processing instructions provided by today&#39;s CPUs.</p><p>Beyond leveraging the capabilities of modern hardware, the columnar engine includes several algorithmic optimizations to further speed up query processing. It makes use of column-specific metadata, such as minimum and maximum values, to speed up scans, and can perform other operations like aggregation directly on the relevant columns without materializing the results of a scan. Finally, hybrid execution combines both columnar and row-oriented query processing techniques where beneficial.</p><h3>Columnar data format</h3><p>The columnar engine intelligently determines the data format and metadata for each column; it learns from both the content of the column and the type of query operations that are executed. Learned metadata is used both to encode the data values efficiently and to accelerate query processing. For example, when a string column that has a small number of distinct values is used in filters, the columnar engine may decide to generate a list of the distinct values as metadata. This can then be used to accelerate both equality and range-based filters. As another example, the columnar engine may keep minimum and maximum values of a date column (for a given range of rows) as metadata; this may then be used to skip that range of rows when processing certain filters. In addition, the columnar engine may also use compression techniques to make efficient use of memory and speed up query processing. </p><h3>Query acceleration</h3><p>The columnar engine transforms queries into a series of operations on columns and their metadata. Typically this involves first looking up the metadata to determine the most efficient type of operation to perform on an array of column values. These operations on column values, called vectorized operations, are designed to be executed using hardware-accelerated vectorized (SIMD) instructions that are available on modern CPUs.</p><p>The columnar engine can also perform table scan operations efficiently without fully materializing the result of the table scan; for example, if an aggregation operation needs to be performed after a table scan, it may use the result of evaluating the filters to directly perform vectorized aggregation operations on the relevant columns. Join operations are transparently accelerated using <a href="https://en.wikipedia.org/wiki/Bloom_filter" target="_blank" track-type="inline link" track-name="3" track-metadata-eventdetail="https://en.wikipedia.org" track-metadata-module="post">bloom filters</a>, depending on selectivity; this optimization uses the power of vectorized filtering to reduce the number of rows that need to be processed by the join operation.</p><p>Let&#39;s take a look at how some of these optimizations apply to a simple query involving a table scan based on a schema similar to the <a href="https://en.wikipedia.org/wiki/Star_schema" target="_blank" track-type="inline link" track-name="4" track-metadata-eventdetail="https://en.wikipedia.org" track-metadata-module="post">Star Schema</a> benchmark. This query scans the list of sales, filtering by shipping mode and date. The following figure illustrates how the table scan with two filters is executed. For the filter lo_shipmode = ‘MAIL’, the columnar engine first checks the column’s metadata to see if the value ‘MAIL’ is present in this dataset. If ‘MAIL’ does occur, the columnar engine proceeds by searching using SIMD instructions. The resulting bitmap of passing rows is further filtered using the result set from the next filter. </p><p>Alternatively, if the value ‘MAIL’ had not occured in the column metadata, the columnar engine could have skipped searching a large number of values. Similarly, the columnar engine may also use min/max metadata on the lo_quantity column to skip some rows based on the range filter on that column.</p></div></paragraph-block><!----><!----><!----></div></div></div><!----><!----><!----><!----><!----><!----><!----></div></div>
  </body>
</html>
