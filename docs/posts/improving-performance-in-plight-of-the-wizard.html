<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.winstoncooke.com/blog/improving-performance-in-plight-of-the-wizard">Original</a>
    <h1>Improving Performance in Plight of the Wizard</h1>
    
    <div id="readability-page-1" class="page"><article><div><p><time datetime="2024-08-26">2024-08-26</time></p><p data-svelte-h="svelte-kuep5d">I wrote most of the core code for <em>Plight of the Wizard</em> during a four-day game jam at <a href="https://www.recurse.com/" rel="nofollow">Recurse Center</a>.
The game was perfectly performant at that time given the limited scope.
However, I have made a lot of changes to the game since my last blog post, and a lot of my initial code did not scale very well at all.
The biggest change I made was implementing a camera to allow the player to explore a larger map size beyond the Playdate’s 400x240 screen.</p> <p><a href="https://imagedelivery.net/ga2MLDZ3d0ln9C7Qw_eDwg/7db6c760-56e6-405d-c9e0-4f115abefe00/gallery"><img loading="lazy" src="https://imagedelivery.net/ga2MLDZ3d0ln9C7Qw_eDwg/7db6c760-56e6-405d-c9e0-4f115abefe00/public" alt="The game&#39;s&#39; camera system that allows the player to move around a map beyond the screen." title="Plight of the Wizard - Camera"/></a></p> <p data-svelte-h="svelte-160ygpa">This change was really exciting to implement because it meant that I could now do a lot more with my game.
However, it revealed all the assumptions I had made about the gameplay being confined to the screen size no longer held up.
First, the gameplay was immediately less fun, which meant that numerous gameplay elements needed to be added or tweaked.
Second, the performance took a massive hit.
Constantly moving around the screen means that everything has to be redrawn, which has massive performance implications.</p> <h2 data-svelte-h="svelte-hzj91g">UI</h2> <p data-svelte-h="svelte-14xce5t">The first problem was that the score in the upper left had been hardcoded and was in the physical space.
For the game jam, I quickly gave it a collision box to avoid enemies from walking over it.
With a camera system, the score was physically in the upper left corner of the map.
This was easily fixed by setting the text to ignore the camera offset and applying a z-index to always place it on the top of screen.
I went ahead and also added a black rectangle across the top of the screen that the score sits on to prevent sprites from overlapping with the text, which would make it hard to read.</p> <h2 data-svelte-h="svelte-cbwgqf">Redrawing sprites</h2> <p data-svelte-h="svelte-nz4939">The next issue I faced was related to my grass sprites.
My initial approach was creating an algorithm to randomly place grass sprites around the map.
This worked fine when the game was bound within the screen, but I learned the hard way that redrawing the individual sprites is extremely CPU-intensive on the Playdate.
After a large amount of enemies had spawned, the fps would drop from a stable 30 down to an excruciatingly slow 5 fps when the player moved around the map.</p> <p data-svelte-h="svelte-8mzpjz">I noticed that the performance dip only occurred when the player moved around the center of the map.
When the player hits the edges of the map, the camera locks into place and stops following the player.
Combining this revelation with the observation that fps was stable while the player wasn’t moving, I discovered that the issue was due to redrawing all of the individual sprites.
While I couldn’t avoid redrawing the sprites for the player and enemies that moved around and could spawn and despawn, grass was purely a background element.</p> <p data-svelte-h="svelte-j7gzph">I thought my initial approach would work fine because I could see on the screen that the black background was not being redrawn as I moved.
However, once I converted the grass into a tilemap, the fps issues stopped, despite the Playdate simulator now showing the entire background was being redrawn.
It seems that the Playdate SDK optimizes for tilemaps when drawing the background.
Switching to this approach led to major performance gains.</p> <h2 data-svelte-h="svelte-j5bp02">Entity spawning</h2> <p data-svelte-h="svelte-12psnxe">The next issue I faced with my new camera system was my logic for spawning entities such as enemies or items to pick up.
This broke down into two separate issues stemming from the same root problem, which was determining where to spawn entities.
There are a dozen ways to solve this problem, but I chose to stick with what I had done the first time around, which was to find a solution that works well enough to solve the problem so I can focus on other gameplay elements I still need to implement.
My new system is significantly simplified and involves two elements: collision detection and spawning entities off-screen.</p> <h3 data-svelte-h="svelte-1qqawnb">Collision detection</h3> <p data-svelte-h="svelte-1l38te3">The first thing I tackled was a low-hanging fruit I had long been aware needed to be improved.
My system for spawning objects used a <code>repeat...until</code> loop, which chose random <em>x</em> and <em>y</em> coordinates on the map, checked if those coordinates were occupied, and selected new random coordinates if so.
Each time an entity was successfully spawned, I added its ID to a hash map with a reference to its live coordinates.
Whenever I wanted to spawn a new entity, I would iterate through the entire map and check each of the occupied positions.
This logic could run forever in theory since it kept repeating execution until it found an available space.
With a larger map to explore, more entities needed to be spawned to fill up the space, and this system become far too slow.</p> <p data-svelte-h="svelte-1y7o4us">My new method simply chooses random coordinates, checks for collisions in that position and its surrounding area, and abandons the spawn if there is a collision.
This uses the built-in collision detection in the SDK, which I’m making the naive assumption is fairly optimized.
So far this seems to work really well and is very easy to read in my code.
However, I didn’t want to spawn enemies on the screen, and I realized if I spawn them off of the screen, when the enemies naturally move towards the player, the off-screen positions free up.</p> <h3 data-svelte-h="svelte-k61d2k">Spawning entities off-screen</h3> <p data-svelte-h="svelte-7j5zzp">By moving spawning off-screen, this reduced the frequency of spawn collisions, which made spawning much easier to perform.
This also had the added benefit of leading to better gameplay.
Now my primary concern is if the enemy will spawn on environmental items such as trees, and I no longer have to worry about spawning on top of the player or any items on screen that can be picked up.</p> <p data-svelte-h="svelte-ggb5ow">However, I ran into an issue, which was how do I determine the location of the screen as I move around the map?
My first approach was to use the camera’s current bounds.
This involved calling for the camera’s current left, right, top, and bottom positions whenever an entity needed to be spawned.
This worked fine at first but led to some major performance issues once the game filled up with enemies spawning.
The amount of calculations for determining the camera position and randomly choosing coordinates when spawning enemies every half-second adds up.
But if I weren’t moving around, the camera position would be unchanged, so why bother constantly recalculating its position?</p> <h3 data-svelte-h="svelte-1tg8f34">Caching available spawn coordinates</h3> <p data-svelte-h="svelte-jho3jn">A eureka moment regarding available spawn points came to me while I was in the shower.
I could cache the camera’s bounds. That way if the player isn’t moving, the function for choosing random coordinates based on the camera bounds would have one less step to perform.
Taking it one step further, I realized that I would only have to update the camera’s position in the cache if the camera has moved by the distance that the enemy spawns away from the screen.
So if the enemy spawns 32 pixels to the left or right of the camera, then I only need to update the camera’s left and right positions when the player has moved 32 pixels horizontally.
Next, I realized that this meant the top and bottom camera positions didn’t need to change while the player was only moving horizontally.
I can cache the horizontal and vertical positions separately and only updated them as-needed when the player moves far enough in a specific direction.</p> <h2 data-svelte-h="svelte-s6ksa4">Results</h2> <p data-svelte-h="svelte-1a5qf3c">Implementing the new spawning technique alongside the cache improved mid-game performance from previously having occasional dips to 15 fps to now maintaining a stable 30 fps.
My game is essentially the worst-case type of game for the Playdate and its screen since it requires constantly redrawing elements everywhere.
But that doesn’t mean that I can’t solve various issues!
All I need is a bit of targeted logic and the attitude to learn as I go while being fine with constantly refactoring my code to implement what I’ve learned.</p> <h2 data-svelte-h="svelte-16o06a2">Other updates</h2> <p data-svelte-h="svelte-1e3ctvt">I’ve made a few gameplay changes since my last blog post that I want to highlight while I’m writing this post.</p> <h3 data-svelte-h="svelte-wgs9gs">Camera lerping</h3> <p><a href="https://imagedelivery.net/ga2MLDZ3d0ln9C7Qw_eDwg/76ba4565-d675-43cc-5ac9-d2bc03a9e500/gallery"><img loading="lazy" src="https://imagedelivery.net/ga2MLDZ3d0ln9C7Qw_eDwg/76ba4565-d675-43cc-5ac9-d2bc03a9e500/public" alt="The camera moving smoothly from the center of the screen to center on the player." title="Plight of the Wizard - Camera lerping"/></a></p> <p data-svelte-h="svelte-m0q0gf">I implemented <a href="https://en.wikipedia.org/wiki/Linear_interpolation" rel="nofollow">lerping</a> using the <a href="https://en.wikipedia.org/wiki/Smoothstep" rel="nofollow">smoothstep</a> algorithm.
This kicks in when the player first kills the tutorial zombie to provide a sort of “aha” moment and slowly reveal that there is a larger map to explore beyond the small screen.
I plan to also use this to snap the camera back on bosses that spawn and constrict the player’s movement to the screen again until the boss has been defeated.</p> <h3 data-svelte-h="svelte-1dti252">Lightning spell</h3> <p><a href="https://imagedelivery.net/ga2MLDZ3d0ln9C7Qw_eDwg/3e9433c5-196e-4188-acf8-e9980108ba00/gallery"><img loading="lazy" src="https://imagedelivery.net/ga2MLDZ3d0ln9C7Qw_eDwg/3e9433c5-196e-4188-acf8-e9980108ba00/public" alt="The lightning spell firing a spread like a shotgun, which knocks back the enemies struck." title="Plight of the Wizard - Lightning spell"/></a></p> <p data-svelte-h="svelte-1p3o1jc">Only having one spell was growing to be boring, so I added a new lightning spell that works similarly to a shotgun.
It fires 3 lightning bolts in a spread.
As the cast spell travels further, the bolts inflict less damage and have a lessened knockback effect on enemies.
This is best used up close with riskier tactics.</p> <h3 data-svelte-h="svelte-cvfcyz">Item despawning</h3> <p><a href="https://imagedelivery.net/ga2MLDZ3d0ln9C7Qw_eDwg/6b8b1d45-6878-4f97-6188-a06445fba700/gallery"><img loading="lazy" src="https://imagedelivery.net/ga2MLDZ3d0ln9C7Qw_eDwg/6b8b1d45-6878-4f97-6188-a06445fba700/public" alt="The lightning spell pickup flashing in and out as it despawns." title="Plight of the Wizard - Item despawning"/></a></p> <p data-svelte-h="svelte-1ddc42c">Finally, it felt wrong that items remained on the map forever, so I updated them to despawn after a certain amount of time.
This helps add a sense of urgency for the player to pick them up while also potentially helping the player if the item spawns again in a more favorable location when the player is pinned on one side of the map.</p></div></article></div>
  </body>
</html>
