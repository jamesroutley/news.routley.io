<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://openjdk.org/jeps/8300786">Original</a>
    <h1>JEP draft: No longer require super() and this() to appear first in a constructor</h1>
    
    <div id="readability-page-1" class="page"><div><h2 id="Summary">Summary</h2>
<p>No longer require <code>super()</code> and <code>this()</code> to appear first in a constructor.</p>
<h2 id="Goals">Goals</h2>
<p>Change the Java Language Specification and make corresponding changes to the Java compiler so that:</p>
<ul>
<li><code>super()</code> and <code>this()</code> no longer must appear as the first statement in a constructor</li>
<li>The language preserves existing safety and initialization guarantees afforded to constructors</li>
<li>Existing programs continue to compile and function as they did before</li>
</ul>
<h2 id="Non-Goals">Non-Goals</h2>
<p><strong>Modifications to the JVM.</strong> These changes may prompt reconsideration of the JVM&#39;s current restrictions on constructors, however, in order to avoid unnecessary linkage between JLS and JVM changes, any such modifications should be proposed in a follow-on JEP. This JEP assumes no change to the current JVM behavior.</p>
<p><strong>Changes to current behavior.</strong> There is no intention to change the behavior of any program that adheres to the current JLS.</p>
<p><strong>Addressing larger language concerns.</strong> Thinking about the interplay between superclass constructors and subclass initialization has evolved since the Java language was first designed. This work should be considered a pragmatic tweak rather than a statement on language design.</p>
<h2 id="Motivation">Motivation</h2>
<p>Currently, the Java language requires that invocations of <code>this()</code> or <code>super()</code> appear as the first statement in a constructor.</p>
<p>However, the Java Virtual Machine actually allows more flexibility:</p>
<ul>
<li>Multiple invocations of <code>this()</code> and/or <code>super()</code> may appear in a constructor, as long as on any code path there is exactly one invocation</li>
<li>Arbitrary code may appear before <code>this()</code>/<code>super()</code>, as long as that code doesn&#39;t reference the instance under construction, with an exception carved out for field assignments</li>
<li>However, invocations of <code>this()</code>/<code>super()</code> may not appear within a <code>try { }</code> block (i.e., within a bytecode exception range)</li>
</ul>
<p>Note that these more permissive rules do not cause any reduction in existing safety guarantees regarding proper initialization: (a) the uninitialized instance is still &#34;off limits&#34;, except for field assignments (which do not affect outcomes), until superclass initialization is performed, and (b) superclass initialization always happens exactly once, either directly via <code>super()</code> or indirectly via <code>this()</code>.</p>
<p>So a basic motivation is simply that the JLS is being needlessly restrictive. In fact, this inconsistency is a historical artifact: the original JVM specification was more restrictive also, however, this led to issues with initialization of synthetic fields generated by the compiler to support new language features such as inner classes and captured free variables. As as result, the JVM specification was relaxed to accommodate the compiler, but this new flexibility never made its way back up to the language level.</p>
<p>There is also a practical motivation, which is that it&#39;s often convenient to be able to do &#34;housekeeping&#34; before invoking <code>super()</code> or <code>this()</code>.</p>
<p>Here&#39;s a somewhat contrived example:</p>
<pre><code>import java.math.*;

public class BigPositiveValue extends BigInteger {

    /**
     * Constructor taking a {@code long} value.
     *
     * @param value value, must be one or greater
     */
    public BigPositiveValue(long value) {
        if (value &lt; 1)
            throw new IllegalArgumentException(&#34;non-positive value&#34;);
        super(String.valueOf(value));
    }

    /**
     * Constructor taking a base and exponent. Negative exponents are clipped to zero.
     *
     * @param base base
     * @param power exponent
     */
    public BigPositiveValue(int base, float power) {
        if (base &lt; 2)
            throw new IllegalArgumentException(&#34;invalid base&#34;);
        if (!Float.isFinite(power))
            throw new IllegalArgumentException(&#34;invalid power&#34;);
        if (power &lt;= 0)      // clip negative exponents to zero
            super(&#34;1&#34;);
        else
            this(Math.round(Math.pow(base, power)));
    }
}</code></pre>
<p>Another reason is to provide a way to avoid bugs caused by a &#39;this&#39; escape in a superclass constructor. A &#39;this&#39; escape is when a superclass constructor does something that could cause a subclass method to be invoked before the superclass constructor returns; in such cases the subclass method would operate on an incompletely initialized instance.</p>
<p>For example, consider this class:</p>
<pre><code>import java.util.*;
import java.util.function.*;

/**
 * A {@link Set} that rejects elements not accepted by the configured {@link Predicate}.
 */
public class FilteredSet&lt;E&gt; extends HashSet&lt;E&gt; {

    private final Predicate&lt;? super E&gt; filter;

    public FilteredSet(Predicate&lt;? super E&gt; filter, Collection&lt;? extends E&gt; elems) {
        super(elems);
        this.filter = filter;
    }

    @Override
    public boolean add(E elem) {
        if (!this.filter.test(elem))
            throw new IllegalArgumentException(&#34;disallowed element&#34;);
        return super.add(elem);
    }

    public static void main(String[] args) {
        new FilteredSet&lt;&gt;(s -&gt; true, Arrays.asList(&#34;abc&#34;, &#34;def&#34;));   // NullPointerException
    }
}</code></pre>
<p>It appears bug-free, but actually it throws a <code>NullPointerException</code>. The reason is not apparent until you realize that the <code>HashSet(Collection)</code> constructor invokes <code>AbstractCollection.addAll()</code>, which invokes <code>add()</code>, which as overridden in <code>FilteredSet</code> dereferences <code>this.filter</code> before that field is initialized. In other words, the bug results from the trap laid by the &#39;this&#39; escape in the <code>HashSet(Collection)</code> constructor.</p>
<p>Moreover, there&#39;s no simple way for the <code>FilteredSet</code> constructor to work around that trap. But the problem could be easily avoided if the constructor could simply do this:</p>
<pre><code>public FilteredSet(Predicate&lt;? super E&gt; filter, Collection&lt;? extends E&gt; elems) {
    this.filter = filter;
    super(elems);
}</code></pre>
<p>Even if there is no &#39;this&#39; escape in a superclass, this is a fact that&#39;s not going to be obvious to a developer, because it requires recursive inspection of each superclass constructor&#39;s code. Moreover, &#39;this&#39; escape behavior in constructors is rarely part of their documented behavior (either way), and so is subject to change; it&#39;s unwise to rely on some other class&#39; unspecified implementation details for correct code. By initializing fields prior to superclass initialization, developers can confidently dismiss any concerns about superclass &#39;this&#39; escapes.</p>
<h2 id="Description">Description</h2>
<h2 id="Language-Changes">Language Changes</h2>
<p>The JLS will be modified as follows:</p>
<ul>
<li>Remove the requirement that <code>super()</code> or <code>this()</code> appear as the first statement in a constructor</li>
<li>Add the requirement that, in any constructor with explicit <code>super()</code> and/or <code>this()</code> invocations, either <code>super()</code> or <code>this()</code> must be invoked exactly once (assuming the constructor returns normally). This may be specified economically by stating that the compiler treats superclass initialization like a non-static blank final field.</li>
<li>Add the requirement that no access to the new instance in a constructor, other than assignments to fields, may occur prior to an invocation of <code>super()</code> or <code>this()</code></li>
<li>Add the requirement that <code>super()</code> and <code>this()</code> may not appear within any <code>try { }</code> block</li>
<li>Specify that non-static field initializers and initialization blocks are executed immediately after <code>super()</code> invocation, wherever it occurs</li>
</ul>
<p>Note: there is no change to the implicit addition of <code>super()</code> at the beginning of any constructor having no explicit <code>super()</code> or <code>this()</code> invocation.</p>
<h3 id="try-{-}-Blocks"><code>try { }</code> Blocks</h3>
<p>The restriction that <code>super()</code> and <code>this()</code> may not appear inside a <code>try { }</code> block comes from the JVM itself, and is due to how StackMaps are represented. The logic is that when a superclass constructor throws an exception, the new instance on the stack is neither fully uninitialized nor fully initialized, so it should be considered unusable, and therefore such a constructor must never return. However, the JVM doesn&#39;t allow the bytecode to discard the unusable instance and throw another exception; instead, it doesn&#39;t allow it to exist on the stack at all. The net effect is that constructors can&#39;t catch exceptions thrown by superclass initialization, even if rethrown.</p>
<h3 id="Initialization-Order">Initialization Order</h3>
<p>The JLS specifies that field initializers and initialization blocks execute after superclass initialization via <code>super()</code>. So this class:</p>
<pre><code>class Test1 {
    final int x;
    {
        x = 123;
    }
    public Test1() {
        super();
        this.x = 456;
    }
}</code></pre>
<p>generates this error:</p>
<pre><code>Test1.java:8: error: variable x might already have been assigned
        this.x = 456;
            ^</code></pre>
<p>However, now that <code>super()</code> can appear anywhere in a constructor, an assignment in an initializer block can now happen after an earlier assignment in a constructor. So this class:</p>
<pre><code>class Test1 {
    final int x;
    {
        x = 123;
    }
    public Test1() {
        this.x = 456;
        super();
    }
}</code></pre>
<p>will now generate this error:</p>
<pre><code>Test1.java:4: error: variable x might already have been assigned
        x = 123;
        ^</code></pre>
<p>As before, initializers and initialization blocks happen immediately after superclass initialization, which happens when <code>super()</code> is invoked. But now this can be anywhere in the constructor.</p>
<p>One might ask why not move initializers and initialization blocks to the start of every constructor, but that doesn&#39;t work. First, they could have early references (e.g., by invoking an instance method), and second, the constructor might invoke <code>this()</code> and <code>super()</code> on different code branches, so you&#39;d be executing the initialization twice in the <code>this()</code> case.</p>
<h3 id="Records">Records</h3>
<p>Record constructors are subject to more restrictions that normal constructors. In particular:</p>
<ul>
<li>Canonical record constructors may not contain any explicit <code>super()</code> or <code>this()</code> invocation</li>
<li>Non-canonical record constructors may invoke <code>this()</code>, but not <code>super()</code></li>
</ul>
<p>These restrictions remain in place, but otherwise record constructors benefit from these changes. The net change is that non-canonical record constructors can now invoke <code>this()</code> multiple times, as long as it is invoked exactly once along any code path.</p>
<h2 id="Compiler-Changes">Compiler Changes</h2>
<p>All constructors except <code>java.lang.Object()</code> must initialize their superclass. Currently, there are three options for superclass initialization:</p>
<ol>
<li>Invoke <code>super()</code> as the first statement</li>
<li>Invoke <code>this()</code> as the first statement</li>
<li>Do not invoke <code>super()</code> or <code>this()</code> â†’ the compiler adds a <code>super()</code> for you</li>
</ol>
<p>In the compiler, constructors are currently divided into two categories:</p>
<ol>
<li><em>Initial</em> constructors invoke <code>super()</code> (either explicitly or implicitly)</li>
<li><em>Non-inital</em> constructors invoke <code>this()</code></li>
</ol>
<p>In the current code, non-initial constructors are treated almost the same as normal methods, because once <code>this()</code> is invoked at the start of the constructor, the object is fully initialized. Initial constructors, however, must be more closely watched to insure final fields are initialized correctly. Initial constructors also must be modified during compilation to execute any non-static field initializers and initialization blocks. All constructors are modified to handle non-static nested class references to outer instances, and free variable proxies.</p>
<p>Overall, the following &#34;syntactic sugar&#34; adjustments are applied to constructors during compilation:</p>
<ol>
<li>If the constructor doesn&#39;t invoke <code>this()</code> or <code>super()</code>, an initial <code>super()</code> invocation is inserted</li>
<li>If the class has non-static fields initializers or initialization blocks:
<ol>
<li>Code is added after <code>super()</code> invocations to initialize fields and run initialization blocks</li>
</ol>
</li>
<li>If the class has an outer instance:
<ol>
<li>A synthetic <code>this$0</code> field is added to the class</li>
<li>Constructors have an extra parameter prepended to carry it</li>
<li>Code is added prior to <code>super()</code> invocations to initialize <code>this$0</code> from the new parameter</li>
</ol>
</li>
<li>If the class has proxies for free variables:
<ol>
<li>Synthetic <code>val$x</code> fields are added to the class</li>
<li>Constructors have extra parameters appended</li>
<li>Code is added prior to <code>super()</code> invocations to initialize each <code>val$x</code> from its new parameter</li>
</ol>
</li>
</ol>
<p>By initializing <code>this$0</code> and <code>val$x</code> fields before invoking <code>super()</code>, the compiler is already taking advantage of the looser JVM requirements for its own purposes. A side effect is that this alternate version of <code>FilteredSet</code> works fine:</p>
<pre><code>import java.util.*;
import java.util.function.*;

public class FilteredSet {

    public static &lt;E&gt; Set&lt;E&gt; create(Predicate&lt;? super E&gt; filter, Collection&lt;? extends E&gt; elems) {
        return new HashSet&lt;E&gt;(elems) {
            @Override
            public boolean add(E elem) {
                if (!filter.test(elem))
                    throw new IllegalArgumentException(&#34;disallowed element&#34;);
                return super.add(elem);
            }
        };
    }

    public static void main(String[] args) {
        FilteredSet.create(s -&gt; true, Arrays.asList(&#34;abc&#34;, &#34;def&#34;));   // works!
    }
}</code></pre>
<h3 id="Compiler-Change-Overview">Compiler Change Overview</h3>
<p>This change impacts a few different areas of the compiler. In all cases, existing classes should compile the same way as they did before; we are strictly expanding the set of accepted source inputs.</p>
<p>At a high level, here&#39;s what changes in the compiler:</p>
<ol>
<li>Relax checks so that <code>this()</code>/<code>super()</code> may appear anywhere in constructors except for <code>try { }</code> blocks</li>
<li>Add DA/DU analysis for superclass initialization</li>
<li>Add checks to disallow early <code>this</code> references, except for field assignments</li>
<li>Refactor/replace any code that currently assumes <code>this()</code>/<code>super()</code> is always first in constructors</li>
</ol>
<h3 id="Changes-to-Specific-Files">Changes to Specific Files</h3>
<p>Below are per-file descriptions of the changes being made.</p>
<h3 id="comp/Attr-java"><code>comp/Attr.java</code></h3>
<p>The check that <code>super()</code>/<code>this()</code> is the first statement of a constructor is relaxed to just check that <code>super()</code>/<code>this()</code> occurs within a constructor.</p>
<p>Non-canonical record constructors may now invoke <code>this()</code> more than once on different code branches, but (as before) they must invoke <code>this()</code> exactly once and they must not ever invoke <code>super()</code>.</p>
<h3 id="comp/Check-java"><code>comp/Check.java</code></h3>
<p>The check for recursive constructor invocation is adjusted to handle the fact that a constructor may invoke more than one other constructor, i.e., the invocation call graph is now one-to-many instead of one-to-one.</p>
<h3 id="comp/Flow-java"><code>comp/Flow.java</code></h3>
<p><code>Flow.FlowAnalyzer</code> checks for uncaught checked exceptions. For initializer blocks, this was previously done by requiring that any checked exceptions thrown be declared as thrown by all initial constructors. This list of checked exceptions is pre-calculated before recursing into the initial constructors. This works because initializer blocks are executed at the beginning of each initial constructor right after <code>super()</code> is called.</p>
<p>In the new version of <code>FlowAnalyzer</code>, initializer blocks are traversed in the flow analysis after each <code>super()</code> invocation, reflecting what actually will happen at runtime (see below), and the pre-calculation is removed. The effect is the same as before, namely, any checked exceptions thrown by initializer blocks must be declared as thrown by all constructors that invoke <code>super()</code>.</p>
<p><code>Flow.AssignAnalyzer</code> is responsible for DA/DU analysis for fields and variables. We piggy-back on the existing machinery for tracking assignments to final instance fields to track superclass initialization, which acts like an assignment to a blank final field, in that it must happen exactly once in each constructor no matter what code branch is taken. To do this we allocate an additional bit in the existing DA/DU bitmaps, and for the most part the existing machinery takes care of the rest.</p>
<p>Previously, the code worked as follows:</p>
<ol>
<li>For initial constructors:
<ol>
<li>Assume final fields with initializers or assigned within initialization blocks start out DA.
<ol>
<li>Note: This is an optimization based on the assumption that <code>super()</code> is always first and then followed by initializers</li>
</ol>
</li>
<li>Assume all blank final fields start out DU.</li>
<li>Upon seeing an assignment to a blank final field:
<ol>
<li>Before, the blank final field must be DU</li>
<li>After, the blank final field is DA</li>
</ol>
</li>
<li>Require all final fields to be DA on any return.</li>
</ol>
</li>
<li>For non-initial constructors, don&#39;t do DA/DU analysis for fields (i.e., treat non-initial constructors like a normal method)
<ol>
<li>Note: This is another optimization, based on the assumption that <code>this()</code> is always first</li>
</ol>
</li>
</ol>
<p>Now that <code>super()</code> and <code>this()</code> can appear anywhere in constructors, there is no longer such a thing as an &#34;initial&#34; constructor. The new code works as follows:</p>
<ol>
<li>For all constructors:
<ol>
<li>Assume all final fields start out DU.</li>
<li>Upon seeing an assignment to a blank final field:
<ol>
<li>Before, the blank final field must be DU</li>
<li>After, the blank final field is DA</li>
</ol>
</li>
<li>Upon seeing <code>super()</code>:
<ol>
<li>Superclass initialization must be DU</li>
<li>Mark superclass initialization as DA</li>
<li>Recurse on initializers and initialization blocks normally to process field assignments therein</li>
</ol>
</li>
<li>Upon seeing <code>this()</code>:
<ol>
<li>Superclass initialization must be DU</li>
<li>Mark superclass initialization as DA</li>
<li>&#34;Infer&#34; assignments to all blank final fields, i.e.:
<ol>
<li>All blank final fields must be DU</li>
<li>Mark all blank final fields as DA</li>
</ol>
</li>
</ol>
</li>
<li>Require all final fields to be DA on any return.</li>
<li>Require superclass initialization to be DA on any return.</li>
</ol>
</li>
</ol>
<p>The result is that on every path through every constructor, each blank final field must be assigned exactly once, and superclass initialization must also happen exactly once.</p>
<p><code>AssignAnalyzer</code> is also augmented to enforce these new restrictions:</p>
<ol>
<li>Disallow any reference to the current instance prior to <code>super()</code> or <code>this()</code>, except for assignments to fields.</li>
<li>Disallow invocations of <code>this()</code> or <code>super()</code> invocations within <code>try { }</code> blocks.</li>
</ol>
<h3 id="comp/Lower-java"><code>comp/Lower.java</code></h3>
<p>This is where the adjustments are made for initializing outer instances and free variable proxies. This now must be done at every <code>super()</code> invocation instead of just at the presumed first and only one, so the new code goes and finds all <code>super()</code> invocations. Otherwise the adjustments made are the same.</p>
<h3 id="jvm/Code-java"><code>jvm/Code.java</code></h3>
<p>This class requires a change because of the following problem: while the class <code>Code.State</code> is used to model the JVM state on each code branch, the &#34;uninitialized&#34; status of each local variable is not part of <code>Code.State</code> but rather stored in the <code>LocalVar</code> fields themselves (which are not cloned per code branch). Previously this was not a problem because the initial <code>this()</code> or <code>super()</code> invocation was always on the (only) initial branch of the code.  Now that different branches of code may or may not initialize the superclass, we have to keep track of the &#34;uninitialized&#34; status of each <code>LocalVar</code> separately in each <code>Code.State</code> instance.</p>
<p>This is done by adding a bitmap indicating which local variables are initialized. As a result, to get the current type of a <code>LocalVar</code>, now you access the <code>State</code> instead of accessing the <code>LocalVar</code> directly.</p>
<h3 id="jvm/Gen-java"><code>jvm/Gen.java</code></h3>
<p>Previously, the method <code>Gen.normalizeMethod()</code> added initialization code to initial constructors after the intial <code>super()</code> invocation. This is now done at every <code>super()</code> invocation instead of just after the presumed first and only one.</p>
<h3 id="tree/TreeInfo-java"><code>tree/TreeInfo.java</code></h3>
<p>Removed these utility methods:</p>
<ol>
<li><code>public static Name getConstructorInvocationName(List&lt;? extends JCTree&gt; trees, Names names)</code></li>
<li><code>public static boolean isInitialConstructor(JCTree tree)</code></li>
</ol>
<p>Added these utility methods:</p>
<ol>
<li><code>public static boolean hasConstructorCalls(JCTree tree, Name target)</code></li>
<li><code>public static boolean hasAnyConstructorCalls(JCTree tree)</code></li>
<li><code>public static List&lt;JCMethodInvocation&gt; findConstructorCalls(JCTree tree, Name target)</code></li>
<li><code>public static List&lt;JCMethodInvocation&gt; findAllConstructorCalls(JCTree tree)</code></li>
<li><code>public static void mapSuperCalls(JCBlock block, Function&lt;? super JCExpressionStatement, ? extends JCStatement&gt; mapper)</code></li>
</ol>
<h3 id="resources/compiler-properties"><code>resources/compiler.properties</code></h3>
<p>There are some changes to error messages:</p>
<p>Removed these errors</p>
<ol>
<li><code>call to {0} must be first statement in constructor</code></li>
</ol>
<p>Added these errors:</p>
<ol>
<li><code>calls to {0}() may only appear within constructors</code></li>
<li><code>calls to {0}() may not appear within try statements</code></li>
<li><code>superclass constructor might not have been invoked</code></li>
<li><code>superclass constructor might already have been invoked</code></li>
</ol>
<p>Changed these errors:</p>
<p><strong>Old:</strong> <code>canonical constructor must not contain explicit constructor invocation</code></p>
<p><strong>New:</strong> <code>canonical constructor must not contain explicit constructor invocations</code></p>
<p><strong>Old:</strong> <code>constructor is not canonical, so its first statement must invoke another constructor of class {0}</code></p>
<p><strong>New:</strong> <code>constructor is not canonical, so it must invoke other constructors of class {0}</code></p>
<h2 id="Testing">Testing</h2>
<p>Testing of compiler changes will be done using the existing unit tests, which are unchanged except for those tests that verify changed compiler behavior, plus new positive and negative test cases related to this new feature.</p>
<p>All JDK existing classes will be compiled using the previous and new versions of the compiler, and the bytecode compared, to verify there is no change to existing bytecode.</p>
<p>No platform-specific testing should be required.</p>
<h2 id="Risks-and-Assumptions">Risks and Assumptions</h2>
<p>An explicit goal of this work is to not change the behavior of existing programs. Therefore, other than any newly created bugs, the risk to existing software should be low.</p>
<p>From a technical point of view, the most complicated aspect of this change is proper DA/DU analysis of superclass initialization. It is believed that risk here is reduced by relying on the existing, well-tested code for blank final field DA/DU analysis.</p>
<p>It&#39;s possible that compiling and/or executing newly valid code could trigger bugs in existing code that were not previously accessible.</p>
<h2 id="Dependencies">Dependencies</h2>
<p>Java compiler changes - <a href="https://bugs.openjdk.org/browse/JDK-8194743">JDK-8194743</a></p>
</div></div>
  </body>
</html>
