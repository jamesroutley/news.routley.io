<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bitfieldconsulting.com/golang/scripting">Original</a>
    <h1>Scripting with Go</h1>
    
    <div id="readability-page-1" class="page"><div data-block-type="44" id="block-7554cec72d8c2ede6a18"><div><p>The Unix shell is pure wizardry. With the right incantation of shell spells, you can organise files, process text, compute data, and feed the output of any program to the input of any other. We might even say, paraphrasing <a href="https://en.wikipedia.org/wiki/Clarke%27s_three_laws">Clarke&#39;s Third Law</a>:</p>
<blockquote>
<p>Any sufficiently clever shell one-liner is indistinguishable from magic.</p>
</blockquote>
<h2 id="systems-programs">Systems programs</h2>
<p>It&#39;s not that the shell itself is so clever. As a <em>programming</em> language, at least for non-trivial tasks, it&#39;s distinctly clumsy. But its elegant design makes it the perfect tool for <em>scripts</em>: short, focused programs that operate on files, processes, or text, in the service of managing computer systems. In other words, <em>systems programs</em>.</p>
<p>Traditionally, much of this kind of software has been written as scripts for various <em>shells</em>. A shell such as <code>bash</code> is a sort of hybrid between a job control language and a text-based interactive user interface.</p>
<p>There are lots of different and mutually incompatible shells, which is part of the problem, but let&#39;s just refer to all of these as “the shell” in this discussion.</p>
<p>Why shouldn&#39;t it be as easy to write systems programs in Go as it is in the shell?</p>
<h2 id="why-go-">Why Go?</h2>
<p>If the shell is the traditional way of writing systems software, then what would be the point of using a language like Go instead? It has many advantages: Go programs are fast, scalable, can be written quickly, and can also be maintained by large teams over a long time.</p>
<p>Go does much to support us in writing <em>correct</em> programs, being a compiled language with a strong type system. It also surfaces errors in a way that makes them hard to ignore, encouraging robust programs.</p>
<p>However, whereas shells are optimised for the specific tasks of scripting and job control, Go is a <em>general-purpose</em> language, used for all sorts of different applications.</p>
<p>That doesn&#39;t mean that we can&#39;t use it for systems programming, though. It just means that it doesn&#39;t have a lot of built-in facilities for making such programs easy to write. At least, perhaps not as easy as the shell makes it.</p>
<p>For example, consider a typical devops task such as counting the lines in a log file that match a certain string (<code>error</code>, let&#39;s say). Most experienced Unix users would write some kind of shell <em>one-liner</em> to do this. For example:</p>
<pre><code>grep error log.txt |wc -l</code></pre><p>The overall effect of this pipeline is to print the number of lines in <code>log.txt</code> that match the string <code>error</code>. The shell makes it easy to compose individual commands like <code>grep</code> and <code>wc</code> to achieve the goal.</p>
<h2 id="a-typical-task">A typical task</h2>
<p>But shell wizards (and witches) can do much more. For example, suppose we have a web server access log to analyse. Here&#39;s a typical line from such a log: it contains the client&#39;s IP address, a timestamp, and various information about the request.</p>
<pre><code>203.0.113.17 - - [30/Jun/2019:17:06:15 +0000] &#34;GET / HTTP/1.1&#34; 200 2028 &#34;https://example.com/ &#34;Mozilla/5.0...&#34;</code></pre><p>And suppose we want to find the top ten most frequent visitors to our website, by IP address. How could we do that?</p>
<p>Each line represents one request, so we&#39;ll need to count the lines for each IP address, sort them in descending order of frequency, and take the first ten.</p>
<p>A shell one-liner like this would do the job:</p>
<pre><code>cut -d&#39; &#39; -f 1 access.log |sort |uniq -c |sort -rn |head</code></pre><p>This extracts the IP address from the first column of each line (<code>cut</code>), counts the number of unique values (<code>uniq -c</code>), sorts them in descending numerical order (<code>sort -rn</code>), and shows the first ten (<code>head</code>).</p>
<p>Since virtually all Unix commands can accept data on standard input, and write results to standard output, some very complex pipelines can be constructed this way, using only the shell&#39;s simple pipe operator.</p>
<p>This is a very powerful and flexible programming paradigm, which goes a long way to explaining the dominance of the Unix model today. It also suggests it&#39;s worth investing a little time in learning how to get the best out of your shell.</p>
<p>So can we do the same sort of magic in Go? Let&#39;s try to write a similar program and see how easy it is (or not).</p>
<h2 id="the-wrong-answer">The wrong answer</h2>
<p>While the task is well-defined, this program is by no means easy to write in Go. It&#39;s certainly hard to make it as concise as the shell version.</p>
<p>Something like this might do the job:</p>
<pre><code>package main

import (
    &#34;bufio&#34;
    &#34;fmt&#34;
    &#34;log&#34;
    &#34;os&#34;
    &#34;sort&#34;
    &#34;strings&#34;
)

func main() {
    f, err := os.Open(&#34;log&#34;)
    if err != nil {
        log.Fatal(err)
    }
    defer f.Close()
    scanner := bufio.NewScanner(f)
    uniques := map[string]int{}
    for scanner.Scan() {
        fields := strings.Fields(scanner.Text())
        if len(fields) &gt; 0 {
            uniques[fields[0]]++
        }
    }
    type freq struct {
        addr  string
        count int
    }
    freqs := make([]freq, 0, len(uniques))
    for addr, count := range uniques {
        freqs = append(freqs, freq{addr, count})
    }
    sort.Slice(freqs, func(i, j int) bool {
        return freqs[i].count &gt; freqs[j].count
    })
    fmt.Printf(&#34;%-16s%s\n&#34;, &#34;Address&#34;, &#34;Requests&#34;)
    for i, f := range freqs {
        if i &gt; 9 {
            break
        }
        fmt.Printf(&#34;%-16s%d\n&#34;, f.addr, f.count)
    }
}</code></pre><p>There are several problems with this program, not least that it&#39;s pretty complicated. You might like to test your code-reading skills by figuring out how it works, but I&#39;m by no means recommending it as a model of Go style.</p>
<p>It&#39;s just a quick, untested, hack, and that&#39;s partly the point. In devops work we&#39;re often required to solve problems quickly, rather than elegantly. The server could be on fire <em>now</em>, and we need to figure out which IP address is burning it down.</p>
<p>So this isn&#39;t a very satisfactory result. If Go is so great, why isn&#39;t it a good fit for this problem? What kind of code would we like to write instead?</p>
<h2 id="programs-as-pipelines">Programs as pipelines</h2>
<p>Given the nature of the problem, we&#39;d prefer to express the solution as a <em>pipeline</em>, just like the shell program. How could we express that in Go? What about something like this?</p>
<pre><code>File(&#34;log&#34;).Column(1).Freq().First(10).Stdout()</code></pre><p>In other words, read the file <code>log</code>, take its first column, sort by frequency, get the first ten results, and print them to standard output.</p>
<p>Not only is this extremely concise, it&#39;s arguably even <em>clearer</em> than the shell pipeline. A beginner wouldn&#39;t necessarily know what <code>cut -d&#39; &#39; -f 1</code> does, for example. But if they saw <code>Column(1)</code>, I think they&#39;d understand that.</p>
<p>And this program achieves the same task as the awkward 30+ line monster we just saw... in <em>one</em> line. Not bad. In fact, it&#39;s getting to the point where even seasoned shell wizards might start to think it&#39;s worth writing systems programs in Go.</p>
<h2 id="the-script-library">The <code>script</code> library</h2>
<p>But this example doesn&#39;t even really look like Go code! How is it possible? The answer is a library package called <a href="https://pkg.go.dev/github.com/bitfield/script"><code>script</code></a>:</p>
<pre><code>import &#34;github.com/bitfield/script&#34;</code></pre><p><code>script</code> is a Go library for doing the kind of tasks that shell scripts are good at: reading files, executing subprocesses, counting lines, matching strings, and so on. The author liked the elegant and concise nature of well-crafted shell pipelines, but liked Go even more.</p>
<p>Now you can construct nifty one-liners in Go without all that tedious scanning, sorting, slicing, and looping. Let&#39;s take a look at a few examples.</p>
<p>Suppose you want to read the contents of a file as a string. Here&#39;s what that looks like in <code>script</code>:</p>
<pre><code>data, err := script.File(&#34;test.txt&#34;).String()</code></pre><p>That looks straightforward enough, but suppose you now want to count the lines in that file.</p>
<pre><code>n, err := script.File(&#34;test.txt&#34;).CountLines()</code></pre><p>For something a bit more challenging, let&#39;s try counting the number of lines in the file that match the string “Error”:</p>
<pre><code>n, err := script.File(&#34;test.txt&#34;).
    Match(&#34;Error&#34;).CountLines()</code></pre><p>But what if, instead of reading a specific file, we want to simply pipe input into this program, and have it output only matching lines (like <code>grep</code>)?</p>
<pre><code>script.Stdin().Match(&#34;Error&#34;).Stdout()</code></pre><p>That was almost too easy! So let&#39;s pass in a list of files on the command line, and have our program read them all in sequence and output the matching lines:</p>
<pre><code>script.Args().Concat().
    Match(&#34;Error&#34;).Stdout()</code></pre><p>Maybe we&#39;re only interested in the first 10 matches. No problem:</p>
<pre><code>script.Args().Concat().
    Match(&#34;Error&#34;).First(10).Stdout()</code></pre><p>What&#39;s that? You want to append that output to a file instead of printing it to the terminal? <em>You&#39;ve got some attitude, mister</em>. But okay:</p>
<pre><code>script.Args().Concat().
    Match(&#34;Error&#34;).First(10).
    AppendFile(&#34;/var/log/errors.txt&#34;)</code></pre>
<p>One of the things that makes shell scripts powerful is not just the shell language itself, which is pretty basic. It&#39;s the availability of a rich set of <em>userland</em> tools, like <code>grep</code>, <code>awk</code>, <code>cat</code>, <code>find</code>, <code>head</code>, and so on.</p>
<p>But we can replicate most of the functionality of those tools using script. Here&#39;s a program that just echoes its input to its output, like <code>cat</code>:</p>
<pre><code>script.Stdin().Stdout()</code></pre><p>And here&#39;s one that concatenates all the files it&#39;s given as arguments and writes them to the output, again like <code>cat</code>:</p>
<pre><code>script.Args().Concat().Stdout()</code></pre><p>What about <code>echo</code>? Can we do that? Yup:</p>
<pre><code>script.Args().Join().Stdout()</code></pre><p>It&#39;s fairly easy to reproduce at least the simple behaviour of most of the familiar Unix tools in this way. And for anything that&#39;s not already provided in <code>script</code>, well, we can just use the tool itself:</p>
<pre><code>script.Exec(&#34;open info.pdf&#34;)</code></pre><p>Since we can run any external program, we can use the shell&#39;s facilities too. Now we really have the best of all worlds!</p>
<pre><code>script.Exec(&#34;bash -c &#39;echo hello from bash&#39;&#34;).
    Stdout()</code></pre><p>One common operation in shell scripts is to use the <code>find</code> tool to generate a recursive directory listing. We can do that too:</p>
<pre><code>script.FindFiles(&#34;/backup&#34;).Stdout()</code></pre><p>But supposing we then wanted to do some operation on each of the files discovered in this way. What would that look like?</p>
<pre><code>script.FindFiles(&#34;*.go&#34;).
    ExecForEach(&#34;gofmt -w {{.}}&#34;)</code></pre><p>You might recognise the argument to <code>ExecForEach</code> as a Go template; every filename produced by <code>FindFiles</code> will be substituted into this command in turn.</p>
<h2 id="how-does-it-work-">How does it work?</h2>
<p>Those chained function calls look a bit weird. What&#39;s going on there?</p>
<p>One of the neat things about the Unix shell, and its many imitators, is the way you can compose operations into a <em>pipeline</em>:</p>
<pre><code>cat test.txt | grep Error | wc -l</code></pre><p>The output from each stage of the pipeline feeds into the next, and you can think of each stage as a <em>filter</em> that passes on only certain parts of its input to its output.</p>
<p>By comparison, writing shell-like scripts in raw Go is much less convenient, because everything you do returns a different data type, and you must (or at least should) check errors following every operation.</p>
<p>In scripts for system administration we often want to compose different operations like this in a quick and convenient way. If an error occurs somewhere along the pipeline, we would like to check this just once at the end, rather than after every operation.</p>
<h2 id="everything-is-a-pipe">Everything is a pipe</h2>
<p>The <code>script</code> library allows us to do this because everything is a pipe (specifically, a <code>script.Pipe</code>). To create a pipe, start with a <em>source</em> like <code>File</code>:</p>
<pre><code>p := script.File(&#34;test.txt&#34;)</code></pre><p>You might expect <code>File</code> to return an error if there is a problem opening the file, but it doesn&#39;t. We will want to call a chain of methods on the result of <code>File</code>, and it&#39;s inconvenient to do that if it also returns an error. So <code>File</code> returns a pipe instead.</p>
<p>Since <code>File</code> returns a pipe, you can call any method on it you like. For example, <code>Match</code>:</p>
<pre><code>p.Match(&#34;what I&#39;m looking for&#34;)</code></pre><p>The result of <em>this</em> is another pipe (containing only the matching lines from <code>test.txt</code>), and so on. You don&#39;t have to chain all your methods onto a single line, but it&#39;s pretty neat that you can if you want to.</p>
<h2 id="handling-errors">Handling errors</h2>
<p>Woah, woah! Just a minute! We haven&#39;t done anything about errors. We know that good Go programmers <a href="https://bitfieldconsulting.com/golang/commandments">always check errors</a>. That&#39;s because almost everything we do in a program can go wrong, and the <em>robustness</em> of a program is almost all about how it behaves in error situations.</p>
<p>What if there was an error opening the file at the source end of this pipe? Won&#39;t <code>Match</code> blow up if it tries to read from a non-existent file?</p>
<p>No, it won&#39;t. That&#39;s because if <code>File</code> encounters an error, it sets a flag on the resulting pipe to say “hey, something&#39;s wrong”. Normally when Go functions run into an error, they return something like <code>nil</code> and an error value indicating the problem. Instead, <code>File</code> returns a valid pipe, just one with its error flag set.</p>
<p>All pipe operations check this error flag before doing anything. If it&#39;s set, then they don&#39;t have valid data, so they short-circuit, returning immediately without doing any work (a “no-op”, short for “no operation”).</p>
<p>As soon as any pipeline stage hits an error, the error flag is set on the pipe, and all subsequent operations on the pipe become no-ops. That means you don&#39;t need to check for an error <em>at each stage</em>: instead, you can check it at the end, or whenever you like.</p>
<p>You can always ask a pipe for its error status by calling its <code>Error</code> method:</p>
<pre><code>if err := p.Error(); err != nil {
    return fmt.Errorf(&#34;oh no: %w&#34;, err)
}</code></pre><p>Seasoned Gophers will recognise this as the <code>errWriter</code> pattern described by Rob Pike in the blog post <a href="https://blog.golang.org/errors-are-values">Errors are values</a>. It&#39;s ideal when you&#39;re carrying out a series of operations, any of which can error, but you only care if the <em>sequence</em> as a whole encounters an error.</p>
<p>This eliminates a lot of the <code>if err != nil</code> boilerplate which seems to infuriate people so much about Go. Those people aren&#39;t crazy: that kind of thing <em>can</em> be annoying, if you don&#39;t know this useful pattern.</p>
<h2 id="closing-pipes">Closing pipes</h2>
<p>If you&#39;ve dealt with files in Go before, you&#39;ll know that you need to <em>close</em> a file once you&#39;ve finished with it. Otherwise, the program will retain what&#39;s called a <em>file handle</em> (the kernel data structure that represents an open file).</p>
<p>There is a limit to the total number of open file handles for a given program, and for the system as a whole, so a program that leaks file handles will eventually crash, and will waste resources in the meantime.</p>
<p>Files aren&#39;t the only things that need to be closed after reading: so do network connections, HTTP response bodies, and so on.</p>
<p>How does <code>script</code> handle this? Simple. The data source associated with a pipe will be automatically closed once it is read completely. Therefore, calling any sink method that reads the pipe to completion (such as <code>String</code>) will close its data source. The only case in which you need to explicitly call <code>Close</code> on a pipe is when you don&#39;t read from it, or you don&#39;t read it to completion for some reason.</p>
<p>If the pipe was created from something that doesn&#39;t need to be closed, such as a string, then calling <code>Close</code> simply does nothing, as you&#39;d expect.</p>
<h2 id="why-not-shell-">Why not shell?</h2>
<p>This is cool and all, but is it <em>really</em> needed? After all, haven&#39;t we been running the world on shell scripts for several decades? And aren&#39;t we writing more of them every day? So what&#39;s the problem with shell scripts, and why is Go the solution?</p>
<p>It&#39;s a fair question. Shell scripts and one-liners are perfectly adequate for building one-off tasks, initialization scripts, and the kind of &#39;glue code&#39; that holds the internet together. I speak as someone who&#39;s spent at least thirty years doing this for a living. But in many ways they&#39;re not ideal for important, non-trivial programs:</p>
<ul>
<li>Trying to build portable shell scripts is a nightmare. The exact syntax and options of Unix commands varies from one distribution to another. Although in theory POSIX is a workable common subset of functionality, in practice it&#39;s usually precisely the non-POSIX behaviour that you need.</li>
</ul>
<ul>
<li>Shell scripts are hard to test (though test frameworks have been written, and if you&#39;re seriously putting mission-critical shell scripts into production, you should be using them, or reconsidering your technology choices).</li>
</ul>
<ul>
<li>Shell scripts don&#39;t scale. Because there are very limited facilities for logic and abstraction, and because any successful program tends to grow remorselessly over time, shell scripts can become an unreadable mess of special cases and spaghetti code. We&#39;ve all seen it, if not, indeed, done it.</li>
</ul>
<ul>
<li>Shell syntax is awkward: quoting, whitespace, and brackets can require a lot of fiddling to get right, and so many characters are magic to the shell (<code>*</code>, <code>?</code>, <code>&gt;</code> and so on) that this can lead to subtle bugs. Scripts can work fine for years until you suddenly encounter a file whose name contains whitespace, and then everything breaks horribly.</li>
</ul>
<ul>
<li>Deploying shell scripts obviously requires at least a (sizable) shell binary in addition to the source code, but it usually also requires an unknown and variable number of extra userland programs (<code>cut</code>, <code>grep</code>, <code>head</code>, and friends). If you&#39;re building container images, for example, you effectively need to include a whole Unix distribution with your program, which runs to hundreds of megabytes, and is not at all in the spirit of containers.</li>
</ul>



<p>To be fair to the shell, this kind of thing is not what it was ever intended for. Shell is an interactive job control tool for launching programs, connecting programs together, and to a limited extent, manipulating text. It&#39;s not for building portable, scalable, reliable, and elegant programs. That&#39;s what <em>Go</em> is for.</p>
<h2 id="scripting-with-go">Scripting with Go</h2>
</div></div><div data-block-type="44" id="block-yui_3_17_2_1_1644257000497_10064"><div><p>Go has a great testing framework built right into the standard library. It has a superb standard library, and thousands of high-quality third-party packages for just about any functionality you can imagine. It is compiled, so it&#39;s fast, and statically typed, so it&#39;s reliable. It&#39;s efficient and memory-safe. Go programs can be distributed as a single binary. Go scales to enormous projects (Kubernetes, for example).</p>
<p>The <code>script</code> library is implemented entirely in Go, and does not require any external userland programs. Thus you can build your <code>script</code> program as a single (very small) binary that is quick to build, quick to upload, quick to deploy (in a container, for example), quick to run, and economical with resources.</p>
<p>I&#39;m not saying shell scripting is obsolete. I still use a lot of shell scripts myself. There is a large problem domain where shell is absolutely the right answer. But small programs tend to grow into large ones, and when that happens, it&#39;s nice to be able to use the facilities of a language that was designed for programming at scale.</p>
<p>But with a package like <code>script</code>, we don&#39;t have to lose all the elegance and flexibility of the classic Unix environment we&#39;ve come to love. Instead, we can keep just a little bit of that old shell magic.</p>
<p><small data-preserve-html-node="true">You can read more about the implementation of the <code data-preserve-html-node="true">script</code> library, and other interesting programs, in my book, <a data-preserve-html-node="true" href="https://bitfieldconsulting.com/books/tools">The Power of Go: Tools</a>.</small></p>
</div></div></div>
  </body>
</html>
