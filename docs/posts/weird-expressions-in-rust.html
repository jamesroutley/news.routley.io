<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.wakunguma.com/blog/rust-weird-expr">Original</a>
    <h1>Weird Expressions in Rust</h1>
    
    <div id="readability-page-1" class="page"><article data-astro-cid-4dqtj3le=""> <p>Rust has a very powerful type system, but as a result it has some quirks, some would say cursed expressions. Thereâ€™s a test file, <a href="https://github.com/rust-lang/rust/blob/master/tests/ui/weird-exprs.rs"><code>weird-expr.rs</code></a>, in the rust repository that tests for some of these and makes sure there consistent between updates. So I wanted to go over each of these and explain how itâ€™s valid rust.</p>
<blockquote>
<p>Note that these are not bugs, but rather extreme cases of rust features like loops, expressions, coercion and so on.</p>
</blockquote>
<h2 id="strange">Strange</h2>
<pre tabindex="0" data-language="rust"><code><span><span>fn</span><span> strange</span><span>()</span><span> -&gt;</span><span> bool</span><span> {</span><span>let</span><span> _x</span><span>:</span><span>bool</span><span> =</span><span> return</span><span> true</span><span>;}</span></span></code></pre>
<p>The expression <code>return true</code> has the type <code>!</code>. The never type can coerce into any other type, so we can assign it to a boolean.</p>
<h2 id="funny">Funny</h2>
<pre tabindex="0" data-language="rust"><code><span><span>fn</span><span> funny</span><span>(){</span></span>
<span><span>	fn</span><span> f</span><span>(_x</span><span>:</span><span> ()){}</span></span>
<span><span>	f</span><span>(</span><span>return</span><span>);</span></span>
<span><span>}</span></span></code></pre>
<p>The function <code>f</code> has a single parameter of <code>()</code> type, we can again pass <code>return</code> because <code>!</code> will be coerced into <code>()</code>.</p>
<h2 id="what">What</h2>
<pre tabindex="0" data-language="rust"><code><span><span>use</span><span> std</span><span>::</span><span>cell</span><span>::</span><span>Cell</span><span>;</span></span>
<span></span>
<span><span>fn</span><span> what</span><span>(){</span></span>
<span><span>	fn</span><span> the</span><span>(x</span><span>:</span><span> &amp;</span><span>Cell</span><span>&lt;</span><span>bool</span><span>&gt;){</span></span>
<span><span>		return</span><span> while</span><span> !</span><span>x</span><span>.</span><span>get</span><span>() {x</span><span>.</span><span>set</span><span>(</span><span>true</span><span>);};</span></span>
<span><span>	}</span></span>
<span><span>	let</span><span> i </span><span>=</span><span> &amp;</span><span>Cell</span><span>::</span><span>new</span><span>(</span><span>false</span><span>);</span></span>
<span><span>	let</span><span> dont </span><span>=</span><span> {</span><span>||</span><span>the</span><span>(i)};</span></span>
<span><span>	dont</span><span>();</span></span>
<span><span>	assert!</span><span>(i</span><span>.</span><span>get</span><span>());</span></span>
<span><span>}</span></span></code></pre>
<p>The <code>the</code> function takes a reference to a <code>Cell&lt;bool&gt;</code>. Inside the function, we use a while loop</p>
<pre tabindex="0" data-language="rust"><code><span><span>while</span><span> !</span><span>x</span><span>.</span><span>get</span><span>() {x</span><span>.</span><span>set</span><span>(</span><span>true</span><span>);}</span></span></code></pre>
<p>to set the cells contains to <code>true</code> if its contents are <code>false</code> and we return that while loop which has the type <code>()</code>.</p>
<p>Next we create a variable <code>i</code> which is a reference to a <code>Cell&lt;bool&gt;</code> and bind a closure that calls <code>the</code> with <code>i</code> as the parameter, we then call that closure and assert that <code>i</code> is true.</p>
<h2 id="zombie-jesus">Zombie jesus</h2>
<pre tabindex="0" data-language="rust"><code><span><span>fn</span><span> zombiejesus</span><span>()</span><span> {  </span></span>
<span><span>    loop</span><span> {  </span></span>
<span><span>        while</span><span> (</span><span>return</span><span>) {  </span></span>
<span><span>            if</span><span> (</span><span>return</span><span>) {  </span></span>
<span><span>                match</span><span> (</span><span>return</span><span>) {  </span></span>
<span><span>                    1</span><span> =&gt;</span><span> {  </span></span>
<span><span>                        if</span><span> (</span><span>return</span><span>) {  </span></span>
<span><span>                            return</span><span>  </span></span>
<span><span>                        } </span><span>else</span><span> {  </span></span>
<span><span>                            return</span><span>  </span></span>
<span><span>                        }  </span></span>
<span><span>                    }                    </span></span>
<span><span>                    _ </span><span>=&gt;</span><span> { </span><span>return</span><span> }  </span></span>
<span><span>                };  </span></span>
<span><span>            } </span><span>else</span><span> if</span><span> (</span><span>return</span><span>) {  </span></span>
<span><span>                return</span><span>;  </span></span>
<span><span>            }  </span></span>
<span><span>        }        </span></span>
<span><span>        if</span><span> (</span><span>return</span><span>) { </span><span>break</span><span>; }  </span></span>
<span><span>    }</span></span>
<span><span>}</span></span></code></pre>
<p>The expression <code>(return)</code> has the type never, since the never type can coerce into any type we can use it in all these places.</p>
<p>In <code>if</code> and <code>while</code> statements it gets coerced into a boolean, in a <code>match</code> statement it gets coerced into anything.</p>
<pre tabindex="0" data-language="rust"><code><span><span>let</span><span> screaming </span><span>=</span><span> match</span><span>(</span><span>return</span><span>){</span></span>
<span><span>	&#34;</span><span>aahhh</span><span>&#34;</span><span> =&gt;</span><span> true</span><span>,</span></span>
<span><span>	_ </span><span>=&gt;</span><span> false</span></span>
<span><span>};</span></span></code></pre>
<h2 id="not-sure">Not sure</h2>
<pre tabindex="0" data-language="rust"><code><span><span>use</span><span> std</span><span>::</span><span>mem</span><span>::</span><span>swap;</span></span>
<span></span>
<span><span>fn</span><span> notsure</span><span>()</span><span> {</span></span>
<span><span>    let</span><span> mut</span><span> _x</span><span>:</span><span> isize</span><span>;</span></span>
<span><span>    let</span><span> mut</span><span> _y </span><span>=</span><span> (_x </span><span>=</span><span> 0</span><span>) </span><span>==</span><span> (_x </span><span>=</span><span> 0</span><span>);</span></span>
<span><span>    let</span><span> mut</span><span> _z </span><span>=</span><span> (_x </span><span>=</span><span> 0</span><span>) </span><span>&lt;</span><span> (_x </span><span>=</span><span> 0</span><span>);</span></span>
<span><span>    let</span><span> _a </span><span>=</span><span> (_x </span><span>+=</span><span> 0</span><span>) </span><span>==</span><span> (_x </span><span>=</span><span> 0</span><span>);</span></span>
<span><span>    let</span><span> _b </span><span>=</span><span> swap</span><span>(</span><span>&amp;mut</span><span> _y,</span><span> &amp;mut</span><span> _z) </span><span>==</span><span> swap</span><span>(</span><span>&amp;mut</span><span> _y,</span><span> &amp;mut</span><span> _z);</span></span>
<span><span>}</span></span></code></pre>
<p>We have an uninitialised variable <code>_x</code>, we assign <code>_y</code> to <code>(_x = 0) == (_x = 0)</code>. <code>(_x = 0)</code> evaluates to the unit type so <code>_y</code> is true. Similar thing with <code>_z</code> and <code>_a</code>, except <code>_z</code> is false since <code>()</code> is not less than itself. <code>_b</code> is also true because <code>swap</code> returns <code>()</code>.</p>
<h2 id="cant-touch-this">Cant touch this</h2>
<pre tabindex="0" data-language="rust"><code><span></span>
<span><span>fn</span><span> canttouchthis</span><span>()</span><span> -&gt;</span><span> usize</span><span> {</span></span>
<span><span>    fn</span><span> p</span><span>()</span><span> -&gt;</span><span> bool</span><span> { </span><span>true</span><span> }</span></span>
<span><span>    let</span><span> _a </span><span>=</span><span> (</span><span>assert!</span><span>(</span><span>true</span><span>) </span><span>==</span><span> (</span><span>assert!</span><span>(</span><span>p</span><span>())));</span></span>
<span><span>    let</span><span> _c </span><span>=</span><span> (</span><span>assert!</span><span>(</span><span>p</span><span>()) </span><span>==</span><span> ());</span></span>
<span><span>    let</span><span> _b</span><span>:</span><span> bool</span><span> =</span><span> (</span><span>println!</span><span>(</span><span>&#34;{}&#34;</span><span>, </span><span>0</span><span>) </span><span>==</span><span> (</span><span>return</span><span> 0</span><span>));</span></span>
<span><span>}</span></span></code></pre>
<p>The function <code>p()</code> function returns that a boolean, the <code>assert!</code> macro returns <code>()</code>, so <code>_a</code> and <code>_c</code> are both true.</p>
<p>In the final line <code>_b</code> is assigned to the expression</p>
<pre tabindex="0" data-language="rust"><code><span><span>(</span><span>println!</span><span>(</span><span>&#34;{}&#34;</span><span>),</span><span>0</span><span>) </span><span>==</span><span> (</span><span>return</span><span> 0</span><span>))</span></span></code></pre>
<p>The <code>println!</code> returns macro returns <code>()</code>, and <code>(return 0)</code> is <code>!</code> which gets coerced into <code>()</code> so the expression is valid, this line also returns 0 which makes the function signature valid.</p>
<h2 id="angry-dome">Angry dome</h2>
<pre tabindex="0" data-language="rust"><code><span><span>fn</span><span> angrydome</span><span>()</span><span> {  </span></span>
<span><span>    loop</span><span> { </span><span>if</span><span> break</span><span> { } }  </span></span>
<span><span>    let</span><span> mut</span><span> i </span><span>=</span><span> 0</span><span>;  </span></span>
<span><span>    loop</span><span> {   </span></span>
<span><span>		i </span><span>+=</span><span> 1</span><span>;   </span></span>
<span><span>		if</span><span> i </span><span>==</span><span> 1</span><span> { </span></span>
<span><span>			match</span><span> (</span><span>continue</span><span>) { </span></span>
<span><span>				1</span><span> =&gt;</span><span> { }, </span></span>
<span><span>				_ </span><span>=&gt;</span><span> panic!</span><span>(</span><span>&#34;</span><span>wat</span><span>&#34;</span><span>) } </span></span>
<span><span>			}  </span></span>
<span><span>	        break</span><span>;   </span></span>
<span><span>		}  </span></span>
<span><span>}</span></span></code></pre>
<p>In the first line we immediately exit the loop, because <code>break</code> is a valid expression, which has the type <code>!</code>, we can use it in an if statement.</p>
<p>In the next part we assign <code>i</code> to 0. We increment <code>i</code> in the loop, the if statement will run in the first iteration because <code>i</code> is now 1. We match <code>(continue)</code> which is <code>!</code>, the loop skips to the next iteration, we increment <code>i</code> again so itâ€™s now <code>2</code>. The <code>if</code> statement doesnâ€™t run so the loop exits and the function returns.</p>
<h2 id="union">Union</h2>
<pre tabindex="0" data-language="rust"><code><span><span>fn</span><span> union</span><span>()</span><span> {</span></span>
<span><span>    union</span><span> union</span><span>&lt;&#39;</span><span>union</span><span>&gt; { </span><span>union</span><span>:</span><span> &amp;</span><span>&#39;</span><span>union</span><span> union</span><span>&lt;&#39;</span><span>union</span><span>&gt;, }</span></span>
<span><span>}</span></span></code></pre>
<p>Rust has <a href="https://doc.rust-lang.org/reference/keywords.html">three categories</a> of keywords:</p>
<ul>
<li>Strict keywords, which can only be used in their correct contexts</li>
<li>Reserved keywords, which have been reserved for future use, but have the same limitations as strict keywords</li>
<li>Weak keywords, which only have special meaning in certain contexts</li>
</ul>
<p><code>union</code> is a weak keyword and is <a href="https://doc.rust-lang.org/reference/keywords.html#r-lex.keywords.weak.union">only a keyword when used in a union declaration</a>, allowing us to it to be used in other contexts, such as function names.</p>
<h2 id="punch-card">Punch card</h2>
<pre tabindex="0" data-language="rust"><code><span><span>fn</span><span> punch_card</span><span>()</span><span> -&gt;</span><span> impl</span><span> std</span><span>::</span><span>fmt</span><span>::</span><span>Debug</span><span> {</span></span>
<span><span>    ..=..=..</span><span> ..</span><span>    ..</span><span> ..</span><span> ..</span><span> ..</span><span>    ..</span><span> ..</span><span> ..</span><span> ..</span><span>    ..</span><span> ..</span><span> ..</span><span> ..</span></span>
<span><span>    ..=..</span><span> ..=..</span><span>    ..</span><span> ..</span><span> ..</span><span> ..</span><span>    ..</span><span> ..</span><span> ..</span><span> ..</span><span>    ..</span><span> ..=..</span><span> ..</span></span>
<span><span>    ..=..</span><span> ..=..</span><span>    ..=..</span><span> ..=..</span><span>    ..</span><span> ..=..=..</span><span>    ..=..=..=..</span></span>
<span><span>    ..=..=..</span><span> ..</span><span>    ..=..</span><span> ..=..</span><span>    ..=..</span><span> ..</span><span> ..</span><span>    ..</span><span> ..=..</span><span> ..</span></span>
<span><span>    ..=..</span><span> ..=..</span><span>    ..=..</span><span> ..=..</span><span>    ..</span><span> ..=..</span><span> ..</span><span>    ..</span><span> ..=..</span><span> ..</span></span>
<span><span>    ..=..</span><span> ..=..</span><span>    ..=..</span><span> ..=..</span><span>    ..</span><span> ..</span><span> ..=..</span><span>    ..</span><span> ..=..</span><span> ..</span></span>
<span><span>    ..=..</span><span> ..=..</span><span>    ..</span><span> ..=..=..</span><span>    ..=..=..</span><span> ..</span><span>    ..</span><span> ..=..=..</span></span>
<span><span>}</span></span></code></pre>
<p>In rust <code>..</code> represents an unbounded range (<a href="https://doc.rust-lang.org/std/ops/struct.RangeFull.html"><code>std::ops::RangeFull</code></a>) usually used in slices. Similarly <code>..=</code> represents a range up to and including a value  (<a href="https://doc.rust-lang.org/std/ops/struct.RangeToInclusive.html"><code>std::ops::RangeToInclusive</code></a>). All the different ranges have types which you can see in the <code>std::ops</code> <a href="https://doc.rust-lang.org/std/ops/index.html">module docs</a>.</p>
<p>Ranges can be combined into whatever amalgamation you would like:</p>
<pre tabindex="0" data-language="rust"><code><span><span>use</span><span> std</span><span>::</span><span>ops</span><span>::</span><span>{</span><span>RangeFull</span><span>, </span><span>RangeTo</span><span>, </span><span>RangeToInclusive</span><span>};</span></span>
<span></span>
<span><span>let</span><span> _a</span><span>:</span><span> RangeToInclusive</span><span>&lt;</span><span>RangeTo</span><span>&lt;</span><span>RangeFull</span><span>&gt;&gt; </span><span>=</span><span>  ..=..</span><span> ..</span><span> ;</span></span></code></pre>
<p>All of these range types implement <code>Debug</code>, which satisfies the <code>impl std::fmt::Debug</code> return type.</p>
<h2 id="monkey-barrel">Monkey barrel</h2>
<pre tabindex="0" data-language="rust"><code><span><span>fn</span><span> monkey_barrel</span><span>()</span><span> {</span></span>
<span><span>    let</span><span> val</span><span>:</span><span> () </span><span>=</span><span> ()</span><span>=</span><span>()</span><span>=</span><span>()</span><span>=</span><span>()</span><span>=</span><span>()</span><span>=</span><span>()</span><span>=</span><span>()</span><span>=</span><span>()</span><span>=</span><span>()</span><span>=</span><span>()</span><span>=</span><span>()</span><span>=</span><span>()</span><span>=</span><span>()</span><span>=</span><span>()</span><span>=</span><span>()</span><span>=</span><span>()</span><span>=</span><span>()</span><span>=</span><span>()</span><span>=</span><span>()</span><span>=</span><span>()</span><span>=</span><span>()</span><span>=</span><span>()</span><span>=</span><span>()</span><span>=</span><span>()</span><span>=</span><span>();</span></span>
<span><span>    assert_eq!</span><span>(val, ());</span></span>
<span><span>}</span></span></code></pre>
<p>In rust an <a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#assignment-expressions"><strong>assignment expression</strong></a> consists of a left <a href="https://doc.rust-lang.org/reference/expressions.html#r-expr.place-value.assignee"><strong>assignee expression</strong></a>, an equals sign (<code>=</code>) and a right <a href="https://doc.rust-lang.org/reference/expressions.html#r-expr.place-value.value-result"><strong>value expression</strong></a>. A tuple pattern can be used an assignee expression, which means it can appear on the left part of an assignment expression. Most of the times we use this to assign destructure values.</p>
<pre tabindex="0" data-language="rust"><code><span><span>let</span><span> (x,y) </span><span>=</span><span> (</span><span>110</span><span>.</span><span>0</span><span>,</span><span>50</span><span>.</span><span>5</span><span>);</span></span></code></pre>
<p>But the tuple can also be empty, which means weâ€™re assigning it to the <code>()</code> type.</p>
<pre tabindex="0" data-language="rust"><code><span><span>let</span><span> () </span><span>=</span><span> ();</span></span></code></pre>
<p>Because assignments return <code>()</code> we can chain them</p>
<pre tabindex="0" data-language="rust"><code><span><span>let</span><span> () </span><span>=</span><span> ()</span><span>=</span><span>()</span><span>=</span><span>();</span></span></code></pre>
<h2 id="semis">Semiâ€™s</h2>
<pre tabindex="0" data-language="rust"><code><span><span>fn</span><span> semisemisemisemisemi</span><span>()</span><span> {</span></span>
<span><span>    ;;;;;;; ;;;;;;; ;;;    ;;; ;;</span></span>
<span><span>    ;;      ;;      ;;;;  ;;;; ;;</span></span>
<span><span>    ;;;;;;; ;;;;;   ;; ;;;; ;; ;;</span></span>
<span><span>         ;; ;;      ;;  ;;  ;; ;;</span></span>
<span><span>    ;;;;;;; ;;;;;;; ;;      ;; ;;</span></span>
<span><span>}</span></span></code></pre>
<p>You can add a semi-colon anywhere in a block, which creates an empty statement with an empty value <code>()</code>. So these semi-colons just create a bunch of empty statements.</p>
<h2 id="useful-syntax">Useful syntax</h2>
<pre tabindex="0" data-language="rust"><code><span><span>fn</span><span> useful_syntax</span><span>()</span><span> {  </span></span>
<span><span>    use</span><span> {{</span><span>std</span><span>::</span><span>{{</span><span>collections</span><span>::</span><span>{{</span><span>HashMap</span><span>}}}}}};  </span></span>
<span><span>    use</span><span> ::</span><span>{{{{core}, {std}}}};  </span></span>
<span><span>    use</span><span> {{</span><span>::</span><span>{{core </span><span>as</span><span> core2}}}};  </span></span>
<span><span>}</span></span></code></pre>
<p>Rust allows grouped <code>use</code> statements to reduce boilerplate. These braces can also be used at the root of the statement, thereâ€™s also no limit to the number of braces you can use.</p>
<pre tabindex="0" data-language="rust"><code><span><span>use</span><span> {</span><span>std</span><span>::</span><span>sync</span><span>::</span><span>Arc</span><span>};</span></span>
<span><span>use</span><span> core</span><span>::</span><span>{</span><span>mem</span><span>::</span><span>{{transmute}}};</span></span></code></pre>
<h2 id="infinite-modules">Infinite modules</h2>
<pre tabindex="0" data-language="rust"><code><span><span>fn</span><span> infcx</span><span>()</span><span> {</span></span>
<span><span>    pub</span><span> mod</span><span> cx {</span></span>
<span><span>        pub</span><span> mod</span><span> cx {</span></span>
<span><span>            pub</span><span> use</span><span> super</span><span>::</span><span>cx;</span></span>
<span><span>            pub</span><span> struct</span><span> Cx</span><span>;</span></span>
<span><span>        }</span></span>
<span><span>    }</span></span>
<span><span>    let</span><span> _cx</span><span>:</span><span> cx</span><span>::</span><span>cx</span><span>::</span><span>Cx</span><span> =</span><span> cx</span><span>::</span><span>cx</span><span>::</span><span>cx</span><span>::</span><span>cx</span><span>::</span><span>cx</span><span>::</span><span>Cx</span><span>;</span></span>
<span><span>}</span></span></code></pre>
<p>We declare a module <code>cx</code>, then we create another sub-module also named <code>cx</code>. The line</p>
<pre tabindex="0" data-language="rust"><code><span><span>pub</span><span> use</span><span> super</span><span>::</span><span>cx;</span></span></code></pre>
<p>is re-exporting the module from itself, which means we can now call it recursively. Itâ€™s simpler to see if we change the names.</p>
<pre tabindex="0" data-language="rust"><code><span><span>pub</span><span> mod</span><span> outer{  </span></span>
<span><span>    pub</span><span> mod</span><span> inner{  </span></span>
<span><span>        pub</span><span> use</span><span> super</span><span>::</span><span>inner;  </span></span>
<span><span>        pub</span><span> struct</span><span> Item</span><span>;  </span></span>
<span><span>    }  </span></span>
<span><span>}  </span></span>
<span><span>  </span></span>
<span><span>let</span><span> _item</span><span>:</span><span> outer</span><span>::</span><span>inner</span><span>::</span><span>Item</span><span> =</span><span> outer</span><span>::</span><span>inner</span><span>::</span><span>inner</span><span>::</span><span>inner</span><span>::</span><span>Item</span><span>;</span></span></code></pre>
<h2 id="fish-fight">Fish fight</h2>
<pre tabindex="0" data-language="rust"><code><span><span>fn</span><span> fish_fight</span><span>()</span><span> {</span></span>
<span><span>    trait</span><span> Rope</span><span> {</span></span>
<span><span>        fn</span><span> _____________</span><span>&lt;</span><span>U</span><span>&gt;(_</span><span>:</span><span> Self</span><span>,</span><span> _</span><span>:</span><span> U</span><span>)</span><span> where</span><span> Self</span><span>:</span><span> Sized</span><span> {}</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    struct</span><span> T</span><span>;</span></span>
<span></span>
<span><span>    impl</span><span> Rope</span><span> for</span><span> T</span><span> {}</span></span>
<span></span>
<span><span>    fn</span><span> tug_o_war</span><span>(_</span><span>:</span><span> impl</span><span> Fn</span><span>(</span><span>T</span><span>,</span><span> T</span><span>))</span><span> {}</span></span>
<span></span>
<span><span>    tug_o_war</span><span>(&lt;</span><span>T</span><span>&gt;</span><span>::</span><span>_____________</span><span>::</span><span>&lt;</span><span>T</span><span>&gt;);</span></span>
<span><span>}</span></span></code></pre>
<p>The <code>Rope</code> trait has a provided method with one generic <code>U</code>, and it takes in two arguments, one of type <code>Self</code> and another of type <code>U</code>. We make a struct <code>T</code> and implement <code>Rope</code> for it. The <code>tug_of_war</code> function accepts any function or closure that implements <code>Fn(T,T)</code>.</p>
<p>The expression <code>&lt;T&gt;::_____________::&lt;T&gt;</code> is a fully qualified function pointer, with <code>T</code> as the generic type (<code>fn(T,T)</code>). Because both parameters are of the same type, we can pass this into the <code>tug_of_war</code>.</p>
<h2 id="dots">Dots</h2>
<pre tabindex="0" data-language="rust"><code><span><span>fn</span><span> dots</span><span>()</span><span> {</span></span>
<span><span>    assert_eq!</span><span>(</span><span>String</span><span>::</span><span>from</span><span>(</span><span>&#34;</span><span>..................................................</span><span>&#34;</span><span>),</span></span>
<span><span>               format!</span><span>(</span><span>&#34;{</span><span>:?</span><span>}&#34;</span><span>, </span><span>..</span><span> ..</span><span> ..</span><span> ..</span><span> ..</span><span> ..</span><span> ..</span><span> ..</span><span> ..</span><span> ..</span><span> ..</span><span> ..</span><span> ..</span></span>
<span><span>                               ..</span><span> ..</span><span> ..</span><span> ..</span><span> ..</span><span> ..</span><span> ..</span><span> ..</span><span> ..</span><span> ..</span><span> ..</span><span> ..</span><span>));</span></span>
<span><span>}</span></span></code></pre>
<p>The range syntax (<code>std::ops::RangeFull</code>) implements <code>Debug</code> and gets formatted as <code>&#34;..&#34;</code>. So we can chain them to get a string of dots.</p>
<h2 id="u8">u8</h2>
<pre tabindex="0" data-language="rust"><code><span><span>fn</span><span> u8</span><span>(</span><span>u8</span><span>:</span><span> u8</span><span>)</span><span> {  </span></span>
<span><span>    if</span><span> u8</span><span> !=</span><span> 0</span><span>u8</span><span> {  </span></span>
<span><span>        assert_eq!</span><span>(</span><span>8</span><span>u8</span><span>, {  </span></span>
<span><span>            macro_rules!</span><span> u8</span><span> {  </span></span>
<span><span>                (</span><span>u8</span><span>) </span><span>=&gt;</span><span> {  </span></span>
<span><span>                    mod</span><span> u8 {  </span></span>
<span><span>                        pub</span><span> fn</span><span> u8</span><span>&lt;&#39;</span><span>u8</span><span>:</span><span> &#39;</span><span>u8</span><span> +</span><span> &#39;</span><span>u8</span><span>&gt;(</span><span>u8</span><span>:</span><span> &amp;</span><span>&#39;</span><span>u8</span><span> u8</span><span>)</span><span> -&gt;</span><span> &amp;</span><span>&#39;</span><span>u8</span><span> u8</span><span> {  </span></span>
<span><span>                            &#34;</span><span>u8</span><span>&#34;</span><span>;  </span></span>
<span><span>                            u8</span><span>  </span></span>
<span><span>                        }  </span></span>
<span><span>                    }                </span></span>
<span><span>                };  </span></span>
<span><span>            }</span></span>
<span><span>            u8</span><span>!</span><span>(</span><span>u8</span><span>);  </span></span>
<span><span>            let</span><span> &amp;</span><span>u8</span><span>:</span><span> &amp;</span><span>u8</span><span> =</span><span> u8</span><span>::</span><span>u8</span><span>(</span><span>&amp;</span><span>8</span><span>u8</span><span>);  </span></span>
<span><span>            crate</span><span>::</span><span>u8</span><span>(</span><span>0</span><span>u8</span><span>);  </span></span>
<span><span>            u8</span><span>  </span></span>
<span><span>        });  </span></span>
<span><span>    }  </span></span>
<span><span>}</span></span></code></pre>
<p>Letâ€™s take this apart, we have a macro <code>u8!</code>, which declares a module <code>u8</code> which declares a function <code>u8</code> which takes a parameter named <code>u8</code> of type <code>u8</code> and returns a reference to a <code>u8</code>.</p>
<pre tabindex="0" data-language="rust"><code><span><span>macro_rules!</span><span> u8</span><span> {  </span></span>
<span><span>    (</span><span>u8</span><span>) </span><span>=&gt;</span><span> {  </span></span>
<span><span>        mod</span><span> u8 {  </span></span>
<span><span>            pub</span><span> fn</span><span> u8</span><span>&lt;&#39;</span><span>u8</span><span>:</span><span> &#39;</span><span>u8</span><span> +</span><span> &#39;</span><span>u8</span><span>&gt;(</span><span>u8</span><span>:</span><span> &amp;</span><span>&#39;</span><span>u8</span><span> u8</span><span>)</span><span> -&gt;</span><span> &amp;</span><span>&#39;</span><span>u8</span><span> u8</span><span> {  </span></span>
<span><span>                &#34;</span><span>u8</span><span>&#34;</span><span>;  </span></span>
<span><span>                u8</span><span>  </span></span>
<span><span>	        }  </span></span>
<span><span>        }                </span></span>
<span><span>    };  </span></span>
<span><span>}</span></span></code></pre>
<p>Next we call <code>u8::u8(&amp;8u8)</code> and assign it to a variable (<code>u8</code>). The next line calls <code>crate::u8(0u8)</code>, and finally we return the <code>u8</code> variable from the entire expression.</p>
<h2 id="continue">Continue</h2>
<pre tabindex="0" data-language="rust"><code><span><span>fn</span><span> ğšŒğš˜ğš—ğšğš’ğš—ğšğš() {  </span></span>
<span><span>    type</span><span> ğš•ğš˜ğš˜ğš™ </span><span>=</span><span> i32</span><span>;  </span></span>
<span><span>    fn</span><span> ğš‹ğš›ğšğšŠğš”() </span><span>-&gt;</span><span> ğš•ğš˜ğš˜ğš™ {  </span></span>
<span><span>        let</span><span> ğš›ğšğšğšğš›ğš— </span><span>=</span><span> 42</span><span>;  </span></span>
<span><span>        return</span><span> ğš›ğšğšğšğš›ğš—;  </span></span>
<span><span>    }  </span></span>
<span><span>    assert_eq!</span><span>(</span><span>loop</span><span> {  </span></span>
<span><span>        break</span><span> ğš‹ğš›ğšğšŠğš” ();  </span></span>
<span><span>    }, </span><span>42</span><span>);  </span></span>
<span><span>}</span></span></code></pre>
<p>These use unicode monospace characters, instead of normal ASCII characters, for identifiers, which donâ€™t break rustâ€™s rules of using keywords as identifiers.</p>
<h2 id="fishy">Fishy</h2>
<pre tabindex="0" data-language="rust"><code><span><span>fn</span><span> fishy</span><span>()</span><span> {</span></span>
<span><span>    assert_eq!</span><span>(</span></span>
<span><span>	    String</span><span>::</span><span>from</span><span>(</span><span>&#34;</span><span>&gt;&lt;&gt;</span><span>&#34;</span><span>),</span></span>
<span><span>        String</span><span>::</span><span>&lt;&gt;</span><span>::</span><span>from</span><span>::</span><span>&lt;&gt;(</span><span>&#34;</span><span>&gt;&lt;&gt;</span><span>&#34;</span><span>)</span><span>.</span><span>chars</span><span>::</span><span>&lt;&gt;()</span><span>.</span><span>rev</span><span>::</span><span>&lt;&gt;()</span><span>.</span><span>collect</span><span>::</span><span>&lt;</span><span>String</span><span>&gt;()</span></span>
<span><span>    );</span></span>
<span><span>}</span></span></code></pre>
<p>Rust uses the turbo fish syntax when adding generics and lifetimes. We can use empty angle brackets to explicitly specify empty generics.</p>
<h2 id="special-characters">Special characters</h2>
<pre tabindex="0" data-language="rust"><code><span><span>fn</span><span> special_characters</span><span>()</span><span> {</span></span>
<span><span>    let</span><span> val </span><span>=</span><span> !</span><span>((</span><span>|</span><span>(</span><span>..</span><span>)</span><span>:</span><span>(_,_),(</span><span>|</span><span>__</span><span>@</span><span>_</span><span>|</span><span>__)</span><span>|</span><span>__)((</span><span>&amp;*</span><span>&#34;</span><span>\\</span><span>&#34;</span><span>,</span><span>&#39;</span><span>ğŸ¤”</span><span>&#39;</span><span>)</span><span>/**/</span><span>,{})</span><span>==</span><span>{</span><span>&amp;</span><span>[</span><span>..=..</span><span>][</span><span>..</span><span>];})</span><span>//</span></span>
<span><span>    ;</span></span>
<span><span>    assert!</span><span>(</span><span>!</span><span>val);</span></span>
<span><span>}</span></span></code></pre>
<p>Letâ€™s decode the right expression:</p>
<pre tabindex="0" data-language="rust"><code><span><span>let</span><span> val </span><span>=</span><span> &amp;</span><span>[</span><span>..=..</span><span>][</span><span>..</span><span>];</span></span></code></pre>
<p>We create a reference to a slice containing a range <code>&amp;[..=..]</code>, then we take a full slice of that.</p>
<p>Now for the left expression:</p>
<pre tabindex="0" data-language="rust"><code><span><span>let</span><span> val </span><span>=</span><span> (</span><span>|</span><span>(</span><span>..</span><span>)</span><span>:</span><span>(_,_),(</span><span>|</span><span>__</span><span>@</span><span>_</span><span>|</span><span>__)</span><span>|</span><span>__)((</span><span>&amp;*</span><span>&#34;</span><span>\\</span><span>&#34;</span><span>,</span><span>&#39;</span><span>ğŸ¤”</span><span>&#39;</span><span>)</span><span>/**/</span><span>,{});</span></span></code></pre>
<p>We have a closure with two arguments, the first argument is a tuple, with auto-inferred types.</p>
<pre tabindex="0" data-language="rust"><code><span><span>let</span><span> val </span><span>=</span><span> |</span><span>(</span><span>..</span><span>)</span><span>:</span><span>(_,_)</span><span>|</span><span>{};</span></span></code></pre>
<p>The second argument is a closure which has an <a href="https://doc.rust-lang.org/book/ch19-03-pattern-syntax.html#-bindings">at binding</a>, the variable <code>__</code> is bound to a wildcard pattern (<code>_</code>), which will match anything.</p>
<pre tabindex="0" data-language="rust"><code><span><span>let</span><span> val </span><span>=</span><span> |</span><span>(</span><span>..</span><span>)</span><span>:</span><span>(_,_),(</span><span>|</span><span>__</span><span>@</span><span>_</span><span>|</span><span>__)</span><span>|</span><span>{};</span></span></code></pre>
<p>Then we immediately call that closure, passing in a tuple with a string and a char, and an empty block.</p>
<pre tabindex="0" data-language="rust"><code><span><span>let</span><span> val </span><span>=</span><span> (</span><span>|</span><span>(</span><span>..</span><span>)</span><span>:</span><span>(_,_),(</span><span>|</span><span>__</span><span>@</span><span>_</span><span>|</span><span>__)</span><span>|</span><span>)((</span><span>&amp;*</span><span>&#34;</span><span>\\</span><span>&#34;</span><span>,</span><span>&#39;</span><span>ğŸ¤”</span><span>&#39;</span><span>),{})</span></span></code></pre>
<h2 id="match">Match</h2>
<pre tabindex="0" data-language="rust"><code><span><span>fn</span><span> r#match</span><span>()</span><span> {</span></span>
<span><span>    let</span><span> val</span><span>:</span><span> () </span><span>=</span><span> match</span><span> match</span><span> match</span><span> match</span><span> match</span><span> () {</span></span>
<span><span>        () </span><span>=&gt;</span><span> ()</span></span>
<span><span>    } {</span></span>
<span><span>        () </span><span>=&gt;</span><span> ()</span></span>
<span><span>    } {</span></span>
<span><span>        () </span><span>=&gt;</span><span> ()</span></span>
<span><span>    } {</span></span>
<span><span>        () </span><span>=&gt;</span><span> ()</span></span>
<span><span>    } {</span></span>
<span><span>        () </span><span>=&gt;</span><span> ()</span></span>
<span><span>    };</span></span>
<span><span>    assert_eq!</span><span>(val, ());</span></span>
<span><span>}</span></span></code></pre>
<p>This is just matching nested <code>match</code> statements.</p>
<h2 id="match-nested-if">Match nested if</h2>
<pre tabindex="0" data-language="rust"><code><span><span>fn</span><span> match_nested_if</span><span>()</span><span> {</span></span>
<span><span>    let</span><span> val </span><span>=</span><span> match</span><span> () {</span></span>
<span><span>        () </span><span>if</span><span> if</span><span> if</span><span> if</span><span> true</span><span> {</span><span>true</span><span>} </span><span>else</span><span> {</span><span>false</span><span>} {</span><span>true</span><span>} </span><span>else</span><span> {</span><span>false</span><span>} {</span><span>true</span><span>} </span><span>else</span><span> {</span><span>false</span><span>} </span><span>=&gt;</span><span> true</span><span>,</span></span>
<span><span>        _ </span><span>=&gt;</span><span> false</span><span>,</span></span>
<span><span>    };</span></span>
<span><span>    assert!</span><span>(val);</span></span>
<span><span>}</span></span></code></pre>
<p>This is a <a href="https://doc.rust-lang.org/rust-by-example/flow_control/match/guard.html"><code>match guard</code></a> with nested <code>if</code> statements.</p>
<h2 id="function">Function</h2>
<pre tabindex="0" data-language="rust"><code><span></span>
<span><span>fn</span><span> function</span><span>()</span><span> {</span></span>
<span><span>    struct</span><span> foo;</span></span>
<span><span>    impl</span><span> Deref</span><span> for</span><span> foo {</span></span>
<span><span>        type</span><span> Target</span><span> =</span><span> fn</span><span>() </span><span>-&gt;</span><span> Self</span><span>;</span></span>
<span><span>        fn</span><span> deref</span><span>(</span><span>&amp;</span><span>self</span><span>)</span><span> -&gt;</span><span> &amp;</span><span>Self</span><span>::</span><span>Target</span><span> {</span></span>
<span><span>            &amp;</span><span>((</span><span>||</span><span> foo) </span><span>as</span><span> _)</span></span>
<span><span>        }</span></span>
<span><span>    }</span></span>
<span><span>    let</span><span> foo </span><span>=</span><span> foo () ()() ()()() ()()()() ()()()()();</span></span>
<span><span>}</span></span></code></pre>
<p>The <code>Deref</code> trait is used when a type can be implicitly coerced into another type, itâ€™s usually used by smart pointers so they can be implicitly used at the underlying type.</p>
<p>We implement <code>Deref</code> for foo into a function pointer that returns <code>foo</code>, which means we can call that foo again recursively.</p>
<h2 id="bathroom-stall">Bathroom stall</h2>
<pre tabindex="0" data-language="rust"><code><span><span>fn</span><span> bathroom_stall</span><span>()</span><span> {</span></span>
<span><span>    let</span><span> mut</span><span> i </span><span>=</span><span> 1</span><span>;</span></span>
<span><span>    matches!</span><span>(</span><span>2</span><span>, _</span><span>|</span><span>_</span><span>|</span><span>_</span><span>|</span><span>_</span><span>|</span><span>_</span><span>|</span><span>_ </span><span>if</span><span> (i</span><span>+=</span><span>1</span><span>) </span><span>!=</span><span> (i</span><span>+=</span><span>1</span><span>));</span></span>
<span><span>    assert_eq!</span><span>(i, </span><span>13</span><span>);</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>In a match arm multiple patterns can be matched in one arm, separated by <code>|</code>.</p>
<pre tabindex="0" data-language="rust"><code><span><span>let</span><span> foo </span><span>=</span><span> &#39;</span><span>a</span><span>&#39;</span><span>;  </span></span>
<span><span>match</span><span> foo {   </span></span>
<span><span>	&#39;</span><span>a</span><span>&#39;</span><span>..</span><span>&#39;</span><span>c</span><span>&#39;</span><span>|</span><span>&#39;</span><span>x</span><span>&#39;</span><span>..</span><span>&#39;</span><span>z</span><span>&#39;</span><span> =&gt;</span><span> {}  </span></span>
<span><span>    _ </span><span>=&gt;</span><span> {}  </span></span>
<span><span>}</span></span></code></pre>
<p>The <a href="https://doc.rust-lang.org/nightly/core/macro.matches.html"><code>matches!</code></a> macro has the same syntax as a match statement so we can also chain multiple patterns, even if those are wildcard patterns.</p>
<pre tabindex="0" data-language="rust"><code><span><span>matches!</span><span>((),_</span><span>|</span><span>_</span><span>|</span><span>_</span><span>|</span><span>_</span><span>|</span><span>_</span><span>|</span><span>_)</span></span></code></pre>
<pre tabindex="0" data-language="rust"><code><span><span>matches!</span><span>(</span><span>2</span><span>, _</span><span>|</span><span>_</span><span>|</span><span>_</span><span>|</span><span>_</span><span>|</span><span>_</span><span>|</span><span>_ </span><span>if</span><span> (i</span><span>+=</span><span>1</span><span>) </span><span>!=</span><span> (i</span><span>+=</span><span>1</span><span>));</span></span></code></pre>
<p>We have six different patterns here, which all do the same thing: we check if <code>i +=1 != i += 1</code>, which increments it twice, so each iteration is incrementing <code>i</code> by 2. <code>6 x 2 = 12</code> plus 1 (the initial value) and the final value is 13 so the assert <code>assert_eq!(i,13)</code> is true. The <code>match!(2,..)</code> doesnâ€™t panic because itâ€™s a wildcard pattern so any value could have been used. The if statement is always going to be false because the right expression will always be one more than the left so it will run until all the patterns have been tried.</p>
<h2 id="closure-matching">Closure matching</h2>
<pre tabindex="0" data-language="rust"><code><span><span>fn</span><span> closure_matching</span><span>()</span><span> {</span></span>
<span><span>    let</span><span> x </span><span>=</span><span> |</span><span>_</span><span>|</span><span> Some</span><span>(</span><span>1</span><span>);</span></span>
<span><span>    let</span><span> (</span><span>|</span><span>x</span><span>|</span><span> x) </span><span>=</span><span> match</span><span> x</span><span>(</span><span>..</span><span>) {</span></span>
<span><span>        |</span><span>_</span><span>|</span><span> Some</span><span>(</span><span>2</span><span>) </span><span>=&gt;</span><span> |</span><span>_</span><span>|</span><span> Some</span><span>(</span><span>3</span><span>),</span></span>
<span><span>        |</span><span>_</span><span>|</span><span> _ </span><span>=&gt;</span><span> unreachable!</span><span>(),</span></span>
<span><span>    };</span></span>
<span><span>    assert!</span><span>(</span><span>matches!</span><span>(</span><span>x</span><span>(</span><span>..</span><span>), </span><span>|</span><span>_</span><span>|</span><span> Some</span><span>(</span><span>4</span><span>)));</span></span>
<span><span>}</span></span></code></pre>
<p><code>x</code> is a closure that takes in a parameter with an unspecified type, which will be inferred through its usage. Next we <code>match x(..)</code> which makes the type of the closure <code>RangeFull</code>. It looks like weâ€™re matching closures but itâ€™s really just multiple wildcard patterns.</p>
<p>The numbers also donâ€™t matter even though it seems as though the function is being incremented each time, since itâ€™s a wildcard anything would match.</p>
<h2 id="return-already">Return already</h2>
<pre tabindex="0" data-language="rust"><code><span><span>fn</span><span> return_already</span><span>()</span><span> -&gt;</span><span> impl</span><span> std</span><span>::</span><span>fmt</span><span>::</span><span>Debug</span><span> {</span></span>
<span><span>    loop</span><span> {</span></span>
<span><span>        return</span><span> !!!!!!!</span></span>
<span><span>        break</span><span> !!!!!!</span><span>1111</span></span>
<span><span>    }</span></span>
<span><span>}</span></span></code></pre>
<p>The <code>break</code> expression is repeatedly applying a <a href="https://doc.rust-lang.org/std/ops/trait.Not.html"><code>not</code></a> operation on an integer, while the <code>return expression</code> is also repeatedly applying a <code>not</code> operation on the <code>break</code> expression.</p>
<h2 id="fake-macros">Fake macros</h2>
<pre tabindex="0" data-language="rust"><code><span><span>fn</span><span> fake_macros</span><span>()</span><span> -&gt;</span><span> impl</span><span> std</span><span>::</span><span>fmt</span><span>::</span><span>Debug</span><span> {</span></span>
<span><span>    loop</span><span> {</span></span>
<span><span>        if</span><span>!</span><span> {</span></span>
<span><span>            match</span><span>!</span><span> (</span></span>
<span><span>                break</span><span>!</span><span> {</span></span>
<span><span>                    return</span><span>!</span><span> {</span></span>
<span><span>                        1337</span></span>
<span><span>                    }</span></span>
<span><span>                }</span></span>
<span><span>            ) {</span></span>
<span><span>            }</span></span>
<span><span>        } {</span></span>
<span><span>        }</span></span>
<span><span>    }</span></span>
<span><span>}</span></span></code></pre>
<p>Letâ€™s isolate the return statement:</p>
<pre tabindex="0" data-language="rust"><code><span><span>fn</span><span> fake_macros</span><span>()</span><span> -&gt;</span><span> impl</span><span> std</span><span>::</span><span>fmt</span><span>::</span><span>Debug</span><span>{</span></span>
<span><span>	return</span><span>!</span><span> { </span><span>1337</span><span> }</span></span>
<span><span>}</span></span></code></pre>
<p>This is doing a <code>not</code> operation on the inner expression. Next we wrap that expression in a loop.</p>
<pre tabindex="0" data-language="rust"><code><span><span>fn</span><span> fake_macros</span><span>()</span><span> -&gt;</span><span> impl</span><span> std</span><span>::</span><span>fmt</span><span>::</span><span>Debug</span><span>{</span></span>
<span><span>	loop</span><span> {</span></span>
<span><span>		break</span><span>!</span><span> {</span></span>
<span><span>			return</span><span>!</span><span> {</span></span>
<span><span>				1337</span></span>
<span><span>			}</span></span>
<span><span>		}</span></span>
<span><span>	}</span></span>
<span><span>}</span></span></code></pre>
<p>The <code>break!{ }</code> is also doing a <code>not</code> operation on the <code>return! { 1337 }</code>, which has the type <code>!</code>. Now the functions return type is inferred from both the loop and the return statement. Divergent function?</p>
<p>Next we wrap everything inside the loop in a match statement</p>
<pre tabindex="0" data-language="rust"><code><span><span>fn</span><span> fake_macros</span><span>()</span><span> -&gt;</span><span> impl</span><span> std</span><span>::</span><span>fmt</span><span>::</span><span>Debug</span><span>{</span></span>
<span><span>	loop</span><span> {</span></span>
<span><span>		match</span><span>!</span><span>(</span></span>
<span><span>			break</span><span>!</span><span> {</span></span>
<span><span>				return</span><span>!</span><span> {</span></span>
<span><span>					1337</span></span>
<span><span>				}</span></span>
<span><span>			}</span></span>
<span><span>		){</span></span>
<span><span>		</span></span>
<span><span>		}</span></span>
<span><span>	}</span></span>
<span><span>}</span></span></code></pre>
<p>We donâ€™t have to add any patterns to the match statement since weâ€™re matching <code>never</code>. And finally we wrap this in an <code>if</code> statement.</p>
<pre tabindex="0" data-language="rust"><code><span><span>fn</span><span> fake_macros</span><span>()</span><span> -&gt;</span><span> impl</span><span> std</span><span>::</span><span>fmt</span><span>::</span><span>Debug</span><span>{</span></span>
<span><span>	loop</span><span> {</span></span>
<span><span>		if</span><span>!</span><span> {</span></span>
<span><span>			match</span><span>!</span><span> (</span></span>
<span><span>				break</span><span>!</span><span> {</span></span>
<span><span>					return</span><span>!</span><span> {</span></span>
<span><span>						1337</span></span>
<span><span>					}</span></span>
<span><span>				}</span></span>
<span><span>			)</span></span>
<span><span>		} {</span></span>
<span><span>		}</span></span>
<span><span>	}</span></span>
<span><span>}</span></span></code></pre>
<p>So to sum it up:</p>
<ul>
<li><code>return! { 1337 }</code> makes the return type of the function an <code>i32</code>, which implements <code>Debug</code></li>
<li><code>break! { ... }</code> makes the return type of the loop <code>!</code>, because of the inner <code>return</code>, which also implements <code>Debug</code></li>
<li>We match the break statement and leave out the patterns since it is <code>!</code></li>
<li>Wrap the match statement in an if statement</li>
</ul> </article></div>
  </body>
</html>
