<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://frankchiarulli.com/blog/building-the-rcade/">Original</a>
    <h1>RCade: Building a Community Arcade Cabinet</h1>
    
    <div id="readability-page-1" class="page"><div><p>The RCade is a custom arcade cabinet at the <a target="_blank" href="https://www.recurse.com/">Recurse Center</a> that runs games made by the community. It has a real CRT running at 320x240, a custom graphics card, custom input controllers with spinners, and a deployment system where any Recurser can ship a game to it just by pushing to GitHub. There’s also a web player and local simulator so remote Recursers can play and build for it from anywhere.</p>
<p>There are now 44+ games on it. This is the story of how it came together.</p>
<figure><img src="https://frankchiarulli.com/building-the-rcade/complete-rcade.jpg" alt="The complete RCade arcade cabinet with CRT display and glowing marquee"/><figcaption>The RCade</figcaption></figure>
<hr/>
<p>At the <a target="_blank" href="https://www.recurse.com/">Recurse Center</a>, I met <a target="_blank" href="https://greg.technology">Greg Sadetsky</a> and saw his <a target="_blank" href="https://github.com/gregsadetsky/rapidriteros">Rapid Riter</a> project. The Rapid Riter is an LED display from the 1980s, 96 pixels wide by 38 pixels high. Greg hung it on the wall in the hub and built a way for Recursers to contribute images and animations to it. The simplicity of the display and the fact that it lives in the physical space means both in-person and remote Recursers can leave their mark on the community.</p>
<figure><img src="https://frankchiarulli.com/building-the-rcade/rapid-riter.jpg" alt="The Rapid Riter displaying RECURSE! on the wall at the Recurse Center"/><figcaption>The Rapid Riter hanging in the hub at the Recurse Center</figcaption></figure>
<p>I love the constraints. There’s something about retro hardware and limited resolution that gets people’s creative juices flowing in a way that a blank canvas doesn’t. People really want to build for it.</p>
<p>I loved my time at RC and really wanted to give back in the same way that Greg did. <a target="_blank" href="https://www.evakhoury.com">Eva Khoury</a>, who runs Operations at RC and also coordinates <a target="_blank" href="https://boshis.place">Boshi’s Place</a>, an indie games and arts space in Brooklyn, was super encouraging about the idea from the start. I wanted to build something similar to the Rapid Riter: the RCade, a custom arcade cabinet that runs games made by the community.</p>
<p>The project had three goals:</p>
<ol>
<li>Build hardware that feels like a real arcade machine</li>
<li>Make deployment so easy that someone who has never made a game can ship one in minutes</li>
<li>Create something that connects remote and in-person Recursers</li>
</ol>
<figure><img src="https://frankchiarulli.com/building-the-rcade/cabinet-arrives-at-rc.jpg" alt="The cabinet arrives at the Recurse Center"/><figcaption>The cabinet arrives at the Recurse Center</figcaption></figure>
<h2 id="part-1-the-hardware"><a target="_self" href="#part-1-the-hardware">Part 1: The Hardware</a></h2>
<h3 id="starting-with-a-bare-crt"><a target="_self" href="#starting-with-a-bare-crt">Starting with a Bare CRT</a></h3>
<p>The project started with me scouring Facebook Marketplace and Craigslist, bombarding Greg with
listing after listing. We eventually found a gutted cabinet with an 80s CRT that had all its
wires cut. Just a bare tube, no connectors, no interface. I wanted to keep the original CRT
rather than swap in an LCD for the same reason the Rapid Riter works so well: retro hardware and
its constraints inspire people.</p>

<p>The first challenge was getting any video out of it at all. This turned out to be the hardest part of the entire project.</p>
<h3 id="understanding-arcade-monitor-signals"><a target="_self" href="#understanding-arcade-monitor-signals">Understanding Arcade Monitor Signals</a></h3>
<p>Classic arcade CRTs are quite different from modern VGA monitors. Standard VGA runs at 31.5kHz horizontal sync, meaning it draws 31,500 lines per second. Arcade monitors run at 15.7kHz, roughly half that rate. So unfortunately you can’t just plug a VGA cable into an arcade monitor: the monitor’s horizontal deflection circuitry physically cannot sweep the electron beam fast enough.</p>
<p>At 60 frames per second with a 15.7kHz horizontal rate, you get about 262 lines per frame. Subtract the vertical blanking interval and you’re left with roughly 240 visible lines, which is why classic arcade games run at 320x240 or similar resolutions.</p>
<p>VGA signals at these timings also use different sync polarities and timing parameters (front porch, back porch, sync pulse width) than what off-the-shelf adapters expect. Most display adapters refuse to go below 640x480. We needed something custom.</p>
<h3 id="tracing-the-pinout"><a target="_self" href="#tracing-the-pinout">Tracing the Pinout</a></h3>
<p>The first challenge was figuring out which wires went where. <a target="_blank" href="https://jspha.com/">Joseph Abrahamson</a> and I used an oscilloscope to trace the signals from the tube’s neck board. We were looking for the RGB color lines, horizontal sync, vertical sync, and ground connections.</p>

<p>Once we identified the pinout, we wired up a JAMMA connector. JAMMA (Japan Amusement Machine and Marketing Association) is the standard edge connector used in arcade cabinets. It carries video (active-low RGB with composite sync), audio, power, and player controls through a single 56-pin connector. Most arcade games from the late 80s through the 2000s used JAMMA, which means if you have a JAMMA-compatible monitor setup, you can swap games easily.</p>
<p>The moment we got any video on the screen was the most exciting part of the project. A flickering, incorrectly timed mess of pixels, but pixels nonetheless.</p>
<figure><img src="https://frankchiarulli.com/building-the-rcade/first-video.jpg" alt="First video output on the CRT"/><figcaption>First video output on the CRT, a mess of pixels, but pixels!</figcaption></figure>
<h3 id="the-vga666-adapter"><a target="_self" href="#the-vga666-adapter">The VGA666 Adapter</a></h3>
<p>With JAMMA working, we needed a way to drive the monitor from a computer. <a target="_blank" href="https://wobblybits.blog">David Allen Feil</a> and I got a <a target="_blank" href="https://github.com/fenlogic/vga666">vga666</a> adapter running on a Raspberry Pi. The vga666 is an open-source design that uses the Pi’s GPIO pins to output analog VGA signals through a resistor DAC.</p>
<p>The vga666 was designed for small TFT displays, but because VGA is just analog RGB plus sync signals, it can drive any monitor that accepts the right timings. We needed two configuration files.</p>
<p>An X11 configuration file at <code>/etc/X11/xorg.conf.d/99-vga666.conf</code>:</p>
<pre><code>Section &#34;Device&#34;
    Identifier  &#34;VGA666&#34;
    Driver      &#34;fbdev&#34;
    Option      &#34;fbdev&#34; &#34;/dev/fb0&#34;
EndSection
</code></pre>
<p>And device tree overlay parameters in <code>/boot/config.txt</code> for the exact timing:</p>
<pre><code>dtoverlay=vc4-kms-dpi-generic
dtparam=clock-frequency=5700000,hactive=320,hfp=9,hsync=16,hbp=18
dtparam=vactive=240,vfp=2,vsync=3,vbp=17
dtparam=hsync-invert,vsync-invert
</code></pre>
<p>Breaking down the timing parameters:</p>
<ul>
<li><code>clock-frequency=5700000</code>: 5.7 MHz pixel clock</li>
<li><code>hactive=320</code>: 320 visible pixels per line</li>
<li><code>hfp=9, hsync=16, hbp=18</code>: horizontal front porch, sync pulse, and back porch (total line = 320+9+16+18 = 363 pixels)</li>
<li><code>vactive=240</code>: 240 visible lines</li>
<li><code>vfp=2, vsync=3, vbp=17</code>: vertical front porch, sync pulse, and back porch (total frame = 240+2+3+17 = 262 lines)</li>
<li><code>hsync-invert, vsync-invert</code>: active-low sync polarities, which arcade monitors expect</li>
</ul>
<p>At a 5.7 MHz pixel clock with 363 pixels per line, we get 15,702 lines per second (5,700,000 / 363 ≈ 15,702 Hz). With 262 lines per frame, that’s ~60 frames per second (15,702 / 262 ≈ 59.9 Hz). These timings fall within what a 15kHz arcade monitor can handle.</p>
<p>The setup worked, but the vga666 only supports 18-bit color (6 bits per channel), a limitation of the Raspberry Pi’s GPIO interface. With only 64 levels per color channel instead of 256, you get visible color banding, especially in gradients.</p>
<p>For the games people were making at this point, it was fine. But we wanted better.</p>

<h3 id="stephens-custom-display-adapter"><a target="_self" href="#stephens-custom-display-adapter">Stephen’s Custom Display Adapter</a></h3>
<p><a target="_blank" href="https://www.scd31.com/">Stephen D</a> took on the challenge of building a proper display adapter. We wanted to replace the Raspberry Pi 5 with a more capable computer that could run WebGPU. The Pi’s GPIO-based video output tied us to that specific hardware. A USB display adapter would let us use any laptop or mini PC.</p>
<p>Stephen wrote an <a target="_blank" href="https://www.scd31.com/posts/building-an-arcade-display-adapter">amazing in-depth blog post</a> about the entire journey, including multiple failed attempts, designing custom PCBs, writing PIO assembly for the RP2040, implementing the GUD (Generic USB Display) protocol, and eventually landing on an STM32H750-based solution with precision DACs. I highly recommend reading it.</p>
<p>The result: 24-bit color at 60fps with no visible latency. Words can’t describe how amazing the before and after looks. The 18-bit to 24-bit jump eliminated all the color banding we’d been living with.</p>
<h3 id="custom-input-controllers"><a target="_self" href="#custom-input-controllers">Custom Input Controllers</a></h3>
<p>For controls, I worked with <a target="_blank" href="https://github.com/abettercoach">Iris E Fernandez Valdes</a> and <a target="_blank" href="https://anjana.dev/">Anjana Vakil</a> on custom input boards using RP2040 microcontrollers.</p>
<p>Each player has:</p>
<ul>
<li>One 8-way joystick (up/down/left/right as digital switches)</li>
<li>Two action buttons</li>
<li>One spinner (rotary encoder found on games like Tempest or Arkanoid)</li>
</ul>
<p>Eva helped a lot when we were figuring out the control design, and was kind enough to let me take over a corner of the hub semi-permanently, both for building the cabinet and now as its permanent home. They also showed me the <a target="_blank" href="https://www.deathbyaudioarcade.com/wondercab">Wondercab</a>, an open-source arcade cabinet design, which influenced how we thought about the controls.</p>
<p>We added the spinners after playing <a target="_blank" href="https://hoverburger.com">Hoverburger</a> at <a target="_blank" href="https://www.wonderville.nyc">Wonderville</a> in Brooklyn. The spinner controls felt so good that we knew we had to have them on the RCade. If you’re in NYC, definitely check out Wonderville, it’s an incredible arcade bar full of indie games.</p>
<p>The firmware reads the digital inputs and the quadrature signals from the rotary encoders, debounces everything, and presents itself to the host as a standard USB HID gamepad. This means the cabinet works with any operating system without custom drivers.</p>
<p>The spinners are weighted knobs that you can spin freely in either direction. Inside, a rotary encoder produces two square wave signals (A and B) that are 90 degrees out of phase. By counting the edges and checking which signal leads, you can determine both the speed and direction of rotation. We sample these at 1kHz in firmware and report the accumulated counts as an axis value in the HID reports.</p>
<figure><img src="https://frankchiarulli.com/building-the-rcade/controller-wiring.jpg" alt="Inside wiring of the controller panel showing joysticks, buttons, and spinners"/><figcaption>Inside the controller panel: joysticks, buttons, and spinners for two players</figcaption></figure>
<h3 id="the-marquee"><a target="_self" href="#the-marquee">The Marquee</a></h3>
<p>We also added a marquee to the top of the cabinet using two HUB75 RGB LED matrices. They fit perfectly in the space where an original arcade marquee would go. David helped me drill out the cabinet to mount them, and Stephen designed the RCade logo that now glows above the screen.</p>

<p>For the cabinet’s exterior, we decided against a permanent design. Instead, we wrapped it in chalkboard vinyl so that Recursers can draw on it, add to the design, and change it over time. The cabinet itself becomes a collaborative art piece. Joseph and I went a little overboard and bought <a target="_blank" href="https://alumni.berkeley.edu/california-magazine/online/chalk-market-where-mathematicians-go-get-good-stuff/">Hagoromo chalk</a> for it, because only the best for Recurse.</p>
<h2 id="part-2-the-software"><a target="_self" href="#part-2-the-software">Part 2: The Software</a></h2>
<p>With the hardware working, <a target="_blank" href="https://rose.hall.ly">Rose</a> and I turned to the software. We both care deeply about developer experience, and our goal was that someone who had never made a game before should be able to create one and see it running on real hardware in under five minutes. Ideally without the need to set up any deployment scripts or manage any secrets.</p>
<h3 id="the-cli-npm-create-rcadelatest"><a target="_self" href="#the-cli-npm-create-rcadelatest">The CLI: <code>npm create rcade@latest</code></a></h3>
<p>The <code>create-rcade</code> package is a scaffolding tool that sets up a complete game project. When you run it, it asks you a series of questions:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="sh" data-theme="Overnight"><code data-language="sh" data-theme="Overnight"><span data-line=""><span>$</span><span> npm</span><span> create</span><span> rcade@latest</span></span>
<span data-line=""> </span>
<span data-line=""><span>?</span><span> Enter game identifier (</span><span>e.g.</span><span> my-game</span><span>): space-blaster</span></span>
<span data-line=""><span>?</span><span> Enter display name: Space Blaster</span></span>
<span data-line=""><span>?</span><span> Enter game description: An epic space shooter</span></span>
<span data-line=""><span>?</span><span> Game visibility: Public (</span><span>Everyone</span><span> can</span><span> play!</span><span>)</span></span>
<span data-line=""><span>?</span><span> Versioning:</span><span> Automatic</span><span> (version </span><span>is</span><span> incremented</span><span> every</span><span> push</span><span>)</span></span>
<span data-line=""><span>?</span><span> Starting template: Vanilla (</span><span>JavaScript</span><span>)</span></span>
<span data-line=""><span>?</span><span> Package manager: npm</span></span></code></pre></figure>
<p>Based on your answers, it generates:</p>
<ol>
<li>A game project with your chosen template (vanilla JS, TypeScript, p5.js, or Rust/WASM)</li>
<li>An <code>rcade.manifest.json</code> file describing your game</li>
<li>A <code>.github/workflows/deploy.yaml</code> file for automatic deployment</li>
<li>Development tooling (Vite for hot reloading)</li>
</ol>
<p>The generated workflow file looks like this:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="yaml" data-theme="Overnight"><code data-language="yaml" data-theme="Overnight"><span data-line=""><span>name</span><span>:</span><span> Deploy to RCade</span></span>
<span data-line=""> </span>
<span data-line=""><span>on</span><span>:</span></span>
<span data-line=""><span>  push</span><span>:</span></span>
<span data-line=""><span>    branches</span><span>:</span></span>
<span data-line=""><span>      -</span><span> main</span></span>
<span data-line=""> </span>
<span data-line=""><span>jobs</span><span>:</span></span>
<span data-line=""><span>  build-and-deploy</span><span>:</span></span>
<span data-line=""><span>    name</span><span>:</span><span> Build and Deploy to RCade</span></span>
<span data-line=""><span>    runs-on</span><span>:</span><span> ubuntu-latest</span></span>
<span data-line=""><span>    permissions</span><span>:</span></span>
<span data-line=""><span>      contents</span><span>:</span><span> read</span></span>
<span data-line=""><span>      id-token</span><span>:</span><span> write</span></span>
<span data-line=""><span>    steps</span><span>:</span></span>
<span data-line=""><span>      -</span><span> name</span><span>:</span><span> Checkout</span></span>
<span data-line=""><span>        uses</span><span>:</span><span> actions/checkout@v4</span></span>
<span data-line=""> </span>
<span data-line=""><span>      -</span><span> name</span><span>:</span><span> Setup Node</span></span>
<span data-line=""><span>        uses</span><span>:</span><span> actions/setup-node@v4</span></span>
<span data-line=""> </span>
<span data-line=""><span>      -</span><span> name</span><span>:</span><span> Install dependencies</span></span>
<span data-line=""><span>        run</span><span>:</span><span> npm ci</span></span>
<span data-line=""> </span>
<span data-line=""><span>      -</span><span> name</span><span>:</span><span> Build</span></span>
<span data-line=""><span>        run</span><span>:</span><span> npm run build</span></span>
<span data-line=""> </span>
<span data-line=""><span>      -</span><span> name</span><span>:</span><span> Deploy to RCade</span></span>
<span data-line=""><span>        uses</span><span>:</span><span> fcjr/rcade/action-deploy@main</span></span></code></pre></figure>
<p>The key line is <code>permissions: id-token: write</code>. This enables GitHub’s OpenID Connect token generation.</p>
<h3 id="authentication-with-github-oidc"><a target="_self" href="#authentication-with-github-oidc">Authentication with GitHub OIDC</a></h3>
<p>Traditional CI/CD authentication requires storing secrets (API keys, tokens) in your repository settings. This is annoying to set up and creates security risks if secrets are leaked.</p>
<p>GitHub Actions has a better approach: OIDC (OpenID Connect) tokens. When a workflow runs with <code>id-token: write</code> permission, it can request a cryptographically signed JWT from GitHub. This JWT contains claims about the workflow:</p>
<ul>
<li>Which repository the action is running in</li>
<li>Which branch triggered it</li>
<li>Who owns the repository</li>
<li>The workflow file path and ref</li>
</ul>
<p>The RCade deployment action requests one of these tokens and sends it to the RCade API. The API:</p>
<ol>
<li>Validates the JWT signature against GitHub’s public keys</li>
<li>Extracts the repository owner (your GitHub username)</li>
<li>Checks the <a target="_blank" href="https://www.recurse.com/">Recurse Center</a> API to see if that GitHub username is linked to an RC profile</li>
<li>If yes, allows the deployment</li>
</ol>
<p>This is “passwordless” authentication: no secrets are stored anywhere, yet we can cryptographically verify that a deployment came from a GitHub Action running in a repository owned by a Recurser. The tokens are short-lived (valid for a few minutes) and scoped to the specific workflow run.</p>
<p>The <a target="_blank" href="https://www.recurse.com/">Recurse Center</a> is a trusted community. Everyone who has access has been through the admissions process. The OIDC flow extends that trust boundary to the deployment pipeline without requiring any manual configuration.</p>
<p>Currently, only Recursers can add games to the RCade. I hope to create a public section of the site soon.</p>
<h3 id="the-sandbox"><a target="_self" href="#the-sandbox">The Sandbox</a></h3>
<p>When you’re running community-created code on shared hardware, security matters. A malicious or buggy game shouldn’t be able to:</p>
<ul>
<li>Access other games’ data</li>
<li>Make network requests to external servers</li>
<li>Persist data that survives across game sessions</li>
<li>Read input events intended for other applications</li>
<li>Crash or hang the cabinet</li>
</ul>
<p>Games on the RCade run in a sandboxed iframe with strict Content Security Policy headers:</p>
<p><strong>Blocked capabilities:</strong></p>
<ul>
<li><code>fetch()</code> and <code>XMLHttpRequest</code> to external URLs</li>
<li><code>localStorage</code>, <code>sessionStorage</code>, <code>indexedDB</code>, cookies</li>
<li><code>document.addEventListener(&#39;keydown&#39;, ...)</code> and other direct input APIs</li>
<li>WebSockets and WebRTC</li>
<li>Access to the parent frame (<code>window.parent</code>, <code>window.top</code>)</li>
</ul>
<p><strong>Allowed capabilities:</strong></p>
<ul>
<li>Canvas 2D and WebGL rendering</li>
<li>Web Audio API</li>
<li>Web Workers</li>
<li><code>requestAnimationFrame</code></li>
<li>All assets bundled with the game</li>
</ul>
<p>The iframe is loaded from a separate origin than the cabinet UI, so the same-origin policy provides additional isolation. The CSP headers explicitly block inline scripts, eval, and connections to non-allowlisted hosts.</p>
<h3 id="the-plugin-system"><a target="_self" href="#the-plugin-system">The Plugin System</a></h3>
<p>Since direct browser APIs are blocked, games read the arcade controls through plugins.</p>
<p><a target="_blank" href="https://rose.hall.ly">Rose</a> designed the plugin system. Plugins are trusted code that runs in a separate context and communicates with games through <code>postMessage</code> channels.</p>
<p>A game using the input plugin looks like this:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="javascript" data-theme="Overnight"><code data-language="javascript" data-theme="Overnight"><span data-line=""><span>import</span><span> {</span><span> PLAYER_1</span><span>,</span><span> PLAYER_2</span><span>,</span><span> SYSTEM </span><span>}</span><span> from</span><span> &#34;</span><span>@rcade/plugin-input-classic</span><span>&#34;</span><span>;</span></span>
<span data-line=""> </span>
<span data-line=""><span>function</span><span> gameLoop</span><span>()</span><span> {</span></span>
<span data-line=""><span>  if</span><span> (</span><span>PLAYER_1</span><span>.</span><span>DPAD</span><span>.</span><span>up</span><span>)</span><span> moveUp</span><span>();</span></span>
<span data-line=""><span>  if</span><span> (</span><span>PLAYER_1</span><span>.</span><span>DPAD</span><span>.</span><span>down</span><span>)</span><span> moveDown</span><span>();</span></span>
<span data-line=""><span>  if</span><span> (</span><span>PLAYER_1</span><span>.</span><span>DPAD</span><span>.</span><span>left</span><span>)</span><span> moveLeft</span><span>();</span></span>
<span data-line=""><span>  if</span><span> (</span><span>PLAYER_1</span><span>.</span><span>DPAD</span><span>.</span><span>right</span><span>)</span><span> moveRight</span><span>();</span></span>
<span data-line=""> </span>
<span data-line=""><span>  if</span><span> (</span><span>PLAYER_1</span><span>.</span><span>A</span><span>)</span><span> fire</span><span>();</span></span>
<span data-line=""><span>  if</span><span> (</span><span>PLAYER_1</span><span>.</span><span>B</span><span>)</span><span> jump</span><span>();</span></span>
<span data-line=""> </span>
<span data-line=""><span>  if</span><span> (</span><span>SYSTEM</span><span>.</span><span>ONE_PLAYER</span><span>)</span><span> startOnePlayerGame</span><span>();</span></span>
<span data-line=""><span>  if</span><span> (</span><span>SYSTEM</span><span>.</span><span>TWO_PLAYER</span><span>)</span><span> startTwoPlayerGame</span><span>();</span></span>
<span data-line=""> </span>
<span data-line=""><span>  requestAnimationFrame</span><span>(</span><span>gameLoop</span><span>);</span></span>
<span data-line=""><span>}</span></span></code></pre></figure>
<p>The <code>@rcade/plugin-input-classic</code> package looks like a normal npm import, but it’s actually a shim. At runtime, the RCade cabinet:</p>
<ol>
<li>Reads the game’s <code>rcade.manifest.json</code> to see which plugins it depends on</li>
<li>Loads the plugin code in a privileged context that can access the real input events</li>
<li>Sets up a <code>postMessage</code> channel between the plugin and the game iframe</li>
<li>The plugin sends input state updates through the channel</li>
<li>The game’s imported shim receives these updates and exposes them as the <code>PLAYER_1</code>, etc. objects</li>
</ol>
<p>Games only get access to plugins they declare in their manifest, so a game that doesn’t need spinner input doesn’t get it. We can add new plugins (persistence, networking, leaderboards) without changing the sandbox model. And during local development, the plugin shims can be backed by keyboard input instead of real arcade controls.</p>
<p>The manifest file declares dependencies:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="json" data-theme="Overnight"><code data-language="json" data-theme="Overnight"><span data-line=""><span>{</span></span>
<span data-line=""><span>  &#34;$schema&#34;</span><span>: </span><span>&#34;</span><span>https://rcade.dev/manifest.schema.json</span><span>&#34;</span><span>,</span></span>
<span data-line=""><span>  &#34;name&#34;</span><span>: </span><span>&#34;</span><span>space-blaster</span><span>&#34;</span><span>,</span></span>
<span data-line=""><span>  &#34;display_name&#34;</span><span>: </span><span>&#34;</span><span>Space Blaster</span><span>&#34;</span><span>,</span></span>
<span data-line=""><span>  &#34;description&#34;</span><span>: </span><span>&#34;</span><span>An epic space shooter</span><span>&#34;</span><span>,</span></span>
<span data-line=""><span>  &#34;visibility&#34;</span><span>: </span><span>&#34;</span><span>public</span><span>&#34;</span><span>,</span></span>
<span data-line=""><span>  &#34;authors&#34;</span><span>: { </span><span>&#34;display_name&#34;</span><span>: </span><span>&#34;</span><span>Your Name</span><span>&#34;</span><span> },</span></span>
<span data-line=""><span>  &#34;dependencies&#34;</span><span>: </span><span>[</span></span>
<span data-line=""><span>    { </span><span>&#34;name&#34;</span><span>: </span><span>&#34;</span><span>@rcade/input-classic</span><span>&#34;</span><span>, </span><span>&#34;version&#34;</span><span>: </span><span>&#34;</span><span>1.0.0</span><span>&#34;</span><span> }</span></span>
<span data-line=""><span>  ]</span></span>
<span data-line=""><span>}</span></span></code></pre></figure>
<h3 id="the-cabinet-software-stack"><a target="_self" href="#the-cabinet-software-stack">The Cabinet Software Stack</a></h3>
<p>The cabinet itself runs an Electron app. We originally tried Tauri, which would have been smaller and more efficient, but we ran into GPU acceleration issues on the Raspberry Pi and eventually gave up. Electron gives us a Chromium-based browser for rendering games plus Node.js for system integration (reading USB input devices, managing the game library, handling updates).</p>
<p>The stack:</p>
<ul>
<li><strong>Electron</strong>: Main application runtime</li>
<li><strong>SvelteKit</strong>: Game browser UI and menu system</li>
<li><strong>Node HID libraries</strong>: Reading input from the custom controllers</li>
<li><strong>Systemd service</strong>: Auto-start on boot, restart on crash</li>
</ul>
<p>Games are stored locally and synced from the RCade API. When someone deploys a new game, the cabinet receives a webhook notification, downloads the new build, and adds it to the library. No manual intervention required.</p>
<h3 id="the-web-player"><a target="_self" href="#the-web-player">The Web Player</a></h3>
<p>Games are also playable at <a target="_blank" href="https://rcade.dev">rcade.dev</a>, though the online player is still a work in progress. In the meantime, you can use the simulator and test games locally with <code>npx rcade@latest play</code>. This is important for remote Recursers: you can build a game, deploy it, and immediately play it in your emulator. You know people at RC are playing it on the real cabinet, even if you’re on the other side of the world.</p>
<p>The web player uses the same sandboxed iframe setup as the cabinet, with keyboard input mapped to the arcade controls (arrow keys for joystick, Z/X for buttons). Under the hood, it uses the Cache API to store game assets, which is probably worthy of a separate blog post once we’ve ironed out the kinks.</p>

<p>There are now 44+ games on the RCade, all created by Recursers. The <a target="_blank" href="https://github.com/rcade-community">rcade-community</a> GitHub organization maintains mirrors of every game ever deployed.</p>
<p>We’ve run game jams where people build and ship games in a single session. The scaffolding and deployment pipeline make this possible: you can go from zero to playable game on real hardware in minutes. <a target="_blank" href="https://greg.technology">Greg Sadetsky</a> even made a game in 5 minutes while hanging out at an Infra meetup.</p>
<h3 id="some-of-my-favorite-games"><a target="_self" href="#some-of-my-favorite-games">Some of My Favorite Games</a></h3>
<p><strong><a target="_blank" href="https://rcade.dev/games/nibbles">NIBBLES.BAS</a></strong> by <a target="_blank" href="https://purposefulserendipity.com">Joe</a> is a recreation of the original NIBBLES.BAS, but with a ton of beautiful easter eggs. My favorite: he built it in sub-pixels, so if you use the spinner knob it breaks out of the x/y grid.</p>
<p><strong><a target="_blank" href="https://rcade.dev/games/siggy-sketch">SIGGY SKETCH</a></strong> by <a target="_blank" href="https://github.com/abettercoach">Iris</a>, <a target="_blank" href="https://victoriaritvo.com">Victoria</a>, and <a target="_blank" href="https://anjana.dev/">Anjana</a> is a true-to-life implementation of an Etch A Sketch.</p>
<p><strong><a target="_blank" href="https://rcade.dev/games/cat-ignore">YOUR CAT</a></strong> by <a target="_blank" href="https://github.com/sllewely">Sarah</a> and <a target="_blank" href="https://nadiaheredia.com">Nadia</a> makes you understand what it’s like to own a cat.</p>
<p><strong><a target="_blank" href="https://rcade.dev/games/goose-chase">Goose Chase</a></strong> by <a target="_blank" href="https://clairefro.dev">Claire</a> has you scaring geese out of the room before they poop everywhere.</p>
<p><strong><a target="_blank" href="https://rcade.dev/games/one-two-three-soleil">ONE TWO THREE SOLEIL</a></strong> by <a target="_blank" href="https://github.com/panglesd">Paul-Elliot</a>. He literally added an OCaml template to the RCade just to build this game.</p>
<p><strong><a target="_blank" href="https://rcade.dev/games/bad-orchestra">BAD ORCHESTRA</a></strong> by <a target="_blank" href="https://www.henryfellerhoff.com">Henry</a> uses the spinners to adjust the pitch of instruments and is generally one of the funniest games to hear people play.</p>
<p><strong><a target="_blank" href="https://rcade.dev/games/posecade">POSECADE</a></strong> by <a target="_blank" href="https://clairekwong.com/">Claire</a> is a webcam-based dance partner game.</p>
<p><strong><a target="_blank" href="https://rcade.dev/games/let-it-rip">LET IT RIP</a></strong> by <a target="_blank" href="https://www.henryfellerhoff.com">Henry</a> and <a target="_blank" href="https://cysabi.github.io">Cyrene</a> is a PvP Beyblade-inspired game where you use the spinners to gain enough momentum to beat your opponent.</p>
<p>This is just a small selection. There are too many good games to list. Check out the <a target="_blank" href="https://rcade.dev/games">full library</a>.</p>
<h3 id="contributors"><a target="_self" href="#contributors">Contributors</a></h3>
<p>This project wouldn’t exist without contributions from:</p>
<ul>
<li><a target="_blank" href="https://rose.hall.ly">Rose Hall</a>: Plugin system architecture and cabinet software</li>
<li><a target="_blank" href="https://www.scd31.com/">Stephen D</a>: Custom 24-bit USB display adapter (hardware and firmware)</li>
<li><a target="_blank" href="https://jspha.com/">Joseph Abrahamson</a>, <a target="_blank" href="https://github.com/jm771">Jack Heard</a>, <a target="_blank" href="https://www.joelholmberg.com">Joel Holmberg</a>: Oscilloscope work, CRT wiring, and JAMMA connector</li>
<li><a target="_blank" href="https://github.com/abettercoach">Iris E Fernandez Valdes</a>: Custom input controller firmware</li>
<li><a target="_blank" href="https://wobblybits.blog">David Allen Feil</a>: vga666 adapter configuration and initial video output</li>
<li><a target="_blank" href="https://anjana.dev/">Anjana Vakil</a>: Custom input controller firmware</li>
<li><a target="_blank" href="https://greg.technology">Greg Sadetsky</a>: Inspiration (Rapid Riter) and contributions to the platform</li>
</ul>
<p>These are just a few of the people involved. Many more Recursers contributed ideas, tested hardware, playtested games, and helped shape the project along the way.</p>
<h3 id="what-made-it-work"><a target="_self" href="#what-made-it-work">What Made It Work</a></h3>
<p>The RCade exists because of a few things that came together.</p>
<p>RC gives you time and space to work on weird projects without business justification. The arcade cabinet had no product requirements, no user stories, no quarterly goals. It exists because it seemed like a cool thing to build.</p>
<p>But more than the project itself, I loved that the RCade gave me a reason to work with all these incredible people. It pulled me deeper into the community. There were two weeks of all-nighters with Rose to get ready for our first game jam, and many late nights with Joseph, David, and Stephen working on the hardware. These weren’t obligations. They were some of the best nights of my time at RC.</p>
<figure><img src="https://frankchiarulli.com/building-the-rcade/complete-rcade.jpg" alt="The complete RCade with the marquee glowing"/><figcaption>The complete RCade</figcaption></figure>
<p>The <a target="_blank" href="https://www.recurse.com/">Recurse Center</a> is a self-directed retreat for programmers where you can spend six or twelve weeks working on whatever interests you most, surrounded by curious and kind people doing the same. I did two back-to-back batches. I went in wanting to rediscover what I loved about programming, and I left having built something that brings joy to a community I care about and hope to be part of for the rest of my life. If that sounds interesting, you should <a target="_blank" href="https://www.recurse.com/scout/click?t=ba46ea16fafed13b3f8ccacb0ce83ad1">apply</a>.</p>
<p>The source code is at <a target="_blank" href="https://github.com/fcjr/RCade">github.com/fcjr/RCade</a>. Games are playable via the emulator by running <code>npx rcade@latest play</code> (or on <a target="_blank" href="https://rcade.dev">rcade.dev</a>, though not all games work there yet). And if you’re a Recurser, remote or in-person, I hope you’ll make something for it.</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="sh" data-theme="Overnight"><code data-language="sh" data-theme="Overnight"><span data-line=""><span>npm</span><span> create</span><span> rcade@latest</span></span></code></pre></figure><hr/><p><a target="_blank" href="https://github.com/fcjr/frankchiarulli.com/edit/main/public/building-the-rcade/index.md">Edit on GitHub</a></p></div></div>
  </body>
</html>
