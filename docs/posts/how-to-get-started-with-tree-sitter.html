<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.masteringemacs.org/article/how-to-get-started-tree-sitter">Original</a>
    <h1>How to Get Started with Tree-Sitter</h1>
    
    <div id="readability-page-1" class="page"><article>
    
    
    
      
    
    
      
    
    
      
        <section>
          Emacs 29 introduces tree-sitter support, a powerful parsing library that enhances its understanding of source code. With this integration, Emacs gains features like precise syntax highlighting, accurate indentation and easier extensibility. Here&#39;s how you install and configure Emacs with tree-sitter support.
        </section>
      
      
        <figure>
          <img src="https://www.masteringemacs.org/static/uploads/article-images/tree-computer-2.jpg"/>
        </figure>
      
      
        
      
      
        <p>Updated for <strong>emacs 29</strong></p>
      
      <img src="https://www.masteringemacs.org/static/img/fleuron2.gif"/>
      
<p>The next version of Emacs is around the corner, so I think it’s time to talk about how you can start using one of the more impressive additions to Emacs 29: tree-sitter. Briefly, tree-sitter is a library that transforms source code – or any other structured text, like Markdown – into a <em>concrete syntax tree</em>. I’ve written about <a href="https://www.masteringemacs.org/article/tree-sitter-complications-of-parsing-languages">tree sitter and the complications of parsing languages</a> and why it’s a big deal: correct syntax highlighting; cleverer editing and movement; and better indentation are just some of the benefits of tree-sitter.</p><p>And in Emacs 29, support for tree-sitter is built in. Sort of. It’s an optional extra, so you must compile Emacs from source, or hope that someone else will do it for you. In my experience, unless you’re using a bleeding-edge Linux distribution, you’re in for quite a wait. So I’ve compiled a guide on how to get started with tree-sitter in Emacs: not just the compilation, but how to get started using it. You see, getting everything to work properly is a bit more involved than just compiling Emacs with tree-sitter support.</p><figure>
<img src="https://www.masteringemacs.org/static/uploads/combobulate/expand-region.gif" alt=""/>
<figcaption>My package, <a href="https://www.masteringemacs.org/article/combobulate-structured-movement-editing-treesitter">Combobulate</a>, adds advanced editing and movement using tree-sitter. This is Combobulate&#39;s expand region feature, bound to <code>M-h</code>.</figcaption>
</figure><p>Despite the high activation cost of getting tree-sitter up and running, I firmly believe it’s worth it. Here’s what you’ll need to do to get it set up.</p><h2 id="building-emacs-with-tree-sitter-support">Building Emacs with Tree-Sitter Support</h2><p><em>Note that these compilation instructions cover Linux, and use Ubuntu/Debian as the example distribution. Tree-sitter will also work on other platforms, like Microsoft Windows. For compiling or installing the grammars on more platforms than just Linux, see below.</em></p><ol type="1"><li><p>Grab the latest Emacs sources from Savannah, Emacs’s official git repo. Once Emacs 29 is out you can use the official tarballs instead, but for now I recommend you check out the <code>emacs-29</code> branch, or just <code>master</code> if you’re OK with living life on the bleeding edge. I always use <code>master</code>:</p><pre><code>$ git clone https://git.savannah.gnu.org/git/emacs.git -b emacs-29</code></pre></li><li><p>Next, you’ll need to install the prerequisites required for Emacs to compile. With Debian/Ubuntu-based systems, that is easy, as you can rely on <code>apt-get build-deps</code> to do the heavy lifting by having it install the dependencies for one of the Emacs versions it your distro <em>does</em> support.</p><p>Building Emacs is not hard, and the simplest way to do this is to follow my existing guide where I detail how to do all of this, step-by-step, to get native compilation working:</p><p><a href="https://www.masteringemacs.org/article/speed-up-emacs-libjansson-native-elisp-compilation">Speed up Emacs with libjansson and native elisp compilation</a></p><p>If you’ve never bothered with native compilation, you should: it provides a significant speed boost. You may as well build Emacs with it also.</p><p>I would urge you to get this step working first: we’ll amend it slightly to add tree-sitter support (and other optional goodies) next. The approach outlined in that article is the barebones version of Emacs, but once you get it building on your system, you can easily recompile Emacs from scratch with additional features, as needed.</p></li><li><p>Next, you’ll need to check out tree-sitter’s source code:</p><pre><code>$ git clone git@github.com:tree-sitter/tree-sitter.git</code></pre><p>I, once again, stick to the <code>master</code> branch, but you can use a tagged release if you prefer a stable release.</p><p>Your distro may already include tree-sitter as a package, as in the case of Debian:</p><pre><code>$ sudo apt-get install libtree-sitter-dev</code></pre><p>That is occasionally enough to install tree-sitter so it works with Emacs. <em>However</em>, given how easy tree-sitter is to install, having no real depencies of its own, and it being a rather fast-moving project, I recommend you just build it from source also.</p></li><li><p>Time to build tree-sitter. Provided your Emacs builds, so should tree-sitter:</p><pre><code>$ cd tree-sitter/
$ make
$ make install</code></pre><p>That is all it takes. Note that <code>make install</code> normally requires root. It’ll install a shared library to (usually) <code>/usr/local/lib</code>.</p><p>In <em>theory</em>, that’s all it takes for Emacs to compile with tree-sitter support. <em>However</em>, if Emacs complains during the build that it can’t find the shared library <code>libtree-sitter.so</code>, try this:</p><pre><code>$ export LD_LIBRARY_PATH=/usr/local/lib/</code></pre><p>And retry building Emacs.</p></li><li><p>Now you can start building Emacs with tree-sitter. I’ll assume you followed my other tutorial and you’re now at a point where Emacs builds (without) tree-sitter. Now all you need to do is add <code>--with-tree-sitter</code> (technically, it should detect tree-sitter automatically, but I prefer being explicit) to the call to <code>./configure</code>:</p><pre><code>./configure --with-tree-sitter --with-native-compilation ... CC=gcc-10</code></pre><p>Now run <code>make</code> then <code>make install</code>. Everything should build and link and you’ll wind up with your own build of Emacs.</p></li></ol><p>That takes care of Emacs. Unfortunately, that is not enough to reap the benefits of tree-sitter. We’ll have to install some language grammars also.</p><h2 id="installing-the-language-grammars">Installing the Language Grammars</h2><p>Neither tree-sitter nor Emacs come installed with language grammars. Just like kids’ toys and batteries, they’re sold separately. So you’re required to download and compile the sources for each language grammar you want to use.</p><p>You must compile each language into a shared library and put in a place where tree-sitter can find them. It is not especially hard to do so, but it can be a frustrating experience as it’ll depend on: your platform; your choice of compilers; whether the grammar author chose C++ or just C, and so on. Furthermore, there is often no <code>Makefile</code>, so you have to tell the compiler yourself to build a shared library.</p><p>Luckily, there are two simpler ways than the manual way: the builtin method in Emacs, or relying on the kindness of strangers.</p><p>Before I explain both methods, I must point out that, at the end of the day, regardless of the method you choose – and especially if you’re compiling the grammars yourself – that you must put them in a directory where Emacs and tree-sitter can find them:</p><ol type="1"><li>Emacs will look in <code>treesit-extra-load-path</code> if you have it set;</li><li>Then, in a subdirectory called <code>tree-sitter</code> under <code>user-emacs-directory</code> — e.g., <code>~/.emacs.d/tree-sitter/</code>.</li><li>And finally it’ll look in all the usual <code>/lib</code> locations scattered around your filesystem.</li></ol><p>I prefer the Emacs directory approach myself. The grammars are small and, unless you make it a habit to swap between wildly different system architectures, you can safely commit the shared libraries to git and lug ’em around with you.</p><p>Anyway. Let’s install the grammar libraries. Onwards!</p><h3 id="compiling-and-installing-with-the-builtin-method-in-emacs">Compiling and Installing with the builtin method in Emacs</h3><p>This is perhaps the simplest, but it’ll only work if you don’t have an exceptional setup (so it won’t work well unless you have GCC and run some flavor of Linux.) But if your Linux installation’s plain as day, expect this method to work fine if you successfully compiled Emacs and tree-sitter from scratch.</p><p>The command <code>M-x treesit-install-language-grammar</code> installs a language grammar by first cloning the git repo hosting it and then compiling it and storing the shared library in your <code>.emacs.d</code> directory.</p><p>In order to determine where – and what – it can install, you must first tell Emacs where to find the language grammars. The variable <code>treesit-language-source-alist</code> is a simple alist that expects a form in the format of <code>(LANG . (URL REVISION SOURCE-DIR CC C++))</code>. Where only <code>LANG</code> and <code>URL</code> are mandatory. Leave out the rest and Emacs will try to do the right thing. It is not customizable using the <em>Customize</em> interface, unfortunately, so you must set and edit it manually.</p><p>Here’s an example:</p><pre><code>(<span>setq</span> treesit-language-source-alist
   &#39;((bash <span>&#34;https://github.com/tree-sitter/tree-sitter-bash&#34;</span>)
     (cmake <span>&#34;https://github.com/uyha/tree-sitter-cmake&#34;</span>)
     (css <span>&#34;https://github.com/tree-sitter/tree-sitter-css&#34;</span>)
     (elisp <span>&#34;https://github.com/Wilfred/tree-sitter-elisp&#34;</span>)
     (<span>go</span> <span>&#34;https://github.com/tree-sitter/tree-sitter-go&#34;</span>)
     (html <span>&#34;https://github.com/tree-sitter/tree-sitter-html&#34;</span>)
     (javascript <span>&#34;https://github.com/tree-sitter/tree-sitter-javascript&#34;</span> <span>&#34;master&#34;</span> <span>&#34;src&#34;</span>)
     (json <span>&#34;https://github.com/tree-sitter/tree-sitter-json&#34;</span>)
     (make <span>&#34;https://github.com/alemuller/tree-sitter-make&#34;</span>)
     (markdown <span>&#34;https://github.com/ikatyang/tree-sitter-markdown&#34;</span>)
     (python <span>&#34;https://github.com/tree-sitter/tree-sitter-python&#34;</span>)
     (toml <span>&#34;https://github.com/tree-sitter/tree-sitter-toml&#34;</span>)
     (tsx <span>&#34;https://github.com/tree-sitter/tree-sitter-typescript&#34;</span> <span>&#34;master&#34;</span> <span>&#34;tsx/src&#34;</span>)
     (typescript <span>&#34;https://github.com/tree-sitter/tree-sitter-typescript&#34;</span> <span>&#34;master&#34;</span> <span>&#34;typescript/src&#34;</span>)
     (yaml <span>&#34;https://github.com/ikatyang/tree-sitter-yaml&#34;</span>)))</code></pre><p>As you can see, there’s not much to it. A couple of the languages require a little path and branch fiddling as their directory structure differ from the accepted standard.</p><p>Once you’ve found the languages you like, you’ll need to install them. Call the command <code>M-x treesit-install-language-grammar</code> for each language and that’s usually all there is to it.</p><p>If that’s too much manual work, just bulk install all of ’em in one go. <a href="https://www.masteringemacs.org/article/evaluating-elisp-emacs">Evaluate this elisp form</a> to do so:</p><pre><code>(<span>mapc</span> #&#39;treesit-install-language-grammar (<span>mapcar</span> #&#39;car treesit-language-source-alist))</code></pre><p>It can happen that <code>LANGUAGE</code> is named differently than the shared library. In the unlikely event that happens you can use <code>treesit-load-name-override-list</code>. You’re more likely to encounter this if you’re using competing grammars for the same language, or if the name does not match the shared library name.</p><p>Every language has a function entry point named <code>tree_sitter_&lt;LANGUAGE&gt;</code> in the library, and if the <code>&lt;LANGUAGE&gt;</code> does not match up with the filename (usually <code>libtree-sitter-&lt;LANGUAGE&gt;.so</code>), Emacs won’t load the module. This is not the case with the example I gave above, but you may run into it if you’re using niche language grammars or if you want multiple ones serving the same language (for some reason.)</p><p>Here is what that could look like:</p><pre><code>(<span>setq</span> treesit-load-name-override-list &#39;((js <span>&#34;libtree-sitter-js&#34;</span> <span>&#34;tree_sitter_javascript&#34;</span>)))</code></pre><h3 id="using-pre-compiled-language-grammars">Using pre-compiled language grammars</h3><p>Before Emacs 29 added tree-sitter support, Tuấn-Anh Nguyễn created <a href="https://github.com/ubolonton">a third-party tree-sitter package</a> that adds tree-sitter based font locking and support for tree-sitter in all modern versions of Emacs. It’s excellent, though it has a number of limitations (mostly due to Emacs’s dynamic module system more than anything else.) But if you want tree-sitter support in older Emacsen, you should check it out. It’s a MELPA package install away and it pretty much works out of the box.</p><p>Nevertheless, Tuấn-Anh also took the time to build a CI release system that tracks a large portion of the most common language grammars — complete with builds for Windows, Mac and various Linux architectures. Really superb work.</p><p>So if you’re on Windows or if you find the idea of building the grammars cumbersome, you should give his precompiled packages a shot.</p><p>You can find them <a href="https://github.com/emacs-tree-sitter/tree-sitter-langs/releases">on his Github releases</a> page. You can also download the <code>tree-sitter-langs</code> package from MELPA, but I recommend you just download the shared libs directly instead, as you’ll in any event have to rename them and place the grammar libraries somewhere else.</p><p>The names of the files are <code>&lt;LANGUAGE&gt;.so</code> (or with your platform’s equivalent extension) which is not in keeping with the expected naming style in Emacs. You must first rename them so they’re named <code>libtree-sitter-&lt;LANGUAGE&gt;.so</code>. This is as good a time as any to learn how to bulk rename them with Emacs’s <code>M-x dired</code> and the <a href="https://www.masteringemacs.org/article/wdired-editable-dired-buffers">editable dired buffers</a> feature.</p><p>Once they’re named appropriately, put them in the directory called <code>tree-sitter</code> in <code>user-emacs-directory</code>. Or pick another place for them, as per the search path order I wrote about earlier. But for most of us, putting them in <code>~/.emacs.d/tree-sitter</code> is good enough.</p><h3 id="check-if-a-grammar-is-working">Check if a grammar is working</h3><p>Determining if a grammar is available is not intuitive nor obvious unless you use elisp. You must call the <code>treesit-language-available-p</code> function to check:</p><pre><code>ELISP&gt; (treesit-language-available-p &#39;python)
<span>t</span>
ELISP&gt; (treesit-language-available-p &#39;klingon)
<span>nil</span></code></pre><p>Emacs will return <code>t</code> if it’s a known language and <code>nil</code> otherwise. Use this to check if you’ve compiled, installed or copied (all depending on the method you chose) the grammars correctly.</p><p>The other thing to keep in mind with the grammars is <em>that they are not versioned!</em> There is no version tags beyond the git commit hash to help you determine which version of the grammar you have. That’s mostly of interest to major mode developers or people like me that <a href="https://www.masteringemacs.org/article/combobulate-structured-movement-editing-treesitter">build structured editing and movement</a> packages on top of tree-sitter. I recommend you reinstall the grammars every now again to keep up with changes, for package authors have no easy way of checking.</p><h3 id="how-to-use-tree-sitter">How to use Tree-Sitter</h3><p>Yep. This part needs a tutorial introduction also. Emacs now implements a very different way of font locking (syntax highlighting) than most – though not all! – major modes in Emacs, as most of them use regular expressions to feed Emacs’s font lock engine with syntactic information. Now that it’s using an actual syntax tree to extract information, Emacs is a lot more accurate.</p><p>Because of the complete 180-degree turn in, well, almost everything, the Emacs developers decided against wedging tree-sitter support into the existing modes. Instead it’s relegated to its <em>own</em>, “TS”-powered, major modes. I understand <em>why</em> – some of the major modes are complex and naively cramming tree-sitter-powered features into them will require more longer-term engineering effort to sort out than they can currently muster – but it’s still, well, they’re different modes, with all the drawbacks and benefits that bring.</p><p>Modes that use tree-sitter are all named <code>&lt;major-mode&gt;-ts-mode</code>. That’s the naming standard and it does mean you can quickly check if Emacs supports your pet major mode out of the box: typing <code>C-h a -ts-mode$</code> should do the trick. The apropos window will list all known tree-sitter major modes.</p><p>Note that, just because you have installed a grammar, does <em>not</em> mean Emacs supports it. Someone still has to write the – admittedly, <em>way</em> easier – syntax and indentation logic and all that good stuff.</p><p>One interesting outcome of tree-sitter support is that Emacs has now gained new major modes it did not have before. Like <code>dockerfile-ts-mode</code>.</p><p>So to use tree-sitter you must activate the new major mode manually. Emacs will, by default, use the existing major modes, even if you have everything set up correctly.</p><p>To coax Emacs into using the new major modes by default, you’ll have to either:</p><ol type="a"><li>Edit <code>auto-mode-alist</code>, <code>interpreter-mode-alist</code>, etc. and change over all the references you care about to use new <code>&lt;LANGUAGE&gt;-ts-mode</code> major modes; or…</li><li>Use <code>major-mode-remap-alist</code>, an icky hack that maps one major mode symbol to another behind-the-scenes. That feature, rather conveniently, debuted in Emacs 29 also.</li></ol><p>Hacky though I think it is, I’d pick the <code>major-mode-remap-alist</code> for now: it’s easy to get started with, and you can always migrate everything to the harder, and more explicit, way once you’re happy with your new tree-sitter-enabled major modes.</p><p>Here’s an example, and this time you can instead use <code>M-x customize-option</code> to customize it to your liking, if you prefer the customize interface.</p><pre><code>(<span>setq</span> major-mode-remap-alist
 &#39;((yaml-mode . yaml-ts-mode)
   (bash-mode . bash-ts-mode)
   (js2-mode . js-ts-mode)
   (typescript-mode . typescript-ts-mode)
   (json-mode . json-ts-mode)
   (css-mode . css-ts-mode)
   (python-mode . python-ts-mode)))</code></pre><p>As you can see there’s not much to it. Whenever Emacs is asked to activate <code>css-mode</code>, it’ll instead call <code>css-ts-mode</code>.</p><p>Despite the major mode switcheroo gimmick, it does not remove most of the obstacles and annoyances of having a new major mode.</p><p>At this point, I’d try out some of the major modes you want to use. Annoyingly, there’s no easy way to see if you’re using the normal or the TS-powered major mode: you can look at the lighter in the mode line, but it’s often the same text as the normal mode. The quickest way to tell is to type <code>M-: major-mode</code> and you’ll see which major mode you’re using.</p><p>I’ve heard tales of the TS-powered major modes being “temporary”, but… there’s nothing so permanent like a temporary solution. I understand why the distinction has to exist (for now), but it’s still awkward, and this approach does leave a number of unsolved problems you’ll still have to solve yourself:</p><ol type="1"><li>You must duplicate and/or change your mode hooks. <code>python-mode-hook</code> is distinct from <code>python-ts-mode-hook</code>, and you should ensure you copy over your settings.</li><li>Your indentation customizations (if you have them) may not work. Indeed, any customizations you’ve applied to one mode won’t <em>necessarily</em> apply. They <em>might</em>, but there’s no guarantee they will. It comes down to the mode and the feature.</li><li>Font lock faces are now more detailed and expressive than ever before. This is one area you probably definitely <em>will</em> and <em>want</em> to customize, if only to take advantage of better syntax highlighting.</li><li>Third-party packages will blithely assume you’re using the default major mode and not your turbo-charged tree-sitter equivalent, and so they may not activate or work at all in the TS-powered one. It’ll take a while for this distinction to percolate, and for packages to check for one or the other.</li><li>Most TS-powered modes ‘derive’ from the original major mode, with varying levels of overlapping customizations and features. The best way to see what your new major mode can (or cannot) do is, uh, well.. to read the source. Sorry.</li></ol><p>Nevertheless, it’s worth the pain, as you’ll only have to do it once.</p><h3 id="tweaking-the-font-locking">Tweaking the Font Locking</h3><p>One of the benefits of having a concrete syntax tree is precision. Emacs is now capable of precisely highlighting things it couldn’t before: it can distinguish function calls from keywords or identifiers. To better support that, there’s now a host of new font lock faces.</p><p>Due to the large array of things you can color, Emacs now separates its font locking into <em>font lock features</em>. This feature’s akin to the long-existing <code>font-lock-maximum-decoration</code> that the chromatically averse can tweak to disable some or all of Emacs’s coloring if it’s too ostentatious. If you belong to that cohort – most of whom refer to this as “<a href="https://en.wiktionary.org/wiki/angry_fruit_salad">angry fruit salad</a>” – then you’re in for a technicolor razzle-dazzle.</p><p>Every TS-enabled major mode will decide on its own list of <em>features</em>. The features are buffer-local and set in <code>treesit-font-lock-feature-list</code>, with each sub-list representing a <em>level</em> of highlighting. If you want to change it, you’ll need a mode hook to alter it properly.</p><p>For most, it’s enough to change the font lock feature level. To do so, customize <code>treesit-font-lock-level</code>. Every incrementation of the level will color more and more things: one you reach the higher echelons, it does become a bit much, even for me. But it’s great to have that flexibility and the power to decide which things should, and which things should not, be highlighted.</p><p><strong>NOTE</strong>: <code>treesit-font-lock-level</code> has a special <em>setter</em> attached to it, so as to automatically recompute the font lock features in all your buffers when you change the level. If you use Customize, then you don’t have to do anything, but if you normally use <code>setq</code>, you’ll have to use <code>customize-set-variable</code> instead to ensure the setter is called properly.</p><p>It’s worth experimenting with the font lock level: the default is conservative and in line with what Emacs normally font locks. This is one of the capstone features of tree-sitter, and you should absolutely tweak it to your liking. To go along with each feature is an equivalent <code>font-lock-&lt;feature&gt;-face</code>. You can list all the pertinent faces with <code>M-x customize-apropos-faces RET ^font-lock-</code>. It’s very likely your theme (or your own face customizations if you maintain your own faces, like I do) is missing these customizations, so be sure to check, as their defaults make everything look rather samey.</p><p>The general intent behind the level is that you set it once and you get – approximately – the same general style of font locking in all TS-powered modes. I think that intent holds up rather well, even though what gets font locked, and how, is up to each major mode author.</p><h3 id="inspecting-the-tree-sitter-tree">Inspecting the Tree-sitter tree</h3><p>One benefit of tree-sitter is access to the live concrete syntax tree of your source code. You can inspect the tree in a buffer with <code>M-x treesit-explore-mode</code> and <code>M-x treesit-inspect-mode</code>. There’s a lot more you can do with it, so I recommend you consult the manual, or stay tuned for more in-depth articles on this topic here!</p><h2 id="fixing-the-s-expression-commands">“Fixing” the S-Expression Commands</h2><p>Emacs has had s-expression-based commands for decades. They’re bound to keys like <code>C-M-f</code>, <code>C-M-SPC</code>, and <code>C-M-k</code>.</p><p>They work well in a wide range of languages because they’re delightfully dumb: they look for structured expressions – such as <code>(</code> and <code>)</code>, <code>&#34;</code> and <code>&#34;</code>, and so forth – and treat them as cohesive, syntactic ‘unit’. In the absence of such structured units, they fall back and behave much like word-based movement and editing.</p><p>Not so in tree-sitter major modes. They’ve been “upgraded” to try and guess the syntactic units you probably want to move over or edit.</p><p>That sounds like a great idea until you realize that it is not possible to make one-size-fits all commands that do this. Believe me: <em>I’ve tried</em>. Every language is different, and even a modest language grammar will have hundreds of node types and millions of combinations. Whereas before you could predict where point would end up after calling these commands, now you probably can’t. Worse, the commands do not mirror the old behavior at all: they’re erratic and unpredictable.</p><p>If you already use these commands, and you also dislike this unwanted and unasked for change in behavior, then you can use this snippet to revert to the old way:</p><pre><code>(<span>defun</span><span> mp-remove-treesit-sexp-changes </span>()
  (<span>when</span> (<span>eq</span> forward-sexp-function #&#39;treesit-forward-sexp)
    (<span>setq</span> forward-sexp-function <span>nil</span>))
  (<span>when</span> (<span>eq</span> transpose-sexps-function #&#39;treesit-transpose-sexps)
    (<span>setq</span> transpose-sexps-function #&#39;transpose-sexps-default-function))
  (<span>when</span> (<span>eq</span> forward-sentence-function #&#39;treesit-forward-sentence)
    (<span>setq</span> forward-sentence-function #&#39;forward-sentence-default-function)))

(add-hook &#39;prog-mode-hook #&#39;mp-remove-treesit-sexp-changes)</code></pre><h2 id="structured-editing-and-movement">Structured Editing and Movement</h2><figure>
<img src="https://www.masteringemacs.org/static/uploads/combobulate/combobulate-example.gif" alt=""/>
<figcaption>Combobulate can insert multiple cursors (if you use it); move around your code structurally; insert syntax-aware code templates; and much, much more.</figcaption>
</figure><p>One of the tantalizing things that a library like tree-sitter offers is better and more correct editing and movement that understands the syntax of your code. That’s one of the things my package <a href="https://www.masteringemacs.org/article/combobulate-structured-movement-editing-treesitter">Combobulate</a> sets out to do: to provide advanced editing and movement across a swathe of languages.</p><p>Now that you’ve gotten tree-sitter working, why not take my <a href="https://github.com/mickeynp/combobulate">Combobulate package</a> for a spin? It’s a work-in-progress still, so expect bugs, but it’s got a host of useful features that’ll speed up your day-to-day coding.</p>

    
    
  </article></div>
  </body>
</html>
