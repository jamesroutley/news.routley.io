<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/Articles/495304/">Original</a>
    <h1>TCP Connection Repair</h1>
    
    <div id="readability-page-1" class="page"><div>
<center>
           <div><b>LWN.net needs you!</b><p>Without subscribers, LWN would simply not exist.  Please consider
       <a href="https://lwn.net/subscribe/">signing up for a subscription</a> and helping
       to keep LWN publishing</p></div>
           </center>
           <p>
Migrating a running container from one physical host to another is a tricky
job on a number of levels.  Things get even harder if, as is likely, the
container has active network connections to processes outside of that
container.  It is natural to want those connections to follow the container
to its new host, preferably without the remote end even noticing that
something has changed, but the Linux networking stack was not written with
this kind of move in mind.  Even so, it appears that transparent relocation
of network connections, in the form of Pavel Emelyanov&#39;s <a href="https://lwn.net/Articles/493983/">TCP connection repair patches</a>, will be
supported in the 3.5 kernel. 
</p><p>
The first step in moving a TCP connection is to gather all of the
information possible about its current state.  Much of that information is
available from user space now; by digging around in <tt>/proc</tt> and
<tt>/sys</tt>, one can determine the address and port of the remote end,
the sizes of the send and receive queues, TCP sequence numbers, and a
number of parameters 
negotiated between the two end points.  There are still a few things that
user space will need to obtain, though, before it can finish the job; that
requires some additional support from the kernel.  
</p><p>
With Pavel&#39;s patch, that support is available to suitably privileged
processes. 
To dig into the internals of an active network connection, user space must
put the associated socket into a new &#34;repair mode.&#34;  That is done with the
<tt>setsockopt()</tt> system call, using the new <tt>TCP_REPAIR</tt>
option.  Changing a process&#39;s repair mode status requires the
<tt>CAP_NET_ADMIN</tt> capability; the socket must also either be closed or
in the &#34;established&#34; state.  Once the socket is in repair mode, it can be
manipulated in a number of ways.
</p><p>
One of those is to read the contents of the send and receive queues.  The
send queue contains data that has not yet been successfully transmitted to
the remote end; that data needs to move with the connection so it can be
transmitted from the new location.  The receive queue, instead, contains
data received from the remote end that has not yet been consumed by the
application being moved; that data, too, should move so it will be waiting
on the new host when the application gets around to reading it.  Obtaining
the contents of these queues is done with a two-step sequence:
(1) call <tt>setsockopt(TCP_REPAIR_QUEUE)</tt> with either
<tt>TCP_RECV_QUEUE</tt> or <tt>TCP_SEND_QUEUE</tt>, then (2) call
<tt>recvmesg()</tt> to read the contents of the selected queue.
</p><p>
It turns out there is only one other important piece of information that
cannot already be obtained from user space: the maximum value of the MSS
(maximum segment size) negotiated between the two endpoints at connection
setup time.  To make this value available, Pavel&#39;s patch changes the
semantics of the <tt>TCP_MAXSEG</tt> socket option (for
<tt>getsockopt()</tt>)  when the connection is
in repair mode: it returns the maximal &#34;clamp&#34; MSS value rather than the
currently active value.
</p><p>
Finally, if a connection is closed while it is in the repair mode, it is
simply deleted with no notification to the remote end.  No FIN or RST
packets will be sent, so the remote side will have no idea that things have
changed.
</p><p>
Then there is the matter of establishing the connection on the new host.
That is done by creating a new socket and putting it immediately into the
repair mode.  The socket can then be bound to the proper port number; a
number of the usual checks for port numbers are suspended when the socket
is in repair mode.  The <tt>TCP_REPAIR_QUEUE</tt> <tt>setsockopt()</tt>
call comes into play again, but this time <tt>sendmsg()</tt> is used to
restore the contents of the send and receive queues.
</p><p>
Another important task is to restore the send and receive sequence numbers.
These numbers are normally generated randomly when the connection is
established, but that cannot be done when a connection is being moved.
These numbers can be set with yet another call to <tt>setsockopt()</tt>,
this time with the <tt>TCP_QUEUE_SEQ</tt> option.  This operation applies
to whichever queue was previously selected with <tt>TCP_REPAIR_QUEUE</tt>,
so the refilling of a queue&#39;s content and the setting of its sequence
number are best done at the same time.
</p><p>
A few negotiated parameters also need to be restored so that the two ends
will remain in agreement with each other; these include the MSS clamp
described above, along with the active maximum segment size, the window
size, and whether the selective acknowledgment and timestamp features can
be used.  One last <tt>setsockopt()</tt> option,
<tt>TCP_REPAIR_OPTIONS</tt>, has been added to make it possible to set
these parameters from user space.
</p><p>
Once the socket has been restored to a state approximating that which
existed on the old host, it&#39;s time to put it into operation.  When
<tt>connect()</tt> is called on a socket in repair mode, much of the
current setup and negotiation code is shorted out; instead, the connection
goes directly to the &#34;established&#34; state without any communication from the
remote end.  As a final step, when the socket is taken out of the repair
mode, a window probe is sent to restart traffic 
between the two ends; at that point, the socket can resume normal operation
on the new host.
</p><p>
These patches have been through a few revisions over a number of months;
with version 4, networking maintainer David Miller <a href="https://lwn.net/Articles/495318/">accepted</a> them into net-next.  From there,
those changes will almost certainly hit the mainline during the 3.5 merge
window.  The TCP connection repair patches do not represent a complete
solution to the problem of checkpointing and restoring containers, but they
are an important step in that direction.<br clear="all"/></p><table>
           <tbody><tr><th colspan="2">Index entries for this article</th></tr>
           <tr><td><a href="https://lwn.net/Kernel/Index">Kernel</a></td><td><a href="https://lwn.net/Kernel/Index#Checkpointing">Checkpointing</a></td></tr>
            <tr><td><a href="https://lwn.net/Kernel/Index">Kernel</a></td><td><a href="https://lwn.net/Kernel/Index#Containers">Containers</a></td></tr>
            <tr><td><a href="https://lwn.net/Kernel/Index">Kernel</a></td><td><a href="https://lwn.net/Kernel/Index#Networking">Networking</a></td></tr>
            </tbody></table></div></div>
  </body>
</html>
