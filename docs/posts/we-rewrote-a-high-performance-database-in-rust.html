<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.pinecone.io/learn/rust-rewrite/">Original</a>
    <h1>We rewrote a high-performance database in Rust</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><p><img loading="lazy" src="https://d33wubrfki0l68.cloudfront.net/e9d8491cb26b87b00ddfcfc8f7de0b80d44c1df0/34503/images/rust-rewrite.jpg" alt="August’s Rust NYC Meetup" width="100%"/></p><p>I recently spoke at the <a href="https://www.meetup.com/rust-nyc/">Rust NYC meetup group</a> about the Pinecone engineering team’s experience rewriting our vector database from Python and C++ to Rust. The event was very well attended (178+ registrations), which just goes to show the growing interest in Rust and its applications for real-world products. Below is a recap of what I discussed, but make sure to check out the <a href="https://www.youtube.com/watch?v=zv6bXXQmMqA">full recording</a> if interested in learning more.</p><h2 id="introduction-to-pinecone---why-are-we-here">Introduction to Pinecone - why are we here?</h2><p>Data lakes, ML Ops, feature stores - these are all common buzzwords trying to solve similar sorts of problems. For example, let’s say you have a lot of unstructured data, and in order to gain insights you store it in blob storage. Historically, you would use an ML Ops platform, like a hosted Spark pipeline, for this. However, in many ways, we’re seeing the industry start to transition to the concept of vector databases and specifically approximate nearest neighbor (ANN) search to support similar use cases.</p><p><img loading="lazy" src="https://d33wubrfki0l68.cloudfront.net/c21434892386676b5ff38039f75458817ac7f06e/2d9e7/images/rust-rewrite-vector-database.png" alt="Vector Databse" width="100%"/></p><p><a href="https://www.pinecone.io/">Pinecone</a> is a fully managed, SaaS solution for this piece of the puzzle - <a href="https://www.pinecone.io/learn/vector-database/">the vector database</a>. While the concept of the vector database has been used by many large tech companies for years, these sorts of companies have built their own proprietary, deep learning ANN indexing algorithms to serve news feeds, advertisements, and recommendations. These infrastructures and algorithms require intensive resources and overhead that most companies can’t support. With its strict memory management, efficient multi-threading, and fast, reliable performance, this is where the Pinecone solution comes in.</p><h2 id="ramping-up-with-rust">Ramping up with Rust</h2><p>Pinecone was originally written in C++ with a connectivity wrapper written in Python. While this worked well for a while, we began to run into issues.</p><p>First of all, Python is a garbage collected language, which means it can be extremely slow for writing anything high performance at scale. In addition, it’s challenging to find developers with experience in both Python and C++. And so the idea of iterating on the database was born - we wanted to find some way to unify our code base while achieving the performance predictability we needed.</p><p>We looked at and compared several languages - Go, Java, C++, and Rust. We knew that C++ was harder to scale and maintain high quality as you build a dev team; that Java doesn’t provide the flexibility and systems programming language we needed; and that Go is also a garbage collected language. This left us with Rust. With Rust, the pros around performance, memory management, and ease of use outweighed the cons of it not yet being a very established language.</p><h2 id="identifying-bottlenecks">Identifying bottlenecks</h2><h3 id="continuous-benchmarking">Continuous benchmarking</h3><p>As we began ramping up with Rust, we ran into a few bottlenecks. Before shipping the newly rewritten database, we wanted to ensure it continued to scale easily and have predictable performance. How did we test this? With continuous benchmarking.</p><p>Continuous benchmarking allowed us to see every commit broken down by the performance of a specific benchmark test. Through HTML reports, we are able to see the exact commit that caused the regression of the debt anytime a code change is merged.</p><p><img loading="lazy" src="https://d33wubrfki0l68.cloudfront.net/bf72466f7d7ccb31222eafa79cc6491000a6b968/5eeef/images/continuous-benchmarking.png" alt="Continuous benchmarking" width="100%"/></p><p>As you can see in the above graph, a commit was merged that caused a huge spike. However, with Criterion, an open source benchmarking tool, we were easily able to identify it, mitigate it, and push a fix. And over time, we lowered our latency and shipped improvements.</p><h3 id="building-an-observability-layer">Building an observability layer</h3><p>At this point, we’ve confirmed that the new database is performant, and have benchmarks to run it against. But what happens when you go to production, and things are slower than they should be? This is when you need an observability solution.</p><p>Adding an observability layer with Rust can be complicated without the support of a more mature developer community. As a result, we wanted a solution with minimal instrumentation, that’s easy to integrate, and is cloud agnostic. Our end goal was to provide a layer compatible with Datadog, Prometheus or any other metrics provider.</p><p>There are two main components to our observability layer - traces and aggregated metrics. With each of these signals, you can see how each part of the code is performing over time.</p><p>How did we achieve this? For metrics, we used some macros for histogram and counter metrics. We also used a custom Rust macro that hooks into OpenMetrics, and from there we can push metrics to Prometheus or Datadog. For tracing, we took a similar approach. We implemented an OpenTelemetry protocol that allows us to send traces to any observability solution. This way we’re able to see all of our metrics and trace requests as graphs in a single dashboard (see the below example).</p><p><img loading="lazy" src="https://d33wubrfki0l68.cloudfront.net/763448a18fc002488c7414c5f1c4a2dacce8624a/85741/images/dashboard-graphs.png" alt="Dashboard graphs" width="100%"/></p><h2 id="optimizing-performance-with-rust">Optimizing performance with Rust</h2><p>After identifying and addressing the above bottlenecks, we were able to focus on optimizing performance. With Rust, there are several aspects around achieving high performance that we liked - low level optimized instruction sets, memory layout, and running async tasks.</p><h3 id="optimized-instruction-sets">Optimized instruction sets</h3><p>One of the things we considered when choosing Rust was its access to low level optimized instruction sets, which are critical for optimizing the kind of vector based workloads that Pinecone utilizes. So for example, AVX-512 allows us to utilize parallel dot-product to compute high throughput dot-product queries on anything. And Rust gives us direct access to these compiler optimizations.</p><h3 id="memory-layout">Memory layout</h3><p>If you’re using a higher level language, you’re not going to have access to how the memory is laid out. A simple change, like removing indirection in our list, was an order of magnitude improvement in our latencies since there’s memory prefetching in the compiler and the CPU can anticipate which vectors are going to be loaded next in order to improve the memory footprint.</p><h3 id="running-async-tasks">Running async tasks</h3><p>Rust is async, and <a href="https://tokio.rs/">Tokio</a> is the one of the most popular async providers. It’s performant, ergonomic, and has options for running on a single event loop. However, it’s not great for running CPU intensive workloads, like with Pinecone.</p><p>When it comes to running these tasks, there are many options. For example, because Tokio has different runtime modes, you can run it by itself in this async mode with multiple threads. And in that context, you can block on an individual thread in place, which is called ‘block_in_place’. You can also use ‘spawn_blocking’.</p><p>There are also “smart” work, parallel processing libraries, like <a href="https://github.com/rayon-rs/rayon">Rayon</a>, that maintain a thread pool and implement things like work stealing. And finally there’s the option of your own solution. If you want more control, you can use MPSC channels. While you have to write some custom code, they give you the fine grained ability to schedule work and ensure data locality.</p><h2 id="whats-next-for-pinecone">What’s next for Pinecone?</h2><p>We are continuing to optimize our codebase to ensure we’re maintaining a highly performant, stable, and fast database. This recap highlights the key points discussed during the meetup, but make sure to <a href="https://www.youtube.com/watch?v=zv6bXXQmMqA">watch the full recording</a> for more detail.</p><p>If you are interested in learning more about Pinecone and vector databases, check out the resources on our <a href="https://www.pinecone.io/learn/">learn page</a> or <a href="https://app.pinecone.io/">try it out</a> (it’s free). Also, if you’re currently using or interested in working with Rust, <a href="https://www.pinecone.io/careers/#open-roles">we are hiring</a>.</p><p><iframe src="https://www.youtube.com/embed/zv6bXXQmMqA" allowfullscreen="" title="YouTube Video"></iframe></p></div></div></div></div>
  </body>
</html>
