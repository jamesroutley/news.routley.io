<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://srasu.srht.site/var-evaluation.html">Original</a>
    <h1>Why your REPL experience sucks</h1>
    
    <div id="readability-page-1" class="page"><div id="content">

<p>
If you’ve been programming in Clojure for any amount of time, especially if
you’re working with webservices, Discord bots, or any other long-running process
that you may want to update the behavior of without restarting it, you’ve
probably had an experience where you re-evaluated some code, tried to run it
again, and it acts like it did before. You can evaluate that code as many times
as you want to and it just never runs the updated code.
</p>

<p>
Early on you may have just restarted your REPL every time this happened, and
that was frustrating, especially if it takes 20-30 seconds to start up every
time! Eventually, you probably figured out that there was something less than
restarting the whole REPL, whether that was restarting your Component system
map, shutting down your Ring server and starting it back up, or anything else
that results in bouncing a long-running process, that would allow you to run
your new code, and that was slightly less annoying.
</p>

<p>
Then you learned about the var quote, and how it can solve this problem. You put
that funny little <code>#&#39;</code> right where the Stack Overflow question said you should,
and it worked! But not every time. Some things reloaded perfectly, and other
things didn’t. Objectively this is better than when you had to bounce your
service every time, but it <b>feels</b> way worse, because you <i>know</i> that it could
all just reload the way you want it to, but it’s completely unclear when and why
it happens.
</p>

<p>
In this article, I will do my best to demystify the when and why of the var
quote when writing reloadable code for long-running processes.
</p>

<div id="outline-container-org1e1c1fa">
<h2 id="org1e1c1fa"><span>1.</span> The Setup</h2>
<div id="text-1">
<p>
In order to illustrate the problem, let’s write a tiny, fictional webservice
that just hosts static HTML files out of a directory. We’ll assume another
namespace, <code>myapp.util</code>, has been written to handle this basic stuff and now
we’re writing the entrypoint of the application in <code>myapp.core</code>.
</p>

<div>
<pre><span>(</span><span>ns</span> <span>myapp.core</span>
  <span>(</span><span>:require</span>
   <span>[</span>myapp.util <span>:as</span> util<span>]</span>
   <span>[</span>reitit.ring <span>:as</span> ring<span>]</span>
   <span>[</span>ring.adapter.jetty <span>:refer</span> <span>[</span>run-jetty<span>]</span><span>]</span><span>)</span>
  <span>(</span><span>:gen-class</span><span>)</span><span>)</span>

<span>(</span><span>defn</span> <span>file-handler</span>
  <span>[</span>file-path<span>]</span>
  <span>(</span><span>if-let</span> <span>[</span>html-body <span>(</span><span>util</span>/read-html file-path<span>)</span><span>]</span>
    <span>{</span><span>:status</span> <span>200</span>
     <span>:body</span> html-body<span>}</span>
    <span>{</span><span>:status</span> <span>404</span>
     <span>:body</span> <span>(</span><span>util</span>/read-html <span>&#34;not-found.html&#34;</span><span>)</span><span>}</span><span>)</span><span>)</span>

<span>(</span><span>defn</span> <span>wrap-path-param</span>
  <span>[</span>handler param<span>]</span>
  <span>(</span><span>fn</span> <span>[</span>request<span>]</span>
    <span>(</span>handler <span>(</span>get-in request <span>[</span><span>:path-params</span> param<span>]</span><span>)</span><span>)</span><span>)</span><span>)</span>

<span>(</span><span>def</span> <span>router</span>
  <span>(</span><span>ring</span>/ring-handler
   <span>(</span><span>ring</span>/router
    <span>[</span><span>[</span><span>&#34;/not-found&#34;</span> <span>{</span><span>:get</span> #<span>(</span>assoc <span>(</span>file-handler <span>&#34;not-found.html&#34;</span><span>)</span> <span>:status</span> <span>404</span><span>)</span><span>}</span><span>]</span>
     <span>[</span><span>&#34;/:file&#34;</span> <span>{</span><span>:get</span> <span>(</span>wrap-path-param file-handler <span>:file</span><span>)</span><span>}</span><span>]</span><span>]</span>
    <span>{</span><span>:conflicts</span> <span>nil</span><span>}</span><span>)</span><span>)</span><span>)</span>

<span>(</span><span>def</span> <span>server</span> <span>(</span>atom <span>nil</span><span>)</span><span>)</span>

<span>(</span><span>defn</span> <span>stop-server!</span>
  <span>[]</span>
  <span>(</span>swap! server #<span>(</span><span>do</span> <span>(</span>.stop <span>%</span><span>)</span> <span>nil</span><span>)</span><span>)</span><span>)</span>

<span>(</span><span>defn</span> <span>-main</span>
  <span>[]</span>
  <span>(</span>reset! server <span>(</span>run-jetty router <span>{</span><span>:port</span> <span>8080</span> <span>:join?</span> <span>false</span><span>}</span><span>)</span><span>)</span><span>)</span>
</pre>
</div>

<p>
For this application we’re using a few pretty common libraries, Ring’s jetty
adapter for the HTTP server, reitit for routing, and reitit-ring to make it easy
to put the two together.
</p>

<p>
What this does is pretty simple, but I’m going to go over it anyway to ensure
everybody’s on the same page.
</p>

<p>
To start with the <code>-main</code> function just starts up an HTTP server that uses
<code>router</code> as the handler function for the request. <code>router</code> itself has just two
routes, <code>/not-found</code> will just get <code>not-found.html</code> and return a 404 status
code, and <code>/:file</code> will take any other path provided, read it in as an HTML
file, or returns a 404 if it failed to read any HTML for whatever reason.
</p>

<p>
There’s also the <code>stop-server!</code> function paired with the <code>server</code> atom which is
used to provide a little REPL convenience to shut things down as needed.
</p>

<p>
This is the start of our application, but the application isn’t done yet. Now
that we have a starting point, let’s fire up a REPL, evaluate this code, start
the server, and make some changes.
</p>
</div>
</div>

<div id="outline-container-org43246da">
<h2 id="org43246da"><span>2.</span> The Problem</h2>
<div id="text-2">
<p>
This webservice so far has hosted only static HTML files for articles we host,
but you’ve just had a brilliant idea to add user profiles so that you can put
comments on your articles. That means we’ll have to have a new URL scheme to
allow files and users to not share the same namespace. So let’s put the files
into a <code>/articles</code> prefix to get ready for the <code>/users</code> prefix we’ll have to add
later.
</p>

<p>
This is quite an easy change, let’s just update our <code>router</code>!
</p>

<div>
<pre><span>(</span><span>def</span> <span>router</span>
  <span>(</span><span>ring</span>/ring-handler
   <span>(</span><span>ring</span>/router
    <span>[</span><span>[</span><span>&#34;/not-found&#34;</span> <span>{</span><span>:get</span> #<span>(</span>assoc <span>(</span>file-handler <span>&#34;not-found.html&#34;</span><span>)</span> <span>:status</span> <span>404</span><span>)</span><span>}</span><span>]</span>
     <span>[</span><span>&#34;/articles/:file&#34;</span> <span>{</span><span>:get</span> <span>(</span>wrap-path-param file-handler <span>:file</span><span>)</span><span>}</span><span>]</span><span>]</span><span>)</span><span>)</span><span>)</span>
</pre>
</div>

<p>
And look at that, we don’t even have to have allow conflicts anymore! This is a
real improvement. Let’s re-evaluate that code, and then make a request to the
new URL in our browser.
</p>

<p>
…
</p>

<p>
It gave us an internal server error, even though we’ve re-evaluated the router!
</p>
</div>
</div>

<div id="outline-container-org0d36a03">
<h2 id="org0d36a03"><span>3.</span> The Solution</h2>
<div id="text-3">
<p>
Well unfortunately, in order to progress from here, we need to stop the server
using that handy <code>stop-server!</code> function we made earlier. Fortunately, once
we’ve done that, making the router reloadable is easy. We just add a var quote
to the router when we start the server.
</p>

<div>
<pre><span>(</span><span>defn</span> <span>-main</span>
  <span>[]</span>
  <span>(</span>reset! server <span>(</span>run-jetty #&#39;router <span>{</span><span>:port</span> <span>8080</span> <span>:join?</span> <span>false</span><span>}</span><span>)</span><span>)</span><span>)</span>
</pre>
</div>

<p>
This is a very simple change, and once we’ve done it we can change the router to
our hearts’ content and it will reflect the changes as soon as we re-evaluate
it.
</p>
</div>
</div>

<div id="outline-container-orgd14c17d">
<h2 id="orgd14c17d"><span>4.</span> Why Though?</h2>
<div id="text-4">
<p>
If you’re new to Clojure, or even if you’re not but haven’t had a chance to
carefully study its evaluation model, this may seem a bit mysterious. Why should
putting two little characters in front of the function name suddenly mean that
the HTTP server will be updated when we re-evaluate the definition of the
router?
</p>

<p>
In order to answer this question, we’re going to go back to the basics of
Clojure, and dive a little deeper. When we evaluate the form <code>(+ 2 2)</code>, what
happens? In Clojure (and indeed all Lisps I am aware of), lists evaluate to some
kind of operation call. It may be a function, it may be a macro, it may be a
special form. In order to determine this, first Clojure evaluates the first
element of the list, in this case the symbol <code>+</code>.
</p>

<p>
When Clojure evaluates a symbol in function position like this it first checks
if it is a special form, like <code>if</code>, <code>let*</code>, or similar. If it is, it allows that
special form to take over. If not, it continues to check if it’s a local
variable and uses that value as a function. If it doesn’t refer to a local
variable, then it looks up that symbol in the current namespace to determine
what var it refers to. Once it finds the var that the symbol refers to, it
dereferences that var to get the value, before checking to see if the value is a
function or macro, and then saves the function object in either case to complete
the evaluation, and then if it’s a function it moves on to evaluate the
arguments to the call.
</p>

<p>
In this simple case of <code>(+ 2 2)</code> all the hard work is done because numbers just
evaluate to themselves, and then the saved function object is called and we get
the result <code>4</code>.
</p>

<p>
This may seem like quite the digression, but let’s now turn our attention to the
offending function call. <code>(run-jetty router {:port 8080 :join? false})</code> is
evaluated in exactly the same manner as the addition was, but something slightly
more interesting happens when it evaluates the first argument.
</p>

<p>
When Clojure evaluates the symbol <code>router</code> here, it goes through almost the
exact same process as it did for the symbol <code>+</code>, but without checking if it’s a
special form. It looks for the var in the current namespace that maps to the
symbol <code>router</code>, dereferences it, and saves the function object it retrieves as
the first argument before evaluating the second argument, and then calling the
function that <code>run-jetty</code> evaluated to.
</p>

<p>
<code>run-jetty</code> in turn takes that function object and starts up its server. How it
does this is more or less irrelevant, but somewhere inside it ends up calling
the function object you passed with the request object.
</p>

<p>
Now imagine we just evaluated some changes to <code>router</code>. Maybe we added that
<code>/users/:id</code> route to be able to view a user profile. This constructs a brand
new function object that will handle the new route, and then takes the existing
var associated with the symbol <code>router</code> and updates it to point at this new
function object.
</p>

<p>
Now think about what happens with <code>run-jetty</code>. It already has a function object
that was passed to it, and it doesn’t know about the var associated with the
symbol <code>router</code> anymore. There’s no way that it could know that there’s a new
function object it should be using instead. If only there was a way that we
could pass a function that would look up the current value of the var before
calling it with its arguments!
</p>

<p>
As it turns out, the Clojure devs foresaw this need, and vars implement the
<code>IFn</code> interface doing exactly that! So if we passed a var to <code>run-jetty</code>, every
time it tried to call the var as a function it would first dereference itself,
assume the contained object is a function object, and then call it with the same
arguments the var was called with.
</p>

<p>
Now that we know vars can do this, we just need to know how to pass the var
object itself to <code>run-jetty</code> instead of the function object. This is what the
<code>#&#39;</code> syntax means in Clojure, and it’s equivalent to calling the <code>var</code> special
form on a symbol.
</p>
</div>
</div>

<div id="outline-container-orgdc41062">
<h2 id="orgdc41062"><span>5.</span> Gaining Intuition</h2>
<div id="text-5">
<p>
Now that we’ve used the var quote (the name for the <code>#&#39;</code> syntax) on the
<code>router</code>, we should be home free, right? Not quite. Let’s say that we need to
modify <code>file-handler</code>. We’ve determined we’re vulnerable to directory traversal
attacks because we’re not validating the path before we read it from disk.
Somebody else has already made a handy function to handle these cases, called
<code>util/safe-path?</code>, and it returns a truthy value if it’s safe to read the given
path as html.
</p>

<div>
<pre><span>(</span><span>defn</span> <span>file-handler</span>
  <span>[</span>file-path<span>]</span>
  <span>(</span><span>if</span> <span>(</span><span>util</span>/safe-path? file-path<span>)</span>
    <span>(</span><span>if-let</span> <span>[</span>html-body <span>(</span><span>util</span>/read-html file-path<span>)</span><span>]</span>
      <span>{</span><span>:status</span> <span>200</span>
       <span>:body</span> html-body<span>}</span>
      <span>{</span><span>:status</span> <span>404</span>
       <span>:body</span> <span>(</span><span>util</span>/read-html <span>&#34;not-found.html&#34;</span><span>)</span><span>}</span><span>)</span>
    <span>{</span><span>:status</span> <span>400</span>
     <span>:body</span> <span>(</span><span>util</span>/read-html <span>&#34;invalid-path.html&#34;</span><span>)</span><span>}</span><span>)</span><span>)</span>
</pre>
</div>

<p>
If the body is a safe path, we happily try to read it, returning a 404 status if
it’s not found. If it’s <i>not</i> a safe path, we return a 400 invalid request.
</p>

<p>
Once we evaluate this function we test our routes again and find some very
strange behavior. If we make a request to <code>/articles/../admin-ui/index.html</code>, it
happily returns this file! This is very bad. Let’s check the other routes that
use <code>file-handler</code>.
</p>

<p>
The person who wrote <code>util/safe-path?</code> did some thinking about 404 errors and
similar and decided that <code>not-found.html</code> isn’t a safe path because it wouldn’t
make sense to return a 200 status code when you’re trying to get the 404 error
page.
</p>

<p>
So now we make a request to <code>/not-found</code>… and it returns a 400 with the text
from <code>invalid-path.html</code>! You should really talk to that coworker who thinks
that the <code>util/safe-path?</code> code should worry about response code semantics
despite it not being a part of the request handler functions.
</p>

<p>
Questionable choices about path validation aside, why does one route have the
updated code for <code>file-handler</code> and the other doesn’t? Neither one of them is
using the var quote, so it seems like <b>both</b> of them should be using the old
code if one is.
</p>

<p>
Let’s take another look at our router definition and think about evaluation
model again.
</p>

<div>
<pre><span>(</span><span>def</span> <span>router</span>
  <span>(</span><span>ring</span>/ring-handler
   <span>(</span><span>ring</span>/router
    <span>[</span><span>[</span><span>&#34;/not-found&#34;</span> <span>{</span><span>:get</span> #<span>(</span>assoc <span>(</span>file-handler <span>&#34;not-found.html&#34;</span><span>)</span> <span>:status</span> <span>404</span><span>)</span><span>}</span><span>]</span>
     <span>[</span><span>&#34;/articles/:file&#34;</span> <span>{</span><span>:get</span> <span>(</span>wrap-path-param file-handler <span>:file</span><span>)</span><span>}</span><span>]</span><span>]</span><span>)</span><span>)</span><span>)</span>
</pre>
</div>

<p>
When we evaluate the arguments to <code>ring/router</code> it evaluates the vector, which
in turn evaluates each of its elements before returning itself. This happens
recursively with each of the routes. The strings return themselves unaltered,
the maps evaluate all of their keys and values before returning themselves. The
keywords return themselves unaltered, and now we get to the interesting bit: the
values.
</p>

<p>
Let’s start with the value for the article endpoint. It’s a list, so it
evaluates to a function call. It calls the <code>wrap-path-param</code> function with the
result of evaluating each of the arguments. The first argument is
<code>file-handler</code>, and that works just like it did when we passed <code>router</code> to
<code>ring-jetty</code>. It looks up the var, gets the function object out, and uses that
as the argument to <code>wrap-path-param</code>. If we use a var quote on <code>file-handler</code>,
it will use the new function object, the same way the <code>#&#39;router</code> did with
<code>run-jetty</code>.
</p>

<p>
So that explains why the articles endpoint used the old code, but why did the
<code>/not-found</code> endpoint use the new code? The value in the map is a function
literal, and here we find our answer. Function literals don’t evaluate their
bodies when they are evaluated, they return a function object. That function
object, when called, will evaluate its body. So when the <code>router</code> is called and
the <code>/not-found</code> endpoint reached, it calls this function object, and only
<i>then</i> does the symbol <code>file-handler</code> get evaluated, its associated var
dereferenced, and the returned function object called. And because every time
the handler function object is called the body is evaluated again, that means
that <code>file-handler</code> is looked up each time, getting the new value.
</p>

<p>
This means that we have to pay attention not just to references to different
functions, but we have to pay attention to when those references are evaluated,
and that will tell us whether or not we need to use a var quote.
</p>
</div>
</div>

<div id="outline-container-orgfd464c6">
<h2 id="orgfd464c6"><span>6.</span> When This Applies</h2>
<div id="text-6">
<p>
Something that you might not have noticed just yet but that may seem obvious
when I point it out is that every circumstance where we see stale code being
used is the result of a function being used as a value in a context that is only
evaluated once. The <code>file-handler</code> function was passed as an argument inside a
<code>def</code> for the <code>router</code>, the <code>router</code> itself was used inside the body of the
<code>-main</code> function that you called once to start up the server and ideally would
not call again.
</p>

<p>
This pattern is not coincidence. Any time code will be called repeatedly over
the course of the runtime of your program or REPL session will have new code
reflected the next time that code is run after the evaluation takes place. This
means you don’t have to worry about this inside the bodies of most functions
besides initialization functions and application loops.
</p>

<p>
This is also why many types of applications you may work on don’t suffer from
reloadability problems at all, and only the types of programs I called out at
the beginning of this post are affected.
</p>

<p>
In general, you will need to ask yourself when writing a piece of code how often
that code will be executed. If it will be executed only a small number of times
at the start of your application or during re-evaluation and holds onto function
objects as we’ve seen in the examples in this article, then you will have to
consider where to apply the var quote.
</p>
</div>
</div>

<div id="outline-container-orge066387">
<h2 id="orge066387"><span>7.</span> Caveats</h2>
<p>
While everything said above is approximately correct, it’s been framed in terms
of the way a Lisp interpreter would work, and not in terms of how a compiler,
like Clojure’s, would actually resolve this. The actual semantics should match
entirely, but it’s important to know that “evaluation” in Clojure is mostly a
conceptual framework that we impose on the language because it matches how Lisp
interpreters work, and that the real version works slightly differently. If
you’d like to read further about how these things work, you can consult the
official documentation on <a href="https://clojure.org/reference/evaluation">evaluation</a> and <a href="https://clojure.org/reference/vars">vars</a>.
</p>
</div>

<div id="outline-container-org620b1e0">
<h2 id="org620b1e0"><span>8.</span> Conclusion</h2>
<p>
Congratulations on making it to the end of my first blog post! I hope you
understand the difference between using a var or a function object a little
better, and that you now know enough to go and make your existing software more
reloadable! If you just use Clojure yourself, I wish you well and I hope to see
you back to read more posts! If, however, you use Clojure as a teaching tool,
especially in time-constrained environments or to complete beginners, read on to
see a magical way to bypass this problem entirely, at the cost of your code
becoming somewhat more mysterious.
</p>
</div>

<div id="outline-container-org3c10371">
<h2 id="org3c10371"><span>9.</span> A Teaching Solution</h2>
<div id="text-9">
<p>
Unfortunately, the fact that you have to know so much about Clojure’s evaluation
model in order for it to make sense when to use a bare symbol and when to use a
var quoted symbol makes this a real tripping hazard for beginner to intermediate
programmers who just want a reasonable reloading experience, and while I
recommend learning this for anybody who wants to advance their Clojure
knowledge, for someone just learning Clojure from scratch, it might be too much
information to dump this onto them right from the beginning just to be able to
experience how fun it is to program with a REPL.
</p>

<p>
In cases where it’s important to be able to work with the full power of the
REPL, but it’s not reasonable to dive this deep into the evaluation model, like
in an hour long coding camp or a tutorial for complete beginners with Clojure
who want to write real software as they learn, it could be worthwhile to
introduce a construct which allows you to use function references everywhere and
simply not worry about reloadability.
</p>

<p>
For exactly this purpose, I’ve designed a macro (which you are free to copy and
use as you will, consider it to be under an MIT license) which acts like <code>defn</code>
but which will always run the latest version of the body that has been
evaluated, no matter if you have var-quoted it or not.
</p>

<div>
<pre><span>(</span>require &#39;<span>[</span>clojure.spec.alpha <span>:as</span> s<span>]</span><span>)</span>

<span>(</span><span>s</span>/<span>def</span> <span>::defreloadable-args</span>
  <span>(</span><span>s</span>/cat <span>:name</span> simple-symbol?
         <span>:doc</span> <span>(</span><span>s</span>/? string?<span>)</span>
         <span>:attr-map</span> <span>(</span><span>s</span>/? map?<span>)</span>
         <span>:fn-tails</span> <span>(</span><span>s</span>/+ any?<span>)</span><span>)</span><span>)</span>

<span>(</span><span>defmacro</span> <span>defreloadable</span>
  <span>&#34;Defines a new function as [[</span><span>defn</span><span>]], but old references will refer to new versions when reloaded.</span>

<span>  This will construct a phantom var that&#39;s used for the lookup, so calls to</span>
<span>  functions defined with this macro will have an additional layer of</span>
<span>  indirection as compared to normal functions. This should also work in</span>
<span>  production environments compiled with direct linking turned on.</span>
<span>  I do not recommend using this macro, but it can be useful for beginners</span>
<span>  who are learning how to write webservers or other persistent applications</span>
<span>  and don&#39;t want to worry about having a bad reloadability experience.</span>
<span>  Instead of using this, I recommend learning about Clojure&#39;s evaluation</span>
<span>  model, which will allow you to have the same benefits as using this</span>
<span>  macro, but without any magic.&#34;</span>
  <span>[</span>&amp; args<span>]</span>
  <span>(</span><span>let</span> <span>[</span>args <span>(</span><span>s</span>/conform <span>::defreloadable-args</span> args<span>)</span><span>]</span>
    `<span>(</span><span>let</span> <span>[</span>v# <span>(</span><span>or</span> <span>(</span><span>when-let</span> <span>[</span>fn# <span>(</span><span>binding</span> <span>[</span><span>*ns*</span> ~<span>*ns*</span><span>]</span>
                                   <span>(</span>resolve &#39;~<span>(</span><span>:name</span> args<span>)</span><span>)</span><span>)</span><span>]</span>
                    <span>(</span><span>-&gt;</span> <span>(</span>meta fn#<span>)</span> <span>::impl</span><span>)</span><span>)</span>
                  <span>(</span><span>with-local-vars</span> <span>[</span>v# <span>nil</span><span>]</span> v#<span>)</span><span>)</span><span>]</span>
       <span>(</span>alter-var-root v# <span>(</span>constantly <span>(</span><span>fn</span> ~<span>(</span><span>:name</span> args<span>)</span> ~@<span>(</span><span>:fn-tails</span> args<span>)</span><span>)</span><span>)</span><span>)</span>
       <span>(</span><span>doto</span> <span>(</span><span>def</span> ~<span>(</span><span>:name</span> args<span>)</span> <span>(</span><span>fn</span> <span>[</span>~&#39;&amp; args#<span>]</span> <span>(</span>apply @v# args#<span>)</span><span>)</span><span>)</span>
         <span>(</span>alter-meta! merge <span>(</span>assoc <span>(</span>merge <span>{</span><span>:doc</span> ~<span>(</span><span>:doc</span> args<span>)</span><span>}</span>
                                          ~<span>(</span><span>:attr-map</span> args<span>)</span><span>)</span>
                                   <span>::impl</span> v#<span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
<span>(</span><span>s</span>/fdef defreloadable
  <span>:args</span> <span>::defreloadable-args</span><span>)</span>
</pre>
</div>

<p>
I won’t go into detail about how the internals of this macro work, but I’d be
happy to make another post about it if it’s requested.
</p>

<p>
I also, as mentioned in the docstring, <b>do not</b> recommend that you use this for
any code that matters. For one thing it’s less performant, but the far more
important thing I think is that for anyone who <i>does</i> understand the Clojure
evaluation model as described in this article, usage of the above macro will
make code more confusing, with behavior changing at unexpected times during
re-evaluation of code because you can come to rely on Clojure’s normal behavior.
</p>
</div>
</div>
</div><div id="postamble">

<p>Created: 2022-11-28 Mon 16:49</p>
</div></div>
  </body>
</html>
