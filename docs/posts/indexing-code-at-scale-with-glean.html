<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://engineering.fb.com/2024/12/19/developer-tools/glean-open-source-code-indexing/">Original</a>
    <h1>Indexing Code at Scale with Glean</h1>
    
    <div id="readability-page-1" class="page"><div>

		<ul>
<li aria-level="1"><span>We’re sharing details about </span><a href="https://glean.software/" target="_blank" rel="noopener"><span>Glean</span></a><span>, Meta’s open source system for collecting, deriving, and working with facts about source code.</span></li>
<li aria-level="1"><span>In this blog post we’ll talk about why a system like Glean is important, explain the rationale for Glean’s design, and run through some of the ways we’re using Glean to supercharge our developer tooling at Meta.</span></li>
</ul>
<p><span>In August 2021 we open-sourced our code indexing system </span><a href="https://glean.software/" target="_blank" rel="noopener"><span>Glean</span></a><span>. Glean collects information about source code and provides it to developer tools through an efficient and flexible query language. We use Glean widely within Meta to power a range of developer tools including code browsing, code search, and documentation generation.</span></p>
<h2>Code Indexing</h2>
<p><span>Many tools that developers use rely on information extracted from the code they’re working on. For example:</span></p>
<ul>
<li aria-level="1"><span>Code navigation (“Go to definition”) in an IDE or a code browser;</span></li>
<li aria-level="1"><span>Code search;</span></li>
<li aria-level="1"><span>Automatically-generated documentation;</span></li>
<li aria-level="1"><span>Code analysis tools, such as dead code detection or linting.</span></li>
</ul>
<p><span>The job of collecting information from code is often called </span><i><span>code indexing</span></i><span>. A code indexing system’s job is to efficiently answer the questions your tools need to ask, such as, “Where is the definition of </span><span>MyClass</span><span>?” or “Which functions are defined in </span><span>myfile.cpp</span><span>?”</span></p>
<p><span>An IDE will typically do indexing as needed, when you load a new file or project for example. But the larger your codebase, the more important it becomes to do code indexing ahead of time. For large projects it becomes impractical to have the IDE process all the code of your project at startup and, depending on what language you’re using, that point may come earlier or later: C++ in particular is problematic due to the long compile times.</span></p>
<p><span>Moreover, with a larger codebase and many developers working on it, it makes sense to have a shared centralized indexing system so that we don’t repeat the work of indexing on every developer’s machine. And as the data produced by indexing can become large, we want to make it available over the network through a query interface rather than having to download it.</span></p>
<p><span>This leads to an architecture like this:<img decoding="async" src="https://engineering.fb.com/wp-content/uploads/2024/12/Meta-Glean-image-1.png?w=768" alt="" width="636" height="450" srcset="https://engineering.fb.com/wp-content/uploads/2024/12/Meta-Glean-image-1.png 768w, https://engineering.fb.com/wp-content/uploads/2024/12/Meta-Glean-image-1.png?resize=96,68 96w, https://engineering.fb.com/wp-content/uploads/2024/12/Meta-Glean-image-1.png?resize=192,136 192w" sizes="(max-width: 992px) 100vw, 62vw"/></span></p>
<p><span>In practice the real architecture is highly distributed:</span></p>
<ul>
<li aria-level="1"><span>Indexing can be heavily parallelized and we may have many indexing jobs running concurrently;</span></li>
<li aria-level="1"><span>The query service will be widely distributed to support load from many clients that are also distributed;</span></li>
<li aria-level="1"><span>The databases will be replicated across the query service machines and also backed up centrally.</span></li>
</ul>
<p><span>We’ve found that having a centralized indexing infrastructure enables a wide range of powerful developer tools. We’ll talk about some of the ways we’ve deployed Glean shortly, but first we’ll dive into the rationale for Glean’s design.</span></p>
<h2><b>How is Glean different?</b></h2>
<p><span>Code indexing systems have been around for a while. For example, there’s a well-established format called </span><a href="https://microsoft.github.io/language-server-protocol/" target="_blank" rel="noopener"><span>LSIF</span></a><span> used by IDEs that caches information about code navigation.</span></p>
<p><span>When we designed Glean we wanted a system that wasn’t tied either to particular programming languages or to any particular use case. While we had some use cases in mind that we wanted to support—primarily code navigation of course—we didn’t want to design the system around one use case, in the hope that a more general system would support emerging requirements further into the future.</span></p>
<p><span>Therefore:</span></p>
<ul>
<li aria-level="1"><b>Glean doesn’t decide for you what data you can store</b><span>. Indeed, most languages that Glean indexes have their own data schema and Glean can store arbitrary non-programming-language data too. The data is ultimately stored using </span><a href="https://rocksdb.org/" target="_blank" rel="noopener"><span>RocksDB</span></a><span>, providing good scalability and efficient retrieval.</span></li>
<li aria-level="1"><b>Glean’s query language is very general</b><span>. It’s a declarative logic-based query language that we call </span><i><span>Angle</span></i><span> (“Angle” is an anagram of “Glean”, and means “to fish”). Angle supports </span><i><span>deriving</span></i><span> information automatically, either on-the-fly at query time or ahead of time; this is a powerful mechanism that enables Glean to abstract over language-specific data and provide a language-neutral view of the data.</span></li>
</ul>
<p><span>Storing arbitrary language-specific data can be very powerful. For example, in C++ we use the detailed data to detect dead code such as unused </span><span>#include</span><span> or </span><span>using</span><span> statements. The latter in particular is rather tricky to do correctly and requires the data to include some C++-specific details, such as which </span><span>using</span><span> statement is used to resolve each symbol reference.</span></p>
<p><span>On the other hand, clients often don’t want the full language-specific data. They want to work at a higher level of abstraction. Imagine asking questions like, “Give me the names and locations of all the declarations in this file”, which should work for any language, and which you could use to implement a code outline feature in a code browser. Glean can provide this language-neutral view of the data by defining an abstraction layer in the schema itself – the mechanism is similar to SQL views if you’re familiar with those. This means that we don’t have to compromise between having detailed language-specific data or a lowest-common-denominator language-neutral view; we can have both.</span></p>
<p><span>This generality has allowed Glean to extend to a number of use cases beyond what we originally envisaged. We’ll cover some of those later in this post.</span></p>
<h2>A taste of Angle</h2>
<p><span>Glean has a unified language, Angle, for specifying both schemas and queries. As mentioned above, each language that we index has its own schema. To give you a flavor of this, here’s a fragment of the schema for C++ function declarations:</span></p>
<p><img decoding="async" src="https://engineering.fb.com/wp-content/uploads/2024/12/Meta-Glean-image-2.png?w=380" alt="" width="380" height="206" srcset="https://engineering.fb.com/wp-content/uploads/2024/12/Meta-Glean-image-2.png 380w, https://engineering.fb.com/wp-content/uploads/2024/12/Meta-Glean-image-2.png?resize=96,52 96w, https://engineering.fb.com/wp-content/uploads/2024/12/Meta-Glean-image-2.png?resize=192,104 192w" sizes="(max-width: 992px) 100vw, 62vw"/></p>
<p><span>Defining a schema for Glean is just like writing a set of type definitions. The braces surround a record definition, with a set of fields and their types. </span></p>
<ul>
<li aria-level="1"><span>A </span><span>FunctionDeclaration</span><span> is a </span><i><span>predicate</span></i><span> (roughly equivalent to a table in SQL). </span></li>
<li aria-level="1"><span>The instances of a predicate are called </span><i><span>facts</span></i><span> (roughly equivalent to rows in SQL). </span></li>
<li aria-level="1"><span>A predicate is a thing that you can query, and a query returns facts. </span></li>
</ul>
<p><span>To query efficiently you specify a prefix of the fields. So, for example, we can retrieve a particular </span><span>FunctionDeclaration</span><span> efficiently if we know its </span><span>name</span><span>.</span></p>
<p><span>Let’s write a query to find the function </span><span>folly::parseJson</span><span>:</span></p>
<p><img loading="lazy" decoding="async" src="https://engineering.fb.com/wp-content/uploads/2024/12/Meta-Glean-image-3.png?w=562" alt="" width="562" height="83" srcset="https://engineering.fb.com/wp-content/uploads/2024/12/Meta-Glean-image-3.png 562w, https://engineering.fb.com/wp-content/uploads/2024/12/Meta-Glean-image-3.png?resize=96,14 96w, https://engineering.fb.com/wp-content/uploads/2024/12/Meta-Glean-image-3.png?resize=192,28 192w" sizes="auto, (max-width: 992px) 100vw, 62vw"/></p>
<p><span>Without going into all the details, at a high level this query specifies that we want to find </span><span>FunctionDeclaration</span><span> facts that have a particular name and namespace. Glean can return results for this query in about a millisecond.</span></p>
<p><span>Angle supports more complex queries too. For example, to find all classes that inherit from a class called </span><span>exception</span><span> and have a method called </span><span>what</span><span> that overrides a method in a base class:</span></p>
<p><img loading="lazy" decoding="async" src="https://engineering.fb.com/wp-content/uploads/2024/12/Meta-Glean-image-4.png?w=717" alt="" width="717" height="240" srcset="https://engineering.fb.com/wp-content/uploads/2024/12/Meta-Glean-image-4.png 717w, https://engineering.fb.com/wp-content/uploads/2024/12/Meta-Glean-image-4.png?resize=96,32 96w, https://engineering.fb.com/wp-content/uploads/2024/12/Meta-Glean-image-4.png?resize=192,64 192w" sizes="auto, (max-width: 992px) 100vw, 62vw"/></p>
<p><span>This query returns the first results in a few milliseconds, and because there might be a lot of results we can fetch the results incrementally from the query server.</span></p>
<h2>Incremental indexing</h2>
<p><span>An important innovation in Glean is the ability to index </span><i><span>incrementally</span></i><span>. As the codebase grows, and the rate of change of the codebase increases (a monorepo suffers from both of these problems) we find that we can’t provide up-to-date information about the latest code because indexing the entire repository can take a long time. The index is perpetually out of date, perhaps by many hours.</span></p>
<p><span>The solution to this scaling problem is to process </span><i><span>just the changes</span></i><span>. In terms of computer science big-O notation, we want the cost of indexing to be </span><i><span>O(changes)</span></i><span> rather than </span><i><span>O(repository)</span></i><span>.</span></p>
<p><span>But actually achieving this is not as straightforward as it might sound.</span></p>
<p><span>We don’t want to destructively modify the original data, because we would like to be able to provide data at multiple revisions of the repository, and to do that without storing multiple full-sized copies of the data. So we would like to store the changes in such a way that we can view the whole index at both revisions simultaneously.</span></p>
<p><span>Even if we figure out a way to represent the changes, in practice it isn’t possible to achieve </span><i><span>O(changes)</span></i><span> for many programming languages. For example, in C++ if a header file is modified, we have to reprocess every source file that depends on it (directly or indirectly). We call this the </span><i><span>fanout</span></i><span>. So in practice the best we can do is </span><i><span>O(fanout)</span></i><span>.</span></p>
<p><span>Glean solves the first problem with an ingenious method of </span><i><span>stacking</span></i><span> immutable databases on top of each other. A stack of databases behaves just like a single database from the client’s perspective, but each layer in the stack can non-destructively add information to, or hide information from, the layers below. </span></p>
<p><img loading="lazy" decoding="async" src="https://engineering.fb.com/wp-content/uploads/2024/12/Meta-Glean-image-5.png?w=569" alt="" width="569" height="458" srcset="https://engineering.fb.com/wp-content/uploads/2024/12/Meta-Glean-image-5.png 569w, https://engineering.fb.com/wp-content/uploads/2024/12/Meta-Glean-image-5.png?resize=96,77 96w, https://engineering.fb.com/wp-content/uploads/2024/12/Meta-Glean-image-5.png?resize=192,155 192w" sizes="auto, (max-width: 992px) 100vw, 62vw"/></p>
<p><span>The full details are beyond the scope of this post, for more on how incrementality works see: </span><a href="https://glean.software/blog/incremental/" target="_blank" rel="noopener"><span>Incremental indexing with Glean</span></a><span>.</span></p>
<p><span>Finding the fanout of a set of changes is different for each language.  Interestingly the fanout can often be obtained using Glean queries: for example for C++, the fanout is calculated by finding all the files that </span><span>#include</span><span> one of the changed files, and then repeating that query until there are no more files to find.</span></p>
<h2>How we use Glean at Meta</h2>
<h3>Code navigation</h3>
<p><span>Code navigation at scale, on large monorepos containing millions of lines in diverse programming languages, is a challenging problem. But what makes it different from the code navigation support available in modern IDEs, other than scale? In our experience, code indexing a la Glean offers the following advantages over IDEs:</span></p>
<ol>
<li aria-level="1"><span>Instantly available: Just open the code browser web app (our internal tool uses Monaco) and navigate without waiting for the IDE, build system, and LSP server to initialize</span></li>
<li aria-level="1"><span>More widely available: You can integrate code navigation in pretty much any app that shows code! One particularly useful integration is in your code review tool (ours is called Phabricator), but more on that later.</span></li>
<li aria-level="1"><span>Full repo visibility: Glean allows you to, for example, find all the references to a function, not just the ones visible to the IDE. This is particularly useful for finding dead code, or finding clients of an API that you want to change.</span></li>
<li aria-level="1"><span>Symbol search for all the languages across the whole repository.</span></li>
<li aria-level="1"><span>Cross language navigation: A common situation that comes up is a remote procedure call (RPC). When browsing the code you might want to jump to the service definition or, indeed, to the service implementation itself. Another case is languages with a foreign function interface (FFI), where you would like to browse from an FFI call to the corresponding definition in the target language.</span></li>
</ol>
<p><span>Our architecture for code navigation is based on </span><a href="https://github.com/facebookincubator/Glean/tree/main/glean/glass" target="_blank" rel="noopener"><span>Glass</span></a><span>, a symbol server that abstracts all the complexities of Glean by implementing the usual code navigation logic in a simple but powerful API. The code browser needs only a single Glass API call,</span><i><span> documentSymbols(repo,path,revision),</span></i><span> to obtain a list of all the definitions and references in a source file, including source and target spans. The list of definitions is used to render an outline of the file, and the list of references to render underlines that can be hovered over or clicked to navigate. Finally, other code browser features like Find References or Call Hierarchy are also driven by API calls to Glass. </span></p>
<p><img loading="lazy" decoding="async" src="https://engineering.fb.com/wp-content/uploads/2024/12/Meta-Glean-image-6.png?w=844" alt="" width="844" height="186" srcset="https://engineering.fb.com/wp-content/uploads/2024/12/Meta-Glean-image-6.png 844w, https://engineering.fb.com/wp-content/uploads/2024/12/Meta-Glean-image-6.png?resize=768,169 768w, https://engineering.fb.com/wp-content/uploads/2024/12/Meta-Glean-image-6.png?resize=96,21 96w, https://engineering.fb.com/wp-content/uploads/2024/12/Meta-Glean-image-6.png?resize=192,42 192w" sizes="auto, (max-width: 992px) 100vw, 62vw"/></p>
<p><span>The code for Glass is also open-source, you can find it in </span><a href="https://github.com/facebookincubator/Glean/tree/main/glean/glass" target="_blank" rel="noopener"><span>glean/glass</span></a><span> on GitHub.</span></p>
<h3>Speeding up the IDE</h3>
<p><span>Using an IDE such as VS Code on a large project, or a project with a large set of dependencies, or in a large monorepo tends to lead to a degraded experience as the IDE isn’t able to analyze all the code that you might want to explore. At Meta we’re using Glean to plug this gap for C++ developers: Because Glean has already analyzed the whole repository, C++ developers have access to basic functionality such as go-to-definition, find-references, and doc comment hovercards for the whole repository immediately on startup. As the IDE loads the files the developer is working on, the C++ language service seamlessly blends the Glean-provided data with that provided by the native clangd backend.</span></p>
<p><span>Our target was C++ developers initially because that group typically has the worst IDE experience due to the long compile times, but the approach is not specific to C++ and we imagine other languages following the same path in the future.</span></p>
<h3>Documentation generation</h3>
<p><span>The data we store in Glean includes enough information to reconstruct the full details of an API: classes, methods, type signatures, inheritance, and so on. Glean also collects documentation from the source code when it uses the standard convention for the language, e.g., in C++ the convention is </span><span>/// comment</span><span> or </span><span>/** comment */</span><span>. With API data and documentation strings in Glean we can produce automatically-generated documentation on demand. </span></p>
<p><span>Here’s an example page for the </span><span>folly::Singleton</span><span> type:</span></p>
<p><img loading="lazy" decoding="async" src="https://engineering.fb.com/wp-content/uploads/2024/12/Meta-Glean-image-7.png?w=1024" alt="" width="1024" height="664" srcset="https://engineering.fb.com/wp-content/uploads/2024/12/Meta-Glean-image-7.png 1672w, https://engineering.fb.com/wp-content/uploads/2024/12/Meta-Glean-image-7.png?resize=916,594 916w, https://engineering.fb.com/wp-content/uploads/2024/12/Meta-Glean-image-7.png?resize=768,498 768w, https://engineering.fb.com/wp-content/uploads/2024/12/Meta-Glean-image-7.png?resize=1024,664 1024w, https://engineering.fb.com/wp-content/uploads/2024/12/Meta-Glean-image-7.png?resize=1536,997 1536w, https://engineering.fb.com/wp-content/uploads/2024/12/Meta-Glean-image-7.png?resize=96,62 96w, https://engineering.fb.com/wp-content/uploads/2024/12/Meta-Glean-image-7.png?resize=192,125 192w" sizes="auto, (max-width: 992px) 100vw, 62vw"/></p>
<p><span>The data for these pages is produced by Glass and rendered by a client-side UI. The documentation is fully hyperlinked so the user can navigate around all the APIs throughout the repository easily. Meta engineers get consistent code documentation integrations across all the programming languages supported by Glean.</span></p>
<h3>Symbol IDs</h3>
<p><span>Glass assigns every symbol a </span><i><span>symbol ID</span></i><b><i>, </i></b><span>a unique string that identifies the symbol. For example, the symbol ID for </span><span>folly::Singleton</span><span> would be something like, </span><span>REPOSITORY/cpp/folly/Singleton</span><span>. The symbol ID can be used to link directly to the documentation page for the symbol, so there’s a URL for every symbol that doesn’t change even if the symbol’s definition moves around. </span></p>
<p><span>We can use the symbol ID to request information about a symbol from Glass, for example to find all the references to the symbol throughout the repository. All of this works for every language, although the exact format for a symbol ID varies per language.</span></p>
<h3>Analyzing code changes</h3>
<p><span>Glean indexing runs on diffs (think, “pull requests”) to extract a mechanical summary of the changeset that we call a </span><i><span>diff sketch</span></i><span>. For example, a diff might introduce a new class, remove a method, add a field to a type, introduce a new call to a function, and so on. The diff sketch lists all of these changes in a machine-readable form.</span></p>
<p><span>Diff sketches are used to drive a simple static analysis that can identify potential issues that might require further review. They can also be used to drive non-trivial lint rules, rich notifications, and semantic search over commits. One example of the latter is connecting a production stack trace to recent commits that modified the affected function(s), to help root-cause performance issues or new failures.</span></p>
<p><span>Indexing diffs also powers code navigation in our code review tools, giving code reviewers access to accurate go-to-definition on the code changes being reviewed, along with other code insights such as type-on-hover and documentation. This is a powerful lift to the code review process, making it easier for reviewers to understand the changes and provide valuable review feedback. At Meta this is enabled for a <a href="https://engineering.fb.com/2022/07/27/developer-tools/programming-languages-endorsed-for-server-side-use-at-meta/" target="_blank" rel="noopener">variety of different languages</a>, including C++, Python, PHP, Javascript, <a href="https://engineering.fb.com/2021/04/29/developer-tools/rust/" target="_blank" rel="noopener">Rust</a>, Erlang, Thrift, and even Haskell.</span></p>
<h2>More applications for Glean</h2>
<p><span>Aside from the primary applications described above, Glean is also used to</span></p>
<ul>
<li aria-level="1"><span>Analyse build dependency graphs.</span></li>
<li aria-level="1"><a href="https://engineering.fb.com/2023/10/24/data-infrastructure/automating-dead-code-cleanup/" target="_blank" rel="noopener"><span>Detect and remove dead code</span></a><span>.</span></li>
<li aria-level="1"><span>Track the progress of API migrations.</span></li>
<li aria-level="1"><span>Measure various metrics that contribute to code complexity.</span></li>
<li aria-level="1"><span>Track test coverage and select tests to run.</span></li>
<li aria-level="1"><a href="https://engineering.fb.com/2023/10/31/data-infrastructure/automating-data-removal/" target="_blank" rel="noopener"><span>Automate data removal</span></a><span>.</span></li>
<li aria-level="1"><span>Retrieval Augmented Generation (RAG) in AI coding assistants</span></li>
</ul>
<p><span>Furthermore, there are an ever-growing number of ad-hoc queries made by various people and systems to solve a variety of problems. Having a system like Glean means you can ask questions about your code: we don’t know all the questions we might want to ask, nor do we know all the data we might want to store, so Glean deliberately aims to be as general as possible on both of these fronts.</span></p>
<h2>Try Glean today</h2>
<p><span>Visit the </span><a href="https://glean.software/" target="_blank" rel="noopener"><span>Glean site</span></a><span> for more details, technical documentation, and information on how to get started.</span></p>

		
	</div></div>
  </body>
</html>
