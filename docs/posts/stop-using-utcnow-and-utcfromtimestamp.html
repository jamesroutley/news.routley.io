<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.ganssle.io/articles/2019/11/utcnow.html">Original</a>
    <h1>Stop using utcnow and utcfromtimestamp</h1>
    
    <div id="readability-page-1" class="page"><div>
<section id="content">
  <article>
    
    <div><!-- Early draft reviewed by Mahmoud Hashemi -->
<p>If you are the kind of developer who prefers to work in UTC, you may have seen Python&#39;s <tt>datetime.utcnow()</tt> and <tt>datetime.utcfromtimestamp()</tt> methods and thought, &#34;Ah, yes, this is what I should do to work in UTC!&#34; But alas, this is <em>not</em> the best way to work with UTC datetimes. In fact I would say that it is <em>extremely</em> rare that you would want to use either of these functions. Consider the following dangerous code:</p>
<div><pre><span></span><span>from</span> <span>datetime</span> <span>import</span> <span>datetime</span>
<span>ts</span> <span>=</span> <span>1571595618.0</span>
<span>x</span> <span>=</span> <span>datetime</span><span>.</span><span>utcfromtimestamp</span><span>(</span><span>ts</span><span>)</span>
<span>x_ts</span> <span>=</span> <span>x</span><span>.</span><span>timestamp</span><span>()</span>

<span>assert</span> <span>ts</span> <span>==</span> <span>x_ts</span><span>,</span> <span>f</span><span>&#34;</span><span>{</span><span>ts</span><span>}</span><span> != </span><span>{</span><span>x_ts</span><span>}</span><span>&#34;</span>
</pre></div>
<p>When executed with your system locale set to UTC, this will succeed just fine, but when executed in any locale where the offset at that particular timestamp is something <em>other</em> than 0, the assertion fails — for example when executed with an <tt>America/New_York</tt> locale, you&#39;ll get <tt>AssertionError: 1571595618.0 != 1571610018.0</tt>.</p>
<p>This is due to an unfortunate quirk of history and a subtle shift in what it means for a datetime to be naïve that took place in the Python 2 to 3 transition. I imagine that these functions would not exist if the <tt>datetime</tt> library were redesigned today, but at the moment there are a mix of harmful and harmless uses of them out there, and it&#39;s not a simple matter to rip them all out. <a href="#pytz-familiar" id="footnote-reference-1">[1]</a></p>
<p>Rather than make you stick around for a history lesson as to why this problem exists, I&#39;m going to spoil the ending and say that the right thing to do is to pass a UTC object to the <tt>tz</tt> parameter of <tt>now()</tt> and <tt>fromtimestamp()</tt>, respectively, to get a <em>time zone-aware</em> datetime:</p>
<div><pre><span></span><span>from</span> <span>datetime</span> <span>import</span> <span>datetime</span><span>,</span> <span>timezone</span>
<span>ts</span> <span>=</span> <span>1571595618.0</span>
<span>x</span> <span>=</span> <span>datetime</span><span>.</span><span>fromtimestamp</span><span>(</span><span>ts</span><span>,</span> <span>tz</span><span>=</span><span>timezone</span><span>.</span><span>utc</span><span>)</span>
<span>x_ts</span> <span>=</span> <span>x</span><span>.</span><span>timestamp</span><span>()</span>

<span>assert</span> <span>ts</span> <span>==</span> <span>x_ts</span><span>,</span> <span>f</span><span>&#34;</span><span>{</span><span>ts</span><span>}</span><span> != </span><span>{</span><span>x_ts</span><span>}</span><span>&#34;</span>  <span># This assertion succeeds</span>
</pre></div>
<p>The problem with <tt>datetime.utcnow()</tt> and <tt>datetime.utcfromtimestamp()</tt> occurs because these return <em>naïve</em> datetimes (i.e. with no timezone attached), and in Python 3, these are interpreted as system-local times. Explicitly specifying a time zone solves the problem.</p>
<div id="naive-datetimes-as-local-time">
<h2>Naïve datetimes as local time</h2>
<p>When originally conceived, naïve datetimes were intended to be abstract, not representing any specific time zone, and it was up to the program to determine what they represent — this is no different from abstract numbers which can represent mass in kilograms, distance in meters or any other specific quantity according to the programmer&#39;s intention. By contrast <em>aware</em> datetimes represent a specific point in time in a specific time zone. Awareness of the datetime&#39;s time zone allows you to do things like <a href="https://blog.ganssle.io/articles/2018/02/aware-datetime-arithmetic.html">arithmetic</a> and <a href="https://blog.ganssle.io/articles/2018/02/a-curious-case-datetimes.html">comparison</a> between time zones, conversion to other time zones and other operations which require a concrete datetime.</p>
<p>In Python 3, two things have changed that make <tt>utcnow</tt> unnecessary and, in fact, dangerous. The first is that a concrete time zone class, <tt>datetime.timezone</tt>, was introduced, along with a constant UTC object, <tt>datetime.timezone.utc</tt>. With this change, you now have a clear and unambiguous way to mark which of your datetimes are in UTC without bringing in third party code or implementing your own UTC class.</p>
<p>The change that made <tt>utcnow</tt> <em>dangerous</em> is that naïve datetimes underwent a subtle shift in meaning: for certain operations that require interpreting a <tt>datetime</tt> as a fixed point in time, rather than throwing an error they would instead assume that the <tt>datetime</tt> represents the current system local time zone. So in Python 2, operations like <tt>astimezone()</tt> will raise an exception when called on a naïve datetime:</p>
<div><pre><span></span><span>&gt;&gt;&gt;</span> <span>from</span> <span>datetime</span> <span>import</span> <span>datetime</span>
<span>&gt;&gt;&gt;</span> <span>from</span> <span>dateutil</span> <span>import</span> <span>tz</span>
<span>&gt;&gt;&gt;</span> <span>datetime</span><span>(</span><span>2015</span><span>,</span> <span>5</span><span>,</span> <span>1</span><span>)</span><span>.</span><span>astimezone</span><span>(</span><span>tz</span><span>.</span><span>UTC</span><span>)</span>
<span>Traceback</span> <span>(</span><span>most</span> <span>recent</span> <span>call</span> <span>last</span><span>):</span>
  <span>File</span> <span>&#34;&lt;stdin&gt;&#34;</span><span>,</span> <span>line</span> <span>1</span><span>,</span> <span>in</span> <span>&lt;</span><span>module</span><span>&gt;</span>
<span>ValueError</span><span>:</span> <span>astimezone</span><span>()</span> <span>cannot</span> <span>be</span> <span>applied</span> <span>to</span> <span>a</span> <span>naive</span> <span>datetime</span>
</pre></div>
<p>but in Python 3 it will use your system&#39;s locale (on my machine it&#39;s <tt>America/New_York</tt>) and convert accordingly:</p>
<div><pre><span></span><span>&gt;&gt;&gt;</span> <span>from</span> <span>datetime</span> <span>import</span> <span>datetime</span>
<span>&gt;&gt;&gt;</span> <span>from</span> <span>dateutil</span> <span>import</span> <span>tz</span>
<span>&gt;&gt;&gt;</span> <span>datetime</span><span>(</span><span>2015</span><span>,</span> <span>5</span><span>,</span> <span>1</span><span>)</span><span>.</span><span>astimezone</span><span>(</span><span>tz</span><span>.</span><span>UTC</span><span>)</span>
<span>datetime</span><span>.</span><span>datetime</span><span>(</span><span>2015</span><span>,</span> <span>5</span><span>,</span> <span>1</span><span>,</span> <span>4</span><span>,</span> <span>0</span><span>,</span> <span>tzinfo</span><span>=</span><span>tzutc</span><span>())</span>
</pre></div>
<p>This is why the example that I started this post off with fails. The <tt>.timestamp()</tt> method gives a representation of a <em>fixed point in time</em>, not a point on the calendar; it returns <a href="https://en.wikipedia.org/wiki/Unix_time">Unix time</a>, which is the number of seconds since 1970-01-01T00:00:00 UTC, and if you call it on a naïve datetime, Python will assume that that datetime represents your machine&#39;s local time, even if you originally intended it to be UTC.</p>
</div>
<div id="conclusions">
<h2>Conclusions</h2>
<p>Even without the change in Python&#39;s model of what a naïve datetime means, I would still recommend that you not use <tt>utcnow()</tt> or <tt>utcfromtimestamp()</tt> simply because it&#39;s the wrong abstraction: to do so would be to represent a concrete point in time as an <em>abstract</em> datetime. <a href="#now-concrete" id="footnote-reference-2">[2]</a> You know that your datetime represents UTC, and it&#39;s easy to mark that clearly in Python, so there&#39;s very little reason <em>not</em> to do it. As it says in the warning recently added to <a href="https://docs.python.org/3/library/datetime.html#datetime.datetime.utcnow">the documentation</a>, you should prefer to use <tt>now</tt> in place of <tt>utcnow</tt> and <tt>fromtimestamp</tt> in place of <tt>utcfromtimestamp</tt>, so replace:</p>
<div><pre><span></span><span>&gt;&gt;&gt;</span> <span>dt_now</span> <span>=</span> <span>datetime</span><span>.</span><span>utcnow</span><span>()</span>
<span>&gt;&gt;&gt;</span> <span>dt_ts</span> <span>=</span> <span>datetime</span><span>.</span><span>utcfromtimestamp</span><span>(</span><span>1571595618.0</span><span>)</span>
</pre></div>
<p>with</p>
<div><pre><span></span><span>&gt;&gt;&gt;</span> <span>from</span> <span>datetime</span> <span>import</span> <span>timezone</span>
<span>&gt;&gt;&gt;</span> <span>dt_now</span> <span>=</span> <span>datetime</span><span>.</span><span>now</span><span>(</span><span>tz</span><span>=</span><span>timezone</span><span>.</span><span>utc</span><span>)</span>
<span>&gt;&gt;&gt;</span> <span>dt_ts</span> <span>=</span> <span>datetime</span><span>.</span><span>fromtimestamp</span><span>(</span><span>1571595618.0</span><span>,</span> <span>tz</span><span>=</span><span>timezone</span><span>.</span><span>utc</span><span>)</span>
</pre></div>
<p>or the equivalent using positional arguments.</p>
<p>One last thing to note: the reason that we cannot simply change <tt>utcnow()</tt> into an alias for <tt>now(timezone.utc)</tt> in the standard library is that would change the semantics of how those datetimes are treated by their consumers (and as such it would not be backwards-compatible). You should keep this in mind when converting over old code that uses <tt>utcnow</tt> and <tt>utcfromtimestamp</tt> — you will need to make sure that any code that consumes your datetimes is expecting an aware datetime. In my experience, this is not a high bar to clear, but you probably don&#39;t want to just do a search-and-replace on untested code before deploying to production and leaving work for the weekend.</p>
</div>

</div>
  </article>
</section>


    </div></div>
  </body>
</html>
