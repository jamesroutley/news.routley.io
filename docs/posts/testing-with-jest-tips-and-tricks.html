<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://onestepcode.com/jest-js-testing/?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=jest-js-testing">Original</a>
    <h1>Testing with Jest (tips and tricks)</h1>
    
    <div id="readability-page-1" class="page"><div>
						
<p>This post covers some tips and tricks while testing JavaScript with <a href="https://jestjs.io/">Jest</a>. We’ll start with some configuration and setup, followed by some testing practices: </p>



<ul><li>Avoid repetition using <code><a href="#test-each">test.each</a></code>.</li><li>Skip tests with <code><a href="#test-skip">test.skip</a></code>.</li><li>Focus on tests with <code><a href="#test-only">test.only</a></code>.</li><li><a href="#mock-functions">Mock functions</a>.</li><li>Testing <a href="#async-testing">async functions</a>.</li><li><a href="#fake-timers">Fake timers</a>.</li></ul>



<h2>Initial setup</h2>



<p>Here are some basic steps to setup <code>jest</code> .</p>



<p>Create a project folder and initialize npm.</p>



<pre data-enlighter-language="raw" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">$ mkdir jest-testing &amp;&amp; cd jest-jesting
$ npm init -y</pre>



<p>Install the necessary dependencies.</p>



<pre data-enlighter-language="raw" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">$ npm install jest babel-jest regenerator-runtime</pre>



<p><code>babel-jest</code> will be used by Jest to transform modern JavaScript code like <code>import</code> statements and arrow functions <code>() =&gt; {}</code>.</p>



<p><code>regenerator-runtime</code> is necessary for <code>async</code> functions.</p>



<p>After installing those packages, create the files <code>babel.config.js</code> and <code>jest.config.js</code> at the root directory.</p>



<pre data-enlighter-language="js" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">// babel.config.js
module.exports = {presets: [&#39;@babel/preset-env&#39;]}</pre>



<pre data-enlighter-language="js" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">// jest.config.js
module.exports = {
  transform: {
    &#34;^.+\\.js$&#34;: &#34;babel-jest&#34;,
  }
};</pre>



<p>With this setup, we’re instructing <code>jest</code> to transform <code>.js</code> files using <code>babel-jest</code>. </p>



<p>Finally, let’s add the following script to package.json:</p>



<pre data-enlighter-language="json" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">{
...
&#34;scripts&#34;: {
    ...
    &#34;test&#34;: &#34;jest&#34;
  },
}</pre>



<p>This way, we’ll be able to trigger the test suites with <code>npm test</code>.</p>



<h2>Project structure</h2>



<p>Throughout this tutorial we’ll “test” the following dummy module: <code>add.js</code> located at folder <code>src</code>.</p>



<pre data-enlighter-language="js" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">// add.js
export const add = (a, b) =&gt; a + b;</pre>



<p>Our initial tests file will be <code>add.test.js</code>:</p>



<pre data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">// add.test.js
test(&#34;testing&#34;, () =&gt; {});</pre>



<p>The resulting folder structure of our project will be as follows:</p>



<pre data-enlighter-language="raw" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">.
├── babel.config.js
├── jest.config.js
├── package.json
├── package-lock.json
├── setupTests.js
└── src
    ├── add.js
    └── add.test.js</pre>



<p>The tests can be triggered with <code>npm run test</code> or with <code>npx jest</code>. <code>jest</code> will automatically pick up all <code>.test.js</code> files and execute the tests in them.</p>



<p>Alternatively, we could place the tests in a <code>__tests__</code> folder. The best practice is to place either the <code>.test.js</code> files or the <code>__tests__</code> folder right next to the tested file. </p>



<h2>Configuring jest</h2>



<p>There are many different <a href="https://jestjs.io/docs/configuration#options">options</a> that can be passed to the <code>jest.config.js</code> file. Let’s see a few of them.</p>



<p><code>roots</code> is used to define the paths that jest should look test files in. In our case, that’s only the <code>src</code>  directory.</p>



<pre data-enlighter-language="js" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">roots: [&#34;&lt;rootDir&gt;/src/&#34;],</pre>



<p><code>&lt;rootDir&gt;</code> is the path where the <code>jest.config.js</code> file is located.</p>



<p><code>setupFilesAfterEnv</code> defines files that should be executed just before running the actual tests. Our setup file will be <code>setupTests.js</code> located at the root directory.</p>



<pre data-enlighter-language="js" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">setupFilesAfterEnv: [&#39;./setupTests.js&#39;],</pre>



<p>For example, we need to import the regenerator runtime for <code>async</code> functions to work on our tests. Instead of importing it explicitly on every test file, we can do so at the tests setup file.</p>



<pre data-enlighter-language="js" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">// setupTests.js
import &#34;regenerator-runtime/runtime&#34;;</pre>



<p>Finally, the <code>extraGlobals</code> allows us to specify global methods that will be used in the tests for faster lookup. For example, our tests will require functions from the <code>Math</code> module. </p>



<pre data-enlighter-language="js" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">extraGlobals: [&#34;Math&#34;]</pre>



<p>Note that we can still call <code>Math</code> functions inside our tests without setting this property. It’s used only to make references to <code>Math</code> faster. </p>



<p>Our resulting <code>jest.config.js</code> file would be:</p>



<pre data-enlighter-language="js" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">module.exports = {
  transform: {
    &#34;^.+\\.js$&#34;: &#34;babel-jest&#34;,
  },
  roots: [&#34;&lt;rootDir&gt;/src/&#34;],
  setupFilesAfterEnv: [&#34;./setupTests.js&#34;],
  extraGlobals: [&#34;Math&#34;],
};</pre>



<p>Now that we have jest and our project configured, let’s start testing!</p>



<h2 id="test-each">Avoid repetition with <code>test.each</code></h2>



<p>Consider the following two tests:</p>



<pre data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">// add.test.js
import { add } from &#34;./add&#34;;

test(&#34;add 1 and 1 equals 2&#34;, () =&gt; {
  const result = add(1, 1);
  const expected = 2;
  expect(result).toBe(expected);
});

test(&#34;add 2 and 2 equals 4&#34;, () =&gt; {
  const result = add(2, 2);
  const expected = 4;
  expect(result).toBe(expected);
});</pre>



<p>We can see that besides changing some values, the second test is almost an exact copy of the first test. This is a good use case for <code><a href="https://jestjs.io/docs/api#testeachtablename-fn-timeout">test.each</a></code></p>



<pre data-enlighter-language="js" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">test.each([
  [1, 1, 2],
  [2, 2, 4],
])(&#34;add %d + %d equals %d&#34;, (val1, val2, expectedVal) =&gt; {
  const result = add(val1, val2);
  expect(result).toBe(expectedVal);
});</pre>



<p>The first argument to <code>test.each</code> is a 2D array. Each row in the array contains the arguments that will be passed to the function that defines the test. See that not only the test function is parameterized, also the test description can be parameterized as a <code><a href="https://nodejs.org/api/util.html#util_util_format_format_args">printf</a></code> string. </p>



<p>In the previous example, each of <code>%d</code> is a placeholder for an integer value. The first <code>%d</code> takes the first numerical value in the array and so on.</p>



<h2 id="test-skip">Skipping tests with <code>test.skip</code></h2>



<p>Let’s say that, for some reason, we want to keep the first two tests we defined above. They could be useful for documentation or we might need them later on. Instead of commenting them to avoid running the tests each time, we can, use <code><a href="https://jestjs.io/docs/api#testskipname-fn">test.skip</a></code>.</p>



<pre data-enlighter-language="js" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">test.skip(&#34;add 1 and 1 equals 2&#34;, () =&gt; ...);

test.skip(&#34;add 2 and 2 equals 4&#34;, () =&gt; ...);</pre>



<p><code>jest</code> will ignore these tests when running <code>npm test</code>.</p>



<p>We can even use it with <code>test.each</code>:</p>



<pre data-enlighter-language="js" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">test.skip.each(...)(...);</pre>



<h2 id="test-only">When a test fails, try using <code>test.only</code></h2>



<p><code><a href="https://jestjs.io/docs/api#testonlyname-fn-timeout">test.only</a></code> is helpful in two situations. First, imagine you have a test suite with several tests. You add a new test and you would like to verify that this single new test passes. Adding <code>.only</code> to the test will make <code>jest</code> execute only that single test (and any other <code>test.only</code> tests).</p>



<p>In the example below, only test <code>n</code> would be executed.</p>



<pre data-enlighter-language="js" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">describe(&#34;My test suite&#34;, () =&gt; {
  test(&#34;1&#34;, ...);
  test(&#34;2&#34;, ...);
  ...
  test.only(&#34;n&#34;, ...);
});</pre>



<p>The second use case is when we have a test that fails. Before any further inspection, it’s helpful to verify if the test passes when we execute only it. If the test passes as <code>test.only</code>, that means that the problem is not in the test itself, but may be due to a side-effect in other tests. We’ll see such an example next.</p>



<h2 id="mock-functions">Be careful when mocking functions and side-effects</h2>



<p>Let’s define the following function in <code>add.js</code> that calls <code>Math.abs</code> under the hood:</p>



<pre data-enlighter-language="js" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">export const addAbs = (a, b) =&gt; Math.abs(a) + Math.abs(b);</pre>



<p>In general, we want to limit our testing only to our own implementation. We don’t want to test external modules or functions. Since <code>addAbs</code> calls <code>Math.abs</code>, we’ll start testing <code>addAbs</code> using a mock implementation of <code>Math.abs</code>.</p>



<pre data-enlighter-language="js" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">// add.test.js
import { addAbs } from &#34;./add&#34;;

test(&#34;addAbs 1, -1 equals 2 (with mocking)&#34;, () =&gt; {
  Math.abs = jest.fn((x) =&gt; 1);
  const result = addAbs(Math.abs(1), Math.abs(-1));
  expect(result).toBe(2);
});</pre>



<p>This mock implementation fulfills the needs of our test because we know the absolute value of both <code>-1</code> and <code>1</code> is <code>1</code>.</p>



<p>Now that we’re more confident with our implementation, let’s make another test. This time, without mocking <code>Math.abs</code>.</p>



<pre data-enlighter-language="js" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">test(&#34;addAbs 0, 0 equals 0 (without mocking)&#34;, () =&gt; {
  const result = addAbs(0, 0);
  const expected = 0;
  expect(result).toBe(expected);
});</pre>



<p>Surprisingly, our second test will fail!</p>



<pre data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group=""> FAIL  src/add.test.js
  ✓ addAbs 1, -1 equals 2 (with mocking) (2 ms)
  ✕ addAbs 0, 0 equals 0 (without mocking) (2 ms)

  ● addAbs 0, 0 equals 0 (without mocking)

    expect(received).toBe(expected) // Object.is equality

    Expected: 0
    Received: 2</pre>



<p>By inspecting the received result during the second test, we can conclude that <code>Math.abs</code> is still calling the mock function. The line:</p>



<pre data-enlighter-language="js" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group=""> Math.abs = jest.fn((x) =&gt; 1);</pre>



<p>Has a <strong>global</strong> effect! </p>



<p>Let’s see some solutions for this problem.</p>



<h3>Change the order of tests</h3>



<p>We can simply move the mock function tests after the tests that don’t mock functions.</p>



<pre data-enlighter-language="js" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">test(&#34;addAbs 0, 0 equals 0 (without mocking)&#34;, () =&gt; {
  const result = addAbs(0, 0);
  const expected = 0;
  expect(result).toBe(expected);
});

test(&#34;addAbs 1, -1 equals 2 (with mocking)&#34;, () =&gt; {
  Math.abs = jest.fn((x) =&gt; 1);
  const result = addAbs(Math.abs(1), Math.abs(-1));
  const expected = 2;
  expect(result).toBe(expected);
});</pre>



<p>Both tests will pass now.</p>



<h3>Manually restoring the mocked function</h3>



<p>The second option is to save the reference of the original function and restore it before leaving the test.</p>



<pre data-enlighter-language="js" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">test(&#34;addAbs 1, -1 equals 2 (with mocking and restoring)&#34;, () =&gt; {
  const previousFunc = Math.abs;
  Math.abs = jest.fn((x) =&gt; 1);
  const result = addAbs(1, -1);
  const expected = 2;
  expect(result).toBe(2);
  Math.abs = previousFunc;
});

test(&#34;addAbs 0, 0 equals 0 (without mocking)&#34;, () =&gt; {
  const result = addAbs(0, 0);
  const expected = 0;
  expect(result).toBe(expected);
});</pre>



<p>Now, both tests will pass regardless of their order.</p>



<h3>Restore references with <code>jest.restoreAllMocks</code></h3>



<p>Functions like <code><a href="https://jestjs.io/docs/jest-object#jestrestoreallmocks">jest.restoreAllMocks</a></code> and <code><a href="https://jestjs.io/docs/mock-function-api#mockfnmockrestore">mockRestore</a></code>, restore the original function reference. However, these functions work only for mock functions created with <code><a href="https://jestjs.io/docs/jest-object#jestspyonobject-methodname">jest.spyOn</a></code>.</p>



<pre data-enlighter-language="js" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">test(&#34;addAbs 1, -1 equals2 (mock with jest.spyOn)&#34;, () =&gt; {
  Math.abs = jest.spyOn(Math, &#34;abs&#34;).mockImplementation((x) =&gt; 1);
  const result = addAbs(1, -1);
  const expected = 2;
  expect(result).toBe(expected);
  Math.abs.mockRestore();
  // or
  // jest.restoreAllMocks();
});</pre>



<p>See that after creating the mock function with <code>jest.spyOn</code>,  we give it an implementation with <code>mockImplementation</code>. Just calling <code>jest.spyOn</code> does not modify the original function reference. </p>



<p>An alternative to this method is to set the <code><a href="https://jestjs.io/docs/configuration#restoremocks-boolean">restoreMocks</a></code> option to <code>true</code> in <code>jest.config.js</code> to automatically restore mocks after each single test.</p>



<h2 id="async-testing">Async testing</h2>



<p>Let’s add the function <code>addAsync</code> that returns the sum result only after a short delay.</p>



<pre data-enlighter-language="js" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">// add.js
export const asyncAdd = (a, b) =&gt;
  new Promise((resolve) =&gt;
    setTimeout(() =&gt; {
      resolve(a + b);
    }, 500)
  );</pre>



<p>Let’s test it as follows:</p>



<pre data-enlighter-language="js" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">// add.test.js
import { addAsync } from &#34;./add&#34;

test(&#34;addAsync 1, 1 equals 2&#34;, () =&gt; {
  const result = addAsync(1, 1);
  const expected = 2;
  expect(result).toBe(expected);
});</pre>



<p>This test will fail.</p>



<pre data-enlighter-language="js" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group=""> FAIL  src/add.test.js
  ✕ addAsync 1, 1 equals 2 (5 ms)

  ● addAsync 1, 1 equals 2

    expect(received).toBe(expected) // Object.is equality

    Expected: 2
    Received: {}</pre>



<p><code>jest</code> does not wait  for the promise to resolve. Moreover, we’re comparing a <code>Promise</code> object (the received value) with our expected result.</p>



<p>The simplest solution is to use the <code>async/await</code> syntax.</p>



<pre data-enlighter-language="js" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">test(&#34;addAsync 1, 1 equals 2 (async/await)&#34;, async () =&gt; {
  const result = await slowaddAsync(1, 1);
  const expected = 2;
  expect(result).toBe(expected);
});</pre>



<p>Another solution is to call <code>resolves</code> on the Promise.</p>



<pre data-enlighter-language="js" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">test(&#34;addAsync 1, 1 equals 2 (resolves)&#34;, () =&gt; {
  const result = addAsync(1, 1);
  const expected = 2;
  return expect(result).resolves.toBe(expected);
});</pre>



<p>Note that we have to <code>return</code> the <code>resolves</code> statement for <code>jest</code> to wait for the promise to resolve.  (The test passed without adding <code>return</code> in this case, but jest docs <a href="https://jestjs.io/docs/asynchronous#resolves--rejects">recommend doing it</a>)</p>



<p>The previous two tests will both pass.</p>



<h2 id="fake-timers">Use fake timers to test delayed events</h2>



<p>Finally, let’s add the following function. It’s a variation of <code>addAsync</code> that takes longer (10 seconds) to resolve.</p>



<pre data-enlighter-language="js" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">// add.js
export const addAsyncSlow = (a, b) =&gt;
  new Promise((resolve) =&gt;
    setTimeout(() =&gt; {
      resolve(a + b);
    }, 10000)
  );</pre>



<p>Let’s test it with <code>async/await</code>:</p>



<pre data-enlighter-language="js" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">// add.test.js
import { addAsyncSlow } from &#34;./add&#34;;

test(&#34;addAsyncSlow 1, 1 equals 2 (async/await)&#34;, async () =&gt; {
  const result = await addAsyncSlow(1, 1);
  const expected = 2;
  expect(result).toBe(expected);
});</pre>



<p>This test will fail.</p>



<pre data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group=""> FAIL  src/add.test.js (5.811 s)
  ✕ addAsyncSlow 1, 1 equals 2 (async/await) (5002 ms)
 
  ● addAsyncSlow 1, 1 equals 2 (async/await)

    thrown: &#34;Exceeded timeout of 5000 ms for a test.
    Use jest.setTimeout(newTimeout) to increase the timeout value, if this is a long-running test.&#34;
</pre>



<p>We can see that <code>jest</code>has a timeout of 5 seconds. Since <code>addAsyncSlow</code> takes 10 seconds to resolve, it fails.</p>



<p>While jest suggests using <code>jest.setTimeout</code>, we can do better using <code><a href="https://jestjs.io/docs/jest-object#jestusefaketimersimplementation-modern--legacy">jest.useFakeTimers</a></code>. </p>



<p><code>jest.useFakeTimers</code> will use fake versions of the timer functions. This fake implementation can be <a href="https://jestjs.io/docs/jest-object#jestrunalltimers">manipulated</a> to instantly resolve timers. </p>



<pre data-enlighter-language="js" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">test(&#34;addAsyncSlow 1, 1 equals 2 (fake timers)&#34;, () =&gt; {
  jest.useFakeTimers();
  const result = addAsyncSlow(1, 1);
  const expected = 2;
  jest.runAllTimers();
  jest.useRealTimers();
  return expect(result).resolves.toBe(expected);
});</pre>



<p><code>jest.runAllTimers</code> will make all pending timers resolve immediately. </p>



<p>In order to avoid unexpected side-effects on other tests, we restore the real timers with <code><a href="https://jestjs.io/docs/jest-object#jestuserealtimers">jest.useRealTimers</a></code> at the end of the test.</p>



<p>If we wanted to use fake timers on all tests, we could extract these statements with <code><a href="https://jestjs.io/docs/api#beforeeachfn-timeout">beforeEach</a></code> and <code><a href="https://jestjs.io/docs/api#aftereachfn-timeout">aferEach</a></code>.</p>



<pre data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">beforeEach(() =&gt; jest.useFakeTimers());
afterEach(() =&gt; jest.useRealTimers());</pre>



<p>While this example is contrived, fake timers are helpful to test DOM events that take some time to complete. For example, when we wait a certain delay for user interaction.</p>
					</div></div>
  </body>
</html>
