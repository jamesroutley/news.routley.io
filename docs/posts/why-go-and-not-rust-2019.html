<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://kristoff.it/blog/why-go-and-not-rust/">Original</a>
    <h1>Why Go and Not Rust? (2019)</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body"><p>Imagine you’re a developer who mainly works with Go. You go to an event and, while chatting with some people, you decide to share with them the news that you wrote a small tool that does <em>something</em>. You claim that since you wrote it in Go, it’s fairly fast, it’s a single binary, etc. The group seems pleased with your recount and you start feeling good, but then you notice a stranger approaching from behind. A bone-chilling wind blows and you hear: “Why Go and not Rust?”</p><p>You start feeling less good. Well, you could answer that Go is what you know, so that’s what you used to solve your problem, but that’s probably not going to be a satisfactory answer. You were pridefully talking about how fast your tool was in the first place, and it’s obvious that the stranger is going to counter your simplistic excuse with all the great benefits that Rust brings over Go.</p><p>You start feeling bad. Why did you choose to learn Go in the first place? You were told that Go is fast and that it has great concurrency primitives, and now Rust comes along and everybody is saying that Rust is better in every aspect. Were they lying before or are they lying now? While there is no single language to rule them all, you know that it’s still possible to make bad choices and end up in a technological cul de sac. After all, you did choose Go over <em>that</em> other language a few years ago and you were pretty pleased with the routine of joining circles to ask “Why <em>that</em> and not Go?”</p><hr/><p>While the story above is 100% the result of my imagination, it’s no secret that the Rust fandom has a few <em>overexcited</em> members who feel compelled to enlighten every lost soul about the virtues of the Crab-God. This isn’t really Rust’s fault, every successful project will have misbehaving followers, it’s inevitable. While everyone has to deal with these people, I feel that Go developers are particularly susceptible to their behavior because of how much Rust’s and Go’s <a href="https://courses.lumenlearning.com/ivytech-mktg101-master/chapter/reading-defining-the-message/">messaging</a> overlap.</p><p>Go is fast, but Rust is faster.</p><p>Go has an efficient garbage collector, but Rust has static memory management.</p><p>Go has great concurrency support, but Rust has provably-correct concurrency.</p><p>Go has interfaces, but Rust has traits and other zero-cost abstractions.</p><p>If you’re a Go developer you might feel a bit cheated. In contrast, Python developers are not particularly fazed by Rust. They know that Python is in many ways slow and inefficient, and they’re fine with that because they know Python’s role: make the code easy to write and offload to C when performance matters.</p><p>What about Go?</p><h2 id="go-is-very-good-for-writing-services">Go is very good for writing services</h2><p>Go was created at Google to solve Google problems, which mostly involves dealing with networked services. Go’s concurrency model is a good fit for server-side applications that must primarily handle multiple independent requests, rather than participate in complex result-passing schemes. This is one reason why you’re given <code>go</code> and not <code>await</code>.</p><p>Go has great support for HTTP and related protocols and it doesn’t take long to write a satisfactory web service. In my personal projects, Go proved to be a good alternative to Node.js, especially in situations where I wanted to pin down the interfaces between different components more explicitly than you would do while writing idiomatic JavaScript.</p><p>On top of that, it has great tooling to diagnose concurrency and performance problems, and cross-compilation makes deploying on whichever platform a breeze.</p><h2 id="go-is-unapologetically-simple">Go is unapologetically simple</h2><p>Go takes great pride in offering a limited set of features built-in the language. This makes Go easy to learn and, even more importantly, it ensures that Go projects remain understandable even when growing in size. The creators of Go like to call it a “boring” language. While we could debate whether the language could use one or two extra things, the idea of forcing people to “do more with less” has proven to be very successful.</p><p>Rust can indeed be as good as Go at doing web services, or even better, but it really cannot beat Go in terms of simplicity. And it’s not just simplicity, Go is also strict about things that other languages are usually more lax about. Go doesn’t want unused variables or imports, files belonging to different packages in the same directory, etc. It even used to complain about projects saved outside of <code>GOPATH</code> (thankfully that’s not the case anymore).</p><p>Go also doesn’t want any “fingerprints” in the code, so it enforces a single, universal style via <code>go fmt</code>.</p><p>In truth, none of these things alone is particularly impressive, but they do describe the mindset that Go wants to impose. Many don’t like it but, in my opinion, it’s a killer feature for some types of development, like enterprise software.</p><h2 id="go-is-great-for-enterprise-software">Go is great for enterprise software</h2><p>As I already mentioned, Go was created to solve Google problems, and Google problems are definitely enterprise-scale problems. Whether this was the direct aim of the creators or just the natural result of using it at a Big Corp, Go is indubitably an amazing breath of fresh air in enterprise software development.</p><p>If you have experience in writing enterprise software and tried Go, you probably know what I mean. Here’s a quick summary for everyone else.</p><p>Enterprise development is a very weird beast compared to other kinds of development. If you’ve never done it, you might ask yourself “What the hell is even enterprise software?” I did that kind of development as a consultant for a bit, so here’s my take on the subject.</p><h4 id="enterprise-software-development-is-about-scale">Enterprise software development is about scale</h4><p>Not in terms of total number of users, or amount of data. Often that’s the case too, but the defining characteristics are scale of <strong>scope</strong> and <strong>process</strong>.</p><p><strong>Enterprise software always has a big scope.</strong> The domain can be big and wide, or narrow but stupidly complex. Sometimes it’s both. When creating software to model such domains, normal programming wisdom falls incredibly short because non-technological concerns out-weight most technological ones.</p><p><strong>To unravel complex domains you need a well-structured process.</strong> You need domain experts, analysts, and a mechanism that lets stakeholders gauge how much progress is being made. It’s also often the case that you, the technologist, don’t know the domain very well. Stakeholders and domain experts often won’t understand technology very well either.</p><p>This pushes further down technological concerns such as efficiency, <strong>and even correctness.</strong> Don’t get me wrong, the business does care about correctness, but they have a different definition for it. When you’re thinking about algorithmic correctness, they are thinking about a reconciliation back-office for the operations team they keep in a country where labor is cheap.</p><p>Because of the environment resulting from this general premise, a few well-known enterprise development “quirks” have emerged over time. I’ll name three relevant to my point.</p><ol><li><strong>There are a lot of junior developers</strong> who learn on the job how to program and most are not lucky enough to find a job that will truly teach them anything. In some places, after you’re hired, you are stationed for one week in front of PluralSight and then you’re considered ready to go.</li><li><strong>Software projects quickly become huge and complex for all the wrong reasons.</strong> Big projects take time to build and people (or whole teams) will come and go in the meantime. Constant refactoring is never an option so each will leave behind a lot of code written with very varying levels of quality. Multiple teams working in parallel will produce redundant code. The domain shifts over time, inevitably invalidating older assumptions and consequently causing abstractions to leak. The more sophisticated an abstraction is, the higher the risk that it will become a problem when business comes back with a serious change request.</li><li><strong>The toolchain is very often lousy and/or dated.</strong> This is pretty much the inevitable result of all that I described so far. Huge amounts of old code tie you down to a specific toolset, junior developers will learn the status-quo at best, and the people on top (managers and stakeholders) are extremely often not prepared for making technological decisions based on first-hand experience, the general nature of the endeavor makes them risk-averse, causing them to mainly mimic what other successful players in their space do or, more precisely, what analysts <em>claim</em> other successful players do.</li></ol><h4 id="go-is-about-suppressing-complexity-at-scale">Go is about suppressing complexity at scale</h4><p>Go makes teams more successful, partially by giving them more than what they would get with other ecosystems, and partially by taking tools away from them, to prevent common pitfalls.</p><p><strong>Go is much easier to learn than Java or C#.</strong> A faster ramp-up is generally good, but it becomes fundamental when the project is lagging behind, the deadline is approaching, and management inevitably resorts to hiring more people, hoping (in vain) to speed things up.</p><p><strong>The Go community regards as anti-patterns many abstractions regularly employed by Java / C#</strong>, like IoC containers, or OOP inheritance, for example. There are only two levels of visibility for variables, and the only concurrency model is CSP. It’s way harder to fall into incomprehensible pitfalls when writing in Go than it is in Java / C#.</p><p><strong>The Go compiler is fast.</strong> Which means that running tests is going to be faster in general, that deployments will take less time, increasing the overall productivity.</p><p>With Go, it’s easier as a junior developer to be more productive, and harder as a mid-level developer to introduce brittle abstractions that will cause problems down the line.</p><p>For these reasons, Rust is less compelling than Go for enterprise software development. That doesn’t mean that Go is perfect, or that it’s not true that Rust has some advantages over Go. Rust has many advantages over Go, but more than anything, I would say that it’s the common perception of Go that is wrong.</p><p>Go is not blazing-fast. Go is not super memory-efficient. Go doesn’t have the absolutely best concurrency model.</p><p>Go is faster than Java / C#, more memory-efficient than Java / C#, and definitely has better concurrency than Java / C#. <strong>Go is simple so that all of this can hold true when confronting the average Go program with the average Java / C# program.</strong> It doesn’t matter whether Go is truly faster than C# or Java in an absolute sense. The average Java / C# application will be very different than the best theoretical program, and the amount of foot guns in those languages is huge compared to Go. If you want an example, <a href="https://www.youtube.com/watch?v=J0mcYVxJEl0">take a look at this talk on C# concurrency</a>, it’s incredible in my opinion how the straightforward use of <code>await</code> is <strong>never</strong> correct. Imagine how broken must be the average asynchronous C# application. Actually, ASP.NET applications deadlocking for no apparent reason are not uncommon.</p><figure><a href="https://kristoff.it/blog/why-go-and-not-rust/1*JrvDmC-KS7iL2Aexb-lskA.png" target="_blank"><img src="https://kristoff.it/blog/why-go-and-not-rust/1*JrvDmC-KS7iL2Aexb-lskA.png" alt="deadlock table"/></a><figcaption><i><small>Will it deadlock? (click to zoom)</small></i></figcaption></figure><p>This image was taken from <a href="https://medium.com/rubrikkgroup/understanding-async-avoiding-deadlocks-e41f8f2c6f5d">this blog post</a> that tries to explain the innumerable ways of breaking concurrency in C#.</p><h2 id="in-conclusion">In conclusion</h2><p>Go is a <em>better</em> Java / C#, while Rust is not. The clarity that Go can bring to enterprise software development is without a doubt much more valuable than removing garbage collection at the cost of worsening the overall productivity.</p><p>Rust is a <em>better</em> C++, and even if you occasionally hear that Go is a <em>better</em> C, well, that’s just not the case. No language with a built-in garbage collector and runtime can be considered a C. And don’t be mistaken, Rust is a C++, not a C. <a href="https://kristoff.it/blog/what-is-zig-comptime">If you want a better C, take a look at Zig</a>.</p><p>Lastly, going back to our story, not all “Why not Rust” questions should be interpreted like in the example above. Sometimes the chilling wind is just in your head and the people asking the dreaded question just want to know your opinion. Let’s avoid tying our identity to a single language and embrace practicality first and foremost. Tribal names like Rustacean or Gopher should be avoided, as they are inherently a marketing tool for inducing stronger branding.</p></div></div>
  </body>
</html>
