<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.openresty.com/en/ylang-intro-part4/">Original</a>
    <h1>Ylang: Universal Language for eBPF, Stap&#43;, GDB, and More (2021)</h1>
    
    <div id="readability-page-1" class="page"><div id="main">
<div>
<div>
<div id="content">
<article>

<div>
<p><em>This post is the 4th and final part of the series “Ylang: Universal Language for <a href="https://ebpf.io/">eBPF</a>, Stap+, <a href="https://www.gnu.org/software/gdb/">GDB</a>, and More.” See also <a href="https://blog.openresty.com/en/ylang-intro-part1/">Part 1</a>, <a href="https://blog.openresty.com/en/ylang-intro-part2/">Part 2</a>. and <a href="https://blog.openresty.com/en/ylang-intro-part3/">Part 3</a>.</em></p>

<p>Ylang supports tracing across the boundaries of containers transparently. It can trace the Docker and Kubernetes containers just like normal target processes. One can specify the process ID or process group ID for the containerized processes. <a href="https://openresty.com/en/xray/">OpenResty XRay</a> can also automatically detect applications running inside some containers of the same host.</p>
<p>The following screen shot of the <a href="https://openresty.com/en/xray/">OpenResty XRay</a> web console shows a Perl target application running inside a Kubernetes container detected automatically.</p>
<p>
<a data-lightbox="" href="https://blog.openresty.com/images/ylang-intro/perl-in-k8s.png" data-title="Perl Application in a Kubernetes container"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line></svg>
<picture>
<source srcset="/images/ylang-intro/perl-in-k8s_hu56434192b65e55cba8bbb62750280cd0_22833_746x0_resize_q75_h2_box_3.webp" type="image/webp"/>
<img src="https://blog.openresty.com/images/ylang-intro/perl-in-k8s.png" alt="Perl Application in a Kubernetes container" loading="lazy" decoding="async" width="746" height="274"/>
</picture>
</a>
</p>

<p>The target containers do <em>not</em> require any modifications or extra permissions. It is the beauty of 100% non-invasive <a href="https://blog.openresty.com/en/dynamic-tracing-part-1/">dynamic tracing</a>.</p>
<p>The generated tools from the <a href="https://doc.openresty.com/en/xray/ylang/">Ylang</a> compiler are executed and managed by the OpenResty Agent daemon process. The latter can <em>transparently</em> peek into any Docker and Kubernetes containers running in the same host operating system <em>without</em> any collaborations from the target containers themselves.</p>
<p>
<a data-lightbox="" href="https://blog.openresty.com/images/ylang-intro/trace-container.png" data-title="Tracing Containers"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line></svg>
<picture>
<source srcset="/images/ylang-intro/trace-container_hu3d4a8ad846083b6111be4d2d72991e48_50929_837x0_resize_q75_h2_box_3.webp" type="image/webp"/>
<img src="https://blog.openresty.com/images/ylang-intro/trace-container.png" alt="Tracing Containers" loading="lazy" decoding="async" width="927" height="557"/>
</picture>
</a>
</p>

<p>Some users prefer running the <a href="https://openresty.com/en/xray/">OpenResty XRay</a> Agent processes inside a container. We also support that though the container for the Agent must be privileged, or otherwise, it won’t have the permissions to inspect any other containers (by definition).</p>
<p>
<a data-lightbox="" href="https://blog.openresty.com/images/ylang-intro/container-trace-container.png" data-title="Containers tracing containers"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line></svg>
<picture>
<source srcset="/images/ylang-intro/container-trace-container_hu93d038996fde980c10669d82219724de_69066_837x0_resize_q75_h2_box_3.webp" type="image/webp"/>
<img src="https://blog.openresty.com/images/ylang-intro/container-trace-container.png" alt="Containers tracing containers" loading="lazy" decoding="async" width="927" height="557"/>
</picture>
</a>
</p>

<p>As always, <a href="https://openresty.com/en/xray/">OpenResty XRay</a> does not inject any code or require any changes inside those target processes. The original security isolations and permissions in those target containers are never compromised.</p>

<p>The <a href="https://doc.openresty.com/en/xray/ylang/">Ylang</a> compiler can automatically compile unwinding data (indexed by <a href="https://openresty.com/en/xray/">OpenResty XRay</a>’s Package Database) into very efficient native code that performs stack unwinding to produce a stack backtrace or just read specific local variables from the current runtime stack.</p>
<p>Backtraces are crucial because they provide a natural presentation for the current code execution context or “code path.” They are the cornerstones for many analyzers, including generating flame graphs for CPU, latency, and memory usage analysis.</p>
<p>Here is a quick <a href="https://doc.openresty.com/en/xray/ylang/">Ylang</a> example:</p>
<pre><code>_probe usleep() {
    _print(_sym_ubt(_ubt()));
}
</code></pre>
<p>It puts a dynamic probe on the <code>usleep</code> C function call’s entry point and prints out a simple C backtrace string. Typical output looks like this:</p>
<pre><code>f95e0: usleep[1]
401134: main[0]
27082: __libc_start_main[1]
40106e: _start[0]
</code></pre>
<p>Note that the integer numbers in the square brackets (<code>[]</code>) indicate the indexes of the target program module files. Here <code>0</code> is for the primary executable called <code>a.out</code> while <code>1</code> is for the <code>libc-2.27.so</code> file depended on by <code>a.out</code>. The user can quickly obtain the actual mapping relationships by other means in <a href="https://openresty.com/en/xray/">OpenResty XRay</a>.</p>
<h2 id="full-c-backtraces">
<a href="#full-c-backtraces"></a>
Full C Backtraces
</h2>
<p>Some of the <a href="https://doc.openresty.com/en/xray/ylang/">Ylang</a> backends also support the <code>_print_full_ubt()</code> built-in function to dump the full backtrace with argument and local variable values in all the stack frames. Below is an example:</p>
<pre><code>_probe usleep() {
    _print_full_ubt();
}
</code></pre>
<p>The output may look like this with the ODB backend:</p>
<pre><code>f95e0: usleep[1] (useconds=0x3)
  ts=0x0
401134: main[0]
27082: __libc_start_main[1] (main=0x401126, argc=1, argv=0x7ffcd83d8378, init=&lt;optimized&gt;, fini=&lt;optimized&gt;, rtld_fini=&lt;optimized&gt;, stack_end=0x7ffcd83d8368)
  result = &lt;optimized&gt;
  unwind_buf=0x0
  not_first_call = &lt;optimized&gt;
  afct = &lt;optimized&gt;
  head = &lt;optimized&gt;
  cnt = &lt;optimized&gt;
  __value = &lt;optimized&gt;
  __value = &lt;optimized&gt;
  ptr = &lt;optimized&gt;
  __p = &lt;optimized&gt;
  __result = &lt;optimized&gt;
40106e: _start[0]
</code></pre>
<p>It looks very similar to the output of <a href="https://www.gnu.org/software/gdb/">GDB</a>’s <code>bt full</code> command.</p>
<h2 id="reading-specific-variable-values-from-c-stacks">
<a href="#reading-specific-variable-values-from-c-stacks"></a>
Reading Specific Variable Values from C Stacks
</h2>
<p>The full backtrace dumper can be very expensive. Sometimes we only need to read a particular variable on the current stack, which can be very efficient. For example, if we use the <code>_stack_var(&#34;r&#34;, 1)</code> <a href="https://doc.openresty.com/en/xray/ylang/">Ylang</a> function call, it will return the value of the first non-optimized local variable (including function arguments) named <code>r</code> on the current stack (from the stack top to its bottom). This <code>_stack_var</code> function is not yet available in the <a href="https://openresty.com/en/xray/">OpenResty XRay</a> product though it is already available in our internal code repositories. We’ll update this article once it is released.</p>
<h2 id="dynamic-language-backtraces">
<a href="#dynamic-language-backtraces"></a>
Dynamic Language Backtraces
</h2>
<p>Ylang provides standard libraries via header files for generating backtraces for dynamic languages. Dynamic languages include those scripting languages like Lua, PHP, Python, and Perl. More languages will be supported in the future, such as Ruby Java (JVM), JavaScript (NodeJS), Go, and Erlang.</p>
<p>We’ll illustrate how to print out backtraces for the Lua and PHP languages below.</p>
<h3 id="lua-backtraces">
<a href="#lua-backtraces"></a>
Lua Backtraces
</h3>
<p>For example, to generate a Lua-land backtrace string when some Lua code is running on <a href="https://github.com/openresty/luajit2#readme">LuaJIT</a> 2.1, we can write:</p>
<pre><code>#include &#34;lj21.y&#34;

_probe lj_cf_os_exit() {
    printf(&#34;%s&#34;, lj_dump_bt(NULL, &#34;min&#34;));
}
</code></pre>
<p>Here we put a dynamic probe on the <code>lj_cf_os_exit()</code> C function’s entry point and then dump out the Lua-land backtrace in the minimized format. One sample output looks like this:</p>
<pre><code>$ run-y -c &#39;luajit test.lua&#39;
test.lua:c
test.lua:b
test.lua:a
test.lua:0
C:pmain
</code></pre>
<p>The <code>test.lua</code> file looks like this:</p>
<pre><code>local function c()
    local baz = &#34;hello&#34;
    os.exit(0)
end

local function b()
    local bar = 3.14
    c()
end

local function a()
    local foo = 32
    b()
end

a()
</code></pre>
<p>The <code>os.exit()</code> Lua function call will trigger the <code>lj_cf_os_exit()</code> C function call inside the <a href="https://github.com/openresty/luajit2#readme">LuaJIT</a> VM.</p>
<p>The Lua-land Flame Graph analyzer provided by <a href="https://openresty.com/en/xray/">OpenResty XRay</a> uses a similar <a href="https://doc.openresty.com/en/xray/ylang/">Ylang</a> code to produce the flame graphs. Here is an example graph.</p>


<h4 id="full-lua-backtraces">
<a href="#full-lua-backtraces"></a>
Full Lua Backtraces
</h4>
<p>We can get the full Lua backtraces with local Lua variable values printed out in each Lua function call frame by writing <code>lj_dump_bt(NULL, &#34;full&#34;)</code> in the <a href="https://doc.openresty.com/en/xray/ylang/">Ylang</a> program above. One sample output for the sample <code>test.lua</code> script above is as follows:</p>
<pre><code>[builtin#os.exit]
exit
test.lua:3
    baz = &#34;hello&#34;
test.lua:c
test.lua:8
    bar = 3.140000
test.lua:b
test.lua:13
    foo = 32
test.lua:a
test.lua:16
    c = function @test.lua:1: (GCfunc *)0x7feff0851578
    b = function @test.lua:6: (GCfunc *)0x7feff0851658
    a = function @test.lua:11: (GCfunc *)0x7feff08516c8
C:pmain
</code></pre>
<p>Even the Lua standard library does not support full backtraces out of the box. <a href="https://doc.openresty.com/en/xray/ylang/">Ylang</a> does not need any collaborations from the <a href="https://github.com/openresty/luajit2#readme">LuaJIT</a> VM or the target process because it knows about the <a href="https://github.com/openresty/luajit2#readme">LuaJIT</a> VM internals.</p>
<h3 id="php-backtraces">
<a href="#php-backtraces"></a>
PHP Backtraces
</h3>
<p>Below is an example for dumping PHP 7’s backtraces:</p>
<pre><code>#include &#34;php7.y&#34;

_probe _timer.profile {
    printf(&#34;%s\n&#34;, php7_dump_bt());
    _exit();
}
</code></pre>
<p>One sample output is</p>
<pre><code>C:sapi_cli_single_write
Application-&gt;setLogger
/tmp/test.php:24
C:sapi_cli_single_write
Application-&gt;getLogger
/tmp/test.php:30
C:sapi_cli_single_write
class@anonymous@/tmp/test.php:24$0-&gt;log
/tmp/test.php:30
</code></pre>

<p>SystemTap directly embeds the unwinding data (usually in the <a href="https://en.wikipedia.org/wiki/DWARF">DWARF</a> format) into its compiled tools and interprets the unwinding data at runtime. It is slow because unwinding data formats like <a href="https://en.wikipedia.org/wiki/DWARF">DWARF</a> is a complex data format<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>, and also, they are usually optimized for compactness and space usage instead of for speed. <a href="https://doc.openresty.com/en/xray/ylang/">Ylang</a> is a proper compiler that converts <a href="https://en.wikipedia.org/wiki/DWARF">DWARF</a> data into specialized native code that runs at the fastest possible speed. <a href="https://www.gnu.org/software/gdb/">GDB</a> also interprets <a href="https://en.wikipedia.org/wiki/DWARF">DWARF</a> data instead of working as an actual compiler.</p>
<p>Linux’s perf copies the full runtime stack memory content to the user-land for unwinding, which has the following drawbacks:</p>
<ol>
<li>It may copy too much data from the kernel space to the user-land, and most of the data is useless for stack unwinding. The copying can quickly saturate the memory bus and expose sensitive data vulnerable to security breaches.</li>
<li>It won’t be possible for complex tools to utilize the backtrace results directly in the kernel space.</li>
</ol>
<p>And the open-source <a href="https://ebpf.io/">eBPF</a> toolchain relies on the frame pointer registers<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup> to be used in the target programs, which goes against the recommendations of the x86_64 ABI, for example. And the user has to recompile most of the target programs with the C/C++ compiler flag <code>-fno-omit-frame-pointer</code>, which breaks the golden rule of <a href="https://blog.openresty.com/en/dynamic-tracing-part-1/">dynamic tracing</a>: no slowdown or explicit collaborations from the target programs.</p>
<p>None of the open-source toolchains support unwinding dynamic languages&#39; function call stacks or generating their backtraces.</p>

<p>Ylang’s <a href="https://www.gnu.org/software/gdb/">GDB</a> backend is particularly useful for analyzing core dump files generated from crashed processes. Other backends like Stap+ and <a href="https://ebpf.io/">eBPF</a> have <em>no</em> support for core dump files.</p>
<p>For the first time, the same analyzing tools can analyze both live processes and dead ones. Thanks to the higher-level language, <a href="https://doc.openresty.com/en/xray/ylang/">Ylang</a>, the same analyzing tools can analyze both live processes and dead ones for the first time.</p>
<p>It makes little sense to specify any probes other than <code>_oneshot</code> and <code>_begin</code> in <a href="https://doc.openresty.com/en/xray/ylang/">Ylang</a> analyzers for core dumps. After all, a core-dump is a corpse of dead processes<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup>.</p>
<p>
<a data-lightbox="" href="https://blog.openresty.com/images/ylang-intro/xray-core-dump.png" data-title="OpenResty XRay for Core Dump Analysis"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line></svg>
<picture>
<source srcset="/images/ylang-intro/xray-core-dump_hu2a5dc966d07517318df63c6d932203ad_18187_531x0_resize_q75_h2_box_3.webp" type="image/webp"/>
<img src="https://blog.openresty.com/images/ylang-intro/xray-core-dump.png" alt="OpenResty XRay for Core Dump Analysis" loading="lazy" decoding="async" width="531" height="549"/>
</picture>
</a>
</p>

<p>We also have plans to add a new <a href="https://doc.openresty.com/en/xray/ylang/">Ylang</a> backend for the Red Hat <a href="https://github.com/crash-utility/crash">crash</a> command-line utility so that we could also use <a href="https://doc.openresty.com/en/xray/ylang/">Ylang</a> to debug Linux kernel crash dumps (like those from <a href="https://en.wikipedia.org/wiki/Kdump_(Linux)">kdump</a>). Analyzing operating system kernel corpses is fun as well.</p>

<p>Dynamic tracing has a very low runtime overhead because it only collects information needed for specific analysis goals. It is dramatically different from traditional approaches of collecting as much information as possible in log data<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup>. The latter incurs much higher overhead due to writing and moving big data around<sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup>.</p>
<p>Dynamic tracing is also usually based on sampling. Because it never injects any code or loads any special modules into the target processes, it is precisely 0 overhead when it is not sampling. Most analyzers&#39; overhead is usually unmeasurable, even during the sampling window. When the target application reaches maximum throughput, the cost of sampling is generally under 5% of the throughput. Some full-instrumentation tools may incur higher overhead, like a cost of more than 30% of the maximum application throughput. However, we can still use them in production environments when the online performance is degraded to a crawl already.</p>
<p>Ylang is also an optimizing compiler that emits compact and efficient code for different backends. For example, the Python code generated by <a href="https://doc.openresty.com/en/xray/ylang/">Ylang</a>’s <a href="https://www.gnu.org/software/gdb/">GDB</a> backend is about four times faster than hand-crafted code<sup id="fnref:6"><a href="#fn:6" role="doc-noteref">6</a></sup>.</p>

<p>As we saw in previous sections, <a href="https://doc.openresty.com/en/xray/ylang/">Ylang</a> provides standard header files to import more functions and other features. It is similar to C/C++’s way of reusing code. We’ve already seen standard header files like <code>lj21.y</code> and <code>php7.y</code>, which form the standard libraries for <a href="https://doc.openresty.com/en/xray/ylang/">Ylang</a>. We also use <a href="https://doc.openresty.com/en/xray/ylang/">Ylang</a> to implement these libraries.</p>
<p>In the future, we may also support multiple compilation units in <a href="https://doc.openresty.com/en/xray/ylang/">Ylang</a><sup id="fnref:7"><a href="#fn:7" role="doc-noteref">7</a></sup> to reduce the amount of code that the compiler must re-compile.</p>
<p>Additionally, <a href="https://openresty.com/en/xray/">OpenResty XRay</a> offers hundreds of standard analyzers or tools for many different types of open-source software. Most of these tools are coded in <a href="https://doc.openresty.com/en/xray/ylang/">Ylang</a>. Some are written in even higher-level languages like <a href="https://doc.openresty.com/en/xray/ylua/">YLua</a> and <a href="https://doc.openresty.com/en/xray/ysql/">YSQL</a>. We have an entire “food chain” to build language abstractions on top of <a href="https://doc.openresty.com/en/xray/ylang/">Ylang</a>. It’s more natural to use the Lua language syntax, for instance, to manipulate Lua-land data structures than using the C syntax to inspect the C-level data structures.</p>
<p>
<a data-lightbox="" href="https://blog.openresty.com/images/ylang-intro/y-food-chain.png" data-title="Ylang Food Chain"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line></svg>
<picture>
<source srcset="/images/ylang-intro/y-food-chain_huc1747412f1b80af253aa36b06ae59db9_9646_542x0_resize_q75_h2_box_3.webp" type="image/webp"/>
<img src="https://blog.openresty.com/images/ylang-intro/y-food-chain.png" alt="Ylang Food Chain" loading="lazy" decoding="async" width="542" height="332"/>
</picture>
</a>
</p>


<p>Using <a href="https://doc.openresty.com/en/xray/ylang/">Ylang</a> to write in-kernel network programs to manipulate network packets is also possible. Thanks to the <a href="https://ebpf.io/">eBPF</a> support in the Linux kernel’s network stack. <a href="https://ebpf.io/">eBPF</a>’s predecessor, BPF, was created exclusively for network filters. With <a href="https://doc.openresty.com/en/xray/ylang/">Ylang</a> and <a href="https://openresty.com/en/xray/">OpenResty XRay</a>’s <a href="https://ebpf.io/">eBPF</a> toolchain, we no longer suffer from the painful limitations in the stock <a href="https://ebpf.io/">eBPF</a> toolchain and VM implementation. We can hook up powerful programs to both the <a href="https://www.iovisor.org/technology/xdp">XDP</a> and TC subsystems.</p>
<p>This feature has not yet landed in <a href="https://openresty.com/en/xray/">OpenResty XRay</a>. We are still actively working on it.</p>

<p>The <a href="https://doc.openresty.com/en/xray/ylang/">Ylang</a> compiler was written in the Fan language (or fanlang), our Perl 6 (or <a href="https://en.wikipedia.org/wiki/Raku_(programming_language)">Raku</a>) dialect language specifically designed to implement new optimizing compilers for general-purpose and domain specific languages. The fanlang compiler emits optimized <a href="https://github.com/openresty/luajit2#readme">LuaJIT</a> bytecode and runs much faster than open-source Perl 6 implementations like <a href="https://rakudo.org/">Rakudo</a><sup id="fnref:8"><a href="#fn:8" role="doc-noteref">8</a></sup>. The fanlang compiler will also become part of our <a href="https://openresty.com/en/edge/">OpenResty Edge</a> and OpenResty Plus products soon.</p>

<p>Ylang and <a href="https://openresty.com/en/xray/">OpenResty XRay</a> support most mainstream Linux distributions that have not reached end-of-life. Some of the end-of-life distribution versions like Ubuntu 14.04 and CentOS 6 are also working to some extend.</p>
<p>The next big operating system flavor that will get supported is Android because its kernel is based on Linux anyway. The <a href="https://ebpf.io/">eBPF</a> backend of <a href="https://doc.openresty.com/en/xray/ylang/">Ylang</a> will work out of the box there.</p>
<p>We also plan to support more exotic systems like *BSD and macOS. Windows is also technically possible. Stay tuned!</p>

<p>We created <a href="https://doc.openresty.com/en/xray/ylang/">Ylang</a> and <a href="https://openresty.com/en/xray/">OpenResty XRay</a> to help troubleshoot and optimize all kinds of open-source software. Open-source software is everywhere nowadays, but very few people have deep insights into the open-source software they use daily and love. And many people use it in suboptimal or even incorrect ways. <a href="https://doc.openresty.com/en/xray/ylang/">Ylang</a> and <a href="https://openresty.com/en/xray/">OpenResty XRay</a> themselves also leverage a lot of high-quality open-source code.</p>
<p>Ylang makes it possible to create tremendously complex analyzers and tools, which imposing unprecedented pressure on the underlying open-source infrastructures. Indeed, we ran into many obscure bugs in almost all the open-source components we employ, like <a href="https://sourceware.org/systemtap/">SystemTap</a>, Clang/LLVM, libbpf, <a href="https://www.gnu.org/software/gdb/">GDB</a>, and Linux kernel (including the <a href="https://ebpf.io/">eBPF</a> machinery, perf events, libbpf, btftool, etc.).</p>
<p>We’ve been reporting a lot of bugs and submitting many patches to these open-source projects to help make the open-source world better. Special thanks go to the author of the <a href="https://sourceware.org/systemtap/">SystemTap</a> project, Frank Ch. Eigler, for quickly reviewing and accepting our patches, as well as his general support over the years. We’ve also been leading our open-source projects, like <a href="https://openresty.org">OpenResty</a> and we believe in the open-source movement.</p>

<p>Ylang is a universal debugging and <a href="https://blog.openresty.com/en/dynamic-tracing-part-1/">dynamic tracing</a> language targeting many different debugging frameworks and runtimes. Additionally, the backends used by <a href="https://doc.openresty.com/en/xray/ylang/">Ylang</a> also lift a lot of limitations and add many new features to their open-source counterparts (if there is a counterpart). Developing new <a href="https://blog.openresty.com/en/dynamic-tracing-part-1/">dynamic tracing</a> tools cannot be easier now. The user can use the <a href="https://doc.openresty.com/en/xray/ylang/">Ylang</a> language and toolchain via the <a href="https://openresty.com/en/xray/">OpenResty XRay</a> product or use our standard analyzers written in <a href="https://doc.openresty.com/en/xray/ylang/">Ylang</a>.</p>
<p>This series of articles gives a 30,000 feet overview of the <a href="https://doc.openresty.com/en/xray/ylang/">Ylang</a> language’s features and advantages, with simple examples. You can find more details about the <a href="https://doc.openresty.com/en/xray/ylang/">Ylang</a> language in the <a href="https://doc.openresty.com/en/xray/ylang/">official documentation</a>.</p>


<p>We base our work upon many <a href="https://blog.openresty.com/en/dynamic-tracing-part-1/">dynamic tracing</a> and debugging giants.</p>
<p>Brendan Gregg’s blog first got me interested in this field back in 2012. He was mostly talking about <a href="https://en.wikipedia.org/wiki/DTrace">DTrace</a> in those years. In recent years, his work around Linux <a href="https://ebpf.io/">eBPF</a> and perf toolchains is still inspiring us.</p>
<p>During 2012 ~ 2016, <a href="https://www.cloudflare.com/">Cloudflare</a> provided a big playground to apply dynamic-tracing technologies to solve real-world problems in large-scale clouds when I worked there.</p>
<p>Frank Ch. Eigler’s <a href="https://sourceware.org/systemtap/">SystemTap</a> delivers the most capable open-source <a href="https://blog.openresty.com/en/dynamic-tracing-part-1/">dynamic tracing</a> framework, which served me well in those early days. We’ve been closely working with Frank and other <a href="https://sourceware.org/systemtap/">SystemTap</a> developers at Red Hat over the years.</p>
<p>The people working on Linux <a href="https://ebpf.io/">eBPF</a> are admirable. They bring the power of <a href="https://en.wikipedia.org/wiki/DTrace">DTrace</a>’s in-kernel VM into the Linux kernel and extend it to both the networking and tracing worlds.</p>
<p>Special thanks go to our developers at <a href="https://openresty.com/">OpenResty Inc.</a> for making <a href="https://doc.openresty.com/en/xray/ylang/">Ylang</a> and <a href="https://openresty.com/en/xray/">OpenResty XRay</a> a reality. Also, thanks all our <a href="https://openresty.com/en/xray/">OpenResty XRay</a> users for helping make the product better every day.</p>
<p>Last but not least, I must thank the developers who created <a href="https://en.wikipedia.org/wiki/DTrace">DTrace</a> at Sun Microsystems in the dawn of the 21st century. That sparked a whole new era in the computing world.</p>

<p>Yichun Zhang is the creator of the OpenResty® open-source project and contributed a dozen open-source Nginx 3rd-party modules, many Nginx and <a href="https://github.com/openresty/luajit2#readme">LuaJIT</a> core patches. He is also the founder and CEO of the <a href="https://openresty.com/">OpenResty Inc.</a> company. He also designed the <a href="https://openresty.com/en/edge/">OpenResty Edge</a>,
<a href="https://openresty.com/en/xray">OpenResty XRay</a>, and <a href="https://openresty.com/en/showman/">OpenResty Showman</a> products.</p>

<p>We also welcome interested readers to contribute translations in other natural
languages as long as the transcript covers the entire article without any omissions. We
thank them in advance.</p>

<p>We always welcome talented and enthusiastic engineers to join our team at <a href="https://openresty.com/en/">OpenResty Inc</a>.
to explore various open-source software’s internals and build powerful analyzers and
visualizers for real-world applications built atop the open-source software. If you are
interested, please send your resume to <code>talents@openresty.com</code>. Thank you!</p>


</div>




</article>
</div>



</div>

</div>
</div></div>
  </body>
</html>
