<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://web.dev/case-studies/google-sheets-wasmgc">Original</a>
    <h1>Why Google Sheets ported its calculation worker from JavaScript to WasmGC</h1>
    
    <div id="readability-page-1" class="page"><div>

  
    




<div translate="no">
  
    
    
      
    
  
    
    
      <div>
        
          <p><img alt="Thomas Steiner" src="https://web.dev/images/authors/thomassteiner.jpg" decoding="async" height="64" loading="lazy" width="64"/></p>
      </div>
    
  
</div>

<p>Google Sheets is one of the first products at Google to use WasmGC on Chrome. The move was announced in 2022, and the Sheets and Chrome teams partnered on standardization, engineering, and tooling to provide real-time feedback on optimizations. This partnership set a precedent for how engineering teams at Google can effectively work with Chrome to have more Google apps running on WasmGC.</p>

<h2 id="the_challenge_javascript" data-text="The challenge: JavaScript" tabindex="-1">The challenge: JavaScript</h2>

<p>The Google Sheets calculation engine was originally written in Java and launched in 2006. In the early days of the product, all calculation happened on the server. However, from 2013, the engine has run in the browser using JavaScript. This was originally accomplished through Google Web Toolkit (<a href="https://www.gwtproject.org/">GWT</a>), and later through Java to Closure JavaScript transpiler (<a href="https://github.com/google/j2cl/">J2CL</a>). The JavaScript calculation engine runs in a <a href="https://developer.mozilla.org/docs/Web/API/Web_Workers_API/Using_web_workers">Web Worker</a> and communicates with the main thread using a <a href="https://developer.mozilla.org/docs/Web/API/MessageChannel"><code translate="no" dir="ltr">MessageChannel</code></a>.</p>

<p>Migrating users from the server to the JavaScript version of the calculation engine (and later from GWT to J2CL) was a major undertaking that required careful validation. To ensure that the JavaScript calculation engine produced precisely the same results as the Java version, the Sheets team developed an internal validation mechanism. This mechanism can process a large corpus of sheets and validate that the results are identical between multiple versions of the calculation engine. The Sheets team uses this tool regularly to validate changes to Sheets. But the team didn&#39;t just compare the results of those calculations, they also compared the performance between JavaScript on the client and Java on the server. They found that the JavaScript version of the calculation engine was more than three times slower than the Java version.</p>

<h3 id="why_is_javascript_slower_than_java" data-text="Why is JavaScript slower than Java?" tabindex="-1">Why is JavaScript slower than Java?</h3>

<p>JavaScript is fast for a loosely-typed, dynamic language. Heavy investment in just-in-time (JIT) compilers (for example, <a href="https://v8.dev/blog/maglev">Maglev</a>, <a href="https://v8.dev/blog/sparkplug">Sparkplug</a>, and <a href="https://v8.dev/blog/turbofan-jit">Turbofan</a>) over the past 15 years has increased JavaScript&#39;s performance. However, JavaScript&#39;s loose types and dynamic behavior make it challenging for JIT compilers to generate optimal code. This means JavaScript still lags behind languages like Java and C++ for raw throughput. <a href="https://www.typescriptlang.org/">TypeScript</a> adds type safety to JavaScript, but that type information is designed to make development easier, not to provide the sorts of guarantees needed by compilers to generate optimal code. For cases like Google Sheets, where large spreadsheets can take tens of seconds to calculate, JavaScript is fast, but not fast enough.</p>

<h2 id="the_solution_wasmgc" data-text="The Solution: WasmGC" tabindex="-1">The Solution: WasmGC</h2>

<p><a href="https://developer.chrome.com/blog/wasmgc/">WasmGC</a> is an <a href="https://github.com/WebAssembly/gc">extension</a> to the existing <a href="https://webassembly.org/">WebAssembly</a> specification which adds the primitives needed to compile garbage collected languages (such as Java). For example, WasmGC adds instructions for defining types and allocating garbage collected data structures. WasmGC is poised to do for garbage collected languages what Wasm did for C++ (for example, <a href="https://web.dev/articles/ps-on-the-web#webassembly_porting_with_emscripten">Photoshop</a> or <a href="https://web.dev/case-studies/earth-webassembly">Google Earth</a>), which is to bring them to the web at near native speed. At Google, we believe that WasmGC has the potential to be even more impactful than Wasm because of the popularity of garbage collected languages.</p>

<h2 id="google_workspace_partners_with_chrome" data-text="Google Workspace partners with Chrome" tabindex="-1">Google Workspace partners with Chrome</h2>

<p>The <a href="https://github.com/WebAssembly/gc/blob/main/proposals/gc/MVP.md">WasmGC MVP draft specification</a> was published in 2019. In late 2020, Google Workspace and Chrome partnered to evaluate WasmGC using the Sheets calculation engine. Workspace&#39;s multiplatform team has significant expertise building and optimizing compilers and transpilers. Sheets, a part of Workspace, was identified as an ideal candidate for evaluating WasmGC: it is performance-sensitive and has robust performance and correctness validation mechanisms. Chrome has the <a href="http://v8.dev">V8</a> team to build and optimize the WasmGC runtime as well as contributors to <a href="https://github.com/WebAssembly/binaryen">Binaryen</a> to build ahead-of-time (AOT) optimizations. Between Chrome and Workspace, there&#39;s all the expertise needed to build and optimize a WasmGC toolchain, with Google Sheets as an ideal testbed.</p>

<h3 id="the_first_prototype" data-text="The first prototype" tabindex="-1">The first prototype</h3>

<p>By mid 2021, the teams had a working <a href="https://github.com/google/j2cl/tree/master/samples/wasm">Java to WasmGC compiler</a>. Toward the end of the same year, they had a prototype version of Google Sheets running as WasmGC and doing calculations. Along the way, they hit many challenges. Tooling for profiling and taking heap dumps did not exist and had to be built. The existing implementation relied on many JavaScript libraries for which replacements had to be found or written for WasmGC. Validating the correctness of the Wasm calculation engine was a time-consuming effort due to the experimental nature of the specification, compiler, and new libraries. But Sheets&#39; validation mechanisms were once again extremely helpful. The teams ultimately got it all working, and performance data started coming in early 2022.</p>

<h3 id="additional_optimizations" data-text="Additional optimizations" tabindex="-1">Additional optimizations</h3>

<p>The initial version of Sheets Wasm showed calculation performance roughly two times <em>slower</em> than JavaScript. However, this isn&#39;t a bad result for a new specification, new compiler, and several new libraries. From this point, the Sheets team began optimizing. Of the optimizations they found, a few categories emerged:</p>

<ul>
<li>Replicating core optimizations that already existed in the Java Virtual Machine (JVM) and in V8.</li>
<li>Using highly optimized browser APIs.</li>
<li>Removing JavaScript-specific coding patterns.</li>
</ul>

<p>Firstly, the Sheets team needed to replicate optimizations which already exist in other toolchains. The best example of this is optimizing <a href="https://en.wikipedia.org/wiki/Dynamic_dispatch">virtual method dispatching</a>, which has long been optimized by the JVM and V8, but nothing existed for WasmGC. Implementing <a href="https://en.wikipedia.org/wiki/Inline_caching">speculative inlining</a> and <a href="https://github.com/WebAssembly/binaryen/blob/main/src/passes/ConstantFieldPropagation.cpp">devirtualization</a>—two very common optimizations—sped up calculation time by roughly 40% in Chrome.</p>

<p>Second, there are cases where browser APIs are backed by optimized native implementations that are difficult to compete with using Wasm. Strings and regular expressions are two good examples. Specifically, with regular expressions, the team saw nearly a 100 times speedup of regular expression operations when switching from <a href="https://github.com/google/re2j">re2j</a> (compiled to WasmGC) to the <a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/RegExp"><code translate="no" dir="ltr">RegExp</code></a> browser API in Chrome, which can compile each regular expression to its own machine code.</p>

<p>Lastly, they found that years of optimizing had caused the codebase to be over-fitted to JavaScript. For example, they had a core data structure in Sheets which was blurring the lines between arrays and maps. This is efficient in JavaScript, which automatically models sparse arrays as maps, but slow on other platforms. So they had to rewrite the code in a more platform-agnostic way. This is another thing the team like about WebAssembly: it makes it easier for multiplatform applications to get good performance on the web. You don&#39;t have to bend your whole application to the idiosyncrasies of JavaScript.</p>

<h2 id="conclusion" data-text="Conclusion" tabindex="-1">Conclusion</h2>

<p>WasmGC is a powerful technology that has the potential to advance the way developers build web applications. Over the coming years, at Google, we hope to see WasmGC advance to support <a href="https://chromestatus.com/feature/5163209685467136">shared memory multithreading</a> and further improve single threaded performance. We encourage all web developers to consider <a href="https://v8.dev/blog/wasm-gc-porting">using WasmGC</a> for their next high-performance project. Join us and make the web a faster, smoother place together!</p>

<h2 id="acknowledgements" data-text="Acknowledgements" tabindex="-1">Acknowledgements</h2>

<p>Thank you for those who worked on the WasmGC implementation and this case study:
Diwas Adhikary,
Matthew Albright,
Ksenia Bukina,
Julien Dramaix,
Asim Fazal,
Michael Frederick,
Goktug Gokdogan,
Janice Gu,
Adam Klein,
Manos Koukoutos,
Jakob Kummerow,
Matthias Liedtke,
Thomas Lively,
Roberto Lublinerman,
Vishrut Mehta,
Thomas Nattestad,
Josh Pearlstein,
Joaquim Perotti,
Chris Ruenes,
Steven Saviano,
Derek Schuff,
Tim Sears,
Michael Thomas,
Yuan Tian,
Philipp Weis,
Mason Wu,
Alon Zakai, and
Emanuel Ziegler.</p>

  

  
</div></div>
  </body>
</html>
