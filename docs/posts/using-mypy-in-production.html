<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://notes.crmarsh.com/using-mypy-in-production-at-spring">Original</a>
    <h1>Using Mypy in Production</h1>
    
    <div id="readability-page-1" class="page"><div><article id="block-using-mypy-in-production-at-spring"><p><span><span>At </span><span><a href="https://www.springdiscovery.com/" target="_blank" rel="noopener noreferrer">Spring</a></span><span>, we maintain a large Python monorepo with complete Mypy coverage configured under Mypy’s </span><span><a href="https://blog.wolt.com/engineering/2021/09/30/professional-grade-mypy-configuration/" target="_blank" rel="noopener noreferrer">strictest available settings</a></span><span>. In short, that means every function signature is annotated and implicit </span><span><code>Any</code></span><span> conversions are disallowed.</span></span></p><p><span><span>Lines-of-code is admittedly a poor measure, but as a rough approximation: our monorepo contains over 300,000 lines of Python, with about half of that constituting our core data platform, and the other half, end-user code written by data scientists and machine learning researchers. </span><span><strong>My unsubstantiated guess is that this is one of the most comprehensively-typed Python codebases out there for its size.</strong></span></span></p><p><span><span>We first adopted Mypy in July 2019, achieved complete type coverage about a year later, and have been happy Mypy users ever since.</span></span></p><p><span><span>A few weeks back, I had a brief conversation with </span><span><a href="https://twitter.com/srchvrs/status/1551676839856377859?s=20&amp;t=KKSFIcDQnWbm2kYxm0vtbg" target="_blank" rel="noopener noreferrer">Leo Boytsov</a></span><span> and </span><span><a href="https://twitter.com/bernhardsson/status/1551677664754389003?s=20&amp;t=KKSFIcDQnWbm2kYxm0vtbg" target="_blank" rel="noopener noreferrer">Erik Bernhardsson</a></span><span> on Twitter about Python typing — then I saw </span><span><a href="https://twitter.com/charliermarsh/status/1558460385665114113?s=20&amp;t=LagGcX_CKH6zQeutBWYzKg" target="_blank" rel="noopener noreferrer">Will McGugan</a></span><span> praising types too. Since Mypy is a key part of how we ship and iterate on Python code at Spring, I wanted to write about our experience using it at-scale over the past few years.</span></span></p><p><span><span><strong>TL;DR</strong></span><span>: while Mypy adoption comes at a cost (via upfront and ongoing investment, a learning curve, etc.), I’ve found it invaluable for maintaining a large Python codebase. Mypy may not be for everyone, but it </span><span><em>is</em></span><span> for me.</span></span></p><p><span><span><em>(If you’re already familiar with Mypy, skip ahead.)</em></span></span></p><p><span><span>Mypy is a static type checker for Python. If you’re written any Python 3, you may have noticed that Python supports type annotations, like this:</span></span></p><div id="block-2c179210a5704364ba3122547f95c060"><pre><code>def greeting(name: str) -&gt; str:
    return &#39;Hello &#39; + name</code></pre><figcaption><span></span></figcaption></div><p><span><span>Python defined this type annotation syntax in 2014 via </span><span><a href="https://peps.python.org/pep-0484/" target="_blank" rel="noopener noreferrer">PEP 484</a></span><span>. While these annotations are part of the </span><span><em>language</em></span><span>, Python (and its associated first-party tooling) doesn’t actually </span><span><em>use</em></span><span> them to enforce type safety.</span></span></p><p><span><span>Instead, type checking is implemented via third-party tools. Mypy is one such tool. Facebook’s </span><span><a href="https://github.com/facebook/pyre-check" target="_blank" rel="noopener noreferrer">Pyre</a></span><span> is another — though in my experience, Mypy is more popular (Mypy has more than twice as many stars on GitHub, it’s the default type-checker used in </span><span><a href="https://www.pantsbuild.org/docs/python-check-goal" target="_blank" rel="noopener noreferrer">Pants</a></span><span>, etc.). IntelliJ has their own type checker, which powers the type inference you see in PyCharm. In each case, these tools describe themselves as “PEP 484-compliant”, in that they work with the type annotations defined by the language itself.</span></span></p><p><span><span>In other words: Python saw its responsibility as defining the syntax and semantics of its type annotations (though PEP 484 itself was heavily inspired by existing versions of Mypy), but intentionally left it to third-party tools to enforce those semantics.</span></span></p><p><span><span>Note that when you use a tool like Mypy, you’re running it out-of-band from Python itself — i.e., you run </span><span><code>mypy path/to/file.py</code></span><span> , and Mypy spits out any inferred violations. (Python exposes but does not leverage those type annotations at runtime.)</span></span></p><p><span><span>(As an aside: in writing this post, I learned that Mypy started out with very different goals, comparable to projects like PyPy. PEP 484 didn’t exist (it was inspired by Mypy!), so Mypy defined its own syntax that diverged from Python and implemented its own runtime (i.e., Mypy code was executed through </span><span><em>Mypy</em></span><span>). One of </span><span><a href="https://mypy-lang.blogspot.com/2012/12/why-mypy-can-be-more-efficient-than.html" target="_blank" rel="noopener noreferrer">Mypy’s goals</a></span><span> at the time was to improve performance by leveraging static types, encouraging immutability, and more — and they explicitly eschewed compatibility with CPython. Mypy switched to a Python-compatible syntax in </span><span><a href="https://mypy-lang.blogspot.com/2013/07/mypy-switches-to-python-compatible.html" target="_blank" rel="noopener noreferrer">2013</a></span><span>, and PEP 484 came out in 2015. (I believe the “use static typing to speed up Python” concept became </span><span><a href="https://github.com/mypyc/mypyc" target="_blank" rel="noopener noreferrer">Mypyc</a></span><span>, which is still an active project, and is used to compile Mypy itself.))</span></span></p><p><span><span>We introduced Mypy to our codebase in July 2019 (</span><span><a href="https://github.com/spring-discovery/spring-experiments/pull/1724" target="_blank" rel="noopener noreferrer">#1724</a></span><span>). When the proposal first dropped, we found ourselves talking through two main sources of hesitation internally:</span></span></p><ol type="1"><li id="block-2042719f20ce45d6867d7e2193dc90e0"><span><span>Although Mypy was first introduced at PyCon Finland in 2012, and they began releasing PEP 484-compatible versions in early 2015, it still </span><span><em>felt</em></span><span> like a fairly new tool — at least to us. No one on the team had used it before, despite having worked in some fairly large Python codebases (at Khan Academy and elsewhere). I’d worked in </span><span><em>one</em></span><span> codebase that showed signs of having enabled Mypy at </span><span><em>some</em></span><span> point in the past, but had since given up on it.</span></span></li><li id="block-10a297bc028f4073b857e607e0893013"><span><span>Like other incremental type checkers (e.g., </span><span><a href="https://flow.org/" target="_blank" rel="noopener noreferrer">Flow</a></span><span>), the value of Mypy compounds over time, as more and more of your codebase is annotated. While Mypy </span><span><em>can</em></span><span> and </span><span><em>will</em></span><span> catch bugs with even minimal annotations, the more you’re able to invest in annotating your codebase, the more valuable it becomes.</span></span></li></ol><p><span><span>Despite these reservations, we decided to give Mypy a shot. Internally, our engineering culture tended towards a strong preference for static typing (apart from Python, we write a lot of Rust and TypeScript). So, we were primed to </span><span><em>want</em></span><span> to use Mypy. Beyond that, I was personally willing to champion the tool and invest in extending our code coverage.</span></span></p><p><span><span>We started by typing a handful of files. A year later, we finished typing our existing code (</span><span><a href="https://github.com/spring-discovery/spring-experiments/pull/2622" target="_blank" rel="noopener noreferrer">#2622</a></span><span>), and were able to upgrade to the strictest Mypy settings available (most importantly, </span><span><code>disallow_untyped_defs</code></span><span>, which requires </span><span><em>all</em></span><span> functions signatures to be annotated), which we’ve maintained ever since. (The team at </span><span><a href="https://blog.wolt.com/engineering/2021/09/30/professional-grade-mypy-configuration/" target="_blank" rel="noopener noreferrer">Wolt</a></span><span> has a nice post on what they call the &#34;Professional-grade mypy configuration”, which is, coincidentally, what we use.)</span></span></p><p><span><span>Overall: </span><span><strong>I have a very positive opinion of Mypy.</strong></span><span> As a developer of core infrastructure (i.e., the common libraries used across services and across the team), I find it invaluable.</span></span></p><p><span><span>I’ll use it again for any and all future Python projects.</span></span></p><h2 id="block-c81d4f53fc564ee4a09c23359838c9a5"><span id="c81d4f53fc564ee4a09c23359838c9a5"></span><span><span>Benefits</span></span></h2><p><span><span>Zulip wrote a nice </span><span><a href="https://blog.zulip.com/2016/10/13/static-types-in-python-oh-mypy/#benefitsofusingmypy" target="_blank" rel="noopener noreferrer">blog post</a></span><span> back in 2016 on the benefits of using Mypy (that post is also linked from the </span><span><a href="https://mypy.readthedocs.io/en/stable/getting_started.html#next-steps" target="_blank" rel="noopener noreferrer">Mypy docs</a></span><span>).</span></span></p><p><span><span>I don’t want to rehash all the benefits of static typing (it is good), but I will briefly double down on a few that they called out in their post:</span></span></p><ol type="1"><li id="block-aaec9d67215e4c1fa5dae6b84dd36146"><span><span><strong>Improved readability</strong></span><span>: with type annotations, code tends towards self-documenting (and the accuracy of that documentation can be statically enforced, unlike in a docstring).</span></span></li><li id="block-9f652f9b05de48dfab6d89cc0a11ad22"><span><span><strong>Catching bugs: </strong></span><span>it’s true! Mypy </span><span><em>does</em></span><span> catch bugs. All the time.</span></span></li><li id="block-6f60408ed2934984befed3908ed29bdf"><span><span><strong>Refactoring with confidence: </strong></span><span>this has been the single most impactful benefit of using Mypy. With extensive Mypy coverage, I can confidently ship changes that span hundreds or even thousands of files. This is, of course, related to (2) — most of the bugs we catch with Mypy are bugs that we iron out while refactoring.</span></span></li></ol><p><span><span>The value of (3) is hard to overstate. It’s no exaggeration to say that there are classes of changes that I’ve shipped ten, or even a hundred times faster with the help of Mypy.</span></span></p><p><span><span>Though it’s entirely subjective, in writing this post I realized that </span><span><em><strong>I trust Mypy</strong></em></span><span><em>.</em></span><span> Not to the same degree as, say, the OCaml compiler, but still — it’s completely changed my relationship to maintaining Python code, and I can’t imagine going back to a world without annotations.</span></span></p><h2 id="block-af1ba2f205544337ab5610b9de26000d"><span id="af1ba2f205544337ab5610b9de26000d"></span><span><span>Pain points</span></span></h2><p><span><span>The Zulip post similarly highlights the </span><span><a href="https://blog.zulip.com/2016/10/13/static-types-in-python-oh-mypy/#painpoints" target="_blank" rel="noopener noreferrer">pain points</a></span><span> that they experienced in their Mypy migration (interactions with linters, import cycles). </span></span></p><p><span><span>Candidly, the pain points that I’ve felt with Mypy differed from those outlined in the Zulip article. I’d bucket them into three categories:</span></span></p><ol type="1"><li id="block-2f90f3ed900b4ed08232bff9e1aa526b"><span><span><strong>Lack of type annotations for external libraries</strong></span></span></li><li id="block-ca2e456e041d4eee95b3cf84a3473949"><span><span><strong>The Mypy learning curve</strong></span></span></li><li id="block-62ee0775439245aebba8c10bce7ff219"><span><span><strong>Fighting the type system</strong></span></span></li></ol><p><span><span>Let’s review them one-at-a-time:</span></span></p><h3 id="block-aaf5bd4d10264206aae2201125095e6b"><span id="aaf5bd4d10264206aae2201125095e6b"></span><span><span>1. Lack of type annotations for external libraries</span></span></h3><p><span><span>The first and most important pain point is that most of the third-party Python libraries we pull in are either untyped or otherwise </span><span><a href="https://peps.python.org/pep-0561/" target="_blank" rel="noopener noreferrer">PEP 561</a></span><span>-non-compliant. In practice, that means any reference to an external library gets interpreted as </span><span><code>Any</code></span><span>, which weakens your type coverage significantly. </span></span></p><p><span><span>Whenever we add a third-party library to our environment, we include an entry in our </span><span><code>mypy.ini</code></span><span>, which tells Mypy to ignore the absence of type annotations for those modules (the rare exception being libraries that are typed or provide type stubs):</span></span></p><div id="block-96bb67d2266b48f0a34940a0ff7c0777"><pre><code>[mypy-altair.*]
ignore_missing_imports = True

[mypy-apache_beam.*]
ignore_missing_imports = True

[mypy-bokeh.*]
ignore_missing_imports = True

...</code></pre><figcaption><span></span></figcaption></div><p><span><span>Because of this escape hatch, even coarse object annotations don’t work as you might expect. For example, Mypy allows this:</span></span></p><div id="block-316b264a4edb4a0b9b57d687d8fc7bd7"><pre><code>import pandas as pd


def return_data_frame() -&gt; pd.DataFrame:
    &#34;&#34;&#34;Mypy interprets pd.DataFrame as Any, so returning a str is fine!&#34;&#34;&#34;
    return &#34;Hello, world!&#34;</code></pre><figcaption><span></span></figcaption></div><p><span><span>Beyond third-party libraries, we’ve also had some bad luck with the Python standard library itself. For example, </span><span><code>functools.lru_cache</code></span><span> </span><span><em>does</em></span><span> have a type annotation in </span><span><a href="https://github.com/python/typeshed/blob/a57e1826083b80fa564e8d46b72981f005bbdd65/stdlib/functools.pyi" target="_blank" rel="noopener noreferrer">typeshed</a></span><span>, but for complicated reasons, it doesn’t preserve the underlying function signature, so any function decorated with </span><span><code>@functools.lru_cache</code></span><span> sheds all of its type annotations.</span></span></p><p><span><span>For example, Mypy allows this:</span></span></p><div id="block-b34aa7b4d1504418ab2259128966da5d"><pre><code>import functools


@functools.lru_cache
def add_one(x: float) -&gt; float:
    return x + 1


add_one(&#34;Hello, world!&#34;)</code></pre><figcaption><span></span></figcaption></div><p><span><span>The situation with third-party libraries </span><span><em>is</em></span><span> improving. NumPy, for example, started </span><span><a href="https://numpy.org/devdocs/reference/typing.html" target="_blank" rel="noopener noreferrer">exposing types in version 1.20</a></span><span>. Pandas, too, has a set of </span><span><a href="https://github.com/pandas-dev/pandas-stubs" target="_blank" rel="noopener noreferrer">public typing stubs</a></span><span>, but they’re marked as incomplete. (Adding stubs to those libraries is very much non-trivial, it’s a huge effort!) As another data point, I saw </span><span><a href="https://blog.wolt.com/engineering/2022/08/11/project-template-for-modern-python-packages/" target="_blank" rel="noopener noreferrer">Wolt’s Python project template</a></span><span> on Twitter recently, and that too includes types-by-default. </span></span></p><p><span><span>So, types are becoming </span><span><em>less</em></span><span> rare. But in my experience, I’m surprised when we add a dependency that </span><span><em>does</em></span><span> have type annotations. It still feels like the exception, not the rule.</span></span></p><h3 id="block-f46145d877014e76ae550c049396e52b"><span id="f46145d877014e76ae550c049396e52b"></span><span><span>2. The Mypy learning curve</span></span></h3><p><span><span>This is entirely anecdotal, but most folks that join Spring (and have written Python in the past) haven’t used Mypy before, though they’re typically aware of and familiar with Python’s type annotation syntax. </span></span></p><p><span><span>Similarly, in candidate interviews, folks are often unfamiliar with the </span><span><code>typing</code></span><span> module beyond the annotation syntax itself. I typically show candidates a snippet that uses </span><span><code>typing.Protocol</code></span><span> as part of a broader technical discussion, and I can’t recall any candidates having seen that specific construct before — which, of course, is totally fine! But it says something about the popularity of typing in the ecosystem right now.</span></span></p><p><span><span>So, when we onboard team members, Mypy tends to be a </span><span><em>new</em></span><span> tool, something they have to learn. While the basics of the type annotation syntax are straightforward, we do regularly hear questions like, “Why doesn’t Mypy like this?”, “Why is Mypy failing here?”, etc.</span></span></p><p><span><span>For example, this is something that typically has to be explained:</span></span></p><div id="block-0baa0245f1964f3789c3516144e3d324"><pre><code>if condition:
	value: str = &#34;Hello, world&#34;
else:
  # Not ok -- we declared `value` as `str`, and this is `None`!
  value = None

...

if condition:
	value: str = &#34;Hello, world&#34;
else:
  # Not ok -- we already declared the type of `value`.
  value: Optional[str] = None

...

# This is ok!
if condition:
	value: Optional[str] = &#34;Hello, world&#34;
else:
  value = None</code></pre><figcaption><span></span></figcaption></div><p><span><span>Or, another source of confusion:</span></span></p><div id="block-ebfa30bdcf0f42f4991dddecbf0165a6"><pre><code>from typing import Literal

def my_func(value: Literal[&#39;a&#39;, &#39;b&#39;]) -&gt; None:
  ...

for value in (&#39;a&#39;, &#39;b&#39;):
	# Not ok -- `value` is `str`, not `Literal[&#39;a&#39;, &#39;b&#39;]`.
  my_func(value)</code></pre><figcaption><span></span></figcaption></div><p><span><span>When explained, the “why” of these examples makes sense, but I can’t deny that people on the team lose time getting familiar with Mypy. And anecdotally, we’ve heard from folks on the team that PyCharm’s type-assistance (even with ample static typing) just </span><span><em>feels</em></span><span> less helpful and complete than (e.g.) what you get with TypeScript from the same IDE. Unfortunately, this is just the cost of doing business with Mypy.</span></span></p><p><span><span>Beyond the learning curve, there’s also the ongoing overhead of annotating functions and variables. In the past, I’ve suggested relaxing our Mypy rules for certain “kinds” of code (like exploratory data analysis) — and yet, the sentiment on the team is that the annotations are worthwhile, which has been cool to see.</span></span></p><h3 id="block-bebf2c20a1e84b9eaf3fabae6ce1aa6e"><span id="bebf2c20a1e84b9eaf3fabae6ce1aa6e"></span><span><span>3. Fighting the type system</span></span></h3><p><span><span>There are a couple things I try to avoid when writing code for Mypy, lest I find myself fighting the type system: taking code that I </span><span><em>know</em></span><span> works, and coercing Mypy to accept it.</span></span></p><p><span><span>First, </span><span><code>@overload</code></span><span>, from the </span><span><code>typing</code></span><span> module: Very powerful, but hard to get right. Of course, if I need to overload a method, I’ll use it — but, like I said, I prefer to avoid it if I can. The basics are straightforward:</span></span></p><div id="block-488f0b7ac6bd42feb7fcec2752f6d38c"><pre><code>@overload
def clean(s: str) -&gt; str:
    ...


@overload
def clean(s: None) -&gt; None:
    ...


def clean(s: Optional[str]) -&gt; Optional[str]:
    if s:
        return s.strip().replace(&#34;\u00a0&#34;, &#34; &#34;)
    else:
        return None</code></pre><figcaption><span></span></figcaption></div><p><span><span>But often, we want to do things like “return a different type based on a boolean flag, with a default”, which requires this incantation:</span></span></p><div id="block-f6786befa4c34253a5ced6f05d24debc"><pre><code>@overload
def lookup(
    paths: Iterable[str], *, strict: Literal[False]
) -&gt; Mapping[str, Optional[str]]:
    ...


@overload
def lookup(
    paths: Iterable[str], *, strict: Literal[True]
) -&gt; Mapping[str, str]:
    ...


@overload
def lookup(
    paths: Iterable[str]
) -&gt; Mapping[str, Optional[str]]:
    ...


def lookup(
    paths: Iterable[str], *, strict: Literal[True, False] = False
) -&gt; Any:
    pass</code></pre><figcaption><span></span></figcaption></div><p><span><span>Even </span><span><em>this</em></span><span> is a hack — you can’t pass a </span><span><code>bool</code></span><span> into </span><span><code>find_many_latest</code></span><span>, you have to pass a literal </span><span><code>True</code></span><span> or </span><span><code>False</code></span><span>.</span></span></p><p><span><span>Similarly, I’ve run into issues in the past with using </span><span><code>@typing.overload</code></span><span> vs. </span><span><code>@overload</code></span><span>, using </span><span><code>@overload</code></span><span> with class methods, and so on.</span></span></p><p><span><span>Second, </span><span><code>TypedDict</code></span><span>, again from the </span><span><code>typing</code></span><span> module: can be useful, but tends to produce awkward code. For example, you can’t destructure a </span><span><code>TypedDict</code></span><span> — it always has to be constructed from literal keys — so this doesn’t work:</span></span></p><div id="block-89184986ec5642f6b23baaa15361e49f"><pre><code>from typing import TypedDict


class Point(TypedDict):
    x: float
    y: float

a: Point = {&#34;x&#34;: 1, &#34;y&#34;: 2}

# error: Expected TypedDict key to be string literal
b: Point = {**a, &#34;y&#34;: 3}</code></pre><figcaption><span></span></figcaption></div><p><span><span>In practice, it’s just very hard to do Pythonic things with </span><span><code>TypedDict</code></span><span> objects. I end up tending towards either </span><span><code>dataclass</code></span><span> or </span><span><code>typing.NamedTuple</code></span><span> objects instead.</span></span></p><p><span><span>Third, decorators. The Mypy </span><span><a href="https://mypy.readthedocs.io/en/stable/generics.html#declaring-decorators" target="_blank" rel="noopener noreferrer">docs</a></span><span> have a standard suggestion for signature-preserving decorators and decorator factories. And while it’s quite advanced, it does work:</span></span></p><div id="block-38a843f859394e05972367e4a76de65b"><pre><code>F = TypeVar(&#34;F&#34;, bound=Callable[..., Any])


def decorator(func: F) -&gt; F:
    def wrapper(*args: Any, **kwargs: Any):
        return func(*args, **kwargs)

    return cast(F, wrapper)


@decorator
def f(a: int) -&gt; str:
    return str(a)</code></pre><figcaption><span></span></figcaption></div><p><span><span>However, I find that doing anything fancy with decorators (and, in particular, anything non-signature-preserving) leads to code that’s hard to type or rife with casts. Which might be a good thing! </span><span><strong>Mypy has certainly changed </strong></span><span><strong><em>how</em></strong></span><span><strong> I write Python: clever code is harder to type properly, and so I try to avoid writing clever code.</strong></span><span> (The other fear with decorators is the </span><span><code>@functools.lru_cache</code></span><span> problem I raised above: since a decorator ultimately defines an entirely new function, you’re opening the door to significant and surprising errors, if you happen to annotate your code incorrectly.)</span></span></p><p><span><span>I feel similarly about circular imports — the need to import types, to use as annotations, can create circular imports that you’d otherwise avoid (which the </span><span><a href="https://blog.zulip.com/2016/10/13/static-types-in-python-oh-mypy/#painpoints" target="_blank" rel="noopener noreferrer">Zulip</a></span><span> team highlighted as a pain point too). And while circular imports </span><span><em>are</em></span><span> a pain point with Mypy, they’re often indicative of a design flaw in the system or code itself, which Mypy forces me to reckon with.</span></span></p><p><span><span>In my experience, though, even experienced Mypy users will find themselves making a correction or two to otherwise-working code prior to passing type-checks.</span></span></p><p><span><span>(By the way: Python 3.10 contains a great improvement to the decorator situation via </span><span><a href="https://docs.python.org/3/library/typing.html#typing.ParamSpec" target="_blank" rel="noopener noreferrer"><code>ParamSpec</code></a></span><span>.)</span></span></p><h2 id="block-9cc8cac693414dc6a37eb06e16b41af2"><span id="9cc8cac693414dc6a37eb06e16b41af2"></span><span><span>Tips &amp; tricks</span></span></h2><p><span><span>Finally, a couple tricks I’ve found useful in working with Mypy.</span></span></p><h3 id="block-e840a96d6c724a979c9c3ff420fcc209"><span id="e840a96d6c724a979c9c3ff420fcc209"></span><span><span><code>reveal_type</code></span></span></h3><p><span><span>Adding </span><span><code>reveal_type</code></span><span> </span><span><em>anywhere</em></span><span> will cause Mypy to display the inferred type of a variable when type-checking the file. This is very, very, very useful.</span></span></p><p><span><span>The most basic example would be:</span></span></p><div id="block-015f918f744c42c2a129344a8b6329d1"><pre><code># No need to import anything. Just call `reveal_type`.
# Your editor will flag it as an undefined reference -- just ignore that.
x = 1
reveal_type(x)  # Revealed type is &#34;builtins.int&#34;</code></pre><figcaption><span></span></figcaption></div><p><span><span><code>reveal_type</code></span><span> is especially useful when you start dealing with </span><span><a href="https://mypy.readthedocs.io/en/stable/generics.html" target="_blank" rel="noopener noreferrer">generics</a></span><span>, as it can help you understand how generics are being “filled in”, whether your types are getting narrowed, and so on.</span></span></p><h3 id="block-83bff192fb2d4e4b8998ac34f563b306"><span id="83bff192fb2d4e4b8998ac34f563b306"></span><span><span>Mypy as a library</span></span></h3><p><span><span>Mypy can be used as a runtime library!</span></span></p><p><span><span>We have an internal workflow orchestration library that looks a bit like </span><span><a href="https://flyte.org/" target="_blank" rel="noopener noreferrer">Flyte</a></span><span> or </span><span><a href="https://www.prefect.io/" target="_blank" rel="noopener noreferrer">Prefect</a></span><span>. The details aren’t critical, but notably, it </span><span><em>is</em></span><span> fully typed — so we can statically enforce the type-safety of runnable tasks as they’re chained together.</span></span></p><p><span><span>Getting that typing right was very challenging. To ensure that it remains intact, and isn’t poisoned by a stray </span><span><code>Any</code></span><span>, we actually wrote unit tests that call Mypy on a set of files, and assert that the errors raised by Mypy match an expected set of violations:</span></span></p><div id="block-890f9ce75aba47c297448e6d37cbb96d"><pre><code>def test_check_function(self) -&gt; None:
	  result = api.run(
	      [
	          os.path.join(
	              os.path.dirname(__file__),
	              &#34;type_check_examples/function.py&#34;,
	          ),
	          &#34;--no-incremental&#34;,
	      ],
	  )
	
	  actual = result[0].splitlines()
	  expected = [
	      # fmt: off
	      &#39;type_check_examples/function.py:14: error: Incompatible return value type (got &#34;str&#34;, expected &#34;int&#34;)&#39;,  # noqa: E501
	      &#39;type_check_examples/function.py:19: error: Missing positional argument &#34;x&#34; in call to &#34;__call__&#34; of &#34;FunctionPipeline&#34;&#39;,  # noqa: E501
	      &#39;type_check_examples/function.py:22: error: Argument &#34;x&#34; to &#34;__call__&#34; of &#34;FunctionPipeline&#34; has incompatible type &#34;str&#34;; expected &#34;int&#34;&#39;,  # noqa: E501
	      &#39;type_check_examples/function.py:25: note: Revealed type is &#34;builtins.int&#34;&#39;,  # noqa: E501
	      &#39;type_check_examples/function.py:28: note: Revealed type is &#34;builtins.int&#34;&#39;,  # noqa: E501
	      &#39;type_check_examples/function.py:34: error: Unexpected keyword argument &#34;notify_on&#34; for &#34;options&#34; of &#34;Expression&#34;&#39;,  # noqa: E501
	      &#39;pipeline.py:307: note: &#34;options&#34; of &#34;Expression&#34; defined here&#39;,  # noqa: E501
	      &#34;Found 4 errors in 1 file (checked 1 source file)&#34;,
	      # fmt: on
	  ]
	
	  self.assertEqual(actual, expected)</code></pre><figcaption><span></span></figcaption></div><h3 id="block-0d1ee96b0fe647aca49222818a8c83b6"><span id="0d1ee96b0fe647aca49222818a8c83b6"></span><span><span>GitHub Issues</span></span></h3><p><span><span>When I find myself wondering how to resolve a certain typing issue, I inevitably find myself in Mypy’s </span><span><a href="https://github.com/python/mypy/issues" target="_blank" rel="noopener noreferrer">GitHub Issues</a></span><span> (more-so than, e.g., Stack Overflow). It’s probably the best source of typing knowledge for Mypy-specific workarounds and How-To’s. You’ll typically find tips and suggestions from the core team (including Guido) on notable issues.</span></span></p><p><span><span>The main downside is that each comment in a GitHub Issue represents commentary from a specific moment in time — what was a limitation in 2018 may’ve been resolved, what was a workaround last year may have a new best practice. So be sure to read through Issue history with that in mind.</span></span></p><h3 id="block-45e0069862844b42a4d3e76a5677824a"><span id="45e0069862844b42a4d3e76a5677824a"></span><span><span><code>typing-extensions</code></span></span></h3><p><span><span>While the </span><span><code>typing</code></span><span> module tends to see a bunch of improvement with each Python release, some features are backported via the </span><span><a href="https://pypi.org/project/typing-extensions/" target="_blank" rel="noopener noreferrer"><code>typing-extensions</code></a></span><span> module.</span></span></p><p><span><span>For example, while we’re only on Python 3.8, we make use of </span><span><code>ParamSpec</code></span><span> for the aforementioned workflow orchestration library via </span><span><code>typing-extensions</code></span><span>. (Unfortunately, PyCharm doesn’t seem to support the </span><span><code>ParamSpec</code></span><span> syntax via </span><span><code>typing-extensions</code></span><span> and marks it as an error, but oh well.) Features that depend on syntactical changes to the language itself are, of course, not available via </span><span><code>typing-extensions</code></span><span>.</span></span></p><h3 id="block-ad1319d46693452888df6f8e0cfb3b79"><span id="ad1319d46693452888df6f8e0cfb3b79"></span><span><span><code>NewType</code></span></span></h3><p><span><span>There are a bunch of useful helpers in the </span><span><code>typing</code></span><span> module, but </span><span><a href="https://docs.python.org/3/library/typing.html#newtype" target="_blank" rel="noopener noreferrer"><code>NewType</code></a></span><span> is one of my favorites.</span></span></p><p><span><span><code>NewType</code></span><span> lets you create distinct types from existing types. As an example, you could use </span><span><code>NewType</code></span><span> to demarcate fully-qualified Google Cloud Storage URLs, in lieu of the </span><span><code>str</code></span><span>, like:</span></span></p><div id="block-fb21914899294f43ab5969e7f9957010"><pre><code>from typing import NewType


GCSUrl = NewType(&#34;GCSUrl&#34;, str)

def download_blob(url: GCSUrl) -&gt; None:
    ...

# Incompatible type &#34;str&#34;; expected &#34;GCSUrl&#34;
download_blob(&#34;gs://my_bucket/foo/bar/baz.jpg&#34;)

# Ok!
download_blob(GCSUrl(&#34;gs://my_bucket/foo/bar/baz.jpg&#34;))</code></pre><figcaption><span></span></figcaption></div><p><span><span>By indicating the </span><span><em>intent</em></span><span> to callers of </span><span><code>download_blob</code></span><span> , we’ve made the function self-documenting.</span></span></p><p><span><span>I find </span><span><code>NewType</code></span><span> to be especially useful for converting primitives like </span><span><code>str</code></span><span> and </span><span><code>int</code></span><span>, into semantically meaningful types.</span></span></p><h3 id="block-73552f08d70a4279b44d2d11d7f72be1"><span id="73552f08d70a4279b44d2d11d7f72be1"></span><span><span>Performance</span></span></h3><p><span><span>Mypy’s performance has never been a major problem for us. Mypy persists type-checking results to a cache, which speeds up repeated invocations (per the docs: “Mypy performs type checking </span><span><em>incrementally</em></span><span>, reusing results from previous runs to speed up successive runs”). </span></span></p><p><span><span>Running </span><span><code>mypy</code></span><span> on our largest service takes ~50-60 seconds with a cold cache, and ~1-2 seconds with a warm cache.</span></span></p><p><span><span>There are at least two ways to speed up Mypy, both of which leverage this concept (we don’t use either of them internally):</span></span></p><ol type="1"><li id="block-16362017c2814b2a8b43262624512e2e"><span><span>The </span><span><a href="https://mypy.readthedocs.io/en/stable/mypy_daemon.html" target="_blank" rel="noopener noreferrer">Mypy daemon</a></span><span>, which runs Mypy persistently in the background, allowing it to retain cache state in memory. Although Mypy caches results to disk between runs, the daemon is indeed </span><span><em>much</em></span><span> faster. (We used the Mypy daemon for a while by default, but I disabled it after we experienced some flakiness with the shared state — I can’t remember the specifics.)</span></span></li><li id="block-aceedd569ce24390a348572d2ae6b7b5"><span><span><a href="https://mypy.readthedocs.io/en/stable/additional_features.html#using-a-remote-cache-to-speed-up-mypy-runs" target="_blank" rel="noopener noreferrer">Shared remote caches</a></span><span>. As mentioned above, Mypy caches type-checking results to disk between runs — but if you’re running Mypy from a fresh machine or a fresh container (as on CI), you won’t see any benefit from that caching. The solution is to seed your disk with a recent cache state (i.e., warm the cache). The Mypy docs outline this process, but it’s fairly involved, and the specifics will depend on your own setup. We’ll probably enable this eventually for our own CI systems — we just haven’t gotten around it.</span></span></li></ol><p><span><span>Mypy has had a significant impact on our ability to ship code with confidence. Though I’ve tried to be honest in assessing the </span><span><em>costs</em></span><span> associated with adopting it, I’d do it all over again.</span></span></p><p><span><span>Beyond the value of the tool itself, I find Mypy to be an extremely </span><span><em>impressive</em></span><span> project, and I’m grateful to the maintainers for all the work they’ve put into it over the years. With each subsequent Mypy and Python release, we’re seeing noticeable improvements to the </span><span><code>typing</code></span><span> module, the annotation syntax, and Mypy itself. (Examples include: the new union types syntax (</span><span><code>X | Y</code></span><span>), </span><span><code>ParamSpec</code></span><span>, and </span><span><code>TypeAlias</code></span><span>, all of which were included in Python 3.10.)</span></span></p><p><span><span>If you have any questions, reactions, etc., find me on </span><span><a href="https://twitter.com/charliermarsh" target="_blank" rel="noopener noreferrer">Twitter</a></span><span>.</span></span></p><p><span><span><em>Published on August 21, 2022.</em></span></span></p></article></div></div>
  </body>
</html>
