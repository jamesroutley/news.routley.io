<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.appsignal.com/2021/11/30/three-ways-to-debug-code-in-elixir.html">Original</a>
    <h1>Three Ways to Debug Code in Elixir</h1>
    
    <div id="readability-page-1" class="page"><article>

<p>Elixir provides a very powerful suite of tools that devs can use to observe the behavior of their code and debug errors.</p>
<p>There are several different strategies you can use to debug code in Elixir.</p>
<p>While it is hard to produce a comprehensive list of all possible debugging methods, we will cover some of the most common methods in today’s post.</p>

<h2>1. The IO Module: <code>puts/2</code> and <code>inspect/2</code></h2>
<p>Use the <a href="https://hexdocs.pm/elixir/1.12/IO.html"><code>IO</code> module</a> for a quick and easy way to get some basic visibility into your code when debugging.
You can print out log statements that:</p>

<ul>
<li>tell you where you are in executing code</li>
<li>inspect structs and other entities</li>
<li>display the function’s arguments</li>
</ul>
<p><code>puts/2</code> and <code>inspect/2</code> are the most interesting to use when debugging.
With these, it’s easy to sprinkle a few good output messages throughout your code and then visualize what’s happening.</p>
<p><code>puts/2</code> just prints out a string to the intended device (or <code>:stdio</code> if you don’t provide anything).</p>
<p><code>inspect/2</code> does something similar but writes out formatted output (e.g., pretty-printing maps, structs, and arrays).
There are a couple of options to select the <code>width</code> or a <code>label</code> for the message:</p>
<div><table><tbody><tr><td><pre>1
2</pre></td><td><pre><span>&gt;</span> <span>IO</span><span>.</span><span>inspect</span><span>(%{</span><span>foo:</span> <span>:bar</span><span>},</span> <span>label:</span> <span>&#34;</span><span>some map&#34;</span><span>)</span>
<span># some map: %{foo: :bar}</span>
</pre></td></tr></tbody></table>
</div>
<p>The great thing about <code>IO.inspect/2</code> is that it returns the input, so it is easy to tap into long pipes:</p>
<div><table><tbody><tr><td><pre>1
2
3
4
5</pre></td><td><pre><span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span>
<span>|&gt;</span> <span>IO</span><span>.</span><span>inspect</span><span>(</span><span>label:</span> <span>&#34;</span><span>before&#34;</span><span>)</span>
<span>|&gt;</span> <span>Enum</span><span>.</span><span>map</span><span>(</span><span>&amp;</span><span>(</span><span>&amp;1</span> <span>*</span> <span>2</span><span>))</span>
<span>|&gt;</span> <span>IO</span><span>.</span><span>inspect</span><span>(</span><span>label:</span> <span>&#34;</span><span>after&#34;</span><span>)</span>
<span>|&gt;</span> <span>Enum</span><span>.</span><span>sum</span>
</pre></td></tr></tbody></table>
</div>
<p>In addition to this, if you need to create strings with embedded maps for the log messages, it is also possible to use <code>Kernel.inspect/2</code> inside puts strings — like this:</p>
<div><table><tbody><tr><td><pre>1
2</pre></td><td><pre><span>&gt;</span> <span>IO</span><span>.</span><span>puts</span><span>(</span><span>&#34;</span><span>some map: </span><span>#{</span><span>inspect</span><span>(%{</span><span>foo:</span> <span>:bar</span><span>}</span><span>)}&#34;</span><span>)</span>
<span># some map: %{foo: :bar}</span>
</pre></td></tr></tbody></table>
</div>
<p>The <a href="https://hexdocs.pm/elixir/1.12/Inspect.Opts.html"><code>inspect</code> method has a lot more options</a> to customize your output.</p>
<p>Finally, if you need to access a function’s arguments quickly, it is possible to use <code>binding/1</code>.</p>
<div><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8</pre></td><td><pre><span>defmodule</span> <span>Greeter</span> <span>do</span>
  <span>def</span> <span>greet</span><span>(</span><span>name</span> <span>\\</span> <span>&#34;</span><span>John Doe&#34;</span><span>)</span> <span>do</span>
    <span>IO</span><span>.</span><span>inspect</span><span>(</span><span>binding</span><span>())</span>
  <span>end</span>
<span>end</span>

<span>Greeter</span><span>.</span><span>greet</span><span>()</span> <span># Prints [name: &#34;John Doe&#34;]</span>
<span>Greeter</span><span>.</span><span>greet</span><span>(</span><span>&#34;</span><span>Jane Doe&#34;</span><span>)</span> <span># Prints [name: &#34;Jane Doe&#34;]</span>
</pre></td></tr></tbody></table>
</div>

<h2>2. IEx for Advanced Debugging Control</h2>
<p>If you need advanced control for debugging, the next tool you’ll find useful is the interactive shell IEx.
IEx lets you inspect and visualize the current state of your code, manually execute code, and examine the results.
Just pop in <code>require IEx; IEx.pry</code> anywhere in your code and then run it with <code>iex</code>. So, if you are running a:</p>

<ul>
<li>Standalone elixir file with <code>elixir fib.exs</code>, use <code>iex -r fib.exs</code> instead.</li>
<li>Mix command like <code>mix run fib.exs</code> or <code>mix phx.server</code>, use <code>iex -S mix run fib.exs</code> or <code>iex -S mix phx.server</code>.</li>
</ul>
<p>Let’s take a look at some of the things we can do with IEx.</p>

<h3>Using Pry with IEx</h3>
<p>Let’s see how debugging works with pry by looking at a <a href="https://gist.github.com/pulkit110/cdf5341405d36a945faf6882b187c96d">buggy Fibonacci number generator</a>. The code does not produce the expected result. Let’s put a <code>require IEx; IEx.pry</code> on line 9 (just after <code>fib2 = fib</code>) and run it with <code>iex -r fib.exs</code>:</p>
<div><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12</pre></td><td><pre><span>Request</span> <span>to</span> <span>pry</span> <span>#PID&lt;0.104.0&gt; at Fib.number/1 (fib.exs:9)</span>

    <span>7</span><span>:</span>       <span>fib1</span> <span>=</span> <span>fib2</span>
    <span>8</span><span>:</span>       <span>fib2</span> <span>=</span> <span>fib</span>
    <span>9</span><span>:</span>       <span>require</span> <span>IEx</span><span>;</span> <span>IEx</span><span>.</span><span>pry</span>
   <span>10</span><span>:</span>     <span>end</span><span>)</span>
   <span>11</span><span>:</span>     <span>fib2</span>

<span>Allow</span><span>?</span> <span>[</span><span>Yn</span><span>]</span> <span>y</span>
<span>Interactive</span> <span>Elixir</span> <span>(</span><span>1.12</span><span>.</span><span>0</span><span>)</span> <span>-</span> <span>press</span> <span>Ctrl</span><span>+</span><span>C</span> <span>to</span> <span>exit</span> <span>(</span><span>type</span> <span>h</span><span>()</span> <span>ENTER</span> <span>for</span> <span>help</span><span>)</span>
<span>pry</span><span>(</span><span>1</span><span>)</span><span>&gt;</span> <span>binding</span><span>()</span>
<span>[</span><span>_i:</span> <span>2</span><span>,</span> <span>fib:</span> <span>1</span><span>,</span> <span>fib1:</span> <span>1</span><span>,</span> <span>fib2:</span> <span>1</span><span>,</span> <span>n:</span> <span>5</span><span>]</span>
</pre></td></tr></tbody></table>
</div>
<p>We can see that it stops at the <code>IEx.pry()</code> call. Then, we can inspect the values of the variables (or just use <code>binding</code> to output all context).
For the first iteration, everything looks good, <code>fib2</code> updates to <code>1</code>, and <code>fib1</code> uses the previous value of <code>fib2</code>, i.e., <code>1</code>.</p>
<p>On the next iteration, we expect <code>fib2</code> to be <code>1 + 1 = 2</code> and <code>fib1</code> to be <code>1</code>, and then <code>fib2</code> to be <code>2 + 1 = 3</code> and <code>fib1</code> to be <code>2</code>, and so on.</p>
<p>So let’s type <code>continue</code> to go to the next <code>pry</code> call and inspect the binding again:</p>
<div><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11</pre></td><td><pre><span>pry</span><span>(</span><span>2</span><span>)</span><span>&gt;</span> <span>continue</span>
<span>Break</span> <span>reached:</span> <span>Fib</span><span>.</span><span>number</span><span>/</span><span>1</span> <span>(</span><span>fib</span><span>.</span><span>exs:</span><span>9</span><span>)</span>

    <span>7</span><span>:</span>       <span>fib1</span> <span>=</span> <span>fib2</span>
    <span>8</span><span>:</span>       <span>fib2</span> <span>=</span> <span>fib</span>
    <span>9</span><span>:</span>       <span>require</span> <span>IEx</span><span>;</span> <span>IEx</span><span>.</span><span>pry</span>
   <span>10</span><span>:</span>     <span>end</span><span>)</span>
   <span>11</span><span>:</span>     <span>fib2</span>

<span>pry</span><span>(</span><span>1</span><span>)</span><span>&gt;</span> <span>binding</span><span>()</span>
<span>[</span><span>_i:</span> <span>3</span><span>,</span> <span>fib:</span> <span>1</span><span>,</span> <span>fib1:</span> <span>1</span><span>,</span> <span>fib2:</span> <span>1</span><span>,</span> <span>n:</span> <span>5</span><span>]</span>
</pre></td></tr></tbody></table>
</div>
<p>Here, we see that we are on the next iteration (<code>_i</code> is <code>3</code>), but apparently, the other variables do not change at all.
So this is where our bug lies. Everything is immutable in Elixir, so assigning variables inside the anonymous function creates new variables rather than overriding the ones on the outer scope.
We can now use this insight to fix our code.</p>
<p>If you are curious, <a href="https://gist.github.com/pulkit110/1c477da9e47dbc5fdb6df582b7999e59">see the fixed version of the Fibonacci number generator</a>.</p>

<h3>Using Breakpoints with IEx</h3>
<p>In the previous section, we had to change the code to enter the pry session.
IEx also provides a <code>break!</code> function to set breakpoints without changing code.
This is very important when you want to set breakpoints in parts of code that you don’t own, coming from a library or even from Elixir standard modules.</p>
<p>The only drawback is that this only works on compiled code, and you can only <code>break!</code> at the start of the function, not on any arbitrary line.</p>
<p>To use <code>break!</code> with our Fibonacci example:</p>
<div><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12</pre></td><td><pre><span>$ </span>elixirc fib.ex <span># This generates a beam file in your current dir</span>
<span>$ </span>ls <span>*</span>.beam
Elixir.Fib.beam
<span>$ </span>iex            <span># This will load all beam files in the current directory</span>
<span>iex&gt; </span>IEx.Helpers.break!<span>(</span>Fib.number/1<span>)</span>
<span>iex&gt; </span>Fib.number<span>(</span>5<span>)</span>
Break reached: Fib.number/1 <span>(</span>fib.ex:2<span>)</span>

    1: defmodule Fib <span>do
    </span>2:   def number<span>(</span>n<span>)</span> <span>do
    </span>3:     fib1 <span>=</span> 0
    4:     fib2 <span>=</span> 1
</pre></td></tr></tbody></table>
</div>

<h3>Bonus: IEx Tips and Tricks</h3>
<p>While we are on IEx, let us look at some general tips that can help you be more productive with it.</p>
<p>The first, and possibly the most important, is to enable shell history if you use IEx a lot. You can then press <code>↑</code> to get your last used commands or use <code>^ + R</code> to reverse search the history of used commands.
There are two ways you can enable shell history:</p>

<ol>
<li><p>Enable each session by starting it with a flag:</p>
<div><table><tbody><tr><td><pre>1</pre></td><td><pre><span>$ </span>iex --erl <span>&#34;-kernel shell_history enabled&#34;</span>
</pre></td></tr></tbody></table>
</div></li>
<li><p>Enable all sessions by setting the <code>ERL_AFLAGS</code> environment on your shell. Depending on your terminal configuration, you will need to add the following (or its equivalent) to a startup script (like <code>~/.zshrc</code>/<code>~/.bashrc</code>):</p>
<div><table><tbody><tr><td><pre>1</pre></td><td><pre><span>export </span><span>ERL_AFLAGS</span><span>=</span><span>&#34;-kernel shell_history enabled&#34;</span>
</pre></td></tr></tbody></table>
</div></li>
</ol>
<p>The second tip, which works on the recent version of Elixir (1.12+), means that you can use multi-line pipes directly in the shell.
The pipe automatically gets the last evaluated statement’s return value.
So you can just copy and paste long pipes from your code directly in the IEx session:</p>
<div><table><tbody><tr><td><pre>1
2
3
4</pre></td><td><pre><span>iex</span><span>(</span><span>1</span><span>)</span><span>&gt;</span> <span>[</span><span>1</span><span>,</span> <span>[</span><span>2</span><span>],</span> <span>3</span><span>]</span>
<span>[</span><span>1</span><span>,</span> <span>[</span><span>2</span><span>],</span> <span>3</span><span>]</span>
<span>iex</span><span>(</span><span>2</span><span>)</span><span>&gt;</span> <span>|&gt;</span> <span>List</span><span>.</span><span>flatten</span><span>()</span>
<span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span>
</pre></td></tr></tbody></table>
</div>
<p>If you often use modules in IEx, you can create a file called <code>.iex.exs</code> from the directory used to access IEx. Alternatively, you can create a global file inside the home directory (<code>~/.iex/exs</code>), and it will be evaluated every time you open an IEx session.</p>
<div><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8</pre></td><td><pre><span># Load another &#34;.iex.exs&#34; file</span>
<span>import_file</span><span>(</span><span>&#34;</span><span>~/.iex.exs&#34;</span><span>)</span>

<span># Import some module from lib that may not yet have been defined</span>
<span>import_if_available</span><span>(</span><span>MyApp</span><span>.</span><span>Mod</span><span>)</span>

<span># Import Ecto.Query so that querying is always available in the shell</span>
<span>import</span> <span>Ecto</span><span>.</span><span>Query</span>
</pre></td></tr></tbody></table>
</div>
<p>Finally, there are some cases when you might be using IEx and you make a typo (like an additional bracket or “) and the command cannot be terminated, for example:</p>
<div><table><tbody><tr><td><pre>1
2
3</pre></td><td><pre><span>iex&gt; </span><span>[</span><span>&#34;abc&#34;</span>
...  <span>&#34;
...  ]
</span></pre></td></tr></tbody></table>
</div>
<p>In this case, you cannot use <code>^ + C</code> or <code>^ + \</code> as they would terminate the session, rather than just the command. To terminate the command immediately, start a new line with <code>#iex:break</code>:</p>
<div><table><tbody><tr><td><pre>1
2
3
4
5
6</pre></td><td><pre><span>iex&gt; </span><span>[</span><span>&#34;abc&#34;</span>
...  <span>&#34;
...  ]
...  #iex:break
** (TokenMissingError) iex:1: incomplete expression
&gt;
</span></pre></td></tr></tbody></table>
</div>

<h2>3. Visual Debugging</h2>
<p>In addition to the prying functionality provided by Elixir, there is also a more sophisticated Erlang debugger that you can use.
While it works with a single compiled file like <code>IEx.break!</code>, let’s try using a file that is a part of a mix project with <code>iex -S mix</code> this time.</p>
<div><table><tbody><tr><td><pre>1
2
3
4
5
6
7</pre></td><td><pre><span>iex</span><span>&gt;</span> <span>:debugger</span><span>.</span><span>start</span><span>()</span>
<span>{</span><span>:ok</span><span>,</span> <span>#PID&lt;0.672.0&gt;}</span>
<span>iex</span><span>&gt;</span> <span>:int</span><span>.</span><span>ni</span><span>(</span><span>Fib</span><span>)</span>
<span>{</span><span>:module</span><span>,</span> <span>Fib</span><span>}</span>
<span>iex</span><span>&gt;</span> <span>:int</span><span>.</span><span>break</span><span>(</span><span>Fib</span><span>,</span> <span>6</span><span>)</span>
<span>ok</span>
<span>iex</span><span>&gt;</span> <span>Fib</span><span>.</span><span>number</span><span>(</span><span>5</span><span>)</span>
</pre></td></tr></tbody></table>
</div>
<p>The above will open the Erlang debugger and stop at the configured breakpoint.
This provides a more traditional debugging approach where you can perform a single step or continue to the next breakpoint, evaluate expressions in the current context, etc.</p>
<p><img src="https://d33wubrfki0l68.cloudfront.net/a760f20e11ae07003842a310601e8f020b52d0cb/71607/images/blog/2021-11/debugging-code-in-elixir-erlang-debugger.png" alt="Erlang Debugger"/></p>
<p>If you are using Visual Studio Code, the <a href="https://marketplace.visualstudio.com/items?itemName=JakeBecker.elixir-ls">ElixirLS plugin</a> supports in-editor breakpoints.
There is also similar support in IntelliJ through the <a href="https://github.com/KronicDeth/intellij-elixir#debugger">intellij-elixir plugin</a>.</p>

<h2>Debugging Elixir Processes</h2>
<p>A post on debugging Elixir code wouldn’t be complete without also covering how to debug processes.
While we can use the debugging methods we’ve already covered, a couple of other process-specific options are available.</p>

<h3>Using Trace to Debug Processes in Elixir</h3>
<p>Use <code>:sys.trace/2</code> when you quickly want to see all the messages exchanged between a process and its state updates.
We can use it to start/stop logging the process states and messages. Let’s continue with the Fibonacci computer, but this time, <a href="https://gist.github.com/pulkit110/e49fadea22e60758c26c5b6e81391ec1">wrapped inside a GenServer</a>:</p>
<div><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></td><td><pre>iex(3)&gt; {:ok, pid} = GenServer.start_link(Fib, nil)
{:ok, #PID&lt;0.1023.0&gt;}
iex(4)&gt; :sys.trace(pid, true)
:ok
iex(5)&gt; GenServer.call(pid, {:get, 1})
*DBG* &lt;0.1023.0&gt; got call {get,1} from &lt;0.1004.0&gt;
*DBG* &lt;0.1023.0&gt; sent 1 to &lt;0.1004.0&gt;, new state #{0 =&gt; 0,1 =&gt; 1}
1
iex(6)&gt; GenServer.call(pid, {:get, 2})
*DBG* &lt;0.1023.0&gt; got call {get,2} from &lt;0.1004.0&gt;
*DBG* &lt;0.1023.0&gt; sent nil to &lt;0.1004.0&gt;, new state #{0 =&gt; 0,1 =&gt; 1}
nil
iex(3)&gt; GenServer.cast(pid, {:compute, 10})
*DBG* &lt;0.1031.0&gt; got cast {compute,10}
:ok
*DBG* &lt;0.1031.0&gt; new state #{0 =&gt; 0,1 =&gt; 1,2 =&gt; 1,3 =&gt; 2,4 =&gt; 3,5 =&gt; 5,6 =&gt; 8,
                             7 =&gt; 13,8 =&gt; 21,9 =&gt; 34,10 =&gt; 55}
iex(4)&gt; GenServer.call(pid, {:get, 2})
*DBG* &lt;0.1031.0&gt; got call {get,2} from &lt;0.1029.0&gt;
*DBG* &lt;0.1031.0&gt; sent 1 to &lt;0.1029.0&gt;, new state #{0 =&gt; 0,1 =&gt; 1,2 =&gt; 1,
                                                   3 =&gt; 2,4 =&gt; 3,5 =&gt; 5,
                                                   6 =&gt; 8,7 =&gt; 13,8 =&gt; 21,
                                                   9 =&gt; 34,10 =&gt; 55}
1
</pre></td></tr></tbody></table>
</div>

<h3>Debugging Processes with Observer in Elixir</h3>
<p>If you prefer a more visual approach, Erlang provides an <code>:observer</code> that opens a user interface you can use to browse the Supervision Tree or check process states and messages.</p>
<p>To access this, all you need is:</p>

<p>While a full review of <code>:observer</code> would take up a whole new post, here is a small demo of all that is possible:</p>

<video width="100%" loop="" muted="" autoplay="" controls="">
  <source src="https://d33wubrfki0l68.cloudfront.net/1ad2d28a81342ca4ab74820c758bc29b34b163be/4f177/videos/debugging-code-in-elixir-observer.mp4" type="video/mp4"/>
  <source src="https://d33wubrfki0l68.cloudfront.net/aa116d06d98e9819b79d41aae214d5705682ea40/b8423/videos/debugging-code-in-elixir-observer.ogv" type="video/ogg"/>
  <source src="https://d33wubrfki0l68.cloudfront.net/3bdadd04792cfa0e5c36aefb9ccd041f9f5d591d/ef6b8/videos/debugging-code-in-elixir-observer.webm" type="video/webm"/>
</video>

<h2>Wrap-up</h2>
<p>In this post, we’ve covered three common methods of debugging: using the IO module, IEx, and visual debugging. We’ve also touched on debugging Elixir processes using trace and observer.</p>
<p>Elixir’s powerful debugging tools are what make it such a compelling language choice for developers and businesses.</p>
<p>Until next time, enjoy getting stuck into debugging code and processes in Elixir!</p>
<p><strong>P.S. If you’d like to read Elixir Alchemy posts as soon as they get off the press, <a href="https://blog.appsignal.com/category/elixir-alchemy.html#elixir-alchemy">subscribe to our Elixir Alchemy newsletter and never miss a single post</a>!</strong></p>
<p><em>Our guest author Pulkit is a senior full-stack engineer and consultant. In his free time, he writes about his experiences on <a href="https://pulkitgoyal.in">his blog</a>.</em></p>
</article></div>
  </body>
</html>
