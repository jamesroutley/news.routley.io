<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://zenhorace.dev/blog/context-control-go/">Original</a>
    <h1>Context Control in Go</h1>
    
    <div id="readability-page-1" class="page"><article>
	<h3>Best practices for handling context plumbing.</h3>
	<h5>Published: 2024-02-03</h5>
	<hr/>
	<img src="https://zenhorace.dev/img/context-go.png" alt="gopher teaching about context call chains"/>
	<blockquote><p>tl;dr</p></blockquote>

	<p>Context is one of the foundational building blocks in Go. Anyone with even a cursory experience
		with the language is likely to have encountered it, as it’s the first argument passed to
		functions that accept contexts. I see the purpose of context as twofold:</p>

	<p>This post will focus on good practices for leveraging contexts with control-flow operations.
	</p>

	<h2 id="a-couple-of-rules-of-thumb-to-start">A couple of rules of thumb to start.</h2>

	<ol><li><p>Only entry-point functions (the one at the top of a call chain) should create an empty
				context (i.e., <code>context.Background()</code>). For example, <code>main()</code>,
				<code>TestXxx()</code>. The HTTP library creates a custom context for each request, which
				you should access and pass. Of course, mid-chain functions can create child contexts to pass
				along if they need to share data or have flow control over the functions they call.
			</p></li>

		<li><p>Contexts are (only) passed down the call chain. If you’re not in an entry-point function and
				you need to call a function that takes a context, your function should accept a context and
				pass that along. But what if, for some reason, you can’t currently get access to the context
				at the top of the chain? In that case, use <code>context.TODO()</code>. This signals that
				the context is not yet available, and further work is required. Perhaps maintainers of
				another library you depend on will need to extend their functions to accept a context so
				that you, in turn, can pass it on. Of course, a function should never be returning a
				context.
			</p></li></ol>

	<p>There are three key rules of thumb when handling context. The first two mentioned above are
		relatively straightforward. The third rule is the reason for this post, as I encountered it this
		week.
	</p>

	<h2 id="storytime">Storytime</h2>

	<p>The <a href="https://pkg.go.dev/context" target="_blank" rel="noreferrer noopener">documentation
		</a> for context states:
	</p>

	<blockquote><p>Do not store Contexts inside a struct type; instead, pass a Context explicitly to each
			function that needs it.
		</p></blockquote>

	<p>I <em>thought</em> I understood this implicitly, and it sounds easy to obey. So I was surprised
		and confused earlier this week when I received a comment on a code review telling me, “Don’t
		store contexts.”</p>

	<p>What was I doing wrong? Let me set the context (pun intended). If you just want the third rule
		sans preamble, skip to the next section.
	</p>

	<p><em>Note: The code samples discussed below are simplified approximations of the issue I faced.
			While the examples should be fine, there may be typos.</em></p>

	<p>Imagine a long-running routine that makes requests to some source and relays the data it
		receives to a PubSub service. It keeps doing this until the caller tells the routine to stop.
		This relatively common system may look something like this:
	</p>

	<pre><code>type Worker struct {
  quit chan struct{}
  // internal details
}

// New configures and returns a Worker.
func New(ctx context.Context, ...) (*Worker, error)

func (w *Worker) Run(ctx context.Context)

func (w *Worker) Stop()</code></pre>

	<p>This is fine. However, I (in my infinite wisdom) thought that I could simplify things. I knew
		that:</p>

	<p>So, I came up with this:</p>

	<pre><code>type worker struct {
  quit chan struct{}
  // other internal details
}

func Start(ctx context.Context, ...) (cancel func()){
  // Configure setup. Details elided.
  w := &amp;worker{...}

  go w.run(ctx context.Context)
  return w.stop
}

func (w *worker) run(ctx context.Context) {
  ticker := time.NewTicker(time.Minute)
  defer ticker.Stop()
  for {
    select {
    case &lt;- w.quit:
      // perform cleanup
    case &lt;-ticker.C:
      cctx, cancel := context.WithTimeout(ctx, 30 * time.Second)
      w.doWork(cctx)
      cancel()
    }
  }
}

func (w *worker) stop() {
  close(w.quit)
}</code></pre>

	<p>Now, most seasoned Go devs would leap out of their seats to tell you it’s an anti-pattern for
		libraries to start their own goroutines. Best practices dictate that you should perform your
		work synchronously and let the caller decide if they want it to be asynchronous. Despite knowing
		this, I figured, “I’m writing the caller; it’ll be fine.” Now, instead of calling <code>New()</code>, then <code>Run()</code>, I can simply call <code>Start()</code>, which returns a cancel
		function. And I no longer need to export anything except <code>Start()</code> (I’m a sucker for tiny
		API surfaces).
	</p>

	<p>After I did that, I realized, “Oh… I need to ensure I also respect context cancellations.” So I
		made this change to <code>run()</code>:
	</p>

	<pre><code>func (w *worker) run(ctx context.Context) {
  ticker := time.NewTicker(time.Minute)
  defer ticker.Stop()
  for {
    select {
    case &lt;- w.quit:
      // perform cleanup
    case &lt;- ctx.Done():
      // perform cleanup
    case &lt;-ticker.C:
      // do work
    }
  }
}</code></pre>

	<p>Again, this should’ve been another indication that my hack wasn’t such a stroke of genius. I had
		the same logic to handle context cancellations and calls to <code>stop</code>. However, I was
		still too thrilled with my work, so I abstracted the cleanup logic to its own method and moved
		on.
	</p>

	<p>Anyway, can you spot how I was storing context even though I only passed it to functions and
		never put it in a struct?</p>

	<p>So, I assessed my code with some <a href="https://en.wikipedia.org/wiki/Rubber_duck_debugging" target="_blank" rel="noreferrer noopener">rubber duck debugging</a>:
	</p>

	<p><strong>Me</strong>: So, does this mean I have to toss this whole thing and start over??</p>

	<p><strong>Rubber Duck</strong>: There were some interesting ideas in there. This can work with
		some tweaks. First off, stop ignoring best practices and make the work synchronous.
	</p>

	<p><strong>Me</strong>: That makes sense. It’s two extra characters for the caller to make it async
		- not much work. But wait! If <code>Start()</code> is blocking, how will the caller access
		<code>Stop()</code>? I’ll have to go back to the <code>New() -&gt; [Run, Stop]</code> way…
	</p>

	<p><strong>Rubber Duck</strong>: Well, you currently have two stopping mechanisms that do identical
		work.
	</p>

	<p><strong>Me</strong>: You’re right! A cancellable context is an excellent
		<a href="https://en.wikipedia.org/wiki/Inversion_of_control" target="_blank" rel="noreferrer noopener">inversion of control</a> mechanism. I don’t need to create a custom Stop function.
	</p>

	<pre><code>type worker struct {
  // internal details. no stop channel.
}

// Start configures and runs the worker.
// Blocks until context cancellation.
func Start(ctx context.Context, ...){
  // Configure setup. Details elided.
  w := worker{...}
  // blocking call to run
  w.run(ctx context.Context)
}

func (w *worker) run(ctx context.Context) {
  ticker := time.NewTicker(time.Minute)
  defer ticker.Stop()
  for {
    select {
    case &lt;- ctx.Done:
      // perform cleanup
    case &lt;-ticker.C:
      // do work
    }
  }
}</code></pre>

	<p>By trying to be a little less clever, the final solution was cleaner, simpler, and less
		error-prone.
	</p>

	<h2 id="rule-3-don-t-store-contexts">Rule 3: Don’t store contexts</h2>

	<p>The core of the rule is:</p>
	<blockquote><p>When a function takes a context parameter, that context should only be used for the duration
			of the call, not after it returns.
		</p></blockquote>

	<p>The rationale is that once a function returns, the caller often cancels the context. Then, any
		calls made with that context will be canceled before they even begin, causing errors. These can
		be some of the most obscure bugs to root cause, so it’s best to eliminate the possibility.
	</p>

	<p><strong><em>Fin.</em></strong></p>

	<hr/>

	<p>Additional References on this topic:</p>
</article></div>
  </body>
</html>
