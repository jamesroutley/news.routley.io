<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.gauge.sh/blog/ai-makes-tech-debt-more-expensive">Original</a>
    <h1>AI makes tech debt more expensive</h1>
    
    <div id="readability-page-1" class="page"><section><div><div><div data-w-id="5b8e0128-dfc2-fd07-77df-30819f5d5004"><p>There is an emerging belief that AI will make tech debt <strong>less relevant</strong>. Since it’s getting easier to write code, and easier to clean up code, wouldn’t it make sense that the typical company can handle a little more debt?</p><p>The opposite is true - AI has significantly increased the real cost of carrying tech debt. The key impact to notice is that generative AI <strong>dramatically widens the gap in velocity </strong>between ‘low-debt’ coding and ‘high-debt’ coding.</p><p>Companies with relatively young, high-quality codebases benefit the most from generative AI tools, while companies with gnarly, legacy codebases will struggle to adopt them. In other words, the penalty for having a ‘high-debt’ codebase is now larger than ever.</p><figure><p><img src="https://cdn.prod.website-files.com/665a5f120c4c63df1944d627/673529427e9a3f24440903f2_673529288758869858b0a9d2_Screenshot%2520from%25202024-11-13%252014-32-42.png" loading="lazy" alt=""/></p><figcaption>Model of AI Tools&#39; Impact; Large Velocity Gain on Low-Debt Code</figcaption></figure><h3>GenAI can’t handle High Complexity</h3><p>If you’ve tried tools like <a href="https://cursor.com">Cursor</a> or <a href="https://aider.chat/">Aider</a> for professional coding, you know that their performance is highly sensitive to the complexity of the code you’re working on. They provide a dramatic speedup when applying pre-existing patterns, and when making use of existing interfaces or module relationships. However, in ‘high-debt’ environments with subtle control flow, long-range dependencies, and unexpected patterns, they struggle to generate a useful response.</p><p>Not only does a complex codebase make it harder for the model to generate a coherent response, it also makes it harder for the developer to formulate a coherent request.</p><p>This experience has lead most developers to “watch and wait” for the tools to improve until they can handle ‘production-level’ complexity in software. While genAI is improving dramatically in some sense (multi-modal, faster, smaller, cheaper), this barrier has so far proven more stubborn, with o1 seeing relatively low adoption and multi-agent frameworks failing to significantly scale reasoning capabilities.</p><h3>Make Your Tools Work for You</h3><p>Instead of trying to force genAI tools to tackle thorny issues in legacy codebases, human experts should do the work of refactoring legacy code until genAI can operate on it smoothly. When direct refactoring is still too risky, teams can adjust their development strategy with approaches like <a href="https://martinfowler.com/bliki/StranglerFigApplication.html">strangler fig</a> to build greenfield modules which can benefit immediately from genAI tooling.</p><p>This implies a shift to a higher level of abstraction for a modern development team. A product should be owned by a lean team of experts, focused primarily on the architecture of their code rather than the implementation details.</p><h3>AI-Friendly Approaches</h3><p>In essence, the goal should be to unblock your AI tools as much as possible. One reliable way to do this is to spend time breaking your system down into cohesive and coherent modules, each interacting through an explicit interface.</p><p>A useful heuristic for evaluating a set of modules is to use them to explain your core features and data flows in natural language. You should be able to concisely describe current and planned functionality. You might also want to set up <a href="https://github.com/gauge-sh/tach">visibility and enforcement</a> to make progress toward your desired architecture.</p><p>A modern development team should work to maintain and evolve a system of well-defined modules which robustly model the needs of their domain. Day-to-day feature work should then be done on top of this foundation with maximum leverage from generative AI tooling.</p><p>‍</p><h3>Quality Leads to Speed</h3><p>It’s now more valuable than ever to have a high-quality codebase. Investment into modular architecture lets teams take full advantage of generative AI tools, achieving rapid feature development while simultaneously building higher quality software.</p></div></div></div></section></div>
  </body>
</html>
