<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://devblogs.microsoft.com/dotnet/dotnet-8-hardware-intrinsics/">Original</a>
    <h1>Hardware Intrinsics in .NET 8</h1>
    
    <div id="readability-page-1" class="page"><div id="featured">

	<div>
                         <p>
            December 11th, 2023</p><!-- .entry-meta -->
        <p>.NET has a long history of providing access to additional hardware functionality via APIs that are intrinsically understood by the JIT compiler. This started on .NET Framework back in 2014 and expanded with the introduction of .NET Core 3.0 in 2019. Since then, the runtime has iteratively provided more APIs and taken better advantage of this in each release.</p>
<p>As a brief overview:</p>
<ul>
<li>2014 – .NET 4.5.2 – First APIs exposed in the <code>System.Numerics</code> namespace
<ul>
<li>Introduces <code>Vector&lt;T&gt;</code></li>
<li>Introduces <code>Vector2</code>, <code>Vector3</code>, <code>Vector4</code>, <code>Matrix4x4</code>, <code>Quaternion</code>, and <code>Plane</code></li>
<li>64-bit only</li>
<li>See also: https://devblogs.microsoft.com/dotnet/the-jit-finally-proposed-jit-and-simd-are-getting-married/</li>
</ul>
</li>
<li>2019 – .NET Core 3.0 – First APIs exposed in the <code>System.Runtime.Intrinsics</code> namespace
<ul>
<li>Introduces <code>Vector128&lt;T&gt;</code> and <code>Vector256&lt;T&gt;</code></li>
<li>Introduces <code>Sse</code>, <code>Sse2</code>, <code>Sse3</code>, <code>Ssse3</code>, <code>Sse41</code>, <code>Sse42</code>, <code>Avx</code>, <code>Avx2</code>, <code>Fma</code>, <code>Bmi1</code>, <code>Bmi2</code>, <code>Lzcnt</code>, <code>Popcnt</code>, <code>Aes</code>, and <code>Pclmul</code> for <code>x86</code>/<code>x64</code></li>
<li>32-bit and 64-bit support</li>
<li>See also: https://devblogs.microsoft.com/dotnet/hardware-intrinsics-in-net-core/</li>
</ul>
</li>
<li>2020 – .NET 5 – Arm support added to the <code>System.Runtime.Intrinsics</code> namespace
<ul>
<li>Introduces <code>Vector64&lt;T&gt;</code></li>
<li>Introduces <code>AdvSimd</code>, <code>ArmBase</code>, <code>Dp</code>, <code>Rdm</code>, <code>Aes</code>, <code>Crc32</code>, <code>Sha1</code>, and <code>Sha256</code> for <code>Arm</code>/<code>Arm64</code></li>
<li>Introduces <code>X86Base</code> for <code>x86</code>/<code>x64</code></li>
<li>See also: https://devblogs.microsoft.com/dotnet/announcing-net-5-0-preview-7/</li>
</ul>
</li>
<li>2021 – .NET 6 – Codegen and infrastructure improvements
<ul>
<li>Introduces <code>AvxVnni</code> for <code>x86</code>/<code>x64</code></li>
<li>Rewrites the <code>System.Numerics</code> implementation to use <code>System.Runtime.Intrinsics</code></li>
<li>See also: https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-6/</li>
</ul>
</li>
<li>2022 – .NET 7 – Support for writing cross platform algorithms
<ul>
<li>Introduces significant new functionality on the <code>Vector64&lt;T&gt;</code>, <code>Vector128&lt;T&gt;</code>, and <code>Vector256&lt;T&gt;</code> types that works across platforms</li>
<li>Introduces <code>X86Serialize</code> for <code>x86</code>/<code>x64</code></li>
<li>Brings the API surface exposed by the above vector types and <code>Vector&lt;T&gt;</code> to a parity</li>
<li>See also: https://devblogs.microsoft.com/dotnet/performance_improvements_in_net_7/</li>
</ul>
</li>
<li>2023 – .NET 8 – <a href="https://webassembly.org/">Wasm</a> support and AVX-512
<ul>
<li>Introduces <code>PackedSimd</code> and <code>WasmBase</code> for <code>Wasm</code></li>
<li>Introduces <code>Vector512&lt;T&gt;</code></li>
<li>Introduces <code>Avx512F</code>, <code>Avx512BW</code>, <code>Avx512CD</code>, <code>Avx512DQ</code>, and <code>Avx512Vbmi</code> for <code>x86</code>/<code>x64</code></li>
<li>See also: The rest of this blog post</li>
</ul>
</li>
</ul>
<p>Because of this work, with every release .NET libraries and applications gain more power to take advantage of the underlying hardware. In this post I’ll cover in depth what we introduced in .NET 8 and the type of functionality it enables.</p>
<h2 id="webassembly-support">WebAssembly Support</h2>
<p><a href="https://devblogs.microsoft.com/dotnet/extending-web-assembly-to-the-cloud/">WebAssembly</a>, or Wasm for short, is essentially code that runs in your browser and which allows a much higher performance profile than typical interpreted scripting support. As a platform, Wasm has started providing underlying SIMD (Single Instruction, Multiple Data) support so that core algorithms can be accelerated and .NET has correspondingly opted to expose support for this functionality via hardware intrinsics.</p>
<p>This support is very similar to the foundations that other platforms provide and so we won’t go into it in significant detail. Rather, you can simply expect that your existing cross platform algorithms using <code>Vector128&lt;T&gt;</code> will implicitly light up where supported. If you want to take more direct advantage of functionality that is unique to Wasm, then you can explicitly use the APIs exposed by the <code>PackedSimd</code> and <code>WasmBase</code> classes in the <code>System.Runtime.Intrinsics.Wasm</code> namespace.</p>
<h2 id="avx-512-support">AVX-512 Support</h2>
<p>AVX-512 is a new feature set provided for x86 and x64 computers. It brings along with it a large set of new instructions and hardware functionality that wasn’t previously available including support for 16 additional SIMD registers, dedicated masking, and operating on 512-bits of data at a time. Access to this functionality requires a relatively new processor, namely it requires Skylake-X or newer from Intel and Zen4 or newer from AMD. Because of this, the number of users that can take advantage of this new functionality is smaller, but the improvements it can bring to that hardware are still significant and make it worthwhile to support for data heavy workloads. Additionally, the JIT will opportunistically utilize these instructions for existing SIMD code where it determines benefit to exist. Some examples include:</p>
<ul>
<li>using <code>vpternlog</code> instead of <code>and, andn, or</code> when a bitwise conditional select is done (<code>Vector128.ConditionalSelect</code>)</li>
<li>using the EVEX encoding to fit more operations into less bytes of code, such as for embedded broadcasts (<code>x + Vector128.Create(5)</code>)</li>
<li>using newer instructions where support now exists with AVX-512, such as for full-width shuffling and many <code>long</code>/<code>ulong</code> (<code>Int64</code>/<code>UInt64</code>) operations</li>
<li>there were other improvements, that are not listed here, as well and you can expect even more to be added over time
<ul>
<li>some cases such as <code>Vector&lt;T&gt;</code> allowing scaling to 512-bits were not completed in .NET 8</li>
</ul>
</li>
</ul>
<p>In order to support the new vector size of 512-bits, .NET introduced the <code>Vector512&lt;T&gt;</code> type. This exposes the same general API surface as the other fixed-sized vector types such as <code>Vector256&lt;T&gt;</code>. It likewise continues exposing the <code>Vector512.IsHardwareAccelerated</code> property that allows you to determine whether the general logic should be accelerated in the hardware or if it will end up emulating the behavior via a software fallback.</p>
<p>Vector512 is accelerated with AVX-512 by default on Ice Lake and newer hardware (and thus <code>Vector512.IsHardwareAccelerated</code> reports <code>true</code>), where AVX-512 instructions do not cause the CPU to significantly downclock; where-as utilizing AVX-512 instructions can cause more significant downclocking on Skylake-X, Cascade Lake, and Cooper Lake based hardware (see also <code>2.5.3 Skylake Server Power Management</code> in the <code>Intel® 64 and IA-32 Architectures Optimization Reference Manual: Volume 1</code>). While this is ultimately beneficial for large workloads, it can negatively impact other smaller workloads and as such we default to reporting <code>false</code> for <code>Vector512.IsHardwareAccelerated</code> on these platforms. <code>Avx512F.IsSupported</code> will still report true and the underlying implementation of <code>Vector512</code> will still utilize <code>AVX-512</code> instructions if called directly. This allows workloads to take advantage of the functionality where they know it to be explicitly beneficial without accidentally causing a negative impact to others.</p>
<h3 id="special-thanks">Special Thanks</h3>
<p>This functionality was made possible via significant contributions by our friends at Intel. The .NET team and Intel have collaborated many times over the years and this continued by us working together on the overall design and implementation, allowing the AVX-512 support to land in .NET 8.</p>
<p>There was also a great deal of input and validation from the .NET community that helped achieve success and make the release all the better.</p>
<p>If you would like to contribute or provide input, please join us in the <a href="https://github.com/dotnet/runtime">dotnet/runtime</a> repos on GitHub, and tune into API Review on the <a href="https://www.youtube.com/@NETFoundation/streams">.NET Foundation YouTube</a> channel by following our <a href="https://apireview.net/schedule">schedule</a> where you can see us discuss new additions to the .NET Libraries and even provide your own input via the chat channel.</p>
<h3 id="its-not-just-512-bits">It’s not just 512-bits?</h3>
<p>Contrary to the name, AVX-512 is not just about 512-bit support. The additional registers, masking support, embedded rounding or broadcast support, and new instructions also all exist for 128-bit and 256-bit vectors. This means that your existing workloads can implicitly get better and you can take explicit advantage of newer functionality where such implicit light up is not possible.</p>
<p>When SSE was first introduced in 1999 on the Intel Pentium III, it provided 8 registers each 128-bits in length. These registers were known as <code>xmm0</code> through <code>xmm7</code>. When the x64 platform was later introduced in 2003 on the AMD Athlon 64, it then provided 8 additional registers that were accessible to 64-bit code. These registers were named <code>xmm8</code> through <code>xmm15</code>. This initial support used a simple encoding scheme that worked in a very similar manner to the general purpose instructions and only allowed for 2 registers to be specified. For something like addition which requires 2 inputs, this meant that one of the registers acted as both an input and an output. This meant that if your input and output needed to be different, you needed 2 instructions to complete the operation. Effectively, your <code>z = x + y</code> would become <code>z = x; z += y</code>. At the high level these behave the same, but at the low level there is 2 rather than 1 step to make it happen.</p>
<p>This was then further expanded in 2011 when Intel introduced AVX on the Sandy Bridge based processors by expanding the support to 256-bits. These newer registers were named <code>ymm0</code> through <code>ymm15</code>, with only registers up to <code>ymm7</code> being accessible to 32-bit code. This also introduced a new encoding known as <code>VEX</code> (Vector Extensions) which allowed for 3 registers to be encoded. This meant that you could encode <code>z = x + y</code> directly and didn’t have to break it into 2 separate steps.</p>
<p>AVX-512 was then introduced by Intel in 2017 with the Skylake-X based processors. This expanded that support to 512-bits and named the registers <code>zmm0</code> through <code>zmm15</code>. It also introduced 16 new registers, aptly named <code>zmm16</code> through <code>zmm31</code> and which also have <code>xmm16-xmm31</code> and <code>ymm16-ymm31</code> variants. As with the previous cases, only registers up to <code>zmm7</code> are accessible to 32-bit code. It introduced 8 new registers, named <code>k0</code> through <code>k7</code>, designed to support “masking” and another new encoding named <code>EVEX</code> (Enhanced Vector Extensions) which allows all this new information to be expressed. The EVEX encoding also has other features that allow more common information and operations to be expressed in a more compact fashion. This can help decrease code size while improving performance.</p>
<h3 id="what-new-instructions-exist">What new instructions exist?</h3>
<p>There is a lot of new functionality, far too much to cover everything in this blog post. But some of the most notable new instructions provide things like:</p>
<ul>
<li>Support for doing operations like <code>Abs</code>, <code>Max</code>, <code>Min</code>, and shifting on 64-bit integers – previously this functionality had to be emulated using multiple instructions</li>
<li>Support for doing conversions between unsigned integers and floating-point types</li>
<li>Support for working with floating-point edge cases</li>
<li>Support for fully rearranging the elements in a vector or multiple vectors</li>
<li>Support for doing 2 bitwise operations in a single instruction</li>
</ul>
<p>The 64-bit integer support is notable because it means working with 64-bit data doesn’t need to use a slower or alternative code sequence to support the same functionality. It makes it much easier to just write your code and expect it to behave the same regardless of the underlying data type you’re working with.</p>
<p>The floating-point to unsigned integer conversion support is notable for similar reasons. Converting from <code>double</code> to <code>long</code> required a single instruction, but converting from <code>double</code> to <code>ulong</code> required many instructions. With AVX-512 this becomes a single instruction and allows users to get the expected performance when working with unsigned data. This can be common in various image processing or Machine Learning scenarios.</p>
<p>The expanded support for floating-point data is one of my favorite features of AVX-512. Some examples include the ability to extract the unbiased exponent (<code>Avx512F.GetExponent</code>) or the normalized mantissa (<code>Avx512F.GetMantissa</code>), to round a floating-point value to a specific number of fraction bits (<code>Avx512F.RoundScale</code>), to multiply a value by 2^x (<code>Avx512F.Scale</code>, known in C as <code>scalebn</code>), to perform <code>Min</code>, <code>Max</code>, <code>MinMagnitude</code>, and <code>MaxMagnitude</code> with correct handling of <code>+0</code> and <code>-0</code> (<code>Avx512DQ.Range</code>), and even to perform reductions which are useful when handling large values for trigonometric functions like <code>Sin</code> or <code>Cos</code> (<code>Avx512DQ.Reduce</code>).</p>
<p>However, one of my personal favorites is an instruction named <code>vfixupimm</code> (<code>Avx512F.Fixup</code>). At a high level, this instruction lets you detect a number of input edge cases and “fixup” the output to be one of the common outputs and to do this per element. This can massively improve the performance of some algorithms and greatly reduces the amount of handling required. The way it works is it takes 4 inputs known as <code>left</code>, <code>right</code>, <code>table</code>, and <code>control</code>. It first does a classification of the floating-point value in <code>right</code> and determines if it is <code>QNaN</code> (0), <code>SNaN</code> (1), <code>+/-0</code> (2), <code>+1</code> (3), <code>-Infinity</code> (4), <code>+Infinity</code> (5), <code>Negative</code> (6), or <code>Positive</code> (7). It then uses that to read <code>4</code> bits from <code>table</code> (<code>QNaN</code> being <code>0</code>, reads bits <code>0..3</code>; <code>Negative</code> being <code>6</code> reads bits <code>24..27</code>). The value of those 4 bits in <code>table</code> then determines what the result will be. The possible results (per element) are:</p>
<table>
<thead>
<tr>
<th>Bit Pattern</th>
<th>Definition</th>
</tr>
</thead>
<tbody>
<tr>
<td>0b0000</td>
<td>left[i]</td>
</tr>
<tr>
<td>0b0001</td>
<td>right[i]</td>
</tr>
<tr>
<td>0b0010</td>
<td>QNaN(right[i])</td>
</tr>
<tr>
<td>0b0011</td>
<td>QNaN</td>
</tr>
<tr>
<td>0b0100</td>
<td>-Infinity</td>
</tr>
<tr>
<td>0b0101</td>
<td>+Infinity</td>
</tr>
<tr>
<td>0b0110</td>
<td>IsNegative(right[i]) ? -Infinity : +Infinity</td>
</tr>
<tr>
<td>0b0111</td>
<td>-0.0</td>
</tr>
<tr>
<td>0b1000</td>
<td>+0.0</td>
</tr>
<tr>
<td>0b1001</td>
<td>-1.0</td>
</tr>
<tr>
<td>0b1010</td>
<td>+1.0</td>
</tr>
<tr>
<td>0b1011</td>
<td>+0.5</td>
</tr>
<tr>
<td>0b1100</td>
<td>+90.0</td>
</tr>
<tr>
<td>0b1101</td>
<td>PI / 2</td>
</tr>
<tr>
<td>0b1110</td>
<td>MaxValue</td>
</tr>
<tr>
<td>0b1111</td>
<td>MinValue</td>
</tr>
</tbody>
</table>
<p>With SSE there was some support for rearranging the data in a vector. Say, for example, you had <code>0, 1, 2, 3</code> and you wanted it ordered <code>3, 1, 2, 0</code>. With the introduction of AVX and the expansion to 256-bits, this support was likewise expanded. However, due to how the instructions operated you’d actually do the same 128-bit operation twice. This made it simple to expand existing algorithms to 256-bits since you effectively are just doing the same thing twice. However, it made working with other algorithms more difficult when you actually needed to consider the entire vector cohesively. There were some instructions that let you rearrange the data across the entire 256-bit vector, but they were often limited either in how the data could be rearranged or in the types they supported (full shuffle of byte elements is a notable example of missing support). AVX-512 has many of the same considerations for its expanded 512-bit support. However, it also introduces new instructions that fill the gap and now let you fully rearrange the elements for any size of element.</p>
<p>Finally, one of my other personal favorites is an instruction named <code>vpternlog</code> (<code>Avx512F.TernaryLogic</code>). This instruction lets you take any 2 bitwise operations and combine them, so they can be executed in a single instruction. For example, you can do <code>(a &amp; b) | c</code>. The way it works is that it takes 4 inputs, <code>a</code>, <code>b</code>, <code>c</code>, and <code>control</code>. You then have 3 keys to remember: <code>A: 0xF0</code>, <code>B: 0xCC</code>, <code>C: 0xAA</code>. In order to represent the operation desired, you simply build the <code>control</code> by performing that operation on those keys. So, if you wanted to simply return <code>a</code>, you’d use <code>0xF0</code>. If you wanted to do <code>a &amp; b</code>, you’d use <code>(byte)(0xF0 &amp; 0xCC)</code>. If you wanted to do <code>(a &amp; b) | c</code>, then it is <code>(byte)((0xF0 &amp; 0xCC) | 0xAA</code>. There are 256 different operations possible in total, with the basic building blocks being those keys and the following bitwise operations:</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Definition</th>
</tr>
</thead>
<tbody>
<tr>
<td>not</td>
<td>~x</td>
</tr>
<tr>
<td>and</td>
<td>x &amp; y</td>
</tr>
<tr>
<td>nand</td>
<td>~x &amp; y</td>
</tr>
<tr>
<td>or</td>
<td>x</td>
<td>y</td>
</tr>
<tr>
<td>nor</td>
<td>~x</td>
<td>y</td>
</tr>
<tr>
<td>xor</td>
<td>x ^ y</td>
</tr>
<tr>
<td>xnor</td>
<td>~x ^ y</td>
</tr>
</tbody>
</table>
<p>There are then some special operations that are also supported given the above basic operations and which can expand even further.</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Definition</th>
</tr>
</thead>
<tbody>
<tr>
<td>false</td>
<td>Bit pattern of 0x00</td>
</tr>
<tr>
<td>true</td>
<td>Bit pattern of 0xFF</td>
</tr>
<tr>
<td>major</td>
<td>Returns 0 if two or more input bits are 0, returns 1 if two or more input bits are 1</td>
</tr>
<tr>
<td>minor</td>
<td>Returns 0 if two or more input bits are 1, returns 1 if two or more input bits are 0</td>
</tr>
<tr>
<td>conditional select</td>
<td>Logically <code>(x &amp; y) | (~x &amp; z)</code>, which works since it is <code>(x and y) or (x nand y)</code></td>
</tr>
</tbody>
</table>
<p>In .NET 8 we didn’t complete the support to implicitly recognize and fold these patterns to emit <code>vpternlog</code>. We expect that to debut in .NET 9.</p>
<h3 id="what-is-masking-support">What is masking support?</h3>
<p>At the simplest level, writing vectorized code involves using SIMD to do the same basic operation on <code>Count</code> different elements of type <code>T</code> in a single instruction. This works very nicely when the same operation needs to be done to all data. However, not all data is necessarily uniform and sometimes you need to handle particular inputs differently. For example, you may want to do a different operation for positive vs negative numbers. You may need to return a different result if the user has passed in <code>NaN</code>, and so on. When writing regular code, you would normally handle this with a branch and this works very nicely. When writing vectorized code, however, such branches break the ability to use SIMD instructions since you have to handle each element independently. .NET takes advantage of this in various locations, including the new <code>TensorPrimitives</code> APIs where it allows us to handle trailing data that would otherwise not fit into a full vector.</p>
<p>The typical solution for this is to write “branch-free” code. One of the simplest ways to do this is to compute both answers and then use bitwise operations to pick the correct answer. You can think of this a lot like a ternary condition <code>cond ? result1 : result2</code>. In order to support this in SIMD, there exists an API named <code>ConditionalSelect</code> which takes a mask and both results. The mask is also a vector, but its values are typically either <code>AllBitsSet</code> or <code>Zero</code>. When you have this pattern, then the implementation of <code>ConditionalSelect</code> is effectively <code>(cond &amp; result1) | (~cond &amp; result2)</code>. What this breaks down to doing is taking bits from <code>result1</code> where the corresponding bit in <code>cond</code> is <code>1</code> and otherwise taking the corresponding bit from <code>result2</code> (when the bit in <code>cond</code> is <code>0</code>). So if you wanted to convert all negative values to <code>0</code>, you would have something like <code>(x &lt; 0) ? 0 : x</code> for regular code and <code>Vector128.ConditionalSelect(Vector128.LessThan(x, Vector128.Zero), Vector128.Zero, x)</code> for vectorized code. It’s a bit more verbose, but can also provide significant performance improvement.</p>
<p>When hardware first started having SIMD support, you would have to support this masking very literally by doing 3 instructions: <code>and, nand, or</code>. As newer hardware came out, more optimized versions were added that allowed you to do this in a single instruction, such as <code>blendv</code> on x86/x64 and <code>bsl</code> on Arm64. AVX-512 then took this a step further by introducing dedicated hardware support for expressing masks and tracking them in registers (the previously mentioned <code>k0-k7</code>). It then provided additional support for allowing this masking to be done as part of almost any other operation. So rather than having to specify <code>vcmpltps; vblendvps; vaddps</code> (compare, mask, then add), you could instead encode that mask directly as part of the addition (and thus emit <code>vcmpltps; vaddps</code> instead). This allows the hardware to represent more operations in less space, improving code density, and to better take advantage of the intended behavior.</p>
<p>Notably we do not directly expose a 1-to-1 concept with the underlying hardware for masking here. Rather, the JIT continues taking and returning a regular vector for comparison results and does the relevant pattern recognition and subequent opportunistic lightup of masking features based on this. This allows the exposed API surface to be significantly smaller (over 3000 fewer APIs), for existing code to largely “just work” and take advantage of the newer hardware support without explicit action, and for users wanting to support AVX-512 to not have to learn new concepts or write code in a new way.</p>
<h3 id="what-about-examples-of-using-avx-512-in-practice">What about examples of using AVX-512 in practice?</h3>
<p>AVX-512 can be used to accelerate all of the same scenarios as SSE or AVX based scenarios. An easy way to identify where the .NET Libraries are already using this acceleration is to search for the places we’re calling <code>Vector512.IsHardwareAccelerated</code>, this can be done using <a href="https://source.dot.net/#System.Private.CoreLib/src/libraries/System.Private.CoreLib/src/System/Runtime/Intrinsics/Vector512.cs,576d90eecb8bc9d4,references">source.dot.net</a>.</p>
<p>We’ve accelerated cases such as:</p>
<ul>
<li>System.Collections.BitArray – <a href="https://source.dot.net/#System.Collections/System/Collections/BitArray.cs,137">creation</a>, <a href="https://source.dot.net/#System.Collections/System/Collections/BitArray.cs,137">bitwise and</a>, <a href="https://source.dot.net/#System.Collections/System/Collections/BitArray.cs,137">bitwise or</a>, <a href="https://source.dot.net/#System.Collections/System/Collections/BitArray.cs,137">bitwise xor</a>, <a href="https://source.dot.net/#System.Collections/System/Collections/BitArray.cs,137">bitwise not</a></li>
<li>System.Linq.Enumerable – <a href="https://source.dot.net/#System.Linq/System/Linq/MaxMin.cs,70">Max and Min</a></li>
<li>System.Buffers.Text.Base64 – <a href="https://source.dot.net/#System.Private.CoreLib/src/libraries/System.Private.CoreLib/src/System/Buffers/Text/Base64Decoder.cs,72">Decoding</a>, <a href="https://source.dot.net/#System.Private.CoreLib/src/libraries/System.Private.CoreLib/src/System/Buffers/Text/Base64Encoder.cs,71">Encoding</a></li>
<li>System.String – <a href="https://source.dot.net/#System.Private.CoreLib/src/libraries/System.Private.CoreLib/src/System/Globalization/Ordinal.cs,166">Equals, IgnoreCase</a></li>
<li>System.Span – <a href="https://source.dot.net/#System.Private.CoreLib/src/libraries/System.Private.CoreLib/src/System/SpanHelpers.Packed.cs,117">IndexOf</a>, <a href="https://source.dot.net/#System.Private.CoreLib/src/libraries/System.Private.CoreLib/src/System/SpanHelpers.Packed.cs,117">IndexOfAny</a>, <a href="https://source.dot.net/#System.Private.CoreLib/src/libraries/System.Private.CoreLib/src/System/SpanHelpers.Packed.cs,117">IndexOfAnyInRange</a>, <a href="https://source.dot.net/#System.Private.CoreLib/src/libraries/System.Private.CoreLib/src/System/SpanHelpers.Byte.cs,66">SequenceEqual</a>, <a href="https://source.dot.net/#System.Private.CoreLib/src/libraries/System.Private.CoreLib/src/System/SpanHelpers.Byte.cs,66">Reverse</a>, <a href="https://source.dot.net/#System.Private.CoreLib/src/libraries/System.Private.CoreLib/src/System/SpanHelpers.Packed.cs,117">Contains</a>, etc</li>
</ul>
<p>There are other examples throughout the .NET libraries and general .NET ecosystem, far too many to list and cover. These include, but are not limited to, scenarios such as color conversions, image processing, machine learning, text transcoding, JSON parsing, software rendering, ray tracing, game acceleration, and much more.</p>
<h3 id="whats-next">What’s next?</h3>
<p>We plan to continue to improve the hardware intrinsics support in .NET when and where it makes sense. Please note the following items are forward thinking and speculative. The list is not complete and we provide no guarantees any of these features will land or when they will ship if they do.</p>
<p>Some of the items on our longer term roadmap include the following:</p>
<ul>
<li><code>SVE</code> and SVE2 for Arm64</li>
<li><code>AVX10</code> for x86/x64</li>
<li>Allowing <code>Vector&lt;T&gt;</code> to implicitly expand to 512-bits</li>
<li>An <code>ISimdVector&lt;TSelf, T&gt;</code> interface to allow better reuse of SIMD logic</li>
<li>An analyzer to help encourage users to use the cross-platform APIs where the semantics are identical (use <code>x + y</code> instead of <code>Sse.Add(x, y)</code>)</li>
<li>An analyzer to recognize patterns that may have more optimal alternatives (do <code>value + value</code> instead of <code>value * 2</code> or <code>Sse.UnpackHigh(value, value)</code> instead of <code>Sse.Shuffle(value, value, 0b11_11_10_10)</code></li>
<li>Additional explicit usage of hardware intrinsics in various .NET APIs</li>
<li>Additional cross-platform APIs to help abstract common operation
<ul>
<li>getting the index of the first/last match in a mask</li>
<li>getting the number of matches in a mask</li>
<li>determining if any matches exist</li>
<li>allowing non-deterministic behavior for cases like <code>Shuffle</code> or <code>ConditionalSelect</code></li>
<li>these APIs have a well-defined behavior on all platforms today, such as <code>Shuffle</code> treating any out of range index as zeroing the destination element</li>
<li>the new APIs, such as <code>ShuffleUnsafe</code>, would instead allow different behavior for out of range indices</li>
<li>for such a scenario, Arm64 would have the same behavior, while x64 only has the same behavior if the most-significant bit is set</li>
</ul>
</li>
<li>Additional pattern recognition for cases like
<ul>
<li>embedded masking (AVX512, AVX10, SVE/SVE2)</li>
<li>combined bitwise-operations (<code>vpternlog</code> on AVX512)</li>
<li>limited JIT time constant folding opportunities</li>
</ul>
</li>
</ul>
<p>If you’re looking to use hardware intrinsics in .NET, we encourage you to try out the APIs available in the <a href="https://learn.microsoft.com/dotnet/api/system.runtime.intrinsics?view=net-8.0">System.Runtime.Intrinsics namespace</a>, log <a href="https://github.com/dotnet/runtime/issues/new?assignees=&amp;labels=api-suggestion&amp;projects=&amp;template=02_api_proposal.yml&amp;title=%5BAPI+Proposal%5D%3A+">API suggestions</a> for functionality you feel is missing or could be improved, and to engage in our preview releases to try out the functionality before it ships so you can help make each release better than the last!</p>

        

        
		
        
	</div><!-- .entry-content -->

</div></div>
  </body>
</html>
