<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://voidcomputing.hu/blog/worse-better-prettier/">Original</a>
    <h1>More AR Glasses USB Protocols: The Worse, the Better and the Prettier</h1>
    
    <div id="readability-page-1" class="page"><div>
  <article>
    <header>
        
        <time datetime="2023-10-10T21:36:10+02:00"> Published on 2023.10.10 </time>
    </header>
        <img src="https://voidcomputing.hu/blog/worse-better-prettier/thumbnail.jpg"/>
    <p>We&#39;ve found a drop-in replacement for the Nreal Light, called
the Grawoow G530 (or Metavision M53, and who knows how many other
names), so we finally have 3 more protocols to write about in this blog.</p>



<h2 id="background"><a href="#background">Background</a></h2>
<p>The <a href="https://voidcomputing.hu/blog/good-bad-ugly">previous blog post</a>
in the topic has become somewhat of a reference in
the community, and has actually driven some sales for the company, so it
seemed like a good idea to write about our more recent findings, and share
it with anyone interested.</p>
<p>The post itself will probably be a bit dry for the casual reader.
Sorry about that.</p>
<h2 id="the-worse-grawoow-g530"><a href="#the-worse-grawoow-g530">The Worse: Grawoow G530</a></h2>
<p><img alt="G530 on a dog" src="https://voidcomputing.hu/blog/worse-better-prettier/zserbo-g530.jpg"/></p>
<p>We started searching for a replacement for the <a href="https://voidcomputing.hu/blog/good-bad-ugly#the-ugly-nreal-light">XREAL Light</a>
from Day 1, because it is not supported or manufactured by XREAL anymore.
We needed glasses with stereo cams and active support.</p>
<p>Some months ago I got contacted on LinkedIn by a Chinese seller, and after a bit of talking,
we bought a test piece. It wasn&#39;t as easy as just going on a webshop (and I had to do all kinds of
import paperwork), but it was still smooth: send some mails, wire money, receive glasses.</p>
<p>I call it worse, because it is a tiny bit worse in every regard: it looks cheaper,
the plastic parts fit worse, and the protocol is missing some information that
is crucial for good support. The main thing it has going for it is that it&#39;s still
available from distributors.</p>
<p>The architecture is extremely similar to the XREAL Light, so much so that I&#39;m
only going to <a href="https://voidcomputing.hu/blog/good-bad-ugly/nreal-light-arch.png">link the draft architecture pic</a>.
Main components:</p>
<ul>
<li>All the standard DP-over-USB-C driving two micro OLED LCD display stuff on two USB 3 lanes</li>
<li>An USB 3 RGB CAM on the remaining two lanes</li>
<li>Stereo grayscale cams and IMU driven by an OV-580 (exactly the same as the Light, even
   the protocol... mostly)</li>
<li>Distance sensor at the forehead</li>
<li>Four physical buttons: brightness up/down, and volume up/down</li>
<li>Judging by the USB device descriptors, the MCU and audio functionalities are
   done by the same chip.</li>
</ul>
<p>Gotta love Chinese copying culture. By the way, the glasses seem to be widely
white-labeled; the Metavision M53 seem to be the same hardware. Even the
firmware and SDK say G530 and not M53.</p>
<h3 id="usb-interfaces"><a href="#usb-interfaces">USB interfaces</a></h3>
<p>The device comes up as two hubs (one USB 3 and one USB 2) and 5 devices:</p>
<ul>
<li>Realtek Semiconductor Corp. RGB Camera</li>
<li>VID: <code>0bda</code>, PID: <code>5880</code></li>
<li>Bog-standard USB3 camera, capable of full HD at some pretty high frame rates</li>
<li>CVT Electronics.Co.,Ltd G530</li>
<li>VID: <code>1ff7</code>, PID: <code>0ff4</code></li>
<li>Interfaces<ul>
<li>0: HID. This is the glasses control (MCU) endpoint.</li>
<li>1,2,3: Audio</li>
</ul>
</li>
<li>OmniVision Technologies, Inc. USB Camera-OV580</li>
<li>VID: <code>05a9</code> PID: <code>0f87</code></li>
<li>The OV580 with an <a href="https://voidcomputing.hu/blog/android-uvc">UVC (stereo cam)</a> and a HID (IMU) interface</li>
</ul>
<h3 id="mcu-protocol"><a href="#mcu-protocol">MCU Protocol</a></h3>
<p>The MCU control is predominantly through control packets, although there
is an interrupt endpoint for the forehead detector event.</p>
<p>The control protocol is always two control packets, one to send the command
and one to receive the result. The magic <code>libusb</code> parameters are:</p>
<div><pre><span></span><code><span>Send</span><span>:</span><span> </span>
<span>    </span><span>bmRequestType</span><span>:</span><span> </span><span>0x21</span><span> </span><span>(</span><span>CTRL_TYPE_CLASS</span><span>|</span><span>CTRL_RECIPIENT_INTERFACE</span><span>|</span><span>ENDPOINT_OUT</span><span>)</span>
<span>    </span><span>bRequest</span><span>:</span><span>      </span><span>9</span>
<span>    </span><span>wValue</span><span>:</span><span>        </span><span>0x201</span>
<span>    </span><span>wIndex</span><span>:</span><span>        </span><span>0</span>

<span>Receive</span><span>:</span><span> </span>
<span>    </span><span>bmRequestType</span><span>:</span><span> </span><span>0xa1</span><span> </span><span>(</span><span>CTRL_TYPE_CLASS</span><span>|</span><span>CTRL_RECIPIENT_INTERFACE</span><span>|</span><span>ENDPOINT_IN</span><span>)</span>
<span>    </span><span>bRequest</span><span>:</span><span>      </span><span>1</span>
<span>    </span><span>wValue</span><span>:</span><span>        </span><span>0x102</span>
<span>    </span><span>wIndex</span><span>:</span><span>        </span><span>0</span>
</code></pre></div>

<p>Note that these are the standard <code>SetReport</code> and <code>GetReport</code> HID requests (see 
Section 7.2 in the <a href="https://www.usb.org/sites/default/files/hid1_11.pdf">HID Device Class definition</a>),
so these might be available with some standard report-based HID APIs.</p>
<p>The packet structure is as follows:</p>
<ul>
<li>Header: 2 bytes, fixed <code>0xaa, 0xbb</code></li>
<li>Command: 2 bytes, big endian</li>
<li>Additional data size: 2 bytes, big endian</li>
<li>Additional data: variable, can be 0 bytes</li>
<li>Checksum: sum of all previous bytes, excluding the <code>0xaa</code>, <code>0xbb</code> part.</li>
</ul>
<p>An example packets:</p>
<ul>
<li>Get serial number:</li>
<li>Response:</li>
</ul>
<p>Commands (data is empty for &#34;Get&#34; commands here):</p>
<div>
<table>
<thead>
<tr>
<th>Command</th>
<th>ID</th>
<th>Data</th>
</tr>
</thead>
<tbody>
<tr>
<td>Get firmware version</td>
<td>0xffe1</td>
<td>8 bytes, unknown format</td>
</tr>
<tr>
<td>Get serial number</td>
<td>0x8005</td>
<td>The serial number as UTF-8 string</td>
</tr>
<tr>
<td>Set serial number</td>
<td>0x8004</td>
<td>Same as above</td>
</tr>
<tr>
<td>Get display mode</td>
<td>0x8007</td>
<td>Display mode as a single byte: 0 is mirrored, any other nonzero is SBS 60Hz</td>
</tr>
<tr>
<td>Set display mode</td>
<td>0x8008</td>
<td>Same as above</td>
</tr>
<tr>
<td>Get display brightness</td>
<td>0x801d</td>
<td>Brightness as a single byte, 0-4</td>
</tr>
<tr>
<td>Set display brightness</td>
<td>0x801e</td>
<td>Same as above</td>
</tr>
</tbody>
</table>
</div>
<p>Some commands I haven&#39;t listed (or tested really), but can be easily obtained from
the SDK libraries:</p>
<ul>
<li>Sensor and camera enable/disable: All sensors and cameras are enabled and streaming
by default, so no need to touch those</li>
<li>Display settings, like brightness contrast per channel, and all kinds of low-level DP stuff</li>
<li>Audio volume</li>
<li>Firmware update</li>
<li>Sketchy stuff like getting and setting a HDCP key</li>
</ul>
<p>You can also continuously read the Interrupt endpoint on endpoint number <code>0x85</code>,
where you should get key and distance sensor events (in the same <code>0xaa 0xbb</code> format
as the control packets), but I only ever got the &#34;glasses taken off&#34; event,
and it was not worth implementing.</p>
<h3 id="getting-the-calibration-data"><a href="#getting-the-calibration-data">Getting the calibration data</a></h3>
<p>As opposed to the XREAL protos, where you can get the calibration JSON
from the OV580, you actually have to do it over the above MCU protocol, using
command IDs <code>0x8009</code> (metadata) and <code>0x800a</code> (actual calibration data).</p>
<p>The metadata response looks something like this:</p>
<ul>
<li>2 bytes header, which should be 0</li>
<li>2 bytes is the &#34;max packet size&#34; (big endian). We&#39;ll be doing 256 byte control packets anyway, but good to know I guess?</li>
<li>4 bytes data size (big endian)</li>
<li>2 more unknown bytes.</li>
</ul>
<p>The &#34;get calibration data&#34; packet needs additional data: a 0 byte, and then
4 byte offset, in big endian. So it&#39;s <code>[0, 0, 0, 0, 0]</code> for the first packet,
<code>[0, 0, 0, 0, 241]</code> for the next, and so on.</p>
<p>Response is the same 5 bytes followed by a 0 byte (so 6 in total), and then
the actual data. If you request more data than the calibration file size,
the packet will be smaller, or even empty. So requesting the metadata is kind
of useless, you can just request data until you get an empty response.</p>
<h3 id="imu-protocol"><a href="#imu-protocol">IMU protocol</a></h3>
<p>Fortunately this is another glasses that gives you an IMU stream out of the box,
and you don&#39;t need to fight for it. All you have to do is continuously read <code>0x80</code> chunks
on the HID interrupt endpoint <code>0x89</code> of the OV580 device.</p>
<p>It is a large packet, and the SDK only parses the raw accelerometer, gyro and temperature
data. A lot of the packets seem to be fixed bytes, and the only thing that changes
(other than what we already know) are two sequence numbers. Yeah, sequence numbers, not
even proper timestamps.</p>
<p>All data are transferred as little endian signed ints. The conversion factors
are the same as in the Invensense MPU6050 docs.</p>
<div>
<table>
<thead>
<tr>
<th>Data</th>
<th>Offset</th>
<th>Size</th>
<th>Conversion</th>
</tr>
</thead>
<tbody>
<tr>
<td>Acceleration</td>
<td>0x58</td>
<td>3*4</td>
<td>Divide by 16384.0 and then convert <code>g</code>s to <code>m/s2</code></td>
</tr>
<tr>
<td>Gyroscope</td>
<td>0x3c</td>
<td>3*4</td>
<td>Divide by 16.4 and then convert <code>°/s</code> to <code>rad/s</code></td>
</tr>
<tr>
<td>Temperature</td>
<td>0x2a</td>
<td>2</td>
<td>Divide by 326.8, then add 25.0</td>
</tr>
</tbody>
</table>
</div>
<h2 id="the-better-rokid-max"><a href="#the-better-rokid-max">The Better: Rokid Max</a></h2>
<p><img alt="Rokid Max on a dog" src="https://voidcomputing.hu/blog/worse-better-prettier/zserbo-rokid-max.jpg"/></p>
<p>The Rokid Max is a logical evolution of the <a href="https://voidcomputing.hu/blog/good-bad-ugly#the-good-rokid-air">Rokid Air</a>.
Better design, better fit, better protocol, and the DisplayPort part is apparently 2ms quicker,
reducing motion-to-photon latency. Everything else is pretty much the same,
so much so that most of it can be handled by <a href="https://github.com/badicsalex/ar-drivers-rs/blob/db65af113de81e23384a326fc2afecb23594bc30/src/rokid.rs#L28">the same code</a>.
They even kept the gimmicky focal adjustment knobs (even though
it&#39;s still unusable for people who have <a href="https://voidcomputing.hu/blog/stereo-vision#side-note-astigmatism">astigmatism</a>)</p>
<h3 id="protocol"><a href="#protocol">Protocol</a></h3>
<p>The main new protocol element is &#34;<code>sensor data marker = 17</code>&#34; in the IMU data packets, which combines
all previous packets into one. Its structure looks like this:</p>
<div>
<table>
<thead>
<tr>
<th>Index</th>
<th>Bytes</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x00</td>
<td>1</td>
<td>Sensor data marker (17)</td>
</tr>
<tr>
<td>0x01</td>
<td>8</td>
<td>Timestamp (little endian)</td>
</tr>
<tr>
<td>0x09</td>
<td>3x4</td>
<td>Gyroscope x, y and z reading in <code>f32</code> format</td>
</tr>
<tr>
<td>0x15</td>
<td>3x4</td>
<td>Accelerometer x, y and z reading in <code>f32</code> format</td>
</tr>
<tr>
<td>0x21</td>
<td>3x4</td>
<td>Magnetometer x, y and z reading in <code>f32</code> format</td>
</tr>
<tr>
<td>0x2d</td>
<td>1</td>
<td>Physical key statuses (bitfield)</td>
</tr>
<tr>
<td>0x2e</td>
<td>1</td>
<td>Proximity sensor status (near=0, far=1)</td>
</tr>
<tr>
<td>0x2f</td>
<td>1</td>
<td>?</td>
</tr>
<tr>
<td>0x30</td>
<td>8</td>
<td>Timestamp of last VSYNC (little endian)</td>
</tr>
<tr>
<td>0x38</td>
<td>3</td>
<td>???</td>
</tr>
<tr>
<td>0x3b</td>
<td>1</td>
<td>Display brightness</td>
</tr>
<tr>
<td>0x3c</td>
<td>1</td>
<td>Volume</td>
</tr>
<tr>
<td>0x3d</td>
<td>3</td>
<td>???</td>
</tr>
</tbody>
</table>
</div>
<h3 id="display-modes"><a href="#display-modes">Display modes</a></h3>
<p>The Max added a bunch of new display modes:</p>
<table>
<thead>
<tr>
<th>Mode</th>
<th>SBS</th>
<th>Resolution</th>
<th>Refresh rate</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td></td>
<td>1920x1080</td>
<td>60Hz</td>
</tr>
<tr>
<td>1</td>
<td>Yes</td>
<td>3840x1080</td>
<td>60Hz</td>
</tr>
<tr>
<td>2</td>
<td>Yes*</td>
<td>1920x1080</td>
<td>60Hz</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>1920x1080</td>
<td>120Hz</td>
</tr>
<tr>
<td>4</td>
<td>Yes</td>
<td>3840x1200</td>
<td>90Hz</td>
</tr>
<tr>
<td>5</td>
<td>Yes</td>
<td>3840x1200</td>
<td>60Hz</td>
</tr>
</tbody>
</table>
<p>*: This is a &#34;half SBS&#34; mode, meaning that it splits the regular HD
image in half, and then stretches each half horizontally over each of
the glasses.</p>
<p>Modes above 6 are equivalent to mode 3.</p>
<h2 id="the-prettier-xreal-air"><a href="#the-prettier-xreal-air">The Prettier: XREAL Air</a></h2>
<p><img alt="XREAL Air on a dog" src="https://voidcomputing.hu/blog/worse-better-prettier/zserbo-nreal-air.jpg"/></p>
<p>The XREAL Air is <em>not</em> an evolution of the Light, it is much more
like the Rokid Max, but with a way better design. And I mean a lot better,
the thing actually looks like regular (albeit a bit big) sunglasses.
It is the first AR glasses that passes the &#34;Tram #4 test&#34;: I could wear it <a href="https://voidcomputing.hu/blog/worse-better-prettier/4es.jpg">on Tram #4</a>
and people wouldn&#39;t really notice. Maybe the cable hanging down.</p>
<p>Unfortunately it doesn&#39;t have a camera, so no inside-out 6DOF anymore.</p>
<p>On the other hand, it has the absolute lowest display delay out of all 6 we
described in these blog posts, so the image is rock stable even with dynamic
head movements.</p>
<p>The protocol is weird. They kept the separate USB interfaces for the MCU
and IMU + DSP pair. Both are different from the Light&#39;s.
Unfortunately this post was written way after I finished work on the Air,
so I&#39;m writing it based on the code of <a href="https://github.com/badicsalex/ar-drivers-rs">ar-drivers-rs</a>.</p>
<h3 id="mcu-protocol_1"><a href="#mcu-protocol_1">MCU protocol</a></h3>
<p>Packets are sent over regular HID <code>read()</code> and <code>write()</code> primitives, over interface 4
(endpoints <code>0x86</code> and <code>0x07</code>). Packet size is <code>0x40</code> both ways.</p>
<div>
<table>
<thead>
<tr>
<th>Index</th>
<th>Bytes</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x00</td>
<td>1</td>
<td>Header (0xfd)</td>
</tr>
<tr>
<td>0x01</td>
<td>4</td>
<td>Checksum (see below)</td>
</tr>
<tr>
<td>0x05</td>
<td>2</td>
<td>Length of additional data</td>
</tr>
<tr>
<td>0x07</td>
<td>4</td>
<td>Request ID (not checked by the MCU, only used to identify answers. Can be anything)</td>
</tr>
<tr>
<td>0x0b</td>
<td>4</td>
<td>Timestamp (also not checked, can be 0)</td>
</tr>
<tr>
<td>0x0f</td>
<td>2</td>
<td>Command ID</td>
</tr>
<tr>
<td>0x11</td>
<td>5</td>
<td>Zeros (probably)</td>
</tr>
<tr>
<td>0x16</td>
<td>n</td>
<td>Additional data</td>
</tr>
</tbody>
</table>
</div>
<p>Every int is Little Endian.</p>
<p>The checksum is <a href="http://www.mrob.com/pub/comp/crc-all.html#adler">CRC32(Adler)</a> like
the Light&#39;s. The checksum data is from byte 5 to the end of the packet (i.e. the length field + 17).</p>
<p>Again, there is no need to individually enable events or hardware, so we
only need the bare minimum commands:</p>
<div>
<table>
<thead>
<tr>
<th>Command</th>
<th>ID</th>
<th>Data</th>
</tr>
</thead>
<tbody>
<tr>
<td>Get MCU FW version</td>
<td>0x0026</td>
<td>Version as UTF-8 string</td>
</tr>
<tr>
<td>Get serial number</td>
<td>0x0015</td>
<td>The serial number as UTF-8 string</td>
</tr>
<tr>
<td>Get display mode</td>
<td>0x0007</td>
<td>Display mode as a single byte</td>
</tr>
<tr>
<td>Set display mode</td>
<td>0x0008</td>
<td>Same as above</td>
</tr>
</tbody>
</table>
</div>
<p>There is <a href="https://voidcomputing.hu/blog/worse-better-prettier/nreal_proto.json">a .js file</a> in the official app that describes a lot more
commands for both the Air and the Light. There aren&#39;t many interesting things,
just a couple version strings, firmware update, reboot, and fiddling with
the display.</p>
<p>Some asynchronous events also arrive on the same channel (sometimes between
command and its reply). They use the same packet format as the commands and replies.
The only one worth looking for is ID 0x6c05, which is the key press (more precisely key release)
event.</p>
<h3 id="display-modes_1"><a href="#display-modes_1">Display modes</a></h3>
<p>They also added a lot more display modes:</p>
<table>
<thead>
<tr>
<th>Mode</th>
<th>SBS</th>
<th>Resolution</th>
<th>Refresh rate</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td></td>
<td>1920x1080</td>
<td>60Hz</td>
</tr>
<tr>
<td>3</td>
<td>Yes</td>
<td>3840x1080</td>
<td>60Hz</td>
</tr>
<tr>
<td>4</td>
<td>Yes</td>
<td>3840x1080</td>
<td>72Hz</td>
</tr>
<tr>
<td>5</td>
<td></td>
<td>1920x1080</td>
<td>72Hz</td>
</tr>
<tr>
<td>8</td>
<td>Yes*</td>
<td>1920x1080</td>
<td>60Hz</td>
</tr>
<tr>
<td>9</td>
<td>Yes</td>
<td>3840x1080</td>
<td>90Hz</td>
</tr>
<tr>
<td>10</td>
<td></td>
<td>1920x1080</td>
<td>90Hz</td>
</tr>
<tr>
<td>11</td>
<td></td>
<td>1920x1080</td>
<td>120Hz</td>
</tr>
</tbody>
</table>
<p>*: This is a &#34;half SBS&#34; mode, meaning that it splits the regular HD
image in half, and then stretches each half horizontally over each of
the glasses. This is the replacement for Mode 1, which was vertically
stretched half-SBS on the Light.</p>
<p>Invalid display modes cause an error, and I checked all 256 values.</p>
<h3 id="the-imu-protocol"><a href="#the-imu-protocol">The IMU protocol</a></h3>
<p>IMU packets are also sent/received with regular HID <code>read()</code> and <code>write()</code>,
over interface 3 (endpoints <code>0x84</code> and <code>0x05</code>), with <code>0x40</code>-sized packets.</p>
<div>
<table>
<thead>
<tr>
<th>Index</th>
<th>Bytes</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x00</td>
<td>1</td>
<td>Header (0xaa)</td>
</tr>
<tr>
<td>0x01</td>
<td>4</td>
<td>Checksum (same as MCU checksum)</td>
</tr>
<tr>
<td>0x05</td>
<td>2</td>
<td>Length of additional data</td>
</tr>
<tr>
<td>0x07</td>
<td>1</td>
<td>Command ID</td>
</tr>
<tr>
<td>0x08</td>
<td>n</td>
<td>Additional data</td>
</tr>
</tbody>
</table>
</div>
<p>Every int is Little Endian.</p>
<p>Interestingly, while the packet format is very different, the commands are
exactly the same as the Light&#39;s:</p>
<div>
<table>
<thead>
<tr>
<th>Command</th>
<th>Id</th>
<th>Command data</th>
</tr>
</thead>
<tbody>
<tr>
<td>Get calibration file length</td>
<td>0x14</td>
<td>Calibration file id according to the SDK, doesn&#39;t seem to affect anything. Can be empty</td>
</tr>
<tr>
<td>Get calibration file part</td>
<td>0x15</td>
<td>Should be block number. Doesn&#39;t do anything, can be empty.</td>
</tr>
<tr>
<td>Enable IMU stream</td>
<td>0x19</td>
<td>0: disable, 1: Enable</td>
</tr>
</tbody>
</table>
</div>
<p>The calibration file format is similar, although this time they didn&#39;t stuff
3 different files in there, you only have the JSON.</p>
<p>The IMU packet format is different, more compact, but the logic is the same:</p>
<div>
<table>
<thead>
<tr>
<th>Index</th>
<th>Bytes</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x00</td>
<td>2</td>
<td>Header (0x01, 0x02)</td>
</tr>
<tr>
<td>0x02</td>
<td>2</td>
<td>Temperature (raw data from the ICM-20602)</td>
</tr>
<tr>
<td>0x04</td>
<td>8</td>
<td>Timestamp (nanoseconds)</td>
</tr>
<tr>
<td>0x0C</td>
<td>2</td>
<td>Gyroscope multiplier</td>
</tr>
<tr>
<td>0x0e</td>
<td>4</td>
<td>Gyroscope divisor</td>
</tr>
<tr>
<td>0x12</td>
<td>3</td>
<td>Gyroscope X reading</td>
</tr>
<tr>
<td>0x15</td>
<td>3</td>
<td>Gyroscope Y reading</td>
</tr>
<tr>
<td>0x18</td>
<td>3</td>
<td>Gyroscope Z reading</td>
</tr>
<tr>
<td>0x1b</td>
<td>2</td>
<td>Accelerometer multiplier</td>
</tr>
<tr>
<td>0x1d</td>
<td>4</td>
<td>Accelerometer divisor</td>
</tr>
<tr>
<td>0x21</td>
<td>3</td>
<td>Accelerometer X reading</td>
</tr>
<tr>
<td>0x24</td>
<td>3</td>
<td>Accelerometer Y reading</td>
</tr>
<tr>
<td>0x27</td>
<td>3</td>
<td>Accelerometer Z reading</td>
</tr>
<tr>
<td>0x2a</td>
<td>2</td>
<td>Magnetometer offset</td>
</tr>
<tr>
<td>0x2c</td>
<td>4</td>
<td>Magnetometer divisor</td>
</tr>
<tr>
<td>0x30</td>
<td>2</td>
<td>Magnetometer X reading</td>
</tr>
<tr>
<td>0x32</td>
<td>2</td>
<td>Magnetometer Y reading</td>
</tr>
<tr>
<td>0x34</td>
<td>2</td>
<td>Magnetometer Z reading</td>
</tr>
</tbody>
</table>
</div>
<p>Yes, there are 3 byte signed integers there. They are encoded the same
way as &#34;regular&#34; 4 byte integers (little endian, one&#39;s complement), but on 3 bytes.
Thankfully the Rust parsing library I use has built-in support for these,
because manually converting is a pain.</p>
<p>One thing to note is that the coordinate system of the raw sensor
readings is <a href="https://github.com/badicsalex/ar-drivers-rs/blob/db65af113de81e23384a326fc2afecb23594bc30/src/nreal_air.rs#L342">different from the calibration file&#39;s coordinate system</a>.</p>

<p>I always wanted to support the Rokid Max, but I didn&#39;t really want to buy one
just to do it. Thankfully, a kind soul from Canada actually <a href="https://github.com/badicsalex/ar-drivers-rs/issues/3#issuecomment-1662539257">got in contact with me on github</a>
paid for both the glasses and my time to do it. Thanks again Mauve.</p>
<p>The only extra was that I had to also make a <a href="https://gitlab.freedesktop.org/monado/monado/-/blob/a3f228af3536a7d4f16e85df02a1bc248c7dcf31/src/xrt/drivers/rokid/rokid_hmd.c">Monado driver</a>.
<a href="https://monado.dev/">Monado</a> is a nice piece of software that implements <a href="https://en.wikipedia.org/wiki/OpenXR">the OpenXR API</a>,
so any OpenXR-using apps (major 3D engines, <a href="https://github.com/SimulaVR/Simula">some AR desktops</a> for example)
can use any Monado-supported hardware. They have a very friendly discord, and the code is very good quality,
it was a joy to work with, and my code got reviewed basically instantly. Once the
comments were fixed, it was in trunk the next day.</p>
<p>Support for the Rokid Max has been merged to main. Some people are working
on supporting the Nreal Air, and (as of writing) it works well, but there are
some kinks to be ironed out. </p>
<p>Maybe you can help :)</p>
    <hr/>
    
    </article>
        </div></div>
  </body>
</html>
