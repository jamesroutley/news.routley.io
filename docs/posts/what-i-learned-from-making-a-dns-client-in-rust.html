<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.adamchalmers.com/making-a-dns-client/">Original</a>
    <h1>What I learned from making a DNS client in Rust</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>Over the last few weeks I built <a href="https://github.com/adamchalmers/dingo">my own DNS client</a>. Mostly because I thought dig (the standard DNS client) was kinda clunky. Partly because I wanted to learn more about DNS. So here&#39;s how I built it, and how you can build your own too. It&#39;s a great weekend project, and I learned a lot from finishing it.</p>

<p><a href="https://jvns.ca/">Julia Evans</a> gave me the idea of making a DNS client. She&#39;s one of my favourite tech bloggers. Her blog always teaches me something, and often inspires me to go learn something new. She&#39;s also really good at summing up complex topics into really <a href="https://wizardzines.com">simple little cartoons</a>, like this one:</p>
<p><a href="https://wizardzines.com/comics/dns-packet/"><img src="https://blog.adamchalmers.com/making-a-dns-client/julia-evans-dns-packet.png" alt="Comic explaining DNS query structure, when serialized for transmission over wire"/></a></p>
<p>When I read that comic, I was shocked -- the DNS query protocol is much simpler as I thought it would be. Also, I work at a company that is, uh, kind of a big player in the DNS world. I should probably understand it better.</p>

<p>The other reason I wanted to make a DNS client is that I knew I could simplify every step using some great Rust crates. The plan:</p>
<ol>
<li>
<p><strong>Parse the CLI args using <a href="https://crates.io/crates/pico-args">picoargs</a></strong></p>
<p>It&#39;s not as powerful as <a href="https://crates.io/crates/clap">clap</a>, the standard Rust &#34;enterprise-grade&#34; CLI crate, and it requires some more boilerplate. But I don&#39;t really need advanced CLI features, and picoargs compiles <em>way</em> faster.</p>
</li>
<li>
<p><strong>Serialize the DNS query using <a href="https://docs.rs/bitvec">bitvec</a>, an <em>awesome</em> general-purpose crate for reading or writing individual bits</strong></p>
<p>I learned how to parse bitwise protocols with Nom when doing <a href="https://adventofcode.com/2021/day/16">Advent of Code</a>. I considered using <a href="https://crates.io/crates/deku">deku</a> instead but decided against it.</p>
</li>
<li>
<p><strong>Communicate with a DNS resolver with the stdlib <a href="https://doc.rust-lang.org/stable/std/net/struct.UdpSocket.html">UdpSocket</a> type</strong></p>
<p>I had no idea how this worked, but the Rust stdlib is really well-documented, so I was sure I could pick it up.</p>
</li>
<li>
<p><strong>Parse the binary response with <a href="https://docs.rs/nom">Nom</a></strong></p>
<p>I learned how to parse bitwise protocols with Nom when doing <a href="https://adventofcode.com/2021/day/16">Advent of Code</a>. My <a href="https://blog.adamchalmers.com/nom-dns">previous blog post</a> has a detailed guide to parsing DNS headers, using bit-level Nom for the one-bit flags and four-bit numbers.</p>
</li>
<li>
<p><strong>Use plain old <code>println!</code> to print the response to the user</strong></p>
</li>
</ol>

<p>It took around 800 lines of code, and I had it almost finished in a weekend. There was just one part of the spec I hadn&#39;t implemented: message compression (MC). Unfortunately that took me another weekend to do -- see below for more details.</p>
<p>I named it Dingo because it sounded like <code>dig</code>, and it reminds me of Australia, my home. Anyway, it works!</p>
<p><img src="https://blog.adamchalmers.com/making-a-dns-client/dingo_screenshot.png" alt="Screenshot of a terminal running dingo, my DNS client, and resolving a name"/></p>
<p>You can install it or read the finished code <a href="https://github.com/adamchalmers/dingo">on GitHub</a>. </p>

<h2 id="reading-rfcs">Reading RFCs</h2>
<p>I think a lot of programmers are intimidated by RFCs. At least, I&#39;d like to think so, because I certainly am. Maybe all my peers are secretly RFC-loving little gremlins who get a heart-pounding high from reading plaintext ASCII diagrams... but they&#39;ve never mentioned it.</p>
<p><a href="https://datatracker.ietf.org/doc/html/rfc1035">RFC 1035</a> defines the DNS message protocol, so I had to read it very closely. This was my first time actually reading an RFC top-to-bottom, and I was surprised by how legible it was. I kept referring back to it, and I pasted key definitions and quotes from the RFC into source code comments, to help understand how all the pieces fit together. Maybe RFC 1035 is unusually good and the rest <em>are</em> actually all scary and incomprehensible. But I liked it.</p>
<p>(it&#39;s especially interesting reading this as a historical document, a primary source -- a lot has changed since the 1980s, and it&#39;s fascinating to learn what programmers back then were thinking, before the modern internet really existed)</p>
<h2 id="sockets">Sockets</h2>
<p>I&#39;ve never been very comfortable with sockets. I tried reading <a href="https://beej.us/guide/bgnet/">Beej&#39;s guide to socket programming</a> back in college, but I didn&#39;t really have the necessary OS, networking or C skills to make it through. I know about TCP and UDP, but I knew nothing about the lower-level abstractions that unify them. </p>
<p>This project was the first time I had to open a UDP socket -- in my regular programming, I&#39;ve just relied on some networking library to handle that low level detail. So, I read the <a href="https://doc.rust-lang.org/stable/std/net/struct.UdpSocket.html">Rust docs for UDP sockets</a>, which are remarkably clear. A lot of the methods on UdpSocket correspond directly to Linux syscalls. When I later went back and read <a href="https://beej.us/guide/bgnet/">Beej&#39;s socket guide</a> properly, it was really easy. All these syscalls were familiar -- they&#39;re just Rust stdlib networking methods!</p>
<p>In fact, if I use <code>dtruss</code> (a MacOS tool for inspecting which syscalls your programs make), I can see exactly what syscalls my program is using:</p>
<pre><code data-lang="bash"><span>$</span><span> sudo dtruss dingo</span><span> -t</span><span> A www.twitter.com
</span><span># Skipping lots of syscalls just for starting a process on MacOS...
</span><span>getentropy(0x7FF7BE8734E0, 0x20, 0x0)  = </span><span>0</span><span> 0 </span><span># Used by `rand` to generate a random DNS request ID
</span><span>socket(0x2, 0x2, 0x0)  = </span><span>3</span><span> 0 </span><span># Create the UDP socket, aka &#34;file descriptor 3&#34;
</span><span>ioctl(0x3, 0x20006601, 0x0)  = </span><span>0</span><span> 0 </span><span># Not sure, something about the UDP socket
</span><span>setsockopt(0x3, 0xFFFF, 0x1022)  = </span><span>0</span><span> 0 </span><span># Set the options on the UDP socket
</span><span>bind(0x3, 0x7FF7BE87346C, 0x10)  = </span><span>0</span><span> 0 </span><span># Bind the UDP socket to a local address
</span><span>setsockopt(0x3, 0xFFFF, 0x1006)  = </span><span>0</span><span> 0 </span><span># Set more options, dunno why it needs more...
</span><span>connect(0x3, 0x7FF7BE873584, 0x10)  = </span><span>0</span><span> 0 </span><span># Connect to the remote DNS resolver
</span><span>sendto(0x3, 0x7FAE060041F0, 0x21)  = </span><span>33</span><span> 0 </span><span># Send the request to the remote DNS resolver
</span><span>recvfrom(0x3, 0x7FAE060043F0, 0x200)  = </span><span>79</span><span> 0 </span><span># Get the response from the remote DNS resolver
</span><span>close_nocancel(0x3)  = </span><span>0</span><span> 0 </span><span># Close the UDP socket
# Skipping lots of syscalls just for ending a process on MacOS
</span></code></pre>
<p>The syscalls <code>connect</code>, <code>sendto</code> and <code>recvfrom</code> are all from calling Rust methods <code>UdpSocket::{connect, send_to, recv_from}</code> -- they translate 1:1 into syscalls! That&#39;s really cool.</p>
<h2 id="bitvec">Bitvec</h2>
<p>I really love Bitvec. It combines the usability and readability of <code>Vec&lt;bool&gt;</code> with the speed of using bit-twiddling tricks. It&#39;s the perfect example of Rust&#39;s no-compromises &#34;ergonomics AND speed AND correctness&#34; ideals.</p>
<p>The library exposes types for BitArray, BitVec and BitSlice. They <em>mostly</em> work the same, but I found two little <a href="https://twitter.com/adam_chal/status/1487975794379005960">confusing issues</a> where they work differently. These were easily caught with unit tests, though, so I guess it&#39;s just a learning experience. The author hopes that after Rust ships more <a href="https://blog.adamchalmers.com/grids-2/">const generics</a> features, they can release a Bitvec 2.0 where these types work the same. </p>
<h2 id="dig-s-weird-output">Dig&#39;s weird output</h2>
<p>I mentioned earlier that I hate using <code>dig</code>. It&#39;s got so many confusing fields and weird extraneous information. I just want to see what some hostname resolves to, and <code>dig</code> forces me to read all this extra info I don&#39;t care about.</p>
<pre><code><span>$ dig adamchalmers.com

; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; adamchalmers.com
;; global options: +cmd
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 51459
;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; QUESTION SECTION:
;adamchalmers.com.		IN	A

;; ANSWER SECTION:
adamchalmers.com.	300	IN	A	104.19.237.120
adamchalmers.com.	300	IN	A	104.19.238.120

;; Query time: 80 msec
;; SERVER: 2600:1700:280:1f40::1#53(2600:1700:280:1f40::1)
;; WHEN: Sun Apr 10 17:48:43 CDT 2022
;; MSG SIZE  rcvd: 77
</span></code></pre>
<p>But after implementing a DNS client, I actually know what all these mean! Like, &#34;IN&#34; doesn&#39;t mean the English word &#34;in&#34;, it&#39;s short for &#34;internet&#34;, because DNS technically supports many possible namespaces (it&#39;s just that we basically only ever use <code>dig</code> for internet DNS).</p>
<p>It&#39;s kind of cool reading <code>dig</code> output now because it&#39;s a reminder of how much I&#39;ve learned. Oh yeah, I also learned that it&#39;s easy to make <code>dig</code> give you just the information you want:</p>
<pre><code><span>$ dig +short adamchalmers.com
104.19.238.120
104.19.237.120
</span></code></pre>
<p>...if I&#39;d known that back in January, I might never have started this project :)</p>
<h2 id="i-still-fucking-love-enums">I still fucking love enums</h2>
<p>Enums are such a great way to express domain logic. Functional programmers have been talking about union types for decades now, and I&#39;m glad they&#39;re finally appearing in other languages. It&#39;s hard to model domain logic in Go after using enums in Rust/Swift/Haskell. </p>
<h2 id="message-compression-mc">Message compression (MC)</h2>
<p>MC is a neat feature that DNS servers can use to reduce the size of their responses. Instead of repeating the same hostname multiple times in the response, MC replaces a hostname with a pointer back to a previously-cited hostname. The RFC actually <a href="https://datatracker.ietf.org/doc/html/rfc1035#section-4.1.4">explains it really well</a>. MC helps servers fit their DNS responses into a single UDP packet, which is important because UDP is unreliable and doesn&#39;t care about truncated packets. MC requires looking <em>back</em> at the previously-parsed bytes, but Nom only lets you look <em>ahead</em> at remaining, unparsed bytes. It took several attempts before I could support MC in a nice, idiomatic Nom way ([code][msgcmprcode]), so that cost me another weekend of work.</p>

<p>This is one of my favourite projects I&#39;ve done. My career goal for this year is to learn a lot more about Linux and networking. Writing dingo taught me a lot about one of the fundamental building blocks of the internet and how real operating systems handle it. If you&#39;re trying to learn more about low-level programming, a DNS client is a perfect challenge. It&#39;s got bitwise arithmetic, parsing, UDP networking, IP addresses and DNS hostnames. You&#39;ll learn a lot. In fact, after I wrote dingo, my friend Jesse Li <a href="https://twitter.com/__jesse_li/status/1504509199253966850">wrote his own DNS client in Python</a>. Clearly writing a DNS client is the hot new trend that you&#39;ve got to get on. You should comment below if you try it :)</p>
<hr/>


<p>But I wanted practice explicitly using bitvec and getting comfortable with its API -- after all, I was only doing this project to learn things. </p>
<p>Also, deku uses <a href="https://crates.io/crates/serde">serde</a> and <a href="https://crates.io/crates/syn">syn</a> to power its (really helpful) serialization annotations. These crates are really powerful and can really reduce the boilerplate in your codebases. But they do add a fair bit of overhead to your build times. This isn&#39;t a problem at work, where my Rust projects are pretty large and already include serde/syn in the tree. But dingo didn&#39;t use either of them, so adding Deku would increase build time from 5 seconds to 15 seconds. I hope to use Deku in the future, but it didn&#39;t really fit for this particular project. </p>

</div></div>
  </body>
</html>
