<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fly.io/ruby-dispatch/rails-on-docker/">Original</a>
    <h1>Rails on Docker</h1>
    
    <div id="readability-page-1" class="page"><article> <dl> <dt>Author</dt> <dd> <img src="https://www.gravatar.com/avatar/0cbe06e04f80388dc83d1a2cbac48aec" alt="Brad Gessler"/> <dl> <dt>Name</dt> <dd> Brad Gessler </dd> <dt>Twitter</dt> <dd> <a href="https://twitter.com/bradgessler" target="_blank"> @bradgessler </a> </dd> </dl> </dd> </dl> <section> <figure> <img src="https://fly.io/ruby-dispatch/2023-01-19/rails-on-docker-cover.jpg" alt="Container ship carrying a train"/> <figcaption> <span>Image by</span> <svg role="img" style="pointer-events: none; width: 17px; height: 17px;" viewBox="0 0 20 20" fill="currentColor" fill-rule="evenodd"> <g buffered-rendering="static"> <path fill-rule="evenodd" d="M1 8a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 018.07 3h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0016.07 6H17a2 2 0 012 2v7a2 2 0 01-2 2H3a2 2 0 01-2-2V8zm13.5 3a4.5 4.5 0 11-9 0 4.5 4.5 0 019 0zM10 14a3 3 0 100-6 3 3 0 000 6z" clip-rule="evenodd"></path> </g> </svg> <a href="https://annieruygtillustration.com/" target="_blank"> Annie Ruygt </a> </figcaption> </figure> <p><strong>Rails 7.1 is getting an</strong> <a href="https://github.com/rails/rails/pull/46794"><strong>official Dockerfile</strong></a><strong>, which should make it easier to deploy Rails applications to production environments that support Docker. Think of it as a pre-configured Linux box that will work for most Rails applications.</strong></p> <p>That means you&#39;ll start seeing a <code>Dockerfile</code> in the project directory of a lot more Rails apps. If you&#39;re not familiar with Docker, you might open the file and see a few things that look familiar like some bash commands, but some other things might be new and foreign to you.</p> <p>Let&#39;s dive into what&#39;s in a <code>Dockerfile</code> so its less of a mystery, but first let&#39;s have a look at how Fly.io uses Docker so you better understand how Docker fits into a Rails stack.</p> <h2 id="how-does-fly-io-use-docker"><a href="#how-does-fly-io-use-docker" aria-label="Anchor"></a>How Does Fly.io Use Docker?</h2><p>Fun fact! Fly.io doesn&#39;t actually run Docker in production—rather it uses a Dockerfile to <a href="https://fly.io/blog/docker-without-docker/">create a Docker image, also known as an OCI image, that it runs as a Firecracker VM</a>. What does that mean for you? Not much really. For all practical purposes you&#39;ll describe your applications&#39; production machine in a Dockerfile and Fly.io transparently handles the rest.</p> <p>The great thing about Dockerfiles is it makes standardizing production deployments possible, which for most developers means its easier to deploy applications to hosts that support Docker, like <a href="https://fly.io/docs/rails">Fly.io</a>.</p> <p>What&#39;s a Dockerfile? It&#39;s a text file with a bunch of declarations and Linux commands that describe what needs to be installed and executed to get an application running. This file is given to a bunch of fancy software that configures a Linux distribution to the point where it can run your application.</p> <p>You can think of each command in the file as a &#34;layer&#34;. At the bottom of the layer is a Linux distribution, like Ubuntu. Each command adds another layer to the configuration until eventually all the packages, configurations, and application code are in the container and your app can run. This layering is important for caching commands, which make deployments fast if done correctly.</p> <p>Let&#39;s get into it.</p> <h2 id="a-closer-look-at-the-rails-dockerfile"><a href="#a-closer-look-at-the-rails-dockerfile" aria-label="Anchor"></a>A Closer Look at the Rails Dockerfile</h2><p>At the time of this writing, the default Rails 7.1 Dockerfile looks like:</p> <div><pre><code><span># Make sure it matches the Ruby version in .ruby-version and Gemfile</span>
<span>ARG</span><span> RUBY_VERSION=3.2.0</span>
<span>FROM</span><span> ruby:$RUBY_VERSION</span>

<span># Install libvips for Active Storage preview support</span>
<span>RUN </span>apt-get update <span>-qq</span> <span>&amp;&amp;</span> <span>\
</span>    apt-get <span>install</span> <span>-y</span> build-essential libvips <span>&amp;&amp;</span> <span>\
</span>    apt-get clean <span>&amp;&amp;</span> <span>\
</span>    <span>rm</span> <span>-rf</span> /var/lib/apt/lists/<span>*</span> /usr/share/doc /usr/share/man

<span># Rails app lives here</span>
<span>WORKDIR</span><span> /rails</span>

<span># Set production environment</span>
<span>ENV</span><span> RAILS_LOG_TO_STDOUT=&#34;1&#34; \</span>
    RAILS_SERVE_STATIC_FILES=&#34;true&#34; \
    RAILS_ENV=&#34;production&#34; \
    BUNDLE_WITHOUT=&#34;development&#34;

# Install application gems
<span>COPY</span><span> Gemfile Gemfile.lock ./</span>
<span>RUN </span>bundle <span>install</span>

<span># Copy application code</span>
<span>COPY</span><span> . .</span>

<span># Precompile bootsnap code for faster boot times</span>
<span>RUN </span>bundle <span>exec </span>bootsnap precompile <span>--gemfile</span> app/ lib/

<span># Precompiling assets for production without requiring secret RAILS_MASTER_KEY</span>
<span>RUN </span><span>SECRET_KEY_BASE_DUMMY</span><span>=</span>1 bundle <span>exec </span>rails assets:precompile

<span># Entrypoint prepares the database.</span>
<span>ENTRYPOINT</span><span> [&#34;/rails/bin/docker-entrypoint&#34;]</span>

<span># Start the server by default, this can be overwritten at runtime</span>
<span>EXPOSE</span><span> 3000</span>
<span>CMD</span><span> [&#34;./bin/rails&#34;, &#34;server&#34;]</span>
</code></pre></div><p>At the top of the file, we set the Ruby version.</p> <div><pre><code><span># Make sure it matches the Ruby version in .ruby-version and Gemfile</span>
<span>ARG</span><span> RUBY_VERSION=3.2.0</span>
<span>FROM</span><span> ruby:$RUBY_VERSION</span>
</code></pre></div><p>The version gets plugged into the <code>FROM</code> command, which ends up looking like <code>FROM ruby:3.2.0</code>. Where is <code>ruby:3.2.0</code>? It&#39;s a <a href="https://hub.docker.com/_/ruby/">Docker image</a> that some community members have graciously configured for us that gets us a Linux distribution running Ruby 3.2. That&#39;s not enough to run a Rails application; we need to add a few more layers to the image.</p> <p>Next up the Dockerfile installs Linux packages needed to run certain Rails gems in Linux. <code>libvibs</code> is a native library used to resize images for ActiveSupport. Other packages could be added here, like a Postgres, MAQL, or SQLite client. Other gems may depend on Linux packages too. For example, a popular XML parsing library, Nokogiri, depends on libxml. Those are not included in this list because the <code>ruby</code> image already includes them.</p> <div><pre><code><span># Install libvips for Active Storage preview support</span>
<span>RUN </span>apt-get update <span>-qq</span> <span>&amp;&amp;</span> <span>\
</span>    apt-get <span>install</span> <span>-y</span> build-essential libvips <span>&amp;&amp;</span> <span>\
</span>    apt-get clean <span>&amp;&amp;</span> <span>\
</span>    <span>rm</span> <span>-rf</span> /var/lib/apt/lists/<span>*</span> /usr/share/doc /usr/share/man
</code></pre></div><p><code>apt-get</code> is a Linux package manager that always looks strange in a Dockerfile because of all the command it does before and after installing a package. Let&#39;s break it down line-by-line.</p> <p>First, <code>apt-get update -qq</code> tells Linux to download a manifest of all the packages that are available for download from <code>apt-get</code>.</p> <p>The second line is the one you care about and might need to change. <code>apt-get install -y build-essential libvips</code> installs two packages and the <code>-y</code> automatically answers &#34;yes&#34; when it asks if you&#39;re sure you want to install the packages.</p> <p>Everything after that removes the manifest files and any temporary files downloaded during this command. It&#39;s necessary to remove all these files in this command to keep the size of the Docker image to a minimum. Smaller Dockerfiles mean faster deployments.</p> <p>Next the working directory is set.</p> <div><pre><code><span># Rails app lives here</span>
<span>WORKDIR</span><span> /rails</span>
</code></pre></div><p>This creates the <code>./rails</code> folder inside the docker image. All of the lines in the Dockerfile after this are run from that directory and any files added to the image are put in that directory. It&#39;s the equivalent of <code>mkdir -p ./rails &amp;&amp; cd ./rails</code>.</p> <p>Next a few environment variables are set.</p> <div><pre><code><span># Set production environment</span>
<span>ENV</span><span> RAILS_LOG_TO_STDOUT=&#34;1&#34; \</span>
    RAILS_SERVE_STATIC_FILES=&#34;true&#34; \
    RAILS_ENV=&#34;production&#34; \
    BUNDLE_WITHOUT=&#34;development&#34;
</code></pre></div><p>What are these you ask?</p> <ul> <li><code>RAILS_LOG_TO_STDOUT</code> - Rails log output is sent to STDOUT instead of a file. STDOUT, or standard out, makes it possible for <code>docker logs</code> to view the output of whatever is running on the container. <a href="https://12factor.net/logs">The Twelve-Factor App has a good explanation</a> of why logs should be written to STDOUT. </li><li><code>RAILS_SERVE_STATIC_FILES</code> - This instructs Rails to <em>not</em> serve static files. It&#39;s always been recommended to have a server like nginx serve up images, CSS, JavaScripts, and other static files by a server that&#39;s not Ruby for better performance. </li><li><code>RAILS_ENV</code> - Instructs Rails to boot with <code>production</code> gems and with the configuration from <code>config/environments/production.rb</code>. </li><li><code>BUNDLE_WITHOUT</code> - If you&#39;ve ever looked in your application&#39;s Gemfile, you&#39;ll notice there&#39;s gems tagged with the <code>development</code> group like <code>web-console</code>. These gems are not needed or wanted in a production environment because they would either slow things down, not be used, or pose a security risk. This command tells bundler to leave out all the <code>development</code> gems. </li></ul> <p>Time to install the gems! First Docker copies the <code>Gemfile</code> and <code>Gemfile.lock</code> from our workstation or CI&#39;s server project directory into the containers <code>./rails</code> directory (remember the thing that was set by <code>WORKDIR</code> above? This is it!)</p> <div><pre><code><span># Install application gems</span>
<span>COPY</span><span> Gemfile Gemfile.lock ./</span>
<span>RUN </span>bundle <span>install</span>
</code></pre></div><p><code>bundle install</code> is run against the Gemfiles that were copied over. This installs the gems inside the container, which we&#39;ll need for our Rails application to run.</p> <p>Something you might be asking yourself, &#34;why not copy the entire application from my workstation and then run <code>bundle install</code>?&#34;. Great question! Each &#34;ALLCAPS&#34; directive in a Dockerfile, like <code>RUN</code>, <code>COPY</code>, etc. are &#34;layers&#34; that get cached. If you didn&#39;t handle copying the Gemfile and running bundler as a separate layer, you&#39;d have to run <code>bundle install</code> every time you deployed Rails, even if you didn&#39;t change the gem. That would take forever!</p> <p>Making it a separate layer means you only have to update the bundle when the <code>Gemfile</code> changes. In other words, if you only change application code, you can skip running bundle and jump right into the next layer, which saves loads of time between deploys.</p> <p>Finally the Rails application code files are copied from your computer or CI machine to the <code>WORKDIR</code> set above, which is <code>./rails</code> in the image.</p> <div><pre><code><span># Copy application code</span>
<span>COPY</span><span> . .</span>
</code></pre></div><p>When we boot the Docker image and the Rails server, we want it to come online as quickly as possible so our deploys are faster, so the image copies over the bootsnap cache to make that happen.</p> <div><pre><code><span># Precompile bootsnap code for faster boot times</span>
<span>RUN </span>bundle <span>exec </span>bootsnap precompile <span>--gemfile</span> app/ lib/
</code></pre></div><p>At this point all the files needed to run the server are copied over from the workstation to the Docker image, with the exception of files listed in <code>.dockerignore</code>which typically include the <code>.git</code> directory, log files, etc.</p> <p>Now its time to compile JavaScript, stylesheet, and image assets!</p> <div><pre><code><span># Precompiling assets for production without requiring secret RAILS_MASTER_KEY</span>
<span>RUN </span><span>SECRET_KEY_BASE_DUMMY</span><span>=</span>1 bundle <span>exec </span>rails assets:precompile
</code></pre></div><p>This is a bit if a hack. Rails <em>requires</em> a secret key to keep sessions and other cryptographic Rails features secure, but for an asset compilation, including the actual secret key is not needed and is therefore a liability. Instead <code>SECRET_KEY_BASE_DUMMY=1</code> is passed into the compilation task to tell Rails, &#34;ignore requiring a secret key&#34;.</p> <p>The most important part of this command is <code>bundle exec rails assets:precompile</code>, which runs whatever compilation steps are needed to minify and fingerprint assets so they load quickly in production.</p> <p>The <code>ENTRYPOINT</code> directive in Docker acts like a wrapper.</p> <div><pre><code># Entrypoint prepares the database.
ENTRYPOINT [&#34;/rails/bin/docker-entrypoint&#34;]
</code></pre></div><p>The best thing to do is look at the contents of the <code>ENTRYPOINT</code> script, which lives at <code>./bin/docker-entrypoint</code></p> <div><pre><code><span>#!/bin/bash</span>

<span># If running the rails server then create or migrate existing database</span>
<span>if</span> <span>[</span> <span>&#34;</span><span>${</span><span>*</span><span>}</span><span>&#34;</span> <span>==</span> <span>&#34;./bin/rails server&#34;</span> <span>]</span><span>;</span> <span>then</span>
  ./bin/rails db:prepare
<span>fi

</span><span>exec</span> <span>&#34;</span><span>${</span><span>@</span><span>}</span><span>&#34;</span>
</code></pre></div><p>The script checks to see if the <code>CMD</code>, below, is running <code>./bin/rails server</code>. If its running the server, it will make sure it runs a database migration before it boots the application. If you don&#39;t want Rails to automatically run migrations when you deploy, you could comment out or remove the <code>ENTRYPOINT</code> directive in the <code>Dockerfile</code>.</p> <p>The last thing in all Dockerfiles is how to boot the application server.</p> <div><pre><code><span># Start the server by default, this can be overwritten at runtime</span>
<span>EXPOSE</span><span> 3000</span>
<span>CMD</span><span> [&#34;./bin/rails&#34;, &#34;server&#34;]</span>
</code></pre></div><p><code>EXPOSE 3000</code> tells Docker the application will listen on port 3000, which is the default for <code>bin/rails server</code>, as you see in your Rails development environment.</p> <h2 id="take-it-for-a-spin"><a href="#take-it-for-a-spin" aria-label="Anchor"></a>Take It for a Spin</h2><p>You can expect a lot of changes between now and when Rails 7.1 is released. For example, we&#39;re currently exploring extracting Dockerfile generation out of <code>railties</code> and moving it into its own gem at <a href="https://rubygems.org/gems/dockerfile-rails">https://rubygems.org/gems/dockerfile-rails</a>. That means you can use this today with your current Rails project. If you want to try it out, first install the gem to your Rails app.</p> <div><pre><code><span>$ </span>bundle add dockerfile-rails
</code></pre></div><p>Then generate the <code>Dockerfile</code> with the <code>dockerfile</code> command.</p> <p>Then checkout the <code>Dockerfile</code> that&#39;s now at the root of your project. You can then deploy it by <a href="https://fly.io/docs/flyctl/installing/">installing Fly.io</a>, running the following command, and following the instructions.</p> <p>Fly.io will ask you a few questions and within a few minutes, you should see your Rails app running in production.</p> <h2 id="there-s-a-lot-of-different-ways-to-configure-a-dockerfile"><a href="#there-s-a-lot-of-different-ways-to-configure-a-dockerfile" aria-label="Anchor"></a>There&#39;s a Lot of Different Ways to Configure a Dockerfile</h2><p>The official Rails Dockerfile will be a great starting place for most people, but as applications grow in complexity and the need to install additional packages arises, it might not be enough.</p> <p>Fly.io has started putting together a collection of Dockerfile recipes in the <a href="https://fly.io/docs/rails/cookbooks/">Fly Rails Cookbooks</a>. You&#39;ll find example Dockerfiles for all sorts of different Rails deployments including those that needs Node 19+ installed or for Rails API deployments.</p>  </section> <dl> <dt> Previous post  ↓ </dt> <dd> <a href="https://fly.io/ruby-dispatch/monkey-patch-responsibly/"> Monkey Patch Responsibly </a> </dd> </dl> </article></div>
  </body>
</html>
