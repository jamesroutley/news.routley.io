<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.mooncake.dev/blog/htap-is-dead">Original</a>
    <h1>HTAP is Dead</h1>
    
    <div id="readability-page-1" class="page"><div><article><div><p>This blog is inspired by Jordan Tigani’s blog titled <a href="https://motherduck.com/blog/big-data-is-dead/">“Big Data is Dead”</a>. Jordan and I actually spent some time building a HTAP database at SingleStore. 
</p><h2>The good old days (&#39;70s)</h2><p>Back in the ’70s, one relational database did everything. Transactions (OLTP) during the day and reports after hours (OLAP). Databases like Oracle V2 and IBM DB2 ran OLTP and OLAP on the same system; largely because data sets still fit on a few disks and compute was costly.</p><p>Nobody called it Hybrid Transactional/Analytical Processing (HTAP); it was simply the <strong>database.</strong>
</p><h2>The great divide (‘80s)</h2><p>As businesses had more data and asked tougher questions, the database began to show its limits.</p><p>See, transactional and analytical workloads pull in opposite directions. OLTP requires microsecond inserts and single-row lookups, while OLAP demands full-table scans and large-scale aggregates. This created constant contention; analytics consuming I/O and cache needed for latency-sensitive transactions, and vice versa. </p><p>The solution? Isolate the workloads. By the early ’80s, the Great Divide had begun.
</p><h2>The storage split (‘90s)</h2><p>A key technical driver behind this divide was storage architecture. OLTP systems optimized for row-based storage (fast writes + point queries). While OLAP systems chose columnar storage for efficient scans and aggregations.</p><p>By the mid-2000s, this split had become industry standard. Database pioneer Michael Stonebraker marked this shift in his <a href="https://dl.acm.org/doi/abs/10.1145/3226595.3226636">paper</a>, “One Size Fits All”: An Idea Whose Time Has Come and Gone. The database started breaking up into specialized engines.
</p><h2>OLTP and OLAP both ditched the SQL (2000–2010s)</h2><p>Horizontal scaling pushed OLTP and OLAP even further apart.</p><p>Early distributed OLTP databases (NoSQL engines like MongoDB) dropped SQL and analytical capabilities entirely. On the analytics side, we saw the adoption of MapReduce and Data Lake architectures (Hadoop/HDFS): trading traditional RDBMS properties like strict consistency for massive throughput.
</p><h2>The unexpected reconciliation (2010s)</h2><p>In the 2010s, two distinct database movements gained momentum:</p><p>1. <strong>NewSQL</strong> (Spanner, CockroachDB, Vitess). OLTP should remain SQL-based. </p><p>On paper, these systems served very different workloads. But under the hood, they shared a lot: distributed, MPP-style execution, and SQL. OLTP and OLAP systems, in isolation, had converged on many of the same architectural principles. There was one big difference: storage engines.</p><p>We asked ourselves: what if you could combine both row and columnstore storage engines in a single database? </p><h2>Voilà, HTAP (2014)</h2><p>In 2014, Gartner <a href="https://www.gartner.com/en/documents/2657815#:~:text=Summary,memory%20computing%20technologies%20as%20enablers">introduced</a> the term HTAP (Hybrid Transactional and Analytical Processing): the next big DB architecture. </p><p>The goal was to close the gap between operational and analytical systems. This was a necessity for emerging workloads like pricing, fraud detection, and personalization. Even at the business level, decision makers wanted now’s data. Early HTAP systems showed it could be done. Well, mostly…</p><p><a href="https://dl.acm.org/doi/10.1145/3514221.3526055">SingleStoreDB</a> combined an in-memory rowstore, a disk-based columnstore, and a vectorized execution engine—supporting fast scans, seeks, filters, aggregations, and updates in a single system. Over time, we found that with modern hardware, the columnstore alone could handle a surprising number of OLTP-style queries, including point lookups and low-latency access patterns.</p><p><a href="https://docs.pingcap.com/tidb/stable/tidb-architecture">TiDB</a> took a different route, pairing its TiKV rowstore with a separate columnar engine based on ClickHouse—maintaining two copies of the data to serve both workloads.</p><p>So that should be it, right? ‘70s data nirvana, alas.
</p><h2>The Cloud Data Warehouse was the only winner (2020s)</h2><p>Cloud data warehouses have clearly won. The NewSQL movement stalled… And HTAP? It never got the attention it deserved. Despite real technical progress, it remained pre-product market fit. </p><p><strong>1. It’s really, really hard to replace someone’s OLTP system.</strong> Take <a href="https://db-engines.com/en/ranking">DBEngines’</a> word for this: Oracle and SQL Server still sit at #1 and #3. </p><p><strong>2. Most workloads don’t need distributed OLTP.</strong> Hardware got faster and cheaper. A single beefy machine can handle the majority of transactional workloads.
<a href="https://www.youtube.com/watch?v=4jDQi9P9UIw">Cursor</a> and <a href="https://www.pixelstech.net/article/1747708863-openai%3a-scaling-postgresql-to-the-next-level">OpenAI</a> are powered by a single-box Postgres instance. You’ll be just fine. </p><p><strong>3. Cloud-native architectures favored shared-disk, not shared-nothing.</strong> While NewSQL systems demanded fast local storage (and even in-memory durability), cloud platforms pushed toward object storage and elastic compute. </p><p><strong>4. OLTP and OLAP are owned by different teams.</strong> OLTP is owned by product engineering; OLAP belongs to the data team. The incentives rarely align. No one gets promoted for “consolidating the stack”. </p><h2>Your data-stack forms the HTAP database (Today)</h2><p>The cloud also started the move away from tightly coupled warehouses toward modular lakes built on object storage.</p><p>1. OLTP systems and stream processors as the WAL</p><p>Even in today’s disaggregated data stack, the need remains the same: fast OLAP queries on fresh transactional data. This now happens through a web of streaming pipelines, cloud data lakes, and real-time query layers.</p><p>It’s still HTAP; but through composition instead of consolidation of databases. It comes down to questions like:</p><p><strong>1. How do I apply the WAL to my storage engine?</strong>
AKA: How do I CDC from my OLTP system to the data lake efficiently?</p><p><strong>2. Can I build a lower-cost index on my data lake, and keep it in sync?</strong>
AKA: How do I ingest real-time data into the lake? Or how do I query Lake data with Postgres or Elastic functionality?</p><p>The HTAP challenge of our time comes down to making the lakehouse real-time ready.</p><p>After spending my best 10 years first starting and then rescuing it, HTAP as a database is dead. </p></div></article></div></div>
  </body>
</html>
