<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jamiepalatnik.com/day-46-cs50p-et-cetera/">Original</a>
    <h1>Day 46: CS50P Et Cetera</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">Prolog is the only good programming language. I should know, <a href="https://needleful.net" rel="nofollow">my website</a> is <a href="https://github.com/needleful/nng">written in Prolog</a>.</p>
<p dir="auto">Unfortunately, C is the only useful programming language.</p>
<p dir="auto">Scientists have been trying to find an answer to this problem for nearly 50 years. Some make their <a href="https://doc.rust-lang.org/book/ch19-06-macros.html" rel="nofollow">C more like Prolog</a>. Others make their <a href="https://prescheme.org/" rel="nofollow">Prolog more like C</a>.</p>
<p dir="auto">I offer a new solution: simply add Prolog and C together. I call it, “C Plus Prolog”, or “C+P” for short.</p>
<div dir="auto" data-snippet-clipboard-copy-content=":- include(stdio).

int func main
{ 
	puts(&#34;Hello, world!&#34;);
	return 0
}."><pre>:- include(<span>stdio</span>)<span>.</span>

<span>int</span> <span>func</span> <span>main</span>
{ 
	puts(<span>&#34;Hello, world!&#34;</span>);
	<span>return</span> <span>0</span>
}<span>.</span></pre></div>
<p dir="auto">If you&#39;re familiar with C, you&#39;ll notice this is some sort of weird, bad C. You&#39;re mistaken, however. This is valid Prolog, using some <a href="https://www.swi-prolog.org/pldoc/man?section=ext-blockop" rel="nofollow">non-standard features of SWI-Prolog</a> for the curly braces.</p>
<p dir="auto">This Prolog is read as a list of terms, and converted to valid C code. So this:</p>
<div dir="auto" data-snippet-clipboard-copy-content="int func main(int var argc, char:ptr:array var argv)"><pre><span>int</span> <span>func</span> main(<span>int</span> <span>var</span> <span>argc</span>, <span>char</span>:<span>ptr</span>:<span>array</span> <span>var</span> <span>argv</span>)</pre></div>
<p dir="auto">Translates to this:</p>
<div dir="auto" data-snippet-clipboard-copy-content="int main(int argc, char*( argv[]))"><pre><span>int</span> <span>main</span>(<span>int</span> <span>argc</span>, <span>char</span><span>*</span>( <span>argv</span>[]))</pre></div>
<p dir="auto">Beyond some obvious changes like <code>var</code> and <code>func</code> operators, which make the syntax expressible as Prolog, there are some unexpected quirks:</p>
<ul dir="auto">
<li>Symbols starting with capital letters or underscores are for use with Prolog, and won&#39;t translate to C unless wrapped in single quotes:</li>
</ul>
<div dir="auto" data-snippet-clipboard-copy-content="int:ptr var string = &#39;NULL&#39;;
&#39;_Bool&#39; var v = true;"><pre><span>int</span>:<span>ptr</span> <span>var</span> <span>string</span> = <span>&#39;NULL&#39;</span>;
<span>&#39;_Bool&#39;</span> <span>var</span> <span>v</span> = <span>true</span>;</pre></div>
<ul dir="auto">
<li>As a result of the above, character literals start with <code>#</code>:</li>
</ul>
<div dir="auto" data-snippet-clipboard-copy-content="char var c = #c;    % quotes not required for lowercase letters
char var c2 = #&#39;C&#39;; 
char var nl = #&#39;\n&#39;;"><pre><span>char</span> <span>var</span> <span>c</span> = #<span>c</span>;    % <span>quotes</span> <span>not</span> <span>required</span> <span>for</span> <span>lowercase</span> <span>letters</span>
<span>char</span> <span>var</span> <span>c2</span> = #<span>&#39;C&#39;</span>; 
<span>char</span> <span>var</span> <span>nl</span> = #<span>&#39;\n&#39;</span>;</pre></div>
<ul dir="auto">
<li>Operator precedence was maintained for existing Prolog operators. For example, <code>=</code> and comparison operators like <code>==</code>, <code>&lt;</code>, and <code>&gt;</code> have the same precedence, so you&#39;ll need parentheses where you wouldn&#39;t in C:</li>
</ul>

<p dir="auto">This is also why the arrow operator <code>-&gt;</code> was replaced with <code>@</code>, since it&#39;s used in a completely different way in Prolog and has a completely different precedence.</p>
<p dir="auto">C+P:</p>

<p dir="auto">C:</p>

<ul dir="auto">
<li>Complex type declarations are different. C-style declarations are perfectly expressible in Prolog, I just don&#39;t like them.</li>
</ul>

<p dir="auto">Becomes</p>

<p dir="auto">It may also help you remember the difference between <code>const char *</code> and <code>char const *</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="const(char):ptr,
char:const(ptr)"><pre><span>const</span>(<span>char</span>):<span>ptr</span>,
<span>char</span>:const(<span>ptr</span>)</pre></div>
<p dir="auto">The examples provide a more complete picture of the syntax.
In the end, it&#39;s C but more verbose and particular about semicolons. Not exactly a silver bullet.</p>
<p dir="auto">Let&#39;s introduce the <code>*=&gt;</code> operator.</p>

<p dir="auto">Take this snippet from example 04:</p>
<div dir="auto" data-snippet-clipboard-copy-content="max(A, B) *=&gt; A &gt; B then A else B."><pre><span>max</span>(<span>A</span>, <span>B</span>) *=&gt; <span>A</span> &gt; <span>B</span> <span>then</span> <span>A</span> <span>else</span> <span>B</span><span>.</span></pre></div>
<p dir="auto">I said C+P does no processing beyond translating terms to C, but it does one small step. The compiler will gather all the terms defined with <code>*=&gt;</code>, and then substitute the left-hand for the right-hand in the rest of the code until no more rules apply.</p>
<p dir="auto">Because this operates on Prolog terms, not text, we don&#39;t need any extra parentheses in our <code>max(A, B)</code> macro to prevent mishaps with operator precedence. It&#39;s inserted into code as a single term, and looks exactly like a function call in use:</p>
<div dir="auto" data-snippet-clipboard-copy-content="float var f = max(12.3, 0) + 20;
printf(&#34;Should be 32.3: %f\n&#34;, f);`"><pre><span>float</span> <span>var</span> <span>f</span> = max(<span>12</span>.<span>3</span>, <span>0</span>) + <span>20</span>;
printf(<span>&#34;Should be 32.3: %f\n&#34;</span>, <span>f</span>);`</pre></div>
<p dir="auto">It&#39;s converted to the following C:</p>
<div dir="auto" data-snippet-clipboard-copy-content="float f=(((12.3&gt;0) ? 12.3 : 0)+20);
printf(&#34;Should be 32.3: %f\n&#34;, f);"><pre><span>float</span> <span>f</span><span>=</span>(((<span>12.3</span><span>&gt;</span><span>0</span>) ? <span>12.3</span> : <span>0</span>)<span>+</span><span>20</span>);
<span>printf</span>(<span>&#34;Should be 32.3: %f\n&#34;</span>, <span>f</span>);</pre></div>
<p dir="auto">Also, I&#39;m tired of adding <code>\n</code> at the end of all my <code>printf</code> statements. Let&#39;s defined another macro, <code>println</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="PrintLn *=&gt; PrintF :-
	PrintLn =.. [println,Format| Args],
	string_concat(Format, &#34;\n&#34;, Format2),
	PrintF =.. [printf,Format2| Args]."><pre>PrintLn *=&gt; PrintF :-
	<span>PrintLn</span> <span>=</span><span>.</span>. [println,Format| Args],
	<span>string_concat</span>(<span>Format</span>, <span>&#34;\n&#34;</span>, <span>Format2</span>),
	<span>PrintF</span> =<span>.</span>. [printf,Format2| Args].</pre></div>
<p dir="auto">We have full access to Prolog at compile time using <code>:-</code>, allowing us to do just about anything.
This macro gets any instance of <code>println(Format, Args...)</code> with a string literal <code>Format</code>, and converts it to <code>printf</code> with a newline appended to <code>Format</code>.</p>
<p dir="auto">Simple enough. Let&#39;s implement poor man&#39;s generics.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Poor Man&#39;s Generics in C Plus Prolog</h2><a id="user-content-poor-mans-generics-in-c-plus-prolog" aria-label="Permalink: Poor Man&#39;s Generics in C Plus Prolog" href="#poor-mans-generics-in-c-plus-prolog"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Example 05 defines a generic type, <code>list[T]</code>, using the following syntax:</p>
<div dir="auto" data-snippet-clipboard-copy-content="list[T]
{
	struct list[T] {
		T:ptr:ptr var items
	};

	% Let&#39;s also define syntax for type-specific functions, in this case “list[T]:capacity”
	size_t:ptr func list[T]:capacity(list[T] var this)
	{
		...
	};
	...
}."><pre><span>list</span>[<span>T</span>]
{
	<span>struct</span> <span>list</span>[<span>T</span>] {
		<span>T</span>:<span>ptr</span>:<span>ptr</span> <span>var</span> <span>items</span>
	};

	% <span>Let</span>&#39;<span>s</span> <span>also</span> <span>define</span> <span>syntax</span> <span>for</span> <span>type</span>-<span>specific</span> <span>functions</span>, <span>in</span> <span>this</span> <span>case</span> “<span>list</span>[<span>T</span>]:<span>capacity</span>”
	<span>size_t</span>:<span>ptr</span> <span>func</span> <span>list</span>[<span>T</span>]:capacity(<span>list</span>[<span>T</span>] <span>var</span> <span>this</span>)
	{
		<span>.</span>..
	};
	...
}.</pre></div>
<p dir="auto">This will work similarly to C++ templates.
For simplicity of implementation, we&#39;ll require the user to instantiate the template.</p>
<div dir="auto" data-snippet-clipboard-copy-content="declare(list[int]).
declare(list[const(char):ptr])."><pre><span>declare</span>(<span>list</span>[<span>int</span>])<span>.</span>
<span>declare</span>(<span>list</span>[const(<span>char</span>):<span>ptr</span>])<span>.</span></pre></div>
<p dir="auto">We could probably do this automatically by scanning the code for any usage of <code>list[T]</code> and instantiating the template right above it, but I&#39;ll leave that as an exercise for the reader.</p>
<p dir="auto">We also have some syntax to get a function name with <code>list[T]:Method</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="int func main {
	list[int] var my_ints = list[int]:new(17);

	size_t var size = *(list[int]:capacity(my_ints));
	for(int var i = 0; i &lt; size; i += 1)
	{
		list[int]:append(my_ints, i*i)
	};
	for(int var i = 0; i &lt; size; i+= 1)
	{
		printf(&#34;%d squared = %d.\n&#34;, i, list[int]:get(my_ints, i))
	};
	return 0
}."><pre><span>int</span> <span>func</span> <span>main</span> {
	<span>list</span>[<span>int</span>] <span>var</span> <span>my_ints</span> = <span>list</span>[<span>int</span>]:new(<span>17</span>);

	<span>size_t</span> <span>var</span> <span>size</span> = *(<span>list</span>[<span>int</span>]:capacity(<span>my_ints</span>));
	for(<span>int</span> <span>var</span> <span>i</span> = <span>0</span>; <span>i</span> &lt; <span>size</span>; <span>i</span> += <span>1</span>)
	{
		<span>list</span>[<span>int</span>]:append(<span>my_ints</span>, <span>i</span>*<span>i</span>)
	};
	for(<span>int</span> <span>var</span> <span>i</span> = <span>0</span>; <span>i</span> &lt; <span>size</span>; <span>i</span>+= <span>1</span>)
	{
		printf(<span>&#34;%d squared = %d.\n&#34;</span>, <span>i</span>, <span>list</span>[<span>int</span>]:get(<span>my_ints</span>, <span>i</span>))
	};
	<span>return</span> <span>0</span>
}<span>.</span></pre></div>
<p dir="auto">Not exactly C++, but it keeps the namespaces clear.</p>
<p dir="auto">Let&#39;s read the macro.</p>
<p dir="auto">It matches on our template as you might have expected:</p>
<div dir="auto" data-snippet-clipboard-copy-content="Name[T] {Body} *=&gt; Comment :-
	\+ground(T), atom(Name),
	atom_concat(&#39;//Defined template type: &#39;, Name, Comment),"><pre>Name[T] {Body} *=&gt; Comment :-
	<span>\+</span>ground(<span>T</span>), atom(<span>Name</span>),
	atom_concat(<span>&#39;//Defined template type: &#39;</span>, <span>Name</span>, <span>Comment</span>),</pre></div>
<p dir="auto">We have a template with a name <code>Name</code>, type parameterss <code>T</code>, and the body <code>Body</code>.
The macro removes this code and inserts a comment. Everything else is handled in the Prolog world.</p>
<div dir="auto" data-snippet-clipboard-copy-content="	assertz(
		declare(Name[Z]) *=&gt; NewBody"><pre>	<span>assertz</span>(
		declare(<span>Name</span>[<span>Z</span>]) *=&gt; <span>NewBody</span></pre></div>
<p dir="auto">By God. Our macro <code>assert</code>s another macro, <code>declare(Name[Z])</code>. It also has conditions:</p>
<div dir="auto" data-snippet-clipboard-copy-content="		:- (
			ground(Z),
			T=Z,
			Body=NewBody,"><pre>		:- (
			ground(<span>Z</span>),
			<span>T</span><span>=</span><span>Z</span>,
			<span>Body</span><span>=</span><span>NewBody</span>,</pre></div>
<p dir="auto">Those three lines are the bulk of the macro. It unifies the template type <code>T</code> with the real (ground) type <code>Z</code>, then returns the body of the template. This is what turns <code>declare(list[int])</code> into the code for the type.</p>
<p dir="auto">But that&#39;s not all it does, the macro we&#39;re asserting itself asserts more macros:</p>
<div dir="auto" data-snippet-clipboard-copy-content="			(&#39;*mangled_name&#39;(Name[Z]) *=&gt; ZName),
			assertz(Name[Z] *=&gt; ZName),
			assertz((ZName:Method *=&gt; ZMethod :-
				% Crudely hacking some shorthand for method names
				Method \= ptr, Method \= array,
				(	atom(Method)
				-&gt;	MName = Method,
					ZArgs = []
				;	Method =.. [MName|ZArgs]
				),
				(&#39;*mangled_name&#39;(ZName:MName) *=&gt; MZ_Name),
				ZMethod =.. [MZ_Name|ZArgs]
			))
		))."><pre>			(&#39;*mangled_name&#39;(Name[Z]) *=&gt; ZName),
			<span>assertz</span>(<span>Name</span>[<span>Z</span>] *=&gt; <span>ZName</span>),
			assertz((<span>ZName</span>:<span>Method</span> *=&gt; <span>ZMethod</span> :-
				% <span>Crudely</span> <span>hacking</span> <span>some</span> <span>shorthand</span> <span>for</span> <span>method</span> <span>names</span>
				<span>Method</span> \= <span>ptr</span>, <span>Method</span> \= <span>array</span>,
				(	atom(<span>Method</span>)
				-&gt;	<span>MName</span> = <span>Method</span>,
					<span>ZArgs</span> = <span>[]</span>
				;	<span>Method</span> =<span>.</span>. [MName|ZArgs]
				),
				(&#39;*mangled_name&#39;(ZName:MName) *=&gt; MZ_Name),
				<span>ZMethod</span> =<span>.</span>. [MZ_Name|ZArgs]
			))
		)).</pre></div>
<p dir="auto">This generates the C names for things like <code>list[int]</code> and <code>list[int]:function</code>. <code>&#39;*mangled_name&#39;</code> is just another macro, but this example is long enough and it&#39;s all in example 05. The <code>*</code> and single quotes are nothing special, they just prevent this macro from accidentally colliding with a user-defined <code>mangled_name</code> function.</p>
<p dir="auto">C+P provides no type information we could use for method syntax, to do something like <code>my_list.append(...)</code>, instead of <code>list[int]:append(my_list, ...)</code>.</p>
<p dir="auto">We could, of course, use macros to gather the types of every variable in a function body and swap out method calls for the appropriate function, but at a certain point I&#39;m just writing a full-on XLang-to-C compiler in the macro system, which is an interesting idea, but I&#39;m employed.</p>
<p dir="auto">I&#39;ve provided several other examples of the wonders of C Plus Prolog:</p>
<ul dir="auto">
<li>Example 06 overloads the <code>struct</code> keyword to add compile-time reflection.</li>
<li>Example 08a compiles different code if the target file ends in <code>.h</code> or <code>.c</code>, to declare a typical header and implementation in a single file.</li>
</ul>
<p dir="auto">I find it strangely compelling to write in C+P, adding features that sound impossible. It&#39;s like a puzzle game, which is why I reach for Prolog so frequently.</p>

<p dir="auto">C Plus Prolog is easy to install. All you need is a C compiler, SWI-Prolog, and this repository. You can figure it out.</p>
<p dir="auto">Then you can run <code>cpp.pl</code> from this repository with the following syntax:
<code>swipl -s cpp.pl -- &lt;input file&gt; &lt;output file&gt;</code></p>
<p dir="auto">By convention, C Plus Prolog files end in the extension <code>.c+p</code>.</p>
<p dir="auto">Check <code>test.sh</code> and <code>test.ps1</code> for more example usage, plus a fast way to run all the tests (which are probably not rootkits).</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">What is the point of this?</h2><a id="user-content-what-is-the-point-of-this" aria-label="Permalink: What is the point of this?" href="#what-is-the-point-of-this"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">C Plus Prolog is a half-serious exploration of macros in a systems programming language.
In the process of making this, it became clear I prefer the compile-time evaluation and reflection offered by languages like D and Zig over syntactic macros.</p>
<p dir="auto">Sure, with enough work you can do everything and more with the macro system, but what does it actually <em>add</em> over a separate code generator, or a DSL? A nicer interface, maybe.</p>
<p dir="auto">In Common Lisp, you have the full codebase at compile time, but the real value is recompiling code at runtime, not manipulating a list of lists that sort of looks like code, if you squint through all the backquotes and commas.</p>
<p dir="auto">Rust&#39;s procedural macros save maybe 40 lines of code, since you don&#39;t have to write your own tokenizer, but everything else is up to you and whatever libraries you want to bring in.</p>
<p dir="auto">Most of my metaprogramming wants involve reflecting on information the compiler already knows, like the types and annotations in the code, not the raw syntax tree.  For a language-within-a-language, which syntactic macros are best at, I&#39;d usually rather go the extra mile and make an entirely separate DSL with a purpose-built syntax, rather than contort the problem to, say, S expressions or Prolog terms.</p>
<p dir="auto">Despite that, C+P is dangerously close to being useful.
The biggest advantage it has is the fact it generates plain C by default, allowing for performant cross-platform builds where less popular languages don&#39;t have support, or have to generate much more complicated C due to different abstractions.
Prolog&#39;s been around for 50 years, as well. If the SWI-Prolog extensions were removed, swapping <code>func F {Body}</code> with <code>func F =&gt; Body</code>, for example, it could be built on a huge swath of hardware.</p>
<p dir="auto">But I wouldn&#39;t want to use it. There&#39;s absolutely no validation or error messaging, so any mistakes lead to broken C or silent failures. I thought using <code>var</code> as an operator would be nice, but it&#39;s a lot of visual noise.  And if you thought C&#39;s semicolons were annoying, in C Plus Prolog, semicolons are operators. Having two in a row breaks things. Having one at the start breaks things. Having one at the <em>end</em> breaks things.</p>
<p dir="auto">If someone wanted to use C+P, there are many better alternatives.</p>
<ul dir="auto">
<li>The <a href="https://nim-lang.org/" rel="nofollow">Nim</a> and <a href="https://haxe.org/" rel="nofollow">Haxe</a> languages can compile to C and/or C++, and they offer a good user experience out of the box, though I can&#39;t say how directly their code translates to C.</li>
<li><a href="https://github.com/eudoxia0/cmacro">cmacro</a> offers a similar level of syntax manipulation to C+P in a nicer format, powered by Common Lisp.</li>
<li><a href="https://dlang.org/" rel="nofollow">The D language</a> Has compilers backed by GCC and LLVM, so it should work in most places C will.</li>
</ul>
<p dir="auto">I don&#39;t know what the conclusion is.</p>
</article></div></div>
  </body>
</html>
