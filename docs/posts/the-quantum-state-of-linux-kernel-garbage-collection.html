<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://googleprojectzero.blogspot.com/2022/08/the-quantum-state-of-linux-kernel.html">Original</a>
    <h1>The quantum state of Linux kernel garbage collection</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-6481767562526230244" itemprop="description articleBody">

 <p id="h.y3ub1og6t2w0"><span>A deep dive into an in-the-wild Android exploit</span></p>
 <p><span>Guest Post by Xingyu Jin, Android Security Research</span><span>This is part one of a two-part guest blog post, where first we&#39;ll look at the <span><a href="https://googleprojectzero.github.io/0days-in-the-wild//0day-RCAs/2021/CVE-2021-0920.html">root cause</a></span> of the CVE-2021-0920 vulnerability. In the second post, we&#39;ll dive </span><span>into the in</span><span>-</span><span>the</span><span>-wild 0-day exploitation of the vulnerability and post-compromise modules.</span></p>
 <p><span>A surveillance vendor </span><span>named Wintego</span><span> has developed an exploit for Linux socket syscall 0-day, CVE-2021-0920, and used it in the wild since </span><span>at least November 2020 based on the earliest captured sample</span><span>, until the issue was fixed in November 2021.  Combined with Chrome and Samsung browser </span><span>exploits</span><span>, the vendor was able to remotely root Samsung devices. The fix was released with the </span><span><a href="https://source.android.com/security/bulletin/2021-11-01">November 2021 Android Security Bulletin</a></span><span>, and applied to Samsung devices in Samsung&#39;s December 2021 security update.</span></p>
 
 <p><span>Google&#39;s Threat Analysis Group (TAG) discovered Samsung browser exploit chains being used in the wild. TAG then performed root cause analysis and discovered that this vulnerability, CVE-2021-0920, was being used to escape the sandbox and elevate privileges. </span><span>CVE-2021-0920 was reported to Linux/Android anonymously. The Google Android Security Team performed</span><span> the full deep-dive analysis of the exploit.</span></p>
 
 <p><span>This issue was initially discovered in 2016 by a RedHat kernel developer and disclosed in a public email thread, but the Linux kernel community </span><span><a href="https://patchwork.ozlabs.org/project/netdev/patch/CAOssrKcfncAYsQWkfLGFgoOxAQJVT2hYVWdBA6Cw7hhO8RJ_wQ@mail.gmail.com/">did not patch</a></span><span> the issue until it was re-reported in 2021.</span></p>
 
 <p><span>Various Samsung devices were targeted, including the Samsung S10 and S20. By abusing an ephemeral race condition in Linux kernel garbage collection, the exploit code was able to obtain a use-after-free (UAF) in a kernel </span><span>sk_buff</span><span> object. The in-the-wild sample could effectively circumvent </span><span>CONFIG_ARM64_UAO</span><span>, achieve arbitrary read / write primitives and bypass Samsung RKP to elevate to root.</span><span> Other Android devices</span><span> </span><span>were also vulnerable, but we did not find any exploit samples against them.</span></p>
 
 <p><span>Text extracted from captured samples dubbed the vulnerability “quantum Linux kernel garbage collection”, which appears to be a fitting title for this blogpost.</span></p>
 <p><span>CVE-2021-0920 is a use-after-free (UAF) due to a race condition in the garbage collection system for </span><span>SCM_RIGHTS</span><span>. </span><span>SCM_RIGHTS</span><span> is a control message that allows unix-domain sockets to transmit an open file descriptor from one process to another. In other words, the sender transmits a file descriptor and the receiver then obtains a file descriptor from the sender. This passing of file descriptors adds complexity to reference-counting file structs. To account for this, the Linux kernel community designed a special garbage collection system. CVE-2021-0920 is a vulnerability within this garbage collection system. By winning a race condition during the garbage collection process, an adversary can exploit the UAF on the socket buffer, </span><span>sk_buff</span><span> object. In the following sections, we’ll explain the </span><span>SCM_RIGHTS</span><span> garbage collection system and the details of the vulnerability. The analysis is based on the Linux 4.14 kernel.</span></p><h2 id="h.qjne51ghywhs"><span>What is SCM_RIGHTS</span><span>?</span></h2>
 <p><span>Linux developers can share file descriptors (fd) from one process to another using the </span><span><a href="https://man7.org/linux/man-pages/man7/unix.7.html">SCM_RIGHTS datagram with the sendmsg syscall</a></span><span>. When a process passes a file descriptor to another process, </span><span>SCM_RIGHTS</span><span> will add a reference to the underlying </span><span>file</span><span> struct. This means that the process that is sending the file descriptors can immediately close the file descriptor on their end, even if the receiving process has not yet accepted and taken ownership of the file descriptors. When the file descriptors are in the “queued” state (meaning the sender has passed the fd and then closed it, but the receiver has not yet accepted the fd and taken ownership), specialized garbage collection is needed. To track this “queued” state, this </span><span><a href="https://lwn.net/Articles/779472/">LWN article</a></span><span> does a great job explaining </span><span>SCM_RIGHTS</span><span> reference counting, and it&#39;s recommended reading before continuing on with this blogpost.</span></p><h2 id="h.4irl9u2c0bda"><span>Sending</span></h2>
 <p><span>As stated previously, a unix domain socket uses the syscall </span><span>sendmsg</span><span> to send a file descriptor to another socket. To explain the reference counting that occurs during </span><span>SCM_RIGHTS</span><span>, </span><span>we’ll start from the sender’s point of view. We start with the kernel</span><span> function </span><span>unix_stream_sendmsg</span><span>, which implements the </span><span>sendmsg</span><span> syscall. </span><span>To implement the </span><span>SCM_RIGHTS</span><span> functionality, the kernel uses the structure </span><span>scm_fp_list</span><span> for managing all the transmitted </span><span>file</span><span> structures. </span><span>scm_fp_list</span><span> stores the list of </span><span>file</span><span> pointers to be passed. </span></p>
 <div colspan="1" rowspan="1">
 <p><span>struct</span><span> scm_fp_list </span><span>{</span></p>
 <p><span>        </span><span>short</span><span>                   count</span><span>;</span></p>
 <p><span>        </span><span>short</span><span>                   max</span><span>;</span></p>
 <p><span>        </span><span>struct</span><span> user_struct      </span><span>*</span><span>user</span><span>;</span></p>
 <p><span>        </span><span>struct</span><span> file             </span><span>*</span><span>fp</span><span>[</span><span>SCM_MAX_FD</span><span>];</span></p>
 <p><span>};</span></p></div>
 
 <p><span>unix_stream_sendmsg</span><span> invokes </span><span>scm_send</span><span> (</span><span><a href="https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/af_unix.c#L1886">af_unix.c#L1886</a></span><span>) to initialize the </span><span>scm_fp_list</span><span> structure, linked by the</span><span> </span><span>scm_cookie</span><span> structure on the stack.</span></p><div colspan="1" rowspan="1">
 <p><span>struct</span><span> scm_cookie </span><span>{</span></p>
 <p><span>        </span><span>struct</span><span> pid              </span><span>*</span><span>pid</span><span>;</span><span>           </span><span>/* Skb credentials */</span></p>
 <p><span>        </span><span>struct</span><span> scm_fp_list      </span><span>*</span><span>fp</span><span>;</span><span>            </span><span>/* Passed files         */</span></p>
 <p><span>        </span><span>struct</span><span> scm_creds        creds</span><span>;</span><span>          </span><span>/* Skb credentials      */</span></p>
 <p><span>#ifdef</span><span> CONFIG_SECURITY_NETWORK</span></p>
 <p><span>        u32                     secid</span><span>;</span><span>          </span><span>/* Passed security ID   */</span></p>
 <p><span>#endif</span></p>
 <p><span>};</span></p></div>
 
 <p><span>To be more specific, </span><span>scm_send</span><span> → </span><span>__scm_send</span><span> → </span><span>scm_fp_copy</span><span> (</span><span><a href="https://elixir.bootlin.com/linux/v4.14.277/source/net/core/scm.c#L68">scm.c#L68</a></span><span>) reads the file descriptors from the userspace and initializes </span><span>scm_cookie-&gt;fp</span><span> which can contain </span><span>SCM_MAX_FD</span><span> file structures.</span></p>
 <p><span>Since the Linux kernel uses the </span><span>sk_buff</span><span> (also known as socket buffers or </span><span>skb</span><span>) object to manage all types of socket datagrams, the kernel also needs to invoke the </span><span>unix_scm_to_skb</span><span> function to link the </span><span>scm_cookie-&gt;fp</span><span> to a corresponding </span><span>skb</span><span> object. This occurs in </span><span>unix_attach_fds</span><span> (</span><span><a href="https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/scm.c#L103">scm.c#L103</a></span><span>):</span></p>
 <div colspan="1" rowspan="1">
 <p><span>…</span></p>
 <p><span>/*</span></p>
 <p><span> * Need to duplicate file references for the sake of garbage</span></p>
 <p><span> * collection.  Otherwise a socket in the fps might become a</span></p>
 <p><span> * candidate for GC while the skb is not yet queued.</span></p>
 <p><span> */</span></p>
 <p><span>UNIXCB</span><span>(</span><span>skb</span><span>).</span><span>fp </span><span>=</span><span> scm_fp_dup</span><span>(</span><span>scm</span><span>-&gt;</span><span>fp</span><span>);</span></p>
 <p><span>if</span><span> </span><span>(!</span><span>UNIXCB</span><span>(</span><span>skb</span><span>).</span><span>fp</span><span>)</span></p>
 <p><span>        </span><span>return</span><span> </span><span>-</span><span>ENOMEM</span><span>;</span></p>
 <p><span>…</span></p></div>
 
 <p><span>The </span><span>scm_fp_dup</span><span> call in </span><span>unix_attach_fds</span><span> increases the reference count of the file descriptor that’s being passed so the file is still valid even after the sender closes the transmitted file descriptor later:</span></p>
 <div colspan="1" rowspan="1">
 <p><span>struct</span><span> scm_fp_list </span><span>*</span><span>scm_fp_dup</span><span>(</span><span>struct</span><span> scm_fp_list </span><span>*</span><span>fpl</span><span>)</span></p>
 <p><span>{</span></p>
 <p><span>        </span><span>struct</span><span> scm_fp_list </span><span>*</span><span>new_fpl</span><span>;</span></p>
 <p><span>        </span><span>int</span><span> i</span><span>;</span></p>
 
 <p><span>        </span><span>if</span><span> </span><span>(!</span><span>fpl</span><span>)</span></p>
 <p><span>                </span><span>return</span><span> NULL</span><span>;</span></p>
 
 <p><span>        new_fpl </span><span>=</span><span> kmemdup</span><span>(</span><span>fpl</span><span>,</span><span> offsetof</span><span>(</span><span>struct</span><span> scm_fp_list</span><span>,</span><span> fp</span><span>[</span><span>fpl</span><span>-&gt;</span><span>count</span><span>]),</span></p>
 <p><span>                          GFP_KERNEL</span><span>);</span></p>
 <p><span>        </span><span>if</span><span> </span><span>(</span><span>new_fpl</span><span>)</span><span> </span><span>{</span></p>
 <p><span>                </span><span>for</span><span> </span><span>(</span><span>i </span><span>=</span><span> </span><span>0</span><span>;</span><span> i </span><span>&lt;</span><span> fpl</span><span>-&gt;</span><span>count</span><span>;</span><span> i</span><span>++)</span></p>
 <p><span>                        get_file</span><span>(</span><span>fpl</span><span>-&gt;</span><span>fp</span><span>[</span><span>i</span><span>]);</span></p>
 <p><span>                new_fpl</span><span>-&gt;</span><span>max </span><span>=</span><span> new_fpl</span><span>-&gt;</span><span>count</span><span>;</span></p>
 <p><span>                new_fpl</span><span>-&gt;</span><span>user </span><span>=</span><span> get_uid</span><span>(</span><span>fpl</span><span>-&gt;</span><span>user</span><span>);</span></p>
 <p><span>        </span><span>}</span></p>
 <p><span>        </span><span>return</span><span> new_fpl</span><span>;</span></p>
 <p><span>}</span></p></div>
 
 <p><span>Let’s examine a concrete example. Assume we have sockets </span><span>A</span><span> and </span><span>B</span><span>. The </span><span>A</span><span> attempts to pass itself to </span><span>B</span><span>. After the </span><span>SCM_RIGHTS</span><span> datagram is sent, the newly allocated </span><span>skb</span><span> from the sender will be appended to the </span><span>B</span><span>’s </span><span>sk_receive_queue</span><span> which stores received datagrams:</span></p>
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgNWAkA0RVb4goO21_FhJOVV-LSNTfbXV7GKoqH-CUrdMTpDcNUSQxEssrnAVGxC50aK-Z3HfIWeDyCgkr6lb5-a1Ha9Km5ppaHeBzWmLj8NTmZtUjx8J-VzzM1O7mYdjOfw2ErddrslDXw6rDZrs0g1DEC1Ya4VAbkLKKEhZgNPeiSefH-xpv3zDa8/s1438/image71.png"><img alt="unix_stream_sendmsg creates sk_buff which contains the structure scm_fp_list. The scm_fp_list has a fp pointer points to the transmitted file (A). The sk_buff is appended to the receiver queue and the reference count of A is 2." src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgNWAkA0RVb4goO21_FhJOVV-LSNTfbXV7GKoqH-CUrdMTpDcNUSQxEssrnAVGxC50aK-Z3HfIWeDyCgkr6lb5-a1Ha9Km5ppaHeBzWmLj8NTmZtUjx8J-VzzM1O7mYdjOfw2ErddrslDXw6rDZrs0g1DEC1Ya4VAbkLKKEhZgNPeiSefH-xpv3zDa8/s1200/image71.png" title="unix_stream_sendmsg creates sk_buff which contains the structure scm_fp_list. The scm_fp_list has a fp pointer points to the transmitted file (A). The sk_buff is appended to the receiver queue and the reference count of A is 2."/></a></span></p>
 <p><span>sk_buff</span><span> carries </span><span>scm_fp_list</span><span> structure</span></p>
 
 <p><span>The reference count of </span><span>A</span><span> is incremented to 2 and the reference count of </span><span>B</span><span> is still 1.</span></p>
 <h2 id="h.b16dgtqtkmv1"><span>Receiving</span></h2>
 <p><span>Now, let’s take a look at the receiver side </span><span>unix_stream_read_generic</span><span> (we will not discuss the </span><span>MSG_PEEK</span><span> flag yet, and focus on the normal </span><span><a href="https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/af_unix.c#L2445">routine</a></span><span>). First of all, the kernel grabs the current </span><span>skb</span><span> from </span><span>sk_receive_queue</span><span> using </span><span>skb_peek</span><span>. Secondly, since </span><span>scm_fp_list</span><span> is attached to the </span><span>skb</span><span>, the kernel will call </span><span>unix_detach_fds</span><span> (</span><span><a href="https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/scm.c#L125">link</a></span><span>) </span><span>to parse the transmitted file structures from </span><span>skb</span><span> and clear the </span><span>skb</span><span> from </span><span>sk_receive_queue</span><span>:</span></p>
 <div colspan="1" rowspan="1">
 <p><span>/* Mark read part of skb as used */</span></p>
 <p><span>if</span><span> </span><span>(!(</span><span>flags </span><span>&amp;</span><span> MSG_PEEK</span><span>))</span><span> </span><span>{</span></p>
 <p><span>        </span><span>UNIXCB</span><span>(</span><span>skb</span><span>).</span><span>consumed </span><span>+=</span><span> chunk</span><span>;</span></p>
 
 <p><span>        sk_peek_offset_bwd</span><span>(</span><span>sk</span><span>,</span><span> chunk</span><span>);</span></p>
 
 <p><span>        </span><span>if</span><span> </span><span>(</span><span>UNIXCB</span><span>(</span><span>skb</span><span>).</span><span>fp</span><span>)</span></p>
 <p><span>                unix_detach_fds</span><span>(&amp;</span><span>scm</span><span>,</span><span> skb</span><span>);</span></p>
 
 <p><span>        </span><span>if</span><span> </span><span>(</span><span>unix_skb_len</span><span>(</span><span>skb</span><span>))</span></p>
 <p><span>                </span><span>break</span><span>;</span></p>
 
 <p><span>        skb_unlink</span><span>(</span><span>skb</span><span>,</span><span> </span><span>&amp;</span><span>sk</span><span>-&gt;</span><span>sk_receive_queue</span><span>);</span></p>
 <p><span>        consume_skb</span><span>(</span><span>skb</span><span>);</span></p>
 
 <p><span>        </span><span>if</span><span> </span><span>(</span><span>scm</span><span>.</span><span>fp</span><span>)</span></p>
 <p><span>                </span><span>break</span><span>;</span></p></div>
 
 <p><span>The function </span><span>scm_detach_fds</span><span> iterates over the list of passed file descriptors (</span><span>scm-&gt;fp)</span><span> </span><span>and installs the new file descriptors accordingly for the receiver:</span></p><div colspan="1" rowspan="1">
 <p><span>for</span><span> </span><span>(</span><span>i</span><span>=</span><span>0</span><span>,</span><span> cmfptr</span><span>=(</span><span>__force </span><span>int</span><span> __user </span><span>*)</span><span>CMSG_DATA</span><span>(</span><span>cm</span><span>);</span><span> i</span><span>&lt;</span><span>fdmax</span><span>;</span></p>
 <p><span>     i</span><span>++,</span><span> cmfptr</span><span>++)</span></p>
 <p><span>{</span></p>
 <p><span>        </span><span>struct</span><span> socket </span><span>*</span><span>sock</span><span>;</span></p>
 <p><span>        </span><span>int</span><span> new_fd</span><span>;</span></p>
 <p><span>        err </span><span>=</span><span> security_file_receive</span><span>(</span><span>fp</span><span>[</span><span>i</span><span>]);</span></p>
 <p><span>        </span><span>if</span><span> </span><span>(</span><span>err</span><span>)</span></p>
 <p><span>                </span><span>break</span><span>;</span></p>
 <p><span>        err </span><span>=</span><span> get_unused_fd_flags</span><span>(</span><span>MSG_CMSG_CLOEXEC </span><span>&amp;</span><span> msg</span><span>-&gt;</span><span>msg_flags</span></p>
 <p><span>                                  </span><span>?</span><span> O_CLOEXEC </span><span>:</span><span> </span><span>0</span><span>);</span></p>
 <p><span>        </span><span>if</span><span> </span><span>(</span><span>err </span><span>&lt;</span><span> </span><span>0</span><span>)</span></p>
 <p><span>                </span><span>break</span><span>;</span></p>
 <p><span>        new_fd </span><span>=</span><span> err</span><span>;</span></p>
 <p><span>        err </span><span>=</span><span> put_user</span><span>(</span><span>new_fd</span><span>,</span><span> cmfptr</span><span>);</span></p>
 <p><span>        </span><span>if</span><span> </span><span>(</span><span>err</span><span>)</span><span> </span><span>{</span></p>
 <p><span>                put_unused_fd</span><span>(</span><span>new_fd</span><span>);</span></p>
 <p><span>                </span><span>break</span><span>;</span></p>
 <p><span>        </span><span>}</span></p>
 <p><span>        </span><span>/* Bump the usage count and install the file. */</span></p>
 <p><span>        sock </span><span>=</span><span> sock_from_file</span><span>(</span><span>fp</span><span>[</span><span>i</span><span>],</span><span> </span><span>&amp;</span><span>err</span><span>);</span></p>
 <p><span>        </span><span>if</span><span> </span><span>(</span><span>sock</span><span>)</span><span> </span><span>{</span></p>
 <p><span>                sock_update_netprioidx</span><span>(&amp;</span><span>sock</span><span>-&gt;</span><span>sk</span><span>-&gt;</span><span>sk_cgrp_data</span><span>);</span></p>
 <p><span>                sock_update_classid</span><span>(&amp;</span><span>sock</span><span>-&gt;</span><span>sk</span><span>-&gt;</span><span>sk_cgrp_data</span><span>);</span></p>
 <p><span>        </span><span>}</span></p>
 <p><span>        fd_install</span><span>(</span><span>new_fd</span><span>,</span><span> get_file</span><span>(</span><span>fp</span><span>[</span><span>i</span><span>]));</span></p>
 <p><span>}</span></p>
 
 <p><span>…</span></p>
 <p><span>/*</span></p>
 <p><span> * All of the files that fit in the message have had their</span></p>
 <p><span> * usage counts incremented, so we just free the list.</span></p>
 <p><span> */</span></p>
 <p><span>__scm_destroy</span><span>(</span><span>scm</span><span>);</span></p></div>
 
 <p><span>Once the file descriptors have been installed</span><span>, </span><span>__scm_destroy</span><span> (</span><span><a href="https://elixir.bootlin.com/linux/v4.14.277/source/net/core/scm.c#L119">link</a></span><span>) cleans up the allocated </span><span>scm-&gt;fp</span><span> and decrements the file reference count for every transmitted file structure:</span></p><div colspan="1" rowspan="1">
 <p><span>void</span><span> __scm_destroy</span><span>(</span><span>struct</span><span> scm_cookie </span><span>*</span><span>scm</span><span>)</span></p>
 <p><span>{</span></p>
 <p><span>        </span><span>struct</span><span> scm_fp_list </span><span>*</span><span>fpl </span><span>=</span><span> scm</span><span>-&gt;</span><span>fp</span><span>;</span></p>
 <p><span>        </span><span>int</span><span> i</span><span>;</span></p>
 
 <p><span>        </span><span>if</span><span> </span><span>(</span><span>fpl</span><span>)</span><span> </span><span>{</span></p>
 <p><span>                scm</span><span>-&gt;</span><span>fp </span><span>=</span><span> NULL</span><span>;</span></p>
 <p><span>                </span><span>for</span><span> </span><span>(</span><span>i</span><span>=</span><span>fpl</span><span>-&gt;</span><span>count</span><span>-</span><span>1</span><span>;</span><span> i</span><span>&gt;=</span><span>0</span><span>;</span><span> i</span><span>--)</span></p>
 <p><span>                        </span><span>fput</span><span>(</span><span>fpl</span><span>-&gt;</span><span>fp</span><span>[</span><span>i</span><span>]);</span></p>
 <p><span>                free_uid</span><span>(</span><span>fpl</span><span>-&gt;</span><span>user</span><span>);</span></p>
 <p><span>                kfree</span><span>(</span><span>fpl</span><span>);</span></p>
 <p><span>        </span><span>}</span></p>
 <p><span>}</span></p></div><h2 id="h.zi0w3dhxm2me"><span>Reference Counting and Inflight Counting</span></h2>
 <p><span>As mentioned above, when a file descriptor is passed using </span><span>SCM_RIGHTS,</span><span> its reference count is immediately incremented. Once the recipient socket has accepted and installed the passed file descriptor, the reference count is then decremented. The complication comes from the “middle” of this operation: after the file descriptor has been sent, but before the receiver has accepted and installed the file descriptor.</span></p>
 
 <p><span>Let’s consider the following scenario:</span></p><ol start="1"><li><span>The process creates sockets </span><span>A</span><span> and </span><span>B</span><span>.</span></li><li><span>A</span><span> sends socket </span><span>A </span><span>to socket </span><span>B</span><span>.</span></li><li><span>B</span><span> sends socket </span><span>B</span><span> to socket </span><span>A</span><span>.</span></li><li><span>Close </span><span>A</span><span>.</span></li><li><span>Close </span><span>B</span><span>.</span></li></ol>
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEixn2j2I0_3XKxc7uimc_-Bd2F7fUflziTRwXRLeCfzDzrA_GKDsDLvqidYluwq_lGptlzWkZ3DD4f2DGnyjuALHuH46yzHjovkrVdzuG-Ncgi4WphgXf9HK_RPnxB91R07fG7cnyy4wZN-M3qZtb6uKOwarRmxIPdQWbJVA-KQlhKQBBR4EZS6aZDe/s724/image66.png"><img alt="Socket A and B form a reference count cycle." src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEixn2j2I0_3XKxc7uimc_-Bd2F7fUflziTRwXRLeCfzDzrA_GKDsDLvqidYluwq_lGptlzWkZ3DD4f2DGnyjuALHuH46yzHjovkrVdzuG-Ncgi4WphgXf9HK_RPnxB91R07fG7cnyy4wZN-M3qZtb6uKOwarRmxIPdQWbJVA-KQlhKQBBR4EZS6aZDe/s724/image66.png" title="Socket A and B form a reference count cycle."/></a></span></p>
 <p><span>Scenario for reference count cycle</span></p>
 
 <p><span>Both sockets are closed prior to accepting the passed file descriptors.The reference counts of </span><span>A</span><span> and </span><span>B</span><span> are both 1 and can&#39;t be further decremented because they were removed from the kernel fd table when the respective processes closed them. Therefore the kernel is unable to release the two skbs and sock structures </span><span>and an unbreakable cycle is formed</span><span>. The Linux kernel garbage collection system is designed to prevent memory exhaustion in this particular scenario. The </span><span>inflight</span><span> count was implemented to identify potential garbage. Each time the reference count is increased due to an SCM_RIGHTS datagram being sent, the </span><span>inflight</span><span> count will also be incremented.</span></p>
 
 <p><span>When a file descriptor is sent by </span><span>SCM_RIGHTS</span><span> datagram,</span><span> the Linux kernel puts its </span><span>unix_sock</span><span> into a global list </span><span>gc_inflight_list</span><span>. The kernel</span><span> </span><span>increments </span><span>unix_tot_inflight</span><span> which counts the total number of inflight sockets. Then, the kernel increments </span><span>u-&gt;inflight</span><span> which tracks the inflight count for each individual file descriptor in the </span><span>unix_inflight</span><span> function (</span><span><a href="https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/scm.c#L45">scm.c#L45</a></span><span>) invoked from </span><span>unix_attach_fds</span><span>:</span></p>
 <div colspan="1" rowspan="1">
 <p><span>void</span><span> unix_inflight</span><span>(</span><span>struct</span><span> user_struct </span><span>*</span><span>user</span><span>,</span><span> </span><span>struct</span><span> file </span><span>*</span><span>fp</span><span>)</span></p>
 <p><span>{</span></p>
 <p><span>        </span><span>struct</span><span> sock </span><span>*</span><span>s </span><span>=</span><span> unix_get_socket</span><span>(</span><span>fp</span><span>);</span></p>
 
 <p><span>        spin_lock</span><span>(&amp;</span><span>unix_gc_lock</span><span>);</span></p>
 
 <p><span>        </span><span>if</span><span> </span><span>(</span><span>s</span><span>)</span><span> </span><span>{</span></p>
 <p><span>                </span><span>struct</span><span> unix_sock </span><span>*</span><span>u </span><span>=</span><span> unix_sk</span><span>(</span><span>s</span><span>);</span></p>
 
 <p><span>                </span><span>if</span><span> </span><span>(</span><span>atomic_long_inc_return</span><span>(&amp;</span><span>u</span><span>-&gt;</span><span>inflight</span><span>)</span><span> </span><span>==</span><span> </span><span>1</span><span>)</span><span> </span><span>{</span></p>
 <p><span>                        BUG_ON</span><span>(!</span><span>list_empty</span><span>(&amp;</span><span>u</span><span>-&gt;</span><span>link</span><span>));</span></p>
 <p><span>                        list_add_tail</span><span>(&amp;</span><span>u</span><span>-&gt;</span><span>link</span><span>,</span><span> </span><span>&amp;</span><span>gc_inflight_list</span><span>);</span></p>
 <p><span>                </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span></p>
 <p><span>                        BUG_ON</span><span>(</span><span>list_empty</span><span>(&amp;</span><span>u</span><span>-&gt;</span><span>link</span><span>));</span></p>
 <p><span>                </span><span>}</span></p>
 <p><span>                unix_tot_inflight</span><span>++;</span></p>
 <p><span>        </span><span>}</span></p>
 <p><span>        user</span><span>-&gt;</span><span>unix_inflight</span><span>++;</span></p>
 <p><span>        spin_unlock</span><span>(&amp;</span><span>unix_gc_lock</span><span>);</span></p>
 <p><span>}</span></p></div>
 
 <p><span>Thus, here is what the </span><span>sk_buff</span><span> looks like when transferring a file descriptor within sockets </span><span>A</span><span> and </span><span>B</span><span>:</span></p>
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg7JYdav9RAoJLT1TJAAfsVJ6kudGtVBqb8V8Xs0DjEVDEfouQv3SX06oh4AmpRx8UrMNnjqhe0i0FYB6c2jjNtiwGSa1LpHSsg-0AI270tzyX2ziVEHuOO69qTIYhjj780S0oMvXfrdAuyNImJYtBfZ8oUV869w62NV5wshFX3cM0hpmPW219HZT3u/s756/image64.png"><img alt="When the file descriptor A sends itself to the file descriptor B, the reference count of the file descriptor A is 2 and the inflight count is 1. For the receiver file descriptor B, the file reference count is 1 and the inflight count is 0." src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg7JYdav9RAoJLT1TJAAfsVJ6kudGtVBqb8V8Xs0DjEVDEfouQv3SX06oh4AmpRx8UrMNnjqhe0i0FYB6c2jjNtiwGSa1LpHSsg-0AI270tzyX2ziVEHuOO69qTIYhjj780S0oMvXfrdAuyNImJYtBfZ8oUV869w62NV5wshFX3cM0hpmPW219HZT3u/s756/image64.png" title="When the file descriptor A sends itself to the file descriptor B, the reference count of the file descriptor A is 2 and the inflight count is 1. For the receiver file descriptor B, the file reference count is 1 and the inflight count is 0."/></a></span></p>
 <p><span>The inflight count of </span><span>A</span><span> is incremented</span></p>
 <p><span>When the socket file descriptor is received from the other side, the </span><span>unix_sock.inflight</span><span> count will be decremented.</span></p>
 
 <p><span>Let’s revisit the reference count cycle scenario before the close syscall. </span><span>This cycle is breakable because any socket files can receive the transmitted file and break the reference cycle:</span><span> </span></p>
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgXASWOd1HPgwueBa5J636vqpj3uP4onThAwMEL0K_ZBBh3mUr5WklN_YPLIYzXaKl2aSpzcf_odw0ymXe-k7wewgh592dQfkj8AYn6r4jHVh6TXpML2-zsCyFt6ZjmR8N-hcyCeHIwVDjtgCGuRU-YfulCdMk5GWTu9h7X8N7iuCV7GXkzLOKEwFy9/s704/image70.png"><img alt="The file descriptor A sends itself to the file descriptor B and vice versa. The inflight count of the file descriptor A and B is both 1 and the file reference count is both 2." src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgXASWOd1HPgwueBa5J636vqpj3uP4onThAwMEL0K_ZBBh3mUr5WklN_YPLIYzXaKl2aSpzcf_odw0ymXe-k7wewgh592dQfkj8AYn6r4jHVh6TXpML2-zsCyFt6ZjmR8N-hcyCeHIwVDjtgCGuRU-YfulCdMk5GWTu9h7X8N7iuCV7GXkzLOKEwFy9/s704/image70.png" title="The file descriptor A sends itself to the file descriptor B and vice versa. The inflight count of the file descriptor A and B is both 1 and the file reference count is both 2."/></a></span></p>
 <p><span>Breakable cycle before close </span><span>A</span><span> and </span><span>B</span></p>
 <p><span>After closing both of the file descriptors, the reference count equals the inflight count for each of the socket file descriptors, which is a sign of possible garbage:</span></p>
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhiLYC-jGxNwF2UbjAZgIsusMaCUGbBo61ZVRxLljS27iXShVhfCth-_lXBBevW9hyWaIcKBWdkX_6BixTMWNDoE56ZrUFbiKLolrc8orEqPTp_0ITjwRfxUzJZwvaJZWkomMlkM-_Lqr1DdFQVKjnEW_nnuSOz51JCvu-xZDterJudPenVekqGpqP-/s700/image61.png"><img alt="The cycle becomes unbreakable after closing A and B. The reference count equals to the inflight count for A and B." src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhiLYC-jGxNwF2UbjAZgIsusMaCUGbBo61ZVRxLljS27iXShVhfCth-_lXBBevW9hyWaIcKBWdkX_6BixTMWNDoE56ZrUFbiKLolrc8orEqPTp_0ITjwRfxUzJZwvaJZWkomMlkM-_Lqr1DdFQVKjnEW_nnuSOz51JCvu-xZDterJudPenVekqGpqP-/s700/image61.png" title="The cycle becomes unbreakable after closing A and B. The reference count equals to the inflight count for A and B."/></a></span></p>
 <p><span>Unbreakable cycle after close </span><span>A</span><span> and </span><span>B</span></p>
 <p><span>Now, let’s check another example. </span><span>Assume we have sockets </span><span>A</span><span>, </span><span>B</span><span> and </span><span>𝛼</span><span>:</span></p><ol start="1"><li><span>A</span><span> sends socket </span><span>A</span><span> to socket </span><span>B</span><span>.</span></li><li><span>B</span><span> sends socket </span><span>B</span><span> to socket </span><span>A</span><span>.</span></li><li><span>B</span><span> sends socket </span><span>B</span><span> to socket </span><span>𝛼</span><span>.</span></li><li><span>𝛼</span><span> sends socket </span><span>𝛼</span><span> to socket </span><span>B</span><span>.</span></li><li><span>Close </span><span>A</span><span>.</span></li><li><span>Close </span><span>B</span><span>.</span></li></ol>
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgnuMdkCyfn1Xhzr4NJiNcf3Oxt8ZB8kCVOZEIIVcuTGoHGEq37NFy44gE-wgNaaIZiwoSE0iWSpfifiXtfEMc0qec9_Lih7VE3xqzQJ6PjIGMT7K6Jcz0VLfYELIev025FXRJbnmnKHdChHBnk7DnjFQSRe0kB8k9zoXBP_ZYh7SYlCkQ08qHYhyxY/s1999/image68.png"><img alt="A, B and alpha form a breakable cycle." src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgnuMdkCyfn1Xhzr4NJiNcf3Oxt8ZB8kCVOZEIIVcuTGoHGEq37NFy44gE-wgNaaIZiwoSE0iWSpfifiXtfEMc0qec9_Lih7VE3xqzQJ6PjIGMT7K6Jcz0VLfYELIev025FXRJbnmnKHdChHBnk7DnjFQSRe0kB8k9zoXBP_ZYh7SYlCkQ08qHYhyxY/s1200/image68.png" title="A, B and alpha form a breakable cycle."/></a></span></p>
 <p><span>Breakable cycle for </span><span>A</span><span>, </span><span>B</span><span> </span><span>and</span><span> </span><span>𝛼</span></p>
 <p><span>The cycle is breakable, because </span><span>we can get newly installed file descriptor </span><span>B</span><span>’</span><span> from the socket file descriptor </span><span>𝛼</span><span> and newly installed file descriptor </span><span>A&#39;</span><span> from </span><span>B</span><span>’.</span></p><h2 id="h.6bkr31v5bx7w"><span>Garbage Collection</span></h2>
 <p><span>A h</span><span>igh level view of garbage collection is available from </span><span><a href="https://lwn.net/Articles/779472/">lwn.net</a></span><span>:</span></p>
 
 <p><span>&#34;</span><span>If, instead, the two counts are equal, that file structure might be part of an unreachable cycle. To determine whether that is the case, the kernel finds the set of all in-flight Unix-domain sockets for which all references are contained in SCM_RIGHTS datagrams (for which f_count and inflight are equal, in other words). It then counts how many references to each of those sockets come from SCM_RIGHTS datagrams attached to sockets in this set. Any socket that has references coming from outside the set is reachable and can be removed from the set. If it is reachable, and if there are any SCM_RIGHTS datagrams waiting to be consumed attached to it, the files contained within that datagram are also reachable and can be removed from the set.</span></p>
 
 <p><span>At the end of an iterative process, the kernel may find itself with a set of in-flight Unix-domain sockets that are only referenced by unconsumed (and unconsumable) SCM_RIGHTS datagrams; at this point, it has a cycle of file structures holding the only references to each other. Removing those datagrams from the queue, releasing the references they hold, and discarding them will break the cycle.&#34;</span></p>
 
 <p><span>To be more specific, the </span><span>SCM_RIGHTS</span><span> garbage collection system was developed in order to handle the unbreakable reference cycles. To identify which file descriptors are a part of unbreakable cycles:</span></p><ol start="1"><li><span>Add any </span><span>unix_sock</span><span> objects whose reference count equals its inflight count to the </span><span>gc_candidates</span><span> list.</span></li><li><span>Determine if the socket is referenced by any sockets outside of the </span><span>gc_candidates</span><span> list. If it is then it is reachable, remove it and any sockets it references from the </span><span>gc_candidates</span><span> list. </span><span>Repeat until no more reachable sockets are found.</span></li><li><span>After this iterative process, only sockets who are solely referenced by other sockets within the </span><span>gc_candidates</span><span> list are left. </span></li></ol>
 
 <p><span>Let’s take a closer look at how this garbage collection process works. First, the kernel finds all the </span><span>unix_sock</span><span> objects whose reference counts equals their inflight count and puts them into the </span><span>gc_candidates</span><span> </span><span>list</span><span> (</span><span><a href="https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/garbage.c#L242">garbage.c#L242)</a></span><span>:</span></p>
 <div colspan="1" rowspan="1">
 <p><span>list_for_each_entry_safe</span><span>(</span><span>u</span><span>,</span><span> </span><span>next</span><span>,</span><span> </span><span>&amp;</span><span>gc_inflight_list</span><span>,</span><span> link</span><span>)</span><span> </span><span>{</span></p>
 <p><span>        </span><span>long</span><span> total_refs</span><span>;</span></p>
 <p><span>        </span><span>long</span><span> inflight_refs</span><span>;</span></p>
 
 <p><span>        total_refs </span><span>=</span><span> file_count</span><span>(</span><span>u</span><span>-&gt;</span><span>sk</span><span>.</span><span>sk_socket</span><span>-&gt;</span><span>file</span><span>);</span></p>
 <p><span>        inflight_refs </span><span>=</span><span> atomic_long_read</span><span>(&amp;</span><span>u</span><span>-&gt;</span><span>inflight</span><span>);</span></p>
 
 <p><span>        BUG_ON</span><span>(</span><span>inflight_refs </span><span>&lt;</span><span> </span><span>1</span><span>);</span></p>
 <p><span>        BUG_ON</span><span>(</span><span>total_refs </span><span>&lt;</span><span> inflight_refs</span><span>);</span></p>
 <p><span>        </span><span>if</span><span> </span><span>(</span><span>total_refs </span><span>==</span><span> inflight_refs</span><span>)</span><span> </span><span>{</span></p>
 <p><span>                list_move_tail</span><span>(&amp;</span><span>u</span><span>-&gt;</span><span>link</span><span>,</span><span> </span><span>&amp;</span><span>gc_candidates</span><span>);</span></p>
 <p><span>                __set_bit</span><span>(</span><span>UNIX_GC_CANDIDATE</span><span>,</span><span> </span><span>&amp;</span><span>u</span><span>-&gt;</span><span>gc_flags</span><span>);</span></p>
 <p><span>                __set_bit</span><span>(</span><span>UNIX_GC_MAYBE_CYCLE</span><span>,</span><span> </span><span>&amp;</span><span>u</span><span>-&gt;</span><span>gc_flags</span><span>);</span></p>
 <p><span>        </span><span>}</span></p>
 <p><span>}</span></p></div>
 
 <p><span>Next, the kernel removes any sockets that are referenced by other sockets outside of the current </span><span>gc_candidates</span><span> list. To do this, the kernel invokes </span><span>scan_children</span><span> (</span><span><a href="https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/garbage.c#L138">garbage.c#138</a></span><span>) along with the function pointer </span><span>dec_inflight</span><span> to iterate through each candidate’s </span><span>sk-&gt;receive_queue</span><span>.</span><span> It decreases the inflight count for each of the passed file descriptors that are themselves candidates for garbage collection (</span><span><a href="https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/garbage.c#L261">garbage.c#L261</a></span><span>):</span></p>
 <div colspan="1" rowspan="1">
 <p><span>/* Now remove all internal in-flight reference to children of</span></p>
 <p><span> * the candidates.</span></p>
 <p><span> */</span></p>
 <p><span>list_for_each_entry</span><span>(</span><span>u</span><span>,</span><span> </span><span>&amp;</span><span>gc_candidates</span><span>,</span><span> link</span><span>)</span></p>
 <p><span>        scan_children</span><span>(&amp;</span><span>u</span><span>-&gt;</span><span>sk</span><span>,</span><span> dec_inflight</span><span>,</span><span> NULL</span><span>);</span></p></div>
 
 <p><span>After iterating through all the candidates, if a gc candidate still has a positive inflight count it means that it is referenced by objects outside of the </span><span>gc_candidates</span><span> list and therefore is reachable. These candidates should not be included in the </span><span>gc_candidates</span><span> list so the related inflight counts need to be restored.</span></p>
 
 <p><span>To do this, the kernel will put the candidate to </span><span>not_cycle_list</span><span> instead and iterates through its receiver queue of each transmitted file in the </span><span>gc_candidates</span><span> </span><span>list</span><span> (</span><span><a href="https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/garbage.c#L281">garbage.c#L281</a></span><span>) and increments the inflight count back. The entire process is done recursively, i</span><span>n order for the garbage collection to avoid purging reachable sockets:</span></p>
 <div colspan="1" rowspan="1">
 <p><span>/* Restore the references for children of all candidates,</span></p>
 <p><span> * which have remaining references.  Do this recursively, so</span></p>
 <p><span> * only those remain, which form cyclic references.</span></p>
 <p><span> *</span></p>
 <p><span> * Use a &#34;cursor&#34; link, to make the list traversal safe, even</span></p>
 <p><span> * though elements might be moved about.</span></p>
 <p><span> */</span></p>
 <p><span>list_add</span><span>(&amp;</span><span>cursor</span><span>,</span><span> </span><span>&amp;</span><span>gc_candidates</span><span>);</span></p>
 <p><span>while</span><span> </span><span>(</span><span>cursor</span><span>.</span><span>next</span><span> </span><span>!=</span><span> </span><span>&amp;</span><span>gc_candidates</span><span>)</span><span> </span><span>{</span></p>
 <p><span>        u </span><span>=</span><span> list_entry</span><span>(</span><span>cursor</span><span>.</span><span>next</span><span>,</span><span> </span><span>struct</span><span> unix_sock</span><span>,</span><span> link</span><span>);</span></p>
 
 <p><span>        </span><span>/* Move cursor to after the current position. */</span></p>
 <p><span>        list_move</span><span>(&amp;</span><span>cursor</span><span>,</span><span> </span><span>&amp;</span><span>u</span><span>-&gt;</span><span>link</span><span>);</span></p>
 
 <p><span>        </span><span>if</span><span> </span><span>(</span><span>atomic_long_read</span><span>(&amp;</span><span>u</span><span>-&gt;</span><span>inflight</span><span>)</span><span> </span><span>&gt;</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span></p>
 <p><span>                list_move_tail</span><span>(&amp;</span><span>u</span><span>-&gt;</span><span>link</span><span>,</span><span> </span><span>&amp;</span><span>not_cycle_list</span><span>);</span></p>
 <p><span>                __clear_bit</span><span>(</span><span>UNIX_GC_MAYBE_CYCLE</span><span>,</span><span> </span><span>&amp;</span><span>u</span><span>-&gt;</span><span>gc_flags</span><span>);</span></p>
 <p><span>                scan_children</span><span>(&amp;</span><span>u</span><span>-&gt;</span><span>sk</span><span>,</span><span> inc_inflight_move_tail</span><span>,</span><span> NULL</span><span>);</span></p>
 <p><span>        </span><span>}</span></p>
 <p><span>}</span></p>
 <p><span>list_del</span><span>(&amp;</span><span>cursor</span><span>);</span></p></div>
 
 <p><span>Now </span><span>gc_candidates</span><span> contains only “garbage”. The kernel restores original inflight counts from </span><span>gc_candidates</span><span>, moves candidates from </span><span>not_cycle_list</span><span> back to </span><span>gc_inflight_list</span><span> and invokes </span><span>__skb_queue_purge</span><span> for cleaning up </span><span>garbage</span><span> (</span><span><a href="https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/garbage.c#L306">garbage.c#L306</a></span><span>).</span></p>
 <div colspan="1" rowspan="1">
 <p><span>/* Now gc_candidates contains only garbage.  Restore original</span></p>
 <p><span> * inflight counters for these as well, and remove the skbuffs</span></p>
 <p><span> * which are creating the cycle(s).</span></p>
 <p><span> */</span></p>
 <p><span>skb_queue_head_init</span><span>(&amp;</span><span>hitlist</span><span>);</span></p>
 <p><span>list_for_each_entry</span><span>(</span><span>u</span><span>,</span><span> </span><span>&amp;</span><span>gc_candidates</span><span>,</span><span> link</span><span>)</span></p>
 <p><span>        scan_children</span><span>(&amp;</span><span>u</span><span>-&gt;</span><span>sk</span><span>,</span><span> inc_inflight</span><span>,</span><span> </span><span>&amp;</span><span>hitlist</span><span>);</span></p>
 
 <p><span>/* not_cycle_list contains those sockets which do not make up a</span></p>
 <p><span> * cycle.  Restore these to the inflight list.</span></p>
 <p><span> */</span></p>
 <p><span>while</span><span> </span><span>(!</span><span>list_empty</span><span>(&amp;</span><span>not_cycle_list</span><span>))</span><span> </span><span>{</span></p>
 <p><span>        u </span><span>=</span><span> list_entry</span><span>(</span><span>not_cycle_list</span><span>.</span><span>next</span><span>,</span><span> </span><span>struct</span><span> unix_sock</span><span>,</span><span> link</span><span>);</span></p>
 <p><span>        __clear_bit</span><span>(</span><span>UNIX_GC_CANDIDATE</span><span>,</span><span> </span><span>&amp;</span><span>u</span><span>-&gt;</span><span>gc_flags</span><span>);</span></p>
 <p><span>        list_move_tail</span><span>(&amp;</span><span>u</span><span>-&gt;</span><span>link</span><span>,</span><span> </span><span>&amp;</span><span>gc_inflight_list</span><span>);</span></p>
 <p><span>}</span></p>
 
 <p><span>spin_unlock</span><span>(&amp;</span><span>unix_gc_lock</span><span>);</span></p>
 
 <p><span>/* Here we are. Hitlist is filled. Die. */</span></p>
 <p><span>__skb_queue_purge</span><span>(&amp;</span><span>hitlist</span><span>);</span></p>
 
 <p><span>spin_lock</span><span>(&amp;</span><span>unix_gc_lock</span><span>);</span></p></div>
 
 <p><span>__skb_queue_purge</span><span> clears every </span><span>skb</span><span> from the receiver queue:</span></p>
 <div colspan="1" rowspan="1">
 <p><span>/**</span></p>
 <p><span> *      __skb_queue_purge - empty a list</span></p>
 <p><span> *      @list: list to empty</span></p>
 <p><span> *</span></p>
 <p><span> *      Delete all buffers on an &amp;sk_buff list. Each buffer is removed from</span></p>
 <p><span> *      the list and one reference dropped. This function does not take the</span></p>
 <p><span> *      list lock and the caller must hold the relevant locks to use it.</span></p>
 <p><span> */</span></p>
 <p><span>void</span><span> skb_queue_purge</span><span>(</span><span>struct</span><span> sk_buff_head </span><span>*</span><span>list</span><span>);</span></p>
 <p><span>static</span><span> </span><span>inline</span><span> </span><span>void</span><span> __skb_queue_purge</span><span>(</span><span>struct</span><span> sk_buff_head </span><span>*</span><span>list</span><span>)</span></p>
 <p><span>{</span></p>
 <p><span>        </span><span>struct</span><span> sk_buff </span><span>*</span><span>skb</span><span>;</span></p>
 <p><span>        </span><span>while</span><span> </span><span>((</span><span>skb </span><span>=</span><span> __skb_dequeue</span><span>(</span><span>list</span><span>))</span><span> </span><span>!=</span><span> NULL</span><span>)</span></p>
 <p><span>                kfree_skb</span><span>(</span><span>skb</span><span>);</span></p>
 <p><span>}</span></p></div>
 
 <p><span>There are two ways to trigger the garbage collection process:</span></p><ol start="1"><li><span>wait_for_unix_gc</span><span> is invoked at the beginning of the </span><span>sendmsg</span><span> function if there are more than 16,000 inflight sockets</span></li><li><span>When a </span><span>socket file</span><span> is released by the kernel (i.e., a file descriptor is closed), the kernel will directly invoke </span><span>unix_gc</span><span>.</span></li></ol>
 
 <p><span>Note that </span><span>unix_gc</span><span> is not preemptive. If garbage collection is already in process, the kernel will not perform another </span><span>unix_gc</span><span> invocation.</span></p>
 
 <p><span>Now, let’s check this example (a breakable cycle) with a pair of sockets </span><span>f0</span><span>0</span><span> and </span><span>f0</span><span>1</span><span>,</span><span> and a single socket </span><span>𝛼</span><span>:</span></p><ol start="1"><li><span>Socket </span><span>f </span><span>0</span><span>0</span><span> sends socket </span><span>f </span><span>0</span><span>0</span><span> </span><span>to socket </span><span>f </span><span>0</span><span>1</span><span>.</span></li><li><span>Socket </span><span>f </span><span>0</span><span>1</span><span> sends socket </span><span>f </span><span>0</span><span>1</span><span> to socket </span><span>𝛼</span><span>.</span></li><li><span>Close </span><span>f </span><span>0</span><span>0</span><span>.</span></li><li><span>Close </span><span>f </span><span>0</span><span>1</span><span>.</span></li></ol>
 
 <p><span>Before starting the garbage collection process, the status of socket file descriptors are:</span></p><ul><li><span>f </span><span>0</span><span>0</span><span>: ref = 1, inflight = 1</span></li><li><span>f </span><span>0</span><span>1</span><span>: ref = 1, inflight = 1</span></li><li><span>𝛼</span><span>: ref = 1, inflight = 0</span></li></ul>
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhfD3EkqhRCP3nucxrm7-5h2T0Z0Q9e2xWhLX_CA07nU5IWXOAejwDvqPBd2CeJVLrM5bg502cpkm2noANVBV24QVmHRGA3IkHF_at3u6i2rYCHZH4wpvS5EfIC6ibJgtZb4LSO2IjdNbqw_PawxHzGAI9LtmhXRO5rv8SDTHa5mwncMXptSJmjnBZx/s834/image69.png"><img alt="f00, f01 and alpha form a breakable cycle." src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhfD3EkqhRCP3nucxrm7-5h2T0Z0Q9e2xWhLX_CA07nU5IWXOAejwDvqPBd2CeJVLrM5bg502cpkm2noANVBV24QVmHRGA3IkHF_at3u6i2rYCHZH4wpvS5EfIC6ibJgtZb4LSO2IjdNbqw_PawxHzGAI9LtmhXRO5rv8SDTHa5mwncMXptSJmjnBZx/s834/image69.png" title="f00, f01 and alpha form a breakable cycle."/></a></span></p>
 <p><span>Breakable cycle by </span><span>f </span><span>0</span><span>0</span><span>, </span><span>f </span><span>0</span><span>1</span><span> and </span><span>𝛼</span></p>
 
 <p><span>During the garbage collection process, </span><span>f </span><span>0</span><span>0</span><span> </span><span>and </span><span>f </span><span>0</span><span>1</span><span> </span><span>are considered garbage candidates. The inflight count of </span><span>f </span><span>0</span><span>0</span><span> is dropped to zero, but the count of </span><span>f </span><span>0</span><span>1</span><span> is still 1 because </span><span>𝛼</span><span> is not a candidate. Thus, the kernel will restore the inflight count from </span><span>f </span><span>0</span><span>1</span><span>’s</span><span> receive queue. As a result, </span><span>f </span><span>0</span><span>0</span><span> and </span><span>f </span><span>0</span><span>1</span><span> are not treated as garbage anymore.</span></p>
 <p><span>When</span><span> a user receives </span><span>SCM_RIGHTS</span><span> message from </span><span>recvmsg</span><span> without the </span><span>MSG_PEEK</span><span> flag, the kernel will wait until the garbage collection process finishes if it is in progress. However, if the </span><span>MSG_PEEK</span><span> flag is on, the kernel will increment the reference count of the transmitted file structures without synchronizing with any ongoing garbage collection process. This may lead to inconsistency of the internal garbage collection state, making the garbage collector mark a non-garbage sock object as garbage to purge.</span></p>
 <h2 id="h.7lz5lcv6k4oi"><span>r</span><span>ecvmsg without MSG_PEEK flag</span></h2>
 <p><span>The kernel function</span><span> </span><span>unix_stream_read_generic</span><span> (</span><span><a href="https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/af_unix.c#L2290">af_unix.c#L2290</a></span><span>) parses the </span><span>SCM_RIGHTS</span><span> message and manages the file inflight count when the </span><span>MSG_PEEK</span><span> flag is </span><span>NOT</span><span> set. Then, the function </span><span>unix_stream_read_generic</span><span> calls </span><span>unix_detach_fds</span><span> to decrement the inflight count. Then, </span><span>unix_detach_fds</span><span> clears the list of passed file descriptors (</span><span>scm_fp_list</span><span>) from the </span><span>skb</span><span>:</span></p>
 <div colspan="1" rowspan="1">
 <p><span>static</span><span> </span><span>void</span><span> unix_detach_fds</span><span>(</span><span>struct</span><span> scm_cookie </span><span>*</span><span>scm</span><span>,</span><span> </span><span>struct</span><span> sk_buff </span><span>*</span><span>skb</span><span>)</span></p>
 <p><span>{</span></p>
 <p><span>        </span><span>int</span><span> i</span><span>;</span></p>
 
 <p><span>        scm</span><span>-&gt;</span><span>fp </span><span>=</span><span> UNIXCB</span><span>(</span><span>skb</span><span>).</span><span>fp</span><span>;</span></p>
 <p><span>        </span><span>UNIXCB</span><span>(</span><span>skb</span><span>).</span><span>fp </span><span>=</span><span> NULL</span><span>;</span></p>
 
 <p><span>        </span><span>for</span><span> </span><span>(</span><span>i </span><span>=</span><span> scm</span><span>-&gt;</span><span>fp</span><span>-&gt;</span><span>count</span><span>-</span><span>1</span><span>;</span><span> i </span><span>&gt;=</span><span> </span><span>0</span><span>;</span><span> i</span><span>--)</span></p>
 <p><span>                unix_notinflight</span><span>(</span><span>scm</span><span>-&gt;</span><span>fp</span><span>-&gt;</span><span>user</span><span>,</span><span> scm</span><span>-&gt;</span><span>fp</span><span>-&gt;</span><span>fp</span><span>[</span><span>i</span><span>]);</span></p>
 <p><span>}</span></p></div>
 
 <p><span>The </span><span>unix_notinflight</span><span> from </span><span>unix_detach_fds</span><span> will reverse the effect of </span><span>unix_inflight</span><span> by decrementing the inflight count:</span></p>
 <div colspan="1" rowspan="1">
 <p><span>void</span><span> unix_notinflight</span><span>(</span><span>struct</span><span> user_struct </span><span>*</span><span>user</span><span>,</span><span> </span><span>struct</span><span> file </span><span>*</span><span>fp</span><span>)</span></p>
 <p><span>{</span></p>
 <p><span>        </span><span>struct</span><span> sock </span><span>*</span><span>s </span><span>=</span><span> unix_get_socket</span><span>(</span><span>fp</span><span>);</span></p>
 
 <p><span>        spin_lock</span><span>(&amp;</span><span>unix_gc_lock</span><span>);</span></p>
 
 <p><span>        </span><span>if</span><span> </span><span>(</span><span>s</span><span>)</span><span> </span><span>{</span></p>
 <p><span>                </span><span>struct</span><span> unix_sock </span><span>*</span><span>u </span><span>=</span><span> unix_sk</span><span>(</span><span>s</span><span>);</span></p>
 
 <p><span>                BUG_ON</span><span>(!</span><span>atomic_long_read</span><span>(&amp;</span><span>u</span><span>-&gt;</span><span>inflight</span><span>));</span></p>
 <p><span>                BUG_ON</span><span>(</span><span>list_empty</span><span>(&amp;</span><span>u</span><span>-&gt;</span><span>link</span><span>));</span></p>
 
 <p><span>                </span><span>if</span><span> </span><span>(</span><span>atomic_long_dec_and_test</span><span>(&amp;</span><span>u</span><span>-&gt;</span><span>inflight</span><span>))</span></p>
 <p><span>                        list_del_init</span><span>(&amp;</span><span>u</span><span>-&gt;</span><span>link</span><span>);</span></p>
 <p><span>                unix_tot_inflight</span><span>--;</span></p>
 <p><span>        </span><span>}</span></p>
 <p><span>        user</span><span>-&gt;</span><span>unix_inflight</span><span>--;</span></p>
 <p><span>        spin_unlock</span><span>(&amp;</span><span>unix_gc_lock</span><span>);</span></p>
 <p><span>}</span></p></div>
 
 <p><span>Later </span><span>skb_unlink</span><span> and </span><span>consume_skb</span><span> are invoked from </span><span>unix_stream_read_generic</span><span> </span><span>(</span><span><a href="https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/af_unix.c#L2451">af_unix.c#2451</a></span><span>)</span><span> to destroy the current </span><span>skb</span><span>. Following the call chain </span><span>kfree(skb)-&gt;__kfree_skb</span><span>, the kernel will invoke the function pointer </span><span>skb-&gt;destructor</span><span> (</span><span><a href="https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/af_unix.c#L1605">code</a></span><span>) which redirects to </span><span>unix_destruct_scm</span><span>:</span></p>
 <div colspan="1" rowspan="1">
 <p><span>static</span><span> </span><span>void</span><span> unix_destruct_scm</span><span>(</span><span>struct</span><span> sk_buff </span><span>*</span><span>skb</span><span>)</span></p>
 <p><span>{</span></p>
 <p><span>        </span><span>struct</span><span> scm_cookie scm</span><span>;</span></p>
 <p><span>        memset</span><span>(&amp;</span><span>scm</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>sizeof</span><span>(</span><span>scm</span><span>));</span></p>
 <p><span>        scm</span><span>.</span><span>pid  </span><span>=</span><span> UNIXCB</span><span>(</span><span>skb</span><span>).</span><span>pid</span><span>;</span></p>
 <p><span>        </span><span>if</span><span> </span><span>(</span><span>UNIXCB</span><span>(</span><span>skb</span><span>).</span><span>fp</span><span>)</span></p>
 <p><span>                unix_detach_fds</span><span>(&amp;</span><span>scm</span><span>,</span><span> skb</span><span>);</span></p>
 
 <p><span>        </span><span>/* Alas, it calls VFS */</span></p>
 <p><span>        </span><span>/* So fscking what? fput() had been SMP-safe since the last Summer */</span></p>
 <p><span>        scm_destroy</span><span>(&amp;</span><span>scm</span><span>);</span></p>
 <p><span>        sock_wfree</span><span>(</span><span>skb</span><span>);</span></p>
 <p><span>}</span></p></div>
 
 <p><span>In fact, the </span><span>unix_detach_fds</span><span> will not be invoked again here from </span><span>unix_destruct_scm</span><span> because </span><span>UNIXCB(skb).fp</span><span> is already cleared by </span><span>unix_detach_fds</span><span>. Finally, </span><span>fd_install(new_fd, get_file(fp[i]))</span><span> from </span><span>scm_detach_fds</span><span> is invoked for installing a new file descriptor.</span></p>
 <h2 id="h.yfq48nayx2kg"><span>r</span><span>ecvmsg with MSG_PEEK flag</span></h2>
 <p><span>The </span><span>recvmsg</span><span> process is different i</span><span>f the </span><span>MSG_PEEK</span><span> flag is set. The </span><span>MSG_PEEK</span><span> flag is used during receive to “peek” at the message, but the data is treated as unread. </span><span>unix_stream_read_generic</span><span> will invoke </span><span>scm_fp_dup</span><span> instead of </span><span>unix_detach_fds</span><span>. </span><span>This increases the reference count of the inflight file (</span><span><a href="https://android.googlesource.com/kernel/goldfish/+/eee65a1282369eedfcbb664d0c865a0ef3eb7017/net/unix/af_unix.c#2149">af_unix.c#2149</a></span><span>)</span><span>:</span></p>
 <div colspan="1" rowspan="1">
 <p><span>/* It is questionable, see note in unix_dgram_recvmsg.</span></p>
 <p><span> */</span></p>
 <p><span>if</span><span> </span><span>(</span><span>UNIXCB</span><span>(</span><span>skb</span><span>).</span><span>fp</span><span>)</span></p>
 <p><span>        scm</span><span>.</span><span>fp </span><span>=</span><span> scm_fp_dup</span><span>(</span><span>UNIXCB</span><span>(</span><span>skb</span><span>).</span><span>fp</span><span>);</span></p>
 
 <p><span>sk_peek_offset_fwd</span><span>(</span><span>sk</span><span>,</span><span> chunk</span><span>);</span></p>
 
 <p><span>if</span><span> </span><span>(</span><span>UNIXCB</span><span>(</span><span>skb</span><span>).</span><span>fp</span><span>)</span></p>
 <p><span>        </span><span>break</span><span>;</span></p></div>
 
 <p><span>Because the data should be treated as unread, the </span><span>skb</span><span> is not unlinked and consumed when the </span><span>MSG_PEEK</span><span> flag is set. However, the receiver will still get a new file descriptor for the inflight socket.</span></p>
 <h2 id="h.4kuedi8b9x2y"><span>recvmsg </span><span>Examples</span></h2>
 <p><span>Let’s see a concrete example. Assume there are the following socket pairs:</span></p><ul><li><span>f </span><span>0</span><span>0</span><span>, </span><span>f </span><span>0</span><span>1</span></li><li><span>f </span><span>1</span><span>0</span><span>, </span><span>f </span><span>1</span><span>1</span></li></ul>
 
 <p><span>Now, the program does the following operations:</span></p><ul><li><span>f </span><span>0</span><span>0</span><span> → [</span><span>f </span><span>0</span><span>0</span><span>] → </span><span>f </span><span>0</span><span>1 </span><span>(means </span><span>f </span><span>0</span><span>0</span><span> sends [</span><span>f </span><span>0</span><span>0</span><span>] to </span><span>f </span><span>0</span><span>1</span><span>)</span></li><li><span>f </span><span>1</span><span>0</span><span> → [</span><span>f </span><span>0</span><span>0</span><span>] → </span><span>f </span><span>1</span><span>1</span></li><li><span>Close</span><span>(</span><span>f </span><span>0</span><span>0</span><span>)</span></li></ul>
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhi5B8kJXBAiYH3vq8NcQtmatM_hz8o9KgBZpMbMyd9QwRC84jh-SZo76fLhvSFrRohs4pUhBW48q3fQ0bUu0DlySHyJhDMC69rz8qwEM8nHK4b1RGLMw9QGwPmf4E7iMjo5Noa6eF-GDEuMqa4Gzq0fwiBCXU_x0i_Q7eGd2OqiIbu7lYFFaErVE5o/s1102/image62.png"><img alt="f00, f01, f10, f11 forms a breakable cycle." src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhi5B8kJXBAiYH3vq8NcQtmatM_hz8o9KgBZpMbMyd9QwRC84jh-SZo76fLhvSFrRohs4pUhBW48q3fQ0bUu0DlySHyJhDMC69rz8qwEM8nHK4b1RGLMw9QGwPmf4E7iMjo5Noa6eF-GDEuMqa4Gzq0fwiBCXU_x0i_Q7eGd2OqiIbu7lYFFaErVE5o/s1102/image62.png" title="f00, f01, f10, f11 forms a breakable cycle."/></a></span></p>
 <p><span>Breakable cycle by </span><span>f </span><span>0</span><span>0</span><span>, </span><span>f </span><span>0</span><span>1</span><span>, </span><span>f </span><span>1</span><span>0</span><span> </span><span>and</span><span> </span><span>f </span><span>1</span><span>1</span></p>
 
 <p><span>Here is the status:</span></p><ul><li><span>inflight</span><span>(</span><span>f </span><span>0</span><span>0</span><span>) = 2, </span><span>ref</span><span>(</span><span>f </span><span>0</span><span>0</span><span>) = 2</span></li><li><span>inflight</span><span>(</span><span>f </span><span>0</span><span>1</span><span>) = 0, </span><span>ref</span><span>(</span><span>f </span><span>0</span><span>1</span><span>) = 1</span></li><li><span>inflight</span><span>(</span><span>f </span><span>1</span><span>0</span><span>) = 0, </span><span>ref</span><span>(</span><span>f </span><span>1</span><span>0</span><span>) = 1</span></li><li><span>inflight</span><span>(</span><span>f </span><span>1</span><span>1</span><span>) = 0, </span><span>ref</span><span>(</span><span>f </span><span>1</span><span>1</span><span>) = 1</span></li></ul>
 
 <p><span>If the garbage collection process happens now, before any </span><span>recvmsg</span><span> calls, the kernel will choose </span><span>f </span><span>0</span><span>0</span><span> as the garbage candidate. However, </span><span>f </span><span>0</span><span>0</span><span> will not have the inflight count altered and the kernel will not purge any garbage.</span></p>
 
 <p><span>I</span><span>f </span><span>f </span><span>0</span><span>1</span><span> then calls </span><span>recvmsg</span><span> </span><span>with</span><span> </span><span>MSG_PEEK</span><span> flag, t</span><span>he receive queue doesn’t change and the inflight counts are not decremented. </span><span>f </span><span>0</span><span>1</span><span> gets a new file descriptor </span><span>f </span><span>0</span><span>0</span><span>&#39;</span><span> which increments the </span><span>reference count on </span><span>f </span><span>0</span><span>0</span><span>:</span></p>
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhO9D3ODJFXZt6dQmkyP1e7zZe0smN042wAbdy7isVbd407L-oCrSDS9LDCBshKwft2pWiuKHXQBclib4tQFoou-8U14ZNuyeJMRxDjtuFsTk3B_TDHVQNDl5x8aLt09negBlNpoEzrYgybadh-KbAAGu_U4hqaDNLyOpWFbI06Vjfh1kam2JHuD7yH/s1216/image63.png"><img alt="After f01 receives the socket file descriptor by MSG_PEEK, the reference count of f00 is incremented and the receive queue from f01 remains the same." src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhO9D3ODJFXZt6dQmkyP1e7zZe0smN042wAbdy7isVbd407L-oCrSDS9LDCBshKwft2pWiuKHXQBclib4tQFoou-8U14ZNuyeJMRxDjtuFsTk3B_TDHVQNDl5x8aLt09negBlNpoEzrYgybadh-KbAAGu_U4hqaDNLyOpWFbI06Vjfh1kam2JHuD7yH/s1216/image63.png" title="After f01 receives the socket file descriptor by MSG_PEEK, the reference count of f00 is incremented and the receive queue from f01 remains the same."/></a></span></p>
 <p><span>MSG_PEEK</span><span> increment the reference count of </span><span>f </span><span>0</span><span>0</span><span> while the receive queue is not cleared</span></p>
 
 <p><span>Status:</span></p><ul><li><span>inflight</span><span>(</span><span>f </span><span>0</span><span>0</span><span>) = 2, </span><span>ref</span><span>(</span><span>f </span><span>0</span><span>0</span><span>) = 3</span></li><li><span>inflight</span><span>(</span><span>f </span><span>0</span><span>1</span><span>) = 0, </span><span>ref</span><span>(</span><span>f </span><span>0</span><span>1</span><span>) = 1</span></li><li><span>inflight</span><span>(</span><span>f </span><span>1</span><span>0</span><span>) = 0, </span><span>ref</span><span>(</span><span>f </span><span>1</span><span>0</span><span>) = 1</span></li><li><span>inflight</span><span>(</span><span>f </span><span>1</span><span>1</span><span>) = 0, </span><span>ref</span><span>(</span><span>f </span><span>1</span><span>1</span><span>) = 1</span></li></ul>
 
 <p><span>Then, </span><span>f </span><span>0</span><span>1</span><span> calls </span><span>recvmsg</span><span> </span><span>without</span><span> </span><span>MSG_PEEK</span><span> flag, </span><span>f </span><span>0</span><span>1</span><span>’s receive queue is removed. </span><span>f </span><span>0</span><span>1</span><span> also fetches a new file descriptor </span><span>f </span><span>0</span><span>0</span><span>&#39;&#39;</span><span>:</span></p>
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiNsC7ADpPbHG_EVgFzDOGi6oaXluRrxDKc6kaQAkdwadnfFOu4SbwVESi0-SGHDwu9La-ztndastPnhfiocmhd6fmU0mhCy9a5sDosCQu6eW3x_uu7wHGL5d1c0eMTO3inZlhObh4faQkcGU2fM6zd-cXDjbg6fjS6CKUMpT8Sre9XHefE7Exrt04s/s1344/image67.png"><img alt="After f01 receives the socket file descriptor without MSG_PEEK, the receive queue is cleared and file descriptor f00&#39;&#39;&#39; is obtained." src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiNsC7ADpPbHG_EVgFzDOGi6oaXluRrxDKc6kaQAkdwadnfFOu4SbwVESi0-SGHDwu9La-ztndastPnhfiocmhd6fmU0mhCy9a5sDosCQu6eW3x_uu7wHGL5d1c0eMTO3inZlhObh4faQkcGU2fM6zd-cXDjbg6fjS6CKUMpT8Sre9XHefE7Exrt04s/s1200/image67.png" title="After f01 receives the socket file descriptor without MSG_PEEK, the receive queue is cleared and file descriptor f00&#39;&#39;&#39; is obtained."/></a></span></p>
 <p><span>The receive queue of </span><span>f </span><span>0</span><span>1</span><span> is cleared and </span><span>f </span><span>0</span><span>1</span><span>&#39;&#39;</span><span> is obtained from </span><span>f </span><span>0</span><span>1</span></p>
 
 <p><span>Status:</span></p><ul><li><span>inflight</span><span>(</span><span>f </span><span>0</span><span>0</span><span>) = 1, </span><span>ref</span><span>(</span><span>f </span><span>0</span><span>0</span><span>) = 3</span></li><li><span>inflight</span><span>(</span><span>f </span><span>0</span><span>1</span><span>) = 0, </span><span>ref</span><span>(</span><span>f </span><span>0</span><span>1</span><span>) = 1</span></li><li><span>inflight</span><span>(</span><span>f </span><span>1</span><span>0</span><span>) = 0, </span><span>ref</span><span>(</span><span>f </span><span>1</span><span>0</span><span>) = 1</span></li><li><span>inflight</span><span>(</span><span>f </span><span>1</span><span>1</span><span>) = 0, </span><span>ref</span><span>(</span><span>f </span><span>1</span><span>1</span><span>) = 1</span></li></ul>
 <h2 id="h.v0psi01ks7q2"><span>UAF Scenario</span></h2>
 <p><span>From a very high level perspective, the internal state of Linux garbage collection can be non-deterministic because </span><span>MSG_PEEK</span><span> is not synchronized with the garbage collector. T</span><span>here is a race condition where the garbage collector can treat an inflight socket as a garbage candidate while the file reference is incremented at the same time during the </span><span>MSG_PEEK</span><span> receive. As a consequence, the garbage collector may purge the candidate, freeing the socket buffer, while a receiver may install the file descriptor, leading to a UAF on the </span><span>skb</span><span> object.</span></p>
 
 <p><span>Let’s see how the captured </span><span>0-day</span><span> sample triggers the bug step by step (simplified version, in reality you may need more threads working together, but it should demonstrate the core idea). First of all, the sample allocates the following socket pairs and single socket </span><span>𝛼</span><span>:</span></p><ul><li><span>f </span><span>0</span><span>0</span><span>, </span><span>f </span><span>0</span><span>1</span></li><li><span>f </span><span>1</span><span>0</span><span>, </span><span>f </span><span>1</span><span>1</span></li><li><span>f </span><span>2</span><span>0</span><span>, </span><span>f </span><span>2</span><span>1</span></li><li><span>f </span><span>3</span><span>0</span><span>, </span><span>f </span><span>3</span><span>1</span></li><li><span>sock</span><span> 𝛼</span><span> (actually there might be even thousands of </span><span>𝛼</span><span> for protracting the garbage collection process in order to evade a </span><span>BUG_ON</span><span> check which will be introduced later).</span></li></ul>
 
 <p><span>Now, the program does the below operations:</span></p>
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjAHUeccUboPeEe8ydW1HHpM2R-iibCZnsJSrhByCsnhQHtW4IJcC_8GEPtO3R3GPV5x2C9xJfxT7l6Z3UoqRcUeMtuf65G9wI2tPnd91q_vO7spVOfZgAwjeC6WCILmjs1ED618PGlxgMp196O3odP-fKaqIloMSEYRNory126HtXPNyyXCUWefJew/s564/image17.png"><img alt="" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjAHUeccUboPeEe8ydW1HHpM2R-iibCZnsJSrhByCsnhQHtW4IJcC_8GEPtO3R3GPV5x2C9xJfxT7l6Z3UoqRcUeMtuf65G9wI2tPnd91q_vO7spVOfZgAwjeC6WCILmjs1ED618PGlxgMp196O3odP-fKaqIloMSEYRNory126HtXPNyyXCUWefJew/s564/image17.png" title=""/></a></span></p>
 
 <p><span>Close the following file descriptors prior to any </span><span>recvmsg</span><span> calls:</span></p><ul><li><span>Close</span><span>(</span><span>f </span><span>0</span><span>0</span><span>)</span></li><li><span>Close</span><span>(</span><span>f </span><span>0</span><span>1</span><span>)</span></li><li><span>Close</span><span>(</span><span>f </span><span>1</span><span>1</span><span>)</span></li><li><span>Close</span><span>(</span><span>f </span><span>1</span><span>0</span><span>)</span></li><li><span>Close</span><span>(</span><span>f </span><span>3</span><span>0</span><span>)</span></li><li><span>Close</span><span>(</span><span>f </span><span>3</span><span>1</span><span>)</span></li><li><span>Close</span><span>(𝛼)</span></li></ul>
 
 <p><span>Here is the status:</span></p><ul><li><span>inflight</span><span>(</span><span>f </span><span>0</span><span>0</span><span>) = </span><span>N</span><span> + 1, </span><span>ref</span><span>(</span><span>f </span><span>0</span><span>0</span><span>) = </span><span>N </span><span>+ 1</span></li><li><span>inflight</span><span>(</span><span>f </span><span>0</span><span>1</span><span>) = 2, </span><span>ref</span><span>(</span><span>f </span><span>0</span><span>1</span><span>) = 2</span></li><li><span>inflight</span><span>(</span><span>f </span><span>1</span><span>0</span><span>) = 3, </span><span>ref</span><span>(</span><span>f </span><span>1</span><span>0</span><span>) = 3</span></li><li><span>inflight</span><span>(</span><span>f </span><span>1</span><span>1</span><span>) = 1, </span><span>ref</span><span>(</span><span>f </span><span>1</span><span>1</span><span>) = 1</span></li><li><span>inflight</span><span>(</span><span>f </span><span>2</span><span>0</span><span>) = 0, </span><span>ref</span><span>(</span><span>f </span><span>2</span><span>0</span><span>) = 1</span></li><li><span>inflight</span><span>(</span><span>f </span><span>2</span><span>1</span><span>) = 0, </span><span>ref</span><span>(</span><span>f </span><span>2</span><span>1</span><span>) = 1</span></li><li><span>inflight</span><span>(</span><span>f </span><span>3</span><span>1</span><span>) = 1, </span><span>ref</span><span>(</span><span>f </span><span>3</span><span>1</span><span>) = 1</span></li><li><span>inflight</span><span>(</span><span>𝛼</span><span>) = 1, </span><span>ref</span><span>(</span><span>𝛼</span><span>) = 1</span></li></ul>
 
 <p><span>If the garbage collection process happens now, the kernel will do the following scrutiny:</span></p><ul><li><span>List </span><span>f </span><span>0</span><span>0</span><span>, </span><span>f </span><span>0</span><span>1</span><span>, </span><span>f </span><span>1</span><span>0</span><span>,  </span><span>f </span><span>1</span><span>1</span><span>, </span><span>f </span><span>3</span><span>1</span><span>, </span><span>𝛼</span><span> as garbage candidates. Decrease inflight count for the candidate children in each receive queue.</span></li><li><span>Since </span><span>f </span><span>2</span><span>1</span><span> is not considered a candidate, </span><span>f </span><span>1</span><span>1</span><span>’s inflight count is still above zero.</span></li><li><span>Recursively restore the inflight count.</span></li><li><span>Nothing is considered garbage.</span></li></ul>
 
 <p><span>A potential skb UAF by race condition can be triggered by:</span></p><ol start="1"><li><span>Call </span><span>recvmsg</span><span> with </span><span>MSG_PEEK</span><span> flag from </span><span>f </span><span>2</span><span>1</span><span> to get </span><span>f </span><span>1</span><span>1</span><span>’.</span></li><li><span>Call </span><span>recvmsg</span><span> with </span><span>MSG_PEEK</span><span> flag from </span><span>f </span><span>1</span><span>1</span><span> to get </span><span>f </span><span>1</span><span>0</span><span>’.</span></li><li><span>Concurrently do the following operations:</span></li></ol><ol start="1"><li><span>Call </span><span>recvmsg</span><span> without </span><span>MSG_PEEK</span><span> flag from </span><span>f </span><span>1</span><span>1</span><span> to get </span><span>f </span><span>1</span><span>0</span><span>’’.</span></li><li><span>Call </span><span>recvmsg</span><span> with </span><span>MSG_PEEK</span><span> flag from </span><span>f </span><span>1</span><span>0</span><span>’</span></li></ol>
 
 <p><span>How is it possible? Let’s see a case where the race condition is not hit so there is no UAF:</span></p><table><tbody><tr><td colspan="1" rowspan="1">
 <p><span>Thread 0</span></p></td><td colspan="1" rowspan="1">
 <p><span>Thread 1</span></p></td><td colspan="1" rowspan="1">
 <p><span>Thread 2</span></p></td></tr><tr><td colspan="1" rowspan="1">
 <p><span>Call unix_gc</span></p></td><td colspan="1" rowspan="1">
 </td><td colspan="1" rowspan="1">
 </td></tr><tr><td colspan="1" rowspan="1">
 <p><span>Stage0: List </span><span>f </span><span>0</span><span>0</span><span>, </span><span>f </span><span>0</span><span>1</span><span>, </span><span>f </span><span>1</span><span>0</span><span>,  </span><span>f </span><span>1</span><span>1</span><span>, </span><span>f </span><span>3</span><span>1</span><span>, </span><span>𝛼</span><span> </span><span>as garbage candidates.</span></p></td><td colspan="1" rowspan="1">
 </td><td colspan="1" rowspan="1">
 </td></tr><tr><td colspan="1" rowspan="1">
 </td><td colspan="1" rowspan="1">
 <p><span>Call </span><span>recvmsg</span><span> with </span><span>MSG_PEEK</span><span> flag from </span><span>f </span><span>2</span><span>1</span><span> to get </span><span>f </span><span>1</span><span>1</span><span>’</span></p></td><td colspan="1" rowspan="1">
 </td></tr><tr><td colspan="1" rowspan="1">
 </td><td colspan="1" rowspan="1">
 <p><span>Increase reference count: </span><span>scm.fp = scm_fp_dup(</span><span>UNIXCB</span><span>(skb).fp);</span></p></td><td colspan="1" rowspan="1">
 </td></tr><tr><td colspan="1" rowspan="1">
 <p><span>Stage0: decrease inflight count from the child of every garbage candidate</span></p></td><td colspan="1" rowspan="1">
 </td><td colspan="1" rowspan="1">
 </td></tr><tr><td colspan="1" rowspan="1">
 <p><span>Status after stage 0:</span></p>
 <p><span>inflight</span><span>(</span><span>f </span><span>0</span><span>0</span><span>) = 0</span></p>
 <p><span>inflight</span><span>(</span><span>f </span><span>0</span><span>1</span><span>) = 0</span></p>
 <p><span>inflight</span><span>(</span><span>f </span><span>1</span><span>0</span><span>) = 0</span></p>
 <p><span>inflight</span><span>(</span><span>f </span><span>1</span><span>1</span><span>) = 1</span></p>
 <p><span>inflight</span><span>(</span><span>f </span><span>3</span><span>1</span><span>) = 0</span></p>
 <p><span>inflight</span><span>(𝛼) = 0</span></p></td><td colspan="1" rowspan="1">
 </td><td colspan="1" rowspan="1">
 </td></tr><tr><td colspan="1" rowspan="1">
 <p><span>Stage1: Recursively restore inflight count if a candidate still has inflight count. </span></p></td><td colspan="1" rowspan="1">
 </td><td colspan="1" rowspan="1">
 </td></tr><tr><td colspan="1" rowspan="1">
 <p><span>Stage1: All inflight counts have been restored.</span></p></td><td colspan="1" rowspan="1">
 </td><td colspan="1" rowspan="1">
 </td></tr><tr><td colspan="1" rowspan="1">
 <p><span>Stage2: No garbage, return.</span></p></td><td colspan="1" rowspan="1">
 </td><td colspan="1" rowspan="1">
 </td></tr><tr><td colspan="1" rowspan="1">
 </td><td colspan="1" rowspan="1">
 <p><span>Call </span><span>recvmsg</span><span> with </span><span>MSG_PEEK</span><span> flag from </span><span>f </span><span>1</span><span>1</span><span> to get </span><span>f </span><span>1</span><span>0</span><span>’</span></p></td><td colspan="1" rowspan="1">
 </td></tr><tr><td colspan="1" rowspan="1">
 </td><td colspan="1" rowspan="1">
 </td><td colspan="1" rowspan="1">
 <p><span>Call </span><span>recvmsg</span><span> without </span><span>MSG_PEEK</span><span> flag from </span><span>f </span><span>1</span><span>1</span><span> to get </span><span>f </span><span>1</span><span>0</span><span>’’</span></p></td></tr><tr><td colspan="1" rowspan="1">
 </td><td colspan="1" rowspan="1">
 <p><span>Call </span><span>recvmsg</span><span> with </span><span>MSG_PEEK</span><span> flag from </span><span>f </span><span>1</span><span>0</span><span>’</span></p></td><td colspan="1" rowspan="1">
 </td></tr><tr><td colspan="1" rowspan="1">
 <p><span>Everyone is happy</span></p></td><td colspan="1" rowspan="1">
 <p><span>Everyone is happy</span></p></td><td colspan="1" rowspan="1">
 <p><span>Everyone is happy</span></p></td></tr></tbody></table>
 
 <p><span>However, if the second </span><span>recvmsg</span><span> occurs </span><span>just after stage </span><span>1 of the garbage collection process, the UAF is triggered:</span></p>
 <table><tbody><tr><td colspan="1" rowspan="1">
 <p><span>Thread 0</span></p></td><td colspan="1" rowspan="1">
 <p><span>Thread 1</span></p></td><td colspan="1" rowspan="1">
 <p><span>Thread 2</span></p></td></tr><tr><td colspan="1" rowspan="1">
 <p><span>Call unix_gc</span></p></td><td colspan="1" rowspan="1">
 </td><td colspan="1" rowspan="1">
 </td></tr><tr><td colspan="1" rowspan="1">
 <p><span>Stage0: List </span><span>f </span><span>0</span><span>0</span><span>, </span><span>f </span><span>0</span><span>1</span><span>, </span><span>f </span><span>1</span><span>0</span><span>,  </span><span>f </span><span>1</span><span>1</span><span>, </span><span>f </span><span>3</span><span>1</span><span>, </span><span>𝛼</span><span> </span><span>as garbage candidates.</span></p></td><td colspan="1" rowspan="1">
 </td><td colspan="1" rowspan="1">
 </td></tr><tr><td colspan="1" rowspan="1">
 </td><td colspan="1" rowspan="1">
 <p><span>Call </span><span>recvmsg</span><span> with </span><span>MSG_PEEK</span><span> flag from </span><span>f </span><span>2</span><span>1</span><span> to get </span><span>f </span><span>1</span><span>1</span><span>’</span></p></td><td colspan="1" rowspan="1">
 </td></tr><tr><td colspan="1" rowspan="1">
 </td><td colspan="1" rowspan="1">
 <p><span>Increase reference count: </span><span>scm.fp = scm_fp_dup(</span><span>UNIXCB</span><span>(skb).fp);</span></p></td><td colspan="1" rowspan="1">
 </td></tr><tr><td colspan="1" rowspan="1">
 <p><span>Stage0: decrease inflight count from the child of every garbage candidates</span></p></td><td colspan="1" rowspan="1">
 </td><td colspan="1" rowspan="1">
 </td></tr><tr><td colspan="1" rowspan="1">
 <p><span>Status after stage 0:</span></p>
 
 <p><span>inflight</span><span>(</span><span>f </span><span>0</span><span>0</span><span>) = 0</span></p>
 <p><span>inflight</span><span>(</span><span>f </span><span>0</span><span>1</span><span>) = 0</span></p>
 <p><span>inflight</span><span>(</span><span>f </span><span>1</span><span>0</span><span>) = 0</span></p>
 <p><span>inflight</span><span>(</span><span>f </span><span>1</span><span>1</span><span>) = 1</span></p>
 <p><span>inflight</span><span>(</span><span>f </span><span>3</span><span>1</span><span>) = 0</span></p>
 <p><span>inflight</span><span>(𝛼) = 0</span></p></td><td colspan="1" rowspan="1">
 </td><td colspan="1" rowspan="1">
 </td></tr><tr><td colspan="1" rowspan="1">
 <p><span>Stage1: Start restoring inflight count.</span></p></td><td colspan="1" rowspan="1">
 </td><td colspan="1" rowspan="1">
 </td></tr><tr><td colspan="1" rowspan="1">
 </td><td colspan="1" rowspan="1">
 <p><span>Call </span><span>recvmsg</span><span> with </span><span>MSG_PEEK</span><span> flag from </span><span>f </span><span>1</span><span>1</span><span> to get </span><span>f </span><span>1</span><span>0</span><span>’</span></p></td><td colspan="1" rowspan="1">
 </td></tr><tr><td colspan="1" rowspan="1">
 </td><td colspan="1" rowspan="1">
 </td><td colspan="1" rowspan="1">
 <p><span>Call </span><span>recvmsg</span><span> without </span><span>MSG_PEEK</span><span> flag from </span><span>f </span><span>1</span><span>1</span><span> to get </span><span>f </span><span>1</span><span>0</span><span>’’</span></p></td></tr><tr><td colspan="1" rowspan="1">
 </td><td colspan="1" rowspan="1">
 </td><td colspan="1" rowspan="1">
 <p><span>unix_detach_fds</span><span>: </span><span>UNIXCB</span><span>(skb).fp = NULL</span></p></td></tr><tr><td colspan="1" rowspan="1">
 </td><td colspan="1" rowspan="1">
 </td><td colspan="1" rowspan="1">
 <p><span>Blocked by </span><span>spin_lock(&amp;unix_gc_lock)</span></p></td></tr><tr><td colspan="1" rowspan="1">
 <p><span>Stage1: </span><span>scan_inflight</span><span> cannot find candidate children from </span><span>f </span><span>1</span><span>1</span><span>. Thus, the inflight count accidentally remains the same.</span></p></td><td colspan="1" rowspan="1">
 </td><td colspan="1" rowspan="1">
 </td></tr><tr><td colspan="1" rowspan="1">
 <p><span>Stage2: </span><span>f </span><span>0</span><span>0</span><span>, </span><span>f </span><span>0</span><span>1</span><span>, </span><span>f </span><span>1</span><span>0</span><span>, </span><span>f </span><span>3</span><span>1</span><span>, </span><span>𝛼</span><span> are garbage.</span></p></td><td colspan="1" rowspan="1">
 </td><td colspan="1" rowspan="1">
 </td></tr><tr><td colspan="1" rowspan="1">
 <p><span>Stage2: start purging garbage.</span></p></td><td colspan="1" rowspan="1">
 </td><td colspan="1" rowspan="1">
 </td></tr><tr><td colspan="1" rowspan="1">
 </td><td colspan="1" rowspan="1">
 <p><span>Start calling </span><span>recvmsg</span><span> with </span><span>MSG_PEEK</span><span> flag from </span><span>f </span><span>1</span><span>0</span><span>’, which would expect to receive </span><span>f </span><span>0</span><span>0</span><span>&#39;</span></p></td><td colspan="1" rowspan="1">
 </td></tr><tr><td colspan="1" rowspan="1">
 </td><td colspan="1" rowspan="1">
 <p><span>Get </span><span>skb = skb_peek(&amp;sk-&gt;sk_receive_queue)</span><span>, </span><span>skb</span><span> is going to be freed by thread 0.</span></p></td><td colspan="1" rowspan="1">
 </td></tr><tr><td colspan="1" rowspan="1">
 <p><span>Stage2: for</span><span><img alt="" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgRTVI1goYtLkJZYRh0P5Wj_jeCjDeIhbMLEzwbzMCMWdag6uBicpIv7TtDorvArzkMmQGMRq6Ss5WdVDwyKTZE9frPBY44fOF667d2D7rKxarcAfp9x9t-YrNRielyFYOgI0998OI0TplaeHW7CGyz4SAFs2udorAlUMxe4gaCPYqr2zP9AjmKbyip/s260/image18.png" title=""/>, calls </span><span>__skb_unlink</span><span> and </span><span>kfree_skb</span><span> later.</span></p></td><td colspan="1" rowspan="1">
 </td><td colspan="1" rowspan="1">
 </td></tr><tr><td colspan="1" rowspan="1">
 </td><td colspan="1" rowspan="1">
 <p><span>state-&gt;recv_actor(skb, skip, chunk, state)</span><span> </span><span>UAF</span></p></td><td colspan="1" rowspan="1">
 </td></tr><tr><td colspan="1" rowspan="1">
 <p><span>GC finished.</span></p></td><td colspan="1" rowspan="1">
 </td><td colspan="1" rowspan="1">
 </td></tr><tr><td colspan="1" rowspan="1">
 </td><td colspan="1" rowspan="1">
 </td><td colspan="1" rowspan="1">
 <p><span>Start garbage collection.</span></p></td></tr><tr><td colspan="1" rowspan="1">
 </td><td colspan="1" rowspan="1">
 </td><td colspan="1" rowspan="1">
 <p><span>Get </span><span>f </span><span>1</span><span>0</span><span>’’</span></p></td></tr></tbody></table>
 
 <p><span>Therefore, the race condition causes a UAF of the skb object. At first glance, we should blame the second </span><span>recvmsg</span><span> syscall because it clears </span><span>skb.fp</span><span>, the passed file list.</span><span> However, if the first </span><span>recvmsg</span><span> syscall doesn’t set the </span><span>MSG_PEEK</span><span> flag, the UAF can be avoided because </span><span>unix_notinflight</span><span> is serialized with the garbage collection. In other words, the kernel makes sure the garbage collection is either not processed or finished before decrementing the inflight count and removing the skb. After </span><span>unix_notinflight</span><span>, the receiver obtains </span><span>f</span><span>1</span><span>1</span><span>&#39; and inflight sockets don&#39;t form an unbreakable cycle.</span></p>
 
 <p><span>Since </span><span>MSG_PEEK</span><span> is not serialized with the garbage collection, when </span><span>recvmsg</span><span> is called with </span><span>MSG_PEEK</span><span> set, the kernel still considers </span><span>f </span><span>1</span><span>1</span><span> as a garbage candidate. For this reason, the following next </span><span>recvmsg</span><span> will eventually trigger the bug due to the inconsistent state of the garbage collection process.</span></p>
 <h2 id="h.de5p59plssty"><span>CVE-2021-0920 was found in 2016</span></h2>
 <p><span>The vulnerability was </span><span><a href="https://patchwork.ozlabs.org/project/netdev/patch/CAOssrKcfncAYsQWkfLGFgoOxAQJVT2hYVWdBA6Cw7hhO8RJ_wQ@mail.gmail.com/">initially reported to the Linux kernel community in 2016</a></span><span>. The researcher also provided the correct patch advice but it was not accepted by the Linux kernel community:</span></p>
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEh8WLJ5TaSrwBSyzsB2cnn3WlhRBqZzDHyOAnU8PWvMGr9d2l85FCYHw8fwiHRmFRMtPBMSe3kcFyISMGzuqmFyc0Ks5gJymqNPxh_kHdy59iHrUXTkpc5MTEyoOSroIHMzmqgQCibycvyxMRR-kUmjKIB3y0kqNHvN1TQULEUY8f04pIe65f-z3l3A/s1202/image65.png"><img alt="Linux kernel developers: Why would I apply a patch that&#39;s an RFC, doesn&#39;t have a proper commit message, lacks a proper signoff, and also lacks ACK&#39;s and feedback from other knowledgable developers?" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEh8WLJ5TaSrwBSyzsB2cnn3WlhRBqZzDHyOAnU8PWvMGr9d2l85FCYHw8fwiHRmFRMtPBMSe3kcFyISMGzuqmFyc0Ks5gJymqNPxh_kHdy59iHrUXTkpc5MTEyoOSroIHMzmqgQCibycvyxMRR-kUmjKIB3y0kqNHvN1TQULEUY8f04pIe65f-z3l3A/s1202/image65.png" title="Linux kernel developers: Why would I apply a patch that&#39;s an RFC, doesn&#39;t have a proper commit message, lacks a proper signoff, and also lacks ACK&#39;s and feedback from other knowledgable developers?"/></a></span></p>
 <p><span>Patch was not applied in 2016</span></p>
 
 <p><span>In theory, anyone who saw this patch might come up with an exploit against the faulty garbage collector. </span></p>
 <h2 id="h.4z83prp6b89e"><span>Patch in 2021</span></h2>
 <p><span>Let’s check the official </span><span><a href="https://lore.kernel.org/lkml/20210802134333.066918619@linuxfoundation.org/">patch</a></span><span> </span><span>for CVE-2021-0920. For the </span><span>MSG_PEEK</span><span> branch, it </span><span>requests the</span><span> garbage collection lock </span><span>unix_gc_lock</span><span> before performing sensitive actions</span><span> and immediately releases it afterwards:</span></p>
 <div colspan="1" rowspan="1">
 <p><span>…</span></p>
 <p><span>+</span><span>       spin_lock</span><span>(&amp;</span><span>unix_gc_lock</span><span>);</span></p>
 <p><span>+</span><span>       spin_unlock</span><span>(&amp;</span><span>unix_gc_lock</span><span>);</span></p>
 <p><span>…</span></p></div>
 
 <p><span>The patch is confusing - it’s rare to see such lock usage in software development. Regardless, the </span><span>MSG_PEEK</span><span> flag now waits for the completion of the garbage collector, so the UAF issue is resolved.</span></p><h2 id="h.9ft0l34fnpmk"><span>BUG_ON Added in 2017</span></h2>
 <p><span>Andrey Ulanov from Google in 2017 found another issue in </span><span>unix_gc</span><span> and provided a fix </span><span><a href="https://lore.kernel.org/lkml/20170315031642.19576-1-andreyu@google.com/">commit</a></span><span>. Additionally, the patch added a </span><span>BUG_ON</span><span> for the inflight count:</span></p>
 <div colspan="1" rowspan="1">
 <p><span>void</span><span> unix_notinflight</span><span>(</span><span>struct</span><span> user_struct </span><span>*</span><span>user</span><span>,</span><span> </span><span>struct</span><span> file </span><span>*</span><span>fp</span><span>)</span></p>
 <p><span>        </span><span>if</span><span> </span><span>(</span><span>s</span><span>)</span><span> </span><span>{</span></p>
 <p><span>                </span><span>struct</span><span> unix_sock </span><span>*</span><span>u </span><span>=</span><span> unix_sk</span><span>(</span><span>s</span><span>);</span></p>
 
 <p><span>+</span><span>               BUG_ON</span><span>(!</span><span>atomic_long_read</span><span>(&amp;</span><span>u</span><span>-&gt;</span><span>inflight</span><span>));</span></p>
 <p><span>                BUG_ON</span><span>(</span><span>list_empty</span><span>(&amp;</span><span>u</span><span>-&gt;</span><span>link</span><span>));</span></p>
 
 <p><span>                </span><span>if</span><span> </span><span>(</span><span>atomic_long_dec_and_test</span><span>(&amp;</span><span>u</span><span>-&gt;</span><span>inflight</span><span>))</span></p></div>
 
 <p><span>At first glance, i</span><span>t seems that</span><span> the </span><span>BUG_ON</span><span> can prevent CVE-2021-0920 from being exploitable. However, if the exploit code can delay garbage collection by crafting a large amount of fake garbage,  it can waive the </span><span>BUG_ON</span><span> check by heap spray.</span></p>
 <h2 id="h.f7eb84wuwvc6"><span>New Garbage Collection</span><span> </span><span>Discovered </span><span>in 2021</span></h2>
 <p><span>CVE-2021-4083 deserves an honorable mention: when I </span><span>discussed</span><span> CVE-2021-0920 with Jann Horn and Ben Hawkes, Jann found another </span><span><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=2247">issue</a></span><span> in the garbage collection, described in the Project Zero blog post </span><span><a href="https://googleprojectzero.blogspot.com/2022/03/racing-against-clock-hitting-tiny.html">Racing against the clock -- hitting a tiny kernel race window</a></span><span>.</span></p><p>
 \</p>
 <p><span>To recap, we have discussed the kernel internals of </span><span>SCM_RIGHTS</span><span> and the designs and implementations of the Linux kernel garbage collector. Besides, we have analyzed the behavior of </span><span>MSG_PEEK</span><span> flag with the </span><span>recvmsg</span><span> syscall and how it leads to a kernel UAF by a subtle and arcane race condition.</span></p>
 
 <p><span>The bug was spotted in 2016 publicly, but unfortunately the Linux kernel community did not accept the patch at that time. Any threat actors who saw the public email thread may have a chance to develop an LPE exploit against the Linux kernel.</span></p>
 
 <p><span>In part two, we&#39;ll look at how the vulnerability was exploited and the functionalities of the post compromise modules.</span></p>

</div></div>
  </body>
</html>
