<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fasterthanli.me/articles/i-want-off-mr-golangs-wild-ride">Original</a>
    <h1>I want off Mr. Golang’s Wild Ride (2020)</h1>
    
    <div id="readability-page-1" class="page"><div>
  

  <p>
    Feb 28, 2020
    
      · 31 minute read
    
    
    
      
        
          ·
          <a href="https://www.youtube.com/tags/golang">golang</a>
        
      
        
          ·
          <a href="https://www.youtube.com/tags/rant">rant</a>
        
      
      
      
      
          
      
      
    
  </p>

  
</div><div>
  

  <p>My honeymoon with the <a href="https://golang.org/">Go language</a> is <em>extremely</em> over.</p>
<p>This article is going to have a different tone from what I&#39;ve been posting
the past year - it&#39;s a proper rant. And I always feel bad writing those,
because, inevitably, it discusses things a lot of people have been working
very hard on.</p>
<p>In spite of that, here we are.</p>
<p>Having invested thousands of hours into the language, and implemented several
critical (to my employer) pieces of infrastructure with it, I wish I hadn&#39;t.</p>
<p>If you&#39;re <em>already</em> heavily invested in Go, you probably shouldn&#39;t read this,
it&#39;ll probably just twist the knife. If you work on Go, you <em>definitely</em>
shouldn&#39;t read this.</p>
<p>I&#39;ve been suffering Go&#39;s idiosyncracies in relative silence for too long,
there&#39;s a few things I really need to get off my chest.</p>
<p>Alright? Alright.</p>
<h2>Garden-variety takes on Go</h2>
<p>By now, everybody knows Go doesn&#39;t have generics, which makes a lot of
problems impossible to model accurately (instead, you have to fall back to
reflection, which is <em>extremely</em> unsafe, and the API is very error-prone),
error handling is wonky (even with your pick of the third-party libraries
that add context or stack traces), package management took a while to arrive,
etc.</p>
<p>But everybody also knows Go&#39;s strengths: static linking makes binaries easy
to deploy (although, Go binaries get <a href="https://blog.filippo.io/shrink-your-go-binaries-with-this-one-weird-trick/">very
large</a>,
even if you strip DWARF tables - stack trace annotations still remain, and are <em>costly</em>).</p>
<p>Compile times are short (unless you need cgo), there&#39;s an interactive runtime
profiler (pprof) at arm&#39;s reach, it&#39;s relatively cross-platform (there&#39;s even
a <a href="https://github.com/tinygo-org/tinygo">tiny variant</a> for embedded), it&#39;s
easy to syntax-highlight, and there&#39;s now an official <a href="https://github.com/golang/tools/blob/master/gopls/README.md">LSP
server</a> for it.</p>
<p>I&#39;ve accepted all of these - the good and the bad.</p>
<p>We&#39;re here to talk about the ugly.</p>
<h2>Simple is a lie</h2>
<p>Over and over, every piece of documentation for the Go language markets it
as &#34;simple&#34;.</p>
<p>This is a lie.</p>
<p>Or rather, it&#39;s a half-truth that conveniently covers up the fact that, when
you make something simple, you move complexity elsewhere.</p>
<p>Computers, operating systems, networks are a hot mess. They&#39;re barely
manageable, even if you know a decent amount about what you&#39;re doing. Nine
out of ten software engineers agree: it&#39;s a miracle anything works at all.</p>
<p>So all the complexity is swept under the rug. Hidden from view, but not
solved.</p>
<p>Here&#39;s a simple example.</p>
<div>

<p>This example does go on for a while, actually - but don&#39;t let the specifics
distract you. While it goes rather in-depth, it illustrates a larger point.</p>
</div>
<p>Most of Go&#39;s APIs (much like NodeJS&#39;s APIs) are designed for Unix-like
operating systems. This is not surprising, as Rob &amp; Ken are from the <a href="https://en.wikipedia.org/wiki/Plan_9_from_Bell_Labs#History">Plan 9
gang</a>.</p>
<p>So, the file API in Go looks like this:</p>
<div><p>Go code</p><pre data-lang="go"><i>// File represents an open file descriptor.</i>
<i>type</i> <i>File</i> <i>struct</i> {
    <i>*</i><i>file</i> <i>// os specific</i>
}

<i>func</i> (<i>f</i> <i>*</i><i>File</i>) <i>Stat</i>() (<i>FileInfo</i>, <i>error</i>) {
    <i>// omitted</i>
}

<i>// A FileInfo describes a file and is returned by Stat and Lstat.</i>
<i>type</i> <i>FileInfo</i> <i>interface</i> {
  <i>Name</i>() <i>string</i>       <i>// base name of the file</i>
  <i>Size</i>() <i>int64</i>        <i>// length in bytes for regular files; system-dependent for others</i>
  <i>Mode</i>() <i>FileMode</i>     <i>// file mode bits</i>
  <i>ModTime</i>() time.<i>Time</i> <i>// modification time</i>
  <i>IsDir</i>() <i>bool</i>        <i>// abbreviation for Mode().IsDir()</i>
  <i>Sys</i>() <i>interface</i>{}   <i>// underlying data source (can return nil)</i>
}

<i>// A FileMode represents a file&#39;s mode and permission bits.</i>
<i>// The bits have the same definition on all systems, so that</i>
<i>// information about files can be moved from one system</i>
<i>// to another portably. Not all bits apply to all systems.</i>
<i>// The only required bit is ModeDir for directories.</i>
<i>type</i> <i>FileMode</i> <i>uint32</i>

<i>// The defined file mode bits are the most significant bits of the FileMode.</i>
<i>// The nine least-significant bits are the standard Unix rwxrwxrwx permissions.</i>
<i>// The values of these bits should be considered part of the public API and</i>
<i>// may be used in wire protocols or disk representations: they must not be</i>
<i>// changed, although new bits might be added.</i>
<i>const</i> (
  <i>// The single letters are the abbreviations</i>
  <i>// used by the String method&#39;s formatting.</i>
  <i>ModeDir</i>        <i>FileMode</i> <i>=</i> 1 <i>&lt;&lt;</i> (32 <i>-</i> 1 <i>-</i> <i>iota</i>) <i>// d: is a directory</i>
  <i>ModeAppend</i>                                     <i>// a: append-only</i>
  <i>ModeExclusive</i>                                  <i>// l: exclusive use</i>
  <i>ModeTemporary</i>                                  <i>// T: temporary file; Plan 9 only</i>
  <i>ModeSymlink</i>                                    <i>// L: symbolic link</i>
  <i>ModeDevice</i>                                     <i>// D: device file</i>
  <i>ModeNamedPipe</i>                                  <i>// p: named pipe (FIFO)</i>
  <i>ModeSocket</i>                                     <i>// S: Unix domain socket</i>
  <i>ModeSetuid</i>                                     <i>// u: setuid</i>
  <i>ModeSetgid</i>                                     <i>// g: setgid</i>
  <i>ModeCharDevice</i>                                 <i>// c: Unix character device, when ModeDevice is set</i>
  <i>ModeSticky</i>                                     <i>// t: sticky</i>
  <i>ModeIrregular</i>                                  <i>// ?: non-regular file; nothing else is known about this file</i>

  <i>// Mask for the type bits. For regular files, none will be set.</i>
  <i>ModeType</i> <i>=</i> <i>ModeDir</i> <i>|</i> <i>ModeSymlink</i> <i>|</i> <i>ModeNamedPipe</i> <i>|</i> <i>ModeSocket</i> <i>|</i> <i>ModeDevice</i> <i>|</i> <i>ModeCharDevice</i> <i>|</i> <i>ModeIrregular</i>

  <i>ModePerm</i> <i>FileMode</i> <i>=</i> 0777 <i>// Unix permission bits</i>
)
</pre></div>
<p>Makes sense for a Unix, right?</p>
<p>Every file has a mode, there&#39;s even a command that lets you dump it as hex:</p>
<div><p>Shell session</p><pre data-lang="shell">$ stat -c &#39;%f&#39; /etc/hosts
81a4
$ stat -c &#39;%f&#39; /usr/bin/man
81ed
</pre></div>
<p>And so, a simple Go program can easily grab those &#34;Unix permission bits&#34;:</p>
<div><p>Go code</p><pre data-lang="go"><i>package</i> main

<i>import</i> (
        <i>&#34;fmt&#34;</i>
        <i>&#34;os&#34;</i>
)

<i>func</i> <i>main</i>() {
        <i>arg</i> <i>:=</i> <i>os</i>.<i>Args</i>[1]
        <i>fi</i>, <i>_</i> <i>:=</i> <i>os</i>.<i>Stat</i>(<i>arg</i>)
        <i>fmt</i>.<i>Printf</i>(<i>&#34;(%s) mode = %o\n&#34;</i>, <i>arg</i>, <i>fi</i>.<i>Mode</i>() <i>&amp;</i> <i>os</i>.<i>ModePerm</i>)
}
</pre></div><div><p>Shell session</p><pre data-lang="shell">$ go run main.go /etc/hosts
(/etc/hosts) mode = 644
$ go run main.go /usr/bin/man
(/etc/hosts) mode = 755
</pre></div>
<p>On Windows, files don&#39;t have modes. It doesn&#39;t have <code>stat</code>, <code>lstat</code>, <code>fstat</code>
syscalls - it has a <code>FindFirstFile</code> family of functions (alternatively,
<code>CreateFile</code> to open, then <code>GetFileAttributes</code>, alternatively,
<code>GetFileInformationByHandle</code>), which takes a pointer to a <code>WIN32_FIND_DATA</code>
structure, which contains <a href="https://docs.microsoft.com/en-us/windows/win32/fileio/file-attribute-constants">file
attributes</a>.</p>
<p>So, what happens if you run that program on Windows?</p>
<div><p>Shell session</p><pre data-lang="shell">&gt; go run main.go C:\Windows\notepad.exe
(C:\Windows\notepad.exe) mode = 666
</pre></div>
<p>It makes up a mode.</p>
<div><p>Go code</p><pre data-lang="go"><i>// src/os/types_windows.go</i>

<i>func</i> (<i>fs</i> <i>*</i><i>fileStat</i>) <i>Mode</i>() (<i>m</i> <i>FileMode</i>) {
  <i>if</i> <i>fs</i> <i>==</i> <i>&amp;</i><i>devNullStat</i> {
    <i>return</i> <i>ModeDevice</i> <i>|</i> <i>ModeCharDevice</i> <i>|</i> 0666
  }
  <i>if</i> <i>fs</i>.<i>FileAttributes</i><i>&amp;</i><i>syscall</i>.<i>FILE_ATTRIBUTE_READONLY</i> <i>!=</i> 0 {
    <i>m</i> <i>|=</i> 0444
  } <i>else</i> {
    <i>m</i> <i>|=</i> 0666
  }
  <i>if</i> <i>fs</i>.<i>isSymlink</i>() {
    <i>return</i> <i>m</i> <i>|</i> <i>ModeSymlink</i>
  }
  <i>if</i> <i>fs</i>.<i>FileAttributes</i><i>&amp;</i><i>syscall</i>.<i>FILE_ATTRIBUTE_DIRECTORY</i> <i>!=</i> 0 {
    <i>m</i> <i>|=</i> <i>ModeDir</i> <i>|</i> 0111
  }
  <i>switch</i> <i>fs</i>.<i>filetype</i> {
  <i>case</i> <i>syscall</i>.<i>FILE_TYPE_PIPE</i>:
    <i>m</i> <i>|=</i> <i>ModeNamedPipe</i>
  <i>case</i> <i>syscall</i>.<i>FILE_TYPE_CHAR</i>:
    <i>m</i> <i>|=</i> <i>ModeDevice</i> <i>|</i> <i>ModeCharDevice</i>
  }
  <i>return</i> <i>m</i>
}
</pre></div>
<p>Node.js does the same. There&#39;s a <a href="https://nodejs.org/api/fs.html#fs_class_fs_stats">single fs.Stats
&#34;type&#34;</a> for all platforms.</p>
<p>Using &#34;whatever Unix has&#34; as the lowest common denominator is <em>extremely
common</em> in open-source codebases, so it&#39;s not surprising.</p>
<p>Let&#39;s go a little bit further. On Unix systems, you can change the modes of
files, to make them read-only, or flip the executable bit.</p>
<div><p>Go code</p><pre data-lang="go"><i>package</i> main

<i>import</i> (
  <i>&#34;fmt&#34;</i>
  <i>&#34;os&#34;</i>
)

<i>func</i> <i>main</i>() {
  <i>arg</i> <i>:=</i> <i>os</i>.<i>Args</i>[1]

  <i>fi</i>, <i>err</i> <i>:=</i> <i>os</i>.<i>Stat</i>(<i>arg</i>)
  <i>must</i>(<i>err</i>)
  <i>fmt</i>.<i>Printf</i>(<i>&#34;(%s) old mode = %o\n&#34;</i>, <i>arg</i>, <i>fi</i>.<i>Mode</i>()<i>&amp;</i><i>os</i>.<i>ModePerm</i>)

  <i>must</i>(<i>os</i>.<i>Chmod</i>(<i>arg</i>, 0755))

  <i>fi</i>, <i>err</i> <i>=</i> <i>os</i>.<i>Stat</i>(<i>arg</i>)
  <i>must</i>(<i>err</i>)
  <i>fmt</i>.<i>Printf</i>(<i>&#34;(%s) new mode = %o\n&#34;</i>, <i>arg</i>, <i>fi</i>.<i>Mode</i>()<i>&amp;</i><i>os</i>.<i>ModePerm</i>)
}

<i>func</i> <i>must</i>(<i>err</i> <i>error</i>) {
  <i>if</i> <i>err</i> <i>!=</i> <i>nil</i> {
    <i>panic</i>(<i>err</i>)
  }
}
</pre></div>
<p>Let&#39;s run this on Linux:</p>
<div><p>Shell session</p><pre data-lang="shell">$ touch test.txt
$ go run main.go test.txt
(test.txt) old mode = 644
(test.txt) new mode = 755
</pre></div>
<p>And now on Windows:</p>
<div><p>Shell session</p><pre data-lang="shell">&gt; go run main.go test.txt
(test.txt) old mode = 666
(test.txt) new mode = 666
</pre></div>
<p>So, no errors. <code>Chmod</code> just silently does... nothing. Which is reasonable -
there&#39;s no equivalent to the &#34;executable bit&#34; for files on Windows.</p>
<p>What does <code>Chmod</code> even do on Windows?</p>
<div><p>Go code</p><pre data-lang="go"><i>// src/syscall/syscall_windows.go</i>

<i>func</i> <i>Chmod</i>(<i>path</i> <i>string</i>, <i>mode</i> <i>uint32</i>) (<i>err</i> <i>error</i>) {
  <i>p</i>, <i>e</i> <i>:=</i> <i>UTF16PtrFromString</i>(<i>path</i>)
  <i>if</i> <i>e</i> <i>!=</i> <i>nil</i> {
    <i>return</i> <i>e</i>
  }
  <i>attrs</i>, <i>e</i> <i>:=</i> <i>GetFileAttributes</i>(<i>p</i>)
  <i>if</i> <i>e</i> <i>!=</i> <i>nil</i> {
    <i>return</i> <i>e</i>
  }
  <i>if</i> <i>mode</i><i>&amp;</i><i>S_IWRITE</i> <i>!=</i> 0 {
    <i>attrs</i> &amp;^= <i>FILE_ATTRIBUTE_READONLY</i>
  } <i>else</i> {
    <i>attrs</i> <i>|=</i> <i>FILE_ATTRIBUTE_READONLY</i>
  }
  <i>return</i> <i>SetFileAttributes</i>(<i>p</i>, <i>attrs</i>)
}
</pre></div>
<p>It sets or clears the read-only bit. That&#39;s it.</p>
<p>We have an <code>uint32</code> argument, with four billion two hundred ninety-four
million nine hundred sixty-seven thousand two hundred ninety-five possible
values, to encode... one bit of information.</p>
<p>That&#39;s a pretty innocent lie. The assumption that files have modes was baked
into the API design from the start, and now, everyone has to live with it.
Just like in Node.JS, and probably tons of other languages.</p>
<p>But <em>it doesn&#39;t have to be like that</em>.</p>
<p>A language with a more involved type system, and better designed libraries
could avoid that pitfall.</p>
<p>Out of curiosity, what does Rust do?</p>
<div>

<p>Oh, here we go again - Rust, Rust, and Rust again.</p>
<p>Why always Rust?</p>
<p>Well, I tried <em>real hard</em> to keep Rust out of all of this. Among other
things, because people are going to dismiss this article as coming from &#34;a
typical rustacean&#34;.</p>
<p>But for all the problems I raise in this article... Rust gets it right.
If I had another good example, I&#39;d use it. But I don&#39;t, so, here goes.</p>
</div>
<p>There&#39;s no <code>stat</code>-like function in the Rust standard library. There&#39;s
<code>std::fs::metadata</code>:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>pub</i> <i>fn</i> <i>metadata</i><i>&lt;</i><i>P</i>: <i>AsRef</i><i>&lt;</i><i>Path</i><i>&gt;</i><i>&gt;</i><i>(</i><i>path</i>: <i>P</i><i>)</i> -&gt; <i>Result</i><i>&lt;</i><i>Metadata</i><i>&gt;</i><i></i>
</pre></div>
<p>This function signatures tells us a lot already. It returns a <code>Result</code>, which
means, not only do we know this can fail, we <em>have</em> to handle it. Either by
panicking on error, with <code>.unwrap()</code> or <code>.expect()</code>, or by matching it against
<code>Result::Ok</code> / <code>Result::Err</code>, or by bubbling it up with the <code>?</code> operator.</p>
<p>The point is, this function signature makes it <em>impossible</em> for us to access
an invalid/uninitialized/null <code>Metadata</code>. With a Go function, if you ignore the
returned <code>error</code>, you <em>still</em> get the result - most probably a null pointer.</p>
<p>Also, the argument is not a string - it&#39;s a path. Or rather, it&#39;s something
that <em>can be turned into a path</em>.</p>
<p>And <code>String</code> <a href="https://doc.rust-lang.org/std/string/struct.String.html#impl-AsRef%3CPath%3E">does implement
<code>AsRef&lt;Path&gt;</code></a>,
so, for simple use cases, it&#39;s not troublesome:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> metadata = std<i>::</i>fs<i>::</i><i>metadata</i><i>(</i><i>&#34;Cargo.toml&#34;</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;is dir? {:?}&#34;</i>, metadata.is_dir<i>(</i><i>)</i><i>)</i><i>;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;is file? {:?}&#34;</i>, metadata.is_file<i>(</i><i>)</i><i>)</i><i>;</i>
}
</pre></div>
<p>But paths are not necessarily strings. On Unix (!), paths can be any sequence
of bytes, except null bytes.</p>
<div><p>Shell session</p><pre data-lang="shell">$ cd rustfun/
$ touch &#34;$(printf &#34;\xbd\xb2\x3d\xbc\x20\xe2\x8c\x98&#34;)&#34;
$ ls
ls: cannot compare file names ‘Cargo.lock’ and ‘\275\262=\274 ⌘’: Invalid or incomplete multibyte or wide character
 src   target   Cargo.lock   Cargo.toml  &#39;&#39;$&#39;\275\262&#39;&#39;=&#39;$&#39;\274&#39;&#39; ⌘&#39;
</pre></div>
<p>We&#39;ve just made a file with a <em>very naughty</em> name - but it&#39;s a perfectly
valid file, even if <code>ls</code> struggles with it.</p>
<div><p>Shell session</p><pre data-lang="shell">$ stat &#34;$(printf &#34;\xbd\xb2\x3d\xbc\x20\xe2\x8c\x98&#34;)&#34;
  File: = ⌘
  Size: 0               Blocks: 0          IO Block: 65536  regular empty file
Device: 8c70d496h/2356204694d   Inode: 72620543991375285  Links: 1
Access: (0644/-rw-r--r--)  Uid: (197611/    amos)   Gid: (197611/    amos)
Access: 2020-02-28 13:12:12.783734000 +0100
Modify: 2020-02-28 13:12:12.783734000 +0100
Change: 2020-02-28 13:12:12.783329400 +0100
 Birth: 2020-02-28 13:12:12.783329400 +0100
</pre></div>
<p>That&#39;s not something we can represent with a <code>String</code> in Rust, because <a href="https://www.youtube.com/blog/2020/working-with-strings-in-rust/">Rust
Strings are valid utf-8</a>, and this isn&#39;t.</p>
<p>Rust <code>Path</code>s, however, are... arbitrary byte sequences.</p>
<p>And so, if we use <code>std::fs::read_dir</code>, we have no problem listing it and
getting its metadata:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>use</i> std<i>::</i>fs<i>;</i>

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> entries = fs<i>::</i><i>read_dir</i><i>(</i><i>&#34;.&#34;</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
    <i>for</i> entry <i>in</i> entries {
        <i>let</i> path = entry<i>.</i><i>unwrap</i><i>(</i><i>)</i><i>.</i><i>path</i><i>(</i><i>)</i><i>;</i>
        <i>let</i> meta = fs<i>::</i><i>metadata</i><i>(</i><i>&amp;</i>path<i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
        <i>if</i> meta<i>.</i><i>is_dir</i><i>(</i><i>)</i> {
            <i>println</i><i>!</i><i>(</i><i>&#34;(dir) {:?}&#34;</i>, path<i>)</i><i>;</i>
        } <i>else</i> {
            <i>println</i><i>!</i><i>(</i><i>&#34;      {:?}&#34;</i>, path<i>)</i><i>;</i>
        }
    }
}
</pre></div><div><p>Shell session</p><pre data-lang="shell">$ cargo run --quiet
(dir) &#34;./src&#34;
      &#34;./Cargo.toml&#34;
      &#34;./.gitignore&#34;
      &#34;./\xBD\xB2=\xBC ⌘&#34;
(dir) &#34;./.git&#34;
      &#34;./Cargo.lock&#34;
(dir) &#34;./target&#34;
</pre></div>
<p>What about Go?</p>
<div><p>Go code</p><pre data-lang="go"><i>package</i> main

<i>import</i> (
        <i>&#34;fmt&#34;</i>
        <i>&#34;os&#34;</i>
)

<i>func</i> <i>main</i>() {
        <i>arg</i> <i>:=</i> <i>os</i>.<i>Args</i>[1]
        <i>f</i>, <i>err</i> <i>:=</i> <i>os</i>.<i>Open</i>(<i>arg</i>)
        <i>must</i>(<i>err</i>)

        <i>entries</i>, <i>err</i> <i>:=</i> <i>f</i>.<i>Readdir</i>(<i>-</i>1)
        <i>must</i>(<i>err</i>)

        <i>for</i> <i>_</i>, <i>e</i> <i>:=</i> <i>range</i> <i>entries</i> {
                <i>if</i> <i>e</i>.<i>IsDir</i>() {
                        <i>fmt</i>.<i>Printf</i>(<i>&#34;(dir) %s\n&#34;</i>, <i>e</i>.<i>Name</i>())
                } <i>else</i> {
                        <i>fmt</i>.<i>Printf</i>(<i>&#34;      %s\n&#34;</i>, <i>e</i>.<i>Name</i>())
                }
        }
}

<i>func</i> <i>must</i>(<i>err</i> <i>error</i>) {
        <i>if</i> <i>err</i> <i>!=</i> <i>nil</i> {
                <i>panic</i>(<i>err</i>)
        }
}
</pre></div><div><p>Shell session</p><pre data-lang="shell">$ go build
$ ./gofun ../rustfun
(dir) src
      Cargo.toml
      .gitignore
      = ⌘
(dir) .git
      Cargo.lock
(dir) target
</pre></div>
<p>It... silently prints a wrong version of the path.</p>
<p>See, there&#39;s no &#34;path&#34; type in Go. Just &#34;string&#34;. And Go strings <a href="https://blog.golang.org/strings">are just byte
slices</a>, with no guarantees about what&#39;s
inside.</p>
<p>So it prints garbage, whereas in Rust, <code>Path</code> does not implement <code>Display</code>, so
we couldn&#39;t do this:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>println</i><i>!</i><i>(</i><i>&#34;(dir) {}&#34;</i>, path<i>)</i><i>;</i>
</pre></div>
<p>We had to do this:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>println</i><i>!</i><i>(</i><i>&#34;(dir) {:?}&#34;</i>, path<i>)</i><i>;</i>
</pre></div>
<p>And if we wanted a friendlier output, we <em>could</em> handle both cases: when
the path happens to be a valid utf-8 string, and when it doesn&#39;t:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>use</i> std<i>::</i>fs<i>;</i>

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> entries = fs<i>::</i><i>read_dir</i><i>(</i><i>&#34;.&#34;</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
    <i>for</i> entry <i>in</i> entries {
        <i>let</i> path = entry<i>.</i><i>unwrap</i><i>(</i><i>)</i><i>.</i><i>path</i><i>(</i><i>)</i><i>;</i>
        <i>let</i> meta = fs<i>::</i><i>metadata</i><i>(</i><i>&amp;</i>path<i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
        <i>let</i> prefix = <i>if</i> meta<i>.</i><i>is_dir</i><i>(</i><i>)</i> {
            <i>&#34;(dir)&#34;</i>
        } <i>else</i> {
            <i>&#34;     &#34;</i>
        }<i>;</i>
        <i>match</i> path<i>.</i><i>to_str</i><i>(</i><i>)</i> {
            Some<i>(</i>s<i>)</i> =&gt; <i>println</i><i>!</i><i>(</i><i>&#34;{} {}&#34;</i>, prefix, s<i>)</i>,
            None =&gt; <i>println</i><i>!</i><i>(</i><i>&#34;{} {:?} (invalid utf-8)&#34;</i>, prefix, path<i>)</i>,
        }
    }
}
</pre></div><div><p>Shell session</p><pre data-lang="shell">$ cargo run --quiet
(dir) ./src
      ./Cargo.toml
      ./.gitignore
      &#34;./\xBD\xB2=\xBC ⌘&#34; (invalid utf-8)
(dir) ./.git
      ./Cargo.lock
(dir) ./target
</pre></div>
<p>Go says &#34;don&#39;t worry about encodings! things are <em>probably</em> utf-8&#34;.</p>
<p>Except when they aren&#39;t. And paths aren&#39;t. So, in Go, all path manipulation
routines operate on <code>string</code>, let&#39;s take a look at the <code>path/filepath</code> package.</p>
<blockquote>
<p>Package filepath implements utility routines for manipulating filename paths
in a way compatible with the target operating system-defined file paths.</p>
<p>The filepath package uses either forward slashes or backslashes, depending on
the operating system. To process paths such as URLs that always use forward
slashes regardless of the operating system, see the path package.</p>
</blockquote>
<p>What does this package give us?</p>
<div><p>Go code</p><pre data-lang="go"><i>func</i> <i>Abs</i>(<i>path</i> <i>string</i>) (<i>string</i>, <i>error</i>)
<i>func</i> <i>Base</i>(<i>path</i> <i>string</i>) <i>string</i>
<i>func</i> <i>Clean</i>(<i>path</i> <i>string</i>) <i>string</i>
<i>func</i> <i>Dir</i>(<i>path</i> <i>string</i>) <i>string</i>
<i>func</i> <i>EvalSymlinks</i>(<i>path</i> <i>string</i>) (<i>string</i>, <i>error</i>)
<i>func</i> <i>Ext</i>(<i>path</i> <i>string</i>) <i>string</i>
<i>func</i> <i>FromSlash</i>(<i>path</i> <i>string</i>) <i>string</i>
<i>func</i> <i>Glob</i>(<i>pattern</i> <i>string</i>) (<i>matches</i> []<i>string</i>, <i>err</i> <i>error</i>)
<i>func</i> <i>HasPrefix</i>(<i>p</i>, <i>prefix</i> <i>string</i>) <i>bool</i>
<i>func</i> <i>IsAbs</i>(<i>path</i> <i>string</i>) <i>bool</i>
<i>func</i> <i>Join</i>(<i>elem</i> <i>...</i><i>string</i>) <i>string</i>
<i>func</i> <i>Match</i>(<i>pattern</i>, <i>name</i> <i>string</i>) (<i>matched</i> <i>bool</i>, <i>err</i> <i>error</i>)
<i>func</i> <i>Rel</i>(<i>basepath</i>, <i>targpath</i> <i>string</i>) (<i>string</i>, <i>error</i>)
<i>func</i> <i>Split</i>(<i>path</i> <i>string</i>) (<i>dir</i>, <i>file</i> <i>string</i>)
<i>func</i> <i>SplitList</i>(<i>path</i> <i>string</i>) []<i>string</i>
<i>func</i> <i>ToSlash</i>(<i>path</i> <i>string</i>) <i>string</i>
<i>func</i> <i>VolumeName</i>(<i>path</i> <i>string</i>) <i>string</i>
<i>func</i> <i>Walk</i>(<i>root</i> <i>string</i>, <i>walkFn</i> <i>WalkFunc</i>) <i>error</i>
</pre></div>
<p>Strings. Lots and lots of strings. Well, byte slices.</p>
<p>Speaking of bad design decisions - what&#39;s that <code>Ext</code> function I see?</p>
<div><p>Go code</p><pre data-lang="go"><i>// Ext returns the file name extension used by path. The extension is the suffix</i>
<i>// beginning at the final dot in the final element of path; it is empty if there</i>
<i>// is no dot.</i>
<i>func</i> <i>Ext</i>(<i>path</i> <i>string</i>) <i>string</i>
</pre></div>
<p>Interesting! Let&#39;s try it out.</p>
<div><p>Go code</p><pre data-lang="go"><i>package</i> main

<i>import</i> (
        <i>&#34;fmt&#34;</i>
        <i>&#34;path/filepath&#34;</i>
)

<i>func</i> <i>main</i>() {
        <i>inputs</i> <i>:=</i> []<i>string</i>{
                <i>&#34;/&#34;</i>,
                <i>&#34;/.&#34;</i>,
                <i>&#34;/.foo&#34;</i>,
                <i>&#34;/foo&#34;</i>,
                <i>&#34;/foo.txt&#34;</i>,
                <i>&#34;/foo.txt/bar&#34;</i>,
                <i>&#34;C:\\&#34;</i>,
                <i>&#34;C:\\.&#34;</i>,
                <i>&#34;C:\\foo.txt&#34;</i>,
                <i>&#34;C:\\foo.txt\\bar&#34;</i>,
        }
        <i>for</i> <i>_</i>, <i>i</i> <i>:=</i> <i>range</i> <i>inputs</i> {
                <i>fmt</i>.<i>Printf</i>(<i>&#34;%24q =&gt; %q\n&#34;</i>, <i>i</i>, <i>filepath</i>.<i>Ext</i>(<i>i</i>))
        }
}

<i>func</i> <i>must</i>(<i>err</i> <i>error</i>) {
        <i>if</i> <i>err</i> <i>!=</i> <i>nil</i> {
                <i>panic</i>(<i>err</i>)
        }
}
</pre></div><div><p>Shell session</p><pre data-lang="shell">$ go run main.go
                     &#34;/&#34; =&gt; &#34;&#34;
                    &#34;/.&#34; =&gt; &#34;.&#34;
                 &#34;/.foo&#34; =&gt; &#34;.foo&#34;
                  &#34;/foo&#34; =&gt; &#34;&#34;
              &#34;/foo.txt&#34; =&gt; &#34;.txt&#34;
          &#34;/foo.txt/bar&#34; =&gt; &#34;&#34;
                  &#34;C:\\&#34; =&gt; &#34;&#34;
                 &#34;C:\\.&#34; =&gt; &#34;.&#34;
           &#34;C:\\foo.txt&#34; =&gt; &#34;.txt&#34;
      &#34;C:\\foo.txt\\bar&#34; =&gt; &#34;.txt\\bar&#34;
</pre></div>
<p>Right away, I&#39;m in debating mood - is <code>.foo</code>&#39;s extension <em>really</em> <code>.foo</code>? But
let&#39;s move on.</p>
<p>This example was run on Linux, so <code>C:\foo.txt\bar</code>&#39;s extension, according
to <code>filepath.Ext</code>, is.. <code>.txt\bar</code>.</p>
<p>Why? Because the Go standard library makes the assumption that a platform has
a single path separator - on Unix and BSD-likes, it&#39;s <code>/</code>, and on Windows
it&#39;s <code>\\</code>.</p>
<p>Except... that&#39;s not the whole truth. I was curious, so I checked:</p>
<div><p>C code</p><pre data-lang="c"><i>// in `fun.c`</i>

<i>void</i> <i>main</i>() {
  <i>HANDLE</i> <i>hFile</i> <i>=</i> <i>CreateFile</i>(<i>&#34;C:/Users/amos/test.txt&#34;</i>, <i>GENERIC_WRITE</i>, 0, <i>NULL</i>,
                            <i>CREATE_NEW</i>, <i>FILE_ATTRIBUTE_NORMAL</i>, <i>NULL</i>);

  <i>char</i> <i>*</i><i>data</i> <i>=</i> <i>&#34;Hello from the Win32 API&#34;</i>;
  <i>DWORD</i> <i>dwToWrite</i> <i>=</i> (<i>DWORD</i>) <i>strlen</i>(<i>data</i>);
  <i>DWORD</i> <i>dwWritten</i> <i>=</i> 0;
  <i>WriteFile</i>(<i>hFile</i>, <i>data</i>, <i>dwToWrite</i>, <i>&amp;</i><i>dwWritten</i>, <i>NULL</i>);
  <i>CloseHandle</i>(<i>hFile</i>);
}
</pre></div><div><p>Shell session</p><pre data-lang="shell">&gt; cl fun.c
Microsoft (R) C/C++ Optimizing Compiler Version 19.23.28107 for x64
Copyright (C) Microsoft Corporation.  All rights reserved.

fun.c
Microsoft (R) Incremental Linker Version 14.23.28107.0
Copyright (C) Microsoft Corporation.  All rights reserved.

/out:fun.exe
fun.obj
&gt; .\fun.exe
&gt; type C:\Users\amos\test.txt
Hello from the Win32 API
</pre></div>
<p>No funny <a href="https://www.msys2.org/">Unix emulation</a> business going on - just
regular old Windows 10.</p>
<p>And yet, in Go&#39;s standard library, the <code>path/filepath</code> package exports those
constants:</p>
<div><p>Go code</p><pre data-lang="go"><i>const</i> (
    <i>Separator</i>     <i>=</i> <i>os</i>.<i>PathSeparator</i>
    <i>ListSeparator</i> <i>=</i> <i>os</i>.<i>PathListSeparator</i>
)
</pre></div>
<p><code>os</code>, in turn, exports:</p>
<div><p>Go code</p><pre data-lang="go"><i>// src/os/path_windows.go</i>
<i>const</i> (
  <i>PathSeparator</i>     <i>=</i> <i>&#39;\\&#39;</i> <i>// OS-specific path separator</i>
  <i>PathListSeparator</i> <i>=</i> <i>&#39;;&#39;</i>  <i>// OS-specific path list separator</i>
)
</pre></div>
<p>So how comes <code>filepath.Ext</code> works with both separators on Windows?</p>
<div><p>Shell session</p><pre data-lang="shell">$ go run main.go
                     &#34;/&#34; =&gt; &#34;&#34;
                    &#34;/.&#34; =&gt; &#34;.&#34;
                 &#34;/.foo&#34; =&gt; &#34;.foo&#34;
                  &#34;/foo&#34; =&gt; &#34;&#34;
              &#34;/foo.txt&#34; =&gt; &#34;.txt&#34;
          &#34;/foo.txt/bar&#34; =&gt; &#34;&#34;
                  &#34;C:\\&#34; =&gt; &#34;&#34;
                 &#34;C:\\.&#34; =&gt; &#34;.&#34;
           &#34;C:\\foo.txt&#34; =&gt; &#34;.txt&#34;
      &#34;C:\\foo.txt\\bar&#34; =&gt; &#34;&#34;
</pre></div>
<p>Let&#39;s look at its implementation:</p>
<div><p>Go code</p><pre data-lang="go"><i>// src/path/filepath/path.go</i>

<i>func</i> <i>Ext</i>(<i>path</i> <i>string</i>) <i>string</i> {
  <i>for</i> <i>i</i> <i>:=</i> <i>len</i>(<i>path</i>) <i>-</i> 1; <i>i</i> <i>&gt;=</i> 0 <i>&amp;&amp;</i> <i>!</i><i>os</i>.<i>IsPathSeparator</i>(<i>path</i>[<i>i</i>]); <i>i</i><i>--</i> {
    <i>if</i> <i>path</i>[<i>i</i>] <i>==</i> <i>&#39;.&#39;</i> {
      <i>return</i> <i>path</i>[<i>i</i>:]
    }
  }
  <i>return</i> <i>&#34;&#34;</i>
}
</pre></div>
<p>Ah. An <code>IsPathSeparator</code> function.</p>
<p>Sure enough:</p>
<div><p>Go code</p><pre data-lang="go"><i>// src/os/path_windows.go</i>

<i>// IsPathSeparator reports whether c is a directory separator character.</i>
<i>func</i> <i>IsPathSeparator</i>(<i>c</i> <i>uint8</i>) <i>bool</i> {
  <i>// NOTE: Windows accept / as path separator.</i>
  <i>return</i> <i>c</i> <i>==</i> <i>&#39;\\&#39;</i> <i>||</i> <i>c</i> <i>==</i> <i>&#39;/&#39;</i>
}
</pre></div>
<p>(Can I just point out how hilarious that &#34;Extension&#34; was deemed long
enough to abbreviate to &#34;Ext&#34;, but &#34;IsPathSeparator&#34; wasn&#39;t?)</p>
<p>How does Rust handle this?</p>
<p>It has <code>std::path::is_separator</code>:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>/// Determines whether the character is one of the permitted</i>
<i>// path separators for the current platform.</i>
<i>pub</i> <i>fn</i> <i>is_separator</i><i>(</i><i>c</i>: <i>char</i><i>)</i> -&gt; <i>bool</i><i></i>
</pre></div>
<p>And it has <code>std::path::MAIN_SEPARATOR</code> - emphasis on <em>main</em> separator:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>/// The primary separator of path components for the current platform.</i>
<i>/// </i>
<i>/// For example, / on Unix and \ on Windows.</i>
<i>pub</i> <i>const</i> MAIN_SEPARATOR: <i>char</i><i></i>
</pre></div>
<p>The naming along makes it much clearer that there <em>might</em> be secondary path
separators, and the rich Path manipulation API makes it much less likely
to find this kind of code, for example:</p>
<div><p>Go code</p><pre data-lang="go">  <i>DefaultScripts</i> <i>=</i> <i>&#34;downloads&#34;</i> <i>+</i> <i>string</i>(<i>os</i>.<i>PathSeparator</i>) <i>+</i> <i>&#34;defaultScripts&#34;</i>
</pre></div>
<p>Or this kind:</p>
<div><p>Go code</p><pre data-lang="go">  <i>if</i> <i>os</i>.<i>PathSeparator</i> <i>==</i> <i>&#39;/&#39;</i> {
    <i>projname</i> <i>=</i> <i>strings</i>.<i>Replace</i>(<i>name</i>, <i>&#34;\\&#34;</i>, <i>&#34;/&#34;</i>, <i>-</i>1)
  } <i>else</i> <i>if</i> <i>os</i>.<i>PathSeparator</i> <i>==</i> <i>&#39;\\&#39;</i> {
    <i>projname</i> <i>=</i> <i>strings</i>.<i>Replace</i>(<i>name</i>, <i>&#34;/&#34;</i>, <i>&#34;\\&#34;</i>, <i>-</i>1)
  }
</pre></div>
<p>Or this... kind:</p>
<div><p>Go code</p><pre data-lang="go"><i>filefullpath</i> <i>=</i> <i>fmt</i>.<i>Sprintf</i>(<i>&#34;%s%c%s%c%s%c%s%c%s%s&#34;</i>,
    <i>a</i>.<i>DataDir</i>, <i>os</i>.<i>PathSeparator</i>,
    <i>m</i>[0:1], <i>os</i>.<i>PathSeparator</i>,
    <i>m</i>[1:2], <i>os</i>.<i>PathSeparator</i>,
    <i>m</i>[2:3], <i>os</i>.<i>PathSeparator</i>,
    <i>m</i>, <i>ext</i>)
</pre></div>
<p>It turns out Rust also has a &#34;get a path&#39;s extension&#34; function, but it&#39;s a lot
more conservative in the promises it makes:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>// Extracts the extension of self.file_name, if possible.</i>
<i>// </i>
<i>// The extension is:</i>
<i>// </i>
<i>//   * None, if there is no file name;</i>
<i>//   * None, if there is no embedded .;</i>
<i>//   * None, if the file name begins with . and has no other .s within;</i>
<i>//   * Otherwise, the portion of the file name after the final .</i>
<i>pub</i> <i>fn</i> <i>extension</i><i>(</i><i>&amp;</i><i>self</i><i>)</i> -&gt; <i>Option</i><i>&lt;</i><i>&amp;</i><i>OsStr</i><i>&gt;</i><i></i>
</pre></div>
<p>Let&#39;s submit it to the same test:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> inputs = <i>[</i>
        <i>r&#34;/&#34;</i>,
        <i>r&#34;/.&#34;</i>,
        <i>r&#34;/.foo&#34;</i>,
        <i>r&#34;/foo&#34;</i>,
        <i>r&#34;/foo.txt&#34;</i>,
        <i>r&#34;/foo.txt/bar&#34;</i>,
        <i>r&#34;C:\&#34;</i>,
        <i>r&#34;C:\.&#34;</i>,
        <i>r&#34;C:\foo.txt&#34;</i>,
        <i>r&#34;C:\foo.txt\bar&#34;</i>,
    <i>]</i><i>;</i>
    <i>for</i> input <i>in</i> <i>&amp;</i>inputs {
        <i>use</i> std<i>::</i>path<i>::</i>Path<i>;</i>
        <i>println</i><i>!</i><i>(</i><i>&#34;{:&gt;20} =&gt; {:?}&#34;</i>, input, Path::new<i>(</i>input<i>)</i>.extension<i>(</i><i>)</i><i>)</i><i>;</i>
    }
}
</pre></div>
<p>On Linux:</p>
<div><p>Shell session</p><pre data-lang="shell">$ cargo run --quiet
                   / =&gt; None
                  /. =&gt; None
               /.foo =&gt; None
               /foo. =&gt; Some(&#34;&#34;)
                /foo =&gt; None
            /foo.txt =&gt; Some(&#34;txt&#34;)
        /foo.txt/bar =&gt; None
                 C:\ =&gt; None
                C:\. =&gt; Some(&#34;&#34;)
          C:\foo.txt =&gt; Some(&#34;txt&#34;)
      C:\foo.txt\bar =&gt; Some(&#34;txt\\bar&#34;)
</pre></div>
<p>On Windows:</p>
<div><p>Shell session</p><pre data-lang="shell">$ cargo run --quiet
                   / =&gt; None
                  /. =&gt; None
               /.foo =&gt; None
               /foo. =&gt; Some(&#34;&#34;)
                /foo =&gt; None
            /foo.txt =&gt; Some(&#34;txt&#34;)
        /foo.txt/bar =&gt; None
                 C:\ =&gt; None
                C:\. =&gt; None
          C:\foo.txt =&gt; Some(&#34;txt&#34;)
      C:\foo.txt\bar =&gt; None
</pre></div>
<p>Like Go, it gives a <code>txt\bar</code> extension for a Windows path on Linux.</p>
<p>Unlike Go, it:</p>
<ul>
<li>Doesn&#39;t think &#34;/.foo&#34; has a file extension</li>
<li>Distinguishes between the &#34;/foo.&#34; case (<code>Some(&#34;&#34;)</code>) and the &#34;/foo&#34; case (<code>None</code>)</li>
</ul>
<p>Let&#39;s also look at the Rust implementation of <code>std::path::Path::extension</code>:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>pub</i> <i>fn</i> <i>extension</i><i>(</i><i>&amp;</i><i>self</i><i>)</i> -&gt; <i>Option</i><i>&lt;</i><i>&amp;</i><i>OsStr</i><i>&gt;</i> {
  <i>self</i><i>.</i><i>file_name</i><i>(</i><i>)</i><i>.</i><i>map</i><i>(</i>split_file_at_dot<i>)</i><i>.</i><i>and_then</i><i>(</i>|<i>(</i>before, after<i>)</i>| before<i>.</i><i>and</i><i>(</i>after<i>)</i><i>)</i>
}
</pre></div>
<p>Let&#39;s dissect that: first it calls <code>file_name()</code>. How does that work? Is it where
it searches for path separators backwards from the end of the path?</p>
<div><p>Rust code</p><pre data-lang="rust"><i>pub</i> <i>fn</i> <i>file_name</i><i>(</i><i>&amp;</i><i>self</i><i>)</i> -&gt; <i>Option</i><i>&lt;</i><i>&amp;</i><i>OsStr</i><i>&gt;</i> {
  <i>self</i><i>.</i><i>components</i><i>(</i><i>)</i><i>.</i><i>next_back</i><i>(</i><i>)</i><i>.</i><i>and_then</i><i>(</i>|p| <i>match</i> p {
    <i>Component</i><i>::</i>Normal<i>(</i>p<i>)</i> =&gt; Some<i>(</i>p<i>.</i><i>as_ref</i><i>(</i><i>)</i><i>)</i>,
    _ =&gt; None,
  }<i>)</i>
}
</pre></div>
<p>No! It calls <code>components</code> which returns a type that implements <code>DoubleEndedIterator</code> -
an iterator you can navigate from the front or the back. <em>Then</em> it grabs the first item
from the back - if any - and returns that.</p>
<p>The iterator <em>does</em> look for path separators - lazily, in a re-usable way. There is
no code duplication, like in the Go library:</p>
<div><p>Go code</p><pre data-lang="go"><i>// src/os/path_windows.go</i>

<i>func</i> <i>dirname</i>(<i>path</i> <i>string</i>) <i>string</i> {
  <i>vol</i> <i>:=</i> <i>volumeName</i>(<i>path</i>)
  <i>i</i> <i>:=</i> <i>len</i>(<i>path</i>) <i>-</i> 1
  <i>for</i> <i>i</i> <i>&gt;=</i> <i>len</i>(<i>vol</i>) <i>&amp;&amp;</i> <i>!</i><i>IsPathSeparator</i>(<i>path</i>[<i>i</i>]) {
    <i>i</i><i>--</i>
  }
  <i>dir</i> <i>:=</i> <i>path</i>[<i>len</i>(<i>vol</i>) : <i>i</i><i>+</i>1]
  <i>last</i> <i>:=</i> <i>len</i>(<i>dir</i>) <i>-</i> 1
  <i>if</i> <i>last</i> <i>&gt;</i> 0 <i>&amp;&amp;</i> <i>IsPathSeparator</i>(<i>dir</i>[<i>last</i>]) {
    <i>dir</i> <i>=</i> <i>dir</i>[:<i>last</i>]
  }
  <i>if</i> <i>dir</i> <i>==</i> <i>&#34;&#34;</i> {
    <i>dir</i> <i>=</i> <i>&#34;.&#34;</i>
  }
  <i>return</i> <i>vol</i> <i>+</i> <i>dir</i>
}
</pre></div>
<p>So, now we have <em>only the file name</em>. If we had <code>/foo/bar/baz.txt</code>, we&#39;re now only
dealing with <code>baz.txt</code> - as an <code>OsStr</code>, <em>not</em> a utf-8 <code>String</code>. We can still have
random bytes.</p>
<p>We then map this result through <code>split_file_at_dot</code>, which behaves like so:</p>
<ul>
<li>For <code>&#34;foo&#34;</code>, return <code>(Some(&#34;foo&#34;), None)</code></li>
<li>For <code>&#34;foo.bar&#34;</code>, return <code>(Some(&#34;foo&#34;), Some(&#34;bar&#34;))</code></li>
<li>For <code>&#34;foo.bar.baz&#34;</code>, return <code>(Some(&#34;foo.bar&#34;), Some(&#34;baz&#34;))</code></li>
</ul>
<p><code>and_then</code>, we only return <code>after</code> if <code>before</code> wasn&#39;t <code>None</code>.</p>
<p>If we spelled out everything, we&#39;d have:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>pub</i> <i>fn</i> extension<i>(</i><i>&amp;</i><i>self</i><i>)</i> -&gt; <i>Option</i><i>&lt;</i><i>&amp;</i><i>OsStr</i><i>&gt;</i> {
  <i>if</i> <i>let</i> Some<i>(</i>file_name<i>)</i> = <i>self</i><i>.</i><i>file_name</i><i>(</i><i>)</i> {
    <i>let</i> <i>(</i>before, after<i>)</i> = <i>split_file_at_dot</i><i>(</i>file_name<i>)</i><i>;</i>
    <i>if</i> <i>let</i> Some<i>(</i>before<i>)</i> {
      <i>// note: `after` is already an `Option&lt;&amp;OsStr&gt;` - it</i>
      <i>// might still be `None`.</i>
      <i>return</i> after
    }
  }
  None
}
</pre></div>
<p>The problem is carefully modelled. We can look at <em>what</em> we&#39;re manipulating
just by looking at its type. If it might not exist, it&#39;s an <code>Option&lt;T&gt;</code>! If
it&#39;s a path with multiple components, it&#39;s a <code>&amp;Path</code> (or its owned
counterpart, <code>PathBuf</code>). If it&#39;s just part of a path, it&#39;s an <code>&amp;OsStr</code>.</p>
<p>Of course there&#39;s a learning curve. Of course there&#39;s more concepts involved
than just throwing for loops at byte slices and seeing what sticks, like the
Go library does.</p>
<p>But the result is a high-performance, reliable and type-safe library.</p>
<p>It&#39;s worth it.</p>
<p>Speaking of Rust, we haven&#39;t seen how it handles the whole &#34;mode&#34; thing yet.</p>
<p>So <code>std::fs::Metadata</code> has <code>is_dir()</code> and <code>is_file()</code>, which return booleans.
It also has <code>len()</code>, which returns an <code>u64</code> (unsigned 64-bit integer).</p>
<p>It has <code>created()</code>, <code>modified()</code>, and <code>accessed()</code>, all of which return an
<code>Option&lt;SystemTime&gt;</code>. Again - the types inform us on what scenarios are
possible. Access timestamps might not exist at all.</p>
<p>The returned time is not an <code>std::time::Instant</code> - it&#39;s an
<code>std::time::SystemTime</code> - the documentation tells us the difference:</p>
<blockquote>
<p>A measurement of the system clock, useful for talking to external entities
like the file system or other processes.</p>
<p>Distinct from the
<a href="https://doc.rust-lang.org/std/time/struct.Instant.html"><code>Instant</code></a> type,
this time measurement <strong>is not monotonic</strong>. This means that you can save a
file to the file system, then save another file to the file system, <strong>and the
second file has a <code>SystemTime</code> measurement earlier than the first</strong>. In other
words, an operation that happens after another operation in real time may
have an earlier <code>SystemTime</code>!</p>
<p>Consequently, comparing two <code>SystemTime</code> instances to learn about the
duration between them returns a
<a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> instead of
an infallible
<a href="https://doc.rust-lang.org/std/time/struct.Duration.html"><code>Duration</code></a> to
indicate that this sort of time drift may happen and needs to be handled.</p>
<p>Although a <code>SystemTime</code> cannot be directly inspected, the
<a href="https://doc.rust-lang.org/std/time/constant.UNIX_EPOCH.html"><code>UNIX_EPOCH</code></a>
constant is provided in this module as an anchor in time to learn information
about a <code>SystemTime</code>. By calculating the duration from this fixed point in
time, a <code>SystemTime</code> can be converted to a human-readable time, or perhaps
some other string representation.</p>
<p>The size of a <code>SystemTime</code> struct may vary depending on the target operating
system.</p>
<p>Source: <a href="https://doc.rust-lang.org/std/time/struct.SystemTime.html">https://doc.rust-lang.org/std/time/struct.SystemTime.html</a></p>
</blockquote>

<p>What about permissions? Well, there it is:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>pub</i> <i>fn</i> <i>permissions</i><i>(</i><i>&amp;</i><i>self</i><i>)</i> -&gt; <i>Permissions</i><i></i>
</pre></div>
<p>A <code>Permissions</code> type! Just for that! And we can afford it, too - because
types don&#39;t cost anything at runtime. Everything probably ends up inlined
anyway.</p>
<p>What does it expose?</p>
<div><p>Rust code</p><pre data-lang="rust"><i>pub</i> <i>fn</i> <i>readonly</i><i>(</i><i>&amp;</i><i>self</i><i>)</i> -&gt; <i>bool</i> {}
<i>pub</i> <i>fn</i> <i>set_readonly</i><i>(</i><i>&amp;</i><i>mut</i> <i>self</i>, <i>readonly</i>: <i>bool</i><i>)</i> {}
</pre></div>
<p>Well! It exposes <em>only what all supported operating systems have in common</em>.</p>
<p>Can we still get Unix permission? Of course! But <em>only</em> on Unix:</p>
<blockquote>
<p>Representation of the various permissions on a file.</p>
<p>This module only currently provides one bit of information,
<a href="https://doc.rust-lang.org/std/fs/struct.Permissions.html#method.readonly"><code>readonly</code></a>,
which is exposed on all currently supported platforms. Unix-specific
functionality, such as mode bits, is available through the
<a href="https://doc.rust-lang.org/std/os/unix/fs/trait.PermissionsExt.html"><code>PermissionsExt</code></a>
trait.</p>
<p>Source: <a href="https://doc.rust-lang.org/std/fs/struct.Permissions.html">https://doc.rust-lang.org/std/fs/struct.Permissions.html</a></p>
</blockquote>
<p><code>std::os::unix::fs::PermissionsExt</code> is only compiled in on Unix, and exposes
the following functions:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>fn</i> <i>mode</i><i>(</i><i>&amp;</i><i>self</i><i>)</i> -&gt; <i>u32</i> {}
<i>fn</i> <i>set_mode</i><i>(</i><i>&amp;</i><i>mut</i> <i>self</i>, <i>mode</i>: <i>u32</i><i>)</i> {}
<i>fn</i> <i>from_mode</i><i>(</i><i>mode</i>: <i>u32</i><i>)</i> -&gt; <i>Self</i> {}
</pre></div>
<p>The documentation makes it <em>really clear</em> it&#39;s Unix-only:</p>
<p><img src="https://www.youtube.com/static/img/i-want-off-mr-golangs-wild-ride/unix-only.5cc6cc8731121cf0.png" title="" alt="" loading="lazy"/></p><p>But it&#39;s not just documentation. This sample program will compile and run
on Linux (and macOS, etc.)</p>
<div><p>Rust code</p><pre data-lang="rust"><i>use</i> std<i>::</i>fs<i>::</i>File<i>;</i>
<i>use</i> std<i>::</i>os<i>::</i>unix<i>::</i>fs<i>::</i>PermissionsExt<i>;</i>

<i>fn</i> <i>main</i><i>(</i><i>)</i> -&gt; std<i>::</i>io<i>::</i><i>Result</i><i>&lt;</i><i>(</i><i>)</i><i>&gt;</i> {
    <i>let</i> f = <i>File</i><i>::</i><i>open</i><i>(</i><i>&#34;/usr/bin/man&#34;</i><i>)</i>?<i>;</i>
    <i>let</i> metadata = f<i>.</i><i>metadata</i><i>(</i><i>)</i>?<i>;</i>
    <i>let</i> permissions = metadata<i>.</i><i>permissions</i><i>(</i><i>)</i><i>;</i>

    <i>println</i><i>!</i><i>(</i><i>&#34;permissions: {:o}&#34;</i>, permissions.mode<i>(</i><i>)</i><i>)</i><i>;</i>
    Ok<i>(</i><i>(</i><i>)</i><i>)</i>
}
</pre></div><div><p>Shell session</p><pre data-lang="shell">$ cargo run --quiet
permissions: 100755
</pre></div>
<p>But will fail to compile on Windows:</p>
<div><p>Shell session</p><pre data-lang="shell">$ cargo run --quiet
error[E0433]: failed to resolve: could not find `unix` in `os`
 --&gt; src\main.rs:2:14
  |
2 | use std::os::unix::fs::PermissionsExt;
  |              ^^^^ could not find `unix` in `os`

error[E0599]: no method named `mode` found for type `std::fs::Permissions` in the current scope
 --&gt; src\main.rs:9:47
  |
9 |     println!(&#34;permissions: {:o}&#34;, permissions.mode());
  |                                               ^^^^ method not found in `std::fs::Permissions`

error: aborting due to 2 previous errors

Some errors have detailed explanations: E0433, E0599.
For more information about an error, try `rustc --explain E0433`.
error: could not compile `rustfun`.

To learn more, run the command again with --verbose.
</pre></div>
<p>How can we make a program that runs on Windows too? The same way
the standard library only exposes <code>PermissionsExt</code> on Unix: with
attributes.</p>
<div><p>Rust code</p><pre data-lang="rust"><i>use</i> std<i>::</i>fs<i>::</i>File<i>;</i>
<i>#<i>[</i>cfg<i>(</i>target_family = <i>&#34;unix&#34;</i><i>)</i><i>]</i></i>
<i>use</i> std<i>::</i>os<i>::</i>unix<i>::</i>fs<i>::</i>PermissionsExt<i>;</i>

<i>fn</i> <i>main</i><i>(</i><i>)</i> -&gt; std<i>::</i>io<i>::</i><i>Result</i><i>&lt;</i><i>(</i><i>)</i><i>&gt;</i> {
    <i>let</i> arg = std<i>::</i>env<i>::</i><i>args</i><i>(</i><i>)</i><i>.</i><i>nth</i><i>(</i><i>1</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
    <i>let</i> f = <i>File</i><i>::</i><i>open</i><i>(</i><i>&amp;</i>arg<i>)</i>?<i>;</i>
    <i>let</i> metadata = f<i>.</i><i>metadata</i><i>(</i><i>)</i>?<i>;</i>
    <i>let</i> permissions = metadata<i>.</i><i>permissions</i><i>(</i><i>)</i><i>;</i>

    <i>#<i>[</i>cfg<i>(</i>target_family = <i>&#34;unix&#34;</i><i>)</i><i>]</i></i>
    {
        <i>println</i><i>!</i><i>(</i><i>&#34;permissions: {:o}&#34;</i>, permissions.mode<i>(</i><i>)</i><i>)</i><i>;</i>
    }

    <i>#<i>[</i>cfg<i>(</i>target_family = <i>&#34;windows&#34;</i><i>)</i><i>]</i></i>
    {
        <i>println</i><i>!</i><i>(</i><i>&#34;readonly? {:?}&#34;</i>, permissions.readonly<i>(</i><i>)</i><i>)</i><i>;</i>
    }

    Ok<i>(</i><i>(</i><i>)</i><i>)</i>
}
</pre></div>
<p>Those aren&#39;t <code>#ifdef</code> - they&#39;re not preprocessor directives. There&#39;s no risk
of forgetting an <code>#endif</code>. And if you miss if/else chains, <a href="https://github.com/alexcrichton/cfg-if">there&#39;s a crate
for that</a>.</p>
<p>Here&#39;s that sample program on Linux:</p>
<div><p>Shell session</p><pre data-lang="shell">$ cargo run --quiet -- /usr/bin/man
permissions: 100755
</pre></div>
<p>And on Windows:</p>
<div><p>Shell session</p><pre data-lang="shell">$ cargo run --quiet -- Cargo.toml
readonly? false
</pre></div>
<p>Can you do that in Go? Sure! Kind of!</p>
<p>There&#39;s two ways to do something similar, and both involve multiple files.</p>
<p>Here&#39;s one:</p>
<div><p>Shell session</p><pre data-lang="shell">$ go mod init github.com/fasterthanlime/gofun
</pre></div>
<p>In <code>main.go</code>, we need:</p>
<div><p>Go code</p><pre data-lang="go"><i>package</i> main

<i>import</i> <i>&#34;os&#34;</i>

<i>func</i> <i>main</i>() {
        <i>poke</i>(<i>os</i>.<i>Args</i>[1])
}
</pre></div>
<p>In <code>poke_windows.go</code>, we need:</p>
<div><p>Go code</p><pre data-lang="go"><i>package</i> main

<i>import</i> (
        <i>&#34;fmt&#34;</i>
        <i>&#34;os&#34;</i>
)

<i>func</i> <i>poke</i>(<i>path</i> <i>string</i>) {
        <i>stats</i>, <i>_</i> <i>:=</i> <i>os</i>.<i>Stat</i>(<i>path</i>)
        <i>fmt</i>.<i>Printf</i>(<i>&#34;readonly? %v\n&#34;</i>, (<i>stats</i>.<i>Mode</i>() <i>&amp;</i> 0o600) <i>==</i> 0);
}
</pre></div>
<p>And in <code>poke_unix.go</code>, we need:</p>
<div><p>Go code</p><pre data-lang="go"><i>// +build !windows</i>

<i>package</i> main

<i>import</i> (
        <i>&#34;fmt&#34;</i>
        <i>&#34;os&#34;</i>
)

<i>func</i> <i>poke</i>(<i>path</i> <i>string</i>) {
    <i>stats</i>, <i>_</i> <i>:=</i> <i>os</i>.<i>Stat</i>(<i>path</i>)
    <i>fmt</i>.<i>Printf</i>(<i>&#34;permissions: %o\n&#34;</i>, <i>stats</i>.<i>Mode</i>() <i>&amp;</i> <i>os</i>.<i>ModePerm</i>);
}
</pre></div>
<p>Note how the <code>_windows.go</code> suffix is magic - it&#39;ll get automatically excluded
on non-Windows platforms. There&#39;s no magic suffix for Unix systems though!</p>
<p>So we have to add a <a href="https://golang.org/pkg/go/build/">build constraint</a>, which is:</p>
<ul>
<li>A comment</li>
<li>That must be &#34;near the top of the file&#34;</li>
<li>That can only be preceded by blank space</li>
<li>That must appear before the package clause</li>
<li>That has its own language</li>
</ul>
<p>From the docs:</p>
<blockquote>
<p>A build constraint is evaluated as the OR of space-separated options. Each
option evaluates as the AND of its comma-separated terms. Each term consists
of letters, digits, underscores, and dots. A term may be negated with a
preceding !. For example, the build constraint:</p>
<p><code>// +build linux,386 darwin,!cgo</code></p>
<p>corresponds to the boolean formula:</p>
<p><code>(linux AND 386) OR (darwin AND (NOT cgo))</code></p>
<p>A file may have multiple build constraints. The overall constraint is the AND
of the individual constraints. That is, the build constraints:</p>
<p><code>// +build linux darwin</code></p>
<p>corresponds to the boolean formula:</p>
<p><code>(linux OR darwin) AND 386</code></p>
</blockquote>
<p>Fun! Fun fun fun. So, on Linux, we get:</p>
<div><p>Shell session</p><pre data-lang="shell">$ go build
$ ./gofun /usr/bin/man
permissions: 755
$ ./gofun /etc/hosts
permissions: 644
</pre></div>
<p>And on Windows, we get:</p>
<div><p>Shell session</p><pre data-lang="shell">&gt; go build
&gt; .\gofun.exe .\main.go
readonly? false
</pre></div>
<p>Now, <em>at least there&#39;s a way</em> to write platform-specific code in Go.</p>
<p>In practice, it gets old very quickly. You now have related code split across
multiple files, even if <em>only one</em> of the functions is platform-specific.</p>
<p>Build constraints override the magic suffixes, so it&#39;s never obvious exactly
which files are compiled in. You also have to duplicate (and keep in sync!)
function signatures all over the place.</p>
<p>It&#39;s... a hack. A shortcut. And an annoying one, at that.</p>
<p>So what happens when you make it hard for users to do things the right way?
(The right way being, in this case, to <em>not</em> compile in code that isn&#39;t relevant
for a given platform). They take shortcuts, too.</p>
<p>Even in the official Go distribution, a lot of code just switches on the value
of <code>runtime.GOOS</code> at, well, run-time:</p>
<div><p>Go code</p><pre data-lang="go"><i>// src/net/file_test.go</i>

<i>func</i> <i>TestFileConn</i>(<i>t</i> <i>*</i>testing.<i>T</i>) {
  <i>switch</i> <i>runtime</i>.<i>GOOS</i> {
  <i>case</i> <i>&#34;plan9&#34;</i>, <i>&#34;windows&#34;</i>:
    <i>t</i>.<i>Skipf</i>(<i>&#34;not supported on %s&#34;</i>, <i>runtime</i>.<i>GOOS</i>)
  }

  <i>for</i> <i>_</i>, <i>tt</i> <i>:=</i> <i>range</i> <i>fileConnTests</i> {
    <i>if</i> <i>!</i><i>testableNetwork</i>(<i>tt</i>.<i>network</i>) {
      <i>t</i>.<i>Logf</i>(<i>&#34;skipping %s test&#34;</i>, <i>tt</i>.<i>network</i>)
      <i>continue</i>
    }
</pre></div>
<p>&#34;But these are little things!&#34;</p>
<p>They&#39;re all little things. They add up. Quickly.</p>
<p>And they&#39;re symptomatic of the problems with &#34;the Go way&#34; in general. The Go
way is to half-ass things.</p>
<p>The Go way is to patch things up until they sorta kinda work, in the name of
simplicity.</p>
<h2>Lots of little things</h2>
<p>Speaking of little things, let&#39;s consider what pushed me over the edge and
provoked me to write this whole rant in the first place.</p>
<p>It was <a href="https://github.com/getlantern/idletiming">this package</a>.</p>
<p>What does it do?</p>
<blockquote>
<p>Provides mechanisms for adding idle timeouts to <code>net.Conn</code> and <code>net.Listener</code>.</p>
</blockquote>
<p>Why do we need it?</p>
<p>Because the real-world is messy.</p>
<p>If you do a naive HTTP request in Go:</p>
<div><p>Go code</p><pre data-lang="go"><i>package</i> main

<i>import</i> (
  <i>&#34;fmt&#34;</i>
  <i>&#34;io/ioutil&#34;</i>
  <i>&#34;net/http&#34;</i>
)

<i>func</i> <i>main</i>() {
  <i>res</i>, <i>err</i> <i>:=</i> <i>http</i>.<i>Get</i>(<i>&#34;http://perdu.com&#34;</i>)
  <i>must</i>(<i>err</i>)
  <i>defer</i> <i>res</i>.<i>Body</i>.<i>Close</i>() <i>// this is a *very* common gotcha</i>

  <i>body</i>, <i>err</i> <i>:=</i> <i>ioutil</i>.<i>ReadAll</i>(<i>res</i>.<i>Body</i>)
  <i>must</i>(<i>err</i>)
  <i>fmt</i>.<i>Printf</i>(<i>&#34;%s&#34;</i>, <i>string</i>(<i>body</i>))
}

<i>func</i> <i>must</i>(<i>err</i> <i>error</i>) {
  <i>if</i> <i>err</i> <i>!=</i> <i>nil</i> {
    <i>panic</i>(<i>err</i>)
  }
}
</pre></div><div><p>Shell session</p><pre data-lang="shell">$ go run main.go
&lt;html&gt;&lt;head&gt;&lt;title&gt;Vous Etes Perdu ?&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Perdu sur l&#39;Internet ?&lt;/h1&gt;&lt;h2&gt;Pas de panique, on va vous aider&lt;/h2&gt;&lt;strong&gt;&lt;pre&gt;    * &lt;----- vous &amp;ecirc;tes ici&lt;/pre&gt;&lt;/strong&gt;&lt;/body&gt;&lt;/html&gt;
</pre></div>
<p>Then it works. When it works.</p>
<p>If the server never accepts your connection - which might <em>definitely</em> happen
if it&#39;s dropping all the traffic to the relevant port, then you&#39;ll just hang
forever.</p>
<p>If you <em>don&#39;t</em> want to hang forever, you have to do something else.</p>
<p>Like this:</p>
<div><p>Go code</p><pre data-lang="go"><i>package</i> main

<i>import</i> (
  <i>&#34;fmt&#34;</i>
  <i>&#34;io/ioutil&#34;</i>
  <i>&#34;net&#34;</i>
  <i>&#34;net/http&#34;</i>
  <i>&#34;time&#34;</i>
)

<i>func</i> <i>main</i>() {
  <i>client</i> <i>:=</i> <i>&amp;</i>http.<i>Client</i>{
    <i>Transport</i>: <i>&amp;</i>http.<i>Transport</i>{
      <i>DialContext</i>: (<i>&amp;</i>net.<i>Dialer</i>{
        <i>Timeout</i>: 5 <i>*</i> <i>time</i>.<i>Second</i>,
      }).<i>DialContext</i>,
    },
  }

  <i>req</i>, <i>err</i> <i>:=</i> <i>http</i>.<i>NewRequest</i>(<i>&#34;GET&#34;</i>, <i>&#34;http://perdu.com&#34;</i>, <i>nil</i>)
  <i>must</i>(<i>err</i>)

  <i>res</i>, <i>err</i> <i>:=</i> <i>client</i>.<i>Do</i>(<i>req</i>)
  <i>must</i>(<i>err</i>)
  <i>defer</i> <i>res</i>.<i>Body</i>.<i>Close</i>()

  <i>body</i>, <i>err</i> <i>:=</i> <i>ioutil</i>.<i>ReadAll</i>(<i>res</i>.<i>Body</i>)
  <i>must</i>(<i>err</i>)
  <i>fmt</i>.<i>Printf</i>(<i>&#34;%s&#34;</i>, <i>string</i>(<i>body</i>))
}

<i>func</i> <i>must</i>(<i>err</i> <i>error</i>) {
  <i>if</i> <i>err</i> <i>!=</i> <i>nil</i> {
    <i>panic</i>(<i>err</i>)
  }
}
</pre></div>
<p>Not so simple, but, eh, whatever, it works.</p>
<p>Unless the server accepts your connection, says it&#39;s going to send a bunch of bytes,
and then <em>never sends you anything</em>.</p>
<p>Which definitely, 100%, for-sure, if-it-can-happen-it-does-happen, happens.</p>
<p>And then you hang forever.</p>
<p>To avoid that, you can set a timeout on <em>the whole request</em>, like so:</p>
<div><p>Go code</p><pre data-lang="go"><i>package</i> main

<i>import</i> (
  <i>&#34;context&#34;</i>
  <i>&#34;fmt&#34;</i>
  <i>&#34;io/ioutil&#34;</i>
  <i>&#34;net/http&#34;</i>
  <i>&#34;time&#34;</i>
)

<i>func</i> <i>main</i>() {
  <i>ctx</i>, <i>cancel</i> <i>:=</i> <i>context</i>.<i>WithTimeout</i>(<i>context</i>.<i>Background</i>(), 5<i>*</i><i>time</i>.<i>Second</i>)
  <i>defer</i> <i>cancel</i>()
  <i>req</i>, <i>err</i> <i>:=</i> <i>http</i>.<i>NewRequestWithContext</i>(<i>ctx</i>, <i>&#34;GET&#34;</i>, <i>&#34;http://perdu.com&#34;</i>, <i>nil</i>)
  <i>must</i>(<i>err</i>)

  <i>res</i>, <i>err</i> <i>:=</i> <i>http</i>.<i>DefaultClient</i>.<i>Do</i>(<i>req</i>)
  <i>must</i>(<i>err</i>)
  <i>defer</i> <i>res</i>.<i>Body</i>.<i>Close</i>()

  <i>body</i>, <i>err</i> <i>:=</i> <i>ioutil</i>.<i>ReadAll</i>(<i>res</i>.<i>Body</i>)
  <i>must</i>(<i>err</i>)
  <i>fmt</i>.<i>Printf</i>(<i>&#34;%s&#34;</i>, <i>string</i>(<i>body</i>))
}

<i>func</i> <i>must</i>(<i>err</i> <i>error</i>) {
  <i>if</i> <i>err</i> <i>!=</i> <i>nil</i> {
    <i>panic</i>(<i>err</i>)
  }
}
</pre></div>
<p>But that doesn&#39;t work if you&#39;re planning on uploading something large, for
example. How many seconds is enough to upload a large file? Is 30 seconds
enough? And how do you know you&#39;re spending those seconds uploading, and not
waiting for the server to accept your request?</p>
<p>So, <code>getlantern/idletiming</code> adds a mechanism for timing out <em>if there hasn&#39;t
been any data transmitted in a while</em>, which is distinct from a dial timeout,
and doesn&#39;t force you to set a timeout on the <em>whole request</em>, so that it
works for arbitrarily large uploads.</p>
<p>The repository looks innocent enough:</p>
<p><img src="https://www.youtube.com/static/img/i-want-off-mr-golangs-wild-ride/idle-repo.097cbc4b39fb709f.png" title="" alt="" loading="lazy"/></p><p>Just a couple files! And even some tests. Also - it works. I&#39;m using it
in production. I&#39;m happy with it.</p>
<p>There&#39;s just.. one thing.</p>
<div><p>Shell session</p><pre data-lang="shell">$ git clone https://github.com/getlantern/idletiming
Cloning into &#39;idletiming&#39;...
(cut)
$ cd idletiming
$ go mod graph | wc -l
196
</pre></div>
<p>I&#39;m sorry?</p>
<p>One hundred and ninety-six packages?</p>
<p>Well, I mean... lots of small, well-maintained libraries isn&#39;t necessarily a
bad idea - I never really agreed that the takeaway from the <code>left-pad</code> disaster
was &#34;small libraries are bad&#34;.</p>
<p>Let&#39;s look at what we&#39;ve got there:</p>
<div><p>Shell session</p><pre data-lang="shell">$ go mod graph
github.com/getlantern/idletiming github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183
github.com/getlantern/idletiming github.com/getlantern/fdcount@v0.0.0-20190912142506-f89afd7367c4
github.com/getlantern/idletiming github.com/getlantern/golog@v0.0.0-20190830074920-4ef2e798c2d7
github.com/getlantern/idletiming github.com/getlantern/grtrack@v0.0.0-20160824195228-cbf67d3fa0fd
github.com/getlantern/idletiming github.com/getlantern/mtime@v0.0.0-20170117193331-ba114e4a82b0
github.com/getlantern/idletiming github.com/getlantern/netx@v0.0.0-20190110220209-9912de6f94fd
github.com/getlantern/idletiming github.com/stretchr/testify@v1.4.0
</pre></div>
<p>I&#39;m sure all of these are reasonable. Lantern is a &#34;site unblock&#34; product, so
it has to deal with networking a lot, it makes sense that they&#39;d have their
own libraries for a bunch of things, including logging (<code>golog</code>) and some
network extensions (<code>netx</code>). <code>testify</code> is a well-known set of testing
helpers, I use it too!</p>
<p>Let&#39;s keep going:</p>
<div><p>Shell session</p><pre data-lang="shell">github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/Shopify/sarama@v1.23.1
</pre></div>
<p>Uhh....</p>
<div><p>Shell session</p><pre data-lang="shell">github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/aristanetworks/fsnotify@v1.4.2
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/aristanetworks/glog@v0.0.0-20180419172825&gt;
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/aristanetworks/splunk-hec-go@v0.3.3
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/garyburd/redigo@v1.6.0
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/golang/protobuf@v1.3.2
</pre></div>
<p>Wait, I think we..</p>
<div><p>Shell session</p><pre data-lang="shell">github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/influxdata/influxdb1-client@v0.0.0-201908&gt;
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/klauspost/cpuid@v1.2.1
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/klauspost/reedsolomon@v1.9.2
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/kylelemons/godebug@v1.1.0
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/onsi/ginkgo@v1.10.1
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/onsi/gomega@v1.7.0
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/openconfig/gnmi@v0.0.0-20190823184014-89b&gt;
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/openconfig/reference@v0.0.0-2019072701583&gt;
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/prometheus/client_golang@v1.1.0
</pre></div>
<p>I can understand some of these but...</p>
<div><p>Shell session</p><pre data-lang="shell">github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/satori/go.uuid@v1.2.0
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/stretchr/testify@v1.3.0
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/templexxx/cpufeat@v0.0.0-20180724012125-c&gt;
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/templexxx/xor@v0.0.0-20181023030647-4e92f&gt;
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/tjfoc/gmsm@v1.0.1
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/xtaci/kcp-go@v5.4.5+incompatible
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/xtaci/lossyconn@v0.0.0-20190602105132-8df&gt;
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 golang.org/x/net@v0.0.0-20190912160710-24e19bdeb0f2
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 golang.org/x/sys@v0.0.0-20190912141932-bc967efca4b8
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 golang.org/x/time@v0.0.0-20190308202827-9d24e82272b4
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 golang.org/x/tools@v0.0.0-20190912185636-87d9f09c5d89
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 google.golang.org/grpc@v1.23.1
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 gopkg.in/bsm/ratelimit.v1@v1.0.0-20160220154919-db14&gt;
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 gopkg.in/jcmturner/goidentity.v3@v3.0.0
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 gopkg.in/redis.v4@v4.2.4
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 gopkg.in/yaml.v2@v2.2.2
</pre></div>
<p>STOP! Just stop. Stop it already.</p>
<p>It keeps going on, and on. There&#39;s everything.</p>
<p><a href="https://en.wikipedia.org/wiki/YAML">YAML</a>, <a href="https://redis.io/">Redis</a>,
<a href="https://grpc.io/">GRPC</a>, which in turns needs
<a href="https://developers.google.com/protocol-buffers/">protobuf</a>,
<a href="https://en.wikipedia.org/wiki/InfluxDB">InfluxDB</a>, an <a href="https://github.com/Shopify/sarama">Apache Kafka
client</a>, a
<a href="https://prometheus.io/">Prometheus</a> client,
<a href="https://en.wikipedia.org/wiki/Snappy_(compression)">Snappy</a>,
<a href="https://en.wikipedia.org/wiki/Zstandard">Zstandard</a>,
<a href="https://lz4.github.io/lz4/">LZ4</a>, <a href="https://github.com/shopify/toxiproxy">a chaos-testing TCP
proxy</a>, three other logging packages, and client
libraries for various Google Cloud services.</p>
<p>What could <em>possibly</em> justify all this?</p>
<p>Let&#39;s review:</p>
<div><p>Go code</p><pre data-lang="go"><i>// `idletiming_listener.go`</i>

<i>package</i> idletiming

<i>import</i> (
  <i>&#34;net&#34;</i>
  <i>&#34;time&#34;</i>
)
</pre></div>
<p>Only built-in imports. Good.</p>
<div><p>Go code</p><pre data-lang="go"><i>// `idletiming_conn.go`</i>

<i>// package idletiming provides mechanisms for adding idle timeouts to net.Conn</i>
<i>// and net.Listener.</i>
<i>package</i> idletiming

<i>import</i> (
  <i>&#34;errors&#34;</i>
  <i>&#34;io&#34;</i>
  <i>&#34;net&#34;</i>
  <i>&#34;sync&#34;</i>
  <i>&#34;sync/atomic&#34;</i>
  <i>&#34;time&#34;</i>

  <i>&#34;github.com/getlantern/golog&#34;</i>
  <i>&#34;github.com/getlantern/mtime&#34;</i>
  <i>&#34;github.com/getlantern/netx&#34;</i>
)
</pre></div>
<p>This one is the meat of the library, so to say, and it requires a few of the
<code>getlantern</code> packages we&#39;ve seen:</p>
<p><img src="https://www.youtube.com/static/img/i-want-off-mr-golangs-wild-ride/golog-graph.ddfff2c409797eff.png" title="" alt="" loading="lazy"/></p><p>It does end up importing <code>golang.org/x/net/http2/hpack</code> - but that&#39;s just because
of <code>net/http</code>. These are built-ins, so let&#39;s ignore them for now.</p>
<p><code>getlantern/hex</code> is self-contained, so, moving on to <code>getlantern/mtime</code>:</p>
<p><img src="https://www.youtube.com/static/img/i-want-off-mr-golangs-wild-ride/mtime-graph.eb60f21782ed6818.png" title="" alt="" loading="lazy"/></p><p>That&#39;s it? What&#39;s why Go ends up fetching <em>the entire</em>
<code>github.com/aristanetworks/goarista</code> repository, and <em>all its transitive
dependencies</em>?</p>
<p>What does <code>aristanetworks/goariasta/monotime</code> even do?</p>
<p><img src="https://www.youtube.com/static/img/i-want-off-mr-golangs-wild-ride/monotime-github.9012a90a2b59801a.png" title="" alt="" loading="lazy"/></p><p>Mh. Let&#39;s look inside <code>issue15006.s</code></p>
<div><p>C code</p><pre data-lang="c"><i>// Copyright (c) 2016 Arista Networks, Inc.</i>
<i>// Use of this source code is governed by the Apache License 2.0</i>
<i>// that can be found in the COPYING file.</i>

<i>// This file is intentionally empty.</i>
<i>// It&#39;s a workaround for https://github.com/golang/go/issues/15006</i>
</pre></div>
<p>I uh... okay.</p>
<p>What does <a href="https://github.com/golang/go/issues/15006">that issue</a> say?</p>
<blockquote>
<p>This is known and I think the empty assembly file is the accepted fix.</p>
<p>It&#39;s a rarely used feature and having an assembly file also make it
standout.</p>
<p>I don&#39;t think we should make this unsafe feature easy to use.</p>
</blockquote>
<p>And later (emphasis mine):</p>
<blockquote>
<p>I agree with Minux. If you&#39;re looking at a Go package to import, you might
want to know if it does any unsafe trickery. Currently you have to grep for
an import of unsafe <strong>and look for non-.go files</strong>. If we got rid of the
requirement for the empty .s file, then you&#39;d have to grep for //go:linkname
also.</p>
</blockquote>
<p>That&#39;s... that&#39;s certainly a stance.</p>
<p>But <em>which</em> unsafe feature exactly?</p>
<p>Let&#39;s look at <code>nanotime.go</code>:</p>
<div><p>Go code</p><pre data-lang="go"><i>// Copyright (c) 2016 Arista Networks, Inc.</i>
<i>// Use of this source code is governed by the Apache License 2.0</i>
<i>// that can be found in the COPYING file.</i>

<i>// Package monotime provides a fast monotonic clock source.</i>
<i>package</i> monotime

<i>import</i> (
  <i>&#34;time&#34;</i>
  _ <i>&#34;unsafe&#34;</i> <i>// required to use //go:linkname</i>
)

<i>//go:noescape</i>
<i>//go:linkname nanotime runtime.nanotime</i>
<i>func</i> <i>nanotime</i>() <i>int64</i>

<i>// Now returns the current time in nanoseconds from a monotonic clock.</i>
<i>// The time returned is based on some arbitrary platform-specific point in the</i>
<i>// past.  The time returned is guaranteed to increase monotonically at a</i>
<i>// constant rate, unlike time.Now() from the Go standard library, which may</i>
<i>// slow down, speed up, jump forward or backward, due to NTP activity or leap</i>
<i>// seconds.</i>
<i>func</i> <i>Now</i>() <i>uint64</i> {
  <i>return</i> <i>uint64</i>(<i>nanotime</i>())
}

<i>// Since returns the amount of time that has elapsed since t. t should be</i>
<i>// the result of a call to Now() on the same machine.</i>
<i>func</i> <i>Since</i>(<i>t</i> <i>uint64</i>) time.<i>Duration</i> {
  <i>return</i> <i>time</i>.<i>Duration</i>(<i>Now</i>() <i>-</i> <i>t</i>)
}
</pre></div>
<p>That&#39;s it. That&#39;s the whole package.</p>
<p>The unsafe feature in question is being able to access unexported (read:
lowercase, <em>sigh</em>) symbols from the Go standard library.</p>
<p>Why is that even needed?</p>
<p>If you remember from earlier, Rust has two types for time: <code>SystemTime</code>,
which corresponds to your... system&#39;s... time, which can be adjusted via
<a href="https://en.wikipedia.org/wiki/Network_Time_Protocol">NTP</a>. It can go
back, so subtraction can fail.</p>
<p>And it has <code>Instant</code>, which is weakly monotonically increasing - at worse,
it&#39;ll give the same value twice, but never <em>less</em> than the previous value.
This is useful to measure elapsed time <em>within a process</em>.</p>
<p>How did Go solve that problem?</p>
<p>At first, <a href="https://github.com/golang/go/issues/16658">it didn&#39;t</a>. Monotonic
time measurement is a hard problem, so it was only available internally, in
the standard library, not for regular Go developers (a common theme):</p>
<p><img src="https://www.youtube.com/static/img/i-want-off-mr-golangs-wild-ride/expose-nanotime.91186ecee6915d08.png" title="" alt="" loading="lazy"/></p><p>And then, <a href="https://github.com/golang/go/issues/12914">it did</a>.</p>
<p>Sort of. In the most &#34;Go way&#34; possible.</p>
<blockquote>
<p>I thought some more about the suggestion above to reuse <code>time.Time</code> with a
special location. The special location still seems wrong, but what if we
reuse <code>time.Time</code> by storing inside it both a wall time and a monotonic time,
fetched one after the other?</p>
<p>Then there are two kinds of <code>time.Time</code>s: those with wall <em>and</em> monotonic
stored inside (let&#39;s call those &#34;wall+monotonic Times&#34;) and those with only
wall stored inside (let&#39;s call those &#34;wall-only Times&#34;).</p>
<p>Suppose further that:</p>
<ul>
<li><code>time.Now</code> returns a wall+monotonic Time.</li>
<li>for <code>t.Add(d)</code>, if t is a wall+monotonic Time, so is the result;
if t is wall-only, so is the result.</li>
<li>all other functions that return Times return wall-only Times. These include:
<code>time.Date</code>, <code>time.Unix</code>, <code>t.AddDate</code>, <code>t.In</code>, <code>t.Local</code>, <code>t.Round</code>, <code>t.Truncate</code>,
<code>t.UTC</code></li>
<li>for <code>t.Sub(u)</code>, if t and u are both wall+monotonic, the result is computed by
subtracting monotonics; otherwise the result is computed by subtracting wall
times. - <code>t.After(u)</code>, <code>t.Before(u)</code>, <code>t.Equal(u)</code> compare monotonics if available
(just like <code>t.Sub(u)</code>), otherwise walls.</li>
<li>all the other functions that operate on time.Times use the wall time only.
These include: <code>t.Day</code>, <code>t.Format</code>, <code>t.Month</code>, <code>t.Unix</code>, <code>t.UnixNano</code>, <code>t.Year</code>, and so on.</li>
</ul>
<p>Doing this returns a kind of hybrid time from <code>time.Now</code>: it works as a wall
time but also works as a monotonic time, and future operations use the right
one.</p>
</blockquote>
<p>So, as of Go 1.9 - problem solved!</p>
<p>If you&#39;re confused by the proposal, no worries, let&#39;s check out the release notes:</p>
<blockquote>
<h3>Transparent Monotonic Time support</h3>
<p>The <a href="https://golang.org/pkg/time/"><code>time</code></a> package now transparently tracks
monotonic time in each <a href="https://golang.org/pkg/time/#Time"><code>Time</code></a> value,
making computing durations between two <code>Time</code> values a safe operation in the
presence of wall clock adjustments. See the <a href="https://golang.org/pkg/time/#hdr-Monotonic_Clocks">package
docs</a> and <a href="https://golang.org/design/12914-monotonic">design
document</a> for details.</p>
</blockquote>
<p>This changed the behavior of a number of Go packages, but, the core team
knows best:</p>
<p><img src="https://www.youtube.com/static/img/i-want-off-mr-golangs-wild-ride/breaking-change.b82df9b116893561.png" alt="" loading="lazy"/>
This <em>is</em> a breaking change, but more importantly, it wasn&#39;t before the
introduction of Go modules (declared &#34;stable&#34; as of Go 1.14) that you could
require a certain Go version for a package.</p>
<p>So, if you have a package without a minimum required Go version, you can&#39;t be
sure you have the &#34;transparent monotonic time support&#34; of Go 1.9, and it&#39;s
better to rely on <code>aristanetworks/goarista/monotime</code>, which pulls 100+ packages,
because Go packages are &#34;simple&#34; and they&#39;re just folders in a git repository.</p>

<p>The change raised other questions: since <code>time.Time</code> now sometimes packs two
types of time, two calls are needed. This concern was dismissed.</p>
<p><img src="https://www.youtube.com/static/img/i-want-off-mr-golangs-wild-ride/two-calls.04cfddee818e9b5e.png" title="" alt="" loading="lazy"/></p><p>In order for <code>time.Time</code> not to grow, both values were <em>packed</em> inside it, which
restricted the range of times that could be represented with it:</p>
<p><img src="https://www.youtube.com/static/img/i-want-off-mr-golangs-wild-ride/packing.d8321c16b18c6d25.png" title="" alt="" loading="lazy"/></p><p>This issue was raised early on in the design process:</p>
<p><img src="https://www.youtube.com/static/img/i-want-off-mr-golangs-wild-ride/embedded1.dcd07cb5b88be4b4.png" title="" alt="" loading="lazy"/><img src="https://www.youtube.com/static/img/i-want-off-mr-golangs-wild-ride/embedded2.3bd7c390cdae5d69.png" title="" alt="" loading="lazy"/></p><p>You can check out <a href="https://github.com/golang/go/issues/12914">the complete
thread</a> for a full history.</p>
<h2>Parting words</h2>
<p>This is just one issue. But there are many like it - this one is as good an
example as any.</p>
<p>Over and over, Go is a victim of its own mantra - &#34;simplicity&#34;.</p>
<p>It constantly takes power away from its users, reserving it for itself.</p>
<p>It constantly lies about how complicated real-world systems are, and optimize
for the 90% case, ignoring correctness.</p>
<p>It is a minefield of subtle gotchas that have very real implications -
everything looks simple <em>on the surface</em>, but nothing is.</p>
<p>The <a href="https://dave.cheney.net/2014/03/19/channel-axioms">Channel Axioms</a> are a
good example. There is nothing explicit about them. They are invented truths,
that were convenient to implement, and who everyone must now work around.</p>
<p>Here&#39;s a fun gotcha I haven&#39;t mentioned yet:</p>
<div><p>Go code</p><pre data-lang="go"><i>// IdleTimingConn is a net.Conn that wraps another net.Conn and that times out</i>
<i>// if idle for more than idleTimeout.</i>
<i>type</i> <i>IdleTimingConn</i> <i>struct</i> {
  <i>// Keep 64-bit words at the top to make sure 64-bit alignment, see</i>
  <i>// https://golang.org/pkg/sync/atomic/#pkg-note-BUG</i>
  <i>lastActivityTime</i> <i>uint64</i>

  <i>// (cut)</i>
}
</pre></div>
<p>The documentation reads:</p>
<blockquote>
<p>BUGS</p>
<p>On ARM, x86-32, and 32-bit MIPS, it is the caller&#39;s responsibility to arrange
for 64-bit alignment of 64-bit words accessed atomically. The first word in a
variable or in an allocated struct, array, or slice can be relied upon to be
64-bit aligned.</p>
</blockquote>
<p>If the condition isn&#39;t satisfied, it panics at run-time. Only on 32-bit
platforms. I didn&#39;t have to go far to hit this one - I got bit by this bug
multiple times in the last few years.</p>
<p>It&#39;s a footnote. Not a compile-time check. There&#39;s an <a href="https://github.com/golang/go/issues/11891">in-progress
lint</a>, for very simple cases, because
Go&#39;s simplicity made it extremely hard to check for.</p>
<p>This fake &#34;simplicity&#34; runs deep in the Go ecosystem. Rust has the opposite
problem - things look scary at first, but it&#39;s for a good reason. The problems
tackled have inherent complexity, and it takes some effort to model them
appropriately.</p>
<p>At this point in time, I deeply regret investing in Go.</p>
<p>Go is a Bell Labs fantasy, and not a very good one at that.</p>
<h2>April 2022 Update</h2>
<p>I wrote this in 2020, and have changed jobs twice since. Both jobs involved Go
in some capacity, where it&#39;s supposed to shine (web services). It has not been a
pleasant experience either - I&#39;ve lost count of the amount of incidents directly
caused by poor error handling, or Go default values.</p>
<p>If folks walk away with only one new thought from this, please let it be that:
<em>defaults matter</em>. Go lets you whip something up quickly, but making the result
&#34;production-ready&#34; is left as an exercise to the writer. Big companies that have
adopted it have developed tons of tooling around it, use all available linters,
do code generation, check the disassembly, and regularly pay the engineering
cost of just using Go at all.</p>
<p>That&#39;s not how most Go code is written though. I&#39;m interested not in what the
language lets you do, but what is typical for a language - what is idiomatic,
what &#34;everyone ends up doing&#34;, because it is encouraged.</p>
<p>Because that&#39;s the kind of code I inevitably end up being on-call for, and I&#39;m
tired of being woken up due to the same classes of preventable errors, all the
time. It doesn&#39;t matter that I don&#39;t personally write Go anymore: it&#39;s
unescapable. If it&#39;s not internal Go code, it&#39;s in a SAAS we pay for: and no
matter who writes it, it fails in all the same predictable ways.</p>
<p>Generics will not solve this. It is <em>neat</em> that they found a way to sneak them
into the language, but it&#39;s not gonna change years of poor design decisions, and
it&#39;s definitely not gonna change the enormous amount of existing Go code out
there, especially as <a href="https://planetscale.com/blog/generics-can-make-your-go-code-slower">the
discourse</a>
around them not being the usability+performance win everyone thought they would
be keeps unfolding.</p>
<p>As I&#39;ve mentioned <a href="https://twitter.com/fasterthanlime/status/1519455555517136902">recently on
Twitter</a>, what
makes everything worse is that you cannot replace Go piecemeal once it has taken
hold in a codebase: its FFI story is painful, the only good boundary with Go is
a network boundary, and there&#39;s often a latency concern there.</p>
<p>Lastly: pointing out that I have been teaching Rust is a lazy and dismissive
response to this. For me personally, I have found it to be the least awful
option in a bunch of cases. I am yearning for even better languages, ones that
tackle the same kind of issues but do it even better. I like to remind everyone
that we&#39;re not out there cheering for sports team, just discussing our tools.</p>
<p>If you&#39;re looking to reduce the whole discourse to &#34;X vs Y&#34;, let it be
&#34;<a href="https://serde.rs/">serde</a> vs crossing your fingers and hoping user input is
well-formed&#34;. It is one of the better reductions of the problem: it really is
&#34;specifying behavior that should be allowed (and rejecting everything else)&#34; vs
&#34;manually checking that everything is fine in a thousand tiny steps&#34;, which
inevitably results in missed combinations because the human brain is not
designed to hold graphs that big. </p>

</div><div>
  
    
    
  

  

  

  


  







<div>
    <h2>Latest video</h2>









<div>
    
        
        
        
            
        

        

        

        
        
        
        
        
            
        
        
         
        
            
        
        
            
        
        <div>
            <a href="https://www.youtube.com/videos/getting-good-at-snes">
                
                    
                    <div>
                        <picture>
                            <source type="image/avif" srcset="https://tube.fasterthanli.me/covers/joy/cover.avif"/>
                            <source type="image/webp" srcset="https://tube.fasterthanli.me/covers/joy/cover.webp"/>
                            <img alt="video cover image" src="https://tube.fasterthanli.me/covers/joy/cover.jpg"/>
                        </picture>
                    </div>
                

                <span>
                    
                        
                        Getting good at SNES games through DLL injection
                    
                </span>
            </a>
            <div>
                <div>
                    <div>
                        <p>Apr 25, 2022</p>
                        
                            
                                
                                    <p>
                                        19 minute watch
                                    </p>
                                
                            
                        

                        
                            
                            
                        

                        
                        
                        
                            
                        
                        

                        
                        
                    </div>
                </div>

                <div>
                    
                        
                            
                            <p>Are you ever confronted with a problem and then think to yourself &#34;wait a minute,
I know how to code?&#34; — that&#39;s exactly what happened there.</p>
                        
                    
                </div>

                
                    <p><a href="https://www.youtube.com/videos/getting-good-at-snes">
                        <span>
                            
                                Watch now
                            
                        </span>
                    </a>
                
            </p></div>
        </div>
    
</div>


    <p>You can watch more videos <a href="https://www.youtube.com/videos">over there</a></p>
</div> <!-- Latest video -->

  
</div></div>
  </body>
</html>
