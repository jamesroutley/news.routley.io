<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://cyata.ai/blog/langgrinch-langchain-core-cve-2025-68664/">Original</a>
    <h1>Critical vulnerability in LangChain â€“ CVE-2025-68664</h1>
    
    <div id="readability-page-1" class="page"><div><div>
<figure><img decoding="async" width="1500" height="900" src="https://cyata.ai/wp-content/uploads/2025/12/LangGrinch-Article.png" alt="" srcset="https://cyata.ai/wp-content/uploads/2025/12/LangGrinch-Article.png 1500w, https://cyata.ai/wp-content/uploads/2025/12/LangGrinch-Article-300x180.png 300w, https://cyata.ai/wp-content/uploads/2025/12/LangGrinch-Article-1024x614.png 1024w, https://cyata.ai/wp-content/uploads/2025/12/LangGrinch-Article-768x461.png 768w, https://cyata.ai/wp-content/uploads/2025/12/LangGrinch-Article-372x223.png 372w" sizes="(max-width: 1500px) 100vw, 1500px"/><figcaption>Cyata Research: LangGrinch Vulnerability in LangChain</figcaption></figure>



<p>Yesterday, LangChain published a <a href="https://github.com/advisories/GHSA-c67j-w6g6-q2cm">critical advisory</a> for a vulnerability I reported in langchain-core: <strong>CVE-2025-68664 / GHSA-c67j-w6g6-q2cm</strong>.Â </p>



<p>Earlier this year, my research focused on breaking secret managers in our â€œ<a href="https://cyata.ai/vault-fault/">Vault Fault</a>â€ work â€“ systems that are explicitly designed to be the security boundary around your most sensitive credentials. One takeaway kept repeating: when a platform accidentally treats attacker-shaped data as trusted structure, that boundary collapses fast. <strong>This time, the system that â€œbreaksâ€ isnâ€™t your secret manager. Itâ€™s the agent framework that may use them.</strong></p>



<p>Why this vulnerability deserves extra attention:</p>



<ol>
<li><strong>Itâ€™s in Core.</strong> This is not a specific tool bug, not an integration edge-case, and not a â€œsome community package did something weird.â€ The vulnerable APIs (dumps() / dumpd()) live in <strong>langchain-core itself</strong>.</li>



<li><strong>The blast radius is scale.</strong> By download volume, langchain is one of the most widely deployed AI framework components globally today. As of late December 2025, public package telemetry shows <strong>hundreds of millions of installs</strong>, with pepy.tech reporting <strong>~847M total downloads</strong> and pypistats showing <strong>~98M downloads in the last month</strong>.</li>



<li><strong>One prompt can trigger a lot of machinery.</strong> The most common real-world path here is not â€œattacker sends you a serialized blob and you call load().â€ Itâ€™s subtler: LLM outputs can influence fields like additional_kwargs or response_metadata, and those fields can be serialized and later deserialized through normal framework features like streaming logs/events. Plainly, this means <strong>an exploit can be triggered by a single text prompt</strong> that cascades into a surprisingly complex internal pipeline.Â <br/></li>
</ol>



<p>Before you read further, patches are now released in versions 1.2.5 and 0.3.81. If youâ€™re running LangChain in production, this one is trickier than it may seem; please update ASAP.</p>



<h2><strong>The short version of the bug</strong></h2>



<p>LangChain uses a special internal serialization format where dictionaries containing an â€˜lcâ€™ marker represent LangChain objects. The vulnerability was that dumps() and dumpd() <strong>did not properly escape user-controlled dictionaries</strong> that happened to include the reserved â€˜lcâ€™ key.Â </p>



<p>So once an attacker is able to make a LangChain orchestration loop serialize and later deserialize content including an â€˜lcâ€™ key, they would instantiate an unsafe arbitrary object, potentially triggering many attacker-friendly paths.</p>



<p>The <a href="https://github.com/advisories/GHSA-c67j-w6g6-q2cm">advisory</a> lists <strong>12 distinct vulnerable flows</strong>, which are extremely common use cases, such as standard event streaming, logging, message history/memory or caches:</p>



<figure data-wp-context="{&#34;imageId&#34;:&#34;694e5aba1951b&#34;}" data-wp-interactive="core/image"><img loading="lazy" decoding="async" width="1024" height="221" data-wp-class--hide="state.isContentHidden" data-wp-class--show="state.isContentVisible" data-wp-init="callbacks.setButtonStyles" data-wp-on-async--click="actions.showLightbox" data-wp-on-async--load="callbacks.setButtonStyles" data-wp-on-async-window--resize="callbacks.setButtonStyles" src="https://cyata.ai/wp-content/uploads/2025/12/image-16-1024x221.png" alt="" srcset="https://cyata.ai/wp-content/uploads/2025/12/image-16-1024x221.png 1024w, https://cyata.ai/wp-content/uploads/2025/12/image-16-300x65.png 300w, https://cyata.ai/wp-content/uploads/2025/12/image-16-768x166.png 768w, https://cyata.ai/wp-content/uploads/2025/12/image-16-1536x331.png 1536w, https://cyata.ai/wp-content/uploads/2025/12/image-16-2048x441.png 2048w, https://cyata.ai/wp-content/uploads/2025/12/image-16-372x80.png 372w" sizes="auto, (max-width: 1024px) 100vw, 1024px"/></figure>



<p>The most damaging outcomes include:</p>



<ul>
<li><strong>Secret extraction</strong> from environment variables. The advisory notes this happens when deserialization is performed with secrets_from_env=True. Notably, <strong>this was the default until yesterday</strong>. ğŸ™‚Â </li>



<li><strong>Object instantiation</strong> within pre-approved namespaces (including <em>langchain_core</em>, <em>langchain_openai, langchain_aws, langchain_anthropicâ€¦</em>), potentially triggering side effects in constructors (network calls, file operations, etc.).Â </li>



<li>Under certain conditions LangChain object instantiation may lead to arbitrary code execution.</li>
</ul>



<p>This is categorized under <strong>CWE-502: Deserialization of Untrusted Data</strong>, with a CNA CVSS score of <strong>9.3 (Critical)</strong>.Â </p>



<figure data-wp-context="{&#34;imageId&#34;:&#34;694e5aba19e66&#34;}" data-wp-interactive="core/image"><img loading="lazy" decoding="async" width="627" height="344" data-wp-class--hide="state.isContentHidden" data-wp-class--show="state.isContentVisible" data-wp-init="callbacks.setButtonStyles" data-wp-on-async--click="actions.showLightbox" data-wp-on-async--load="callbacks.setButtonStyles" data-wp-on-async-window--resize="callbacks.setButtonStyles" src="https://cyata.ai/wp-content/uploads/2025/12/banner-langgrinch.png" alt="" srcset="https://cyata.ai/wp-content/uploads/2025/12/banner-langgrinch.png 627w, https://cyata.ai/wp-content/uploads/2025/12/banner-langgrinch-300x165.png 300w, https://cyata.ai/wp-content/uploads/2025/12/banner-langgrinch-372x204.png 372w" sizes="auto, (max-width: 627px) 100vw, 627px"/></figure>



<h2><strong>My research story: how I stumbled into it</strong></h2>







<p>Security research often looks dramatic from the outside. In reality, it is usually careful reading, small hypotheses, and a slow accumulation of â€œthatâ€™s oddâ€ moments.</p>



<p>This one started the way many do at Cyata: with a simple question we ask constantly as we assess AI stacks for real-world risk:</p>



<p><em>Where are the trust boundaries in AI applications, and do developers actually know where those boundaries are?</em></p>



<p>LangChain is a powerful framework, and like most modern frameworks it has to move complex structured data around: messages, tool calls, streaming events, traces, caches, and â€œrunnables.â€</p>



<p>Reviewing previous research, there was already extensive research on LangChain tooling and integrations, but very few findings on the core library.</p>



<figure data-wp-context="{&#34;imageId&#34;:&#34;694e5aba1a82e&#34;}" data-wp-interactive="core/image"><img loading="lazy" decoding="async" width="1024" height="342" data-wp-class--hide="state.isContentHidden" data-wp-class--show="state.isContentVisible" data-wp-init="callbacks.setButtonStyles" data-wp-on-async--click="actions.showLightbox" data-wp-on-async--load="callbacks.setButtonStyles" data-wp-on-async-window--resize="callbacks.setButtonStyles" src="https://cyata.ai/wp-content/uploads/2025/12/image-2-1024x342.png" alt="" srcset="https://cyata.ai/wp-content/uploads/2025/12/image-2-1024x342.png 1024w, https://cyata.ai/wp-content/uploads/2025/12/image-2-300x100.png 300w, https://cyata.ai/wp-content/uploads/2025/12/image-2-768x256.png 768w, https://cyata.ai/wp-content/uploads/2025/12/image-2-372x124.png 372w, https://cyata.ai/wp-content/uploads/2025/12/image-2.png 1177w" sizes="auto, (max-width: 1024px) 100vw, 1024px"/></figure>







<p>From there, the investigation became a structured exercise:</p>



<ol>
<li>Identify where <strong>untrusted content</strong> (mostly arbitrary dictionaries) gets serialized (LLM outputs, prompt injection, user input, external tools, retrieved docs).</li>



<li>Identify when that serialized data gets deserialized.</li>



<li>Identify what an attacker can achieve from arbitrary object instantiation.</li>
</ol>



<p>At that point, the core finding was clear and actionable enough to responsibly report: there was an escaping gap in dumps() / dumpd() around â€˜lcâ€™ key dictionaries.Â </p>



<p>The advisory later captured what we often see in practice: fields like additional_kwargs and response_metadata can be influenced by LLM output and prompt injection, and those fields can get serialized-deserialized in many flows.Â </p>



<p>To the LangChain teamâ€™s credit: the response and follow-through were decisive, not just patching the bug but also hardening defaults that were too permissive for the world weâ€™re in now.Â </p>



<p>The LangChain project decided to award a $4,000 USD bounty for this finding. According to huntr, the platform where LangChain operated its bounty program, this would be the maximum amount ever awarded in the project, with bounties so far awarded up to $125.</p>



<h2><strong>Technical deep dive</strong></h2>



<h3><strong>Background: the â€œlcâ€ marker and why it exists</strong></h3>



<p>LangChain serializes certain objects using a structured dict format. The â€˜lcâ€™ key is used internally to indicate â€œthis is a LangChain-serialized structure,â€ not just arbitrary user data.Â </p>



<p>This is a common pattern, but it creates a security invariant: Any user-controlled data that could contain â€˜lcâ€™ must be treated carefully. Otherwise, an attacker can craft a dict that â€œlooks likeâ€ an internal object and trick the deserializer into giving it meaning.</p>



<p>The patch makes the intent explicit in the updated documentation: during serialization, <strong>plain dicts that contain an â€˜lcâ€™ key are escaped</strong> by wrapping them.Â </p>



<p>This prevents those dicts from being confused with actual LangChain serialized objects during deserialization.Â </p>



<h3><strong>The allowlist: what can be instantiated</strong></h3>



<p>LangChainâ€™s load()/loads() functions donâ€™t instantiate arbitrary classes â€“ they check against an allowlist that controls which classes can be deserialized. By default, this allowlist includes classes from langchain_core, langchain_openai, langchain_aws, and other ecosystem packages.</p>



<p>Hereâ€™s the catch: most classes on the allowlist have harmless constructors. Finding exploitable paths required digging through the ecosystem for classes that do something meaningful on instantiation. The ones I found are detailed below, but there may be others waiting to be discovered.</p>



<h3><strong>The exfiltration path</strong></h3>



<p>LangChainâ€™s loads() function supports a <em>secret</em> type that resolves values from environment variables during deserialization. Before the patch, this feature <em>secrets_from_env</em> was enabled by default:</p>



<pre><code>if (
Â Â Â Â value.get(&#34;lc&#34;) == 1
Â Â Â Â and value.get(&#34;type&#34;) == &#34;secret&#34;
Â Â Â Â and value.get(&#34;id&#34;) is not None
):
Â Â Â Â [key] = value[&#34;id&#34;]
Â Â Â Â if key in self.secrets_map:
Â Â Â Â Â Â Â Â return self.secrets_map[key]
Â Â Â Â if self.secrets_from_env and key in os.environ and os.environ[key]:
Â Â Â Â Â Â Â  return os.environ[key] # <strong>&lt;-- Returning env variable</strong>
Â    return None</code></pre>



<p>If a deserialized object is returned to an attacker, for example message history inside the LLM context, that could leak environment variables.</p>



<figure><img loading="lazy" decoding="async" width="720" height="403" src="https://cyata.ai/wp-content/uploads/2025/12/image-1.png" alt="" srcset="https://cyata.ai/wp-content/uploads/2025/12/image-1.png 720w, https://cyata.ai/wp-content/uploads/2025/12/image-1-300x168.png 300w, https://cyata.ai/wp-content/uploads/2025/12/image-1-372x208.png 372w" sizes="auto, (max-width: 720px) 100vw, 720px"/></figure>



<p>This validator runs when <em>ChatBedrockConverse</em> is instantiated. The attacker controls <em>endpoint_url</em>, triggering an outbound request. Combined with <em>secrets_from_env</em>, the <em>aws_access_key_id</em> header can be populated with any environment variable â€“ not just AWS keys.</p>



<p>We are intentionally not publishing a copy-paste exploit here, to give time for security teams. In a few months, the Huntr website will publish them automatically.</p>



<h3><strong>Code Execution via jinja2 templates</strong></h3>



<p>Among the classes in the default <em>loads()</em> allowlist is <em>PromptTemplate</em>. This class creates a prompt from a template, and one of the available template formats is Jinja2.</p>



<p>When a template is rendered with Jinja2, arbitrary Python code can run. We did not find a way to trigger this directly from the <em>loads()</em> function alone, but if a subsequent call to the deserialized object triggers rendering, code execution follows.</p>



<p>We suspect there may be paths to direct code execution from <em>loads()</em>, but we have not confirmed one yet. If you have a solid idea or a lead worth testing, weâ€™d love to hear from you â€“ this is exactly where the security community helps turn hypotheses into proof. ğŸ¤</p>



<p>Also worth noting: in past versions, the Chain class was also in the allowlist. That class has special features that might have enabled a flow to template rendering.</p>



<h2><strong>Who is affected? The practical checklist</strong></h2>



<p>Your application is potentially exposed if it uses vulnerable langchain-core versions. Here are some of the most common vulnerable patterns (12 flows have been identified in total):</p>



<ul>
<li>astream_events(version=â€v1â€³) (v1 uses the vulnerable serialization; v2 is not vulnerable)</li>



<li>Runnable.astream_log()</li>



<li>dumps() / dumpd() on untrusted data, followed by load() / loads()</li>



<li>Deserializing untrusted data with load() / loads()</li>



<li>Internal serialization flows like RunnableWithMessageHistory, InMemoryVectorStore.load(), certain caches, pulling manifests from LangChain Hub (hub.pull), and other listed components in the advisory</li>
</ul>



<p>That said, the systemâ€™s behavior is complex enough that itâ€™s risky to assume a quick code-path review will catch every reachable variant. <strong>The safer course is to upgrade to a patched version </strong>and not assume youâ€™re in the clear until you do.</p>



<p>Also, the advisory calls out what I consider the most important real-world point:</p>



<p>The most common attack vector is through LLM response fields like additional_kwargs or response_metadata, which can be controlled via prompt injection and then serialized/deserialized in streaming operations.Â </p>



<p>This is exactly the kind of â€œAI meets classic securityâ€ intersection where organizations get caught off guard. LLM output is an untrusted input. If your framework treats portions of that output as structured objects later, you must assume attackers will try to shape it.</p>



<h2><strong>Defensive guidance: how to respond in production</strong></h2>



<h3><strong>1) Patch first (this is the fastest risk reduction)</strong></h3>



<p>Upgrade langchain-core to a patched version. If you are using langchain, langchain-community, or other ecosystem packages, validate what version of langchain-core is actually installed in production environments.</p>



<h3><strong>2) Assume LLM outputs can be attacker-shaped</strong></h3>



<p>Treat additional_kwargs, response_metadata, tool outputs, retrieved documents, and message history as untrusted unless proven otherwise. This is especially important if you stream logs/events and later rehydrate them with a loader.</p>



<h3><strong>3) Review deserialization features like secret resolution</strong></h3>



<p>Even after upgrading, keep the principle: do not enable secret resolution from environment variables unless you trust the serialized input. The project changed defaults for a reason.Â </p>



<h2><strong>The LangChainJS parallel</strong></h2>



<p>Based on my report, there is a closely related advisory in LangChainJS (GHSA-r399-636x-v7f6 / CVE-2025-68665) with similar mechanics: â€˜lcâ€™ marker confusion during serialization, enabling secret extraction and unsafe instantiation in certain configurations.Â </p>



<p>If your organization runs both Python and JavaScript LangChain stacks, treat this as a reminder that <strong>the pattern travels across ecosystems</strong>: marker-based serialization, untrusted model output, and later deserialization is a recurring risk shape.</p>



<h2><strong>Why this matters beyond LangChain</strong></h2>



<p>We are entering a phase where agentic AI frameworks are becoming critical infrastructure inside production systems. Serialization formats, orchestration pipelines, tool execution, caches, and tracing are no longer â€œplumbingâ€ â€“ they are part of your security boundary.</p>



<p>This vulnerability is not â€œjust a bug in a library.â€ It is a case study in a bigger pattern:</p>



<ul>
<li>Your application might deserialize data it believes it produced safely.</li>



<li>But that serialized output can contain fields influenced by untrusted sources (including LLM outputs shaped by prompt injection).</li>



<li>A single reserved key used as an internal marker can become a pivot point into secrets and execution-adjacent behaviors.</li>
</ul>



<p>At Cyata, our work is to help organizations build <strong>visibility, risk assessment, control, and governance</strong> around AI systems â€“ because if you canâ€™t quickly answer <em>where agents are running, which versions are deployed, and what data flows through it</em>, youâ€™re effectively flying blind when advisories like this land.</p>



<h2><strong>What this teaches us about AI governance</strong></h2>



<p>If you are a security leader reading this, here is the uncomfortable truth:</p>



<p>Most organizations cannot currently answer, quickly and confidently:</p>



<ul>
<li>Where are we using agents?</li>



<li>Which versions are deployed in production?</li>



<li>Which services have access to sensitive secrets?</li>



<li>Where do LLM outputs cross those boundaries?</li>
</ul>



<p>That is not a â€œdeveloper problem.â€ It is a visibility and governance problem.</p>



<p>And that is where Cyata comes in.</p>



<h2><strong>How Cyata helps: visibility, risk assessment, control, governance</strong></h2>



<p>At Cyata, we focus on a practical outcome: reducing AI and agent risk without slowing down builders. Vulnerabilities like this one are rarely â€œjust a patch.â€ They expose gaps in how teams discover where agents run, understand real trust boundaries, and enforce safer defaults across fast-moving frameworks.</p>



<h3><strong>Visibility</strong></h3>



<p>Know what is running, where, and how it is wired.</p>



<p>Answer the first CVE question quickly: <strong>are we exposed, and in which flows?</strong></p>



<p>Discover agent runtimes and integrations across environments (IDEs, CI, services, worker jobs, hosted agents).</p>



<p>Track frameworks, packages, and versions in use.</p>



<h3><strong>Risk assessment</strong></h3>



<p>Prioritize what matters based on real-world blast radius, not just â€œlibrary present.â€</p>



<p>Support faster triage: what is internet-facing, what touches secrets, what runs with elevated credentials.</p>



<p>Identify the highest-risk paths: untrusted content flowing into privileged contexts (services with secrets, broad tool permissions, prod network access).</p>



<p>Highlight where â€œstructured fieldsâ€ can cross trust boundaries (metadata, tool outputs, streamed events, cached artifacts).</p>



<h3><strong>Control</strong></h3>



<p>Reduce exposure even before every dependency is patched everywhere.</p>



<p>Encourage safer operational defaults: least privilege, isolation boundaries, and policy checks that scale across teams.</p>



<p>Enforce guardrails around risky patterns (for example: deserializing untrusted data, permissive object revival, unsafe streaming-to-cache-to-rehydrate flows).</p>



<p>Gate or restrict sensitive capabilities in untrusted contexts (for example: secret access via environment, high-privilege tool execution, or running risky code paths in privileged workers).</p>



<h3><strong>Governance</strong></h3>



<p>Make â€œsafe agent usageâ€ repeatable, auditable, and hard to drift.</p>



<ul>
<li>Define policies for <strong>approved frameworks, versions, and configurations</strong>.</li>



<li>Track and time-box exceptions with owners and rationale.</li>



<li>Monitor for drift and risky feature usage over time, with an audit trail that supports security reviews and compliance.</li>
</ul>



<p>When a Christmas-week advisory drops, the goal is not heroics â€“ itâ€™s calm, controlled response backed by real inventory and enforced guardrails.</p>



<h2><strong>Disclosure Timeline</strong></h2>



<p>Report submitted via Huntr â€“ December 4th, 2025</p>



<p>Acknowledged by LangChain maintainers â€“ December 5th, 2025Â </p>



<p>Advisory and CVE published â€“ December 24th, 2025</p>


<section>
	<div>
		<p>The Control Plane â€¨for Agentic Identity</p>
					
			</div>
</section>




</div></div></div>
  </body>
</html>
