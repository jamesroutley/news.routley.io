<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jepsen.io/analyses/amazon-rds-for-postgresql-17.4">Original</a>
    <h1>Jepsen: Amazon RDS for PostgreSQL 17.4</h1>
    
    <div id="readability-page-1" class="page"><p><a href="https://aws.amazon.com/rds/postgresql/">Amazon RDS for PostgreSQL</a> is an Amazon Web Services (AWS) service which provides managed instances of the <a href="https://www.postgresql.org/">PostgreSQL</a> database. We show that Amazon RDS for PostgreSQL multi-AZ clusters violate <a href="https://jepsen.io/consistency/models/snapshot-isolation">Snapshot Isolation</a>, the strongest consistency model supported across all endpoints. Healthy clusters occasionally allow <a href="https://jepsen.io/consistency/phenomena/long-fork">Long Fork</a> and other <a href="https://jepsen.io/consistency/phenomena/g-nonadjacent">G-nonadjacent</a> cycles. These phenomena occurred in every version tested, from 13.15 to 17.4. Amazon RDS for PostgreSQL may instead provide <a href="https://scispace.com/pdf/transactional-storage-for-geo-replicated-systems-2j5mhrj29h.pdf">Parallel Snapshot Isolation</a>. This work was performed independently by Jepsen, without compensation, and conducted in accordance with the <a href="https://jepsen.io/analyses/ethics">Jepsen ethics policy</a>.</p><article>
  <div>

<p><a href="https://www.postgresql.org/">PostgreSQL</a> is a popular open source general-purpose SQL database. It uses multiversion concurrency control (MVCC) to provide <a href="https://www.postgresql.org/docs/17/transaction-iso.html">three levels of transaction isolation</a>. PostgreSQL’s “Read Uncommitted” and “Read Committed” are both <a href="https://jepsen.io/consistency/models/read-committed">Read Committed</a>. The “Repeatable Read” level actually provides <a href="https://jepsen.io/consistency/models/snapshot-isolation">Snapshot Isolation</a>, not <a href="https://jepsen.io/consistency/models/repeatable-read">Repeatable Read</a>. “Serializable” provides <a href="https://jepsen.io/consistency/models/serializable">Serializability</a>.</p>
<p><a href="https://aws.amazon.com/rds/postgresql/">Amazon RDS for PostgreSQL</a> is an AWS service which provides managed PostgreSQL clusters. RDS automates provisioning, storage management, replication, backups, upgrades, and more. <a href="https://aws.amazon.com/rds/features/multi-az/">Multi-AZ deployments</a> distribute database nodes across multiple availability zones, reducing the probability of correlated failure. RDS uses synchronous replication to ensure that transactions are durable both on primary and (at least one) secondary instances before acknowledging.</p>
<p>From a user perspective, Amazon RDS for PostgreSQL provides a pair of URLs which speak the PostgreSQL wire protocol: a primary endpoint for read-write transactions, and a reader endpoint for read-only transactions. The primary endpoint supports all PostgreSQL isolation levels, while secondaries do not support Serializable. The strongest level supported across all nodes is therefore Snapshot Isolation (which PostgreSQL terms “Repeatable Read”).</p>

<p>We adapted Jepsen’s <a href="https://github.com/jepsen-io/postgres/tree/225203dd64ad5e5e4fe481ccb8b180b7d0d99f9d/postgres">test library for PostgreSQL</a> for use with Amazon RDS for PostgreSQL with a <a href="https://github.com/jepsen-io/postgres/tree/225203dd64ad5e5e4fe481ccb8b180b7d0d99f9d/rds">small wrapper program</a>. For each round of tests, we <a href="https://github.com/jepsen-io/rds/blob/13cada8381b7cde00bca3adfb005a66613656039/src/jepsen/rds.clj#L284-L377">provisioned an RDS cluster</a> using AWS’s <a href="https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_CreateDBCluster.html"><code>CreateDBCluster</code></a> API, using <code>gp3</code> storage and <code>db.m6id.large</code> instances. We then launched a single EC2 node to run our tests, and provided it with the main and read-only endpoints of the RDS cluster. We performed no fault injection, and triggered no failovers.</p>
<p>As in <a href="https://jepsen.io/analyses/postgresql-12.3#test-design">our previous work on PostgreSQL</a>, our <a href="https://github.com/jepsen-io/postgres/blob/225203dd64ad5e5e4fe481ccb8b180b7d0d99f9d/postgres/src/jepsen/postgres/workload/append.clj">primary workload</a> consisted of transactions over lists of unique integers. We stored each list in a single row, encoded as a <code>TEXT</code> field of comma-separated values. Transactions could either read a list by primary key, or append a unique integer to a list using <code>CONCAT</code>. This workload allowed our <a href="https://github.com/jepsen-io/elle">Elle checker</a> to verify a variety of isolation levels, mainly by inferring dataflow dependencies between transactions and finding cycles in the resulting graph.</p>

<p>Under healthy conditions, with moderate concurrency, Amazon RDS for PostgreSQL 17.4 exhibited <a href="https://jepsen.io/consistency/phenomena/g-nonadjacent">G-nonadjacent</a> cycles every few minutes. Consider <a href="https://s3.amazonaws.com/jepsen.io/analyses/amazon-rds-for-postgresql-17.4/20250406T172435-long-fork.zip">this two-minute test run</a>, which performed approximately 150 write transactions per second, along with 1600 read-only transactions per second. It contains the following cycle of four transactions:</p>

<p>From top to bottom, call these transactions <span><em>T</em><sub>1</sub></span>, <span><em>T</em><sub>2</sub></span>, <span><em>T</em><sub>3</sub></span>, and <span><em>T</em><sub>4</sub></span>. <span><em>T</em><sub>1</sub></span> appended 9 to row 89, resulting in the list <code>[4 9]</code>, which <span><em>T</em><sub>2</sub></span> observed. <span><em>T</em><sub>3</sub></span> appended 11 to row 90, resulting in the list <code>[11]</code>. That version was overwritten by <span><em>T</em><sub>4</sub></span>, which appended <code>3</code> to row <code>90</code>, and read the resulting list <code>[11, 3]</code>. While <span><em>T</em><sub>2</sub></span> observed <span><em>T</em><sub>1</sub></span>’s append to row 89, it failed to observe <span><em>T</em><sub>3</sub></span>’s append to row 90. Symmetrically, <span><em>T</em><sub>4</sub></span> observed <span><em>T</em><sub>3</sub></span>’s append to row 90, but failed to observe <span><em>T</em><sub>1</sub></span>’s append to 89.</p>
<p>Since this cycle includes <a href="https://jepsen.io/consistency/dependencies">read-write dependencies</a> which are not adjacent to each other, this cycle is G-nonadjacent, a violation of Snapshot Isolation. This behavior should not occur in standard PostgreSQL at “Repeatable Read” and we have not observed it there.</p>
<p>To understand why this cycle is illegal, recall that in <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-95-51.pdf">Snapshot Isolation</a>, every transaction (apparently) operates on a snapshot of the database taken at some start timestamp <span><em>s</em></span>. That transaction’s effects are made visible to others at some later commit timestamp <span><em>c</em></span>. In order for <span><em>T</em><sub>2</sub></span> to read <span><em>T</em><sub>1</sub></span>’s append, its start timestamp must have followed <span><em>T</em><sub>1</sub></span>’s commit timestamp: <span><em>c</em><sub>1</sub> &lt; <em>s</em><sub>2</sub></span>. Since <span><em>T</em><sub>2</sub></span> did not observe <span><em>T</em><sub>3</sub></span>’s append, <span><em>s</em><sub>2</sub></span> &lt; <span><em>c</em><sub>3</sub></span>. Since <span><em>T</em><sub>4</sub></span> overwrote (and observed) <span><em>T</em><sub>3</sub></span>, <span><em>c</em><sub>3</sub> &lt; <em>s</em><sub>4</sub></span>. But <span><em>T</em><sub>4</sub></span> did not observe <span><em>T</em><sub>1</sub></span>’s append, so <span><em>s</em><sub>4</sub></span> &lt; <span><em>c</em><sub>1</sub></span>. We have a contradiction! There is no way these timestamps can each precede each other.</p>
<p>This cycle is also an example of <a href="https://jepsen.io/consistency/phenomena/long-fork">Long Fork</a>. The first and second transactions compose one logical fork of the state. The third and fourth comprise a second. Each fork updates a different row, but neither fork observes the other’s effects. Curiously, we did <em>not</em> observe <a href="https://jepsen.io/consistency/phenomena/a5b">Short Fork</a>, also known as Write Skew. This suggests that Amazon RDS for PostgreSQL might provide <a href="https://www.cs.princeton.edu/courses/archive/fall13/cos518/papers/walter.pdf">Parallel Snapshot Isolation</a>, a slightly weaker consistency model.</p>
<p>We observed a variety of G-nonadjacent anomalies, including those linked only by write-read edges, as well as several with more than four transactions. They occurred in every PostgreSQL version we tested, from 13.15 (the oldest version which AWS supported) to 17.4 (the newest).</p>

<p>From the presence of Long Fork and other G-nonadjacent cycles, we conclude that Amazon RDS for PostgreSQL multi-AZ clusters do not ensure Snapshot Isolation. Instead, they may provide Parallel Snapshot Isolation, a slightly weaker model. In this respect Amazon RDS for PostgreSQL multi-AZ clusters offer weaker safety semantics than a single-node PostgreSQL system, which, <a href="https://jepsen.io/analyses/postgresql-12.3">in our previous testing</a>, appeared to provide Strong Snapshot Isolation.</p>
<p>Users of Amazon RDS for PostgreSQL may wish to examine their transaction structures with an eye towards Long Fork, or design experiments to verify whether their intended invariants are preserved. A read transactions may disagree with other transactions as to the order in which transactions were executed. Since these anomalies appear to involve queries against read-only secondaries, it may be possible to recover Snapshot Isolation by only using the writer endpoint, or ensuring that every safety-critical transaction includes at least one write.</p>
<p>This report is the product of a cursory exploration—we have not investigated Amazon RDS for PostgreSQL behavior in detail. As always, Jepsen takes an experimental approach to safety verification: we can prove the presence of bugs, but not their absence. While we make extensive efforts to find problems, we cannot prove correctness.</p>
<p><em>Our thanks to <a href="https://www.irenekannyo.com/">Irene Kannyo</a> for her editorial support. This work was performed independently by Jepsen, without compensation, and conducted in accordance with the <a href="https://jepsen.io/analyses/ethics">Jepsen ethics policy</a>.</em></p>
  </div>
</article></div>
  </body>
</html>
