<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.rustprooflabs.com/2022/07/postgres-15-unique-improvement-with-null">Original</a>
    <h1>Postgres 15 improves UNIQUE and NULL</h1>
    
    <div id="readability-page-1" class="page"><div>
                    <p>By Ryan Lambert -- Published July 11, 2022</p><p>Postgres 15 beta 2 <a href="https://www.postgresql.org/about/news/postgresql-15-beta-2-released-2479/">was released</a>
recently! I enjoy Beta season... reviewing and testing new features
is a fun diversion from daily tasks. This post takes a look at an improvement
to <code>UNIQUE</code> constraints on columns with <a href="https://en.wikipedia.org/wiki/Null_%28SQL%29"><code>NULL</code> values</a>. While the nuances of unique constraints are not as flashy
as <a href="https://www.citusdata.com/blog/2022/05/19/speeding-up-sort-performance-in-postgres-15/">making sorts faster</a> (that&#39;s exciting!),
improving the database developer&#39;s control over data quality is always a good benefit.</p>
<p>This <a href="https://www.postgresql.org/message-id/flat/84e5ee1b-387e-9a54-c326-9082674bde78%40enterprisedb.com">email chain</a>
has the history behind this change.  The
<a href="https://www.postgresql.org/docs/15/release-15.html">Postgres 15 release notes</a>
summarize this improvement:</p>
<blockquote>
<p>&#34;Allow unique constraints and indexes to treat NULL values as not distinct (Peter Eisentraut)</p>
<p>Previously <code>NULL</code> values were always indexed as distinct values, but this can now be changed by creating constraints and indexes using <code>UNIQUE NULLS NOT DISTINCT</code>.&#34;</p>
</blockquote>
<h2>Two styles of <code>UNIQUE</code></h2>
<p>To take a look at what this change does, we create two tables.
The <code>null_old_style</code> table has a 2-column <code>UNIQUE</code> constraint
on <code>(val1, val2)</code>.  The <code>val2</code> allows <code>NULL</code> values.</p>
<pre><code>CREATE TABLE null_old_style
(
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    val1 TEXT NOT NULL,
    val2 TEXT NULL,
    CONSTRAINT uq_val1_val2
        UNIQUE (val1, val2)
);
</code></pre>
<!--endteaser-->

<p>The <code>null_new_style</code> table uses the new option: <code>UNIQUE NULLS NOT DISTINCT</code>.
The only difference from the previous table is the addition of the
new syntax for the unique constraint.</p>
<pre><code>CREATE TABLE null_new_style
(
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    val1 TEXT NOT NULL,
    val2 TEXT NULL,
    CONSTRAINT uq_val1_val2_new
        UNIQUE NULLS NOT DISTINCT (val1, val2)
);
</code></pre>
<h2>Change in allowed data</h2>
<p>In Postgres 14 and prior, unique constraints treated <code>NULL</code> values as
not equal to other <code>NULL</code> values. From the 
<a href="https://www.postgresql.org/docs/14/indexes-unique.html">Postgres 14 docs</a>:</p>
<blockquote>
<p>When an index is declared unique, multiple table rows with equal indexed values are not allowed. <strong>Null values are not considered equal.</strong></p>
</blockquote>
<p>This is consistent with the SQL Standard handling of <code>NULL</code> in general,
where <code>NULL</code> is unknown. It is impossible to determine if one unknown is
equal to another unknown.  Because <code>NULL</code> values are of unknown equality
to one another, they do not violate <code>UNIQUE</code> constraints.
This is illustrated by adding 5 identical rows to the <code>null_old_style</code> table.</p>
<pre><code>INSERT INTO null_old_style (val1, val2)
SELECT &#39;Hello&#39;, NULL
    FROM generate_series(1, 5)
;

SELECT * FROM null_old_style;

id|val1 |val2|
--+-----+----+
 1|Hello|    |
 2|Hello|    |
 3|Hello|    |
 4|Hello|    |
 5|Hello|    |
</code></pre>
<p>This behavior is documented and expected, and is even part of the
ANSI SQL Standard. That said, I never really liked the above behavior because
it is not restrictive enough.</p>
<p>With the new <code>NULLS NOT DISTINCT</code> option, the unique constraint
is more restrictive by not allowing repeated <code>NULL</code> values.
Add one row to start.</p>
<pre><code>INSERT INTO null_new_style (val1, val2)
SELECT &#39;Hello&#39;, NULL;

SELECT * FROM null_new_style;

id|val1 |val2|
--+-----+----+
 1|Hello|    |
</code></pre>
<p>Attempting to add a second row with <code>&#39;Hello&#39;</code> in <code>val1</code> and <code>NULL</code> in <code>val2</code>
now results in a violation of the unique constraint.</p>
<pre><code>INSERT INTO null_new_style (val1, val2)
SELECT &#39;Hello&#39;, NULL;

SQL Error [23505]: ERROR: duplicate key value violates unique constraint &#34;uq_val1_val2_new&#34;
  Detail: Key (val1, val2)=(Hello, null) already exists.
</code></pre>
<p>Of course, a changing the value in <code>val1</code> to a new value will allow
another <code>NULL</code> to be added in <code>val2</code>.</p>
<pre><code>INSERT INTO null_new_style (val1, val2)
SELECT &#39;World&#39;, NULL;

id|val1 |val2|
--+-----+----+
 1|Hello|    |
 3|World|    |
</code></pre>
<p>This fits with my mental model of how I think unique constraints should work
with null values.</p>
<h2>Summary</h2>
<p>I am happy to see the addition of <code>UNIQUE NULLS NOT DISTINCT</code> coming
in Postgres 15. This adds an additional level of quality control to
Postgres. It&#39;s also a low-impact change as the default operation
will continue as it has been.</p>
<p>Need help with your PostgreSQL servers or databases?
<a href="https://www.rustprooflabs.com/contact">Contact us</a>
to start the conversation!</p>
                </div></div>
  </body>
</html>
