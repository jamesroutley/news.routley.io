<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://aaadaaam.com/notes/no-class/">Original</a>
    <h1>This Website Has No Class</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
  <article animate-children="">
    <time><span>Sep 14, 2025</span></time>
    
    <p>In my recent post, <a href="https://aaadaaam.com/notes/useful-defaults/">“There’s no such thing as a CSS reset”</a>, I wrote this:</p>
<blockquote>
<p>Think of elements like components, but ones that come packed in the browser. Custom elements, without the “custom” part. You can just like, <em>use them</em>.</p>
</blockquote>
<p>The line continued to rattle around in my head, and a few weeks later when I was digging into some cleanup work I came to an uncomfortable realization; <em>I wasn’t really taking my own advice</em>. Sure, I was setting some default element styles, but I was leaving <em>a lot</em> on the table. I felt attacked. Called out even. Present me, <em>positively roasted</em> by past me. There was only one possible solution; <strong>refactor my website.</strong></p>
<p>I like to apply severe constraints in designing and building this site – I think constraints lead to interesting, creative solutions – and it was no different this time around. Instead of relying on built in elements <em>a bit more</em>, I decided to <em>banish classes from my website completely</em>. I haven’t used a class-free approach since the CSS Zen Garden days, and wanted to se how it felt with modern HTML and CSS.</p>
<h2 id="doubling-down-on-styled-defaults">Doubling down on styled defaults</h2>
<p>CSS for the site was structured around 3 cascade layers; <code>base</code>, <code>components</code>, and <code>utilities</code>. Everything in <code>base</code> was already tag selectors, so the task at hand was to change my approach for components, and eliminate utilities completely.</p>
<p>Step 1? <em>Mitigation.</em> There was plenty of code that could have been styled defaults but wasn’t, so I gave all my markup a thorough review, increasing use of semantic elements, extracting common patterns in the form of new element defaults, and making more use of contextual element styling. By contextual styling, I mean going from something like this:</p>
<pre><code><span>.header-primary</span> <span>{</span>
  <span>margin-block</span><span>:</span> <span>clamp</span><span>(</span><span>var</span><span>(</span>--size-sm<span>)</span><span>,</span> 4vw<span>,</span> <span>var</span><span>(</span>--size-lg<span>)</span><span>)</span> <span>var</span><span>(</span>--size-flex<span>)</span><span>;</span>
<span>}</span></code></pre>
<p>To something like this:</p>
<pre><code><span>body</span> <span>{</span>
  <span>background-color</span><span>:</span> <span>var</span><span>(</span>--color-sheet<span>)</span><span>;</span>

  <span>&amp; &gt; header</span> <span>{</span>
    <span>margin-block</span><span>:</span> <span>clamp</span><span>(</span><span>var</span><span>(</span>--size-sm<span>)</span><span>,</span> 4vw<span>,</span> <span>var</span><span>(</span>--size-lg<span>)</span><span>)</span> <span>var</span><span>(</span>--size-flex<span>)</span><span>;</span>
  <span>}</span>
<span>}</span></code></pre>
<p>It was a good start, and modern features like nesting, <code>:where()</code>, and <code>:has()</code> made this feel better that it did 20 years ago, but I took things way too far with contextual styles. Taken to the extreme, you end up with overloaded selector definitions and progressively more esoteric selector patterns. I knew I was down the rabbit hole when I did something like this:</p>
<pre><code><span>li</span> <span>{</span>
  <span>&amp;:has( &gt; a + p)</span> <span>{</span>
    <span>padding-block</span><span>:</span> <span>var</span><span>(</span>--size-lg<span>)</span><span>;</span>
    <span>border-block-end</span><span>:</span> <span>var</span><span>(</span>--border-default<span>)</span><span>;</span>
    <span>text-wrap</span><span>:</span> balance<span>;</span>

    <span>&amp; &gt; a</span> <span>{</span>
      <span>font-size</span><span>:</span> <span>var</span><span>(</span>--font-xxl<span>)</span><span>;</span>
    <span>}</span>

    <span>&amp; &gt; p</span> <span>{</span>
      <span>margin-block</span><span>:</span> <span>var</span><span>(</span>--size-sm<span>)</span><span>;</span>
    <span>}</span>
  <span>}</span>
<span>}</span></code></pre>
<p>I still needed a “real” solution for components, and a way to manage variants.</p>

<p>I had an inkling of a solution, which is to leverage patterns from custom elements and web components, sans js. By virtue of their progressively enhanced nature, custom tag names and custom attributes are 100% valid HTML, javascript or no. That inkling turned into fervent belief after reading Keith Cirkel’s excellent post <a href="https://www.keithcirkel.co.uk/css-classes-considered-harmful/">“CSS classes considered harmful”</a>.</p>
<p>Revisiting the example above, now we’ve got a pattern like this:</p>
<pre><code><span>note-pad</span> <span>{</span>
  <span>padding-block</span><span>:</span> <span>var</span><span>(</span>--size-lg<span>)</span><span>;</span>
  <span>border-block-end</span><span>:</span> <span>var</span><span>(</span>--border-default<span>)</span><span>;</span>
  <span>text-wrap</span><span>:</span> balance<span>;</span>

  <span>&amp; a</span> <span>{</span>
    <span>font-size</span><span>:</span> <span>var</span><span>(</span>--font-xxl<span>)</span><span>;</span>
  <span>}</span>

  <span>&amp; p</span> <span>{</span>
    <span>margin-block</span><span>:</span> <span>var</span><span>(</span>--size-sm<span>)</span><span>;</span>
  <span>}</span>
<span>}</span></code></pre>
<p>Custom attributes become a go-to for handling former BEM modifiers, but instead of relying on stylistic writing convention to fake a key-value pair, you get an <em>actual</em> key-value pair.</p>
<pre><code><span>random-pattern</span> <span>{</span>
  <span>&amp; [shape-type=&#34;1&#34;]</span> <span>{</span>
    <span>border</span><span>:</span> 0.1rem solid <span>var</span><span>(</span>--color-sheet<span>)</span><span>;</span>
    <span>background-color</span><span>:</span> <span>var</span><span>(</span>--color-sheet<span>)</span><span>;</span>
    <span>filter</span><span>:</span> <span><span>url</span><span>(</span><span>&#34;#noise1&#34;</span><span>)</span></span><span>;</span>
  <span>}</span>

  <span>&amp; [shape-type=&#34;2&#34;]</span> <span>{</span>
    <span>background</span><span>:</span> <span>var</span><span>(</span>--pattern-lines-horizontal<span>)</span><span>;</span>
    <span>background-size</span><span>:</span> <span>var</span><span>(</span>--pattern-scale<span>)</span><span>;</span>
  <span>}</span>
<span>}</span></code></pre>
<p>Now, you can use <code>data-whatever</code> for attributes, but really, any two dash-separated words are safe. Personally, I think dropping the <code>data</code> prefix feels better and allows for richer semantics.</p>
<p>You can argue that both of these techniques are re-inventing classes in various ways. Kind of! You can use custom element names in lieu of semantic tags, just like you can slap a class on a div. But these techniques, particularly with how you can seamlessly enhance to true custom elements or web components, feels like a coherent end-to-end system in a way that class-based approaches don’t. <em>It’s tags and attributes, all the way down.</em></p>
<h2 id="would-i-do-this-again">Would I do this again?</h2>
<p>On the plus side, the user outcomes are decidedly positive; I removed a non-trivial amount of CSS (now about ~5KB of CSS over the wire for the entire site), and accessibility is without question better due to having to paid much closer attention to markup. Also, <em>just look</em> at that markup. So clean. So shiny.</p>
<p>On the flipside, this feels like an approach that <em>simply asks more of authors</em>. It requires more careful planning compared to pure component approaches; you can’t think of things in purely isolated terms. All to say, I’m very happy to ship this on my personal website, I’d be less likely to advocate for this approach on a large project with varied levels of frontend knowledge.</p>
<p>There’s a variation here that’s more encapsulated (use custom tag names with abandon), but that pulls on what feels like an unresolved thread; replacing a semantic element with a custom tag name that has no semantic value <em>feels bad</em>, and adding extra wrappers around everything <em>also feels bad</em>.</p>
<p>All to say, I’m not quite ready to say that this is The One True Way I’ll build all sites from now on, but I also can’t help but feel like I’ve crossed some kind of threshold. I used to think classes were fine. Now I’m not so sure. I don’t know exactly where it’ll lead yet, but this feels like one of those exercises that’ll have a lasting influence on my work.</p>
<hr/>
<p><em>A mea culpa; I only got 99% of the way there. I use <a href="https://www.11ty.dev/docs/plugins/syntaxhighlight/">11ty’s syntax highlighting plugin</a>, which uses classes for styling. I gave <a href="https://andreruffert.github.io/syntax-highlight-element/">syntax-highlight</a> a hard look, but I don’t love the idea of introducing client-side js where none need exist, and the authoring experience would be a step back, so I begrudgingly left it alone for now.</em></p>

    
  </article>
</div></div>
  </body>
</html>
