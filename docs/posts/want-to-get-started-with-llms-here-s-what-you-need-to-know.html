<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://flyte.org/blog/getting-started-with-large-language-models-key-things-to-know#what-are-llms">Original</a>
    <h1>Want to get started with LLMs? Here&#39;s what you need to know</h1>
    
    <div id="readability-page-1" class="page"><div fs-readtime-element="contents" fs-codehighlight-element="code" fs-codehighlight-theme="a11y-light" fs-richtext-element="rich-text" fs-toc-element="contents" fs-toc-offsettop="2rem" fs-toc-hideurlhash="true"><p><em>An introductory guide to LLMs</em></p><p>As a machine learning engineer who has witnessed the rise of Large Language Models (LLMs), I find it daunting to comprehend how the ecosystem surrounding LLMs is developing. Every week, I come across new tools and techniques related to LLMs on my Twitter feed. It can be difficult to keep up with ways in which the LLM ecosystem is evolving. And if you’re just starting to use LLMs, the stream may seem to be moving too quickly to jump in!  </p><p>The good news is that we&#39;ve now reached a point where there are reliable and easy-to-use tools to work with LLMs. While more advanced tools will likely appear in the future, the current choices for fine-tuning models or making predictions are pretty impressive. They empower you to create some truly powerful applications.</p><p>In this post, I dive into the core principles of LLMs and the tools and techniques you’ll need to get started with LLMs.</p><h2><strong>What are LLMs?</strong></h2><p>A Large Language Model, as the name implies, refers to a model trained on large datasets to comprehend and generate content. Essentially, it&#39;s a transformer model on a large scale. The transformer model itself is a neural network designed to grasp context and meaning through the analysis of relationships within sequential data.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/63bc83b29094ec80844b6dd5/6526dc7acad02c40d777c57e_vhiySUD-e-bRSZISk2VyN92nxWrMQGP9AqqiDPVsTm2_sWaccjGWkxihFg4DKiL2lfhbg3xonfvMRpzDnvwuvIuiJhto8cPiltZgjhY4Y6vL6-yzH-f4-eqNApwrO8z6lqmy9iRyzNMuqHq6gkAeYX4.png" alt=""/></p><figcaption>The architecture of transformer model (<a href="https://arxiv.org/pdf/1706.03762.pdf">Source</a>)</figcaption></figure><p>Transformers are great for LLMs because they have two important features: positional encodings and self-attention.</p><p>Positional encodings help the model understand the order of words in a sequence and include this information in the word <a href="https://vickiboykis.com/what_are_embeddings/">embeddings</a>. Here&#39;s a bit more about it from Brandon Rohrer’s article &#34;<a href="https://e2eml.school/transformers.html">Transformers from Scratch</a>&#34;:</p><p>“There are several ways that position information could be introduced into our embedded representation of words, but the way it was done in the original transformer was to add a circular wiggle.”</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/63bc83b29094ec80844b6dd5/6526df6b5c3a19649d0943e5_circular-wiggle.jpg" loading="lazy" alt=""/></p></figure><p>“The position of the word in the embedding space acts as the center of a circle. A perturbation is added to it, depending on where it falls in the order of the sequence of words. For each position, the word is moved the same distance but at a different angle, resulting in a circular pattern as you move through the sequence. Words that are close to each other in the sequence have similar perturbations, but words that are far apart are perturbed in different directions.”</p><p>Self-attention allows the words in a sequence to interact with each other and find out who they should pay more attention to. To help you understand this concept better, I’ve borrowed an example from Jay Alammar’s “<a href="http://jalammar.github.io/illustrated-transformer/">The Illustrated Transformer</a>” article:</p><p>“Say the following sentence is an input sentence we want to translate:”</p><p>‘The animal didn’t cross the street because it was too tired’</p><p>“What does ‘it’ in this sentence refer to? Is it referring to the street or to the animal? It’s a simple question to a human, but not as simple to an algorithm.”</p><p>“When the model is processing the word ‘it,’ self-attention allows it to associate ‘it’ with ‘animal.’”</p><p>Transformers utilize a powerful attention mechanism known as multi-head attention. Think of it as combining several self-attentions. This way, we can capture various aspects of language and better understand how different entities relate to each other in a sequence.</p><p>If you&#39;re interested in a visual guide to understand LLMs and transformers, <a href="https://ig.ft.com/generative-ai/">this resource</a> is worth exploring.</p><h2><strong>What can LLMs do?</strong></h2><p>With LLMs, the possibilities are vast — from creating AI assistants and chatbots to engaging in conversations with your data and enhancing search capabilities. </p><h3><strong>AI assistants</strong></h3><p>The growth of LLMs has led to the development of many AI assistants, each designed for specific tasks like pair programming, scheduling and making reservations. Ongoing research aims to create a universal assistant capable of assisting with a wide range of tasks. Examples of such assistants include <a href="https://pi.ai/talk">Pi</a> and ChatGPT.</p><h3><strong>Chatbots</strong></h3><p>You can create chatbots tailored to specific tasks, like answering user or customer questions by fine-tuning them on custom data. For example, one of our community members has built a <a href="https://flyte.org/blog/building-flytegpt-on-flyte-with-langchain">chatbot to address Flyte-related inquiries</a>.</p><p>What’s more, you have the flexibility to develop chatbots that mimic the speech patterns of various personas, such as game characters or celebrities. <a href="https://beta.character.ai/">Character.ai</a> is an intriguing example.</p><h3><strong>Generation</strong></h3><p>LLMs are trained to generate the next piece of text given some input text. You can use them to write stories, create marketing content or even generate code. They&#39;re great at understanding what comes next in a text, making them handy for all sorts of writing tasks.</p><h3><strong>Translation</strong></h3><p>An LLM excels at translation tasks, which are considered relatively straightforward for them. They can also handle more complex tasks like translating text into code. If you provide a user instruction to generate a code snippet in any programming language, an LLM should be able to generate the code for you. A popular example of such a model is <a href="https://about.fb.com/news/2023/08/code-llama-ai-for-coding/">Code Llama</a>.</p><h3><strong>Summarization</strong></h3><p>With LLMs, you can create applications that automatically summarize long documents, research papers, and meeting notes and articles, making information more accessible. </p><h3><strong>Search</strong></h3><p>LLMs are great at grasping natural language queries. Unlike simple keyword-based searches, LLM-powered search engines like <a href="https://blog.google/products/search/google-search-generative-ai-learning-features/">Google&#39;s generative AI search</a> and <a href="https://www.perplexity.ai/">Perplexity AI</a> offer more relevant and context-aware results. These advancements have revolutionized real-time search capabilities.</p><p>These use cases represent just the tip of the iceberg; LLMs offer many more possibilities, including personalization, recommendation systems, interactive fiction, gaming and much more.</p><h2><strong>Putting LLMs to the test</strong></h2><p><a href="https://chat.openai.com/">ChatGPT</a> is the go-to choice for testing LLMs. However, if you&#39;re a fan of open-source solutions like we are, you might want to explore <a href="https://huggingface.co/chat/">HuggingChat</a>. Additionally, there&#39;s <a href="https://bard.google.com/">Google Bard</a> and other open-source LLMs available on Hugging Face spaces. These can be used as hosted applications or accessed programmatically through the API.</p><p>You can find a list of open-source LLMs on Hugging Face in the <a href="https://huggingface.co/spaces/HuggingFaceH4/open_llm_leaderboard">Open LLM leaderboard</a>. These models are assessed using the <a href="https://github.com/EleutherAI/lm-evaluation-harness">Eleuther AI Language Model Evaluation Harness</a> framework, which evaluates generative language models across a wide range of tasks.</p><p>It&#39;s important to note that not all chatbots or applications use the same LLM. ChatGPT employs the GPT-series models, HuggingChat <em>currently</em> utilizes the <a href="https://huggingface.co/OpenAssistant/oasst-sft-6-llama-30b-xor">OpenAssistant LLaMa 30B SFT 6</a> model, and Google Bard is <em>currently</em> powered by the <a href="https://ai.google/discover/palm2/">PaLM 2</a> model. It&#39;s worth noting that these models can change over time as newer, more efficient models are continually trained on larger datasets and improved model architectures.</p><h3><strong>How do LLMs differ?</strong></h3><p>An important question we need to address: What&#39;s the purpose of having multiple language models? It&#39;s important to note that LLMs are still an active area of research, and we haven&#39;t reached a point where we can rely on a single model for all tasks. Whether we will ever reach that stage remains uncertain. However, the community is actively working to discover the best models for various applications we intend to build upon and use.</p><p>The following are some key factors that contribute to the differences between LLMs:</p><h4><strong>Model architecture</strong></h4><p>LLMs can have different architectures depending on their objectives, computational resources and training tasks.</p><h4><strong>Data</strong></h4><p>The quality and amount of training data vary among models. PaLM 2, for instance, utilizes five times more data than its predecessor.</p><h4><strong>Parameter count</strong></h4><p>A higher parameter count indicates a more powerful model. For example, GPT-3 has 175 billion parameters. Meta&#39;s <a href="https://ai.meta.com/llama/">Llama 2</a> includes models ranging from 7 billion to 70 billion parameters.</p><h4><strong>Training objective</strong></h4><p>While some LLMs excel at text completion tasks, others are designed for specific use cases. For instance, MosaicML introduced the <a href="https://huggingface.co/mosaicml/mpt-7b-storywriter">StoryWriter</a> model, developed to read and write fictional stories with extended context lengths (65K tokens). At inference time, it can go beyond 65K tokens. </p><h4><strong>Computational resources</strong></h4><p>Some LLMs are designed to be resource-intensive for better performance, while others prioritize efficiency for faster inference or when resources are limited. For example, <a href="https://simonwillison.net/2023/Aug/1/llama-2-mac/">Llama 2 can run on your Mac</a>.</p><h2><strong>What are prompts?</strong></h2><p>A prompt is the input given by a user, and the model responds based on that input. A prompt can be a question, a command or any kind of input, depending on what&#39;s needed for a particular use case. </p><div><div>
  <p>Copied to clipboard!</p>
  <pre><code fs-copyclip-element="copy-this-1">Classify the text into positive, negative or neutral.

Text: The movie isn’t that great.
Sentiment:</code></pre>
</div></div><p>This is a prompt that can be provided to an LLM to guide it. An LLM typically responds with &#39;positive,&#39; &#39;negative&#39; or &#39;neutral&#39;.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/63bc83b29094ec80844b6dd5/6526dc7abdca412177ebf5e0_MJ7kAA472mdMZpxlpZdCkp5SHefoHsDt2LGS6hRCHHeZ0Wp-_4R0iNMl08HfYWcbwpcEGZHhAhjdCKArL3wfEX_qydata-WmQt_fI-M9DeBTAiUkie5RFqwsqKhdqtcTt6YZ4n8YtYP4Khpm2urtgV8.png" alt=""/></p><figcaption>Response generated by ChatGPT</figcaption></figure><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/63bc83b29094ec80844b6dd5/6526dc7a973293482c53741a_QerwpukKzVys4dS78_GFbu9M6RzbRxsKpZN2LtqoJzfl2KWyTlnM3oLUcvW0YDepcKDXbNhcdKkcEXBaVRNzPm5dVfvJGOFC6rn1ueApLkW_ZZgcOtUFG2B7jECca-kbycfXBNMN6PmY9WQT9ZzD41E.png" alt=""/></p><figcaption>Response generated by Llama 2 7B Chat model</figcaption></figure><p>From the examples above, you can see that different LLMs create different results. This happens because of how they were trained, similar to how each of us has different opinions 🧠 about the sentiment that exact piece of text conveys.</p><h3><strong>Prompt format</strong></h3><p>A straightforward way to interact with an LLM is by offering an incomplete sentence and allowing the model to complete it. This approach aligns with the nature of pre-trained LLMs, which excel at text completion.</p><div><div>
  <p>Copied to clipboard!</p>
  <pre><code fs-copyclip-element="copy-this-2">Flamingos are</code></pre>
</div></div><p>When presented with this prompt, an LLM provides information about what flamingos are.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/63bc83b29094ec80844b6dd5/6526dc7b523a12e5ee41a97e_t1qNIPgILazRwUbuIKISqiEZ1ePUqd_hEQan3gLP3WQhxSRuP1LMTu_MLzxjEgkdWVB119SPF_rlwicEHzIB8OLFANzaMVpGLVZD901dbzj9vGAvybZCOGlD_WBJmvR2BtQB8g8_ebZHJhWaeHOrBgw.png" alt=""/></p><figcaption>Google Bard not only provided a definition of flamingos but also included a citation.</figcaption></figure><p>LLMs can do more than just complete text; they can summarize, generate code, solve math problems and more. </p><div><div>
  <p>Copied to clipboard!</p>
  <pre><code fs-copyclip-element="copy-this-3">&lt;Q&gt;: Two missiles speed directly toward each other, one at 9,000 miles per hour and the other at 21,000 miles per hour. They start 1,317 miles apart. Without using pencil and paper, calculate how far apart they are one minute before they collide.
&lt;A&gt;:</code></pre>
</div></div><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/63bc83b29094ec80844b6dd5/6526dc7acad02c40d777c5be_uQsLsVTB6uSL-VfRzivujHxja8-wvSF2OL4GptGM_4FTvSkaJ2CjmZMvOYqyIV2wSmMT5rfdtN3DXrgbJuLmU5T7O5A8dDvm2kSMVJoSyySV5-9IGfz1zFX4qbq66rftK6JX9LjwR7T_FCZJYMXW0hI.png" alt=""/></p><figcaption>Response generated by ChatGPT </figcaption></figure><p>In this case, the format of the prompt is `&lt; Q &gt;` followed by `&lt; A &gt;`. However, the format can vary depending on the specific LLM you&#39;re using and the response you&#39;re aiming for. For instance, there&#39;s a detailed guide on how to <a href="https://replicate.com/blog/how-to-prompt-llama">prompt Llama 2</a>. </p><p>Creating clear and effective prompts is crucial to achieve the results you want, a process known as prompt engineering.</p><h3><strong>Prompt engineering</strong></h3><p>Prompt engineering is all about coaxing the model into a region of its latent space by manipulating the input prompt so the probability distribution of the next-tokens it predicts matches your intent. In simpler terms, it means guiding the model to generate the desired output.</p><p>There are many ways of doing this, such as providing examples of the kinds of outputs you want, instructing the model to write “in the style of” certain authors, using chain-of-thought reasoning, enabling the model to use external tools, and more.</p><h3><strong>Zero-shot prompts</strong></h3><p>A prompt that doesn&#39;t provide specific examples for how the model should respond is called a “zero-shot prompt.” The flamingos prompt and the classification prompt are both examples of zero-shot prompts. Zero-shot prompts are effective in cases where the model understands the instruction.</p><h3><strong>Few-shot prompts</strong></h3><p>LLMs excel with zero-shot prompts but may struggle with complex tasks. Few-shot prompts, which include examples within the prompt, enable in-context learning. In this approach, the model learns from both the instructions and the provided examples to understand its task.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/63bc83b29094ec80844b6dd5/6526dc7ad98b0710b7a4b5bd_p5FGHZ4oQhjv46aTd2pkBcLbOrTpljqqFuCLK1nYDxkjO-vkC-B2YQ0vHD26xp4qibYyYyYvcmK4N5Zvtd6R_Qtg--JoomGJpj0AkW0LbYOSeft-k-pZanHyGIe2TVB6rhP0Y5HOgTAy2x7uNu4R-xs.png" alt=""/></p><figcaption>Vicuna 33B: Few-shot prompting </figcaption></figure><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/63bc83b29094ec80844b6dd5/6526dc7a9e5946ce6be0da2f_JaZuPahPaKwejaT7XxcHuWed6EEiXwNjAmmaFxEA0utxXiSlaPNis24cARKD2iJnVytBTmgE34r9WPikAssIl2v2HATndM3mP_COb1B2bzCd1xTW6jhjd53X8-N1vQVgdeOGOB3FPZ2Lzs8t1Z4arC8.png" alt=""/></p><figcaption>HuggingChat: Few-shot prompting</figcaption></figure><h3><strong>Chain of thought (CoT) prompting</strong></h3><p>CoT prompting encourages the LLM to provide explanations for its reasoning. Combining it with few-shot prompting can yield improved results for more intricate tasks that demand prior reasoning before generating responses.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/63bc83b29094ec80844b6dd5/6526dc7a2ef13c9c9ea4e49a_0DUqKmq_GlbM6o3Mo-T19l-lwOKhwHNdqPkz9Tv6NmkLxAYVRIdN1K-WIZJtyX5RLUBYdalFjrxkX5EAYd4kWJgjVcyRe-j9YOLNELdTr4wHv2gDhBgYdFVxYEuWHTwPgaEkh6jMZbeEM536d_00fyc.png" alt=""/></p><figcaption>Standard prompting vs CoT prompting (<a href="https://arxiv.org/abs/2201.11903">Source</a>)</figcaption></figure><p>The core concept behind CoT is that by presenting the LLM few-shot examples that include reasoning, it will subsequently incorporate the reasoning process into its responses when addressing prompts.</p><h4><strong>Let’s think step by step</strong></h4><p>Instead of including examples with reasoning in the prompt, you can achieve accurate answers by employing zero-shot prompting simply by adding &#34;Let&#39;s consider step by step&#34; to the end of the question. This approach has been demonstrated in the <a href="https://arxiv.org/pdf/2205.11916.pdf">Large Language Models are Zero-Shot Reasoners</a> paper to yield reliable results.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/63bc83b29094ec80844b6dd5/6526dc7a2c0d5b9fc0b70522_sYkpR7MFfYX27TGzGSHXvAqeaNR_A3uc-SfHOfdB6ghzJCXz0zO1INi3QzlxXXkSslSud78f3u3zCCVuxHug09D5s4GoQlormtm0unE61sO-Q8iQTJmAAuIql_ceeVvOiEZASNej4K_hWBnruFpR8lk.png" alt=""/></p><figcaption>Zero-shot CoT (<a href="https://arxiv.org/pdf/2205.11916.pdf">Source</a>)</figcaption></figure><h2><strong>In-context learning (ICL)</strong></h2><p>In-context learning (ICL) entails providing context within prompts, which can be in the form of examples (few-shot prompting) or additional information. This approach empowers pre-trained LLMs to assimilate new knowledge. </p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/63bc83b29094ec80844b6dd5/6526dc7b00210dacf8dbaba5_prxmosontgXmGuQJ0WxEkacJwbStS50flJkzX13eJmTG1HbGiDkXzJ4pTMM1uEuu8epop2pRhNDnWA-kvJJgBSiQJHqt3g1wwLMunYF_21_t1w_t26BhzJgrmj-TwlnD9MyR_lB9rruBm-iTqmFscC4.png" alt=""/></p><figcaption>Teaching an LLM new information: HuggingChat</figcaption></figure><p>The categorization in this example can be easily understood — even at a glance, — because it represents a distinction between two- and four-wheelers. The LLM accurately categorizes based on the context provided in the prompt, showing its ability to infer. This approach can be extended to more-complex scenarios. For instance, a chatbot that interacts with data and incorporates context from provided documentation will be limited by the context window&#39;s size because it restricts the information you can include in the prompt. Fortunately, you can overcome this limitation by using vector databases.</p><h3><strong>Vector databases</strong></h3><p>Vector databases store context vectors or embeddings. If you want to input documents into your LLM, you must first convert the text into vectors and store them in a vector database. Later, these vectors can be used to provide “relevant” context within prompts to the LLM. Relevancy, referred to as <strong>semantic search</strong>, involves finding similarities between input queries and documents, both of which are represented as vectors. This allows us to fetch selectively from the vector database and provide relevant documents to the LLM without overwhelming the prompt context window.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/63bc83b29094ec80844b6dd5/6526dc7ac957a70292c794f4_598lLYbp9pdY6jShouCZuXQK_X_FxnWPxbFP_kkIv1WYnaispQMazodOxpKamY4jxYlvxAykrDIUFfLoFktBhlakfaIzsm1vCdpMfZp4ymOvSue0paxBzJte9QBCuXfr7ImAxTnarX5PRma9sc_cX44.png" alt=""/></p><figcaption>Semantic search (<a href="https://txt.cohere.com/what-is-semantic-search/">Source</a>)</figcaption></figure><p>Examples of vector databases include <a href="https://www.pinecone.io/">Pinecone</a>, <a href="https://www.trychroma.com/">ChromaDB</a> and <a href="https://weaviate.io/">Weaviate</a>.</p><p>The generic pipeline for semantic search and model prompting is as follows:</p><ol role="list"><li>Users input their query.</li><li>The query is embedded using identical embeddings as document vectors.</li><li>Semantic search retrieves the k-most similar documents from the vector database.</li><li>The output of semantic search, along with the user query, is sent to the model to generate a coherent response.</li></ol><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/63bc83b29094ec80844b6dd5/6526dc7a9358df9297a745c3_VcuXY6_891-FjYOPlzxwIQPzmMo4oLOfJE8vKFpK_Jo45mEuy6zTkmK0QoXKFoYqcQ7-8A8t43tOks7Xa1gicD6NZxmJRF4e7fICOmUG41PnaGASjezWGi9NbRZIZQGre3_BvIUs2-AqfWUEG5CMPTc.png" alt=""/></p><figcaption>Generic pipeline for in-context learning with semantic search (<a href="https://www.pinecone.io/learn/retrieval-augmented-generation/">Source</a>)</figcaption></figure><p><a href="https://www.langchain.com/">LangChain</a> is a popular tool to build context-aware applications on top of LLMs.</p><h3><strong>What is Retrieval Augmented Generation (RAG)?</strong></h3><p>The documents stored in the vector database may not provide up-to-date information for your LLM to answer accurately. This limitation arises because the model&#39;s knowledge is restricted to the data it was trained on, which has a cutoff date. If you ask your model about recent events not included in its knowledge, it may produce inaccurate answers, a phenomenon often referred to as <strong>hallucination</strong>.</p><p>Retrieval Augmented Generation (RAG) addresses this issue by retrieving current context-specific information from an external database. This updated information is then fed into the LLM to generate accurate responses. RAG also enables the LLM to cite resources while generating responses. </p><h4><strong>How does RAG differ from regular in-context learning?</strong></h4><p>RAG can be conceptualized as an online, in-context learning method. The process of generating vectors, storing them in a vector database and updating the index occurs in real time. This effectively addresses the recency issue commonly observed in LLM applications. For instance, you can write your code to ensure that whenever there&#39;s a data update, the indexing module upserts the data in the vector database. </p><p>RAG can be implemented through LangChain, HuggingFace, OpenAI and so on.</p><h2><strong>LLM parameters</strong></h2><p>When provided with a prompt, an LLM can generate a long list of potential responses. It operates like a prediction engine. However, in practice, LLMs typically provide a single output that represents the most likely response according to the model. The model calculates the probabilities of different words appearing in a response and returns only those words that meet the set parameters.</p><h3><strong>Model</strong></h3><p>The performance of a pre-trained LLM relies on its size: Larger models tend to produce higher-quality responses. However, bigger models increase costs and require more computational resources.</p><h3><strong>Temperature</strong></h3><p>Temperature influences the model&#39;s creativity. Lower temperatures yield consistent and predictable results, while higher temperatures introduce randomness, resulting in more creative outputs. At a temperature of 0, the model always produces the same output. However, with higher temperatures, the model outputs words associated with varying probabilities.</p><h3><strong>Top-p and Top-k</strong></h3><p>Top-p selection involves choosing tokens from the highest-probability options; the sum of their probabilities determine the selection. For example, if `p` is set to 0.15, the model will select tokens like “United” and”&#39;Netherlands” because their combined probabilities add up to 14.7%.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/63bc83b29094ec80844b6dd5/6526dc7a58abce2cf80c7ec4_3xuGN41Y7YS_FrN2v4e_OuSrPloFU9IR0BQCRDsrR6f6tzParykxZ31uazO5Z1njqicoXsfPWdmOBcmK3p5EGffZSKC_mT6AoBTJhD8r6Eobbkeu0MUYJ52aUPXixE2gqQ7g--T8lXCSHCiV5boZX08.png" alt=""/></p><figcaption>Top-p (<a href="https://txt.cohere.com/llm-parameters-best-outputs-language-ai/">Source</a>)</figcaption></figure><p>The lower the value of `p`, the more deterministic the responses generated by the model are. The general recommendation is to alter either temperature or top-p, but not both.</p><p>Top-k selection involves selecting the next token from the list of the highest `k` tokens, which are sorted by their probability. For instance, if `k` is set to 3, the model will choose from the top 3 options.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/63bc83b29094ec80844b6dd5/6526dc7a85ec36671da4beed_LFlGG_lEIghK6EDT9JX6eRFV0OCeg5V3XU55bK6KOWfyK587162XIwJWp4qUwgSo6Maq2sELAh7x4lYmmwxB4rxwYZdti5WWVx4e-7amly4G-PQ-xFryT8ypOcwa5HIjlcIpGm92GutgTxd_bJgn61w.png" alt=""/></p><figcaption>Top-k (<a href="https://txt.cohere.com/llm-parameters-best-outputs-language-ai/">Source</a>)</figcaption></figure><h3><strong>Number of tokens</strong></h3><p>Tokens serve as the fundamental units of text in LLMs. A token doesn&#39;t always represent a single word; it can also encompass a group of characters. As a general rule of thumb, one token is roughly equivalent to four characters of English text.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/63bc83b29094ec80844b6dd5/6526dc7a3a01cebbc6fede41_3kV3_EHVsIsvhqHiDvj68BpsPSwvyFIOv7RV8ZB6zfxJdulGqzsWT2kZDJHwZMc99Zhrstw29L3vEDyC7YiRSQC1AlS4KdvEf_AvzLRS002MFUD2El5-YnmS13FgiNhbgJF9HCOgcx6II0tjFRvIJJw.png" alt=""/></p><figcaption>The highlighted text corresponds to tokens. (<a href="https://platform.openai.com/tokenizer">Source</a>)</figcaption></figure><p>The number of tokens in a model corresponds to the maximum number of input tokens the model can accept and the maximum number of output tokens it can produce. Typically, this number is set at 1,024, 2,048 or 4,096, but for some models, it can be even larger.</p><h3><strong>Stop sequences</strong></h3><p>Stop sequences can be employed to instruct the model to stop its token generation at a specific point, such as the end of a sentence or a list. It proves useful when you intend to stop token generation immediately upon encountering a stop sequence. This approach can be tailored to specific use cases or employed to reduce the cost of token generation.</p><h3><strong>Repetition penalty</strong></h3><p>Repetition penalty discourages the repetition of tokens that have appeared recently in the generated text. It encourages the model to produce more diverse tokens by reducing the likelihood of selecting tokens with higher scores.</p><p>When the repetition penalty is set to 1.0, there is no penalty applied. A value of 1.2 strikes a good balance between maintaining accuracy in generation and minimizing repetition, as described in <a href="https://arxiv.org/pdf/1909.05858.pdf">this paper</a>.</p><h2><strong>When to fine-tune?</strong></h2><p>Prompt engineering, with or without few-shot prompts and in-context learning, is suitable when the model needs data input. However, for scenarios requiring specific styles, patterns, specialized skills or internal model improvement, fine-tuning is a better choice. Fine-tuning involves updating model parameters through training on selected data, enhancing the model from within, while prompt engineering enhances the model externally. Fine-tuning is a more advanced technique, often requiring a substantial level of expertise in LLMs.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/63bc83b29094ec80844b6dd5/6526dc7a85ec36671da4bee9_XFLTneVrI20STsazT3u69bQJtnNhytvSSqjYFNh5DXc9SHjnxgBsxnfPBuIHtvK0WL8No9Z835qaXq826WF48TtUQ7g-_CubAHjb69UvEErXoR7pKAsaRDn6CwVRA1QpS4XoFkfFWGCHCthGk80o0Rs.png" alt=""/></p><figcaption>The three fine-tuning approaches (<a href="https://magazine.sebastianraschka.com/p/finetuning-large-language-models">Source</a>)</figcaption></figure><p>In the feature-based approach, we load a pre-trained LLM, generate output embeddings for the training set and use them as input features to train a classifier. In fine-tuning I, the output layers are pre-trained, keeping the LLM frozen. In fine-tuning II, all model layers are updated — that’s expensive and requires a lot more compute power.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/63bc83b29094ec80844b6dd5/6526dc7ab6869df20b2f7310_L1lzUbREy9_abXbHFOfWJvvoC3-j1QySAl5JkpmLlhrwQt58VxGJ3ixT_xvTUcgIwbP_2WBesT_xkCELMKE3gQTztlcCEiMOlWY9N1Av4ugXO1OVuo7MUuv1jPM1gVJWfXL9C3d67wutg1y_GhYIqak.png" alt=""/></p><figcaption>Performance of pre-trained DistilBERT models fine-tuned on the IMDB Movie review dataset (<a href="https://magazine.sebastianraschka.com/p/finetuning-large-language-models">Source</a>)</figcaption></figure><p>Updating all layers (fine-tuning II) yields better performance than updating only the output layers (fine-tuning I). This can be seen in the performance plot from an experiment conducted by the blog post author, Sebastian Raschka. The graph shows performance plateaus when training the last two layers and transformer blocks, with no improvement in accuracy between the final stages. In other words, performing a full parameter fine-tuning becomes inefficient in terms of computation resources and time.</p><h3><strong>Parameter-efficient fine-tuning (PEFT)</strong></h3><p>PEFT (Parameter Efficient Fine-Tuning) reuses a pre-trained model to reduce computational and resource requirements. PEFT encompasses techniques that fine-tune a limited number of model parameters while preserving accuracy. Examples of PEFT techniques include prompt tuning and low rank adaptation (LoRA).</p><h4><strong>Prompt tuning</strong></h4><p>Prompt tuning falls between prompt engineering and fine-tuning. Unlike fine-tuning, it doesn&#39;t modify the model parameters. Instead, it involves passing prompt embeddings along with each prompt sent to the model. Essentially, the model updates the prompt itself, creating what we call <strong>soft prompts</strong>. These soft prompts comprise embeddings, numeric representations derived from the larger model&#39;s knowledge. In contrast to <strong>hard prompts</strong>, which are manually crafted with discrete input tokens, soft prompts cannot be directly viewed or edited as text.</p><h4><strong>Low rank adaptation (LoRA)</strong></h4><p>Another popular PEFT technique is LoRA, which facilitates fine-tuning specific adapters loaded into the model. LoRA achieves this by transforming weights into a lower-dimensional space, effectively reducing computational and storage demands.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/63bc83b29094ec80844b6dd5/6526dc7aafb7a686d8643a80_VTe0h3y2KO_ScFQ4BweoovzGq_nm_xdECSxbcp4ynct9HtgwQu_uYm09j5RVIcSqYW8xErsn1nujOp50k8XeyzwfWgdtFkOZ_ybBcJzFeblbvVb1jgWB_FpTy1PlIHSde84RBNjp7CbSX1WBAXdp7mI.png" alt=""/></p><figcaption>Pretrained weights W are frozen while the trainable parameters A and B approximate the gradient update, ∆W (<a href="https://arxiv.org/pdf/2106.09685.pdf">Paper</a>)</figcaption></figure><h3><strong>Reinforcement learning with human feedback (RLHF)</strong></h3><p>In RLHF, a pre-trained model is fine-tuned via a combination of supervised and reinforcement learning. Human feedback is collected by ranking or rating various model outputs, creating a reward signal. These reward labels train a reward model, which, in turn, guides the LLM’s adaptation to human preferences. </p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/63bc83b29094ec80844b6dd5/6526dc7aa204e991feec3a9a_SgR3MGQN8PV_rxDdoPawloL1aMOrdfU-kutd96ihVc4-EBKG-XA-dFCsZYbZAI-1bM4_jM60mpOXLEWUTpYmek7IjP2s3Cx6oSCWo-Qvodr_bcc2oXcL6Ww1E8os-scKENqu6FTFIuVq65vlFBsytXs.png" alt=""/></p><figcaption>A typical RLHF pipeline</figcaption></figure><p>The reward model can be initialized from a supervised fine-tuning model (SFT), where the model is fine-tuned through supervised learning. Then, the reward model calculates the loss and updates the pre-trained LLM using a form of reinforcement learning known as proximal policy optimization (PPO).</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/63bc83b29094ec80844b6dd5/6526dc7a3a01cebbc6fede47_VyYrZ4BkcSSJxHHcnfsfZr4UUETO1JcliFMEr1bBkRXGjw-g-0kM_BtQN9golSFOESm1uLjlsxNVlYbJHriSCJUX-XDIgd_CSh4k37XyMPazzF-203QHagbLY8An0lwNbO4XUYG3WnsgBxnNFZxgTiE.png" alt=""/></p><figcaption>RLHF process applied to InstructGPT model: supervised fine-tuning, reward model and reinforcement learning via PPO (<a href="https://arxiv.org/pdf/2203.02155.pdf">Source</a>)</figcaption></figure><p>The <a href="https://github.com/huggingface/trl">Transformer Reinforcement Learning (TRL) library</a> can be used to train transformer language models and stable diffusion models from SFT, reward modeling to PPO. It is built on top of the <a href="https://github.com/huggingface/transformers">transformers</a> library.</p><h2><strong>Optimization techniques for fine-tuning</strong></h2><p>To enhance fine-tuning efficiency, consider employing quantization and zero-redundancy optimization. </p><p>Note: This section is excerpted from Niels Bantilan’s blog post titled “<a href="https://www.union.ai/blog-post/fine-tuning-vs-prompt-tuning-large-language-models">Fine-Tuning vs. Prompt Engineering Large Language Models</a>” on Union.ai. </p><h3><strong>Quantization reduces memory utilization</strong></h3><p>Quantization is the process of reducing the precision of numerical data so it consumes less memory and increases processing speed. However, lower precision leads to lower accuracy because less information is being stored within each layer. This doesn’t just apply to neural networks; if you’re a data scientist or ML engineer who has used Numpy, Pandas or any other numerical library, you’ve probably encountered `float64`, `float32` and `float16` data types. The numbers 64, 32 and 16, respectively, indicate how many bits are used to represent, in this case, floating point numbers.</p><p>Deep learning frameworks like <a href="https://pytorch.org/docs/stable/notes/amp_examples.html">PyTorch</a>, <a href="https://www.tensorflow.org/guide/mixed_precision">TensorFlow</a> and <a href="https://github.com/deepmind/jmp">Jax</a>, commonly provide utilities to do mixed-precision training; this lets the framework automatically cast the weights, biases, activations and gradients to lower floating-point precision (e.g. float16) when appropriate, and then cast them to higher precision representations (e.g. float32) when numerical stability matters (for instance in gradient accumulation or loss scaling). One library that may be of interest to fine-tuners is the <a href="https://github.com/TimDettmers/bitsandbytes">bitsandbytes</a> library, which uses 8-bit optimizers to reduce the memory footprint significantly during model training.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/63bc83b29094ec80844b6dd5/6526dc7a7583bb32b0bb9207_fmaeYH7UD8eOrpmDv55DuubnHoj9kXUFkKWN2dKt4g1qvFMSsyZhKF92eicJfCryhoLuwiAKp5EyP9stqFYiM-nz0bp6DBo-u9pqHUFMKQUOIJwvLjTlGzFB8CE7uRrPqhjQBSCixHWg37A5YmWvKXg.png" alt=""/></p><figcaption>Converting an FP-16 vector to INT8 through quantization (<a href="https://huggingface.co/blog/hf-bitsandbytes-integration#introduction-to-model-quantization">Source</a>)</figcaption></figure><h3><strong>Zero-redundancy optimization shards and offloads model state</strong></h3><p>A few years ago, the only sort of data parallelism that you could easily leverage with deep learning libraries consumed a lot of GPU memory. If you had a machine with four GPUs, you could replicate the model four times, and if you could train a batch size of 8 on each GPU, you would obtain an effective batch size of 32.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/63bc83b29094ec80844b6dd5/6526dc7a9358df9297a7459f_0aW9iRLuTbXJ9QyE35YRzXID3pjvD59afhrq1U_9_9AA2gvlGKera8SDiGMRYU6bbKzLwtoIwJo18GWU74xuEJ3szLOWt1YCtUAZXqF32unos4K3qAlG4yw2iqaypNwQoLAvJvTQUDe8Dl6XDGYkM8k.png" alt=""/></p><figcaption>Conventional data parallelism maintains a full replica of the model across the available cores, allowing you to increase the effective batch size during training. (<a href="https://engineering.fb.com/2021/07/15/open-source/fsdp/">Source</a>)</figcaption></figure><p>The<a href="https://arxiv.org/pdf/1910.02054.pdf"> ZeRO paper</a>, which is available via<a href="https://github.com/microsoft/DeepSpeed"> DeepSpeed</a> and Pytorch’s<a href="https://pytorch.org/tutorials/intermediate/FSDP_tutorial.html"> FSDP</a> implementation, enables you to shard the optimizer state, gradients and parameters across the available GPUs and CPUs in the training system. This is done in a layer-wise fashion, so only the model state required for a specific local forward/backward pass is replicated across GPUs. For example, if you’re training a neural net with three layers, the ZeRO protocol replicates the model state required for the forward pass of the first layer, freeing up memory once it obtains the activations. This is repeated in the forward passes for layers two and three. Finally, this process is applied to the backward passes, resulting in updates to the parameters of the model.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/63bc83b29094ec80844b6dd5/6526dc7a87a474ff8229fb12_138XdFxUt2Ok4xbwlf46-k7bHYFLKjAYo63p8E-19o7W51m3aZEHNb3zFfb75cQqQlfr0WSDbINgNsy76DCfY6GMy5E_5jTLSESRAn8zLXi36wog1VXzrTotVyQdiaNSue-vIsKTXkICklq-shNfM7Y.png" alt=""/></p><figcaption>ZeRO is a type of data parallelism that only loads the weights needed for a particular layer-wise forward/backward pass, so you never load a full model into memory. (<a href="https://engineering.fb.com/2021/07/15/open-source/fsdp/">Source</a>)</figcaption></figure><p>The ZeRO framework also allows for offloading of model states to CPU or <a href="https://en.wikipedia.org/wiki/NVM_Express">NVMe</a> where appropriate, which further reduces GPU memory consumption and improves training speed.</p><h2><strong>What is hallucination in LLMs?</strong></h2><p>A hallucination in an LLM occurs when the model generates text that seems plausible but is actually incorrect or nonsensical. While <a href="https://bard.google.com/">Google Bard</a>, Perplexity AI, and <a href="https://www.bing.com/search?q=Bing+AI&amp;showconv=1&amp;FORM=hpcodx">Bing Chat</a> show citations, they may reduce hallucinations to some extent but don&#39;t fully eliminate them.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/63bc83b29094ec80844b6dd5/6526dc7a98bd2645ac8cb546_2oYfMA1IYxhebWoUqcNNgifKRQz0dovbka_dE8SfAfSr9GfcENkc0DoxcvbaN9eQL-vNa5XBbzV8wWb_51wwEU7nuljL02RjsG3phGSbOkyZjYZPwfN3WQBlsx5hCzoVvzTzbkQFnCMeh990LxGCMBU.png" alt=""/></p><figcaption>ChatGPT got deceived! 😱(<a href="https://flyingbisons.com/blog/hallucinations-of-chatgpt-4-even-the-most-powerful-tool-has-a-weakness">Source</a>)</figcaption></figure><h3><strong>Why do LLMs hallucinate?</strong></h3><p>LLMs tend to hallucinate when they have an incomplete understanding of the prompt&#39;s context. In such cases, they may make educated guesses based on learned patterns. Hallucinations can also be a result of incomplete or incorrect training data. Since LLMs rely on their training data rather than real-world information, their outputs may sometimes be irrelevant. However, techniques like Retrieval Augmented Generation (RAG) can be employed to incorporate real-time information and mitigate this issue.</p><h3><strong>How can you reduce hallucinations?</strong></h3><p>Hallucination can be desirable in certain scenarios, such as when creative responses are needed, like in story writing or marketing content creation. However, when accuracy and factual information are required, hallucination becomes undesirable.</p><p>Here are ways to mitigate hallucinations:</p><ol role="list"><li>Prompt engineering: By including more contextual information in the prompt, the language model gains a better understanding of the context and can generate more appropriate responses.</li><li>In-context learning: When the model receives contextual information as part of the prompt, it has access to additional data that aids in generating accurate responses. A lack of context is a common cause of hallucinations.</li><li>Controlled generation: Imposing sufficient constraints in the prompt can restrict the model&#39;s freedom to produce hallucinatory content.</li></ol><p>However, it&#39;s important to note that hallucinations cannot always be completely eliminated. Models may still generate errors that are challenging to detect.</p><h2><strong>Running LLMs on local machines</strong></h2><p>Indeed, you heard correctly! You can run LLMs on your local machine to generate predictions. You can utilize <a href="https://github.com/mlc-ai/mlc-llm">Machine Learning Compilation (MLC)</a> for LLM or employ <a href="https://github.com/ggerganov/llama.cpp">llama.cpp</a> for the same purpose.</p><h3><strong>MLC</strong></h3><p>MLC enables the native deployment of any LLM through native APIs with compiler acceleration. It offers support for the following platforms and hardware:</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/63bc83b29094ec80844b6dd5/6526dc7a2c0d5b9fc0b70519_WftY87s-mCLRQ2vZLh2vlb05ZEmhFNAHbSBmMV88SkK6RmrT7HT_NT94F7Zo6ePrKy0eP72oXIxEkMznNQU-EGaK8N7j07aNio93WsxqG18mvRYdRPGAKxCbe5CAeRgRLHIRhzpH_m6XSSyWDa-pRUc.png" alt=""/></p><figcaption>Platforms and hardware supported by MLC</figcaption></figure><h3><strong>llama.cpp</strong></h3><p>llama.cpp empowers you to execute the Llama model using 4-bit integer quantization on a MacBook. It conducts the inference of the Llama model in pure C/C++.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/63bc83b29094ec80844b6dd5/6526dc7ada8b9b0182bf5fd7_BPQqPJjzyeKnknmYc4z9UKdfa-kyBOgQKFjOYl4OlTJ6DIN7MgxXNsDNuU6Ah2XGVxoLeAK_HUcsZWJFyTm0SESPLVy4ZllNa4lYROoaljzC43SXFE6yqpiBgWG7sBey21WfdwpiicntBVxkig8YTDE.png" alt=""/></p><figcaption>Platforms, models and bindings supported by llama.cpp </figcaption></figure><h2><strong>Conclusion</strong></h2><p>This blog post introduced LLMs and discussed the various ways we could interact with them. It began with an overview of how LLMs had been developed and their applications. Following that, we delved into how LLMs were tested and why different types of LLMs were necessary, highlighting their differences.</p><p>We then explored the concept of prompts, which interact with the model and encourage it to generate accurate responses through various manipulations. Subsequently, we explored LLM parameters and examined some reasons for fine-tuning an LLM, along with optimization strategies to reduce computational and storage costs.</p><p>Finally, we addressed the issue of hallucination in LLMs and provided insights into running LLMs on local machines.</p><h3><strong>Fine-tuning and running LLMs in production</strong></h3><p>For those eager to explore further, you may want to know how to fine-tune an LLM with an <a href="https://www.union.ai/blog-post/orchestration-for-data-machine-learning-and-infrastructure">orchestrated</a> pipeline and perform low-latency, high-throughput inference.</p><p>Successful fine-tuning typically demands a significant amount of GPUs, RAM and memory resources, although it&#39;s worth noting that some models can be fine-tuned on local machines. For instance, you can find guidance on fine-tuning Llama 2 on a local machine <a href="https://www.youtube.com/watch?v=3fsn19OI_C8">here</a>. The specific resource requirements vary depending on the size of the model you&#39;re working with.</p><p><a href="http://github.com/flyteorg/flyte">Flyte</a> enables the seamless integration of PyTorch Elastic Trainer, PEFT, quantization and various optimization techniques into your LLM pipeline for fine-tuning. Additionally, it offers the flexibility to implement strategies such as caching, recovery, checkpointing and running on spot instances. These features are part of the orchestration toolkit, which proves invaluable when optimizing resource allocation to lower costs and manage jobs more efficiently.</p><p>To delve deeper into the advantages offered by orchestrators like Flyte, you can explore further details <a href="https://flyte.org/features">here</a>.</p><p>For inference, various tools like <a href="https://github.com/vllm-project/vllm">vLLM</a>, <a href="https://github.com/OpenNMT/CTranslate2">CTranslate2</a>, <a href="https://docs.ray.io/en/latest/serve/index.html">Ray serve</a> and <a href="https://github.com/huggingface/text-generation-inference">text generation inference</a> can be employed to meet your specific needs.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/63bc83b29094ec80844b6dd5/6526dc7b7cf1df604e4a5c23_35MRswvSORpeJB6VZMfGzoOn85yxbufQWQJgP7klZHsoTvxUZijkv0juf-mwQZGeZ0i1-fc3K-CyVw4KH5GTzj8OikV3AQzweML2Ufr3-AKNXTaAx3FB3N3USM_uGxTftgL97x5a_gYhw-EsDSc_NPs.png" alt=""/></p><figcaption>Comparison of frameworks for LLM inference (<a href="https://betterprogramming.pub/frameworks-for-serving-llms-60b7f7b23407">Source</a>)</figcaption></figure><p>The world of LLMs is constantly evolving. As people venture into this field, we aim to ensure that all relevant and up-to-date information is included in this post. This is an ongoing effort, and we encourage you to share your thoughts and ideas with us on <a href="https://slack.flyte.org/">Slack</a>, as well as your feedback on this post.</p></div></div>
  </body>
</html>
