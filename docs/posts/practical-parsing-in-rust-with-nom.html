<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://naiveai.hashnode.dev/practical-parsing-nom">Original</a>
    <h1>Practical Parsing in Rust with nom</h1>
    
    <div id="readability-page-1" class="page"><div id="post-content-wrapper"><p>If you&#39;re a programmer who&#39;s done some research on CS fundamentals, or
learned them in a college setting, you&#39;ve probably heard of the term
&#34;parser-combinator&#34;.</p>
<p>As a largely self-taught script kiddie, this term - heard in quiet whispers
and brushes with some tutorials every now and then - was scary to me for the
longest time. Parsers in general are associated with even more esoteric words
like &#34;yacc&#34;, &#34;lex&#34;, &#34;tokenisation&#34;, &#34;parse trees&#34;, &#34;analytic grammar&#34;... and too
many more.</p>
<p>There&#39;s really no reason for it to be this way, though. Parsing is a hard
problem, for sure, but it&#39;s also one of the most fundamental things programs
do. Mastering it, or at least its foundational concepts, is a huge step towards
unlocking higher-order levels of thinking about programming in general, because
they&#39;re so widely applicable.</p>
<p>In this article, I want to demonstrate the power of parser-combinators in Rust,
for a real use case that&#39;s not too simple and not too complex. Let me know in
the comments if I succeeded!</p>
<h2 id="heading-motivation">Motivation</h2>
<p>In my particular case, me and a pairing partner at the
<a target="_blank" href="https://www.recurse.com/">Recurse Center</a> named <a target="_blank" href="https://github.com/jeffzh4ng">Jeff
Zhang</a> wanted to make a simple <a target="_blank" href="https://www.bittorrent.org/beps/bep_0003.html">BitTorrent
protocol</a> client. An important
part of this was parsing the torrent file to obtain information on the files to
download, trackers, and other metadata; in a format we&#39;d never heard of called
Bencode. Bencode is a complex enough format that fumbling our way with manual
implementations or regexes didn&#39;t seem like a great idea. I also wanted to
overcome my deep-set fear of parsers without having to go all-in on reading the
<a target="_blank" href="https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools">Dragon Book</a>
or something equally dense. So we found <code>nom</code>, which is a library
that enables anyone to make simple, type-safe parsers in Rust.</p>
<p>Bencode as defined in <a target="_blank" href="https://www.bittorrent.org/beps/bep_0003.html">BEP 0003</a>
consists of two primitive types (numbers and strings) and two composite types
(lists and dictionaries). We can model this easily with an enum corresponding to
each of these types, with self-referential portions in the composite types:</p>
<pre><code><span>#[derive(Debug, PartialEq, Eq, Clone)]</span>
<span>pub</span> <span><span>enum</span> <span>Bencode</span></span> {
    Number(<span>i64</span>),
    ByteString(<span>Vec</span>&lt;<span>u8</span>&gt;),
    List(<span>Vec</span>&lt;Bencode&gt;),
    Dict(BTreeMap&lt;<span>Vec</span>&lt;<span>u8</span>&gt;, Bencode&gt;),
}
</code></pre>
<p>The basic form of a parser using <code>nom</code> is a simple function returning an
<code>IResult</code>, which is either an error or a tuple of the remaining input and the
successfully parsed output. For example, a simple number parser could behave
like so:</p>
<pre><code><span>assert_eq!</span>(parse_num(<span>b&#34;1&#34;</span>), <span>Ok</span>((<span>b&#34;&#34;</span>, <span>1</span>)));
<span>assert_eq!</span>(parse_num(<span>b&#34;1something&#34;</span>), <span>Ok</span>((<span>b&#34;something&#34;</span>, <span>1</span>)));
<span>assert!</span>(parse_num(<span>b&#34;nothing&#34;</span>).is_err())
</code></pre>
<p>In our case, we need to define a signature for our overall parser like this:</p>
<pre><code><span>pub</span> <span><span>fn</span> <span>parse_bencode</span></span>(bencode_bytes: &amp;[<span>u8</span>])
    -&gt; IResult&lt;&amp;[<span>u8</span>], Bencode&gt; {
    todo!()
}
</code></pre>
<p>In <code>nom</code>, parsers are created using combinations of other parsers. In our
case, we can create four separate parsers for each of the types and combine
them together easily, as we&#39;ll show later. <code>nom</code> also has its own primitive
combinators so we don&#39;t have to rewrite common logic ourselves. You do
need to import these from their respective modules, but for the sake of
simplicity I&#39;ll be leaving out the imports. You can use the search in the <a target="_blank" href="https://docs.rs/nom/latest/nom"><code>nom</code>
docs</a> to find them.</p>
<h2 id="heading-numbers">Numbers</h2>
<p>First, we&#39;ll implement the simplest parser: numbers. Bencode numbers are
simply numbers wrapped in <code>i</code> and <code>e</code> on either end. For instance:</p>
<pre><code><span>&#34;i3e&#34;</span> 
<span>&#34;i-3e&#34;</span> 
<span>&#34;i10e&#34;</span> 
<span>&#34;i2562e&#34;</span> 
</code></pre>
<pre><code><span><span>fn</span> <span>parse_number</span></span>(bencode_bytes: &amp;[<span>u8</span>])
    -&gt; IResult&lt;&amp;[<span>u8</span>], <span>i64</span>&gt; {
    
    
    
    
    delimited(
        
        
        tag(<span>&#34;i&#34;</span>),
        
        
        
        
        map_res(
            
            
            
            
            is_not(<span>&#34;e&#34;</span>),
            
            
            
            
            
            
            |bytes| <span>String</span>::from_utf8_lossy(bytes).parse::&lt;<span>i64</span>&gt;()
        ),
        tag(<span>&#34;e&#34;</span>)
    )(bencode_bytes)
}
</code></pre>
<p>The key thing to spot here is that since functions are first-class values in
Rust, all of <code>nom</code>&#39;s combinators are in fact functions that return functions:
see how at the very end we&#39;re passing <code>bencode_bytes</code> to the function that
<code>delimited</code> returns. Many of them also <em>take</em> functions as arguments. This makes
them very straightforward to compose and the code much better at expressing
its underlying semantics.</p>
<h2 id="heading-strings">Strings</h2>
<p>Bencode strings are a number followed by a colon, then characters equal to
that number. For instance:</p>
<pre><code><span>&#34;4:spam&#34;</span> 
<span>&#34;5:hello&#34;</span> 
<span>&#34;10:technology&#34;</span> 
<span>&#34;2:hello&#34;</span> 
</code></pre>
<p>The string parser is only slightly more complex than the number parser, since
there isn&#39;t a delimiter for them as there is for numbers.</p>
<pre><code><span><span>fn</span> <span>parse_string</span></span>(bencode_bytes: &amp;[<span>u8</span>])
    -&gt; IResult&lt;&amp;[<span>u8</span>], <span>Vec</span>&lt;<span>u8</span>&gt;&gt; {
    
    
    
    
    
    
    <span>let</span> (remaining, num_characters) = terminated(
        map_res(
            digit1,
            |digits| <span>String</span>::from_utf8_lossy(digits).parse::&lt;<span>usize</span>&gt;()
        ),
        tag(<span>&#34;:&#34;</span>)
    )(bencode_bytes)?;

    
    
    
    map(
        
        
        take(num_characters),
        |bytestring: &amp;[<span>u8</span>]| bytestring.to_vec()
    )(remaining)
}
</code></pre>
<p>Notice how we use two separate steps here and return only the results of our
second step, since we don&#39;t care about the length of the string once we&#39;re done
parsing it.</p>
<h2 id="heading-lists">Lists</h2>
<p>Lists are simply a series of Bencode values in succession, delimited
by <code>l</code> and <code>e</code>. For example:</p>
<pre><code><span>&#34;l 4:spam 5:hello i3e e&#34;</span> 

<span>&#34;l 2:he i3e l i4e i5e e e&#34;</span> 
</code></pre>
<p>I&#39;ve separated with spaces to make this clearer, though real Bencode would not
do that.</p>
<p>I initially thought this would be very difficult to implement correctly, since
lists can nest arbitrarily into other lists and dictionaries, but once again,
the simple nature of parsers, and the tools <code>nom</code> has to combine them, save us
in a major way. This is the real payoff for parser-combinators, folks!</p>
<pre><code><span><span>fn</span> <span>parse_list</span></span>(bencode_bytes: &amp;[<span>u8</span>])
    -&gt; IResult&lt;&amp;[<span>u8</span>], <span>Vec</span>&lt;Bencode&gt;&gt; {
    delimited(
        tag(<span>&#34;l&#34;</span>),
        
        
        
        
        
        
        
        
        
        many0(parse_bencode),
        tag(<span>&#34;e&#34;</span>)
    )(bencode_bytes)
}
</code></pre>
<h2 id="heading-dictionaries">Dictionaries</h2>
<p>Dictionaries are delimited by <code>d</code> and <code>e</code>, and then contain a string
followed by a value, in succession. For instance:</p>
<pre><code><span>&#34;d 3:cow 3:moo 4:spam 4:eggs e&#34;</span> 
<span>&#34;d 4:spam l 1:a 1:b e e&#34;</span> 

<span>&#34;d 4:spam d 3:cow l 1:a 1:b e e e&#34;</span> 
</code></pre>
<p>Again, I&#39;ve separated everything with spaces for clarity only.</p>
<p>Even these beasts turn out to be astonishingly simple to implement, and more
importantly, to read, because of our composition superpowers!</p>
<pre><code><span><span>fn</span> <span>parse_dictionary</span></span>(bencode_bytes: &amp;[<span>u8</span>])
    -&gt; IResult&lt;&amp;[<span>u8</span>], BTreeMap&lt;<span>Vec</span>&lt;<span>u8</span>&gt;, Bencode&gt;&gt; {
    map(
        delimited(
            tag(<span>&#34;d&#34;</span>),
            many0(
                
                
                
                
                pair(parse_string, parse_bencode)
            ),
            tag(<span>&#34;e&#34;</span>)
        ),
        
        
        
        |elements| elements.into_iter().collect()
    )(bencode_bytes)
}
</code></pre>
<h2 id="heading-putting-it-all-together">Putting It All Together</h2>
<p>Finally, we need to fill in the signature of our <code>parse_bencode</code> public-facing
method by combining together all these individual parsers for our types. This
also works beautifully thanks to the <code>alt</code> combinator.</p>
<pre><code><span>pub</span> <span><span>fn</span> <span>parse_bencode</span></span>(bencode_bytes: &amp;[<span>u8</span>])
    -&gt; IResult&lt;&amp;[<span>u8</span>], Bencode&gt; {
    
    
    
    alt((
        
        
        
        map(parse_number, Bencode::Number),
        map(parse_string, Bencode::ByteString),
        map(parse_list, Bencode::List),
        map(parse_dictionary, Bencode::Dict),
    ))(bencode_bytes)
}
</code></pre>
<p>Just like that, we&#39;ve got a easy-to-understand, fully type-safe parser for
Bencode, in a tad less than 100 lines of code. It&#39;s a little out of scope for
this article, but using
<a target="_blank" href="https://docs.rs/nom/latest/nom/error/struct.VerboseError.html"><code>nom</code>&#39;s VerboseError interface</a>,
you can also very easily extend this parser to keep track of where exactly its
errors originate and display user-friendly error messages. Perhaps a topic
for a part 2 - let me know if you&#39;re interested.</p>
<p>You can find the full code 
<a target="_blank" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=38599ebd80b70497f555f141bfea9af3">in the Rust Playground</a>,
along with an extensive litany of tests to prove its correctness.</p>
<p>Thanks for reading this long! I hope you came to appreciate the coolness of
<code>nom</code> and parser-combinators in general the same way I did. If you have any
feedback at all, I&#39;d appreciate leaving some in the comments. If you learned
something from this article, I&#39;d appreciate that, too!</p>
<p><em>Cover image courtesy of <a target="_blank" href="https://xkcd.com/1171/">XKCD</a>.</em></p>
</div></div>
  </body>
</html>
