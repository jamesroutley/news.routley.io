<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://awkravchuk.itch.io/cl-fast-ecs/devlog/622054/gamedev-in-lisp-part-1-ecs-and-metalinguistic-abstraction">Original</a>
    <h1>Gamedev in Lisp. Part 1: ECS and Metalinguistic Abstraction</h1>
    
    <div id="readability-page-1" class="page"><div><section id="object_text_widget_7724120"><p>In this series of tutorials, we will delve into creating simple 2D games in Common Lisp. The result of the first part will be a development environment setup and a basic simulation displaying a 2D scene with a large number of physical objects. It is assumed that the reader is familiar with some high-level programming language, has a general idea of how graphics are displayed on a computer screen, and is interested in expanding their horizons.</p>
<p>Common Lisp is a programming language with a rich history of providing effective tools for developing complex, interactive applications such as video games. This series of tutorials aims to illustrate a range of CL capabilities that fit seamlessly into the context of game development. A short overview of these capabilities and the unique features of Common Lisp is provided in Yukari Hafner‚Äôs article <a href="https://github.com/Shinmera/talks/blob/master/gic2021-highly-dynamic/paper.pdf" referrerpolicy="origin" rel="nofollow noopener">‚ÄúUsing a Highly Dynamic Language for Development‚Äù</a>.</p>
<p>Many features first introduced in Lisp, such as the <code>if/then/else</code> conditional construct, functions as first class objects, garbage collection, and <a href="http://www.paulgraham.com/diff.html" referrerpolicy="origin" rel="nofollow noopener">others</a> have long since made their way into mainstream programming languages. However, one unique feature that we‚Äôll look at today is <em>metalinguistic abstraction</em>.</p>
<h2>Metalinguistic abstraction</h2>
<p>To grok this concept, let‚Äôs turn to the well-known fundamental textbook <a href="https://sarabander.github.io/sicp/html/index.xhtml" referrerpolicy="origin" rel="nofollow noopener">‚ÄúStructure and Interpretation of Computer Programs‚Äù</a>:</p>
<blockquote>
<p>However, as we confront increasingly complex problems, we will find that Lisp, or indeed any fixed programming language, is not sufficient for our needs. We must constantly turn to new languages in order to express our ideas more effectively. Establishing new languages is a powerful strategy for controlling complexity in engineering design; we can often enhance our ability to deal with a complex problem by adopting a new language that enables us to describe (and hence to think about) the problem in a different way, using primitives, means of combination, and means of abstraction that are particularly well suited to the problem at hand.</p>
</blockquote>
<blockquote>
<p>Metalinguistic abstraction ¬≠‚Äî establishing new languages ‚Äî plays an important role in all branches of engineering design.</p>
</blockquote>
<blockquote>
<p>To appreciate this point is to change our images of ourselves as programmers. We come to see ourselves as designers of languages, rather than only users of languages designed by others.</p>
</blockquote>
<p>So, an important mechanism provided by virtually any Lisp dialect, including of course one of the most powerful of them, Common Lisp, is the ability to create your own language constructs within the language itself. This concept is also known as DSL (Domain Specific Languages), but only Lisp dialects have it incredibly tightly integrated into their core. In most of them, the mechanism of metalinguistic abstraction is built around so-called <em>macros</em>, special functions defined by the programmer, which are called at compile time and return small fragments of program code for the compiler to substitute wherever they occur. The distinctive feature of Lisps is that the code is essentially a regular nested list, which makes it easy and efficient to generate and process program code fragments.</p>
<p>There are numerous of different ways to creatively use and abuse this feature. I‚Äôd like to introduce the <a href="https://awkravchuk.itch.io/cl-fast-ecs">cl-fast-ecs</a> macro library I‚Äôve created, which provides a mini-language for describing game objects and their processing rules using the Entity-Component-System pattern often used in game development.</p>
<h2>Entity Component System</h2>
<p>ECS is a rather straightforward pattern for organizing data storage and processing in game applications that achieves two important conceptual goals at once:</p>
<ol>
<li>Flexibility in defining and modifying the structure of game objects.</li>
<li>Performance gains through efficient utilization of CPU caches.</li>
</ol>
<p>Flexibility, interactivity, and the ability to redefine program behavior on the fly are cornerstones of most Lisp-like languages. We will revisit this issue later, but for now let‚Äôs focus a bit more on the second goal, which is often presented as the main advantage of the ECS pattern. Let‚Äôs start from the beginning.</p>
<p>In the Von Neumann architecture currently used in most computing devices, there is a fundamental problem called the ‚ÄúVon Neumann bottleneck‚Äù. Its essence is that no matter how fast the CPU processes data, its processing speed is limited by memory performance. Moreover, the performance of the ‚ÄúCPU-memory‚Äù system is limited by the bandwidth of the bus through which these nodes exchange information, and this value cannot grow indefinitely or at least at the same rate as the CPU performance grows. The problem is vividly illustrated by the following graph:</p>
<p><img src="https://img.itch.zone/aW1nLzEzNzMyODk2LmpwZw==/original/kMHmtU.jpg" alt="" loading="lazy"/>
<em>(source: <a href="https://aras-p.info/texts/files/2018Academy%20-%20ECS-DoD.pdf" referrerpolicy="origin" rel="nofollow noopener">Aras Pranckeviƒçius. ‚ÄúEntity Component Systems &amp; Data Oriented Design‚Äù</a>)</em></p>
<p>The curve labeled ‚ÄúProcessor‚Äù represents the number of memory requests the CPU can make per unit of time; the curve labeled ‚ÄúMemory‚Äù represents the number of requests RAM can process per unit of time (both values are normalized to the average values in 1980). Even superficially analyzing the graph, one can come to a disappointing conclusion ‚Äî most of the time the CPU is idle waiting for data from memory, and over time the gap between CPU and memory performance is getting larger and larger.</p>
<p>Already in the early 1990s, with the release of the Intel 486, a common solution to this problem in consumer grade hardware was the cache located on the same chip as the processor. The cache is a small but extremely fast memory that stores the data requested by the processor earlier, thus reducing the duration of subsequent requests for the same data by retrieving them from the cache instead of the slower main memory. Toward the end of the nineties, the cache started to be divided into several levels (L1, L2, etc.), each subsequent level having a larger capacity, but also a higher latency, although still significantly lower than the latency of access to the main RAM. Typical memory interaction timings of desktop hardware as of 2020 are as follows:</p>
<ul>
<li>processor register: &lt;1 ns</li>
<li>L1 cache: 1 ns</li>
<li>L2 cache: 3 ns</li>
<li>L3 cache: 13 ns</li>
<li>RAM: 100 ns</li>
</ul>
<p><em>(source: <a href="https://cloud.githubusercontent.com/assets/1489514/19324275/be41885c-908e-11e6-95a2-68fa75333c38.jpg" referrerpolicy="origin" rel="nofollow noopener">dzone.com</a>)</em></p>
<p>CPU cache helps a lot in optimizing sequential access to memory cells. Even when the processor requests for a single byte from RAM, an entire <em>cache line</em> is returned to it and stored in the cache. On modern x86 architectures, a cache line is 64 bytes (512 bits) long.
So, if we sequentially process elements of an array, for example, single precision floating point numbers (32 bit <code>float</code>s), the first access to an element not only retrieves the requested element but also (512¬†‚àí¬†32)¬†‚àï¬†32¬†=¬†15 subsequent elements. For the next 15 iterations of the loop, accessing the element will take 1 ns instead of 100 ns. Thus, thanks to the cache, our loop operates approximately 16¬†√ó¬†100¬†‚àï¬†(100¬†+¬†15¬†√ó¬†1)¬†‚âà¬†14 times faster regardless of the array‚Äôs length! This example illustrates how important it is from the performance point of view to process data in such a way that it remains ‚Äúhot‚Äù in cache.</p>
<p>To understand how the ECS architectural pattern contributes to cache utilization, let‚Äôs examine its key parts:</p>
<ul>
<li>entity - a composite game object;</li>
<li>component - data describing some logical facet of an object;</li>
<li>system - code that processes objects of a specific structure.</li>
</ul>
<p>Let‚Äôs first deal with entities and components with a concrete example:</p>
<p><img src="https://img.itch.zone/aW1nLzEzNzMzMTYwLnBuZw==/original/fZ1tL%2F.png" alt="" loading="lazy"/>
<em>(source: <a href="https://cowboyprogramming.com/2007/01/05/evolve-your-heirachy" referrerpolicy="origin" rel="nofollow noopener">Mick West. ‚ÄúCowboy Programming. Evolve Your Hierarchy‚Äù</a>)</em></p>
<p>Horizontally, the components <code>Position</code>, <code>Movement</code>, <code>Render</code> and so on are represented by colored rectangles. Note that each of these components may contain several data fields, for example, <code>Position</code> and <code>Movement</code> will almost certainly contain <code>x</code> and <code>y</code> fields.
Vertically, the entities are labeled in parentheses ‚Äî <code>Alien</code>, <code>Player</code>, etc. Each entity has a specific set of components. More importantly, we can add or remove some components to any entity ‚Äúon the fly‚Äù, in runtime, to change its structure and, consequently, its behavior and status in the game world, all without recompiling the game code! This achieves the first conceptual goal of ECS mentioned earlier ‚Äî flexibility of the structure of game objects.</p>
<p>The illustration above, if you squint a little, looks a lot like an ordinary Excel spreadsheet. In essence, that‚Äôs what ECS is üòä</p>
<p><img src="https://img.itch.zone/aW1nLzEzNzMzMjc4LnBuZw==/original/JQOTwc.png" alt="" loading="lazy"/>
<em>(source: <a href="https://youtu.be/lt4eL4RSx7k" referrerpolicy="origin" rel="nofollow noopener">Maxim Zaks - Entity Component System - A Different Approach to Game / Application Development</a>)</em></p>
<p>From a conceptual perspective, entities and components form the rows and columns of a table whose cells hold the component data or no values. This representation of game data allows us to pull off a number of tricks related to its memory layout. In turn, these tricks enable the most efficient utilization of the CPU cache when processing data, similar to the example mentioned earlier with a loop over <code>float</code>s, and thus squeeze maximum performance out of the ‚ÄúCPU-memory‚Äù system.</p>
<p>The processing of game data when using the ECS pattern is delegated to the so-called systems ‚Äî loops that iterate over all entities that have certain components and perform operations on these entities in the same uniform way. For example, a system that calculates the movement of objects will process entities with <code>Position</code> and <code>Movement</code> components, a system that draws objects on the screen will be interested in entities with <code>Position</code> and <code>Render</code> components, and so on. This can be illustrated by the following example:</p>
<p><img src="https://img.itch.zone/aW1nLzEzNzMzNDA2LnBuZw==/original/j%2FRGUX.png" alt="" loading="lazy"/>
<em>(<a href="https://habr.com/ru/companies/pixonic/articles/413729" referrerpolicy="origin" rel="nofollow noopener">source</a>)</em></p>
<p>In this example, the <code>MoveSystem</code> is essentially a loop that sequentially traverses all entities with <code>Transform</code> and <code>Movement</code> components and calculates new position values for each entity according to its velocity. Most implementations of the ECS pattern are structured so that the component field data (e.g., the <code>x</code> and <code>y</code> fields of the <code>Movement</code> component) are stored in flat one-dimensional arrays, and the entities are basically integer indices in those arrays. Systems, in turn, simply iterate over arrays with component data, thus achieving spatial cache locality, just like in the <code>float</code> loop example mentioned earlier.</p>
<p>This concludes the brief overview of the Entity-Component-System architectural pattern. For a deeper dive into the topic, the following resources are recommended:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Entity_component_system" referrerpolicy="origin" rel="nofollow noopener">Entity component system</a>: Wikipedia description of the pattern.</li>
<li><a href="https://github.com/SanderMertens/ecs-faq" referrerpolicy="origin" rel="nofollow noopener">ECS FAQ</a>: frequently asked questions about ECS from Sander Mertens, author of the Flecs C framework.</li>
<li><a href="https://github.com/jslee02/awesome-entity-component-system" referrerpolicy="origin" rel="nofollow noopener">awesome-entity-component-system</a>: a collection of ECS libraries and resources.</li>
<li><a href="https://en.wikipedia.org/wiki/CPU_cache" referrerpolicy="origin" rel="nofollow noopener">CPU cache</a>: a fairly detailed Wikipedia article on processor caches.</li>
<li><a href="https://people.freebsd.org/~lstewart/articles/cpumemory.pdf" referrerpolicy="origin" rel="nofollow noopener">Ulrich Drepper, What Every Programmer Should Know About Memory</a>: A comprehensive work by one of the GNU libc developers, Ulrich Drepper, on memory structure and performance optimization.</li>
</ul>
<p>Now we are ready to use the <code>cl-fast-ecs</code> library to create a minimal game project with ECS architecture. But before that, we need a configured Common Lisp development environment.</p>
<h2>Development environment</h2>
<p>The first thing we need to build a development environment is a compiler, and the universally recognized leader among open-source Common Lisp compilers is <a href="https://sbcl.org" referrerpolicy="origin" rel="nofollow noopener">Steel Bank Common Lisp</a>, aka SBCL. You can install it using your package manager with a command in the terminal like:</p>
<pre><code># for Ubuntu/Debian and their derivatives:
sudo apt-get install sbcl

# for Fedora:
sudo dnf install sbcl

# for MacOS with Homebrew:
brew install sbcl
</code></pre>
<p>‚Ä¶or download a ready-made installer from the <a href="https://sbcl.org/platform-table.html" referrerpolicy="origin" rel="nofollow noopener">official website</a> (be sure to choose the CPU architecture you need; in most cases, it‚Äôs AMD64).</p>
<p>After installing the compiler, you will need to install <a href="https://quicklisp.org" referrerpolicy="origin" rel="nofollow noopener">Quicklisp</a>, which is the de facto standard package manager for Common Lisp. To do this, download the installation file at <a href="https://beta.quicklisp.org/quicklisp.lisp" referrerpolicy="origin" rel="nofollow noopener">https://beta.quicklisp.org/quicklisp.lisp</a> , and then load it by running SBCL in the directory containing the file with the following command:</p>
<pre><code>sbcl --load quicklisp.lisp
</code></pre>
<p>After loading this file, SBCL will enter the so-called REPL (Read-Eval-Print¬†Loop) mode, in which it will display an input prompt consisting of a single asterisk and wait for you to input the code to be executed, and after executing it and displaying the result, it will go back to waiting for input. Let‚Äôs give SBCL three code fragments to execute: to install Quicklisp, to connect an additional LuckyLambda repository with the latest versions of gamedev packages, and to add Quicklisp support to the SBCL config:</p>
<pre><code>(quicklisp-quickstart:install)

(ql-dist:install-dist &#34;<a href="http://dist.luckylambda.technology/releases/lucky-lambda.txt&#34;" referrerpolicy="origin" rel="nofollow noopener">http://dist.luckylambda.technology/releases/lucky-lambda.txt&#34;</a> :prompt nil)

(ql:add-to-init-file)
</code></pre>
<p>After running the last command and pressing Enter as prompted, you can exit SBCL by pressing Ctrl-D or typing <code>(exit)</code> at the REPL prompt.</p>
<p><img src="https://img.itch.zone/aW1nLzEzNzMzNjMyLnBuZw==/original/TryBEO.png" alt="" loading="lazy"/></p>
<p>To write Common Lisp code with comfort and still have the ability to interact with REPL, you can choose your favorite IDE:</p>
<ul>
<li><a href="https://vscodium.com" referrerpolicy="origin" rel="nofollow noopener">VScode</a> with the <a href="https://marketplace.visualstudio.com/items?itemName=rheller.alive" referrerpolicy="origin" rel="nofollow noopener">Alive</a> extension installed; see the <a href="https://lispcookbook.github.io/cl-cookbook/vscode-alive.html" referrerpolicy="origin" rel="nofollow noopener">Common Lisp cookbook guide</a> to using it. To make it work correctly with the SBCL we‚Äôve installed, it‚Äôs necessary to install a few additional packages by executing the following code line in the SBCL REPL:
<pre><code>(ql:quickload &#39;(:bordeaux-threads :cl-json :flexi-streams :usocket)))
</code></pre>
</li>
<li><a href="https://jetbrains.com/idea" referrerpolicy="origin" rel="nofollow noopener">IntelliJ IDEA</a> with the <a href="https://plugins.jetbrains.com/plugin/21132-slt" referrerpolicy="origin" rel="nofollow noopener">SLT</a> plugin installed; see the <a href="https://github.com/Enerccio/SLT/wiki/User-Guide" referrerpolicy="origin" rel="nofollow noopener">user guide</a> for it.</li>
<li><a href="https://sublimetext.com" referrerpolicy="origin" rel="nofollow noopener">Sublime Text</a> with the <a href="https://github.com/s-clerc/slyblime" referrerpolicy="origin" rel="nofollow noopener">Slyblime</a> plugin installed (unfortunately, the plugin does not work on Windows at the moment).</li>
<li>For <a href="https://www.vim.org" referrerpolicy="origin" rel="nofollow noopener">Vim</a> and <a href="https://neovim.io" referrerpolicy="origin" rel="nofollow noopener">Neovim</a>, there is <a href="https://github.com/vlime/vlime" referrerpolicy="origin" rel="nofollow noopener">Vlime</a> plugin.</li>
<li>However, the unrivaled leader as an IDE for Lisp-like languages is <a href="https://gnu.org/software/emacs" referrerpolicy="origin" rel="nofollow noopener">Emacs</a>. If you‚Äôre already an experienced Emacs user, you can simply install the <a href="https://github.com/joaotavora/sly" referrerpolicy="origin" rel="nofollow noopener">Sly</a> plugin. If you don‚Äôt want to bother with configuring this environment, you can use the ready-made cross-platform Emacs build customized for Common Lisp called <a href="https://portacle.github.io" referrerpolicy="origin" rel="nofollow noopener">Portacle</a>, and read the <a href="https://lispcookbook.github.io/cl-cookbook/emacs-ide.html" referrerpolicy="origin" rel="nofollow noopener">Emacs introduction from the Common Lisp cookbook</a>. In order for our project to work in Portacle, you‚Äôll need to run the following code in its REPL:
<pre><code>(ql-dist:install-dist &#34;<a href="http://dist.luckylambda.technology/releases/lucky-lambda.txt&#34;" referrerpolicy="origin" rel="nofollow noopener">http://dist.luckylambda.technology/releases/lucky-lambda.txt&#34;</a> :prompt nil)
(ql:quickload :deploy)
</code></pre>
</li>
</ul>
<p>Besides, for such an exotic OS as Windows, you‚Äôll need a tool like <a href="https://msys2.org" referrerpolicy="origin" rel="nofollow noopener">MSYS2</a> for proper development.</p>
<h2>Common Lisp game project template</h2>
<p>To start our project, let‚Äôs use the <a href="https://github.com/lockie/cookiecutter-lisp-game" referrerpolicy="origin" rel="nofollow noopener"><code>cookiecutter-lisp-game</code></a> template. For this you‚Äôll need the <code>cookiecutter</code> Python tool installed. You can find installation instructions <a href="https://cookiecutter.readthedocs.io/en/stable/installation.html" referrerpolicy="origin" rel="nofollow noopener">here</a>. Let‚Äôs run the following command in the terminal:</p>
<pre><code>cookiecutter gh:lockie/cookiecutter-lisp-game
</code></pre>
<p><code>cookiecutter</code> will prompt you with questions about the project you‚Äôre creating. Answer them in the following manner:</p>
<pre><code>full_name (Your Name): Alyssa P. Hacker
email (your@e.mail): alyssa@domain.tld
project_name (The Game): ECS Tutorial 1
project_slug (ecs-tutorial-1):
project_short_description (A simple game.): cl-fast-ecs framework tutorial.
version (0.0.1):
Select backend
    1 - liballegro
    2 - raylib
    3 - SDL2
    Choose from [1/2/3] (1): 1
</code></pre>
<p><code>cookiecutter</code> will create a project skeleton in the <code>ecs-tutorial-1</code> directory. You‚Äôll need to add this directory to your local Quicklisp package repository with the following command:</p>
<pre><code># for UNIX-like OS:
ln -s $(pwd)/ecs-tutorial-1 $HOME/quicklisp/local-projects/

# for Windows:
mklink /j %USERPROFILE%\quicklisp\local-projects\ecs-tutorial-1 ecs-tutorial-1

# for Windows when using Portacle:
mklink /j %USERPROFILE%\portacle\projects\ecs-tutorial-1 ecs-tutorial-1
</code></pre>
<p>As a backend, we chose the default option #1, <a href="https://liballeg.github.io" referrerpolicy="origin" rel="nofollow noopener">liballegro</a>, because it‚Äôs currently the most hassle-free graphics framework for use in Common Lisp. You‚Äôll also need to install it, either with the terminal command like</p>
<pre><code># for Ubuntu/Debian and their derivatives:
sudo apt-get install liballegro-acodec5-dev \
    liballegro-audio5-dev liballegro-dialog5-dev \
    liballegro-image5-dev liballegro-physfs5-dev \
    liballegro-ttf5-dev liballegro-video5-dev

# for Fedora:
sudo dnf install allegro5-addon-acodec-devel \
    allegro5-addon-audio-devel allegro5-addon-dialog-devel \
    allegro5-addon-image-devel allegro5-addon-physfs-devel \
    allegro5-addon-ttf-devel allegro5-addon-video-devel

# for MacOS with Homebrew:
brew install allegro

# for Windows with MSYS2:
pacman -S mingw-w64-x86_64-allegro
</code></pre>
<p>‚Ä¶or by downloading ready-made binaries from the <a href="https://liballeg.github.io/download.html" referrerpolicy="origin" rel="nofollow noopener">official website</a>. Additionally, because of the programming language <code>liballegro</code> is written in, which is pure C, you‚Äôll need a working environment to compile the C code:</p>
<pre><code># for Ubuntu/Debian and their derivatives:
sudo apt-get install gcc pkg-config make

# for Fedora:
sudo dnf install gcc pkg-config make redhat-rpm-config

# for MacOS with Homebrew:
brew install pkg-config

# for Windows with MSYS2:
pacman -S mingw-w64-x86_64-gcc \
    mingw-w64-x86_64-pkg-config make
</code></pre>
<p>For Windows with MSYS2, you‚Äôll also need to set the <code>MSYS2_PATH_TYPE</code> environment variable to the value <code>inherit</code> and add the following paths to the beginning of the <code>PATH</code> environment variable: <code>C:\msys64\usr\bin;C:\msys64\mingw64\bin;</code>
Additionally, you‚Äôll need the <code>libffi</code> library for Common Lisp to interact with C code. You can install it with a command like this:</p>
<pre><code># for Ubuntu/Debian and their derivatives:
sudo apt-get install libffi-dev

# for Fedora:
sudo dnf install libffi-devel

# for MacOS with Homebrew:
brew install libffi

# for Windows with MSYS2:
pacman -S mingw-w64-x86_64-libffi
</code></pre>
<p>Finally, after all these preparations, you can run the project by:</p>
<ol>
<li>Navigating to the <code>src</code> subdirectory of the project (this is <strong>important</strong> so that the game code can find all the resource files it needs, such as fonts, images, etc.).</li>
<li>Launching <code>sbcl</code> within this directory.</li>
<li>Loading the project package with a code like
<pre><code>(ql:quickload :ecs-tutorial-1)
</code></pre>
</li>
<li>After waiting for the input prompt in the form of an asterisk after loading, call the project entry point, the <code>main</code> function, by executing the following code: <code>(ecs-tutorial-1:main)</code></li>
</ol>
<p>If everything goes smoothly, you‚Äôll see an empty window with an FPS counter:</p>
<p><img src="https://img.itch.zone/aW1nLzEzNzM0MDkzLnBuZw==/original/pELjjl.png" alt="" loading="lazy"/></p>
<p>To run the project from an IDE, you may need to manually set the working directory by running the code like <code>(uiop:chdir &#34;/path/to/src&#34;)</code> in IDE REPL. On Windows, make sure to use forward slashes, <code>/</code>, instead of backslashes in the <code>src</code> directory path.</p>
<p>Now we can proceed to add the ‚Äúmeat‚Äù of components and systems to the skeleton.</p>
<h2>Adding components and systems</h2>
<p>First and foremost, if you‚Äôve never dealt with Common Lisp or other Lisp-family languages, I recommend referring to a brief guide, <a href="https://learnxinyminutes.com/docs/common-lisp" referrerpolicy="origin" rel="nofollow noopener">Learn X in Y minutes, Where X=Common Lisp</a> (studying its first six sections should be sufficient). For a deeper dive, <a href="https://gigamonkeys.com/book" referrerpolicy="origin" rel="nofollow noopener">Practical Common Lisp</a> is an excellent resource.</p>
<p>The first thing we need to do is to connect the <code>cl-fast-ecs</code> library to our project. To do this, open the <code>ecs-tutorial-1.asd</code> file in the root directory of the project. The <code>.asd</code> extension is not the result of a random chord on the keyboard; it stands for ‚ÄúAnother System Definition‚Äù, and it‚Äôs the de facto standard for describing Common Lisp packages. In this file, you need to add an element <code>#:cl-fast-ecs</code> to the list that is the value of the keyword parameter <code>:depends-on</code>, so that it looks like this:</p>
<pre><code>  ;; ...
  :license &#34;MIT&#34;
  :depends-on (#:alexandria
               #:cl-fast-ecs
               #:cl-liballegro
               #:cl-liballegro-nuklear
               #:livesupport)
  :serial t
  ;; ...
</code></pre>
<p>After that, you should (re)load the package with the future game in REPL using the familiar command <code>(ql:quickload :ecs-tutorial-1)</code>. Now we are ready to dive into the source code.</p>
<p>So, let‚Äôs open the <code>src/main.lisp</code> file. Don‚Äôt be frightened by the code inside the form starting with the symbols <code>cffi:defcallback %main</code>. This is a standard boilerplate, similar to what can be found in any program using <code>liballegro</code>. For instance, you can find a similar boilerplate in the <a href="https://github.com/liballeg/allegro5/blob/5.2.8.0/demos/skater/src/framework.c#L68" referrerpolicy="origin" rel="nofollow noopener">code</a> of the ‚Äúskater‚Äù <a href="https://liballeg.github.io/examples_demos.html" referrerpolicy="origin" rel="nofollow noopener">demo</a> from the official library website. This boilerplate deals with initialization and finalization of <code>liballegro</code> and its addons necessary for the game to function, error handling and rendering of the FPS counter you‚Äôve already seen. However, its central part is the main game loop, which sequentially draws the game frames on the screen. You can read more about what the main game loop is <a href="https://gameprogrammingpatterns.com/game-loop.html" referrerpolicy="origin" rel="nofollow noopener">here</a>. We won‚Äôt interfere with the <code>%main</code> callback code. Instead, we‚Äôll extend the <code>init</code> and <code>update</code> functions which it calls to initialize the game logic and update the game‚Äôs internal state on each frame respectively.</p>
<p>Let‚Äôs start editing the code by initializing the <code>cl-fast-ecs</code> framework. If we try to use its functions without initialization, for example, run the code for creating a new entity <code>(ecs:make-entity)</code> in REPL right now (try it!), we will get an error like <code>The variable CL-FAST-ECS:*STORAGE* is unbound</code>. It happens not because the author forgot to define the variable <code>*storage*</code> in the framework code, but because it is not <em>bound</em> to any value yet. To bind it to a newly created ECS data storage object, you need to call the <a href="https://lockie.gitlab.io/cl-fast-ecs/#FUNCTION%20CL-FAST-ECS%3ABIND-STORAGE" referrerpolicy="origin" rel="nofollow noopener"><code>bind-storage</code></a> function. The most logical place to do this in the game code is the <code>init</code> function:</p>
<pre><code>(defun init ()
  (ecs:bind-storage)))
</code></pre>
<p>Having written this code, we must turn it into a part of our program. Here an essential aspect of Lisp we discussed earlier, which is rare in other mainstream languages, comes into play: interactivity. It‚Äôs not necessary to close the currently running SBCL process. Just put the cursor on the function code and use the keyboard combination of your IDE that sends the code to the running REPL. For example, in Emacs it is double-press of Ctrl-C (or <code>C-c C-c</code> in its lingo). In other IDEs the corresponding context menu item will be called ‚Äú<em>Inline eval</em>‚Äù, ‚Äú<em>Evaluate This S-expression</em>‚Äù, ‚Äú<em>Evaluate form at cursor</em>‚Äù or similar. Furthermore, when using the <a href="https://github.com/cbaggers/livesupport" referrerpolicy="origin" rel="nofollow noopener">livesupport</a> library (which is included in our template), you can redefine code fragments or entire functions not only when Lisp awaits your input, but at any moment of program execution. This feature opens up truly limitless possibilities for code modification and debugging ‚Äúon the fly‚Äù. There is a well-known <a href="https://corecursive.com/lisp-in-space-with-ron-garret" referrerpolicy="origin" rel="nofollow noopener">example</a> of how Lisp interactivity was used to bring to life a spacecraft 150 million miles away from the Earth.</p>
<p><img src="https://img.itch.zone/aW1nLzEzNzM0NjYxLnBuZw==/original/pSQGN5.png" alt="" loading="lazy"/></p>
<p>Now we‚Äôre ready to define the components that our game simulation will use. We‚Äôll be modeling the Newtonian physics of a large number of celestial bodies. To do this, we will certainly need components for the position and speed of objects structured in a similar way. Let‚Äôs add the following code that uses the <a href="https://lockie.gitlab.io/cl-fast-ecs/#MACRO-FUNCTION%20CL-FAST-ECS%3ADEFINE-COMPONENT" referrerpolicy="origin" rel="nofollow noopener"><code>define-component</code></a> macro from the <code>cl-fast-ecs</code> framework just before the <code>init</code> function at the top level:</p>
<pre><code>(ecs:define-component position
  &#34;Determines the location of the object, in pixels.&#34;
  (x 0.0 :type single-float :documentation &#34;X coordinate&#34;)
  (y 0.0 :type single-float :documentation &#34;Y coordinate&#34;))

(ecs:define-component speed
  &#34;Determines the speed of the object, in pixels/second.&#34;
  (x 0.0 :type single-float :documentation &#34;X coordinate&#34;)
  (y 0.0 :type single-float :documentation &#34;Y coordinate&#34;))
</code></pre>
<p>Each call to this macro takes as input the name of a component, an optional documentation string, and a set of component fields, or <em>slots</em> as <a href="https://lispcookbook.github.io/cl-cookbook/data-structures.html#structures" referrerpolicy="origin" rel="nofollow noopener">structure</a> fields are commonly called in CL. For each slot, just like for structure slots, we specify in parentheses:</p>
<ul>
<li>name,</li>
<li>default value,</li>
<li>keyword parameter <code>:type</code> defining the type of the field,</li>
<li>optional keyword parameter <code>:documentation</code> adding a documentation string to the slot.</li>
</ul>
<p>The <code>define-component</code> call contains a minimum of redundant information and is very straightforward. However, in actuality the macro generates quite a substantial amount of code to support component operations. You can look at it by passing the quoted macro call to the standard <a href="https://cl-community-spec.github.io/pages/macroexpand.html" referrerpolicy="origin" rel="nofollow noopener"><code>macroexpand</code></a> function in REPL:</p>
<pre><code>(macroexpand
 &#39;(ecs:define-component position
   &#34;Determines the location of the object, in pixels.&#34;
   (x 0.0 :type single-float :documentation &#34;X coordinate&#34;)
   (y 0.0 :type single-float :documentation &#34;Y coordinate&#34;)))))
</code></pre>
<p>I warn you right away, the result can look overwhelming üòÖ It might seem that the compiler is SCREAMING AT YOU because the generated code is in uppercase, but in fact automatic symbol-to-uppercase conversion is a historical feature that can be disabled by tweaking the <a href="https://cl-community-spec.github.io/pages/readtable_002dcase.html" referrerpolicy="origin" rel="nofollow noopener">readtable-case</a> setting. Typically no one bothers with that. You can also have a look at the generated code <a href="https://gist.github.com/lockie/7f097c8ba90be4178005d21459d44890" referrerpolicy="origin" rel="nofollow noopener">here</a>.</p>
<p>The code generated by the macro includes not only a description of the structure that stores <code>position</code> component data for all entities and is automatically added to the common object data storage, but also a set of auxiliary functions and macros (yes, yes, macros can define other macros ü§Ø). Those allow:</p>
<ul>
<li>to get and set the <code>x</code> and <code>y</code> slot values,</li>
<li>to add and remove a <code>position</code> component from a given entity,</li>
<li>to copy <code>position</code> component data from one entity to another,</li>
<li>to check if the <code>position</code> component exists for a given entity,</li>
<li>to easily access slots by name.</li>
</ul>
<p>As part of this tutorial series, we‚Äôll eventually try them all.</p>
<p>Let‚Äôs add one more component before <code>init</code>, which will allow us to draw images corresponding to our celestial bodies on the screen:</p>
<pre><code>(ecs:define-component image
  &#34;Stores ALLEGRO_BITMAP structure pointer, size and scaling information.&#34;
  (bitmap (cffi:null-pointer) :type cffi:foreign-pointer)
  (width 0.0 :type single-float)
  (height 0.0 :type single-float)
  (scale 1.0 :type single-float)))
</code></pre>
<p>In addition to the C pointer to the <a href="https://liballeg.github.io/a5docs/trunk/graphics.html#allegro_bitmap" referrerpolicy="origin" rel="nofollow noopener"><code>ALLEGRO_BITMAP</code></a> image structure from <code>liballegro</code>, this component also stores the image size and scaling information.</p>
<p>Now let‚Äôs implement our first system that will display objects on the screen. Add the following code after the component definitions:</p>
<pre><code>(ecs:define-system draw-images
  (:components-ro (position image)
   :initially (al:hold-bitmap-drawing t)
   :finally (al:hold-bitmap-drawing nil)))
  (let ((scaled-width (* image-scale image-width))
        (scaled-height (* image-scale image-height))))
    (al:draw-scaled-bitmap image-bitmap 0 0
                           image-width image-height
                           (- position-x (* 0.5 scaled-width))
                           (- position-y (* 0.5 scaled-height))
                           scaled-width scaled-height 0))))))
</code></pre>
<p>Defining a system is slightly more complex than defining a component, as it involves the actual entity processing code. The arguments of the <a href="https://lockie.gitlab.io/cl-fast-ecs/#MACRO-FUNCTION%20CL-FAST-ECS%3ADEFINE-SYSTEM" referrerpolicy="origin" rel="nofollow noopener"><code>define-system</code></a> macro are: the name of the system, a set of named options in parentheses, and then the forms that make up the body of the system ‚Äî the code executed for each entity in which the system is interested. This interest is specified with the <code>:components-ro</code> option, where ‚Äúro‚Äù stands for ‚Äúread-only‚Äù: we will process all entities that have <code>position</code> and <code>image</code> components, but we won‚Äôt modify them. In the body of the system, for each such entity, we calculate the scaled dimensions of the image and put them into the <code>scaled-width</code> and <code>scaled-height</code> variables using the special form <a href="https://cl-community-spec.github.io/pages/let.html" referrerpolicy="origin" rel="nofollow noopener"><code>let</code></a>. We then call the <a href="https://liballegro.github.io/a5docs/trunk/graphics.html#al_draw_scaled_bitmap" referrerpolicy="origin" rel="nofollow noopener"><code>al_draw_scaled_bitmap</code></a> function from <code>liballegro</code> to render the image according to the specified position and scale. Note that to access the slots of the components of the processed entity, we use variables in the form <code>component-slot</code>, like <code>image-width</code> or <code>position-y</code>. These variables are automatically generated for us to use by the <code>define-system</code> macro. Additionally, we use the <code>:initially</code> and <code>:finally</code> system options, similar to the corresponding keywords in the standard LISP <a href="https://cl-community-spec.github.io/pages/loop.html" referrerpolicy="origin" rel="nofollow noopener"><code>loop</code></a> construct: expressions from these options will be executed at the very beginning and at the very end of the system, respectively. We call the <a href="https://liballeg.github.io/a5docs/trunk/graphics.html#al_hold_bitmap_drawing" referrerpolicy="origin" rel="nofollow noopener"><code>al_hold_bitmap_drawing</code></a> function at these moments to activate liballegro‚Äôs built-in sprite batching, which ensures that all the calls to the graphics APIs necessary for drawing will occur only after we‚Äôve processed all the objects, saving expensive bus communications between CPU and GPU.</p>
<p>To see the results of our work on the screen, we need two things:</p>
<ul>
<li>create some number of objects with random positions,</li>
<li>and call our system every frame.</li>
</ul>
<p>Let‚Äôs start with the first point.</p>
<p>First, we need images for our celestial bodies. Download them from <a href="https://opengameart.org/content/asteroids" referrerpolicy="origin" rel="nofollow noopener">this page</a> of the OpenGameArt website (click the ‚ÄúFile(s)‚Äù link):</p>
<p><img src="https://img.itch.zone/aW1nLzEzNzQxODk0LnBuZw==/original/2D6FVw.png" alt="" loading="lazy"/></p>
<p>Let‚Äôs unpack the <code>small</code> directory from the downloaded archive into our <code>Resources</code> directory, so that the PNG files are available to our application by paths like <code>Resources/a10000.png</code>. In order to keep things simple, let‚Äôs just hardcode the necessary images as a constant list before the <code>init</code> function:</p>
<pre><code>(define-constant asteroid-images
    &#39;(&#34;../Resources/a10000.png&#34; &#34;../Resources/a10001.png&#34;
      &#34;../Resources/a10002.png&#34; &#34;../Resources/a10003.png&#34;
      &#34;../Resources/a10004.png&#34; &#34;../Resources/a10005.png&#34;
      &#34;../Resources/a10006.png&#34; &#34;../Resources/a10007.png&#34;
      &#34;../Resources/a10008.png&#34; &#34;../Resources/a10009.png&#34;
      &#34;../Resources/a10010.png&#34; &#34;../Resources/a10011.png&#34;
      &#34;../Resources/a10012.png&#34; &#34;../Resources/a10013.png&#34;
      &#34;../Resources/a10014.png&#34; &#34;../Resources/a10015.png&#34;
      &#34;../Resources/b10000.png&#34; &#34;../Resources/b10001.png&#34;
      &#34;../Resources/b10002.png&#34; &#34;../Resources/b10003.png&#34;
      &#34;../Resources/b10004.png&#34; &#34;../Resources/b10005.png&#34;
      &#34;../Resources/b10006.png&#34; &#34;../Resources/b10007.png&#34;
      &#34;../Resources/b10008.png&#34; &#34;../Resources/b10009.png&#34;
      &#34;../Resources/b10010.png&#34; &#34;../Resources/b10011.png&#34;
      &#34;../Resources/b10012.png&#34; &#34;../Resources/b10013.png&#34;
      &#34;../Resources/b10014.png&#34; &#34;../Resources/b10015.png&#34;)
  :test #&#39;equalp)
</code></pre>
<p>Note for MacOS users: there‚Äôs currently unresolved <a href="https://github.com/liballeg/allegro5/issues/1531" referrerpolicy="origin" rel="nofollow noopener">bug</a> in liballegro, which causes it to incorrectly display PNG images with 16-bit color on MacOS. Thus under this OS you‚Äôll need to convert them to 8-bit format using the command like</p>
<pre><code>mogrify -depth 8 *.png
</code></pre>
<p>after installing <code>imagemagick</code> from Homebrew. Thanks to Marcus for the bug report!</p>
<p>Then, add the following code to the <code>init</code> function after the <code>bind-storage</code> call:</p>
<pre><code>  (let ((asteroid-bitmaps
          (map &#39;list
               #&#39;(lambda (filename)
                   (al:ensure-loaded
                    #&#39;al:load-bitmap filename))
               asteroid-images)))
    (dotimes (_ 1000)
      (ecs:make-object `((:position
                          :x ,(float (random +window-width+))
                          :y ,(float (random +window-height+)))
                         (:image
                          :bitmap ,(alexandria:random-elt
                                    asteroid-bitmaps)
                          :width 64.0 :height 64.0)))))
</code></pre>
<p>In this code, we load all hardcoded images into the <code>asteroid-bitmaps</code> list using the <a href="https://liballegro.github.io/a5docs/trunk/graphics.html#al_load_bitmap" referrerpolicy="origin" rel="nofollow noopener"><code>al_load_bitmap</code></a> function and the helper Lisp function <a href="https://github.com/resttime/cl-liballegro/blob/42ce43/src/interface/streams.lisp#L15" referrerpolicy="origin" rel="nofollow noopener"><code>al:ensure-loaded</code></a>. After that, we use the ECS framework function <a href="https://lockie.gitlab.io/cl-fast-ecs/#FUNCTION%20CL-FAST-ECS%3AMAKE-OBJECT" referrerpolicy="origin" rel="nofollow noopener"><code>make-object</code></a> in a loop with a thousand iterations. This function constructs an entity with components defined by the provided specification ‚Äî a list of the form</p>
<pre><code>&#39;((:component1 :slot1 &#34;value1&#34; :slot2 &#34;value2&#34;)
  (:component2 :slot &#34;value&#34;)
  ;; ...
 )
</code></pre>
<p>Additionally, we use a distinctive feature of Common Lisp that blurs the thin line between data and code, and is often encountered when writing macros, the so-called <a href="https://cl-community-spec.github.io/pages/Backquote.html" referrerpolicy="origin" rel="nofollow noopener"><em>quasiquoting</em></a>. It allows us to construct lists of arbitrary nesting level by inserting the results of some code execution into the required places in the list. In our case, this involves calls to the standard function <a href="https://cl-community-spec.github.io/pages/random.html" referrerpolicy="origin" rel="nofollow noopener"><code>random</code></a>, which returns a random number in a given range, and <a href="https://cl-community-spec.github.io/pages/float.html" referrerpolicy="origin" rel="nofollow noopener"><code>float</code></a>, which converts its argument to a floating-point number (since liballegro uses <code>float</code> as coordinate type). Also, to randomly select an image, we use the <a href="https://alexandria.common-lisp.dev/draft/alexandria.html#index-random_002delt" referrerpolicy="origin" rel="nofollow noopener"><code>random-elt</code></a> function from the <code>alexandria</code> library, which includes a lot of useful functions  (basically, this library is to Common Lisp what GLib is to C or boost is to C++).</p>
<p>Now, the second point: calling the system. This is taken care of for us by the <a href="https://lockie.gitlab.io/cl-fast-ecs/#FUNCTION%20CL-FAST-ECS%3ARUN-SYSTEMS" referrerpolicy="origin" rel="nofollow noopener"><code>run-systems</code></a> function in the ECS framework, since it runs all systems registered via <code>define-system</code>. It‚Äôs interesting to note that, although our template code separates the <code>update</code> and <code>render</code> steps in the main game loop, with ECS we don‚Äôt have to explicitly define separate functions for world updates and on-screen rendering. With ECS, the game code is concentrated within systems, and we have the flexibility to arbitrarily define the execution order of systems relative to each other. So, we simply add a call to <code>run-systems</code> to the <code>update</code> function in our template, after the FPS calculation code:</p>
<pre><code>(defun update (dt)
  (unless (zerop dt)
    (setf *fps* (round 1 dt)))
  (ecs:run-systems))
</code></pre>
<p>Let‚Äôs leave the <code>render</code> function as it is, despite the TODO comment inviting to put the drawing code there. In our setup, this function is only responsible for the FPS counter.</p>
<p>After sending the new code ‚Äî the <code>asteroid-images</code> constant, new bodies of <code>init</code> and <code>update</code> functions, <code>position</code>, <code>speed</code> and <code>image</code> component definitions, and the <code>draw-images</code> system ‚Äî to a running Lisp process using the <code>C-c C-c</code> keys (or the equivalent for your IDE) and running <code>(ecs-tutorial-1:main)</code>, you should be able to observe the following result:</p>
<p><img src="https://img.itch.zone/aW1nLzEzNzQyMzEzLnBuZw==/original/92WGG9.png" alt="" loading="lazy"/></p>
<h2>Physics</h2>
<p>Now let‚Äôs add a bit of Newtonian physics. We have the <code>speed</code> component, so it makes sense to use it to calculate the current position of the object. Let‚Äôs create a separate system called <code>move</code> for this purpose:</p>
<pre><code>(ecs:define-system move
  (:components-ro (speed)
   :components-rw (position)
   :arguments ((:dt single-float)))
  (incf position-x (* dt speed-x))
  (incf position-y (* dt speed-y)))
</code></pre>
<p>This time, we will modify the <code>position</code> component of the entities of interest, so we specify it in the list corresponding to the <code>components-rw</code> option. Additionally, our system will need the actual time elapsed since the previous frame as an argument, to ensure the physical correctness of what‚Äôs happening on the screen. For simplicity, this argument will also be a single-precision floating-point number, <a href="https://cl-community-spec.github.io/pages/short_002dfloat.html" referrerpolicy="origin" rel="nofollow noopener"><code>single-float</code></a>. We call it <code>dt</code> and specify it along with its type in the <code>arguments</code> system option. Finally, the system code simply increments the position values using the standard <a href="https://cl-community-spec.github.io/pages/incf.html" referrerpolicy="origin" rel="nofollow noopener"><code>incf</code></a> macro, similar to the <code>+=</code> operator from C-like languages, by the value of <code>dt</code> multiplied by the corresponding speed component.</p>
<p>In order for this system to do its job, we also need to add the <code>speed</code> component to our objects. To do this, modify the snippet for creating the objects in the <code>init</code> function as follows:</p>
<pre><code>  (let ((asteroid-bitmaps
          (map &#39;list
               #&#39;(lambda (filename)
                   (al:ensure-loaded
                    #&#39;al:load-bitmap filename))
               asteroid-images)))
    (dotimes (_ 1000)
      (ecs:make-object `((:position
                          :x ,(float (random +window-width+))
                          :y ,(float (random +window-height+)))
                         (:speed :x ,(- (random 100.0) 50.0)
                                 :y ,(- (random 100.0) 50.0))
                         (:image
                          :bitmap ,(alexandria:random-elt
                                    asteroid-bitmaps)
                          :width 64.0 :height 64.0)))))
</code></pre>
<p>However, running the <code>ecs-tutorial-1:main</code> function again after sending the <code>move</code> system and the new <code>init</code> function code to the Lisp process by means of your IDE yields the following error right in the <code>move-system</code> function:</p>
<pre><code>The value
  NIL
is not of type
  NUMBER
   [Condition of type TYPE-ERROR]
</code></pre>
<p>Let‚Äôs terminate the <code>main</code> function by selecting the default <code>ABORT</code> restart from the <code>Restarts</code> list and try to figure out what went wrong.</p>
<p>Upon closer examination of the new code, you may notice that we forgot to pass the <code>dt</code> parameter to the new <code>move</code> system. It is already computed for us in the template code and passed to the <code>update</code> function. All we have to do is convert it from double precision <a href="https://cl-community-spec.github.io/pages/short_002dfloat.html" referrerpolicy="origin" rel="nofollow noopener"><code>double-float</code></a> to single precision and pass it to the <code>ecs:run-system</code> function called in <code>update</code>. <code>run-systems</code> accepts any number of keyword parameters and passes them to the systems by name as needed:</p>
<pre><code>(defun update (dt)
  (unless (zerop dt)
    (setf *fps* (round 1 dt)))
  (ecs:run-systems :dt (float dt 0.0)))
</code></pre>
<p>Running <code>main</code> after sending a new definition of the <code>update</code> function to the Lisp process, you should observe asteroids slowly drifting apart:</p>
<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/1jtvVs3q0xY?si=bOzMQl0H7blaIQpo" frameborder="0" allowfullscreen=""></iframe>
<p>Note that the demo still maintains reasonable FPS values. Moreover, out of curiosity, we can take a look at the machine code generated by the compiler for our last system, <code>move</code>, using the standard CL <a href="https://cl-community-spec.github.io/pages/disassemble.html" referrerpolicy="origin" rel="nofollow noopener"><code>disassemble</code></a> function:</p>
<pre><code>(disassemble (rest (assoc :move ecs::*system-registry*)))
</code></pre>
<p>As a result, we can see (for the release build generated for us by the <code>package.sh</code> script from the template) something like this:</p>
<pre><code>; disassembly for ECS-TUTORIAL-1::MOVE-SYSTEMG5
; Size: 210 bytes. Origin: #x538B2811                          ; ECS-TUTORIAL-1::MOVE-SYSTEMG5
; 11:       488B0508FFFFFF   MOV RAX, [RIP-248]                ; &#39;CL-FAST-ECS:*STORAGE*
; 18:       8B48F5           MOV ECX, [RAX-11]
; 1B:       4A8B0C29         MOV RCX, [RCX+R13]
; 1F:       4883F9FF         CMP RCX, -1
; 23:       480F444801       CMOVEQ RCX, [RAX+1]
; 28:       488B4125         MOV RAX, [RCX+37]
; 2C:       488B4801         MOV RCX, [RAX+1]
; 30:       488B712D         MOV RSI, [RCX+45]
; 34:       488B5935         MOV RBX, [RCX+53]
; 38:       488B4009         MOV RAX, [RAX+9]
; 3C:       4C8B582D         MOV R11, [RAX+45]
; 40:       4C8B7035         MOV R14, [RAX+53]
; 44:       498B42F9         MOV RAX, [R10-7]
; 48:       4C8B52F9         MOV R10, [RDX-7]
; 4C:       488BD0           MOV RDX, RAX
; 4F:       EB35             JMP L2
; 51:       660F1F840000000000 NOP
; 5A:       660F1F440000     NOP
; 60: L0:   4D8B41F9         MOV R8, [R9-7]
; 64:       488BCA           MOV RCX, RDX
; 67:       48D1F9           SAR RCX, 1
; 6A:       488BC1           MOV RAX, RCX
; 6D:       48C1E806         SHR RAX, 6
; 71:       498B44C001       MOV RAX, [R8+RAX*8+1]
; 76:       480FA3C8         BT RAX, RCX
; 7A:       7217             JB L3
; 7C: L1:   488BCA           MOV RCX, RDX
; 7F:       4883C102         ADD RCX, 2
; 83:       488BD1           MOV RDX, RCX
; 86: L2:   4C39D2           CMP RDX, R10
; 89:       7ED5             JLE L0
; 8B:       BA17010050       MOV EDX, #x50000117               ; NIL
; 90:       C9               LEAVE
; 91:       F8               CLC
; 92:       C3               RET
; 93: L3:   488BC2           MOV RAX, RDX
; 96:       F3410F10544301   MOVSS XMM2, [R11+RAX*2+1]
; 9D:       66480F6ECF       MOVQ XMM1, RDI
; A2:       0FC6C9FD         SHUFPS XMM1, XMM1, #4r3331
; A6:       F30F59D1         MULSS XMM2, XMM1
; AA:       F30F104C4601     MOVSS XMM1, [RSI+RAX*2+1]
; B0:       F30F58CA         ADDSS XMM1, XMM2
; B4:       F30F114C4601     MOVSS [RSI+RAX*2+1], XMM1
; BA:       488BC2           MOV RAX, RDX
; BD:       F3410F104C4601   MOVSS XMM1, [R14+RAX*2+1]
; C4:       66480F6EDF       MOVQ XMM3, RDI
; C9:       0FC6DBFD         SHUFPS XMM3, XMM3, #4r3331
; CD:       F30F59D9         MULSS XMM3, XMM1
; D1:       F30F10544301     MOVSS XMM2, [RBX+RAX*2+1]
; D7:       F30F58DA         ADDSS XMM3, XMM2
; DB:       F30F115C4301     MOVSS [RBX+RAX*2+1], XMM3
; E1:       EB99             JMP L1
</code></pre>
<p>And this is indeed an impressive result: the machine code that calculates the positions of an arbitrary number of objects according to physical considerations does not call any external functions and occupies only 210 bytes! Moreover, if you have a basic skill of reading assembler, you can see the body of the loop that processes our objects. It starts with the label <code>L3</code> and consists of only 17 (!) machine instructions, which also go with the flow of CPU cache ensuring high performance.</p>
<p>However, we digress. To make the simulation more fun than just asteroids flying around, let‚Äôs add a massive planetary body to it, turning the demo into a simulation of space debris orbiting a planet.</p>
<p>Let‚Äôs use the following content from OpenGameArt: <a href="https://opengameart.org/content/space-background-3" referrerpolicy="origin" rel="nofollow noopener">Space Background</a>. Besides a nice planet, the archive also contains some charming space backgrounds. Unpack the <code>layers</code> directory from the downloaded archive into our <code>Resources</code> directory, so that the PNG files are available to our application by the paths like <code>Resources/parallax-space-big-planet.png</code>.</p>
<p>In order to see the planet on the screen, we need to create a corresponding entity in the <code>init</code> function. First of all, before definitions of all our ECS systems, let‚Äôs create global variables with the characteristics of the planet, we will need them later:</p>
<pre><code>(declaim
 (type single-float
       *planet-x* *planet-y* *planet-width* *planet-height* *planet-mass*))
(defvar *planet-x*)
(defvar *planet-y*)
(defvar *planet-width*)
(defvar *planet-height*)
(defvar *planet-mass* 500000.0)
</code></pre>
<p>Note that in Common Lisp it is customary to add ‚Äúearmuffs‚Äù ‚Äî asterisks at the beginning and at the end ‚Äî to the names of global variables, to emphasize that they are <a href="https://cl-community-spec.github.io/pages/special.html" referrerpolicy="origin" rel="nofollow noopener">special</a> in a sense that they use dynamic scoping rules instead of lexical. Additionally, before defining variables using the standard <a href="https://cl-community-spec.github.io/pages/defparameter.html" referrerpolicy="origin" rel="nofollow noopener"><code>defvar</code></a> macro, we declare their type, <code>single-float</code>, which is a floating-point number with single precision, using the <a href="https://cl-community-spec.github.io/pages/declaim.html" referrerpolicy="origin" rel="nofollow noopener"><code>declaim</code></a> macro with the <code>type</code> parameter. This is optional, since Common Lisp has <a href="https://en.wikipedia.org/wiki/Gradual_typing" referrerpolicy="origin" rel="nofollow noopener">gradual typing</a>, but it‚Äôll positively affect the performance of the code that uses these variables.</p>
<p>Now let‚Äôs create the planet entity with the following new code snippet in the <code>init</code> function after the <code>ecs:bind-storage</code> call:</p>
<pre><code>  (let ((planet-bitmap
          (al:ensure-loaded
           #&#39;al:load-bitmap
           &#34;../Resources/parallax-space-big-planet.png&#34;)))
    (setf *planet-width*
          (float (al:get-bitmap-width planet-bitmap))
          *planet-height*
          (float (al:get-bitmap-height planet-bitmap))
          *planet-x* (/ +window-width+ 2.0)
          *planet-y* (/ +window-height+ 2.0))
    (ecs:make-object `((:position :x ,*planet-x*
                                  :y ,*planet-y*)
                       (:image :bitmap ,planet-bitmap
                               :width ,*planet-width*
                               :height ,*planet-height*))))
</code></pre>
<p>Here we load an image with the planet using the already familiar <a href="https://liballeg.github.io/a5docs/trunk/graphics.html#al_load_bitmap" referrerpolicy="origin" rel="nofollow noopener"><code>al_load_bitmap</code></a> and <a href="https://github.com/resttime/cl-liballegro/blob/42ce43/src/interface/streams.lisp#L15" referrerpolicy="origin" rel="nofollow noopener"><code>al:ensure-loaded</code></a> functions. Then, using straightforward arithmetic and the <a href="https://liballeg.github.io/a5docs/trunk/graphics.html#al_get_bitmap_width" referrerpolicy="origin" rel="nofollow noopener"><code>al_get_bitmap_width</code></a> and <a href="https://liballeg.github.io/a5docs/trunk/graphics.html#al_get_bitmap_height" referrerpolicy="origin" rel="nofollow noopener"><code>al_get_bitmap_height</code></a> functions, we create an entity with the image exactly in the middle of the screen, storing its coordinates and dimensions in the corresponding global variables using the <a href="https://cl-community-spec.github.io/pages/setf.html" referrerpolicy="origin" rel="nofollow noopener"><code>setf</code></a> macro.</p>
<p>After sending the new code to the Lisp process ¬≠‚Äî global variable definitions via <code>defvar</code> and the modified <code>init</code> function ‚Äî and restarting the <code>main</code> function, you will see the planet:</p>
<p><img src="https://img.itch.zone/aW1nLzEzNzQyNzM3LnBuZw==/original/W7tXE1.png" alt="" loading="lazy"/></p>
<h2>More physics</h2>
<p>Now let‚Äôs add more realism ‚Äî let objects crash when they collide with the planet. For simplicity, we‚Äôll consider the planet as an ellipse. Let‚Äôs implement another system for collision detection, naming it <code>crash-asteroids</code>:</p>
<pre><code>(ecs:define-system crash-asteroids
  (:components-ro (position)
   :with ((planet-half-width planet-half-height)
          :of-type (single-float single-float)
          := (values (/ *planet-width* 2.0)
                     (/ *planet-height* 2.0))))
  (when (&lt;= (+
             (expt
              (/ (- position-x *planet-x*) planet-half-width)
              2)
             (expt
              (/ (- position-y *planet-y*) planet-half-height)
              2))
            1.0)
    (ecs:delete-entity entity)))
</code></pre>
<p>In its definition, we use the <code>:with</code> system option, which allows us to define local variables once at the beginning of the system execution. These variables will be available within the system‚Äôs body. We use this feature to calculate the semiaxes of the planet to plug them into the ellipse equation</p>
<p><img src="https://img.itch.zone/aW1nLzEzNzQyODQwLmdpZg==/original/90mE3f.gif" alt="" loading="lazy"/></p>
<p>to determine whether an object collides with the planet. If this condition is true, we delete the object by calling the <a href="https://lockie.gitlab.io/cl-fast-ecs/#FUNCTION%20CL-FAST-ECS%3ADELETE-ENTITY" referrerpolicy="origin" rel="nofollow noopener"><code>delete-entity</code></a> function with the <code>entity</code> variable automatically created for us by the <code>define-system</code> macro for the currently processed entity.</p>
<p>Note that you don‚Äôt even have to close the simulation window and restart the <code>main</code> function! By sending the <code>crash-asteroids</code> system definition to the Lisp process, you immediately change the behavior of our simulation according to the rules encoded in the new system. However, using this opportunity, you will encounter an unexpected effect ‚Äî the planet disappears!</p>
<p>If you look closely at the new system, you can understand the essence of the problem: the code in <code>crash-asteroids</code> does not distinguish between asteroids and the planet. It just processes all entities with the <code>position</code> component one after another. Since the coordinates of the planet center are quite surely inside the ellipse formed by the width and height of its image, it gets deleted at the very first run of the <code>crash-asteroids</code> system.</p>
<p>In order to correct this issue, let‚Äôs use a technique often used in ECS-architecture applications, known as the <em>tag component</em>. We‚Äôll create an empty component with no slots, which will serve as a kind of ‚Äútag‚Äù or ‚Äúlabel‚Äù. When added to an entity, it will signal some boolean feature, in this case, whether the object is a planet:</p>
<pre><code>(ecs:define-component planet
  &#34;Tag component to indicate that entity is a planet.&#34;)
</code></pre>
<p>Then modify the <code>init</code> function so that the newly created component is added to the planet entity:</p>
<pre><code>    (ecs:make-object `((:planet)
                       (:position :x ,*planet-x*
                                  :y ,*planet-y*)
                       (:image :bitmap ,planet-bitmap
                               :width ,*planet-width*
                               :height ,*planet-height*)))
</code></pre>
<p>Also, while we‚Äôre at it, let‚Äôs add a little cÃ∂oÃ∂sÃ∂mÃ∂iÃ∂cÃ∂ cosmetic touch by making the asteroids inside our 1000-iteration loop to have random sizes:</p>
<pre><code>      (ecs:make-object `((:position
                          :x ,(float (random +window-width+))
                          :y ,(float (random +window-height+)))
                         (:speed :x ,(- (random 100.0) 50.0)
                                 :y ,(- (random 100.0) 50.0))
                         (:image
                          :bitmap ,(alexandria:random-elt
                                    asteroid-bitmaps)
                          :scale ,(+ 0.1 (random 0.9))
                          :width 64.0 :height 64.0)))
</code></pre>
<p>Finally, let‚Äôs modify the <code>crash-asteroids</code> system to skip entities with the <code>planet component</code>. To do this, we use the <code>:components-no</code> option to the <code>define-system</code> macro, in which we can specify a list of components that should <strong>not</strong> be had by entities processed by the system:</p>
<pre><code>(ecs:define-system crash-asteroids
  (:components-ro (position)
   :components-no (planet)
   :with ((planet-half-width planet-half-height)
          :of-type (single-float single-float)
          := (values (/ *planet-width* 2.0)
                     (/ *planet-height* 2.0))))
  (when (&lt;= (+
             (expt
              (/ (- position-x *planet-x*) planet-half-width)
              2)
             (expt
              (/ (- position-y *planet-y*) planet-half-height)
              2))
            1.0)
    (ecs:delete-entity entity)))
</code></pre>
<p>By sending the new definitions (<code>planet</code> component, <code>init</code> function and <code>crash-asteroids</code> system) to the Lisp process and restarting <code>ecs-tutorial-1:main</code>, we can observe the following virtual snow globe:</p>
<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/_RdCTXRSxMA?si=FALRmpStWgQzlzRC" frameborder="0" allowfullscreen=""></iframe>
<h2>Even more physics</h2>
<p>Finally, let us add the gravitational force of the planet to the factors affecting the simulated objects. We will neglect the mutual attraction of asteroids for simplicity. To do this, we need a new component ‚Äî acceleration:</p>
<pre><code>(ecs:define-component acceleration
  &#34;Determines the acceleration of the object, in pixels/second^2.&#34;
  (x 0.0 :type single-float :documentation &#34;X coordinate&#34;)
  (y 0.0 :type single-float :documentation &#34;Y coordinate&#34;))
</code></pre>
<p>Next, let‚Äôs introduce a system that will use acceleration to influence the speed vector, and name it <code>accelerate</code>:</p>
<pre><code>(ecs:define-system accelerate
  (:components-ro (acceleration)
   :components-rw (speed)
   :arguments ((:dt single-float)))
  (incf speed-x (* dt acceleration-x))
  (incf speed-y (* dt acceleration-y)))
</code></pre>
<p>However, the main character in the gravity story will be the effect of planet mass on our asteroids. We already have a global variable with the mass of the planet, <code>*planet-mass*</code>. Through some simple algebraic manipulations, we derive expressions for acceleration from the law of universal gravitation and Newton‚Äôs 2nd law:</p>
<p><img src="https://img.itch.zone/aW1nLzEzNzQzMTI3LmdpZg==/original/99qR6G.gif" alt="" loading="lazy"/>
<img src="https://img.itch.zone/aW1nLzEzNzQzMTMxLmdpZg==/original/2Pt6IE.gif" alt="" loading="lazy"/></p>
<p>where</p>

<p>Assuming that the gravitational constant <code>G</code> is already included as a multiplier in the <code>*planet-mass*</code> variable, let us create a new system named <code>pull</code> to calculate the asteroid acceleration using the above formulas:</p>
<pre><code>(ecs:define-system pull
  (:components-ro (position)
   :components-rw (acceleration))
  (let* ((distance-x (- *planet-x* position-x))
         (distance-y (- *planet-y* position-y))
         (angle (atan distance-y distance-x))
         (distance-squared (+ (expt distance-x 2)
                              (expt distance-y 2)))
         (acceleration (/ *planet-mass* distance-squared)))
    (setf acceleration-x (* acceleration (cos angle))
          acceleration-y (* acceleration (sin angle)))))
</code></pre>
<p>Finally, in the <code>init</code> function, let‚Äôs add an <code>acceleration</code> component to our asteroids:</p>
<pre><code>      (ecs:make-object `((:position
                          :x ,(float (random +window-width+))
                          :y ,(float (random +window-height+)))
                         (:speed :x ,(- (random 100.0) 50.0)
                                 :y ,(- (random 100.0) 50.0))
                         (:acceleration)
                         (:image
                          :bitmap ,(alexandria:random-elt
                                    asteroid-bitmaps)
                          :scale ,(+ 0.1 (random 0.9))
                          :width 64.0 :height 64.0)))))
</code></pre>
<p>By sending the definitions of the <code>acceleration</code> component, as well as the <code>init</code> function and the <code>accelerate</code> and <code>pull</code> systems to the Lisp process, we get a similar picture of a snow globe, only now the asteroids swarm around the planet more eagerly.</p>
<p>To make the simulation more interesting, let‚Äôs set it up as if a satellite near the planet has been destroyed, and a large amount of its debris, attracted by the planet, forms rings. Change the code for creating asteroids in the <code>init</code> function to the following:</p>
<pre><code>  (let ((asteroid-bitmaps
          (map &#39;list
               #&#39;(lambda (filename)
                   (al:ensure-loaded
                    #&#39;al:load-bitmap filename))
               asteroid-images)))
    (dotimes (_ 5000)
      (let ((r (random 20.0))
            (angle (float (random (* 2 pi)) 0.0)))
        (ecs:make-object
         `((:position :x ,(+ 200.0 (* r (cos angle)))
                      :y ,(+ *planet-y* (* r (sin angle))))
           (:speed :x ,(+ -5.0 (random 15.0))
                   :y ,(+ 30.0 (random 30.0)))
           (:acceleration)
           (:image
            :bitmap ,(alexandria:random-elt asteroid-bitmaps)
            :scale ,(+ 0.1 (random 0.9))
            :width 64.0 :height 64.0))))))
</code></pre>
<p>Also, as a final cosmic touch, let‚Äôs use the star backgrounds from our resources by adding the following code to the <code>init</code> function, right after <code>bind-storage</code> call:</p>
<pre><code>  (let ((background-bitmap-1
          (al:ensure-loaded
           #&#39;al:load-bitmap
           &#34;../Resources/parallax-space-stars.png&#34;))
        (background-bitmap-2
          (al:ensure-loaded
           #&#39;al:load-bitmap
           &#34;../Resources/parallax-space-far-planets.png&#34;)))
    (ecs:make-object
     `((:position :x 400.0 :y 200.0)
       (:image
        :bitmap ,background-bitmap-1
        :width
        ,(float (al:get-bitmap-width background-bitmap-1))
        :height
        ,(float (al:get-bitmap-height background-bitmap-1)))))
    (ecs:make-object
     `((:position :x 100.0 :y 100.0)
       (:image
        :bitmap ,background-bitmap-2
        :width
        ,(float (al:get-bitmap-width background-bitmap-2))
        :height
        ,(float (al:get-bitmap-height background-bitmap-2))))))
</code></pre>
<p>These initial parameters will lead to the following mesmerizing simulation behavior:</p>
<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/LyVqRaUOLNs?si=ymlKKMDs_4sTEfkh" frameborder="0" allowfullscreen=""></iframe>
<p>Note that the physical simulation of five thousand objects easily fits within the 60 frames per second limit, further confirming the efficiency of the code built using the Entity-Component-System pattern. And the amount of code we wrote, totaling 250 lines (including boilerplate and hardcode) confirms high expressiveness of the Lisp language and the power of metalinguistic abstraction.</p>
<p>You can change the simulation‚Äôs initial parameters in the <code>init</code> function to create your own visual masterpieces. Please share your results in the comments üòä</p>
<h2>Conclusion</h2>
<p>In this tutorial, we‚Äôve built a 2D physics simulation in Common Lisp, and explored the main features of the <code>cl-fast-ecs</code> framework. The full source code can be found at <a href="https://github.com/lockie/ecs-tutorial-1" referrerpolicy="origin" rel="nofollow noopener">github</a>.</p>
<p>At the time of writing, the version of the <code>cl-fast-ecs</code> framework is 0.4.0, which means that it is rapidly evolving and there still may be changes breaking backward compatibility. However, the functionality we‚Äôve covered today ‚Äî macros for defining components and systems, functions for creating entities ‚Äî is fundamental and is unlikely to undergo major changes in the future.</p>
<p>In the next part, we will add user interaction and switch from the space genre to the fantasy genre as we attempt to make a simple dungeon crawler. Follow me on <a href="https://awkravchuk.itch.io">itch.io</a> so you won‚Äôt miss the next part.</p>
<p>I would like to thank my friend <a href="https://viruscd.itch.io">@ViruScD</a> for support and help in writing the article, and Artem from the Lisp Forever Telegram community for help with proofreading the text.</p>
</section><section><h2>Get cl-fast-ecs</h2></section></div></div>
  </body>
</html>
