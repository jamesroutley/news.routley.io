<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://denizaksimsek.com/2023/xpath/">Original</a>
    <h1>Using XPath in 2023</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>In the latest release of <a href="https://htmx.org">htmx</a>,
you can add event listeners to elements with <code>hx-on</code>:</p>
<pre tabindex="0"><code></code></pre>
<p>For all the other <code>hx-</code> attributes, we use CSS attribute selectors.
However, with <code>hx-on</code>, the attribute name is not fixed as it contains the event.
CSS attribute selectors support wildcards on the <em>value</em> of attributes,
but not the name:</p>
<pre tabindex="0"><code>[hx-trigger] 
[href^=<span>&#34;https://dz4k.com&#34;</span>] 
[^<span>ĥx-on</span><span>:</span>] 
</code></pre>
<h2><ruby>X<rt>XML</rt>Path<rt>Path Language</rt></ruby></h2>
<p>XPath is a query language for extracting information from XML(-like) documents.
Its main use cases are XSLT and parsing API responses.</p>
<p>The XPath language is significantly more expressive than CSS,
making it possible to traverse the XML tree in any direction,
filter nodes based on arbitrary predicates,
and select any kind of node
(including comments, text nodes, and individual attributes).
Our non-existent CSS attribute could be written as follows:</p>
<pre tabindex="0"><code>//@*[starts-with(name(), &#34;hx-on:&#34;)]
</code></pre>
<p>This post is not supposed to be an XPath tutorial, but I’ll break this one down:</p>
<dl>
<dt><code>//</code></dt>
<dd>traverse the document (in CSS, this is the default)</dd>
<dt><code>@*</code></dt>
<dd>find any attribute (mnemonic: <strong>at</strong>-tribute)</dd>
<dt><code>[ ... ]</code></dt>
<dd>where…</dd>
<dt><code>starts-with(name(), &#34;hx-on:&#34;)</code></dt>
<dd>its name starts with <code>&#34;hx-on:&#34;</code></dd>
</dl>
<p>CSS selectors don’t have these kinds of features,
and it has good reasons not to.
CSS has strict performance requirements
– to the point that “CSS optimization” is generally not a thing –
and selectors that offer more control could make slow selectors possible.
In addition, CSS has well-defined specificity rules, whereas XPath does not.</p>
<p>However, while these features make CSS great for stylesheets,
CSS selectors are also the most common way to find DOM elements in
JavaScript code and lacking in that regard.
Many libraries which extend HTML do so by traversing the entire document
and finding elements manually.
This is often not needed since, if you didn’t know,
<strong>XPath is built into browsers.</strong></p>
<h2>document.evaluate</h2>
<p>The <a href="https://developer.mozilla.org/en-US/Web/XPath/Introduction_to_using_XPath_in_JavaScript"><code>document.evaluate</code> API</a> is somewhat archaic,
partly because it was designed for talking to XML APIs over <code>XMLHTTPRequest</code>.
Here’s a DOM-friendly wrapper:</p>
<pre tabindex="0"><code>function* xpath(...args) {
  let path, root = document;
  if (args.length &gt; 1) [root, path] = args;
  else [path] = args;

  const nodeIterator = document.evaluate(
    path,
    root,
    null,
    XPathResult.UNORDERED_NODE_ITERATOR_TYPE,
    null,
  );

  for (
    let node = nodeIterator.iterateNext();
    node != null;
    node = nodeIterator.iterateNext()
  ) {
    yield node;
  }
}

// TypeScript declaration
function xpath(path: string): Iterable;
function xpath(root: Element, path: string): Iterable;
</code></pre>
</div></div>
  </body>
</html>
