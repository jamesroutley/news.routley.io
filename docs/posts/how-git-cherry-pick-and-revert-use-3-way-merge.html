<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jvns.ca/blog/2023/11/10/how-cherry-pick-and-revert-work/">Original</a>
    <h1>How git cherry-pick and revert use 3-way merge</h1>
    
    

<p>Hello! I was trying to explain to someone how <code>git cherry-pick</code> works the other
day, and I found myself getting confused.</p>

<p>What went wrong was: I thought that <code>git cherry-pick</code> was basically applying a
patch, but when I tried to actually do it that way, it didn&rsquo;t work!</p>

<p>Let&rsquo;s talk about what I thought <code>cherry-pick</code> did (applying a patch), why
that&rsquo;s not quite true, and what it actually does instead (a &ldquo;3-way merge&rdquo;).</p>

<p>This post is extremely in the weeds and you definitely don&rsquo;t need to understand
this stuff to use git effectively. But if you (like me) are curious about git&rsquo;s
internals, let&rsquo;s talk about it!</p>

<h3 id="cherry-pick-isn-t-applying-a-patch">cherry-pick isn&rsquo;t applying a patch</h3>

<p>The way I previously understood <code>git cherry-pick COMMIT_ID</code> is:</p>

<ul>
<li>calculate the diff for <code>COMMIT_ID</code>, like <code>git show COMMIT_ID --patch &gt; out.patch</code></li>
<li>Apply the patch to the current branch, like <code>git apply out.patch</code></li>
</ul>

<p>Before we get into this &ndash; I want to be clear that this model is mostly
right, and if that&rsquo;s your mental model that&rsquo;s fine. But it&rsquo;s wrong in some
subtle ways and I think that&rsquo;s kind of interesting, so let&rsquo;s see how it works.</p>

<p>If I try to do the &ldquo;calculate the diff and apply the patch&rdquo; thing in a case
where there&rsquo;s a merge conflict, here&rsquo;s what happens:</p>

<pre><code>$ git show 10e96e46 --patch &gt; out.patch
$ git apply out.patch
error: patch failed: content/post/2023-07-28-why-is-dns-still-hard-to-learn-.markdown:17
error: content/post/2023-07-28-why-is-dns-still-hard-to-learn-.markdown: patch does not apply
</code></pre>

<p>This just fails &ndash; it doesn&rsquo;t give me any way to resolve the conflict or figure
out how to solve the problem.</p>

<p>This is quite different from what actually happens when run <code>git cherry-pick</code>,
which is that I get a merge conflict:</p>

<pre><code>$ git cherry-pick 10e96e46
error: could not apply 10e96e46... wip
hint: After resolving the conflicts, mark them with
hint: &quot;git add/rm &lt;pathspec&gt;&quot;, then run
hint: &quot;git cherry-pick --continue&quot;.
</code></pre>

<p>So it seems like the &ldquo;git is applying a patch&rdquo; model isn&rsquo;t quite right. But the
error message literally does say &ldquo;could not <strong>apply</strong> 10e96e46&rdquo;, so it&rsquo;s not quite
<em>wrong</em> either. What&rsquo;s going on?</p>

<h3 id="so-what-is-cherry-pick-doing">so what is cherry-pick doing?</h3>

<p>I went digging through git&rsquo;s source code to see how <code>cherry-pick</code> works, and
ended up at <a href="https://github.com/git/git/blob/dadef801b365989099a9929e995589e455c51fed/sequencer.c#L2353-L2358">this line of code</a>:</p>

<pre><code>res = do_recursive_merge(r, base, next, base_label, next_label, &amp;head, &amp;msgbuf, opts);
</code></pre>

<p>So a cherry-pick is a&hellip; merge? What? How? What is it even merging? And how does merging even work in the first place?</p>

<p>I realized that I didn&rsquo;t really know how git&rsquo;s merge worked, so I googled it
and found out that git does a thing called &ldquo;3-way merge&rdquo;. What&rsquo;s that?</p>

<h3 id="how-git-merges-files-the-3-way-merge">how git merges files: the 3-way merge</h3>

<p>Let&rsquo;s say I want to merge these 2 files. We&rsquo;ll call them <code>v1.py</code> and <code>v2.py</code>.</p>

<pre><code>def greet():
    greeting = &quot;hello&quot;
    name = &quot;julia&quot;
    return greeting + &quot; &quot; + name
</code></pre>

<pre><code>def say_hello():
    greeting = &quot;hello&quot;
    name = &quot;aanya&quot;
    return greeting + &quot; &quot; + name
</code></pre>

<p>There are two lines that differ: we have</p>

<ul>
<li><code>def greet()</code> and <code>def say_hello</code></li>
<li><code>name = &quot;aanya&quot;</code> and <code>name = &quot;julia&quot;</code></li>
</ul>

<p>How do we know what to pick? It seems impossible!</p>

<p>But what if I told you that the original function was this (<code>base.py</code>)?</p>

<pre><code>def say_hello():
    greeting = &quot;hello&quot;
    name = &quot;julia&quot;
    return greeting + &quot; &quot; + name
</code></pre>

<p>Suddenly it seems a lot clearer! <code>v1</code> changed the function&rsquo;s name to <code>greet</code>
and <code>v2</code> set <code>name = &quot;aanya&quot;</code>. So to merge, we should make both those changes:</p>

<pre><code>def greet():
    greeting = &quot;hello&quot;
    name = &quot;aanya&quot;
    return greeting + &quot; &quot; + name
</code></pre>

<p>We can ask git to do this merge with <code>git merge-file</code>, and it gives us exactly
the result we expected: it picks <code>def greet()</code> and <code>name = &quot;aanya&quot;</code>.</p>

<pre><code>$ git merge-file v1.py base.py v2.py -p
def greet():
    greeting = &quot;hello&quot;
    name = &quot;aanya&quot;
    return greeting + &quot; &quot; + name‚èé
</code></pre>

<p>This way of merging where you merge 2 files + their original version is called
a <strong>3-way merge</strong>.</p>

<p>If you want to try it out yourself in a browser, I made a little playground at
<a href="https://jvns.ca/3-way-merge/">jvns.ca/3-way-merge/</a>. I made it very quickly so it&rsquo;s not mobile friendly.</p>

<h3 id="git-merges-changes-not-files">git merges changes, not files</h3>

<p>The way I think about the 3-way merge is &ndash; git merges <strong>changes</strong>, not files.
We have an original file and 2 possible changes to it, and git tries to combine
both of those changes in a reasonable way. Sometimes it can&rsquo;t (for example if
both changes change the same line), and then you get a merge conflict.</p>

<p>Git can also merge more than 2 possible changes: you can have an original file
and 8 possible changes, and it can try to reconcile all of them. That&rsquo;s called
an octopus merge but I don&rsquo;t know much more than that, I&rsquo;ve never done one.</p>

<h3 id="how-git-uses-3-way-merge-to-apply-a-patch">how git uses 3-way merge to apply a patch</h3>

<p>Now let&rsquo;s get a little weird! When we talk about git &ldquo;applying a patch&rdquo; (as you
do in a <code>rebase</code> or <code>revert</code> or <code>cherry-pick</code>), it&rsquo;s not actually creating a
patch file and applying it. Instead, it&rsquo;s doing a 3-way merge.</p>

<p>Here&rsquo;s how applying commit <code>X</code> as a patch to your current commit corresponds to
this <code>v1</code>, <code>v2</code>, and <code>base</code> setup from before:</p>

<ol>
<li>The version of the file <strong>in your current commit</strong> is <code>v1</code>.</li>
<li>The version of the file <strong>before commit X</strong> is <code>base</code></li>
<li>The version of the file <strong>in commit X</strong>. Call that <code>v2</code></li>
<li>Run <code>git merge-file v1 base v2</code> to combine them (technically git does not
actually run <code>git merge-file</code>, it runs a C function that does it)</li>
</ol>

<p>Together, you can think of <code>base</code> and <code>v2</code> as being the &ldquo;patch&rdquo;: the diff between
them is the change that you want to apply to <code>v1</code>.</p>

<h3 id="how-cherry-pick-works">how cherry-pick works</h3>

<p>Let&rsquo;s say we have this commit graph, and we want to cherry-pick <code>Y</code> on to <code>main</code>:</p>

<pre><code>A - B (main)
 \
  \
   X - Y - Z
</code></pre>

<p>How do we turn that into a 3-way merge? Here&rsquo;s how it translates into our <code>v1</code>, <code>v2</code> and <code>base</code> from earlier:</p>

<ul>
<li><code>B</code> is v1</li>
<li><code>X</code> is the base, <code>Y</code> is v2</li>
</ul>

<p>So together <code>X</code> and <code>Y</code> are the &ldquo;patch&rdquo;.</p>

<p>And <code>git rebase</code> is just like <code>git cherry-pick</code>, but repeated a bunch of times.</p>

<h3 id="how-revert-works">how revert works</h3>

<p>Now let&rsquo;s say we want to run <code>git revert Y</code> on this commit graph</p>

<pre><code>X - Y - Z - A - B
</code></pre>

<ul>
<li><code>B</code> is v1</li>
<li><code>Y</code> is the base, <code>X</code> is v2</li>
</ul>

<p>This is exactly like a cherry-pick, but with <code>X</code> and <code>Y</code> reversed. We have to
flip them because we want to apply a &ldquo;reverse patch&rdquo;.</p>

<p>Revert and cherry-pick are so closely related in git that they&rsquo;re actually
implemented in the same file:
<a href="https://github.com/git/git/blob/dadef801b365989099a9929e995589e455c51fed/builtin/revert.c">revert.c</a>.</p>

<h3 id="this-3-way-patch-is-a-really-cool-trick">this &ldquo;3-way patch&rdquo; is a really cool trick</h3>

<p>This trick of using a 3-way merge to apply a commit as a patch seems really
clever and cool and I&rsquo;m surprised that I&rsquo;d never heard of it before! I don&rsquo;t
know of a name for it, but I kind of want to call it a &ldquo;3-way patch&rdquo;.</p>

<p>The idea is that with a 3-way patch, you specify the patch as 2 files: the file
before the patch and after (<code>base</code> and <code>v2</code> in our language in this post).</p>

<p>So there are 3 files involved: 1 for the original and 2 for the patch.</p>

<p>The point is that the 3-way patch is a much better way to patch than a normal
patch, because you have a lot more context for merging when you have
both full files.</p>

<p>Here&rsquo;s more or less what a normal patch for our example looks like:</p>

<pre><code>@@ -1,1 +1,1 @@:
- def greet():
+ def say_hello():
    greeting = &quot;hello&quot;
</code></pre>

<p>and a 3-way patch. This &ldquo;3-way patch&rdquo; is not a real file format, it&rsquo;s just
something I made up.</p>

<pre><code>BEFORE: (the full file)
def greet():
    greeting = &quot;hello&quot;
    name = &quot;julia&quot;
    return greeting + &quot; &quot; + name
AFTER: (the full file)
def say_hello():
    greeting = &quot;hello&quot;
    name = &quot;julia&quot;
    return greeting + &quot; &quot; + name
</code></pre>

<h3 id="building-git-talks-about-this">&ldquo;Building Git&rdquo; talks about this</h3>

<p>The book <a href="https://shop.jcoglan.com/building-git/">Building Git</a> by James Coglan
is the only place I could find other than the git source code explaining how
<code>git cherry-pick</code> actually uses 3-way merge under the hood (I thought Pro Git might
talk about it, but it didn&rsquo;t seem to as far as I could tell).</p>

<p>I actually went to buy it and it turned out that I&rsquo;d already bought it in 2019
so it was a good reference to have here :)</p>

<h3 id="merging-is-actually-much-more-complicated-than-this">merging is actually much more complicated than this</h3>

<p>There&rsquo;s more to merging in git than the 3-way merge &ndash; there&rsquo;s something
called a &ldquo;recursive merge&rdquo; that I don&rsquo;t understand, and there are a bunch of
details about how to deal with handling file deletions and moves, and there are
also multiple merge algorithms.</p>

<p>My best idea for where to learn more about this stuff is Building Git, though I
haven&rsquo;t read the whole thing.</p>

<h3 id="so-what-does-git-apply-do">so what does <code>git apply</code> do?</h3>

<p>I also went looking through git&rsquo;s source to find out what <code>git apply</code> does, and it
seems to (unsurprisingly) be in <code>apply.c</code>. That code parses a patch file, and
then hunts through the target file to figure out where to apply it. The core logic
seems to be <a href="https://github.com/git/git/blob/dadef801b365989099a9929e995589e455c51fed/apply.c#L2684">around here</a>:
I think the idea is to start at the line number that the patch suggested and
then hunt forwards and backwards from there to try to find it:</p>

<pre><code>	/*
	 * There's probably some smart way to do this, but I'll leave
	 * that to the smart and beautiful people. I'm simple and stupid.
	 */
	backwards = current;
	backwards_lno = line;
	forwards = current;
	forwards_lno = line;
	current_lno = line;
  for (i = 0; ; i++) {
     ...
</code></pre>

<p>That all seems pretty intuitive and about what I&rsquo;d naively expect.</p>

<h3 id="how-git-apply-3way-works">how <code>git apply --3way</code> works</h3>

<p><code>git apply</code> also has a <code>--3way</code> flag that does a 3-way merge. So we actually
could have more or less implemented <code>git cherry-pick</code> with <code>git apply</code> like
this:</p>

<pre><code>$ git show 10e96e46 --patch &gt; out.patch
$ git apply out.patch --3way
Applied patch to 'content/post/2023-07-28-why-is-dns-still-hard-to-learn-.markdown' with conflicts.
U content/post/2023-07-28-why-is-dns-still-hard-to-learn-.markdown
</code></pre>

<p><code>--3way</code> doesn&rsquo;t just use the contents of the patch file  though! The patch file starts with:</p>

<pre><code>index d63ade04..65778fc0 100644
</code></pre>

<p><code>d63ade04</code> and <code>65778fc0</code> are the IDs of the old/new versions of that file in
git&rsquo;s object database, so git can retrieve them to do a 3-way patch
application. This won&rsquo;t work if someone emails you a patch and you don&rsquo;t have
the files for the new/old versions of the file though: if you&rsquo;re missing the
blobs you&rsquo;ll get this error:</p>

<pre><code>$ git apply out.patch
error: repository lacks the necessary blob to perform 3-way merge.
</code></pre>

<h3 id="that-s-all">that&rsquo;s all!</h3>

<p>I was pretty surprised to learn that I didn&rsquo;t actually understand the core way
that git applies patches internally &ndash; it was really cool to learn about!</p>

<p>I have <a href="https://jvns.ca/blog/2023/11/01/confusing-git-terminology/">lots of issues</a> with git&rsquo;s UI but I think this particular thing is not
one of them. The 3-way merge seems like a nice unified way to solve a bunch of
different problems, it&rsquo;s pretty intuitive for people (the idea of &ldquo;applying a
patch&rdquo; is one that a lot of programmers are used to thinking about, and the
fact that it&rsquo;s implemented as a 3-way merge under the hood is an implementation
detail that nobody actually ever needs to think about).</p>

<p><small>
Also a very quick plug: I&rsquo;m working on writing a
<a href="https://wizardzines.com">zine</a> about git, if you&rsquo;re interested in getting an email when it comes out you can
sign up to my <a href="https://wizardzines.com/zine-announcements/">very infrequent announcements mailing list</a>.
</small></p>

  </body>
</html>
