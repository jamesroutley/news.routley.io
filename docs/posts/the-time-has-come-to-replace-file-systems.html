<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://didgets.substack.com/p/where-did-i-put-that-file">Original</a>
    <h1>The time has come to replace file systems</h1>
    
    <div id="readability-page-1" class="page"><div><div><article><div><div dir="auto"><p>If you have ever forgotten where you stored a file in a file system, you know that finding it can be a real challenge. File systems let you store any file in any folder, regardless of whether the folder path is appropriate for the file. Even if you remember some parts of the file name, it can take a long time to search through a large folder tree looking for it. Sometimes the application that stored it when you hit the ‘save’ button, didn’t even bother to tell you where it put it.</p><p>Documents, photos, and other common types of files often have several different formats (and the file extensions that accompany them) so searching by file extension may or may not turn up the file you were looking for. File systems are also designed to know only about the files in their managed volume, so even if you have multiple volumes of the same file system type (e.g. NTFS or Ext4) stored on the same physical hard disk drive; you must search each volume independently.</p><p>The time it takes to find a file is often dependent upon how many other files are present in the system. Like finding a needle in a haystack, it really depends upon the size of the haystack when figuring out how long it might take to find the needle.</p><p>File systems were invented decades ago when the largest physical drives were measured in megabytes and could only store a few hundred files on them.  Today’s hard drives (HDDs) and solid state drives (SDDs) are measured in terabytes (millions of times bigger). HDD manufacturers have recently announced drives that will hold more than 20TB. If the average size of a file is 100,000 bytes; this means you can store about 200 million files before the drive is full. That is one big haystack!</p><p>Even though numerous improvements have been made to file systems over the years; they are all still based on the same basic architecture from decades ago. They are not designed to classify files and quickly search for a single file or groups of files easily. Applications that help with searching are still required to do a hierarchical tree traversal using sequential search functions (e.g. findNext or readdir) which are slow by nature.</p><p>Having a separate indexing service such as Microsoft’s Windows Search or Apple’s Spotlight, can greatly speed up searching; but these are not an integral part of the file system so they have to store their indexing information in a separate database. It is easy for the database to become out of synchronization with the file system. Also, to speed up the indexing process, users often only index a portion of the file system so using the index might not turn up the file(s) you were looking for.</p><p>Fast searching is just one of the problems that plague today’s file systems. As someone who has worked with file systems and databases since the 1980s, I have come up with a long laundry list of things a data storage system should do better. Many of the problems cannot be solved with just minor changes to the existing file system architecture. I believe that the time has come to completely replace file systems with something better!</p><p>Rather than list all the problems in this article, I will limit it to my ‘Top 5’ problems for brevity. I have designed and developed a new system called ‘Didgets’ that I think solves these problems and many others. Didgets (short for data widgets) are intelligent data objects that can efficiently manage large amounts of unstructured or structured data. Whether file systems are replaced by Didgets or some other similar system, the problems will persist until these issues are addressed:</p><ol><li><p>The fixed-size metadata record for each file is too big. Reading in and caching the entire file table takes too long and uses too much memory.</p></li><li><p>The metadata record does not have a file classification system. To determine what is in a file, the file name or the data stream must be examined.</p></li><li><p>File systems do not have a uniform tagging system that is easily and quickly searchable by applications.</p></li><li><p>Each file’s unique identifier is its full path name. If the name changes or the file is moved to a different folder, any stored references to it become invalid.</p></li><li><p>Files cannot be protected against malicious code. Virus detection software must examine every single file to ensure the system is safe. </p></li></ol><p>Every file system has a file table that stores a record for each file. The size of this record in popular file systems can range from 256 bytes (Ext4) to 1024 bytes (NTFS). This means that if you have 200 million records in the table; then between 50GB and 200GB of data must be read in and cached if you want to do lots of fast searches. Disk transfer speeds have certainly increased and memory is cheaper than ever, but that is still a lot of data. With Didgets, each record is only 64 bytes which means a table with 200 million records is less than 13GB total, which is much more manageable.</p><p>With Didgets, there is a small field in its metadata record  that tells whether the file is a photo or a document or a video or some other type. Searches can be exceptionally fast. On my development machine, I can find all 20 million photos (out of 200 million files) in under 2 seconds. Fast searches like this are impossible if you have to compare file name extensions.</p><p>File systems use folder names as a general way to organize data. Some file systems support things like extended attributes that let you attach tags to your files. None of them make finding files based off metadata tags quick and easy. Didgets let you attach up to 255 tags to any Didget and find all of them that share a common tag in seconds.</p><p>The unique identifier for a Didget is a 64 bit number. It remains consistent throughout the life of that Didget. It doesn’t change when you assign it a different name (names are just another tag) or put it in a different list (e.g. folder). Any stored references to the Didget remain valid until it is deleted.</p><p>Unlike a file, a Didget’s data stream can be permanently immutable. The file system read-only attribute is just a suggestion to any application, which can ignore it. For Didgets, the immutable attribute is enforced by the system with no way around it. No application can modify the contents of a read-only Didget no matter what user permissions it might have.</p><p>If HDD and SDD capacities continue on their current trajectory, storage systems may exceed 100TB for the average user within the next decade. Files will be kept forever and finding a single file or a group of them will become harder and more time consuming if file systems are not replaced with something better.</p><p>Watch a 4 minute demo video: </p><p id="youtube2-dWIo6sia_hw" data-attrs="{&#34;videoId&#34;:&#34;dWIo6sia_hw&#34;,&#34;startTime&#34;:null,&#34;endTime&#34;:null}"><iframe src="https://www.youtube-nocookie.com/embed/dWIo6sia_hw?rel=0&amp;autoplay=0&amp;showinfo=0&amp;enablejsapi=0" frameborder="0" loading="lazy" gesture="media" allow="autoplay; fullscreen" allowautoplay="true" allowfullscreen="true" width="728" height="409"></iframe></p></div></div></article></div></div></div>
  </body>
</html>
