<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hodlbod.npub.pro/post/1739830562159/">Original</a>
    <h1>Svelte 5 is not JavaScript</h1>
    
    <div id="readability-page-1" class="page"><div event="naddr1qqxnzden8yurxvp4xcerzdfeqgsf03c2gsmx5ef4c9zmxvlew04gdh7u94afnknp33qvv3c94kvwxgsrqsqqqa28ae4fzd"><p>For the last couple of weeks, I&#39;ve been dealing with the fallout of upgrading a web application to Svelte 5. Complaints about framework churn and migration annoyances aside, I&#39;ve run into some interesting issues with the migration. So far, I haven&#39;t seen many other people register the same issues, so I thought it might be constructive for me to articulate them myself.</p>
    <p>I&#39;ll try not to complain too much in this post, since I&#39;m grateful for the many years of Svelte 3/4 I&#39;ve enjoyed. But I don&#39;t think I&#39;ll be choosing Svelte for any new projects going forward. I hope my reflections here will be useful to others as well.</p>
    <p>If you&#39;re interested in reproductions for the issues I mention here, you can find them below.</p>
    <ul>
    <li><a href="https://github.com/sveltejs/svelte/issues/15327">Can&#39;t save state to indexeddb</a></li>
    <li><a href="https://github.com/sveltejs/svelte/issues/15327">Component unmount results in undefined variables in closures</a></li>
    </ul>
    
    <p>To start with, let me just quickly acknowledge what the Svelte team is trying to do. It seems like most of the substantial changes in version 5 are built around &#34;deep reactivity&#34;, which allows for more granular reactivity, leading to better performance. Performance is good, and the Svelte team has always excelled at reconciling performance with DX.</p>
    <p>In previous versions of Svelte, the main way this was achieved was with the Svelte compiler. There were many ancillary techniques involved in improving performance, but having a framework compile step gave the Svelte team a lot of leeway for rearranging things under the hood without making developers learn new concepts. This is what made Svelte so original in the beginning.</p>
    <p>At the same time, it resulted in an even more opaque framework than usual, making it harder for developers to debug more complex issues. To make matters worse, the compiler had bugs, resulting in errors which could only be fixed by blindly refactoring the problem component. This happened to me personally at least half a dozen times, and is what ultimately pushed me to migrate to Svelte 5.</p>
    <p>Nevertheless, I always felt it was an acceptable trade-off for speed and productivity. Sure, sometimes I had to delete my project and port it to a fresh repository every so often, but the framework was truly a pleasure to use.</p>
    
    <p>Svelte 5 doubled down on this tradeoff — which makes sense, because it&#39;s what sets the framework apart. The difference this time is that the abstraction/performance tradeoff did not stay in compiler land, but intruded into runtime in two important ways:</p>
    <ul>
    <li>The use of proxies to support deep reactivity</li>
    <li>Implicit component lifecycle state</li>
    </ul>
    <p>Both of these changes improved performance <em>and</em> made the API for developers look slicker. What&#39;s not to like? Unfortunately, both of these features are classic examples of a <a href="https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/">leaky abstraction</a>, and ultimately make things <em>more</em> complex for developers, not less.</p>
    <h2>Proxies are not objects</h2>
    <p>The use of proxies seems to have allowed the Svelte team to squeeze a little more performance out of the framework, without asking developers to do any extra work. Threading state through multiple levels of components without provoking unnecessary re-renders in frameworks like React is an infamously difficult chore.</p>
    <p>Svelte&#39;s compiler avoided some of the pitfalls associated with virtual DOM diffing solutions, but evidently there was still enough of a performance gain to be had to justify the introduction of proxies. The Svelte team also <a href="https://svelte.dev/blog/runes">seems to argue</a> that their introduction represents an improvement in developer experience:</p>
    <blockquote>
    <p>we... can maximise both efficiency and ergonomics.</p>
    </blockquote>
    <p>Here&#39;s the problem: Svelte 5 <em>looks</em> simpler, but actually introduces <em>more</em> abstractions.</p>
    <p>Using proxies to monitor array methods (for example) is appealing because it allows developers to forget all the goofy heuristics involved with making sure state was reactive and just <code>push</code> to the array. I can&#39;t count how many times I&#39;ve written <code>value = value</code> to trigger reactivity in svelte 4.</p>
    <p>In Svelte 4, developers had to understand how the Svelte compiler worked. The compiler, being a leaky abstraction, forced its users to know that assignment was how you signaled reactivity. In svelte 5, developers can just &#34;forget&#34; about the compiler!</p>
    <p>Except they can&#39;t. All the introduction of new abstractions really accomplishes is the introduction of more complex heuristics that developers have to keep in their heads in order to get the compiler to act the way they want it to.</p>
    <p>In fact, this is why after years of using Svelte, I found myself using Svelte stores more and more often, and reactive declarations less. The reason being that Svelte stores are <em>just javascript</em>. Calling <code>update</code> on a store is <em>simple</em>, and being able to reference them with a <code>$</code> was just a nice bonus — nothing to remember, and if I mess up the compiler yells at me.</p>
    <p>Proxies introduce a similar problem to reactive declarations, which is that they look like one thing but act like another on the edges.</p>
    <p>When I started using Svelte 5, everything worked great — until <a href="https://github.com/sveltejs/svelte/issues/15327">I tried to save a proxy to indexeddb</a>, at which point I got a <code>DataCloneError</code>. To make matters worse, it&#39;s impossible to reliably tell if something is a <code>Proxy</code> without <code>try/catch</code>ing a structured clone, which is a performance-intensive operation.</p>
    <p>This forces the developer to remember what is and what isn&#39;t a Proxy, calling <code>$state.snapshot</code> every time they pass a proxy to a context that doesn&#39;t expect or know about them. This obviates all the nice abstractions they gave us in the first place.</p>
    <h2>Components are not functions</h2>
    <p>The reason virtual DOM took off way back in 2013 was the ability to model your application as composed functions, each of which takes data and spits out HTML. Svelte retained this paradigm, using a compiler to sidestep the inefficiencies of virtual DOM and the complexities of lifecycle methods.</p>
    <p>In Svelte 5, component lifecycles are back, react-hooks style.</p>
    <p>In React, hooks are an abstraction that allows developers to avoid writing all the stateful code associated with component lifecycle methods. Modern React tutorials universally recommend using hooks instead, which rely on the framework invisibly synchronizing state with the render tree.</p>
    <p>While this does result in cleaner code, it also requires developers to tread carefully to avoid breaking the assumptions surrounding hooks. Just try accessing state in a <code>setTimeout</code> and you&#39;ll see what I mean.</p>
    <p>Svelte 4 had a few gotchas like this — for example, async code that interacts with a component&#39;s DOM elements has to keep track of whether the component is unmounted. This is pretty similar to the kind of pattern you&#39;d see in old React components that relied on lifecycle methods.</p>
    <p>It seems to me that Svelte 5 has gone the React 16 route by adding implicit state related to component lifecycles in order to coordinate state changes and effects.</p>
    <p>For example, here is an excerpt from the documentation for <a href="https://svelte.dev/docs/svelte/$effect">$effect</a>:</p>
    <blockquote>
    <p>You can place $effect anywhere, not just at the top level of a component, as long as it is called during component initialization (or while a parent effect is active). It is then tied to the lifecycle of the component (or parent effect) and will therefore destroy itself when the component unmounts (or the parent effect is destroyed).</p>
    </blockquote>
    <p>That&#39;s very complex! In order to use <code>$effect</code>... effectively (sorry), developers have to understand how state changes are tracked. The <a href="https://svelte.dev/docs/svelte/lifecycle-hooks">documentation for component lifecycles</a> claims:</p>
    <blockquote>
    <p>In Svelte 5, the component lifecycle consists of only two parts: Its creation and its destruction. Everything in-between — when certain state is updated — is not related to the component as a whole; only the parts that need to react to the state change are notified. This is because under the hood the smallest unit of change is actually not a component, it’s the (render) effects that the component sets up upon component initialization. Consequently, there’s no such thing as a “before update”/&#34;after update” hook.</p>
    </blockquote>
    <p>But then goes on to introduce the idea of <code>tick</code> in conjunction with <code>$effect.pre</code>. This section explains that &#34;<code>tick</code> returns a promise that resolves once any pending state changes have been applied, or in the next microtask if there are none.&#34;</p>
    <p>I&#39;m sure there&#39;s some mental model that justifies this, but I don&#39;t think the claim that a component&#39;s lifecycle is only comprised of mount/unmount is really helpful when an addendum about state changes has to come right afterward.</p>
    <p>The place where this really bit me, and which is the motivation for this blog post, is when state gets coupled to a component&#39;s lifecycle, even when the state is passed to another function that doesn&#39;t know anything about svelte.</p>
    <p>In my application, I manage modal dialogs by storing the component I want to render alongside its props in a store and rendering it in the <code>layout.svelte</code> of my application. This store is also synchronized with browser history so that the back button works to close them. Sometimes, it&#39;s useful to pass a callback to one of these modals, binding caller-specific functionality to the child component:</p>
    <pre><code>const {value} = $props()
    const callback = () =&gt; console.log(value)
    const openModal = () =&gt; pushModal(MyModal, {callback})
    </code></pre>
    <p>This is a fundamental pattern in javascript. Passing a callback is just one of those things you do.</p>
    <p>Unfortunately, if the above code lives in a modal dialog itself, the caller component gets unmounted before the callback gets called. In Svelte 4, this worked fine, but in Svelte 5 <code>value</code> gets updated to <code>undefined</code> when the component gets unmounted. <a href="https://github.com/sveltejs/svelte/issues/15325">Here&#39;s a minimal reproduction</a>.</p>
    <p>This is only one example, but it seems clear to me that <em>any</em> prop that is closed over by a callback function that lives longer than its component will be undefined when I want to use it — with no reassignment existing in lexical scope.</p>
    <p>This just isn&#39;t how javascript works. And I think the reason Svelte works this way is that it is attempting to re-invent garbage collection. Because <code>value</code> is a prop of the component, it apparently has to be cleaned up at the end of the component&#39;s lifecycle. I&#39;m sure there&#39;s a good engineering reason for this, but it is surprising.</p>
    
    <p>Easy things are nice, but as Rich Hickey says, <a href="https://www.infoq.com/presentations/Simple-Made-Easy/">easy things are not always simple</a>. And like Joel Spolsky, I don&#39;t like being surprised. Svelte has always been full of magic, but with the latest release I think the cognitive overhead of reciting incantations has finally outweighed the power it confers.</p>
    <p>My point in this post is not to dunk on the Svelte team. I know lots of people like Svelte 5 (and react hooks). The point I&#39;m trying to make is that there is a tradeoff between doing things for the user, and giving the user agency. Good software is built on understanding, not cleverness.</p>
    <p>I also think this is an important lesson to remember as AI-assisted coding becomes increasingly popular. Don&#39;t choose tools that alienate you from your work. Choose tools that leverage the wisdom you&#39;ve already accumulated, and which help you to cultivate a deeper understanding of the discipline.</p>
    <p>Thank you to Rich Harris and team for many years of pleasant development. I hope that (if you read this) it&#39;s not <em>so</em> full of inaccuracies as to be unhelpful as user feedback.</p>
    </div></div>
  </body>
</html>
