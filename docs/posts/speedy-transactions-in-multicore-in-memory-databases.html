<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://muratbuffalo.blogspot.com/2023/02/speedy-transactions-in-multicore-in.html">Original</a>
    <h1>Speedy Transactions in Multicore In-Memory Databases</h1>
    
    <div id="readability-page-1" class="page"><div>

<main id="main" role="main" tabindex="-1">
<div id="page_body" name="Page Body">
<div data-version="2" id="Blog1">
<div>
<article>
<div>
<div>

<h3>
 Speedy Transactions in Multicore In-Memory Databases
</h3>


<div id="post-body-6508653951025562814">
<p><a href="https://people.csail.mit.edu/stephentu/papers/silo.pdf">This paper is from SOSP&#39;13.</a> The Polyjuice paper, <a href="https://muratbuffalo.blogspot.com/2023/02/polyjuice-high-performance-transactions.html">which we studied last week,</a> built on the Silo codebase and commit protocol, which led me to read the Silo paper. </p><p><a href="https://blogger.googleusercontent.com/img/a/AVvXsEgVTJZ2YaOuwp1LYlLucTKQtPqsmI1KA4-SebPQokN80j7oBfmuS-ynQ3EqYcxChyOxPoyb63vtP2iNyK5sMDDmmADEb0iYDZH-Iu8_tsX8iZxUL-5q7zmXGJt-daTTTfNX6xi4WFQQGg8pY3CVdwlNaWcNIN9pJ5fIhCz3Xcb7lOWRBmfxLnOXqgyo"><img alt="" data-original-height="1334" data-original-width="1258" height="400" src="https://blogger.googleusercontent.com/img/a/AVvXsEgVTJZ2YaOuwp1LYlLucTKQtPqsmI1KA4-SebPQokN80j7oBfmuS-ynQ3EqYcxChyOxPoyb63vtP2iNyK5sMDDmmADEb0iYDZH-Iu8_tsX8iZxUL-5q7zmXGJt-daTTTfNX6xi4WFQQGg8pY3CVdwlNaWcNIN9pJ5fIhCz3Xcb7lOWRBmfxLnOXqgyo=w377-h400" width="377"/></a></p></div>

</div>
</div>

</article>
</div>
</div><div data-version="2" id="PopularPosts1">
<h3>
Popular posts from this blog
</h3>
<div>
<div role="feed">
<article role="article">
<h3><a href="http://muratbuffalo.blogspot.com/2021/02/foundational-distributed-systems-papers.html"> Foundational distributed systems papers</a></h3>

<div>
<div>
<p>
I talked about the importance of reading foundational papers  last week. To followup, here is my compilation of foundational papers in the distributed systems area. (I focused on the core distributed systems area, and did not cover networking, security, distributed ledgers, verification work etc. I even left out distributed transactions, I hope to cover them at a later date.)  I classified the papers by subject, and listed them in chronological order. I also listed expository papers and blog posts at the end of each section. Time and State in Distributed Systems Time, Clocks, and the Ordering of Events in a Distributed System.  Leslie Lamport, Commn. of the ACM,  1978. Distributed Snapshots: Determining Global States of a Distributed System.  K. Mani Chandy Leslie Lamport, ACM Transactions on Computer Systems, 1985. Virtual Time and Global States of Distributed Systems.  Mattern, F. 1988. Practical uses of synchronized clocks in distributed systems.  B. Liskov, 1991.  Expository papers
</p>
</div>

</div>
</article>
<article role="article">
<h3><a href="http://muratbuffalo.blogspot.com/2022/08/strict-serializability-but-at-what-cost.html">Strict-serializability, but at what cost, for what purpose?</a></h3>

<div>
<p><a href="http://muratbuffalo.blogspot.com/2022/08/strict-serializability-but-at-what-cost.html">
<img alt="Image" sizes="72px" src="https://blogger.googleusercontent.com/img/a/AVvXsEgDxQ2mnmH2lMCeD8Mm1cJ8HFM_PI1XtzNUQXppIyI9wpS4ol0P_ZvMM_B8K92NW5n528f4GcWG2aDp68A_xkdrRGDpDiEZIQWA9vlv5kmyh3Ds30BrKdv4V6Y7qYoopXpImGtdx1xy_jDS_kR_Bxr--yeJ9oeuC-d63G_PUW6l4S0iHr9ZPaXWsUdd=w388-h400" srcset="https://blogger.googleusercontent.com/img/a/AVvXsEgDxQ2mnmH2lMCeD8Mm1cJ8HFM_PI1XtzNUQXppIyI9wpS4ol0P_ZvMM_B8K92NW5n528f4GcWG2aDp68A_xkdrRGDpDiEZIQWA9vlv5kmyh3Ds30BrKdv4V6Y7qYoopXpImGtdx1xy_jDS_kR_Bxr--yeJ9oeuC-d63G_PUW6l4S0iHr9ZPaXWsUdd=w72-h72-p-k-no-nu 72w, https://blogger.googleusercontent.com/img/a/AVvXsEgDxQ2mnmH2lMCeD8Mm1cJ8HFM_PI1XtzNUQXppIyI9wpS4ol0P_ZvMM_B8K92NW5n528f4GcWG2aDp68A_xkdrRGDpDiEZIQWA9vlv5kmyh3Ds30BrKdv4V6Y7qYoopXpImGtdx1xy_jDS_kR_Bxr--yeJ9oeuC-d63G_PUW6l4S0iHr9ZPaXWsUdd=w144-h144-p-k-no-nu 144w"/>
</a>
</p>
<div>
<p>
Strict-serializability guarantees that transactions appear to occur in an order consistent with the &#34;real-time&#34; ordering of those transactions: If transaction T1 commits before transaction T2 is invoked, then the commit timestamp of T1 precedes the commit timestamp of T2.  This is, in fact, the real-time constraint from linearizability , but applied across transactions not just per-key. A strict-serializability system satisfies both serializability (transactions appear to occur as if they are executed one at a time in isolation) and linearizability per key (after all single-key reads/writes are transactions over one item). Below figure is from https://jepsen.io/consistency . However, this is a one-way implication, the other direction does not hold. You can satisfy both serializability per transactions and linearizability per key, but fail to satisfy strict-serializability. (Below I give an example accompanied with a TLA+ specification to check it.) This is because, in strict-
</p>
</div>

</div>
</article>
<article role="article">
<h3><a href="http://muratbuffalo.blogspot.com/2020/06/learning-about-distributed-systems.html"> Learning about distributed systems: where to start?</a></h3>

<div>
<div>
<p>
This is definitely not a &#34;learn distributed systems in 21 days&#34; post. I recommend a principled, from the foundations-up, studying of distributed systems, which will take a good three months in the first pass, and many more months to build competence after that.   If you are practical and coding oriented you may not like my advice much. You may object saying, &#34;Shouldn&#39;t I learn distributed systems with coding and hands on? Why can I not get started by deploying a Hadoop cluster, or studying the Raft code.&#34; I think that is the wrong way to go about learning distributed systems, because seeing similar code and programming language constructs will make you think this is familiar territory, and will give you a false sense of security. But, nothing can be further from the truth.   Distributed systems need radically different software than centralized systems do.    --A. Tannenbaum  This quotation is literally the first sentence in my distributed systems syllabus. Inst
</p>
</div>

</div>
</article>
<article role="article">
<h3><a href="http://muratbuffalo.blogspot.com/2022/03/cockroachdb-resilient-geo-distributed.html">CockroachDB: The Resilient Geo-Distributed SQL Database</a></h3>

<div>
<p><a href="http://muratbuffalo.blogspot.com/2022/03/cockroachdb-resilient-geo-distributed.html">
<img alt="Image" sizes="72px" src="https://blogger.googleusercontent.com/img/a/AVvXsEjPXzlc-0S3Mw2IqC_xZ_XFbxtlo5DWQ5_VrqBgwd7ZyGg__bfgmwdtky6fvgOCCn0ez_pBvbI41tZ4OPyx48oNNauQfKlUMyA8ziyf6Mv0ULzCD-pmmSHzzlikzUGmZXvE5ytaG9rge-QqW9lIT0TbcTv7a5rkSrdGEL4nMSOjh_fRqVqUnQPNHKCt=w640-h336" srcset="https://blogger.googleusercontent.com/img/a/AVvXsEjPXzlc-0S3Mw2IqC_xZ_XFbxtlo5DWQ5_VrqBgwd7ZyGg__bfgmwdtky6fvgOCCn0ez_pBvbI41tZ4OPyx48oNNauQfKlUMyA8ziyf6Mv0ULzCD-pmmSHzzlikzUGmZXvE5ytaG9rge-QqW9lIT0TbcTv7a5rkSrdGEL4nMSOjh_fRqVqUnQPNHKCt=w72-h72-p-k-no-nu 72w, https://blogger.googleusercontent.com/img/a/AVvXsEjPXzlc-0S3Mw2IqC_xZ_XFbxtlo5DWQ5_VrqBgwd7ZyGg__bfgmwdtky6fvgOCCn0ez_pBvbI41tZ4OPyx48oNNauQfKlUMyA8ziyf6Mv0ULzCD-pmmSHzzlikzUGmZXvE5ytaG9rge-QqW9lIT0TbcTv7a5rkSrdGEL4nMSOjh_fRqVqUnQPNHKCt=w144-h144-p-k-no-nu 144w"/>
</a>
</p>
<div>
<p>
This paper appeared in Sigmod 2020.  Here is a link to the 10 minute, but extremely useful, Sigmod presentation . There is also a 1 hour extended presentation . CockroachDB is open source available via GitHub.  The core features of the database are under a Business Source License (BSL), which converts to a fully open-source Apache 2.0 license after three years. Storage layer CockroachDB (or CRDB for short) consists of a distributed SQL layer on top of a distributed key-value store. The key value store is laid out in a single monolithic ordered key space. The logical key space is physically realized by dividing it into contiguous ranges of keys which we call ranges. Ranges are about 64 megabytes in size. Ranges start empty, grow, and split when they get too large, and merge with their neighbors when they get too small. The ranges are sorted, and I will talk about why in the SQL discussion later. As we will discuss soon, CRDB uses multi-version concurrency control. Hybrid logical clocks 
</p>
</div>

</div>
</article>
<article role="article">
<h3><a href="http://muratbuffalo.blogspot.com/2022/03/amazon-aurora-design-considerations-and.html">Amazon Aurora: Design Considerations + On Avoiding Distributed Consensus for I/Os, Commits, and Membership Changes</a></h3>

<div>
<p><a href="http://muratbuffalo.blogspot.com/2022/03/amazon-aurora-design-considerations-and.html">
<img alt="Image" sizes="72px" src="https://blogger.googleusercontent.com/img/a/AVvXsEgI54uHOcq3J-jWzODaNj344vGfbLaKv9duh3wvYpJ3TCD8GRYa7DjZ8wIkuFnJtZeTEEOnWArweSeA7VD4gGeaqUzunaQr2cvbvnQ9hg8kkWETn4mP7KarlhuspN2BfK2bSrPOupEWpzhygRIowrHSfL7Rp4WWdkYq7MKc6YdXcvr054DWoiI77IJj=w400-h312" srcset="https://blogger.googleusercontent.com/img/a/AVvXsEgI54uHOcq3J-jWzODaNj344vGfbLaKv9duh3wvYpJ3TCD8GRYa7DjZ8wIkuFnJtZeTEEOnWArweSeA7VD4gGeaqUzunaQr2cvbvnQ9hg8kkWETn4mP7KarlhuspN2BfK2bSrPOupEWpzhygRIowrHSfL7Rp4WWdkYq7MKc6YdXcvr054DWoiI77IJj=w72-h72-p-k-no-nu 72w, https://blogger.googleusercontent.com/img/a/AVvXsEgI54uHOcq3J-jWzODaNj344vGfbLaKv9duh3wvYpJ3TCD8GRYa7DjZ8wIkuFnJtZeTEEOnWArweSeA7VD4gGeaqUzunaQr2cvbvnQ9hg8kkWETn4mP7KarlhuspN2BfK2bSrPOupEWpzhygRIowrHSfL7Rp4WWdkYq7MKc6YdXcvr054DWoiI77IJj=w144-h144-p-k-no-nu 144w"/>
</a>
</p>
<div>
<p>
Amazon Aurora is a high-throughput cloud-native relational database. I will summarize its design as covered by the Sigmod 17  and Sigmod 18  papers from the Aurora team. Aurora uses MySQL or PostgreSQL for the database instance at top, and decouples the storage to a multi-tenant scale-out storage service.  In this decoupled architecture, each database instance acts as a SQL endpoint and supports query processing, access methods, transactions, locking, buffer caching, and undo management. Some database functions, including redo logging, materialization of data blocks, garbage collection, and backup/restore, are offloaded to the storage nodes. A big innovation in Aurora is to do the replication among the storage  nodes by pushing the redo log; this reduces networking traffic and  enables fault-tolerant storage that heals without database involvement. In contrast to CockroachDB  and FoundationDB , Aurora manages not to use consensus at all. It uses a primary secondary failover at the comp
</p>
</div>

</div>
</article>
<article role="article">
<h3><a href="http://muratbuffalo.blogspot.com/2022/04/anna-key-value-store-for-any-scale.html">Anna: A Key-Value Store For Any Scale</a></h3>

<div>
<p><a href="http://muratbuffalo.blogspot.com/2022/04/anna-key-value-store-for-any-scale.html">
<img alt="Image" sizes="72px" src="https://blogger.googleusercontent.com/img/a/AVvXsEgJAP34N-KhzUICKVTkx2LLmkvr-fmRbHf0VESi-vwFPo5XKGYnQ75rF0X7UNS0qiAAV3VhtLwq4zDG5C0GpsnRFGxMcTAE645RIF7o-vxzLsuICgwhnBAMnDCJ538avGxdQD289SI4vHVL-kYjapDom1U79eBCxJmAGwtbygSdwlgXLzPhNCGdDCQ-=s16000" srcset="https://blogger.googleusercontent.com/img/a/AVvXsEgJAP34N-KhzUICKVTkx2LLmkvr-fmRbHf0VESi-vwFPo5XKGYnQ75rF0X7UNS0qiAAV3VhtLwq4zDG5C0GpsnRFGxMcTAE645RIF7o-vxzLsuICgwhnBAMnDCJ538avGxdQD289SI4vHVL-kYjapDom1U79eBCxJmAGwtbygSdwlgXLzPhNCGdDCQ-=w72-h72-p-k-no-nu 72w, https://blogger.googleusercontent.com/img/a/AVvXsEgJAP34N-KhzUICKVTkx2LLmkvr-fmRbHf0VESi-vwFPo5XKGYnQ75rF0X7UNS0qiAAV3VhtLwq4zDG5C0GpsnRFGxMcTAE645RIF7o-vxzLsuICgwhnBAMnDCJ538avGxdQD289SI4vHVL-kYjapDom1U79eBCxJmAGwtbygSdwlgXLzPhNCGdDCQ-=w144-h144-p-k-no-nu 144w"/>
</a>
</p>
<div>
<p>
This paper (ICDE&#39;18) introduces Anna,  a CALM / CRDT  implementation of a distributed key-value system both at the data structure level as well as system architecture and transaction protocol levels. Anna is a partitioned, multi-mastered key-value system that achieves high performance and elasticity via wait-free execution and coordination-free consistency. Anna employs coordination-free actors that perform state update via merge of lattice-based composite data structures. I love the strongly opinionated introduction of this paper. This is what papers should be about: opinionated, challenging conventions, making bets, and doing hypothesis testing in the small. Conventional wisdom says that  software designed for one scale point needs to be rewritten when scaling up by 10x. Anna  sets out to disprove this by showing how a key-value storage (KVS) system can be architected to scale across many orders of magnitude. (Spoiler Anna can give you only upto causal consistency, but cannot pro
</p>
</div>

</div>
</article>
<article role="article">
<h3><a href="http://muratbuffalo.blogspot.com/2022/08/the-seattle-report-on-database-research.html">The Seattle Report on Database Research (2022)</a></h3>

<div>
<div>
<p>
Every 5 years, researchers from academia and industry gather to write a state-of-the-union (SOTU) report on database research. This one was released recently . It is a very readable report, and my summary consists of important paragraphs clipped from the report. Emphasis mine in bolded sentences. I use square brackets for when I paraphrase a long text with a more direct statement. TL;DR: The SOTU is strong (the relational database market alone has revenue upwards of $50B) and growing stronger thanks to boom in cloud computing and machine learning (ML). For the next 5 years, research should scale up to address emerging challenges in data science, data governance, cloud services, and database engines.   What has changed in the last 5 years Over the last decade, our research community pioneered the use of columnar storage, which is used in all commercial data analytic platforms. Database systems offered as cloud services have witnessed explosive growth. Hybrid transactional/analytical pro
</p>
</div>

</div>
</article>
<article role="article">
<h3><a href="http://muratbuffalo.blogspot.com/2022/05/warp-lightweight-multi-key-transactions.html">Warp: Lightweight Multi-Key Transactions for Key-Value Stores</a></h3>

<div>
<p><a href="http://muratbuffalo.blogspot.com/2022/05/warp-lightweight-multi-key-transactions.html">
<img alt="Image" sizes="72px" src="https://blogger.googleusercontent.com/img/a/AVvXsEjFAbCYdUi-THqc2dkePkBIQ1Y9KSHAdRI75dFmvtIT2XFg5Ms8TrCLDBWJjnMkmUsqm3NqwzHjO66MQl66lY1cLUEGM3HuSb-BjW0BtGVuqKT75qy7HEkpWyn7ewGk7USYRQ1tGuwQbtNEZJH-j3LgbpeX2Tb06tKKmX4JK1Y54eqBZBkBDh4PBDyP=w315-h400" srcset="https://blogger.googleusercontent.com/img/a/AVvXsEjFAbCYdUi-THqc2dkePkBIQ1Y9KSHAdRI75dFmvtIT2XFg5Ms8TrCLDBWJjnMkmUsqm3NqwzHjO66MQl66lY1cLUEGM3HuSb-BjW0BtGVuqKT75qy7HEkpWyn7ewGk7USYRQ1tGuwQbtNEZJH-j3LgbpeX2Tb06tKKmX4JK1Y54eqBZBkBDh4PBDyP=w72-h72-p-k-no-nu 72w, https://blogger.googleusercontent.com/img/a/AVvXsEjFAbCYdUi-THqc2dkePkBIQ1Y9KSHAdRI75dFmvtIT2XFg5Ms8TrCLDBWJjnMkmUsqm3NqwzHjO66MQl66lY1cLUEGM3HuSb-BjW0BtGVuqKT75qy7HEkpWyn7ewGk7USYRQ1tGuwQbtNEZJH-j3LgbpeX2Tb06tKKmX4JK1Y54eqBZBkBDh4PBDyP=w144-h144-p-k-no-nu 144w"/>
</a>
</p>
<div>
<p>
This paper  introduces a simple yet powerful idea to provide efficient multi-key transactions with ACID semantics on top of a sharded NoSQL data store. The Warp protocol prevents serializability cycles forming between concurrent transactions by forcing them to serialize via a chain communication pattern rather than using a parallel 2PC fan-out/fan-in communication. This avoids hotspots associated with fan-out/fan-in communication and prevents wasted parallel work from contacting multiple other servers when traversing them in serial would surface an invalidation/abortion early on in the serialization. I love the elegance of this idea. As far as I can see, this paper did not get published in any conference. The authors published a followup paper to this in NSDI 16, called &#34;The Design and Implementation of the Warp Transactional Filesystem.&#34;  But that paper does not talk about the internals of Warp protocol like this archive report, rather talks about the Warp Transactional File
</p>
</div>

</div>
</article>
<article role="article">
<h3><a href="http://muratbuffalo.blogspot.com/2021/12/learning-technical-subject.html">Learning a technical subject</a></h3>

<div>
<div>
<p>
I love learning.  I wanted to write about how I learn, so I can analyze if there is a method to this madness. I will first talk about what my learning process looks like in abstract terms, and then I&#39;ll give an analogy to make things more concrete and visual.   Learning is a messy process for me I know some very clear thinkers. They are very organized and methodical. I am not like that. These tidy thinkers seem to learn a new subject quickly (and effortlessly) by studying the rules of the subject and then deriving everything about that subject from that set of rules. They speak in precise statements and have clear and hard-set opinions about the subject. They seem to thrive most in theoretical subjects. In my observation those tidy learners are in the minority. Maybe the tidy thinkers are able to pull this feat off because they come from a neighboring domain/subject and map the context there to this subject quickly. But, again from my experience, it doesn&#39;t feel like that. It s
</p>
</div>

</div>
</article>
<article role="article">
<h3><a href="http://muratbuffalo.blogspot.com/2022/10/checking-statistical-properties-of.html"> Checking statistical properties of protocols using TLA+</a></h3>

<div>
<p><a href="http://muratbuffalo.blogspot.com/2022/10/checking-statistical-properties-of.html">
<img alt="Image" sizes="72px" src="https://blogger.googleusercontent.com/img/a/AVvXsEjZLpGANL9qnsEB-6FrREQDzSdlG4nRczNN70zuCW4qOq_tKGc7pC2mbXamL55Plc9VPmf64cibgmSJ4HvPjrRLS4B3YnsXwdASCO992Mq3gRZPdN2Iy-EOUJrdS6sEbk3Jx0vHQJY5eHl2JfVjvT75aS_EyiHzmGUZ0wmfNGnjJoJtECiPgHE61IXv=s16000" srcset="https://blogger.googleusercontent.com/img/a/AVvXsEjZLpGANL9qnsEB-6FrREQDzSdlG4nRczNN70zuCW4qOq_tKGc7pC2mbXamL55Plc9VPmf64cibgmSJ4HvPjrRLS4B3YnsXwdASCO992Mq3gRZPdN2Iy-EOUJrdS6sEbk3Jx0vHQJY5eHl2JfVjvT75aS_EyiHzmGUZ0wmfNGnjJoJtECiPgHE61IXv=w72-h72-p-k-no-nu 72w, https://blogger.googleusercontent.com/img/a/AVvXsEjZLpGANL9qnsEB-6FrREQDzSdlG4nRczNN70zuCW4qOq_tKGc7pC2mbXamL55Plc9VPmf64cibgmSJ4HvPjrRLS4B3YnsXwdASCO992Mq3gRZPdN2Iy-EOUJrdS6sEbk3Jx0vHQJY5eHl2JfVjvT75aS_EyiHzmGUZ0wmfNGnjJoJtECiPgHE61IXv=w144-h144-p-k-no-nu 144w"/>
</a>
</p>
<div>
<p>
In my previous post,  I mentioned how excited I was about Jack Vanlightly and Markus Kuppe&#39;s talk  at TLA+ Conference. They showed a new mode (called &#34;generate&#34;) added to the TLA+ checker to enable  obtaining statistical properties from the models. Here is how this works in a nutshell. Your TLA+ model/protocol produces a tree of runs, and, in the generate mode the TLA+ checker chooses these runs in a uniform manner. You also specify some state constraints, and when these are satisfied the TLA+ checker executes/evaluates your state constraint formula: you add the statistics logging as the side effect of this formula, and record information about the current run to a CSV file. This way, you can collect statistical hyper properties (abort rates, completion rounds, etc.) about the runs, in addition to checking it for correctness invariants. Later you can use Excel or Rscript to visualize the statistics collected and analyze the model behavior. Checking statistics is very usef
</p>
</div>

</div>
</article>
</div>
</div>
</div></div>
</main>
</div></div>
  </body>
</html>
