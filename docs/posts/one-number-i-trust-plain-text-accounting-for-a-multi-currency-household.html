<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lalitm.com/post/one-number-i-trust/">Original</a>
    <h1>One Number I Trust: Plain-Text Accounting for a Multi-Currency Household</h1>
    
    <div id="readability-page-1" class="page"><section><p>Two people. Eighteen accounts spanning checking, savings, credit cards, investments. Three currencies. Twenty minutes of work every week.</p><p>One net worth number I actually trust.</p><p><img src="https://lalitm.com/img/one-number-i-trust/01-payoff-net-worth.png" alt="Net Worth Chart growing over 2+ years" title="One net worth number to trust"/></p><p><em>The payoff: A single, trustworthy net worth number growing over time.</em></p><p>No app did exactly what I needed, so I built my own personal finance system using <strong>plain-text accounting</strong> principles and a powerful Python library called <strong>Beancount</strong>. This post shows you how I handle imports, investments, multi-currency, and a two-person view.</p><h2 id="how-i-got-here">How I got here</h2><p>It all started during the 2021 tax season. I had blocked out an entire weekend and was juggling statements, trying to compute capital gains, stressing about getting the numbers mixed up. “This is chaos”, I thought. “There must be a way to simplify this with automation”. Being a software engineer, I did what felt natural and hacked together a bunch of scripts on top of a database.</p><p>Though it worked and I kept using it day-to-day, by the next tax season the cracks became obvious. The code was hard to debug, random transactions went missing, and worst of all, the balances the scripts computed didn’t match the balances on my statements. I tried to fix it but the more I tried, the more I felt lost about what the system was really doing. Eventually I just gave up.</p><p>Why did I fail so spectacularly? My entire approach was flawed from the start! I’d ignored centuries of accounting wisdom and repeated fundamental mistakes humanity solved long ago. So I learned from my mistakes and did the research. And over time I incrementally discovered <strong>double-entry bookkeeping</strong>, <strong>plain-text accounting</strong> and <strong>Beancount</strong>.</p><p>Fast forward to today, and I have a flexible, powerful, and private system, fully customized to how my brain works. Most transactions import automatically from PDF statements (counterintuitively, it’s often more reliable than CSV!). Tax time is a simple matter of checking always-fresh reports and copying numbers over. The weekly ritual is simple: download statements, categorize transactions in a web UI, run a bunch of scripts to regenerate, commit (I walk through this in more detail later).</p><p>However, I want to be realistic: building a system like this takes time and effort.<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup> You will need to learn some basic accounting concepts, be comfortable with Python, and consistently spend time every week keeping things up-to-date. If your finances are simple or you just want day-to-day budgeting, this is almost certainly overkill. Apps like YNAB or even the humble spreadsheet work great.</p><p>But if you want uncompromising control over how you look at your finances, read on.</p><h2 id="chapter-1-the-concepts">Chapter 1: The Concepts</h2><h4 id="double-entry-bookkeeping">Double-entry bookkeeping</h4><p>Suppose on a Saturday, I transfer money from my checking account to a savings account. The money leaves on the same day but doesn’t show up on the other side until Monday. So where was it for those two days?</p><p>In a “normal”<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup> personal finance system, the answer would be that it was just gone. That is, for those two days, there would be a drop in the total money in two accounts. But this is weird because in reality my “net worth” did not change, yet there’s no good way to represent this.</p><p>Or suppose I pay $90 for a dinner for me and two friends. They pay me back a week later. Again, in this case the money is “gone” for that week. And even worse, the full $90 would be categorized as a “restaurant expense” while each $30 my friends paid would be “income”. But this is wrong. My expense is just $30 and the money they give me should be matched against the $60 they owe me.</p><p>Both of these are fundamental problems with how so-called “<a href="https://en.wikipedia.org/wiki/Single-entry_bookkeeping">single-entry bookkeeping</a>” works: each account’s transactions and balance are tracked individually but without the context of the “whole”. In the case of the transfer, because we’re looking at each account in isolation, we lose the fact that even though the money has left one account, it’s really still part of the “pool of money” that belongs to us. Similarly, when our friends pay us back, we’re not tracking the fact that our friends owe us money when the original transaction happened and their payment later neutralizes the debt.</p><p><a href="https://en.wikipedia.org/wiki/Double-entry_bookkeeping">Double-entry bookkeeping</a> is the solution to both these problems. Businesses have been using it for hundreds of years<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup> to run their accounts, and it has powerful yet elegant ways to solve these problems and many others too.</p><p>Let’s consider again the transfer. In double-entry bookkeeping, we would represent the initial move of money as:</p><div><pre tabindex="0"><code data-lang="fallback"><span><span>Bank-Checking              -1000
</span></span><span><span>Transfer-In-Flight         +1000
</span></span></code></pre></div><p>And when it arrives:</p><div><pre tabindex="0"><code data-lang="fallback"><span><span>Transfer-In-Flight         -1000
</span></span><span><span>Savings-Account            +1000
</span></span></code></pre></div><p>In both cases, we see the “golden rules” of double-entry bookkeeping:</p><ol><li><em>Every transaction has at least two sides and the sum of all the sides is zero</em>. -1000 + 1000 = 0. That is, transactions always “balance”.</li><li><em>Every side of a transaction is an account</em>, whether it exists in the real world or not.</li></ol><p>It should be clear that “Bank-Checking” and “Savings-Account” are labels for your checking and savings accounts, respectively. But what is “Transfer-In-Flight”?</p><p>Well, it’s also an account! It’s not an account you’ll find on your bank’s website, but within the double-entry system, it’s <em>just as real</em>. Concretely, accounts in double-entry are just labels for a “bucket of money”. So there’s no “category to put this transaction under”, no “expense tracking”, no special “transfer tag”. Everything is an account.</p><p>In this specific case, <code>Bank-Checking</code>, <code>Savings-Account</code>, and <code>Transfer-In-Flight</code> are all a specific type of account: they are <strong>Asset</strong> accounts. Assets are stuff you own; these can be real accounts (bank account, savings, stocks, bonds) or conceptual accounts (money in transit between accounts).</p><p>Now let’s consider the dinner example. There are 4 sides to the transaction:</p><div><pre tabindex="0"><code data-lang="fallback"><span><span>Credit-Card                  -90
</span></span><span><span>Restaurant-Expense           +30
</span></span><span><span>Owes-Me:Alice                +30
</span></span><span><span>Owes-Me:Bob                  +30
</span></span></code></pre></div><p>Again, -90 + 30 + 30 + 30 = 0. It balances. All of <code>Credit-Card</code>, <code>Restaurant-Expense</code>, <code>Owes-Me:Alice</code>, and <code>Owes-Me:Bob</code> are just accounts.</p><p><code>Credit-Card</code> is a different type of account though: it’s a <strong>Liability</strong>. Liabilities are the opposite of assets: instead of stuff you own, they’re stuff you <strong>owe</strong> to someone else. So for example, loans, credit cards, and mortgages are all liabilities.</p><p>Why <strong>negative</strong> 90? The rule is always: negative means money flowed <em>from</em> this account and positive means it flowed <em>into</em> this account. The credit card company fronted you $90, so that money flowed from your credit card to fund the purchase.</p><p><code>Restaurant-Expense</code> is yet another type of account, an <strong>Expense</strong> account. Expense accounts are money “leaving your world”. So any time you spend some money and you no longer have access to it, that’s an expense.</p><p>Finally, <code>Owes-Me:Alice</code> and <code>Owes-Me:Bob</code> are also <strong>Assets</strong>. Alice and Bob have promised to pay you back, and that promise has value, $30 each. It’s not cash in your pocket, but it’s money you have a claim on. In double-entry, anything with economic value you control is an asset, whether it’s a bank balance or an IOU.</p><p>Later, when Alice pays you back:</p><div><pre tabindex="0"><code data-lang="fallback"><span><span>Bank-Checking               +30
</span></span><span><span>Owes-Me:Alice               -30
</span></span></code></pre></div><p>This is just money moving from the “virtual” <code>Owes-Me:Alice</code> to the “real” <code>Bank-Checking</code> account. Both of these are still assets; it’s just the <em>type</em> of asset that’s changing. So no money has “entered the system” at this point. You’re just settling the debt Alice owed you.</p><p>Let’s take one last example: a paycheck.</p><div><pre tabindex="0"><code data-lang="fallback"><span><span>Bank-Checking              +3000
</span></span><span><span>Salary                     -3000
</span></span></code></pre></div><p><code>Bank-Checking</code> is an <strong>Asset</strong> as we’ve learned. But <code>Salary</code> is a new account type, an <strong>Income</strong> account. Just like <strong>Assets</strong> and <strong>Liabilities</strong> are opposites, so are <strong>Income</strong> and <strong>Expenses</strong>. Where <strong>Expenses</strong> are money leaving your world, <strong>Income</strong> is money entering it.</p><p>Money flowed from Salary (source, negative) to Bank-Checking (destination, positive). The sign feels backwards: “I <em>received</em> money, so why is Income <em>negative</em>?” Because the sign shows direction of flow: income is where the money <em>came from</em>, and your bank is where it <em>went to</em>.</p><p>This is the one part of double-entry that takes repetition.<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup> Don’t try to make it intuitive; just trust the invariant: <strong>if your transaction sums to zero, you’ve got the signs right.</strong> After a dozen transactions, the pattern becomes automatic.</p><p>These four types of accounts cover 99% of what you’ll do:</p><ul><li><strong>Assets</strong>: stuff you own (bank accounts, cash, investments, money owed to you)</li><li><strong>Liabilities</strong>: stuff you owe (credit cards, loans)</li><li><strong>Income</strong>: money entering your world (salary, interest, dividends)</li><li><strong>Expenses</strong>: money leaving your world (groceries, rent, restaurants)</li></ul><p>There’s a fifth type, <strong>Equity</strong>, which is a catch-all “this money doesn’t fit elsewhere” bucket.<sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup> Suppose you start tracking an account that already has $1000 in it; that money came from <strong>somewhere</strong> but you don’t have a record of that. It can’t be income because you already had it, and the other types don’t fit. That’s a good sign it belongs in equity. The good news is that you rarely interact with Equity directly. Generally, the software handles it for you, but there are some exceptions that we’ll cover in Chapter 2.</p><p>There’s so much more that could be said about double-entry bookkeeping. For further reading, I particularly like the <a href="https://beancount.github.io/docs/the_double_entry_counting_method.html">double entry explainer</a> in the Beancount docs. It goes through some more examples and expands into a bunch of related topics.</p><p>But we now have the foundation which ensures that every transaction balances, every dollar is accounted for, and nothing slips through the cracks. But we still need a way to actually record and store these transactions.</p><h4 id="plain-text-accounting">Plain text accounting</h4><p>One of the things I learned from writing my own finance system is that auditability is king. You need the ability to eyeball a transaction, ask yourself “does this look right,” and fix it if it doesn’t. And nothing beats being able to see and edit any transaction you’ve ever made in a text editor.</p><p>That’s one of the main things that drew me to the philosophy of <a href="https://plaintextaccounting.org/">Plain Text Accounting</a>. This is a set of principles on using plain text files as the “immutable source of truth” of your finances and then building scripts and tools on top of them to process, analyze, and visualize them.</p><p>There are many other advantages to this I’ve come to appreciate over the years:</p><p><strong>Everything is version controlled.</strong> You can store these transaction files in a git repo, which has powerful effects. You can look at diffs to see what changed on any day. You can <code>git blame</code> any transaction to see when and why it was added. You can <code>git tag</code> important states of the repo (e.g. when taxes were filed, when a new job was started, when a big refactoring happened). You can <code>git checkout</code> any previous state to see e.g. “how did my repo look last year”.</p><p><strong>It’s private</strong> so you never have to trust any third party with all your financial details. Everything can be stored in locations that you fully control.</p><p><strong>There’s no lock-in.</strong> Because everything is just a plain text file, it’s trivially easy to change how you want things to be represented: you don’t have to deal with apps with broken or messy CSV exports making it difficult to take your data elsewhere.</p><p><strong>It’s scriptable</strong>. If you want to refactor something, compute a new breakdown or even rewrite your system entirely, all you need is to write a script. Whether you write it yourself or prompt an LLM to do it for you, the text-based format makes automation trivial.</p><p>Plain text gives you the abstract idea of “storing transactions in text” but there’s still a bunch of questions. What’s the transaction syntax? How do you parse your files? How do you validate that everything balances, compute totals, and let you query the results? That’s where <strong>Beancount</strong> comes in.</p><h4 id="introducing-beancount">Introducing Beancount!</h4><p>Over the years, people have written many plain-text accounting tools which answer all the questions above. The main ones you’ll find which have gained a lot of popularity are <strong>Ledger</strong>, <strong>hledger</strong>, and <strong>Beancount</strong>. I’ve used each of them at some point in my plain text journey and all are solid choices. But I ended up on Beancount for a few reasons.</p><p><strong>It’s a Python library</strong>, not just a command-line tool. I can write importers that parse my bank’s PDF statements, generate transactions programmatically, and build custom reports, all in a language I already know.</p><p><strong>Strictness by default</strong>. Accounts must be declared before use, so typos get caught immediately. Transactions must balance and there are immediate error messages if they don’t. The tool catches mistakes early rather than letting them propagate.</p><p><strong>Plugin and tool ecosystem</strong>. Beancount has a very rich set of libraries and tools which build on top of and integrate with it. Along with the core project, you get access to any and all of these projects you want to use. We’ll discuss this much more later.</p><p><strong><a href="https://github.com/beancount/fava">Fava</a></strong>. The web UI which sits on top of the Beancount engine. It’s so good that people convert from other formats (using tools like <a href="https://github.com/beancount/ledger2beancount">ledger2beancount</a> or <a href="https://github.com/shivanshu7/gnucash2beancount">gnucash2beancount</a>) just to use it. Where Beancount gives you the reliable engine, Fava gives you the pretty yet powerful frontend:</p><ul><li><strong>Reports</strong>: balance sheet, income statement, transaction journal</li><li><strong>Query editor</strong>: SQL-like queries, exportable to CSV</li><li><strong>Charts</strong>: spending breakdowns, net worth over time, holdings by currency</li><li><strong>Error highlighting</strong>: problems highlighted immediately</li><li><strong>Extensibility</strong>: plugins like <a href="https://github.com/andreasgerstmayr/fava-dashboards">fava-dashboards</a> and <a href="https://github.com/andreasgerstmayr/fava-portfolio-returns">fava-portfolio-returns</a></li></ul><p>With this, we now understand enough of the basic concepts for us to get started trying out Beancount!</p><h2 id="chapter-2-getting-started">Chapter 2: Getting Started</h2><p>The best way to learn plain-text accounting is to roll up your sleeves and try it out. So let’s pause the theory for a moment and get a real ledger running on your machine.</p><p>I’ve built a companion repository, <a href="https://github.com/LalitMaganti/beancount-blog-examples">LalitMaganti/beancount-blog-examples</a>, which contains a cut-down version of the system I use day-to-day. The repo is organized into folders that match the chapters of this post (<code>chapter-2/</code>, <code>chapter-3/</code>, etc.), each building on the previous. It also includes a <code>demo/</code> folder with 2+ years of synthetic history if you want to see the end result immediately.</p><p><strong>To get started, clone the repository:</strong></p><div><pre tabindex="0"><code data-lang="bash"><span><span>git clone https://github.com/LalitMaganti/beancount-blog-examples.git
</span></span><span><span>cd beancount-blog-examples
</span></span><span><span>
</span></span><span><span><span># Run the demo to see the end result</span>
</span></span><span><span>./scripts/quickstart.sh demo
</span></span><span><span>
</span></span><span><span><span># Or start Chapter 2 to follow the guide</span>
</span></span><span><span>./scripts/quickstart.sh chapter-2
</span></span></code></pre></div><p>This will set up a Python environment, install dependencies, and open Fava at http://localhost:5000. Here’s what you should see.</p><p><img src="https://lalitm.com/img/one-number-i-trust/02-first-look-trial-balance.png" alt="Fava Trial Balance showing Assets, Income, and Expenses" title="First look at Fava"/></p><p><em>Fava&#39;s Trial Balance view shows assets, income, and expenses in one place.</em></p><p><img src="https://lalitm.com/img/one-number-i-trust/03-sunburst-expenses.png" alt="Sunburst chart breaking down expenses" title="Visualizing expenses"/></p><p><em>Sunburst charts make it easy to spot your biggest expense categories instantly.</em></p><p>Click around the different tabs. You’ll find that Fava gives you the following:</p><ul><li><strong>Balance sheet</strong>: the state of your accounts at the current point in time. Basically think of it as an aggregate view of all your finances. You can answer questions like “what’s my net worth now?”, “how much money do I owe across my credit cards?” or “how much have I gained from investments?”</li><li><strong>Income statement</strong>: the sum of all the money flows into/out of your accounts. Think of it as a sum of all the income and expenses across time. You can answer questions like “how much did I earn from my job?”, “how much did I spend on Amazon?” or “did I spend more or less than last year?”</li><li><strong>Transaction history</strong>: a flat list of all transactions you have in your journal. A way to see and search any transaction you’ve made across any accounts in your system.</li></ul><p><img src="https://lalitm.com/img/one-number-i-trust/04-query-console.png" alt="Fava Query Console running a SQL query" title="SQL for your finances"/></p><p><em>The Query Console lets you run SQL-like queries against your financial data.</em></p><p>There’s much more to Fava’s features (queries, multi-currency, plugins) as we’ll see later on in the post.</p><p>You can also explore the text journal itself using a text editor. For example, here’s a grocery run and a payslip in the Beancount transaction format:</p><div><pre tabindex="0"><code data-lang="fallback"><span><span>; chapter-2/src/transactions.beancount
</span></span><span><span>
</span></span><span><span>; Beancount auto-fills the second amount when it can be inferred.
</span></span><span><span>2024-01-15 * &#34;Tesco&#34; &#34;Weekly groceries&#34;
</span></span><span><span>  Expenses:Groceries                    85.50 GBP
</span></span><span><span>  Assets:Lalit:UK:HSBC:Current:GBP
</span></span><span><span>
</span></span><span><span>2024-01-25 * &#34;Google&#34; &#34;January salary&#34;
</span></span><span><span>  Assets:Lalit:UK:HSBC:Current:GBP    3200.00 GBP
</span></span><span><span>  Income:Lalit:UK:Google:Salary
</span></span></code></pre></div><p>Go through the transactions and get a feel for the format. It might seem alien at first but trust me when I say soon it’ll feel like the most natural thing in the world!</p><p><img src="https://lalitm.com/img/one-number-i-trust/05-ide-experience.png" alt="VS Code with Beancount extension showing syntax highlighting" title="The IDE Experience"/></p><p><em>With a VS Code extension, you get syntax highlighting and auto-completion for your accounts.</em></p><p>Now that you have a working system, I want to share the hard-won insights that aren’t in the official docs. This post isn’t going to be a full Beancount tutorial. The <a href="https://beancount.github.io/docs/getting_started_with_beancount.html">official docs</a> are excellent for that (Fava even has a <a href="https://fava.pythonanywhere.com/example-beancount-file/income_statement/">demo</a> that you can try without downloading anything!).</p><p>Instead, I want to focus on the <em>architecture</em>: the decisions I wish I’d made correctly from day one. I’m writing this as if I’m speaking to my past self.</p><h4 id="start-with-one-account">Start with one account</h4><p>You don’t need to track everything on day one. Pick one account. Your main checking account is a good start. Get comfortable with the flow. Import statements, categorize transactions, check that balances match. Once that feels solid, add another account. Then another.</p><p>I started with my HSBC current account. Now, I have my whole financial life inside the system and I trust it wholeheartedly. But this happened one account at a time. If I tried to do everything in one go, I would certainly have been overwhelmed and given up on the whole thing.</p><h4 id="opening-balances">Opening balances</h4><p>Once you’ve picked your first account, you face an immediate problem: you may have opened that account years ago and there might already be thousands of transactions over that time. Trying to import them all in one go is another sure path to being overwhelmed and giving up.</p><p>Instead, a better idea is to pick a “starting date” at which you say “I will import everything from this day onwards”. But that poses its own problem: you already had money in that account, how do you tell Beancount it exists?</p><p>Well, Beancount has a <code>pad</code> directive that creates the balancing entry automatically:</p><div><pre tabindex="0"><code data-lang="fallback"><span><span>; chapter-2/src/balance.beancount
</span></span><span><span>2024-01-01 open Equity:Opening-Balances
</span></span><span><span>2024-01-01 pad Assets:Lalit:UK:HSBC:Current:GBP Equity:Opening-Balances
</span></span><span><span>2024-01-02 balance Assets:Lalit:UK:HSBC:Current:GBP  1500.00 GBP
</span></span></code></pre></div><p>The <code>pad</code> directive tells Beancount: “whatever amount is needed to make the balance assertion true, take it from <code>Equity:Opening-Balances</code> and put it in this account”. This is one of the rare cases you actually have to think about equity accounts (though not much beyond blindly using <code>Equity:Opening-Balances</code>!).</p><h3 id="structure-that-scales">Structure That Scales</h3><p>Adding a first account is easy and the second is straightforward, but adding a third, fourth, fifth… and you can easily find that things start becoming jumbled and messy. Just like code, putting a little bit of thought into the organization upfront goes a long way. This part covers the architectural decisions you’ll thank yourself later for.</p><h4 id="naming-asset-and-liability-accounts">Naming Asset and Liability accounts</h4><p>The structure of asset and liability account names is very important, much more than I initially gave them credit for. It’s a good idea to keep as much information in them as possible. Here’s what I’ve settled on:</p><div><pre tabindex="0"><code data-lang="fallback"><span><span>; chapter-2/src/accounts.beancount
</span></span><span><span>2024-01-01 open Assets:Lalit:UK:HSBC:Current:GBP          GBP
</span></span><span><span>2024-01-01 open Assets:Lalit:UK:Barclays:Current:GBP      GBP
</span></span><span><span>2024-01-01 open Liabilities:Lalit:UK:AMEX:GBP             GBP
</span></span></code></pre></div><p>The pattern is:</p><div><pre tabindex="0"><code data-lang="fallback"><span><span>Type:Person:Region:Institution:Account:Currency
</span></span></code></pre></div><p>Why this structure? Because it’s a lot easier to <em>remove detail</em> than add it in later! I initially started by not having the country, the currency or my name in the account. But over time, I wanted to understand:</p><ul><li>How much money I have in the UK vs the US?</li><li>How much cash (i.e. not investments) is in a certain currency?</li><li>How much of our household wealth was in my wife’s accounts vs my own (discussed in more detail in Chapter 6)?</li></ul><p>Having this information in the account name is great because Beancount’s SQL syntax makes it very easy to filter on account names. Want “all UK assets”? Filter on <code>:UK:</code>. Want “all HSBC accounts”? Filter on <code>:HSBC:</code>. Want “all GBP cash”? Filter on <code>:GBP</code>.</p><h4 id="powering-up-with-plugins">Powering up with Plugins</h4><p>Once you have a structure, you want to ensure it stays clean. This is where Beancount’s <strong>Plugins</strong> come in.</p><p>Plugins are Python scripts that run when your ledger loads. They can validate data, modify entries, or even generate new transactions automatically. You load them in your journal file like this:</p><div><pre tabindex="0"><code data-lang="fallback"><span><span>plugin &#34;beancount.plugins.check_commodity&#34;
</span></span></code></pre></div><p>Remember the transfer-in-flight pattern from Chapter 1? Here’s how it looks in Beancount:</p><div><pre tabindex="0"><code data-lang="fallback"><span><span>; chapter-2/src/transactions.beancount
</span></span><span><span>; Money leaves on Saturday
</span></span><span><span>2024-03-16 * &#34;Transfer to Barclays&#34;
</span></span><span><span>  Assets:Lalit:UK:HSBC:Current:GBP      -1000.00 GBP
</span></span><span><span>  Assets:Lalit:Transfers:Internal        1000.00 GBP
</span></span><span><span>
</span></span><span><span>; Money arrives on Monday
</span></span><span><span>2024-03-18 * &#34;Transfer from HSBC&#34;
</span></span><span><span>  Assets:Lalit:Transfers:Internal       -1000.00 GBP
</span></span><span><span>  Assets:Lalit:UK:Barclays:Current:GBP   1000.00 GBP
</span></span></code></pre></div><p>Once both transactions are recorded, the transit account balance returns to zero, confirming the transfer is complete. If you record one leg of a transfer but forget the other, the transit account will simply show a non-zero balance.</p><p>Understanding where a non-zero balance in transfers is coming from is handled by my absolute favorite plugin, <strong><a href="https://github.com/redstreet/beancount_reds_plugins">beancount_reds_plugins.zerosum</a></strong>. It’s responsible for matching both sides of a transaction and moving it to a separate account, meaning my <code>Transfers:Internal</code> account only contains the actual “pending” transactions. Making this account empty is a surprisingly satisfying little “minigame” during my weekly imports (though it never lasts for long!).</p><p>There are also a couple more plugins that make handling closed accounts better:</p><ul><li><strong><a href="https://github.com/beancount/beancount/blob/master/beancount/plugins/close_tree.py">beancount.plugins.close_tree</a></strong> - When you close an account, automatically closes all child accounts too. Useful as you move your banking between institutions.</li><li><strong><a href="https://github.com/daniel-wells/beancount_checkclosed">beancount_checkclosed.check_closed</a></strong> - Validates that closed accounts have zero balance and no transactions after the close date.</li></ul><h4 id="the-boundary-of-your-system">The boundary of your system</h4><p>As you add accounts one by one, you’ll inevitably see money flowing to places you haven’t set up yet. Say you transfer £500 to a Natwest savings account you haven’t added to the system. Where does it go?</p><p>Specifically, use a named placeholder account in <code>Equity:Transfers</code>:</p><div><pre tabindex="0"><code data-lang="fallback"><span><span>; chapter-2/src/transactions.beancount
</span></span><span><span>2024-03-15 * &#34;Transfer to savings (not yet tracked)&#34;
</span></span><span><span>  Assets:Lalit:UK:HSBC:Current:GBP     -500.00 GBP
</span></span><span><span>  Equity:Transfers:Natwest-Savings      500.00 GBP
</span></span></code></pre></div><p>This essentially says: “£500 went to Natwest Savings, which I’m not tracking yet”. Putting it in an equity account means it doesn’t pollute your balance sheet with incomplete information <em>or</em> your income statement with false expenses.</p><p>Note also the best practice of using a <em>named</em> equity account per untracked destination, not a generic bucket; this was a mistake I made when I did this initially. You’ll thank yourself when you import your Natwest savings account later, you can just do a search-replace to rename the accounts <sup id="fnref:6"><a href="#fn:6" role="doc-noteref">6</a></sup>.</p><h4 id="organizing-your-repo">Organizing your repo</h4><p>As you add these patterns (transit accounts, multiple institutions, liability accounts) your single <code>journal.beancount</code> file will start to become unwieldy. Just like good software architecture, you want to organize upfront to be easy to maintain as the system continues to grow.</p><p>This is what the structure looks like with the concepts we have right now (it’ll get more complicated as we go deeper!):</p><div><pre tabindex="0"><code data-lang="fallback"><span><span>chapter-2/
</span></span><span><span>├── journal.beancount            # Main entry point, includes everything
</span></span><span><span>├── src/
</span></span><span><span>│   ├── accounts.beancount       # Account definitions
</span></span><span><span>│   ├── transactions.beancount   # Primary transaction ledger
</span></span><span><span>│   └── balance.beancount        # Balance assertions
</span></span></code></pre></div><ul><li><code>src/</code> is what you write and edit (your “code”)</li><li><code>journal.beancount</code> is the entry point that includes everything</li><li>Later, <code>data/</code> will hold inputs from the outside world (raw statements: PDFs, OFX, CSVs)</li></ul><p>This organization is a small change but can make a big difference in your subconscious feeling about the state of your finances!</p><h4 id="exit-ramp">Exit ramp</h4><p>At this point, you have a solid foundation for tracking multiple accounts. If you stop here, you have a robust, auditable system for manual bookkeeping. You could continue adding transactions by hand indefinitely, and you’d still be miles ahead of any spreadsheet in terms of correctness and visibility.</p><p>But manual entry is a chore, and as your financial life grows, it becomes a bottleneck. In the next chapter, we’ll see how to automate the tedious part: getting transactions from your bank statements into your ledger without losing the control that plain-text accounting gives you.</p><h2 id="chapter-3-automated-import">Chapter 3: Automated Import</h2><h4 id="automation-is-king-but-harder-than-it-looks">Automation is king, but harder than it looks</h4><p>Inputting transactions by hand works for some people, but I don’t have the patience for it. Ever since I was young, I’ve always wanted to automate everything: it’s the reason why I became a software engineer in the first place!</p><p>But full automation is a dead end. Most banks don’t offer APIs, and scraping breaks constantly. 2FA flows change <sup id="fnref:7"><a href="#fn:7" role="doc-noteref">7</a></sup>, websites get redesigned, sessions expire. I tried this route, and it wasn’t worth it. Even in the US where aggregators like Plaid exist, coverage is patchy.<sup id="fnref:8"><a href="#fn:8" role="doc-noteref">8</a></sup> In the UK, it’s impossible.</p><h4 id="the-hierarchy-of-data-sources">The hierarchy of data sources</h4><p>So what actually works? Well ideally your financial institution gives you something you can write a script against. But what that might be is non-obvious and counter-intuitive. Here’s the hierarchy I’ve landed on over time:</p><ul><li><strong>OFX is the gold standard.</strong> If your bank offers it, use it. The format is standardized, transactions have unique IDs, and deduplication is straightforward. Life is easy if you have good OFX.</li><li><strong>CSV is the deceptive runner-up.</strong> It seems like the logical choice. Structured data, right? But in practice, bank CSVs are often afterthoughts. I’ve seen column formats change without notice, “CSVs” that are actually weird custom formats spread over multiple lines, and rows coalesced in ways that lose critical information (like cost basis).</li></ul><p>So what do you do when OFX isn’t available and CSV isn’t trustworthy? You turn to an unlikely hero.</p><h4 id="why-pdfs-beat-csvs">Why PDFs beat CSVs</h4><p>It sounds backwards, but PDFs are often the most reliable data source available.</p><p>Banks have a strong incentive to get PDFs right. Customers actually read them. They’re legal documents that get printed and filed. If a bank messes up a PDF statement, they hear about it immediately. If they break a CSV export, it might go months without anyone noticing.</p><p>The key insight is that bank statement PDFs are almost always columnar. Of course, this relies on the PDF having a proper text layer; if your bank sends you scanned images, you’re out of luck (though I’ve yet to encounter one that does). When you convert them to text while preserving the layout, you get something that looks like this:</p><div><pre tabindex="0"><code data-lang="fallback"><span><span>Date      Details                      Paid out     Paid in     Balance
</span></span><span><span>15 Jan 24 TESCO STORES 1234            42.50                    1,457.50
</span></span><span><span>16 Jan 24 TFL TRAVEL                    6.80                    1,450.70
</span></span><span><span>25 Jan 24 GOOGLE SALARY                           3,200.00      4,650.70
</span></span></code></pre></div><p>The columns are aligned by spaces, which means you can parse them as fixed-width data. The approach works in three steps:</p><ol><li><p><strong>Convert PDF to text</strong>: Run <code>pdftotext -layout statement.pdf statement.txt</code>. The <code>-layout</code> flag preserves the original column alignment.</p></li><li><p><strong>Find the table boundaries</strong>: Bank statements have predictable markers. HSBC uses “BALANCE BROUGHT FORWARD” at the start and “BALANCE CARRIED FORWARD” at the end. You extract just the transaction rows between these markers.</p></li><li><p><strong>Parse with fixed-width columns</strong>: Pandas’ <code>read_fwf</code> function is designed exactly for this. You put this logic inside the <code>extract()</code> method of your <code>beangulp</code> importer class, where it converts the text into a DataFrame:</p></li></ol><div><pre tabindex="0"><code data-lang="python"><span><span><span># Inside your Importer class</span>
</span></span><span><span>df <span>=</span> pd<span>.</span>read_fwf(
</span></span><span><span>    io<span>.</span>StringIO(text),
</span></span><span><span>    colspecs<span>=</span>[(<span>0</span>, <span>10</span>), (<span>10</span>, <span>40</span>), (<span>40</span>, <span>52</span>), (<span>52</span>, <span>64</span>), (<span>64</span>, <span>80</span>)],
</span></span><span><span>    names<span>=</span>[<span>&#39;Date&#39;</span>, <span>&#39;Details&#39;</span>, <span>&#39;Paid out&#39;</span>, <span>&#39;Paid in&#39;</span>, <span>&#39;Balance&#39;</span>]
</span></span><span><span>)
</span></span></code></pre></div><p>The column positions come from inspecting the header row. In practice, I detect them dynamically by finding keywords like “Paid out” and “Paid in” in the header and using their character positions.</p><p>Once you have a DataFrame, generating Beancount transactions is straightforward. You write a small class that iterates through this DataFrame and maps each row to a Beancount <code>Transaction</code> object, filling in the date, amount, and payee. See my <a href="https://github.com/LalitMaganti/beancount-lalitm/blob/main/src/beancount_tools/importers/hsbc.py">HSBC importer</a> for a working example.</p><p>For 95% of my banks, this approach works great. However, there is one bank where the text spacing becomes very strange and so I need to use something else. That’s when I turn to <a href="https://tabula.technology/">Tabula</a>, a Java CLI that extracts data tables from PDFs, even very complex ones.</p><p>The main reason I don’t use it all the time is that it’s much slower. But it also succeeds in the cases where <code>pdftotext</code> fails. I run it to get a structured JSON output, from which I create transactions (see my <a href="https://github.com/LalitMaganti/beancount-lalitm/blob/main/src/beancount_tools/importers/hsbc_us_cc.py">HSBC US credit card importer</a>).</p><p>I’m sure some readers will have worries about the fragility of what I’ve described here. I can tell you from experience that in three years, neither my UK nor my US HSBC PDF importer has ever broken. Neither has my Schwab one, and my Aviva one has only needed a single change. So I can personally vouch that this approach works and works <strong>well</strong>.</p><h4 id="from-raw-data-to-transactions">From raw data to transactions</h4><p>OK, so now you have statements. What do you do then? There are two pieces to the puzzle: parsing statements into transactions, and categorizing those transactions.</p><p>For parsing, Beancount has an official importer framework called <a href="https://beancount.github.io/docs/beangulp.html">beangulp</a>. You write a Python class that knows how to read a particular file format (the <a href="https://github.com/LalitMaganti/beancount-blog-examples/blob/main/chapter-3/importers/hsbc.py">skeleton importer</a> in <code>chapter-3/</code> already uses this API). Beangulp handles the mechanics: identifying which importer handles which file, extracting transactions, and deduplicating against existing entries.</p><p>But beangulp just extracts transactions without making any judgment on which account the transaction should be booked against. It doesn’t know that Tesco is groceries or that British Airways is an airline. I go to a new restaurant. How does the system know that <em>is</em> a restaurant?</p><p>This leads to a very important conclusion: we <strong>cannot</strong> fully automate importing transactions for bank accounts and credit cards. However, that doesn’t mean we have to enter things manually either. There’s a middle ground.</p><p>Enter <a href="https://github.com/jbms/beancount-import">beancount-import</a><sup id="fnref:9"><a href="#fn:9" role="doc-noteref">9</a></sup> (Note: this is a standalone tool, distinct from Fava’s built-in import features). It’s a web UI that uses your beangulp importers and adds a categorization layer on top. You run it, it opens in your browser, and it presents pending transactions one by one for review. Think of it as a staging area where you approve or tweak before anything hits your ledger.</p><p>For each transaction, it shows the raw data from your statement alongside a suggested categorization. You can accept the suggestion, override it with a different account, or skip it entirely. Once you decide, it moves to the next one. The interface is simple, mostly keyboard-driven and optimized for speed.</p><p><img src="https://lalitm.com/img/one-number-i-trust/06-import-ui.png" alt="Beancount Import Web UI" title="Visual Categorization"/></p><p><em>The import UI allows you to manually categorize transactions, like this Tesco grocery run, while the system learns your preferences.</em></p><p>The categorization uses machine learning (old-school decision trees, running locally, no LLMs, no cloud). It learns from your previous choices: the first time you see “Tesco”, you pick “Expenses:Groceries”, and the second time it auto-suggests and you just hit Enter. After a few weeks, the system should know 90% of the types of transactions you make and it’s easy to correct the ones which it doesn’t.</p><p>Once you’re proficient, a month’s worth of transactions takes 5-10 minutes. Most are repeats and you’re just hitting Enter. You only pause on genuinely new merchants. This is the core of my weekly ritual, and why I’ve found categorization has not become a chore, even after doing it for years.</p><h4 id="exit-ramp-1">Exit ramp</h4><p>With automated imports and semi-automated categorization, the “hard work” of bookkeeping is mostly solved. For many, this is the endgame: a perfect record of where every penny went, updated in minutes each week.</p><p>But your net worth isn’t just cash in a bank account. It’s also the stocks, bonds, and funds that grow (or shrink) over time. Tracking these requires a few more tools to handle cost basis, dividends, and market prices. We’ll tackle those in Chapter 4.</p><h2 id="chapter-4-investments">Chapter 4: Investments</h2><p>Now for investments. It’s where things get more interesting, and I think there’s less material out there covering the nitty-gritty. Here are some lessons I’ve learned over the years.</p><h4 id="the-unified-mental-model">The Unified Mental Model</h4><p>The most important thing to realize is that Beancount treats <strong>everything</strong> as a commodity.</p><p>A share of Apple (<code>AAPL</code>) is a commodity. A US Dollar (<code>USD</code>) is a commodity. A British Pound (<code>GBP</code>) is a commodity. While Beancount <em>can</em> infer these on the fly, you’ll typically declare them explicitly in your journal (e.g., <code>2024-01-01 commodity AAPL</code>).<sup id="fnref:10"><a href="#fn:10" role="doc-noteref">10</a></sup></p><p>This explicit declaration is a small but critical architectural win: it prevents a simple typo from creating a phantom currency, and it provides the metadata that advanced reporting plugins (like those used to calculate your portfolio performance) rely on to work correctly.</p><p>This means you don’t “buy stocks with money”. You simply exchange one commodity for another. The syntax for buying shares is identical to the syntax for exchanging currency.</p><h4 id="the-account-structure">The Account Structure</h4><p>Just like with bank accounts, I break investments down by institution and security.</p><div><pre tabindex="0"><code data-lang="fallback"><span><span>; chapter-4/src/accounts.beancount
</span></span><span><span>2024-01-01 open Assets:Lalit:US:IB:Brokerage:USD          USD
</span></span><span><span>2024-01-01 open Assets:Lalit:US:IB:Brokerage:AAPL         AAPL
</span></span><span><span>2024-01-01 open Assets:Lalit:UK:Vanguard:ISA:GBP          GBP
</span></span><span><span>2024-01-01 open Assets:Lalit:UK:Vanguard:ISA:VWRL         VWRL
</span></span></code></pre></div><p>Cash in a brokerage is just another holding named by currency (<code>GBP</code>, <code>USD</code>), while stock holdings use their ticker (<code>AAPL</code>, <code>VWRL</code>).</p><p>But you also need to track the flows <em>generated</em> by these assets: capital gains, dividends, commissions, and withholding taxes. I create specific accounts for each security:</p><div><pre tabindex="0"><code data-lang="fallback"><span><span>2024-01-01 open Income:Lalit:US:IB:Brokerage:AAPL:Dividends        USD
</span></span><span><span>2024-01-01 open Income:Lalit:US:IB:Brokerage:AAPL:Capital-Gains    USD
</span></span></code></pre></div><p><strong>Why so granular?</strong> It’s the same reason I name assets fully: aggregation up the tree is trivial; disaggregation after the fact is impossible. If you track all your dividends in a single <code>Income:Dividends</code> account, it’s easy to know “how much dividends did I earn total?”. But if you want to know “what was my AAPL dividend yield this year?”, you’re out of luck. Track at the leaf (<code>Income:IB:AAPL:Dividends</code>), and you can answer both questions.</p><h4 id="the-notation">The Notation</h4><p>With our accounts defined, we can now record the actual movement of assets. We use <code>{}</code> to denote cost (what we paid per unit) and <code>@</code> to denote price (what the unit is worth now).</p><p><strong>Example 1: Buying Stock</strong>
Exchanging 1850 USD for 10 shares of Apple.</p><div><pre tabindex="0"><code data-lang="fallback"><span><span>2024-01-10 * &#34;BUY AAPL&#34;
</span></span><span><span>  Assets:Lalit:US:IB:Brokerage:AAPL      10 AAPL {185.00 USD} @ 185.00 USD
</span></span><span><span>  Assets:Lalit:US:IB:Brokerage:USD   -1850.00 USD
</span></span></code></pre></div><p>The <code>{185.00 USD}</code> is the <strong>cost basis</strong> and the <code>@ 185.00 USD</code> is the <strong>price</strong>. Beancount uses the cost basis to track lots and calculate capital gains.</p><p><em>Note: Cost basis rules depend heavily on where you are. In the US, you track cost basis of individual lots. In the UK, we have special “Section 104” pooling rules.<sup id="fnref:11"><a href="#fn:11" role="doc-noteref">11</a></sup> I discuss this more in Chapter 5.</em></p><p><strong>Example 2: Buying Currency</strong>
Exchanging 950 GBP for 98,000 INR.</p><div><pre tabindex="0"><code data-lang="fallback"><span><span>2024-03-02 * &#34;Wise&#34; &#34;GBP to INR&#34;
</span></span><span><span>  Assets:Lalit:UK:Wise:INR            98000.00 INR @@ 950.00 GBP
</span></span><span><span>  Assets:Lalit:UK:Wise:GBP             -950.00 GBP
</span></span></code></pre></div><p>In the second example, <code>@@</code> specifies the <em>total</em> cost rather than the per-unit cost.</p><p><strong>Example 3: Selling Stock</strong>
Selling 5 shares of Apple at $190 (bought at $185).</p><div><pre tabindex="0"><code data-lang="fallback"><span><span>2024-01-30 * &#34;SELL AAPL&#34;
</span></span><span><span>  Assets:Lalit:US:IB:Brokerage:AAPL      -5 AAPL {185.00 USD} @ 190.00 USD
</span></span><span><span>  Assets:Lalit:US:IB:Brokerage:USD     950.00 USD
</span></span><span><span>  Income:Lalit:US:IB:Brokerage:AAPL:Capital-Gains  -25.00 USD
</span></span></code></pre></div><p>Here we specify the lot we’re selling (<code>{185.00 USD}</code>) and the price we’re selling it at (<code>@ 190.00 USD</code>). The difference is the capital gain (or loss).</p><p>But the principle is identical: <code>Assets:Wise:INR</code> and <code>Assets:Brokerage:AAPL</code> are just accounts holding commodities.</p><h4 id="automation">Automation</h4><p>Investments are very different from normal accounts in that they can be <strong>fully automated</strong>. No categorization needed: a buy is a buy, a dividend is a dividend. You don’t have new merchants to worry about.</p><p>This means you can skip beancount-import’s web UI and run your beangulp importers directly with output going straight to the ledger. To help inspire you, I’ve open-sourced my personal collection of importers (IB, Vanguard, Schwab, and more) in the <a href="https://github.com/LalitMaganti/beancount-lalitm/tree/main/src/beancount_tools/importers">beancount-lalitm</a> repo.</p><h4 id="handling-account-sprawl">Handling Account Sprawl</h4><p>However, one annoyance is that creating those granular accounts for every single stock (<code>...:AAPL:Dividends</code>, <code>...:AAPL:Commissions</code>, etc.) is tedious. To solve this, I wrote the <a href="https://github.com/LalitMaganti/beancount-lalitm/blob/main/src/beancount_tools/plugins/ancillary_accounts.py">ancillary_accounts</a> plugin. Instead of manual account creation, you just add metadata to the main holding account:</p><div><pre tabindex="0"><code data-lang="fallback"><span><span>2023-02-01 open Assets:Lalit:US:IB:Brokerage:BAC    BAC
</span></span><span><span>  ancillary_commission_currency: &#34;USD&#34;
</span></span><span><span>  ancillary_distribution_currency: &#34;USD&#34;
</span></span><span><span>  ancillary_withholding_tax_currency: &#34;USD&#34;
</span></span><span><span>  ancillary_capital_gains_currency: &#34;USD&#34;
</span></span></code></pre></div><p>The plugin automatically generates the corresponding income and expense accounts for you.</p><h4 id="corporate-actions">Corporate Actions</h4><p>I also use a plugin called <a href="https://github.com/LalitMaganti/beancount-lalitm/blob/main/src/beancount_tools/plugins/stock_split.py">stock_split</a> to handle corporate actions. It retroactively adjusts historical transactions when a stock splits, keeping quantities and prices consistent with post-split values so your charts don’t show a sudden, fake drop in value.</p><h4 id="the-value-of-things-prices">The Value of Things (Prices)</h4><p>We have the quantities (10 AAPL, 98,000 INR), but to calculate a single “Net Worth” number, we need to know what they are worth in your home currency. This requires prices for <strong>both</strong>:</p><div><pre tabindex="0"><code data-lang="fallback"><span><span>; chapter-4/src/prices.beancount
</span></span><span><span>2024-01-10 price AAPL  185.50 USD  ; Stock price in USD
</span></span><span><span>2024-01-10 price USD   0.79 GBP    ; Currency price in GBP
</span></span></code></pre></div><p>I automate this using a daily CI job. A script fetches the latest stock prices and forex rates from <a href="https://www.alphavantage.co/">AlphaVantage</a> and commits them to <code>prices.beancount</code>. You can find the script <a href="https://github.com/LalitMaganti/beancount-lalitm/blob/main/hack/fetch_prices.py">here</a>.</p><p>In practice, I actually have three price files:</p><ul><li><code>prices.beancount</code> - auto-fetched daily for as many securities as possible.</li><li><code>prices-manual.beancount</code> - for securities without automatic feeds (like some pension funds). I input these manually once a month.</li><li><code>prices-delisted.beancount</code> - historical prices for securities no longer trading. This saves me from making API calls which would fail anyway.</li></ul><h4 id="the-payoff">The Payoff</h4><p>With this data, Fava comes alive. To see the full potential of these reports, I’ve included a <code>demo/</code> folder in the companion repo with 2+ years of history. Run <code>./scripts/quickstart.sh demo</code> and you’ll see the payoff.</p><p>The <strong>Holdings</strong> page now shows your positions with their cost basis and current market value.</p><p><img src="https://lalitm.com/img/one-number-i-trust/07-holdings-table.png" alt="Holdings view showing Cost Basis and Market Value" title="Tracking Investments"/></p><p><em>The Holdings report automatically calculates the market value of your assets using live price data.</em></p><p>In the demo environment, you can also see how plugins like <a href="https://github.com/andreasgerstmayr/fava-dashboards"><strong>fava-dashboards</strong></a> build custom visualizations. The plugin uses beanquery (Beancount’s SQL-like query language) to fetch data and renders interactive charts. It’s the best way to track long-term trends and asset allocation at a glance.</p><p><img src="https://lalitm.com/img/one-number-i-trust/08a-dashboard-scorecards.png" alt="Dashboard showing top-level scorecards and savings rate heatmap" title="Dashboard Scorecards"/>
<img src="https://lalitm.com/img/one-number-i-trust/08b-dashboard-allocation.png" alt="Dashboard showing asset allocation charts" title="Asset Allocation Dashboard"/></p><p><em>Custom dashboards (shown here using the demo data) allow you to track long-term trends and asset allocation at a glance.</em></p><p>And with <a href="https://github.com/andreasgerstmayr/fava-portfolio-returns"><strong>fava-portfolio-returns</strong></a>, you can calculate your true Time-Weighted Return (TWR) and Internal Rate of Return (IRR) to see if you’re actually beating the market. It accounts for cash flows properly, so adding money mid-year doesn’t inflate your returns.</p><p><img src="https://lalitm.com/img/one-number-i-trust/09-portfolio-returns.png" alt="Portfolio returns showing TWR and IRR" title="Portfolio Returns"/></p><p><em>The portfolio returns plugin (using the demo data) calculates your actual investment performance, net of cash flows.</em></p><h4 id="exit-ramp-2">Exit ramp</h4><p>You now have a system that tracks your entire financial world: from the coffee you bought this morning to the capital gains in your brokerage account. For most people, this is a complete solution.</p><p>However, as you collect more data, you’ll find you want to look at it in different ways. Maybe you want a simplified view for daily use and a detailed one for tax season. Or maybe you’re not the only person in your household. In the final chapters, we’ll see how to scale this system to handle multiple views and multiple people.</p><h2 id="chapter-5-multiple-views">Chapter 5: Multiple Views</h2><p>Day-to-day, I want a simple view of my finances. Take-home pay as a single number, investments without tax calculations cluttering the screen. But at tax time, I need detail. Every payslip line item and capital gains calculated the way HMRC wants them. Recording the same transaction twice would be maintenance hell. So instead, I extract multiple views from a single journal.</p><p>I think of these as “lenses” on the data. Some lenses <strong>aggregate</strong>: rolling up transactions into balances, summaries, or dashboards. Others <strong>transform</strong>: collapsing detail you don’t need day-to-day, or expanding it when you do. Both read from the same source files; nothing is duplicated.</p><h4 id="aggregated-views">Aggregated views</h4><p>Fava is great for interactive exploration, but I also want textual snapshots I can version control. I have a script that generates daily summaries showing account balances, and a CI workflow that commits them automatically. In my setup this runs on a self-hosted Gitea instance on hardware I control, so the raw ledger never leaves machines I own. If you prefer, you can keep everything local-only or push to an encrypted remote; GitHub Actions works the same way if you’re comfortable with that trade-off. This gives me:</p><ul><li>A record of how balances changed day to day</li><li>An immutable snapshot at tax time of what the system showed</li><li>Git as audit trail: “What was my net worth on March 15th 2023?” is answerable with <code>git checkout</code></li></ul><p>The key script is <a href="https://github.com/LalitMaganti/beancount-blog-examples/blob/main/chapter-5/scripts/archive.py">archive.py</a>. It uses the <a href="https://github.com/beancount/beanquery">beanquery</a> library to write SQL scripts over your journal and generate textual reports:</p><div><pre tabindex="0"><code data-lang="python"><span><span><span># Generate balance sheet in GBP</span>
</span></span><span><span>sql <span>=</span> <span>&#39;&#39;&#39;
</span></span></span><span><span><span>  SELECT account,
</span></span></span><span><span><span>         round(sum(number(convert(value(position, &#39;2024-12-31&#39;), &#39;GBP&#39;, &#39;2024-12-31&#39;))), 2) as value
</span></span></span><span><span><span>  FROM OPEN ON 2024-01-01 CLOSE ON 2024-12-31 CLEAR
</span></span></span><span><span><span>  GROUP BY account
</span></span></span><span><span><span>  HAVING round(sum(number), 2) != 0
</span></span></span><span><span><span>  ORDER BY account;
</span></span></span><span><span><span>&#39;&#39;&#39;</span>
</span></span></code></pre></div><p>I run this for each calendar year and tax year, generating files like:</p><ul><li><code>networth.txt</code> - Single-line net worth in each currency</li><li><code>balance-sheet.txt</code> - Net worth breakdown by account</li><li><code>holdings.txt</code> - Investment positions with cost basis and market value</li></ul><p>Here’s what <code>networth.txt</code> looks like:</p><div><pre tabindex="0"><code data-lang="fallback"><span><span>     gbp            usd
</span></span><span><span>-------------  -------------
</span></span><span><span> 15978.42 GBP   19973.02 USD
</span></span></code></pre></div><p>This is the concrete “one number I trust”: a single net-worth snapshot in my reporting currency, generated from the full ledger and price data.</p><p>And <code>holdings.txt</code>:</p><div><pre tabindex="0"><code data-lang="fallback"><span><span>account                           units  curr  avg_cost  price  book_val  mkt_val
</span></span><span><span>---------------------------------  -----  ----  --------  -----  --------  -------
</span></span><span><span>Assets:Lalit:UK:HSBC:Current:GBP  4914.50  GBP      1.00   1.00   4914.50  4914.50
</span></span><span><span>Assets:Lalit:UK:Vanguard:ISA:VWRL   20.00  VWRL    96.00  97.50   1920.00  1950.00
</span></span><span><span>Assets:Lalit:US:IB:Brokerage:AAPL    5.00  AAPL   146.15 150.40    730.75   752.00
</span></span></code></pre></div><p>My Gitea workflow is very simple too:</p><div><pre tabindex="0"><code data-lang="yaml"><span><span><span>on</span>:
</span></span><span><span>  <span>schedule</span>:
</span></span><span><span>    - <span>cron</span>: <span>&#39;00 7 * * *&#39;</span>  <span># Run daily at 7am</span>
</span></span><span><span>
</span></span><span><span><span>jobs</span>:
</span></span><span><span>  <span>update</span>:
</span></span><span><span>    <span>steps</span>:
</span></span><span><span>      - <span>run</span>: <span>uv run scripts/archive.py outputs/ journal.beancount 2024-01-01 2024-12-31</span>
</span></span><span><span>      - <span>run</span>: <span>git commit -am &#34;Regen reports&#34; &amp;&amp; git push</span>
</span></span></code></pre></div><h4 id="transformed-views">Transformed views</h4><p>Sometimes I want to change <em>how</em> transactions work fundamentally. This is a more advanced technique: while Aggregated views <em>read</em> data, Transformed views temporarily <em>rewrite</em> it in memory to simplify reality.</p><p>I have three transformed views, each for a different purpose:</p><ul><li><strong>Net</strong> - my daily driver. Collapses payslip details into a single take-home number.</li><li><strong>Gross</strong> - breaks down payslip line items for tax time analysis.</li><li><strong>CGT</strong> - a view that includes a “virtual currency” tracking capital gains the way my tax authority calculates them.</li></ul><p>The linchpin is the <code>rename_accounts</code> plugin. It lets me keep one copy of all transactions and rename accounts on the fly to show or hide detail.</p><p><strong>Gross vs net payslip</strong></p><p>Let me start with the simpler example. In gross view, my payslip shows every line item:</p><div><pre tabindex="0"><code data-lang="fallback"><span><span>2024-01-25 * &#34;Google&#34; &#34;January salary&#34;
</span></span><span><span>  Assets:Lalit:UK:HSBC:Current:GBP           3500.00 GBP  ; Take-home pay
</span></span><span><span>  Income:Lalit:UK:Google:Salary           -5000.00 GBP  ; Gross salary
</span></span><span><span>  Expenses:Lalit:UK:Google:Income-Tax        1000.00 GBP  ; Tax withheld
</span></span><span><span>  Expenses:Lalit:UK:Google:National-Insurance 400.00 GBP  ; NI contribution
</span></span><span><span>  Expenses:Lalit:UK:Google:Pension            100.00 GBP  ; Pension contribution
</span></span></code></pre></div><p>Useful for analyzing my tax situation. But day-to-day, I don’t care about the breakdown. In net view, the same transaction collapses:</p><div><pre tabindex="0"><code data-lang="fallback"><span><span>; chapter-5/journal-net.beancount
</span></span><span><span>include &#34;journal.beancount&#34;
</span></span><span><span>
</span></span><span><span>plugin &#34;beancount_reds_plugins.rename_accounts.rename_accounts&#34; &#34;{
</span></span><span><span>  &#39;Income:Lalit:UK:Google:Salary&#39;: &#39;Income:Lalit:UK:Google:Net-Income&#39;,
</span></span><span><span>  &#39;Income:Lalit:UK:Google:Bonus&#39;: &#39;Income:Lalit:UK:Google:Net-Income&#39;,
</span></span><span><span>  &#39;Expenses:Lalit:UK:Google:Income-Tax&#39;: &#39;Income:Lalit:UK:Google:Net-Income&#39;,
</span></span><span><span>  &#39;Expenses:Lalit:UK:Google:National-Insurance&#39;: &#39;Income:Lalit:UK:Google:Net-Income&#39;,
</span></span><span><span>  &#39;Expenses:Lalit:UK:Google:Pension&#39;: &#39;Income:Lalit:UK:Google:Net-Income&#39;,
</span></span><span><span>}&#34;
</span></span></code></pre></div><p>Because Income is stored as a negative number and Expenses as positive numbers, merging them into one account mathematically subtracts the tax from the gross pay, leaving just the net amount. The difference should be obvious if I compare the Income Statements on Fava:</p><p><img src="https://lalitm.com/img/one-number-i-trust/10-gross-view.png" alt="Gross Income Statement view showing all tax line items" title="Gross View"/></p><p><em>The Gross view is essential for tax season, but the detailed line items for taxes and insurance often dwarf your actual spending data.</em></p><p><img src="https://lalitm.com/img/one-number-i-trust/11-net-view.png" alt="Net Income Statement view showing take-home pay" title="Net View"/></p><p><em>The Net view collapses those details into a single take-home number, making your everyday expenses much easier to analyze.</em></p><h4 id="tracking-capital-gains-for-tax">Tracking capital gains for tax</h4><p>We can use this same renaming technique to handle a much more complex beast: <strong>Capital Gains Tax</strong>.</p><p>Your broker reports one gain number, but your tax authority may calculate another. In the UK, where I live, we have specific rules like “Section 104 pooling” (averaging cost basis) and “bed-and-breakfasting” (wash sale rules).</p><p>To handle this, I use a virtual currency called <code>CGT-GBP</code> that represents “pounds of gain HMRC cares about”. My plugin, <a href="https://github.com/LalitMaganti/beancount-lalitm/blob/main/src/beancount_tools/plugins/uk_cgt_lots.py"><code>uk_cgt_lots</code></a>, calculates this number and automatically appends a <strong>self-balancing pair of Equity postings</strong> to the original sale transaction:</p><div><pre tabindex="0"><code data-lang="fallback"><span><span>2024-06-15 * &#34;SELL AAPL&#34;
</span></span><span><span>  Assets:Lalit:US:IB:Brokerage:AAPL           -10 AAPL {150.00 USD} @ 175.00 USD
</span></span><span><span>  Assets:Lalit:US:IB:Brokerage:USD            1750.00 USD
</span></span><span><span>  Income:Lalit:US:IB:Brokerage:AAPL:Capital-Gains  -250.00 USD
</span></span><span><span>  ; The following postings are generated by the uk_cgt_lots plugin:
</span></span><span><span>  Equity:Taxable-Capital-Gains              195.00 CGT-GBP
</span></span><span><span>  Equity:Taxable-Capital-Gains-Placeholder -195.00 CGT-GBP
</span></span></code></pre></div><p>Since both legs are in <code>Equity</code>, they remain invisible on my Income Statement in my daily “Net” view. In fact, I use <code>rename_accounts</code> to collapse them into a single account so they net to zero:</p><div><pre tabindex="0"><code data-lang="fallback"><span><span>; journal-net.beancount
</span></span><span><span>plugin &#34;beancount_reds_plugins.rename_accounts.rename_accounts&#34; &#34;{
</span></span><span><span>  &#39;Equity:Taxable-Capital-Gains-Placeholder&#39; : &#39;Equity:Taxable-Capital-Gains&#39;,
</span></span><span><span>}&#34;
</span></span></code></pre></div><p>But when I want to see my tax liability, I switch to the <strong>CGT View</strong>. This view renames the “Placeholder” to a visible Revenue account:</p><div><pre tabindex="0"><code data-lang="fallback"><span><span>; journal-cgt.beancount
</span></span><span><span>plugin &#34;beancount_reds_plugins.rename_accounts.rename_accounts&#34; &#34;{
</span></span><span><span>  &#39;Equity:Taxable-Capital-Gains-Placeholder&#39; : &#39;Revenues:Taxable-Capital-Gains&#39;,
</span></span><span><span>}&#34;
</span></span></code></pre></div><p>Now, the -195.00 becomes Revenue, which shows up as profit on my tax report. The matching +195.00 remains in Equity. This allows me to have “Schrödinger’s Capital Gains”: they exist for the taxman, but not for my daily budget, all controlled by which view I load.</p><p>I don’t calculate the tax owed since that’s too complicated with allowances, rates, and bands; the system just tracks the gains. At tax time, I sum up the CGT-GBP balance and do the actual calculation on the tax form.</p><h4 id="exit-ramp-3">Exit ramp</h4><p>By separating your “source of truth” from your “lenses,” you get a system that grows with you. You can add new plugins or virtual currencies to solve specific problems (like taxes) without ever touching the raw transactions you’ve already imported.</p><p>In the final chapter, we’ll see the ultimate application of this: combining two people’s financial lives into one unified view.</p><h2 id="chapter-6-two-people-one-number">Chapter 6: Two People, One Number</h2><p>I got married at the start of the year, which brought a fundamental change to how I manage my finances. While many couples use joint accounts, we prefer to keep our individual accounts and perform occasional “normalization” transfers. However, we view our combined resources as shared household wealth.</p><p>This created a reporting paradox that I had to solve in Beancount.</p><h4 id="the-paradox">The Paradox</h4><p>When I transfer £500 to my wife for my share of the bills, two things are true simultaneously:</p><ol><li><strong>The Individual Truth:</strong> From my perspective, £500 is “gone” (an expense). From her perspective, £500 has “arrived” (income).</li><li><strong>The Household Truth:</strong> For the household, the net worth hasn’t changed. Money just moved from the left pocket to the right pocket.</li></ol><p>In a traditional system, you usually have to pick one truth. In Beancount, we can have both.</p><h4 id="the-composable-architecture">The Composable Architecture</h4><p>To solve this, I treat the household as a composable system of three distinct entities: <strong>Me</strong>, <strong>Her</strong>, and <strong>Shared Definitions</strong>. We use Beancount’s <code>include</code> feature to build the specific “lens” we need at any given moment:</p><ul><li><strong>Lalit’s View</strong> = Shared Definitions + Lalit’s Transactions</li><li><strong>Wife’s View</strong> = Shared Definitions + Wife’s Transactions</li><li><strong>Household View</strong> = Shared Definitions + Lalit’s Transactions + Wife’s Transactions + <em>Translation Logic</em></li></ul><p>For example, the household view literally just includes the other files (alongside the translation logic we’ll see in a moment):</p><div><pre tabindex="0"><code data-lang="fallback"><span><span>; chapter-6/total/journal-net.beancount
</span></span><span><span>include &#34;../common/src/commodities.beancount&#34;
</span></span><span><span>include &#34;../common/src/accounts.beancount&#34;
</span></span><span><span>
</span></span><span><span>include &#34;../lalit/src/journal.beancount&#34;
</span></span><span><span>include &#34;../wife/src/journal.beancount&#34;
</span></span><span><span>
</span></span><span><span>; ... Translation Logic follows
</span></span></code></pre></div><h4 id="implementation-the-directory-structure">Implementation: The Directory Structure</h4><p>This architecture is reflected directly in the repository structure:</p><div><pre tabindex="0"><code data-lang="fallback"><span><span>chapter-6/
</span></span><span><span>├── common/                    # Shared configuration
</span></span><span><span>│   └── src/
</span></span><span><span>│       ├── accounts.beancount   # Shared expense accounts (e.g. Expenses:Groceries)
</span></span><span><span>│       └── commodities.beancount
</span></span><span><span>├── lalit/                     # My stuff
</span></span><span><span>│   ├── src/                   # My ledger
</span></span><span><span>│   └── data/                  # My statement PDFs/CSVs
</span></span><span><span>├── wife/                      # Wife&#39;s stuff
</span></span><span><span>│   ├── src/                   # Her ledger
</span></span><span><span>│   └── data/                  # Her statement PDFs/CSVs
</span></span><span><span>└── total/                     # Combined household view
</span></span><span><span>    └── journal-net.beancount  # Entry point with Translation Logic
</span></span></code></pre></div><h4 id="the-rules-of-engagement">The Rules of Engagement</h4><p>For this to work without constant manual adjustment, we follow two simple rules:</p><p><strong>Rule 1: Assets and Liabilities are Private.</strong>
Bank accounts always include the person’s name in the path (e.g., <code>Assets:Lalit:HSBC</code> or <code>Assets:Wife:HSBC</code>). We never use a generic <code>Assets:Checking</code> account. Legal ownership of the cash always matters.</p><p><strong>Rule 2: Expenses are Public.</strong>
Shared expenses like groceries or electricity use a generic name without a person prefix.</p><div><pre tabindex="0"><code data-lang="fallback"><span><span>; chapter-6/common/src/accounts.beancount
</span></span><span><span>2024-01-01 open Expenses:Groceries                   GBP
</span></span></code></pre></div><p>When I buy groceries, I record it in my ledger using the shared account. We don’t track “who owes what” for individual grocery runs; we just track that the household spent the money. We accept that we lose the ability to split shared expenses by person, but the gain in simplicity is worth it.</p><h4 id="the-magic-solving-the-transfer-paradox">The “Magic”: Solving the Transfer Paradox</h4><p>Finally, we use the <code>rename_accounts</code> plugin in the <code>total/</code> folder to resolve the transfer paradox.</p><p>In my ledger, a transfer looks like a simple expense:</p><div><pre tabindex="0"><code data-lang="fallback"><span><span>; chapter-6/lalit/src/transactions.beancount
</span></span><span><span>2024-01-20 * &#34;Transfer to Wife&#34;
</span></span><span><span>  Expenses:Lalit:Transfers:Wife       500.00 GBP
</span></span><span><span>  Assets:Lalit:UK:HSBC:Current:GBP
</span></span></code></pre></div><p>In her ledger, it looks like income:</p><div><pre tabindex="0"><code data-lang="fallback"><span><span>; chapter-6/wife/src/transactions.beancount
</span></span><span><span>2024-01-20 * &#34;Transfer from Lalit&#34;
</span></span><span><span>  Assets:Wife:UK:HSBC:Current:GBP     500.00 GBP
</span></span><span><span>  Income:Wife:Transfers:Lalit
</span></span></code></pre></div><p>The “Translation Logic” in the combined view renames these into a shared transit account:</p><div><pre tabindex="0"><code data-lang="fallback"><span><span>; chapter-6/total/journal-net.beancount
</span></span><span><span>plugin &#34;beancount_reds_plugins.rename_accounts.rename_accounts&#34; &#34;{
</span></span><span><span>  &#39;Expenses:Lalit:Transfers:Wife&#39;: &#39;Assets:Household:Transfers:Internal&#39;,
</span></span><span><span>  &#39;Income:Wife:Transfers:Lalit&#39;: &#39;Assets:Household:Transfers:Internal&#39;,
</span></span><span><span>}&#34;
</span></span></code></pre></div><p>Now, when Fava loads the combined view, it sees £500 leave my account and enter <code>Assets:Household:Transfers:Internal</code>, and then £500 leave that same account and enter her bank account. The transit account nets to zero, and our household net worth remains unchanged.</p><h4 id="the-result">The Result</h4><p>This setup gives us the best of both worlds. I can maintain my own financial autonomy and see my personal “runway,” while we can simultaneously monitor our combined progress toward shared goals.</p><p><img src="https://lalitm.com/img/one-number-i-trust/12-household-balance-sheet.png" alt="Combined Household Balance Sheet" title="Two people, one number"/></p><p><em>The final result: a unified household view that tracks legal ownership without sacrificing the &#34;One Number&#34; net worth total.</em></p><p>That’s the full system (see <a href="https://github.com/LalitMaganti/beancount-blog-examples/tree/main/chapter-6">chapter-6</a> for the complete multi-person structure). But how do I actually use it week to week?</p><h2 id="the-weekly-ritual">The weekly ritual</h2><p>Now here’s how I keep it current: the “20 minutes a week” I mentioned at the start:</p><ul><li><p><strong>Getting statements</strong>: During the week, banks email me saying a statement is available. Some attach PDFs directly; others require a login. Either way, I snooze the emails (I use inbox zero) until the weekend. For my wife’s accounts, I nudge her once a month and she drops stuff in a shared Drive folder.</p></li><li><p><strong>Running imports</strong>: On the weekend, I work through my snoozed emails. Note that I’m not updating every single account every week. I only download statements for the 3-4 accounts that saw activity; long-term investments often just get a monthly or quarterly check-in. I move each file to the correct <code>data/</code> subfolder for that institution (e.g., <code>data/hsbc-uk-current/</code>). My importer pipeline automatically runs <code>pdftotext</code> to extract text so the parsers can read it.</p></li><li><p><strong>Categorizing</strong>: I launch beancount-import, which opens a web UI in my browser:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>python -m beancount_import.webserver --journal lalit/journal-net.beancount
</span></span></code></pre></div><p>As I mentioned before, most transactions auto-categorize and I’m just hitting Enter: I buy groceries from the same place, pay my hosting costs to the same provider etc. New merchants do need some manual work, but it’s a matter of typing a few characters and again pressing Enter.</p></li><li><p><strong>Formatting and checking</strong>: I run <code>bean-format</code> (a Beancount utility that normalizes indentation and aligns amounts) to keep my transactions file tidy. This makes git diffs cleaner. Then I open Fava for a quick sanity check:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>fava lalit/journal-net.beancount
</span></span></code></pre></div><p>Are transfer accounts zeroed out? Do expenses look legit? How are investments doing? If it all checks out, commit and push.</p></li></ul><p>That’s it. I try to stick to doing this <em>every week</em>, but sometimes I’m on holiday or just have other commitments. In that case, it’s 40 minutes every two weeks. The system is forgiving; I’m never behind for too long.</p><p>I also have some automation helping me out: during the week, I have a CI workflow that runs daily, regenerates summaries, and commits them. Whenever I want, I can check the repo and see what the numbers look like. I particularly like this because I can easily see the before/after numbers in a single file, so I can spot check “does this make sense”. And of course at any time, I can also open Fava if I want to go a bit deeper.</p><h2 id="conclusion">Conclusion</h2><p>That 2021 tax disaster feels like a lifetime ago. What started as “there must be a better way” became a system I actually trust. One number, always current, completely under my control.</p><p>The specifics will evolve as life changes and tools improve, but three principles have held for years now. I expect them to hold for decades:</p><p><strong>Double-entry everywhere.</strong> Every transaction balances. Money never appears from nowhere or vanishes into nothing. When something doesn’t add up, you know immediately.</p><p><strong>Plain text as the source of truth.</strong> Your financial history lives in files you can read, diff, grep, and version control. No vendor lock-in, no opaque databases, no trusting a third party with your data.</p><p><strong>Track at the leaf.</strong> Record transactions at the most granular level that makes sense. You can always aggregate up (<code>Income:Dividends</code> from <code>Income:IB:AAPL:Dividends</code>), but you can never disaggregate down. Capture the detail; collapse it later with views.</p><p>Finance systems are deeply personal. This post isn’t meant to say this is <em>the</em> system everyone should use, just what’s worked for me over several years.</p><p>Each chapter here could be its own post, so if you want me to go deeper on imports, investments, or the multi-person setup, let me know!</p></section><p><em>If you enjoyed this post, you can <a href="https://lalitm.com/page/about/#subscribe">subscribe</a> to my weekly roundup of recent posts, or follow via <a href="https://lalitm.com/index.xml">RSS</a>.</em></p></div>
  </body>
</html>
