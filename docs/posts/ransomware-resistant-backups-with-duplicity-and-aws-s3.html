<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.franzoni.eu/ransomware-resistant-backups/">Original</a>
    <h1>Ransomware-resistant backups with duplicity and AWS S3</h1>
    
    <div id="readability-page-1" class="page"><div>
            <!--kg-card-begin: markdown--><h2 id="ransomware-and-backups">Ransomware and backups</h2>
<p>Ransomware is changing the security scenario. Once upon a time, attackers who entered your systems could pull some data to sell it somewhere; they could deface your website for kudos; but, unless they had some compelling reason (disgruntled former employees), they probably wouldn&#39;t destroy your data and your backups.</p>
<p>Now they would, though. Cryptocurrencies make it very easy to ask for a ransom  and never get caught. Hence, <a href="https://en.wikipedia.org/wiki/CryptoLocker">cryptolocker-like</a> malwares are spreading. You&#39;re not safe just because <em>why should anybody hack into my little server</em>: if a widespread exploit is found, cybercriminals will perform a mass scan on the whole internet, exploit and implant a malware on every single vulnerable system, then ask some amount of cryptocurrency to get your data back.</p>
<p>So: <strong>people should revise their own threat models</strong>. And your backup strategy is likely one of the first things you should revise. It&#39;s quite likely it was designed for a <strong>failure scenario</strong> (hardware failure, accidental deletion), not for an <strong>attack scenario</strong>. But even half-serious cybercriminals, once they get access to your server, <strong>will delete all backup sets they can access</strong>, so that their encrypt-your-data-and-ask-for-money threat actually works.</p>
<h2 id="once-upon-a-time">Once upon a time</h2>
<p>You had backups on a <a href="https://en.wikipedia.org/wiki/Tape_drive">tape library</a>. A tape drive is usually append-only, and the backup is handled through a dedicated system so it was hard (if possible at all) and clunky to wipe an older backup from a compromised system. And tapes would get physically rotated - getting hold of an old tape was not feasible for a remote attacker, so at least you got an older backup which was safe.</p>
<p>Then approaches like <a href="https://www.bacula.org/">bacula</a> were common - the bacula server (where the backups are saved) would contact the bacula clients (systems to be backed up) and asked for data to be saved. The bacula server deleted old data using its own schedule, there was no way for the bacula client to tell it &#34;wipe everything&#34; so again, barring any bacula server exploit, bacula server data held backups safe.</p>
<p>More recently, cloud approaches like <a href="https://www.rsync.net/">rsync.net</a> leverage ZFS snapshots to make remote data immutable - they can be removed only according to your retention schedule (<a href="https://www.rsync.net/resources/howto/snapshots.html">details</a>).</p>
<p>But, many modern backup systems don&#39;t take the ransomware scenario into account, since the backup software needs full access to a local or remote filesystem. Some actually try: <a href="https://restic.net/">restic</a> offers <a href="https://github.com/restic/rest-server">rest-server</a>, which has an append-only option to prevent malicious deletion of the server&#39;s content. But you need an additional system just to host the server.</p>
<h2 id="the-cloud-to-the-rescue">The cloud to the rescue</h2>
<p>So, here we&#39;ll see how to use the good old <a href="https://duplicity.gitlab.io/duplicity-web/">duplicity</a> backup software to perform backups to AWS S3 in a ransomware-resistant way. You can use any cloud storage that supports properly fine-grained permissions (see later) and is supported by duplicity.</p>
<p>For the sake of this article, I suppose you&#39;ve got access to two distinct machines: your <strong>workstation</strong> and your <strong>server</strong>, and you&#39;d like to have your <strong>server</strong> backed up. You could actually employ a single machine to perform all the steps, but you&#39;ll need to make sure that your master access to AWS S3 is never compromised, otherwise say goodbye to your ransomware resistance.</p>
<p>So, make yourself a favour and use two separate machines.</p>
<h2 id="create-your-s3-bucket-and-credentials">Create your S3 bucket and credentials</h2>
<p><em>Those steps must be taken from your workstation</em></p>
<p>These examples don&#39;t leverage the aws cli to prevent accidents with API key leakeges; if you use the AWS S3 Console, and you&#39;ve properly configured 2FA for your account, it&#39;s less likely you can be attacked that way.</p>
<h3 id="create-the-bucket">Create the bucket</h3>
<p>Enter the AWS Console, choose the S3 service, create a bucket (we&#39;ll call it <em>sample-duplicity-backup</em> for the sake of this article) in your preferred region (I will use <em>eu-central-1</em>) ; and use these settings:</p>
<h4 id="disable-acls">Disable ACLs</h4>
<p><img src="https://www.franzoni.eu/content/images/2022/01/S3_bucket-1-1.jpg" alt="S3_bucket-1-1" loading="lazy"/></p>
<h4 id="block-public-access">Block public access</h4>
<p><img src="https://www.franzoni.eu/content/images/2022/01/S3_bucket-2-1.jpg" alt="S3_bucket-2-1" loading="lazy"/></p>
<h4 id="enable-bucket-versioning">Enable bucket versioning</h4>
<p><img src="https://www.franzoni.eu/content/images/2022/01/S3_bucket-3-1.jpg" alt="S3_bucket-3-1" loading="lazy"/></p>
<h4 id="enable-object-lock">Enable object lock</h4>
<p><img src="https://www.franzoni.eu/content/images/2022/01/S3_bucket-4-1.jpg" alt="S3_bucket-4-1" loading="lazy"/></p>
<h4 id="configure-object-lock">Configure object lock</h4>
<p>Then, select the bucket you just created, go to Properties, choose Object Lock, and enable Default Retention. For the purpose we have, Governance mode is OK; choose a 40 days default retention period, and save your changes.</p>
<p><img src="https://www.franzoni.eu/content/images/2022/01/sample-duplicity-backup_objectlock.jpg" alt="sample-duplicity-backup_objectlock" loading="lazy"/></p>
<h3 id="create-a-iam-user">Create a IAM user</h3>
<p>Now you need to <a href="https://console.aws.amazon.com/iamv2/home#/users">create a suitable IAM user</a> to be used with duplicity. Let&#39;s call this <code>sample-duplicity-user</code>; it should only have programmatic access, and you should attach <strong>only</strong> this policy to such user:</p>
<pre><code>{
    &#34;Version&#34;: &#34;2012-10-17&#34;,
    &#34;Statement&#34;: [
        {
            &#34;Effect&#34;: &#34;Allow&#34;,
            &#34;Action&#34;: [
                &#34;s3:PutObject&#34;,
                &#34;s3:GetObject&#34;,
                &#34;s3:ListBucketMultipartUploads&#34;,
                &#34;s3:AbortMultipartUpload&#34;,
                &#34;s3:ListBucket&#34;,
                &#34;s3:ListMultipartUploadParts&#34;
            ],
            &#34;Resource&#34;: [
                &#34;arn:aws:s3:::sample-duplicity-backup&#34;,
                &#34;arn:aws:s3:::sample-duplicity-backup/*&#34;
            ]
        }
    ]
}
</code></pre>
<p>Download the access key ID and the secret access key for such user.</p>
<h2 id="install-duplicity">Install duplicity</h2>
<p><em>The following steps must be performed on the server</em></p>
<p>Duplicity may be available in your distribution, but I suggest you pick a recent version (0.8.x) in order to make sure the s3 remote backend is properly supported - check <a href="https://duplicity.gitlab.io/duplicity-web/">the homepage</a> for further info. Also make sure the <code>boto3</code> library and <code>gnupg</code> are available on your system.</p>
<p>As an example, for recent Ubuntu versions (tested on 20.04):</p>
<ul>
<li>Add the <a href="https://code.launchpad.net/~duplicity-team/+archive/ubuntu/duplicity-release-git">stable duplicity PPA</a></li>
<li><code>apt -y install duplicity python3-boto3 gnupg</code></li>
</ul>
<h2 id="create-a-backup-script">Create a backup script</h2>
<p>Put some data in <code>/root/data</code> for the purpose of this test.</p>
<p>Then, add the following snippet to a script; set the passphrase as you wish (duplicity encrypts the backups using symmetric cryptography - support for public key crypto is available but I haven&#39;t had great success with it so far), and fill in the AWS credentials you got from the previous step:</p>
<pre><code>#!/bin/bash -e
export PASSPHRASE=&#34;XYZXYZXYZ&#34;
export AWS_ACCESS_KEY_ID=&#34;XXXXXXX&#34;
export AWS_SECRET_ACCESS_KEY=&#34;YYYYYYYYY&#34;
/usr/bin/duplicity \
--s3-european-buckets \
  --s3-use-new-style  --asynchronous-upload -v 4 \
   incr --full-if-older-than 30D \
  /root/data \
  &#34;boto3+s3://sample-duplicity-backup/data&#34;
</code></pre>
<p>This command will backup the contents of <code>/root/data</code> to your s3 bucket, using a</p>
<p>One detail to note: the <code>--full-if-older 30D</code> means: <em>create an incremental backup</em>. It is <strong>essential</strong> that the number of days that we set here is smaller than the object lock days.</p>
<p>So, great! Now, from your workstation, you can check that your S3 bucket contains some data; check the Objects tab of your bucket, and enter the <em>data</em> directory:</p>
<p><img src="https://www.franzoni.eu/content/images/2022/01/sample-duplicity-backup_-_S3_bucket.jpg" alt="sample-duplicity-backup_-_S3_bucket" loading="lazy"/></p>
<p>If you like, you can run the script again. You&#39;ll notice that duplicity <em>only adds new data to the s3 bucket, it never removes or changes existing files once they have been uploaded.</em></p>
<h2 id="attack-scenario">Attack scenario</h2>
<p>Now a Bad Guy exploits a vulnerability and takes total, root control of your server. He gets all your data; you can&#39;t help that, it&#39;s compromised. He even gets access to the credentials for <code>sample-duplicity-user</code>, and, being Bad, after deleting your data directory he tries to delete the content of your backup bucket.</p>
<p>For the sake of simplicity, we&#39;ll configure an aws cli account (do it either on your workstation or on your server, it doesn&#39;t really make a difference. Remember to delete such credentials afterwards) using the same <code>sample-duplicity-user</code> credentials and pretend you&#39;re the badguy:</p>
<p><code>aws configure --profile badguy</code></p>
<p>Now, try acting as the Bad Guy:</p>
<pre><code>$ aws --profile badguy s3 ls s3://sample-duplicity-backup/data/
2022-01-25 21:41:36       3228 duplicity-full-signatures.20220125T204132Z.sigtar.gpg
2022-01-25 21:41:37        267 duplicity-full.20220125T204132Z.manifest.gpg
2022-01-25 21:41:36      27298 duplicity-full.20220125T204132Z.vol1.difftar.gpg
</code></pre>
<p>He can read the backup. This is expected. But can he <strong>delete</strong> the backup?</p>
<pre><code>$ aws --profile badguy s3 rm s3://sample-duplicity-backup/data/duplicity-full.20220125T204132Z.manifest.gpg
delete failed: s3://sample-duplicity-backup/data/duplicity-full.20220125T204132Z.manifest.gpg An error occurred (AccessDenied) when calling the DeleteObject operation: Access Denied
</code></pre>
<p>The attacker cannot delete files; our object lock policy prevents that!</p>
<p>But, there&#39;s still one thing that the attacker could do: <strong>overwrite</strong> existing files. In fact, AWS S3 Put actions (and permissions) don&#39;t make a distinction between &#34;add an object&#34; or &#34;overwrite an existing object&#34; (and it would be quite difficult and slow to implement in a distributed storage system):</p>
<pre><code>$ aws --profile badguy s3 cp temp.txt s3://sample-duplicity-backup/data/duplicity-full.20220125T204132Z.manifest.gpg
upload: ./temp.txt to s3://sample-duplicity-backup/data/duplicity-full.20220125T204132Z.manifest.gpg
</code></pre>
<p>Ouch! This (apparently) succeeded:</p>
<p><img src="https://www.franzoni.eu/content/images/2022/01/sample-duplicity-backup_-_S3_bucket-update.jpg" alt="sample-duplicity-backup_-_S3_bucket-update" loading="lazy"/></p>
<p>But the reality is that <strong>the original data is still there:</strong> the attacker has uploaded a new file with same name as ours, but we can still retrieve the first version; Object Lock and Bucket Versioning work together. Check the &#34;Versions&#34; tab for our modified file:</p>
<p><img src="https://www.franzoni.eu/content/images/2022/01/sample-duplicity-backup_-_S3_bucket-versions.jpg" alt="sample-duplicity-backup_-_S3_bucket-versions" loading="lazy"/></p>
<p>Choose the older version and download it: it&#39;s the original file! So, if you get hit by a ransomware, you can still retrieve all your original files. Accessing those in a programmatic way requires the <em>s3:ListBucketVersions</em> permission (check the <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListObjectVersions.html">API call as well</a>) - we don&#39;t even have it for our backup IAM user.</p>
<h2 id="retrieving-the-original-files">Retrieving the original files</h2>
<p>A full demonstration of how to retrieve the original files is trivial and beyond the scope of this article; but I&#39;ll leave some breadcrumbs here. With an user with the ListBucketVersions permissions, call this command:</p>
<pre><code>$ aws s3api list-object-versions --bucket sample-duplicity-backup
{
    &#34;Versions&#34;: [
        ...
        {
            &#34;ETag&#34;: &#34;\&#34;500e2a10137f805dba21f4bb7bf3678a\&#34;&#34;,
            &#34;Size&#34;: 50,
            &#34;StorageClass&#34;: &#34;STANDARD&#34;,
            &#34;Key&#34;: &#34;data/duplicity-full.20220125T204132Z.manifest.gpg&#34;,
            &#34;VersionId&#34;: &#34;w_ZOOamRomLYpZO5Gc.Vy_nrl0cP6bWq&#34;,
            &#34;IsLatest&#34;: true,
            &#34;LastModified&#34;: &#34;2022-01-25T20:50:15+00:00&#34;,
            &#34;Owner&#34;: {
                &#34;ID&#34;: &#34;132149dd72a1af36909b73ae719ccba0096cd23aa62158308ef4b9619f3b63ed&#34;
            }
        },
        {
            &#34;ETag&#34;: &#34;\&#34;2dd325e03ac11eb6edaf0e9a7b177064\&#34;&#34;,
            &#34;Size&#34;: 267,
            &#34;StorageClass&#34;: &#34;STANDARD&#34;,
            &#34;Key&#34;: &#34;data/duplicity-full.20220125T204132Z.manifest.gpg&#34;,
            &#34;VersionId&#34;: &#34;ORkLIhukxVZKTeQruI9hPDWXUzAJoYgb&#34;,
            &#34;IsLatest&#34;: false,
            &#34;LastModified&#34;: &#34;2022-01-25T20:41:37+00:00&#34;,
            &#34;Owner&#34;: {
                &#34;ID&#34;: &#34;132149dd72a1af36909b73ae719ccba0096cd23aa62158308ef4b9619f3b63ed&#34;
            }
        },
        ...
    ]
}
</code></pre>
<p>Then retrieve this file in its older version:</p>
<pre><code>$ aws s3api get-object --bucket sample-duplicity-backup --key data/duplicity-full.20220125T204132Z.manifest.gpg duplicity-full.20220125T204132Z.manifest.gpg  --version-id &#34;ORkLIhukxVZKTeQruI9hPDWXUzAJoYgb&#34;
{
    &#34;AcceptRanges&#34;: &#34;bytes&#34;,
    &#34;LastModified&#34;: &#34;2022-01-25T20:41:37+00:00&#34;,
    &#34;ContentLength&#34;: 267,
    &#34;ETag&#34;: &#34;\&#34;2dd325e03ac11eb6edaf0e9a7b177064\&#34;&#34;,
    &#34;VersionId&#34;: &#34;ORkLIhukxVZKTeQruI9hPDWXUzAJoYgb&#34;,
    &#34;ContentType&#34;: &#34;binary/octet-stream&#34;,
    &#34;Metadata&#34;: {}
}
$ ls *.gpg
duplicity-full.20220125T204132Z.manifest.gpg
</code></pre>
<p>Apply for all files where you actually need it. Actually, it&#39;s quite likely that the attacker will have noticed the bucket is versioned and object locked, so he won&#39;t waste time at overwriting all files.</p>
<h2 id="wrapping-up">Wrapping up</h2>
<p>I hope this article can be useful from an implementation standpoint, but the most important takeaway is: <strong>always think about your threat model every time you take a decision</strong>. Reason in the terms of what an attacker could do when entering your system; <strong>security is never binary</strong>.</p>
<p>And, please: <strong>don&#39;t run your applications as root, but run your backup script as root, and make sure its ownership and permissions are properly set</strong>, like <code>-rwx------ 1 root root 365 Dec  9 21:52 duplicity_run</code>. It&#39;s great to have a ransomware resistant backup, but you shouldn&#39;t make things too easy for an attacker!</p>
<h3 id="an-exercise">An exercise</h3>
<p>An attacker enters your server, but he realizes you&#39;re using object lock and bucket versioning. But he really wants to find a way to get some money from you, since he knows you&#39;re full of XMR in your wallets. Hypothesize how could he proceed, then go on and think about what you could do to prevent damages to your system and to your backups.</p>
<p><em>To my readers:</em> since this is sort of security-related and a topic with a potentially high impact, please let me know if got anything wrong. Contact me by commenting or directly via e-mail.</p>
<!--kg-card-end: markdown-->

        
	
        </div></div>
  </body>
</html>
