<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://funktionale-programmierung.de/en/2018/03/22/transducer.html">Original</a>
    <h1>Transducer: Composition, abstraction, performance (2018)</h1>
    
    <div id="readability-page-1" class="page"><div>

<p>Higher-order functions like <code>map</code>, <code>fold</code>, <code>filter</code> are indispensable in any
functional program. With their flexibility, they are the tool of choice for
operations on collections of all kinds. However, their scope of application is
not limited to classic lists or vectors. In this article, we examine more
fundamental properties of these operations and take a particular look at
so-called transducers in the Clojure programming language.</p>

<!-- more start -->

<p>Additionally, we will see how we can achieve not only very good reusability but
also higher performance with the help of meaningful abstraction.</p>

<h2 id="everything-is-a-fold">Everything is a <code>fold</code></h2>

<p>Those who have engaged with functional programming in the past may already be
familiar with this statement. If you haven‘t had the opportunity yet (or want to
refresh your memory), let‘s first look at a variant of the usual definitions of
<code>map</code> and <code>filter</code>. (Note: All examples are written in Clojure, so from this
point on we‘ll call <code>fold</code> by its Clojure name <code>reduce</code>):</p>

<div><div><pre><code><span>(</span><span>defn</span><span> </span><span>map</span><span>
  </span><span>&#34;Takes a function f and applies it to every element of xs.&#34;</span><span>
  </span><span>[</span><span>f</span><span> </span><span>xs</span><span>]</span><span>
  </span><span>(</span><span>if</span><span> </span><span>(</span><span>empty?</span><span> </span><span>xs</span><span>)</span><span>
    </span><span>xs</span><span>
    </span><span>(</span><span>cons</span><span> </span><span>(</span><span>f</span><span> </span><span>(</span><span>first</span><span> </span><span>xs</span><span>))</span><span> </span><span>(</span><span>map</span><span> </span><span>f</span><span> </span><span>(</span><span>rest</span><span> </span><span>xs</span><span>)))))</span><span>

</span><span>(</span><span>defn</span><span> </span><span>filter</span><span>
  </span><span>&#34;Takes a predicate pred and returns a list with all elements of xs that
  satisfy pred.&#34;</span><span>
  </span><span>[</span><span>pred</span><span> </span><span>xs</span><span>]</span><span>
  </span><span>(</span><span>if</span><span> </span><span>(</span><span>empty?</span><span> </span><span>xs</span><span>)</span><span>
    </span><span>xs</span><span>
    </span><span>(</span><span>if</span><span> </span><span>(</span><span>pred</span><span> </span><span>(</span><span>first</span><span> </span><span>xs</span><span>))</span><span>
      </span><span>(</span><span>cons</span><span> </span><span>(</span><span>first</span><span> </span><span>xs</span><span>)</span><span> </span><span>(</span><span>filter</span><span> </span><span>pred</span><span> </span><span>(</span><span>rest</span><span> </span><span>xs</span><span>)))</span><span>
      </span><span>(</span><span>filter</span><span> </span><span>pred</span><span> </span><span>(</span><span>rest</span><span> </span><span>xs</span><span>)))))</span><span>
</span></code></pre></div></div>

<p>Many definitions can be found like this in various standard libraries. As the
heading of this section already reveals, both functions can also be defined via
<code>fold</code> (or rather <code>reduce</code>). The signature of <code>reduce</code>, expressed in Haskell
notation, looks like this: <code>(b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b</code> (specialized for
lists in this case).</p>

<div><div><pre><code><span>(</span><span>defn</span><span> </span><span>mapping</span><span>
  </span><span>&#34;Takes a function f and returns a function. The returned function takes a
  collection acc and an element x and appends x applied to f to the end of
  acc.&#34;</span><span>
  </span><span>[</span><span>f</span><span>]</span><span>
  </span><span>(</span><span>fn</span><span> </span><span>[</span><span>acc</span><span> </span><span>x</span><span>]</span><span> </span><span>(</span><span>conj</span><span> </span><span>acc</span><span> </span><span>(</span><span>f</span><span> </span><span>x</span><span>))))</span><span>

</span><span>(</span><span>defn</span><span> </span><span>map</span><span>
  </span><span>&#34;Takes a function f and applies it to every element of xs.&#34;</span><span>
  </span><span>[</span><span>f</span><span> </span><span>xs</span><span>]</span><span>
  </span><span>(</span><span>reduce</span><span> </span><span>(</span><span>mapping</span><span> </span><span>f</span><span>)</span><span> </span><span>[]</span><span> </span><span>xs</span><span>))</span><span>

</span><span>(</span><span>defn</span><span> </span><span>filtering</span><span>
  </span><span>&#34;Takes a predicate pred and returns a function. The returned function takes
  a collection acc and an element x and appends x to the end of acc if it
  satisfies pred.&#34;</span><span>
  </span><span>[</span><span>pred</span><span>]</span><span>
  </span><span>(</span><span>fn</span><span> </span><span>[</span><span>acc</span><span> </span><span>x</span><span>]</span><span> </span><span>(</span><span>if</span><span> </span><span>(</span><span>pred</span><span> </span><span>x</span><span>)</span><span> </span><span>(</span><span>conj</span><span> </span><span>acc</span><span> </span><span>x</span><span>)</span><span> </span><span>acc</span><span>)))</span><span>

</span><span>(</span><span>defn</span><span> </span><span>filter</span><span>
  </span><span>&#34;Takes a predicate pred and returns a list with all elements of xs that
  satisfy pred.&#34;</span><span>
  </span><span>[</span><span>pred</span><span> </span><span>xs</span><span>]</span><span>
  </span><span>(</span><span>reduce</span><span> </span><span>(</span><span>filtering</span><span> </span><span>pred</span><span>)</span><span> </span><span>[]</span><span> </span><span>xs</span><span>))</span><span>
</span></code></pre></div></div>

<p>If our programs consisted exclusively of list processing, we could stop here,
satisfied. However, something catches the eye: apart from the call to <code>conj</code>,
the definitions of <code>mapping</code> and <code>filtering</code> tell us nothing about them working
„only“ on collections!</p>

<h2 id="from-collections-to-processes">From Collections to Processes</h2>

<p>We have established that the connection to collections in our <code>mapping</code> and
<code>filtering</code> functions exists only through <code>conj</code>. Now let‘s go one step further
and see what happens when we abstract over <code>conj</code>. For this, it‘s helpful to
think not of lists but of sequences of steps. <code>mapping</code> and <code>filtering</code> take on
the role of „process modifications“: they receive a step and deliver a modified
version of this step. So let‘s define a version of our functions parameterized
over this „step“:</p>

<div><div><pre><code><span>(</span><span>defn</span><span> </span><span>mapping</span><span>
  </span><span>[</span><span>f</span><span>]</span><span>
  </span><span>(</span><span>fn</span><span> </span><span>[</span><span>step</span><span>]</span><span>
    </span><span>(</span><span>fn</span><span> </span><span>[</span><span>acc</span><span> </span><span>x</span><span>]</span><span> </span><span>(</span><span>step</span><span> </span><span>acc</span><span> </span><span>(</span><span>f</span><span> </span><span>x</span><span>)))))</span><span>

</span><span>(</span><span>defn</span><span> </span><span>map</span><span>
  </span><span>[</span><span>f</span><span> </span><span>xs</span><span>]</span><span>
  </span><span>(</span><span>reduce</span><span> </span><span>((</span><span>mapping</span><span> </span><span>f</span><span>)</span><span> </span><span>conj</span><span>)</span><span> </span><span>[]</span><span> </span><span>xs</span><span>))</span><span>

</span><span>(</span><span>defn</span><span> </span><span>filtering</span><span>
  </span><span>[</span><span>pred</span><span>]</span><span>
  </span><span>(</span><span>fn</span><span> </span><span>[</span><span>step</span><span>]</span><span>
    </span><span>(</span><span>fn</span><span> </span><span>[</span><span>acc</span><span> </span><span>x</span><span>]</span><span> </span><span>(</span><span>if</span><span> </span><span>(</span><span>pred</span><span> </span><span>x</span><span>)</span><span> </span><span>(</span><span>step</span><span> </span><span>acc</span><span> </span><span>x</span><span>)</span><span> </span><span>acc</span><span>))))</span><span>

</span><span>(</span><span>defn</span><span> </span><span>filter</span><span>
  </span><span>[</span><span>pred</span><span> </span><span>xs</span><span>]</span><span>
  </span><span>(</span><span>reduce</span><span> </span><span>((</span><span>filtering</span><span> </span><span>pred</span><span>)</span><span> </span><span>conj</span><span>)</span><span> </span><span>[]</span><span> </span><span>acc</span><span>))</span><span>
</span></code></pre></div></div>

<p>Looking at the resulting definitions of <code>mapping</code> and <code>filtering</code>, we notice
that the data structure on which they now operate is determined by the <code>step</code>
parameter. This means we are no longer dependent on classic collections, but can
(as we will see later) work with more or less arbitrary data structures and
process them using mapping and filtering. However, one consideration for this
step is still outstanding: while lists and vectors make it easy to think about a
„beginning“ and an „end,“ which we use in <code>map</code> and <code>filter</code>, it‘s different
with data structures like streams or signals. Instead of relying on the data
structure, we take a different path:</p>

<ol>
  <li>Our transformers (<code>mapping</code>, <code>filtering</code>) should have a concept of „beginning“
and „end“ by themselves.</li>
  <li>We expect from our <code>step</code> function not only that it is binary, but also that
when called with no or one argument, it produces a „null“ value. Examples in
Clojure would be <code>(conj) =&gt; [], (conj [1]) =&gt; [1]</code> or <code>(+) =&gt; 0, (+ 1) =&gt; 1</code>,
etc.</li>
</ol>

<p>We‘ll only address point 1 here. First, we‘ll propose an implementation of
mapping and filtering. In the code example below, we make use of Clojure‘s
syntax for „arity overloading.“ This means we can offer multiple implementations
in one function for different numbers of arguments (more on this at Clojure -
Functional Programming). Clojure will choose the corresponding implementation
depending on the number of arguments passed.</p>

<div><div><pre><code><span>(</span><span>defn</span><span> </span><span>mapping</span><span>
  </span><span>[</span><span>f</span><span>]</span><span>
  </span><span>(</span><span>fn</span><span> </span><span>[</span><span>step</span><span>]</span><span>
    </span><span>(</span><span>fn</span><span>
      </span><span>([]</span><span> </span><span>(</span><span>step</span><span>))</span><span> </span><span>; 1.</span><span>
      </span><span>([</span><span>acc</span><span>]</span><span> </span><span>(</span><span>step</span><span> </span><span>acc</span><span>))</span><span> </span><span>; 2.</span><span>
      </span><span>([</span><span>acc</span><span> </span><span>x</span><span>]</span><span> </span><span>(</span><span>step</span><span> </span><span>acc</span><span> </span><span>(</span><span>f</span><span> </span><span>x</span><span>)))</span><span> </span><span>; 3.</span><span>
      </span><span>)))</span><span>

</span><span>(</span><span>defn</span><span> </span><span>filtering</span><span>
  </span><span>[</span><span>pred</span><span>]</span><span>
  </span><span>(</span><span>fn</span><span> </span><span>[</span><span>step</span><span>]</span><span>
    </span><span>(</span><span>fn</span><span>
      </span><span>([]</span><span> </span><span>(</span><span>step</span><span>))</span><span>
      </span><span>([</span><span>acc</span><span>]</span><span> </span><span>(</span><span>step</span><span> </span><span>acc</span><span>))</span><span>
      </span><span>([</span><span>acc</span><span> </span><span>x</span><span>]</span><span> </span><span>(</span><span>if</span><span> </span><span>(</span><span>pred</span><span> </span><span>x</span><span>)</span><span>
        </span><span>(</span><span>step</span><span> </span><span>acc</span><span> </span><span>x</span><span>)</span><span>
        </span><span>acc</span><span>)))))</span><span>
</span></code></pre></div></div>

<p>At first glance, this may look somewhat unintuitive, but it‘s quickly explained
using the example of <code>mapping</code>. The numbering here corresponds to the numbers in
the code example above.</p>

<ol>
  <li>This case covers the „beginning“ of a process. Nothing has been calculated
yet and there is no „next“ calculation. In this case, we want a „neutral“
element from our <code>step</code> function with which we can kick off the calculation.</li>
  <li>Here we signal the „end“ of a process. No more elements are coming, so we
take the last step with the already available „result.“</li>
  <li>Finally, there‘s our case that processes the current result and an element
together.</li>
</ol>

<p>These functions are now parameterized to such an extent that we can express
somewhat arbitrary processes with them and, probably more importantly, execute
(or compose) multiple such process modifications in sequence! What does this
look like in reality?</p>

<h2 id="process-modifiers">Process Modifiers</h2>

<p>In the following, we give two examples of how all this helps us in the real
world and when we might prefer this approach to regular chaining of list
operations.</p>

<p>In both examples, we deal with the following problem: The semester is over and
the professor wants to know how good the average performance of their master‘s
students was in the exercise sessions. Using
<a href="https://clojure.org/guides/spec">Clojure-Spec</a>, we define some sample data. The
first four lines define the „shape“ of our data. For example, <code>::title</code> is a
value that satisfies the <code>string?</code>-predicate; in the fifth line, we specify
<code>::exercise</code> as a map with the keys defined above. The output of <code>sample</code> has
been prettified here a bit; the actual result would probably look somewhat more
obviously random. Those who want to learn more about Spec can do so <a href="http://funktionale-programmierung.de/2016/11/18/clojure-spec.html">in an older
blog article (German language
only)</a>.</p>

<div><div><pre><code><span>(</span><span>ns</span><span> </span><span>my.namespace</span><span>
  </span><span>(</span><span>:require</span><span> </span><span>[</span><span>clojure.spec.alpha</span><span> </span><span>:as</span><span> </span><span>s</span><span>]</span><span>
            </span><span>[</span><span>clojure.spec.gen.alpha</span><span> </span><span>:as</span><span> </span><span>sgen</span><span>]))</span><span>

</span><span>(</span><span>s/def</span><span> </span><span>::title</span><span> </span><span>string?</span><span>)</span><span>
</span><span>(</span><span>s/def</span><span> </span><span>::student</span><span> </span><span>string?</span><span>)</span><span>
</span><span>(</span><span>s/def</span><span> </span><span>::points</span><span> </span><span>(</span><span>set</span><span> </span><span>(</span><span>range</span><span> </span><span>31</span><span>)))</span><span>
</span><span>(</span><span>s/def</span><span> </span><span>::degree</span><span> </span><span>#</span><span>{</span><span>::msc</span><span> </span><span>::bsc</span><span>})</span><span>
</span><span>(</span><span>s/def</span><span> </span><span>::exercise</span><span> </span><span>(</span><span>s/keys</span><span> </span><span>:req</span><span> </span><span>[</span><span>::title</span><span> </span><span>::student</span><span> </span><span>::points</span><span> </span><span>::degree</span><span>]))</span><span>

</span><span>;; `sample` takes a generator for our `spec` and returns some random data that</span><span>
</span><span>;; matches this spec.</span><span>
</span><span>(</span><span>sgen/sample</span><span> </span><span>(</span><span>s/gen</span><span> </span><span>::exercise</span><span>))</span><span>
</span><span>;; =&gt;</span><span>
</span><span>;; [{::name &#34;Marco&#34;</span><span>
</span><span>;;   ::title &#34;Exercise 1&#34;</span><span>
</span><span>;;   ::points 29</span><span>
</span><span>;;   ::degree ::msc}</span><span>
</span><span>;;  {::name &#34;Mathias&#34;</span><span>
</span><span>;;   ::title &#34;Exercise 1&#34;</span><span>
</span><span>;;   ::points 28</span><span>
</span><span>;;   ::degree ::bsc}</span><span>
</span><span>;;  ...]</span><span>
</span></code></pre></div></div>

<p>Back to our task. This could be solved with regular list functions, for example,
like this:</p>

<div><div><pre><code><span>(</span><span>defn</span><span> </span><span>sum-of-msc</span><span>
  </span><span>[</span><span>exercises</span><span>]</span><span>
  </span><span>(</span><span>reduce</span><span> </span><span>+</span><span> </span><span>0</span><span> </span><span>(</span><span>-&gt;&gt;</span><span> </span><span>exercises</span><span>
                   </span><span>(</span><span>filter</span><span> </span><span>#</span><span>(</span><span>=</span><span> </span><span>::msc</span><span> </span><span>(</span><span>::degree</span><span> </span><span>%</span><span>)))</span><span>
                   </span><span>(</span><span>map</span><span> </span><span>::handins</span><span>))))</span><span>
</span></code></pre></div></div>

<p>Applied to a list of exercises, it gives us the correct result. However, there
is a problem: Each call to <code>filter</code>, <code>map</code>, and <code>reduce</code> computes a new list!
With large amounts of data, this can, as we‘ll see shortly, certainly lead to
problems.</p>

<p>Next, we implement the same functionality expressed via our newly defined
operators.</p>

<p>The first step will be a slightly modified version of <code>reduce</code> named
<code>reduce-with</code>. This works very similarly to <code>reduce</code>, except that in addition to
the reduction function (here <code>step</code>), it expects a parameter <code>xf</code>, which
represents a composition of our functions.</p>

<div><div><pre><code><span>(</span><span>defn</span><span> </span><span>reduce-with</span><span>
  </span><span>&#34;Takes a function composed of process modifications xf, a step function, an 
  initial value and a sequence of operations. Applies xf with a step to every x
  in xs.&#34;</span><span>
  </span><span>[</span><span>xf</span><span> </span><span>step</span><span> </span><span>init</span><span> </span><span>xs</span><span>]</span><span>
  </span><span>(</span><span>let</span><span> </span><span>[</span><span>f</span><span> </span><span>(</span><span>xf</span><span> </span><span>step</span><span>)]</span><span>
    </span><span>(</span><span>f</span><span> </span><span>(</span><span>reduce</span><span> </span><span>f</span><span> </span><span>init</span><span> </span><span>xs</span><span>))))</span><span>
</span></code></pre></div></div>

<p>Inside the function, we call <code>reduce</code> as usual. However, the composition
function xf is used as the reduction function, which is specialized for
evaluation via the <code>step</code> parameter (itself a function) and bound to <code>f</code>. Then
reduction occurs and the result is called once more with <code>f</code> to produce a final
result. But what must xf look like? This function, quite analogously to
<code>sum-of-msc</code> above, is also a composition of filtering and mapping. We call it
<code>xform</code> here (a convention in the Clojure world).</p>

<div><div><pre><code><span>;; Compose two process modificators into one.</span><span>
</span><span>(</span><span>def</span><span> </span><span>xform</span><span>
  </span><span>(</span><span>comp</span><span> </span><span>(</span><span>filtering</span><span> </span><span>#</span><span>(</span><span>=</span><span> </span><span>::msc</span><span> </span><span>(</span><span>::degree</span><span> </span><span>%</span><span>)))</span><span>
        </span><span>(</span><span>mapping</span><span> </span><span>::points</span><span>)))</span><span>
</span></code></pre></div></div>

<p>You may rightly wonder why the order of calls to <code>filtering</code> and <code>mapping</code>
doesn‘t change, since regular composition (as with Clojures <code>comp</code> function) is
evaluated „from right to left,“ but the threading in our <code>sum-of-msc</code> happens
„from left to right“ (or top to bottom). At this point, the complete answer
would exceed the scope. For the moment, let‘s just note that the composition of
this type of function also evaluates „from right to left.“ You can easily find
this out by completely reducing the composition of the functions by hand once.</p>

<div><div><pre><code><span>(</span><span>defn</span><span> </span><span>sum-of-msc-2</span><span>
  </span><span>[</span><span>exercises</span><span>]</span><span>
  </span><span>(</span><span>reduce-with</span><span> </span><span>xform</span><span> </span><span>+</span><span> </span><span>0</span><span> </span><span>exercises</span><span>))</span><span>
</span></code></pre></div></div>

<p>This solution also delivers the correct result, also revealing a major speedup:</p>

<div><div><pre><code><span>(</span><span>let</span><span> </span><span>[</span><span>exercises</span><span> </span><span>(</span><span>sgen/sample</span><span> </span><span>(</span><span>s/gen</span><span> </span><span>::exercises</span><span>)</span><span> </span><span>1000</span><span>)]</span><span>  </span><span>; generate a random sample of 1000 exercises</span><span>
  </span><span>(</span><span>=</span><span> </span><span>(</span><span>time</span><span> </span><span>(</span><span>sum-of-msc</span><span> </span><span>exercises</span><span>))</span><span>
     </span><span>(</span><span>time</span><span> </span><span>(</span><span>sum-of-msc-2</span><span> </span><span>exercises</span><span>))))</span><span>
</span><span>;; =&gt; true</span><span>
</span><span>;; &#34;Elapsed time: 407.378092 msecs&#34;</span><span>
</span><span>;; &#34;Elapsed time: 2.144632 msecs&#34;</span><span>
</span></code></pre></div></div>

<p>Upon closer inspection, the reason becomes obvious: Instead of computing a new
list for each step, the processes are executed sequentially for each element.
This saves us long intermediate results and gains us throughput.</p>

<p><strong>Note</strong>: Obviously, the timing varies a lot by the actual kind of inputs we
generate. Also, <code>time</code> is not really intended to be used as a measuring tool.
However, the tendency that the transducer-version is vastly faster than the
‚standard‘ implementation still stands, even over repeated observations.</p>

<p>This concept is so practical that it is now part of the Clojure standard library
under the name <code>transducer</code>. Many functions are already set up for use as
transducers (including the well-known <code>map</code>, <code>filter</code>, <code>mapcat</code>, …). Our
function <code>reduce-with</code> is defined there as <code>transduce</code>.</p>

<h2 id="more-than-lists">More Than Lists</h2>

<p>Finally, the promised second example. The problem is the same, but this time we
don‘t want to use lists but channels (via <code>clojure.core.async</code>). Here we write
all values to a channel <code>c</code> and observe how the same <code>xform</code> process
modification is applicable to these very channels. We also now use the built-in
function <code>transduce</code>, which takes over the work of <code>sum-of-msc-2</code>.</p>

<div><div><pre><code><span>(</span><span>ns</span><span> </span><span>my.namespace</span><span>
  </span><span>(</span><span>:require</span><span>
    </span><span>[</span><span>clojure.core.async</span><span> </span><span>:as</span><span> </span><span>async</span><span>]</span><span>
    </span><span>[</span><span>clojure.spec.alpha</span><span> </span><span>:as</span><span> </span><span>s</span><span>]</span><span>
    </span><span>[</span><span>clojure.spec.gen.alpha</span><span> </span><span>:as</span><span> </span><span>sgen</span><span>]))</span><span>

</span><span>(</span><span>let</span><span> </span><span>[</span><span>exercises</span><span> </span><span>(</span><span>sgen/sample</span><span> </span><span>(</span><span>s/gen</span><span> </span><span>::exercises</span><span>))</span><span>
      </span><span>;; Create a channel using the xform defined above.</span><span>
      </span><span>c</span><span> </span><span>(</span><span>async/chan</span><span> </span><span>1</span><span> </span><span>xform</span><span>)]</span><span>
      </span><span>;; Put all our elements onto the channel.</span><span>
    </span><span>(</span><span>async/go</span><span> </span><span>(</span><span>async/onto-chan</span><span> </span><span>c</span><span> </span><span>exercises</span><span>))</span><span>
    </span><span>(</span><span>let</span><span> </span><span>[</span><span>chan-res</span><span> </span><span>(</span><span>loop</span><span> </span><span>[</span><span>;; Read one element from the channel.</span><span>
                          </span><span>n</span><span> </span><span>(</span><span>async/&lt;!!</span><span> </span><span>c</span><span>)</span><span>
                          </span><span>res</span><span> </span><span>0</span><span>]</span><span>
                     </span><span>(</span><span>if-not</span><span> </span><span>n</span><span>
                       </span><span>res</span><span>
                       </span><span>(</span><span>recur</span><span> </span><span>(</span><span>async/&lt;!!</span><span> </span><span>c</span><span>)</span><span>  </span><span>; Read the next element from the channel.</span><span>
                              </span><span>(</span><span>+</span><span> </span><span>res</span><span> </span><span>n</span><span>)</span><span>  </span><span>; Accumulate the result.</span><span>
                              </span><span>)))</span><span>
          </span><span>list-res</span><span> </span><span>(</span><span>transduce</span><span> </span><span>xform</span><span> </span><span>+</span><span> </span><span>0</span><span> </span><span>exercises</span><span>)]</span><span>
      </span><span>(</span><span>=</span><span> </span><span>chan-res</span><span> </span><span>list-res</span><span>)))</span><span>
</span><span>;; =&gt; true</span><span>
</span></code></pre></div></div>

<p>Here we first put all elements into the channel (<code>onto-channel</code>). Then we read
step by step from this channel until no more elements are present in it (<code>&lt;!!</code>).
As we see from the result, our <code>xform</code> does exactly the same here as it did with
lists. Since our <code>xform</code> doesn‘t care what data structure it operates on (as
long as it provides the infrastructure mentioned above), it can be reused
without any changes and without problems!</p>

<h2 id="conclusion">Conclusion</h2>

<p>Conclusion Transducers are the natural continuation of widely used list
functions. In this article, we engaged with consistent abstraction and learned
the concept of <em>transducer</em> along the way. Not only do transducers give us a
powerful description of data transformations that is purely based on function
composition and can be used in many ways, but they also bring crucial
performance improvements.“
<!-- more end --></p>
</div></div>
  </body>
</html>
