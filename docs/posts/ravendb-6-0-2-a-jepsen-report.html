<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jepsen.io/analyses/ravendb-6.0.2">Original</a>
    <h1>RavenDB 6.0.2 (A Jepsen Report)</h1>
    
    <div id="readability-page-1" class="page"><p><a href="https://ravendb.net">RavenDB</a> is a document database which claims to offer ACID transactions, including Snapshot Isolation by default and Serializability with the strongest settings. Following the documentation’s claim that a session “represents a single business transaction,” we tested RavenDB 6.0.2 and found surprising behavior even in healthy, single-node clusters. Transactions lose updates by default. Both the optimistic concurrency and cluster-wide transaction modes allow fractured read: a serious anomaly forbidden by Snapshot Isolation and several weaker consistency models. Alternatively, RavenDB may not have interactive transactions at all. This work was performed independently without compensation, and conducted in accordance with the <a href="https://jepsen.io/ethics">Jepsen ethics policy</a>.</p><article>
  <div>

<p><a href="https://ravendb.net">RavenDB</a> is a distributed document database which <a href="https://ravendb.net/why-ravendb">repeatedly advertises</a> its support for ACID transactions.<a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a> It’s intended for OLTP workloads, and offers a variety of <a href="https://ravendb.net/docs/article-page/6.0/csharp/server/ongoing-tasks/etl/basics">ETL paths</a> for exporting data to other systems. Its transactional API revolves around a <a href="https://ravendb.net/docs/article-page/6.0/csharp/client-api/session/what-is-a-session-and-how-does-it-work">session</a> handle, which “represents a single business transaction on a particular database.” Users create a session, perform operations like reads and writes, and finally call <code>session.saveChanges()</code> to commit their writes as an atomic unit.</p>
<p>RavenDB can <a href="https://ravendb.net/why-ravendb/high-availability">replicate data across a set of nodes with automated failover</a>. Sharding is either a <a href="https://issues.hibernatingrhinos.com/issue/RavenDB-8115">work in progress</a> or <a href="https://ravendb.net/features/clusters/sharding">ready in 6.0</a>, depending on which part of the documentation you’re reading. RavenDB includes secondary indices wrapped with a homegrown <a href="https://ravendb.net/docs/article-page/6.0/csharp/client-api/session/querying/how-to-query">query language</a>, <a href="https://ravendb.net/docs/article-page/6.0/csharp/document-extensions/revisions/overview">multiple revisions of documents</a>, <a href="https://ravendb.net/docs/article-page/6.0/csharp/document-extensions/timeseries/overview">time series</a> datatypes, and <a href="https://crdt.tech/">CRDT</a>-based <a href="https://ravendb.net/why-ravendb/multi-model">counters</a>. In this text, we’ll focus on RavenDB’s transactional key-value operations.</p>
<h2 data-number="1.1" id="replication"> Replication</h2>
<p>Per RavenDB’s <a href="https://ravendb.net/why-ravendb/high-availability">High Availability</a> page, the database accepts writes and reads across all nodes in the cluster. It uses the <a href="https://raft.github.io/">Raft</a> consensus algorithm, which should theoretically allow RavenDB to provide consistency models up to <a href="https://jepsen.io/consistency/models/strict-serializable">Strong Serializability</a>. However, that page goes on to say operators can “easily setup a topology in which end points operate … independently in case the network is disrupted.” In a blog post, CEO Oren Eini repeats this claim:</p>
<blockquote>
<p>If a node is located in a place where the internet connectivity goes down, that node can continue to operate offline, taking in data locally. Once the connection is restored, the node will take the data it processed and replicate it throughout your cluster.</p>
</blockquote>
<p>This would make ACID transactions impossible. The “I” in ACID refers to “Isolation”: transactions must appear to execute independently, without interference from other transactions. This property is formalized as <a href="https://jepsen.io/consistency/models/serializable">Serializability</a>: equivalence to some totally ordered, non-concurrent execution of transactions. We know that totally available systems <a href="https://jepsen.io/consistency">cannot offer</a> Serializability or even <a href="https://jepsen.io/consistency/models/snapshot-isolation">Snapshot Isolation</a>. RavenDB might offer <a href="https://jepsen.io/consistency/models/causal">Causal</a> or <a href="https://jepsen.io/consistency/models/read-committed">Read Committed</a>, but the stronger consistency models are theoretically off-limits.</p>
<p>A <a href="https://ravendb.net/features/clusters/high-availability">second page on high availability</a> explains that there are two layers within RavenDB, and that Raft is used only for cluster metadata:</p>
<blockquote>
<ul>
<li><p>First, the cluster layer is managed by a consensus protocol called Raft. In CAP theorem it is CP (consistent and partition tolerant).</p></li>
<li><p>The second layer, the database layer, is AP (it is always available, even if there is a partition, and it’s eventually consistent) and is handled by a gossip protocol between the databases on different nodes, forming multi-master mesh and replicating data between each other.</p></li>
</ul>
<p>RavenDB utilizes the different layers for different purposes. At the cluster layer, the consensus protocol ensures that operators have the peace of mind of knowing that their commands are accepted and followed. At the database layer you know that RavenDB will never lose writes and will always keep your data safe.</p>
</blockquote>
<p>This is also confusing. AP systems are known for availability, not safety; lost update is a well-understood problem in AP registers. RavenDB claims to offer transactions with ACID guarantees. However, these transactions are apparently routed through an eventually-consistent, totally available replication system. There are <a href="https://docs.datomic.com/pro/getting-started/brief-overview.html">databases which couple</a> an (e.g.) Sequential transaction coordinator to an eventually-consistent datastore to provide Serializability, but it’s not clear from this documentation how RavenDB links cluster and database layers together to ensure safety.</p>
<p>The <a href="https://ravendb.net/learn/inside-ravendb-book/reader/4.0/6-ravendb-clusters">Inside RavenDB chapter on cluster design</a> confirms that Raft is used only for cluster metadata. Writes are allowed on every node, and are totally available:</p>
<blockquote>
<p>RavenDB uses multi-master replication inside a database, and it’s always able to accept writes.</p>
<p>In other words, even if the majority of the cluster is down, as long as a single node is available, we can still process reads and writes.</p>
</blockquote>
<p>On the other hand, RavenDB’s <a href="https://ravendb.net/articles/acid-transactions-in-nosql-ravendb-vs-mongodb">ACID Transactions in NoSQL</a> post claims the opposite:</p>
<blockquote>
<p>As in the single node version, RavenDB commits a transaction with just one round of Raft consensus.</p>
</blockquote>
<p>If Raft <em>is</em> involved in the transactions, RavenDB can offer up to Strong Serializability—but transactions cannot be totally available. Indeed, RavenDB’s <a href="https://ravendb.net/docs/article-page/6.0/Csharp/server/clustering/cluster-transactions">clustering documentation</a> clarifies there are actually two separate transaction paths. The default mode is called a <em>single-node</em> transaction, which allows conflicts “when two clients try to modify the same set of documents on two different database nodes.” A <em>cluster-wide transaction</em> uses Raft to prevent conflicts, allowing transactions to “favor consistency over availability.” To execute a cluster-wide transaction, one <a href="https://ravendb.net/docs/article-page/6.0/java/client-api/session/saving-changes#transaction-mode---cluster-wide">must set</a> <code>TransactionMode = CLUSTER_WIDE</code>.</p>
<p>What safety properties do these transaction paths guarantee? For this, we need to consider RavenDB’s ACID claims in detail.</p>
<h2 data-number="1.2" id="acid"> ACID</h2>
<p>RavenDB’s <a href="https://ravendb.net/why-ravendb">home page</a> prominently advertises “ACID database transactions” “across multiple documents and across your entire cluster.” Its <a href="https://ravendb.net/why-ravendb/acid-transactions">ACID Database Transactions</a> page explains that a database without transactions is “not much of a database.” It boasts that RavenDB “guarantee[s] ACID without sacrificing performance” and notes that because of its distributed ACID guarantees, “developers are exempt from handling the numerous scenarios of partial data transfers and the intricacies of data storage.”</p>
<p>RavenDB’s <a href="https://ravendb.net/articles/acid-transactions-in-nosql-ravendb-vs-mongodb">ACID Transactions in NoSQL</a> article explains that RavenDB “was capable of multi-document transactions since version 1.0”:</p>
<blockquote>
<p>Because it was optimized with this in mind, there wasn’t even a need for a non-ACID option. Any combination of database operations can be combined into an ACID transaction. As a user you never needed to implement ACID guarantees yourself, and you were free to design documents around your own requirements….</p>
<p>RavenDB was designed to make one and only one round trip to the server per transaction. RavenDB’s version of the session object tracks a series of commands, collects them as a batch, and sends them all to the server in a single round-trip when the method <code>session.saveChanges()</code> is called.</p>
</blockquote>
<p>Again, <a href="https://ravendb.net/articles/acid-cluster-distributed-nonrelational-database">RavenDB claims</a> to have been “the pioneer database to offer ACID in a nonrelational context. In 2010, RavenDB offered ACID consistency across multiple documents.” However, these guarantees held only on a single node: concurrent clients on different nodes could violate isolation. RavenDB 4.0, released in fall 2020, introduced the cluster-wide transaction path, which took transactions “from being ACID over multiple documents to being ACID over your entire cluster.”</p>
<p>The <a href="https://ravendb.net/docs/article-page/6.0/csharp/client-api/faq/transaction-support">Transaction FAQ</a> says “all actions performed on documents are fully ACID” but contradicts itself immediately, saying “in a single transaction, all operations operate under snapshot isolation.” <a href="https://dbdb.io/db/ravendb">DBDB</a> takes this to mean that RavenDB offers Snapshot Isolation by default.<a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a> In a <a href="https://www.youtube.com/watch?v=5ZXBR3croMA&amp;t=39m">2020 webinar</a>, CEO Oren Eini confirmed this position: “RavenDB uses Snapshot Isolation by default, and transactions are effectively going to observe Serializable between operations that happen on the same node.”</p>
<p>There are hints that RavenDB might provide something much weaker than Snapshot Isolation. Buried in the <em>Inside RavenDB</em> book, in the chapter on document modeling, is a <a href="https://ravendb.net/learn/inside-ravendb-book/reader/4.0/3-document-modeling#concurrency-control">section on concurrency control</a>. This section explains that RavenDB (at least in version 4.0) performed no concurrency control, and instead used Last Write Wins conflict resolution by default.</p>
<blockquote>
<p>What happens if two requests are trying to modify the same document at the same time? That depends on what, exactly, you asked RavenDB to do. If you didn’t do anything, RavenDB will execute those two modifications one at a time, and the last one will win. There’s no way to control which would be last. Note that both operations will execute.</p>
</blockquote>
<p>This is the <em>opposite</em> of ACID isolation. Isolated transactions appear to execute sequentially, not concurrently. It also contradicts claims of Snapshot Isolation: Last Write Wins registers allow all kinds of anomalies which would be prohibited under Snapshot Isolation, including <a href="https://dzone.com/articles/conflict-resolution-using-last-write-wins-vs-crdts">lost update</a>. However, this book is two major releases out of date; it may not apply to 6.0.2.</p>
<p>What about cluster-wide transactions? The <a href="https://ravendb.net/docs/article-page/6.0/java/server/clustering/cluster-transactions#concurrent-cluster-wide-and-single-node-transactions">Cluster Transactions</a> page seems definitive. “Concurrent cluster-wide transactions are guaranteed to appear as if they are run one at a time (<code>serializable</code> isolation level).”<a href="#fn3" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<p>From this, Jepsen infers that RavenDB’s default transaction settings should ensure Snapshot Isolation by default and Serializability in a single-node system. Cluster-wide transactions should ensure Serializability globally.</p>

<p>In 2020 RavenDB <a href="https://github.com/ml054/jepsen/">wrote their own Jepsen test</a> and declared in <a href="https://www.youtube.com/watch?v=5ZXBR3croMA&amp;">a webinar</a> that per that test, “everything works.” Their test checked the linearizability of individual <a href="https://github.com/ml054/jepsen/blob/08960da98ab9bf7959fce014c63b146b903cbe6c/ravendb/src/jepsen/ravendb.clj#L164-L196">reads and writes</a> against a single document. It did not evaluate multi-operation or multi-document transactions.<a href="#fn4" id="fnref4" role="doc-noteref"><sup>4</sup></a></p>
<p>We designed a <a href="https://github.com/jepsen-io/ravendb/tree/4431310402f334ffdb18a5a7ec819316847b642b">new test harness</a> for RavenDB 6.0.2 running on a single Debian Bookworm node. Our test used RavenDB’s JVM client library at version 5.0.4. We did not evaluate multi-node clusters or any kind of faults.</p>
<p>We wrote a single list-append workload using <a href="https://github.com/jepsen-io/elle">Elle</a> to verify transactional isolation. This workload performs transactions over lists, each list identified by a unique integer ID. Each transaction consists of reads and/or appends of unique integers to those lists. Each worker thread in the test <a href="https://github.com/jepsen-io/ravendb/blob/8315d6053bf022203a24db74812d2fdfe89b56b7/src/jepsen/ravendb/client.clj#L26-L31C15">opens a single DocumentStore</a> connected to the same node. Each transaction creates a new <a href="https://github.com/jepsen-io/ravendb/blob/8315d6053bf022203a24db74812d2fdfe89b56b7/src/jepsen/ravendb/client.clj#L54-L62">session</a>, performs <a href="https://github.com/jepsen-io/ravendb/blob/8315d6053bf022203a24db74812d2fdfe89b56b7/src/jepsen/ravendb/append.clj#L25-L41">reads and/or appends</a>, then calls <a href="https://github.com/jepsen-io/ravendb/blob/8315d6053bf022203a24db74812d2fdfe89b56b7/src/jepsen/ravendb/client.clj#L90"><code>session.saveChanges()</code></a> to commit. Reads are encoded as a <a href="https://github.com/jepsen-io/ravendb/blob/8315d6053bf022203a24db74812d2fdfe89b56b7/src/jepsen/ravendb/append.clj#L26-L28">single call</a> to <code>session.load(java.util.Map, id)</code>. Appends call <code>session.load</code> to read the current value, add their integer element to the end of the list, then call <a href="https://github.com/jepsen-io/ravendb/blob/8315d6053bf022203a24db74812d2fdfe89b56b7/src/jepsen/ravendb/append.clj#L40"><code>session.store(map, key)</code></a>.</p>
<p>RavenDB offers a few knobs for tuning transaction safety: <code>transactionMode</code> and <code>optimisticConcurrency</code>. We ran our tests using the defaults (single-node transactions, no optimistic concurrency), with single-node transactions and optimistic concurrency, and finally with cluster-wide transactions. Cluster-wide transactions cannot be combined with optimistic concurrency.</p>

<p>We found surprising safety errors in all three transaction modes.</p>
<h2 data-number="3.1" id="lost-update-with-single-node-transactions-17927"> Lost Update with Single-Node Transactions (#17927)</h2>
<p>By default, RavenDB executes transactions with <code>transactionMode = SINGLE_NODE</code> and <code>optimisticConcurrency = false</code>. One might assume that <code>SINGLE_NODE</code> transactions are safe on single-node clusters. However, we found the default settings caused RavenDB to lose updates constantly, even in single-node clusters without faults.</p>
<p>For instance, in this <a href="https://github.com/ravendb/ravendb/files/13794868/20231229T102201.960-0600.zip">five-second test run</a> we performed 12,886 transactions over 975 keys. 81 of those keys exhibited a provable lost update. Here are two committed transactions involving key 830:</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>[[<span>:r</span> <span>830</span> [<span>1</span> <span>2</span>]]</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a> [<span>:append</span> <span>824</span> <span>11</span>]</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a> [<span>:append</span> <span>807</span> <span>14</span>]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a> [<span>:append</span> <span>830</span> <span>3</span>]]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>[[<span>:r</span> <span>830</span> [<span>1</span> <span>2</span>]]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a> [<span>:r</span> <span>831</span> <span>nil</span>]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a> [<span>:r</span> <span>831</span> <span>nil</span>]</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a> [<span>:append</span> <span>830</span> <span>4</span>]]}]}</span></code></pre></div>
<p>Both of these transactions read key 830’s value as the list <code>[1, 2]</code>. Both went on to append a value to key 830: the first transaction appended <code>3</code>, and the second transaction appended <code>4</code>. Neither saw the other’s effects. In a Snapshot Isolated system, the <em>first-committer-wins</em> rule demands that one of these transactions must abort. RavenDB, however, allowed both transactions to commit. This is the definition of a lost update anomaly.</p>
<p>In an isolated transaction system which only ever appends elements to lists, every observed version of a single list must be a prefix of the longest version of that list. However, 454 of the keys in this test violated this prefix property, exhibiting <em>incompatible orders</em>. For example, here are all the reads of key 116:</p>
<table>
<thead>
<tr>
<th>Time (s)</th>
<th>Process</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>3.01</td>
<td>1</td>
<td>[1 2]</td>
</tr>
<tr>
<td>3.01</td>
<td>1</td>
<td>[1 2]</td>
</tr>
<tr>
<td>3.01</td>
<td>0</td>
<td>[1 2]</td>
</tr>
<tr>
<td>3.01</td>
<td>1</td>
<td>[1 2 3]</td>
</tr>
<tr>
<td>3.01</td>
<td>0</td>
<td>[1 2 4]</td>
</tr>
<tr>
<td>3.01</td>
<td>1</td>
<td>[1 2 4 5]</td>
</tr>
<tr>
<td>3.01</td>
<td>0</td>
<td>[1 2 4]</td>
</tr>
<tr>
<td>3.02</td>
<td>1</td>
<td>[1 2 4 6]</td>
</tr>
<tr>
<td>3.02</td>
<td>1</td>
<td>[1 2 4 6]</td>
</tr>
<tr>
<td>3.02</td>
<td>1</td>
<td>[1 2 4 6 9]</td>
</tr>
<tr>
<td>3.02</td>
<td>1</td>
<td>[1 2 4 6 9 10]</td>
</tr>
<tr>
<td>3.02</td>
<td>1</td>
<td>[1 2 4 6 9 10 11 15]</td>
</tr>
<tr>
<td>3.02</td>
<td>0</td>
<td>[1 2 4 6 9 10 11 15]</td>
</tr>
</tbody>
</table>
<p>Just over three seconds into the test, process 1 observed key 116’s state as <code>[1 2 3]</code>. However, an immediately following read by process 0 saw <code>[1 2 4]</code>, and the write of <code>3</code> never appeared again. Process 1 then observed <code>[1 2 4 5]</code>. This write of <code>5</code> was replaced by <code>6</code> and never seen again.</p>
<p>Our lost update checker is conservative: it only infers an anomaly if two transactions read the same version of some key <em>and</em> both write to it. However, our <code>append</code> operations are performed by reading the value, then writing back changes. This means these transactions contain reads which are effectively invisible to the checker. It seems likely that these cases of incompatible order also represent lost updates.</p>
<p>In total, 481 out of the 975 keys in this test exhibited lost updates or incompatible orders. These phenomena are prohibited by Serializability, Snapshot Isolation, and Repeatable Read. We’ve reported this as <a href="https://github.com/ravendb/ravendb/issues/17927">issue 17927</a> in RavenDB’s issue tracker.</p>
<h2 data-number="3.2" id="fractured-reads-with-optimistic-concurrency-17929"> Fractured Reads with Optimistic Concurrency (#17929)</h2>
<p>With the <em><a href="https://ravendb.net/docs/article-page/6.0/csharp/client-api/session/configuration/how-to-enable-optimistic-concurrency">optimistic concurrency</a></em> feature enabled, RavenDB promises to “generate a concurrency exception (and abort all modifications in the current transaction) when the document has been modified on the server side after the client received and modified it.” When running on a single node, this setting does appear to prevent lost updates. However, it allows fractured reads—as well as various flavors of G-Single, G-nonadjacent, and G2-item. Again, these anomalies occurred in a healthy single-node system.</p>
<p>For instance, consider this <a href="https://s3.amazonaws.com/jepsen.io/analyses/ravendb-6.0.2/20231229T140050.249-0600.zip">ten-second test run</a> in which every transaction enabled optimistic concurrency. Our checker found hundreds of anomalies like this:</p>

<p>In this diagram the top transaction <span><em>T</em><sub>1</sub></span> appended <code>3</code> to key 271, then appended <code>2</code> to key 279. The bottom transaction <span><em>T</em><sub>2</sub></span> read key 271 and found nothing, appended 6 to key 276, and finally read key 279’s value as <code>[2]</code>. Because <span><em>T</em><sub>2</sub></span> failed to observe <span><em>T</em><sub>1</sub></span>’s append to key 271, we have a read-write anti-dependency, denoted <code>rw</code>. Because <span><em>T</em><sub>2</sub></span> observed <span><em>T</em><sub>1</sub></span>’s append to key 279, we have a write-read dependency, denoted <code>wr</code>. In short, <span><em>T</em><sub>2</sub></span> observed some, but not all, of the effects of <span><em>T</em><sub>1</sub></span>.</p>
<p>This anomaly is called <em>fractured read</em>, and it is prohibited under Read Atomic, Update Atomic, Causal, Prefix, Parallel Snapshot Isolation, Snapshot Isolation, Repeatable Read, and Serializable. RavenDB’s <a href="https://ravendb.net/docs/article-page/6.0/csharp/client-api/faq/transaction-support">Transaction FAQ</a> promises Snapshot Isolation: “even if you access multiple documents, you’ll get all of their state as it was in the beginning of the request.” In all Snapshot Isolated databases Jepsen is familiar with, snapshots extend across multiple reads. In RavenDB, it appears each read can observe a different state. We’ve reported this as <a href="https://github.com/ravendb/ravendb/issues/17929">issue #17929</a> to RavenDB.</p>
<h2 data-number="3.3" id="fractured-read-with-cluster-wide-transactions-17928"> Fractured Read with Cluster-Wide Transactions (#17928)</h2>
<p>Cluster-wide transactions are <a href="https://ravendb.net/docs/article-page/6.0/csharp/server/clustering/cluster-transactions">supposed to be Serializable</a>. However, we found that even healthy, single-node clusters in which every transaction used <code>CLUSTER_WIDE</code> mode routinely exhibited fractured reads, as well as G-single, G-nonadjacent, G2-item, and more. Consider this <a href="https://s3.amazonaws.com/jepsen.io/analyses/ravendb-6.0.2/20231229T145350.284-0600.zip">five second test run</a>, which contained hundreds of serializability violations. Here is one of those anomalies:</p>

<p>Here, the bottom transaction <span><em>T</em><sub>2</sub></span> appended <code>6</code> to key 146 and <code>1</code> to key 149. The top transaction <span><em>T</em><sub>1</sub></span> failed to observe <span><em>T</em><sub>2</sub></span>’s append to key 149, but <em>did</em> observe its append to key 146. This is another instance of fractured read. As before, this behavior appears to be proscribed by RavenDB’s documentation, as well as all consistency models above Read Atomic.</p>
<p>We’ve reported this to RavenDB as <a href="https://github.com/ravendb/ravendb/issues/17928">issue #17928</a>.</p>
<table>
<thead>
<tr>
<th>№</th>
<th>Summary</th>
<th>Event Required</th>
<th>Fixed in</th>
</tr>
</thead>
<tbody>
<tr>
<td>17927</td>
<td>Lost update with single-node transactions</td>
<td>None</td>
<td>Unresolved</td>
</tr>
<tr>
<td>17929</td>
<td>Fractured read with optimistic concurrency</td>
<td>None</td>
<td>Unresolved</td>
</tr>
<tr>
<td>17928</td>
<td>Fractured read with cluster-wide transactions</td>
<td>None</td>
<td>Unresolved</td>
</tr>
</tbody>
</table>

<p>RavenDB variously claims to offer “fully ACID” transactions, Serializability, or at least Snapshot Isolation. All of these claims appear false. RavenDB 6.0.2’s default settings allowed lost updates. Even cluster-wide transactions exhibited fractured reads: a serious anomaly prohibited under Snapshot Isolation, as well as several weaker models. These behaviors occur even in healthy, single-node, single-shard systems, in which all access occurs via primary key.</p>
<p>RavenDB’s strongest safety settings violate Read Atomic. It therefore cannot satisfy Update Atomic, Causal, Prefix, Parallel Snapshot Isolation, Snapshot Isolation, Repeatable Read, or Serializable. RavenDB might offer Read Committed or Monotonic Atomic View, but without more rigorous testing, Jepsen is hesitant to make this claim.</p>
<p>RavenDB’s weak default behavior is surprising given RavenDB’s repeated emphasis on safety. As CEO Oren Eini <a href="https://www.youtube.com/watch?v=5ZXBR3croMA&amp;t=850s">remarked</a> on MongoDB’s transaction safety settings:</p>
<blockquote>
<p>[Default] values matter. They matter quite a lot. Why is that? Because if you choose the bad values, you’re absolutely going to get some great numbers in benchmark performance. But then you are going to be hitting those [safety] issues in production. And then there is this classic response: “Oh, you should have read the docs and used the proper configuration.”</p>
</blockquote>
<p>One wonders: if ACID properties are so important for RavenDB’s users, why do the default settings allow lost updates, even on single-key operations? Do users realize their updates can be silently discarded? How many are taking care to use cluster-wide transactions where lost updates would violate safety? Do they know that even cluster-wide transactions allow fractured read?</p>
<p>This report follows a cursory investigation into RavenDB’s behavior—it is by no means exhaustive. As always, we caution that Jepsen takes an experimental approach to safety verification: we can prove the presence of bugs, but not their absence. There may be other anomalies in RavenDB.</p>
<h2 data-number="4.1" id="does-ravendb-even-have-transactions"> Does RavenDB Even Have Transactions?</h2>
<p>The first sentence of RavenDB’s <a href="https://ravendb.net/docs/article-page/6.0/csharp/client-api/session/cluster-transaction/overview">cluster transaction documentation</a> appears quite clear:</p>
<blockquote>
<p>A session represents a single business transaction.</p>
</blockquote>
<p>This is echoed by the first sentence of RavenDB’s <a href="https://ravendb.net/docs/article-page/6.0/csharp/client-api/session/what-is-a-session-and-how-does-it-work">session documentation</a>:</p>
<blockquote>
<p>The Session, which is obtained from the Document Store, is a Unit of Work that represents a single business transaction on a particular database.</p>
</blockquote>
<p>… which goes on to say:</p>
<blockquote>
<p>The batched operations that are sent in the <code>SaveChanges()</code> will complete transactionally. In other words, either all changes are saved as a Single Atomic Transaction or none of them are. So once SaveChanges returns successfully, it is guaranteed that all changes are persisted to the database.</p>
</blockquote>
<p>RavenDB sessions are clearly not intended to work like sessions in typical databases, which are (roughly speaking) <a href="https://www.postgresql.org/docs/current/tutorial-arch.html">one-to-one with client connections</a>.<a href="#fn5" id="fnref5" role="doc-noteref"><sup>5</sup></a> They come with a default limit of <a href="https://ravendb.net/docs/article-page/5.4/java/client-api/session/what-is-a-session-and-how-does-it-work#remarks">30 network requests</a>; typical database sessions are unbounded. They buffer writes; Jepsen is unaware of any other database whose sessions do this. They cache reads; most sessions do not. They include concurrency control mechanisms like lost update prevention; Jepsen is unaware of any other database which does this at the session level. These are all hallmarks of what most databases would call a transaction.</p>
<p>RavenDB’s article <a href="https://ravendb.net/articles/acid-transactions-in-nosql-ravendb-vs-mongodb">ACID Transactions in NoSQL? RavenDB vs MongoDB</a> is emphatic: RavenDB has supported ACID transactions over “any combination of database operations” for over a decade. It certainly appears as if RavenDB sessions are intended for this role!</p>
<p>However, in a <a href="https://github.com/ravendb/ravendb/issues/17927#issuecomment-1872912239">response to issue 17927</a>, Eini (a.k.a. Ayende Rahien) explained that sessions are <em>not</em> in fact transactions:<a href="#fn6" id="fnref6" role="doc-noteref"><sup>6</sup></a></p>
<blockquote>
<p>Crucially, RavenDB does not attempt to provide transactional semantics over the entire session, rather it provide[s] transactions over individual requests.</p>
</blockquote>
<p>And in <a href="https://github.com/ravendb/ravendb/issues/17928#issuecomment-1872916841">response to issue #17928</a>, Eini affirms:</p>
<blockquote>
<p>A transaction in RavenDB is a request - so TX1 and TX2 above aren’t actually single transactions, instead, each of them represent 3 independent transactions.</p>
</blockquote>
<p>This is a striking viewpoint: the point of transactions is generally to provide isolation across multiple requests.<a href="#fn7" id="fnref7" role="doc-noteref"><sup>7</sup></a> Moreover, RavenDB’s optimistic concurrency and cluster-wide transaction mechanisms are clearly intended to provide transactional isolation which spans from a session’s reads to its writes. Furthermore, Eini <a href="https://www.youtube.com/watch?v=5ZXBR3croMA&amp;t=23m40s">directly compared RavenDB sessions to MongoDB transactions</a> (which offer typical interactive transaction semantics) and claimed that unlike MongoDB, RavenDB sessions actually satisfied Snapshot Isolation. Yet per Eini’s comments, RavenDB <em>does not have interactive transactions at all</em>.</p>
<p>Repeatedly advertising “ACID transactions” across “any combination of database operations,” telling users that a “session represents a single business transaction,” comparing RavenDB sessions to interactive transactions in other databases, offering concurrency control mechanisms whose scope extends across an entire session, and finally expecting users to realize that sessions are not transactions at all—that a transaction is actually limited to a single HTTP request—stretches credulity.</p>
<p>Jepsen strives to evaluate databases in the context of their marketing and documentation. Although RavenDB’s CEO <a href="https://github.com/ravendb/ravendb/issues/17928#issuecomment-1874064897">now states</a> “we don’t support a transaction over more than a single HTTP request,” RavenDB’s documentation and marketing give every appearance that a session is intended to be a transaction. Jepsen has consulted with several software engineers on their interpretation of these claims, and believes typical database users would come to the same conclusion: RavenDB sessions are transactions. We continue this interpretation throughout this report.</p>
<h2 data-number="4.2" id="recommendations"> Recommendations</h2>
<p>RavenDB users should be aware RavenDB transactions are not ACID in any meaningful sense.<a href="#fn8" id="fnref8" role="doc-noteref"><sup>8</sup></a> This holds even in single-node, single-shard deployments. The defaults allow lost updates: you should expect some of your writes to be silently discarded. The strongest safety settings allow fractured read: you might observe some, but not all, of another transaction’s effects. You could appear to write “into the middle” of another transaction. The two isolation levels RavenDB advertises—Snapshot Isolation and Serializable—appear impossible to obtain.</p>
<p>Users who designed their applications assuming RavenDB provided interactive ACID transactions—or even Snapshot Isolation—should carefully reevaluate their transactions to ensure they are safe in the presence of these anomalies. Consider writing simple tests to verify application invariants are preserved under concurrent execution: the issues in this report are easy to reproduce.</p>
<p>Jepsen recommends RavenDB remove claims of “ACID”, “Serializable”, and “Snapshot Isolation” from their marketing materials and documentation. RavenDB should instead make specific, accurate, and internally consistent claims about safety properties. For instance, RavenDB might say “transactions offer Read Committed by default, plus internal consistency within the scope of a transaction: once a transaction reads a key, subsequent reads and writes of that key observe the originally read state, plus the effects of that particular transaction’s writes. Transactions allow lost update by default. Enabling cluster-wide transactions prevents lost update, but still allows fractured read,” and so on.</p>
<p>RavenDB’s documentation is remarkably confusing. It repeatedly claims to offer <a href="https://ravendb.net/why-ravendb/acid-transactions">ACID transactions</a>, which implies Serializability. There are specific claims that RavenDB ensures either <a href="https://ravendb.net/docs/article-page/6.0/csharp/server/clustering/cluster-transactions#case-1-multiple-concurrent-cluster-transactions">Serializability</a> or <a href="https://www.youtube.com/watch?v=5ZXBR3croMA">Snapshot Isolation</a>. However, the documentation also says that RavenDB’s database layer is an <a href="https://ravendb.net/learn/inside-ravendb-book/reader/4.0/6-ravendb-clusters">AP system</a> based on Last Write Wins, and the marketing material claims isolated nodes can operate <a href="https://ravendb.net/why-ravendb/high-availability">independently</a>. This is impossible: totally available systems <a href="https://jepsen.io/consistency">cannot provide</a> Serializability or Snapshot Isolation.<a href="#fn9" id="fnref9" role="doc-noteref"><sup>9</sup></a></p>
<p>There are systems (like <a href="https://riak.com/index.html">Riak</a> &amp; <a href="https://cassandra.apache.org/_/index.html">Cassandra</a>) which allow clients to execute either totally available operations with weak consistency, or majority available operations with stronger guarantees, like Linearizability. If RavenDB intends to build a system which supports both modes, they should clearly distinguish those modes throughout marketing and documentation. They have completely different availability, latency, and safety characteristics. Repeated claims that RavenDB provides ACID “<a href="https://ravendb.net/why-ravendb/acid-transactions">without sacrificing performance</a>” are <a href="https://lamport.azurewebsites.net/pubs/lower-bound.pdf">provably impossible</a>, and should be rewritten to clearly explain the tradeoffs involved.</p>
<p>ACID transactions are clearly important to RavenDB. It is therefore alarming that RavenDB’s documentation and GitHub comments fundamentally disagree on what a transaction <em>is</em>. In one interpretation, RavenDB offers interactive transactions, represented by the session API, which provide relatively weak isolation—certainly not ACID. In another interpretation, RavenDB lacks interactive transactions altogether. Instead, it offers a sort of micro-transaction which (e.g.) writes multiple documents in a single network request. In this world, sessions offer varying, weak consistency constraints that extend <em>between</em> micro-transactions.</p>
<p>To resolve this confusion, RavenDB should pick a single definition of “transaction” and stick with it. The equivalence or difference between a transaction and session should be clearly explained, and these terms used consistently throughout marketing and documentation. RavenDB should provide guidance as to the boundaries of each unit: when are multiple calls to <code>load</code> performed in a single transaction? What about <code>store</code>? Can a single transaction encompass both a <code>load</code> and <code>store</code>? The consistency properties of both transactions and sessions should be clearly and formally defined. Are transactions Serializable? Do sessions ensure Monotonic Atomic View? When does a session preclude lost update, and when does it allow it? Above all, do not <a href="https://ravendb.net/docs/article-page/6.0/csharp/client-api/session/cluster-transaction/overview">tell</a> <a href="https://ravendb.net/docs/article-page/6.0/csharp/client-api/session/what-is-a-session-and-how-does-it-work">users</a> that sessions “represent a single business transaction” if they are, in point of fact, not transactions at all.</p>
<p>Finally, if RavenDB transactions are truly intended to cover only a single network request, consider using a different term altogether, and avoid comparisons to databases which do have interactive transactions. Some databases call these “mini-” or “micro-transactions,” which provides an obvious hint of their limited scope.</p>
<h2 data-number="4.3" id="future-work"> Future Work</h2>
<p>This work evaluated only single-node RavenDB clusters without faults. Future research could expand tests across multiple nodes, as well as introducing network, process, and disk faults. We dealt only with key-value operations, and did not evaluate RavenDB’s secondary indices. These indices are described as eventually consistent, which raises questions around the integrity of predicate reads. RavenDB also offers <a href="https://ravendb.net/docs/article-page/6.0/csharp/client-api/operations/patching/single-document">server-side transactions</a> using Javascript or a library of built-in patch operations. These might offer different safety characteristics than the interactive transactions we used in this report. Finally, cross-shard transactions are a notoriously challenging problem and deserve careful testing.</p>
<p><em>Jepsen wishes to thank <a href="https://www.irenekannyo.com/">Irene Kannyo</a> for her invaluable editorial support. Thanks as well to C. Scott Andreas, Taber Bain, Silvia Botros, Coda Hale, Ben Linsay, Kelly Shortridge, Nathan Taylor, Zach Tellman, and Leif Walsh for their comments on early versions of this manuscript. This work was performed independently without compensation, in accordance with the <a href="https://jepsen.io/ethics">Jepsen ethics policy</a>.</em></p>

  </div>
</article></div>
  </body>
</html>
