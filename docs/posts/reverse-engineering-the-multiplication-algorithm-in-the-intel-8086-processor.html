<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.righto.com/2023/03/8086-multiplication-microcode.html">Original</a>
    <h1>Reverse-engineering the multiplication algorithm in the Intel 8086 processor</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-8390323699966089555" itemprop="description articleBody">



<p>While programmers today take multiplication for granted, most microprocessors in the 1970s could only add and subtract — multiplication required a slow and tedious loop implemented in assembly code.<span id="fnref:mul"><a href="#fn:mul">1</a></span>
One of the nice features of the Intel 8086 processor (1978) was
that it provided machine instructions for multiplication,<span id="fnref:division"><a href="#fn:division">2</a></span> able to multiply 8-bit or 16-bit numbers with a single instruction.
Internally, the 8086 still performed a loop, but the loop was implemented in microcode: faster and transparent to
the programmer.
Even so, multiplication was a slow operation, about 24 to 30 times slower than addition.</p>
<p>In this blog post, I explain the multiplication process inside the 8086, analyze the microcode that it used, and discuss the hardware
circuitry that helped it out.<span id="fnref:microcode"><a href="#fn:microcode">3</a></span>
My analysis is based on reverse-engineering the 8086 from die photos. The die photo below shows the chip under a microscope.
I&#39;ve labeled the key functional blocks; the ones that are important to this post are darker.
At the left, the ALU (Arithmetic/Logic Unit) performs the arithmetic operations at the heart of multiplication: addition and shifts.
Multiplication also uses a few other hardware features: the X register, the F1 flag, and a loop counter.
The microcode ROM at the lower right controls the process.</p>
<p><a href="https://static.righto.com/images/8086-mul/die-labeled.jpg"><img alt="The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip with the metal and polysilicon removed, revealing the silicon underneath. Click on this image (or any other) for a larger version." height="592" src="https://static.righto.com/images/8086-mul/die-labeled-w600.jpg" title="The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip with the metal and polysilicon removed, revealing the silicon underneath. Click on this image (or any other) for a larger version." width="600"/></a></p><p>The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip with the metal and polysilicon removed, revealing the silicon underneath. Click on this image (or any other) for a larger version.</p>
<h2>Microcode</h2>
<p>The multiplication routines in the 8086 are implemented in microcode.
Most people think of machine instructions as the basic steps that a computer performs.
However, many processors (including the 8086) have another layer of software underneath: microcode.
With microcode, instead of building the control circuitry from complex logic gates, the control logic is largely replaced with code.
To execute a machine instruction, the computer internally executes several simpler micro-instructions, specified by the microcode.
This is especially useful for a machine instruction such as multiplication, which requires many steps in a loop.</p>
<!--
The 8086 uses a hybrid approach: although it uses microcode, much of the instruction functionality is implemented with gate logic.
This approach removed duplication from the microcode and kept the microcode small enough for 1978 technology.
In a sense, the microcode is parameterized.
For instance, the microcode can specify a generic Arithmetic/Logic Unit (ALU) operation and a generic register.
The gate logic examines the instruction to determine which specific operation to perform and the appropriate register.
-->

<p>A micro-instruction in the 8086 is encoded into 21 bits as shown below.
Every micro-instruction has a move from a source register to a destination register, each specified with 5 bits.
The meaning of the remaining bits depends on the type field and can be anything from an ALU operation to a memory read or write to
a change of microcode control flow.
Thus, an 8086 micro-instruction typically does two things in parallel: the move and the action.
For more about 8086 microcode, see my <a href="https://www.righto.com/2022/11/how-8086-processors-microcode-engine.html">microcode blog post</a>.</p>
<p><a href="https://static.righto.com/images/8086-mul/microcode-format.jpg"><img alt="The encoding of a micro-instruction into 21 bits. Based on NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?" height="203" src="https://static.righto.com/images/8086-mul/microcode-format-w700.jpg" title="The encoding of a micro-instruction into 21 bits. Based on NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?" width="700"/></a></p>
<p>The behavior of an ALU micro-operation is important for multiplication.
The ALU has three temporary registers that are invisible to the programmer: tmpA, tmpB, and tmpC.
An ALU operation takes its first argument from any temporary register, while the second argument always comes from tmpB.
An ALU operation requires two micro-instructions.
The first micro-instruction specifies the ALU operation and source register, configuring the ALU. For instance, <code>ADD tmpA</code> to add tmpA to the default tmpB.
In the next micro-instruction (or a later one), the ALU result can be accessed through the <code>Σ</code> register and moved to another register.</p>
<p>Before I get into the microcode routines, I should explain two ALU operations that play a central role in multiplication: <code>LRCY</code> and <code>RRCY</code>, Left Rotate through Carry and Right Rotate through Carry.
(These correspond to the <code>RCL</code> and <code>RCR</code> machine instructions, which rotate through carry left or right.)
These operations shift the bits in a 16-bit word, similar to the <code>&lt;&lt;</code> and <code>&gt;&gt;</code> bit-shift operations in high-level languages, but with an additional feature.
Instead of discarding the bit on the end, that bit is moved into the carry flag (<code>CF</code>). Meanwhile, the bit formerly in the carry flag moves into the word.
You can think of this as rotating the bits while treating the carry flag as a 17th bit of the word.</p>
<p><a href="https://static.righto.com/images/8086-mul/rotates.jpg"><img alt="The left rotate through carry and right rotate through carry micro-instructions." height="172" src="https://static.righto.com/images/8086-mul/rotates-w300.jpg" title="The left rotate through carry and right rotate through carry micro-instructions." width="300"/></a></p><p>The left rotate through carry and right rotate through carry micro-instructions.</p>
<p>These shifts perform an important part of the multiplication process since shifting can be viewed as multiplying by two.
<code>LRCY</code> also provides a convenient way to move the most-significant bit to the carry flag, where it can be tested for a conditional jump.
(This is important because the top bit is used as the sign bit.)
Similarly, <code>RRCY</code> provides access to the least significant bit, very important for the multiplication process.
Another important property is that performing <code>RRCY</code> on an upper word and then <code>RRCY</code> on a lower word will perform a 32-bit shift, since
the low bit of the upper word will be moved into the high bit of the lower word via the carry bit.</p>
<h2>Binary multiplication</h2>
<p>The shift-and-add method of multiplication (below) is similar to grade-school long multiplication, except it uses binary instead of decimal.
In each row, the multiplicand is multiplied by one digit of the multiplier. (The multiplicand is the value that gets repeatedly added, and the multiplier
controls how many times it gets added.)
Successive rows are shifted left one digit.
At the bottom, the rows are added together to yield the product.
The example below shows how 6×5 is calculated in binary using long multiplication.</p>




<p>Binary long multiplication is much simpler than decimal multiplication: at each step, you&#39;re multiplying by 0 or 1.
Thus, each row is either zero or the multiplicand appropriately shifted (0110 in this case).
(Unlike decimal long multiplication, you don&#39;t need to know the multiplication table.)
This simplifies the hardware implementation, since each step either adds the multiplicand or doesn&#39;t.
In other words, each step tests a bit of the multiplier, starting with the low bit, to determine if an add should take place or not.
This bit can be obtained by shifting the multiplier one bit to the right each step.</p>
<p>Although the diagram above shows the sum at the end, a real implementation performs the addition at each step of the loop, keeping a running total.
Moreover, in the 8086, instead of shifting the multiplicand to the left during each step, the sum shifts to the right.
(The result is the same but it makes the implementation easier.)
Thus, multiplying 6×5 goes through the steps below.</p>


<p>Why would you shift the result to the right?
There&#39;s a clever reason for this.
Suppose you&#39;re multiplying two 16-bit numbers, which yields a 32-bit result. That requires four 16-bit words of storage if you use the
straightforward approach.
But if you look more closely, the first sum fits into 16 bits, and then you need one more bit at each step. Meanwhile, you&#39;re &#34;using up&#34;
one bit of the multiplier at each step.
So if you squeeze the sum and the multiplier together, you can fit them into two words.
Shifting right accomplishes this, as the diagram below illustrates for <code>0xffff</code>×<code>0xf00f</code>. The sum (blue) starts in a 16-bit register called <code>tmpA</code>
while the multiplier (green) is stored in the 16-bit <code>tmpB</code> register.
In each step, they are both shifted right, so the sum gains one bit and the multiplier loses one bit. By the end, the sum takes up all 32 bits,
split across both registers.</p>


<table>
<tbody><tr><th colspan="16">sum (tmpA)</th><th colspan="16">multiplier (tmpC)</th></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td></tr>
<tr><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td></tr>
</tbody></table>

<h2>The multiplication microcode</h2>
<p>The 8086 has four multiply instructions to handle signed and unsigned multiplication of byte and word operands.
These machine instructions are implemented in microcode.
I&#39;ll start by describing the unsigned word multiplication, which multiplies two 16-bit values and produces a 32-bit result.
The source word is provided by either a register or memory. It is multiplied by <code>AX</code>, the accumulator register.
The 32-bit result is returned in the <code>DX</code> and <code>AX</code> registers.</p>
<p>The microcode below is the main routine for word multiplication, both signed and unsigned.
Each micro-instruction specifies a register move on the left, and an action on the right.
The moves transfer words between the visible registers and the ALU&#39;s temporary registers, while the actions are mostly subroutine calls
to other micro-routines.</p>
<pre>  move        action
AX → tmpC   LRCY tmpC        <span><b>iMUL rmw:</b></span>
M → tmpB    CALL X0 PREIMUL   <span>called for signed multiplication</span>
            CALL CORX         <span>the core routine</span>
            CALL F1 NEGATE    <span>called for negative result</span>
            CALL X0 IMULCOF   <span>called for signed multiplication</span>
tmpC → AX   JMPS X0 7  
            CALL MULCOF       <span>called for unsigned multiplication</span>
tmpA → DX   RNI  
</pre>

<p>The microcode starts by moving one argument <code>AX</code> into the ALU&#39;s temporary C register and setting up the ALU to perform a Left Rotate through Carry on this register, in order to access the sign bit.
Next, it moves the second argument <code>M</code> into the temporary B register; <code>M</code> references the register or memory specified in the second byte
of the instruction, the &#34;ModR/M&#34; byte.
For a signed multiply instruction, the <code>PREIMUL</code> micro-subroutine is called, but I&#39;ll skip that for now.
(The <code>X0</code> condition tests bit 3 of the instruction, which in this case distinguishes <code>MUL</code> from <code>IMUL</code>.)
Next, the <code>CORX</code> subroutine is called, which is the heart of the multiplication.<span id="fnref:corx"><a href="#fn:corx">4</a></span>
If the result needs to be negated (indicated by the <code>F1</code> condition), the <code>NEGATE</code> micro-subroutine is called.
For signed multiplication, <code>IMULCOF</code> is then called to set the carry and overflow flags, while <code>MULCOF</code> is called for unsigned multiplication.
Meanwhile, the result bytes are moved from the temporary C and temporary registers to the <code>AX</code> and <code>DX</code> registers.
Finally, <code>RNI</code> runs the next machine instruction, ending the microcode routine.</p>
<h3><code>CORX</code></h3>
<p>The heart of the multiplication code is the <code>CORX</code> routine, which performs the multiplication loop, computing the product through shifts and adds.
The first two lines set up the loop, initializing the sum (tmpA) to 0.
The number of loops is controlled by a special-purpose loop counter.
The <code>MAXC</code> micro-instruction initializes the counter to 7 or 15, for a byte or word multiply respectively.
The first shift of tmpC is performed, putting the low bit into the carry flag.</p>
<p>The loop body performs the shift-and-add step.
It tests the carry flag, the low bit of the multiplicand. It skips over the <code>ADD</code> if there is no carry (<code>NCY</code>).
Otherwise, tmpB is added to tmpA. (As tmpA gets shifted to the right, tmpB gets added to higher and higher positions in the result.)
The tmpA and tmpC registers are rotated right. This also puts the next bit of the multiplicand into the carry flag for the next cycle.
The microcode jumps to the top of the loop if the counter is not zero (<code>NCZ</code>). Otherwise, the subroutine returns with the result in tmpA and tmpC.</p>
<pre>ZERO → tmpA  RRCY tmpC   <span><b>CORX:</b> initialize right rotate</span>
Σ → tmpC     MAXC         <span> get rotate result, initialize counter to max value</span>
             JMPS NCY 8  <span><b>5:</b> top of loop</span>
             ADD tmpA     <span>conditionally add</span>
Σ → tmpA               F  <span>sum to tmpA, update flags to get carry</span>
             RRCY tmpA   <span><b>8:</b> 32-bit shift of tmpA/tmpC</span>
Σ → tmpA     RRCY tmpC  
Σ → tmpC     JMPS NCZ 5   <span>loop to 5 if counter is not 0</span>
             RTN  
</pre>

<h3><code>MULCOF</code></h3>
<p>The last subroutine is <code>MULCOF</code>, which configures the carry and overflow flags.
The 8086 uses the rule that if the upper half of the result is nonzero, the carry and overflow flags are set, otherwise they are cleared.
The first two lines pass tmpA (the upper half of the result) through the ALU to set the
zero flag for the conditional jump. As a side-effect, the other status flags will get set but these values are &#34;undefined&#34; in the documentation.<span id="fnref:flags"><a href="#fn:flags">6</a></span>
If the test is nonzero, the carry and overflow flags are set (<code>SCOF</code>), otherwise they are cleared (<code>CCOF</code>).<span id="fnref:overflow"><a href="#fn:overflow">5</a></span>
The <code>SCOF</code> and <code>CCOF</code> micro-operations were implemented solely for used by multiplication, illustrating how microcode can be designed around
specific needs.</p>
<pre>             PASS tmpA  <span><b>MULCOF:</b> pass tmpA through to test if zero</span>
Σ → no dest  JMPS 12   F <span>update flags</span>

             JMPS Z 8   <span><b>12:</b> jump if zero</span>
             SCOF RTN    <span>otherwise set carry and overflow</span>

             CCOF RTN   <span><b>8:</b> clear carry and overflow</span>
</pre>

<h2>8-bit multiplication</h2>
<p>The 8086 has separate instructions for 8-bit multiplication.
The process for 8-bit multiplication is similar to 16-bit multiplication, except the values are half as long and the shift-and-add loop executes 8 times instead of 16.
As shown below, the 8-bit sum starts in the low half of the temporary A register and is shifted left into tmpC.
Meanwhile, the 8-bit multiplier starts in the low half of tmpC and is shifted out to the right.
At the end, the result is split between tmpA and tmpC.</p>
<table>
<tbody><tr><th colspan="16">sum (tmpA)</th><th colspan="16">multiplier (tmpC)</th></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
</tbody></table>

<p>The 8086 supports many instructions with byte and word versions, using 8-bit or 16-bit arguments.
In most cases, the byte and word instructions use the same microcode, with the ALU and register hardware using bytes or words based on the instruction.
However, the byte- and word-multiply instructions use different registers, requiring microcode changes.
In particular, the multiplier is in <code>AL</code>, the low half of the accumulator.
At the end, the 16-bit result is returned in <code>AX</code>, the full 16-bit accumulator; two micro-instructions assemble the result from tmpC and tmpA into
the two bytes of the accumulator, &#39;AL&#39; and &#39;AH&#39; respectively.
Apart from those changes, the microcode is the same as the word multiply microcode discussed earlier.</p>
<pre>AL → tmpC    LRCY tmpC         <span><b>iMUL rmb:</b></span>
M → tmpB     CALL X0 PREIMUL  
             CALL CORX  
             CALL F1 NEGATE  
             CALL X0 IMULCOF  
tmpC → AL    JMPS X0 7  
             CALL MULCOF  
tmpA → AH    RNI
</pre>

<h2>Signed multiplication</h2>
<p>The 8086 (like most computers) represents signed numbers using a format called two&#39;s complement.
While a regular byte holds a number from 0 to 255, a signed byte holds a number from -128 to 127.
A negative number is formed by flipping all the bits (known as the one&#39;s complement) and then adding 1, yielding the two&#39;s complement value.<span id="fnref:complement"><a href="#fn:complement">7</a></span>
For instance, +5 is <code>0x05</code> while -5 is <code>0xfb</code>.
(Note that the top bit of a number is set for a negative number; this is the sign bit.)
The nice thing about two&#39;s complement numbers is that the same addition and subtraction operations work on both signed and unsigned values.
Unfortunately, this is not the case for signed multiplication, since signed and unsigned values yield different results due to sign extension.</p>
<p>The 8086 has separate multiplication instructions <code>IMUL</code> (Integer Multiply) to perform signed multiplication.
The 8086 performs signed multiplication by converting the arguments to positive values, performing unsigned multiplication, and then
negating the result if necessary.
As shown above, signed and unsigned multiplication both use the same microcode, but the microcode conditionally calls some subroutines for
signed multiplication.
I will discuss those micro-subroutines below.</p>
<h3><code>PREIMUL</code></h3>
<p>The first subroutine for signed multiplication is <code>PREIMUL</code>, performing preliminary operations for integer multiplication.
It converts the two arguments, stored in tmpC and tmpB, to positive values.
It keeps track of the signs using an internal flag called <code>F1</code>, toggling this flag for a negative argument.
This conveniently handles the rule that two negatives make a positive since complementing the <code>F1</code> flag twice will clear it.</p>
<p>This microcode, below, illustrates the complexity of microcode and how micro-operations are carefully arranged to get the right values at the right time.
The first micro-instruction performs one ALU operation and sets up a second operation.
The calling code had set up the ALU to perform <code>LRCY tmpC</code>, so that&#39;s the result returned by Σ (and discarded).
Performing a left rotate and discarding the result may seem pointless, but the important side-effect is that the top bit
(i.e. the sign bit) ends up in the carry flag.
The microcode does not have a conditional jump based on the sign, but has a conditional jump based on carry, so the point is
to test if tmpC is negative.
The first micro-instruction also sets up negation (<code>NEG tmpC</code>) for the <em>next</em> ALU operation.</p>
<pre>Σ → no dest  NEG tmpC   <span><b>PREIMUL:</b> set up negation of tmpC</span>
             JMPS NCY 7  <span>jump if tmpC positive</span>
Σ → tmpC     CF1         <span>if negative, negate tmpC, flip F1</span>
             JMPS 7      <span>jump to shared code</span>

             LRCY tmpB  <span><b>7:</b></span>
Σ → no dest  NEG tmpB    <span>set up negation of tmpB</span>
             JMPS NCY 11 <span>jump if tmpB positive</span>
Σ → tmpB     CF1 RTN     <span>if negative, negate tmpB, flip F1</span>
             RTN        <span><b>11:</b> return</span>
</pre>

<p>For the remaining lines,
if the carry is clear (<code>NCY</code>), the next two lines are skipped. Otherwise, the ALU result (<code>Σ</code>) is written to tmpC, making it positive,
and the <code>F1</code> flag is complemented with <code>CF1</code>. (The second short jump (<code>JMPS</code>) may look unnecessary, but I reordered the code for clarity.)
The second half of the microcode performs a similar test on tmpB. If tmpB is negative, it is negated and <code>F1</code> is toggled.</p>
<h3><code>NEGATE</code></h3>
<p>The microcode below is called after computing the result, if the result needs to be made negative.
Negation is harder than you might expect because the result is split between the tmpA and tmpC registers.
The two&#39;s complement operation (<code>NEG</code>) is applied to the low word, while either 2&#39;s complement or one&#39;s complement (<code>COM1</code>) is applied to
the upper word, depending on the carry for mathematical reasons.<span id="fnref:neg"><a href="#fn:neg">8</a></span>
The code also toggles F1 and makes tmpB positive; I think this code is only useful for division, which also uses the <code>NEGATE</code> subroutine.</p>
<pre>             NEG tmpC   <span><b>NEGATE:</b> negate tmpC</span>
Σ → tmpC     COM1 tmpA F <span>maybe complement tmpA</span>
             JMPS CY 6  
             NEG tmpA    <span>negate tmpA if there&#39;s no carry</span>
Σ → tmpA     CF1        <span><b>6:</b> toggle F1 for some reason</span>

             LRCY tmpB  <span><b>7:</b> test sign of tmpB</span>
Σ → no dest  NEG tmpB    <span>maybe negate tmpB</span>
             JMPS NCY 11 <span>skip if tmpB positive</span>
Σ → tmpB     CF1 RTN     <span>else negate tmpB, toggle F1</span>
             RTN        <span><b>11:</b> return</span>
</pre>

<h3><code>IMULCOF</code></h3>
<p>The <code>IMULCOF</code> routine is similar to <code>MULCOF</code>, but the calculation is a bit trickier for a signed result.
This routine sets the carry and overflow flags if the upper half of the result is significant, that is, it is not
just the sign extension of the lower half.<span id="fnref:imulcof"><a href="#fn:imulcof">9</a></span>
In other words, the top byte is not significant if it duplicates the top bit (the sign bit) of the lower byte.
The trick in the microcode is to add the top bit of the lower byte to the upper byte by putting it in the carry flag
and performing an add with carry (<code>ADC</code>) of 0.
If the result is 0, the upper byte is not significant, handling the positive and negative cases.
(This also holds for words instead of bytes.)</p>
<pre>ZERO → tmpB  LRCY tmpC  <span><b>IMULCOF:</b> get top bit of tmpC</span>
Σ → no dest  ADC tmpA    <span>add to tmpA and 0 (tmpB)</span>
Σ → no dest   F          <span>update flags</span>
             JMPS Z 8   <span><b>12: jump if zero result</b></span>
             SCOF RTN    <span>otherwise set carry and overflow</span>

             CCOF RTN   <span><b>8:</b> clear carry and overflow</span>
</pre>

<h2>The hardware for multiplication</h2>
<p>For the most part, the 8086 uses the regular ALU addition and shifts for the multiplication algorithm. Some special hardware
features provide assistance.</p>
<h3>Loop counter</h3>
<p>The 8086 has a special 4-bit loop counter for multiplication. This counter starts at 7 for byte multiplication and 15 for word multiplication,
based on the instruction.
This loop counter allows the microcode to decrement the counter, test for the end, and perform a conditional branch in one micro-operation.
The counter is implemented with four flip-flops, along with logic to compute the value after decrementing by one.
The <code>MAXC</code> (Maximum Count) micro-instruction sets the counter to 7 or 15 for byte or word operations respectively.
The <code>NCZ</code> (Not Counter Zero) micro-instruction has two actions. First, it performs a conditional jump if the counter is nonzero.
Second, it decrements the counter.</p>
<h3>X register</h3>
<p>The multiplication microcode uses an internal register called the <code>X</code> register to distinguish between the <code>MUL</code> and <code>IMUL</code> instructions.
The <code>X</code> register is a 3-bit register that holds the ALU opcode, indicated by bits 5–3 of the instruction.<span id="fnref:x-reg"><a href="#fn:x-reg">10</a></span>
Since the instruction is held in the Instruction Register, you might wonder why a separate register is required.
The motivation is that some opcodes specify the type of ALU operation in the second byte of the instruction, the ModR/M byte, bits 5–3.<span id="fnref:opcode"><a href="#fn:opcode">11</a></span>
Since the ALU operation is sometimes specified in the first byte and sometimes in the second byte, the <code>X</code> register was added to handle
both these cases.</p>
<p>For the most part, the <code>X</code> register indicates which of the eight standard ALU operations is selected (<code>ADD</code>, <code>OR</code>, <code>ADC</code>, <code>SBB</code>, <code>AND</code>, <code>SUB</code>, <code>XOR</code>, <code>CMP</code>). 
However, a few instructions use bit 0 of the <code>X</code> register to distinguish between other pairs of instructions.
For instance, it distinguishes between <code>MUL</code> and <code>IMUL</code>, <code>DIV</code> and <code>IDIV</code>, <code>CMPS</code> and <code>SCAS</code>, <code>MOVS</code> and <code>LODS</code>, or <code>AAA</code> and <code>AAS</code>.
While these instruction pairs may appear to have arbitrary opcodes, they have been carefully assigned.
The microcode can test this bit using the <code>X0</code> condition and perform conditional jumps.</p>
<p>The implementation of the <code>X</code> register is straightforward, consisting of three flip-flops to hold the three bits of the instruction.
The flip-flops are loaded from the prefetch queue bus during First Clock and during Second Clock for appropriate instructions, as the
instruction bytes travel over the bus.
Testing bit 0 of the <code>X</code> register with the <code>X0</code> condition is supported by the microcode condition evaluation circuitry, so it can be used for conditional jumps in the microcode.</p>
<h3>The F1 flag</h3>
<p>The multiplication microcode uses an internal flag called <code>F1</code>,<span id="fnref:f1"><a href="#fn:f1">12</a></span> which has two distinct uses.
The flag keeps track of a <code>REP</code> prefix for use with a string operation.
But the <code>F1</code> flag is also used by signed multiplication and division to keep track of the sign.
The <code>F1</code> flag can be toggled by microcode through the <code>CF1</code> (Complement F1) micro-instruction.
The <code>F1</code> flag is implemented with a flip-flop, along with a multiplexer to select the value. It is cleared when a new instruction starts,
set by a <code>REP</code> prefix, and toggled by the <code>CF1</code> micro-instruction.</p>
<p>The diagram below shows how the F1 latch and the loop counter appear on the die. In this image, the metal layer has been removed, showing the
silicon and the polysilicon wiring underneath.</p>
<p><a href="https://static.righto.com/images/8086-mul/counter.jpg"><img alt="The counter and F1 latch as they appear on the die. The latch for the REP state is also here." height="308" src="https://static.righto.com/images/8086-mul/counter-w600.jpg" title="The counter and F1 latch as they appear on the die. The latch for the REP state is also here." width="600"/></a></p><p>The counter and F1 latch as they appear on the die. The latch for the REP state is also here.</p>
<h2>Later advances in multiplication</h2>
<p>The 8086 was pretty slow at multiplying compared to later Intel processors.<span id="fnref:performance"><a href="#fn:performance">13</a></span>
The 8086 took up to 133 clock cycles to multiply unsigned 16-bit values due to the complicated microcode loops.
By 1982, the Intel 286 processor cut this time down to 21 clock cycles.
The Intel 486 (1989) used an improved algorithm that could end early, so multiplying by a small number could take just 9 cycles.</p>
<p>Although these optimizations improved performance, they still depended on looping over the bits.
With the shift to 32-bit processors, the loop time became unwieldy.
The solution was to replace the loop with hardware: instead of performing 32 shift-and-add loops,
an array of adders could compute the multiplication in one step.
This quantity of hardware was unreasonable in the 8086 era, but as Moore&#39;s law made transistors smaller and cheaper, hardware multiplication became
practical.
For instance, the Cyrix Cx486SLC (1992) had a 16-bit hardware multiplier that cut word multiply down to 3 cycles.
The Intel Core 2 (2006) was even faster, able to complete a 32-bit multiplication every clock cycle.</p>
<!-- Manual page 26-160 http://www.bitsavers.org/components/intel/80486/i486_Processor_Programmers_Reference_Manual_1990.pdf -->
<!-- https://techmonitor.ai/technology/cyrix_promises_misery_for_intel_with_its_cx486slc -->
<!-- Pentium: alpert 1993 -->

<p>Hardware multiplication is a fairly complicated subject, with many optimizations to maximize performance while minimizing hardware.<span id="fnref:hardware"><a href="#fn:hardware">14</a></span>
Simply replacing the loop with a sequence of 32 adders is too slow because the result would be delayed while propagating through all the adders.
The solution is to arrange the adders as a tree to provide parallelism. The first layer has 16 adders to add pairs of terms. The next layer adds pairs of these partial
sums, and so forth. The resulting tree of adders is 5 layers deep rather than 32, reducing the time to compute the sum.
Real multipliers achieve further performance improvements by splitting up the adders and creating a more complex tree:
the venerable <a href="https://en.wikipedia.org/wiki/Wallace_tree">Wallace tree</a> (1964) and <a href="https://en.wikipedia.org/wiki/Dadda_multiplier">Dadda multiplier</a> (1965) are
two popular approaches.
Another optimization is the <a href="https://en.wikipedia.org/wiki/Booth%27s_multiplication_algorithm">Booth algorithm</a> (1951), which performs signed
multiplication directly, without converting the arguments to positive values first.
The Pentium 4 (2000) used a Booth encoder and a Wallace tree
(<a href="https://past.date-conference.com/proceedings-archive/2017/pyear/PAPERS/2002/DATE02/PDFFILES/01B_1.PDF">ref</a>), but research in
the early 2000s found the Dadda tree is faster and it is now more popular.</p>
<h2>Conclusions</h2>
<p>Multiplication is much harder to compute than addition or subtraction. The 8086 processor hid this complexity from the programmer
by providing four multiplication instructions for byte and word multiplication of signed or unsigned values.
These instructions were implemented multiplication in microcode, performing shifts and adds in a loop.
By using microcode subroutines and conditional execution, these four machine instructions share most of the microcode.
As the microcode capacity of the 8086 was very small, this was a critical feature of the implementation.</p>
<p>If you made it through all the discussion of microcode, congratulations!
Microcode is even harder to understand than assembly code.
Part of the problem is that microcode is very fine-grain, with even ALU operations split into multiple steps.
Another complication is that 8086 microcode performs a register move and another operation in parallel, so it&#39;s hard to
keep track of what&#39;s going on.
Microcode can seem a bit like a jigsaw puzzle, with pieces carefully fit together as compactly as possible.
I hope the explanations here made sense, or at least gave you a feel for how microcode operates.</p>
<p>I&#39;ve written multiple <a href="https://www.righto.com/search/label/8086">posts on the 8086</a> so far and
plan to continue reverse-engineering the 8086 die so
follow me on Twitter <a href="https://twitter.com/kenshirriff">@kenshirriff</a> or <a href="https://www.righto.com/feeds/posts/default">RSS</a> for updates.
I&#39;ve also started experimenting with Mastodon recently as <a href="https://oldbytes.space/@kenshirriff">@<span data-cfemail="016e6d6563787564722f7271606264416a646f7269687373686767">[email protected]</span></a>.</p>
<h2>Notes and references</h2>


</div></div>
  </body>
</html>
