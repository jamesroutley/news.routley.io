<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://esoteric.codes/blog/published-for-the-first-time-the-original-intercal72-compiler-code">Original</a>
    <h1>The Princeton INTERCAL Compiler&#39;s source code</h1>
    
    <div id="readability-page-1" class="page"><div>
                <p><img src="https://esoteric.codes/uploads/c164fd0b-de22-4dd6-919e-881b023dbe6d/ical-header.png" alt="" width="" height=""/></p>
<p>It is with great excitement that we share the original INTERCAL-72 compiler source code, as both scans and transcriptions (see below). INTERCAL was created by Don Woods (<a href="https://esoteric.codes/blog/don-woods" target="_blank" rel="noopener">previously interviewed here</a>) and Jim Lyon as undergrads at Princeton in an infamous late-night session after freshman finals in 1972. Don recently rediscovered a print-out, on green-barred, continuous-feed pages, of the SPITBOL source code for the original compiler. If the legend holds true, this code had not been run since Woods and Lyon&#39;s Princeton days. Sean Haas (of the <a href="https://adventofcomputing.com/" target="_blank" rel="noopener">Advent of Computing</a> podcast) and I transcribed the code from these scans, proof-reading each others&#39; interpretations of fading characters. Haas has also produced a refined, runnable version of the script.</p>
<p>INTERCAL (&#34;Compiler Language with No Pronounceable Acronym&#34;) is the first language that can unequivocally be called an esolang. While previous languages had odd designs as pl research and experimentation, INTERCAL intentionally subverts its programmers&#39; effort to write what Dijkstra called &#34;good code&#34;: that which &#34;shortens the conceptual gap between the static program and the dynamic process.&#34; In INTERCAL, code is circuitous, full of symbols used in bizarre ways and with unique designations (#, for example, is the &#34;mesh&#34; sign). It is a challenge to read or to run in ones head, even for those deeply immersed in the language. Furthermore, it does this for parody and play, not with any practical aim in mind.</p>
<p>The length of INTERCAL&#39;s shadow cannot be overstated. It was twenty years after its creation that a series of minimalist languages (FALSE, Befunge, brainfuck) took the next steps toward what would become the esolang movement. INTERCAL-72 offered somewhat of a different path from these; it was less concerned with minimalism, and more explicitly dramatized the act of programming. Woods and Lyon described it as eschewing conventions of languages like ALGOL, SNOBOL, FOCAL, and AP/I, yet it is also clearly parody, embracing and exaggerating their worst eccentricities and inefficiencies for an alienating experience.</p>
<p>INTERCAL&#39;s most striking feature is its humanizing of the interpreter, a mercurial being who we literally plead with to get our programs to run. Use the command PLEASE too little and the interpreter will be offended and ignore the whole program; use it too much and it writes you off as a suck-up and... also ignore the whole program. Its subjectivity feels particularly relevant in an age when AI systems are designed to deliberately confuse the human and algorithmic. The influence of just this one feature can be seen in early parody languages like Chicken and Ook! that undermine the seriousness of the interpreter, to <a href="https://esolangs.org/wiki/English" target="_blank" rel="noopener">English</a>, where the interpreter was once literally another person but is now downgraded to an AI prompt system. More personally, the interpreter for my <a href="https://github.com/rottytooth/Olympus" target="_blank" rel="noopener">language Olympus</a> has many, competing personalities in the form of the Greek gods, any of which might become offended and ignore the rest of the program, in INTERCAL style.</p>
<p>However, for such an influential esolang, it is one that we experience primarily in derivative forms. The most well-known INTERCAL keyword (apart from PLEASE) is not part of the INTERCAL-72 language at all. That would be the COME FROM statement, an inverse of GOTO, where one has to trace back jumps from destination to source, like cheating in a choose-your-own-adventure book. It was added in 1990 by Eric S Raymond (<a href="https://esoteric.codes/blog/interview-with-eric-s-raymond" target="_blank" rel="noopener">interviewed here</a>) for his adaptation C-INTERCAL. The original INTERCAL-72 compiler never left Princeton according to Woods; it is likely that ESR worked from the INTERCAL-72 manual without access to the reference compiler. Almost all who have used the language since then have actually used C-INTERCAL or one of its successors (CLC-INTERCAL etc). These later versions capture much of the spirit of the original but differ significantly in style and content. Now, with access to the original, we can experience INTERCAL-72 first-hand and make new discoveries.</p>
<p>Sean Haas describes the process of getting the ical.sbl (INTERCAL compiler) program running on a modern system, using SPITBOLx64. As he points out, ICAL is actually a transpiler; some of its infamous slowness is due to the overhead of generating a SPITBOL program and executing it. More surprisingly, it avoids SPITBOL&#39;s math functions, performing math through pure string manipulation. Sean discusses this in <a href="https://adventofcomputing.libsyn.com/website/episode-158-intercal-rides-again-restoring-a-lost-compiler" target="_blank" rel="noopener">the latest episode</a> of his podcast, Advent of Code, explaining the infamous thirty seconds needed to perform a single division:</p>
<blockquote><span>The two operations you get, called MINGLE and SELECT, operate on binary data. Internally, ICAL will store numbers as a string of binary digits. A 4 becomes &#34;100&#34;, for instance. When you operate on that number it&#39;s done as a string operation. The result is that any operation with numbers become this convoluted mess, both in INTERCAL and in the final output SPITBOL. Hence, 30 second divides.</span></blockquote>
<p>The full set of scans and transcribed code <a href="https://github.com/rottytooth/INTERCAL72" target="_blank" rel="noopener">can be found on GitHub</a>.</p>
<p><a href="https://github.com/rottytooth/INTERCAL72/tree/main" target="_blank" rel="noopener"><img src="https://github.com/rottytooth/INTERCAL72/blob/main/scans/ical-01.jpeg?raw=true" alt="" width="404" height="554"/></a> <a href="https://github.com/rottytooth/INTERCAL72" target="_blank" rel="noopener"><img src="https://github.com/rottytooth/INTERCAL72/blob/main/scans/ical-02.jpeg?raw=true" alt="" width="404" height="556"/></a></p>
            </div></div>
  </body>
</html>
