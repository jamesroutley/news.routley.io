<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.tweag.io/blog/2022-11-22-wasm-backend-merged-in-ghc/">Original</a>
    <h1>WebAssembly back end merged into GHC</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>Tweag has been working on a GHC WebAssembly backend for some time.
Recently, the WebAssembly backend <a href="https://gitlab.haskell.org/ghc/ghc/-/merge_requests/9204">merge request</a> has landed
in GHC, and is on course to appear in the upcoming 9.6 release series.
This post will give a quick demonstration of how to try it out
locally, and explain what comes in this patch and what will be coming next.</p>
<h2 id="playing-with-wasm-locally"><a href="#playing-with-wasm-locally" aria-label="playing with wasm locally permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Playing with WASM locally</h2>
<p>If you’re using nix on x86_64-linux, compiling a Haskell program to a
self-contained wasm module is as simple as:</p>
<div data-language="sh"><pre><code>$ nix shell https://gitlab.haskell.org/ghc/ghc-wasm-meta/-/archive/master/ghc-wasm-meta-master.tar.gz
$ <span>echo</span> <span>&#39;main = putStrLn &#34;hello world&#34;&#39;</span> <span>&gt;</span> hello.hs
$ wasm32-wasi-ghc hello.hs <span>-o</span> hello.wasm
<span>[</span><span>1</span> of <span>2</span><span>]</span> Compiling Main             <span>(</span> hello.hs, hello.o <span>)</span>
<span>[</span><span>2</span> of <span>2</span><span>]</span> Linking hello.wasm
$ wasmtime ./hello.wasm
hello world</code></pre></div>
<p>There’s also a non-nix installation script. Check the <a href="https://gitlab.haskell.org/ghc/ghc-wasm-meta">ghc-wasm-meta</a>
repo’s README for details.</p>
<p>What’s interesting about the example above? It doesn’t need any
companion JavaScript code, and runs on a variety of wasm engines that
support <a href="https://github.com/WebAssembly/WASI">wasi</a>, including but not limited to: <a href="https://wasmtime.dev">wasmtime</a>, <a href="https://wasmedge.org">wasmedge</a>,
<a href="https://wasmer.io">wasmer</a> and <a href="https://github.com/wasm3/wasm3">wasm3</a>. Compared to the legacy <a href="https://github.com/tweag/asterius"><code>asterius</code></a>
project, there are also a few other serious benefits:</p>
<ul>
<li>The killer feature is being able to use GHC’s own RTS code for garbage
collection and other runtime functionality. The GHC RTS is way more
robust, feature-complete and performant than <code>asterius</code>’s legacy
JavaScript runtime. Lots of Haskell features that never worked in
<code>asterius</code> (e.g. STM or profiling) now work out of the box.</li>
<li>It has proper support for compiling and linking C/C++ code. Terms
and conditions apply here, but there’s still a high chance the
<code>cbits</code> in your packages will work out of the box.</li>
<li>Since it uses LLVM for linking, the linking step is orders of
magnitudes faster than <code>asterius</code>, which uses a custom
object format and linking logic.</li>
<li>GHC CI tests a <a href="https://gitlab.haskell.org/ghc/ghc/-/blob/master/.gitlab/hello.hs">program</a> that uses the GHC API to parse a
Haskell module. <code>ghc</code> is a big package and depends on everything in
the boot libraries, so even having only a part of GHC frontend
working in pure wasm is already pretty cool, and it certainly
provides more assurance than a simple “hello world”. <code>asterius</code>
never had <code>ghc</code> in its boot libraries.</li>
</ul>
<h2 id="what-is-in-this-merge-request"><a href="#what-is-in-this-merge-request" aria-label="what is in this merge request permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What is in this merge request</h2>
<p>The GHC wasm backend merge request’s commit <a href="https://gitlab.haskell.org/ghc/ghc/-/merge_requests/9204/commits">history</a>
is carefully structured to contain mostly small and easy to review
patches. The changeset can be roughly grouped into:</p>
<ul>
<li>Enhancing the build system, making it aware of the <code>wasm32-wasi</code>
target, and avoid compiling stuff not supported on that target</li>
<li>Avoiding the usage of POSIX features not supported on <code>wasm32-wasi</code> – various places need to be patched, like the RTS, <code>base</code> or <code>unix</code></li>
<li>Doing various other RTS fixes, for issues that didn’t break other
GHC targets by pure luck</li>
<li>Enhancing the GHC driver with certain wasm-specific logic – most of
the time due to the need to workaround some upstream issues in LLVM</li>
<li>Modeling the wasm structured control flow, and implementing the
algorithm to translate arbitrary Cmm control flow graphs to it – this
part of the work was done by my colleague Norman Ramsey, and well explained
in his ICFP 2022 <a href="https://dl.acm.org/doi/10.1145/3547621">paper</a></li>
<li>Implementing the wasm native code generator (NCG), which translates Cmm to
assembly code – unlike NCGs for other targets, the wasm NCG uses a
dependently-typed IR to preserve type safety of the wasm value
stack, and this has proved to be helpful in catching some errors
early on when writing the NCG</li>
<li>Serving the binary distributions as CI artifacts, and there’s
already some basic testing</li>
</ul>
<p>GHC is a rapidly evolving project, and merging the wasm backend does not
make it immune to potential future breakages. For me, it’s not just an
honor to implement wasm support, but also a personal commitment to
maintain it, prevent bit-rotting, and make sure that the <a href="https://en.wikipedia.org/wiki/Bus_factor">bus
factor</a> of this work goes beyond 1 in the future. This is made possible
by Tweag’s long term support.</p>
<h2 id="what-comes-next"><a href="#what-comes-next" aria-label="what comes next permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What comes next</h2>
<h3 id="javascript-ffi"><a href="#javascript-ffi" aria-label="javascript ffi permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>JavaScript FFI</h3>
<p><code>asterius</code> had a rich JavaScript FFI implementation, allowing one to
import JavaScript functions into Haskell, pass arbitrary JavaScript
values as first-class Haskell values, and export Haskell functions to
be called by JavaScript. Furthermore, the JavaScript async functions
worked naturally with the Haskell threading system, so that when a Haskell
thread is blocked on an async JavaScript call, the runtime executes
other threads instead of blocking completely.</p>
<p>This is the first of <code>asterius</code> main features that I plan to port to
GHC’s wasm backend. You don’t pay for JavaScript if you don’t use it.
We’ve already gained good experience with wasm/js interoperability,
but this time I will need to do non-trivial refactorings in the GHC
RTS storage manager and scheduler to achieve the same. So this will
take some time and may not make it into GHC 9.6.1.</p>
<h3 id="template-haskell"><a href="#template-haskell" aria-label="template haskell permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Template Haskell</h3>
<p><code>asterius</code> had limited support for Template Haskell. Template Haskell
requires dynamically linking Haskell code, but how dynamic linking is
supposed to work in wasm is still unclear, so <code>asterius</code> cheated by
doing static linking each time a TH splice was evaluated. Since the
runtime heap state isn’t preserved between splice evals, when the TH
splices are stateful, this approach won’t work, but it’s been proven
to work surprisingly well for a lot of TH splices in the wild.</p>
<p>I plan to add Template Haskell support for GHC’s wasm backend in a
similar way. Pure TH splices (e.g. generating optics for datatypes)
are likely to work, and work much faster than <code>asterius</code> thanks to the much
improved linking performance. But splices with side effects (e.g.
<code>gitrev</code> that needs to spawn a <code>git</code> subprocess), may not work if
the side effect isn’t a supported WASI operation.</p>
<p>Since implementing proper dynamic linking isn’t planned yet, ghci
wouldn’t work in GHC’s wasm backend in the near future.</p>
<h3 id="more-things-to-come"><a href="#more-things-to-come" aria-label="more things to come permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>More things to come</h3>
<p>There are also other things planned in addition to the above features,
including but not limited to:</p>
<ul>
<li>Using the GHC issue tracker for bugfixes/feature planning and
discussions, for better transparency of my work</li>
<li>Running the full GHC testsuite and nofib benchmarks</li>
<li>Supporting cross-compiling to wasm from more host systems</li>
<li>Wasm-related patches to common Hackage dependencies, or a Hackage
overlay for wasm</li>
</ul></div></div></div>
  </body>
</html>
