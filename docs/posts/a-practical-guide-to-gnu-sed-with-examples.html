<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://thevaluable.dev/sed-cli-practical-guide-examples/">Original</a>
    <h1>A Practical Guide to GNU sed With Examples</h1>
    
    <div id="readability-page-1" class="page"><section><picture><source srcset="https://thevaluable.dev/images/2024/sed-guide/sed_stream_editor.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2024/sed-guide/sed_stream_editor.jpg" alt="Bilbo trying to edit the stream of Rivendell"/></picture><p>The sun is shining today; too bad, you’re stuck in the office of your beloved company, MegaCorpMoneyMaker. Your task is to delete specific lines across thousands of XML files; it’s the “API” of an external warehouse, and, as always, they screwed it up.</p><p>You begin to write a script using your favorite programming language, when suddenly Davina, your colleague developer, comes to your desk:</p><p>“You know that you don’t have to write a script to do that? You could simply use sed in your terminal.”</p><p>You used sed in the past, but only to <span>s</span>ubstitute some words with others. How could Davina delete specific lines depending on their content? You don’t have time to think more: Davina is already on your keyboard.</p><p>“It’s super easy. I’ll show you!”</p><p>Curious to learn more, you let her explain what sed is all about. This article is the transcription of this magical day which changed the world.</p><p>More specifically, Davina explained the following:</p><ul><li>What argument we can give to sed.</li><li>What’s a sed script.</li><li>How to write the input file in place.</li><li>How to use an address in a sed script to edit specific lines.</li><li>How to use the commands <span>p</span>rint and <span>d</span>elete.</li><li>How to invert the address.</li><li>How to use more than one command in a sed script.</li><li>How to use the <span>s</span>ubstitute command.</li></ul><p>As the title suggest, we’ll focus on GNU sed in this article. If you don’t have it, I’d recommend you to install and use it. To know if you have GNU sed, simply run <code>sed --version</code> in your shell; if it doesn’t work, you don’t have it. If it does work, you’ll get the information you seek.</p><p>Also, if you prefer watching videos instead of reading, you’ll find two at the end of this article, recorded by your humble servant.</p><p>Last thing: you can download the <a href="https://github.com/Phantas0s/the_valuable_dev_companion/blob/main/guide-sed/nginx.conf" target="_blank" rel="noopener">companion file</a> if you want to follow along and try by yourself the different commands. I’d recommend you to do so, to remember what we’ll see here, and be able to use sed in different contexts.</p><p>It’s time! Get your diving gear and let’s explore the intricate caves of our stream of text.</p><h2 id="the-basics-of-sed">The Basics of sed</h2><p>Let’s begin by the obvious: what on Earth does “sed” mean? This lovely name is for <span>s</span>tream <span>ed</span>itor. It’s indeed an editor which follows this workflow:</p><ol><li>Take a stream of text as input.</li><li>Select some specific lines.</li><li>Perform some operations on each line selected.</li><li>Output the resulting text.</li></ol><p>The second and third steps are done thanks to a <em>sed script</em>. <a href="#the-sed-script">We’ll look at this concept later</a>; first, let’s look at what arguments we can give to sed in our shell.</p><h3 id="general-command-line-syntax">General Command-Line Syntax</h3><p>Our stream editor can take two arguments:</p><p>The <code>[script]</code> defines what operations you want to do, and the <code>[file...]</code> are the files you want to work on.</p><p>Let’s look at the simplest example ever:</p><p>Here’s the result:</p><picture><source srcset="https://thevaluable.dev/images/2024/sed-guide/01_sed_without_script.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2024/sed-guide/01_sed_without_script.jpg" alt="Running sed without script output the whole input"/></picture><p>By default, sed output (or “print”) every single line of its input. Because our sed script is empty, sed only output the file. As a result, the command above is equivalent to the shell command <code>cat nginx.conf</code>.</p><p>Files are not the only possible input. We can also directly pipe to sed. For example:</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span>echo</span> <span>&#34;this is some input&#34;</span> <span>|</span> sed <span>&#39;&#39;</span>
</span></span></code></pre></div><p>The result:</p><picture><source srcset="https://thevaluable.dev/images/2024/sed-guide/02_sed_pipe.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2024/sed-guide/02_sed_pipe.jpg" alt="We can pass an input to sed with a shell pipe"/></picture><p>Wonderful.</p><h3 id="the-sed-script">The sed Script</h3><p>The purpose of a sed script is to perform operations on the input.</p><h4 id="the-three-parts-of-a-sed-script">The Three Parts of a sed Script</h4><p>A sed script can be divided in three parts; they should be given in order:</p><table><tbody><tr><th>Name</th><th>Description</th></tr><tr><td>Address</td><td>The lines you want to edit. It’s always followed by a command.</td></tr><tr><td>Command</td><td>The operation you want to perform. It’s always a single letter.</td></tr><tr><td>Options</td><td>A couple of commands can have options, like the <a href="#the-substitute-command">substitute command</a> for example.</td></tr></tbody></table><p>Here’s an example of a sed script using the command <span>d</span>elete:</p><p>By default, the command of a sed script operate on each line. As a result, we <span>d</span>elete here every single line. That’s why the output is empty.</p><p>Thankfully, It doesn’t mean that we delete all the content of the file <code>nginx.conf</code>; by default, sed will never modify the file (or input) given. Instead, it will:</p><ol><li>Copy each line of the input in a buffer.</li><li>Do the operations described by the sed script on the buffered lines.</li><li>Output the (possibly modified) buffered lines.</li></ol><p>You can also directly modify the file in place if you want to.</p><h3 id="writing-directly-the-input-file">Writing Directly The Input File</h3><p>It might be confusing for beginners to see an editor which doesn’t edit a file directly; it was confusing for me at least. But it’s a good thing: contrary to most text editors out there, there’s no undo functionality with sed. When you modify your input file, you can’t go back.</p><p>Let’s add an address to our sed script, to only delete the first line:</p><p>As we saw, this won’t affect the file <code>nginx.conf</code>, but the output. As a result, if you want to save your editing, you could redirect this output to a new file:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>sed <span>&#39;1d&#39;</span> nginx.conf &gt; nginx.new.conf
</span></span></code></pre></div><p>If you really want to modify the input file, you can also add the option <code>-i</code> to your shell command, to modify directly the file <span>i</span>n place. I would recommend you to create a backup before doing so; for example:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>cp nginx.conf nginx.conf.back
</span></span><span><span>sed -i <span>&#39;1d&#39;</span> nginx.conf
</span></span></code></pre></div><p>This time, the file <code>nginx.conf.back</code> will have the content of <code>nginx.conf</code> before any sed editing, and the first line of the file <code>nginx.conf</code> will be deleted. You can actually do this operation in one command-line:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>sed -i.back <span>&#39;1d&#39;</span> nginx.conf
</span></span></code></pre></div><p>Our stream editor will automatically:</p><ol><li>Copy the input file, and add the suffix <code>.back</code> to the filename (here <code>nginx.conf.back</code>).</li><li>Modify the input file <span>i</span>n place.</li></ol><p>To summarize:</p><picture><source srcset="https://thevaluable.dev/images/2024/sed-guide/03_edit_file_in_place.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2024/sed-guide/03_edit_file_in_place.jpg" alt="We can directly modify the input file in place with sed"/></picture><h2 id="the-address-selecting-specific-lines">The Address: Selecting Specific Lines</h2><p>The address indicates what to copy in sed’s buffer, to then apply a sed command to each of them. As a result, the address is always before the command in a sed script.</p><p>An address can be:</p><ul><li>A line number.</li><li>A range of lines</li><li>Every <em>nth</em> line.</li><li>A regex.</li></ul><p>In our previous example, we used the address <code>1</code> in the sed script to <span>d</span>elete the first line:</p><h3 id="selecting-specific-line-numbers">Selecting Specific Line Numbers</h3><p>We can directly give line numbers as addresses. Here are a couple of examples:</p><table><tbody><tr><th>Example</th><th>Description</th><th>Type</th></tr><tr><td><code>sed &#39;1d&#39; nginx.conf</code></td><td>Delete the first line.</td><td>Line number.</td></tr><tr><td><code>sed &#39;2,5d&#39; nginx.conf</code></td><td>Delete the lines 2 to 5 (included).</td><td>Range of line.</td></tr><tr><td><code>sed &#39;0~2d&#39; nginx.conf</code></td><td>Delete every even line (from line 0, delete every 2 lines).</td><td>Every <em>nth</em> line.</td></tr><tr><td><code>sed &#39;1~2d&#39; nginx.conf</code></td><td>Delete every odd line (from line 1, delete every 2 lines).</td><td>Every <em>nth</em> line</td></tr></tbody></table><h3 id="selecting-lines-using-regular-expressions">Selecting Lines Using Regular Expressions</h3><p>We can also select the lines we want using regular expressions (regexes). Here are more examples:</p><table><tbody><tr><th>Example</th><th>Description</th><th>Type</th></tr><tr><td><code>sed &#39;/include/d&#39; nginx.conf</code></td><td>Delete each line matching the pattern <code>include</code>.</td><td>Regex.</td></tr><tr><td><code>sed &#39;3,/include/d&#39; nginx.conf</code></td><td>Delete from the 3rd line until the first line matching the pattern <code>include</code>.</td><td>Range of line using a regex.</td></tr><tr><td><code>sed &#39;/http/,/include/d&#39; nginx.conf</code></td><td>Delete every line, from the first line matching <code>http</code> to the first line matching <code>include</code>.</td><td>Range of lines using two regexes.</td></tr></tbody></table><p>If you want to know more about regexes, <a href="https://thevaluable.dev/regular-expression-basics-vim-grep/">this article explores the basics using Vim</a>.</p><p>Let’s look closer at the following example:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>sed <span>&#39;/http/,/include/d&#39;</span> nginx.conf
</span></span></code></pre></div><p>The result:</p><picture><source srcset="https://thevaluable.dev/images/2024/sed-guide/04_range_regex_not_matched.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2024/sed-guide/04_range_regex_not_matched.jpg" alt="We can use regexes as range in sed"/></picture><p>In our file, the first instance of <code>http</code> is at line 1, and the first instance of <code>include</code> is at line 2, so both lines are deleted. Nothing groundbreaking here.</p><p>But if you give a range ending with a regex which doesn’t match any other subsequent line, your sed command will operate until the end of your input. Here, the regex <code>http</code> can also be matched at line 8, and no following line matches <code>include</code>. As a result, everything from line 8 until the end of the input is deleted.</p><p>In the same spirit, if you use a range beginning with a regex, but this regex is never matched, your sed command will never operate on anything.</p><h4 id="case-insensitive-regex">Case Insensitive Regex</h4><p>If you don’t want to be bothered by the case, you can add the flag <code>I</code> after a regex to make it case <span>i</span>sensitive. For example:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>sed <span>&#39;/HTTP/I,/InClUdE/Id&#39;</span> nginx.conf
</span></span></code></pre></div><p>The result:</p><picture><source srcset="https://thevaluable.dev/images/2024/sed-guide/05_regex_case_insensitive.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2024/sed-guide/05_regex_case_insensitive.jpg" alt="Add the &#39;I&#39; flag to a sed regex for case-insensitive"/></picture><h4 id="the-extended-regex-engine">The Extended Regex Engine</h4><p>You can use one of two regex engines with GNU sed:</p><ul><li>Basic regex engine (the default).</li><li><span>E</span>xtended regex engine.</li></ul><p>With the basic regex engine, you’ll have to escape the following characters if you want them to be <a href="https://thevaluable.dev/regular-expression-basics-vim-grep/#characters-and-metacharacters">regex metacharacters</a>: <code>?</code>, <code>+</code>, <code>()</code>, <code>{}</code>, and <code>|</code>. The extended regex engine includes them; to use it, simply add the option <code>-E</code> to your shell command.</p><p>For example, these two command-lines are equivalent:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>sed <span>&#39;/server\|include\|on\|log\|^$/d&#39;</span> nginx.conf
</span></span><span><span>sed -E <span>&#39;/server|include|on|log|^$/d&#39;</span> nginx.conf
</span></span></code></pre></div><p>The breathtaking result:</p><picture><source srcset="https://thevaluable.dev/images/2024/sed-guide/06_extended_regex_engine.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2024/sed-guide/06_extended_regex_engine.jpg" alt="Using the extended regex engine when using regexes with sed is the best"/></picture><p>Escaping characters is often a bad idea: it makes the regex more difficult to read and understand. Personally, to keep things simple, I use the extended regex engine each time I use regex metacharacters.</p><h3 id="only-output-the-chosen-lines">Only Output the Chosen Lines</h3><p>As we saw at the very beginning, sed always output every line of the input by default. You can disable this with the command-line option <code>-n</code> (for <span>n</span>o print), or its more understandable equivalents <code>--quiet</code> or <code>--silent</code>.</p><p>For example, the following doesn’t output anything:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>sed -n <span>&#39;&#39;</span> nginx.conf
</span></span><span><span>sed --quiet <span>&#39;&#39;</span> nginx.conf
</span></span></code></pre></div><p>What’s the point, then? It’s where the sed command <code>p</code> becomes useful: it <span>p</span>rints the lines we address, to only output them. For example, to display the first line of a file:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>sed -n <span>&#39;1p&#39;</span> nginx.conf
</span></span><span><span>sed --quiet <span>&#39;1p&#39;</span> nginx.conf
</span></span></code></pre></div><picture><source srcset="https://thevaluable.dev/images/2024/sed-guide/07_sed_print_quiet.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2024/sed-guide/07_sed_print_quiet.jpg" alt="Printing the lines we want with sed"/></picture><p>Without the option <code>--quiet</code> (or <code>-n</code>), you’d get the first line of the file, as well as all the lines of the file! As a result, the first line would be printed twice, and every other line printed once:</p><picture><source srcset="https://thevaluable.dev/images/2024/sed-guide/08_sed_print_without_quiet.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2024/sed-guide/08_sed_print_without_quiet.jpg" alt="Printing lines with sed without the noprint option"/></picture><p>This also allows us to mimic the behavior of <a href="https://thevaluable.dev/grep-cli-guide-examples/">grep</a> with sed; to only output the lines matching a specific pattern, we can simply give a regex as address, and print only the lines matching it. For example:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>sed -n <span>&#39;/include/p&#39;</span> nginx.conf
</span></span></code></pre></div><p>Here’s a quick comparison:</p><picture><source srcset="https://thevaluable.dev/images/2024/sed-guide/09_sed_mimic_grep.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2024/sed-guide/09_sed_mimic_grep.jpg" alt="How to use sed to mimic grep"/></picture><p>This make sed a powerful tool to only output a part of your input stream. It’s handy if you want to work with a specific ranges of line, with sed or with any other CLI tool (using a pipe). For example, if you want to know how many lines there are between the beginning of the file until the first line matching <code>include</code>:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>sed --quiet <span>&#39;1,/include/p&#39;</span> nginx.conf <span>|</span> wc -l
</span></span></code></pre></div><p>The result:</p><picture><source srcset="https://thevaluable.dev/images/2024/sed-guide/10_sed_print_pipe.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2024/sed-guide/10_sed_print_pipe.jpg" alt="The print sed command is useful to pipe it through other CLI tool"/></picture><h3 id="inverting-the-address">Inverting the Address</h3><p>It’s possible to invert the concept of address: instead of operating on the lines addressed, we could operate on every line <em>except</em> the ones addressed. To do so, we need to add a bang <code>!</code> after the address itself.</p><p>Here are some examples to illustrate the point:</p><table><tbody><tr><th>Example</th><th>Description</th></tr><tr><td><code>sed &#39;1!d&#39; nginx.conf</code></td><td>Delete every line <em>except</em> the first one.</td></tr><tr><td><code>sed &#39;/include/!d&#39; nginx.conf</code></td><td>Delete every line <em>except</em> the ones matching the pattern <code>include</code>.</td></tr></tbody></table><p>As a result, the two following shell commands are equivalent:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>sed <span>&#39;/include/!d&#39;</span> nginx.conf
</span></span><span><span>sed -n <span>&#39;/include/p&#39;</span> nginx.conf
</span></span></code></pre></div><p>To prove my discourse:</p><picture><source srcset="https://thevaluable.dev/images/2024/sed-guide/11_sed_invert_address_print_equivalent.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2024/sed-guide/11_sed_invert_address_print_equivalent.jpg" alt="How to invert the address in a sed script"/></picture><h2 id="using-more-than-one-command">Using More than One Command</h2><p>It’s also possible to use more than one command in our sed scripts (with different addresses), or even use multiples sed script in one shell command.</p><h3 id="using-multiple-commands-in-a-sed-script">Using Multiple Commands in a sed Script</h3><p>You can use more than one command in a sed script if you separate them with <code>;</code>. For example:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>sed <span>&#39;1,10d;15,$d&#39;</span> nginx.conf
</span></span></code></pre></div><p>The first script <code>1,10d</code> deletes all the lines from line 1 to 10, and the second script <code>15,$d</code> deletes all the lines from line 15 to the end of the input.</p><h3 id="using-multiple-sed-scripts">Using Multiple sed Scripts</h3><p>You can also use the command-line option <code>-e</code> (or <code>--expression</code>) to execute multiple scripts:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>sed -e <span>&#39;1,10d&#39;</span> -e <span>&#39;15,$d&#39;</span> nginx.conf
</span></span></code></pre></div><p>The illustration we all waited for:</p><picture><source srcset="https://thevaluable.dev/images/2024/sed-guide/12_sed_multiple_commands_scripts.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2024/sed-guide/12_sed_multiple_commands_scripts.jpg" alt="How to use multiple scripts in a sed shell command"/></picture><h2 id="the-substitute-command">The Substitute Command</h2><p>We already spoke about two important sed commands in this article: the <span>d</span>elete and the <span>p</span>rint commands. While they’re useful in their own right, many use sed for its <span>s</span>ubstitute command.</p><h3 id="general-syntax">General Syntax</h3><p>As we saw, a sed script can be made of three elements: the address, the sed command, and possible options depending on the command. These elements need to be given in this order.</p><p>The <span>s</span>ubstitute command is one of the few sed commands taking some options. Here’s the general syntax:</p><div><pre tabindex="0"><code data-lang="text"><span><span>s/&lt;pattern&gt;/&lt;replacement&gt;/[flag]
</span></span></code></pre></div><p>This command will try to match the regular expression <code>&lt;pattern&gt;</code> on each line of your input, and replace these matches with the <code>&lt;replacement&gt;</code>. For example, if you want to replace the string “index” by “page”, you can do:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>sed <span>&#39;s/index/page/&#39;</span> nginx.conf
</span></span></code></pre></div><p>Here’s the difference between the input (the file nginx.conf) and the output:</p><table><tbody><tr><td><strong>input</strong></td><td><code>index index.html index.htm index.php;</code></td></tr><tr><td><strong>output</strong></td><td><code>page index.html index.htm index.php;</code></td></tr></tbody></table><h3 id="replacing-a-specific-match-on-a-line">Replacing a Specific Match on a Line</h3><p>By default, if your pattern matches more than one string of characters on the line, only the first one will be replaced. If you want to replace every matches on each line, you need to use the <span>g</span>lobal flag:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>sed <span>&#39;s/index/page/g&#39;</span> nginx.conf
</span></span></code></pre></div><p>Again, here’s the difference between the input and output:</p><table><tbody><tr><td><strong>input</strong></td><td><code>index index.html index.htm index.php;</code></td></tr><tr><td><strong>output</strong></td><td><code>page page.html page.htm page.php;</code></td></tr></tbody></table><p>You can also replace a specific match on the line by giving a number as flag. This number represents the <em>nh</em> match you want to replace. For example, if you want to replace the second match:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>sed <span>&#39;s/index/page/2&#39;</span> nginx.conf
</span></span></code></pre></div><p>The result:</p><table><tbody><tr><td><strong>input</strong></td><td><code>index index.html index.htm index.php;</code></td></tr><tr><td><strong>output</strong></td><td><code>index page.html index.htm index.php;</code></td></tr></tbody></table><p>Finally, you might want to replace every match from the <em>nth</em> match on. To do so, you can add two flags: a number and the <span>g</span>lobal flag. For example:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>sed <span>&#39;s/index/page/2g&#39;</span> nginx.conf
</span></span></code></pre></div><p>The difference between input and output:</p><table><tbody><tr><td><strong>input</strong></td><td><code>index index.html index.htm index.php;</code></td></tr><tr><td><strong>output</strong></td><td><code>index page.html page.htm page.php;</code></td></tr></tbody></table><h3 id="reusing-the-pattern-in-the-replacement">Reusing the Pattern in the Replacement</h3><p>You can reuse the pattern you want to match in your replacement thanks to the character <code>&amp;</code>. For example:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>sed <span>&#39;s/index/&amp;-page/&#39;</span> nginx.conf
</span></span></code></pre></div><p>The result:</p><table><tbody><tr><td><strong>input</strong></td><td><code>index index.html index.htm index.php;</code></td></tr><tr><td><strong>output</strong></td><td><code>index-page index.html index.htm index.php;</code></td></tr></tbody></table><p>You could also use regexes with <a href="https://thevaluable.dev/regular-expression-basics-vim-grep/#grouping-and-backreference">grouping and backreference</a>. For example:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>sed -E <span>&#39;s/(ind)(ex)/\1-page-\2/&#39;</span> nginx.conf
</span></span></code></pre></div><p>We use here the <span>e</span>xtended regular expression engine to avoid escaping the parentheses. The result:</p><table><tbody><tr><td><strong>input</strong></td><td><code>index index.html index.htm index.php;</code></td></tr><tr><td><strong>output</strong></td><td><code>ind-page-ex index.html index.htm index.php;</code></td></tr></tbody></table><h3 id="using-different-separators">Using Different Separators</h3><p>Using the slash <code>/</code> as a separator between your pattern, your replacement, and the optional flags can bring some problems. If you work with a pattern (or a replacement) which has already some slashes (like URLs), you’d need to escape every single one of them for sed to understand what slashes are separators and what slashes aren’t.</p><p>For example, the following won’t work:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>sed <span>&#39;s/http://server.com/ftp://ftpserver/&#39;</span> nginx.conf
</span></span></code></pre></div><p>The unfortunate result:</p><picture><source srcset="https://thevaluable.dev/images/2024/sed-guide/13_sed_error_substitution.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2024/sed-guide/13_sed_error_substitution.jpg" alt="Using the separator in a substitute as characters doesn&#39;t work"/></picture><p>Instead, we need to escape each slash which is not a separator:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>sed <span>&#39;s/http:\/\/server.com/ftp:\/\/ftpserver/&#39;</span> nginx.conf
</span></span></code></pre></div><p>As we saw already, we should avoid escaping characters as much as we could. But fear not! There’s a better solution. You can actually use other characters as separators (if they’re not alphanumerical characters), like <code>|</code>, <code>%</code> or <code>#</code> (my personal favorite). For example:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>sed <span>&#39;s#http://server.com#ftp://ftpserver#&#39;</span> nginx.conf
</span></span><span><span>sed <span>&#39;s%http://server.com%ftp://ftpserver%&#39;</span> nginx.conf
</span></span></code></pre></div><p>The result:</p><table><tbody><tr><td><strong>input</strong></td><td><code>proxy_pass http://server.com/this/is/a/massive/server;</code></td></tr><tr><td><strong>output</strong></td><td><code>proxy_pass ftp://ftpserver/this/is/a/massive/server;</code></td></tr></tbody></table><h3 id="only-displaying-the-replaced-lines">Only Displaying the Replaced Lines</h3><p>We saw above that it was possible to only display the lines addressed, thanks to the <span>p</span>rint command. But what if we want to only display the lines where some replacements are made?</p><p>We could use two commands for that: first the <span>s</span>ubstitute command to replace our characters, and second the <span>p</span>rint command to only output the lines replaced. For example:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>sed -n <span>&#39;s/index/page/g;/page/p&#39;</span> nginx.conf
</span></span><span><span>sed -n -e <span>&#39;s/index/page/g&#39;</span> -e <span>&#39;/page/p&#39;</span> nginx.conf
</span></span></code></pre></div><p>But it’s not really a good solution. If any other line matches the address <code>/page/</code> in the file for example, they would be added to the output even if no replacements were made.</p><p>A better solution is to add the <span>p</span>rint flag to the options of our <span>s</span>ubstitute command:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>sed <span>&#39;s/index/page/gp&#39;</span> nginx.conf
</span></span></code></pre></div><p>But this doesn’t really work as expected. Remember: sed print already all the lines of the file (or input) by default; to only print the lines which have some replacements, we need to only output what we want to <span>p</span>rint explicitly:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>sed -n <span>&#39;s/index/page/gp&#39;</span> nginx.conf
</span></span></code></pre></div><p>Here’s the difference:</p><picture><source srcset="https://thevaluable.dev/images/2024/sed-guide/14_sed_substitute_command_print_flag.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2024/sed-guide/14_sed_substitute_command_print_flag.jpg" alt="Using the print flag with the sed substitute command"/></picture><p>Don’t be confused here: we use here the flag <code>p</code> for the sed command <code>s</code>, <em>not</em> the sed command <code>p</code>.</p><h3 id="special-sequences">Special Sequences</h3><p>We can use special sequences in the <code>&lt;replacement&gt;</code> of the <span>s</span>ubstitute command, to convert one or multiple characters to uppercase or lowercase:</p><table><tbody><tr><th>Sequence</th><th>Description</th></tr><tr><td><code>u</code></td><td>The next character becomes uppercase.</td></tr><tr><td><code>l</code></td><td>The next character becomes lowercase.</td></tr><tr><td><code>\U</code></td><td>All characters following this sequence become uppercase, until the next <code>\E</code>.</td></tr><tr><td><code>\L</code></td><td>All characters following this sequence become lowercase, until the next <code>\E</code>.</td></tr><tr><td><code>\E</code></td><td>Stop the case conversion started by <code>\U</code> or <code>\L</code>.</td></tr></tbody></table><p>For example:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>sed -E <span>&#39;s/(in)dex/\U\1\E-\u&amp;-page/2g&#39;</span> nginx.conf
</span></span></code></pre></div><p>Here’s the difference between the input and the output:</p><table><tbody><tr><td><strong>input</strong></td><td><code>index index.html index.htm index.php;</code></td></tr><tr><td><strong>output</strong></td><td><code>index IN-Index-page.html IN-Index-page.htm IN-Index-page.php;</code></td></tr></tbody></table><h2 id="youre-now-ready-to-surf-on-the-stream">You’re Now Ready to Surf on the Stream</h2><p>The next time you need to do some bulk editing on multiple files, or if you need to do some editing in a Bash script, sed is a really strong option to do so.</p><p>What did we see in this article?</p><ul><li>The sed command-line can take two arguments: a sed script and a file.</li><li>Instead of a file, an input can also be piped to sed.</li><li>A sed script is composed of three parts: the address, the command, and possibly the command’s options.</li><li>By default, sed copy the input, edit it, and output the result. It means that the input itself is never modified.</li><li>If you modify directly the file given to sed, you can’t undo the editing. As a result, create a backup if you modify the file <span>i</span>n place.</li><li>Adding an address in a sed script allows you to output specific lines.</li><li>An address can target some line numbers, or lines matching some regexes.</li><li>It’s possible to use more than one sed script by shell command, using the option <code>-e</code> (or <code>--expression</code>).</li><li>The <span>s</span>ubstitute command is one of the most useful commands to find and replace some text.</li><li>The <span>s</span>ubstitute command can take some options, separated by non-alphanumerical characters: a pattern, a replacement, and optional flags.</li><li>With the <span>s</span>ubstitute command, you can target the exact match you want to replace using flags.</li><li>It’s possible to re-use part of the pattern in your replacement in your <span>s</span>ubstitute command.</li></ul><p>We saw simple examples in this article, but sed script is actually a Turing complete programming language: <a href="https://www.mpaoli.net/~michael/bin/ttt" target="_blank" rel="noopener">here’s a TicTacToe implemented in sed</a>.</p><p>There are also some videos on my YouTube channel about sed:</p><p><iframe src="https://www.youtube.com/embed/R-3EahsCmpg" allowfullscreen="" title="YouTube Video"></iframe></p><p><iframe src="https://www.youtube.com/embed/BtZB-fndkzM" allowfullscreen="" title="YouTube Video"></iframe></p></section></div>
  </body>
</html>
