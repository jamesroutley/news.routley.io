<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://eranstiller.com/rabbitmq-vs-kafka-an-architects-dilemma-part-1">Original</a>
    <h1>RabbitMQ vs. Kafka – An Architect’s Dilemma (Part 1)</h1>
    
    <div id="readability-page-1" class="page"><div>
	


<h2>Introduction</h2>



<p>As a software architect dealing with a lot of Microservices based systems, I often encounter the ever-repeating question – “should I use RabbitMQ or Kafka?”. For some reason, many developers view these technologies as interchangeable. While this is true for some cases, there are various underlying differences between these platforms. As a result, different scenarios require a different solution and choosing the wrong one might severely impact your ability to design, develop, and maintain your software solution.</p>



<p>The goal of this blog post is first to introduce the basic asynchronous messaging patterns. Then, it continues to present both RabbitMQ and Kafka and their internal structure. <a href="https://eranstiller.com/rabbitmq-vs-kafka-an-architects-dilemma-part-2">Part 2</a> highlights the critical differences between these platforms, their various advantages and disadvantages, and how to choose between the two.</p>



<h2>Asynchronous Messaging Patterns</h2>



<p>Asynchronous messaging is a messaging scheme where message production by a producer is decoupled from its processing by a consumer.  When dealing with messaging systems, we typically identify two main messaging patterns – Message Queuing and Publish/Subscribe.</p>



<h3>Message Queueing</h3>



<p>In the Message Queuing communication pattern, queues temporally decouple producers from consumers. Multiple producers can send messages to the same queue; however, when a consumer processes a message, it is locked or removed from the queue and is no longer available. Only a single consumer consumes a specific message.</p>


<div>
<figure><img decoding="async" width="642" height="241" src="https://eranstiller.com/wp-content/uploads/2020/02/RabbitMQ-vs-Kafka-Message-Queuing.svg" alt="An illustration of message queue as a transport between producers and consumers"/><figcaption>Message Queuing</figcaption></figure></div>


<p>As a side note, if the consumer fails to process a certain message, the messaging platform typically returns the message to the queue where it is made available for other consumers. Besides temporal decoupling, queues allow us to scale producers and consumers independently as well as providing a degree of fault-tolerance against processing errors.</p>



<h3>Publish/Subscribe</h3>



<p>In the Publish/Subscribe (or Pub/Sub) communication pattern, a single message can be received and processed by multiple subscribers concurrently.</p>


<div>
<figure><img decoding="async" width="675" height="369" src="https://eranstiller.com/wp-content/uploads/2020/02/RabbitMQ-vs-Kafka-PubSub.svg" alt="An illustration of a pub/sub message exchange"/><figcaption>Publish/Subscribe</figcaption></figure></div>


<p>This pattern allows a publisher, for example, to notify all subscribers that something has happened in the system. Many queueing platforms often associate pub/sub with the term <strong>topics</strong>. In RabbitMQ, topics are a specific type of pub/sub implementation (a type of exchange to be exact), but during this post, I refer to topics as a representation of pub/sub as a whole.</p>



<p>Generically speaking, there are two types of subscriptions:</p>



<ol>
<li><strong>An ephemeral subscription</strong>, where the subscription is only active as long the consumer is up and running. Once the consumer shuts down, its subscription and yet-to-be processed messages are lost.</li>



<li><strong>A durable subscription</strong>, where the subscription is maintained as long as it is not explicitly deleted. When the consumer shuts down, the messaging platform maintains the subscription and message processing can be resumed later.</li>
</ol>



<h3>RabbitMQ</h3>



<p><a target="_blank" href="https://www.rabbitmq.com/" rel="noreferrer noopener">RabbitMQ</a> is an implementation of a <strong>Message Broker</strong>, and as is also often referred to as a <strong>Service Bus</strong>. It natively supports both messaging patterns described above. Other popular implementations of message brokers include <a target="_blank" href="https://activemq.apache.org/" rel="noreferrer noopener">ActiveMQ</a>, <a target="_blank" href="https://zeromq.org/" rel="noreferrer noopener">ZeroMQ</a>, <a target="_blank" href="https://azure.microsoft.com/en-us/services/service-bus/" rel="noreferrer noopener">Azure Service Bus</a>, and <a target="_blank" href="https://aws.amazon.com/sqs/" rel="noreferrer noopener">Amazon Simple Queue Service (SQS)</a>. All of these implementations have a lot in common; many concepts described in this post apply to most of them.</p>



<h3>Queues</h3>



<p>RabbitMQ supports classic message queuing out of the box. A developer defines named queues, and then publishers can send messages to that named queue. Consumers, in turn, use the same queue to retrieve messages to process them.</p>



<h3>Message Exchanges</h3>



<p>RabbitMQ implements Pub/Sub via the use of message exchanges. A publisher publishes its messages to a message exchange without knowing who are the subscribers of these messages. Each consumer wishing to subscribe to an exchange creates its queue; the message exchange then queues produced messages for consumers to consume. It can also filter messages for some subscribers based on various routing rules.</p>


<div>
<figure><img decoding="async" loading="lazy" width="675" height="369" src="https://eranstiller.com/wp-content/uploads/2020/02/RabbitMQ-vs-Kafka-RabbitMQ-Message-Exchange.svg" alt="An illustration of a RabbitMQ Message Exchange"/><figcaption>RabbitMQ Message Exchange</figcaption></figure></div>


<p>It is important to note that RabbitMQ supports both ephemeral and durable subscriptions. A consumer can decide the type of subscription they’d like to employ via RabbitMQ’s API.</p>



<p>Due to RabbitMQ’s architecture, we can also create a hybrid approach where some subscribers form <strong>consumer groups</strong> who work together processing messages in the form of competing consumers over a specific queue. In this manner, we implement the pub/sub pattern while also allowing some subscribers to scale-up to handle received messages.</p>


<div>
<figure><img decoding="async" loading="lazy" width="679" height="369" src="https://eranstiller.com/wp-content/uploads/2020/02/RabbitMQ-vs-Kafka-RabbitMQ-Consumer-Groups.svg" alt="An illustration of RabbitMQ fanout topology with routing and consumer groups"/><figcaption>Pub/Sub &amp; Queuing Combined</figcaption></figure></div>


<h2>Apache Kafka</h2>



<p><a target="_blank" href="https://kafka.apache.org/" rel="noreferrer noopener">Apache Kafka</a> is <em>not </em>an implementation of a message broker. Instead, it is a <strong>distributed streaming platform</strong>. Unlike RabbitMQ, which is based on queues and exchanges, Kafka’s storage layer is implemented using a partitioned transaction log. Kafka also provides a Streams API to process streams in real-time and a Connectors API for easy integration with various data sources, however, these are out of scope for this post. </p>



<p>The Cloud Vendors provide alternative solutions for Kafka’s storage layer. These solutions include <a target="_blank" href="https://azure.microsoft.com/en-us/services/event-hubs/" rel="noreferrer noopener">Azure Event Hubs</a>, and to some extent, <a target="_blank" href="https://aws.amazon.com/kinesis/data-streams/" rel="noreferrer noopener">AWS Kinesis Data Streams</a>. There are also cloud-specific and open source alternatives to Kafka’s stream processing capabilities, but again, these are out of scope for this post.</p>



<h3>Topics</h3>



<p>Kafka does not implement the notion of a queue. Instead, Kafka stores collections of records in categories called topics. For each topic, Kafka maintains a partitioned log of messages. Each partition is an ordered, immutable sequence of records where messages are continually appended. Kafka appends messages to these partitions as they arrive. By default, it uses a round-robin partitioner to spread messages uniformly across partitions. Producers can modify this behavior to create logical streams of messages. For example, in a multitenant application, we might want to create logical message streams according to every message’s tenant Id. In an IoT scenario, we might want to have each producer’s identity map to a specific partition constantly. Making sure that all messages from the same logical stream map to the same partition guarantees their delivery in-order to consumers.</p>


<div>
<figure><img decoding="async" loading="lazy" width="571" height="396" src="https://eranstiller.com/wp-content/uploads/2020/02/RabbitMQ-vs-Kafka-Kafka-Producers.svg" alt="An illustration of producers for a Kafka topic and its inner structure"/><figcaption>Kafka Producers</figcaption></figure></div>


<p>Consumers consume messages by maintaining an offset (or index) to these partitions and reading them sequentially. A single consumer can consume multiple topics, and consumers can scale-up to the number of partitions available. As a result, when creating a topic, one should carefully consider the expected throughput of messaging on that topic. A group of consumers working together to consume a topic is called a <strong>consumer group</strong>. Kafka’s API typically handles the balancing of partition processing between consumers in a consumer group and storing consumers’ current partition offsets.</p>


<div>
<figure><img decoding="async" loading="lazy" width="562" height="330" src="https://eranstiller.com/wp-content/uploads/2020/02/RabbitMQ-vs-Kafka-Kafka-Consumers.svg" alt="An illustration of consumer groups for a Kafka topic and its inner structure"/><figcaption>Kafka Consumers</figcaption></figure></div>


<h3>Implementing Messaging Patterns with Kafka</h3>



<p>Kafka’s implementation maps quite well to the pub/sub pattern. A producer can send messages to a specific topic, and multiple consumer groups can consume the same message. Each consumer group can scale individually to handle the load. Since consumers maintain their partition offset, they can choose to have a durable subscription that maintains its offset across restarts or an ephemeral subscription, which throws the offset away and restarts from the latest record in each partition every time it starts up. However, it is a less than perfect fit for the message queuing pattern. Of course, we could have a topic with just a single consumer group to emulate classic message queuing. Nevertheless, this has multiple drawbacks that <a href="https://eranstiller.com/rabbitmq-vs-kafka-an-architects-dilemma-part-2">part 2</a> of this post discusses at length.</p>



<p>It is important to note that Kafka retains messages in partitions up to a preconfigured period, regardless of whether consumers consumed these messages. This retention means that consumers are free to reread past messages. Furthermore, developers can also use Kafka’s storage layer for implementing mechanisms such as Event Sourcing and Audit Logs.</p>



<h2>Closing Words</h2>



<p>While RabbitMQ and Kafka are sometimes interchangeable, their implementations are very different from each other. As a result, we cannot view them as members of the same category of tools; one is a message broker, and the other is a distributed streaming platform. As solution architects, we should acknowledge these differences and actively consider which of these types of solutions we should use for a given scenario. <a href="https://eranstiller.com/rabbitmq-vs-kafka-an-architects-dilemma-part-2">Part 2</a> addresses these differences and provides guidance on when to use each.</p>



<h2>Further Reading</h2>



<p>If you’d like to read more regarding the internal implementation of RabbitMQ and Kafka, I recommend the following resources:</p>



<ul>
<li><a rel="noreferrer noopener" target="_blank" href="https://www.rabbitmq.com/tutorials/amqp-concepts.html">AMQP 0.9.1 Model Explained – RabbitMQ</a></li>



<li><a rel="noreferrer noopener" target="_blank" href="https://kafka.apache.org/intro">Introduction to Apache Kafka</a></li>
</ul>



<hr/>



<p><sub><i>Featured Image – Photo by <a rel="noreferrer noopener" href="https://unsplash.com/@jluebke?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank">Justin Luebke</a> on <a rel="noreferrer noopener" href="https://unsplash.com/s/photos/justin-luebke-coat?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank">Unsplash</a> </i></sub></p>
</div></div>
  </body>
</html>
