<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gpfault.net/posts/asm-tut-0.txt.html">Original</a>
    <h1>Let&#39;s Learn x86-64 Assembly (2020)</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
    <main role="main">
        
        <p><small>published on Apr 18 2020</small></p>
<p><img src="https://gpfault.net/assets/post-img/asm-tut-0/header.png"/>
</p>

<p>
The way I was taught x86 assembly at the university had been completely outdated for many years by the time I had my first class. It was around 2008 or 2009, and 64-bit processors had already started becoming a thing even in my neck of the woods. Meanwhile, we were doing DOS, real-mode, memory segmentation and all the other stuff from the bad old days.
</p>

<p>
Nevertheless, I picked up enough of it during the classes (and over the subsequent years) to be able to understand the stuff coming out of the other end of a compiler, and that has helped me a few times. However, I&#39;ve never manually written any substantial amount of x86 assembly for something non-trivial. Due to being locked up inside (on account of a global pandemic), I decided to change that situation, to pass the time.
</p>

<p>
I wanted to focus on x86-64 specifically, and completely forget/skip any and all legacy crap that is no longer relevant for this architecture. After getting a bit deeper into it, I also decided to publish my notes in the form of tutorials on this blog since there seems to be a desire for this type of content.
</p>

<p>
Everything I write in these posts will be a normal, 64-bit, Windows program. We&#39;ll be using Windows because that is the OS I&#39;m running on all of my non-work machines, and when you drop down to the level of writing assembly it starts becoming incresingly impossible to ignore the operating system you&#39;re running on. I will also try to go as &#34;from scratch&#34; as possible - no libraries, we&#39;re only allowed to call out to the operating system and that&#39;s it.
</p>

<p>
In this first, introductory part (yeah, I&#39;m planning a series and I know I will regret this later), I will talk about the tools we will need, show how to use them, explain how I generally think about programming in assembly and show how to write what is perhaps the smallest viable Windows program.
</p>

<h2>Getting the Tools</h2>
<p>There are two main tools that we will use throughout this series.</p>

<h3>Assembler</h3>

<p>
CPUs execute machine code - an efficient representation of instructions for the processor that is almost completely impenetrable to humans. The assembly language is a human-readable representation of it. A program that converts this symbolic representation into machine code ready to be executed by a CPU is called an <b>assembler</b>.
</p>

<p>
There is no single, agreed-upon standard for x86-64 assembly language. There are many assemblers out there, and even though some of them share a great deal of similarities, each has its own set of features and quirks. It is therefore important which assembler you choose. In this series, we will be using 
<a href="http://flatassembler.net">Flat Assembler</a> (or FASM for short). I like it because it&#39;s small, easy to obtain and use, has a nice macro system and comes with a handy little editor.</p>

<h3>Debugger</h3>

<p>
Another important tool is the debugger. We&#39;ll use it to examine the state of our programs. While I&#39;m pretty sure it&#39;s possible to use Visual Studio&#39;s integrated debugger for this, I think a standalone debugger is better when all you want to do is look at the disassembly, memory and registers. I&#39;ve always used <a href="http://ollydbg.de/">OllyDbg</a> for stuff like that, but unfortunately it does not have a 64-bit version. Therefore we will be using <a href="https://www.microsoft.com/en-us/p/windbg-preview/9pgjgd53tn86?activetab=pivot:overviewtab">WinDbg</a>. The version linked here is a revamp of this venerable tool with a slightly nicer interface. Alternatively, you can get the non-Windows-store version <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools">here</a> as part of the Windows 10 SDK. Just make sure you deselect everything else besides WinDbg during installation. For our purposes, the two versions are mostly interchangeable.
</p>

<h2>Thinking in Assembly</h2>

<p>
Now that we have our tools, I want to spend a bit of time to discuss some basics. For the purpose of these tutorials I&#39;m assuming some knowledge of languages like C or C++, but little or no previous exposure to assembly, therefore many readers will find this stuff familiar.
</p>
<h3>A 10000-foot view</h3>
<p>
CPUs only &#34;know&#34; how to do a fixed number of certain things. When you hear someone talk about an &#34;instruction set&#34;, they&#39;re referring to the set of things a particular CPU has been designed to do, and the term &#34;instruction&#34; just means &#34;one of the things a CPU can do&#34;. Most instructions are parameterized in one way or another, and they&#39;re generally really simple. Usually an instruction is somthing along the lines of &#34;write a given 8-bit value to a given location in memory&#34;, or &#34;interpreting the values from registers A and B as 16-bit signed integers, multiply them and record the result into register A&#34;.
</p>

<p>
Below is a simple mental model of the architecture that we&#39;ll start with.
</p>

<p><img src="https://gpfault.net/assets/post-img/asm-tut-0/diag0.png"/>
</p>

<p>
 This skips a <i>ton</i> of things (there can be more than one core executing instructions and reading/writing memory, there&#39;s different levels of cache, etc. etc.), but should serve as a good starting point.
</p>

<p>
 To be effective at low-level programming or debugging you need to understand that every high-level concept eventually maps to this low-level model, and learning how the mapping works will help you.
</p>

<h3>Registers</h3>
<p>
 You can think of <b>registers</b> as a special kind of memory built right into the CPU that is very small, but extremely fast to access. There are many different kinds of registers in x86-64, and for now we&#39;ll concern ourselves only with the so-called <i>general-purpose</i> registers, of which there are sixteen. Each of them is 64 bits wide, and for each of them the lower byte, word and double-word can be addressed individually (incidentally, 1 &#34;word&#34; = 2 bytes, 1 &#34;double-word&#34; = 4 bytes, in case you haven&#39;t heard this terminology before).
 </p>
 
 <table>
 <tbody><tr>
  <td><b>Register</b></td>
  <td><b>Lower byte</b></td>
  <td><b>Lower word</b></td>
  <td><b>Lower dword</b></td>
 </tr>
 <tr>
  <td>rax</td> <td>al</td> <td>ax</td> <td>eax</td>
 </tr>
 <tr>
  <td>rbx</td> <td>bl</td> <td>bx</td> <td>ebx</td>
 </tr>
 <tr>
  <td>rcx</td> <td>cl</td> <td>cx</td> <td>ecx</td>
 </tr>
 <tr>
  <td>rdx</td> <td>dl</td> <td>dx</td> <td>edx</td>
 </tr>
 <tr>
  <td>rsp</td> <td>spl</td> <td>sp</td> <td>esp</td>
 </tr>
 <tr>
  <td>rsi</td> <td>sil</td> <td>si</td> <td>esi</td>
 </tr>
 <tr>
  <td>rdi</td> <td>dil</td> <td>di</td> <td>edi</td>
 </tr>
 <tr>
  <td>rbp</td> <td>bpl</td> <td>bp</td> <td>ebp</td>
 </tr>
 <tr>
  <td>r8</td> <td>r8b</td> <td>r8w</td> <td>r8d</td>
 </tr>
 <tr>
  <td>r9</td> <td>r9b</td> <td>r9w</td> <td>r9d</td>
 </tr>
 <tr>
  <td>r10</td> <td>r10b</td> <td>r10w</td> <td>r10d</td>
 </tr>
 <tr>
  <td>r11</td> <td>r11b</td> <td>r11w</td> <td>r11d</td>
 </tr>
 <tr>
  <td>r12</td> <td>r12b</td> <td>r12w</td> <td>r12d</td>
 </tr> 
 <tr>
  <td>r13</td> <td>r13b</td> <td>r13w</td> <td>r13d</td>
 </tr> 
 <tr>
  <td>r14</td> <td>r14b</td> <td>r14w</td> <td>r14d</td>
 </tr> 
 <tr>
  <td>r15</td> <td>r15b</td> <td>r15w</td> <td>r15d</td>
 </tr>   
</tbody></table>  

<p>Additionally, the higher 8 bits of <code>rax</code>, <code>rbx</code>, <code>rcx</code> and <code>rdx</code> can be referred to as <code>ah</code>, <code>bh</code>, <code>ch</code> and <code>dh</code>.</p>

<p>
Note that even though I said those were &#34;general-purpose&#34; registers, some instructions can only be used with certain registers, and some registers have special meaning for certain instructions. In particular, <code>rsp</code> holds the stack pointer (which is used by instructions like <code>push</code>, <code>pop</code>, <code>call</code> and <code>ret</code>), and <code>rsi</code> and <code>rdi</code> serve as source and destination index for &#34;string manipulation&#34; instructions. Another example where certain registers get &#34;special treatment&#34; are the multiplication instructions, which require one of the multiplier values to be in the register <code>rax</code>, and write the result into the pair of registers <code>rax</code> and <code>rdx</code>.
</p>

<p>
In addition to these registers, we will also consider the special registers <code>rip</code> and <code>rflags</code>. <code>rip</code> holds the address of the next instruction to execute. It is modified by control flow instructions like <code>call</code> or <code>jmp</code>. <code>rflags</code> holds a bunch of binary flags indicating various aspects of the program&#39;s state, such as whether the result of the last arithmetic operation was less, equal or greater than zero. The behavior of many instructions depends on those flags, and many instructions update certain flags as part of their execution. The flags register can also be read and written &#34;wholesale&#34; using special instructions.
</p>

<p>
There are a lot more registers on x86-64. Most of them are used for SIMD or floating-point instructions, and we&#39;ll not be considering them in this series.
</p>

<h3>Memory and Addresses</h3>

<p>
You can think of memory as a large array of byte-sized &#34;cells&#34;, numbered starting at 0. We&#39;ll call these numbers &#34;memory addresses&#34;. Simple, right?
</p>
<p>
Well... addressing memory used to be rather annoying back in the old days. You see, registers in old x86 processors used to be only 16-bit wide. Sixteen bits is enough to address 64 kilobytes worth of memory, but not more. The hardware was actually capable of using addresses as wide as 20 bits, but you had put a &#34;base&#34; address into a special segment register, and instructions that read or wrote memory would use a 16-bit offset into that segment to obtain the final 20-bit &#34;linear&#34; address. There were separate segment registers for code, data and stack portions (and a few more &#34;extra&#34; ones), and segments could overlap. 
</p>
<p>
In x86-64 these concerns are non-existant. The segment registers for code, data and stack are still present, and they&#39;re loaded with some special values, but as a user-space programmer you needn&#39;t concern yourself with them. For all intents and purposes you can assume that all segments start at 0 and extend for the entire addressable length of memory. So, as far as we&#39;re concerned, on x86-64 our programs see memory as a &#34;flat&#34; contiguous array of bytes, with sequential addresses, starting at 0, just like we said in the beginning of this section...
</p>
<p>
Okay, I may have distorted the truth a little bit. Things aren&#39;t quite as simple. While it is true that on 64-bit Windows your programs see memory as a flat contiguous array of bytes with addresses starting at 0, it is actually an elaborate illusion maintained by the OS and CPU working together.
</p>
<p>
The truth is, if you were really able to read and write any byte in memory willy-nilly, you&#39;d stomp all over other programs&#39; code and data (something that indeed could happen in the Bad Old Days). To prevent that, special protection mechanisms exist. I won&#39;t get too deep into their inner workings here because this stuff matters mostly for OS developers. Nevertheless, here&#39;s a very short overview:
</p>
<p>
Each process gets a &#34;flat&#34; address space as described above (we&#39;ll call it the &#34;virtual address space&#34;). For each process, the OS sets up a <a href="https://wiki.osdev.org/Paging">mapping</a> between its virtual addresses and actual physical addresses in memory. This mapping is respected by the hardware: the &#34;virtual&#34; addresses get translated to physical addresses dynamically at runtime. Thus, the same address (e.g. 0x410F119C) can map to two different locations in physical memory for two different processes. This, in a nutshell, is how the separation between processes in enforced.
</p>

<p>
The final thing I want to invite your attention to here is how the instructions and data which they operate on are held in the same memory. While it may seem an obvious choice, it&#39;s not how computers necessarily <i>have</i> to work. This is a property characteristic of the von Neumann model - as opposed to the Harvard model, where instructions and data are held in separate memories. A real-world example of a Harvard computer is the AVR microcontroller on your Arduino.
</p>

<h2>Our First Program</h2>
<p>
Hopefully by this point you have downloaded FASM and are ready to write some code. Our first program will be really simple: it will load and then immediately exit. We mostly want it just to get acquainted with the tools.
</p>
<p>
Here&#39;s the code for our first program in x86-64 assembly:
</p>
<pre><code>
format PE64 NX GUI 6.0
entry start

section &#39;.text&#39; code readable executable
start:
        int3
        ret
</code>
</pre>
<h3>Analyzing the Code</h3>
<p>
We&#39;ll go through this line-by-line.
</p><ul>
  <li><code>format PE64 NX GUI 6.0</code> - this is a directive telling FASM the format of the binary we expect it to produce - in our case, Portable Executable Format (which is what most Windows programs use). We&#39;ll talk about it in a bit more detail later.
  </li>
  <li><code>entry start</code> - this defines the <i>entry point</i> into our program. The entry directive requires a label, which in this case is &#34;start&#34;. A label can be thought of as a name for an address within our program, so in this case we&#39;re saying &#34;the entry point to the program is at whatever address the &#39;start&#39; label is&#34;. Note that you&#39;re allowed to refer to labels even if they&#39;re defined later in the program code (as is the case here).</li>
  <li><code>section &#39;.text&#39; code readable executable</code> - this directive indicates the beginning of a new section in a Portable Executable file, in this case a section containing executable code. More on this later.</li>
  <li><code>start:</code> - this is the label that denotes the entry point to our program. We referred to it earlier in the &#34;entry&#34; directive. Note that labels themselves don&#39;t produce any executable machine code: they&#39;re just a way for the programmer to mark locations within the executable&#39;s address space.</li>
  <li><code>int3</code> - this is a special instruction that causes the program to call the debug exception handler - when running under a debugger, this will pause the program and allow us to examine its state or proceed with the execution step-by-step. This is how breakpoints are actually implemented - the debugger replaces a single byte in the executable with the opcode corresponding to int3, and when the program hits it, the debugger takes over (obviously, the original content of the memory at breakpoint address has to be remembered and restored before proceeding with execution or single-stepping). In our case, we are hard-coding a breakpoint immediately at the entry point for convenience, so that we don&#39;t have to set it manually via the debugger every time.</li>
  <li><code>ret</code> - this instruction pops off an address from the top of the stack, and transfers execution to that address. In our case, we&#39;ll return into the OS code that initially invoked our entry point.</li>
</ul>

<p>
Fire up FASMW.EXE, paste the code above into the editor, save the file and press <code>Ctrl+F9</code>. Your first assembly program is now complete! Let&#39;s now load it up in a debugger and single-step through it to see it actually working.
</p>

<h3>Using the Debugger</h3>
<p>
Open up WinDbg. Go to the View tab and make sure the following windows are visible: Disassembly, Registers, Stack, Memory and Command. Go to File &gt; Launch Executable and select the executable you just built with FASM. At this point your workspace should resemble something like this:
</p>
<p><img src="https://gpfault.net/assets/post-img/asm-tut-0/windbg0.png"/>
</p>
<p>
In the <b>disassembly</b> window you can see the code that is currently being executed. Right now it&#39;s not our program&#39;s code, but some OS loader code - this stuff will load our program into memory and eventually transfer execution to our entry point. WinDbg ensures a breakpoint is triggered before any of that happens.
</p>
<p>
In the <b>registers</b> window, you can see the contents of x86-64 registers that we discussed earlier.
</p>
<p>
The <b>memory</b> window shows the raw content of the program&#39;s memory around a given virtual address. We&#39;ll use it later.
</p>
<p>
The <b>stack</b> window shows the current call stack (as you can see, it&#39;s all inside ntdll.dll right now).
</p>
<p>
Finally, the <b>command</b> window allows entering text commands and shows log messages.
</p>
<p>
If you press F5 at this time, it will cause the program to continue running until it hits another breakpoint. The next breakpoint it will hit is the one we hardcoded. Try pressing F5, and you&#39;ll see something like this:
</p>
<p><img src="https://gpfault.net/assets/post-img/asm-tut-0/windbg1.png"/>
</p>
<p>You should be able to recognize the two instructions we wrote - int3 and ret. To advance to the next instruction, press F8. When you do that, pay attention to the <b>registers</b> window - you should see the <code>rip</code> register being updated as you advance (WinDbg highlights the registers that change in red).</p>
<p>Right after the <code>ret</code> instruction is executed, you will return to the code that invoked our program&#39;s entry point.
</p>
<p><img src="https://gpfault.net/assets/post-img/asm-tut-0/windbg2.png"/>
</p>
<p>
As you can see from the image above, the next thing that will happen is a call to RtlExitUserThread (a pretty self-explanatory name). If you press F5 now, your program&#39;s main thread will clean up and end, and so will the program. Or will it?...
</p>
<p>
The truth is, by using <code>ret</code>, I took a bit of a shortcut. On Windows a process will terminate if any of the following conditions are met:
</p><ul>
  <li>Any thread calls the WinAPI function <code>ExitProcess</code> explicitly</li>
  <li>All threads have exited</li>
</ul>

<p>
But, we&#39;re exiting the main thread here so we should be good, right? Well, sort of. There&#39;s no guarantee that Windows hasn&#39;t started any <i>other</i> background threads (for example, to load DLLs or something like that) within our process. It seems that at least in this example, the main thread is the only one (I&#39;ve checked and the process doesn&#39;t stick around), but this may change. A well-behaved Windows program should always call <code>ExitProcess</code> at the appropriate time.
</p>

<p>
In order to be able to call WinAPI functions, we need to learn a few things about the Portable Executable file format, how DLLs are loaded and calling conventions.
</p>

<h2>The PE Format and DLL Imports</h2>
<p>The <code>ExitProcess</code> function lives in KERNEL32.DLL (yes, that&#39;s not a typo, KERNEL32 is the name of the 64-bit library. The 32-bit versions of those libs provided for back-compat pueporses, live in a folder names SysWOW64. I&#39;m not joking.). In order to be able to call it, we first need to <i>import</i> it.
</p>
<p>We won&#39;t cover the Portable Executable format in its entirety here. It is <a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format">documented extensively</a> on the Microsoft docs website. Here are a couple of basic facts we&#39;ll need to know:
</p><ul>
  <li>PE files are comprised of <i>sections</i>. We have already seen a section containing executable code in our program, but sections may contain other types of data.</li>
  <li>Information about what symbols are imported from what DLLs is stored in a special section called &#39;.idata&#39;.</li>
</ul>
Let&#39;s have a look at the .idata section.

<p>
As per the <a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#the-idata-section">docs</a>, the .idata section begins with an <b>import directory table</b> (IDT). Each entry in the IDT corresponds to one DLL, is 20 bytes in length and consists of the following fields: 
</p><ul>
  <li>A 4-byte <i><a href="https://en.wikipedia.org/wiki/COFF#Relative_virtual_address">relative virtual address</a></i> (RVA) of the Import Lookup Table (ILT), which contains the names of functions to import. More on that later</li>
  <li>A 4-byte timestamp field (usually 0)</li>
  <li>Forwarder chain index (usually 0)</li>
  <li>A 4-byte RVA of a null-terminated string containing the name of the DLL</li>
  <li>A 4-byte RVA of the Import Address Table (IAT). The structure of the IAT is the same as ILT, the only difference is that the content of IAT is modified at runtime by the loader - it overwrites each entry with the address of the corresponding imported function. So theoretically, you can have both ILT and IAT fields point to the same exact piece of memory. Moreover, I&#39;ve found that setting the ILT pointer to zero also works, although I am not sure if this behavior is officially supported.</li>
</ul>
The Import Directory Table is terminated by an entry where all fields are equal zero.

<p>
The ILT/IAT is an array of 64-bit values terminated by a null value. The bottom 31 bits of each entry contain the RVA of an entry in a hint/name table (containing the name of the imported function). During runtime, the entries of the IAT are replaced with the actual addresses of the imported functions.
</p>
<p>
The hint/name table mentioned above consists of entries, each of which needs to be aligned on an even boundary. Each entry begins by a 2-byte hint (which we&#39;ll ignore for now) and a null-terminated string containing the imported function name, and a null byte (if necessary), to align the next entry on an even boundary.
</p>
<p>
With that out of the way, let&#39;s see how we would define our executable&#39;s .idata section in FASM
</p>
<pre><code>
section &#39;.idata&#39; import readable writeable
idt: ; import directory table starts here
     ; entry for KERNEL32.DLL
     dd rva kernel32_iat
     dd 0
     dd 0
     dd rva kernel32_name
     dd rva kernel32_iat
     ; NULL entry - end of IDT
     dd 5 dup(0)
name_table: ; hint/name table
        _ExitProcess_Name dw 0
                          db &#34;ExitProcess&#34;, 0, 0

kernel32_name: db &#34;KERNEL32.DLL&#34;, 0
kernel32_iat: ; import address table for KERNEL32.DLL
        ExitProcess dq rva _ExitProcess_Name
        dq 0 ; end of KERNEL32&#39;s IAT
</code>
</pre>
<p>
The directive for a new PE section is already familiar to us. In this case, we&#39;re communicating that the section we&#39;re about to introduce contains the imports data and needs to be made writeable when loaded into memory (since addresses of the imported functions will be written in there).
</p>
<p>
The directives db, dw, dd and dq all cause FASM to emit a raw byte/word/double-word/quad-word value respectively. The <code>rva</code> operator, unsurprisingly, yields the relative virtual address of its argument. So, <code>dd rva kernel32_iat</code> will cause FASM to emit a 4-byte binary value equal to the RVA of <code>kernel32_iat</code> label.
</p>
<p>
  Here we&#39;ve just made use of fasm&#39;s db/dw/etc. directives to precisely describe the contents of our .idata section. 
</p>
<h2>The 64-bit Windows Calling Convention</h2>
<p>
We&#39;re now almost ready to finally call ExitProcess. One thing we have to answer though, is - how does a function call work? Think about it. There is a <code>call</code> instruction, which pushes the current value of <code>rip</code> onto the stack, and transfers execution to the address specified by its parameter. There is also the <code>ret</code> instruction, which pops off an address from the stack and transfers execution there. Nowhere is it specified how arguments should be passed to a function, or how to handle the return values. The hardware simply doesn&#39;t care about that. It is the job of the caller and the callee to establish a contract between themselves. These rules might look along the lines of:
</p><ul>
  <li>The caller shall push the arguments onto the stack (starting from the last one)</li>
  <li>The callee shall remove the parameters from the stack before returning.</li>
  <li>The callee shall place return values in the register <code>eax</code></li>
  <li>...</li>
</ul>

<p>
A set of rules like that is referred to as the <i>calling convention</i>, and there are many different calling conventions in use. When you try to call a function from assembly, you must know what type of calling convention it expects.
</p>
<p>
The good news is that on 64-bit Windows there&#39;s pretty much only one calling convention that you need to be aware of - the <a href="https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=vs-2019">Microsoft x64 calling convention</a>. The bad news is that it&#39;s a tricky one - unlike many of the older conventions, it requires the first few parameters to be passed via registers (as opposed to being passed on the stack), which can be good for performance.
</p>
<p>
You may read the full docs if you&#39;re interested in details, I will cover only the parts of the calling convention relevant to us here:
</p><ul>
 <li>The stack pointer has to be aligned to a 16-byte boundary</li>
 <li>The first four integer or pointer arguments are passed in the registers rcx, rdx, r8 and r9; the first four floating point arguments are passed in registers xmm0 to xmm3. Any additional args are passed on the stack.</li>
 <li>Even though the first 4 arguments aren&#39;t passed on the stack, the caller is still required to allocate 32 bytes of space for them on the stack. This has to be done even if the function has less than 4 arguments.</li>
 <li>The caller is responsible for cleaning up the stack.</li>
</ul>

<p>
Armed with this knowledge, we can finally call ExitProcess:
</p><pre><code>
format PE64 NX GUI 6.0
entry start

section &#39;.text&#39; code readable executable
start:
        int3
        sub rsp, 8 * 5  ; adjust stack ptr and allocate shadow space.
        xor rcx, rcx    ; The first and only argument is the return code - passed in rcx.
        call [ExitProcess]


section &#39;.idata&#39; import readable writeable
idt: ; import directory table starts here
     ; entry for KERNEL32.DLL
     dd rva kernel32_iat
     dd 0
     dd 0
     dd rva kernel32_name
     dd rva kernel32_iat
     ; NULL entry - end of IDT
     dd 5 dup(0)
name_table: ; hint/name table
        _ExitProcess_Name dw 0
                          db &#34;ExitProcess&#34;, 0, 0

kernel32_name db &#34;KERNEL32.DLL&#34;, 0
kernel32_iat: ; import address table for KERNEL32.DLL
        ExitProcess dq rva _ExitProcess_Name
        dq 0 ; end of KERNEL32&#39;s IAT
</code>
</pre>

<p>
Let&#39;s go through the new lines one-by-one.
</p><ul>
  <li><code>sub rsp, 8 * 5</code> - the <code>sub</code> instruction subtracts its second operand from its first operand and stores the result in the first operand. In this case, we&#39;re subtracting 40 from the current value of the stack pointer (note that somewhat counterintuitively, the stack &#34;grows&#34; downward, i.e. pushing onto the stack or allocating space on it diminishes the value of the stack pointer). Thus, we&#39;re aligning the stack to a 16-byte boundary, and allocating a &#34;shadow space&#34; for the first 4 arguments in one fell swoop. How does this work? Well, before our entry point was invoked, the stack pointer was aligned to a 16-byte boundary. As a result of the call, a return address was pushed onto the stack, diminishing the stack pointer value by 8 and throwing it out of alignment. We need to subtract another 8 bytes to bring it into alignment again, and another 32 bytes to account for the shadow space, hence the value 40.</li>
  <li><code>xor rcx, rcx</code> - recall that the first integer argument should be passed in the rcx register. Here, we&#39;re setting the value of that register to zero by performing a bitwise exclusive-or operation with itself.
  </li>
  <li><code>call [ExitProcess]</code> - this is what finally calls ExitProcess. The square brackets around the label name denote indirection - rather than calling the address referred to by the label, the value recorded in memory at that address is used as the target address for the call. Of course, the label we&#39;re using is pointing to the location within the import table where the loader has written the address of the required function!</li>
</ul>

<p>
Fire it up in WinDbg again, run until our hardcoded breakpoint, then single-step to see how we eventually call ExitProcess, making note of how the rsp and rcx registers change.
</p>
<p><img src="https://gpfault.net/assets/post-img/asm-tut-0/windbg3.png"/>
</p>
<p>
That&#39;s it for this first part. Next time, we&#39;ll try to do something more interesting than just exiting the process :)
</p>
  
        <hr/>
        <p><i>Like this post? <a href="https://bsky.app/profile/nicebyte.bsky.social">Follow</a> me on bluesky for more!</i></p>
      </main>
    </div></div>
  </body>
</html>
