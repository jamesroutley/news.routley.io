<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://quic.video/blog/replacing-webrtc/">Original</a>
    <h1>Replacing WebRTC: real-time latency with WebTransport and WebCodecs</h1>
    
    <div id="readability-page-1" class="page"><article>
<p>The long path to use <em>something else</em> for real-time media.</p>
<h2 id="tldr">tl;dr</h2>
<p>If you primarily use WebRTC for…</p>
<ul>
<li><strong>real-time media</strong>: it will take a while to replace WebRTC; we’re working on it.</li>
<li><strong>data channels</strong>: WebTransport is amazing and <em>actually</em> works.</li>
<li><strong>peer-to-peer</strong>: you’re stuck with WebRTC for the forseeable future.</li>
</ul>
<h2 id="disclaimer">Disclaimer</h2>
<p>I spent almost two years building/optimizing a partial WebRTC stack @ Twitch using <a href="https://github.com/pion/webrtc">pion</a>.
Our use-case was quite custom and we ultimately scrapped it, but your millage may vary.</p>
<h2 id="why-webrtc">Why WebRTC?</h2>
<p>Google released WebRTC in 2011 as a way of fixing a very specific problem:</p>
<blockquote>
<p>How do we build Google Meet?</p>
</blockquote>
<p>Back then, the web was a very different place.
Flash was the only way to do live media and it was a <em>mess</em>.
HTML5 video was primarily for pre-recorded content.
It personally took me until 2015 to write a <a href="https://reddit.com/r/Twitch/comments/3hqfkw/the_csgo_client_embeds_the_twitch_html5_player/">HTML5 player for Twitch</a> using <a href="https://developer.mozilla.org/en-US/docs/Web/API/Media_Source_Extensions_API">MSE</a>, and we’re still talking 5+ seconds of latency on a good day.</p>
<p>Transmitting video over the internet <em>in real-time</em> is hard.</p>
<p>You need a tight coupling between the video encoding and the network to avoid any form of queuing, which adds latency.
This effectively rules out TCP and forces you to use UDP.
But now you also need a video encoder/decoder that can deal with packet loss without spewing artifacts everywhere.</p>
<figure><p><img src="https://thewitchofendor.com/blog/replacing-webrtc/artifact.png" alt="Video artifacts"/></p><figcaption><p><a href="https://flashphoner.com/10-important-webrtc-streaming-metrics-and-configuring-prometheus-grafana-monitoring/">Source</a>.
Example of Artifacts caused by packet loss.</p></figcaption></figure>
<p>Google (correctly) determined that it would be impossible to solve these problems piecewise with new web standards.
The approach instead was to create <a href="https://webrtc.googlesource.com/src/">libwebrtc</a>, the defacto WebRTC implementation that still ships with all browsers.
It does everything, from networking to video encoding/decoding to data transfer, and it does it remarkably well.
It’s actually quite a feat of software engineering, <em>especially</em> the part where Google managed to convince Apple/Mozilla to embed a full media/networking stack into their browsers.</p>
<p>My favorite part about WebRTC is that it manages to leverage existing standards.
WebRTC is not really a protocol, but rather a collection of protocols: <a href="https://datatracker.ietf.org/doc/html/rfc8445">ICE</a>, <a href="https://datatracker.ietf.org/doc/html/rfc5389">STUN</a>, <a href="https://datatracker.ietf.org/doc/html/rfc5766">TURN</a>, <a href="https://datatracker.ietf.org/doc/html/rfc6347">DTLS</a>, <a href="https://datatracker.ietf.org/doc/html/rfc3550">RTP/RTCP</a>, <a href="https://datatracker.ietf.org/doc/html/rfc3711">SRTP</a>, <a href="https://datatracker.ietf.org/doc/html/rfc4960">SCTP</a>, <a href="https://datatracker.ietf.org/doc/html/rfc4566">SDP</a>, <a href="https://datatracker.ietf.org/doc/html/rfc6762">mDNS</a>, etc.
Throw a <a href="https://www.w3.org/TR/webrtc/">Javascript API</a> on top of these and you have WebRTC.</p>
<figure><p><img src="https://thewitchofendor.com/blog/replacing-webrtc/layers.png" alt="WebRTC protocols and layers"/>
</p><figcaption><a href="https://hpbn.co/webrtc/">Source</a>. That’s a lot of protocols layered on top of each other.</figcaption></figure>
<h2 id="why-not-webrtc">Why not WebRTC?</h2>
<p>I wouldn’t be writing this blog post if WebRTC was perfect.
The core issue is that WebRTC is not a protocol; it’s a monolith.</p>
<p>WebRTC does a lot of things, let’s break down it down piece by piece:</p>
<ul>
<li><a href="#media">Media</a>: a full capture/encoding/networking/rendering pipeline.</li>
<li><a href="#data">Data</a>: reliable/unreliable messages.</li>
<li><a href="#p2p">P2P</a>: peer-to-peer connectability.</li>
<li><a href="#sfu">SFU</a>: a relay that selectively forwards media.</li>
</ul>
<h3 id="media">Media</h3>
<p>The WebRTC media stack is designed for conferencing and does an amazing job at it.
The problems start when you try to use it for anything else.</p>
<p>My final project at Twitch was to reduce latency by replacing HLS with WebRTC for delivery.
This seems like a no-brainer at first, but it quickly turned into <a href="https://docs.google.com/document/d/1OTnJunbpSJchdj8XI3GU9Fo-RUUFBqLO1AhlaKk5Alo/edit?usp=sharing">death by a thousand cuts</a>.
The biggest issue was that the user experience was just terrible.
Twitch doesn’t need the same aggressive latency as Google Meet, but WebRTC is hard-coded to compromise on quality.</p>
<p>In general, it’s quite difficult to customize WebRTC outside of a few configurable modes.
It’s a black box that you turn on, and if it works it works.
And if it doesn’t work, then you have to deal with the pain that is <a href="https://github.com/webrtc-sdk/libwebrtc">forking libwebrtc</a>… or just hope Google fixes it for you.</p>
<p>The protocol has some wiggle room and I really enjoyed my time tinkering with <a href="https://github.com/pion/webrtc">pion</a>.
But you’re ultimately bound by the browser implementation, unless you don’t need web support, in which case you don’t need WebRTC.</p>
<h3 id="data">Data</h3>
<p>WebRTC also has a data channel API, which is particularly useful because <a href="#webtransport">until recently</a>, it’s been the only way to send/receive “unreliable” messages from a browser.
In fact, many companies use WebRTC data channels to avoid the WebRTC media stack (ex. Zoom).</p>
<p>I went down this path too, attempting to send each video frame as an unreliable message, but it didn’t work due to fundamental flaws with <a href="https://www.rfc-editor.org/rfc/rfc9260.html">SCTP</a>.
I won’t go into the detail in this post, but I eventually hacked “datagram” support into SCTP by breaking frames into unreliable messages below the MTU size.</p>
<p>Finally! UDP* in the browser, but at what cost:</p>
<ul>
<li>a convoluted handshake that takes at least 10 (!) round trips.</li>
<li>2x the packets, because libsctp immediately ACKs every “datagram”.</li>
<li>a custom SCTP implementation, which means the browser can’t send “datagrams”.</li>
</ul>
<p>Oof.</p>
<h3 id="p2p">P2P</h3>
<p>The best and worst part about WebRTC is that it supports peer-to-peer.</p>
<p>The <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Connectivity">ICE handshake</a> is extremely complicated, even from the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling">application’s point of view</a>.
Without going into detail, there’s an explosion of permutations that you need to handle based on the network topology.
Some networks block P2P (ex. symmetric NATs) while others outright block UDP, forcing you to use a TURN server a <a href="https://twitter.com/HCornflower/status/894600051506515968">non-insignificant amount of time</a>.</p>
<p>Most conferencing solutions are client-server anyway, relying on their own private network instead of public transit (aka a CDN).
However the server is still forced to perform the complicated ICE handshake which has major architecture ramifications, but I’ll save that for another blog post.</p>
<p>Note that there are rumblings of <a href="https://w3c.github.io/p2p-webtransport/">P2P WebTransport</a> and <a href="https://datatracker.ietf.org/doc/draft-seemann-quic-nat-traversal/">P2P QUIC</a>, but I wouldn’t hold my breath.</p>
<h3 id="sfu">SFU</h3>
<p>Last but not least, WebRTC scales using SFUs (Selective Forwarding Units).</p>
<figure><p><img src="https://thewitchofendor.com/blog/replacing-webrtc/sfu.png" alt="SFU example"/></p><figcaption><p><a href="https://blog.livekit.io/scaling-webrtc-with-distributed-mesh/">Source</a>. Participants send to a central server,
rather than directly to each other.</p></figcaption></figure>
<p>The problem with SFUs is subtle: they’re custom.</p>
<p>It requires a lot of business logic to determine <em>where</em> to forward packets.
A single server like that diagram won’t scale, nor will all of the participants be located in the same geo.
Each SFU needs to be made aware of the network topology and the location of each participant <em>somehow</em>.</p>
<p>Additionally, a good SFU will avoid dropping packets based on dependencies, otherwise you waste bandwidth on undecodable packets.
Unfortunately, determining this requires parsing each RTP packet on a <em>per-codec</em> basis.
For example, here’s a <a href="https://webrtc.googlesource.com/src/+/refs/heads/main/modules/rtp_rtcp/source/video_rtp_depacketizer_h264.cc">h.264 depacketizer</a> for libwebrtc.</p>
<p>But the biggest issue at Twitch was that SFUs share very little in common with CDNs.
One team is optimizing WebRTC, another team is optimizing HTTP, and they’re not talking to each other.</p>
<p>This is why HLS/DASH uses HTTP instead: <strong>economies of scale</strong></p>

<p>Okay enough ranting about what’s wrong, let’s fix it.</p>
<p>First off, <strong>WebRTC is not going anywhere</strong>. It does a fantastic job at what it was designed for: conferencing.
It will take a long time before anything will reach feature/latency parity with WebRTC.</p>
<p>Before you can replace <strong>Web</strong>RTC, you need <strong>Web</strong>Support.
Fortunately, we now have <strong>Web</strong>Codecs and <strong>Web</strong>Transport.</p>
<h2 id="webcodecs">WebCodecs</h2>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebCodecs_API">WebCodecs</a> is a new API for encoding/decoding media in the browser.
It’s remarkably simple:</p>
<ol>
<li>Capture input via <a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API">canvas</a> or a <a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia">media device</a>.</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/VideoEncoder">VideoEncoder</a>: Input raw frames, output encoded frames.</li>
<li>Transfer those frames somehow. (ex. <a href="#webtransport">WebTransport</a>)</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/VideoDecoder">VideoDecoder</a>: Input encoded frames, output raw frames.</li>
<li>Render output via <a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API">canvas</a> or just marvel at the pixel data.</li>
</ol>
<p>The catch is that the application is responsible for all timing.
That means you need to choose when to render each frame via <a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame">requestAnimationFrame</a>.
In fact, you need to choose when to render each audio <em>sample</em> via <a href="https://developer.mozilla.org/en-US/docs/Web/API/AudioWorklet">AudioWorklet</a>.</p>
<p>The upside is that now your web application gets full control of how to render media.
It’s now possible to implement WebRTC-like behavior, like temporarily freezing video and desyncing A/V.</p>
<p>Check <a href="https://caniuse.com/webcodecs">caniuse</a> for current browser support.</p>
<h2 id="webtransport">WebTransport</h2>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebTransport_API">WebTransport</a> is a new API for transmitting data over the network.
Think of it like WebSockets, but with a few key differences:</p>
<ul>
<li><a href="https://www.rfc-editor.org/rfc/rfc9000.html">QUIC</a> not TCP.</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebTransport_API#reliable_transmission_via_streams">Reliable streams</a> that are delivered in order.</li>
<li><strong>Semi-reliable streams</strong> by closing a stream (with an error code) to drop the tail.</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebTransport/datagrams">Unreliable datagrams</a> that may be dropped during congestion.</li>
</ul>
<p>QUIC has too many benefits to enumerate, but some highlights:</p>
<ul>
<li>Fully encrypted</li>
<li>Congestion controlled (even datagrams)</li>
<li>Independent streams (no head-of-line blocking)</li>
<li>1-RTT handshake</li>
<li>Multiplexed over a single UDP port</li>
<li>Transparent network migration (ex. switching from Wifi to LTE)</li>
<li>Used for HTTP/3</li>
</ul>
<p>That last one is surprisingly important: WebTransport will share all of the optimizations that HTTP/3 receives.
A HTTP/3 server can simultaneously serve multiple WebTransport sessions and HTTP requests over the same connection.</p>
<p>Check <a href="https://caniuse.com/webtransport">caniuse</a> for current browser support.
Use my <a href="https://docs.rs/webtransport-quinn/latest/webtransport_quinn/">Rust library</a> for servers and native clients!</p>
<h2 id="but-how">But how?</h2>
<p>Okay, so we have WebCodecs and WebTransport, but are they actually useful?</p>
<p>I alluded to the secret behind latency earlier: avoiding queues.
Queuing can occur at any point in the media pipeline.</p>















<table><thead><tr><th>Capture/Encode</th><th>Send/Receive</th><th>Decode/Render</th></tr></thead><tbody><tr><td>—&gt;</td><td>—&gt;</td><td>—&gt;</td></tr></tbody></table>
<p>Let’s start with the easy one.
<a href="#webcodecs">WebCodecs</a> allows you to avoid queuing almost entirely.</p>















<table><thead><tr><th>Capture/Encode</th><th>Send/Receive</th><th>Decode/Render</th></tr></thead><tbody><tr><td><strong>WebCodecs</strong></td><td>?</td><td><strong>WebCodecs</strong></td></tr></tbody></table>
<p>The tricky part is the bit in the middle, the network.
It’s not as simple as throwing your hands into the air and proclaiming “UDP has no queues!”</p>
<h3 id="the-internet-of-queues">The Internet of Queues</h3>
<p>The internet is a <a href="https://en.wikipedia.org/wiki/Series_of_tubes">series of tubes</a>.
You put packets in one end and they eventually come out of the other end, kinda.
This section will get an entire blog post in the future, but until then, let’s over-simplify things.</p>
<p>Every packet you send will fight with other packets on the internet.</p>
<ul>
<li>If routers have sufficient throughput, <strong>packets arrive on time</strong>.</li>
<li>If routers have limited throughput, <strong>packets will be queued</strong>.</li>
<li>If those queues are full, <strong>packets will be dropped</strong>.</li>
</ul>
<p>There can be random packet loss, but 99% of the time we care about loss due to queuing.
Note that even datagrams may be queued by the network; a firehose of packets is never the answer.</p>
<h3 id="detecting-queuing">Detecting Queuing</h3>
<p>The goal of congestion control is to detect queuing and back off.</p>
<p>Different congestion control algorithms use different signals to detect queuing.
This is a gross oversimplification of a topic with an immense amount of research, but here’s a rough breakdown:</p>



































<table><thead><tr><th>Signal</th><th>Description</th><th>Latency</th><th>Examples</th></tr></thead><tbody><tr><td>Packet Loss</td><td>Wait until the queue is full and packets are dropped.</td><td><a href="https://en.wikipedia.org/wiki/Bufferbloat">High</a></td><td><a href="https://en.wikipedia.org/wiki/TCP_congestion_control">Reno</a>, <a href="https://en.wikipedia.org/wiki/CUBIC_TCP">CUBIC</a></td></tr><tr><td>ACK Delay</td><td>Indirectly measure the queue size via ACK RTT.</td><td>Medium</td><td><a href="https://research.google/pubs/pub45646/">BBR</a>, <a href="https://web.mit.edu/copa/">COPA</a></td></tr><tr><td>Packet Delay</td><td>Indirectly measure the queue size via packet RTT.</td><td>Low</td><td><a href="https://datatracker.ietf.org/doc/html/draft-ietf-rmcat-gcc-02">GCC</a>, <a href="https://github.com/EricssonResearch/scream">SCReAM</a></td></tr><tr><td>ECN</td><td>Get told by the router to back off.</td><td>None*</td><td><a href="https://datatracker.ietf.org/doc/rfc9330/">L4S</a></td></tr></tbody></table>
<p>There’s no single “best” congestion control algorithm; it depends on your use-case, network, and target latency.
But this is one area where WebRTC has an advantage thanks to <a href="https://webrtc.googlesource.com/src/+/refs/heads/main/docs/native-code/rtp-hdrext/transport-wide-cc-02/README.md">transport-wide-cc</a>.</p>
<h3 id="reducing-bitrate">Reducing Bitrate</h3>
<p>Once you detect queuing, the application needs to send fewer bytes.</p>
<p>In some situations we can just reduce the encoder bitrate, however:</p>
<ul>
<li>This only applies to future frames.</li>
<li>We don’t want one viewer to degrade the experience for all.</li>
<li>It’s too expensive to encode on a per-viewer basis.</li>
</ul>
<p>So basically, we have to drop encoded media in response to congestion.</p>
<p>This is the fundamental problem with TCP.
Once you queue data on a TCP socket, it can’t be undone without closing the connection.
You can’t put the toothpaste back in the tube.</p>
<figure><p><img src="https://thewitchofendor.com/blog/replacing-webrtc/toothpaste.jpg" alt="TCP toothpaste"/></p><figcaption><p><a href="https://knowyourmeme.com/memes/shitting-toothpaste-pooping-toothpaste">Source</a>. You earned a meme for making it
this far.</p></figcaption></figure>
<p>However, there are actually quite a few ways of dropping media with <a href="#webtransport">WebTransport</a>:</p>
<ol>
<li>Use datagrams and choose which packets to transmit. (like WebRTC)</li>
<li>Use QUIC streams and close them to stop transmissions. (like <a href="https://www.ietf.org/archive/id/draft-kpugin-rush-00.html">RUSH</a>)</li>
<li>Use QUIC streams and prioritize them. (like <a href="https://www.youtube.com/watch?v=PncdrMPVaNc">Warp</a>)</li>
</ol>
<p>I’m biased because I made the 3rd one.
WebTransport’s <a href="https://www.w3.org/TR/webtransport/#dom-webtransportsendstreamoptions-sendorder">sendOrder</a> can be used to instruct the QUIC stack what should be sent during congestion.
But that deserves an entire blog post on its own.</p>

<p>But to actually replace WebRTC, we need a standard. Anybody can make their own UDP-based protocol (<em>and they do</em>), using this new web tech (<em>and they will</em>).</p>
<p>What sets <a href="https://datatracker.ietf.org/wg/moq/about/">Media over QUIC</a> apart is that we’re doing it through the IETF, the same organization that standardized WebRTC… and virtually every internet protocol.</p>
<p>It’s going to take years.</p>
<p>And there are major flaws with both <strong>WebCodecs</strong> and <strong>WebTransport</strong> that still need to be addressed before we’ll ever reach WebRTC parity.
To name a few:</p>
<ul>
<li>We need better <a href="https://www.w3.org/TR/webtransport/#dom-webtransportoptions-congestioncontrol">congestion control</a> in browsers.</li>
<li>We need something like <a href="https://webrtc.googlesource.com/src/+/refs/heads/main/docs/native-code/rtp-hdrext/transport-wide-cc-02/README.md">transport-wide-cc</a> in QUIC: <a href="https://www.ietf.org/archive/id/draft-smith-quic-receive-ts-00.html">like this proposal</a></li>
<li>We need echo cancellation in <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API">WebAudio</a>, which might be possible?</li>
<li>We may need <a href="https://en.wikipedia.org/wiki/Error_correction_code#Forward_error_correction">FEC</a> in QUIC: <a href="https://datatracker.ietf.org/doc/draft-michel-quic-fec/">like this proposal</a></li>
<li>We may need more encoding options, like non-reference frames or SVC.</li>
<li>Oh yeah and full browser support: <a href="https://caniuse.com/webcodecs">WebCodecs</a> - <a href="https://caniuse.com/webtransport">WebTransport</a></li>
</ul>
<h2 id="so-yeah">So yeah…</h2>
<p>Written by <a href="https://github.com/kixelated">@kixelated</a>.
Hit me up on <a href="https://discord.gg/FCYF3p99mr">Discord</a> if you want to help!</p>
<p>Tune in for next week’s episode: <strong>Replacing HLS/DASH</strong> and then <strong>Replacing RTMP</strong>.</p>
<img src="https://thewitchofendor.com/blog/kixelCat.png"/></article></div>
  </body>
</html>
