<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lupyuen.codeberg.page/articles/nim.html">Original</a>
    <h1>Nim on a Real-Time Operating System: Apache NuttX RTOS and Ox64 BL808 SBC</h1>
    
    <div id="readability-page-1" class="page">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    
    
    
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    
    <nav id="TOC"><ul>
<li><a href="#basic-nim-from-scratch">1 Basic Nim from scratch</a><ul></ul></li>
<li><a href="#blink-an-led">2 Blink an LED</a><ul></ul></li>
<li><a href="#import-nuttx-functions">3 Import NuttX Functions</a><ul></ul></li>
<li><a href="#run-nim-on-qemu">4 Run Nim on QEMU</a><ul></ul></li>
<li><a href="#nim-blinky-on-ox64">5 Nim Blinky on Ox64</a><ul></ul></li>
<li><a href="#inside-nim-on-nuttx">6 Inside Nim on NuttX</a><ul></ul></li>
<li><a href="#led-driver-for-ox64">7 LED Driver for Ox64</a><ul></ul></li>
<li><a href="#whats-next">8 What‚Äôs Next</a><ul></ul></li>
<li><a href="#appendix-build-nuttx-for-qemu">9 Appendix: Build NuttX for QEMU</a><ul></ul></li>
<li><a href="#appendix-build-nuttx-for-ox64">10 Appendix: Build NuttX for Ox64</a><ul></ul></li>
<li><a href="#appendix-opensbi-timer-for-nuttx">11 Appendix: OpenSBI Timer for NuttX</a><ul></ul></li></ul></nav><p>üìù <em>1 Jan 2024</em></p>
<p><img src="https://lupyuen.codeberg.page/images/nim-ox64.png" alt="Apache NuttX RTOS on Ox64 BL808 RISC-V SBC: Works great with Nim!"/></p>
<p>Happy New Year! 2024 is here and we‚Äôre running <a href="https://www.hackster.io/lupyuen/8-risc-v-sbc-on-a-real-time-operating-system-ox64-nuttx-474358"><strong>Apache NuttX RTOS</strong></a> (Real-Time Operating System) on Single-Board Computers with <strong>plenty of RAM</strong>‚Ä¶</p>
<p>Like <a href="https://wiki.pine64.org/wiki/Ox64"><strong>Pine64 Ox64 BL808</strong></a> RISC-V SBC with <strong>64 MB RAM!</strong> (Pic below)</p>
<p><em>How will we use the Plentiful RAM?</em></p>
<p>In this article, we create a <strong>Blinky LED</strong> app with a Modern, Garbage-Collected Language: <a href="https://nim-lang.org"><strong>Nim Programming Language</strong></a>.</p>
<p><a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)"><strong>Garbage-Collected</strong></a> Languages (like Nim) require <a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)#Disadvantages"><strong>a bit more RAM</strong></a> than Low-Level Languages (like C). Perfect for our roomy (and vroomy) SBC!</p>
<p><a href="https://youtube.com/shorts/KCkiXFxBgxQ">(Watch the <strong>Demo on YouTube</strong>)</a></p>
<p><em>But we need a RISC-V SBC?</em></p>
<p>No worries! We‚Äôll run Nim + NuttX on the <strong>QEMU Emulator</strong> for 64-bit RISC-V. Which works great on Linux, macOS and Windows machines.</p>
<p>Everything that happens on Ox64 SBC, we‚Äôll see the <strong>exact same thing</strong> in QEMU!</p>
<p><a href="https://lupyuen.codeberg.page/images/nim-blink.jpg">(Except the <strong>blinkenlight</strong>)</a></p>
<p><em>Hmmm Garbage Collection‚Ä¶ Won‚Äôt it jitter: run-pause-run-pause?</em></p>
<p>The fine folks at <a href="https://www.wildernesslabs.co/"><strong>Wilderness Labs</strong></a> are running <a href="https://www.wildernesslabs.co/developers"><strong>.NET on NuttX</strong></a> with Garbage Collection. <a href="https://nim-lang.org/blog/2022/11/11/a-cost-model-for-nim.html"><strong>Optimising for performance</strong></a> really helps!</p>
<p><a href="https://www.mdpi.com/2079-9292/12/1/143">(See <strong>TinyGo</strong> and <strong>MicroPython</strong>)</a></p>
<p><em>How is Nim different from Rust and Zig?</em></p>
<p>We‚Äôve tested <a href="https://lupyuen.codeberg.page/articles/rusti2c"><strong>Rust on NuttX</strong></a> and <a href="https://lupyuen.codeberg.page/articles/lvgl4"><strong>Zig on NuttX</strong></a>. <strong>Nim is different</strong> because it‚Ä¶</p>
<ul>
<li>
<p><strong>Compiles to C</strong> (instead of Machine Code)</p>
</li>
<li>
<p>Syntax is <strong>Python-like</strong> (but Statically Compiled)</p>
</li>
<li>
<p>Automatic <strong>Garbage Collection</strong> (no Borrow Checker)</p>
</li>
<li>
<p>And it‚Äôs <a href="https://nim-lang.org/faq.html"><strong>Memory Safe</strong></a> (like Rust)</p>
</li>
</ul>
<p>First we say hello to Nim‚Ä¶</p>
<p><img src="https://lupyuen.codeberg.page/images/ox64-solder.jpg" alt="Pine64 Ox64 64-bit RISC-V SBC (Sorry for my substandard soldering)"/></p>

<p><em>(3 languages in a title heh heh)</em></p>
<p>This is the <strong>simplest Nim Program</strong> that will run on NuttX: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/nim/examples/hello_nim/hello_nim_async.nim#L54-L63">hello_nim_async.nim</a></p>
<div><pre><code>## Main Function in Nim.
## Will be called by NuttX, so we export to C.
proc hello_nim() {.exportc, cdecl.} =

  ## Print something
  echo &#34;Hello Nim!&#34;

  ## Force the Garbage Collection
  GC_runOrc()
</code></pre></div>
<p>Which looks a lot like Python!</p>
<p><em>What‚Äôs GC_runOrc?</em></p>
<p>Our Nim Program will be <strong>called by C</strong>. (Remember NuttX?)</p>
<p>And Nim works with <a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)"><strong>Garbage Collection</strong></a>. Thus we call <a href="https://nim-lang.org/blog/2022/11/11/a-cost-model-for-nim.html"><strong>GC_runOrc</strong></a> to‚Ä¶</p>
<ul>
<li>
<p>Force the Garbage Collection to complete</p>
</li>
<li>
<p>Clean up all remaining Nim Objects</p>
</li>
<li>
<p>Then return to C and NuttX</p>
</li>
</ul>
<p><em>What if we forget to call GC_runOrc?</em></p>
<p>Erm don‚Äôt! To make it unforgettable, we <a href="https://nim-lang.org/docs/manual.html#exception-handling-defer-statement"><strong><code>defer</code></strong></a> the Garbage Collection: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/nim/examples/hello_nim/hello_nim_async.nim#L54-L63">hello_nim_async.nim</a></p>
<div><pre><code>## Main Function in Nim
proc hello_nim() {.exportc, cdecl.} =

  ## On Return: Force the Garbage Collection
  defer: GC_runOrc()

  ## Print something
  echo &#34;Hello Nim!&#34;
</code></pre></div>
<p><a href="https://nim-lang.org/docs/manual.html#exception-handling-defer-statement"><strong><code>defer</code></strong></a> ensures that the Garbage Collection <strong>will always happen</strong>, as soon as we return from the Main Function.</p>
<p>Now we do something cool and enlightening‚Ä¶</p>
<p>(<a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/nim/examples/hello_nim/hello_nim_async.nim#L54-L67"><strong>hello_nim</strong></a> is called by our C Program <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/nim/examples/hello_nim/hello_nim_main.c#L35-L42"><strong>hello_nim_main.c</strong></a>)</p>
<p><img src="https://lupyuen.codeberg.page/images/nim-code.jpg" alt="Blink an LED with Nim"/></p>

<p>This is how we <strong>blink an LED</strong> with Nim on NuttX: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/nim/examples/hello_nim/hello_nim_async.nim#L19-L50">hello_nim_async.nim</a></p>
<div><pre><code>## Blink the LED
proc blink_led() =

  ## Open the LED Driver
  echo &#34;Opening /dev/userleds&#34;
  let fd = c_open(&#34;/dev/userleds&#34;, O_WRONLY)

  ## Check the File Descriptor for error
  if fd &lt; 0:
    echo &#34;Failed to open /dev/userleds&#34;
    return
</code></pre></div>
<p>First we call the NuttX Function <strong><code>open</code></strong> to access the <strong>LED Driver</strong>.</p>
<p>We might forget to <strong><code>close</code></strong> the LED Driver (in case of error), so we <a href="https://nim-lang.org/docs/manual.html#exception-handling-defer-statement"><strong><code>defer</code></strong></a> the closing‚Ä¶</p>
<div><pre><code>  ## On Return: Close the LED Driver
  defer: c_close(fd)
</code></pre></div>
<p>Next we call the NuttX Function <strong><code>ioctl</code></strong> to flip <strong>LED 0 to On</strong>‚Ä¶</p>
<div><pre><code>  ## Turn on LED
  echo &#34;Set LED 0 to 1&#34;
  var ret = c_ioctl(fd, ULEDIOC_SETALL, 1)
  if ret &lt; 0:
    echo &#34;ioctl(ULEDIOC_SETALL) failed&#34;
    return
</code></pre></div>
<p><a href="https://github.com/apache/nuttx/blob/master/include/nuttx/leds/userled.h#L57-L66"><strong>ULEDIOC_SETALL</strong></a> accepts a Bit Mask of LED States. The value <strong><code>1</code></strong> says that <strong>LED 0</strong> (Bit 0) will be flipped On.</p>
<p>(Other LEDs will be flipped Off)</p>
<p>We <strong>pause a while</strong>‚Ä¶</p>
<div><pre><code>  ## Wait a second (literally)
  ## Because 1 million microseconds = 1 second
  echo &#34;Waiting...&#34;
  c_usleep(1000_000)
</code></pre></div>
<p>Finally we flip <strong>LED 0 to Off</strong>‚Ä¶</p>
<div><pre><code>  ## Turn off LED
  echo &#34;Set LED 0 to 0&#34;
  ret = c_ioctl(fd, ULEDIOC_SETALL, 0)
  if ret &lt; 0:
    echo &#34;ioctl(ULEDIOC_SETALL) failed&#34;
    return

  ## Wait again
  echo &#34;Waiting...&#34;
  c_usleep(1000_000)
</code></pre></div>
<p>In our <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/nim/examples/hello_nim/hello_nim_async.nim#L54-L67"><strong>Main Function</strong></a>: We call the above function <strong>20 times</strong> to blink our LED (pic below)‚Ä¶</p>
<div><pre><code>## Main Function in Nim
proc hello_nim() {.exportc, cdecl.} =

  ## On Return: Force the Garbage Collection
  defer: GC_runOrc()

  ## Blink the LED 20 times
  for loop in 0..19:
    blink_led()
</code></pre></div>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/nim/examples/hello/hello_main.c#L40-L85">(Looks mighty similar to the <strong>C Version</strong>)</a></p>
<p>And we‚Äôre almost done! Nim needs to discover our NuttX Functions‚Ä¶</p>
<p><img src="https://lupyuen.codeberg.page/images/nim-blink2.jpg" alt="Apache NuttX RTOS on Ox64 BL808 RISC-V SBC: Nim blinks our LED"/></p>

<p><em>How will Nim know about open, close, ioctl, usleep?</em></p>
<p>We <strong>import the NuttX Functions</strong> from C into Nim: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/nim/examples/hello_nim/hello_nim_async.nim#L1-L19">hello_nim_async.nim</a></p>
<div><pre><code>## Import NuttX Functions from C.
## Based on https://github.com/nim-lang/Nim/blob/devel/lib/std/syncio.nim

proc c_open(filename: cstring, mode: cint): cint {.
  importc: &#34;open&#34;,
  header: &#34;&lt;fcntl.h&gt;&#34;.}

proc c_close(fd: cint): cint {.
  importc: &#34;close&#34;,
  header: &#34;&lt;fcntl.h&gt;&#34;,
  discardable.}

proc c_ioctl(fd: cint, request: cint): cint {.
  importc: &#34;ioctl&#34;,
  header: &#34;&lt;sys/ioctl.h&gt;&#34;,
  varargs.}

proc c_usleep(usec: cuint): cint {.
  importc: &#34;usleep&#34;,
  header: &#34;&lt;unistd.h&gt;&#34;,
  discardable.}
</code></pre></div>
<p><a href="https://nim-lang.org/docs/manual.html#statements-and-expressions-discard-statement">(<strong>discardable</strong> tells Nim Compiler that the Return Value is Optional)</a></p>
<p>We do the same for <strong>NuttX Macros</strong>‚Ä¶</p>
<div><pre><code>## Import NuttX Macros from C.
## Based on https://github.com/nim-lang/Nim/blob/devel/lib/std/syncio.nim

var O_WRONLY {.
  importc: &#34;O_WRONLY&#34;, 
  header: &#34;&lt;fcntl.h&gt;&#34;.}: cint

var ULEDIOC_SETALL {.
  importc: &#34;ULEDIOC_SETALL&#34;, 
  header: &#34;&lt;nuttx/leds/userled.h&gt;&#34;.}: cint
</code></pre></div>
<p>We‚Äôre ready to run this!</p>
<p><img src="https://lupyuen.codeberg.page/images/nim-qemu.png" alt="Nim with Apache NuttX RTOS on QEMU RISC-V (64-bit)"/></p>

<p><em>How to run Nim Blinky on QEMU Emulator?</em></p>
<p>We begin by <strong>booting NuttX RTOS</strong> on RISC-V QEMU Emulator (64-bit)‚Ä¶</p>
<ol>
<li>
<p>Install <a href="https://www.qemu.org/download/"><strong>QEMU Emulator for RISC-V (64-bit)</strong></a>‚Ä¶</p>
<div><pre><code>## For macOS:
brew install qemu

## For Debian and Ubuntu:
sudo apt install qemu-system-riscv64
</code></pre></div></li>
<li>
<p>Download <strong><code>nuttx</code></strong> from the <a href="https://github.com/lupyuen/nuttx-nim/releases/tag/qemu-1"><strong>NuttX Release</strong></a>‚Ä¶</p>
<p><a href="https://github.com/lupyuen/nuttx-nim/releases/download/qemu-1/nuttx"><strong>nuttx: NuttX Image for 64-bit RISC-V QEMU</strong></a></p>
<p>If we prefer to <strong>build NuttX</strong> ourselves: <a href="https://lupyuen.codeberg.page/articles/nim#appendix-build-nuttx-for-qemu"><strong>Follow these steps</strong></a></p>
</li>
<li>
<p>Start the <strong>QEMU RISC-V Emulator</strong> (64-bit) with NuttX RTOS‚Ä¶</p>
<div><pre><code>qemu-system-riscv64 \
  -semihosting \
  -M virt,aclint=on \
  -cpu rv64 \
  -smp 8 \
  -bios none \
  -kernel nuttx \
  -nographic
</code></pre></div>
<p><a href="https://lupyuen.codeberg.page/articles/riscv#qemu-emulator-for-risc-v">(About the <strong>QEMU Options</strong>)</a></p>
</li>
<li>
<p>NuttX is now running in the <strong>QEMU Emulator</strong>! (Pic above)</p>
<div><pre><code>NuttShell (NSH) NuttX-12.0.3
nsh&gt;
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/09e653cbd227b9cdff7cf3cb0a5e1ffa#file-qemu-nuttx-nim-build-log-L199-L208">(See the <strong>Complete Log</strong>)</a></p>
</li>
<li>
<p>At the NuttX Prompt, enter ‚Äú<strong>hello_nim</strong>‚Äù‚Ä¶</p>
<div><pre><code>nsh&gt; hello_nim
Hello Nim!
Opening /dev/userleds
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/09e653cbd227b9cdff7cf3cb0a5e1ffa#file-qemu-nuttx-nim-build-log-L472-L497">(Enter ‚Äú<strong>help</strong>‚Äù to see the available commands)</a></p>
</li>
<li>
<p>Nim on NuttX blinks our <strong>Simulated LED</strong>‚Ä¶</p>
<div><pre><code>Set LED 0 to 1
board_userled_all: led=0, val=1
Waiting...

Set LED 0 to 0
board_userled_all: led=0, val=0
Waiting...

Set LED 0 to 1
board_userled_all: led=0, val=1
Waiting...
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/09e653cbd227b9cdff7cf3cb0a5e1ffa#file-qemu-nuttx-nim-build-log-L210-L471">(See the <strong>Complete Log</strong>)</a></p>
</li>
<li>
<p>To Exit QEMU: Press <strong><code>Ctrl-A</code></strong> then <strong><code>x</code></strong></p>
</li>
</ol>
<p>Now we step out from the Virtual World into the Real World (like ‚ÄúThe Matrix‚Äù)‚Ä¶</p>
<p><img src="https://lupyuen.codeberg.page/images/nim-wiring.jpg" alt="Connect an LED to Ox64 SBC at GPIO 29, Pin 21"/></p>

<p><em>Will Nim Blinky run on a real RISC-V SBC?</em></p>
<p>Yep! Connect an LED to Ox64 SBC at <strong>GPIO 29, Pin 21</strong> (pic above)‚Ä¶</p>
<div><table><thead><tr><th>Connect</th><th>To</th><th>Wire</th></tr></thead><tbody>
<tr><td><strong>Ox64 Pin 21</strong> </td><td><strong>Resistor</strong> </td><td>Red</td></tr>
<tr><td><strong>Resistor</strong> </td><td><strong>LED +</strong> </td><td>Breadboard</td></tr>
<tr><td><strong>LED -</strong> </td><td><strong>Ox64 Pin 23</strong> </td><td>Black</td></tr>
</tbody></table>
</div>
<p><a href="https://wiki.pine64.org/wiki/File:Ox64_pinout.png">(See the <strong>Ox64 Pinout</strong>)</a></p>
<p>(Resistor is <strong>47 Ohm</strong>, yellow-purple-black-gold, almost Karma Chameleon)</p>
<p>Follow these steps to <strong>boot NuttX RTOS</strong> on our Ox64 BL808 SBC‚Ä¶</p>
<ol>
<li>
<p>Flash <a href="https://lupyuen.codeberg.page/articles/ox64#flash-opensbi-and-u-boot"><strong>OpenSBI and U-Boot Bootloader</strong></a> to Ox64</p>
</li>
<li>
<p>Prepare a <strong>Linux microSD</strong> for Ox64 as described <a href="https://lupyuen.codeberg.page/articles/ox64"><strong>in the previous article</strong></a></p>
</li>
<li>
<p>Download <strong><code>Image</code></strong> from the <a href="https://github.com/lupyuen/nuttx-nim/releases/tag/ox64-1"><strong>NuttX Release</strong></a>‚Ä¶</p>
<p><a href="https://github.com/lupyuen/nuttx-nim/releases/download/ox64-1/Image"><strong>Image: NuttX Image for Ox64 BL808 SBC</strong></a></p>
<p>If we prefer to <strong>build NuttX</strong> ourselves: <a href="https://lupyuen.codeberg.page/articles/nim#appendix-build-nuttx-for-ox64"><strong>Follow these steps</strong></a></p>
</li>
<li>
<p>Copy the <strong><code>Image</code></strong> file and overwrite the <strong><code>Image</code></strong> in the Linux microSD</p>
</li>
<li>
<p>Insert the <a href="https://lupyuen.codeberg.page/images/ox64-sd.jpg"><strong>microSD into Ox64</strong></a> and power up Ox64</p>
</li>
<li>
<p>NuttX is now running on our <strong>Ox64 SBC</strong>! (Pic below)</p>
<div><pre><code>Starting kernel...
NuttShell (NSH) NuttX-12.0.3
nsh&gt;
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/553c2da4ad5d119468d223e162573e96#file-ox64-nuttx-nim-blink-log-L112-L125">(See the <strong>Complete Log</strong>)</a></p>
</li>
<li>
<p>At the NuttX Prompt, enter ‚Äú<strong>hello_nim</strong>‚Äù‚Ä¶</p>
<div><pre><code>nsh&gt; hello_nim
Hello Nim!
Opening /dev/userleds
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/09e653cbd227b9cdff7cf3cb0a5e1ffa#file-qemu-nuttx-nim-build-log-L472-L497">(Enter ‚Äú<strong>help</strong>‚Äù to see the available commands)</a></p>
</li>
<li>
<p>Nim on NuttX <a href="https://lupyuen.codeberg.page/images/nim-blink.jpg"><strong>blinks our LED</strong></a>‚Ä¶</p>
<div><pre><code>Set LED 0 to 1
board_userled_all: led=0, val=1
Waiting...

Set LED 0 to 0
board_userled_all: led=0, val=0
Waiting...

Set LED 0 to 1
board_userled_all: led=0, val=1
Waiting...
</code></pre></div>
<p><a href="https://youtube.com/shorts/KCkiXFxBgxQ">(Watch the <strong>Demo on YouTube</strong>)</a></p>
<p><a href="https://gist.github.com/lupyuen/553c2da4ad5d119468d223e162573e96#file-ox64-nuttx-nim-blink-log-L129-L395">(See the <strong>Complete Log</strong>)</a></p>
</li>
</ol>
<p>Nim blinks a real LED on a real RISC-V SBC! Let‚Äôs figure out how it works‚Ä¶</p>
<p><img src="https://lupyuen.codeberg.page/images/nim-ox64.png" alt="Apache NuttX RTOS on Ox64 BL808 RISC-V SBC: Works great with Nim!"/></p>

<p><em>Nim runs incredibly well on NuttX. How is that possible?</em></p>
<p>That‚Äôs because <strong>Nim compiles to C</strong>. As far as NuttX is concerned‚Ä¶</p>
<p>Nim looks like <strong>any other C Program!</strong></p>
<p><em>Whoa! How is Nim compiled to C?</em></p>
<p>Our <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/nim/examples/hello_nim/Makefile#L37-L41"><strong>NuttX Makefile</strong></a> calls the Nim Compiler‚Ä¶</p>
<div><pre><code>## Compile Nim to C
export TOPDIR=$PWD/nuttx
cd apps/examples/hello_nim
nim c --header hello_nim_async.nim 
</code></pre></div>
<p>Nim Compiler compiles our <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/nim/examples/hello_nim/hello_nim_async.nim#L54-L63"><strong>Nim Program</strong></a>‚Ä¶</p>
<div><pre><code>## Nim Program that prints something
proc hello_nim() {.exportc, cdecl.} =
  echo &#34;Hello Nim!&#34;
</code></pre></div>
<p>Into this <a href="https://gist.github.com/lupyuen/4d3f44b58fa88b17ca851decb0419b86#file-mhello_nim_async-nim-c-L198-L203"><strong>C Program</strong></a>‚Ä¶</p>
<div><pre><code>// Main Function compiled from Nim to C:
// echo &#34;Hello Nim!&#34;
N_LIB_PRIVATE N_CDECL(void, hello_nim)(void) {
  ...
  // `echo` comes from the Nim System Library
  // https://github.com/nim-lang/Nim/blob/devel/lib/system.nim#L2849-L2902
  echoBinSafe(TM__1vqzGCGyH8jPEpAwiaNwvg_2, 1);
  ...
}

// String &#34;Hello Nim!&#34; compiled from Nim to C
static NIM_CONST tyArray__nHXaesL0DJZHyVS07ARPRA TM__1vqzGCGyH8jPEpAwiaNwvg_2 
  = {{10, (NimStrPayload*)&amp;TM__1vqzGCGyH8jPEpAwiaNwvg_3}};

// Actual String for &#34;Hello Nim!&#34;
static const struct { NI cap; NIM_CHAR data[10+1]; } TM__1vqzGCGyH8jPEpAwiaNwvg_3 
  = { 10 | NIM_STRLIT_FLAG, &#34;Hello Nim!&#34; };
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/4d3f44b58fa88b17ca851decb0419b86#file-mhello_nim_async-nim-c-L198-L203">(From .nimcache/@mhello_nim_async.nim.c)</a></p>
<p><a href="https://github.com/lupyuen/nuttx-nim/releases/download/ox64-1/nimcache.tar">(See the <strong>nimcache</strong>)</a></p>
<p>Hence Nim Compiler has produced a <a href="https://gist.github.com/lupyuen/4d3f44b58fa88b17ca851decb0419b86#file-mhello_nim_async-nim-c-L198-L203"><strong>perfectly valid C Program</strong></a>. That will compile with any C Compiler!</p>
<p><em>How will NuttX compile this?</em></p>
<p>Nim Compiler generates the code above into the <a href="https://github.com/lupyuen/nuttx-nim/releases/download/ox64-1/nimcache.tar"><strong><code>.nimcache</code></strong></a> folder.</p>
<p>Our <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/nim/examples/hello_nim/Makefile#L31-L35"><strong>NuttX Makefile</strong></a> compiles everything inside <a href="https://github.com/lupyuen/nuttx-nim/releases/download/ox64-1/nimcache.tar"><strong><code>.nimcache</code></strong></a> with the GCC Compiler‚Ä¶</p>
<div><pre><code>## Compile everything in the .nimcache folder
NIMPATH = $(shell choosenim show path)
CFLAGS += -I $(NIMPATH)/lib -I ../../.nimcache
CSRCS  += $(wildcard ../../.nimcache/*.c)
</code></pre></div>
<p>And links the Nim Modules (compiled by GCC) into NuttX.</p>
<p><em>So Nim Compiler is aware of NuttX?</em></p>
<p>Yep! Nim Compiler is internally wired to <strong>produce NuttX Code</strong> (that GCC will compile correctly)‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/nim-lang/Nim/pull/21372/files"><strong>Nim Support for NuttX</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/nim/config.nims"><strong>Nim Configuration for NuttX: config.nims</strong></a></p>
</li>
</ul>
<p>Kudos to <a href="https://github.com/centurysys"><strong>centurysys</strong></a> and the Nim Community for making this possible!</p>
<p><em>Everything is hunky dory with Nim on NuttX?</em></p>
<p>We made some <strong>Minor Fixes</strong>, we‚Äôll upstream to NuttX shortly‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/pull/3/files#diff-7fb4194c7b9e7b17a2a650d4182f39fb0e932cc9bb566e9b580d22fa8a7b4307"><strong>Makefile</strong></a>: Nimcache has moved 2 folders up</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/pull/3/files#diff-be274e89063d9377278fad5fdcdd936e89d2f32efd7eb8eb8a6a83ac4c711879"><strong>config.nims</strong></a>: Add support for 64-bit RISC-V</p>
</li>
</ul>
<p>Here we see the Nim Compiler working perfectly, <a href="https://gist.github.com/lupyuen/09e653cbd227b9cdff7cf3cb0a5e1ffa#file-qemu-nuttx-nim-build-log-L55-L185"><strong>compiling our program</strong></a> for NuttX (by parsing the <a href="https://github.com/lupyuen/nuttx-nim/releases/download/ox64-1/nuttx.config"><strong>NuttX Build Config</strong></a>)‚Ä¶</p>
<div><pre><code>$ export TOPDIR=/workspaces/bookworm/nuttx
$ cd /workspaces/bookworm/apps/examples/hello_nim
$ nim c --header hello_nim_async.nim

read_config: /workspaces/bookworm/nuttx/.config
line=CONFIG_DEBUG_SYMBOLS=y
line=CONFIG_DEBUG_FULLOPT=y
line=CONFIG_ARCH=&#34;risc-v&#34;
@[&#34;keyval=&#34;, &#34;ARCH&#34;, &#34;\&#34;risc-v\&#34;&#34;]
keyval[1]=&#34;risc-v&#34;
line=CONFIG_RAM_SIZE=33554432
* arch:    riscv64
* opt:     oSize
* debug:   true
* ramSize: 33554432
* isSim:   false
Hint: used config file &#39;/home/vscode/.choosenim/toolchains/nim-#devel/config/nim.cfg&#39; [Conf]
Hint: used config file &#39;/home/vscode/.choosenim/toolchains/nim-#devel/config/config.nims&#39; [Conf]
Hint: used config file &#39;/workspaces/bookworm/apps/config.nims&#39; [Conf]
....................................................................................................................................
Hint: mm: orc; opt: size; options: -d:danger
92931 lines; 1.214s; 137.633MiB peakmem; proj: /workspaces/bookworm/apps/examples/hello_nim/hello_nim_async.nim; out: /workspaces/bookworm/apps/.nimcache/hello_nim_async.json [SuccessX]
</code></pre></div>
<p><em>Isn‚Äôt Nim supposed to be Memory Safe?</em></p>
<p>Yeah so far we‚Äôre doing Low-Level Coding with NuttX. And the <a href="https://nim-lang.org/faq.html"><strong>Nim Memory Safety</strong></a> doesn‚Äôt shine through.</p>
<p>Later when we write <strong>LVGL Graphical Apps</strong> in Nim, we‚Äôll appreciate the <a href="https://github.com/mantielero/lvgl.nim/blob/main/examples/ex02_label.nim"><strong>safety and simplicity</strong></a> of Nim‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/mantielero/lvgl.nim"><strong>Nim Wrapper for LVGL Graphics Library</strong></a></p>
<p><a href="https://nim-lang.org/docs/nimc.html#nim-for-embedded-systems">(More about <strong>Embedded Nim</strong>)</a></p>
<p><a href="https://nim-lang.org/docs/nimc.html">(More about <strong>Nim Compiler</strong>)</a></p>
</li>
</ul>
<p><img src="https://lupyuen.codeberg.page/images/nim-gpio.jpg" alt="GPIO 29 in BL808 Reference Manual (Page 119)"/></p>
<p><a href="https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf"><em>GPIO 29 in BL808 Reference Manual (Page 119)</em></a></p>

<p><em>Nim Blinky needs an LED Driver for Ox64‚Ä¶</em></p>
<p><em>What‚Äôs the Quickest Way to create a NuttX LED Driver?</em></p>
<p><a href="https://gist.github.com/lupyuen/553c2da4ad5d119468d223e162573e96#file-ox64-nuttx-nim-blink-log-L79-L112"><strong>U-Boot Bootloader</strong></a> can help! Power up Ox64 and press Enter a few times to reveal the <strong>U-Boot Command Prompt</strong>.</p>
<p>We enter these <strong>U-Boot Commands</strong>‚Ä¶</p>
<div><pre><code>## Dump the GPIO 29 Register at 0x20000938 (gpio_cfg29)
$ md 0x20000938 1
20000938: 00400803                             ..@.

## Set GPIO 29 Output to 1:
## (1 &lt;&lt; 6) | (11 &lt;&lt; 8) | (0 &lt;&lt; 30) | (0 &lt;&lt; 4) | (1 &lt;&lt; 24)
## = 0x1000b40
$ mw 0x20000938 0x1000b40 1

## Dump the GPIO 29 Register to verify
$ md 020000938 1
20000938: 01000b40                             @...

## Set GPIO 29 Output to 0:
## (1 &lt;&lt; 6) | (11 &lt;&lt; 8) | (0 &lt;&lt; 30) | (0 &lt;&lt; 4) | (0 &lt;&lt; 24)
## = 0xb40
$ mw 0x20000938 0xb40 1

## Dump the GPIO 29 Register to verify
$ md 0x20000938 1
20000938: 00000b40                             @...
</code></pre></div>
<p>And our LED (GPIO 29) will <strong>flip On and Off</strong>!</p>
<p>Thus we have verified the <strong>Magic Bits</strong> for flipping our LED‚Ä¶</p>
<ul>
<li>
<p>Write to <strong>GPIO 29 Register</strong> at <strong><code>0x2000</code> <code>0938</code></strong> (gpio_cfg29)</p>
</li>
<li>
<p>Register Value <strong><code>0x100</code> <code>0B40</code></strong> will flip the LED On</p>
</li>
<li>
<p>Register Value <strong><code>0xB40</code></strong> will flip the LED Off</p>
</li>
</ul>
<p><em>How did we figure out the Magic Bits for GPIO 29?</em></p>
<p>From <a href="https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf"><strong>BL808 Reference Manual</strong></a> (Page 56), ‚ÄúNormal GPIO Output Mode‚Äù‚Ä¶</p>
<ul>
<li>
<p>Set <strong>reg_gpio_29_oe</strong> (Bit 6) to <strong><code>1</code></strong> to enable GPIO Output Mode </p>
</li>
<li>
<p>Set <strong>reg_gpio_29_func_sel</strong> (Bits 8 to 12) to <strong><code>11</code></strong> to enter SWGPIO Mode </p>
</li>
<li>
<p>Set <strong>reg_gpio_29_mode</strong> (Bits 30 to 31) to <strong><code>0</code></strong> to enable Normal Output Function of I/O </p>
</li>
<li>
<p>Set <strong>reg_gpio_29_pu</strong> (Bit 4) and <strong>reg_gpio_29_pd</strong> (Bit 5) to <strong><code>0</code></strong> to disable Internal Pull-Up and Pull-Down functions </p>
</li>
<li>
<p>Set the Pin Level (<strong><code>0</code></strong> or <strong><code>1</code></strong>) through <strong>reg_gpio_29_o</strong> (Bit 24) </p>
</li>
</ul>
<p><a href="https://lupyuen.codeberg.page/images/nim-gpio.jpg">(<strong>GPIO Bits</strong> are listed in the pic above)</a></p>
<p>Which means‚Ä¶</p>
<ul>
<li>
<p><strong>Set GPIO Output to 0</strong> </p>
</li>
<li>
<p><strong>Set GPIO Output to 1</strong> </p>
</li>
</ul>
<p>And we write the above values to <strong>GPIO 29 Register</strong> at <strong><code>0x2000</code> <code>0938</code></strong> (gpio_cfg29)</p>
<p><em>How to flip the GPIO in our LED Driver?</em></p>
<p>We do this in our <strong>NuttX LED Driver</strong>: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/nim/boards/risc-v/bl808/ox64/src/bl808_userleds.c#L176-L209">bl808_userleds.c</a></p>
<div><pre><code>// Flip the LEDs On and Off according to the LED Set
// (Bit 0 = LED 0)
void board_userled_all(uint32_t ledset) {

  // For LED 0 to 2...
  for (int i = 0; i &lt; BOARD_LEDS; i++) {

    // Get the desired state of the LED
    const bool val = ((ledset &amp; g_led_setmap[i]) != 0);

    // If this is LED 0...
    if (i == 0) {

      // Flip it On or Off?
      if (val) {

        // Flip LED 0 (GPIO 29) to On:
        // Set gpio_cfg29 to (1 &lt;&lt; 6) | (11 &lt;&lt; 8) | (0 &lt;&lt; 30) | (0 &lt;&lt; 4) | (1 &lt;&lt; 24)
        // mw 0x20000938 0x1000b40 1
        *(volatile uint32_t *) 0x20000938 = 0x1000b40;
      } else {

        // Flip LED 0 (GPIO 29) to Off:
        // Set gpio_cfg29 to (1 &lt;&lt; 6) | (11 &lt;&lt; 8) | (0 &lt;&lt; 30) | (0 &lt;&lt; 4) | (0 &lt;&lt; 24)
        // mw 0x20000938 0xb40 1
        *(volatile uint32_t *) 0x20000938 = 0xb40;
      }
    }
  }
}
</code></pre></div>
<p>That‚Äôs how we created a barebones LED Driver for Ox64!</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/nim/boards/risc-v/bl808/ox64/src/bl808_autoleds.c">(Remember to add the <strong>Auto LED Driver</strong>)</a></p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/pull/47/files#diff-60cc096e3a9b22a769602cbbc3b0f5e7731e72db7b0338da04fcf665ed753b64">(And update the <strong>Board Kconfig</strong>)</a></p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/nim/boards/risc-v/bl808/ox64/src/bl808_appinit.c#L167-L179">(And start our <strong>LED Driver</strong>)</a></p>
<p><em>Ahem it looks a little messy‚Ä¶</em></p>
<p>No Worries! Later we‚Äôll replace the (awful) code above by the <strong>BL808 GPIO Driver</strong>. Which we‚Äôll copy from <a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/bl602/bl602_gpio.c"><strong>NuttX for BL602</strong></a>‚Ä¶</p>
<div><pre><code>// Get the desired state of LED[i]
const bool val = ((ledset &amp; g_led_setmap[i]) != 0);

// Call the BL808 GPIO Driver to flip the LED On or Off
bl808_gpio_write(  // Write to the GPIO Output...
  g_led_map[i],    // GPIO Number for LED[i]
  val              // Flip it On or Off
);
</code></pre></div>
<p><em>Anything else we patched?</em></p>
<p>We fixed the <strong>NuttX Timer</strong> for Ox64 (otherwise we can‚Äôt blink)‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.codeberg.page/articles/nim#appendix-opensbi-timer-for-nuttx"><strong>‚ÄúOpenSBI Timer for NuttX‚Äù</strong></a></li>
</ul>
<p><img src="https://lupyuen.codeberg.page/images/nim-blink.jpg" alt="Apache NuttX RTOS on Ox64 BL808 RISC-V SBC: Nim blinks our LED"/></p>

<p>Today we ran some Fun Experiments with <strong>Nim on NuttX</strong>‚Ä¶</p>
<ul>
<li>
<p>We blinked a Simulated LED on <strong>QEMU Emulator</strong></p>
</li>
<li>
<p>Then we blinked a Real LED on <strong>Ox64 BL808 RISC-V SBC</strong> (pic above)</p>
</li>
<li>
<p>We peeked <strong>inside Nim on NuttX</strong></p>
</li>
<li>
<p>To figure out how <strong>Nim compiles to C</strong></p>
</li>
<li>
<p>Even though it‚Äôs Python-like with <strong>Garbage Collection</strong></p>
</li>
<li>
<p>And <strong>Everything works OK</strong>!</p>
<p>(With minor fixes to Nim Config, LED Driver and RISC-V Timer)</p>
</li>
</ul>
<p>We‚Äôll do more with Nim on NuttX. (Maybe <strong>LVGL</strong>?) Stay Tuned!</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> (and the awesome NuttX Community) for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://news.ycombinator.com/item?id=38828619"><strong>Discuss this article on Hacker News</strong></a></p>
</li>
<li>
<p><a href="https://forum.pine64.org/showthread.php?tid=18986"><strong>Discuss this article on Pine64 Forum</strong></a></p>
</li>
<li>
<p><a href="https://bbs.bouffalolab.com/d/274-article-nim-on-a-real-time-operating-system-apache-nuttx-rtos-ox64-bl808"><strong>Discuss this article on Bouffalo Lab Forum</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-ox64"><strong>My Current Project: ‚ÄúApache NuttX RTOS for Ox64 BL808‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64"><strong>My Other Project: ‚ÄúNuttX for Star64 JH7110‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>Older Project: ‚ÄúNuttX for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.codeberg.page"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.codeberg.page/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/nim.md"><strong>lupyuen.github.io/src/nim.md</strong></a></p>
<p><img src="https://lupyuen.codeberg.page/images/nim-qemu.png" alt="Nim with Apache NuttX RTOS on QEMU RISC-V (64-bit)"/></p>

<p>In this article, we compiled a Work-In-Progress Version of <strong>Apache NuttX RTOS for QEMU RISC-V (64-bit)</strong> that has Minor Fixes for Nim‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/pull/47/files#diff-dd54e0076f30825f912248f2424460e3126c2a8f4e2880709f5c68af9342ddcf"><strong>nsh64/defconfig</strong></a>: NuttX Config for QEMU</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/pull/47/files#diff-5905dc63d5fd592e0a1e25ab25783ae99e54180a7b98fb59f56a73dee79104e6"><strong>qemu_rv_autoleds.c</strong></a>
: Auto LED Driver for QEMU</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/pull/47/files#diff-a6fd389669ddef88302f00a34d401479886cb8983f7be58b32ba075699cb5bb8"><strong>qemu_rv_userleds.c</strong></a>: User LED Driver for QEMU</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/pull/47/files#diff-beeaeb03fa5642002a542446c89251c9a7c5c1681cfe915387740ea0975e91b3"><strong>qemu_rv_appinit.c</strong></a>: Start LED Driver</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/pull/3/files#diff-7fb4194c7b9e7b17a2a650d4182f39fb0e932cc9bb566e9b580d22fa8a7b4307"><strong>Makefile</strong></a>: Nimcache has moved 2 folders up</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/pull/3/files#diff-be274e89063d9377278fad5fdcdd936e89d2f32efd7eb8eb8a6a83ac4c711879"><strong>config.nims</strong></a>: Add support for 64-bit RISC-V</p>
</li>
</ul>
<p>First we install <a href="https://nim-lang.org/install_unix.html"><strong>Nim Compiler</strong></a> (only the Latest Dev Version supports NuttX)‚Ä¶</p>
<div><pre><code>## Install Nim Compiler: https://nim-lang.org/install_unix.html
curl https://nim-lang.org/choosenim/init.sh -sSf | sh

## Add Nim to PATH
export PATH=$HOME/.nimble/bin:$PATH

## Select Latest Dev Version of Nim. Will take a while!
choosenim devel --latest

## Version should be 2.1.1 or later:
## Nim Compiler Version 2.1.1 [Linux: amd64]
## Compiled at 2023-12-22
nim -v
</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx-nim#build-nuttx-with-debian-container-in-vscode">(Nim won‚Äôt install? Try a <strong>Linux Container</strong>)</a></p>
<p>Then we download and build NuttX for <strong>QEMU RISC-V (64-bit)</strong>‚Ä¶</p>
<div><pre><code>## Download the WIP NuttX Source Code
git clone \
  --branch nim \
  https://github.com/lupyuen2/wip-pinephone-nuttx \
  nuttx
git clone \
  --branch nim \
  https://github.com/lupyuen2/wip-pinephone-nuttx-apps \
  apps

## Configure NuttX for QEMU RISC-V (64-bit)
cd nuttx
tools/configure.sh rv-virt:nsh64

## Build NuttX
make

## Dump the disassembly to nuttx.S
riscv64-unknown-elf-objdump \
  --syms --source --reloc --demangle --line-numbers --wide \
  --debugging \
  nuttx \
  &gt;nuttx.S \
  2&gt;&amp;1
</code></pre></div>
<p><a href="https://lupyuen.codeberg.page/articles/release#build-nuttx-for-star64">(Remember to install the <strong>Build Prerequisites and Toolchain</strong>)</a></p>
<p><a href="https://github.com/lupyuen/nuttx-nim/releases/tag/qemu-1">(See the <strong>Build Script</strong>)</a></p>
<p><a href="https://gist.github.com/lupyuen/09e653cbd227b9cdff7cf3cb0a5e1ffa">(See the <strong>Build Log</strong>)</a></p>
<p><a href="https://github.com/lupyuen/nuttx-nim/releases/tag/qemu-1">(See the <strong>Build Outputs</strong>)</a></p>
<p>This produces the NuttX ELF Image <strong><code>nuttx</code></strong> that we may boot on QEMU RISC-V Emulator‚Ä¶</p>
<div><pre><code>## Start the QEMU RISC-V Emulator (64-bit) with NuttX RTOS
qemu-system-riscv64 \
  -semihosting \
  -M virt,aclint=on \
  -cpu rv64 \
  -smp 8 \
  -bios none \
  -kernel nuttx \
  -nographic
</code></pre></div>
<p>At the NuttX Prompt, enter ‚Äú<strong>hello_nim</strong>‚Äù‚Ä¶</p>
<div><pre><code>nsh&gt; hello_nim
Hello Nim!
Opening /dev/userleds
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/09e653cbd227b9cdff7cf3cb0a5e1ffa#file-qemu-nuttx-nim-build-log-L472-L497">(Enter ‚Äú<strong>help</strong>‚Äù to see the available commands)</a></p>
<p>Nim on NuttX blinks our <strong>Simulated LED</strong>‚Ä¶</p>
<div><pre><code>Set LED 0 to 1
board_userled_all: led=0, val=1
Waiting...

Set LED 0 to 0
board_userled_all: led=0, val=0
Waiting...

Set LED 0 to 1
board_userled_all: led=0, val=1
Waiting...
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/09e653cbd227b9cdff7cf3cb0a5e1ffa#file-qemu-nuttx-nim-build-log-L210-L471">(See the <strong>NuttX Log</strong>)</a></p>
<p>To Exit QEMU: Press <strong><code>Ctrl-A</code></strong> then <strong><code>x</code></strong></p>
<p><img src="https://lupyuen.codeberg.page/images/nim-ox64.png" alt="Apache NuttX RTOS on Ox64 BL808 RISC-V SBC: Works great with Nim!"/></p>

<p>In this article, we compiled a Work-In-Progress Version of <strong>Apache NuttX RTOS for Ox64</strong> that has Minor Fixes for Nim‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/pull/47/files#diff-fa4b30efe1c5e19ba2fdd2216528406d85fa89bf3d2d0e5161794191c1566078"><strong>nsh/defconfig</strong></a>: NuttX Config for Ox64</p>
</li>
<li>
<p><a href="https://lupyuen.codeberg.page/articles/nim#appendix-opensbi-timer-for-nuttx"><strong>bl808_timerisr.c</strong></a>: RISC-V Timer for Ox64</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/pull/47/files#diff-efdf5ed87983905c7021de03a7add73932da529d4312b80f948eb199c256b170"><strong>bl808_autoleds.c</strong></a>: Auto LED Driver for Ox64</p>
</li>
<li>
<p><a href="https://lupyuen.codeberg.page/articles/nim#led-driver-for-ox64"><strong>bl808_userleds.c</strong></a>: User LED Driver for Ox64</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/pull/47/files#diff-902a3cb106dc7153d030370077938ef28c9412d8b3434888fca8bbf1a1cfbd54"><strong>bl808_appinit.c</strong></a>: Start LED Driver for Ox64</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/pull/3/files#diff-7fb4194c7b9e7b17a2a650d4182f39fb0e932cc9bb566e9b580d22fa8a7b4307"><strong>Makefile</strong></a>: Nimcache has moved 2 folders up</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/pull/3/files#diff-be274e89063d9377278fad5fdcdd936e89d2f32efd7eb8eb8a6a83ac4c711879"><strong>config.nims</strong></a>: Add support for 64-bit RISC-V</p>
</li>
</ul>
<p>First we install <a href="https://nim-lang.org/install_unix.html"><strong>Nim Compiler</strong></a> (only the Latest Dev Version supports NuttX)‚Ä¶</p>
<div><pre><code>## Install Nim Compiler: https://nim-lang.org/install_unix.html
curl https://nim-lang.org/choosenim/init.sh -sSf | sh

## Add Nim to PATH
export PATH=$HOME/.nimble/bin:$PATH

## Select Latest Dev Version of Nim. Will take a while!
choosenim devel --latest

## Version should be 2.1.1 or later:
## Nim Compiler Version 2.1.1 [Linux: amd64]
## Compiled at 2023-12-22
nim -v
</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx-nim#build-nuttx-with-debian-container-in-vscode">(Nim won‚Äôt install? Try a <strong>Linux Container</strong>)</a></p>
<p>Then we download and build NuttX for <strong>Ox64 BL808 SBC</strong>‚Ä¶</p>
<div><pre><code>## Download the WIP NuttX Source Code
git clone \
  --branch nim \
  https://github.com/lupyuen2/wip-pinephone-nuttx \
  nuttx
git clone \
  --branch nim \
  https://github.com/lupyuen2/wip-pinephone-nuttx-apps \
  apps

## Configure NuttX for Ox64 BL808 RISC-V SBC
cd nuttx
tools/configure.sh ox64:nsh

## Build NuttX
make

## Export the NuttX Kernel
## to `nuttx.bin`
riscv64-unknown-elf-objcopy \
  -O binary \
  nuttx \
  nuttx.bin

## Dump the disassembly to nuttx.S
riscv64-unknown-elf-objdump \
  --syms --source --reloc --demangle --line-numbers --wide \
  --debugging \
  nuttx \
  &gt;nuttx.S \
  2&gt;&amp;1

## Dump the hello_nim disassembly to hello_nim.S
riscv64-unknown-elf-objdump \
  --syms --source --reloc --demangle --line-numbers --wide \
  --debugging \
  ../apps/bin/hello_nim \
  &gt;hello_nim.S \
  2&gt;&amp;1
</code></pre></div>
<p><a href="https://lupyuen.codeberg.page/articles/release#build-nuttx-for-star64">(Remember to install the <strong>Build Prerequisites and Toolchain</strong>)</a></p>
<p>We build the <strong>Initial RAM Disk</strong> that contains NuttX Shell and NuttX Apps‚Ä¶</p>
<div><pre><code>## Build the Apps Filesystem
make -j 8 export
pushd ../apps
./tools/mkimport.sh -z -x ../nuttx/nuttx-export-*.tar.gz
make -j 8 import
popd

## Generate the Initial RAM Disk `initrd`
## in ROMFS Filesystem Format
## from the Apps Filesystem `../apps/bin`
## and label it `NuttXBootVol`
genromfs \
  -f initrd \
  -d ../apps/bin \
  -V &#34;NuttXBootVol&#34;

## Prepare a Padding with 64 KB of zeroes
head -c 65536 /dev/zero &gt;/tmp/nuttx.pad

## Append Padding and Initial RAM Disk to NuttX Kernel
cat nuttx.bin /tmp/nuttx.pad initrd \
  &gt;Image
</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx-nim/releases/tag/ox64-1">(See the <strong>Build Script</strong>)</a></p>
<p><a href="https://gist.github.com/lupyuen/578a7eb2d4d827aa252fff37c172dd18">(See the <strong>Build Log</strong>)</a></p>
<p><a href="https://github.com/lupyuen/nuttx-nim/releases/tag/ox64-1">(See the <strong>Build Outputs</strong>)</a></p>
<p>This produces the NuttX Image for Ox64: <strong><code>Image</code></strong></p>
<p>Next we prepare a <strong>Linux microSD</strong> for Ox64 as described <a href="https://lupyuen.codeberg.page/articles/ox64"><strong>in the previous article</strong></a>.</p>
<p><a href="https://lupyuen.codeberg.page/articles/ox64#flash-opensbi-and-u-boot">(Remember to flash <strong>OpenSBI and U-Boot Bootloader</strong>)</a></p>
<p>And we do the <a href="https://lupyuen.codeberg.page/articles/ox64#apache-nuttx-rtos-for-ox64"><strong>Linux-To-NuttX Switcheroo</strong></a>: Copy the <strong><code>Image</code></strong> file (from above) and overwrite the <strong><code>Image</code></strong> in the Linux microSD‚Ä¶</p>
<div><pre><code>## Overwrite the Linux Image
## on Ox64 microSD
cp Image \
  &#34;/Volumes/NO NAME/Image&#34;
diskutil unmountDisk /dev/disk2
</code></pre></div>
<p>Insert the <a href="https://lupyuen.codeberg.page/images/ox64-sd.jpg"><strong>microSD into Ox64</strong></a> and power up Ox64.</p>
<p>Ox64 boots <a href="https://lupyuen.codeberg.page/articles/sbi"><strong>OpenSBI</strong></a>, which starts <a href="https://lupyuen.codeberg.page/articles/linux#u-boot-bootloader-for-star64"><strong>U-Boot Bootloader</strong></a>, which starts <strong>NuttX Kernel</strong> and the NuttX Shell (NSH).</p>
<p>At the NuttX Prompt, enter ‚Äú<strong>hello_nim</strong>‚Äù‚Ä¶</p>
<div><pre><code>nsh&gt; hello_nim
Hello Nim!
Opening /dev/userleds

Set LED 0 to 1
board_userled_all: led=0, val=1
Waiting...

Set LED 0 to 0
board_userled_all: led=0, val=0
Waiting...
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/09e653cbd227b9cdff7cf3cb0a5e1ffa#file-qemu-nuttx-nim-build-log-L472-L497">(Enter ‚Äú<strong>help</strong>‚Äù to see the available commands)</a></p>
<p>Nim on NuttX <a href="https://lupyuen.codeberg.page/images/nim-blink.jpg"><strong>blinks our LED</strong></a>.</p>
<p><a href="https://youtube.com/shorts/KCkiXFxBgxQ">(Watch the <strong>Demo on YouTube</strong>)</a></p>
<p><a href="https://gist.github.com/lupyuen/553c2da4ad5d119468d223e162573e96">(See the <strong>NuttX Log</strong>)</a></p>
<p><img src="https://lupyuen.codeberg.page/images/privilege-title.jpg" alt="OpenSBI Supervisor Binary Interface"/></p>

<p><em>The <code>sleep</code> command hangs in NuttX Shell. How to fix it?</em></p>
<p>That‚Äôs because we haven‚Äôt implemented the <strong>RISC-V Timer</strong> for Ox64! We should call <a href="https://www.hackster.io/lupyuen/8-risc-v-sbc-on-a-real-time-operating-system-ox64-nuttx-474358#toc-bare-metal-experiments-8"><strong>OpenSBI Supervisor Binary Interface</strong></a> to handle the Timer‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/commit/57ea5f000636f739ac3cb8ea1e60936798f6c3a9#diff-535879ffd6d9fc8e7d84b37a88bdeb1609c4a90e3777150939a96bed18696aee"><strong>Fix RISC-V Timer for Ox64</strong></a></p>
<p>(Ignore <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/commit/57ea5f000636f739ac3cb8ea1e60936798f6c3a9#diff-922834c58227800347b4486fa310c3570cd4014f200ac5ea0cd2e40764cefac4">riscv_mtimer.c</a>)</p>
</li>
</ul>
<p>We only need to change the <strong>Timer Initialisation</strong>:¬†<a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/nim/arch/risc-v/src/bl808/bl808_timerisr.c#L44-L116">bl808_timerisr.c</a></p>
<div><pre><code>// Timer Frequency
#define MTIMER_FREQ 1000000

// This function is called during start-up to initialize the timer interrupt.
void up_timer_initialize(void) {
  struct oneshot_lowerhalf_s *lower = riscv_mtimer_initialize(
    0, 0, RISCV_IRQ_STIMER, MTIMER_FREQ);
  DEBUGASSERT(lower);
  up_alarm_set_lowerhalf(lower);
}
</code></pre></div>
<p>How it works: At startup, <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/nim/arch/risc-v/src/bl808/bl808_timerisr.c#L98-L116"><strong>up_timer_initialize</strong></a> (above) calls‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/common/riscv_mtimer.c#L318-L332"><strong>riscv_mtimer_initialize</strong></a> which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/common/riscv_mtimer.c#L136-L141"><strong>riscv_mtimer_set_mtimecmp</strong></a> which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/common/supervisor/riscv_sbi.c#L94-L107"><strong>riscv_sbi_set_timer</strong></a> which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/common/supervisor/riscv_sbi.c#L53-L76"><strong>sbi_ecall</strong></a> which makes an ecall to OpenSBI</p>
</li>
<li>
<p>Which accesses the <strong>RISC-V System Timer</strong></p>
</li>
</ul>
<p>Originally we set¬†<strong>MTIMER_FREQ</strong> to <code>10000000</code>:¬†<a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/nim/arch/risc-v/src/bl808/bl808_timerisr.c#L44-L48">bl808_timerisr.c</a></p>
<div><pre><code>#define MTIMER_FREQ 10000000
</code></pre></div>
<p>But this causes the command <strong><code>sleep 1</code></strong> to pause for 10 seconds. So we divide the frequency by 10: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/nim/arch/risc-v/src/bl808/bl808_timerisr.c#L44-L48">bl808_timerisr.c</a></p>
<div><pre><code>#define MTIMER_FREQ 1000000
</code></pre></div>
<p>Now the <strong><code>sleep</code></strong> command works correctly in NuttX Shell! Here‚Äôs the log (ignore the errors)‚Ä¶</p>
<ul>
<li><a href="https://gist.github.com/lupyuen/8aa66e7f88d1e31a5f198958c15e4393"><strong><code>sleep</code> works OK on Ox64</strong></a></li>
</ul>

    


</div>
  </body>
</html>
