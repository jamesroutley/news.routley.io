<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tn1ck.com/blog/how-to-generate-sudokus">Original</a>
    <h1>Generating sudokus for fun and no profit</h1>
    
    <div id="readability-page-1" class="page"><div><article><a title="Go back to blog" href="https://tn1ck.com/blog"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"></path><path d="m6 6 12 12"></path></svg></a><p>Once upon a time, I decided to create a complete Sudoku application as my grandma wanted to play some Sudokus on her computer, and I wasn&#39;t satisfied with the free offers available. The project went on for some years and finally led to<!-- --> <a href="https://sudoku.tn1ck.com">sudoku.tn1ck.com</a> - a free and<!-- --> <a href="https://github.com/TN1ck/super-sudoku">open source</a> Sudoku app without any tracking. While working on it, I went down the rabbit hole of generating Sudokus of a specified &#34;human perceived&#34; difficulty and accidentally created a quite thorough analysis of it.</p><h2>Creating a Sudoku solver</h2><p>First things first, to generate a Sudoku, we first have to solve one. The solver plays an integral part in the generation part, as we will use the iterations it needed to solve a Sudoku to measure the difficulty.</p><p>We will explore multiple algorithms and benchmark them against each other in how well we can use them to measure the difficulty of a Sudoku. We start with the most basic brute force algorithm and end up with the final one, based on seeing the Sudoku as a Constraint Satisfaction Problem (short CSP). We use a depth-first search (short DFS) for all our different strategies here. We abstract this by the following function. We make it Sudoku specific instead of completely generic for ease of use.</p><div><div><p>+ </p><!-- --><p>Code of the depth-first search</p></div></div><div><div><p>Brute force version</p><p>Brute force version</p><div><p>This is the most simple strategy to solve the Sudoku: We find an empty spot and fill in a number between 1 - 9. We don’t do anything else. This is horribly slow; do not try this at home.</p><div><div><div><div><div><p><label for="timeout">Time between each step (ms)</label></p></div></div></div></div></div><div><div><div><p>+ </p><!-- --><p>Code of the brute force strategy</p></div></div></div></div></div></div><div><div><p>Skip on invalid Sudokus</p><p>Skip on invalid Sudokus</p><div><p>The simplest and most substantial change we can do is not waiting until the whole Sudoku is filled but skipping on the Sudokus that are already invalid. This solver will solve even the hardest Sudokus in adequate time, but it still wastes a lot of cycles as it is not choosing the cell to fill with a value with any strategy.</p><div><div><div><div><div><p><label for="timeout">Time between each step (ms)</label></p></div></div></div></div></div><div><div><div><p>+ </p><!-- --><p>Code of the improved brute force</p></div></div></div></div></div></div><div><p>Minimum remaining value</p><p>Minimum remaining value</p><div><p>&#34;Minimum remaining value&#34; is a heuristic we can use to not search blindly, but to select the cell next with the least amount of possibilities. This is something a human would do as well - fill or work on the cells with the least options. This greatly reduces the number of iterations needed for the difficult Sudoku. This algorithm is pretty solid now as it can solve even the hardest Sudokus in the millisecond range.</p><div><div><div><div><div><p><label for="timeout">Time between each step (ms)</label></p></div></div></div></div></div><div><div><div><p>+ </p><!-- --><p>Code of the minimum remaining value strategy</p></div></div></div></div></div><div><p>Arc Consistency</p><p>Arc Consistency</p><div><p>We now embark on a different way to solve the Sudoku, namely framing it as a Constraint Satisfaction Problem to solve it and then use Arc Consistency to simplify the problem. A quick primer on some computer science terms.</p><ul><li><strong>Domain</strong> - A domain is the set of possible values for a variable. For a Sudoku, this is the numbers 1 - 9.</li><li><strong>CSP</strong> - A constraint satisfaction problem (CSP) is a problem defined by a set of variables, a set of domains, and a set of constraints. The goal is to assign a value to each variable such that the constraints are satisfied. For a Sudoku, the variables are the cells, the domains are the numbers 1 - 9, and the constraints are that every row, column, and square has to have unique numbers.</li><li><strong>Arc consistency</strong> - A variable is arc-consistent with another variable if every value in the domain of the first variable has a possible value in the domain of the second variable that satisfies the constraint between the two variables.</li><li><strong>AC3</strong> - The AC3 algorithm is an algorithm to create arc consistency. The main difference from the complete naive way to achieve arc consistency is that we do not loop over all constraints again when a domain of a variable changes, but only the relevant variables that have a constraint with it (in Sudoku the cells in the same row/column/square).</li></ul><p>For every cell in the Sudoku, we keep track of its possible values. We reduce the possible values for every cell by checking the Sudoku constraints e.g. remove the numbers that are already in the same row/column/square. We do this as long until no domain is changing anymore. This &#34;reduction of domains using the constraints&#34; is arc consistency.</p><p>For very simple Sudokus, this is already enough to solve one (see the applet below), for harder ones, we are left with multiple options for every unfilled cell. This means we have to employ a search again. We use then the &#34;Minimum remaining value&#34; strategy again to select the cell with the least options and create new versions of the Sudoku with that cell filled with the possible values. This is called &#34;domain splitting&#34; in fancy computer science terms. We again count the number of iterations needed to solve the Sudoku.</p><p>The applet shows the domains of the applied AC3 algorithm in unfilled cells. If a Sudoku cannot be solved, one domain will become empty, which is shown as red, then the algorithm will backtrack.</p><div><div><div><div><div><p><label for="timeout">Time between each step (ms)</label></p></div></div></div></div></div><div><div><div><p>+ </p><!-- --><p>Code of the Arc consistency strategy</p></div></div></div></div></div><h3>Rating the difficulty of Sudokus</h3><p>The main problem that one faces when generating a Sudoku is to assign the difficulty rating for a human solver. As we don’t want to manually verify every Sudoku we generate, we need an automatic way for us to group a newly generated Sudoku according to its difficulty. All our Sudoku solvers yield an iteration count, which we will use as our cost function. I&#39;m relying here on the paper &#34;Rating and generating Sudoku puzzles based on constraint satisfaction problems.&#34; by Fatemi, Bahare, Seyed Mehran Kazemi, and Nazanin Mehrasa.</p><p>We will do basically the same, but actually publish the data and also try out how the &#34;lesser&#34; strategies work here for rating the difficulty. I fetched 100 Sudokus from websudoku.com (easy, medium, hard, evil) for each of its difficulty classes as well as from sudoku.com (easy, medium, hard, expert, master, extreme).</p><h3>How well do the solvers measure human difficulty?</h3><p>I&#39;m not a data scientist, so take this analysis with a grain of salt, and I&#39;m happy for any comments/proposals on how to improve it. As I don&#39;t have comments here yet, you can open an issue at<!-- --> <a target="_blank" href="https://github.com/TN1ck/sudoku-analysis">the GitHub repository of this analysis</a> <!-- -->instead.</p><p>This is the raw data on how many iterations each solver took to solve the Sudokus. You can also execute it yourself<!-- --> <a href="https://tn1ck.com/apps/benchmark-sudokus">here </a> or look at the source<!-- --> <a href="https://github.com/TN1ck/tn1ck.com/blob/main/pages/apps/benchmark-sudokus.tsx">at GitHub</a>. I skipped the most simple brute force, as it would take ages to compute even medium difficult Sudokus.</p><p><strong>For all the charts, I used the logarithm on the iterations as especially the qq plot made it very obvious that the iterations count is exponential to the difficulty.</strong> <!-- -->Which is not surprising as solving Sudokus is famously NP hard. Any currently known algorithms to solve an NP-hard problem take exponential time.</p><div><p>Histograms</p><p>Histograms</p><div><div><p>First let&#39;s draw a histogram of each strategy and each dataset to get an idea of the distribution. From that, we can see that they seem to be more or less normally distributed (with the applied logarithm), especially the brute force algorithm.</p></div><div><p><img src="https://tn1ck.com/how-to-generate-sudokus/benchmark_bruteForceWithValidCheck.csv_histograms.png"/></p></div></div></div><div><p>QQ plots</p><p>QQ plots</p><div><p>Then we look at the QQ plots for each strategy/source/level combination. QQ plots are super cool to get an intuitive understanding of how the values are distributed. A perfect normal distribution would be a straight line. These lines also look pretty straight, but only because we used the logarithm on the iterations count already. For the minimum remaining value and arc consistency, the lower difficulty levels look much less like a straight line, but the higher difficulty levels look very much like it. This is explained with their very low iteration count for the easy Sudokus.</p><div><p><img src="https://tn1ck.com/how-to-generate-sudokus/benchmark_bruteForceWithValidCheck.csv_qq_plots.png"/></p></div></div></div><div><p>Correlation</p><p>Correlation</p><div><p>We can already see that these graphs all look somewhat alike, even the second most basic brute force looks decently similar to our fancy CSP algorithm. But do the numbers agree? How much do the iterations correlate with the level?</p><div><p><img src="https://tn1ck.com/how-to-generate-sudokus/benchmark_bruteForceWithValidCheck.csv_correlation.png"/></p></div><p>As we can see, they all correlate almost perfectly with the brute force having a perfect 1.0 correlation, making it highly likely that the websites use the iteration count as well for their level determination - and this makes the whole analysis problematic, as we still don&#39;t know if this is actually a good difficulty indicator for how a human perceives the difficulty. Actually solving Sudokus by a human and rating them by the time to get a ground truth is left as an exercise for the reader (Sorry I&#39;m not paid for this.)</p></div></div><div><p>Generating a Sudoku with a specific difficulty</p><p>Generating a Sudoku with a specific difficulty</p><div><p>To now generate a Sudoku of a specific difficulty, we do the following:</p><ol><li>Start with an empty grid and fill it with random numbers until it is a valid (and unique) Sudoku. We backtrack when the added number will lead to a non-solvable Sudoku. Note: The uniqueness constraint comes automatically as we continue to fill the Sudoku with numbers. Instead of stopping when it is unique, we could also stop when it is fully filled, but that wouldn&#39;t be helpful as we would have to delete numbers again in the next step.</li><li>To generate a Sudoku of a wanted difficulty, we either remove numbers or add numbers until the reached difficulty is achieved.</li><li>If we cannot delete any more numbers without making it non-unique, meaning we reached max difficulty, but the difficulty is below the requested one, start at 1 again. Note: We could also backtrack or add numbers again, but for my personal use, I found it better to save the Sudoku with the maximum achieved difficulty and start over, but by adding and removing numbers, one could theoretically reach the requested difficulty.</li><li>If the call count is close to the requested value, return the Sudoku.</li></ol><p>As point 3 points out, generating very difficult Sudokus can take quite some time as any generation method will struggle with the uniqueness constraint and has to randomly alter the Sudoku generation steps. Here is an applet for you to interactively run the Sudoku. The code is not crazy optimized, and we do have to do some heavy calculations,<!-- --> <strong>so be wary that your browser might freeze for a bit if you click solve</strong>.</p><div><div><div><div><ol><li><p>Find a sudoku that is solvable and unique:</p></li><li><div><p>Decrease / increase difficulty as much as possible. </p><p><span>Disabled: Sudoku is not unique and solvable yet.</span></p></div></li></ol></div><p><label for="timeout">Seed</label></p><p><label for="timeout">Iteration goal (difficulty)</label></p></div></div></div></div></div><h3 id="criticism">Generation algorithm as described by the paper</h3><p>As mentioned above, the algorithm described in the paper has some issues, which in effect make it <strong>very</strong> slow albeit still valid. Here is how they describe the algorithm:</p><blockquote>&#34;We use hill climbing to generate new puzzles having a call count close to the call count we need. In this method, first of all, we generate an initial puzzle with some random numbers inside it and calculate its cost function. Then in each iteration, we randomly change one element of this solution by adding, deleting, or changing a single number and calculate the cost function again.</blockquote><p>When I first read it, I thought &#34;we generate an initial puzzle with some random numbers inside it&#34; would mean that I could literally start with a Sudoku grid and put random numbers in it.</p><p>I’m not entirely sure if they meant to start with a valid Sudoku, but &#34;initial puzzle with some random numbers&#34; does not sound like it. Furthermore, &#34;just adding, deleting, or changing a single number&#34; is not efficient, as again, this can lead to an invalid configuration quickly, albeit the hill climbing will take care of that if you were in a valid configuration before.</p><p>I find my algorithm to be more efficient and elegant as it is guided by the Sudoku&#39;s constraints, namely we first create a solvable and unique Sudoku, making the hill climbing afterwards easier as our cost function will not return infinity. Their algorithm will spend most of their time trying to stumble upon a valid Sudoku.</p></article></div></div>
  </body>
</html>
