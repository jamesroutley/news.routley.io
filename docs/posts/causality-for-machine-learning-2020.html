<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ff13.fastforwardlabs.com/">Original</a>
    <h1>Causality for Machine Learning (2020)</h1>
    
    <div id="readability-page-1" class="page"><div>
          <p><a href="https://www.cloudera.com/products/fast-forward-labs-research.html"><img alt="Cloudera Fast Forward" src="https://ff13.fastforwardlabs.com/figures/cloudera-fast-forward-logo.png"/></a>
          </p>
          
          
<p>FF13 · ©2020 Cloudera, Inc. All rights reserved</p>
<figure><img src="https://ff13.fastforwardlabs.com/figures/ff13-cover-splash.png" alt="Causality for Machine Learning report cover"/><figcaption>Causality for Machine Learning report cover</figcaption></figure>
<p><em>This is an applied research report by <a href="https://www.cloudera.com/products/fast-forward-labs-research.html">Cloudera Fast Forward Labs</a>. We write reports about emerging technologies. Accompanying each report are working prototypes that exhibit the capabilities of the algorithm and offer detailed technical advice on its practical application. Read our full report on causality for machine learning below or <a href="https://ff13.fastforwardlabs.com/FF13-Causality_for_Machine_Learning-Cloudera_Fast_Forward.pdf" target="_blank" id="report-pdf-download">download the PDF</a>. Also be sure to check out the complementary prototype, <a href="https://scene.fastforwardlabs.com">Scene</a>.</em></p>

<h2 id="introduction">Introduction</h2>
<p>In recent years, machine learning has made remarkable progress, providing novel capabilities like the creation of sophisticated, computable representations of text and images. These capabilities have enabled new products, such as image searches based on image content, automatic translation between many languages, and even the synthesis of realistic images and voice. Simultaneously, machine learning has seen widespread adoption in the enterprise for classic use cases (for instance, predicting customer churn, loan defaulting, and manufacturing equipment failure).</p>
<p>Where machine learning has been successful, it has been extraordinarily so.</p>
<p>In many cases, that success can be attributed to supervised learning on large volumes of training data (combined with extensive computation). Broadly, supervised learning systems excel at one task: <em>prediction</em>. When the goal is to predict an outcome, and when we have many examples of that outcome arising, as well as the features associated with it, we may turn to supervised learning.</p>
<p>As machine learning has gained popularity, its sphere of influence in business processes has expanded beyond narrow prediction and into decision making. The results of machine learning systems are routinely used to set credit limits, anticipate manufacturing equipment failures, and curate our various news feeds. As individuals and businesses seek to learn from the information provided by such complex and nonlinear systems, more (and better) methods for interpretability have been developed, and this is both healthy and important.</p>
<p>However, there are fundamental limits to reasoning based on prediction alone. For instance, what will happen if a bank increases a customer’s credit limit? Such questions cannot be answered by a correlative model built on previously observed data, because they involve a possible change in the customer’s choices as a reaction to the change in credit limit. In many cases, the outcome of our decision process is an <em>intervention</em> - an action that changes something in the world. As we’ll demonstrate in this report, purely correlative predictive systems are not equipped for reasoning under such interventions, and hence are prone to biases. For data-informed decision making under intervention, we need causality.</p>
<p>Even for purely predictive systems, which is very much the forte of supervised learning, applying some causal thinking brings benefits. Causal relationships are by their definition <em>invariant</em>, meaning they hold true across different circumstances and environments. This is a very desirable property for machine learning systems, where we often predict on data that we have not seen in training; we need these systems to be adaptable and robust.</p>
<p>The intersection of causal inference and machine learning is a rapidly expanding area of research. It is already yielding capabilities that are ready for mainstream adoption - capabilities which can help us build more robust, reliable, and fair machine learning systems.</p>
<p>This report is an introduction to causal reasoning as it pertains to much data science and machine learning work. We introduce causal graphs, with a focus on removing the <em>conceptual</em> barriers to understanding. We then use this understanding to explore recent ideas around <em>invariant prediction</em>, which brings some of the benefits of causal graphs to high dimensional problems. Along with the accompanying prototype, we show how even classic machine learning problems, like image classification, can benefit from the tools of causal inference.</p>
<h2 id="background%3A-causal-inference">Background: Causal Inference</h2>
<p>In this chapter, we discuss the essentials of causal reasoning (particularly in how it differs from supervised learning) and give an informal introduction to structural causal models. Grasping the basic notions of causal modeling allows for a much richer understanding of invariance and generalization, which we discuss in the next chapter, <a href="#causality-and-invariance">Causality and Invariance</a>.</p>
<h3 id="why-are-we-interested-in-causal-inference%3F">Why are we interested in causal inference?</h3>
<p>Imagine a bank that would like to reduce the number of business loans which default. Historical data and sophisticated supervised learning techniques may be able to accurately identify which loans are likely to default, and interpretability techniques may tell us some features that are correlated with (or predictive of) defaulting. However, to reduce the default rate, we must understand what changes to make, which requires understanding not only <em>which</em> loans default, but <em>why</em> the loans default.</p>
<figure><img src="https://ff13.fastforwardlabs.com/figures/ff13-01.png" alt="A bank would like to decide which business loans to grant based on true, causal relationships."/><figcaption>A bank would like to decide which business loans to grant based on true, causal relationships.</figcaption></figure>
<p>It may be that we find small loans are more likely to default than larger loans. One might naively assume that the bank ought to stop making small loans. However, perhaps it is really the case that smaller businesses are more likely to fail than large businesses, and <em>also</em> more likely to apply for small loans. In this case, the true causal relationship is between the size of the <em>business</em> and defaulting, and not between the size of the <em>loan</em> and defaulting. If this is so, our policy decisions should be influenced by business size, rather than loan size.</p>
<p>Unfortunately, supervised learning alone cannot tell us which is true. If we include both loan size and business size as features in our model, we will simply find that they are both related to loan defaulting, to some extent. While that insight is true - as they are both statistically related to defaulting - which <em>causes</em> defaulting is a separate question, and the one to which we want the answer.</p>
<p>Causality gives us a framework to reason about such questions, and recent developments at the intersection of causality and machine learning are making the discovery of such causal relationships easier.</p>
<h4 id="the-shortcomings-of-supervised-learning">The shortcomings of supervised learning</h4>
<p>Supervised machine learning has proved enormously successful at some tasks. This is particularyly true in dealing with tasks that require high-dimensional inputs, such as computer vision and natural language processing. There has been truly remarkable progress over the past two decades, and it should be noted that an acknowledgment of supervised learning’s shortcomings does not in any way diminish that progress.</p>
<p>With success have come inflated expectations that autonomous systems be capable of independent decision-making, and even human-like intelligence. Current machine learning approaches are unable to meet those expectations, owing to fundamental limitations of pattern recognition.</p>
<p>One such limitation is <strong>generalizability</strong> (also called <em>robustness</em> or <em>adaptability</em>), that is, the ability to apply a model learned in one context in a new environment. Many current state-of-the-art machine learning approaches assume that the trained model will be applied to data that looks the same as the training data. These models are trained on highly specific tasks, like recognizing dogs in images or identifying fraud in banking transactions. In real life, though, the data on which we predict is often different from the data on which we train, even when the task is the same. For example, training data is often subject to some form of selection bias, and simply collecting more of it does not mitigate that.</p>
<figure><img src="https://ff13.fastforwardlabs.com/figures/ff13-02.png" alt="The real world is often distributed differently than our training data."/><figcaption>The real world is often distributed differently than our training data.</figcaption></figure>
<p>Another limitation is <strong>explainability</strong>, that is, machine learning models remain mostly “black boxes” that are unable to explain the reasons behind their predictions or recommendations, thus eroding users’ trust and impeding diagnosis and repair. For example, a deep learning system can be trained to recognize cancer in medical images with high accuracy, provided it is given plenty of images and compute power, but - unlike a real doctor - it cannot explain why or how a particular image suggests disease. Several methods for understanding model predictions have been developed, and while these are necessary and welcome, understanding the interpretation and limitations of their outputs is a science in itself. While model interpretation methods like <a href="https://arxiv.org/abs/1602.04938">LIME</a> and <a href="https://arxiv.org/abs/1705.07874">SHAP</a> are useful, they provide insight only into how the model works, and not into how the world works.</p>
<figure><img src="https://ff13.fastforwardlabs.com/figures/ff13-03.png" alt="Predictions alone are often not useful unless accompanied by an explanation."/><figcaption>Predictions alone are often not useful unless accompanied by an explanation.</figcaption></figure>
<p>And finally, the understanding of <strong>cause-and-effect</strong> connections - a key element of human intelligence - is absent from pattern recognition systems. Humans have the ability to answer “what if” kinds of questions. <em>What if I change something? What if I had acted differently?</em> Such interventional, counterfactual, or retrospective questions are the forte of human intelligence. While imbuing machines with this kind of intelligence is still far-fetched, researchers in deep learning are increasingly recognizing the importance of these questions, and using them to inform their research.</p>
<figure><img src="https://ff13.fastforwardlabs.com/figures/ff13-04.png" alt="Humans use counterfactual reasoning all the time. This is enabled by our unconcious understanding of cause and effect."/><figcaption>Humans use counterfactual reasoning all the time. This is enabled by our unconcious understanding of cause and effect.</figcaption></figure>
<p>All of this means that supervised machine learning systems must be used cautiously in certain situations - and if we want to mitigate these restrictions effectively, causation is key.</p>
<h4 id="what-does-causality-bring-to-the-table%3F">What does causality bring to the table?</h4>
<p>Causal inference provides us with tools that allow us to answer the question of <em>why</em> something happens. This takes us a step further than traditional statistical or machine learning approaches that are focused on predicting outcomes and concerned with identifying associations.</p>
<p>Causality has long been of interest to humanity on a philosophical level, but it has only been in the latter half of the 20th century (thanks to the work of pioneering methodologists such as Donald Rubin and Judea Pearl), that a mathematical framework for causality has been introduced. In recent years, the boom of machine learning has enhanced the development of causal inference and attracted new researchers to the area.</p>
<p>Identifying causal effects helps us understand a variety of things: for example, user behavior in online systems, effect of social policies, risk factors of diseases. Questions of cause-and-effect are also critical for the design of data-driven applications. For instance, how do algorithmic recommendations affect our purchasing decisions? How do they affect a student’s learning outcome or a doctor’s efficacy? All of these are hard questions and require thinking about the counterfactual: what would have happened in a world with a different system, policy, or intervention?  Without causal reasoning, correlation-based methods can lead us astray.</p>
<p>That said, learning causality is a challenging problem. There are broadly two situations in which we could find ourselves: in one case, we are able to actively intervene in the system we are modeling and get experimental data; in the other, we have only observational data.</p>
<p>The gold standard in establishing causal effects is a Randomised Controlled Trial (RCT) and this falls under the experimental data category. In an RCT, we try to engineer similar populations using random assignment (as choosing the populations manually could introduce selection effects that destroy our ability to learn causal relations) and apply an intervention to one population and not the other. From this, we measure the causal effect of changing one variable as a simple difference in the quantity of interest between the two populations.</p>
<figure><img src="https://ff13.fastforwardlabs.com/figures/ff13-05.png" alt="Randomised controlled trials are the gold standard in establishing causal effects."/><figcaption>Randomised controlled trials are the gold standard in establishing causal effects.</figcaption></figure>
<p>We can use RCTs to establish whether a particular causal relation holds. However, trials are not always physically possible, and even when they are, they are not always ethical (for instance, it would not be ethical to deny a patient a treatment that is reasonably believed to work, or trial a news aggregation algorithm designed to influence a person’s mood without informed consent). In some cases, we can find naturally occurring experiments. In the worst cases, we’re left trying to infer causality from observational data alone.</p>
<p>In general, this is not possible, and we must at least impose some modeling assumptions. There are several formal frameworks for doing so. For our purpose of building intuition, we’ll introduce Judea Pearl’s <a href="http://bayes.cs.ucla.edu/BOOK-2K/">Structural Causal Model</a> (SCM) framework in this chapter.</p>
<h3 id="the-ladder-of-causation">The ladder of causation</h3>
<p>In <a href="http://bayes.cs.ucla.edu/WHY/">The Book of Why</a>, Judea Pearl, an author of much foundational work in causality, describes three kinds of reasoning we can perform as rungs on a ladder. These rungs describe when we need causality, and what it buys us.</p>
<figure><img src="https://ff13.fastforwardlabs.com/figures/ff13-06.png" alt="The ladder of causation, as described in The Book of Why."/><figcaption>The ladder of causation, as described in <a href="http://bayes.cs.ucla.edu/WHY/">The Book of Why</a>.</figcaption></figure>
<p>On the <strong>first rung</strong>, we can do <strong>statistical and predictive reasoning</strong>. This covers most (but not all) of what we do in machine learning. We may make very sophisticated forecasts, infer latent variables in complex deep generative models, or cluster data according to subtle relations. All of these things sit on rung one.</p>
<p><em>Example: a bank wishes to predict which of its current business loans are likely to default, so it can make financial forecasts that account for likely losses.</em></p>
<p>The <strong>second rung</strong> is <strong>interventional reasoning</strong>. Interventional reasoning allows us to predict what will happen when a system is changed. This enables us to describe what characteristics are particular to the exact observations we’ve made, and what should be invariant across new circumstances. This kind of reasoning requires a <em>causal</em> model. Intervening is a fundamental operation in causality, and we’ll discuss both interventions and causal models in this chapter.</p>
<p><em>Example: a bank would like to reduce the number of loans which default, and considers changing its policies. Predicting what will happen as a result of this intervention requires that the bank understand the causal relations which affect loan defaulting.</em></p>
<p>The <strong>third rung</strong> is <strong>counterfactual reasoning</strong>. On this rung, we can talk not only about what has happened, but also what would have happened if circumstances were different. Counterfactual reasoning requires a more precisely specified causal model than intervention. This form of reasoning is very powerful, providing a mathematical formulation of computing in alternate worlds where events were different.</p>
<p><em>Example: a bank would like to know what the likely return on a loan would have been, had they offered different terms than they did.</em></p>
<figure><img src="https://ff13.fastforwardlabs.com/figures/ff13-07.png" alt="The ladder of causation describes the kind of question we can answer depending on the sophistication of our causal model."/><figcaption>The ladder of causation describes the kind of question we can answer depending on the sophistication of our causal model.</figcaption></figure>
<p>By now, we hopefully agree that there is something to causality, and it has much to offer. However, we have yet to really <em>define</em> causality. We must begin with a familiar refrain: correlation is not causation.</p>
<h3 id="from-correlation-to-causation">From correlation to causation</h3>
<h4 id="spurious-correlations">Spurious correlations</h4>
<p>Very many things display correlation. The rooster crows when the sun rises. The lights turn off when you flick a switch. Global temperatures have risen alarmingly since the 1800s, and meanwhile pirate numbers have dwindled to almost nothing.</p>
<p>These examples show us that while correlation can <em>appear</em> as a result of causation, as in the case of the light switch, correlation certainly does not always <em>imply</em> causation, as in the case of the pirates.</p>
<p>Correlated things are not always related. It’s possible to find many correlations with no readily imaginable causal interaction. The internet treasure <a href="https://www.tylervigen.com/spurious-correlations">Spurious Correlations</a> collects many amusing examples of this. These spurious correlations most likely arise as a result of small sample size and coincidences that are bound to happen when making many comparisons. We should not be surprised if we find something that has low probability if we try many combinations.</p>
<figure><img src="https://ff13.fastforwardlabs.com/figures/spurious-correlation.png" alt="Figure source: Spurious Correlations."/><figcaption>Figure source: <a href="https://www.tylervigen.com/spurious-correlations">Spurious Correlations</a>.</figcaption></figure>
<p>In real world systems, spurious correlations can be cause for serious ethical concerns. For instance, certain characteristics may be spuriously associated with individuals or minority groups, and these characteristics may be highly predictive. As such, the model weights them as important during a learning task. This can easily embed bias and unfairness into an algorithm based on the spurious correlations in a given dataset.</p>
<h4 id="the-principle-of-common-cause">The Principle of Common Cause</h4>
<p>In a posthumous 1956 book, <a href="https://www.goodreads.com/book/show/848892.The_Direction_of_Time">The Direction of Time</a>, Hans Reichenbach outlined the principle of common cause. He states the principle this way:</p>
<blockquote>
<p>“If an improbable coincidence has occurred, there must exist a common cause.”</p>
</blockquote>
<p>Our understanding of causality has evolved, but this language is remarkably similar to what we use now. Let’s discuss how correlation may arise from causation.</p>
<p>We will do this in the framework of Structural Causal Models (SCMs). An SCM is a directed acyclic graph of relationships between variables. The nodes represent variables, and the edges between them point from cause to effect. The value of each variable depends only on its direct parents in the graph (the other variables which point directly into it) and a noise variable that encapsulates any environmental interactions we are not modeling. We will examine three fundamental causal structures.</p>
<div>
<h5 id="causal-terminology">Causal Terminology</h5>
<p>A <strong>causal graph</strong> is a directed acyclic graph denoting the dependency between variables.</p>
<p>A <strong>structural causal model</strong> carries more information than a causal graph alone. It also specifies the functional form of dependencies between variables.</p>
<p>Remarkably, it’s possible to do much causal reasoning - including a calculation of the size of causal effects - via the graph alone, without specifying a parametric form for the relationships between causes and effects.</p>
</div>
<h5 id="1.-direct-causation">1. Direct causation</h5>
<p>The simplest way in which correlation between two variables arises is when one variable is a direct cause of the other. We say that one thing causes another when a change in the first thing, while holding everything else constant, results in a change in the second. In the business loan defaulting example discussed earlier, we could create a two node graph with one of the nodes being whether or not a business is small (say “small business” with values 0 or 1) and the other node being “default” indicating whether or not the business defaulted on the loan. In this case, we would expect that a small business increases the chances of it defaulting.</p>
<figure><img src="https://ff13.fastforwardlabs.com/figures/ff13-08.png" alt="Direct causation gives rise to statistical dependence between two variables. In this fictional example, the indicator variable for Small businesses has a direct causal effect on the Loan Defalt indicator variable."/><figcaption>Direct causation gives rise to statistical dependence between two variables. In this fictional example, the indicator variable for Small businesses has a direct causal effect on the Loan Defalt indicator variable.</figcaption></figure>
<p>This setup is immediately reminiscent of supervised learning, where we have a dataset of features, X, and targets, Y, and want to learn a mapping between them. However, in machine learning, we typically start with all available features and select those that are most informative about the target. When drawing a causal relationship, only those features we believe have an actual causal effect on the target should be included as direct causes. As we will see below, there are other diagrams that can lead to a predictive statistical relationship between X and Y in which neither directly causes the other.</p>
<h5 id="2.-common-cause">2. Common cause</h5>
<p>A common pattern is for a single variable to be the cause of multiple other variables. If a variable, Z, is a direct cause of both X and Y, we say that Z is a common cause and call the structure a “fork.” For example, unemployment could potentially cause both loan default and reduced consumer spend.</p>
<figure><img src="https://ff13.fastforwardlabs.com/figures/ff13-09.png" alt="Two effects appear statistically dependent, but only because of a common cause. If the common cause, Unemployment, is fixed, then Consumer Spend and Loan Default become statistically independent."/><figcaption>Two effects appear statistically dependent, but only because of a common cause. If the common cause, Unemployment, is fixed, then Consumer Spend and Loan Default become statistically independent.</figcaption></figure>
<p>Because both consumer spend and loan default depend on unemployment, they will appear correlated. A given value of unemployment will generate some values of consumer spend and loan default, and when unemployment changes, both consumer spend and loan default will change. As such, in the joint distribution of the SCM, the two dependent variables (consumer spend and loan default) will appear statistically related to one another.</p>
<p>However, if we were to <em>condition</em> on unemployment (for instance, by selecting data corresponding to a fixed unemployment rate), we would see that consumer spend and loan default are independent from one another.</p>
<p>The common cause unemployment <em>confounds</em> the relationship between consumer spend and loan default. We are unable to correctly calculate the relationship between consumer spend and loan default without accounting for unemployment (by conditioning). This is especially dangerous if unnoticed.</p>
<p>Unfortunately, confounders can be tricky or impossible to detect from observational data alone. In fact, if we look only at consumer spend and loan default, we could see the same joint distribution as in the case where consumer spend and loan default are directly causally related. As such, we should think of causal graphs as encoding our <em>assumptions</em> about the system we are studying. We return to this point in <a href="#how-do-we-know-which-graph-to-use%3F">How do we know which graph to use?</a></p>
<h5 id="3.-common-effect">3. Common effect</h5>
<p>The opposite common pattern is for one effect to have multiple direct causes. A node that has multiple causal parents is called a “collider” with respect to those nodes.</p>
<figure><img src="https://ff13.fastforwardlabs.com/figures/ff13-10.png" alt="Variables that share a common effect are independent, until we fix the effect. For a given value of Loan Default, there is an induced dependency between the Number of Liens and Credit Score."/><figcaption>Variables that share a common effect are independent, until we fix the effect. For a given value of Loan Default, there is an induced dependency between the Number of Liens and Credit Score.</figcaption></figure>
<p>A collider is a node that depends on more than one cause. In this example, loan defaulting depends on both commercial credit score and number of liens (a “lien” refers to the right to keep possession of property belonging to another entity until a debt owed by that entity is discharged), so we call loan default a <em>collider</em>.</p>
<p>Colliders are different to chains of direct causation and forks because the conditioning behaviour works oppositely. Before any conditioning, commercial credit score and number of liens are unconditionally independent. There is no variable with causal arrows going into both commercial credit score and number of liens, and no arrow linking them directly, so we should not expect a statistical dependency. However, if we condition on the collider, we will induce a conditional dependence between commercial credit score and number of liens.</p>
<p>This may seem a bit unintuitive, but we can make sense of it with a little thought experiment. Loan default depends on both commercial credit score and number of liens, so if either of those changes value, the chance of loan default changes. We fix the value of loan default (say, we look only at those loans that did default). Now, if we were to learn anything about the value of commercial credit score, we would know something about the number of liens too; only certain values of number of liens are compatible with the conditioned value of loan defaulting and observed value of commercial credit score. As such, conditioning on a collider induces a spurious correlation between the parent nodes. Conditioning on a collider is exactly selection bias!</p>
<h4 id="structural-causal-models%2C-in-code">Structural Causal Models, in code</h4>
<div>
<p>The small causal graphs shown above are an intuitive way to reason about causality. Remarkably, we can do much causal reasoning (and calculate causal effects) with these graphs, simply by specifying qualitatively which variables causally influence others. In the real world, causal graphs can be large and complex.</p>
<p>Of course, there are other ways to encode the information. Given the graph, we can easily write down an expression for the joint distribution: it’s the product of probability distributions for each node conditioned on its direct causal parents. In the case of a collider structure, <code>x</code> → <code>z</code> ← <code>y</code>, the joint distribution is simply <code>p(x,y,z) = p(x) p(y) p(z|x,y)</code>. The conditional probability <code>p(z|x,y)</code> is exactly what we’re used to estimating in supervised learning!</p>
<p>If we know more about the system, we can move from this causal graph to a full structural causal model. An example SCM compatible with this graph would be:</p>
<pre><code>from numpy.random import randn

def x():
  return -5 + randn()

def y():
  return 5 + randn()

def z(x, y):
  return x + y + randn()

def sample():
  x_ = x()
  y_ = y()
  z_ = z(x_, y_)
  return x_, y_, z_
</code></pre>
<p>Each of the variables has an independent random noise associated with it, arising from factors not modeled by the graph. These distributions need not be identical, but must be independent. Notice that the structure of the graph encodes the dependencies between variables, which we see as the function signatures. The values of <code>x</code> and <code>y</code> are independent, but <code>z</code> depends on both. We can also see clearly that the model defines a generative process for the data, since we can easily sample from the joint distribution by calling the <code>sample</code> function. Doing so repeatedly allows us to chart the joint distribution, and see that <code>x</code> and <code>y</code> are indeed independent; there’s no apparent correlation in the scatter chart.</p>
<figure><img src="https://ff13.fastforwardlabs.com/figures/scm-observed.png" alt="Left: Histograms of the observational distributions of x, y and z. Right: Scatter plot of the observational joint distribution of x and y. Since x and y are not causally connected except through the collider z, they are completely uncorrelated."/><figcaption>Left: Histograms of the observational distributions of x, y and z. Right: Scatter plot of the observational joint distribution of x and y. Since x and y are not causally connected except through the collider z, they are completely uncorrelated.</figcaption></figure>
<p>Now that we have a model in code, we can see a selection bias effect. If we condition the data to only values of <code>z</code> (the collider node) greater than a cutoff (which we can do easily, if inefficiently, by filtering the samples to those where <code>z &gt; 2.5</code>), the previously independent <code>x</code> and <code>y</code> become negatively correlated.</p>
<figure><img src="https://ff13.fastforwardlabs.com/figures/scm-conditioned.png" alt="Left: We have conditioned on z &gt; 2.5 by filtering the samples (note the change of scale), which changes the x and y distributions; they’re both shifted right. Right: The conditional joint distribution of x and y, with a line showing a linear fit, which illustrates the induced negative correlation."/><figcaption>Left: We have conditioned on z &gt; 2.5 by filtering the samples (note the change of scale), which changes the x and y distributions; they’re both shifted right. Right: The conditional joint distribution of x and y, with a line showing a linear fit, which illustrates the induced negative correlation.</figcaption></figure>
</div>
<h3 id="from-prediction-to-intervention">From prediction to intervention</h3>
<p>Now that we have some understanding of what a causal model is, we can get to the heart of causality: the difference between an observation and an <em>intervention</em>.</p>
<p>When we introduced the ladder of causation, we mentioned the notion of <em>intervention</em>, something that changes the system. This is a fundamental operation, and it is important to understand the difference between intervention and observation. It may not at first seem natural to consider intervening as a fundamental action, evoking a similar sense of confusion to when one first encounters priors in Bayesian statistics. Is an intervention subjective? Who gets to define what an intervention is?</p>
<p>Simply, an intervention is a change to the data generating process. Samples from the joint distribution of the variables in the graph may be obtained by simply “running the graph forward.” For each cause, we sample from its noise distribution and propagate that value through the SCM to calculate the resulting effects. To compute an <em>interventional</em> distribution, we force particular causes (on which we are intervening) to some value, and propagate those values through the equations of the SCM. This introduces a distribution different from the observational distribution with which we usually work.</p>
<p>There is sometimes confusion between an interventional distribution and a conditional distribution. A conditional distribution is generated by filtering an observed distribution to meet some criteria. For instance, we might want to know the loan default rate among the businesses to which we have granted a loan at a particular interest rate. This interest rate would itself likely have been determined by some model, and as such, the businesses with that rate will likely share statistical similarities.</p>
<p>The interventional distribution (when we intervene on interest rate) is fundamentally different. It is the distribution of loan defaulting if we <em>fix</em> the interest rate to a particular value, regardless of other features of the business that may warrant a different rate. This corresponds to removing all the inbound arrows to the interest rate in the causal graph; we’re forcing the value, so it no longer depends on its causal parents.</p>
<p>Clearly, not all interventions are physically possible! While we could intervene to set the interest rate, we of course would not be able to make every business a large one.</p>
<h4 id="interventions-in-code">Interventions in code</h4>
<div>
<p>It is easy to make interventions concrete with code. Returning to the collider example, to compute an interventional distribution, we could define a new sampling function where instead of drawing all variables at random, we intervene to set <code>x</code> to a particular value. Because this is an intervention, not simply conditioning (as earlier), we must make the change, then run the data generating process again.</p>
<pre><code>def sample_intervened():
  x_ = -3
  y_ = y()
  z_ = z(x_, y_)
  return x_, y_, z_
</code></pre>
<p>Performing this intervention results in a new distribution for <code>z</code>, which is different from the observational distribution that we saw earlier. Further, the relationship between x and y has changed; the joint distribution is now simply the marginal distribution of <code>y</code>, since <code>x</code> is fixed. This is a strikingly different relationship than when we simply conditioned the observational distribution.</p>
<figure><img src="https://ff13.fastforwardlabs.com/figures/scm-intervened.png" alt="Left: We have intervened to fix x in the data generating process, which changes z, but not y. Right: When we intervened on x, the joint distribution of x and y became just the marginal distribution of y."/><figcaption>Left: We have intervened to fix x in the data generating process, which changes z, but not y. Right: When we intervened on x, the joint distribution of x and y became just the marginal distribution of y.</figcaption></figure>
</div>
<h4 id="interventions-in-customer-churn">Interventions in customer churn</h4>
<p>In our <a href="https://ff06-2020.fastforwardlabs.com/">interpretability report</a>, we present a customer churn modeling use case. Briefly, given 20 features of the customers of a telco - things like tenure, demographic attributes, whether they have phone and internet services, and whether they have tech support - we must model their likelihood of churning within a fixed time. To do this, we turn to a dataset of customers and whether they churned in the time period. This can be modeled as straightforward binary classification, and we can use the resulting output scores as a measure of how likely a customer is to churn.</p>
<p>The model used to calculate the churn score is an ensemble of a linear model, a random forest, and a simple feed forward neural network. With appropriate hyperparameters and training procedure, such an ensemble is capable of good predictive performance. That performance is gained by exploiting subtle correlations in the data.</p>
<p>To understand the predictions made, we apply <a href="https://arxiv.org/abs/1602.04938">LIME</a>. This returns a feature importance at the local level: which features contributed to each individual prediction. To accompany the analysis, we built Refractor, an interface for exploring the feature importances. Examining these is interesting, and highlights the factors that are <em>correlated</em> with a customer being likely to churn. <a href="https://refractor.fastforwardlabs.com/">Refractor</a> suggests which features most affect the churn prediction, and allows an analyst to change customer features and see the resulting churn prediction.</p>
<figure><img src="https://ff13.fastforwardlabs.com/figures/refractor.gif" alt="The Refractor prototype"/><figcaption>The <a href="https://refractor.fastforwardlabs.com/">Refractor</a> prototype</figcaption></figure>
<p>Because we have a model that provides new predictions when we change the features, it is tempting to believe we can infer from this alone how to reduce churn probability. Aside from the fact that often the most important features cannot be changed by intervention (tenure, for instance), this is an incorrect interpretation of what LIME and our model provide. The correct interpretation of the prediction is the probability of churn for someone who <em>naturally</em> occurred in our dataset with those features, or, for instance, what this same customer’s churn probability will look like next year (when tenure will have naturally increased by one year), assuming none of their other features change.</p>
<p>Of course, there are some features that can be changed in reality. For instance:</p>
<ul>
<li>the telco could reduce the monthly fee for a customer, or</li>
<li>try to convince them to change contract type from monthly to yearly (one does not have to think too hard about why this changes the short-term churn probability), or</li>
<li>upgrade the service from DSL to fiber-optic.</li>
</ul>
<p>Which of these interventions would most decrease the probability that the customer churns? We don’t know. Our model alone - for all its excellent predictive accuracy - can’t tell us that, precisely because it is entirely correlative. Even a perfect model, that 100% accurately predicts which customers will churn, cannot tell us that.</p>
<p>With some common sense, we can see that a causal interpretation is not appropriate here. LIME often reports that having a faster fiber-optic broadband connection increases churn probability, relative to slower DSL. It seems unlikely that faster internet has this effect. In reality, LIME is correctly reporting that there is a <em>correlation</em> between having fiber-optic and churning, likely because of some latent factors - perhaps people who prefer faster internet are also intrinsically more willing to switch providers. This distinction of interpretation is crucial.</p>
<p>The model can only tell us what <strong>statistical dependencies</strong> exist in the dataset we trained it on. The training dataset was purely observational - a snapshot of a window of time with observations about those customers in it. If we select “give the customer access to tech support” in the app, the model can tell us that similar customers who also had access to tech support were less likely to churn. Our model only captures information about customers who happened to have some combination of features. It does not capture information about what happens when we <em>change</em> a customer’s features. This is an important distinction.</p>
<p>To know what would happen when we intervene to change a feature, we must compute the interventional distribution (or a point prediction), which can be very different from the observational distribution. In the case of churn, it’s likely the true causal graph is rather complex.</p>
<p>Interpretability techniques such as LIME provide important insights into models, but they are not causal insights. To make good decisions using the output of any interpretability method, we need to combine it with causal knowledge.</p>
<p>Often, this causal knowledge is not formally specified in a graph, and we simply call it “domain knowledge,” or expertise. We have emphasized what the <em>model</em> cannot do, in order to make the technical point clear, but in reality, anyone working with the model would naturally apply their own expertise. The move from that to a causal model requires formally encoding the assumptions we make all the time and verifying that the expected statistical relationships hold in our observed data (and if possible, experimenting). Doing so would give us an understanding of the cause-effect relationships in our system, and the ability to reason quantitatively about the effect of interventions.</p>
<figure><img src="https://ff13.fastforwardlabs.com/figures/ff13-11.png" alt=""/></figure>
<p>Constructing a useful causal model of churn is a complex undertaking, requiring both deep domain knowledge and a detailed technical understanding of causal inference. In <a href="#causality-and-invariance">Causality and Invariance</a>, we will discuss some techniques that are bridging the gap between a full causal model and the supervised learning setup we use in problems like churn prediction.</p>
<h4 id="when-do-we-need-interventions%3F">When do we need interventions?</h4>
<p>When do we need to concern ourselves with intervention and causality? If all we want to do is predict, and to do so with high accuracy (or whatever model performance metric we care about), then we should use everything at our disposal to do so. That means making use of all the variables that may correlate with the outcome we’re trying to predict, and it doesn’t matter that they don’t cause the outcome. Correlation is not causation, but correlation is still predictive, and supervised learning excels at discovering subtle correlations.</p>
<p>Some situations in which this pure supervised learning approach is useful:</p>
<ul>
<li>We want to predict when a machine in our factory will fail.</li>
<li>We want to forecast next quarter’s sales.</li>
<li>We want to identify named entities in some text.</li>
</ul>
<p>Conversely, if we want to predict the effect of an intervention, we need causal reasoning. For example:</p>
<ul>
<li>We want to know what to change about our machines to reduce the likelihood of failures.</li>
<li>We want to know how we can increase next quarter’s sales.</li>
<li>We want to know whether longer or shorter article headlines generate more clicks.</li>
</ul>
<h3 id="how-do-we-know-which-graph-to-use%3F">How do we know which graph to use?</h3>
<p>Knowing the true causal structure of a problem is immensely powerful. Earlier in this chapter, we discussed three building blocks of causal graphs (direct causation, forks, and colliders) but for real problems, a graph can be arbitrarily complex.</p>
<p>The graph structure allows us to reason qualitatively about what statistical dependencies ought to hold in our data. In the absence of abundant randomized controlled trials or other experiments, qualitative thinking is necessary for causal inference. We must use our domain knowledge to construct a plausible graph to test against the data we have. It is possible to refute a causal graph by considering the statistical independence relations it implies, and matching those against the expected relations from the causal structure. For example, if two variables are connected by a common cause on which we have not conditioned, we should expect a statistical dependence between them.</p>
<div>
<h5 id="causal-discovery">Causal Discovery</h5>
<p>The independence relationships implied by a graph can be used for causal discovery. Causal discovery is the process of attempting to recover causal graphs from observational data. There are many approaches appropriate for different sets of assumptions about the graph. However, since many causal graphs can imply the same joint distribution, the best we should hope for from causal discovery is a set of plausible graphs, which, if we are fortunate, may contain the true graph. In reality, inferring the direction of causation in even a two variable system is not always possible from data alone.</p>
</div>
<p>It is not, in general, possible to <em>prove</em> a causal graph, since different graphs can result in the same observed and even interventional distributions. The difficulty of confirming a causal relationship means that we should always proceed with caution when making causal claims. It is best to think of causal models as giving results <em>conditional on a set of causal assumptions</em>. Two nodes that are not directly connected in the causal graph are assumed to be independent in the data generating process, except insofar as the causal relations described above (or combinations of them) induce a statistical dependence.</p>
<p>The validity of the results depends on the validity of the assumptions. Of course, we face the same situation in all machine learning work - and it is to be expected that stronger, causal claims require stronger assumptions than merely observational claims.</p>
<figure><img src="https://ff13.fastforwardlabs.com/figures/ff13-23.png" alt="Sometimes it can be difficult to establish the causal direction even in very simple graphs."/><figcaption>Sometimes it can be difficult to establish the causal direction even in very simple graphs.</figcaption></figure>
<p>One case in which we may be able to write down the true causal graph is when we have ourselves created the system. For instance, a manufacturing line may have a sufficiently deterministic process that makes it possible to write down a precise graph encoding which parts move from which machine to another. If we were to model the production of faulty parts, that graph would be a good basis for the causal graph, since a machine that has not processed a given faulty part is unlikely to be responsible for the fault, and causal graphs encode exactly these independences.</p>
<h3 id="tl%3Bdr">TL;DR</h3>
<p>Causal graphical models present an intuitive and powerful means of reasoning about systems. If an application requires only pure prediction, this reasoning is not necessary, and we may apply supervised learning to exploit subtle correlations between variables and our predicted quantity of interest. However, when a prediction will be used to inform a decision that changes the system, or we want to predict for the system under intervention, we <em>must</em> reason causally  - or else likely draw incorrect conclusions. That said, behind every causal conclusion there is always a causal assumption that cannot be tested or verified by mere observation.</p>
<p>Even without a formal education in causal inference, there are advantages to the qualitative reasoning enabled by causal graphical models. Trying to write down a causal graph forces us to confront our mental model of a system, and helps to highlight potential statistical and interpretational errors. Further, it precisely encodes the independence assumptions we are making. However, these graphs could be complex and high dimensional and require close collaboration between practitioners and domain experts who have substantive knowledge of the problem.</p>
<p>In many domains, problems such as the large numbers of predictors, small sample sizes, and possible presence of unmeasured causes, remain serious impediments to practical applications of causal inference. In such cases, there is often limited background knowledge to reduce the space of alternative causal hypotheses. Even when experimental interventions are possible, performing the many thousands of experiments that would be required to discover causal relationships between thousands or tens of thousands of predictors is often not practical.</p>
<p>Given these challenges, how do we combine causal inference and machine learning? Many of the researched approaches at the intersection of ML and causal inference are motivated by the ability to apply causal inference techniques to high dimensional data, and in domains where specifying causal relationships could be difficult. In the next chapter, we will bridge this gap between structural causal models and supervised machine learning.</p>
<h2 id="causality-and-invariance">Causality and Invariance</h2>
<p>Supervised machine learning is very good at prediction, but there are useful lessons we can take from causal models even for purely predictive problems.</p>
<p>Relative to recent advancements made in the broader field of machine learning, the intersection of machine learning and causal reasoning is still in its infancy. Nonetheless, there are several emerging research directions. Here, we focus on one particularly promising path: the link between causality and invariance. Invariance is a desirable property for many machine learning systems: a model that is invariant is one that performs well in new circumstances, particularly when the underlying data distribution changes. As we will see in this chapter, invariance also provides a route to some causal insights, even when working only with observational data.</p>
<h3 id="the-great-lie-of-machine-learning">The great lie of machine learning</h3>
<p>In supervised learning, we wish to predict something that we don’t know, based on only the information that we do have. Usually, this boils down to learning a mapping between input and output.</p>
<p>To create that map, we require a dataset of input features and output targets; the number of examples required scales with the complexity of the problem. We can then fit the parameters of a learning algorithm to the dataset to minimize some loss function that we choose. For instance, if we are predicting a continuous number, like temperature, we might seek to minimize the mean squared difference between the prediction and the true measurements.</p>
<p>If we are not careful, we will <em>overfit</em> the parameters of the ML algorithm to the dataset we train on. In this context, an overfit model is one that has learned the idiosyncrasies (the spurious correlations!) of our dataset. The result is that when the model is applied to any other dataset (even one with the same data generating process), the model’s performance is poor, because it is relying on superficial features that are no longer present.</p>
<p>To avoid overfitting, we employ various regularization schemes and adjust the capacity of the model to an appropriate level. When we fit the model, we shuffle and split our data, so we may learn the parameters from one portion of the data, and validate the resulting model’s performance on another portion. This gives us confidence that the learned parameters are capturing something about all the data we have, and not merely a portion of it.</p>
<p>Whatever procedure we use (be it cross-validation, forward chaining for time series, or simpler train-test-validation splits), we are relying on a crucial assumption. The assumption is that the data points are <em>independent and identically distributed</em> ( i.i.d.). By <em>independent</em>, we mean that each data point was generated without reference to any of the others, and by <em>identically distributed</em>, we mean that the underlying distributions in the data generating process are the same for all the data points.</p>
<p>Paraphrasing <a href="https://www.youtube.com/watch?v=x1UByHT60mQ&amp;feature=youtu.be&amp;t=37m34s">Zoubin Ghahramani</a>,</p>
<blockquote>
<p>the i.i.d. assumption is the great lie of machine learning.</p>
</blockquote>
<p>Rarely are data truly independent and identically distributed. What are the ramifications of this misassumption for machine learning systems?</p>
<h3 id="dangers-of-spurious-correlations">Dangers of spurious correlations</h3>
<p>When we train a machine learning system with the i.i.d. assumption, we are implicitly assuming an underlying data generating process for that data. This data generating process defines an <em>environment</em>. Different data generating processes will result in different environments, with different underlying distributions of features and targets.</p>
<p>When the environment in which we predict differs from the environment in which our machine learning system was trained, we should expect it to perform poorly. The correlations between features and the target are different - and, as such, the model we created to map from features to target in one environment will output incorrect values of the target for the features in another environment.</p>
<p>Unfortunately, it’s rarely possible to know whether the data generating process for data at predict time (in a deployed ML system, for instance) will be the same as during training time. Even once the system is predicting in the wild, if we do not or cannot collect ground truth labels to match to the input features on which the prediction was based, we may never know.</p>
<p>This problem is not academic. <a href="https://arxiv.org/abs/1807.04975">Recognition in Terra Incognita</a> points this out in humorous fashion (see also <a href="http://people.csail.mit.edu/torralba/publications/datasets_cvpr11.pdf">Unbiased Look at Dataset Bias</a>). Both of these papers highlight that computer vision systems trained for visual recognition of objects, animals, and people can utterly fail to recognise the same objects in different contexts. A cow on the slopes of an alpine field is easily recognised, but a cow on a beach is not noticed at all, or poorly classified as a generic “mammal.”</p>
<figure><img src="https://ff13.fastforwardlabs.com/figures/terra-incognita.png" alt="Figure from Recognition in Terra Incognita, where annotations were provided by ClarifAI.com."/><figcaption>Figure from <a href="https://arxiv.org/abs/1807.04975">Recognition in Terra Incognita</a>, where annotations were provided by <a href="https://www.clarifai.com/">ClarifAI.com</a>.</figcaption></figure>
<p>These failures should not come as a surprise to us! Supervised machine learning is <em>designed</em> to exploit correlations between features to gain predictive performance, and cows and alpine pastures are highly correlated. Neural networks are a very flexible class of models that encode the invariants of the dataset on which they’re trained. If cows dominantly appear on grass, we should expect this to be learned.</p>
<div>
<h5 id="when-is-a-correlation-spurious%3F">When is a correlation spurious?</h5>
<p>In supervised learning, we learn to use subtle correlations, possibly in high dimensional spaces like natural images, to make predictions. What distinguishes a genuine correlation from a spurious one? The answer depends on the intended use of the resulting model.</p>
<p>If we intend for our algorithm to work in only one environment, with very similar images, then we should use all the correlations at our disposal, including those that are very specific to our environment. However, if - as is almost always the case - we intend the algorithm to be used on new data outside of the training environment, we should consider any correlation that only holds in the training environment to be spurious. A spurious correlation is a correlation that only appears to be true due to a selection effect (such as selecting a training set!).</p>
<p>In <a href="#background%3A-causal-inference">Background: Causal Inference</a>, we saw that correlation can arise from several causal structures. In the strictest interpretation, any correlation that does not arise from direct causation could be considered spurious.</p>
<p>Unfortunately, given only a finite set of training data, it is often not possible to know which correlations are spurious. The methods in this section are intended to address precisely that problem.</p>
</div>
<p>When a machine learning algorithm relies heavily on spurious correlations for predictive performance, its performance will be poor on data from outside the dataset on which it was trained. However, that is not the only problem with spurious correlations.</p>
<p>There is an important and growing emphasis on interpretability in machine learning. A machine learning system should not only make predictions, but also provide a means of inspecting how those predictions were made. If a model is relying on spurious correlations, the feature importances (such as those calculated by <a href="https://arxiv.org/abs/1602.04938">LIME</a> or <a href="https://arxiv.org/abs/1705.07874">SHAP</a>) will be similarly spurious. No one should make decisions based on spurious explanations!</p>
<h3 id="invariance">Invariance</h3>
<p>To be confident of our predictions outside of our training and testing datasets, we need a model that is robust to distributional shifts away from the training set. Such a model would have learned a representation which ignores dataset-specific correlations, and instead relies upon features that affect the target in all environments.</p>
<p>How can we go about creating such a model? We could simply train our model with data from multiple environments, as we often do in machine learning (playing fast and loose with the i.i.d. assumption). However, doing so naively would provide us with a model that can only generalize to the environments it has seen (and interpolations of them, if we use a robust objective). We wish our model to generalize beyond the limited set of environments we can access for training, and indeed extrapolate to new and unseen (perhaps unforeseen) environments. The property we are looking for - performing optimally in all environments - is called invariance.</p>
<p>The connection between causality and invariance is well established. In fact, causal relationships are - by their nature - invariant. The way many intuitive causal relationships are established is by observing that the relationship holds all the time, in all circumstances.</p>
<p>Consider how physical laws are discovered. They are found by performing a series of experiments in different conditions, and monitoring which relationships hold, and what their functional form is. In the process of discovering nature’s laws, we will perform some tests that do not show the expected result. In cases where a law does not hold, this gives us information to refine the law to something that is invariant across environments.</p>
<figure><img src="https://ff13.fastforwardlabs.com/figures/ff13-12.png" alt="We learn causal relationships by observing under different experimental conditions. Causal relationships are those that are invariant across the environments created by these conditions."/><figcaption>We learn causal relationships by observing under different experimental conditions. Causal relationships are those that are invariant across the environments created by these conditions.</figcaption></figure>
<p>For example, water boils at 100° Celsius (212° Fahrenheit). We could observe that everywhere, and write a simple causal graph: temperature → water boiling. We have learned a relationship that is invariant across all the environments we have observed.</p>
<p>Then, a new experiment conducted on top of a tall mountain reveals that on the mountain, water boils at a slightly lower temperature. After some more experimentation, we improve our causal model, by realising that in fact, both temperature and pressure affect the boiling point of water, and the true invariant relationship is more complicated.</p>
<p>The mathematics of causality make the notion of invariance and environments precise. Environments are defined by interventions in the causal graph. Each intervention changes the data generating process, such that the correlations between variables in the graph may be different (see <a href="#from-prediction-to-intervention">From prediction to intervention</a>). However, direct causal relationships are invariant relationships: if a node in the causal graph depends only on three variables, and our causal model is correct, it will depend on those three variables, and in the same way, regardless of any interventions. It may be that an intervention restricts the values that the causal variables take, but the relationship itself is not changed. Changing the arguments to a function does not change the function itself.</p>
<h4 id="invariance-and-machine-learning">Invariance and machine learning</h4>
<p>In the machine learning setting, we are mostly concerned with using features to predict a target. As such, we tend to select features for their predictive performance. In contrast, causal graphs are constructed based on domain knowledge and statistical independence relations, and thus encode a much richer dependency structure. However, we are not always interested in the entire causal graph. We may be interested only in the causes of a particular target variable. This puts us closer to familiar machine learning territory.</p>
<figure><img src="https://ff13.fastforwardlabs.com/figures/ff13-14.png" alt="In supervised learning, we often use all available variables (or a subset selected for predictive performance) to predict an outcome. With structural causal models, we encode a much richer dependency structure between variables."/><figcaption>In supervised learning, we often use all available variables (or a subset selected for predictive performance) to predict an outcome. With structural causal models, we encode a much richer dependency structure between variables.</figcaption></figure>
<p>We will now examine two approaches to combining causal invariance and machine learning. The first, invariant causal prediction, uses the notion of invariance to infer the direct causes of a variable of interest. This restricted form of causal discovery (working out the structure of a small part of the graph in which we are interested) is appropriate for problems with well defined variables where a structural causal model (or at least causal graph) could be created - in principle, if not in practice.</p>
<p>Not all problems are amenable to SCMs. In the following section, we describe invariant risk minimization, where we forego the causal graph and seek to find a predictor that is invariant across multiple environments. We don’t learn anything about the graph structure from this procedure, but we do get a predictor with greatly improved out-of-distribution generalization.</p>
<h3 id="invariant-causal-prediction">Invariant Causal Prediction</h3>
<p><a href="https://arxiv.org/abs/1501.01332">Invariant causal prediction</a> (ICP) addresses the task of invariant prediction explicitly in the framework of structural causal models.</p>
<p>Often, the quantity we are ultimately concerned with in a causal analysis is the causal effect of an intervention: what is the difference in the target quantity when another variable is changed? To calculate that, we either need to hold some other variables constant, or else account for the fact that they have changed. If we are only interested in the causes that affect a particular target, we do not need to construct the whole graph, but rather only determine which factors are the true direct causes of the target. Once we know that, we can answer causal questions, like how strongly each variable contributes to the effect, or the causal effect of changing one of the input variables.</p>
<p>The key insight offered by ICP is that because direct causal relationships are invariant, we can use that to determine the causal parents (the direct causes). The set-up is similar to that of machine learning; we have some input features, and we’d like a model of an output target. The difference from supervised learning is that the goal is not “performance at predicting the target variable.” In ICP, we aim to discover the direct causes of a given variable - the variables that point directly into the target in the causal graph.</p>
<figure><img src="https://ff13.fastforwardlabs.com/figures/ff13-15.png" alt="We are not always interested in the full causal graph, and instead only seek to find the direct causes of a given target variable. This brings some of the advantages of a causal model into the supervised learning paradigm."/><figcaption>We are not always interested in the full causal graph, and instead only seek to find the direct causes of a given target variable. This brings some of the advantages of a causal model into the supervised learning paradigm.</figcaption></figure>
<p>To use ICP, we take a target variable of interest, and construct a plausible list of the potential direct causes of that variable. Then we must define environments for the problem: each environment is a dataset. In the language of SCMs, each environment corresponds to data observed when a particular intervention somewhere in the graph was active. We can reason about this even without specifying the whole graph, or even which particular intervention was active, as long as we can separate the data into environments. In practice, we often take an observed variable to be the environment variable, when it could plausibly be so.</p>
<p>For instance, perhaps we are predicting sales volume in retail, and want to discern what store features causally impact sales. The target is sales volume, and the potential causes would be features like store size, number of nearby competitors, level of staffing, and so on.</p>
<p>Environments might be different counties (or even countries) - something that is unlikely to impact the sales directly, but which may impact the <em>features</em> that impact the sales. For instance, different places will have different populations, and population density is a possible cause of sales volume. Importantly, the environment cannot be a descendent of the target variable.</p>
<figure><img src="https://ff13.fastforwardlabs.com/figures/ff13-16.png" alt="We fit a model in multiple environments, and monitor which features are consistently predictive."/><figcaption>We fit a model in multiple environments, and monitor which features are consistently predictive.</figcaption></figure>
<p>To apply ICP, we first consider a subset of features. We then fit a linear (Gaussian) regression from this subset to the target in each environment we have defined. If the model does not change between environments (which can be assessed either via the coefficients or a check on residuals), we have found a set of features that appear to result in an invariant predictor. We iterate over subsets of features combinatorially. Features that appear in a model that is invariant are plausible causes of the target variable. The intersection of these sets of plausible causes (i.e., the features which are predictive in all environments) is then a subset of the true direct causes.</p>
<figure><img src="https://ff13.fastforwardlabs.com/figures/ff13-17.png" alt="The features that are consistently predictive of a target are likely the causal parents in the (unknown!) causal graph."/><figcaption>The features that are consistently predictive of a target are likely the causal parents in the (unknown!) causal graph.</figcaption></figure>
<p>In machine learning terms, ICP is essentially a feature selection method, where the features selected are very likely to be the direct causes of the target. The model built atop those features can be interpreted causally: a high coefficient for a feature means that feature has a high causal effect on the target, and changes in those features should result in the predicted change in the target.</p>
<p>Naturally, there are some caveats and assumptions. In particular, we must assume there is no unobserved confounding between the features and the target (recall that a confounder is a common cause of the feature and target). If there are known confounders, we must make some adjustments to account for them, as detailed in the <a href="https://arxiv.org/abs/1501.01332">ICP paper</a>. The authors provide an R package, <a href="https://cran.r-project.org/web/packages/InvariantCausalPrediction/index.html">InvariantCausalPrediction</a>, implementing the methods.</p>
<p>The restriction of using a linear Gaussian model - and that environments be discrete, rather than defined by the value of a continuous variable - are removed by nonlinear ICP. In the nonlinear case, we replace comparing residuals or coefficients with conditional independence tests.</p>
<h3 id="invariant-risk-minimization">Invariant Risk Minimization</h3>
<p>When using Invariant Causal Prediction, we avoid writing the full structural causal model, or even the full graph of the system we are modeling, but we must still think about it.</p>
<p>For many problems, it’s difficult to even attempt drawing a causal graph. While structural causal models provide a complete framework for causal inference, it is often hard to encode known physical laws (such as Newton’s gravitation, or the ideal gas law) as causal graphs. In familiar machine learning territory, how does one model the causal relationships between individual pixels and a target prediction? This is one of the motivating questions behind the paper <a href="https://arxiv.org/abs/1907.02893">Invariant Risk Minimization</a> (IRM). In place of structured graphs, the authors elevate invariance to the defining feature of causality.</p>
<p>They also make the connection between invariance and causality well:</p>
<blockquote>
<p>“If both Newton’s apple and the planets obey the same equations, chances are that gravitation is a thing.”
– <a href="https://arxiv.org/abs/1907.02893">IRM</a> authors</p>
</blockquote>
<p>Like ICP, IRM uses the idea of training in multiple environments. However, unlike ICP, IRM is not concerned with retrieving the causal parents of the target in a causal graph. Rather, IRM focusses on out-of-distribution generalization: the performance of a predictive model when faced with a new environment. The technique proposed aims to create a data representation, on which a classifier or regressor can perform optimally in all environments. The paper itself describes the IRM principle:</p>
<blockquote>
<p>“To learn invariances across environments, find a data representation such that the optimal classifier on top of that representation matches for all environments.”
– <a href="https://arxiv.org/abs/1907.02893">IRM</a> authors</p>
</blockquote>
<p>Said differently, the idea is that there is a latent causal structure behind the problem we’re learning, and the task is to recover a representation that encodes the part of that structure that affects the target. This is different from selecting features, as in Invariant Causal Prediction. In particular, it provides a bridge from very low level features (such as individual pixels) to a representation encoding high level concepts (such as cows).</p>
<h4 id="the-causal-direction">The causal direction</h4>
<p>The idea of a latent causal system generating observed features is particularly useful as a view of computer vision problems. Computer vision researchers have long studied the generative processes involved in moving from real world objects to pixel representations. It’s instructive to inspect the causal structure of a dataset of cow pictures.</p>
<figure><img src="https://ff13.fastforwardlabs.com/figures/ff13-13.png" alt="When the features are the causes of the target, we say we are learning in the causal direction. When effects are the features, we are learning in the anti-causal direction."/><figcaption>When the features are the causes of the target, we say we are learning in the causal direction. When effects are the features, we are learning in the anti-causal direction.</figcaption></figure>
<p>In nature, cows exist in fields and on beaches, and we have an intuitive understanding that the cow itself and the ground are different things. A neural network trying to predict the presence of a cow in an image could be called an “anti-causal” learning problem, because the direction of causation is the opposite of the direction of prediction. The presence of a cow causes certain pixel patterns, but pixels are the input to the network, and the presence of a cow is the output.</p>
<p>However, a further sophistication can be added: the dataset on which we train a neural network is not learning from nature, but rather from annotations provided by humans. This changes the causal direction: we are now learning the effect from the cause, since those annotations are caused by the pixels of the image. This is the view taken by IRM, which thus interprets supervised learning from images as being a causal (rather than anti-causal) problem.</p>
<p>Not all supervised learning problems are causal. Anti-causal supervised learning problems arise when the label is not provided based on the features, but by some other mechanism that causes the features. For example, in medical imaging, we could obtain a label without reference to the image itself by observing the case over time (this is not a recommended approach for treatment, of course).</p>
<p>Learning in the causal direction explains some of the success of supervised learning - there is a chance that it can recover invariant representations without modification. Any supervised learning algorithm is learning how to combine features to predict the target. If the learning direction is causal, each input is a potential cause of the output, and it’s possible that the features learned will be the true causes. The modifications that invariant risk minimization makes to the learning procedure improve the chance by specifically promoting invariance.</p>
<h3 id="how-irm-works">How IRM works</h3>
<p>To learn an invariant predictor, we must provide the IRM algorithm with data from multiple environments. As in ICP, these environments take the form of datasets - and, as such, the environments must be discrete. We need not specify the graphical or interventional structure associated with the environments. The motivating example of the IRM paper asks us to consider a machine learning system to distinguish cows from camels, highlighting a similar problem to that which <a href="https://arxiv.org/abs/1807.04975">Recognition in Terra Incognita</a> does: animals being classified based on their environment, rather than on the animal itself. In this case, cows on sand may be misclassified as camels, due to the spurious correlations absorbed by computer vision systems.</p>
<figure><img src="https://ff13.fastforwardlabs.com/figures/ff13-18.png" alt="In the IRM setup, we feed the algorithm data from multiple environments, and we must be explicit about which environment a data point belongs to."/><figcaption>In the IRM setup, we feed the algorithm data from multiple environments, and we must be explicit about which environment a data point belongs to.</figcaption></figure>
<p>Simply providing data from multiple environments is not enough. The problem of learning the optimal classifier in multiple environments is a bi-level constrained optimization problem, in which we must simultaneously find the optimal data representation and optimal classifier across multiple separate datasets. IRM reduces the problem to a single optimization loop, with the trick of using a constant classifier and introducing a new penalty term to the loss function.</p>
<pre><code>IRM loss = sum over environments (error + penalty)
</code></pre>
<p>The <code>error</code> is the usual error we would use for the problem at hand - for example, the cross entropy for a classification problem - calculated on each environment. The technical definition of the new <code>penalty</code> term is the squared gradient norm with respect to a constant classifier, but it has an intuitive explanation. While the error measures how well the model is performing in each environment, the penalty measures how much the performance could be improved in each environment with one gradient step.</p>
<p>By including the penalty term in the loss, we punish high gradients (situations in which a large improvement in an environment would be possible with one more epoch of learning). The result is a model with optimal performance in all environments. Without the IRM penalty, a model could minimize the loss by performing extremely well in just one environment, and poorly in others. Adding a term to account for the model having a low gradient (roughly, it has converged) in each environment ensures that the learning is balanced between environments.</p>
<p>To understand the IRM paradigm, we can perform a thought experiment. Imagine we have a dataset of cows and camels, and we’d like to learn to classify them as such. We separate out the dataset by the geolocation of photos - those taken in grassy areas form one environment, and those taken in deserts form another.</p>
<p>As a baseline, we perform regular supervised learning to learn a binary classifier between cows and camels. The learning principle at work in supervised learning is referred to as <em>empirical risk minimization</em>, (ERM); we’re just seeking to minimize the usual cross-entropy loss. We’ll surely find that we can get excellent predictive performance on these two environments, because we have explicitly provided data from both.</p>
<p>The trouble arises when we want to identify a cow on snow, and find that our classifier did not <em>really</em> learn to identify a cow; it learned to identify grass. The holdout performance of our model in any new environment we haven’t trained on will be poor.</p>
<figure><img src="https://ff13.fastforwardlabs.com/figures/ff13-19.png" alt="If we rely on empirical risk minimization, we learn spurious correlations between animals and their environments."/><figcaption>If we rely on empirical risk minimization, we learn spurious correlations between animals and their environments.</figcaption></figure>
<p>With IRM, we perform the training across (at least) two environments, and include the penalty term for each in the loss. We’ll almost certainly find that our performance in the training environments is reduced. However, because we have encouraged the learning of invariant features that transfer across environments, we’re more likely to be able to identify cows on snow. In fact, the very reason our performance in training is reduced is that we’ve not absorbed so many spurious correlations that would hurt prediction in new environments.</p>
<p>It is impossible to guarantee that a model trained with IRM learns <em>no</em> spurious correlations. That depends entirely on the environments provided. If a particular feature is a useful discriminator in all environments, it may well be learned as an invariant feature, even if in reality it is spurious. As such, access to sufficiently diverse environments is paramount for IRM to succeed.</p>
<p>However, we should not be reckless in labeling something as an environment. Both ICP and IRM note that splitting on arbitrary variables in observational data can create diverse environments while destroying the very invariances we wish to learn. While IRM promotes invariance as the primary feature of causality, it pays to hold a structural model in the back of one’s mind, and ask if an environment definition makes sense as something that would alter the data-generating process.</p>
<h4 id="considerations-for-applying-irm">Considerations for applying IRM</h4>
<p>IRM buys us extrapolation powers to new datasets, where independent and identically distributed supervised learning can (at best) interpolate between them. Using IRM to construct models improves their generalization properties by explicitly promoting performance across multiple environments, and leaves us with a new, closer-to-causal representation of the input features. Of course, this representation may not be perfect (IRM is an optimization-based procedure, and we will never know if we have found the true minimum risk across all environments) but it should be a step towards latent causal structure. This means that we can use our model to predict based on true, causal correlations, rather than spurious, environment-specific correlations.</p>
<p>However, there is no panacea, and IRM does come with some challenges.</p>
<p>Often, the dataset that we use in a machine learning project is collected well ahead of time, and may have been collected for an entirely different purpose. Even when a well-labeled dataset that is amenable to the problem exists, it is seldom accompanied by detailed metadata (by which we mean “information about the information”). As such, we often do not have information about the environment in which the data was collected.</p>
<figure><img src="https://ff13.fastforwardlabs.com/figures/ff13-20.png" alt="Most datasets are collected in a variety of environments, and without the metadata necessary to separate them. This presents a challenge for invariance-based approaches."/><figcaption>Most datasets are collected in a variety of environments, and without the metadata necessary to separate them. This presents a challenge for invariance-based approaches.</figcaption></figure>
<p>Another challenge is finding data from sufficiently diverse environments. If the environments are similar, IRM will be unlikely to learn features that generalize to environments that are different. This is both a blessing and a curse - on the one hand, we do not need to have perfectly separated environments to benefit from IRM, but on the other hand, we are limited by the diversity of environments. If a feature appears to be a good predictor in all the environments we have, IRM will not be able to distinguish that from a true causal feature. In general, the more environments we have, and the more diverse they are, the better IRM will do at learning an invariant predictor, and the closer we will get to a causal representation.</p>
<figure><img src="https://ff13.fastforwardlabs.com/figures/ff13-21.png" alt="IRM relies on representative data from diverse environments. If we cannot collect enough data from sufficiently diverse environments, we may still learn spurious correlations."/><figcaption>IRM relies on representative data from diverse environments. If we cannot collect enough data from sufficiently diverse environments, we may still learn spurious correlations.</figcaption></figure>
<p>No model is perfect, and whether or not one is appropriate to use depends on the objective. IRM is more likely to produce an invariant predictor, with good out-of-distribution performance, than empirical risk minimization (regular supervised learning), but using IRM will come at the expense of predictive performance in the training environment.</p>
<p>It’s entirely possible that for a given application, we may be very sure that the data in the eventual test distribution (“in the wild”) will be distributed in the same way as our training data. Further, we may know that all we want to do with the resulting model is predict, not intervene. If both these things are true, we should stick to supervised learning with empirical risk minimization and exploit all the spurious correlations we can.</p>
<h2 id="prototype">Prototype</h2>
<p>The promise of Invariant Risk Minimization (greatly improved out-of-distribution generalization using a representation that is closer-to-causal) is tempting. The IRM paper performs some experiments that clearly show the method works when applied to an artificial structural causal model. Further, an experiment in which an artificial spurious correlation is injected into the MNIST dataset (by coloring the images) is detailed, and works.</p>
<p>In order to gain a better understanding of the algorithm and investigate further, we wanted to test the same technique in a less artificial scenario: on a natural image dataset.</p>
<h3 id="the-wildcam-dataset">The Wildcam dataset</h3>
<p>The <a href="https://www.kaggle.com/c/iwildcam-2019-fgvc6">iWildCam 2019 dataset</a> (from The iWildCam 2019 Challenge Dataset) consists of wildlife images taken using camera traps. In particular, the dataset contains the Caltech Camera Traps (CCT) dataset, on which we focus. The CCT dataset contains 292,732 images, with each image labeled as containing one of 13 animals, or none. The images are collected from 143 locations, and feature a variety of weather conditions and all times of day. The challenge is to identify the animal present in the image.</p>
<figure><img src="https://ff13.fastforwardlabs.com/figures/wildcam-coyote-raccoon.png" alt="Left, a coyote in its natural environment. Right, a raccoon in the same location at night. Image credit: The iWildCam 2019 Challenge Dataset, used under the Community Data License Agreement."/><figcaption>Left, a coyote in its natural environment. Right, a raccoon in the same location at night. Image credit: The <a href="https://arxiv.org/abs/1907.07617">iWildCam 2019 Challenge Dataset</a>, used under the <a href="https://cdla.io/permissive-1-0/">Community Data License Agreement</a>.</figcaption></figure>
<h3 id="experimental-setup">Experimental setup</h3>
<p>This setup maps naturally to the environmental splits used in IRM. Each camera trap location is a distinct physical environment which is roughly consistent, allowing for seasonal, weather, and day/night patterns. No two environments are the same, though the camera locations are spread around roughly the same geographic region (the American Southwest).</p>
<p>The objects of interest in the dataset are animals, which are basically invariant across environments: a raccoon looks like a raccoon in the mountains and in your backyard (though the particular raccoon may be different). The images are not split evenly between environments, since there is more animal activity in some places than others. Nor are the animal species evenly distributed among cameras. Some cameras will primarily produce images of one species or another, depending on the animals active in the area.</p>
<p>If we were to naively train a model using empirical risk on a subset of cameras, we could well end up learning exactly those class imbalances. If 99% of the images from camera 1 are labeled as deer, then we could have a 99% accurate classifier by learning to recognize the fallen tree that is present only in camera 1, rather than the deer themselves. Clearly such a classifier has not really learned to recognize deer, and would be useless for predicting in another environment.</p>
<p>We want to learn to recognize the animals themselves. The IRM setup seems ideally suited to address this challenge.</p>
<p>To validate the approach, we restricted our experiment to only three cameras and two animal species, which were randomly chosen. Of the three cameras, two were used as training environments, and one as a held-out environment for testing. The task was binary classification: distinguish coyotes from raccoons. We used <a href="https://arxiv.org/abs/1512.03385">ResNet18</a>, a pretrained classifier trained on the much larger ImageNet dataset, as a feature extractor with a final fully connected layer with sigmoid output, which we tuned to the problem at hand.</p>
<p>Each of the environments contained images of both coyotes and racoons. Even this reduced dataset exhibited several challenges typical to real world computer vision: some images were dark, some were blurred, some were labeled as containing an animal when only the foot of the animal was visible, and some featured nothing but a patch of fur covering the lens. We saw some success simply ignoring these problems, but ultimately manually selected only those images clearly showing an identifiable coyote or raccoon.</p>
<h3 id="results">Results</h3>
<p>When tackling any supervised learning problem, it’s a good idea to set up a simple baseline against which to compare performance. In the case of a binary classifier, an appropriate baseline model is to always predict the majority class of the training set. The three environments had a class balance as shown in the table below. The majority class in both train environments is coyote, so our baseline accuracy is the accuracy if we always predict the animal is a coyote, regardless of environment or input image.</p>
<div><table>
<thead>
<tr>
<th></th>
<th>Train environment 1</th>
<th>Train environment 2</th>
<th>Test</th>
</tr>
</thead>
<tbody>
<tr>
<td>Coyotes</td>
<td>582</td>
<td>512</td>
<td>144</td>
</tr>
<tr>
<td>Raccoons</td>
<td>276</td>
<td>241</td>
<td>378</td>
</tr>
<tr>
<td>Baseline accuracy</td>
<td>68%</td>
<td>68%</td>
<td>28%</td>
</tr>
</tbody>
</table></div>
<p>When we treated the problem with empirical risk minimization (minimizing the cross-entropy between classes), we found good performance in the train environments, but very poor performance in the test environment. We report the metrics over 120 epochs of training in the table below. The best test accuracy is achieved at epoch 40, after which ERM (empirical risk minimization) begins to overfit. In the case of IRM (invariant risk minimization), we paid a small price in train set accuracy, but achieved much better test results - again, reporting the highest test accuracy achieved in 120 epochs (at epoch 120).</p>
<figure><img src="https://ff13.fastforwardlabs.com/figures/erm-vs-irm-table.png" alt="Table comparing metrics on the combined train set and test set for empirical risk minimization (ERM) and invariant risk minimization (IRM)."/><figcaption>Table comparing metrics on the combined train set and test set for empirical risk minimization (ERM) and invariant risk minimization (IRM).</figcaption></figure>
<p>ERM outperforms the baseline in all environments, but not by too much in the new test environment. This can be attributed to the learning of spurious correlations. The network was able to effectively distinguish between raccoons and coyotes in the training environments, but the features it relied upon to do so were not general enough to help prediction much in the test environment.</p>
<p>In contrast, IRM loses a single percentage point of accuracy in the train environments, but performs almost as well in the test environment. The feature representation IRM constructs has translated between different environments effectively, and proves an effective discriminator.</p>
<p>As a practical point, we found that IRM worked best when the additional IRM penalty term was not added to the loss until the point at which ERM had reached its best performance - in this case the 40th training epoch. As such, ERM and IRM had identical training routines and performance until this point. When we introduced the IRM penalty, the IRM procedure continued to learn and gain out-of-distribution generalization capability, whereas ERM began to overfit. By the 120th epoch, IRM had the accuracy reported above, whereas ERM had achieved 91% in the combined training environments, at the cost of reducing its test accuracy by a few percentage points to 33%.</p>
<h4 id="interpretability">Interpretability</h4>
<p>IRM yields impressive results, especially considering how hard it is to learn from these images. It has a clear and significant improvement in when compared to ERM in a new environment. In this section, we examine a few concrete examples of successes and failures of our prototype model and our speculations as to why they may be.</p>
<p>It would be nice to have a better sense of whether IRM has learned invariant features. By that we mean, whether it has learned to spot a raccoon’s long bushy tail or a coyote’s slender head, instead of the terrain or foliage in the image. Understanding which parts of the image contribute towards IRM’s performance is a powerful proposition. The classification task itself is hard: if you closely look at some of the images in the Wildcam dataset, at a first glance it’s even hard for us, humans, to point out where exactly the animal is. An interpretability technique like Local Interpretable Model-agnostic Explanations (<a href="https://arxiv.org/abs/1602.04938">LIME</a>) provides valuable insights into how that classification is working.</p>
<p>LIME is an explanation technique that can be applied to almost any type of classification model — our report <a href="https://ff06-2020.fastforwardlabs.com/">FF06: Interpretability</a> discusses these possibilities — but here we will consider its application to image data. LIME is a way to understand how different parts of an input affect the output of a model. This is accomplished, essentially, by turning the dials of the input and observing the effect on the output.</p>
<p>Let’s first try and understand how LIME works at a high level - including what inputs we need to provide, and what to expect as output - through a sample image in the test set. The image on the left of the figure below is a sample raw image of a coyote with dimensions height=747 and width=1024, as were all images in the dataset.</p>
<figure><img src="https://ff13.fastforwardlabs.com/figures/coyote-resized.png" alt="Left: a raw Wildcam image. Right: Having been cropped and scaled to the input dimensions required by ResNet18."/><figcaption>Left: a raw Wildcam image. Right: Having been cropped and scaled to the input dimensions required by ResNet18.</figcaption></figure>
<p>To use the IRM model, we must first perform some image transformations like resizing, cropping, and normalization - using the same transformations that we did when training the model. The input image then appears as shown on the right of the figure above, a normalized, 224 * 224 image. The transformed image when scored by the IRM model outputs a probability of 98% (0.98) for the coyote class! So yes, our model is pretty confident of its prediction.</p>
<p>Now, let’s see how LIME works on this image. First, LIME constructs a local linear model, and makes a prediction for the image. For the example image, the predicted score is 0.95, pretty close to the IRM model. When trying to explain the prediction, LIME uses interpretable representations. For images, interpretable representations are basically contiguous patches of similar pixels called superpixels. The superpixels for an image are generated by a standard algorithm, QuickShift, in the LIME implementation. The left panel in the figure below shows all of the 34 superpixels generated by LIME for the example image.</p>
<figure><img src="https://ff13.fastforwardlabs.com/figures/lime-masks.png" alt="LIME masks random combinations of superpixels, generated by QuickShift, to build a local linear model."/><figcaption>LIME masks random combinations of superpixels, generated by QuickShift, to build a local linear model.</figcaption></figure>
<p>It then creates versions of the original image by randomly masking different combinations of the superpixels as shown in the middle and right panes of the above figure. Each random set of masked superpixels is one perturbation of the image. The modeler chooses the number of perturbations; in our case, we used 1000 perturbations of the original image. LIME then builds a regression model on all these perturbed images and determines the superpixels that contributed most towards the prediction, based on their weights.</p>
<p>The figure below shows the superpixel explanations (with the rest of the image grayed out) for the top 12 features that contribute towards the prediction of the coyote classification. While there are quite a few features that are mostly spurious covering the foliage or terrain, one of them covers the entire body of the coyote. Looking at these explanations provides an alternative way of assessing the IRM model and can enhance our trust that the model is learning to rely on sensible features.</p>
<figure><img src="https://ff13.fastforwardlabs.com/figures/irm-top-12.png" alt="The non-grayed-out pixels correspond to the top 12 superpixels that contribute positively to the Coyote classification for the IRM model."/><figcaption>The non-grayed-out pixels correspond to the top 12 superpixels that contribute positively to the Coyote classification for the IRM model.</figcaption></figure>
<p>Now when we generate the top 12 LIME explanations for the same image but based on the ERM model, they seem to capture more of the surroundings, rather than any of the coyote’s body parts.</p>
<figure><img src="https://ff13.fastforwardlabs.com/figures/erm-top-12.png" alt="The non-grayed-out pixels correspond to the top 12 superpixels that contribute positively to the Coyote classification for the ERM model. In this case, they didn’t catch much of the coyote."/><figcaption>The non-grayed-out pixels correspond to the top 12 superpixels that contribute positively to the Coyote classification for the ERM model. In this case, they didn’t catch much of the coyote.</figcaption></figure>
<p>And then there are instances where LIME explanations seem to rely on spurious features. For example, in the figure below, the original image is classified as a coyote by the IRM model with a probability of 72% (0.72), whereas the LIME score is close to 0.53. The superpixels contributing towards the classification for both the IRM and ERM models usually cover the terrain or foliage, though some outline the coyote’s body.</p>
<figure><img src="https://ff13.fastforwardlabs.com/figures/spurious-coyote.png" alt="In this instance, both models seem to be relying on environmental features to predict Coyote."/><figcaption>In this instance, both models seem to be relying on environmental features to predict Coyote.</figcaption></figure>
<p>We observe that the explanations make more intuitive sense when the LIME score is close to the model score.</p>
<p>IRM can only learn to be invariant with respect to the invariants that the environments encode. If there are spurious correlations that are the same across environments, IRM will not distinguish them from invariant features.</p>
<p>One feature that appears invariant in this dataset is the day or night cycle. Raccoons appear exclusively at night, and IRM could well learn that night means raccoon, and rely on it heavily. This correlation is spurious; a raccoon is still a raccoon during the day! However, we would need more environments, including images of raccoons in the daytime, to disentangle that.</p>
<p>The representation that IRM extracts from an environment should theoretically be closer to encoding the latent causal structure of the problem than that which ERM extracts. In our scenario, we might expect that IRM learns to focus more on the actual animal in the picture, since the presence of the animal is the cause of a given annotation. The animals change little between environments, whereas environmental features (like foliage) are completely different at different camera trap locations. Thus, the causal features ought to be invariant between environments.</p>
<p>That said, although the IRM results appear promising for some samples, it is hard to confirm that there is an obvious pattern, and this can be attributed to both the model and the interpretability technique. We chose to train only the last layer of ResNet18 to come up with the IRM model. This choice has an inherent drawback: the capacity for feature learning is low. As such, we wouldn’t expect perfect results, since it’s unlikely that the pretrained ResNet representations map perfectly to raccoons and coyotes.</p>
<p>Further, although an explanation of an image provides some reassurance of the quality of the model, it’s probably still insufficient to provide an overall picture of the <em>kind</em> of features a given model is using, aggregated from all the individual explanations. And even though explanations for multiple images are insightful, these have to be judiciously selected. When it comes to text or tabular data, there are ways to determine the global feature importances, because the features in tabular data or vocabulary stay consistent across all the data points. The superpixels of an image cannot be consistent across all the images, which makes it really hard to assess whether the explanations make sense. Developing tools to understand large image datasets is a worthy endeavour!</p>
<h3 id="product%3A-scene">Product: Scene</h3>
<figure><img src="https://ff13.fastforwardlabs.com/figures/scene.png" alt="The Scene prototype"/><figcaption>The <a href="https://scene.fastforwardlabs.com">Scene prototype</a></figcaption></figure>
<p>To accompany this report, we built a prototype called <a href="https://scene.fastforwardlabs.com">Scene</a> that takes you on a guided tour through the dataset, models, and results of our experiment. With Scene, we really wanted to give people a feel for the images that make up the dataset. Each panel of the tour features 16 images from the dataset, cropped and resized to the same dimensions of the images that the model is trained on. Many of the images featured are randomly sampled from the dataset when we generate the page, while others we specifically selected to use as examples. We hope that the amount and variety of images shown helps people get an intuitive feel for the dataset.</p>
<figure><img src="https://ff13.fastforwardlabs.com/figures/scene-all.png" alt="View all the images in the dataset on the all page."/><figcaption>View all the images in the dataset on the <a href="https://scene.fastforwardlabs.com/all">all</a> page.</figcaption></figure>
<p>If you want to go even deeper, we included an <a href="https://scene.fastforwardlabs.com/all">all</a> page, which shows all 2,133 images in the dataset, along with the predictions and interpretability visualizations for each model. It’s nice to be able to use these visualizations to check intuitions (like which features are important to each model) with your own eyes. Of course, even having access to all the images doesn’t mean you can see “the big picture.” It’s difficult to hold everything you’ve seen in your head as you scroll through. If you’re not careful, you’ll end up generalizing the patterns you’ve seen most recently to the entire dataset. This is the challenge of visualizing the scale of the data that machine learning systems take in. Other techniques, like embeddings (as seen in our <a href="https://activelearner.fastforwardlabs.com/">Active Learner</a> prototype) can help you visualize patterns, but then you lose some of the detail gained by being able to see the images up close. No one technique can give you the whole picture; data visualization requires a variety of techniques.</p>
<p>Generating such a large number of images, complete with text labels and interpretability overlays, was an interesting technical challenge. Originally, we’d planned to have Scene animate transitions between the original image and the interpretability overlays. To do this efficiently in a browser, you generate a “sprite sheet” - a large image that contains all the different animation states you’ll transition through (a technique borrowed from video games). It was while we were generating the sprite sheets that we decided that, rather than transitioning through them one at a time, it would be more effective to show the entire sheet. Having more images visible together made comparisons easier and the scale of the dataset more clear. We ended up using the <a href="https://activelearner.fastforwardlabs.com/">node-canvas</a> package to crop and place the images, overlay the interpretability layers, and apply the labels through a node script. Since we do all the work of generating images locally, we guarantee the user as snappy an experience as possible. Static site generation has seen renewed interest as a web-development strategy, and could be especially useful for large-scale data-visualization.</p>
<h2 id="landscape">Landscape</h2>
<p>Causality spans a broad area of topics, including using causal insights to improve machine learning methods, adapting it for high-dimensional datasets and applying them for better data-driven decision making in real-world contexts. We also discussed in <a href="#causality-and-invariance">Causality and Invariance</a> how the collected data is rarely an accurate reflection of the population, and hence may fail to generalize in different environments or new datasets. Methods based on invariance show promise in addressing out-of-distribution generalization.</p>
<h3 id="use-cases">Use Cases</h3>
<p>As we demonstrated in the <a href="#prototype">Prototype</a> chapter, Invariant Risk Minimization is particularly well suited to image problems in diverse physical environments. However, an environment need not mean only the scenery in an image, and when it does, it need not be fixed to a single value. Here we suggest some applications in and beyond computer vision.</p>
<h4 id="healthcare">Healthcare</h4>
<p>In healthcare, medical images have to be manually annotated by radiologists to identify abnormalities. These annotated images are then used to train and build diagnostic models. Often the devices (like MRI scanners) which generate these medical images exhibit some kind of variation. That is, due to mechanical configurations, vendor differences, or any number of other reasons, the images that are generated by one MRI scanner could be systematically different from another for the same patient. As such, a diagnostic model that was built on the images generated by an old MRI scanner may perform poorly when tested on the images generated by a new scanner. One way to solve this problem is to have the radiologist annotate the images generated by the new scanner and then retrain the model. But that could be expensive and time-consuming. Plus, this isn’t a permanent solution; every time there’s a new scanner or changes to the configuration, it would be necessary to retrain the existing model with an entirely new set of images.</p>
<p>A diagnostic model based on invariant prediction that treats scanners as environments could be immune to these noisy device variations and change its decisions accordingly. This could save the time and money needed to annotate images from the new scanner.</p>
<h4 id="robotics">Robotics</h4>
<figure><img src="https://ff13.fastforwardlabs.com/figures/ff13-26.png" alt="Autonomous systems trained in the lab or in limited environments will struggle to adapt to the diversity present in the real world."/><figcaption>Autonomous systems trained in the lab or in limited environments will struggle to adapt to the diversity present in the real world.</figcaption></figure>
<p>Autonomous systems need to detect and adapt to different environments. These systems rely on sophisticated sensors, cameras, and large amounts of labeled and diverse real-world datasets (which are difficult to acquire). Take, for example, the task of autonomously following a man-made trail that is traversed by hikers or mountain bikers. This is a mostly unsolved task for robotics, but yet an important one for applications like search and rescue.</p>
<p>While many types of robots (such as the quadrupedal robot) can be efficient at locomotion, successfully navigating real-world forest trails is hard. Apart from the mechanics of the problem, perceiving real-world trails is difficult. The appearance of the wilderness area may vary a lot depending on the location, unpaved roads generally have less structure (and tend to blend in with the surrounding grass areas, vegetation, and such), and trails change over time. It would be impossible to have a comprehensive dataset of all trails, in all weather and lighting conditions.</p>
<p>In such cases, a possible solution is to cast the trail perception problem as an image classification task and adopt an invariance based approach that operates directly on the image’s raw pixel values. Successful application could allow for out-of-distribution generalization to new trails, since the features learned are more transferable than environment-specific signals. Naturally, similar ideas are relevant for autonomous vehicles in urban areas.</p>
<h4 id="activity-recognition-systems">Activity recognition systems</h4>
<p>Smart devices (phones, watches, fitness trackers) carry a large array of sensors: accelerometers, gyroscopes, magnetometers, barometers, ambient lights sensors, and many more. Categorizing this data by the activity being performed at the time of recording - such as sitting, standing, or swimming - has allowed for the development of machine learning-based human-activity recognition systems. Correctly predicting a wearer’s activity enables a host of contextual applications, in particular in (but not restricted to) the health and wellness space.</p>
<p>Unfortunately, it is hard to satisfactorily model this data due to the diversity exhibited in the real world. A single individual can perform a given activity slightly differently day-to-day, or the device may be unusually placed, or held or worn in a variety of orientations. Of course, different users are also physically diverse, and devices have intrinsic differences in their sensors and systems. This means that we either need a labeled dataset that captures the activity for each user and device (which is prohibitively expensive) or another way of identifying attributes that generalize better. Methods based on invariance could be particularly useful and well-suited in this scenario, capturing the essence of “sitting,” rather than the particular sensor activations for a particular user sitting on a particular chair.</p>
<h4 id="natural-language-processing">Natural language processing</h4>
<figure><img src="https://ff13.fastforwardlabs.com/figures/ff13-25.png" alt="Environments are everywhere. For instance, different sources of natural language."/><figcaption>Environments are everywhere. For instance, different sources of natural language.</figcaption></figure>
<p>Invariant prediction approaches are of course not restricted exclusively to image problems. In natural language processing, texts from different publication platforms are tricky to analyze due to different contexts, vocabularies, and differences between how authors express themselves. For instance, financial news articles use a vocabulary and tone that differs from culture or society articles. The former is likely terse, whereas the latter may have an entertaining or personal tone. Similarly, online product reviews are linguistically different from tweets. Sentiment classification also relies heavily on context; different words are used to express whether someone likes a book versus an electronic gadget.</p>
<p>Two recent papers, <a href="https://arxiv.org/abs/2004.05007">An Empirical Study of Invariant Risk Minimization</a> and <a href="https://arxiv.org/abs/2003.09772">Invariant Rationalization</a>, apply the idea of IRM to a sentiment classification task, and find it improves out-of-distribution generalization. In particular, invariance acts to remove spurious reliance on single words which correlate highly with the target. Like images, text corpora form very high-dimensional datasets (there are many possible words!), making spurious correlations extremely unlikely to be noticed “manually.” As such, invariance based approaches are especially promising here.</p>
<h4 id="recommender-systems">Recommender systems</h4>
<figure><img src="https://ff13.fastforwardlabs.com/figures/ff13-24.png" alt="The data a recommender system collects is inherently biased by the suggestions it makes. We can untangle this bias with causal inference."/><figcaption>The data a recommender system collects is inherently biased by the suggestions it makes. We can untangle this bias with causal inference.</figcaption></figure>
<p>Recommendation systems are algorithms designed to present relevant items to users on the web (for example, suggesting which movie to watch, a book to read, or a product to buy). As such, making good recommendations is an important problem: we want to make relevant recommendations for a user based on a record of their historical activities, from which we must infer their preferences.</p>
<p>The training data is either explicit (e.g., a rating a user left on a book) or implicit (e.g., linger time on a webpage or click data). There is a well-known exposure problem in recommender systems: a user simply cannot click on an item with which they have not been presented. Modeling the data without accounting for this is akin to the assumption of independent and identically distributed data, and is false: users do not select items randomly and independently of one another. For instance, a user may choose between two competing movies to watch, rather than selecting whether to watch each independently.</p>
<p>RecSys are a classic application for causality, which allows us to correct for this exposure bias by treating the selection of items to present to a user as an intervention. Applying causal approaches to recommendation naturally improves generalization to new data, and it seems likely that methods using invariant prediction could enhance this.</p>
<h3 id="tools">Tools</h3>
<p>The invariance-based approaches to causality we have discussed do not require dedicated tooling - ICP and IRM are procedures that could be implemented with general purpose machine learning frameworks.</p>
<p>Nonetheless, the authors of the ICP papers  provide corresponding R packages: <a href="https://cran.r-project.org/web/packages/InvariantCausalPrediction/index.html">InvariantCausalPrediction</a> and <a href="https://cran.r-project.org/web/packages/nonlinearICP/index.html">nonlinearICP</a>. The packages make the techniques easy to use, and include additional utilities, such as dedicated plots for confidence intervals on causal coefficients. We are not aware of a package for IRM, but the authors have provided a <a href="http://github.com/facebookresearch/InvariantRiskMinimization/">code repository</a> which reproduces the paper results.</p>
<p>Below, we list a handful of open source projects that aid in traditional, SCM-based causal inference.</p>
<h4 id="dowhy">DoWhy</h4>
<p>Microsoft Research is developing the <a href="https://microsoft.github.io/dowhy/">DoWhy</a> python library for causal inference, incorporating elements of both causal graphical models and potential outcomes. The library is oriented around pandas DataFrames, and fits easily into a Python data analysis workflow. In particular, DoWhy makes a separation between four stages of causal inference:</p>
<ol>
<li>Modeling - defining a causal graph, or else the assumptions necessary for a potential outcomes approach (the common causes of the treatment and the outcome variable).</li>
<li>Identification - identifying the expression it is necessary to evaluate, in terms of conditional probability distributions.</li>
<li>Estimation - estimating the treatment effect. There are many estimation methods available in DoWhy, including machine learning-based methods from another of Microsoft’s causal libraries: <a href="https://github.com/microsoft/EconML">EconML</a>.</li>
<li>Refutation - assessing the robustness of the conclusion. Given the reliance of causal inference on modeling assumptions, it is especially important to find ways to test our conclusions. DoWhy provides several methods for this, such as introducing a dummy common cause or replacing the treatment with a random placebo.</li>
</ol>
<p>In addition to the above, DoWhy includes a novel algorithm, the “do-sampler.” In much of causal inference, the quantity of interest is a single number - for instance, the difference in the outcome variable when a binary treatment variable is applied (“what is the average causal effect of smoking on cancer incidence?”). The do-sampler extends the pandas DataFrame API directly, and moves beyond calculating causal effects to allow sampling from the full interventional distribution. Having done so, we can then compute arbitrary statistics under this intervention. The do-sampler is new, but provides a very promising direction for further research, and a potential avenue to making causal inference accessible to many more data science practitioners.</p>
<h4 id="causaldiscoverytoolbox">CausalDiscoveryToolbox</h4>
<p>The <a href="https://fentechsolutions.github.io/CausalDiscoveryToolbox/html/index.html">Causal Discovery Toolbox</a> provides implementations of many algorithms designed for causal discovery - attempting to recover the full causal graph from observational data alone. There are many approaches to causal discovery, and the library is relatively comprehensive, including algorithms for pairwise causal discovery (inferring the direction of causation between a pair of variables), graph skeleton creation (creating an undirected graph of potential causal relationships), and full graphical causal model discovery.</p>
<p>Discovery of entire causal graphs does not yet appear mature enough that we can naively trust its conclusions about the causal structure of a problem. This makes sense, given the difficulty of the task! Inferring the whole causal structure from only observational data is about the hardest imaginable problem we could face with data.</p>
<h4 id="causalnex">CausalNex</h4>
<p><a href="https://causalnex.readthedocs.io/en/latest/">CausalNex</a> is a very recently released (at time of writing) toolkit by QuantumBlack to help data scientists do causal reasoning. It provides both a graph structure learning component to help build the causal graph and tools to fit that graph as a Bayesian network.</p>
<p>The structure learning component is an implementation of <a href="https://arxiv.org/abs/1803.01422">DAGs with NOTEARS</a>, an algorithm that casts structure learning as a continuous optimization problem. In its simplest form, it assumes linear relationships between variables (but unlike some causal discovery methods, does not assume Gaussian noise). Further, the algorithm assumes that all variables are observed (i.e., there is data for all variables). Unfortunately, this is rarely the case in causal problems.</p>
<p>Within these limitations, the algorithm is performant, and allows the user to specify hard constraints (such as, “these variables cannot be child nodes,” or “there is no causal relationship between these two variables”). This facilitates directly encoding domain knowledge into the graph, and using the structure learning component as an aid in places where the causal connection is not known.</p>
<h4 id="pyro">Pyro</h4>
<p>Uber’s <a href="http://pyro.ai/">Pyro</a> probabilistic programming library is primarily intended for implementing deep probabilistic models and fitting them with variational inference. However, in addition to tools for conditioning on observed data, the library implements a do operation to force a variable to take a certain distribution. This allows simulating from interventional distributions, provided the structural causal model (including equations) is known. The intersection of probabilistic programming with causal inference is nascent, but promising!</p>
<h2 id="ethics">Ethics</h2>
<p>Machine learning is playing an increasingly critical role in our society. Decisions that were previously exclusively made by humans are more frequently being made algorithmically. These algorithmic systems govern everything from which emails reach our inboxes, to whether we are approved for credit, to whom we have the opportunity to date – and their impact on our experience of the world is growing. Furthermore, our understanding of how these systems work is still lacking. We can neither explain nor correct them when their predictions are unfairly discriminatory or their outputs are reinforcing existing biases. Causal reasoning gives us a framework for thinking about these problems.</p>
<h3 id="causal-graphs-make-assumptions-explicit">Causal graphs make assumptions explicit</h3>
<p>Even without employing the full machinery of causal inference, when one approaches a new problem, it can be informative to try to write down the causal graph. This forces us to confront our assumptions about a system. It also allows someone else to understand our assumptions, and furnishes a precise framework for debate.</p>
<figure><img src="https://ff13.fastforwardlabs.com/figures/ff13-22.png" alt="Writing down a causal graph provides a principled way to specify and discuss causal assumptions."/><figcaption>Writing down a causal graph provides a principled way to specify and discuss causal assumptions.</figcaption></figure>
<p>Making our assumptions explicit aids transparency, which is a win. However, it doesn’t protect against bad assumptions. Establishing causal relationships is hard. Unless we are able to perform sufficient experiments to validate our hypotheses, causal reasoning from observational data is subject to untested (sometimes untestable) assumptions.</p>
<p>We should make any causal claim with humility. As ever, we should be careful of dressing up a bad analysis with additional formalism.</p>
<h3 id="omitting-protected-attributes-is-not-enough">Omitting protected attributes is not enough</h3>
<p>It is unethical, and in many places illegal, to discriminate on the basis of a protected attribute, such as age, race, or disability. Avoiding <em>direct</em> discrimination (whereby some individuals with particular protected attributes are treated unfavourably) is comparatively easy. Appropriately, these protected attributes are frequently omitted from machine learning systems. Using a protected attribute as a feature directly is inviting discrimination based on that attribute.</p>
<p>More difficult to detect and avoid is <em>indirect causal discrimination</em>. Many features that are not themselves protected attributes are nonetheless highly predictive of a protected attribute. For instance, geographic location can correlate very highly with race, religion, and age. In denying loans to any individual with a particular zipcode, a bank could be committing indirect, but very real, discrimination against a protected attribute.</p>
<p>Another sub-category of discrimination is <em>indirect spurious discrimination</em>. These are instances when there are no pathways from causal attributes to the outcome. However, as we saw in <a href="#from-correlation-to-causation">From correlation to causation</a>, correlations can arise from numerous causal structures. As such, merely omitting the protected attribute does not omit its effects. A system is not guaranteed to be non-discriminatory on a protected attribute simply because it does not include that attribute directly. More simply, just because a feature does not cause the target does not mean that it will not be predictive of the target. This presents a particular challenge to algorithmic systems that are designed to find subtle correlations, especially since much historical data on which algorithms are trained is subject to selection bias (and other biases).</p>
<p>Since removing protected attributes is not enough, we must evaluate the resulting model for its discrimination and fairness properties. There are many possible measures of fairness, and it is generally impossible to optimize for all of them.</p>
<p>Several recent papers, for instance) have proposed causality as a route to understanding and defining fairness and discrimination. In particular, if we have a causal graphical model of a system, we can see which paths are impacted by protected attributes, and correctly account for that impact. There have also been contributions in non-parametric structural causal models that allow one to detect and distinguish the three main discriminations - namely, direct, indirect and spurious.</p>
<p>That said, the difficulty lies in constructing the causal graph. A causal graph could, of course, be used to embed all kinds of biases and prejudices, but at least provides a basis for argument.</p>
<h3 id="invariance-as-a-route-to-fairness">Invariance as a route to fairness</h3>
<p>An interesting idea is proposed in the final section of the IRM paper: treating groups over which we want fairness as the environments. When we seek to learn an invariant model (be that by ICP or IRM), we are explicitly trying to learn a model that performs optimally in different environments. We could construct those environments by separating out groups having different values for protected attributes. Then, by learning a model that seeks to perform optimally in each environment, we are explicitly trying to guarantee the best performance for each protected attribute.</p>
<p>Said differently, invariant features are exactly those that are consistent across groups. Consider again a bank granting loans, this time directly to individuals. The bank does not wish to discriminate on the basis of protected attributes. By treating the protected attributes as the groups, they are looking to learn what impacts loan defaulting invariantly across those groups.</p>
<p>The idea of learning an invariant predictor across environments is that the representation used is capturing something true about the generative process of the data. This representation would be, to some degree, <em>disentangled</em>, in the sense that each dimension of the representation (a vector) should correspond to something meaningful. <a href="https://arxiv.org/abs/1905.13662">On the Fairness of Disentangled Representations</a> shows experimentally that disentangled representations improve fairness in downstream uses.</p>
<h2 id="future">Future</h2>
<p>At the outset, causal reasoning provides a conceptual and technical framework for addressing questions about the effect of real or hypothetical actions or <em>interventions</em>. Once we understand what the effect of an action is, we can turn the question around and ask what action plausibly caused an event. This gives us a formal language to talk about cause-and-effect. That said, not every question about cause is easy to answer. Further, it may not be a trivial task to find an answer or even to interpret it. Causal graphs that we discuss in the <a href="#background%3A-causal-inference">Background: Causal Inference</a> chapter provide a convenient way to discuss these notions, and allow us to reason about statistical dependencies in observed data.</p>
<p>Structural causal models take a step further to this intuitive way of reasoning by making formal assumptions about the parametric form of how the variables interact.</p>
<p>However, causal graphs and SCMs become difficult to construct as the number of variables increases. Some systems are hard to model in this way. How do we draw a causal graph for pixels of an image? Or words in text? The problem gets out of hand quickly.</p>
<p>Fortunately, not all problems require the entire causal graph. Often, we are interested only in the causal relations associated with one particular target variable. This is where methods based on invariance (like IRM) step in to allow the model to capture stable features across environments (that is, different data generating processes). This paradigm enables out-of-distribution generalization. As opposed to causal graphs or structural causal models, where the only way to validate assumptions of the variable interactions is through experimentation, IRM allows us to test them on an unseen test set!</p>
<h3 id="comparable-approaches">Comparable approaches</h3>
<p>So, at this point we probably agree that methods based on invariance are promising. How else might we approach out-of-distribution generalization? In general, there are two families of approaches; those that learn to match the feature distributions (or estimate a data representation) and those that employ some kind of optimization technique.</p>
<h4 id="domain-adaptation">Domain adaptation</h4>
<p>Domain adaptation is a special case of transfer learning. In domain adaptation, the model learns a task in a source domain, which has some feature distribution, and we would like it to be able to perform the same task well in a target domain, where the feature distribution is different. Domains play the same role as environments in invariance-based approaches; a source domain is an environment that was trained in, and a target domain is any environment that was not trained in.</p>
<p>Domain adaptation also enforces a kind of invariance - it seeks a representation that is distributed the same across source and target domains (so, across environments). However, truly invariant, causal features need not follow the same distribution in different environments. A snowy cow will not generate quite the same pixel distribution as a sandy cow, and the causal feature we wish to represent is the cow itself.</p>
<h4 id="robust-learning">Robust learning</h4>
<p>The idea of learning across multiple environments is not novel to invariance-based approaches. <a href="https://www.aaai.org/Library/AAAI/2005/aaai05-112.php">Robust Supervised Learning</a> is a family of techniques that uses the same multi-environment setup as IRM (but much predates it), with a similar goal of enabling or enhancing out-of-distribution generalization. Said differently, the goal is a predictor that is robust to distributional shifts of the inputs.</p>
<p>The difference from the IRM setup we have covered is the loss function. The key idea is to add environment-specific “baseline” terms to the loss, and try to fix these terms such that particularly noisy environments where the loss may be high do not dominate. Then, minimizing the loss should guarantee good performance across all the known environments. Further, a robust predictor will perform well in new environments that are interpolations of those seen in training. This certainly improves out-of-distribution generalization, but does not allow <em>extrapolation</em> outside of what was seen in training, whereas IRM can extrapolate, thanks to relying on an invariant predictor.</p>
<h4 id="meta-learning">Meta-learning</h4>
<p>Approaches like domain adaptation, robust learning, and (in general) transfer learning try to alleviate the problem of out-of-distribution generalization to some extent. Unfortunately, learning invariant features with varying distributions across environments is still challenging. These approaches are good at interpolation, but not extrapolation.</p>
<p>This is where meta-learning approaches like Model Agnostic Meta Learning (MAML) come into play. The underlying idea for meta-learners generally is to attempt to learn tasks with a small number of labeled examples. Training meta-learners is a two-step process involving a <em>learner</em> and a <em>trainer</em>. The goal of the learner (model) is to quickly learn new tasks from a small amount of new data; hence, it is sometimes called a <em>fast learner</em>. (A task here refers to any supervised machine learning problem - e.g., predicting a class given a small number of examples.) This learner is trained, by the meta-learner, to be able to learn from a large number of different tasks. The meta-learner accomplishes this by repeatedly showing the learner hundreds and thousands of different tasks.</p>
<p>Learning then, happens at two levels. The first level focuses on quick acquisition of knowledge within each task with a few examples. The second level slowly pulls and digests information across all tasks. In case of MAML (which is optimization-based), the learner (or the first level) can achieve an optimal fast learning on a new task with only a small number of gradient steps because the meta-learner provides a good initialization of a model’s parameters. This approach is close to the problem of learning an optimal classifier in multiple environments, and could be explored further to learn invariant features within the data.</p>
<p>Some recent works have made the connection between causality and meta-learning explicitly.</p>
<h3 id="looking-ahead">Looking ahead</h3>
<p>In this section, we discuss future possibilities with causality in general, as well as with methods based on invariance.</p>
<h4 id="causal-reinforcement-learning">Causal Reinforcement Learning</h4>
<p>Reinforcement learning is the study of how an agent can learn to choose actions that maximize its future rewards in an interactive and uncertain environment. These agents rely on plenty of simulations (and sometimes real data) to learn which actions lead to high reward in a particular context. Causality is also about calculating the effect of actions, and allows us to transfer knowledge to new, unfamiliar situations. These two disciplines have evolved independently with little interaction between them until recently. Integrating them is likely to be a fruitful area of research, and may extend the reach of both causality and reinforcement learning.</p>
<p>There is a natural mapping between the concept of intervention in causal inference and actions taken in reinforcement learning. Throughout an episode of reinforcement learning (an episode is formed of one run of the system, for example, a complete game of chess, or go), an agent takes actions. This defines a data generating process for the reward that the agent ultimately cares about; different sequences of actions will generate different rewards. Since the agent can choose its actions, each of them is an intervention in this data generating process. In making this connection, we can leverage the mathematics of causal inference. For instance, we could use counterfactuals, the third level of the <a href="#the-ladder-of-causation">The ladder of causation</a>, to reason about actions not taken. Applying such causal techniques may reduce the state space the agent needs to consider, or help account for confounders.</p>
<p>Methods based on invariance, like IRM, in principle, learn to discover unknown invariances from multiple environments. We could leverage this attribute in reinforcement learning. An episode of RL consists of all the states that fall in between an initial state and a terminal state. Since each episode is independent of another, in IRM terminology they could be viewed as different environments. An agent could then learn robust policies from each of these episodes that leverage the invariant part of behaviour or actions that lead to reward.</p>
<p>While reinforcement learning itself is still in nascent stages when it comes to commercial applications, combining it with causality offers great potential. But prior to that, we need to address some questions. For example, how do we combine programming abstractions in causal modeling with reinforcement learning to help find the best decisions? What tools and libraries are necessary to enable commercial applications in this space?</p>
<h4 id="irm-and-environments">IRM and environments</h4>
<p>IRM uses the idea of training in multiple environments to achieve out-of-distribution generalization. Unfortunately, few datasets come with existing environment annotations. There are at least two ways we can try to address this problem.</p>
<p>The first is to be mindful of the environment when collecting data, and collect metadata alongside it. This may be easy (for example, collecting the geo-location of photos in settings where this is possible and does not violate a user’s privacy), or extremely hard (requiring much post-collection manual labeling).</p>
<p>Another compelling but untested option is to try combining IRM with some sort of clustering to segment a single dataset into environments. The question would be how to cluster in such a way that meaningful and diverse environments are defined. Since existing clustering approaches are purely correlative, and - as such - vulnerable to spurious correlations, this could prove challenging.</p>
<p>Studying the impact of environment selection, and how to create or curate datasets with multiple environments would be a valuable contribution to making invariance-based methods more widely applicable. (The authors of <a href="https://deepai.org/publication/an-empirical-study-of-invariant-risk-minimization">An Empirical Study of Invariant Risk Minimization</a> reach the same conclusion.)</p>
<h4 id="causal-reasoning-for-algorithmic-fairness">Causal reasoning for algorithmic fairness</h4>
<p>In the <a href="#ethics">Ethics</a> chapter, we reviewed some notions of fairness in prediction problems and shared how tools of causal reasoning can be leveraged to address fairness. They depart in the traditional way of wholly relying on data-driven approaches and emphasize the need to require additional knowledge of the structure of the world, in the form of a causal model. This additional knowledge is particularly valuable, as it informs us how changes in variables propagate in a system (be it natural, engineered, or social). Explicit causal assumptions remove ambiguity from methods that just depend upon statistical correlations. Avoiding discrimination through causal reasoning is an active area of research. As efforts to aid more transparency and fairness in machine learning systems grow, causal reasoning will continue to gain significant momentum in guiding algorithms towards fairness.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Structural causal models give us a framework for thinking precisely about cause and effect, and encoding our assumptions about data generating processes. Knowing the complete model for a system is immensely powerful, allowing us to reason about how the system will behave when we intervene in the data generating process, and correct for selection biases.</p>
<p>In machine learning, we’re often concerned only with prediction, for which we do not need causal inference. However, even in this scenario, taking a causal approach brings some benefits. Notably, causal relationships are invariant (they do not change between environments) and when we learn predictors based on them, we get greatly improved out-of-distribution generalization.</p>
<p>For many problems, constructing a causal graph is prohibitively hard, and always relies on assumptions. When working with only observational data, these assumptions are especially important, since they cannot be validated through experiments. Fortunately, by relying on the correspondence between causal relationships and invariance, we can still construct the relevant part of the causal graph for some problems using <a href="#invariant-causal-prediction">Invariant Causal Prediction</a>. For high dimensional inputs like image and text, we can use <a href="#invariant-risk-minimization">Invariant Risk Minimization</a> to learn a predictor that greatly enhances our out-of-distribution performance by learning not to rely on dataset-specifc spurious correlations.</p>
<p>Research at the intersection of causality and machine learning is blossoming, with many major ML conferences hosting dedicated workshops on the topic. Invariance-based approaches are an especially promising development and are ripe for industrial application. As algorithmic systems become increasingly prevalent, and their influence on decisions grows, the need for causal reasoning becomes all the more acute. We think it is important that practitioners have an understanding of causality, and hope to see causal approaches gain significant traction in mainstream data science practice. We hope this report has sparked some causal curiosity in you!</p>



        </div></div>
  </body>
</html>
