<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://martinmelhus.com/web-audio-modem/">Original</a>
    <h1>Web Audio Modem (2017)</h1>
    
    <div id="readability-page-1" class="page"><section><h2>Motivation</h2>
<p>Lately, I&#39;ve been working with a client where my development computer is not
connected to the Internet. This is a huge inconvenience, as the unavailability
of Google and Stack Overflow vastly impact my productivity. Only recently have I
begun to grasp how much of my time is actually spent copy/pasting between Visual
Studio and the browser.</p>
<p>My office also features an Internet connected laptop and my development computer
expose 3,5 mm jack sockets for audio devices. And thus my problems can be
solved! Here&#39;s how I made a modem for closing the gap with Web Audio.</p>
<p><strong>PS</strong> If you just want to try the modem already, head over to the
<a href="https://martme.github.io/webaudio-modem">live demo</a>. Also check out the source
code on <a href="https://github.com/martme/webaudio-modem">github</a>.</p>
<h2>HTML5 to Modem</h2>
<p>Our modern era copy/paste implementation will be based on the
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API">Web Audio API</a>
which
<a href="http://caniuse.com/#search=web%20audio">is supported by all major browsers</a>.
Most notably we&#39;ll leverage instances of
<a href="https://developer.mozilla.org/en/docs/Web/API/OscillatorNode"><code>OscillatorNode</code></a>
to encode data as an audio signal composed of sinusoids at preselected
frequencies. The audio signal is decomposed using an
<a href="https://developer.mozilla.org/en/docs/Web/API/AnalyserNode"><code>AnalyserNode</code></a> in
our gap-closing endeavor.</p>
<h3>Modulation</h3>
<p>We can convert characters to integer values using ASCII encoding. Our encoding
problem can thus be reduced to encoding values in the range 0 through 127.</p>
<p>With distinct frequencies, <code>f<sub>0</sub></code> through
<code>f6</code> we can encode the bits comprising a 7-bit signal. We
let <code>f<sub>i</sub></code> be included in the encoded number <code>n</code> if
<code>n &amp; (1 &lt;&lt; i)</code>, i.e. the bit at position <code>i</code> from the least significant bit in
the binary representation of <code>n</code> equals <code>1</code>.</p>
<p><span>
      <a href="https://martinmelhus.com/static/196a5791e31e3d2d7a57b1fc9d13f2a8/0ad97/webaudio-spectrum.png" target="_blank" rel="noopener">
    <span></span>
  <img alt="Frequency spectrum resulting from encoding the character &#39;a&#39; (0b1100001)" title="Frequency spectrum resulting from encoding the character &#39;a&#39; (0b1100001)" src="https://martinmelhus.com/static/196a5791e31e3d2d7a57b1fc9d13f2a8/0ad97/webaudio-spectrum.png" srcset="/static/196a5791e31e3d2d7a57b1fc9d13f2a8/772e8/webaudio-spectrum.png 200w,
/static/196a5791e31e3d2d7a57b1fc9d13f2a8/e17e5/webaudio-spectrum.png 400w,
/static/196a5791e31e3d2d7a57b1fc9d13f2a8/0ad97/webaudio-spectrum.png 717w" sizes="(max-width: 717px) 100vw, 717px" loading="lazy"/>
  </a>
    </span></p>
<h3>Demodulation</h3>
<p>The decoding party knows which frequencies are used by the encoder. Figuring out
if these are present in a recorded signal is done by applying a
<a href="https://betterexplained.com/articles/an-interactive-guide-to-the-fourier-transform/">Fourier transform</a>
to the input signal. Significant peaks in the resulting frequency bins indicates
which frequencies are in fact present in the recorded signal, and we can map
these bins to the known frequencies.</p>
<p>Luckily, the Web Audio API handles all the complexities of digital signal
processing for us via the <code>AnalyserNode</code>.</p>
<h3>Parameters</h3>
<p>We can find the sampling rate of our <code>AnalyserNode</code> via the <code>sampleRate</code>
property on our <code>AudioContext</code>.</p>
<div data-language="js"><pre><code><span>var</span> audioContext <span>=</span> <span>new</span> <span>AudioContext</span><span>(</span><span>)</span>
<span>var</span> sampleRate <span>=</span> audioContext<span>.</span>sampleRate </code></pre></div>
<p>This means that we&#39;ll be able to analyze frequencies up to <code>22050 Hz</code>, half of
the sampling rate. Using a <code>fftwSize</code> (window size in the Fourier transform) of
<code>512</code> yields <code>256</code> frequency bins, each representing a range of approximately
<code>86.1 Hz</code>. The gap between our chosen frequencies should far exceed this value.
We select the following frequencies <code>f<sub>0</sub></code> through
<code>f7</code>, activated by the associated bitmask.</p>
<table>
<thead>
<tr>
<th>Bit</th>
<th>Bit mask</th>
<th>Frequency (Hz)</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0000000<strong>1</strong></td>
<td>392</td>
</tr>
<tr>
<td>1</td>
<td>000000<strong>1</strong>0</td>
<td>784</td>
</tr>
<tr>
<td>2</td>
<td>00000<strong>1</strong>00</td>
<td>1046.5</td>
</tr>
<tr>
<td>3</td>
<td>0000<strong>1</strong>000</td>
<td>1318.5</td>
</tr>
<tr>
<td>4</td>
<td>000<strong>1</strong>0000</td>
<td>1568</td>
</tr>
<tr>
<td>5</td>
<td>00<strong>1</strong>00000</td>
<td>1864.7</td>
</tr>
<tr>
<td>6</td>
<td>0<strong>1</strong>000000</td>
<td>2093</td>
</tr>
<tr>
<td>7</td>
<td><strong>1</strong>0000000</td>
<td>2637</td>
</tr>
</tbody>
</table>
<h2>Implementation</h2>
<p>If you want to see the modem in action, check out this
<a href="https://martme.github.io/webaudio-modem/encoder.html">live of the version encoder</a>.
The corresponding decoder can be found
<a href="https://martme.github.io/webaudio-modem/decoder.html">here</a>.</p>
<p>The source code for the live version is available on
<a href="https://github.com/martme/webaudio-modem/">GitHub</a>.</p>
<h3>Encoder</h3>
<p>First, we need to initialize an audio context. We also create a master gain
node, and set the gain to 1.</p>
<div data-language="js"><pre><code><span>let</span> audioContext <span>=</span> <span>new</span> <span>AudioContext</span><span>(</span><span>)</span>
<span>let</span> masterGain <span>=</span> audioContext<span>.</span><span>createGain</span><span>(</span><span>)</span>
masterGain<span>.</span>gain<span>.</span>value <span>=</span> <span>1</span></code></pre></div>
<p>Next up is setting up an oscillator for each of the frequencies, producing a
sinusoid at the given frequency.</p>
<div data-language="js"><pre><code><span>const</span> frequencies <span>=</span> <span>[</span><span>392</span><span>,</span> <span>784</span><span>,</span> <span>1046.5</span><span>,</span> <span>1318.5</span><span>,</span> <span>1568</span><span>,</span> <span>1864.7</span><span>,</span> <span>2093</span><span>,</span> <span>2637</span><span>]</span>

<span>let</span> sinusiods <span>=</span> frequencies<span>.</span><span>map</span><span>(</span><span>f</span> <span>=&gt;</span> <span>{</span>
  <span>let</span> oscillator <span>=</span> audioContext<span>.</span><span>createOscillator</span><span>(</span><span>)</span>
  oscillator<span>.</span>type <span>=</span> <span>&#34;sine&#34;</span>
  oscillator<span>.</span>frequency<span>.</span>value <span>=</span> f
  oscillator<span>.</span><span>start</span><span>(</span><span>)</span>
  <span>return</span> oscillator
<span>}</span><span>)</span></code></pre></div>
<p>Now, we need some means to switch the oscillators on and off, depending on the
input signal. We can do this by connecting each of the oscillators to a
dedicated gain node, utilizing the <code>volume</code> property of the gain node to control
the oscillator.</p>
<div data-language="js"><pre><code><span>let</span> oscillators <span>=</span> frequencies<span>.</span><span>map</span><span>(</span><span>f</span> <span>=&gt;</span> <span>{</span>
  <span>let</span> volume <span>=</span> audioContext<span>.</span><span>createGain</span><span>(</span><span>)</span>
  volume<span>.</span>gain<span>.</span>value <span>=</span> <span>0</span>
  <span>return</span> volume
<span>}</span><span>)</span></code></pre></div>
<p>To connect everything, we pass the oscillator&#39;s output <code>sinusoids[i]</code> to the
corresponding gain node <code>oscillators[i]</code> and the send the output of all the gain
nodes to the master gain node <code>masterGain</code>. Lastly, we send the output from
<code>masterGain</code> to the system audio playback device, referenced by the
<code>destination</code> property of the <code>AudioContext</code> instance.</p>
<div data-language="js"><pre><code>sinusoids<span>.</span><span>forEach</span><span>(</span><span>(</span><span>sine<span>,</span> i</span><span>)</span> <span>=&gt;</span> sine<span>.</span><span>connect</span><span>(</span>oscillators<span>[</span>i<span>]</span><span>)</span><span>)</span>
oscillators<span>.</span><span>forEach</span><span>(</span><span>osc</span> <span>=&gt;</span> osc<span>.</span><span>connect</span><span>(</span>masterGain<span>)</span><span>)</span>
masterGain<span>.</span><span>connect</span><span>(</span>audioContext<span>.</span>destination<span>)</span></code></pre></div>
<h4>Encoding</h4>
<p>The character <code>a</code> has character code 97 which equals <code>0b1100001</code>. As for our
encoder, this means that the oscillators at index 0, 1 and 6 should be active
when encoding this value.</p>
<p>To retrieve the active oscillators for a given value we have the implement the
<code>char2oscillators</code> function.</p>
<div data-language="js"><pre><code><span>const</span> <span>char2oscillators</span> <span>=</span> <span>char</span> <span>=&gt;</span> <span>{</span>
  <span>return</span> oscillators<span>.</span><span>filter</span><span>(</span><span>(</span><span>_<span>,</span> i</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>let</span> charCode <span>=</span> char<span>.</span><span>charCodeAt</span><span>(</span><span>0</span><span>)</span>
    <span>return</span> charCode <span>&amp;</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> i<span>)</span>
  <span>}</span><span>)</span>
<span>}</span></code></pre></div>
<p>Now that we&#39;ve identified which oscillators to activate, we can create a
function that encodes individual characters. The <code>mute</code> function is used to
silence all oscillators between each character transmission.</p>
<div data-language="js"><pre><code><span>const</span> <span>mute</span> <span>=</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  oscillators<span>.</span><span>forEach</span><span>(</span><span>osc</span> <span>=&gt;</span> <span>{</span>
    osc<span>.</span>gain<span>.</span>value <span>=</span> <span>0</span>
  <span>}</span><span>)</span>
<span>}</span>
<span>const</span> <span>encodeChar</span> <span>=</span> <span>(</span><span>char<span>,</span> duration</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>let</span> activeOscillators <span>=</span> <span>char2oscillators</span><span>(</span>char<span>)</span>
  activeOscillators<span>.</span><span>forEach</span><span>(</span><span>osc</span> <span>=&gt;</span> <span>{</span>
    osc<span>.</span>gain<span>.</span>value <span>=</span> <span>1</span>
  <span>}</span><span>)</span>

  window<span>.</span><span>setTimeout</span><span>(</span>mute<span>,</span> duration<span>)</span>
<span>}</span></code></pre></div>
<p>Combining the pieces, we end up with the following function to encode strings of
text.</p>
<div data-language="js"><pre><code><span>const</span> <span>encode</span> <span>=</span> <span>text</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> pause <span>=</span> <span>50</span>
  <span>const</span> duration <span>=</span> <span>150</span>
  
  <span>const</span> timeBetweenChars <span>=</span> pause <span>+</span> duration

  text<span>.</span><span>split</span><span>(</span><span>&#34;&#34;</span><span>)</span><span>.</span><span>forEach</span><span>(</span><span>(</span><span>char<span>,</span> i</span><span>)</span> <span>=&gt;</span> <span>{</span>
    window<span>.</span><span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>encodeChar</span><span>(</span>char<span>,</span> duration<span>)</span>
    <span>}</span><span>,</span> i <span>*</span> timeBetweenChars<span>)</span>
  <span>}</span><span>)</span>
<span>}</span></code></pre></div>
<h3>Decoder</h3>
<p>The decoder must use the same set of frequencies as the encoder. We start by
initializing the audio context as well as an analyzer node. We set the
<code>smoothingTimeConstant</code> of the analyzer node to <code>0</code> to ensure that the analyzer
only carry information about the most recent window. The <code>minDecibels</code> property
is set to <code>-58</code> which helps to improve the signal-to-noise ratio by reducing the
amount of background noise accounted for by the analyzer.</p>
<div data-language="js"><pre><code><span>const</span> frequencies <span>=</span> <span>[</span><span>392</span><span>,</span> <span>784</span><span>,</span> <span>1046.5</span><span>,</span> <span>1318.5</span><span>,</span> <span>1568</span><span>,</span> <span>1864.7</span><span>,</span> <span>2093</span><span>,</span> <span>2637</span><span>]</span>

<span>let</span> audioContext <span>=</span> <span>new</span> <span>AudioContext</span><span>(</span><span>)</span>
<span>let</span> analyser <span>=</span> audioContext<span>.</span><span>createAnalyser</span><span>(</span><span>)</span>
analyser<span>.</span>fftSize <span>=</span> <span>512</span>
analyser<span>.</span>smoothingTimeConstant <span>=</span> <span>0.0</span>
analyser<span>.</span>minDecibels <span>=</span> <span>-</span><span>58</span></code></pre></div>
<p>Next up, connect the microphone input to the analyzer node.</p>
<div data-language="js"><pre><code>navigator<span>.</span><span>getUserMedia</span><span>(</span>
  <span>{</span> audio<span>:</span> <span>true</span> <span>}</span><span>,</span>
  <span>stream</span> <span>=&gt;</span> <span>{</span>
    <span>var</span> microphone <span>=</span> audioContext<span>.</span><span>createMediaStreamSource</span><span>(</span>stream<span>)</span>
    microphone<span>.</span><span>connect</span><span>(</span>analyser<span>)</span>
  <span>}</span><span>,</span>
  <span>err</span> <span>=&gt;</span> <span>{</span>
    console<span>.</span><span>error</span><span>(</span><span>&#34;[error]&#34;</span><span>,</span> err<span>)</span>
  <span>}</span>
<span>)</span></code></pre></div>
<p>The analyzer will require a buffer to store frequency bin data, so we introduce
a buffer for the cause. The following utility function is used to decide which
bin corresponds to a given frequency, and returns the value of the corresponding
bin.</p>
<div data-language="js"><pre><code><span>let</span> buffer <span>=</span> <span>new</span> <span>Uint8Array</span><span>(</span>analyser<span>.</span>frequencyBinCount<span>)</span>

<span>const</span> <span>frequencyBinValue</span> <span>=</span> <span>f</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> hzPerBin <span>=</span> audioContext<span>.</span>sampleRate <span>/</span> <span>(</span><span>2</span> <span>*</span> analyser<span>.</span>frequencyBinCount<span>)</span>
  <span>const</span> index <span>=</span> <span>parseInt</span><span>(</span><span>(</span>f <span>+</span> hzPerBin <span>/</span> <span>2</span><span>)</span> <span>/</span> hzPerBin<span>)</span>
  <span>return</span> buffer<span>[</span>index<span>]</span>
<span>}</span></code></pre></div>
<p>We populate the buffer by allowing the Web Audio API work it&#39;s Fourier sorcery
with the following single line of code.</p>
<div data-language="js"><pre><code>analyser<span>.</span><span>getByteFrequencyData</span><span>(</span>buffer<span>)</span></code></pre></div>
<p>After having populated the bins, we can deduce which frequencies are active and
thus converting this information to a numeric value. We call the value the
decoder <code>state</code>. The <code>isActive</code> function is used to decide if a frequency bin
value is above a chosen threshold, indicating that it was present in the
recorded audio. We set the threshold to 124, with a theoretical maximum of 255.</p>
<div data-language="js"><pre><code><span>const</span> <span>isActive</span> <span>=</span> <span>value</span> <span>=&gt;</span> <span>{</span>
  <span>return</span> value <span>&gt;</span> <span>124</span>
<span>}</span>

<span>const</span> <span>getState</span> <span>=</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>return</span> frequencies<span>.</span><span>map</span><span>(</span>frequencyBinValue<span>)</span><span>.</span><span>reduce</span><span>(</span><span>(</span><span>acc<span>,</span> binValue<span>,</span> idx</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>if</span> <span>(</span><span>isActive</span><span>(</span>binValue<span>)</span><span>)</span> <span>{</span>
      acc <span>+=</span> <span>1</span> <span>&lt;&lt;</span> idx
    <span>}</span>
    <span>return</span> acc
  <span>}</span><span>,</span> <span>0</span><span>)</span>
<span>}</span></code></pre></div>
<p>We require the state of the decoder to be consistent for multiple generations of
frequency bins before we&#39;re confident that the state is due to receiving an
encoded signal. Decoding is performed by continuously updating the frequency bin
data followed by comparing the state output of the decoder to its previous
state.</p>
<div data-language="js"><pre><code><span>const</span> <span>decode</span> <span>=</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>let</span> prevState <span>=</span> <span>0</span>
  <span>let</span> duplicates <span>=</span> <span>0</span>

  <span>const</span> <span>iteration</span> <span>=</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    analyser<span>.</span><span>getByteFrequencyData</span><span>(</span>buffer<span>)</span>
    <span>let</span> state <span>=</span> <span>getState</span><span>(</span><span>)</span>

    <span>if</span> <span>(</span>state <span>===</span> prevState<span>)</span> <span>{</span>
      duplicates<span>++</span>
    <span>}</span> <span>else</span> <span>{</span>
      prevState <span>=</span> state
      duplicates <span>=</span> <span>0</span>
    <span>}</span>
    <span>if</span> <span>(</span>duplicates <span>===</span> <span>10</span><span>)</span> <span>{</span>
      
      <span>let</span> decoded <span>=</span> String<span>.</span><span>fromCharCode</span><span>(</span>state<span>)</span>
      console<span>.</span><span>log</span><span>(</span><span>&#34;[output]&#34;</span><span>,</span> decoded<span>)</span>
    <span>}</span>
    
    window<span>.</span><span>setTimeout</span><span>(</span>iteration<span>,</span> <span>1</span><span>)</span>
  <span>}</span>
  <span>iteration</span><span>(</span><span>)</span>
<span>}</span>
<span>decode</span><span>(</span><span>)</span></code></pre></div>
<p>And that&#39;s about it! Here&#39;s what it looks like in action (the microphone is next
to the webcam on the top of the screen).</p>
<p><span>
      <a href="https://martinmelhus.com/static/3080843fc63fbe68f82cad411e2ad20e/ef2d5/webaudio-poc.jpg" target="_blank" rel="noopener">
    <span></span>
  <img alt="Decoder in action" title="Headphones are placed above the built-in microphone on the PC acting as decoder." src="https://martinmelhus.com/static/3080843fc63fbe68f82cad411e2ad20e/4b190/webaudio-poc.jpg" srcset="/static/3080843fc63fbe68f82cad411e2ad20e/e07e9/webaudio-poc.jpg 200w,
/static/3080843fc63fbe68f82cad411e2ad20e/066f9/webaudio-poc.jpg 400w,
/static/3080843fc63fbe68f82cad411e2ad20e/4b190/webaudio-poc.jpg 800w,
/static/3080843fc63fbe68f82cad411e2ad20e/e5166/webaudio-poc.jpg 1200w,
/static/3080843fc63fbe68f82cad411e2ad20e/b17f8/webaudio-poc.jpg 1600w,
/static/3080843fc63fbe68f82cad411e2ad20e/ef2d5/webaudio-poc.jpg 3982w" sizes="(max-width: 800px) 100vw, 800px" loading="lazy"/>
  </a>
    </span></p>
<h3>Disclaimer</h3>
<p>I made this; it&#39;s not perfect. As a matter of fact, the signal-to-noise ratio is
usually really bad. However, making it was fun, and that&#39;s what matters to me!</p>
<p><strong>N.B.</strong> This was only ever intended as a gimmick and a proof of concept - not
something that I would actually use at work. Please keep this in mind before
arguing why I should be fired over this in various online comment sections.</p></section></div>
  </body>
</html>
