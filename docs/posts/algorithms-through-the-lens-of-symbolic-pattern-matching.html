<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://symbolica.io/posts/pattern_matching/">Original</a>
    <h1>Algorithms through the lens of symbolic pattern matching</h1>
    
    <div id="readability-page-1" class="page"><div id="quarto-document-content">





<div>

<p>This blog post uses the computational framework Symbolica. Symbolica is <strong>free</strong> for hobbyists and a single-core instance is <strong>free</strong> for non-commercial use. Would you like to have new features added? Your organization can purchase a license and support the Symbolica project!</p>
</div>
<section id="introduction">
<h2 data-anchor-id="introduction">Introduction</h2>
<p>Pattern matching is all around us. It is what you do when you solve puzzles, and it lies at the core of some programming languages. The evolution of a cell in <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Conway’s game of life</a> is completely determined by the pattern of the 8 surrounding cells:</p>
<div>
<figure>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/e/e5/Gospers_glider_gun.gif" alt="Game of life"/></p>
</figure>
</div>
<p>Another common use of pattern matching is <em>regular expressions</em> (regex). This is a language that describes patterns in text. Below you see a regex to parse an e-mail address:</p>
<pre><code>^[a-zA-Z0-9]+(?:\.[a-zA-Z0-9]+)*@[a-zA-Z0-9]+(?:\.[a-zA-Z0-9]+)*$</code></pre>
<p>The text needs to start (<code>^</code>) with an alpha-numerical character (<code>[a-zA-Z0-9]</code>) and must contain <code>@</code> followed by at least one alpha-numerical character. This pattern will actually not match all valid e-mail addresses! For that you need this <a href="https://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html">horrendous regex</a>. Yikes.</p>
<p>Pattern matching is also ubiquitous in mathematics. For example, in the recursive definition of the factorial function: <span>\[
\begin{align}
f(0) &amp;= 1\\
f(n) &amp;= n f(n - 1);\quad n &gt; 0
\end{align}
\]</span></p>
<p>Let’s see how we can code the above relation using the Symbolica library in Python. We need to define a function <code>f</code> and we need a <em>wildcard</em> that can match any argument of the function <code>f</code>. Wildcards are variables that end with an underscore (<code>_</code>). We will use <code>x_</code>.</p>
<div id="5d7de214" data-execution_count="1">
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span>from</span> symbolica <span>import</span> <span>*</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>f, x_ <span>=</span> Expression.symbols(<span>&#39;f&#39;</span>, <span>&#39;x_&#39;</span>)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>e <span>=</span> f(<span>10</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>e <span>=</span> e.replace_all(f(x_), x_<span>*</span>f(x_<span>-</span><span>1</span>), x_.req_gt(<span>0</span>), repeat<span>=</span><span>True</span>)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>e <span>=</span> e.replace_all(f(<span>0</span>), <span>1</span>)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span>print</span>(e)</span></code></pre></div>

</div>
<p>That indeed equals 10 factorial. Note that we use the restriction <code>x_.req_gt(0)</code>, which means that the pattern will only match if <code>x_</code> is greater than 0.</p>
<p>Great, now let’s try to design some algorithms using only pattern matching and replacements on mathematical expressions. These algorithms will not be the most efficient, but they could be elegant and could unlock a different way of thinking.</p>
<p>The first challenge is to represent a problem as a mathematical expression. This will feel a bit alien at first, but remember that LLMs receive an array of integers as input and they function just fine ;)</p>
</section>
<section id="graphs">
<h2 data-anchor-id="graphs">Graphs</h2>
<p>Let’s write a graph as a mathematical expression. Graphs have edges and nodes/vertices. One possible way of writing a graph is by defining a function <code>v</code> that represents a node/vertex. The first argument is the label of the vertex and the remainder are labels of the edges that connect to that vertex. We can then <em>multiply</em> these vertices together. For example:</p>
<pre><code>v(A,1,2,3)*v(B,2,3,4)*v(C,4,1)</code></pre>
<p>represents the following graph:</p>
<div data-layout-align="default">
<div>
<div>
<figure>
<div>
<pre>flowchart LR
  A[A] -- 2 --- B(B)
  A[A] -- 3 --- B(B)
  B -- 4 --- C
  C(C) -- 1 --- A
</pre>
</div>
</figure>
</div>
</div>
</div>
<p>In Symbolica, it looks like:</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span>from</span> symbolica <span>import</span> <span>*</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>v, A, B, C <span>=</span> Expression.symbols(<span>&#39;v&#39;</span>, <span>&#39;A&#39;</span>, <span>&#39;B&#39;</span>, <span>&#39;C&#39;</span>)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>g <span>=</span> v(A,<span>1</span>,<span>2</span>,<span>3</span>)<span>*</span>v(B,<span>2</span>,<span>3</span>,<span>4</span>)<span>*</span>v(C,<span>4</span>,<span>1</span>)</span></code></pre></div>
<p>To represent graphs with directional edges, one could introduce an edge function that specifies the direction. For example, <code>e(2,B,A)</code> indicates that the edge <code>2</code> flows from vertex <code>B</code> to <code>A</code>. Again, this <code>e(...)</code> can be <em>multiplied</em> into the term.</p>
<p>Now that we have a basic mapping of a graph as a term (an expression with multiplications and no additions at the top level) we can manipulate it with pattern matching. For example, we can add two graphs:</p>
<div id="d191531c" data-execution_count="2">
<div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span>from</span> symbolica <span>import</span> <span>*</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>v, A, B, C <span>=</span> Expression.symbols(<span>&#39;v&#39;</span>, <span>&#39;A&#39;</span>, <span>&#39;B&#39;</span>, <span>&#39;C&#39;</span>)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>g1 <span>=</span> v(A,<span>1</span>,<span>2</span>,<span>3</span>)<span>*</span>v(B,<span>2</span>,<span>3</span>,<span>4</span>)<span>*</span>v(C,<span>4</span>,<span>1</span>)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>g2 <span>=</span> v(A,<span>1</span>,<span>2</span>)<span>*</span>v(B,<span>1</span>,<span>2</span>)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>g <span>=</span> <span>3</span><span>*</span>g1 <span>+</span> <span>2</span><span>*</span>g2</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span>print</span>(g)</span></code></pre></div>
<div>
<pre><code>2*v(A,1,2)*v(B,1,2)+3*v(C,4,1)*v(A,1,2,3)*v(B,2,3,4)</code></pre>
</div>
</div>
<p>What sense does this make? It depends on the context. In particle physics one can express probabilities of collision events in terms of a weighted sum of Feynman graphs, so this <code>g</code> could be something that can be measured in a detector!</p>
<section id="testing-connectivity">
<h3 data-anchor-id="testing-connectivity">Testing connectivity</h3>
<p>Now let us try to extract some basic properties of our graph using pattern matching. For example, we can answer the question whether a graph is connected or if the input consists of two or more connected components (disjoint graphs).</p>
<p>How to go about this? Well, we realize that the number of connected components does not change if we <em>shrink</em> an edge; any edge connects two nodes of the graph, which we can fuse into one. For example, in the example graph above, we can shrink the edge <code>4</code>, which fuses <code>B</code> and <code>C</code>. We get:</p>
<div data-layout-align="default">
<div>
<div>
<figure>
<div>
<pre>flowchart LR
  A -- 2 --- BC
  A -- 3 --- BC
  BC -- 4 --- BC
  BC -- 1 --- A
</pre>
</div>
</figure>
</div>
</div>
</div>
<p>Now we can pick any other edge and shrink that too. For example, edge <code>2</code>:</p>
<div data-layout-align="default">
<div>
<div>
<figure>
<div>
<pre>flowchart LR
  ABC -- 1 --- ABC
  ABC -- 2 --- ABC
  ABC -- 3 --- ABC
  ABC -- 4 --- ABC
</pre>
</div>
</figure>
</div>
</div>
</div>
<p>We are now left with a single vertex that contains all our edges. We shrank the entire graph to a point, and therefore it is one component! To conclude, if we are left with <span>\(n\)</span> vertices after shrinking every edge, we have <span>\(n\)</span> connected components.</p>
<p>Let’s write the algorithm in Symbolica. We need to be able to match any edge in a vertex. To achieve that, we define ranged wildcards <code>l1___</code>, <code>r1___</code>,<code>l2___</code> and <code>r2___</code> that can match <em>any</em> number of arguments (see <a href="https://symbolica.io/docs/pattern_matching.html#wildcards">here</a> for more information).</p>
<div id="cb8"><pre><code><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span>from</span> symbolica <span>import</span> <span>*</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>v, A, B, C, x_, l1___, l2___, r1___, r2___ <span>=</span> Expression.symbols(<span>&#39;v&#39;</span>, <span>&#39;A&#39;</span>, <span>&#39;B&#39;</span>, <span>&#39;C&#39;</span>, <span>&#39;x_&#39;</span>,</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>                                                <span>&#39;l1___&#39;</span>, <span>&#39;l2___&#39;</span>, <span>&#39;r1___&#39;</span>, <span>&#39;r2___&#39;</span>)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>g <span>=</span> v(A,<span>1</span>,<span>2</span>,<span>3</span>)<span>*</span>v(B,<span>2</span>,<span>3</span>,<span>4</span>)<span>*</span>v(C,<span>4</span>,<span>1</span>)</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>g <span>=</span> g.replace_all(v(l1___,x_,r1___)<span>*</span>v(l2___,x_,r2___),</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        v(l1___,x_,x_,r1___,l2___,r2___), repeat<span>=</span><span>True</span>)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span>print</span>(g)</span></code></pre></div>
<pre><code>v(A,B,C,1,1,2,2,3,3,4,4)</code></pre>
<p>We are left with one vertex and therefore the graph is connected. Thus, in just a single line we have written an algorithm that tests if a graph is connected. Not bad!</p>
</section>
<section id="counting-cycles">
<h3 data-anchor-id="counting-cycles">Counting cycles</h3>
<p>One may wonder how many cycles/loops a graph has. Our example has two loops, as can be clearly seen by eye. But how many loops does the following graph have?</p>
<div data-layout-align="default">
<div>
<div>
<figure>
<div>
<pre>flowchart LR
  A -- 1 --- B
  B -- 2 --- C
  B -- 8 --- E
  C -- 3 --- D
  C -- 9 --- F
  D -- 10 --- E
  D -- 4 --- G
  G -- 5 --- H
  G -- 6 --- F
  E -- 9 --- F
</pre>
</div>
</figure>
</div>
</div>
</div>
<p>The non-planarity (crossings of edges) makes it hard to count! The representation in <code>v</code>-notation is sadly not more illuminating:</p>
<pre><code>v(A,1)*v(B,1,2,8)*v(C,2,3,9)*v(D,3,4,10)*v(G,4,5,6)*v(F,6,7,9)*v(E,8,9,10)*v(H,5)</code></pre>
<p>Fortunately, Euler derived a formula to determine the number of cycles/loops:</p>
<p><span>\[
L = E - V + C
\]</span> where <span>\(L\)</span> is the number of loops, <span>\(E\)</span> is the number of edges, <span>\(V\)</span> the number of vertices and <span>\(C\)</span> the number of connected components. For now, we will always work with one connected component, so <span>\(C=1\)</span>. What remains is to count the number of vertices and the number of edges. Since each edge appears twice in our representation — once in the vertex of its left end and once in the vertex of its right end — we can count the total number of arguments of all the vertex functions and divide by two!</p>
<p>We only want to use pattern matching and replacements, so we will find a way to represent a counter for the number of vertices in the mathematical expression. We define the variable <code>nv</code> whose <em>power</em> will determine the number of vertices and <code>ne</code> whose power will determine the total number of edges.</p>
<p>Then if we replace all <code>v(...)</code> by <code>v(...)*nv</code>, the power of <code>nv</code> will represent the number of vertices:</p>
<div id="a1fc327c" data-execution_count="3">
<div id="cb11"><pre><code><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span>from</span> symbolica <span>import</span> <span>*</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>v, A, B, C, D, E, F, G, H, nv, x___ <span>=</span> Expression.symbols(<span>&#39;v&#39;</span>, <span>&#39;A&#39;</span>, <span>&#39;B&#39;</span>, <span>&#39;C&#39;</span>, <span>&#39;D&#39;</span>, <span>&#39;E&#39;</span>, <span>&#39;F&#39;</span>, <span>&#39;G&#39;</span>, <span>&#39;H&#39;</span>, <span>&#39;nv&#39;</span>, <span>&#39;x___&#39;</span>)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>g <span>=</span> v(A,<span>1</span>)<span>*</span>v(B,<span>1</span>,<span>2</span>,<span>8</span>)<span>*</span>v(C,<span>2</span>,<span>3</span>,<span>9</span>)<span>*</span>v(D,<span>3</span>,<span>4</span>,<span>10</span>)<span>*</span>v(G,<span>4</span>,<span>5</span>,<span>6</span>)<span>*</span>v(F,<span>6</span>,<span>7</span>,<span>9</span>)<span>*</span>v(E,<span>8</span>,<span>9</span>,<span>10</span>)<span>*</span>v(H,<span>5</span>)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>g <span>=</span> g.replace_all(v(x___), v(x___)<span>*</span>nv)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span>print</span>(g)</span></code></pre></div>
<div>
<pre><code>nv^8*v(A,1)*v(H,5)*v(B,1,2,8)*v(C,2,3,9)*v(D,3,4,10)*v(E,8,9,10)*v(F,6,7,9)*v(G,4,5,6)</code></pre>
</div>
</div>
<p>So we have 8 vertices. Note that this match-and-replace works just as well if we have a sum of graphs: each graph will be multiplied by the correct number of <code>nv</code>s.</p>
<p>For the counting of edges, we use the <code>nargs</code> function that counts the number of arguments:</p>
<div id="cb13"><pre><code><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>g <span>=</span> g.replace_all(v(x___), v(x___)<span>*</span>nv<span>*</span>ne<span>**</span>((x___.transform().nargs() <span>-</span> <span>1</span>) <span>/</span> <span>2</span>))</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span>print</span>(g)</span></code></pre></div>
<pre><code>nv^8*ne^10*v(A,1)*v(H,5)*v(B,1,2,8)*v(C,2,3,9)*v(D,3,4,10)*v(E,8,9,10)*v(F,6,7,9)*v(G,4,5,6)</code></pre>
<p>By using <a href="https://symbolica.io/docs/pattern_matching.html#transformers"><code>transform()</code></a>, the function <code>nargs()</code> is applied to the expression <code>x__</code> <em>after</em> it has been replaced by its matched content. We subtract <code>1</code> because the first argument of the function is the vertex id and not an edge.</p>
<p>With this one-liner we get the number of vertices (<code>8</code>) and the number of edges (<code>10</code>).</p>
<p>Now we do the final transformation to obtain the number of loops:</p>
<div id="cb15"><pre><code><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>g <span>=</span> g.replace_all(nv, <span>1</span><span>/</span>ne) <span>*</span> ne</span></code></pre></div>
<p>which will subtract the power of <code>nv</code> from the power of <code>ne</code> (computing <span>\(E-V\)</span>). Finally we add 1 (the number of connected components) to it by multiplying <code>ne</code>.</p>
<p>Putting it all together:</p>
<div id="e529fabf" data-execution_count="4">
<div id="cb16"><pre><code><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span>from</span> symbolica <span>import</span> <span>*</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>v, A, B, C, D, E, F, G, H, nv, ne, x___ <span>=</span> Expression.symbols(<span>&#39;v&#39;</span>, <span>&#39;A&#39;</span>, <span>&#39;B&#39;</span>, <span>&#39;C&#39;</span>, <span>&#39;D&#39;</span>, <span>&#39;E&#39;</span>, <span>&#39;F&#39;</span>, <span>&#39;G&#39;</span>, <span>&#39;H&#39;</span>, <span>&#39;nv&#39;</span>, <span>&#39;ne&#39;</span>, <span>&#39;x___&#39;</span>)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>g <span>=</span> v(A,<span>1</span>)<span>*</span>v(B,<span>1</span>,<span>2</span>,<span>8</span>)<span>*</span>v(C,<span>2</span>,<span>3</span>,<span>9</span>)<span>*</span>v(D,<span>3</span>,<span>4</span>,<span>10</span>)<span>*</span>v(G,<span>4</span>,<span>5</span>,<span>6</span>)<span>*</span>v(F,<span>6</span>,<span>7</span>,<span>9</span>)<span>*</span>v(E,<span>8</span>,<span>9</span>,<span>10</span>)<span>*</span>v(H,<span>5</span>)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>g <span>=</span> g.replace_all(v(x___), v(x___)<span>*</span>nv<span>*</span>ne<span>**</span>((x___.transform().nargs() <span>-</span> <span>1</span>) <span>/</span> <span>2</span>))</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>g <span>=</span> g.replace_all(nv, ne<span>**-</span><span>1</span>) <span>*</span> ne</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span>print</span>(g)</span></code></pre></div>
<div>
<pre><code>ne^3*v(A,1)*v(H,5)*v(B,1,2,8)*v(C,2,3,9)*v(D,3,4,10)*v(E,8,9,10)*v(F,6,7,9)*v(G,4,5,6)</code></pre>
</div>
</div>
<p>We find that graph has three loops!</p>
</section>
<section id="graph-automorphisms-self-maps">
<h3 data-anchor-id="graph-automorphisms-self-maps">Graph automorphisms (self-maps)</h3>
<p>One may wonder in what ways the graph can be transformed into itself by relabeling the vertices and edges. These are the self-maps or <em>automorphisms</em> of the graph. With a pattern match, one could find all ways a graph can map into itself. But how do we construct a pattern that has the same connectivity as the graph at hand?</p>
<p>We first need to make a modification to our graph definition. For simplicity, we drop the vertex labels (if they are all distinct, only the identity map is a self-map!) We will also make each vertex symmetric in its arguments, since there is no preferred edge ordering.</p>
<p>This is our setup and test graph:</p>
<div id="cb18"><pre><code><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>v <span>=</span> Expression.symbol(<span>&#39;vs&#39;</span>, is_symmetric<span>=</span><span>True</span>)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>e_ <span>=</span> Expression.symbols(<span>*</span>[<span>&#39;e</span><span>{}</span><span>_&#39;</span>.<span>format</span>(i) <span>for</span> i <span>in</span> <span>range</span>(<span>7</span>)])</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>graph <span>=</span> v(<span>0</span>, <span>1</span>, <span>4</span>)<span>*</span>v(<span>1</span>, <span>2</span>, <span>5</span>, <span>6</span>)<span>*</span>v(<span>0</span>, <span>2</span>, <span>3</span>)<span>*</span>v(<span>3</span>, <span>4</span>, <span>5</span>)</span></code></pre></div>
<p>Now comes the crux: we replace each edge identifier by its associated wildcard by indexing into the <code>e_</code> array.</p>
<div id="cb19"><pre><code><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>graph_pat <span>=</span> graph</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span>for</span> edge, edge_pat <span>in</span> <span>enumerate</span>(e_):</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    graph_pat <span>=</span> graph_pat.replace_all(</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>        edge, edge_pat, allow_new_wildcards_on_rhs<span>=</span><span>True</span>)</span></code></pre></div>
<p>Normally Symbolica will not allow new wildcards on the right-hand side of a replacement, but this can be explicitly enabled using <code>allow_new_wildcards_on_rhs=True</code> in the next version of Symbolica (soon to be released).</p>
<p>We get the graph pattern:</p>
<pre><code>v(e0_, e1_, e4_)*v(e1_, e2_, e5_, e6_)*v(e0_, e2_, e3_)*v(e3_, e4_, e5_)</code></pre>
<p>Now we apply the pattern-replaced version of our graph to our graph:</p>
<div id="cb21"><pre><code><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span>for</span> x <span>in</span> graph.match(graph_pat):</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    <span>for</span> ee <span>in</span> e_:</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>        <span>print</span>(<span>&#39;</span><span>{}</span><span>=</span><span>{}</span><span>&#39;</span>.<span>format</span>(ee, x[ee]), end<span>=</span><span>&#39; &#39;</span>)</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    <span>print</span>()</span></code></pre></div>
<p>We get 6 automorphisms:</p>
<pre><code>e0_=0 e1_=1 e2_=2 e3_=3 e4_=4 e5_=5 e6_=6 
e0_=4 e1_=1 e2_=5 e3_=3 e4_=0 e5_=2 e6_=6 
e0_=0 e1_=2 e2_=1 e3_=4 e4_=3 e5_=5 e6_=6 
e0_=3 e1_=2 e2_=5 e3_=4 e4_=0 e5_=1 e6_=6 
e0_=3 e1_=5 e2_=2 e3_=0 e4_=4 e5_=1 e6_=6 
e0_=4 e1_=5 e2_=1 e3_=0 e4_=3 e5_=2 e6_=6 </code></pre>
<p>The same idea can also be used to test if two graphs are <em>isomorphic</em> (whether one can be mapped into the other).</p>
</section>
</section>
<section id="conclusion">
<h2 data-anchor-id="conclusion">Conclusion</h2>
<p>Sometimes recasting your problem in a different language can lead to surprisingly elegant algorithms (though not necessarily fast ones). In this blog post we saw how reinterpreting a graph as a mathematical expression allowed for creative algorithms by making use of the pattern matching capabilities of Symbolica.</p>
<p>Want to learn more? Join the discussion on the Symbolica <a href="https://discord.gg/DeaWSkZuv3">Discord</a> or <a href="https://reform.zulipchat.com/">Zulip</a>!</p>
</section>
<section id="support-symbolica-1">
<h2 data-anchor-id="support-symbolica-1">Support Symbolica</h2>
<p>Symbolica is <strong>free</strong> for hobbyists and a single-core instance is <strong>free</strong> for non-commercial use. Would you like to use additional features or have unrestricted access? Your organization can purchase a license and support the Symbolica project!</p>


</section>

</div></div>
  </body>
</html>
