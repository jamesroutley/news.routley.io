<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.infoq.com/news/2025/08/netflix-tudum-cqrs-raw-hollow/">Original</a>
    <h1>Netflix Revamps Tudum&#39;s CQRS Architecture with Raw Hollow In-Memory Object Store</h1>
    
    <div id="readability-page-1" class="page"><div>
								<p>
Netflix <a href="https://netflixtechblog.com/netflix-tudum-architecture-from-cqrs-with-kafka-to-cqrs-with-raw-hollow-86d141b72e52">replaced a CQRS implementation using Kafka and Cassandra with a new solution leveraging RAW Hollow</a>, an in-memory object store developed internally. Revamped architecture of Tudum offers much faster content preview during the editorial process and faster page rendering for visitors.
</p>

<p>Netflix launched Tudum, its official fan website, in late 2021, to provide a destination for Netflix users interested in additional content associated with the company’s shows. The architecture of the website was initially based on the <a href="https://learn.microsoft.com/en-us/azure/architecture/patterns/cqrs">Command Query Responsibility Segregation (CQRS)</a> pattern to optimize read performance for serving content.</p>

<p>The write part of the platform was built around the 3rd-party CMS product, and had a dedicated ingestion service for handling content update events, delivered via a webhook. The ingestion service was responsible for converting CMS data into read-optimized page content by applying templates, as well as data validations and transformations. Read-optimized data would then be published to a dedicated Kafka topic.</p>

<p><img alt="" data-src="news/2025/08/netflix-tudum-cqrs-raw-hollow/en/resources/1netflix-tudum-arch-old-1755081110544.jpeg" src="https://imgopt.infoq.com/fit-in/3000x4000/filters:quality(85)/filters:no_upscale()/news/2025/08/netflix-tudum-cqrs-raw-hollow/en/resources/1netflix-tudum-arch-old-1755081110544.jpeg" rel="share"/></p>

<p><em>Initial Tudum data architecture (Source: <a href="https://netflixtechblog.com/netflix-tudum-architecture-from-cqrs-with-kafka-to-cqrs-with-raw-hollow-86d141b72e52">Netflix Engineering Blog</a>)</em></p>

<p>On the query side, the page data service was responsible for consuming messages for the Kafka topic and storing the data in the <a href="https://cassandra.apache.org/_/index.html">Cassandra</a> query database. The service utilized a near cache to improve performance, providing stored page data to the page construction service and other internal services.</p>

<p>The initial architecture benefited from the decoupling of read and write paths, allowing for independent scaling. However, due to the caching refresh cycle, CMS updates were taking many seconds to show up on the website. The issue made it problematic for content editors to preview their modifications and got progressively worse as the amount of content grew, resulting in delays lasting tens of seconds.</p>

<p><a href="https://www.linkedin.com/in/eugeneemelyanov/">Eugene Yemelyanau</a>, technology evangelist, and <a href="https://www.linkedin.com/in/jake-grice/">Jake Grice</a>, staff engineer at Netflix, describe the cause for delays in retrieving content for displaying due to caching:</p>

<blockquote>
<p>Regardless of which system modifies the data, the cache is updated with each refresh cycle. If you have 60 keys and a refresh interval of 60 seconds, the near cache will update one key per second. This was problematic for previewing recent modifications, as these changes were only reflected with each cache refresh. As Tudum’s content grew, cache refresh times increased, further extending the delay.</p>
</blockquote>

<p>Eventually, the team decided to revamp the architecture to eliminate the delays in previewing content updates, ideally. Engineers chose to leverage <a href="https://hollow.how/">RAW Hollow</a>, a homegrown in-memory object database. Netflix designed the database to handle small to medium datasets and support strong read-after-write consistency. RAW Hollow allows the entire dataset to reside in the memory of each application process within a cluster, offering low latency and high availability. The database provides eventual consistency by default but supports strong consistency at the individual request level.</p>

<p><img alt="" data-src="news/2025/08/netflix-tudum-cqrs-raw-hollow/en/resources/1netflix-tudum-arch-new-1755081110544.jpeg" src="https://imgopt.infoq.com/fit-in/3000x4000/filters:quality(85)/filters:no_upscale()/news/2025/08/netflix-tudum-cqrs-raw-hollow/en/resources/1netflix-tudum-arch-new-1755081110544.jpeg" rel="share"/></p>

<p><em>Revised Tudum data architecture (Source: <a href="https://netflixtechblog.com/netflix-tudum-architecture-from-cqrs-with-kafka-to-cqrs-with-raw-hollow-86d141b72e52">Netflix Engineering Blog</a>)</em></p>

<p>Tudum engineers replaced Kafka and Cassandra with the RAW Follow cluster, spanning the ingestion and page construction service instances. The team concluded that, for the use case at hand, the CQRS design pattern wasn’t the optimal approach, and using a distributed, in-memory object store suited the situation better. The new solution eliminated cache invalidation problems as the entire dataset could fit into the application’s memory, helped by Hollow’s data compression, reducing the data size to 25% of the uncompressed size in the Apache Iceberg table.</p>

<p>As a result of the architecture revamp and supporting data migration, the platform benefited from a significant reduction in data propagation times and page construction due to reduced request I/O and round-trip times. Tudum engineers believe that the new architecture offers the best of both worlds for editors and visitors.</p>

								









  
    <div> <!-- main wrapper for authors section -->
        <h2>About the Author</h2> <!-- section title -->

        
            
                
            
            <div data-id="author-Rafal-Gancarz"> <!-- main wrapper for each author -->
                <div>
                    <h4><strong>Rafal Gancarz</strong></h4>
                    <div>
                        
                        <p><span>
                            <span>Show more</span><span>Show less</span>
                        </span>
                    </p></div>
                </div>
            </div>
        
    </div>

							</div></div>
  </body>
</html>
