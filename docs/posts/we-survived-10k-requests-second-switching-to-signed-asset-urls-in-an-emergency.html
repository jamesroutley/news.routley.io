<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hardcover.app/blog/how-we-survived-10k-requests-second-switching-to-signed-urls">Original</a>
    <h1>We survived 10k requests/second: Switching to signed asset URLs in an emergency</h1>
    
    <div id="readability-page-1" class="page"><div>
<figure><img loading="lazy" decoding="async" width="1024" height="683" src="https://wp.hardcover.app/wp-content/uploads/2024/08/library_safe-1024x683.png" alt="" srcset="https://wp.hardcover.app/wp-content/uploads/2024/08/library_safe-1024x683.png 1024w, https://wp.hardcover.app/wp-content/uploads/2024/08/library_safe-300x200.png 300w, https://wp.hardcover.app/wp-content/uploads/2024/08/library_safe-768x512.png 768w, https://wp.hardcover.app/wp-content/uploads/2024/08/library_safe-1200x800.png 1200w, https://wp.hardcover.app/wp-content/uploads/2024/08/library_safe.png 1344w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<p>Yesterday I woke up to a ping on my Apple Watch of unusual spending on my Hardcover debit card. Itâ€™s not unusual to get a ping about an expense, but this was a new one. Google Cloud had charged me a round $100 â€“ an unusual amount to spend.</p>



<p>The previous day I was experimenting with Google Cloud Run, trying to migrate our Next.js staging environment from Vercel to there to save some money. I assumed I misconfigured that service and turned it off and went about my day.</p>



<p>A few hours later I got another expense alert: this time for $200 (!). Now I was worried. It didnâ€™t help that I was working from a coffee shop, it was about to rain and my laptop battery was almost dead. ðŸ˜…</p>



<p>After speed walking the trip home while listening to <a href="https://hardcover.app/books/bride-2024">Bride</a> (Iâ€™m making my way through the <a href="https://hardcover.app/trending/recent">Trending Books</a>), I got to work tracking down what was happening.</p>



<h2>Whatâ€™s the Issue?</h2>



<p>My first stop was to Google Cloud Billing. That should narrow the issue down. The new expense was there â€“ I wasnâ€™t crazy. It seemed to level off, which was a good sign.</p>



<figure><img loading="lazy" decoding="async" width="1024" height="512" src="https://wp.hardcover.app/wp-content/uploads/2024/08/Screenshot-2024-08-14-at-12.09.23â€¯PM-1024x512.png" alt="" srcset="https://wp.hardcover.app/wp-content/uploads/2024/08/Screenshot-2024-08-14-at-12.09.23â€¯PM-1024x512.png 1024w, https://wp.hardcover.app/wp-content/uploads/2024/08/Screenshot-2024-08-14-at-12.09.23â€¯PM-300x150.png 300w, https://wp.hardcover.app/wp-content/uploads/2024/08/Screenshot-2024-08-14-at-12.09.23â€¯PM-768x384.png 768w, https://wp.hardcover.app/wp-content/uploads/2024/08/Screenshot-2024-08-14-at-12.09.23â€¯PM-1536x768.png 1536w, https://wp.hardcover.app/wp-content/uploads/2024/08/Screenshot-2024-08-14-at-12.09.23â€¯PM-1200x600.png 1200w, https://wp.hardcover.app/wp-content/uploads/2024/08/Screenshot-2024-08-14-at-12.09.23â€¯PM-1980x990.png 1980w, https://wp.hardcover.app/wp-content/uploads/2024/08/Screenshot-2024-08-14-at-12.09.23â€¯PM.png 2012w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<p>This confirmed there was something costly happening, but what?</p>



<p>I clicked over to the breakdown by service and it was clear: Cloud Storage expenses were up 2,098% ðŸ˜…</p>



<figure><img loading="lazy" decoding="async" width="1024" height="800" src="https://wp.hardcover.app/wp-content/uploads/2024/08/Screenshot-2024-08-14-at-12.12.57â€¯PM-1024x800.png" alt="" srcset="https://wp.hardcover.app/wp-content/uploads/2024/08/Screenshot-2024-08-14-at-12.12.57â€¯PM-1024x800.png 1024w, https://wp.hardcover.app/wp-content/uploads/2024/08/Screenshot-2024-08-14-at-12.12.57â€¯PM-300x234.png 300w, https://wp.hardcover.app/wp-content/uploads/2024/08/Screenshot-2024-08-14-at-12.12.57â€¯PM-768x600.png 768w, https://wp.hardcover.app/wp-content/uploads/2024/08/Screenshot-2024-08-14-at-12.12.57â€¯PM-1536x1200.png 1536w, https://wp.hardcover.app/wp-content/uploads/2024/08/Screenshot-2024-08-14-at-12.12.57â€¯PM-1200x938.png 1200w, https://wp.hardcover.app/wp-content/uploads/2024/08/Screenshot-2024-08-14-at-12.12.57â€¯PM.png 1802w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<p>Whelp, I wondered if this day would come. Let me back up and mention what services weâ€™re using real quick.</p>



<h2>What Google Cloud Services Does Hardcover Use?</h2>



<p>Not much. In fact only 3. The rest of our services are hosted elsewhere.</p>



<figure><img loading="lazy" decoding="async" width="1024" height="599" src="https://wp.hardcover.app/wp-content/uploads/2024/08/Server-Diagram-1024x599.png" alt="" srcset="https://wp.hardcover.app/wp-content/uploads/2024/08/Server-Diagram-1024x599.png 1024w, https://wp.hardcover.app/wp-content/uploads/2024/08/Server-Diagram-300x175.png 300w, https://wp.hardcover.app/wp-content/uploads/2024/08/Server-Diagram-768x449.png 768w, https://wp.hardcover.app/wp-content/uploads/2024/08/Server-Diagram-1536x898.png 1536w, https://wp.hardcover.app/wp-content/uploads/2024/08/Server-Diagram-2048x1198.png 2048w, https://wp.hardcover.app/wp-content/uploads/2024/08/Server-Diagram-1200x702.png 1200w, https://wp.hardcover.app/wp-content/uploads/2024/08/Server-Diagram-1980x1158.png 1980w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<p><strong>Google Cloud Storage</strong> â€“ We store all cover images, author avatars, user avatars, and various static images in Google Cloud Storage. Iâ€™ve previously used S3 for this, but <a href="https://hardcover.app/blog/why" data-type="post" data-id="194">weâ€™re anti-amazon</a>. </p>



<p><strong>Google Cloud Run</strong> â€“ We have exactly one process in Cloud Run, our <a href="https://hardcover.app/blog/how-we-reduced-a-1000-month-imgix-bill-to-1-using-google-cloud" data-type="post" data-id="851">Image Resize Service</a> (Imaginary) I wrote about last year. It cut our $1,000 bill down to $50/month or less with no loss in functionality. If youâ€™re using Imgix or Cloudinary, itâ€™s  kind of amazing.</p>



<p><strong>Google CDN</strong> â€“ The Image Resize Service doesnâ€™t do any caching, so we throw a CDN in front of it that aggressively caches images. </p>



<p>Cloud Run and the Google CDN have worked absolutely perfectly. I havenâ€™t even touched them in 11 months. Not once. I hadnâ€™t touched Google Cloud Storage either, but that was the problem. ðŸ˜…</p>



<p>When I initially setup Google Cloud Storage, I made the bucket (the storage container per-environment) public with optional private files. This allowed user avatars, cover images and other images we show on the site to be publicly accessed, but save user uploaded CSVs privately in the same place.</p>



<p>For their part, Google adds a lot of alert messages when a bucket has public access. Itâ€™s almost like they know something I donâ€™t. Turns out the Internet is a <a href="https://hardcover.app/books/the-dark-forest">Dark Forest</a> (I just re-read The Three Body Problem after the Netflix series and will use any chance I can to drop it into conversation ðŸ˜‚). </p>



<p>My decision to keep our Google Cloud Storage public was the culprit.</p>



<h2>So, What Actually Happened?</h2>



<p>Weâ€™re still working that out and looking for ways to improve, but hereâ€™s the theory.</p>



<p>Someone has been hitting our API pretty hard recently. They likely downloaded a large amount of data from it â€“ including every edition with URLs for covers.</p>



<p>Those cover images are direct URLs to Google Cloud Storage. For example:</p>



<div><div>
<p>Example URL</p>


<pre aria-describedby="shcb-language-1" data-shcb-language-name="JavaScript" data-shcb-language-slug="javascript"><span><code>https:<span>//storage.googleapis.com/hardcover/external_data/ 36306160/04fdf2f73287526f8326413f4d3d7ec77999b832.jpeg</span></code></span><small id="shcb-language-1"><span>Code language:</span> <span>JavaScript</span> <span>(</span><span>javascript</span><span>)</span></small></pre></div></div>



<p>These are the images that were public.</p>



<p>Downloading a few images from here wouldnâ€™t have shown up on my radar. In this case, someone decided to download up to 10k images/secondâ€¦ for close to 7 hours.</p>



<figure><img loading="lazy" decoding="async" width="1024" height="271" src="https://wp.hardcover.app/wp-content/uploads/2024/08/Screenshot-2024-08-14-at-12.23.55â€¯PM-1024x271.png" alt="" srcset="https://wp.hardcover.app/wp-content/uploads/2024/08/Screenshot-2024-08-14-at-12.23.55â€¯PM-1024x271.png 1024w, https://wp.hardcover.app/wp-content/uploads/2024/08/Screenshot-2024-08-14-at-12.23.55â€¯PM-300x79.png 300w, https://wp.hardcover.app/wp-content/uploads/2024/08/Screenshot-2024-08-14-at-12.23.55â€¯PM-768x203.png 768w, https://wp.hardcover.app/wp-content/uploads/2024/08/Screenshot-2024-08-14-at-12.23.55â€¯PM-1536x407.png 1536w, https://wp.hardcover.app/wp-content/uploads/2024/08/Screenshot-2024-08-14-at-12.23.55â€¯PM-2048x542.png 2048w, https://wp.hardcover.app/wp-content/uploads/2024/08/Screenshot-2024-08-14-at-12.23.55â€¯PM-1200x318.png 1200w, https://wp.hardcover.app/wp-content/uploads/2024/08/Screenshot-2024-08-14-at-12.23.55â€¯PM-1980x524.png 1980w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<p>This is equivalent to about 650 mb/second for that time period. Thatâ€™s about 16 TB of data. We donâ€™t even have that much in our bucket! They mustâ€™ve downloaded many things multiple times.</p>



<figure><img loading="lazy" decoding="async" width="1024" height="365" src="https://wp.hardcover.app/wp-content/uploads/2024/08/Screenshot-2024-08-14-at-12.24.01â€¯PM-1024x365.png" alt="" srcset="https://wp.hardcover.app/wp-content/uploads/2024/08/Screenshot-2024-08-14-at-12.24.01â€¯PM-1024x365.png 1024w, https://wp.hardcover.app/wp-content/uploads/2024/08/Screenshot-2024-08-14-at-12.24.01â€¯PM-300x107.png 300w, https://wp.hardcover.app/wp-content/uploads/2024/08/Screenshot-2024-08-14-at-12.24.01â€¯PM-768x274.png 768w, https://wp.hardcover.app/wp-content/uploads/2024/08/Screenshot-2024-08-14-at-12.24.01â€¯PM-1200x427.png 1200w, https://wp.hardcover.app/wp-content/uploads/2024/08/Screenshot-2024-08-14-at-12.24.01â€¯PM.png 1432w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<p>For most people in our Discord theyâ€™re using our API to create fun things based on their history. It turns out we need more protections in place to stop bulk access.</p>



<h2>An Easy Solution With Issues</h2>



<p>The solution for this technically difficult, but itâ€™s a pain: making this bucket private. Doing that immediately would cause the site to no longer show images, and would prevent anyone using the API from getting images. We needed a plan to make it private and generate signed URLs for all images that expire after a set period of time.</p>



<p>Signed URLs are a variant of the original URL with additional parameters. I think of it like sending an address (the URL) and a combination (the additional parameters).</p>



<p>You can generate a signed URL using the Google Cloud Storage API, hitting it with a specific file and a duration. That URL will look something like this:</p>



<div><div>
<p>Example URL</p>


<pre aria-describedby="shcb-language-2" data-shcb-language-name="JavaScript" data-shcb-language-slug="javascript"><span><code>https:<span>//storage.googleapis.com/hardcover/external_data/36306160/04fdf2f73287526f8326413f4d3d7ec77999b832.jpeg?GoogleAccessId=hardcover-production%40hardcover-313100.iam.gserviceaccount.com&amp;Expires=1723846732&amp;Signature=gQ81vjCntrus3j5xbr2r7XEQ30DCTye4ikwdrAQvhwlGGeUJuJ760n9f2o%2B70zjM91%2Bng3C4pWgZzp2DFWdXH2%2BAZMFv1pYMzk%2F20x66NKnZ2dX%2BbQuVu6BgDsIw%2BvmLzEnsMbN6RGm0Dlq0V8e8JoEWrohR5UkN1n5YscnOBywZgsSxIQ8KrL079GeCvWvdE%2B%2BAldLuHT0JhFyo76hJE%2Ba7tCUBuL8drPQSKaHguLrbMjrtuW8%2FfuKRSOnY8wMgI%2FQcFVZPDuA5uVXchi67zVu26RFraBO93MxfhwuIpFHVft6ViRxLF0irLp%2FGDTzDPwpR5vBSLlMPk58ByxxTeg%3D%3D</span></code></span><small id="shcb-language-2"><span>Code language:</span> <span>JavaScript</span> <span>(</span><span>javascript</span><span>)</span></small></pre></div></div>



<p>This URL contains a few specific parameters that Google Cloud Storage can use to authenticate this URL including <code>GoogleAccessId</code>, <code>Expires</code> and the <code>Signature</code>. Unless all 3 of these are correct youâ€™ll get an Access Denied error from Google Cloud Storage.</p>



<p>On the walk home from the coffee shop I started brainstorming how to add these to Hardcover. If youâ€™re ever wondering if a walk will help you think: the answer is most likely yes. ðŸ˜‚</p>



<h3>Failed Solution #1: Change the URLs in our Database</h3>



<p>I know what I didnâ€™t want to do: rewrite all images in our database. Even if we make them private, those image URLs are correct. Also, since signed URLs expire after a set period of time, if we went this route, weâ€™d need to regenerate 5 million signed URLs over that time period.</p>



<p>This did get me thinking about how long we should allow URLs to be used for. <strong>I landed on one day</strong>. We canâ€™t regenerate 5 million signed URLs everyday â€“ nor do we need to. This option was out.</p>



<h3>Failed Solution #2: Update the API to return Signed URLs</h3>



<p>Our API (Hasura) connects straight to our database. If someone requests 100 books with covers, what theyâ€™re getting back is straight from our database. Ruby and Rails arenâ€™t involved.</p>



<p>In other words, we have no way to override the static value from that column in the database. Nor should we. That endpoint to get data about editions and books should be allowed to be accessed at a much higher rate. If we were to generate signed URLs at that step it would slow down the entire system which relies on book data.</p>



<p>Having our API return signed URLs in bulk was out.</p>



<h3>Failed Solution #3: Generate Signed URLs in Next.js</h3>



<p>Next.js is responsible for presenting all information to visitors of this site. It seemed like this might be a valid solution. Before we show a URL for any image we could generate a signed URL, cache it in Redis for 24 hours then use that.</p>



<p>There are two major problems with this. First off, generating the signed URL would need to happen on the server. Unfortunately, we use cover images that have been downloaded client side. Itâ€™d be unrealistic to fetch information about a book on the Next.js client side, send it to the server to get the URL, then use that. Not impossible, but not great.</p>



<p>The other problem was bigger: API users wouldnâ€™t have access to this! Weâ€™d effectively taken away the ability to download images.</p>



<h2>Actual Solution: Just use Ruby on Rails</h2>



<p>Iâ€™m a huge fan of Ruby on Rails. Iâ€™ve been using it since before version 1.0 back in 2005. All of Hardcoverâ€™s backend business logic is in Rails.</p>



<p>Back when I worked at Code School, we served a lot of videos. At one point our video host went down and we scurried to get a backup solution in place. We landed on using an intermediary service that would redirect to the actual host. I thought this would work for Hardcover too. </p>



<h3>Updating the Website to Support Signed URLs</h3>



<p>Hereâ€™s how that works in practice.</p>



<p>Rather including the image from Google Cloud Storage directly, weâ€™d change this to proxy through our Ruby on Rails site. For example:</p>



<div><div>
<p>Example URL</p>


<pre aria-describedby="shcb-language-3" data-shcb-language-name="JavaScript" data-shcb-language-slug="javascript"><span><code>https:<span>//projector.hardcover.app/signed/images/crop?url=https://storage.googleapis.com/hardcover/â€¦jpeg&amp;width=100&amp;height=100</span></code></span><small id="shcb-language-3"><span>Code language:</span> <span>JavaScript</span> <span>(</span><span>javascript</span><span>)</span></small></pre></div></div>



<p>That URL is doing a lot. Letâ€™s break it down.</p>



<p>First, itâ€™s hitting an endpoint in Rails, in this case itâ€™s a route in our Ruby on Rails application.</p>



<div><div>
<p>rails/config/routes.rb</p>


<pre aria-describedby="shcb-language-4" data-shcb-language-name="Ruby" data-shcb-language-slug="ruby"><span><code>namespace <span>:signed_assets</span>, <span>path:</span> <span>:signed</span> <span>do</span>
  resource <span>:images</span> <span>do</span>
    get <span>:crop</span>
    get <span>:enlarge</span>
  <span>end</span>
<span>end</span></code></span><small id="shcb-language-4"><span>Code language:</span> <span>Ruby</span> <span>(</span><span>ruby</span><span>)</span></small></pre></div></div>



<p>This tells Rails to create a two new routes at <code>/signed/images/crop</code> and <code>/signed/images/enlarge</code>. These will go to the controller which needs two methods for <code>enlarge</code> and <code>crop</code>.</p>



<p>Those actions need to do a two things: generate a signed URL for the passed in URL and redirect to that URL.</p>



<p>It should also cache this generated URL. We donâ€™t need to regenerate it every time someone looks at cover. I decided to cache these for 1 day.</p>



<div><div>
<p>rails/controllers/signed_assets/images_controller.rb</p>


<pre aria-describedby="shcb-language-5" data-shcb-language-name="Ruby" data-shcb-language-slug="ruby"><span><code><span><span>module</span> <span>SignedAssets</span></span>
  <span><span>class</span> <span>ImagesController</span> &lt; ApplicationController</span>

    <span># GET /signed/images/enlarge</span>
    <span><span>def</span> <span>enlarge</span></span>
      redirect_to_signed_url(<span>&#34;enlarge&#34;</span>)
    <span>end</span>

    <span># GET /signed/images/crop</span>
    <span><span>def</span> <span>crop</span></span>
      redirect_to_signed_url(<span>&#34;crop&#34;</span>)
    <span>end</span>

    private

    <span><span>def</span> <span>signed_params</span></span>
      @enlarge_params <span>||</span>= params.permit(<span>:url</span>, <span>:width</span>, <span>:height</span>, <span>:type</span>)
    <span>end</span>

    <span><span>def</span> <span>url</span></span>
      @url <span>||</span>= Rails.cache.fetch(<span>&#34;/signed/images/signed/<span>#{signed_params[<span>:url</span>]}</span>&#34;</span>, <span>expires_in:</span> <span>24</span>.hours) <span>do</span>
        ExternalStorage::Google::Cloud.sign(signed_params[<span>:url</span>])
      <span>end</span>
    <span>end</span>

    <span><span>def</span> <span>redirect_to_signed_url</span> <span>action</span></span>
      <span>if</span> url.<span>nil</span>?
        head <span>:unprocessable_entity</span>
      <span>else</span>
        redirect_to <span>&#34;https://cdn.hardcover.app/<span>#{action}</span>?url=<span>#{CGI.escape(url)}</span>&amp;width=<span>#{signed_params[<span>:width</span>]}</span>&amp;height=<span>#{signed_params[<span>:height</span>]}</span>&amp;type=<span>#{signed_params[<span>:type</span>]}</span>&#34;</span>
      <span>end</span>
    <span>end</span>
  <span>end</span>
<span>end</span></code></span><small id="shcb-language-5"><span>Code language:</span> <span>Ruby</span> <span>(</span><span>ruby</span><span>)</span></small></pre></div></div>



<p>This is a mostly standard Ruby on Rails Controller. The public actions are URL endpoints we set in the routes file. The private methods help with code reuse and organization.</p>



<p>The bulk of the work happens in the <code>url</code> method. </p>



<p>First, we check if the given URL is in the cache (weâ€™re using Redis). If something with those contents exist in Redis, we return it any never run the contents of the block that comes after.</p>



<p>If a signed URL isnâ€™t in the cache, we call <code>ExternalStorage::Google::Cloud.sign</code> to generate a signed URL.</p>



<p>Iâ€™m not going to get into generating a signed URL. Weâ€™re using the <a href="https://rubygems.org/gems/google-cloud-storage/versions/1.52.0">google-cloud-storage</a> Ruby gem which handles everything, including the line that actually hits the Google API:</p>



<div><div>
<p>ExternalStorage::Google::Cloud.sign</p>


<pre aria-describedby="shcb-language-6" data-shcb-language-name="Ruby" data-shcb-language-slug="ruby"><span><code>signed_url = file.signed_url <span>method:</span> <span>&#34;GET&#34;</span>, <span>expires:</span> <span>3600</span>*<span>25</span> <span># expires daily</span></code></span><small id="shcb-language-6"><span>Code language:</span> <span>Ruby</span> <span>(</span><span>ruby</span><span>)</span></small></pre></div></div>



<p>These URL endpoints need to be FAST. Loading a page with 100 covers means this endpoint will be hit 100 times. My first iteration didnâ€™t have caching, which led to a 250 ms wait PER IMAGE. With caching itâ€™s 250 ms for the <em>first request</em>, then less than 1 ms after that.</p>



<p>The generated URL will be the same, which also means that the image will be cached on the CDN. If a user refreshes a page, theyâ€™ll still hit Rails to generate URLs for all images, but theyâ€™ll use the images cached by their browser. (<em>side note: Iâ€™d like to improve this even more. Any recommendations?</em>)</p>



<h3>Updating the API to Support Signed URLs</h3>



<p>Things are working for our website visitors, but we need to do one more step for API users: create a new endpoint for generating signed URLs.</p>



<p>Hardcover has an API that registered users can use for accessing their book and reading data. If youâ€™re building something with it, youâ€™ll have our existing Google Cloud Storage URLs already.</p>



<p>I ended up creating a single new endpoint, <code>image_url_signed</code>. It takes in a URL (which could be a cover, avatar or anything) and we return a signed URL.</p>



<figure><img loading="lazy" decoding="async" width="1024" height="270" src="https://wp.hardcover.app/wp-content/uploads/2024/08/Screenshot-2024-08-14-at-3.14.46â€¯PM-1024x270.png" alt="" srcset="https://wp.hardcover.app/wp-content/uploads/2024/08/Screenshot-2024-08-14-at-3.14.46â€¯PM-1024x270.png 1024w, https://wp.hardcover.app/wp-content/uploads/2024/08/Screenshot-2024-08-14-at-3.14.46â€¯PM-300x79.png 300w, https://wp.hardcover.app/wp-content/uploads/2024/08/Screenshot-2024-08-14-at-3.14.46â€¯PM-768x202.png 768w, https://wp.hardcover.app/wp-content/uploads/2024/08/Screenshot-2024-08-14-at-3.14.46â€¯PM-1536x404.png 1536w, https://wp.hardcover.app/wp-content/uploads/2024/08/Screenshot-2024-08-14-at-3.14.46â€¯PM-2048x539.png 2048w, https://wp.hardcover.app/wp-content/uploads/2024/08/Screenshot-2024-08-14-at-3.14.46â€¯PM-1200x316.png 1200w, https://wp.hardcover.app/wp-content/uploads/2024/08/Screenshot-2024-08-14-at-3.14.46â€¯PM-1980x521.png 1980w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<p>Behind the scenes this Hasura API endpoint will hit another Rails controller with a single endpoint for generating a signed URL. Itâ€™s pretty much the same as the other controller.</p>



<div><div>
<p>rails/app/controllers/hasura/signed_assets_controller.rb</p>


<pre aria-describedby="shcb-language-7" data-shcb-language-name="Ruby" data-shcb-language-slug="ruby"><span><code><span><span>module</span> <span>Hasura</span></span>
  <span><span>class</span> <span>SignedAssetsController</span> &lt; Hasura::BaseController</span>
    skip_before_action <span>:set_paper_trail_whodunnit</span>

    <span># Returns a signed asset URL for the given url</span>
    <span># GET /hasura/signed_assets</span>
    <span><span>def</span> <span>index</span></span>
      url = Rails.cache.fetch(<span>&#34;/signed/images/signed/<span>#{input_url}</span>&#34;</span>, <span>expires_in:</span> <span>24</span>.hours) <span>do</span>
        ExternalStorage::Google::Cloud.sign(input_url)
      <span>end</span>
      render <span>json:</span> {
        <span>url:</span> url
      } 
    <span>rescue</span> ExternalStorage::Google::Cloud::AccessDenied
      head <span>:forbidden</span>
    <span>end</span>

    private

    <span><span>def</span> <span>input_url</span></span>
      @input_url <span>||</span>= params.<span>require</span>(<span>:url</span>)
    <span>end</span>
  <span>end</span>
<span>end</span>
</code></span><small id="shcb-language-7"><span>Code language:</span> <span>Ruby</span> <span>(</span><span>ruby</span><span>)</span></small></pre></div></div>



<p>It even uses the same cache as for website users! ðŸ™Œ</p>



<h3>Last Step: Throttling API Use</h3>



<p>With this setup everything <em>works</em>, but we havenâ€™t fully fixed the problem. Someone could still hit our new API endpoints repeatedly and bypass our newfound security.</p>



<p>Hasura has an option that could help here: <strong>API Rate limits</strong>.</p>



<figure><img loading="lazy" decoding="async" width="1024" height="984" src="https://wp.hardcover.app/wp-content/uploads/2024/08/Screenshot-2024-08-14-at-3.21.13â€¯PM-1024x984.png" alt="" srcset="https://wp.hardcover.app/wp-content/uploads/2024/08/Screenshot-2024-08-14-at-3.21.13â€¯PM-1024x984.png 1024w, https://wp.hardcover.app/wp-content/uploads/2024/08/Screenshot-2024-08-14-at-3.21.13â€¯PM-300x288.png 300w, https://wp.hardcover.app/wp-content/uploads/2024/08/Screenshot-2024-08-14-at-3.21.13â€¯PM-768x738.png 768w, https://wp.hardcover.app/wp-content/uploads/2024/08/Screenshot-2024-08-14-at-3.21.13â€¯PM-1536x1476.png 1536w, https://wp.hardcover.app/wp-content/uploads/2024/08/Screenshot-2024-08-14-at-3.21.13â€¯PM-2048x1968.png 2048w, https://wp.hardcover.app/wp-content/uploads/2024/08/Screenshot-2024-08-14-at-3.21.13â€¯PM-1200x1153.png 1200w, https://wp.hardcover.app/wp-content/uploads/2024/08/Screenshot-2024-08-14-at-3.21.13â€¯PM-1980x1903.png 1980w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<p>Unfortunately, this is a Hasura Enterprise feature, and weâ€™re mere peasants on the free version. It can even rate limit by user id from a JWT â€“ which is exactly how we determine the owner of a request.</p>



<p>Iâ€™m considering moving back to enterprise once we can afford it, but thatâ€™s out for now.</p>



<p>Fortunately this endpoint is in Rails. We can lock it down on that side instead. After a little Googling, I found the beautiful <a href="https://github.com/rack/rack-attack">rack-attack gem</a> that does exactly what I was looking for.</p>



<p>If youâ€™re not from the Ruby world, you might not have heard of <a href="https://github.com/rack/rack">Rack</a>. Think of Rack is the base layer that most Ruby web frameworks are built on (Ruby on Rails, Sinatra, Hanami and others). It handles the low level request/response cycle.</p>



<p>The rack-attack gem builds on that with features for IP allowing, blocking and throttling.</p>



<p>In our case we wanted to throttle the API endpoint with at 60 requests a minute, but the website endpoint at 500 a minute â€“ equal to browsing at a steady pace.</p>



<p>This ended up being so much easier than I thought. It only needs a new initializer.</p>



<div><div>
<p>rails/config/initializers/rack-attack.rb</p>


<pre aria-describedby="shcb-language-8" data-shcb-language-name="Ruby" data-shcb-language-slug="ruby"><span><code><span><span>class</span> <span>Rack::Attack</span></span>
  Rack::Attack.cache.store = ActiveSupport::Cache::RedisCacheStore.new(<span>url:</span> ENV[<span>&#34;REDIS_URL&#34;</span>]) 

  throttle(<span>&#34;hasura/signed_assets&#34;</span>, <span>limit:</span> <span>60</span>, <span>period:</span> <span>1</span>.minute) <span>do</span> <span>|req|</span>
    req.params[<span>&#34;user_id&#34;</span>] <span>if</span> req.path == <span>&#34;/hasura/signed_assets&#34;</span>
  <span>end</span>

  throttle(<span>&#34;/signed/images/enlarge&#34;</span>, <span>limit:</span> <span>500</span>, <span>period:</span> <span>1</span>.minute) <span>do</span> <span>|req|</span>
    req.ip <span>if</span> req.path == <span>&#34;/signed/images/enlarge&#34;</span> <span>||</span> req.path == <span>&#34;/signed/images/crop&#34;</span>
  <span>end</span>
<span>end</span></code></span><small id="shcb-language-8"><span>Code language:</span> <span>Ruby</span> <span>(</span><span>ruby</span><span>)</span></small></pre></div></div>



<p>This also uses Redis and will generate a key for each endpoint using the value returned from the block.</p>



<p>This allows us to throttle the API endpoint to 60 requests/minute based on <code>user_id</code>, while the public endpoint used by the website has a limit of 500 requests/minute based on IP address.</p>



<p>Whatâ€™s great about this setup is that this run before Rails has even handled the request â€“ thatâ€™s the beauty of middleware. This will return a <strong>429 Too Many Requests</strong> header after theyâ€™ve reached their limit.</p>



<h2>Limiting the API More?</h2>



<p>One of the reasons I started Hardcover in the first place was because <a href="https://hardcover.app/blog/manifesto" data-type="post" data-id="126">Goodreads discontinued their API</a>. Iâ€™ve never run a public API before, but want to make sure weâ€™re being good stewards of book data by the community as well as everyones personal book data.</p>



<p>I have a few other takeaways from this experience that weâ€™ll put into place in the near future: mostly for rate limiting, reporting, limiting API access to areas that you donâ€™t need access to and expanding on our API terms of service.</p>



<p>What will always be true is that youâ€™ll be able to get any data about books, editions, authors, series, publishers, characters, your library and whatever people that follow you have decided to share. ðŸ“š</p>
</div></div>
  </body>
</html>
