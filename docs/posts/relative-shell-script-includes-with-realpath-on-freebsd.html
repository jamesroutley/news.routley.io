<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://patmaddox.com/doc/trunk/www/2023-12-sh-relative-shell-script-includes-with-realpath-on-freebsd/">Original</a>
    <h1>Relative shell script includes with realpath on FreeBSD</h1>
    
    <div id="readability-page-1" class="page"><div>

<p><em>Published on December 2, 2023</em></p>

<p><em>Discuss:
<a href="https://forums.freebsd.org/threads/article-relative-shell-script-includes-with-realpath-on-freebsd.91270/">FreeBSD forum</a>
|
<a href="https://www.reddit.com/r/freebsd/comments/189k7d8/sh_relative_shell_script_includes_with_realpath/">reddit</a></em></p>

<p><em>View this article&#39;s <a href="https://patmaddox.com/dir?ci=trunk&amp;name=www/2023-12-sh-relative-shell-script-includes-with-realpath-on-freebsd">example files</a></em></p>

<hr/>

<p>I like writing shell scripts, but one thing that has bugged me for years is that I don&#39;t reliably know how to include relative scripts.
I run into three key problems:</p>

<ol>
<li><code>. relative/script.sh</code> depends on the invocation dir.</li>
<li>Symlinking the command results in inconsistent command name and location.</li>
<li>Almost all internet discussion about shell scripting is about Bash, whereas I&#39;m using <a href="https://man.freebsd.org/cgi/man.cgi?sh(1)"><code>sh(1)</code></a> on FreeBSD (aka Bourne shell).</li>
</ol>

<h2>tl;dr: The Solution</h2>
<p>Use <code>$(dirname $(realpath $0))</code> in your command files. <a href="https://man.freebsd.org/cgi/man.cgi?realpath(1)"><code>realpath(1)</code></a></p>

<h2>Problem 1: The invocation dir matters</h2>
<p><em>(<a href="https://patmaddox.com/dir?ci=trunk&amp;name=www/2023-12-sh-relative-shell-script-includes-with-realpath-on-freebsd/1-naive-broken">example files</a>)</em></p>

<p>The obvious way to include relative files is <code>. relative/script.sh</code>.
We have the following file structure:</p>
<pre><code>.
├── bin
│   └── hello.sh
└── lib
    └── libhello.sh
</code></pre>
<p><strong>bin/hello.sh:</strong></p>
<pre><code>#!/bin/sh
. lib/libhello.sh

hello
</code></pre>
<p><strong>lib/libhello.sh:</strong></p>
<pre><code>hello() {
    echo hello, world
}
</code></pre>
<p>Running <code>./bin/hello.sh</code> works as expected, whereas <code>cd bin &amp;&amp; ./hello.sh</code> fails:</p>
<pre><code>./bin/hello.sh
hello, world
cd bin &amp;&amp; ./hello.sh
.: cannot open lib/libhello.sh: No such file or directory
</code></pre>
<p>We need some way of sourcing relative to the script path, rather than the invocation directory.</p>

<h2>Naive solution: Use <code>$0</code> to find the script location</h2>
<p><em>(<a href="https://patmaddox.com/dir?ci=trunk&amp;name=www/2023-12-sh-relative-shell-script-includes-with-realpath-on-freebsd/2-dirname">example files</a>)</em></p>

<p><code>$0</code> returns the name of the invoked command, including any directory prefixing.
We can use it to require relative files:</p>

<p><strong>bin/hello.sh:</strong></p>
<pre><code>#!/bin/sh
LIB=$(dirname $0)/../lib
. $LIB/libhello.sh

hello
</code></pre>
<p>Now the command succeeds, regardless of which dir we invoke it from:</p>
<pre><code>./bin/hello.sh
hello, world
cd bin &amp;&amp; ./hello.sh
hello, world
</code></pre>
<p>However, <code>$0</code> is the name of the command passed to the shell - which may not be the actual command file when using symlinks.</p>

<h2>Problem 2: Symlinks make the script name unreliable</h2>
<p><em>(<a href="https://patmaddox.com/dir?ci=trunk&amp;name=www/2023-12-sh-relative-shell-script-includes-with-realpath-on-freebsd/3-symlink-broken">example files</a>)</em></p>

<p>Referencing <code>$0</code> works, until we symlink the file.
This is the new file structure:</p>
<pre><code>.
├── actual-hello
│   ├── actual-hello.sh
│   └── libhello.sh
└── bin
    └── hello.sh -&gt; ../actual-hello/actual-hello.sh
</code></pre>
<p>Now running <code>./bin/hello.sh</code> tries to include the file relative to <code>bin/hello.sh</code>, when it should be relative to <code>actual-hello/actual-hello.sh</code>.</p>

<p>Fortunately, FreeBSD gives us <a href="https://man.freebsd.org/cgi/man.cgi?realpath(1)"><code>realpath(1)</code></a> to identify the real file referenced by a symlink.</p>

<h2>Solution: Use <a href="https://man.freebsd.org/cgi/man.cgi?realpath(1)"><code>realpath(1)</code></a> to source relative to the real file</h2>
<p><em>(<a href="https://patmaddox.com/dir?ci=trunk&amp;name=www/2023-12-sh-relative-shell-script-includes-with-realpath-on-freebsd/4-symlink-realpath">example files</a>)</em></p>

<p><strong>actual-hello/actual-hello.sh:</strong></p>
<pre><code>#!/bin/sh
LIB=$(dirname $(realpath $0))
. $LIB/libhello.sh

hello
</code></pre>
<p><code>$(realpath $0)</code> returns the path of the real file, so now we can source relative to it.
Our symlink works, regardless the invocation dir:</p>
<pre><code>./bin/hello.sh
hello, world
cd bin &amp;&amp; ./hello.sh
hello, world
</code></pre>
<h2>Bonus solution: A lib helper function</h2>
<p><em>(<a href="https://patmaddox.com/dir?ci=trunk&amp;name=www/2023-12-sh-relative-shell-script-includes-with-realpath-on-freebsd/5-libhelper">example files</a>)</em></p>

<p>Now that we know the basic technique, we can define a <code>BASE</code> var and write our shell library relative to it.
Here&#39;s the file structure:</p>
<pre><code>.
├── actual-hello
│   ├── bin
│   │   └── actual-hello.sh
│   └── lib
│       ├── libhello.sh
│       └── libhelper.sh
└── bin
    └── hello.sh -&gt; ../actual-hello/bin/actual-hello.sh
</code></pre>
<p><strong>actual-hello/bin/actual-hello.sh:</strong></p>
<pre><code>#!/bin/sh
BASE=$(dirname $(realpath $0))/..
. $BASE/lib/libhelper.sh
require_lib &#34;hello&#34;

hello
</code></pre>
<p><strong>actual-hello/lib/libhelper.sh:</strong></p>
<pre><code>: ${BASE:?}
LIB=$BASE/lib

require_lib() {
    . $LIB/lib${1}.sh
}
</code></pre>
<h2>Conclusion</h2>
<p>It&#39;s possible to write <a href="https://github.com/freebsd/poudriere">extremely</a> <a href="https://github.com/churchers/vm-bhyve">powerful</a> <a href="https://github.com/BastilleBSD/bastille">tools</a> using shell scripts, and modularize your code.
Bourne shell doesn&#39;t provide a clear mechanism for referencing relative files.
By establishing a command file&#39;s base dir, you can reliably reference relative shell scripts.</p>

</div></div>
  </body>
</html>
