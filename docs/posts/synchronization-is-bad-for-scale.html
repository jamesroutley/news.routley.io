<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wippler.dev/posts/synchronization-is-bad-for-scale">Original</a>
    <h1>Synchronization Is Bad for Scale</h1>
    
    <div id="readability-page-1" class="page"><div id="quartz-body"><div><article><p>In the early days of <a href="https://mailgun.com">Mailgun</a> I started working on a distributed lock service. Something I had worked on briefly at Rackspace. Even as I implemented the thing, I had the sneaky suspicion that it was a bad idea. So, let‚Äôs talk about why the locking service never took off at Mailgun‚Ä¶</p>
<h3 id="the-synchronization-problem">The Synchronization problem<a aria-hidden="true" tabindex="-1" data-no-popover="true" href="#the-synchronization-problem"> ¬ß</a></h3>
<p>In both distributed and monolithic systems, you often MUST have things which are performed in an orderly or synchronized manner. In almost all cases where synchronization is required, it is due to the system needing to write something. Whether it‚Äôs a financial system recording the order of debits to credits, or an apache access log on a server. Write synchronization happens everywhere.</p>
<p>In monolithic design, you have an easy answer to this problem, just use a mutex lock. Indeed, most logging systems use a lock in order to ensure log lines do not clobber each other and remain legible. But a lock in a monolithic design has the same problem as a lock in a distributed design, they both create a synchronization point, which is typically bad for scaling horizontally.</p>
<p>Most of the time, we don‚Äôt see a problem with using a lock, as our laptops and services don‚Äôt span 8+ CPUs to do their work. However, In a very high concurrency system where there are a non-trivial number of CPUs in use, kernel locking ‚Äî regardless of how fast ‚Äî eventually gets in the way of scaling.</p>
<p>Consider <a href="https://github.com/gubernator-io/gubernator">https://github.com/gubernator-io/gubernator</a> where you have a service which needs to handle tens of thousands of concurrent requests, each of which needs access to a central in-memory cache of rate limits. In such a situation, lock contention will eventually become a problem. To solve this problem, you have two options, you can shard or you can eliminate the lock.</p>
<p>Because Gubernator doesn‚Äôt do anything CPU intensive, each request simply needs access to the shared cache. The answer to the synchronization problem for Gubernator was to remove the need for a lock by using a <a href="https://s3fifo.com/">S3-FIFO</a> cache. We did attempt to shard, but the overhead of calculating the hash to shard with, and the increased number of queues and threads needed (thus increased context switching) made this a unviable solution for our use case.</p>
<p>Looking at the graph below, you can see the <code>Otter</code> implementation (S3-FIFO) easily beat out the <code>WorkerPool</code> (Hash) implementation in our tests. Interestingly, we were only able to see such an improvement when running this test on a machine with a very high number of vCPUs. Running this test on my development laptop showed very little performance improvement over the <code>WorkerPool</code> or <code>Mutex</code> implementation. This is because the lock contention only showed up once we got to sufficient horizontal scale.</p>
<p><img src="https://wippler.dev/images/Gubernator-S3-FIFO.png" width="auto" height="auto"/></p>
<h3 id="digging-deeper">Digging Deeper<a aria-hidden="true" tabindex="-1" data-no-popover="true" href="#digging-deeper"> ¬ß</a></h3>
<p>To get a deeper understanding of what is happening when you use a lock with multiple CPUs, consider a few traces I took while looking into Gubernator lock contention. We can visualize the effect lock contention has on our CPU‚Äôs by using the trace tool built into golang.</p>
<p>In the trace below the tiny green vertical bars indicate CPU work (the time when the CPU is doing work), the opaque area‚Äôs between the green lines indicate CPU wait (waiting around to do something). The graph below shows a trace I took of a benchmark running for a few seconds, then running the same benchmark test again, but each time increasing the number of CPUs golang can use by calling <code>runtime.GOMAXPROCS(processors)</code> in between each run, until we reached 32 processors. The benchmark‚Äôs only job is to do as much work as possible in as little time as possible. As such, an efficient use of resources will use as much CPU as possible without allowing the CPU to wait around for more work. Thus the most efficient implementation will show a solid green bar, the more green you see, the better.</p>
<p>Here is Gubernator‚Äôs mutex implementation
<img src="https://wippler.dev/images/Gubernator-Trace-Mutex.png" width="auto" height="auto"/></p>
<p>The first few seconds of the test use only 1 CPU, and you can see a mostly solid green line on processor 0, which indicates that the CPU was engaged for most of the time during that benchmark run ‚Äî which is what we want. After that run, you see the test run again but with 2 CPUs in the test, and the green lines ‚Äî though not as solid as before ‚Äî are evenly distributed between the 2 processors. Next you see 4 processors engaged and again, very even distribution. After we get to 8 CPUs the distribution starts to fall off and even though we are using more CPUs the efficient use of each CPU starts to drop off dramatically, until we get to 32 processors where several CPUs mostly sit around waiting for lock access. This waiting around is all due to the mutex lock or synchronization that has to occur for all of the CPU‚Äôs to access the shared cache. For the curious, <a href="https://go.dev/src/sync/mutex.go?s=765:813#L42">golang implements a 2 mode mutex</a>, once starvation occurs, you get what you see above.</p>
<p>Now let‚Äôs look at the same benchmark but this time, with no mutex, using a lock-less shared cache.
<img src="https://wippler.dev/images/Gubernator-Trace-Lock-Free.png" width="auto" height="auto"/>
We can quickly see the distribution of work (the green lines) is more evenly distributed. Since we‚Äôve avoided synchronization, we get more efficient use of the CPU resources at our disposal. We never get a completely even distribution of CPU due to the context switching that needs to occur between threads, but you get the idea.</p>
<blockquote>
<p>If the work we gave each thread was more CPU intensive, you would likely see an even distribution. For Gubernator, the work each thread is doing is literally a simple ‚ÄúGet this value from the cache, and return it‚Äù. As a result, context switching degrades our efficiency as the number of CPU‚Äôs increases. And, now you know why a single threaded <a href="https://redis.io/">Redis</a> server can be so fast üòâ</p>
</blockquote>
<h3 id="the-locking-service">The Locking Service<a aria-hidden="true" tabindex="-1" data-no-popover="true" href="#the-locking-service"> ¬ß</a></h3>
<p>At the beginning of this article, I teased that I once worked on a distributed lock service at Mailgun. Now‚Ä¶ Hopefully, you understand why this turned out to be a bad idea. Distributed locking sounds like a good idea on paper; but, just like a lock in a monolithic application, it‚Äôs not great for concurrent scaling, which is why you want to build a distributed system in the first place!</p>
<p>The lock service implementation wasn‚Äôt anything special, it was a single service instance which held on to a reservation which a client requested to gain the lock. If the client who gained the lock didn‚Äôt unlock it within the time it promised, then the lock would release, and allow some other client to gain the lock. The initial version was purely in memory with no storage at all. Thankfully, I worked with some very smart people and they convinced me it was a bad idea, and I abandoned the project after it very quickly become apparent that despite having written the service in this super fast, brand new language called golang, the service just wasn‚Äôt fast enough to handle the scale we threw at it.</p>
<p>What did we do instead? Well, I‚Äôll answer like any good Principal Engineer should‚Ä¶ ‚ÄúIt depends‚Ä¶‚Äù</p>
<p>A few Solutions that have worked for us:</p>
<h6 id="spread-the-load-across-multiple-tables">Spread the load across multiple tables<a aria-hidden="true" tabindex="-1" data-no-popover="true" href="#spread-the-load-across-multiple-tables"> ¬ß</a></h6>
<p>We have successfully implemented round robin writes/reads across many MongoDB collections. By writing &amp; reading to many collections (tables) we spread synchronization across many CPU‚Äôs and files. This works well in situations where rebalance of the data isn‚Äôt required, such as when used as a queue for ingestion. Rebalancing data in a sharded system can be an expensive operation and depending on the workload, is often more trouble than it‚Äôs worth. However, when used as a write queue from which the rest of the system can pull from ‚Äî which is very similar to <a href="https://kafka.apache.org/">Kafka‚Äôs</a> topics and partitions ‚Äî you by pass any write synchronization issues your database may have, which allows you to ingest massive amounts of data which your system can then process as it see‚Äôs fit. For the curious, we did use Kafka; just not for our ingest queue. I swear we had a very good reason for it! I guess I‚Äôll have to write about that some day. If you want, you can read about <a href="https://wippler.dev/posts/The-Write-Synchronization-Problem" data-slug="posts/The-Write-Synchronization-Problem">The Write Synchronization Problem</a> which I used when on-boarding new devs, to explain some of the concepts I‚Äôm describing here, so there is a bit of an overlap.</p>
<h6 id="consistent-hashing">Consistent Hashing<a aria-hidden="true" tabindex="-1" data-no-popover="true" href="#consistent-hashing"> ¬ß</a></h6>
<p>There were some situations where we needed a synchronization point, but we wanted to avoid the rebalancing problem. The way to get the best of both worlds is to separate your sync point from your storage. We do this by using a consistent hash ring algorithm to determine which node in a distributed system should ‚Äúown‚Äù the synchronization. Then, when a bit of work that requires synchronization happens ‚Äî just like in sharded solution ‚Äî we hash a key for that work and send the work to the node the hash ring tells us ‚Äúowns‚Äù that synchronization process. In this way, keys which hash to the same value ‚Äî regardless who which node received the work ‚Äîis always forwarded to the same node for processing.</p>
<p>This works great for ‚ÄúThis can only happen once anywhere in the cluster‚Äù style things. The result of that synchronization work is often stored in an un-sharded database. This is because the important part ‚Äî the synchronization ‚Äî was performed in the service, not the database. This is great, since it‚Äôs easier and cheaper to scale up and down a service than it is to scale a database. See <a href="https://wippler.dev/posts/You-don&#39;t-know-how-to-Cloud" data-slug="posts/You-don&#39;t-know-how-to-Cloud">You don‚Äôt know how to Cloud</a></p>
<p>The TLDR is, most of the problems where you think you need a distributed lock, we solved by using a <a href="https://www.geeksforgeeks.org/consistent-hashing/">Consistent Hash</a> or the <a href="https://microservices.io/patterns/data/saga.html">Saga Pattern</a>.</p>
<h6 id="reservation-queues">Reservation Queues<a aria-hidden="true" tabindex="-1" data-no-popover="true" href="#reservation-queues"> ¬ß</a></h6>
<p>Reservation queues were at the heart of a lot of what we did a Mailgun, so I want to quickly touch on this topic, as the reservation pattern is a very close cousin too a lock. The nice thing about the <a href="https://wippler.dev/posts/Reservation-Pattern-in-Queues" data-slug="posts/Reservation-Pattern-in-Queues">Reservation Pattern in Queues</a> is that much like a lock, you gain exclusive access to an item for a period of time. Unlike a shared mutex lock, you are not locking a shared resource in order to create a synchronization point. The Reservation only says that a part of your distributed system has gained exclusive access to process a bit of data, no one else can process it except the entity which owns the lock on that item. This particular locking pattern scales, as you are not gaining the exclusive right a shared resource, but instead to process one of many thousands or millions of items which could be processing in parallel.</p>
<h6 id="avoid-synchronization">Avoid synchronization<a aria-hidden="true" tabindex="-1" data-no-popover="true" href="#avoid-synchronization"> ¬ß</a></h6>
<p>Much like the lock free implementation in Gubernator we talked about earlier, you may THINK you need a lock, but often, if you look closely, you find that you actually don‚Äôt need a lock. We have found that if you avoid thinking about your system like you would a relational database, by that I mean, avoid thinking in terms of data consistency, and embrace eventual consistency, embrace data normalization via <a href="https://www.datacamp.com/tutorial/single-table-database-design-with-dynamodb">single table design</a>, and design data models which lend to concurrent processing, then most of the situations where you thought you needed a lock, go away.</p>
<h6 id="the-saga-pattern">The Saga Pattern<a aria-hidden="true" tabindex="-1" data-no-popover="true" href="#the-saga-pattern"> ¬ß</a></h6>
<p>This discussion is close enough to transactions that I had to put this in here. When we needed to do distributed transactional things, we used the <a href="https://microservices.io/patterns/data/saga.html">Saga Pattern</a> and this worked really well for us.  See <a href="https://wippler.dev/posts/Reservation-Pattern-in-Queues" data-slug="posts/Reservation-Pattern-in-Queues">Reservation Pattern in Queues</a></p>
<h3 id="the-database-as-a-synchronization-point">The Database as a synchronization point<a aria-hidden="true" tabindex="-1" data-no-popover="true" href="#the-database-as-a-synchronization-point"> ¬ß</a></h3>
<p>Databases are very good at synchronization, for they must synchronize many threads attempting to write to a single table. But as we‚Äôve seen above, synchronization will eventually impede our ability to scale. So‚Ä¶ the simple answer to avoid sync contention in a database, is to shard across more than one table, database or cluster.</p>
<p>At <a href="https://mailgun.com">Mailgun</a> we needed a way to quickly enqueue messages to be sent. In order to do this, we spread message writes across multiple databases and collections with MongoDB to great success. As a result we were able to scale MongoDB too many billions of messages a day with a few clusters of 3 nodes running on general compute. By writing to hundreds of collections (tables) per node we were able to avoid lock contention and get the most out of the resources we had.</p>
<blockquote>
<p>With replica sets, when MongoDB writes to a collection on the primary, MongoDB also writes to the primary‚Äôs oplog, which is a special collection in the local database. Therefore, <strong>MongoDB must lock both the collection‚Äôs database and the local database</strong>.</p>
</blockquote>
<h4 id="use-with-caution">Use With Caution<a aria-hidden="true" tabindex="-1" data-no-popover="true" href="#use-with-caution"> ¬ß</a></h4>
<p>Since synchronization is literally built into the database, it‚Äôs very tempting to use the Database and the transactions they provide as the synchronization point for EVERYTHING. I would advise caution here, because the database is an expensive part of; and often is THE MOST EXPENSIVE part of your infrastructure. It‚Äôs better suited for storing bits on disk, than for synchronizing all of the things for you. If you rely on the DB for synchronization, you will inevitably need to shard and rebalance your database in order to continue scaling, and BTW, you are scaling the most expensive part of your infra.</p>
<p>As an example, one of our email competitors, ‚Äî  which we later acquired ‚Äî built their entire tech stack around PostgreSQL. As a result, they used PostgreSQL for ALL their synchronization. In order to scale, they built their own custom sharding solution which, unfortunately, sharded by customer, and it was a nightmare. In order to maintain relational consistency, during a rebalance they had to move all a customer‚Äôs data together in a single operation. This isn‚Äôt a problem if the data is small, however, if they on-boarded a customer that grew too quickly, with terabytes of data for a single customer, they had no hope of ever rebalancing them to a different cluster as the operation to move all that data would take hours, during which the customer would not be able to send or use their system. Their only recourse was to upgrade to beefy, very expensive database clusters when rebalancing was not an option.</p>
<p>Mailgun was able to scale efficiently by avoiding exactly that problem, by not using the database as a synchronization point. Instead, we intentionally created synchronization points in our code. This allowed us to scale up and down independent of the database as the load increased or decreased, thus saving us lots and lots of money.</p>
<h3 id="the-end">The End<a aria-hidden="true" tabindex="-1" data-no-popover="true" href="#the-end"> ¬ß</a></h3>
<p>I‚Äôve run out of things to talk about here, but I will eventually talk more about the saga pattern and distributed transactions, as I‚Äôm currently working on <a href="https://github.com/kapetan-io/querator">Querator</a> which takes all of the lessons learned from implementing the Saga pattern and in code synchronization into a friendly and reusable service.</p></article></div></div></div>
  </body>
</html>
