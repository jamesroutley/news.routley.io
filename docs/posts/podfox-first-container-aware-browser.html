<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://val.packett.cool/blog/podfox/">Original</a>
    <h1>Podfox: First Container-Aware Browser</h1>
    
    <div id="readability-page-1" class="page"><p>A port conflict pushed me to abolish container port forwarding once and for all, making my Firefox talk to Podman&#39;s whole network. Also: containerizing dev environments for command-line addicts.
</p><div>
		<p>Containers. Containers containers containers. Even if you were reluctant before, it’s likely that you use them at least for running various supporting infrastructure when working on projects that involve that kind of thing. Having a whole-system install of Postgres on a laptop shared between various different projects never actually felt right. Running <code>podman run --rm -it -p 5432:5432 postgres:17</code> to pop up a temporary instance with no persistent state does.</p>
<p>These days, it’s very typical for any web backend or other kind of networked service project to include something like a <code>docker-compose.yml</code> file that makes it possible to just run all the service dependencies with one single command. And so I was running a Compose setup for one project, a serious business client consulting job thing, and I kept it in the background and I went to start up another project and—</p>
<p>oh no, that failed with EADDRINUSE. A <em>port conflict</em>.</p>
<p>Both projects involved RabbitMQ and both forwarded the management web UI port to the host:</p>
<pre><code>  <span>queue:</span>
    <span>image:</span> <span>rabbitmq:3-management</span>
    <span>ports:</span> 
      <span>-</span> <span>&#34;15672:15672&#34;</span>
</code></pre>
<p>And as such, I couldn’t launch both projects without modifying the port numbers or something. So like any rational well-adjusted chill person, at that point I’ve decided that port forwarding Must. Be. ABOLISHED!!</p>
<p>Seriously though, we have <a href="https://flathub.org/apps/app.devsuite.Ptyxis">Ptyxis</a> as a container-aware terminal emulator… why isn’t there a container-aware web browser that would just communicate directly with the containers? (Does anyone remember <a href="https://web.archive.org/web/20150313045857/http://pow.cx/">Pow</a> from the golden age of Rails that proposed the “just open <code>yourapp.dev</code>” experience?)</p>
<p>As the title suggests, now there kinda is a container-aware browser:</p>
<figure>
	<picture>
		<source type="image/webp" srcset="scr.webp"/>
		<img alt="Screenshot with a Firefox window on top showing a RabbitMQ management UI on http://myrabbit.randomtests.podman, and a terminal on the bottom shown launching podman run --rm -it --network randomtests --name myrabbit rabbitmq:3-management" src="https://bugwhisperer.dev/blog/static-site-hosting-on-bunnynet/scr.png" width="1438" height="1080" loading="lazy" decoding="async"/>
	</picture>
</figure>
<p>Okay, the title is slightly exaggerated. It’s not that the browser itself was modified in any way. And no, it’s not just running inside of a Podman container. There’s a process running alongside everything that makes it possible, and it’s quite simple and tiny.</p>
<p>Can you already guess how it works? First, let’s see how we got here.</p>
<h2 id="how-do-containers-even-networking" tabindex="-1"><a href="#how-do-containers-even-networking"><span>How Do Containers Even Networking??</span></a></h2>
<p>Back in the day, containering required root privileges and there was a daemon running as root, which always felt repulsive to me. It never was an inherent necessity, but Linux’s namespacing abilities weren’t good enough to run without privileges. These days —thankfully— they are, and Podman encourages running “rootless” (and daemonless).</p>
<p>In the old-school rootful setup, networking is pretty straightforward: the daemon can create bridge interfaces on the host, containers get assigned IP addresses on a bridged subnet, and they are accessible as if they were actual machines. And it’s possible to <a href="https://forums.docker.com/t/docker-using-dnsmasq-as-resolver-forwarder-to-reach-containers-from-host/137390">set up DNS</a> on the host machine to resolve to container names but like… ugh, <em>messing with DNS</em>.</p>
<p>But as an unprivileged process we can’t just create bridges on the host (and I wouldn’t <em>want</em> anything to show up in the list of network interfaces, it bothers me to see Stuff there!) so what does Podman do?</p>
<p>You might’ve heard about networking being “all fake in userspace” with <code>slirp4netns</code> which is an amazing resurrection of early-90s modem era hacks that has just <a href="https://www.youtube.com/watch?v=QMUEtEt1i3I">been replaced by</a> a modern alternative called <code>pasta</code> (mm, tasty – wait, what’s that <a href="https://github.com/rootless-containers/bypass4netns">bypass4netns</a> thing?). Heck, Podman’s <a href="https://github.com/containers/podman/blob/400a9a528bfc33d23725958f379cb2bfecb4865e/docs/tutorials/rootless_tutorial.md">actual “rootless tutorial”</a> mentions these as <em>the</em> “rootless networking tools”. But… actually… that’s just the teeny tiny part that makes it possible for the unprivileged containers to <em>reach out to the outside world</em>.</p>
<p>The actual networking stack is the real Linux kernel one, namespaced.</p>
<p><a href="https://github.com/containers/podman/discussions/22943#discussioncomment-9795883">Here’s what it actually looks like</a>. Rootless Podman first creates a single network namespace called <code>rootless-netns</code>, inside of which it creates bridge networks, real Linux kernel bridges; and for each container that joins a network it spawns it makes a <code>veth</code> pair, one end of which is connected to the network’s bridge interface in the aforementioned common namespace, and the other end passed to the container’s own namespace.</p>
<p>And we can manually enter that “parent” namespace —without entering “a container”, <em>only</em> entering the network namespace— by running <code>podman unshare --rootless-netns</code>.</p>
<p>Wait, how does that work? Tell me, <a href="https://wizardzines.com/zines/strace/">almighty <code>strace</code></a>!</p>
<pre><code>open(&#34;/run/user/1000/libpod/tmp/pause.pid&#34;, O_RDONLY|O_LARGEFILE) = 4
read(4, &#34;1809&#34;, 11)                     = 4
open(&#34;/proc/1809/ns/user&#34;, O_RDONLY|O_LARGEFILE|O_CLOEXEC) = 5
fcntl(5, F_SETFD, FD_CLOEXEC)           = 0
open(&#34;/proc/1809/ns/mnt&#34;, O_RDONLY|O_LARGEFILE|O_CLOEXEC) = 6
fcntl(6, F_SETFD, FD_CLOEXEC)           = 0
setns(5, 0)                             = 0
setns(6, 0)                             = 0
</code></pre>
<p>Oh, umm, that’s it?? Wait, where’s the netw—</p>
<pre><code>openat(AT_FDCWD, &#34;/run/user/1000/containers/networks/rootless-netns/rootless-netns&#34;, O_RDONLY|O_CLOEXEC) = 8
[…]
setns(8, CLONE_NEWNET)                  = 0
</code></pre>
<p>Right, that explains the <code>mnt</code> namespace above.</p>
<p>So the key is the <a href="https://man7.org/linux/man-pages/man2/setns.2.html">setns(2)</a> system call, which “allows the calling thread to move into different namespaces”. When it’s the only thread in the process, mind you, so we can’t just have different threads in different namespaces. But no one said we can’t retain open sockets from the previous namespace before switching! Just realizing that opens a world of possibilities. Now we can build a very elegant and simple…</p>
<h2 id="proxy-ding-ding-ding-ding-ding" tabindex="-1"><a href="#proxy-ding-ding-ding-ding-ding"><span>Proxy! Ding ding ding ding ding</span></a></h2>
<p>If you guessed “proxy” before reading all of the above, congratulations! You win! :)</p>
<p>That is what <a href="https://codeberg.org/valpackett/podfox#podfox">Podfox</a> actually is. It’s a SOCKS proxy that starts listening on the host system and then enters Podman’s rootless networking namespace in order to talk to your containers. It’s a portal into the container world, running as one simple process, written in Rust.</p>
<p>There’s no need to do any DNS on the host, as a proxy can handle hostnames however it likes, so Podfox parses <code>&lt;container&gt;.&lt;network&gt;.podman</code> hostnames, queries <code>podman network inspect</code> with the <code>network</code> name to find the gateway address for the network, finally sends a DNS query for <code>&lt;container&gt;.dns.podman</code> to that network’s gateway, connects to the returned address and starts proxying.</p>
<p>Beautiful.</p>
<p>It just works.</p>
<p>And you can install it from crates.io right now:</p>
<pre><code>cargo install --locked podfox
</code></pre>
<p>And run it as just <code>podfox</code>, it would listen on port :42666 by default. (It also support systemd socket activation!)</p>
<p>Now, um, we haven’t actually touched the “fox” part of it all. The browser. When I was first testing, I was using Multi-Account Containers’ (heh) ability to assign proxies per Firefox container, but that was just for testing.</p>
<p>Later I made a WebExtension to make a global proxy rule that assigns the Podfox proxy to the fake <code>.podman</code> TLD. It’s probably the simplest Firefox add-on ever that’s actually useful, as all it contained was a one-liner (!) background script:</p>
<pre><code>browser.<span>proxy</span>.<span>onRequest</span>.<span>addListener</span>(<span>() =&gt;</span> ({ <span>type</span>: <span>&#34;socks&#34;</span>, <span>host</span>: <span>&#34;localhost&#34;</span>, <span>port</span>: <span>42666</span>, <span>proxyDNS</span>: <span>true</span> }), { <span>urls</span>: [<span>&#34;*://*.podman/*&#34;</span>] });
</code></pre>
<p>But I’m not feeling like publishing a literal one-liner to addons.mozilla.org. I am considering making a tiny add-on for creating rules of this sort via a settings UI, but for now I’ve discovered a simpler solution that doesn’t require any add-on publishing at all.</p>
<p>Yeah, it’s <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Proxy_servers_and_tunneling/Proxy_Auto-Configuration_PAC_file">PAC (Proxy Auto-Configuration)</a>. Another 90s comeback, just like SLiRP!</p>
<p>Place the following in a file directly accessible to Firefox (I’m saying that because mind the Flatpak – if running Flatpak Firefox, expose a new directory through <a href="https://flathub.org/apps/com.github.tchx84.Flatseal">Flatseal</a> with just the file):</p>
<pre><code><span>function</span> <span>FindProxyForURL</span>(<span>url, host</span>) {
  <span>if</span> (host.<span>endsWith</span>(<span>&#39;.podman&#39;</span>))
    <span>return</span> <span>&#39;SOCKS5 localhost:42666&#39;</span>;
  <span>return</span> <span>&#39;DIRECT&#39;</span>;
}
</code></pre>
<p>Finally, configure Firefox to use it (and tick the checkbox to proxy DNS names):</p>
<figure>
	<picture>
		<source type="image/webp" srcset="prefs.webp"/>
		<img alt="Screenshot of Firefox proxy settings, set to &#39;Automatic proxy configuration URL&#39; with a path of &#39;file:///home/val/.config/podfox/podfox.pac&#39;, and at the bottom the &#39;Proxy DNS when using SOCKSv[45]&#39; checkboxes are checked" src="https://bugwhisperer.dev/blog/static-site-hosting-on-bunnynet/prefs.png" width="940" height="473" loading="lazy" decoding="async"/>
	</picture>
</figure>
<p>Now you have this virtual <code>.podman</code> TLD always accessible in the browser, and as long as the Podfox proxy is running, you can open any port on any container in any network in your rootless Podman runtime!</p>
<h2 id="bonus-containerizing-my-cli-development-environment" tabindex="-1"><a href="#bonus-containerizing-my-cli-development-environment"><span>Bonus: Containerizing my CLI Development Environment</span></a></h2>
<p>So with this ability to browse services running in containers, and without using port forwarding, the services under development must run in containers as well, of course.</p>
<p>There’s been an explosion of container dev tools in the recent years. I’ve heard of <a href="https://tilt.dev/">Tilt</a> which provides a workflow where service containers by default get constantly rebuilt (and on top of that there’s an option for supporting live-reloading by copying changes into the container) and there’s a nice UI page for watching all the logs and the “most heavily suggested” runtime is a local Kubernetes cluster (even though just running in Podman is also possible). And <a href="https://containers.dev/">the Development Container Specification™ from MicrosoftⓇ</a> comes from the VSCode and GitHub Codespaces world and provides a manifest format that lets (typically) IDEs know how to set up a container where (typically) the Run button would run the app (and the language server and other related tools).</p>
<p>But I like my command-line environment and I don’t want it to be disrupted! I edit code in <a href="https://helix-editor.com/">Helix</a> —which runs language servers that might share their caches with the actual build— and run a variety of random tools, all from my <a href="https://fishshell.com/">fish</a> shell configured with a prompt that I like and so on.</p>
<p>Trying to run just-the-project-parts like the compiler, the service itself, the language server and language-specific tools like linters and formatters inside of the container sounds kinda painful, as for example Helix doesn’t have a “wrap all the tools in something” option, and configuring the PATH to include containerized tools or wrapping invocations manually sounds very annoying. I’d rather… bring my whole environment into each container!</p>
<p>Running a container with my dotfiles is surprisingly easy: <code>-v $HOME/.config:$HOME/.config:ro</code> – thankfully pretty much everything I use supports XDG directories and doesn’t pollute <code>~</code> with random paths. But what about the shell, the editor, the random tools? Building my own containers per project that add my tools on top of the project’s image sounds annoying, slow and heavy. Installing them in an overlay volume that wouldn’t even be a container image (which seems to be how VSCode dev containers do stuff) feels like a “dirtier” version of the same. Can’t I just <code>-v</code> mount them?</p>
<p>Well, with how my setup already was, most of my tools were installed by an <a href="https://codeberg.org/valpackett/dotfiles/src/commit/105193ab7a140986a30a3e42ce37d5220b7d75e6/.config/fish/functions/updatetools.fish">updatetools</a> script into <code>~/.local</code> directories. However, of course, they’re built for the host system — dynamically linking, currently, to <a href="https://chimera-linux.org/">Chimera</a>’s musl libc, LLVM libc++, and occasionally to various other system-wide libraries. They weren’t going to work in a random Debian-based container, unless packed with <a href="https://github.com/VHSgunzo/sharun">sharun</a> or whatever was the tool that I saw ages ago, but the whole point is to <em>avoid</em> “weird stuff” like this. And I don’t want to build static binaries either. Not everything <em>can</em> work as static binaries, even.</p>
<p>That’s when it hit me.</p>
<p>The answer is to get <a href="https://brew.sh/">Homebrew</a>.</p>
<p>Yes, that same package manager that came from the macOS world and always had to consider the host OS as sorta immutable, which in the old days was seen as a workaround for a proprietary OS, but now is a huge asset. Homebrew manages a separate unprivileged prefix, and has prebuilt packages with a fixed one, currently <code>/home/linuxbrew/.linuxbrew</code> on Linux. (It also does <a href="https://www.gobolinux.org/">GoboLinux</a>-style multi-versioning, which I like to jokingly call “<a href="https://nix.dev/">Nix</a> for those of us who touch grass”, but that’s not very relevant right now.)</p>
<p>With containers, we can just mount Homebrew’s prefix: <code>-v /home/linuxbrew:/home/linuxbrew:ro</code>. And append it to the PATH with Podman’s nice env-merge feature: <code>--env-merge PATH=\${PATH}:/home/linuxbrew/.linuxbrew/sbin:/home/linuxbrew/.linuxbrew/bin</code>. And now we can change the <code>--entrypoint</code> to the homebrewed fish… and we’re off to the races!</p>
<figure>
	<picture>
		<source type="image/webp" srcset="hop.webp"/>
		<img alt="Screenshot of a terminal, first running fastfetch that shows Chimera Linux, then running &#39;podman run --rm -it --tz local -v /home/linuxbrew:/home/linuxbrew:ro --env-merge PATH=${PATH}:/home/linuxbrew/.linuxbrew/sbin:/home/linuxbrew/.linuxbrew/bin -e XDG_CONFIG_HOME=$HOME/.config -v $HOME/.config:$HOME/.config:ro -v $PWD:$PWD -w $PWD --entrypoint (which fish) haskell:9.10.1&#39;, the same shell prompt appears, fastfetch is run and shows Debian" src="https://bugwhisperer.dev/blog/static-site-hosting-on-bunnynet/hop.png" width="1504" height="1152" loading="lazy" decoding="async"/>
	</picture>
</figure>
<p>Now THAT’S what I call “distro hopping”!</p>
<p>Despite the superficial similarity with <a href="https://distrobox.it/">Distrobox</a> the above screenshot has at a glance, this is a different idea. Remember, we’re still talking about project-specific dev containers. This is <em>not</em> a persistent “pet” container where you persistently install packages from another distro,</p>
<p>this is a runtime COMPOSITION of an ephemeral/“cattle” project-specific dev container that just has the project’s toolchain, and a “pet” user environment, mounted read-only.</p>
<p>And because it’s mounted, there are no redundant copies that can get outdated and no delay for copying/installing stuff! This is really cool. I can just enter any container image while bringing all my comfy stuff with me, instantly.</p>
<p>I went all-in on Homebrew, mostly replacing my custom tool installation/update script with a <a href="https://codeberg.org/valpackett/dotfiles/src/branch/trunk/.config/homebrew/Brewfile">Brewfile</a>, and I’m really happy about it. As a bonus, it also makes the original full-system kind of distro hopping easier! If I use Homebrew for all my CLI stuff and Flatpak for all my GUI stuff, I could be using something as fixed and bare-bones as <a href="https://os.gnome.org/">GNOME OS</a> for the host! Though I’m currently most intrigued by <a href="https://aerynos.com/">AerynOS</a> which reflects a lot of my engineering values and choices.</p>
<p>Anyway, so, I started by writing out these long <code>podman run</code> invocations and quickly felt the need to automate them. The result is called <a href="https://codeberg.org/valpackett/dotfiles/src/branch/trunk/.config/fish/functions/podchamp.fish">Podchamp</a> (<a href="https://codeberg.org/valpackett/dotfiles/src/commit/105193ab7a140986a30a3e42ce37d5220b7d75e6/.config/fish/functions/podchamp.fish">current version permalink</a>) as a silly internet reference. It’s just a fish script that lives in my dotfiles, I’m not releasing it as a Real Project™ since it’s tiny and relatively specific to the way I personally do things, but what it does is simple: it finds the first <code>.podchamp[.local]</code> config file above the working directory (in a “project root”), reads container-running instructions and either <code>run</code>s a podman container or <code>exec</code>s into an existing one. The instructions look like:</p>
<pre><code>image mycoolproject-dev:latest
pod pod_mycoolproject
network mycoolproject_app-network
name mycoolproject-dev
persist /var/cache/rust
env CARGO_TARGET_DIR=/var/cache/rust
requires mycoolproject_postgres mycoolproject_rabbitmq
</code></pre>
<p>so it’s basically a bunch of convenience to store the per-project development container configuration in an actual file and not in shell history. And it’s been working great for me!</p>
<p>It also emits OSC 777 sequences to indicate to <a href="https://gitlab.gnome.org/chergert/ptyxis">Ptyxis</a> which container has been just entered, which (for now) Podman itself doesn’t do. The container-awareness in the terminal emulator is really nice for being able to spawn new tabs in the same container as the current tab – yes, not that much more, but that’s <em>huge</em> for UX. It would be nice to have the same experience in other terminals — there’s <a href="https://github.com/ghostty-org/ghostty/discussions/2358">a prototype for Ghostty</a> already, and I’m looking into making it work <a href="https://github.com/wezterm/wezterm/issues/6914">in WezTerm</a>.</p>

	</div></div>
  </body>
</html>
