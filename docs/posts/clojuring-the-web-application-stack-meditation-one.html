<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.evalapply.org/posts/clojure-web-app-from-scratch/index.html">Original</a>
    <h1>Clojuring the web application stack: Meditation One</h1>
    
    <div id="readability-page-1" class="page"><div id="the-very-top">
        
  <main id="main">
    <article id="blog-post">
  <header>
      <p>Clojuring the web application stack: Meditation One</p>

      <p>
        <span>[ ↓ <a href="#blog-post-toc" rel="bookmark" target="_self">toc</a> ]</span>
        <span>Published: 2024-08-24</span>
        <span>Updated: 2025-02-18</span>
        
      </p>

      <p>
        In a land bereft of a canonical &#34;killer app&#34; web framework or two, one must think about the what, why, how, where of all the moving parts. Out here, one must become a student of web framework architecture in addition to web application architecture. For here, in Clojure-land, the two are one. ☯
      </p>
     
     
  </header>
  <hr/>
  <section>
      
<hr/>
  
<ul>
<li><p>This post is big! Skip whatever bores… Follow the <a href="#blog-post-toc">nice ToC</a>!</p></li>
<li><p>It is an &#34;I to I&#34; explanation I wish I had long ago. I&#39;ve referenced <a href="#getting-started-and-tutored">getting started material</a> and <a href="#review-the-current-state-of-the-art">&#34;batteries included&#34; Clojure web stacks</a> toward the end, which may be the most practically useful section of this post.</p>
<ul>
<li><p><strong>Update (2025-02-18):</strong> Links to my talk at Functional Conf 2025: <strong><em>Composing (Clojure) Web Stacks using Functional First Principles</em></strong> (<a href="https://www.youtube.com/watch?v=YEHVEId-utY&amp;list=PLG4-zNACPCsNVwz3ohXKeoeQjRLoFsc7F">video</a>, <a href="https://www.evalapply.org/posts/clojure-web-app-from-scratch/deck.html">slides</a>).</p></li>
<li><p><strong>Update (2024-09-04):</strong> I just published a complete project that follows up the concepts set up in this post. <a href="https://github.com/adityaathalye/usermanager-first-principles">adityaathalye/usermanager-first-principles</a> is a stripped-down variant of <a href="https://github.com/seancorfield/usermanager-example">seancorfield/usermanager-example</a>. The project README explains all.</p></li>
</ul></li>
<li><p>Errors and inaccuracies are all mine <a href="#fn1" target="_self" id="fnref1" role="doc-noteref"><sup>1</sup></a>. If you spot any, please write to <em>complaints</em> @ my domain. (And if you want to say nice things, write to <em>compliments</em> @ my domain :). Feel free to discuss on HackerNews (<a href="https://news.ycombinator.com/item?id=41340179">here</a>) and r/Clojure (<a href="https://www.reddit.com/r/Clojure/comments/1f1u0xt/clojuring_the_web_application_stack_meditation_one/">here</a>).</p></li>
<li><p>A basic grounding in the Clojure programming language is assumed <a href="#fn2" target="_self" id="fnref2" role="doc-noteref"><sup>2</sup></a>. Familiarity with web development will help.</p></li>
<li><p>I will stick to discussing the Clojure web application stack in relation to classical Web Frameworks. Primarily <a href="#fn3" target="_self" id="fnref3" role="doc-noteref"><sup>3</sup></a>.</p></li>
<li><p>Yes, a <em>Meditation Two</em> is in draft hell. It is about <em>Getting Pretty Deep In The Woods</em>. If it sees the light of day, it will also be a giant post. Lambda help us.</p></li>
</ul>

<p><em>Multitudes of sworn &#34;Rails developer&#34;s, &#34;Laravel developer&#34;s, &#34;Django developer&#34;s, &#34;Next.js developer&#34;s and suchlike throng the universe…</em> <em>Why?</em></p>
<blockquote>
<p><strong>Novices don&#39;t know they don&#39;t know.</strong></p>
<p><strong>Intermediates know enough but would rather not <em>have</em> to.</strong></p>
<p><strong>Experts know enough to care deeply <a href="#fn4" target="_self" id="fnref4" role="doc-noteref"><sup>4</sup></a>.</strong></p>
<p><strong>Masters know enough to not roll their own.</strong></p>
<p><strong>Once upon a time, there was one.</strong></p>
</blockquote>

<p>Picture the Clojure web stack this way… to a good first approximation:</p>
<ul>
<li>Our business logic (written in Clojure),
<ul>
<li>relies on a bunch of Clojure libraries (frequently, ring-clojure),
<ul>
<li>that know how to use an application server (Jetty).</li>
</ul></li>
</ul></li>
<li>In the simplest deployment model, this picture fits within a single compute instance (e.g. a PC, Cloud VM, or &#34;Serverless&#34; container).</li>
</ul>
<pre><code>|                      |
|  The bulk of our     | Our Business Domain&#39;s
|  application logic,  | data representations
|  written in Clojure. | {} [] #{} &#39;() &#39;x 42
|                      |
+- - - - - - - - - - - + -- RING SPEC -- -- -- -- -- --
|                      |    ^       |
|  The subset of Ring  |    |       |
|  libraries we use    |   { } REQUEST hash-maps
|  as-provided, and    |    |       |
|  as utilities to     |    |       |
|  make custom handlers|    |       |
|  and middleware in   |    |      { } RESPONSE hash-maps
|  Clojure.            |    |       |
|                      |    |       v
+----------------------+ -- RING SPEC -- -- -- -- -- --
|    CLOJURE MAPS      |  Clojure facing interfaces
|                      |  (functions, hash-maps)
+- ring.adapter.jetty -+- - - - - - - - - - - - - - - -
|                      |  Java facing interfaces
|    JAVA OBJECTS      |  (Servlet API, Jetty config API)
+----------------------+ ------------------------------
|       Jetty          |  (deserialize ^)
| (Application server, |  HttpServlet Objects
|  &#34;embedded&#34; mode.)   |  (serialize   v)
+----------------------+ ------------------------------
                          (Plaintext HTTP Responses v)
     NETWORK BOUNDARY facing the WWW side
                          (Plaintext HTTP Requests ^)
+----------------------+ ------------------------------
|  Public Web Server   |  (deserialize ^)
| (for SSL termination |  HTTP Objects
|  static assets etc.) |  (encrypt, serialize v)
+----------------------+ ------------------------------
                          (HTTPS Responses v)
   NETWORK BOUNDARY with the Public WWW
                          (HTTPS Requests ^)
</code></pre>
<p>But before getting too practical, an indulgent philosophical interlude.</p>

<p>I think frameworks are a form of industrial automation (of choices, behaviour, workflows, detail and so forth). Perceived this way, they embody the tradeoffs of industrial automation <a href="#fn5" target="_self" id="fnref5" role="doc-noteref"><sup>5</sup></a>.</p>
<p>Tim Ewald makes astute observations about this phenomenon, in his talk &#34;<a href="https://www.youtube.com/watch?v=ShEez0JkOFw">Clojure: Programming with Hand Tools</a>&#34;. As he remarks, pervasive use of automation has the insidious quality of changing how we view the world and how we perceive problems. To a mind invested in <em>a</em> framework, all web software will look irresistibly framework shaped. Squint just right, and the answer reveals itself. And they may very well be right. Until they are not.</p>
<p>The Clojure world does it the hard way; viz. the not-framework way.</p>
<h2 id="what-does-a-killer-app-kill">What does a Killer App kill?</h2>
<p>Building web applications is arguably the most well trodden path into the software industry. Naturally. Many of the most valuable companies on Earth are web applications. Well-heeled web forms <em>dominate</em> the world.</p>
<p>As the Web evolved, the <em>Web Application Framework</em> gained status as <em>the</em> &#34;killer app&#34; of any respectable programming language ecosystem. Framework makers work hard to serve the multi-faceted, ever-evolving demands on the Web Application. Their products contain time tested ideas; accumulated knowledge of many minds, battle scars from full contact <em>Kumite</em> with the Wild Wild Web. In polite society, we call these scars <em>&#34;design patterns&#34;</em>.</p>
<p>Knowing a framework well can liberate a person <a href="#fn6" target="_self" id="fnref6" role="doc-noteref"><sup>6</sup></a> from the rabbit holes of composing software to solve for things like:</p>
<ul>
<li>App architecture (MVC) and code layout (project templates)</li>
<li>HTTP request/response parsing and handling</li>
<li>Routing and dispatch</li>
<li>HTML templating and/or rendering</li>
<li>API design and use (HTML / text / JSON etc.)</li>
<li>Form handling</li>
<li>Data serialisation / deserialisation</li>
<li>Sessions</li>
<li>Persistent connections (websockets, long polling)</li>
<li>Database connector / driver (e.g. JDBC)</li>
<li>Database ORM</li>
<li>Sending emails</li>
<li>Managing job queues</li>
<li>Configuration (via. environment variables, files, remote sources)</li>
<li>App runtime lifecycle (dependency injection, starting/stopping etc.)</li>
<li>Security (encryption, data sanitisation etc.)</li>
<li>Authentication and/or Authorization</li>
<li>Application logging</li>
<li>Monitoring (with metrics and/or probes to monitor the live runtime)</li>
<li>Building and Packaging</li>
<li>Deployment (new-age frameworks)</li>
<li>Boilerplate and glue code required to make all these work together.</li>
<li>Developer Experience (framework-aware tools and IDEs are life savers).</li>
<li>More…</li>
</ul>
<p>That said, as with all things, <a href="https://en.wikipedia.org/wiki/Taanstafl">TANSTAAFL</a>.</p>
<h2 id="whats-the-catch">What&#39;s the catch?</h2>
<p>Tradeoffs of using a framework stem from the degree of control ceded to it and its ecosystem (ideas, plugins, packages, tools etc.). One accepts a form of vendor lock-in, in lieu of anticipated benefits. Some tradeoffs are:</p>
<ul>
<li><p><em>Fixed core architecture.</em></p></li>
<li><p><em>Leaky abstractions.</em></p></li>
<li><p><em>Upkeep.</em></p></li>
<li><p><em>Production expertise.</em></p></li>
<li><p><em>Choices are an expert matter.</em></p></li>
</ul>
<h2 id="in-clojureland-you-stack-libraries-and-the-odds-yourself">In Clojureland you stack libraries and the odds yourself</h2>
<p>The culture here strongly prefers libraries over frameworks. Here is a quick overview of what we have in our web ecosystem, and the implications thereof.</p>
<h3 id="the-ring-world">The Ring world</h3>
<p>The <a href="https://github.com/ring-clojure">Ring project</a>, by James Reeves (a.k.a. <a href="https://github.com/weavejester">weavejester</a>), is the Clojure ecosystem&#39;s canonical collection of HTTP libraries. Its design choices have a far-reaching effect on the whole Clojure web ecosystem. So it&#39;s worth becoming familiar with Ring.</p>
<p>James also created <a href="https://github.com/weavejester/hiccup">hiccup</a> (HTML rendering) and <a href="https://github.com/weavejester/compojure">compojure</a> (routing), which used with ring and Clojure&#39;s standard library are enough to create a functional traditional multi-page web application, backed by the file system. To use a database, all we need is a library like <a href="https://github.com/seancorfield/next-jdbc">next-jdbc</a>. And making a &#34;modern-feeling&#34; web UI has become easy with HTMX, which &#34;just works&#34; with hiccup.</p>
<p>IMO, most web apps can start this way (and can probably stay this way).</p>
<h3 id="framework-like-web-stack-projects">Framework-like web stack projects</h3>
<p>Several framework-like web stacks also grace Clojureland, viz. <a href="https://www.fulcrologic.com/open-source">Fulcro</a>, <a href="https://biffweb.com/">Biffweb</a>, <a href="https://kit-clj.github.io/">Kit</a> (successor to <a href="https://luminusweb.com/">Luminus</a>), <a href="https://github.com/duct-framework/duct">Duct</a>, <a href="http://pedestal.io">Pedestal</a> etc. However, unlike object oriented frameworks that are fully integrated monolithic systems, these are open-ended sets of libraries that represent the project developer&#39;s opinion of how to build web applications. Newer projects like <a href="https://github.com/chr15m/sitefox">sitefox</a> and <a href="https://donut.party/">donut</a> aim to be more &#34;fully integrated&#34; frameworks. Single Page Application enjoyers may find <a href="https://hoplon.io/">hoplon</a> cool. And if you want truly novel systems, check out <a href="https://github.com/hyperfiddle/electric">hyperfiddle/electric</a>, and <a href="https://redplanetlabs.com/">Rama</a> by Red Planet Labs.</p>
<h3 id="dependency-injection-for-those-in-the-know">Dependency injection for those in the know</h3>
<p>Another approach is to use something like a dependency injection framework to connect and orchestrate all our app&#39;s moving parts through some common system. Libraries like <a href="https://github.com/stuartsierra/component">component</a>, <a href="https://github.com/weavejester/integrant">integrant</a>, <a href="https://github.com/tolitius/mount">mount</a>, <a href="https://github.com/donut-party/system">donut-system</a> serve this purpose. These are favoured by people who already have specific opinions about what set of libraries and pieces of infrastructure they need (and why).</p>
<h3 id="thats-not-all-folks">That&#39;s not all folks</h3>
<p>We haven&#39;t even begun to enumerate a constellation of other libraries needed for databases, caches, security, logging, monitoring, queues, jobs and so forth.</p>
<p>Even otherwise seasoned programmers, who are new to Clojure, can struggle to find their bearings amid this dizzying array of choices.</p>
<h3 id="there-is-no-spoon-architecture">&#34;There is no <del>spoon</del> architecture&#34;</h3>
<p>Alas, not only is there no obvious <em>One True Framework</em>, there is no obvious <em>One True Framework Architecture</em> either. This adds to every Clojure newcomer&#39;s struggle, even grizzled web veterans. As a thought experiment, I feel a Rails developer will find it easy to make sense of a Django or Laravel project, versus any of the apps built with tools we have in the Clojure ecosystem.</p>
<p>Popular web frameworks, going all the way back to <a href="https://en.wikipedia.org/wiki/WebObjects">WebObjects</a> (1996) are object oriented GUI software; products of <a href="https://martinfowler.com/eaaDev/uiArchs.html">convergent evolution</a> along common industry-wide OOP patterns. They are designed for use via Public APIs. Core parts are welded together. Thus, a competent Rails developer parachuting into a Django project can reasonably expect to follow their nose down familiar-feeling Class hierarchies and method chains, across familiar Model, View, Controller structures.</p>
<h3 id="why-become-a-student-of-the-web-stack">Why become a student of the web stack?</h3>
<p>The Clojure world, though built with Java for the JVM, .Net for the .Net CLR, and Javascript for node and browser engines, departs wildly from those underlying Object Oriented foundations.</p>
<p>This fact deeply influences everything, including making web apps. So, although freshly-minted intrepid Clojurians will do well to pick the Ring stack, or one of the popular &#34;starter kits&#34;, we must consciously become students of web framework architecture too.</p>
<p>For out here, the problem of making a web application is also the meta-problem of composing a bespoke web stack.</p>

<p>Many wonderful resources teach Clojure/ClojureScript web development. However, I struggled to build a coherent picture, until I worked out a first-principles model, upon which to build my understanding. So here are the bare essentials, to motivate further learning, using material I <a href="#getting-started-and-tutored">reference later</a>.</p>
<h2 id="a-web-app-is-just-a-polymorphic-dispatcher">A web app is just a polymorphic dispatcher</h2>
<p>Think… what does a web app reeeeeally do?</p>
<pre><code>HTTP request -&gt;
  /pattern-1/ method-1
  /pattern-2/ method-2
  /pattern-3/ method-3
              -&gt; HTTP response
</code></pre>
<p>Shell scripting enjoyers will immediately think of AWK programs, and their design sense would not be wrong. <em>But</em> there is more to the story, of course. For a &#34;pattern&#34; is a set of one or more pieces of information culled from HTTP requests, most crucially the URI and the HTTP verb. <a href="#fn7" target="_self" id="fnref7" role="doc-noteref"><sup>7</sup></a></p>
<pre><code>HTTP request -&gt;
  GET    /uri-1/ getter-method
  PUT    /uri-1/ putter-method
  POST   /uri-1/ poster-method
  PATCH  /uri-1/ patcher-method
  DELETE /uri-1/ deleter-method
                 -&gt; HTTP response
</code></pre>
<p>This pattern tempts us to construct an <code>HttpObject</code>, and is arguably why modern-day OOP style <em>appears</em> to be a natural fit. Yes, the tiniest piece looks like an Object. And yes, the whole web app as a system <em>is</em> very Object Oriented. <em>However</em>, IMHO, the monolithic design of frameworks is rooted in having to use the smallest datum as some concrete HttpObject, instead of generic data.</p>
<p>Clojurists favour generic data over concrete objects and composition over inheritance, because building with composable parts gives us almost unlimited control over the shape, size, and sophistication of our application. The initial learning curve pays off over time, as we get to keep simple apps dead simple, and to ensure not-so-simple apps are only as complex as they need to be.</p>
<p>We build our polymorphic <em>systems</em> using Functional Programming <em>parts</em>.</p>
<p>With this in mind, we construct the core intuition of the anatomy of Clojure web apps, which lives in the heart of ring-clojure…</p>
<h2 id="ring-with-jetty-is-the-classic-combo">Ring with Jetty is the classic combo</h2>
<p>Refer back to the <a href="#getting-the-big-picture">Big Picture</a>.</p>
<p><strong>The Ring project</strong> is a crowd favourite for production Clojure <a href="#fn8" target="_self" id="fnref8" role="doc-noteref"><sup>8</sup></a> web apps. It established <a href="https://github.com/ring-clojure/ring/blob/master/SPEC.md">the Ring specification</a> along with the request / response handling model that many other Clojure web libraries support, or complement.</p>
<p><strong>Jetty</strong> is a popular server of choice in the Clojure community. It is generally used as an &#34;Application Server&#34; in &#34;embedded&#34; mode, i.e. we put the server inside our web application, as a regular library dependency. We can alternately invert the model and run Jetty in &#34;standalone&#34; mode, as a &#34;container&#34; runtime, i.e. we put our application inside the Jetty server.</p>
<p>We will briefly peek at the Servlet API in a later section, as that is the common base for both modes of operation. <em>But</em> this post assumes we <em>run</em> our app in the community-preferred way. By and large, Clojurians prefer the embedded jetty way over the servlet container way <a href="#fn9" target="_self" id="fnref9" role="doc-noteref"><sup>9</sup></a>.</p>
<h2 id="bare-minimum-ring.adapter.jetty-web-app">Bare minimum ring.adapter.jetty web app</h2>
<p>Now we make a bare-minimum web app where the handler function is a catch-all method. It will return a string containing the request information for any HTTP request made to any route. This seemingly pointless code is actually useful to check that your project is set up right. Use it as a starter template.</p>
<h3 id="bare-minimum-directory-structure">Bare minimum directory structure</h3>
<pre><code>$ tree . # root of our project directory
.
├── deps.edn  # project configuration
├── classes   # target for compiled code
└── src
    └── first_principles
        └── core.clj # our bare minimum app
</code></pre>
<h3 id="bare-minimum-library-dependencies">Bare minimum library dependencies</h3>
<p>Our <code>deps.edn</code> file contains this configuration; only Clojure and the Jetty adapter library from the Ring project. We use the Jetty adapter as-provided, to avoid rewriting a whole bunch of code to do Java interop and implement the Ring specification. We rely on these as <em>standards</em>, so we can assume they are available as a given.</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>{<span>:paths</span> [<span>&#34;src&#34;</span> <span>&#34;classes&#34;</span>]</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a> <span>:deps</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a> {org.clojure/clojure {<span>:mvn/version</span> <span>&#34;1.11.3&#34;</span>}</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  ring/ring-jetty-adapter {<span>:mvn/version</span> <span>&#34;1.12.1&#34;</span>}}}</span></code></pre></div>
<h3 id="bare-minimum-code">Bare minimum code</h3>
<p>The lone <code>-main</code> function in <code>src/first_principles/core.clj</code> is the entry point of our web application. It contains a catch-all &#34;handler&#34; function that takes any incoming request and &#34;echoes&#34; it back as a string in the response. We compile and run this little web app as a Java process.</p>
<div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>(<span>ns</span> first-principles.core</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  (<span>:require</span> [ring.adapter.jetty <span>:as</span> adapter])</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  (<span>:gen-class</span>))</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>(<span>defn</span><span> -main</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  [&amp; args]</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>  (adapter/run-jetty <span>; [1.] Jetty adapter&#39;s public API</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>   (<span>fn</span> [request]     <span>; [2.] Handler function (required).</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>     {<span>:status</span> <span>200</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>      <span>:headers</span> {<span>&#34;Content-Type&#34;</span> <span>&#34;text/plain;charset=UTF-8&#34;</span>}</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>      <span>:body</span> (<span>str</span> <span>&#34;echo request: &#34;</span> request)})</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>   {<span>:port</span> <span>3000</span>       <span>; [3.] Jetty server config. (optional)</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    <span>:join</span>? <span>false</span>}))</span></code></pre></div>
<p>In the code above:</p>
<ol>
<li>The Jetty adapter&#39;s public API expects:
<ul>
<li>A Ring-compliant handler function.</li>
<li>An optional configuration map.</li>
</ul></li>
<li>Our bare minimum handler function.
<ul>
<li>The handler expects Ring-compliant request hash-maps, which the Ring Jetty adapter crafts for us.</li>
<li>And it <em>must</em> return Ring-compliant response hash-maps, for consumption by the adapter.</li>
</ul></li>
<li>Optional Jetty server configuration.
<ul>
<li>Again, just a Clojure hash-map, also specified by the Ring spec.</li>
<li>Our Jetty adapter translates and applies any configuration we pass, to Jetty via its Java configuration API.</li>
</ul></li>
</ol>
<h3 id="bare-minimum-live-application">Bare minimum live application</h3>
<p>Here is how we can run it from the terminal using <a href="https://clojure.org/reference/clojure_cli">Clojure CLI</a>.</p>
<p>Compile and run as a Java process. <a href="#fn10" target="_self" id="fnref10" role="doc-noteref"><sup>10</sup></a></p>
<pre><code>$ clj # in the root directory of our project
Clojure 1.11.3
user=&gt; (compile &#39;first-principles.core)
first-principles.core

# Ctrl-d to exit the REPL, then run the compiled code

$ java --class-path $(clj -Spath) first_principles.core
</code></pre>
<p>Or directly from the REPL session.</p>
<pre><code>$ clj # in the root directory of our project
user=&gt; (compile &#39;first-principles.core)
first-principles.core

user=&gt; (first-principles.core/-main) ; start the server
SLF4J: No SLF4J providers were found.
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See https://www.slf4j.org/codes.html#noProviders for further details.
#object[org.eclipse.jetty.server.Server 0x6331250e &#34;Server@6331250e{STARTED}[11.0.20,sto=0]&#34;]

user=&gt; ; Ignore the SLF4J messages. Ctrl-d to exit, when done.
</code></pre>
<h3 id="bare-minimum-http-requests">Bare minimum HTTP requests</h3>
<p>Our bare minimum live app responds to any HTTP request. Observe the request maps echoed back, for what changes, and what doesn&#39;t.</p>
<ul>
<li>Try <code>curl http://localhost:3000</code> , the bare minimum GET request.</li>
<li>Try other URI paths, with and without query params.</li>
<li>Try any of those combinations with other HTTP verbs e.g. <code>curl
 -XPOST http://localhost:3000</code> (or <code>-XDELETE</code> or <code>-XPUT</code> or <code>-XPATCH</code>).</li>
</ul>
<p>Here is a sample result of a GET request to some made-up path with some arbitrary query parameters.</p>
<pre><code>$ curl -XGET \
       &#34;http://localhost:3000/foo/bar/baz?search=wassup%20world&#34;

echo request: {:ssl-client-cert nil,
:protocol &#34;HTTP/1.1&#34;,
:remote-addr &#34;127.0.0.1&#34;,
:headers {&#34;accept&#34; &#34;*/*&#34;,
          &#34;user-agent&#34; &#34;curl/7.81.0&#34;,
          &#34;host&#34; &#34;localhost:3000&#34;},
:server-port 3000,
:content-length nil,
:content-type nil,
:character-encoding nil,
:uri &#34;/foo/bar/baz&#34;,
:server-name &#34;localhost&#34;,
:query-string &#34;search=wassup%20world&#34;,
:body #object[org.eclipse.jetty.server.HttpInput 0x2a91914a &#34;HttpInput@714182986 cs=HttpChannelState@2eae00c0{s=HANDLING rs=BLOCKING os=OPEN is=IDLE awp=false se=false i=true al=0} cp=org.eclipse.jetty.server.BlockingContentProducer@6bac9b71 eof=false&#34;],
:scheme :http,
:request-method :get}
</code></pre>
<p>Though small, our &#34;barebones&#34; app is still doing a lot of stuff. To figure out what&#39;s going on, let&#39;s deconstruct it further.</p>
<h2 id="bare-minimum-ring-project-derived-from-first-principles">Bare minimum Ring project derived from first principles</h2>
<p><em><strong>Hint:</strong></em> It&#39;s functions all the way down.</p>
<p>Continuing with reference to the <a href="#getting-the-big-picture">Big Picture</a>, I feel like a minimal web application stack must, <strong><em>at the very least</em></strong>, facilitate the following:</p>
<ul>
<li><em><strong>Interface with the outside world</strong></em>, relative to our application.</li>
<li><em><strong>Interface with us</strong></em>, in the language / domain of said app.</li>
<li><em><strong>Provide creature comforts</strong></em> to automate the drudgery of interpreting HTTP requests and creating HTTP responses.</li>
<li><em><strong>Provide some mechanism to orchestrate and control handler execution</strong></em>. It turns out that the mechanism of handlers alone is not enough to cater to all our request/response needs. We use another mechanism called &#34;middleware&#34;.</li>
</ul>
<h3 id="interface-with-the-outside-world">Interface with the outside world</h3>
<p><a href="https://github.com/ring-clojure/ring/tree/master/ring-jetty-adapter">ring-jetty-adapter</a> is our interface (ref: <a href="#getting-the-big-picture">Big Picture</a>). It is a Clojure wrapper over Jetty&#39;s Java APIs.</p>
<p>For us &#34;outside&#34; is the land of Java objects, viz. Jetty&#39;s HTTP object model, Servlet interface, and server configuration interface. These bits of the library&#39;s &#34;outside-facing&#34; code illustrate how it &#34;adapts&#34; between Jetty and Clojure:</p>
<ul>
<li><p><strong>A Ring request</strong> can have a lot of stuff in it. For example, here is <a href="https://github.com/ring-clojure/ring/blob/7d54a32425da4a0933656128a6b0bbfae2f43374/ring-jakarta-servlet/src/ring/util/jakarta/servlet.clj#L30">the function</a> that moves HTTP request information from the Jetty server&#39;s request object into the corresponding Clojure hash-map that conforms to the Ring specification. Compare this with the response of the echo handler we saw <a href="#bare-minimum-http-requests">a few paragraphs earlier</a>.</p>
<div id="cb10"><pre><code><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>(<span>defn</span><span> build-request-map</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span>&#34;Create the request map from the HttpServletRequest object.&#34;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  [^HttpServletRequest request]</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  {<span>:server-port</span>        (.getServerPort request)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>   <span>:server-name</span>        (.getServerName request)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>   <span>:remote-addr</span>        (.getRemoteAddr request)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>   <span>:uri</span>                (.getRequestURI request)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>   <span>:query-string</span>       (.getQueryString request)</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>   <span>:scheme</span>             (<span>keyword</span> (.getScheme request))</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>   <span>:request-method</span>     (<span>keyword</span> (.toLowerCase (.getMethod request) Locale/ENGLISH))</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>   <span>:protocol</span>           (.getProtocol request)</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>   <span>:headers</span>            (get-headers request)</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>   <span>:content-type</span>       (.getContentType request)</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>   <span>:content-length</span>     (get-content-length request)</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>   <span>:character-encoding</span> (.getCharacterEncoding request)</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>   <span>:ssl-client-cert</span>    (get-client-cert request)</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>   <span>:body</span>               (.getInputStream request)})</span></code></pre></div></li>
<li><p><strong>A Ring response</strong> contains the HTTP status code, headers, and optional body. The adapter uses <a href="https://github.com/ring-clojure/ring/blob/7d54a32425da4a0933656128a6b0bbfae2f43374/ring-jakarta-servlet/src/ring/util/jakarta/servlet.clj#L62">these functions</a> to move information from a response hash-map, into the corresponding Jetty servlet response object.</p>
<div id="cb11"><pre><code><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>(<span>defn</span><span> update-servlet-response</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span>&#34;Update the HttpServletResponse using a response map. Takes an optional</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span>  AsyncContext.&#34;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  ([response response-map]</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>   (update-servlet-response response <span>nil</span> response-map))</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>  ([^HttpServletResponse response context response-map]</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>   (<span>let</span> [{<span>:keys</span> [status headers body]} response-map]</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>     (<span>when</span> (<span>nil?</span> response)</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>       (<span>throw</span> (NullPointerException. <span>&#34;HttpServletResponse is nil&#34;</span>)))</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>     (<span>when</span> (<span>nil?</span> response-map)</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>       (<span>throw</span> (NullPointerException. <span>&#34;Response map is nil&#34;</span>)))</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>     (<span>when</span> status</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>       (.setStatus response status))</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>     (set-headers response headers)</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>     (<span>let</span> [output-stream (make-output-stream response context)]</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>       (protocols/write-body-to-stream body response-map output-stream)))))</span></code></pre></div></li>
</ul>
<p>Thankfully, weavejester has done all the heavy lifting for us, so we only have to care about the public API of this adapter library, which is a single function, <code>run-jetty</code>. Take a gander at its <a href="https://ring-clojure.github.io/ring/ring.adapter.jetty.html">API doc</a>.</p>
<h3 id="interface-with-us">Interface with us</h3>
<p><code>ring-jetty-adapter</code> is, again, our interface (ref: <a href="#getting-the-big-picture">Big Picture</a>).</p>
<p>For Clojure programmers, generic Clojure data is our programming model, not custom objects. So the adapter&#39;s Clojure facing side lets us:</p>
<ul>
<li>Configure Jetty from our Clojure app, using plain Clojure hash-maps.</li>
<li>Manipulate HTTP requests and responses from our Clojure app as plain Clojure hash-maps.</li>
<li>Rely on a standard specification of requests and responses as hash-maps that mirror the HTTP standard.</li>
</ul>
<p>The Clojure data version of Ring&#39;s request/response specification is human <em>and</em> machine readable (within our Clojure runtime).</p>
<ul>
<li><p><strong>A Ring Request map</strong> has a lot of stuff in it, as seen in the <code>build-request-map</code> function featured above.</p></li>
<li><p><strong>The Ring response map</strong> is much simpler. A valid response is just the following hash-map.</p>
<div id="cb12"><pre><code><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>{<span>:status</span> <span>200</span> <span>; [1.]</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a> <span>:headers</span> {<span>&#34;Content-Type&#34;</span> <span>&#34;text/html;charset=UTF-8&#34;</span>} <span>; [2.]</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a> <span>:body</span> <span>&#34;&lt;h1&gt;optional&lt;/h1&gt;&#34;</span>} <span>; [3.]</span></span></code></pre></div>
<ol>
<li><code>:status</code> is mandatory, and must be an Integer.</li>
<li><code>:header</code> is mandatory, and must be a map of type <code>{String String}</code>.</li>
<li><code>:body</code> is optional, and must be a <code>ring.core.protocols/StreamableResponseBody</code>.</li>
</ol></li>
</ul>
<p>See the <a href="https://github.com/ring-clojure/ring/blob/master/SPEC.md">Ring specification</a> and compare it with the code in these two namespaces of the <a href="https://github.com/ring-clojure/ring/tree/master">main ring project</a>: <code>ring.adapter.jetty</code> and <code>ring.util.jakarta.servlet</code>.</p>
<h3 id="provide-http-creature-comforts">Provide HTTP creature comforts</h3>
<p>… to automate the drudgery of interpreting HTTP requests and creating HTTP responses. Illustrating this will require a bit of set up.</p>
<p>First, I&#39;ll copy down our barebones app code, and slightly refactor it so <code>-main</code> looks more like it would in a production Clojure app.</p>
<div id="cb13"><pre><code><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>(<span>ns</span> first-principles.core</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  (<span>:require</span> [ring.adapter.jetty <span>:as</span> adapter])</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  (<span>:gen-class</span>))</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>(<span>defn</span><span> echo-handler </span>[request]</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>  {<span>:status</span> <span>200</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>   <span>:headers</span> {<span>&#34;Content-Type&#34;</span> <span>&#34;text/plain;charset=UTF-8&#34;</span>}</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>   <span>:body</span> (<span>str</span> <span>&#34;echo request: &#34;</span> request)})</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>(<span>defn</span><span> -main</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>  [&amp; args]</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>  (adapter/run-jetty <span>; [1.] Jetty adapter&#39;s public API</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>   echo-handler      <span>; [2.] Handler function (required).</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>   {<span>:port</span> <span>3000</span>       <span>; [3.] Jetty server config. (optional)</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>    <span>:join</span>? <span>false</span>}))</span></code></pre></div>
<p>Now, I&#39;ll modify <code>echo-handler</code> to a generic <code>handler</code> that:</p>
<ul>
<li>Redirects the root URI <code>&#34;/&#34;</code> to a new <code>&#34;/echo&#34;</code> URI.</li>
<li>Echos responses only for the echo URI.</li>
<li>Returns a &#34;pong&#34; for a <code>&#34;/health-check&#34;</code> URI.</li>
<li>Returns 404 for all other routes.</li>
</ul>
<div id="cb14"><pre><code><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>(<span>defn</span><span> generic-handler</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  [request]</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  (<span>case</span> (<span>:uri</span> request)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span>&#34;/&#34;</span> <span>; Try: curl -L localhost:3000 # -L means follow redirects</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    {<span>:status</span> <span>303</span> <span>; &#34;See Other&#34;</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>     <span>:headers</span> {<span>&#34;Location&#34;</span> <span>&#34;/echo&#34;</span>}</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>     <span>:body</span> <span>&#34;&#34;</span>}</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    <span>&#34;/echo&#34;</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>    {<span>:status</span> <span>200</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>     <span>:headers</span> {<span>&#34;Content-Type&#34;</span> <span>&#34;text/plain;charset=UTF-8&#34;</span>}</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>     <span>:body</span> (<span>str</span> <span>&#34;echo request: &#34;</span> request)}`</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>    <span>&#34;/health-check&#34;</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>    {<span>:status</span> <span>200</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>     <span>:headers</span> {<span>&#34;Content-Type&#34;</span> <span>&#34;text/plain;charset=UTF-8&#34;</span>}</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>     <span>:body</span> <span>&#34;Pong&#34;</span>}</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>    <span>;; Default case is not found.</span></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>    {<span>:status</span> <span>404</span> <span>; &#34;Not Found&#34;</span></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>     <span>:headers</span> {}</span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>     <span>:body</span> <span>&#34;Not Found.&#34;</span>}))</span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>(<span>defn</span><span> -main</span></span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>    [&amp; args]</span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a>    (adapter/run-jetty <span>; [1.] Jetty adapter&#39;s public API</span></span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a>     generic-handler   <span>; [2.] Handler function (required).</span></span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a>     {<span>:port</span> <span>3000</span>       <span>; [3.] Jetty server config. (optional)</span></span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a>      <span>:join</span>? <span>false</span>}))</span></code></pre></div>
<p>Now, it&#39;s totally fine to hand-write maps the way I just did, <em>but</em> well-chosen utility functions will help us reduce some repetition <em>and</em> do things like:</p>
<ul>
<li>Easily construct Ring spec-compliant requests/responses.</li>
<li>Provide semantics of common HTTP actions, so we don&#39;t have to remember them.</li>
<li>Provide sane defaults when constructing responses.</li>
<li>Check constraints when it matters, etc.</li>
</ul>
<p>So, finally, lets refactor <code>handler</code> and pull out utility functions. This is just the seed of intuition for a whole set of utilities designed around the ring spec. See the official API docs for <a href="https://ring-clojure.github.io/ring/ring.util.response.html">ring.util.response</a> functions, for example. Also check out its sibling <code>ring.util.*</code> namespaces. These utilities address i/o, requests, mime-type, parsing etc.</p>
<div id="cb15"><pre><code><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span>;; Ring-compliant HTTP utilities</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>(<span>defn</span><span> status</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>  <span>&#34;Set or override status of response.&#34;</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>  [response status-code]</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>  (<span>assoc</span> response <span>:status</span> status-code))</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>(<span>defn</span><span> header</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>  [response header-name header-value]</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>  (<span>assoc-in</span> response [<span>:headers</span> header-name] header-value))</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>(<span>defn</span><span> content-type</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>  [response content-type]</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>  (header response <span>&#34;Content-Type&#34;</span> content-type))</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>(<span>defn</span><span> response</span></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>  <span>&#34;Skeleton response with status 200 OK.&#34;</span></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>  [body]</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>  {<span>:status</span> <span>200</span></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>   <span>:headers</span> {}</span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>   <span>:body</span> body})</span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>(<span>defn</span><span> not-found</span></span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a>  [body]</span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a>  {<span>:status</span> <span>404</span></span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a>   <span>:headers</span> {}</span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a>   <span>:body</span> body})</span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a>(<span>defn</span><span> see-other</span></span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a>  [uri]</span>
<span id="cb15-33"><a href="#cb15-33" aria-hidden="true" tabindex="-1"></a>  {<span>:status</span> <span>303</span></span>
<span id="cb15-34"><a href="#cb15-34" aria-hidden="true" tabindex="-1"></a>   <span>:headers</span> {<span>&#34;Location&#34;</span> uri}</span>
<span id="cb15-35"><a href="#cb15-35" aria-hidden="true" tabindex="-1"></a>   <span>:body</span> <span>&#34;&#34;</span>})</span>
<span id="cb15-36"><a href="#cb15-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-37"><a href="#cb15-37" aria-hidden="true" tabindex="-1"></a><span>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span></span>
<span id="cb15-38"><a href="#cb15-38" aria-hidden="true" tabindex="-1"></a><span>;; Handler(s)</span></span>
<span id="cb15-39"><a href="#cb15-39" aria-hidden="true" tabindex="-1"></a><span>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span></span>
<span id="cb15-40"><a href="#cb15-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-41"><a href="#cb15-41" aria-hidden="true" tabindex="-1"></a>(<span>defn</span><span> generic-handler</span></span>
<span id="cb15-42"><a href="#cb15-42" aria-hidden="true" tabindex="-1"></a>  [request]</span>
<span id="cb15-43"><a href="#cb15-43" aria-hidden="true" tabindex="-1"></a>  <span>;; It is trivial to look up information in hash-maps.</span></span>
<span id="cb15-44"><a href="#cb15-44" aria-hidden="true" tabindex="-1"></a>  (<span>case</span> (<span>:uri</span> request)</span>
<span id="cb15-45"><a href="#cb15-45" aria-hidden="true" tabindex="-1"></a>    <span>&#34;/&#34;</span></span>
<span id="cb15-46"><a href="#cb15-46" aria-hidden="true" tabindex="-1"></a>    (see-other <span>&#34;/echo&#34;</span>)</span>
<span id="cb15-47"><a href="#cb15-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-48"><a href="#cb15-48" aria-hidden="true" tabindex="-1"></a>    <span>&#34;/echo&#34;</span></span>
<span id="cb15-49"><a href="#cb15-49" aria-hidden="true" tabindex="-1"></a>    (<span>-&gt;</span> (response (<span>str</span> <span>&#34;echo request: &#34;</span> request))</span>
<span id="cb15-50"><a href="#cb15-50" aria-hidden="true" tabindex="-1"></a>        (content-type <span>&#34;text/plain;charset=UTF-8&#34;</span>))`</span>
<span id="cb15-51"><a href="#cb15-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-52"><a href="#cb15-52" aria-hidden="true" tabindex="-1"></a>    <span>&#34;/health-check&#34;</span></span>
<span id="cb15-53"><a href="#cb15-53" aria-hidden="true" tabindex="-1"></a>    (<span>-&gt;</span> (response <span>&#34;Pong&#34;</span>)</span>
<span id="cb15-54"><a href="#cb15-54" aria-hidden="true" tabindex="-1"></a>        (content-type <span>&#34;text/plain;charset=UTF-8&#34;</span>))</span>
<span id="cb15-55"><a href="#cb15-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-56"><a href="#cb15-56" aria-hidden="true" tabindex="-1"></a>    <span>;; Default case is not found.</span></span>
<span id="cb15-57"><a href="#cb15-57" aria-hidden="true" tabindex="-1"></a>    (not-found <span>&#34;Not Found.&#34;</span>)))</span></code></pre></div>
<p>In production code, we either directly use Ring-provided utility functions, and/or use utility libraries by other people, and/or design our own high-level utilities using any of those as building blocks.</p>
<p>Ring request/response utilities and our handlers are not enough, because we also need to…</p>
<h3 id="orchestrate-and-control-handler-execution-using-middleware">Orchestrate and control handler execution using middleware</h3>
<p>In OOP terms, Ring middleware are a functional mechanism to use handlers as visitors. They also can perform dependency injection. Since middleware accept handlers and return handlers, the Ring middleware pattern is akin to the factory pattern of OOP.</p>
<p>This section sets up the intuition for actual Ring middleware (see official <a href="https://ring-clojure.github.io/ring/ring.middleware.content-type.html">ring.middleware.* API docs</a>). These are also &#34;just functions&#34;, like the one below. We will see how and why such middleware work, but first a bit on why we need this mechanism at all.</p>
<div id="cb16"><pre><code><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>(<span>defn</span><span> wrap-request-barebones-middleware</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  [handler]</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  (<span>fn</span> [request]</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    (handler request)))</span></code></pre></div>
<p>Remember the notion that a web app is just a ploymorphic dispatcher?</p>
<p>Real-world Ring handlers are specialised functions, unlike our barebones handler, which is a monolithic function tasked with handling all requests and responses. The single responsibility principle directs us to (typically) dedicate one handler function per dispatch case, yielding us isolated, maintainable, testable, composable parts.</p>
<p>This means handlers ought not handle shared or cross-cutting concerns, and ought not be aware of each other either. This means they cannot cooperate to manage their own control flow. Shared dependencies and/or behaviours need to sit elsewhere and be passed into or interleaved with handlers. These interventions happen anywhere &#34;in the middle&#34; of request/response processing. Thus we call such logic &#34;middleware&#34;, in the Ring world.</p>
<p>Some scenarios that handlers do not address, but middleware can:</p>
<ul>
<li><em>How to handle state generically across handlers?</em> e.g.
<ul>
<li>Inject per-request state into request context, like a database connection or a resource path.</li>
<li>Maintain state across requests, e.g. browser sessions and cookies.</li>
<li>Handle errors thrown that no handler catches.</li>
<li>Selectively log data for some requests or responses.</li>
</ul></li>
<li><em>How to massage the structure and formatting of request/response hash-maps</em> for every request, so that any handler can more easily access information?
<ul>
<li>Parse out query or form params and make them easy to access.</li>
<li>Automatically inject header information, such as content-type with mime type guessed based on the response body.</li>
<li>Automatically coerce information to expected types.</li>
<li>Automatically decode / encode body content.</li>
</ul></li>
<li><em>How to exercise control over handler execution itself?</em>
<ul>
<li>Gate handler evaluation based on authentication and authorization.</li>
<li>Route specific requests to specific handlers. This lets us write independently testable handler functions and compose them later using the routing mechanism.</li>
<li>Short-circuit and return early if we already have a response.</li>
<li>Do content negotiation and fix headers, to make handlers return the type of response the client expects.</li>
</ul></li>
</ul>
<p>We can write &#34;request&#34; middleware to exercise control over the behaviour of the inbound path of our app, and &#34;response&#34; middleware to manage behaviour of the outbound path. The simplest middleware (&#34;no-op&#34; or identity function of middleware) looks like this:</p>
<div id="cb17"><pre><code><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>(<span>defn</span><span> wrap-barebones-request-handler</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  <span>&#34;Uses a request handler as a visitor.&#34;</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  [handler] <span>; expects a request-handling function</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  <span>;; returns a new function that expects a request map</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  (<span>fn</span> [request]</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    <span>;; This in turn calls the handler function, that it has</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    <span>;; captured in its scope, on the request that it receives.</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>    (handler request)))</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>(<span>defn</span><span> wrap-barebonse-response-handler</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>  <span>&#34;Uses a response handler as a visitor.&#34;</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>  [handler] <span>; expects a response-handling function</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>  <span>;; returns a new function that expects a response map</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>  (<span>fn</span> [response]</span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>    <span>;; This in turn calls the handler function, that it has</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>    <span>;; captured in its scope, on the response that it receives.</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>    (<span>if</span> (response? response)</span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>      (handler response))))</span></code></pre></div>
<p>The category of functions that accept functions as arguments and/or return functions as responses are &#34;higher order functions&#34; (HoFs) <a href="#fn11" target="_self" id="fnref11" role="doc-noteref"><sup>11</sup></a>.</p>
<p><em>Order of invocation matters. Wrapping your head around a stack of HoFs can get a little freaky.</em> It is fine to just <em>believe</em> and simply follow the usual pattern of Ring projects one sees in examples and tutorials. One will find said <em>belief</em> handy even if, with some labour, one convinces oneself that the model <em>works</em> by walking down the middleware stack of function calls and returns.</p>
<p>Here is a step-by-step expansion of our aforementioned &#34;barebones&#34; middleware stack. We use the &#34;substitution principle&#34; of function evaluation.</p>
<ol>
<li><p>Pass our <code>generic-handler</code> function to our barebones middleware stack, and call the resulting handler on the request map we expect from the ring-jetty-adapter&#39;s <code>run-jetty</code> interface. We are evaluating a single invocation, and so we can lift our web app&#39;s absolute minimal core functionality out of the <code>-main</code> entry point.</p>
<div id="cb18"><pre><code><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>(<span>defn</span><span> -main</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  [&amp; args]</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  (adapter/run-jetty <span>; [1.] Jetty adapter&#39;s public API</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>   generic-handler   <span>; [2.] Handler function (required).</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>   {<span>:port</span> <span>3000</span>       <span>; [3.] Jetty server config. (optional)</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    <span>:join</span>? <span>false</span>}))</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span>;; Can be stripped down to just run-jetty</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a><span>;; without the optional config. map...</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>(adapter/run-jetty</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a> generic-handler)</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a><span>;; This creates a live server that calls our</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a><span>;; generic-handler on every inbound request.</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>(generic-handler</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a> inbound-request-map-from-jetty-adapter)</span></code></pre></div></li>
<li><p>Now, what if we wrap <code>generic-handler</code> in our barebones middleware stack? How and <em>why</em> would this even work?</p>
<div id="cb19"><pre><code><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>((wrap-barebones-request-handler</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  (wrap-barebones-response-handler</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>   generic-handler))</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a> inbound-request-map-from-jetty-adapter)</span></code></pre></div></li>
<li><p>We know any middleware must return a Ring compliant handler function, <em>because we designed it that way</em>. The cumulative result of calling more than one middleware on a handler, also reduces down to a Ring handler.</p>
<p>Abstractly, our barebones middleware would evaluate this way:</p>
<div id="cb20"><pre><code><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>((middleware<span>-2</span> (middleware<span>-1</span> handler-fn)) request-map)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>((middleware<span>-2</span> handler-fn&#39;) request-map)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>(handler-fn<span>&#39;&#39;</span> request-map)</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span>;; =&gt; response-map</span></span></code></pre></div></li>
<li><p>So, concretely, we can take our &#34;barebones middleware stack&#34; from point 2. above, and use the insight from point 3. to evaluate the stack down to a response, as follows.</p>
<ol>
<li><p>Substitute the name <code>wrap-barebones-response-handler</code> with its corresponding function body.</p>
<div id="cb21"><pre><code><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>((wrap-barebones-request-handler</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>  ((<span>fn</span> [handler]</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>     (<span>fn</span> [response]</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>       (handler response))) generic-handler))</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a> inbound-request-map-from-jetty-adapter)</span></code></pre></div></li>
<li><p>Pass <code>generic-handler</code> to the just-substituted function body of the response handler and replace the whole with the resulting handler function (a middleware accepts a handler and returns a handler… quite like the Factory pattern).</p>
<div id="cb22"><pre><code><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>((wrap-barebones-request-handler</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>  (<span>fn</span> [response]</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    (generic-handler response)))</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a> inbound-request-map-from-jetty-adapter)</span></code></pre></div></li>
<li><p>Simplify the resulting function call because any expression of the form <code>(fn [x] (some-func x))</code> is equivalent to just <code>some-func</code> <a href="#fn12" target="_self" id="fnref12" role="doc-noteref"><sup>12</sup></a>:</p>
<div id="cb25"><pre><code><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>((wrap-barebones-request-handler</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>  generic-handler)</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a> inbound-request-map-from-jetty-adapter)</span></code></pre></div></li>
<li><p>Repeat the same type of function body substitution done in step 4.1, except now for the barebones request handler.</p>
<div id="cb26"><pre><code><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>(((<span>fn</span> [handler]</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    (<span>fn</span> [request]</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>      (handler request))) generic-handler)</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a> inbound-request-map-from-jetty-adapter)</span></code></pre></div></li>
<li><p>Repeat the simplification operation of steps 4.2 and 4.3.</p>
<div id="cb27"><pre><code><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>((<span>fn</span> [request]</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>   (generic-handler request))</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a> inbound-request-map-from-jetty-adapter)</span></code></pre></div>
<p>Simplifies to…</p>
<div id="cb28"><pre><code><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>(generic-handler</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a> inbound-request-map-from-jetty-adapter)</span></code></pre></div>
<p>Which ought to return us a <code>response</code>, because that is how we have constructed <code>generic-handler</code>.</p></li>
</ol></li>
<li><p>This chain makes sense because both our &#34;barebones&#34; middleware apply their incoming handler argument <em>as-is</em>.</p>
<p>Even so, reading and understanding code with real-world middleware requires <em>belief</em> that it does :-)</p>
<div id="cb29"><pre><code><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>(<span>defn</span><span> -main</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>  [&amp; args]</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>  (<span>-&gt;</span> generic-handler</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>      wrap-keyword-params</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>      wrap-params</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>      wrap-multipart-params</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>      wrap-cookies</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>      wrap-session</span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>      wrap-resource)</span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>  {<span>:port</span> <span>3000</span></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>   <span>:join</span>? <span>false</span>})</span></code></pre></div></li>
</ol>
<p>There is one final core-to-web-apps functionality that the Ring project <em>does not</em> include, which is polymorphic dispatch mechanism, which is &#34;Routing&#34;. Routers like compojure, reitit, bidi, pedestal exist, but we still need a first-principles understanding of Routing. So, we round things up with…</p>
<h2 id="bare-minimum-router---the-polymorphic-dispatcher-appears">Bare minimum router - the polymorphic dispatcher appears</h2>
<p>The Ring project is focused on being a very good HTTP abstraction and toolkit, based on the Ring specification. It does <em>not</em> offer a router, even though it is a critical piece of the web stack <a href="#fn13" target="_self" id="fnref13" role="doc-noteref"><sup>13</sup></a>. Many routing libraries exist, each with their own particular design choices, feature sets, and performance goals. It is just fine to use <a href="https://github.com/weavejester/compojure">compojure</a> in your first little web app or three. Swap it out for another library later, to explore other ways of routing.</p>
<p>Here is the bare minimum intuition for routing.</p>
<p>We pull apart our monolithic <code>generic-handler</code> into little handlers and wire them back together with our poor man&#39;s router using something more flexible than a plain old <code>case</code> expression.</p>
<p>First, a copy of the <code>generic-handler</code> for quick reference.</p>
<div id="cb30"><pre><code><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>(<span>defn</span><span> generic-handler</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>  [request]</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>  (<span>case</span> (<span>:uri</span> request)</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>    <span>&#34;/&#34;</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>    (see-other <span>&#34;/echo&#34;</span>)</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>    <span>&#34;/echo&#34;</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>    (<span>-&gt;</span> (response (<span>str</span> <span>&#34;echo request: &#34;</span> request))</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>        (content-type <span>&#34;text/plain;charset=UTF-8&#34;</span>))</span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>    <span>&#34;/health-check&#34;</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>    (<span>-&gt;</span> (response <span>&#34;Pong&#34;</span>)</span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>        (content-type <span>&#34;text/plain;charset=UTF-8&#34;</span>))</span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a>    <span>;; Default case</span></span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a>    (not-found <span>&#34;Not Found.&#34;</span>)))</span></code></pre></div>
<p>Since we want <em>open-ended</em> polymorphic dispatch, we can use Clojure multimethods and dispatch over a much richer pattern space. Here we combine HTTP verb <em>and</em> URI, for example. But our dispatch function is almost unlimited in the pattern space it can generate.</p>
<div id="cb31"><pre><code><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>(<span>defmulti</span><span> generic-handler</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>  (<span>fn</span> [{<span>:keys</span> [request-method uri] <span>:as</span> _request}]</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>    [request-method uri]))</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>(<span>defmethod</span><span> generic-handler </span><span>:default</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>  [_request]</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>  (not-found <span>&#34;Not Found.&#34;</span>))</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>(<span>defmethod</span><span> generic-handler </span>[<span>:get</span> <span>&#34;/health-check&#34;</span>]</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>  [_request]</span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>  (<span>-&gt;</span> (response <span>&#34;Pong&#34;</span>)</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>      (content-type <span>&#34;text/plain;charset=UTF-8&#34;</span>))  )</span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a>(<span>defn-</span><span> echo</span></span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>  <span>&#34;Helper function to handle Echo requests.&#34;</span></span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a>  [request]</span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a>  (<span>-&gt;</span> (response (<span>format</span> <span>&#34;%s: %s</span><span>\n</span><span>&#34;</span></span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a>                        (<span>:request-method</span> request)</span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a>                        (<span>:uri</span> request)))</span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true" tabindex="-1"></a>      (content-type <span>&#34;text/plain;charset=UTF-8&#34;</span>)))</span>
<span id="cb31-21"><a href="#cb31-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-22"><a href="#cb31-22" aria-hidden="true" tabindex="-1"></a>(<span>defmethod</span><span> generic-handler </span>[<span>:get</span> <span>&#34;/echo&#34;</span>]</span>
<span id="cb31-23"><a href="#cb31-23" aria-hidden="true" tabindex="-1"></a>  [request]</span>
<span id="cb31-24"><a href="#cb31-24" aria-hidden="true" tabindex="-1"></a>  (echo request))</span>
<span id="cb31-25"><a href="#cb31-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-26"><a href="#cb31-26" aria-hidden="true" tabindex="-1"></a>(<span>defmethod</span><span> generic-handler </span>[<span>:post</span> <span>&#34;/echo&#34;</span>]</span>
<span id="cb31-27"><a href="#cb31-27" aria-hidden="true" tabindex="-1"></a>  [request]</span>
<span id="cb31-28"><a href="#cb31-28" aria-hidden="true" tabindex="-1"></a>  (echo request))</span>
<span id="cb31-29"><a href="#cb31-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-30"><a href="#cb31-30" aria-hidden="true" tabindex="-1"></a>(<span>defmethod</span><span> generic-handler </span>[<span>:put</span> <span>&#34;/echo&#34;</span>]</span>
<span id="cb31-31"><a href="#cb31-31" aria-hidden="true" tabindex="-1"></a>  [request]</span>
<span id="cb31-32"><a href="#cb31-32" aria-hidden="true" tabindex="-1"></a>  (echo request))</span>
<span id="cb31-33"><a href="#cb31-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-34"><a href="#cb31-34" aria-hidden="true" tabindex="-1"></a>(<span>defmethod</span><span> generic-handler </span>[<span>:delete</span> <span>&#34;/echo&#34;</span>]</span>
<span id="cb31-35"><a href="#cb31-35" aria-hidden="true" tabindex="-1"></a>  [request]</span>
<span id="cb31-36"><a href="#cb31-36" aria-hidden="true" tabindex="-1"></a>  (echo request))</span>
<span id="cb31-37"><a href="#cb31-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-38"><a href="#cb31-38" aria-hidden="true" tabindex="-1"></a><span>;; Let&#39;s not support PATCH for echo. It should 404.</span></span>
<span id="cb31-39"><a href="#cb31-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-40"><a href="#cb31-40" aria-hidden="true" tabindex="-1"></a>(<span>defn</span><span> -main</span></span>
<span id="cb31-41"><a href="#cb31-41" aria-hidden="true" tabindex="-1"></a>  [&amp; _args]</span>
<span id="cb31-42"><a href="#cb31-42" aria-hidden="true" tabindex="-1"></a>  (adapter/run-jetty generic-handler</span>
<span id="cb31-43"><a href="#cb31-43" aria-hidden="true" tabindex="-1"></a>                     {<span>:port</span> <span>3000</span></span>
<span id="cb31-44"><a href="#cb31-44" aria-hidden="true" tabindex="-1"></a>                      <span>:join</span>? <span>false</span>}))</span></code></pre></div>
<p>Given a HTTP abstraction like Ring, and some robust non-icky way to do routing, we can potentially build the rest of the web app like they did in the last century… string-bash HTML and SQL for the UI and the DB. But we can do better, and use more of the web stack.</p>

<blockquote>
<p><strong>what is the most common stack for building web apps in clojure at the moment? is it kit/pedestal or do most clojurians prefer to roll</strong> <strong>everything from scratch?</strong></p>
<p>— asked by <em><strong>growthesque</strong></em> in the #beginners channel of the Clojurians Slack, 2024-07-11 (many suggestions <a href="https://clojurians.slack.com/archives/C053AK3F9/p1720699697065839">in the thread</a>)</p>
</blockquote>
<p>I suggest <em>don&#39;t</em> &#34;roll your own&#34;, at the outset. Make old-skool web apps with Ring + Jetty + Compojure + Hiccup + next-jdbc stack, which is <em>fine</em> for ordinary production use. Sprinkle in some HTMX for fancier web frontend. Rest assured that it is possible to swap out any of these later, if specific needs arise.</p>
<h2 id="speed-run-through-small-demos">Speed run through small demos</h2>
<p>It&#39;s a good idea to work through existing examples and demo apps, over a weekend or two. This should give you enough finger feel to choose one of the state-of-the-art stacks listed later in this section, <em>or</em> roll your own too.</p>
<ul>
<li><p>Review the <a href="https://github.com/ring-clojure/ring?tab=readme-ov-file#documentation">docs and wiki of the main Ring project</a>, and keep these handy. Ring is a fantastic reference. I notice <em>weavejester</em> has been adding example projects too, so you may like to <a href="https://github.com/ring-clojure/ring-examples">follow that repo</a>.</p></li>
<li><p>Speed-code through Eric Normand&#39;s &#34;<a href="https://ericnormand.me/guide/clojure-web-tutorial">Learn to build a Clojure Web App</a>&#34; tutorial. I feel like my post is a nice conceptual complement to his more practical post. In it you&#39;ll learn some useful real-world tricks and techniques that we use in day-to-day web development.</p></li>
<li><p>Watch <a href="https://www.youtube.com/watch?v=LcpbBth7FaQ">Nir Rubinstein live code</a> a similar tiny demo web app at Wix Engineering Tech Talk. He walks us through his thinking, various little details of the Clojure web development workflow, as well as some comparisons with the more popular Object-oriented approaches.</p></li>
</ul>
<h2 id="do-more-hands-on-practice">Do more hands-on practice</h2>
<p>I like to copy example apps (type them out from scratch in my own words) <a href="#fn14" target="_self" id="fnref14" role="doc-noteref"><sup>14</sup></a>. Here are some good options.</p>
<ul>
<li><p>Sean Corfield&#39;s <a href="https://github.com/seancorfield/usermanager-example">usermanager-example</a> demo app, and its variants linked in the README.</p></li>
<li><p>Learn the tricks of web development workflows used by Clojurians, by watching them code example apps using real-world workflows.</p>
<ul>
<li><p>I quite like Andrey Fadeev&#39;s video tutorial series, <em><a href="https://www.youtube.com/watch?v=LqVyP_EGKqw&amp;list=PLRGAFpvDgm2ylbXYIjvu3kI426zAP_Lqc">Building a real-world Clojure application from SCRATCH</a></em>.</p></li>
<li><p>I&#39;m not a full-stack developer and don&#39;t generally need ClojureScript, but I&#39;ve enjoyed the video series by Kelvin Mai: <a href="https://www.youtube.com/playlist?list=PLBeQxJQNprbgkmvbv80xC8R0SHcPsosjZ">Full Stack Clojure Contact Book</a> and by Daniel Amber: look up the &#34;full stack&#34; videos in his <a href="https://www.youtube.com/playlist?list=PLqunUpREWrwKdi3DEkTnIia54JjnWk8JB">assorted collection</a> of Clojure videos.</p></li>
<li><p><a href="https://www.parens-of-the-dead.com/">Parens of the Dead</a> is a terrific screencast series of zombie themed games written with Clojure / ClojureScript. Watch two expert Clojure programmers teach newcomers how to build everything from scratch, with clear explanations, run-time foibles, and some friendly banter. As of this post, the series is still undead!</p></li>
</ul></li>
<li><p>Good paid material is available too (no affiliation with any).</p>
<ul>
<li>Eric Normand&#39;s <a href="https://ericnormand.me/">video courses</a> offer firm grounding, especially with Ring libraries.</li>
<li><a href="https://www.jacekschae.com/">Courses by (and curated by) Jacek Shae</a> cover a range of Clojure web stacks, especially full-stack Clojure/ClojureScript web dev.</li>
<li><a href="https://pragprog.com/titles/dswdcloj3/web-development-with-clojure-third-edition/">Web development in Clojure</a> book, which uses a &#34;batteries included&#34; stack called Luminus.</li>
</ul></li>
</ul>
<h2 id="review-the-current-state-of-the-art">Review the current state of the art</h2>
<ul>
<li><p><a href="https://kit-clj.github.io/">kit-clj</a>, <a href="https://biffweb.com/">biffweb</a>, and <a href="https://github.com/juxt/edge">edge</a> are &#34;batteries included, production grade&#34; web stacks that look pretty good to me, all with thorough documentation. These should get you from quickstart to production.</p></li>
<li><p>Eric Normand opines on: <em><a href="https://ericnormand.me/mini-guide/what-web-framework-should-i-use-in-clojure">What Web Framework Should I Use in Clojure?</a></em></p></li>
<li><p>Another recent opinion piece; <a href="https://www.freshcodeit.com/blog/the-clojure-web-frameworks">The Clojure Web Developer&#39;s Toolkit: A Framework Face-off</a>, compares Luminus, Kit, and Pedestal.</p></li>
<li><p>The Clojure-doc site features a page on <a href="https://clojure-doc.org/articles/ecosystem/web_development/">Ecosystem: Web Development</a> (thanks, Sean Corfield for reviving clojure-doc.org!).</p></li>
<li><p>You may also like to check out <a href="https://hoplon.github.io/">hoplon</a> and keep tabs on emerging full-stack-y projects: <a href="https://donut.party/">donut</a>, <a href="https://github.com/chr15m/sitefox">sitefox</a>, and <a href="https://github.com/hyperfiddle/electric">electric-clojure</a>.</p></li>
</ul>

<p>The afore-linked references use many web stack pieces not seen in this post. These pieces are specialised solutions (libraries) for problems like routing, content negotiation, security, safe templating, safe SQL etc.; each solving for its particular domain of devilish edge cases.</p>
<p>The whys and wherefores thereof are being meditated upon in the next post with the working title <em>&#34;Getting Pretty Deep In The Woods&#34;</em>.</p>
<p>Or posts.</p>
<p>Egad.</p>
<figure>
<img src="https://www.evalapply.org/posts/clojure-web-app-from-scratch/http-headers-status-v3.jpg"/>
<figcaption>An activity diagram to describe the resolution of the response status code, given various headers. Image source: <a href="https://github.com/webmachine/webmachine/blob/main/docs/http-headers-status-v3.png">webmachine</a>, CC By SA 2.5, <a href="http://thoughtpad.net/alan-dean">Alan Dean</a>.</figcaption>
</figure>
<blockquote>
<p>Oh how your states go round and round,</p>
</blockquote>


  </section>
  
</article>
  </main>
      
    </div></div>
  </body>
</html>
