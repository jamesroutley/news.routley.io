<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/SubscriberLink/905777/a6dba1b2ed54f04f/">Original</a>
    <h1>Ushering Out Strlcpy()</h1>
    
    <div id="readability-page-1" class="page"><div>
<!-- $Id: slink-none,v 1.2 2005-11-04 22:11:18 corbet Exp $ -->
<blockquote>
<div>
<h3>Welcome to LWN.net</h3>
<p>
The following subscription-only content has been made available to you 
by an LWN subscriber.  Thousands of subscribers depend on LWN for the 
best news from the Linux and free software communities.  If you enjoy this 
article, please consider <a href="https://lwn.net/subscribe/">subscribing to LWN</a>.  Thank you
for visiting LWN.net!
</p></div>
</blockquote>
<p>
With all of the complex problems that must be solved in the kernel, one
might think that copying a string would draw little attention.  Even with
the hazards that C strings present, simply moving some bytes should not be
all that hard.  But string-copy functions have been a frequent subject of
debate over the years, with different variants being in fashion at times.
Now it seems that the BSD-derived </p><a href="https://man.openbsd.org/strlcpy.3"><tt>strlcpy()</tt></a><p> function
may finally be on its way out of the kernel.
</p><p>
In the beginning, copying strings in C was simple.
Your editor&#39;s dog-eared, first-edition copy of <i>The C Programming
Language</i> provides an implementation of <tt>strcpy()</tt> on page 101:
</p><pre>    strcpy(s, t)
    char *s, *t;
    {
        while (*s++ = *t++)
	    ;
    }
</pre>
<p>
This function has a few shortcomings, the most obvious of which is that
it will overrun the destination buffer if the source string is too long.
Developers working in C eventually concluded that this could be a problem,
so other string-copying functions were developed, starting with <a href="https://man7.org/linux/man-pages/man3/strncpy.3p.html"><tt>strncpy()</tt></a>:
</p><pre>    char *strncpy(char *dest, char *src, size_t n);
</pre>
<p>
This function will copy at most <tt>n</tt> bytes from <tt>src</tt> to
<tt>dest</tt>, so, if <tt>n</tt> is no larger than the length of
<tt>dest</tt>, then that array cannot be overrun.  <tt>strncpy()</tt> has a
couple of quirks, though.  It is defined to NUL-fill <tt>dest</tt> if
<tt>src</tt> is shorter than <tt>n</tt>, so it ends up always writing the
full array.  If <tt>src</tt> is longer than <tt>n</tt>, then <tt>dest</tt>
will not be NUL-terminated at all — an invitation to trouble if the caller
does not carefully check the return value.  That return value is <strike>the
address of the first NUL character written to <tt>dest</tt> unless
<tt>src</tt> is too long, in which case <tt>strncpy()</tt> returns
<tt>&amp;dest[n]</tt> — an address beyond the actual array</strike>
<tt>dest</tt> regardless of whether truncation occurs or not.  As a result,
checking for truncation is a bit tricky and often not done.  [Thanks to
Rasmus Villemoes for pointing out the error in our earlier description of
the <tt>strncpy()</tt> return value.]
</p><h4><tt>strlcpy()</tt> and <tt>strscpy()</tt></h4>
<p>
The BSD answer to the problems with <tt>strncpy()</tt> was to introduce a
new function called <tt>strlcpy()</tt>:
</p><pre>    size_t strlcpy(char *dest, const char *src, size_t n);
</pre>
<p>
This function, too, will copy a maximum of <tt>n</tt> bytes from
<tt>src</tt> to <tt>dest</tt>; unlike <tt>strncpy()</tt>, it will always
ensure that <tt>dest</tt> is NUL-terminated.  The return value is always
the length of <tt>src</tt> regardless of whether it was truncated in the
copy or not; developers must compare the returned length against <tt>n</tt>
to determine whether truncation has occurred.
</p><p>
The first uses of <tt>strlcpy()</tt> in the kernel entered
briefly during the 2.4 stable series — sort of.  The media subsystem had a
couple of implementations defined as:
</p><pre>    #define strlcpy(dest,src,len) strncpy(dest,src,(len)-1)
</pre>
<p>
As one might imagine, there was not a lot of checking of return values
going on at that point.  That macro disappeared relatively quickly,
but a real <tt>strlcpy()</tt> implementation appeared in the <a href="https://lore.kernel.org/lkml/Pine.LNX.4.44.0305261903330.2164-100000@home.transmeta.com/">2.5.70
release</a> in May 2003; that release also converted many callers in the
kernel over to this new function.  Everything seemed good for quite some
time.
</p><p>
In 2014, though, criticism of <tt>strlcpy()</tt> started to be heard,
resulting in, among other things, an <a href="https://lwn.net/Articles/612244/">extended
discussion</a> over whether 
to add an implementation to the GNU C library; to this day, glibc lacks
<tt>strlcpy()</tt>.  Kernel developers, too,
started to feel disenchanted with this API.  In 2015, <a href="https://lwn.net/Articles/659214/">yet another string-copy function</a> was added to
the kernel by Chris Metcalf:
</p><pre>    ssize_t strscpy(char *dest, const char *src, size_t count);
</pre>
<p>
This function, like the others, will copy <tt>src</tt> to <tt>dest</tt>
without overrunning the latter.  Like <tt>strlcpy()</tt>, it ensures that
the result is NUL-terminated.  The difference is in the return value; it
is the number of characters copied (without the trailing NUL byte) if the
string fits, and <tt>-E2BIG</tt> otherwise.
</p><h4>Reasons to like <tt>strscpy()</tt></h4>
<p>
Why is <tt>strscpy()</tt> better?  One claimed advantage is the return
value, which makes it easy to check whether the source string was truncated
or not.  There are a few other points as well, though; to get into
those, it is instructive to look at <a href="https://elixir.bootlin.com/linux/v5.19.3/source/lib/string.c#L125">the
kernel&#39;s implementation of <tt>strlcpy()</tt></a>:
</p><pre>    size_t strlcpy(char *dest, const char *src, size_t size)
    {
	size_t ret = strlen(src);

	if (size) {
	    size_t len = (ret &gt;= size) ? size - 1 : ret;
	    memcpy(dest, src, len);
	    dest[len] = &#39;\0&#39;;
	}
	return ret;
    }
</pre>
<p>

One obvious shortcoming is that this function will read the entire source
string regardless of whether that data will be copied or not.  Given the
defined semantics of <tt>strlcpy()</tt>, this inefficiency simply cannot be
fixed; there is no other way to return the length of the source string.
This is not just a question of efficiency, though; as recently <a href="https://lwn.net/ml/linux-kernel/CAHk-=wi+xbVq++uqW9YgWpHjyBHNB8a-xad+Xp23-B+eodLCEA@mail.gmail.com/">pointed
out</a> by Linus Torvalds, bad things can happen if the source
string is untrusted — which is one of the intended use cases for this
function.  If <tt>src</tt> is not NUL-terminated, then <tt>strlcpy()</tt>
will continue merrily off the end until it <i>does</i> find a NUL byte,
which may be way beyond the source array — if it doesn&#39;t crash first.
</p><p>
Finally, <tt>strlcpy()</tt> is subject to a race condition.  The length of
<tt>src</tt> is calculated, then later used to perform the copy and
returned to the caller.  But if <tt>src</tt> changes in the middle, strange
things could happen; at best the return value will not match what is
actually in the <tt>dest</tt> string.  This problem is specific to the
implementation rather 
than the definition, and could thus be fixed, but nobody seems to think
it&#39;s worth the effort.
</p><p>
The <a href="https://elixir.bootlin.com/linux/v5.19.3/source/lib/string.c#L151">implementation
of <tt>strscpy()</tt></a> avoids all of these problems and is also more
efficient.  It is also rather more complex as a result, of course.
</p><h4>The end of <tt>strlcpy()</tt> in the kernel?</h4>
<p>
When <tt>strlcpy()</tt> was first introduced, the intent was to replace
all of the <tt>strncpy()</tt> calls in the kernel and get rid of the latter
function altogether.  In the 6.0-rc2 kernel, though, there are still nearly
900 <tt>strncpy()</tt> call sites remaining; that number grew by two in the
6.0 merge window.  At the introduction of <tt>strscpy()</tt>, instead,
Torvalds explicitly <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=30c44659f4a3e7e1f9f47e895591b4b40bf62671">did
not want</a> to see any sort of mass conversion of <tt>strlcpy()</tt>
calls.  In 6.0-rc2, there are just over 1,400 <tt>strlcpy()</tt> calls and
nearly 1,800 <tt>strscpy()</tt> calls.
</p><p>
Nearly seven years later, the attitude seems to have changed a bit;
Torvalds now says that &#34;<q>strlcpy() does need to go</q>&#34;.  A number of
subsystems have made conversion passes, and the number of
<tt>strlcpy()</tt> call sites has fallen by 85 since 5.19.  Whether it will
ever be possible to remove <tt>strlcpy()</tt> entirely is unclear;
<tt>strncpy()</tt> is still holding strong despite its known hazards and a
decision to get rid of it nearly 20 years ago.  Once something gets
into the kernel, taking it out again can be a difficult process.
</p><p>
There may be hope, though, in this case.  As Torvalds <a href="https://lwn.net/ml/linux-kernel/CAHk-%3DwjGmhaE-Y8GqWKPtWYOi%3DbOarFgo7UkzHNoOVEKnkXXrQ%40mail.gmail.com/">observed</a>
in response to a set of conversions from Wolfram Sang, most of the callers to
<tt>strlcpy()</tt> never use the return value; those could all be converted
to <tt>strscpy()</tt> with no change in behavior.  All that would be needed, he
suggested, was for somebody to create a <a href="https://coccinelle.gitlabpages.inria.fr/website/">Coccinelle</a>
script to do the work.  Sang <a href="https://lwn.net/ml/linux-kernel/YvhXzarjOLEJ8nsW@shikoro/">rose to the challenge</a>
and has created <a href="https://git.kernel.org/pub/scm/linux/kernel/git/wsa/linux.git/log/?h=renesas/strlcpy">a
branch with the conversions done</a>.  That work, obviously, 
won&#39;t be considered for 6.0, but might show up in a 6.1 pull request.
</p><p>
That would leave relatively few <tt>strlcpy()</tt> users in the kernel.
Those could be cleaned up one by one, and it might just be possible to get
rid of <tt>strlcpy()</tt> entirely.  That would end a 20-year sporadic
discussion on the best way to do bounded string copies in the kernel — all
of those remaining <tt>strncpy()</tt> calls notwithstanding — at
least until some clever developer comes up an even better function and
starts the whole process anew.</p>
               </div></div>
  </body>
</html>
