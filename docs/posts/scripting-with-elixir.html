<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://underjord.io/scripting-with-elixir.html">Original</a>
    <h1>Scripting with Elixir</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
<main>
    <hr/>
    <article>
        
        <small>2023-06-12</small>
        <p>I was a Python developer for some time and one great joy of Python is that you have an expressive language that you can use for your serious apps as well as for your hacky little one-off script or bespoke pieces of automation. By expressive I mean that typing very little can give you a lot of progress towards your result. I’ve scripted a fair bit in Python. Now I do it with Elixir.</p>
<p>Overall I would recommend scripting in whatever language you are most comfortable in that is at least reasonably comfortable for scripting. A quick script benefits from a low barrier between thought and execution. Use what makes sense for you. I find Elixir surprisingly good as a scripting language ever since the introduction of <code>Mix.install</code>.</p>
<p>Elixir actually answers a question that Python, to my knowledge does not, in this regard. While you do need the language and its runtime installed, how about dependencies? I usually globally installed <code>requests</code> in Python, maybe an AWS SDK library, because I’d need them eventually.</p>
<p>In Elixir each script can briefly define dependencies.</p>

  <div>
    <p><span>elixir</span>
      
    </p>
    <div><pre tabindex="0"><code data-lang="elixir"><span>#!/usr/bin/env elixir</span>

<span>Mix</span><span>.</span>install([<span>:req</span>, <span>:jason</span>])

<span>&#34;https://api.github.com/users/lawik&#34;</span>
<span>|&gt;</span> <span>Req</span><span>.</span>get!()
<span>|&gt;</span> <span>IO</span><span>.</span>inspect()</code></pre></div>
  </div>

<p>The <code>Mix.install</code> part installs the top two things I need. An easy-to-use HTTP client (Erlang <code>httpc</code> works but is kinda clunky) and a JSON library. I could similarly pull in CSV-parsers or what-have-you. In Python you have JSON and CSV built in but you generally do want a better HTTP client.</p>
<p>I have occasionally found Elixir to be a bit less convenient for doing nice sloppy dictionaries as mutable state is less conveniently available and if I’m parsing a bunch of files or larger structures and want to build up convenient key/values for them I often want to exfiltrate some key and value out of multiple nested loops. This usually leads to Enum.reduce in Elixir and it is less convenient. It totally works though. And if you want to be really gnarly you can do <code>Process.put/2</code> and <code>Process.get/2</code>. I bet you could do it reasonably comfortable with an ETS table but I haven’t really used those while scripting. Yet.</p>
<p>Let’s compare.</p>

  <div>
    <p><span>python</span>
      
    </p>
    <div><pre tabindex="0"><code data-lang="python"><span>#/usr/bin/env python3</span>
index <span>=</span> {}

<span>with</span> f <span>in</span> open(<span>&#34;file.json&#34;</span>):
	<span>for</span> item <span>in</span> json<span>.</span>loads(f):
		<span>for</span> subitem <span>in</span> item[<span>&#34;children&#34;</span>]:
			index[subitem[<span>&#34;id&#34;</span>]] <span>=</span> subitem</code></pre></div>
  </div>

<p>Versus</p>

  <div>
    <p><span>elixir</span>
      
    </p>
    <div><pre tabindex="0"><code data-lang="elixir"><span>#/usr/bin/env elixir</span>

<span>&#34;file.json&#34;</span>
<span>|&gt;</span> <span>File</span><span>.</span>read!()
<span>|&gt;</span> <span>Jason</span><span>.</span>decode!()
<span>|&gt;</span> <span>Enum</span><span>.</span>reduce(%{}, <span>fn</span> item, index <span>-&gt;</span>
    <span>Enum</span><span>.</span>reduce(item[<span>&#34;children&#34;</span>], index, <span>fn</span> subitem, index <span>-&gt;</span>
		<span>Map</span><span>.</span>put(index, subitem[<span>&#34;id&#34;</span>], subitem)
    <span>end</span>)
<span>end</span>)</code></pre></div>
  </div>

<p>It can get a bit involved in nested cases. Especially if you need to operate on multiple data structures and such. Lacking mutability means paying more attention to data structures and how they flow through functions.</p>
<p>Overall though I’ve also found that whenever I do something slightly time-consuming I can optimize it significantly by using a single <code>Task.async_stream/3</code> which will effectively utilize all my cores as it works through whatever list I’m processing. Getting this equivalent thing going in Python is significantly more painful.</p>

  <div>
    <p><span>elixir</span>
      
    </p>
    <div><pre tabindex="0"><code data-lang="elixir"><span>#!/usr/bin/env elixir  </span>
  
<span>Mix</span><span>.</span>install([<span>:req</span>, <span>:jason</span>])  
  
<span>&#34;https://api.github.com/users/lawik/repos&#34;</span>  
<span>|&gt;</span> <span>Req</span><span>.</span>get!()  
<span>|&gt;</span> then(<span>&amp;</span> &amp;1<span>.</span>body)
<span># And now we get very parallel</span>
<span>|&gt;</span> <span>Task</span><span>.</span>async_stream(<span>fn</span> %{<span>&#34;stargazers_url&#34;</span> <span>=&gt;</span> url} <span>-&gt;</span>  
 url  
 <span>|&gt;</span> <span>Req</span><span>.</span>get!()  
 <span>|&gt;</span> then(<span>&amp;</span> &amp;1<span>.</span>body)  
<span>end</span>)  
<span>|&gt;</span> <span>Enum</span><span>.</span>flat_map(<span>fn</span> result <span>-&gt;</span>  
 <span>case</span> result <span>do</span>  
   {<span>:ok</span>, stargazers} <span>-&gt;</span>  
     stargazers  
   err <span>-&gt;</span>  
     <span>IO</span><span>.</span>inspect(err, <span>label</span>: <span>&#34;Error fetching stargazers&#34;</span>)  
     []  
 <span>end</span>  
<span>end</span>)  
<span>|&gt;</span> <span>Enum</span><span>.</span>uniq()  
<span>|&gt;</span> <span>Enum</span><span>.</span>count()  
<span>|&gt;</span> <span>IO</span><span>.</span>inspect()</code></pre></div>
  </div>

<p>When writing out this script and trying it I hit the Github API limit for unauthenticated calls on like my third or forth run :)</p>
<p>I also like that most of the Elixir syntax ends up being basic function calls. Instead of <code>with f in open</code> to open a file I’ll call the <code>File</code> module and the <code>read!</code> function. The exclamation point (or bang) is a special convention. In most cases there are matching functions without that symbol and those generally return an <code>{:ok, content}</code> tuple or an error tuple on failure. The bang functions will raise an error on failure. These bang functions make for very convenient pipelines. If you need to operate on the failure case it is generally better to use the regular one and a case statement.</p>
<p>This is very Erlang “let it crash” but applied in a different context. By using them in a script we are saying that any failure to exeute the function has no reasonable mitigation or that we don’t care to spend time defending against small deviations from expectation. Handling all conceivable possible outcomes of attempting to read a file is generally a waste of time and effort in a script that requires the file to exist. Just error out if it doesn’t.</p>
<p>First run can be a bit slow if the Mix.install needs to pull down and compile the packages (just as the initial pip install would) but subsequent runs will be reasonably snappy.</p>
<p>If you want more examples of doing scripting in Elixir I suggest looking at <a href="https://github.com/wojtekmach/mix_install_examples/tree/main">Wojtek Mach’s Mix Install Examples repo</a>. It has a lot of things. Wallaby for driving a browser. A single-file web server with Phoenix LiveView. Or why not write a NIF in C. Lots of fun stuff in there.</p>
<p>This is intentionally a shorter post. Hope you enjoyed it and it made you a bit curious. If you have thoughts, questions or anything of the sort you can reach me at <a href="mailto:lars@underjord.io">lars@underjord.io</a> or as @lawik@fosstodon.org on the Fediverse.</p>

    </article>

    <hr/>

    

    <hr/>
</main>

        </div></div>
  </body>
</html>
