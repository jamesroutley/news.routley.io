<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://turtleware.eu/posts/Using-Common-Lisp-from-inside-the-Browser.html">Original</a>
    <h1>Show HN: Using Common Lisp from Inside the Browser</h1>
    
    <div id="readability-page-1" class="page"><section id="content"> <div> <div> <div> <div>

<p> Tagged as <a href="https://turtleware.eu/tag/lisp.html">lisp</a>, <a href="https://turtleware.eu/tag/webassembly.html">webassembly</a> </p> <p> Written on 2025-08-21 by Daniel Kochmański </p> 

<ol>
<li><a href="#orgdcf199e">Scripting a website with Common Lisp</a></li>
<li><a href="#orgd38ed8e">JS-FFI – low level interface</a></li>
<li><a href="#org8b3e676">LIME/SLUG – interacting from Emacs</a></li>
<li><a href="#org490d9cc">Injecting CL runtime in arbitrary websites</a></li>
<li><a href="#org5264ea7">Current Caveats</a></li>
<li><a href="#orgfb4da56">Funding</a></li>
</ol>

<p>Web Embeddable Common Lisp is a project that brings Common Lisp and the Web
Browser environments together. In this post I&#39;ll outline the current progress of
the project and provide some technical details, including current caveats and
future plans.</p>

<p>It is important to note that this is not a release and none of the described
APIs and functionalities is considered to be stable. Things are still changing
and I&#39;m not accepting bug reports for the time being.</p>

<p>The source code of the project is available: <a href="https://fossil.turtleware.eu/wecl/">https://fossil.turtleware.eu/wecl/</a>.</p>





<p>The easiest way to use Common Lisp on a website is to include WECL and insert
script tags with a type &#34;text/common-lisp&#34;. When the attribute src is present,
then first the runtime loads the script from that url, and then it executes the
node body. For example create and run this HTML document from localhost:</p>

<pre><code>&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Web Embeddable Common Lisp&lt;/title&gt;
    &lt;link rel=&#34;stylesheet&#34; href=&#34;https://turtleware.eu/static/misc/wecl-20250821/easy.css&#34; /&gt;
    &lt;script type=&#34;text/javascript&#34; src=&#34;https://turtleware.eu/static/misc/wecl-20250821/boot.js&#34;&gt;&lt;/script&gt;
    &lt;script type=&#34;text/javascript&#34; src=&#34;https://turtleware.eu/static/misc/wecl-20250821/wecl.js&#34;&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script type=&#34;text/common-lisp&#34; src=&#34;https://turtleware.eu/static/misc/wecl-20250821/easy.lisp&#34; id=&#39;easy-script&#39;&gt;
(defvar *div* (make-element &#34;div&#34; :id &#34;my-ticker&#34;))
(append-child [body] *div*)

(dotimes (v 4)
  (push-counter v))

(loop for tic from 6 above 0
      do (replace-children *div* (make-paragraph &#34;~a&#34; tic))
         (js-sleep 1000)
      finally (replace-children *div* (make-paragraph &#34;BOOM!&#34;)))

(show-script-text &#34;easy-script&#34;)
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>We may use Common Lisp that can call to JavaScript, and register callbacks to be
called on specified events. The source code of the script can be found here:</p>

<ul>
<li><a href="https://turtleware.eu/static/misc/wecl-20250821/easy.html">https://turtleware.eu/static/misc/wecl-20250821/easy.html</a></li>
<li><a href="https://turtleware.eu/static/misc/wecl-20250821/easy.lisp">https://turtleware.eu/static/misc/wecl-20250821/easy.lisp</a></li>
</ul>

<p>Because the runtime is included as a script, the browser will usually cache the
~10MB WebAssembly module.</p>





<p>The initial foreign function interface has numerous macros defining wrappers
that may be used from Common Lisp or passed to JavaScript.</p>

<p>Summary of currently available operators:</p>

<ul>
<li><strong>define-js-variable:</strong> an inlined expression, like <code>document</code></li>
<li><strong>define-js-object:</strong> an object referenced from the object store</li>
<li><strong>define-js-function:</strong> a function</li>
<li><strong>define-js-method:</strong> a method of the argument, like <code>document.foobar()</code></li>
<li><strong>define-js-getter:</strong> a slot reader of the argument</li>
<li><strong>define-js-setter:</strong> a slot writer of the first argument</li>
<li><strong>define-js-accessor:</strong> combines define-js-getter and define-js-setter</li>
<li><strong>define-js-script:</strong> template for JavaScript expressions</li>
<li><strong>define-js-callback:</strong> Common Lisp function reference callable from JavaScript</li>
<li><strong>lambda-js-callback:</strong> anonymous Common Lisp function reference (for closures)</li>
</ul>

<p>Summary of argument types:</p>

<table>


<colgroup>
<col/>

<col/>

<col/>
</colgroup>
<thead>
<tr>
<th scope="col">type name</th>
<th scope="col">lisp side</th>
<th scope="col">js side</th>
</tr>
</thead>
<tbody>
<tr>
<td>:object</td>
<td>Common Lisp object</td>
<td>Common Lisp object reference</td>
</tr>

<tr>
<td>:js-ref</td>
<td>JavaScript object reference</td>
<td>JavaScript object</td>
</tr>

<tr>
<td>:fixnum</td>
<td>fixnum (coercible)</td>
<td>fixnum (coercible)</td>
</tr>

<tr>
<td>:symbol</td>
<td>symbol</td>
<td>symbol (name inlined)</td>
</tr>

<tr>
<td>:string</td>
<td>string (coercible)</td>
<td>string (coercible)</td>
</tr>

<tr>
<td>:null</td>
<td>nil</td>
<td>null</td>
</tr>
</tbody>
</table>

<p>All operators, except for <code>LAMBDA-JS-CALLBACK</code> have a similar lambda list:</p>

<blockquote>
<p>(DEFINE-JS NAME-AND-OPTIONS [ARGUMENTS [,@BODY]])</p>
</blockquote>

<p>The first argument is a list <code>(name &amp;key js-expr type)</code> that is common to all
defining operators:</p>

<ul>
<li><strong>name:</strong> Common Lisp symbol denoting the object</li>
<li><strong>js-expr:</strong> a string denoting the JavaScript expression, i.e &#34;innerText&#34;</li>
<li><strong>type:</strong> a type of the object returned by executing the expression</li>
</ul>

<p>For example:</p>

<pre><code>(define-js-variable ([document] :js-expr &#34;document&#34; :type :symbol))
;; document
(define-js-object ([body] :js-expr &#34;document.body&#34; :type :js-ref))
;; wecl_ensure_object(document.body) /* -&gt; id   */
;; wecl_search_object(id)            /* -&gt; node */
</code></pre>

<p>The difference between a variable and an object in JS-FFI is that variable
expression is executed each time when the object is used (the expression is
inlined), while the object expression is executed only once and the result is
stored in the object store.</p>

<p>The second argument is a list of pairs <code>(name type)</code>. Names will be used in the
lambda list of the operator callable from Common Lisp, while types will be used
to coerce arguments to the type expected by JavaScript.</p>

<pre><code>(define-js-function (parse-float :js-expr &#34;parseFloat&#34; :type :js-ref)
    ((value :string)))
;; parseFloat(value)

(define-js-method (add-event-listener :js-expr &#34;addEventListener&#34; :type :null)
    ((self :js-ref)
     (name :string)
     (fun :js-ref)))
;; self.addEventListener(name, fun)

(define-js-getter (get-inner-text :js-expr &#34;innerText&#34; :type :string)
    ((self :js-ref)))
;; self.innerText

(define-js-setter (set-inner-text :js-expr &#34;innerText&#34; :type :string)
    ((self :js-ref)
     (new :string)))
;; self.innerText = new

(define-js-accessor (inner-text :js-expr &#34;innerText&#34; :type :string)
    ((self :js-ref)
     (new :string)))
;; self.innerText
;; self.innerText = new

(define-js-script (document :js-expr &#34;~a.forEach(~a)&#34; :type :js-ref)
    ((nodes :js-ref)
     (callb :object)))
;; nodes.forEach(callb)
</code></pre>

<p>The third argument is specific to callbacks, where we define Common Lisp body of
the callback. Argument types are used to coerce values from JavaScript to Common
Lisp.</p>

<pre><code>(define-js-callback (print-node :type :object)
    ((elt :js-ref)
     (nth :fixnum)
     (seq :js-ref))
  (format t &#34;Node ~2d: ~a~%&#34; nth elt))

(let ((start 0))
  (add-event-listener *my-elt* &#34;click&#34;
                      (lambda-js-callback :null ((event :js-ref)) ;closure!
                        (incf start)
                        (setf (inner-text *my-elt*)
                              (format nil &#34;Hello World! ~a&#34; start)))
</code></pre>

<p>Note that callbacks are a bit different, because <code>define-js-callback</code> does not
accept <code>js-expr</code> option and <code>lambda-js-callback</code> has unique lambda list. It is
important for callbacks to have an exact arity as they are called with, because
JS-FFI does not implement variable number of arguments yet.</p>

<p>Callbacks can be referred by name with an operator <code>(js-callback name)</code>.</p>





<p>While working on FFI I&#39;ve decided to write an adapter for SLIME/SWANK that will
allow interacting with WECL from Emacs. The principle is simple: we connect with
a websocket to Emacs that is listening on the specified port (i.e on localhost).
This adapter uses the library <code>emacs-websocket</code> written by Andrew Hyatt.</p>

<p>It allows for compiling individual forms with <code>C-c C-c</code>, but file compilation
does not work (because files reside on a different &#34;host&#34;). REPL interaction
works as expected, as well as SLDB. The connection may occasionally be unstable,
and until Common Lisp call returns, the whole page is blocked. Notably waiting
for new requests is not a blocking operation from the JavaScript perspective,
because it is an asynchronous operation.</p>

<p>You may find my changes to SLIME here: <a href="https://github.com/dkochmanski/slime/">https://github.com/dkochmanski/slime/</a>,
and it is proposed upstream here: <a href="https://github.com/slime/slime/pull/879">https://github.com/slime/slime/pull/879</a>.
Before these changes are merged, we&#39;ll patch SLIME:</p>

<pre><code>;;; Patches for SLIME 2.31 (to be removed after the patch is merged).
;;; It is assumed that SLIME is already loaded into Emacs.
(defun slime-net-send (sexp proc)
  &#34;Send a SEXP to Lisp over the socket PROC.
This is the lowest level of communication. The sexp will be READ and
EVAL&#39;d by Lisp.&#34;
  (let* ((payload (encode-coding-string
                   (concat (slime-prin1-to-string sexp) &#34;\n&#34;)
                   &#39;utf-8-unix))
         (string (concat (slime-net-encode-length (length payload))
                         payload))
         (websocket (process-get proc :websocket)))
    (slime-log-event sexp)
    (if websocket
        (websocket-send-text websocket string)
      (process-send-string proc string))))

(defun slime-use-sigint-for-interrupt (&amp;optional connection)
  (let ((c (or connection (slime-connection))))
    (cl-ecase (slime-communication-style c)
      ((:fd-handler nil) t)
      ((:spawn :sigio :async) nil))))
</code></pre>

<p>Now we can load the LIME adapter opens a websocket server. The source code may
be downloaded from <a href="https://turtleware.eu/static/misc/wecl-20250821/lime.el">https://turtleware.eu/static/misc/wecl-20250821/lime.el</a>:</p>

<pre><code>;;; lime.el --- Lisp Interaction Mode for Emacs -*-lexical-binding:t-*-
;;; 
;;; This program extends SLIME with an ability to listen for lisp connections.
;;; The flow is reversed - normally SLIME is a client and SWANK is a server.

(require &#39;websocket)

(defvar *lime-server* nil
  &#34;The LIME server.&#34;)

(cl-defun lime-zipit (obj &amp;optional (start 0) (end 72))
  (let* ((msg (if (stringp obj)
                  obj
                (slime-prin1-to-string obj)))
         (len (length msg)))
    (substring msg (min start len) (min end len))))

(cl-defun lime-message (&amp;rest args)
  (with-current-buffer (process-buffer *lime-server*)
    (goto-char (point-max))
    (dolist (arg args)
      (insert (lime-zipit arg)))
    (insert &#34;\n&#34;)
    (goto-char (point-max))))

(cl-defun lime-client-process (client)
  (websocket-conn client))

(cl-defun lime-process-client (process)
  (process-get process :websocket))

;;; c.f slime-net-connect
(cl-defun lime-add-client (client)
  (lime-message &#34;LIME connecting a new client&#34;)
  (let* ((process (websocket-conn client))
         (buffer (generate-new-buffer &#34;*lime-connection*&#34;)))
    (set-process-buffer process buffer)
    (push process slime-net-processes)
    (slime-setup-connection process)
    client))

;;; When SLIME kills the process, then it invokes LIME-DISCONNECT hook.
;;; When SWANK kills the process, then it invokes LIME-DEL-CLIENT hook.
(cl-defun lime-del-client (client)
  (when-let ((process (lime-client-process client)))
    (lime-message &#34;LIME client disconnected&#34;)
    (slime-net-sentinel process &#34;closed by peer&#34;)))

(cl-defun lime-disconnect (process)
  (when-let ((client (lime-process-client process)))
    (lime-message &#34;LIME disconnecting client&#34;)
    (websocket-close client)))

(cl-defun lime-on-error (client fun error)
  (ignore client fun)
  (lime-message &#34;LIME error: &#34; (slime-prin1-to-string error)))

;;; Client sends the result over a websocket. Handling responses is implemented
;;; by SLIME-NET-FILTER. As we can see, the flow is reversed in our case.
(cl-defun lime-handle-message (client frame)
  (let ((process (lime-client-process client))
        (data (websocket-frame-text frame)))
    (lime-message &#34;LIME-RECV: &#34; data)
    (slime-net-filter process data)))

(cl-defun lime-net-listen (host port &amp;rest parameters)
  (when *lime-server*
    (error &#34;LIME server has already started&#34;))
  (setq *lime-server*
        (apply &#39;websocket-server port
               :host host
               :on-open    (function lime-add-client)
               :on-close   (function lime-del-client)
               :on-error   (function lime-on-error)
               :on-message (function lime-handle-message)
               parameters))
  (unless (memq &#39;lime-disconnect slime-net-process-close-hooks)
    (push &#39;lime-disconnect slime-net-process-close-hooks))
  (let ((buf (get-buffer-create &#34;*lime-server*&#34;)))
    (set-process-buffer *lime-server* buf)
    (lime-message &#34;Welcome &#34; *lime-server* &#34;!&#34;)
    t))

(cl-defun lime-stop ()
  (when *lime-server*
   (websocket-server-close *lime-server*)
   (setq *lime-server* nil)))
</code></pre>

<p>After loading this file into Emacs invoke <code>(lime-net-listen &#34;localhost&#34; 8889)</code>.
Now our Emacs listens for new connections from SLUG (the lisp-side part adapting
SWANK, already bundled with WECL). There are two SLUG backends in a repository:</p>

<ul>
<li><strong>WANK:</strong> for web browser environment</li>
<li><strong>FRIG:</strong> for Common Lisp runtime (uses <code>websocket-driver-client</code>)</li>
</ul>

<p>Now you can open a page listed here and connect to SLIME:</p>

<pre><code>&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Web Embeddable Common Lisp&lt;/title&gt;
    &lt;link rel=&#34;stylesheet&#34; href=&#34;easy.css&#34; /&gt;
    &lt;script type=&#34;text/javascript&#34; src=&#34;https://turtleware.eu/static/misc/wecl-20250821/boot.js&#34;&gt;&lt;/script&gt;
    &lt;script type=&#34;text/javascript&#34; src=&#34;https://turtleware.eu/static/misc/wecl-20250821/wecl.js&#34;&gt;&lt;/script&gt;
    &lt;script type=&#34;text/common-lisp&#34; src=&#34;https://turtleware.eu/static/misc/wecl-20250821/slug.lisp&#34;&gt;&lt;/script&gt;
    &lt;script type=&#34;text/common-lisp&#34; src=&#34;https://turtleware.eu/static/misc/wecl-20250821/wank.lisp&#34;&gt;&lt;/script&gt;
    &lt;script type=&#34;text/common-lisp&#34; src=&#34;https://turtleware.eu/static/misc/wecl-20250821/easy.lisp&#34;&gt;
      (defvar *connect-button* (make-element &#34;button&#34; :text &#34;Connect&#34;))
      (define-js-callback (connect-to-slug :type :null) ((event :js-ref))
        (wank-connect &#34;localhost&#34; 8889)
        (setf (inner-text *connect-button*) &#34;Crash!&#34;))
      (add-event-listener *connect-button* &#34;click&#34; (js-callback connect-to-slug))
      (append-child [body] *connect-button*)
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<ul>
<li><a href="https://turtleware.eu/static/misc/wecl-20250821/slug.html">https://turtleware.eu/static/misc/wecl-20250821/slug.html</a>.</li>
</ul>

<p>This example shows an important limitation – <span>Emscripten</span> does not allow for
multiple asynchronous contexts in the same thread. That means that if Lisp call
doesn&#39;t return (i.e because it waits for input in a loop), then we can&#39;t execute
other Common Lisp statements from elsewhere because the application will crash.</p>





<p>Here&#39;s another example. It is more a cool gimmick than anything else, but let&#39;s
try it. Open a console on this very website (on firefox C-S-i) and execute:</p>

<pre><code>function inject_js(url) {
    var head = document.getElementsByTagName(&#39;head&#39;)[0];
    var script = document.createElement(&#39;script&#39;);
    head.appendChild(script);
    script.type = &#39;text/javascript&#39;;
    return new Promise((resolve) =&gt; {
        script.onload = resolve;
        script.src = url;
    });
}

function inject_cl() {
    wecl_eval(&#39;(wecl/impl::js-load-slug &#34;https://turtleware.eu/static/misc/wecl-20250821&#34;)&#39;);
}

inject_js(&#39;https://turtleware.eu/static/misc/wecl-20250821/boot.js&#39;)
    .then(() =&gt; {
        wecl_init_hooks.push(inject_cl);
        inject_js(&#39;https://turtleware.eu/static/misc/wecl-20250821/wecl.js&#39;);
    });
</code></pre>

<p>With this, assuming that you&#39;ve kept your LIME server open, you&#39;ll have a REPL
onto uncooperative website. Now we can fool around with queries and changes:</p>

<pre><code>(define-js-accessor (title :js-expr &#34;title&#34; :type :string)
  ((self :js-ref)
   (title :string)))

(define-js-accessor (background :js-expr &#34;body.style.backgroundColor&#34; :type :string)
  ((self :js-ref)
   (background :string)))

(setf (title [document]) &#34;Write in Lisp!&#34;)
(setf (background [document]) &#34;#aaffaa&#34;)
</code></pre>





<p>The first thing to address is the lack of threading primitives. Native threads
can be implemented with web workers, but then our GC wouldn&#39;t know how to stop
the world to clean up. Another option is to use cooperative threads, but that
also won&#39;t work, because Emscripten doesn&#39;t support independent asynchronous
contexts, nor ECL is ready for that yet.</p>

<p>I plan to address both issues simultaneously in the second stage of the project
when I port the runtime to WASI. We&#39;ll be able to use browser&#39;s GC, so running
in multiple web workers should not be a problem anymore. Unwinding and rewinding
the stack will require tinkering with ASYNCIFY and I have somewhat working green
threads implementation in place, so I will finish it and upstream in ECL.</p>

<p>Currently I&#39;m focusing mostly on having things working, so JS and CL interop is
brittle and often relies on evaluating expressions, trampolining and coercing.
That impacts the performance in a significant way. Moreover all loaded scripts
are compiled with a one-pass compiler, so the result bytecode is not optimized.</p>

<p>There is no support for loading cross-compiled files onto the runtime, not to
mention that it is not possible to precompile systems with ASDF definitions.</p>

<p>JS-FFI requires more work to allow for defining functions with variable number
of arguments and with optional arguments. There is no dynamic coercion of
JavaScript exceptions to Common Lisp conditions, but it is planned.</p>





<p>This project is funded through <a href="https://nlnet.nl/commonsfund">NGI0 Commons Fund</a>, a fund established by <a href="https://nlnet.nl">NLnet</a> with financial support from the European Commission&#39;s <a href="https://ngi.eu">Next Generation Internet</a> program. Learn more at the <a href="https://nlnet.nl/project/ECL">NLnet project page</a>.</p>

<p><a href="https://nlnet.nl"><img src="https://nlnet.nl/logo/banner.png" alt="NLnet foundation logo" width="20%"/></a>
<a href="https://nlnet.nl/commonsfund"><img src="https://nlnet.nl/image/logos/NGI0_tag.svg" alt="NGI Zero Logo" width="20%"/></a></p>
 </div>
 </div>  </div> </div> </section></div>
  </body>
</html>
