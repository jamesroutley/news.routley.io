<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://radanskoric.com/experiments/minesweeper-100-lines-of-clean-ruby">Original</a>
    <h1>Exercise: Minesweeper in 100 lines of Ruby</h1>
    
    <div id="readability-page-1" class="page"><div><p>Ruby is such an expressive language. You can often do surprisingly much with just a few lines of code. It’s why I find it so satisfying to think about how to accomplish the same thing in fewer lines of Ruby<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" rel="footnote">1</a></sup>.</p><p>I want to be clear: I am not talking about <a href="https://en.wikipedia.org/wiki/Code_golf" target="_blank">Code Golfing</a>, although that can also be fun. I’m talking about reducing the number of lines of code <strong>without loosing the readability</strong>. In fact, one of the nicest things about Ruby is how often reducing the number of lines of code can <strong>increase readability.</strong></p><p>As an exercise, let’s do this with good old minesweeper. I remember playing it on Windows XP when I was a kid. If you also have such memories, well, hello fellow millenial!</p><p><a href="https://radanskoric.com/assets/img/posts/minesweeper.png"><img src="https://radanskoric.com/assets/img/posts/minesweeper.png" alt="How much total time has humanity spent on this game?" width="506" height="363" loading="lazy"/></a></p><p>For practice, I implemented it in CLI form in vanilla Ruby. Get my fully implemented version <a href="https://github.com/radanskoric/minesweeper" target="_blank">here</a>. If you want to do it yourself, stop here and come back later to compare. The rest of the article walks through my implementation which landed on exactly 100 lines (counted by <a href="https://github.com/AlDanial/cloc" target="_blank">cloc</a> in lib folder) by a happy accident. No, really, I didn’t cheat to make it be a round number. I was planning on doing it but turns out I didn’t have to.</p><p><strong>Along the way we’ll also refresh our memory of some less often used Ruby features.</strong> I can’t learn new things in a vacuum. I prefer to learn in context of a mini project over learning from Changelog overviews.</p><h2 id="generating-the-playing-board"><span>Generating the playing board</span><a href="#generating-the-playing-board"><i></i></a></h2><p>The first thing we need is a <code>Board</code> class to represent, drum roll, the board. The board is fully defined by its width, height and the locations of mines:</p><div file="lib/minesweeper/board.rb"><p><code><table><tbody><tr><td><pre>1
2
3
</pre></td><td><pre><span>class</span> <span>Board</span> <span>&lt;</span> <span>Data</span><span>.</span><span>define</span><span>(</span><span>:width</span><span>,</span> <span>:height</span><span>,</span> <span>:mines</span><span>)</span>
  <span># content ...</span>
<span>end</span>
</pre></td></tr></tbody></table></code></p></div><p>Here we’re using a feature <a href="https://docs.ruby-lang.org/en/3.2/Data.html" target="_blank">introduced in Ruby 3.2, Data class</a>. It’s perfect for defining immutable value objects. If you’ve used if before you’re probably wondering why I didn’t use the usual syntax of <code>Board = Data.define(...) do ... end</code> and instead inherited from it. That will be explained a bit later.</p><p>We’ll create the board by randomly placing a number of mines on it. We can’t just give each mine a random pair of coordinates because then we could end up with 2 mines in the same location. Instead we want to take all possible locations on the board and then randomly take some of these locations.</p><p>Thankfully, in Ruby this is not far from the plain English description:</p><div file="lib/minesweeper/board.rb"><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
</pre></td><td><pre><span>class</span> <span>Board</span> <span>&lt;</span> <span>Data</span><span>.</span><span>define</span><span>(</span><span>:width</span><span>,</span> <span>:height</span><span>,</span> <span>:mines</span><span>)</span>
    <span># ...</span>
    <span>def</span> <span>self</span><span>.</span><span>generate_random</span><span>(</span><span>width</span><span>,</span> <span>height</span><span>,</span> <span>mines_count</span><span>)</span>
      <span>full_board</span> <span>=</span> <span>Enumerator</span><span>.</span><span>product</span><span>(</span><span>width</span><span>.</span><span>times</span><span>,</span> <span>height</span><span>.</span><span>times</span><span>)</span>
        <span>.</span><span>map</span> <span>{</span> <span>|</span><span>x</span><span>,</span> <span>y</span><span>|</span> <span>Coordinate</span><span>.</span><span>new</span><span>(</span><span>x</span><span>,</span> <span>y</span><span>)</span> <span>}</span>
      <span>self</span><span>.</span><span>new</span><span>(</span><span>width</span><span>,</span> <span>height</span><span>,</span> <span>full_board</span><span>.</span><span>sample</span><span>(</span><span>mines_count</span><span>))</span>
    <span>end</span>
    <span># ...</span>
<span>end</span>
</pre></td></tr></tbody></table></code></p></div><p>The <a href="https://docs.ruby-lang.org/en/master/Enumerator.html#method-c-product" target="_blank">product enumerator</a> takes two enumerators and returns their cartesian product. That’s a mathematical way of saying: “every element from first list, combined with every element from second list”. This effectively gives us all of the possible coordinates. And then we call <code>sample</code> which takes a number of random elements from a collection. I could have inlined that call to save lines but I felt like using <code>full_board</code> variable has a nice self documenting effect.</p><p>The <code>Coordinate</code> class starts as another simple <code>Data</code> object:</p><div><p><code><table><tbody><tr><td><pre>1
</pre></td><td><pre><span>Coordinate</span> <span>=</span> <span>Data</span><span>.</span><span>define</span><span>(</span><span>:x</span><span>,</span> <span>:y</span><span>)</span>
</pre></td></tr></tbody></table></code></p></div><p>The <code>Board</code> should also determine if a specific cell has a mine or is empty. If it is empty we want to know how many neighbouring mines it has. Since <code>mines</code> is already just an array of <code>Coordinate</code> objects, we can use it directly:</p><div file="lib/minesweeper/board.rb"><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td><pre><span>class</span> <span>Board</span> <span>&lt;</span> <span>Data</span><span>.</span><span>define</span><span>(</span><span>:width</span><span>,</span> <span>:height</span><span>,</span> <span>:mines</span><span>)</span>
    <span># ...</span>
    <span>class</span> <span>Mine</span><span>;</span> <span>end</span><span>;</span>
    <span>Empty</span> <span>=</span> <span>Data</span><span>.</span><span>define</span><span>(</span><span>:neighbour_mines</span><span>)</span>

    <span>def</span> <span>cell</span><span>(</span><span>coordinate</span><span>)</span>
      <span>mines</span><span>.</span><span>include?</span><span>(</span><span>coordinate</span><span>)</span> <span>?</span> <span>Mine</span><span>.</span><span>new</span> <span>:</span> <span>Empty</span><span>.</span><span>new</span><span>(</span><span>count_neighbours</span><span>(</span><span>coordinate</span><span>))</span>
    <span>end</span>

    <span>private</span>

    <span>def</span> <span>count_neighbours</span><span>(</span><span>coordinate</span><span>)</span>
      <span>mines</span><span>.</span><span>count</span> <span>{</span> <span>|</span><span>mine</span><span>|</span> <span>mine</span><span>.</span><span>neighbour?</span><span>(</span><span>coordinate</span><span>)</span> <span>}</span>
    <span>end</span>
  <span>end</span>
</pre></td></tr></tbody></table></code></p></div><p>The <code>Mine</code> and <code>Empty</code> nested subclasses are why here I inherited from <code>Data</code> defined class, they’ll be needed outside this context. They would not be visible from inside a <code>Data.define do; end</code> block.</p><p>Yes, the method that counts the neighbours is <em>not optimal</em> as it checks all mines. For now, let’s keep the very readable simple version and optimise if needed.</p><p>In that last method, a <code>mine</code> is just a <code>coordinate</code> and we use a <code>neighbour?</code> method we haven’t yet defined. We define it by checking that the distance in either coordinate is less than or equal to 1:</p><div file="lib/minesweeper/coordinate.rb"><p><code><table><tbody><tr><td><pre>1
2
3
4
5
</pre></td><td><pre><span>Coordinate</span> <span>=</span> <span>Data</span><span>.</span><span>define</span><span>(</span><span>:x</span><span>,</span> <span>:y</span><span>)</span> <span>do</span>
    <span>def</span> <span>neighbour?</span><span>(</span><span>other</span><span>)</span>
      <span>[(</span><span>self</span><span>.</span><span>x</span> <span>-</span> <span>other</span><span>.</span><span>x</span><span>).</span><span>abs</span><span>,</span> <span>(</span><span>self</span><span>.</span><span>y</span> <span>-</span> <span>other</span><span>.</span><span>y</span><span>).</span><span>abs</span><span>].</span><span>max</span> <span>&lt;=</span> <span>1</span>
    <span>end</span>
<span>end</span>
</pre></td></tr></tbody></table></code></p></div><p>With that we’ve finished the <code>Board</code> class.</p><h2 id="playing-the-game"><span>Playing the game</span><a href="#playing-the-game"><i></i></a></h2><p>We’ll leave the actual playing of the game to a new class named, shockingly, <code>Game</code>. It needs: an instance of the board object and a map of what has been revealed so far:</p><div file="lib/minesweeper/game.rb"><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
</pre></td><td><pre><span>class</span> <span>Game</span>
    <span>def</span> <span>initialize</span><span>(</span><span>board</span><span>)</span>
      <span>@cells</span> <span>=</span> <span>Array</span><span>.</span><span>new</span><span>(</span><span>board</span><span>.</span><span>height</span> <span>*</span> <span>board</span><span>.</span><span>width</span><span>,</span> <span>nil</span><span>)</span>
      <span>@board</span> <span>=</span> <span>board</span>
    <span>end</span>
    <span># ...</span>
<span>end</span>
</pre></td></tr></tbody></table></code></p></div><p>Initially nothing has been revealed so we initialise an array matching the board size. By default it’s initialised with all <code>nil</code>.</p><p>We’ll reduce the interface to a single <code>reveal</code> method which is what we’ll run when we “click” on a cell to reveal it. The only tricky part is that when you reveal a cell that has no neighbouring mines, the game should then <a href="https://en.wikipedia.org/wiki/Recursion_%28computer_science%29" target="_blank">recursively</a> auto reveal all neighbouring cells. This is what causes the satisfying “pop” when a whole area becomes revealed at once. We’ll implement the logic just as we described it now, by recursively revealing all neighbouring cells:</p><div file="lib/minesweeper/game.rb"><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td><pre><span>class</span> <span>Game</span>
  <span># ...</span>
  <span>CELL_WITH_NO_ADJACENT_MINES</span> <span>=</span> <span>Board</span><span>::</span><span>Empty</span><span>.</span><span>new</span><span>(</span><span>0</span><span>)</span>

  <span>def</span> <span>reveal</span><span>(</span><span>coordinate</span><span>)</span>
    <span>index</span> <span>=</span> <span>cell_index</span><span>(</span><span>coordinate</span><span>)</span>
    <span>return</span> <span>:play</span> <span>if</span> <span>@cells</span><span>[</span><span>index</span><span>]</span>

    <span>(</span><span>@cells</span><span>[</span><span>index</span><span>]</span> <span>=</span> <span>@board</span><span>.</span><span>cell</span><span>(</span><span>coordinate</span><span>)).</span><span>tap</span> <span>do</span> <span>|</span><span>cell</span><span>|</span>
      <span>return</span> <span>:lose</span> <span>if</span> <span>cell</span><span>.</span><span>is_a?</span><span>(</span><span>Board</span><span>::</span><span>Mine</span><span>)</span>
      <span>reveal_neighbours</span><span>(</span><span>coordinate</span><span>)</span> <span>if</span> <span>cell</span> <span>==</span> <span>CELL_WITH_NO_ADJACENT_MINES</span>
    <span>end</span>
    <span>@cells</span><span>.</span><span>count</span><span>(</span><span>&amp;</span><span>:nil?</span><span>)</span> <span>==</span> <span>@board</span><span>.</span><span>mines</span><span>.</span><span>size</span> <span>?</span> <span>:win</span> <span>:</span> <span>:play</span>
  <span>end</span>

  <span>private</span>

  <span>def</span> <span>cell_index</span><span>(</span><span>coordinate</span><span>)</span><span>=</span> <span>coordinate</span><span>.</span><span>y</span> <span>*</span> <span>@board</span><span>.</span><span>width</span> <span>+</span> <span>coordinate</span><span>.</span><span>x</span>

  <span>def</span> <span>reveal_neighbours</span><span>(</span><span>coordinate</span><span>)</span>
    <span>coordinate</span><span>.</span><span>neighbours</span><span>(</span><span>width</span><span>,</span> <span>height</span><span>).</span><span>each</span> <span>{</span> <span>|</span><span>n</span><span>|</span> <span>reveal</span><span>(</span><span>n</span><span>)</span> <span>}</span>
  <span>end</span>
<span>end</span>
</pre></td></tr></tbody></table></code></p></div><p>This effectively performs a <a href="https://en.wikipedia.org/wiki/Breadth-first_search" target="_blank">Breadth-first search</a> of the board when a cell-with-no-adjacent-mines is revealed. There are 2 key parts making it work:</p><ol><li>The early exit from the method when a cell has already been revealed.</li><li>Assigning the revealed value before recursing into calling reveal on the neighbours. This prevents hitting infinite recursion when a neighbour we just revealed tries to then reveal the original cell.</li></ol><p>Finally, if we hit a mine we exit early with <code>:lose</code>. Otherwise we check if all the remaining cells are just mines and, if yes, return <code>:win</code>. All other cases return <code>:play</code>.</p><p>The only thing missing here is the neighbours method on the coordinate. We implement it by first creating a list of offsets to all 8 neighbours:</p><div file="lib/minesweeper/coordinate.rb"><p><code><table><tbody><tr><td><pre>1
2
3
4
</pre></td><td><pre><span>Coordinate</span> <span>=</span> <span>Data</span><span>.</span><span>define</span><span>(</span><span>:x</span><span>,</span> <span>:y</span><span>)</span> <span>do</span>
  <span>NEIGHBOURS</span> <span>=</span> <span>(</span><span>Enumerator</span><span>.</span><span>product</span><span>([</span><span>-</span><span>1</span><span>,</span> <span>0</span><span>,</span> <span>1</span><span>],</span> <span>[</span><span>-</span><span>1</span><span>,</span> <span>0</span><span>,</span> <span>1</span><span>]).</span><span>to_a</span> <span>-</span> <span>[</span><span>0</span><span>,</span> <span>0</span><span>]).</span><span>map</span> <span>{</span> <span>|</span><span>x</span><span>,</span> <span>y</span><span>|</span> <span>self</span><span>.</span><span>new</span><span>(</span><span>x</span><span>,</span> <span>y</span><span>)</span> <span>}</span>
  <span># ...</span>
<span>end</span>
</pre></td></tr></tbody></table></code></p></div><p>We’re again using <code>product</code> except this will also include the centre which we remove by subtracting <code>[0, 0]</code> from the list.</p><p>The list of actual neighbour coordinates is then formed by adding all neighbour offsets to the coordinate and removing any that fall outside the board:</p><div file="lib/minesweeper/coordinate.rb"><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td><pre><span>Coordinate</span> <span>=</span> <span>Data</span><span>.</span><span>define</span><span>(</span><span>:x</span><span>,</span> <span>:y</span><span>)</span> <span>do</span>
  <span># ...</span>
  <span>def</span> <span>+</span><span>(</span><span>other</span><span>)</span>
    <span>self</span><span>.</span><span>class</span><span>.</span><span>new</span><span>(</span><span>self</span><span>.</span><span>x</span> <span>+</span> <span>other</span><span>.</span><span>x</span><span>,</span> <span>self</span><span>.</span><span>y</span> <span>+</span> <span>other</span><span>.</span><span>y</span><span>)</span>
  <span>end</span>

  <span>def</span> <span>neighbours</span><span>(</span><span>board_width</span><span>,</span> <span>board_height</span><span>)</span>
    <span>NEIGHBOURS</span>
      <span>.</span><span>map</span> <span>{</span> <span>|</span><span>n</span><span>|</span> <span>self</span> <span>+</span> <span>n</span> <span>}</span>
      <span>.</span><span>reject</span> <span>{</span> <span>|</span><span>n</span><span>|</span> <span>n</span><span>.</span><span>x</span> <span>&lt;</span> <span>0</span> <span>||</span> <span>n</span><span>.</span><span>x</span> <span>&gt;=</span> <span>board_width</span> <span>||</span> <span>n</span><span>.</span><span>y</span> <span>&lt;</span> <span>0</span> <span>||</span> <span>n</span><span>.</span><span>y</span> <span>&gt;=</span> <span>board_height</span> <span>}</span>
  <span>end</span>
<span>end</span>
</pre></td></tr></tbody></table></code></p></div><h2 id="ascii-printing-the-board"><span>ASCII printing the board</span><a href="#ascii-printing-the-board"><i></i></a></h2><p>To print the board on the command line we’ll iterate over the grid, converting the cells to ASCII characters:</p><div file="lib/minesweeper/ascii_renderer.rb"><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td><pre><span>AsciiRenderer</span> <span>=</span> <span>Data</span><span>.</span><span>define</span><span>(</span><span>:grid</span><span>)</span> <span>do</span>
  <span>def</span> <span>render</span><span>(</span><span>output</span> <span>=</span> <span>$stdout</span><span>)</span>
    <span>grid</span><span>.</span><span>height</span><span>.</span><span>times</span> <span>do</span> <span>|</span><span>y</span><span>|</span>
      <span>grid</span><span>.</span><span>width</span><span>.</span><span>times</span> <span>do</span> <span>|</span><span>x</span><span>|</span>
        <span>output</span><span>.</span><span>print</span> <span>case</span> <span>cell</span> <span>=</span> <span>grid</span><span>.</span><span>cell</span><span>(</span><span>Coordinate</span><span>.</span><span>new</span><span>(</span><span>x</span><span>,</span> <span>y</span><span>))</span>
                      <span>when</span> <span>nil</span> <span>then</span> <span>&#34;#&#34;</span>
                      <span>when</span> <span>Board</span><span>::</span><span>Mine</span> <span>then</span> <span>&#34;*&#34;</span>
                      <span>else</span> <span>cell</span><span>.</span><span>neighbour_mines</span><span>.</span><span>zero?</span> <span>?</span> <span>&#34;_&#34;</span> <span>:</span> <span>cell</span><span>.</span><span>neighbour_mines</span>
                      <span>end</span>
      <span>end</span>
      <span>output</span><span>.</span><span>puts</span>
    <span>end</span>
  <span>end</span>
<span>end</span>
</pre></td></tr></tbody></table></code></p></div><p>This will print something like this:</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
</pre></td><td><pre>___1#1_______1#1___1#1__1#1___
___111_______111___1#1__1#1___
11_________________111__1#211_
#21111_______111111_____1###1_
#####1_______1####311___12#21_
###211__111__111####1____111__
###1____2#2____1#2211_______11
###1____2#2____1#1__________1#
</pre></td></tr></tbody></table></code></p></div><p>Notice that it expects <code>width</code>, <code>height</code> and <code>cell</code> methods which we have defined on <code>Board</code> but not on<code>Game</code> and we actually need to print instances of <code>Game</code>. Let’s define them:</p><div file="lib/minesweeper/game.rb"><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
</pre></td><td><pre><span>class</span> <span>Game</span>
  <span># ...</span>
  <span>def</span> <span>width</span> <span>=</span> <span>@board</span><span>.</span><span>width</span>
  <span>def</span> <span>height</span> <span>=</span> <span>@board</span><span>.</span><span>height</span>
  <span>def</span> <span>cell</span><span>(</span><span>coordinate</span><span>)</span> <span>=</span> <span>@cells</span><span>[</span><span>cell_index</span><span>(</span><span>coordinate</span><span>)]</span>
  <span># ...</span>
<span>end</span>
</pre></td></tr></tbody></table></code></p></div><p>Here we’re using <a href="https://allaboutcoding.ghinda.com/endless-method-a-quick-intro" target="_blank">endless methods</a>. Yes, they did save 2 lines per each method, playing a role in the full game being exactly 100 lines, but that’s not why I used them! The only requirement of endless methods is that the method body is just <strong>one expression</strong>, how ever many lines it spans. Notice there are several methods on <code>Coordinate</code> and <code>Board</code> which could also be endless methods. I didn’t use it there because the result wasn’t very readable. Aesthetics matter.</p><h2 id="putting-it-all-together"><span>Putting it all together</span><a href="#putting-it-all-together"><i></i></a></h2><p>Finally, we assemble all components into a playable command-line game.</p><p>We want to be able to run it with <code>ruby lib/play.rb 20, 10, 20</code> and params defining: width, height, and number of mines. For that we’ll parse the command line arguments:</p><div file="lib/play.rb"><p><code><table><tbody><tr><td><pre>1
2
3
4
5
</pre></td><td><pre><span>if</span> <span>ARGV</span><span>.</span><span>size</span> <span>==</span> <span>3</span>
  <span>Minesweeper</span><span>.</span><span>play</span><span>(</span><span>*</span><span>ARGV</span><span>.</span><span>map</span><span>(</span><span>&amp;</span><span>:to_i</span><span>))</span>
<span>else</span>
  <span>puts</span> <span>&#34;Usage: ruby lib/play.rb width, height, mines_count (e.g. &#39;play.rb 12 6 6&#39;)&#34;</span>
<span>end</span>
</pre></td></tr></tbody></table></code></p></div><p>And now we just define the play method as a module function. We’ll use <code>Readline</code> module to print a prompt and read one line at a time. It’s the same thing used under the hood by IRB. :</p><div file="lib/play.rb"><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td><pre><span>module</span> <span>Minesweeper</span>
  <span>module_function</span> <span>def</span> <span>play</span><span>(</span><span>...</span><span>)</span>
    <span>game</span> <span>=</span> <span>Game</span><span>.</span><span>new</span><span>(</span><span>Board</span><span>.</span><span>generate_random</span><span>(</span><span>...</span><span>))</span>
    <span>renderer</span> <span>=</span> <span>AsciiRenderer</span><span>.</span><span>new</span><span>(</span><span>game</span><span>)</span>
    <span>renderer</span><span>.</span><span>render</span>

    <span>while</span> <span>input</span> <span>=</span> <span>Readline</span><span>.</span><span>readline</span><span>(</span><span>&#34;Type click coordinate as &#39;x, y&#39; (0 based)&gt; &#34;</span><span>)</span>
      <span>result</span> <span>=</span> <span>game</span><span>.</span><span>reveal</span><span>(</span><span>Coordinate</span><span>.</span><span>new</span><span>(</span><span>*</span><span>input</span><span>.</span><span>split</span><span>(</span><span>&#34;,&#34;</span><span>).</span><span>map</span><span>(</span><span>&amp;</span><span>:to_i</span><span>)))</span>
      <span>renderer</span><span>.</span><span>render</span>
      <span>if</span> <span>[</span><span>:win</span><span>,</span> <span>:lose</span><span>].</span><span>include?</span><span>(</span><span>result</span><span>)</span>
        <span>puts</span> <span>&#34;You </span><span>#{</span><span>result</span> <span>==</span> <span>:win</span> <span>?</span> <span>&#34;win&#34;</span> <span>:</span> <span>&#34;lose&#34;</span><span>}</span><span>!&#34;</span>
        <span>return</span>
      <span>end</span>
    <span>end</span>
  <span>end</span>
<span>end</span>
</pre></td></tr></tbody></table></code></p></div><p>Notice that we’re using here <code>def play(...)</code> . That syntax was added in Ruby 2.7. to support uses cases where all parameters are simply forwarded. Here, the parameters need to be completely forwarded to <code>Board.generate_random</code> and then we add gameplay logic around it.</p><h2 id="what-next"><span>What next?</span><a href="#what-next"><i></i></a></h2><p>You can get my fully implemented version <a href="https://github.com/radanskoric/minesweeper" target="_blank">here</a>. If you’ve implemented your version for practice, please share it in the comments.</p><p>Now, this is technically a fully playable minesweeper implementation but it’s not exactly fun to play. CLI is not a great fit for Minesweeper. That’s why in the next post we’ll package it into a Rails + Hotwire application. And just for fun we’ll make it multiplayer, because why not. Stay tuned.</p></div></div>
  </body>
</html>
