<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://erikarow.land/notes/git-spelunking-bisect">Original</a>
    <h1>Git Spelunking with Bisect</h1>
    
    <div id="readability-page-1" class="page"><section id="Git-Spelunking-with-Bisect">

<p>Today, I continued on the git spelunking that prompted the post from <a href="https://odigos.io/notes/git-checkout-tag">yesterday</a>. I’ve been diving deeper in the Erlang codebase today, and so I needed some new tools.</p>
<section id="git-bisect">
<h2><code>git bisect</code></h2>
<p><code>git-bisect</code> lets you search for a commit using binary search. I wanted to find the last commit that contained a particular Erlang function in the <a href="https://github.com/erlang/otp"><code>otp</code></a> codebase. My process looked something like this:<label for="fn1"></label><span></span><label for="fn2"></label><span></span></p>
<p>First I start the bisect</p>
<pre><code>git bisect start
</code></pre>
<p>Then I specify a commit that didn’t have the function, in this case HEAD:</p>
<pre><code>git bisect bad
</code></pre>
<p>Then I specify a commit that <strong>does</strong> have the function. In this case I knew that the function was in OTP_R14A. <code>git-bisect</code> lets me specify a tag here:</p>
<pre><code>git bisect good OTP_R14A
</code></pre>
<p>At this point <code>git-bisect</code> took me automatically to a commit that was roughly halfway between those two commits. While I’m here, I can run whatever checks I want to on the command line:</p>
<pre><code>rg &#39;&lt;function-to-find&gt;&#39;
</code></pre>
<p>If the function is there, I mark <code>git bisect good</code>. If it’s not, then I mark <code>git bisect bad</code>. Either way, <code>git-bisect</code> moves me to the next pivot commit in the search. <code>otp</code> has tens of thousands of commits, but binary search meant that it took around 15 steps to get the commit I wanted.</p>
<p>Once I was done, I could run:</p>
<pre><code>git bisect reset
</code></pre>
<p>To get back to where I started.</p>
<p>It’s great to know that I can run whatever arbitrary manual commands I need at each manual step, but in this case I was running the same command each time.</p>
<p>In this case, that’s where <code>git bisect run</code> comes in:</p>
</section>
<section id="git-bisect-run">
<h2><code>git bisect run</code></h2>
<p><code>git bisect run</code> lets you run a script to check for <code>good/bad</code> at each step of the binary search, instead of having to do it manually.<label for="fn3"></label><span></span><label for="fn4"></label><span></span></p>
<p>The initial suggestion I got was to use <code>git grep</code> as in:</p>
<pre><code>git bisect start
git bisect bad
git bisect good &#34;[tag]&#34;
git bisect run git grep &#34;[function name]&#34;
</code></pre>
<p>But I knew that there were <strong>two</strong> versions of <code>is_system_process/1</code> at various times in the Erlang codebase. I only wanted to know about the older one,
so I used this modified version instead:</p>
<pre><code>git bisect start
git bisect bad
git bisect good OTP_R14A
git bisect run git grep &#34;[function name]&#34; &#34;path/to/folder/*&#34;
</code></pre>
<p>Where <code>path/to/folder/*</code> was pointing the folder I knew the function was in.<label for="fn5"></label><span></span></p>
<p>With this, the binary search took a few seconds and quickly returned the same commit that I found manually.</p>
<p>Now that I had the commit in hand, I wanted to know what the <em>next</em> tagged release that contained that commit was. Enter <code>git-describe</code>:</p>
</section>
<section id="git-describe">
<h2><code>git describe</code></h2>
<p><code>git-describe</code> is purpose built for finding tags from commits. By default, it finds the tag that immediately predates the commit. But if you use the <code>--contains</code> option, it will find the tag that “contains” the commit, that is the commit I want to find.<label for="fn6"></label><span></span></p>
<p>If the tag is exactly the commit, then it will only return the tag. Otherwise, it will have a suffix that shows:<label for="fn7"></label><span></span></p>
<blockquote>
<p>the number of additional commits on top of the tagged object and the abbreviated object name of the most recent commit.</p>
</blockquote>
<p>I can use <code>sed</code> to strip out the suffix, since I only want the tag name:</p>
<pre><code>git describe --contains &#34;&lt;commit&gt;&#34; | sed &#39;s/~.*//&#39;
</code></pre>
<p>Another way to accomplish this is with <code>git tag --contains</code>:<label for="fn8"></label><span></span><label for="fn9"></label><span></span></p>
<pre><code>git tag --contains &#34;&lt;commit&gt;&#34; --sort=creatordate
</code></pre>
<p>Which will return <em>all</em> of the tags that contain the commit, sorted by their creation date.</p>
<p>Now I have the tag I want, but when was it created? I found a couple techniques that work:</p>
</section>
<section id="Technique-1-git-log--1">
<h2>Technique 1: <code>git log -1</code></h2>
<p><code>git log</code> will display information about the parents of a given commit. But if you use the <code>-1</code> option, it will limit it to <code>1</code> commit, only the one we pass to it. And we can pass a tag to it:<label for="fn10"></label><span></span><label for="fn11"></label><span></span></p>
<pre><code>git log -1 &#34;&lt;tag&gt;&#34;
</code></pre>
<p>This will show the default information about the commit behind the tag.</p>
<p>If I only wanted the date, I could use:</p>
<pre><code>git log -1 --format=%ai &#34;&lt;tag&gt;&#34;
</code></pre>
</section>
<section id="Technique-2-git-for-each-ref">
<h2>Technique 2: <code>git for-each-ref</code></h2>
<p><code>git for-each-ref</code> will iterate over all refs that match a given pattern. It also lets you format information from that ref.<label for="fn12"></label><span></span><label for="fn13"></label><span></span></p>
<p>That pattern can be as specific as a single tag:</p>
<pre><code>git for-each-ref \
  --format=&#34;%(refname:short) | %(creatordate)&#34; \
  &#34;refs/tags/OTP_17.0-rc1&#34;
</code></pre>
<p>I like this one because I can easy generalize a solution to ask other questions. When was every tag released?</p>
<pre><code>git for-each-ref \
  --format=&#34;%(refname:short) | %(creatordate)&#34; \
  &#34;refs/tags&#34;
</code></pre>
<p>By default, it seems to sort alphabetically by <code>refname</code>. If I want them in chronological order, I can add <code>--sort=creatordate</code> on the end.</p>
</section>
<section id="Takeaways">
<h2>Takeaways</h2>
<p>I came out of this expedition with a rich collection of tools that I can use in future spelunking. All of these tools are built into <code>git</code> and have excellent documentation in the <a href="https://git-scm.com/docs">reference manual</a>.</p>
<p>I often read source code in order to get a better understanding of the tools, libraries, and software that I use. These <code>git</code> tools allow me to explore that source code in specific historical context, and understand how codebases evolve and change over time.</p>
</section>
<section id="Bonus-A-Simpler-Search-Method">
<h2>Bonus: A Simpler Search Method</h2>
<p>When I asked about how to find the commit I needed in a Recursers chat, I got more answers after I had already found the commit I was looking for. Here is one that was simpler than <code>git-bisect</code>:<label for="fn14"></label><span></span></p>
<section id="git-log--S">
<h3><code>git log -S</code></h3>
<p>You can use <code>git log -S &#34;&lt;name of function&gt;&#34;</code> to find commits that touch the string <code>&lt;name of function&gt;</code>. I found this didn’t take much longer than <code>git bisect run</code> on the Erlang codebase. And, I didn’t have to find an early “good” commit before searching.</p>
</section>
</section>
</section></div>
  </body>
</html>
