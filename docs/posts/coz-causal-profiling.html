<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/plasma-umass/coz">Original</a>
    <h1>Coz: Causal Profiling</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">by <a href="https://curtsinger.cs.grinnell.edu/" rel="nofollow">Charlie Curtsinger</a> and <a href="https://emeryberger.com" rel="nofollow">Emery Berger</a></p>
<p dir="auto"><a href="https://crates.io/crates/coz" rel="nofollow"><img src="https://camo.githubusercontent.com/5b91112c2004db0e678a56b760165784306d026c93003cbf9f05f7bd728eff8f/68747470733a2f2f696d672e736869656c64732e696f2f6372617465732f642f636f7a3f6c6f676f3d72757374266c696e6b3d68747470732533412532462532466372617465732e696f253246637261746573253246636f7a" alt="Rust Crate downloads" data-canonical-src="https://img.shields.io/crates/d/coz?logo=rust&amp;link=https%3A%2F%2Fcrates.io%2Fcrates%2Fcoz"/></a></p>
<p dir="auto">Coz is a profiler for native code (C/C++/Rust) that unlocks
optimization opportunities missed by traditional profilers. Coz
employs a novel technique called <em>causal profiling</em> that measures
optimization potential. It predicts what the impact of optimizing code
will have on overall throughput or latency.</p>
<p dir="auto">Profiles generated by Coz show the &#34;bang for buck&#34; of optimizing a
line of code in an application. In the below profile, almost every
effort to optimize the performance of this line of code directly leads
to an increase in overall performance, making it an excellent
candidate for optimization efforts.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/plasma-umass/coz/blob/master/example-coz-output.png"><img src="https://github.com/plasma-umass/coz/raw/master/example-coz-output.png" alt="Example Coz profile"/></a></p>
<p dir="auto">Coz&#39;s measurement matches developers&#39; assumptions about profilers: that optimizing highly-ranked code will have the greatest impact on performance. Causal profiling measures optimization potential for serial, parallel, and asynchronous programs without instrumentation of special handling for library calls and concurrency primitives. Instead, a causal profiler uses performance experiments to predict the effect of optimizations. This allows the profiler to establish causality: &#34;optimizing function X will have effect Y,&#34; exactly the measurement developers had assumed they were getting all along.</p>
<p dir="auto">Full details of Coz are available in our paper, <a href="http://arxiv.org/pdf/1608.03676v1.pdf" rel="nofollow">Coz: Finding Code
that Counts with Causal Profiling
(pdf)</a>, SOSP 2015, October 2015
(recipient of a Best Paper Award).</p>
<p dir="auto"><a href="http://www.youtube.com/watch?v=jE0V-p1odPg&amp;t=0m28s" title="Coz presentation at SOSP" rel="nofollow"><img src="https://camo.githubusercontent.com/dfd521596c2690ea1549d6d34dd674cde1649b02350f7d56fc4d018c60a66a7e/687474703a2f2f696d672e796f75747562652e636f6d2f76692f6a4530562d70316f6450672f302e6a7067" alt="Coz presentation at SOSP" data-canonical-src="http://img.youtube.com/vi/jE0V-p1odPg/0.jpg"/></a></p>

<p dir="auto">On Debian and Ubuntu, you can install Coz via apt:</p>
<div dir="auto" data-snippet-clipboard-copy-content="sudo apt install coz-profiler"><pre>sudo apt install coz-profiler</pre></div>
<p dir="auto">An OpenSUSE package was prepared by user
<a href="https://github.com/zethra">@zethra</a> and is available at
<a href="https://build.opensuse.org/package/show/home:zethra/coz-profiler" rel="nofollow">https://build.opensuse.org/package/show/home:zethra/coz-profiler</a>.</p>
<p dir="auto">Coz should work on any modern Linux system (specifically, running
version 2.6.32 or later, with support for the <code>perf_event_open</code> system
call) with a Python 3.x interpreter.</p>

<p dir="auto">By default, Coz works for C, C++, and Rust programs. It has been ported or
has wrappers for several other languages, listed below:</p>
<table>
<thead>
<tr>
<th>Language</th>
<th>Link</th>
</tr>
</thead>
<tbody>
<tr>
<td>Java</td>
<td>JCoz: <a href="https://github.com/Decave/JCoz">https://github.com/Decave/JCoz</a></td>
</tr>
<tr>
<td>Go</td>
<td>Cozgo: <a href="https://github.com/urjitbhatia/cozgo">https://github.com/urjitbhatia/cozgo</a></td>
</tr>
<tr>
<td>Swift</td>
<td>Swift Coz: <a href="https://github.com/funcmike/swift-coz">https://github.com/funcmike/swift-coz</a></td>
</tr>
</tbody>
</table>

<p dir="auto">To build Coz from source, you will need:</p>
<ul dir="auto">
<li>A copy of the source code for this project</li>
<li>A compiler with C++0x support (clang++ or g++)</li>
<li>A Python interpreter (Python 3.x is required)</li>
<li><em>OPTIONAL</em>: for building the profiler viewer, you need NodeJS and npm -- <code>sudo apt-get install nodejs npm</code></li>
</ul>
<p dir="auto">Once you have all dependencies in place, build Coz with CMake. On Debian-based distributions, the following commands should take care of the entire process:</p>
<div dir="auto" data-snippet-clipboard-copy-content="sudo apt-get update
sudo apt-get install libdwarf-dev
sudo apt-get install build-essential cmake docutils-common git python3 pkg-config
git clone https://github.com/antoyo/libelfin &amp;&amp; cd libelfin &amp;&amp; make &amp;&amp; sudo make install &amp;&amp; cd ..
git clone https://github.com/plasma-umass/coz &amp;&amp; cd coz &amp;&amp; cmake . &amp;&amp; make &amp;&amp; sudo make install &amp;&amp; cd .."><pre>sudo apt-get update
sudo apt-get install libdwarf-dev
sudo apt-get install build-essential cmake docutils-common git python3 pkg-config
git clone https://github.com/antoyo/libelfin <span>&amp;&amp;</span> <span>cd</span> libelfin <span>&amp;&amp;</span> make <span>&amp;&amp;</span> sudo make install <span>&amp;&amp;</span> <span>cd</span> ..
git clone https://github.com/plasma-umass/coz <span>&amp;&amp;</span> <span>cd</span> coz <span>&amp;&amp;</span> cmake <span>.</span> <span>&amp;&amp;</span> make <span>&amp;&amp;</span> sudo make install <span>&amp;&amp;</span> <span>cd</span> ..</pre></div>
<p dir="auto">Next, you need to change the &#34;perf_event_paranoia&#34; level so Coz can run.</p>
<div dir="auto" data-snippet-clipboard-copy-content="sudo sh -c &#39;echo 1 &gt;/proc/sys/kernel/perf_event_paranoid&#39;"><pre>sudo sh -c <span><span>&#39;</span>echo 1 &gt;/proc/sys/kernel/perf_event_paranoid<span>&#39;</span></span></pre></div>
<p dir="auto">Now you can test Coz. Build the benchmark suite and run one of the benchmarks (the SQLite3 benchmark takes a while to build).</p>
<div dir="auto" data-snippet-clipboard-copy-content="sudo apt-get install libbz2-dev libsqlite3-dev
cd coz/benchmarks &amp;&amp; cmake . &amp;&amp; make &amp;&amp; cd ../..
coz run --- ./coz/benchmarks/toy/toy"><pre>sudo apt-get install libbz2-dev libsqlite3-dev
<span>cd</span> coz/benchmarks <span>&amp;&amp;</span> cmake <span>.</span> <span>&amp;&amp;</span> make <span>&amp;&amp;</span> <span>cd</span> ../..
coz run --- ./coz/benchmarks/toy/toy</pre></div>
<p dir="auto">Finally, use the Coz viewer to see the results. This command will open up a browser tab, from which you will need to load the file <code>profile.coz</code>.</p>

<p dir="auto">If you are on a remote system, you can open the Coz viewer in your browser: <a href="https://plasma-umass.github.io/coz" rel="nofollow">https://plasma-umass.github.io/coz</a> and then load the file <code>profile.coz</code>, which you will have to transfer to your local machine.</p>
<p dir="auto">(You may need to move the &#34;Minimum Points&#34; slider on the left side to see the results.)</p>

<p dir="auto">Using Coz requires a small amount of setup, but you can jump ahead to the section on the included <a href="#sample-applications">sample applications</a> in this repository if you want to try Coz right away.</p>
<p dir="auto">To run your program with Coz, you will need to build it with debug information (<code>-g -gdwarf-3</code>). You do not need to include debug symbols in the main executable: coz uses the same procedure as <code>gdb</code> to locate debug information for stripped binaries.</p>
<p dir="auto">Once you have your program built with debug information, you can run it with Coz using the command <code>coz run {coz options} --- {program name and arguments}</code>. But, to produce a useful profile you need to decide which part(s) of the application you want to speed up by specifying one or more progress points.</p>

<p dir="auto">Coz departs from conventional profiling by making it possible to view the effect of optimizations on both throughput and latency. To profile throughput, you must specify a progress point. To profile latency, you must specify a pair of progress points.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Throughput Profiling: Specifying Progress Points</h4><a id="user-content-throughput-profiling-specifying-progress-points" aria-label="Permalink: Throughput Profiling: Specifying Progress Points" href="#throughput-profiling-specifying-progress-points"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">To profile throughput you must indicate a line in the code that corresponds to the end of a unit of work. For example, a progress point could be the point at which a transaction concludes, when a web page finishes rendering, or when a query completes. Coz then measures the rate of visits to each progress point to determine any potential optimization&#39;s effect on throughput.</p>
<p dir="auto">To place a progress point, include <code>coz.h</code> (under the <code>include</code> directory in this repository) and add the <code>COZ_PROGRESS</code> macro to at least one line you would like to execute more frequently. Don&#39;t forget to link your program with libdl: use the <code>-ldl</code> option.</p>
<p dir="auto">By default, Coz uses the source file and line number as the name for your progress points. If you use <code>COZ_PROGRESS_NAMED(&#34;name for progress point&#34;)</code> instead, you can provide an informative name for your progress points. This also allows you to mark multiple source locations that correspond to the same progress point.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Latency Profiling: Specifying Progress Points</h4><a id="user-content-latency-profiling-specifying-progress-points" aria-label="Permalink: Latency Profiling: Specifying Progress Points" href="#latency-profiling-specifying-progress-points"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">To profile latency, you must place two progress points that correspond to the start and end of an event of interest, such as when a transaction begins and completes. Simply  mark the beginning of a transaction with the <code>COZ_BEGIN(&#34;transaction name&#34;)</code> macro, and the end with the <code>COZ_END(&#34;transaction name&#34;)</code> macro. Unlike regular progress points, you always need to specify a name for your latency progress points. Don&#39;t forget to link your program with libdl: use the <code>-ldl</code> option.</p>
<p dir="auto">When coz tests a hypothetical optimization it will report the effect of that optimization on the average latency between these two points. Coz can track this information without any knowledge of individual transactions thanks to <a href="https://en.wikipedia.org/wiki/Little%27s_law" rel="nofollow">Little&#39;s Law</a>.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Specifying Progress Points on the Command Line</h3><a id="user-content-specifying-progress-points-on-the-command-line" aria-label="Permalink: Specifying Progress Points on the Command Line" href="#specifying-progress-points-on-the-command-line"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Coz has command line options to specify progress points when profiling the application instead of modifying its source. This feature is currently disabled because it did not work particularly well. Adding support for better command line-specified progress points is planned in the near future.</p>

<p dir="auto">To plot profile results, go to <a href="http://plasma-umass.github.io/coz/" rel="nofollow">http://plasma-umass.github.io/coz/</a> and load your profile. This page also includes several sample profiles from PARSEC benchmarks.</p>

<p dir="auto">The <code>benchmarks</code> directory in this repository includes several small benchmarks with progress points added at appropriate locations. To build and run one of these benchmarks with <code>coz</code>, just browse to <code>benchmarks/{bench name}</code> and type <code>cmake . &amp;&amp; make</code>. These programs may require several runs before coz has enough measurements to generate a useful profile. Once you have profiled these programs for several minutes, go to <a href="http://plasma-umass.github.io/coz/" rel="nofollow">http://plasma-umass.github.io/coz/</a> to load and plot your profile.</p>

<p dir="auto">When you install coz it installs a cmake config file. To add coz to a cmake project simply use the command <code>find_package(coz-profiler)</code>. This will import a target for the library and includes called <code>coz::coz</code> and a target for the coz binary <code>coz::profiler</code>. For guidance on how to use these targets refer to the CMake documentation.</p>

<p dir="auto">Coz currently does not support interpreted or JIT-compiled languages such as Python, Ruby, or JavaScript. Interpreted languages will likely not be supported at any point, but support for JIT-compiled languages that produce debug information could be added in the future.</p>

<p dir="auto">All source code is licensed under the BSD 2-clause license unless otherwise indicated. See LICENSE.md for details.</p>
<p dir="auto">Sample applications (in the <code>benchmarks</code> directory) include several <a href="https://github.com/kozyraki/phoenix">Phoenix</a> programs and <a href="http://compression.ca/pbzip2/" rel="nofollow">pbzip2</a>, which are licensed separately and included with this release for convenience.</p>
</article></div></div>
  </body>
</html>
