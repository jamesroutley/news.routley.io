<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.appsignal.com/2023/09/27/an-introduction-to-litestack-for-ruby-on-rails.html">Original</a>
    <h1>An Introduction to LiteStack for Ruby on Rails</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>In this series of posts, we will look at <strong>LiteStack</strong>, a one-stop-shop solution that hosts and processes all your production data on a single machine. LiteStack (as the name suggests) makes use of SQLite to provide:</p>
<ul>
<li>a database using the <em>LiteDB</em> adapter</li>
<li>an ActiveJob backend (<em>LiteJob</em>)</li>
<li>an ActionCable backend (<em>LiteCable</em>)</li>
<li>an ActiveSupport::Cache store (<em>LiteCache</em>)</li>
</ul>
<p>In this first post, we&#39;ll introduce the basics of LiteStack and set up an example Rails application.</p>
<p>Let&#39;s begin!</p>
<h2 id="an-introduction-to-sqlite">An Introduction to SQLite</h2>
<p><a href="https://www.sqlite.org/index.html">SQLite</a> itself has been the go-to embedded database of many industries for decades. For example, it&#39;s widely used in <a href="https://www.sqlite.org/whentouse.html">native app development, testing environments, caching, and others</a>.</p>
<p>Recently, though, it has attracted a lot of experimentation and extensions. One of the most popular extensions is <a href="https://litestream.io/">Litestream</a>, which can recover stream changes to an S3-compatible bucket. This means you get a replica of your production database at a very cheap price point and can recover from failure anytime.</p>
<p>Incidentally, this has made using SQLite as a production database for your Rails app a feasible option. Combined with a full-fledged development stack like LiteStack, it promises to make apps hosted on a single machine a reality. We are here to test this hypothesis and point out any obstacles in the way.</p>
<p>To do this, we need an example app that&#39;s complex enough to surface potential difficulties, but simple enough to fit this series.</p>
<h2 id="our-example-rails-application">Our Example Rails Application</h2>
<p>We will write an app that transforms children&#39;s drawings using <a href="https://replicate.com/cjwbw/stable-diffusion-img2img-v2.1">StableDiffusion on replicate.com</a>.</p>
<p>As an example, here&#39;s a cute teddy bear drawn by my daughter, with a couple of StableDiffusion interpretations:</p>
<figure><p><img alt="Teddybears" loading="lazy" width="1320" height="719" decoding="async" data-nimg="1" srcset="/_next/image?url=%2Fimages%2Fblog%2F2023-09%2Fteddybears.png&amp;w=1920&amp;q=75 1x, /_next/image?url=%2Fimages%2Fblog%2F2023-09%2Fteddybears.png&amp;w=3840&amp;q=75 2x" src="https://blog.appsignal.com/_next/image?url=%2Fimages%2Fblog%2F2023-09%2Fteddybears.png&amp;w=3840&amp;q=75"/></p></figure>
<p>As a rough sketch, our app will cover the following steps:</p>
<ol>
<li>The user uploads an image with a textual prompt (we&#39;ll show some advanced SQLite techniques here).</li>
<li>The user chooses an image style (e.g., &#34;cartoon&#34;, &#34;oil painting&#34;, &#34;photorealistic&#34;, &#34;3D rendering&#34;).</li>
<li>The processing happens in the background (this kicks off a <em>LiteJob</em>-powered job).</li>
<li>While the processing is underway, we show a placeholder image and update the logs sent over by the server. Once completed, we update it to show the actual image. This allows us to explore <em>LiteCable</em> as we replace the image via Turbo Streams.</li>
<li>We store the image prediction.</li>
<li>We use <em>LiteCache</em> to wrap computationally costly views.</li>
</ol>
<p>These steps provide a scaffold for this series. The remainder of this post, though, will be concerned with setting up the app.</p>
<p>We start by creating a new Rails app called <em>skAItch</em>, using esbuild as our JavaScript bundler and SASS as the CSS preprocessor:</p>

<h2 id="install-litestack">Install LiteStack</h2>
<p>Next, we install <a href="https://github.com/oldmoe/litestack">LiteStack</a> using the shipped generator:</p>

<p>After that is done, we complete the setup and start the development server:</p>

<h2 id="authentication-and-tenants">Authentication and Tenants</h2>
<p>Subsequently, we need a way to authenticate our users to associate prompts with them. Rather than using an incumbent like Devise, I chose to use a different approach. The <a href="https://github.com/lazaronixon/authentication-zero">authentication-zero gem</a> can flexibly generate an authentication system, as opposed to including it as an engine. Conveniently, it comes with options such as:</p>
<ul>
<li>authentication by token (for APIs)</li>
<li>two-factor auth</li>
<li>multitenancy</li>
<li>rate limiting</li>
<li>an OmniAuth interface</li>
<li>passwordless auth</li>
</ul>
<p>I&#39;ve chosen to add the <code>--tenantable</code> option because it&#39;s always a good idea to automatically scope your database records to accounts. Authentication-zero provides this with the <code>AccountScoped</code> model concern.</p>

<p>Let&#39;s add a first user via database seeds:</p>


<h2 id="prompt-scaffold">Prompt Scaffold</h2>
<p>Now it&#39;s time to start writing our actual application logic. We start by defining the central model of our app: the <code>Prompt</code>.</p>
<p>We want our prompt to have a title, a description, and a reference to the account that created it. Furthermore, to test SQLite&#39;s &#34;file system&#34; capabilities, we would like it to store the prompt image in binary form:</p>

<p>A <code>prompts</code> resources entry is also added to <code>config/routes.rb</code>. Note that authentication-zero adds a <code>before_action</code> authenticating the user to <code>ApplicationController</code> by default.</p>

<p>Furthermore, we include the <code>AccountScoped</code> concern in our Prompt model, which allows us to scope the stored records by logged-in account. We also validate that a prompt title and image are present.</p>

<p>As the final step to enable multitenancy, we have to connect the prompt to an account when it is created. We do this in the <code>PromptsController</code>:</p>

<h2 id="connecting-our-rails-application-to-replicatecom">Connecting our Rails Application to Replicate.com</h2>
<p><a href="https://replicate.com/">Replicate.com</a> is a leading platform for running AI predictions on high-performance graphics cards. It features an <a href="https://replicate.com/docs/reference/http">API</a> to create predictions, train and store models, etc. To use it, you have to obtain an API token from <a href="https://replicate.com/account/api-tokens">https://replicate.com/account/api-tokens</a>.</p>
<p><strong>Note:</strong> Running predictions on Replicate is subject to a charge.</p>
<p>Fortunately for us, there are official and unofficial clients that interface with the API. One such wrapper is the <a href="https://github.com/dreamingtulpa/replicate-rails">replicate-rails</a> gem, which we will install now:</p>


<p>To store our API key securely, we are going to use Rails credentials:</p>


<p>Editing and saving this file will encrypt your credentials, and it can only be opened by providing the correct <code>RAILS_MASTER_KEY</code>.</p>
<p>Now, we have to put it to use. As suggested in replicate-rails&#39; README, we authenticate against Replicate in an initializer. We also define a webhook handler which (in our case) is just a class put into the same file. Note that I added a <code>binding.irb</code> breakpoint here for a first test of our functionality.</p>

<p>Replicate-rails also ships a default webhook controller, which calls the above handler. We only have to mount it in our <code>config/routes.rb</code>:</p>

<p>To test the webhook locally, you have to set up a tunnel, for example, with <a href="https://ngrok.com/">Ngrok</a>. The steps to set it up are beyond the scope of this article, but it&#39;s pretty simple. Please refer to the <a href="https://ngrok.com/docs">Ngrok docs</a>.</p>
<p>You do, however, have to tell Rails that it may listen to your tunnel&#39;s URL. To enable this, add it to the <code>allowed_hosts</code> in <code>config/application.rb</code>:</p>

<h2 id="running-a-prediction">Running a Prediction</h2>
<p>Now we&#39;ll test creating a prediction. The only missing bit is to hook it up in our <code>PromptsController</code>. The general workflow is as follows:</p>
<ol>
<li>We retrieve a model (in our case, the <code>stable-diffusion-img2img</code> model) from Replicate.</li>
<li>We grab a specific version (in our case, the latest one) to run the prediction against.</li>
<li>We run the prediction, specifying:<!-- -->
<ul>
<li>A text prompt describing the image (in our case, our prompt&#39;s title).</li>
<li>An image prompt that we have to provide as a Base64-encoded Data URL.</li>
<li>A webhook to ping when the prediction completes (we point it at the webhook route provided by replicate-rails).</li>
</ul>
</li>
</ol>

<p>If you go to <a href="https://YOUR_NGROK_URL/prompts/new">https://YOUR_NGROK_URL/prompts/new</a> and upload an image together with a title, you will now trigger a prediction. When done, it will call back via the provided webhook. Because we set a <code>binding.irb</code> breakpoint there, the controller action stops in a REPL, and we can take a look around:</p>

<p>As we can see, our first run of an image-to-image generation succeeded. The prediction model returns a URL to the created image, which we will want to store locally (they are deleted at Replicate periodically). We will take a closer look at this next time.</p>
<h2 id="up-next-litedb-deep-dive">Up Next: LiteDB Deep Dive</h2>
<p>In this opening post, we introduced the LiteStack environment as an interesting alternative to host all of your Rails app&#39;s components on a single machine. We have furthermore set up an example app that talks to Replicate.com for AI image generation.</p>
<p>In the next part of this series, we will explore the first and central element of LiteStack — <em>LiteDB</em> — in more depth. We will look at some traits that make it uniquely powerful, common pitfalls, limitations, and tradeoffs.</p>
<p>Until then, happy coding!</p>
<p><strong>P.S. If you&#39;d like to read Ruby Magic posts as soon as they get off the press, <a href="https://blog.appsignal.com/ruby-magic">subscribe to our Ruby Magic newsletter and never miss a single post</a>!</strong></p></div></div></div>
  </body>
</html>
