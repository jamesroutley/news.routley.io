<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://architecturenotes.co/datasette-simon-willison/">Original</a>
    <h1>Architecture Notes: Datasette</h1>
    
    <div id="readability-page-1" class="page"><article>
		<div>
				
		<p>I am very happy to introduce our first Arc Note with Simon Willison who is going to be talking about Datasette, SQLite and the challenges of building a server-side web application that also works in both Electron and WebAssembly. Its a great read <strong>‚Äî</strong> I hope you enjoy and hopefully learn a little something. </p><div><p>üí°</p><p>Simon is the creator of Datasette and co-creator of Django web framework. Formerly he was a JSK journalism fellow at Stanford, and prior to that an Engineering Director at Eventbrite.</p></div><h3 id="who-are-you"></h3><p>I‚Äôve been building web applications since the first dot-com boom back in 1999. I started out in the very early days of online gaming, building community websites and running a news site (we didn‚Äôt call them blogs yet) and online league for the Half-Life mod Team Fortress Classic.</p><p>During my computer science degree I took a ‚Äúyear in industry‚Äù paid internship program in Lawrence, Kansas where I worked with Adrian Holovaty to build a CMS for a local newspaper using Python - this later became the open source Django web framework.</p><p>I later worked for the Guardian newspaper in London building tools for data journalism, including <a href="https://www.theguardian.com/politics/2009/jun/18/mps-expenses-crowdsourcing-app">a crowdsourcing application</a> for analyzing UK Members of Parliament expense claims.</p><p>After the Guardian I went on an extended honeymoon with my partner Natalie Downe during which we <a href="https://blog.natbat.net/post/61658401806/lanyrd-from-idea-to-exit">accidentally started a startup</a> together. This was Lanyrd, a website to help people find conferences to attend and build a profile of events they had attended and spoken at. We took Lanyrd through Y Combinator, raised a seed round and three years later sold the company to Eventbrite and moved from London to San Francisco with our team.</p><p>My first role at Eventbrite was as the engineering director for the architecture team, helping to solve scaling problems, shepherding Eventbrite‚Äôs adoption of microservices and migrating team development environments to Docker. I later took on a R&amp;D role exploring new ways to help users discover events relevant to them.</p><p>My true passion remained data journalism. I originally started <a href="https://datasette.io/">Datasette</a> as a side-project, exploring data publishing challenges I had wanted to solve years earlier at the Guardian. I left Eventbrite to <a href="https://simonwillison.net/2019/Sep/10/jsk-fellowship/">participate in the JSK journalism fellowship program</a> at Stanford, which afforded me a full year to dedicate to my open source data journalism projects. I‚Äôve been working full-time on Datasette and related projects ever since.</p><h3 id="what-are-you-building"></h3><p><a href="https://datasette.io/">Datasette</a> is a tool for exploring and publishing data. The original goal of the project was to make it easy and inexpensive to publish structured datasets online. This was inspired by my time at the Guardian, where we launched a Data Blog to publish the raw data behind our stories. We used Google Sheets to share data there, but I always felt there should be a more powerful and flexible way to share data.</p><p>I want to encourage more news organizations - and other groups that control and gather useful data - to publish their databases. As such, I wanted a system that could be run as cheaply as possible while providing maximum power and flexibility to people trying to make use of that data.</p><p>My breakthrough was the realization that read-only data packaged as a SQLite database could be deployed to inexpensive serverless hosting, where it could scale from zero (costing nothing) up to handling an unlimited amount of inbound traffic.</p><p>Since releasing the first version nearly five years ago, my ambitions have expanded. I added support for writable databases via plugin hooks a few releases ago, and I‚Äôm now starting to build out features that let people build databases directly in Datasette in addition to exploring and publishing databases that already exist.</p><h2 id="high-level-architecture-design">High Level Architecture Design</h2><figure><img src="https://architecturenotes.co/content/images/2022/05/Datasette-sections-02.jpg" alt="" loading="lazy" width="850" height="997" srcset="https://architecturenotes.co/content/images/size/w600/2022/05/Datasette-sections-02.jpg 600w, https://architecturenotes.co/content/images/2022/05/Datasette-sections-02.jpg 850w"/></figure><ul><li><strong><strong><strong>Datasette</strong> </strong></strong>is the core Python web application, distributed as a Python package with a CLI interface for running a server. This can be run locally but is also designed to be deployed to hosting providers such as Google Cloud Run, Heroku, Fly, Vercel and more.</li><li><strong>Datasette Desktop</strong> packages up Desktop inside an Electron desktop application for macOS, primarily to help users who aren‚Äôt familiar with CLI applications.</li><li><strong><strong><strong>Datasette Lite</strong> </strong></strong>uses Pyodide to run the full Datasette Python application entirely in the user‚Äôs browser. This helps people use Datasette when they do not have the capacity to host a Python server somewhere.</li></ul><p>Datasette is a web application written in Python. The core application ships as a Python package which bundles its own web server, so you can start Datasette running on localhost like this:</p><pre><code>pip install datasette # Or ‚Äúbrew install datasette‚Äù
datasette myfile.db
</code></pre><p>This will start a server running on port 8001 serving the default Datasette application.</p><div><p>üí°</p><p>If you want to join the community of just under 5K strong, get a weekly newsletter on software architecture, technology deep dives, and future Arc Notes from the companies you use every day. Subscribe below.¬†</p></div><!--kg-card-begin: html--><div>
	<div>
		
		<p><small>Processing your application</small>
			<small>Please check your inbox and click the link to confirm your subscription.</small>
			<small>There was an error sending the email</small>
		</p>
	</div>
</div><!--kg-card-end: html--><h3 id="asgi">ASGI</h3><figure><div><div><p><img src="https://architecturenotes.co/content/images/2022/05/Datasette-sections-01.jpg" width="1093" height="803" loading="lazy" alt="" srcset="https://architecturenotes.co/content/images/size/w600/2022/05/Datasette-sections-01.jpg 600w, https://architecturenotes.co/content/images/size/w1000/2022/05/Datasette-sections-01.jpg 1000w, https://architecturenotes.co/content/images/2022/05/Datasette-sections-01.jpg 1093w" sizes="(min-width: 720px) 720px"/></p><p><img src="https://architecturenotes.co/content/images/2022/05/Datasette-sections-05.jpg" width="1123" height="866" loading="lazy" alt="" srcset="https://architecturenotes.co/content/images/size/w600/2022/05/Datasette-sections-05.jpg 600w, https://architecturenotes.co/content/images/size/w1000/2022/05/Datasette-sections-05.jpg 1000w, https://architecturenotes.co/content/images/2022/05/Datasette-sections-05.jpg 1123w" sizes="(min-width: 720px) 720px"/></p></div></div></figure><p>Datasette is built using ASGI. <a href="https://asgi.readthedocs.io/">ASGI</a> is a modern standard for interfacing between web servers and Python applications, designed by Andrew Godwin for the Django project as an asynchronous alternative to WSGI.</p><div data-kg-toggle-state="close"><div><h4>Little Primer on GIL and Synchronous Python</h4></div><p>The Python Global Interpreter Lock or <a href="https://wiki.python.org/moin/GlobalInterpreterLock">GIL</a>, in simple words, is a mutex (or a lock) that allows only one thread to hold the control of the Python interpreter.</p></div><figure><img src="https://architecturenotes.co/content/images/2022/05/Datasette-sections-04.jpg" alt="" loading="lazy" width="1133" height="670" srcset="https://architecturenotes.co/content/images/size/w600/2022/05/Datasette-sections-04.jpg 600w, https://architecturenotes.co/content/images/size/w1000/2022/05/Datasette-sections-04.jpg 1000w, https://architecturenotes.co/content/images/2022/05/Datasette-sections-04.jpg 1133w"/></figure><p>Datasette bundles the <a href="https://www.uvicorn.org/">Uvicorn</a> ASGI server for running on localhost, but it can be hosted by any platform that speaks ASGI: Datasette running on AWS Lambda via Vercel (enabled by the <a href="https://datasette.io/plugins/datasette-publish-vercel">datasette-publish-vercel plugin</a>) exposes the ASGI application directly, skipping the Uvicorn server.</p><p>One benefit of building on top of ASGI is that Datasette can integrate with ASGI middleware. Datasette recently <a href="https://simonwillison.net/2022/Apr/27/parallel-queries/#datasette-gzip">grew gzip support</a> using an ASGI middleware class originally written for Starlette.</p><h3 id="sqlite">SQLite</h3><figure><img src="https://architecturenotes.co/content/images/2022/05/Datasette-sections-08.jpg" alt="" loading="lazy" width="1142" height="605" srcset="https://architecturenotes.co/content/images/size/w600/2022/05/Datasette-sections-08.jpg 600w, https://architecturenotes.co/content/images/size/w1000/2022/05/Datasette-sections-08.jpg 1000w, https://architecturenotes.co/content/images/2022/05/Datasette-sections-08.jpg 1142w"/></figure><p><a href="https://www.sqlite.org/">SQLite</a> is key to the design of Datasette. Unlike commonly used databases such as MySQL or PostgreSQL, SQLite doesn‚Äôt require running an additional database server: a SQLite database is a file, and the SQLite library can be used to directly access and query the data in that file.<br/></p><p><a href="https://www.sqlite.org/whentouse.html">Appropriate Uses For SQLite</a> explains:</p><blockquote>SQLite does not compete with client/server databases. SQLite competes with<a href="http://man.he.net/man3/fopen"> fopen()</a>.</blockquote><p>SQLite is often underestimated by developers. It provides a modern, extremely fast and extremely well tested relational database engine, and it comes bundled as part of ¬†Python in the sqlite3 standard library module. It effortlessly handles many GBs of data and includes powerful features like JSON support and full-text search. </p><p>Importantly, a SQLite database is contained in a single binary file. This makes them easy to copy, share and upload to hosting providers. The cognitive overhead involved in working with SQLite databases is tiny: create or download a .db file and you&#39;re ready to go.</p><figure><img src="https://architecturenotes.co/content/images/2022/05/Datasette-sections-09.jpg" alt="" loading="lazy" width="924" height="455" srcset="https://architecturenotes.co/content/images/size/w600/2022/05/Datasette-sections-09.jpg 600w, https://architecturenotes.co/content/images/2022/05/Datasette-sections-09.jpg 924w" sizes="(min-width: 720px) 720px"/></figure><p>SQLite‚Äôs single biggest limitation involves concurrent writes: only one process is allowed to write to a SQLite database at a time.</p><p>Since most SQLite writes complete in just a few microseconds this limitation isn&#39;t actually much of a problem for real-world applications. Datasette implements an in-Python-memory queue for write operators to ensure they are applied to the database without overlapping each other.</p><h3 id="plugins">Plugins</h3><p>Plugins are a crucial piece of the overall Datasette vision. They can extend Datasette‚Äôs core functionality with additional features, and there are already more than 80 of them listed in <a href="https://datasette.io/plugins">the plugins directory</a>.<br/></p><p>Plugins can be used for a wide variety of things:</p><ul><li>Visualization tools, such as <a href="https://datasette.io/plugins/datasette-cluster-map">datasette-cluster-map</a> for maps or <a href="https://datasette.io/plugins/datasette-vega">datasette-vega</a> for charts</li><li>Authentication: <a href="https://datasette.io/plugins/datasette-auth-passwords">datasette-auth-passwords</a> adds password protection, while <a href="https://datasette.io/plugins/datasette-auth-github">datasette-auth-github</a> and <a href="https://datasette.io/plugins/datasette-auth0">datasette-auth0</a> provide integration with SSO services</li><li>Additional output formats: <a href="https://datasette.io/plugins/datasette-geojson">datasette-geojson</a> can output data as GeoJSON, <a href="https://datasette.io/plugins/datasette-atom">datasette-atom</a> provides Atom feeds and <a href="https://datasette.io/plugins/datasette-ics">datasette-ics</a> can output data as a subscribable calendar feed</li><li>Adding entirely new routes to the application: <a href="https://datasette.io/plugins/datasette-graphql">datasette-graphql</a> adds a <code>/graphql</code> endpoint speaking the GraphQL query language</li></ul><p>The goal is for there to eventually be hundreds of plugins covering every possible form of visualization or data manipulation that users might need for their projects.</p><p>Plugins have a major impact on Datasette‚Äôs architecture. Designing plugin hooks forces me to think extremely hard about the design of different aspects of Datasette. I‚Äôm increasingly moving core pieces of Datasette‚Äôs functionality to use the same hook mechanism as the plugins.</p><p>Designing these hooks is really hard! Over time I‚Äôve found that it‚Äôs crucial to avoid the temptation to add a hook until you have at least two (and ideally more) potential plugins in mind that can use it. One of the main reasons I haven‚Äôt shipped a 1.0 release of Datasette yet is the pressure to make sure the plugin hooks are designed right, since future breaking changes to them would require a major version bump and I‚Äôm hoping to provide as much stability as possible.</p><p>Plugins also allow me to try out wild ideas without risk of over-complicating Datasette‚Äôs core. I started building <a href="https://datasette.io/plugins/datasette-graphql">datasette-graphql</a> as a GraphQL skeptic - I thought SQL was a better querying language, and wanted to prove that I was right. Building the plugin convinced me otherwise - it turns out GraphQL queries excel at retrieving deeply nested structures, which are much harder to achieve using regular SQL. This can result in many N+1 SQL query patterns under the hood, but SQLite is uniquely well suited to handling these because <a href="https://www.sqlite.org/np1queryprob.html">Many Small Queries Are Efficient In SQLite</a>.</p><p>Having a risk-free way to try out new ideas is a huge productivity and motivational boost for the overall project.</p><h3 id="supporting-arbitrary-sql-queries"></h3><p>Datasette allows end users to execute their own arbitrary SQL queries against the database, <a href="https://congress-legislators.datasettes.com/legislators?sql=select%0D%0A++*%0D%0Afrom%0D%0A++legislators%0D%0Awhere%0D%0A++%22bio_birthday%22+like+%3Ap0&amp;p0=198%25">for example this one</a>. This is potentially a very dangerous feature - in most web applications this would be classed as <a href="https://owasp.org/www-community/attacks/SQL_Injection">SQL injection</a>, a serious class of security vulnerability!</p><div data-kg-toggle-state="close"><p>A SQL injection is a security threat that allows an attacker to manipulate the SQL queries that the application sends to the database. That way, the attacker might access data that they aren‚Äôt authorized to see, such as other users‚Äô data. Worse yet is the scenario in which the attacker can get write privileges to the database. They can then update or delete data, causing serious and lasting damages.<br/></p></div><p>In addition to preventing attackers from modifying data, Datasette also needs to protect against malicious long-running queries that could exhaust server resources.</p><p>Datasette takes several steps to enable this in a safe way:</p><ol><li>Datasette encourages people to only publish the subset of their data that they want to be available to their users. If you don‚Äôt include any private data in your Datasette instance you don‚Äôt need to worry about it being selected by a query.</li><li>SQLite database connections are opened using immutable mode (for DBs guaranteed not to change) or read-only mode (for databases that may be updated by other processes). This disallows any write queries that might make it to the connection somehow.</li><li>Datasette rejects any queries that are not SELECT queries, based on <a href="https://github.com/simonw/datasette/blob/280ff372ab30df244f6c54f6f3002da57334b3d7/datasette/utils/__init__.py#L208-L215">an allow-list</a> of regular expressions.</li><li>Queries are executed with a time limit. This cancels any query with an error if it takes longer than a specific limit - one second by default, but this can be customized by the Datasette administrator.</li></ol><p>The time limit mechanism uses the sqlite3 <a href="https://docs.python.org/3/library/sqlite3.html#sqlite3.Connection.set_progress_handler"><code>set_progress_handler()</code></a> method. This can be used to run a custom Python function to run after every N instructions executed by the SQLite virtual machine. Datasette‚Äôs <a href="https://github.com/simonw/datasette/blob/280ff372ab30df244f6c54f6f3002da57334b3d7/datasette/utils/__init__.py#L181-L201">custom handler</a> checks how long the query has been running and terminates it if it has exceeded the time limit.</p><p>Time limits are used in other places too. Datasette displays <a href="https://docs.datasette.io/en/stable/facets.html#suggested-facets">suggested facets</a> showing columns that could be interesting to facet by, based on checking if that column has a unique value count in a specific range.</p><p>These suggestion queries are executed optimistically against each column in the table with a lower time limit of just 50ms. If the query takes longer than that it is canceled and the column is not considered as a suggested facet. This is necessary because the suggested queries are more of a cosmetic enhancement - in a table with 20 columns and 2 million rows calculating these suggestions could take 20 seconds using the default 1s time limit!</p><p>Users of the Datasette JSON API can use this optimistic time limit pattern to build their own features, by appending <a href="https://docs.datasette.io/en/stable/json_api.html#special-json-arguments">?_timelimit=5</a> to the query string (<a href="https://global-power-plants.datasettes.com/global-power-plants.json?sql=select+*+from+[global-power-plants]+where+%22country_long%22+%3D+%27United+Kingdom%27&amp;_timelimit=1">example</a>).</p><p>The ability to run arbitrary SQL queries can be disabled by Datasette administrators using <a href="https://docs.datasette.io/en/stable/authentication.html#execute-sql">the permissions system</a>.</p><h3 id="asyncio-threading-and-database-connections"></h3><figure><img src="https://architecturenotes.co/content/images/2022/05/Datasette-sections-06.jpg" alt="" loading="lazy" width="969" height="890" srcset="https://architecturenotes.co/content/images/size/w600/2022/05/Datasette-sections-06.jpg 600w, https://architecturenotes.co/content/images/2022/05/Datasette-sections-06.jpg 969w"/></figure><p>I decided to build Datasette on top of the new asyncio mechanism introduced in Python 3 right from the start, partly as a learning exercise and partly because I hoped that doing so would allow me to handle more parallel connections and give me options for clever integrations with external systems.</p><p>With hindsight, it‚Äôs not clear to me that those benefits have really proven themselves. I still enjoy the asyncio paradigm but I‚Äôm not confident that it has given me any huge wins for this project over writing traditional non-asyncio code.</p><p>The biggest problem here is that Python currently lacks a way of performing truly asynchronous queries against a SQLite database.</p><p>Since the SQLite querying methods are all blocking, the safe way to query SQLite from an asyncio application is via threads. Libraries such as <a href="https://github.com/omnilib/aiosqlite">aiosqlite</a> use threads under the hood.</p><p>There isn‚Äôt yet a SQLite alternative to <a href="https://github.com/MagicStack/asyncpg">asyncpg</a> for PostgreSQL, which provides true asynchronous querying.</p><p>Datasette runs SQL read queries in a thread <a href="https://github.com/simonw/datasette/blob/280ff372ab30df244f6c54f6f3002da57334b3d7/datasette/database.py#L207-L209">using <code>asyncio.get_event_loop().run_in_executor()</code></a> where the executor is defined <a href="https://github.com/simonw/datasette/blob/280ff372ab30df244f6c54f6f3002da57334b3d7/datasette/app.py#L294-L296">here</a>.</p><p>Each of these worker threads has a ‚Äúconnections‚Äù thread local, with a connection object for each attached database. This means that if you have 5 attached database files you‚Äôll end up with 15 total connections - 3 read connections for each. I haven‚Äôt yet done the research to figure out the optimal configuration here.</p><p>Write queries work slightly differently. SQLite requires that only a single connection writes to a database at any one time, so Datasette maintains a dedicated thread wrapping a single write connection for each database that accepts writes.</p><p>Writes are then sent to that thread via a queue, using an open source library called <a href="https://pypi.org/project/janus/">Janus</a> which provides a queue that can bridge the gap between the asyncio and threaded Python worlds.</p><p>New write operations are added to that queue from the main Datasette asyncio thread. The write thread reads from the queue, executes the writes in turn and places any result back on a reply queue. The calling code can opt to block awaiting that response in asyncio land, or can fire-and-forget the query and move on without waiting for it to complete.</p><p>Here‚Äôs <a href="https://github.com/simonw/datasette/blob/280ff372ab30df244f6c54f6f3002da57334b3d7/datasette/database.py#L139-L188">the code</a> for that. I wrote more about this in <a href="https://simonwillison.net/2020/Feb/26/weeknotes-datasette-writes/">Weeknotes: Datasette writes</a>.</p><h3 id="deploying-datasette-with-%E2%80%9Cdatasette-publish%E2%80%9D-and-baked-data">Deploying Datasette with ‚Äúdatasette publish‚Äù and Baked Data</h3><p>I want people to publish their data using Datasette. Hosting web applications is still way harder than it should be, so I&#39;ve invested a lot of effort in making deploying Datasette as easy as possible.</p><p>The Datasette CLI tool includes a ‚Äúpublish‚Äù command which can be used to deploy Datasette along with a database to a variety of different hosting providers, powered by the <a href="https://docs.datasette.io/en/stable/plugin_hooks.html#publish-subcommand-publish">publish_subcommand</a> plugin hook.</p><p>By default this can be published to Google Cloud Run and Heroku. If you have a database file called legislators.db - and you&#39;ve previously installed and configured the Heroku or Google Cloud CLI tools - you can deploy it to Cloud Run using the following:<br/></p><pre><code>datasette publish cloudrun legislators.db --service=congress-legislators</code></pre><p>Or for Heroku:</p><pre><code>datasette publish heroku mydatabase.db -n congress-legislators</code></pre><p>You can also deploy directly to <a href="https://vercel.com/">Vercel</a> or <a href="https://fly.io/">Fly.io</a> if you first install the <a href="https://datasette.io/plugins/datasette-publish-vercel">datasette-publish-vercel</a> or <a href="https://datasette.io/plugins/datasette-publish-fl">datasette-publish-fly</a> plugins.</p><p>All four of these deployment mechanisms use the same trick: they treat the SQLite database file as a binary asset to be applied along with the Datasette application. Fly and Cloud Run both run Docker images, so the scripts build a Docker image that bakes the database in with the code. Vercel and Heroku use slightly different mechanisms - a shim around AWS Lambda functions in the case of Vercel and a <a href="https://devcenter.heroku.com/articles/buildpacks">buildpack</a> for Heroku - but they both also bundle the database file as part of the deploy.</p><h3 id="datasette-desktopdatasette-in-electron"></h3><p>I want people to be able to run Datasette on their own laptops. My target users are people who are data literate - they understand rows and columns and maybe work with data professionally - but are not necessarily software engineers themselves.</p><p>Telling people to install Python (often after first installing Homebrew) and learn to operate ‚Äúpip‚Äù just so they can use my software is an intolerable level of friction!</p><p>Last year I did a research spike to see if I could get Datasette to work as an installable desktop application. I chose Electron for this, since Datasette is already a web application and my hope was that I could wrap it in an Electron shell with as few changes to the core application as possible.</p><p>The research spike was a success, and I developed it into a full supported product which I called <a href="https://datasette.io/desktop">Datasette Desktop</a>.</p><p>When you install and run Datasette Desktop, a native application window opens running the Datasette interface. macOS menu items provide options for opening SQLite databases or opening CSV files, plus a way to search for and install plugins.</p><p>There are a lot of moving parts needed to make this happen. The biggest challenge here was to figure out how to include a full Python environment with an installable desktop application.</p><p>I couldn‚Äôt guarantee that the user would already have Python installed, and I didn‚Äôt want to have to walk them through that installation process.</p><p>I also needed to be confident that Datasette Desktop would not conflict with any existing Python installations they had and make the <a href="https://xkcd.com/1987/">XKCD 1987 situation</a> even worse for them!</p><figure><img src="https://architecturenotes.co/content/images/2022/05/python_environment_2x.png" alt="" loading="lazy" width="983" height="974" srcset="https://architecturenotes.co/content/images/size/w600/2022/05/python_environment_2x.png 600w, https://architecturenotes.co/content/images/2022/05/python_environment_2x.png 983w"/></figure><p>Then I found <a href="https://github.com/indygreg/python-build-standalone">python-build-standalone</a> by Gregory Szorc, which produces ‚Äúself-contained, highly-portable Python distributions‚Äù. It turned out to be exactly what I needed.</p><p>Datasette Desktop bundles a full standalone copy of Python as part of its macOS application bundle, including the full Python standard library.</p><p>When the application first starts, it uses that Python to create a brand new invisible virtual environment in the ~/.datasette-app/venv directory on the user‚Äôs machine. It then installs the latest Datasette directly into that environment.</p><p>It uses a dedicated virtual environment in order to support the installation of plugins. If the user manages to break the application by installing the wrong plugins they can recover by deleting that folder and restarting the application.</p><p>The Electron application itself is <a href="https://github.com/simonw/datasette-app/blob/0.2.1/main.js">1200 lines of JavaScript</a> which starts the Python Datasette server running, restarts it after a new plugin is installed and configures the various menu options that let the user control how the application behaves.</p><p>A custom Datasette plugin called <a href="https://github.com/simonw/datasette-app-support">datasette-app-support</a> adds some extra API endpoints to Datasette which the Electron JavaScript wrapper can call to activate specific custom actions - importing a CSV file or creating a new blank database for example.</p><p>My top concern in building Datasette Desktop was that I wanted to avoid slowing down the development of Datasette core: I didn‚Äôt want changes I made to the main product to require additional considerations for the macOS application.</p><p>This final design - with any customizations for the app encapsulated exclusively in a plugin - was effective in achieving that goal.</p><h3 id="datasette-litedatasette-in-the-browser">Datasette Lite - Datasette in the browser</h3><figure><img src="https://architecturenotes.co/content/images/2022/05/Datasette-sections-07.jpg" alt="" loading="lazy" width="1334" height="647" srcset="https://architecturenotes.co/content/images/size/w600/2022/05/Datasette-sections-07.jpg 600w, https://architecturenotes.co/content/images/size/w1000/2022/05/Datasette-sections-07.jpg 1000w, https://architecturenotes.co/content/images/2022/05/Datasette-sections-07.jpg 1334w"/></figure><p>My latest attempt at making Datasette as easy to host as possible was to see if it was possible to run it without any server at all, using <a href="https://pyodide.org/">Pyodide</a> - an absolutely incredible distribution of Python that compiles it to WebAssembly so that it can run directly in a user‚Äôs browser.</p><p>I was convinced that Datasette could be run in this way by <a href="https://jupyterlite.readthedocs.io/">JupyterLite</a>, an astonishing system that provides the full Jupyter Lab environment - a complex Python web application - running in the browser.</p><p>As with Datasette Desktop, this started out as a research spike.</p><p>I like to do research like this in a GitHub Issues thread - here‚Äôs <a href="https://github.com/simonw/datasette-lite/issues/1">the thread I used for the prototype</a>. You can follow that for a blow-by-blow account of the different techniques I tried to get this working.</p><p>I ended up figuring out that running Datasette in <a href="https://pyodide.org/en/stable/usage/webworker.html">Pyodide in a web worker</a> was the best strategy. Web workers allow JavaScript web applications to run CPU intensive code in a separate process, such that they won‚Äôt block the main browser UI thread. Running Python in WebAssembly is exactly the kind of thing they are good for!</p><p><a href="https://docs.datasette.io/en/stable/internals.html#datasette-client">datasette.client</a> is an internal API mechanism within Datasette that lets Python code make calls to Datasette‚Äôs HTTP endpoints without having to do a round-trip over the network. I originally built it with the idea that plugins could benefit with the same JSON APIs that Datasette exposes to the outside world, and as a utility for running automated tests.</p><p>It turned out to be exactly what I needed to build Datasette Lite as well.</p><p>Web worker scripts run separately from the visible page, and can‚Äôt directly manipulate the DOM. Instead, they communicate with code running on the page via message passing.</p><p>Datasette Lite instantiates a Datasette object in the web worker, then uses message passing to receive user navigation events and send back the resulting HTML.</p><p>So each time the user clicks a link in the parent window, that URL is sent to the web worker where Datasette generates the full HTML of the page just as if it was running as a regular server-side application.</p><p>The web worker sends that HTML (and the status code and content-type) back to the parent window, which injects it into the page using innerHTML.</p><p>I‚Äôm shocked how well this approach works! The entire implementation is less than 300 lines of JavaScript.</p><p>As with Datasette Desktop, my aim here is to be able to run Datasette with as few modifications as possible - such that I don‚Äôt lose velocity on the core project due to concerns about how changes might impact Datasette Lite.</p><p>How well I‚Äôll be able to keep that is yet to be discovered: I only built Datasette Lite a few weeks ago and it‚Äôs mainly still a tech demo, although it already looks like it will grow to be an important part of the overall Datasette ecosystem.</p><p>If you want to join the community of just under 5K strong, get a weekly newsletter on software architecture, technology deep dives, and future Arc Notes from the companies you use every day. Subscribe below!</p><h3 id="references">References</h3><figure><a href="https://datasette.io/"><div><p>Datasette</p><p>Datasette is a tool for exploring and publishing data. It helps people take data of any shape or size, analyze and explore it, and publish it as an interactive website and accompanying API.</p></div><p><img src="https://datasette.io/static/datasette-card.png" alt=""/></p></a></figure><figure><a href="https://realpython.com/python-gil/"><div><p>What Is the Python Global Interpreter Lock (GIL)? ‚Äì Real Python</p><p>Python‚Äôs Global Interpreter Lock or GIL, in simple words, is a mutex (or a lock) that allows only one thread to hold the control of the Python interpreter at any one time. In this article you‚Äôll learn how the GIL affects the performance of your Python programs.</p><p><img src="https://cdn.realpython.com/static/favicon.68cbf4197b0c.png" alt=""/><span>Real Python</span></p></div><p><img src="https://files.realpython.com/media/What-is-the-Python-Global-Interpreter-Lock-GIL_Watermarked.e8bdd22f0b09.jpg" alt=""/></p></a></figure><figure><a href="https://simonwillison.net/2022/May/4/datasette-lite/"><div><p>Datasette Lite: a server-side Python web application running in a browser</p><p>Datasette Lite is a new way to run Datasette: entirely in a browser, taking advantage of the incredible Pyodide project which provides Python compiled to WebAssembly plus a whole suite ‚Ä¶</p></div><p><img src="https://static.simonwillison.net/static/2022/datasette-lite.jpg" alt=""/></p></a></figure><figure><a href="https://www.sqlite.org/index.html"><div><p>SQLite Home Page</p></div><p><img src="https://www.sqlite.org/images/sqlite370_banner.gif" alt=""/></p></a></figure><figure><a href="https://webassembly.org"><div><p>WebAssembly</p><p><img src="https://webassembly.org/favicon.ico" alt=""/></p></div><p><img src="https://webassembly.org/images/firefox.svg" alt=""/></p></a></figure><figure><a href="https://www.electronjs.org/docs/latest"><div><p>Introduction | Electron</p><p>Welcome to the Electron documentation! If this is your first time developing an Electron app, read through this Getting Started section to get familiar with the basics. Otherwise, feel free to explore our guides and API documentation!</p><p><img src="https://www.electronjs.org/assets/img/favicon.ico" alt=""/><span>Electron</span></p></div><p><img src="https://www.electronjs.org/assets/img/logo.svg" alt=""/></p></a></figure><figure><a href="https://www.uvicorn.org"><div><p>Uvicorn</p><p>The lightning-fast ASGI server.</p><p><img src="https://www.uvicorn.org/assets/images/favicon.png" alt=""/></p></div><p><img src="https://raw.githubusercontent.com/tomchristie/uvicorn/master/docs/uvicorn.png" alt=""/></p></a></figure>
			</div>
</article></div>
  </body>
</html>
