<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://spectrum.ieee.org/the-mythical-non-roboticist">Original</a>
    <h1>The Mythical Non-Roboticist: Wouldn&#39;t it be great if everyone could do robotics?</h1>
    
    <div id="readability-page-1" class="page"><div data-headline="The Mythical Non-Roboticist"><div><p><em>The original version of this post by Benjie Holson was published on Substack <a href="https://generalrobots.substack.com/p/the-mythical-non-roboticist" target="_blank">here</a>, and includes </em><em>Benjie’s original comics as <a href="https://generalrobots.substack.com/" target="_blank">part of his series on robots and startups</a>.</em></p><p>
	I worked on this idea for months before I decided it was a mistake. The second time I heard someone mention it, I thought, “That’s strange, these two groups had the same idea. Maybe I should tell them it didn’t work for us.” The third and fourth time I rolled my eyes and ignored it. The fifth time I heard about a group struggling with this mistake, I decided it was worth a blog post all on its own. I call this idea “The Mythical Non-Roboticist.”<br/></p><hr/><h2>The Mistake</h2><p>
	The idea goes something like this: Programming robots is hard. And there are some people with really arcane skills and PhDs who are really expensive and seem to be required for some reason. Wouldn’t it be nice if we could do <a href="https://spectrum.ieee.org/topic/robotics/">robotics</a> without them?
	<a href="#1"><sup>1</sup></a> What if everyone could do robotics? That would be great, right? We should make a software framework so that non-roboticists can program robots.
</p><p>
	This idea is so close to a correct idea that it’s hard to tell why it doesn’t work out. On the surface, it’s not 
	<em>wrong</em>: All else being equal, it would be good if programming robots was more accessible. The problem is that we don’t have a good recipe for making working robots. So we don’t know how to make that recipe easier to follow. In order to make things simple, people end up removing things that folks might need, because no one knows for sure what’s absolutely required. It’s like saying you want to invent an invisibility cloak and want to be able to make it from materials you can buy from Home Depot. Sure, that would be nice, but if you invented an invisibility cloak that required some mercury and neodymium to manufacture would you toss the recipe?
</p><p>
	In robotics, this mistake is based on a very true and very real observation: Programming robots 
	<em>is</em> super hard. Famously hard. It would be super great if programming robots was easier. The issue is this: Programming robots has two different kinds of hard parts.
</p><h2>Robots are hard because the world is complicated</h2><p><img alt="Illustration of a robot photo stepping down towards a banana peel." data-rm-shortcode-id="2bbe2d6fffcd94831aabc656e3e81b84" data-rm-shortcode-name="rebelmouse-image" data-runner-src="https://spectrum.ieee.org/media-library/illustration-of-a-robot-photo-stepping-down-towards-a-banana-peel.jpg?id=52208546&amp;width=980" height="1563" id="831cc" lazy-loadable="true" src="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20viewBox=&#39;0%200%202500%201563&#39;%3E%3C/svg%3E" width="2500"/><small placeholder="Add Photo Credit...">Moor Studio/Getty Images</small></p><p>
	The first kind of hard part is that robots deal with the real world, imperfectly sensed and imperfectly actuated. Global mutable state is bad programming style because it’s really hard to deal with, but to robot software the entire physical world is global mutable state, and you only get to unreliably observe it and hope your actions approximate what you wanted to achieve. Getting robotics to work at all is often at the very limit of what a person can reason about, and requires the flexibility to employ whatever heuristic might work for your special problem. This is the
	<em> intrinsic </em>complexity of the problem: Robots live in complex worlds, and for every working solution there are millions of solutions that don’t work, and finding the right one is hard, and often very dependent on the task, robot, sensors, and environment.
</p><p>
	Folks look at that challenge, see that it is super hard, and decide that, sure, maybe some fancy roboticist could solve it in one particular scenario, but what about “normal” people? “We should make this possible for non-roboticists” they say. I call these users “Mythical Non-Roboticists” because once they are programming a robot, I feel they 
	<em>become</em> roboticists. Isn’t anyone programming a robot for a purpose a roboticist? Stop gatekeeping, people.
</p><h2>Don’t design for amorphous groups</h2><p>
	I call also them “mythical” because usually the “non-roboticist” implied is a vague, amorphous group. Don’t design for amorphous groups. If you can’t name three real people (that you have talked to) that your API is for, then you are designing for an amorphous group and only amorphous people will like your API.
</p><p>
	And with this hazy group of users in mind (and seeing how difficult everything is), folks think, “Surely we could make this easier for everyone else by papering over these things with simple APIs?”
</p><p>
	No. No you can’t. Stop it.
</p><p>
	You can’t paper over intrinsic complexity with simple APIs because 
	<strong>if your APIs are simple they can’t cover the complexity of the problem</strong>. You will inevitably end up with a beautiful looking API, with calls like “grasp_object” and “approach_person” which demo nicely in a hackathon kickoff but last about 15 minutes of someone actually trying to get some work done. It will turn out that, for their particular application, “grasp_object()” makes 3 or 4 wrong assumptions about “grasp” <em>and</em> “object” and doesn’t work for them at all.
</p><h2>Your users are just as smart as you</h2><p>
	This is made worse by the pervasive assumption that these people are less savvy (read: less intelligent) than the creators of this magical framework.
	<a href="#2"><sup>2</sup></a> That feeling of superiority will cause the designers to cling desperately to their beautiful, simple “grasp_object()”s and resist adding the knobs and arguments needed to cover more use cases and allow the users to customize what they get.
</p><p>
	Ironically this foists a bunch of complexity on to the poor users of the API who have to come up with clever workarounds to get it to work at all.
</p><p><img alt="Illustration of a human and robot hand fitting puzzle pieces together in front of a brain" data-rm-shortcode-id="6bb28ed080b7a6ac68893ee2d530c6da" data-rm-shortcode-name="rebelmouse-image" data-runner-src="https://spectrum.ieee.org/media-library/illustration-of-a-human-and-robot-hand-fitting-puzzle-pieces-together-in-front-of-a-brain.jpg?id=52208580&amp;width=980" height="1250" id="7d7e9" lazy-loadable="true" src="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20viewBox=&#39;0%200%202000%201250&#39;%3E%3C/svg%3E" width="2000"/><small placeholder="Add Photo Credit...">Moor Studio/Getty Images</small></p><p>
	The sad, salty, bitter icing on this cake-of-frustration is that, even if done really well, the goal of this kind of framework would be to expand the group of people who can do the work. And to achieve that, it would sacrifice some performance you can only get by super-specializing your solution to your problem. If we lived in a world where expert roboticists could program robots that worked really well, but there was so much demand for robots that there just wasn’t enough time for those folks to do all the programming, this would be a great solution.
	<a href="#3"><sup>3</sup></a></p><p>
	The obvious truth is that (outside of really constrained environments like manufacturing cells) even the very best collection of real bone-fide, card-carrying roboticists working at the best of their ability struggle to get close to a level of performance that makes the robots commercially viable, even with long timelines and mountains of funding.
	<a href="#4"><sup>4</sup></a> We don’t have <em>any</em> headroom to sacrifice power and effectiveness for ease.
</p><h2>What problem are we solving?</h2><p>
	So should we give up making it easier? Is robotic development available only to a small group of elites with fancy PhDs?
	<a href="#5"><sup>5</sup></a> No to both! I have worked with tons of undergrad interns who have been completely able to do robotics.<a href="#6"><sup>6</sup></a> I myself am mostly self-taught in robot programming.<a href="#7"><sup>7</sup></a> While there is a lot of intrinsic complexity in making robots work, I don’t think there is any more than, say, video game development.
</p><p>
	In robotics, like in all things, experience helps, some things are teachable, and as you master many areas you can see things start to connect together. These skills are not magical or unique to robotics. We are not as special as we like to think we are.
</p><p>
	But what about making programming robots easier? Remember way back at the beginning of the post when I said that there were two different kinds of hard parts? One is the intrinsic complexity of the problem, and that one will be hard no matter what.
	<a href="#8"><sup>8</sup></a> But the second is the incidental complexity, or as I like to call it, the stupid <a href="https://en.wikipedia.org/wiki/BS#:~:text=Bullshit%2C%20a%20phrase%20denoting%20something%20worthless" target="_blank">BS</a> complexity.
</p><h2>Stupid BS Complexity</h2><p>
	Robots are asynchronous, distributed, real-time systems with weird hardware. All of that will be hard to configure for stupid BS reasons. Those drivers need to work in the weird flavor of Linux you want for hard real-time for your controls and getting that all set up will be hard for stupid BS reasons. You are abusing Wi-Fi so you can roam seamlessly without interruption but Linux’s Wi-Fi will not want to do that. Your log files are huge and you have to upload them somewhere so they don’t fill up your robot. You’ll need to integrate with some cloud something or other and deal with its stupid BS.
	<a href="#9"><sup>9</sup></a></p><p><img alt="An illustration of a robot whose head has exploded off " data-rm-shortcode-id="5d8145dc2ed005a011a7b8cd4d21efe1" data-rm-shortcode-name="rebelmouse-image" data-runner-src="https://spectrum.ieee.org/media-library/an-illustration-of-a-robot-whose-head-has-exploded-off.jpg?id=52208747&amp;width=980" height="1250" id="d818f" lazy-loadable="true" src="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20viewBox=&#39;0%200%202000%201250&#39;%3E%3C/svg%3E" width="2000"/><small placeholder="Add Photo Credit...">Moor Studio/Getty Images</small></p><p>
	There is a ton of crap to deal with before you even get to complexity of dealing with 3D rotation, moving reference frames, time synchronization, messaging protocols. Those things have intrinsic complexity (you have to think about when something was observed and how to reason about it as other things have moved) and stupid BS complexity (There’s a weird bug because someone multiplied two transform matrices in the wrong order and now you’re getting an error message that deep in some protocol a quaternion is not normalized. WTF does that mean?)
	<a href="#10"><sup>10</sup></a></p><p>
	One of the biggest challenges of robot programming is wading through the sea of stupid BS you need to wrangle in order to 
	<em>start</em> working on your interesting and challenging robotics problem.
</p><p>
	So a simple heuristic to make good APIs is:
</p><p><em>Design your APIs for someone as smart as you, but less tolerant of stupid BS.</em></p><p>
	That feels universal enough that I’m tempted to call it 
	<strong>Holson’s Law of Tolerable API Design</strong>.
</p><p>
	When you are using tools you’ve made, you know them well enough to know the rough edges and how to avoid them.
</p><p>
	But rough edges are things that have to be held in a programmer’s memory while they are using your system. If you insist on making a robotics framework
	<a href="#11"><sup>11</sup></a>, you should strive to make it as powerful as you can with the least amount of stupid BS. Eradicate incidental complexity everywhere you can. You want to make APIs that have maximum flexibility but good defaults. I like python’s default-argument syntax for this because it means you can write APIs that can be used like:
</p><p><img alt="A screenshot of code" data-rm-shortcode-id="49db54aa7c3e3983bd6e628e2ca3cf3a" data-rm-shortcode-name="rebelmouse-image" data-runner-src="https://spectrum.ieee.org/media-library/a-screenshot-of-code.jpg?id=52208798&amp;width=980" height="237" id="e18db" lazy-loadable="true" src="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20viewBox=&#39;0%200%201392%20237&#39;%3E%3C/svg%3E" width="1392"/></p><p>
	It is possible to have easy things be simple 
	<em>and</em> allow complex things. And please, please, please don’t make condescending APIs. Thanks!
</p><p id="1">
	1. Ironically it is very often the expensive arcane-knowledge-having PhDs who are proposing this.
</p><p id="2">
	2. Why is it always a
	<a href="https://generalrobots.substack.com/p/tech-debt#footnote-anchor-3-118842509" target="_blank"> framework</a>?
</p><p id="3">
	3. The exception that might prove the rule is things like traditional manufacturing-cell automation. That is a place where the solutions exist, but the limit to expanding is set up cost. I’m not an expert in this domain, but I’d worry that physical installation and safety compliance might still dwarf the software programming cost, though.
</p><p id="4">
	4. As I well know from personal experience.
</p><p id="5">
	5. Or non-fancy PhDs for that matter?
</p><p id="6">
	6. I suspect that many bright highschoolers would also be able to do the work. Though, as <a href="https://spectrum.ieee.org/tag/google">Google</a> tends not to hire them, I don’t have good examples.
</p><p id="7">
	7. My schooling was in Mechanical Engineering and I never got a PhD, though my ME classwork did include some programming fundamentals.
</p><p id="8">
	8. Unless we create effective general purpose AI. It feels weird that I have to add that caveat, but the possibility that it’s actually coming for robotics in my lifetime feels much more possible than it did two years ago.
</p><p id="9">
	9. And if you are unlucky, its API was designed by someone who thought they were smarter than their customers.
</p><p id="10">
	10. This particular flavor of BS complexity is why I wrote 
	<a href="https://github.com/robobenjie/posetree" target="_blank">posetree.py</a>. If you do robotics, you should check it out.
</p><p id="11">
	11. Which, judging by the trail of dead robot-framework-companies, is a fraught thing to do.
</p></div></div></div>
  </body>
</html>
