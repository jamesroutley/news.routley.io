<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.keithcirkel.co.uk/css-classes-considered-harmful/">Original</a>
    <h1>CSS Classes Considered Harmful</h1>
    
    <div id="readability-page-1" class="page"><div role="main" aria-label="Main Content"><article><section><p>If you&#39;ve ever so much as peeked behind the curtain of Web user interfaces before, you&#39;ll know what the <code>class</code> property is for. It&#39;s for connecting HTML to CSS, right? I&#39;m here to tell you it&#39;s time for us to stop using it. Class names are an archaic system that serves as a poor proxy for your UI primitives, and worse they&#39;re co-opted in awkward ways which results in combinatorial explosion of weird edge cases. Let&#39;s get into it, first with a boring history lesson which you&#39;ve all heard a million times before:</p><h2>Class is old. Like real old</h2><p>HTML 2.0 (1996) was the first published specification of HTML, and it had a fixed list of tag names, and each tag had a fixed list of allowed attributes. HTML 2.0 documents could not be styled - what was the point? Computers <a href="https://en.wikipedia.org/wiki/Monochrome_monitor">were black and white then, kiddos</a>! The closest thing to customising the style of an HTML 2.0 tag was the <code>&lt;pre&gt;</code> tag which had a <code>width</code> attribute. HTML 3.0 spent a few years being worked on, meanwhile Netscape and Microsoft were adding all sorts of weird extensions such as the beloved <code>&lt;marquee&gt;</code> and <code>&lt;blink&gt;</code> tags. Eventually everyone settled their differences, and HTML 3.2 was born in 1997, which allowed the <code>&lt;body&gt;</code> tag to be &#34;styled&#34; with attributes like <code>bgcolor</code> and <code>text</code>.</p><p><img src="https://www.keithcirkel.co.uk/images/2022-08-25-1.png" alt="A screenshot of a modern browser loading the worlds first website: info.cern.ch"/></p><p>Meanwhile, CSS was being invented as a way to supply some layout and styling to web pages to make them a bit less bland. HTML 3.2 had a short lived history, because that same year, 1997, HTML 4.0 was published, which included mechanisms to support CSS - including the new &#34;Element Identifiers&#34;; the <code>id</code> and <code>class</code> attributes:</p><blockquote><p>To increase the granularity of control over elements, a new attribute has been added to HTML <a href="https://www.w3.org/TR/CSS1/#ref2">[2]</a>: &#39;CLASS&#39;. All elements inside the &#39;BODY&#39; element can be classed, and the class can be addressed in the style sheet <a href="https://www.w3.org/TR/CSS1/#class-as-selector">CSS Level 1</a></p></blockquote><p>These attributes allowed us, with a limited set of tags, to define &#34;classes&#34; of elements which we could style. For example a <code>&lt;div class=&#34;panel&#34;&gt;</code> might look considerably different to a <code>&lt;div class=&#34;card&#34;&gt;</code> even though they share the same tag name. Conceptually you could think of these as classical inheritance (so <code>class Card extends Div</code>) - inherit the semantics and base styles of <code>div</code> while making a re-usable style for a <code>Card</code> class.</p><p>Since 1997, we&#39;ve had more than 20 years of innovation of the Web. There are myriad new ways to structure your CSS.</p><h2>Scaling Class selectors.</h2><p>If we continue to think of the <code>class</code> property as an analog to OOP Classes - it&#39;s rare that you&#39;d have a class that takes no parameters or has no state. The intrinsic value of capital C Classes is that they have &#34;modes&#34; through parameters, and can change their state through methods. CSS has pseudo selectors which represent limited portions of state such as <code>:hover</code> but for representing <em>custom state</em> or <em>modality</em> within a class, you need to use yet-more classes. The problem is <code>class</code> just takes a list of strings...</p><p>Take our <code>Card</code> example. If we wanted to parameterise <code>Card</code> to take a <code>size</code> option which is either <code>Big</code> <code>Medium</code> or <code>Small</code>, a <code>rounded</code> boolean, and an <code>align</code> option which is either <code>Left</code>, <code>Right</code>, or <code>Center</code>. Let&#39;s say our <code>Card</code> also can be lazily loaded, so we want to represent a state of <code>Loading</code> and <code>Loaded</code>. We have several options at our disposal, but each with limitations:</p><ul><li>We can present them as additional classes, for example <code>&lt;div class=&#34;Card big&#34;&gt;</code>. One problem with this approach is that it lack namespaces; some other CSS can come along and co-opt what <code>big</code> means for their own component which can conflict. A way around this is to combine selectors in your CSS: <code>.Card.big {}</code> but this can cause specificity issues, which can create problems further down the line.</li><li>We can present them as distinct &#34;concrete&#34; classes, for example <code>&lt;div class=&#34;BigCard&#34;&gt;</code>. One issue with this approach is that we potentially produce a lot of duplicate CSS, as <code>BigCard</code> and <code>SmallCard</code> will likely have some shared CSS. This approach also has scalability issues, hitting the combinatorial explosion problem; with just the <code>size</code> option we need to create 3 classes, but add <code>rounded</code> and that becomes six, now add <code>align</code> and we have 18 classes to create.</li><li>We can namespace the classes parameters, for example <code>&lt;div class=&#34;Card Card--big&#34;&gt;</code>. This helps alleviate conflicts, and avoids the combinatorial explosion issue, but it can be overly wordy with a lot of duplicate typing, and it suffers another issue around misuse: what happens when I use the <code>Card--big</code> class without <code>Card</code>?</li></ul><p>Modern CSS can solve some of these issues, for example <code>:is()</code> and <code>:where()</code> pseudo class functions can massage the specificity of a selector ( <code>.Card:is(.big)</code> has an equal specificity to <code>.Card</code>). We could also use languages like SASS to help on authoring these systems, thanks to nesting and mixins which can alleviate the pain of duplication. These improve developer experience but fail to address the root problems.</p><p>We also have several problems which classes <em>inherently cannot solve</em>:</p><ul><li>With transitory state classes like <code>loading</code> and <code>loaded</code>, it is possible for code to arbitrarily apply these classes to the element, even when the element is <em>not</em> actually loading. The way to counter this is with engineering discipline (hard to scale to many engineers) or tooling (hard to maintain).</li><li>With mutually exclusive classes like <code>Big</code> and <code>Small</code>, it is possible for elements to apply <em>both</em> classes at once, and none of the class naming systems can correct for this, unless you specifically counter it with, again, more tooling or more code (for example <code>.Card.big.small { border: 10px solid red }</code>).</li></ul><p>We also have a cottage industry of CSS pseudo-specifications that try to solve these issues, but they&#39;re not really <em>the</em> solution:</p><h3>BEM is not the solution</h3><p>BEM or &#34;Block Element Modifier&#34; proposes a reasonably robust and scalable solution for parametrising classes. It uses namespaces which prevents re-use issues, at the expense of verbosity. It has hard rules around naming, which makes the code a little easier to reason about.</p><pre><code><span>.Card</span> <span>{</span> <span>}</span></code></pre><p>One big issue with BEM is that representing <em>dynamic</em> state through JS is an absolutely grueling amount of boilerplate:</p><pre><code></code></pre><p>Solutions around the boilerplate include using helper functions, but this is again merely pushing the problem down, rather than solving it.</p><h3>Atomic CSS is not the solution</h3><p>Atomic CSS or &#34;utility classes&#34; does away with the OOP concept of representing your design system components like &#34;Card&#34; and instead opts for classes to be used as an abstraction from CSS properties. It plays well into most design systems which are strictly a <em>subset</em> of CSS itself (CSS allows near limitless colours for example, while your brand palette probably allows for less than 100 colours). The popular &#34;Tailwind&#34; library is perhaps the most notable implementation of atomic CSS, but if you&#39;re unfamiliar it might look a bit like this:</p><pre><code><span>.w-big</span> <span>{</span> <span>width</span><span>:</span> 100% <span>}</span></code></pre><p>Atomic CSS usually results in chaos within your markup. To cut down on verbosity this system usually prefers short class names that are a handful of characters such as <code>br</code> instead of <code>border-radius</code>. To represent our Card example in this system requires a smörgåsbord of inscrutable class names, and this is a trivial example:</p><pre><code></code></pre><p>Atomic CSS also leaves a lot of the benefits of CSS on the cutting room floor. Atomic CSS reduces everyone to using the documentation; experienced designers who may have a lot of experience writing CSS now need to confer to a lookup table (&#34;I want <code>flex-shrink: 0</code>, is that <code>flex-shrink-0</code> or <code>shrink-0</code>?&#34;). All utilities are generally one class name, which means we lose any benefits from specificity; worse if we <em>introduce</em> specifity through mixing methodologies or using media queries or inline styles the whole thing falls apart. The typical response to specificity issues it to counter it with more specificity; GitHub&#39;s Primer CSS works around this by adding <code>!important</code> to every utility class, which then creates new problems.</p><p>While on the topic of media queries, we find the biggest problem with Atomic CSS which is that it leaves responsive design open to interpretation. Many implementations resort to providing classes that are only applied during a responsive breakpoint, which only serves to further litter the markup, and suffers from the combinatorial explosion issue. Here&#39;s a snippet of just 2 of the widths across 2 breakpoints as defined in tailwind CSS:</p><pre><code><span>.w-96</span> <span>{</span> <span>width</span><span>:</span> 24rem <span>}</span></code></pre><pre><code></code></pre><p>At first blush a utility class system might seem like a boon to a design system, but when applied to the markup we quickly see the problems: being unable to represent components easily in markup leads to a design system looking for other solutions such as providing markup with attached class names to represent a component - which usually results in the design system implementing components across a multitude of frameworks.</p><p>There are a plethora of other issues with the Utility CSS methodology, and with it a plethora of articles. If you consider this a suitable solution, I&#39;d encourage you to invest time researching the pitfalls, but I don&#39;t want to spend too long on this.</p><h3>CSS Modules is not the solution</h3><p>CSS Modules really only solves one problem: the &#34;selector collision&#34; issue. You can author CSS in a single file, which then becomes the class namespace, and run it through a tool which which prepends the namespace and tacks random characters at the end. The random characters are generated during build, as a way to prevent custom written styles that don&#39;t use CSS modules colliding with those that do. This means our card css...</p><pre><code><span>.card</span> <span>{</span>  <span>}</span></code></pre><p>...gets transformed during a build step to become...</p><pre><code><span>.card_166056</span> <span>{</span>  <span>}</span></code></pre><p>This seems like it solves the issues around BEM, as you don&#39;t have to write the namespaces everywhere! But instead it trades it for tooling that needs to be developed and maintained across all of your stack that presents UI; this requires your templating framework, JS runtime (if that&#39;s different) and your CSS compiler to all understand and use the same CSS Module system which creating a multitude of dependencies across your codebase. If you have a large organisation with multiple websites to maintain, perhaps written in multiple languages, you have to develop and maintain tooling across all of them. Now your design system team is tasked (or burdens other engineering teams) with orchestrating all of this tooling.</p><p>It also completely destroys any chance of caching your CSS beyond a single deploy. The only way to cache CSS like this is to make the class name transform deterministic, which defeats the purpose of using the hash in the first place.</p><h3>The problem all of these solutions have</h3><p>The key issue with all of these solutions is that they centre around the <code>class</code> property as the only way to represent the state of an object. Classes, being a list of arbitrary strings, have no key-values, no private state, no complex types (which also means IDE support is quite limited) and rely on custom DSLs like BEM just to make them slightly more usable. We keep trying to implement parameters into a <code>Set&lt;string&gt;</code> when what we want is a <code>Map&lt;string, T&gt;</code>.</p><h2>The solution to all of these problems</h2><p>I humbly put forward that modern web development provides us all the utilities to move away from class names and implement something much more robust, with some fairly straightforward changes:</p><h4>Attributes</h4><p>Attributes allow us to parameterise a component using a key-value representation, very similar to <code>Map&lt;string, T&gt;</code>. Browsers come with a <em>wealth</em> of selector functions to parse the values of an attribute. Given our card example, the full CSS can be expressed simply as:</p><pre><code><span>.Card</span> <span>{</span>  <span>}</span></code></pre><p>This might look similar to BEM, it has a lot of the same benefits. When authoring CSS it&#39;s certainly similar, but it demonstrates its advantage when we come to authoring the HTML:</p><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>&#34;</span>Card<span>&#34;</span></span> <span>data-size</span><span><span>=</span><span>&#34;</span>big<span>&#34;</span></span> <span>data-align</span><span><span>=</span><span>&#34;</span>center<span>&#34;</span></span><span>&gt;</span></span><span><span><span>&lt;/</span>div</span><span>&gt;</span></span></code></pre><p>It&#39;s also quite straightforward to make values dynamic in JS:</p><pre><code><span>function</span> <span>changeCardSize</span><span>(</span>card<span>,</span> newSize<span>:</span> <span>&#39;big&#39;</span> <span>|</span> <span>&#39;small&#39;</span> <span>|</span> <span>&#39;medium&#39;</span><span>)</span> <span>{</span></code></pre><p>The <code>data-</code> prefix can be a little unwieldy but it allows for the widest compatibility with tools and frameworks. Using attributes without some kind of namespace can be a little dangerous, as you risk clobbering HTML&#39;s global attributes, but as long as your attribute name has a dash it should be quite safe. For example you might invent your own namespace for addressing CSS parameters, which gives the benefit of readability:</p><pre><code><span>.Card[my-align=left]</span> <span>{</span> <span>text-align</span><span>:</span> left<span>;</span> <span>}</span></code></pre><p>This also has other tangible benefits. Attribute selectors like <code>[attr~&#34;val&#34;]</code> allow you to treat the value as if it were a list. This can be useful when you want flexibility in styling parts of a component, such as applying a style to one or more border sides:</p><pre><code><span>.Card</span> <span>{</span> <span>border</span><span>:</span> 10px solid <span>var</span><span>(</span>--brand-color<span>)</span> <span>}</span></code></pre><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>&#34;</span>card<span>&#34;</span></span> <span>data-border-collapse</span><span><span>=</span><span>&#34;</span>left right<span>&#34;</span></span><span>&gt;</span></span><span><span><span>&lt;/</span>div</span><span>&gt;</span></span></code></pre><p>The up and coming CSS Values 5 specification also allows for attributes to penetrate into CSS properties, much like CSS variables. It&#39;s common for design systems to have various size levels abstracting away pixel values (for example <code>pad-size</code> might go from 1-6 where each number represents range from 3px to 18px):</p><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>&#34;</span>card<span>&#34;</span></span> <span>pad-size</span><span><span>=</span><span>&#34;</span>2<span>&#34;</span></span><span>&gt;</span></span><span><span><span>&lt;/</span>div</span><span>&gt;</span></span></code></pre><pre><code><span>.Card</span> <span>{</span></code></pre><p>Of course with enough typing this could be solved today at least for bounded values (which most design systems express):</p><pre><code><span>.Card</span> <span>{</span></code></pre><p>Admittedly this is an uncomfortable amount of boilerplate, but it&#39;s a workaround for now.</p><h4>Custom Tag Names</h4><p>If you got down to here you&#39;re probably screaming at your monitor saying &#34;Keith you absolute buffoon, you&#39;re still using class names! .Card is a class!&#34;. Well that&#39;s the easy bit. HTML5 allows for custom tags, any tag that isn&#39;t recognised by the parser is an unknown element that can be freely styled as you see fit. Unknown tags come with no default user-agent styling: by default it behaves like a <code>&lt;span&gt;</code>. This is useful because we can express a component by using the <em>literal tag name</em> instead of <code>class</code>:</p><pre><code><span><span><span>&lt;</span>my-card</span> <span>data-size</span><span><span>=</span><span>&#34;</span>big<span>&#34;</span></span><span>&gt;</span></span><span><span><span>&lt;/</span>my-card</span><span>&gt;</span></span></code></pre><pre><code><span>my-card</span> <span>{</span>  <span>}</span></code></pre><p>These elements are <em>completely valid</em> HTML5 syntax and do not need any additional definitions, no special DTD or meta tag, no JavaScript. Just like attributes it&#39;s a good idea to include a <code>-</code> which the spec accommodates for and won&#39;t clobber. Using a <code>-</code> also means you can opt into even more powerful tools like Custom Element Definitions which <em>can</em> allow for JavaScript interactivity. With Custom Elements you can use <em>custom CSS states</em>, which takes us to the next level of capability:</p><h4>Custom State (custom pseudo selectors)</h4><p>If your components have any level of interactivity, they might want to change style due to some state change. You might be familiar with <code>input[type=checkbox]</code> elements having a <code>:checked</code> pseudo class, which allows CSS to hook into their internal state. With our Card example, we wanted to introduce a loading state, so we can decorate it in CSS; replete with animated spinners, while a fully loaded card might want to represent itself with a green border. With a little JavaScript, you can define your tag as a Custom Elements, grab the internal state object and manipulate it to represent these as <em>custom pseudo selectors</em> for your custom tag:</p><pre><code>customElements<span>.</span><span>define</span><span>(</span><span>&#39;my-card&#39;</span><span>,</span> <span>class</span> <span>extends</span> HTMLElement <span>{</span></code></pre><pre><code><span>my-card:--loading</span> <span>{</span> <span>background</span><span>:</span> <span><span>url</span><span>(</span>./spinner.svg<span>)</span></span> <span>}</span></code></pre><p>Custom states can be really powerful because they allow an element to represent itself in a modality under certain conditions <em>without</em> altering its markup, which means the element can retain full control of its states, and they <em>cannot</em> be controlled from the outside (unless the element allows it). You might go so far as to call it... <em>internal state</em>.</p><p>The one caveat with custom pseudo selectors is that they&#39;re not supported out of the box in Safari, which <a href="https://github.com/calebdwilliams/element-internals-polyfill#state-api">requires a polyfill which has some downsides</a>. <a href="https://bugs.webkit.org/show_bug.cgi?id=197960">However there is ongoing work to fix this in Safari</a> so time will soon heal this wound.</p><h2>Conclusion</h2><p>There are many great ways we express states and parameters of a component without having to shoehorn them into an archaic system like the <code>class</code> attribute. We have mechanisms today to replace it, we just need to unleash ourselves from our own shackles. Upcoming standards will allow us to express ideas in powerful new ways.</p><p>Still attached to utility classes? Think Custom Elements are the work of Satan? I&#39;d love to hear your thoughts on this, and as always you can shout in the comments below, or on Twitter, where I&#39;m <a href="https://twitter.com/keithamus">@keithamus</a>.</p></section></article></div></div>
  </body>
</html>
