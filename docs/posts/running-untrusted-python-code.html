<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://healeycodes.com/running-untrusted-python-code">Original</a>
    <h1>Running Untrusted Python Code</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>For a side-project, I needed to run some untrusted Python code.</p><p>I would usually sandbox untrusted code inside a virtual machine. Either with a managed service like Fargate, Lambda, or Fly Machines; or if there were specific requirements (e.g. performance, cost) perhaps I would use a primitive like a Firecracker microVM or a V8 isolate.</p><p>Since it&#39;s a side-project, I can do something less secure and more fun – like using a separate process with some limits applied to it. My understanding is that sandboxing untrusted code inside a separate process is something that used to be more common but, after many CVEs, it&#39;s now less common.</p><p>You can go straight to trying to break out of my sandbox here: <a href="https://untrusted-python.vercel.app/">untrusted-python.vercel.app</a>, view the <a href="https://github.com/healeycodes/untrusted-python">source code</a>, or keep on reading.</p><p>I will update this post if (more like when!) someone finds a security hole in it.</p><h2 id="how-it-works">How it works</h2><p>When the API receives some code, it spins up a new Python process. When the process starts, it has regular permissions and no resource limits. It then applies limits to itself (which can&#39;t be revoked) and then calls the guest code with <a href="https://docs.python.org/3/library/functions.html#exec"><code>exec</code></a>. After this last step, the process isn&#39;t trusted.</p><p>The input is source code and the output is stdout/stderr.</p><p>I have side-stepped the common mistake of building a sandbox in application land e.g. by removing access to parts of of the runtime.</p><p>In Python, removing builtins <em>seems</em> like it will stop people being able to access the system:</p><pre><div><div><p><span># ImportError: __import__ not found</span><span></span></p><p><span></span><span>exec</span><span>(</span><span>&#34;import os; os.system(&#39;ls&#39;)&#34;</span><span>,</span><span> </span><span>{</span><span>&#39;builtins&#39;</span><span>:</span><span> </span><span>{</span><span>}</span><span>}</span><span>)</span></p></div></div></pre><p>But program languages (and especially dynamic programming languages) allow you to do funky things, like walking up a class tree and dancing across frames:</p><pre><div><div><p><span># remove builtins, now we&#39;re safe!</span><span></span></p><p><span>__builtins__ </span><span>=</span><span> </span><span>{</span><span>}</span><span></span></p><p><span></span><span>import</span><span> os </span><span># ImportError: __import__ not found</span><span></span></p><p><span></span><span># .. until someone gets the builtins back</span><span></span></p><p><span>lookup </span><span>=</span><span> </span><span>lambda</span><span> n</span><span>:</span><span> </span><span>[</span><span>x </span><span>for</span><span> x </span><span>in</span><span> </span><span>(</span><span>1</span><span>)</span><span>.</span><span>__class__</span><span>.</span><span>__base__</span><span>.</span><span>__subclasses__</span><span>(</span><span>)</span><span> </span><span>if</span><span> x</span><span>.</span><span>__name__ </span><span>==</span><span> n</span><span>]</span><span>[</span><span>0</span><span>]</span><span></span></p><p><span></span><span>try</span><span>:</span><span></span></p><p><span>    lookup</span><span>(</span><span>&#39;Codec&#39;</span><span>)</span><span>(</span><span>)</span><span>.</span><span>decode</span><span>(</span><span>&#39;&#39;</span><span>)</span><span></span></p><p><span></span><span>except</span><span> lookup</span><span>(</span><span>&#39;BaseException&#39;</span><span>)</span><span> </span><span>as</span><span> e</span><span>:</span><span></span></p><p><span>    </span><span>del</span><span> lookup</span></p><p><span>    __builtins__ </span><span>=</span><span> e</span><span>.</span><span>__traceback__</span><span>.</span><span>tb_next</span><span>.</span><span>tb_frame</span><span>.</span><span>f_globals</span><span>[</span><span>&#39;__builtins__&#39;</span><span>]</span><span></span></p><p><span></span><span>import</span><span> os </span><span># works!</span><span></span></p><p><span></span><span># (source https://old.reddit.com/r/Python/comments/hftnp/ask_rpython_recovering_cleared_globals/c1v3l4i/)</span></p></div></div></pre><h2 id="seccomp">seccomp</h2><p>When you hand out virtual machines, you don&#39;t need to hide parts of the runtime. If a user decides to start deleting system files, that&#39;s fine! The output of the sandbox will be broken/undefined/errored but it doesn&#39;t matter. Everything is discarded in the end.</p><p>When using a separate process as a sandbox, you need something that sits between the program and the system – and when a user tries to delete a system file they should hit a meaningful error like <code>EPERM: operation not permitted</code> so they understand they&#39;ve run into a permissions issue.</p><p>For my sandbox, the layer between the process and the system is <a href="https://man7.org/linux/man-pages/man2/seccomp.2.html">seccomp</a> (secure computing mode) – a feature of the Linux kernel restricts a process from calling any system call apart from <code>exit</code>, <code>sigreturn</code>, <code>read</code> or <code>write</code> (to already open file descriptors).</p><p>You can also set <a href="https://man.archlinux.org/man/seccomp.2.en#SECCOMP_SET_MODE_FILTER">seccomp filters</a> to specify which system calls are allowed or not allowed, and what error code should be returned.</p><p>That&#39;s what I do:</p><pre><div><div><p><span>import</span><span> pyseccomp </span><span>as</span><span> seccomp</span></p><p><span></span><span>def</span><span> </span><span>drop_perms</span><span>(</span><span>)</span><span>:</span><span></span></p><p><span>    </span><span># respond with EPERM: operation not permitted so users can tell</span><span></span></p><p><span>    </span><span># they&#39;re being blocked from doing something</span><span></span></p><p><span>    </span><span>filter</span><span> </span><span>=</span><span> seccomp</span><span>.</span><span>SyscallFilter</span><span>(</span><span>seccomp</span><span>.</span><span>ERRNO</span><span>(</span><span>seccomp</span><span>.</span><span>errno</span><span>.</span><span>EPERM</span><span>)</span><span>)</span><span></span></p><p><span>    </span><span># allow `write`ing to two already-opened files stdout and stderr</span><span></span></p><p><span>    </span><span>filter</span><span>.</span><span>add_rule</span><span>(</span><span></span></p><p><span>        seccomp</span><span>.</span><span>ALLOW</span><span>,</span><span> </span><span>&#34;write&#34;</span><span>,</span><span> seccomp</span><span>.</span><span>Arg</span><span>(</span><span>0</span><span>,</span><span> seccomp</span><span>.</span><span>EQ</span><span>,</span><span> sys</span><span>.</span><span>stdout</span><span>.</span><span>fileno</span><span>(</span><span>)</span><span>)</span><span></span></p><p><span>    </span><span>)</span><span></span></p><p><span>    </span><span>filter</span><span>.</span><span>add_rule</span><span>(</span><span></span></p><p><span>        seccomp</span><span>.</span><span>ALLOW</span><span>,</span><span> </span><span>&#34;write&#34;</span><span>,</span><span> seccomp</span><span>.</span><span>Arg</span><span>(</span><span>0</span><span>,</span><span> seccomp</span><span>.</span><span>EQ</span><span>,</span><span> sys</span><span>.</span><span>stderr</span><span>.</span><span>fileno</span><span>(</span><span>)</span><span>)</span><span></span></p><p><span>    </span><span>)</span><span></span></p><p><span>    </span><span># load the filter in the kernel</span><span></span></p><p><span>    </span><span>filter</span><span>.</span><span>load</span><span>(</span><span>)</span></p></div></div></pre><p>This method of filtering system calls isn&#39;t super flexible e.g. you can&#39;t specify which files are allowed to be read or written to – just file descriptors.</p><p>Note: I avoided namespaces/cgroups to make it a little easier to ship something.</p><h2 id="setrlimit">setrlimit</h2><p>As well as system calls, you also need to worry about resources. My sandbox runs on the smallest Fly Machine size so there aren&#39;t many resources to go around. If someone sends up <code>while True: pass</code> it&#39;s going to start eating up a CPU core.</p><p>You can limit wall clock time from the outside with a timeout like this:</p><pre><div><div><p><span>proc </span><span>=</span><span> subprocess</span><span>.</span><span>Popen</span><span>(</span><span></span></p><p><span>  </span><span>[</span><span>sys</span><span>.</span><span>executable</span><span>,</span><span> </span><span>&#34;./sandbox.py&#34;</span><span>,</span><span> code</span><span>]</span><span>,</span><span></span></p><p><span>  stdout</span><span>=</span><span>subprocess</span><span>.</span><span>PIPE</span><span>,</span><span></span></p><p><span>  stderr</span><span>=</span><span>subprocess</span><span>.</span><span>PIPE</span><span>,</span><span></span></p><p><span></span><span>)</span><span></span></p><p><span></span><span>try</span><span>:</span><span></span></p><p><span>    stdout</span><span>,</span><span> stderr </span><span>=</span><span> proc</span><span>.</span><span>communicate</span><span>(</span><span>code</span><span>,</span><span> timeout</span><span>=</span><span>2</span><span>)</span><span></span></p><p><span></span><span>except</span><span> subprocess</span><span>.</span><span>TimeoutExpired</span><span>:</span><span></span></p><p><span>    proc</span><span>.</span><span>kill</span><span>(</span><span>)</span></p></div></div></pre><p>But during that timeout, what if some code tries to fill all available memory? Or writes GBs of data to stdout/stderr?</p><p><code>[setrlimit](https://linux.die.net/man/2/setrlimit)</code> is one of the answers for this – a system call that allows a process to set resource limits on itself/its child processes. There are different limits available but I picked out the ones I&#39;m concerned about. <code>RLIMIT_CPU</code> (overall CPU time), <code>RLIMIT_AS</code> (maximum virtual memory size), and <code>RLIMIT_FSIZE</code> (maximum size of files created by the process).</p><p>Python lets you call into this from the standard library module <a href="https://docs.python.org/3/library/resource.html">resource</a>.</p><pre><div><div><p><span>import</span><span> resource</span></p><p><span></span><span>def</span><span> </span><span>set_mem_limit</span><span>(</span><span>)</span><span>:</span><span></span></p><p><span>    </span><span># virtual memory</span><span></span></p><p><span>    resource</span><span>.</span><span>setrlimit</span><span>(</span><span>resource</span><span>.</span><span>RLIMIT_AS</span><span>,</span><span> </span><span>(</span><span>MEMORY_LIMIT</span><span>,</span><span> MEMORY_LIMIT</span><span>)</span><span>)</span><span></span></p><p><span>    </span><span># cpu time</span><span></span></p><p><span>    resource</span><span>.</span><span>setrlimit</span><span>(</span><span>resource</span><span>.</span><span>RLIMIT_CPU</span><span>,</span><span> </span><span>(</span><span>CPU_TIME_LIMIT</span><span>,</span><span> CPU_TIME_LIMIT</span><span>)</span><span>)</span><span></span></p><p><span>    </span><span># write limit i.e. don&#39;t allow an infinite stream to stdout/stderr</span><span></span></p><p><span>    resource</span><span>.</span><span>setrlimit</span><span>(</span><span>resource</span><span>.</span><span>RLIMIT_FSIZE</span><span>,</span><span> </span><span>(</span><span>WRITE_LIMIT</span><span>,</span><span> WRITE_LIMIT</span><span>)</span><span>)</span></p></div></div></pre><p>I suspect I&#39;m missing an important limit here. If some Python code is able to monopolise a system resource in a way that the API or another sandbox process is affected I would consider it a security hole.</p><p>Let me know if you can break something here. DDoSing is cheating!</p><h2 id="more-on-sandboxes">More on sandboxes</h2><p>As part of my Python sandbox research, I read about <a href="https://lwn.net/Articles/574215/">The failure of pysandbox</a>:</p><blockquote><p>I now agree that putting a sandbox in CPython is the wrong design. There are too many ways to escape the untrusted namespace using the various introspection features of the Python language. To guarantee the [safety] of a security product, the code should be [carefully] audited and the code to review must be as small as possible. Using pysandbox, the &#34;code&#34; is the whole Python core which is a really huge code base. For example, the Python and Objects directories of Python 3.4 contain more than 126,000 lines of C code.</p></blockquote><p>Which prompted me to <em>just wrap it in seccomp</em>.</p><p><a href="https://doc.pypy.org/en/latest/sandbox.html">Pypy&#39;s sandbox</a> seems pretty promising if you need to productionize a Python sandbox (and, for some reason, you can&#39;t use virtual machines).</p><p>A few months ago I wrote about <a href="https://healeycodes.com/sandboxing-javascript-code">sandboxing JavaScript code</a> and built a TypeScript sandbox with Deno. Shortly after publishing it, I received a few bug bounties for reporting sandbox-related exploits in Val Town&#39;s runtime. They fixed these issues by shipping <a href="https://blog.val.town/blog/restricted-library-mode">Restricted Library Mode</a>. After poking at it, it seems like an additional isolation implemented with <a href="https://developer.mozilla.org/en-US/docs/Web/API/Worker">Workers</a>. JavaScript (and its various runtimes) have features that make sandboxing/isolation a little easier than Python because JavaScript always has sandboxes in mind (i.e. web browsers).</p><p>One idea I&#39;m noodling around with is sandboxing SQLite at the process level – using a mixture of its <a href="https://www.sqlite.org/c3ref/limit.html">run-time limits</a>, and using <a href="https://man7.org/linux/man-pages/man2/ptrace.2.html">ptrace</a> to restrict access to any file that isn&#39;t the main database file or one of SQLite&#39;s <a href="https://www.sqlite.org/tempfiles.html">nine types of temporary files</a>.</p></div></div></div>
  </body>
</html>
