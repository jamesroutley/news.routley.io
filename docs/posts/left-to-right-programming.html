<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://graic.net/p/left-to-right-programming">Original</a>
    <h1>Left to Right Programming</h1>
    
    <div id="readability-page-1" class="page"><article><!--[--><sub>2025-08-17</sub>  <h3>Programs Should Be Valid as They Are Typed</h3> <hr/><!--]--> <!--[!--><!--]--> <!----><p>I don’t like Python’s list comprehensions:</p> <pre><!----><code>text <span>=</span> <span>&#34;apple banana cherry\ndog emu fox&#34;</span>
words_on_lines <span>=</span> <span>[</span>line<span>.</span>split<span>(</span><span>)</span> <span>for</span> line <span>in</span> text<span>.</span>splitlines<span>(</span><span>)</span><span>]</span></code><!----></pre> <p>Don’t get me wrong, declarative programming is good. However, this syntax has poor ergonomics. Your editor can’t help you out as you write it. To see what I mean, lets walk through typing this code.</p> <pre><!----><code>words_on_lines <span>=</span> <span>[</span>l</code><!----></pre> <p>Ideally, your editor would be to autocomplete <code>line</code> here. Your editor can’t do this because <code>line</code> hasn’t been declared yet.</p> <pre><!----><code>words_on_lines <span>=</span> <span>[</span>line<span>.</span>sp</code><!----></pre> <p>Here, our editor knows we want to access some property of <code>line</code>, but since it doesn’t know the type of <code>line</code>, it can’t make any useful suggestions. Should our editor flag <code>line</code> as a non-existent variable? For all it knows, we might have meant to refer to some existing <code>lime</code> variable.</p> <pre><!----><code>words_on_lines <span>=</span> <span>[</span>line<span>.</span>split<span>(</span><span>)</span> <span>for</span> line <span>in</span></code><!----></pre> <p>Okay, now we know that <code>line</code> is the variable we’re iterating over. Is <code>split()</code> a method that exists for <code>line</code>? Who knows!</p> <pre><!----><code>words_on_lines <span>=</span> <span>[</span>line<span>.</span>split<span>(</span><span>)</span> <span>for</span> line <span>in</span> text<span>.</span>splitlines<span>(</span><span>)</span><span>]</span></code><!----></pre> <p>Ah! now we know the type of <code>line</code> and can validate the call to <code>split()</code>.
Notice that since <code>text</code> had already been declared, our editor is able to autocomplete <code>splitlines()</code>.</p> <p>This sucked! If we didn’t know what the <code>split()</code> function was called and wanted some help from our editor, we’d have to write</p> <pre><!----><code>words_on_lines <span>=</span> <span>[</span>_ <span>for</span> line <span>in</span> text<span>.</span>splitlines<span>(</span><span>)</span><span>]</span></code><!----></pre> <p>and go back to the <code>_</code> to get autocomplete on <code>line.sp</code></p> <!----> <hr/> <!----> <!----> <p>You deserve better than this.</p> <p>To see what I mean, lets look at a Rust example that does it <!--#s1--><span> <label for="s1-footnote">better. <span>†</span><span id="slot">[<!---->The most elegant solution here is Haskell’s <code>map words $ lines text</code> but that breaks all the principles I’m arguing for.<!---->]</span></label></span><!----></p> <pre><!----><code><span>let</span> text <span>=</span> <span>&#34;apple banana cherry\ndog emu fox&#34;</span><span>;</span>
<span>let</span> words_on_lines <span>=</span> text<span>.</span><span>lines</span><span>(</span><span>)</span><span>.</span><span>map</span><span>(</span><span><span>|</span>line<span>|</span></span> line<span>.</span><span>split_whitespace</span><span>(</span><span>)</span><span>)</span><span>;</span></code><!----></pre> <p>If you aren’t familiar with Rust syntax, <code>|argument| result</code> is an anonymous function equivilent to <code>function myfunction(argument) { return result; }</code></p> <p>Here, your program is constructed left to right. The first time you type <code>line</code> is the declaration of the variable. as soon as you type <code>line.</code> your editor is able to give you suggestions of <!--#s2--><span> <label for="s2-footnote">possible methods. <span>†</span><span id="slot">[<!---->In fact, I didn’t know that Rust had a <code>split_whitespace</code> function until it popped up as I was typing this example.<!---->]</span></label></span><!----></p> <p>This is much more pleasent. Since the program is always in a somehwat valid state as you type it, your editor is able to guide you towards the <a href="https://blog.codinghorror.com/falling-into-the-pit-of-success/" rel="nofollow">Pit of Success</a>.</p> <!----> <hr/> <!----> <!----> <p>There’s a principle in design called <a href="https://en.wikipedia.org/wiki/Progressive_disclosure" rel="nofollow">progressive disclosure</a>. The user should only be exposed to as much complexity as is neccessary to complete a task.
Additionally, complexity should naturally surface itself as it is relevant to the user.
You shouldn’t have to choose a font family and size before you start typing into Word, and options to change text wrapping around images should appear when you add an image.</p> <p>In C, you can’t have methods on structs. This means that any function that could be <code>myStruct.function(args)</code> has to be <code>function(myStruct, args)</code>.</p> <p>Suppose you have a <code>FILE *file</code> and you want to get it’s contents.
Ideally, you’d be able to type <code>file.</code> and see a list of every function that is primarily concerned with files.
From there you could pick <code>read</code> and get on with your day.</p> <p>Instead, you must know that functions releated to <code>FILE *</code> tend to start with <code>f</code>, and when you type <code>f</code> the best your editor can do is show you all functions ever written that start with an <code>f</code>.
From there you can eventually find <code>fread</code>, but you have no confidence that it was the best choice. Maybe there was a more efficient <code>read_lines</code> function that does exactly what you want, but you’ll never discover it by accident.</p> <p>In a more ideal language, you’d see that a <code>close</code> method exists while you’re typing <code>file.read</code>. This gives you a hint that you need to close your file when you’re done with it. You naturally came accross this information right as it became relevant to you. In C, you have to know ahead of time that <code>fclose</code> is a function that you’ll need to call once you’re done with the file.</p> <!----> <hr/> <!----> <!----> <p>C is not the only language that has this problem. Python has plenty of examples too. Consider the following Python and JavaScript snippets:</p> <pre><!----><code>
text <span>=</span> <span>&#34;lorem ipsum dolor sit amet&#34;</span>
word_lengths <span>=</span> <span>map</span><span>(</span><span>len</span><span>,</span> text<span>.</span>split<span>(</span><span>)</span><span>)</span></code><!----></pre> <pre><!----><code>
text <span>=</span> <span>&#34;lorem ipsum dolor sit amet&#34;</span>
wordLengths <span>=</span> text<span>.</span><span>split</span><span>(</span><span>&#34; &#34;</span><span>)</span><span>.</span><span>map</span><span>(</span><span>word</span> <span>=&gt;</span> word<span>.</span>length<span>)</span></code><!----></pre> <p>While Python gets some points for using a <!--#s3--><span> <label for="s3-footnote">first-class function <span>†</span><span id="slot">[<!---->Haskell, of course, solos with <code>map len $ words text</code><!---->]</span></label></span><!---->, the functions are not discoverable. Is string length <code>len</code>, <code>length</code>, <code>size</code>, <code>count</code>, <code>num</code>, or <!--#s4--><span> <label for="s4-footnote"># <span>†</span><span id="slot">[<!---->It is in Lua! I’ve seen all of these names used at some point<!---->]</span></label></span><!---->? Is there even a global function for length? You won’t know until you try all of them.</p> <p>In the JavaScript version, you see length as soon as you type <code>word.l</code>. There is less guesswork for what the function is named. The same is true for the <code>map</code>. When you type <code>.map</code>, you know that this function is going to work with the data you have. You aren’t going to get some weird error because the <code>map</code> function actually expected some other type, or because your language actually calls this function <!--#s5--><span> <label for="s5-footnote">select <span>†</span><span id="slot">[<!---->As it is in C# LINQ<!---->]</span></label></span><!---->.</p> <!----> <hr/> <!----> <!----> <p>While the Python code in the previous example is still readable, it gets worse as the complexity of the logic increases. Consider the following code that was part of <a href="https://github.com/Graicc/advent-of-code-2024/blob/0d7bf0f4f05489f0b5a09255fde47370084066e3/day_2/aoc2.py#L9" rel="nofollow">my 2024 Advent of Code solutions</a>.</p> <pre><!----><code><span>len</span><span>(</span><span>list</span><span>(</span><span>filter</span><span>(</span><span>lambda</span> line<span>:</span> <span>all</span><span>(</span><span>[</span><span>abs</span><span>(</span>x<span>)</span> <span>&gt;=</span> <span>1</span> <span>and</span> <span>abs</span><span>(</span>x<span>)</span> <span>&lt;=</span> <span>3</span> <span>for</span> x <span>in</span> line<span>]</span><span>)</span> <span>and</span> <span>(</span><span>all</span><span>(</span><span>[</span>x <span>&gt;</span> <span>0</span> <span>for</span> x <span>in</span> line<span>]</span><span>)</span> <span>or</span> <span>all</span><span>(</span><span>[</span>x <span>&lt;</span> <span>0</span> <span>for</span> x <span>in</span> line<span>]</span><span>)</span><span>)</span><span>,</span> diffs<span>)</span><span>)</span><span>)</span></code><!----></pre> <p>Yikes. You have to jump back and forth between the start and end of the line to figure out what’s going on. “Okay so we have the length of a list of some filter which takes this lambda… is it both of these conditions or just one? Wait which parenthesis does this go with…”</p> <p>In JavaScript:</p> <pre><!----><code>diffs<span>.</span><span>filter</span><span>(</span><span>line</span> <span>=&gt;</span> 
    line<span>.</span><span>every</span><span>(</span><span>x</span> <span>=&gt;</span> Math<span>.</span><span>abs</span><span>(</span>x<span>)</span> <span>&gt;=</span> <span>1</span> <span>&amp;&amp;</span> Math<span>.</span><span>abs</span><span>(</span>x<span>)</span> <span>&lt;=</span> <span>3</span><span>)</span> <span>&amp;&amp;</span>
    <span>(</span>line<span>.</span><span>every</span><span>(</span><span>x</span> <span>=&gt;</span> x <span>&gt;</span> <span>0</span><span>)</span> <span>||</span> line<span>.</span><span>every</span><span>(</span><span>x</span> <span>=&gt;</span> x <span>&lt;</span> <span>0</span><span>)</span><span>)</span>
<span>)</span><span>.</span>length<span>;</span></code><!----></pre> <p>Ah, okay. We have some list of <code>diffs</code>, that we filter down based on two conditons, and then we return the number that pass. The logic of the program can be read from left to right!</p> <!----> <hr/> <!----> <!----> <p>All of these examples illustrate a common principle:</p> <h2><center>Programs should be valid as they are typed.</center></h2> <p>When you’ve typed <code>text</code>, the program is valid.
When you’ve typed <code>text.split(&#34; &#34;)</code>, the program is valid.
When you’ve typed <code>text.split(&#34; &#34;).map(word =&gt; word.length)</code>, the program is valid.
Since the program is valid as you build it up, your editor is able to help you out. If you had a REPL, you could even see the result as you type your program out.</p> <p>Make good APIs!</p><!----></article></div>
  </body>
</html>
