<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/coekie/flowtracker">Original</a>
    <h1>Show HN: FlowTracker â€“ Track data flowing through Java programs</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto"><em>Track data flowing through Java programs, gain new understanding at a glimpse.</em></p>
<p dir="auto">FlowTracker is a Java agent that tracks how a program reads, manipulates, and writes data.
By watching a program run, it can show what file and network I/O happened, but more importantly connecting its inputs and outputs to show where its output came from.
This helps you understand what any Java program&#39;s output means and why it wrote it.</p>
<p dir="auto">This proof-of-concept explores what insights we get by looking at program behaviour from this perspective.</p>

<p dir="auto">Spring PetClinic is a demo application for the Spring framework.
To demonstrate FlowTracker&#39;s abilities, we let it observe PetClinic handling an HTTP request and generating an HTML page based on a template and data from a database.
You can use this demo in your browser, without installing anything.
Open the <a href="https://flowtracker-demo.coekie.com/petclinic/#Server%20socket/*/%2F127.0.0.1%3A*/Write" rel="nofollow">FlowTracker PetClinic demo</a>, or watch the video below.</p>
<details open="">
  <summary>
    <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path d="M16 3.75v8.5a.75.75 0 0 1-1.136.643L11 10.575v.675A1.75 1.75 0 0 1 9.25 13h-7.5A1.75 1.75 0 0 1 0 11.25v-6.5C0 3.784.784 3 1.75 3h7.5c.966 0 1.75.784 1.75 1.75v.675l3.864-2.318A.75.75 0 0 1 16 3.75Zm-6.5 1a.25.25 0 0 0-.25-.25h-7.5a.25.25 0 0 0-.25.25v6.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-6.5ZM11 8.825l3.5 2.1v-5.85l-3.5 2.1Z"></path>
</svg>
    <span aria-label="Video description petclinic.mp4">petclinic.mp4</span>
    <span></span>
  </summary>

  <video src="https://private-user-images.githubusercontent.com/271022/352298644-af1af08e-0a7c-4d10-b105-c60d4222e13c.mp4?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MjYyODE4OTYsIm5iZiI6MTcyNjI4MTU5NiwicGF0aCI6Ii8yNzEwMjIvMzUyMjk4NjQ0LWFmMWFmMDhlLTBhN2MtNGQxMC1iMTA1LWM2MGQ0MjIyZTEzYy5tcDQ_WC1BbXotQWxnb3JpdGhtPUFXUzQtSE1BQy1TSEEyNTYmWC1BbXotQ3JlZGVudGlhbD1BS0lBVkNPRFlMU0E1M1BRSzRaQSUyRjIwMjQwOTE0JTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDI0MDkxNFQwMjM5NTZaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT1iOThlN2E1N2YxZjlhOGQxZjVkNTFkNzU0YzJiZDM0MmRkZTYwNWE5MTVlZWVjNzlkYzIyYThiNGJjYWUzZGM2JlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCZhY3Rvcl9pZD0wJmtleV9pZD0wJnJlcG9faWQ9MCJ9.km6R2N33GTc501AZUL2g8Qm8Tw-MQa4GtQOaB9UQ11Q" data-canonical-src="https://private-user-images.githubusercontent.com/271022/352298644-af1af08e-0a7c-4d10-b105-c60d4222e13c.mp4?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MjYyODE4OTYsIm5iZiI6MTcyNjI4MTU5NiwicGF0aCI6Ii8yNzEwMjIvMzUyMjk4NjQ0LWFmMWFmMDhlLTBhN2MtNGQxMC1iMTA1LWM2MGQ0MjIyZTEzYy5tcDQ_WC1BbXotQWxnb3JpdGhtPUFXUzQtSE1BQy1TSEEyNTYmWC1BbXotQ3JlZGVudGlhbD1BS0lBVkNPRFlMU0E1M1BRSzRaQSUyRjIwMjQwOTE0JTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDI0MDkxNFQwMjM5NTZaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT1iOThlN2E1N2YxZjlhOGQxZjVkNTFkNzU0YzJiZDM0MmRkZTYwNWE5MTVlZWVjNzlkYzIyYThiNGJjYWUzZGM2JlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCZhY3Rvcl9pZD0wJmtleV9pZD0wJnJlcG9faWQ9MCJ9.km6R2N33GTc501AZUL2g8Qm8Tw-MQa4GtQOaB9UQ11Q" controls="controls" muted="muted">

  </video>
</details>

<p dir="auto">You see the HTTP response that FlowTracker saw PetClinic send over the network.
Click on a part of the contents of the HTTP response to see in the bottom view where that part came from.
You can select another tracked origin/input or sink/output in the tree on the left (or bottom left button on mobile).</p>
<p dir="auto">Exploring this HTTP response, we navigate through multiple layers of the software stack:</p>
<ul dir="auto">
<li><strong>HTTP handling</strong> <em>FlowTracker shows what code produced what output</em>.
Click on &#34;HTTP/1.1&#34; or the HTTP headers. You see that this part of the response was generated by apache coyote (classes in the <code>org.apache.coyote</code> package), pointing you to where exactly each header came from.</li>
<li><strong>Thymeleaf templates</strong> <em>FlowTracker shows how the input the program reads (the HTML templates) corresponds to the output</em>.
Click on an HTML tag name, like &#34;html&#34; or &#34;head&#34;. You see the <code>layout.html</code> file, where this part of the HTML page comes from.
If you click on <code>layout.html</code>, and then on the colorful <code>+</code> button at the bottom, then everything coming from that file will be marked in the same color.
Scrolling down you&#39;ll then notice part of the response comes from a different file, <code>ownerDetails.html</code>.
Click on a <code>&lt;</code> or <code>&gt;</code> to see that those characters were written by the Thymeleaf templating library.</li>
<li><strong>Database</strong>
The HTML page contains a table with information that comes from the database.
Clicking on <code>George</code> in that table does not only show that that value came from the database.
It goes further: it traced it all the way back to the SQL script that inserted that value in the database in first place.</li>
</ul>
<p dir="auto">In that demo, the tracking up to the SQL script works because it was using an in-memory database.
The database content never left the JVM, so FlowTracker could fully keep track of it.
When we run the same demo but with a mysql database, then we track those values up to the database connection: we see the SQL query sent before to produce them, and details of how the mysql jdbc driver talks to the database.
See <a href="https://flowtracker-demo.coekie.com/petclinic-mysql/#Server%20socket/*/%2F127.0.0.1%3A*/Write" rel="nofollow">FlowTracker PetClinic mysql demo</a>.
Notice that FlowTracker intercepts the decrypted contents sent over the SSL connection to the database.</p>
<p dir="auto">This Spring PetClinic demo is just an example.
FlowTracker does not depend on your application using any particular framework or library.</p>
<p dir="auto">Another demo, showing how by watching the java compiler, FlowTracker helps you understand the format of the generated class file and the bytecode in it:
<a href="https://flowtracker-demo.coekie.com/javac/#Files/home/coekie/flowtracker-demo/HelloWorld.class" rel="nofollow">javac demo</a>, <a href="https://github.com/user-attachments/assets/5884c8fd-342b-471e-b13d-a2fe7219e8e6">video</a>.</p>

<p dir="auto">Warning:
In its current state, FlowTracker is closer to a proof of concept than production ready.
It has proven itself to work well on a number of example programs, but it is not going to work well for everything, your mileage may vary.
Also be aware that it adds a lot of overhead, making programs run much slower.</p>
<p dir="auto">Download the FlowTracker agent jar from the <a href="https://github.com/coekie/flowtracker/releases">Github releases pages</a> (<code>flowtracker-*.jar</code> under &#34;Assets&#34;).
Add the agent to your java command line: <code>-javaagent:path/to/flowtracker.jar</code>.
Disable some JVM optimizations that disrupt flowtracker by also adding the output of <code>java -jar flowtracker.jar jvmopts</code> to the command line.
By default, FlowTracker starts a webserver on port 8011, so open <a href="http://localhost:8011/" rel="nofollow">http://localhost:8011/</a> in your browser.</p>
<p dir="auto">For more detailed instructions, including configuration options, see <a href="https://github.com/coekie/flowtracker/blob/master/USAGE.md">USAGE.md</a>.</p>


<p dir="auto">FlowTracker is an instrumenting agent.
The agent injects its code into class files (bytecode) when the JVM loads them.
That code maintains a mapping of in-memory data to its origin, while the program reads, passes around, and writes data.
The focus is on tracking textual and binary data (like Strings, char and byte arrays), not on numerical, structured or computed data.</p>
<p dir="auto">This achieved with a combination of:</p>
<ul dir="auto">
<li>Replacing some calls to JDK methods with calls to FlowTracker&#39;s version of those methods.</li>
<li>Injecting code into key places in the JDK, mostly to track input and output.</li>
<li>Dataflow analysis and deeper instrumentation within methods to track local variables and values on the stack.</li>
<li>Adding code before and after method invocations, and at the start and end of invoked methods, to track method arguments and return values using ThreadLocals.</li>
</ul>

<p dir="auto">Core classes and concepts of FlowTracker&#39;s data model:</p>
<ul dir="auto">
<li>Tracker: holds information about a tracked object&#39;s content and source:
<ul dir="auto">
<li>content: the data that passed through them. e.g. all bytes passed through an <code>InputStream</code> or <code>OutputStream</code>.</li>
<li>source: associate ranges of its content to their source ranges in other trackers. For example, for the bytes of a <code>String</code> that could be pointing to the range of the tracker of the <code>FileInputStream</code> that the <code>String</code> was read from; telling us from which file and where exactly in that file it came from.</li>
</ul>
</li>
<li>TrackerRepository: holds a large global <code>Map&lt;Object, Tracker&gt;</code> that associates interesting objects with their tracker.</li>
<li>TrackerPoint: Pointer to a position in a tracker, representing a single primitive value being tracked, e.g. the source of one <code>byte</code>.</li>
</ul>

<p dir="auto">To keep Trackers up-to-date, our instrumentation inserts calls to <em>hook</em> methods in flowtracker when some specific JDK methods are being called.</p>
<p dir="auto">The simplest example of that is for System.arraycopy.
We intercept that on the caller&#39;s side: Calls to <code>java.lang.System.arraycopy</code> are replaced with calls to <code>com.coekie.flowtracker.hook.SystemHook.arraycopy</code>.
For this and other instrumentation, we use the ASM bytecode manipulation library.
In <code>SystemHook</code> we call the real <code>arraycopy</code>, get the <code>Trackers</code> of the source and destination arrays from the <code>TrackerRepository</code>, and update the target <code>Tracker</code> to point to its source.</p>
<p dir="auto">For example, given this code:</p>
<div dir="auto" data-snippet-clipboard-copy-content="char[] abc = ...; char[] abcbc = new char[5];
System.arraycopy(abc, 0, abcbc, 0, 3);
System.arraycopy(abc, 1, abcbc, 3, 2);"><pre><span>char</span>[] <span>abc</span> = ...; <span>char</span>[] <span>abcbc</span> = <span>new</span> <span>char</span>[<span>5</span>];
<span>System</span>.<span>arraycopy</span>(<span>abc</span>, <span>0</span>, <span>abcbc</span>, <span>0</span>, <span>3</span>);
<span>System</span>.<span>arraycopy</span>(<span>abc</span>, <span>1</span>, <span>abcbc</span>, <span>3</span>, <span>2</span>);</pre></div>
<p dir="auto">This gets rewritten to the following.
Note that instrumentation happens on bytecode, not source code, but we show equivalent source code here because that&#39;s much easier to read.</p>
<div dir="auto" data-snippet-clipboard-copy-content="char[] abc = ...; char[] abcbc = new char[5];
SystemHook.arraycopy(abc, 0, abcbc, 0, 3);
SystemHook.arraycopy(abc, 1, abcbc, 3, 2);"><pre><span>char</span>[] <span>abc</span> = ...; <span>char</span>[] <span>abcbc</span> = <span>new</span> <span>char</span>[<span>5</span>];
<span>SystemHook</span>.<span>arraycopy</span>(<span>abc</span>, <span>0</span>, <span>abcbc</span>, <span>0</span>, <span>3</span>);
<span>SystemHook</span>.<span>arraycopy</span>(<span>abc</span>, <span>1</span>, <span>abcbc</span>, <span>3</span>, <span>2</span>);</pre></div>
<p dir="auto">After executing this, the tracker for abcbc would look like: <code>{[0-2]: {tracker: abcTracker, sourceIndex: 0, length: 3}, [3-4]: {tracker: abcTracker, sourceIndex: 1, length: 2}}</code></p>
<p dir="auto">That was an example of a hook on the caller side.
But most calls to <em>hook</em> methods are added on the callee side, inside the methods in the JDK.
For example take <code>FileInputStream.read(byte[])</code>, which reads data from a File and stores the result in the provided <code>byte[]</code>.
We add the call to our hook method (<code>FileInputStreamHook.afterReadByteArray</code>) at the end of the <code>FileInputStream.read(byte[])</code> method.
We have our own instrumentation micro-framework for that, driven by annotations, implemented using ASM&#39;s <code>AdviceAdapter</code>.</p>
<p dir="auto">That way we add hooks to a number of classes in the JDK responsible for input and output, such as <code>java.io.FileInputStream</code>, <code>java.io.FileOutputStream</code>, and internal classes like <code>sun.nio.ch.FileChannelImpl</code>, <code>sun.nio.ch.IOUtil</code>, <code>sun.nio.ch.NioSocketImpl</code> and more.</p>
<p dir="auto">Implementation:
<a href="https://github.com/coekie/flowtracker/blob/master/core/src/main/java/com/coekie/flowtracker/hook/SystemHook.java">SystemHook</a>,
<a href="https://github.com/coekie/flowtracker/blob/master/core/src/main/java/com/coekie/flowtracker/hook/FileInputStreamHook.java">FileInputStreamHook</a>,
and other classes in the <a href="https://github.com/coekie/flowtracker/tree/master/core/src/main/java/com/coekie/flowtracker/hook">hook package</a>.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Primitive values, dataflow analysis</h2><a id="user-content-primitive-values-dataflow-analysis" aria-label="Permalink: Primitive values, dataflow analysis" href="#primitive-values-dataflow-analysis"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">A bigger challenge is tracking primitive values.
Consider this example:</p>
<div dir="auto" data-snippet-clipboard-copy-content="byte[] x; byte[] y;
// ...
byte b = x[1];
// ...
y[2] = b;"><pre><span>byte</span>[] <span>x</span>; <span>byte</span>[] <span>y</span>;
<span>// ...</span>
<span>byte</span> <span>b</span> = <span>x</span>[<span>1</span>];
<span>// ...</span>
<span>y</span>[<span>2</span>] = <span>b</span>;</pre></div>
<p dir="auto">When that code is executed, we would need to update the Tracker of <code>y</code>, to remember that the value at index 2 comes from the value at index 1 in <code>x</code>.
If those had been <code>String[]</code>s and <code>b</code> was a <code>String</code> instead of a <code>byte</code>, then we wouldn&#39;t need to modify code like this, because the TrackerRepository would know what the Tracker of the String is, and keeps that association no matter how that String object is passed around.
But the TrackerRepository can&#39;t keep a mapping of primitive values like bytes to Trackers, because primitive values don&#39;t have an identity: any <code>Map</code> having a byte as key would mix up different occurrences of the same byte.
Instead, we store the association of <code>b</code> to its tracker in a local variable in the method itself.
The code gets rewritten to roughly something like this:</p>
<div dir="auto" data-snippet-clipboard-copy-content="byte[] x; byte[] y;
// ...
byte b = x[1];
TrackerPoint bTracker = ArrayHook.getElementTracker(x, 1);
// ...
y[2] = b;
ArrayHook.setElementTracker(y, 2, bTracker);"><pre><span>byte</span>[] <span>x</span>; <span>byte</span>[] <span>y</span>;
<span>// ...</span>
<span>byte</span> <span>b</span> = <span>x</span>[<span>1</span>];
<span>TrackerPoint</span> <span>bTracker</span> = <span>ArrayHook</span>.<span>getElementTracker</span>(<span>x</span>, <span>1</span>);
<span>// ...</span>
<span>y</span>[<span>2</span>] = <span>b</span>;
<span>ArrayHook</span>.<span>setElementTracker</span>(<span>y</span>, <span>2</span>, <span>bTracker</span>);</pre></div>
<p dir="auto">To do that FlowTracker needs to understand how exactly values flow through a method.
We build upon ASM&#39;s analysis support to analyze the code (<em>symbolic interpretation</em>).
That way we construct a model of where values in local variables and on the stack come from at every point in the method, and where they end up.</p>
<p dir="auto">This is implemented in</p>
<ul dir="auto">
<li><a href="https://github.com/coekie/flowtracker/blob/master/weaver/src/main/java/com/coekie/flowtracker/weaver/flow/FlowValue.java">FlowValue</a> and its subclasses (e.g. <a href="https://github.com/coekie/flowtracker/blob/master/weaver/src/main/java/com/coekie/flowtracker/weaver/flow/ArrayLoadValue.java">ArrayLoadValue</a>) that model where values come from, and can generate the instructions that create the TrackerPoints that point to that source.
A particularly interesting one is <a href="https://github.com/coekie/flowtracker/blob/master/weaver/src/main/java/com/coekie/flowtracker/weaver/flow/MergedValue.java">MergedValue</a>, which handles situations where because of control flow (e.g. if-statements, loops) a value can come from multiple possible places.</li>
<li><a href="https://github.com/coekie/flowtracker/blob/master/weaver/src/main/java/com/coekie/flowtracker/weaver/flow/FlowInterpreter.java">FlowInterpreter</a>: extension of ASM&#39;s <code>Interpreter</code>, <em>interprets</em> bytecode instructions, creates the appropriate <code>FlowValue</code>s.</li>
<li><a href="https://github.com/coekie/flowtracker/blob/master/weaver/src/main/java/com/coekie/flowtracker/weaver/flow/Store.java">Store</a> and its subclasses (e.g. <a href="https://github.com/coekie/flowtracker/blob/master/weaver/src/main/java/com/coekie/flowtracker/weaver/flow/ArrayStore.java">ArrayStore</a>) that represent places that FlowValues go to, that consume the TrackerPoints.</li>
<li><a href="https://github.com/coekie/flowtracker/blob/master/weaver/src/main/java/com/coekie/flowtracker/weaver/flow/FlowTransformer.java">FlowTransformer</a>: drives the whole analysis and instrumentation process. See its docs for a more detailed walkthrough of how this all fits together.</li>
</ul>
<p dir="auto">We don&#39;t track the source of <em>all</em> primitive values.
The focus is on <code>byte</code> and <code>char</code> values, and to a lesser extent <code>int</code>s and <code>long</code>s.</p>

<p dir="auto">The dataflow analysis from the previous section is limited to handling flow of primitive values within a single method.
Those values also flow into other methods, as arguments and return values of method invocations.
We model that in <code>Invocation</code>, which stores <code>PointTracker</code>s for arguments and return values.
The <code>Invocation</code> is stored in a <code>ThreadLocal</code> just before a method invocation, and retrieved at the start of the implementation of the method.</p>
<p dir="auto">For example, take this code passing a primitive value to a &#34;write&#34; method:</p>
<div dir="auto" data-snippet-clipboard-copy-content="void caller() {
  byte b = ...;
  out.write(b);  
}

...

class MyOutputStream {
  void write(byte value) {
    ... // do something with value
  }
}"><pre><span>void</span> <span>caller</span>() {
  <span>byte</span> <span>b</span> = ...;
  <span>out</span>.<span>write</span>(<span>b</span>);  
}

...

<span>class</span> <span>MyOutputStream</span> {
  <span>void</span> <span>write</span>(<span>byte</span> <span>value</span>) {
    ... <span>// do something with value</span>
  }
}</pre></div>
<p dir="auto">To get the TrackerPoint of <code>b</code> into the <code>write</code> method, the code is instrumented like this:</p>
<div dir="auto" data-snippet-clipboard-copy-content="void caller() {
  byte b = ...;
  TrackerPoint bTracker = ...;
  Invocation.create(&#34;write(byte)&#34;)
    .setArg(0, bTracker)
    // this puts the Invocation in the ThreadLocal
    .calling(); 
  out.write(b);  
}

...

class MyOutputStream {
  void write(byte value) {
    // this extracts the Invocation from the ThreadLocal
    Invocation invocation = Invocation.start(&#34;write(byte)&#34;);
    TrackerPoint valueTracker = invocation.getArg0();
    ... // do something with value &amp; valueTracker
  }
}"><pre><span>void</span> <span>caller</span>() {
  <span>byte</span> <span>b</span> = ...;
  <span>TrackerPoint</span> <span>bTracker</span> = ...;
  <span>Invocation</span>.<span>create</span>(<span>&#34;write(byte)&#34;</span>)
    .<span>setArg</span>(<span>0</span>, <span>bTracker</span>)
    <span>// this puts the Invocation in the ThreadLocal</span>
    .<span>calling</span>(); 
  <span>out</span>.<span>write</span>(<span>b</span>);  
}

...

<span>class</span> <span>MyOutputStream</span> {
  <span>void</span> <span>write</span>(<span>byte</span> <span>value</span>) {
    <span>// this extracts the Invocation from the ThreadLocal</span>
    <span>Invocation</span> <span>invocation</span> = <span>Invocation</span>.<span>start</span>(<span>&#34;write(byte)&#34;</span>);
    <span>TrackerPoint</span> <span>valueTracker</span> = <span>invocation</span>.<span>getArg0</span>();
    ... <span>// do something with value &amp; valueTracker</span>
  }
}</pre></div>
<p dir="auto">Implementation:
<a href="https://github.com/coekie/flowtracker/blob/master/core/src/main/java/com/coekie/flowtracker/tracker/Invocation.java">Invocation</a>,
<a href="https://github.com/coekie/flowtracker/blob/master/weaver/src/main/java/com/coekie/flowtracker/weaver/flow/InvocationArgStore.java">InvocationArgStore</a>,
<a href="https://github.com/coekie/flowtracker/blob/master/weaver/src/main/java/com/coekie/flowtracker/weaver/flow/InvocationArgValue.java">InvocationArgValue</a>,
<a href="https://github.com/coekie/flowtracker/blob/master/weaver/src/main/java/com/coekie/flowtracker/weaver/flow/InvocationReturnStore.java">InvocationReturnStore</a>,
<a href="https://github.com/coekie/flowtracker/blob/master/weaver/src/main/java/com/coekie/flowtracker/weaver/flow/InvocationReturnValue.java">InvocationReturnValue</a>,
<a href="https://github.com/coekie/flowtracker/blob/master/weaver/src/main/java/com/coekie/flowtracker/weaver/flow/InvocationOutgoingTransformation.java">InvocationOutgoingTransformation</a>,
<a href="https://github.com/coekie/flowtracker/blob/master/weaver/src/main/java/com/coekie/flowtracker/weaver/flow/InvocationIncomingTransformation.java">InvocationIncomingTransformation</a></p>

<p dir="auto">There are two main types of tracked origins of data.
There is I/O, which is tracked as explained in the &#34;Basic instrumentation&#34; section.
And there are values coming from the code itself, such as primitive and String constants (<code>&#39;a&#39;</code>, <code>&#34;abc&#34;</code>).
For those, we create a tracker for each class (a <code>ClassOriginTracker</code>), that contains a textual representation of that class and the constants that it references.
When those constants are referenced, we then point the trackers for those values at the corresponding place in that textual representation.
That is <em>as if</em> our textual representation of the class is where the values were read from.
That makes our model for constants look very similar to how we model I/O.</p>
<p dir="auto">For example for this code:</p>
<div dir="auto" data-snippet-clipboard-copy-content="class MyClass {
  void myMethod() {
    char a = &#39;x&#39;;
    ... // do something with a
  }
}"><pre><span>class</span> <span>MyClass</span> {
  <span>void</span> <span>myMethod</span>() {
    <span>char</span> <span>a</span> = <span>&#39;x&#39;</span>;
    ... <span>// do something with a</span>
  }
}</pre></div>
<p dir="auto">We generate a <code>ClassOriginTracker</code> with content that looks like this:</p>
<div data-snippet-clipboard-copy-content="class MyClass
void myMethod():
  (line 3): x"><pre><code>class MyClass
void myMethod():
  (line 3): x
</code></pre></div>
<p dir="auto">And the code gets rewritten to something like:</p>
<div dir="auto" data-snippet-clipboard-copy-content="class MyClass {
  void myMethod() {
    char a = &#39;x&#39;;
    TrackerPoint aTracker = ConstantHook.constantPoint(
      1234 /* id for MyClass*/,
      81 /* offset of &#39;x&#39; in the ClassOriginTracker content */);
    
    ... // do something with a and aTracker
  }
}"><pre><span>class</span> <span>MyClass</span> {
  <span>void</span> <span>myMethod</span>() {
    <span>char</span> <span>a</span> = <span>&#39;x&#39;</span>;
    <span>TrackerPoint</span> <span>aTracker</span> = <span>ConstantHook</span>.<span>constantPoint</span>(
      <span>1234</span> <span>/* id for MyClass*/</span>,
      <span>81</span> <span>/* offset of &#39;x&#39; in the ClassOriginTracker content */</span>);
    
    ... <span>// do something with a and aTracker</span>
  }
}</pre></div>
<p dir="auto">For performance reasons, we actually use ConstantDynamic (<a href="https://openjdk.org/jeps/309" rel="nofollow">JEP 309</a>) to ensure that the <code>constantPoint</code> methods are only invoked once instead of every time <code>myMethod</code> executes.</p>
<p dir="auto">Implementation:
<a href="https://github.com/coekie/flowtracker/blob/master/core/src/main/java/com/coekie/flowtracker/tracker/ClassOriginTracker.java">ClassOriginTracker</a>,
<a href="https://github.com/coekie/flowtracker/blob/master/weaver/src/main/java/com/coekie/flowtracker/weaver/flow/ConstantValue.java">ConstantValue</a>,
<a href="https://github.com/coekie/flowtracker/blob/master/weaver/src/main/java/com/coekie/flowtracker/weaver/flow/ConstantsTransformation.java">ConstantsTransformation</a></p>

<p dir="auto">For String literals, we create a new copy of the String, and associate the content of the String (the <code>byte[]</code> in <code>String.value</code>) with the <code>ClassOriginTracker</code>.
A statement like <code>String s = &#34;abc&#34;;</code> gets rewritten to <code>String s = StringHook.constantString(&#34;abc&#34;, 1234, 81);</code>.
This breaks a guarantee that the JVM normally provides, that all String constants are <em>interned</em>: all occurrences of the same String constant should refer to the same instance.
Most code doesn&#39;t actually rely on String interning, but code that does would get broken by our instrumentation.
We avoid most of the issues that could cause because:</p>
<ul dir="auto">
<li>We use ConstantDynamic, so the same String literal (at the same line of code) executed multiple times still gives the same instance every time.</li>
<li>We rewrite some <code>stringA == stringB</code> expressions as <code>Objects.equals(stringA, stringB)</code>, so that from some points of view they look like the same instance again.</li>
<li>We disable tracking of String literals in some packages (such as <code>java.lang.*</code>). This is configurable (see <code>breakStringInterning</code> in <a href="https://github.com/coekie/flowtracker/blob/master/USAGE.md">USAGE.md</a>).</li>
</ul>
<p dir="auto">Implementation:
<a href="https://github.com/coekie/flowtracker/blob/master/weaver/src/main/java/com/coekie/flowtracker/weaver/flow/StringLdc.java">StringLdc</a>,
<a href="https://github.com/coekie/flowtracker/blob/master/weaver/src/main/java/com/coekie/flowtracker/weaver/flow/ConstantsTransformation.java">ConstantsTransformation</a>
<a href="https://github.com/coekie/flowtracker/blob/master/weaver/src/main/java/com/coekie/flowtracker/weaver/flow/StringComparison.java">StringComparison</a></p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Fallback for untracked values</h2><a id="user-content-fallback-for-untracked-values" aria-label="Permalink: Fallback for untracked values" href="#fallback-for-untracked-values"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">FlowTracker does not track every value in the program.
That is partly because of performance concerns, partly because we just haven&#39;t implemented everything we would want, and partly because it just doesn&#39;t seem relevant or would require building a more complicated data model where values can come from a combination of places (e.g. calculated numerical values).
When values that are not being tracked end up in places where we do want to start tracking them, then we treat them similar to constants: we add a link to the <code>ClassOriginTracker</code>, to where they became tracked, represented there as <code>&#34;&lt;?&gt;&#34;</code>.
For example, lengths of arrays are values that are not tracked, so suppose a method calls <code>write(array.length)</code>, then in that <code>Invocation</code> we pass a <code>PointTracker</code> that refers to that place in the code where the <code>write</code> method is called.</p>
<p dir="auto">In practice, the result of that is when you look at some output, particularly if it&#39;s in a binary format, while you don&#39;t see where a value originally came from, you can often still quickly decipher what it means (e.g. &#34;that value just before that tracked String points to <code>write(array.length)</code>, so that must be the length of that String&#34;).</p>

<p dir="auto">More topics about the implementation that could be talked about, but didn&#39;t make the cut. Most of this is documented in the code, if you really want to learn more:</p>
<ul dir="auto">
<li>Details of <a href="https://github.com/coekie/flowtracker/blob/master/weaver/src/main/java/com/coekie/flowtracker/weaver/flow/MergedValue.java">MergedValue</a>: the hardest part of dataflow analysis, how to instrument code to keep track of values through branches and loops.</li>
<li>How we hook String concatenation through its indification (<a href="https://openjdk.org/jeps/280" rel="nofollow">JEP 280</a>) by adding hooks to the MethodHandles returned by StringConcatFactory in <a href="https://github.com/coekie/flowtracker/blob/master/weaver/src/main/java/com/coekie/flowtracker/weaver/flow/StringConcatenation.java">StringConcatenation</a> and <a href="https://github.com/coekie/flowtracker/blob/master/core/src/main/java/com/coekie/flowtracker/hook/StringConcatFactoryHook.java">StringConcatFactoryHook</a>.</li>
<li>Finding the source code, decompiling with Vineflower, associating bytecode with source code lines.
See <a href="https://github.com/coekie/flowtracker/blob/master/web/src/main/java/com/coekie/flowtracker/web/SourceCodeGenerator.java">SourceCodeGenerator</a>,
<a href="https://github.com/coekie/flowtracker/blob/master/web/src/main/java/com/coekie/flowtracker/web/VineflowerCodeGenerator.java">VineflowerCodeGenerator</a>,
<a href="https://github.com/coekie/flowtracker/blob/master/web/src/main/java/com/coekie/flowtracker/web/AsmCodeGenerator.java">AsmCodeGenerator</a>.</li>
<li>The ClassLoader setup. How we avoid dependencies on the bootclasspath colliding with the app, without shading (because that makes debugging annoying) and without nested jars.
Development setup that allows changing an agent without repackaging it, to ensure fast development cycles.
See <a href="https://github.com/coekie/flowtracker/blob/master/agent/src/main/java/com/coekie/flowtracker/agent/FlowTrackerAgent.java">FlowTrackerAgent</a>,
<a href="https://github.com/coekie/flowtracker/blob/master/agent/src/main/java/com/coekie/flowtracker/agent/DevAgent.java">DevAgent</a>,
<a href="https://github.com/coekie/flowtracker/blob/master/agent/src/main/java/com/coekie/flowtracker/agent/SpiderClassLoader.java">SpiderClassLoader</a>.</li>
<li>How class loading can intervene with tracking of method invocations, and how we work around that.
See <a href="https://github.com/coekie/flowtracker/blob/master/weaver/src/main/java/com/coekie/flowtracker/weaver/SuspendInvocationTransformer.java">SuspendInvocationTransformer</a>,
<a href="https://github.com/coekie/flowtracker/blob/72ab61da96cbbb236a7395f9226f1797fa851892/core/src/main/java/com/coekie/flowtracker/tracker/Invocation.java#L163-L189">Invocation#suspend</a>.
<em>Interesting problem, simple solution kinda obvious in retrospect.</em></li>
<li>Tracking of primitive values stored in fields:
<a href="https://github.com/coekie/flowtracker/blob/master/core/src/main/java/com/coekie/flowtracker/tracker/FieldRepository.java">FieldRepository</a>,
<a href="https://github.com/coekie/flowtracker/blob/master/weaver/src/main/java/com/coekie/flowtracker/weaver/flow/FieldStore.java">FieldStore</a>,
<a href="https://github.com/coekie/flowtracker/blob/master/weaver/src/main/java/com/coekie/flowtracker/weaver/flow/FieldValue.java">FieldValue</a>.
<em>Just more of the same, nothing surprising.</em></li>
<li>How we add comments into instrumented code to help understand and debug instrumentation. <em>ASM/Bytecode doesn&#39;t support comments, but that won&#39;t stop me!</em></li>
<li>Avoiding circularity problems when instrumenting core JDK classes. <em>I eat <code>ClassCircularityError</code>s and <code>StackOverFlowError</code>s for breakfast</em>.</li>
<li>Front-end: Web server with jetty, JAX-RS. Web UI built with Svelte. <em>Beautiful UI design by... nobody.</em></li>
<li>Our optimized ThreadLocal abomination in <code>ContextSupplier</code>. <em>On second thought, never mind, you don&#39;t want to know.</em></li>
</ul>
</article></div></div>
  </body>
</html>
