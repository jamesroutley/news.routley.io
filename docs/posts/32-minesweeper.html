<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://elijer.github.io/garden/devnotes/LeetCode-Journal/32%29-Minesweeper">Original</a>
    <h1>32) Minesweeper</h1>
    
    <div id="readability-page-1" class="page"><article><p><strong>Informal Tags:</strong> nested 2D arrays, Array.from, Arrays,</p>
<p>Jaseem Abid generously agreed to give me another mock interview today because he has a behavioral tomorrow and his words “I can’t really prepare for that at this point because my answers will be built out of my , and the challenge was to design minesweeper!</p>
<p>I would not have passed the criteria for a real interview here - it turns out my ability to manipulate 2D arrays with Typescript is <em>somewhat</em> clunky and unpracticed . However, I do want to give myself props for this gem:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>  let</span><span> ranTile </span><span>=</span><span> Math.</span><span>floor</span><span>(Math.</span><span>random</span><span>() </span><span>*</span><span> (height </span><span>*</span><span> width))</span></span>
<span data-line=""><span>  let</span><span> tileWidth </span><span>=</span><span> ranTile </span><span>%</span><span> height</span></span>
<span data-line=""><span>  let</span><span> tileHeight </span><span>=</span><span> Math.</span><span>floor</span><span>(ranTile </span><span>/</span><span> height)</span></span>
<span data-line=""><span>  return</span><span> [tileWidth, tileHeight]</span></span></code></pre></figure>
<p>This is something I learned while creating a game that allowed me to translate a line of <code>height * width</code> elements into a <code>width</code> and <code>height</code> values.</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>// HW / prep</span></span>
<span data-line=""><span>// think of questions</span></span>
<span data-line=""><span>// refresh my own spiel</span></span>
<span data-line=""> </span>
<span data-line=""> </span>
<span data-line=""><span>// The challenge</span></span>
<span data-line=""><span>// N-part question</span></span>
<span data-line=""> </span>
<span data-line=""><span>// placeMines</span></span>
<span data-line=""><span>// where is this going to go?</span></span>
<span data-line=""><span>// Probably playing the game to be honest</span></span>
<span data-line=""> </span>
<span data-line=""><span>// Doesn&#39;t have to really </span></span>
<span data-line=""> </span>
<span data-line=""><span>function</span><span> generateRandomTile</span><span>(</span><span>height</span><span>:</span><span> number</span><span>, </span><span>width</span><span>:</span><span> number</span><span>){</span></span>
<span data-line=""> </span>
<span data-line=""><span>  let</span><span> ranTile </span><span>=</span><span> Math.</span><span>floor</span><span>(Math.</span><span>random</span><span>() </span><span>*</span><span> (height </span><span>*</span><span> width))</span></span>
<span data-line=""><span>  let</span><span> tileWidth </span><span>=</span><span> ranTile </span><span>%</span><span> height</span></span>
<span data-line=""><span>  let</span><span> tileHeight </span><span>=</span><span> Math.</span><span>floor</span><span>(ranTile </span><span>/</span><span> height)</span></span>
<span data-line=""><span>  return</span><span> [tileWidth, tileHeight]</span></span>
<span data-line=""><span>}</span></span>
<span data-line=""> </span>
<span data-line=""><span>// start: 11:30am</span></span>
<span data-line=""><span>function</span><span> placeMines</span><span>(</span><span>height</span><span>:</span><span> number</span><span>, </span><span>width</span><span>:</span><span> number</span><span>, </span><span>count</span><span>:</span><span> number</span><span>){</span></span>
<span data-line=""><span>  const</span><span> board</span><span>:</span><span> number</span><span>[][] </span><span>=</span><span> []</span></span>
<span data-line=""><span>  // create a bunch of rows</span></span>
<span data-line=""><span>  for</span><span> (</span><span>let</span><span> row </span><span>=</span><span> 0</span><span>; row </span><span>&lt;</span><span> height; row</span><span>++</span><span>){</span></span>
<span data-line=""><span>    const</span><span> row</span><span>:</span><span> number</span><span>[] </span><span>=</span><span> []</span></span>
<span data-line=""><span>    board.</span><span>push</span><span>(row)</span></span>
<span data-line=""> </span>
<span data-line=""><span>    // create a bunch of columns per row</span></span>
<span data-line=""><span>    for</span><span> (</span><span>let</span><span> col </span><span>=</span><span> 0</span><span>; col </span><span>&lt;</span><span> width; col</span><span>++</span><span>){</span></span>
<span data-line=""><span>      row.</span><span>push</span><span>(</span><span>0</span><span>)</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""> </span>
<span data-line=""><span>  const</span><span> randomTiles</span><span>:</span><span> number</span><span>[][] </span><span>=</span><span> []</span></span>
<span data-line=""> </span>
<span data-line=""> </span>
<span data-line=""><span>  </span></span>
<span data-line=""><span>  for</span><span> (</span><span>let</span><span> c </span><span>=</span><span> 0</span><span>; c </span><span>&lt;</span><span> count; c</span><span>++</span><span>){</span></span>
<span data-line=""> </span>
<span data-line=""><span>    // is this range completely right?</span></span>
<span data-line=""><span>    // Inefficient - stop at count</span></span>
<span data-line=""><span>    // repeating tiles</span></span>
<span data-line=""> </span>
<span data-line=""> </span>
<span data-line=""><span>    let</span><span> ranTile </span><span>=</span><span> generateRandomTile</span><span>(height, width)</span></span>
<span data-line=""> </span>
<span data-line=""><span>    while</span><span> (randomTiles.</span><span>includes</span><span>(ranTile)){</span></span>
<span data-line=""><span>      ranTile </span><span>=</span><span> generateRandomTile</span><span>(height, width)</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    randomTiles.</span><span>push</span><span>(ranTile)</span></span>
<span data-line=""><span>    let</span><span> [tileWidth, tileHeight]</span><span>=</span><span> ranTile</span></span>
<span data-line=""> </span>
<span data-line=""><span>    console.</span><span>log</span><span>(count)</span></span>
<span data-line=""> </span>
<span data-line=""><span>    board[tileWidth][tileHeight] </span><span>=</span><span> 1</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""> </span>
<span data-line=""> </span>
<span data-line=""><span>  return</span><span> board</span></span>
<span data-line=""><span>  // return count of mines randomly, across a board</span></span>
<span data-line=""><span>  // 10 x 10 board, place 15 of them</span></span>
<span data-line=""><span>}</span></span>
<span data-line=""> </span>
<span data-line=""><span>const</span><span> tester</span><span> =</span><span> (</span><span>expectedMines</span><span>:</span><span> number</span><span>, </span><span>board</span><span>:</span><span> number</span><span>[][]) </span><span>=&gt;</span><span> {</span></span>
<span data-line=""> </span>
<span data-line=""><span>  let</span><span> minesFound </span><span>=</span><span> 0</span></span>
<span data-line=""> </span>
<span data-line=""><span>  for</span><span> (</span><span>let</span><span> row </span><span>of</span><span> board){</span></span>
<span data-line=""><span>    for</span><span> (</span><span>let</span><span> col </span><span>of</span><span> row){</span></span>
<span data-line=""><span>      if</span><span> (col </span><span>===</span><span> 1</span><span>){</span></span>
<span data-line=""><span>        minesFound</span><span>++</span></span>
<span data-line=""><span>      }</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""> </span>
<span data-line=""><span>  console.</span><span>log</span><span>(expectedMines)</span></span>
<span data-line=""> </span>
<span data-line=""><span>  return</span><span> expectedMines </span><span>===</span><span> minesFound</span></span>
<span data-line=""><span>}</span></span>
<span data-line=""> </span>
<span data-line=""><span>// placeMines(10, 10, 2)</span></span>
<span data-line=""><span>//11:48</span></span>
<span data-line=""><span>console.</span><span>log</span><span>(</span><span>tester</span><span>(</span><span>2</span><span>, </span><span>placeMines</span><span>(</span><span>10</span><span>, </span><span>10</span><span>, </span><span>2</span><span>)))</span></span>
<span data-line=""> </span>
<span data-line=""> </span>
<span data-line=""> </span>
<span data-line=""> </span>
<span data-line=""> </span>
<span data-line=""><span>// Fix- 11:58 for the clashing repeat random tiles</span></span>
<span data-line=""><span>// end timestamp: 12:07</span></span>
<span data-line=""><span>// does JS have a tuple?</span></span>
<span data-line=""> </span>
<span data-line=""> </span>
<span data-line=""> </span>
<span data-line=""><span>// My job is convincing the recruitor possibly not solving problem</span></span></code></pre></figure>
<p>This works, and the testing works, which is all good, but there are some problems to address.</p>

<p>Creating a board with two nested loops is a <em>lot</em> of typing and code complexity that could certainly be compressed into a single line. This is sort of a trick, but it’s a very useful trick.</p>
<pre><code>  for (let row = 0; row &lt; height; row++){
    const row: number[] = []
    board.push(row)

    for (let col = 0; col &lt; width; col++){
      row.push(0)
    }
  }
</code></pre>
<p>That’s 8 lines - it’s a big chunk. There are a few ways to do this.</p>

<pre><code>const grid = Array.from({ length: height }, () =&gt; Array(width).fill(0));
</code></pre>
<p><code>Array.from()</code> takes two arguments. The first is an options object, which we are using to specify that the length of the array array should be equal to the variable <code>height</code>.</p>
<p>The second argument is a function, which specifies how to fill the array. In this case, we are using the <code>Array(n)</code> constructor with the <code>.fill</code> method to fill in the values of the rows.</p>
<p><code>Array.from</code> is certainly kind of funky. It turns out there are a few other ways to use it. We can, for example, pass another array into Array.from. The second argument will always be a map function that is applied to every element in the array.</p>
<p><em>That map function</em> can have up to two arguments: <code>value</code> and <code>index</code>. So if we wanted, we could create an array that was filled with its own indexes.</p>
<p>So what’s up with <code>{length: height}</code>?</p>
<p>It turns out I lied. There is no special <code>options</code> object expected by <code>Array.from</code>. <code>Array.from</code> will simply take any array-like object, like <code>Map</code> or <code>Set</code> (who gets to say those are array-like? I mean <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from">I guess MDN does<svg aria-hidden="true" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a> but I’m not sure what this criteria is) that, in MDN’s words, <em>has a length property</em>.</p>
<p>So that’s what we’re doing - passing in an object with a length property. That’s enough for <code>Array.from</code> to create an Array for us.</p>
<p>My question is, why do this when we can instead use <code>Array(numberOfItems)</code>?</p>
<p>Well, it turns out that simply using <code>Array(n)</code> alone creates an array that is completely empty in such a way that running <code>.map</code> on it will actually <em>skip</em> each element, since each element is empty.</p>
<p>Not event <code>undefined</code> apparently, but truly <em>empty</em>:</p>
<p><img src="https://thornberry-obsidian-general.s3.us-east-2.amazonaws.com/attachments/e8cca152e0e48e3fc4cb13386212abea.png" alt="image"/></p>
<p>This can be pretty easily fixed though - the spread operator apparently converts empty array slots into <code>undefined</code> ones, which <em>can</em> be mapped over. <img src="https://thornberry-obsidian-general.s3.us-east-2.amazonaws.com/attachments/d42a4ce840e3a9efadd7ba59744f2ccb.png" alt="image"/></p>
<p>So these two lines are roughly equivalent:</p>
<p><strong>Spread Array Constructor</strong></p>
<pre><code>const grid = [...Array(n)].map(e=&gt;e)
</code></pre>
<p><strong>Array.from Approach</strong></p>
<pre><code>const grid = Array.from({length: n}, e=&gt;e)`
</code></pre>
<p>The only difference I am really able to find is performance. Because the spread operator involves going back over an array a second time, the first approach is technically slower.</p>
<p>I ran this benchmark</p>
<pre><code>function usingArrayFrom(n: number) {
  return Array.from({length: n}, (_, i) =&gt; i);
}

function usingSpreadAndMap(n: number) {
  return [...Array(n)].map((_, i) =&gt; i);
}

// Benchmark
const n = 1000000;

let froms = 0
let spreads = 0

let loops = 1000
for (let i = 0; i &lt; loops; i++){

  let now = Date.now()
  usingArrayFrom(n);
  froms+=Date.now()-now

  let now2 = Date.now()
  usingSpreadAndMap(n);
  spreads+=Date.now()-now2
}

console.log(&#34;Array.from&#34;, froms/loops)
console.log(&#34;Array.spead&#34;, spreads/loops)
</code></pre>
<p>---<em><strong>Results for 1000 loops</strong></em>---
<strong>Array.from</strong> = 1.997 ms/average
<strong>Array.spead</strong> =  7.767 ms/average
<strong>Ratio:</strong> From is 3.8x faster</p>
<p>When I swapped their order, this result was actually even a bit more dramatic
<strong>Array.from1</strong> =1.57
<strong>Array.spread7</strong> = 7.79
<strong>Ratio</strong>: From is 6.2x faster</p>
<p>In summary, the <code>Array.from({}, ()=&gt;_)</code> method is faster enough to use instead of spread. I sort of like the way spread looks - fewer parenthesis. You can probably use either. We’re comparing between <code>1</code> and <code>8</code> milliseconds to create an array with <code>1000</code> items in it.</p>
<p>What I found was that  2.5 - 3.8 times faster
Here’s a different method using the spread operator and <code>Array.map</code> together, which is pretty cool.</p>
<p>So I’d say that settles it. Objectively the best way to create a grid of height <code>h</code> by width <code>w</code> is:</p>
<pre><code>const grid = Array.from({length: h}, () =&gt; Array(width).fill(0))
</code></pre>
<p>I suppose if you want to do it in the most performant way, <code>.from</code> is <em>still</em> more performant. It’s a little more than double the performance of  the <code>Array(n).fill(0)</code> approach. Unfortunately. Once again, I feel like it’s syntactically not as nice. But benchmarks don’t lie:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> from</span><span>(</span><span>n</span><span>:</span><span> number</span><span>) {</span></span>
<span data-line=""><span>  return</span><span> Array</span><span>(n).</span><span>fill</span><span>(</span><span>0</span><span>)</span></span>
<span data-line=""><span>}</span></span>
<span data-line=""> </span>
<span data-line=""><span>function</span><span> fill</span><span>(</span><span>n</span><span>:</span><span> number</span><span>) {</span></span>
<span data-line=""><span>  Array.</span><span>from</span><span>({length: n}, ()</span><span>=&gt;</span><span>0</span><span>)</span></span>
<span data-line=""><span>}</span></span>
<span data-line=""> </span>
<span data-line=""><span>// Benchmark</span></span>
<span data-line=""><span>const</span><span> n</span><span> =</span><span> 1000000</span><span>;</span></span>
<span data-line=""> </span>
<span data-line=""><span>let</span><span> froms </span><span>=</span><span> 0</span></span>
<span data-line=""><span>let</span><span> fills </span><span>=</span><span> 0</span></span>
<span data-line=""> </span>
<span data-line=""><span>let</span><span> loops </span><span>=</span><span> 1000</span></span>
<span data-line=""><span>for</span><span> (</span><span>let</span><span> i </span><span>=</span><span> 0</span><span>; i </span><span>&lt;</span><span> loops; i</span><span>++</span><span>){</span></span>
<span data-line=""> </span>
<span data-line=""><span>  let</span><span> now2 </span><span>=</span><span> Date.</span><span>now</span><span>()</span></span>
<span data-line=""><span>  fill</span><span>(n);</span></span>
<span data-line=""><span>  fills</span><span>+=</span><span>Date.</span><span>now</span><span>()</span><span>-</span><span>now2</span></span>
<span data-line=""> </span>
<span data-line=""><span>  let</span><span> now </span><span>=</span><span> Date.</span><span>now</span><span>()</span></span>
<span data-line=""><span>  from</span><span>(n);</span></span>
<span data-line=""><span>  froms</span><span>+=</span><span>Date.</span><span>now</span><span>()</span><span>-</span><span>now</span></span>
<span data-line=""><span>}</span></span>
<span data-line=""> </span>
<span data-line=""><span>console.</span><span>log</span><span>(</span><span>&#34;From&#34;</span><span>, froms</span><span>/</span><span>loops)</span></span>
<span data-line=""><span>console.</span><span>log</span><span>(</span><span>&#34;Fills&#34;</span><span>, fills</span><span>/</span><span>loops)</span></span></code></pre></figure>
<p>Creating an array with a million 0’s for each of them one thousand times averages out to
<strong>fill:</strong> 1.5ms
<strong>from:</strong> .6ms</p>
<p>Wow! That’s so fast <code>from</code>! So I revise my conclusion. The fastest, one-line way I can find to create a 2D array is:</p>
<pre><code>const grid = Array.from({length: h}, () =&gt; Array.from({length: w}, ()=&gt;h))
</code></pre>
<p>Oh my god. I’m so sorry. I’m just writing this as I go, but the plot thickens. In isolation, the verdict is super clear, right? <code>.from</code> is much faster than the <code>...Array().fill()</code> technique.</p>
<p>But when used together…</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>const</span><span> grid</span><span> =</span><span> Array.</span><span>from</span><span>({length: h}, () </span><span>=&gt;</span><span> Array.</span><span>from</span><span>({length: w}, ()</span><span>=&gt;</span><span>0</span><span>))</span></span>
<span data-line=""><span>// Average of 2.1ms*</span></span>
<span data-line=""> </span>
<span data-line=""><span>const</span><span> grid</span><span> =</span><span> [</span><span>...</span><span>Array</span><span>(h)].</span><span>map</span><span>(</span><span>e</span><span>=&gt;</span><span>Array</span><span>(w).</span><span>fill</span><span>(</span><span>0</span><span>))</span></span>
<span data-line=""><span>//Average of 0.9ms*</span></span>
<span data-line=""> </span>
<span data-line=""><span>// *where h and w are both 1000 over 1000 loops</span></span>
<span data-line=""> </span></code></pre></figure>
<p>So I guess we’ll never know. Do what you want, nothing makes sense. I say this tongue in cheek - modern Javascript parsers have all sorts of crazy optimizations, so the expectation that the results here would be deterministic and consistent across scales is unrealistic.</p>
<p>I wish I had a solid breakdown though, just to get to the bottom of this. I ran some benchmarks Claude created and came up with this:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>Array.</span><span>from</span><span>({length: h}, () </span><span>=&gt;</span><span> [</span><span>...</span><span>Array</span><span>(w)].</span><span>map</span><span>(() </span><span>=&gt;</span><span> 0</span><span>));</span></span>
<span data-line=""><span>// From -&gt; spread -&gt; map</span></span>
<span data-line=""><span>// 75ms</span></span>
<span data-line=""> </span>
<span data-line=""><span>Array.</span><span>from</span><span>({length: h}, () </span><span>=&gt;</span><span> Array.</span><span>from</span><span>({length: w}, () </span><span>=&gt;</span><span> 0</span><span>));</span></span>
<span data-line=""><span>// from -&gt; from</span></span>
<span data-line=""><span>// 41ms</span></span>
<span data-line=""> </span>
<span data-line=""><span>[</span><span>...</span><span>Array</span><span>(h)].</span><span>map</span><span>(() </span><span>=&gt;</span><span> Array</span><span>(w).</span><span>fill</span><span>(</span><span>0</span><span>));</span></span>
<span data-line=""><span>// spread -&gt; map -&gt; fill</span></span>
<span data-line=""><span>//13ms</span></span>
<span data-line=""> </span>
<span data-line=""><span>Array.</span><span>from</span><span>({length: h}, () </span><span>=&gt;</span><span> Array</span><span>(w).</span><span>fill</span><span>(</span><span>0</span><span>));</span></span>
<span data-line=""><span>// from -&gt; fill</span></span>
<span data-line=""><span>//11ms</span></span></code></pre></figure>
<p>These are with <code>100x100</code> grids and <code>1000</code> iterations.</p>
<p>I’m not totally sure what’s going on here. But I do sort of feel like I got my wish - I really like the <code>spread -&gt; map -&gt; fill</code> for a combination of having the shortest and simplest syntax, matched with nearly the top performance. So that’s what I’m going to add to my toolkit.
**</p>

<p>Did this OOP implementation and got stuck adding the bombs:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>type</span><span> Point</span><span> =</span><span> &#34;BOMB&#34;</span><span> |</span><span> number</span></span>
<span data-line=""> </span>
<span data-line=""><span>class</span><span> MineSweeper</span><span> {</span></span>
<span data-line=""><span>  height</span><span>:</span><span> number</span></span>
<span data-line=""><span>  width</span><span>:</span><span> number</span></span>
<span data-line=""><span>  count</span><span>:</span><span> number</span></span>
<span data-line=""><span>  totalPoints</span><span>:</span><span> number</span></span>
<span data-line=""><span>  board</span><span>:</span><span> Point</span><span>[][]</span></span>
<span data-line=""> </span>
<span data-line=""><span>  constructor</span><span>(</span><span>height</span><span>:</span><span> number</span><span>, </span><span>width</span><span>:</span><span> number</span><span>, </span><span>count</span><span>:</span><span> number</span><span>){</span></span>
<span data-line=""><span>    this</span><span>.height </span><span>=</span><span> height</span></span>
<span data-line=""><span>    this</span><span>.width </span><span>=</span><span> width</span></span>
<span data-line=""><span>    this</span><span>.count </span><span>=</span><span> count</span></span>
<span data-line=""><span>    this</span><span>.totalPoints </span><span>=</span><span> this</span><span>.height </span><span>*</span><span> this</span><span>.width</span></span>
<span data-line=""><span>    this</span><span>.board </span><span>=</span><span> this</span><span>.</span><span>createBoard</span><span>(</span><span>this</span><span>.height, </span><span>this</span><span>.width)</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""> </span>
<span data-line=""><span>  createBoard</span><span>(</span><span>h</span><span>:</span><span> number</span><span>, </span><span>w</span><span>:</span><span> number</span><span>)</span><span>:</span><span> Point</span><span>[][] {</span></span>
<span data-line=""><span>    return</span><span> [</span><span>...</span><span>Array</span><span>(h)].</span><span>map</span><span>(() </span><span>=&gt;</span><span> Array</span><span>(w).</span><span>fill</span><span>(</span><span>0</span><span>))</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""><span>  </span></span>
<span data-line=""><span>  findRandomPoint</span><span>()</span><span>:</span><span> [</span><span>number</span><span>, </span><span>number</span><span>, </span><span>number</span><span>]{</span></span>
<span data-line=""><span>    let</span><span> randomTile </span><span>=</span><span> Math.</span><span>floor</span><span>(Math.</span><span>random</span><span>() </span><span>*</span><span> this</span><span>.totalPoints)</span></span>
<span data-line=""><span>    let</span><span> ranWidth </span><span>=</span><span> randomTile </span><span>%</span><span> this</span><span>.height</span></span>
<span data-line=""><span>    let</span><span> ranHeight </span><span>=</span><span> Math.</span><span>floor</span><span>(randomTile </span><span>/</span><span> this</span><span>.width)</span></span>
<span data-line=""><span>    return</span><span> [randomTile, ranWidth, ranHeight]</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""> </span>
<span data-line=""><span>  setBoard</span><span>(){</span></span>
<span data-line=""><span>    let</span><span> uniquePoints </span><span>=</span><span> new</span><span> Set</span><span>()</span></span>
<span data-line=""><span>    console.</span><span>log</span><span>(uniquePoints.size)</span></span>
<span data-line=""><span>    while</span><span> (uniquePoints.size </span><span>&lt;=</span><span> this</span><span>.totalPoints){</span></span>
<span data-line=""><span>      let</span><span> [point, w, h] </span><span>=</span><span> this</span><span>.</span><span>findRandomPoint</span><span>()</span></span>
<span data-line=""><span>      if</span><span> (uniquePoints.</span><span>has</span><span>(point)) </span><span>continue</span></span>
<span data-line=""><span>      uniquePoints.</span><span>add</span><span>(point)</span></span>
<span data-line=""><span>      this</span><span>.board[w][h] </span><span>=</span><span> &#39;BOMB&#39;</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""><span>}</span></span>
<span data-line=""> </span>
<span data-line=""><span>let</span><span> ms </span><span>=</span><span> new</span><span> MineSweeper</span><span>(</span><span>10</span><span>, </span><span>10</span><span>, </span><span>2</span><span>)</span></span>
<span data-line=""><span>ms.</span><span>setBoard</span><span>()</span></span>
<span data-line=""><span>console.</span><span>log</span><span>(ms.board)</span></span></code></pre></figure>
<p>It’s way to verbose. 43 lines. I’m going to try again.</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>type</span><span> Point</span><span> =</span><span> &#34;BOMB&#34;</span><span> |</span><span> &#34;_&#34;</span><span> |</span><span> number</span></span>
<span data-line=""> </span>
<span data-line=""><span>function</span><span> mineSweeper</span><span>(</span><span>h</span><span>:</span><span> number</span><span>, </span><span>w</span><span>:</span><span> number</span><span>, </span><span>count</span><span>:</span><span> number</span><span>)</span><span>:</span><span> Point</span><span>[][]{</span></span>
<span data-line=""><span>  let</span><span> board </span><span>=</span><span> [</span><span>...</span><span>Array</span><span>(h)].</span><span>map</span><span>(() </span><span>=&gt;</span><span> Array</span><span>(w).</span><span>fill</span><span>(</span><span>&#39;_&#39;</span><span>))</span></span>
<span data-line=""><span>  let</span><span> uniquePoints </span><span>=</span><span> new</span><span> Set</span><span>()</span></span>
<span data-line=""><span>  while</span><span> (uniquePoints.size </span><span>&lt;</span><span> count){</span></span>
<span data-line=""><span>    let</span><span> ranPoint </span><span>=</span><span> Math.</span><span>floor</span><span>(Math.</span><span>random</span><span>()</span><span>*</span><span>h</span><span>*</span><span>w)</span></span>
<span data-line=""><span>    if</span><span> (uniquePoints.</span><span>has</span><span>(ranPoint)) </span><span>continue</span></span>
<span data-line=""><span>    uniquePoints.</span><span>add</span><span>(ranPoint)</span></span>
<span data-line=""><span>    const</span><span> ranHeight</span><span> =</span><span> ranPoint </span><span>%</span><span> h</span></span>
<span data-line=""><span>    const</span><span> ranWidth</span><span> =</span><span> Math.</span><span>floor</span><span>(ranPoint </span><span>/</span><span> w)</span></span>
<span data-line=""><span>    board[ranHeight][ranWidth] </span><span>=</span><span> &#39;BOMB&#39;</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""> </span>
<span data-line=""><span>  return</span><span> board</span></span>
<span data-line=""><span>}</span></span>
<span data-line=""> </span>
<span data-line=""><span>console.</span><span>log</span><span>(</span><span>mineSweeper</span><span>(</span><span>10</span><span>, </span><span>10</span><span>, </span><span>3</span><span>))</span></span></code></pre></figure>
<p>Wow that is way better.
18 lines.
That took me about 5 minutes this time around.</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>[</span><span>...</span><span>Array</span><span>(h)].</span><span>map</span><span>(()</span><span>=&gt;</span><span>Array</span><span>(w).</span><span>fill</span><span>(</span><span>&#39;_&#39;</span><span>))</span></span></code></pre></figure>
<p>Okay this time I got it in <code>3:11s</code>:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>type</span><span> Point</span><span> =</span><span> &#34;BOMB&#34;</span><span> |</span><span> &#34;_&#34;</span><span> |</span><span> number</span></span>
<span data-line=""> </span>
<span data-line=""><span>function</span><span> generateBoard</span><span>(</span><span>h</span><span>:</span><span> number</span><span>, </span><span>w</span><span>:</span><span> number</span><span>)</span><span>:</span><span> Point</span><span>[][] {</span></span>
<span data-line=""><span>  return</span><span> [</span><span>...</span><span>Array</span><span>(h)].</span><span>map</span><span>(()</span><span>=&gt;</span><span>Array</span><span>(w).</span><span>fill</span><span>(</span><span>&#34;_&#34;</span><span>))</span></span>
<span data-line=""><span>}</span></span>
<span data-line=""> </span>
<span data-line=""><span>function</span><span> mineSweeper</span><span>(</span><span>h</span><span>:</span><span> number</span><span>, </span><span>w</span><span>:</span><span> number</span><span>, </span><span>count</span><span>:</span><span> number</span><span>)</span><span>:</span><span> Point</span><span>[][]{</span></span>
<span data-line=""><span>  let</span><span> board </span><span>=</span><span> generateBoard</span><span>(h, w)</span></span>
<span data-line=""><span>  let</span><span> uniquePoints</span><span>:</span><span> Set</span><span>&lt;</span><span>number</span><span>&gt; </span><span>=</span><span> new</span><span> Set</span><span>()</span></span>
<span data-line=""><span>  while</span><span> (uniquePoints.size </span><span>&lt;</span><span> count){</span></span>
<span data-line=""><span>    let</span><span> ranPoint </span><span>=</span><span> Math.</span><span>floor</span><span>(Math.</span><span>random</span><span>() </span><span>*</span><span> h </span><span>*</span><span> w)</span></span>
<span data-line=""><span>    if</span><span> (uniquePoints.</span><span>has</span><span>(ranPoint)) </span><span>continue</span></span>
<span data-line=""><span>    let</span><span> ranHeight </span><span>=</span><span> ranPoint </span><span>%</span><span> h</span></span>
<span data-line=""><span>    let</span><span> ranWidth </span><span>=</span><span> Math.</span><span>floor</span><span>(ranPoint </span><span>/</span><span> w)</span></span>
<span data-line=""><span>    uniquePoints.</span><span>add</span><span>(ranPoint)</span></span>
<span data-line=""><span>    board[ranHeight][ranWidth] </span><span>=</span><span> &#34;BOMB&#34;</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""><span>  return</span><span> board</span></span>
<span data-line=""><span>}</span></span>
<span data-line=""> </span>
<span data-line=""><span>console.</span><span>log</span><span>(</span><span>mineSweeper</span><span>(</span><span>10</span><span>, </span><span>10</span><span>, </span><span>6</span><span>))</span></span></code></pre></figure>
<p>I think that extracting the board generation into it’s own function is actually very unnecessary, and wastes a lot of time.</p>
<p>It could be done later.</p></article></div>
  </body>
</html>
