<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://akkartik.name/post/division-of-labor">Original</a>
    <h1>Ten years against division of labor in software</h1>
    
    <div id="readability-page-1" class="page"><div>
  <p><b>10 years against division of labor in software</b></p><p>
<em>2012</em>
</p><p>
&#34;Software libraries suck. Here&#39;s why, in a sentence: they promise to be
abstractions, but they end up becoming services. An abstraction frees you from
thinking about its internals every time you use it. A service allows you to
never learn its internals. A service is not an abstraction. It isn&#39;t &#39;abstracting&#39;
away the details. Somebody else is thinking about the details so you can
remain ignorant.
</p><p>
&#34;Programmers manage abstraction boundaries, that&#39;s our stock in trade.
Managing them requires bouncing around on both sides of them. If you restrict
yourself to one side of an abstraction, you&#39;re limiting your growth as a
programmer.1 You&#39;re chopping off your strength and potential, one lock of hair
at a time, and sacrificing it on the altar of convenience. &#34;
</p><p>
&#34;Division of labor is a relationship not to be gotten into lightly.&#34;
</p><p>
<em>2015</em>
</p><p>
&#34;I think software finally gives us a way to avoid division of labor.&#34;
</p><p>
&#34;I think namespaces and modules are socially counter-productive even when
implemented in a technically impeccable manner, because they encourage
division of labor. In even the smallest of projects, without thinking about
it, we often start out with the goal of working with someone, and proceed to
do so by defining an interface and then working apart. That is no fun, and it
is gradually self-limiting. I think we do this because it&#39;s so easy to create
interfaces and silos, to isolate ourselves from each other&#39;s changes using
namespaces and similar constructs. By creating these constructs, by making
them too easily available, we forget to ask if we should use them. This is, I
think, an example of taking the human out of the loop. But even here, the only
way I can think of to do a rollback is by trying to build a software stack
from scratch.&#34;
</p><p>
<em>2016</em>
</p><p>
&#34;For the past couple of years I’ve been researching ways to write software
that make it easier for newcomers to understand rather than for insiders to
maintain. In this quest I built a toy OS and Basic-like language called Mu
which tries to “rhyme with” the design process by which Unix was coevolved
with C. The big additional design constraint compared to Unix+C is to make the
OS primitives testable. I want to be able to pretend in tests that we run out
of memory or disk, that a context switch happens between these two instructions,
and so on. My hypothesis is that having the ability to easily write such tests
from day 1 would radically impact the culture of an eco-system in a way that
no bolted-on tool or service at higher levels can replicate: it would enable
new kinds of tests to be written and make it easier to be confident that an
app is free from regression if all automated tests pass. This would make the
stack easy to rewrite and simplify by dropping features, without fear that a
subset of targeted apps might break. As a result people might fork projects
more easily, and also exchange code between disparate forks more easily (copy
the tests over, then try copying code over and making tests pass, rewriting
and polishing where necessary). The community would have in effect a diversified
portfolio of forks, a “wavefront” of possible combinations of features and
alternative implementations of features instead of the single trunk with
monotonically growing complexity that we get today. Application writers who
wrote thorough tests for their apps (something they just can’t do today) would
be able to bounce around between forks more easily without getting locked in
to a single one as currently happens.&#34;
</p><p>
<em>2017</em>
</p><p>
&#34;The lesson I draw for software from <a href="https://creators.vice.com/en_uk/article/animator-hand-draws-film-in-4-years-nova-seed">https://creators.vice.com/en_uk/article/animator-hand-draws-film-in-4-years-nova-seed</a>
isn&#39;t about collaborating or not, it&#39;s about avoiding division of labor. When
working with someone on a project don&#39;t &#34;design an interface&#34; and then work
alone on either side of it. Work together all over it.&#34;
</p><p>
&#34;It is undeniably useful to be able to put off learning about some parts of
the system until we feel the urge. The golden mean may be to be on a stack
that isn&#39;t &#39;lumpy&#39;, where between you and machine code are many gossamer-thin
layers, any one of which can be easily peeled back to understand how it
works.
</p><p>
&#34;I started out mocking NPM for the left-pad debacle, but over time I&#39;ve
actually grown more sympathetic to left-pad. The problem isn&#39;t that somebody
wrote a library for left-pad. It is that even something as trivial as left-pad
has triggered our division-of-labor instincts. A library like left-pad is just
begging to be saved into projects that use it so users have one less moving
part to worry about at deployment time. Turning it into a first-class dependency
also ensured that a lot less people looked inside it to understand its five
lines of code or whatever.&#34;
</p><p>
&#34;One of the benefits of my scheme is that calling programming languages
abstractions is almost always obviously incorrect. Libraries are also never
abstractions. Clarifying this wording immediately cuts through a bunch of
confused discussions online.&#34;
</p><p>
&#34;Libraries with non-trivial functionality take a long time to get right, and
in the meantime they are produced more like guilds of craftsmen than factories.
(Even if the products themselves permit factory-like operation at scale.) In
that initial bake-in period we are ill-served by conventional metaphors of
software components, building blocks, etc. We should be dealing more in
vertically-integrated self-contained systems rather than plug-and-play
libraries. More OpenBSD, less `gem install`.&#34;
</p><p>
&#34;Division of labor is an extremely mature state for a society. Aiming prematurely
for it is counterproductive. Rather than try to imitate more mature domains,
start from scratch and see what this domain ends up needing.&#34;
</p><p>
<em>2018</em>
</p><p>
&#34;Confusingly, I&#39;ve been calling Iverson&#39;s notion of subordination of detail
&#34;abstraction&#34;, and Iverson&#39;s notion of abstraction &#34;service&#34; or &#34;division of
labor&#34;. Though lately I try to avoid the term &#34;abstraction&#34; entirely. That
seems on the right track. Regardless of terminology, this is a critical
distinction.&#34;
</p><p>
&#34;I consider an example of exemplary library use to be how I <a href="https://github.com/akkartik/mu/commit/5f1285238b">copied the termbox
library into Mu</a>, <a href="https://github.com/akkartik/mu/commit/9ba313ab7f">periodically
merged commits from upstream</a>,
<a href="(&lt;a href=&#34;https://github.com/akkartik/mu/commit/9a31c34f0f&#34;&gt;https://github.com/akkartik/mu/commit/9a31c34f0f&lt;/a&gt;">gradually cleaned it up to fit better with my project</a>,
and <a href="https://github.com/akkartik/mu/commit/c04baba4f2">gradually
stripped out</a> <a href="https://github.com/akkartik/mu/commit/8e7827dfcf">code
from it</a> that <a href="https://github.com/akkartik/mu/commit/547ec78bf2">Mu
does not require</a>.
</p><p>
&#34;In the process I made some wrong turns, <a href="https://github.com/akkartik/mu/commit/10a3b8cca2">deleting
features that I later decided I wanted</a> and <a href="https://github.com/akkartik/mu/commit/3315a7d3bb">created</a>
<a href="https://github.com/akkartik/mu/commit/0c0d1ea5cd">bugs</a> for
myself. But when it did things I didn&#39;t want, <a href="https://github.com/akkartik/mu/commit/ee1a18f050">I
was now empowered to change them</a>. One of my patches was useful upstream,
so <a href="https://github.com/nsf/termbox/commit/0730826a07">I submitted
it</a>. I would be in no position to submit that patch if I hadn&#39;t taken the
trouble to understand termbox&#39;s internals. And that shows a final benefit of
copying and privately forking libraries: it makes you a better citizen of the
open source world, because open source depends on eyeballs, and using a
library blindly helps nobody except your (extremely short-term) self.&#34;
</p><p>
&#34;I&#39;ve been thinking about the problem with division of labor for 7 years now,
and I think I&#39;ve boiled it down to two sentences. Why division of labor is
disempowering:
</p><p>
1. (the setup) Power = capability - supervision.
</p><p>
2. Division of labor tends to discourage supervision.&#34;
</p><p>
—<a href="https://mastodon.social/@akkartik/100448295592974261">https://mastodon.social/@akkartik/100448295592974261</a>
</p><p>
&#34;Let&#39;s assume code reuse is a mirage. What can we achieve if we stop aiming
for it? In this I think I&#39;m close to the Forth aesthetic.&#34;
</p><p>
&#34;Division of labor discourages learning from <a href="https://www.joelonsoftware.com/2002/06/12/strategy-letter-v">your
complements</a>.&#34;
</p><p>
<em>2022</em>
</p><ul>
<li> The only way to guarantee you won&#39;t run afoul of <a href="https://www.hyrumslaw.com">Hyrum&#39;s
Law</a> is to make no updates.
</li><li> As a consequence, I don&#39;t care about Hyrum&#39;s Law. I make updates to the
best of my ability, trying not to break others, but I don&#39;t/can&#39;t guarantee
they won&#39;t break others.
</li><li> If my updates can break others, I can&#39;t push them to others without
explicit consent. Others have to pick them up on their own schedule, when they
have the time to test them for their own context.
</li><li> If my updates can break others, others may have to make changes to them
for themselves.
</li></ul>
<p>
Rather surprisingly, these baby steps lead to a world entirely different from
the one I live in. One where we don&#39;t have <a href="https://en.wikipedia.org/wiki/Interchangeable_parts">interchangeable
parts</a> yet, where software is often tweaked for a specific situation.
</p>
  
</div></div>
  </body>
</html>
