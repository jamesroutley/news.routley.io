<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hynek.me/articles/productive-fruit-fly-programmer/">Original</a>
    <h1>I’m a productive programmer with a memory of a fruit fly</h1>
    
    <div id="readability-page-1" class="page"><section><p>A love letter to tools that changed everything for me.</p><h2 id="programming-over-the-years">Programming Over the Years</h2><p>Programming got vastly more varied compared to when I started dabbling in <a href="https://en.wikipedia.org/wiki/AmigaBASIC"><em>AmigaBASIC</em></a> in the mid-1990s. Back then you could buy one very big book about the computer you’re programming and were 99% there. That book, full with earmarks and Post-its, lay next to you while hacking into your monochrome editor, always in reach.</p><p>Nowadays it can happen that the book on your frontend web framework is thicker than what a C64 programmer needed to write a complete game. On the other hand, the information for everything that we need to write code <em>today</em> is usually no more than one click away.</p><p>Nobody can imagine to pay for developer documentation – both <a href="https://learn.microsoft.com/en-us/windows/apps/desktop/">Microsoft</a> and <a href="https://developer.apple.com/documentation/">Apple</a> offer their documentation on the web for free for everyone. And don’t get me even started about open-source projects!</p><p>In times of <a href="https://www.npmjs.com"><em>npm</em></a>, <a href="https://pypi.org"><em>PyPI</em></a>, and GitHub, it’s hard to explain that requiring anything beyond what your operating system offers, used to be a controversial decision that had to be weighted judiciously. Often, you shipped your dependencies along with your product<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>.</p><hr/><p>The new availability is great and variety is healthy, but it leads to <strong>fragmentation of the information that you need to be productive</strong>.</p><p>People have dozens of tabs open<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup> with documentation for the packages they’re using at the moment, hectically switching between them to find the right one. As someone who has worked from the <a href="https://en.wikipedia.org/wiki/Muizenberg">best longboard spot in the world</a> where several 10,000s of people share <em>one</em> <a href="https://en.wikipedia.org/wiki/Point_of_presence">POP</a>, I can tell you that online-only docs aren’t only a problem when when your Internet dies altogether. Especially an online search function with flaky Internet is worse than no search function.</p><p>If you’re like me, and are a polyglot working with multiple programming languages with enormous sub-communities each (even within Python, <em>Flask</em> + <em>SQLAlchemy</em> + <em>Postgres</em> is a very different beast from writing <em>asyncio</em>-based network servers), it hurts my head to even imagine one could remember the arguments of every method I’m using. Primarily, if you’re <em>really</em> like me and barely remember your own phone number.</p><p>That’s why it was such a life-changing event for me when I found <a href="https://kapeli.com/dash"><em>Dash</em></a> in 2012.</p><h2 id="api-documentation-browsers">API Documentation Browsers</h2><blockquote><p>Your mind is for having ideas, not holding them.</p></blockquote><figure><a href="https://hynek.me/articles/productive-fruit-fly-programmer/dash-search.original.png" target="_blank"><picture><source type="image/webp" srcset="dash-search.webp"/><img src="https://hynek.me/articles/productive-fruit-fly-programmer/dash-search.png" alt="Dash searching"/></picture></a><figcaption><p><em>Dash</em> searching</p></figcaption></figure><p><em>Dash</em> gives me the superpower of having all relevant APIs one key press away:</p><ul><li>I press ⌥Space and a floating window pops up with an <em>activated</em> search bar,</li><li>I start typing the rough name of the API or topic,</li><li>I choose from the suggestions and land at the symbol within the official <em>project documentation</em>,</li><li>I press Escape, the floating window disappears and I can start typing code immediately because my editor is in focus again.</li><li>If I forget what I just read, I press ⌥Space again and the window pops up at the same position.</li></ul><p>All of this is <em>blazing fast</em> – I want to make such a round trip under 2 seconds. The forgotten bliss of native applications – yes I know about <a href="https://devdocs.io">‌https://devdocs.io</a>.</p><div><p><strong>Having <em>all</em> API docs one key press away is profoundly empowering.</strong></p><p>The less energy I spend trying to remember the argument of a function or the import path of a class, the more energy I can spend on thinking about the problem I’m solving.</p><p>I don’t consider myself particularly smart, so I take any opportunity to lower my mental load.</p></div><p>While <em>Dash</em> is a $30 Mac app<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup> (also available as part of <a href="https://setapp.com"><em>Setapp</em></a> subscriptions!), there’s the <strong>free Windows</strong> and <strong>Linux</strong> version called <a href="https://zealdocs.org"><em>Zeal</em></a>, and a $20 <strong>Windows</strong> app called <a href="https://velocity.silverlakesoftware.com"><em>Velocity</em></a>. <em>Of course</em> there’s also at least one <strong>Emacs</strong> package doing the same thing: <a href="https://github.com/dash-docs-el/helm-dash"><em>helm-dash</em></a>.</p><p>Meaning: you can have this API bliss on any platform! In the following I’ll only write about <em>Dash</em>, because that’s what I’m using, but unless noted otherwise, it applies to all of them.</p><p>The one thing they have in common is the format of the local documentation.</p><h2 id="documentation-sets">Documentation Sets</h2><p>They all use Apple’s <a href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/Documentation_Sets/010-Overview_of_Documentation_Sets/docset_overview.html#//apple_ref/doc/uid/TP40005266-CH13-SW6"><em>Documentation Set Bundles</em></a> (<em>docsets</em>) that are directories with the HTML documentation, metadata in an XML-based <a href="https://en.wikipedia.org/wiki/Property_list"><em>property list</em></a> and a search index in a <a href="https://sqlite.org"><em>SQLite</em></a> database:</p><div><pre tabindex="0"><code data-lang="plain"><span><span>some.docset
</span></span><span><span>└── Contents
</span></span><span><span>    ├── Info.plist # ← metadata
</span></span><span><span>    └── Resources
</span></span><span><span>        ├── Documents # ← root dir of HTML docs
</span></span><span><span>        │   └── index.html
</span></span><span><span>        └── docSet.dsidx  # ← SQLite db w/ search index
</span></span></code></pre></div><p>If you have a bunch of HTML files on your disk, you can convert it into a <em>docset</em> that can be consumed by <em>Dash</em>. It’s just HTML files with metadata. And since it’s HTML files on <strong>your disk</strong>, all this works <strong>offline</strong>.</p><p>Therefore, <em>docsets</em> can replace documentation that you already keep locally on your computer for faster and/or offline access without doing anything special. Just package it up into the necessary directory structure, <a href="https://kapeli.com/docsets#createsqlite">add an empty index</a>, and fill out simple metadata.</p><p><em>Shazam</em>! Now you can conjure them with a single keypress and get rid of them with another.</p><hr/><p>Let’s circle back to the boring history lesson from the beginning: there’s a myriad of projects that I use across countless platforms – every day. And I’m not talking just about programming APIs here: <em>Ansible</em> roles, CSS classes, <em>HAProxy</em> configuration, <em>Postgres</em> (and SQL!) peculiarities…<strong>it’s a lot</strong>.</p><figure><a href="https://hynek.me/articles/productive-fruit-fly-programmer/dash-docsets.original.png" target="_blank"><picture><source type="image/webp" srcset="dash-docsets.webp"/><img src="https://hynek.me/articles/productive-fruit-fly-programmer/dash-docsets.png" alt="Installed Dash docsets"/></picture></a><figcaption><p>Installed <em>Dash</em> <em>docsets</em></p></figcaption></figure><p>And while Python and Go core documentation ship with <em>Dash</em>, and while <a href="https://go.dev/blog/godoc"><em>Godoc</em></a> documentation can be added directly by URL<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup>, no matter how hard <em>Dash</em> will try: in the fragmented world of modern software development, it will never be able to deliver everything I need.</p><h3 id="sphinx">Sphinx</h3><p>The biggest gap for me is <a href="https://www.sphinx-doc.org"><em>Sphinx</em></a>-based docs that dominate (not only) the Python ecosystem.</p><p><em>Sphinx</em> is a language-agnostic framework to write documentation. Not just API docs or just narrative docs: <strong>all of it</strong>, with rich interlinking. It used to be infamous for forcing <a href="https://en.wikipedia.org/wiki/ReStructuredText"><em>reStructuredText</em></a> on its users, but nowadays more and more projects use the wonderful <a href="https://myst-parser.readthedocs.io/"><em>MyST</em> package</a> to do it in <em>Markdown</em>. If you have any preconceptions about the look of <em>Sphinx</em> documentation, I urge you to visit the <em><a href="https://sphinx-themes.org">Sphinx Themes Gallery</a></em> and see how pretty your docs can be. It’s written in Python, but it’s used widely, including Apple’s <a href="https://github.com/apple/swift/tree/main/docs"><em>Swift</em></a>, the <a href="https://github.com/llvm/llvm-project/tree/main/clang/docs"><em>LLVM</em> (<em>Clang</em>!) project</a>, or wildly popular <a href="https://github.com/guzzle/guzzle/tree/master/docs">PHP projects</a>.</p><p>And it offers the exact missing piece: an index for API entries, sections, glossary terms, configuration options, command line arguments, and more – all distributed throughout your documentation any way you like, but always mutually <em>linkable</em>. I find this wonderful particularly if you follow a systematic framework like <a href="https://diataxis.fr"><em>‌Diátaxis</em></a>.</p><p>The key component that makes this possible is technically just an extension: <a href="https://www.sphinx-doc.org/en/master/usage/extensions/intersphinx.html"><em>intersphinx</em></a>. Originally made for inter-project linking (hence the name) it offers a machine-readable index for us to take. That index grew so popular that it’s now supported by the <a href="https://www.mkdocs.org"><em>MkDocs</em></a> extension <a href="https://mkdocstrings.github.io"><em>mkdocstrings</em></a> and <a href="https://github.com/twisted/pydoctor"><em>pydoctor</em></a>. You can recognize <em>intersphinx</em>-compatible documentation exactly by that index file: <code>objects.inv</code>.</p><p>And that’s why, 10 years ago almost to the day, I’ve started the <em>doc2dash</em> project.</p><h2 id="doc2dash">doc2dash</h2><p><a href="https://github.com/hynek/doc2dash"><em>doc2dash</em></a> is a command line tool that you can get from my <a href="https://github.com/hynek/homebrew-tap"><em>Homebrew</em> tap</a>, download one of the <a href="https://hynek.me/til/python-portable-binaries/">pre-built binaries</a> for Linux, macOS, and Windows from its <a href="https://github.com/hynek/doc2dash/releases">release page</a>, or install from <a href="https://pypi.org/project/doc2dash/">PyPI</a>.</p><p>Then, all you have to do is to point it at a directory with <em>intersphinx</em>-compatible documentation and it will do everything necessary to give you a <em>docset</em>.</p><figure><a href="https://hynek.me/articles/productive-fruit-fly-programmer/doc2dash.original.png" target="_blank"><picture><source type="image/webp" srcset="doc2dash.webp"/><img src="https://hynek.me/articles/productive-fruit-fly-programmer/doc2dash.png" alt="doc2dash converting"/></picture></a><figcaption><p><em>doc2dash</em> converting</p></figcaption></figure><p>Please note that the name is <em><strong>doc</strong>2dash</em> and not <em>sphinx2dash</em>. It was always meant as a <em>framework</em> for writing high-quality converters, the first ones being <em>Sphinx</em> and <em>pydoctor</em>. That hope sadly didn’t work out, because – understandably – every community wanted to use their own language and tools.</p><p>Those tools usually look quite one-off to me though, so I’d like to re-emphasize that I would <em>love</em> to work with others adding support for other documentation formats. Don’t reinvent the wheel, the framework is all there! <a href="https://doc2dash.readthedocs.io/en/stable/extending/">It’s just a bunch of lines of code</a>! You don’t even have to share your parser with me and the world.</p><hr/><p>The fact that both <em>Dash</em> and <em>doc2dash</em> have existed well over a decade and I <em>still</em> see friends have a bazillion tabs with API docs open has been positively heartbreaking for me. I keep showing people <em>Dash</em> in action and they keep saying it’s cool, and put it on their <em>someday</em> list. Barring another nudge, <em>someday</em> never comes.</p><p>While the fruit-fly part of this article ends here, let me try to give you that nudge with a step-by-step tutorial such that <em>today</em> becomes <em>someday</em>!</p><h2 id="tutorial-convert-and-submit-your-docs">Tutorial: Convert and Submit Your Docs</h2><p>The goal of this tutorial is to teach you how to convert <em>intersphinx</em>-compatible documentation to a <em>docset</em> and how to submit it to <em>Dash</em>’s <a href="https://github.com/Kapeli/Dash-User-Contributions"><em>user-generated docset registry</em></a>, such that others don’t have to duplicate your work.</p><p>I’ll assume you have picked and installed your API browser of choice. It doesn’t matter which one you use, but the tutorial uses <em>Dash</em>. For <em>optionally</em> submitting the <em>docset</em> at the end, you’ll also need a basic understanding of GitHub and its <a href="https://docs.github.com/en/get-started/quickstart/contributing-to-projects">pull request workflow</a>.</p><p><strong>I</strong> will be using this tutorial as an occasion to <em>finally</em> start publishing <em>docsets</em> of my own projects, starting with <a href="https://www.structlog.org/"><em>structlog</em></a>. I suggest <strong>you</strong> pick an <em>intersphinx</em>-compatible project that isn’t supported by <em>Dash</em> yet and whose documentation’s tab you visit most often.</p><p>Let’s do this!</p><h3 id="getting-doc2dash">Getting doc2dash</h3><p>If you’re already using <a href="https://brew.sh/"><em>Homebrew</em></a>, the easiest way to get <em>doc2dash</em> is to use my <a href="https://github.com/hynek/homebrew-tap/">tap</a>:</p><div><pre tabindex="0"><code data-lang="console"><span><span><span>$</span> brew install hynek/tap/doc2dash
</span></span></code></pre></div><p>There are pre-built <a href="https://docs.brew.sh/Bottles"><em>bottles</em></a> for Linux <em>x86-64</em> and macOS on both <em>x86-64</em> and <em>Apple silicon</em>, so the installation should be very fast.</p><p>Unless you know your way around Python packaging, the next best way are pre-built binaries from the <a href="https://github.com/hynek/doc2dash/releases/latest">release page</a>. Currently it offers binaries for Linux, Windows, and macOS – all on <em>x86-64</em>. I hope to offer more in the future if this proves to be popular.</p><p>Finally, you can get it from <a href="https://pypi.org/project/doc2dash/">PyPI</a>. I <em>strongly</em> recommend to use <a href="https://pypa.github.io/pipx/"><em>pipx</em></a> and the easiest way to run <em>doc2dash</em> with it is:</p><div><pre tabindex="0"><code data-lang="console"><span><span><span>$</span> pipx run doc2dash --help
</span></span></code></pre></div><h3 id="building-documentation">Building Documentation</h3><p>Next comes the biggest problem and source of frequent feature requests for <em>doc2dash</em>: you need the documentation in a complete, built form. Usually that means that you have to download the repository and figure out how to build the docs before even installing <em>doc2dash</em> because most documentation sites unfortunately don’t offer a download of the whole thing.</p><p>My personal heuristic is to look for a <code>tox.ini</code> or <code>noxfile.py</code> first and see if it builds the documentation. If it doesn’t, I look for a <a href="https://dev.readthedocs.io/en/latest/design/yaml-file.html"><code>readthedocs.yml</code></a>, and if even that lets me down, I’m on the lookout for files named like <code>docs-requirements.txt</code> or optional installation targets like <code>docs</code>. My final hope is going through pages of YAML and inspecting CI configurations.</p><p>Once you’ve managed to install all dependencies, it’s usually just a matter of <code>make html</code> in the documentation directory.</p><hr/><p>After figuring this out, you should have a directory called <code>_build/html</code> for <em>Sphinx</em> or <code>site</code> for <em>MkDocs</em>.</p><div><p>Please note with <em>MkDocs</em> that if the project doesn’t use the <a href="https://mkdocstrings.github.io"><em>mkdocstrings</em></a> extension – which alas, right now is virtually all of the popular ones – there won’t be an <code>objects.inv</code> file and therefore no API data to be consumed.</p><p>I truly hope that more <em>MkDocs</em>-based projects add support for <em>mkdocstrings</em> in the future! As with <em>Sphinx</em>, it’s language-agnostic.</p></div><h3 id="converting">Converting</h3><p>Following the hardest step comes the easiest one: converting the documentation we’ve just built into a <em>docset</em>.</p><p>All you have to do is pointing <em>doc2dash</em> at the directory with HTML documentation and wait:</p><p>That’s all!</p><p><em>doc2dash</em> knows how to extract the name from the <em>intersphinx</em> index and uses it by default (you can override it with <code>--name</code>). You should be able to add this <em>docset</em> to an API browser of your choice and everything should work.</p><hr/><p>If you pass <code>--add-to-dash</code> or <code>-a</code>, the final <em>docset</em> is automatically added to <em>Dash</em> when it’s done. If you pass <code>--add-to-global</code> or <code>-A</code>, it moves the finished docset to a global directory (<code>~/Library/Application Support/doc2dash/DocSets</code>) and adds it from there. It’s rare that I run <em>doc2dash</em> without <code>-A</code> when creating <em>docset</em>s for myself.</p><h3 id="improving-your-documentation-set">Improving Your Documentation Set</h3><p><em>Dash</em>’s documentation has a <a href="https://kapeli.com/docsets#contributetodash">bunch of recommendations</a> of how you can improve the <em>docset</em> that we built in the previous step. It’s important to note that the next five steps are strictly optional and more often than not, I skip them, because I’m lazy.</p><p>But in this case, I want to submit the <em>docset</em> to <em>Dash</em>’s user-contributed registry, so let’s go the full distance!</p><h4 id="set-a-main-page">Set a Main Page</h4><p>With <em>Dash</em>, you can always search <em>all</em> installed <em>docsets</em>, but sometimes you want to limit the scope of search. For example when I type <code>p3:</code> (the colon is significant), switches to only searching Python 3 <em>docset</em>. Before you start typing, it offers you a menu underneath the search box whose first item is “Main Page”.</p><p>When converting <em>structlog</em> docs, this main page is the index which can be useful, but usually not what I want. When I got to the main page, I want to browse the narrative documentation.</p><p>The <em>doc2dash</em> option to set the main page is <code>--index-page</code> or <code>-I</code> and takes the file name of the page you want to use, relative to the documentation root.</p><p>Confusingly, the file name of the index is <code>genindex.html</code> and the file name of the main page is the HTML-typical <code>index.html</code>. Therefore, we’ll add <code>--index-page index.html</code> to the command line.</p><h4 id="add-an-icon">Add an Icon</h4><p>Documentation sets can have icons that are shown throughout <em>Dash</em> next to the <em>docsets</em>’s name and symbols. That’s pretty, but also helpful to recognize <em>docsets</em> faster and if you’re searching across multiple <em>docsets</em>, where a symbol is coming from.</p><p><em>structlog</em> has a cute beaver logo, so let’s use <a href="https://imagemagick.org/"><em>ImageMagick</em></a> to resize the logo to 16x16 pixels:</p><div><pre tabindex="0"><code data-lang="console"><span><span><span>$</span> magick <span>\
</span></span></span><span><span><span></span><span>    docs/_static/structlog_logo_transparent.png \
</span></span></span><span><span><span>    -resize 16x16 \
</span></span></span><span><span><span>    docs/_static/docset-icon.png
</span></span></span></code></pre></div><p>Now we can add it to the <em>docset</em> using the <code>--icon docset-icon.png</code> option.</p><h4 id="support-online-redirection">Support Online Redirection</h4><p>Offline docs are awesome, but sometimes it can be useful to jump to the online version of the documentation page you’re reading right now. A common reason is to peruse a newer or older version.</p><p><em>Dash</em> has the menu item “Open Online Page ⇧⌘B” for that, but it needs to know the base URL of the documentation. You can set that using <code>--online-redirect-url</code> or <code>-u</code>.</p><p>For Python packages on <a href="https://readthedocs.org"><em>Read the Docs</em></a> you can pick between the <code>stable</code> (last VCS tag) or <code>latest</code> (current main branch).</p><p>I think <code>latest</code> makes more sense, if you leave the comfort of offline documentation, thus I’ll add:</p><div><pre tabindex="0"><code data-lang="plaintext"><span><span>--online-redirect-url https://www.structlog.org/en/latest/
</span></span></code></pre></div><h4 id="putting-it-all-together">Putting It All Together</h4><p>We’re done! Let’s run the whole command line and see how it looks in <em>Dash</em>:</p><div><pre tabindex="0"><code data-lang="console"><span><span><span>$</span> doc2dash <span>\
</span></span></span><span><span><span></span><span>    --index-page index.html \
</span></span></span><span><span><span>    --icon docs/_static/docset-icon.png \
</span></span></span><span><span><span>    --online-redirect-url https://www.structlog.org/en/latest/ \
</span></span></span><span><span><span>    docs/_build/html
</span></span></span><span><span><span>Converting intersphinx docs from &#39;/Users/hynek/FOSS/structlog/docs/_build/html&#39; to &#39;structlog.docset&#39;.
</span></span></span><span><span><span>Parsing documentation...
</span></span></span><span><span><span>Added 238 index entries.
</span></span></span><span><span><span>Patching for TOCs... ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 100% 0:00:00
</span></span></span></code></pre></div><p>Wonderful:</p><figure><a href="https://hynek.me/articles/productive-fruit-fly-programmer/structlog-docset.original.png" target="_blank"><picture><source type="image/webp" srcset="structlog-docset.webp"/><img src="https://hynek.me/articles/productive-fruit-fly-programmer/structlog-docset.png" alt="structlog&amp;rsquo;s Main Page"/></picture></a><figcaption><p><em>structlog</em>’s Main Page</p></figcaption></figure><p>Notice the icon in the search bar and pressing ⇧⌘B on any page with any anchor takes me to the same place in the latest version of the online docs.</p><h4 id="automation">Automation</h4><p>Since I want to create a new version of the <em>docsets</em> for every new release, the creation needs to be automated. <em>structlog</em> is already using GitHub Actions as CI, so it makes sense to use it for building the docset too.</p><p>For local testing I’ll take advantage of <em>doc2dash</em> being a Python project and use a <a href="https://tox.wiki/"><em>tox</em></a> environment that reuses the dependencies that I use when testing documentation itself.</p><p>The environment installs <code>structlog[docs]</code> – i.e. the package with optional <code>docs</code> dependencies, plus <em>doc2dash</em>. Then it runs <code>commands</code> in order:</p><div><pre tabindex="0"><code data-lang="ini"><span><span><span>[testenv:docset]</span>
</span></span><span><span><span>extras</span> <span>=</span> <span>docs</span>
</span></span><span><span><span>deps</span> <span>=</span> <span>doc2dash</span>
</span></span><span><span><span>allowlist_externals</span> <span>=</span><span>
</span></span></span><span><span><span>    rm
</span></span></span><span><span><span>    cp
</span></span></span><span><span><span>    tar</span>
</span></span><span><span><span>commands</span> <span>=</span><span>
</span></span></span><span><span><span>    rm -rf structlog.docset docs/_build
</span></span></span><span><span><span>    sphinx-build -n -T -W -b html -d {envtmpdir}/doctrees docs docs/_build/html
</span></span></span><span><span><span>    doc2dash --index-page index.html --icon docs/_static/docset-icon.png --online-redirect-url https://www.structlog.org/en/latest/ docs/_build/html
</span></span></span><span><span><span>    cp docs/_static/docset-icon@2x.png structlog.docset/icon@2x.png
</span></span></span><span><span><span>    tar --exclude=&#39;.DS_Store&#39; -cvzf structlog.tgz structlog.docset</span>
</span></span></code></pre></div><p>Now I can build a <em>docset</em> just by calling <code>tox -e docset</code>. <a href="https://github.com/hynek/doc2dash/issues/130">Until <em>doc2dash</em> supports hi-res icons</a>, it also copies a 32x32 pixels big version of the logo directly into the <em>docset</em>.</p><p>Doing that in CI is trivial, but entails tons of boilerplate, so I’ll just <a href="https://github.com/hynek/structlog/blob/main/.github/workflows/build-docset.yml">link to the workflow</a>. Note the <code>upload-artifact</code> action at the end that allows me to download the built <em>docset</em>s from the run summaries<sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup>.</p><hr/><p>At this point we have a <em>great</em> <em>docset</em> that’s built <em>automatically</em>. Time to share it with the world!</p><h3 id="submitting">Submitting</h3><p>In the final step we’ll submit our <em>docset</em> to <em>Dash</em>’s user-contributed repository, so other people can download it comfortably from <em>Dash</em>’s GUI. Conveniently, <em>Dash</em> uses a concept for the <a href="https://github.com/Kapeli/Dash-User-Contributions#contribute-a-new-docset">whole process</a> that’s probably familiar to every open-source aficionado<sup id="fnref:6"><a href="#fn:6" role="doc-noteref">6</a></sup>: GitHub pull requests.</p><p>First step is checking the <a href="https://github.com/Kapeli/Dash-User-Contributions/wiki/Docset-Contribution-Checklist"><em>Docset Contribution Checklist</em></a>. Fortunately we – or in some cases <em>doc2dash</em> – have already taken care of everything!</p><p>So let’s move right along, and fork the <a href="https://github.com/Kapeli/Dash-User-Contributions">https://github.com/Kapeli/Dash-User-Contributions</a> repo and clone it to your computer.</p><p>First, you have to copy the <code>Sample_Docset</code> directory into <code>docsets</code> and rename it while doing so. For me the command line is therefore:</p><div><pre tabindex="0"><code data-lang="console"><span><span><span>$</span> cp -a Sample_Docset docsets/structlog
</span></span></code></pre></div><p>Let’s enter the directory with <code>cd docsets/structlog</code> and take it from there further.</p><p>The main step is adding the <em>docset</em> itself – but as a <em>gzipped</em> <em>tar</em> file. The contribution guide even gives us the template for creating it. In my case the command line is:</p><div><pre tabindex="0"><code data-lang="console"><span><span><span>$</span> tar --exclude<span>=</span><span>&#39;.DS_Store&#39;</span> -cvzf structlog.tgz structlog.docset
</span></span></code></pre></div><p>You may have noticed that I’ve already done the <em>tar</em>-ing in my <em>tox</em> file, so I just have to copy it over:</p><div><pre tabindex="0"><code data-lang="console"><span><span><span>$</span> cp ~/FOSS/structlog/structlog.tgz .
</span></span></code></pre></div><p>It also wants the icons <em>additionally</em> to what is in the <em>docset</em>, so I copy them from them docset:</p><div><pre tabindex="0"><code data-lang="console"><span><span><span>$</span> cp ~/FOSS/structlog/structlog.docset/icon* .
</span></span></code></pre></div><p>Next, it would like us to fill in metadata in the <code>docset.html</code> file which is straightforward in my case:</p><div><pre tabindex="0"><code data-lang="json"><span><span><span>{</span>
</span></span><span><span>    <span>&#34;name&#34;</span><span>:</span> <span>&#34;structlog&#34;</span><span>,</span>
</span></span><span><span>    <span>&#34;version&#34;</span><span>:</span> <span>&#34;22.1.0&#34;</span><span>,</span>
</span></span><span><span>    <span>&#34;archive&#34;</span><span>:</span> <span>&#34;structlog.tgz&#34;</span><span>,</span>
</span></span><span><span>    <span>&#34;author&#34;</span><span>:</span> <span>{</span>
</span></span><span><span>        <span>&#34;name&#34;</span><span>:</span> <span>&#34;Hynek Schlawack&#34;</span><span>,</span>
</span></span><span><span>        <span>&#34;link&#34;</span><span>:</span> <span>&#34;https://github.com/hynek&#34;</span>
</span></span><span><span>    <span>},</span>
</span></span><span><span>    <span>&#34;aliases&#34;</span><span>:</span> <span>[]</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Finally, it wants us to write some documentation about who we are and how to build the <em>docset</em>. After looking at other <a href="https://github.com/Kapeli/Dash-User-Contributions/tree/master/docsets">examples</a>, I’ve settled on the following:</p><div><pre tabindex="0"><code data-lang="markdown"><span><span><span># structlog
</span></span></span><span><span><span></span>
</span></span><span><span><span>&lt;</span><span>https:</span><span>//</span><span>www</span><span>.</span><span>structlog</span><span>.</span><span>org</span><span>/&gt;</span>
</span></span><span><span>
</span></span><span><span>Maintained by [<span>Hynek Schlawack</span>](<span>https://github.com/hynek/</span>).
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>## Building the Docset
</span></span></span><span><span><span></span>
</span></span><span><span><span>### Requirements
</span></span></span><span><span><span></span>
</span></span><span><span><span>-</span> Python 3.10
</span></span><span><span><span>-</span> [<span>*tox*</span>](<span>https://tox.wiki/</span>)
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>### Building
</span></span></span><span><span><span></span>
</span></span><span><span><span>1.</span> Clone the [<span>*structlog* repository</span>](<span>https://github.com/hynek/structlog</span>).
</span></span><span><span><span>2.</span> Check out the tag you want to build.
</span></span><span><span><span>3.</span> <span>`tox -e docset`</span> will build the documentation and convert it into <span>`structlog.docset`</span> in one step.
</span></span></code></pre></div><p>The <em>tox</em> trick is paying off – I don’t have to explain Python packaging to anyone!</p><p>Don’t forget to delete stuff from the sample <em>docset</em> that we don’t use:</p><div><pre tabindex="0"><code data-lang="console"><span><span><span>$</span> rm -r versions Sample_Docset.tgz
</span></span></code></pre></div><hr/><p>We’re done! Let’s check in our changes:</p><div><pre tabindex="0"><code data-lang="console"><span><span><span>$</span> git checkout -b structlog
</span></span><span><span><span>$</span> git add docsets/structlog
</span></span><span><span><span>$</span> git commit -m <span>&#34;Add structlog docset&#34;</span>
</span></span><span><span><span>[structlog 33478f9] Add structlog docset
</span></span></span><span><span><span> 5 files changed, 30 insertions(+)
</span></span></span><span><span><span> create mode 100644 docsets/structlog/README.md
</span></span></span><span><span><span> create mode 100644 docsets/structlog/docset.json
</span></span></span><span><span><span> create mode 100644 docsets/structlog/icon.png
</span></span></span><span><span><span> create mode 100644 docsets/structlog/icon@2x.png
</span></span></span><span><span><span> create mode 100644 docsets/structlog/structlog.tgz
</span></span></span><span><span><span> $ git push -u
</span></span></span></code></pre></div><p>Looking good – time for a <a href="https://github.com/Kapeli/Dash-User-Contributions/pull/3891">pull request</a>!</p><p>A few hours later:</p><figure><a href="https://hynek.me/articles/productive-fruit-fly-programmer/dash-contributed.original.png" target="_blank"><picture><source type="image/webp" srcset="dash-contributed.webp"/><img src="https://hynek.me/articles/productive-fruit-fly-programmer/dash-contributed.png" alt="Our contributed structlog docset inside Dash!"/></picture></a><figcaption><p>Our contributed <em>structlog</em> <em>docset</em> inside <em>Dash</em>!</p></figcaption></figure><p>Big success: everyone can download the <em>structlog</em> <em>Documentation Set</em> now which concludes our little tutorial!</p><h2 id="closing">Closing</h2><p>I hope I have both piqued your interest in API documentation browsers and demystified the creation of your own documentation sets. My goal is to turbocharge programmers who – like me – are overwhelmed by all the packages they have to keep in mind while getting stuff done.</p><p>My biggest hope, though, is that this article inspires someone to help me adding more formats to <em>doc2dash</em>, such that even more programmers get to enjoy the bliss of API documentation at their fingertips.</p><p>I’ve done a terrible job at promoting <em>doc2dash</em> in the past decade and I hope the next ten years will go better!</p></section></div>
  </body>
</html>
