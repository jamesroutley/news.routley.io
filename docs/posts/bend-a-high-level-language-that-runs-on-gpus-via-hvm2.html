<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/HigherOrderCO/Bend">Original</a>
    <h1>Bend: a high-level language that runs on GPUs (via HVM2)</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">Bend is a massively parallel, high-level programming language.</p>
<p dir="auto">Unlike low-level alternatives like CUDA and Metal, Bend has the feeling and
features of expressive languages like Python and Haskell, including fast object
allocations, higher-order functions with full closure support, unrestricted
recursion, even continuations. Yet, it runs on massively parallel hardware like
GPUs, with near-linear speedup based on core count, and zero explicit parallel
annotations: no thread spawning, no locks, mutexes, atomics. Bend is powered by
the <a href="https://github.com/HigherOrderCO/hvm">HVM2</a> runtime.</p>

<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/VictorTaelin/media/blob/main/bend_live_demo.gif?raw=true"><img src="https://github.com/VictorTaelin/media/raw/main/bend_live_demo.gif?raw=true" alt="Bend live demo" data-animated-image=""/></a></p>

<blockquote>
<p dir="auto">Currently not working on Windows, please use <a href="https://learn.microsoft.com/en-us/windows/wsl/install" rel="nofollow">WSL2</a> as a workaround.</p>
</blockquote>
<p dir="auto">First, install <a href="https://www.oreilly.com/library/view/rust-programming-by/9781788390637/e07dc768-de29-482e-804b-0274b4bef418.xhtml" rel="nofollow">Rust nightly</a>. Then, install both HVM2 and Bend with:</p>
<div dir="auto" data-snippet-clipboard-copy-content="cargo +nightly install hvm
cargo +nightly install bend-lang"><pre>cargo +nightly install hvm
cargo +nightly install bend-lang</pre></div>
<p dir="auto">Finally, write some Bend file, and run it with one of these commands:</p>
<div dir="auto" data-snippet-clipboard-copy-content="bend run    &lt;file.hvm&gt; # uses the Rust interpreter (sequential)
bend run-c  &lt;file.hvm&gt; # uses the C interpreter (parallel)
bend run-cu &lt;file.hvm&gt; # uses the CUDA interpreter (massively parallel)"><pre>bend run    <span>&lt;</span>file.hvm<span>&gt;</span> <span><span>#</span> uses the Rust interpreter (sequential)</span>
bend run-c  <span>&lt;</span>file.hvm<span>&gt;</span> <span><span>#</span> uses the C interpreter (parallel)</span>
bend run-cu <span>&lt;</span>file.hvm<span>&gt;</span> <span><span>#</span> uses the CUDA interpreter (massively parallel)</span></pre></div>
<p dir="auto">You can also compile <code>Bend</code> to standalone C/CUDA files with <code>gen-c</code> and
<code>gen-cu</code>, for maximum performance. But keep in mind our code gen is still on its
infancy, and is nowhere as mature as SOTA compilers like GCC and GHC.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Parallel Programming in Bend</h2><a id="user-content-parallel-programming-in-bend" aria-label="Permalink: Parallel Programming in Bend" href="#parallel-programming-in-bend"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">To write parallel programs in Bend, all you have to do is... <strong>nothing</strong>. Other
than not making it <em>inherently sequential</em>! For example, the expression:</p>

<p dir="auto">Can <strong>not</strong> run in parallel, because <code>+4</code> depends on <code>+3</code> which
depends on <code>(1+2)</code>. But the following expression:</p>

<p dir="auto">Can run in parallel, because <code>(1+2)</code> and <code>(3+4)</code> are independent; and it <em>will</em>,
per Bend&#39;s fundamental pledge:</p>
<blockquote>
<p dir="auto">Everything that <strong>can</strong> run in parallel, <strong>will</strong> run in parallel.</p>
</blockquote>
<p dir="auto">For a more complete example, consider:</p>
<div dir="auto" data-snippet-clipboard-copy-content="# Sorting Network = just rotate trees!
def sort(d, s, tree):
  switch d:
    case 0:
      return tree
    case _:
      (x,y) = tree
      lft   = sort(d-1, 0, x)
      rgt   = sort(d-1, 1, y)
      return rots(d, s, lft, rgt)

# Rotates sub-trees (Blue/Green Box)
def rots(d, s, tree):
  switch d:
    case 0:
      return tree
    case _:
      (x,y) = tree
      return down(d, s, warp(d-1, s, x, y))

(...)"><pre><span># Sorting Network = just rotate trees!</span>
<span>def</span> <span>sort</span>(<span>d</span>, <span>s</span>, <span>tree</span>):
  <span>switch</span> <span>d</span>:
    <span>case</span> <span>0</span>:
      <span>return</span> <span>tree</span>
    <span>case</span> <span>_</span>:
      (<span>x</span>,<span>y</span>) <span>=</span> <span>tree</span>
      <span>lft</span>   <span>=</span> <span>sort</span>(<span>d</span><span>-</span><span>1</span>, <span>0</span>, <span>x</span>)
      <span>rgt</span>   <span>=</span> <span>sort</span>(<span>d</span><span>-</span><span>1</span>, <span>1</span>, <span>y</span>)
      <span>return</span> <span>rots</span>(<span>d</span>, <span>s</span>, <span>lft</span>, <span>rgt</span>)

<span># Rotates sub-trees (Blue/Green Box)</span>
<span>def</span> <span>rots</span>(<span>d</span>, <span>s</span>, <span>tree</span>):
  <span>switch</span> <span>d</span>:
    <span>case</span> <span>0</span>:
      <span>return</span> <span>tree</span>
    <span>case</span> <span>_</span>:
      (<span>x</span>,<span>y</span>) <span>=</span> <span>tree</span>
      <span>return</span> <span>down</span>(<span>d</span>, <span>s</span>, <span>warp</span>(<span>d</span><span>-</span><span>1</span>, <span>s</span>, <span>x</span>, <span>y</span>))

(...)</pre></div>
<p dir="auto">This
<a href="https://gist.github.com/VictorTaelin/face210ca4bc30d96b2d5980278d3921">file</a>
implements a sorting algorithm with just tree rotations. It is not the kind of
algorithm you&#39;d expect to run fast on GPUs. Yet, since it uses a
divide-and-conquer approach, which is <em>inherently parallel</em>, Bend will run it
multi-threaded. Some benchmarks:</p>
<ul dir="auto">
<li>
<p dir="auto">CPU, Apple M3 Max, 1 thread: <strong>12.15 seconds</strong></p>
</li>
<li>
<p dir="auto">CPU, Apple M3 Max, 16 threads: <strong>0.96 seconds</strong></p>
</li>
<li>
<p dir="auto">GPU, NVIDIA RTX 4090, 16k threads: <strong>0.21 seconds</strong></p>
</li>
</ul>
<p dir="auto">That&#39;s a <strong>57x speedup</strong> by doing nothing. No thread spawning, no explicit
management of locks, mutexes. We just asked bend to run our program on RTX, and
it did. Simple as that.</p>
<p dir="auto">Bend isn&#39;t limited to a specific paradigm, like tensors or matrices. Any
concurrent system, from shaders to Erlang-like actor models can be emulated on
Bend. For example, to render images in real time, we could simply allocate an
immutable tree on each frame:</p>
<div dir="auto" data-snippet-clipboard-copy-content="# given a shader, returns a square image
def render(depth, shader):
  bend d = 0, i = 0:
    when d &lt; depth:
      color = (fork(d+1, i*2+0), fork(d+1, i*2+1))
    else:
      width = depth / 2
      color = shader(i % width, i / width)
  return color

# given a position, returns a color
# for this demo, it just busy loops
def demo_shader(x, y):
  bend i = 0:
    when i &lt; 5000:
      color = fork(i + 1)
    else:
      color = 0x000001
  return color

# renders a 256x256 image using demo_shader
def main:
  return render(16, demo_shader)"><pre><span># given a shader, returns a square image</span>
<span>def</span> <span>render</span>(<span>depth</span>, <span>shader</span>):
  <span>bend</span> <span>d</span> <span>=</span> <span>0</span>, <span>i</span> <span>=</span> <span>0</span>:
    <span>when</span> <span>d</span> <span>&lt;</span> <span>depth</span>:
      <span>color</span> <span>=</span> (<span>fork</span>(<span>d</span><span>+</span><span>1</span>, <span>i</span><span>*</span><span>2</span><span>+</span><span>0</span>), <span>fork</span>(<span>d</span><span>+</span><span>1</span>, <span>i</span><span>*</span><span>2</span><span>+</span><span>1</span>))
    <span>else</span>:
      <span>width</span> <span>=</span> <span>depth</span> <span>/</span> <span>2</span>
      <span>color</span> <span>=</span> <span>shader</span>(<span>i</span> <span>%</span> <span>width</span>, <span>i</span> <span>/</span> <span>width</span>)
  <span>return</span> <span>color</span>

<span># given a position, returns a color</span>
<span># for this demo, it just busy loops</span>
<span>def</span> <span>demo_shader</span>(<span>x</span>, <span>y</span>):
  <span>bend</span> <span>i</span> <span>=</span> <span>0</span>:
    <span>when</span> <span>i</span> <span>&lt;</span> <span>5000</span>:
      <span>color</span> <span>=</span> <span>fork</span>(<span>i</span> <span>+</span> <span>1</span>)
    <span>else</span>:
      <span>color</span> <span>=</span> <span>0x000001</span>
  <span>return</span> <span>color</span>

<span># renders a 256x256 image using demo_shader</span>
<span>def</span> <span>main</span>:
  <span>return</span> <span>render</span>(<span>16</span>, <span>demo_shader</span>)</pre></div>
<p dir="auto">And it would actually work. Even involved algorithms, such as a <a href="https://github.com/HigherOrderCO/Bend/blob/main/examples/bitonic_sort.bend">Bitonic Sort
using tree rotations</a>, parallelize well on Bend.
Long-distance communication is performed by <em>global beta-reduction</em> (as per the
<a href="https://github.com/VictorTaelin/Interaction-Calculus">Interaction Calculus</a>),
and synchronized correctly and efficiently by
<a href="https://github.com/HigherOrderCO/HVM">HVM2</a>&#39;s <em>atomic linker</em>.</p>
<ul dir="auto">
<li>
<p dir="auto">To jump straight into action, check Bend&#39;s <a href="https://github.com/HigherOrderCO/bend/blob/main/GUIDE.md">GUIDE.md</a>.</p>
</li>
<li>
<p dir="auto">For an extensive list of features, check <a href="https://github.com/HigherOrderCO/bend/blob/main/FEATURES.md">FEATURES.md</a>.</p>
</li>
<li>
<p dir="auto">To understand the tech behind Bend, check HVM2&#39;s <a href="https://paper.higherorderco.com" rel="nofollow">paper</a>.</p>
</li>
<li>
<p dir="auto">Bend is developed by <a href="https://HigherOrderCO.com" rel="nofollow">HigherOrderCO.com</a> - join our <a href="https://discord.HigherOrderCO.com" rel="nofollow">Discord</a>!</p>
</li>
</ul>
</article></div></div>
  </body>
</html>
