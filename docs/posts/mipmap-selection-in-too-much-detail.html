<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pema.dev/2025/05/09/mipmaps-too-much-detail/">Original</a>
    <h1>Mipmap selection in too much detail</h1>
    
    <div id="readability-page-1" class="page"><div>
        <article>
  
  <time datetime="2025-05-09T00:00:00+00:00">09 May 2025</time>
  <p>In this post, I want to shed some light on something I’ve been wondering about for a while: How exactly are mipmap levels selected when sampling textures on the GPU? If you already know what mipmapping is, why we use it, and what pixel derivatives (<code>ddx()</code> / <code>ddy()</code>) are, you can skip to the section <a href="#d">Derivatives to mipmap levels</a>. The post does, however, assume some knowledge of graphics programming.</p>



<p>A very common operation in <a href="https://en.wikipedia.org/wiki/Shader">shaders</a> is texture sampling. In <a href="https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl">HLSL</a>, we typically use the <code>Texture2D.Sample()</code> function for this. For a regular 4-channel floating-point texture, the full function signature looks like this:</p>

<div><div><pre><code><span>float4</span> <span>Texture2D</span><span>.</span><span>Sample</span><span>(</span><span>SamplerState</span> <span>sampler</span><span>,</span> <span>float2</span> <span>location</span><span>);</span>
</code></pre></div></div>

<p>It takes as input a location to sample the texture at, and a <code>SamplerState</code>, which is an object containing metadata used to influence the sampling, like which <a href="https://en.wikipedia.org/wiki/Texture_filtering#Filtering_methods">texture filtering</a> mode should be used.</p>

<p>Here is an example of a simple fragment shader which shades each pixel by sampling a texture <code>_Texture</code> using the texture coordinates in the 0th UV channel:</p>

<div><div><pre><code><span>float4</span> <span>frag</span> <span>(</span><span>float2</span> <span>uv</span> <span>:</span> <span>TEXCOORD0</span><span>)</span> <span>:</span> <span>SV_Target</span>  
<span>{</span>  
    <span>return</span> <span>_Texture</span><span>.</span><span>Sample</span><span>(</span><span>sampler_Texture</span><span>,</span> <span>uv</span><span>);</span>  
<span>}</span>
</code></pre></div></div>

<p>When applied to a quadrilateral and fed a brick texture as input, we get this:
<img src="https://pema.dev/assets/AliasedBricks.png" alt=""/></p>

<p>Notice that the surface looks rather ‘pixelated’, especially near the far edge. This is called texture <a href="https://en.wikipedia.org/wiki/Aliasing">aliasing</a>. The root cause is that the size of the texture space region covered by a screen pixel varies with distance and viewing angle.
<img src="https://pema.dev/assets/MipmapAreaExplainer.png" alt=""/></p>
<blockquote>
  <p>Consider, for illustration, the tilted quadrilateral. Observe how the same area in screen space can correspond to very different areas in texture space. The blue square covers roughly 4 pixels, while the green one covers roughly 12, even though they have the same area in screen space.</p>
</blockquote>

<p>The more shallow the viewing angle, the more <a href="https://en.wikipedia.org/wiki/Texel_(graphics)">texels</a> are covered by each pixel on the screen. Since we only sample 1 texel for every screen pixel, most of the texels covered by the screen pixel are <em>aliased</em> into a single sample - the contribution from the covered texels that were not sampled is lost!</p>

<p>The typical solution to this is <a href="https://en.wikipedia.org/wiki/Mipmap">mipmapping</a> - we first generate a bunch of smaller versions of our texture, called <em>mipmaps</em>, by averaging texels from the higher resolution texture. As the mipmaps get smaller, their contents get more blurry. We are effectively applying a series of <a href="https://en.wikipedia.org/wiki/Low-pass_filter">low-pass filters</a> to the texture. We typically name the mipmaps using numbers, where 0 is the full resolution texture, and each subsequent number corresponds to a lower resolution texture. I’ll call these numbers ‘mipmap levels’.
<img src="https://pema.dev/assets/BrickMips.gif" alt=""/>
In cases where texture sampling would result in aliasing, because too many texels are covered by the screen pixel, we instead sample a lower resolution mipmap to mitigate it. That way, we get an approximate average of the texels in the covered area. Here’s the same setup before, but now with mipmapping enabled:
<img src="https://pema.dev/assets/MipmapExample.png" alt=""/>
I didn’t have to change the shader at all to achieve this - when <code>Texture2D.Sample()</code> is used, and the input texture contains mipmaps, the GPU will automatically select an appropriate mipmap level for each sample!</p>

<p>If you are like me, you won’t find this explanation very satisfying. The GPU does <em>some magic</em> to select a mipmap level? Ok - so how does it work? That’s what the rest of this post is about.</p>



<p>A common mental model for a fragment shader is “the piece of code inside of a big parallel for-loop iterating over every pixel on the screen”. The fragment shader is invoked for every pixel in parallel; each invocation gets a set of per-pixel inputs, and uses them to calculate the final color at that pixel. This is a fine mental model, but it doesn’t tell the full story.</p>

<p>In reality, fragment shaders aren’t invoked for every pixel in isolation - rather, they are invoked for 2x2 blocks of pixels, typically called “pixel quads”, or just “quads”. This setup allows us to approximate partial derivatives in screen space for any variable using the <a href="https://en.wikipedia.org/wiki/Finite_difference">finite difference</a> method! In HLSL, the functions to do this are called <code>ddx()</code> and <code>ddy()</code>, and return partial derivatives along the X and Y axes in screen space, respectively. You couldn’t implement these functions yourself - they are magic intrinsics which are implemented in hardware by subtracting the values associated with different pixels in the quad.</p>

<p>Now, observe what happens if we apply a small fragment shader that visualizes the partial derivatives along the Y-axis of the UV coordinates we were using to sample the texture from earlier:</p>

<div><div><pre><code><span>float4</span> <span>frag</span> <span>(</span><span>float2</span> <span>uv</span> <span>:</span> <span>TEXCOORD0</span><span>)</span> <span>:</span> <span>SV_Target</span>  
<span>{</span>  
    <span>// Multiply by 15 so we can actually see the derivatives,  </span>
    <span>// they are typically very small.</span>
    <span>return</span> <span>float4</span><span>(</span><span>ddy</span><span>(</span><span>uv</span><span>),</span> <span>0</span><span>,</span> <span>1</span><span>)</span> <span>*</span> <span>15</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>The more shallow the viewing angle, the larger the partial derivatives get. Additionally, the partial derivatives are larger further away from the camera. <img src="https://pema.dev/assets/PixelDerivatives.gif" alt=""/></p>

<p>These conditions line up well with the cases where texture sampling would result in ugly aliasing, so it shouldn’t come as a big surprise that the selection of mipmap levels has something to do with the partial derivatives of the input coordinates used to sample the texture. In fact, <code>Texture2D.Sample()</code> can be seen as syntax sugar for the more general <code>Texture2D.SampleGrad()</code> function:</p>

<div><div><pre><code><span>// These 2 lines of code are equivalent:</span>
<span>Texture2D</span><span>.</span><span>Sample</span><span>(</span><span>sampler</span><span>,</span> <span>location</span><span>);</span>
<span>Texture2D</span><span>.</span><span>SampleGrad</span><span>(</span><span>sampler</span><span>,</span> <span>location</span><span>,</span> <span>ddx</span><span>(</span><span>location</span><span>),</span> <span>ddy</span><span>(</span><span>location</span><span>));</span>
</code></pre></div></div>

<p><code>Texture2D.SampleGrad()</code> takes the partial derivatives of the sampling location explicitly, whereas <code>Texture2D.Sample()</code> implicitly calculates them using <code>ddx()</code> and <code>ddy()</code>. Passing these explicitly can be useful in cases where the sampling locations are warped in a way that prevents <code>ddx()</code> and <code>ddy()</code> from returning useful partial derivatives (for example, during <a href="https://iquilezles.org/articles/filteringrm/">textured raymarching</a> or parallax mapping). It also lets us use analytical partial derivatives in cases where we have a way to compute them.</p>

<p>This description still leaves an open question: How exactly does <code>Texture2D.SampleGrad()</code> use the input partial derivatives to determine which mipmap level to sample?</p>



<p><code>Texture2D.SampleGrad()</code> has some internal logic that maps from the partial derivatives of the sampling location to a specific mipmap level. This function directly corresponds to a hardware instruction on the GPU, though, so we unfortunately can’t just ‘look at the code’. To get a better idea of how it works, we can ask 2 questions: What does the mapping look like conceptually, and what does the hardware do in practice? Both questions are surprisingly difficult to find good answers to online, but I’ll tackle them both one by one.</p>

<h2 id="a">What does the mapping look like conceptually?</h2>

<p>One place you might think to look for information on how the mapping should work, is in the spec for your graphics library of choice. I find the <a href="https://registry.khronos.org/OpenGL/specs/es/3.0/es_spec_3.0.pdf">GLES3.0</a> spec particularly readable. According to section 3.8.10.1 “Scale Factor and Level of Detail”, the mipmap level is calculated like so:</p>

\[MipLevel(x, y) = log_2(\rho(x, y))\]

<p>Where \(x, y\) are the coordinates of the screen pixel, and \(\rho\) is a “scale factor” defined by:</p>

\[\rho = max\Bigg\{\sqrt{\bigg(\frac{\partial u}{\partial x}\bigg)^2 + \bigg(\frac{\partial v}{\partial x}\bigg)^2},\sqrt{\bigg(\frac{\partial u}{\partial y}\bigg)^2 + \bigg(\frac{\partial v}{\partial y}\bigg)^2}\Bigg\}\]

<p>Here, \(u\) and \(v\) denote the coordinates of the sampling location in texture space, scaled to the range \([0; TextureSize]\), so \(\frac{\partial u}{\partial x}\) for example is the partial derivative of the horizontal coordinate of the sampling location with respect to the \(x\), i.e. <code>ddx(u * textureSize)</code>.</p>

<p>That’s a bit of a mouthful, so let’s translate it to code:</p>

<div><div><pre><code><span>float</span> <span>MipLevel</span><span>(</span><span>float</span> <span>u</span><span>,</span> <span>float</span> <span>v</span><span>,</span> <span>float</span> <span>textureWidth</span><span>,</span> <span>float</span> <span>textureHeight</span><span>)</span>
<span>{</span>
    <span>float</span> <span>du_dx</span> <span>=</span> <span>ddx</span><span>(</span><span>u</span> <span>*</span> <span>textureWidth</span><span>);</span>
    <span>float</span> <span>dv_dx</span> <span>=</span> <span>ddx</span><span>(</span><span>v</span> <span>*</span> <span>textureHeight</span><span>);</span>
    <span>float</span> <span>du_dy</span> <span>=</span> <span>ddy</span><span>(</span><span>u</span> <span>*</span> <span>textureWidth</span><span>);</span>
    <span>float</span> <span>dv_dy</span> <span>=</span> <span>ddy</span><span>(</span><span>v</span> <span>*</span> <span>textureHeight</span><span>);</span>

    <span>float</span> <span>lengthX</span> <span>=</span> <span>sqrt</span><span>(</span><span>du_dx</span><span>*</span><span>du_dx</span> <span>+</span> <span>dv_dx</span><span>*</span><span>dv_dx</span><span>);</span>
    <span>float</span> <span>lengthY</span> <span>=</span> <span>sqrt</span><span>(</span><span>du_dy</span><span>*</span><span>du_dy</span> <span>+</span> <span>dv_dy</span><span>*</span><span>dv_dy</span><span>);</span>
    <span>float</span> <span>rho</span> <span>=</span> <span>max</span><span>(</span><span>lengthX</span><span>,</span> <span>lengthY</span><span>);</span>

    <span>return</span> <span>log2</span><span>(</span><span>rho</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>This should be <em>somewhat</em> intuitive - as the magnitude of the partial derivatives increase, so should the mipmap level. We only really care about the axis where the aliasing will be worst (the axis with the largest magnitude), hence the <code>max()</code>. The <code>log2()</code> accounts for the fact that each increment in mipmap level corresponds to sampling a texture that is half the size.</p>

<p>If you search around the web for how to calculate mipmap level manually, you will probably find a solution like this. However, as we will soon see, this is not the full story.</p>

<h2 id="c">What does the hardware actually do?</h2>

<p>Since <code>Texture2D.SampleGrad()</code> is implemented in hardware, we can’t look at the implementation directly. However, we <em>can</em> use observations of its behavior to deduce what it is doing. To facilitate this, I will first need a texture with mipmaps that are easily distinguishable from each other. Luckily, most graphics frameworks let you manually fill in the texture data for each mipmap - they don’t <em>have</em> to be blurry versions of the full-resolution texture. Since I’m using Unity for visualization, I wrote <a href="https://gist.github.com/pema99/c706b38eb94b13a1680c8635c180b228">a little script</a> that produces a texture where each mipmap is a single, bright, clearly distinguishable color. The resulting texture looks like this:
<img src="https://pema.dev/assets/WeirdMips.gif" alt=""/></p>

<p>Next, I wrote a shader that samples the texture using <code>Texture2D.SampleGrad()</code>, but where the sampling location is a constant, and the partial derivatives are based on UV coordinates. <code>Texture2D.SampleGrad()</code> takes a partial derivative of the sampling location for both the X and Y axes, each of which are 2-dimensional vectors, so this is technically a 6-dimensional function. Since we are keeping the sampling location fixed, it is a 4-dimensional function in practice. Functions of over 3 dimensions are a bit tricky to visualize, so I’ll focus on just the partial derivatives for the X axis for now, and leave the Y axis partial derivatives as 0:</p>

<div><div><pre><code><span>float4</span> <span>frag</span> <span>(</span><span>float2</span> <span>uv</span> <span>:</span> <span>TEXCOORD0</span><span>)</span> <span>:</span> <span>SV_Target</span>  
<span>{</span>  
    <span>// Scale UVs from [0; 1] to [-1; 1]</span>
    <span>float2</span> <span>scaledUV</span> <span>=</span> <span>(</span><span>uv</span> <span>-</span> <span>0</span><span>.</span><span>5</span><span>)</span> <span>*</span> <span>2</span><span>.</span><span>0</span><span>;</span>

    <span>// Sample texture at location (0.5, 0.5),</span>
    <span>// using X derivative = UV coords,</span>
    <span>// and Y derivative = 0.</span>
    <span>float2</span> <span>samplingLocation</span> <span>=</span> <span>0</span><span>.</span><span>5</span><span>;</span>
    <span>float2</span> <span>yDerivative</span> <span>=</span> <span>0</span><span>;</span>
    <span>float4</span> <span>hardwareSample</span> <span>=</span> <span>_MainTex</span><span>.</span><span>SampleGrad</span><span>(</span>
        <span>sampler_MainTex</span><span>,</span>
        <span>samplingLocation</span><span>,</span>
        <span>scaledUV</span><span>.</span><span>xy</span><span>,</span>
        <span>yDerivative</span><span>);</span>  
  
    <span>return</span> <span>hardwareSample</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>Applying this shader to a quadrilateral gives this result on my machine (GPU is an RTX 4070 super):
<img src="https://pema.dev/assets/NvidiaViz.png" alt=""/>
The image is scaled such that the bottom left corner corresponds to X-axis partial derivatives of (-1, -1), and the top right corner corresponds to (1, 1). The color at each pixel indicates which mipmap level is being sampled, when <code>Texture2D.SampleGrad()</code> is passed partial derivatives equal to the pixel coordinates.</p>

<p>When I first saw this result, I was a bit surprised. Why are there jagged edges!? The formulas described in the previous section should result in a bunch of perfect concentric circles! As it turns out, current graphics libraries leave the specifics of the implementation up to the GPU vendor, and only prescribe some loose criteria on the implementation. Nvidia cards use a particularly crude approximation.</p>

<blockquote>
  <p>Side note: This is just one of many pieces of functionality that differ in implementation across different vendors. It’s a pet peeve of mine when people assume that there is a “one true correct” implementation of pretty much anything in GPU-land. To name a few other areas where vendors differ: The precision of transcendentals like <code>cos(x)</code> and <code>sin(x)</code>, the implementation of AlphaToCoverage (AMD uses dithering), subtle differences in rasterizer output, especially with conservative rasterization, etc. This is unfortunately a big source of pain when doing image-based/golden-image testing for anything involving the graphics pipeline, and is one of the big reasons such test setups often have per-platform reference images, and use fuzzy comparisons.</p>
</blockquote>

<p>My next instinct was to determine which vendors <em>actually</em> differ in their implementation, and to what extent. I asked a bunch of friends to try it on their hardware and collected the results. I’m only rendering the quadrant with positive partial derivatives here, since the shape is symmetric anyway:
<img src="https://pema.dev/assets/VendorTable.png" alt=""/></p>

<p>A few notes on my findings:</p>

<ul>
  <li>All tested vendors seem to <em>roughly</em> agree on the mapping function. Every image resembles a set of concentric circles with the same radius. The extent to which the circle is approximated differs quite a bit across every vendor, though.</li>
  <li>No two vendors agree <em>entirely</em> on the implementation.</li>
  <li>All tested vendors seem to be consistent across their hardware lineup. Interestingly, AMD’s APUs are consistent with their dedicated GPUs.</li>
  <li>The result is the same across all the graphics libraries Unity supports (I checked).</li>
</ul>

<p>And with this, I present perhaps the first-ever GPU tier list ranked in order of fidelity of partial-derivative-to-mipmap-level-mapping-function (the only important metric, clearly): Adreno/Qualcomm &gt; AMD &gt; Intel &gt; MacBook/Apple &gt; Nvidia. You heard it here first, Nvidia hardware bad! (/s)</p>

<h2 id="exploring-the-full-4d-mapping-function">Exploring the full 4D mapping function</h2>

<p>In the previous visualizations of the partial-derivative-to-mipmap-level mapping function, I’ve only visualized the influence of X-axis partial derivatives and have left the Y-axis partial derivatives at (0, 0). Next, I’d like to visualize the influence of both axes simultaneously. The easiest way I found to visualize this 4-dimensional function is using a grid. In each grid cell, we will have an image where the X-axis partial derivatives vary. Each grid cell will use fixed values for the Y-axis partial derivative, the values depending on the location of the cell. This way, we can see 2-dimensional “slices” of the full function. I whipped up a Unity script to render that out using the shader from earlier, which produced this image:
<img src="https://pema.dev/assets/NvidiaTable.png" alt=""/></p>
<blockquote>
  <p>Note: This kind of visualization will pop up several times throughout the post, so it’s worth hammering in what we are looking at: The bottom left grid cell has constant Y-axis partial derivatives (0, 0), while the top right grid cell has constant Y-axis partial derivatives (1,1), all the cells between have constant Y-axis partial derivatives somewhere between 0 and 1. Within each grid cell, the local X and Y coordinates determine the X-axis partial derivatives. I’m only visualizing positive Y-axis partial derivatives, because the images for negative partial derivatives are just the same, but mirrored. The color once again indicates the selected mipmap level. Of course, this image is very vendor-specific - these images were all generated on an RTX 4070 Super.</p>
</blockquote>

<p>With this setup, we can easily compare what the hardware does to the proposed software implementation from the <a href="#a">What does the mapping look like conceptually?</a> section, using <code>Texture2D.SampleLevel()</code> to explicitly sample the mipmap level we have selected. Here’s the same image, but using the software implementation:
<img src="https://pema.dev/assets/WeirdMips%201.png" alt=""/>
That looks… quite different from the hardware implementation. As expected, the software implementation produces perfect circle patterns, while the hardware implementation approximates them. But additionally, the hardware implementation produces some kind of ellipse shape whenever <em>both</em> the X- and Y-axis partial derivatives have nonzero components, while the software implementation <em>only</em> ever produces perfect circles. This surprised me a bit when I first saw it, since I found no mention of this behavior during my initial research. This piqued my interest and drove me to attempt to reverse engineer the behavior. The answers were out there, I just had to dig a little deeper…</p>



<p>The first resource I managed to find, which made mention of an ellipse in the context of mipmap level selection, was the <a href="https://microsoft.github.io/DirectX-Specs/d3d/archive/D3D11_3_FunctionalSpec.htm">DirectX 11.3 Functional Spec</a> (praise be), in Section 7.18.11 “LOD Calculations”. I’ll briefly restate the relevant parts of the spec, then dissect them:</p>

<ul>
  <li>Given a pair of partial derivative vectors representing an elliptical transform, it is important to calculate LOD using a proper orthogonal Jacobian matrix, as described by <a href="https://www2.eecs.berkeley.edu/Pubs/TechRpts/1989/CSD-89-516.pdf">Heckbert 89</a>. When performing anisotropic filtering, it is also important to use these modified vectors to calculate the proper filtering footprint. D3D11.3 will allow approximations to this effect. The following describes the ideal transformation, given 2-dimensional vectors:</li>
</ul>

<div><div><pre><code><span>Implicit</span> <span>ellipse</span> <span>coefficients</span><span>:</span>

<span>A</span> <span>=</span> <span>dX</span><span>.</span><span>v</span> <span>^</span> <span>2</span> <span>+</span> <span>dY</span><span>.</span><span>v</span> <span>^</span> <span>2</span>
<span>B</span> <span>=</span> <span>-</span><span>2</span> <span>*</span> <span>(</span><span>dX</span><span>.</span><span>u</span> <span>*</span> <span>dX</span><span>.</span><span>v</span> <span>+</span> <span>dY</span><span>.</span><span>u</span> <span>*</span> <span>dY</span><span>.</span><span>v</span><span>)</span>
<span>C</span> <span>=</span> <span>dX</span><span>.</span><span>u</span> <span>^</span> <span>2</span> <span>+</span> <span>dY</span><span>.</span><span>u</span> <span>^</span> <span>2</span>
<span>F</span> <span>=</span> <span>(</span><span>dX</span><span>.</span><span>u</span> <span>*</span> <span>dY</span><span>.</span><span>v</span> <span>-</span> <span>dY</span><span>.</span><span>u</span> <span>*</span> <span>dX</span><span>.</span><span>v</span><span>)</span> <span>^</span> <span>2</span>
</code></pre></div></div>

<ul>
  <li>Defining the following variables:</li>
</ul>

<div><div><pre><code><span>p</span> <span>=</span> <span>A</span> <span>-</span> <span>C</span>
<span>q</span> <span>=</span> <span>A</span> <span>+</span> <span>C</span>
<span>t</span> <span>=</span> <span>sqrt</span><span>(</span><span>p</span> <span>^</span> <span>2</span> <span>+</span> <span>B</span> <span>^</span> <span>2</span><span>)</span>
</code></pre></div></div>

<ul>
  <li>The new vectors may be then calculated as:</li>
</ul>

<div><div><pre><code><span>new_dX</span><span>.</span><span>u</span> <span>=</span> <span>sqrt</span><span>(</span><span>F</span> <span>*</span> <span>(</span><span>t</span><span>+</span><span>p</span><span>)</span> <span>/</span> <span>(</span> <span>t</span> <span>*</span> <span>(</span><span>q</span><span>+</span><span>t</span><span>)))</span>
<span>new_dX</span><span>.</span><span>v</span> <span>=</span> <span>sqrt</span><span>(</span><span>F</span> <span>*</span> <span>(</span><span>t</span><span>-</span><span>p</span><span>)</span> <span>/</span> <span>(</span> <span>t</span> <span>*</span> <span>(</span><span>q</span><span>+</span><span>t</span><span>)))</span><span>*</span><span>sgn</span><span>(</span><span>B</span><span>)</span>
<span>new_dY</span><span>.</span><span>u</span> <span>=</span> <span>sqrt</span><span>(</span><span>F</span> <span>*</span> <span>(</span><span>t</span><span>-</span><span>p</span><span>)</span> <span>/</span> <span>(</span> <span>t</span> <span>*</span> <span>(</span><span>q</span><span>-</span><span>t</span><span>)))</span><span>*-</span><span>sgn</span><span>(</span><span>B</span><span>)</span>
<span>new_dY</span><span>.</span><span>v</span> <span>=</span> <span>sqrt</span><span>(</span><span>F</span> <span>*</span> <span>(</span><span>t</span><span>+</span><span>p</span><span>)</span> <span>/</span> <span>(</span> <span>t</span> <span>*</span> <span>(</span><span>q</span><span>-</span><span>t</span><span>)))</span>
</code></pre></div></div>

<ul>
  <li>The following caveats also apply:
    <ul>
      <li>if either of dX or dY are of zero length, an implementation should skip these transformations.</li>
      <li>if dX and dY are parallel, an implementation should skip these transformations.</li>
      <li>if dX and dY are perpendicular, an implementation should skip these transformations.</li>
      <li>if any component of dX or dY is inf or NaN, an implementation should skip these transformations.</li>
      <li>if components of dX and dY are large or small enough to cause NaNs in these calculations, an implementation should skip these transformations.</li>
    </ul>
  </li>
  <li>if(ComputeIsotropicLOD), the LOD calculation is:</li>
</ul>

<div><div><pre><code><span>float</span> <span>lengthX</span> <span>=</span> <span>sqrt</span><span>(</span><span>dX</span><span>.</span><span>u</span><span>*</span><span>dX</span><span>.</span><span>u</span> <span>+</span> <span>dX</span><span>.</span><span>v</span><span>*</span><span>dX</span><span>.</span><span>v</span> <span>+</span> <span>dX</span><span>.</span><span>w</span><span>*</span><span>dX</span><span>.</span><span>w</span><span>)</span>
<span>float</span> <span>lengthY</span> <span>=</span> <span>sqrt</span><span>(</span><span>dY</span><span>.</span><span>u</span><span>*</span><span>dY</span><span>.</span><span>u</span> <span>+</span> <span>dY</span><span>.</span><span>v</span><span>*</span><span>dY</span><span>.</span><span>v</span> <span>+</span> <span>dY</span><span>.</span><span>w</span><span>*</span><span>dY</span><span>.</span><span>w</span><span>)</span>
<span>output</span><span>.</span><span>LOD</span> <span>=</span> <span>log2</span><span>(</span><span>max</span><span>(</span><span>lengthX</span><span>,</span><span>lengthY</span><span>))</span>
</code></pre></div></div>

<p>Phew, that’s a bit of a mouthful… In the snippets from the spec, <code>dX</code> and <code>dY</code> represent the X- and Y-axis partial derivatives we’ve discussed previously. The <code>w</code> component of these vectors is only used for 3D- and cubemap textures, so it isn’t relevant here. Notice that the code in the very last snippet looks almost exactly like the software implementation we tested earlier. However, most of the text before that snippet describes some kind of ‘elliptical’ transformation that should be applied to the partial derivatives before we calculate their lengths. This sounds quite promising, so let’s try to grok what the spec is prescribing.</p>

<h2 id="missing-elliptical-transformation">Missing elliptical transformation</h2>

<h3 id="side-quest-texture-filtering-theory-and-vector-calculus">Side quest: Texture filtering theory and vector calculus</h3>

<p>Before I can describe the elliptical transformation, we need to visit a few ideas from the theory of texture filtering and from vector calculus. If you are already familiar with jacobians and the concept of pixel footprint, you can probably skip to the next section <a href="#b">Understanding the elliptical transformation</a>.</p>

<p>A naïve approach to rendering a textured surface is this: For each screen pixel, determine the corresponding point on the surface, find its corresponding point in texture space, then read the value in the texture nearest to this point. As we’ve established earlier, this approach causes aliasing; when a screen pixel covers too many texels, and only one texel is sampled, the contribution from most of the covered texels is lost. A better approach would be to <em>integrate</em> over the area covered by each screen pixel, gathering contribution from all the covered texels. Mipmapping is a cheap way to approximate this integral using precomputed tables.</p>

<p>Ideally, we’d like to integrate over the projection of the screen pixel onto the texture. This projection is called the “footprint” of the pixel. To do this, we want to know how a unit area in screen space (i.e., a pixel) is transformed when projecting into texture space. The typical mathematical tool for describing changes in area due to mappings between spaces, such as projection, is called “the <a href="https://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant">jacobian matrix</a>” or just “the jacobian”. When used to transform a point, the jacobian of the mapping provides the best linear approximation of the mapping at that point. When the jacobian is a square matrix, its <a href="https://en.wikipedia.org/wiki/Determinant">determinant</a> describes how much space is ‘stretched’ at that point. The jacobian is constructed from first-order partial derivatives of coordinates in the input space with respect to coordinates in the output space. In our case, the input space is screen space, and the output space is texture space. The jacobian looks like this:</p>

\[\Large \begin{bmatrix}
\frac{\partial u}{\partial x} &amp; \frac{\partial u}{\partial y} \\
\frac{\partial v}{\partial x} &amp; \frac{\partial v}{\partial y}
\end{bmatrix}\]

<p>Where \((u, v)\) are coordinates in texture space, and \((x, y)\) are coordinates in screen space. If you’ve paid attention so far, this might ring a few bells - these partial derivatives can be calculated in HLSL using <code>ddx()</code> and <code>ddy()</code>. In other words, we can view the partial derivatives passed to <code>Texture2D.SampleGrad()</code> as forming a jacobian which describes the projective mapping involved in rendering the textured surface.</p>

<p>In reality, it is impractical to integrate over the <em>actual</em> footprint of a screen pixel, as it will in general be a <a href="https://en.wikipedia.org/wiki/Curvilinear_coordinates">curvilinear</a> quadrilateral (a quadrilateral with curved edges) - quite an unpleasant shape. Therefore, most approaches approximate it as either a regular quadrilateral or an ellipse, as illustrated in the figure below (<a href="https://resources.mpi-inf.mpg.de/departments/d4/teaching/ws200708/cg/slides/CG09-Textures+Filtering.pdf">Image source</a>).
<img src="https://pema.dev/assets/TextureMappingExplainer.png" alt=""/>
When using mipmapping, we are mostly interested in the <em>size</em> of the footprint. The larger the area, the larger mipmap level we need to use, since higher mipmap levels correspond to approximations of integrals over larger regions of the texture.</p>

<h3 id="b">Understanding the elliptical transformation</h3>

<p>With these concepts in mind, let us dissect the elliptical transformation described in the DirectX 11 spec. The first paragraph reads:</p>
<blockquote>
  <p>“Given a pair of partial derivative vectors <strong>representing an elliptical transform</strong>, it is important to calculate LOD using a <strong>proper orthogonal Jacobian matrix</strong>, as described by <a href="https://www2.eecs.berkeley.edu/Pubs/TechRpts/1989/CSD-89-516.pdf">Heckbert 89</a>.”</p>
</blockquote>

<p>I’ve highlighted the 2 important concepts with bold text. We have the partial derivatives of our texture sampling coordinates, but in what sense do these represent an elliptical transform? Imagine representing each screen pixel with a unit circle described by an angle \(\theta\), such that \(s(\theta)\) evaluates to all the points on the perimeter of the unit circle:</p>

\[\Large s(\theta)=
\begin{bmatrix}
cos(\theta) \\
sin(\theta)
\end{bmatrix}\]

<p>If we additionally construct the jacobian described in the previous section:</p>

\[\Large \begin{bmatrix}
\frac{\partial u}{\partial x} &amp; \frac{\partial u}{\partial y} \\
\frac{\partial v}{\partial x} &amp; \frac{\partial v}{\partial y}
\end{bmatrix}\]

<p>… And transform the unit circle with the jacobian via matrix multiplication to get a new function:</p>

\[\Large p(\theta) =
\begin{bmatrix}
\frac{\partial u}{\partial x} &amp; \frac{\partial u}{\partial y} \\
\frac{\partial v}{\partial x} &amp; \frac{\partial v}{\partial y}
\end{bmatrix}
\begin{bmatrix}
cos(\theta) \\
sin(\theta)
\end{bmatrix}\]

<p>The resulting function \(p(\theta)\) will describe <em>an ellipse</em>, where the 2 column vectors of the jacobian (i.e., the X- and Y-axis partial derivatives) are on the perimeter of the ellipse. In the special case where the column vectors are perpendicular and have the same length, the result is still just a (potentially scaled) circle. When the column vectors are perpendicular, but have different lengths, the result is an ellipse where the column vectors are the <a href="https://en.wikipedia.org/wiki/Semi-major_and_semi-minor_axes">semi-major and semi-minor axes</a> of the ellipse. If vectors are not perpendicular, this doesn’t apply.</p>

<p>That explains the first part of the paragraph, so what is the “proper orthogonal Jacobian matrix” part about? When the column vectors of the jacobian are not perpendicular, the jacobian does not form an orthogonal basis - shapes transformed by the jacobian will be <a href="https://en.wikipedia.org/wiki/Shear_mapping">sheared</a>. Recall that selecting a mipmap level involves calculating 2 lengths - in our software implementation from earlier, this was done like so:</p>

<div><div><pre><code><span>float</span> <span>lengthX</span> <span>=</span> <span>sqrt</span><span>(</span><span>du_dx</span><span>*</span><span>du_dx</span> <span>+</span> <span>dv_dx</span><span>*</span><span>dv_dx</span><span>);</span>
<span>float</span> <span>lengthY</span> <span>=</span> <span>sqrt</span><span>(</span><span>du_dy</span><span>*</span><span>du_dy</span> <span>+</span> <span>dv_dy</span><span>*</span><span>dv_dy</span><span>);</span>
</code></pre></div></div>

<p>When the column vectors of the jacobian are perpendicular, this code calculates the distance to the furthest point on the perimeter of an ellipse, whose semi-major and semi-minor axes are given by the column vectors. You can think of this as measuring how ‘stretched’ the ellipse is, along whichever axis is most stretched. That’s exactly what we want for mipmapping - the more stretched the elliptical footprint, the more texels it will cover, and the higher the mipmap level we need. However, when the column vectors are not perpendicular, the shearing breaks this stretch metric. We need to manually correct for this by calculating the metric in a different coordinate system. To do this, we need to <em>diagonalize</em> the ellipse.</p>

<p>Diagonalizing an ellipse means finding a coordinate system in which the ellipse is aligned with the axes. In particular, the major and minor axes should be aligned with the X and Y axis of the coordinate system. This eliminates the shearing, and allows us to calculate the stretch metric properly.</p>
<blockquote>
  <p>Note: For the curious reader, this ‘diagonalization’ is closely related to <a href="https://en.wikipedia.org/wiki/Diagonalizable_matrix#Diagonalization">matrix diagonalization</a>, which decomposes a matrix into its <a href="https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors">eigenvectors and eigenvalues</a>. In fact, ellipses can be represented as a 2x2 matrix whose eigenvectors give the direction of the major and minor semi-axes, and whose eigenvalues are related to the length of the axes.</p>
</blockquote>

<p>The next few paragraphs of the DirectX 11 spec describe an algorithm for performing this diagonalization, taken from <a href="https://www2.eecs.berkeley.edu/Pubs/TechRpts/1989/CSD-89-516.pdf">Heckbert 89</a>. The details of this algorithm are not so important, so I won’t describe them. Instead, to build intuition, I have implemented the algorithm in a graphing calculator, which lets us easily see what is going on:
<img src="https://pema.dev/assets/EllipseFootprint.png" alt=""/></p>
<blockquote>
  <p>Note: You can play with this interactive demo <a href="https://www.geogebra.org/classic/msau3zqx">here</a>.</p>
</blockquote>

<p>The image shows an elliptical footprint corresponding to a case where the X- and Y-axis partial derivatives (labelled \(d_x\), \(d_y\)) are not perpendicular. Notice how their length no longer describes the stretch of the ellipse. The outputs of the algorithm (labelled \(n_x\), \(n_y\)) are a set of new basis vectors describing the transformation to a coordinate space in which the ellipse is axis-aligned. These new basis vectors are the column vectors of our “proper orthogonal Jacobian matrix”. This new jacobian describes almost the same mapping as the original one, and would produce the exact same ellipse as the original when used to transform the unit circle. The only difference is where the basis vectors are pointing.</p>

<p>This visualization also shows why the DirectX spec provides a bunch of corner cases where the diagonalization should not be applied:</p>
<blockquote>
  <p>The following caveats also apply:</p>
  <ul>
    <li>if either of dX or dY are of zero length, an implementation should skip these transformations.</li>
    <li>if dX and dY are parallel, an implementation should skip these transformations.</li>
    <li>if dX and dY are perpendicular, an implementation should skip these transformations.</li>
    <li>if any component of dX or dY is inf or NaN, an implementation should skip these transformations.</li>
    <li>if components of dX and dY are large or small enough to cause NaNs in these calculations, an implementation should skip these transformations.</li>
  </ul>
</blockquote>

<p>If either partial derivative is zero length, the coordinate would be flattened to an infinite line.
<img src="https://pema.dev/assets/ParallelEllipse.png" alt=""/>
The same happens if the partial derivatives are parallel:
<img src="https://pema.dev/assets/ParallelEllipse2.png" alt=""/>
If the partial derivatives are perpendicular, there is no shearing, so performing the diagonalization is a waste of effort. Other than that, the final 2 points about inf and NaN are pretty self-explanatory.</p>

<p>With the elliptical transformation under our belt, let’s try adding it to our software implementation of mipmap level selection from earlier:</p>

<div><div><pre><code><span>void</span> <span>EllipseTransformDerivatives</span><span>(</span><span>inout</span> <span>float2</span> <span>dx</span><span>,</span> <span>inout</span> <span>float2</span> <span>dy</span><span>)</span>  
<span>{</span>  
    <span>bool</span> <span>anyZero</span> <span>=</span> <span>length</span><span>(</span><span>dx</span><span>)</span> <span>==</span> <span>0</span> <span>||</span> <span>length</span><span>(</span><span>dy</span><span>)</span> <span>==</span> <span>0</span><span>;</span>  
    <span>bool</span> <span>parallel</span> <span>=</span> <span>(</span><span>dx</span><span>.</span><span>x</span> <span>*</span> <span>dy</span><span>.</span><span>y</span> <span>-</span> <span>dx</span><span>.</span><span>y</span> <span>*</span> <span>dy</span><span>.</span><span>x</span><span>)</span> <span>==</span> <span>0</span><span>;</span>  
    <span>bool</span> <span>perpendicular</span> <span>=</span> <span>dot</span><span>(</span><span>dx</span><span>,</span> <span>dy</span><span>)</span> <span>==</span> <span>0</span><span>;</span>  
    <span>bool</span> <span>nonFinite</span> <span>=</span> <span>isinf</span><span>(</span><span>dx</span><span>)</span> <span>||</span> <span>isinf</span><span>(</span><span>dy</span><span>)</span> <span>||</span> <span>isnan</span><span>(</span><span>dx</span><span>)</span> <span>||</span> <span>isnan</span><span>(</span><span>dy</span><span>);</span>  
    <span>if</span> <span>(</span><span>!</span><span>anyZero</span> <span>&amp;&amp;</span> <span>!</span><span>parallel</span> <span>&amp;&amp;</span> <span>!</span><span>perpendicular</span> <span>&amp;&amp;</span> <span>!</span><span>nonFinite</span><span>)</span>  
    <span>{</span>        
        <span>float</span> <span>A</span> <span>=</span> <span>dx</span><span>.</span><span>y</span><span>*</span><span>dx</span><span>.</span><span>y</span> <span>+</span> <span>dy</span><span>.</span><span>y</span><span>*</span><span>dy</span><span>.</span><span>y</span><span>;</span>  
        <span>float</span> <span>B</span> <span>=</span> <span>-</span><span>2</span><span>.</span><span>0</span> <span>*</span> <span>(</span><span>dx</span><span>.</span><span>x</span> <span>*</span> <span>dx</span><span>.</span><span>y</span> <span>+</span> <span>dy</span><span>.</span><span>x</span> <span>*</span> <span>dy</span><span>.</span><span>y</span><span>);</span>  
        <span>float</span> <span>C</span> <span>=</span> <span>dx</span><span>.</span><span>x</span><span>*</span><span>dx</span><span>.</span><span>x</span> <span>+</span> <span>dy</span><span>.</span><span>x</span><span>*</span><span>dy</span><span>.</span><span>x</span><span>;</span>  
        <span>float</span> <span>F</span> <span>=</span> <span>(</span><span>dx</span><span>.</span><span>x</span> <span>*</span> <span>dy</span><span>.</span><span>y</span> <span>-</span> <span>dy</span><span>.</span><span>x</span> <span>*</span> <span>dx</span><span>.</span><span>y</span><span>)</span> <span>*</span> <span>(</span><span>dx</span><span>.</span><span>x</span> <span>*</span> <span>dy</span><span>.</span><span>y</span> <span>-</span> <span>dy</span><span>.</span><span>x</span> <span>*</span> <span>dx</span><span>.</span><span>y</span><span>);</span>  
        <span>float</span> <span>p</span> <span>=</span> <span>A</span> <span>-</span> <span>C</span><span>;</span>  
        <span>float</span> <span>q</span> <span>=</span> <span>A</span> <span>+</span> <span>C</span><span>;</span>  
        <span>float</span> <span>t</span> <span>=</span> <span>sqrt</span><span>(</span><span>p</span><span>*</span><span>p</span> <span>+</span> <span>B</span><span>*</span><span>B</span><span>);</span>  
        <span>float2</span> <span>newDx</span><span>,</span> <span>newDy</span><span>;</span>  
        <span>newDx</span><span>.</span><span>x</span> <span>=</span> <span>sqrt</span><span>(</span><span>F</span> <span>*</span> <span>(</span><span>t</span><span>+</span><span>p</span><span>)</span> <span>/</span> <span>(</span> <span>t</span> <span>*</span> <span>(</span><span>q</span><span>+</span><span>t</span><span>)));</span>  
        <span>newDx</span><span>.</span><span>y</span> <span>=</span> <span>sqrt</span><span>(</span><span>F</span> <span>*</span> <span>(</span><span>t</span><span>-</span><span>p</span><span>)</span> <span>/</span> <span>(</span> <span>t</span> <span>*</span> <span>(</span><span>q</span><span>+</span><span>t</span><span>)))</span><span>*</span><span>sign</span><span>(</span><span>B</span><span>);</span>  
        <span>newDy</span><span>.</span><span>x</span> <span>=</span> <span>sqrt</span><span>(</span><span>F</span> <span>*</span> <span>(</span><span>t</span><span>-</span><span>p</span><span>)</span> <span>/</span> <span>(</span> <span>t</span> <span>*</span> <span>(</span><span>q</span><span>-</span><span>t</span><span>)))</span><span>*-</span><span>sign</span><span>(</span><span>B</span><span>);</span>  
        <span>newDy</span><span>.</span><span>y</span> <span>=</span> <span>sqrt</span><span>(</span><span>F</span> <span>*</span> <span>(</span><span>t</span><span>+</span><span>p</span><span>)</span> <span>/</span> <span>(</span> <span>t</span> <span>*</span> <span>(</span><span>q</span><span>-</span><span>t</span><span>)));</span>  
  
        <span>bool</span> <span>failed</span> <span>=</span> <span>any</span><span>(</span><span>isnan</span><span>(</span><span>newDx</span><span>)</span> <span>||</span> <span>isinf</span><span>(</span><span>newDx</span><span>)</span> <span>||</span> <span>isnan</span><span>(</span><span>newDy</span><span>)</span> <span>||</span> <span>isinf</span><span>(</span><span>newDy</span><span>));</span>  
        <span>if</span> <span>(</span><span>!</span><span>failed</span><span>)</span>  
        <span>{</span>
            <span>dx</span> <span>=</span> <span>newDx</span><span>;</span>
            <span>dy</span> <span>=</span> <span>newDy</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>Rendering out the same visualization we used before:
<img src="https://pema.dev/assets/WeirdMips%204.png" alt=""/>
This looks a lot more similar to what the hardware implementation was doing!</p>

<h2 id="trilinear-filtering">Trilinear filtering</h2>

<p>All the visualizations I’ve made thus far have been without any kind of hardware texture filtering, and just use simple <a href="https://en.wikipedia.org/wiki/Nearest-neighbor_interpolation">nearest-neighbor interpolation</a>. Enabling <a href="https://learn.microsoft.com/en-us/windows/uwp/graphics-concepts/bilinear-texture-filtering">bilinear filtering</a> makes no difference, as it doesn’t affect how the mipmap level is selected. Enabling trilinear filtering, however, does make a difference. Rendered with the correct software implementation:
<img src="https://pema.dev/assets/WeirdMips%207.png" alt=""/>
And with hardware mipmap level selection:
<img src="https://pema.dev/assets/WeirdMips%208.png" alt=""/>
Trilinear filtering is just like bilinear filtering, but where we additionally interpolate between 2 mipmap levels. Without trilinear filtering, the selected mipmap level is just rounded to the nearest integer, and only one mipmap is sampled. With trilinear filtering, the floor and ceiling of the mipmap level are calculated, the 2 corresponding mipmaps are sampled, and the results are linearly interpolated using the fractional part of the mipmap level. This is why we’ve been calculating it as a <code>float</code> all along.</p>

<p>With that, harsh transitions between mipmap levels from the previous images are changed to smooth gradients. This is not very surprising, but I wanted to show that the software implementation continues to hold up when using trilinear filtering.</p>

<h2 id="anisotropic-filtering">Anisotropic filtering</h2>

<p>In addition to bilinear and trilinear filtering, most GPUs also support <a href="https://en.wikipedia.org/wiki/Anisotropic_filtering">anisotropic filtering</a>. Anisotropic filtering aims to alleviate one of the main issues with mipmapping. Mipmapping reduces aliasing from texture samples, but also introduces blurring, especially at shallow viewing angles. Anisotropic filtering effectively removes the blur by taking multiple texture samples from a higher resolution mipmap when the footprint of a pixel is unevenly stretched (<a href="https://en.wikipedia.org/wiki/Anisotropic_filtering#/media/File:Anisotropic_filtering_en.png">Image source</a>):
<img src="https://pema.dev/assets/TrilinearFilteringVsAniso.png" alt=""/>
The typical algorithm for anisotropic filtering works like this:</p>

<ol>
  <li>Determine the elliptical footprint of the screen pixel using the X- and Y-axis partial derivatives of the sampling location in texture space.</li>
  <li>Determine the semi-major and semi-minor axes of the ellipse. The semi-major (longer) axis is called the “axis of anisotropy”.</li>
  <li>Calculate the ratio of the lengths of the semi-major and semi-minor axes. This is called the “ratio of anisotropy”.</li>
  <li>Clamp the ratio of anisotropy to the maximum degree of anisotropy - this is typically a setting on the texture, with possible values ranging from 0 to 16. The maximum degree is sometimes called the “aniso level”.</li>
  <li>Calculate \(log_2(semiMinorAxisLength)\). This is the mipmap level to sample.</li>
  <li>Distribute sample points along the axis of anisotropy. The number of sample points depends on the clamped ratio of anisotropy.</li>
  <li>Sample the texture at each of the sample points and average their values.</li>
</ol>

<p>Notice that, unlike with regular mipmapping, where we use the length of the semi-major axis to select the mipmap level, we now use the length of the <em>semi-minor</em> axis. This is what mitigates the blurring caused by mipmapping - we sample a higher resolution texture when the pixel’s footprint is anisotropic (stretched differently on each axis). That <em>alone</em> would just reintroduce aliasing, so to mitigate this, we take more samples along the axis where they are needed most, effectively mitigating the added aliasing by supersampling, rather than blurring.</p>

<p>So, how does enabling anisotropic filtering change the visualization of mipmap level selection from before? To visualize this, I’ve upgraded our previous visualization to an animation. Since anisotropic filtering is parameterized by a maximum degree of anisotropy setting, the visualization is now an animation. Each maximum degree produces a different image:
<img src="https://pema.dev/assets/AnisoHW.gif" alt=""/>
When the maximum degree of anisotropy exceeds 0, the image no longer matches what our software implementation produced. This makes sense - anisotropic filtering affects mipmap level selection, but our implementation isn’t accounting for it.</p>

<p>Returning to the DirectX 11 spec, recall that the paragraph about the elliptical transform read: “[…] it is important to calculate LOD using a proper orthogonal Jacobian matrix, as described by [Heckbert 89]. <strong>When performing anisotropic filtering, it is also important to use these modified vectors to calculate the proper filtering footprint.</strong>”. I skipped over this part earlier, but it is exactly what we are missing. The spec further elaborates: “if(ComputeAnisotropicLOD), the LOD calculation is:”</p>

<div><div><pre><code><span>// Compute outputs:</span>
<span>// (1) float ratioOfAnisotropy</span>
<span>// (2) float anisoLineDirection</span>
<span>// (3) float LOD</span>

<span>float</span> <span>squaredLengthX</span> <span>=</span> <span>dX</span><span>.</span><span>u</span><span>*</span><span>dX</span><span>.</span><span>u</span> <span>+</span> <span>dX</span><span>.</span><span>v</span><span>*</span><span>dX</span><span>.</span><span>v</span>
<span>float</span> <span>squaredLengthY</span> <span>=</span> <span>dY</span><span>.</span><span>u</span><span>*</span><span>dY</span><span>.</span><span>u</span> <span>+</span> <span>dY</span><span>.</span><span>v</span><span>*</span><span>dY</span><span>.</span><span>v</span>
<span>float</span> <span>determinant</span> <span>=</span> <span>abs</span><span>(</span><span>dX</span><span>.</span><span>u</span><span>*</span><span>dY</span><span>.</span><span>v</span> <span>-</span> <span>dX</span><span>.</span><span>v</span><span>*</span><span>dY</span><span>.</span><span>u</span><span>)</span>
<span>bool</span> <span>isMajorX</span> <span>=</span> <span>squaredLengthX</span> <span>&gt;</span> <span>squaredLengthY</span>
<span>float</span> <span>squaredLengthMajor</span> <span>=</span> <span>isMajorX</span> <span>?</span> <span>squaredLengthX</span> <span>:</span> <span>squaredLengthY</span>
<span>float</span> <span>lengthMajor</span> <span>=</span> <span>sqrt</span><span>(</span><span>squaredLengthMajor</span><span>)</span>
<span>float</span> <span>normMajor</span> <span>=</span> <span>1</span><span>.</span><span>f</span><span>/</span><span>lengthMajor</span>

<span>output</span><span>.</span><span>anisoLineDirection</span><span>.</span><span>u</span> <span>=</span> <span>(</span><span>isMajorX</span> <span>?</span> <span>dX</span><span>.</span><span>u</span> <span>:</span> <span>dY</span><span>.</span><span>u</span><span>)</span> <span>*</span> <span>normMajor</span>
<span>output</span><span>.</span><span>anisoLineDirection</span><span>.</span><span>v</span> <span>=</span> <span>(</span><span>isMajorX</span> <span>?</span> <span>dX</span><span>.</span><span>v</span> <span>:</span> <span>dY</span><span>.</span><span>v</span><span>)</span> <span>*</span> <span>normMajor</span>

<span>output</span><span>.</span><span>ratioOfAnisotropy</span> <span>=</span> <span>squaredLengthMajor</span><span>/</span><span>determinant</span>

<span>// clamp ratio and compute LOD</span>
<span>float</span> <span>lengthMinor</span>
<span>// maxAniso comes from a Sampler state.</span>
<span>if</span> <span>(</span><span>output</span><span>.</span><span>ratioOfAnisotropy</span> <span>&gt;</span> <span>input</span><span>.</span><span>maxAniso</span><span>)</span>
<span>{</span>
<span> </span> <span> </span> <span>// ratio is clamped - LOD is based on ratio (preserves area)</span>
<span> </span> <span> </span> <span>output</span><span>.</span><span>ratioOfAnisotropy</span> <span>=</span> <span>input</span><span>.</span><span>maxAniso</span>
<span> </span> <span> </span> <span>lengthMinor</span> <span>=</span> <span>lengthMajor</span><span>/</span><span>output</span><span>.</span><span>ratioOfAnisotropy</span>
<span>}</span>
<span>else</span>
<span>{</span>
<span> </span> <span> </span> <span>// ratio not clamped - LOD is based on area</span>
<span> </span> <span> </span> <span>lengthMinor</span> <span>=</span> <span>determinant</span><span>/</span><span>lengthMajor</span>
<span>}</span>

<span>// clamp to top LOD</span>
<span>if</span> <span>(</span><span>lengthMinor</span> <span>&lt;</span> <span>1</span><span>.</span><span>0</span><span>)</span>
<span>{</span>
<span> </span> <span> </span> <span>output</span><span>.</span><span>ratioOfAnisotropy</span> <span>=</span> <span>MAX</span><span>(</span><span>1</span><span>.</span><span>0</span><span>,</span> <span>output</span><span>.</span><span>ratioOfAnisotropy</span><span>*</span><span>lengthMinor</span><span>)</span>
<span>}</span>

<span>output</span><span>.</span><span>LOD</span> <span>=</span> <span>log2</span><span>(</span><span>lengthMinor</span><span>);</span>
</code></pre></div></div>

<p>I’ve omitted some comments for brevity. The spec states that this code should run <em>after</em> applying the elliptical transformation from earlier. This is a pseudocode implementation of (part of) the algorithm for anisotropic filtering described earlier. It produces the ratio of anisotropy (<code>ratioOfAnisotropy</code>), the axis of anisotropy (<code>anisoLineDirection</code>), and the mipmap level (<code>LOD</code>).</p>

<p>To illustrate this, I’ve extended my interactive ellipse diagram from earlier with an implementation of the algorithm. As the partial derivative vectors move around, the axis of anisotropy remains the major axis of the ellipse, and the selected mipmap level depends on the size of the minor axis.
<img src="https://pema.dev/assets/AnisotropyGraphViz.gif" alt=""/></p>
<blockquote>
  <p>Note: You can play with the updated version of the diagram <a href="https://www.geogebra.org/classic/uyjgqzjj">here</a>.</p>
</blockquote>

<p>For now, only the portions of the pseudocode from the DirectX spec relating to mipmap level calculation are relevant. This pseudocode is straightforward to <a href="https://gist.github.com/pema99/9a2cd933332106915a970b96ce05e286">translate into real shader code</a>. Doing so yields the following:
<img src="https://pema.dev/assets/AnisoSW.gif" alt=""/>
Nice - we seem to have a pretty decent match with the hardware implementation…</p>

<p>There is one noteworthy difference, however. On my GPU, every other value for the max degree of anisotropy barely looks different from the previous one. For example, Degree=4 and Degree=5 look very similar, though there is a slight difference. Then Degree=5 and Degree=6 look completely different. In the software implementation, we don’t have any such behavior. I’m not quite sure what is going on here, and it is probably extremely vendor-specific.</p>

<h2 id="bonus-more-visualizations">Bonus: More visualizations</h2>

<p>To get a better feel for how the final software implementation of mipmap level selection compares to the hardware, I wrote a <a href="https://gist.github.com/pema99/b0d046a30afb0ca1b2fdc3e14b6c2920">small shader</a> that uses the software implementation on the left half of the screen, and the hardware implementation on the right. First, it can visualize which mipmap levels are chosen. Here’s with no filtering:
<img src="https://pema.dev/assets/MipSelectionComparison.gif" alt=""/>
And here is with 16x anisotropic filtering:
<img src="https://pema.dev/assets/AnisoMipComparison.gif" alt=""/>
Looks pretty good to me! Finally, we can visualize the actual effect of using these implementations on a typical textured surface:
<img src="https://pema.dev/assets/MipMapStrategyComparison.gif" alt=""/>
The halves are barely distinguishable to me! This is without anisotropic filtering, though. Unfortunately, we can’t visualize the difference with anisotropic filtering, as there is no way to manually specify the axis and ratio of anisotropy in shader code.</p>

<p>However, we can implement anisotropic filtering entirely in shadercode, by manually doing multiple samples. An implementation may look something like this:</p>

<div><div><pre><code><span>// Get mip level, aniso line direction, and ratio of anisotropy</span>
<span>float</span> <span>ratioOfAnisotropy</span><span>;</span>
<span>float2</span> <span>anisoLineDirection</span><span>;</span>
<span>float</span> <span>mipLevel</span> <span>=</span> <span>CalculateLodLevel</span><span>(</span>
    <span>_MainTex_TexelSize</span><span>.</span><span>zw</span><span>,</span> <span>ddx</span><span>(</span><span>i</span><span>.</span><span>uv</span><span>),</span> <span>ddy</span><span>(</span><span>i</span><span>.</span><span>uv</span><span>),</span>
    <span>_MaxAnisoLevel</span><span>,</span> <span>ratioOfAnisotropy</span><span>,</span> <span>anisoLineDirection</span><span>);</span>

<span>// Take multiple samples and average them</span>
<span>if</span> <span>(</span><span>ratioOfAnisotropy</span> <span>&gt;</span> <span>1</span><span>.</span><span>0</span><span>)</span>
<span>{</span>
    <span>ratioOfAnisotropy</span> <span>=</span> <span>ceil</span><span>(</span><span>ratioOfAnisotropy</span><span>);</span>
    <span>float4</span> <span>sum</span> <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>float</span> <span>anisoIdx</span> <span>=</span> <span>0</span><span>;</span> <span>anisoIdx</span> <span>&lt;</span> <span>ratioOfAnisotropy</span><span>;</span> <span>anisoIdx</span><span>++</span><span>)</span>
    <span>{</span>
        <span>// Convert ratio to [0; 1] space</span>
        <span>float2</span> <span>ratioInUVSpace</span> <span>=</span> <span>ratioOfAnisotropy</span> <span>*</span> <span>_MainTex_TexelSize</span><span>.</span><span>xy</span><span>;</span>

        <span>// Get start and end positions of the anisotropic line</span>
        <span>float2</span> <span>startPos</span> <span>=</span> <span>i</span><span>.</span><span>uv</span> <span>-</span> <span>anisoLineDirection</span> <span>*</span> <span>(</span><span>ratioInUVSpace</span> <span>/</span> <span>2</span><span>.</span><span>0</span><span>);</span>
        <span>float2</span> <span>endPos</span> <span>=</span> <span>startPos</span> <span>+</span> <span>anisoLineDirection</span> <span>*</span> <span>ratioInUVSpace</span><span>;</span>
        
        <span>// Get the current sample position</span>
        <span>float2</span> <span>samplePos</span> <span>=</span> <span>lerp</span><span>(</span><span>startPos</span><span>,</span> <span>endPos</span><span>,</span> <span>anisoIdx</span> <span>/</span> <span>(</span><span>ratioOfAnisotropy</span><span>-</span><span>1</span><span>));</span>

        <span>// Accumulate the sample</span>
        <span>sum</span> <span>+=</span> <span>_MainTex</span><span>.</span><span>SampleLevel</span><span>(</span><span>sampler_MainTex</span><span>,</span> <span>samplePos</span><span>,</span> <span>mipLevel</span><span>);</span>
    <span>}</span>
    <span>return</span> <span>sum</span> <span>/</span> <span>ratioOfAnisotropy</span><span>;</span>
<span>}</span>
<span>else</span>
<span>{</span>
    <span>return</span> <span>_MainTex</span><span>.</span><span>SampleLevel</span><span>(</span><span>sampler_MainTex</span><span>,</span> <span>i</span><span>.</span><span>uv</span><span>,</span> <span>mipLevel</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>Where <code>CalculateLodLevel</code> is an implementation of the pseudocode from the DirectX 11 spec. This implementation isn’t particularly good, and it doesn’t quite seem to match what the hardware does (the implementation details of anisotropic filtering are very much up to the vendors), but it does have the intended effect:</p>

<p><img src="https://pema.dev/assets/SWAniso.gif" alt=""/></p>

<p>On this image, we see 3 setups side-by-side. On the left, we have no mipmapping. As expected, it looks very aliased. In the center we have software anisotropic filtering. It looks a lot less aliased, especially at shallow angles. Finally, on the right, we have regular mipmapping, with no anisotropic filtering. It has no aliasing, but is quite blurry.</p>

<h2 id="bonus-nvidias-approximation">Bonus: Nvidia’s approximation</h2>

<p>I noted in the section <a href="#c">What does the hardware actually do?</a> that Nvidia uses a particularly crude approximation for their mipmap level selection. I can only assume they do this for performance reasons. I found their approximation quite intriguing, so I attempted to reverse engineer it. I believe they are doing something <em>similar</em> to this:</p>

<div><div><pre><code><span>// Scale input derivatives to texture size  </span>
<span>dx</span> <span>*=</span> <span>float2</span><span>(</span><span>width0</span><span>,</span> <span>height0</span><span>);</span> 
<span>dy</span> <span>*=</span> <span>float2</span><span>(</span><span>width0</span><span>,</span> <span>height0</span><span>);</span>

<span>// Elliptical transform</span>
<span>EllipseTransformDerivatives</span><span>(</span><span>dx</span><span>,</span> <span>dy</span><span>);</span>

<span>// Absolute value to mirror around X and Y axis</span>
<span>float2</span> <span>sx</span> <span>=</span> <span>abs</span><span>(</span><span>dx</span><span>);</span>
<span>float2</span> <span>sy</span> <span>=</span> <span>abs</span><span>(</span><span>dy</span><span>);</span>

<span>// This is a cheap way to calculate the distance to a weird looking octagon</span>
<span>const</span> <span>float</span> <span>magic</span> <span>=</span> <span>1</span><span>.</span><span>0</span><span>/</span><span>3</span><span>.</span><span>0</span><span>;</span>
<span>float</span> <span>lengthX</span> <span>=</span> <span>lerp</span><span>(</span><span>sx</span><span>.</span><span>x</span><span>+</span><span>magic</span><span>*</span><span>sx</span><span>.</span><span>y</span><span>,</span> <span>sx</span><span>.</span><span>y</span><span>+</span><span>magic</span><span>*</span><span>sx</span><span>.</span><span>x</span><span>,</span> <span>step</span><span>(</span><span>sx</span><span>.</span><span>x</span><span>,</span> <span>sx</span><span>.</span><span>y</span><span>));</span>
<span>float</span> <span>lengthY</span> <span>=</span> <span>lerp</span><span>(</span><span>sy</span><span>.</span><span>x</span><span>+</span><span>magic</span><span>*</span><span>sy</span><span>.</span><span>y</span><span>,</span> <span>sy</span><span>.</span><span>y</span><span>+</span><span>magic</span><span>*</span><span>sy</span><span>.</span><span>x</span><span>,</span> <span>step</span><span>(</span><span>sy</span><span>.</span><span>x</span><span>,</span> <span>sy</span><span>.</span><span>y</span><span>));</span>

<span>// Regular logarithmic length -&gt; mip mapping</span>
<span>float</span> <span>rho</span> <span>=</span> <span>max</span><span>(</span><span>lengthX</span><span>,</span><span>lengthY</span><span>);</span>  
<span>float</span> <span>mipLevel</span> <span>=</span> <span>log2</span><span>(</span><span>rho</span><span>);</span>
</code></pre></div></div>

<p>That octagon distance check compiles down to just a few instructions:</p>

<div><div><pre><code><span>ge</span> <span>r0</span><span>.</span><span>xy</span><span>,</span> <span>v0</span><span>.</span><span>ywyy</span><span>,</span> <span>v0</span><span>.</span><span>xzxx</span>
<span>and</span> <span>r0</span><span>.</span><span>xy</span><span>,</span> <span>r0</span><span>.</span><span>xyxx</span><span>,</span> <span>l</span><span>(</span><span>0x3f800000</span><span>,</span> <span>0x3f800000</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>)</span>
<span>mad</span> <span>r1</span><span>.</span><span>xyzw</span><span>,</span> <span>v0</span><span>.</span><span>yxwz</span><span>,</span> <span>l</span><span>(</span><span>0</span><span>.</span><span>333333</span><span>,</span> <span>0</span><span>.</span><span>333333</span><span>,</span> <span>0</span><span>.</span><span>333333</span><span>,</span> <span>0</span><span>.</span><span>333333</span><span>),</span> <span>v0</span><span>.</span><span>xyzw</span>
<span>add</span> <span>r0</span><span>.</span><span>zw</span><span>,</span> <span>-</span><span>r1</span><span>.</span><span>xxxz</span><span>,</span> <span>r1</span><span>.</span><span>yyyw</span>
<span>mad</span> <span>o0</span><span>.</span><span>xy</span><span>,</span> <span>r0</span><span>.</span><span>xyxx</span><span>,</span> <span>r0</span><span>.</span><span>zwzz</span><span>,</span> <span>r1</span><span>.</span><span>xzxx</span>
</code></pre></div></div>

<p>And in particular, has no square roots or exponents. Rendered out:
<img src="https://pema.dev/assets/WeirdMips%205.png" alt=""/>
It doesn’t quite match the hardware implementation, but it’s pretty close. Close enough that I think I am on to something. If you think you have a better idea, let me know! For completeness, here is the diff between the hardware and my attempt rendered out:
<img src="https://pema.dev/assets/WeirdMips%206.png" alt=""/></p>



<p>I hope that I’ve lived up to the title of this blog post, and that you learned a thing or two. I certainly did while researching this. Before we finish, I’d like to briefly touch on my motivation for writing this - it is twofold:</p>

<p>I initially became interested in how mipmap level selection works on GPU hardware when I was looking into writing a library for transpiling and running shaders on the CPU. There are many challenges involved in writing such a library, but one of the more annoying ones is deciphering how various hardware-implemented techniques can be done in software, based on often limited information. Mipmap level selection is one good example of this, but there are many others (think MSAA, rasterization rules, conservative rasterization, early Z, block texture compression, tessellation, etc.). This post explores just one of these rabbit holes.</p>

<p>What pushed me to dig deeper than the first software implementation I stumbled upon was this: I find myself frustrated with the relative lack of readily available information on GPU functionality specifics. So much of what I know comes from experimenting, exchanging ideas with fellow graphics programmers, and trying to decipher obtuse morsels of information drip-fed to me by the GPU vendors, through various documentation and pseudo-specs. I wish the details were easier to find, and this post is one small contribution towards fulfilling that. I hope you enjoyed following along.</p>

</article>





      </div></div>
  </body>
</html>
