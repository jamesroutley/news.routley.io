<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://derekabdine.com/blog/2022-arris-advisory.html">Original</a>
    <h1>Arris / Arris-variant DSL/Fiber router critical vulnerability exposure</h1>
    
    <div id="readability-page-1" class="page"><div id="main_content_wrap">
      <section id="main_content">
        

<p><strong>NOTE: This issue has been patched and deployed by at least one ISP, whose BGW routers use a customized variant of Arris NVG firmware.</strong></p>

<p>Multiple vulnerabilities exist in the MIT-licensed <a href="http://inglorion.net/software/muhttpd/">muhttpd web server</a>. This web server is widely used in ISP customer premise equipment (CPE), most notably in Arris firmware used in router models (at least, possibly other) NVG443, NVG599, NVG589, NVG510, as well as ISP-customized variants such as BGW210 and BGW320 (Arris has declined to confirm affected models). These routers are typically loaned to ISP subscribers for telephony and Internet access. The most severe vulnerability allows unauthenticated path traversal from the root of the file system as the root user. It is possible to recover the WiFi access code and SSID, remote administration password, SIP credentials (if VoIP is supported), ISP CWMP/TR-069 endpoint URLs and their username and password as well as other sensitive information, although some parts may require more complicated techniques or computing resources that may not be available to all attackers. Network-based unauthenticated exploitation is most severe if the router’s web services (such as the administration portal) are exposed to the Internet, though it can also be exploited on the LAN. According to Censys (link redacted to limit targeting), <strong>there are at least 19,000 Internet-facing likely vulnerable routers exposed directly to the Internet (at the time of writing, though patching since private disclosure has greatly reduced this number)</strong> over US, European and APAC ISPs, impacting both residential and business clients. There are millions more that are not Internet-facing or not easily identifiable from the Internet (depending on aggregate ISP deployment footprint).</p>

<p>Prior to the patch in version 1.1.7 (released June 1st, 2022), muhttpd was last released in 2010 (version 1.1.5), and the path traversal issue appears present in the initial commit of the muhttpd source in 2006. Additionally, the vulnerability appears to be present in the earliest versions of the Arris firmware (or any firmware that forks the Arris firmware). Testing confirms presence in at least version 2.7.7 (2020) in a BGW210-700 gateway. Thus, it should be assumed information and access detailed in this report was obtainable for at least several years, if not from the first launch of all NVG/BGW products.</p>

<p>A working proof-of-concept exploit exists that can do the following without authentication:</p>
<ul>
  <li>Download any non-directory, non-special file from the device.</li>
  <li>Loot secrets from the device database through <code>/etc/config.cfg</code>, including every WiFi SSID broadcast by the device and their corresponding access codes, management passwords, the device pin, and CWMP endpoint and credential information** (some router models may encrypt portions of this information, though the encryption implementation is flawed–see below).</li>
  <li>Deobfuscate any file in the proprietary “XMLC” file format (the device config database “<code>/etc/config.cfg</code>” is in this format, as well as the web server private key)</li>
  <li>Enumerate all processes, their environment variables and command line arguments.</li>
  <li>Parse the <code>mfg.dat/calibration_01.bin</code> file to extract secrets such as the default access code and pin (this file can be obtained by using the file download functionality of the exploit while the router is booting by repeatedly requesting the file as it is temporarily mounted during boot).</li>
</ul>

<p>Additionally, another proof-of-concept decryption tool exists that can decrypt any base64-encoded device secret from the deobfuscated <code>/etc/config.cfg</code> if given a device serial number, default WiFi access code, “board id” and certificate (all of which are obtainable via the Internet, except for the certificate – see “decrypting secrets” below).</p>

<p>Neither proof of concept will be released to the public.</p>

<h2 id="disclosure-timeline">Disclosure timeline</h2>
<p>April 6th, 2022: Initial disclosure to Arris</p>

<h2 id="vulnerability-1-cve-2022-31793-path-traversal-from-the-filesystem-root">Vulnerability 1 (CVE-2022-31793): Path traversal from the filesystem root</h2>

<p><strong>Mitigation: Stop the web server, or firewall it from untrusted networks (Internet, LAN). For affected Arris-based gateways: Disable remote management, or firewall the remote access ports from the Internet. This does not stop LAN (Ethernet or WiFi) exploitation, however. For regular users of muhttpd: Upgrade to version 1.1.7.</strong></p>

<p>The muhttpd server 1.1.5 (last official release 2010) has a path traversal vulnerability. Exploitation is trivial: Simply prepending a single character (or hexit such as <code>%0a</code>, with the exception of <code>%00</code> as it is a NUL byte) that is not a dot (“<code>.</code>”), forward slash (“<code>/</code>”) or question mark (“<code>?</code>”) before the requested path is sufficient to obtain any regular file on the device (the server does restrict directory listing and special file – such as symlinks and block devices – access):</p>

<div><div><pre><code>curl <span>--ignore-content-length</span> <span>-X</span><span>&#34;GET a/etc/hosts&#34;</span> http://&lt;ip&gt;:&lt;port&gt;
</code></pre></div></div>

<p>The above command will cause curl to issue a “<code>GET a/etc/hosts / HTTP/1.0</code>” request to the remote endpoint. The muhttpd server will happily ignore the extra “<code>/</code>“ prior to the HTTP protocol in the request. In fact, the exploit can be simplified to (plaintext HTTP):</p>

<div><div><pre><code><span>printf</span> <span>&#34;GET a/etc/hosts</span><span>\n\n</span><span>&#34;</span> | nc server port
</code></pre></div></div>

<p>To test this on a suspected vulnerable device over the LAN, assuming the gateway IP is 192.168.1.254:</p>

<div><div><pre><code><span>printf</span> <span>&#34;GET a/etc/hosts</span><span>\n\n</span><span>&#34;</span> | nc 192.168.1.254 80
</code></pre></div></div>

<p>The root cause of this issue is fairly straightforward: The server references the path component of the URL using the C code <code>&amp;filename[1]</code>, which effectively skips over the first letter (a/etc/hosts becomes <code>/etc/hosts</code>). No checks are done prior to handling the request to jail any paths under the web root (the server process is simply chdir()’d into the web root), although the path is sanitized before it gets to this point to strip out “<code>../</code>” sequences:</p>

<div><div><pre><code>	<span>/* Open file */</span>
	<span>fd</span> <span>=</span> <span>open</span><span>(</span><span>&amp;</span><span>req</span><span>-&gt;</span><span>filename</span><span>[</span><span>1</span><span>],</span> <span>O_RDONLY</span><span>);</span>
	<span>if</span><span>(</span><span>fd</span> <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
		<span>/* open failed, inform client */</span>
		<span>if</span><span>(</span><span>req</span><span>-&gt;</span><span>status</span> <span>!=</span> <span>HTTP_200</span><span>)</span> <span>{</span>
			<span>/* Unable to send error document; send error message */</span>
			<span>send_status_message</span><span>(</span><span>req</span><span>);</span>
</code></pre></div></div>

<h3 id="practical-exploitation-for-millions-of-routers">Practical exploitation for millions of routers</h3>
<p>For any router using an Arris-based firmware containing this web server, an unauthenticated remote (if remote administration is enabled) or local (LAN) party can obtain:</p>
<ul>
  <li><strong>The contents of the md5crypt (salted/hashed) passwords in /etc/passwd</strong>, which can be passed to password cracking rigs to identify the administrator password to change configuration settings on the device. The “<code>remote</code>” account corresponds to the remote management password (remote administration).</li>
  <li>Via the device “sdb” database file located at <code>/etc/config.cfg</code> (requires extra steps, see the sections on deobfuscation and decryption below):
    <ul>
      <li><strong>The SSID and plaintext password of the 2G and 5G WiFi networks</strong> broadcast by the device, and their independent on/off states.</li>
      <li><strong>The usernames and (sometimes encrypted) passwords of all administration accounts on the system.</strong> Several accounts (administrator, dslf-config) have passwords set to the device pin (printed on a sticker on the device itself).</li>
      <li><strong>ISP TR-069 / CWMP ACS and CR configuration information, including CWMP endpoint URLs, logging urls and their usernames and passwords</strong> (sometimes encrypted), per subscriber (unknown if any are shared).</li>
      <li><strong>SIP usernames (phone numbers) and passwords, including SIP endpoint URLs</strong>.</li>
      <li><strong>Port forwarding configuration information, including the external port, internal port and mac address</strong> of the device which has a port forward configuration. When combined with the LAN device list, it can enable more sophisticated targeting.</li>
    </ul>
  </li>
  <li>Sensitive network information, such as established TCP connections and the router’s ARP table and various MAC addresses, via the proc filesystem. <strong>The MAC address of the wireless networks (BSSID) can be used to geolocate these routers via wigle.net.</strong></li>
  <li><strong>Various system &amp; firewall logs</strong>, such as <code>/var/log/system.log.1</code>, <code>/var/log/firewall.log</code>, etc.</li>
  <li><strong>A complete list of the LAN IP address, hostname, MAC, uptime, and device characteristics such as the operating system and known applications of every device on the LAN</strong> via several files on the router (<code>/var/tmp/cwmp.lhd</code>, <code>/var/etc/hostdb.gz</code>, …)</li>
  <li><strong>The router serial number</strong> (via <code>/sys/motopia/serial_number</code>, <code>/etc/hosts</code> and elsewhere) and model number (via <code>/sys/motopia/dsl_eoc_string</code>, though this does not appear to be on BGW320 devices) of the device.</li>
  <li>The <strong>certificate and private key</strong> for the web management portal (requires deobfuscation, same as <code>/etc/config.cfg*</code>) and internal web services the device uses.</li>
  <li><strong>Router process information can be brute forced by walking the proc filesystem</strong> (<code>/proc/&lt;pid&gt;/...</code>), including obtaining each process executable, its command line, its environment, etc. Process memory cannot be retrieved since the code that sends the byte stream of file data does not support range requests, and reading from the address 0x0 is not allowed.</li>
</ul>

<p>A non-exhaustive list of example attack scenarios:</p>
<ul>
  <li>An actor scans the internet for vulnerable devices, downloads the device configuration database (<code>/etc/config.cfg</code> files) and deobfuscates them using the proof-of-concept. The actor then grabs the management password for each endpoint from the deobfuscated configuration file, logs into the router web admin portal over the Internet and reconfigures the network.</li>
  <li>An actor uses the above method to grab CWMP credentials and attempts to <a href="https://www.pcworld.com/article/440767/many-home-routers-supplied-by-isps-can-be-compromised-en-masse-researchers-say.html">reconfigure a subscriber’s router configuration</a> via the ISP.</li>
  <li>In the case the management password is obtained, it would be possible to surreptitiously add port forwarding rules and additional WiFi network configurations for some level of persistence into the network. For example:
    <ul>
      <li>An attacker could expose a LAN device to the Internet over its Remote Desktop Protocol (RDP) port, then run a secondary exploit/credential stuffing attacks on that host.</li>
      <li>An attacker could expose a database server’s port to the Internet and potentially leverage a misconfiguration / LAN trust relationship to download / retrieve data.</li>
    </ul>
  </li>
  <li>A semi-sophisticated actor may choose to identify vulnerable devices of interest for a victim corporation, government or critical infrastructure provider. They would:
    <ol>
      <li>Enumerate all LAN devices, router serial numbers, WiFi SSIDs, BSSIDs and passwords from every device exposed to the Internet (roughly 19K exposed).</li>
      <li>Filter / select which targets based on certain criteria, such as corporate device asset hostname naming patterns, physical location (proximity to the attacker), types of applications on the network (Tesla vehicles use their model name as their hostname, and some devices such as Tesla Powerwalls have been <a href="https://www.forbes.com/sites/thomasbrewster/2020/11/17/hundreds-of-tesla-powerwalls-exposed-to-potential-password-hacks-via-google---dont-let-one-be-yours">known to use their hostname as their password</a>, etc.</li>
      <li>Geolocate those devices using the BSSID of the router (obtainable through the proc filesystem) and wigle.net.</li>
      <li>Physically visit the location of the router, authenticate to the device wirelessly using credentials from the configuration database obtained via exploitation, and launch further attacks on LAN devices.</li>
    </ol>
  </li>
</ul>

<h3 id="file-obfuscation-and-the-device-configuration-database">File obfuscation and the device configuration database</h3>
<p>Certain files on Arris-based routers, such as dropbear and HTTPS RSA keys (for the web portal and other HTTP-based services), SKU-specific configuration files, and the contents of <code>/etc/config.cfg</code> (the device configuration database) appear to be in a proprietary binary data format, with an “XMLC” header. Binwalk indicates these files have fairly high entropy, indicating obfuscation, compression or encryption:</p>

<p>
<img width="75%" src="https://derekabdine.com/blog/images/image8.png"/></p>

<p>However, the HTTPS private key is read by muhttpd, and reading a private key and certificate has existed in the original source code for SSL/TLS support, while the original source does not support this file format. As it would turn out, <strong>the modified/customized muhttpd binary shipping in the firmware of these routers has the ability to deobfuscate files from this proprietary format</strong>. More specifically, the <code>ssl-key</code> parameter in the muhttpd server configuration file references the private key that must be in this format. After deobfuscating, the binary will pipe the data to <code>/bin/gzip</code> to deflate the contents to their plaintext form, then pipe the output of gzip back into its own process to set the server key:</p>

<p>
<img width="75%" src="https://derekabdine.com/blog/images/image3.png"/></p>

<p>This chain of custody issue (using an untrusted external program, <code>/bin/gzip</code>) can be exploited to avoid reverse engineering the proprietary file format. Thus, to restore any file in this format back to its original content, <strong>you can deobfuscate it in a docker container by abusing the <code>/bin/gzip</code> relationship with muhttpd</strong>:</p>
<ol>
  <li>Download the necessary executable binaries and libraries from the device (muhttpd and its required libraries in <code>/lib</code>)</li>
  <li>Download the target file encoded in this format (https keys, <code>/etc/config.cfg</code>, etc.)
Create a fake httpd.conf file with its <code>ssl-key</code> parameter set to the XMLC filename we want to decode.</li>
  <li>Create a fake <code>/bin/gzip</code> with a small script (chmod +x) that copies <code>/dev/stdin</code> to a resulting file on the mounted docker volume:</li>
  <li>Set necessary file permissions, volume mounts (for the libs, muhttpd binary, fake gzip and httpd.conf file) and execute muhttpd in the container.</li>
</ol>

<p>
<img width="75%" src="https://derekabdine.com/blog/images/image6.png"/></p>

<p>The muhttpd server will fail to launch if the result of deobfuscating the input file is not an RSA key. However, that doesn’t matter since it would’ve already piped the contents to (a fake) <code>/bin/gzip</code>. The point of the container is only to get to that point, not run a functional muhttpd server (though that is indeed possible with a bit of work). The result is a completely deobfuscated version of the input XMLC file. Note that non-XML files are encoded in this format (RSA private keys). The letters “XML” in “XMLC” seem to bear no relationship to the deobfuscated content (i.e., don’t always expect the content to be XML once deobfuscated). The deobfuscated content itself is gzipped, so you must decompress it first (technically, we could’ve piped it to the real <code>/bin/gzip</code> before writing output.gz).</p>

<p>A proof-of-concept exists that has the ability to deobfuscate <code>/etc/config.cfg</code> (the device database) and other files in the XMLC file format using the above method (assuming docker and a few python libraries are installed). A deobfuscated <code>/etc/config.cfg</code> would look something like this (heavily truncated/redacted and will differ based on the router model, firmware and ISP), versus the binary blob of data you would otherwise see without deobfuscating:</p>

<div><div><pre><code><span>&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
<span>&lt;config&gt;</span>
   <span>&lt;cgn&gt;</span>
      <span>&lt;MaxTCPInternalPortsUsed&gt;</span>1377<span>&lt;/MaxTCPInternalPortsUsed&gt;</span>
      <span>&lt;MaxTCPUserPortsUsed&gt;</span>5528<span>&lt;/MaxTCPUserPortsUsed&gt;</span>
      <span>&lt;MaxUDPInternalPortsUsed&gt;</span>3993<span>&lt;/MaxUDPInternalPortsUsed&gt;</span>
      <span>&lt;MaxUDPUserPortsUsed&gt;</span>592<span>&lt;/MaxUDPUserPortsUsed&gt;</span>
      <span>&lt;MaxOtherInternalPortsUsed&gt;</span>1<span>&lt;/MaxOtherInternalPortsUsed&gt;</span>
      <span>&lt;MaxOtherUserPortsUsed&gt;</span>84<span>&lt;/MaxOtherUserPortsUsed&gt;</span>
   <span>&lt;/cgn&gt;</span>
   <span>&lt;tai&gt;</span>
      <span>&lt;config&gt;</span>
         <span>&lt;enable-v-zone-ad</span> <span>notify=</span><span>&#34;active&#34;</span> <span>setby=</span><span>&#34;4&#34;</span><span>&gt;</span>on<span>&lt;/enable-v-zone-ad&gt;</span>
         <span>&lt;carousel-ip-addr</span> <span>notify=</span><span>&#34;active&#34;</span> <span>setby=</span><span>&#34;4&#34;</span><span>&gt;</span><span>&lt;</span><span>&lt;REDACTED&gt;</span>&gt;<span>&lt;/carousel-ip-addr&gt;</span>
         <span>&lt;carousel-port</span> <span>notify=</span><span>&#34;none&#34;</span> <span>setby=</span><span>&#34;4&#34;</span><span>&gt;</span><span>&lt;</span><span>&lt;REDACTED&gt;</span>&gt;<span>&lt;/carousel-port&gt;</span>
         <span>&lt;key-identification-counter</span> <span>notify=</span><span>&#34;none&#34;</span> <span>setby=</span><span>&#34;4&#34;</span><span>&gt;</span>19<span>&lt;/key-identification-counter&gt;</span>
         <span>&lt;authentication-key</span> <span>notify=</span><span>&#34;none&#34;</span> <span>setby=</span><span>&#34;4&#34;</span><span>&gt;</span><span>&lt;</span><span>&lt;REDACTED&gt;</span>&gt;<span>&lt;/authentication-key&gt;</span>
      <span>&lt;/config&gt;</span>
   <span>&lt;/tai&gt;</span>
   <span>&lt;system&gt;</span>
      <span>&lt;timezone</span> <span>notify=</span><span>&#34;none&#34;</span> <span>setby=</span><span>&#34;4&#34;</span><span>&gt;</span>PST8PDT<span>&lt;/timezone&gt;</span>
<span>&lt;</span><span>&lt; CUT</span> <span>&gt;</span>&gt;
      <span>&lt;microservice&gt;</span>
         <span>&lt;execution-environment</span> <span>name=</span><span>&#34; &#34;</span><span>&gt;</span>
            <span>&lt;status&gt;</span>Up<span>&lt;/status&gt;</span>
            <span>&lt;upgrade-status&gt;</span>off<span>&lt;/upgrade-status&gt;</span>
            <span>&lt;registry-password&gt;</span><span>&lt;</span><span>&lt;REDACTED</span><span>,</span> <span>ENCRYPTED</span><span>&gt;</span>&gt;<span>&lt;/registry-password&gt;</span>
            <span>&lt;manifest-server-password&gt;</span><span>&lt;</span><span>&lt;REDACTED</span><span>,</span> <span>ENCRYPTED</span><span>&gt;</span>&gt;<span>&lt;/manifest-server-password&gt;</span>
            <span>&lt;registry-pswd-flag&gt;</span>on-1<span>&lt;/registry-pswd-flag&gt;</span>
            <span>&lt;manifest-server-pswd-flag&gt;</span>on-1<span>&lt;/manifest-server-pswd-flag&gt;</span>
            <span>&lt;reboot-status&gt;</span>off<span>&lt;/reboot-status&gt;</span>
         <span>&lt;/execution-environment&gt;</span>
<span>&lt;</span><span>&lt; CUT</span> <span>&gt;</span>&gt;
      <span>&lt;cwmp&gt;</span>
         <span>&lt;acs-url</span> <span>notify=</span><span>&#34;active&#34;</span> <span>setby=</span><span>&#34;4&#34;</span><span>&gt;</span><span>&lt;</span><span>&lt;REDACTED&gt;</span>&gt;<span>&lt;/acs-url&gt;</span>
         <span>&lt;acs-password</span> <span>notify=</span><span>&#34;active&#34;</span><span>&gt;</span><span>&lt;</span><span>&lt;REDACTED</span><span>,</span> <span>ENCRYPTED</span><span>&gt;</span>&gt;<span>&lt;/acs-password&gt;</span>
         <span>&lt;acs-pwd-flag&gt;</span>on-1<span>&lt;/acs-pwd-flag&gt;</span>
         <span>&lt;cr-url</span> <span>notify=</span><span>&#34;active&#34;</span><span>&gt;</span>/XML/001E46-<span>&lt;</span><span>&lt;REDACTED&gt;</span>&gt;.xml<span>&lt;/cr-url&gt;</span>
         <span>&lt;cr-username</span> <span>notify=</span><span>&#34;active&#34;</span> <span>setby=</span><span>&#34;4&#34;</span><span>&gt;</span>001E46-<span>&lt;</span><span>&lt;REDACTED&gt;</span>&gt;<span>&lt;/cr-username&gt;</span>
         <span>&lt;cr-password</span> <span>notify=</span><span>&#34;active&#34;</span> <span>setby=</span><span>&#34;4&#34;</span><span>&gt;</span><span>&lt;</span><span>&lt;REDACTED</span><span>,</span> <span>ENCRYPTED</span><span>&gt;</span>&gt;<span>&lt;/cr-password&gt;</span>
         <span>&lt;cr-pwd-flag</span> <span>setby=</span><span>&#34;4&#34;</span><span>&gt;</span>on-2<span>&lt;/cr-pwd-flag&gt;</span>
         <span>&lt;param-key</span> <span>setby=</span><span>&#34;4&#34;</span><span>&gt;</span>1<span>&lt;/param-key&gt;</span>
         <span>&lt;periodic-inform&gt;</span>
            <span>&lt;enable</span> <span>notify=</span><span>&#34;none&#34;</span> <span>setby=</span><span>&#34;4&#34;</span><span>&gt;</span>on<span>&lt;/enable&gt;</span>
            <span>&lt;interval</span> <span>notify=</span><span>&#34;none&#34;</span> <span>setby=</span><span>&#34;4&#34;</span><span>&gt;</span>86400<span>&lt;/interval&gt;</span>
            <span>&lt;time</span> <span>setby=</span><span>&#34;4&#34;</span><span>&gt;</span>2021-11-08T04:00:00Z<span>&lt;/time&gt;</span>
         <span>&lt;/periodic-inform&gt;</span>
         <span>&lt;sbdc&gt;</span>
            <span>&lt;enable</span> <span>notify=</span><span>&#34;none&#34;</span><span>&gt;</span>on<span>&lt;/enable&gt;</span>
            <span>&lt;request-port&gt;</span>61001<span>&lt;/request-port&gt;</span>
            <span>&lt;request-url&gt;</span>001E46_<span>&lt;</span><span>&lt;REDACTED&gt;</span>&gt;<span>&lt;/request-url&gt;</span>
            <span>&lt;ssl-enable&gt;</span>on<span>&lt;/ssl-enable&gt;</span>
            <span>&lt;max-sessions&gt;</span>8<span>&lt;/max-sessions&gt;</span>
<span>&lt;</span><span>&lt; CUT</span> <span>&gt;</span>&gt;
   <span>&lt;phy&gt;</span>
      <span>&lt;enet</span> <span>name=</span><span>&#34;wan&#34;</span> <span>id=</span><span>&#34;7&#34;</span><span>&gt;</span>
         <span>&lt;port</span> <span>id=</span><span>&#34;7&#34;</span><span>&gt;</span>
            <span>&lt;media-type&gt;</span>copper<span>&lt;/media-type&gt;</span>
         <span>&lt;/port&gt;</span>
      <span>&lt;/enet&gt;</span>
      <span>&lt;wl80211</span> <span>id=</span><span>&#34;1&#34;</span> <span>version=</span><span>&#34;1.0&#34;</span><span>&gt;</span>
         <span>&lt;enable&gt;</span>on<span>&lt;/enable&gt;</span>
         <span>&lt;radio</span> <span>notify=</span><span>&#34;active&#34;</span><span>&gt;</span>on<span>&lt;/radio&gt;</span>
         <span>&lt;ssid</span> <span>id=</span><span>&#34;1&#34;</span> <span>version=</span><span>&#34;1.0&#34;</span><span>&gt;</span>
            <span>&lt;enable</span> <span>notify=</span><span>&#34;active&#34;</span><span>&gt;</span>on<span>&lt;/enable&gt;</span>
            <span>&lt;ssid-name</span> <span>notify=</span><span>&#34;active&#34;</span><span>&gt;</span>homenet<span>&lt;/ssid-name&gt;</span>
            <span>&lt;passphrase</span> <span>notify=</span><span>&#34;active&#34;</span><span>&gt;</span>hunter2!<span>&lt;/passphrase&gt;</span>
         <span>&lt;/ssid&gt;</span>
         <span>&lt;ssid</span> <span>id=</span><span>&#34;2&#34;</span> <span>version=</span><span>&#34;1.0&#34;</span><span>&gt;</span>
            <span>&lt;enable</span> <span>notify=</span><span>&#34;active&#34;</span><span>&gt;</span>off<span>&lt;/enable&gt;</span>
            <span>&lt;ssid-name</span> <span>notify=</span><span>&#34;active&#34;</span> <span>setby=</span><span>&#34;4&#34;</span><span>&gt;</span><span>&lt;</span><span>&lt;REDACTED&gt;</span>&gt;_Guest<span>&lt;/ssid-name&gt;</span>
            <span>&lt;passphrase</span> <span>notify=</span><span>&#34;active&#34;</span><span>&gt;</span>test123!<span>&lt;/passphrase&gt;</span>
            <span>&lt;admin-access-enable&gt;</span>off<span>&lt;/admin-access-enable&gt;</span>
            <span>&lt;wired-access-enable&gt;</span>off<span>&lt;/wired-access-enable&gt;</span>
         <span>&lt;/ssid&gt;</span>

<span>&lt;</span><span>&lt; CUT</span> <span>&gt;</span>&gt;
   <span>&lt;voice&gt;</span>
      <span>&lt;profile</span> <span>id=</span><span>&#34;1&#34;</span><span>&gt;</span>
         <span>&lt;sip-publish-invocation</span> <span>setby=</span><span>&#34;4&#34;</span><span>&gt;</span>endofcall<span>&lt;/sip-publish-invocation&gt;</span>
         <span>&lt;sip-advanced-setting&gt;</span>
            <span>&lt;sip-digit-map</span> <span>notify=</span><span>&#34;none&#34;</span> <span>setby=</span><span>&#34;4&#34;</span><span>&gt;</span>O=15,I=6,S=3(*#101<span>&amp;lt;</span>:@C03<span>&amp;gt;</span>|*#103<span>&amp;lt;</span>:@C06<span>&amp;gt;</span>|T0|T*xx|T*xxx|[2-9]11|[01]911|988|1[2-9]xxxxxxxxx|T[2-9]xxxxxx|[2-9]xxxxxxxxx|n.)<span>&lt;/sip-digit-map&gt;</span>
            <span>&lt;sip-allow-ip-list</span> <span>setby=</span><span>&#34;4&#34;</span><span>&gt;</span><span>&lt;</span><span>&lt;REDACTED&gt;</span>&gt;<span>&lt;/sip-allow-ip-list&gt;</span>
         <span>&lt;/sip-advanced-setting&gt;</span>
         <span>&lt;user-account</span> <span>name=</span><span>&#34;1&#34;</span> <span>id=</span><span>&#34;1&#34;</span><span>&gt;</span>
            <span>&lt;enable</span> <span>notify=</span><span>&#34;none&#34;</span> <span>setby=</span><span>&#34;4&#34;</span><span>&gt;</span>off<span>&lt;/enable&gt;</span>
            <span>&lt;sip-user-password/&gt;</span>
            <span>&lt;sip-user-password-flag&gt;</span>off<span>&lt;/sip-user-password-flag&gt;</span>
         <span>&lt;/user-account&gt;</span>
         <span>&lt;user-account</span> <span>name=</span><span>&#34;2&#34;</span> <span>id=</span><span>&#34;2&#34;</span><span>&gt;</span>
            <span>&lt;sip-user-password/&gt;</span>
            <span>&lt;sip-user-password-flag&gt;</span>off<span>&lt;/sip-user-password-flag&gt;</span>
         <span>&lt;/user-account&gt;</span>
         <span>&lt;user-account</span> <span>name=</span><span>&#34;3&#34;</span> <span>id=</span><span>&#34;3&#34;</span><span>&gt;</span>
            <span>&lt;sip-user-password/&gt;</span>
            <span>&lt;sip-user-password-flag&gt;</span>off<span>&lt;/sip-user-password-flag&gt;</span>
         <span>&lt;/user-account&gt;</span>
         <span>&lt;user-account</span> <span>name=</span><span>&#34;4&#34;</span> <span>id=</span><span>&#34;4&#34;</span><span>&gt;</span>
            <span>&lt;sip-user-password/&gt;</span>
            <span>&lt;sip-user-password-flag&gt;</span>off<span>&lt;/sip-user-password-flag&gt;</span>
         <span>&lt;/user-account&gt;</span>
      <span>&lt;/profile&gt;</span>
</code></pre></div></div>

<p>
<i>An example of the contents of a deobfuscated `/etc/config.cfg` from a BGW router. The microservice environment appears to be a docker environment for running speed test software. Note that this specific router did not have VoIP enabled, so no SIP passwords are present in this instance.</i>
</p>

<h3 id="decrypting-secrets">Decrypting secrets</h3>
<p>The firmware may encrypt plaintext secrets in the <code>/etc/config.cfg</code> file (see “REDACTED, ENCRYPTED” markers above) using AES-128-CBC (default padding). The AES ciphertext is encoded using base64 before writing to the configuration database (<code>/etc/config.cfg</code>), which itself is obfuscated using a proprietary “XMLC” file format (see below on deobfuscation). However, the encryption is particularly weak due to a number of issues and is susceptible to fixed-value, brute force or lookup table attacks.</p>

<p><strong>Given a base64-encoded ciphertext, is it possible to recover the plaintext?</strong> Let’s assess.</p>

<p>The AES 16-byte (128 bit) key is derived from two invocations of Argon2i, a modern hashing algorithm. In both phases, Argon2 is run with a t_cost of 2, memory of 4096KiB, and parallelism of 1. First, an 8-byte key salt is computed by the firmware. This salt is created by utilizing the byte stream of a DER-encoded client certificate embedded in the device at manufacture time as the password, while using a fixed 8-byte string as the salt. However, interestingly, the code copies the certificate DER byte array to a separate buffer using strlcpy() before hashing with Argon2i. <strong>Use of <code>strlcpy()</code> effectively arbitrarily chops the client certificate bytes to the first NUL terminator encountered in the DER certificate byte array</strong> (as the <code>str*cpy</code> functions operate on strings and consider a NUL <code>\x00</code> to be the end of a string), greatly reducing or eliminating the entropy used in the hash function:</p>

<p>
<img width="75%" src="https://derekabdine.com/blog/images/image7.png"/>
</p>

<p>Interestingly, this defect is similar to the <a href="https://wiibrew.org/wiki/Signing_bug">strcmp issue</a> that enabled the Nintendo home brew scene, and points to a misunderstanding of the source data being used, or the effect of string operations on non-string data. The key salt is then fed into Argon2i again (this time with a hashlen of 16 bytes, corresponding to the 128-bit AES key length), with the password in this second invocation set to a computed string based on the default WiFi access code, the device serial number, and board id:</p>

<p>
<img width="75%" src="https://derekabdine.com/blog/images/image4.png"/>
</p>

<p>Given vulnerability #1, the device serial number, wifi access code, and board ID are known. The serial number is obtainable in a number of places, such as <code>/sys/motopia/serial_number</code>, <code>/etc/hosts</code>, and various log files. The WiFi access code can be obtained through <code>/etc/config.cfg</code> (once deobfuscated, see below) unless customized by a user, or it can be viewed in plaintext in the management user interface (if the user has the access pin, which is printed on the device). The board ID is a single byte value which is printed in <code>/var/log/system.log{,.1,.2}</code> (also obtainable with the same vulnerability), and appears to be a simple, short enumeration (BGW210 devices use <code>0x1c</code>, BGW320 devices use 0x1e or 0x1f depending on the manufacturer). Thus, the password “A” is assumed to be completely known.</p>

<p><strong>Knowledge of “A” (through information easily obtained over the network via the muhttpd vulnerability) in effect renders the 128-bit AES encryption to 64 bits (the same as the salt “C”).</strong></p>

<p>Thus, we are left with a few methods of obtaining the salt value “C” to recover the AES key and decrypt any secrets encrypted using this key generation methodology:</p>
<ul>
  <li><strong>Obtaining the certificate via reboot &amp; exploitation.</strong> This is less interesting, because a reboot would require social engineering or physical access. The certificate can be obtained via a router reboot, while repeatedly requesting the /mfg/mfg.dat file on BGW210-700 models using vulnerability #1 (or /mfg/calibration_01.bin on BGW320-500 models). The client, intermediate and root certificates as well as the private key exist at offset -16384 (that is, from the end of the file) of mfg.dat. This file is mounted temporarily during bootup and after the muhttpd server is online, but it appears it is unmounted prior to the WAN interface going live.</li>
  <li><strong>Brute-forcing 2^64 possible values of the salt.</strong> With the right hardware it may be possible to brute force the correct value for C by trying all 2^64 or 1.844674407x109 combinations of values. The required computational power for this likely makes it impractical for the casual attacker except for a select few organizations (possibly state-aligned) with the requisite compute power.</li>
  <li><strong>Exploiting the strlcpy() call and certificate DER encoding properties.</strong> A BGW320-500 manufactured by HUMAX was found to use a serial number in a small enough integer such that the DER bytes in the certificate contained a NUL byte in a fixed location. For devices with client certificates installed at manufacture time which use a serial number stored this way, it is possible to use a fixed set of bytes as a placeholder for the entire certificate, nullifying the entropy otherwise incorporated into the key. This was verified on another similar device using a proof of concept decrypt tool:</li>
</ul>

<div><div><pre><code>decrypt &lt;MODEL NUMBER&gt; <span>\</span>
        &lt;WIFI PASSCODE&gt; <span>\</span>
        &lt;BOARD ID&gt; <span>\</span>
        <span>&#34;</span><span>$(</span>python <span>-c</span> <span>&#39;import base64;print(base64.b64encode(bytes.fromhex(&#34;308203d5308202bda0030201020209&#34; + &#34;0&#34; * 1940)).decode(&#34;utf-8&#34;))&#39;</span><span>)</span><span>&#34;</span> <span>\</span>
        &lt;ENCRYPTED SECRET&gt;
</code></pre></div></div>

<p>The 15-byte sequence “<code>308203d5308202bda0030201020209</code>” is straight from a HUMAX-generated certificate on a BGW320-500 gateway, and starts with a DER SEQUENCE (3082) tag (length 981 - <code>03d5</code>). The remaining 1940 characters are zeros, corresponding to the NUL-padded (due to the <code>strlcpy()</code>) byte array fed into the argon2i hash function (the full size of the buffer is still used). We can check our math: 1940/2 (hex digits) is 970, and the 15-byte header gives us a total size of 985, the on-disk size of the client certificate (subtract 4 bytes for the initial sequence tag header, and you’re left with 981).</p>

<p>In the event the serial number is not stored in this format, the NUL may come in a different position with some entropy offered by the bytes comprising the certificate (up until a NUL byte is encountered). However, in this case, the entire amount of entropy incorporated into the hash depends on the entropy used to source the serial number, as it is the first non-fixed field in the certificate after the initial sequence tag. If the serial number is found to be generated in a predictable way – such as sequential/incremental generator – it would be possible to compute a lookup table in a very reasonable amount of space to “recover” the appropriate certificate material and bypass encryption no matter the length of the bytes representing the serial number. This could be proven by obtaining certificates from several devices by the same manufacturer and comparing their serial numbers. Otherwise, one may choose to use precomputed lookup tables that search for a NUL in the first 5-6 bytes of the certificate, and resort to brute forcing methods within reasonable limits depending on available computing resources (however, at a certain point it may make more sense to just brute force the 8-byte salt itself).</p>

<p><em>A special thanks to Royce Williams (twitter: <a href="https://twitter.com/TychoTithonus">@TychoTithonus</a>) and Sam “Chick3nman” Croley (twitter: <a href="https://twitter.com/Chick3nman512">@Chick3nman512</a>) of the Hashcat team for their advice during analysis.</em></p>

<p>Thus, the answer is yes: <strong>It is possible to recover the plaintext remote administration password and pin for the device, as well as the SIP and ISP CWMP passwords used for the particular customer over the Internet if they are encrypted</strong>, though with varying degrees of difficulty, as depicted by this chart:</p>

<p>
<img width="75%" src="https://derekabdine.com/blog/images/image1.png"/><br/>
</p>

<p>It’s worth noting that if the certificate is known by anyone other than the ISP or the subscriber, the LAN should be assumed compromised as well. If the client certificate is shared with the ISP, the ISP would also have control over the remote administration password, WiFi access code, etc. (however, some of this information, like the WiFi access code, is already shared with certain ISPs in their cloud portals). In remote work scenarios where the ISP holds this information, an organization’s attack surface includes the ISP of the home user. Subscribers should act as if the LAN is tainted if the web administration portal is Internet-facing anyway, as the plaintext WiFi password is obtainable by downloading and deobfuscating /etc/config.cfg, which is trivial. Changing the WiFi password is also recommended.</p>

<h2 id="vulnerability-2-null-pointer-dereference">Vulnerability 2: NULL pointer dereference</h2>
<p><strong>Mitigation: Disable remote access, or firewall the remote access ports from the Internet.</strong></p>

<p>The muhttpd server receives HTTP requests on a non-blocking socket. Socket connections are accept()ed and fed to a <code>fork()</code>ed process to execute. When data is received, the server reads in a loop until a sequence of two carriage return/newline characters are received (<code>read_request</code>). Processing is then handed off to another method (<code>do_request</code>) which attempts to parse the request method, uri, filename, and headers.</p>

<p>Injecting a NULL byte into the request steam will cause the request process (forked from the server process) to segfault:</p>

<p>http:</p>
<div><div><pre><code><span>echo</span> <span>-n</span> <span>&#34;GET a </span><span>\x</span><span>00</span><span>\n\n</span><span>&#34;</span> | nc serverip 80
</code></pre></div></div>
<p>OR (due to echo compatibility between shells/environments)</p>
<div><div><pre><code><span>echo </span>474554206120000a0a | xxd <span>-r</span> <span>-p</span> | nc 192.168.1.254 80
</code></pre></div></div>

<p>https:</p>
<div><div><pre><code><span>(</span><span>echo</span> <span>-n</span> <span>&#34;GET a </span><span>\x</span><span>00</span><span>\n\n</span><span>&#34;</span><span>;</span> <span>cat</span><span>)</span> | openssl s_client <span>-host</span> serverip <span>-port</span> 443
</code></pre></div></div>
<p>OR</p>
<div><div><pre><code><span>(</span><span>echo </span>474554206120000a0a | xxd <span>-r</span> <span>-p</span><span>;</span> <span>cat</span><span>)</span> | openssl s_client <span>-host</span> serverip <span>-port</span> 443
</code></pre></div></div>

<p>This problem manifests when parsing the request protocol (<code>HTTP/1.0</code>, for example) in <code>request.c#do_request</code>. The call to <code>strpbrk</code> can return NULL if the string terminates before a token is found, which would be the case if a NUL byte is injected into the request stream sent to the server. The end result is a NULL value for p, followed by an increment to address <code>0x00000001</code> and a dereference of p to check for ‘<code>\r</code>’ or ‘<code>\n</code>’, which causes the segfault:</p>

<p>
<img width="75%" src="https://derekabdine.com/blog/images/image2.png"/><br/>
</p>

<p>However, various other parts of the request processing code are also prone to the same issue. The request processing code of this server should be revisited to ensure processing robustness, and tested against several edge cases such as this.</p>

<p>Functionally the child <code>fork()</code>ed process crashes, but because of the fork, the main server continues to listen and accept sockets. Therefore, no DoS-like attacks are likely using this scenario, though resource exhaustion leading to DoS may be possible with more research.</p>

<h2 id="vulnerability-3-buffer-over-read-when-defanging-urls">Vulnerability 3: Buffer over-read when defanging URLs</h2>
<p><strong>Mitigation: Disable remote access, or firewall the remote access ports from the Internet.</strong></p>

<p>The muhttpd server contains a buffer over-read when dealing with percent-encoded values, such as <code>%2e</code> (dot). When encountering a percent “<code>%</code>” in the URL, the server attempts to decode the next two characters without checking the bounds, and while incrementing the index “<code>n</code>” into the URL buffer “<code>url</code>.” The end result is that if the URL consists of “%” with no following characters, the decode_url function will read past the URL data and into the parts of the request buffer containing the HTTP protocol version string (<code>HTTP/1.0</code>, <code>HTTP/1.1</code>, etc.), as the code previously had parsed the input request stream from the client by injecting NUL terminators in the original socket data as opposed to allocating new buffers. While not practically exploitable, safeguards should be made to prevent accessing unintended address space. The worst an attacker could do with this issue–when combined with vulnerability 1–is single-level path traversal (<code>../</code>). However, since vulnerability #1 is much more severe as it allows traversal from the filesystem root, and since fixing vulnerability #1 would also fix this traversal problem, addressing vulnerability #1 is enough to mitigate the path traversal issue here (but not completely eliminate the over-read).</p>

<p>
<img width="75%" src="https://derekabdine.com/blog/images/image5.png"/><br/>
</p>

<h2 id="conclusion">Conclusion</h2>
<p>Arris and Arris firmware-based devices have a web administration portal running muhttpd which has three vulnerabilities, one of which is critical, and two of which are presumably impractical to exploit. The affected server is used in fiber and DSL-based Arris router products (NVG), as well as whitelabel/OEM products (BGW) by other vendors. The complete list of affected products is unknown as Arris has declined to comment on the affected product list.</p>

<p>Internet Service Providers (ISPs) around the world typically loan these routers out to their collective millions of subscribers, though only up to 19,000 have been visible on the public Internet. Since the firmware is widespread and every ISP manages their own firmware updates independently, it’s likely that this issue will persist for years. While the majority of devices disclosed in this advisory through public searches are now patched, it is unlikely the search contains every exposed device, due to per-ISP filtering, transient network errors from Internet scanning engines, and differences in fingerprinting methodologies that the search query may have missed.</p>

<p>Though no evidence of active exploitation exists, it is best to create an action plan that assumes a subscriber (residential or commercial) has been compromised due to the length of time the vulnerability has existed. Subscribers can mitigate any potential <em>future</em> impact by limiting access to the administration portal (typically at http(s)://192.168.1.254/) on the LAN and WAN (e.g., by placing untrusted guests on a separate guest network without the administration portal exposed, and by disabling the ability to access the portal from the Internet).</p>


      </section>
    </div></div>
  </body>
</html>
