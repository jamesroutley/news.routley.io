<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://svelte.dev/blog/virtual-dom-is-pure-overhead">Original</a>
    <h1>Virtual DOM is pure overhead (2018)</h1>
    
    <div id="readability-page-1" class="page"><div id="main">

<article>
	<p>Let&#39;s retire the &#39;virtual DOM is fast&#39; myth once and for all</p>

	

	<!-- HTML_TAG_START --><p>If you&#39;ve used JavaScript frameworks in the last few years, you&#39;ve probably heard the phrase &#39;the virtual DOM is fast&#39;, often said to mean that it&#39;s faster than the <em>real</em> DOM. It&#39;s a surprisingly resilient meme — for example people have asked how Svelte can be fast when it doesn&#39;t use a virtual DOM.</p>
<p>It&#39;s time to take a closer look.</p>
<h2>What is the virtual DOM?</h2>
<p>In many frameworks, you build an app by creating <code>render()</code> functions, like this simple <a href="https://reactjs.org/">React</a> component:</p>
<div><pre><code><span>function</span> <span>HelloMessage</span><span>(</span><span>props</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span>
        <span>&lt;</span>div className<span>=</span><span>&#34;greeting&#34;</span><span>&gt;</span>
            Hello <span>{</span>props<span>.</span>name<span>}</span>
        <span>&lt;</span><span>/</span>div<span>&gt;</span>
    <span>)</span><span>;</span>
<span>}</span></code></pre></div><p>You can do the same thing without JSX...</p>
<div><pre><code><span>function</span> <span>HelloMessage</span><span>(</span><span>props</span><span>)</span> <span>{</span>
    <span>return</span> React<span>.</span><span>createElement</span><span>(</span>
        <span>&#39;div&#39;</span><span>,</span>
        <span>{</span> <span>className</span><span>:</span> <span>&#39;greeting&#39;</span> <span>}</span><span>,</span>
        <span>&#39;Hello &#39;</span><span>,</span>
        props<span>.</span>name
    <span>)</span><span>;</span>
<span>}</span></code></pre></div><p>...but the result is the same — an object representing how the page should now look. That object is the virtual DOM. Every time your app&#39;s state updates (for example when the <code>name</code> prop changes), you create a new one. The framework&#39;s job is to <em>reconcile</em> the new one against the old one, to figure out what changes are necessary and apply them to the real DOM.</p>
<h2>How did the meme start?</h2>
<p>Misunderstood claims about virtual DOM performance date back to the launch of React. In <a href="https://www.youtube.com/watch?v=x7cQ3mrcKaY">Rethinking Best Practices</a>, a seminal 2013 talk by former React core team member Pete Hunt, we learned the following:</p>
<blockquote>
<p>This is actually extremely fast, primarily because most DOM operations tend to be slow. There&#39;s been a lot of performance work on the DOM, but most DOM operations tend to drop frames.</p>
</blockquote>
<figure>
    <img alt="Pete Hunt at JSConfEU 2013" src="https://www.recurse.com/media/rethinking-best-practices.jpg"/>
    <figcaption>Screenshot from <a href="https://www.youtube.com/watch?v=x7cQ3mrcKaY">Rethinking Best Practices</a> at JSConfEU 2013</figcaption>
</figure>

<p>But hang on a minute! The virtual DOM operations are <em>in addition to</em> the eventual operations on the real DOM. The only way it could be faster is if we were comparing it to a less efficient framework (there were plenty to go around back in 2013!), or arguing against a straw man — that the alternative is to do something no-one actually does:</p>
<div><pre><code><span>onEveryStateChange</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    document<span>.</span>body<span>.</span>innerHTML <span>=</span> <span>renderMyApp</span><span>(</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span></code></pre></div><p>Pete clarifies soon after...</p>
<blockquote>
<p>React is not magic. Just like you can drop into assembler with C and beat the C compiler, you can drop into raw DOM operations and DOM API calls and beat React if you wanted to. However, using C or Java or JavaScript is an order of magnitude performance improvement because you don&#39;t have to worry...about the specifics of the platform. With React you can build applications without even thinking about performance and the default state is fast.</p>
</blockquote>
<p>...but that&#39;s not the part that stuck.</p>
<h2>So... is the virtual DOM <em>slow</em>?</h2>
<p>Not exactly. It&#39;s more like &#39;the virtual DOM is usually fast enough&#39;, but with certain caveats.</p>
<p>The original promise of React was that you could re-render your entire app on every single state change without worrying about performance. In practice, I don&#39;t think that&#39;s turned out to be accurate. If it was, there&#39;d be no need for optimisations like <code>shouldComponentUpdate</code> (which is a way of telling React when it can safely skip a component).</p>
<p>Even with <code>shouldComponentUpdate</code>, updating your entire app&#39;s virtual DOM in one go is a lot of work. A while back, the React team introduced something called React Fiber which allows the update to be broken into smaller chunks. This means (among other things) that updates don&#39;t block the main thread for long periods of time, though it doesn&#39;t reduce the total amount of work or the time an update takes.</p>
<h2>Where does the overhead come from?</h2>
<p>Most obviously, <a href="https://twitter.com/pcwalton/status/1015694528857047040">diffing isn&#39;t free</a>. You can&#39;t apply changes to the real DOM without first comparing the new virtual DOM with the previous snapshot. To take the earlier <code>HelloMessage</code> example, suppose the <code>name</code> prop changed from &#39;world&#39; to &#39;everybody&#39;.</p>
<ol>
<li>Both snapshots contain a single element. In both cases it&#39;s a <code>&lt;div&gt;</code>, which means we can keep the same DOM node</li>
<li>We enumerate all the attributes on the old <code>&lt;div&gt;</code> and the new one to see if any need to be changed, added or removed. In both cases we have a single attribute — a <code>className</code> with a value of <code>&#34;greeting&#34;</code></li>
<li>Descending into the element, we see that the text has changed, so we&#39;ll need to update the real DOM</li>
</ol>
<p>Of these three steps, only the third has value in this case, since — as is the case in the vast majority of updates — the basic structure of the app is unchanged. It would be much more efficient if we could skip straight to step 3:</p>
<div><pre><code><span>if</span> <span>(</span>changed<span>.</span>name<span>)</span> <span>{</span>
    text<span>.</span>data <span>=</span> name<span>;</span>
<span>}</span></code></pre></div><p>(This is almost exactly the update code that Svelte generates. Unlike traditional UI frameworks, Svelte is a compiler that knows at <em>build time</em> how things could change in your app, rather than waiting to do the work at <em>run time</em>.)</p>
<h2>It&#39;s not just the diffing though</h2>
<p>The diffing algorithms used by React and other virtual DOM frameworks are fast. Arguably, the greater overhead is in the components themselves. You wouldn&#39;t write code like this...</p>
<div><pre><code><span>function</span> <span>StrawManComponent</span><span>(</span><span>props</span><span>)</span> <span>{</span>
    <span>const</span> value <span>=</span> <span>expensivelyCalculateValue</span><span>(</span>props<span>.</span>foo<span>)</span><span>;</span>

    <span>return</span> <span>(</span>
        <span>&lt;</span>p<span>&gt;</span>the value is <span>{</span>value<span>}</span><span>&lt;</span><span>/</span>p<span>&gt;</span>
    <span>)</span><span>;</span>
<span>}</span></code></pre></div><p>...because you&#39;d be carelessly recalculating <code>value</code> on every update, regardless of whether <code>props.foo</code> had changed. But it&#39;s extremely common to do unnecessary computation and allocation in ways that seem much more benign:</p>
<div><pre><code><span>function</span> <span>MoreRealisticComponent</span><span>(</span><span>props</span><span>)</span> <span>{</span>
    <span>const</span> <span>[</span>selected<span>,</span> setSelected<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>null</span><span>)</span><span>;</span>

    <span>return</span> <span>(</span>
        <span>&lt;</span>div<span>&gt;</span>
            <span>&lt;</span>p<span>&gt;</span>Selected <span>{</span>selected <span>?</span> selected<span>.</span>name <span>:</span> <span>&#39;nothing&#39;</span><span>}</span><span>&lt;</span><span>/</span>p<span>&gt;</span>

            <span>&lt;</span>ul<span>&gt;</span>
                <span>{</span>props<span>.</span>items<span>.</span><span>map</span><span>(</span><span>item</span> <span>=&gt;</span>
                    <span>&lt;</span>li<span>&gt;</span>
                        <span>&lt;</span>button onClick<span>=</span><span>{</span><span>(</span><span>)</span> <span>=&gt;</span> <span>setSelected</span><span>(</span>item<span>)</span><span>}</span><span>&gt;</span>
                            <span>{</span>item<span>.</span>name<span>}</span>
                        <span>&lt;</span><span>/</span>button<span>&gt;</span>
                    <span>&lt;</span><span>/</span>li<span>&gt;</span>
                <span>)</span><span>}</span>
            <span>&lt;</span><span>/</span>ul<span>&gt;</span>
        <span>&lt;</span><span>/</span>div<span>&gt;</span>
    <span>)</span><span>;</span>
<span>}</span></code></pre></div><p>Here, we&#39;re generating a new array of virtual <code>&lt;li&gt;</code> elements — each with their own inline event handler — on every state change, regardless of whether <code>props.items</code> has changed. Unless you&#39;re unhealthily obsessed with performance, you&#39;re not going to optimise that. There&#39;s no point. It&#39;s plenty fast enough. But you know what would be even faster? <em>Not doing that.</em></p>


<p>The danger of defaulting to doing unnecessary work, even if that work is trivial, is that your app will eventually succumb to &#39;death by a thousand cuts&#39; with no clear bottleneck to aim at once it&#39;s time to optimise.</p>
<p>Svelte is explicitly designed to prevent you from ending up in that situation.</p>
<h2>Why do frameworks use the virtual DOM then?</h2>
<p>It&#39;s important to understand that virtual DOM <em>isn&#39;t a feature</em>. It&#39;s a means to an end, the end being declarative, state-driven UI development. Virtual DOM is valuable because it allows you to build apps without thinking about state transitions, with performance that is <em>generally good enough</em>. That means less buggy code, and more time spent on creative tasks instead of tedious ones.</p>
<p>But it turns out that we can achieve a similar programming model without using virtual DOM — and that&#39;s where Svelte comes in.</p>
<!-- HTML_TAG_END --></article>


</div></div>
  </body>
</html>
