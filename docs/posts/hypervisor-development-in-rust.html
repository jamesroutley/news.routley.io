<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://memn0ps.github.io/hypervisor-development-in-rust-part-1/">Original</a>
    <h1>Hypervisor Development in Rust</h1>
    
    <div id="readability-page-1" class="page"><section><p>This article will cover the development of a <a href="https://github.com/memN0ps/hypervisor-rs">minimalistic Intel VT-x research hypervisor in Rust</a>. We will use the <a href="https://crates.io/crates/x86">x86 crate</a> and <a href="https://docs.rs/x86/latest/x86/">documentation</a>, which help simplify the code.</p><p>The knowledge acquired to make this hypervisor was from reading blogs and code, notably the two excellent free hypervisor development series by <a href="https://revers.engineering/7-days-to-virtualization-a-series-on-hypervisor-development/">@daax_rynd</a> and <a href="https://rayanfam.com/">@Intel80x86</a>. The primary motivation came shortly after <a href="https://github.com/not-matthias/amd_hypervisor">@not_matthias</a> released an AMD (SVM) Hypervisor in Rust and from <a href="https://twitter.com/the_secret_club">Secret Club’s</a> excellent articles:</p><ul><li><a href="https://secret.club/2020/01/12/battleye-hypervisor-detection.html">https://secret.club/2020/01/12/battleye-hypervisor-detection.html</a></li><li><a href="https://secret.club/2020/07/06/bottleye.html">https://secret.club/2020/07/06/bottleye.html</a></li><li><a href="https://secret.club/2020/04/13/how-anti-cheats-detect-system-emulation.html">https://secret.club/2020/04/13/how-anti-cheats-detect-system-emulation.html</a></li></ul><p>The majority of the hypervisor was already developed before the legendary <a href="https://github.com/tandasat/Hypervisor-101-in-Rust">@tandasat released Hypervisor 101 in Rust</a>.</p><h2 id="virtual-machine-architecture">Virtual Machine Architecture</h2><p><code>Virtual Machine Monitor (VMM):</code> A VMM serves as a host and has complete command over the platform’s processor(s) and other hardware. A VMM enables guest software to run directly on a logical processor by providing it with an abstraction of a virtual processor. A VMM can maintain granular control over I/O, interrupt handling, physical memory, and processor resources.</p><p><code>Guest Software:</code> Any software that runs inside a virtual machine (VM) controlled by a virtual machine monitor (VMM) or hypervisor is referred to as guest software. Each virtual machine (VM) supports an operating system (OS) stack and application software as a guest software environment. Each virtual machine runs independently of the others and has a standard interface with the physical platform’s processor(s), memory, storage, graphics, and I/O. The software stack performs as though it were on a platform without a VMM. So that the VMM may continue to have control over platform resources, software running in virtual machines must have fewer privileges.</p><h2 id="introduction-to-virtual-machine-extension-vmx-operation">Introduction to Virtual Machine Extension (VMX) Operation</h2><p>An operation that the Virtual Machine Monitor (VMM) does to enter or depart a virtual machine execution mode is referred to as a VMX operation. The host system’s standard operating mode and the virtualized operating mode of the guest system executing within the VM are switched via the VMX procedure. The virtualization technology in the processor supports the low-level VMX operation, which enables the VMM to construct and manage virtual machines.</p><h2 id="life-cycle-of-virtual-machine-monitor-vmm-software">Life Cycle of Virtual Machine Monitor (VMM) Software</h2><p>The Virtual Machine Monitor (VMM) can enter and leave the execution mode of virtual machines (VMs) using low-level hardware operations called <code>VM ENTRY</code> and <code>VM EXIT</code>. Other low-level hardware operations, such as <code>VMXON</code> and <code>VMXOFF</code>, enable and disable the VMX operation, the processor’s implementation of hardware virtualization that supports VMMs, respectively. In essence, <code>VMXON</code> and <code>VMXOFF</code> allow the VMM to construct and operate virtual machines, whereas <code>VM ENTRY</code> and <code>VM EXIT</code> enable the VMM to move between the host system and the guest system.</p><p><img src="https://memn0ps.github.io/Hypervisor-Development-In-Rust-Part-1/Interaction_of_a_Virtual-Machine_Monitor_and_Guests.png" alt="Interaction_of_a_Virtual-Machine_Monitor_and_Guests"/></p><p><em>Credits: Intel® 64 and IA-32 Architectures Software Developer Manual</em></p><h2 id="virtual-machine-control-structure-vmcs">Virtual-Machine Control Structure (VMCS)</h2><p>A virtual machine’s execution is managed and controlled by the Virtual Machine Monitor (VMM) via a virtual machine control structure (VMCS).
The virtual machine’s state, the settings for the virtual processor, and the mapping between the virtual and physical resources are all contained in the VMCS.</p><p>The VMM employs a collection of low-level instructions to control the VMCS. The Virtual-Machine Control Structure Pointer (VMCS pointer), which enables the VMM to access the VMCS for a particular VM, can be read using <code>VMPTRST</code> and loaded using <code>VMPTRLD</code>. The VMM can alter the virtual machine’s state or obtain details regarding its present state by using the commands <code>VMREAD</code> and <code>VMWRITE</code>, which are used to read and write values from and to the VMCS, respectively. When a virtual machine is terminated, or its state needs to be reset, <code>VMCLEAR</code> is used to clear the contents of the VMCS.</p><p>Each of the VMCSs assigned to a physical computer’s logical processors corresponds to a particular virtual machine. As a result, the VMM can oversee and administer numerous virtual machines on a single physical device. In order to generate, monitor, and manage the execution of virtual machines on logical processors, the VMCS and related instructions give the VMM essential control and management capabilities.</p><h2 id="discovering-support-for-virtual-machine-extension-vmx">Discovering Support for Virtual Machine Extension (VMX)</h2><p>When developing a hypervisor, it’s crucial to determine whether Intel or AMD built the CPU because each manufacturer has a unique virtualization technology with unique capabilities and instructions. It is vital to identify the processor type and employ the proper approaches to use these technologies and guarantee that the hypervisor functions on various systems.</p><p>The <code>CPUID</code> instruction can be used to determine whether Virtual Machine Extension (VMX) / Intel Virtualization Technology is supported. The processor will reveal information about its features, including whether it supports VMX, when the <code>CPUID</code> instruction is run with the <code>EAX</code> register set to <code>1</code>. The <code>EAX</code>, <code>EBX</code>, <code>ECX</code>, and <code>EDX</code> registers store the CPUID data for the processor. If VMX is supported by the processor, bit <code>5</code> of <code>ECX</code> will be set to <code>1</code>. The processor does not support VMX if the bit is not set, making virtualization unavailable.</p><h3 id="rust">Rust</h3><p>We check whether Intel makes the CPU by examining the <code>CPUID</code> information using the Rust x86 crate. Specifically, we check the vendor information returned by the <code>CPUID</code> instruction to see if it equals <code>&#34;GenuineIntel&#34;</code>. If the vendor information indicates an Intel CPU, we return an <code>Ok</code> result; otherwise, we return an error indicating that the hypervisor does not support the CPU.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>/// Check to see if CPU is Intel (“GenuineIntel”).
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>fn</span> <span>has_intel_cpu</span>()<span> </span>-&gt; Result<span>&lt;</span>(),<span> </span>HypervisorError<span>&gt;</span><span> </span>{<span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span>cpuid<span> </span><span>=</span><span> </span>CpuId::new();<span>
</span></span></span><span><span><span>    </span><span>if</span><span> </span><span>let</span><span> </span>Some(vi)<span> </span><span>=</span><span> </span>cpuid.get_vendor_info()<span> </span>{<span>
</span></span></span><span><span><span>        </span><span>if</span><span> </span>vi.as_str()<span> </span><span>==</span><span> </span><span>&#34;GenuineIntel&#34;</span><span> </span>{<span>
</span></span></span><span><span><span>            </span><span>return</span><span> </span>Ok(());<span>
</span></span></span><span><span><span>        </span>}<span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span>    </span>Err(HypervisorError::CPUUnsupported)<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><h3 id="rust-1">Rust</h3><p>We check whether the processor supports Virtual Machine Extension (VMX) technology by checking if the bit <code>5</code> in the <code>ECX</code> register is set to <code>1</code> using the <code>CPUID</code> instruction. We use the Rust x86 crate to get the CPUID information and check whether the processor has VMX support by reading the feature information. If the processor supports VMX, we return an <code>Ok</code> result; otherwise, we return an error indicating that VMX is not supported.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>/// Check processor supports for Virtual Machine Extension (VMX) technology - CPUID.1:ECX.VMX[bit 5] = 1 (Intel Manual: 24.6 Discovering Support for VMX)
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>fn</span> <span>has_vmx_support</span>()<span> </span>-&gt; Result<span>&lt;</span>(),<span> </span>HypervisorError<span>&gt;</span><span> </span>{<span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span>cpuid<span> </span><span>=</span><span> </span>CpuId::new();<span>
</span></span></span><span><span><span>    </span><span>if</span><span> </span><span>let</span><span> </span>Some(fi)<span> </span><span>=</span><span> </span>cpuid.get_feature_info()<span> </span>{<span>
</span></span></span><span><span><span>        </span><span>if</span><span> </span>fi.has_vmx()<span> </span>{<span>
</span></span></span><span><span><span>            </span><span>return</span><span> </span>Ok(());<span>
</span></span></span><span><span><span>        </span>}<span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span>    </span>Err(HypervisorError::VMXUnsupported)<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><h3 id="rust-2">Rust</h3><p>We use a custom <code>HypervisorError</code> enum to handle errors, which was made using <a href="https://crates.io/crates/thiserror-no-std">thiserror-no-std</a> crate.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span><span> </span>thiserror_no_std::Error;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>#[derive(Error, Debug)]</span><span>
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>enum</span> <span>HypervisorError</span><span> </span>{<span>
</span></span></span><span><span><span>    </span><span>#[error(</span><span>&#34;Intel CPU not found&#34;</span><span>)]</span><span>
</span></span></span><span><span><span>    </span>CPUUnsupported,<span>
</span></span></span><span><span><span>    
</span></span></span><span><span><span>    </span><span>#[error(</span><span>&#34;VMX is not supported&#34;</span><span>)]</span><span>
</span></span></span><span><span><span>    </span>VMXUnsupported,<span>
</span></span></span><span><span><span>    
</span></span></span><span><span><span>    </span><span>#[error(</span><span>&#34;VMX locked off in BIOS&#34;</span><span>)]</span><span>
</span></span></span><span><span><span>    </span>VMXBIOSLock,<span>
</span></span></span><span><span><span>    
</span></span></span><span><span><span>    </span><span>#[error(</span><span>&#34;Failed allocate memory via PhysicalAllocator&#34;</span><span>)]</span><span>
</span></span></span><span><span><span>    </span>MemoryAllocationFailed(<span>#[from]</span><span> </span>core::alloc::AllocError),<span>
</span></span></span><span><span><span>    
</span></span></span><span><span><span>    </span><span>#[error(</span><span>&#34;Failed to convert from virtual address to physical address&#34;</span><span>)]</span><span>
</span></span></span><span><span><span>    </span>VirtualToPhysicalAddressFailed,<span>
</span></span></span><span><span><span>    
</span></span></span><span><span><span>    </span><span>#[error(</span><span>&#34;Failed to execute VMXON&#34;</span><span>)]</span><span>
</span></span></span><span><span><span>    </span>VMXONFailed,<span>
</span></span></span><span><span><span>    
</span></span></span><span><span><span>    </span><span>#[error(</span><span>&#34;Failed to execute VMXOFF&#34;</span><span>)]</span><span>
</span></span></span><span><span><span>    </span>VMXOFFFailed,<span>
</span></span></span><span><span><span>    
</span></span></span><span><span><span>    </span><span>#[error(</span><span>&#34;Failed to execute VMCLEAR&#34;</span><span>)]</span><span>
</span></span></span><span><span><span>    </span>VMCLEARFailed,<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>#[error(</span><span>&#34;Failed to execute VMPTRLD&#34;</span><span>)]</span><span>
</span></span></span><span><span><span>    </span>VMPTRLDFailed,<span>
</span></span></span><span><span><span>    
</span></span></span><span><span><span>    </span><span>#[error(</span><span>&#34;Failed to execute VMREAD&#34;</span><span>)]</span><span>
</span></span></span><span><span><span>    </span>VMREADFailed,<span>
</span></span></span><span><span><span>    
</span></span></span><span><span><span>    </span><span>#[error(</span><span>&#34;Failed to execute VMWRITE&#34;</span><span>)]</span><span>
</span></span></span><span><span><span>    </span>VMWRITEFailed,<span>
</span></span></span><span><span><span>    
</span></span></span><span><span><span>    </span><span>#[error(</span><span>&#34;Failed to execute VMLAUNCH&#34;</span><span>)]</span><span>
</span></span></span><span><span><span>    </span>VMLAUNCHFailed,<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>#[error(</span><span>&#34;Failed to execute VMRESUME&#34;</span><span>)]</span><span>
</span></span></span><span><span><span>    </span>VMRESUMEFailed,<span>
</span></span></span><span><span><span>    
</span></span></span><span><span><span>    </span><span>#[error(</span><span>&#34;Failed to switch processor&#34;</span><span>)]</span><span>
</span></span></span><span><span><span>    </span>ProcessorSwitchFailed,<span>
</span></span></span><span><span><span>    
</span></span></span><span><span><span>    </span><span>#[error(</span><span>&#34;Failed to access VCPU table&#34;</span><span>)]</span><span>
</span></span></span><span><span><span>    </span>VcpuIsNone,<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><h2 id="enabling-and-entering-virtual-machine-extension-vmx-operation">Enabling and Entering Virtual Machine Extension (VMX) Operation</h2><p>The CPU must operate in a hardware virtualization mode to execute virtual machines, made possible by Virtual Machine Extensions (VMX). System software initially sets the <code>CR4.VMXE[bit 13]</code> to <code>1</code> to enable VMX. This bit is found in the control register <code>CR4</code>, which regulates the processor’s multiple operating modes. The system software can execute the <code>VMXON</code> instruction to enter VMX operating mode once the VMX bit has been set.</p><p>Yet when <code>VMXON</code> is attempted to be executed with <code>CR4.VMXE = 0</code>, an invalid-opcode exception (<code>#UD</code>) is raised. Because VMX is not enabled, the CPU does not recognize the <code>VMXON</code> instruction, which leads to this exception. After the processor switches to VMX operation mode, the <code>CR4.VMXE</code> bit cannot be cleared. Because of this, system software must exit VMX operating mode with the <code>VMXOFF</code> instruction before <code>CR4.VMXE</code> may be cleared.</p><h3 id="rust-3">Rust</h3><p>We have a function called <code>enable_vmx_operation()</code> that enables virtual machine extensions (VMX). We do this by setting a specific bit (bit <code>13</code>) in the <code>CR4</code> control register to <code>1</code>. We first read the current value of <code>CR4</code> using the <code>controlregs::cr4()</code> function, then set the appropriate bit using the <code>set()</code> method of the <code>Cr4</code> struct, and finally, write the updated value back to <code>CR4</code> using the <code>controlregs::cr4_write()</code> function.</p><p>In addition to setting the <code>CR4</code> bit, we call the <code>set_lock_bit()</code> function, which sets a lock bit via the <code>IA32_FEATURE_CONTROL</code> register and logs a message indicating that the lock bit has been set. If everything goes well, we return a <code>Result</code> with an <code>Ok</code> value indicating success. If an error occurs, we return a <code>Result</code> with an <code>Err</code> value containing a <code>HypervisorError</code>.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>/// Enables Virtual Machine Extensions - CR4.VMXE[bit 13] = 1 (Intel Manual: 24.7 Enabling and Entering VMX Operation)
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>fn</span> <span>enable_vmx_operation</span>()<span> </span>-&gt; Result<span>&lt;</span>(),<span> </span>HypervisorError<span>&gt;</span><span> </span>{<span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span>cr4<span> </span><span>=</span><span> </span><span>unsafe</span><span> </span>{<span> </span>controlregs::cr4()<span> </span>};<span>
</span></span></span><span><span><span>    </span>cr4.set(controlregs::Cr4::<span>CR4_ENABLE_VMX</span>,<span> </span><span>true</span>);<span>
</span></span></span><span><span><span>    </span><span>unsafe</span><span> </span>{<span> </span>controlregs::cr4_write(cr4)<span> </span>};<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span>set_lock_bit()<span>?</span>;<span>
</span></span></span><span><span><span>    </span>log::info!(<span>&#34;[+] Lock bit set via IA32_FEATURE_CONTROL&#34;</span>);<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span>Ok(())<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>The <code>IA32_FEATURE_CONTROL</code> MSR is a model-specific register that controls the processor’s features, including VMX capability. This register is zeroed when a logical processor is reset. Bits <code>0</code> through <code>1</code> and <code>2</code> are crucial for <code>VMXON</code>. Whether it can be updated depends on the lock bit in the MSR. If the lock bit is not set, <code>VMXON</code> execution will fail, and the MSR cannot be modified until after a power-up reset. The lock bit, bit <code>1</code>, bit <code>2</code>, or both can be changed in the BIOS to deactivate VMX capability.</p><ul><li><code>Bit 1</code> activates <code>VMXON</code> in SMX mode, providing a more secure setting. If this bit is not set, <code>VMXON</code> execution in SMX mode will encounter an error.</li><li><code>Bit 2</code> permits <code>VMXON</code> execution while SMX mode is not active. A general protection exception is triggered when this bit is attempted to be set on logical processors that cannot support VMX operation.</li></ul><p>The <code>IA32_FEATURE_CONTROL</code> MSR and control bits in <code>CR4</code> need to be set in order to activate VMX. The lock bit, bit <code>1</code>, and bit <code>2</code> enable VMX. Once enabled, processors can enter the VMX operating mode and operate virtual machines using VMX instructions.</p><h3 id="rust-4">Rust</h3><p>We first check the current value of the <code>IA32_FEATURE_CONTROL</code> MSR register to see if the lock bit is already set. If it’s not set, then we set the lock bit along with the <code>VMXON_OUTSIDE_SMX</code> bit and write the new value to the <code>IA32_FEATURE_CONTROL MSR</code> register. If the lock bit is already set, but the <code>VMXON_OUTSIDE_SMX</code> bit is not set, we then return an error indicating that the BIOS has locked the VMX feature.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>/// Check if we need to set bits in IA32_FEATURE_CONTROL (Intel Manual: 24.7 Enabling and Entering VMX Operation)
</span></span></span><span><span><span></span><span>fn</span> <span>set_lock_bit</span>()<span> </span>-&gt; Result<span>&lt;</span>(),<span> </span>HypervisorError<span>&gt;</span><span> </span>{<span>
</span></span></span><span><span><span>    </span><span>const</span><span> </span><span>VMX_LOCK_BIT</span>: <span>u64</span> <span>=</span><span> </span><span>1</span><span> </span><span>&lt;&lt;</span><span> </span><span>0</span>;<span>
</span></span></span><span><span><span>    </span><span>const</span><span> </span><span>VMXON_OUTSIDE_SMX</span>: <span>u64</span> <span>=</span><span> </span><span>1</span><span> </span><span>&lt;&lt;</span><span> </span><span>2</span>;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span>ia32_feature_control<span> </span><span>=</span><span> </span><span>unsafe</span><span> </span>{<span> </span>rdmsr(msr::<span>IA32_FEATURE_CONTROL</span>)<span> </span>};<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>if</span><span> </span>(ia32_feature_control<span> </span><span>&amp;</span><span> </span><span>VMX_LOCK_BIT</span>)<span> </span><span>==</span><span> </span><span>0</span><span> </span>{<span>
</span></span></span><span><span><span>        </span><span>unsafe</span><span> </span>{<span>
</span></span></span><span><span><span>            </span>msr::wrmsr(<span>
</span></span></span><span><span><span>                </span>msr::<span>IA32_FEATURE_CONTROL</span>,<span>
</span></span></span><span><span><span>                </span><span>VMXON_OUTSIDE_SMX</span><span> </span><span>|</span><span> </span><span>VMX_LOCK_BIT</span><span> </span><span>|</span><span> </span>ia32_feature_control,<span>
</span></span></span><span><span><span>            </span>)<span>
</span></span></span><span><span><span>        </span>};<span>
</span></span></span><span><span><span>    </span>}<span> </span><span>else</span><span> </span><span>if</span><span> </span>(ia32_feature_control<span> </span><span>&amp;</span><span> </span><span>VMXON_OUTSIDE_SMX</span>)<span> </span><span>==</span><span> </span><span>0</span><span> </span>{<span>
</span></span></span><span><span><span>        </span><span>return</span><span> </span>Err(HypervisorError::VMXBIOSLock);<span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span>Ok(())<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><h2 id="restrictions-on-vmx-operation-adjusting-control-registers">Restrictions on VMX Operation (Adjusting Control Registers)</h2><p>In order to ensure that Virtual Machine Extension (VMX) Operation work as intended, specific bits in the Control Registers (<code>CR0</code> and <code>CR4</code>) must be set or cleared to particular values. The VMX operation will fail if any of these bits have an unsupported value when the system is in virtualization mode. A general protection exception will be thrown if one of these bits is ever attempted to be set to an unsupported value while the VMX operation is in progress. Software should consult the VMX capability MSRs <code>IA32_VMX_CR0_FIXED0</code>, <code>IA32_VMX_CR0_FIXED1</code>, <code>IA32_VMX_CR4_FIXED0</code>, and <code>IA32_VMX_CR4_FIXED1</code> to find out which bits in the <code>CR0</code> and <code>CR4</code> registers are fixed and how they should be set.</p><h3 id="rust-5">Rust</h3><p>We have implemented functions that adjust the <code>CR0</code> and <code>CR4</code> control registers for virtualization. These functions aim to ensure that the mandatory bits in the Control Registers are set and cleared appropriately to support virtualization. To achieve this, we have defined two functions: <code>set_cr0_bits()</code> and <code>set_cr4_bits()</code>. The former sets the mandatory bits in <code>CR0</code> while clearing the mandatory <code>zero</code> bits, while the latter does the same for <code>CR4</code>.</p><p>To adjust <code>CR0</code> and <code>CR4</code>, we read the values stored in the <code>IA32_VMX_CR0_FIXED0</code>, <code>IA32_VMX_CR0_FIXED1</code>, <code>IA32_VMX_CR4_FIXED0</code>, and <code>IA32_VMX_CR4_FIXED1</code> Model-Specific Registers (MSRs) to determine which bits should be set and cleared. We then use the <code>from_bits_truncate()</code> function to ensure that the bit values fit within the <code>Cr0</code> and <code>Cr4</code> types, set the mandatory bits using the or bitwise operator, and clear the mandatory <code>zero</code> bits using the and bitwise operator. Finally, we write the resulting value back to the <code>CR0</code> or <code>CR4</code> register using the <code>cr0_write()</code> or <code>cr4_write()</code> functions.</p><p>We have also defined a higher-level function <code>adjust_control_registers()</code> that calls both <code>set_cr0_bits()</code> and <code>set_cr4_bits()</code>. This function sets and clears the mandatory bits in both <code>CR0</code> and <code>CR4</code> and logs a message indicating that the bits have been set/cleared.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>/// Adjust set and clear the mandatory bits in CR0 and CR4
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>fn</span> <span>adjust_control_registers</span>()<span> </span>{<span>
</span></span></span><span><span><span>    </span>set_cr0_bits();<span>
</span></span></span><span><span><span>    </span>log::info!(<span>&#34;[+] Mandatory bits in CR0 set/cleared&#34;</span>);<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span>set_cr4_bits();<span>
</span></span></span><span><span><span>    </span>log::info!(<span>&#34;[+] Mandatory bits in CR4 set/cleared&#34;</span>);<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>/// Set the mandatory bits in CR0 and clear bits that are mandatory zero (Intel Manual: 24.8 Restrictions on VMX Operation)
</span></span></span><span><span><span></span><span>fn</span> <span>set_cr0_bits</span>()<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span>ia32_vmx_cr0_fixed0<span> </span><span>=</span><span> </span><span>unsafe</span><span> </span>{<span> </span>msr::rdmsr(msr::<span>IA32_VMX_CR0_FIXED0</span>)<span> </span>};<span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span>ia32_vmx_cr0_fixed1<span> </span><span>=</span><span> </span><span>unsafe</span><span> </span>{<span> </span>msr::rdmsr(msr::<span>IA32_VMX_CR0_FIXED1</span>)<span> </span>};<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span>cr0<span> </span><span>=</span><span> </span><span>unsafe</span><span> </span>{<span> </span>controlregs::cr0()<span> </span>};<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span>cr0<span> </span><span>|=</span><span> </span>controlregs::Cr0::from_bits_truncate(ia32_vmx_cr0_fixed0<span> </span><span>as</span><span> </span><span>usize</span>);<span>
</span></span></span><span><span><span>    </span>cr0<span> </span><span>&amp;=</span><span> </span>controlregs::Cr0::from_bits_truncate(ia32_vmx_cr0_fixed1<span> </span><span>as</span><span> </span><span>usize</span>);<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>unsafe</span><span> </span>{<span> </span>controlregs::cr0_write(cr0)<span> </span>};<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>/// Set the mandatory bits in CR4 and clear bits that are mandatory zero (Intel Manual: 24.8 Restrictions on VMX Operation)
</span></span></span><span><span><span></span><span>fn</span> <span>set_cr4_bits</span>()<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span>ia32_vmx_cr4_fixed0<span> </span><span>=</span><span> </span><span>unsafe</span><span> </span>{<span> </span>msr::rdmsr(msr::<span>IA32_VMX_CR4_FIXED0</span>)<span> </span>};<span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span>ia32_vmx_cr4_fixed1<span> </span><span>=</span><span> </span><span>unsafe</span><span> </span>{<span> </span>msr::rdmsr(msr::<span>IA32_VMX_CR4_FIXED1</span>)<span> </span>};<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span>cr4<span> </span><span>=</span><span> </span><span>unsafe</span><span> </span>{<span> </span>controlregs::cr4()<span> </span>};<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span>cr4<span> </span><span>|=</span><span> </span>controlregs::Cr4::from_bits_truncate(ia32_vmx_cr4_fixed0<span> </span><span>as</span><span> </span><span>usize</span>);<span>
</span></span></span><span><span><span>    </span>cr4<span> </span><span>&amp;=</span><span> </span>controlregs::Cr4::from_bits_truncate(ia32_vmx_cr4_fixed1<span> </span><span>as</span><span> </span><span>usize</span>);<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>unsafe</span><span> </span>{<span> </span>controlregs::cr4_write(cr4)<span> </span>};<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><h2 id="vmxon-region">VMXON Region</h2><p>Software must allocate a memory region called the <code>VMXON Region</code>, which will be used by the logical processor for VMX operation, before allowing virtual machine extensions (VMX) activity. The operand for the <code>VMXON</code> instruction is the physical address of this area.</p><p>The <code>VMXON</code> pointer must adhere to certain specifications, such as being 4-KByte aligned and not exceeding the processor’s physical address width. Software must use a different region for each logical processor and write the VMCS revision identification (VMCS ID) to the <code>VMXON</code> region before <code>VMXON</code> is executed. Unpredictable behaviour may emerge from accessing or altering the <code>VMXON</code> region of a logical processor between the execution of <code>VMXON</code> and <code>VMXOFF</code>.</p><h3 id="rust-6">Rust</h3><p>Fortunately for us, <a href="https://twitter.com/not_matthias">@not-matthias</a> already has a <a href="https://crates.io/crates/kernel-alloc">kernel-alloc</a> crate in Rust ready for community use.</p><p>The <code>PhysicalAllocator</code> is a custom allocator that allocates physical memory in Windows kernel mode. When you allocate memory using this allocator, it calls the <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-mmallocatecontiguousmemoryspecifycachenode"><code>MmAllocateContiguousMemorySpecifyCacheNode</code></a> function to allocate contiguous physical memory. If the allocation is successful, it returns a pointer to the allocated memory. If it fails, it returns an <code>AllocError</code>. When you deallocate memory using this allocator, it calls the <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-mmfreecontiguousmemory"><code>MmFreeContiguousMemory</code></a> function to free the memory that was previously allocated. This allocator can be used with Rust’s <code>GlobalAlloc</code> trait to provide a custom global allocator for Rust’s heap-allocated data types like <code>String</code>, <code>Vec</code>, and <code>Box</code>.</p><p>If you want to find out more about it, please refer to the <a href="https://doc.rust-lang.org/std/alloc/trait.GlobalAlloc.html">alloc::GlobalAllocator</a> or <a href="https://doc.rust-lang.org/std/alloc/trait.Allocator.html">alloc::Allocator</a> and the Rust book for <a href="https://doc.rust-lang.org/1.26.2/unstable-book/language-features/global-allocator.html">global_allocator</a> or <a href="https://doc.rust-lang.org/1.26.2/unstable-book/library-features/allocator-api.html">allocator_api.</a></p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>/// The physical kernel allocator structure.
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>struct</span> <span>PhysicalAllocator</span>;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>unsafe</span><span> </span><span>impl</span><span> </span>Allocator<span> </span><span>for</span><span> </span>PhysicalAllocator<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>fn</span> <span>allocate</span>(<span>&amp;</span>self,<span> </span>layout: <span>Layout</span>)<span> </span>-&gt; Result<span>&lt;</span>NonNull<span>&lt;</span>[<span>u8</span>]<span>&gt;</span>,<span> </span>AllocError<span>&gt;</span><span> </span>{<span>
</span></span></span><span><span><span>        </span><span>let</span><span> </span><span>mut</span><span> </span>boundary: <span>PHYSICAL_ADDRESS</span><span> </span><span>=</span><span> </span><span>unsafe</span><span> </span>{<span> </span>core::mem::zeroed()<span> </span>};<span>
</span></span></span><span><span><span>        </span><span>let</span><span> </span><span>mut</span><span> </span>lowest: <span>PHYSICAL_ADDRESS</span><span> </span><span>=</span><span> </span><span>unsafe</span><span> </span>{<span> </span>core::mem::zeroed()<span> </span>};<span>
</span></span></span><span><span><span>        </span><span>let</span><span> </span><span>mut</span><span> </span>highest: <span>PHYSICAL_ADDRESS</span><span> </span><span>=</span><span> </span><span>unsafe</span><span> </span>{<span> </span>core::mem::zeroed()<span> </span>};<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>        </span><span>unsafe</span><span> </span>{<span> </span><span>*</span>(boundary.QuadPart_mut())<span> </span><span>=</span><span> </span><span>0</span><span> </span>};<span>
</span></span></span><span><span><span>        </span><span>unsafe</span><span> </span>{<span> </span><span>*</span>(lowest.QuadPart_mut())<span> </span><span>=</span><span> </span><span>0</span><span> </span>};<span>
</span></span></span><span><span><span>        </span><span>unsafe</span><span> </span>{<span> </span><span>*</span>(highest.QuadPart_mut())<span> </span><span>=</span><span> </span><span>-</span><span>1</span><span> </span>};<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>        </span><span>let</span><span> </span>memory<span> </span><span>=</span><span> </span><span>unsafe</span><span> </span>{<span>
</span></span></span><span><span><span>            </span>MmAllocateContiguousMemorySpecifyCacheNode(<span>
</span></span></span><span><span><span>                </span>layout.size(),<span>
</span></span></span><span><span><span>                </span>lowest,<span>
</span></span></span><span><span><span>                </span>highest,<span>
</span></span></span><span><span><span>                </span>boundary,<span>
</span></span></span><span><span><span>                </span>MmCached,<span>
</span></span></span><span><span><span>                </span><span>MM_ANY_NODE_OK</span>,<span>
</span></span></span><span><span><span>            </span>)<span>
</span></span></span><span><span><span>        </span>}<span> </span><span>as</span><span> </span><span>*</span><span>mut</span><span> </span><span>u8</span>;<span>
</span></span></span><span><span><span>        </span><span>if</span><span> </span>memory.is_null()<span> </span>{<span>
</span></span></span><span><span><span>            </span>Err(AllocError)<span>
</span></span></span><span><span><span>        </span>}<span> </span><span>else</span><span> </span>{<span>
</span></span></span><span><span><span>            </span><span>let</span><span> </span>slice<span> </span><span>=</span><span> </span><span>unsafe</span><span> </span>{<span> </span>core::slice::from_raw_parts_mut(memory,<span> </span>layout.size())<span> </span>};<span>
</span></span></span><span><span><span>            </span>Ok(<span>unsafe</span><span> </span>{<span> </span>NonNull::new_unchecked(slice)<span> </span>})<span>
</span></span></span><span><span><span>        </span>}<span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>unsafe</span><span> </span><span>fn</span> <span>deallocate</span>(<span>&amp;</span>self,<span> </span>ptr: <span>NonNull</span><span>&lt;</span><span>u8</span><span>&gt;</span>,<span> </span>_layout: <span>Layout</span>)<span> </span>{<span>
</span></span></span><span><span><span>        </span>MmFreeContiguousMemory(ptr.cast().as_ptr());<span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><ul><li>Credits: <a href="https://github.com/not-matthias/kernel-alloc-rs/">https://github.com/not-matthias/kernel-alloc-rs/</a></li></ul><p>We are defining a struct called <code>VmxonRegion</code>, which represents a <code>VMXON Region</code> in memory. This region must be aligned to the page size of <code>4096</code> bytes (or <code>0x1000</code> in hexadecimal). The <code>VmxonRegion</code> structure contains two fields: <code>revision_id</code> and <code>data</code>. The <code>revision_id</code> is a <code>32-bit</code> unsigned integer representing the version of the VMX capabilities supported by the processor, and it takes up <code>4</code> bytes of the memory region. The data field is an array of <code>4092</code> bytes that contains the rest of the <code>VMXON Region</code>. By using the <code>repr(C, align(4096))</code> attribute, we ensure that the <code>VmxonRegion</code> type is laid out exactly as specified, with <code>4096</code> bytes of memory allocated for each instance of this type. This ensures that the <code>VMXON Region</code> is aligned correctly in memory and can be used by the processor without any issues.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>pub</span><span> </span><span>const</span><span> </span><span>PAGE_SIZE</span>: <span>usize</span> <span>=</span><span> </span><span>0x1000</span>;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>#[repr(C, align(4096))]</span><span>
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>struct</span> <span>VmxonRegion</span><span> </span>{<span>
</span></span></span><span><span><span>    </span><span>pub</span><span> </span>revision_id: <span>u32</span>,<span>
</span></span></span><span><span><span>    </span><span>pub</span><span> </span>data: [<span>u8</span>;<span> </span><span>PAGE_SIZE</span><span> </span><span>-</span><span> </span><span>4</span>],<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>We define a function <code>get_vmcs_revision_id</code> that returns the Virtual Machine Control Structure (VMCS) revision ID. To get this revision ID, we read a Model Specific Register (MSR) using the <code>rdmsr</code> function, passing it the MSR identifier <code>IA32_VMX_BASIC</code>. We cast the returned value to a <code>32-bit</code> unsigned integer and then bitwise <code>AND</code> it with <code>0x7FFF_FFFF</code> to clear the high bit, which is reserved. The resulting value is the VMCS revision ID, which we return.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>/// Get the Virtual Machine Control Structure revision identifier (VMCS revision ID) (Intel Manual: 25.11.5 VMXON Region)
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>fn</span> <span>get_vmcs_revision_id</span>()<span> </span>-&gt; <span>u32</span> {<span>
</span></span></span><span><span><span>    </span><span>unsafe</span><span> </span>{<span> </span>(msr::rdmsr(msr::<span>IA32_VMX_BASIC</span>)<span> </span><span>as</span><span> </span><span>u32</span>)<span> </span><span>&amp;</span><span> </span><span>0x7FFF_FFFF</span><span> </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>To convert a virtual address to a physical address, we can use the <code>MmGetVirtualForPhysical</code> undocumented function. Luckily for us we can reuse the code written by <a href="https://twitter.com/not_matthias">@not-matthias</a> in this <a href="https://github.com/not-matthias/amd_hypervisor/blob/main/hypervisor/src/utils/addresses.rs">amd_hypervisor</a> since there is no crate for it currently.</p><p>We have two functions here. The first function, <code>physical_address</code> takes a pointer to a <code>u64</code> and converts it to a physical address of type <code>PAddr</code>. This function is used to convert virtual addresses to physical addresses. The second function <code>va_from_pa</code> takes a physical address and converts it to a virtual address. This is achieved using the Windows kernel undocumented function <code>MmGetVirtualForPhysical</code>.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>pub</span><span> </span><span>fn</span> <span>physical_address</span>(ptr: <span>*</span><span>const</span><span> </span><span>u64</span>)<span> </span>-&gt; <span>PAddr</span><span> </span>{<span>
</span></span></span><span><span><span>    </span>PhysicalAddress::from_va(ptr<span> </span><span>as</span><span> </span><span>u64</span>).<span>0</span><span>
</span></span></span><span><span><span></span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>fn</span> <span>va_from_pa</span>(pa: <span>u64</span>)<span> </span>-&gt; <span>u64</span> {<span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span>physical_address: <span>PHYSICAL_ADDRESS</span><span> </span><span>=</span><span> </span><span>unsafe</span><span> </span>{<span> </span>core::mem::zeroed()<span> </span>};<span>
</span></span></span><span><span><span>    </span><span>unsafe</span><span> </span>{<span> </span><span>*</span>(physical_address.QuadPart_mut())<span> </span><span>=</span><span> </span>pa<span> </span><span>as</span><span> </span><span>i64</span><span> </span>};<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>unsafe</span><span> </span>{<span> </span>MmGetVirtualForPhysical(physical_address)<span> </span><span>as</span><span> </span><span>u64</span><span> </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><ul><li>Credits: <a href="https://github.com/not-matthias/amd_hypervisor/blob/main/hypervisor/src/utils/addresses.rs">https://github.com/not-matthias/amd_hypervisor/blob/main/hypervisor/src/utils/addresses.rs</a></li></ul><p>The <code>VcpuData</code> struct represents data associated with a virtual CPU in a hypervisor, and it contains a field called <code>vmxon_region</code>, which is a zero-initialized naturally aligned <code>4-KByte</code> region of memory, as well as a field called <code>vmxon_region_physical_address</code> which is its physical address. The <code>new()</code> function initializes the <code>VcpuData</code> struct and allocates the <code>VMXON Region</code> in memory using a <code>PhysicalAllocator</code>. The <code>init_vmxon_region()</code> function initializes the <code>VMXON Region</code> with the VMCS revision ID, enables VMX operation by calling <code>vmxon()</code>, and returns an error if the virtual to physical address translation fails.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>pub</span><span> </span><span>struct</span> <span>VcpuData</span><span> </span>{<span>
</span></span></span><span><span><span>    </span><span>/// The virtual and physical address of the Vmxon naturally aligned 4-KByte region of memory
</span></span></span><span><span><span></span><span>    </span><span>pub</span><span> </span>vmxon_region: Box<span>&lt;</span>VmxonRegion,<span> </span>PhysicalAllocator<span>&gt;</span>,<span>
</span></span></span><span><span><span>    </span><span>pub</span><span> </span>vmxon_region_physical_address: <span>u64</span>,<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>impl</span><span> </span>VcpuData<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>pub</span><span> </span><span>fn</span> <span>new</span>()<span> </span>-&gt; Result<span>&lt;</span>Box<span>&lt;</span>Self<span>&gt;</span>,<span> </span>HypervisorError<span>&gt;</span><span> </span>{<span>
</span></span></span><span><span><span>        </span><span>let</span><span> </span>instance<span> </span><span>=</span><span> </span>Self<span> </span>{<span>
</span></span></span><span><span><span>            </span>vmxon_region: <span>unsafe</span><span> </span>{<span> </span>Box::try_new_zeroed_in(PhysicalAllocator)<span>?</span>.assume_init()<span> </span>},<span>
</span></span></span><span><span><span>            </span>vmxon_region_physical_address: <span>0</span>,<span>
</span></span></span><span><span><span>        </span>};<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>        </span><span>let</span><span> </span><span>mut</span><span> </span>instance<span> </span><span>=</span><span> </span>Box::new(instance);<span>
</span></span></span><span><span><span>                
</span></span></span><span><span><span>        </span>log::info!(<span>&#34;[+] init_vmxon_region&#34;</span>);<span>
</span></span></span><span><span><span>        </span>instance.init_vmxon_region()<span>?</span>;<span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>/// Allocate a naturally aligned 4-KByte VMXON region of memory to enable VMX operation (Intel Manual: 25.11.5 VMXON Region)
</span></span></span><span><span><span></span><span>    </span><span>pub</span><span> </span><span>fn</span> <span>init_vmxon_region</span>(<span>&amp;</span><span>mut</span><span> </span>self)<span> </span>-&gt; Result<span>&lt;</span>(),<span> </span>HypervisorError<span>&gt;</span><span> </span>{<span>
</span></span></span><span><span><span>        </span>self.vmxon_region_physical_address<span> </span><span>=</span><span> </span>physical_address(self.vmxon_region.as_ref()<span> </span><span>as</span><span> </span><span>*</span><span>const</span><span> </span>_<span> </span><span>as</span><span> </span>_).as_u64();<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>        </span><span>if</span><span> </span>self.vmxon_region_physical_address<span> </span><span>==</span><span> </span><span>0</span><span> </span>{<span>
</span></span></span><span><span><span>            </span><span>return</span><span> </span>Err(HypervisorError::VirtualToPhysicalAddressFailed);<span>
</span></span></span><span><span><span>        </span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>        </span>log::info!(<span>&#34;[+] VMXON Region Virtual Address: {:p}&#34;</span>,<span> </span>self.vmxon_region);<span>
</span></span></span><span><span><span>        </span>log::info!(<span>&#34;[+] VMXON Region Physical Addresss: 0x{:x}&#34;</span>,<span> </span>self.vmxon_region_physical_address);<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>        </span>self.vmxon_region.revision_id<span> </span><span>=</span><span> </span>support::get_vmcs_revision_id();<span>
</span></span></span><span><span><span>        </span>self.vmxon_region.as_mut().revision_id.set_bit(<span>31</span>,<span> </span><span>false</span>);<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>        </span>support::vmxon(self.vmxon_region_physical_address)<span>?</span>;<span>
</span></span></span><span><span><span>        </span>log::info!(<span>&#34;[+] VMXON successful!&#34;</span>);<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>        </span>Ok(())<span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>The <code>vmxon()</code> function is just a wrapper around the x86 <code>vmxon()</code> function, which calls <code>vmxon &lt;addr&gt;</code> in assembly. However, it is not necessary to create wrappers, but it helps with error handling.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>/// Enable VMX operation.
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>fn</span> <span>vmxon</span>(vmxon_pa: <span>u64</span>)<span> </span>-&gt; Result<span>&lt;</span>(),<span> </span>HypervisorError<span>&gt;</span><span> </span>{<span>
</span></span></span><span><span><span>    </span><span>match</span><span> </span><span>unsafe</span><span> </span>{<span> </span>x86::bits64::vmx::vmxon(vmxon_pa)<span> </span>}<span> </span>{<span>
</span></span></span><span><span><span>        </span>Ok(_)<span> </span><span>=&gt;</span><span> </span>Ok(()),<span>
</span></span></span><span><span><span>        </span>Err(_)<span> </span><span>=&gt;</span><span> </span>Err(HypervisorError::VMXONFailed),<span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>Overall, the above initializes a memory region to enable VMX operation for a virtual CPU in a hypervisor. However, we want to do this for every logical/virtual CPU.</p><h2 id="processors-cores-and-logicalvirtual-processors-vcpus">Processors, Cores and Logical/Virtual Processors (VCPUs)</h2><p><code>Processor:</code> The primary part of a computer that conducts mathematical, logical, input/output (I/O), and control activities is a processor, sometimes known as a central processing unit (CPU). It is in charge of carrying out commands and controlling the data flow inside a computer system.</p><p><code>Cores:</code> A core is a physical processing unit that can carry out instructions within a CPU. In order to work in parallel with other cores, each core typically includes its arithmetic logic unit (ALU), register set, and cache.</p><p><code>Logical Processor:</code> A processing unit within a CPU that can carry out a single thread of instructions is referred to as a logical processor, also known as a virtual processor. Depending on the particular processor design, each physical core in current CPUs can house several logical processors.</p><p>Say we have four physical cores in our processor; this translates to four separate processing units in our CPU. Hyper-threading technology allows for the simultaneous execution of two threads on each core. As a result, there are eight logical processors, which the operating system interprets as eight different CPUs.</p><p>General purpose registers, MSR registers, VMCSs, and <code>VMXON Regions</code> are among the registers to which each logical processor has access. We must ensure that a Virtual Machine Monitor (VMM) is set up to use all logical processors. This will enable us to make the most of our CPU’s capabilities and deliver the best performance for our virtualized workloads.</p><h3 id="rust-7">Rust</h3><p>We have a struct called <code>Vcpu</code> that represents a virtual CPU. It has two fields: <code>index</code>, which is an integer that represents the index of the processor, and <code>data</code>, which is an <a href="https://docs.rs/once_cell/latest/once_cell/"><code>OnceCell</code></a> that holds a boxed <code>VcpuData</code> instance. The <code>new()</code> function takes an <code>index</code> as an argument and creates a new <code>Vcpu</code> instance with that index and an uninitialized data field.</p><p>The <code>virtualize_cpu</code> function is responsible for initializing the virtual CPU for virtualization. It first enables the Virtual Machine Extensions (VMX), <code>adjusts control registers</code>, and then initializes the <code>VcpuData</code> structure by calling <code>get_or_try_init</code> on the <code>data</code> field. The <code>get_or_try_init</code> function initializes the <code>data</code> field if it has not been initialized before or returns the existing value if it has been initialized.</p><p>The <code>devirtualize_cpu()</code> is used to devirtualize the CPU using the <code>vmxoff</code> instruction. This instruction is used to disable virtualization and return control to the host operating system. The function returns a <code>Result</code> indicating whether the operation was successful or not and any relevant error information. The <code>id()</code> returns the index of the current virtual processor, which is helpful in multi-processor systems where we need to identify which processor is executing the code.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>pub</span><span> </span><span>struct</span> <span>Vcpu</span><span> </span>{<span>
</span></span></span><span><span><span>    </span><span>/// The index of the processor.
</span></span></span><span><span><span></span><span>    </span>index: <span>u32</span>,<span>
</span></span></span><span><span><span>    
</span></span></span><span><span><span>    </span>data: <span>OnceCell</span><span>&lt;</span>Box<span>&lt;</span>VcpuData<span>&gt;&gt;</span>,<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>impl</span><span> </span>Vcpu<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>pub</span><span> </span><span>fn</span> <span>new</span>(index: <span>u32</span>)<span> </span>-&gt; Result<span>&lt;</span>Self,<span> </span>HypervisorError<span>&gt;</span><span> </span>{<span>
</span></span></span><span><span><span>        </span>log::trace!(<span>&#34;Creating processor {}&#34;</span>,<span> </span>index);<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>        </span>Ok<span> </span>(Self<span> </span>{<span>
</span></span></span><span><span><span>            </span>index,<span>
</span></span></span><span><span><span>            </span>data: <span>OnceCell</span>::new(),<span>
</span></span></span><span><span><span>        </span>})<span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>pub</span><span> </span><span>fn</span> <span>virtualize_cpu</span>(<span>&amp;</span>self)<span> </span>-&gt; Result<span>&lt;</span>(),<span> </span>HypervisorError<span>&gt;</span><span> </span>{<span>
</span></span></span><span><span><span>        </span>log::info!(<span>&#34;[+] Enabling Virtual Machine Extensions (VMX)&#34;</span>);<span>
</span></span></span><span><span><span>        </span>support::enable_vmx_operation()<span>?</span>;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>        </span>log::info!(<span>&#34;[+] Adjusting Control Registers&#34;</span>);<span>
</span></span></span><span><span><span>        </span>support::adjust_control_registers();<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>        </span>log::info!(<span>&#34;[+] Initializing VcpuData&#34;</span>);<span>        
</span></span></span><span><span><span> 
</span></span></span><span><span><span>        </span><span>let</span><span> </span>_vcpu_data<span> </span><span>=</span><span> </span><span>&amp;</span>self.data.get_or_try_init(<span>||</span><span> </span>VcpuData::new())<span>?</span>;<span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>/// Devirtualize the CPU using vmxoff
</span></span></span><span><span><span></span><span>    </span><span>pub</span><span> </span><span>fn</span> <span>devirtualize_cpu</span>(<span>&amp;</span>self)<span> </span>-&gt; Result<span>&lt;</span>(),<span> </span>HypervisorError<span>&gt;</span><span> </span>{<span>
</span></span></span><span><span><span>        </span>support::vmxoff()<span>?</span>;<span>
</span></span></span><span><span><span>        </span>Ok(())<span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>/// Gets the index of the current logical/virtual processor
</span></span></span><span><span><span></span><span>    </span><span>pub</span><span> </span><span>fn</span> <span>id</span>(<span>&amp;</span>self)<span> </span>-&gt; <span>u32</span> {<span>
</span></span></span><span><span><span>        </span>self.index<span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>The <code>vmxoff()</code> function is just a wrapper around the x86 <code>vmxoff()</code> function, which calls <code>vmxoff</code> in assembly.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>/// Disable VMX operation.
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>fn</span> <span>vmxoff</span>()<span> </span>-&gt; Result<span>&lt;</span>(),<span> </span>HypervisorError<span>&gt;</span><span> </span>{<span>
</span></span></span><span><span><span>    </span><span>match</span><span> </span><span>unsafe</span><span> </span>{<span> </span>x86::bits64::vmx::vmxoff()<span> </span>}<span> </span>{<span>
</span></span></span><span><span><span>        </span>Ok(_)<span> </span><span>=&gt;</span><span> </span>Ok(()),<span>
</span></span></span><span><span><span>        </span>Err(_)<span> </span><span>=&gt;</span><span> </span>Err(HypervisorError::VMXOFFFailed),<span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>Once again, we can reuse the code written by <a href="https://twitter.com/not_matthias">@not-matthias</a> in this <a href="https://github.com/not-matthias/amd_hypervisor/blob/main/hypervisor/src/utils/processor.rs">amd_hypervisor</a> since there is no crate for it currently. The module provides utilities for managing processor affinity, which is the ability to control which processor(s) a thread can execute.</p><p>The <code>processor_count()</code> function returns the number of processors available on the system using the Windows kernel function <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-kequeryactiveprocessorcountex"><code>KeQueryActiveProcessorCountEx</code></a></p><p>The <code>current_processor_index()</code> function returns the index of the processor currently executing the calling thread using the Windows kernel function <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-kegetcurrentprocessornumberex"><code>KeGetCurrentProcessorNumberEx</code></a></p><p>The <code>processor_number_from_index()</code> function takes an <code>index</code> and returns the corresponding <code>PROCESSOR_NUMBER</code> structure, which identifies the processor’s group and number within that group using the Windows kernel function <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-kegetprocessornumberfromindex"><code>KeGetProcessorNumberFromIndex</code></a>. If the index is out of range or if there is an error in the system call, the function returns <code>None</code>.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>pub</span><span> </span><span>fn</span> <span>processor_count</span>()<span> </span>-&gt; <span>u32</span> {<span>
</span></span></span><span><span><span>    </span><span>unsafe</span><span> </span>{<span> </span>KeQueryActiveProcessorCountEx(<span>ALL_PROCESSOR_GROUPS</span>)<span> </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>fn</span> <span>current_processor_index</span>()<span> </span>-&gt; <span>u32</span> {<span>
</span></span></span><span><span><span>    </span><span>unsafe</span><span> </span>{<span> </span>KeGetCurrentProcessorNumberEx(core::ptr::null_mut())<span> </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>/// Returns the processor number for the specified index.
</span></span></span><span><span><span></span><span>fn</span> <span>processor_number_from_index</span>(index: <span>u32</span>)<span> </span>-&gt; Option<span>&lt;</span><span>PROCESSOR_NUMBER</span><span>&gt;</span><span> </span>{<span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span>processor_number<span> </span><span>=</span><span> </span>MaybeUninit::uninit();<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span>status<span> </span><span>=</span><span> </span><span>unsafe</span><span> </span>{<span> </span>KeGetProcessorNumberFromIndex(index,<span> </span>processor_number.as_mut_ptr())<span> </span>};<span>
</span></span></span><span><span><span>    </span><span>if</span><span> </span><span>NT_SUCCESS</span>(status)<span> </span>{<span>
</span></span></span><span><span><span>        </span>Some(<span>unsafe</span><span> </span>{<span> </span>processor_number.assume_init()<span> </span>})<span>
</span></span></span><span><span><span>    </span>}<span> </span><span>else</span><span> </span>{<span>
</span></span></span><span><span><span>        </span>None<span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>The <code>ProcessorExecutor</code> struct temporarily switches execution to a specified processor until it is dropped. When an instance of <code>ProcessorExecutor</code> is created with a valid processor <code>index</code>, the <code>switch_to_processor()</code> function sets the affinity of the calling thread to the specified processor and yields execution to another thread using the Windows kernel function <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-kesetsystemgroupaffinitythread"><code>KeSetSystemGroupAffinityThread</code></a>. If there is an error setting the affinity or yielding execution, the function returns <code>None</code>. When the <code>ProcessorExecutor</code> instance is dropped, the original processor affinity is restored using the Windows kernel function <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-kereverttousergroupaffinitythread"><code>KeRevertToUserGroupAffinityThread</code></a>.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>/// Switches execution to a specific processor until dropped.
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>struct</span> <span>ProcessorExecutor</span><span> </span>{<span>
</span></span></span><span><span><span>    </span>old_affinity: <span>MaybeUninit</span><span>&lt;</span><span>GROUP_AFFINITY</span><span>&gt;</span>,<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>impl</span><span> </span>ProcessorExecutor<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>pub</span><span> </span><span>fn</span> <span>switch_to_processor</span>(i: <span>u32</span>)<span> </span>-&gt; Option<span>&lt;</span>Self<span>&gt;</span><span> </span>{<span>
</span></span></span><span><span><span>        </span><span>if</span><span> </span>i<span> </span><span>&gt;</span><span> </span>processor_count()<span> </span>{<span>
</span></span></span><span><span><span>            </span>log::error!(<span>&#34;Invalid processor index: {}&#34;</span>,<span> </span>i);<span>
</span></span></span><span><span><span>            </span><span>return</span><span> </span>None;<span>
</span></span></span><span><span><span>        </span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>        </span><span>let</span><span> </span>processor_number<span> </span><span>=</span><span> </span>processor_number_from_index(i)<span>?</span>;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>        </span><span>let</span><span> </span><span>mut</span><span> </span>old_affinity<span> </span><span>=</span><span> </span>MaybeUninit::uninit();<span>
</span></span></span><span><span><span>        </span><span>let</span><span> </span><span>mut</span><span> </span>affinity: <span>GROUP_AFFINITY</span><span> </span><span>=</span><span> </span><span>unsafe</span><span> </span>{<span> </span>core::mem::zeroed()<span> </span>};<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>        </span>affinity.Group<span> </span><span>=</span><span> </span>processor_number.Group;<span>
</span></span></span><span><span><span>        </span>affinity.Mask<span> </span><span>=</span><span> </span><span>1</span><span> </span><span>&lt;&lt;</span><span> </span>processor_number.Number;<span>
</span></span></span><span><span><span>        </span>affinity.Reserved[<span>0</span>]<span> </span><span>=</span><span> </span><span>0</span>;<span>
</span></span></span><span><span><span>        </span>affinity.Reserved[<span>1</span>]<span> </span><span>=</span><span> </span><span>0</span>;<span>
</span></span></span><span><span><span>        </span>affinity.Reserved[<span>2</span>]<span> </span><span>=</span><span> </span><span>0</span>;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>        </span>log::trace!(<span>&#34;Switching execution to processor {}&#34;</span>,<span> </span>i);<span>
</span></span></span><span><span><span>        </span><span>unsafe</span><span> </span>{<span> </span>KeSetSystemGroupAffinityThread(<span>&amp;</span><span>mut</span><span> </span>affinity,<span> </span>old_affinity.as_mut_ptr())<span> </span>};<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>        </span>log::trace!(<span>&#34;Yielding execution&#34;</span>);<span>
</span></span></span><span><span><span>        </span><span>if</span><span> </span><span>!</span><span>NT_SUCCESS</span>(<span>unsafe</span><span> </span>{<span> </span>ZwYieldExecution()<span> </span>})<span> </span>{<span>
</span></span></span><span><span><span>            </span><span>return</span><span> </span>None;<span>
</span></span></span><span><span><span>        </span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>        </span>Some(Self<span> </span>{<span> </span>old_affinity<span> </span>})<span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>impl</span><span> </span>Drop<span> </span><span>for</span><span> </span>ProcessorExecutor<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>fn</span> <span>drop</span>(<span>&amp;</span><span>mut</span><span> </span>self)<span> </span>{<span>
</span></span></span><span><span><span>        </span>log::trace!(<span>&#34;Switching execution back to previous processor&#34;</span>);<span>
</span></span></span><span><span><span>        </span><span>unsafe</span><span> </span>{<span>
</span></span></span><span><span><span>            </span>KeRevertToUserGroupAffinityThread(self.old_affinity.as_mut_ptr());<span>
</span></span></span><span><span><span>        </span>}<span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><ul><li>Credits: <a href="https://github.com/not-matthias/amd_hypervisor/blob/main/hypervisor/src/utils/processor.rs">https://github.com/not-matthias/amd_hypervisor/blob/main/hypervisor/src/utils/processor.rs</a></li></ul><p>We have a <code>Hypervisor</code> struct and a <code>HypervisorBuilder</code> struct for virtualization. The <code>HypervisorBuilder</code> struct has a <code>build()</code> function that creates a new <code>Hypervisor</code> instance and returns it as a <code>Result</code>. The <code>build()</code> function checks whether the CPU is an Intel processor and whether it supports the Virtual Machine Extension (VMX) technology. If the CPU and VMX are supported, the function creates and populates a vector (<code>Vec</code>) of virtual CPUs (<code>Vcpu</code>), one per available processor, and initializes a new <code>Hypervisor</code> instance with the vector of virtual CPUs (<code>Vcpu</code>).</p><p>The <code>Hypervisor</code> struct has three methods:</p><ol><li><p>The <code>builder()</code> function returns a new <code>HypervisorBuilder</code> instance.</p></li><li><p>The <code>virtualize()</code> function virtualizes all of the available processors by calling <code>ProcessorExecutor::switch_to_processor()</code> for each processor and then calling the <code>virtualize_cpu()</code> method on each <code>Vcpu</code> instance in the <code>&#34;processors&#34;</code> vector.</p></li><li><p>The <code>devirtualize()</code> function devirtualizes all of the available processors by calling <code>ProcessorExecutor::switch_to_processor()</code> for each processor and then calling the <code>devirtualize_cpu()</code> method on each <code>Vcpu</code> object in the <code>&#34;processors&#34;</code> vector.</p></li></ol><p>The <code>virtualize()</code> and <code>devirtualize()</code> functions use the <code>ProcessorExecutor</code> struct to switch execution to each processor temporarily and then switch back after the virtualization or devirtualization operation is complete.</p><p>Overall, this module provides a way to build a <code>Hypervisor</code> instance with support for virtualizing all available processors and provides methods for virtualizing and devirtualizing the processors using the <code>Vcpu</code> struct and the <code>ProcessorExecutor</code> struct.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>#[derive(Default)]</span><span>
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>struct</span> <span>HypervisorBuilder</span>;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>impl</span><span> </span>HypervisorBuilder<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>pub</span><span> </span><span>fn</span> <span>build</span>(self)<span> </span>-&gt; Result<span>&lt;</span>Hypervisor,<span> </span>HypervisorError<span>&gt;</span><span> </span>{<span>
</span></span></span><span><span><span>        </span><span>//
</span></span></span><span><span><span></span><span>        </span><span>// 1) Intel Manual: 24.6 Discover Support for Virtual Machine Extension (VMX)
</span></span></span><span><span><span></span><span>        </span><span>//
</span></span></span><span><span><span></span><span>        </span>support::has_intel_cpu()<span>?</span>;<span>
</span></span></span><span><span><span>        </span>log::info!(<span>&#34;[+] CPU is Intel&#34;</span>);<span>
</span></span></span><span><span><span>    
</span></span></span><span><span><span>        </span>support::has_vmx_support()<span>?</span>;<span>
</span></span></span><span><span><span>        </span>log::info!(<span>&#34;[+] Virtual Machine Extension (VMX) technology is supported&#34;</span>);<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>        </span><span>let</span><span> </span><span>mut</span><span> </span>processors: Vec<span>&lt;</span>Vcpu<span>&gt;</span><span> </span><span>=</span><span> </span>Vec::new();<span>
</span></span></span><span><span><span>        
</span></span></span><span><span><span>        </span><span>for</span><span> </span>i<span> </span><span>in</span><span> </span><span>0</span><span>..</span>processor_count()<span> </span>{<span>
</span></span></span><span><span><span>            </span>processors.push(Vcpu::new(i)<span>?</span>);<span>
</span></span></span><span><span><span>        </span>}<span>
</span></span></span><span><span><span>        </span>log::info!(<span>&#34;[+] Found {} processors&#34;</span>,<span> </span>processors.len());<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>        </span>Ok(Hypervisor<span> </span>{<span> </span>processors<span> </span>})<span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>struct</span> <span>Hypervisor</span><span> </span>{<span>
</span></span></span><span><span><span>    </span>processors: Vec<span>&lt;</span>Vcpu<span>&gt;</span>,<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>impl</span><span> </span>Hypervisor<span> </span>{<span>
</span></span></span><span><span><span>    
</span></span></span><span><span><span>    </span><span>pub</span><span> </span><span>fn</span> <span>builder</span>()<span> </span>-&gt; <span>HypervisorBuilder</span><span> </span>{<span>
</span></span></span><span><span><span>        </span>HypervisorBuilder::default()<span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>pub</span><span> </span><span>fn</span> <span>virtualize</span>(<span>&amp;</span><span>mut</span><span> </span>self)<span> </span>-&gt; Result<span>&lt;</span>(),<span> </span>HypervisorError<span>&gt;</span><span> </span>{<span>
</span></span></span><span><span><span>        </span>log::info!(<span>&#34;[+] Virtualizing processors&#34;</span>);<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>        </span><span>for</span><span> </span>processor<span> </span><span>in</span><span> </span>self.processors.iter_mut()<span> </span>{<span>
</span></span></span><span><span><span>            
</span></span></span><span><span><span>            </span><span>let</span><span> </span>Some(executor)<span> </span><span>=</span><span> </span>ProcessorExecutor::switch_to_processor(processor.id())<span> </span><span>else</span><span> </span>{<span>
</span></span></span><span><span><span>                </span><span>return</span><span> </span>Err(HypervisorError::ProcessorSwitchFailed);<span>
</span></span></span><span><span><span>            </span>};<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>            </span>processor.virtualize_cpu()<span>?</span>;<span>
</span></span></span><span><span><span>                
</span></span></span><span><span><span>            </span>core::mem::drop(executor);<span>
</span></span></span><span><span><span>        </span>}<span>
</span></span></span><span><span><span>        </span>Ok(())<span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>pub</span><span> </span><span>fn</span> <span>devirtualize</span>(<span>&amp;</span><span>mut</span><span> </span>self)<span> </span>-&gt; Result<span>&lt;</span>(),<span> </span>HypervisorError<span>&gt;</span><span> </span>{<span>
</span></span></span><span><span><span>        </span>log::info!(<span>&#34;[+] Devirtualizing processors&#34;</span>);<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>        </span><span>for</span><span> </span>processor<span> </span><span>in</span><span> </span>self.processors.iter_mut()<span> </span>{<span>
</span></span></span><span><span><span>            
</span></span></span><span><span><span>            </span><span>let</span><span> </span>Some(executor)<span> </span><span>=</span><span> </span>ProcessorExecutor::switch_to_processor(processor.id())<span> </span><span>else</span><span> </span>{<span>
</span></span></span><span><span><span>                </span><span>return</span><span> </span>Err(HypervisorError::ProcessorSwitchFailed);<span>
</span></span></span><span><span><span>            </span>};<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>            </span>processor.devirtualize_cpu()<span>?</span>;<span>
</span></span></span><span><span><span>                
</span></span></span><span><span><span>            </span>core::mem::drop(executor);<span>
</span></span></span><span><span><span>        </span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>        </span>Ok(())<span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>This follows a similar neat structure to the <a href="https://github.com/not-matthias/amd_hypervisor/blob/main/hypervisor/src/svm/mod.rs">amd_hypervisor</a> made by <a href="https://twitter.com/not_matthias">@not-matthias</a>, which will help integrate the open-source projects if required.</p><ul><li>Credits: <a href="https://github.com/not-matthias/amd_hypervisor/blob/main/hypervisor/src/svm/mod.rs">https://github.com/not-matthias/amd_hypervisor/blob/main/hypervisor/src/svm/mod.rs</a></li></ul><p>We create a Windows kernel driver in Rust. When loaded, the <code>driver_entry</code> function is called automatically, and we initialize a logger and set the driver unload function to <code>driver_unload</code>. We then attempt to virtualize the processor by calling <code>virtualize().is_none()</code>. If the virtualization process fails, we return <code>STATUS_UNSUCCESSFUL</code>, and if it succeeds, we return <code>STATUS_SUCCESS</code>.</p><p>The <code>virtualize()</code> function is responsible for virtualizing the processor using the <code>hypervisor</code> module. To do this, we create a new hypervisor using <code>Hypervisor::builder()</code> and attempt to build it using <code>hv.build()</code>. If the build process fails, we log an error message and return <code>None</code>. If the build process succeeds, we attempt to virtualize the processor using <code>hypervisor.virtualize()</code>. If the virtualization process succeeds, we log a success message, and if it fails, we log an error message and return <code>None</code>. If the virtualization process succeeds, we save the hypervisor in a static mutable variable called <code>HYPERVISOR</code> and return <code>Some(())</code>.</p><p>When our driver is unloaded, the <code>driver_unload</code> function is called automatically, which devirtualizes the processor using the <code>hypervisor</code> module. If the devirtualization process succeeds, we log a success message, and if it fails, we log the error message.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>static</span><span> </span><span>mut</span><span> </span><span>HYPERVISOR</span>: Option<span>&lt;</span>Hypervisor<span>&gt;</span><span> </span><span>=</span><span> </span>None;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>#[no_mangle]</span><span>
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>extern</span><span> </span><span>&#34;system&#34;</span><span> </span><span>fn</span> <span>driver_entry</span>(driver: <span>&amp;</span><span>mut</span><span> </span><span>DRIVER_OBJECT</span>,<span> </span>_: <span>&amp;</span><span>UNICODE_STRING</span>)<span> </span>-&gt; <span>NTSTATUS</span><span> </span>{<span>
</span></span></span><span><span><span>    </span>KernelLogger::init(LevelFilter::Info).expect(<span>&#34;Failed to initialize logger&#34;</span>);<span>
</span></span></span><span><span><span>    </span>log::info!(<span>&#34;Driver Entry called&#34;</span>);<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span>driver.DriverUnload<span> </span><span>=</span><span> </span>Some(driver_unload);<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>if</span><span> </span>virtualize().is_none()<span> </span>{<span>
</span></span></span><span><span><span>        </span>log::error!(<span>&#34;Failed to virtualize processors&#34;</span>);<span>
</span></span></span><span><span><span>        </span><span>return</span><span> </span><span>STATUS_UNSUCCESSFUL</span>;<span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>STATUS_SUCCESS</span><span>
</span></span></span><span><span><span></span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>extern</span><span> </span><span>&#34;system&#34;</span><span> </span><span>fn</span> <span>driver_unload</span>(_driver: <span>&amp;</span><span>mut</span><span> </span><span>DRIVER_OBJECT</span>)<span> </span>{<span>
</span></span></span><span><span><span>    </span>log::info!(<span>&#34;Driver unloaded successfully!&#34;</span>);<span>
</span></span></span><span><span><span>    
</span></span></span><span><span><span>    </span><span>if</span><span> </span><span>let</span><span> </span>Some(<span>mut</span><span> </span>hypervisor)<span> </span><span>=</span><span> </span><span>unsafe</span><span> </span>{<span> </span><span>HYPERVISOR</span>.take()<span> </span>}<span> </span>{<span>
</span></span></span><span><span><span>        </span><span>match</span><span> </span>hypervisor.devirtualize()<span> </span>{<span>
</span></span></span><span><span><span>            </span>Ok(_)<span> </span><span>=&gt;</span><span> </span>log::info!(<span>&#34;[+] Devirtualized successfully!&#34;</span>),<span>
</span></span></span><span><span><span>            </span>Err(err)<span> </span><span>=&gt;</span><span> </span>log::error!(<span>&#34;[-] Failed to dervirtualize {}&#34;</span>,<span> </span>err),<span>
</span></span></span><span><span><span>        </span>}<span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>fn</span> <span>virtualize</span>()<span> </span>-&gt; Option<span>&lt;</span>()<span>&gt;</span><span> </span>{<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span>hv<span> </span><span>=</span><span> </span>Hypervisor::builder();<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span>Ok(<span>mut</span><span> </span>hypervisor)<span> </span><span>=</span><span> </span>hv.build()<span> </span><span>else</span><span> </span>{<span>
</span></span></span><span><span><span>        </span>log::error!(<span>&#34;[-] Failed to build hypervisor&#34;</span>);<span>
</span></span></span><span><span><span>        </span><span>return</span><span> </span>None;<span>
</span></span></span><span><span><span>    </span>};<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>match</span><span> </span>hypervisor.virtualize()<span> </span>{<span>
</span></span></span><span><span><span>        </span>Ok(_)<span> </span><span>=&gt;</span><span> </span>log::info!(<span>&#34;[+] VMM initialized&#34;</span>),<span>
</span></span></span><span><span><span>        </span>Err(err)<span> </span><span>=&gt;</span><span>  </span>{<span>
</span></span></span><span><span><span>            </span>log::error!(<span>&#34;[-] VMM initialization failed: {}&#34;</span>,<span> </span>err);<span>
</span></span></span><span><span><span>            </span><span>return</span><span> </span>None;<span>
</span></span></span><span><span><span>        </span>}<span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>unsafe</span><span> </span>{<span> </span><span>HYPERVISOR</span><span> </span><span>=</span><span> </span>Some(hypervisor)<span> </span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span>Some(())<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>We can now test our code by creating a service and starting it to load our Windows kernel driver.</p><div><pre tabindex="0"><code data-lang="fallback"><span><span>sc.exe create hypervisor type= kernel binPath= C:\Windows\System32\drivers\hypervisor.sys
</span></span><span><span>sc.exe query hypervisor
</span></span><span><span>sc.exe start hypervisor
</span></span></code></pre></div><p>The output is shown in Windbg:</p><div><pre tabindex="0"><code data-lang="fallback"><span><span>INFO  [driver] Driver Entry called
</span></span><span><span>INFO  [hypervisor] [+] CPU is Intel
</span></span><span><span>INFO  [hypervisor] [+] Virtual Machine Extension (VMX) technology is supported
</span></span><span><span>INFO  [hypervisor] [+] Found 2 processors
</span></span><span><span>INFO  [hypervisor] [+] Virtualizing processors
</span></span><span><span>INFO  [hypervisor::vcpu] [+] Enabling Virtual Machine Extensions (VMX)
</span></span><span><span>INFO  [hypervisor::support] [+] Lock bit set via IA32_FEATURE_CONTROL
</span></span><span><span>INFO  [hypervisor::vcpu] [+] Adjusting Control Registers
</span></span><span><span>INFO  [hypervisor::support] [+] Mandatory bits in CR0 set/cleared
</span></span><span><span>INFO  [hypervisor::support] [+] Mandatory bits in CR4 set/cleared
</span></span><span><span>INFO  [hypervisor::vcpu] [+] Initializing VcpuData
</span></span><span><span>INFO  [hypervisor::vcpu_data] [+] init_vmxon_region
</span></span><span><span>INFO  [hypervisor::vcpu_data] [+] VMXON Region Virtual Address: 0xffffa3801098a000
</span></span><span><span>INFO  [hypervisor::vcpu_data] [+] VMXON Region Physical Addresss: 0x23ffc1000
</span></span><span><span>INFO  [hypervisor::vcpu_data] [+] VMXON successful!
</span></span></code></pre></div><p>Congratulations! You have completed the first part of the Intel VT-x Hypervisor Development in Rust series. I hope you enjoyed it.</p><h2 id="credits--references--thanks--motivation">Credits / References / Thanks / Motivation</h2><p>Thanks to <a href="https://twitter.com/daax_rynd">@daax_rynd</a>, <a href="https://twitter.com/Intel80x86">@Intel80x86</a>, <a href="https://twitter.com/not_matthias">@not_matthias</a>, <a href="https://twitter.com/standa_t">@standa_t</a>, and <a href="https://github.com/felix-rs">@felix-rs / @joshuа</a></p><ul><li>7 Days to Virtualization: A Series on Hypervisor Development: <a href="https://revers.engineering/7-days-to-virtualization-a-series-on-hypervisor-development/">https://revers.engineering/7-days-to-virtualization-a-series-on-hypervisor-development/</a></li><li>Hypervisor From Scratch: <a href="https://rayanfam.com/tutorials/">https://rayanfam.com/tutorials/</a></li><li>amd_hypervisor: <a href="https://github.com/not-matthias/amd_hypervisor/">https://github.com/not-matthias/amd_hypervisor/</a></li><li>Hypervisor-101-in-Rust: <a href="https://github.com/tandasat/Hypervisor-101-in-Rust">https://github.com/tandasat/Hypervisor-101-in-Rust</a></li><li>RustyVisor: <a href="https://github.com/iankronquist/rustyvisor/">https://github.com/iankronquist/rustyvisor/</a></li><li>RVM1.5: <a href="https://github.com/rcore-os/RVM1.5/">https://github.com/rcore-os/RVM1.5/</a></li><li>Barbervisor: <a href="https://github.com/Cisco-Talos/Barbervisor/">https://github.com/Cisco-Talos/Barbervisor/</a></li><li>Orange Slice: <a href="https://github.com/gamozolabs/orange_slice">https://github.com/gamozolabs/orange_slice</a></li><li>Orange Slice: Writing the Hypervisor: <a href="https://www.youtube.com/watch?v=WabeOICAOq4&amp;list=PLSkhUfcCXvqFJAuFbABktmLaQvJwKxJ3i">https://www.youtube.com/watch?v=WabeOICAOq4&amp;list=PLSkhUfcCXvqFJAuFbABktmLaQvJwKxJ3i</a></li><li><a href="https://git.back.engineering/_xeroxz/bluepill">https://git.back.engineering/_xeroxz/bluepill</a></li><li><a href="https://secret.club/2020/07/06/bottleye.html">https://secret.club/2020/07/06/bottleye.html</a></li><li><a href="https://secret.club/2020/04/13/how-anti-cheats-detect-system-emulation.html">https://secret.club/2020/04/13/how-anti-cheats-detect-system-emulation.html</a></li><li><a href="https://secret.club/2020/01/12/battleye-hypervisor-detection.html">https://secret.club/2020/01/12/battleye-hypervisor-detection.html</a></li><li><a href="https://openai.com/blog/chatgpt">https://openai.com/blog/chatgpt</a></li><li><a href="https://www.grammarly.com/">https://www.grammarly.com/</a></li></ul><p><strong>Full Disclaimer</strong>: Thanks to <a href="https://openai.com/blog/chatgpt">OpenAI’s ChatGPT</a>, and <a href="https://www.grammarly.com/">Grammarly</a> for helping/assisting me to write some parts of the blog. This was the first time I used <a href="https://chat.openai.com/">ChatGPT</a> in my blog, and might be the last time as I believe that you learn more if you write everything yourself, even if your grammar, spelling, or descriptions are not great. I learned a lot from reading/writing/porting code and reading <a href="https://revers.engineering/7-days-to-virtualization-a-series-on-hypervisor-development/">@daax_rynd’s</a>, <a href="https://rayanfam.com/">@Intel80x86’s</a> and <a href="https://github.com/not-matthias/amd_hypervisor">@not_matthias’s</a> work. When you use ChatGPT, I highly recommend that people try to reword it as much as possible and give credits to whoever deserves it.</p></section></div>
  </body>
</html>
