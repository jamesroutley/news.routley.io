<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ajxs.me/blog/Introduction_to_Reverse-Engineering_Vintage_Synth_Firmware.html">Original</a>
    <h1>Introduction to reverse-engineering vintage synth firmware</h1>
    
    <div id="readability-page-1" class="page"><div>
        <p>
          In this article we&#39;re going to take a look at how to reverse-engineer
          vintage synthesiser firmware. The synthesiser I&#39;ve chosen for us to
          look at is the Yamaha DX7 (<i>See <a href="#why_the_dx7">Appendix: Why Choose This Synth?</a></i>). You don&#39;t need a DX7 to follow along at home, but you will need a
          copy of the DX7 V1.8 firmware (available
          <a href="https://dbwbp.com/index.php/9-misc/37-synth-eprom-dumps" target="_blank">here</a>) and the
          <a href="https://ghidra-sre.org/" target="_blank">Ghidra</a>
          disassembler.
        </p>
        <div>
          <p>
            <span>Who is this article for?</span>
            This article&#39;s intended audience is people from a technical
            background who are new to reverse-engineering, 8-bit architectures,
            or embedded development. If you come from an electrical-engineering
            or embedded-software background, you&#39;ll probably find the content
            here a little basic.
          </p>
          <p>
            You&#39;ll only need to know a little bit about low-level programming: A
            basic understanding of how binary and pointers work should be
            enough. You don&#39;t need to know assembly language, or understand any
            specific processor architecture.
          </p>
        </div>
        <p>
          A few years ago I decided to give myself a crash course on what goes
          on inside synthesisers. I ended up writing the article
          <a href="https://ajxs.me/blog/Yamaha_DX7_Technical_Analysis.html" target="_blank">Yamaha DX7 Technical Analysis</a>
          about what I&#39;d learned. In order to tease out some more details about
          the DX7&#39;s inner-workings, I decided to
          <a href="https://github.com/ajxs/yamaha_dx7_rom_disassembly" target="_blank">disassemble the synth&#39;s firmware ROM</a>. I didn&#39;t have any experience with reverse-engineering binaries, so
          I had to figure it out as I went. I&#39;m still by no means an expert (<i>if you see any mistakes in this article, please let me know!</i>), but I&#39;d like to share what I&#39;ve learned.
        </p>
        <p>
          All I had when I started was a copy of the firmware, a copy of the
          service manual, and a <i>can-do</i> attitude. I knew nothing about
          8-bit systems, and <em>absolutely nothing</em> about electronics, but
          I was willing to give anything a shot. If this sounds like you, read
          on, and I hope you find this article helpful!
        </p>

        

        <p>
          Reverse-engineering vintage synthesisers is a great introduction to
          embedded systems, and can be a lot of fun. In a lot of ways
          reverse-engineering is a bit like putting together a big jigsaw
          puzzle. Sometimes putting a new piece in place unlocks a lot of new
          progress, and like a jigsaw puzzle, the best place to start is at the
          edges.
        </p>

        <h2 id="address_decoding">
          Address Decoding <a href="#address_decoding">#</a>
        </h2>
        <p>
          The peripheral devices attached to the DX7&#39;s CPU, such as its LCD
          screen and sound chips, are <i>memory-mapped</i>. This means that the
          device has been allocated a specific address range in the system&#39;s
          memory, and the system communicates with the device by reading and
          writing data from and to these addresses.
        </p>
        <p>
          Before we can start disassembling the firmware ROM, we need to know
          what peripheral device is mapped where. To do that we&#39;ll need to look
          at the DX7&#39;s <i>address decoding</i> logic. The first place to start
          is with the schematics.
        </p>
        <p>
          The best version of the schematics I&#39;ve seen is
          <a href="https://yamahamusicians.com/forum/viewtopic.php?p=90769#p90769" target="_blank">this</a>
          version, created by the yamahamusicians.com user <i>Miks</i>. While
          you&#39;re at it, grab a copy of the
          <a href="https://homepages.abdn.ac.uk/d.j.benson/pages/dx7/manuals/dx7-9_service_manual_1.pdf" target="_blank">service manual</a>
          too. We won&#39;t be referencing it in this article, but it&#39;s a good
          resource to have. It explains certain details about the synth&#39;s
          architecture that aren&#39;t obvious from the schematics.
        </p>
        <p><span>Service Manuals:</span>
          Most consumer devices from the 80s and 90s have
          <i>service manuals</i> available. These are technical documents
          written by the manufacturer to assist in servicing the device. They
          typically include schematics, diagrams, and lists of electrical
          components. The first place to start when reverse-engineering a device
          is looking for its service manual.
        </p>
        <p>
          If you&#39;re new to electronics, device schematics can look very
          intimidating, but once you understand the basics they&#39;re not actually
          as scary as they look! You can find a good introductory guide to
          schematics
          <a href="https://learn.sparkfun.com/tutorials/how-to-read-a-schematic/all" target="_blank">here</a>.
        </p>

        <h3>Background</h3>
        <p>
          But first, what does <i>address decoding</i> actually mean?
          <a href="https://en.wikipedia.org/wiki/Address_decoder" target="_blank">Address decoding</a>
          refers to <em>how</em> a specific device is mapped to a specific
          address. In this section we&#39;ll figure out what peripheral is mapped to
          what address by tracing the address decoding logic in the synth&#39;s
          schematics.
        </p>
        <p>
          The total amount of memory addresses that a CPU can access is referred
          to as the CPU&#39;s <i>&#39;address space&#39;</i>. This is limited by the
          <i>width</i> of its <i>&#39;address bus&#39;</i>. The CPU&#39;s address bus is
          responsible for selecting addresses in attached memory devices, such
          as RAM, or peripheral devices with addressable registers. Each
          <i>line</i> in the address bus represents a single bit, with the total
          number of lines determining the address range the CPU can access. For
          example, a 16-bit address bus can address 2<sup>16</sup> unique memory
          locations, or 64KiB.
        </p>
        <p>
          When a CPU&#39;s address lines are exposed externally in the form of pins
          on the chip&#39;s package, this is called an <i>external</i> address
          bus<sup><a href="#footnote_1" id="footnote_1_link">1</a></sup>. These lines can be physically connected to external memory devices.
          Together with the CPU&#39;s <i>data bus</i>, this allow reading and
          writing binary data back and forth.
        </p>
        <p>
          When the CPU performs an instruction that reads or writes memory, like
          <code>LDB 0x2001</code>, several things happen:
        </p>
        <ul>
          <li>
            The CPU&#39;s external address pins are set to high and low
            <a href="https://en.wikipedia.org/wiki/Logic_level" target="_blank">logic levels</a>
            according to the specified address. For address
            <span>0x2001</span>
            (<code>0b0010_0000_0000_0001</code>), address pins 0 and 13 will be
            high, and all the others will be low.
          </li>
          <li>
            The CPU&#39;s <code>RW</code> pin will be set high to
            indicate that this is a <i>read</i> operation, and...
          </li>
          <li>
            The CPU will prepare to accept the incoming data at
            <span>0x2001</span> over the data bus into the
            <span>B</span> register.
          </li>
        </ul>

        <p>
          But wait... If the CPU only has one set of address and data bus lines,
          how do you connect multiple memory devices to the CPU? This is where
          the
          <a href="https://en.wikipedia.org/wiki/Chip_select" target="_blank"><i>&#39;Chip Select&#39;</i></a>
          interface comes in: Each device attached to the CPU&#39;s data/address
          buses has a &#39;Chip Select&#39; pin, controlling whether the device responds
          to incoming signals.
        </p>
        <p>
          <a href="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/address_decoding_logic.png" target="_blank">
            <img alt="A schematic showing the address decoding logic of a hypothetical system." src="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/address_decoding_logic_thumbnail.jpg"/>
          </a>
          Consider the above (incredibly simplified) diagram: Two 8KiB
          <a href="https://en.wikipedia.org/wiki/6264" target="_blank">6264</a>
          RAM chips (U3 and U4) are connected to shared address and data buses
          on a Z80 CPU. U3&#39;s <code>CE1</code> (Chip Enable)
          pin is connected to the CPU&#39;s A13 pin. The bar over the top of the
          label indicates that this pin is <i>&#39;Active Low&#39;</i>, meaning a low
          logic level will &#39;activate&#39; its function. When the CPU selects an
          address between <span>0x0</span> and
          <span>0x1FFF</span>, the A13 pin will be low,
          activating the U3 chip. U4&#39;s <code>CE1</code> pin
          is attached to the CPU&#39;s A13 pin via a <code>NOT</code> gate, which
          inverts the signal coming from A13. When an address above
          <span>0x1FFF</span> is selected, A13 will be set
          high, selecting the U4 chip. This effectively maps U3 to the first
          8KiB of the system&#39;s memory, and U4 to the next.
        </p>
        <p>
          Can you spot the problem with this example? Since <em>any</em> address
          using A13 will &#39;select&#39; U4, U4 is now mapped to <em>every</em> 8KiB
          block of memory above <span>0x1FFF</span>. In
          reality, more sophisticated logic is used to map memory devices. Let&#39;s
          examine the real world example of the DX7&#39;s address decoding
          circuitry.
        </p>

        <p><span>Logic Gates:</span>
          The DX7&#39;s <i>address decoding logic</i> is primarily implemented via
          the use of <i>logic gates</i>. If you&#39;re not familiar with logic
          gates, a good introduction to the topic can be found
          <a href="https://www.khanacademy.org/computing/computers-and-internet/xcae6f4a7ff015e7d:computers/xcae6f4a7ff015e7d:logic-gates-and-circuits/a/logic-gates" target="_blank">here</a>. Don&#39;t worry though, we&#39;re not going to be going too in-depth. A
          basic understanding of what <code>AND</code>, <code>OR</code>, and
          <code>NOT</code> gates do is all you need. One particular type of
          component you&#39;ll encounter a lot inside vintage synthesisers are
          <a href="https://en.wikipedia.org/wiki/7400-series_integrated_circuits" target="_blank">7400-series logic chips</a>.
        </p>

        <h2 id="memory_map">
          Decoding the DX7&#39;s Memory Map
          <a href="#memory_map">#</a>
        </h2>
        <p>
          Nearly all of the discrete electrical components that make up a DX7
          are commonly available products. They&#39;re mass-manufactured and sold by
          a variety of different manufacturers. The best way to understand these
          components is to read the <i>datasheets</i> made available by the
          manufacturer. I&#39;ll provide links to these as we go.
        </p>
        <p><span>Note:</span>
          The creator of the DX7 schematics used the <i>logic</i> symbols ·
          and + to denote <code>AND</code> and <code>OR</code> gates, rather
          than the more standard
          <a href="https://www.electrical-symbols.com/electrical-electronics-pdf/Logic_Gates_Symbols.pdf" target="_blank">
            ANSI, or IEC notations </a><sup>[pdf]</sup>. Other gates use the ANSI notation.
        </p>
        <h3 id="rom_address_decoding">
          The Firmware ROM
          <a href="#rom_address_decoding">#</a>
        </h3>
        <p>Let&#39;s start by taking a look at the firmware ROM, IC14.</p>
        <figure>
          <a href="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/schematics/rom.png" target="_blank">
            <img alt="An excerpt from the Yamaha DX7&#39;s schematics, with the ROM address mapping logic highlighted" src="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/schematics/rom_thumbnail.jpg"/>
          </a>
          <figcaption>
            An excerpt from the Yamaha DX7&#39;s schematics, with the ROM address
            mapping logic highlighted.
          </figcaption>
        </figure>
        <p>
          In the schematic we can see that IC14&#39;s
          <code>CE1</code> pin is connected to the CPU&#39;s
          <code>A14/A15</code> lines via an <code>AND</code> gate, and a
          <code>NOT</code> gate. What&#39;s going on here?
        </p>
        <p>
          The <code>AND</code> gate ensures that the signal is only high when
          <em>both</em> address lines are active, and the <code>NOT</code> gate
          inverts the signal so that it activates the <em>active-low</em>
          <code>CE1</code> pin. If <code>A14</code> and
          <code>A15</code> being active on the CPU &#39;selects&#39; the ROM chip, that
          means it&#39;s mapped to the address range
          <span>0xC000 - 0xFFFF</span><sup><a href="#footnote_2" id="footnote_2_link">2</a></sup>.
        </p>
        <p>
          Awesome! That wasn&#39;t so hard. Now we know where the ROM is mapped in
          memory. What&#39;s next?
        </p>

        <h3 id="ram_address_decoding">
          RAM <a href="#ram_address_decoding">#</a>
        </h3>
        <p>
          The address decoding logic for the RAM is a little more complicated.
        </p>
        <figure>
          <a href="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/schematics/ram.png" target="_blank">
            <img alt="An excerpt from the Yamaha DX7&#39;s schematics, with the RAM address mapping logic highlighted" src="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/schematics/ram_thumbnail.jpg"/>
          </a>
          <figcaption>
            An excerpt from the Yamaha DX7&#39;s schematics, with the RAM address
            mapping logic highlighted.
          </figcaption>
        </figure>
        <p>
          The DX7 features three 4KiB
          <a href="https://www.allaboutcircuits.com/electronic-components/datasheet/M5M5118P--Mitsubishi/" target="_blank">5118P</a>
          RAM chips (IC19, 20, 21). These are connected to the CPU&#39;s address bus
          via a
          <a href="https://www.ti.com/product/SN74LS138" target="_blank">74LS138 demultiplexer</a>
          (IC23). This
          <a href="https://www.electronics-tutorials.ws/combination/comb_3.html" target="_blank">demultiplexing</a>
          circuit is used to select one of 8 individual output lines based on a
          3-bit input signal. These output lines are labeled as
          <code>Y<sub>0</sub></code> -
          <code>Y<sub>7</sub></code>, and the input lines as <code>D<sub>A</sub></code>, <code>D<sub>B</sub></code>, and <code>D<sub>C</sub></code>. The <code>OR</code> gates used here are wired to the system clock
          output pin. Presumably to ensure the timing of read and write
          operations are valid.
        </p>
        <figure>
          <a href="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/74ls138_function_table.png" target="_blank">
            <img alt="The function table from the 74LS138P&#39;s datasheet" src="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/74ls138_function_table_thumbnail.jpg"/>
          </a>
          <figcaption>
            The &#39;Function Table&#39; from the 74LS138P&#39;s datasheet, showing what
            combinations of input lines select which output line.
          </figcaption>
        </figure>
        <p>
          The first RAM chip (IC19)&#39;s chip select terminal is connected to the
          demultiplexer&#39;s
          <code>Y<sub>2</sub></code> line. The &#39;Function
          Table&#39; from the 74LS138P datasheet shows that
          <code>Y<sub>2</sub></code> will be set low when
          input <code>D<sub>B</sub></code> (connected to the CPU&#39;s
          <code>A12</code>) is high. Therefore, when the CPU selects address
          <span>0x1000</span>, the first RAM chip will be
          selected.
        </p>
        <p>
          <code>Y<sub>3</sub></code>
          (connected to the second RAM chip, IC20) will be set low when inputs
          <code>D<sub>A</sub></code> and <code>D<sub>B</sub></code> (<code>A11</code>
          and <code>A12</code>) are high, corresponding to an address of
          <span>0x1800</span>. Likewise,
          <code>Y<sub>4</sub></code>
          (connected to IC21) corresponds to an address of
          <span>0x2000</span>.
        </p>
        <p>
          By tracing this address decoding logic, we&#39;ve successfully mapped the
          synth&#39;s RAM to
          <span>0x1000 - 0x2800</span>.
        </p>

        <h3 id="lcd_address_decoding">
          LCD Screen <a href="#lcd_address_decoding">#</a>
        </h3>
        <p>
          The last peripheral we&#39;re going to look at right now is the synth&#39;s
          LCD screen. When you take your first peek inside a binary you&#39;ll be
          staring at an intimidating jumble of machine code. One of the few
          things that will stand out at a glance is ASCII strings. A good way to
          get a quick overview of the binary is finding out how these strings
          are printed to the screen, and where.
        </p>
        <p>
          The best place to start doing that is understanding how the CPU
          interfaces with the LCD controller, and working your way backwards to
          the code responsible for sending string data to it. Once you&#39;ve found
          <em>how</em> strings are printed to the screen, you can easily see
          <em>what&#39;s</em> printed <em>where</em> to get a better understanding
          of the code.
        </p>
        <figure>
          <a href="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/schematics/lcd.png" target="_blank">
            <img alt="An excerpt from the Yamaha DX7&#39;s schematics, with the LCD address mapping logic highlighted" src="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/schematics/lcd_thumbnail.jpg"/>
          </a>
          <figcaption>
            An excerpt from the Yamaha DX7&#39;s schematics, with the LCD address
            mapping logic highlighted.
          </figcaption>
        </figure>
        <p>
          The LCD address mapping logic might look really complicated, but don&#39;t
          worry though. It&#39;s just more of the same logic as before.
        </p>
        <p>
          IC23&#39;s <code>Y<sub>5</sub></code> pin is connected
          to IC24, another 74LS138 demultiplexer. From the 74LS138 function
          table we know that <code>Y<sub>5</sub></code> goes
          low when inputs A, and C (<code>A11</code> and <code>A13</code>) are
          high. So it looks like IC24 is mapped to
          <span>0x2800</span>.
        </p>
        <p>
          Take a look at IC24: Inputs A, B and C are wired to
          <code>A1</code>, <code>A2</code> and <code>A3</code>. That means that
          IC24 only maps <em>8 bytes</em>.
        </p>
        <p>
          IC24&#39;s <code>Y<sub>0</sub></code> and
          <code>Y<sub>1</sub></code> pins are connected to an
          <code>AND</code> gate connected to the &#39;chip select&#39; pin of IC12.
          What&#39;s happening here? This might seem a little confusing at first,
          but since the 74LS138P&#39;s outputs are <i>active-low</i>, this makes
          <code>LCDCS</code> active when either
          <code>Y<sub>0</sub></code> or
          <code>Y<sub>1</sub></code> are active. This maps
          IC12 to the four-byte range
          <span>0x2800 - 0x2803</span>. Awesome. But what&#39;s
          IC12 doing?
        </p>
        <p>
          IC12 is an
          <a href="https://en.wikipedia.org/wiki/Intel_8255" target="_blank">Intel 8255</a>
          <i>Programmable Peripheral Interface (PPI)</i>. It provides 24
          parallel, bidirectional IO lines<sup><a href="#footnote_3" id="footnote_3_link">3</a></sup>.
        </p>
        <figure>
          <a href="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/8255_basic_operation.png" target="_blank">
            <img alt="An excerpt from the Intel 8255 datasheet showing its basic operations" src="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/8255_basic_operation_thumbnail.jpg"/>
          </a>
          <figcaption>
            An excerpt from the Intel 8255 datasheet showing its basic
            operations.
          </figcaption>
        </figure>
        <p>
          The schematics show the LCD&#39;s parallel interface (<code>DB0 - DB7</code>) is connected to the PPI&#39;s port A (<code>PA0 - PA7</code>), and its
          control pins (<code>E, RW</code> and <code>RS</code>) to the PPI&#39;s
          port B (<code>PB0 - PB2</code>).
        </p>
        <p>
          The Hitachi LM016 LCD screen used in the DX7 features the ubiquitous
          <i><a href="https://en.wikipedia.org/wiki/Hitachi_HD44780_LCD_controller" target="_blank">Hitachi HD44780 LCD Controller</a></i>. According to its datasheet (available
          <a href="https://www.sparkfun.com/datasheets/LCD/HD44780.pdf" target="_blank">here</a>) it has two registers. When its <code>RS</code> line (connected to
          the PPI&#39;s <code>PB0</code>) is low, the <i>instruction register</i> is
          selected. When high, the <i>data register</i> is selected.
        </p>
        <p>
          Based on the HD44780 datasheet, and the above table from the 8255&#39;s
          datasheet, we can tell that the LCD&#39;s data register must be mapped to
          <span>0x2800</span>, and its control register to
          <span>0x2801</span>. We&#39;ll go into more detail
          about the LCD controller itself later in the article.
        </p>

        <h3 id="wrapping_up">
          Wrapping Up <a href="#wrapping_up">#</a>
        </h3>
        <p>
          Now we&#39;ve got a pretty good idea of what&#39;s going on where in the
          memory map, and how this is discovered. To save you the trouble of
          going through the whole schematic, here are all the memory-mapped
          peripheral addresses.
        </p>
        <table>
          <tbody><tr>
            <th>Address Range</th>
            <th>Peripheral</th>
          </tr>
          <tr>
            <td><span>0x1000 - 0x2800</span></td>
            <td>RAM (External)</td>
          </tr>
          <tr>
            <td><span>0x2800</span></td>
            <td>LCD Data</td>
          </tr>
          <tr>
            <td><span>0x2801</span></td>
            <td>LCD Control</td>
          </tr>
          <tr>
            <td><span>0x2802</span></td>
            <td>Sustain/Portamento Pedals, and LCD Busy Line</td>
          </tr>
          <tr>
            <td><span>0x2803</span></td>
            <td>8255 Peripheral Controller Control Register</td>
          </tr>
          <tr>
            <td><span>0x2804</span></td>
            <td>OPS Mode register</td>
          </tr>
          <tr>
            <td><span>0x2805</span></td>
            <td>OPS Algorithm/Feedback register</td>
          </tr>
          <tr>
            <td><span>0x280A</span></td>
            <td>DAC Volume</td>
          </tr>
          <tr>
            <td><span>0x280E</span></td>
            <td>LED1</td>
          </tr>
          <tr>
            <td><span>0x280F</span></td>
            <td>LED2</td>
          </tr>
          <tr>
            <td><span>0x3000 - 0x4000</span></td>
            <td>EGS</td>
          </tr>
          <tr>
            <td><span>0x4000 - 0x5000</span></td>
            <td>Cartridge Interface</td>
          </tr>
          <tr>
            <td><span>0xC000 - 0xFFFF</span></td>
            <td>ROM</td>
          </tr>
        </tbody></table>

        <p>
          These aren&#39;t the only peripherals attached to the system, the Hitachi
          6303 CPU also features &#39;IO Ports&#39;. These are memory-mapped
          input/output lines with their own dedicated functionality. We&#39;ll touch
          on these later in the article.
        </p>

        <h2 id="disassembling_the_firmware">
          Disassembling The Firmware
          <a href="#disassembling_the_firmware">#</a>
        </h2>
        <p>
          Now that we know the memory map, we can start disassembling the
          firmware. To do this we&#39;ll use a graphical disassembler called
          <a href="https://ghidra-sre.org/" target="_blank">Ghidra</a><sup><a href="#footnote_4" id="footnote_4_link">4</a></sup>. It&#39;s a relatively new player on the scene, but it&#39;s free, open
          source, and very powerful. A great resource to keep handy while
          working with Ghidra is the
          <a href="https://ghidra-sre.org/CheatSheet.html" target="_blank">Ghidra Cheat Sheet</a>.
        </p>

        <p><span>Ghidra 6303 Support:</span>
          As of the time of writing, Ghidra doesn&#39;t yet support the HD6303
          architecture out of the box, so we&#39;ll need to install our own language
          specification.
          <a href="https://github.com/blackjetrock/ghidra-6303" target="_blank">This</a>
          repository contains a Ghidra language specification for the 6303
          architecture. To install it, download the repository and copy the
          <code>6303</code> directory to the
          <code>Ghidra/Processors</code> directory inside your Ghidra
          installation. You&#39;ll need to restart Ghidra to see the new processor
          in the list.
        </p>

        <p>
          Once you&#39;ve installed the language definitions, open Ghidra and create
          a new project.
          <a href="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/new_project.png" target="_blank">
            <img alt="A screenshot of Ghidra showing the &#39;New Project&#39; dialog" src="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/new_project_thumbnail.jpg"/>
          </a>

          The first thing we&#39;re going to need to do is to import the firmware
          ROM binary. Select the &#39;6303&#39; language, and click &#39;OK&#39;.
          <a href="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/set_language.png" target="_blank">
            <img alt="A screenshot of Ghidra showing the &#39;Select Language&#39; dialog" src="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/set_language_thumbnail.jpg"/>
          </a>
        </p>
        <p>
          Next, open up the <i>Codebrowser</i>. This is where all the action
          happens.
          <a href="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/codebrowser.png" target="_blank">
            <img alt="A screenshot of Ghidra showing the &#39;Codebrowser&#39; button" src="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/codebrowser_thumbnail.jpg"/>
          </a>
        </p>
        <p>
          Once the initial disassembly loads, the first thing you&#39;ll be looking
          at is row after row of hexadecimal. This is the actual machine code as
          it would appear to the CPU. Don&#39;t bother with <i>analyzing</i> the
          file.
        </p>
        <p>
          The first thing we&#39;re going to do is set up the memory map. Remember
          that thing we just did all that hard work figuring out? That&#39;s going
          to come in handy now. Press the <b>&#39;Display Memory Map&#39;</b> icon in
          the top button bar, to open up the Memory Map dialog.
          <a href="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/display_memory_map.png" target="_blank">
            <img alt="A screenshot of Ghidra showing the &#39;Display Memory Map&#39; button" src="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/display_memory_map_thumbnail.jpg"/>
          </a>

          By default there&#39;s only one memory block defined. This block consists
          of the binary we just imported, so go ahead and rename it to
          <i>&#39;ROM&#39;</i>. The next thing we need to do is move this block to the
          correct offset <span>0xC000</span>. Because all of
          the machine code instructions reference memory with absolute
          addresses, if we didn&#39;t map the ROM to the correct location none of
          the disassembly would work.
          <a href="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/move_block_button.png" target="_blank">
            <img alt="A screenshot of Ghidra showing the &#39;Move Memory Block&#39; button" src="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/move_block_button_thumbnail.jpg"/>
          </a>

          <a href="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/move_block.png" target="_blank">
            <img alt="A screenshot of Ghidra showing the &#39;Move Memory Block&#39; dialog" src="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/move_block_thumbnail.jpg"/>
          </a>
        </p>
        <p>
          Before we finish setting up the memory map, let&#39;s take a quick look at
          the code. When the Hitachi 6303 processor in the DX7 powers up, it
          knows where to begin executing code by fetching a pointer from a
          specific location in the <i>interrupt vector table</i>.
        </p>
        <figure>
          <a href="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/interrupt_vectors.png" target="_blank">
            <img alt="An excerpt table from the 6301/6303 Handbook showing the 6303&#39;s interrupt vector table" src="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/interrupt_vectors_thumbnail.jpg"/>
          </a>
          <figcaption>
            An excerpt table from the 6301/6303 Handbook showing the 6303&#39;s
            interrupt vector table.
          </figcaption>
        </figure>
        <p>
          In this case the <i>&#39;Reset vector&#39;</i> is always located at the
          specific memory address <span>0xFFFE</span>, right
          at the end of the address space. Press the
          <span>
            <span>Ctrl</span><span>+</span><span>End</span>
          </span>
          combination on your keyboard to move to the end of the binary, and
          select the offset <span>0xFFFE</span> by clicking
          on it. Press the
          <span><span>P</span></span>
          key on your keyboard to convert the data at this address to a pointer.
          You should see something similar to the image below.
          <a href="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/reset_vector_pointer.png" target="_blank">
            <img alt="A screenshot from Ghidra showing the reset vector pointer" src="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/reset_vector_pointer_thumbnail.jpg"/>
          </a>
        </p>
        <p>
          Double-click on this pointer to take you to the associated offset in
          the binary. Now we&#39;ve found where the actual code is located, but it
          doesn&#39;t look like much just yet.
          <a href="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/reset_handler_location.png" target="_blank">
            <img alt="A screenshot from Ghidra showing the reset handler function" src="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/reset_handler_location_thumbnail.jpg"/>
          </a>
        </p>
        <p>
          To begin disassembling the machine code into something we can work
          with, click on the label and press the
          <span><span>D</span></span>
          key on your keyboard, or right-click and select
          <i>&#39;Disassemble&#39;</i> in the context menu.
        </p>
        <p><span>The Reset Vector:</span>
          Different processor architectures will have different methods for
          locating the reset handler. Typically a pointer to the reset handler
          will be stored in an <i>interrupt vector table</i> (IVT) at a fixed
          location in memory. On an ARM Cortex-M processor the IVT is located at
          address <span>0x0</span>, and the reset vector at
          <span>0x4</span>. On the
          <a href="https://en.wikipedia.org/wiki/MCS-51" target="_blank">MCS-51</a>
          architecture —another popular 8-bit microcontroller commonly
          seen in synthesisers— the actual reset <em>handler</em> begins
          at <span>0x0</span>.
        </p>
        <p>
          The disassembly process will follow the flow of code through the
          binary, disassembling as it goes. An error will pop up here, but don&#39;t
          worry about it for now. This is just the disassembler mistaking a jump
          table for code.
          <a href="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/analyzer_error.png" target="_blank">
            <img alt="A screenshot from Ghidra showing the expected &#39;analyzer error&#39; message" src="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/analyzer_error_thumbnail.jpg"/>
          </a>
        </p>
        <p>
          Once the disassembly completes you should see something like the
          picture below.
          <a href="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/reset_handler_disassembled.png" target="_blank">
            <img alt="A screenshot from Ghidra showing the disassembled reset handler" src="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/reset_handler_disassembled_thumbnail.jpg"/>
          </a>
        </p>
        <p>
          Now we&#39;re looking at real code! No need to panic though. If you don&#39;t
          understand what you&#39;re looking at, that&#39;s okay. Assembly can look
          pretty intimidating at first, but with a little bit of practice you&#39;ll
          get the hang of it!
        </p>
        <p>
          Each of the lines you&#39;re seeing here represents a single machine-code
          instruction translated into assembly code. The three letter
          <i>mnemonics</i> are the human-readable representation of the
          instructions.
          <span>LDA</span>
          for example, is the mnemonic for the
          <i>&#39;Load value into register A&#39;</i> instruction.
          <span>STA</span>
          is the mnemonic for the
          <i>&#39;Store value in register A&#39;</i> instruction. If you&#39;ve never
          encountered assembly language before, that&#39;s okay!
          <a href="https://youtu.be/4gwYkEK0gOk?si=ZY9W2wwP2YZEtN7V" target="_blank">This</a>
          video will give a very quick and general introduction to assembly
          language.
        </p>
        <p>
          The HD63B03RP CPU used in the DX7 is a member of the
          <a href="https://www.cpushack.com/tag/6800/" target="_blank">6800</a>
          family of processors. Its instruction set (the full set of assembly
          <i>instructions</i>) is small and easy to understand. A great resource
          for understanding the 6303 CPU and its instruction set is the
          <i><a href="http://www.bitsavers.org/components/hitachi/_dataBooks/1989_U07_HD6301_HD6303_Series_Handbook_1989.pdf" target="_blank">
              HD6301/HD6303 Series Handbook
            </a></i>
          freely available on bitsavers.org.
        </p>
        <p>
          The <span>FUN_c5e5</span> text you&#39;re seeing
          here is a <i>label</i>. This is a symbol placed in the disassembler&#39;s
          <a href="https://en.wikipedia.org/wiki/Symbol_table" target="_blank">symbol table</a>, which can be referenced elsewhere in the assembly code, usually as
          the target for a branching instruction. Ghidra should already have set
          up the reset vector as a &#39;function&#39;. Select this label with your
          cursor and press the
          <span><span>F</span></span>
          key on your keyboard to edit the function and give it a more
          meaningful label like
          <span>reset</span>.
        </p>
        <p>
          But what are all these red labels we&#39;re seeing, like
          <span>DAT_2575</span>?
          If you try to double click on it, Ghidra offers a helpful error
          message: <i>&#39;Address not found in program memory: 2575&#39;</i>. This is
          because we&#39;re missing our memory map! Let&#39;s go back to the &#39;Memory
          Map&#39; dialog, and add the missing blocks.
          <a href="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/adding_ram_memory_map.png" target="_blank">
            <img alt="A screenshot showing adding the RAM memory map block in Ghidra" src="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/adding_ram_memory_map_thumbnail.jpg"/>
          </a>
        </p>
        <p>
          Fill in the memory map that we worked out in the last section. The
          completed map should look something like the screenshot below. You can
          choose to consolidate some of these blocks if you like. It&#39;s not super
          important how the blocks are divided. What matters is that the blocks
          cover all of the needed peripheral addresses.

          <a href="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/memory_map.png" target="_blank">
            <img alt="The completed memory map shown in Ghidra, with all peripheral address space allocated" src="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/memory_map_thumbnail.jpg"/>
          </a>

          Note that I added memory blocks for the HD6303 CPU&#39;s internal
          registers, and internal RAM.
        </p>
        <p>
          Now is a good time to go and fill in the individual peripheral
          addresses that we know. The
          <a href="http://www.bitsavers.org/components/hitachi/_dataBooks/1989_U07_HD6301_HD6303_Series_Handbook_1989.pdf" target="_blank">HD6301/HD6303 Series Handbook</a>
          provides a list of the HD6303RP&#39;s internal registers.
        </p>
        <figure>
          <a href="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/internal_register_area.png" target="_blank">
            <img alt="An excerpt from the Hitachi HD6301/HD6303 Series Handbook showing the IO port addresses" src="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/internal_register_area_thumbnail.jpg"/>
          </a>
          <figcaption>
            An excerpt from the Hitachi HD6301/HD6303 Series Handbook showing
            the IO port addresses.
          </figcaption>
        </figure>
        <p>
          Press the
          <span>
            <span>Ctrl</span><span>+</span><span>Home</span>
          </span>
          keys on your keyboard to go to address
          <span>0x0</span>. Press the
          <span><span>B</span></span> key
          on your keyboard to declare that address
          <span>0x0</span> specifies a byte of data. You&#39;ll
          see the <code>??</code> change to <code>db</code>, which is the
          assembler <i>directive</i> to define a byte of memory. Press the
          <span><span>L</span></span>
          key on your keyboard to give this address a useful label like
          <span>io_port_1_dir</span>. Go ahead and fill
          in the rest of the peripherals. When you go back to the reset handler
          you&#39;ll notice that, even with only a few pieces of the jigsaw puzzle
          in place, things will start to make a lot more sense.
        </p>

        <h3 id="reset_function">
          The Reset Function <a href="#reset_function">#</a>
        </h3>
        <p>
          The main reset handler in the DX7 is responsible for initialising the
          firmware. It sets up the CPU&#39;s IO ports, ensures the firmware&#39;s
          important variables have valid values, and sets up the CPU&#39;s
          <i>timer interrupt</i>. More on this later.
        </p>
        <p><span>Registers:</span>
          The 6303 has three general-purpose
          <a href="https://en.wikipedia.org/wiki/Accumulator_(computing)" target="_blank">accumulator</a>
          registers: <span>A</span>,
          <span>B</span>, and
          <span>D</span>.
          <span>A</span> and
          <span>B</span> are both 8-bits in size, and
          <span>D</span> provides a 16-bit view of both of
          them combined: <code>D == (A &lt;&lt; 8) | B</code>.
        </p>
        <p>
          A great way to visualise the <i>&#39;control flow&#39;</i> of the program is
          in the <i>&#39;Function Graph&#39;</i> view. This view shows a directed graph
          of the program&#39;s branching logic. You can open this view by selecting
          <b>Window → Function Graph</b> in the top window menu. You
          should see a view similar to the picture below.
          <a href="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/reset_function_graph.png" target="_blank">
            <img alt="A screenshot of Ghidra&#39;s function graph of the reset handler" src="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/reset_function_graph_thumbnail.jpg"/>
          </a>
          At offset <span>0xC605</span> you&#39;ll see the
          following instructions:
        </p>
        <div>
          <pre><span></span><span>LDA</span><span>   </span><span>#</span><span>0</span><span>xd</span>
<span>CMPA</span><span>  </span><span>DAT_2328</span>
<span>BHI</span><span>   </span><span>LAB_c60f</span>
</pre>
        </div>
        <ol>
          <li>
            The <span>LDA</span> instruction loads
            the <i>immediate</i> value <code>0xD</code> into the
            <span>A</span> register.
          </li>
          <li>
            The <span>CMPA</span> instruction then
            compares the value in the <span>A</span>
            register with the value at the memory address
            <span>DAT_2328</span>.
          </li>
          <li>
            The <span>BHI</span> instruction tells
            the CPU to branch to the label
            <span>LAB_c60f</span>
            if the value in the <span>A</span>
            register is greater than the value at
            <span>DAT_2328</span>.
          </li>
        </ol>
        <p><span>Condition Codes:</span>
          What <em>actually</em> happens when you execute a
          <span>CMPA</span>
          instruction is that the CPU sets a series of fields in the
          <i>&#39;condition code&#39;</i> register based on the result of the
          comparison. These <i>&#39;condition codes&#39;</i> are used by the conditional
          branching instructions to determine whether or not to take the branch.
          In this case, the
          <span>BHI</span> instruction will take
          the branch if the <i>C(arry)</i> and <i>Z(ero)</i>
          condition codes are both clear.
        </p>
        <p>
          You can see in the function graph that if the memory at
          <span>DAT_2328</span>
          is greater than or equal to &#39;13&#39;, it will not branch, and the value
          will be cleared. The program will then continue to execute the next
          instruction, which would have been the original branch target. In this
          case, the program is checking to see that the &#39;pitch bend range&#39;
          variable (stored in memory at location
          <span>0x2328</span>) is within a valid range of
          0-12. If not, it&#39;s reset to 0.
        </p>
        <p>
          If you look down at the bottom of the graph, you&#39;ll notice something
          interesting: The program goes into an infinite loop. This is the
          firmware&#39;s <i>&#39;main loop&#39;</i>.
          <a href="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/main_loop.png" target="_blank">
            <img alt="The firmware&#39;s &#39;main loop&#39;" src="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/main_loop_thumbnail.jpg"/>
          </a>
          Tasks that need to be performed continuously happen here. Such as
          updating the UI based on user input, and parsing incoming MIDI
          messages.
        </p>
        <p>
          When certain tasks not only need to be performed <i>continuously</i>,
          but also <i>periodically</i>, there&#39;s another way to make this happen:
          <i>interrupts</i>.
        </p>
        <h3 id="interrupts">
          Interrupts <a href="#interrupts">#</a>
        </h3>
        <p>
          <a href="https://en.wikipedia.org/wiki/Interrupt" target="_blank">Interrupts</a>
          are signals sent to the processor by hardware or software to
          <em>interrupt</em> the current code being executed, and handle a
          specific event. They&#39;re commonly used in embedded-software to handle
          external, time-critical, or asynchronous events.
        </p>
        <p>
          One of the most common types of interrupt you&#39;ll encounter is a
          <a href="https://www.visualmicro.com/page/Timer-Interrupts-Explained.aspx" target="_blank"><i>&#39;timer interrupt&#39;</i></a>. The HD6303&#39;s built-in timer interrupt consists of a 16-bit
          <i>&#39;counter&#39;</i> register, which is incremented every clock cycle, and
          a 16-bit <i>&#39;output compare&#39;</i> register. When the value in the
          counter register matches the value in the output compare register, a
          timer interrupt will be raised. This causes the processor to halt what
          it was doing, push the current state of the CPU onto the stack, and
          jump to the appropriate interrupt handler specified in the interrupt
          vector table. In the 6303 a pointer to this handler is located at
          offset <span>0xFFF4</span>. Once the firmware is
          done handling the interrupt, it executes the
          <span>RTI</span> instruction, which
          restores the CPU&#39;s state from the stack and continues executing the
          code from where it left off.
        </p>
        <p>
          The timer interrupt handler is where all the synth&#39;s
          <i>real-time</i> functionality happens. This is any code that needs to
          be executed in a time-critical manner. The DX7 uses the periodic timer
          interrupt to process portamento and modulation, update the individual
          voice frequencies, and send the updated voice data to the sound chips.
          Feel free to declare the pointer to the timer interrupt handler just
          like we did for the reset handler, disassemble the handler, and take a
          look at what&#39;s going on.
          <a href="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/ocf_handler.png" target="_blank">
            <img alt="A screenshot from Ghidra showing the interrupt vector table and the OCF interrupt handler pointer" src="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/ocf_handler_thumbnail.jpg"/>
          </a>
        </p>
        <h3 id="lcd_interface">
          LCD Interface <a href="#lcd_interface">#</a>
        </h3>
        <p>
          One of the best places to start reverse-engineering a synth&#39;s firmware
          is to understand how it prints things to the LCD screen. We already
          know <em>where</em> the LCD controller is mapped in memory, let&#39;s work
          backwards from there and see if we can find that code.
        </p>
        <p>
          Press the
          <span><span>G</span></span> key
          on your keyboard to open the <i>&#39;Go To...&#39;</i> dialog, and go to
          address <span>0x2800</span>.
          <a href="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/lcd_registers.png" target="_blank">
            <img alt="A screenshot from Ghidra showing the LCD registers" src="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/lcd_registers_thumbnail.jpg"/>
          </a>
          These are the two memory-mapped LCD registers. The list of
          <i>cross-references</i> on the right shows us where these addresses
          are referenced in the code. Click on the
          <span>FUN_fdef</span> label to take us to this
          function. This is the function called by the reset handler to
          initialise the LCD screen.
        </p>
        <p>
          Below the function we can see something that looks like ASCII data.
          <a href="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/welcome_message.png" target="_blank">
            <img alt="Screenshot from Ghidra showing ASCII data embedded in the code" src="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/welcome_message_thumbnail.jpg"/>
          </a>
          In fact, it looks a lot like the welcome message displayed when you
          boot up the DX7. Hmm. Click on offset
          <span>0xFE31</span>, and press the
          <span><span>&#39;</span></span> key
          on the keyboard twice. Once to convert the data at this offset to
          character data, twice to convert it to a NULL-terminated string.
        </p>
        <p>
          Notice that the welcome message location is referenced in the code at
          offset
          <span>0xFE2B</span>:
        </p>
        <div>
          <pre><span></span><span>JSR</span><span>   </span><span>FUN_fe52</span>
<span>LDX</span><span>   </span><span>#</span><span>0</span><span>xfe31</span>
<span>JMP</span><span>   </span><span>FUN_fea4</span>
</pre>
        </div>
        <p>
          Select the operand <code>#0xFe31</code>, and press
          <span>
            <span>Alt</span><span>+</span><span>Ctrl</span><span>+</span><span>R</span>
          </span>
          on your keyboard to turn this into a
          <i>memory reference</i>. The default label looks a bit strange, so you
          might want to give it a better one like
          <span>str_welcome_message</span>
          by selecting the reference and pressing the
          <span><span>L</span></span> key.
        </p>
        <p>
          We can see here that a pointer to the welcome message string is loaded
          into the <span>X</span> register, and then the
          ROM jumps to the function
          <span>FUN_fea4</span>. Could this function have
          something to do with printing the string? Let&#39;s find out.
        </p>
        <p><span>The Index Register (X):</span>
          The Motorola 6800 family of processors has an interesting feature
          called an
          <a href="https://en.wikipedia.org/wiki/Index_register" target="_blank"><i>&#39;index register&#39;</i></a>. The index register (<span>X</span>) can be
          used as a 16-bit base address, to which an 8-bit relative offset can
          be applied. For example, the <code>LDA 4,x</code> instruction will
          load the byte into <span>A</span> that is 4
          bytes from the address stored in <span>X</span>.
          This is useful because it allows us to reference 16-bit addresses with
          only an 8-bit operand.
        </p>
        <p>
          Let&#39;s take a walk through <span>FUN_fea4</span>
          together and see if we can figure out what it&#39;s doing:
          <a href="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/lcd_print_and_update.png" target="_blank">
            <img alt="Screenshot from Ghidra showing an unknown function that prints the welcome message to the LCD screen" src="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/lcd_print_and_update_thumbnail.jpg"/>
          </a>
        </p>
        <ol>
          <li>
            First, it pushes the address of the welcome message string in
            <span>X</span> to the stack.
          </li>
          <li>
            Then it loads a memory address (<span>0x261F</span>) into <span>X</span>, and saves that address
            to a pointer in memory.
          </li>
          <li>
            Then it restores the welcome message address from the stack into
            <span>X</span>.
          </li>
        </ol>
        <p>
          Not very helpful yet, unfortunately. Something I find that helps make
          sense of so many unknown labels is to give them names that describe
          how they&#39;re used. Double-click on the label
          <span>DAT_00fb</span> to go to its location.
          Since we know this variable stores memory addresses, press the
          <span><span>P</span></span> key
          to convert it to a pointer. Giving it a name like
          <span>unknown_lcd_pointer_00fb</span>
          can help identify it at a glance later.
        </p>
        <p>
          Use the
          <span>
            <span>Alt</span><span>+</span><span>←</span>
          </span>
          keyboard combination to navigate back to where we were before. Once
          you&#39;re there, click through to
          <span>FUN_fe8b</span>.

          <a href="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/lcd_strcpy.png" target="_blank">
            <img alt="A screenshot from Ghidra showing the function located at 0xfe8b" src="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/lcd_strcpy_thumbnail.jpg"/>
          </a>

          We can see that lots of cross-references to this function have been
          found in the code already. Let&#39;s go through this function step by step
          and see what we can figure out:
        </p>
        <ol>
          <li>
            We already know that the
            <span>X</span> register contains a pointer to
            a string. So we can see that this function is loading an ASCII
            character into register <span>B</span> from
            the address stored in <span>X</span>.
          </li>
          <li>
            When the <span>LDB</span> instruction
            loads a new value into <span>B</span> it sets
            the <i>condition codes</i> according to its value. If the
            most-significant bit of this byte is 1, the
            <i>N(egative)</i> condition code will be set. This will cause the
            <span>BMI</span> (<i><b>B</b>ranch If <b>MI</b>nus</i>) instruction to branch. Valid
            <a href="https://www.asciitable.com/" target="_blank">ASCII</a>
            values fall within the range 0-127, so this code looks like it&#39;s
            checking for an invalid character, and will branch to the exit if
            this is the case.</li>
          <li>
            The value in <span>B</span> is then compared
            against <code>0x20</code> (ASCII space). As I mentioned earlier, the
            <span>CMP</span> instruction sets
            condition codes according to the value in the associated
            accumulator, and the operand. The
            <span>BCC</span> instruction (<i><b>B</b>ranch If <b>C</b>arry <b>C</b>lear</i>) will branch if the <i>C(arry)</i> condition code is
            <em>clear</em>. This means that the value in
            <span>B</span> must be <code>0x20</code> or
            above, otherwise the function exits.</li>
          <li>
            If the ASCII char is valid, it calls
            <span>BSR</span> to branch to the
            subroutine <span>FUN_fe9a</span>. In this
            subroutine we can immediately see something interesting: Remember
            that pointer we labeled earlier? This subroutine writes the ASCII
            character in <span>B</span>
            to the location in this pointer, increments the pointer, and saves
            it...
          </li>
          <li>
            After this, the address in <span>X</span> is
            incremented, and the function loops back to the start. Now the
            function repeats, with <span>X</span> pointing
            to the <em>next</em> character in the string.
          </li>
        </ol>
        <p>
          Are you thinking what I&#39;m thinking? This is a
          <em>String Copy</em> function! It copies characters from a string into
          a buffer, until either a NULL-terminator, or other unprintable ASCII
          character is encountered.
        </p>
        <p>
          Go ahead and give this function a label like
          <span>lcd_strcpy</span>. If you like, you can
          apply local labels to <span>LAB_fe94</span>,
          and <span>LAB_fe99</span> like
          <span>.copy_character</span> and
          <span>.exit</span>. Maybe give that buffer
          address we saw earlier (<span>0x261F</span>) a
          temporary label too.
        </p>
        <p><span>Subroutines:</span>
          You might have noticed the instructions
          <span>BSR</span>
          (<i>&#39;<b>B</b>ranch to <b>S</b>ub<b>R</b>outine&#39;</i>), or
          <span>JSR</span> (<i>&#39;<b>J</b>ump to <b>S</b>ub<b>R</b>outine&#39;</i>). These instructions are used to call <i>subroutines</i>. When a
          subroutine is <i>called</i>, the address of the next instruction is
          pushed onto the stack, and the
          <a href="https://en.wikipedia.org/wiki/Program_counter" target="_blank"><i>&#39;program counter&#39;</i></a>
          jumps to the address of the subroutine. When the subroutine calls the
          <span>RTS</span> instruction to
          <i>return</i> to its caller, this address is popped from the stack
          into the <span>PC</span> (Program Counter)
          register, and the program continues from where it left off. Just like
          a function call in a higher-level language.
        </p>
        <p>
          This is where we&#39;re at so far:
          <a href="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/lcd_function_partially_annotated.png" target="_blank">
            <img alt="A screenshot from Ghidra showing the function located at 0xfea4 partially annotated" src="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/lcd_function_partially_annotated_thumbnail.jpg"/>
          </a>
        </p>
        <p>
          Let&#39;s move on to that last function
          <span>FUN_fe52</span> and see where that leads
          us. This function is a bit more complicated. Using the
          <i>Function Graph</i> window I showed you before might help visualise
          what&#39;s going on.
          <a href="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/lcd_update.png" target="_blank">
            <img alt="A screenshot from Ghidra showing the function graph of the function located at 0xfe52" src="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/lcd_update_thumbnail.jpg"/>
          </a>
          Let&#39;s go through this function step-by-step like we did before:
        </p>
        <ol>
          <li>
            A new location in memory (<span>0x263F</span>)
            is being saved to that pointer we saw before, and the LCD buffer
            address we saw earlier (<span>0x261F</span>) is
            being saved to a new pointer. There&#39;s something interesting about
            those addresses. They&#39;re 32 bytes apart. That seems a bit
            conspicuous, doesn&#39;t it? Maybe this corresponds to the length of the
            LCD screen (2 lines of 16 characters)?
          </li>
          <li>
            A constant value is loaded into
            <span>B</span>.
          </li>
          <li>
            Inside the loop, we can see that
            <span>B</span> is saved to the stack. A byte
            is then loaded into <span>A</span> from the
            location in the pointer at <span>0xF9</span>. We
            know from seeing the welcome message string loaded into
            <span>X</span>
            that this byte is ASCII string data. The pointer is then incremented
            and saved.
          </li>
          <li>
            This byte is then compared against the byte pointed to by
            <span>unknown_lcd_pointer_00fb</span>.
          </li>
          <li>
            If the character in
            <span>unknown_lcd_pointer_00f9</span> and
            <span>unknown_lcd_pointer_00fb</span>
            <em>aren&#39;t</em> equal, then this character is used as an argument
            for a function call to <span>FUN_fec7</span>.
          </li>
        </ol>
        <p>
          The function at <span>FUN_fec7</span> is a bit
          more complicated, so I&#39;ll walk you through what&#39;s happening.
          <a href="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/lcd_write_instruction.png" target="_blank">
            <img alt="The firmware&#39;s &#39;main loop&#39;" src="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/lcd_write_instruction_thumbnail.jpg"/>
          </a>
        </p>

        <ol>
          <li>
            The constant <code>0x89</code> is written to the 8255 PPI control
            register at <span>0x2803</span>. The PPI
            datasheet refers to this as <i>&#39;Control Word #5&#39;</i>. This sets the
            PPI&#39;s Port A, and B to outputs, allowing the CPU to send data to the
            LCD controller.
          </li>
          <li>
            A value of zero is written to the LCD control register. This sets
            the <code>RS</code> line low to select the
            <i>Instruction Register</i>, and the <code>RW</code> line low to
            select a <i>Write</i> operation.
          </li>
          <li>
            The <code>E</code> line of the LCD is then driven high to instruct
            it to be ready to receive data over the data bus.
          </li>
          <li>
            The byte in <span>A</span> is then written to
            the LCD instruction register. After this, the <code>E</code> line is
            driven low, and the <code>RW</code> line is driven high to signal
            the end of the data transfer.
          </li>
          <li>
            The 8255 <i>&#39;Control Word #13&#39;</i> is written to the PPI control
            register to revert port A and C to being inputs.
          </li>
          <li>
            Finally, it branches unconditionally to
            <span>FUN_ff08</span>.
          </li>
        </ol>

        <p><span>Note about unconditional branches:</span>
          Sometimes, rather than returning with an
          <span>RTS</span> instruction, a
          subroutine will just unconditionally branch to the next subroutine. As
          long as the stack is managed correctly, this is perfectly valid. The
          second subroutine&#39;s ending
          <span>RTS</span>
          instruction will just pop the original return value from the stack and
          return to the original caller. This technique saves a few bytes of
          code.
        </p>

        <p>
          Let&#39;s check out the subroutine at
          <span>FUN_ff08</span> that our function jumps
          to.
          <a href="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/lcd_wait_ready.png" target="_blank">
            <img alt="A screenshot from Ghidra showing the subroutine at 0xFF08." src="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/lcd_wait_ready_thumbnail.jpg"/>
          </a>
        </p>
        <ol>
          <li>
            The <code>E</code> and <code>RW</code> lines of the LCD controller
            are set high. This sets the LCD controller to read mode.
          </li>
          <li>
            The PPI&#39;s port C is read into the
            <span>A</span> register, then the
            <code>E</code> line of the LCD controller is set low to indicate the
            read operation is complete.
          </li>
          <li>
            A bitwise <code>AND</code> is performed between value of the
            <span>A</span> register and
            <code>0b1000_0000</code>. This checks the status of the
            <code>PC7</code> line. If the <code>PC7</code> line is high, the
            function loops back to the start.
          </li>
        </ol>
        <p>
          It&#39;s easy to miss, but if you look closely in the schematics you&#39;ll
          see that the PPI&#39;s <code>PC7</code> line is connected to
          <code>PA7</code>, which is connected to the LCD controller&#39;s DB7 pin.
          <a href="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/schematics/lcd_busy_line.png" target="_blank">
            <img alt="An excerpt from the Yamaha DX7&#39;s schematics showing the PPI&#39;s connection to the LCD controller&#39;s &#39;Busy Flag&#39; line" src="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/schematics/lcd_busy_line_thumbnail.jpg"/>
          </a>
          The DB7 pin serves as the LCD controller&#39;s <i>&#39;Busy Flag&#39;</i>. This
          flag indicates whether the LCD controller is busy processing data.
          When it&#39;s clear, the LCD controller is ready to accept new data.
        </p>
        <p>
          It looks like the purpose of this function is to poll the LCD
          controller, waiting for it to be ready to accept new data. Awesome!
          Let&#39;s give it a label like
          <span>lcd_wait_ready</span>. Okay! So putting
          it all together, the function at
          <span>0xFEC7</span> writes an
          <em>instruction</em> to the LCD controller, and then waits for it to
          be ready to receive data again. Go ahead and give it a name like
          <span>lcd_write_instruction</span>.
        </p>
        <p>
          Reverse-engineering often involves going down a rabbit hole. Sometimes
          you need to fill in a few different pieces of the puzzle before you
          can start to see the whole picture. Let&#39;s return to the function at
          <span>FUN_fe52</span> and see what happens
          next.
        </p>
        <p>
          We now know the loop is writing an instruction to the LCD controller,
          but what did this instruction do? The original instruction value when
          the function started was <code>0x80</code>, and it&#39;s incremented by
          one with each iteration of the loop. The HD44780 datasheet tells us
          that <code>0x80</code> is the instruction to set the DDRAM (Display
          Data RAM) address in the LCD controller. This is the address in the
          LCD&#39;s memory where the next character will be written. A value of
          <code>0x80</code> indicates the start of the screen&#39;s first line.
        </p>
        <p>
          <a href="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/lcd_write_data.png" target="_blank">
            <img alt="The firmware&#39;s &#39;main loop&#39;" src="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/lcd_write_data_thumbnail.jpg"/>
          </a>
          The next function call (<span>FUN_fee7</span>)
          looks almost identical to our
          <span>lcd_write_instruction</span> function.
          The only difference is that it writes to the LCD controller&#39;s
          <em>data</em> register, rather than the instruction register. This
          must be where the actual character data is written! You can give this
          function a label like
          <span>lcd_write_data</span>. Note that this
          function <i>&#39;falls-through&#39;</i> to the LCD controller polling function
          we saw earlier.
        </p>
        <p>
          Now we know what&#39;s going on here. This is our LCD printing function!
          Notice that after writing the character data to the LCD, at offset
          <span>0xFE77</span> the function writes it to the
          buffer at <span>0x263F</span>? The incoming
          characters are compared against the contents of this buffer to see if
          they&#39;re identical, if they are then it skips printing the character.
          Maybe these buffers represent the <i>&#39;next&#39;</i>, and
          <i>&#39;current&#39;</i> contents of the LCD screen?
        </p>
        <p>
          After writing the LCD character data, the function then checks whether
          the LCD instruction byte is equal to <code>0xD0</code>. Now we know
          that this is checking whether the LCD DDRAM position is at the end of
          the second line. If not, it checks whether we&#39;re at the end of the
          first line (<code>0x90</code>). If so, the instruction byte is set to
          <code>0xC0</code>, which sets the DDRAM address to the start of the
          second line.
        </p>
        <p><span>Note about HD44780 DDRAM addresses:</span>
          Each &#39;line&#39; in the HD44780 LCD controller actually has a length of 64
          characters, even if the screen is only 16 characters wide. As a
          result, <code>0xC0</code> (<code>0x80 + 0x40</code>) is the correct
          DDRAM address for the start of the second line.
        </p>
        <p>
          Awesome! Now we&#39;ve discovered the LCD printing function! Go ahead and
          give it a name like <span>lcd_print</span>.
        </p>
        <figure>
          <a href="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/lcd_print.png" target="_blank">
            <img alt="The firmware&#39;s &#39;main loop&#39;" src="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/disassembly/lcd_print_thumbnail.jpg"/>
          </a>
          <figcaption>
            The completed <code>lcd_print</code> function. Note that I went
            ahead and labelled all of the important variables.
          </figcaption>
        </figure>
        <p>
          If you&#39;ve followed along, give yourself a huge pat on the back. This
          was no easy feat! You&#39;ve now got a pretty good understanding of how
          vintage synth binaries are reverse-engineered. Everything else
          involved in disassembling a synth&#39;s firmware is just a matter of
          applying these same ideas.
        </p>

        <p><span>Bonus:</span>
          The HD44780 LCD controller has been a staple in consumer devices for
          <em>decades</em><sup><a href="#footnote_5" id="footnote_5_link">5</a></sup>. LCD controllers compatible with the HD44780 instruction set are
          still being manufactured, and are commonly used in commercial, and
          hobby projects alike. Because of this, lots of tutorial material is
          available online, and the knowledge gained in working with it is
          applicable elsewhere.
        </p>

        <h2 id="going_further">
          Going Further <a href="#going_further">#</a>
        </h2>

        <h3 id="midi_handling_routine">
          The MIDI Handling Routine
          <a href="#midi_handling_routine">#</a>
        </h3>
        <p>
          After disassembling the LCD printing function, the next best way to
          figure out what&#39;s going on inside a synth ROM is to disassemble the
          function that parses incoming MIDI data. This function is an entry
          point to nearly every aspect of a synth&#39;s functionality. Disassembling
          it will allow you to trace the path of a particular MIDI message to
          its associated functionality. You can trace <i>&#39;NOTE ON&#39;</i> and
          <i>&#39;NOTE OFF&#39;</i> messages to find the code that handles starting and
          stopping individual voices; Or you can trace
          <i>&#39;CONTROL CHANGE&#39;</i> messages to find the code that handles pitch
          bend or modulation.
        </p>
        <p>
          I decided not to tackle this function in this article, as the DX7&#39;s
          MIDI parsing code is huge, and requires a lot of explanation. Parsing
          MIDI messages is always implemented via a straightforward state
          machine, and the code is nearly identical across different synths.
          Once you&#39;ve seen how it works in one synth, you&#39;ve seen how it works
          in nearly all of them.
        </p>

        <h3 id="debugging_the_firmware">
          Debugging the Firmware in an Emulator
          <a href="#debugging_the_firmware">#</a>
        </h3>
        <p>
          One of the best ways to understand what&#39;s going on inside a synth&#39;s
          firmware is to run it in an emulator. The
          <a href="https://www.mamedev.org/" target="_blank">MAME</a>
          emulation framework is freely available, and already supports a wide
          variety of vintage synths. It features a built-in disassembler, and a
          debugger that can be used to step through the firmware instruction by
          instruction to see what&#39;s happening in detail. When I was working on
          my
          <a href="https://github.com/ajxs/yamaha_dx97" target="_blank">Yamaha DX9/7</a>
          project, I used MAME as a testing and development platform for the
          firmware.
        </p>

        <h3 id="final_words">
          Final Words <a href="#final_words">#</a>
        </h3>
        <p>
          The DX7, and its 8-bit CPU might be a bit primitive by today&#39;s
          standards, but the same principles apply to reverse-engineering modern
          devices. Instructions sets and
          <a href="https://en.wikipedia.org/wiki/Calling_convention" target="_blank">calling-conventions</a>
          might change, but whether it&#39;s a vintage 8-bit architecture like the
          6800, or a cutting-edge 32-bit ARM system, the principles of how to
          disassemble device firmware remain the same.
        </p>
        <p>
          If you have any questions about this article, please get in touch! If
          you have any corrections or suggestions, I&#39;d love to hear from you.
          Thank you for reading!
        </p>

        <h2 id="why_the_dx7">
          Appendix: Why Choose This Synth?
          <a href="#why_the_dx7">#</a>
        </h2>
        <h3>It Can Be Disassembled With Free Software</h3>
        <p>
          6303 binaries can be disassembled by using free and open source tools,
          such as <a href="https://ghidra-sre.org/" target="_blank">Ghidra</a>,
          <a href="https://github.com/Arakula/f9dasm" target="_blank">F9DASM</a>, and MAME&#39;s
          <a href="https://www.mameworld.info/easyemu/mameguide/tools/unidasm.html" target="_blank">Universal Disassembler</a>.
        </p>

        <h3>It&#39;s Well Documented</h3>
        <p>
          40 years on, the DX7 continues to captivate people&#39;s imaginations. As
          a result, lots is known about what goes on inside a DX7. Yamaha&#39;s
          service manuals are comprehensive, and freely available online.
        </p>
        <p>
          Yamaha even released internal documentation on the DX7&#39;s architecture
          and sound chips, which is now
          <a href="https://ajxs.me/blog/Yamaha_DX7_Official_Technical_Analysis.html" target="_blank">available online</a>.
        </p>

        <h3>Only One ROM</h3>
        <p>
          One advantage of reverse-engineering the DX7 is that there&#39;s only one
          ROM you need worry about.
          <em>Technically</em> there&#39;s also the sub-CPU and its mask ROM, but in
          this case you don&#39;t <em>really</em> need to worry what&#39;s going on
          there.
        </p>
        <p>
          Some synths have important part of the firmware stored on the CPU&#39;s
          mask ROM, such as the Casio CZ-101. Other synths spread the synth&#39;s
          core functionality across multiple CPUs, each with their own ROMs,
          such as the Roland JX-8P. The DX7 is much simpler, having (nearly) all
          of its code in one place.
        </p>

        <h3>It Has an LCD Screen</h3>
        <p>
          Disassembling code for a system with a text-based user interface has a
          lot of advantages. I considered some of the early DCO-based Roland
          polysynths as candidates for this article, but without an LCD screen
          it&#39;s much harder to make headway into a ROM.
        </p>

        <h3>No Bank Switching</h3>
        <p>
          Unfortunately the various disassembler tools available don&#39;t handle
          <a href="https://en.wikipedia.org/wiki/Bank_switching" target="_blank"><i>bank switching</i></a>
          very well. In Ghidra you can use &#39;Overlay&#39; memory blocks to set up the
          different banks, however it&#39;s still not very intuitive in my
          experience.
        </p>
        <p>
          I considered the Ensoniq ESQ-1 as a candidate for this article. It
          features a Motorola MC6809 processor, which is very well supported by
          lots of different debuggers. However it uses bank switching, which
          makes it a bit of a nuisance to disassemble.
        </p>

        <h4>What Is Bank Switching?</h4>
        <p>
          What happens if you need to squeeze 64KiB of firmware ROM, and 32KiB
          of RAM into your HD6303 chip&#39;s 16-bit address space? One solution to
          this problem is <i>bank switching</i>. Many vintage synths use
          bank-switching to fit their firmware into the CPU&#39;s address space.
        </p>
        <p>
          Bank switching breaks a memory device&#39;s address space up into multiple
          <i>&#39;banks&#39;</i>
          by latching one or more of its address lines to one of the CPU&#39;s I/O
          port lines. This allows the CPU to select which &#39;bank&#39; is active by
          toggling the aforementioned I/O line in the software.
        </p>
        <figure>
          <a href="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/tx81z_schematics_excerpt.png" target="_blank">
            <img alt="Yamaha TX81Z schematics excerpt showing CPU, ROM, and RAM" src="https://ajxs.me/static/articles/reverse_engineering_vintage_synths/tx81z_schematics_excerpt_thumbnail.jpg"/>
          </a>
          <figcaption>
            An excerpt from the Yamaha TX81Z&#39;s schematics, showing the CPU, ROM,
            and RAM wiring.
          </figcaption>
        </figure>
        <p>
          The Yamaha TX81Z features a 64KiB 27C512 EPROM chip, mapped into the
          CPU&#39;s address space at
          <span>0x8000 - 0xFFFF</span>. The EPROM&#39;s A0-A14
          pins are wired to the CPU&#39;s A0-A14, and the EPROM&#39;s
          <code>CE1</code> pin is latched to the CPU&#39;s A15
          pin. The EPROM&#39;s A15 pin is wired to the CPU&#39;s I/O port 6 (pin
          <code>P63</code> in the schematics). If the <code>P63</code> I/O line
          is pulled <em>high</em>, the upper half of the EPROM&#39;s memory is
          selected, mapping addresses
          <span>0x8000 - 0xFFFF</span> into the CPU&#39;s
          address space. If it&#39;s pulled <em>low</em>, the EPROM&#39;s
          <span>0x0000 to 0x7FFF</span> memory is mapped to
          <span>0x8000 - 0xFFFF</span>.
        </p>
        <p>
          To allow branching from code in one bank to code in another, a common
          technique is to use a
          <i><a href="https://en.wikipedia.org/wiki/Trampoline_(computing)" target="_blank">&#39;trampoline function&#39;</a></i>
          located at the same address in both banks.
        </p>

        <h2 id="documentation">
          Appendix: Documentation
          <a href="#documentation">#</a>
        </h2>
        <p>
          Below is a list of all the important documentation referenced in the
          article.
        </p>
        <ul>
          <li>
            <a href="https://yamahamusicians.com/forum/viewtopic.php?p=90769#p90769" target="_blank">
              DX7 Schematic
            </a>
          </li>
          <li>
            <a href="https://homepages.abdn.ac.uk/d.j.benson/pages/dx7/manuals/dx7-9_service_manual_1.pdf" target="_blank">
              DX7 Service Manual
            </a>
          </li>
          <li>
            <a href="https://www.alldatasheet.com/datasheet-pdf/pdf/63667/HITACHI/HD6303R.html" target="_blank">
              Hitachi HD6303R Datasheet
            </a>
          </li>
          <li>
            <a href="http://www.bitsavers.org/components/hitachi/_dataBooks/1989_U07_HD6301_HD6303_Series_Handbook_1989.pdf" target="_blank">
              HD6301/HD6303 Series Handbook
            </a>
          </li>
          <li>
            <a href="https://www.sparkfun.com/datasheets/LCD/HD44780.pdf" target="_blank">
              Hitachi HD44780 Datasheet
            </a>
          </li>
          <li>
            <a href="https://www.alldatasheet.com/datasheet-pdf/pdf/66100/INTEL/8255A.html" target="_blank">
              Intel 8255 Datasheet
            </a>
          </li>
          <li>
            <a href="https://www.ti.com/product/SN74LS138#tech-docs" target="_blank">
              74LS138 Datasheet
            </a>
          </li>
        </ul>

        <hr/>
        
      </div></div>
  </body>
</html>
