<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://words.filippo.io/dispatches/go-1-21-plan/">Original</a>
    <h1>Planning Go 1.21 Cryptography Work</h1>
    
    <div id="readability-page-1" class="page"><article>
        <span>
            <time datetime="2023-03-23">23 Mar 2023</time>
        </span>
        
        
        <section>
            <!--kg-card-begin: markdown--><p>As most of you are tired to hear by now, I am <a href="https://words.filippo.io/full-time-maintainer/">a professional, full-time open-source maintainer</a>, and a lot of my time is spent maintaining the Go cryptography standard libraries.</p>
<p>Go’s development follows a fixed calendar with two development windows and two releases every year. I try to write about what I plan to do / be involved in for the next release at the beginning of the cycle, and about what happened at the end of the cycle.</p>
<p>This is the planning overview for the Go 1.21 release. There is some exciting API work going on, as well as some satisfying follow-ups on stuff that landed in Go 1.20.</p>
<p>Now is a very good time to provide feedback (and you can do that by just replying to this if you’re reading it in your inbox)! You can also <a href="https://github.com/users/FiloSottile/projects/2?ref=words.filippo.io">take a look at my public GitHub Projects planning board</a>.</p>
<h2 id="follow-ups">Follow-ups</h2>
<p>Go 1.20 was a big release for cryptography, so there are a few items to follow-up on, to tie up loose ends while the iron is hot. (That is, while I still have any context paged into my brain.)</p>
<h2 id="cryptoecdh-follow-ups">crypto/ecdh follow-ups</h2>
<p>The new <a href="https://pkg.go.dev/crypto/ecdh?ref=words.filippo.io">crypto/ecdh package</a> made its debut in Go 1.20.</p>
<p>This means that we can <a href="https://go.dev/cl/459977?ref=words.filippo.io">deprecate almost all of crypto/elliptic</a> in Go 1.21. We leave undeprecated only the Curve singletons returned by <a href="https://pkg.go.dev/crypto/elliptic?ref=words.filippo.io#P256"><code>P256()</code></a> and the like, needed to use the crypto/ecdsa APIs. crypto/ecdsa doesn’t actually use crypto/elliptic code besides switching on these values, so crypto/elliptic is now a glorified enum and a legacy compatibility layer. As always, deprecated doesn’t mean removed: per the <a href="https://go.dev/doc/go1compat?ref=words.filippo.io">Go 1 Compatibility Promise</a> crypto/elliptic keeps working, but <a href="https://staticcheck.io/?ref=words.filippo.io">staticcheck</a> will yell at you about using it.</p>
<p>There is <em>one</em> meaningful bit of functionality in crypto/elliptic that is not in crypto/ecdh yet: compressed point encodings for NIST curves. <a href="https://github.com/golang/go/issues/52221?ref=words.filippo.io#issuecomment-1111153164">I explored the topic and proposed an API in the original discussion</a> but then decided to wait to add those APIs. “No is temporary, yes is forever.” If anyone uses compressed point encodings, now would be the time to reach out!</p>
<p>Oh, also P-224, but that’s on purpose and I think we got away with it.</p>
<p>Finally, we can now <a href="https://go.dev/cl/451115?ref=words.filippo.io">rewrite golang.org/x/crypto/curve25519 as a crypto/ecdh.X25519 wrapper</a>, hopefully bringing down the number of -25519 implementations in the Go project to one: crypto/internal/edwards25519 (available externally as <a href="https://filippo.io/edwards25519?ref=words.filippo.io">filippo.io/edwards25519</a>), used by crypto/ecdh and crypto/ed25519, and transitively by the x/crypto/ed25519 and x/crypto/curve25519 wrappers. We’ll wait a few releases before dropping the pre-Go 1.20 compatibility layer from x/crypto.</p>
<h2 id="cryptorsa-follow-ups">crypto/rsa follow-ups</h2>
<p>The other big change of Go 1.20 has been migrating crypto/rsa away from math/big to crypto/internal/bigmod (available externally as <a href="https://filippo.io/bigmod?ref=words.filippo.io">filippo.io/bigmod</a>). Dear reader, I’ll be honest, I did not expect this to land, but it did!</p>
<p>The switch came with a significant performance degradation: between approximately 15% (RSA-2048 on amd64) and 45% (RSA-4096 on arm64), despite dropping in some dedicated amd64 <a href="https://github.com/mmcloughlin/avo?ref=words.filippo.io">Avo-generated</a> assembly. That’s counter-intuitive: I expected the more-specific crypto/internal/bigmod to be faster than math/big, despite having to waste some cycles on keeping computations constant-time. Turns out that an implementation technique used in crypto/internal/bigmod since its initial submission might be based on outdated wisdom that I also assumed was still true. The idea was that splitting numbers into 63-bit “unsaturated limbs” allows for faster Montgomery multiplication, because it allows <a href="https://cs.opensource.google/go/go/+/master:src/crypto/internal/bigmod/nat.go;l=626;drc=335e7647f53293eb320c1f069eaf0ff641810d6d?ref=words.filippo.io">a result in the hot loop to fit in 128 bits</a>, so two registers. Well, turns out that might be true in portable C, but if you have access to the add-with-carry instructions of most modern processors, using saturated 64-bit limbs and keeping the carries in flags across loop iterations is faster. That’s what the math/big assembly does.</p>
<p>The good news is that we have pure-Go access to these “addition chains” thanks to <a href="https://pkg.go.dev/math/bits?ref=words.filippo.io#Add">math/bits.Add</a>. The bad news is that Montgomery multiplication needs to keep track of <em>two</em> carry bits across loop iterations, and while possible (that’s what ADX is for, it’s just ADC that uses a different flag) <a href="https://abyssdomain.expert/@commaok@inuh.net/109934357847363407?ref=words.filippo.io">it’s too much for the compiler to figure out</a>, so we’re stuck with assembly. I have <a href="https://go.dev/cl/471259?ref=words.filippo.io">a CL that switches bigmod to using math/big’s assembly core</a> and it brings crypto/rsa within 5% of its Go 1.19 performance without even using all the assembly. It needs cleaning up, but I expect RSA on Go 1.21 to be at least as fast as on Go 1.19, maybe faster.</p>
<p>Aside from clawing back performance, there’s <a href="https://github.com/golang/go/issues/57752?ref=words.filippo.io">a laundry list of follow-ups</a>.</p>
<ul>
<li><a href="https://pkg.go.dev/crypto/rsa?ref=words.filippo.io#PrivateKey.Validate"><code>PrivateKey.Validate</code></a> and <a href="https://pkg.go.dev/crypto/rsa?ref=words.filippo.io#PrivateKey.Equal"><code>PrivateKey.Equal</code></a> still use math/big and need porting to bigmod or other constant-time code.</li>
<li><a href="https://github.com/golang/go/issues/56980?ref=words.filippo.io">The race detector makes the new code dramatically slower.</a> If that’s still the case after the changes above, we probably need to drop some <code>go:norace</code> annotations.</li>
<li>The deprecation of the unused <code>GenerateMultiPrimeKey</code> was reverted at the last minute to <a href="https://go.dev/issue/56921?ref=words.filippo.io">go through the proposal process</a>. It’s now ready to land.</li>
<li>A couple docs fixups.</li>
</ul>
<h2 id="new-api-proposals">New API proposals</h2>
<p>There are a few ongoing proposal discussions that thanks to <a href="https://github.com/golang/go/wiki/Go-Release-Cycle?ref=words.filippo.io">the new release calendar with shorter freezes</a> have a good chance of landing into Go 1.21 changes.</p>
<h3 id="cryptotls-support-for-quic">crypto/tls support for QUIC</h3>
<p>Damien Neil, Marten Seemann, and I have been <a href="https://go.dev/issue/44886?ref=words.filippo.io">discussing the APIs that crypto/tls needs to expose to support QUIC and HTTP/3</a>. These higher level protocols use TLS 1.3 for the handshake, but then derive their own keys and have their own record encryption, since they don’t run over simple TCP streams. Marten has a fork of crypto/tls for his <a href="https://github.com/quic-go/quic-go?ref=words.filippo.io">quic-go</a> implementation, which is a maintenance and ecosystem pain point. The new APIs are intended to let quic-go drop the fork and depend on behavior covered by the Go 1 Compatibility Promise, as well as to support <a href="https://go.dev/issue/58547?ref=words.filippo.io">an HTTP/3 implementation in the standard library</a>.</p>
<p>It’s a large and important change, because we’ll be maintaining these APIs in perpetuity, and we have to decide even fundamental architecture details like what side “drives” the handshake: is the caller injecting data, or is crypto/tls requesting it with callbacks from a blocking handshake function? The current design is interesting: the API works synchronously, with the QUIC implementation calling a crypto/tls function to provide incoming bytes, and effectively getting back any bytes it needs to send back, if any. <em>How</em> it gets those bytes back is somewhat weird: it provides callbacks that are called synchronously by crypto/tls before returning; semantically the parameters of those callbacks are just fancy return values of the crypto/tls methods. I am going to try proposing switching them to proper return values to make the semantics clearer and the implementation simpler. What makes the design interesting is that this simple and natural API is a poor match for the internals of crypto/tls, which are used to issue blocking reads until they have a full message, and so can’t interrupt the handshake to return a “please give me more data” signal. The idea is using a hidden goroutine in crypto/tls to bridge the gap. I like it because the complexity is an implementation detail, not set in stone at the API level, and so can be removed in the future if necessary.</p>
<p>Marten’s employer, Protocol Labs, is a client. This helped with working on the proposal, because by the time Damien asked for my input I had already talked to Marten about what quic-go needs, so I had the context to get started. Yay for <a href="https://words.filippo.io/dispatches/reciprocal/">reciprocal access</a>.</p>
<h3 id="tls-session-overhaul">TLS session overhaul</h3>
<p>Closely related to the QUIC APIs, are the TLS session resumption APIs. QUIC sometimes needs to store extra data in session tickets, for example. That adds to <a href="https://github.com/golang/go/issues/6379?ref=words.filippo.io#issuecomment-596655811">a list of needs that would be addressed by a well-designed PSK API</a>, now that TLS 1.3 redefined session resumption in terms of PSKs.</p>
<p>I’m very happy about how the general API I had in mind seems to also fit the QUIC 0-RTT use-case, without spreading any 0-RTT complexity into the rest of crypto/tls, based on a conversation with Marten.</p>
<p>I listed the TLS session resumption issues in the Go 1.20 planning post as a stretch goal (which I didn’t get to). Go 1.21 is the right time to do this.</p>
<h3 id="a-%E2%80%9Cpublic%E2%80%9D-http-server-mode">A “public” HTTP Server mode</h3>
<p>I get asked all the time to update my <a href="https://blog.gopheracademy.com/advent-2016/exposing-go-on-the-internet/?ref=words.filippo.io">Exposing Go on the Internet</a> post, and indeed a lot changed in the past five years, including finally <a href="https://go.dev/issue/16100?ref=words.filippo.io">a way to set per-request timeouts</a>. Things are better now, but there’s still a few knobs that need turning to safely expose net/http to the Internet, because changing the default would be a significant backwards-compatibility break. I was going to write a 2023 edition to list those knobs, but then Russ Cox suggested that we should have a better answer than “here’s what you need to know”.</p>
<p>That might mean a dedicated “Public” mode, which tunes all defaults to the safest settings, maybe all the way to over-conservative configurations, with the right knobs to explicitly relax them, for example after authenticating a request. I like this in particular because sometimes there isn’t a “right” default, and the same cap can be both unusable for some applications and unsafe for some others. Public mode would set those to zero (or whatever the fail-closed option is), and let the application tune it.</p>
<p>An interesting thought is whether that mode should also come with a relaxed backwards-compatibility commitment, saying we reserve the right to make changes if we identify new things that need to be tightened. The argument in favor is that otherwise this is our one chance to get all things right, and if we miss something we’ll be stuck for the next ten years with a “safe” mode that is safer but not entirely safe by default. The argument against is the same as any relaxing of the compatibility promise: if you upgrade Go and your application stops working, you are sad.</p>
<h3 id="x509-x509-x509">X.509 X.509 X.509</h3>
<p>Go 1.20 includes <a href="https://go.dev/issue/43958?ref=words.filippo.io">the new SetFallbackRoots API we talked about in the recap</a>. The idea is that it will be used as a hook by the golang.org/x/crypto/x509roots/fallback package, which when imported makes a root CA bundle available in case the system doesn’t have any (like empty containers). The <a href="https://go.dev/issue/57792?ref=words.filippo.io">x509roots discussion is wrapping up</a> but just as we finalized the original plan, <a href="https://groups.google.com/a/mozilla.org/g/dev-security-policy/c/oxX69KFvsm4/m/yLohoVqtCgAJ?ref=words.filippo.io">TrustCor went and got distrusted for new certificates</a>. We could just exclude it from the fallback package, and we plan to start by doing that, but the reality is that trust stores are more than a list of roots: they have arbitrary logic embedded in them (like requiring SCTs, limiting the TLDs a CA can issue for, or restricting the issuance date of certificate like in this case). Roland and I discussed <a href="https://github.com/golang/go/issues/57178?ref=words.filippo.io">a solution that allows CertPool entries to have custom code attached to them</a> so we can add arbitrary restrictions. I am pretty happy with it, because it’s tightly scoped, only accessible at root addition time, and pretty future-proof. Who knows, maybe one day even Linux will figure out how to have proper root stores, and we’ll be ready.</p>
<p>Speaking of root stores and platforms, a few releases ago we switched to using the platform verifier everywhere it’s available, instead of trying to pry the roots (and additional logic) out of clunky APIs. That’s been a good choice. However, it also means we are exposed to the requirements of the platform verifier. If the verifier checks SCTs, we need to provide SCTs. If the verifier enforces OCSP Must Staple, we need to provide stapled OCSP responses. Those can come via TLS extensions (although <a href="https://groups.google.com/a/chromium.org/g/ct-policy/c/WX6iZt7uJBs?ref=words.filippo.io">Chrome is considering deprecating SCTs via TLS extension</a>, which ~nobody uses and makes inspecting the PKI harder) and we have them wired though crypto/tls to the <a href="https://pkg.go.dev/crypto/tls?ref=words.filippo.io#ConnectionState">ConnectionState</a> structure, but there’s no way to pass them to crypto/x509 Certificate.Verify, since we never used them there. Hence, <a href="https://github.com/golang/go/issues/58251?ref=words.filippo.io">proposal to add SCTs and OCSP staples to VerifyOptions</a>.</p>
<h2 id="miscellaneous">Miscellaneous</h2>
<p>As always, a long tail, starting from the list of TLS changes that were stretch goals in Go 1.20.</p>
<ul>
<li><a href="https://github.com/golang/go/issues/20420?ref=words.filippo.io">crypto/tls: customisable max TLS record size</a></li>
<li><a href="https://github.com/golang/go/issues/35504?ref=words.filippo.io">crypto/tls: improve default performance of SupportsCertificate</a></li>
<li><a href="https://github.com/golang/go/issues/46308?ref=words.filippo.io">crypto/tls: add VersionName function to return a string version of the TLS Version</a></li>
<li><a href="https://github.com/golang/go/issues/50773?ref=words.filippo.io">crypto/tls: make maxHandshake larger or configurable</a></li>
<li><a href="https://github.com/golang/go/issues/51434?ref=words.filippo.io">crypto/tls: run BoringSSL test suite (BoGo)</a></li>
<li><a href="https://github.com/golang/go/issues/43922?ref=words.filippo.io">proposal: crypto/tls: implement RFC7627</a></li>
</ul>
<p>And some fresh ones.</p>
<ul>
<li><a href="https://go.dev/issue/58637?ref=words.filippo.io">crypto: document that GenerateKey functions are not deterministic</a>
<ul>
<li>ecdsa.GenerateKey was the last GenerateKey left that wasn’t using <a href="https://pkg.go.dev/crypto/internal/randutil?ref=words.filippo.io#MaybeReadByte">MaybeReadByte</a> to stop callers from relying on it being deterministic. Ironically, it was exactly the one that had to change algorithm to work better with the new internals. (It’s now rejection sampling instead of reduction, which for NIST curves is a little simpler/cleaner.) So it’s now non-deterministic, too. We need to document that.</li>
<li>Relatedly, I am working on a package for deterministic key generation, and a couple articles on how randomness should be used in cryptographic specifications to enable proper testing. Stay tuned :)</li>
</ul>
</li>
<li><a href="https://go.dev/issue/58635?ref=words.filippo.io">crypto/x509: stop using math/big and crypto/elliptic for parsing</a>
<ul>
<li>This is another follow-up on the bigmod work. I noticed we are still using math/big in the key parsing functions in crypto/x509. We shouldn’t!</li>
<li>While at it, we should land in some way <a href="https://go.dev/cl/402554?ref=words.filippo.io">my fancy static analysis test</a> that makes sure math/big is unreachable from crypto functions, and extend it to also cover crypto/x509.</li>
</ul>
</li>
<li><a href="https://go.dev/issue/58636?ref=words.filippo.io">crypto: use purego tag consistently</a>
<ul>
<li>We have a convention to use the purego build tag to disable assembly, but we’ve been applying it only in x/crypto because it’s not like anyone imports the stdlib, right? Wrong! TinyGo doesn’t support a bunch of crypto because it depends on assembly. I noticed this discussed on the Gophers Slack. We can fix it by applying purego everywhere, all assembly has a pure Go fallback, <a href="https://github.com/golang/go/wiki/AssemblyPolicy?ref=words.filippo.io">by policy</a>. (Also relevant, our <a href="https://github.com/golang/go/wiki/PlatformSpecific?ref=words.filippo.io">platform-specific code policy</a>.)</li>
</ul>
</li>
</ul>
<p>Finally, a preview bonus: in Go 1.20 Russ <a href="https://github.com/golang/go/issues/54880?ref=words.filippo.io">made the global math/rand RNG non-deterministic</a> and <a href="https://github.com/golang/go/issues/56319?ref=words.filippo.io">deprecated the global Seed function</a>. This is great because it removes the backwards compatibility lock-in to a specific RNG algorithm. It means for example that the global lock can be removed or relaxed or even made per-CPU. Now… wouldn’t it be nice if the default algorithm happened to also be cryptographically safe? Not saying we’d even document that, because you should still use crypto/rand for anything security sensitive, but it’d be nice if we failed safe if anyone does use math/rand, right? Well, the question is how fast I can make ChaCha8. I have a quick prototype that is ~50% slower than the current insecure RNG and uses an order of magnitude less memory. Maybe I can land it in Go 1.21 if I find the time to play with it more.</p>
<h2 id="the-picture">The picture</h2>
<p>First motorcycle trip to Tuscolo of the season. There were some folks flying radiocontrolled glider models in the wind. It looked fun. I don&#39;t need a new hobby. But it did look fun. Hmmmm...</p>
<p><img src="https://words.filippo.io/content/images/2023/03/IMG_0806.jpeg" alt="A panorama picture taken from a green hill. In the center the valley below is brown and dotted with houses. The sun is starting to set towards the right of the picture, in a smoky but clear light blue sky." loading="lazy"/></p>
<p>My awesome clients—<a href="https://www.sigsum.org/?ref=words.filippo.io">Sigsum</a>, <a href="https://protocol.ai/?ref=words.filippo.io">Protocol Labs</a>, <a href="https://www.latacora.com/?ref=words.filippo.io">Latacora</a>, <a href="https://interchain.io/?ref=words.filippo.io">Interchain</a>, <a href="https://smallstep.com/?ref=words.filippo.io">Smallstep</a>, and <a href="https://tailscale.com/?ref=words.filippo.io">Tailscale</a>—are funding all this work and through our retainer contracts they get face time about its direction, as well as unlimited access to advice.</p>
<p>Here are a few words from some of them!</p>
<p>Latacora — <a href="https://www.latacora.com/?ref=words.filippo.io">Latacora</a> bootstraps security practices for startups. Instead of wasting your time trying to hire a security person who is good at everything from Android security to AWS IAM strategies to SOC2 and apparently has the time to answer all your security questionnaires plus never gets sick or takes a day off, you hire us. We provide a crack team of professionals prepped with processes and power tools, coupling individual security capabilities with strategic program management and tactical project management.</p>
<p>Protocol Labs — Build Peer to Peer apps easily with <a href="https://libp2p.io/?ref=words.filippo.io">libp2p</a> — our cross-platform library that offers useful building blocks such as Kademlia DHT for decentralized state, Gossipsub for resilient pub/sub, and NAT traversal protocols for global connectivity. With <a href="https://libp2p.io/?ref=words.filippo.io">libp2p</a>, you can easily connect to anyone, anywhere using multiple network transports like QUIC, WebTransport, WebSockets, WebRTC, or TCP through a single interface.</p>
<p>Smallstep — Open source licensing, sustainable open source, and monetizing open source with open core technology — this all is a lot of work and it&#39;s hard within our economic systems. Join Smallstep CEO Mike Malone and Offroad Engineer Carl Tashian as they <a href="https://hopin.com/events/the-business-of-open-source-is-hard/registration?ref=words.filippo.io">talk through all of the compromises, triumphs, and love of open source</a>.</p>


<!--kg-card-end: markdown-->
        </section>
    </article></div>
  </body>
</html>
