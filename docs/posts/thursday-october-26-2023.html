<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://quintenkonyn.recurse.com/log/2023-10-26/">Original</a>
    <h1>Thursday, October 26, 2023</h1>
    
    <div id="readability-page-1" class="page"><article>
  

  <p>Learned about about Rust slices. Increased padding for mobile.</p>
<h2>Today&#39;s Plan</h2>
<ul>
<li><strong>Done</strong> Finish <a href="https://rust-book.cs.brown.edu/ch04-04-slices.html">Rust book ch4.4</a></li>
<li><strong>Done</strong> Add link to Atom feed to the log</li>
<li><strong>Done</strong> Lengthen whitespace in the footer</li>
</ul>
<h2>Rust Slices</h2>
<p>This section was much less intimidating than the previous one (on fixing ownership errors). I&#39;m familiar with <a href="https://stackoverflow.com/questions/509211/how-slicing-in-python-works">slices in Python</a> and MATLAB, which are much more flexible. You can go backwards, and can also skip elements (with a stride size).</p>
<p>Slices in Rust can not do these fancy features. Instead, they can only refer to a contiguous subsection of a data collection. I suspect this is because conceptually, Rust is working closer to the physically-adjacent memory of <a href="https://rust-book.cs.brown.edu/ch04-01-what-is-ownership.html?highlight=stack#variables-live-in-the-stack">the stack</a>?</p>
<p>I bet that Rust uses iterators for skipping and going backwards, but I&#39;ve yet to learn about those in detail.</p>
<h2>Fat Pointers</h2>
<p>Slices are really simple objects in Rust: just a &#39;fat pointer&#39;. A fat pointer is a pointer that also has a little bit of data attached (a length, in this case). All string literals in Rust are fat pointers.</p>
<p>I remember learning in an intro CS class that strings in C are just <code>char</code> bytes that are adjacent in memory, and the program doesn&#39;t know when they&#39;ll end, it just keeps reading until it encounters a special character that signifies the end. That&#39;s something that can easily make you run into memory problems or unpredictable results if you aren&#39;t careful. I wonder if this is why Rust chose to bundle some pointers with metadata.</p>
<h2>Page Padding</h2>
<p>I&#39;ve given my navigation header and footer some breathing room by increasing the padding of the HTML element. Here&#39;s my explanation, quoted from my <a href="https://quintenkonyn.recurse.com/projects/quintens-blog/css/">CSS breakdown</a>:</p>
<blockquote>
<p>Instead of having zero padding for the top and bottom, I have added a little at the top, and a lot at the bottom. This is because I was encountering some problems with my header and footer navigation being too close to the edge of the screen on mobile. Either a browser footer covers my footer, or it&#39;s too close for comfortable tapping. I don&#39;t want buttons to be too close together, because it&#39;s an unnecessary barrier for people visiting the site.</p>
</blockquote>
<h2>Task Ideas</h2>

</article></div>
  </body>
</html>
