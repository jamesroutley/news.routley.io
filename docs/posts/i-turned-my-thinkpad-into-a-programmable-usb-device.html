<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://xairy.io/articles/thinkpad-xdci">Original</a>
    <h1>I turned my ThinkPad into a programmable USB device</h1>
    
    <div id="readability-page-1" class="page"><div>
    <article>
      

      <div itemprop="articleBody"><p>This is the story of how I figured out a way to turn my ThinkPad X1 Carbon 6th Gen laptop into a programmable USB device by enabling the <a href="https://edc.intel.com/content/www/us/en/design/ipla/software-development-platforms/client/platforms/alder-lake-desktop/12th-generation-intel-core-processors-datasheet-volume-1-of-2/010/extensible-device-controller-interface-xdci/">xDCI</a> controller.</p>

<p>As a result, the laptop can now be used to emulate arbitrary USB devices such as keyboards or storage drives.
Or to fuzz USB hosts with the help of <a href="https://github.com/xairy/raw-gadget">Raw Gadget</a> and <a href="https://github.com/google/syzkaller">syzkaller</a>.
Or to even run <a href="https://github.com/greatscottgadgets/Facedancer">Facedancer</a> with the help of the <a href="https://github.com/xairy/raw-gadget#facedancer-backend">Raw Gadget‚Äìbased backend</a>.
And do all this without any external hardware.</p>

<p>The journey of enabling xDCI included fiddling with Linux kernel drivers, xHCI, DWC3, ACPI, BIOS/UEFI, Boot Guard, TPM, NVRAM, PCH, PMC, PSF, IOSF, and P2SB, and making a custom USB cable üò±</p>



        
          
          <div>
            <p markdown="1">‚¨Ö Note the interactive table of contents on the left.</p>

          </div>

        

        <!--end_excerpt-->

<h2 id="-introduction">üé¨ Introduction</h2>

<p>One day, I was working on improving <a href="https://github.com/xairy/raw-gadget">Raw Gadget</a>.</p>

<p><strong>Raw Gadget and UDCs</strong>.
Raw Gadget is a Linux kernel module for emulating highly customizable USB devices.
This module provides a userspace API for the Linux kernel USB Gadget subsystem.
The flexibility of the API allows using Raw Gadget for fuzzing and exploiting USB hosts by providing malformed USB descriptors.</p>

<div>
  <p>
UDCs are also sometimes called USB Peripheral Controllers.
</p>
</div>

<p>To emulate USB devices through the Gadget subsystem of the Linux kernel, one needs a special hardware component called the USB Device Controller (UDC).
Such components are generally not present on PCs (right? üòâ) but are typically embedded into single-board computers like a Raspberry Pi.</p>

<p><strong>Raspberry Pi</strong>.
Thus, I usually used a Raspberry Pi to work with Raw Gadget.
However, dealing with a Raspberry Pi is a hassle: plugging in the wires, booting the board, accessing the shell, etc.
So, for a while, I dreamt how nice it would be to have a UDC connected directly to my laptop instead.</p>

<p><strong>EC3380-AB</strong>.
At some point, I managed to find a solution for connecting a UDC to a PC: <a href="http://www.hwtools.net/Adapter/EC3380-AB.html">EC3380-AB</a>.</p>

<div>
  <p>
Quite a pity modern laptops moved away from using ExpressCard üò¢
</p>
</div>

<p>EC3380-AB is an ExpressCard board based on the <a href="https://docs.broadcom.com/docs/12351862">USB 3380</a> Peripheral Controller chip that implements a UDC.
With the help of the <a href="https://www.sonnettech.com/product/echoexpresscard34thunderbolt.html">Sonnet Echo</a> ExpressCard-to-Thunderbolt adapter, EC3380-AB can be plugged into a Thunderbolt port to connect the UDC to a PC without an ExpressCard slot.</p>

<figure>
	
		
			<img src="https://hazure.neocities.org/images/content/thinkpad-xdci/ec3380-echo.jpg" title="EC3380-AB with the Sonnet Echo ExpressCard-to-Thunderbolt adapter"/>
		
	
	
		<figcaption>EC3380-AB with the Sonnet Echo ExpressCard-to-Thunderbolt adapter</figcaption>
	
</figure>

<p>There are also a few other UDC boards based on USB 3380.
But those connect over PCIe and thus require a bulky PCIe-to-Thunderbolt enclosure to connect them conveniently.</p>

<p>
Two of these boards, <a href="http://www.hwtools.net/adapter/usb3380evb.html">USB3380EVB</a> and <a href="http://www.bplus.com.tw/Adapter/PP3380-AB.html">PP3380-AB</a>, might be familiar to those who worked with DMA attacks.
Like <a href="http://www.hwtools.net/Adapter/EC3380-AB.html">EC3380-AB</a>, these boards are powered by USB 3380 and are originally intended to serve as UDCs.
However, they can also be <a href="https://github.com/ufrisk/pcileech/blob/master/usb3380.md">reprogrammed</a> to be used as a tool for DMA attacks over PCIe.
</p>

<p><strong>Working with EC3380-AB</strong>.
The combination of EC3380-AB and the Sonnet Echo adapter worked mostly fine.
However, the <code>net2280</code> Linux kernel driver used for this UDC would sometimes glitch out.
Thus, occasionally, I had to replug the controller into my laptop to reset the driver state.</p>

<p>As I was plugging and unplugging EC3380-AB, I would check the contents of <code>/sys/class/udc/</code> to make sure that EC3380-AB connected successfully.
This directory displays the UDCs connected to the system:</p>

<div><div><pre><code><span>$ </span><span>ls</span> /sys/class/udc/
0000:0a:00.0
<span>$ </span><span>cat</span> /sys/class/udc/0000<span>\:</span>0a<span>\:</span>00.0/uevent
<span>USB_UDC_NAME</span><span>=</span>net2280
</code></pre></div></div>

<p><strong>Huh</strong>.
At some point, I typed <code>ls /sys/class/u</code> in the terminal and pressed Tab to let it autocomplete to <code>.../udc</code>.
However, the autocomplete showed me another directory: <code>/sys/class/usb_role</code>.
Moreover, this directory unexpectedly contained another one named <code>intel_xhci_usb_sw-role-switch</code>.
‚ÄúHm, what the hell is this?‚Äù thought I ü§î</p>

<p>
xHCI (eXtensible Host Controller Interface) is a USB HCD (Host Controller Device) used on x86-powered systems.
It‚Äôs a hardware component that allows the system to act as a USB host.
</p>

<p>
<code>/sys/class/usb_role</code> is an <a href="https://www.kernel.org/doc/Documentation/ABI/testing/sysfs-class-usb_role">interface</a> for switching the hardware USB component between the host and the device modes.
Some computers use the same chip to serve either as an HCD or a UDC, depending on the chosen configuration, and this interface allows reconfiguring that in runtime.
</p>

<p><strong>xHCI role switch</strong>.
What surprised me here was seeing a <code>usb_role</code> switch for the xHCI device on my ThinkPad laptop.
I wouldn‚Äôt be surprised to see it on an x86-powered single-board computer or on an Intel NUC device.
But ThinkPad?
I thought it didn‚Äôt have any capability of being a USB device.
This was unexpected.</p>

<p>Out of curiosity, I tried writing <code>device</code> to <code>intel_xhci_usb_sw-role-switch/role</code>, which is supposed to switch the USB component on the laptop to the device mode.
But nothing happened: no <code>dmesg</code> messages, no new files in <code>/sys/class/udc/</code>.</p>

<p>So I decided to dig deeper.</p>

<h2 id="-investigation">üßê Investigation</h2>

<h3 id="-reading-kernel-code">üêß Reading kernel code</h3>

<p>I started by looking into how <code>intel_xhci_usb_sw-role-switch</code> ended up appearing on my ThinkPad in the first place.</p>

<p><strong>xHCI role switch implementation</strong>.
A grep for <code>intel_xhci_usb_sw</code> through the Linux kernel code yielded two results:</p>

<ol>
  <li>
    <p>The <code>drivers/usb/roles/intel-xhci-usb-role-switch.c</code> <a href="https://elixir.bootlin.com/linux/v6.5/source/drivers/usb/roles/intel-xhci-usb-role-switch.c">file</a> that contained the platform driver for an <code>intel_xhci_usb_sw</code> device.</p>

    <p>This driver registered a <a href="https://elixir.bootlin.com/linux/v6.5/source/drivers/usb/roles/class.c#L309">USB Role Switch</a>, which implemented the handlers for when <code>device</code> or <code>host</code> is written into <code>intel_xhci_usb_sw-role-switch</code>.
Both handlers appeared to <a href="https://elixir.bootlin.com/linux/v6.5/source/drivers/usb/roles/intel-xhci-usb-role-switch.c#L83">manipulate the registers</a> of the xHCI device.</p>
  </li>
  <li>
    <p>The <code>drivers/usb/host/xhci-ext-caps.c</code> <a href="https://elixir.bootlin.com/linux/v6.5/source/drivers/usb/host/xhci-ext-caps.c">file</a> that created the <code>intel_xhci_usb_sw</code> virtual platform device, for which the driver from #1 got registered.</p>

    <p>This device was only created <a href="https://elixir.bootlin.com/linux/v6.5/source/drivers/usb/host/xhci-ext-caps.c#L97">when</a> the xHCI driver set the <code>XHCI_INTEL_USB_ROLE_SW</code> quirk flag.
And this only <a href="https://elixir.bootlin.com/linux/v6.5/source/drivers/usb/host/xhci-pci.c#L430">happened</a> for PCIe devices with a few specific device numbers.
The list of numbers included <code>PCI_DEVICE_ID_INTEL_SUNRISEPOINT_LP_XHCI</code> with the value <code>0x9d2f</code>, which matched the xHCI PCIe device ID on my laptop.</p>
  </li>
</ol>

<p><strong>ThinkPad</strong>.
So apparently, the xHCI device on my laptop did support the role switching.
Or at least its driver believed so.</p>

<p>Now the question was: What exactly happened when the driver wrote to the xHCI registers?
Did these writes produce any effects?
Or did the hardware not support the <code>device</code> role at all?</p>

<h3 id="-searching-online">üîç Searching online</h3>

<p>The next thing I tried was looking online for references to <code>intel_xhci_usb_sw-role-switch</code>.</p>

<p><strong>Mailing list discussion</strong>.
This led me to the discussion titled <a href="https://lore.kernel.org/all/CAGR4S9HQiZCsA7Y5_47j-xBOkydKiT2Exam=36L=-vwRjt+UWA@mail.gmail.com/t/#u">Any example of USB gadget for DRD device mode on Intel Gemini Lake?</a> on the Linux kernel mailing list.
There, Dmitry Mikushin was facing the same issue as me: role switching for the xHCI device did not appear to work.</p>

<p>
Dmitry‚Äôs question also noted that after switching the role, one of the ports was successfully recognized as a new USB device when connected with a cable to another laptop.
However, initially, I managed to overlook this part of the question.
</p>

<p><strong>DWC3</strong>.
Luckily, Heikki Krogerus came to the help:</p>

<table>
	<tbody><tr>
		<th>¬´</th>
		<th>
So, do you have the DWC3 (the USB device controller) PCI device available/visible on your system?
What do you get if you run <code>lspci -nn | grep USB</code>?
The DWC3 PCI device ID on Gemini Lake is <code>0x31aa</code> (search <code>PCI_DEVICE_ID_INTEL_GLK</code> in <code>drivers/usb/dwc3/dwc3-pci.c</code>).
</th>
	</tr>

</tbody></table>



<p>In the response, Heikki suggested checking if a DWC3 UDC was present in the list of PCI devices.
This made sense: if a UDC is present on a system, it has to be somehow connected.
And it looked like Intel connected their DWC3 UDCs over PCI or PCIe.</p>

<p>Dmitry responded:</p>

<table>
	<tbody><tr>
		<th>¬´</th>
		<th>
Yes, AFAIK, <code>PCI_DEVICE_ID_INTEL_GLK_XHCI</code> is actually <code>0x31a8</code>, and I do have it:
<code>00:15.0 USB controller [0c03]: Intel Corporation Device [8086:31a8] (rev 03)</code>.
</th>
	</tr>

</tbody></table>

<p><strong>Mux</strong>.
Heikki answered:</p>

<table>
	<tbody><tr>
		<th>¬´</th>
		<th>
That is the xHCI controller, and it is not what you need if you want to use the connector in device mode.
The xHCI and DWC3 IPs are separate IPs on GLK.
That is why there is a mux between the two.
</th>
	</tr>

</tbody></table>

<p>Here, Heikki pointed out that xHCI and DWC3 UDC were different devices.
And having xHCI enabled did not imply that the DWC3 UDC could be used.</p>

<p>Heikki also gave another valuable piece of information: there is a mux (multiplexer ‚Äî a kind of switch) between xHCI and the DWC3 UDC.
And, apparently, changing the USB role via <code>intel_xhci_usb_sw-role-switch</code> should switch this mux.</p>

<p><strong>Oh no</strong>.
Heikki then continued:</p>

<table>
	<tbody><tr>
		<th>¬´</th>
		<th>
The DWC3 USB Device Controller has device ID <code>31aa</code>, so you want to see a PCI device with this device ID.
It‚Äôs not there.
So, the DWC3 PCI device is not enabled on your board, which means you do not have a USB Device Controller to deal with.
The connector is in host mode only. Sorry.
</th>
	</tr>

</tbody></table>

<p>So, if the DWC3 UDC itself was not there, having the mux switched was pointless.
Most likely, this is what was happening in my case.</p>

<p><strong>xDCI in BIOS</strong>.
Heikki then also added:</p>

<table>
	<tbody><tr>
		<th>¬´</th>
		<th>
If you can enter the BIOS menu, then you can try to find a setting named xDCI (so that‚Äôs ‚ÄúxDCI‚Äù, not ‚ÄúxHCI‚Äù).
It is usually somewhere under some USB menu.
If you have that, then enable it, and you should see the DWC3 PCI device in the operating system.
</th>
	</tr>

</tbody></table>

<p>This was where I encountered the term xDCI for the first time.</p>

<p>An online search for <code>xDCI</code> revealed:</p>

<table>
	<tbody><tr>
		<th>¬´</th>
		<th>
Extensible Device Controller Interface (xDCI) is an interface specification that defines Device Controller for a Universal Serial Bus (USB 3), which is capable of interfacing with USB 1.x, 2.0, and 3.x compatible devices.
In the case that the computer is connected as a device to another computer (for example, a tablet connected to a desktop), then the xDCI controller will be activated inside the device and will talk to the Host on the other computer.
</th>
	</tr>

	<tr>
		<th></th>
		<th><a href="https://edc.intel.com/content/www/us/en/design/ipla/software-development-platforms/client/platforms/alder-lake-desktop/12th-generation-intel-core-processors-datasheet-volume-1-of-2/010/extensible-device-controller-interface-xdci/">Extensible Device Controller Interface (xDCI)</a>, 12th Generation Intel¬Æ Core‚Ñ¢ Processors Datasheet</th>
	</tr>

</tbody></table>

<p>So, xDCI is what Intel calls its interface for the DWC3 UDC.
Unlike xHCI, xDCI is the interface for the device side of USB, not the host one.</p>

<p>In the response, Heikki suggested checking whether xDCI could be enabled in BIOS.
This created a spark of hope for me.
Perhaps I could indeed enable xDCI in BIOS, and everything would work.</p>

<p>
For simplicity, I will be using the term ‚ÄúxDCI‚Äù to refer to the Intel‚Äôs DWC3 UDC itself from now on.
</p>

<p>
Even though technically, the word ‚Äú<a href="https://en.wikipedia.org/wiki/BIOS">BIOS</a>‚Äù refers to the legacy firmware used by older <a href="https://en.wikipedia.org/wiki/IBM_PC_compatible">IBM PC‚Äìcompatible</a> systems, I will be saying ‚ÄúBIOS‚Äù to refer to the <a href="https://en.wikipedia.org/wiki/UEFI">UEFI</a>-compatible platform firmware of modern systems for simplicity.
</p>

<p>
Once I knew the term ‚ÄúxDCI‚Äù, I also did an online search for <code>xHCI xDCI</code>.
This led me to a diagram from the <a href="https://projectacrn.github.io/latest/developer-guides/hld/usb-virt-hld.html">USB Virtualization</a> documentation page of Project ACRN, which schematically shows xHCI, xDCI, and the mux between them.
</p>

<p><strong>xDCI in ACPI</strong>.
In the discussion, Felipe Balbi, who was the maintainer for the USB Gadget subsystem in the Linux kernel up until recently, added:</p>

<table>
	<tbody><tr>
		<th>¬´</th>
		<th>
Also, have a look at <code>acpidump</code>.
See if the device even exists in your <code>DSDT</code> but, perhaps, is disabled (look at the <code>_STA</code> method for <code>OTDG</code> or <code>XDCI</code>).
</th>
	</tr>

</tbody></table>

<p>Here, Felipe proposed to also make sure that xDCI was enabled in ACPI.</p>

<table>
	<tbody><tr>
		<th>¬´</th>
		<th>
ACPI (Advanced Configuration and Power Interface) is an open standard that operating systems can use to discover and configure computer hardware components.
ACPI defines hardware abstraction interfaces between the device‚Äôs firmware (e.g., BIOS, UEFI), the computer hardware components, and the operating systems.
</th>
	</tr>

	<tr>
		<th></th>
		<th><a href="https://en.wikipedia.org/wiki/ACPI">ACPI</a>, Wikipedia</th>
	</tr>

</tbody></table>

<p>After reading more about ACPI, I found out that <code>_STA</code> method is used to check the device status.
The OS will only try to connect the device if its status indicates that the device is enabled and properly configured.
If the <code>_STA</code> method is not defined in ACPI at all, the device will not function.</p>

<p><strong>Next steps</strong>.
Finding this discussion was extremely helpful.
Now I knew what to do next:</p>

<ol>
  <li>Check if the xDCI device shows up in the list of PCIe devices;</li>
  <li>If not, check if there is a way to enable xDCI through BIOS;</li>
  <li>Finally, check if ACPI enables xDCI.</li>
</ol>

<h3 id="-checking-pcie-and-acpi">üöß Checking PCIe and ACPI</h3>

<p><strong>Checking PCIe device</strong>.
Following Heikki‚Äôs guidance, I first checked whether the xDCI device appeared on my laptop‚Äôs list of PCIe devices via <code>sudo lspci -vvnnn</code>.</p>

<p>The only USB device that I saw there was xHCI with the <code>9d2f</code> device ID:</p>

<div><div><pre><code>00:14.0 USB controller [0c03]: Intel Corporation Sunrise Point-LP USB 3.0 xHCI Controller [8086:9d2f] (rev 21) (prog-if 30 [XHCI])
	Subsystem: Lenovo Sunrise Point-LP USB 3.0 xHCI Controller [17aa:225c]
	Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B- DisINTx+
	Status: Cap+ 66MHz- UDF- FastB2B+ ParErr- DEVSEL=medium &gt;TAbort- &lt;TAbort- &lt;MAbort- &gt;SERR- &lt;PERR- INTx-
	Latency: 0
	Interrupt: pin A routed to IRQ 130
	Region 0: Memory at 2ffb210000 (64-bit, non-prefetchable) [size=64K]
	Capabilities: [70] Power Management version 2
		Flags: PMEClk- DSI- D1- D2- AuxCurrent=375mA PME(D0-,D1-,D2-,D3hot+,D3cold+)
		Status: D0 NoSoftRst+ PME-Enable- DSel=0 DScale=0 PME-
	Capabilities: [80] MSI: Enable+ Count=1/8 Maskable- 64bit+
		Address: 00000000fee00358  Data: 0000
	Kernel driver in use: xhci_hcd
	Kernel modules: xhci_pci
</code></pre></div></div>

<p>Then, I checked the <code>dwc3</code> driver <a href="https://elixir.bootlin.com/linux/v6.5/source/drivers/usb/dwc3/dwc3-pci.c#L26">source code</a> to find out what ID the xDCI device should have:</p>

<div>
  <p>
SPTLP stands for ‚ÄúSunrise Point-LP‚Äù.
</p>
</div>

<div><div><pre><code><span>#define PCI_DEVICE_ID_INTEL_SPTLP		0x9d30
</span></code></pre></div></div>

<p>Unfortunately, I could not see a device with this ID üò¢</p>

<p>However, from the <code>lspci</code> output, I found out that my ThinkPad X1 Carbon 6th Gen laptop uses the Sunrise Point-LP chipset.
This information came in handy later.</p>

<p><strong>Checking ACPI</strong>.
Before moving on to checking BIOS settings, I decided to find out whether the <code>_STA</code> method existed in ACPI for <code>XDCI</code> or <code>OTGD</code>.</p>

<p>I dumped and decompiled <code>DSDT</code> via:</p>

<div><div><pre><code><span>$ </span><span>sudo </span>apt-get <span>install </span>acpica-tools
<span>$ </span><span>sudo </span>acpidump <span>&gt;</span> acpi.dat
<span>$ </span>acpixtract <span>-a</span> acpi.dat
<span>$ </span>iasl <span>-d</span> dsdt.dat
</code></pre></div></div>

<p>And grepped <code>dsdt.dsl</code> for <code>XDCI</code>:</p>

<div><div><pre><code>Device (XDCI)
{
    Name (_ADR, 0x00140001)  // _ADR: Address
    OperationRegion (OTGD, PCI_Config, 0x00, 0x0100)
    Field (OTGD, DWordAcc, NoLock, Preserve)
    {
        DVID,   16,
        Offset (0x10),
        XDCB,   64
    }

    Method (_STA, 0, NotSerialized)  // _STA: Status
    {
        If ((DVID != 0xFFFFFFFF))
        {
            Return (0x0F)
        }
        Else
        {
            Return (0x00)
        }
    }

    ...
}
</code></pre></div></div>

<p>This was good news: the <code>_STA</code> method was present!
While this didn‚Äôt necessarily mean that ACPI properly set up xDCI, this was already promising.</p>

<p>
I believe that <code>DVID</code> in the <code>_STA</code> implementation stands for ‚ÄúDevice ID‚Äù, and it is read from the PCIe Configuration Space of the xDCI device, but I didn‚Äôt analyze ACPI for xDCI beyond that.
</p>

<p><strong>Status result</strong>.
Out of curiosity, I decided to check what the <code>_STA</code> method returned.</p>

<p>After looking around <code>/sys/bus/acpi/devices/</code>, I found out that <code>device:33</code> was designated to the <code>XDCI</code> ACPI device:</p>

<div><div><pre><code><span>$ </span><span>cat</span> /sys/bus/acpi/devices/device:33/path
<span>\_</span>SB_.PCI0.XDCI
</code></pre></div></div>

<p>And the result of the <code>_STA</code> method was:</p>

<div><div><pre><code><span>$ </span><span>cat</span> /sys/bus/acpi/devices/device:33/status
15
</code></pre></div></div>

<p>Interestingly, <code>_STA</code> returned <code>15</code>, which <a href="https://www.kernel.org/doc/html/latest/admin-guide/abi-testing.html#abi-sys-bus-acpi-devices-status">stands for</a> the device being enabled and functioning.
However, as I had no xDCI device show up in <code>lspci</code>, this was clearly false.
Perhaps everything functioned properly only from the ACPI point of view.</p>

<p>I decided that finding a defined <code>_STA</code> method was good enough and proceeded to check BIOS.</p>

<h3 id="-checking-bios">üéÅ Checking BIOS</h3>

<p>An online search for combinations of <code>ThinkPad</code>, <code>BIOS</code>, and <code>xDCI</code> yielded no relevant results.
Apparently, no one has attempted to figure out whether xDCI can be enabled in Thinkpad BIOS.</p>

<p><strong>BIOS settings</strong>.
I booted into the BIOS settings screen (aka BIOS Setup) and looked around for something related to xDCI or OTG.
I found nothing.</p>

<p>I knew that many Lenovo laptops had a hidden <code>Advanced</code> page in their BIOS settings.
So, perhaps I could find the xDCI setting there.
While some Lenovo laptops allow unlocking this page via magic keypresses, I failed to find a way to do this on Thinkpad X1 Carbon.
But maybe there was another way.</p>

<p><strong>Unpacking BIOS</strong>.
Before trying to unlock the <code>Advanced</code> page, I decided to check the BIOS image directly for the presence of an xDCI-related setting.</p>

<p>I downloaded the BIOS Bootable CD update image from the <a href="https://pcsupport.lenovo.com/us/de/products/laptops-and-netbooks/thinkpad-x-series-laptops/thinkpad-x1-carbon-6th-gen-type-20kh-20kg/downloads/ds502281">Lenovo website</a>, unpacked it, and mounted it:</p>

<div><div><pre><code><span>$ </span><span>sudo </span>apt-get <span>install </span>genisoimage
<span>$ </span>geteltorito <span>-o</span> n23ur39w.img n23ur39w.iso
<span>$ </span><span>sudo </span>kpartx <span>-av</span> ./n23ur39w.img
<span>$ </span><span>sudo mkdir</span> /mnt/bios
<span>$ </span><span>sudo </span>mount <span>-o</span> ro /dev/mapper/loop0p1 /mnt/bios/
</code></pre></div></div>

<p>The main BIOS binary was now in <code>/mnt/bios/FLASH/N23ET86W/\$0AN2300.FL1</code>.</p>

<p>
For reference, here‚Äôs how to unmount the image later:
</p>

<div><div><pre><code><span>$ </span><span>sudo </span>umount /mnt/bios/
<span>$ </span><span>sudo </span>kpartx <span>-d</span> ./n23ur39w.img
</code></pre></div></div>

<p>
Also, for reference, here‚Äôs how to extract BIOS from the <code>.exe</code> update finary that Lenovo provides:
</p>

<div><div><pre><code><span>$ </span><span>sudo </span>apt-get <span>install </span>innoextract
<span>$ </span>innoextract n23uj39w_v2.exe
<span>$ </span><span>ls </span>codeGetExtractPath/N23ET86W/<span>\$</span>0AN2300.FL1
</code></pre></div></div>

<p>
Right in the middle of me meddling with BIOS images, Lenovo removed its Linux <code>*.cab</code> BIOS update packages from their website ü§î
So no more <code>cabextract</code> üò¢
Come to think of this, new ThinkPads are also <a href="https://wiki.archlinux.org/title/Lenovo_ThinkPad_X1_Carbon_(Gen_10)">missing</a> Linux kernel drivers for their MIPI web cameras.
Eh, Lenovo.
</p>

<p><strong>UEFITool</strong>.
I installed <a href="https://github.com/LongSoft/UEFITool">UEFITool</a> and imported the BIOS binary:</p>

<div><div><pre><code><span>$ </span><span>sudo </span>apt-get <span>install </span>uefitool
<span>$ </span>UEFITool /mnt/bios/FLASH/N23ET86W/<span>\$</span>0AN2300.FL1
</code></pre></div></div>

<p>I searched for <code>xDCI</code> and got a hit in GUID <code>E6A7A1CE-5881-4B49-80BE-69C91811685C</code>, corresponding to the <code>Setup</code> module.</p>

<figure>
	
		
			<img src="https://hazure.neocities.org/images/content/thinkpad-xdci/uefi-tool-xdci.jpg" title="Searching for xDCI via UEFITool"/>
		
	
	
		<figcaption>Searching for xDCI via UEFITool</figcaption>
	
</figure>

<table>
	<tbody><tr>
		<th>¬´</th>
		<th>
A GUID is a unique 128-bit number that is a <u>G</u>lobally <u>U</u>nique <u>ID</u>entifier.
Each time an image, protocol, device, or other item is defined in UEFI, a GUID must be generated for that item. 
</th>
	</tr>

	<tr>
		<th></th>
		<th><a href="https://github.com/tianocore-docs/edk2-UefiDriverWritersGuide/blob/master/3_foundation/35_guids.md">GUIDs</a>, EDK II Driver Writer‚Äôs Guide</th>
	</tr>

</tbody></table>

<p>I extracted the binary data from the <code>PE32 image section</code> of the <code>Setup</code> module into <code>Setup.bin</code> via <code>Extract body...</code> from UEFITool and checked for strings that contained <code>xDCI</code>:</p>

<div><div><pre><code><span>$ </span>strings <span>-el</span> ./Setup.bin | <span>grep </span>xDCI
xDCI Support
Enable/Disable xDCI <span>(</span>USB OTG Device<span>)</span><span>.</span>
</code></pre></div></div>

<p>Aha!
So, the setting for enabling xDCI was there; it was just indeed hidden by default.</p>

<h2 id="-enabling-xdci">üí° Enabling xDCI</h2>

<p>At this point, I had high hopes that xDCI could be enabled through BIOS.
I only had to find a way to unlock the setting to do this.</p>

<h3 id="-enabling-xdci-via-advanced-settings">‚öô Enabling xDCI via Advanced settings</h3>

<p>The first thing I tried was unlocking the hidden <code>Advanced</code> BIOS page.</p>

<p>Luckily, the BIOS modding community has already figured this out.
The process is <a href="https://tylernguyen.github.io/x1c6-hackintosh/BIOS/modding-the-BIOS/">well-documented</a> by the authors of the <a href="https://github.com/tylernguyen/x1c6-hackintosh">x1c6-hackintosh project</a> coordinated by <a href="https://tylernguyen.social/@tylernguyen">Tyler Nguyen</a>.
That project aims to run MacOS on ThinkPad X1 Carbon 6th Gen ‚Äî specifically the laptop that I had.</p>

<p><strong>SPI reflashing</strong>.
Unlocking the <code>Advanced</code> page via the proposed method required reflashing the SPI chip that stores BIOS.</p>

<p>The most common approach for reflashing the BIOS SPI chip is attaching a clip to the chip on the laptop‚Äôs motherboard and using an SPI programmer to rewrite the chip‚Äôs contents.
The good thing about this approach is that you can attach the clip once and then reflash BIOS as many times as you‚Äôd like.</p>

<p>However, I was hesitant to use that approach.
A few years ago, I successfully fried the motherboard on another laptop when I tried reflashing BIOS with an SPI clip.
I guess I either connected the clip improperly, or the motherboard just didn‚Äôt tolerate the SPI chip being powered externally.
This time, I wanted to avoid messing this up.</p>

<p>A safer approach to reflashing an SPI chip is to unsolder it from the motherboard and directly connect it to an SPI programmer.
This is more time-consuming but allows avoiding damaging the motherboard.
In the worst case, you would just kill the SPI chip, which is easily replaceable.</p>

<p><strong>SPI socket</strong>.
Instead of unsoldering and soldering the chip back on for each BIOS test, I decided to replace the SPI chip on the motherboard with an <a href="https://www.adafruit.com/product/4726">SPI socket</a>.
With the socket in place, I could take the chip out and put it back in whenever I wanted.</p>

<p>My soldering skills are not great.
Luckily, <a href="https://brs.im/">Sergey Korablin</a>, who used to design and assemble motherboards for a job, was around to help me with soldering ü§ó</p>

<p>Accessing to the SPI chip on the ThinkPad X1 Carbon 6th Gen motherboard required removing the Wi-Fi antenna module.
This module was held by a single screw, so this was not hard.
We also disconnected the main laptop battery before soldering, just in case (and I also did that whenever I took the chip out of the socket).</p>

<figure>
	
		
			<img src="https://hazure.neocities.org/images/content/thinkpad-xdci/spi-socket.jpg" title="Left: SPI chip before unsoldering; Right: SPI socket installed"/>
		
	
	
		<figcaption>Left: SPI chip before unsoldering; Right: SPI socket installed</figcaption>
	
</figure>

<p><strong>Wieson G6179-10</strong>.
For the SPI socket, I chose <a href="https://www.adafruit.com/product/4726">Wieson G6179-10</a> by Adafruit.</p>

<p>This socket had a few non-critical problems:</p>

<ol>
  <li>
    <p>It was quite large, so the bottom laptop lid didn‚Äôt fully close;</p>
  </li>
  <li>
    <p>The latch on the socket was tight, so opening it required care to avoid tearing it apart from the motherboard (I used a thread to pull on the latch while holding the socket in place);</p>
  </li>
  <li>
    <p>The connection between the chip and the socket was flaky: my laptop would occasionally shut down and make beep noises on the power-on (I had to jiggle the chip in the socket to fix that temporarily).</p>
  </li>
</ol>

<p>But overall, the socket was good enough for running my experiments.</p>

<p><strong>FT2232H Mini Module</strong>.
For reflashing the SPI chip, I used the <a href="https://ftdichip.com/products/ft2232h-mini-module/">FTDI FT2232H Mini Module</a>, which is a <a href="https://en.wikipedia.org/wiki/USB-to-serial_adapter">USB-to-serial converter</a> that supports working with SPI, UART, I2C, and JTAG.</p>

<p>
I learned about this module from an <a href="http://blog.cr4.sh/2016/10/exploiting-ami-aptio-firmware.html">article</a> by <a href="https://twitter.com/d_olex">Dmytro Oleksiuk</a> many years ago and have it in my toolkit since then.
</p>

<p>
For reference, here‚Äôs the pinout of this module for working with SPI chips:
</p>

<div>
  <p>
The module can simultaneously work with two SPI chips through different channels (named 2 and 3).
</p>
</div>

<table>
  <thead>
    <tr>
      <th>SPI chip pin</th>
      <th>Boarn pin, ch. 2</th>
      <th>Board pin, ch. 3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>CN2.12</td>
      <td>CN3.23</td>
    </tr>
    <tr>
      <td>2</td>
      <td>CN2.09</td>
      <td>CN3.24</td>
    </tr>
    <tr>
      <td>3</td>
      <td>CN2.14</td>
      <td>CN3.21</td>
    </tr>
    <tr>
      <td>4</td>
      <td>CN2.02</td>
      <td>CN3.04</td>
    </tr>
    <tr>
      <td>5</td>
      <td>CN2.10</td>
      <td>CN3.25</td>
    </tr>
    <tr>
      <td>6</td>
      <td>CN2.07</td>
      <td>CN3.26</td>
    </tr>
    <tr>
      <td>7</td>
      <td>CN2.13</td>
      <td>CN3.20</td>
    </tr>
    <tr>
      <td>8</td>
      <td>CN2.05</td>
      <td>CN3.01</td>
    </tr>
  </tbody>
</table>

<p>To connect the SPI chip pins to the FT2232H module, I used a SOP8 to DIP8 adapter (similar to <a href="https://www.amazon.de/-/en/DollaTek-200-208mils-Socket-Adapter-OTS-20-1-27-01/dp/B07DK2TNYV">this one</a>) and a bunch of <a href="https://www.amazon.de/-/en/EL-CP-004/dp/B01EV70C78/">jump wires</a>.
I also connected <code>CN2.1</code> to <code>CN2.11</code> and <code>CN3.1</code> to <code>CN3.3</code> on the FT2232H module to enable the USB Bus-Powered mode according to the module‚Äôs <a href="https://ftdichip.com/wp-content/uploads/2020/07/DS_FT2232H_Mini_Module.pdf">datasheet</a>.</p>

<figure>
	
		
			<img src="https://hazure.neocities.org/images/content/thinkpad-xdci/ft2232h.jpg" title="FTDI FT2232H Mini Module connected to SOP8 to DIP8 adapter with SPI chip"/>
		
	
	
		<figcaption>FTDI FT2232H Mini Module connected to SOP8 to DIP8 adapter with SPI chip</figcaption>
	
</figure>

<p>To dump the contents of the SPI chip via the module, I used <code>flashrom</code>:</p>

<div><div><pre><code><span>$ </span><span>sudo </span>flashrom <span>-p</span> ft2232_spi:type<span>=</span>2232H,port<span>=</span>A <span>-r</span> bios.bin
</code></pre></div></div>

<p>
Tip: always dump SPI chips twice and make sure the contents in both dumps match.
</p>

<p><strong>Patching BIOS</strong>.
The <a href="https://tylernguyen.github.io/x1c6-hackintosh/BIOS/modding-the-BIOS/">BIOS modding guide</a> suggested patching the BIOS image in two steps:</p>

<ol>
  <li>
    <p>Use the <code>UEFIPatch</code> tool to apply a provided <a href="https://github.com/digmorepaka/thinkpad-firmware-patches/blob/master/xx70_xx80_patches_v7.txt">set of patches</a>;</p>
  </li>
  <li>
    <p>Use a hex editor to change the <code>4C 4E 56 42 42 53 45 43 FB</code> byte sequence to <code>4C 4E 56 42 42 53 45 43 FF</code> (the last byte is different).</p>
  </li>
</ol>

<p>Before mindlessly following these steps, I decided to get at least a high-level understanding of what these changes did.</p>

<p><strong>First patch</strong>.
After poking around, I found out that the first step <a href="https://habr.com/en/articles/250611/">replaced references</a> to the GUID for the <code>Date/Time</code> BIOS page with such for the <code>Advanced</code> one:</p>

<div><div><pre><code># SystemFormBrowserCoreDxe | enable advance menu Lenovo xx70/xx80
721C8B66-426C-4E86-8E99-3457C46AB0B9 10 P:04320b483cc2e14abb16a73fadda475f:778b1d826d24964e8e103467d56ab1ba
32442D09-1D11-4E27-8AAB-90FE6ACB0489 10 P:04320b483cc2e14abb16a73fadda475f:778b1d826d24964e8e103467d56ab1ba
</code></pre></div></div>

<p>With this patch, the <code>Date/Time</code> BIOS settings page should be replaced with the <code>Advanced</code> one.</p>

<p>I applied the patch above via <code>UEFIPatch</code> to my <code>bios.bin</code>:</p>

<div><div><pre><code><span>$ </span><span>sudo </span>apt-get <span>install </span>uefitool-cli
<span>$ </span>UEFIPatch bios.bin patch.txt <span>-o</span> bios-patched.bin
</code></pre></div></div>

<p><strong>Second patch</strong>.
The second step of changing a magical byte sequence was quite cryptic.</p>

<div>
  <p>
I suspect this patch switches the TPM-related BIOS setting bit in NVRAM, but I didn‚Äôt check it.
</p>
</div>

<p>Eventually, I <a href="https://github.com/tylernguyen/x1c6-hackintosh/issues/85#issuecomment-730309699">found out</a> that this change was forcing the TPM (Trusted Platform Module) into the <code>MFG Mode</code> (Manufacturing Mode).
This prevented Boot Guard from detecting the BIOS modification from step #1.</p>

<table>
	<tbody><tr>
		<th>¬´</th>
		<th>
Intel Boot Guard is a processor feature that prevents the computer from running firmware (UEFI) images not released by the system manufacturer.
When turned on, the processor verifies a digital signature contained in the firmware image before executing it using the public key, which is fused into the system‚Äôs Platform Controller Hub (PCH) by the system manufacturer (not by Intel).
As a result, Intel Boot Guard makes it impossible for end users to install replacement firmware or modded BIOS.
</th>
	</tr>

	<tr>
		<th></th>
		<th><a href="https://en.wikipedia.org/wiki/Intel_vPro#IBG">Intel vPro</a>, Wikipedia</th>
	</tr>

</tbody></table>

<p>Normally, disabling Boot Guard should be much harder than simply flipping a bit in the BIOS binary.
But I guess ThinkPad X1 Carbon 6th Gen is just old and vulnerable.</p>

<p>
I did this step on a fairly old BIOS version 1.37.
It is possible that this Boot Guard bypass has been fixed in one of the newer versions.
However, the NVRAM approach I discuss below should still work.
</p>

<p>
I tried applying only the first change without the second.
The laptop made beeping noises, most likely indicating a Boot Guard failure, and refused to boot.
</p>

<p>To apply the patch from the second step, I simply used the <code>ghex</code> hex editor.</p>

<p><strong>Flashing</strong>.
After applying both patches, I flashed the modified BIOS to the SPI chip:</p>

<div><div><pre><code><span>$ </span><span>sudo </span>flashrom <span>-p</span> ft2232_spi:type<span>=</span>2232H,port<span>=</span>A <span>-w</span> bios-patched.bin
</code></pre></div></div>

<p>And put the chip into the socket.</p>

<p><strong>Advanced settings</strong>.
After booting into BIOS, the <code>Date/Time</code> page disappeared, but the <code>Advanced</code> page appeared instead, as expected ü•≥</p>

<div>
  <p>
I haven‚Äôt found a way to take BIOS screenshots, so I had to take pictures of the screen üôÉ
</p>
</div>

<figure>
	
		
			<img src="https://hazure.neocities.org/images/content/thinkpad-xdci/bios1.jpg" title=""/>
		
	
	
</figure>

<p>After following through <code>Intel Advanced Menu</code>, <code>PCI-IO Configuration</code>, and <code>USB Configuration</code>, I found the setting called <code>xDCI Support</code> and switched it to <code>Enabled</code>.</p>

<figure>
	
		
			<img src="https://hazure.neocities.org/images/content/thinkpad-xdci/bios2.jpg" title=""/>
		
	
	
</figure>

<p>I also checked the TPM settings.
As expected, the TPM was switched to <code>MFG Mode</code>.</p>

<figure>
	
		
			<img src="https://hazure.neocities.org/images/content/thinkpad-xdci/bios3.jpg" title=""/>
		
	
	
</figure>

<p><strong>Success</strong>.
After I booted the laptop, I checked <code>lspci</code> once again.</p>

<p>Magically, the xDCI device with the expected <code>9d30</code> device ID appeared ü•≥:</p>

<div><div><pre><code>00:14.1 USB controller [0c03]: Intel Corporation Device [8086:9d30] (rev 21) (prog-if fe [USB Device])
	Subsystem: Lenovo Device [17aa:225c]
	Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B- DisINTx-
	Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast &gt;TAbort- &lt;TAbort- &lt;MAbort- &gt;SERR- &lt;PERR- INTx-
	Latency: 0
	Interrupt: pin B routed to IRQ 17
	Region 0: Memory at 2ffb000000 (64-bit, non-prefetchable) [size=2M]
	Region 2: Memory at 2ffb230000 (64-bit, non-prefetchable) [size=4K]
	Capabilities: [80] Power Management version 3
		Flags: PMEClk- DSI- D1- D2- AuxCurrent=0mA PME(D0+,D1-,D2-,D3hot+,D3cold-)
		Status: D0 NoSoftRst+ PME-Enable- DSel=0 DScale=0 PME-
	Capabilities: [90] Vendor Specific Information: Len=14 &lt;?&gt;
	Kernel driver in use: dwc3-pci
	Kernel modules: dwc3_pci
</code></pre></div></div>

<p>Moreover, the kernel even automatically loaded the <code>dwc3</code> UDC driver (remember that xDCI is based on DWC3), and a new entry appeared in the list of UDC devices ü§Ø:</p>

<div><div><pre><code><span>$ </span><span>ls</span> /sys/class/udc/
dwc3.1.auto
</code></pre></div></div>

<p>The only thing left was checking whether this UDC driver actually worked with xDCI.</p>

<p><strong>Shortcomings</strong>.
This approach of enabling xDCI had two shortcomings.
It required:</p>

<ol>
  <li>
    <p>Reflashing the SPI chip via a programmer.
This sets a high bar for those wishing to enable xDCI on their machine.
Doing this might also be impossible on newer systems due to RPMC; see the <a href="#-afterword">Afterword</a> section.</p>
  </li>
  <li>
    <p>Having a Boot Guard bypass.
While there is a bypass for the X1 Carbon 6th Gen laptop, other machines might not be vulnerable in the same way.</p>
  </li>
</ol>

<p>I tried to tackle these problems later; see the <a href="#-attempting-to-enable-xdci-via-pch">sections</a> <a href="#-enabling-xdci-via-nvram">below</a>.</p>

<h3 id="-checking-xdci">üßÅ Checking xDCI</h3>

<p>At this point, I had xDCI enabled in BIOS, and the <code>dwc3</code> UDC driver was loaded.</p>

<p>As before, I switched the USB role to the <code>device</code> state:</p>

<div><div><pre><code><span>$ </span><span>echo </span>device | <span>sudo tee</span> /sys/class/usb_role/intel_xchi_usb_sw-role-switch/role
</code></pre></div></div>

<p>And as before, nothing happened; no new <code>dmesg</code> messages appeared, at least.</p>

<p>But as I now had the UDC driver loaded, I could attempt emulating a USB device through it and check if that works.</p>

<p><strong>Finding port</strong>.
First, I had to figure out to which USB port xDCI was connected, if to any.</p>

<p>On Raspberry Pi‚Äìlike boards, there is usually a single USB port that can be used for USB device emulation; such port is typically marked as ‚ÄúUSB OTG‚Äù.
But there are no such markings on ThinkPad laptops.
Moreover, it could be that the xDCI-enabled port of the xHCI controller was not wired to the external casing of the laptop at all üòü</p>

<p>To find the xDCI-enabled port, I tried plugging in a USB flash drive into all external ports one by one while having the USB role set to <code>device</code>.
The second port I tried didn‚Äôt work: the OS did not detect the flash drive.
But once I switched the USB role back to <code>host</code>, the port started working.</p>

<p>So, it looked like I had found the right port ü•≥</p>

<figure>
	
		
			<img src="https://hazure.neocities.org/images/content/thinkpad-xdci/xdci-port.jpg" title="xDCI-enabled port on ThinkPad X1 Carbon 6th Gen"/>
		
	
	
		<figcaption>xDCI-enabled port on ThinkPad X1 Carbon 6th Gen</figcaption>
	
</figure>

<p><strong>USB cable</strong>.
Next, I needed a USB cable to connect my laptop to a USB host.</p>

<p>First, the cable had to be male-to-male: the xDCI-enabled port of my laptop was type A, not type B, which is typically used on USB devices.
So, I needed a cable with a type A connector on both sides.</p>

<p>
Technically, male-to-male cables are <a href="https://electronics.stackexchange.com/questions/644717/are-usb-2-0-type-a-male-male-cables-compliant-with-usb-specification">not compliant</a> with USB 2.0.
But, oh well, USB is weird.
</p>

<p>Then, it was reasonable to use a cable with the power <code>VBUS</code> line disconnected.
It could be that role switching did not turn off the power on the xDCI-enabled port (and this was indeed the case: I later checked with a USB breakout board and a multimeter).
And connecting two devices with slightly different <code>VBUS</code> levels might not be a good idea.</p>

<p>
A normal USB 2.0 cable has four wires inside: the power <code>VBUS</code> and the ground <code>GND</code> lines that the host uses to supply 5 V and up to 500 mA of power to the device, and the data <code>D-</code> and <code>D+</code> lines that are used primarily to transmit data.
</p>

<p><strong>Making USB cable</strong>.
For the initial testing, I cut open two USB 2.0 cables with type A connectors and used them to make a single male-to-male cable with <code>VBUS</code> disconnected.
Later, I switched to using <a href="https://www.amazon.de/gp/product/B094FYL9QT/">PortaPow USB Power Blocker</a> with a <a href="https://www.amazon.de/-/en/gp/product/B07NSM1XTL/">male-to-male USB 2.0 cable</a> as a more production-grade solution.</p>

<p>
PortaPow USB Power Blocker is a USB adapter that disconnects <code>VBUS</code> while leaving the data <code>D-</code> and <code>D+</code> and the ground <code>GND</code> lines untouched.
Perfect for my use case.
</p>

<figure>
	
		
			<img src="https://hazure.neocities.org/images/content/thinkpad-xdci/usb-wires.jpg" title="Left: DIY male-to-male USB 2.0 cable with VBUS (red wire) disconnected;&lt;br&gt;Right: male-to-male USB 2.0 cable with PortaPow USB Power Block attached"/>
		
	
	
		<figcaption>Left: DIY male-to-male USB 2.0 cable with VBUS (red wire) disconnected;</figcaption>
	
</figure>

<p>
I also tried using the <a href="https://www.datapro.net/products/usb-3-0-super-speed-a-a-debugging-cable.html">USB 3.0 Super-Speed A/A Debugging Cable</a> made by DataPro.
This is a male-to-male USB 3.0 cable that leaves <code>VBUS</code> disconnected (along with USB 2.0 <code>D-</code> and <code>D+</code>) and swaps the SuperSpeed receiver/transmitter differentials pairs.
However, this cable didn‚Äôt work for my use case; I haven‚Äôt tried to figure out why.
</p>

<p><strong>Gadget Zero</strong>.
Now came the moment of truth.
I connected the xDCI-enabled port of my X1 Carbon 6th Gen laptop to a USB port of another computer and loaded the <code>g_zero</code> gadget driver module.</p>

<p>
<code>g_zero</code> is a gadget driver module that is typically used for testing UDCs.
Its <a href="https://elixir.bootlin.com/linux/v6.5/source/drivers/usb/gadget/legacy/Kconfig#L39">configuration entry</a> says: ‚ÄúMake this be the first driver you try using on top of any new USB peripheral controller driver‚Äù.
Once loaded, this module emulates a testing USB device through the first UDC it finds on the system.
</p>

<p>And it worked! The <code>g_zero</code> gadget driver successfully emulated a USB device through xDCI for another laptop that I used as the host ü•≥</p>

<figure>
	
		
			<img src="https://hazure.neocities.org/images/content/thinkpad-xdci/xdci-emulation.jpg" title="ThinkPad X1 Carbon 6th Gen emulates a USB device for ThinkPad X1 Carbon 10th Gen via xDCI"/>
		
	
	
		<figcaption>ThinkPad X1 Carbon 6th Gen emulates a USB device for ThinkPad X1 Carbon 10th Gen via xDCI</figcaption>
	
</figure>

<p>Awesome! üòÉ</p>

<p>Before moving on to showing a few more interesting <a href="#-using-xdci">usage examples</a> for xDCI, I‚Äôll cover two other approaches to enabling it that I tried.</p>

<h3 id="-attempting-to-enable-xdci-via-pch">üßæ Attempting to enable xDCI via PCH</h3>

<p>After I managed to enable xDCI by reflashing the SPI chip, I was wondering whether it would be possible to do this purely via software.
My thinking was that since BIOS somehow enabled xDCI, perhaps I could do the same from the booted OS.</p>

<p>For this, I had to figure out how exactly BIOS enabled xDCI.</p>

<p>
This approach was suggested to me by <a href="https://twitter.com/h0t_max">Maxim Goryachy</a>, who is an expert in the low-level platform security area.
Maxim also tremendously helped me by answering questions about BIOS and PCH.
</p>

<p>
For everything in this section, I used the old BIOS version 1.37.
I did not check whether it all works the same with newer versions.
</p>

<p><strong>BIOS source</strong>.
I‚Äôm not a big fan of reverse engineering binaries, so decompiling BIOS to understand how it handled xDCI was not a thing I wanted to do.</p>

<p>Luckily, there have been several BIOS source code leaks from various manufacturers over the last few years.
Thus, obtaining the source code for the Kaby Lake BIOS was not hard (my ThinkPad X1 Carbon 6th Gen laptop with the i7-8650U CPU is <a href="https://www.thinkwiki.org/wiki/Category:X1_Carbon_(6th_Gen)">based</a> on the Kaby Lake R architecture).</p>

<p>
I will not provide a link to the leaked source code nor full snippets of non-public code to limit the possibility of violating some copyrights.
But you can find the leaked code yourself if you‚Äôre interested; search for <code>KabylakeSiliconPkg</code>.
</p>

<p><strong>xDCI in BIOS</strong>.
I grepped the BIOS source code for <code>xDCI</code> and found the code responsible for its bring-up in <code>Pch/Library/Private/PeiPchInitLib/PchXdci.c</code>.</p>

<p>The code was roughly structured like this:</p>

<div><div><pre><code><span>ConfigureXdci</span><span>()</span> <span>{</span>
	<span>// Do stuff.</span>

	<span>if</span> <span>(</span><span>XdciConfig</span><span>.</span><span>Enable</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
		<span>// Do stuff to disable xDCI.</span>

		<span>// Disable xDCI in PSF.</span>

		<span>// Disable xDCI in PMC.</span>
	<span>}</span> <span>else</span> <span>{</span>
		<span>// Do stuff to enable xDCI.</span>
	<span>}</span>
<span>}</span>
</code></pre></div></div>

<p>The parts of the code that I replaced with comments appeared to manipulate various PCH registers.</p>

<table>
	<tbody><tr>
		<th>¬´</th>
		<th>
Platform Controller Hub (PCH) is a family of Intel‚Äôs single-chip chipsets.
PCH controls certain data paths and support functions used in conjunction with Intel CPUs.
</th>
	</tr>

	<tr>
		<th></th>
		<th><a href="https://en.wikipedia.org/wiki/Platform_Controller_Hub">Platform Controller Hub</a>, Wikipedia</th>
	</tr>

</tbody></table>

<p>My idea was to try reverting all of the register manipulations done in the disable branch in the reverse order and then apply the manipulations from the enable branch.</p>

<p><strong>Datasheet</strong>.
Before proceeding, I decided to try finding a datasheet for the PCH used on my laptop.
The datasheet could hopefully describe the PCH registers, which would be helpful.</p>

<p>First, I <a href="https://en.wikipedia.org/wiki/List_of_Intel_chipsets#LGA_1151_rev_1">found out</a> that Sunrise Point (the chipset on my laptop) is the codename for the series 100 PCH chipsets.
Even though Kaby Lake does <a href="https://en.wikipedia.org/wiki/Kaby_Lake">support</a> the 200 series chipsets, ThinkPad X1 Carbon 6th Gen used an older one.</p>

<p>After that, I managed to find the <a href="https://www.intel.com/content/www/us/en/content-details/332691/intel-100-series-chipset-family-platform-controller-hub-pc">Intel 100 Series Chipset Family Platform Controller Hub (PCH)</a> datasheet.</p>

<p>However, the datasheet subtitle said ‚ÄúSupporting S and H Platform Register Information‚Äù.
Later, I discovered that this meant that this specific datasheet applied to Sunrise Point-<strong>H</strong> chipsets, not Sunrise Point-<strong>LP</strong>, which I had.
But it was still good enough for my purposes.</p>

<h4 id="-enabling-xdci-in-pmc">üîã Enabling xDCI in PMC</h4>

<p>The last step in the branch responsible for disabling xDCI in BIOS was disabling it in PMC.</p>

<p>
PMC (Power Management Controller) is a controller that manages power ü§ì
</p>

<p>Naturally, disabling xDCI in PMC most likely disconnected the xDCI device from power.</p>



<p><strong>xDCI in PMC</strong>.
To disable xDCI in PMC, BIOS set the <code>B_PCH_PWRM_NST_PG_FDIS_1_XDCI_FDIS_PMC</code> <a href="https://github.com/tianocore/edk2-platforms/blob/14b8c793e685422bf32ada10acf74e0ff1cf52fc/Silicon/Intel/KabylakeSiliconPkg/Pch/Include/Register/PchRegsPmc.h#L577">bit</a> (#24) in the <code>R_PCH_PWRM_NST_PG_FDIS_1</code> <a href="https://github.com/tianocore/edk2-platforms/blob/14b8c793e685422bf32ada10acf74e0ff1cf52fc/Silicon/Intel/KabylakeSiliconPkg/Pch/Include/Register/PchRegsPmc.h#L575">register</a> (offset <code>0x628</code>) of the PMC device.</p>

<p>I searched through the PCH datasheet and found out that <code>NST_PG_FDIS_1</code> was one of the PMC <code>Chipset Initialization Register</code>s, and its bit #24 was responsible for <code>XDCI Function Disable</code> as expected.</p>

<figure>
	
		
			<img src="https://hazure.neocities.org/images/content/thinkpad-xdci/pch-pmc.jpg" title="NST_PG_FDIS_1 register and its xDCI bit in the PCH datasheet"/>
		
	
	
		<figcaption>NST_PG_FDIS_1 register and its xDCI bit in the PCH datasheet</figcaption>
	
</figure>

<p><strong>PMC registers</strong>.
To enable xDCI in PMC, I thus wanted to reset the <code>XDCI Function Disable</code> bit in the <code>NST_PG_FDIS_1</code> register of the PMC device.</p>

<p>The question then was: ‚ÄúHow do I access this PMC register from the OS?‚Äù.</p>

<p>This turned out to be not hard.
In the datasheet, the <code>NST_PG_FDIS_1</code> register was listed in the <code>PMC Memory Mapped Registers</code> section.
This meant that the register was memory-mapped, and thus, I could access it through a specific address in physical memory.</p>

<p>I only had to figure out what that address was.</p>

<p><strong>PMC in BIOS</strong>.
First, I checked how BIOS finds this address.</p>

<p>As it turned out, BIOS <a href="https://github.com/tianocore/edk2-platforms/blob/14b8c793e685422bf32ada10acf74e0ff1cf52fc/Silicon/Intel/KabylakeSiliconPkg/Pch/Library/PeiDxeSmmPchCycleDecodingLib/PchCycleDecodingLib.c#L181">read</a> the PMC memory-mapped register area address from the <code>R_PCH_PMC_PWRM_BASE</code> <a href="https://github.com/tianocore/edk2-platforms/blob/14b8c793e685422bf32ada10acf74e0ff1cf52fc/Silicon/Intel/KabylakeSiliconPkg/Pch/Include/Register/PchRegsPmc.h#L52">register</a> (offset <code>0x48</code>) within the PCIe Configuration Space of the PMC device:</p>



<div id="bios-pmc-off">

  <div><div><pre><code><span>EFI_STATUS</span> <span>EFIAPI</span> <span>PchPwrmBaseGet</span> <span>(</span><span>OUT</span> <span>UINT32</span> <span>*</span><span>Address</span><span>)</span>
<span>{</span>
  <span>UINTN</span> <span>PmcBase</span> <span>=</span> <span>MmPciBase</span> <span>(</span>
                    <span>DEFAULT_PCI_BUS_NUMBER_PCH</span><span>,</span>
                    <span>PCI_DEVICE_NUMBER_PCH_PMC</span><span>,</span>
                    <span>PCI_FUNCTION_NUMBER_PCH_PMC</span>
                  <span>);</span>
  <span>*</span><span>Address</span> <span>=</span> <span>MmioRead32</span> <span>(</span><span>PmcBase</span> <span>+</span> <span>R_PCH_PMC_PWRM_BASE</span><span>)</span> <span>&amp;</span>
               <span>B_PCH_PMC_PWRM_BASE_BAR</span><span>;</span>
  <span>return</span> <span>EFI_SUCCESS</span><span>;</span>
<span>}</span>
</code></pre></div>  </div>
  <div>
  <p>
Click the switch to see the full source code.
</p>
</div>

</div>






<p>
Note that the PMC <a href="https://wiki.osdev.org/PCI_Express">PCIe Configuration Space</a> area (<code>PmcBase</code> in the snippet above) differs from the PMC memory-mapped register area (denoted as <code>PWRMBASE</code>).
Both are technically memory-mapped (can be accessed through physical memory), but they serve different purposes and reside at different addresses.
</p>

<p><strong>PMC device</strong>.
There indeed was a PMC PCIe device on my laptop:</p>

<div><div><pre><code>00:1f.2 Memory controller [0580]: Intel Corporation Sunrise Point-LP PMC [8086:9d21] (rev 21)
        Subsystem: Lenovo Sunrise Point-LP PMC [17aa:225c]
        Control: I/O- Mem- BusMaster- SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B- DisINTx-
        Status: Cap- 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast &gt;TAbort- &lt;TAbort- &lt;MAbort- &gt;SERR- &lt;PERR- INTx-
        Region 0: Memory at ee420000 (32-bit, non-prefetchable) [disabled] [size=16K]
</code></pre></div></div>

<p>The device and function numbers <code>1f.2</code> <a href="https://github.com/tianocore/edk2-platforms/blob/14b8c793e685422bf32ada10acf74e0ff1cf52fc/Silicon/Intel/KabylakeSiliconPkg/Pch/Include/Register/PchRegsPmc.h#L34">matched</a> <code>PCI_DEVICE_NUMBER_PCH_PMC</code> (<code>31</code>, which is <code>1f</code> in hex) <a href="https://github.com/tianocore/edk2-platforms/blob/14b8c793e685422bf32ada10acf74e0ff1cf52fc/Silicon/Intel/KabylakeSiliconPkg/Pch/Include/Register/PchRegsPmc.h#L35">and</a> <code>PCI_FUNCTION_NUMBER_PCH_PMC</code> (<code>2</code>) from the BIOS code.</p>

<p>The register offset and the PCIe device numbers also matched the information in the datasheet.</p>

<figure>
	
		
			<img src="https://hazure.neocities.org/images/content/thinkpad-xdci/pmc-pwrmbase.jpg" title="PMC Memory Mapped Registers Summary in the PCH datasheet"/>
		
	
	
		<figcaption>PMC Memory Mapped Registers Summary in the PCH datasheet</figcaption>
	
</figure>

<p>Thus, to change the value of the <code>NST_PG_FDIS_1</code> register, I could read out the PMC memory-mapped register area address from <code>R_PCH_PMC_PWRM_BASE</code> and then overwrite the value at that address in physical memory.</p>

<p>However, I ended up using a different approach.</p>

<p><strong>PMC in kernel</strong>.
While looking into how to work with PMC registers, I also searched through the Linux kernel code to find out whether it interacted with PMC.</p>

<p>As it turned out, it did!
The kernel contained a global pointer to a <code>pmc_core_device</code> <a href="https://elixir.bootlin.com/linux/v6.5/source/drivers/platform/x86/intel/pmc/pltdrv.c#L28">platform device</a>:</p>

<div><div><pre><code><span>static</span> <span>struct</span> <span>platform_device</span> <span>*</span><span>pmc_core_device</span><span>;</span>
</code></pre></div></div>

<p>Whose <a href="https://elixir.bootlin.com/linux/v6.5/source/include/linux/platform_device.h#L258">driver data</a>
contained a pointer to a <code>pmc</code> <a href="https://elixir.bootlin.com/linux/v6.5/source/drivers/platform/x86/intel/pmc/core.h#L346">structure</a>:</p>

<div><div><pre><code><span>struct</span> <span>pmc</span> <span>{</span>
	<span>u64</span> <span>base_addr</span><span>;</span>
	<span>void</span> <span>__iomem</span> <span>*</span><span>regbase</span><span>;</span>	<span>/* Address of memory-mapped PMC reg. area. */</span>
	<span>const</span> <span>struct</span> <span>pmc_reg_map</span> <span>*</span><span>map</span><span>;</span>
	<span>u32</span> <span>*</span><span>lpm_req_regs</span><span>;</span>
<span>};</span>
</code></pre></div></div>

<p>Which contained a pointer to the PMC memory-mapped register area <code>regbase</code>, which, in turn, <a href="https://elixir.bootlin.com/linux/latest/source/drivers/platform/x86/intel/pmc/core.c#L56">could be</a> read or written via <code>readl</code> and <code>writel</code>:</p>

<div><div><pre><code><span>static</span> <span>inline</span> <span>u32</span> <span>pmc_core_reg_read</span><span>(</span><span>struct</span> <span>pmc</span> <span>*</span><span>pmc</span><span>,</span> <span>int</span> <span>reg_offset</span><span>)</span>
<span>{</span>
	<span>return</span> <span>readl</span><span>(</span><span>pmc</span><span>-&gt;</span><span>regbase</span> <span>+</span> <span>reg_offset</span><span>);</span>
<span>}</span>

<span>static</span> <span>inline</span> <span>void</span> <span>pmc_core_reg_write</span><span>(</span><span>struct</span> <span>pmc</span> <span>*</span><span>pmc</span><span>,</span> <span>int</span> <span>reg_offset</span><span>,</span>
				      <span>u32</span> <span>val</span><span>)</span>
<span>{</span>
	<span>writel</span><span>(</span><span>val</span><span>,</span> <span>pmc</span><span>-&gt;</span><span>regbase</span> <span>+</span> <span>reg_offset</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>Thus, instead of reading out the address myself, I decided to reuse the mapping that the kernel provided.</p>

<p><strong>Resetting bit</strong>.
I wrote a small kernel module that hijacks the PMC memory-mapped register area the kernel mapped and changes the <code>NST_PG_FDIS_1</code> value:</p>

<div id="kernel-pmc-off">

  <div><div><pre><code><span>#define SPT_PMC_NST_PG_FDIS_1_OFFSET	0x628
#define SPT_PMC_NST_PG_FDIS_1_BIT_XDCI	BIT(24)
</span>
<span>static</span> <span>void</span> <span>enable_xdci_in_fdis_1</span><span>(</span><span>void</span><span>)</span>
<span>{</span>
	<span>struct</span> <span>pmc</span> <span>*</span><span>pmc</span> <span>=</span> <span>find_pmc</span><span>();</span>

	<span>u32</span> <span>reg_value</span> <span>=</span> <span>readl</span><span>(</span><span>pmc</span><span>-&gt;</span><span>regbase</span> <span>+</span> <span>SPT_PMC_NST_PG_FDIS_1_OFFSET</span><span>);</span>
	<span>pr_err</span><span>(</span><span>&#34;xdci: NST_PG_FDIS_1 is %x</span><span>\n</span><span>&#34;</span><span>,</span> <span>reg_value</span><span>);</span>
	<span>int</span> <span>xdci_bit</span> <span>=</span> <span>!!</span><span>(</span><span>reg_value</span> <span>&amp;</span> <span>SPT_PMC_NST_PG_FDIS_1_BIT_XDCI</span><span>);</span>
	<span>pr_err</span><span>(</span><span>&#34;xdci: XDCI bit is %d</span><span>\n</span><span>&#34;</span><span>,</span> <span>xdci_bit</span><span>);</span>

	<span>reg_value</span> <span>&amp;=</span> <span>~</span><span>SPT_PMC_NST_PG_FDIS_1_BIT_XDCI</span><span>;</span>
	<span>pr_err</span><span>(</span><span>&#34;xdci: writing %x to NST_PG_FDIS_1</span><span>\n</span><span>&#34;</span><span>,</span> <span>reg_value</span><span>);</span>
	<span>writel</span><span>(</span><span>reg_value</span><span>,</span> <span>pmc</span><span>-&gt;</span><span>regbase</span> <span>+</span> <span>SPT_PMC_NST_PG_FDIS_1_OFFSET</span><span>);</span>

	<span>reg_value</span> <span>=</span> <span>readl</span><span>(</span><span>pmc</span><span>-&gt;</span><span>regbase</span> <span>+</span> <span>SPT_PMC_NST_PG_FDIS_1_OFFSET</span><span>);</span>
	<span>pr_err</span><span>(</span><span>&#34;xdci: NST_PG_FDIS_1 is %x</span><span>\n</span><span>&#34;</span><span>,</span> <span>reg_value</span><span>);</span>
<span>}</span>
</code></pre></div>  </div>
</div>






<p>
Another reason I chose the kernel approach is that I was initially thinking about writing a kernel driver for enabling xDCI.
It should, however, be possible to access the PMC memory-mapped registers from userspace via <code>/dev/mem</code> without writing a kernel module.
</p>

<p><strong>Fail</strong>.
Unfortunately, resetting the bit failed:</p>

<div><div><pre><code>xdci: NST_PG_FDIS_1 is 3403ba8
xdci: XDCI bit is 1
xdci: writing 2403ba8 to NST_PG_FDIS_1
xdci: NST_PG_FDIS_1 is 3403ba8
</code></pre></div></div>

<p>The <code>NST_PG_FDIS_1</code> value didn‚Äôt change after an overwrite attempt.</p>

<p>My guess at that point was that the register was locked.
This is a typical case with configuration registers: they might be initially writeable, but then they might get locked during boot.</p>

<p><strong>Register locked</strong>.
After searching through the PCH datasheet, I discovered that there was indeed a way to lock the <code>NST_PG_FDIS_1</code> register via the <code>ST_FDIS_LK</code> <a href="https://github.com/tianocore/edk2-platforms/blob/14b8c793e685422bf32ada10acf74e0ff1cf52fc/Silicon/Intel/KabylakeSiliconPkg/Pch/Include/Register/PchRegsPmc.h#L558">bit</a> (<code>Static Function Disable Lock</code>; bit #31) in the <code>ST_PG_FDIS1</code> <a href="https://github.com/tianocore/edk2-platforms/blob/14b8c793e685422bf32ada10acf74e0ff1cf52fc/Silicon/Intel/KabylakeSiliconPkg/Pch/Include/Register/PchRegsPmc.h#L557">register</a> (<code>Static PG Function Disable 1</code>; offset <code>0x620</code>).</p>

<p>Moreover, it was impossible to unlock the register once locked.
The bit description said: ‚ÄúLock control for all <code>ST_PG_FDIS*</code> and <code>NST_PG_FDIS_*</code> registers. Also <strong>self-locks</strong> when written to <code>1</code>‚Äù.</p>

<figure>
	
		
			<img src="https://hazure.neocities.org/images/content/thinkpad-xdci/pch-pmc-lock.jpg" title="NST_PG_FDIS_1 register and its ST_FDIS_LK bit in the PCH datasheet"/>
		
	
	
		<figcaption>NST_PG_FDIS_1 register and its ST_FDIS_LK bit in the PCH datasheet</figcaption>
	
</figure>

<p><strong>Checking lock</strong>.
To confirm that the register was locked, I wrote the code for checking the value of the <code>ST_FDIS_LK</code> bit in <code>ST_PG_FDIS1</code>:</p>

<div id="kernel-pmc-lock-off">

  <div><div><pre><code><span>#define SPT_PMC_ST_PG_FDIS1_OFFSET      0x620
#define SPT_PMC_ST_PG_FDIS1_BIT_FDIS_LK BIT(31)
</span>
<span>static</span> <span>void</span> <span>check_fdis_lock</span><span>(</span><span>void</span><span>)</span>
<span>{</span>
	<span>struct</span> <span>pmc</span> <span>*</span><span>pmc</span> <span>=</span> <span>find_pmc</span><span>();</span>

	<span>u32</span> <span>reg_value</span> <span>=</span> <span>readl</span><span>(</span><span>pmc</span><span>-&gt;</span><span>regbase</span> <span>+</span> <span>SPT_PMC_ST_PG_FDIS1_OFFSET</span><span>);</span>
	<span>pr_err</span><span>(</span><span>&#34;xdci: ST_PG_FDIS1 is %x</span><span>\n</span><span>&#34;</span><span>,</span> <span>reg_value</span><span>);</span>
	<span>int</span> <span>lock_bit</span> <span>=</span> <span>!!</span><span>(</span><span>reg_value</span> <span>&amp;</span> <span>SPT_PMC_ST_PG_FDIS1_BIT_FDIS_LK</span><span>);</span>
	<span>pr_err</span><span>(</span><span>&#34;xdci: FDIS_LK bit is %d</span><span>\n</span><span>&#34;</span><span>,</span> <span>lock_bit</span><span>);</span>
<span>}</span>
</code></pre></div>  </div>
</div>






<p>The result was:</p>

<div><div><pre><code>xdci: ST_PG_FDIS1 is 80000040
xdci: FDIS_LK bit is 1
</code></pre></div></div>

<p>The lock was enabled.
Thus, I could not change the value of the <code>NST_PG_FDIS_1</code> register to enable xDCI in PMC.
And I could not remove the lock, as the bit self-locked.</p>

<p>This was unfortunate üò¢</p>

<p>At that point, I took a break for lunch.</p>

<p><strong>Surprise</strong>.
After coming back to continue, I ran the code again to remember where I was.</p>

<p>To my surprise, the lock bit was not set anymore üòÆ:</p>

<div><div><pre><code>xdci: ST_PG_FDIS1 is 40
xdci: FDIS_LK bit is 0
</code></pre></div></div>

<p>‚ÄúWhat the hell?‚Äù thought I.</p>

<p>I rebooted the laptop to see what would happen.
The bit was set again üôÉ</p>

<p>It took me some time to figure out what was going on üßê</p>

<p><strong>Suspend</strong>.
As it turned out, the reason for this was suspend.
When I took the lunch break, I closed the lid of my laptop.
And the laptop went into suspend.
And apparently, the wake-up-from-suspend BIOS code did not set the lock bit; only the boot code did üòÖ</p>

<p>
Do we need a CVE for this or something? üòÅ
</p>

<p><strong>Success</strong>.
After waking up the laptop from suspend, I ran the code to enable xDCI in PMC again:</p>

<div><div><pre><code>xdci: NST_PG_FDIS_1 is 3403ba8
xdci: XDCI bit is 1
xdci: writing 2403ba8 to NST_PG_FDIS_1
xdci: NST_PG_FDIS_1 is 2403ba8
</code></pre></div></div>

<p>And it worked! üòÅ</p>

<p>Putting the laptop into suspend to enable xDCI in PMC was weird but good enough for me.</p>

<h4 id="-enabling-xdci-in-psf">üß∂ Enabling xDCI in PSF</h4>

<p>The next step was to enable xDCI in something called PSF.</p>

<p><strong>PSF and IOSF</strong>.
Before reading into the BIOS code responsible for this, I wanted to get at least a high-level idea of what PSF is.</p>

<p>This turned out to be non-trivial: the available information about PSF is extremely scarce.
The best two sources I managed to find were a talk titled &#34;<a href="https://i.blackhat.com/asia-19/Thu-March-28/bh-asia-Goryachy-Ermolov-Intel-Visa-Through-the-Rabbit-Hole.pdf">Intel VISA: Through the Rabbit Hole</a>&#34; by <a href="https://twitter.com/_markel___">Mark Ermolov</a> and <a href="https://twitter.com/h0t_max">Maxim Goryachy</a> and a <a href="https://patents.google.com/patent/EP2778930A2/en">patent EP2778930A2</a> titled &#34;Method and apparatus to trigger and trace on-chip system fabric transactions within the primary scalable fabric&#34;.</p>

<p>
I spent many hours trying to figure out the relationship between PSF, IOSF-P, and IOSF-SB (these last two are mentioned below), but I cannot say that I fully succeeded.
Nevertheless, I tried my best to make this section consistent within my simplified understanding of these terms.
</p>

<table>
	<tbody><tr>
		<th>¬´</th>
		<th>
PSF (Primary Scalable Fabric) is an IP unit that interconnects other IP units within the CPU and the PCH chipset.
PSF is based on a proprietary Intel specification called IOSF (Intel On-Chip System Fabric).
</th>
	</tr>

	<tr>
		<th></th>
		<th>Based on <a href="https://patents.google.com/patent/EP2778930A2/en">patent EP2778930A2</a> and <a href="https://i.blackhat.com/asia-19/Thu-March-28/bh-asia-Goryachy-Ermolov-Intel-Visa-Through-the-Rabbit-Hole.pdf">Intel VISA: Through the Rabbit Hole</a></th>
	</tr>

</tbody></table>

<p>Thus, when BIOS disabled xDCI in PSF, the xDCI IP unit likely got disconnected from the system.</p>



<table>
	<tbody><tr>
		<th>¬´</th>
		<th>
According to IOSF, PSF provides two main (non-debug) interfaces: IOSF-P (IOSF Primary) and IOSF-SB (IOSF Sideband).
IOSF-P is a fast-speed interface that handles data communication between IP units.
IOSF-SB is a low-speed interface used for configuration and error reporting.
</th>
	</tr>

	<tr>
		<th></th>
		<th>Based on <a href="https://patents.google.com/patent/EP2778930A2/en">patent EP2778930A2</a> and <a href="https://i.blackhat.com/asia-19/Thu-March-28/bh-asia-Goryachy-Ermolov-Intel-Visa-Through-the-Rabbit-Hole.pdf">Intel VISA: Through the Rabbit Hole</a></th>
	</tr>

</tbody></table>

<p>As IOSF-SB is the interface that is used for configuration, BIOS probably disabled xDCI via IOSF-SB.</p>

<table>
	<tbody><tr>
		<th>¬´</th>
		<th>
IOSF-SB can be used to configure PSF and other connected IP units.
Each IP unit that can be configured via IOSF-SB is identified by a so-called Port ID.
</th>
	</tr>

	<tr>
		<th></th>
		<th>Based on <a href="https://patents.google.com/patent/EP2778930A2/en">patent EP2778930A2</a> and <a href="https://i.blackhat.com/asia-19/Thu-March-28/bh-asia-Goryachy-Ermolov-Intel-Visa-Through-the-Rabbit-Hole.pdf">Intel VISA: Through the Rabbit Hole</a></th>
	</tr>

</tbody></table>

<p>Based on this, BIOS likely reconfigured PSF via a corresponding Port ID to disconnect the xDCI IP unit.</p>

<p>Having got this high-level understanding, I moved on to reading the BIOS code.</p>

<p>
In reality, I was going back and forth between reading the BIOS code and trying to find out more details about PSF.
But let‚Äôs say that everything happened as I describe for a better narrative üòÑ
</p>

<p><strong>xDCI in PSF</strong>.
To disable xDCI in PSF, BIOS called the <code>PsfDisableXdciDevice</code> function <a href="https://github.com/tianocore/edk2-platforms/blob/14b8c793e685422bf32ada10acf74e0ff1cf52fc/Silicon/Intel/KabylakeSiliconPkg/Pch/LibraryPrivate/PeiDxeSmmPchPsfPrivateLib/PchPsfPrivateLib.c#L88">defined</a> in <code>Pch/Library/Private/PeiDxeSmmPchPsfPrivateLib/PchPsfPrivateLib.c</code>:</p>



<div><div><pre><code><span>VOID</span> <span>PsfDisableXdciDevice</span> <span>(</span><span>VOID</span><span>)</span>
<span>{</span>
  <span>UINT16</span> <span>RegOffset</span><span>;</span>

  <span>if</span> <span>(</span><span>GetPchSeries</span> <span>()</span> <span>==</span> <span>PchLp</span><span>)</span> <span>{</span>
    <span>RegOffset</span> <span>=</span> <span>R_PCH_LP_PCR_PSF2_T0_SHDW_OTG_REG_BASE</span> <span>+</span>
                <span>R_PCH_PCR_PSFX_T0_SHDW_PCIEN</span><span>;</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>RegOffset</span> <span>=</span> <span>R_PCH_H_PCR_PSF2_T0_SHDW_OTG_REG_BASE</span> <span>+</span>
                <span>R_PCH_PCR_PSFX_T0_SHDW_PCIEN</span><span>;</span>
  <span>}</span>

  <span>PchPcrAndThenOr32</span> <span>(</span>
    <span>PID_PSF2</span><span>,</span>
    <span>RegOffset</span><span>,</span>
    <span>~</span><span>0u</span><span>,</span>
    <span>B_PCH_PCR_PSFX_T0_SHDW_PCIEN_FUNDIS</span>
  <span>);</span>
<span>}</span>
</code></pre></div></div>

<p>In <code>PsfDisableXdciDevice</code>, the <code>PchPcrAndThenOr32</code> call was responsible for reconfiguring PSF via the <code>PID_PSF2</code> <a href="https://github.com/tianocore/edk2-platforms/blob/14b8c793e685422bf32ada10acf74e0ff1cf52fc/Silicon/Intel/KabylakeSiliconPkg/Pch/Include/Register/PchRegsPcr.h#L85">Port ID</a> (<code>0xBB</code>; first argument).
Internally, it likely somehow used IOSF-SB.
I left figuring out how exactly it does that for later and first looked at the used register and bit offsets.</p>

<p>For a Sunrise Point-<strong>LP</strong> chipset (<code>PchLp</code> series in the snippet), <code>PsfDisableXdciDevice</code> set the <code>B_PCH_PCR_PSFX_T0_SHDW_PCIEN_FUNDIS</code> <a href="https://github.com/tianocore/edk2-platforms/blob/14b8c793e685422bf32ada10acf74e0ff1cf52fc/Silicon/Intel/KabylakeSiliconPkg/Pch/Include/Register/PchRegsPsf.h#L68">bit</a> (#8) in the <code>R_PCH_PCR_PSFX_T0_SHDW_PCIEN</code> <a href="https://github.com/tianocore/edk2-platforms/blob/14b8c793e685422bf32ada10acf74e0ff1cf52fc/Silicon/Intel/KabylakeSiliconPkg/Pch/Include/Register/PchRegsPsf.h#L61">register</a> (offset <code>0x1C</code>) from the <code>R_PCH_LP_PCR_PSF2_T0_SHDW_OTG_REG_BASE</code> <a href="https://github.com/tianocore/edk2-platforms/blob/14b8c793e685422bf32ada10acf74e0ff1cf52fc/Silicon/Intel/KabylakeSiliconPkg/Pch/Include/Register/PchRegsPsf.h#L310">register area</a> (offset <code>0x600</code>) within the <code>PID_PSF2</code> Port ID.</p>

<p><strong>Checking datasheet</strong>.
I looked up this register in the PCH datasheet.
As the datasheet was intended for Sunrise Point-<strong>H</strong> chipsets, the register offset there was <code>0x21C</code> instead of the expected <code>0x61C</code> (<code>0x600</code> + <code>0x1C</code>).
<code>0x21C</code> did, however, correspond to <code>R_PCH_H_PCR_PSF2_T0_SHDW_OTG_REG_BASE</code> (<code>H</code>, not <code>LP</code>) in the BIOS code.
Bit #8 within this register was still described as <code>USB Dual Role (OTG) Function Disable (FunDis)</code>, as expected.</p>

<figure>
	
		
			<img src="https://hazure.neocities.org/images/content/thinkpad-xdci/psf-otg.jpg" title="PSF OTG register and its Function Disable bit in the PCH datasheet"/>
		
	
	
		<figcaption>PSF OTG register and its Function Disable bit in the PCH datasheet</figcaption>
	
</figure>

<p><strong>PSF2 PCR</strong>.
Now, I wanted to figure out how <code>PchPcrAndThenOr32</code> used IOSF-SB to configure the <code>PID_PSF2</code> Port ID, as I would later need to reproduce this in my kernel module.</p>

<p><code>PchPcrAndThenOr32</code> turned out to be a wrapper around a <code>PchPcrWrite</code> <a href="https://github.com/tianocore/edk2-platforms/blob/14b8c793e685422bf32ada10acf74e0ff1cf52fc/Silicon/Intel/KabylakeSiliconPkg/Pch/Library/PeiDxeSmmPchPcrLib/PchPcrLib.c#L380">call</a>, which <a href="https://github.com/tianocore/edk2-platforms/blob/14b8c793e685422bf32ada10acf74e0ff1cf52fc/Silicon/Intel/KabylakeSiliconPkg/Pch/Library/PeiDxeSmmPchPcrLib/PchPcrLib.c#L267">changed</a> the value of one of the so-called PCRs (<a href="https://github.com/tianocore/edk2-platforms/blob/14b8c793e685422bf32ada10acf74e0ff1cf52fc/Silicon/Intel/KabylakeSiliconPkg/Pch/Include/Register/PchRegsPcr.h#L2">Private Chipset Register</a>s):</p>

<div id="bios-pcr-write-off">

  <div><div><pre><code><span>STATIC</span> <span>EFI_STATUS</span> <span>PchPcrWrite</span> <span>(</span>
  <span>IN</span>  <span>PCH_SBI_PID</span>                       <span>Pid</span><span>,</span>
  <span>IN</span>  <span>UINT16</span>                            <span>Offset</span><span>,</span>
  <span>IN</span>  <span>UINTN</span>                             <span>Size</span><span>,</span>
  <span>IN</span>  <span>UINT32</span>                            <span>InData</span><span>)</span>
<span>{</span>
  <span>// ...</span>

  <span>switch</span> <span>(</span><span>Size</span><span>)</span> <span>{</span>
    <span>case</span> <span>4</span><span>:</span>
      <span>MmioWrite32</span> <span>(</span><span>PCH_PCR_ADDRESS</span> <span>(</span><span>Pid</span><span>,</span> <span>Offset</span><span>),</span> <span>(</span><span>UINT32</span><span>)</span> <span>InData</span><span>);</span>
      <span>break</span><span>;</span>
    <span>// ...</span>
  <span>}</span>

  <span>// ...</span>
<span>}</span>
</code></pre></div>  </div>
</div>






<p>Thus, apparently, changing the PSF2 PCR value was what made PCH reconfigure PSF via IOSF-SB.</p>

<p><strong>PCR addresses</strong>.
Based on the BIOS code, the PCRs were memory-mapped, and the address of each of them was calculated as <code>PCH_PCR_ADDRESS(Pid, Offset)</code>, where <code>Pid</code> is the Port ID and <code>Offset</code> is the offset to a specific PCR.</p>

<p><code>PCH_PCR_ADDRESS</code> was <a href="https://github.com/tianocore/edk2-platforms/blob/14b8c793e685422bf32ada10acf74e0ff1cf52fc/Silicon/Intel/KabylakeSiliconPkg/Pch/Include/Register/PchRegsPcr.h#L40">defined</a> as:</p>

<div><div><pre><code><span>#define PCH_PCR_ADDRESS(Pid, Offset) \
	(PCH_PCR_BASE_ADDRESS | ((UINT8)(Pid) &lt;&lt; 16) | (UINT16)(Offset))
</span></code></pre></div></div>

<p>Where <code>PCH_PCR_BASE_ADDRESS</code> was <a href="https://github.com/tianocore/edk2-platforms/blob/14b8c793e685422bf32ada10acf74e0ff1cf52fc/Silicon/Intel/KabylakeSiliconPkg/Pch/Include/PchReservedResources.h#L34">defined</a> as a constant:</p>

<div><div><pre><code><span>#define PCH_PCR_BASE_ADDRESS 0xFD000000  ///&lt; SBREG MMIO base address
</span></code></pre></div></div>

<p>These calculations aligned with the information about the PSF2 PCR registers in the PCH datasheet:</p>

<table>
	<tbody><tr>
		<th>¬´</th>
		<th>
These registers are within the PCH Private Configuration Space, which is accessible through the PCH Sideband Interface. They can be accessed via (<code>SBREG_BAR</code> + Port ID + Register Offset).
</th>
	</tr>

	<tr>
		<th></th>
		<th>PSF2 PCR Registers Summary, <a href="https://www.intel.com/content/www/us/en/content-details/332691/intel-100-series-chipset-family-platform-controller-hub-pch-datasheet-volume-2.html">Intel 100 Series PCH Datasheet, Volume 2</a></th>
	</tr>

</tbody></table>

<p><strong>SBREG</strong>.
Both the BIOS code and the PCH datasheet referred to the memory region that mapped the PCRs as <code>SBREG</code>.
Based on the name, I figured that <code>SBREG</code> stands for ‚ÄúSideband Registers‚Äù.</p>

<p>Thus, it was logical to assume that overwriting one of the PSF2 PCR registers indeed led to PSF being reconfigured via IOSF-SB;
‚ÄúSB‚Äù there stands for ‚ÄúSideband‚Äù too, after all.</p>

<p>The next step was to implement changing the xDCI-related PSF2 PCR register in my kernel module.</p>

<p><strong>PSF in kernel</strong>.
I searched through the Linux kernel code to see if it accessed any PSF PCRs.
I hoped that I could reuse the kernel mapping of the PSF-related registers, just like I did in the PMC case.</p>

<p>Unfortunately, the kernel did not map this area.</p>

<p>Thus, I had to implement mapping of the PSF2 PCR register area myself.</p>

<p><strong>Mapping PSF2 PCR</strong>.
The Linux kernel provides an <code>ioremap</code> <a href="https://elixir.bootlin.com/linux/v6.5/source/arch/x86/mm/ioremap.c#L343">function</a> for mapping memory-mapped register areas into the kernel virtual address space.
This function accepts the physical address and the size of the area to be mapped and returns the virtual address of the mapping.</p>

<p>To calculate the physical address of the PSF2 PCR register area, my kernel module needed to know the address of the <code>SBREG</code> region.
Here, I had two options:</p>

<ol>
  <li>
    <p>Hardcode the <code>SBREG</code> area address <code>0xFD000000</code> taken from the BIOS code.</p>

    <p>This option had the downside of only working on the systems where <code>SBREG</code> resides at that specific address, like my ThinkPad laptop;</p>
  </li>
  <li>
    <p>Or figure out a way to dynamically determine the <code>SBREG</code> area address.</p>

    <p>This would be the proper way portable to other systems.</p>
  </li>
</ol>

<p>I decided to explore the second option first.</p>

<p><strong>P2SB</strong>.
As it turned out, the <code>SBREG</code> area address <a href="https://github.com/chipsec/chipsec/issues/527">could be read</a> from the PCIe Configuration Space of the so-called P2SB (Primary-to-Sideband Bridge) device.</p>

<p>
I failed to find a good explanation of what P2SB is.
Based on my understanding, this is a device designed specifically for accessing IOSF-SB.
My guess is that its name comes from the fact that accessing memory-mapped I/O or register areas normally happens via IOSF-P, but P2SB converts such accesses to its areas to communication over IOSF-SB.
</p>

<p>As I learned from the <a href="https://lab.whitequark.org/notes/2017-11-08/accessing-intel-ich-pch-gpios/">Accessing Intel ICH/PCH GPIOs</a> article by <a href="https://twitter.com/whitequark">whitequark</a>, P2SB is a PCIe device with the device number <code>31</code> (<code>0x1f</code> in hex) and the function number <code>1</code>.
And the address of the <code>SBREG</code> region is stored split across its two Configuration Space registers: <code>SBREG_BAR</code> and <code>SBREG_BARH</code>.</p>

<p>By default, the P2SB device is hidden, and all reads from its Configuration Space return <code>1</code>s.
However, it‚Äôs possible to unhide it by overwriting the <code>HIDE</code> bit in the <code>P2SBC</code> Configuration Space register.
Even when P2SB is hidden, writes to this register still go through.</p>

<figure>
	
		
			<img src="https://hazure.neocities.org/images/content/thinkpad-xdci/p2sb.jpg" title="P2SB device and its registers in the PCH datasheet"/>
		
	
	
		<figcaption>P2SB device and its registers in the PCH datasheet</figcaption>
	
</figure>

<p><strong>Resetting bit</strong>.
Thus, to dynamically read out the <code>SBREG</code> area address and calculate the PSF2 PCR address based on that, I had to unhide P2SB first.</p>

<p>This seemed like a bit of a hassle, so for now, I decided to just fall back to the simple way of hardcoding the address the same way BIOS did it.</p>

<p>Here‚Äôs the code I came up with for resetting the xDCI-related bit in the corresponding PSF2 PCR:</p>

<div>
  <p>
PCH_PCR_BASE_ADDRESS here is the SBREG address.
</p>
</div>

<div id="kernel-p2sb-off">

  <div><div><pre><code><span>#define PCH_PCR_BASE_ADDRESS 0xFD000000
#define PCH_PCR_ADDRESS(pid, offset) \
	(PCH_PCR_BASE_ADDRESS | ((u8)(pid) &lt;&lt; 16) | (u16)(offset))
#define PID_PSF2 0xBB
</span>
<span>#define PCR_PSF2_T0_SHDW_OTG_REG_BASE		0x600
#define PCR_PSFX_T0_SHDW_PCIEN			0x1C
#define PCR_PSFX_T0_SHDW_PCIEN_FUNDIS_BIT	BIT(8)
</span>
<span>void</span> <span>enable_xdci_in_psf</span><span>(</span><span>void</span><span>)</span>
<span>{</span>
	<span>void</span> <span>__iomem</span> <span>*</span><span>regbase</span> <span>=</span> <span>ioremap</span><span>(</span><span>PCH_PCR_ADDRESS</span><span>(</span><span>PID_PSF2</span><span>,</span> <span>0</span><span>),</span> <span>0x1000</span><span>);</span>

	<span>u32</span> <span>reg_value</span> <span>=</span> <span>readl</span><span>(</span><span>regbase</span> <span>+</span> <span>PCR_PSF2_T0_SHDW_OTG_REG_BASE</span> <span>+</span>
					<span>PCR_PSFX_T0_SHDW_PCIEN</span><span>);</span>
	<span>pr_err</span><span>(</span><span>&#34;xdci: PCR_PSFX_T0_SHDW_PCIEN for OTG is %x</span><span>\n</span><span>&#34;</span><span>,</span> <span>reg_value</span><span>);</span>
	<span>int</span> <span>fundis_bit</span> <span>=</span> <span>!!</span><span>(</span><span>reg_value</span> <span>&amp;</span> <span>PCR_PSFX_T0_SHDW_PCIEN_FUNDIS_BIT</span><span>);</span>
	<span>pr_err</span><span>(</span><span>&#34;xdci: FUNDIS bit is %d</span><span>\n</span><span>&#34;</span><span>,</span> <span>fundis_bit</span><span>);</span>

	<span>reg_value</span> <span>&amp;=</span> <span>~</span><span>PCR_PSFX_T0_SHDW_PCIEN_FUNDIS_BIT</span><span>;</span>
	<span>pr_err</span><span>(</span><span>&#34;xdci: writing %x to PCR_PSFX_T0_SHDW_PCIEN</span><span>\n</span><span>&#34;</span><span>,</span> <span>reg_value</span><span>);</span>
	<span>writel</span><span>(</span><span>reg_value</span><span>,</span> <span>regbase</span> <span>+</span> <span>PCR_PSF2_T0_SHDW_OTG_REG_BASE</span> <span>+</span>
				    <span>PCR_PSFX_T0_SHDW_PCIEN</span><span>);</span>

	<span>reg_value</span> <span>=</span> <span>readl</span><span>(</span><span>regbase</span> <span>+</span> <span>PCR_PSF2_T0_SHDW_OTG_REG_BASE</span> <span>+</span>
				    <span>PCR_PSFX_T0_SHDW_PCIEN</span><span>);</span>
	<span>pr_err</span><span>(</span><span>&#34;xdci: PCR_PSFX_T0_SHDW_PCIEN for OTG is %x</span><span>\n</span><span>&#34;</span><span>,</span> <span>reg_value</span><span>);</span>

	<span>iounmap</span><span>(</span><span>regbase</span><span>);</span>
<span>}</span>
</code></pre></div>  </div>
</div>






<p>
Again, accessing these PCR registers should also be possible from userspace via <code>/dev/mem</code>.
</p>

<p>When I ran the code, I got:</p>

<div><div><pre><code>xdci: PCR_PSFX_T0_SHDW_PCIEN for OTG is ffffffff
xdci: FUNDIS bit is 1
xdci: writing fffffeff to PCR_PSFX_T0_SHDW_PCIEN
xdci: PCR_PSFX_T0_SHDW_PCIEN for OTG is ffffffff
</code></pre></div></div>

<p><strong>Fail</strong>.
From this, I could see that the kernel likely failed to read the register value.
For one thing, the initial value had all bits set, which was suspicious.
And then, after I tried to overwrite the value, the read value was still the same.</p>

<p>This could mean one of two things.
Either the register was completely locked and I could not access it at all.
Or the write itself did go through, but I just could not read the register value.</p>

<p><strong>Unhiding P2SB</strong>.
First, I decided to check if unhiding P2SB would make any difference.
Even though I wanted to avoid implementing this initially, I had to do it after all.</p>

<p>To unhide P2SB, I had to overwrite the <code>HIDE</code> bit (#8) in the <code>P2SBC</code> register (<code>P2SB Control</code>; offset <code>0xE0</code>) within the PCIe Configuration Space of the P2SB device.</p>

<figure>
	
		
			<img src="https://hazure.neocities.org/images/content/thinkpad-xdci/p2sb-control.jpg" title="P2SB Control register and its Hide Device bit in the PCH datasheet"/>
		
	
	
		<figcaption>P2SB Control register and its Hide Device bit in the PCH datasheet</figcaption>
	
</figure>

<p><strong>P2SB in kernel</strong>.
Following the usual path, I checked if the kernel used P2SB to avoid implementing unhiding from scratch myself.</p>

<p>Luckily, it did!
There were quite a few drivers that unhid P2SB for various purposes.</p>

<p>By using the <code>pnd2_edac</code> <a href="https://elixir.bootlin.com/linux/v6.5/source/drivers/edac/pnd2_edac.c#L162">driver</a> as a reference, I came up with the following code that unhides P2SB and attempts to read the PSF2 PCR:</p>

<div>
  <p>
Instead of overwriting just the HIDE bit, this code overwrites the whole byte for simplicity.
</p>
</div>

<div id="kernel-p2sb-unhide-off">

  <div><div><pre><code><span>#define P2SB_DEVFN		PCI_DEVFN(31, 1)
#define P2SB_HIDE_OFFSET	(0xE0 + 1)
</span>
<span>#define P2SB_READ(size, off, ptr) \
	pci_bus_read_config_##size(p2sb_bus, P2SB_DEVFN, off, ptr)
#define P2SB_WRITE(size, off, val) \
	pci_bus_write_config_##size(p2sb_bus, P2SB_DEVFN, off, val)
</span>
<span>static</span> <span>void</span> <span>p2sb_unhide</span><span>(</span><span>void</span><span>)</span>
<span>{</span>
	<span>struct</span> <span>pci_bus</span> <span>*</span><span>p2sb_bus</span> <span>=</span> <span>pci_find_bus</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>);</span>
	<span>P2SB_WRITE</span><span>(</span><span>byte</span><span>,</span> <span>P2SB_HIDE_OFFSET</span><span>,</span> <span>0</span><span>);</span>
	<span>pr_err</span><span>(</span><span>&#34;xdci: P2SB unhidden</span><span>\n</span><span>&#34;</span><span>);</span>
<span>}</span>

<span>static</span> <span>void</span> <span>p2sb_hide</span><span>(</span><span>void</span><span>)</span>
<span>{</span>
	<span>struct</span> <span>pci_bus</span> <span>*</span><span>p2sb_bus</span> <span>=</span> <span>pci_find_bus</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>);</span>
	<span>P2SB_WRITE</span><span>(</span><span>byte</span><span>,</span> <span>P2SB_HIDE_OFFSET</span><span>,</span> <span>1</span><span>);</span>
	<span>pr_err</span><span>(</span><span>&#34;xdci: P2SB hidden</span><span>\n</span><span>&#34;</span><span>);</span>
<span>}</span>

<span>static</span> <span>int</span> <span>__init</span> <span>xdci_enable_init</span><span>(</span><span>void</span><span>)</span>
<span>{</span>
	<span>p2sb_unhide</span><span>();</span>
	<span>check_psf</span><span>();</span>
	<span>p2sb_hide</span><span>();</span>
	<span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre></div>  </div>
</div>






<p>After running it, I got:</p>

<div><div><pre><code>xdci: P2SB unhidden
xdci: PCR_PSFX_T0_SHDW_PCIEN for OTG is ffffffff
xdci: P2SB hidden
</code></pre></div></div>

<p>So, unhiding P2SB did not help: I still could not read the PSF2 PCR.</p>

<p><strong>Unhiding is for IOSF-P</strong>.
Later, I noticed the following note in the description of the <code>HIDE</code> P2SB bit in the datasheet:</p>

<table>
	<tbody><tr>
		<th>¬´</th>
		<th>
When this bit is set, the P2SB will return 1s on any PCI Configuration Read on <strong>IOSF-P</strong>.
All other transactions, including PCI Configuration Writes, are unaffected by this.
This does not affect reads performed on the <strong>IOSF-SB</strong> interface.
</th>
	</tr>

</tbody></table>

<p>When I first read this, I didn‚Äôt pay attention to the mentions of IOSF-P and IOSF-SB.</p>

<p>But now it made sense: unhiding P2SB made no difference, as I was reading the PSF2 PCR through IOSF-SB.
Unhiding P2SB was only good for reading the data from the P2SB PCIe Configuration Space, like the <code>SBREG_BAR</code> register or the <code>HIDE</code> bit.</p>

<p>Thus, something else prevented me from reading the PSF register.</p>

<p><strong>PSF disconnected</strong>.
After a lot of tinkering, I discovered the reason: PSF was simply disconnected from the Sideband interface.
This was done by the <code>RemoveSidebandAccess</code> function <a href="https://github.com/tianocore/edk2-platforms/blob/14b8c793e685422bf32ada10acf74e0ff1cf52fc/Silicon/Intel/KabylakeSiliconPkg/Pch/LibraryPrivate/PeiDxeSmmPchInitCommonLib/PchInitCommon.c#L284">defined</a> in <code>Pch/Library/Private/PeiDxeSmmPchInitCommonLib/PchInitCommon.c</code>:</p>

<div>
  <p>
This code is public as well.
</p>
</div>

<div id="bios-remove-sideband-off">

  <div><div><pre><code><span>VOID</span> <span>RemoveSidebandAccess</span> <span>(</span><span>VOID</span><span>)</span>
<span>{</span>
  <span>UINTN</span>                                 <span>P2sbBase</span><span>;</span>
  <span>BOOLEAN</span>                               <span>P2sbOrgStatus</span><span>;</span>

  <span>P2sbBase</span> <span>=</span> <span>MmPciBase</span> <span>(</span><span>DEFAULT_PCI_BUS_NUMBER_PCH</span><span>,</span>
                        <span>PCI_DEVICE_NUMBER_PCH_P2SB</span><span>,</span>
                        <span>PCI_FUNCTION_NUMBER_PCH_P2SB</span><span>);</span>
  <span>PchRevealP2sb</span> <span>(</span><span>P2sbBase</span><span>,</span> <span>&amp;</span><span>P2sbOrgStatus</span><span>);</span>

  <span>// Disable Sideband access for PSF and other things.</span>
  <span>MmioOr32</span> <span>(</span><span>P2sbBase</span> <span>+</span> <span>R_PCH_P2SB_EPMASK5</span><span>,</span>
            <span>BIT29</span> <span>|</span> <span>BIT28</span> <span>|</span> <span>BIT27</span> <span>/* PSF */</span> <span>|</span>
            <span>BIT26</span> <span>|</span> <span>BIT17</span> <span>|</span> <span>BIT16</span> <span>|</span> <span>BIT10</span> <span>|</span> <span>BIT1</span><span>);</span>

  <span>// ...</span>

  <span>// Lock the EPMASK registers.</span>
  <span>MmioOr8</span> <span>(</span><span>P2sbBase</span> <span>+</span> <span>R_PCH_P2SB_E0</span> <span>+</span> <span>2</span><span>,</span> <span>BIT1</span><span>);</span>

  <span>if</span> <span>(</span><span>!</span><span>P2sbOrgStatus</span><span>)</span> <span>{</span>
    <span>PchHideP2sb</span> <span>(</span><span>P2sbBase</span><span>);</span>
  <span>}</span>
<span>}</span>
</code></pre></div>  </div>
</div>






<p><code>RemoveSidebandAccess</code> did two things besides unhiding and hiding P2SB:</p>

<ol>
  <li>
    <p>Disconnected several Port IDs, including <code>PID_PSF2</code>, via the P2SB <code>EPMASK5</code> <a href="https://github.com/tianocore/edk2-platforms/blob/14b8c793e685422bf32ada10acf74e0ff1cf52fc/Silicon/Intel/KabylakeSiliconPkg/Pch/Include/Register/PchRegsP2sb.h#L98">register</a>
(offset <code>0xC4</code>; ‚Äú<code>Endpoint Mask 5</code>: One hot mask for disabling IOSF-SB endpoint IDs 191-160‚Äù);</p>
  </li>
  <li>
    <p>Locked the <code>EPMASK</code> registers via the <code>MASKLOCK</code> bit (‚Äú<code>Endpoint Mask Lock</code>: Locks the value of the <code>EPMASK[0-7]</code> registers. Once this value is written to a one, it may only be cleared by a reset.‚Äù; bit #17) of the <code>P2SBC</code> <a href="https://github.com/tianocore/edk2-platforms/blob/14b8c793e685422bf32ada10acf74e0ff1cf52fc/Silicon/Intel/KabylakeSiliconPkg/Pch/Include/Register/PchRegsP2sb.h#L127">register</a> (offset <code>0xE0</code>).</p>
  </li>
</ol>

<p>
<code>BIT27</code> in the code corresponds to the <code>0xBB</code> Port ID, as <code>EPMASK5</code> counts Port IDs from <code>160</code>.
</p>

<p>
The <code>MASKLOCK</code> bit wasn‚Äôt mentioned in the PCH datasheet that I had, but it was <a href="https://edc.intel.com/content/www/us/en/design/products-and-solutions/processors-and-chipsets/comet-lake-u/intel-400-series-chipset-on-package-platform-controller-hub-register-database/p2sb-control-p2sbc-offset-e0/">referenced</a> on the Intel website, albeit for a different chipset version.
</p>

<figure>
	
		
			<img src="https://hazure.neocities.org/images/content/thinkpad-xdci/psf-epmask5.jpg" title="EPMASK5 register in the PCH datasheet"/>
		
	
	
		<figcaption>EPMASK5 register in the PCH datasheet</figcaption>
	
</figure>

<p><strong>Checking disconnect</strong>.
To confirm my finding, I wrote the code to check the values of the <code>EPMASK5</code> and <code>P2SBC</code> registers and, just in case, to try overwriting them:</p>

<div id="kernel-p2sb-epmask-off">

  <div><div><pre><code><span>#define PID_PSF2		0xBB
</span>
<span>#define P2SB_EPMASK5_OFFSET	0xC4
#define P2SB_EPMASK5_PSF2_BIT	BIT(PID_PSF2 - 160)
</span>
<span>#define P2SB_MASKLOCK_OFFSET	(0xE0 + 2)
#define P2SB_MASKLOCK_BIT	BIT(1)
</span>
<span>void</span> <span>check_epmask</span><span>(</span><span>void</span><span>)</span>
<span>{</span>
	<span>struct</span> <span>pci_bus</span> <span>*</span><span>p2sb_bus</span> <span>=</span> <span>pci_find_bus</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>);</span>

	<span>u32</span> <span>epmask5</span><span>;</span>
	<span>P2SB_READ</span><span>(</span><span>dword</span><span>,</span> <span>P2SB_EPMASK5_OFFSET</span><span>,</span> <span>&amp;</span><span>epmask5</span><span>);</span>
	<span>pr_err</span><span>(</span><span>&#34;xdci: EPMASK5 is %x</span><span>\n</span><span>&#34;</span><span>,</span> <span>epmask5</span><span>);</span>
	<span>int</span> <span>epmask5_psf2_bit</span> <span>=</span> <span>!!</span><span>(</span><span>epmask5</span> <span>&amp;</span> <span>P2SB_EPMASK5_PSF2_BIT</span><span>);</span>
	<span>pr_err</span><span>(</span><span>&#34;xdci: PSF2 bit is %d</span><span>\n</span><span>&#34;</span><span>,</span> <span>epmask5_psf2_bit</span><span>);</span>

	<span>u8</span> <span>masklock_byte</span><span>;</span>
	<span>P2SB_READ</span><span>(</span><span>byte</span><span>,</span> <span>P2SB_MASKLOCK_OFFSET</span><span>,</span> <span>&amp;</span><span>masklock_byte</span><span>);</span>
	<span>int</span> <span>masklock_bit</span> <span>=</span> <span>!!</span><span>(</span><span>masklock_byte</span> <span>&amp;</span> <span>P2SB_MASKLOCK_BIT</span><span>);</span>
	<span>pr_err</span><span>(</span><span>&#34;xdci: MASKLOCK is %d</span><span>\n</span><span>&#34;</span><span>,</span> <span>masklock_bit</span><span>);</span>

	<span>masklock_byte</span> <span>&amp;=</span> <span>~</span><span>P2SB_MASKLOCK_BIT</span><span>;</span>
	<span>pr_err</span><span>(</span><span>&#34;xdci: writing 0 to MASKLOCK</span><span>\n</span><span>&#34;</span><span>);</span>
	<span>P2SB_WRITE</span><span>(</span><span>byte</span><span>,</span> <span>P2SB_MASKLOCK_OFFSET</span><span>,</span> <span>masklock_byte</span><span>);</span>

	<span>P2SB_READ</span><span>(</span><span>byte</span><span>,</span> <span>P2SB_MASKLOCK_OFFSET</span><span>,</span> <span>&amp;</span><span>masklock_byte</span><span>);</span>
	<span>masklock_bit</span> <span>=</span> <span>!!</span><span>(</span><span>masklock_byte</span> <span>&amp;</span> <span>P2SB_MASKLOCK_BIT</span><span>);</span>
	<span>pr_err</span><span>(</span><span>&#34;xdci: MASKLOCK is %d</span><span>\n</span><span>&#34;</span><span>,</span> <span>masklock_bit</span><span>);</span>

	<span>epmask5</span> <span>&amp;=</span> <span>~</span><span>P2SB_EPMASK5_PSF2_BIT</span><span>;</span>
	<span>pr_err</span><span>(</span><span>&#34;xdci: writing 0 to PSF2 bit</span><span>\n</span><span>&#34;</span><span>);</span>
	<span>P2SB_WRITE</span><span>(</span><span>dword</span><span>,</span> <span>P2SB_EPMASK5_OFFSET</span><span>,</span> <span>epmask5</span><span>);</span>

	<span>P2SB_READ</span><span>(</span><span>dword</span><span>,</span> <span>P2SB_EPMASK5_OFFSET</span><span>,</span> <span>&amp;</span><span>epmask5</span><span>);</span>
	<span>epmask5_psf2_bit</span> <span>=</span> <span>!!</span><span>(</span><span>epmask5</span> <span>&amp;</span> <span>P2SB_EPMASK5_PSF2_BIT</span><span>);</span>
	<span>pr_err</span><span>(</span><span>&#34;xdci: PSF2 bit is %d</span><span>\n</span><span>&#34;</span><span>,</span> <span>epmask5_psf2_bit</span><span>);</span>
<span>}</span>

<span>static</span> <span>int</span> <span>__init</span> <span>xdci_enable_init</span><span>(</span><span>void</span><span>)</span>
<span>{</span>
	<span>p2sb_unhide</span><span>();</span>
	<span>check_epmask</span><span>();</span>
	<span>p2sb_hide</span><span>();</span>
	<span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre></div>  </div>
</div>






<p>The result was:</p>

<div><div><pre><code>xdci: P2SB unhidden
xdci: EPMASK5 is 3c030402
xdci: PSF2 bit is 1
xdci: MASKLOCK is 1
xdci: writing 0 to MASKLOCK
xdci: MASKLOCK is 1
xdci: writing 0 to PSF2 bit
xdci: PSF2 bit is 1
xdci: P2SB hidden
</code></pre></div></div>

<p><strong>Fail</strong>.
So, the <code>PID_PSF2</code> IOSF-SB Port ID was disconnected, the register responsible for this was locked, and I could not unlock it.</p>

<p>Thus, I could not enable xDCI in PSF üò•</p>

<p>At that point, I decided that I had sunk enough time into this rabbit hole and moved on to trying a different approach.</p>

<p>
I nevertheless enjoyed learning about PCH, PMC, and PSF, and I don‚Äôt regret the time spent on this üòå
</p>

<p>
In the BIOS code, <code>RemoveSidebandAccess</code> is called at the end of the PEI stage by <code>PchOnEndOfPei</code> and only if the <code>SbAccessUnlock</code> bit is not set in <code>P2sbConfig</code>.
Thus, in theory, it might be possible to unlock IOSF-SB access to PSF2 by somehow changing the value of <code>SbAccessUnlock</code>, putting the laptop into suspend, and then waking it up.
I, however, didn‚Äôt explore this idea in detail.
</p>

<h3 id="-enabling-xdci-via-nvram">üíæ Enabling xDCI via NVRAM</h3>

<p>Having failed to implement a software solution, I wanted to at least figure out a way to enable xDCI without breaking the TPM and, more importantly, without requiring a Boot Guard bypass.
Such an approach could be applied to other laptops besides the vulnerable ThinkPad Carbon X1 6th Gen.</p>

<p><strong>Avoiding Boot Guard</strong>.
The change that would piss off Boot Guard was the <code>Advanced</code> page patch I had applied.
However, I only needed the <code>Advanced</code> page change the value of the <code>xDCI Support</code> setting.
So, perhaps I could somehow enable this setting without unlocking the <code>Advanced</code> page?</p>

<p>As the values of BIOS settings are preserved across reboots, they must be stored somewhere.
And changing these values through BIOS Setup does not trigger Boot Guard.</p>

<p>So, the idea that I had was to try directly changing the value for the <code>xDCI Support</code> setting.</p>

<p>For this, I had to figure out where the BIOS settings values are stored.</p>

<p><strong>NVRAM</strong>.
As it turned out, modern UEFI-compatible BIOS stores the values of its settings on the very same SPI chip as the BIOS binary, in the NVRAM region.</p>

<table>
	<tbody><tr>
		<th>¬´</th>
		<th>
NVRAM (Non-Volatile Random-Access Memory) is a random-access memory that retains data without applied power.
NVRAM is where BIOS stores its configuration data, including BIOS settings.
Legacy BIOS relied on a separate volatile RAM chip that was powered by a CMOS (Complementary Metal‚ÄìOxide‚ÄìSemiconductor) battery when the main power was turned off.
In modern UEFI-compatible motherboards, a separate chip is not present.
Instead, the configuration data is stored in the so-called NVRAM region on the SPI chip alongside other UEFI data.
</th>
	</tr>

	<tr>
		<th></th>
		<th>Based on <a href="https://en.wikipedia.org/wiki/Nonvolatile_BIOS_memory">Non-volatile BIOS memory</a>, Wikipedia</th>
	</tr>

</tbody></table>

<p>Naturally, the value of the <code>xDCI Support</code> setting should be stored in NVRAM as well.</p>

<p>So, to change the setting value, I had to figure out where exactly on the SPI chip it was located.</p>

<p><strong>IFR</strong>.
Searching online revealed that a UEFI-compatible BIOS stores the description of its configuration settings in a special format called IFR.</p>

<table>
	<tbody><tr>
		<th>¬´</th>
		<th>
UEFI Internal Form Representation (IFR) is a binary format that the UEFI Human Interface Infrastructure (HII) subsystem uses to store strings, forms, images, animations, and other things that are eventually supposed to end up on the BIOS Setup screen.
</th>
	</tr>

	<tr>
		<th></th>
		<th>What is this IFR thing about?, <a href="https://github.com/LongSoft/IFRExtractor-RS">IFRExtractor-RS</a></th>
	</tr>

</tbody></table>

<p>Thus, my plan was to check IFR to hopefully find the location of the <code>xDCI Support</code> setting.</p>

<p><strong>Extracting IFR</strong>.
I downloaded and built the <code>ifrextractor</code> <a href="https://github.com/LongSoft/IFRExtractor-RS.git">tool</a>:</p>

<div><div><pre><code><span>$ </span>git clone https://github.com/LongSoft/IFRExtractor-RS.git
<span>$ </span><span>cd </span>IFRExtractor-RS
<span>$ </span>cargo build
</code></pre></div></div>

<p>And extracted the information about the UEFI configuration settings from the <code>Setup</code> module:</p>

<div><div><pre><code><span>$ </span>./ifrextractor ./Setup.bin all
Extracting all UEFI HII form packages using all UEFI HII string packages
</code></pre></div></div>

<p>Inside a produced <code>Setup.bin.1.0.en-US.ifr.txt</code> file, I found the following:</p>

<div><div><pre><code>VarStoreEfi Guid: 4570B7F1-ADE8-4943-8DC3-406472842384, VarStoreId: 0x5,
  Attributes: 0x7, Size: 0x75F, Name: &#34;PchSetup&#34;

OneOf Prompt: &#34;xDCI Support&#34;, Help: &#34;Enable/Disable xDCI (USB OTG Device).&#34;,
  QuestionFlags: 0x10, QuestionId: 0x4D4, VarStoreId: 0x5,
  VarOffset: 0x40, Flags: 0x10, Size: 8, Min: 0x0, Max: 0x1, Step: 0x0
</code></pre></div></div>

<p>From this, I could see that the value of the <code>xDCI Support</code> BIOS setting was stored at offset <code>0x40</code> within the <code>PchSetup</code> storage area (note the matching <code>VarStoreId</code>).</p>

<p><strong>efivarfs</strong>.
While looking for information about how UEFI stores the values of IFR entries, I stumbled upon <code>efivarfs</code>.</p>

<table>
	<tbody><tr>
		<th>¬´</th>
		<th>
<code>efivarfs</code> is a filesystem in the Linux kernel that enables users to create, delete, and modify UEFI variables.
<code>efivarfs</code> is typically and automatically mounted in <code>/sys/firmware/efi/efivars</code>.
</th>
	</tr>

	<tr>
		<th></th>
		<th><a href="https://wiki.gentoo.org/wiki/Efivarfs">efivarfs</a>, Gentoo Wiki</th>
	</tr>

</tbody></table>

<p><code>efivarfs</code> allowed me to verify whether the offset for <code>xDCI Support</code> I had found was correct.</p>

<p>Upon checking the <code>efivarfs</code> contents, I saw that there was an entry for each UEFI storage area, including one for <code>PchSetup</code>:</p>

<div><div><pre><code><span>$ </span><span>ls</span> /sys/firmware/efi/efivars/
...
PchSetup-4570b7f1-ade8-4943-8dc3-406472842384
...
</code></pre></div></div>

<p>Based on the <code>efivars</code> <a href="https://docs.kernel.org/filesystems/efivarfs.html">documentation</a>, the first 4 bytes of an <code>efivarfs</code> entry is the header.
Thus, the <code>xDCI Support</code> value should have been at the offset <code>0x44</code> within the entry for <code>PchSetup</code>.</p>

<p>Without xDCI enabled, the value at this offset was <code>00</code>:</p>

<div><div><pre><code><span>$ </span>xxd /sys/firmware/efi/efivars/PchSetup-4570b7f1-ade8-4943-8dc3-406472842384
...
00000040: 0100 0000 0000 0001 0101 0101 0101 0100  ................
...
</code></pre></div></div>

<p>But after enabling xDCI via the <code>Advanced</code> page in BIOS, the value changed to <code>01</code>, as expected:</p>

<div><div><pre><code><span>$ </span>xxd /sys/firmware/efi/efivars/PchSetup-4570b7f1-ade8-4943-8dc3-406472842384
...
00000040: 0100 0000 0100 0001 0101 0101 0101 0100  ................
...
</code></pre></div></div>

<p><strong>Can‚Äôt change from userspace</strong>.
Out of curiosity, I tried changing the value from userspace by overwriting the <code>/sys/firmware/efi/efivars/PchSetup-...</code> file.</p>

<p>The <code>PchSetup-...</code> file had the Immutable attribute set:</p>

<div><div><pre><code><span>$ </span>lsattr /sys/firmware/efi/efivars/PchSetup-...
<span>----i---------------</span> /sys/firmware/efi/efivars/PchSetup-...
</code></pre></div></div>

<p>So, I removed it via <code>sudo chattr -i</code> and then tried to overwrite the file‚Äôs contents.</p>

<p>Unfortunately, this produced a <code>Read-only file system</code> error.
After searching through the Linux kernel code for <code>efivarfs</code>, I found out that this error <a href="https://elixir.bootlin.com/linux/v6.5/source/drivers/firmware/efi/efi.c#L973">mapped</a> to <code>EFI_WRITE_PROTECTED</code> being returned from UEFI.</p>

<p>Essentially, BIOS rejected the attempt to overwrite <code>PchSetup</code>.
Too bad, but not surprising.</p>

<p>
Interestingly, the <code>Attributes</code> value <code>0x7</code> for <code>PchSetup</code> in IFR includes the <code>EFI_VARIABLE_RUNTIME_ACCESS</code> <a href="https://uefi.org/sites/default/files/resources/UEFI_Spec_2_10_Aug29.pdf">flag</a> (<code>0x4</code>).
This should supposedly mean that the <code>PchSetup</code> value can be changed after boot.
Thus, it‚Äôs unclear to me why changing it via <code>efivarfs</code> fails.
I also tried changing the value from EFI Shell via <a href="https://github.com/chipsec/chipsec">chipsec</a>, but that produced the same error.
</p>

<p><strong>Patching BIOS</strong>.
Returning to my initial plan, I wanted to try changing the value of <code>xDCI Support</code> in the NVRAM region without unlocking the <code>Advanced</code> page.</p>

<p>Instead of figuring out where the NVRAM region was located on the SPI chip, I took a shortcut.</p>

<p>I took the original BIOS image I had read via the SPI programmer (without the <code>Advanced</code> page and the TPM patches) and searched for the <code>0100 0000 0000 0001 0101 0101 0101 0100</code> byte sequence (the one at offset <code>0x40</code> within <code>PchSetup</code>) with a hex editor.
Luckily, this produced only a single hit.</p>

<figure>
	
		
			<img src="https://hazure.neocities.org/images/content/thinkpad-xdci/bios-bytes.jpg" title="Searching for xDCI-related byte sequence"/>
		
	
	
		<figcaption>Searching for xDCI-related byte sequence</figcaption>
	
</figure>

<p>I patched the sequence to enable the xDCI-related bit, flashed the image back to the SPI chip, and booted the laptop.</p>

<p><strong>Success</strong>.
Surprisingly, this worked right away!
After booting, I could see the xDCI device and the <code>dwc3</code> driver was loaded ü•≥</p>

<p><strong>Done</strong>.
With this, I concluded my attempts to enable xDCI.
The NVRAM patching approach still required reflashing the SPI chip, but at least it didn‚Äôt break the TPM and needed no Boot Guard bypass.
I decided that this was good enough and moved on.</p>

<p>
Initially, I patched NVRAM with BIOS version 1.37 and later updated it to 1.61.
As the updater preserves the BIOS settings values, I did not have to apply the patch again.
</p>

<h2 id="-using-xdci">üöÄ Using xDCI</h2>

<p>Once I had xDCI working, I could finally test it with a few USB emulation tools that are based on the Linux kernel USB Gadget subsystem.</p>

<p>
All of the examples below assume that xDCI is enabled through BIOS, the role is switched to <code>device</code> via <code>intel_xhci_usb_sw-role-switch</code>, and a <code>VBUS</code>-disconnected cable connects the xDCI-enabled port to a USB host.
</p>

<p>
The usage examples listed here are technically not specific to xDCI.
Everything would work the same regardless of the used UDC (minding the fact that some UDCs don‚Äôt support certain hardware features).
Nevertheless, I will show these examples to illustrate the possibilities of using xDCI.
</p>

<h3 id="-legacy-gadget-drivers">üñ± Legacy gadget drivers</h3>

<p>The Linux kernel USB Gadget subsystem provides a variety of interfaces for emulating USB devices.</p>

<p><strong>Legacy gadget drivers</strong>.
One of them is the <a href="https://elixir.bootlin.com/linux/latest/source/drivers/usb/gadget/legacy">legacy gadget drivers</a>.
These are Linux kernel modules that emulate USB devices when loaded.
Most of them emulate a USB device of a specific class, like a HID (Human Interface Device) or a mass storage drive.</p>

<p>
These gadget drivers are called ‚Äúlegacy‚Äù because they existed before the introduction of the so-called <a href="https://lwn.net/Articles/395712/">‚Äúcomposite‚Äù framework</a>.
Each legacy gadget driver implements a single gadget function (USB class).
In turn, the composite framework allows combining multiple gadget functions within the same device.
Nowadays, most legacy gadget drivers (except for <a href="https://elixir.bootlin.com/linux/latest/source/drivers/usb/gadget/legacy/inode.c">GadgetFS</a> and <a href="https://github.com/xairy/raw-gadget">Raw Gadget</a>) are just wrappers for the gadget function implementations provided by the composite framework.
</p>

<p>
The <code>g_zero</code> module that I used for the <a href="#-checking-xdci">initial xDCI testing</a> is one of the legacy gadget drivers.
</p>

<p><strong>Mass storage gadget</strong>.
I decided to try emulating a mass storage drive through xDCI via one of the legacy gadget drivers.</p>

<p>For this, the USB Gadget subsystem offers the <code>g_mass_storage</code> module.
This module accepts an argument that specifies the filesystem image that will be exposed to the USB host.
Once loaded, this module emulates a USB drive through the first UDC it finds on the system (just like <code>g_zero</code>).</p>

<p>I prepared a floppy disk‚Äìsized FAT image:</p>

<div><div><pre><code><span>$ </span><span>dd </span><span>if</span><span>=</span>/dev/zero <span>of</span><span>=</span>disk.img <span>bs</span><span>=</span>512 <span>count</span><span>=</span>2880
<span>$ </span>mkfs.fat ./disk.img
<span>$ </span><span>sudo mkdir</span> /mnt/drive
<span>$ </span><span>sudo </span>mount ./disk.img /mnt/drive <span>-o</span> loop
<span>$ </span><span>echo</span> <span>&#34;Hi from xDCI&#34;</span> | <span>sudo tee</span> /mnt/drive/file.txt
<span>$ </span><span>sudo </span>umount /mnt/drive
</code></pre></div></div>

<p>And loaded the <code>g_mass_storage</code> module with the created <code>disk.img</code> as the <code>file</code> argument to start emulating a USB mass storage device:</p>

<div><div><pre><code><span>$ </span><span>sudo </span>modprobe g_mass_storage <span>file</span><span>=</span>./disk.img <span>stall</span><span>=</span>0
</code></pre></div></div>

<p><strong>Worked</strong>.
The emulation worked just as expected.
The drive got auto-mounted on the USB host, and I could see the contents of <code>file.txt</code> ü•≥</p>

<figure>
	
		
			<img src="https://hazure.neocities.org/images/content/thinkpad-xdci/example-ms.jpg" title="Emulating mass storage drive via xDCI"/>
		
	
	
		<figcaption>Emulating mass storage drive via xDCI</figcaption>
	
</figure>

<p>A nifty way to transfer files from an xDCI-enabled laptop in case you forgot to bring a USB drive üòÑ</p>

<p>
To stop emulating the USB drive, unload the module:
</p>

<div><div><pre><code><span>$ </span><span>sudo </span>modprobe <span>-r</span> g_mass_storage
</code></pre></div></div>

<p>
It should also be possible to emulate a USB device with multiple different classes by using the <a href="https://lwn.net/Articles/395712/">composite framework</a> with xDCI.
However, I didn‚Äôt try this myself, so I won‚Äôt provide a usage example.
</p>

<h3 id="-raw-gadget">ü§ñ Raw Gadget</h3>

<p>The next thing I wanted to test was <a href="https://github.com/xairy/raw-gadget">Raw Gadget</a>.</p>

<p>As I mentioned in the <a href="#-introduction">introduction</a>, Raw Gadget is a Linux kernel module for emulating highly customizable USB devices.
Technically, it‚Äôs one of the legacy gadget drivers (as it‚Äôs not based on the composite framework), but it provides much greater flexibility than emulating a USB device with a specific class.</p>

<p>
Running Raw Gadget with xDCI for the first time was very exciting, as my desire to work on Raw Gadget on my laptop without external hardware was what conceived this project üòÑ
</p>

<p><strong>Keyboard.</strong>
I downloaded, built, and loaded the Raw Gadget module on my laptop:</p>

<div><div><pre><code><span>$ </span>git clone https://github.com/xairy/raw-gadget.git
<span>$ </span><span>cd </span>raw-gadget/raw_gadget/
<span>$ </span>make
<span>$ </span>./insmod.sh
</code></pre></div></div>
<p>And then built and ran the example to emulate a keyboard via xDCI:</p>

<div><div><pre><code><span>$ </span><span>cd </span>raw-gadget/examples/
<span>$ </span>make
<span>$ </span><span>sudo</span> ./keyboard dwc3.1.auto dwc3-gadget
</code></pre></div></div>

<p><strong>Fail</strong>.
Unfortunately, the emulation failed.
The emulation code was not able to complete the enumeration process and froze when handling the <code>SET_CONFIGURATION</code> USB request üò¢:</p>

<div id="raw-gadget-fail-off">

  <div><div><pre><code><span>$ </span><span>sudo</span> ./keyboard dwc3.1.auto dwc3-gadget
event: connect, length: 0
...
event: control, length: 8
  bRequestType: 0x0 <span>(</span>OUT<span>)</span>, bRequest: 0x9, wValue: 0x1, wIndex: 0x0, wLength: 0
  <span>type</span> <span>=</span> USB_TYPE_STANDARD
  req <span>=</span> USB_REQ_SET_CONFIGURATION
ep0: ep_int_in enabled: 1
ep0: spawned ep_int_in thread
ep0: transferred 0 bytes <span>(</span>out<span>)</span>
<span># Froze here...</span>
</code></pre></div>  </div>
  <div>
  <p>
Click the switch to see the full log.
</p>
</div>

</div>






<p>
<code>SET_CONFIGURATION</code> is a USB request that the USB host sends to the USB device once the device completes the enumeration process
(the process during which the host asks the device for its descriptors to know what kind of device was plugged in).
</p>

<p><strong>Issue</strong>.
After debugging and a lengthy <a href="https://lore.kernel.org/linux-usb/CA+fCnZcQSYy63ichdivAH5-fYvN2UMzTtZ--h=F6nK0jfVou3Q@mail.gmail.com/T/#u">discussion</a> with the Linux kernel maintainers, I figured out the issue.</p>

<p>As it turned out, <code>dwc3</code> and several other UDC drivers incorrectly used the Gadget subsystem API.
They assumed that a 0-length control request like SET_CONFIGURATION can be acknowledged immediately without the gadget driver‚Äôs confirmation.
And Raw Gadget did not expect that.</p>

<p>
I won‚Äôt go deep into explaining the issue, as this would require covering a lot of the USB protocol and the Gadget subsystem internals.
If you‚Äôre interested in the details, see the <a href="https://lore.kernel.org/linux-usb/CA+fCnZcQSYy63ichdivAH5-fYvN2UMzTtZ--h=F6nK0jfVou3Q@mail.gmail.com/T/#u">discussion</a> and the <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=3551ff7c5cfff4dc27fdcd14fa286edc08d78088">documentation patch</a>.
</p>

<p><strong>Fix</strong>.
A proper fix for this issue would be to change the behavior of all the affected UDC drivers.
However, after looking into this, I decided that fixing all of them would require quite a lot of work.</p>

<div>
  <p>
Both fixes are now in the mainline kernel.
</p>
</div>

<p>So, instead, I just applied a <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=cf9f7a6ee7b1f53f9ae13da55585b7d16aee2460">workaround patch</a> to Raw Gadget.
And I noticed that GadgetFS also suffered from this issue, so I <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=fc85c59b85d111f51b58ecf08485fa74ac5471cd">fixed it up</a> as well.</p>

<p><strong>Success</strong>.
Once I applied the workaround, the keyboard was emulated successfully ü•≥:</p>

<div id="raw-gadget-success-off">

  <div><div><pre><code><span>$ </span><span>sudo</span> ./keyboard dwc3.1.auto dwc3-gadget
event: connect, length: 0
...
event: control, length: 8
  bRequestType: 0x0 <span>(</span>OUT<span>)</span>, bRequest: 0x9, wValue: 0x1, wIndex: 0x0, wLength: 0
  <span>type</span> <span>=</span> USB_TYPE_STANDARD
  req <span>=</span> USB_REQ_SET_CONFIGURATION
ep0: ep_int_in enabled: 1
ep0: spawned ep_int_in thread
ep0: transferred 0 bytes <span>(</span>out<span>)</span>
event: control, length: 8
  bRequestType: 0x80 <span>(</span>IN<span>)</span>, bRequest: 0x6, wValue: 0x303, wIndex: 0x409, wLength: 255
  <span>type</span> <span>=</span> USB_TYPE_STANDARD
  req <span>=</span> USB_REQ_GET_DESCRIPTOR
  desc <span>=</span> USB_DT_STRING
ep0: transferred 4 bytes <span>(</span><span>in</span><span>)</span>
...
event: control, length: 8
  bRequestType: 0x21 <span>(</span>OUT<span>)</span>, bRequest: 0x9, wValue: 0x200, wIndex: 0x0, wLength: 1
  <span>type</span> <span>=</span> USB_TYPE_CLASS
  req <span>=</span> HID_REQ_SET_REPORT
ep0: transferred 1 bytes <span>(</span>out<span>)</span>
ep_int_in: key down: 8
ep_int_in: key up: 8
ep_int_in: key down: 8
ep_int_in: key up: 8
ep_int_in: key down: 8
ep_int_in: key up: 8
...
</code></pre></div>  </div>
</div>






<figure>
	
		
			<img src="https://hazure.neocities.org/images/content/thinkpad-xdci/example-rg.jpg" title="Result of running Raw Gadget keyboard example with xDCI"/>
		
	
	
		<figcaption>Result of running Raw Gadget keyboard example with xDCI</figcaption>
	
</figure>

<p>From then on, I could run Raw Gadget directly on my laptop.
No more need for Raspberry Pis or EC3380-AB.
Yay! üòÑ</p>

<p>Once I had Raw Gadget working, I moved on to testing a few Raw Gadget‚Äìbased tools.</p>

<h3 id="-syzkaller">üß∞ syzkaller</h3>

<p>One of the tools that rely on Raw Gadget is <a href="https://github.com/google/syzkaller">syzkaller</a> ‚Äî a coverage-guided kernel fuzzer.
You can check out my <a href="https://hazure.neocities.org/articles/syzkaller-external-network">Looking for Remote Code Execution bugs in the Linux kernel</a> article for its overview.</p>

<figure>
	
		
		<a href="https://hazure.neocities.org/articles/syzkaller-external-network">
		
			<img src="https://hazure.neocities.org/images/content/syzkaller-external-network/cover.jpg" title=""/>
		
		</a>
		
	
	
</figure>

<p><strong>USB fuzzing</strong>.
syzkaller uses Raw Gadget for <a href="https://github.com/google/syzkaller/blob/master/docs/linux/external_fuzzing_usb.md">externally fuzzing</a> the Linux kernel USB stack.
Initially, I developed Raw Gadget specifically for its use in syzkaller.</p>

<p>With xDCI, I could run syzkaller directly on my laptop to fuzz an external USB host.
However, syzkaller heavily relies on code coverage feedback to guide its fuzzing process.
While collecting coverage from an external system would theoretically be possible to implement, I didn‚Äôt want to get into this.</p>

<p><strong>USB reproducers</strong>.
Instead, I wanted to try running a reproducer for one of the USB bugs syzkaller found.</p>

<p>
You can check the syzbot dashboard to view all of the <a href="https://syzkaller.appspot.com/upstream?manager=ci2-upstream-usb">reported</a> and <a href="https://syzkaller.appspot.com/upstream/fixed?manager=ci2-upstream-usb">fixed</a> USB bugs that syzkaller discovered in the Linux kernel.
</p>

<p><strong>Patching syzkaller</strong>.
By default, syzkaller relies on the <a href="https://github.com/xairy/raw-gadget/tree/master/dummy_hcd">Dummy HCD/UDC</a> module for fuzzing USB.</p>

<table>
	<tbody><tr>
		<th>¬´</th>
		<th>
Dummy HCD/UDC is a module that sets up virtual USB Device and Host controllers that are connected to each other inside the kernel.
This module allows connecting USB devices emulated from userspace through any of the Gadget subsystem interfaces (Raw Gadget, GadgetFS, etc.) directly to the underlying kernel.
</th>
	</tr>

	<tr>
		<th></th>
		<th><a href="https://github.com/xairy/raw-gadget/tree/master/dummy_hcd">Dummy HCD/UDC Kernel Module</a>, Raw Gadget repository</th>
	</tr>

</tbody></table>

<p>As I wanted to make syzkaller use xDCI instead, I patched the code that specifies the used UDC:</p>

<div><div><pre><code><span>diff</span> <span>--</span><span>git</span> <span>a</span><span>/</span><span>executor</span><span>/</span><span>common_usb_linux</span><span>.</span><span>h</span> <span>b</span><span>/</span><span>executor</span><span>/</span><span>common_usb_linux</span><span>.</span><span>h</span>
<span>index</span> <span>b706663f8</span><span>..</span><span>a0ce15293</span> <span>100644</span>
<span>---</span> <span>a</span><span>/</span><span>executor</span><span>/</span><span>common_usb_linux</span><span>.</span><span>h</span>
<span>+++</span> <span>b</span><span>/</span><span>executor</span><span>/</span><span>common_usb_linux</span><span>.</span><span>h</span>
<span>@@</span> <span>-</span><span>303</span><span>,</span><span>9</span> <span>+</span><span>303</span><span>,</span><span>7</span> <span>@@</span> <span>static</span> <span>volatile</span> <span>long</span> <span>syz_usb_connect_impl</span><span>(</span><span>uint64</span> <span>speed</span><span>,</span> <span>uint64</span> <span>dev_len</span><span>,</span> <span>const</span> <span>ch</span>

 	<span>// TODO: consider creating two dummy_udc&#39;s per proc to increace the chance of</span>
 	<span>// triggering interaction between multiple USB devices within the same program.</span>
<span>-</span>	<span>char</span> <span>device</span><span>[</span><span>32</span><span>];</span>
<span>-</span>	<span>sprintf</span><span>(</span><span>&amp;</span><span>device</span><span>[</span><span>0</span><span>],</span> <span>&#34;dummy_udc.%llu&#34;</span><span>,</span> <span>procid</span><span>);</span>
<span>-</span>	<span>int</span> <span>rv</span> <span>=</span> <span>usb_raw_init</span><span>(</span><span>fd</span><span>,</span> <span>speed</span><span>,</span> <span>&#34;dummy_udc&#34;</span><span>,</span> <span>&amp;</span><span>device</span><span>[</span><span>0</span><span>]);</span>
<span>+</span>	<span>int</span> <span>rv</span> <span>=</span> <span>usb_raw_init</span><span>(</span><span>fd</span><span>,</span> <span>speed</span><span>,</span> <span>&#34;dwc3-gadget&#34;</span><span>,</span> <span>&#34;dwc3.1.auto&#34;</span><span>);</span>
 	<span>if</span> <span>(</span><span>rv</span> <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
 		<span>debug</span><span>(</span><span>&#34;syz_usb_connect: usb_raw_init failed with %d</span><span>\n</span><span>&#34;</span><span>,</span> <span>rv</span><span>);</span>
 		<span>return</span> <span>rv</span><span>;</span>
</code></pre></div></div>

<p><strong>Running reproducer</strong>.
I chose to run one of the reproducers for the <a href="https://syzkaller.appspot.com/bug?extid=12002a39b8c60510f8fb">WARNING in smsusb_start_streaming/usb_submit_urb</a> bug:</p>

<div>
  <p>
Program split into multiple lines for readability.
</p>
</div>

<div><div><pre><code><span>syz_usb_connect</span><span>(</span><span>0x0</span><span>,</span> <span>0x36</span><span>,</span> <span>&amp;(</span><span>0x7f0000000000</span><span>)=</span><span>ANY</span><span>=[@</span><span>ANYBLOB</span><span>=</span><span>&#34;
  12010000d39262087f180002311f00000001090224000100000000
  09040000024b92160009050ba32b00000000090582ff00ffff0000&#34;</span><span>],</span> <span>0x0</span><span>)</span>
</code></pre></div></div>

<p>For running reproducers, syzkaller provides a <code>syz-execprog</code> tool.</p>

<p>To avoid having to run <code>syz-execprog</code> as root, I changed the permissions on the <code>/dev/raw-gadget</code> virtual device file Raw Gadget exposes to userspace:</p>

<div><div><pre><code><span>$ </span><span>sudo chown </span>user:user /dev/raw-gadget
</code></pre></div></div>

<p>Then, I built <code>syz-execprog</code> and ran the reproducer:</p>

<div><div><pre><code><span>$ </span>make execprog executor
<span>$ </span><span>cd</span> ./bin/linux_amd64/
<span>$ </span>./syz-execprog <span>-enable</span><span>=</span>usb repro.prog
</code></pre></div></div>

<p>
See the syzkaller documentation on how to <a href="https://github.com/google/syzkaller/blob/master/docs/linux/setup.md">set it up</a>.
</p>

<p><strong>Bug triggered</strong>.
This worked without any issues, and the reproducer triggered the <code>WARNING</code> on the laptop with the <code>5.15.0-91-generic</code> Ubuntu kernel I used as the host ü•≥:</p>

<div id="ubuntu-warning-off">

  <div><div><pre><code>------------[ cut here ]------------
usb 3-9: BOGUS urb xfer, pipe 3 != type 1
WARNING: at drivers/usb/core/urb.c:502 usb_submit_urb+0x473/0x6d0
...
Call Trace:
 smsusb_submit_urb+0x7e/0xb0 [smsusb]
 smsusb_start_streaming+0x39/0x82 [smsusb]
 smsusb_init_device+0x368/0x426 [smsusb]
 smsusb_probe+0x2ce/0x31f [smsusb]
 usb_probe_interface+0xeb/0x2b0
 ...
 hub_event+0x1eb/0x430
 process_one_work+0x228/0x3d0
 worker_thread+0x53/0x420
 kthread+0x127/0x150
 ret_from_fork+0x1f/0x30
---[ end trace 6c8fe15158d398c6 ]---
</code></pre></div>  </div>
  <div>
  <p>
Click the switch to see the full WARNING log.
</p>
</div>

</div>






<p>
This particular bug is just a <code>WARNING</code> caused by the <code>smsusb</code> driver missing validation for USB endpoint types; nothing harmful.
</p>

<h3 id="-facedancer">üíÉ Facedancer</h3>

<p>Another thing I wanted to try with Raw Gadget and xDCI is running <a href="https://github.com/greatscottgadgets/Facedancer">Facedancer</a> directly on my laptop without any external hardware.</p>

<p>
<a href="https://github.com/greatscottgadgets/Facedancer">Facedancer</a> is a Python framework for emulating USB devices via a range of hardware solutions, including <a href="https://greatscottgadgets.com/greatfet/">Great FET</a> and not-yet-released-but-highly-awaited <a href="https://greatscottgadgets.com/cynthion/">Cynthion</a>.
</p>



<p>
Facedancer21 was what enabled me to write my very first Linux kernel <a href="https://hazure.neocities.org/articles/cve-2016-2384">exploit</a> and also set me on the path of fiddling with <a href="https://github.com/xairy/usb-hacking">USB security</a> üòå
</p>



<p><strong>Backend</strong>.
For running Facedancer with Raw Gadget, there‚Äôs a prototype of a Raw Gadget‚Äìbased <a href="https://github.com/xairy/raw-gadget#facedancer-backend">backend</a>.
This prototype relies on a few out-of-tree Raw Gadget <a href="https://github.com/xairy/raw-gadget/commits/dev/">patches</a>, but it already works!</p>

<p>
I‚Äôm yet to submit the backend to the mainline Facedancer repository.
Before upstreaming, I need to finalize the Raw Gadget patches, and I‚Äôll also likely first wait for the <a href="https://github.com/greatscottgadgets/Facedancer/issues/79">3.0 Facedancer release</a>.
</p>

<p><strong>Rubber Ducky</strong>.
To test Facedancer with Raw Gadget and xDCI, I rebuilt and reloaded the Raw Gadget module with the out-of-tree patches, and ran the <code>rubber-ducky.py</code> example:</p>

<div><div><pre><code><span>$ </span><span>sudo chown </span>user:user /dev/raw-gadget
<span>$ </span><span>export </span><span>BACKEND</span><span>=</span>rawgadget
<span>$ </span><span>export </span><span>RG_UDC_DRIVER</span><span>=</span>dwc3-gadget
<span>$ </span><span>export </span><span>RG_UDC_DEVICE</span><span>=</span>dwc3.1.auto
<span>$ </span>./examples/rubber-ducky.py
INFO    | rubber-ducky   | Beginning message typing demo...
INFO    | rawgadget      | gadget resumed
INFO    | rawgadget      | send_on_endpoint: <span>ep_num</span><span>=</span>0 len<span>(</span>data<span>)=</span>12 <span>blocking</span><span>=</span>False
INFO    | rawgadget      | gadget resumed
INFO    | rawgadget      | send_on_endpoint: <span>ep_num</span><span>=</span>0 len<span>(</span>data<span>)=</span>12 <span>blocking</span><span>=</span>False
INFO    | rawgadget      | send_on_endpoint: <span>ep_num</span><span>=</span>0 len<span>(</span>data<span>)=</span>9 <span>blocking</span><span>=</span>False
INFO    | rawgadget      | send_on_endpoint: <span>ep_num</span><span>=</span>0 len<span>(</span>data<span>)=</span>22 <span>blocking</span><span>=</span>False
INFO    | rawgadget      | send_on_endpoint: <span>ep_num</span><span>=</span>0 len<span>(</span>data<span>)=</span>4 <span>blocking</span><span>=</span>False
INFO    | rawgadget      | send_on_endpoint: <span>ep_num</span><span>=</span>0 len<span>(</span>data<span>)=</span>30 <span>blocking</span><span>=</span>False
INFO    | rawgadget      | send_on_endpoint: <span>ep_num</span><span>=</span>0 len<span>(</span>data<span>)=</span>16 <span>blocking</span><span>=</span>False
INFO    | rawgadget      | send_on_endpoint: <span>ep_num</span><span>=</span>0 len<span>(</span>data<span>)=</span>14 <span>blocking</span><span>=</span>False
INFO    | rawgadget      | send_on_endpoint: <span>ep_num</span><span>=</span>0 len<span>(</span>data<span>)=</span>0 <span>blocking</span><span>=</span>False
INFO    | rawgadget      | ep_enable: <span>rv</span><span>=</span>5
INFO    | rawgadget      | configured
INFO    | rawgadget      | send_on_endpoint: <span>ep_num</span><span>=</span>3 len<span>(</span>data<span>)=</span>a <span>blocking</span><span>=</span>False
INFO    | rawgadget      | send_on_endpoint: <span>ep_num</span><span>=</span>0 len<span>(</span>data<span>)=</span>14 <span>blocking</span><span>=</span>False
INFO    | rawgadget      | send_on_endpoint: <span>ep_num</span><span>=</span>3 len<span>(</span>data<span>)=</span>a <span>blocking</span><span>=</span>False
...
</code></pre></div></div>

<p>The example worked without a hitch ü•≥</p>

<figure>
	
		
			<img src="https://hazure.neocities.org/images/content/thinkpad-xdci/example-facedancer.jpg" title="Result of running Facedancer Rubber Ducky example with Raw Gadget and xDCI"/>
		
	
	
		<figcaption>Result of running Facedancer Rubber Ducky example with Raw Gadget and xDCI</figcaption>
	
</figure>

<p><strong>Yay</strong>.
By itself, Raw Gadget allows running Facedancer on Linux-based boards (minding the Raw Gadget <a href="https://github.com/xairy/raw-gadget?tab=readme-ov-file#limitations">limitations</a>), which is quite cool.
But combined with xDCI, it‚Äôs possible to run Facedancer directly on a PC without any external hardware at all.
Insane! üò±</p>

<p>
Another Raw Gadget‚Äîbased tool I successfully ran with xDCI was <a href="https://github.com/AristoChen/usb-proxy">USB Proxy</a> by <a href="https://github.com/AristoChen">Aristo Chen</a>.
I won‚Äôt provide the instructions here, as the article is already quite long.
With xDCI, this tool allows turning the laptop into a USB sniffer or a USB Man-in-the-Middle attack tool.
</p>

<h2 id="-summary">üóÉ Summary</h2>

<figure>
	
		
			<img src="https://hazure.neocities.org/images/content/thinkpad-xdci/xdci-emulation.jpg" title="ThinkPad X1 Carbon 6th Gen emulates a USB device for ThinkPad X1 Carbon 10th Gen via xDCI"/>
		
	
	
		<figcaption>ThinkPad X1 Carbon 6th Gen emulates a USB device for ThinkPad X1 Carbon 10th Gen via xDCI</figcaption>
	
</figure>

<p><strong>Introduction</strong>.
While working on <a href="https://github.com/xairy/raw-gadget">Raw Gadget</a>, I <a href="#-introduction">noticed</a> a suspicious <code>/sys/class/usb_role/intel_xhci_usb_sw-role-switch</code> file on my ThinkPad X1 Carbon 6th Gen laptop.
Finding this file seemingly implied that the xHCI device on my laptop could be switched into the <code>device</code> mode and be used to emulate USB devices.</p>

<p><strong>Investigation</strong>.
Upon <a href="#-reading-kernel-code">checking</a> the Linux kernel source code and <a href="#-searching-online">reading</a> through a related mailing list <a href="https://lore.kernel.org/all/CAGR4S9HQiZCsA7Y5_47j-xBOkydKiT2Exam=36L=-vwRjt+UWA@mail.gmail.com/t/#u">discussion</a>, I found out that some Intel systems indeed support enabling the so-called xDCI controller for emulating USB devices.
On my laptop, this controller was <a href="#-checking-pcie-and-acpi">not present</a> in the list of PCIe devices, but <a href="#-checking-bios">there was</a> a hidden <code>xDCI Support</code> setting in BIOS.</p>

<p><strong>Enabling xDCI</strong>.
Then, I took three approaches to try enabling xDCI:</p>

<ol>
  <li>
    <p>Successfully <a href="#-enabling-xdci-via-advanced-settings">via</a> unlocking the <code>Advanced</code> BIOS settings page and changing the value of <code>xDCI Support</code>.
This required reflashing the SPI chip on my laptop and patching BIOS to unlock the <code>Advanced</code> page and bypass Boot Guard.</p>

    <p>Once I enabled xDCI, I <a href="#-checking-xdci">managed</a> to find the xDCI-enabled port on my laptop, make a custom <code>VBUS</code>-disconnected USB cable, and successfully emulate a testing USB device through xDCI;</p>
  </li>
  <li>
    <p>Unsuccessfully <a href="#-attempting-to-enable-xdci-via-pch">via</a> PCH.
Within this approach, I tried to reconfigure the PCH registers to enable xDCI.
I <a href="#-enabling-xdci-in-pmc">managed</a> to reconfigure PMC by relying on missing register locking on the wake-up-from-suspend path.
However, I <a href="#-enabling-xdci-in-psf">failed</a> to reconfigure PSF, as PSF was disconnected from IOSF-SB by BIOS during boot;</p>
  </li>
  <li>
    <p>Successfully <a href="#-enabling-xdci-via-nvram">via</a> patching NVRAM.
For this, I patched the <code>xDCI Support</code> value in NVRAM on the SPI chip directly.
This still required reflashing the SPI chip but did not need a Boot Guard bypass.
Thus, this approach should be portable to other systems besides my laptop to enable xDCI.</p>
  </li>
</ol>

<p><strong>Using xDCI</strong>.
In the last part, I <a href="#-using-xdci">showed</a> a few usage scenarios for xDCI:</p>

<ul>
  <li>
    <p>First, I <a href="#-legacy-gadget-drivers">demonstrated</a> how to use the <code>g_mass_storage</code> legacy gadget driver to emulate a USB mass storage drive;</p>
  </li>
  <li>
    <p>Then, I <a href="#-raw-gadget">managed</a> to get <a href="https://github.com/xairy/raw-gadget">Raw Gadget</a> working with xDCI and used them to emulate a USB keyboard.
This required applying a <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=cf9f7a6ee7b1f53f9ae13da55585b7d16aee2460">workaround patch</a> to Raw Gadget to make it compatible with the <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=3551ff7c5cfff4dc27fdcd14fa286edc08d78088">buggy</a> <code>dwc3</code> driver used for xDCI;</p>
  </li>
  <li>
    <p>After that, I successfully <a href="#-syzkaller">ran</a> a reproducer for one of the syzkaller-found <a href="https://syzkaller.appspot.com/bug?extid=12002a39b8c60510f8fb">bugs</a> to emulate an improper USB device through xDCI and triggered a <code>WARNING</code> on a Linux kernel host;</p>
  </li>
  <li>
    <p>Finally, I <a href="#-facedancer">showed</a> how to use the Raw Gadget‚Äìbased Facedancer <a href="https://github.com/xairy/raw-gadget#facedancer-backend">backend</a> with xDCI to emulate a USB keyboard via the <code>rubber-ducker.py</code> Facedancer example.</p>
  </li>
</ul>

<p>Emulating USB devices in all shown examples required no hardware besides my laptop.</p>

<h2 id="-afterword">üìù Afterword</h2>

<p><strong>Motivation</strong>.
Even though this project was a bit of a spin-off from my usual expertise areas, I really enjoyed working on it and learning about BIOS and PCH internals in particular üòÑ</p>

<p>Once I found that USB role-switching file on my laptop, I could not stop thinking about the possibility of it being functional.
Luckily, it indeed was üòä</p>

<p>Managing to turn a commonly-used laptop into a programmable USB device feels like a good accomplishment ü•≥</p>

<p><strong>Other machines</strong>.
I specifically targeted my ThinkPad X1 Carbon 6th Gen laptop where I found the file, but I suspect enabling xDCI should also be possible on other PCs.</p>

<p>In the simplest case, this might be as easy as turning on xDCI in BIOS settings.
This should just work if there‚Äôs proper ACPI and role-switching support and the xDCI-enabled port is wired to the external casing.</p>

<p>As for other ThinkPads in particular, enabling xDCI should also not be a problem. 
Although, this will likely require reflashing the SPI chip, as the xDCI BIOS setting is hidden.
But at least, with the NVRAM approach, this will not require a Boot Guard bypass.</p>

<p>
I briefly looked at the ThinkPad X1 Carbon <strong>10th</strong> Gen laptop but failed to find the SPI chip.
Perhaps the chip is located on the bottom side of the motherboard, which I did not check.
</p>

<p>
Note that the SPI chip on some modern systems might be protected from reflashing via RPMC (Replay Protected Monotonic Counter).
The chips that support this feature have ‚ÄúR‚Äù in their name, like ‚ÄúW25<strong>R</strong>128FW‚Äù.
</p>

<p><strong>Software approaches</strong>.
I also believe it should be possible to enable xDCI purely via software.
Even though I failed to do it by reconfiguring PCH, there are other approaches.</p>

<p>One of them would be to exploit a BIOS bug to flip the xDCI-related NVRAM variable.
For example, this can likely be done by <a href="https://binarly.io/posts/inside_the_logofail_poc_from_integer_overflow_to_arbitrary_code_execution/index.html">exploiting</a> the <a href="https://binarly.io/posts/finding_logofail_the_dangers_of_image_parsing_during_system_boot/">LogoFAIL</a> vulnerability found by the Binarly team.</p>

<p>Another idea that comes to mind is using DMA to <a href="https://github.com/ufrisk/pcileech/wiki/Target-UEFI">attack BIOS</a> during boot.
This way, it might be possible to execute arbitrary code within BIOS and enable xDCI.
Even though some modern systems protect BIOS from DMA, others might be vulnerable.</p>

<p><strong>Clickbait</strong>.
Using the word ‚Äúsecret‚Äù in the title was a mere attempt at clickbait üòå
I don‚Äôt have any reason to believe that Lenovo deliberately keeps the knowledge about xDCI functionality private.
It‚Äôs likely rather just an undocumented feature.</p>

<p><strong>Acknowledgements</strong>.
Many thanks to those who willingly or unknowingly helped me with this project:</p>

<ul>
  <li>to Dmitry Mikushin, Heikki Krogerus, and Felipe Balbi for following through with the mailing list discussion about xHCI/xDCI role switching;</li>
  <li>to <a href="https://brs.im/en/">Sergey Korablin</a> for helping me with soldering and taking hardware pictures;</li>
  <li>to <a href="https://twitter.com/h0t_max">Maxim Goryachy</a> for suggesting the PCH approach, answering my countless questions about BIOS, and giving feedback on the article;</li>
  <li>to Alan Stern and Thinh Nguyen for looking into the <code>dwc3</code> issue I reported and reviewing the Raw Gadget workaround;</li>
  <li>to <a href="https://twitter.com/a13xp0p0v">Alexander Popov</a> for reviewing the article;</li>
  <li>and to everyone else whose work is referenced in this article üíú</li>
</ul>

<p>While I failed to implement a software-only approach, I‚Äôm very happy with the result.
Now, I can run Raw Gadget on my laptop without having to deal with external hardware üòÑ</p>

<h3>üíú Thank you for reading!</h3>



<h3 id="-about-me">üê± About me</h3>

<p>I‚Äôm a security researcher and a software engineer focusing on the Linux kernel.</p>

<p>I contributed to several security-related Linux kernel subsystems and tools, including
<a href="https://www.kernel.org/doc/html/latest/dev-tools/kasan.html">KASAN</a> ‚Äî a fast dynamic bug detector,
<a href="https://github.com/google/syzkaller">syzkaller</a> ‚Äî a production-grade kernel fuzzer,
and <a href="https://docs.google.com/presentation/d/1IpICtHR1T3oHka858cx1dSNRu2XcT79-RCRPgzCuiRk/edit?usp=sharing">Arm Memory Tagging Extension</a> ‚Äî an exploit mitigation.
I also wrote a few Linux kernel <a href="https://github.com/xairy/kernel-exploits">exploits</a> for the bugs I found.</p>

<p>Occasionally, I‚Äôm having fun with
<a href="https://github.com/xairy/usb-hacking">hardware</a>
<a href="https://github.com/xairy/dma-attacks">hacking</a>,
<a href="https://github.com/xairy/mipt-ctf">teaching</a>,
and <a href="https://github.com/xairy/easy-linux-pwn">other</a>
<a href="https://github.com/xairy/raw-gadget">random</a>
<a href="https://github.com/xairy/unlockdown">stuff</a>.</p>

<p>Follow me <a href="https://twitter.com/andreyknvl">@andreyknvl</a> on Twitter,
<a href="https://infosec.exchange/@xairy">@xairy@infosec.exchange</a> on Mastodon,
or <a href="https://www.linkedin.com/in/xairy">@xairy</a> on LinkedIn
for notifications about new <a href="https://hazure.neocities.org/articles/">articles</a>, <a href="https://hazure.neocities.org/talks/">talks</a>, and <a href="https://hazure.neocities.org/trainings/">training sessions</a>.</p>


      </div>
    </article>
  </div></div>
  </body>
</html>
