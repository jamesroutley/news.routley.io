<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/mwerezak/sphinx-lang">Original</a>
    <h1>Show HN: I&#39;m making a dynamic language in Rust</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p data-sourcepos="3:1-3:168" dir="auto"><em>The lastest version (0.5) requires nightly Rust. This is because pointer metadata is being used to GC unsized types, whereas before a double-indirection was required.</em></p>
<p data-sourcepos="5:1-5:120" dir="auto">Sphinx is a dynamically typed programming language that is inspired by Lua and Python, and implemented entirely in Rust!</p>
<p data-sourcepos="7:1-7:111" dir="auto">Sphinx is not complete! There is still a lot to do before it is a functional language. Some things on my radar:</p>
<ul data-sourcepos="9:2-12:0" dir="auto">
<li data-sourcepos="9:2-9:16">import system</li>
<li data-sourcepos="10:2-10:27">a basic standard library</li>
<li data-sourcepos="11:2-12:0">work out the details of the class/object system</li>
</ul>

<p data-sourcepos="15:1-15:164" dir="auto">My goal is to have a lightweight, expressive language. At the same time, I also want the language runtime to be decently fast, and I aim to balance these two goals.</p>
<p data-sourcepos="17:1-17:254" dir="auto">Finally, this whole project started just as a way to learn Rust, and I have definitely been doing a lot of that. While I would love for this to someday be an actual, practical, and complete development tool for someone, that&#39;s a pretty long road to walk.</p>

<p data-sourcepos="21:1-21:413" dir="auto">Sphinx makes use of Rust&#39;s <a href="https://github.com/rust-lang/rust/issues/81513" data-hovercard-type="issue" data-hovercard-url="/rust-lang/rust/issues/81513/hovercard">pointer metadata API</a>, which has not yet been stabilized. So in order to build it you will need nightly Rust. Probably if you&#39;re here you&#39;re interested in looking at the internals of a compiler/VM (since the language itself is pretty WIP), so you probably already know how to set that up, but if you don&#39;t, you can get it with <code>rustup</code>.</p>
<p data-sourcepos="23:1-23:152" dir="auto">Once built, you can run the REPL with <code>sphinx</code> and the disassembler with <code>sphinx-dasm</code>. Both executables have <code>--help</code> to list the command line options.</p>
<p data-sourcepos="25:1-25:53" dir="auto">Here is some example code you can run to get started:</p>
<div data-snippet-clipboard-copy-content="# Makes a counter using closures
fun make_inc()
    var a = 0
    fun inc(s = 1)
        nonlocal a += s
    end
end

# Warning - very slow! This was intended for a stress test
# Try this: compile Sphinx in release mode and note the massive speedup when executing fib(30)
fun fib(n)
    if n &lt; 2 then 
        return n 
    end
    fib(n - 2) + fib(n - 1)
end"><pre><code># Makes a counter using closures
fun make_inc()
    var a = 0
    fun inc(s = 1)
        nonlocal a += s
    end
end

# Warning - very slow! This was intended for a stress test
# Try this: compile Sphinx in release mode and note the massive speedup when executing fib(30)
fun fib(n)
    if n &lt; 2 then 
        return n 
    end
    fib(n - 2) + fib(n - 1)
end
</code></pre></div>
<p data-sourcepos="45:1-45:180" dir="auto">Right now <code>sphinx</code> will compile the code and execute it from memory. I plan to add support for binary bytecode input/output, but right now even the file format for that is TBD <g-emoji alias="upside_down_face" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f643.png">ðŸ™ƒ</g-emoji></p>

<p data-sourcepos="49:1-49:323" dir="auto">I have an internal type system built around a <code>MetaObject</code> trait which makes it easy to specify the behaviours that are supported by each of the core primitive types in the language. Thanks to Rust&#39;s enum types (and some macros) this is implemented without any vtables, using static dispatch based on the enum discriminant.</p>
<p data-sourcepos="51:1-51:382" dir="auto">Different representations of string data. Short strings are &#34;inlined&#34; on the stack when possible (inspired by flexstr). All strings that are used as identifiers are interned. Only strings &gt;40 bytes long are allocated using the GC. The bytecode compiler converts local variable names into indexes into the value stack, so strings are not used at all when referencing local variables.</p>
<p data-sourcepos="53:1-53:295" dir="auto">The Sphinx language uses a simple Mark-Trace GC inspired by <code>rust-gc</code>. The <em>runtime</em> itself does not use any GC. Since we are only GC&#39;ing script data, a lot of the challenges that would be involved in writing a GC for general Rust code are avoided (that for example, <code>rust-gc</code> has to deal with).</p>
<p data-sourcepos="55:1-55:349" dir="auto">The GC also supports allocating dynamically sized types without double-indirection (i.e. the <code>Gc&lt;T&gt;</code> smart pointer used for GCed data points directly to the DST, not a Box). It also uses <em>thin pointers</em> to refer to the dynamically sized allocation, which keeps the size of each <code>Gc&lt;T&gt;</code> down to a single <code>usize</code>. The GC also supports weak references!</p>
<p data-sourcepos="57:1-57:153" dir="auto">In the future I would like to support incremental GC and <em>maybe</em> generational GC as well, but the current implementation is simple and works pretty well.</p>

<p data-sourcepos="61:1-61:232" dir="auto">Because Sphinx is (mostly) implemented in Safe Rust, it should be possible to provide a completely safe FFI with Rust code. This would allow a host Rust application to gain the capabilities of an embedded dynamic scripting language.</p>
<p data-sourcepos="63:1-63:108" dir="auto">As a long term goal I would like to also leverage the rlua bindings to provide a Lua FFI in Sphinx, as well.</p>

<p data-sourcepos="67:1-67:372" dir="auto">At the present moment, nearly complete syntax highlighting is available for users of Sublime Text - just copy <code>sphinx.sublime-syntax</code> into your user packages directory. If you use a different text editor and want syntax highlighting for Sphinx, feel free to drop a request on GitHub. Getting the language working is my first priority, but I don&#39;t mind taking a look at it.</p>

<div data-snippet-clipboard-copy-content="#{ 
    Block Comment  
    #{ Nested! }#
}#

echo &#34;Hello, world!&#34;  # print() function will be available later once there is a builtin library

# Semicolons are optional. The syntax has been designed so that the end of a statement can always be inferred.
&#34;One&#34;; &#34;Two&#34;

# Mutable and immutable variables
let immutable = &#34;can&#39;t change me&#34;
var mutable = 0
echo mutable += 1  # almost all constructs in Sphinx are expressions

var annotated: Float = 3.14159  # not implemented yet, but someday...

# Tuples
&#34;abc&#34;, 123

# Tuple assignment
var first, second = &#34;abc&#34;, &#34;def&#34;
second, first = first, second
assert &#34;def&#34;, &#34;abc&#34; == first, second

# Objects
{ value = 0xA }  # anonymous object

Person { value = 0xC }  # classy object


# Functions, including default and variadic arguments

# note: default arguments are re-evaluated with each invocation (unlike another scripting language that shall not be named)
fun echo_default(thing = &#34;default&#34;)
  echo thing
end

fun variadic_fun(normal_arg, variadic...)
  echo normal_arg  
  for variadic_arg in variadic do
    echo variadic_arg
  end
end

variadic_fun(&#34;red&#34;, &#34;blue&#34;, &#34;green&#34;)  # prints &#34;red&#34; then &#34;blue&#34; then &#34;green&#34;

# Note: named arguments are not supported. It may be added in the future.
# You can pass an anonymous object instead.
configure_something({ option1: true, option2: false })


# Argument unpacking and wrapping decorators
fun trace(wrapped)
  return fun(args...)
    echo &#34;trace&#34;
    wrapped(args...)
  end
end

# &#34;@decorator let/var name = value&#34; is syntactic sugar for &#34;let/var name = decorator(value)&#34;
# And &#34;fun name() ... end&#34; is syntatic sugar for &#34;let name = fun() ... end&#34;
# Put that together and we can do:
@trace
fun increment(x)
  return x + 1
end

# Classes, Metatables
# WIP/TBD
"><pre><code>#{ 
    Block Comment  
    #{ Nested! }#
}#

echo &#34;Hello, world!&#34;  # print() function will be available later once there is a builtin library

# Semicolons are optional. The syntax has been designed so that the end of a statement can always be inferred.
&#34;One&#34;; &#34;Two&#34;

# Mutable and immutable variables
let immutable = &#34;can&#39;t change me&#34;
var mutable = 0
echo mutable += 1  # almost all constructs in Sphinx are expressions

var annotated: Float = 3.14159  # not implemented yet, but someday...

# Tuples
&#34;abc&#34;, 123

# Tuple assignment
var first, second = &#34;abc&#34;, &#34;def&#34;
second, first = first, second
assert &#34;def&#34;, &#34;abc&#34; == first, second

# Objects
{ value = 0xA }  # anonymous object

Person { value = 0xC }  # classy object


# Functions, including default and variadic arguments

# note: default arguments are re-evaluated with each invocation (unlike another scripting language that shall not be named)
fun echo_default(thing = &#34;default&#34;)
  echo thing
end

fun variadic_fun(normal_arg, variadic...)
  echo normal_arg  
  for variadic_arg in variadic do
    echo variadic_arg
  end
end

variadic_fun(&#34;red&#34;, &#34;blue&#34;, &#34;green&#34;)  # prints &#34;red&#34; then &#34;blue&#34; then &#34;green&#34;

# Note: named arguments are not supported. It may be added in the future.
# You can pass an anonymous object instead.
configure_something({ option1: true, option2: false })


# Argument unpacking and wrapping decorators
fun trace(wrapped)
  return fun(args...)
    echo &#34;trace&#34;
    wrapped(args...)
  end
end

# &#34;@decorator let/var name = value&#34; is syntactic sugar for &#34;let/var name = decorator(value)&#34;
# And &#34;fun name() ... end&#34; is syntatic sugar for &#34;let name = fun() ... end&#34;
# Put that together and we can do:
@trace
fun increment(x)
  return x + 1
end

# Classes, Metatables
# WIP/TBD

</code></pre></div>
</article>
          </div></div>
  </body>
</html>
