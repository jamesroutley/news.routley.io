<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://staniks.github.io/articles/serious-engine-networking-analysis">Original</a>
    <h1>Serious Sam handled massive amounts of enemies on 56k modem connections</h1>
    
    <div id="readability-page-1" class="page"><section><p><img alt="Banner" src="https://staniks.github.io/img/articles/serious-engine/banner.jpg" title="Banner"/></p>
<p>Croteam released the <a href="https://github.com/Croteam-official/Serious-Engine">Serious Engine 1 source code</a> under GNU GPL v2 in 2016, and I&#39;ve wanted to check it out for quite a while now. My observations here are based on reading and debugging this particular codebase and not reverse-engineering the classics released on GOG and Steam. Keep in mind that comments in code snippets have been replaced to provide more context. Also, some of my conclusions here may be wrong, so you can send me a message over at <a href="https://twitter.com/Sklopec">@Sklopec</a> if you feel like something needs correction.</p>
<blockquote>
<p><strong>NOTE:</strong> <em>This isn&#39;t an in-depth technical analysis, but an overview with more focus on the concepts rather than the implementation. I have skipped over a lot of things for the sake of simplicity. Also, the following sections assume you have at least a vague idea of how Serious Sam looks and plays.</em></p>
</blockquote>




<ul>
<li><strong>2020-11-05</strong> - published.</li>
<li><strong>2024-06-11</strong> - fix typo.</li>
</ul>

<hr/>
<p><strong>Serious Sam</strong> was built from the ground up as a multiplayer game. In a way, it&#39;s multiplayer even when you&#39;re playing the singleplayer campaign. While this idea may seem unusual at first, it&#39;s really just a clever way of abstraction. Let&#39;s explore how it works.</p>
<p>Serious Engine supports:</p>
<ul>
<li>singleplayer - offline campaign</li>
<li>multiplayer - online, LAN or local co-op and various game modes<ul>
<li>supports multiple players on the same client via split-screen!</li>
</ul>
</li>
<li>demo recording and playback</li>
</ul>
<p>Let&#39;s look at the demo functionality first. Serious Engine allows recording and reproduction of gameplay clips or <em>demos</em>. Both multiplayer and singleplayer game sessions can be recorded. In order to record a game, the most naive solution would be to persist the game state of every tick into a file.</p>
<p>However, such an approach has a problem - demo files would be ridiculously large.</p>
<p>Instead, Serious Engine records the entire game state at the beginning of the recording, and then, each tick, records something called <strong>game stream blocks</strong>. For now, think of these as messages which describe events in the game. They can be of these types:</p>
<pre><code>MSG_SEQ_ALLACTIONS,      // Player actions. See below.
MSG_SEQ_ADDPLAYER,       // Add a new player to the game.
MSG_SEQ_REMPLAYER,       // Remove a player from the game.
MSG_SEQ_PAUSE,           // Pause or unpause the game.
MSG_SEQ_CHARACTERCHANGE, // Change an aspect of player&#39;s character.
</code></pre>
<p>It&#39;s not important that you understand these context of these message types right now - we&#39;ll get to that later. For now, let&#39;s focus on message type <code>MSG_SEQ_ALLACTIONS</code>, because this is key to understanding how the whole thing works. This particular message type is processed in <code>CSessionState::ProcessGameTick</code>:</p>
<pre><code>FOREACHINSTATICARRAY(ses_apltPlayers, CPlayerTarget, itplt) {
    if (itplt-&gt;IsActive()) {
        // Extract action from message passed as parameter.
        CPlayerAction paAction;
        nmMessage&gt;&gt;paAction;

        // Apply the action to the CPlayerTarget.
        itplt-&gt;ApplyActionPacket(paAction);
    }
}
</code></pre>
<p>The engine deserializes several <code>CPlayerAction</code> objects from the message, one for each active player (since multiplayer games can be recorded as well), and applies these packets. Let&#39;s take a look at the <code>CPlayerAction</code> class to see what these packets actually are.</p>
<pre><code>class ENGINE_API CPlayerAction {
public:
    FLOAT3D pa_vTranslation;
    ANGLE3D pa_aRotation;
    ANGLE3D pa_aViewRotation;
    ULONG   pa_ulButtons;
    __int64 pa_llCreated;

    // ...
}
</code></pre>
<p><code>CPlayerAction</code> describes the player&#39;s state:</p>
<ul>
<li>player character velocity in world-space (<code>pa_vTranslation</code>)</li>
<li>player character rotation in world-space (<code>pa_aRotation</code>)</li>
<li>player view rotation in world-space (<code>pa_aViewRotation</code>)</li>
<li>buttons currently held down (<code>pa_ulButtons</code>, application defined, independent of control mapping scheme)</li>
<li>timestamp in milliseconds (<code>pa_llCreated</code>, from <a href="https://en.wikipedia.org/wiki/Time_Stamp_Counter">TSC</a>)</li>
</ul>
<p>These messages are generated by the Engine each tick during gameplay as the player interacts with the game (presses buttons, moves the mouse and/or thumbsticks). The messages are continuously serialized during recording and written into the demo file.</p>
<p>So how does reproduction work? The idea is simple - the Engine assumes everything in the game is completely predictable, and the players are the only ones with the power to change things. So in order to record the demo, the Engine only needs to record the entire game state once, and then only record the actions players perform each tick. In order to perform playback, the Engine deserializes the initial game state from the demo file, and then deserializes and applies player actions each tick as if the player was playing the game.</p>
<p>Neat, isn&#39;t it?</p>
<p>There&#39;s a caveat, though - <strong>this means the Engine&#39;s game model has to be completely deterministic.</strong> And it is. You can see an example of this if you peek into the <code>CEntity</code> implementation:</p>
<pre><code>ULONG CEntity::IRnd(void)
{
    return ((_pNetwork-&gt;ga_sesSessionState.Rnd()&gt;&gt;(31-16))&amp;0xFFFF);
}
</code></pre>
<p>where <code>CSessionState::Rnd()</code> is a pseudo-random number generator whose seed is part of the game state and is therefore initialized during game state deserialization:</p>
<pre><code>void CSessionState::Read_t(CTStream *pstr)  // throw char *
{
    // ...
    (*pstr)&gt;&gt;ses_ulRandomSeed;
    // ...
</code></pre>
<p>This makes sure the Engine is able to reproduce the exact same scenario every time we play the demo. If we would, say, use a truly random number generator for some game logic, or even a pseudo-random generator with differing seed, we would get different results every time - the famous <strong>desynchronization</strong>.</p>
<h2>Floating Point Determinism <a name="floating-point-determinism"></a></h2>
<p>There&#39;s also the matter of potential desynchronization due to floating point numbers. However, since Serious Sam on PC was originally released on Windows only, they could get away with using one compiler for everything, thus eliminating any sync issues that would emerge due to differences in C runtime library, like different implementations of trigonometry functions.</p>
<p>Similar issues can also arise due to differences in FPU precision. For example, the renderers are DLLs, and different clients might use different renderers. Renderers call various APIs (OpenGL, DirectX), and function calls in some of them might set FPU precision to different than expected. Serious Engine seems to have that covered as well. You can see precision guards like these, sprinkled around:</p>
<pre><code>CSetFPUPrecision FPUPrecision(FPT_24BIT);
</code></pre>
<p>Upon this object&#39;s construction, <code>_control87</code> function (MSVC specific) is used to cache the current FPU precision, then apply the new one. Once the object goes out of scope, the cached FPU precision is restored.</p>
<p>In theory, problems like these could also occur due to rounding control, but I haven&#39;t seen it explicitly set anywhere in the engine. There&#39;s this assert though, but this is just a query.</p>
<pre><code>ASSERT((_controlfp(0, 0)&amp;_MCW_RC)==_RC_NEAR);
</code></pre>
<p>Maybe it just wasn&#39;t that big of a deal - perhaps the rounding differences would be small enough not to accumulate significantly over the relatively short time that a session lasts, and thus, not produce any noticeable desynchronization.</p>
<h2>Tick vs. Frame <a name="tick-vs-frame"></a></h2>
<p>Notice how I use the word <strong>tick</strong> instead of <strong>frame</strong>. This is because the game logic tickrate is decoupled from the rendering framerate. Rendering framerate varies depending on the hardware and settings, but seems to be capped at <strong>500 frames per second</strong> internally. However, the game logic rate is constant and limited to <strong>20 ticks per second</strong>. But why do we see smooth movement and animation?</p>
<p><strong>Interpolation</strong>. Serious Engine interpolates between the current and the previous game tick based on time passed between. Try opening the in-game console (<code>~</code> key) and typing this to see how the game looks and feels without interpolation:</p>
<pre><code>/net_bLerping=0
</code></pre>
<p>It&#39;s kind of like playing a modern console exclusive. So how does Serious Engine smooth this out?</p>
<p>Animations and movement are interpolated with simple linear interpolation (lerp):</p>
<pre><code>interpolated_state = old_state + (new_state - old_state) * factor;
</code></pre>
<p>where <code>factor</code> is a floating point value in range <code>[0.0f, 1.0f]</code>. The factor in a particular moment in time is calculated as follows (pseudocode):</p>
<pre><code>// Time is in seconds.
float real_delta = time_since_session_started;
float tick_delta = time_of_last_tick - time_of_first_tick;

// 20 FPS logic framerate.
static constexpr float tick_quantum = 1 / 20.0f;

float factor2 = 1.0f - (tick_delta - real_delta) / tick_quantum;
</code></pre>
<p>Or illustrated, if don&#39;t mind my terrible handwriting...</p>
<p><img alt="Ticks explained" src="https://staniks.github.io/img/articles/serious-engine/frametick.png" title="Ticks explained"/></p>
<p>You can also see the implementation in <code>CSessionState::SetLerpFactor</code>. You will notice there are two interpolation (<code>Lerp</code>) factors - one is for predicted movement, and one is for non-predicted. For now, don&#39;t worry about predicted movement - we&#39;ll get to prediction and explain how it works later.</p>
<p>Now that we&#39;ve covered the basic concept of the demo recording and reproduction, think about this: instead of recording the course of the game into a file to be reproduced later, we could send it over the network to be reproduced in real time as we play the game with another person. That is the basic idea of Serious Engine multiplayer.</p>

<hr/>
<p>Unfortunately, the internet is a much more complicated environment than a file on your disk drive. Serious Sam is a fast paced game, and making things work fast over the internet is somewhat tricky, especially if you consider the fact that Serious Sam came out in the early 2000s, when a noticeable amount of people were still using 56k modems.</p>
<p>As you may have already guessed, Serious Sam employs a multiplayer model in which every player runs their own simulation and merely receives instructions on what the players have done, much like the demo system. If you glance at the code, you might see function names like <code>CNetworkLibrary::StartPeerToPeer_t</code>, but this is somewhat misleading - Serious Sam&#39;s networking isn&#39;t really peer to peer, even though the logic is processed akin to the old lockstep multiplayer games.</p>
<p>Serious Engine&#39;s networking model is actually client-server.</p>
<p>The basic idea is that, for a single multiplayer session, there is a single server, and the clients connect to it. The server receives messages from clients, processes them, and relays relevant information to all the clients. The clients then use this information to advance the state of their simulation.</p>
<p>This concept introduces the server as the &#34;middleman&#34; and avoids a myriad of issues which could emerge in a classic peer-to-peer model. For example, in case of desynchronization in pure peer-to-peer, it isn&#39;t trivial to determine whose game state is legitimate. Even worse, since public IPv4 addresses are in short supply, many people play behind NATs, and directly interfacing with such clients via UDP would often involve ugly hacks like NAT hole punching, or may not even work at all.</p>
<h2>The Packet Layer <a name="the-packet-layer"></a></h2>
<p>Serious Engine uses UDP - a connectionless, &#34;fire and forget&#34; protocol. UDP packets begin with a struct like this, followed by packet data.</p>
<pre><code>struct udp_packet_header_t
{
    uint16_t src_port; // Source port.
    uint16_t dst_port; // Destination port.
    uint16_t length;   // Packet length (including the header).
    uint16_t checksum; // Checksum.
};
</code></pre>
<p>UDP packets can arrive at their destination out of order, or may not arrive at all. This is a significant problem when playing over the internet, so Croteam implemented their own, custom protocol on top of UDP to achieve reliability and packet ordering. Let&#39;s take a look at the <code>CPacket</code> structure.</p>
<blockquote>
<p><strong>NOTE:</strong> This isn&#39;t actually what&#39;s being transmitted, but rather an internal representation. <code>pa_pubPacketData</code> is the data that will eventually end up being sent over the network.</p>
</blockquote>
<pre><code>class CPacket {
public:
    ULONG       pa_ulSequence;
    UBYTE       pa_ubReliable;
    SLONG       pa_slSize;
    SLONG       pa_slTransferSize;
    UBYTE       pa_ubRetryNumber;
    CTimerValue pa_tvSendWhen;
    UBYTE       pa_pubPacketData[MAX_PACKET_SIZE];
    CListNode   pa_lnListNode;
    CAddress    pa_adrAddress;

    // ...
};
</code></pre>
<p>Packet ordering and deduplication is achieved via <strong>sequence number</strong> (<code>CPacket::pa_ulSequence</code>). This is incremented every time the engine sends a packet. When packets are received or prepared for sending, they are inserted into a corresponding packet buffer (<code>CPacketBuffer</code>), at a position based on this sequence number (i.e. packet of highest index is appended to the end of the buffer). When a packet with an already encountered sequence number is received, it is discarded to prevent duplication.</p>
<p>Reliability is handled via <code>CPacket::pa_ubReliable</code> flag field. The basic idea is to have two types of packets.</p>
<ul>
<li>
<p><strong>Unreliable packets</strong> - these are sent and discarded. They are used when the Engine doesn&#39;t care if the message has reached the destination or not.</p>
</li>
<li>
<p><strong>Reliable packets</strong> - when these are sent, Serious Engine expects to get an <strong>acknowledge packet</strong> (in further text: <strong>ACK</strong>) to confirm the destination has received the packet. In case the ACK isn&#39;t received after some time (timeout), the Engine sends the original packet again - this is called <strong>retransmission</strong>.</p>
</li>
</ul>
<p><code>CPacket::pa_ubReliable</code> is a flag field with the following flags:</p>
<pre><code>#define UDP_PACKET_UNRELIABLE       0
#define UDP_PACKET_RELIABLE         1
#define UDP_PACKET_RELIABLE_HEAD    2
#define UDP_PACKET_RELIABLE_TAIL    4
#define UDP_PACKET_ACKNOWLEDGE      8
#define UDP_PACKET_CONNECT_REQUEST  16
#define UDP_PACKET_CONNECT_RESPONSE 32
</code></pre>
<p>If a packet is to be considered reliable, Serious Engine sets the <code>UDP_PACKET_RELIABLE</code> flag. It is also worth noting that reliable packets can form streams to carry more data than fits into a single packet. The Engine adds <code>UDP_PACKET_RELIABLE_HEAD</code> flag to the first packet in the stream, and <code>UDP_PACKET_RELIABLE_TAIL</code> to the last packet. If the Engine is sending a single reliable packet (i.e. not part of a stream), both <code>UDP_PACKET_RELIABLE_HEAD</code> and <code>UDP_PACKET_RELIABLE_TAIL</code> flags are set for that packet.</p>
<p>Unreliable packets can&#39;t form streams because that wouldn&#39;t make any sense - packet loss could result in a corrupted stream.</p>
<p><strong>Acknowledge (ACK)</strong> packets are sent for received reliable packets. ACK packets are unreliable by design, and only have <code>UDP_PACKET_ACKNOWLEDGE</code> flag set. A single ACK packet can contain acknowledgements for multiple reliable packets - just a series of <code>ULONG</code> (<code>unsigned long</code>) numbers, each representing a sequence number of a packet meant to be acknowledged.</p>
<p>In case no ACK is received for a packet, Serious Engine will attempt retransmission several times before closing the (virtual) connection to the client, and this is kept track of in <code>pa_ubRetryNumber</code>. Number of retries is specified with shell variable <code>net_iMaxSendRetries</code> and can be configured via console or configuration files. It seems to be <code>10</code> by default. It is worth noting that each retransmission will delay the next one by a certain amount of time. This is also configurable with shell variable <code>net_fSendRetryWait</code>, which seems to be <code>0.5f</code> by default. Each retransmission can occur only <code>net_fSendRetryWait</code> seconds after the previous.</p>
<p><code>CPacket::pa_tvSendWhen</code> keeps track of when the packet was supposed to be sent, not including the retransmission penalty. This isn&#39;t only used to calculate when the next retry should occur, but also serves as a simple congestion control mechanism to prevent flooding the client with more messages than they can handle in a certain amount of time. Serious Engine will attempt to approximate a good time in the future to send a particular packet based on the packet size, bandwidth limit, latency limit and latency variation. The latter two are used to simulate real network conditions and are configurable via shell variables (I believe this was only intended for debugging), while the bandwidth limit configuration is also exposed in the options menu:</p>
<p><img alt="Banner" src="https://staniks.github.io/img/articles/serious-engine/network-settings.png" title="Network options menu."/></p>
<p>There options merely execute and persist shell commands in <code>.ini</code> files in <code>Scripts/NetSettings/</code>. For example, <code>ISDN.ini</code>:</p>
<pre><code>cli_bPrediction = 1;
cli_iBufferActions = 2;
cli_iMinBPS = 5000;
cli_iMaxBPS = 10000;
</code></pre>
<p>While prediction only affects the client, the latter three are communicated to the server upon establishing the virtual connection as <code>CSessionSocketParams</code>.</p>
<pre><code>class CSessionSocketParams {
public:
    INDEX ssp_iBufferActions;
    INDEX ssp_iMaxBPS;
    INDEX ssp_iMinBPS;
}
</code></pre>
<p>This allows the server to work with clients with varying connection speeds and quality. Packet time is approximated in <code>CPacketBufferStats::GetPacketSendTime</code>.</p>
<p>As for the rest of the <code>CPacket</code> fields, <code>CPacket::pa_slSize</code> represents the size of packet payload in bytes, while <code>CPacket::pa_slTransferSize</code> represents the size of the stream payload in bytes. In case the packet isn&#39;t part of a stream, these fields are equal.</p>
<p>These packets are the basics for higher-level constructs such as <code>CNetworkMessage</code>, which we&#39;ll cover soon. But first, let&#39;s take a look at how the packets are used in a real multiplayer session.</p>
<h3>The Lifecycle of a Connection <a name="the-lifecycle-of-a-connection"></a></h3>
<p><code>CCommunicationInterface</code> is the main class responsible for packet-layer communication. Among mostly uninteresting socket abstraction and handling, we have three sets of distinct member functions:</p>
<pre><code>// Send an unreliable packet to the specified client.
void Server_Send_Unreliable(INDEX iClient,
                            const void *pvSend,
                            SLONG slSendSize);

// Check if any unreliable packets have arrived from
// the specified client. If so, fill out the buffer
// and the size and return true.
BOOL Server_Receive_Unreliable(INDEX iClient,
                               void *pvReceive,
                               SLONG &amp;slReceiveSize);

// Also: reliable variation.
</code></pre>
<p>And these:</p>
<pre><code>// Send an unreliable packet to the server.
void Client_Send_Unreliable(const void *pvSend, SLONG slSendSize);

// Check if any unreliable packets have arrived from the server.
// If so, fill out the buffer and size and return true.
BOOL Client_Receive_Unreliable(void *pvReceive, SLONG &amp;slReceiveSize);

// Also: reliable variation.
</code></pre>
<p>But also these:</p>
<pre><code>// Sends a packet to a specified CAddress.
void Broadcast_Send(const void *pvSend,
                    SLONG slSendSize,
                    CAddress &amp;adrDestination);

// Check if there are any packets from any address.
// If so, fill out the buffer, size and address and
// return true.
BOOL Broadcast_Receive(void *pvReceive,
                       SLONG &amp;slReceiveSize,
                       CAddress &amp;adrAddress);
</code></pre>
<blockquote>
<p><strong>NOTE:</strong> If you find the above naming confusing, perhaps it&#39;ll help if you think of this as a polymorphic class, with derived classes like <code>CServerCommunicationInterface</code>, <code>CClientCommunicationInterface</code> and <code>CBroadcastCommunicationInterface</code>. But hey, static calls beat polymorphic indirection.</p>
</blockquote>
<p>Notice how the server and the client interfaces both assume the source or destination of the message is already known. In other words, it&#39;s assumed that the virtual connection between the client and the server is already established. However, if you look at the <strong>broadcast interface</strong>, you&#39;ll see that these methods can send and receive packets to and from <strong>any</strong> address - this is used to establish the connection. To understand how this works, we need to explore the concept of <strong>master buffers</strong> and <strong>packet routing</strong>.</p>
<h3>Master Buffers <a name="master-buffers"></a></h3>
<p><code>CCommunicationInterface</code> has two main (master) packet buffers - one for input, and one for output. Every time the Engine calls <code>CCommunicationInterface::UpdateMasterBuffers()</code>, the communication interface will do the following:</p>
<ol>
<li>Poll the socket API (Winsock) to check for and read any incoming UDP packets, deserialize them into <code>CPackets</code> and insert them into the master input buffer (<code>cci_pbMasterInput</code>).</li>
<li>Serialize and send out (via socket API) any <code>CPackets</code> in the master output buffer (<code>cci_pbMasterOutput</code>).</li>
</ol>
<p>Notice how this is very simple - UDP layer is very thin, and all the heavy lifting is done on the higher levels.</p>
<h3>Packet Routing <a name="packet-routing"></a></h3>
<p>This is where things get more interesting. Remember the three interface groups from <code>CCommunicationInterface</code>? They each actually just call the (mostly) same functions of a corresponding <code>CClientInterface</code>.</p>
<pre><code>CClientInterface cm_aciClients[SERVER_CLIENTS];
CClientInterface cm_ciBroadcast;
CClientInterface cm_ciLocalClient;
</code></pre>
<p>The purpose of <code>CClientInterface</code> is to abstract away the complexity of communicating with a client (or the server, if used by the client). When the application is the server, <code>cm_aciClients</code> array is used to provide an interface for each player in the game. If the application is the client, it uses <code>cm_ciLocalClient</code> to communicate with the server. <code>cm_ciBroadcast</code> is used by both the client and the server to establish the connection.</p>
<p><img alt="Communication Interface" src="https://staniks.github.io/img/articles/serious-engine/comminterface.png" title="Communication Interface"/></p>
<p><code>CClientInterface</code> contains simple methods by design:</p>
<pre><code>// Sends a message through the interface.
void Send(const void *pvSend, SLONG slSize, BOOL bReliable);

// Broadcast variant.
void SendTo(const void *pvSend,
            SLONG slSize,
            const CAddress adrAdress,
            BOOL bReliable);
</code></pre>
<p>However, the implementation is a bit more complex. Internally, <code>CClientInterface</code> performs packet ordering and reliability. For this purpose, it contains four main buffers.</p>
<pre><code>CPacketBuffer ci_pbOutputBuffer;
CPacketBuffer ci_pbWaitAckBuffer;
CPacketBuffer ci_pbInputBuffer;
CPacketBuffer ci_pbReliableInputBuffer;
</code></pre>
<p>For now, let&#39;s focus on <code>ci_pbInputBuffer</code> and <code>ci_pbOutputBuffer</code>. As you may have guessed, these are the input and output packet buffers. Input buffer contains packets which were meant to be received by this client interface, and output buffer contains packet which are meant to be sent by this interface. But how do packets end up in <code>ci_pbInputBuffer</code>, and get out of <code>ci_pbOutputBuffer</code>?</p>
<p>They actually come from the <code>CCommunicationInterface</code>&#39;s input master buffer, and end up in its output master buffer, but how does the Engine know which <code>CClientInterface</code> needs to receive a certain packet?</p>
<p>Packet routing!</p>
<p>If you go back a bit and look at the <code>CPacket</code> structure, you&#39;ll see it contains a <code>CAddress</code> object (<code>pa_adrAddress</code>). Let&#39;s have a look what this actually is.</p>
<pre><code>class CAddress {
public:
    ULONG adr_ulAddress;   // IPv4 address.
    UWORD adr_uwPort;      // UDP port.
    UWORD adr_uwID;        // Huh?
}
</code></pre>
<p><code>adr_uwID</code>, depending on its value, may carry either:</p>
<ul>
<li>unique identifier for a client</li>
<li>information that this is a broadcast packet</li>
</ul>
<p>If <code>adr_uwID</code> is equal to <code>&#39;//&#39;</code> (<code>0x2f2f</code>) or <code>0</code>, this packet was meant for, or came from the broadcast interface. Otherwise, it contains a unique client ID for this session.</p>
<p>So, if the packet is a broadcast packet, it&#39;s routed to the broadcast interface, otherwise it is routed to the corresponding client interface. You can see the routing logic performed in <code>Server_Update</code> and <code>Client_Update</code> methods of <code>CCommunicationInterface</code>.</p>
<h3>Establishing a connection <a name="establishing-a-connection"></a></h3>
<p>In order to connect to the server, the client must send a reliable broadcast packet with the <code>UDP_PACKET_CONNECT_REQUEST</code> flag. We can see this in <code>CCommunicationInterface::Client_OpenNet_t</code>:</p>
<pre><code>// Instantiate the connection request packet.
ppaInfoPacket = new CPacket;

// Set the flags.
ubReliable = UDP_PACKET_RELIABLE
             | UDP_PACKET_RELIABLE_HEAD
             | UDP_PACKET_RELIABLE_TAIL
             | UDP_PACKET_CONNECT_REQUEST;

// Set parameters and write a single-byte (useless) payload.
ppaInfoPacket-&gt;pa_adrAddress.adr_ulAddress = ulServerAddress;
ppaInfoPacket-&gt;pa_adrAddress.adr_uwPort = net_iPort;
ppaInfoPacket-&gt;pa_ubRetryNumber = 0;
ppaInfoPacket-&gt;WriteToPacket(&amp;ubDummy,
                             1,
                             ubReliable,
                             cm_ciLocalClient.ci_ulSequence++,
                             &#39;//&#39;,
                             1);
</code></pre>
<p>When the server receives this packet, it will first check whether the client with this address and port (from which the packet came from) is already connected. If so, the packet is simply ignored. If not, the server will look for the first empty client interface and do the following:</p>
<ol>
<li>Generate the unique identifier for that client and assign it to the corresponding <code>CClientInterface</code>.</li>
<li>Send the unique identifier to the client via the <code>UDP_PACKET_CONNECT_RESPONSE</code> reliable broadcast packet.</li>
</ol>
<p>Identifier generation is pretty straightforward:</p>
<pre><code>// This isn&#39;t some cryptographic hash so the timer value will do.
UWORD uwID = _pTimer-&gt;GetHighPrecisionTimer().tv_llValue &amp; 0x0FFF;

// In case we&#39;re so unlucky we hit a broadcast packet marker,
// just increment by one.
if (uwID==0 || uwID==&#39;//&#39;) {
    uwID+=1;
}

// Assign the ID to the client interface.
cm_aciClients[iClient].ci_adrAddress.adr_uwID = (uwID&lt;&lt;4)+iClient;
</code></pre>
<p>From the moment the server sends the response packet, the client is considered connected. The client will then use the provided <code>uwID</code> to identify themselves when sending packets to the server, and the server will properly route the packet to the corresponding client interface.</p>
<p>Why bother with <code>uwID</code>, though? Why not just assign an index?</p>
<p>It prevents impersonation attacks. The attacker would need to guess <code>uwID</code> of the player they would want to impersonate, so the attack surface is lowered. Sure, they could brute-force the <code>uwID</code> by spamming non-broadcast packets and receive an ACK at some point as confirmation, but that wouldn&#39;t be very subtle - non-broadcast packets from non-connected players will cause Serious Engine to emit a warning in the console. You can see this in <code>CCommunicationInterface</code> method <code>Server_Update</code>.</p>
<pre><code>// bClientFound - true if packet came from connected client.
if (!bClientFound) {
    // warn about possible attack
    extern INDEX net_bReportMiscErrors;
    if (net_bReportMiscErrors) {
        CPrintF(TRANS(&#34;WARNING: Invalid message from: %s\n&#34;),
            AddressToString(ppaPacket-&gt;pa_adrAddress.adr_ulAddress));
    }
}
</code></pre>
<h3>Reliability <a name="reliability"></a></h3>
<p>Let&#39;s head back to the <code>CClientInterface</code> and have a look at these buffers again.</p>
<pre><code>CPacketBuffer ci_pbOutputBuffer;
CPacketBuffer ci_pbWaitAckBuffer;
CPacketBuffer ci_pbInputBuffer;
CPacketBuffer ci_pbReliableInputBuffer;
</code></pre>
<p><code>ci_pbWaitAckBuffer</code> is the buffer containing copies of reliable packets which have been sent. In case the Engine doesn&#39;t receive the ACK for these, it will attempt retransmission. The packets are copied into this buffer from <code>ci_pbOutputBuffer</code> before being sent into the master output buffer.</p>
<p><code>ci_pbReliableInputBuffer</code> contains ordered and deduplicated reliable packets. It&#39;s filled just after the packets are routed to the <code>ci_pbInputBuffer</code> from the master input buffer. The Engine iterates through packets in <code>ci_pbInputBuffer</code> and does several things:</p>
<ol>
<li>If the incoming packet is an ACK packet, remove the acknowledged packets from both <code>ci_pbWaitAckBuffer</code> and <code>ci_pbOutputBuffer</code>. Also remove the ACK packet from the input buffer.</li>
<li>If the incoming packet is reliable, then insert it into <code>ci_pbReliableInputBuffer</code>, but only if not already present (deduplication). Also remove the packet from the input buffer, and write it up for acknowledgement.</li>
<li>If the incoming packet is unreliable, leave it in the input buffer.</li>
<li>Generate an ACK packet (or packets) which contain acknowledges for each of the input packets written up for acknowledgement.</li>
</ol>
<p>It&#39;s a simple but elegant system.</p>
<h3>Offline Play <a name="offline-play"></a></h3>
<p>The singleplayer and demo reproduction are just a special case of multiplayer. We still have the server, and still have the client, but here they&#39;re the same process.</p>
<p>It would be somewhat ridiculous to use the network sockets to communicate with something in the same process, so the Engine establishes a simple shortcut. If we observe <code>CCommunicationInterface</code>, we can see this:</p>
<pre><code>void CCommunicationInterface::Client_OpenLocal(void)
{
    CTSingleLock slComm(&amp;cm_csComm, TRUE);

    CClientInterface &amp;ci0 = cm_ciLocalClient;
    CClientInterface &amp;ci1 = cm_aciClients[SERVER_LOCAL_CLIENT];

    ci0.ci_bUsed = TRUE;
    ci0.SetLocal(&amp;ci1);
    ci1.ci_bUsed = TRUE;
    ci1.SetLocal(&amp;ci0);
};
</code></pre>
<p><code>ci0</code> is the virtual client&#39;s <code>CClientInterface</code>, and <code>ci1</code> is the matching <code>CClientInterface</code> as it would be on the server. These client interfaces become paired in <code>CClientInterface::SetLocal</code>:</p>
<pre><code>void CClientInterface::SetLocal(CClientInterface *pciOther)
{
    // ...
    ci_pciOther = pciOther;
    // ...
}
</code></pre>
<p>When two client interfaces are paired, they can exchange buffers by calling <code>CClientInterface::ExchangeBuffers</code>. This will consume packets from one interface&#39;s output buffer and insert them into the other interface&#39;s input buffer, then vice versa. This eliminates the need for sending and receiving everything through master output and input buffers when playing locally.</p>
<p>Buffer exchange is performed in <code>CCommunicationInterface::Server_Update</code>.</p>
<p>And that pretty-much covers the packet layer overview.</p>
<p>There&#39;s a bit more going on in there than I laid out, but I suggest you consult the source code if you want to know more. After all, this is a conceptual overview, so I&#39;d rather not bore the average reader to death with details.</p>
<p><code>CPackets</code> provide a neat layer above the UDP, but they&#39;re still somewhat low-level and awkward to use, at least directly. This is why Croteam introduced another layer above packets - <strong>network messages</strong>.</p>
<h2>The Message Layer <a name="the-message-layer"></a></h2>
<p><code>CNetworkMessage</code> is a message abstraction which can be read from and written into in a stream-like manner. Let&#39;s look at the data members:</p>
<pre><code>class ENGINE_API CNetworkMessage {
public:
    MESSAGETYPE nm_mtType; // Message type (enumeration).

    #define MAX_NETWORKMESSAGE_SIZE 2048
    UBYTE *nm_pubMessage;  // Buffer (allocated on heap).
    SLONG nm_slMaxSize;    // Buffer size.

    UBYTE *nm_pubPointer;  // Read/write pointer.
    SLONG nm_slSize;       // Message size (so far).
    INDEX nm_iBit;         // Next bit index to read/write.

    // ...
};
</code></pre>
<p>I was surprised to find that <code>nm_pubMessage</code> is allocated via <code>AllocMemory</code> which seems to just call <code>malloc</code> under the hood. In fact, memory is allocated this way all over the Engine. There&#39;s a <code>CLinearAllocator</code>, but doesn&#39;t seem to be used anywhere. <code>CNetworkMessage</code> buffers are allocated (and reallocated) quite often, so at some point, some people would argue that the heap could end up looking like swiss cheese.</p>
<p>Well, it&#39;s either that, or I missed a custom allocator implementation somewhere within the Engine codebase. But then again, it&#39;s not like you&#39;d need a long-running server for this kind of game, so you probably wouldn&#39;t even notice; heap fragmentation usually becomes a problem when software is expected to work for days or even weeks.</p>
<p><code>CNetworkMessage</code> is meant to be written into and read from via simple interface:</p>
<pre><code>void Read(void *pvBuffer, SLONG slSize);
void Write(const void *pvBuffer, SLONG slSize);
void ReadBits(void *pvBuffer, INDEX ctBits);
void WriteBits(const void *pvBuffer, INDEX ctBits);
</code></pre>
<p>but also like a stream:</p>
<pre><code>inline CNetworkMessage &amp;operator&gt;&gt;(SLONG &amp;sl);
inline CNetworkMessage &amp;operator&gt;&gt;(SWORD &amp;sw);

// ...

inline CNetworkMessage &amp;operator&lt;&lt;(const SLONG &amp;sl);
inline CNetworkMessage &amp;operator&lt;&lt;(const SWORD &amp;sw);

// ...

void Rewind(void);
</code></pre>
<p>Messages can also contain submessages (serialized version of themselves). Once the message buffer contains all the data needed, the buffer can be reallocated to fit the data (<code>CNetworkMessage::Shrink</code>).</p>
<h3>Message Compression <a name="message-compression"></a></h3>
<p>It&#39;s also worth noting that messages can be compressed by either specifying a <code>Compressor</code> or using the default one based on <code>nm_mtType</code>. The enumeration (<code>MESSAGETYPE</code>) is actually just the lower 6 bits, while the remaining two indicate a type of compression used. This can be either:</p>
<ul>
<li>LZ77 (<code>CzlibCompressor</code>)</li>
<li>LZRW1 (<code>CLZCompressor</code>)</li>
<li>uncompressed</li>
</ul>
<p>LZRW1 seems to be used by default. This can be changed via shell variable <code>net_iCompression</code>, most likely just for development purposes.</p>
<p>Also, remember <code>CPlayerAction</code> from the beginning of the article? If we peek into <code>PlayerBuffer::CreateActionPacket</code>, we can see this piece of code:</p>
<pre><code>CPlayerAction paDelta;
for (INDEX i=0; i&lt;sizeof(CPlayerAction); i++) {
    ((UBYTE*)&amp;paDelta)[i] = ((UBYTE*)&amp;paCurrent)[i]
                            ^ ((UBYTE*)&amp;plb_paLastAction)[i];
}
</code></pre>
<p>The <code>CPlayerAction</code> here is being prepared for sending, but the structure itself isn&#39;t being sent, but rather its <em>delta</em>, which is just a result of a XOR operation between the current and the last player action sent.</p>
<p>Then again, in <code>PlayerTarget::ApplyActionPacket</code>, which is meant to be processed by the receiving end, we can see this:</p>
<pre><code>for (INDEX i=0; i&lt;sizeof(CPlayerAction); i++) {
    ((UBYTE*)&amp;plt_paLastAction)[i] ^= ((UBYTE*)&amp;paDelta)[i];
}
</code></pre>
<p>The <code>CPlayerAction</code> is being XOR-ed back, yielding the desired player action. But why go through all this trouble? Why not just send the <code>CPlayerAction</code>, thus avoiding calculating the delta and reconstructing the action structure?</p>
<p>Because a <strong>delta can be compressed more efficiently</strong> when the data hasn&#39;t changed much.</p>
<p>And in this particular case, data really doesn&#39;t change that much; for example, <code>CPlayerAction</code> contains information about keys being held down, and players often hold the same keys for a period over several frames, so it makes sense to minimize the amount of information being sent over the network (or being written to a file). Same goes for velocity and view rotation - they don&#39;t cover the full range of the floating point, so there&#39;s usually very little change there.</p>
<p>We might not see the benefit of this when sending a single client action (e.g. from client to server), but rather when they&#39;re being sent in bulk, as server does via <code>MSG_SEQ_ALLACTIONS</code>.</p>
<p>Neat trick, huh? It&#39;s actually a well-known and established concept called <a href="https://en.wikipedia.org/wiki/Delta_encoding">delta encoding</a>.</p>
<h3>Message Security <a name="message-security"></a></h3>
<p>Messages aren&#39;t encrypted. Most people would agree that observing a way someone dodges a Kleer or a Sirian Werebull is hardly a meaningful privacy violation.</p>
<p>However, that may not be true for chat messages.</p>
<p>If we put on our tinfoil hat and disable message compression:</p>
<pre><code>/net_iCompression=0
</code></pre>
<p>By sending a chat message in-game, we can see the UDP packet and its payload. Since it&#39;s transmitted in plaintext, we can see the whole message.</p>
<p><img alt="Wireshark output" src="https://staniks.github.io/img/articles/serious-engine/wireshrek.png" title="Wireshark output"/></p>
<p>Sure, in real-case scenario, the compression would be enabled and someone sniffing for UDP packets would have to go through the trouble of figuring out this is a LZ-compressed stream and then decompress it, but they&#39;d have everything they need in order to do it.</p>
<p>So yeah - the original Serious Sam multiplayer sessions might not be the best place to have very private conversations. But then again, it&#39;s not like people play this game to <em>slide into DMs</em>.</p>
<p>This isn&#39;t anything controversial or particularly concerning, though - most games from that time didn&#39;t deal with encryption simply because it wasn&#39;t necessary, or would perhaps increase complexity since it would require implementing mechanisms like authentication and key exchange.</p>
<p>Also, at the time, most of the web was still on HTTP.</p>
<h3>Message Dispatcher <a name="message-dispatcher"></a></h3>
<p><code>CMessageDispatcher</code> is essentially a wrapper around the packet layer.</p>
<p>It invokes <code>CCommunicationInterface</code>&#39;s functions to send packets with the <code>CNetworkMessage</code>&#39;s content, or receive a <code>CNetworkMessage</code> by reading the packet content.</p>
<p>Its job is also to prepare the <code>_cmiComm</code> (global <code>CCommunicationInterface</code>) for use based on the selected <code>CNetworkProvider</code>. This is actually just a description wrapper, and can be:</p>
<ul>
<li><code>Local</code></li>
<li><code>TCP/IP Server</code></li>
<li><code>TCP/IP Client</code></li>
</ul>
<p>&#34;Preparation for use&#34; here is basically just deciding whether to open the socket and how to open it.</p>
<ul>
<li><code>Local</code> is used when playing singleplayer or the demo recording. Winsock isn&#39;t initialized here, so no socket either.</li>
<li><code>TCP/IP Server</code> is used when hosting. The socket is opened on the port specified by <code>net_iPort</code> shell variable.</li>
<li><code>TCP/IP Client</code> is used when we&#39;re the client. It also opens the socket, but the Engine lets the socket API decide on the port, since it doesn&#39;t matter.</li>
</ul>
<h2>The Game Session Layer <a name="the-game-session-layer"></a></h2>
<p>To see network messages in action, let&#39;s take a step back and get a bit broader look at how Serious Engine manages a multiplayer game. We&#39;ll skip the outer layers dealing with platform specifics, timing and rendering, and just focus on game logic and communication, and that&#39;s mostly packed in <code>CNetworkLibrary</code>.</p>
<p>A seemingly unusual place for game logic, isn&#39;t it?</p>
<p><code>CNetworkLibrary</code>, despite its peculiar naming choice, is a class that houses and manages the game state (<code>CSessionState</code>), among other things. It&#39;s inherited from <code>CMessageDispatcher</code> we mentioned earlier.</p>
<p>The scope of <code>CNetworkLibrary</code> a bit wide and there&#39;s a lot going on there, so I&#39;ll rather attempt to simplify how the whole thing works without going into too much detail - if I start speaking in classes, this would become an unreadable mess.</p>
<h3>Hosting a Game <a name="hosting-a-game"></a></h3>
<p>Let&#39;s assume we want to start a server. Upon hosting the game (<code>CNetworkLibrary::StartPeerToPeer_t()</code>), the Engine will do the following:</p>
<ol>
<li>Initialize CRC (cyclic redundancy check) gathering. This is used later to determine whether the connecting clients have the same files as the server. This isn&#39;t a cheat prevention method, but rather a way to detect desynchronization early.</li>
<li>Create a new session state (<code>CSessionState</code>), serialize it and store it into <code>ga_pubDefaultState</code>. This is considered the default state and will be used as a baseline for calculating <strong>state deltas</strong> later on.</li>
<li>Load the local world instance.</li>
<li>Initialize the global communication interface.</li>
<li>Set up and initialize the local session state (<code>ga_sesSessionState</code>). When clients connect, they will receive a <strong>state delta</strong> - a difference between the default (baseline) state and the server&#39;s local state. This is required because clients can connect to a game already in progress. The local client is also initialized here (if not dedicated server).</li>
<li>Finish CRC gathering. At this point CRC of files is stored in <code>ga_ulCRC</code>. When clients connect, they will request a list of filenames to check (<code>MSG_REQ_CRCLIST</code>). The server will then send a list of filenames (<code>MSG_REQ_CRCCHECK</code>), and the client will produce a CRC of their copies of these files, then send it to the server (<code>MSG_REP_CRCCHECK</code>). If CRCs don&#39;t match, the client is disconnected.</li>
</ol>
<p>At this point, the server is considered up and running, and we have entered the game logic loop (<code>CNetworkLibrary::MainLoop()</code>).</p>
<h3>Joining a Game <a name="joining-a-game"></a></h3>
<p>Joining a game is done via <code>CNetworkLibrary::JoinSession_t()</code>. The function receives a <code>CNetworkSession</code> parameter which contains, among various session information, a server address. This is either instantiated via polling the GameAgent (part of the engine responsible for session discovery) or manually, via the class constructor. Upon joining the game, the client will do the following:</p>
<ol>
<li>Initialize CRC gathering, just like the server.</li>
<li>Set up and initialize an empty local session state.</li>
<li>Initialize the global communication interface.</li>
<li>Send a connection request message (<code>MSG_REQ_CONNECTREMOTESESSIONSTATE</code>). It contains the build version, mod name, server password, amount of local players on this client (in case of split-screen) and serialized <code>CSessionSocketParams</code> (connection quality information).</li>
<li>Wait for the response in form of <code>MSG_REP_CONNECTREMOTESESSIONSTATE</code>. It contains message of the day, world filename, spawn flags (difficulty, game mode) and session properties.</li>
<li>Initialize the baseline game state using received information (much like the server).</li>
<li>Send a <code>MSG_REQ_STATEDELTA</code> message. This requests a state delta between the baseline state (which <em>should</em> be equal on the client and the server) and the server&#39;s current local state.</li>
<li>Await a response in form of <code>MSG_REP_STATEDELTA</code>. Upon decompression, a reverse diff is performed to reconstruct the game state stream.</li>
<li>Initialize the local session state with the reconstructed stream via <code>CSessionState::Read_t()</code>.</li>
<li>Perform a CRC check with the server (<code>MSG_REQ_CRCLIST</code>/<code>MSG_REP_CRCCHECK</code>). Disconnect in case of mismatch.</li>
</ol>
<p>At this point, the client is considered connected to the server and the Engine will enter the game loop, just like the server.</p>
<h3>Starting a Demo Playback <a name="starting-a-demo-playback"></a></h3>
<p>Demo playback is initialized via <code>CNetworkLibrary::StartDemoPlay_t()</code>. It receives a filename string as a parameter. In comparison to multiplayer, it&#39;s very simple:</p>
<ol>
<li>Parse the demo file, read the header and the version.</li>
<li>Initialize <code>ga_sesSessionState</code> with the serialized game state from this point in the file stream.</li>
</ol>
<p>At this point, the client is playing the demo and will enter the main loop.</p>
<h3>The Main Loop <a name="the-main-loop"></a></h3>
<p>The main loop is actually very similar for both the client and the server, with a few exceptions.</p>
<ol>
<li>Update<sup>*</sup> the local client communication interface (<code>cm_ciLocalClient</code>) and the broadcast communication interface (<code>cm_ciBroadcast</code>).</li>
<li>Have the local session state handle the incoming network messages.</li>
<li>[<code>SERVER ONLY</code>] Exchange buffers between paired client interfaces, then update each of the server-side client communication interfaces (<code>cm_aciClients</code> array). Also update the local client and the broadcast interface again.</li>
<li>Have the local session state process its game stream.</li>
<li>[<code>SERVER ONLY</code>] Handle GameAgent update (stuff for server browser).</li>
<li>[<code>SERVER ONLY</code>] Handle remote administration shell commands, if any were sent since the last iteration.</li>
</ol>
<p>(<sup>*</sup>) <em>Updating a communication interface is essentially updating its four main buffers, performing message routing, etc. See packet layer section.</em></p>
<p><code>CSessionState</code> handles incoming network messages via <code>SessionStateLoop()</code> function. Let&#39;s look at this function more closely. It handles the following message types:</p>
<p><em>Unreliable messages</em></p>
<ul>
<li><code>MSG_GAMESTREAMBLOCKS</code> - message containing game stream blocks. These are stored into the state&#39;s internal buffer to be processed later.</li>
<li><code>MSG_KEEPALIVE</code> - when received, use current time as time of session start.</li>
<li><code>MSG_INF_PINGS</code> - message containing pings of all players.</li>
<li><code>MSG_CHAT_OUT</code> - message containing a chat message.</li>
</ul>
<p><em>Reliable messages</em></p>
<ul>
<li><code>MSG_INF_DISCONNECTED</code> - message containing the reason why the client was disconnected.</li>
<li><code>MSG_ADMIN_RESPONSE</code> - message containing remote administration response.</li>
</ul>
<p>For some of these messages, responses are generated right here. However, notice how <code>MSG_GAMESTREAMBLOCKS</code> is an unreliable message. But isn&#39;t this information important? <strong>Would we not desync immediately if we miss even just one of these messages?</strong></p>
<p>We definitely would. But retransmission logic for this is handled later, when the local session state processes its game stream - <code>CSessionState::ProcessGameStream</code>. If we look into it, we can see this patch of code:</p>
<pre><code>// Calculate the index of the next expected sequence.
INDEX iSequence = ses_iLastProcessedSequence+1;

// Get the stream block with that sequence.
CNetworkStreamBlock *pnsbBlock;
CNetworkStream::Result res = ses_nsGameStream.GetBlockBySequence(iSequence,
                                                                 pnsbBlock);
</code></pre>
<p>Three things can happen when fetching a game stream block by sequence:</p>
<ol>
<li>The block with the next expected sequence <strong>is</strong> found. In this case, we continue onto processing the block (<code>CSessionState::ProcessGameStreamBlock</code>).</li>
<li>The block with the next expected sequence <strong>isn&#39;t found</strong>, but we don&#39;t have any more recent blocks (i.e. with larger sequence number). In this case we don&#39;t do anything this iteration of the main loop.</li>
<li>The block with the next expected sequence <strong>isn&#39;t found</strong>, but we <strong>already have at least one more recent block.</strong> This means the block might have been lost, and we may have to perform retransmission.</li>
</ol>
<p>However, there is no always need for retransmission in case of (3). The block may have simply been late due to nature of UDP. Instead of requesting retransmission immediately when we encounter a missing block, we mark this sequence as missing and set up a timeout. Then, next time the main loop ends up here and the timeout has passed, we send a retransmission request (<code>MSG_REQUESTGAMESTREAMRESEND</code>) which contains:</p>
<ul>
<li>the sequence of the missing block</li>
<li>number of missing blocks, determined by looking up the difference between the most recent received block sequence and the missing block sequence</li>
</ul>
<p>The server will then re-send these blocks.</p>
<p>Let&#39;s head over to <code>CSessionState::ProcessGameStreamBlock</code> to see how the game stream blocks actually get processed. Just to get your bearings:</p>
<pre><code>CNetworkLibrary::MainLoop();
    ga_sesSessionState.ProcessGameStream();
        ProcessGameStreamBlock(*pnsbBlock); // We&#39;re here!
</code></pre>
<p>Remember the game stream block types from the beginning of the article? We&#39;re finally here.</p>
<p><code>MSG_SEQ_ADDPLAYER</code> is sent when a player joins the game. It contains a player index and a <code>CPlayerCharacter</code> descriptor (guid, name, team, appearance). When received, the local game session state will check whether the corresponding <code>CPlayerEntity</code> already exists in the game world - in case a player was disconnected and is reconnecting. If not, a new <code>CPlayerEntity</code> will be added to the game world. In any case, the entity becomes linked with a corresponding player target. <code>CPlayerTarget</code> is a utility class to which player actions are passed and which applies these actions to the linked player entity.</p>
<p><code>MSG_SEQ_REMPLAYER</code> is sent when a player is disconnected from the game. It contains just the player index. When received, the player entity is disconnected from its player target, and the player target is deactivated.</p>
<p><code>MSG_SEQ_CHARACTERCHANGE</code> is sent when a player changes an aspect of their character. It contains a player index and a <code>CPlayerCharacter</code> descriptor. The player can change their name, team or appearance. Appearance seems to be application specific - it&#39;s just a 32-byte buffer. In Serious Sam, this buffer houses a <code>CPlayerSettings</code> structure which contains the filename of the player model, weapon auto select policy, crosshair type and various flags (all customizable via in-game options menu).</p>
<p><code>MSG_SEQ_PAUSE</code> is sent when the game gets paused or unpaused by someone. It contains whether the game should be paused or unpaused (<code>BOOL</code>) and a string containing the name of the player who requested the change. It affects <code>CSessionState::ses_bPause</code> - when false, the game state is not advanced, nor the player actions are being generated. When this message is received, the pauser&#39;s name is printed in the console. <em>As it should be.</em></p>
<p><code>MSG_SEQ_ALLACTIONS</code> is the most interesting of these. It contains a floating point header which represents time - this is additionally used for diagnostics, to emit a warning in case these blocks are sent too often. It&#39;s then passed to <code>ProcessGameTick()</code>, along with the rest of the message.</p>
<p>The time value is used as a current tick time in the local session. The session&#39;s player targets are being iterated here, and for each, the Engine deserializes a <code>CPlayerAction</code> from the message and then applies it to the player target. After the player targets are done, we have this:</p>
<pre><code>// Update timers. Generate events, etc.
HandleTimers(tmCurrentTick);
// Handle moving entities, physics.
HandleMovers();
</code></pre>
<p>I could go into this, but I&#39;d rather keep the scope of this tutorial limited to networking. This logic is something that everyone&#39;s local game state performs regardless of networking, and the only important thing is that everyone does it exactly the same. We have a synchronization check to confirm that:</p>
<pre><code>MakeSynchronisationCheck();
</code></pre>
<p>This will iterate through various objects with <code>ChecksumForSync()</code> (entities, player targets...) and produce a <code>CSyncCheck</code> object which contains the CRC with some additional info. If <code>CSyncCheck</code> is produced on the server, it&#39;s buffered.</p>
<p>Upon the check, <code>MSG_SYNCCHECK</code> message containing the <code>CSyncCheck</code> is sent to the server and the server disconnects the client if there&#39;s a discrepancy in relation to the server&#39;s local state.</p>
<p>And that&#39;s mostly it. Sure, there&#39;s a lot more going on in this loop than I covered, but then this analysis wouldn&#39;t be a short analysis anymore - let&#39;s keep it simple.</p>
<h3>Prediction <a name="prediction"></a></h3>
<blockquote>
<p><strong>NOTE:</strong> I purposefully omitted prediction-related stuff from the main loop explanation to avoid confusion, but we&#39;ll cover the most relevant stuff here.</p>
</blockquote>
<p>Did you ever hook up your PC or a videogame console to an old TV with huge HDMI input latency? You move the thumbstick and then release it, and then, half a second later, you see your character do the same. It doesn&#39;t feel very interactive.</p>
<p>Now imagine that, instead of TV input, we&#39;re dealing with internet latency. Let&#39;s look at a simple use-case of moving the character in a Serious Sam multiplayer session. We&#39;re a client, and we press a movement key. Assuming there&#39;s no prediction, the player action gets sent to the server, the server eventually simulates its local state and sends <code>MSG_SEQ_ALLACTIONS</code>, which contains all the player actions, including ours. The problem is, we see our character move only after the player actions have been received:</p>
<p><img alt="Latency" src="https://staniks.github.io/img/articles/serious-engine/prediction.png" title="Latency"/></p>
<p>And this is the best case scenario - it becomes even worse if you take packet loss or varying network conditions into account.</p>
<p><strong>Prediction</strong> is a mechanism which helps mitigate this a bit.</p>
<p>In a nutshell, prediction is just a fancy way of saying &#34;we&#39;re going to be extrapolating because packet round-trip time makes fast-paced games feel unresponsive.&#34; In other words, the Engine will try to &#34;guess&#34; where the entities will be in the future without awaiting the action response from the server.</p>
<p>Due to the nature of Serious Engine multiplayer, it is enough to guess player actions, and the rest of the simulation will follow suit. We have two cases:</p>
<ul>
<li>prediction for the local player<ul>
<li>the Engine will use actions sent to the server</li>
</ul>
</li>
<li>prediction for remote players<ul>
<li>the Engine will use last received action from the server</li>
</ul>
</li>
</ul>
<p>Why even wait for player action messages from the server before simulating local state, anyway? Why not just send the action packets and proceed to simulate the world using the sent information?</p>
<p>Because we can&#39;t know what the other players did, and they have direct impact on the game state - we would get desynchronization. To avoid mixing the actual and the predicted game state, Serious Engine employs <strong>predictors</strong>.</p>
<p>A predictor is kind of a &#34;ghost&#34; entity, which is paired to a regular entity in the game world. It&#39;s essentially a copy of the entity with some special flags. There are two types of predictors:</p>
<ul>
<li><strong>Predictor</strong> - a predictor for an existing entity in the game state.</li>
<li><strong>Temporary predictor</strong> - a predictor spawned during prediction. It has no linked entity, since it doesn&#39;t exist in the game state.</li>
</ul>
<p>A <strong>predicted entity</strong> is an entity for which a <strong>predictor</strong> currently exists. When processing predicted game tick, only <strong>predictor entities</strong> are processed. Every time the client receives player actions from the server, the predictors are destroyed and a new prediction cycle begins.</p>
<blockquote>
<p>The nomenclature can be a bit confusing, so just to recap...</p>
<ul>
<li>predictable entity - entity which is meant to be predicted if needed</li>
<li>predictor entity - a copy of an entity, used for prediction</li>
<li>predicted entity - a predictable entity for which a predictor exists</li>
</ul>
</blockquote>
<p>When rendering, <strong>predicted</strong> entities are not rendered - their <strong>predictors</strong> are rendered instead. This gives the illusion of advancing the game state, while the original game state has not changed in any meaningful way.</p>
<p>As for the implementation, prediction is processed just after processing the game stream.</p>
<pre><code>ga_sesSessionState.ProcessGameStream();

// ...

if (bUsePrediction) {
    ga_World.UnmarkForPrediction();
    ga_World.MarkForPrediction();

    ga_sesSessionState.ProcessPrediction();

    ga_World.UnmarkForPrediction();
}
</code></pre>
<p><code>ga_World</code> is a global <code>CWorld</code> instance. In <code>UnmarkForPrediction</code>, the Engine iterates through entities to be predicted and removes <code>ENF_WILLBEPREDICTED</code> flag from the entity&#39;s <code>en_ulFlags</code>. <code>MarkForPrediction</code> does the opposite - it sets the flag on any predictable entities and player entities.</p>
<p>A <strong>predictable entity</strong> is any entity with a <code>ENF_PREDICTABLE</code> flag in its <code>en_ulFlags</code>. This is typically set in a constructor of an entity class via <code>SetPredictable</code>, which also adds the entity to the world&#39;s <code>wo_cenPredictable</code> collection.</p>
<p>As you may have guessed, <code>CSessionState::ProcessPrediction</code> is the prediction equivalent of <code>CSessionState::ProcessGameStream</code>.</p>
<p>It starts by guessing how many ticks can be predicted. To understand this, let&#39;s look at <code>CPlayerTarget</code> members:</p>
<pre><code>class CPlayerTarget {
public:
    BOOL plt_bActive;                     // True if player connected.
    CPlayerEntity *plt_penPlayerEntity;   // Linked player entity.
    CTCriticalSection plt_csAction;       // Access mutex.
    CPlayerAction plt_paPreLastAction;    // Action before last received action.
    CPlayerAction plt_paLastAction;       // Last received action.
    CActionBuffer plt_abPrediction;       // Buffer of sent actions.
    FLOAT3D plt_vPredictorPos;            // Last position of predictor.
</code></pre>
<p><code>plt_abPrediction</code> is interesting in because it&#39;s a buffer of actions which were sent to the server since the last received <code>MSG_SEQ_ALLACTIONS</code>. If we sent only <code>N</code> actions, it only makes sense to predict the following <code>N</code> ticks at the most.</p>
<p>When the Engine knows the number of ticks to predict, it will continue to cache the RNG seed and next entity ID (to avoid corrupting the game state), and after this, delete all existing predictors and instantiate new ones (<code>CWorld::CreatePredictors</code>). Then, for each tick that can be predicted, the Engine calls <code>CSessionState::ProcessPredictedGameTick</code>.</p>
<p>This function is the prediction equivalent of <code>CSessionState::ProcessGameTick</code>. Functionality is similar as well - except the that we apply predicted actions to the player targets, and that we set <code>ses_bPredicting</code> to <code>TRUE</code>, which lets the game logic functions know we&#39;re currently processing prediction and not affecting the actual game state.</p>
<p><code>CPlayerTarget::ApplyPredictedAction</code> is the prediction equivalent of <code>CPlayerTarget::ApplyActionPacket</code>. However, instead of action delta for the parameter, we have two things:</p>
<ul>
<li><code>iAction</code> - index of the action in the <code>plt_abPrediction</code> buffer, used for local players only</li>
<li><code>fFactor</code> - interpolation factor, used for remote players only</li>
</ul>
<p>When predicting the local player, <code>iAction</code> simply becomes the index of the prediction step (range <code>[0, number of predicted steps]</code>). Since prediction step count is capped at number of buffered actions, this is safe.</p>
<p><code>fFactor</code> is a bit more interesting because it&#39;s used only when action interpolation (<code>cli_bLerpActions</code>) is enabled in the console. When predicting the remote player, we have two cases:</p>
<ul>
<li>if <code>cli_bLerpActions</code> is <strong>disabled</strong>, the predicted action is simply the last received action for that player</li>
<li>if <code>cli_bLerpActions</code> is <strong>enabled</strong>, the predicted action is a result of linear interpolation between the last two actions received for that player</li>
</ul>
<p>Honestly, I am not sure how enabling <code>cli_bLerpActions</code> is beneficial. Repeating the last received player action seems reasonable enough, which is likely why <code>cli_bLerpActions</code> is disabled by default.</p>
<p>Once the prediction ticks are processed and the prediction cycle done, RNG seed and entity ID are restored and the prediction has finished for an iteration of the main loop.</p>
<p>Upon rendering, the Engine will simply skip over the entities which are being predicted, and render predictors instead.</p>
<pre><code>void CRenderer::AddModelEntity(CEntity *penModel)
{
    //...

    // Skip the entity if predicted, predicted entities should not be rendered.
    if( penModel-&gt;IsPredicted() &amp;&amp; !gfx_bRenderPredicted) return;
</code></pre>

<h2>Comparison with Doom and Quake <a name="comparison-with-doom-and-quake"></a></h2>
<p>It may be interesting to compare Serious Engine&#39;s networking model to the similar shooters that came before.</p>
<p>For example, it&#39;s somewhat reminiscent of Doom&#39;s networking. Even though Doom was actually peer-to-peer, clients exchanged a structure similar to <code>CPlayerActions</code> and each ran their own simulation independently. Doom used a similar system <a href="https://doomwiki.org/wiki/Demo#Technical_information">for demo recording and playback</a> as well. Since Doom source code was released in 1997, it may be possible that Croteam were inspired by this concept when they were developing the Serious Engine, but I&#39;m just speculating here.</p>
<p>Quake, on the other hand, was much different. Instead of having each client simulate their own independent game state, the clients were &#34;dumb&#34; - they merely served as message relays and dind&#39;t process any significant game logic on their own, but rather received constant updates of the game state from the server. Neat thing about this concept is not having to worry about desynchronization, and the fact it&#39;s easier to prevent cheating (e.g. the server could omit sending information about entities behind walls).</p>
<p>Why Croteam didn&#39;t opt for this kind of networking, I can&#39;t know for sure, but I guess it has to do with the fact that Serious Sam&#39;s game sessions typically have much more active enemies and objects in the world than Quake, and thus, sending updates for that many objects each tick would likely kill the bandwidth. But as I said - I can only speculate.</p>
<h2>Message Portability <a name="message-portability"></a></h2>
<p>If you peek at the network messages, you can see some structs are being serialized with reinterpret casts. Let&#39;s consider the case of sending a synchronization check message.</p>
<pre><code>CSyncCheck sc;

CNetworkMessage nmSyncCheck(MSG_SYNCCHECK);
nmSyncCheck.Write(&amp;sc, sizeof(sc)); // Oooof.
_pNetwork-&gt;SendToServer(nmSyncCheck);
</code></pre>
<p>Since the developers were likely using a single compiler for all the clients, they could get away with this, but when developing a cross-platform game, this is where things get a bit slippery. The C++ standard doesn&#39;t guarantee exactly the same structure layout across different compilers. Compilers may insert padding bytes to align members for faster access, and this padding may vary, so in the end, the resulting structs could end up different.</p>
<p>E.g. when compiling a 32-bit executable, the compiler might attempt to align members to 4-byte boundary, and 8-byte boundary for 64-bit executables.</p>
<p>There&#39;s also the matter of endianness as well (e.g. x86 PC is little-endian, PS3 is big-endian).</p>
<p>But again - the luxury of having a single compiler and developing for a single platform basically made these issues go away.</p>
<h2>Final Thoughts <a name="final-thoughts"></a></h2>
<p>To recap, Serious Engine is an interesting example of a well-thought-out architecture in regard to multiple game modes. The system is fairly elegant since it abstracts away the specifics of the transport medium, be it network or a file, from the game logic.</p>
<p>Due to the nature of the multiplayer model in which everyone maintains a copy of the game state, cheating is possible - for example, it&#39;s possible to create a hacked client which would display outlines of other players behind walls, and thus gain an advantage in deathmatch. But let&#39;s be honest here - no one plays this game for the deathmatch, most of the people are here for the co-op.</p>
<p>This was an interesting experience which gave me some pretty good ideas to experiment with and possibly incorporate into my hobby games. Tearing apart other people&#39;s work to see how it ticks seems like a good way to learn a thing or two.</p>
<p>Once again, do keep in mind that I barely scratched the surface here - I didn&#39;t even cover the entirety of networking, only the parts I found most interesting. There&#39;s much to be said about the other parts of the Serious Engine, but this could be a topic for another time. Even this article came out longer than I originally intended!</p>
<p>If you liked the writeup, consider <a href="https://twitter.com/Sklopec">following me on Twitter</a>.</p>
<p>Until next time!</p></section></div>
  </body>
</html>
