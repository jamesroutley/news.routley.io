<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://verdagon.dev/blog/exploring-seamless-rust-interop-part-2">Original</a>
    <h1>Crossing the impossible FFI boundary, and my gradual descent into madness</h1>
    
    <div id="readability-page-1" class="page"><div class="page">
    <div>
  

        <div>
          <div>
  

            <div>
    

              
    

              <p>Committing language interop sins for science</p>
        

              <p><span>June 17, 2024</span>
        

                <span> — </span>
          

                
        

              </p>
      

            </div>
    
<section>
<p>
Anyone trying to make a new mainstream language is <b>completely insane,</b> unless they&#39;re backed by a large corporation. <a href="#note0" data-noteid="0">0</a>
</p>

</section>
<section>
<p>
There are only two exceptions in the last 25 years that come close: Scala and Kotlin. <a href="#note1" data-noteid="1">1</a> <a href="#note2" data-noteid="2">2</a> They did this by <b>seamlessly building on an existing ecosystem,</b> specifically Java&#39;s.
</p>

</section>
<section>
<p>
But what if you&#39;re a low-level, memory-safe language like Vale, Austral, or Ante? There&#39;s no existing ecosystem of fast, memory-safe code to use.
</p>

</section>
<section>
<p>
And unfortunately, <b>seamlessly building on Rust&#39;s ecosystem is impossible...</b>
</p>

</section>
<section>
<p>
...or so we thought!
</p>

</section>
<section>
<h2 id="the-impossible-task">
 The impossible task</h2>

</section>
<section>
<p>
Anyone who has tried to make Java call C, or Python call Javascript, or C call Rust, can tell you that it&#39;s <b>really difficult to call functions from other languages.</b>
</p>

</section>
<section>
<p>
Heroes throughout the ages have created tools like <a href="https://www.swig.org/Doc1.3/Java.html">SWIG</a>, <a href="https://cxx.rs/">CXX</a>, etc. which at least make it <i>possible</i> for a user to reach across the Foreign Function Interface (FFI) boundary, if they can figure out the correct incantations. <a href="#note3" data-noteid="3">3</a>
</p>

</section>
<section>
<p>
But even with these tools, it&#39;s so difficult that we often just give up and call a microservice instead. <a href="#note4" data-noteid="4">4</a>
</p>

</section>
<section>
<p>
Calling into Rust is even harder; you can&#39;t just slap an <span>extern</span> onto your function, because Rust <a href="https://www.reddit.com/r/rust/comments/ss2p6c/what_does_it_mean_when_people_say_that_rust_does/">doesn&#39;t have a stable ABI</a>; <span>rustc</span>-compiled functions don&#39;t have a predictable signature that the linker can recognize.
</p>
<p>
On top of that, we can&#39;t send normal Rust objects to C. We instead have to make new structs with <span>#[repr(C)]</span>, which have rather restrictive rules about what they can contain.
</p>

</section>
<section>
<p>
And there are even more challenges here!
</p>
<ol>
<li>
Rust has generics. If our language defines <span>OurStruct</span>, how would Rust create a <span>Vec&lt;OurStruct&gt;</span> when <span>rustc</span> doesn&#39;t know anything about <span>OurStruct</span>, like how big it is?
</li>
<li>
If calling from a language without a borrow checker, how do we uphold the Rust code&#39;s memory safety guarantees?
</li>
<li>
In the case of Vale, how do we uphold other guarantees that Rust doesn&#39;t respect, like <a href="https://verdagon.dev/blog/higher-raii-uses-linear-types">higher RAII</a>, <a href="https://verdagon.dev/blog/fearless-ffi">fearless FFI</a>, determinism, and <a href="https://verdagon.dev/blog/perfect-replayability-prototyped">perfect replayability</a>?
</li>
</ol>

</section>
<section>
<p>
It&#39;s a no-man&#39;s land that we dare not tread on, an uncrossable chasm, a mountain-sized wall of ice that we dare not scale. <a href="#note5" data-noteid="5">5</a>
</p>

</section>
<section>
<p>
But before we talk about how it could be done, what would it even look like?
</p>

</section>

      </div>
  
<div>

      <nav>
      <p>Crossing the Impossible FFI Boundary, and My Gradual Descent Into Madness</p>
    


      </nav>
      
    

      <div>
        <div>
    
<div id="note0" data-noteid="0">
<p><span>0</span></p><section>
<p>
Of course, being insane is a prerequisite for being a language geek, so that&#39;s not really a problem for most of us.
</p>

</section>
</div>
<div id="note1" data-noteid="1">
<p><span>1</span></p><section>
<p>
Though it could be said that Kotlin didn&#39;t reach mainstream until Google came in and adopted it for Android. A fair point!
</p>

</section>
</div>
<div id="note2" data-noteid="2">
<p><span>2</span></p><section>
<p>
 Using stats from <a href="https://madnight.github.io/githut/#/pull_requests/2024/1">GitHut</a>, <a href="https://pypl.github.io/PYPL.html">PYPL</a>, and <a href="https://spectrum.ieee.org/the-top-programming-languages-2023">IEEE</a>.
</p>
<p>
More than 25 years old: Java, JS, C, C++, Python, Java, Perl, PHP, Ruby, C#, SQL, Lua.
</p>
<p>
Newer, but backed by a large corporation: Go, Rust, Swift, Dart, TS.
</p>
<p>
Nix, Bash, Groovy, Matlab, SAS, and HTML are also high in some rankings.
</p>

</section>
</div>
<div id="note3" data-noteid="3">
<p><span>3</span></p><section>
<p>
And even with the correct incantations, one has to reconcile fundamental differences between languages&#39; memory models. If your C code forgets to call <a href="https://docs.python.org/3/c-api/refcounting.html">Py_INCREF</a>, you might accidentally summon some demons from the fourth eldritch plane.
</p>

</section>
</div>
<div id="note4" data-noteid="4">
<p><span>4</span></p><section>
<p>
Calling a microservice instead, as is tradition!
</p>

</section>
</div>
<div id="note5" data-noteid="5">
<p><span>5</span></p><section>
<p>
 Actual conversation:
</p>
<p>
<b>Madness:</b> &#34;The universe says it&#39;s impossible.&#34;
</p>
<p>
<b>Evan:</b> &#34;Yeah it&#39;s usually right about this stuff, and--&#34;
</p>
<p>
<b>Madness:</b> &#34;The universe also called you a sissy little bitch.&#34;
</p>
<p>
<b>Evan:</b> &#34;--it isn&#39;t this time, the universe can shut the hell up and watch me!&#34;

</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    
    <div>
      <div>
  
<section>
<h2 id="what-would-it-look-like">
 What would it look like?</h2>

</section>
<section>
<p>
Our ultimate goal is to write this Vale code:
</p>

    
  

    
  
<p>
...which would successfully make a Rust <span>Vec</span> and call <span>capacity</span> on it. <a href="#note6" data-noteid="6">6</a>
</p>

</section>
<section>
<p>
But first thing&#39;s first: a proof-of-concept for C!
</p>

</section>
<section>
<p>
In <a href="https://verdagon.dev/blog/exploring-seamless-rust-interop-part-1">the last post</a>, we talked about how C can treat Rust objects as <b>opaque types</b>, basically blobs of raw bytes that cannot be read directly.
</p>
<p>
TL;DR: By treating them as opaque, our C code was able to <b>receive normal Rust objects</b> (without <span>repr(C)</span>) from normal Rust functions (without <span>no_mangle</span>). We then hand this unreadable data <b>back to other Rust functions</b> to manipulate it, extract data from it, or do other useful things with it.
</p>

</section>
<section>
<p>
That was all under the hood, of course. With the proof-of-concept tool, the coder sees something more like this:
</p>

</section>
<section>

    <div>
      
      <pre><code>#pragma rsuse VecInt = std::vec::Vec&lt;u64&gt;
#pragma rsfn VecInt_with_capacity = VecInt::with_capacity
#pragma rsfn VecInt_capacity = VecInt::capacity
#pragma rsfn VecInt_drop = VecInt::drop
#include &#34;rust_deps/rust_deps.h&#34;
#include &lt;stdio.h&gt;

int main() {
  VecInt argv = VecInt_with_capacity(42);
  printf(&#34;Capacity: %lu\n&#34;, VecInt_capacity(&amp;argv));
  VecInt_drop(argv);
  return 0;
}</code></pre>
    </div>
  

    
  

</section>
<section>
<p>
Under the hood, the tool automatically generates some Rust code, such as this definition for <span>VecInt</span>:
</p>

    <div>
      
      <pre><code>#[repr(C, align(8))]
pub struct VecInt([u8; 24]);</code></pre>
    </div>
  
<p>
and this definition for <span>VecInt_with_capacity</span>:
</p>

    <div>
      
      <pre><code>#[no_mangle]
pub extern &#34;C&#34; fn VecInt_with_capacity(param_0_c: usize) -&gt; VecInt {
  let param_0_rs: usize = unsafe { mem::transmute(param_0_c) };
  let result_rs: alloc::vec::Vec::&lt;u64&gt; =
      alloc::vec::Vec::&lt;u64&gt;::with_capacity(param_0_rs);
  let result_c: VecInt = unsafe { mem::transmute(result_rs) };
  return result_c;
}</code></pre>
    </div>
  
<p>
...and then uses cbindgen to generate an equivalent C header into <span>&#34;rust_deps/rust_deps.h&#34;</span>.
</p>

</section>
<section>
<p>
If you want to know more about that, check out <a href="https://verdagon.dev/blog/exploring-seamless-rust-interop-part-1">the last post</a> that describes it a little more.
</p>

</section>
<section>
<p>
However, the post very mysteriously left out the hardest part...
</p>

</section>
<section>
<p>
How does the tool get the correct information from:
</p>

    <div>
      
      <pre><code>#pragma rsuse VecInt = std::vec::Vec&lt;u64&gt;
#pragma rsfn VecInt_with_capacity = VecInt::with_capacity</code></pre>
    </div>
  
<p>
to be able to generate the above Rust code?
</p>

</section>

      </div>
  
<div>

      <div>
        <div>
    
<div id="note6" data-noteid="6">
<p><span>6</span></p><section>
<p>
 We&#39;re actually surprisingly close to being able to do this today. Stay tuned!

</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    <div>
      <div>
  
<section>
<h2 id="gathering-type-information">
 Gathering type information</h2>
<p>
Let&#39;s look at this line first:
</p>

    <div>
      
      <pre><code>#pragma rsuse VecInt = std::vec::Vec&lt;u64&gt;</code></pre>
    </div>
  
<p>
The tool needs to somehow generate this Rust code:
</p>

    <div>
      
      <pre><code>#[repr(C, align(8))]
pub struct VecInt([u8; 24]);</code></pre>
    </div>
  

</section>
<section>
<p>
It needs three pieces of information about <span>std::vec::Vec</span>:
</p>
<ul>
<li>
Its size: 24 bytes.
</li>
<li>
Its alignment: 8 bytes. <a href="#note7" data-noteid="7">7</a> <a href="#note8" data-noteid="8">8</a>
</li>
<li>
Its real name: <span>alloc::vec::Vec</span> (we&#39;ll use this later).
</li>
</ul>

</section>
<section>
<p>
The tool gathers this information by running a small Rust program (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=bc8bdf99d4c9dd67e4c1d2168bc491ae">playground link</a>) and reading the output:
</p>

    <div>
      
      <pre><code>fn main() {
  println!(
    &#34;{} {} {}&#34;,
    std::mem::size_of::&lt;std::vec::Vec::&lt;u64&gt;&gt;(),
    std::mem::align_of::&lt;std::vec::Vec::&lt;u64&gt;&gt;(),
    std::any::type_name::&lt;std::vec::Vec::&lt;u64&gt;&gt;());
}</code></pre>
    </div>
  

    <div>
      
      <pre><code>24 8 alloc::vec::Vec&lt;u64&gt;</code></pre>
    </div>
  
<p>
(That&#39;s actually a simplified version, here&#39;s a <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=72417e829aa73c67b3ef47bb9d817177">more accurate example</a>)
</p>

</section>
<section>
<p>
In other words, to be able to <b>build</b> our C program, our tool will first <b>run</b> this temporary Rust program. <a href="#note9" data-noteid="9">9</a>
</p>

</section>
<section>
<p>
A little weird, but straightforward!
</p>

</section>
<section>
<p>
Now, how does it generate the <span>VecInt_with_capacity</span> function we saw above?
</p>

</section>

      </div>
  
<div>

      <div>
        <div>
    
<div id="note7" data-noteid="7">
<p><span>7</span></p><section>
<p>
 &#34;Alignment&#34; describes some restrictions on where the type can be in memory.
</p>
<p>
Most types need to be at an address that&#39;s a multiple of 8, like this one. 
</p>
<p>
Some types can be at any address, like <span>char</span> or even <span>char[50]</span>.

</p>

</section>
</div>
<div id="note8" data-noteid="8">
<p><span>8</span></p><section>
<p>
No matter where the object is, even across the FFI boundary, Rust should never see it at an address that doesn&#39;t line up with its alignment. Otherwise, we get bus errors and segmentation faults and other lovely phenomena.
</p>

</section>
</div>
<div id="note9" data-noteid="9">
<p><span>9</span></p><section>
<p>
This is pretty slow. I&#39;m hoping to speed it up with some nice caching, and maybe communicating directly to a subprocess running some sort of Rust REPL.
</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    <div>
      <div>
  
<section>
<h2 id="gathering-function-information">
 Gathering function information</h2>
<p>
Given this line:
</p>

    <div>
      
      <pre><code>#pragma rsfn VecInt_with_capacity = VecInt::with_capacity</code></pre>
    </div>
  
<p>
The tool needs to generate this Rust code:
</p>

    <div>
      
      <pre><code>#[no_mangle]
pub extern &#34;C&#34; fn VecInt_with_capacity(param_0_c: usize) -&gt; VecInt {
  let param_0_rs: usize = unsafe { mem::transmute(param_0_c) };
  let result_rs: alloc::vec::Vec::&lt;u64&gt; =
      alloc::vec::Vec::&lt;u64&gt;::with_capacity(param_0_rs);
  let result_c: VecInt = unsafe { mem::transmute(result_rs) };
  return result_c;
}</code></pre>
    </div>
  

</section>
<section>
<p>
To do that, it needs to know:
</p>
<ul>
<li>
The real name: <span>alloc::vec::Vec::&lt;u64&gt;::with_capacity</span>
</li>
<li>
The return type: <span>alloc::vec::Vec::&lt;u64&gt;</span>
</li>
<li>
The parameter types: <span>usize</span>
</li>
</ul>

</section>
<section>
<p>
These are actually pretty tricky to determine.
</p>

</section>
<section>
<p>
I was hoping that I could just use <span>std::any::type_name</span> (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=45f9de3596aea6b1658a655cb04e95e9">playground link</a>) or say this:
</p>

    <div>
      
      <pre><code>println!(&#34;fn {}&#34;, std::signature_of::&lt;Vec&lt;int&gt;::with_capacity&gt;());</code></pre>
    </div>
  
<p>
But there is no <span>signature_of</span>, I just made that up.
</p>

</section>
<section>
<p>
This is the part I left out of <a href="https://verdagon.dev/blog/exploring-seamless-rust-interop-part-1">the last post</a> because the path from here becomes treacherous... and the only way forward is too arcane, too terrible to consider.
</p>

</section>
<section>
<h2 id="a-horrifying-idea">
 A horrifying idea</h2>
<p>
(Or, <a href="#wisdom-prevails">skip to the final approach</a>!)
</p>

</section>
<section>
<p>
I considered a few other options, such as using macros to search through functions, or using the <a href="https://docs.rs/syn/latest/syn/">syn</a> crate... but neither of those approaches has access to the information we need.
</p>

</section>
<section>
<p>
If we could just see all the functions for a given type, then perhaps we could search them for the correct overload, and print out their parameters.
</p>

</section>
<section>
<p>
So I thought, <b>let&#39;s read rustc&#39;s MIR!</b>
</p>

</section>
<section>
<p>
<a href="https://rustc-dev-guide.rust-lang.org/mir/index.html">MIR</a> is <span>rustc</span>&#39;s &#34;Mid-level Intermediate Representation&#34;. <span>rustc</span> turns Rust source code into HIR, then MIR, then eventually, LLVM IR, which later gets turned into assembly code.
</p>

</section>
<section>
<p>
If we could search through the Rust libraries&#39; MIR, maybe we could find the right function and print its parameters out!
</p>

</section>
<section>
<h2 id="an-even-better-horrifying-idea">
 An even better horrifying idea</h2>
<p>
But first, I <a href="https://discord.com/channels/273534239310479360/1120124565591425034/1226564863812305028">asked on the Rust discord server</a> if that really was the best way to get all the structs and functions for a target crate.
</p>

</section>
<section>
<p>
Luckily, <b>Helix/noop_noob</b> and <b>anden3</b> arrived and told me a much better solution: get rustdoc&#39;s JSON output and read it with <a href="https://discord.com/channels/273534239310479360/1120124565591425034/1226573914256441455">rustdoc_types</a>!
</p>
<p>
That&#39;s probably <i>way, way easier</i> than reading MIR. To this day, I don&#39;t know if using MIR would have worked well.
</p>
<p>
Bless these two heroes, and may their names ever live on in glory.
</p>

</section>
<section>
<p>
Of course, I was then met with horrified reactions when I explained what I&#39;d use it for.
</p>
<p>
I hope they never learn of the dark sorcery they helped me unleash on this world.
</p>

</section>
<section>
<p>
Let&#39;s be clear: <span>rustdoc</span> was <b>not made for this.</b> It was made to generate lovely HTML pages <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">like this one</a>. And even though it has JSON output, it&#39;s <a href="https://rust-lang.github.io/rfcs/2963-rustdoc-json.html">not even stabilized</a>, and organizes its information for, you know, <i>making documentation.</i>
</p>
<p>
What could go wrong?
</p>

</section>
<section>
<p>
Anyway, I made the tool invoke <span>rustdoc</span> <a href="#note10" data-noteid="10">10</a> and load the resulting JSON in with <a href="https://discord.com/channels/273534239310479360/1120124565591425034/1226573914256441455">rustdoc_types</a> and serde.
</p>

</section>
<section>
<p>
Then, the tool reads every single <span>fn</span>, <span>struct</span>, <span>impl</span>, <span>trait</span>, <span>type</span>, and <span>use</span> in every crate, and collects their relationships into a bunch of hash maps. <a href="#note11" data-noteid="11">11</a> <a href="#note12" data-noteid="12">12</a>
</p>

</section>
<section>
<h2 id="the-quest-begins">
 The quest begins!</h2>

</section>
<section>
<p>
At first, things were pretty easy. <a href="https://docs.rs/rustdoc-types/latest/rustdoc_types/struct.Function.html">rustdoc_types::Function</a> has pretty straightforward information:
</p>

    <div>
      
      <pre><code>pub struct Function {
    pub decl: FnDecl, // Parameters, return types
    pub generics: Generics, // &lt;T&gt;, where, etc.
    pub header: Header, // const, unsafe, async, etc.
    pub has_body: bool,
}</code></pre>
    </div>
  

</section>
<section>
<p>
It wasn&#39;t terribly hard to loop through all the functions and compare their types to the ones supplied by the user.
</p>

</section>
<section>
<p>
Though, there were some tricky parts:
</p>
<ul>
<li>
To find a struct&#39;s method, we need to find all <span>impl</span>s for that struct, and look through all of them.
</li>
<li>
Sometimes, a struct&#39;s method is defined in a different crate entirely. <a href="#note13" data-noteid="13">13</a>
</li>
<li>
Types often didn&#39;t know that they were using the <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html">default drop method</a>.
</li>
<li>
<span>_Unwind_Reason_Code</span> and some things in <span>std::detect</span> are referenced but somehow don&#39;t exist.
</li>
</ul>

</section>
<section>
<p>
But it all worked! <a href="#note14" data-noteid="14">14</a>
</p>

</section>
<section>
<p>
At least, until I tried this line:
</p>
<p>
<span>#pragma rsfn OsString_from_str = std::ffi::OsString::from</span>
</p>
<p>
...which made the program burst into flames.
</p>

</section>
<section>
<p>
Why&#39;s that?
</p>
<p>
Because there are multiple overloads for the <span>OsString::from</span> function!
</p>
<p>
The tool couldn&#39;t figure out which to use.
</p>

</section>
<section>
<h2 id="rust-function-overloads">
 Rust Function Overloads</h2>
<p>
Some already know about <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=3881a0e70cea011977196420fb6ffd14">function overloading in Rust</a>, but for those unfamiliar with the term, <a href="https://en.wikipedia.org/wiki/Function_overloading">Wikipedia</a> says:
</p>
<p>
Function overloading is the ability to create multiple functions of the same name with different implementations. Calls to an overloaded function will run a specific implementation of that function appropriate to the context of the call, allowing one function call to perform different tasks depending on context. 
</p>

</section>
<section>
<p>
And unfortunately for us, that&#39;s exactly what&#39;s happening here with the <span>from</span> method.
</p>

</section>
<section>
<p>
You see, <b>we actually want to call this</b> <span>from</span> method at <a href="https://github.com/rust-lang/rust/blob/f1586001ace26df7cafeb6534eaf76fb2c5513e5/library/std/src/ffi/os_str.rs#L1595">os_str.rs:1595</a>:
</p>

    <div>
      
      <pre><code>impl&lt;T: ?Sized + AsRef&lt;OsStr&gt;&gt; From&lt;&amp;T&gt; for OsString {
    fn from(s: &amp;T) -&gt; OsString {
        s.as_ref().to_os_string()
    }
}</code></pre>
    </div>
  
<p>
...because our <span>&amp;str</span> is a kind of <span>AsRef&lt;OsStr&gt;</span>, as specified by <a href="https://github.com/rust-lang/rust/blob/f1586001ace26df7cafeb6534eaf76fb2c5513e5/library/std/src/ffi/os_str.rs#L574">os_str.rs:574</a>:
</p>

    <div>
      
      <pre><code>impl AsRef&lt;OsStr&gt; for str {
    ...
}</code></pre>
    </div>
  

</section>
<section>
<p>
<b>However, we <i>don&#39;t</i> want to call this</b> <span>from</span> function at <a href="https://github.com/rust-lang/rust/blob/f1586001ace26df7cafeb6534eaf76fb2c5513e5/library/std/src/ffi/os_str.rs#L563">os_str.rs:563</a> which makes an <span>OsString</span> from a <span>String</span>:
</p>

    <div>
      
      <pre><code>impl From&lt;String&gt; for OsString {
  fn from(s: String) -&gt; OsString {
    OsString { inner: Buf::from_string(s) }
  }
}</code></pre>
    </div>
  

</section>
<section>
<p>
<b>And we also don&#39;t want to call this</b> <span>from</span> function at <a href="https://github.com/rust-lang/rust/blob/f1586001ace26df7cafeb6534eaf76fb2c5513e5/library/core/src/convert/mod.rs#L765">convert/mod.rs:765</a>, which can turn any <span>T</span> into itself:
</p>

    <div>
      
      <pre><code>impl&lt;T&gt; From&lt;T&gt; for T {
  fn from(t: T) -&gt; T {
    t
  }
}</code></pre>
    </div>
  
<p>
For clarity, here&#39;s that last one again, but replacing <span>T</span> with <span>OsString</span>:
</p>

    <div>
      
      <pre><code>impl From&lt;OsString&gt; for OsString {
  fn from(t: OsString) -&gt; OsString {
    t
  }
}</code></pre>
    </div>
  

</section>
<section>
<p>
In other words, there are three overloads:
</p>
<ul>
<li>
<span>OsString::from(t: OsString)</span>
</li>
<li>
<span>OsString::from(s: String)</span>
</li>
<li>
<span>OsString::from(s: T) where T: ?Sized + AsRef&lt;OsStr&gt;</span>
</li>
</ul>

</section>
<section>
<p>
I concluded that when there are multiple overloads, the user <b>can&#39;t say this anymore:</b>
</p>
<p>
<span>#pragma rsfn OsString_from_str = std::ffi::OsString::from</span>
</p>
<p>
They must be <b>more specific:</b> <a href="#note15" data-noteid="15">15</a>
</p>
<p>
<span>#pragma rsfn OsString_from_str = std::ffi::OsString::From&lt;&amp;str&gt;::from</span>
</p>
<p>
...and then our tool can narrow down the right overload somehow. <a href="#note16" data-noteid="16">16</a>
</p>

</section>

      </div>
  
<div>

      <div>
        <div>
    
<div id="note10" data-noteid="10">
<p><span>10</span></p><section>
<p>
The command is something like <span>cargo rustdoc -Zunstable-options --output-format=json --package (crate_name)</span> but the process is a bit different to get the standard library&#39;s json.
</p>

</section>
</div>
<div id="note11" data-noteid="11">
<p><span>11</span></p><section>
<p>
<span>rustdoc</span>&#39;s JSON output is nice and hierarchical, and the items often refer to each other by ID. The hash maps were more useful for the inverse relationships, and to figure out the best name to access a given type (for example, <span>regex::regex::string::Regex</span> is inaccessible; one must refer to it as <span>regex::Regex</span>.)
</p>

</section>
</div>
<div id="note12" data-noteid="12">
<p><span>12</span></p><section>
<p>
This was really slow, and I hope to find a way to skip this step, or cache the information, or generally make it faster.
</p>

</section>
</div>
<div id="note13" data-noteid="13">
<p><span>13</span></p><section>
<p>
Such as when a third-party <span>trait</span> has an <span>impl</span> for a pre-existing struct, and defines methods in that <span>impl</span> block.
</p>

</section>
</div>
<div id="note14" data-noteid="14">
<p><span>14</span></p><section>
<p>
Well, not entirely, I&#39;m taking some creative liberties to make the story more understandable. Below, I talk about how the tool later needs to evaluate some generics. Right here is where we <i>actually</i> started evaluating generics.
</p>

</section>
</div>
<div id="note15" data-noteid="15">
<p><span>15</span></p><section>
<p>
Instead of <span>From&lt;&amp;str&gt;::from</span>, we could have the user say <span>from(&amp;str)</span>. I eventually did make that switch, but at the time <span>From&lt;&amp;str&gt;::from</span> made more sense since it was easier for the generics substitution code.
</p>

</section>
</div>
<div id="note16" data-noteid="16">
<p><span>16</span></p><section>
<p>
 Easter egg note!
</p>
<p>
<a href="https://en.wikipedia.org/wiki/King_Neptune_%28pig%29">King Neptune</a> is a pig that singlehandedly raised $19 million for the construction of the U.S. Navy&#39;s <a href="https://en.wikipedia.org/wiki/Iowa-class_battleship">Iowa-class battleship</a> <a href="https://en.wikipedia.org/wiki/USS_Illinois_%28BB-65%29">Illinois</a> during World War 2.
</p>
<p>
Originally intended to be served as a pig roast, the Navy recruiter, had a better idea: auction the pig! But each time he tried to auction it off, the winner returned King Neptune alive and well.
</p>
<p>
After an extensive fundraising career, King Neptune retired to a farm in Anna, Illinois, and died a hero. He was buried with military honors.
</p>
<p>
If you read this note, mention &#34;battleship&#34; or &#34;Neptune&#34; anywhere on HN or reddit! <a href="https://youtu.be/-UBgNREvlIo">Nobody will believe you</a>.
</p>
<p>
(Cheers to <a href="https://news.ycombinator.com/item?id=40363660">robert-wallis</a> and <a href="https://x.com/Joebobo2000/status/1791490879569453420">Geroman Joe</a> for <a href="https://verdagon.dev/blog/easter-egg-notes#cher-ami">catching the last one</a>!)

</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    <div>
      <div>
  
<section>
<h2 id="the-descent-into-madness">
 The descent into madness</h2>
<p>
It looked impossible. But I had an idea... an insane idea.
</p>

</section>
<section>
<p>
Sometimes, when the universe tells you something is too crazy to work, you just can&#39;t resist the urge to call its bluff.
</p>
<p>
And sometimes, you know that <a href="https://meta.wikimedia.org/wiki/Cunningham%27s_Law">if you make a solution horrifying enough</a>, it will inspire a legion of internet-goers to come up with something better.
</p>
<p>
So now here we stand, on the edge of sanity, knowing that the only path forward is through a forest of madness and a fiery chasm of <i>sheer and utter folly.</i>
</p>

</section>
<section>
<p>
<b>Let&#39;s implement some Rust overload resolution logic!</b>
</p>
<p>
And to do that, let&#39;s evaluate some generics too!
</p>
<p>
You&#39;ll see what I mean below.
</p>

</section>
<section>
<h2 id="implementing-overload-resolution-and-generics">
 Implementing overload resolution and generics</h2>
<p>
Remember, the tool has access to a lot of information. It knows about every <span>struct</span>, <span>fn</span>, <span>trait</span>, <span>impl</span>, and so on.
</p>
<p>
So why not use that information to narrow down which function we&#39;re calling?
</p>

</section>
<section>
<p>
For example, when the tool encounters this line:
</p>
<p>
<span>#pragma rsfn OsString_from_str = std::ffi::OsString::From&lt;&amp;str&gt;::from</span>
</p>
<p>
Let&#39;s make it figure out which <span>impl</span> we&#39;re referring to as <span>From&lt;&amp;str&gt;</span>.
</p>

</section>
<section>
<p>
To do that, the tool loops through all the <span>impl</span>s for <span>std::ffi::OsString</span>. <a href="#note17" data-noteid="17">17</a>
</p>

</section>
<section>
<p>
It encounters <a href="https://github.com/rust-lang/rust/blob/f1586001ace26df7cafeb6534eaf76fb2c5513e5/library/std/src/ffi/os_str.rs#L1595">os_str.rs:1595</a>&#39;s <span>impl</span>, repeated here:
</p>

    <div>
      
      <pre><code>impl&lt;T: ?Sized + AsRef&lt;OsStr&gt;&gt; From&lt;&amp;T&gt; for OsString {
    fn from(s: &amp;T) -&gt; OsString {
        s.as_ref().to_os_string()
    }
}</code></pre>
    </div>
  

</section>
<section>
<p>
First, it <b>attempts to match</b> the user&#39;s <span>From&lt;&amp;str&gt;</span> against the impl&#39;s <span>From&lt;&amp;T&gt;</span>.
</p>

</section>
<section>
<p>
It succeeds, and along the way it <b>figured out the impl&#39;s generic parameters</b>, specifically that <span>T</span> = <span>str</span>.
</p>

</section>
<section>
<p>
Finally, it <b>figures out the function&#39;s parameters.</b> With <span>T</span> = <span>str</span>, it becomes:
</p>

    <div>
      
      <pre><code>    fn from(s: &amp;str) -&gt; OsString {</code></pre>
    </div>
  
<p>
It then adds this to the final list of &#34;eligible functions&#34;, hoping that we&#39;ll end up with only one.
</p>

</section>
<section>
<p>
Continuing on, the tool sees the next <span>impl</span> from <a href="https://github.com/rust-lang/rust/blob/f1586001ace26df7cafeb6534eaf76fb2c5513e5/library/std/src/ffi/os_str.rs#L563">os_str.rs:563</a>:
</p>

    <div>
      
      <pre><code>impl From&lt;String&gt; for OsString {
  fn from(s: String) -&gt; OsString {
    OsString { inner: Buf::from_string(s) }
  }
}</code></pre>
    </div>
  
<p>
And it properly rejects it because the user&#39;s <span>From&lt;&amp;str&gt;</span> doesn&#39;t match this <span>From&lt;String&gt;</span>.
</p>

</section>
<section>
<p>
Continuing on, the tool sees the next <span>impl</span> from <a href="https://github.com/rust-lang/rust/blob/f1586001ace26df7cafeb6534eaf76fb2c5513e5/library/core/src/convert/mod.rs#L765">convert/mod.rs:765</a>:
</p>

    <div>
      
      <pre><code>impl&lt;T&gt; From&lt;T&gt; for T {
  fn from(t: T) -&gt; T {
    t
  }
}</code></pre>
    </div>
  
<p>
And with some clever logic, <a href="#note18" data-noteid="18">18</a> our process can properly reject this one too.
</p>

</section>
<section>
<p>
We&#39;re left with one surviving overload. Success!
</p>

</section>

      </div>
  
<div>

      <div>
        <div>
    
<div id="note17" data-noteid="17">
<p><span>17</span></p><section>
<p>
It could theoretically use the <a href="https://docs.rs/rustdoc-types/latest/rustdoc_types/struct.Struct.html">rustdoc_types::Struct</a>s&#39; <span>.impls</span> and <a href="https://docs.rs/rustdoc-types/latest/rustdoc_types/struct.Trait.html">rustdoc_types::Trait</a>s&#39; <span>.implementations</span> lists, but sometimes this didn&#39;t actually work, so I had to loop through all <span>impl</span>s in all crates. I&#39;m pretty sure that I could get it working without that looping, but it&#39;s all moot now, luckily.
</p>

</section>
</div>
<div id="note18" data-noteid="18">
<p><span>18</span></p><section>
<p>
 It worked, but my implementation here was pretty bad. It actually approved this overload, and then I had some tiebreaker logic to choose which overload &#34;matched better&#34;.
</p>
<p>
It worked, but I knew even then that this was somewhat incorrect and definitely wouldn&#39;t scale to Rust&#39;s full complexity.
</p>
<p>
The actual good approach I leave as an exercise to the reader!

</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    <div>
      <div>
  
<section>
<p>
But let&#39;s take a step back, and recognize just how <i>cursed</i> this whole thing is.
</p>
<p>
It&#39;s complex: the generics and overload resolution logic, and all of their supporting infrastructure, is something like 1,700 lines of rather intricate code.
</p>
<p>
To make it solid enough to merge into the main branch, it could end up anywhere between 12,000 <a href="#note19" data-noteid="19">19</a> and <a href="https://users.rust-lang.org/t/build-from-actual-source/84277/12">1,000,000 lines</a>, depending on the temperaments of various deities.
</p>

</section>
<section>
<p>
<img src="https://i.imgflip.com/8twhkv.jpg"/>
</p>

</section>
<section>
<p>
And handling generics is a lot more perilous than I made it sound.
</p>
<p>
If you don&#39;t believe me, know that above, we didn&#39;t even check to see if our <span>&amp;str</span> matched the predicate <span>?Sized + AsRef&lt;OsStr&gt;</span>. We also didn&#39;t deal with <a href="https://github.com/rust-lang/rust/blob/f1586001ace26df7cafeb6534eaf76fb2c5513e5/library/alloc/src/vec/mod.rs#L3354">conditionally compiled functions</a> or <a href="https://github.com/rust-lang/rust/blob/f1586001ace26df7cafeb6534eaf76fb2c5513e5/library/core/src/convert/mod.rs#L782">whatever the heck this thing is</a>. <a href="#note20" data-noteid="20">20</a>
</p>

</section>
<section>
<p>
Plus, as I got it working for more and more test cases, the number of <span>unimplemented!()</span> markers in the code didn&#39;t lessen... it only grew larger and larger.
</p>

</section>
<section>
<p>
So, despite all the fun I was having, I was getting <i>slightly worried</i> about this endeavor.
</p>

</section>

      </div>
  
<div>

      <div>
        <div>
    
<div id="note19" data-noteid="19">
<p><span>19</span></p><section>
<p>
After I finished handling all the weird edge cases, I&#39;d still have to optimize, and then add tests, comments, and documentation.
</p>

</section>
</div>
<div id="note20" data-noteid="20">
<p><span>20</span></p><section>
<p>
 I&#39;m kidding, this is a <b>bottom type</b> like Scala&#39;s <a href="https://www.scala-lang.org/api/2.13.3/scala/Nothing.html">Nothing</a> or Vale&#39;s <span>Never</span>.
</p>
<p>
Like an imaginary number, no instances of this ever exist.
</p>
<p>
It&#39;s a type that can be converted to anything.
</p>
<p>
Interesting things happen when you consider a <span>throw</span>, <span>return</span>, <span>break</span>, or <span>continue</span> to result in this type.

</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    <div>
      <div>
  
<section>
<h2 id="wisdom-prevails">
 Wisdom prevails</h2>
<p>
Let&#39;s travel back in time a bit.
</p>
<p>
Before I even started with this overload resolution, I knew what I was getting into.
</p>
<p>
After all, I&#39;ve implemented seven different iterations of generics and overload resolution for Vale, each larger and more powerful than the last.
</p>

</section>
<section>
<p>
Back then, I <i>knew in my bones</i> that I was standing on the edge of sanity, and the only path forward was through that forest of madness and that fiery chasm of sheer and utter folly and so on. <a href="#note21" data-noteid="21">21</a>
</p>

</section>
<section>
<p>
So before I started implementing it, I also <a href="https://www.reddit.com/r/AskHistorians/comments/rzi7go/were_fire_signals_actually_used_like_in_lord_of/">lit the beacons</a> and <b>called for aid.</b>
</p>

</section>
<section>
<p>
In other words, I <a href="https://internals.rust-lang.org/t/different-way-to-call-into-rust-from-other-languages/20912">posted on the Rust internals forum</a>, sent a couple emails, and even tried baiting a better solution out of everyone in <a href="https://verdagon.dev/blog/exploring-seamless-rust-interop-part-1">the last post</a>:
</p>
<p>
&#34;The tool comes out to 3,200 lines, and most of it is this step. ... This part is ridiculously hard. If you have an idea how you&#39;d do it, let me know, because it&#39;s probably better than what I did!&#34;
</p>

</section>
<section>
<p>
Unfortunately, nobody had a better approach, which meant using <span>rustdoc</span> was the only way forward.
</p>

</section>
<section>
<p>
Eventually, I&#39;d gotten the overload resolution working for over half the test cases.
</p>

</section>
<section>
<p>
Then, I got a reply to one of my emails!
</p>

</section>
<section>
<h2 id="a-better-solution-rust-sorcery">
 A better solution: Rust sorcery!</h2>
<p>
The reply was from Alex Kladov, also known as <a href="https://matklad.github.io/">matklad</a>, the author of rust-analyzer and IntelliJ Rust. He&#39;s also working on TigerBeetle (a Zig database which has a <a href="https://tigerbeetle.com/blog/a-database-without-dynamic-memory">really cool approach to handling memory</a> by the way), and he&#39;s the MVP of this post. <a href="#note22" data-noteid="22">22</a>
</p>

</section>
<section>
<p>
He suggested that I do the following magic (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=d594a4ddd8e9d233c02d4a7742617055">playground link</a>):
</p>

    <div>
      
      <pre><code>trait Reflect&lt;Args&gt; {
    fn reflect();
}

fn reflect&lt;T: Reflect&lt;Args&gt;, Args&gt;(_: T) {
    T::reflect()
}

impl &lt;F, T&gt; Reflect&lt;(T,)&gt; for F where F: Fn(T) {
    fn reflect() {
        println!(&#34;1 {}&#34;, std::mem::size_of::&lt;T&gt;())
    }
}

impl &lt;F, T, U&gt; Reflect&lt;(T, U, )&gt; for F where F: Fn(T, U) {
    fn reflect() {
        println!(&#34;1 {} {}&#34;, std::mem::size_of::&lt;T&gt;(), std::mem::size_of::&lt;U&gt;())
    }
}

fn main() {
    reflect(Vec::&lt;std::ffi::OsString&gt;::clear);
    reflect(Vec::&lt;std::ffi::OsString&gt;::push);
}</code></pre>
    </div>
  

    
  

</section>
<section>
<p>
This code takes a function (such as <span>Vec&lt;OsString&gt;::push</span>) and figures out what kind of <span>Fn</span> trait it implements and what kind of arguments it takes.
</p>

</section>
<section>
<p>
I then expanded it to <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=c3c8f5500ab688ec281f45befdee32bd">this code</a> which also prints out the function&#39;s real name and return type too.
</p>

</section>
<section>
<p>
And it worked! By the time this Rust-based solution passed the fourth test case, I was celebrating.
</p>

</section>
<section>
<h2 id="more-function-overloading-troubles">
 More function overloading troubles</h2>
<p>
Unfortunately, this approach <i>also</i> had trouble with overloaded functions.
</p>

</section>
<section>
<p>
Remember this line?
</p>
<p>
<span>#pragma rsfn OsString_from_str = std::ffi::OsString::from</span>
</p>
<p>
This is the line that originally caused the <span>rustdoc</span>-based solution to have overload resolution and generics-resolving logic.
</p>

</section>
<section>
<p>
Our new Rust-based solution generates this line, which <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=04df849f3431ef6e6dee77c116e538a5">Rust doesn&#39;t like</a>:
</p>
<p>
<span>reflect(std::ffi::OsString::from);</span>
</p>

</section>
<section>
<p>
I tried all sorts of things:
</p>

    <div>
      
      <pre><code>reflect(std::ffi::OsString::From&lt;&amp;str&gt;::from);`

reflect(std::ffi::OsString::from::&lt;&amp;str&gt;);`

type FromStrToOsString = fn(&amp;str) -&gt; OsString;
let thing: FromStrToOsString = OsString::from;
reflect(thing);</code></pre>
    </div>
  
<p>
...but nothing worked.
</p>

</section>
<section>
<p>
So, hope dashed, I resumed the <span>rustdoc</span>-based solution, with all its complex overload-resolution and generics-resolving logic.
</p>

</section>

      </div>
  
<div>

      <div>
        <div>
    
<div id="note21" data-noteid="21">
<p><span>21</span></p><section>
<p>
 A beginner engineer will do stupid things.
</p>
<p>
A master engineer will do those same stupid things, but consciously and with <i>style.</i>

</p>

</section>
</div>
<div id="note22" data-noteid="22">
<p><span>22</span></p><section>
<p>
I really want to call him &#34;matklad the madlad&#34;, but he&#39;s probably heard that a hundred times already.
</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    <div>
      <div>
  
<section>
<h2 id="persistence">
 Persistence</h2>
<p>
But a good engineer never gives up on finding a simpler solution!
</p>

</section>
<section>
<p>
So, in parallel with finishing the <span>rustdoc</span>-based solution, I was still trying to make the Rust-based solution work for overloaded functions.
</p>

</section>
<section>
<p>
Finally, on the fourth day of this whole quest, I was able to make a function that <b>selects the correct overload</b> for a given function (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=47ae6b706dbd46efa338dbf3ce761915">playground link</a>).
</p>

    <div>
      
      <pre><code>fn select_overload_1&lt;R, P1&gt;(thing: impl Fn(P1) -&gt; R + PrintFn&lt;(R, P1, )&gt;)
-&gt; impl Fn(P1) -&gt; R + PrintFn&lt;(R, P1,)&gt; {
    thing
}</code></pre>
    </div>
  
<p>
It could be called like this:
</p>

    <div>
      
      <pre><code>print_fn(select_overload_1::&lt;_, &amp;str&gt;(std::ffi::OsString::from));</code></pre>
    </div>
  

</section>
<section>
<p>
That&#39;s it! A mere few lines, to do what my 3,200 line prototype struggled with.
</p>
<p>
Truly, it is a strange fate that we should suffer so much over so small a thing.
</p>

</section>
<section>
<p>
Huge thanks to Alex for providing the foundation for this eventual solution!
</p>

</section>
<section>
<p>
<b>Moral of the story:</b> always be searching for a simpler approach than the one you&#39;re currently implementing. <a href="#note23" data-noteid="23">23</a>
</p>

</section>
<section>
<p>
Luckily, this meant that I could delete all of the complex overload resolution and generics logic in the tool.
</p>
<p>
I have never been so relieved to delete thousands of lines!
</p>

</section>
<section>
<p>
And as it turns out, a lot of the <span>rustdoc</span> infrastructure will actually come back for some of the Vale integration, so this cursed endeavor wasn&#39;t <i>completely</i> fruitless.
</p>
<p>
On top of that, it&#39;s good to know just <i>how far</i> we can take this <span>rustdoc</span> information. The implications for code generation are pretty huge. I could imagine some of you will read all this and think of some equally insane uses for this kind of power.
</p>

</section>

      </div>
  
<div>

      <div>
        <div>
    
<div id="note23" data-noteid="23">
<p><span>23</span></p><section>
<p>
 Or a better moral: once you call for aid, wait a while before giving up and diving into an insane solution!
</p>
<p>
If I had just worked on something else for a week, that would have saved me this ridiculous side quest (which I admit was actually quite fun).

</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    <div>
      <div>
  
<section>
<h2 id="update-an-even-better-solution">
 Update: An even better solution!</h2>
<p>
And then, after reading this very post, <b>literallyvoid</b> found a simple one-line solution:
</p>

    <div>
      
      <pre><code>print_fn(&lt;std::ffi::OsString as From&lt;&amp;str&gt;&gt;::from);</code></pre>
    </div>
  

</section>
<section>
<p>
Is that even valid Rust syntax? Apparently!
</p>

</section>
<section>
<p>
And I bet a few you already know about this, and you&#39;ve been <i>dying</i> this entire time, reading about this cursed side-quest! That makes me chuckle.
</p>

</section>
<section>
<p>
Huge thanks to literallyvoid, for seeing the solution that so many of us didn&#39;t!
</p>

</section>

      </div>
  


    </div>
    <div>
      <div>
  
<section>
<h2 id="the-final-approach">
 The final approach</h2>
<p>
I emerge, battered and bloody, not sure what curséd arcana I&#39;ve wrought. 
</p>
<p>
But it works! And it does it without <i>too</i> much complexity. <a href="#note24" data-noteid="24">24</a>
</p>

</section>
<section>
<p>
In the end, it:
</p>
<ul>
<li>
Reads all the <span>#pragma rsuse</span> lines from a given C file.
</li>
<li>
Generates a temporary Rust program <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=08edd0c16bd7dffb60b1cdd3d873801e">which looks like this</a> to print types&#39; names and sizes and alignments, and functions&#39; names and parameters and returns.
</li>
<li>
Invokes <span>cargo run</span> on the temporary program to gather its output.
</li>
<li>
Until I can remove it, still uses information from <span>cargo rustdoc</span> to correct some user-given type names. <a href="#note25" data-noteid="25">25</a>
</li>
<li>
Generates a Rust library that will allow C to call into the Rust functions, using the technique from <a href="https://verdagon.dev/blog/exploring-seamless-rust-interop-part-1">the last post</a>.
</li>
</ul>

</section>
<section>
<p>
That&#39;s it! You now know the tool&#39;s secret rituals for crossing the impossible boundary between Rust and C.
</p>

</section>
<section>
<p>
If you&#39;re curious, the <a href="https://github.com/Verdagon/Vale/tree/iso/ValeRuster">code is here</a> (but be warned, it&#39;s not cleaned up yet). <a href="#note26" data-noteid="26">26</a> <a href="#note27" data-noteid="27">27</a>
</p>

</section>
<section>
<p>
I don&#39;t have any specific plans to turn this C proof-of-concept into a production-quality tool that would enable calling Rust from C, but if anyone wants to take it from here, I&#39;d be happy to assist!
</p>

</section>
<section>
<p>
From here, the next step is to finish integrating this tool into Vale, so that we can accomplish the original goal:
</p>

    
  

    
  

</section>
<section>
<p>
We&#39;re closer than you might think! <a href="#note28" data-noteid="28">28</a>
</p>

</section>

      </div>
  
<div>

      <div>
        <div>
    
<div id="note24" data-noteid="24">
<p><span>24</span></p><section>
<p>
Well, it&#39;s still a lot of moving parts. But at least it&#39;s not as complex as it was.
</p>

</section>
</div>
<div id="note25" data-noteid="25">
<p><span>25</span></p><section>
<p>
Specifically, it needs to <a href="https://i.imgflip.com/8tt2zf.jpg">figure out the correct public names</a> (e.g. <span>regex::Regex</span>) for private types (<span>regex::regex::string::Regex</span>). I think we can get rid of it if we require the user to specifically mention the public name for every private type they indirectly use, but that might not be good UX.
</p>

</section>
</div>
<div id="note26" data-noteid="26">
<p><span>26</span></p><section>
<p>
There&#39;s also some vestiges of the old overload resolution and generics logic in there, though I&#39;ve managed to remove most of it.
</p>

</section>
</div>
<div id="note27" data-noteid="27">
<p><span>27</span></p><section>
<p>
The <span>src</span> folder contains the canonical code, but I moved the old approach to <span>original</span> because I&#39;ll be reusing some of it for the next steps.
</p>

</section>
</div>
<div id="note28" data-noteid="28">
<p><span>28</span></p><section>
<p>
 Only two pieces remain!
</p>
<ul>
<li>
Generating the right Vale <span>extern struct</span> and <span>extern func</span> declarations, the ones in the current Vale test cases were made manually.
</li>
<li>
We can call <span>Vec&lt;int&gt;.with_capacity(42)</span>, and also <span>Vec&lt;int&gt;.capacity(vec)</span>, but not <span>vec.capacity()</span> yet.
</li>
</ul>


</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    <div>
      <div>
  
<section>
<h2 id="a-veil-a-ritual-and-a-leather-bound-tome">
 A veil, a ritual, and a leather-bound tome</h2>

</section>
<section>
<p>
<a href="https://verdagon.dev/blog/exploring-seamless-rust-interop-part-1">The last post</a> showed how we use opaque types to &#34;directly&#34; call into Rust functions.
</p>

</section>
<section>
<p>
And then this post talked about how we used some arcane Rust generics to select the correct functions and structs, and gather information about them.
</p>

</section>
<section>
<p>
However, there are still <b>some unanswered questions:</b>
</p>
<ol>
<li>
If our language defines <span>OurStruct</span>, how would Rust create a <span>Vec&lt;OurStruct&gt;</span> when <span>rustc</span> doesn&#39;t know anything about <span>OurStruct</span>, like how big it is?
</li>
<li>
If calling from a language without a borrow checker, how do we uphold the Rust code&#39;s memory safety guarantees?
</li>
<li>
In the case of Vale, how do we uphold other guarantees that Rust doesn&#39;t respect, like <a href="https://verdagon.dev/blog/higher-raii-uses-linear-types">higher RAII</a>, <a href="https://verdagon.dev/blog/fearless-ffi">fearless FFI</a>, determinism, and <a href="https://verdagon.dev/blog/perfect-replayability-prototyped">perfect replayability</a>?
</li>
</ol>

</section>
<section>
<p>
The keys to these questions lie deep in <a href="https://verdagon.dev/grimoire/grimoire">the grimoire</a>, hidden to the untrained eye.
</p>

</section>
<section>
<p>
We&#39;ll talk about them in the next post!
</p>

</section>

      </div>
  


    </div>
    <div>
      <div>
  
<section>
<h2 id="thank-you">
 Thank you!</h2>

</section>
<section>
<p>
A lot of people helped make this happen:
</p>
<ul>
<li>
Huge thanks to <b>Alex Kladov</b> (<a href="https://matklad.github.io/">matklad</a>), who showed me the basic Rust sorcery that let us print out functions&#39; arguments and return types. Without Alex&#39;s help, this would still be a complex beast!
</li>
<li>
Thank you to <b>Helix/noop_noob</b> and <b>anden3</b> from the Rust discord server, for telling me about rustdoc&#39;s JSON output!
</li>
<li>
And another big thanks to Jeff Niu, <a href="https://lobste.rs/s/0iskz9/exploring_seamless_rust_interop_for#c_29igsc">snej</a>, <a href="https://internals.rust-lang.org/t/different-way-to-call-into-rust-from-other-languages/20912/2?u=verdagon">kornel</a>, and <a href="https://bjorn3.github.io/about/">bjorn3</a> for fixes and advice on how to correctly use these opaque types with FFI!
</li>
</ul>

</section>
<section>
<p>
With all our powers combined, we might cross this impossible FFI boundary, and make it so languages worldwide can call into Rust code much more easily.
</p>

</section>
<section>
<p>
That&#39;s all!
</p>

</section>
<section>
<p>
If you have any questions, always feel free to reach out via <a href="mailto:verdagon_epsa@verdagon.dev">email</a>, <a href="https://twitter.com/verdagon">twitter</a>, the <a href="https://discord.gg/SNB8yGH">discord server</a>, or the <a href="https://reddit.com/r/vale">subreddit</a>.
</p>

</section>
<section>
<p>
Onward!
</p>

</section>
<section>
<p>
<b>- Evan Ovadia</b>
</p>

</section>
<section>
<p>
PS. If you enjoyed reading this, consider <a href="https://www.etsy.com/listing/1722406930/snowbird-keychain-with-wings?click_key=5ca56adea54d4b16c3141eb85099d05e7d95e3d9%3A1722406930&amp;click_sum=be0cebdf&amp;ref=shop_home_active_1&amp;frs=1&amp;crt=1">buying an adorable snow bird plushie</a> from my partner&#39;s <a href="https://www.etsy.com/shop/SnowForestStudio">etsy store</a>!
</p>
<div>
<div>
<section>
<p>
<img src="https://verdagon.dev/images/snow-bird-2.jpeg"/>

</p>

</section>
</div>
<div>
<section>
<p>
<img src="https://verdagon.dev/images/snow-bird-1.jpeg"/>

</p>

</section>
</div>
</div>
<p>
She broke free from big tech to chase her dream of sharing cute birds with the world, so I&#39;d love it if her little shop takes off!
</p>

</section>

      </div>
  


    </div>
    <div>
      <div>
  
<section>
<h2 id="thank-you">
 Thank you!</h2>
<p>
I want to give a huge thanks to <a href="https://github.com/aweagel">Arthur Weagel</a>, <a href="https://github.com/KirilMihaylov">Kiril Mihaylov</a>, <a href="https://github.com/radekm">Radek Miček</a>, <a href="https://github.com/Geomitron">Geomitron</a>, <a href="https://github.com/chiuzon">Chiuzon</a>, <a href="https://github.com/soupertonic">Felix Scholz</a>, <a href="https://github.com/linkmonitor">Joseph Jaoudi</a>, <a href="https://github.com/lupuchard">Luke Puchner-Hardman</a>, <a href="https://github.com/tootoobeepbeep">Jonathan Zielinski</a>, <a href="https://github.com/albinkc">Albin Kocheril Chacko</a>, <a href="https://github.com/ezschemi">Enrico Zschemisch</a>, <a href="https://github.com/Svintooo">Svintooo</a>, <a href="https://github.com/tstack">Tim Stack</a>, <a href="https://github.com/kripken">Alon Zakai</a>, <a href="https://github.com/rovaughn">Alec Newman</a>, <a href="https://github.com/Shnatsel">Sergey Davidoff</a>, <a href="https://github.com/linuxy">Ian (linuxy)</a>, <a href="https://github.com/Ivo-Balbaert/">Ivo Balbaert</a>, <a href="https://github.com/pierrec">Pierre Curto</a>, <a href="https://github.com/loveJesus">Love Jesus</a>, <a href="https://github.com/jryans">J. Ryan Stinnett</a>, <a href="https://github.com/cdinu">Cristian Dinu</a>, and <a href="https://github.com/lasernoises">Florian Plattner</a> (plus a very generous anonymous donor!) for sponsoring Vale over all these years.
</p>
<p>
Your support has always given me the strength and resolve to explore these arcane corners of the world. And even though I&#39;m not doing sponsorships for a while, it&#39;s awesome to know you&#39;re with me in spirit. <a href="http://www.gamesurge.com/pc/strategy/pc_wt/Adom.shtml">Axes high!</a>

</p>

</section>

      </div>
  


    </div>
    
  

    </div>
  </div></div>
  </body>
</html>
