<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jvns.ca/blog/2024/02/01/dealing-with-diverged-git-branches/">Original</a>
    <h1>Dealing with diverged git branches</h1>
    
    <div id="readability-page-1" class="page"><div>
     

<p>Hello! One of the most common problems I see folks struggling with in Git is
when a local branch (like <code>main</code>) and a remote branch (maybe also called
<code>main</code>) have diverged.</p>

<p>There are two things that make this situation hard:</p>

<ul>
<li>If you’re not used to interpreting git’s error messages, it’s nontrivial to
even <strong>realize</strong> that your <code>main</code> has diverged from the remote <code>main</code> (git
will often just give you an intimidating but generic error message like
<code>! [rejected] main -&gt; main (non-fast-forward) error: failed to push some refs to &#39;github.com:jvns/int-exposed&#39;</code>)</li>
<li>Once you realize that your branch has diverged from the remote <code>main</code>, there
no single clear way to handle it (what you need to do depends on the
situation and your git workflow)</li>
</ul>

<p>So let’s talk about a) how to recognize when you’re in a situation where a local
branch and remote branch have diverged and b) what you can do about it! Here’s a
quick table of contents:</p>

<ul>
<li><a href="#what-does-diverged-mean">what does “diverged” mean?</a></li>
<li><a href="#recognizing-when-branches-are-diverged">recognizing when branches are diverged</a>

<ul>
<li><a href="#way-1-git-status">way 1: git status</a></li>
<li><a href="#way-2-git-push">way 2: git push</a></li>
<li><a href="#way-3-git-pull">way 3: git pull</a></li>
</ul></li>
<li><a href="#there-s-no-one-solution">there’s no one solution</a>

<ul>
<li><a href="#solution-1-1-git-pull-rebase">solution 1.1: git pull –rebase</a></li>
<li><a href="#solution-1-2-git-pull-no-rebase">solution 1.2: git pull –no-rebase</a></li>
<li><a href="#solution-2-1-git-push-force">solution 2.1: git push –force</a></li>
<li><a href="#solution-2-2-git-push-force-with-lease">solution 2.2: git push –force-with-lease</a></li>
<li><a href="#solution-3-git-reset-hard-origin-main">solution 3: git reset –hard origin/main</a></li>
</ul></li>
</ul>

<p>Let’s start with what it means for 2 branches to have “diverged”.</p>

<h3 id="what-does-diverged-mean">what does “diverged” mean?</h3>

<p>If you have a local <code>main</code> and a remote <code>main</code>, there are 4 basic configurations:</p>

<p><strong>1: up to date</strong>. The local and remote <code>main</code> branches are in the exact same place. Something like this:</p>

<pre><code>a - b - c - d
            ^ LOCAL
            ^ REMOTE
</code></pre>

<p><strong>2: local is behind</strong></p>

<p>Here you might want to <code>git pull</code>. Something like this:</p>

<pre><code>a - b - c - d - e
    ^ LOCAL     ^ REMOTE
</code></pre>

<p><strong>3: remote is behind</strong></p>

<p>Here you might want to <code>git push</code>. Something like this:</p>

<pre><code>a - b - c - d - e
    ^ REMOTE    ^ LOCAL
</code></pre>

<p><strong>4: they’ve diverged :(</strong></p>

<p>This is the situation we’re talking about in this blog post. It looks something like this:</p>

<pre><code>a - b - c - d - e
        \       ^ LOCAL
         -- f 
            ^ REMOTE
</code></pre>

<p>There’s no one recipe for resolving this (how you want to handle it depends on
the situation and your git workflow!) but let’s talk about how to recognize
that you’re in that situation and some options for how to resolve it.</p>

<h3 id="recognizing-when-branches-are-diverged">recognizing when branches are diverged</h3>

<p>There are 3 main ways to tell that your branch has diverged.</p>

<h3 id="way-1-git-status">way 1: <code>git status</code></h3>

<p>The easiest way to is to run <code>git fetch</code> and then <code>git status</code>. You’ll get a message something like this:</p>

<pre><code>$ git fetch
$ git status
On branch main
Your branch and &#39;origin/main&#39; have diverged, &lt;-- here&#39;s the relevant line!
and have 1 and 2 different commits each, respectively.
  (use &#34;git pull&#34; to merge the remote branch into yours)
</code></pre>

<h3 id="way-2-git-push">way 2: <code>git push</code></h3>

<p>When I run <code>git push</code>, sometimes I get an error like this:</p>

<pre><code>$ git push
To github.com:jvns/int-exposed
 ! [rejected]        main -&gt; main (non-fast-forward)
error: failed to push some refs to &#39;github.com:jvns/int-exposed&#39;
hint: Updates were rejected because the tip of your current branch is behind
hint: its remote counterpart. Integrate the remote changes (e.g.
hint: &#39;git pull ...&#39;) before pushing again.
hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details.
</code></pre>

<p>This doesn’t <strong>always</strong> mean that my local <code>main</code> and the remote <code>main</code> have
diverged (it could just mean that my <code>main</code> is behind), but for me it <strong>often</strong>
means that. So if that happens I might run <code>git fetch</code> and <code>git status</code> to
check.</p>

<h3 id="way-3-git-pull">way 3: <code>git pull</code></h3>

<p>If I <code>git pull</code> when my branches have diverged, I get this error message:</p>

<pre><code>$ git pull
hint: You have divergent branches and need to specify how to reconcile them.
hint: You can do so by running one of the following commands sometime before
hint: your next pull:
hint:
hint:   git config pull.rebase false  # merge
hint:   git config pull.rebase true   # rebase
hint:   git config pull.ff only       # fast-forward only
hint:
hint: You can replace &#34;git config&#34; with &#34;git config --global&#34; to set a default
hint: preference for all repositories. You can also pass --rebase, --no-rebase,
hint: or --ff-only on the command line to override the configured default per
hint: invocation.
fatal: Need to specify how to reconcile divergent branches.
</code></pre>

<p>This is pretty clear about the issue (“you have divergent branches”).</p>

<p><code>git pull</code> doesn’t always spit out this error message though when your branches have diverged: it depends on how
you configure git. The three other options I’m aware of are:</p>

<ol>
<li>if you set <code>git config pull.rebase false</code>, it’ll automatically start merging the remote <code>main</code></li>
<li>if you set <code>git config pull.rebase true</code>, it’ll automatically start rebasing onto the remote <code>main</code></li>
<li>if you set <code>git config pull.ff only</code>, it’ll exit with the error <code>fatal: Not possible to fast-forward, aborting.</code></li>
</ol>

<p>Now that we’ve talked about some ways to recognize that you’re in a situation
where your local branch has diverged from the remote one, let’s talk about what
you can do about it.</p>

<h3 id="there-s-no-one-solution">there’s no one solution</h3>

<p>There’s no “best” way to resolve branches that have diverged – it really
depends on your workflow for git and why the situation is happening.</p>

<p>I use 3 main solutions, depending on the situation:</p>

<ol>
<li>I want to <strong>keep both sets of changes</strong> on <code>main</code>. To do this, I’ll run <code>git
pull --rebase</code>.</li>
<li>The <strong>remote changes are useless</strong> and I want to overwrite them. To do this,
I’ll run <code>git push --force</code></li>
<li>The <strong>local changes are useless</strong> and I want to overwrite them. To do this, I’ll
run <code>git reset --hard origin/main</code></li>
</ol>

<p>Here are some more details about all 3 of these solutions.</p>

<h3 id="solution-1-1-git-pull-rebase">solution 1.1: <code>git pull --rebase</code></h3>

<p>This is what I do when I want to keep both sets of changes. It rebases <code>main</code>
onto the remote <code>main</code> branch. I mostly use this in repositories where I’m
doing all of my work on the <code>main</code> branch.</p>

<p>You can configure <code>git config pull.rebase true</code>, to do this automatically every
time, but I don’t because sometimes I actually want to use solutions 2 or 3
(overwrite my local changes with the remote, or the reverse). I’d rather be
warned “hey, these branches have diverged, how do you want to handle it?” and
decide for myself if I want to rebase or not.</p>

<h3 id="solution-1-2-git-pull-no-rebase">solution 1.2: <code>git pull --no-rebase</code></h3>

<p>This starts a merge between the <code>local</code> and remote <code>main</code>. Here you’ll need to:</p>

<ol>
<li>Run <code>git pull --no-rebase</code>. This starts a merge and (if it succeeds) opens a text editor so that you can confirm that you want to commit the merge</li>
<li>Save the file in your text editor.</li>
</ol>

<p>I don’t have too much to say about this because I’ve never done it. I always
use rebase instead. That’s a personal workflow choice though, lots of people have very
legitimate reasons to <a href="https://jvns.ca/blog/2023/11/06/rebasing-what-can-go-wrong-/">avoid rebase</a>.</p>

<h3 id="solution-2-1-git-push-force">solution 2.1: <code>git push --force</code></h3>

<p>Sometimes I know that the work on the remote <code>main</code> is actually useless and I
just want to overwrite it with whatever is on my local <code>main</code>.</p>

<p>I do this pretty often on private repositories where I’m the only committer,
for example I might:</p>

<ul>
<li><code>git push</code> some commits</li>
<li>belatedly decide I want to change the most recent commit</li>
<li>make the changes and run <code>git commit --amend</code></li>
<li>run <code>git push --force</code></li>
</ul>

<p>Of course, if the repository has many different committers, force-pushing in
this way can cause a lot of problems. On shared repositories I’ll usually
enable <a href="https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/managing-protected-branches/about-protected-branches">github branch protection</a>
so that it’s impossible to force push.</p>

<h3 id="solution-2-2-git-push-force-with-lease">solution 2.2: <code>git push --force-with-lease</code></h3>

<p>I’ve still never actually used <code>git push --force-with-lease</code>, but I’ve seen a
lot of people recommend it as an alternative to <code>git push --force</code> that makes
sure that nobody else has changed the branch since the last time you pushed or
fetched, so that you don’t accidentally blow their changes away.</p>

<p>Seems like a good option. I did notice that <code>--force-with-lease</code> isn’t
foolproof though – for example <a href="https://github.com/git/git/commit/f17d642d3b0fa64879d59b311e596949f2a1f6d2">this git commit</a>
talks about how if you use VSCode’s autofetching feature to continuously <code>git fetch</code>,
then <code>--force-with-lease</code> won’t help you.</p>

<p>Apparently now Git also has <code>--force-with-lease --force-if-includes</code>
(<a href="https://git-scm.com/docs/git-push#Documentation/git-push.txt---no-force-if-includes">documented here</a>),
which I think checks the reflog to make sure that you’ve already integrated the
remote branch into your branch somehow. I still don’t totally understand this
but I found this <a href="https://stackoverflow.com/questions/65837109/when-should-i-use-git-push-force-if-includes">stack overflow conversation</a>
helpful.</p>

<h3 id="solution-3-1-git-reset-hard-origin-main">solution 3.1: <code>git reset --hard origin/main</code></h3>

<p>You can use this as the reverse of <code>git push --force</code> (since there’s no <code>git pull --force</code>). I do this when I know that
my <strong>local</strong> work shouldn’t be there and I want to throw it away and replace it
with whatever’s on the remote branch.</p>

<p>For example, I might do this if I accidentally made a commit to <code>main</code> that
actually should have been on new branch. In that case I’ll also create a new
branch (<code>new-branch</code> in this example) to store my local work on the <code>main</code>
branch, so it’s not really being thrown away.</p>

<p>Fixing that problem looks like this:</p>

<pre><code>git checkout main

# 1. create `new-branch` to store my work
git checkout -b new-branch   

# 2. go back to the `main` branch I messed up
git checkout main            

# 3. make sure that my `origin/main` is up to date
git fetch                    

# 4. double check to make sure I don&#39;t have any uncomitted 
# work because `git reset --hard` will blow it away                                       
git status                   

# 5. force my local branch to match the remote `main`                               
#    NOTE: replace `origin/main` with the actual name of the
#    remote/branch, you can get this from `git status`.
git reset --hard origin/main  
</code></pre>

<p>This “store your work on <code>main</code> on a new branch and then <code>git reset --hard</code>” pattern can
also be useful if you’re not sure yet how to solve the conflict, since most
people are more used to merging 2 local branches than dealing with merging a
remote branch.</p>

<p>As always <code>git reset --hard</code> is a dangerous action and you can permanently lose
your uncommitted work. I always run <code>git status</code> first to make sure I don’t
have any uncommitted changes.</p>

<p>Some alternatives to using <code>git reset --hard</code> for this:</p>

<ul>
<li>check out some other branch and run <code>git branch -f main origin/main</code>.</li>
<li>check out some other branch and run <code>git fetch origin main:main --force</code></li>
</ul>

<h3 id="that-s-all">that’s all!</h3>

<p>I’d never really thought about how confusing the <code>git push</code> and <code>git pull</code>
error messages can be if you’re not used to reading them.</p>

</div></div>
  </body>
</html>
