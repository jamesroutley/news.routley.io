<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/01mf02/jaq">Original</a>
    <h1>Jaq â€“ A jq clone focused on correctness, speed, and simplicity</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/01mf02/jaq/workflows/Rust/badge.svg"><img src="https://github.com/01mf02/jaq/workflows/Rust/badge.svg" alt="Build status"/></a>
<a href="https://crates.io/crates/jaq-interpret" rel="nofollow"><img src="https://camo.githubusercontent.com/3c79938a5952cfb706aa084332dcb2870ba5c86dbe328e6b03a816ba928ea806/68747470733a2f2f696d672e736869656c64732e696f2f6372617465732f762f6a61712d696e746572707265742e737667" alt="Crates.io" data-canonical-src="https://img.shields.io/crates/v/jaq-interpret.svg"/></a>
<a href="https://docs.rs/jaq-interpret" rel="nofollow"><img src="https://camo.githubusercontent.com/7c9ab2bea037ce46569ecf5370070f9dad63ff1c40cf5cef41ba8f77ad6bd436/68747470733a2f2f646f63732e72732f6a61712d696e746572707265742f62616467652e737667" alt="Documentation" data-canonical-src="https://docs.rs/jaq-interpret/badge.svg"/></a>
<a href="https://www.rust-lang.org" rel="nofollow"><img src="https://camo.githubusercontent.com/9595c6fea652a42b90d506e8670efde9cdb1ca0e086b154d202abd3588162bc8/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f727573742d312e36342b2d6f72616e67652e737667" alt="Rust 1.64+" data-canonical-src="https://img.shields.io/badge/rust-1.64+-orange.svg"/></a></p>
<p dir="auto">jaq (pronounced like <em>Jacques</em><sup><a href="#user-content-fn-jacques-9534c8db200f0c1e3532e80e8a4621d1" id="user-content-fnref-jacques-9534c8db200f0c1e3532e80e8a4621d1" data-footnote-ref="" aria-describedby="footnote-label">1</a></sup>) is a clone of the JSON data processing tool <a href="https://jqlang.github.io/jq/" rel="nofollow">jq</a>.
jaq aims to support a large subset of jq&#39;s syntax and operations.</p>
<p dir="auto">jaq focuses on three goals:</p>
<ul dir="auto">
<li>
<p dir="auto"><strong>Correctness</strong>:
jaq aims to provide a more correct and predictable implementation of jq,
while preserving compatibility with jq in most cases.</p>
<details><summary>Examples of surprising jq behaviour</summary>
<ul dir="auto">
<li><code>nan &gt; nan</code> is false, while <code>nan &lt; nan</code> is true.</li>
<li><code>[[]] | implode</code> crashes jq, and this was not fixed at the time of writing despite
<a href="https://github.com/jqlang/jq/issues/1160" data-hovercard-type="issue" data-hovercard-url="/jqlang/jq/issues/1160/hovercard">being known since five years</a>.</li>
<li>The <a href="https://jqlang.github.io/jq/manual/v1.6/" rel="nofollow">jq manual</a> claims that <code>limit(n; exp)</code> &#34;extracts up to <code>n</code> outputs from <code>exp</code>&#34;.
This holds for values of <code>n &gt; 1</code>, e.g. <code>jq -n &#39;[limit(2; 1, 2, 3)]&#39;</code> yields
<code>[1, 2]</code>, but when <code>n == 0</code>, <code>jq -n &#39;[limit(0; 1, 2, 3)]&#39;</code> yields <code>[1]</code> instead of <code>[]</code>.
And perhaps even worse, when <code>n &lt; 0</code>, then <code>limit</code> yields <em>all</em> outputs from <code>exp</code>,
which is not documented.</li>
</ul>
</details>
</li>
<li>
<p dir="auto"><strong>Performance</strong>:
I created jaq originally because I was bothered by
<a href="https://github.com/jqlang/jq/issues/1411" data-hovercard-type="issue" data-hovercard-url="/jqlang/jq/issues/1411/hovercard">jq&#39;s long start-up time</a>,
which amounts to about 50ms on my machine.
This can particularly show when processing a large number of small files.
jaq starts up about 30 times faster than jq 1.6 and
<a href="#performance">outperforms jq also on many other benchmarks</a>.</p>
</li>
<li>
<p dir="auto"><strong>Simplicity</strong>:
jaq aims to have a simple and small implementation, in order to
reduce the potential for bugs and to
facilitate contributions.</p>
</li>
</ul>
<p dir="auto">I drew inspiration from another Rust program, namely <a href="https://github.com/yamafaktory/jql">jql</a>.
However, unlike jql, jaq aims to closely imitate jq&#39;s syntax and semantics.
This should allow users proficient in jq to easily use jaq.</p>

<h2 tabindex="-1" dir="auto"><a id="user-content-from-source" aria-hidden="true" tabindex="-1" href="#from-source"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>From Source</h2>
<p dir="auto">To compile jaq, you need a Rust toolchain.
See <a href="https://rustup.rs/" rel="nofollow">https://rustup.rs/</a> for instructions.
(Note that Rust compilers shipped with Linux distributions
may be too outdated to compile jaq.)</p>
<p dir="auto">Any of the following commands install jaq:</p>
<div data-snippet-clipboard-copy-content="$ cargo install --locked jaq
$ cargo install --locked --git https://github.com/01mf02/jaq # latest development version"><pre><code>$ cargo install --locked jaq
$ cargo install --locked --git https://github.com/01mf02/jaq # latest development version
</code></pre></div>
<p dir="auto">On my system, both commands place the executable at <code>~/.cargo/bin/jaq</code>.</p>
<p dir="auto">If you have cloned this repository, you can also build jaq by executing one of the commands in the cloned repository:</p>
<div data-snippet-clipboard-copy-content="$ cargo build --release # places binary into target/release/jaq
$ cargo install --locked --path jaq # installs binary"><pre><code>$ cargo build --release # places binary into target/release/jaq
$ cargo install --locked --path jaq # installs binary
</code></pre></div>
<p dir="auto">jaq should work on any system supported by Rust.
If it does not, please file an issue.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-binaries" aria-hidden="true" tabindex="-1" href="#binaries"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Binaries</h2>
<p dir="auto">You may also install jaq using <a href="https://formulae.brew.sh/formula/jaq" rel="nofollow">homebrew</a> on macOS or Linux:</p>
<div data-snippet-clipboard-copy-content="$ brew install jaq
$ brew install --HEAD jaq # latest development version"><pre><code>$ brew install jaq
$ brew install --HEAD jaq # latest development version
</code></pre></div>

<p dir="auto">The following examples should give an impression of what jaq can currently do.
You should obtain the same outputs by replacing jaq with jq.
If not, your filing an issue would be appreciated. :)
The syntax is documented in the <a href="https://jqlang.github.io/jq/manual/v1.6/" rel="nofollow">jq manual</a>.</p>
<p dir="auto">Access a field:</p>
<div data-snippet-clipboard-copy-content="$ echo &#39;{&#34;a&#34;: 1, &#34;b&#34;: 2}&#39; | jaq &#39;.a&#39;
1"><pre><code>$ echo &#39;{&#34;a&#34;: 1, &#34;b&#34;: 2}&#39; | jaq &#39;.a&#39;
1
</code></pre></div>
<p dir="auto">Add values:</p>
<div data-snippet-clipboard-copy-content="$ echo &#39;{&#34;a&#34;: 1, &#34;b&#34;: 2}&#39; | jaq &#39;add&#39;
3"><pre><code>$ echo &#39;{&#34;a&#34;: 1, &#34;b&#34;: 2}&#39; | jaq &#39;add&#39;
3
</code></pre></div>
<p dir="auto">Construct an array from an object in two ways and show that they are equal:</p>
<div data-snippet-clipboard-copy-content="$ echo &#39;{&#34;a&#34;: 1, &#34;b&#34;: 2}&#39; | jaq &#39;[.a, .b] == [.[]]&#39;
true"><pre><code>$ echo &#39;{&#34;a&#34;: 1, &#34;b&#34;: 2}&#39; | jaq &#39;[.a, .b] == [.[]]&#39;
true
</code></pre></div>
<p dir="auto">Apply a filter to all elements of an array and filter the results:</p>
<div data-snippet-clipboard-copy-content="$ echo &#39;[0, 1, 2, 3]&#39; | jaq &#39;map(.*2) | [.[] | select(. &lt; 5)]&#39;
[0, 2, 4]"><pre><code>$ echo &#39;[0, 1, 2, 3]&#39; | jaq &#39;map(.*2) | [.[] | select(. &lt; 5)]&#39;
[0, 2, 4]
</code></pre></div>
<p dir="auto">Read (slurp) input values into an array and get the average of its elements:</p>
<div data-snippet-clipboard-copy-content="$ echo &#39;1 2 3 4&#39; | jaq -s &#39;add / length&#39;
2.5"><pre><code>$ echo &#39;1 2 3 4&#39; | jaq -s &#39;add / length&#39;
2.5
</code></pre></div>
<p dir="auto">Repeatedly apply a filter to itself and output the intermediate results:</p>
<div data-snippet-clipboard-copy-content="$ echo &#39;0&#39; | jaq &#39;[recurse(.+1; . &lt; 3)]&#39;
[0, 1, 2]"><pre><code>$ echo &#39;0&#39; | jaq &#39;[recurse(.+1; . &lt; 3)]&#39;
[0, 1, 2]
</code></pre></div>
<p dir="auto">Lazily fold over inputs and output intermediate results:</p>
<div data-snippet-clipboard-copy-content="$ seq 1000 | jaq -n &#39;foreach inputs as $x (0; . + $x)&#39;
1 3 6 10 15 [...]"><pre><code>$ seq 1000 | jaq -n &#39;foreach inputs as $x (0; . + $x)&#39;
1 3 6 10 15 [...]
</code></pre></div>

<p dir="auto">The following evaluation consists of several benchmarks that
allow comparing the performance of jaq, jq, and <a href="https://github.com/itchyny/gojq">gojq</a>.
The <code>empty</code> benchmark runs <code>n</code> times the filter <code>empty</code> with null input,
serving to measure the startup time.
The <code>bf-fib</code> benchmark runs a Brainfuck interpreter written in jq,
interpreting a Brainfuck script that produces <code>n</code> Fibonacci numbers.
The other benchmarks evaluate various filters with <code>n</code> as input;
see <a href="https://github.com/01mf02/jaq/blob/main/bench.sh"><code>bench.sh</code></a> for details.</p>
<p dir="auto">I generated the benchmark data with
<code>bench.sh target/release/jaq jq-1.7 gojq-0.12.13 jq-1.6 | tee bench.json</code>
on a Linux system with an AMD Ryzen 5 5500U.<sup><a href="#user-content-fn-binaries-9534c8db200f0c1e3532e80e8a4621d1" id="user-content-fnref-binaries-9534c8db200f0c1e3532e80e8a4621d1" data-footnote-ref="" aria-describedby="footnote-label">2</a></sup>
I then processed the results with a &#34;one-liner&#34; (stretching the term and the line a bit):</p>
<div data-snippet-clipboard-copy-content="jq -rs &#39;.[] | &#34;|`\(.name)`|\(.n)|&#34; + ([.time[] | min | (.*1000|round)? // &#34;N/A&#34;] | min as $total_min | map(if . == $total_min then &#34;**\(.)**&#34; else &#34;\(.)&#34; end) | join(&#34;|&#34;))&#39; bench.json"><pre><code>jq -rs &#39;.[] | &#34;|`\(.name)`|\(.n)|&#34; + ([.time[] | min | (.*1000|round)? // &#34;N/A&#34;] | min as $total_min | map(if . == $total_min then &#34;**\(.)**&#34; else &#34;\(.)&#34; end) | join(&#34;|&#34;))&#39; bench.json
</code></pre></div>
<p dir="auto">(Of course, you can also use jaq here instead of jq.)
Finally, I concatenated the table header with the output and piped it through <code>pandoc -t gfm</code>.</p>
<p dir="auto">Table: Evaluation results in milliseconds (&#34;N/A&#34; if more than 10 seconds).</p>
<table>
<thead>
<tr>
<th>Benchmark</th>
<th>n</th>
<th>jaq-1.2</th>
<th>jq-1.7</th>
<th>gojq-0.12.13</th>
<th>jq-1.6</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>empty</code></td>
<td>512</td>
<td><strong>650</strong></td>
<td>790</td>
<td>740</td>
<td>8340</td>
</tr>
<tr>
<td><code>bf-fib</code></td>
<td>13</td>
<td><strong>410</strong></td>
<td>1280</td>
<td>820</td>
<td>1420</td>
</tr>
<tr>
<td><code>reverse</code></td>
<td>1048576</td>
<td><strong>60</strong></td>
<td>680</td>
<td>310</td>
<td>630</td>
</tr>
<tr>
<td><code>sort</code></td>
<td>1048576</td>
<td><strong>140</strong></td>
<td>530</td>
<td>600</td>
<td>670</td>
</tr>
<tr>
<td><code>group-by</code></td>
<td>1048576</td>
<td><strong>420</strong></td>
<td>1850</td>
<td>1680</td>
<td>2830</td>
</tr>
<tr>
<td><code>min-max</code></td>
<td>1048576</td>
<td><strong>220</strong></td>
<td>320</td>
<td>290</td>
<td>310</td>
</tr>
<tr>
<td><code>add</code></td>
<td>1048576</td>
<td><strong>480</strong></td>
<td>650</td>
<td>1540</td>
<td>750</td>
</tr>
<tr>
<td><code>kv</code></td>
<td>131072</td>
<td>160</td>
<td><strong>150</strong></td>
<td>250</td>
<td>200</td>
</tr>
<tr>
<td><code>kv-update</code></td>
<td>131072</td>
<td><strong>190</strong></td>
<td>530</td>
<td>570</td>
<td>N/A</td>
</tr>
<tr>
<td><code>kv-entries</code></td>
<td>131072</td>
<td><strong>580</strong></td>
<td>1170</td>
<td>820</td>
<td>1110</td>
</tr>
<tr>
<td><code>ex-implode</code></td>
<td>1048576</td>
<td><strong>460</strong></td>
<td>1110</td>
<td>740</td>
<td>1080</td>
</tr>
<tr>
<td><code>reduce</code></td>
<td>1048576</td>
<td><strong>740</strong></td>
<td>880</td>
<td>N/A</td>
<td>850</td>
</tr>
<tr>
<td><code>try-catch</code></td>
<td>1048576</td>
<td><strong>180</strong></td>
<td>330</td>
<td>480</td>
<td>650</td>
</tr>
<tr>
<td><code>tree-flatten</code></td>
<td>17</td>
<td>650</td>
<td>360</td>
<td><strong>0</strong></td>
<td>480</td>
</tr>
<tr>
<td><code>tree-update</code></td>
<td>17</td>
<td><strong>450</strong></td>
<td>980</td>
<td>1850</td>
<td>1180</td>
</tr>
<tr>
<td><code>tree-paths</code></td>
<td>17</td>
<td>450</td>
<td><strong>380</strong></td>
<td>920</td>
<td>470</td>
</tr>
<tr>
<td><code>to-fromjson</code></td>
<td>65536</td>
<td><strong>40</strong></td>
<td>370</td>
<td>100</td>
<td>380</td>
</tr>
<tr>
<td><code>ack</code></td>
<td>7</td>
<td><strong>570</strong></td>
<td>680</td>
<td>1090</td>
<td>610</td>
</tr>
<tr>
<td><code>range-prop</code></td>
<td>128</td>
<td><strong>260</strong></td>
<td>310</td>
<td>320</td>
<td>580</td>
</tr>
</tbody>
</table>
<p dir="auto">The results show that
jaq-1.2 is fastest on 16 benchmarks, whereas
jq-1.7 is fastest on 2 benchmarks and
gojq-0.12.13 is fastest on 1 benchmark.
gojq is much faster on <code>tree-flatten</code> because it implements the filter <code>flatten</code> natively instead of by definition.</p>

<p dir="auto">Here is an overview that summarises:</p>
<ul>
<li> features already implemented, and</li>
<li> features not yet implemented.</li>
</ul>
<p dir="auto"><a href="#contributing">Contributions to extend jaq are highly welcome.</a></p>
<h2 tabindex="-1" dir="auto"><a id="user-content-basics" aria-hidden="true" tabindex="-1" href="#basics"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Basics</h2>
<ul>
<li> Identity (<code>.</code>)</li>
<li> Recursion (<code>..</code>)</li>
<li> Basic data types (null, boolean, number, string, array, object)</li>
<li> if-then-else (<code>if .a &lt; .b then .a else .b end</code>)</li>
<li> Folding (<code>reduce .[] as $x (0; . + $x)</code>, <code>foreach .[] as $x (0; . + $x; . + .)</code>)</li>
<li> Error handling (<code>try ... catch ...</code>) (see the <a href="#error-handling">differences from jq</a>)</li>
<li> String interpolation (<code>&#34;The successor of \(.) is \(.+1).&#34;</code>)</li>
<li> Format strings (<code>@json</code>, <code>@text</code>, <code>@csv</code>, <code>@tsv</code>, <code>@html</code>, <code>@sh</code>, <code>@base64</code>, <code>@base64d</code>)</li>
</ul>
<h2 tabindex="-1" dir="auto"><a id="user-content-paths" aria-hidden="true" tabindex="-1" href="#paths"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Paths</h2>
<ul>
<li> Indexing of arrays/objects (<code>.[0]</code>, <code>.a</code>, <code>.[&#34;a&#34;]</code>)</li>
<li> Iterating over arrays/objects (<code>.[]</code>)</li>
<li> Optional indexing/iteration (<code>.a?</code>, <code>.[]?</code>)</li>
<li> Array slices (<code>.[3:7]</code>, <code>.[0:-1]</code>)</li>
<li> String slices</li>
</ul>
<h2 tabindex="-1" dir="auto"><a id="user-content-operators" aria-hidden="true" tabindex="-1" href="#operators"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Operators</h2>
<ul>
<li> Composition (<code>|</code>)</li>
<li> Binding (<code>. as $x | $x</code>)</li>
<li> Concatenation (<code>,</code>)</li>
<li> Plain assignment (<code>=</code>)</li>
<li> Update assignment (<code>|=</code>, <code>+=</code>, <code>-=</code>)</li>
<li> Alternation (<code>//</code>)</li>
<li> Logic (<code>or</code>, <code>and</code>)</li>
<li> Equality and comparison (<code>.a == .b</code>, <code>.a &lt; .b</code>)</li>
<li> Arithmetic (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>)</li>
<li> Negation (<code>-</code>)</li>
<li> Error suppression (<code>?</code>)</li>
</ul>
<h2 tabindex="-1" dir="auto"><a id="user-content-definitions" aria-hidden="true" tabindex="-1" href="#definitions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Definitions</h2>
<ul>
<li> Basic definitions (<code>def map(f): [.[] | f];</code>)</li>
<li> Recursive definitions (<code>def r: r; r</code>)</li>
</ul>
<h2 tabindex="-1" dir="auto"><a id="user-content-core-filters" aria-hidden="true" tabindex="-1" href="#core-filters"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Core filters</h2>
<ul>
<li> Empty (<code>empty</code>)</li>
<li> Errors (<code>error</code>)</li>
<li> Input (<code>inputs</code>)</li>
<li> Length (<code>length</code>, <code>utf8bytelength</code>)</li>
<li> Rounding (<code>floor</code>, <code>round</code>, <code>ceil</code>)</li>
<li> String &lt;-&gt; JSON (<code>fromjson</code>, <code>tojson</code>)</li>
<li> String &lt;-&gt; integers (<code>explode</code>, <code>implode</code>)</li>
<li> String normalisation (<code>ascii_downcase</code>, <code>ascii_upcase</code>)</li>
<li> String prefix/postfix (<code>startswith</code>, <code>endswith</code>, <code>ltrimstr</code>, <code>rtrimstr</code>)</li>
<li> String splitting (<code>split(&#34;foo&#34;)</code>)</li>
<li> Array filters (<code>reverse</code>, <code>sort</code>, <code>sort_by(-.)</code>, <code>group_by</code>, <code>min_by</code>, <code>max_by</code>)</li>
<li> Stream consumers (<code>first</code>, <code>last</code>, <code>range</code>, <code>fold</code>)</li>
<li> Stream generators (<code>range</code>, <code>recurse</code>)</li>
<li> Time (<code>now</code>, <code>fromdateiso8601</code>, <code>todateiso8601</code>)</li>
<li> More numeric filters (<code>sqrt</code>, <code>sin</code>, <code>log</code>, <code>pow</code>, ...) (<a href="#numeric-filters">list of numeric filters</a>)</li>
<li> More time filters (<code>strptime</code>, <code>strftime</code>, <code>strflocaltime</code>, <code>mktime</code>, <code>gmtime</code>, and <code>localtime</code>)</li>
</ul>
<h2 tabindex="-1" dir="auto"><a id="user-content-standard-filters" aria-hidden="true" tabindex="-1" href="#standard-filters"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Standard filters</h2>
<p dir="auto">These filters are defined via more basic filters.
Their definitions are at <a href="https://github.com/01mf02/jaq/blob/main/jaq-std/src/std.jq"><code>std.jq</code></a>.</p>
<ul>
<li> Undefined (<code>null</code>)</li>
<li> Booleans (<code>true</code>, <code>false</code>, <code>not</code>)</li>
<li> Special numbers (<code>nan</code>, <code>infinite</code>, <code>isnan</code>, <code>isinfinite</code>, <code>isfinite</code>, <code>isnormal</code>)</li>
<li> Type (<code>type</code>)</li>
<li> Filtering (<code>select(. &gt;= 0)</code>)</li>
<li> Selection (<code>values</code>, <code>nulls</code>, <code>booleans</code>, <code>numbers</code>, <code>strings</code>, <code>arrays</code>, <code>objects</code>, <code>iterables</code>, <code>scalars</code>)</li>
<li> Conversion (<code>tostring</code>, <code>tonumber</code>)</li>
<li> Iterable filters (<code>map(.+1)</code>, <code>map_values(.+1)</code>, <code>add</code>, <code>join(&#34;a&#34;)</code>)</li>
<li> Array filters (<code>transpose</code>, <code>first</code>, <code>last</code>, <code>nth(10)</code>, <code>flatten</code>, <code>min</code>, <code>max</code>)</li>
<li> Object-array conversion (<code>to_entries</code>, <code>from_entries</code>, <code>with_entries</code>)</li>
<li> Universal/existential (<code>all</code>, <code>any</code>)</li>
<li> Recursion (<code>walk</code>)</li>
<li> I/O (<code>input</code>)</li>
<li> Regular expressions (<code>test</code>, <code>scan</code>, <code>match</code>, <code>capture</code>, <code>splits</code>, <code>sub</code>, <code>gsub</code>)</li>
<li> Time (<code>fromdate</code>, <code>todate</code>)</li>
</ul>
<h2 tabindex="-1" dir="auto"><a id="user-content-numeric-filters" aria-hidden="true" tabindex="-1" href="#numeric-filters"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Numeric filters</h2>
<p dir="auto">jaq imports many filters from <a href="https://crates.io/crates/libm" rel="nofollow">libm</a>
and follows their type signature.</p>
<details><summary>Full list of numeric filters defined in jaq</summary>
<p dir="auto">Zero-argument filters:</p>
<ul>
<li> <code>acos</code></li>
<li> <code>acosh</code></li>
<li> <code>asin</code></li>
<li> <code>asinh</code></li>
<li> <code>atan</code></li>
<li> <code>atanh</code></li>
<li> <code>cbrt</code></li>
<li> <code>cos</code></li>
<li> <code>cosh</code></li>
<li> <code>erf</code></li>
<li> <code>erfc</code></li>
<li> <code>exp</code></li>
<li> <code>exp10</code></li>
<li> <code>exp2</code></li>
<li> <code>expm1</code></li>
<li> <code>fabs</code></li>
<li> <code>frexp</code>, which returns pairs of (float, integer).</li>
<li> <code>ilogb</code>, which returns integers.</li>
<li> <code>j0</code></li>
<li> <code>j1</code></li>
<li> <code>lgamma</code></li>
<li> <code>log</code></li>
<li> <code>log10</code></li>
<li> <code>log1p</code></li>
<li> <code>log2</code></li>
<li> <code>logb</code></li>
<li> <code>modf</code>, which returns pairs of (float, float).</li>
<li> <code>nearbyint</code></li>
<li> <code>pow10</code></li>
<li> <code>rint</code></li>
<li> <code>significand</code></li>
<li> <code>sin</code></li>
<li> <code>sinh</code></li>
<li> <code>sqrt</code></li>
<li> <code>tan</code></li>
<li> <code>tanh</code></li>
<li> <code>tgamma</code></li>
<li> <code>trunc</code></li>
<li> <code>y0</code></li>
<li> <code>y1</code></li>
</ul>
<p dir="auto">Two-argument filters that ignore <code>.</code>:</p>
<ul>
<li> <code>atan2</code></li>
<li> <code>copysign</code></li>
<li> <code>drem</code></li>
<li> <code>fdim</code></li>
<li> <code>fmax</code></li>
<li> <code>fmin</code></li>
<li> <code>fmod</code></li>
<li> <code>hypot</code></li>
<li> <code>jn</code>, which takes an integer as first argument.</li>
<li> <code>ldexp</code>, which takes an integer as second argument.</li>
<li> <code>nextafter</code></li>
<li> <code>nexttoward</code></li>
<li> <code>pow</code></li>
<li> <code>remainder</code></li>
<li> <code>scalb</code></li>
<li> <code>scalbln</code>, which takes as integer as second argument.</li>
<li> <code>yn</code>, which takes an integer as first argument.</li>
</ul>
<p dir="auto">Three-argument filters that ignore <code>.</code>:</p>
<ul>
<li> <code>fma</code></li>
</ul>
</details>
<h2 tabindex="-1" dir="auto"><a id="user-content-advanced-features" aria-hidden="true" tabindex="-1" href="#advanced-features"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Advanced features</h2>
<p dir="auto">jaq currently does <em>not</em> aim to support several features of jq, such as:</p>
<ul dir="auto">
<li>Modules</li>
<li>SQL-style operators</li>
<li>Streaming</li>
</ul>

<h2 tabindex="-1" dir="auto"><a id="user-content-numbers" aria-hidden="true" tabindex="-1" href="#numbers"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Numbers</h2>
<p dir="auto">jq uses 64-bit floating-point numbers (floats) for any number.
By contrast, jaq interprets
numbers such as 0   or -42 as machine-sized integers and
numbers such as 0.0 or 3e8 as 64-bit floats.
Many operations in jaq, such as array indexing,
check whether the passed numbers are indeed integer.
The motivation behind this is to avoid
rounding errors that may silently lead to wrong results.
For example:</p>
<div data-snippet-clipboard-copy-content="$ jq  -n &#39;[0, 1, 2] | .[1.0000000000000001]&#39;
1
$ jaq -n &#39;[0, 1, 2] | .[1.0000000000000001]&#39;
Error: cannot use 1.0 as integer
$ jaq -n &#39;[0, 1, 2] | .[1]&#39;
1"><pre><code>$ jq  -n &#39;[0, 1, 2] | .[1.0000000000000001]&#39;
1
$ jaq -n &#39;[0, 1, 2] | .[1.0000000000000001]&#39;
Error: cannot use 1.0 as integer
$ jaq -n &#39;[0, 1, 2] | .[1]&#39;
1
</code></pre></div>
<p dir="auto">The rules of jaq are:</p>
<ul dir="auto">
<li>The sum, difference, product, and remainder of two integers is integer.</li>
<li>Any other operation between two numbers yields a float.</li>
</ul>
<p dir="auto">Examples:</p>
<div data-snippet-clipboard-copy-content="$ jaq -n &#39;1 + 2&#39;
3
$ jaq -n &#39;10 / 2&#39;
5.0
$ jaq -n &#39;1.0 + 2&#39;
3.0"><pre><code>$ jaq -n &#39;1 + 2&#39;
3
$ jaq -n &#39;10 / 2&#39;
5.0
$ jaq -n &#39;1.0 + 2&#39;
3.0
</code></pre></div>
<p dir="auto">You can convert an integer to a floating-point number e.g.
by adding 0.0, by multiplying with 1.0, or by dividing with 1.
You can convert a floating-point number to an integer by
<code>round</code>, <code>floor</code>, or <code>ceil</code>:</p>
<div data-snippet-clipboard-copy-content="$ jaq -n &#39;1.2 | [floor, round, ceil]&#39;
[1, 1, 2]"><pre><code>$ jaq -n &#39;1.2 | [floor, round, ceil]&#39;
[1, 1, 2]
</code></pre></div>
<h3 tabindex="-1" dir="auto"><a id="user-content-nan-and-infinity" aria-hidden="true" tabindex="-1" href="#nan-and-infinity"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>NaN and infinity</h3>
<p dir="auto">In jq, division by 0 has some surprising properties; for example,
<code>0 / 0</code> yields <code>nan</code>, whereas
<code>0 as $n | $n / 0</code> yields an error.
In jaq, <code>n / 0</code> yields <code>nan</code> if <code>n == 0</code>, <code>infinite</code> if <code>n &gt; 0</code>, and <code>-infinite</code> if <code>n &lt; 0</code>.
jaq&#39;s behaviour is closer to the IEEE standard for floating-point arithmetic (IEEE 754).</p>
<p dir="auto">jaq implements a total ordering on floating-point numbers to allow sorting values.
Therefore, it unfortunately has to enforce that <code>nan == nan</code>.
(jq gets around this by enforcing <code>nan &lt; nan</code>, which breaks basic laws about total orders.)</p>
<p dir="auto">Like jq, jaq prints <code>nan</code> and <code>infinite</code> as <code>null</code> in JSON,
because JSON does not support encoding these values as numbers.</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-preservation-of-fractional-numbers" aria-hidden="true" tabindex="-1" href="#preservation-of-fractional-numbers"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Preservation of fractional numbers</h3>
<p dir="auto">jaq preserves fractional numbers coming from JSON data perfectly
(as long as they are not used in some arithmetic operation),
whereas jq 1.6 may silently convert to 64-bit floating-point numbers:</p>
<div data-snippet-clipboard-copy-content="$ echo &#39;1e500&#39; | jq &#39;.&#39;
1.7976931348623157e+308
$ echo &#39;1e500&#39; | jaq &#39;.&#39;
1e500"><pre><code>$ echo &#39;1e500&#39; | jq &#39;.&#39;
1.7976931348623157e+308
$ echo &#39;1e500&#39; | jaq &#39;.&#39;
1e500
</code></pre></div>
<p dir="auto">Therefore, unlike jq 1.6, jaq satisfies the following paragraph in the <a href="https://jqlang.github.io/jq/manual/v1.6/" rel="nofollow">jq manual</a>:</p>
<blockquote>
<p dir="auto">An important point about the identity filter is that
it guarantees to preserve the literal decimal representation of values.
This is particularly important when dealing with numbers which can&#39;t be
losslessly converted to an IEEE754 double precision representation.</p>
</blockquote>
<p dir="auto">Please note that newer versions of jq, e.g. 1.7,
seem to preserve the literal decimal representation as well.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-assignments" aria-hidden="true" tabindex="-1" href="#assignments"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Assignments</h2>
<p dir="auto">Like jq, jaq allows for assignments of the form <code>p |= f</code>.
However, jaq interprets these assignments differently.
Fortunately, in most cases, the result is the same.</p>
<p dir="auto">In jq, an assignment <code>p |= f</code> first constructs paths to all values that match <code>p</code>.
<em>Only then</em>, it applies the filter <code>f</code> to these values.</p>
<p dir="auto">In jaq, an assignment <code>p |= f</code> applies <code>f</code> <em>immediately</em> to any value matching <code>p</code>.
Unlike in jq, assignment does not explicitly construct paths.</p>
<p dir="auto">jaq&#39;s implementation of assignment likely yields higher performance,
because it does not construct paths.
Furthermore, this also prevents several bugs in jq &#34;by design&#34;.
For example, given the filter <code>[0, 1, 2, 3] | .[] |= empty</code>,
jq  yields <code>[1, 3]</code>, whereas
jaq yields <code>[]</code>.
What happens here?</p>
<p dir="auto">jq first constructs the paths corresponding to <code>.[]</code>, which are <code>.0, .1, .2, .3</code>.
Then, it removes the element at each of these paths.
However, each of these removals <em>changes</em> the value that the remaining paths refer to.
That is, after removing <code>.0</code> (value 0), <code>.1</code> does not refer to value 1, but value 2!
That is also why value 1 (and in consequence also value 3) is not removed.</p>
<p dir="auto">There is more weirdness ahead in jq;
for example, <code>0 | 0 |= .+1</code> yields <code>1</code> in jq,
although <code>0</code> is not a valid path expression.
However, <code>1 | 0 |= .+1</code> yields an error.
In jaq, any such assignment yields an error.</p>
<p dir="auto">jaq attempts to use multiple outputs of the right-hand side, whereas
jq uses only the first.
For example, <code>0 | (., .) |= (., .+1)</code> yields <code>0 1 1 2</code> in jaq,
whereas it yields only <code>0</code> in jq.
However, <code>{a: 1} | .a |= (2, 3)</code> yields <code>{&#34;a&#34;: 2}</code> in both jaq and jq,
because an object can only associate a single value with any given key,
so we cannot use multiple outputs in a meaningful way here.</p>
<p dir="auto">Because jaq does not construct paths,
it does not allow some filters on the left-hand side of assignments,
for example <code>first</code>, <code>last</code>, <code>limit</code>:
For example, <code>[1, 2, 3] | first(.[]) |= .-1</code>
yields <code>[0, 2, 3]</code> in jq, but is invalid in jaq.
Similarly, <code>[1, 2, 3] | limit(2; .[]) |= .-1</code>
yields <code>[0, 1, 3]</code> in jq, but is invalid in jaq.
(Inconsequentially, jq also does not allow for <code>last</code>.)</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-definitions-1" aria-hidden="true" tabindex="-1" href="#definitions-1"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Definitions</h2>
<p dir="auto">Like jq, jaq allows for the definition of filters, such as:</p>

<p dir="auto">Arguments can also be passed <em>by value</em>, such as:</p>
<div data-snippet-clipboard-copy-content="def cartesian($f; $g): [$f, $g];"><pre><code>def cartesian($f; $g): [$f, $g];
</code></pre></div>
<p dir="auto">Filter definitions can be nested and recursive, i.e. refer to themselves.
That is, a filter such as <code>recurse</code> can be defined in jaq:</p>
<div data-snippet-clipboard-copy-content="def recurse(f): def r: ., (f | r); r;"><pre><code>def recurse(f): def r: ., (f | r); r;
</code></pre></div>
<p dir="auto">Since jaq 1.2, jaq optimises tail calls, like jq.
Since jaq 1.1, recursive filters can also have non-variable arguments, like in jq.
For example:</p>

<p dir="auto">Recursive filters with non-variable arguments can yield surprising effects;
for example, a call <code>f(0)</code> builds up calls of the shape <code>f(1+(..(1+0)...))</code>,
which leads to exponential execution times.</p>
<p dir="auto">Recursive filters with non-variable arguments can
very frequently be alternatively implemented by either:</p>
<ul dir="auto">
<li>A nested filter: for example, instead of
<code>def walk(f): (.[]? |= walk(f)) | f;</code>, you can use
<code>def walk(f): def rec: (.[]? |= rec) | f; rec;</code>.</li>
<li>A filter with variable arguments: for example, instead of
<code>def f(a): a, f(1+a);</code>, you can equally well write
<code>def f($a): $a, f(1+$a);</code>.</li>
<li>A filter with <code>recurse</code>: for example, you may write
<code>def f(a): a | recurse(1+.);</code>.
If you expect your filter to recurse deeply,
it is advised to implement it using <code>recurse</code>,
because jaq has an optimised implementation of <code>recurse</code>.</li>
</ul>
<p dir="auto">All of these options are supported by jaq.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-arguments" aria-hidden="true" tabindex="-1" href="#arguments"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Arguments</h2>
<p dir="auto">Like jq, jaq allows to define arguments via the command line,
in particular by the options <code>--arg</code>, <code>--rawfile</code>, <code>--slurpfile</code>.
This binds variables to values, and
for every variable <code>$x</code> bound to <code>v</code> this way,
<code>$ARGS.named</code> contains an entry with key <code>x</code> and value <code>v</code>.
For example:</p>
<div data-snippet-clipboard-copy-content="$ jaq -n --arg x 1 --arg y 2 &#39;$x, $y, $ARGS.named&#39;
&#34;1&#34;
&#34;2&#34;
{
  &#34;x&#34;: &#34;1&#34;,
  &#34;y&#34;: &#34;2&#34;
}"><pre><code>$ jaq -n --arg x 1 --arg y 2 &#39;$x, $y, $ARGS.named&#39;
&#34;1&#34;
&#34;2&#34;
{
  &#34;x&#34;: &#34;1&#34;,
  &#34;y&#34;: &#34;2&#34;
}
</code></pre></div>
<h2 tabindex="-1" dir="auto"><a id="user-content-folding" aria-hidden="true" tabindex="-1" href="#folding"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Folding</h2>
<p dir="auto">jq and jaq provide filters
<code>reduce xs as $x (init; f)</code> and
<code>foreach xs as $x (init; f)</code>.</p>
<p dir="auto">In jaq, the output of these filters is defined very simply:
Assuming that <code>xs</code> evaluates to <code>x0</code>, <code>x1</code>, ..., <code>xn</code>,
<code>reduce xs as $x (init; f)</code> evaluates to</p>
<div data-snippet-clipboard-copy-content="init
| x0 as $x | f
| ...
| xn as $x | f"><pre><code>init
| x0 as $x | f
| ...
| xn as $x | f
</code></pre></div>
<p dir="auto">and <code>foreach xs as $x (init; f)</code> evaluates to</p>
<div data-snippet-clipboard-copy-content="init
| x0 as $x | f | (.,
| ...
| xn as $x | f | (.,
empty)...)"><pre lang="text"><code>init
| x0 as $x | f | (.,
| ...
| xn as $x | f | (.,
empty)...)
</code></pre></div>
<p dir="auto">Additionally, jaq provides the filter <code>for xs as $x (init; f)</code> that evaluates to</p>
<div data-snippet-clipboard-copy-content="init
| ., (x0 as $x | f
| ...
| ., (xn as $x | f
)...)"><pre lang="text"><code>init
| ., (x0 as $x | f
| ...
| ., (xn as $x | f
)...)
</code></pre></div>
<p dir="auto">The difference between <code>foreach</code> and <code>for</code> is that
<code>for</code> yields the output of <code>init</code>, whereas <code>foreach</code> omits it.
For example,
<code>foreach (1, 2, 3) as $x (0; .+$x)</code> yields <code>1, 3, 6</code>, whereas
<code>for (1, 2, 3) as $x (0; .+$x)</code> yields <code>0, 1, 3, 6</code>.</p>
<p dir="auto">The interpretation of <code>reduce</code>/<code>foreach</code> in jaq has the following advantages over jq:</p>
<ul dir="auto">
<li>It deals very naturally with filters that yield multiple outputs.
In contrast, jq discriminates outputs of <code>f</code>,
because it recurses only on the last of them,
although it outputs all of them.
<details><summary>Example</summary>
`foreach (5, 10) as $x (1; .+$x, -.)` yields
`6, -1, 9, 1` in jq, whereas it yields
`6, 16, -6, -1, 9, 1` in jaq.
We can see that both jq and jaq yield the values `6` and `-1`
resulting from the first iteration (where `$x` is 5), namely
`1 | 5 as $x | (.+$x, -.)`.
However, jq performs the second iteration (where `$x` is 10)
*only on the last value* returned from the first iteration, namely `-1`,
yielding the values `9` and `1` resulting from
`-1 | 10 as $x | (.+$x, -.)`.
jaq yields these values too, but it also performs the second iteration
on all other values returned from the first iteration, namely `6`,
yielding the values `16` and `-6` that result from
` 6 | 10 as $x | (.+$x, -.)`.
</details>
</li>
<li>It makes the implementation of <code>reduce</code> and <code>foreach</code>
special cases of the same code, reducing the potential for bugs.</li>
</ul>
<p dir="auto">Compared to <code>foreach ...</code>, the filter <code>for ...</code>
(where <code>...</code> refers to <code>xs as $x (init; f)</code>)
has a stronger relationship with <code>reduce</code>.
In particular,
the values yielded by <code>reduce ...</code> are a subset of
the values yielded by <code>for ...</code>.
This does not hold if you replace <code>for</code> by <code>foreach</code>.</p>
<details>
As an example, if we set `...` to `empty as $x (0; .+$x)`, then
`foreach ...` yields no value, whereas
`for ...` and `reduce ...` yield `0`.
</details>
<p dir="auto">Furthermore, jq provides the filter
<code>foreach xs as $x (init; f; proj)</code> (<code>foreach/3</code>) and interprets
<code>foreach xs as $x (init; f)</code> (<code>foreach/2</code>) as
<code>foreach xs as $x (init; f; .)</code>, whereas
jaq does <em>not</em> provide <code>foreach/3</code> because
it requires completely separate logic from <code>foreach/2</code> and <code>reduce</code>
in both the parser and the interpreter.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-error-handling" aria-hidden="true" tabindex="-1" href="#error-handling"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Error handling</h2>
<p dir="auto">In jq, the <code>try f catch g</code> expression breaks out of the <code>f</code> stream as
soon as an error occurs, ceding control to <code>g</code> after that. This is
mentioned in its manual as a possible mechanism for breaking out of
loops
(<a href="https://jqlang.github.io/jq/manual/#breaking-out-of-control-structures" rel="nofollow">here</a>). jaq
however doesn&#39;t interrupt the <code>f</code> stream, but instead sends <em>each</em>
error value emitted to the <code>g</code> filter; the result is a stream of
values emitted from <code>f</code> with values emitted from <code>g</code> interspersed
where errors occurred.</p>
<p dir="auto">Consider the following example: this expression is <code>true</code> in jq,
because the first <code>error(2)</code> interrupts the stream:</p>
<div dir="auto" data-snippet-clipboard-copy-content="[try (1, error(2), 3, error(4)) catch .] == [1, 2]"><pre>[<span>try</span> (<span>1</span>, <span>error</span>(<span>2</span>), <span>3</span>, <span>error</span>(<span>4</span>)) <span>catch</span> <span>.</span>] <span>==</span> [<span>1</span>, <span>2</span>]</pre></div>
<p dir="auto">In jaq however, this holds:</p>
<div dir="auto" data-snippet-clipboard-copy-content="[try (1, error(2), 3, error(4)) catch .] == [1, 2, 3, 4]"><pre>[<span>try</span> (<span>1</span>, <span>error</span>(<span>2</span>), <span>3</span>, <span>error</span>(<span>4</span>)) <span>catch</span> <span>.</span>] <span>==</span> [<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>]</pre></div>
<h2 tabindex="-1" dir="auto"><a id="user-content-miscellaneous" aria-hidden="true" tabindex="-1" href="#miscellaneous"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Miscellaneous</h2>
<ul dir="auto">
<li>Slurping: When files are slurped in (via the <code>-s</code> / <code>--slurp</code> option),
jq combines the inputs of all files into one single array, whereas
jaq yields an array for every file.
The behaviour of jq can be approximated in jaq;
for example, to achieve the output of
<code>jq -s . a b</code>, you may use
<code>jaq -s . &lt;(cat a b)</code>.</li>
<li>Cartesian products:
In jq, <code>[(1,2) * (3,4)]</code> yields <code>[3, 6, 4, 8]</code>, whereas
<code>[{a: (1,2), b: (3,4)} | .a * .b]</code> yields <code>[3, 4, 6, 8]</code>.
jaq yields <code>[3, 4, 6, 8]</code> in both cases.</li>
<li>List updating:
In jq, <code>[0, 1] | .[3] = 3</code> yields <code>[0, 1, null, 3]</code>; that is,
jq fills up the list with <code>null</code>s if we update beyond its size.
In contrast, jaq fails with an out-of-bounds error in such a case.</li>
<li>Input reading:
When there is no more input value left,
in jq, <code>input</code> yields an error, whereas in jaq, it yields no output value.</li>
<li>Joining:
When given an array <code>[x0, x1, ..., xn]</code>,
in jq, <code>join(x)</code> converts all elements of the input array to strings and intersperses them with <code>x</code>, whereas
in jaq, <code>join(x)</code> simply calculates <code>x0 + x + x1 + x + ... + xn</code>.
When all elements of the input array and <code>x</code> are strings, jq and jaq yield the same output.</li>
</ul>

<p dir="auto">Contributions to jaq are welcome.
Please make sure that after your change, <code>cargo test</code> runs successfully.</p>

<p dir="auto">jaq has profited tremendously from:</p>
<ul dir="auto">
<li><a href="https://docs.rs/serde_json/" rel="nofollow">serde_json</a> to read and <a href="https://docs.rs/colored_json/" rel="nofollow">colored_json</a> to output JSON,</li>
<li><a href="https://docs.rs/chumsky/" rel="nofollow">chumsky</a> to parse and <a href="https://docs.rs/ariadne/" rel="nofollow">ariadne</a> to pretty-print parse errors,</li>
<li><a href="https://docs.rs/mimalloc/" rel="nofollow">mimalloc</a> to boost the performance of memory allocation, and</li>
<li>the Rust standard library, in particular its awesome <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html" rel="nofollow">Iterator</a>,
which builds the rock-solid base of jaq&#39;s filter execution</li>
</ul>
<section data-footnotes="">
<ol dir="auto">
<li id="user-content-fn-jacques-9534c8db200f0c1e3532e80e8a4621d1">
<p dir="auto">I wanted to create a tool that should be discreet and obliging, like a good waiter.
And when I think of a typical name for a (French) waiter, to my mind comes &#34;Jacques&#34;.
Later, I found out about the old French word <em>jacquet</em>, meaning &#34;squirrel&#34;,
which makes for a nice <em>ex post</em> inspiration for the name. <a href="#user-content-fnref-jacques-9534c8db200f0c1e3532e80e8a4621d1" data-footnote-backref="" aria-label="Back to reference 1">â†©</a></p>
</li>
<li id="user-content-fn-binaries-9534c8db200f0c1e3532e80e8a4621d1">
<p dir="auto">The binaries for jq-1.7 and gojq-0.12.13 were retrieved from their GitHub release pages,
the binary for jq-1.6 was installed from the standard Ubuntu repository. <a href="#user-content-fnref-binaries-9534c8db200f0c1e3532e80e8a4621d1" data-footnote-backref="" aria-label="Back to reference 2">â†©</a></p>
</li>
</ol>
</section>
</article>
          </div></div>
  </body>
</html>
