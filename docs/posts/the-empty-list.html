<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.tfeb.org/fragments/2022/12/16/the-empty-list/">Original</a>
    <h1>The empty list</h1>
    
    <div id="readability-page-1" class="page"><div>

        <!-- Main column -->
        <div id="content">





          <article>
  <header>
    
    <p>
<time datetime="2022-12-16" pubdate="true">2022-12-16</time> :: <span><a href="https://www.tfeb.org/fragments/tags/lisp.html">lisp</a></span></p>
  </header>

<p>My friend Zyni pointed out that someone has been getting really impressively confused and cross on reddit about empty lists, booleans and so on in Common Lisp, which led us to a discussion about what the differences between CL and Scheme really are here. Here’s a summary which we think is correct.</p>
<!-- more-->

<h2 id="a-peculiar-object-in-common-lisp">A peculiar object in Common Lisp</h2>

<p>In Common Lisp there is a single special object, <code>nil</code>.</p>

<ul>
 <li>This represents both the empty list, and the special false value, all other objects being true.</li>
 <li>This object is a list and is the only list object which is not a cons.</li>
 <li>As such this object is an atom, and again it is the only list object which is an atom.</li>
 <li>You can take the <code>car</code> and <code>cdr</code> of this object: both of these operations return the object itself.</li>
 <li>This object is also a symbol, and it is the only object which is both a list and a symbol.</li>
 <li>The empty list when written as an empty list, <code>()</code>, is self-evaluating.</li></ul>

<p>Some comments.</p>

<ul>
 <li>It is <em>necessary</em> that there be a special empty-list object which is a list but not a cons: the things which are not necessary are that it be a symbol, and that it represent falsity.</li>
 <li>Combining the empty list and the special false object can lead to particularly good implementations perhaps.</li>
 <li>The implementation of this object is always going to be a bit weird.</li>
 <li>It is clear that the empty list cannot be any kind of compound form so requiring it to be quoted — requiring you to write <code>&#39;()</code> really — serves no useful purpose. Nevertheless I (Tim) would probably rather CL did that.</li>
 <li>Not having to quote <code>nil</code> on the other hand is not at all strange: any symbol can be made self-evaluating simply by <code>(defconstant s &#39;s)</code>, for instance.</li>
 <li>The graph of types in CL is a DAG, not a tree: it is not at all strange that there is an object whose type is both <code>list</code> and <code>symbol</code>.</li></ul>

<h2 id="some-entirely-mundane-things-in-common-lisp">Some entirely mundane things in Common Lisp</h2>

<ul>
 <li>There is a symbol, <code>t</code> which represents the canonical true value. Nothing is magic about this symbol in any way: it could be defined by <code>(defconstant t &#39;t)</code>.</li>
 <li>There is a type, <code>boolean</code> which could be defined by <code>(deftype boolean () &#39;(member nil t))</code>, except that it is required that <code>boolean</code> be a recognisable subtype of <code>symbol</code>. All implementations we have tried recognise <code>(member nil t)</code> as a subtype of <code>symbol</code>, but the standard does not require them to do so. Additionally <code>(type-of &#39;t)</code> must return <code>boolean</code> we think.</li>
 <li>There is a type, <code>null</code> which could be defined by <code>(deftype null () &#39;(member nil))</code> or <code>(deftype null () &#39;(eql nil))</code>, with the same caveats as above, and <code>(type-of nil)</code> should return <code>null</code>.</li>
 <li>There are types named <code>t</code> (top of the type graph) and <code>nil</code> (bottom of type graph).</li></ul>

<p>These mundane things are just that: they don’t require implementational magic at all.</p>

<h2 id="three-peculiar-objects-in-scheme">Three peculiar objects in Scheme</h2>

<p>In Scheme there is an object, <code>()</code>.</p>

<ul>
 <li><code>()</code> is the special object that represents the empty list.</li>
 <li>It does not represent false.</li>
 <li>It is not a symbol.</li>
 <li>It is the only list object which is not a pair (cons): <code>list?</code> is true of it but <code>pair?</code> is false.</li>
 <li>You can’t take the <code>car</code> or <code>cdr</code> of it.</li>
 <li>It is not self-evaluatiing.</li></ul>

<p>There is another object, <code>#f</code>.</p>

<ul>
 <li><code>#f</code> is the distinguished false value and is the only false value in Scheme, all other objects being true.</li>
 <li>It is not a symbol or a list but satisfies the <code>boolean?</code> predicate.</li>
 <li>It is self-evaluating.</li></ul>

<p>There is another object, <code>#t</code>.</p>

<ul>
 <li><code>#t</code> represents the canonical true value, but all objects other than <code>#f</code> are true.</li>
 <li>It is not a symbol or a list but satisfies the <code>boolean?</code> predicate.</li>
 <li>It is self-evaluating.</li></ul>

<p>Some comments. - Scheme does not have such an elaborate type system as CL and, apart from numbers, doesn’t really have subtype relations the way CL does.</p>

<h2 id="a-summary">A summary</h2>

<p>CL’s treatment of <code>nil</code> clearly makes some people very unhappy indeed. In particular they seem to think CL is somehow inconsistent, which it clearly is not. Generally this is either because they don’t understand how it works, because it doesn’t work the way they want it to work, or (usually) both. Scheme’s treatment is often cited by these people as being better. But CL requires <em>precisely one</em> implementationally-weird object, while Scheme requires two, or three if you count <code>#t</code> which you probably should. Both languages have idiosyncratic evaluation rules around these objects. Additionally it’s worth understanding that things like CL’s <code>boolean</code> type mean essentially nothing implementationally: <code>boolean</code> is just a name for a set of symbols. The only thing preventing you from defining a type like this yourself is the requirement for <code>type-of</code> to return the type.</p>

<p>Is one better than the other? No: they’re just not the same. Certainly the CL approach carries more historical baggage. Equally certainly it is perfectly consistent, and changing it would break essentially all CL programs that exist.</p>

<hr/>

<p>Thanks to Zyni for most of this: I’m really writing it up just so we can remember it. We’re pretty confident about the CL part, less so about the Scheme bit.</p>
  
</article>
        </div>
      </div></div>
  </body>
</html>
