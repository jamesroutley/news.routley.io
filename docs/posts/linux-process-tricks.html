<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://iafisher.com/blog/2024/08/linux-process-tricks">Original</a>
    <h1>Linux process tricks</h1>
    
    <div id="readability-page-1" class="page"><div class="page">
  <header>
  <a href="http://iafisher.com/">home</a>
  <a href="http://iafisher.com/blog">blog</a>
  <a href="http://iafisher.com/portfolio">portfolio</a>
  <a href="https://outsiderart.substack.com/" target="_blank">outsider art</a>
  <a href="https://github.com/iafisher" target="_blank">github</a>
</header>


  
  

  <p><em>Thank you to <a href="https://www.cipht.net/">Julian Squires</a> for his assistance with this project.</em></p>
<p>Last week I gave a demo at <a href="https://recurse.com">Recurse Center</a> of the cool and strange things you can do by abusing the <code>ptrace</code> system call on Linux. I promised at the time that I&#39;d write a blog post explaining how I did it. So here it is. It was a little more magical to demo this live, but hopefully the screen recordings I&#39;ve included below give you some idea.</p>
<h2>Warm-up: Pausing and resuming a process</h2>
<video controls="">
  <source src="https://iafisher.com/static/blog/uploads/process_magic/demo-pause-resume.avif"/>
</video>

<p>Here and throughout, <code>p</code> is the program I wrote that implements these tricks; <code>countforever</code> is a <a href="https://github.com/iafisher/process-magic/blob/master/examples/countforever.c">simple C program</a> that I use as an example.</p>
<h2>Rewinding a process</h2>
<video controls="">
  <source src="https://iafisher.com/static/blog/uploads/process_magic/demo-rewind.avif"/>
</video>

<h2>Taking over a running process</h2>
<video controls="">
  <source src="https://iafisher.com/static/blog/uploads/process_magic/demo-takeover.avif"/>
</video>

<p>Notice how inside the Python interpreter, <code>os.getpid()</code> reports the same PID as the original program.</p>
<h2>Freezing and thawing a running process</h2>
<video controls="">
  <source src="https://iafisher.com/static/blog/uploads/process_magic/demo-freeze-thaw.avif"/>
</video>

<h2>Manipulating program output</h2>
<p><a href="https://en.wikipedia.org/wiki/ROT13">ROT13</a>-encrypting a Python interpreter session:</p>
<video controls="">
  <source src="https://iafisher.com/static/blog/uploads/process_magic/demo-rot13.avif"/>
</video>

<p>What I typed is <code>print(&#34;Hello, world!&#34;)</code>. The Python interpreter sees the original input, but the output is ROT13-encrypted before being printed to the screen.</p>
<p>Highlighting error output in red:</p>
<video controls="">
  <source src="https://iafisher.com/static/blog/uploads/process_magic/demo-colorize.avif"/>
</video>

<h2>How it works</h2>
<p>These tricks use two Linux system interfaces: the <a href="https://man7.org/linux/man-pages/man2/ptrace.2.html"><code>ptrace</code></a> system call, which lets one process trace and control another, and <a href="https://en.wikipedia.org/wiki/Procfs"><code>procfs</code></a>, a filesystem interface for inspecting the status of running processes. <code>ptrace</code> is what is used by debuggers like GDB, and <code>procfs</code> is how the <code>ps</code> command reads information about the processes on your system.</p>
<h3>Syscall injection</h3>
<p>Many of the tricks rely on making syscalls from the traced process. Taking over a running process requires making an <code>execve</code> syscall, for instance. <code>ptrace</code> can&#39;t do this directly, so you have to do it manually:</p>
<ol>
<li>Get the current registers with <code>PTRACE_GETREGSET</code>.</li>
<li>Set the appropriate register to the syscall number (<a href="https://gpages.juszkiewicz.com.pl/syscalls-table/syscalls.html">this table</a> helps), and place the arguments in registers. If the argument is a pointer (e.g., to a string constant), you&#39;ll need to inject the data somewhere in the process&#39;s memory. The registers to use are architecture-specific; on ARM64, the syscall number goes in <code>x8</code>, and the arguments go in registers <code>x0</code>, <code>x1</code>, and so on.</li>
<li>Set the program counter to a syscall instruction, either by finding one already in the binary, or by injecting your own.</li>
<li>Single-step the program with <code>PTRACE_SINGLESTEP</code> to execute the syscall.</li>
<li>Get the current registers again, and read the syscall result from the return register (<code>x0</code> on ARM64).</li>
<li>Restore the original registers from step 1.</li>
</ol>
<p><a href="https://github.com/iafisher/process-magic/blob/ae72fcaa8d7a3c5a149afd69a1f5eb28706ca729/src/proctool/pcontroller.rs#L122">Here&#39;s</a> the code. Steps 1 and 6 are omitted from that function, but can be found <a href="https://github.com/iafisher/process-magic/blob/ae72fcaa8d7a3c5a149afd69a1f5eb28706ca729/src/proctool/bin/daemon.rs#L147-L172">elsewhere</a>.</p>
<h3>Pause and resume a process</h3>
<p>Pausing and resuming is as simple as calling <code>PTRACE_ATTACH</code> and <code>PTRACE_DETACH</code>. The one wrinkle is that the traced process will be automatically detached and restarted if the tracing process exits. So <code>p pause</code> and <code>p resume</code> call out to a long-running daemon process that keeps the <code>ptrace</code> connection alive.</p>
<h3>Take over a running process</h3>
<p>I think this is the trick that people were most impressed by, but in fact it&#39;s quite simple. You just need to inject an <a href="https://man7.org/linux/man-pages/man2/execve.2.html"><code>execve</code></a> syscall and pass the path to the new program as the first argument, using the procedure I described above.</p>
<p>Since <code>execve</code> takes a string argument, you have to inject that string constant into the process&#39;s memory, either by overwriting some existing part of memory, or else allocating your own memory with <code>mmap</code>. I chose <a href="https://github.com/iafisher/process-magic/blob/ae72fcaa8d7a3c5a149afd69a1f5eb28706ca729/src/proctool/pcontroller.rs#L491">the latter approach</a>.</p>
<h3>Rewind a process</h3>
<p>Rewinding a process is the same trick as taking it over, except that the process is taken over <em>by itself</em>. This is done by reading the program&#39;s original command line from <code>/proc/&lt;pid&gt;/cmdline</code> and then passing that as the argument to <code>execve</code>.</p>
<h3>Freeze a running process and thaw it later</h3>
<p>This was the most complicated and open-ended trick. The real way to do it is with <a href="https://github.com/checkpoint-restore/criu">CRIU</a>, a mature project that handles many more cases. For my simple version, I just read the process&#39;s registers with <code>ptrace</code>, and its memory via ProcFS: <code>/proc/&lt;pid&gt;/maps</code> has the list of memory regions, and <code>/proc/&lt;pid&gt;/mem</code> has the actual memory.</p>
<p>The <code>thaw</code> command forks a child process and uses <code>ptrace</code> commands to set the registers, set up the memory maps via syscall injection of <code>mmap</code>, and <a href="https://man7.org/linux/man-pages/man2/process_vm_readv.2.html"><code>process_vm_writev</code></a> to write memory.</p>
<p>My implementation doesn&#39;t work with programs that allocate heap memory, I think because it doesn&#39;t save and restore the <code>brk</code> pointer properly. It also doesn&#39;t try to restore file descriptors.</p>
<h3>Manipulate program output</h3>
<p>The ROT13 and colorizing standard error tricks used the same technique: intercept <code>write</code> syscalls using <code>PTRACE_SYSCALL</code> and tamper with the syscall arguments. For ROT13, this was easy because the transformation doesn&#39;t change the length of the string. Colorizing the output requires inserting <a href="https://en.wikipedia.org/wiki/ANSI_escape_code">ANSI escape codes</a>, which makes the string longer, so I had to call <code>mmap</code> to allocate new memory and copy the string over.</p>
<h3>Not done: Teleport a process to another terminal</h3>
<p>Another trick I wanted to demonstrate was &#34;teleporting&#34; a process to an arbitrary terminal. I spent a lot of time on this, mainly following <a href="https://blog.nelhage.com/2011/02/changing-ctty/">this blog post</a> about <a href="https://github.com/nelhage/reptyr"><code>reptyr</code></a>, but ultimately couldn&#39;t get it working. <code>reptyr</code> &#34;pulls&#34; a process from its original terminal to the one that <code>reptyr</code> is running; what I wanted to do was teleport a process to an arbitrary terminal. I followed the arcane sequence of steps from the blog post to get a process to switch to another controlling terminal, and that worked, but the existing shell process in that terminal didn&#39;t cooperate with its new neighbor. In particular, they seemed to fight over input, with some input characters being read by the shell and some being read by the process.</p>
<p>One trick that is simple and doable is redirecting a process&#39;s output to another terminal. You can do this by closing the <code>stdout</code> file descriptor and reopening it to point to the desired <code>/dev/pts</code> device. But the process will still read input from its original terminal, and the new terminal will still be running the shell as its foreground process.</p>
<h3>Not done: Swap the memory of two processes</h3>
<p>I wanted to demo swapping the memory of two running Python interpreters, so that symbols defined in one interpreter would be available in the other and vice versa. If I had done freezing and thawing correctly, this would have been a simple corollary: use the <code>freeze</code> procedure to grab the memory contents of one process, and use <code>thaw</code> to inject it into the other process. ∎</p>

  

  <hr/>
  <p><strong>Disclaimer:</strong> I occasionally make corrections and changes to posts after I publish them. You can view
    the full history of this post <a href="https://github.com/iafisher/blog/commits/master/2024-08-linux-process-tricks.md">on
    GitHub</a>.
  </p>
</div></div>
  </body>
</html>
