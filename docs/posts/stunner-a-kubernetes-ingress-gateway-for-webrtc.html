<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/l7mp/stunner">Original</a>
    <h1>STUNner: A Kubernetes ingress gateway for WebRTC</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto">Ever wondered how to <a href="https://webrtchacks.com/webrtc-media-servers-in-the-cloud" rel="nofollow">deploy your WebRTC infrastructure into the
cloud</a>? Frightened away by the
complexities of Kubernetes container networking, and the surprising ways in which it may interact
with your UDP/RTP media? Tried to read through the endless stream of <a href="https://stackoverflow.com/search?q=kubernetes+webrtc" rel="nofollow">Stack
Overflow</a>
<a href="https://stackoverflow.com/questions/61140228/kubernetes-loadbalancer-open-a-wide-range-thousands-of-port" rel="nofollow">questions</a>
<a href="https://stackoverflow.com/questions/64232853/how-to-use-webrtc-with-rtcpeerconnection-on-kubernetes" rel="nofollow">asking</a>
<a href="https://stackoverflow.com/questions/68339856/webrtc-on-kubernetes-cluster/68352515#68352515" rel="nofollow">how</a>
<a href="https://stackoverflow.com/questions/52929955/akskubernetes-service-with-udp-and-tcp" rel="nofollow">to</a>
<a href="https://stackoverflow.com/questions/62088089/scaling-down-video-conference-software-in-kubernetes" rel="nofollow">scale</a>
WebRTC services with Kubernetes, just to get (mostly) insufficient answers?  Want to safely connect
your users behind a NAT, without relying on expensive <a href="https://bloggeek.me/managed-webrtc-turn-speed" rel="nofollow">third-party TURN
services</a>?</p>
<p dir="auto">Worry no more! STUNner allows you to deploy <em>any</em> WebRTC service into Kubernetes, smoothly
integrating it into the <a href="https://landscape.cncf.io" rel="nofollow">cloud-native ecosystem</a>.  STUNner exposes a
standards-compliant STUN/TURN gateway for clients to access your virtualized WebRTC infrastructure
running in Kubernetes, maintaining full browser compatibility and requiring minimal or no
modification to your existing WebRTC codebase.</p>
<h2 dir="auto"><a id="user-content-table-of-contents" aria-hidden="true" href="#table-of-contents"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Table of Contents</h2>
<ol dir="auto">
<li><a href="#description">Description</a></li>
<li><a href="#features">Features</a></li>
<li><a href="#getting-started">Getting started</a></li>
<li><a href="#examples">Examples</a></li>
<li><a href="#documentation">Documentation</a></li>
<li><a href="#caveats">Caveats</a></li>
<li><a href="#milestones">Milestones</a></li>
</ol>
<h2 dir="auto"><a id="user-content-description" aria-hidden="true" href="#description"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Description</h2>
<p dir="auto">Currently <a href="https://stackoverflow.com/search?q=kubernetes+webrtc" rel="nofollow">WebRTC</a>
<a href="https://stackoverflow.com/questions/61140228/kubernetes-loadbalancer-open-a-wide-range-thousands-of-port" rel="nofollow">lacks</a>
<a href="https://stackoverflow.com/questions/64232853/how-to-use-webrtc-with-rtcpeerconnection-on-kubernetes" rel="nofollow">a</a>
<a href="https://stackoverflow.com/questions/68339856/webrtc-on-kubernetes-cluster/68352515#68352515" rel="nofollow">vitualization</a>
<a href="https://stackoverflow.com/questions/52929955/akskubernetes-service-with-udp-and-tcp" rel="nofollow">story</a>: there
is no easy way to deploy a WebRTC backend service into Kubernetes to benefit from the
<a href="https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/restartIce" rel="nofollow">resiliency</a>,
<a href="https://stackoverflow.com/questions/62088089/scaling-down-video-conference-software-in-kubernetes" rel="nofollow">scalability</a>,
and <a href="https://blog.cloudflare.com/announcing-our-real-time-communications-platform" rel="nofollow">high
availability</a>
features we have come to expect from modern network services. Worse yet, the entire industry relies
on a handful of <a href="https://bloggeek.me/google-free-turn-server/" rel="nofollow">public</a> <a href="https://www.npmjs.com/package/freeice" rel="nofollow">STUN
servers</a> and <a href="https://bloggeek.me/managed-webrtc-turn-speed" rel="nofollow">hosted TURN
services</a> to connect clients behind a NAT/firewall,
which may create a useless dependency on externally operated services, introduce a bottleneck,
raise security concerns, and come with a non-trivial price tag.</p>
<p dir="auto">The main goal of STUNner is to allow <em>anyone</em> to deploy their own WebRTC infrastructure into
Kubernetes, without relying on any external service other than the cloud-provider&#39;s standard hosted
Kubernetes offering. This is achieved by STUNner acting as a gateway for ingesting WebRTC media
traffic into the Kubernetes cluster, exposing a public-facing STUN/TURN server that WebRTC clients
can connect to.</p>
<p dir="auto">In the <em>standalone deployment model</em> STUNner acts as a simple scalable STUN/TURN server that WebRTC
clients can use as a NAT traversal facility for establishing a media connection. This is not that
much different from a standard public STUN/TURN server setup, but in this case the STUN/TURN
servers are deployed into Kubernetes, which makes lifecycle management, scaling and cost
optimization infinitely simpler.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/l7mp/stunner/blob/main/doc/stunner_standalone_arch.svg"><img src="https://github.com/l7mp/stunner/raw/main/doc/stunner_standalone_arch.svg" alt="STUNner standalone deployment architecture"/></a></p>
<p dir="auto">In the fully fledged <em>media-plane deployment model</em> STUNner implements a STUN/TURN ingress gateway
service that WebRTC clients can use to open a transport relay connection to the media servers
running <em>inside</em> the Kubernetes cluster. This makes it possible to deploy WebRTC application
servers and media servers into ordinary Kubernetes pods, taking advantage of Kubernetes&#39;s excellent
tooling to manage, scale, monitor and troubleshoot the WebRTC infrastructure like any other
cloud-bound workload.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/l7mp/stunner/blob/main/doc/stunner_arch.svg"><img src="https://github.com/l7mp/stunner/raw/main/doc/stunner_arch.svg" alt="STUNner media-plane deployment architecture"/></a></p>
<p dir="auto">Don&#39;t worry about the performance implications of processing all your media through a TURN server:
STUNner is written in <a href="https://go.dev" rel="nofollow">Go</a> so it is extremely fast, it is co-located with your
media server pool so you don&#39;t pay the round-trip time to a far-away public STUN/TURN server, and
STUNner can be easily scaled up if needed, just like any other &#34;normal&#34; Kubernetes service.</p>
<h2 dir="auto"><a id="user-content-features" aria-hidden="true" href="#features"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Features</h2>
<p dir="auto">Kubernetes has been designed and optimized for the typical HTTP/TCP Web workload, which makes
streaming workloads, and especially UDP/RTP based WebRTC media, feel like a foreign citizen.
STUNner aims to change this state-of-the-art, by exposing a single public STUN/TURN server port for
ingesting <em>all</em> media traffic into a Kubernetes cluster in a controlled and standards-compliant
way.</p>
<ul dir="auto">
<li>
<p dir="auto"><strong>Seamless integration with Kubernetes.</strong> STUNner can be deployed into any Kubernetes cluster,
even into restricted ones like GKE Autopilot, using a single command. Manage your HTTP/HTTPS
application servers with your favorite <a href="https://istio.io" rel="nofollow">service mesh</a>, and STUNner takes care
of all UDP/RTP media.</p>
</li>
<li>
<p dir="auto"><strong>Expose a WebRTC media server on a single external UDP port.</strong> Get rid of the Kubernetes
<a href="https://kubernetes.io/docs/concepts/configuration/overview" rel="nofollow">hacks</a>, like privileged pods and
<code>hostNetwork</code>/<code>hostPort</code> services, typically recommended as a prerequisite to containerizing your
WebRTC media plane.  Using STUNner a WebRTC deployment needs only two public-facing ports, one
HTTPS port for the application server and a <em>single</em> UDP port for <em>all</em> your media.</p>
</li>
<li>
<p dir="auto"><strong>No reliance on external services for NAT traversal.</strong> Can&#39;t afford a decent <a href="https://bloggeek.me/webrtc-turn" rel="nofollow">hosted TURN
service</a> for client-side NAT traversal? Can&#39;t get good
audio/video quality because the TURN service poses a bottleneck? STUNner can be deployed into the
same cluster as the rest of your WebRTC infrastructure, and any WebRTC client can connect to it
directly, without the use of <em>any</em> external STUN/TURN service apart from STUNner itself.</p>
</li>
<li>
<p dir="auto"><strong>Easily scale your WebRTC infrastructure.</strong> Tired of manually provisioning your WebRTC media
servers?  STUNner lets you deploy the entire WebRTC infrastructure into ordinary Kubernetes pods,
thus scaling the media plane is as easy as issuing a <code>kubectl scale</code> command. STUNner itself can
be scaled with similar ease, completely separately from the media servers.</p>
</li>
<li>
<p dir="auto"><strong>Secure perimeter defense.</strong> No need to open thousands of UDP/TCP ports on your media server for
potentially malicious access; with STUNner <em>all</em> media is received through a single ingress port
that you can tightly monitor and control. STUNner stores all STUN/TURN credentials and DTLS keys
in secure Kubernetes vaults, and uses standard Kubernetes Access Control Lists (ACLs) to lock
down network access between your application servers and the media plane.</p>
</li>
<li>
<p dir="auto"><strong>Simple code and extremely small size.</strong> Written in pure Go using the battle-tested
<a href="https://github.com/pion/webrtc">pion/webrtc</a> framework, STUNner is just a couple of hundred
lines of fully open-source code. The server is extremely lightweight: the typical STUNner
container image size is only about 5 Mbytes.</p>
</li>
</ul>
<h2 dir="auto"><a id="user-content-getting-started" aria-hidden="true" href="#getting-started"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Getting Started</h2>
<p dir="auto">STUNner comes with prefab deployment manifests to fire up a fully functional STUNner-based WebRTC
media gateway in minutes. Note that the default deployment does not contain an application server
and a media server: STUNner in itself is not a WebRTC backend, it is just an <em>enabler</em> for you to
deploy your <em>own</em> WebRTC infrastructure into Kubernetes. Once installed, STUNner makes sure that
your media servers are readily reachable to WebRTC clients, despite running with a private IP
address inside a Kubernetes pod.</p>
<p dir="auto">With a minimal understanding of WebRTC and Kubernetes, deploying STUNner should take less than 5
minutes.</p>
<ul dir="auto">
<li><a href="#installation">Customize STUNner and deploy it</a> into your Kubernetes cluster and expose it over
a public IP address and port.</li>
<li>Optionally <a href="https://github.com/l7mp/stunner/blob/main/examples/kurento-one2one-call">deploy a WebRTC media server</a> into Kubernetes as well.</li>
<li><a href="#configuring-webrtc-clients-to-reach-stunner">Set STUNner as the ICE server</a> in your WebRTC
clients.</li>
<li>...</li>
<li>Profit!!</li>
</ul>
<h3 dir="auto"><a id="user-content-installation" aria-hidden="true" href="#installation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Installation</h3>
<p dir="auto">The simplest way to deploy STUNner is through <a href="https://helm.sh" rel="nofollow">Helm</a>. In this case, all STUNner
configuration parameters are available for customization as <a href="https://helm.sh/docs/chart_template_guide/values_files" rel="nofollow">Helm
Values</a>.</p>
<div data-snippet-clipboard-copy-content="$ helm repo add stunner https://l7mp.io/stunner
$ helm repo update
$ helm install stunner stunner/stunner"><pre>$ <span>helm repo add stunner https://l7mp.io/stunner</span>
$ <span>helm repo update</span>
$ <span>helm install stunner stunner/stunner</span></pre></div>
<p dir="auto">And that&#39;s all: a standalone deployment of STUNner is up and running, waiting for WebRTC clients to
connect to it. See the <a href="https://github.com/l7mp/stunner/blob/main/doc/INSTALL.md">STUNner installation guide</a> on how to customize STUNner or
deploy it without Helm, using a static <a href="https://github.com/l7mp/stunner/blob/main/deploy/manifests/stunner.yaml">Kubernetes manifest</a>.</p>
<h3 dir="auto"><a id="user-content-configuration" aria-hidden="true" href="#configuration"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Configuration</h3>
<p dir="auto">Wait until Kubernetes assigns a public IP address for STUNner; this should not take more than a minute.</p>
<div data-snippet-clipboard-copy-content="$ until [ -n &#34;$(kubectl get svc stunner -o jsonpath=&#39;{.status.loadBalancer.ingress[0].ip}&#39;)&#34; ]; do sleep 1; done"><pre>$ <span><span>until</span> [ <span>-n</span> <span><span>&#34;</span><span><span>$(</span>kubectl get svc stunner -o jsonpath=<span><span>&#39;</span>{.status.loadBalancer.ingress[0].ip}<span>&#39;</span></span><span>)</span></span><span>&#34;</span></span> ]<span>;</span> <span>do</span> sleep 1<span>;</span> <span>done</span></span></pre></div>
<p dir="auto">Query the actual STUNner configuration in order to learn the public IP address and port assigned by
Kubernetes for the STUNner service.</p>
<div data-snippet-clipboard-copy-content="$ kubectl get cm stunner-config -o yaml"><pre>$ <span>kubectl get cm stunner-config -o yaml</span></pre></div>
<p dir="auto">The result should be something like the below. The public IP address allocated by Kubernetes for
STUNner is marked with a placeholder <code>A.B.C.D</code> below.</p>
<div data-snippet-clipboard-copy-content="apiVersion: v1
kind: ConfigMap
metadata:
  name: stunner-config
  namespace: default
data:
  STUNNER_AUTH_TYPE: plaintext
  STUNNER_PUBLIC_ADDR: A.B.C.D
  STUNNER_PUBLIC_PORT: 3478
  STUNNER_USERNAME: user1
  STUNNER_PASSWORD: passwd1
  ..."><pre><span>apiVersion</span>: <span>v1</span>
<span>kind</span>: <span>ConfigMap</span>
<span>metadata</span>:
  <span>name</span>: <span>stunner-config</span>
  <span>namespace</span>: <span>default</span>
<span>data</span>:
  <span>STUNNER_AUTH_TYPE</span>: <span>plaintext</span>
  <span>STUNNER_PUBLIC_ADDR</span>: <span>A.B.C.D</span>
  <span>STUNNER_PUBLIC_PORT</span>: <span>3478</span>
  <span>STUNNER_USERNAME</span>: <span>user1</span>
  <span>STUNNER_PASSWORD</span>: <span>passwd1</span>
  <span>...</span></pre></div>
<p dir="auto">Note that any change to the STUNner <code>ConfigMap</code> will take effect only once STUNner is restarted.</p>
<div data-snippet-clipboard-copy-content="$ kubectl rollout restart deployment stunner"><pre>$ <span>kubectl rollout restart deployment stunner</span></pre></div>
<h2 dir="auto"><a id="user-content-configuring-webrtc-clients-to-reach-stunner" aria-hidden="true" href="#configuring-webrtc-clients-to-reach-stunner"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Configuring WebRTC clients to reach STUNner</h2>
<p dir="auto">The last step is to configure your WebRTC clients to use STUNner as the TURN server. STUNner is
compatible with all client-side <a href="https://datatracker.ietf.org/doc/html/rfc8155" rel="nofollow">TURN auto-discovery
mechanisms</a>. When no auto-discovery mechanism is
available, clients will need to be manually configured to stream audio/video media over STUNner.</p>
<p dir="auto">The below JavaScript snippet will direct a WebRTC client to use STUNner; make sure to substitute
the placeholders (like <code>&lt;STUNNER_PUBLIC_ADDR&gt;</code>) with the correct configuration from the above.</p>
<div data-snippet-clipboard-copy-content="var ICE_config = {
  &#39;iceServers&#39;: [
    {
      &#39;url&#39;: &#34;turn:&lt;STUNNER_PUBLIC_ADDR&gt;:&lt;STUNNER_PUBLIC_PORT&gt;?transport=udp&#39;,
      &#39;username&#39;: &lt;STUNNER_USERNAME&gt;,
      &#39;credential&#39;: &lt;STUNNER_PASSWORD&gt;,
    },
  ],
};
var pc = new RTCPeerConnection(ICE_config);"><pre><span>var</span> <span>ICE_config</span> <span>=</span> <span>{</span>
  <span>&#39;iceServers&#39;</span>: <span>[</span>
    <span>{</span>
      <span>&#39;url&#39;</span>: &#34;turn:&lt;STUNNER_PUBLIC_ADDR&gt;:&lt;STUNNER_PUBLIC_PORT&gt;?transport=udp&#39;,
      &#39;username&#39;: &lt;STUNNER_USERNAME&gt;,
      &#39;credential&#39;: &lt;STUNNER_PASSWORD&gt;,
    },
  ],
};
var pc = new RTCPeerConnection(ICE_config);</pre></div>
<p dir="auto">Note that STUNner comes with a <a href="https://www.npmjs.com/package/@l7mp/stunner-auth-lib" rel="nofollow">small Node.js
library</a> that simplifies generating ICE
configurations and STUNner credentials in the application server.</p>
<h2 dir="auto"><a id="user-content-examples" aria-hidden="true" href="#examples"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Examples</h2>
<p dir="auto">STUNner comes with several demos to show how to use it to deploy a WebRTC application into
Kubernetes.</p>
<ul dir="auto">
<li><a href="https://github.com/l7mp/stunner/blob/main/examples/simple-tunnel">Opening a UDP tunnel via STUNner</a>: This introductory demo shows how to
tunnel an external connection via STUNner to a UDP service deployed into Kubernetes. The demo can
be used to quickly check a STUNner installation.</li>
<li><a href="https://github.com/l7mp/stunner/blob/main/examples/direct-one2one-call">Standalone mode: Direct one to one video call via STUNner</a>: This
introductory tutorial showcases the <em>standalone deployment model</em> of STUNner, that is, when
WebRTC clients connect to each other directly via STUNner, without a media server. The tutorial
has been adopted from the <a href="https://www.kurento.org/" rel="nofollow">Kurento</a> <a href="https://doc-kurento.readthedocs.io/en/latest/tutorials/node/tutorial-one2one.html" rel="nofollow">one-to-one video call
tutorial</a>, but
this time the clients connect to each other via STUNner, without the assistance of a media
server.  The demo contains a <a href="https://nodejs.org" rel="nofollow">Node.js</a> application server for creating a
browser-based two-party WebRTC video-call, plus a STUNner service that clients use as a TURN
server to connect to each other.  Note that no transcoding/transsizing option is available in
this demo, since there is no media server in the media pipeline.</li>
<li><a href="https://github.com/l7mp/stunner/blob/main/examples/kurento-one2one-call">Media-plane mode: One to one video call with Kurento via
STUNner</a>: This tutorial extends the previous demo to showcase the
fully fledged <em>media-plane deployment model</em> of STUNner, that is, when WebRTC clients connect to
each other via a media server deployed into Kubernetes, this time provided by
<a href="https://www.kurento.org" rel="nofollow">Kurento</a>. The media servers in turn are exposed to the clients via a
STUNner gateway.  The demo has been adopted from the <a href="https://www.kurento.org" rel="nofollow">Kurento</a>
<a href="https://doc-kurento.readthedocs.io/en/latest/tutorials/node/tutorial-one2one.html" rel="nofollow">one-to-one video call
tutorial</a>,
with minimal
<a href="https://github.com/l7mp/kurento-tutorial-node/tree/master/kurento-one2one-call">modifications</a>
to deploy it into Kubernetes and integrate it with STUNner. The demo contains a
<a href="https://nodejs.org" rel="nofollow">Node.js</a> application server for creating a browser-based two-party WebRTC
video-call, plus the Kurento media server deployed behind STUNner for media exchange and,
potentially, automatic audio/video transcoding.</li>
<li><a href="https://github.com/l7mp/stunner/blob/main/examples/kurento-magic-mirror/README.md">Media-plane mode: Magic mirror via STUNner</a>: This
example has been adopted from the <a href="https://www.kurento.org" rel="nofollow">Kurento</a> <a href="https://doc-kurento.readthedocs.io/en/stable/tutorials/node/tutorial-magicmirror.html" rel="nofollow">magic
mirror</a>
demo. The demo shows a basic WebRTC loopback server with some media processing added: the
application uses computer vision and augmented reality techniques to add a funny hat on top of
faces. The computer vision functionality is again provided by the <a href="https://www.kurento.org" rel="nofollow">Kurento media
server</a>, being exposed to the clients via a STUNner gateway.</li>
</ul>
<h2 dir="auto"><a id="user-content-documentation" aria-hidden="true" href="#documentation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Documentation</h2>
<p dir="auto">See further documentation <a href="https://github.com/l7mp/stunner/blob/main/doc/README.md">here</a>.</p>
<h2 dir="auto"><a id="user-content-caveats" aria-hidden="true" href="#caveats"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Caveats</h2>
<p dir="auto">STUNner is a work-in-progress. Some features are missing, others may not work as expected. The
notable limitations at this point are as follows.</p>
<ul dir="auto">
<li><em>STUNner is not intended to be used as a public STUN/TURN server</em>; the intended use is as a
Kubernetes ingress gateway for WebRTC. (For implementing a public TURN service, see
<a href="https://github.com/coturn/coturn">alternatives</a>).  Being deployed into a Kubernetes service,
STUNner will not be able to identify the public IP address of a client sending a STUN binding
request to it (without special
<a href="https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/#preserving-the-client-source-ip" rel="nofollow">hacks</a>),
and the TURN transport relay connection opened by a WebRTC client via STUNner is reachable only
to clients configured to use the same STUNner service (again, without further
<a href="https://kubernetes.io/docs/concepts/security/pod-security-policy/#host-namespaces" rel="nofollow">hacks</a>). This
is intended: STUNner is a Kubernetes ingress gateway which happens to expose a STUN/TURN
compatible service to WebRTC clients, and not a public TURN service.</li>
<li>Access through STUNner to the rest of the cluster <em>must</em> be locked down with a Kubernetes
<code>NetworkPolicy</code>. Otherwise, certain internal Kubernetes services would become available
externally; see the <a href="https://github.com/l7mp/stunner/blob/main/doc/SECURITY.md#access-control">notes on access control</a>.</li>
<li>STUNner supports arbitrary scale-up without dropping active calls, but <em>scale-down might
disconnect calls</em> established through the STUNner pods and/or media server replicas being removed
from the load-balancing pool. Note that this problem is
<a href="https://webrtchacks.com/webrtc-media-servers-in-the-cloud" rel="nofollow">universal</a> in WebRTC, but we plan to
do something about it in a later STUNner release so stay tuned.</li>
<li>The WebRTC DataChannel API is not supported at the moment.</li>
</ul>
<h2 dir="auto"><a id="user-content-milestones" aria-hidden="true" href="#milestones"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Milestones</h2>
<ul dir="auto">
<li>v0.9.2: Day-2 operations: STUNner basic UDP/TURN connectivity + helm chart + simple use cases (Kurento
demos).</li>
<li>v0.10.1: Onboarding: long-term STUN/TURN credentials and <a href="https://www.rfc-editor.org/rfc/rfc6062.txt" rel="nofollow">STUN/TURN over
TCP/TLS/DTLS</a>.</li>
<li>v0.11.1: Day-2 operations: STUNner Kubernetes operator.</li>
<li>v0.12.1: Performance: eBPF STUN/TURN acceleration.</li>
<li>v0.13.1: Observability: Prometheus + Grafana dashboard.</li>
<li>v0.14.1: Ubiquity: make STUNner work with Jitsi, Janus, mediasoup and pion-SFU.</li>
<li>v1.0: GA</li>
<li>v2.0: Service mesh: adaptive scaling &amp; resiliency</li>
</ul>
<h2 dir="auto"><a id="user-content-help" aria-hidden="true" href="#help"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Help</h2>
<p dir="auto">STUNner development is coordinated in Discord, send <a href="https://github.com/l7mp/stunner/blob/main/AUTHORS">us</a> an email to ask an invitation.</p>
<h2 dir="auto"><a id="user-content-license" aria-hidden="true" href="#license"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>License</h2>
<p dir="auto">Copyright 2021-2022 by its authors. Some rights reserved. See <a href="https://github.com/l7mp/stunner/blob/main/AUTHORS">AUTHORS</a>.</p>
<p dir="auto">MIT License - see <a href="https://github.com/l7mp/stunner/blob/main/LICENSE">LICENSE</a> for full text.</p>
<h2 dir="auto"><a id="user-content-acknowledgments" aria-hidden="true" href="#acknowledgments"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Acknowledgments</h2>
<p dir="auto">Initial code adopted from <a href="https://github.com/pion/stun">pion/stun</a> and
<a href="https://github.com/pion/turn">pion/turn</a>.</p>
</article>
          </div></div>
  </body>
</html>
