<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://increase.com/articles/no-abstractions">Original</a>
    <h1>No Abstractions: our API design principle</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><p><span>API resources</span> are the nouns of your API. Deciding how to name and model these nouns is arguably the hardest and most important part of designing an API. The resources you expose organize your users’ mental model of how your product works and what it can do. At Increase, our team has used a principle called “no abstractions” to help. What do we mean by this?</p><!-- --> <!-- -->  <!-- --><!-- -->  <!-- --></div><div><p>“For Increase users, trying to hide the underlying complexity of these networks would irritate them, not simplify their lives.”</p></div><div><p>Increase’s users are not like this. They often have deep existing knowledge of payment networks, think about financial technology all the time, and come to us because of our direct network connections and the depth of integration that lets them build. They want to know</p><!-- --> <p><a href="https://status.increase.com/#ach-submission-timeline">exactly</a></p><!-- --><p>when the FedACH window closes and when transfers will land. They understand that setting a different Standard Entry Class code on an ACH transfer can result in different return timing. Trying to hide the underlying complexity of these networks (by, for example, modeling ACH transfers and wire transfers with a single API resource) would irritate them, not simplify their lives.</p></div><p>Real-world naming</p><div><p>Instead of inventing our own names for API resources and their attributes, we tend to use the vocabulary of the underlying networks. For example, the parameters we expose when making an ACH transfer via our API are named after fields in the</p><!-- --> <p><a href="https://achdevguide.nacha.org/ach-file-details">Nacha specification</a>.</p></div><p>Immutability</p><div><p>Similar to how we use network nomenclature, we try to model our resources after real-world events like an action taken or a message sent. This results in more of our API resources being immutable. An approach that’s worked well for our API is to take a cluster of these immutable resources (all of the network messages that can be sent as part of the ACH transfer lifecycle, for example) and group them together under a state machine “lifecycle object”. For example, the <code>ach_transfer</code></p><!-- --><p>object in our API has a field called</p><!-- --> <p><code>status</code> that changes over time, and several immutable sub-objects that are created as the transfer moves through its lifecycle. A newly-minted</p><!-- --> <p><code>ach_transfer</code> object looks like:</p></div><div><div><div><pre><p><span>{</span>
  <span>&#34;id&#34;</span><span>:</span> <span>&#34;ach_transfer_abc123&#34;</span><span>,</span>
  <span>&#34;created_at&#34;</span><span>:</span> <span>&#34;2024-04-24T00:00:00+00:00&#34;</span><span>,</span>
  <span>&#34;amount&#34;</span><span>:</span> <span>1000</span><span>,</span>
  <span>&#34;status&#34;</span><span>:</span> <span>&#34;pending_approval&#34;</span><span>,</span>
  <span>&#34;approval&#34;</span><span>:</span> <span><span>null</span></span><span>,</span>
  <span>&#34;submission&#34;</span><span>:</span> <span><span>null</span></span><span>,</span>
  <span>&#34;acknowledgement&#34;</span><span>:</span> <span><span>null</span></span>
  
<span>}</span></p></pre></div></div></div><p>After that same transfer has moved through our pipeline and we’ve submitted it to FedACH, it looks like:</p><div><div><div><pre><p><span>{</span>
  <span>&#34;id&#34;</span><span>:</span> <span>&#34;ach_transfer_abc123&#34;</span><span>,</span>
  <span>&#34;created_at&#34;</span><span>:</span> <span>&#34;2024-04-24T00:00:00+00:00&#34;</span><span>,</span>
  <span>&#34;amount&#34;</span><span>:</span> <span>1000</span><span>,</span>
  <span>&#34;status&#34;</span><span>:</span> <span>&#34;submitted&#34;</span><span>,</span>
  
  <span>&#34;approval&#34;</span><span>:</span> <span>{</span>
    <span>&#34;approved_by&#34;</span><span>:</span> <span>&#34;administrator@yourcompany.com&#34;</span><span>,</span>
    <span>&#34;approved_at&#34;</span><span>:</span> <span>&#34;2024-04-24T01:00:00+00:00&#34;</span>
  <span>}</span><span>,</span>
  
  <span>&#34;submission&#34;</span><span>:</span> <span>{</span>
    <span>&#34;trace_number&#34;</span><span>:</span> <span>&#34;058349238292834&#34;</span><span>,</span>
    <span>&#34;submitted_at&#34;</span><span>:</span> <span>&#34;2024-04-24T02:00:00+00:00&#34;</span>
  <span>}</span><span>,</span>
  
  <span>&#34;acknowledgement&#34;</span><span>:</span> <span>{</span>
    <span>&#34;acknowledged_at&#34;</span><span>:</span> <span>&#34;2024-04-24T03:00:00+00:00&#34;</span>
  <span>}</span>
  
<span>}</span></p></pre></div></div></div><p>Separating resources by use case</p><div><p>If, for a given API resource, the set of actions a user can take on different instances of the resource varies a lot, we tend to split it into multiple resources. For example, the set of actions you can take on an originated ACH transfer is different (the complete opposite, really) than the actions you can take on a received ACH transfer, so we separate these into</p><!-- --> <p><code>ach_transfer</code> and</p><!-- --> <p><code>inbound_ach_transfer</code> resources.</p></div><div><p>This approach can make our API more verbose and intimidating at first glance — there are a lot of resources on the left-hand side of our</p><!-- --> <p><a href="https://increase.com/documentation/api">documentation</a></p><!-- --><p>page! We think it makes things more predictable over the long-term, though.</p><!-- -->  <!-- --><!-- --> <!-- --> <!-- --> <!-- --> </div></div></div></div>
  </body>
</html>
