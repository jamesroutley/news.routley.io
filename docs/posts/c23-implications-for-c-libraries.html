<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gustedt.gitlabpages.inria.fr/c23-library/">Original</a>
    <h1>C23 Implications for C Libraries</h1>
    
    <div id="readability-page-1" class="page">
  



<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#impacted-headers">Impacted headers</a></li>
<li><a href="#unicode-support">Unicode support</a></li>
<li><a href="#threads">Thread safety of the C library</a></li>
<li><a href="#const-contract-of-the-c-library">Const-contract of the C library</a></li>
<li><a href="#changes-to-integer-types">Changes to integer types</a>
<ul>
<li><a href="#WIDTH">New feature test macros</a></li>
<li><a href="#new-valid-token-sequences-for-integer-constants">New valid token sequences for integer constants</a></li>
<li><a href="#exact-width-integer-types-are-mandatory">Exact-width integer types are mandatory</a></li>
<li><a href="#extended-integer-types-may-be-wider-than-intmax_t">Extended integer types may be wider than <code><span>intmax_t</span></code></a></li>
<li><a href="#BitInt">Bit-precise integer types</a></li>
<li><a href="#string-to-integer-conversion">String to integer conversion</a></li>
<li><a href="#ptrdiff_t"><code><span>ptrdiff_t</span></code></a></li>
<li><a href="#char8_t-added"><code><span>char8_t</span></code> added</a></li>
<li><a href="#stdbit">New mandatory header <code><span>&lt;</span>stdbit<span>.</span>h<span>&gt;</span></code></a></li>
<li><a href="#stdckdint">New mandatory header <code><span>&lt;</span>stdckdint<span>.</span>h<span>&gt;</span></code></a></li>
</ul></li>
<li><a href="#alignment-to-iec-60559-for-standard-floating-point">Alignment to IEC 60559 for standard floating point</a></li>
<li><a href="#optional-iec-60559-support-for-decimal-floating-point">Optional IEC 60559 support for decimal floating point</a></li>
<li><a href="#attributes">Attributes</a>
<ul>
<li><a href="#noreturn-becomes-noreturn"><code><span>_Noreturn</span></code> becomes <code><span>[[</span><span>noreturn</span><span>]]</span></code></a></li>
<li><a href="#deprecating-certain-functions-with-deprecated">Deprecating certain functions with <code><span>[[</span><span>deprecated</span><span>]]</span></code></a></li>
</ul></li>
<li><a href="#predefined-macro-names">Predefined macro names</a>
<ul>
<li><a href="#stdc_utf_16__-and-__stdc_utf_32__-are-mandatory"><code>__STDC_UTF_16__</code> and <code>__STDC_UTF_32__</code> are mandatory</a></li>
</ul></li>
<li><a href="#remove-trigraphs">Remove trigraphs</a></li>
<li><a href="#assert">Changes to <code><span>&lt;</span>assert<span>.</span>h<span>&gt;</span></code></a>
<ul>
<li><a href="#stdc_version_assert_h__"><code>__STDC_VERSION_ASSERT_H__</code></a></li>
<li><a href="#assert-1"><code>assert</code></a></li>
</ul></li>
<li><a href="#float">Changes to <code><span>&lt;</span><span>float</span><span>.</span>h<span>&gt;</span></code></a>
<ul>
<li><a href="#stdc_version_float_h__"><code>__STDC_VERSION_FLOAT_H__</code></a></li>
<li><a href="#missing-macros">Missing macros</a></li>
</ul></li>
<li><a href="#limits">Changes to <code><span>&lt;</span>limits<span>.</span>h<span>&gt;</span></code></a>
<ul>
<li><a href="#stdc_version_limits_h__"><code>__STDC_VERSION_LIMITS_H__</code></a></li>
<li><a href="#missing-macros-1">Missing macros</a></li>
</ul></li>
<li><a href="#stdarg">Changes to <code><span>&lt;</span>stdarg<span>.</span>h<span>&gt;</span></code></a>
<ul>
<li><a href="#stdc_version_stdarg_h__"><code>__STDC_VERSION_STDARG_H__</code></a></li>
<li><a href="#additional-arguments-to-va_start-can-be-omitted.">Additional arguments to <code>va_start</code> can be omitted.</a></li>
<li><a href="#support-for-new-types-standard-or-extended">Support for new types, standard or extended</a></li>
</ul></li>
<li><a href="#stdatomic">Changes to <code><span>&lt;</span>stdatomic<span>.</span>h<span>&gt;</span></code></a>
<ul>
<li><a href="#stdc_version_stdatomic_h__"><code>__STDC_VERSION_STDATOMIC_H__</code></a></li>
<li><a href="#remove-atomic_var_init">Remove <code>ATOMIC_VAR_INIT</code> ?</a></li>
<li><a href="#new-_bitintn-and-decimal-floating-point-types-must-be-supported-by-type-generic-interfaces">New <code><span>_BitInt</span><span>(</span></code><em>N</em><code><span>)</span></code> and decimal floating point types must be supported by type-generic interfaces</a></li>
<li><a href="#new-macro-atomic_char8_t_lock_free-and-type-atomic_char8_t">New macro <code>ATOMIC_CHAR8_T_LOCK_FREE</code> and type <code>atomic_char8_t</code></a></li>
</ul></li>
<li><a href="#stdbool">Changes to <code><span>&lt;</span>stdbool<span>.</span>h<span>&gt;</span></code></a>
<ul>
<li><a href="#stdc_version_bool_h__"><code>__STDC_VERSION_BOOL_H__</code> ?</a></li>
<li><a href="#removeprotect-bool-false-and-true">Remove/protect <code><span>bool</span></code>, <code><span>false</span></code> and <code><span>true</span></code></a></li>
</ul></li>
<li><a href="#stddef">Changes to <code><span>&lt;</span>stddef<span>.</span>h<span>&gt;</span></code></a>
<ul>
<li><a href="#stdc_version_stddef_h__"><code>__STDC_VERSION_STDDEF_H__</code></a></li>
<li><a href="#unreachable-macro"><span><code><span>unreachable</span></code> macro</span></a></li>
<li><a href="#nullptr_t"><code><span>nullptr_t</span></code></a></li>
<li><a href="#null"><code>NULL</code></a></li>
</ul></li>
<li><a href="#stdio">Changes to <code><span>&lt;</span>stdio<span>.</span>h<span>&gt;</span></code></a>
<ul>
<li><a href="#stdc_version_stdio_h__"><code>__STDC_VERSION_STDIO_H__</code></a></li>
<li><a href="#changes-to-formatted-io">Changes to formatted IO</a></li>
</ul></li>
<li><a href="#stdlib">Changes to <code><span>&lt;</span>stdlib<span>.</span>h<span>&gt;</span></code></a>
<ul>
<li><a href="#stdc_version_stdlib_h__"><code>__STDC_VERSION_STDLIB_H__</code></a></li>
<li><a href="#strtol"><code>strtol</code> and friends</a></li>
<li><a href="#alignment-requirements-for-memory-management-functions">Alignment requirements for memory management functions</a></li>
<li><a href="#calloc-overflow"><code>calloc</code> overflow</a></li>
<li><a href="#bsearch"><code>bsearch</code> becomes a <code><span>const</span></code>-preserving tg macro</a></li>
<li><a href="#add-once_flag-and-call_once-also-to-stdlib.h">Add <code><span>once_flag</span></code> and <code>call_once</code> also to <code><span>&lt;</span>stdlib<span>.</span>h<span>&gt;</span></code></a></li>
</ul></li>
<li><a href="#time">Changes to <code><span>&lt;</span>time<span>.</span>h<span>&gt;</span></code></a>
<ul>
<li><a href="#stdc_version_time_h__"><code>__STDC_VERSION_TIME_H__</code></a></li>
<li><a href="#strftime-and-wcsftime"><code>strftime</code> and <code>wcsftime</code></a></li>
<li><a href="#asctime">Deprecation of <code>asctime</code> and <code>ctime</code></a></li>
<li><a href="#gmtime_r-and-localtime_r"><code>gmtime_r</code> and <code>localtime_r</code></a></li>
<li><a href="#timegm"><code>timegm</code></a></li>
<li><a href="#timespec_getres"><code>timespec_getres</code></a></li>
<li><a href="#time_monotonic-time_active-time_thread_active"><code>TIME_MONOTONIC</code>, <code>TIME_ACTIVE</code>, <code>TIME_THREAD_ACTIVE</code></a></li>
</ul></li>
<li><a href="#string">Changes to <code><span>&lt;</span>string<span>.</span>h<span>&gt;</span></code></a>
<ul>
<li><a href="#stdc_version_string_h__"><code>__STDC_VERSION_STRING_H__</code></a></li>
<li><a href="#memccpy-strdup-and-strndup"><code>memccpy</code>, <code>strdup</code> and <code>strndup</code></a></li>
<li><a href="#memset_explicit"><code>memset_explicit</code></a></li>
<li><a href="#memchr"><code>memchr</code>, <code>strchr</code>, <code>strpbrk</code>, <code>strrchr</code> and <code>strstr</code> become <code><span>const</span></code>-preserving tg macros</a></li>
</ul></li>
<li><a href="#uchar">Changes to <code><span>&lt;</span>uchar<span>.</span>h<span>&gt;</span></code></a>
<ul>
<li><a href="#stdc_version_uchar_h__"><code>__STDC_VERSION_UCHAR_H__</code></a></li>
<li><a href="#conversion-functions-and-type-for-utf-8">Conversion functions and type for UTF-8</a></li>
</ul></li>
<li><a href="#wchar">Changes to <code><span>&lt;</span>wchar<span>.</span>h<span>&gt;</span></code></a>
<ul>
<li><a href="#stdc_version_wchar_h__"><code>__STDC_VERSION_WCHAR_H__</code></a></li>
<li><a href="#wcschr-wcspbrk-wcsrchr-wcsstr-and-wmemchr-become-const-preserving-tg-macros"><code>wcschr</code>, <code>wcspbrk</code>, <code>wcsrchr</code>, <code>wcsstr</code> and <code>wmemchr</code> become <code><span>const</span></code>-preserving tg macros</a></li>
</ul></li>
<li><a href="#changes-in-annex-k">Changes in Annex K</a>
<ul>
<li><a href="#bsearch_s"><code>bsearch_s</code></a></li>
</ul></li>
</ul>
</nav>
<h2 id="introduction">Introduction</h2>
<p>The upcomming standard C23 has a lot of additions to the C library clause. Most of them are small, some of them are big but optional.</p>
<p>This document only marginally covers the latter, namely changes to floating point types and their implications for the C library, simply because that is not my domain of expertise.</p>
<p>The last publicly available working draft is <a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n3047.pdf">https://open-std.org/JTC1/SC22/WG14/www/docs/n3047.pdf</a> and section numbers below refer to that document.</p>
<p>Unfortunately, the versions thereafter and in particular the final document fall under the weird ISO laws and can’t be made available. Nevertheless changes to this should be merely editorial; I will try to properly reflect them, here.</p>
<p>The document is currently in ballot to the “National Bodies” (NB) that is the country organizations to collect a set of possible final modifications. These will then be decided upon by WG14 in their plenary session in January 2023.</p>

<p>There are a lot of impacted headers by the changes,</p>

<p>For C23, all these headers have to provide feature test macros of the form <code>__STDC_VERSION_</code><em>NAME</em><code>_H__</code> where <em>NAME</em> is the capitalized form of the header name without <code><span>.</span>h</code> suffix. The value of these macros has to be <code><span>202311</span><span>L</span></code> and should only be set to this once the transition is complete and the header is conforming.</p>
<p>Nevertheless, even before, such a macro can already be used as an include guard, it just has to be set to be empty or to a smaller numerical value, e.g. <code><span>0</span></code>.</p>
<h2 id="unicode-support">Unicode support</h2>
<p>C23 improves Unicode support. <code><span>char8_t</span></code>, <code><span>char16_t</span></code>, <code><span>char32_t</span></code> and strings and characters prefixed with <code>u8</code>, <code>u</code> and <code>U</code> are encoded with the proper UTF encoding. See <a href="#uchar"><code><span>&lt;</span>uchar<span>.</span>h<span>&gt;</span></code></a>, below.</p>
<p>Unfortunately, there are still some escape hatches for hereditary implementations that are controlled by the feature test macros <code>__STDC_ISO_10646__</code> and <code>__STDC_MB_MIGHT_NEQ_WC__</code>.</p>
<p>Unicode Identifier support has been updated to UAX #31 (Unicode Identifier and Pattern Syntax). This means that validity of identifiers rule <strong>as if</strong> the encoding where Unicode.</p>
<ol type="1">
<li><p>The character that starts an identifier must correspond to a Unicode codepoint that has the <sub>XID_Start</sub> property (including the characters of the Latin alphabet) or be the character <code>_</code>.</p></li>
<li><p>The set of continuation characters extents this to all characters that correspond to the <sub>XID_Continue</sub> property (including decimal digits).</p></li>
</ol>
<p>This means in particular that identifiers may not contain characters that have no Unicode equivalent or where the codepoint does not have the required properties. So any identifier <code>ID</code> can be stringified to a multi-byte encoded string <code>mbs</code> and then be transformed by <code>mbrtoc32</code> to a UTF-32 encoded string <code>s32</code> where the characters have the above properties. Transforming with <code>mbrtoc16</code> or <code>mbrtoc8</code> results in a valid UTF-16 or UTF-8 encoded string <code>s16</code> and <code>s8</code>, respectively.</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span><span>#include</span> </span><span>&lt;stdbit.h&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span><span>#include</span> </span><span>&lt;stdlib.h&gt;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span><span>#include</span> </span><span>&lt;uchar.h&gt;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a><span><span>#define</span> STRINGIFY_(X) #X</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a><span><span>#define</span> STRINGIFY(X) STRINGIFY_(X)</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a><span>// For any accepted identifier or pp-number PP this is a valid mb-string</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a><span>char</span> <span>const</span> mbs<span>[]</span> <span>=</span> STRINGIFY<span>(</span>PP<span>);</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a><span>// For any accepted identifier or pp-number PP this will be a valid UTF-32 string</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a><span>// where s32[0] has the XID_Start property or is an underscore character (for identifiers) or</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a><span>// a decimal digit or a period character (for pp-numbers), and all</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true"></a><span>// subsequent characters have the XID_Continue property.</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true"></a><span>char32_t</span>  s32<span>[</span><span>sizeof</span> mbs<span>];</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true"></a><span>char32_t</span><span>*</span> p32 <span>=</span> s32<span>;</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true"></a><span>size_t</span> len <span>=</span> <span>sizeof</span> mbs<span>;</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true"></a><span>mbstate_t</span> state32 <span>=</span> <span>{</span> <span>};</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true"></a><span>for</span> <span>(</span><span>char</span> <span>const</span><span>*</span> p <span>=</span> mbs<span>;</span> <span>*</span>p<span>;)</span> <span>{</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true"></a>    <span>// No error return possible, all mb characters must be</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true"></a>    <span>// complete and have UTF-32 codepoints, os is never 0</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true"></a>    <span>register</span> <span>size_t</span> <span>const</span> os <span>=</span> mbrtoc32<span>(</span>p32<span>,</span> p<span>,</span> len<span>,</span> <span>&amp;</span>state32<span>);</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true"></a>    <span>if</span> <span>(</span>os<span>-</span><span>1</span> <span>&gt;</span> len<span>-</span><span>1</span><span>)</span> <span>unreachable</span><span>();</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true"></a>    <span>if</span> <span>(</span>p32<span>[</span><span>0</span><span>]</span> <span>&gt;</span> <span>0x10&#39;FF&#39;FF<span><span>)</span> <span>unreachable</span><span>();</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true"></a>    p32 <span>+=</span> <span>1</span><span>;</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true"></a>    p   <span>+=</span> os<span>;</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true"></a>    len <span>-=</span> os<span>;</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true"></a><span>}</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true"></a><span>*</span>p32 <span>=</span> <span>0</span><span>;</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true"></a></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true"></a><span>// For any accepted identifier or pp-number PP this will be a valid UTF-16 string</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true"></a><span>char16_t</span>  s16<span>[</span><span>2</span> <span>*</span> <span>sizeof</span> mbs<span>];</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true"></a><span>char16_t</span><span>*</span> p16 <span>=</span> s16<span>;</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true"></a><span>size_t</span> len16 <span>=</span> <span>sizeof</span> mbs<span>;</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true"></a><span>mbstate_t</span> state16 <span>=</span> <span>{</span> <span>};</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true"></a><span>for</span> <span>(</span><span>char</span> <span>const</span><span>*</span> p <span>=</span> mbs<span>;</span> <span>*</span>p<span>;)</span> <span>{</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true"></a>    <span>// No error return possible, all mb characters must be</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true"></a>    <span>// complete and have UTF-32 codepoints, os is never 0</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true"></a>    <span>register</span> <span>size_t</span> <span>const</span> os <span>=</span> mbrtoc16<span>(</span>p16<span>,</span> p<span>,</span> len16<span>,</span> <span>&amp;</span>state16<span>);</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true"></a>    <span>if</span> <span>(</span>os<span>-</span><span>1</span> <span>&gt;</span> len<span>-</span><span>1</span><span>)</span> <span>unreachable</span><span>();</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true"></a>    <span>// A surrogate character has been stored</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true"></a>    <span>if</span> <span>((</span><span>0xD8&#39;00<span> <span>&lt;=</span> p16<span>[</span><span>0</span><span>])</span> <span>&amp;&amp;</span> <span>(</span>p16<span>[</span><span>0</span><span>]</span> <span>&lt;</span> <span>0xE0&#39;00<span><span>))</span> <span>{</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true"></a>        p16 <span>+=</span> <span>1</span><span>;</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true"></a>        <span>// No error return possible, this provides the second surrogate.</span></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true"></a>        <span>if</span> <span>(</span>mbrtoc16<span>(</span>p16<span>,</span> p<span>,</span> len16<span>,</span> <span>&amp;</span>state16<span>)</span> <span>!=</span> <span>-</span><span>3</span><span>)</span> <span>unreachable</span><span>();</span></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true"></a>        <span>if</span> <span>((</span>p16<span>[</span><span>0</span><span>]</span> <span>&lt;</span> <span>0xD8&#39;00<span><span>)</span> <span>||</span> <span>(</span><span>0xE0&#39;00<span> <span>&gt;=</span> p16<span>[</span><span>0</span><span>]))</span> <span>unreachable</span><span>();</span></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true"></a>    <span>}</span></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true"></a>    p16   <span>+=</span> <span>1</span><span>;</span></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true"></a>    p     <span>+=</span> os<span>;</span></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true"></a>    len16 <span>-=</span> os<span>;</span></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true"></a><span>}</span></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true"></a><span>*</span>p16 <span>=</span> <span>0</span><span>;</span></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true"></a></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true"></a><span>/* currently untested, use with care! */</span></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true"></a><span>// For any accepted identifier or pp-number PP this will be a valid UTF-8 string</span></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true"></a><span>char8_t</span>  s8<span>[</span><span>4</span> <span>*</span> <span>sizeof</span> mbs<span>];</span></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true"></a><span>char8_t</span><span>*</span> p8 <span>=</span> s8<span>;</span></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true"></a><span>size_t</span> len8 <span>=</span> <span>sizeof</span> mbs<span>;</span></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true"></a><span>mbstate_t</span> state8 <span>=</span> <span>{</span> <span>};</span></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true"></a><span>for</span> <span>(</span><span>char</span> <span>const</span><span>*</span> p <span>=</span> mbs<span>;</span> <span>*</span>p<span>;)</span> <span>{</span></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true"></a>    <span>// No error return possible, all mb characters must be</span></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true"></a>    <span>// complete and have UTF-32 codepoints, os is never 0</span></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true"></a>    <span>register</span> <span>size_t</span> <span>const</span> os <span>=</span> mbrtoc8<span>(</span>p8<span>,</span> p<span>,</span> len8<span>,</span> <span>&amp;</span>state8<span>);</span></span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true"></a>    <span>if</span> <span>(</span>os<span>-</span><span>1</span> <span>&gt;</span> len<span>-</span><span>1</span><span>)</span> <span>unreachable</span><span>();</span></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true"></a>    <span>// Determine the number of continuation bytes, if any.</span></span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true"></a>    <span>// This is found by looking at the highest order bit that is 0.</span></span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true"></a>    <span>// Mask with 0xFF is needed because p8[0] is promoted to int</span></span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true"></a>    <span>// before doing the complement.</span></span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true"></a>    <span>size_t</span> <span>const</span> plus <span>=</span> <span>8</span><span>-</span>stdc_first_leading_one<span>((~</span>p8<span>[</span><span>0</span><span>])&amp;</span><span>0xFF</span><span>u</span><span>);</span></span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true"></a>    <span>for</span> <span>(</span><span>size_t</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> plus<span>;</span> i<span>++)</span> <span>{</span></span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true"></a>        p8 <span>+=</span> <span>1</span><span>;</span></span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true"></a>        <span>// No error return possible, this provides the next continuation character.</span></span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true"></a>        <span>if</span> <span>(</span>mbrtoc8<span>(</span>p8<span>,</span> p<span>,</span> len8<span>,</span> <span>&amp;</span>state8<span>)</span> <span>!=</span> <span>-</span><span>3</span><span>)</span> <span>unreachable</span><span>();</span></span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true"></a>    <span>}</span></span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true"></a>    p8   <span>+=</span> <span>1</span><span>;</span></span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true"></a>    p    <span>+=</span> os<span>;</span></span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true"></a>    len8 <span>-=</span> os<span>;</span></span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true"></a><span>}</span></span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true"></a><span>*</span>p8 <span>=</span> <span>0</span><span>;</span></span></span></span></span></span></span></span></span></span></span></span></code></pre></div>
<p>Similarly, preprocessing numbers have to adhere to admit all the above continuation characters as possible continuation after initial digits or a decimal point.</p>
<p>These changes may marginally impact C library implementations where they use preprocessor concatenation or stringification if their multi-byte or wide character encodings are not UTF-8 or UTF-32, respectively.</p>
<h2 id="threads">Thread safety of the C library</h2>
<p>In several places C23 now explicitly grants permission to C library implementations to use thread local state for stateful functions. This implies permission to change behavior of <code>setlocale</code>, multibyte character conversion functions, <code>strtok</code>, <code>strerror</code>, and time conversion functions. Some of the changes can be done silently, others need to be documented as they are now implementation-defined.</p>
<p>The latter is in particular the case for all functions that have character conversion state held in an internal object of type <code><span>mbstate_t</span></code>. Here now a thread local object may be used if it is documented. Such a change could be a valuable service for threaded applications, although those that are performance critical should never use the variants of the interfaces that use an internal buffer, anyhow. The following functions each have their own internal state object that is either of static or thread local storage duration:</p>
<blockquote>
<p><code>c16tomb</code> <code>c32tomb</code> <code>c8tomb</code> <code>mbrtoc16</code> <code>mbrtoc32</code> <code>mbrtoc8</code> <code>mbrtowc</code> <code>mbsrtowcs</code> <code>mbtowc</code> <code>wcrtomb</code> <code>wcsrtombs</code> <code>wctomb</code></p>
</blockquote>
<p><code>mbrlen</code> is impacted implicitly because it uses the state of <code>mbrtowc</code>.</p>
<p>Previously, the C standard was ambiguous about this; but for the parts that make this an implementation-defined property (and thus force implementations to document) the possible changes are not normative but for quality of the implementation, only.</p>
<p>Rationale and wording for this change can be found in:</p>
<blockquote>
<blockquote>
<p><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n2444.htm">https://open-std.org/JTC1/SC22/WG14/www/docs/n2444.htm</a></p>
</blockquote>
</blockquote>
<h2 id="const-contract-of-the-c-library">Const-contract of the C library</h2>
<p>In C17 there are still interfaces that violate a <code><span>const</span></code>-contract: in some cases, pointer values to <code><span>const</span></code>-qualified objects that are passed as parameters to a function call can be returned as pointers to unqualified objects. C23 closes a lot of these loopholes per its default interfaces. This concerns the identifiers</p>
<blockquote>
<p><code>bsearch_t</code> <code>bsearch</code> <code>memchr</code> <code>strchr</code> <code>strpbrk</code> <code>strrchr</code> <code>strstr</code> <code>wcschr</code> <code>wmemchr</code> <code>wcspbrk</code> <code>wcsrchr</code> <code>wcsstr</code></p>
</blockquote>
<p>which now interface type-generic macros, see below. The function interfaces that may violate the <code><span>const</span></code>-contract still remain, they are kept for backwards compatibility, but unless they force the use of functions, user code sees the macros.</p>
<p>Code compiled with the C23 library interfaces is possibly rejected or diagnosed by compilers if they do not respect the <code><span>const</span></code>-contract. This is intentional.</p>
<h2 id="changes-to-integer-types">Changes to integer types</h2>
<p>One major change in the language is that two’s complement is now mandatory as a representation for signed types.</p>
<h3 id="WIDTH">New feature test macros</h3>
<p>This makes it easier to characterize integer types. For all of them there are now <code><span>...</span>_WIDTH</code> macros, that, together with the <code><span>sizeof</span></code> operator, completely describe the types. Annex E gives a good overview of the macros that are required and inform about minimal values for these.</p>
<p>Note that in the future the <code><span>...</span>_MAX</code> values are not necessarily always suitable for comparison in <code><span>#if</span></code> conditionals. Usage of these should be change to comparing the <code><span>...</span>_WIDTH</code> values, which are much smaller and usually more comprehensive numbers.</p>
<h3 id="new-valid-token-sequences-for-integer-constants">New valid token sequences for integer constants</h3>
<p>All macros that deal with integer constants have to be capable to deal with new formats for these literals.</p>
<ul>
<li>Binary constants with a <code><span>0b</span></code> or <code><span>0B</span></code> prefix.</li>
<li>Digit separators. The <code>&#39;</code> becomes a digit separator that can be placed anywhere between consecutive digits such as <code><span>1&#39;000<span></span></span></code> or <code><span>0.333</span>&#39;<span>333</span></code>.</li>
</ul>
<p>This concerns most importantly <code><span>...</span>_C</code> macros in <code><span>&lt;</span>stdint<span>.</span>h<span>&gt;</span></code>.</p>
<h3 id="exact-width-integer-types-are-mandatory">Exact-width integer types are mandatory</h3>
<p>This holds for all width for which the platform has integer types without padding.</p>
<h3 id="extended-integer-types-may-be-wider-than-intmax_t">Extended integer types may be wider than <code><span>intmax_t</span></code></h3>
<p>This concerns types that could be used as exact-width types, in particular <code><span>[</span>u<span>]</span>int128_t</code> and <code><span>[</span>u<span>]</span>int256_t</code> where many implementations already have extensions, but which cannot be “extended integer types” in the sense of C17.</p>
<p>On platforms with for example <code>gcc</code> (64 bit) that already have an extension <code>__int128</code> (with predefined macro <code>__SIZEOF_INT128__</code>) the necessary addition to <code><span>&lt;</span>stdint<span>.</span>h<span>&gt;</span></code> could look as follows:</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span>// No language version macro needed</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span><span>#ifdef</span> __SIZEOF_INT128__</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span>typedef</span> <span>signed</span>   __int128 int128_t<span>;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a><span>typedef</span> <span>unsigned</span> __int128 uint128_t<span>;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a><span>typedef</span> <span>signed</span>   __int128 int_fast128_t<span>;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a><span>typedef</span> <span>unsigned</span> __int128 uint_fast128_t<span>;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a><span>typedef</span> <span>signed</span>   __int128 int_least128_t<span>;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a><span>typedef</span> <span>unsigned</span> __int128 uint_least128_t<span>;</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a><span><span># define</span> UINT128_MAX         ((uint128_t)-1)</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a><span><span># define</span> INT128_MAX          ((int128_t)+(UINT128_MAX/2))</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a><span><span># define</span> INT128_MIN          (-INT128_MAX-1)</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a><span><span># define</span> UINT_LEAST128_MAX   UINT128_MAX</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a><span><span># define</span> INT_LEAST128_MAX    INT128_MAX</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true"></a><span><span># define</span> INT_LEAST128_MIN    INT128_MIN</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true"></a><span><span># define</span> UINT_FAST128_MAX    UINT128_MAX</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true"></a><span><span># define</span> INT_FAST128_MAX     INT128_MAX</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true"></a><span><span># define</span> INT_FAST128_MIN     INT128_MIN</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true"></a><span><span># define</span> INT128_WIDTH        128</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true"></a><span><span># define</span> UINT128_WIDTH       128</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true"></a><span><span># define</span> INT_LEAST128_WIDTH  128</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true"></a><span><span># define</span> UINT_LEAST128_WIDTH 128</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true"></a><span><span># define</span> INT_FAST128_WIDTH   128</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true"></a><span><span># define</span> UINT_FAST128_WIDTH  128</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true"></a><span><span># if</span> UINT128_WIDTH &gt; ULLONG_WIDTH</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true"></a><span><span>#  define</span> INT128_C(N)         ((int_least128_t)+N ## WB)</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true"></a><span><span>#  define</span> UINT128_C(N)        ((uint_least128_t)+N ## WBU)</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true"></a><span><span># else</span></span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true"></a><span><span>#  define</span> INT128_C(N)         ((int_least128_t)+N ## LL)</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true"></a><span><span>#  define</span> UINT128_C(N)        ((uint_least128_t)+N ## LLU)</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true"></a><span><span># endif</span></span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true"></a><span><span>#endif</span></span></span></code></pre></div>
<p>This might use the new mandatory bitprecise integer constants with suffix <code>WB</code> and <code>WBU</code> respectively by supposing that these will be implemented on these platforms to support at least 128 bit.</p>
<p>Note that the names for these types have been reserved since several C versions, so they are immediately available to the implementation and need not to be <code><span>#ifdef</span></code>ed for the C version of the compilation. Nevertheless, integer literals and format specifiers for these types might then not be available.</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span><span>#if</span> UINT128_WIDTH &gt; UINTMAX_WIDTH</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a><span><span># if</span> __STDC_VERSION__ &lt; 202311L</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a><span><span>#  warning</span> &#34;extended integer type for 128 type is wider than intmax_t&#34;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a><span><span># endif</span></span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a><span><span>#endif</span></span></span></code></pre></div>
<p>After implementing the mandatory changes to <code>printf</code> and <code>scanf</code> with length specifiers <code><span>%</span>w</code> and <code><span>%</span>wf</code> the corresponding macros should also be added to <code><span>&lt;</span>inttypes<span>.</span>h<span>&gt;</span></code>, see <a href="#wlength"><code><span>%</span>w</code></a> and <a href="#wflength"><code><span>%</span>wf</code></a> below.</p>
<h3 id="BitInt">Bit-precise integer types</h3>
<p>There is a whole new series of integer types called <em>bit-precise integer types</em>. They are coded by the token sequence <code><span>_BitInt</span><span>(</span></code><em>N</em><code><span>)</span></code> where <em>N</em> is an integer constant expression, and which can be combined with <code><span>signed</span></code> (default) and <code><span>unsigned</span></code>. The minimum value for <em>N</em> is <code><span>1</span></code> for unsigned types and <code><span>2</span></code> for signed. The maximum value is provided by a new macro <code>BITITNT_MAX</code> which has to be added to <code><span>&lt;</span>limits<span>.</span>h<span>&gt;</span></code>.</p>
<p>Clang already implements these types in their recent compilers and exports a predefined macro <code>__BITITNT_MAX__</code>. Hopefully gcc will choose the same. The name for the new macro had not previously been reserved, so its definition should be protected by a version macro.</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span><span>#if</span> __STDC_VERSION__ &gt; 202300L</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span><span># ifdef</span> __BITITNT_MAX__</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a><span><span>#  define</span> BITITNT_MAX __BITITNT_MAX__</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a><span><span># endif</span></span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a><span><span>#endif</span></span></span></code></pre></div>
<p>The constants for these types have the suffixes <code>WB</code>, <code>wb</code>, <code>WBU</code>, <code>wbU</code>, , <code>WBu</code>, or <code>wbu</code>, such that a suffixed constant has the type <code><span>_BitInt</span><span>(</span></code><em>N</em><code><span>)</span></code> where <em>N</em> is minimal for the constant to fit. This can be useful (see above) to express integer constants in headers of a perhaps wider range than otherwise would be supported.</p>
<p>Otherwise these types have no direct library interfaces by themselves.</p>
<p>Nevertheless, these type may occur as arguments to generic interfaces</p>
<ul>
<li>all <em>N</em> for <code>atomic_</code> functions in <a href="#stdatomic"><code><span>&lt;</span>stdatomic<span>.</span>h<span>&gt;</span></code></a>, <a href="#stdatomic">see below</a>;</li>
<li>certain <em>N</em> for the new <a href="#stdbit"><code><span>&lt;</span>stdbit<span>.</span>h<span>&gt;</span></code></a> interfaces, <a href="#stdbit">see below</a>.</li>
</ul>
<h3 id="string-to-integer-conversion">String to integer conversion</h3>
<p>See <a href="#strtol"><code>strtol</code></a></p>
<h3 id="ptrdiff_t"><code><span>ptrdiff_t</span></code></h3>
<p>May now be 16 bit wide, instead of previously 17 bit. Only implementations that previously were not conforming because of this (some compilers for 16 bit hardware) should be concerned about this. If that was there only miss, they become conforming to C23 where they weren’t for C17.</p>
<h3 id="char8_t-added"><code><span>char8_t</span></code> added</h3>
<p>See <a href="#uchar"><code><span>&lt;</span>uchar<span>.</span>h<span>&gt;</span></code></a>, below.</p>
<h3 id="stdbit">New mandatory header <code><span>&lt;</span>stdbit<span>.</span>h<span>&gt;</span></code></h3>
<p>This adds 14 <span>×</span> 5 functions and 14 tg macros for bit-manipulation; so in total 84 new interfaces.</p>
<p>On many architectures the functions themselves probably have builtins that just have to be interfaced.</p>
<p>The type-generic interfaces are a bit more tricky, since that have to work for</p>
<ul>
<li>standard unsigned integer types (<code><span>bool</span></code> excluded)</li>
<li>extended unsigned integer types (don’t forget additions such as <code>uint128_t</code>)</li>
<li>bit-precise types that have the same width as a standard or extended unsigned integer type (<code><span>bool</span></code> excluded).</li>
</ul>
<p>On architectures where these integer types don’t have padding bits all of these should probably just switched by the size of the argument and the function arguments should just be cast to these.</p>
<p><strong>ABI choice:</strong> There is one ABI choice to be made for this, the type described as <code>generic_return_type</code> for the type-generic functions. The question that has to be answered here is if an ABI community estimates that one day they will have extended integer types that have more than <code>INT_MAX</code> bits. I personally don’t think that this is likely; 16 bit architectures are unlikely to implement extended integer types with more than <code><span>32&#39;768<span></span></span></code> bit (<code><span>4&#39;096<span></span></span></code> byte), 32 bit architectures should be fine with extended integer types with up to <code><span>2&#39;147&#39;<span><span>483&#39;648<span></span></span></span></span></code> bits (<code><span>268&#39;435&#39;<span><span>456</span></span></span></code> byte).</p>
<p>(Test for parser <code><span>u8&#39;1&#39;</span></code>, <code><span>u8&#34;1&#34;</span></code>, <code><span>0x0&#39;1&#39;<span><span>0</span></span></span></code>, <code><span>0x0</span><span>WBU</span></code>, <code><span>1&#39;888&#39;<span><span>450</span><span>u</span><span>wb</span></span></span></code>, <code><span>0x78.aaP+7</span><span>L</span></code>, <code><span>0b&#39;0&#39;0&#39;1</span></code>, <code><span>077&#39;66<span></span></span></code>)</p>
<p>If we assume that <code><span>int</span></code> as a return type is just good enough, something along the lines of the following would probably work:</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span>static</span> <span>inline</span> <span>int</span> stdc_leading_zero8<span>(</span><span>uint8_t</span> __x<span>)</span> <span>{</span> <span>/* do your thing */</span> <span>}</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span>...</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a><span>static</span> <span>inline</span> <span>int</span> stdc_leading_zero128<span>(</span>uint128_t __x<span>)</span>  <span>{</span> <span>/* do your thing */</span> <span>}</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a><span><span>#define</span> stdc_leading_zero(X)                              \</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a><span>    _Generic((char(*)[sizeof(X)]){ 0 },                   \</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a><span>        char(*)[8]: stdc_leading_zero8((uint8_t)X),       \</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a><span>        ...                                               \</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a><span>        char(*)[128]: stdc_leading_zero128((uint128_t)X))</span></span></code></pre></div>
<p>Here, the cast in the chosen branch would never loose bits; the cast in the other branches is well-defined and should not issue diagnostics. Also, the <code><span>inline</span></code> functions can be <code><span>static</span></code> since these are implementation details that do not have to be exported as linker interfaces on which user code may rely upon.</p>
<p>As an extension, this would also work for</p>
<ul>
<li><code><span>bool</span></code> because the conversion will just have a <code><span>0</span></code> or <code><span>1</span></code> of the appropriate size;</li>
<li>signed integer types because conversion to the unsigned type is always well-defined.</li>
</ul>
<h3 id="stdckdint">New mandatory header <code><span>&lt;</span>stdckdint<span>.</span>h<span>&gt;</span></code></h3>
<p>The specification of the interfaces in C23 is type-generic:</p>
<div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span><span>#include</span> </span><span>&lt;stdckdint.h&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span>bool</span> ckd_add<span>(</span>type1 <span>*</span>result<span>,</span> type2 a<span>,</span> type3 b<span>);</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a><span>bool</span> ckd_sub<span>(</span>type1 <span>*</span>result<span>,</span> type2 a<span>,</span> type3 b<span>);</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a><span>bool</span> ckd_mul<span>(</span>type1 <span>*</span>result<span>,</span> type2 a<span>,</span> type3 b<span>);</span></span></code></pre></div>
<p>This adds overflow and wrap-around safe interfaces for integer addition, subtraction and multiplication. The result target is filled with the truncated result of the mathematical operation, the return value holds <code><span>false</span></code> if that result is correct, <code><span>true</span></code> otherwise.</p>
<p>Admissible types for these operations are all standard integer types with the exception of <code><span>bool</span></code> and <code><span>char</span></code>.</p>
<p>The intent of these interfaces is that they use the underlying hardware as efficient as possible. Most modern processors have overflow flags in hardware and these functions should in general just query these flags.</p>
<p>On most architectures there are probably builtins that just have to be interfaced, but since they are type-generic there might some more to do than just functions. On the other hand, compilers such as gcc and clang already have similar type-generic interfaces:</p>
<div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span>bool</span> __builtin_add_overflow <span>(</span>type1 a<span>,</span> type2 b<span>,</span> type3 <span>*</span>res<span>);</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span>bool</span> __builtin_sub_overflow <span>(</span>type1 a<span>,</span> type2 b<span>,</span> type3 <span>*</span>res<span>);</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a><span>bool</span> __builtin_mul_overflow <span>(</span>type1 a<span>,</span> type2 b<span>,</span> type3 <span>*</span>res<span>);</span></span></code></pre></div>
<p>When relying on such an extension the contents of the header could just read</p>
<div id="cb8"><pre><code><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span><span>#ifndef</span> __STDC_VERSION_STDCKDINT_H__</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a><span><span>#define</span> __STDC_VERSION_STDCKDINT_H__ 202311L</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a><span><span>#ifdef</span> __GNUC__</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a><span><span># define</span> ckd_add(R, A, B) __builtin_add_overflow ((A), (B), (R))</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a><span><span># define</span> ckd_sub(R, A, B) __builtin_sub_overflow ((A), (B), (R))</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a><span><span># define</span> ckd_mul(R, A, B) __builtin_mul_overflow ((A), (B), (R))</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a><span><span>#else</span></span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a><span><span># error</span> &#34;we need a compiler extension for this&#34;</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a><span><span>#endif</span></span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true"></a><span><span>#endif</span></span></span></code></pre></div>
<p>The addition that has been integrated into C23 is the <a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n2683.pdf">core proposal</a> and <a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n2867.pdf">some amendments</a>. The history of this looks a bit confusing because later editions of the paper have removed parts that had already been adopted.</p>
<h2 id="alignment-to-iec-60559-for-standard-floating-point">Alignment to IEC 60559 for standard floating point</h2>
<p>Unfortunately not my field of expertise.</p>
<h2 id="optional-iec-60559-support-for-decimal-floating-point">Optional IEC 60559 support for decimal floating point</h2>
<p>Unfortunately not my field of expertise, but see some discussion for <a href="#stdarg"><code><span>&lt;</span>stdarg<span>.</span>h<span>&gt;</span></code></a> and <a href="#stdio"><code><span>&lt;</span>stdio<span>.</span>h<span>&gt;</span></code></a>, below.</p>
<h2 id="attributes">Attributes</h2>
<p>The introduction of attributes in C23 only implies a few changes in the library.</p>
<h3 id="noreturn-becomes-noreturn"><code><span>_Noreturn</span></code> becomes <code><span>[[</span><span>noreturn</span><span>]]</span></code></h3>
<p>Adapting to that will be a bit tedious because, <code><span>_Noreturn</span></code> lives on as a keyword for some time. The easiest would probably be to change occurrences of <code><span>_Noreturn</span></code> in the C library headers <code><span>&lt;</span>setjmp<span>.</span>h<span>&gt;</span></code>, <code><span>&lt;</span>threads<span>.</span>h<span>&gt;</span></code> and <code><span>&lt;</span>stdlib<span>.</span>h<span>&gt;</span></code> by something like <code>__noreturn</code> and then add the following in a general preamble or to the preambles of these headers:</p>
<div id="cb9"><pre><code><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span><span>#if</span> (__STDC_VERSION__ &gt; 202300L) || defined(__cplusplus)</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a><span><span># define</span> __noreturn </span><span>[[</span><span>noreturn</span><span>]]</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a><span><span>#else</span></span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a><span><span># define</span> __noreturn _Noreturn</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a><span><span>#endif</span></span></span></code></pre></div>
<p>The macros <code>__STDC_VERSION_SETJMP_H__</code>, <code>__STDC_VERSION_STDLIB_H__</code> and <code>__STDC_VERSION_THREADS_H__</code> should only be set to <code><span>202311</span><span>L</span></code> if this change is implemented.</p>
<p>Changes to implementation-defined occurences of <code><span>_Noreturn</span></code> are not necessary, but it would be a good occasion to do so.</p>
<p>The header <code><span>&lt;</span>stdnoreturn<span>.</span>h<span>&gt;</span></code> becomes obsolescent, but does not change.</p>
<h3 id="deprecating-certain-functions-with-deprecated">Deprecating certain functions with <code><span>[[</span><span>deprecated</span><span>]]</span></code></h3>
<p>Two functions in <a href="#asctime"><code><span>&lt;</span>time<span>.</span>h<span>&gt;</span></code></a> receive such an attribute, see <a href="#asctime">below</a>.</p>
<h2 id="predefined-macro-names">Predefined macro names</h2>
<h3 id="stdc_utf_16__-and-__stdc_utf_32__-are-mandatory"><code>__STDC_UTF_16__</code> and <code>__STDC_UTF_32__</code> are mandatory</h3>
<p>They are now forced to the value 1</p>
<h2 id="remove-trigraphs">Remove trigraphs</h2>
<p>Trigraphs are removed from the language. Any library headers that use them must be updated.</p>
<p>Generally, they are probably never used within strings or character literals in C library headers.</p>
<p>A more common use may be the trigraph <code><span>??=</span></code> in preprocessing as a replacement for <code><span>#</span></code>. This can be easily be replaced by the digraphs <code><span>%:</span></code> and <code><span>%:%:</span></code> which have the following advantages</p>
<ul>
<li>They are proper tokens and will not be substituted in early compilation phases. So there is no messing with the contents of user strings anymore.</li>
<li>The characters <code><span>%</span></code> and <code><span>:</span></code> are present in all source file encodings that are currently still in use.</li>
</ul>
<h2 id="assert">Changes to <code><span>&lt;</span>assert<span>.</span>h<span>&gt;</span></code></h2>
<h3 id="stdc_version_assert_h__"><code>__STDC_VERSION_ASSERT_H__</code></h3>
<p>This macro is mandatory and should be set to <code><span>202311</span><span>L</span></code> once the header is compliant to C23.</p>
<h3 id="assert-1"><code>assert</code></h3>
<p>Before this change, the <code>assert</code> macro commonly suffered from the one-macro-parameter problem, namely that expressions that contained a highlevel comma such as <code><span>(</span>mystruct<span>){</span> a <span>=</span> <span>0</span><span>,</span> b <span>=</span> x<span>}.</span>b</code> would not be seen as one argument but several.</p>
<p>There is a simple cure to this namely to define <code>assert</code> with <code><span>...</span></code>. If we suppose that there is a builtin function</p>
<div id="cb10"><pre><code><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span>[[</span><span>noreturn</span><span>]]</span> <span>void</span> __builtin_assert<span>(</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>    <span>const</span> <span>char</span> <span>*</span> __expr<span>,</span>            <span>// textual version of the expression</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>    <span>const</span> <span>char</span><span>*</span> __file<span>,</span>             <span>// the name of the source</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>    <span>unsigned</span> <span>long</span> __line<span>,</span>           <span>// the current line number, may be larger than INT_MAX</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>    <span>const</span> <span>char</span><span>*</span> __func<span>);</span>            <span>// the current function</span></span></code></pre></div>
<p>Then the macro can be defined as</p>
<div id="cb11"><pre><code><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span><span>#ifdef</span> NDEBUG</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a><span><span>#define</span> assert(...) ((void)0)</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a><span><span>#else</span></span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a><span><span>#if</span> __STDC_VERSION &gt;= 199901L</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a><span><span># define</span> assert(...) ((__VA_ARGS__) ? (void)0 : __builtin_assert(#__VA_ARGS__, __FILE__, __LINE__, __func__))</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a><span><span>#else</span></span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a><span><span># define</span> assert(X) ((X) ? (void)0 : __builtin_assert(#X, __FILE__, __LINE__, __func__))</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a><span><span>#endif</span></span></span></code></pre></div>
<p>This change is conforming to all C versions after C99 where variable argument macros were introduced.</p>
<h2 id="float">Changes to <code><span>&lt;</span><span>float</span><span>.</span>h<span>&gt;</span></code></h2>
<h3 id="stdc_version_float_h__"><code>__STDC_VERSION_FLOAT_H__</code></h3>
<p>This macro is mandatory and should be set to <code><span>202311</span><span>L</span></code> once the header is compliant to C23.</p>
<h3 id="missing-macros">Missing macros</h3>
<p>Not my field of expertise.</p>
<h2 id="limits">Changes to <code><span>&lt;</span>limits<span>.</span>h<span>&gt;</span></code></h2>
<h3 id="stdc_version_limits_h__"><code>__STDC_VERSION_LIMITS_H__</code></h3>
<p>This macro is mandatory and should be set to <code><span>202311</span><span>L</span></code> once the header is compliant to C23.</p>
<h3 id="missing-macros-1">Missing macros</h3>
<ul>
<li><a href="#BitInt"><code>BITINT_MAX</code></a> for the maximal supported width of a bit precise integer type</li>
<li><a href="#WIDTH"><code>_WIDTH</code></a> macros for all standard integer types</li>
</ul>
<h2 id="stdarg">Changes to <code><span>&lt;</span>stdarg<span>.</span>h<span>&gt;</span></code></h2>
<p>This header provides a liaison between C language and C library. For implementations that have no good compiler support for <code>va_<span>...</span></code> macros, support for C23 appears to be relatively challenging.</p>
<p>For implementations that just forward these macros to compiler builtins, there is no particular difficulty to be expected.</p>
<h3 id="stdc_version_stdarg_h__"><code>__STDC_VERSION_STDARG_H__</code></h3>
<p>This macro is mandatory and should be set to <code><span>202311</span><span>L</span></code> once the header is compliant to C23.</p>
<h3 id="additional-arguments-to-va_start-can-be-omitted.">Additional arguments to <code>va_start</code> can be omitted.</h3>
<div id="cb12"><pre><code><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span>void</span> va_start<span>(</span><span>va_list</span> ap<span>,</span> <span>...);</span></span></code></pre></div>
<ul>
<li>Only the first argument shall be used and evaluated.</li>
<li>Functions specified with <code><span>...</span></code> parameter may have only that and <code>va_start</code> must be able to deal with that situation.</li>
</ul>
<p>The formulation as given above is only valid if the preprocessor is conforming to C23, namely that it works well without a trailing comma. Probably the easiest way to take care of that is by using the version macro</p>
<div id="cb13"><pre><code><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span><span>#if</span> __STDC_VERSION__ &gt; 202300</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a><span><span>#define</span> va_start(AP, ...) </span><span>/* Use new sequence without second argument */</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a><span><span>#else</span></span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a><span><span>#define</span> va_start(AP, LAST) </span><span>/* Use old sequence with second argument */</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a><span><span>#endif</span></span></span></code></pre></div>
<p>Implementations that set <code>__STDC_VERSION_STDARG_H__</code> have to verify that they conform to that reformulation.</p>
<h3 id="support-for-new-types-standard-or-extended">Support for new types, standard or extended</h3>
<p>Users will expect <code>va_arg</code> to work for all types that a C23 compiler provides.</p>
<p><strong>Compiler dependency:</strong> Implementations that set <code>__STDC_VERSION_STDARG_H__</code> have to verify that they at least support the new standard types. Users would be quite surprised if a compiler implements optional types or certain common extensions and <code>va_arg</code> fails with them. This would make it in particular impossible for third party libraries to add support for these types.</p>
<h4 id="va_arg-can-handle-function-arguments-with-type-nullptr_t"><code>va_arg</code> can handle function arguments with type <code><span>nullptr_t</span></code></h4>
<p>Functions that are called with a <code><span>nullptr</span></code> argument in the variable argument list can deal with such an argument by calls</p>
<div id="cb14"><pre><code><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a>va_arg<span>(</span>ap<span>,</span> <span>nullptr_t</span><span>)</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>va_arg<span>(</span>ap<span>,</span> <span>char</span><span>*)</span></span></code></pre></div>
<p>or any other pointer type that has the same representation as <code><span>char</span><span>*</span></code>, such as <code><span>void</span><span>*</span></code>. In particular, on implementations that have exactly one pointer model (such as POSIX) any pointer type can be used as type name argument.</p>
<p>The result of the macro call is then a null pointer of the indicated type.</p>
<p><strong>Compiler dependency:</strong> To support the variant that uses <code><span>nullptr_t</span></code> compiler support is needed.</p>
<h4 id="va_arg-may-be-called-with-_bitintn-types"><code>va_arg</code> may be called with <code><span>_BitInt</span><span>(</span></code><em>N</em><code><span>)</span></code> types</h4>
<p>This is a bit tricky for narrow bit-precise types, because they do not promote to <code><span>int</span></code> as would other narrow types.</p>
<h4 id="va_arg-and-decimal-floating-types"><code>va_arg</code> and decimal floating types</h4>
<p>Full support for decimal floating point is indicated by the feature test macro <code>__STDC_IEC_60559_DFP__</code>. Setting this macro implies not only compiler support (arithmetic, fuction calls) but also the implementation of about 600 C library interfaces (5.5 pages in the library summary Annex B). So implementations might be hesitant to support this. Hopefully the open source implementations will join forces to supply an add-on external library that completes support for these types.</p>
<p><strong>Compiler dependency:</strong> Decimal floating point types are optional, but they are already implemented on a major compiler (<em>gcc</em>) and expectations will be high that any C library supports these types on such platforms in <code><span>&lt;</span>stdarg<span>.</span>h<span>&gt;</span></code>, even if they do not intend to set <code>__STDC_IEC_60559_DFP__</code> themselves.</p>
<h4 id="va_arg-and-extended-integer-types"><code>va_arg</code> and extended integer types</h4>
<p>With relaxation for wide integer types that exceed the width of <code><span>intmax_t</span></code>, compiler platforms may start to provide support for such types. This may for example be the case of <code>__int128</code> types on <em>x86_64</em>, <em>powerpc64</em> or <em>aarch64</em>, and which are already supported by compilers.</p>
<p>For any width <em>N</em> such there is an extended integer type that has no padding there has to be support for types <code><span>int</span></code><em>N</em><code>_t</code> and <code>uint</code><em>N</em><code>_t</code>. So in particular <code><span>...</span>_C</code> macros and <code>w</code><em>N</em> length modifiers for <code>printf</code> are mandatory. So C library implementations also have to support these extended integer types for <code>va_arg</code>.</p>
<h2 id="stdatomic">Changes to <code><span>&lt;</span>stdatomic<span>.</span>h<span>&gt;</span></code></h2>
<h3 id="stdc_version_stdatomic_h__"><code>__STDC_VERSION_STDATOMIC_H__</code></h3>
<p>This macro is mandatory and should be set to <code><span>202311</span><span>L</span></code> once the header is compliant to C23.</p>
<h3 id="remove-atomic_var_init">Remove <code>ATOMIC_VAR_INIT</code> ?</h3>
<p>This macro is removed from the standard because it is not deemed necessary to implement atomics, normal initialization syntax should be sufficient.</p>
<p>Implementations may keep this macro, though, because the <code>ATOMIC_<span>...</span></code> prefix is still reserved and so they do not impede on the users name space for identifiers.</p>
<h3 id="new-_bitintn-and-decimal-floating-point-types-must-be-supported-by-type-generic-interfaces">New <code><span>_BitInt</span><span>(</span></code><em>N</em><code><span>)</span></code> and decimal floating point types must be supported by type-generic interfaces</h3>
<p>For implementations that mostly rely on <code><span>_Generic</span></code> or similar features to provide operations such as <code>atomic_fetch_add</code>, for example, this addition to the interface might be quite challenging.</p>
<p><strong>ABI choice:</strong> Also ABI decisions have to be taken which of these new types, if any, are to be <em>lock-free</em>. There are no particular feature test macros for these types concerning this property (so no preprocessor conditionals can be used) but the generic function <code>atomic_is_lock_free</code> has to cope with them. This function could, for example, return <code><span>true</span></code> for all types where there is a supporting basic type with the same <em>size</em> that is lock-free.</p>
<h3 id="new-macro-atomic_char8_t_lock_free-and-type-atomic_char8_t">New macro <code>ATOMIC_CHAR8_T_LOCK_FREE</code> and type <code>atomic_char8_t</code></h3>
<p>This is necessary because of the addition of <code><span>char8_t</span></code> to <code><span>&lt;</span>uchar<span>.</span>h<span>&gt;</span></code>. This can be done by inserting the following two lines at the appropriate places of <code><span>&lt;</span>stdatomic<span>.</span>h<span>&gt;</span></code>.</p>
<div id="cb15"><pre><code><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span><span>#define</span> ATOMIC_CHAR8_T_LOCK_FREE ATOMIC_CHAR_LOCK_FREE</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a><span>typedef</span> <span>_Atomic</span><span>(</span><span>unsigned</span> <span>char</span><span>)</span> atomic_char8_t<span>;</span></span></code></pre></div>
<p>Because the <code>ATOMIC_</code> and <code>atomic_</code> prefixes are reserved, no preprocessor conditional is needed.</p>
<h2 id="stdbool">Changes to <code><span>&lt;</span>stdbool<span>.</span>h<span>&gt;</span></code></h2>
<h3 id="stdc_version_bool_h__"><code>__STDC_VERSION_BOOL_H__</code> ?</h3>
<p>This macro is mandatory and should be set to <code><span>202311</span><span>L</span></code> once the header is compliant to C23.</p>
<h3 id="removeprotect-bool-false-and-true">Remove/protect <code><span>bool</span></code>, <code><span>false</span></code> and <code><span>true</span></code></h3>
<p>The following could be the complete contents of this header:</p>
<div id="cb16"><pre><code><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span><span>#ifndef</span> __STDC_VERSION_BOOL_H__</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a><span><span>#define</span> __STDC_VERSION_BOOL_H__ 202311L</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a><span><span>#if</span> (__STDC_VERSION__ &lt; 202300L) &amp;&amp; !defined(__cplusplus)</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a><span><span>#define</span> true  1</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a><span><span>#define</span> false 0</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true"></a><span><span>#define</span> bool  _Bool</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true"></a><span><span>#else</span></span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true"></a><span><span>#define</span> true  true</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true"></a><span><span>#define</span> false false</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true"></a><span><span>#define</span> bool  bool</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true"></a><span><span>#endif</span></span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true"></a></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true"></a><span><span>#define</span> __bool_true_false_are_defined 1</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true"></a></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true"></a><span><span>#endif</span></span></span></code></pre></div>
<p>Note that this unconditionally defines the macros, because some application code might do preprocessor conditionals on these.</p>
<h2 id="stddef">Changes to <code><span>&lt;</span>stddef<span>.</span>h<span>&gt;</span></code></h2>
<h3 id="stdc_version_stddef_h__"><code>__STDC_VERSION_STDDEF_H__</code></h3>
<p>This macro is mandatory and should be set to <code><span>202311</span><span>L</span></code> once the header is compliant to C23.</p>
<h3 id="unreachable-macro"><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n2826.pdf"><code><span>unreachable</span></code> macro</a></h3>
<p>Defined in 7.21.1.</p>
<ul>
<li><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n2826.pdf">https://open-std.org/JTC1/SC22/WG14/www/docs/n2826.pdf</a>, the macro option has been chosen by WG14.</li>
</ul>
<p><strong>Compiler dependency:</strong> Quality implementations need compiler support for this.</p>
<p><em>gcc</em> and <em>clang</em> already have <code>__builtin_unreachable</code> so in general here the “implementation” for the interface is only</p>
<div id="cb17"><pre><code><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span><span>#ifdef</span> unreachable</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a><span><span># error</span> unreachable() is a standard macro for C23</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a><span><span>#endif</span></span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a><span><span>#if</span> __STDC_VERSION__ &gt;= 202311L</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a><span><span># define</span> unreachable() __builtin_unreachable()</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a><span><span>#else</span></span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true"></a><span><span># define</span> unreachable static_assert(0, &#34;unreachable becomes a standard macro for C23&#34;)</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true"></a><span><span>#endif</span></span></span></code></pre></div>
<p>This also detects usage of the now-reserved identifier <code><span>unreachable</span></code> in code that is not yet ready for C23.</p>
<p>Because it is just undefined in the primary sense of the word if a call to that feature is reached, theoretically low quality implementations could do nonsense as the following:</p>
<div id="cb18"><pre><code><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span><span>#define</span> unreachable() ((void)0)</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a><span><span>#define</span> unreachable() ((void)(1/0))</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a><span><span>#define</span> unreachable() ((void)puts(&#34;reached the ureachable&#34;))</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a><span><span>#define</span> unreachable() abort()</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a><span><span>#define</span> unreachable() give_me_your_credit_card_number()</span></span></code></pre></div>
<p>All of this would result in suboptimal code for their users, because this feature is meant such that whole branches of the control flow graph can be pruned from the executable.</p>
<h3 id="nullptr_t"><code><span>nullptr_t</span></code></h3>
<p>C23 has a new keyword and constant <code><span>nullptr</span></code> and provides access to the underlying type via <code><span>&lt;</span>stddef<span>.</span>h<span>&gt;</span></code> as</p>
<div id="cb19"><pre><code><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span><span>#if</span> __STDC_VERSION__ &gt; 202311L</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a><span>typedef</span> <span>typeof</span><span>(</span><span>nullptr</span><span>)</span> <span>nullptr_t</span><span>;</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a><span><span>#endif</span></span></span></code></pre></div>
<p>On general implementations, a preprocessor conditional is needed, because the identifiers <code><span>nullptr</span></code> and <code><span>nullptr_t</span></code> had not been reserved before C23. For the type alone, such a conditional is not needed on POSIX systems, since their types with suffix <code>_t</code> are already reserved.</p>
<h3 id="null"><code>NULL</code></h3>
<p>Because of the ambiguity of its definition, this macro has some portability and safety problems and so C23 has integrated <code><span>nullptr</span></code> (introduced to C++ in 2011) to replace it on the long run.</p>
<p>There is no requirement, yet, to have this macro point to <code><span>nullptr</span></code>, though, but on non-POSIX implementations it might be a good idea to move to something like the following:</p>
<div id="cb20"><pre><code><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span><span>#if</span> (__cplusplus &gt;= 201103L) || (__STDC_VERSION__ &gt;= 202311L)</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a><span><span>#define</span> NULL nullptr</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a><span><span>#elif</span> defined(__cplusplus)</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a><span><span>#define</span> NULL 0L              </span><span>/* Any of 0, 0L, 0LL as wide as a void* */</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true"></a><span><span>#else</span></span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true"></a><span><span>#define</span> NULL ((void*)0)</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true"></a><span><span>#endif</span></span></span></code></pre></div>
<p>POSIX implementations should for the moment stay with <code><span>((</span><span>void</span><span>*)</span><span>0</span><span>)</span></code> since this is a requirement, there, until this constraint is lifted. Since <code><span>nullptr</span></code> values have the same representation as <code><span>void</span><span>*</span></code> this should not result in much difficulties, anyhow.</p>
<p>A preprocessor conditional is needed, because <code><span>nullptr</span></code> is new for C23.</p>
<h2 id="stdio">Changes to <code><span>&lt;</span>stdio<span>.</span>h<span>&gt;</span></code></h2>
<h3 id="stdc_version_stdio_h__"><code>__STDC_VERSION_STDIO_H__</code></h3>
<p>This macro is mandatory and should be set to <code><span>202311</span><span>L</span></code> once the header is compliant to C23.</p>
<h3 id="changes-to-formatted-io">Changes to formatted IO</h3>
<p>This implies changes for <code>printf</code>, <code>scanf</code> and friends.</p>
<h4 id="printing-nan"><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n2446.htm">printing <code>NaN</code></a></h4>
<p>There is a new <code>_PRINTF_NAN_LEN_MAX</code> macro that holds the maximum length of output corresponding to a <code>NaN</code> value that would be issued by <code>printf</code> and friends.</p>
<ul>
<li><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n2446.htm">https://open-std.org/JTC1/SC22/WG14/www/docs/n2446.htm</a></li>
</ul>
<h4 id="the-b-conversion-specifier"><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n2630.pdf">the <code>b</code> conversion specifier</a></h4>
<p>This specifies binary input and output analogous to hexadecimal, only that the character <code>b</code> plays the role of <code>x</code>.</p>
<p>For <code>scanf</code>, <strong>this is a semantic change</strong>, because input may be accepted or rejected according the version of the C library that is linked to the excutable, see <a href="#strtol"><code>strtol</code></a> below. Depending on the solutions that WG14 might still find for that problems, it might be possible that a whole second set of <code>scanf</code> interfaces is needed.</p>
<p>Introduction of a similar <code>B</code> conversion specifier (comparable to <code>X</code>) for <code>printf</code> is only recommended and not imposed because implementations could already have occupied this space. So if an implementations does currently nothing particular for <code>B</code> it is expected that they also implement <code>B</code> analogous to <code>X</code></p>
<ul>
<li><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n2630.pdf">https://open-std.org/JTC1/SC22/WG14/www/docs/n2630.pdf</a></li>
</ul>
<h4 id="wlength"><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n2680.pdf"><code>w</code><em>N</em> length modifiers</a></h4>
<p>Where <em>N</em> is any of the values (decimal without leading <code><span>0</span></code>) for all supported minimum-width integer types provided by 7.22.1.2. The exact width integer types (7.22.1.1) now are a subset of these, so in particular these must all be supported. To implement these, it must be known to which size a given width corresponds, so in particular which widths are natively supported by the architecture. For <code><span>8</span></code>, <code><span>16</span></code>, <code><span>32</span></code> and <code><span>64</span></code> the minimum-width integer types are mandatory, so at least these values must be supported.</p>
<ul>
<li><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n2680.pdf">https://open-std.org/JTC1/SC22/WG14/www/docs/n2680.pdf</a></li>
</ul>
<p>Implementations should try to support <em>N</em> and exact-width types for values where there might not even be compiler support, yet. Now that we know that signed integers are two’s complement, once the byte interpretation (endianess) of <code>int128_t</code> for example is known, I/O on these represented values should not be difficult. Adding such values for which there might be no full support for the type otherwise is allowed, it just has to be documented. In any case, applications may easily check with <code><span>#ifdef</span></code>.</p>
<p>Note that it is not expected that these macros work for the new <code><span>_BitInt</span><span>(</span></code><em>N</em><code><span>)</span></code> types even if <em>N</em> is one of the standard value. This is because the argument-passing convention for these types may be different from the standard integer types.</p>
<p>For versions of the C library that support these formats (and thus set <code>__STDC_VERSION_STDIO_H__</code>) the macros <code>PRIx</code><em>N</em> etc should use these new length modifiers. This could look something like</p>
<div id="cb21"><pre><code><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span><span>#define</span> _PRI(F, N) &#34;w&#34; #N #F</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a><span><span>#define</span> PRIX128 _PRI(X, 128)</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a><span><span>#define</span> PRIX16  _PRI(X, 16)</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a><span><span>#define</span> PRIX256 _PRI(X, 256)</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true"></a><span><span>#define</span> PRIX32  _PRI(X, 32)</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true"></a><span><span>#define</span> PRIX64  _PRI(X, 64)</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true"></a><span><span>#define</span> PRIX8   _PRI(X, 8)</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true"></a><span><span>#define</span> PRId128 _PRI(d, 128)</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true"></a><span><span>#define</span> PRId16  _PRI(d, 16)</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true"></a><span><span>#define</span> PRId256 _PRI(d, 256)</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true"></a><span><span>#define</span> PRId32  _PRI(d, 32)</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true"></a><span><span>#define</span> PRId64  _PRI(d, 64)</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true"></a><span><span>#define</span> PRId8   _PRI(d, 8)</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true"></a><span><span>#define</span> PRIi128 _PRI(i, 128)</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true"></a><span><span>#define</span> PRIi16  _PRI(i, 16)</span></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true"></a><span><span>#define</span> PRIi256 _PRI(i, 256)</span></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true"></a><span><span>#define</span> PRIi32  _PRI(i, 32)</span></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true"></a><span><span>#define</span> PRIi64  _PRI(i, 64)</span></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true"></a><span><span>#define</span> PRIi8   _PRI(i, 8)</span></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true"></a><span><span>#define</span> PRIo128 _PRI(o, 128)</span></span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true"></a><span><span>#define</span> PRIo16  _PRI(o, 16)</span></span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true"></a><span><span>#define</span> PRIo256 _PRI(o, 256)</span></span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true"></a><span><span>#define</span> PRIo32  _PRI(o, 32)</span></span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true"></a><span><span>#define</span> PRIo64  _PRI(o, 64)</span></span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true"></a><span><span>#define</span> PRIo8   _PRI(o, 8)</span></span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true"></a><span><span>#define</span> PRIu128 _PRI(u, 128)</span></span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true"></a><span><span>#define</span> PRIu16  _PRI(u, 16)</span></span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true"></a><span><span>#define</span> PRIu256 _PRI(u, 256)</span></span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true"></a><span><span>#define</span> PRIu32  _PRI(u, 32)</span></span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true"></a><span><span>#define</span> PRIu64  _PRI(u, 64)</span></span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true"></a><span><span>#define</span> PRIu8   _PRI(u, 8)</span></span>
<span id="cb21-32"><a href="#cb21-32" aria-hidden="true"></a><span><span>#define</span> PRIx128 _PRI(x, 128)</span></span>
<span id="cb21-33"><a href="#cb21-33" aria-hidden="true"></a><span><span>#define</span> PRIx16  _PRI(x, 16)</span></span>
<span id="cb21-34"><a href="#cb21-34" aria-hidden="true"></a><span><span>#define</span> PRIx256 _PRI(x, 256)</span></span>
<span id="cb21-35"><a href="#cb21-35" aria-hidden="true"></a><span><span>#define</span> PRIx32  _PRI(x, 32)</span></span>
<span id="cb21-36"><a href="#cb21-36" aria-hidden="true"></a><span><span>#define</span> PRIx64  _PRI(x, 64)</span></span>
<span id="cb21-37"><a href="#cb21-37" aria-hidden="true"></a><span><span>#define</span> PRIx8   _PRI(x, 8)</span></span></code></pre></div>
<div id="cb22"><pre><code><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span><span>#define</span> PRIXLEAST128 PRIX128</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a><span><span>#define</span> PRIXLEAST16 PRIX16</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a><span><span>#define</span> PRIXLEAST256 PRIX256</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a><span><span>#define</span> PRIXLEAST32 PRIX32</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a><span><span>#define</span> PRIXLEAST64 PRIX64</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true"></a><span><span>#define</span> PRIXLEAST8 PRIX8</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true"></a><span><span>#define</span> PRIdLEAST128 PRId128</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true"></a><span><span>#define</span> PRIdLEAST16 PRId16</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true"></a><span><span>#define</span> PRIdLEAST256 PRId256</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true"></a><span><span>#define</span> PRIdLEAST32 PRId32</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true"></a><span><span>#define</span> PRIdLEAST64 PRId64</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true"></a><span><span>#define</span> PRIdLEAST8 PRId8</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true"></a><span><span>#define</span> PRIiLEAST128 PRIi128</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true"></a><span><span>#define</span> PRIiLEAST16 PRIi16</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true"></a><span><span>#define</span> PRIiLEAST256 PRIi256</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true"></a><span><span>#define</span> PRIiLEAST32 PRIi32</span></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true"></a><span><span>#define</span> PRIiLEAST64 PRIi64</span></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true"></a><span><span>#define</span> PRIiLEAST8 PRIi8</span></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true"></a><span><span>#define</span> PRIoLEAST128 PRIo128</span></span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true"></a><span><span>#define</span> PRIoLEAST16 PRIo16</span></span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true"></a><span><span>#define</span> PRIoLEAST256 PRIo256</span></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true"></a><span><span>#define</span> PRIoLEAST32 PRIo32</span></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true"></a><span><span>#define</span> PRIoLEAST64 PRIo64</span></span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true"></a><span><span>#define</span> PRIoLEAST8 PRIo8</span></span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true"></a><span><span>#define</span> PRIuLEAST128 PRIu128</span></span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true"></a><span><span>#define</span> PRIuLEAST16 PRIu16</span></span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true"></a><span><span>#define</span> PRIuLEAST256 PRIu256</span></span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true"></a><span><span>#define</span> PRIuLEAST32 PRIu32</span></span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true"></a><span><span>#define</span> PRIuLEAST64 PRIu64</span></span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true"></a><span><span>#define</span> PRIuLEAST8 PRIu8</span></span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true"></a><span><span>#define</span> PRIxLEAST128 PRIx128</span></span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true"></a><span><span>#define</span> PRIxLEAST16 PRIx16</span></span>
<span id="cb22-33"><a href="#cb22-33" aria-hidden="true"></a><span><span>#define</span> PRIxLEAST256 PRIx256</span></span>
<span id="cb22-34"><a href="#cb22-34" aria-hidden="true"></a><span><span>#define</span> PRIxLEAST32 PRIx32</span></span>
<span id="cb22-35"><a href="#cb22-35" aria-hidden="true"></a><span><span>#define</span> PRIxLEAST64 PRIx64</span></span>
<span id="cb22-36"><a href="#cb22-36" aria-hidden="true"></a><span><span>#define</span> PRIxLEAST8 PRIx8</span></span></code></pre></div>
<p>Similar for <code>scanf</code>:</p>
<div id="cb23"><pre><code><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span><span>#define</span> _SCN(F, N) &#34;w&#34; #N #F</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a><span><span>#define</span> SCNX128 _SCN(X, 128)</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a><span><span>#define</span> SCNX16  _SCN(X, 16)</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a><span><span>#define</span> SCNX256 _SCN(X, 256)</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true"></a><span><span>#define</span> SCNX32  _SCN(X, 32)</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true"></a><span><span>#define</span> SCNX64  _SCN(X, 64)</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true"></a><span><span>#define</span> SCNX8   _SCN(X, 8)</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true"></a><span><span>#define</span> SCNd128 _SCN(d, 128)</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true"></a><span><span>#define</span> SCNd16  _SCN(d, 16)</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true"></a><span><span>#define</span> SCNd256 _SCN(d, 256)</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true"></a><span><span>#define</span> SCNd32  _SCN(d, 32)</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true"></a><span><span>#define</span> SCNd64  _SCN(d, 64)</span></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true"></a><span><span>#define</span> SCNd8   _SCN(d, 8)</span></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true"></a><span><span>#define</span> SCNi128 _SCN(i, 128)</span></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true"></a><span><span>#define</span> SCNi16  _SCN(i, 16)</span></span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true"></a><span><span>#define</span> SCNi256 _SCN(i, 256)</span></span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true"></a><span><span>#define</span> SCNi32  _SCN(i, 32)</span></span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true"></a><span><span>#define</span> SCNi64  _SCN(i, 64)</span></span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true"></a><span><span>#define</span> SCNi8   _SCN(i, 8)</span></span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true"></a><span><span>#define</span> SCNo128 _SCN(o, 128)</span></span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true"></a><span><span>#define</span> SCNo16  _SCN(o, 16)</span></span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true"></a><span><span>#define</span> SCNo256 _SCN(o, 256)</span></span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true"></a><span><span>#define</span> SCNo32  _SCN(o, 32)</span></span>
<span id="cb23-24"><a href="#cb23-24" aria-hidden="true"></a><span><span>#define</span> SCNo64  _SCN(o, 64)</span></span>
<span id="cb23-25"><a href="#cb23-25" aria-hidden="true"></a><span><span>#define</span> SCNo8   _SCN(o, 8)</span></span>
<span id="cb23-26"><a href="#cb23-26" aria-hidden="true"></a><span><span>#define</span> SCNu128 _SCN(u, 128)</span></span>
<span id="cb23-27"><a href="#cb23-27" aria-hidden="true"></a><span><span>#define</span> SCNu16  _SCN(u, 16)</span></span>
<span id="cb23-28"><a href="#cb23-28" aria-hidden="true"></a><span><span>#define</span> SCNu256 _SCN(u, 256)</span></span>
<span id="cb23-29"><a href="#cb23-29" aria-hidden="true"></a><span><span>#define</span> SCNu32  _SCN(u, 32)</span></span>
<span id="cb23-30"><a href="#cb23-30" aria-hidden="true"></a><span><span>#define</span> SCNu64  _SCN(u, 64)</span></span>
<span id="cb23-31"><a href="#cb23-31" aria-hidden="true"></a><span><span>#define</span> SCNu8   _SCN(u, 8)</span></span>
<span id="cb23-32"><a href="#cb23-32" aria-hidden="true"></a><span><span>#define</span> SCNx128 _SCN(x, 128)</span></span>
<span id="cb23-33"><a href="#cb23-33" aria-hidden="true"></a><span><span>#define</span> SCNx16  _SCN(x, 16)</span></span>
<span id="cb23-34"><a href="#cb23-34" aria-hidden="true"></a><span><span>#define</span> SCNx256 _SCN(x, 256)</span></span>
<span id="cb23-35"><a href="#cb23-35" aria-hidden="true"></a><span><span>#define</span> SCNx32  _SCN(x, 32)</span></span>
<span id="cb23-36"><a href="#cb23-36" aria-hidden="true"></a><span><span>#define</span> SCNx64  _SCN(x, 64)</span></span>
<span id="cb23-37"><a href="#cb23-37" aria-hidden="true"></a><span><span>#define</span> SCNx8   _SCN(x, 8)</span></span></code></pre></div>
<div id="cb24"><pre><code><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span><span>#define</span> SCNXLEAST128 SCNX128</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a><span><span>#define</span> SCNXLEAST16 SCNX16</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a><span><span>#define</span> SCNXLEAST256 SCNX256</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a><span><span>#define</span> SCNXLEAST32 SCNX32</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true"></a><span><span>#define</span> SCNXLEAST64 SCNX64</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true"></a><span><span>#define</span> SCNXLEAST8 SCNX8</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true"></a><span><span>#define</span> SCNdLEAST128 SCNd128</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true"></a><span><span>#define</span> SCNdLEAST16 SCNd16</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true"></a><span><span>#define</span> SCNdLEAST256 SCNd256</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true"></a><span><span>#define</span> SCNdLEAST32 SCNd32</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true"></a><span><span>#define</span> SCNdLEAST64 SCNd64</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true"></a><span><span>#define</span> SCNdLEAST8 SCNd8</span></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true"></a><span><span>#define</span> SCNiLEAST128 SCNi128</span></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true"></a><span><span>#define</span> SCNiLEAST16 SCNi16</span></span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true"></a><span><span>#define</span> SCNiLEAST256 SCNi256</span></span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true"></a><span><span>#define</span> SCNiLEAST32 SCNi32</span></span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true"></a><span><span>#define</span> SCNiLEAST64 SCNi64</span></span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true"></a><span><span>#define</span> SCNiLEAST8 SCNi8</span></span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true"></a><span><span>#define</span> SCNoLEAST128 SCNo128</span></span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true"></a><span><span>#define</span> SCNoLEAST16 SCNo16</span></span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true"></a><span><span>#define</span> SCNoLEAST256 SCNo256</span></span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true"></a><span><span>#define</span> SCNoLEAST32 SCNo32</span></span>
<span id="cb24-23"><a href="#cb24-23" aria-hidden="true"></a><span><span>#define</span> SCNoLEAST64 SCNo64</span></span>
<span id="cb24-24"><a href="#cb24-24" aria-hidden="true"></a><span><span>#define</span> SCNoLEAST8 SCNo8</span></span>
<span id="cb24-25"><a href="#cb24-25" aria-hidden="true"></a><span><span>#define</span> SCNuLEAST128 SCNu128</span></span>
<span id="cb24-26"><a href="#cb24-26" aria-hidden="true"></a><span><span>#define</span> SCNuLEAST16 SCNu16</span></span>
<span id="cb24-27"><a href="#cb24-27" aria-hidden="true"></a><span><span>#define</span> SCNuLEAST256 SCNu256</span></span>
<span id="cb24-28"><a href="#cb24-28" aria-hidden="true"></a><span><span>#define</span> SCNuLEAST32 SCNu32</span></span>
<span id="cb24-29"><a href="#cb24-29" aria-hidden="true"></a><span><span>#define</span> SCNuLEAST64 SCNu64</span></span>
<span id="cb24-30"><a href="#cb24-30" aria-hidden="true"></a><span><span>#define</span> SCNuLEAST8 SCNu8</span></span>
<span id="cb24-31"><a href="#cb24-31" aria-hidden="true"></a><span><span>#define</span> SCNxLEAST128 SCNx128</span></span>
<span id="cb24-32"><a href="#cb24-32" aria-hidden="true"></a><span><span>#define</span> SCNxLEAST16 SCNx16</span></span>
<span id="cb24-33"><a href="#cb24-33" aria-hidden="true"></a><span><span>#define</span> SCNxLEAST256 SCNx256</span></span>
<span id="cb24-34"><a href="#cb24-34" aria-hidden="true"></a><span><span>#define</span> SCNxLEAST32 SCNx32</span></span>
<span id="cb24-35"><a href="#cb24-35" aria-hidden="true"></a><span><span>#define</span> SCNxLEAST64 SCNx64</span></span>
<span id="cb24-36"><a href="#cb24-36" aria-hidden="true"></a><span><span>#define</span> SCNxLEAST8 SCNx8</span></span></code></pre></div>
<h4 id="wflength"><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n2680.pdf"><code>wf</code><em>N</em> length modifiers</a></h4>
<p>Where <em>N</em> is any of the values (decimal without leading <code><span>0</span></code>) for all supported fastest minimum-width integer types provided by 7.22.1.3.</p>
<p><strong>ABI choice:</strong> To implement these, it must be known to which size a given width corresponds, this is an ABI decision. For <code><span>8</span></code>, <code><span>16</span></code>, <code><span>32</span></code> and <code><span>64</span></code> the fastest minimum-width integer types are mandatory, so at least these values must be supported.</p>
<ul>
<li><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n2680.pdf">https://open-std.org/JTC1/SC22/WG14/www/docs/n2680.pdf</a></li>
</ul>
<p>For versions of the C library that support these formats (and thus set <code>__STDC_VERSION_STDIO_H__</code>) the macros <code>PRIx</code><em>N</em> etc should use these new length modifiers. This could look something like</p>
<div id="cb25"><pre><code><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a><span><span>#define</span> _PRIFAST(F, N) &#34;wf&#34; #N #F</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a><span><span>#define</span> PRIXFAST128 _PRIFAST(X, 128)</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true"></a><span><span>#define</span> PRIXFAST16  _PRIFAST(X, 16)</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true"></a><span><span>#define</span> PRIXFAST256 _PRIFAST(X, 256)</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true"></a><span><span>#define</span> PRIXFAST32  _PRIFAST(X, 32)</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true"></a><span><span>#define</span> PRIXFAST64  _PRIFAST(X, 64)</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true"></a><span><span>#define</span> PRIXFAST8   _PRIFAST(X, 8)</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true"></a><span><span>#define</span> PRIdFAST128 _PRIFAST(d, 128)</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true"></a><span><span>#define</span> PRIdFAST16  _PRIFAST(d, 16)</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true"></a><span><span>#define</span> PRIdFAST256 _PRIFAST(d, 256)</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true"></a><span><span>#define</span> PRIdFAST32  _PRIFAST(d, 32)</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true"></a><span><span>#define</span> PRIdFAST64  _PRIFAST(d, 64)</span></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true"></a><span><span>#define</span> PRIdFAST8   _PRIFAST(d, 8)</span></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true"></a><span><span>#define</span> PRIiFAST128 _PRIFAST(i, 128)</span></span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true"></a><span><span>#define</span> PRIiFAST16  _PRIFAST(i, 16)</span></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true"></a><span><span>#define</span> PRIiFAST256 _PRIFAST(i, 256)</span></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true"></a><span><span>#define</span> PRIiFAST32  _PRIFAST(i, 32)</span></span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true"></a><span><span>#define</span> PRIiFAST64  _PRIFAST(i, 64)</span></span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true"></a><span><span>#define</span> PRIiFAST8   _PRIFAST(i, 8)</span></span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true"></a><span><span>#define</span> PRIoFAST128 _PRIFAST(o, 128)</span></span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true"></a><span><span>#define</span> PRIoFAST16  _PRIFAST(o, 16)</span></span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true"></a><span><span>#define</span> PRIoFAST256 _PRIFAST(o, 256)</span></span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true"></a><span><span>#define</span> PRIoFAST32  _PRIFAST(o, 32)</span></span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true"></a><span><span>#define</span> PRIoFAST64  _PRIFAST(o, 64)</span></span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true"></a><span><span>#define</span> PRIoFAST8   _PRIFAST(o, 8)</span></span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true"></a><span><span>#define</span> PRIuFAST128 _PRIFAST(u, 128)</span></span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true"></a><span><span>#define</span> PRIuFAST16  _PRIFAST(u, 16)</span></span>
<span id="cb25-28"><a href="#cb25-28" aria-hidden="true"></a><span><span>#define</span> PRIuFAST256 _PRIFAST(u, 256)</span></span>
<span id="cb25-29"><a href="#cb25-29" aria-hidden="true"></a><span><span>#define</span> PRIuFAST32  _PRIFAST(u, 32)</span></span>
<span id="cb25-30"><a href="#cb25-30" aria-hidden="true"></a><span><span>#define</span> PRIuFAST64  _PRIFAST(u, 64)</span></span>
<span id="cb25-31"><a href="#cb25-31" aria-hidden="true"></a><span><span>#define</span> PRIuFAST8   _PRIFAST(u, 8)</span></span>
<span id="cb25-32"><a href="#cb25-32" aria-hidden="true"></a><span><span>#define</span> PRIxFAST128 _PRIFAST(x, 128)</span></span>
<span id="cb25-33"><a href="#cb25-33" aria-hidden="true"></a><span><span>#define</span> PRIxFAST16  _PRIFAST(x, 16)</span></span>
<span id="cb25-34"><a href="#cb25-34" aria-hidden="true"></a><span><span>#define</span> PRIxFAST256 _PRIFAST(x, 256)</span></span>
<span id="cb25-35"><a href="#cb25-35" aria-hidden="true"></a><span><span>#define</span> PRIxFAST32  _PRIFAST(x, 32)</span></span>
<span id="cb25-36"><a href="#cb25-36" aria-hidden="true"></a><span><span>#define</span> PRIxFAST64  _PRIFAST(x, 64)</span></span>
<span id="cb25-37"><a href="#cb25-37" aria-hidden="true"></a><span><span>#define</span> PRIxFAST8   _PRIFAST(x, 8)</span></span></code></pre></div>
<p>Similar for <code>scanf</code>:</p>
<div id="cb26"><pre><code><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a><span><span>#define</span> _SCNFAST(F, N) &#34;wf&#34; #N #F</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a><span><span>#define</span> SCNXFAST128 _SCNFAST(X, 128)</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true"></a><span><span>#define</span> SCNXFAST16  _SCNFAST(X, 16)</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true"></a><span><span>#define</span> SCNXFAST256 _SCNFAST(X, 256)</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true"></a><span><span>#define</span> SCNXFAST32  _SCNFAST(X, 32)</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true"></a><span><span>#define</span> SCNXFAST64  _SCNFAST(X, 64)</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true"></a><span><span>#define</span> SCNXFAST8   _SCNFAST(X, 8)</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true"></a><span><span>#define</span> SCNdFAST128 _SCNFAST(d, 128)</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true"></a><span><span>#define</span> SCNdFAST16  _SCNFAST(d, 16)</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true"></a><span><span>#define</span> SCNdFAST256 _SCNFAST(d, 256)</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true"></a><span><span>#define</span> SCNdFAST32  _SCNFAST(d, 32)</span></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true"></a><span><span>#define</span> SCNdFAST64  _SCNFAST(d, 64)</span></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true"></a><span><span>#define</span> SCNdFAST8   _SCNFAST(d, 8)</span></span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true"></a><span><span>#define</span> SCNiFAST128 _SCNFAST(i, 128)</span></span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true"></a><span><span>#define</span> SCNiFAST16  _SCNFAST(i, 16)</span></span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true"></a><span><span>#define</span> SCNiFAST256 _SCNFAST(i, 256)</span></span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true"></a><span><span>#define</span> SCNiFAST32  _SCNFAST(i, 32)</span></span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true"></a><span><span>#define</span> SCNiFAST64  _SCNFAST(i, 64)</span></span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true"></a><span><span>#define</span> SCNiFAST8   _SCNFAST(i, 8)</span></span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true"></a><span><span>#define</span> SCNoFAST128 _SCNFAST(o, 128)</span></span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true"></a><span><span>#define</span> SCNoFAST16  _SCNFAST(o, 16)</span></span>
<span id="cb26-22"><a href="#cb26-22" aria-hidden="true"></a><span><span>#define</span> SCNoFAST256 _SCNFAST(o, 256)</span></span>
<span id="cb26-23"><a href="#cb26-23" aria-hidden="true"></a><span><span>#define</span> SCNoFAST32  _SCNFAST(o, 32)</span></span>
<span id="cb26-24"><a href="#cb26-24" aria-hidden="true"></a><span><span>#define</span> SCNoFAST64  _SCNFAST(o, 64)</span></span>
<span id="cb26-25"><a href="#cb26-25" aria-hidden="true"></a><span><span>#define</span> SCNoFAST8   _SCNFAST(o, 8)</span></span>
<span id="cb26-26"><a href="#cb26-26" aria-hidden="true"></a><span><span>#define</span> SCNuFAST128 _SCNFAST(u, 128)</span></span>
<span id="cb26-27"><a href="#cb26-27" aria-hidden="true"></a><span><span>#define</span> SCNuFAST16  _SCNFAST(u, 16)</span></span>
<span id="cb26-28"><a href="#cb26-28" aria-hidden="true"></a><span><span>#define</span> SCNuFAST256 _SCNFAST(u, 256)</span></span>
<span id="cb26-29"><a href="#cb26-29" aria-hidden="true"></a><span><span>#define</span> SCNuFAST32  _SCNFAST(u, 32)</span></span>
<span id="cb26-30"><a href="#cb26-30" aria-hidden="true"></a><span><span>#define</span> SCNuFAST64  _SCNFAST(u, 64)</span></span>
<span id="cb26-31"><a href="#cb26-31" aria-hidden="true"></a><span><span>#define</span> SCNuFAST8   _SCNFAST(u, 8)</span></span>
<span id="cb26-32"><a href="#cb26-32" aria-hidden="true"></a><span><span>#define</span> SCNxFAST128 _SCNFAST(x, 128)</span></span>
<span id="cb26-33"><a href="#cb26-33" aria-hidden="true"></a><span><span>#define</span> SCNxFAST16  _SCNFAST(x, 16)</span></span>
<span id="cb26-34"><a href="#cb26-34" aria-hidden="true"></a><span><span>#define</span> SCNxFAST256 _SCNFAST(x, 256)</span></span>
<span id="cb26-35"><a href="#cb26-35" aria-hidden="true"></a><span><span>#define</span> SCNxFAST32  _SCNFAST(x, 32)</span></span>
<span id="cb26-36"><a href="#cb26-36" aria-hidden="true"></a><span><span>#define</span> SCNxFAST64  _SCNFAST(x, 64)</span></span>
<span id="cb26-37"><a href="#cb26-37" aria-hidden="true"></a><span><span>#define</span> SCNxFAST8   _SCNFAST(x, 8)</span></span></code></pre></div>
<h4 id="h-d-and-dd-length-modifiers-for-decimal-floating-point"><code>H</code>, <code>D</code> and <code>DD</code> length modifiers for decimal floating point</h4>
<p>For <code><span>_Decimal32</span></code>, <code><span>_Decimal64</span></code> and <code><span>_Decimal128</span></code>. This is optional depending on support for decimal floating point. Implementation should not be too difficult. In particular these new number types have prescribed representation formats (2 possible choices and endianess), so implementation should even be possible without support for these types on the compilation platform of the C library.</p>
<p><strong>Compiler dependency:</strong> Support for this is important such that the rest of any library support for decimal floating point can be added by an independent library.</p>
<h2 id="stdlib">Changes to <code><span>&lt;</span>stdlib<span>.</span>h<span>&gt;</span></code></h2>
<h3 id="stdc_version_stdlib_h__"><code>__STDC_VERSION_STDLIB_H__</code></h3>
<p>This macro is mandatory and should be set to <code><span>202311</span><span>L</span></code> once the header is compliant to C23.</p>
<h3 id="strtol"><code>strtol</code> and friends</h3>
<p>With base <code><span>0</span></code> or <code><span>2</span></code>, these functions now accept the new binary integer constants. When used with the optional the prefixes <code><span>0b</span></code> or <code><span>0B</span></code>, <strong>this is a semantic change:</strong> for example the following code</p>
<div id="cb27"><pre><code><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a><span>long</span> res <span>=</span> strtol<span>(</span><span>&#34;0b1&#34;</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>);</span></span></code></pre></div>
<p>has <code>res ≡ <span>0</span></code> for C17 and <code>res ≡ <span>1</span></code> for C23. This is because for the first the interpretation stops before the <code>b</code>.</p>
<p>C library implementations that want to support previous versions of C, have to take care of that semantic change. Therefore they probably have to have two functions for each of the interfaces</p>
<div id="cb28"><pre><code><span id="cb28-1"><a href="#cb28-1" aria-hidden="true"></a><span>// don&#39;t recognize 0xb or 0xB for base 0 or 2</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true"></a><span>long</span> <span>int</span> strtol_c17<span>(</span><span>const</span> <span>char</span> <span>*</span><span>restrict</span> nptr<span>,</span> <span>char</span> <span>**</span><span>restrict</span> endptr<span>,</span> <span>int</span> base<span>);</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true"></a><span>long</span> <span>long</span> <span>int</span> strtoll_c17<span>(</span><span>const</span> <span>char</span> <span>*</span><span>restrict</span> nptr<span>,</span> <span>char</span> <span>**</span><span>restrict</span> endptr<span>,</span> <span>int</span> base<span>);</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true"></a><span>unsigned</span> <span>long</span> <span>int</span> strtoul_c17<span>(</span><span>const</span> <span>char</span> <span>*</span><span>restrict</span> nptr<span>,</span> <span>char</span> <span>**</span><span>restrict</span> endptr<span>,</span> <span>int</span> base<span>);</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true"></a><span>unsigned</span> <span>long</span> <span>long</span> <span>int</span> strtoull_c17<span>(</span><span>const</span> <span>char</span> <span>*</span><span>restrict</span> nptr<span>,</span> <span>char</span> <span>**</span><span>restrict</span> endptr<span>,</span> <span>int</span> base<span>);</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true"></a></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true"></a><span>// recognize 0xb or 0xB for base 0 or 2</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true"></a><span>long</span> <span>int</span> strtol_c23<span>(</span><span>const</span> <span>char</span> <span>*</span><span>restrict</span> nptr<span>,</span> <span>char</span> <span>**</span><span>restrict</span> endptr<span>,</span> <span>int</span> base<span>);</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true"></a><span>long</span> <span>long</span> <span>int</span> strtoll_c23<span>(</span><span>const</span> <span>char</span> <span>*</span><span>restrict</span> nptr<span>,</span> <span>char</span> <span>**</span><span>restrict</span> endptr<span>,</span> <span>int</span> base<span>);</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true"></a><span>unsigned</span> <span>long</span> <span>int</span> strtoul_c23<span>(</span><span>const</span> <span>char</span> <span>*</span><span>restrict</span> nptr<span>,</span> <span>char</span> <span>**</span><span>restrict</span> endptr<span>,</span> <span>int</span> base<span>);</span></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true"></a><span>unsigned</span> <span>long</span> <span>long</span> <span>int</span> strtoull_c23<span>(</span><span>const</span> <span>char</span> <span>*</span><span>restrict</span> nptr<span>,</span> <span>char</span> <span>**</span><span>restrict</span> endptr<span>,</span> <span>int</span> base<span>);</span></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true"></a></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true"></a><span><span>#if</span> __STDC_VERSION__ &gt;= 202311L</span></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true"></a><span><span>#define</span> strtol   strtol_c23</span></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true"></a><span><span>#define</span> strtoll  strtoll_c23</span></span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true"></a><span><span>#define</span> strtoul  strtoul_c23</span></span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true"></a><span><span>#define</span> strtoull strtoull_c23</span></span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true"></a><span><span>#else</span></span></span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true"></a><span><span>#define</span> strtol   strtol_c17</span></span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true"></a><span><span>#define</span> strtoll  strtoll_c17</span></span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true"></a><span><span>#define</span> strtoul  strtoul_c17</span></span>
<span id="cb28-22"><a href="#cb28-22" aria-hidden="true"></a><span><span>#define</span> strtoull strtoull_c17</span></span>
<span id="cb28-23"><a href="#cb28-23" aria-hidden="true"></a><span><span>#endif</span></span></span></code></pre></div>
<p><strong>Not yet stable?</strong> It is possible that there will be an NB comment for this and that this interface might still change, e.g by adding <code><span>[[</span><span>deprecated</span><span>]]</span></code> to the existing interfaces and by creating new interfaces with prefix <code>stdc_</code>.</p>
<h3 id="alignment-requirements-for-memory-management-functions">Alignment requirements for memory management functions</h3>
<p>These were reformulated for C23. Implementations that set <code>__STDC_VERSION_STDLIB_H__</code> have to verify that they conform to that reformulation, see</p>
<ul>
<li><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n2293.htm">https://open-std.org/JTC1/SC22/WG14/www/docs/n2293.htm</a></li>
</ul>
<h3 id="calloc-overflow"><code>calloc</code> overflow</h3>
<p>Implementations that set <code>__STDC_VERSION_STDLIB_H__</code> have to verify that they conform to 7.24.3.2 p3:</p>
<blockquote>
<p>The <code>calloc</code> function returns either a pointer to the allocated space or a null pointer if the space cannot be allocated or if the product <code>nmemb <span>*</span> size</code> would wraparound <code><span>size_t</span></code>.</p>
</blockquote>
<h3 id="bsearch"><code>bsearch</code> becomes a <code><span>const</span></code>-preserving tg macro</h3>
<p>This is specified as</p>
<div id="cb29"><pre><code><span id="cb29-1"><a href="#cb29-1" aria-hidden="true"></a>QVoid <span>*</span>bsearch<span>(</span><span>const</span> <span>void</span> <span>*,</span> QVoid<span>*,</span> <span>size_t</span> nmemb<span>,</span> <span>size_t</span> size<span>,</span> <span>int</span> <span>(*)(</span><span>const</span> <span>void</span><span>*,</span> <span>const</span> <span>void</span><span>*));</span></span></code></pre></div>
<p>to emphasize that the return is exactly the same <code><span>void</span></code> pointer type as the argument. <code><span>volatile</span></code> or <code><span>restrict</span></code> types are not accepted.</p>
<p>An implementation of this type-generic macro could look as follows.</p>
<div id="cb30"><pre><code><span id="cb30-1"><a href="#cb30-1" aria-hidden="true"></a><span>// The function itself stays exactly the same.</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true"></a><span>void</span><span>*</span> <span>(</span>bsearch<span>)(</span><span>const</span> <span>void</span><span>*,</span> <span>const</span> <span>void</span><span>*,</span> <span>size_t</span><span>,</span> <span>size_t</span><span>,</span> <span>int</span><span>(*)(</span><span>const</span> <span>void</span><span>*,</span> <span>const</span> <span>void</span><span>*));</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true"></a><span><span>#if</span> __STDC_VERSION__ &gt; 202300L</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true"></a><span><span># define</span> bsearch(K, B, N, S, C)                                                  \</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true"></a><span>    _Generic(                                                                    \</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true"></a><span>        /* ensure conversion to a void pointer */                                \</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true"></a><span>        true ? (B) : (void*)1,                                                   \</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true"></a><span>        void const*: (void const*)bsearch((K), (void const*)(B), (N), (S), (C)), \</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true"></a><span>        /* volatile qualification of *B is an error for this call */             \</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true"></a><span>        default:     bsearch((K), (B), (N), (S), (C))                            \</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true"></a><span>)</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true"></a><span><span>#endif</span></span></span></code></pre></div>
<p>A preprocessor conditional is needed, because the type of call expressions potentially changes with this.</p>
<p>User code that misused these calls and stored the result for a call with a <code><span>const</span></code> qualified array in a pointer with unqualified target type may see their code diagnosed or even rejected. This is intentional.</p>
<h3 id="add-once_flag-and-call_once-also-to-stdlib.h">Add <code><span>once_flag</span></code> and <code>call_once</code> also to <code><span>&lt;</span>stdlib<span>.</span>h<span>&gt;</span></code></h3>
<p>This type and function now become mandatory for C23.</p>
<p>Similar to <code><span>size_t</span></code> it can appear in several headers. Something along the lines of should be added to <code><span>&lt;</span>stdlib<span>.</span>h<span>&gt;</span></code></p>
<div id="cb31"><pre><code><span id="cb31-1"><a href="#cb31-1" aria-hidden="true"></a><span><span>#if</span> (__STDC_VERSION__ &gt;= 201311L) &amp;&amp; !defined(ONCE_FLAG_INIT)</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true"></a><span>typedef</span> <span>int</span> <span>once_flag</span><span>;</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true"></a><span><span>#define</span> ONCE_FLAG_INIT 0</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true"></a><span>void</span> call_once<span>(</span><span>once_flag</span><span>*,</span> <span>void</span> <span>(*)(</span><span>void</span><span>));</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true"></a><span><span>#endif</span></span></span></code></pre></div>
<p>A protection by a preprocessor conditional is not strictly necessary because these names are otherwise only potentially reserved, so adding them to a C library is always possible without impeding on the user identifier space.</p>
<p>A rationale for introducing this feature to the general C library and reference implementations for C libraries that might not have that feature, yet, because they don’t support threads can be found in</p>
<blockquote>
<blockquote>
<p><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n2840.htm">https://open-std.org/JTC1/SC22/WG14/www/docs/n2840.htm</a></p>
</blockquote>
</blockquote>
<p>Implementations that know how to avoid to link against the whole threads and atomic options could have an alternative version of this function</p>
<div id="cb32"><pre><code><span id="cb32-1"><a href="#cb32-1" aria-hidden="true"></a><span>typedef</span> <span>int</span> <span>volatile</span> <span>once_flag</span><span>;</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true"></a><span><span>#define</span> ONCE_FLAG_INIT 0</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true"></a><span>void</span> call_once<span>(</span><span>once_flag</span><span>*</span> flag<span>,</span> <span>void</span> <span>(*</span>func<span>)(</span><span>void</span><span>))</span> <span>{</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true"></a>    <span>if</span> <span>(!*</span>flag<span>)</span> <span>{</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true"></a>        func<span>();</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true"></a>        <span>*</span>flag <span>=</span> <span>1</span><span>;</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true"></a>    <span>}</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true"></a><span>}</span></span></code></pre></div>
<p>In this case, the necessary synchronization guarantees are given, because the call to the function and the assignment to <code>flag</code> are sequenced and cannot be optimized away. Note that this version is not guaranteed to be asynchronous signal safe: not even the type <code><span>sig_atomic_t</span></code> does not give the guarantees that are needed for implementing this function. Only an implementation with lock-free require-release atomics (or similar) could be asynchronous signal safe.</p>
<h2 id="time">Changes to <code><span>&lt;</span>time<span>.</span>h<span>&gt;</span></code></h2>
<h3 id="stdc_version_time_h__"><code>__STDC_VERSION_TIME_H__</code></h3>
<p>This macro is mandatory and should be set to <code><span>202311</span><span>L</span></code> once the header is compliant to C23.</p>
<h3 id="strftime-and-wcsftime"><code>strftime</code> and <code>wcsftime</code></h3>
<p>Two new <code>O</code> modified specifications are added to <code>strftime</code> and <code>wcsftime</code>:</p>
<blockquote>
<p><code><span>%</span>Ob</code> is replaced by the locale’s abbreviated alternative month name.</p>
</blockquote>
<blockquote>
<p><code><span>%</span>OB</code> is replaced by the locale’s alternative appropriate full month name.</p>
</blockquote>
<p>These have also been accepted for POSIX.</p>
<p>The C standard says nothing about erroneous specifications or some that would be implementation-defined extensions, so using new specifiers is just undefined for pre-C23. Therefore these can be added to any implementation without making it non-conforming for any C version.</p>
<p>On the other hand, <code>__STDC_VERSION_TIME_H__</code> should only be taken to <code><span>202311</span><span>L</span></code> once this addition is implemented.</p>
<h3 id="asctime">Deprecation of <code>asctime</code> and <code>ctime</code></h3>
<p>C23 follows POSIX in deprecating these functions. Their interfaces now have the corresponding attribute:</p>
<div id="cb33"><pre><code><span id="cb33-1"><a href="#cb33-1" aria-hidden="true"></a><span><span>#if</span> __STDC_VERSION__ &gt; 202300L</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true"></a><span>[[</span><span>deprecated</span><span>]]</span> <span>char</span> <span>*</span>asctime<span>(</span><span>const</span> <span>struct</span> tm <span>*</span>timeptr<span>);</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true"></a><span>[[</span><span>deprecated</span><span>]]</span> <span>char</span> <span>*</span>ctime<span>(</span><span>const</span> <span>time_t</span> <span>*</span>timer<span>);</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true"></a><span><span>#else</span></span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true"></a><span>char</span> <span>*</span>asctime<span>(</span><span>const</span> <span>struct</span> tm <span>*</span>timeptr<span>);</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true"></a><span>char</span> <span>*</span>ctime<span>(</span><span>const</span> <span>time_t</span> <span>*</span>timer<span>);</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true"></a><span><span>#endif</span></span></span></code></pre></div>
<p>A preprocessor conditional is needed, because the attribute syntax is new for C23.</p>
<h3 id="gmtime_r-and-localtime_r"><code>gmtime_r</code> and <code>localtime_r</code></h3>
<p>C23 inherits these two interfaces from POSIX. C libraries that implement POSIX can simply expose them to C23 aware code by something similar to</p>
<div id="cb34"><pre><code><span id="cb34-1"><a href="#cb34-1" aria-hidden="true"></a><span><span>#if</span> __STDC_VERSION__ &gt; 202300L</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true"></a><span>struct</span> tm <span>*</span>gmtime_r<span>(</span><span>const</span> <span>time_t</span><span>*,</span> <span>struct</span> tm<span>*);</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true"></a><span>struct</span> tm <span>*</span>localtime_r<span>(</span><span>const</span> <span>time_t</span><span>*,</span> <span>struct</span> tm<span>*);</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true"></a><span><span>#endif</span></span></span></code></pre></div>
<p>A preprocessor conditional is needed, because the names had not been reserved before C23.</p>
<h3 id="timegm"><code>timegm</code></h3>
<p>The <code>timegm</code> function from BSD is added. Specifications can be found here.</p>
<p><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n2833.htm">https://open-std.org/JTC1/SC22/WG14/www/docs/n2833.htm</a></p>
<p>A preprocessor conditional is needed, because the name had not been reserved before C23.</p>
<div id="cb35"><pre><code><span id="cb35-1"><a href="#cb35-1" aria-hidden="true"></a><span><span>#if</span> __STDC_VERSION__ &gt; 202300L</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true"></a><span>time_t</span> timegm<span>(</span><span>struct</span> tm <span>*);</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true"></a><span><span>#endif</span></span></span></code></pre></div>
<h3 id="timespec_getres"><code>timespec_getres</code></h3>
<p>This function is meant to port POSIX’ <code>clock_getres</code> to C by translating <code>base</code> to the equivalent POSIX clock:</p>
<div id="cb36"><pre><code><span id="cb36-1"><a href="#cb36-1" aria-hidden="true"></a><span><span>#if</span> __STDC_VERSION__ &gt; 202300L</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true"></a><span>int</span> timespec_getres<span>(</span><span>struct</span> timespec<span>*,</span> <span>int</span><span>);</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true"></a><span><span>#endif</span></span></span></code></pre></div>
<p>A preprocessor conditional is needed, because the name had not been reserved before C23.</p>
<h3 id="time_monotonic-time_active-time_thread_active"><code>TIME_MONOTONIC</code>, <code>TIME_ACTIVE</code>, <code>TIME_THREAD_ACTIVE</code></h3>
<p>C23 adds three <em>optional</em> time bases <code>TIME_MONOTONIC</code>, <code>TIME_ACTIVE</code> and <code>TIME_THREAD_ACTIVE</code> which are modeled after the POSIX clocks <code>CLOCK_MONOTONIC</code>, <code>CLOCK_PROCESS_CPUTIME_ID</code> and <code>CLOCK_THREAD_CPUTIME_ID</code>, respectively.</p>
<p>Having time bases for C other than <code>TIME_UTC</code> is at the liberty of the implementation, so any C library that runs on a POSIX system could easily provide the equivalent to all POSIX clocks that it interfaces. For example, for Linux currently these are</p>
<div id="cb37"><pre><code><span id="cb37-1"><a href="#cb37-1" aria-hidden="true"></a><span><span>#define</span> CLOCK_REALTIME           0</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true"></a><span><span>#define</span> CLOCK_MONOTONIC          1</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true"></a><span><span>#define</span> CLOCK_PROCESS_CPUTIME_ID 2</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true"></a><span><span>#define</span> CLOCK_THREAD_CPUTIME_ID  3</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true"></a><span><span>#define</span> CLOCK_MONOTONIC_RAW      4</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true"></a><span><span>#define</span> CLOCK_REALTIME_COARSE    5</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true"></a><span><span>#define</span> CLOCK_MONOTONIC_COARSE   6</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true"></a><span><span>#define</span> CLOCK_BOOTTIME           7</span></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true"></a><span><span>#define</span> CLOCK_REALTIME_ALARM     8</span></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true"></a><span><span>#define</span> CLOCK_BOOTTIME_ALARM     9</span></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true"></a><span><span>#define</span> CLOCK_SGI_CYCLE         10</span></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true"></a><span><span>#define</span> CLOCK_TAI               11</span></span></code></pre></div>
<p>This could easily be done by using something as</p>
<div id="cb38"><pre><code><span id="cb38-1"><a href="#cb38-1" aria-hidden="true"></a><span><span>#define</span> TIME_UTC              (CLOCK_REALTIME+1)</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true"></a><span><span>#define</span> TIME_MONOTONIC        (CLOCK_MONOTONIC+1)</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true"></a><span><span>#define</span> TIME_ACTIVE           (CLOCK_PROCESS_CPUTIME_ID+1)</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true"></a><span><span>#define</span> TIME_THREAD_ACTIVE    (CLOCK_THREAD_CPUTIME_ID+1)</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true"></a><span><span>#define</span> TIME_MONOTONIC_RAW    (CLOCK_MONOTONIC_RAW+1)</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true"></a><span><span>#define</span> TIME_UTC_COARSE       (CLOCK_REALTIME_COARSE+1)</span></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true"></a><span><span>#define</span> TIME_MONOTONIC_COARSE (CLOCK_MONOTONIC_COARSE+1)</span></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true"></a><span><span>#define</span> TIME_BOOTTIME         (CLOCK_BOOTTIME+1)</span></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true"></a><span><span>#define</span> TIME_UTC_ALARM        (CLOCK_REALTIME_ALARM+1)</span></span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true"></a><span><span>#define</span> TIME_BOOTTIME_ALARM   (CLOCK_BOOTTIME_ALARM+1)</span></span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true"></a><span><span>#define</span> TIME_SGI_CYCLE        (CLOCK_SGI_CYCLE+1)</span></span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true"></a><span><span>#define</span> TIME_TAI              (CLOCK_TAI+1)</span></span></code></pre></div>
<p>and then adapting the corresponding implementation of <code>timespec_get</code> a bit. This would be conforming to current and future C, because the <code>TIME_</code> prefix is already reserved for that purpose.</p>
<p><strong>ABI choice:</strong> Unfortunately the choice of the values is an ABI choice, so before doing so it has to be ensured that other C libraries on the same platform use the same values.</p>
<h2 id="string">Changes to <code><span>&lt;</span>string<span>.</span>h<span>&gt;</span></code></h2>
<h3 id="stdc_version_string_h__"><code>__STDC_VERSION_STRING_H__</code></h3>
<p>This macro is mandatory and should be set to <code><span>202311</span><span>L</span></code> once the header is compliant to C23.</p>
<h3 id="memccpy-strdup-and-strndup"><code>memccpy</code>, <code>strdup</code> and <code>strndup</code></h3>
<p>C23 borrows these interfaces from POSIX</p>
<div id="cb39"><pre><code><span id="cb39-1"><a href="#cb39-1" aria-hidden="true"></a><span>void</span><span>*</span> memccpy<span>(</span><span>void</span><span>*,</span> <span>const</span> <span>void</span><span>*,</span> <span>int</span><span>,</span> <span>size_t</span><span>);</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true"></a><span>char</span><span>*</span> strdup<span>(</span><span>const</span> <span>char</span><span>*);</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true"></a><span>char</span><span>*</span> strndup<span>(</span><span>const</span> <span>char</span><span>*,</span> <span>size_t</span><span>);</span></span></code></pre></div>
<p>A preprocessor conditional is not needed, because the names (with prefixes <code>mem</code> and <code>str</code>) had been reserved before C23.</p>
<h3 id="memset_explicit"><code>memset_explicit</code></h3>
<p>The following function is added with the same normative specification as <code>memset</code>:</p>
<div id="cb40"><pre><code><span id="cb40-1"><a href="#cb40-1" aria-hidden="true"></a><span>void</span><span>*</span> memset_explicit<span>(</span><span>void</span><span>*,</span> <span>int</span><span>,</span> <span>size_t</span><span>);</span></span></code></pre></div>
<p>The difference to that is in expectation. In the description</p>
<blockquote>
<p>The purpose of this function is to make sensitive information stored in the object inaccessible<sup>379)</sup>.</p>
</blockquote>
<p>And with the following text in the footnote.</p>
<blockquote>
<p>The intention is that the memory store is always performed (i.e., never elided), regardless of optimizations.</p>
</blockquote>
<p>There has been long and heated debate in WG14 and WG21 about this, and this is the best that we came up with. The standard does not have the language to describe that memory that is e.g freed has to be zeroed out when given back to the system; such a feature is not observable from within the program.</p>
<p>So this puts the responsibility for the intended purpose (hiding information from one part of the execution to other parts and to the outer world) entirely a point of “quality of implementation”. Implementations should take care:</p>
<ul>
<li>A call to this function should never be optimized out. This can often be achieved by having it in a separate TU from all other functions and by disabling link-time optimization for this TU or at least for this function.</li>
<li>No store to any byte of the function should be optimized out.</li>
<li>The return of the function should synchronize with all read and write operations. This could for example be achieved by issuing a call <code>atomic_signal_fence<span>(</span>memory_order_seq_cst<span>)</span></code> or equivalent, such that even a signal that kicks in right after the call could not not read the previous contents of the byte array.</li>
<li>All caches for the byte array should have been invalidated on return.</li>
<li>To avoid side-channel attacks, the implementation of the function should make no explicit or implicit reference to the contents of the byte array nor the value that has been chosen for the overwrite. Each write operation should use the same time (and other resources) per byte.</li>
<li>Good performance is not expected, security first.</li>
</ul>
<p>A preprocessor conditional is not needed, because the name (with prefix <code>mem</code>) had been reserved before C23.</p>
<h3 id="memchr"><code>memchr</code>, <code>strchr</code>, <code>strpbrk</code>, <code>strrchr</code> and <code>strstr</code> become <code><span>const</span></code>-preserving tg macros</h3>
<p>For example for <code>memchr</code> this is specified as</p>
<div id="cb41"><pre><code><span id="cb41-1"><a href="#cb41-1" aria-hidden="true"></a>QVoid<span>*</span> memchr<span>(</span>QVoid<span>*,</span> <span>int</span><span>,</span> <span>size_t</span><span>);</span></span></code></pre></div>
<p>to emphasize that the return is exactly the same <code><span>void</span></code> pointer type as the argument. <code><span>volatile</span></code> or <code><span>restrict</span></code> types are not accepted.</p>
<p>An implementation of this type-generic macro could look as follows.</p>
<div id="cb42"><pre><code><span id="cb42-1"><a href="#cb42-1" aria-hidden="true"></a><span>// The function itself stays exactly the same.</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true"></a><span>void</span><span>*</span> <span>(</span>memchr<span>)(</span><span>void</span> <span>const</span><span>*,</span> <span>int</span><span>,</span> <span>size_t</span><span>);</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true"></a><span><span>#if</span> __STDC_VERSION__ &gt; 202300L</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true"></a><span><span># define</span> memchr(S, C, N)                                              \</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true"></a><span>    _Generic(                                                         \</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true"></a><span>        /* ensure conversion to a void pointer */                     \</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true"></a><span>        true ? (S) : (void*)1,                                        \</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true"></a><span>        void const*: (void const*)memchr((void const*)(S), (C), (N)), \</span></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true"></a><span>        /* volatile qualification is an error for this call */        \</span></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true"></a><span>        default:     memchr((S), (C), (N))                            \</span></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true"></a><span>)</span></span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true"></a><span><span>#endif</span></span></span></code></pre></div>
<p>A preprocessor conditional is needed, because the type of call expressions potentially changes with this.</p>
<p>User code that misused these calls and stored the result for a call with a <code><span>const</span></code> qualified array in a pointer with unqualified target type may see their code diagnosed or even rejected. This is intentional.</p>
<h2 id="uchar">Changes to <code><span>&lt;</span>uchar<span>.</span>h<span>&gt;</span></code></h2>
<p>The required Unicode support has been straightened out and complemented. The types <code><span>char</span></code><em>N</em><code>_t</code> now are designated for <code>UTF<span>-</span></code><em>N</em> encoding without exception. For <em>N</em> 16 or 32 there should not be much changes to existing C libraries: WG14 found none for which the previously optional macros <code>__STDC_UTF_16__</code> and <code>__STDC_UTF_32__</code> had not been set.</p>
<p>Also, see the discussion about thread safety <a href="#threads">above</a>.</p>
<h3 id="stdc_version_uchar_h__"><code>__STDC_VERSION_UCHAR_H__</code></h3>
<p>This macro is mandatory and should be set to <code><span>202311</span><span>L</span></code> once the header is compliant to C23.</p>
<h3 id="conversion-functions-and-type-for-utf-8">Conversion functions and type for UTF-8</h3>
<p>The set of conversion functions from and to UTF encodings is completed by adding functions for UTF-8. For implementations that have UTF-8 as internal representation, anyhow, these functions are almost no-opts; they just have to iterate through the character sequence that composes the multi-byte character in UTF-8 encoding.</p>
<div id="cb43"><pre><code><span id="cb43-1"><a href="#cb43-1" aria-hidden="true"></a><span><span>#if</span> __STDC_VERSION__ &gt;= 202300L</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true"></a><span>typedef</span> <span>unsigned</span> <span>char</span> <span>char8_t</span><span>;</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true"></a><span>size_t</span> mbrtoc8<span>(</span><span>char8_t</span> <span>*</span> <span>restrict</span> pc8<span>,</span> <span>const</span> <span>char</span> <span>*</span> <span>restrict</span> s<span>,</span> <span>size_t</span> n<span>,</span> <span>mbstate_t</span> <span>*</span> <span>restrict</span> ps<span>);</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true"></a>size t c8rtomb<span>(</span><span>char</span> <span>*</span> <span>restrict</span> s<span>,</span> <span>char8_t</span> c8<span>,</span> <span>mbstate_t</span> <span>*</span> <span>restrict</span> ps<span>);</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true"></a><span><span>#endif</span></span></span></code></pre></div>
<p>The preprocessor conditional is needed, because the names had not been previously reserved.</p>
<h2 id="wchar">Changes to <code><span>&lt;</span>wchar<span>.</span>h<span>&gt;</span></code></h2>
<h3 id="stdc_version_wchar_h__"><code>__STDC_VERSION_WCHAR_H__</code></h3>
<p>This macro is mandatory and should be set to <code><span>202311</span><span>L</span></code> once the header is compliant to C23.</p>
<h3 id="wcschr-wcspbrk-wcsrchr-wcsstr-and-wmemchr-become-const-preserving-tg-macros"><code>wcschr</code>, <code>wcspbrk</code>, <code>wcsrchr</code>, <code>wcsstr</code> and <code>wmemchr</code> become <code><span>const</span></code>-preserving tg macros</h3>
<p>Similar to <a href="#memchr"><code>memchr</code></a> and similar, above.</p>
<h2 id="changes-in-annex-k">Changes in Annex K</h2>
<h3 id="bsearch_s"><code>bsearch_s</code></h3>
<p>Similar to <a href="#bsearch"><code>bsearch</code></a>, above.</p>


</div>
  </body>
</html>
