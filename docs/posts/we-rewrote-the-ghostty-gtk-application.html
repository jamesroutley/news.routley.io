<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mitchellh.com/writing/ghostty-gtk-rewrite">Original</a>
    <h1>We rewrote the Ghostty GTK application</h1>
    
    <div id="readability-page-1" class="page"><div><p>We <a target="_blank" rel="noopener noreferrer" href="https://github.com/ghostty-org/ghostty/pull/8235">just completed</a>
rewriting the Ghostty GTK application fully embracing the
<a target="_blank" rel="noopener noreferrer" href="https://docs.gtk.org/gobject/concepts.html">GObject type system</a> from Zig
and also verifying with <a target="_blank" rel="noopener noreferrer" href="https://valgrind.org/">Valgrind</a> every step of the way.
The result is a more feature rich, stable, and maintainable Ghostty
on Linux and BSD.</p>
<p>There are multiple interesting, technical topics from this process, but
I want to focus in on two (1) interfacing with the GObject type system from
Zig and (2) verifying a GTK application with Valgrind and reflecting on the
memory issues Valgrind found in a Zig codebase.</p>
<h2 id="background"><a href="#background" aria-hidden="true" tabindex="-1"><span></span></a>Background</h2>
<p>First, some quick background. Ghostty is a cross-platform (macOS, Linux,
FreeBSD) terminal emulator. Ghostty sets itself apart from other cross-platform
terminal emulators by using a platform-native application or GUI framework
for each platform<sup><a href="#user-content-fn-1" id="user-content-fnref-1" data-footnote-ref="true" aria-describedby="footnote-label">1</a></sup>.</p>
<p>On macOS, Ghostty is a <a target="_blank" rel="noopener noreferrer" href="https://github.com/ghostty-org/ghostty/tree/main/macos">multi-thousand line Swift application</a>
built with Xcode.
On Linux and BSD, Ghostty is a
<a target="_blank" rel="noopener noreferrer" href="https://github.com/ghostty-org/ghostty/tree/b7913f09ad5326331192a24af53473ec541bf1af/src/apprt/gtk-ng">multi-thousand line GTK application</a>
leveraging direct integrations with
<a target="_blank" rel="noopener noreferrer" href="https://github.com/ghostty-org/ghostty/blob/main/src/apprt/gtk-ng/winproto/x11.zig">X11</a>,
<a target="_blank" rel="noopener noreferrer" href="https://github.com/ghostty-org/ghostty/blob/main/src/apprt/gtk-ng/winproto/wayland.zig">Wayland</a>, etc.
Tying it all together, there is a
<a target="_blank" rel="noopener noreferrer" href="https://github.com/ghostty-org/ghostty/tree/main/src">very large shared core written in Zig</a>
that exports a C ABI compatible API.</p>
<p>For full motivation on why Ghostty was the way it was before and why
we decided to rewrite the GTK application now, see the
<a target="_blank" rel="noopener noreferrer" href="https://github.com/ghostty-org/ghostty/pull/7961">original &#34;gtk-ng&#34; PR</a>.
I&#39;m going to keep this post focused on the takeaways rather than the
motivation.</p>
<h2 id="gobject-type-system-and-zig"><a href="#gobject-type-system-and-zig" aria-hidden="true" tabindex="-1"><span></span></a>GObject Type System and Zig</h2>
<p>Whatever your feelings are about OOP and memory management, the reality
is that if you choose GTK, you&#39;re forced into interfacing in <em>some way</em>
with the GObject type system. You can&#39;t avoid it.</p>
<p>Well you <em>can avoid it</em> and we <em>did avoid it</em>. And it leads to a mess
trying to tie the lifetimes of your non-reference-counted objects to the
reference counted ones. There was an entire class of bug that kept popping
up in the Ghostty GTK application that could basically be summed up as:
the Zig memory or the GTK memory has been freed, but not both.</p>
<p>Besides the correctness issues, avoiding the object system also forced
us away from using GTK-native features such as signals (events), properties
(which can be bound to by GUI elements), actions (invoking one-way behavior
from afar), and more.</p>
<p>Let&#39;s look at a concrete example: reloadable configuration. The
configuration in Ghostty is represented by a Zig-owned <code>Config</code> structure.
Many different parts of the GUI need to be aware of the configuration:
windows, tabs, menus, splits, etc.</p>
<p>Reloading configuration was a complicated, CPU-intensive (relatively),
and error-prone task because we had to ensure the <em>entire GUI</em> updated
before we could free the old <code>Config</code>.</p>
<p>Now, the Zig <code>Config</code> structure is wrapped in a
<a target="_blank" rel="noopener noreferrer" href="https://github.com/ghostty-org/ghostty/blob/b7913f09ad5326331192a24af53473ec541bf1af/src/apprt/gtk-ng/class/config.zig">reference-counted <code>GhosttyConfig</code> GObject</a>.
When we reload the config, we overwrite our property and let the GObject
property change notification system ripple through the application (sometimes
across multiple event loop ticks). When the old configuration no longer has
any references, it frees. Conceptually much simpler.</p>
<p>In addition to memory management, we can now more easily create custom GTK
widgets. This let us fully embrace modern GTK UI technologies such
as <a target="_blank" rel="noopener noreferrer" href="https://gitlab.gnome.org/GNOME/blueprint-compiler">Blueprint</a>.
For example, here is our <a target="_blank" rel="noopener noreferrer" href="https://github.com/ghostty-org/ghostty/blob/b7913f09ad5326331192a24af53473ec541bf1af/src/apprt/gtk-ng/ui/1.5/window.blp">terminal window Blueprint file</a>.
This has already led to more easily introducing GUI features like a new
GTK titlebar tabs option, an animated border on bell, etc.</p>
<h2 id="valgrind-with-gtk-and-zig"><a href="#valgrind-with-gtk-and-zig" aria-hidden="true" tabindex="-1"><span></span></a>Valgrind with GTK and Zig</h2>
<p>This topic deserves an entire blog post on its own. The gist of it is that
from the first PR to the last, we&#39;ve run every change and Ghostty feature
through Valgrind and addressed any issues to ensure that there are no memory
leaks, undefined memory access, etc.</p>
<p>Running Valgrind on a GTK application is pretty nasty. We need a
<a target="_blank" rel="noopener noreferrer" href="https://github.com/ghostty-org/ghostty/blob/main/valgrind.supp">pretty large suppression file</a>.
I know its a lot, but 80% of that file is provided by GTK itself. The
remainder is primarily 3rd party libraries and GPU drivers. There are perhaps
one or two suppressions I find suspicious (and commented as such).</p>
<p>The important part is we were able to identify a number of bugs along the
way that would&#39;ve <em>definitely</em> slipped under the radar. For example, I learned
that if you <a target="_blank" rel="noopener noreferrer" href="https://github.com/ghostty-org/ghostty/commit/7548dcfe634cd9447e0b7a0f5e2900fe7094a225">forget to clear a GObject <code>WeakRef</code> during dispose</a>,
it&#39;ll cause undefined memory access in the <em>target (referenced)</em> object when it
disposes at some point in the future (can be hours, days!). That undefined
memory access happens to be <em>fine</em> 99% of the time, but once in awhile it
causes a crash. Fun! Valgrind found this without problem.</p>
<p>Memory safety seems to... erm... <em>activate</em> certain conversations. So let me
say two things:</p>
<ol>
<li>
<p><strong>Our Zig codebase had one leak and one undefined memory access.</strong> That was
<em>really surprising to me</em> (in a good way). Our Zig codebase is large,
complex, and uses tons of memory tricks for performance that could easily
lead to unsafe behaviors. I thought we&#39;d have a lot more issues, honestly.
Also, the one leak found was during calling a
3rd party C API (so Zig couldn&#39;t detect it). So this is a huge success.</p>
<p>Zig has a leak-detecting debug allocator and various safety checks
that are only on during debug and test builds in the Ghostty project.
Additionally, Zig has integrations with Valgrind. For example, Zig
emits a Valgrind client request to mark some memory as undefined whenever
you set a value as <code>undefined</code> (keyword) in Zig. This helps find even
more issues.</p>
<p>This experience has really shown me that this is <em>working</em>, despite
not having any of these protections in our release builds.</p>
</li>
<li>
<p><strong>All other memory issues revolved around C API boundaries.</strong> Every other
issue we found (and there were dozens) was directly within the complex
lifetimes of the GObject system or on C API boundaries. My takeaway here
is that you absolutely need tooling like Valgrind to safely call across
C APIs (even if they&#39;re not written in C).</p>
<p>For most complex libraries that expose a C API, the C API represents
a boundary where object lifetime is transferred or blurred. Whatever
language you&#39;re using to interact with it, the safety you&#39;re guaranteed
is only as good as understanding the semantics of the API and writing
a good wrapper.</p>
</li>
</ol>
<p>The features Zig provides around memory safety are well documented.
There are a lot of academic or theoretical discussions about what Zig
does or does not do and whether that&#39;s good or bad. Those are valuable
discussions to be had, but so are empirical results. This process is showing
empirical results from a large, complex, multi-threaded, multi-platform
Zig project when every individual feature is run with scrutiny under Valgrind.
Takeaway from that what you want, I don&#39;t want to start any flame wars!</p>
<p>Going forward, I plan to continue to run every GTK PR within Valgrind
and improving our project documentation so maintainers and contributors
can do so as well (we already have a couple up and running!).</p>
<h2 id="conclusion"><a href="#conclusion" aria-hidden="true" tabindex="-1"><span></span></a>Conclusion</h2>
<p>This is now my 5th time writing the GUI part of Ghostty from scratch:
once with GLFW, once on macOS with SwiftUI, then on macOS with AppKit
plus SwiftUI, once on Linux with GTK procedurally, and now on Linux
with GTK and the full GObject type system.</p>
<p>Each time, I&#39;ve learned something new and valuable, and I&#39;ve carried that
experience into each iteration (and across platforms). Even this time,
I&#39;ve learned some new tricks that I plan on taking back over to macOS.</p>
<p>I want to also highlight that the entire GTK subsystem maintenance team
hopped on board to help complete the rewrite. They did a lot of work, too.</p>
<p>The new, rewritten Ghostty GTK application is now the default when
you build Ghostty from source on <code>main</code>, and will be shipped to everyone
in the 1.2 release coming in just a few weeks.</p>
</div></div>
  </body>
</html>
