<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.yossarian.net/2024/08/12/Approximating-sum-types-in-Python-with-Pydantic">Original</a>
    <h1>Approximating sum types in Python with Pydantic</h1>
    
    <div id="readability-page-1" class="page">


<h2><em>Programming, philosophy, pedaling.</em></h2>

<ul>
    <li><a href="https://blog.yossarian.net/">Home</a></li>
    <li><a href="https://blog.yossarian.net/tags">Tags</a></li>
    <li><a href="https://blog.yossarian.net/series">Series</a></li>
    <li><a href="https://blog.yossarian.net/favorites">Favorites</a></li>
    <li><a href="https://blog.yossarian.net/archive">Archive</a></li>
    
      <li><a href="https://yossarian.net">Main Site</a></li>
    
</ul>

<hr/>



<h2>
  <p>
    <span><em>Aug 12, 2024</em></span>

       

    
      <span>
        Tags:
        
        
          <a href="https://blog.yossarian.net/tags#devblog">devblog</a>,
        
          <a href="https://blog.yossarian.net/tags#programming">programming</a>,
        
          <a href="https://blog.yossarian.net/tags#python">python</a>
        
      </span>
    

       

    
  </p>
</h2>






<hr/>


<p>TL;DR: You can use Pydantic’s support for tagged unions to approximate sum
types in Python; go right to <a href="#sum-types-in-python">Sum types in Python</a>
(and onwards) to see how it’s done.</p>

<p>Python is one of my favorite programming languages, and <a href="https://docs.pydantic.dev/latest/">Pydantic</a>
is one of my favorite libraries for Python.</p>

<p>Thanks to Pydantic, I can write full-fledged <em>data models</em> for my
inputs and outputs (e.g. REST APIs, RPC endpoints, application state
between runs, &amp;c) without needing to haphazardly poke through a <code>dict</code>
<em>or</em> manually round-trip through another validation layer.</p>

<p>For example, the following:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td><pre><span>def</span> <span>frobulate</span><span>(</span><span>some_json</span><span>:</span> <span>str</span><span>):</span>
    <span># failure: invalid JSON
</span>    <span>raw</span> <span>=</span> <span>json</span><span>.</span><span>loads</span><span>(</span><span>some_json</span><span>)</span>

    <span># failure point: top-level JSON is not an object
</span>    <span># failure point: `foo` is not a str
</span>    <span># failure point: `foo` does not exist as a key
</span>    <span>foo</span><span>:</span> <span>str</span> <span>=</span> <span>raw</span><span>[</span><span>&#34;</span><span>foo</span><span>&#34;</span><span>]</span>

    <span>do_something_with_foo</span><span>(</span><span>foo</span><span>)</span>
    <span>...</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>becomes:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td><pre><span>from</span> <span>pydantic</span> <span>import</span> <span>BaseModel</span>
<span>from</span> <span>pydantic.types</span> <span>import</span> <span>StrictStr</span>

<span>class</span> <span>Frobulated</span><span>(</span><span>BaseModel</span><span>):</span>
    <span>foo</span><span>:</span> <span>StrictStr</span>

<span>def</span> <span>frobulate</span><span>(</span><span>some_json</span><span>:</span> <span>str</span><span>):</span>
    <span>frobulated</span> <span>=</span> <span>Frobulated</span><span>.</span><span>model_validate_json</span><span>(</span><span>some_json</span><span>)</span>

    <span># `frobulated.foo` can&#39;t be anything except a `str`
</span>    <span>do_something_with_foo</span><span>(</span><span>frobulated</span><span>.</span><span>foo</span><span>)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>In other words, Pydantic enables <a href="https://wiki.c2.com/?CorrectByConstruction"><em>correct by construction</em></a> design
patterns<sup id="fnref:care" role="doc-noteref"><a href="#fn:care" rel="footnote">1</a></sup>: by declaring the expected shape of a piece of data upfront,
we can collapse the question of “is this object valid?” into a single
check. That check ensures that partial or invalid states don’t make it any
further than the parts of the program responsible for handling inputs
(and outputs), helping preserve separation of concerns and making it
harder for implicit invariants to sneak their way into lower levels.</p>

<p>The greatest virtue of this pattern is also its greatest vice: this
kind of strict invariant enforcement results in brittle and inflexible
interfaces.</p>

<p>For example, we could imagine a new requirement for <code>Frobulated</code>:
<code>foo XOR bar</code>, meaning either <code>foo</code> or <code>bar</code> is present, but not both
and not neither.</p>

<p>With Pydantic, one way we could model this is:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
</pre></td><td><pre><span>class</span> <span>Frobulated</span><span>(</span><span>BaseModel</span><span>):</span>
    <span>foo</span><span>:</span> <span>StrictStr</span> <span>|</span> <span>None</span> <span>=</span> <span>None</span>
    <span>bar</span><span>:</span> <span>StrictStr</span> <span>|</span> <span>None</span> <span>=</span> <span>None</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>…but this is imperfect, since the <code>XOR</code> variant is not captured by the type
itself. In other words, the object can be constructed in an invalid state,
and users either need to assert its validity as a precondition or
do something like the following:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
</pre></td><td><pre><span># NOTE: this is imprecise, since `bool(...)` will also incorrectly
# coerce an empty string to False here.
</span><span>if</span> <span>bool</span><span>(</span><span>frobulated</span><span>.</span><span>foo</span><span>)</span> <span>^</span> <span>bool</span><span>(</span><span>frobulated</span><span>.</span><span>bar</span><span>):</span>
    <span>raise</span> <span>ValueError</span><span>(</span><span>&#34;</span><span>invalid state</span><span>&#34;</span><span>)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>With a bit more knowledge of Pydantic, we could improve this by using
a <code>field_validator</code> to ensure that the object itself is always in a valid state:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td><pre><span>class</span> <span>Frobulated</span><span>(</span><span>BaseModel</span><span>):</span>
    <span>foo</span><span>:</span> <span>StrictStr</span> <span>|</span> <span>None</span> <span>=</span> <span>None</span>
    <span>bar</span><span>:</span> <span>StrictStr</span> <span>|</span> <span>None</span> <span>=</span> <span>None</span>

    <span>@field_validator</span><span>(</span><span>&#34;</span><span>bar</span><span>&#34;</span><span>)</span>
    <span>def</span> <span>_check_xor</span><span>(</span><span>cls</span><span>,</span> <span>bar</span><span>:</span> <span>StrictStr</span> <span>|</span> <span>None</span><span>,</span> <span>info</span><span>:</span> <span>ValidationInfo</span><span>)</span> <span>-&gt;</span> <span>StrictStr</span> <span>|</span> <span>None</span><span>:</span>
        <span>foo</span> <span>=</span> <span>info</span><span>.</span><span>data</span><span>.</span><span>get</span><span>(</span><span>&#34;</span><span>foo</span><span>&#34;</span><span>)</span>
        <span>if </span><span>(</span><span>foo</span> <span>is</span> <span>None</span><span>)</span> <span>^</span> <span>(</span><span>bar</span> <span>is</span> <span>None</span><span>):</span>
            <span>raise</span> <span>ValueError</span><span>(</span><span>&#34;</span><span>foo XOR bar</span><span>&#34;</span><span>)</span>
        <span>return</span> <span>bar</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>But this too is imperfect:</p>

<ul>
  <li>Our object is now correct by construction, but our object’s <em>types</em> don’t
reflect its correctness: the typechecker doesn’t know what we’ve performed
the <code>XOR</code> check, and will require us to either scatter <code>type: ignore</code> all
over the place or add no-op checks where we <em>know</em> a particular variant
is present.</li>
  <li>Our solution requires extensive knowledge of Pydantic’s internals, e.g.
knowing that the <code>@field_validator</code> must be declared for <code>bar</code>, not <code>foo</code>,
since field validators run in the order of field declaration and don’t have
access to any not-yet-seen fields.</li>
</ul>

<p>Ideally, we’d be able to express our invariant in a way that both Pydantic
and Python’s type annotations (and underlying type system) understand,
without calling on <em>too</em> many of Pydantic’s internals.</p>

<h2 id="sum-types">Sum types</h2>

<p>Sum types are a subset of <a href="https://en.wikipedia.org/wiki/Algebraic_data_type">algebraic data types</a>. They’re a formalization
of a pre-existing pattern, the <em>tagged union</em>:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
</pre></td><td><pre><span>enum</span> <span>FrobulatedKind</span> <span>{</span> <span>FrobulatedFoo</span><span>,</span> <span>FrobulatedBar</span> <span>};</span>

<span>struct</span> <span>Frobulated</span> <span>{</span>
    <span>enum</span> <span>FrobulatedKind</span> <span>kind</span><span>;</span>
    <span>union</span> <span>{</span>
        <span>char</span> <span>*</span><span>foo</span><span>;</span>
        <span>char</span> <span>*</span><span>bar</span><span>;</span>
    <span>};</span>
<span>};</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>In C and C++, the tagged union pattern<sup id="fnref:basic" role="doc-noteref"><a href="#fn:basic" rel="footnote">2</a></sup> is fundamentally unsound:
implicit promotion of integral values to enum types and a lack of separation
between variant values means that bugs like the following are common<sup id="fnref:contrived" role="doc-noteref"><a href="#fn:contrived" rel="footnote">3</a></sup>:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td><pre><span>void</span> <span>set_kind</span><span>(</span><span>struct</span> <span>Frobulated</span> <span>*</span><span>frobulated</span><span>,</span> <span>enum</span> <span>FrobulatedKind</span> <span>kind</span><span>)</span> <span>{</span>
    <span>frobulated</span><span>-&gt;</span><span>kind</span> <span>=</span> <span>kind</span><span>;</span>
<span>}</span>

<span>char</span><span>*</span> <span>get_value</span><span>(</span><span>struct</span> <span>Frobulated</span> <span>*</span><span>frobulated</span><span>)</span> <span>{</span>
    <span>switch</span> <span>(</span><span>frobulated</span><span>-&gt;</span><span>kind</span><span>)</span> <span>{</span>
        <span>case</span> <span>FrobulatedFoo</span><span>:</span>
            <span>return</span> <span>frobulated</span><span>-&gt;</span><span>foo</span><span>;</span>
        <span>// BUG: assumes `kind` must be FrobulatedBar</span>
        <span>default:</span> <span>/* FrobulatedBar */</span>
            <span>return</span> <span>frobulated</span><span>-&gt;</span><span>bar</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>int</span> <span>main</span><span>(</span><span>int</span> <span>argc</span><span>,</span> <span>char</span> <span>**</span><span>argv</span><span>)</span> <span>{</span>
    <span>struct</span> <span>Frobulated</span> <span>frobulated</span> <span>=</span> <span>{};</span>

    <span>// BUG: no check on `kind` being a valid `FrobulatedKind`</span>
    <span>enum</span> <span>FrobulatedKind</span> <span>kind</span> <span>=</span> <span>atoi</span><span>(</span><span>argv</span><span>[</span><span>1</span><span>]);</span>
    <span>set_kind</span><span>(</span><span>&amp;</span><span>frobulated</span><span>,</span> <span>kind</span><span>);</span>
    <span>frobulated</span><span>.</span><span>foo</span> <span>=</span> <span>&#34;foo!&#34;</span><span>;</span>

    <span>// Prints `foo!` even if `kind` is `FrobulatedBar`.</span>
    <span>printf</span><span>(</span><span>&#34;%s</span><span>\n</span><span>&#34;</span><span>,</span> <span>get_value</span><span>(</span><span>&amp;</span><span>frobulated</span><span>));</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>In this instance the bug is mostly benign, since both variants have the same
type and occupy the exact same layout within the anonymous <code>union</code>. However,
this pattern is essentially the one behind<sup id="fnref:behind" role="doc-noteref"><a href="#fn:behind" rel="footnote">4</a></sup> many <a href="https://cwe.mitre.org/data/definitions/843.html">type confusion</a>
vulnerabilities in C and C++.</p>

<p>When formalized, sum types make these kinds of errors impossible by
<em>making invalid states unrepresentable</em> within the type system. Rust’s
<code>enum</code> encapsulates this:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
</pre></td><td><pre><span>enum</span> <span>Frobulated</span> <span>{</span>
    <span>Foo</span><span>(</span><span>String</span><span>),</span>
    <span>Bar</span><span>(</span><span>String</span><span>),</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>With Rust’s <code>enum</code>, the only valid states are <code>Frobulated::Foo</code> and
<code>Frobulated::Bar</code>, and the two have fully independent member fields at the type
level, <em>despite</em> <code>Foo.0</code> and <code>Bar.0</code> sharing the same underlying location
at runtime. Consequently, it’s impossible to access <code>Foo.0</code> through <code>Bar</code> or
vice versa.</p>

<p>And observe: the Rust version of <code>Frobulated</code> above preserves our original
invariant! With this version <code>Frobulated</code>, the existence of a <code>Frobulated</code>
means one and <em>exactly one</em> variant of <code>Foo</code> or <code>Bar</code> is present —
no other states are possible, and the type system knows this.</p>

<p>Now, let’s apply it to Python.</p>

<h2 id="sum-types-in-python">Sum types in Python</h2>

<p>To start: Pydantic <a href="https://docs.pydantic.dev/latest/concepts/unions/">already supports unions</a>!</p>

<p>To express our <code>Frobulated</code> variants, we could do the following:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td><pre><span>from</span> <span>pydantic</span> <span>import</span> <span>BaseModel</span>
<span>from</span> <span>pydantic.types</span> <span>import</span> <span>StrictStr</span>

<span>class</span> <span>Foo</span><span>(</span><span>BaseModel</span><span>):</span>
    <span>foo</span><span>:</span> <span>StrictStr</span>

<span>class</span> <span>Bar</span><span>(</span><span>BaseModel</span><span>):</span>
    <span>bar</span><span>:</span> <span>StrictStr</span>

<span>Frobulated</span> <span>=</span> <span>Foo</span> <span>|</span> <span>Bar</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>In this case, <code>Frobulated</code> is a <a href="https://docs.python.org/3/library/typing.html#typing.Union"><code>typing.Union</code></a>, which means that it isn’t
<em>itself</em> a Pydantic <code>BaseModel</code>. To deserialize from it such that an appropriate
variant will be selected, we need another Pydantic API: <a href="https://docs.pydantic.dev/latest/concepts/type_adapter/"><code>TypeAdapter</code></a>:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
</pre></td><td><pre><span>from</span> <span>pydantic</span> <span>import</span> <span>TypeAdapter</span>

<span>adapted</span> <span>=</span> <span>TypeAdapter</span><span>(</span><span>Frobulated</span><span>)</span>

<span>foo</span> <span>=</span> <span>adapted</span><span>.</span><span>validate_json</span><span>(</span><span>&#39;</span><span>{</span><span>&#34;</span><span>foo</span><span>&#34;</span><span>: </span><span>&#34;</span><span>foo!</span><span>&#34;</span><span>}</span><span>&#39;</span><span>)</span>
<span>bar</span> <span>=</span> <span>adapted</span><span>.</span><span>validate_json</span><span>(</span><span>&#39;</span><span>{</span><span>&#34;</span><span>bar</span><span>&#34;</span><span>: </span><span>&#34;</span><span>bar!</span><span>&#34;</span><span>}</span><span>&#39;</span><span>)</span>

<span>assert</span> <span>isinstance</span><span>(</span><span>foo</span><span>,</span> <span>Foo</span><span>)</span>
<span>assert</span> <span>isinstance</span><span>(</span><span>bar</span><span>,</span> <span>Bar</span><span>)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Observe that, in this case, <code>Foo</code> and <code>Bar</code> are <strong>not</strong> discriminated or tagged:
Pydantic knows to instantiate one versus the other because they have different
fields.</p>

<p>So, what happens when two variants share (some of) the same fields?</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td><pre><span>class</span> <span>Foo</span><span>(</span><span>BaseModel</span><span>):</span>
    <span>value</span><span>:</span> <span>StrictStr</span>
    <span>extra</span><span>:</span> <span>bool</span> <span>|</span> <span>None</span> <span>=</span> <span>None</span>

<span>class</span> <span>Bar</span><span>(</span><span>BaseModel</span><span>):</span>
    <span>value</span><span>:</span> <span>StrictStr</span>

<span>Frobulated</span> <span>=</span> <span>Foo</span> <span>|</span> <span>Bar</span>

<span>adapted</span> <span>=</span> <span>TypeAdapter</span><span>(</span><span>Frobulated</span><span>)</span>

<span>mystery</span> <span>=</span> <span>adapted</span><span>.</span><span>validate_json</span><span>(</span><span>&#39;</span><span>{</span><span>&#34;</span><span>value</span><span>&#34;</span><span>: </span><span>&#34;</span><span>which type is it?</span><span>&#34;</span><span>}</span><span>&#39;</span><span>)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>yields:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre><span>Foo</span><span>(</span><span>value</span><span>=</span><span>&#39;</span><span>which type is it?</span><span>&#39;</span><span>,</span> <span>extra</span><span>=</span><span>None</span><span>)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Was this the correct variant? Without additional context, it’s impossible
to say: the supplied JSON matches both variants, but <code>Foo</code> is arguably
less “precise” (since <code>Bar</code> is an exact match, while <code>Foo</code> is only
an exact match if the default value for <code>extra</code> is satisfied).
Pydantic allows us to <a href="https://docs.pydantic.dev/latest/concepts/unions/#union-modes">configure</a> its matching behavior, but the fundamental
ambiguity remains<sup id="fnref:perf" role="doc-noteref"><a href="#fn:perf" rel="footnote">5</a></sup>.</p>

<p>To prevent this kind of confusion, we either need to ensure that all
variants remain fully disjoint in shape (challenging over nontrivial
numbers of variants, especially with default values) <em>or</em> take a different
approach.</p>

<h2 id="discriminated-unions-in-pydantic">Discriminated unions in Pydantic</h2>

<p>Pydantic <em>also</em> supports tagged unions! These are referred to as
<em>discriminated unions</em> in Pydantic’s documentation and rely on the presence
of an additional field<sup id="fnref:fields" role="doc-noteref"><a href="#fn:fields" rel="footnote">6</a></sup>, the <em>discriminator</em>, to help Pydantic select the
appropriate variant.</p>

<p>We can define <code>Frobulated</code> as a discriminated union with just a few changes:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td><pre><span>from</span> <span>typing</span> <span>import</span> <span>Literal</span><span>,</span> <span>Annotated</span>

<span>from</span> <span>pydantic</span> <span>import</span> <span>BaseModel</span><span>,</span> <span>Field</span>
<span>from</span> <span>pydantic.types</span> <span>import</span> <span>StrictStr</span>

<span># NOTE: `Foo` and `Bar` both have `value` as their field, to demonstrate
# proper disambiguation.
</span><span>class</span> <span>Foo</span><span>(</span><span>BaseModel</span><span>):</span>
    <span>kind</span><span>:</span> <span>Literal</span><span>[</span><span>&#39;</span><span>foo</span><span>&#39;</span><span>]</span>
    <span>value</span><span>:</span> <span>StrictStr</span>

<span>class</span> <span>Bar</span><span>(</span><span>BaseModel</span><span>):</span>
    <span>kind</span><span>:</span> <span>Literal</span><span>[</span><span>&#39;</span><span>bar</span><span>&#39;</span><span>]</span>
    <span>value</span><span>:</span> <span>StrictStr</span>

<span>Frobulated</span> <span>=</span> <span>Annotated</span><span>[</span><span>Foo</span> <span>|</span> <span>Bar</span><span>,</span> <span>Field</span><span>(</span><span>discriminator</span><span>=</span><span>&#34;</span><span>kind</span><span>&#34;</span><span>)]</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>To load these from JSON, we’ll need the same <code>TypeAdapter</code> trick,
and to explicitly pass the <code>kind</code> as part of the JSON payload:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
</pre></td><td><pre><span>adapted</span> <span>=</span> <span>TypeAdapter</span><span>(</span><span>Frobulated</span><span>)</span>

<span>foo</span> <span>=</span> <span>adapted</span><span>.</span><span>validate_json</span><span>(</span><span>&#39;</span><span>{</span><span>&#34;</span><span>kind</span><span>&#34;</span><span>: </span><span>&#34;</span><span>foo</span><span>&#34;</span><span>, </span><span>&#34;</span><span>value</span><span>&#34;</span><span>: </span><span>&#34;</span><span>foo!</span><span>&#34;</span><span>}</span><span>&#39;</span><span>)</span>
<span>bar</span> <span>=</span> <span>adapted</span><span>.</span><span>validate_json</span><span>(</span><span>&#39;</span><span>{</span><span>&#34;</span><span>kind</span><span>&#34;</span><span>: </span><span>&#34;</span><span>bar</span><span>&#34;</span><span>, </span><span>&#34;</span><span>value</span><span>&#34;</span><span>: </span><span>&#34;</span><span>foo!</span><span>&#34;</span><span>}</span><span>&#39;</span><span>)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>yielding:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
</pre></td><td><pre><span>&gt;&gt;&gt;</span> <span>foo</span>
<span>Foo</span><span>(</span><span>kind</span><span>=</span><span>&#39;</span><span>foo</span><span>&#39;</span><span>,</span> <span>value</span><span>=</span><span>&#39;</span><span>foo!</span><span>&#39;</span><span>)</span>
<span>&gt;&gt;&gt;</span> <span>bar</span>
<span>Bar</span><span>(</span><span>kind</span><span>=</span><span>&#39;</span><span>bar</span><span>&#39;</span><span>,</span> <span>value</span><span>=</span><span>&#39;</span><span>foo!</span><span>&#39;</span><span>)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>…and passing any other <code>kind</code> fails:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td><pre><span>&gt;&gt;&gt;</span> <span>adapted</span><span>.</span><span>validate_json</span><span>(</span><span>&#39;</span><span>{</span><span>&#34;</span><span>kind</span><span>&#34;</span><span>: </span><span>&#34;</span><span>baz</span><span>&#34;</span><span>, </span><span>&#34;</span><span>value</span><span>&#34;</span><span>: </span><span>&#34;</span><span>foo!</span><span>&#34;</span><span>}</span><span>&#39;</span><span>)</span>
<span>Traceback </span><span>(</span><span>most</span> <span>recent</span> <span>call</span> <span>last</span><span>):</span>
  <span>File</span> <span>&#34;</span><span>&lt;stdin&gt;</span><span>&#34;</span><span>,</span> <span>line</span> <span>1</span><span>,</span> <span>in</span> <span>&lt;</span><span>module</span><span>&gt;</span>
  <span>File</span> <span>&#34;</span><span>/tmp/env/lib/python3.12/site-packages/pydantic/type_adapter.py</span><span>&#34;</span><span>,</span> <span>line</span> <span>142</span><span>,</span> <span>in</span> <span>wrapped</span>
    <span>return</span> <span>func</span><span>(</span><span>self</span><span>,</span> <span>*</span><span>args</span><span>,</span> <span>**</span><span>kwargs</span><span>)</span>
           <span>^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
  <span>File</span> <span>&#34;</span><span>/tmp/env/lib/python3.12/site-packages/pydantic/type_adapter.py</span><span>&#34;</span><span>,</span> <span>line</span> <span>391</span><span>,</span> <span>in</span> <span>validate_json</span>
    <span>return</span> <span>self</span><span>.</span><span>validator</span><span>.</span><span>validate_json</span><span>(</span><span>data</span><span>,</span> <span>strict</span><span>=</span><span>strict</span><span>,</span> <span>context</span><span>=</span><span>context</span><span>)</span>
           <span>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<span>pydantic_core</span><span>.</span><span>_pydantic_core</span><span>.</span><span>ValidationError</span><span>:</span> <span>1</span> <span>validation</span> <span>error</span> <span>for</span> <span>tagged</span><span>-</span><span>union</span><span>[</span><span>Foo</span><span>,</span><span>Bar</span><span>]</span>
  <span>Input</span> <span>tag</span> <span>&#39;</span><span>baz</span><span>&#39;</span> <span>found</span> <span>using</span> <span>&#39;</span><span>kind</span><span>&#39;</span> <span>does</span> <span>not</span> <span>match</span> <span>any</span> <span>of</span> <span>the</span> <span>expected</span> <span>tags</span><span>:</span> <span>&#39;</span><span>foo</span><span>&#39;</span><span>,</span> <span>&#39;</span><span>bar</span><span>&#39;</span> <span>[</span><span>type</span><span>=</span><span>union_tag_invalid</span><span>,</span> <span>input_value</span><span>=</span><span>{</span><span>&#39;</span><span>kind</span><span>&#39;</span><span>:</span> <span>&#39;</span><span>baz</span><span>&#39;</span><span>,</span> <span>&#39;</span><span>value</span><span>&#39;</span><span>:</span> <span>&#39;</span><span>foo!</span><span>&#39;</span><span>},</span> <span>input_type</span><span>=</span><span>dict</span><span>]</span>
    <span>For</span> <span>further</span> <span>information</span> <span>visit</span> <span>https</span><span>:</span><span>//</span><span>errors</span><span>.</span><span>pydantic</span><span>.</span><span>dev</span><span>/</span><span>2.8</span><span>/</span><span>v</span><span>/</span><span>union_tag_invalid</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>With an explicit discriminator our variants can be any shape (including
identical shapes) without causing ambiguity during matching — we just
need to be sure to always include our discriminator (in this case,
<code>kind</code>).</p>

<h2 id="getting-fancy">Getting fancy</h2>

<h3 id="non-string-discriminators">Non-string discriminators</h3>

<p>This one really isn’t so fancy, just a generalization to observe: there’s
no requirement that discriminators be strings. They can also be integers<sup id="fnref:others" role="doc-noteref"><a href="#fn:others" rel="footnote">7</a></sup>,
for more compact encodings:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
</pre></td><td><pre><span>class</span> <span>Foo</span><span>(</span><span>BaseModel</span><span>):</span>
    <span>kind</span><span>:</span> <span>Literal</span><span>[</span><span>1</span><span>]</span>
    <span>value</span><span>:</span> <span>StrictStr</span>

<span>class</span> <span>Bar</span><span>(</span><span>BaseModel</span><span>):</span>
    <span>kind</span><span>:</span> <span>Literal</span><span>[</span><span>2</span><span>]</span>
    <span>value</span><span>:</span> <span>StrictStr</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="enum-variants-as-discriminators">Enum variants as discriminators</h3>

<p>With the basic example above, we use Pydantic’s support for <code>Literal[...]</code>
to discriminate each variant. This works just fine, but it isn’t the most
maintainable for large numbers of variants — changing a variant’s <code>kind</code>
would potentially require a large number of literal string changes across our
codebase.</p>

<p>To reduce this duplication, we can use an <a href="https://docs.python.org/3/library/enum.html"><code>enum.Enum</code></a>’s variants as our
discriminator values:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td><pre><span># IMPORTANT: inheriting `str` isn&#39;t necessary, but allows for
# direct instantiation from a Python str rather than an `Enum` value,
# per examples below.
</span><span>class</span> <span>FrobulatedKind</span><span>(</span><span>str</span><span>,</span> <span>enum</span><span>.</span><span>Enum</span><span>):</span>
    <span>Foo</span> <span>=</span> <span>&#34;</span><span>foo</span><span>&#34;</span>
    <span>Bar</span> <span>=</span> <span>&#34;</span><span>bar</span><span>&#34;</span>

<span>class</span> <span>Foo</span><span>(</span><span>BaseModel</span><span>):</span>
    <span>kind</span><span>:</span> <span>Literal</span><span>[</span><span>FrobulatedKind</span><span>.</span><span>Foo</span><span>]</span>
    <span>value</span><span>:</span> <span>StrictStr</span>

<span>class</span> <span>Bar</span><span>(</span><span>BaseModel</span><span>):</span>
    <span>kind</span><span>:</span> <span>Literal</span><span>[</span><span>FrobulatedKind</span><span>.</span><span>Bar</span><span>]</span>
    <span>value</span><span>:</span> <span>StrictStr</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>This adds a small amount of indirection and an additional type,
but gives us the ability to update the value behind each enum variant
without needing to update literals everywhere.</p>

<h3 id="default-discriminator-values">Default discriminator values</h3>

<p>One thing I haven’t touched on so far is Pydantic’s non-JSON constructors.</p>

<p>In particular, Pydantic also allows for direct construction from keyword
arguments or from a Python dictionary. For example:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
</pre></td><td><pre><span>&gt;&gt;&gt;</span> <span>Foo</span><span>(</span><span>kind</span><span>=</span><span>&#34;</span><span>foo</span><span>&#34;</span><span>,</span> <span>value</span><span>=</span><span>&#34;</span><span>foo!</span><span>&#34;</span><span>)</span>
<span>Foo</span><span>(</span><span>kind</span><span>=&lt;</span><span>FrobulatedKind</span><span>.</span><span>Foo</span><span>:</span> <span>&#39;</span><span>foo</span><span>&#39;</span><span>&gt;</span><span>,</span> <span>value</span><span>=</span><span>&#39;</span><span>foo!</span><span>&#39;</span><span>)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>However, there’s some duplication there: we already know we’re constructing
a <code>Foo</code>, so it’s a little silly that we <em>also</em> have to pass in the <code>kind</code>.
Unfortunately, not doing so doesn’t work out of the box, since <code>kind</code> is
a required field no different from any other:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
</pre></td><td><pre><span>&gt;&gt;&gt;</span> <span>Foo</span><span>(</span><span>value</span><span>=</span><span>&#34;</span><span>foo!</span><span>&#34;</span><span>)</span>
<span>Traceback </span><span>(</span><span>most</span> <span>recent</span> <span>call</span> <span>last</span><span>):</span>
  <span>File</span> <span>&#34;</span><span>&lt;stdin&gt;</span><span>&#34;</span><span>,</span> <span>line</span> <span>1</span><span>,</span> <span>in</span> <span>&lt;</span><span>module</span><span>&gt;</span>
  <span>File</span> <span>&#34;</span><span>/tmp/env/lib/python3.12/site-packages/pydantic/main.py</span><span>&#34;</span><span>,</span> <span>line</span> <span>193</span><span>,</span> <span>in</span> <span>__init__</span>
    <span>self</span><span>.</span><span>__pydantic_validator__</span><span>.</span><span>validate_python</span><span>(</span><span>data</span><span>,</span> <span>self_instance</span><span>=</span><span>self</span><span>)</span>
<span>pydantic_core</span><span>.</span><span>_pydantic_core</span><span>.</span><span>ValidationError</span><span>:</span> <span>1</span> <span>validation</span> <span>error</span> <span>for</span> <span>Foo</span>
<span>kind</span>
  <span>Field</span> <span>required</span> <span>[</span><span>type</span><span>=</span><span>missing</span><span>,</span> <span>input_value</span><span>=</span><span>{</span><span>&#39;</span><span>value</span><span>&#39;</span><span>:</span> <span>&#39;</span><span>foo!</span><span>&#39;</span><span>},</span> <span>input_type</span><span>=</span><span>dict</span><span>]</span>
    <span>For</span> <span>further</span> <span>information</span> <span>visit</span> <span>https</span><span>:</span><span>//</span><span>errors</span><span>.</span><span>pydantic</span><span>.</span><span>dev</span><span>/</span><span>2.8</span><span>/</span><span>v</span><span>/</span><span>missing</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>To get around this, we can define a default field value for our discriminator:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
</pre></td><td><pre><span>class</span> <span>Foo</span><span>(</span><span>BaseModel</span><span>):</span>
    <span>kind</span><span>:</span> <span>Literal</span><span>[</span><span>FrobulatedKind</span><span>.</span><span>Foo</span><span>]</span> <span>=</span> <span>FrobulatedKind</span><span>.</span><span>Foo</span>
    <span>value</span><span>:</span> <span>StrictStr</span>

<span>class</span> <span>Bar</span><span>(</span><span>BaseModel</span><span>):</span>
    <span>kind</span><span>:</span> <span>Literal</span><span>[</span><span>FrobulatedKind</span><span>.</span><span>Bar</span><span>]</span> <span>=</span> <span>FrobulatedKind</span><span>.</span><span>Bar</span>
    <span>value</span><span>:</span> <span>StrictStr</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Pydantic will plumb this as a kwarg default, meaning that omitting the <code>kind</code>
will work:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
</pre></td><td><pre><span>&gt;&gt;&gt;</span> <span>Foo</span><span>(</span><span>value</span><span>=</span><span>&#34;</span><span>foo!</span><span>&#34;</span><span>)</span>
<span>Foo</span><span>(</span><span>kind</span><span>=&lt;</span><span>FrobulatedKind</span><span>.</span><span>Foo</span><span>:</span> <span>&#39;</span><span>foo</span><span>&#39;</span><span>&gt;</span><span>,</span> <span>value</span><span>=</span><span>&#39;</span><span>foo!</span><span>&#39;</span><span>)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>What’s more, this <strong>won’t</strong> cause our <code>TypeAdapter</code> to revert back to matching,
since the explicit <code>Field(discriminator=&#34;kind&#34;)</code> must still be upheld:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td><pre><span>&gt;&gt;&gt;</span> <span>adapted</span><span>.</span><span>validate_json</span><span>(</span><span>&#39;</span><span>{</span><span>&#34;</span><span>value</span><span>&#34;</span><span>: </span><span>&#34;</span><span>foo!</span><span>&#34;</span><span>}</span><span>&#39;</span><span>)</span>
<span>Traceback </span><span>(</span><span>most</span> <span>recent</span> <span>call</span> <span>last</span><span>):</span>
  <span>File</span> <span>&#34;</span><span>&lt;stdin&gt;</span><span>&#34;</span><span>,</span> <span>line</span> <span>1</span><span>,</span> <span>in</span> <span>&lt;</span><span>module</span><span>&gt;</span>
  <span>File</span> <span>&#34;</span><span>/tmp/env/lib/python3.12/site-packages/pydantic/type_adapter.py</span><span>&#34;</span><span>,</span> <span>line</span> <span>142</span><span>,</span> <span>in</span> <span>wrapped</span>
    <span>return</span> <span>func</span><span>(</span><span>self</span><span>,</span> <span>*</span><span>args</span><span>,</span> <span>**</span><span>kwargs</span><span>)</span>
           <span>^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
  <span>File</span> <span>&#34;</span><span>/tmp/env/lib/python3.12/site-packages/pydantic/type_adapter.py</span><span>&#34;</span><span>,</span> <span>line</span> <span>391</span><span>,</span> <span>in</span> <span>validate_json</span>
    <span>return</span> <span>self</span><span>.</span><span>validator</span><span>.</span><span>validate_json</span><span>(</span><span>data</span><span>,</span> <span>strict</span><span>=</span><span>strict</span><span>,</span> <span>context</span><span>=</span><span>context</span><span>)</span>
           <span>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<span>pydantic_core</span><span>.</span><span>_pydantic_core</span><span>.</span><span>ValidationError</span><span>:</span> <span>1</span> <span>validation</span> <span>error</span> <span>for</span> <span>tagged</span><span>-</span><span>union</span><span>[</span><span>Foo</span><span>,</span><span>Bar</span><span>]</span>
  <span>Unable</span> <span>to</span> <span>extract</span> <span>tag</span> <span>using</span> <span>discriminator</span> <span>&#39;</span><span>kind</span><span>&#39;</span> <span>[</span><span>type</span><span>=</span><span>union_tag_not_found</span><span>,</span> <span>input_value</span><span>=</span><span>{</span><span>&#39;</span><span>value</span><span>&#39;</span><span>:</span> <span>&#39;</span><span>foo!</span><span>&#39;</span><span>},</span> <span>input_type</span><span>=</span><span>dict</span><span>]</span>
    <span>For</span> <span>further</span> <span>information</span> <span>visit</span> <span>https</span><span>:</span><span>//</span><span>errors</span><span>.</span><span>pydantic</span><span>.</span><span>dev</span><span>/</span><span>2.8</span><span>/</span><span>v</span><span>/</span><span>union_tag_not_found</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>As such, this is a nice Python-only refinement that doesn’t weaken our
explicit JSON deserialization requirements.</p>



<p>In practice, variants often have overlapping subsets of fields. We can model
this too, thanks to Pydantic’s ability to compose through normal
Python class hierarchies!</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td><pre><span># This is also a convenient place to define `model_config`
# for configuration tweaks across multiple variants.
</span><span>class</span> <span>_FrobulatedBase</span><span>(</span><span>BaseModel</span><span>):</span>
    <span>value</span><span>:</span> <span>StrictStr</span>


<span>class</span> <span>Foo</span><span>(</span><span>_FrobulatedBase</span><span>):</span>
    <span>kind</span><span>:</span> <span>Literal</span><span>[</span><span>FrobulatedKind</span><span>.</span><span>Foo</span><span>]</span> <span>=</span> <span>FrobulatedKind</span><span>.</span><span>Foo</span>
    <span>foo_specific</span><span>:</span> <span>int</span>


<span>class</span> <span>Bar</span><span>(</span><span>_FrobulatedBase</span><span>):</span>
    <span>kind</span><span>:</span> <span>Literal</span><span>[</span><span>FrobulatedKind</span><span>.</span><span>Bar</span><span>]</span> <span>=</span> <span>FrobulatedKind</span><span>.</span><span>Bar</span>
    <span>bar_specific</span><span>:</span> <span>bool</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>With this, each of <code>Foo</code> and <code>Bar</code> inherit the <code>value</code> field’s behavior,
without redefinition:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
</pre></td><td><pre><span>&gt;&gt;&gt;</span> <span>Foo</span><span>(</span><span>value</span><span>=</span><span>&#34;</span><span>foo!</span><span>&#34;</span><span>,</span> <span>foo_specific</span><span>=</span><span>123</span><span>)</span>
<span>Foo</span><span>(</span><span>value</span><span>=</span><span>&#39;</span><span>foo!</span><span>&#39;</span><span>,</span> <span>kind</span><span>=&lt;</span><span>FrobulatedKind</span><span>.</span><span>Foo</span><span>:</span> <span>&#39;</span><span>foo</span><span>&#39;</span><span>&gt;</span><span>,</span> <span>foo_specific</span><span>=</span><span>123</span><span>)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Observe that the field order is now slightly different, since the base model’s
(<code>_FrobulatedBase</code>’s) fields come first.</p>

<p>This doesn’t typically matter in practice (since JSON doesn’t have an object
key ordering), but if it <em>does</em> matter for your use case then you can
define <code>_FrobulatedBase</code> with an underspecified <code>kind</code> for each variant
to complete:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
</pre></td><td><pre><span>class</span> <span>_FrobulatedBase</span><span>(</span><span>BaseModel</span><span>):</span>
    <span>kind</span><span>:</span> <span>FrobulatedKind</span>
    <span>value</span><span>:</span> <span>StrictStr</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>…producing:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
</pre></td><td><pre><span>&gt;&gt;&gt;</span> <span>adapted</span><span>.</span><span>validate_json</span><span>(</span><span>&#39;</span><span>{</span><span>&#34;</span><span>kind</span><span>&#34;</span><span>: </span><span>&#34;</span><span>foo</span><span>&#34;</span><span>, </span><span>&#34;</span><span>value</span><span>&#34;</span><span>: </span><span>&#34;</span><span>foo!</span><span>&#34;</span><span>, </span><span>&#34;</span><span>foo_specific</span><span>&#34;</span><span>: 1}</span><span>&#39;</span><span>)</span>
<span>Foo</span><span>(</span><span>kind</span><span>=&lt;</span><span>FrobulatedKind</span><span>.</span><span>Foo</span><span>:</span> <span>&#39;</span><span>foo</span><span>&#39;</span><span>&gt;</span><span>,</span> <span>value</span><span>=</span><span>&#39;</span><span>foo!</span><span>&#39;</span><span>,</span> <span>foo_specific</span><span>=</span><span>1</span><span>)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="avoiding-typeadapter">Avoiding <code>TypeAdapter</code></h3>

<p><code>TypeAdapter</code> is the lynchpin in everything above: it converts our type-level
<code>typing.Union</code> into something that Pydantic’s object model knows how to
serialize and deserialize.</p>

<p>Unfortunately, it’s also a bit of an eyesore: it would be nice to call
<code>Frobulated(...)</code> or <code>Frobulated.model_validate_json(...)</code> directly
and have the appropriate variant returned.</p>

<p>To do this, we can leverage Pydantic’s <a href="https://docs.pydantic.dev/latest/concepts/models/#rootmodel-and-custom-root-types"><code>RootModel</code></a>:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
</pre></td><td><pre><span>from</span> <span>pydantic</span> <span>import</span> <span>RootModel</span>

<span>Frobulated</span> <span>=</span> <span>RootModel</span><span>[</span><span>Annotated</span><span>[</span><span>Foo</span> <span>|</span> <span>Bar</span><span>,</span> <span>Field</span><span>(</span><span>discriminator</span><span>=</span><span>&#34;</span><span>kind</span><span>&#34;</span><span>)]]</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>This results in a <code>Frobulated</code> type with a single relevant member, <code>root</code>,
containing the deserialized variant:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
</pre></td><td><pre><span>&gt;&gt;&gt;</span> <span>foo</span> <span>=</span> <span>Frobulated</span><span>.</span><span>model_validate_json</span><span>(</span><span>&#39;</span><span>{</span><span>&#34;</span><span>kind</span><span>&#34;</span><span>: </span><span>&#34;</span><span>foo</span><span>&#34;</span><span>, </span><span>&#34;</span><span>value</span><span>&#34;</span><span>: </span><span>&#34;</span><span>foo!</span><span>&#34;</span><span>, </span><span>&#34;</span><span>foo_specific</span><span>&#34;</span><span>: 1}</span><span>&#39;</span><span>)</span>
<span>&gt;&gt;&gt;</span> <span>foo</span>
<span>RootModel</span><span>[</span><span>Annotated</span><span>[</span><span>Union</span><span>[</span><span>Foo</span><span>,</span> <span>Bar</span><span>],</span> <span>FieldInfo</span><span>(</span><span>annotation</span><span>=</span><span>NoneType</span><span>,</span> <span>required</span><span>=</span><span>True</span><span>,</span> <span>discriminator</span><span>=</span><span>&#39;</span><span>kind</span><span>&#39;</span><span>)]](</span><span>root</span><span>=</span><span>Foo</span><span>(</span><span>kind</span><span>=&lt;</span><span>FrobulatedKind</span><span>.</span><span>Foo</span><span>:</span> <span>&#39;</span><span>foo</span><span>&#39;</span><span>&gt;</span><span>,</span> <span>value</span><span>=</span><span>&#39;</span><span>foo!</span><span>&#39;</span><span>,</span> <span>foo_specific</span><span>=</span><span>1</span><span>))</span>
<span>&gt;&gt;&gt;</span> <span>foo</span><span>.</span><span>root</span>
<span>Foo</span><span>(</span><span>kind</span><span>=&lt;</span><span>FrobulatedKind</span><span>.</span><span>Foo</span><span>:</span> <span>&#39;</span><span>foo</span><span>&#39;</span><span>&gt;</span><span>,</span> <span>value</span><span>=</span><span>&#39;</span><span>foo!</span><span>&#39;</span><span>,</span> <span>foo_specific</span><span>=</span><span>1</span><span>)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>This is about as good as it gets, in terms of making our type look like a
first-class sum type without compromising on type-level accuracy. To get
rid of that last <code>root</code> attribute wart, we <em>could</em> do something like this:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
</pre></td><td><pre><span>class</span> <span>Frobulated</span><span>(</span><span>RootModel</span><span>):</span>
    <span>root</span><span>:</span> <span>Annotated</span><span>[</span><span>Foo</span> <span>|</span> <span>Bar</span><span>,</span> <span>Field</span><span>(</span><span>discriminator</span><span>=</span><span>&#34;</span><span>kind</span><span>&#34;</span><span>)]</span>

    <span>def</span> <span>__getattr__</span><span>(</span><span>self</span><span>,</span> <span>item</span><span>):</span>
        <span>return</span> <span>getattr</span><span>(</span><span>self</span><span>.</span><span>root</span><span>,</span> <span>item</span><span>)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>resulting in:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
</pre></td><td><pre><span>&gt;&gt;&gt;</span> <span>foo</span> <span>=</span> <span>Frobulated</span><span>.</span><span>model_validate_json</span><span>(</span><span>&#39;</span><span>{</span><span>&#34;</span><span>kind</span><span>&#34;</span><span>: </span><span>&#34;</span><span>foo</span><span>&#34;</span><span>, </span><span>&#34;</span><span>value</span><span>&#34;</span><span>: </span><span>&#34;</span><span>foo!</span><span>&#34;</span><span>, </span><span>&#34;</span><span>foo_specific</span><span>&#34;</span><span>: 1}</span><span>&#39;</span><span>)</span>
<span>&gt;&gt;&gt;</span> <span>foo</span><span>.</span><span>value</span>
<span>&#39;</span><span>foo!</span><span>&#39;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>However, there’s no straightforward way to annotate the type for
that <code>__getattr__</code><sup id="fnref:afaik" role="doc-noteref"><a href="#fn:afaik" rel="footnote">8</a></sup> — I think the best that could be done there
is to use <code>typing.overload</code> and explicitly annotate each expected field
via <code>item: Literal[&#34;field-name&#34;]</code>, which would be exceedingly annoying
to write and maintain.</p>

<h2 id="summary">Summary</h2>

<p>After all of our refinements, here’s what our perfect™ Python sum type looks like:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td><pre><span>from</span> <span>enum</span> <span>import</span> <span>Enum</span>
<span>from</span> <span>typing</span> <span>import</span> <span>Literal</span><span>,</span> <span>Annotated</span>

<span>from</span> <span>pydantic</span> <span>import</span> <span>BaseModel</span><span>,</span> <span>Field</span><span>,</span> <span>RootModel</span>
<span>from</span> <span>pydantic.types</span> <span>import</span> <span>StrictStr</span>

<span>class</span> <span>_FrobulatedKind</span><span>(</span><span>str</span><span>,</span> <span>Enum</span><span>):</span>
    <span>Foo</span> <span>=</span> <span>&#34;</span><span>foo</span><span>&#34;</span>
    <span>Bar</span> <span>=</span> <span>&#34;</span><span>bar</span><span>&#34;</span>

<span>class</span> <span>_FrobulatedBase</span><span>(</span><span>BaseModel</span><span>):</span>
    <span>kind</span><span>:</span> <span>_FrobulatedKind</span>
    <span>value</span><span>:</span> <span>StrictStr</span>

<span>class</span> <span>Foo</span><span>(</span><span>_FrobulatedBase</span><span>):</span>
    <span>kind</span><span>:</span> <span>Literal</span><span>[</span><span>_FrobulatedKind</span><span>.</span><span>Foo</span><span>]</span> <span>=</span> <span>_FrobulatedKind</span><span>.</span><span>Foo</span>
    <span>foo_specific</span><span>:</span> <span>int</span>

<span>class</span> <span>Bar</span><span>(</span><span>_FrobulatedBase</span><span>):</span>
    <span>kind</span><span>:</span> <span>Literal</span><span>[</span><span>_FrobulatedKind</span><span>.</span><span>Bar</span><span>]</span> <span>=</span> <span>_FrobulatedKind</span><span>.</span><span>Bar</span>
    <span>bar_specific</span><span>:</span> <span>bool</span>

<span>Frobulated</span> <span>=</span> <span>RootModel</span><span>[</span><span>Annotated</span><span>[</span><span>Foo</span> <span>|</span> <span>Bar</span><span>,</span> <span>Field</span><span>(</span><span>discriminator</span><span>=</span><span>&#34;</span><span>kind</span><span>&#34;</span><span>)]]</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>…and everything works as expected:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td><pre><span>&gt;&gt;&gt;</span> <span># instantiate variant indirectly via Frobulated
</span><span>&gt;&gt;&gt;</span> <span>Frobulated</span><span>(</span><span>kind</span><span>=</span><span>&#34;</span><span>foo</span><span>&#34;</span><span>,</span> <span>value</span><span>=</span><span>&#34;</span><span>foo!</span><span>&#34;</span><span>,</span> <span>foo_specific</span><span>=</span><span>123</span><span>)</span>
<span>RootModel</span><span>[</span><span>Annotated</span><span>[</span><span>Union</span><span>[</span><span>Foo</span><span>,</span> <span>Bar</span><span>],</span> <span>FieldInfo</span><span>(</span><span>annotation</span><span>=</span><span>NoneType</span><span>,</span> <span>required</span><span>=</span><span>True</span><span>,</span> <span>discriminator</span><span>=</span><span>&#39;</span><span>kind</span><span>&#39;</span><span>)]](</span><span>root</span><span>=</span><span>Foo</span><span>(</span><span>kind</span><span>=&lt;</span><span>_FrobulatedKind</span><span>.</span><span>Foo</span><span>:</span> <span>&#39;</span><span>foo</span><span>&#39;</span><span>&gt;</span><span>,</span> <span>value</span><span>=</span><span>&#39;</span><span>foo!</span><span>&#39;</span><span>,</span> <span>foo_specific</span><span>=</span><span>123</span><span>))</span>

<span>&gt;&gt;&gt;</span> <span># instantiate variants directly, no `kind` needed
</span><span>&gt;&gt;&gt;</span> <span>Foo</span><span>(</span><span>value</span><span>=</span><span>&#34;</span><span>foo!</span><span>&#34;</span><span>,</span> <span>foo_specific</span><span>=</span><span>123</span><span>)</span>
<span>Foo</span><span>(</span><span>kind</span><span>=&lt;</span><span>_FrobulatedKind</span><span>.</span><span>Foo</span><span>:</span> <span>&#39;</span><span>foo</span><span>&#39;</span><span>&gt;</span><span>,</span> <span>value</span><span>=</span><span>&#39;</span><span>foo!</span><span>&#39;</span><span>,</span> <span>foo_specific</span><span>=</span><span>123</span><span>)</span>

<span>&gt;&gt;&gt;</span> <span>Bar</span><span>(</span><span>value</span><span>=</span><span>&#34;</span><span>bar!</span><span>&#34;</span><span>,</span> <span>bar_specific</span><span>=</span><span>True</span><span>)</span>
<span>Bar</span><span>(</span><span>kind</span><span>=&lt;</span><span>_FrobulatedKind</span><span>.</span><span>Bar</span><span>:</span> <span>&#39;</span><span>bar</span><span>&#39;</span><span>&gt;</span><span>,</span> <span>value</span><span>=</span><span>&#39;</span><span>bar!</span><span>&#39;</span><span>,</span> <span>bar_specific</span><span>=</span><span>True</span><span>)</span>

<span>&gt;&gt;&gt;</span> <span># JSON ser/de works
</span><span>&gt;&gt;&gt;</span> <span>Bar</span><span>(</span><span>value</span><span>=</span><span>&#34;</span><span>bar!</span><span>&#34;</span><span>,</span> <span>bar_specific</span><span>=</span><span>True</span><span>).</span><span>model_dump_json</span><span>()</span>
<span>&#39;</span><span>{</span><span>&#34;</span><span>kind</span><span>&#34;</span><span>:</span><span>&#34;</span><span>bar</span><span>&#34;</span><span>,</span><span>&#34;</span><span>value</span><span>&#34;</span><span>:</span><span>&#34;</span><span>bar!</span><span>&#34;</span><span>,</span><span>&#34;</span><span>bar_specific</span><span>&#34;</span><span>:true}</span><span>&#39;</span>
<span>&gt;&gt;&gt;</span> <span>Frobulated</span><span>.</span><span>model_validate_json</span><span>(</span><span>&#39;</span><span>{</span><span>&#34;</span><span>kind</span><span>&#34;</span><span>:</span><span>&#34;</span><span>bar</span><span>&#34;</span><span>,</span><span>&#34;</span><span>value</span><span>&#34;</span><span>:</span><span>&#34;</span><span>bar!</span><span>&#34;</span><span>,</span><span>&#34;</span><span>bar_specific</span><span>&#34;</span><span>:true}</span><span>&#39;</span><span>)</span>
<span>RootModel</span><span>[</span><span>Annotated</span><span>[</span><span>Union</span><span>[</span><span>Foo</span><span>,</span> <span>Bar</span><span>],</span> <span>FieldInfo</span><span>(</span><span>annotation</span><span>=</span><span>NoneType</span><span>,</span> <span>required</span><span>=</span><span>True</span><span>,</span> <span>discriminator</span><span>=</span><span>&#39;</span><span>kind</span><span>&#39;</span><span>)]](</span><span>root</span><span>=</span><span>Bar</span><span>(</span><span>kind</span><span>=&lt;</span><span>_FrobulatedKind</span><span>.</span><span>Bar</span><span>:</span> <span>&#39;</span><span>bar</span><span>&#39;</span><span>&gt;</span><span>,</span> <span>value</span><span>=</span><span>&#39;</span><span>bar!</span><span>&#39;</span><span>,</span> <span>bar_specific</span><span>=</span><span>True</span><span>))</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Is this disgusting and verbose? Yes. Pythonic? Maybe. Overkill? Depends —
I don’t use this pattern for every project, but I find it <em>very</em> useful for consuming
structured inputs from e.g. REST APIs.</p>

<hr/>




<hr/>




  






</div>
  </body>
</html>
