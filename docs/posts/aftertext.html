<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://breckyunits.com/aftertext.html">Original</a>
    <h1>Show HN: Aftertext</h1>
    
    <div id="readability-page-1" class="page"><div>





<p><span>December 15, 2021 â€” </span>Both HTML and Markdown mix content with markup:</p>

<p><code>html
 A link in HTML looks like &lt;a href=&#34;hi.html&#34;&gt;this&lt;/a&gt;</code>

<code>markdown
 A link in Markdown looks like [this](hi.html).</code></p><p>I needed an alternative where <i>content is separate from markup</i>. I made an experimental minilang I&#39;m calling <i>Aftertext</i>.</p>

<p><code>aftertext
 A link in Aftertext looks like this.
 link hi.html this</code></p><p>You write some text. <i>After your text</i>, you add your markup instructions with <i>selectors</i> to select the text to markup, one command per line. For example, this paragraph is written in Aftertext and the source code looks like:</p>
<p><code>aftertext
 You write some text. After your text, you add your markup instructions with selectors to select the text to markup, one command per line. For example, this paragraph is written in Aftertext and the source code looks like:
 italics After your text
 italics selectors</code></p><p><a href="https://try.scroll.pub/#scroll%0A%20aftertext%0A%20%20Here%20is%20another%20a%20richer%20example%2C%20showing%20more%20features.%0A%20%20strikethrough%20another%0A%20%20link%20oldhomepage.html%20Here%0A%20%20italics%20more%0A%20%20bold%20showing%0A%20%20underline%20features">Here</a> is <s>a silly</s> another example, <b>with</b> <i>more</i> <u>markups</u>.</p>
<p><code>aftertext
 Here is a silly another example, with more markups.
 strikethrough a silly
 italics more
 bold with
 underline markups
 link https://try.scroll.pub/#scroll%0A%20aftertext%0A%20%20Here%20is%20another%20a%20richer%20example%2C%20showing%20more%20features.%0A%20%20strikethrough%20another%0A%20%20link%20oldhomepage.html%20Here%0A%20%20italics%20more%0A%20%20bold%20showing%0A%20%20underline%20features Here</code></p><p>The first implementation of Aftertext ships in the newest version of <a href="https://scroll.pub/">Scroll</a>. You can also play with it <a href="https://try.scroll.pub/#url%20https://raw.githubusercontent.com/breck7/breckyunits.com/main/aftertext.scroll">here</a>.</p>




<h4>Why did I make this?</h4>

<p>First I should explicitly state that markup languages like HTML and Markdown with embedded markup are extremely popular and I will always support those as well. Aftertext is an independent addition. The design of Scroll as a collection of composable <a href="https://github.com/publicdomaincompany/scroll/blob/main/grammar/">grammar nodes</a> makes that true for all additions.</p>

<p>With that disclaimer out of the way, I made Aftertext because I see two potential upsides of this kind of markup language. First is the orthogonality of text and markup for those that care about clean source. Second is a fun environment to evolve new markup tags.</p>

<h4>Benefits of Keeping Text and Markup Separate</h4>

<p>The most pressing need I had for Aftertext was importing blogs and books written by others into Scroll with the ability to postpone importing all markup. I import HTML blogs and books into Scroll for power reading. The source code with embedded markup is often messy. I don&#39;t always want to import the markup, but sometimes I do. Aftertext gives me a new trick where I can just copy the text, and add the markup later, if needed. Keeping text and markup separate is useful because <i>sometimes readers don&#39;t want the markup.</i></p>

<p>It is likely a very small fraction of readers that would care about this, of course. But perhaps it would be a set of power users who could make good use of it.</p>

<p>Speaking of power users, Aftertext might also be useful for tool builders. Imagine you are building a collaborative editor. With Aftertext, adding a link, bolding some text, adding a footnote, all are simple line insertions. It seems like Aftertext might be a nice simple core pattern for collaborative editing tools.</p>

<p>Version control tools are often line oriented. When markup and content are on the same line it&#39;s not as easy to see which changes were content related and which were markup related. In Aftertext, each markup change corresponds to a single changed line. In the future, I could imagine using AI writing assistants to add more links and enhancements to my posts while keeping the history of content lines untouched.</p>

<p>Finally, I should mention that it seems like keeping the written text and markup separate might make sense because it often matches the actual order in which writing text and marking up text happens. Writing is a human activity that goes back a thousand generations. Adding links is something only the current generations have done. A pattern I often find myself doing is: <i>write first; add links later</i>. Aftertext mirrors that behavior.</p>

<h4>A Petri dish for new markup ideas</h4>

<p>Aftertext provides a scalable way to add new markup ideas. </p>

<p>Simple markups like bolds or italics aren&#39;t a big pain and conventions like <b>*bold*</b> and <i>_italics_</i> used in languages like <a href="https://en.wikipedia.org/wiki/Markdown">Markdown</a> or <a href="https://en.wikipedia.org/wiki/Textile_(markup_language)">Textile</a> do a sufficient job. But even with those, after a certain amount of rules it&#39;s hard to keep track of what characters do what. You also have to worry about escaping rules. With Aftertext adding new markups does not increase the cognitive load on the writer.</p>

<p>When you get to more advanced markup ideas, Aftertext gives each markup node it&#39;s own scope for advanced functionality while keeping the text text.</p>

<p>I&#39;m particularly interested in exploring new ways to do footnotes, sparklines, definitions, highlights and comments. Basic Aftertext might not be compelling on its own, but maybe it will be a useful tool for evolving a new &#34;killer markup&#34;.</p>

<p>Adding a new markup command is just a few <a href="https://github.com/publicdomaincompany/scroll/blob/main/grammar/aftertext.grammar">lines of code</a>.</p>



<h4>What are the downsides of Aftertext?</h4>

<p>There are downsides in using Aftertext that you don&#39;t have with paired delimiter markups.</p>

<p>There is the issue of <i>breakages</i> when editing Aftertext. The nice thing about <b>*bold*</b> is that if you change the text between the tags you don&#39;t break formatting. When editing Aftertext by hand when you change formatted text you break formatting and have to update those lines separately. I hit this a lot. Surprisingly it hasn&#39;t bothered me. Not yet, at least. I need to wait and see how it feels in a few months.</p>

<p>A similar issue to the breakage problem is <i>verbosity</i>. Embedded markup adds a constant number of bytes per tag but with Aftertext the bytes increase linearly with N, the size of the span you are marking up. Again, I haven&#39;t found this to be a problem yet. Perhaps the downside is outweighed by the helpful nudge toward brevity. Or maybe I just haven&#39;t used it enough yet to be annoyed. </p>

<p>Another problem of Aftertext is when markup is <i>semantic</i> and not just an augmentation. &#34;<code>*I* did not say that</code>&#34; is different from &#34;<code>I did not say *that*</code>&#34;. Without embedded markup in these situations meaning could be lost.</p>

<h4>What are the problems with the initial implementation?</h4>

<p>My first implementation leaves a lot of decisions still to make. Right now Aftertext is only usable in <code>aftertext</code> nodes. That is a footgun. The current implementation uses exact match string selectors that only format the first hit. Another footgun. I&#39;ve already hit both of those. And at least two or three more.</p>

<h4>Is this a bad idea?</h4>

<p>You might make the argument that not just the implementation, but the idea itself should be abandoned.</p>

<p>The most likely reason why this is a bad idea is that it simply doesn&#39;t matter whether it&#39;s a good idea or not. You could argue that improvements to markup syntax are inconsequential. That even if it was a 2x better way to markup text for some use cases, AIs will change writing and code in so many bigger ways that&#39;s it not even worth thinking about clean source anymore. This could very well be true (luckily it didn&#39;t take many hours to build).</p>



<p>Or perhaps it is a bad idea because although it may be mildly useful <i>initially</i>, it is actually an anti-pattern and instead of scaling well, will lead to a Wild West of complex colliding markups. I generally don&#39;t have the mental capacity to think too many moves ahead. So I fallback to inching my way forward with code and relying on the feedback of others smarter than me to warn of unforeseen obstacles. </p>

<h3>Summary and Closing Thoughts</h3>

<p>Markups on text may increase monotonically. With current patterns that means source will get messier and more complex. Aftertext is an alternative way to markup text which can scale while keeping source clean. Aftertext might be a good backend format for WYSIWYG GUIs. Though most humans write in WYSIWYG GUIs, Aftertext is designed for the small subset who prefer formats that are also maintainable by hand.</p>

<h3>Related Work</h3>

<p>Thank you to <a href="http://akkartik.name/">Kartik</a>, <a href="https://shalabh.com/">Shalabh</a>, <a href="https://twitter.com/warianoguerra">Mariano</a>, Joe and rau for pointing me to related work. I am certain there are similar efforts I have missed and am grateful for anyone who points those out to me via comments or email.</p>

<p>In 1997 Ted Nelson proposed <a href="https://www.xml.com/pub/a/w3j/s3.nelson.html">parallel markup</a>.</p>

<blockquote>The text and the markup are treated as separate parallel members, presumably (but not necessarily) in different files.
- Ted Nelson</blockquote>

<p>When searching for &#39;&#34;parallel markup implementation&#34;&#39; I also came across a Wikipedia page titled <a href="https://en.wikipedia.org/wiki/Overlapping_markup">Overlapping markup</a>, which contains a number of related points.</p>

<p>A couple of folks mentioned similarities to <a href="https://cgi.csc.liv.ac.uk/~ped/teachadmin/troff_intro.html">troff directives</a>. In a sense Aftertext is reimagining troff 50 years later, when characters/bytes aren&#39;t so expensive anymore.</p>

<p>Brad Templeton describes two inventions, <a href="https://www.templetons.com/tech/proletext.html">Proletext</a> and <a href="https://www.templetons.com/tech/oob.html">OOB</a>, to solve what he termed &#34;Out of band encoding for HTML&#34;. They seem <i>esolangy</i> now but actually cleverly useful back in the day when bytes and keystrokes were more expensive.</p>

<p>The Codex project has a related idea called <a href="https://zfdg.de/sb004_008#hd14">standoff properties</a>. As I understand it, the Codex version uses character indexes for selectors which requires tooling to be practical and rules out hand editing.</p>

<h4>Why now?</h4>

<p>Issues with embedded markup and alternative solutions have been discussed for decades. I would say it&#39;s a safe bet to say embedded markup is superior since it so thoroughly dominates usage. Nevertheless, as I mentioned in my use case, there is a time and a place for alternatives. Aftertext would have been simple enough to understand decades ago and use with pen and paper. So why hasn&#39;t Aftertext&#39;s been tried before?</p>



<p>Verbosity is certainly a reason. Bytes, bandwidth, and keystrokes (pre-autocomplete) used to be more expensive, so Aftertext would have been inefficient. It probably was worthwhile to have a learning curve and force users to memorize cryptic acronyms. It paid off to minimize keystrokes.</p>

<p>I may also be overvaluing the importance of universal parsibility. I value formats that are easy to maintain by hand but also easy to write parsers for. Before GUIs, collaborative VCSs, IDEs, or AIs, there wasn&#39;t as much value to be gained by doing this. But even today I may be overvaluing hand editability. This seems to be the era of AIs and all apps editing JSON documents on the backend. I may be a dinosaur.</p>

<p>Finally, I may be overvaluing the clean scopes used by Aftertext provided by the underlying <a href="https://treenotation.org/">Tree Notation</a>. Aftertext works because each text block gets its own scope for markup directives and each markup directive gets <i>its own scope</i> and you don&#39;t have to worry about matching brackets. So maybe Aftertext just hasn&#39;t been tried because I overvalue that trick.</p>

<h3>Notes</h3>





<figure><a href="https://breckyunits.com/aftertext.png" target="_blank"><img src="https://breckyunits.com/aftertext.png" width="2580" height="1618" loading="lazy"/></a><figcaption>A screenshot of Aftertext on the left and the rendered HTML on the right.</figcaption></figure>



<p><a href="https://github.com/breck7/breckyunits.com/blob/main//aftertext.scroll">Article source</a></p></div></div>
  </body>
</html>
