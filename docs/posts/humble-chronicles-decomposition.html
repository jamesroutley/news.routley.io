<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tonsky.me/blog/humble-decomposition/">Original</a>
    <h1>Humble Chronicles: Decomposition</h1>
    
    
        
        
        
        
        
        <p>Now feels like a good time to make this blog an actual log, documenting my findings as I develop Clojure UI library, <a href="https://github.com/HumbleUI/HumbleUI/">Humble UI</a>.</p>

<p>This is an introductory post, describing the overall shape of the project.</p>

<p>None of the decisions are final and might change at any time. In fact, my expectation is that talking about them in public might help either solidify or replace them, rubber duck-style.</p>

<h1 id="library-decomposition">Library decomposition</h1>

<p>Humble UI is a Clojure framework, but it’s based on <a href="https://github.com/HumbleUI/JWM/">JWM</a> and <a href="https://github.com/HumbleUI/Skija/">Skija</a>, both Java libraries. Skija draws graphics, JWM takes care of window management and OS integrations.</p>

<figure>
  <img src="https://tonsky.me/blog/humble-decomposition/deps.png" />
</figure>

<p>Yes, the fact that there are three libraries instead of a single monolithic package makes it harder to work with.</p>

<p>But I think it’s a worthy goal: without strong coupling, each library is much more versatile on its own. Use one, use both, or use neither: the decision is up to you. For example, Skija is already being used with AWT, LWJGL, winit, etc. The same applies to JWM: want window management but do your own graphics? Easy!</p>

<p>The use of Java also makes these available to every JVM language out there. So I am happy both with separation and the choice of Java as an implementation language.</p>

<h1 id="shared-types">Shared types</h1>

<p>As you can imagine, in a UI framework there are lots of points, vectors, and rectangles flying around. The same is true for both Skija and JWM, actually.</p>

<p>And if there’s one thing I hate to see the most it’s pointless conversions between structurally the same types but named differently.  E.g. from <code class="language-plaintext highlighter-rouge">class SkijaPoint { int x, y; }</code> to <code class="language-plaintext highlighter-rouge">class JWMPoint { int x, y; }</code> to <code class="language-plaintext highlighter-rouge">(defrecord HumblePoint [^int x ^int y])</code>.</p>

<p>So we need to unify. How?</p>

<p>a) Use built-in AWT classes. A good option but might require linking with java.desktop module and that’s a huge dependency.</p>

<p>b) Use a shared library. That’s what I <a href="https://github.com/HumbleUI/Types">ended up doing</a>, even though I hate to add one more project to the mix. Turned out Point and Rect are pretty much all you need to share, so it’s not that bad and probably won’t need to update it too often.</p>

<figure>
  <img src="https://tonsky.me/blog/humble-decomposition/deps2.png" />
  Sorry, no logo :)
</figure>

<h1 id="java-interop">Java interop</h1>

<p>Clojure has a great Java interop, but it’s relying on type annotations too much. And points and rectangles are really everywhere. An example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(let [content-y (- (.-offset ^VScroll child))
      content-h (.-height ^IPoint (.-child-size ^VScroll child))
      scroll-y  (.-y ^IPoint child-rect)
      scroll-h  (.-height ^IPoint cs)
      scroll-r  (.getRight ^IRect child-rect)
</code></pre></div></div>

<p>Now, this poses an interesting challenge. How does one improve on this?</p>

<p>Solution one will be <code class="language-plaintext highlighter-rouge">(defrecord HumblePoint [^int x ^int y])</code>. But then we’re back to square one: converting from JWM points to Clojure ones.</p>

<p>Solution two is to make <code class="language-plaintext highlighter-rouge">class IPoint</code> implement <code class="language-plaintext highlighter-rouge">clojure.lang.ILookup</code>, <code class="language-plaintext highlighter-rouge">IPersistentCollection</code>, <code class="language-plaintext highlighter-rouge">Associative</code> etc. It’s pretty easy to do and could make any Java class behave like Clojure map!</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(:x (IPoint. 1 2)) ;; =&gt; 1
</code></pre></div></div>

<p>This makes working with Java classes from Clojure <em>very</em> pleasant. Code snipped above turns into</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(let [content-y (- (:offset child))
      content-h (:height (:child-size child))
      scroll-y  (:y child-rect)
      scroll-h  (:height cs)
      scroll-r  (:right child-rect)
</code></pre></div></div>

<p>which is <em>much</em> more readable in my opinion.</p>

<p>The problem is, to implement e.g. <code class="language-plaintext highlighter-rouge">clojure.lang.ILookup</code> you need to depend on Clojure (static typing problems, ugh). And Clojure is a huge dependency to impose on everyone who would want to use Skija or JWM from Java.</p>

<p>I was struggling with this dilemma for a while until I arrived at a rather unorthodox decision: implement two versions of <code class="language-plaintext highlighter-rouge">types</code> library, one with Clojure interfaces and one without. Both contain the same classes, but the latter implements a few Clojure interfaces on them.</p>

<p><code class="language-plaintext highlighter-rouge">io.github.humbleui.types</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class IPoint {
    public final int _x;
    public final int _y;
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">io.github.humbleui.types-clojure</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class IPoint extends AFn implements Associative {
    public final int _x;
    public final int _y;

    @Override
    public Object valAt(Object key) {
        return valAt(key, null);
    }

    @Override
    public Object invoke(Object arg1) {
        return valAt(arg1, null);
    }

    ...
}
</code></pre></div></div>

<p>Both Skija and JWM depend on Clojure-free version of <code class="language-plaintext highlighter-rouge">types</code>. But when used through Humble UI we already have Clojure on classpath, so we replace <code class="language-plaintext highlighter-rouge">types</code> with <code class="language-plaintext highlighter-rouge">types-clojure</code>:</p>

<figure>
  <img src="https://tonsky.me/blog/humble-decomposition/deps3.png" />
</figure>

<p>Am I happy with this decision? I don’t know. It sure sounds complicated, and I don’t like that.</p>

<p>But:</p>

<ul>
  <li>it works,</li>
  <li>it is simple for the end-user (you depend on <code class="language-plaintext highlighter-rouge">humbleui</code> and it does the right thing by default),</li>
  <li>I <em>love</em> how natural it feels to use Clojure-enabled classes, even though they are written in Java.</li>
</ul>

<p>I guess, until we find a better solution, we’ll keep this one.</p>

        
      
  </body>
</html>
