<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/vegesm/c72">Original</a>
    <h1>C72: A port of the earliest C compiler to x86 (2021)</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto">A port of the <a href="https://www.bell-labs.com/usr/dmr/www/primevalC.html" rel="nofollow">earliest C compiler</a> to x86. The compiler generates 32-bit code and works on modern Linux with a current libc. It follows the architecture of the original implementation closely, keeping the bugs and missing features.</p>
<h2 dir="auto"><a id="user-content-usage" aria-hidden="true" href="#usage"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Usage</h2>
<p dir="auto">To compile the compiler:</p>
<div data-snippet-clipboard-copy-content="# install 32-bit libraries
sudo apt-get install gcc-multilib

make
./c72 examples/fizzbuzz.c fizzbuzz
./fizzbuzz"><pre><span><span>#</span> install 32-bit libraries</span>
sudo apt-get install gcc-multilib

make
./c72 examples/fizzbuzz.c fizzbuzz
./fizzbuzz</pre></div>
<p dir="auto">Note: if you get errors on missing &#34;bits/libc-header-start.h&#34; headers make sure you have the 32bit libc installed.</p>
<p dir="auto">I&#39;ve also attached an <a href="https://www.tuhs.org/cgi-bin/utree.pl?file=V5/usr/source/s1/cp.c" rel="nofollow">early implementation of cp</a> from UNIX v5. It worked with minor modifications with this compiler, on my Ubuntu 18.04. It&#39;s pretty neat, to have a nearly 50 years old code compile with a nearly 50 years old compiler and run on a modern OS!</p>
<h2 dir="auto"><a id="user-content-differences-to-modern-c" aria-hidden="true" href="#differences-to-modern-c"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Differences to modern C</h2>
<p dir="auto">This version of C is from around 1972. While the general syntax is pretty much the same as today,
there are tons of missing features:</p>
<ul dir="auto">
<li>no preprocessor, no for loops</li>
<li>bitwise NOT and XOR is not implemented</li>
<li>no short-circuiting AND and OR</li>
<li>even though there is a keyword for <code>float</code> and <code>double</code>, floating point calculations are not implemented, you can not even write a floating point literal</li>
<li>the type system is very weak: pointers, chars, ints can be freely converted into one another</li>
<li>types of the function parameters are not checked, anything can be passed to any function</li>
<li>compound assignment operators are reversed, they are <code>=+</code>, <code>=*</code></li>
<li>only integer global variables can be defined, and the syntax is strange:</li>
</ul>
<div data-snippet-clipboard-copy-content="/* defines globalvar to have the value of 2 */
globalvar 2;

/* equivalent to int globalarr[]={1, 2, 3}; */
globalarr[] 1, 2, 3;"><pre><code>/* defines globalvar to have the value of 2 */
globalvar 2;

/* equivalent to int globalarr[]={1, 2, 3}; */
globalarr[] 1, 2, 3;
</code></pre></div>
<ul dir="auto">
<li>variable names can be of any length but only the first 8 characters are used; i.e. deadbeef1 and deadbeef2 are effectively the same variables</li>
</ul>
<h2 dir="auto"><a id="user-content-internals" aria-hidden="true" href="#internals"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Internals</h2>
<p dir="auto">The compiler has two stages: <code>c0</code> and <code>c1</code>. <code>c0</code> parses the input C file and generates a half-assembly half-parsed syntax tree temporary file. It is not meant to make the second stage easily portable, rather the memory restrictions of the PDP-11 made the split necessary. Then <code>c1</code> generates the final assembly, translating the syntax trees to actual code.</p>
<p dir="auto"><code>c0</code> is a fairly straightforward parser. One interesting bit is that <code>a[b]</code> is parsed and then converted to <code>*(a+b)</code> already in this very early version of C (if you  are not familiar with the C standard, <code>a[b]</code> is defined to be equivalent to <code>*((a)+(b))</code>).</p>
<p dir="auto"><code>c1</code> uses a set of code-generation tables to create the final assmebly. For example, addition is defined as:</p>

<p dir="auto">The part starting with <code>%</code> is the pattern the syntax tree has to match. This pattern means the first operand can be anything (<code>n</code>), the second operand is a word sized (<code>w</code>) variable (<code>a</code> - addressible). Then the code generation instructions say that calculate and place the first operand in the current register (<code>F</code>), and create an <code>add</code> instruction where the source argument is the address of the second operand (<code>A2</code>) and the target argument is the current register (<code>R</code>).</p>
<div data-snippet-clipboard-copy-content="mov $2, %eax
add 4(%ebp), %eax"><pre><span>mov</span> <span>$</span><span>2</span><span>,</span><span> %</span><span>eax</span>
<span>add</span><span> </span><span>4</span><span>(%</span><span>ebp</span><span>)</span><span>,</span><span> %</span><span>eax</span></pre></div>
<p dir="auto">Here I assumed that <code>x</code> is the first parameter of the function so it is placed right after the stack frame.</p>
<p dir="auto">If you are interested in a more in-depth description see Dennis Ritchie&#39;s <a href="https://nickdrozd.github.io/vegesm/c72/blob/master/docs/ctour.pdf">A Tour through the UNIX C compiler</a>. Although it is for a newer version with some differences, it is still helpful to understand <code>c1</code>.</p>
</article>
          </div></div>
  </body>
</html>
