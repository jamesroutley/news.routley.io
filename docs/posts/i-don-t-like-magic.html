<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://adactio.com/journal/22399">Original</a>
    <h1>I Don&#39;t Like Magic</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
<p>I don’t like magic.</p>

<p>I’m not talking about acts of prestidigitation and illusion. I mean the kind of magic that’s used to market technologies. It’s magic. It just works. Don’t think about it.</p>

<p>I’ve written about <a href="https://adactio.com/journal/6786">seamless and seamful design</a> before. Seamlessness is often touted as the ultimate goal of UX—“don’t make me think!”—but it comes with a price. That price is the reduction of agency.</p>

<p>When it comes to front-end development, my distrust of magic tips over into being a complete control freak.</p>

<p>I don’t like using code that I haven’t written and understood myself. Sometimes its unavoidable. I use two JavaScript libraries on <a href="https://thesession.org/">The Session</a>. One for displaying interactive maps and another for generating sheet music. As dependencies go, they’re very good but I still don’t like the feeling of being dependant on anything I don’t fully understand.</p>

<p>I can’t stomach the idea of using npm to install client-side JavaScript (which then installs more JavaScript, which in turn is dependant on even more JavaScript). It gives me the heebie-jeebies. I’m kind of astonished that most front-end developers have normalised doing daily trust falls with their codebases.</p>

<p>While I’m mistrustful of libraries, I’m completely allergic to frameworks.</p>

<p>Often I don’t distinguish between libraries and frameworks but the distinction matters here. Libraries are bits of other people’s code that I call from my code. Frameworks are other people’s code that call bits of my code.</p>

<p>Think of React. In order to use it, you basically have to adopt its idioms, its approach, its syntax. It’s a deeper level of dependency than just dropping in a regular piece of JavaScript.</p>

<p>I’ve always avoided client-side React because of its direct harm to end users (over-engineered bloated sites that take way longer to load than they need to). But the truth is that I also really dislike the extra layer of abstraction it puts between me and the browser.</p>

<p>Now, whenever there’s any talk about abstractions someone inevitably points out that, <a href="https://www.anildash.com/2026/02/11/coding-agents-as-the-new-compilers/">when it comes to computers, there’s always <em>some</em> layer of abstraction</a>. If you’re not writing in binary, you don’t get to complain about <a href="https://front-end.social/@leaverou/115991923267136151">an extra layer of abstraction</a> making you uncomfortable.</p>

<p>I get that. But I still draw a line. When it comes to front-end development, that line is for me to stay as close as I can to raw HTML, CSS, and JavaScript. After all, that’s what users are going to get in their browsers.</p>

<p>My control freakery is not typical. It’s also not a very commercial or pragmatic attitude.</p>

<p>Over the years, I’ve stopped doing front-end development for client projects at work. Partly that’s because I’m pretty slow; it makes more sense to give the work to a better, faster developer. But it’s also because of my aversion to React. Projects came in where usage of React was a foregone conclusion. I wouldn’t work on those projects.</p>

<p>I mention this to point out that you probably shouldn’t adopt my inflexible mistrustful attitude if you want a career in front-end development.</p>

<p>Fortunately for me, front-end development still exists outside of client work. I get to have fun with my own website and with The Session. Heck, they even let me build the occasional hand-crafted website for a Clearleft event. I get to do all that <a href="https://thedolectures.com/talks/do-things-the-long-hard-stupid-way/">the long, hard stupid way</a>.</p>

<p>Meanwhile in the real world, the abstractions are piling up. Developers can now use large language models to generate code. Sometimes the code is good. Sometimes its not. You should probably check it before using it. But some developers just YOLO it straight to production.</p>

<p>That gives me the heebie-jeebies, but then again, so did npm. Is it really all that different? With npm you dialled up other people’s code directly. With large language models, they first slurp up everyone’s code (like, the whole World Wide Web), run a computationally expensive process of tokenisation, and then give you the bit you need when you need it. In a way, large language model coding tools are like a turbo-charged npm with even more layers of abstraction.</p>

<p>It’s not for me but I absolutely understand why it can work in a pragmatic commercial environment. Like <a href="https://alicebartlett.co.uk/blog/weaknotes-388">Alice said</a>:</p>

<blockquote>
  <p>Knitting is the future of coding. Nobody knits because they want a quick or cheap jumper, they knit because they love the craft. This is the future of writing code by hand. You will do it because you find it satisfying but it will be neither the cheapest or quickest way to write software.</p>
</blockquote>

<p>But <a href="https://daverupert.com/2026/02/magic-words/">as Dave points out</a>:</p>

<blockquote>
  <p>And so now we have these “magic words” in our codebases. Spells, essentially. Spells that work sometimes. Spells that we cast with no practical way to measure their effectiveness. They are prayers as much as they are instructions.</p>
</blockquote>

<p>I shudder!</p>

<p>But again, this too is nothing new. We’ve all seen those codebases that contain mysterious arcane parts that nobody dares touch. <em>cough</em>Webpack<em>cough</em>. The issue isn’t with the code itself, but with the <em>understanding</em> of the code. If the understanding of the code was in one developer’s head, and that person has since left, the code is dangerous and best left untouched.</p>

<p>This, as you can imagine, is a maintenance nightmare. That’s where I’ve seen the real cost of abstractions. Abstractions often really do speed up <em>production</em>, but you pay the price in maintenance later on. If you want to understand the codebase, you must first understand the abstractions used in the codebase. That’s a lot to document, and let’s face it, documentation is the first casuality of almost every project.</p>

<p>So perhaps my aversion to abstraction in general—and large language models in particular—is because I tend to work on long-term projects. This website and The Session have lifespans measured in decades. For these kinds of projects, maintenance is a top priority.</p>

<p>Large language model coding tools truly are magic.</p>

<p>I don’t like magic.</p>

</div></div>
  </body>
</html>
