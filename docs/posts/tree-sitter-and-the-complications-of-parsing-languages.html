<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.masteringemacs.org/article/tree-sitter-complications-of-parsing-languages">Original</a>
    
    <div id="readability-page-1" class="page"><div>
        <article>
        
        
        
            
        
        
            
        
        
            
                
            
            <img src="https://www.masteringemacs.org/static/img/fleuron2.gif"/>
            
<p>You might be surprised to hear when you visit a file in Emacs that the syntax highlighting you are shown on your screen is – most likely – a potpourri of regular expressions with a dash of functions and syntax table definitions. As it turns out, this approach is just about good enough right up until the point where it isn’t.</p><p>So there’s a whole host of features in Emacs that tries to work around the inevitable performance or parsing gaps, like giving up if the search space is too large; only partially scanning the buffer; and so on. So when the font locking turns to treacle, and if you’re trained in the eldritch arts, you might have strong opinions on arcana like <code>jit-lock-stealth-time</code> and <code>jit-lock-antiblink-grace</code>.</p><p>So why keep doing it that way, then? Well it’s more than good enough. I can think of very few examples where it wasn’t for me; but that’s not to say it’s the platonic ideal of what syntax highlighting should or ought to be, though.</p><p>But what’s more surprising is that’s how <em>most</em> IDEs and text editors work. Why?</p><p>Well, because it’s gosh-darn hard to do it the right way. The proper way is to start with a <em>grammar</em> of the language, usually Extended Backus-Naur Format, and work your way through its terse definitions of the language until you have a reasonable grasp of what you need to do and, ah — yes. Now you have to write the parser. And it mustn’t be slow, either; oh, and you have to make it work with broken code, too. Because that’s the resting state of all code that you are editing: as you type the syntax highlighter beavers away in the background to give you some semblance of what reality would look like, if only you’d <em>hurry up and make it syntactically correct</em>, thank-you-very-much.</p><p>If a regular expression is the answer that yields <em>two</em> problems (as the old joke goes), then this is surely the one that yields three or four.</p><p>Even if you did have the grammar and an able parser, the grammar might be wrong or it might lack sufficient context to parse it with that alone. For Python it’s good enough; for C or C++ then I wish you good luck. And for Perl (or whatever it’s called these days) only Larry Wall himself can save you.</p><p>It’s a hard problem, and many have had a bite of the cherry over the years with mixed results. Building a parser that can handle the unsteady state your ever-changing source code finds itself in is very, very difficult. You also need to generate incremental changes to the <em>tree</em> that your parser yields so it doesn’t have to redo the whole thing on every keypress. It’s a really hard problem, but the rewards are <em>so</em> worth it though:</p><ol type="1"><li>Perfect syntax highlighting.</li><li>Semantic clues, like: variables and function arguments are correctly highlighted in the scope they are relevant in; perfect navigational aids for function and class names; easy refactoring and so much more.</li><li>Inspectable tree that you can use to build out additional tooling relevant to a language.</li><li><em>Proper</em> multi-language support like Javascript + React-style JSX in the same page. Or PHP + HTML. Or Yaml + Jinja, etc. etc.</li></ol><p>And the list goes on.</p><h2 id="but-what-about-cedet">But what about CEDET?</h2><p>A long time ago a very smart guy named Eric Ludlam created <a href="http://cedet.sourceforge.net/">CEDET</a>, the <em>Collection of Emacs Development Environment Tools</em>, a large collection of development tools that aimed to give Emacs a complete IDE-like experience. Eric clearly worked a lot with C++ so that’s what it supported best most of all, but it supports many other common languages like Python, Java and Javascript.</p><p>But CEDET opted for something much cleverer than just a package for the C++ universe: he wrote the <em>Semantic Bovinator</em>, a parser designed to solve the four points I mentioned above. Unfortunately it never really caught on, even though an effort was made about 10 years ago to hulk smash parts of the code into Emacs proper, where big parts of it lives today. Some features like EDE (project management suite),Speedbar (a navbar), EIEIO (Common Lisp-style Classes) and Semantic Mode (the main draw of CEDET) made it into Emacs core.</p><p>(And yes, Eric clearly loved farm-themed naming schemes. Like the old nursery rhyme <em>Old Macdonald had a farm… EIEIO</em>)</p><p>You can try it right now in your Emacs: open up a Javascript, C/C++, Java, or Python file and type <code>M-x semantic-mode</code>. Now navigate with <code>M-x senator-xxxxx</code> or check out the Semantic keymap with: <code>C-c , C-h</code>. The grammar files haven’t been updated in a long while so it’s possible your code’s ahead of the grammar and it may fail; but still, a herculean effort, and <em>very</em> impressive. And I’ll bet you didn’t know Emacs had that for the better part of a decade.</p><p>I used CEDET for a while back in the day when it was still actively maintained, and in a parallel universe it might’ve been what we’d all be using today. It worked just shy of well enough for Python that I could not switch to it. It’s a shame it was dropped on the floor as it had everything: EDE the project management suite; semantic code search and completion in Semantic; Speedbar (<code>M-x speedbar</code>); SRecode, a templatized code generator, and so much more.</p><p>Which then brings me to the crux of the article: Tree Sitter.</p><h2 id="tree-sitter">Tree Sitter</h2><p>Enter <a href="https://github.com/tree-sitter/tree-sitter">tree sitter</a>. I believe it started its life as the semantic search feature on Github itself (hover your cursor over a function call and it’ll take you to its definition) where it’s in use to this day.</p><p>It’s quick, and it solves most of the problems I talked about earlier. It also has an impressive list of languages it supports and a <em>very</em> large community backing which is important. It’s also available in Emacs for you to use right now: <a href="https://github.com/emacs-tree-sitter/elisp-tree-sitter">Emacs Tree Sitter</a> and it’s on MELPA. Download, install, and type <code>M-x tree-sitter-hl-mode</code> in a buffer to try it out. It requires module support in your Emacs, though, but that’s usually not a problem with newer Emacsen.</p><p>So this is the future of incremental language parsing. And it’ll be the future, too, in Emacs, as there are considerations under way to include the bindings needed to talk to tree sitter directly.</p><p>But that’s not all. Tree sitter is easy to use, and it comes with a query language <em>that uses S-expressions</em> — which in my mind is fate alone that it was meant to be.</p><p>“But what about LSP?” I can hear some of you say. The reason (most) LSP servers don’t offer syntax highlighting is because of the drag on performance. Every keystroke you type must be sent to the server, processed, a partial tree returned, and your syntax highlighting updated. Repeat that up to 100 words per minute (or whatever your typing speed is) and you’re looking at a lot of cross-chatter that is just better suited for in-process communication. But of course that doesn’t mean it can’t replace the language parsing used for other features in LSP!</p><p>So I like to think of tree sitter’s role in Emacs as the spiritual successor to what Eric Ludlam started back in the day. It’s super quick and available with several bindings; it has an S-expression-based query language; and it supports dozens of languages out of the box, with more to come. And the author’s a really friendly guy, too.</p><p>Luckily the Emacs developers are debating the role and place it’ll have in Emacs, if any. I would be surprised if it does not find a home in Emacs core. Native bindings in Emacs and a long-term plan to rewrite major modes that stand to benefit from it the most is most likely going to happen in the next year or two.</p><h2 id="paredit-everywhere-meet-combobulate">ParEdit Everywhere: Meet Combobulate</h2><p><a href="https://www.emacswiki.org/emacs/ParEdit">ParEdit</a>, if you don’t know it, is a supercharged minor mode for LISP-likes. It comes with a large array of tools that operate on S-expressions like merging, joining, splitting and navigating. It’s both powerful and intuitive.</p><p>I only use maybe 15% of its capabilities but it greatly speeds up the tedium of refactoring elisp. It’s also a bit of a “holy grail” of what people want in <em>other</em> languages.</p><p>A decade ago I hacked paredit to kinda-sorta-but-not-really work on Python (yes, seriously) and although some of the features worked it was never really going to happen, but the idea stuck with me. Now that tree sitter (and the <em>excellent</em> Emacs Tree Sitter package) is a “thing” I had another crack at it, but this time written from scratch to better pander to the different types of programming languages.</p><img src="https://www.masteringemacs.org/static/uploads/combobulate-navigate.svg" width="700px"/><p>I call it <a href="https://github.com/mickeynp/combobulate">Combobulate</a>. You can download an alpha version and play around with it if you like. I’ve been dogfooding it for about 10-11 months and I’m finally going to stop kicking the can down the road and get it out there.</p><p>I think it works quite well. I’ll write about the many trials and tribulations of writing even just the bits you do see, as there’s a lot to be said for the way Emacs currently does navigation and editing and how to tie that in with the existing tools. I’m a big believer in Emacs’s take on navigation and editing, and I’m convinced there’s a way to merge the two worlds in a way that it doesn’t break localized editing and larger structural editing that combobulate is made for.</p><p>I’ll round it out and say that interacting with tree sitter’s concrete syntax tree makes it easy to do cool stuff with a handful of lines, but making something ergonomic and flexible that works across languages is <em>not</em>. That’s what took me the longest. That and making it somewhat performant.</p><p>But I’ll talk about that soon enough. But if you’re interested in playing around (and contributing, it’s easy!) then check it out and let me know what you think.</p>

        
    </article>
      </div></div>
  </body>
</html>
