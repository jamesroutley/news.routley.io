<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://matklad.github.io/2022/10/28/elements-of-a-great-markup-language.html">Original</a>
    <h1>Elements of a great markup language</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>To convert our nice, sweet syntax to general tree and than into the final output, we need some kind of a tool.
One way to do that is by direct translation from our source document to, eg, html.</p>
<p>Such one-step translation is convenient for all-inclusive tools, but is a barrier for extensibility.
Amusingly, AsciiDoctor is both a positive and a negative example here.</p>
<p>On the negative side of things, classical AsciiDoctor is an extensible Ruby processor.
To extend it, you essentially write a “compiler plugin” — a bit of Ruby code which gets hook into the main processor and gets invoked as a callback when certain “tags” are parsed.
This plugin interacts with the Ruby API of the processor itself, and is tied to a particular toolchain.</p>
<p>In contrast, asciidoctor-web, a newer thing (which non-the-less uses the same Ruby core), approaches the task a bit differently.
There’s no API to extend the processor itself.
Rather, the processor produces an abstract document tree, and then a user-supplied JavaScript function can convert that <em>piece of data</em> into whatever html it needs, by following a lightweight visitor pattern.
I think this is the key to a rich ecosystem:  strictly separate converting input text to an abstract document model from rendering the model through some template.
The two parts could be done by two separate processes which exchange serialized data.
It’s even possible to imagine some canonical JSON encoding of the parsed document.</p>
<p>There’s one more behavior where all-inclusive approach of AsciiDoctor gets in a way of doing the right thing.
AsciiDoctor supports includes, and they are textual, preprocessor includes, meaning that syntax of the included file affects what follows afterwards.
A much cleaner solution would have been to keep includes in the document tree as distinct nodes (with the path to the included file as an attribute), and let it to the output layer to interpret those as either verbatim text, or subdocuments.</p>
<p>Another aspect of composability is that the parsing part of the processing should have, at minimum, a lightweight, embeddable implementation.
Ideally, of course, there’s a spec and an array of implementations to choose from.</p>
<p>Markdown fairs fairly well here: there never was a shortage of implementations, and today we even have a bunch of different specs!</p>
<p>AsciiDoctor…​
Well, I am amazed.
The original implementation of AsciiDoc was in Python.
AsciiDoctor, the current tool, is in Ruby.
Neither is too embeddable.
<em>But!</em> AsciiDoctor folks are crazy, they compiled Ruby to JavaScript (and Java), and so the toolchain is available on JVM and Node.
At least for Node, I can confidently say that that’s a real production-ready thing which is quite convenient to use!
Still, I’d prefer a Rust library or a small WebAssembly blob instead.</p>
<p>A different aspect of composability is extensibility.
In Markdown land, the usual answer for when Markdown doesn’t quite do everything needed (i.e., in 90% of cases), the answer is to extend <em>concrete syntax</em>.
This is quite unfortunate, changing syntax is <em>hard</em>.
A much better avenue I think is to take advantage of the generic tree structure, and extend the <em>output</em> layer instead.
Tree-with-attributes should be enough to express whatever structure is needed, and than its up to the converter to pattern-match this structure and emit its special thing.</p>
<p>Do you remember the fancy two-column rendering above with source-code on the left, and rendered document on the right?
This is how I’ve done it:</p>
<div>
<div>
<pre><code><table><tbody><tr><td><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
</pre></td><td><pre>[.two-col]
--
```
[lowerroman]
. One
. Two
. Three
```

[lowerroman]
. One
. Two
. Three
--
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>That is, a generic block, with <code>.two-col</code> attribute and two children — a listing block and a list.
Then there’s a separate css which assigns an appropriate <code>flexbox</code> layout for <code>.two-col</code> elements.
There’s no need for special “two column layout” extension.
It would be perhaps <em>nice</em> to have a dedicated syntax here, but just re-using generic <code>--</code> block is quite ok!</p>
<div>
<table>
<tbody><tr>
<td>
<i title="Note"></i>
</td>
<td>
<p>Great markup language defines the semantics of converting text to a document tree, and provides a lightweight library to do the parsing.</p>
<p>Converting an abstract document tree to a specific output type is left to a thriving ecosystem of converters.
A particularly powerful form of converter allows calling user-supplied functions on document elements.
Combined with a generic syntax for nodes and attributes, this provides extensibility which is:</p>
<div>
<ul>
<li>
<p>Easy to use (there’s no new syntax to learn, only new attributes)</p>
</li>
<li>
<p>Easy to implement (no need to depend on internal API of particular converter, extension is a pure function from data to data)</p>
</li>
<li>
<p>Powerful (everything can be expressed as a tree of nodes with attributes)</p>
</li>
</ul>
</div>
</td>
</tr>
</tbody></table>
</div>
</div></div>
  </body>
</html>
