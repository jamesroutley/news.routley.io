<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.bitsnbites.eu/cisc-vs-risc-code-density/">Original</a>
    <h1>Debunking CISC vs. RISC code density</h1>
    
    <div id="readability-page-1" class="page"><article id="post-1241">
	
	<!-- .entry-header -->

	<div>
		
<p>A long standing misconception that dates back to the <a rel="noreferrer noopener" href="https://en.wikipedia.org/wiki/Reduced_instruction_set_computer" target="_blank">RISC</a> vs <a rel="noreferrer noopener" href="https://en.wikipedia.org/wiki/Complex_instruction_set_computer" target="_blank">CISC</a> debate of the 1980‚Äôs is that CISC ISA:s yield better machine code density than RISC ISA:s. At the time that was mostly true, but today (2022) the situation is different and such claims are no longer automatically true. Let us dissect the matter‚Ä¶</p>



<h2>TL;DR</h2>



<p>Scroll to the end for the graphs üìä ‚Ä¶</p>



<h2>What is code density?</h2>



<p>Code density is a measure of how much meaningful program code can be stored in a certain amount of space. The instruction set architecture of a CPU dictates how compact the machine code is, e.g. depending on which instructions it provides and how those instructions are encoded in memory.</p>



<h2>When does code density matter?</h2>



<p>When discussing code density it is important to understand what impact the size of the machine code has. A few different things are directly affected by code density, some of which were more important a few decades ago than they are today, and some of which are more important in embedded systems than in workstations or servers, for instance:</p>



<ul><li><strong>Storage size.</strong> When floppy disks and hard drives had limited storage size, even a few percent smaller code could matter. The same goes for programs that need to be stored in small ROM:s or flash memories on embedded devices.</li><li><strong>RAM size.</strong> When RAM was ridiculously expensive and you only had a few kilobytes of RAM, code size mattered.</li><li><strong>Network transfer speed / cost.</strong> When most programs consisted of program code (as opposed to large media assets) and transfer speed and costs were real issues (e.g. when loading a program over a <a rel="noreferrer noopener" href="https://en.wikipedia.org/wiki/Modem#Dial-up" target="_blank">dial-up modem line</a>), code size mattered.</li></ul>



<p>These are, however, mostly things of the past, and not something that would be strong selling points for a CPU these days.</p>



<p>On the other hand, there a couple of things where code density still matters today, perhaps even more so than a few decades ago:</p>



<ul><li><strong>Cache hit ratio.</strong> Assuming equal cache sizes, denser code means that a larger chunk of a program will fit in the instruction <a rel="noreferrer noopener" href="https://en.wikipedia.org/wiki/CPU_cache" target="_blank">cache</a>, and the lower level caches (L2, L3, ‚Ä¶) are less polluted by program code and can be used for data instead. This translates to better cache hit ratios, which in turn means faster program execution.</li><li><strong>Instruction fetch bandwidth.</strong> Assuming equal cache/memory bandwidths, denser code means that you will fetch more ‚Äúeffective work‚Äù into and out from your L1I cache on each clock cycle, which in turn means faster program execution.</li></ul>



<p>Still, keep in mind that we are usually only talking about small performance advantages as a result of denser code.</p>



<h2>Why was CISC code denser than RISC code?</h2>



<p>The main reasons for the better code density of CISC ISA:s are (or rather, were):</p>



<ul><li><strong>Variable length instructions. </strong>More common instructions are shorter. This utilizes the same size reducing principle as <a rel="noreferrer noopener" href="https://en.wikipedia.org/wiki/Huffman_coding" target="_blank">Huffman coding</a> for instance (i.e. more frequent symbols/instructions use fewer bits than less frequent symbols/instructions). In contrast some RISC ISA:s use fixed length instructions, which means that common instructions are usually longer than the corresponding CISC instruction.</li><li><strong>Memory operands.</strong> By allowing most instructions to operate directly on memory operands fewer instructions are needed for manipulating variables in memory compared to RISC ISA:s, which are typically <a href="https://en.wikipedia.org/wiki/Load%E2%80%93store_architecture" target="_blank" rel="noreferrer noopener">load-store architectures</a>. This also reduces the need for having many architectural registers, which in turn reduces the size of the instruction (fewer bits are required for encoding register operands).</li><li><strong>Specialized registers.</strong> Many CISC architectures use specialized registers, as opposed to general purpose registers that are found in most RISC architectures. In other words some registers can only be accessed by certain instructions or for certain purposes, and some registers are even implicitly used by certain instructions without having to specify them in the instruction word. This reduces the number of bits that are required to encode register operands.</li><li><strong>More powerful addressing modes.</strong> Many CISC ISA:s support fairly complex addressing modes, whereas in RISC ISA:s you need to use multiple simpler instructions to calculate complex addresses. This naturally translates to fewer instructions, and hence denser code, for CISC ISA:s.</li><li><strong>Handwritten assembly code.</strong> Many of the CISC ISA:s were designed to be ‚Äúhuman friendly‚Äù, and had instructions and addressing modes that made it fairly easy to write programs in assembly language instead of using a higher level language. When RISC machines came along they largely replied on compilers to do the heavy lifting of register allocation (error prone for a human) and composing more complex operations from multiple instructions. They were not meant to be programmed by hand. At this time compilers were not very good and often did not produce as compact code as a human would have done. In practice this gave CISC ISA:s an advantage in terms of code density (even if it was not as much of a technical advantage).</li></ul>



<p>Clearly these are convincing arguments, and they also held true back in the day when RISC machines were new. However things have changed.</p>



<h2>What has changed over the years?</h2>



<p>Several things have changed over the years that have reduced or even eliminated some of the advantages of CISC over RISC, for instance:</p>



<ul><li><strong>Less optimal CISC instruction encoding.</strong> As new instructions have been added to CISC ISA:s, new and longer instruction encodings must be used since the shorter encoding spaces have already been used up. This is especially notable for x86 that has seen several major architectural upgrades, without dropping backwards compatibility. For instance the addition of 64-bit integer arithmetic, extra registers (r8-r15) and a new floating-point paradigm (SSE2 replacing x87) has necessitated longer instruction encodings. This means that the instructions with the shortest encodings are not necessarily the most frequently used instructions anymore (in fact, several of the single-byte 8086 instructions are <em>never</em> used in modern x86 code).</li><li><strong>Compilers have improved alot.</strong> These days almost all code that a CPU runs is generated by a compiler, not a human, regardless if it is a CISC or a RISC CPU. The reason is that more often than not compilers are now better than humans at generating good machine code, and it is simply no longer worth the effort to hand-write assembly language (except for a few special cases). One effect of this is that code density for RISC machines has improved, while the code density advantage that CISC had from hand-optimized assembly code is no longer there.</li><li><strong>Compilers prefer RISC-style instructions.</strong> Both compilers and modern out-of-order CPU implementations tend to prefer RISC-like instructions and general purpose registers over specialized CISC constructs, which in turn has incentivized CISC CPU designers to have a RISC mindset when adding new instructions. The result is that compilers do not emit very ‚ÄúCISC:y‚Äù instructions that would potentially save on code size. Also, modern compilers like to inline code and allocate local variables and function arguments to registers (which is good for speed), which means that things like memory operands are not as important anymore.</li><li><strong>RISC ISA:s have added more powerful instructions.</strong> One of the traits of RISC ISA:s is that they have a limited instruction encoding space (whereas variable length CISC ISA:s have an almost infinite encoding space), which incentivizes RISC ISA designers to come up with clever and powerful instructions. While the early RISC ISA:s were pretty bare bones, more recent RISC ISA:s have included some interesting instructions (that never made it into CISC ISA:s for some reason). Among these are bit-field instructions that essentially do the work of 2-4 traditional bit manipulation instructions in a single instruction (as well as remove the need for traditional shift instructions), and integer multiply-and-add instructions (two instructions in one), etc. Another example is clever encoding of immediate values (numeric constants) so that most of the time you do not need to waste four bytes to represent a 32-bit numeric constant, for instance.</li></ul>



<p>All in all this has eliminated much of the ‚ÄúCISC advantage‚Äù when it comes to code density.</p>



<h2>Comparing code density is hard!</h2>



<p>So let us try and compare the code density of a few different architectures, but how?</p>



<p>Measuring or comparing code density for different architectures can be done in many different ways, and you will get different results with different meanings.</p>



<h3>Size of compiled programs</h3>



<p>The naive way to measure code density is to compare the binary size of the same program when it has been compiled for two different architectures, but this has several problems, including:</p>



<ul><li>Different code may be compiled for different architectures. For instance the program may have architecture dependent optimizations or ‚Äú<a rel="noreferrer noopener" href="https://en.wikipedia.org/wiki/Conditional_compilation" target="_blank">ifdefs</a>‚Äú.</li><li>There may be operating-system and/or platform differences (e.g. startup code, <a rel="noreferrer noopener" href="https://en.wikipedia.org/wiki/Application_binary_interface" target="_blank">ABI</a> differences, third party library differences, etc).</li><li>There may be differences in what parts of a program are statically or dynamically linked (statically linked code ends up in the program executable, while dynamically linked code does not). For instance, some parts of the standard C/C++ libraries may be statically or dynamically linked. Some parts may even be <a rel="noreferrer noopener" href="https://en.wikipedia.org/wiki/Inline_expansion" target="_blank">inlined</a> by the compiler.</li><li>There may be compiler differences. The decisions that a compiler make about optimizations etc may have a big impact on code size. Different architecture back ends of the same compiler, or even different versions of the same compiler may produce different code.</li><li>And so on‚Ä¶</li></ul>



<h3>Dynamic code density</h3>



<p>If we think about the effects of code density that we are interested in, i.e. instruction bandwidth and cache hit ratio, it is obvious that what we are really interested in is the <em>dynamic</em> code density. In other words: <em>What code density does the L1 instruction cache see?</em> That is very hard to measure accurately as it requires that you actually run the program, perhaps in some kind of simulator that models caches and/or reports which parts of the program are most frequently executed etc, and to compare different architectures you need to reproduce the exact same program flow on both architectures.</p>



<p>We will not go down that rabbit hole.</p>



<h3>Hand optimized assembler programs</h3>



<p>One way to compare the optimal code densities for different architectures is to hand-optimize selected programs by implementing them in assembly language and utilizing all the features of each ISA to the max. That way you eliminate compiler differences and inefficiencies.</p>



<p>A commonly cited paper, <em><a rel="noreferrer noopener" href="https://web.eece.maine.edu/~vweaver/papers/iccd09/iccd09_density.pdf" target="_blank">Code Density Concerns for New Architectures</a></em> by Vincent M. Weaver and Sally A. McKee, took this approach (it is well worth a read).</p>



<p>While this approach is interesting from an academic perspective and provides lots of good information for ISA design, it is not really representative for real world program code (and it is also very hard to do a fully objective comparison this way).</p>



<h3>Compile qualitatively selected code</h3>



<p>What we <em>can</em> do is to select different pieces of fully portable code that we <em>believe</em> is representative for average program execution, and compile it for different architectures, without linking in platform specific dependencies etc.</p>



<p>To be successful we at least need to manually inspect the generated machine code to verify that the compiler has done a decent job and that there are no obvious unfair differences between the architectures that we are comparing.</p>



<p>This is the method of choice for this article.</p>



<h2>Method</h2>



<p>A few selected software programs were compiled, but <em>not linked</em>, using GCC. The total size of the <a href="https://en.wikipedia.org/wiki/Code_segment" target="_blank" rel="noreferrer noopener">executable sections</a> (.text etc) was collected from the resulting object files using <a rel="noreferrer noopener" href="https://www.man7.org/linux/man-pages/man1/readelf.1.html" target="_blank">readelf</a>, and the total instruction count was collected by disassembling the object files with <a rel="noreferrer noopener" href="https://www.man7.org/linux/man-pages/man1/objdump.1.html" target="_blank">objdump</a>.</p>



<p>In an attempt to measure code density for modern CISC and RISC ISA:s, the following architectures were targeted:</p>



<figure><table><thead><tr><th>Architecture</th><th>Description</th></tr></thead><tbody><tr><td><a rel="noreferrer noopener" href="https://en.wikipedia.org/wiki/Z/Architecture" target="_blank">IBM z/Architecture</a></td><td>64-bit CISC, variable instruction length</td></tr><tr><td><a href="https://en.wikipedia.org/wiki/X86-64" target="_blank" rel="noreferrer noopener">x86_64</a></td><td>64-bit CISC, variable instruction length</td></tr><tr><td><a href="https://github.com/mrisc32/mrisc32" target="_blank" rel="noreferrer noopener">MRISC32</a></td><td>32-bit RISC, fixed instruction length</td></tr><tr><td><a rel="noreferrer noopener" href="https://en.wikipedia.org/wiki/AArch64" target="_blank">AArch64</a> (a.k.a ARM64)</td><td>64-bit RISC, fixed instruction length</td></tr><tr><td><a href="https://en.wikipedia.org/wiki/RISC-V" target="_blank" rel="noreferrer noopener">RISC-V</a> RV64 (with C extension)</td><td>64-bit RISC, variable instruction length</td></tr></tbody></table></figure>



<p>There are several other ISA:s that we could have looked at (e.g. i386, MIPS, Alpha, MC68k and ARMv7), but they are simply not representative for contemporary instruction set architectures, and there are really only two contemporary CISC ISA:s that come in modern, high performance implementations (x86_64 and z/Architecture). MRISC32 is obviously the odd one here, but it was mandatory since it is my own ISA.</p>



<p>The following software programs were compiled for the selected architectures (they were selected based on portability, identical behavior across architectures, lack of dependencies and ease of compilation):</p>



<figure><table><thead><tr><th>Software</th><th>Description</th></tr></thead><tbody><tr><td><a href="https://github.com/lz4/lz4" target="_blank" rel="noreferrer noopener">liblz4</a></td><td>Fast lossless compression library (only the library was compiled).</td></tr><tr><td><a href="https://www.sqlite.org/index.html" target="_blank" rel="noreferrer noopener">sqlite3</a></td><td>SQL database engine (only library was compiled, platform specific parts were disabled).</td></tr><tr><td><a href="https://github.com/mbitsnbites/mfat" target="_blank" rel="noreferrer noopener">mfat</a></td><td>Portable FAT file system library (only the library was compiled).</td></tr><tr><td><a href="https://github.com/michaelrsweet/mxml" target="_blank" rel="noreferrer noopener">mxml</a></td><td>XML parsing library (only the library was compiled).</td></tr><tr><td><a href="https://github.com/mbitsnbites/mc1-quake" target="_blank" rel="noreferrer noopener">Quake</a></td><td>Game by id Software (no platform specific code included).</td></tr></tbody></table></figure>



<p>GCC 12.1 was used for all architectures except MRISC32, for which GCC 13-trunk was used. The reason is that GCC 12.1 is provided by Ubuntu 22.04, while MRISC32 requires a <a rel="noreferrer noopener" href="https://github.com/mrisc32/mrisc32-gnu-toolchain" target="_blank">custom fork of GCC</a>.</p>



<p>The only compiler tuning flag that was used was -O3, which is the most common optimization level for release builds. The rationale is that we want the investigation to be representative for real world code that is normally executed on a CPU.</p>



<p>Relative results were generated for each software, and the results were then averaged together into a total result.</p>



<h3>Caveats</h3>



<p>Since the analysis was made on compiled object files without linking the programs, linker optimizations such as relaxation were not factored in. However the machine code was manually examined before and after linking to ensure that there would be no major differences.</p>



<h2>Results</h2>



<h3>Total program size</h3>



<figure><a href="https://www.bitsnbites.eu/wp-content/uploads/2022/12/code-size-1.png"><img width="800" height="397" src="https://www.bitsnbites.eu/wp-content/uploads/2022/12/code-size-1.png" alt="" srcset="https://www.bitsnbites.eu/wp-content/uploads/2022/12/code-size-1.png 800w, https://www.bitsnbites.eu/wp-content/uploads/2022/12/code-size-1-300x149.png 300w, https://www.bitsnbites.eu/wp-content/uploads/2022/12/code-size-1-768x381.png 768w" sizes="(max-width: 800px) 100vw, 800px"/></a></figure>



<p>As can be seen, RISC architectures enjoyed more compact code than CISC architectures. The most compact code was achieved for RISC-V (with its compressed instruction extension enabled).</p>



<h3>Total number of instructions</h3>



<figure><a href="https://www.bitsnbites.eu/wp-content/uploads/2022/12/instruction-count-1.png"><img loading="lazy" width="800" height="397" src="https://www.bitsnbites.eu/wp-content/uploads/2022/12/instruction-count-1.png" alt="" srcset="https://www.bitsnbites.eu/wp-content/uploads/2022/12/instruction-count-1.png 800w, https://www.bitsnbites.eu/wp-content/uploads/2022/12/instruction-count-1-300x149.png 300w, https://www.bitsnbites.eu/wp-content/uploads/2022/12/instruction-count-1-768x381.png 768w" sizes="(max-width: 800px) 100vw, 800px"/></a></figure>



<p>The total number of instructions was quite similar across the board, with a slight edge for RISC architectures with fixed length encodings.</p>



<p>Since every CPU has an upper limit to how many instructions it can decode every clock cycle, a lower instruction count for the same amount of work is usually a performance advantage.</p>



<p>RISC-V required a higher number of instructions to complete the same task as the other architectures, which is to be expected because of how minimalistic its instruction set is (e.g. common addressing modes are not supported so several instructions are needed where other architectures only require one instruction). The motivation is that the front end of high performance RISC-V implementations is expected to fuse several simple instructions into more complex internal instructions. Simpler RISC-V implementations will suffer a performance penalty, though, as less actual work can be done per clock cycle.</p>



<h3>Average instruction size</h3>



<figure><a href="https://www.bitsnbites.eu/wp-content/uploads/2022/12/instruction-size-1.png"><img loading="lazy" width="800" height="397" src="https://www.bitsnbites.eu/wp-content/uploads/2022/12/instruction-size-1.png" alt="" srcset="https://www.bitsnbites.eu/wp-content/uploads/2022/12/instruction-size-1.png 800w, https://www.bitsnbites.eu/wp-content/uploads/2022/12/instruction-size-1-300x149.png 300w, https://www.bitsnbites.eu/wp-content/uploads/2022/12/instruction-size-1-768x381.png 768w" sizes="(max-width: 800px) 100vw, 800px"/></a></figure>



<p>The average instruction size was about the same for x86_64 as it was for the fixed length RISC ISA:s (four bytes per instruction), and the z/Architecture instructions were even longer (about 20% longer than AArch64 for instance). The compressed RISC-V instructions were 25% shorter than for the fixed size RISC ISA:s.</p>



<h2>Conclusions</h2>



<p>From the results we can conclude that for real world code on modern architectures:</p>



<ul><li>CISC code is <em>not</em> denser than RISC code.</li><li>CISC instructions do <em>not</em> perform more work than RISC instructions.</li><li>CISC instructions are <em>not</em> shorter than RISC instructions.</li></ul>
			</div><!-- .entry-content -->

	<!-- .entry-footer -->
	
<!-- #comments -->

</article></div>
  </body>
</html>
