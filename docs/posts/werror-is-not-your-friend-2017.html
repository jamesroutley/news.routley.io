<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://embeddedartistry.com/blog/2017/05/22/werror-is-not-your-friend/">Original</a>
    <h1>-Werror Is not your friend (2017)</h1>
    
    <div id="readability-page-1" class="page"><article id="post-148">
		

	
	<div>
		<p><a href="https://embeddedartistry.com/blog/2017/05/22/">22 May 2017</a>  • Last updated 8 September 2023</p><p>I want to make a few points up front to short-circuit common misunderstandings with this article:</p>
<ol>
<li>I have a zero warning policy on my projects.</li>
<li>I turn on <em>a lot</em> of warnings. <code>-Wall</code>, <code>-Wextra</code>, and <a href="https://github.com/embeddedartistry/meson-buildsystem/blob/ec64fe6061e052c29d2cb7903f973e25d699cb0c/compiler/meson.build#L9">a whole host of specific warning flags</a>.</li>
<li>I supplement the compiler warnings with analysis from a suite of static analysis tools, including <code>cppcheck</code>, <code>clang-tidy</code>, and clang <code>scan-build</code>.</li>
<li>Zero-warning enforcement happens on the build server. Pull requests will be rejected and builds will be marked as failures if warnings are present.</li>
</ol>
<p>I have to state all of this because many people think that my dislike of <code>-Werror</code> means that I am lax on warnings. That’s simply not the case.</p>
<h2 id="So,-then,-what&#39;s-wrong-with--Werror?">So, then, what’s wrong with -Werror?</h2>
<p><code>-Werror</code> is a compiler flag that causes all compiler warnings to be treated as errors. Developers who enable <code>-Werror</code> are making a statement: we care about our code base, and we won’t accept warnings here. I understand the motivation for enabling the <code>-Werror</code> flag: I also have a zero-warning policy, and I hate when developers ignore warnings.</p>
<p>My opinion on <code>-Werror</code> is based on my experiences as an open-source maintainer, a consumer of other people’s code, and a consultant who is constantly jumping into new proprietary code bases. I almost always find myself frustrated by the presence of <code>-Werror</code>. Most commonly, I check out the project, attempt to build it, and see that it fails to compile because there is a warning. Why is my build failing if I made no changes and your code base allows zero warnings?</p>

<p>The reason: <code>-Werror</code> creates a project dependency on specific toolchain vendors and versions.</p>
<p>Different vendors have different warning sets and warning detection logic. Code that compiles with one toolchain warning-free may not do so with another toolchain. We often see this with our open-source projects. We primarily use Clang, and it is a common occurrence that our <a aria-describedby="tt" data-cmtooltip="&lt;div class=glossaryItemTitle&gt;Continuous Integration [CI]&lt;/div&gt;&lt;div class=glossaryItemBody&gt;Continuous Integration (CI) is a software development practice where members of a team integrate work frequently. Each integration is automatically verified by an automated build and test process, which detects integration errors as(...)&lt;/div&gt;" href="https://embeddedartistry.com/fieldmanual-terms/continuous-integration/" data-mobile-support="0" data-gt-translate-attributes="[{&#34;attribute&#34;:&#34;data-cmtooltip&#34;, &#34;format&#34;:&#34;html&#34;}]">CI</a> server will report a warning when compiling our “warning-free” code with GCC.</p>
<p>Whenever a new compiler version is released, new warnings are added, detection for existing warnings is improved, and experimental warnings may be promoted. Less commonly, new versions include other changes that can impact warning generation. One example that comes to mind is when GCC 5.1.0 changed the default <a aria-describedby="tt" data-cmtooltip="&lt;div class=glossaryItemTitle&gt;C&lt;/div&gt;&lt;div class=glossaryItemBody&gt;A general-purpose imperative programming language widely used for embedded systems development.&lt;/div&gt;" href="https://embeddedartistry.com/fieldmanual-terms/c/" data-mobile-support="0" data-gt-translate-attributes="[{&#34;attribute&#34;:&#34;data-cmtooltip&#34;, &#34;format&#34;:&#34;html&#34;}]">C</a> language standard from <code>gnu90</code> to <code>gnu11</code>.  Some warnings are only enabled when targeting C99 or later, so anyone relying on the default (which we don’t recommend) would have seen new warnings after updating.</p>
<p>Sometimes warnings are not even consistently generated with the same toolchain vendor and version. One example that comes to mind is <code>-Wunknown-pragmas</code>. I am in the habit of using <a href="https://gcc.gnu.org/onlinedocs/gcc/Darwin-Pragmas.html#Darwin-Pragmas"><code>#pragma mark</code></a> to provide nicer IDE interactions (e.g., sectioning code and adding “jump-to” points). Clang accepts this pragma without any problem. GCC will generate a warning when this is used. But the real problem is that <code>gcc</code> will recognize <code>#pragma mark</code> on MacOS, so you won’t see the warning until you build on another <a aria-describedby="tt" data-cmtooltip="&lt;div class=glossaryItemTitle&gt;Operating System [OS]&lt;/div&gt;&lt;div class=glossaryItemBody&gt;System software that manages computer hardware, software resources, and provides common services for computer programs.&lt;/div&gt;" href="https://embeddedartistry.com/fieldmanual-terms/operating-system/" data-mobile-support="0" data-gt-translate-attributes="[{&#34;attribute&#34;:&#34;data-cmtooltip&#34;, &#34;format&#34;:&#34;html&#34;}]">OS</a>.</p>
<p>In other cases, hard-coded warning flags themselves are the source of trouble. Someone using an older/different compiler may find that a particular warning flag is not supported. In many cases, this generates a warning (e.g., <code>-Wunknown-warning</code>).  With <code>-Werror</code>, this build will fail for the user.</p>
<div data-callout-metadata="" data-callout-fold="" data-callout="note">

<p>
Many <a aria-describedby="tt" data-cmtooltip="&lt;div class=glossaryItemTitle&gt;Build System&lt;/div&gt;&lt;div class=glossaryItemBody&gt;A build system is a tool that provides a consistent and reusable framework for defining and automating software construction, quality enforcement, and delivery processes.&lt;/div&gt;" href="https://embeddedartistry.com/fieldmanual-terms/build-system/" data-mobile-support="0" data-gt-translate-attributes="[{&#34;attribute&#34;:&#34;data-cmtooltip&#34;, &#34;format&#34;:&#34;html&#34;}]">build systems</a> provide capabilities for checking whether given compiler flags are supported. We recommend using these approaches over hard-coding flags.
</p>
</div>
<p>This toolchain dependency must be handled in one of a few ways:</p>
<ol>
<li>Documenting the supported toolchain(s)</li>
<li>Capturing the build environment</li>
<li>Ongoing maintenance to ensure that warnings are addressed for new compiler versions</li>
</ol>
<p>Yet, the most common experience we have is that the dependency is not documented and a captured build environment is not provided. With open-source projects, this can lead to a build failure. Within companies, a more common scenario is that a new hire follows the setup guide but can’t get the project to compile. Only after talking to the team do they learn that a specific compiler version has to be used to build the project.</p>
<h2 id="Enforce-Zero-Warnings-at-the-DevOps-Level">Enforce Zero Warnings at the DevOps Level</h2>
<p>I have zero-warning policy (and I try to get my clients to adopt one as well). This policy is enforced by our CI server. To ensure we have a decent level of coverage, we build our software with a minimum of Clang, GCC, and at least one cross-compiler.</p>
<p>Another benefit of the DevOps enforcement approach is that you can expand warning coverage beyond just compiler warnings. For example, we also include warnings from static analysis tools in our zero-warning policy. We can also use our CI tools to generate warnings when FIXME and TODO comments are found in code.</p>
<p>Regardless of the source, if warnings are detected, the server will block pull requests and fail builds. This all happens without requiring <code>-Werror</code>.</p>
<p>This is a pragmatic solution: we have a zero-warning policy, have it enforced automatically, but still enable someone to successfully compile our projects if they are using a newer/different toolchain that reveals new warnings.</p>
<p>Certainly, <code>-Werror</code> can be used as part of the DevOps enforcement method. The only downside to using <code>-Werror</code> as the enforcement mechanism is that you will not be able to get a complete picture of the warnings present in a given build. Allowing compilation to succeed enables you to generate a complete report for the developer.</p>
<h2 id="Refined-Warning-As-Error-Control">Refined Warning-As-Error Control</h2>
<p>Even without the blanket use of <code>-Werror</code>, there are still a number of warnings that should <em>always</em> trigger an error. You can do this by specifying <code>Werror=warning-name</code>, which will cause that specific warning to generate an error.</p>
<p>For example, a warning that I promote to an error is <code>-Wreturn-type</code>.</p>
<pre tabindex="0"><code>Missing return statement in function with return expected
aws.c:158:1: warning: control reaches end of non-void function [-Wreturn-type]
</code></pre>
<p>If your function <em>should</em> return a value but does not actually do so, your function is going to be returning unexpected data, leading to weird behavior. This type of warning is definitely worth promoting to an error in any case!</p>
<h2 id="Make--Werror-Optional">Make -Werror Optional</h2>
<p>When <code>-Werror</code> is used, I like to see it done as a configurable build option. This option can be used by the build server to enforce zero warnings. It can also be disabled if necessary, such as when a user can’t get a project to compile out-of-the-box due to a warning, or when you want to see the full set of warnings while migrating to a new toolchain version.</p>
<pre tabindex="0"><code>$ make all WARNINGS_AS_ERRORS=n
</code></pre>
<p>Some build systems, Meson, provide built-in options for this purpose. These should be preferred manually adding the <code>-Werror</code> flag in your build rules.</p>
<h2 id="Summary">Summary</h2>
<p>My objective was to communicate the more subtle implications of using <code>-Werror</code>. This flag adds a toolchain dependency to your project. Newer compiler versions (or alternative compiler vendors) are likely to generate new warnings, making the build fail.</p>
<p>If you’re going to use this flag, make sure you clearly note the version(s) your project is expected to work with (or completely capture your build environment). Ideally, the use of <code>-Werror</code> will be a configurable option in your <a aria-describedby="tt" data-cmtooltip="&lt;div class=glossaryItemTitle&gt;Build System&lt;/div&gt;&lt;div class=glossaryItemBody&gt;A build system is a tool that provides a consistent and reusable framework for defining and automating software construction, quality enforcement, and delivery processes.&lt;/div&gt;" href="https://embeddedartistry.com/fieldmanual-terms/build-system/" data-mobile-support="0" data-gt-translate-attributes="[{&#34;attribute&#34;:&#34;data-cmtooltip&#34;, &#34;format&#34;:&#34;html&#34;}]">build system</a>, regardless of whether or not is enabled by default.</p>
<p>You can achieve zero-warning policies through other means, and I prefer to do so with our DevOps pipeline.</p>
<p>Of course, everything has its tradeoffs. You might decide that <code>-Werror</code> really is the right tool for your team. Keep on, but take a moment to document or capture the build dependencies if you haven’t done so already.</p>

<ul>
<li>
<a href="https://flameeyes.blog/2009/02/25/future-proof-your-code-dont-use-werror/">Future proof your code: don’t use -Werror</a>
</li>
<li>
<a href="https://github.com/google/flatbuffers/issues/6337">Allow not setting -Werror conveniently · Issue #6337 · google/flatbuffers</a>
<blockquote><p>
there can be many situations why we want to compile old software with newer compilers and <code>-Werror</code> can break that easily although it seems an easily avoidable…
</p></blockquote>
<blockquote><p>
The point is that old software should continue to compile with newer compilers <em>without</em> manual intervention, at least where this is possible to achieve basically for free.
</p></blockquote>
</li>
</ul>

	</div>

	 
</article></div>
  </body>
</html>
