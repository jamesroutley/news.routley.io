<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://quuxplusone.github.io/blog/2023/09/08/constexpr-string-firewall/">Original</a>
    <h1>Just how constexpr is C&#43;&#43;20’s std:string?</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p>In C++20, <code>string</code> and <code>vector</code> are marked <code>constexpr</code>, which means they’re <em>somewhat</em>
usable in compile-time programming. For example, we can write:</p>

<div><div><pre><code>constexpr std::string firstName(std::string s) {
  size_t n = s.find_first_not_of(&#39; &#39;);
  if (n == s.npos)
    return &#34;&#34;;
  return s.substr(n, s.find(&#39; &#39;, n) - n);
}
constexpr std::string bard() {
  return &#34;William Shakespeare&#34;;
}
static_assert(firstName(bard()) == std::string(&#34;William&#34;));
</code></pre></div></div>

<p>and it will Just Work. But we can’t write this:</p>

<div><div><pre><code>constexpr std::string s = &#34;William Shakespeare&#34;;
</code></pre></div></div>

<p>What’s the deal?</p>

<h2 id="two-constraints-on-constexprness">Two constraints on constexprness</h2>

<p>A <code>constexpr</code> variable’s value (or a <code>constinit</code> variable’s initial value)
must be known at compile time. Therefore, our first constraint is that the
value can’t depend on any runtime input.</p>

<div><div><pre><code>int main(int argc, char**) {
  constexpr int n = argc; // Error
}
</code></pre></div></div>

<blockquote>
  <p>This snippet, and the next one, show <code>constexpr</code> stack variables.
In real life, there’s basically no reason ever to use <code>constexpr</code>
on a stack variable; you’ll use it only on globals or as part of the set phrase
<code>static constexpr</code>. But C++ physically allows <code>constexpr</code> even on stack variables,
so I use it here for simplicity.</p>
</blockquote>

<p>C++ treats memory addresses just as you’d expect if you know about ELF files.
The addresses of variables in the static data section (i.e. globals and function-local statics)
are treated as compile-time constants (because we can encode them in a single ELF relocation);
but any non-trivial math on those addresses becomes non-constant.
And the address of a stack variable is automatically non-constant.</p>

<div><div><pre><code>int main() {
  int x = 0;
  static int y = 1;
  constexpr int *p = &amp;x; // Error
  constexpr int *q = &amp;y; // OK
  constexpr intptr_t r = intptr_t(q) * 47; // Error
}
</code></pre></div></div>

<p>That is, C++ forbids data to flow “backward” from runtime back into compile-time.
You might say the laws of physics forbid that! How could we possibly use at compile time,
and encode into the data section, a numeric value that won’t be known until runtime?</p>

<blockquote>
  <p>Note that when I say “value,” what the C++ compiler hears is “object representation” —
the sequence of bytes that actually gets stored, even if that’s not the object’s “value”
in the Platonic sense. This will become important later.</p>
</blockquote>

<p>The second constraint is that C++ forbids certain data to flow “forward” from compile-time
into runtime. This constraint is slightly less obvious. Let’s look at it:</p>

<h2 id="constexpr-allocation-is-fake-allocation">Constexpr allocation is fake allocation</h2>

<p>Constexpr evaluation, ever since C++11, has always allowed us to do “stack allocation”
at compile time. This naïve <code>fib</code> function asks the compiler to allocate four bytes of
“stack memory” for each of <code>a</code> and <code>b</code> at the top level, and then again at the first level
of recursion, and again at the second level, and so on.</p>

<div><div><pre><code>constexpr int fib(int n) {
  if (n &lt;= 1) return n;
  int a = fib(n - 1);
  int b = fib(n - 2);
  return a + b;
}
static_assert(fib(10) == 55);
</code></pre></div></div>

<p>If this were a runtime function, it would just generate code to bump the stack pointer at
runtime. But at compile time, there is no <em>actual</em> stack; the compiler is just <em>pretending</em>
to run this code. The compiler somehow <em>pretends</em> to have access to a stack segment at compile time.
This little lie goes undetected, as long as we confine our use of that “fake” stack segment
to compile time. But it goes bad if a fake-stack address “escapes” out into the actual runtime
program (<a href="https://godbolt.org/z/47M97dh7G">Godbolt</a>):</p>

<div><div><pre><code>constexpr int *f() {
  int i = 42;
  return &amp;i;
}
constexpr int *p = f(); // Error!
int main() {
  printf(&#34;%p\n&#34;, (void*)p);
}
</code></pre></div></div>

<p>This program tries to print out <code>f</code>’s return value (as evaluated at constexpr time), but
that would be a pointer into the constexpr evaluator’s “fake” stack segment, which doesn’t actually exist
at runtime. The compiler rejects this program: the variable <code>p</code> (which is accessible by <code>main</code> at
runtime) can’t be initialized with a fake pointer value that doesn’t actually exist at runtime.</p>

<p>C++20 extends this same “fake memory” allocation mechanism to include heap allocation.</p>

<p>The compiler’s constexpr evaluator has no more access to the <em>actual</em> runtime heap than it
has to the <em>actual</em> runtime stack. It’s still just pretending.
But again its lies go undetected, as long as we confine our use of the fake heap segment
to compile time. <a href="https://godbolt.org/z/5EGqEWq54">Godbolt</a>:</p>

<div><div><pre><code>constexpr auto g() {
  return std::make_unique&lt;int&gt;(42);
}
static_assert(*g() == 42); // OK
constexpr int i = *g(); // OK
constexpr bool gt = (g() != nullptr); // OK
constexpr auto p = g(); // Error!
</code></pre></div></div>

<p>On the last line, we attempt to “escape” the fake-heap pointer result of <code>g</code> into a variable
<code>p</code> that has a real existence at runtime. That’s not allowed; we get a compiler error instead.</p>

<h2 id="subtleties-of-string-and-vector">Subtleties of <code>string</code> and <code>vector</code></h2>

<p>Observe that merely <em>having</em> a runtime variable of type <code>string</code> or <code>vector</code> counts as “escaping”
a pointer to its data. We can’t write something like</p>

<div><div><pre><code>constexpr std::vector&lt;int&gt; v = {1, 2, 3};
</code></pre></div></div>

<p>because then we could try to print out the value of <code>(void*)v.data()</code> at runtime, and it would
be a pointer into the fake compile-time heap, and that’s not allowed. But we <em>can</em> say</p>

<div><div><pre><code>constexpr std::vector&lt;int&gt; v = {};
</code></pre></div></div>

<p>because an empty <code>vector</code> doesn’t hold a pointer to a heap-allocation. There’s nothing wrong
with “escaping” a null pointer from constexpr time into runtime!</p>

<h3 id="sso-matters">SSO matters</h3>

<p>libstdc++ and Microsoft STL both reject</p>

<div><div><pre><code>constexpr std::string author = &#34;William Shakespeare&#34;; // 19 chars: Error!
</code></pre></div></div>

<p>but accept</p>

<div><div><pre><code>constexpr std::string author = &#34;Shakespeare&#34;; // 11 chars: OK
</code></pre></div></div>

<p>The former string contains a pointer to an allocated buffer of chars on the fake compile-time heap.
The latter string, being short enough to fit in <a href="https://quuxplusone.github.io/blog/2019/08/02/the-tough-guide-to-cpp-acronyms/#sbo-soo-sso">SSO</a>, doesn’t.</p>

<h3 id="pointer-into-self-matters">Pointer-into-self matters</h3>

<p>libstdc++ rejects the following code (<a href="https://godbolt.org/z/1ErrKjdbq">Godbolt</a>).
(Microsoft accepts, but I think that might be an MSVC bug.)</p>

<div><div><pre><code>int main() {
  static constexpr std::string abc = &#34;abc&#34;; // OK
  constexpr std::string def = &#34;def&#34;;        // Error!
}
</code></pre></div></div>

<p>The trick here is that libstdc++’s <code>std::string</code> always contains a pointer to its data,
roughly like this:</p>

<div><div><pre><code>struct string {
  char *data_ = &amp;sso_buffer_[0];
  union {
    char sso_buffer_[16];
    struct {
      size_t size_;
      size_t capacity_;
    };
  };
};
</code></pre></div></div>

<p>So <code>def</code>’s object representation contains a pointer to the memory address of <code>def.sso_buffer_</code>,
which is located inside object <code>def</code> on the <em>actual</em> runtime stack frame of <code>main</code>.
We’re asking for <code>def</code>’s value to be computed at compile time; but that value (which the compiler
hears as “object representation”) depends on <code>def</code>’s runtime address. That’s not a
compile-time constant. Thus, failure.</p>

<p>On the other hand, <code>abc</code>’s object representation depends merely on <code>abc</code>’s runtime address,
which is statically known (as far as C++ is concerned) because <code>abc</code> is in static storage.
The compiler just generates a relocation to the address of <code>abc</code> (plus eight or whatever) and we’re
good to go.</p>

<h3 id="libcs-sso-size-changes-at-compile-time">libc++’s SSO size changes at compile time</h3>

<p><a href="https://quuxplusone.github.io/blog/2019/02/20/p1144-what-types-are-relocatable/">Trivial relocatability fans</a> will be asking,
“If <code>string</code>’s pointer-into-self is a problem for libstdc++ and Microsoft, then what about libc++,
whose <code>string</code> doesn’t contain a pointer-into-self? Can libc++ handle an example like <code>def</code>?”</p>

<p>Sadly, no. libc++ makes a decision here that probably
seemed like a good idea back in 2020 when constexpr <code>std::string</code> was first being implemented
and nobody really knew how it was going to develop, but which seems indefensible in hindsight.
libc++ uses <a href="https://en.cppreference.com/w/cpp/language/if#Consteval_if"><code>if consteval</code></a> to change
the SSO buffer capacity of <code>string</code> in constant-evaluation contexts from 23 chars down to zero chars.
So libc++ is physically <em>able</em> to store short strings in a position-independent and thus <code>constexpr</code>-able
object representation; it just <em>chooses</em> never to do so. This means that on libc++ (only), you
aren’t even allowed to write</p>

<div><div><pre><code>constinit std::string s = &#34;&#34;;
</code></pre></div></div>

<p>at global scope. libc++ implements that empty string as a fake heap allocation of one byte (for the
null terminator), and that’s not <code>constinit</code>-able because it’d escape the fake pointer to runtime.</p>

<h2 id="bottom-line">Bottom line</h2>

<p>The <em>intended</em> use of constexpr <code>string</code> and <code>vector</code> is as local variables or return types of
constexpr or consteval functions, not as constexpr or constinit variables. Marking a <code>string</code>
or <code>vector</code> variable with the <code>constexpr</code> keyword is probably a bad idea. It can be done, but
the exact boundaries of what’s accepted will vary among STL vendors.</p>

  </div></div>
  </body>
</html>
