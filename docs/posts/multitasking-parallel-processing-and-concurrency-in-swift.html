<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://eclecticlight.co/2024/06/10/multitasking-parallel-processing-and-concurrency-in-swift/">Original</a>
    <h1>Multitasking, parallel processing, and concurrency in Swift</h1>
    
    <div id="readability-page-1" class="page"><article id="post-80896">
	
	<!-- .entry-header -->

	
		<div data-first_letter="I">
		<p>It has been a very long time since computers have executed code in a simple, linear manner. Even back in the 1950s, most used a system of <em>interrupts</em> or <em>traps</em> to handle errors, input/output, and other features, although those weren’t considered to be <em>multitasking.</em></p>
<p>In computers with a single processor core, multitasking was a way of cheating to give the impression that the processor was doing several things at once, when in fact all it was doing was switching rapidly between two or more different programs. There are two fundamental models for doing that:</p>
<ul>
<li><em>cooperative multitasking,</em> in which individual tasks yield to give others processing time;</li>
<li><em>preemptive multitasking,</em> in which a scheduler switches between tasks at regular intervals.</li>
</ul>
<p>When a processor switches from one task to the next, the current task state must be saved so that it can be resumed later. Once that’s complete, the next task is loaded to complete what’s known as a <em>context switch.</em> That incurs overhead, both in terms of processing and in memory storage. Inevitably, switching between lightweight tasks has less overhead. There have been different strategies adopted to determine the optimum size of tasks and overhead imposed by context switching, and terminology differs between them, variously using words such as <em>processes,</em> <em>threads</em> and even <em>fibres,</em> which can prove thoroughly confusing.</p>
<p>Preemptive multitasking was championed on larger computers and in Unix, but was seldom attempted in personal computers until the mid-1980s. When the Macintosh was released forty years ago, its Motorola 68000 processor had insufficient memory and was short of computing power to make it a good candidate for multitasking. <a href="https://en.wikipedia.org/wiki/Andy_Hertzfeld" target="_blank" rel="noopener">Andy Hertzfeld</a> wrote Switcher for Classic Mac OS in 1984-85 to enable the user to switch between apps, and that led to <a href="https://en.wikipedia.org/wiki/MultiFinder" target="_blank" rel="noopener">MultiFinder</a> in 1987, bringing cooperative multitasking.</p>
<p>At the same time, Apple developed a variant of the Macintosh II with a Paged Memory Management Unit (PMMU) to support virtual memory, and in February 1988 it released the first Unix for Macintosh, <a href="https://en.wikipedia.org/wiki/A/UX" target="_blank" rel="noopener">A/UX</a>, complete with preemptive multitasking. But Mac OS didn’t gain true preemptive multitasking until the release of Mac OS X 12 years later.</p>
<p>Cooperative multitasking worked well much of the time, but let badly behaved tasks hog the processor and block other tasks from getting their fair share. It was greatly aided by the <em>main event loop</em> at the heart of Mac apps that waited for control input to direct the app to perform work for the user. If an app charged off to spend many seconds tackling a demanding task, without polling the main event loop, that app could lock the user out for what seemed like an age.</p>
<p>As IBM was developing its first Personal Computer, and Apple its first Macintosh, on the other side of the Atlantic in England two engineers, David May and Robert Milne, were developing an alternative approach to computing based on a parallel architecture of multiple high-speed processors connected by high-speed serial links, the <a href="https://en.wikipedia.org/wiki/Transputer" target="_blank" rel="noopener">Transputer</a>. In 1985, their company Inmos released its first usable chip, the T414 Transputer, a 32-bit parallel processor with 2 KB of on-board memory and running at up to 20 MHz, with four serial links at up to 20 Mb/s.</p>
<p>Two years later, in 1987, their second-generation chip, the T800, started shipping in small quantities and at high cost because of initial low yields. Its major advance was a 64-bit floating-point unit implementing the new IEEE 7540-1985 standard for floating-point arithmetic. This also had a whole 4 KB of on-chip memory and could run at up to 25 MHz when you were lucky. For comparison, the single 68020 CPU in a Macintosh II of the same year ran at 16 MHz, and had a separate 68881 floating-point unit.</p>
<p>The Transputer wasn’t envisaged to be the sole processor type in a computer. Demonstration designs almost invariably interfaced them with an IBM PC, as an array of Transputers used as co-processors for computationally intensive tasks, of which the most popular was computing <a href="https://en.wikipedia.org/wiki/Mandelbrot_set" target="_blank" rel="noopener">Mandelbrot sets</a> for on-screen display. Matching the number of squares within an image to the number of T800 chips in an array enabled companies such as Meiko Scientific, Parsytec and Microway to enthuse potential customers. By the autumn of 1987, several major PC manufacturers were developing accelerator boards such as Commodore’s for its Amiga A2000, which relied on a Motorola 68000 as the main CPU.</p>
<p>Perhaps the biggest challenge for those intending to use Transputers was software support for these large farms of cores. David May and others at Inmos enlisted the help of Tony Hoare to develop a parallel programming language, <a href="https://en.wikipedia.org/wiki/Occam_(programming_language)" target="_blank" rel="noopener">occam</a> (perversely named with a small o), forming the software heart of the <a href="http://www.transputer.net/prog/72-trn-011-00/book.asp" target="_blank" rel="noopener">Transputer Development System</a>, TDS, inevitably nicknamed <em>tedious.</em> occam was different in that it required sequential instructions to be written explicitly, such as</p>
<p>Because of occam’s structure, its bundled code editor was probably the first to fold sections of code away to reveal its structure, in its spectacular folding editor. This took a similar approach to that now available in BBEdit when working with XML and similar documents.</p>
<p>By 1990, the Transputer was falling behind mainstream processor development, but it provided extensive experience in running code in parallel across multiple processor cores that was later used in the design of computer clusters. Between 2003-2006, Apple shipped thousands of Xserves with PowerPC G4 and G5 processors to build <a href="https://en.wikipedia.org/wiki/Computer_cluster" target="_blank" rel="noopener">supercomputer clusters</a>.</p>
<p>Apple’s first Macs with dual processors came in 2000, with PowerPC 7400 (G4) chips in Power Mac G4 desktop systems. In 2005, the Power Mac G5 was the first Mac to use dual-core PowerPC G5 processors, then the iMac 17-inch of 2006 used Apple’s first Intel Core Duo processor with two cores.</p>
<p>Since Apple has been switching architecture to its own chips from 2020, every Mac comes with multiple CPU cores of two different types, and runs macOS with its support for both preemptive and cooperative multitasking. What we have now, though, is the inverse of where this all started, multiple processor cores on which threads are really executing simultaneously, and have no need to pretend. For those, Swift 6 supports structured concurrency to address many of the problems encountered in parallel processing and cooperative multitasking.</p>
<p>For the sake of example, assume an app needs to access two types of remote information stored in Property Lists on a server somewhere. One type it parses into a list of Updates, the other into a list of Versions. Because those have to be fetched over the network, building those lists could take some seconds, and on occasion might fail altogether. One way to tackle this is with a function loadUpdatesAndVersions() shown below.</p>
<p><span><img data-attachment-id="80898" data-permalink="https://eclecticlight.co/swiftstrucconcurrency1/" data-orig-file="https://eclecticlight.co/wp-content/uploads/2024/06/swiftstrucconcurrency1.png" data-orig-size="1616,780" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="swiftstrucconcurrency1" data-image-description="" data-image-caption="" data-medium-file="https://eclecticlight.co/wp-content/uploads/2024/06/swiftstrucconcurrency1.png?w=300" data-large-file="https://eclecticlight.co/wp-content/uploads/2024/06/swiftstrucconcurrency1.png?w=940" src="https://eclecticlight.co/wp-content/uploads/2024/06/swiftstrucconcurrency1.png" alt="swiftstrucconcurrency1" width="1616" height="780"/></span></p>
<p>This first calls a child task asynchronously, which tries to load the Updates (shown in blue). As soon as that task is running, the main function calls a similar child task to load the Versions (blue). The main task is then suspended as it awaits the lists of Updates and Versions from those child tasks, in the last line of code, which returns the two lists to the rest of the app.</p>
<p>This may appear trivially simple, but building it into the Swift language enables replacement of a lot of contorted code that had been used previously.</p>
<p>In 40 years we have progressed from multitasking of single processors, and massively parallel computing, to cooperative multitasking of multiple cores. It has already been quite a journey.</p>
	</div><!-- .entry-content -->

	
	<!-- .entry-footer -->

</article></div>
  </body>
</html>
