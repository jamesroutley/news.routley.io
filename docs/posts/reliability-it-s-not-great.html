<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://community.fly.io/t/reliability-its-not-great/11253">Original</a>
    <h1>Reliability: It’s Not Great</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
          <p>The last four months have been rough. We’ve had more issues than we’re OK with.</p>
<p>I’ve hesitated to share this because, well, I’m fighting a debilitating feeling of failure. Fear, too. If we don’t improve, our company ceases to exist, and I really like working on this company.</p>
<p>One interesting problem we have is that we’ve exploded in popularity. It sounds like a good problem to have! But we’ve pushed the platform past what it was originally built to do. We’ve put a lot of work and resources into growing the platform and maturing our engineering organization. But that work has lagged growth.</p>
<p>This sucks for you all individually. You don’t really care about our popularity. I mean, a lot of you do. But, really, you just want to confidently ship your apps.</p>
<p>That’s what we want, too. It’s a grind, though, and I think we’re not as forward about our struggles as we should be. Y’all are devs, like us, and we should have been trusting you with the grimy details. So, here some of them are.</p>
<p>Our platform is a bunch of moving pieces that all need to work together so you can deploy an app, deploy it again, walk away, and then come back 24 months later and find out it’s still working. Here’s what goes into making that work:</p>
<ul>
<li>A centralized API that does auth and CRUD stuff against a database,</li>
<li>The WireGuard gateways <code>flyctl</code> uses to connect to your organization’s private network,</li>
<li>Remote Docker builder VMs <code>flyctl</code> uses to build your app into a Docker image,</li>
<li>A global Docker Image registry to hold those Docker images,</li>
<li>A secret storage Vault,</li>
<li>A scheduler that launches Docker images in VMs (that’s <a href="https://fly.io/blog/carving-the-scheduler-out-of-our-orchestrator/">Nomad</a> for most apps today),</li>
<li>Service discovery to propagates information about all the VMs running in our infrastructure,</li>
<li>The proxy that routes traffic to your app instances, and</li>
<li>Networking infrastructure to link apps up with each other.</li>
</ul>
<p>These have all failed in unique and surprising ways. Often, when this happens, we get lucky, and you don’t notice the hiccups. But sometimes we get unlucky.</p>
<p>In no particular order, here are some major incidents from the last 4 months:</p>
<ul>
<li>Service discovery &amp; Corrosion</li>
<li>Centralized secret storage</li>
<li>Postgres</li>
<li>Capacity issues</li>
<li>Volumes pinned to host hardware</li>
<li>Status paging</li>
</ul>
<h2>
<a name="service-discovery-amp-corrosion-1" href="#service-discovery-amp-corrosion-1"></a>Service discovery &amp; Corrosion</h2>
<p>We propagate app instance and health information across all our regions. That’s how our proxies know where to route requests, and how our DNS servers know what names to give out.</p>
<p>We started out using HashiCorp Consul for this. But we were shoehorning Consul, which has a centralized server model design for individual data center deployments, into a global service discovery role it wasn’t suited for. The result: continuously stale data, a proxy that would route to old expired interfaces, and private DNS that would routinely have stale entries.</p>
<p>All of this was a consequence of round-tripping every state update we had (every VM start and stop) through a central cluster of servers, often transcontinentally.</p>
<p>In response, we’ve shipped a project called Corrosion. Corrosion is a gossip based service discovery system. When a VM comes up, that host gossips the instance information. Corrosion’s goal is to propagate changes in under one second, globally (and to get as close to instant as possible).</p>
<p>The problem with Corrosion is that it’s new and gossip based consistency is a difficult problem.</p>
<p>We got Corrosion out the door quickly because Consul was causing problems for users. It’s new software, and it’s caused a pair of issues. Both manifested as corrupted global service discovery state. The first issue happened when one of our process spammed Corrosion with updates, essentially turning it into an internal DDoS. The second occurred during a routine update that unexpectedly messed up a database.</p>
<p>The effect of both of these issues was to break applications during deploys. As VMs came and went, our proxy and DNS servers would find themselves stuck working off stale data.</p>
<p>Corrosion needs to be more resilient to failure. We’re doing incremental things to improve it (rate limits, for instance, mitigate the “internal DDoS” risk). But we’re working on architectural changes, too. Gossip is hard because issues aren’t easy to trace to specific broken nodes, and it propagates quickly, which is what you don’t want when there’s a problem.</p>
<p>Moving off Nomad will also help mitigate Corrosion issues. Because Nomad creates entirely new instances for each deploy, there’s a lot of service discovery churn; many, many event updates per second. Fly Machine-based apps are less frantic – when we update an app running on Machines, we do it in place.</p>
<p>Finally, and this is sort of a general thing not just about service discovery: we deploy a lot of changes to our platform during the week. Sometimes, our changes have collided with yours; an ill-timed app deploy can leave that app in a wonky state. We’re updating our tooling so that app deploys are paused at these times, and when that happens, we’ll make it as obvious as possible why.</p>
<h2>
<a name="centralized-secret-storage-2" href="#centralized-secret-storage-2"></a>Centralized Secret Storage</h2>
<p>We store application secrets in HashiCorp Vault. HashiCorp Vault works a lot like Consul does, with a central cluster of servers.</p>
<p>The problems we have with Vault are less severe than the ones we had with Consul, but they rhyme with them. Every time a new VM boots, the worker running it has to pull secrets from Vault. There are two basic problems with this:</p>
<ol>
<li>
<p>Vault is in the US, internet connectivity between distant regions (like MAA) and the US can cause secret lookups to fail</p>
</li>
<li>
<p>There are failure scenarios that will make Vault inaccessible. For instance, we <a href="https://status.flyio.net/incidents/p95rfvl9lgc1">had a hardware</a> failure on one of our Vault servers that caused widespread VM creation failures.</p>
</li>
</ol>
<p>As with service discovery, these problems are exacerbated by Nomad and mitigated by Fly Machines. But new Fly Machine creation will also fail if Vault is in a bad state.</p>
<p>This is a theme. Existing open source is not designed for global deployment. So when we make the choice to “buy” existing infrastructure software, we’re often paying in part with global resilience.</p>
<h2>
<a name="postgres-3" href="#postgres-3"></a>Postgres</h2>
<p>Our Postgres clusters have had two major problems: (1) our reliance on Stolon and live connections to Consul clusters, and (2) the expectations we’ve set with “unmanaged Postgres”.</p>
<p>The first is an architectural problem. The Consul clusters Postgres depends on are different than the ones we use for service discovery, but they can still “fail” in strange ways. Stolon, the Postgres cluster software we built the first iteration of Fly Postgres on, doesn’t handle Consul connection issues well.</p>
<p>New Postgres clusters don’t use Stolon, and instead come up with <a href="https://community.fly.io/t/improved-postgres-clustering-with-repmgr-preview/10668"><code>repmgr</code></a>. <code>repmgr</code> handles leader election within the cluster, without needing a second database. These new Postgres clusters still use Consul to share configuration information, but if Consul melt downs, the cluster keeps going.</p>
<p>We are working on getting previously provisioned Postgres DBs upgraded to the new <code>repmgr</code> setup. There are complications, but we’ll keep posting about this.</p>
<p>The second problem we have with Postgres was a poor choice on my part. We decided to ship “unmanaged Postgres” to buy ourselves time to wait for the right managed Postgres provider to show up. The problem is, <code>fly pg create</code> implies that people are getting a managed Postgres cluster. That’s because every other provider with a “get an easy Postgres” feature gives you a managed stack to go with it.</p>
<p>This makes sense <em>now</em>, but was a surprising lesson for me. We ended up presenting a UX that promised a lot, then not following through. We’re not the type of company to writes value statements, but if we were, we’d write something like “don’t create nasty surprises by violating developer expectations”.</p>
<p>We’re going to solve managed Postgres. It’s going to take a while to get there, but it’s a core component of the infrastructure stack and we can’t afford to pretend otherwise.</p>
<h2>
<a name="capacity-issues-4" href="#capacity-issues-4"></a>Capacity issues</h2>
<p>An influx of new users ran us out of server capacity in multiple regions, sometimes more than once (hello, Frankfurt).</p>
<p>This was a failure on two levels: we didn’t buy servers fast enough, and we didn’t have good tools for taking pressure off specific regions.</p>
<p>Last year, I assumed that if we hit capacity issues, we could prevent <em>new</em> users from launching in specific regions. This didn’t pan out.</p>
<p>The Heroku exodus broke our assumptions. Pre-Heroku, most of the apps we were running were spread across regions. And: we were growing about 15% per month. But post-Heroku, we got a huge influx of apps in just a few hot spots — and at 30% per month.</p>
<p>In hindsight, I should have started acting like we were doing srsbzns much earlier, basically as soon as we had investor cash to spend.</p>
<p>We’re getting better with capacity planning and logistics. I was doing capacity planning as a side hustle to the rest of my job. The company needed to scale beyond my spreadsheet. We’ve hired here, and reorganized a bit; things are a little better now, and they will rapidly improve.</p>
<h3>
<a name="volumes-are-pinned-to-host-hardware-5" href="#volumes-are-pinned-to-host-hardware-5"></a>Volumes are pinned to host hardware</h3>
<p>The <code>fly volumes</code> command creates a block device on specific host hardware. When we first shipped this, we had a lot of content explaining the limitations of this approach. We designed our volumes to run in sets of 2+.</p>
<p>This means that if the host your volume is on goes down, your app goes down. If the host doesn’t have enough memory or CPU available to run your app VM, you may not be able to deploy.</p>
<p>Those details got lost as our docs improved, however, and it’s led to some nasty surprises. It’s also counterintuitive. People are used to AWS EBS magic. But our volumes aren’t EBS (I shipped the initial version of volumes myself!)</p>
<p>This is another case of the UX creating the wrong expectations.</p>
<h2>
<a name="status-paging-6" href="#status-paging-6"></a>Status paging</h2>
<p>We’re taking a lot of legitimate flak for vague-posting on our status page. Or not posting on our status page. All while we’re being shamelessly rah-rah about our tech stack in blog posts. Issues happen, and we have not communicated aggressively when they do. That makes us look out to lunch.</p>
<p>This is hard. Even this post is hard. Our egos are all wrapped up in this work. We want you to know everything that’s going on, but it’s easy to slip when we’re tired.</p>
<p>Some of the challenges I’ve written about here are Hard, in the CS sense of the word. But this problem isn’t. There’s no way to excuse it. We’re just going to be better at communicating immediately.</p>
<p>We’ve hired a really great person to build up our Infra/Ops organization. In addition to beefing up that team so that it’s no longer spread so thin it’s translucent, they’re also standardizing our incident responses. When the shit hits the fan, we want as few decisions to make as possible, so we can get information out quicker.</p>
<p>We’re also shipping a personalized status page. As our fleet grows, and we rack more and more servers, the chance of us experiencing a hardware failure at any given moment increases. This has made it tricky for us to keep a totally honest status page. The personalized status page will make it easier for us to tell specific customers impacted by hardware failures “hey, a drive died in this region, we’re working on it”.</p>
<hr/>
<p>This is going in the community forum specifically so you all can reply to it. You may throw tomatoes, if that’s your thing. Or ask questions. We’re in an awkward phase where the company isn’t quite mature enough to support the infrastructure we need to deliver a good developer UX, and we’re going to take the bad with the good until that changes.</p>
        </div></div>
  </body>
</html>
