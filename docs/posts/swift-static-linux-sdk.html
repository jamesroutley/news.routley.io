<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.swift.org/documentation/articles/static-linux-getting-started.html">Original</a>
    <h1>Swift Static Linux SDK</h1>
    
    <div id="readability-page-1" class="page"><div role="main">
  <article class="page">
  
    
      <header>
        
      </header>
    
  

  <p>It’s well known that Swift can be used to build software for Apple
platforms such as macOS or iOS, but Swift is also supported on other
platforms, including Linux and Windows.</p>

<p>Building for Linux is especially interesting because, historically,
Linux programs written in Swift needed to ensure that a copy of the
Swift runtime—and all of its dependencies—was installed on the
target system.  Additionally, a program built for a particular
distribution, or even a particular major version of a particular
distribution, would not necessarily run on any other distribution or
in some cases even on a different major version of the same
distribution.</p>

<p>The Swift Static Linux SDK solves both of these problems by allowing
you to build your program as a <em>fully statically linked</em> executable,
with no external dependencies at all (not even the C library), which
means that it will run on <em>any</em> Linux distribution as the only thing
it depends on is the Linux system call interface.</p>

<p>Additionally, the Static Linux SDK can be used from any platform
supported by the Swift compiler and package manager; this means that
you can develop and test your program on macOS before building and
deploying it to a Linux-based server, whether running locally or
somewhere in the cloud.</p>



<p><em>Linking</em> is the process of taking different pieces of a computer
program and wiring up any references between those pieces.  For
<em>static</em> linking, generally speaking those pieces are <em>object files</em>,
or <em>static libraries</em> (which are really just collections of object
files).</p>

<p>For <em>dynamic</em> linking, the pieces are <em>executables</em> and <em>dynamic
libraries</em> (aka dylibs, shared objects, or DLLs).</p>

<p>There are two key differences between dynamic and static linking:</p>

<ul>
  <li>
    <p>The time at which linking takes place.  Static linking happens when
you build your program; dynamic linking happens at runtime.</p>
  </li>
  <li>
    <p>The fact that a static library (or <em>archive</em>) is really a collection
of individual object files, whereas a dynamic library is monolithic.</p>
  </li>
</ul>

<p>The latter is important because traditionally, the static linker will
include every object explicitly listed on its command line, but it
will <em>only</em> include an object from a static library if doing so lets
it resolve an unresolved symbolic reference.  If you statically link
against a library that you do not actually use, a traditional static
linker will completely discard that library and not include any code
from it in your final binary.</p>

<p>In practice, things can be more complicated—the static linker may
actually work on the basis of individual <em>sections</em> or <em>atoms</em> from
your object files, so it may in fact be able to discard individual
functions or pieces of data rather than just whole objects.</p>

<h3 id="pros-and-cons-of-static-linking">Pros and Cons of Static Linking <a title="Permalink for Pros and Cons of Static Linking section" href="#pros-and-cons-of-static-linking">
            <!--?xml version="1.0" encoding="utf-8"?--> <svg width="24px" height="24px" viewBox="0 0 14 14" role="img" focusable="false" aria-hidden="true" xmlns="http://www.w3.org/2000/svg"><path d="m 11.58824,9.823529 q 0,-0.294117 -0.20589,-0.499999 L 9.85294,7.794118 q -0.20588,-0.205883 -0.5,-0.205883 -0.30882,0 -0.52941,0.235295 0.0221,0.02206 0.13971,0.136029 0.11764,0.113971 0.15808,0.158088 0.0404,0.04412 0.1103,0.139706 0.0698,0.09559 0.0956,0.1875 0.0257,0.09191 0.0257,0.202206 0,0.294117 -0.20588,0.5 -0.20588,0.205882 -0.5,0.205882 -0.1103,0 -0.20221,-0.02573 Q 8.35293,9.301471 8.25733,9.231621 8.16173,9.161771 8.11763,9.121327 8.07353,9.080887 7.95954,8.963238 7.84557,8.845591 7.82351,8.823533 7.58086,9.051474 7.58086,9.360297 q 0,0.294118 0.20588,0.5 l 1.51471,1.522059 q 0.19853,0.19853 0.5,0.19853 0.29412,0 0.5,-0.191177 l 1.08088,-1.073529 q 0.20589,-0.205883 0.20589,-0.492648 z M 6.41912,4.639706 q 0,-0.294118 -0.20588,-0.5 L 4.69853,2.617647 q -0.20588,-0.205882 -0.5,-0.205882 -0.28677,0 -0.5,0.198529 L 2.61765,3.683823 q -0.20589,0.205883 -0.20589,0.492648 0,0.294117 0.20589,0.499999 l 1.52941,1.529412 q 0.19853,0.19853 0.5,0.19853 0.30882,0 0.52941,-0.227942 Q 5.15437,6.15441 5.03676,6.040441 4.91912,5.92647 4.87868,5.882353 4.83828,5.838233 4.76838,5.742647 q -0.0698,-0.09559 -0.0956,-0.1875 -0.0257,-0.09191 -0.0257,-0.202206 0,-0.294117 0.20588,-0.5 0.20588,-0.205882 0.5,-0.205882 0.1103,0 0.20221,0.02573 0.0919,0.02573 0.1875,0.09559 0.0956,0.06985 0.1397,0.110294 0.0441,0.04044 0.15809,0.158089 Q 6.15443,5.154409 6.17649,5.176467 6.41914,4.948526 6.41914,4.639703 z M 13,9.823529 q 0,0.882353 -0.625,1.492647 l -1.08088,1.07353 Q 10.68382,13 9.80147,13 q -0.88971,0 -1.5,-0.625 L 6.78676,10.852941 Q 6.17647,10.242647 6.17647,9.360294 q 0,-0.904412 0.64706,-1.536764 L 6.17647,7.176471 Q 5.54412,7.82353 4.64706,7.82353 q -0.88235,0 -1.5,-0.617648 L 1.617647,5.676471 Q 1,5.058824 1,4.176471 1,3.294118 1.625,2.683824 L 2.70588,1.610294 Q 3.31618,1 4.19853,1 q 0.88971,0 1.5,0.625 l 1.51471,1.522059 q 0.61029,0.610294 0.61029,1.492647 0,0.904412 -0.64706,1.536764 L 7.82353,6.823529 Q 8.45588,6.17647 9.35294,6.17647 q 0.88235,0 1.5,0.617648 l 1.52941,1.529411 Q 13,8.941176 13,9.823529 z"></path></svg>
          </a></h3>

<p>Pros of static linking:</p>

<ul>
  <li>
    <p>No runtime overhead.</p>
  </li>
  <li>
    <p>Only include code from libraries that is actually needed.</p>
  </li>
  <li>
    <p>No need for separately installed dynamic libraries.</p>
  </li>
  <li>
    <p>No versioning issues at runtime.</p>
  </li>
</ul>

<p>Cons of static linking:</p>

<ul>
  <li>
    <p>Programs cannot share code (higher overall memory usage).</p>
  </li>
  <li>
    <p>No way to update dependencies without rebuilding program.</p>
  </li>
  <li>
    <p>Larger executables (though this can be offset by not having to
install separate dynamic libraries).</p>
  </li>
</ul>

<p>On Linux in particular, it’s also possible to use static linking to
completely eliminate dependencies on system libraries supplied by the
distribution, resulting in executables that work on any distribution
and can be installed by simply copying.</p>



<p>Before you start, it’s important to note:</p>

<ul>
  <li>
    <p>You will need to <a href="https://www.swift.org/install/">install an Open Source toolchain from
swift.org</a>.</p>
  </li>
  <li>
    <p>You cannot use the toolchain provided with Xcode to build programs
using the SDK.</p>
  </li>
  <li>
    <p>If you are using macOS, you will also need to ensure that you use
the Swift compiler from this toolchain by <a href="https://www.swift.org/install/macos/package_installer/">following the
instructions
here</a>.</p>
  </li>
  <li>
    <p>The toolchain must match the version of the Static Linux SDK that
you install.  The Static Linux SDK includes the corresponding Swift
version in its filename to help identify the correct version of the
SDK.</p>
  </li>
</ul>

<p>Once that is out of the way, actually installing the Static Linux SDK
is easy; at a prompt, enter</p>

<div><div><pre><code><span>$</span><span> </span>swift sdk <span>install</span> &lt;URL-or-filename-here&gt;
</code></pre></div></div>

<p>giving the URL or filename at which the SDK can be found.</p>

<p>For instance, assuming you have installed the
<code>swift-6.0-DEVELOPMENT-SNAPSHOT-2024-06-06-a</code> toolchain, you would
need to enter</p>

<div><div><pre><code><span>$</span><span> </span>swift sdk <span>install </span>https://download.swift.org/development/static-sdk/swift-DEVELOPMENT-SNAPSHOT-2024-06-06-a/swift-DEVELOPMENT-SNAPSHOT-2024-06-06-a_static-linux-0.0.1.artifactbundle.tar.gz
</code></pre></div></div>

<p>to install the corresponding Static Linux SDK.</p>

<p>Swift will download and install the SDK on your system.  You can get a
list of installed SDKs with</p>



<p>and it’s also possible to remove them using</p>

<div><div><pre><code><span>$</span><span> </span>swift sdk remove &lt;name-of-SDK&gt;
</code></pre></div></div>



<p>First, create a directory to hold your code:</p>



<p>Next, ask Swift to create a new program package for you:</p>

<div><div><pre><code><span>$</span><span> </span>swift package init <span>--type</span> executable
</code></pre></div></div>

<p>You can build and run this locally:</p>

<div><div><pre><code><span>$</span><span> </span>swift build
<span>Building for debugging...
[8/8] Applying hello
Build complete! (15.29s)
</span><span>$</span><span> </span>.build/debug/hello
<span>Hello, world!
</span></code></pre></div></div>

<p>But with the Static Linux SDK installed, you can also build Linux
binaries for x86-64 and ARM64 machines:</p>

<div><div><pre><code><span>$</span><span> </span>swift build <span>--sdk</span> x86_64-swift-linux-musl
<span>Building for debugging...
[8/8] Linking hello
Build complete! (2.04s)
</span><span>$</span><span> </span>file .build/x86_64-swift-linux-musl/debug/hello
<span>.build/x86_64-swift-linux-musl/debug/hello: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, with debug_info, not stripped
</span></code></pre></div></div>

<div><div><pre><code><span>$</span><span> </span>swift build <span>--sdk</span> aarch64-swift-linux-musl
<span>Building for debugging...
[8/8] Linking hello
Build complete! (2.00s)
</span><span>$</span><span> </span>file .build/aarch64-swift-linux-musl/debug/hello
<span>.build/aarch64-swift-linux-musl/debug/hello: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), statically linked, with debug_info, not stripped
</span></code></pre></div></div>

<p>These can be copied to an appropriate Linux-based system and executed:</p>

<div><div><pre><code><span>$</span><span> </span>scp .build/x86_64-swift-linux-musl/debug/hello linux:~/hello
<span>$</span><span> </span>ssh linux ~/hello
<span>Hello, world!
</span></code></pre></div></div>



<p>Swift packages that make use of Foundation or Swift NIO should just
work.  If you try to use a package that uses the C library, however,
you may have a little work to do.  Such packages often contain files
with code like the following:</p>

<div><div><pre><code><span>#if os(macOS) || os(iOS)</span>
<span>import</span> <span>Darwin</span>
<span>#elseif os(Linux)</span>
<span>import</span> <span>Glibc</span>
<span>#elseif os(Windows)</span>
<span>import</span> <span>ucrt</span>
<span>#else</span>
<span>#error(Unknown platform)</span>
<span>#endif</span>
</code></pre></div></div>

<p>The Static Linux SDK does not use Glibc; instead, it is built on top
of an alternative C library for Linux called
<a href="https://musl-libc.org">Musl</a>.  We chose this approach for two
reasons:</p>

<ol>
  <li>
    <p>Musl has excellent support for static linking.</p>
  </li>
  <li>
    <p>Musl is permissively licensed, which makes it easy to distribute
executables statically linked with it.</p>
  </li>
</ol>

<p>If you are using such a dependency, you will therefore need to adjust
it to import the <code>Musl</code> module instead of the <code>Glibc</code> module:</p>

<div><div><pre><code><span>#if os(macOS) || os(iOS)</span>
<span>import</span> <span>Darwin</span>
<span>#elseif canImport(Glibc)</span>
<span>import</span> <span>Glibc</span>
<span>#elseif canImport(Musl)</span>
<span>import</span> <span>Musl</span>
<span>#elseif os(Windows)</span>
<span>import</span> <span>ucrt</span>
<span>#else</span>
<span>#error(Unknown platform)</span>
<span>#endif</span>
</code></pre></div></div>

<p>Occasionally there might be a difference between the way a C library
type gets imported between Musl and Glibc; this sometimes happens if
someone has added nullability annotations, or where a pointer type is
using a forward-declared <code>struct</code> for which no actual definition is
ever provided.  Usually the problem will be obvious—a function
argument or result will be <code>Optional</code> in one case and non-<code>Optional</code>
in another, or a pointer type will be imported as <code>OpaquePointer</code>
rather than <code>UnsafePointer&lt;FOO&gt;</code>.</p>

<p>If you do find yourself needing to make these kinds of adjustments,
you can make your local copy of the package dependency editable by
doing</p>

<div><div><pre><code><span>$</span><span> </span>swift package edit SomePackage
</code></pre></div></div>

<p>and then editing the files in the <code>Packages</code> directory that appears in
your program’s source directory.  You may wish to consider raising PRs
upstream with any fixes you may have.</p>


  
    
  
</article>

</div></div>
  </body>
</html>
