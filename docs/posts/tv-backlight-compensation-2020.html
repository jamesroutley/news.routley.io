<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://www.lofibucket.com/articles/tv_backlight_compensation.html">Original</a>
    <h1>TV backlight compensation (2020)</h1>
    
    <div id="readability-page-1" class="page">
<p><a href="http://www.lofibucket.com"> back to lofibucket.com </a></p>

<p><em>Watching TV makes me see red!</em> I mean it in the literal sense: my Panasonic&#39;s backlight is slightly broken causing an uneven pink color when it should be white:</p>
<p><img src="http://www.lofibucket.com/articles/img/tv/badcolor.jpg"/>

</p>
<p>I got this clunker for free so I can&#39;t really complain, but a couple of weeks ago I finally decided to do something about the colors. So what <em>is</em> the issue?</p>
<h2 id="the-issue">The issue</h2>
<p>The backlight LED array doesn&#39;t emit enough blue or green light. This means most screen areas acquire a red tint. This is surprisingly passable in many films, but in black-and-white cinema it&#39;s pretty terrible. It&#39;s not possible to fix the red tint with regular color correction, since only some of the LEDs are broken. So maybe we could only tweak colors only near the broken LEDs?</p>
<div>
<p><img src="http://www.lofibucket.com/articles/img/tv/kaurism%C3%A4ki_before_thumb.jpg" alt="Red blotches become visible when watching &#34;Take Care of Your Scarf, Tatiana&#34;."/></p><p>Red blotches become visible when watching <em>&#34;Take Care of Your Scarf, Tatiana&#34;</em>.</p>
</div>
<p>Let&#39;s say we have an image <em>x</em> that the TV distorts into <em>y = f(x)</em>. We&#39;d like to find the inverse function <em>f<sup>-1</sup>(x)</em> that reverses the color distortion so that <em>y = f<sup>-1</sup>(f(x))</em>. We could then use it to compensate for the red colors before the image is sent over to TV.</p>
<div>
<p><img src="http://www.lofibucket.com/articles/img/tv/diagram.jpg" alt="The setup as a diagram. A corrected image f-1(x) leaves the computer via HDMI, gets distorted by TV&#39;s f(x), and the final color is seen by the observer."/></p><p>The setup as a diagram. A corrected image f<sup>-1</sup>(x) leaves the computer via HDMI, gets distorted by TV&#39;s f(x), and the final color is seen by the observer.</p>
</div>
<p>Unfortunately I happen to know such <em>f<sup>-1</sup>(x)</em> doesn&#39;t exist! As mentioned earlier, the partially operating backlight fails to emit some of the frequencies brightly enough. These can&#39;t be brought back with any preprocessing.</p>
<p>You might be thinking <em>&#34;Why can&#39;t you just dim green and blue channels instead?&#34;</em> and you&#39;d be right to think that since it&#39;s exactly what we are going to do. So the equation we want to satisfy will be</p>
<p>
<em>cy = f<sup>-1</sup>(f(x))</em>,
</p>
<p>where <em>c</em> is some constant, say <em>c = 0.9</em>, and <em>y</em> is the real image we want the observer to see. We accept that only 90% of the maximum brightness will be achieved. Now it&#39;s time to start looking for <em>f<sup>-1</sup></em>. As you saw in the beginning, the red tint varies across the screen, so a constant color correction of the image won&#39;t fly. Therefore it makes sense to try to capture the distortion so we can undo it.</p>
<h2 id="overengineering-a-solution">Overengineering a solution</h2>
<p>I put the TV to show a white screen and took a couple of photos with my phone to get an image of the uneven blob pattern. After some perspective correction and blurring in GIMP it looks like this:</p>
<div>
<p><img src="http://www.lofibucket.com/articles/img/tv/blobs.jpg" alt="The blob image is an average of three different pictures to break the moire pattern. It also has some Gaussian blur."/></p><p>The blob image is an average of three different pictures to break the moire pattern. It also has some Gaussian blur.</p>
</div>
<p>Intuitively, we want to reverse the effect of dim backlight pattern. So we should somehow &#34;subtract&#34; this image from the output image before it gets shown on the TV. But what concrete operation does this?</p>
<p>Let the original image be <em>x</em>, and the blob image be <em>z</em>. Let&#39;s make the assumption that the function <em>f<sup>-1</sup>(x)</em>, we are looking for is of the form <em>f<sup>-1</sup>(x) = x * (gain * z + offset)</em>, or as code:</p>
<div><pre><code>z <span>=</span> load_image(<span>&#34;blobs.png&#34;</span>)

<span>def</span> finv(x):
    <span>return</span> x <span>*</span> (gain <span>*</span> z <span>+</span> offset)</code></pre></div>
<p>where <code>gain</code> and <code>offset</code> are scalars. What&#39;s happening here is that we are first adjusting the colors of the blob image <em>z</em> and then modulating the original input with it. Now the problem boils down to finding good values for <code>gain</code> and <code>offset</code>.</p>
<h3 id="finding-the-inverse">Finding the inverse</h3>
<p>At this point things started to go off the rails. Instead of just trying to find the function by hand, I went for an &#34;optimization&#34; approach. Basically I plugged in a USB camera and pointed it at the TV screen, and wrote a Python script that tried random values for <code>gain</code> and <code>offset</code> until a good image was found. The setup then became this:</p>
<div>
<p><img src="http://www.lofibucket.com/articles/img/tv/diagram2.jpg" alt="Adding a camera in the loop. The camera sees the colors produced by the TV, distorts them again with its own response g(x), and sends the frame to the computer for analysis."/></p><p>Adding a camera in the loop. The camera sees the colors produced by the TV, distorts them again with its own response g(x), and sends the frame to the computer for analysis.</p>
</div>
<p>But how does the computer know what a good picture looks like? What is the fitness function? Can&#39;t you just compute a pixel-wise difference with <em>error = |x - camera_img|</em>? The problem with this approach is that the camera has color distortion of its own! That&#39;s what <em>g(x)</em> represents in the diagram. This makes formulating a meaningful fitness function more difficult.</p>
<p>After some fruitless attempts at simple image statistics, I realized it&#39;s possible to edit a camera picture by hand and use <em>that</em> as a ground truth.</p>
<p><img src="http://www.lofibucket.com/articles/img/tv/target_orig.jpg"/> <img src="http://www.lofibucket.com/articles/img/tv/target_edited.jpg"/></p>
<p><em>Original camera image (left) and the edited image (right) that became the ground-truth image.</em></p>
<p>Now it&#39;s possible to minimize the mean per-pixel difference between the image above and whatever is coming in from the camera. The loop is basically the following.</p>
<div><pre><code><span>import</span> numpy <span>as</span> np

z <span>=</span> load_image(<span>&#39;blobs.png&#39;</span>)
gt <span>=</span> load_image(<span>&#39;ground_truth.png&#39;</span>)

<span># Here we apply the &#34;c&#34; constant mentioned earlier in the article.</span>
gt <span>*=</span> <span>0.9</span>

<span># Indices into &#34;params&#34; array</span>
GAIN <span>=</span> <span>0</span>
OFFSET <span>=</span> <span>1</span>

params <span>=</span> np.zeros(<span>2</span>)
params[GAIN] <span>=</span> <span>1.0</span>
params[OFFSET] <span>=</span> <span>0.0</span>

<span># Our f^-1 function described earlier</span>
<span>def</span> finv(x):
    <span>return</span> x <span>*</span> (z <span>*</span> params[GAIN] <span>+</span> params[OFFSET])

best_fitness <span>=</span> <span>0</span>
best_params <span>=</span> np.copy(params)

<span>while</span> <span>True</span>:
    <span># &#34;frame&#34; is actually taken with a one second exposure to avoid noise</span>
    frame <span>=</span> capture_camera_img()

    <span># Assume the image intensities are in [0, 1] range.</span>
    <span># The fitness is one minus the L1 norm of pixel-wise difference.</span>
    fitness <span>=</span> <span>1</span> <span>-</span> np.mean(np.<span>abs</span>(frame <span>-</span> gt))

    <span>if</span> fitness <span>&gt;</span> best_fitness:
        best_fitness <span>=</span> fitness
        best_params <span>=</span> np.copy(params)
        <span>print</span>(best_fitness, best_params)

    <span># Randomize parameters</span>

    params[GAIN] <span>=</span> np.random.random() <span>*</span> <span>-</span><span>1</span>. <span>-</span> <span>0.1</span>   <span># range [-1.1, -0.1]</span>
    params[OFFSET] <span>=</span> np.random.random() <span>*</span> <span>2</span>         <span># range [0, 2]</span>

    <span># Update the picture shown on the TV.</span>
    <span># We show a corrected blank white image and judge on next frame how good it looked.</span>
    white_img <span>=</span> np.ones_like(frame)
    show_on_tv(finv(white_img))</code></pre></div>
<p>So which function did emerge as a winner? It&#39;s this one:</p>
<p>
<em>f<sup>-1</sup>(x) = x * (-0.9417 * z + 1.48125)</em>,
</p>
<p>where <em>z</em> is still the same blob image.</p>
<p>Here&#39;s how it looks like when applied to a video frame:</p>
<div>
<p><img src="http://www.lofibucket.com/articles/img/tv/fourway_comparison_thumb.jpg" alt="Results of the inverse function. Input images (left column) and the corresponding image on the TV (right column). The corrected input image is in the bottom left corner and has a greenish tint. However its result on the right has better balanced colors. Note that here also a global color correction of the final shader is included. Full size."/></p><p>Results of the inverse function. Input images (left column) and the corresponding image on the TV (right column). The corrected input image is in the bottom left corner and has a greenish tint. However its result on the right has better balanced colors. Note that here also a global color correction of the final shader is included. <a href="http://www.lofibucket.com/articles/img/tv/fourway_comparison.jpg">Full size.</a></p>
</div>
<p>In hindsight, it&#39;s pretty close to <em>f<sup>-1</sup>(x) = x * (-z + 1.5)</em> which is something one could&#39;ve guessed without any automated search. In addition, other solutions returned by the search were utter trash. But now is no time for regrets as we have the inverse function and it&#39;s time to use it!</p>
<h2 id="adding-a-custom-shader-to-mpc-be">Adding a custom shader to MPC-BE</h2>
<p>The whole point of this exercise was to make black-and-white movies look better. I decided to add a custom shader to the <a href="http://forum.doom9.org/showthread.php?t=165890">MPC-BE video player</a>. It would be nice to apply the corrective filter to the whole screen instead of just a video playing in an application, but I couldn&#39;t think of a way to do it. One cool thing about MPC-BE is that it has a live shader editor:</p>
<div>
<p><img src="http://www.lofibucket.com/articles/img/tv/shader_editor.png" alt="The MPC-BE live shader editor."/></p><p>The MPC-BE live shader editor.</p>
</div>
<p>The main problem here was that I had to pass in <code>blobs.png</code> image to the shader. It took a while but in the end I managed to hack in support for an external texture, and adjust the brightness and colors a bit. The end result is glorious:</p>
<div>
<p><img src="http://www.lofibucket.com/articles/img/tv/kaurism%C3%A4ki_anim.gif" alt="Color correction with f-1(x) helps a lot."/></p><p>Color correction with f<sup>-1</sup>(x) helps a lot.</p>
</div>
<p>It works! There&#39;s still a nasty vignetting effect going on near the edges. However the most annoying high frequency variation is gone. You can also view the full <a href="http://www.lofibucket.com/articles/img/tv/kaurism%C3%A4ki_before.jpg">before</a> and <a href="http://www.lofibucket.com/articles/img/tv/kaurism%C3%A4ki_after.jpg">after</a> shots.</p>
<h2 id="conclusion">Conclusion</h2>
<p>This particular TV has already been repaired twice, so it was nice to extend it&#39;s lifetime even further with a small hack. I haven&#39;t yet watched a whole movie with the new colors and it may turn out that small tweaks are still needed.</p>
<p>One aspect I didn&#39;t touch in this post is camera calibration. It took some thinking to find a simplest way to do it (no projection matrices involved) and it might be a topic for a future post.</p>
<h2 id="appendix-the-final-shader-colorfix.hlsl">Appendix: The final shader <code>colorfix.hlsl</code></h2>
<p>Assumes sampler <code>s0</code> has the input video and <code>s1</code> has the blob image.</p>
<div><pre><code><span>// $MinimumShaderProfile: ps_2_0</span>
sampler s0 : <span>register</span>(s0);
sampler s1 : <span>register</span>(s1);

float4 <span>main</span>(float2 tex : TEXCOORD0) : COLOR {
    float4 c0 = <span>tex2D</span>(s0, tex);
    float4 c1 = <span>tex2D</span>(s1, tex);
    float3 c1b = <span>float3</span>(-<span>0.9417</span>, -<span>0.9417</span>, -<span>0.9417</span>) * c1.<span>rgb</span> + <span>float3</span>(<span>1.48125</span>, <span>1.48125</span>, <span>1.48125</span>);

    float4 c2 = c0 * <span>float4</span>(c1b.<span>rgb</span>, <span>1</span>.);
    c2 *= <span>float4</span>(<span>1.05</span>, <span>1</span>., <span>1.15</span>, <span>1</span>.);
    c2 *= <span>0.95</span>;

    <span>return</span> c2 ;
}</code></pre></div>
<h2 id="appendix-mpc-be-patch">Appendix: MPC BE patch</h2>
<div><pre><code>Index: src/filters/renderer/VideoRenderers/SyncRenderer.cpp
<span>===================================================================</span>
<span>--- src/filters/renderer/VideoRenderers/SyncRenderer.cpp    (revision 5052)</span>
<span>+++ src/filters/renderer/VideoRenderers/SyncRenderer.cpp    (working copy)</span>
<span>@@ -45,6 +45,16 @@</span>
 #include &#34;../DSUtil/DXVAState.h&#34;
 #include &#34;../../../apps/mplayerc/resource.h&#34;
 
<span>+#define NOMINMAX</span>
<span>+#include &lt;algorithm&gt;</span>
<span>+namespace Gdiplus</span>
<span>+{</span>
<span>+   using std::min;</span>
<span>+   using std::max;</span>
<span>+}</span>
<span>+#include &#34;../../../apps/mplayerc/PngImage.h&#34;</span>
<span>+</span>
<span>+</span>
 using namespace GothSync;
 using namespace D3D9Helper;
 
<span>@@ -654,6 +664,45 @@</span>
    }
 
    hr = m_pD3DDevEx-&gt;ColorFill(m_pVideoSurfaces[m_iCurSurface], nullptr, 0);
<span>+   </span>
<span>+</span>
<span>+   CMPCPngImage pattern;</span>
<span>+   DLog(L&#34;Loading pattern texture&#34;);</span>
<span>+   // TODO use relative path</span>
<span>+   if (pattern.Load(L&#34;C:\\dev\\opensource\\mpcbe-code\\pattern2.png&#34;) == E_FAIL) {</span>
<span>+       DLog(L&#34;Loading failed&#34;);</span>
<span>+   } </span>
<span>+   else {</span>
<span>+       DLog(L&#34;Pattern: %dx%d @ %d bpp, IsDIB: %d&#34;, pattern.GetWidth(), pattern.GetHeight(), pattern.GetBPP(), pattern.IsDIBSection());</span>
<span>+       if (FAILED(hr = m_pD3DDevEx-&gt;CreateTexture(</span>
<span>+           pattern.GetWidth(), pattern.GetHeight(), 1, D3DUSAGE_DYNAMIC, D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT, &amp;m_pPatternTexture, nullptr))) {</span>
<span>+</span>
<span>+           DLog(L&#34;Texture creation failed&#34;);</span>
<span>+           return hr;</span>
<span>+       }</span>
<span>+       else {</span>
<span>+           DLog(L&#34;Pattern texture OK&#34;);</span>
<span>+           unsigned char* data = (unsigned char*)pattern.GetBits();</span>
<span>+           int pitch = pattern.GetPitch();</span>
<span>+           DLog(&#34;Data: %p, pitch: %d bytes\n&#34;, data, pitch);</span>
<span>+</span>
<span>+           D3DLOCKED_RECT rect = {};</span>
<span>+           m_pPatternTexture-&gt;LockRect(0, &amp;rect, NULL, D3DLOCK_DISCARD);</span>
<span>+           DLog(&#34;Rect pBits: %p, rect.pitch: %d bytes\n&#34;, rect.pBits, rect.Pitch);</span>
<span>+           for (int y = 0; y &lt; pattern.GetHeight(); y++) {</span>
<span>+               for (int x = 0; x &lt; pattern.GetWidth(); x++) {</span>
<span>+                   unsigned char* pix = (unsigned char*)rect.pBits + (y * rect.Pitch + 4 * x);</span>
<span>+                   pix[0] = data[y * pitch + 4 * x + 0];</span>
<span>+                   pix[1] = data[y * pitch + 4 * x + 1];</span>
<span>+                   pix[2] = data[y * pitch + 4 * x + 2];</span>
<span>+                   pix[3] = data[y * pitch + 4 * x + 3];</span>
<span>+               }</span>
<span>+           }</span>
<span>+</span>
<span>+           m_pPatternTexture-&gt;UnlockRect(0);</span>
<span>+       }</span>
<span>+   }</span>
<span>+   </span>
    return S_OK;
 }
 
<span>@@ -669,6 +718,7 @@</span>
    m_pRotateTexture = nullptr;
    m_pRotateSurface = nullptr;
    m_pResizeTexture = nullptr;
<span>+   m_pPatternTexture = nullptr;</span>
 }
 
 // ISubPicAllocatorPresenter3
<span>@@ -1483,6 +1533,8 @@</span>
                            Shader.Compile(m_pPSC);
                        }
                        hr = m_pD3DDevEx-&gt;SetPixelShader(Shader.m_pPixelShader);
<span>+</span>
<span>+                       hr = m_pD3DDevEx-&gt;SetTexture(1, m_pPatternTexture);</span>
                        TextureCopy(m_pScreenSizeTextures[src]);
 
                        std::swap(src, dst);
Index: src/filters/renderer/VideoRenderers/SyncRenderer.h
<span>===================================================================</span>
<span>--- src/filters/renderer/VideoRenderers/SyncRenderer.h  (revision 5052)</span>
<span>+++ src/filters/renderer/VideoRenderers/SyncRenderer.h  (working copy)</span>
<span>@@ -153,6 +153,7 @@</span>
        CComPtr&lt;IDirect3DSurface9&gt;  m_pOSDSurface;
        CComPtr&lt;IDirect3DTexture9&gt;  m_pScreenSizeTextures[2];
        CComPtr&lt;IDirect3DTexture9&gt;  m_pResizeTexture;
<span>+       CComPtr&lt;IDirect3DTexture9&gt;  m_pPatternTexture;</span>
        CComPtr&lt;ID3DXLine&gt;          m_pLine;
        CComPtr&lt;ID3DXFont&gt;          m_pFont;
        CComPtr&lt;ID3DXSprite&gt;        m_pSprite;</code></pre></div>
<h2 id="article-history">Article history</h2>
<ul>
<li>February 7, 2020
<ul>
<li>Fixed optimization loop code</li>
<li>A typo fixed</li>
</ul></li>
<li>February 6, 2020
<ul>
<li>Published</li>
</ul></li>
</ul>
<hr/>
<p>
For feedback email to <a href="mailto:pekka.vaananen@iki.fi">pekka.vaananen@iki.fi</a>
</p>


</div>
  </body>
</html>
