<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://asvarga.github.io/blog/2024/06/22/fair-chess-and-simultaneous-games.html">Original</a>
    <h1>Fair Chess and Simultaneous Games</h1>
    
    <div id="readability-page-1" class="page"><div data-md-component="container">
      
      
        
      
      <main data-md-component="main">
        <div>
          
            
              
                
              
              
            
            
              
                
              
              
            
          
          
  <div data-md-component="content">
    
    <article>
      
        
  
  

<nav>
  
    
    
    
      <a href="https://asvarga.github.io/wiki/index.html#game">Game</a>
    
  
    
    
    
      <a href="https://asvarga.github.io/wiki/index.html#parallelprogramming">ParallelProgramming</a>
    
  
</nav>



  

<p>The game of chess is famously flawed due to the <a href="https://en.wikipedia.org/wiki/First-move_advantage_in_chess">first-move advantage</a>, in which the player who moves first has a significant advantage. Let&#39;s fix it and make it fair.</p>
<!-- more -->

<h3 id="simultaneous-chess">Simultaneous Chess</h3>
<p>Perhaps the simplest way to get rid of a first-move advantage is to remove the first move: we&#39;ll consider chess variants where both players move simultaneously. This is a well-studied concept in game theory, called a <a href="https://en.wikipedia.org/wiki/Simultaneous_game">simultaneous game</a>. We might have a setup where in each round of play:</p>
<ol>
<li>Both players write down a move in <a href="https://en.wikipedia.org/wiki/Algebraic_notation_(chess)">algebraic notation</a>. I&#39;ll call this &#34;requesting&#34; a move.</li>
<li>Players reveal their moves simultaneously.</li>
<li>Their moves are both executed, possibly with some resolution of conflicts. I&#39;ll call this &#34;merging&#34; the moves.</li>
</ol>
<figure>
  <img src="https://asvarga.github.io/files/chess-1.png" width="400"/>
  <figcaption>Fig. 1 - Both players request Bh6; what happens?</figcaption>
</figure>

<p>The interesting part of designing such a simultaneous game is determining the rules for resolving merge conflicts in step 3. For example, what happens when both players move a piece to the same square? Some possibilities include:</p>
<ul>
<li>Both pieces are captured.</li>
<li>Both pieces stay at their original square.</li>
<li>The <a href="https://en.wikipedia.org/wiki/Chess_piece_relative_value">higher-valued</a> piece captures the lower-valued piece.</li>
<li>Pieces are animated one square at a time towards their destination, and the piece to arrive last captures the piece already there.</li>
<li>Players enter a boxing ring and fight for the square.</li>
</ul>
<h3 id="simultaneous-games-in-general">Simultaneous Games in General</h3>
<p>All of those conflict resolution rules are fair, but I&#39;m especially interested in rules that apply to <em>all</em> games. The problem with the resolutions above is that they are specific to the rules of chess. For example, they won&#39;t transfer to a game like tic-tac-toe where pieces aren&#39;t <em>moved</em> but rather <em>placed</em>.</p>
<figure>
  <img src="https://asvarga.github.io/files/tic-tac-toe-1.png" width="400"/>
  <figcaption>Fig. 2 - Both players request the center square; what happens?</figcaption>
</figure>

<p>In particular, I want a sort of function mapping turn-based input games to simultaneous games. Without getting too formal, these input games could be defined via their <a href="https://en.wikipedia.org/wiki/Game_tree">game trees</a> by providing:</p>
<ul>
<li>An initial game state</li>
<li>A partial function from game states and player moves to new game states</li>
<li>A partial function from game states to winning players</li>
</ul>
<p>It&#39;s important to note that the information about whose turn it is to move is not encoded in the game state, but rather in the player moves themselves. An implementation of these games would keep track of whose turn it is outside of the game state, like separating the chess clock&#39;s turn buttons from the chess board itself. This means that we&#39;ll have transitions out of states for all players.</p>
<figure>
  <img src="https://asvarga.github.io/files/game-tree-1.svg" width="400"/>
  <figcaption>Fig. 3 - Part of a game tree with transitions for multiple players out of a single state.</figcaption>
</figure>

<p>Given how opaque this general game interface is, there are only so many things we can do with it to build a simultaneous game. Lets start with:</p>
<blockquote>
<p><strong>Rule 1:</strong> Players may only submit moves that are legal in the input game.</p>
</blockquote>
<p>This might seem like an obvious rule to avoid trivial output games, but certain simultaneous chess variants don&#39;t require this rule. Consider the following moves:</p>
<figure>
  <img src="https://asvarga.github.io/files/chess-2.png" width="400"/>
  <figcaption>Fig. 4 - White preemptively tries to capture their own piece on f6.</figcaption>
</figure>

<p>White is assuming that Black will capture on <code>f6</code>, so White tries to &#34;premove&#34; to capture back on the same square. Such chess variants need to specify what happens when Black doesn&#39;t capture on <code>f6</code>. However, allowing moves like this is impossible in general simultaneous games because &#34;capturing one&#39;s own piece&#34; isn&#39;t a legal transition in the input game. It isn&#39;t in the game tree so it can&#39;t be described or requested through the opaque game interface.</p>
<p>Now we turn to the question of how to resolve conflicts in general. We&#39;ll stick to 2-player games for now, and generalize later. Again there are only so many things we can do, but I&#39;ll propose:</p>
<blockquote>
<p><strong>Rule 2:</strong> a. Moves are tried in both orders, and only moves that are legal in both orders are merged. b. If both moves are legal in both orders but a different game state is reached in each order, neither move is merged.</p>
</blockquote>
<p>This rule again uses none of the details of the input game and instead speaks opaquely about states and moves. I&#39;ll illustrate how this rule manifests in chess with a few examples:</p>
<figure>
  <img src="https://asvarga.github.io/files/chess-pawn-collision.png" width="400"/>
  <figcaption>Fig. 5 - Pawn Collision</figcaption>
</figure>

<p>In Fig. 5, both players try <code>e5</code>. If White goes first, Black is blocked. If Black goes first, White is blocked. Neither move is legal in both orders, so the moves are not merged.</p>
<figure>
  <img src="https://asvarga.github.io/files/chess-rook-collision.png" width="400"/>
  <figcaption>Fig. 6 - Rook Collision</figcaption>
</figure>

<p>In Fig. 6, both players try <code>Rf6</code>. The situation is actually the same as in Fig. 5 because the moves are not <code>Rxf6</code> captures, so again both moves are blocked. We could alternatively omit the capture annotation <code>x</code> from the definition of moves, but the result here would be the same.</p>
<figure>
  <img src="https://asvarga.github.io/files/chess-rook-block.png" width="400"/>
  <figcaption>Fig. 7 - Rook Block</figcaption>
</figure>

<p>In Fig. 7, White plays <code>Rf8</code> and Black plays <code>Rf6</code>. If White moves first, both moves are legal. If Black moves first, White is blocked. So only Black moves and White is blocked.</p>
<figure>
  <img src="https://asvarga.github.io/files/chess-rook-escape.png" width="400"/>
  <figcaption>Fig. 8 - Rook Escape</figcaption>
</figure>

<p>In Fig. 8, White plays <code>Rf3</code> and Black plays <code>Rxf6</code>. If White goes first, Black&#39;s move fails because it is a capture. If Black goes first, White is captured and unable to move. Ultimately Black holds White in place and neither move is merged.</p>
<p>All of these scenarios illustrate rule 2a. Rule 2b is in fact irrelevant for chess, because successful moves always commute.</p>
<p>One might wonder what happens if two &#34;stubborn&#34; players repeatedly try the same rule and are both blocked. We have a couple options, including:</p>
<ul>
<li>Forbid repeated moves until a successful move is made.</li>
<li>Apply a <a href="https://en.wikipedia.org/wiki/Threefold_repetition">threefold repetition</a> rule as in chess which results in a draw.</li>
<li>Do nothing and allow infinite games.</li>
</ul>
<h3 id="generalizing-to-2-players">Generalizing to &gt;2 Players</h3>
<p>Now I&#39;ll address games with more than two players. The rules above can be easily generalized to this case by replacing &#34;both&#34; with &#34;all&#34;. However with many players, this can lead to situations where very little happens, so we can do better.</p>
<p>In order to continue using chess examples while talking about games with more than 2 players, we&#39;ll need to modify our input game: Let each chess piece be controlled by a different player, with players split into teams based on color. Now we have 32 players, all of whom can move simultaneously! We should probably turn off friendly fire, but that&#39;s irrelevant for this discussion.</p>
<p>Now consider the following situation:</p>
<figure>
  <img src="https://asvarga.github.io/files/chess-block-3.png" width="400"/>
  <figcaption>Fig. 9 - Three rooks and a lot of blocking.</figcaption>
</figure>

<p>According to our current rules, only the white rook on <code>c5</code> should be allowed to move. However, the other white rook on <code>d4</code> might find this unfair: <code>c5</code>&#39;s move should block the black rook from blocking <code>d4</code>&#39;s move. This is what I mean by &#34;very little happening&#34; in games with many players. We can make the situation even more extreme:</p>
<figure>
  <img src="https://asvarga.github.io/files/chess-block-12.png" width="400"/>
  <figcaption>Fig. 10 - Twelve rooks and a lot of blocking.</figcaption>
</figure>

<p>Still only a single white rook will move in this situation. However, it seems that all of the white rooks should move because all of the black rooks are blocked. We can make this work by resolving move conflicts in the following way, which specializes to the above rules in the case of 2 players:</p>
<div><pre><span></span><code><span>1</span> <span>start</span> <span>with</span> <span>all</span> <span>moves</span> <span>unresolved</span>
<span>2</span> <span>while</span> <span>not</span> <span>at</span> <span>fixpoint</span><span>:</span>
<span>3</span>     <span>resolve</span> <span>all</span> <span>illegal</span> <span>moves</span> <span>without</span> <span>merging</span> <span>them</span>
<span>4</span>     <span>M</span> <span>:=</span> <span>the</span> <span>set</span> <span>of</span> <span>moves</span> <span>legal</span> <span>in</span> <span>all</span> <span>orderings</span> <span>of</span> <span>unresolved</span> <span>moves</span>
<span>5</span>     <span>if</span> <span>all</span> <span>possible</span> <span>orderings</span> <span>of</span> <span>M</span> <span>lead</span> <span>to</span> <span>the</span> <span>same</span> <span>game</span> <span>state</span><span>:</span>
<span>6</span>         <span>merge</span> <span>all</span> <span>moves</span> <span>in</span> <span>M</span> <span>and</span> <span>resolve</span> <span>them</span>
</code></pre></div>
<p>That is, we iteratively block and merge moves until no more decisions can be made. As mentioned, when we have only 2 players, this algorithm is equivalent to the two rules above. For the case of chess and other games where legal moves commute, the check on line <code>5</code> can be omitted.</p>
<p>Let&#39;s apply this to the 12-rook scenario from Fig. 10. </p>
<ol>
<li>After one round of the loop, the white rook on <code>a7</code> will have moved, and no other moves will be resolved.</li>
<li>In the second round of the loop, the black rook on <code>c8</code> will be blocked and resolved on line 3. This will free up the white rook on <code>b6</code> to move, so <code>M</code> will contain just that move.</li>
<li>In the third round of the loop, the black rook on <code>d7</code> will be blocked and resolved on line 3. This will free up the white rook on <code>c5</code> to move, so <code>M</code> will contain just that move.</li>
<li>Ultimately, all moves will be resolved and only the white rooks will have moved.</li>
</ol>
<h3 id="implementation">Implementation</h3>
<p>The computational complexity of a direct implementation of this algorithm is exponential in the worst case since we must consider all orderings of player moves. However for chess in particular, the ordering on line <code>4</code> can be handled by checking moves pairwise to compute <code>M</code>, and the ordering on line <code>5</code> can be handled by omitting the check altogether. This gives us a polynomial time algorithm, even on large/infinite boards where pieces might move arbitrarily far.</p>
<p>Edit: <a href="https://www.linkedin.com/in/mateen-kasim/">Mateen Kasim</a> shared with me the counterexample to the sufficiency of checking moves pairwise in Fig. 11. Question: Is there still a polynomial time algorithm to compute <code>M</code> for chess? What if we fix the number of kings per team? What if we change the win condition of the input game to capturing the opponent&#39;s king, and remove checks and checkmates?</p>
<figure>
  <img src="https://asvarga.github.io/files/mateen-paradox.png" width="400"/>
  <figcaption>Fig. 11 - Three pairwise legal moves with an illegal ordering.</figcaption>
</figure>

<p>For input games where this algorithm can be implemented with constant work per player, it can be feasible to run large numbers of players in real time on a GPU. I&#39;m working on such a game, which was the original motivation for this investigation.</p>
<h3 id="conclusion">Conclusion</h3>
<p>This game we&#39;ve arrived at may not the most <em>fun</em> simultaneous chess variant, but it makes up for quality with quantity: we have a tool to turn many classes of input games into fair simultaneous games. Some of them might turn out to be fun, but it&#39;s hard to say for sure without playtesting them.</p>
<h3 id="links">Links</h3>
<ul>
<li>Images created using <a href="https://www.chess.com/analysis">chess.com/analysis</a> and <a href="https://playtictactoe.org/">playtictactoe.org</a> and <a href="https://app.diagrams.net/">app.diagrams.net</a></li>
</ul>
<!-- 
Empty Board:
8/8/8/8/8/8/8/8 w - - 0 1
-->







  
  




  



      
    </article>
  </div>

          

        </div>
        
          
        
      </main>
      
        
      
    </div></div>
  </body>
</html>
