<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://cpucycles.cr.yp.to/">Original</a>
    <h1>Libcpucycles is a public-domain microlibrary for counting CPU cycles</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>libcpucycles is a public-domain microlibrary for counting CPU cycles.
Cycle counts are not as detailed as
<a href="https://gamozolabs.github.io/metrology/2019/08/19/sushi_roll.html">Falk diagrams</a>
but are the most precise timers available to typical software; they are
central tools used in understanding and improving software performance.</p>
<p>The libcpucycles <a href="https://cpucycles.cr.yp.to/api.html">API</a> is simple: include <code>&lt;cpucycles.h&gt;</code>, call
<code>cpucycles()</code> to receive a <code>long long</code> whenever desired, and link with
<code>-lcpucycles</code>.</p>
<p><a href="https://cpucycles.cr.yp.to/counters.html">Internally</a>, libcpucycles understands machine-level
cycle counters for amd64 (both PMC and TSC), arm32, arm64 (both PMC and
VCT), mips64, ppc32, ppc64, riscv32, riscv64, sparc64, and x86.
libcpucycles also understands four OS-level mechanisms, which give
varying levels of accuracy: <code>mach_absolute_time</code>, <code>perf_event</code>,
<code>CLOCK_MONOTONIC</code>, and, as a fallback, microsecond-resolution
<code>gettimeofday</code>.</p>
<p>When the program first calls <code>cpucycles()</code>, libcpucycles automatically
benchmarks the available mechanisms and <a href="https://cpucycles.cr.yp.to/selection.html">selects</a> the
mechanism that does the best job. Subsequent <code>cpucycles()</code> calls are
thread-safe and very fast. An accompanying <code>cpucycles-info</code> program
prints a summary of cycle-counter accuracy.</p>
<p>For comparison, there is a simple-sounding <code>__rdtsc()</code> API provided by
compilers, but this works only on Intel/AMD CPUs and is generally noisier
than PMC. There is a <code>__builtin_readcyclecounter()</code> that works on more
CPUs, but this works only with <code>clang</code> and has the same noise problems.
Both of these mechanisms put the burden on the caller to figure out what
can be done on other CPUs. Various packages include their own more
portable abstraction layers for counting cycles (see, e.g., FFTW&#39;s
<a href="https://github.com/FFTW/fftw3/blob/master/kernel/cycle.h"><code>cycle.h</code></a>,
used to automatically select from among multiple implementations
provided by FFTW), but this creates per-package effort to keep up with
the latest cycle counters. The goal of libcpucycles is to provide
state-of-the-art cycle counting centrally for all packages to use.</p><hr/><SPAN size="1"><b>Version:</b>
This is version 2023.01.05 of the &#34;Intro&#34; web page.
</SPAN>
</div></div>
  </body>
</html>
