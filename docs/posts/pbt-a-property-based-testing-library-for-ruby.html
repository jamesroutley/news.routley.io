<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/ohbarye/pbt">Original</a>
    <h1>Show HN: PBT – A property-based testing library for Ruby</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto"><a href="https://rubygems.org/gems/pbt" rel="nofollow"><img src="https://camo.githubusercontent.com/1e4aba19ac30272d7278974d5b9405de20415d890eeb97c8d53c1cf0f5c4c4b5/68747470733a2f2f62616467652e667572792e696f2f72622f7062742e737667" alt="Gem Version" data-canonical-src="https://badge.fury.io/rb/pbt.svg"/></a>
<a href="https://github.com/ohbarye/pbt/actions/workflows/main.yml"><img src="https://github.com/ohbarye/pbt/actions/workflows/main.yml/badge.svg" alt="Build Status"/></a>
<a href="https://www.rubydoc.info/gems/pbt" rel="nofollow"><img src="https://camo.githubusercontent.com/0e2efd55dee25a736dba3440934b56852469e6a9bd487bbc7afff3c4f8851631/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f25463025394625393325394152756279446f632d646f63756d656e746174696f6e2d696e666f726d6174696f6e616c2e737667" alt="RubyDoc" data-canonical-src="https://img.shields.io/badge/%F0%9F%93%9ARubyDoc-documentation-informational.svg"/></a></p>
<p dir="auto">A property-based testing tool for Ruby with experimental features that allow you to run test cases in parallel.</p>
<p dir="auto">PBT stands for Property-Based Testing.</p>
<p dir="auto">As for the results of the parallelization experiment, please refer the talk at RubyKaigi 2024: <a href="https://rubykaigi.org/2024/presentations/ohbarye.html" rel="nofollow">Unlocking Potential of Property Based Testing with Ractor</a>.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">What&#39;s Property-Based Testing?</h2><a id="user-content-whats-property-based-testing" aria-label="Permalink: What&#39;s Property-Based Testing?" href="#whats-property-based-testing"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Property-Based Testing is a testing methodology that focuses on the properties a system should always satisfy, rather than checking individual examples. Instead of writing tests for predefined inputs and outputs, PBT allows you to specify the general characteristics that your code should adhere to and then automatically generates a wide range of inputs to verify these properties.</p>
<p dir="auto">The key benefits of property-based testing include the ability to cover more edge cases and the potential to discover bugs that traditional example-based tests might miss. It&#39;s particularly useful for identifying unexpected behaviors in your code by testing it against a vast set of inputs, including those you might not have considered.</p>
<p dir="auto">For a more in-depth understanding of Property-Based Testing, please refer to external resources.</p>
<ul dir="auto">
<li>Original ideas
<ul dir="auto">
<li><a href="https://ieeexplore.ieee.org/document/367311" rel="nofollow">Property-based testing of privileged programs</a> (1994)</li>
<li><a href="https://dl.acm.org/doi/abs/10.1145/263244.263267" rel="nofollow">Property-based testing: a new approach to testing for assurance</a> (1997)</li>
<li><a href="https://dl.acm.org/doi/10.1145/351240.351266" rel="nofollow">QuickCheck: a lightweight tool for random testing of Haskell programs</a> (2000)</li>
</ul>
</li>
<li>Rather new introductory resources
<ul dir="auto">
<li>Fred Hebert&#39;s book <a href="https://propertesting.com/" rel="nofollow">Property-Based Testing With PropEr, Erlang and Elixir</a>.</li>
<li><a href="https://fast-check.dev/docs/introduction/why-property-based/" rel="nofollow">fast-check - Why Property-Based?</a></li>
</ul>
</li>
</ul>

<p dir="auto">Add this line to your application&#39;s Gemfile and run <code>bundle install</code>.</p>

<p dir="auto">Off course you can install with <code>gem intstall pbt</code>.</p>


<div dir="auto" data-snippet-clipboard-copy-content="# Let&#39;s say you have your own sort method.
def sort(array)
  return array if array.size &lt;= 2 # Here&#39;s a bug! It should be 1.
  pivot, *rest = array
  left, right = rest.partition { |n| n &lt;= pivot }
  sort(left) + [pivot] + sort(right)
end

Pbt.assert do
  # The given block is executed 100 times with different arrays with random numbers.
  # Besides, the block runs in parallel by Ractor.
  Pbt.property(Pbt.array(Pbt.integer)) do |numbers|
    result = sort(numbers)
    result.each_cons(2) do |x, y|
      raise &#34;Sort algorithm is wrong.&#34; unless x &lt;= y
    end
  end
end

# If the function has a bug, the test fails and it reports a minimum counterexample.
# For example, the sort method doesn&#39;t work for [0, -1].
#
# Pbt::PropertyFailure:
#   Property failed after 23 test(s)
#   seed: 43738985293126714007411539287084402325
#   counterexample: [0, -1]
#   Shrunk 40 time(s)
#   Got RuntimeError: Sort algorithm is wrong."><pre><span># Let&#39;s say you have your own sort method.</span>
<span>def</span> <span>sort</span><span>(</span><span>array</span><span>)</span>
  <span>return</span> <span>array</span> <span>if</span> <span>array</span><span>.</span><span>size</span> &lt;= <span>2</span> <span># Here&#39;s a bug! It should be 1.</span>
  <span>pivot</span><span>,</span> *<span>rest</span> <span>=</span> <span>array</span>
  <span>left</span><span>,</span> <span>right</span> <span>=</span> <span>rest</span><span>.</span><span>partition</span> <span>{</span> |<span>n</span>| <span>n</span> &lt;= <span>pivot</span> <span>}</span>
  <span>sort</span><span>(</span><span>left</span><span>)</span> + <span>[</span><span>pivot</span><span>]</span> + <span>sort</span><span>(</span><span>right</span><span>)</span>
<span>end</span>

<span>Pbt</span><span>.</span><span>assert</span> <span>do</span>
  <span># The given block is executed 100 times with different arrays with random numbers.</span>
  <span># Besides, the block runs in parallel by Ractor.</span>
  <span>Pbt</span><span>.</span><span>property</span><span>(</span><span>Pbt</span><span>.</span><span>array</span><span>(</span><span>Pbt</span><span>.</span><span>integer</span><span>)</span><span>)</span> <span>do</span> |<span>numbers</span>|
    <span>result</span> <span>=</span> <span>sort</span><span>(</span><span>numbers</span><span>)</span>
    <span>result</span><span>.</span><span>each_cons</span><span>(</span><span>2</span><span>)</span> <span>do</span> |<span>x</span><span>,</span> <span>y</span>|
      <span>raise</span> <span>&#34;Sort algorithm is wrong.&#34;</span> <span>unless</span> <span>x</span> &lt;= <span>y</span>
    <span>end</span>
  <span>end</span>
<span>end</span>

<span># If the function has a bug, the test fails and it reports a minimum counterexample.</span>
<span># For example, the sort method doesn&#39;t work for [0, -1].</span>
<span>#</span>
<span># Pbt::PropertyFailure:</span>
<span>#   Property failed after 23 test(s)</span>
<span>#   seed: 43738985293126714007411539287084402325</span>
<span>#   counterexample: [0, -1]</span>
<span>#   Shrunk 40 time(s)</span>
<span>#   Got RuntimeError: Sort algorithm is wrong.</span></pre></div>

<p dir="auto">The above snippet is very simple but contains the basic components.</p>

<p dir="auto"><code>Pbt.assert</code> is the runner. The runner interprets and executes the given property. <code>Pbt.assert</code> takes a property and runs it multiple times. If the property fails, it tries to shrink the input that caused the failure.</p>

<p dir="auto">The snippet above declared a property by calling <code>Pbt.property</code>. The property describes the following:</p>
<ol dir="auto">
<li>What the user wants to evaluate. This corresponds to the block (let&#39;s call this <code>predicate</code>) enclosed by <code>do</code> <code>end</code></li>
<li>How to generate inputs for the predicate — using <code>Arbitrary</code></li>
</ol>
<p dir="auto">The <code>predicate</code> block is a function that directly asserts, taking values generated by <code>Arbitrary</code> as input.</p>

<p dir="auto">Arbitrary generates random values. It is also responsible for shrinking those values if asked to shrink a failed value as input.</p>
<p dir="auto">Here, we used only one type of arbitrary, <code>Pbt.integer</code>. There are many other built-in arbitraries, and you can create a variety of inputs by combining existing ones.</p>

<p dir="auto">In PBT, If a test fails, it attempts to shrink the case that caused the failure into a form that is easier for humans to understand.
In other words, instead of stopping the test itself the first time it fails and reporting the failed value, it tries to find the minimal value that causes the error.</p>
<p dir="auto">When there is a test that fails when given an even number, a counterexample of <code>2</code> is simpler and easier to understand than <code>432743417662</code>.</p>

<p dir="auto">There are many built-in arbitraries in <code>Pbt</code>. You can use them to generate random values for your tests. Here are some representative arbitraries.</p>

<div dir="auto" data-snippet-clipboard-copy-content="rng = Random.new

Pbt.integer.generate(rng)                  # =&gt; 42
Pbt.integer(min: -1, max: 8).generate(rng) # =&gt; Integer between -1 and 8

Pbt.symbol.generate(rng)                   # =&gt; :atq

Pbt.ascii_char.generate(rng)               # =&gt; &#34;a&#34;
Pbt.ascii_string.generate(rng)             # =&gt; &#34;aagjZfao&#34;

Pbt.boolean.generate(rng)                  # =&gt; true or false
Pbt.constant(42).generate(rng)             # =&gt; 42 always"><pre><span>rng</span> <span>=</span> <span>Random</span><span>.</span><span>new</span>

<span>Pbt</span><span>.</span><span>integer</span><span>.</span><span>generate</span><span>(</span><span>rng</span><span>)</span>                  <span># =&gt; 42</span>
<span>Pbt</span><span>.</span><span>integer</span><span>(</span><span>min</span>: -<span>1</span><span>,</span> <span>max</span>: <span>8</span><span>)</span><span>.</span><span>generate</span><span>(</span><span>rng</span><span>)</span> <span># =&gt; Integer between -1 and 8</span>

<span>Pbt</span><span>.</span><span>symbol</span><span>.</span><span>generate</span><span>(</span><span>rng</span><span>)</span>                   <span># =&gt; :atq</span>

<span>Pbt</span><span>.</span><span>ascii_char</span><span>.</span><span>generate</span><span>(</span><span>rng</span><span>)</span>               <span># =&gt; &#34;a&#34;</span>
<span>Pbt</span><span>.</span><span>ascii_string</span><span>.</span><span>generate</span><span>(</span><span>rng</span><span>)</span>             <span># =&gt; &#34;aagjZfao&#34;</span>

<span>Pbt</span><span>.</span><span>boolean</span><span>.</span><span>generate</span><span>(</span><span>rng</span><span>)</span>                  <span># =&gt; true or false</span>
<span>Pbt</span><span>.</span><span>constant</span><span>(</span><span>42</span><span>)</span><span>.</span><span>generate</span><span>(</span><span>rng</span><span>)</span>             <span># =&gt; 42 always</span></pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="rng = Random.new

Pbt.array(Pbt.integer).generate(rng)                        # =&gt; [121, -13141, 9825]
Pbt.array(Pbt.integer, max: 1, empty: true).generate(rng)   # =&gt; [] or [42] etc.

Pbt.tuple(Pbt.symbol, Pbt.integer).generate(rng)            # =&gt; [:atq, 42]

Pbt.fixed_hash(x: Pbt.symbol, y: Pbt.integer).generate(rng) # =&gt; {x: :atq, y: 42}
Pbt.hash(Pbt.symbol, Pbt.integer).generate(rng)             # =&gt; {atq: 121, ygab: -1142}

Pbt.one_of(:a, 1, 0.1).generate(rng)                        # =&gt; :a or 1 or 0.1"><pre><span>rng</span> <span>=</span> <span>Random</span><span>.</span><span>new</span>

<span>Pbt</span><span>.</span><span>array</span><span>(</span><span>Pbt</span><span>.</span><span>integer</span><span>)</span><span>.</span><span>generate</span><span>(</span><span>rng</span><span>)</span>                        <span># =&gt; [121, -13141, 9825]</span>
<span>Pbt</span><span>.</span><span>array</span><span>(</span><span>Pbt</span><span>.</span><span>integer</span><span>,</span> <span>max</span>: <span>1</span><span>,</span> <span>empty</span>: <span>true</span><span>)</span><span>.</span><span>generate</span><span>(</span><span>rng</span><span>)</span>   <span># =&gt; [] or [42] etc.</span>

<span>Pbt</span><span>.</span><span>tuple</span><span>(</span><span>Pbt</span><span>.</span><span>symbol</span><span>,</span> <span>Pbt</span><span>.</span><span>integer</span><span>)</span><span>.</span><span>generate</span><span>(</span><span>rng</span><span>)</span>            <span># =&gt; [:atq, 42]</span>

<span>Pbt</span><span>.</span><span>fixed_hash</span><span>(</span><span>x</span>: <span>Pbt</span><span>.</span><span>symbol</span><span>,</span> <span>y</span>: <span>Pbt</span><span>.</span><span>integer</span><span>)</span><span>.</span><span>generate</span><span>(</span><span>rng</span><span>)</span> <span># =&gt; {x: :atq, y: 42}</span>
<span>Pbt</span><span>.</span><span>hash</span><span>(</span><span>Pbt</span><span>.</span><span>symbol</span><span>,</span> <span>Pbt</span><span>.</span><span>integer</span><span>)</span><span>.</span><span>generate</span><span>(</span><span>rng</span><span>)</span>             <span># =&gt; {atq: 121, ygab: -1142}</span>

<span>Pbt</span><span>.</span><span>one_of</span><span>(</span><span>:a</span><span>,</span> <span>1</span><span>,</span> <span>0.1</span><span>)</span><span>.</span><span>generate</span><span>(</span><span>rng</span><span>)</span>                        <span># =&gt; :a or 1 or 0.1</span></pre></div>
<p dir="auto">See <a href="https://github.com/ohbarye/pbt/blob/main/lib/pbt/arbitrary/arbitrary_methods.rb">ArbitraryMethods</a> module for more details.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">What if property-based tests fail?</h2><a id="user-content-what-if-property-based-tests-fail" aria-label="Permalink: What if property-based tests fail?" href="#what-if-property-based-tests-fail"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Once a test fails it&#39;s time to debug. <code>Pbt</code> provides some features to help you debug.</p>

<p dir="auto">When a test fails, you&#39;ll see a message like below.</p>
<div data-snippet-clipboard-copy-content="Pbt::PropertyFailure:
  Property failed after 23 test(s)
  seed: 43738985293126714007411539287084402325
  counterexample: [0, -1]
  Shrunk 40 time(s)
  Got RuntimeError: Sort algorithm is wrong.
  # and backtraces"><pre lang="text"><code>Pbt::PropertyFailure:
  Property failed after 23 test(s)
  seed: 43738985293126714007411539287084402325
  counterexample: [0, -1]
  Shrunk 40 time(s)
  Got RuntimeError: Sort algorithm is wrong.
  # and backtraces
</code></pre></div>
<p dir="auto">You can reproduce the failure by passing the seed to <code>Pbt.assert</code>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="Pbt.assert(seed: 11001296583699917659214176011685741769) do
  Pbt.property(Pbt.array(Pbt.integer)) do |number|
    # your test
  end
end"><pre><span>Pbt</span><span>.</span><span>assert</span><span>(</span><span>seed</span>: <span>11001296583699917659214176011685741769</span><span>)</span> <span>do</span>
  <span>Pbt</span><span>.</span><span>property</span><span>(</span><span>Pbt</span><span>.</span><span>array</span><span>(</span><span>Pbt</span><span>.</span><span>integer</span><span>)</span><span>)</span> <span>do</span> |<span>number</span>|
    <span># your test</span>
  <span>end</span>
<span>end</span></pre></div>

<p dir="auto">You may want to know which values pass and which values fail. You can enable verbose mode by passing <code>verbose: true</code> to <code>Pbt.assert</code>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="Pbt.assert(verbose: true) do
  Pbt.property(Pbt.array(Pbt.integer)) do |numbers|
    # your failed test
  end
end"><pre><span>Pbt</span><span>.</span><span>assert</span><span>(</span><span>verbose</span>: <span>true</span><span>)</span> <span>do</span>
  <span>Pbt</span><span>.</span><span>property</span><span>(</span><span>Pbt</span><span>.</span><span>array</span><span>(</span><span>Pbt</span><span>.</span><span>integer</span><span>)</span><span>)</span> <span>do</span> |<span>numbers</span>|
    <span># your failed test</span>
  <span>end</span>
<span>end</span></pre></div>
<p dir="auto">The verbose mode prints the results of each tested values.</p>
<div data-snippet-clipboard-copy-content="Encountered failures were:
- [152477, 666997, -531468, -92182, 623948, 425913, 656138, 856463, -64529]
- [76239, 666997, -531468, -92182, 623948]
- [76239, 666997, -531468]
(snipped for README)
- [2, 163]
- [2, 11]

Execution summary:
. × [152477, 666997, -531468, -92182, 623948, 425913, 656138, 856463, -64529]
. . √ [152477, 666997, -531468, -92182, 623948]
. . √ [-64529]
. . × [76239, 666997, -531468, -92182, 623948, 425913, 656138, 856463, -64529]
. . . × [76239, 666997, -531468, -92182, 623948]
(snipped for README)
. . . . . . . . . . . . . . . . . √ [2, 21]
. . . . . . . . . . . . . . . . . × [2, 11]
. . . . . . . . . . . . . . . . . . √ []
. . . . . . . . . . . . . . . . . . √ [2, 1]
. . . . . . . . . . . . . . . . . . √ [2, 0]"><pre lang="text"><code>Encountered failures were:
- [152477, 666997, -531468, -92182, 623948, 425913, 656138, 856463, -64529]
- [76239, 666997, -531468, -92182, 623948]
- [76239, 666997, -531468]
(snipped for README)
- [2, 163]
- [2, 11]

Execution summary:
. × [152477, 666997, -531468, -92182, 623948, 425913, 656138, 856463, -64529]
. . √ [152477, 666997, -531468, -92182, 623948]
. . √ [-64529]
. . × [76239, 666997, -531468, -92182, 623948, 425913, 656138, 856463, -64529]
. . . × [76239, 666997, -531468, -92182, 623948]
(snipped for README)
. . . . . . . . . . . . . . . . . √ [2, 21]
. . . . . . . . . . . . . . . . . × [2, 11]
. . . . . . . . . . . . . . . . . . √ []
. . . . . . . . . . . . . . . . . . √ [2, 1]
. . . . . . . . . . . . . . . . . . √ [2, 0]
</code></pre></div>

<p dir="auto">You can configure <code>Pbt</code> by calling <code>Pbt.configure</code> before running tests.</p>
<div dir="auto" data-snippet-clipboard-copy-content="Pbt.configure do |config|
  # Whether to print verbose output. Default is `false`.
  config.verbose = false

  # The concurrency method to use. `:ractor`, `:thread`, `:process` and `:none` are supported. Default is `:none`.
  config.worker = :none

  # The number of runs to perform. Default is `100`.
  config.num_runs = 100

  # The seed to use for random number generation.
  # It&#39;s useful to reproduce failed test with the seed you&#39;d pick up from failure messages. Default is a random seed.
  config.seed = 42

  # Whether to report exceptions in threads.
  # It&#39;s useful to suppress error logs on Ractor that reports many errors. Default is `false`.
  config.thread_report_on_exception = false

  # Whether to allow RSpec expectation and matchers in Ractor. It&#39;s quite experimental! Default is `false`.
  config.experimental_ractor_rspec_integration = false
end"><pre><span>Pbt</span><span>.</span><span>configure</span> <span>do</span> |<span>config</span>|
  <span># Whether to print verbose output. Default is `false`.</span>
  <span>config</span><span>.</span><span>verbose</span> <span>=</span> <span>false</span>

  <span># The concurrency method to use. `:ractor`, `:thread`, `:process` and `:none` are supported. Default is `:none`.</span>
  <span>config</span><span>.</span><span>worker</span> <span>=</span> <span>:none</span>

  <span># The number of runs to perform. Default is `100`.</span>
  <span>config</span><span>.</span><span>num_runs</span> <span>=</span> <span>100</span>

  <span># The seed to use for random number generation.</span>
  <span># It&#39;s useful to reproduce failed test with the seed you&#39;d pick up from failure messages. Default is a random seed.</span>
  <span>config</span><span>.</span><span>seed</span> <span>=</span> <span>42</span>

  <span># Whether to report exceptions in threads.</span>
  <span># It&#39;s useful to suppress error logs on Ractor that reports many errors. Default is `false`.</span>
  <span>config</span><span>.</span><span>thread_report_on_exception</span> <span>=</span> <span>false</span>

  <span># Whether to allow RSpec expectation and matchers in Ractor. It&#39;s quite experimental! Default is `false`.</span>
  <span>config</span><span>.</span><span>experimental_ractor_rspec_integration</span> <span>=</span> <span>false</span>
<span>end</span></pre></div>
<p dir="auto">Or, you can pass the configuration to <code>Pbt.assert</code> as an argument.</p>
<div dir="auto" data-snippet-clipboard-copy-content="Pbt.assert(num_runs: 100, seed: 42) do
  # ...
end"><pre><span>Pbt</span><span>.</span><span>assert</span><span>(</span><span>num_runs</span>: <span>100</span><span>,</span> <span>seed</span>: <span>42</span><span>)</span> <span>do</span>
  <span># ...</span>
<span>end</span></pre></div>

<p dir="auto">One of the key features of <code>Pbt</code> is its ability to rapidly execute test cases in parallel or concurrently, using a large number of values (by default, <code>100</code>) generated by <code>Arbitrary</code>.</p>
<p dir="auto">For concurrent processing, you can specify any of the three workers—<code>:ractor</code>, <code>:process</code>, or <code>:thread</code>—using the <code>worker</code> option. Alternatively, choose <code>:none</code> for serial execution.</p>
<p dir="auto"><code>Pbt</code> supports 3 concurrency methods and 1 sequential one. You can choose one of them by setting the <code>worker</code> option.</p>
<p dir="auto">Be aware that the performance of each method depends on the test subject. For example, if the test subject is CPU-bound, <code>:ractor</code> may be the best choice. Otherwise, <code>:none</code> shall be the best choice for most cases. See <a href="http://harihareswara.net/ohbarye/pbt/blob/main/benchmark/README.md">benchmarks</a>.</p>

<p dir="auto"><code>:ractor</code> worker is useful for test cases that are CPU-bound. But it&#39;s experimental and has some limitations as described below. If you encounter any issues due to those limitations, consider using <code>:process</code> as workers whose benchmark is the most similar to <code>:ractor</code>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="Pbt.assert(worker: :ractor) do
  Pbt.property(Pbt.integer) do |n|
    # ...
  end
end"><pre><span>Pbt</span><span>.</span><span>assert</span><span>(</span><span>worker</span>: <span>:ractor</span><span>)</span> <span>do</span>
  <span>Pbt</span><span>.</span><span>property</span><span>(</span><span>Pbt</span><span>.</span><span>integer</span><span>)</span> <span>do</span> |<span>n</span>|
    <span># ...</span>
  <span>end</span>
<span>end</span></pre></div>

<p dir="auto">Please note that Ractor support is an experimental feature of this gem. Due to Ractor&#39;s limitations, you may encounter some issues when using it.</p>
<p dir="auto">For example, you cannot access anything out of block.</p>
<div dir="auto" data-snippet-clipboard-copy-content="a = 1

Pbt.assert(worker: :ractor) do
  Pbt.property(Pbt.integer) do |n|
    # You cannot access `a` here because this block is executed in a Ractor and it doesn&#39;t allow implicit sharing of objects.
    a + n # =&gt; Ractor::RemoteError (can not share object between ractors)
  end
end"><pre><span>a</span> <span>=</span> <span>1</span>

<span>Pbt</span><span>.</span><span>assert</span><span>(</span><span>worker</span>: <span>:ractor</span><span>)</span> <span>do</span>
  <span>Pbt</span><span>.</span><span>property</span><span>(</span><span>Pbt</span><span>.</span><span>integer</span><span>)</span> <span>do</span> |<span>n</span>|
    <span># You cannot access `a` here because this block is executed in a Ractor and it doesn&#39;t allow implicit sharing of objects.</span>
    <span>a</span> + <span>n</span> <span># =&gt; Ractor::RemoteError (can not share object between ractors)</span>
  <span>end</span>
<span>end</span></pre></div>
<p dir="auto">You cannot use any methods provided by test frameworks like <code>expect</code> or <code>assert</code> because they are not available in a Ractor.</p>
<div dir="auto" data-snippet-clipboard-copy-content="it do
  Pbt.assert(worker: :ractor) do
    Pbt.property(Pbt.integer) do |n|
      # This is not possible because `self` if a Ractor here.
      expect(n).to be_an(Integer) # =&gt; Ractor::RemoteError (cause by NoMethodError for `expect` or `be_an`)
    end
  end
end"><pre><span>it</span> <span>do</span>
  <span>Pbt</span><span>.</span><span>assert</span><span>(</span><span>worker</span>: <span>:ractor</span><span>)</span> <span>do</span>
    <span>Pbt</span><span>.</span><span>property</span><span>(</span><span>Pbt</span><span>.</span><span>integer</span><span>)</span> <span>do</span> |<span>n</span>|
      <span># This is not possible because `self` if a Ractor here.</span>
      <span>expect</span><span>(</span><span>n</span><span>)</span><span>.</span><span>to</span> <span>be_an</span><span>(</span><span>Integer</span><span>)</span> <span># =&gt; Ractor::RemoteError (cause by NoMethodError for `expect` or `be_an`)</span>
    <span>end</span>
  <span>end</span>
<span>end</span></pre></div>
<p dir="auto">If you&#39;re a challenger, you can enable the experimental feature to allow using RSpec expectations and matchers in Ractor. It works but it&#39;s quite experimental and could cause unexpected behaviors.</p>
<p dir="auto">Please note that this feature depends on <a href="https://ruby.github.io/prism/" rel="nofollow">prism</a> gem. If you use Ruby 3.2 or prior, you need to install the gem by yourself.</p>
<div dir="auto" data-snippet-clipboard-copy-content="it do
  Pbt.assert(worker: :ractor, experimental_ractor_rspec_integration: true) do
    Pbt.property(Pbt.integer) do |n|
      # Some RSpec expectations and matchers are available in Ractor by hack.
      # Other features like `let`, `subject`, `before`, `after` that access out of block are still not available.
      expect(n).to be_an(Integer)
    end
  end
end"><pre><span>it</span> <span>do</span>
  <span>Pbt</span><span>.</span><span>assert</span><span>(</span><span>worker</span>: <span>:ractor</span><span>,</span> <span>experimental_ractor_rspec_integration</span>: <span>true</span><span>)</span> <span>do</span>
    <span>Pbt</span><span>.</span><span>property</span><span>(</span><span>Pbt</span><span>.</span><span>integer</span><span>)</span> <span>do</span> |<span>n</span>|
      <span># Some RSpec expectations and matchers are available in Ractor by hack.</span>
      <span># Other features like `let`, `subject`, `before`, `after` that access out of block are still not available.</span>
      <span>expect</span><span>(</span><span>n</span><span>)</span><span>.</span><span>to</span> <span>be_an</span><span>(</span><span>Integer</span><span>)</span>
    <span>end</span>
  <span>end</span>
<span>end</span></pre></div>

<p dir="auto">If you&#39;d like to run test cases that are CPU-bound and <code>:ractor</code> is not available, <code>:process</code> becomes a good choice.</p>
<div dir="auto" data-snippet-clipboard-copy-content="Pbt.assert(worker: :process) do
  Pbt.property(Pbt.integer) do |n|
    # ...
  end
end"><pre><span>Pbt</span><span>.</span><span>assert</span><span>(</span><span>worker</span>: <span>:process</span><span>)</span> <span>do</span>
  <span>Pbt</span><span>.</span><span>property</span><span>(</span><span>Pbt</span><span>.</span><span>integer</span><span>)</span> <span>do</span> |<span>n</span>|
    <span># ...</span>
  <span>end</span>
<span>end</span></pre></div>
<p dir="auto">If you want to use <code>:process</code>, you need to install the <a href="https://github.com/grosser/parallel">parallel</a> gem.</p>

<p dir="auto">You may not need to run test cases with multi-threads.</p>
<div dir="auto" data-snippet-clipboard-copy-content="Pbt.assert(worker: :thread) do
  Pbt.property(Pbt.integer) do |n|
    # ...
  end
end"><pre><span>Pbt</span><span>.</span><span>assert</span><span>(</span><span>worker</span>: <span>:thread</span><span>)</span> <span>do</span>
  <span>Pbt</span><span>.</span><span>property</span><span>(</span><span>Pbt</span><span>.</span><span>integer</span><span>)</span> <span>do</span> |<span>n</span>|
    <span># ...</span>
  <span>end</span>
<span>end</span></pre></div>
<p dir="auto">If you want to use <code>:thread</code>, you need to install the <a href="https://github.com/grosser/parallel">parallel</a> gem.</p>

<p dir="auto">For most cases, <code>:none</code> is the best choice. It runs tests sequentially (without parallelism) but most test cases finishes within a reasonable time.</p>
<div dir="auto" data-snippet-clipboard-copy-content="Pbt.assert(worker: :none) do
  Pbt.property(Pbt.integer) do |n|
    # ...
  end
end"><pre><span>Pbt</span><span>.</span><span>assert</span><span>(</span><span>worker</span>: <span>:none</span><span>)</span> <span>do</span>
  <span>Pbt</span><span>.</span><span>property</span><span>(</span><span>Pbt</span><span>.</span><span>integer</span><span>)</span> <span>do</span> |<span>n</span>|
    <span># ...</span>
  <span>end</span>
<span>end</span></pre></div>

<p dir="auto">Once this project finishes the following, we will release v1.0.0.</p>
<ul>
<li> Implement basic primitive arbitraries</li>
<li> Implement composite arbitraries</li>
<li> Support shrinking</li>
<li> Support multiple concurrency methods
<ul>
<li> Ractor</li>
<li> Process</li>
<li> Thread</li>
<li> None (Run tests sequentially)</li>
</ul>
</li>
<li> Documentation
<ul>
<li> Add better examples</li>
<li> Arbitrary usage</li>
<li> Configuration</li>
</ul>
</li>
<li> Benchmark</li>
<li> Rich report by verbose mode</li>
<li> (Partially) Allow to use expectations and matchers provided by test framework in Ractor if possible.
<ul dir="auto">
<li>It&#39;d be so hard to pass assertions like <code>expect</code>, <code>assert</code> to a Ractor.</li>
</ul>
</li>
<li> Implement frequency arbitrary</li>
<li> Statistics feature to aggregate generated values</li>
<li> Decide DSL</li>
<li> Try Fiber</li>
<li> Stateful property-based testing</li>
</ul>


<div dir="auto" data-snippet-clipboard-copy-content="bin/setup
bundle exec rake # Run tests and lint at once"><pre>bin/setup
bundle <span>exec</span> rake <span><span>#</span> Run tests and lint at once</span></pre></div>



<div dir="auto" data-snippet-clipboard-copy-content="bundle exec rake standard:fix"><pre>bundle <span>exec</span> rake standard:fix</pre></div>

<p dir="auto">Bug reports and pull requests are welcome on GitHub at <a href="https://github.com/ohbarye/pbt">https://github.com/ohbarye/pbt</a>. This project is intended to be a safe, welcoming space for collaboration, and contributors are expected to adhere to the <a href="https://github.com/ohbarye/pbt/blob/master/CODE_OF_CONDUCT.md">code of conduct</a>.</p>

<p dir="auto">The gem is available as open source under the terms of the <a href="https://opensource.org/licenses/MIT" rel="nofollow">MIT License</a>.</p>

<p dir="auto">This project draws a lot of inspiration from other testing tools, namely</p>
<ul dir="auto">
<li><a href="https://fast-check.dev/" rel="nofollow">fast-check</a></li>
<li><a href="https://github.com/vinistock/loupe">Loupe</a></li>
<li><a href="https://github.com/rspec/rspec">RSpec</a></li>
<li><a href="https://github.com/seattlerb/minitest">Minitest</a></li>
<li><a href="https://github.com/grosser/parallel">Parallel</a></li>
<li><a href="https://github.com/Qqwy/ruby-prop_check">PropCheck for Ruby</a></li>
<li><a href="https://github.com/alfert/propcheck">PropCheck for Elixir</a></li>
</ul>

<p dir="auto">Everyone interacting in the Pbt project&#39;s codebases, issue trackers, chat rooms and mailing lists is expected to follow the <a href="https://github.com/ohbarye/pbt/blob/master/CODE_OF_CONDUCT.md">code of conduct</a>.</p>
</article></div></div>
  </body>
</html>
