<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/golang/go/discussions/54763">Original</a>
    <h1>Go standard library: structured, leveled logging</h1>
    
    <div id="readability-page-1" class="page"><div role="presentation" data-paste-markdown-skip="">
    <tbody data-target-translation-id="4345487" data-target-translation-type="discussion">
        <tr>
    <td>
        <p dir="auto">This is a discussion that is intended to lead to a proposal.</p>
<p dir="auto">We would like to add structured logging with levels to the standard library. Structured logging is the ability to output logs with machine-readable structure, typically key-value pairs, in addition to a human-readable message. Structured logs can be parsed, filtered, searched and analyzed faster and more reliably than logs designed only for people to read. For many programs that aren&#39;t run directly by person, like servers, logging is the main way for developers to observe the detailed behavior of the system, and often the first place they go to debug it. Logs therefore tend to be voluminous, and the ability to search and filter them quickly is essential.</p>
<p dir="auto">In theory, one can produce structured logs with any logging package:</p>
<div data-snippet-clipboard-copy-content="log.Printf(`{&#34;message&#34;: %q, &#34;count&#34;: %d}`, msg, count)"><pre><code>log.Printf(`{&#34;message&#34;: %q, &#34;count&#34;: %d}`, msg, count)
</code></pre></div>
<p dir="auto">In practice, this is too tedious and error-prone, so structured logging packages provide an API for expressing key-value pairs. This draft proposal contains such an API.</p>
<p dir="auto">We also propose generalizing the logging &#34;backend.&#34; The <code>log</code> package provides control only over the <code>io.Writer</code> that logs are written to. In the new package (tentative name: <code>log/slog</code>),  every logger has a handler that can process a log event however it wishes. Although it is possible to have a structured logger with a fixed backend (for instance, <a href="https://pkg.go.dev/github.com/rs/zerolog" rel="nofollow">zerolog</a> outputs only JSON), having a flexible backend provides several benefits: programs can display the logs in a variety of formats, convert them to an RPC message for a network logging service, store them for later processing, and add to or modify the data.</p>
<p dir="auto">Lastly, we include levels in our design, in a way that accommodates both traditional named levels and <a href="https://pkg.go.dev/github.com/go-logr/logr" rel="nofollow">logr</a>-style verbosities.</p>
<p dir="auto">Our goals are:</p>
<ul dir="auto">
<li>
<p dir="auto">Ease of use. A survey of the existing logging packages shows that programmers want an API that is light on the page and easy to understand. This proposal adopts the most popular way to express key-value pairs, alternating keys and values.</p>
</li>
<li>
<p dir="auto">High performance. The API has been designed to minimize allocation and locking. It provides an alternative to alternating keys and values that is more cumbersome but faster (similar to <a href="https://pkg.go.dev/go.uber.org/zap" rel="nofollow">Zap</a>&#39;s <code>Field</code>s).</p>
</li>
<li>
<p dir="auto">Integration with runtime tracing. The Go team is developing an improved runtime tracing system. Logs from this package will be incorporated seamlessly into those traces, giving developers the ability to correlate their program&#39;s actions with the behavior of the runtime.</p>
</li>
</ul>
<h2 dir="auto">What Does Success Look Like?</h2>
<p dir="auto">Go has many popular structured logging packages, all good at what they do. We do not expect developers to rewrite their existing third-party structured logging code <em>en masse</em> to use this new package. We expect existing logging packages to coexist with this one for the foreseeable future.</p>
<p dir="auto">We have tried to provide an API that is pleasant enough to prefer to existing packages in new code, if only to avoid a dependency. (Some developers may find the runtime tracing integration compelling.) We also expect newcomers to Go to become familiar with this package before learning third-party packages, so they will naturally prefer it.</p>
<p dir="auto">But more important than any traction gained by the &#34;frontend&#34; is the promise of a common &#34;backend.&#34; An application with many dependencies may find that it has linked in many logging packages. If all of the packages support the handler interface we propose, then the application can create a single handler and install it once for each logging library to get consistent logging across all its dependencies. Since this happens in the application&#39;s main function, the benefits of a unified backend can be obtained with minimal code churn. We hope that this proposal&#39;s handlers will be implemented for all popular logging formats and network protocols, and that every common logging framework will provide a shim from their own backend to a handler. Then the Go logging community can work together to build high-quality backends that all can share.</p>
<h2 dir="auto">Prior Work</h2>
<p dir="auto">The existing <code>log</code> package has been in the standard library since the release of Go 1 in March 2012. It provides formatted logging, but not structured logging or levels.</p>
<p dir="auto"><a href="https://github.com/Sirupsen/logrus">Logrus</a>, one of the first structured logging packages, showed how an API could add structure while preserving the formatted printing of the <code>log</code> package. It uses maps to hold key-value pairs, which is relatively inefficient.</p>
<p dir="auto"><a href="https://pkg.go.dev/go.uber.org/zap" rel="nofollow">Zap</a> grew out of Uber&#39;s frustration with the slow log times of their high-performance servers. It showed how a logger that avoided allocations could be very fast.</p>
<p dir="auto"><a href="https://pkg.go.dev/github.com/rs/zerolog" rel="nofollow">zerolog</a> reduced allocations even further, but at the cost of reducing the flexibility of the logging backend.</p>
<p dir="auto">All the above loggers include named levels along with key-value pairs. <a href="https://pkg.go.dev/github.com/go-logr/logr" rel="nofollow">Logr</a> and Google&#39;s own <a href="https://pkg.go.dev/github.com/golang/glog" rel="nofollow">glog</a> use integer verbosities instead of named levels, providing a more fine-grained approach to filtering high-detail logs.</p>
<p dir="auto">Other popular logging packages are Go-kit&#39;s <a href="https://pkg.go.dev/github.com/go-kit" rel="nofollow">log</a>, HashiCorp&#39;s <a href="https://pkg.go.dev/github.com/hashicorp/go-hclog" rel="nofollow">hclog</a>, and <a href="https://github.com/kubernetes/klog">klog</a>.</p>
<h2 dir="auto">Overview of the Design</h2>
<p dir="auto">Here is a short program that uses some of the new API:</p>
<div data-snippet-clipboard-copy-content="import &#34;log/slog&#34;

func main() {
    slog.SetDefault(slog.New(slog.NewTextHandler(os.Stderr)))
    slog.Info(&#34;hello&#34;, &#34;name&#34;, &#34;Al&#34;)
    slog.Error(&#34;oops&#34;, net.ErrClosed, &#34;status&#34;, 500)
    slog.LogAttrs(slog.ErrorLevel, &#34;oops&#34;,
        slog.Int(&#34;status&#34;, 500), slog.Any(&#34;err&#34;, net.ErrClosed))
}"><pre><code>import &#34;log/slog&#34;

func main() {
    slog.SetDefault(slog.New(slog.NewTextHandler(os.Stderr)))
    slog.Info(&#34;hello&#34;, &#34;name&#34;, &#34;Al&#34;)
    slog.Error(&#34;oops&#34;, net.ErrClosed, &#34;status&#34;, 500)
    slog.LogAttrs(slog.ErrorLevel, &#34;oops&#34;,
        slog.Int(&#34;status&#34;, 500), slog.Any(&#34;err&#34;, net.ErrClosed))
}
</code></pre></div>
<p dir="auto">It begins by setting the default logger to one that writes log records in an easy-to-read format similar to <a href="https://pkg.go.dev/github.com/kr/logfmt" rel="nofollow">logfmt</a> . (There is also a built-in handler for JSON.)</p>
<p dir="auto">The program then outputs three log messages augmented with key-value pairs. The first logs at the Info level, passing a single key-value pair along with the message. The second logs at the Error level, passing an <code>error</code> and a key-value pair.</p>
<p dir="auto">The third produces the same output as the second, but more efficiently. Functions like <code>Any</code> and <code>Int</code> construct <code>slog.Attr</code> values, which are key-value pairs that avoid memory allocation for some values. <code>slog.Attr</code> is modeled on <code>zap.Field</code>.</p>
<h2 dir="auto">The Design</h2>
<h3 dir="auto">Interaction Between Existing and New Behavior</h3>
<p dir="auto">The <code>slog</code> package works to ensure consistent output with the <code>log</code> package. Writing to <code>slog</code>&#39;s default logger without setting a handler will write structured text to <code>log</code>&#39;s default logger. Once a handler is set, as in the example above, the default <code>log</code> logger will send its text output to the structured handler.</p>
<h3 dir="auto">Handlers</h3>
<p dir="auto">A <code>slog.Handler</code> describes the logging backend. It is defined as:</p>
<div data-snippet-clipboard-copy-content="type Handler interface {
    // Enabled reports whether this handler is accepting records.
    Enabled(Level) bool

    // Handle processes the Record.
    Handle(Record) error

    // With returns a new Handler whose attributes consist of                                                                                                                        
    // the receiver&#39;s attributes concatenated with the arguments.                                                                                                                              
    With(attrs []Attr) Handler
}"><pre><code>type Handler interface {
    // Enabled reports whether this handler is accepting records.
    Enabled(Level) bool

    // Handle processes the Record.
    Handle(Record) error

    // With returns a new Handler whose attributes consist of                                                                                                                        
    // the receiver&#39;s attributes concatenated with the arguments.                                                                                                                              
    With(attrs []Attr) Handler
}
</code></pre></div>
<p dir="auto">The main method is <code>Handle</code>. It accepts a <code>slog.Record</code> with the timestamp, message, level, caller source position, and key-value pairs of the log event. Each call to a <code>Logger</code> output method, like <code>Info</code>, <code>Error</code> or <code>LogAttrs</code>, creates a <code>Record</code> and invokes the <code>Handle</code> method.</p>
<p dir="auto">The <code>Enabled</code> method is an optimization that can save effort if the log event should be discarded. <code>Enabled</code> is called early, before any arguments are processed.</p>
<p dir="auto">The <code>With</code> method is called by <code>Logger.With</code>, discussed below.</p>
<p dir="auto">The <code>slog</code> package provides two handlers, one for simple textual output and one for JSON. They are described in more detail below.</p>
<h3 dir="auto">The <code>Record</code> Type</h3>
<p dir="auto">The <code>Record</code> passed to a handler exports <code>Time</code>, <code>Message</code> and <code>Level</code> methods, as well as four methods for accessing the sequence of <code>Attr</code>s:</p>
<ul dir="auto">
<li><code>Attrs() []Attr</code> returns a copy of the <code>Attr</code>s as a slice.</li>
<li><code>NumAttrs() int</code> returns the number of <code>Attr</code>s.</li>
<li><code>Attr(int) Attr</code> returns the i&#39;th <code>Attr</code>.</li>
<li><code>SetAttrs([]Attr)</code> replaces the sequence of <code>Attr</code>s with the given slice.</li>
</ul>
<p dir="auto">This API allows an efficient implementation of the <code>Attr</code> sequence that avoids copying and minimizes allocation. <code>SetAttrs</code> supports &#34;middleware&#34; handlers that want to alter the <code>Attr</code>s, say by removing those that contain sensitive data.</p>
<h3 dir="auto">The <code>Attr</code> Type</h3>
<p dir="auto">The <code>Attr</code> type efficiently represents a key-value pair. The key is a string. The value can be any type, but <code>Attr</code> improves on <code>any</code> by storing common types without allocating memory. In particular, integer types and strings, which account for the vast majority of values in log messages, do not require allocation. The default version of <code>Attr</code> uses package <code>unsafe</code> to store any value in three machine words. The version without <code>unsafe</code> requires five.</p>
<p dir="auto">There are convenience functions for constructing <code>Attr</code>s with various value types:</p>
<ul dir="auto">
<li><code>Int(k string, v int) Attr</code></li>
<li><code>Int64(k string, v int64) Attr</code></li>
<li><code>Uint64(k string, v uint64) Attr</code></li>
<li><code>Float64(k string, v float64) Attr</code></li>
<li><code>String(k, v string) Attr</code></li>
<li><code>Bool(k string, v bool) Attr</code></li>
<li><code>Duration(k string, v time.Duration) Attr</code></li>
<li><code>Time(k string, v time.Time) Attr</code></li>
<li><code>Any(k string, v any) Attr</code></li>
</ul>
<p dir="auto">The last of these dispatches on the type of <code>v</code>, using a more efficient representation if <code>Attr</code> supports it and falling back to an <code>any</code> field in <code>Attr</code> if not.</p>
<p dir="auto">The <code>Attr.Key</code> method returns the key. Extracting values from an <code>Attr</code> is reminiscent of <code>reflect.Value</code>: there is a <code>Kind</code> method that returns an enum, and a variety of methods like <code>Int64() int64</code> and <code>Bool() bool</code> that return the value or panic if it is the wrong kind.</p>
<p dir="auto"><code>Attr</code> also has an <code>Equal</code> method, and an <code>AppendValue</code> method that efficiently appends a string representation of the value to a <code>[]byte</code>, in the manner of the <code>strconv.AppendX</code> functions.</p>
<h3 dir="auto">Loggers</h3>
<p dir="auto">A <code>Logger</code> consists of a handler and a list of <code>Attr</code>s. There is a default logger with no attributes whose handler writes to the default <code>log.Logger</code>, as explained above. Create a <code>Logger</code> with <code>New</code>:</p>
<div data-snippet-clipboard-copy-content="func New(h Handler) *Logger"><pre><code>func New(h Handler) *Logger
</code></pre></div>
<p dir="auto">To add attributes to a Logger, use <code>With</code>:</p>
<div data-snippet-clipboard-copy-content="l2 := l1.With(&#34;url&#34;, &#34;http://example.com/&#34;)"><pre><code>l2 := l1.With(&#34;url&#34;, &#34;http://example.com/&#34;)
</code></pre></div>
<p dir="auto">The arguments are interpreted as alternating string keys and and arbitrary values, which are converted to <code>Attr</code>s. <code>Attr</code>s can also be passed directly. Loggers are immutable, so this actually creates a new Logger with the additional attributes. To allow handlers to preprocess attributes, the new Logger’s handler is obtained by calling <code>Handler.With</code> on the old one.</p>
<p dir="auto">You can obtain a logger&#39;s handler with <code>Logger.Handler</code>.</p>
<p dir="auto">The basic logging methods are</p>
<div data-snippet-clipboard-copy-content="func (*Logger) Log(level Level, message string, kvs ...any)"><pre><code>func (*Logger) Log(level Level, message string, kvs ...any)
</code></pre></div>
<p dir="auto">which logs a message at the given level with a list of attributes that are interpreted just as in <code>Logger.With</code>, and the more efficient</p>
<div data-snippet-clipboard-copy-content="func (Logger) LogAttrs(level Level, message string, attrs ...Attr)"><pre><code>func (Logger) LogAttrs(level Level, message string, attrs ...Attr)
</code></pre></div>
<p dir="auto">These functions first call <code>Handler.Enabled(level)</code> to see if they should proceed. If so, they create a <code>Record</code> with the current time, the given level and message, and a list of attributes that consists of the receiver&#39;s attributes followed by the argument attributes. They then pass the <code>Record</code> to <code>Handler.Handle</code>.</p>
<p dir="auto">Each of these methods has an alternative form that takes a call depth, so other functions can wrap them and adjust the source line information.</p>
<p dir="auto">There are four convenience methods for common levels:</p>
<div data-snippet-clipboard-copy-content="func (*Logger) Info(message string, kvs ...any)
func (*Logger) Warn(message string, kvs ...any)
func (*Logger) Debug(message string, kvs ...any)
func (*Logger) Error(message string, err error, kvs ...any)"><pre><code>func (*Logger) Info(message string, kvs ...any)
func (*Logger) Warn(message string, kvs ...any)
func (*Logger) Debug(message string, kvs ...any)
func (*Logger) Error(message string, err error, kvs ...any)
</code></pre></div>
<p dir="auto">They all call <code>Log</code> with the appropriate level. <code>Error</code> first appends <code>Any(&#34;err&#34;, err)</code> to the attributes.</p>
<p dir="auto">There are no convenience methods for <code>LogAttrs</code>. We expect that most programmers will use the more convenient API; those few who need the extra speed will have to type more, or provide wrapper functions.</p>
<p dir="auto">All the methods described in this section are also names of top-level functions that call the corresponding method on the default logger.</p>
<h3 dir="auto">Context Support</h3>
<p dir="auto">Passing a logger in a <code>context.Context</code> is a common practice and a good way to include dynamically scoped information in log messages. For instance, you could construct a <code>Logger</code> with information from an <code>http.Request</code> and pass it through the code that handles the request by adding it to <code>r.Context()</code>.</p>
<p dir="auto">The <code>slog</code> package has two functions to support this pattern. One adds a <code>Logger</code> to a context:</p>
<div data-snippet-clipboard-copy-content="func NewContext(ctx context.Context, l *Logger) context.Context"><pre><code>func NewContext(ctx context.Context, l *Logger) context.Context
</code></pre></div>
<p dir="auto">As an example, an HTTP server might want to create a new <code>Logger</code> for each request. The logger would contain request-wide attributes and be stored in the context for the request:</p>
<div data-snippet-clipboard-copy-content="func handle(w http.ResponseWriter, r *http.Request) {
    rlogger := slog.With(
        &#34;method&#34;, r.Method,
        &#34;url&#34;, r.URL,
        &#34;traceID&#34;, getTraceID(r))
    ctx := slog.NewContext(r.Context(), rlogger)
    // ... use ctx ...
}"><pre><code>func handle(w http.ResponseWriter, r *http.Request) {
    rlogger := slog.With(
        &#34;method&#34;, r.Method,
        &#34;url&#34;, r.URL,
        &#34;traceID&#34;, getTraceID(r))
    ctx := slog.NewContext(r.Context(), rlogger)
    // ... use ctx ...
}
</code></pre></div>
<p dir="auto">To retrieve a <code>Logger</code> from a context, call <code>FromContext</code>:</p>
<div data-snippet-clipboard-copy-content="slog.FromContext(ctx).Info(...)"><pre><code>slog.FromContext(ctx).Info(...)
</code></pre></div>
<p dir="auto"><code>FromContext</code> returns the default logger if it can&#39;t find one in the context.</p>
<h3 dir="auto">Levels</h3>
<p dir="auto">A level is a positive integer, where lower numbers designate more severe or important log events. The <code>slog</code> package provides names for common levels, with gaps between the assigned numbers to accommodate other level schemes. (For example, Google Cloud Platform supports a Notice level between Info and Warn.)</p>
<p dir="auto">Some logging packages like <a href="https://pkg.go.dev/github.com/golang/glog" rel="nofollow">glog</a> and <a href="https://pkg.go.dev/github.com/go-logr/logr" rel="nofollow">Logr</a> use verbosities instead, where a verbosity of 0 corresponds to the Info level and higher values represent less important messages. To use a verbosity of <code>v</code> with this design, pass <code>slog.InfoLevel + v</code> to <code>Log</code> or <code>LogAttrs</code>.</p>
<h3 dir="auto">Provided Handlers</h3>
<p dir="auto">The <code>slog</code> package includes two handlers, which behave similarly except for their output format. <code>TextHandler</code> emits attributes as <code>KEY=VALUE</code>, and <code>JSONHandler</code> writes line-delimited JSON objects. Both can be configured with the same options:</p>
<ul dir="auto">
<li>
<p dir="auto">The boolean <code>AddSource</code> option controls whether the file and line of the log call. It is false by default, because there is a small cost to extracting this information.</p>
</li>
<li>
<p dir="auto">The <code>LevelRef</code> option, of type <code>LevelRef</code>, provides control over the maximum level that the handler will output. For example, setting a handler&#39;s LevelRef to Info will suppress output at Debug and higher levels. A <code>LevelRef</code> is a safely mutable pointer to a level, which makes it easy to dynamically and atomically change the logging level for an entire program.</p>
</li>
<li>
<p dir="auto">To provide fine control over output, the <code>ReplaceAttr</code> option is a function that both accepts and returns an <code>Attr</code>. If present, it is called for every attribute in the log record, including the four built-in ones for time, message, level and (if AddSource is true) the source position. <code>ReplaceAttr</code> can be used to change the default keys of the built-in attributes, convert types (for example, to replace a <code>time.Time</code> with the integer seconds since the Unix epoch), sanitize personal information, or remove attributes from the output.</p>
</li>
</ul>
<h2 dir="auto">Interoperating with Other Log Packages</h2>
<p dir="auto">As stated earlier, we expect that this package will interoperate with other log packages.</p>
<p dir="auto">One way that could happen is for another package&#39;s frontend to send <code>slog.Record</code>s to a <code>slog.Handler</code>. For instance, a <code>logr.LogSink</code> implementation could construct a <code>Record</code> from a message and list of keys and values, and pass it to a <code>Handler</code>. To facilitate that, <code>slog</code> provides a way to construct <code>Record</code>s directly and add attributes to it:</p>
<div data-snippet-clipboard-copy-content="func NewRecord(t time.Time, level Level, msg string, calldepth int) Record

func (*Record) AddAttr(Attr)"><pre><code>func NewRecord(t time.Time, level Level, msg string, calldepth int) Record

func (*Record) AddAttr(Attr)
</code></pre></div>
<p dir="auto">Another way for two log packages to work together is for the other package to wrap its backend as a <code>slog.Handler</code>, so users could write code with the <code>slog</code> package&#39;s API but connect the results to an existing <code>logr.LogSink</code>, for example. This involves writing a <code>slog.Handler</code> that wraps the other logger&#39;s backend. Doing so doesn&#39;t seem to require any additional support from this package.</p>
<h2 dir="auto">Acknowledgements</h2>
<p dir="auto">Ian Cottrell&#39;s ideas about high-performance observability, captured in the <code>golang.org/x/exp/event</code> package, informed a great deal of the design and implementation of this proposal.</p>
<p dir="auto">Seth Vargo’s ideas on logging were a source of motivation and inspiration. His comments on an earlier draft helped improve the proposal.</p>
<p dir="auto">Michael Knyszek explained how logging could work with runtime tracing.</p>
<p dir="auto">Tim Hockin helped us understand logr&#39;s design choices, which led to significant improvements.</p>
<p dir="auto">Abhinav Gupta helped me understand Zap in depth, which informed the design.</p>
<p dir="auto">Russ Cox provided valuable feedback and helped shape the final design.</p>
<h2 dir="auto">Appendix: API</h2>
<div data-snippet-clipboard-copy-content="package slog // import &#34;golang.org/x/exp/slog&#34;


FUNCTIONS

func Debug(msg string, args ...any)
    Debug calls Logger.Debug on the default logger.

func Error(msg string, err error, args ...any)
    Error calls Logger.Error on the default logger.

func Info(msg string, args ...any)
    Info calls Logger.Info on the default logger.

func Log(level Level, msg string, args ...any)
    Log calls Logger.Log on the default logger.

func LogAttrs(level Level, msg string, attrs ...Attr)
    LogAttrs calls Logger.LogAttrs on the default logger.

func NewContext(ctx context.Context, l *Logger) context.Context
    NewContext returns a context that contains the given Logger. Use FromContext
    to retrieve the Logger.

func SetDefault(l *Logger)
    SetDefault makes l the default Logger. After this call, output from the
    log package&#39;s default Logger (as with log.Print, etc.) will be logged at
    InfoLevel using l&#39;s Handler.

func Warn(msg string, args ...any)
    Warn calls Logger.Warn on the default logger.


TYPES

type Attr struct {
	// Has unexported fields.
}
    An Attr is a key-value pair. It can represent some small values without an
    allocation. The zero Attr has a key of &#34;&#34; and a value of nil.

func Any(key string, value any) Attr
    Any returns an Attr for the supplied value.

    Any does not preserve the exact type of integral values. All signed integers
    are converted to int64 and all unsigned integers to uint64. Similarly,
    float32s are converted to float64.

    However, named types are preserved. So given

        type Int int

    the expression

        log.Any(&#34;k&#34;, Int(1)).Value()

    will return Int(1).

func Bool(key string, value bool) Attr
    Bool returns an Attr for a bool.

func Duration(key string, value time.Duration) Attr
    Duration returns an Attr for a time.Duration.

func Float64(key string, value float64) Attr
    Float64 returns an Attr for a floating-point number.

func Int(key string, value int) Attr
    Int converts an int to an int64 and returns an Attr with that value.

func Int64(key string, value int64) Attr
    Int64 returns an Attr for an int64.

func String(key, value string) Attr
    String returns a new Attr for a string.

func Time(key string, value time.Time) Attr
    Time returns an Attr for a time.Time.

func Uint64(key string, value uint64) Attr
    Uint64 returns an Attr for a uint64.

func (a Attr) AppendValue(dst []byte) []byte
    AppendValue appends a text representation of the Attr&#39;s value to dst.
    The value is formatted as with fmt.Sprint.

func (a Attr) Bool() bool
    Bool returns the Attr&#39;s value as a bool. It panics if the value is not a
    bool.

func (a Attr) Duration() time.Duration
    Duration returns the Attr&#39;s value as a time.Duration. It panics if the value
    is not a time.Duration.

func (a1 Attr) Equal(a2 Attr) bool
    Equal reports whether two Attrs have equal keys and values.

func (a Attr) Float64() float64
    Float64 returns the Attr&#39;s value as a float64. It panics if the value is not
    a float64.

func (a Attr) Format(s fmt.State, verb rune)
    Format implements fmt.Formatter. It formats a Attr as &#34;KEY=VALUE&#34;.

func (a Attr) HasValue() bool
    HasValue returns true if the Attr has a value.

func (a Attr) Int64() int64
    Int64 returns the Attr&#39;s value as an int64. It panics if the value is not a
    signed integer.

func (a Attr) Key() string
    Key returns the Attr&#39;s key.

func (a Attr) Kind() Kind
    Kind returns the Attr&#39;s Kind.

func (a Attr) String() string
    String returns Attr&#39;s value as a string, formatted like fmt.Sprint.
    Unlike the methods Int64, Float64, and so on, which panic if the Attr is of
    the wrong kind, String never panics.

func (a Attr) Time() time.Time
    Time returns the Attr&#39;s value as a time.Time. It panics if the value is not
    a time.Duration.

func (a Attr) Uint64() uint64
    Uint64 returns the Attr&#39;s value as a uint64. It panics if the value is not
    an unsigned integer.

func (a Attr) Value() any
    Value returns the Attr&#39;s value as an any. If the Attr does not have a value,
    it returns nil.

func (a Attr) WithKey(key string) Attr
    WithKey returns an attr with the given key and the receiver&#39;s value.

type Handler interface {
	// Enabled reports whether this handler is accepting records
	// at the given level.
	Enabled(Level) bool

	// Handle processes the Record.
	// Handle methods that produce output should observe the following rules:
	//   - If r.Time() is the zero time, do not output it.
	//   - If r.Level() is Level(0), do not output it.
	Handle(Record) error

	// With returns a new Handler whose attributes consist of
	// the receiver&#39;s attributes concatenated with the arguments.
	With(attrs []Attr) Handler
}
    A Handler processes log records produced by Logger output. Any of the
    Handler&#39;s methods may be called concurrently with itself or with other
    methods. It is the responsibility of the Handler to manage this concurrency.

type HandlerOptions struct {
	// Add a &#34;source&#34; attributes to the output whose value is of the form
	// &#34;file:line&#34;.
	AddSource bool

	// Ignore records with levels above LevelRef.Level.
	// If nil, accept all levels.
	LevelRef *LevelRef

	// If set, ReplaceAttr is called on each attribute of the message,
	// and the returned value is used instead of the original. If the returned
	// key is empty, the attribute is omitted from the output.
	//
	// The built-in attributes with keys &#34;time&#34;, &#34;level&#34;, &#34;source&#34;, and &#34;msg&#34;
	// are passed to this function first, except that time and level are omitted
	// if zero, and source is omitted if AddSource is false.
	ReplaceAttr func(a Attr) Attr
}
    HandlerOptions are options for a TextHandler or JSONHandler. A zero
    HandlerOptions consists entirely of default values.

func (opts HandlerOptions) NewJSONHandler(w io.Writer) *JSONHandler
    NewJSONHandler creates a JSONHandler with the given options that writes to
    w.

func (opts HandlerOptions) NewTextHandler(w io.Writer) *TextHandler
    NewTextHandler creates a TextHandler with the given options that writes to
    w.

type JSONHandler struct {
	// Has unexported fields.
}
    JSONHandler is a Handler that writes Records to an io.Writer as
    line-delimited JSON objects.

func NewJSONHandler(w io.Writer) *JSONHandler
    NewJSONHandler creates a JSONHandler that writes to w, using the default
    options.

func (h JSONHandler) Enabled(l Level) bool
    Enabled reports whether l is less than or equal to the maximum level.

func (h *JSONHandler) Handle(r Record) error
    Handle formats its argument Record as a JSON object on a single line.

    If the Record&#39;s time is zero, it is omitted. Otherwise, the key is &#34;time&#34;
    and the value is output in RFC3339 format with millisecond precision.

    If the Record&#39;s level is zero, it is omitted. Otherwise, the key is &#34;level&#34;
    and the value of Level.String is output.

    If the AddSource option is set and source information is available,
    the key is &#34;source&#34; and the value is output as &#34;FILE:LINE&#34;.

    The message&#39;s key is &#34;msg&#34;.

    To modify these or other attributes, or remove them from the output,
    use [HandlerOptions.ReplaceAttr].

    Values are formatted as with encoding/json.Marshal.

    Each call to Handle results in a single, mutex-protected call to
    io.Writer.Write.

func (h *JSONHandler) With(attrs []Attr) Handler
    With returns a new JSONHandler whose attributes consists of h&#39;s attributes
    followed by attrs.

type Kind int
    Kind is the kind of an Attr&#39;s value.

const (
	AnyKind Kind = iota
	BoolKind
	DurationKind
	Float64Kind
	Int64Kind
	StringKind
	TimeKind
	Uint64Kind
)
func (k Kind) String() string

type Level int
    A Level is the importance or severity of a log event. The higher the level,
    the less important or severe the event.

const (
	ErrorLevel Level = 10
	WarnLevel  Level = 20
	InfoLevel  Level = 30
	DebugLevel Level = 31
)
    Names for common levels.

func (l Level) String() string
    String returns a name for the level. If the level has a name, then that
    name in uppercase is returned. If the level is between named values, then an
    integer is appended to the uppercased name. Examples:

        WarnLevel.String() =&gt; &#34;WARN&#34;
        (WarnLevel-2).String() =&gt; &#34;WARN-2&#34;

type LevelRef struct {
	// Has unexported fields.
}
    A LevelRef is a reference to a level. LevelRefs are safe for use by multiple
    goroutines. Use NewLevelRef to create a LevelRef.

    If all the Handlers of a program use the same LevelRef, then a single Set on
    that LevelRef will change the level for all of them.

func NewLevelRef(l Level) *LevelRef
    NewLevelRef creates a LevelRef initialized to the given Level.

func (r *LevelRef) Level() Level
    Level returns the LevelRef&#39;s level. If LevelRef is nil, it returns the
    maximum level.

func (r *LevelRef) Set(l Level)
    Set sets the LevelRef&#39;s level to l.

type Logger struct {
	// Has unexported fields.
}
    A Logger generates Records and passes them to a Handler.

    Loggers are immutable; to create a new one, call New or Logger.With.

func Default() *Logger
    Default returns the default Logger.

func FromContext(ctx context.Context) *Logger
    FromContext returns the Logger stored in ctx by NewContext, or the default
    Logger if there is none.

func New(h Handler) *Logger
    New creates a new Logger with the given Handler.

func With(attrs ...any) *Logger
    With calls Logger.With on the default logger.

func (l *Logger) Debug(msg string, args ...any)
    Debug logs at DebugLevel.

func (l *Logger) Enabled(level Level) bool
    Enabled reports whether l emits log records at level.

func (l *Logger) Error(msg string, err error, args ...any)
    Error logs at ErrorLevel. If err is non-nil, Error appends Any(&#34;err&#34;,
    err) to the list of attributes.

func (l *Logger) Handler() Handler
    Handler returns l&#39;s Handler.

func (l *Logger) Info(msg string, args ...any)
    Info logs at InfoLevel.

func (l *Logger) Log(level Level, msg string, args ...any)
    Log emits a log record with the current time and the given level and
    message. The Record&#39;s Attrs consist of the Logger&#39;s attributes followed by
    the Attrs specified by args.

    The attribute arguments are processed as follows:
      - If an argument is an Attr, it is used as is.
      - If an argument is a string and this is not the last argument, the
        following argument is treated as the value and the two are combined into
        an Attr.
      - Otherwise, the argument is treated as a value with key &#34;!BADKEY&#34;.

func (l *Logger) LogAttrs(level Level, msg string, attrs ...Attr)
    LogAttrs is a more efficient version of Logger.Log that accepts only Attrs.

func (l *Logger) LogAttrsDepth(calldepth int, level Level, msg string, attrs ...Attr)
    LogAttrsDepth is like Logger.LogAttrs, but accepts a call depth argument
    which it interprets like Logger.LogDepth.

func (l *Logger) LogDepth(calldepth int, level Level, msg string, args ...any)
    LogDepth is like Logger.Log, but accepts a call depth to adjust the file
    and line number in the log record. 0 refers to the caller of LogDepth;
    1 refers to the caller&#39;s caller; and so on.

func (l *Logger) Warn(msg string, args ...any)
    Warn logs at WarnLevel.

func (l *Logger) With(attrs ...any) *Logger
    With returns a new Logger whose handler&#39;s attributes are a concatenation of
    l&#39;s attributes and the given arguments, converted to Attrs as in Logger.Log.

type Record struct {
	// Has unexported fields.
}
    A Record holds information about a log event.

func NewRecord(t time.Time, level Level, msg string, calldepth int) Record
    NewRecord creates a new Record from the given arguments. Use Record.AddAttr
    to add attributes to the Record. If calldepth is greater than zero,
    Record.SourceLine will return the file and line number at that depth.

    NewRecord is intended for logging APIs that want to support a Handler as a
    backend. Most users won&#39;t need it.

func (r *Record) AddAttr(a Attr)
    AddAttr appends a to the list of r&#39;s attributes. It does not check for
    duplicate keys.

func (r *Record) Attr(i int) Attr
    Attr returns the i&#39;th Attr in r.

func (r *Record) Attrs() []Attr
    Attrs returns a copy of the sequence of Attrs in r.

func (r *Record) Level() Level
    Level returns the level of the log event.

func (r *Record) Message() string
    Message returns the log message.

func (r *Record) NumAttrs() int
    NumAttrs returns the number of Attrs in r.

func (r *Record) SourceLine() (file string, line int)
    SourceLine returns the file and line of the log event. If the Record
    was created without the necessary information, or if the location is
    unavailable, it returns (&#34;&#34;, 0).

func (r *Record) Time() time.Time
    Time returns the time of the log event.

type TextHandler struct {
	// Has unexported fields.
}
    TextHandler is a Handler that writes Records to an io.Writer as a sequence
    of key=value pairs separated by spaces and followed by a newline.

func NewTextHandler(w io.Writer) *TextHandler
    NewTextHandler creates a TextHandler that writes to w, using the default
    options.

func (h TextHandler) Enabled(l Level) bool
    Enabled reports whether l is less than or equal to the maximum level.

func (h *TextHandler) Handle(r Record) error
    Handle formats its argument Record as a single line of space-separated
    key=value items.

    If the Record&#39;s time is zero, it is omitted. Otherwise, the key is &#34;time&#34;
    and the value is output in RFC3339 format with millisecond precision.

    If the Record&#39;s level is zero, it is omitted. Otherwise, the key is &#34;level&#34;
    and the value of Level.String is output.

    If the AddSource option is set and source information is available,
    the key is &#34;source&#34; and the value is output as FILE:LINE.

    The message&#39;s key &#34;msg&#34;.

    To modify these or other attributes, or remove them from the output,
    use [HandlerOptions.ReplaceAttr].

    Keys are written as unquoted strings. Values are written according to their
    type:
      - Strings are quoted if they contain Unicode space characters or are over
        80 bytes long.
      - If a value implements [encoding.TextMarshaler], the result of
        MarshalText is used.
      - Otherwise, the result of fmt.Sprint is used.

    Each call to Handle results in a single, mutex-protected call to
    io.Writer.Write.

func (h *TextHandler) With(attrs []Attr) Handler
    With returns a new TextHandler whose attributes consists of h&#39;s attributes
    followed by attrs."><pre><code>package slog // import &#34;golang.org/x/exp/slog&#34;


FUNCTIONS

func Debug(msg string, args ...any)
    Debug calls Logger.Debug on the default logger.

func Error(msg string, err error, args ...any)
    Error calls Logger.Error on the default logger.

func Info(msg string, args ...any)
    Info calls Logger.Info on the default logger.

func Log(level Level, msg string, args ...any)
    Log calls Logger.Log on the default logger.

func LogAttrs(level Level, msg string, attrs ...Attr)
    LogAttrs calls Logger.LogAttrs on the default logger.

func NewContext(ctx context.Context, l *Logger) context.Context
    NewContext returns a context that contains the given Logger. Use FromContext
    to retrieve the Logger.

func SetDefault(l *Logger)
    SetDefault makes l the default Logger. After this call, output from the
    log package&#39;s default Logger (as with log.Print, etc.) will be logged at
    InfoLevel using l&#39;s Handler.

func Warn(msg string, args ...any)
    Warn calls Logger.Warn on the default logger.


TYPES

type Attr struct {
	// Has unexported fields.
}
    An Attr is a key-value pair. It can represent some small values without an
    allocation. The zero Attr has a key of &#34;&#34; and a value of nil.

func Any(key string, value any) Attr
    Any returns an Attr for the supplied value.

    Any does not preserve the exact type of integral values. All signed integers
    are converted to int64 and all unsigned integers to uint64. Similarly,
    float32s are converted to float64.

    However, named types are preserved. So given

        type Int int

    the expression

        log.Any(&#34;k&#34;, Int(1)).Value()

    will return Int(1).

func Bool(key string, value bool) Attr
    Bool returns an Attr for a bool.

func Duration(key string, value time.Duration) Attr
    Duration returns an Attr for a time.Duration.

func Float64(key string, value float64) Attr
    Float64 returns an Attr for a floating-point number.

func Int(key string, value int) Attr
    Int converts an int to an int64 and returns an Attr with that value.

func Int64(key string, value int64) Attr
    Int64 returns an Attr for an int64.

func String(key, value string) Attr
    String returns a new Attr for a string.

func Time(key string, value time.Time) Attr
    Time returns an Attr for a time.Time.

func Uint64(key string, value uint64) Attr
    Uint64 returns an Attr for a uint64.

func (a Attr) AppendValue(dst []byte) []byte
    AppendValue appends a text representation of the Attr&#39;s value to dst.
    The value is formatted as with fmt.Sprint.

func (a Attr) Bool() bool
    Bool returns the Attr&#39;s value as a bool. It panics if the value is not a
    bool.

func (a Attr) Duration() time.Duration
    Duration returns the Attr&#39;s value as a time.Duration. It panics if the value
    is not a time.Duration.

func (a1 Attr) Equal(a2 Attr) bool
    Equal reports whether two Attrs have equal keys and values.

func (a Attr) Float64() float64
    Float64 returns the Attr&#39;s value as a float64. It panics if the value is not
    a float64.

func (a Attr) Format(s fmt.State, verb rune)
    Format implements fmt.Formatter. It formats a Attr as &#34;KEY=VALUE&#34;.

func (a Attr) HasValue() bool
    HasValue returns true if the Attr has a value.

func (a Attr) Int64() int64
    Int64 returns the Attr&#39;s value as an int64. It panics if the value is not a
    signed integer.

func (a Attr) Key() string
    Key returns the Attr&#39;s key.

func (a Attr) Kind() Kind
    Kind returns the Attr&#39;s Kind.

func (a Attr) String() string
    String returns Attr&#39;s value as a string, formatted like fmt.Sprint.
    Unlike the methods Int64, Float64, and so on, which panic if the Attr is of
    the wrong kind, String never panics.

func (a Attr) Time() time.Time
    Time returns the Attr&#39;s value as a time.Time. It panics if the value is not
    a time.Duration.

func (a Attr) Uint64() uint64
    Uint64 returns the Attr&#39;s value as a uint64. It panics if the value is not
    an unsigned integer.

func (a Attr) Value() any
    Value returns the Attr&#39;s value as an any. If the Attr does not have a value,
    it returns nil.

func (a Attr) WithKey(key string) Attr
    WithKey returns an attr with the given key and the receiver&#39;s value.

type Handler interface {
	// Enabled reports whether this handler is accepting records
	// at the given level.
	Enabled(Level) bool

	// Handle processes the Record.
	// Handle methods that produce output should observe the following rules:
	//   - If r.Time() is the zero time, do not output it.
	//   - If r.Level() is Level(0), do not output it.
	Handle(Record) error

	// With returns a new Handler whose attributes consist of
	// the receiver&#39;s attributes concatenated with the arguments.
	With(attrs []Attr) Handler
}
    A Handler processes log records produced by Logger output. Any of the
    Handler&#39;s methods may be called concurrently with itself or with other
    methods. It is the responsibility of the Handler to manage this concurrency.

type HandlerOptions struct {
	// Add a &#34;source&#34; attributes to the output whose value is of the form
	// &#34;file:line&#34;.
	AddSource bool

	// Ignore records with levels above LevelRef.Level.
	// If nil, accept all levels.
	LevelRef *LevelRef

	// If set, ReplaceAttr is called on each attribute of the message,
	// and the returned value is used instead of the original. If the returned
	// key is empty, the attribute is omitted from the output.
	//
	// The built-in attributes with keys &#34;time&#34;, &#34;level&#34;, &#34;source&#34;, and &#34;msg&#34;
	// are passed to this function first, except that time and level are omitted
	// if zero, and source is omitted if AddSource is false.
	ReplaceAttr func(a Attr) Attr
}
    HandlerOptions are options for a TextHandler or JSONHandler. A zero
    HandlerOptions consists entirely of default values.

func (opts HandlerOptions) NewJSONHandler(w io.Writer) *JSONHandler
    NewJSONHandler creates a JSONHandler with the given options that writes to
    w.

func (opts HandlerOptions) NewTextHandler(w io.Writer) *TextHandler
    NewTextHandler creates a TextHandler with the given options that writes to
    w.

type JSONHandler struct {
	// Has unexported fields.
}
    JSONHandler is a Handler that writes Records to an io.Writer as
    line-delimited JSON objects.

func NewJSONHandler(w io.Writer) *JSONHandler
    NewJSONHandler creates a JSONHandler that writes to w, using the default
    options.

func (h JSONHandler) Enabled(l Level) bool
    Enabled reports whether l is less than or equal to the maximum level.

func (h *JSONHandler) Handle(r Record) error
    Handle formats its argument Record as a JSON object on a single line.

    If the Record&#39;s time is zero, it is omitted. Otherwise, the key is &#34;time&#34;
    and the value is output in RFC3339 format with millisecond precision.

    If the Record&#39;s level is zero, it is omitted. Otherwise, the key is &#34;level&#34;
    and the value of Level.String is output.

    If the AddSource option is set and source information is available,
    the key is &#34;source&#34; and the value is output as &#34;FILE:LINE&#34;.

    The message&#39;s key is &#34;msg&#34;.

    To modify these or other attributes, or remove them from the output,
    use [HandlerOptions.ReplaceAttr].

    Values are formatted as with encoding/json.Marshal.

    Each call to Handle results in a single, mutex-protected call to
    io.Writer.Write.

func (h *JSONHandler) With(attrs []Attr) Handler
    With returns a new JSONHandler whose attributes consists of h&#39;s attributes
    followed by attrs.

type Kind int
    Kind is the kind of an Attr&#39;s value.

const (
	AnyKind Kind = iota
	BoolKind
	DurationKind
	Float64Kind
	Int64Kind
	StringKind
	TimeKind
	Uint64Kind
)
func (k Kind) String() string

type Level int
    A Level is the importance or severity of a log event. The higher the level,
    the less important or severe the event.

const (
	ErrorLevel Level = 10
	WarnLevel  Level = 20
	InfoLevel  Level = 30
	DebugLevel Level = 31
)
    Names for common levels.

func (l Level) String() string
    String returns a name for the level. If the level has a name, then that
    name in uppercase is returned. If the level is between named values, then an
    integer is appended to the uppercased name. Examples:

        WarnLevel.String() =&gt; &#34;WARN&#34;
        (WarnLevel-2).String() =&gt; &#34;WARN-2&#34;

type LevelRef struct {
	// Has unexported fields.
}
    A LevelRef is a reference to a level. LevelRefs are safe for use by multiple
    goroutines. Use NewLevelRef to create a LevelRef.

    If all the Handlers of a program use the same LevelRef, then a single Set on
    that LevelRef will change the level for all of them.

func NewLevelRef(l Level) *LevelRef
    NewLevelRef creates a LevelRef initialized to the given Level.

func (r *LevelRef) Level() Level
    Level returns the LevelRef&#39;s level. If LevelRef is nil, it returns the
    maximum level.

func (r *LevelRef) Set(l Level)
    Set sets the LevelRef&#39;s level to l.

type Logger struct {
	// Has unexported fields.
}
    A Logger generates Records and passes them to a Handler.

    Loggers are immutable; to create a new one, call New or Logger.With.

func Default() *Logger
    Default returns the default Logger.

func FromContext(ctx context.Context) *Logger
    FromContext returns the Logger stored in ctx by NewContext, or the default
    Logger if there is none.

func New(h Handler) *Logger
    New creates a new Logger with the given Handler.

func With(attrs ...any) *Logger
    With calls Logger.With on the default logger.

func (l *Logger) Debug(msg string, args ...any)
    Debug logs at DebugLevel.

func (l *Logger) Enabled(level Level) bool
    Enabled reports whether l emits log records at level.

func (l *Logger) Error(msg string, err error, args ...any)
    Error logs at ErrorLevel. If err is non-nil, Error appends Any(&#34;err&#34;,
    err) to the list of attributes.

func (l *Logger) Handler() Handler
    Handler returns l&#39;s Handler.

func (l *Logger) Info(msg string, args ...any)
    Info logs at InfoLevel.

func (l *Logger) Log(level Level, msg string, args ...any)
    Log emits a log record with the current time and the given level and
    message. The Record&#39;s Attrs consist of the Logger&#39;s attributes followed by
    the Attrs specified by args.

    The attribute arguments are processed as follows:
      - If an argument is an Attr, it is used as is.
      - If an argument is a string and this is not the last argument, the
        following argument is treated as the value and the two are combined into
        an Attr.
      - Otherwise, the argument is treated as a value with key &#34;!BADKEY&#34;.

func (l *Logger) LogAttrs(level Level, msg string, attrs ...Attr)
    LogAttrs is a more efficient version of Logger.Log that accepts only Attrs.

func (l *Logger) LogAttrsDepth(calldepth int, level Level, msg string, attrs ...Attr)
    LogAttrsDepth is like Logger.LogAttrs, but accepts a call depth argument
    which it interprets like Logger.LogDepth.

func (l *Logger) LogDepth(calldepth int, level Level, msg string, args ...any)
    LogDepth is like Logger.Log, but accepts a call depth to adjust the file
    and line number in the log record. 0 refers to the caller of LogDepth;
    1 refers to the caller&#39;s caller; and so on.

func (l *Logger) Warn(msg string, args ...any)
    Warn logs at WarnLevel.

func (l *Logger) With(attrs ...any) *Logger
    With returns a new Logger whose handler&#39;s attributes are a concatenation of
    l&#39;s attributes and the given arguments, converted to Attrs as in Logger.Log.

type Record struct {
	// Has unexported fields.
}
    A Record holds information about a log event.

func NewRecord(t time.Time, level Level, msg string, calldepth int) Record
    NewRecord creates a new Record from the given arguments. Use Record.AddAttr
    to add attributes to the Record. If calldepth is greater than zero,
    Record.SourceLine will return the file and line number at that depth.

    NewRecord is intended for logging APIs that want to support a Handler as a
    backend. Most users won&#39;t need it.

func (r *Record) AddAttr(a Attr)
    AddAttr appends a to the list of r&#39;s attributes. It does not check for
    duplicate keys.

func (r *Record) Attr(i int) Attr
    Attr returns the i&#39;th Attr in r.

func (r *Record) Attrs() []Attr
    Attrs returns a copy of the sequence of Attrs in r.

func (r *Record) Level() Level
    Level returns the level of the log event.

func (r *Record) Message() string
    Message returns the log message.

func (r *Record) NumAttrs() int
    NumAttrs returns the number of Attrs in r.

func (r *Record) SourceLine() (file string, line int)
    SourceLine returns the file and line of the log event. If the Record
    was created without the necessary information, or if the location is
    unavailable, it returns (&#34;&#34;, 0).

func (r *Record) Time() time.Time
    Time returns the time of the log event.

type TextHandler struct {
	// Has unexported fields.
}
    TextHandler is a Handler that writes Records to an io.Writer as a sequence
    of key=value pairs separated by spaces and followed by a newline.

func NewTextHandler(w io.Writer) *TextHandler
    NewTextHandler creates a TextHandler that writes to w, using the default
    options.

func (h TextHandler) Enabled(l Level) bool
    Enabled reports whether l is less than or equal to the maximum level.

func (h *TextHandler) Handle(r Record) error
    Handle formats its argument Record as a single line of space-separated
    key=value items.

    If the Record&#39;s time is zero, it is omitted. Otherwise, the key is &#34;time&#34;
    and the value is output in RFC3339 format with millisecond precision.

    If the Record&#39;s level is zero, it is omitted. Otherwise, the key is &#34;level&#34;
    and the value of Level.String is output.

    If the AddSource option is set and source information is available,
    the key is &#34;source&#34; and the value is output as FILE:LINE.

    The message&#39;s key &#34;msg&#34;.

    To modify these or other attributes, or remove them from the output,
    use [HandlerOptions.ReplaceAttr].

    Keys are written as unquoted strings. Values are written according to their
    type:
      - Strings are quoted if they contain Unicode space characters or are over
        80 bytes long.
      - If a value implements [encoding.TextMarshaler], the result of
        MarshalText is used.
      - Otherwise, the result of fmt.Sprint is used.

    Each call to Handle results in a single, mutex-protected call to
    io.Writer.Write.

func (h *TextHandler) With(attrs []Attr) Handler
    With returns a new TextHandler whose attributes consists of h&#39;s attributes
    followed by attrs.
</code></pre></div>
    </td>
  </tr>

    </tbody>
  </div></div>
  </body>
</html>
