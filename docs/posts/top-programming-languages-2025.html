<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://spectrum.ieee.org/top-programming-languages-2025">Original</a>
    <h1>Top Programming Languages 2025</h1>
    
    <div id="readability-page-1" class="page"><div data-headline="The Top Programming Languages 2025"><div><p><span>Since 2013, we’ve been metaphorically peering over the shoulders of <a href="https://spectrum.ieee.org/tag/programmers">programmers</a> to create our annual interactive rankings of the most popular <a href="https://spectrum.ieee.org/tag/programming">programming</a> languages. But fundamental shifts in how people are coding may not just make it harder to measure popularity, but could even make the concept itself irrelevant. And then things might get </span><em><em>really</em></em><span> weird. To see why, let’s start with this year’s rankings and a quick refresher of how we put this thing together.</span></p><p>In the “<em><em>Spectrum</em></em>” default ranking, which is weighted with the interests of IEEE members in mind, we see that once again<a href="https://www.python.org/" target="_blank"> Python</a> has the top spot, with the biggest change in the top five being<a href="https://javascript.info/" target="_blank"> JavaScript</a>’s drop from third place last year to sixth place this year. As <a href="https://spectrum.ieee.org/tag/javascript">JavaScript</a> is often used to create web pages, and vibe coding is often used to create websites, this drop in the apparent popularity may be due to the effects of AI that we’ll dig into in a moment. But first to finish up with this year’s scores, in the “Jobs” ranking, which looks exclusively at what skills employers are looking for, we see that <a href="https://spectrum.ieee.org/tag/python">Python</a> has also taken 1<span>st</span> place, up from second place last year, though<a href="https://www.w3schools.com/sql/" target="_blank"> SQL</a> expertise remains an incredibly valuable skill to have on your resume.</p><p>Because we can’t literally look over the shoulders of everyone who codes, including kids hacking on<a href="https://modrinth.com/mods" target="_blank"> Minecraft</a> <a href="https://spectrum.ieee.org/tag/servers">servers</a> or academic researchers developing new architectures, we rely on proxies to measure popularity. We detail <a href="https://spectrum.ieee.org/top-programming-languages-methodology-2025" target="_blank">our methodology here</a>, but the upshot is that we merge metrics from multiple sources to create our rankings. The metrics we choose publicly signal interest across a wide range of languages—Google search traffic, questions asked on<a href="https://stackexchange.com/" target="_blank"> Stack Exchange</a>, mentions in research papers, activity on the <a href="https://spectrum.ieee.org/tag/github">GitHub</a> <a href="https://spectrum.ieee.org/tag/open-source">open source</a> code repository, and so on.</p><p>But programmers are turning away from many of these public expressions of interest. Rather than page through a book or search a website like Stack Exchange for answers to their questions, they’ll chat with an LLM like<a href="https://claude.ai/" target="_blank"> Claude</a> or <a href="https://chatgpt.com/" target="_blank">ChatGPT</a> in a private conversation. And with an AI assistant like <a href="https://cursor.com/" target="_blank">Cursor</a> helping to write code, the need to pose questions in the first place is significantly decreased. For example, across the total set of languages evaluated in the TPL, the number of questions we saw posted per week on Stack Exchange in 2025 was just 22 percent of what it was in 2024.</p><p>With less signal in publicly available metrics, it becomes harder to track popularity across a broad range of languages. This existential problem for our rankings can be tackled by searching for new metrics, or trying to survey programmers—in all their variety—directly. <span>However, an even more fundamental problem is looming in the wings.</span></p><p>Whether it’s a seasoned coder<a href="https://spectrum.ieee.org/chatgpt-code" target="_self"> using an AI to handle the grunt work</a>, or a neophyte vibe coding a complete web app, AI assistance means that programmers can concern themselves less and less with the particulars of any language. First details of syntax, then flow control and functions, and so on up the levels of how a program is put together—more and more is being left to the AI.</p><p>Although code-writing LLM’s are still very much a <a href="https://spectrum.ieee.org/ai-for-coding" target="_self">work in progress</a>, as they take over an increasing share of the work, programmers inevitably shift from being the kind of people willing to fight religious wars over whether <a href="https://spectrum.ieee.org/tag/source-code">source code</a> should be indented by<a href="https://youtu.be/cowtgmZuai0?si=R4uNNt2P3Ynxb0wG" target="_blank"> typing tabs or spaces</a> to people who care less and less about what <em>language</em> is used.</p><p>After all, the whole reason different computer languages exist is because given a particular challenge, it’s easier to express a solution in one language versus another. You wouldn’t<a href="https://github.com/mnr/rpigpior" target="_blank"> control a washing machine</a> using the<a href="https://www.r-project.org/" target="_blank"> R programming language</a>, or conversely do a statistical analysis on large datasets using <a href="https://en.wikipedia.org/wiki/C_(programming_language)" target="_blank">C</a>.</p><p>But it <em><em>is</em></em> technically possible to do both. A human might tear their hair out doing it, but LLMs have about as much hair as they do sentience. As long as there’s enough training data, they’ll generate code for a given prompt in any language you want. In practical terms, this means using one—any one—of today’s most popular general purpose <a href="https://spectrum.ieee.org/tag/programming-languages">programming languages</a>. In the same way most developers today don’t pay much attention to the instruction sets and other hardware idiosyncrasies of the CPUs that their code runs on, which language a program is vibe coded in ultimately becomes a minor detail.</p><p>Sure, there will always be some people who care, just as today there are nerds like me willing to debate the merits of writing for the<a href="https://spectrum.ieee.org/chip-hall-of-fame-zilog-z80-microprocessor" target="_self"> Z80</a> versus the<a href="https://spectrum.ieee.org/chip-hall-of-fame-mos-technology-6502-microprocessor" target="_self"> 6502</a> 8-bit CPUs. But overall, the popularity of different computer languages could become as obscure a topic as the relative popularity of railway track gauges.</p><p>One obvious long-term consequence to this is that it will become harder for new languages to emerge. Previously, new languages could emerge from individuals or small teams evangelizing their approach to potential contributors and users. Presentations, papers, demos, sample code and tutorials seeded new developer ecosystems. A single well-written book, like Leo Brodie’s<a href="https://www.forth.com/starting-forth/" rel="noopener noreferrer" target="_blank"> <em><em>Starting Forth</em></em></a> or Brian Kernighan and Dennis Ritchies’<a href="https://ia903407.us.archive.org/35/items/the-ansi-c-programming-language-by-brian-w.-kernighan-dennis-m.-ritchie.org/The%20ANSI%20C%20Programming%20Language%20by%20Brian%20W.%20Kernighan%2C%20Dennis%20M.%20Ritchie.pdf" rel="noopener noreferrer" target="_blank"> <em><em>The C Programming Language</em></em></a>, could make an enormous difference to a language’s popularity.</p><p>But while a few samples and a tutorial can be enough material to jump-start adoption among programmers familiar with the ins and outs of hands-on coding, it’s not enough for today’s AIs. Humans build mental models that can extrapolate from relatively small amounts of data. LLMs rely on statistical probabilities, so the more data they can crunch, they better they are. Consequently programmers have noted that<a href="https://www.reddit.com/r/ChatGPTCoding/comments/1gf9aap/training_ai_on_lesser_known_languages/" rel="noopener noreferrer" target="_blank"> AIs give noticeably poorer results</a> when trying to code in less-used languages.</p><p>There are research efforts to<a href="https://news.mit.edu/2025/making-ai-generated-code-more-accurate-0418" rel="noopener noreferrer" target="_blank"> make LLMs more universal coders</a>, but that doesn’t really help new languages get off the ground. Fundamentally new languages grow because they are scratching some itch a programmer has. That itch can be as small as being<a href="https://www.codewithc.com/why-python-doesnt-use-semicolon-pythons-syntax-design/?amp=1" rel="noopener noreferrer" target="_blank"> annoyed at semicolons</a> having to be placed after every statement, or as large as a philosophical argument about the<a href="https://writings.stephenwolfram.com/2019/05/what-weve-built-is-a-computational-language-and-thats-very-important/" rel="noopener noreferrer" target="_blank"> purpose of computation</a>.</p><p>But if an AI is soothing our irritations with today’s languages, will any new ones ever reach the kind of critical mass needed to make an impact? Will the popularity of today’s languages remain frozen in time?</p><h2>What’s the future of programming languages?</h2><p>Before speculating further about the future, let’s touch base again where we are today. Modern high-level computer languages are really designed to do two things: create an abstraction layer that makes it easier to process data in a suitable fashion, and stop programmers from shooting themselves in the foot.</p><p>The first objective has been around since the days of<a href="https://fortran-lang.org/" rel="noopener noreferrer" target="_blank"> Fortran</a> and<a href="https://developer.ibm.com/languages/cobol/" rel="noopener noreferrer" target="_blank"> Cobol</a>, aimed at processing scientific and business data respectively. The second objective emerged later, spurred in no small part by Edgar Dijkstra’s 1968 paper “<a href="https://homepages.cwi.nl/~storm/teaching/reader/Dijkstra68.pdf" rel="noopener noreferrer" target="_blank">Go To Statement Considered Harmful</a>.” In this he argued for eliminating the ability for a programmer to make jumps to arbitrary points in their code. This restriction was to prevent so-called spaghetti code that makes it hard for a programmer to understand how a computer actually executes a given program. Instead, Dijkstra demanded that programmers bend to structural rules imposed by the language. Dijkstra’s argument ultimately won the day, and most modern languages do indeed minimize or eliminate Go Tos altogether in favor of structures like functions and other programmatic blocks.</p><p>These structures don’t exist at the level of the CPU. If you look at the instruction sets for Arm, x86, or <a href="https://spectrum.ieee.org/tag/risc-v">RISC-V</a> <a href="https://spectrum.ieee.org/tag/processors">processors</a>, the flow of a program is controlled by just three types of <a href="https://spectrum.ieee.org/tag/machine-code">machine code</a> instructions. These are conditional jumps, unconditional jumps, and jumps with a trace stored (so you can call a subroutine and return to where you started). In other words, it’s Go Tos all the way down. Similarly, strict <a href="https://en.wikipedia.org/wiki/Data_type" target="_blank">data types</a> designed to label and protect data from incorrect use dissolve into anonymous bits flowing in and out of memory.</p><p>So how much abstraction and anti-foot-shooting structure will a sufficiently-advanced coding AI really need? A hint comes from recent research in AI-assisted hardware design, such as<a href="https://ieeexplore.ieee.org/abstract/document/11103838" rel="noopener noreferrer" target="_blank"> Dall-EM</a>, a <a href="https://spectrum.ieee.org/tag/generative-ai">generative AI</a> developed at <a href="https://spectrum.ieee.org/tag/princeton-university">Princeton University</a> used to create RF and electromagnetic filters.  Designing these filters has always been something of a black art, involving the wrangling of complex electromagnetic fields as they swirl around little strips of metal. But Dall-EM can take in the desired inputs and outputs and spit out something that looks like a <a href="https://spectrum.ieee.org/tag/qr-code">QR code</a>. The results are something no human would ever design—but it works.</p><p>Similarly, could we get our AIs to go straight from prompt to an<a href="https://en.wikipedia.org/wiki/Intermediate_representation" rel="noopener noreferrer" target="_blank"> intermediate language</a> that could be fed into the interpreter or compiler of our choice? Do we need high-level languages at all in that future? True, this would turn programs into inscrutable <a href="https://spectrum.ieee.org/tag/black-boxes">black boxes</a>, but they could still be divided into modular testable units for sanity and quality checks. And instead of trying to read or maintain source code, programmers would just tweak their prompts and generate software afresh.</p><p>What’s the role of the programmer in a future without source code? Architecture design and algorithm selection would remain vital skills—for example, should a pathfinding program use a classic approach like the<a href="https://en.wikipedia.org/wiki/A*_search_algorithm" rel="noopener noreferrer" target="_blank"> A* algorithm</a>, or instead should it try to<a href="https://www.quantamagazine.org/new-method-is-the-fastest-way-to-find-the-best-routes-20250806/" rel="noopener noreferrer" target="_blank"> implement a new </a>method? How should a piece of software be interfaced with a larger system? How should new hardware be exploited? In this scenario, computer science degrees, with their emphasis on fundamentals over the details of programming languages, rise in value over coding boot camps.</p><p>Will there be a Top Programming Language in 2026? Right now, programming is going through the biggest transformation since <a href="https://spectrum.ieee.org/tag/compilers">compilers</a> broke onto the scene in the early 1950s. Even if the predictions that much of <a href="https://spectrum.ieee.org/ai-index-2025" target="_self">AI is a bubble</a> about to burst come true, the thing about tech bubbles is that there’s always some residual technology that survives. It’s likely that using LLMs to write and assist with code is something that’s going to stick. So we’re going to be spending the next 12 months figuring out what popularity means in this new age, and what metrics might be useful to measure. What do <em>you</em> think popularity should mean? What metrics do you think we should consider? Let us know in the comments below.</p></div></div></div>
  </body>
</html>
