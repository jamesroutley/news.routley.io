<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://radiki.dev/posts/match-and-bind-patterns/">Original</a>
    <h1>A step beyond Rust&#39;s pattern matching</h1>
    
    <div id="readability-page-1" class="page"><div>
      
      <h3 id="if-you-dont-need-a-refresh-of-basic-rust-pattern-match-go-directly-to-the-new-stuffglowdust">
  If you don’t need a refresh of basic Rust pattern match, go directly to <a href="#glowdust">the new stuff</a>
  <a href="#if-you-dont-need-a-refresh-of-basic-rust-pattern-match-go-directly-to-the-new-stuffglowdust" aria-hidden="true">#</a>
</h3>
<h2 id="a-very-opinionated-reminder-of-patterns-in-rust">
  A very opinionated reminder of patterns in Rust
  <a href="#a-very-opinionated-reminder-of-patterns-in-rust" aria-hidden="true">#</a>
</h2>
<p>Here’s a simple pattern match in Rust:</p>
<p>Pretty anticlimactic, huh? Well, let me spice it up a bit:</p>
<p>Still not good enough? Ok, let’s try something fancier:</p>
<div><pre tabindex="0"><code data-lang="Rust"><span><span><span>let</span> (a, <span>2</span>) <span>=</span> (<span>1</span>, <span>2</span>); <span>// Does not compile
</span></span></span><span><span><span></span>
</span></span><span><span>error[E0005]: <span>refutable</span> pattern <span>in</span> local binding
</span></span><span><span> <span>-</span>-&gt; <span>src</span><span>/</span>example.rs:<span>3</span>:<span>9</span>
</span></span><span><span>  <span>|</span>
</span></span><span><span><span>3</span> <span>|</span>     <span>let</span> (a, <span>2</span>) <span>=</span> (<span>1</span>, <span>2</span>);
</span></span><span><span>  <span>|</span>         <span>^^^^^^</span> patterns <span>`</span>(_, <span>i32</span>::<span>MIN</span><span>..=</span><span>1_</span><span>i32</span>)<span>`</span> and <span>`</span>(_, <span>3_</span><span>i32</span><span>..=</span><span>i32</span>::<span>MAX</span>)<span>`</span> not covered
</span></span><span><span>  <span>|</span>
</span></span><span><span>  <span>=</span> note: <span>`</span><span>let</span><span>`</span> bindings require an <span>&#34;irrefutable pattern&#34;</span>, like a <span>`</span><span>struct</span><span>`</span> or an <span>`</span><span>enum</span><span>`</span> with only one variant
</span></span></code></pre></div><p>Well, that escalated quickly.</p>
<p>Now, <code>rustc</code> and I have had our disagreements, but in this case I can sort of see the point: This pattern can, in theory, fail.
Our puny human eyes may not see it - in fact, you may think “hey, I am pretty sure 2 is equal to 2. How can that fail?”</p>
<p>Good point. But what if it was</p>
<div><pre tabindex="0"><code data-lang="Rust"><span><span><span>let</span> (a, <span>2</span>) <span>=</span> (<span>1</span>, <span>1</span><span>+</span><span>1</span>); <span>// Does not compile either
</span></span></span></code></pre></div><p>Or some other, more complicated expression? No, says <code>rustc</code>, as long as there is an equality at play,
(by having a constant on the left hand side, for example), I will not let you do this unconditionally.</p>
<p>But <em>conditionally</em>? No problem.</p>
<p>Let’s do that, then</p>
<div><pre tabindex="0"><code data-lang="Rust"><span><span><span>if</span> <span>let</span> (a, <span>2</span>) <span>=</span> (<span>1</span>, <span>2</span>) {
</span></span><span><span>    println!(<span>&#34;Made it, a is </span><span>{}</span><span>&#34;</span>, a);
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>// prints &#34;Made it, a is 1&#34;
</span></span></span></code></pre></div><p>Excellent. I can pattern match on constants and capture variables. Let’s do something more complex</p>
<div><pre tabindex="0"><code data-lang="Rust"><span><span><span>if</span> <span>let</span> (a, <span>2</span>) <span>=</span> (<span>1</span>, <span>2</span>) <span>&amp;&amp;</span>
</span></span><span><span>   <span>let</span> (b, <span>4</span>) <span>=</span> (<span>3</span>, <span>4</span>) <span>&amp;&amp;</span>
</span></span><span><span>    println!(<span>&#34;Made it, a = </span><span>{}</span><span>, b = </span><span>{}</span><span>&#34;</span>, a, b);
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>// prints &#34;Made it, a = 1, b = 3&#34;
</span></span></span></code></pre></div><p>Nice, I can do conditionals between pattern matches and variable bindings. The example above is silly
because the pattern will always match, but the syntax is what matters here.</p>
<p>I can even build on this, to add conditions for the already bound variables:</p>
<div><pre tabindex="0"><code data-lang="Rust"><span><span><span>if</span> <span>let</span> (a, <span>2</span>) <span>=</span> (<span>1</span>, <span>2</span>) <span>&amp;&amp;</span>
</span></span><span><span>   <span>let</span> (c, <span>4</span>) <span>=</span> (<span>3</span>, <span>4</span>) <span>&amp;&amp;</span>
</span></span><span><span>   b <span>==</span> a <span>+</span> <span>2</span> {
</span></span><span><span>      println!(<span>&#34;Made it, a = </span><span>{}</span><span>, b = </span><span>{}</span><span>&#34;</span>, a, b);
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>// still prints &#34;Made it, a = 1, b = 3&#34;
</span></span></span></code></pre></div><h2 id="glowdust">
  And that’s where all the trouble begun
  <a href="#glowdust" aria-hidden="true">#</a>
</h2>
<p>Watching this, I couldn’t help but think that it looks a lot like a declarative query…thing?</p>
<p>Say I have a vector of pairs:</p>
<div><pre tabindex="0"><code data-lang="Rust"><span><span><span>let</span> the_data <span>=</span> vec![
</span></span><span><span>	(<span>1</span>, <span>2</span>),
</span></span><span><span>	(<span>2</span>, <span>2</span>)
</span></span><span><span>	(<span>2</span>, <span>3</span>),
</span></span><span><span>	(<span>5</span>, <span>7</span>),
</span></span><span><span>	(<span>8</span>, <span>8</span>)];
</span></span></code></pre></div><p>I can grab an iterator out of it and do the same pattern matching in a for loop:</p>
<div><pre tabindex="0"><code data-lang="Rust"><span><span><span>for</span> (a, b) <span>in</span> the_data {
</span></span><span><span>    println!(<span>&#34;(</span><span>{}</span><span>, </span><span>{}</span><span>)&#34;</span>, a, b);
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>// prints
</span></span></span><span><span><span>// (1, 2)
</span></span></span><span><span><span>// (2, 3)
</span></span></span><span><span><span>// (5, 7)
</span></span></span><span><span><span>// (8, 8)
</span></span></span></code></pre></div><p>This is trivial, but it is also clearly a pattern match.</p>
<p><em>And I want to do it conditionally, in the match itself.</em></p>
<p>Let’s try a <code>while</code> instead of a <code>for</code></p>
<div><pre tabindex="0"><code data-lang="Rust"><span><span><span>while</span> <span>let</span> Some((a, b)) <span>=</span> iterator.next() <span>&amp;&amp;</span> <span>*</span>b <span>==</span> <span>*</span>a <span>+</span> <span>1</span>  {
</span></span><span><span>    println!(<span>&#34;(</span><span>{}</span><span>, </span><span>{}</span><span>)&#34;</span>, a, b);
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>// prints
</span></span></span><span><span><span>// (1, 2)
</span></span></span><span><span><span>// (2, 3)
</span></span></span></code></pre></div><p>Ok, not bad, we’ve got some kind of a conditional going. But I want something more.
I want to do it in the pattern binding:</p>
<div><pre tabindex="0"><code data-lang="Rust"><span><span><span>while</span> <span>let</span> Some((a, a <span>+</span> <span>1</span>)) <span>=</span> iterator.next() { <span>// How cool would it be if this worked?
</span></span></span><span><span><span></span>    println!(<span>&#34;(</span><span>{}</span><span>, </span><span>{}</span><span>)&#34;</span>, a, b);
</span></span><span><span>}
</span></span></code></pre></div><p>Sadly, it doesn’t work:</p>
<div><pre tabindex="0"><code data-lang="Rust"><span><span>error: <span>expected</span> a pattern, found an expression
</span></span><span><span>  <span>-</span>-&gt; <span>src</span><span>/</span>example.rs:<span>11</span>:<span>24</span>
</span></span><span><span>   <span>|</span>
</span></span><span><span><span>11</span> <span>|</span>     <span>while</span> <span>let</span> Some((a, a <span>+</span> <span>1</span>)) <span>=</span> iterator.next() {
</span></span><span><span>   <span>|</span>                        <span>^^^^^</span> arbitrary expressions are not allowed <span>in</span> patterns
</span></span></code></pre></div><p>Now, I am not a language designer, and I know next to nothing about Rust internals (I barely know Rust, to be honest).
I can’t say if allowing this would break other things in the language or if it’s a well known bad idea.</p>
<p>Thankfully, my ignorance is my shield, and I have no problems whatsoever making this work in my own language.</p>
<h2 id="pattern-matching-in-glowdust">
  Pattern matching in Glowdust
  <a href="#pattern-matching-in-glowdust" aria-hidden="true">#</a>
</h2>
<p>The algorithm in Glowdust is simple.</p>
<p>Just like in Rust, if there is an unbound variable in the left hand side of a pattern, then it is bound to whatever is on the right hand side.
From then on, it is bound, and it behaves as a match, again like Rust does.</p>
<p><em>(NOTE: I say left hand/right hand side, but in Glowdust syntax the -&gt; operator flips the two sides. Keep that in mind for the following examples)</em></p>
<p>The difference is that it does both in the same pattern. Here’s an example, in Glowdust</p>
<p>First define a function to hold our data:</p>
<p>Then populate with the same data as the iterator example above and query that:</p>
<div><pre tabindex="0"><code data-lang="Rust"><span><span>my(<span>1</span>) <span>=</span> (<span>1</span>, <span>2</span>);
</span></span><span><span>my(<span>2</span>) <span>=</span> (<span>2</span>, <span>3</span>);
</span></span><span><span>my(<span>3</span>) <span>=</span> (<span>5</span>, <span>7</span>);
</span></span><span><span>my(<span>4</span>) <span>=</span> (<span>8</span>, <span>8</span>);
</span></span><span><span>
</span></span><span><span><span>match</span> my(x) -&gt; (y1, y1 <span>+</span> <span>1</span>), <span>return</span> y1
</span></span></code></pre></div><p>This works as expected:</p>
<p>But let’s not stop here. Let’s use this capability to do a join:</p>
<div><pre tabindex="0"><code data-lang="Rust"><span><span><span>match</span> my(_) -&gt; (left, middle), my(_) -&gt; (middle, right), <span>return</span> left, middle, right
</span></span></code></pre></div><p>This works exactly because the first time a variable is met it is bound, and then it’s used as a <em>refutable</em> match.</p>
<p><code>middle</code>, in this case, is bound in the outer loop and then its value is used as a refutable pattern in the inner loop.</p>
<p>It also has a very declarative, pattern matching feel to it, but it is very familiar and readable.
The predicates it implies can be moved around and be optimized according to
cardinalities and other statistics in the data store. They can even be pushed down to the
storage layer, if computational storage becomes available.</p>
<p>Did I mention that it works?
You can run these examples right now, today, in <a href="https://codeberg.org/glowdust/glowdust">Glowdust</a>.</p>
<h2 id="query-by-example-didnt-go-far-enough">
  Query By Example didn’t go far enough
  <a href="#query-by-example-didnt-go-far-enough" aria-hidden="true">#</a>
</h2>
<p>This may remind you of Query By Example in MS Access or Hibernate.</p>
<p>It isn’t.</p>
<p>It’s Query By Pattern, which is much cooler.</p>
<p>This compiles down to proper bytecode, it isn’t just a DSL. You can have full expressions reusing
variables that just came into scope, join on them and use them in further expressions like filters and
(eventually) aggregations.</p>
<p>I think the comparison to Rust’s (and other languages’) patern matching is interesting, but I don’t
remotely argue that it is better. It is, however, better suited for a database query language.</p>
<p>Which is quite fortunate, because that’s what I’m building.</p>
<hr/>
<p>As always, let me know your thoughts on <a href="https://fosstodon.org/@chrisg">Mastodon</a></p>
<p>And, if you find this interesting enough, you may want to <a href="https://liberapay.com/chris.gioran/">donate</a> towards the costs of developing Glowdust.</p>

    </div></div>
  </body>
</html>
