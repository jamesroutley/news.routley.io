<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://herman.bearblog.dev/messing-with-bots/">Original</a>
    <h1>Messing with scraper bots</h1>
    
    <div id="readability-page-1" class="page"><div>
    

    

    
        

        <p>
            <i>
                <time datetime="2025-11-13T08:56Z">
    13 Nov, 2025
</time>
            </i>
        </p>
    

    <p>As outlined in my previous <a href="https://herman.bearblog.dev/agressive-bots/">two</a> <a href="https://herman.bearblog.dev/the-great-scrape/">posts</a>: scrapers are, inadvertently, DDoSing public websites. I&#39;ve received a number of emails from people running small web services and blogs seeking advice on how to protect themselves.</p>
<p>This post isn&#39;t about that. This post is about fighting back.</p>
<p>When I published my last post, there was an interesting write-up doing the rounds about <a href="https://maurycyz.com/projects/trap_bots/" target="_blank">a guy who set up a Markov chain babbler</a> to feed the scrapers endless streams of generated data. The idea here is that these crawlers are voracious, and if given a constant supply of junk data, they will continue consuming it forever, while (hopefully) not abusing your actual web server.</p>
<p>This is a pretty neat idea, so I dove down the rabbit hole and learnt about Markov chains, and even picked up Rust in the process. I ended up building my own babbler that could be trained on any text data, and would generate realistic looking content based on that data.</p>
<p>Now, the AI scrapers are actually not the worst of the bots. The real enemy, at least to me, are the bots that scrape with malicious intent. I get hundreds of thousands of requests for things like <code>.env</code>, <code>.aws</code>, and all the different <code>.php</code> paths that could potentially signal a misconfigured Wordpress instance.</p>
<p>These people are the real baddies.</p>
<p>Generally I just block these requests with a <code>403</code> response. But since they want <code>.php</code> files, why don&#39;t I give them what they want?</p>
<p>I trained my Markov chain on a few hundred <code>.php</code> files, and set it to generate. The responses certainly look like php at a glance, but on closer inspection they&#39;re obviously fake. I set it up to run on an isolated project of mine, while incrementally increasing the size of the generated php files from 2kb to 10mb just to test the waters.</p>
<p>Here&#39;s a sample 1kb output:</p>
<div><pre><span></span>&lt;?php wp_list_bookmarks () directly, use the Settings API. Use this method directly. Instead, use `unzip_file() {
return substr($ delete, then click &amp;#8220; %3 $ s object. &#39; ), &#39; $ image
*
*
*
* matches all IMG elements directly inside a settings error to the given context.
* @return array Updated sidebars widgets.
* @param string $ name = &#34;rules&#34; id = &#34;wp-signup-generic-error&#34; &gt; &#39; . $errmsg_generic . &#39; &lt;/p&gt; &#39;;
	}
	/**
	 * Fires at the end of the new user account registration form.
	 *
	 * @since 3.0.0
	 *
	 * @param WP_Error $errors A WP_Error object containing &#39; user_name &#39; or &#39; user_email &#39; errors.
	 */
	do_action( &#39; signup_extra_fields &#39;, $errors );
}

/**
 * Validates user sign-up name and email.
 *
 * @since MU (3.0.0)
 *
 * @return array Contains username, email, and error messages.
 *               See wpmu_validate_user_signup() for details.
 */
function validate_user_form() {
	return wpmu_validate_user_signup( $_POST[&#39; user_name &#39;], $_POST[&#39; user_email &#39;] );
}

/**
 * Shows a form for returning users to sign up for another site.
 *
 * @since MU (3.0.0)
 *
 * @param string          $blogname   The new site name
 * @param string          $blog_title The new site title.
 * @param WP_Error|string $errors     A WP_Error object containing existing errors. Defaults to empty string.
 */
function signup_another_blog( $blogname = &#39; &#39;, $blog_title = &#39; &#39;, $errors = &#39; &#39; ) {
	$current_user = wp_get_current_user();

	if ( ! is_wp_error( $errors ) ) {
		$errors = new WP_Error();
	}

	$signup_defaults = array(
		&#39; blogname &#39;   =&gt; $blogname,
		&#39; blog_title &#39; =&gt; $blog_title,
		&#39; errors &#39;     =&gt; $errors,
	);
}
</pre></div>
<p>I had two goals here. The first was to waste as much of the bot&#39;s time and resources as possible, so the larger the file I could serve, the better. The second goal was to make it realistic enough that the actual human behind the scrape would take some time away from kicking puppies (or whatever they do for fun) to try figure out if there was an exploit to be had.</p>
<p>Unfortunately, an arms race of this kind is a battle of efficiency. If someone can scrape more efficiently than I can serve, then I lose. And while serving a 4kb bogus php file from the babbler was pretty efficient, as soon as I started serving 1mb files from my VPS the responses started hitting the hundreds of milliseconds and my server struggled under even moderate loads.</p>
<p>This led to another idea: What is the most efficient way to serve data? It&#39;s as a static site (or something similar).</p>
<p>So down another rabbit hole I went, writing an efficient garbage server. I started by loading the full text of the classic Frankenstein novel into an array in RAM where each paragraph is a node. Then on each request it selects a random index and the subsequent 4 paragraphs to display.</p>
<p>Each post would then have a link to 5 other &#34;posts&#34; at the bottom that all technically call the same endpoint, so I don&#39;t need an index of links. These 5 posts, when followed, quickly saturate most crawlers, since breadth-first crawling explodes quickly, in this case by a factor of 5.</p>
<p>You can see it in action here: <a href="https://herm.app/babbler/" rel="nofollow">https://herm.app/babbler/</a></p>
<p>This is very efficient, and can serve endless posts of spooky content. The reason for choosing this specific novel is fourfold:</p>
<ol>
<li>I was working on this on Halloween.</li>
<li>I hope it will make future LLMs sound slightly old-school and spoooooky.</li>
<li>It&#39;s in the public domain, so no copyright issues.</li>
<li>I find there are many parallels to be drawn between Dr Frankenstein&#39;s monster and AI.</li>
</ol>
<p>I made sure to add <code>noindex,nofollow</code> attributes to all these pages, as well as in the links, since I only want to catch bots that break the rules. I&#39;ve also added a counter at the bottom of each page that counts the number of requests served. It resets each time I deploy, since the counter is stored in memory, but I&#39;m not connecting this to a database, and it works.</p>
<p>With this running, I did the same for php files, creating a static server that would serve a different (real) <code>.php</code> file from memory on request. You can see this running here: <a href="https://herm.app/babbler.php">https://herm.app/babbler.php</a> (or any path with <code>.php</code> in it).</p>
<p>There&#39;s a counter at the bottom of each of these pages as well.</p>
<p>As Maury said: &#34;Garbage for the garbage king!&#34;</p>
<p>Now with the fun out of the way, a word of caution. I don&#39;t have this running on any project I actually care about; <a href="https://herm.app">https://herm.app</a> is just a playground of mine where I experiment with small ideas. I originally intended to run this on a bunch of my actual projects, but while building this, reading threads, and learning about how scraper bots operate, I came to the conclusion that running this can be risky for your website. The main risk is that despite correctly using <code>robots.txt</code>, <code>nofollow</code>, and <code>noindex</code> rules, there&#39;s still a chance that Googlebot or other search engines scrapers will scrape the wrong endpoint and determine you&#39;re spamming.</p>
<p>If you or your website depend on being indexed by Google, this may not be viable. It pains me to say it, but the gatekeepers of the internet are real, and you have to stay on their good side, <em>or else</em>. This doesn&#39;t just affect your search ratings, but could potentially add a warning to your site in Chrome, with the only recourse being a manual appeal.</p>
<p>However, this applies only to the post babbler. The php babbler is still fair game since Googlebot ignores non-HTML pages, and the only bots looking for php files are malicious.</p>
<p>So if you have a little web-project that is being needlessly abused by scrapers, these projects are fun! For the rest of you, probably stick with 403s.</p>
<p>What I&#39;ve done as a compromise is added the following hidden link on my blog, and another small project of mine, to tempt the bad scrapers:</p>
<div><pre><span></span>&lt;a href=&#34;https://herm.app/babbler/&#34; rel=&#34;nofollow&#34; style=&#34;display:none&#34;&gt;Don&#39;t follow this link&lt;/a&gt;
</pre></div>
<p>The only thing I&#39;m worried about now is running out of Outbound Transfer budget on my VPS. If I get close I&#39;ll cache it with Cloudflare, at the expense of the counter.</p>
<p>This was a fun little project, even if there were a few dead ends. I know more about Markov chains and scraper bots, and had a great time learning, despite it being fuelled by righteous anger.</p>
<p>Not all threads need to lead somewhere pertinent. Sometimes we can just do things for fun.</p>


    

    
        

        
            


        

        
            
        
    


  </div></div>
  </body>
</html>
