<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.artfintel.com/p/efficient-llm-inference">Original</a>
    <h1>Efficient LLM Inference (2023)</h1>
    
    <div id="readability-page-1" class="page"><div><div><article><div class=""><div><div dir="auto"><p><span>Lately, I’ve been thinking a lot about inference, and particularly, how to serve a given LLM more efficiently. The scenario is as follows: Your boss comes to you and says </span><em><span>Hey Finbarr, we’re about to go bankrupt because we’re spending all of our investor’s money on GPUs serving our 300B parameter model that raps in the style of </span><a href="https://en.wikipedia.org/wiki/John_Kenneth_Galbraith" rel="">John Kenneth Galbraith</a><span>. What can we do?</span></em></p><p>Broadly speaking, there are three main classes of things you can do:</p><ol><li><p><span>You can quantize the parameters of your model (</span><em>quantization</em><span>), where you keep your model exactly the same, but use less precision for each of the parameters.</span></p></li><li><p><span>You can distill a smaller version of your model (</span><em>distillation</em><span>), where you copy the architecture of your model to make it smaller and/or more efficient and then train this new, smaller model to mimic the outputs of the original, large model.</span></p></li><li><p><span>You can spend a bunch of time profiling your code and reduce the overhead without changing the architecture or parameters (</span><em>optimization</em><span>).</span></p></li></ol><p><span>The first place to start, somewhat obviously, is optimization. The amount of overhead that most programs have is ridiculous, and by simply profiling</span><span> your code, you can often find surprising amounts of overhead. For instance, I once had a colleague ask for help optimizing his code. He was training a neural network to perform a sophisticated calculation and had implemented a bunch of performance optimizations to make that faster, but he was </span><em>also</em><span> using a list to do lookups in a performance critical loop. I changed the list to a dict and made the code 200x faster.</span></p><p>This isn’t a rare occurrence. Every time I’ve profiled code, I’ve been surprised at the resulting profile. So if you’re having performance issues (don’t worry, it happens to all of us, it’s natural), the first thing you should do is profile your code.</p><p><span>For most people, this will be sufficient. Just removing the overhead from your code and batching requests in the naive way will get you to the point where you can serve requests in a cost-effective manner, </span><em>particularly</em><span> if you have traditional software margins. But let’s say that you’ve done a bunch of profiling and you’re now at the point where the only remaining optimizations are implementing arcane kernels in Triton which requires hiring grizzled old CUDA experts away from Nvidia. What’s the next step you can take to use your GPUs effectively?</span></p><p>Now, you’re left with quantization and distillation. Quantization, where you use less precise weights for your neural network without changing anything else about it, has been talked about a lot lately. Llama.cpp, for instance, used this to great effect to reduce the memory required to store the llama weights by 4x.</p><p>Distillation has received less attention but has historically been an important part of serving models at scale. This is because distillation generally works much, much better than quantization, and if you have the resources, should be the way you do things.</p><p>There’s a key caveat there: if you have the resources.</p><p data-attrs="{&#34;url&#34;:&#34;https://www.artfintel.com/subscribe?group=true&amp;coupon=9ee370da&#34;,&#34;text&#34;:&#34;Get 20% off a group subscription&#34;,&#34;action&#34;:null,&#34;class&#34;:null}" data-component-name="ButtonCreateButton"><a href="https://www.artfintel.com/subscribe?group=true&amp;coupon=9ee370da" rel=""><span>Get 20% off a group subscription</span></a></p><p>Let’s go back to our hypothetical scenario. You’re a hardworking ML engineer at CoherentOpenStability, where you’re trying to reduce the inference costs for your latest and greatest LLM, StableClaudius-4. You’ve already profiled your code and reduced all of the overhead that you can. You now have a few options:</p><ol><li><p>You come up with a research breakthrough which lets you accomplish the same thing, for cheaper. E.g. you design a new sparse attention mechanism which works well.</p></li><li><p>You make your model smaller.</p></li></ol><p>If I were to compare these, the obvious winner is #1. If you can come up with a novel research contribution that magically improves your model, you should obviously do that. If this is you, stop reading this article, go write a paper, apply to OpenAI/Anthropic/DeepMind, and collect a ridiculously high salary for being a large language model whisperer. Most of us cannot do this. So we’re stuck trying to come up with a smaller model that accomplishes the same things.</p><p>How should we come up with a smaller model? A few options:</p><ol><li><p>You train a smaller model in the exact same way as your original model.</p></li><li><p>You distill your big model into a smaller model.</p></li><li><p>You quantize your existing model.</p></li></ol><p><span>In my opinion, the literature indicates a clear &amp; obvious ranking: distillation is strictly better than training a smaller model, and quantizing is </span><em>probably</em><span> better than training a smaller model.</span></p><p><span>There aren’t as many distillation papers as I would like, but the two that come to mind are </span><a href="https://arxiv.org/abs/1910.01108" rel="">DistilBERT</a><span> and the </span><a href="https://arxiv.org/abs/1503.02531" rel="">original distillation paper</a><span> from Hinton et. al. In DistilBERT, the authors reduce the model size by 40% while only hurting performance by 3%.</span></p><p>In the Hinton et. al paper, they’re able to match the performance of an ensemble of 10 models with a single, distilled model, and performance only decreases from 61.1% accuracy to 60.8% accuracy (99.5% of the original performance, with 10% of the size). Now, the Hinton paper is comparing against an ensemble, which is a particularly wasteful way to increase model size, but that’s still impressive result, and much better than training a model from scratch to perform the same task (which had only 58.9% accuracy).</p><p><span>The problem with distillation, however, is that it requires training a smaller model from scratch </span><em><strong>and</strong></em><span> running inference over your entire dataset with your large model. If you have a dataset the size of GPT-3 (500B), this would cost $1M at public API prices (5e11 tokens * 2e-6 $/token = $1e6), or $400k if we assume OpenAI has a 60% margin. Given that it cost approximately $5M to train GPT-3 initially, this would add 10-20% to that already large cost. Not prohibitive, but expensive.</span></p><p><span>If you can afford this cost, great! Do it. It’s almost certainly going to give you the best performance. If you want something cheaper, you’re deciding between training a smaller model from scratch and quantizing an existing model. To help, we have a paper </span><a href="https://arxiv.org/abs/2212.09720" rel="">k-bit inference scaling laws</a><span>. The idea is that, from an inference perspective, we’re agnostic between serving a 30B model at one level of precision and serving a 60B model with twice the level of precision, as most GPUs are twice as fast at running models with half the precision (e.g. </span><a href="https://www.nvidia.com/content/dam/en-zz/Solutions/Data-Center/a100/pdf/nvidia-a100-datasheet-us-nvidia-1758950-r4-web.pdf" rel="">A100s</a><span>).</span></p><div data-attrs="{&#34;url&#34;:&#34;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/318ca76d-b54c-4d96-8b36-52a2099033c3/Screenshot_2023-05-05_at_08.00.53.png&#34;}" data-component-name="AssetErrorToDOM"><picture><img src="https://www.artfintel.com/img/missing-image.png" height="455" width="728"/></picture></div><p><span>This figure shows the tradeoff between using various model sizes with various levels of precision. Let’s compare two points for the </span><a href="https://arxiv.org/abs/2205.01068" rel="">OPT</a><span> line of work.</span></p><p>Model precision Bit precision Mean zeroshot accuracy $10^{11}$ 8 0.675 $10^{11}$ 16 0.65 $10^{12}$ 8 0.725 $10^{12}$ 16 0.7</p><p><span>What we see is that, given a total number of model bits, we prefer the model with </span><em>fewer</em><span> bits per parameter. Intuitively, this makes sense: we don’t see a benefit from training half as many parameters with fp64 vs fp32.</span></p><p><span>If we look at another figure, this time from the </span><a href="https://arxiv.org/abs/2205.01068" rel="">OPT paper</a><span>, we can analyze how performance scales with the number of parameters. As OPT uses FP16, which uses 2 bytes (or 16 bits) per parameter, 1e11 parameters is equal to 1.6e12 bits. By using 10x less parameters, and going from 1.6e12 to 1.6e11 bits, the average accuracy for OPT goes from 0.7 to 0.65: a 10x decrease in cost for a 8% decrease in accuracy. Not quite as good as the model size/accuracy tradeoffs we see with distillation, but I think that most businesses would have to strongly consider the tradeoff.</span></p><p><span>The other thing to keep in mind about quantization is that it’s remarkably cheap to do! The SOTA method for quantization is </span><a href="https://arxiv.org/abs/2210.17323" rel="">GPTQ</a><span>, which can quantize a 175B parameter model in 4 GPU-hours (roughly $4 of cost at public cloud prices). Training the model from scratch, on the other hand, costs a lot; a rough estimate of the cost to train a GPT-3 style model is $5M for the full model, with cost scaling linearly in the number of parameters, so a 20B model would cost ~$500k, and requires a lot of data (~100B tokens to be </span><a href="https://arxiv.org/abs/2203.15556" rel="">Chinchilla optimal</a><span>).</span></p><p><span>So quantizing is great. But what, exactly, </span><em>is</em><span> quantization, and how does it work?</span></p><p><span>The idea behind quantization is simple. Computers, due to their discrete nature, can’t natively store floating point numbers. digital numerical representations are based on </span><strong>bits</strong><span>, namely 1s or 0s. These bits are assembled into </span><strong>binary</strong><span>. In a binary integer representation, you can represent a range of </span></p><p>using a signed integer, where n is the number of bits. One bit is reserved to represent whether or not the number is positive or negative, and n - 1 bits are used to represent the magnitude.</p><p><span>This works well, and is reasonably efficient. However, the problem comes when you want to represent the </span><a href="https://en.wikipedia.org/wiki/Real_number" rel="">real numbers</a><span>, i.e. numbers that can take on values between integers. The most common approach is to reserve 1 bit to indicate the positivity/negativity of the number, m bits to represent the magnitude of the number (the </span><em><strong>exponent</strong></em><span>), and (n - m - 1) bits to represent the precision of the number (the significand)</span></p><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2c4ff675-3791-4b6b-951a-bb59111a2f91_1860x736.png" data-component-name="Image2ToDOM" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2c4ff675-3791-4b6b-951a-bb59111a2f91_1860x736.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2c4ff675-3791-4b6b-951a-bb59111a2f91_1860x736.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2c4ff675-3791-4b6b-951a-bb59111a2f91_1860x736.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2c4ff675-3791-4b6b-951a-bb59111a2f91_1860x736.png 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2c4ff675-3791-4b6b-951a-bb59111a2f91_1860x736.png" width="1456" height="576" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/2c4ff675-3791-4b6b-951a-bb59111a2f91_1860x736.png&#34;,&#34;srcNoWatermark&#34;:null,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:576,&#34;width&#34;:1456,&#34;resizeWidth&#34;:null,&#34;bytes&#34;:125004,&#34;alt&#34;:null,&#34;title&#34;:null,&#34;type&#34;:&#34;image/png&#34;,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;topImage&#34;:false,&#34;internalRedirect&#34;:null}" alt="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2c4ff675-3791-4b6b-951a-bb59111a2f91_1860x736.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2c4ff675-3791-4b6b-951a-bb59111a2f91_1860x736.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2c4ff675-3791-4b6b-951a-bb59111a2f91_1860x736.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2c4ff675-3791-4b6b-951a-bb59111a2f91_1860x736.png 1456w" sizes="100vw" loading="lazy"/></picture></div></a></figure></div><p>The significand is just a (n-m-1)-bit unsigned integer, and can thus represent values up to 2^{n - m - 1}. </p><p>In a 32-bit floating point number (single precision), 1 bit is used for the sign, 8 bits for the exponent, and 23 bits for the significand. </p><p>In a 16-bit floating point number (half precision), 1 bit is used for the sign, 5 bits for the exponent, and 10 bits for the significand. </p><p>In a 64-bit floating point number (double precision), 1 bit is used for the sign, 11 bits for the exponent, and 52 bits for the significand.</p><p><span>Note where the additional bits are going— they are mostly going to the significand, which adds </span><em>precision</em><span>, rather than </span><em>magnitude</em><span>. In other words, this lets us distinguish between </span><em>smaller</em><span> numbers, rather than allowing us to represent </span><em>bigger</em><span> ones.</span></p><p>By default, all major tensor programming frameworks use 32-bit precision to store trainable parameters. There’s a reason for this: 32-bit precision tends to be a good default. There are very few applications which benefit from the additional precision (mostly scientific computing applications). However, in practice, most of the bleeding edge work now uses 16-bits.</p><p><span>But ok. Now that you’ve read through my digression on how precision works in floating point numbers, let’s say we’ve chosen a level of precision. How do you </span><em>actually</em><span> lower the precision of your weights? The naive approach is to simply truncate your weights at a given level of precision. As a simple example, if your weight is 0.534345, naive truncating the weights will convert it to 0.534.</span></p><p><span>The </span><a href="https://twitter.com/Tim_Dettmers/status/1642885684057997313?s=20" rel="">SOTA model for quantizing to 4-bits or below</a><span> is GPTQ. Some other methods are LLM.int8() and ZeroQuant. I’ll discuss these in depth in a future article, but here, I’ll focus on GPTQ. The basic idea behind GPTQ is that, while there’s necessarily a drop in information contained within the network by reducing the number of bits, we can reduce the impact it has on inference accuracy by training weights to directly minimize the difference between the two:</span></p><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2685118e-9f15-4033-a75c-8899305bc637_1622x582.png" data-component-name="Image2ToDOM" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2685118e-9f15-4033-a75c-8899305bc637_1622x582.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2685118e-9f15-4033-a75c-8899305bc637_1622x582.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2685118e-9f15-4033-a75c-8899305bc637_1622x582.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2685118e-9f15-4033-a75c-8899305bc637_1622x582.png 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2685118e-9f15-4033-a75c-8899305bc637_1622x582.png" width="1456" height="522" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/2685118e-9f15-4033-a75c-8899305bc637_1622x582.png&#34;,&#34;srcNoWatermark&#34;:null,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:522,&#34;width&#34;:1456,&#34;resizeWidth&#34;:null,&#34;bytes&#34;:178894,&#34;alt&#34;:null,&#34;title&#34;:null,&#34;type&#34;:&#34;image/png&#34;,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;topImage&#34;:false,&#34;internalRedirect&#34;:null}" alt="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2685118e-9f15-4033-a75c-8899305bc637_1622x582.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2685118e-9f15-4033-a75c-8899305bc637_1622x582.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2685118e-9f15-4033-a75c-8899305bc637_1622x582.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2685118e-9f15-4033-a75c-8899305bc637_1622x582.png 1456w" sizes="100vw" loading="lazy"/></picture></div></a></figure></div><p>Let’s walk through an example. Let’s say that x = 0.323, and as above, w = 0.534345. Then, keeping everything as a float32, the activation output is:</p><div data-component-name="Latex"><p><span>\(x \cdot w = 0.323 \cdot 0.534345 = 0.172593435\)</span></p></div><p>which, rounded to 6 decimal points (the precision for float32s), gives us an output of 0.172593.</p><p>Rounding naively, our output is</p><div data-component-name="Latex"><p><span>\(x \cdot w_{\text{naive}} = 0.323 \cdot 0.534 = 0.172482\)</span></p></div><p>The difference here is 1.114e-4. If we use GPTQ, we solve</p><div data-component-name="Latex"><p><span>\(\text{argmin}_{\hat{w}} (0.172593435 - 0.323 \cdot \hat{w})^2\)</span></p></div><p> which gives us </p><div data-component-name="Latex"><p><span>\(\hat{w} = \frac{0.172593435}{0.323} = 0.534345\)</span></p></div><p> which, rounded to 3 decimal points (the precision for float16s)… gives us precisely the same answer as naively rounding, but with more effort.</p><p>Presumably this would matter more in other scenarios? I haven’t been able to come up with a simple example that makes GPTQ worth it. But in actual deployment scenarios, GPTQ claimed a significant difference (RTN meaning “round to nearest”):</p><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Febe32662-7241-4ba4-9ced-eea6c6a54787_1096x314.png" data-component-name="Image2ToDOM" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Febe32662-7241-4ba4-9ced-eea6c6a54787_1096x314.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Febe32662-7241-4ba4-9ced-eea6c6a54787_1096x314.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Febe32662-7241-4ba4-9ced-eea6c6a54787_1096x314.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Febe32662-7241-4ba4-9ced-eea6c6a54787_1096x314.png 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Febe32662-7241-4ba4-9ced-eea6c6a54787_1096x314.png" width="1096" height="314" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/ebe32662-7241-4ba4-9ced-eea6c6a54787_1096x314.png&#34;,&#34;srcNoWatermark&#34;:null,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:314,&#34;width&#34;:1096,&#34;resizeWidth&#34;:null,&#34;bytes&#34;:75937,&#34;alt&#34;:null,&#34;title&#34;:null,&#34;type&#34;:&#34;image/png&#34;,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;topImage&#34;:false,&#34;internalRedirect&#34;:null}" alt="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Febe32662-7241-4ba4-9ced-eea6c6a54787_1096x314.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Febe32662-7241-4ba4-9ced-eea6c6a54787_1096x314.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Febe32662-7241-4ba4-9ced-eea6c6a54787_1096x314.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Febe32662-7241-4ba4-9ced-eea6c6a54787_1096x314.png 1456w" sizes="100vw" loading="lazy"/></picture></div></a></figure></div><p>So this is a method that works much better than naively rounding, and is cheap.</p><p><span>Quantization isn’t magic. Ultimately, you’re always sacrificing accuracy for performance. Maybe you won’t lose a lot. But you’ll never </span><em>gain</em><span> accuracy, so at best you’re staying the same.</span></p><p><span>It’s also unclear how often the tradeoff is worth it. </span><a href="https://arxiv.org/abs/2212.09720" rel="">Tim Dettmers scaling law for quantization</a><span>. If you’re using half the precision, it might be worth using </span><em>the same precision</em><span> and half the weights and </span><a href="https://finbarr.ca/llms-not-trained-enough/" rel="">training for twice as long on more data</a><span>. This is what, for instance, </span><a href="https://blog.replit.com/replit-developer-day-recap#newmodel" rel="">replit did</a><span>. For many practitioners, the cost to </span><em>serve</em><span> a model heavily outweighs the cost to </span><em><strong>train</strong></em><span> the model. If this is you, you might not care about quantizing one.</span></p><p><span>Even if you do, distillation will typically outperform quantization. So if you </span><em>can</em><span> distill the model, you probably should. It’s only when you don’t have the resources to do this that quantization is clearly worth it.</span></p><p>Finally, with quantization, you only get a linear speedup as you decrease the number of bytes. That’s pretty good! But ideally we’d want to see much better scaling. Perhaps some sort of sparsity will do better.</p></div></div></div></article></div></div></div>
  </body>
</html>
