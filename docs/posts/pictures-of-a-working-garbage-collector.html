<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.oilshell.org/blog/2023/01/garbage-collector.html">Original</a>
    <h1>Pictures of a Working Garbage Collector</h1>
    
    <div id="readability-page-1" class="page">
  <!-- INSERT LATCH HTML -->

<p>
   |
<a href="https://www.oilshell.org/blog/">blog</a> | <a href="https://www.oilshell.org/">oilshell.org</a></p>

<p>
  2023-01-11
</p>
<p>The last post, <a href="https://www.oilshell.org/blog/2022/10/garbage-collector.html">Garbage Collector Problems</a>, was a status update on Oil&#39;s C++ runtime, about 4 months in.</p>
<p>Since then, we solved both the &#34;rooting&#34; and <code>fork()</code>-friendly problems.  So this post shows a <strong>demo</strong> of a fast shell in C++, with a working garbage collector!  Remember, the <a href="https://www.oilshell.org/cross-ref.html?tag=oil-native#oil-native">oil-native</a> tarball contains <strong>no Python</strong> code at all, and now it uses less memory.</p>
<p>More in this post:</p>
<ul>
<li>I describe how we arrived at a simpler design</li>
<li>I give a feeling for the bugs we had to fix, along with some engineering tips</li>
<li>Talk about performance</li>
</ul>
<p>This topic can be dense and wordy, so I break it up with <strong>screenshots</strong> of the many tools we used: <a href="https://www.oilshell.org/cross-ref.html?tag=asan#asan">ASAN</a>, GDB, <a href="https://www.oilshell.org/cross-ref.html?tag=perf#perf">perf</a> and <a href="https://www.oilshell.org/cross-ref.html?tag=flame-graph#flame-graph">flame graphs</a>, <a href="https://www.oilshell.org/cross-ref.html?tag=r-language#r-language">R</a> for benchmarking, and more.  I want to give contributors a sense of what working on Oil is like.</p>
<p>We can still use more help!  <strong>Good news</strong>: we now have a second grant with <a href="https://nlnet.nl">NLnet</a>.  Let me know if working on this sounds fun.  Follow our new account <a href="https://hachyderm.io/@oilsforunix"><code>@oilsforunix</code> on Mastodon</a>.</p>
<hr/>
<p>Big thanks to Jesse Hughes, Melvin Walls, and CoffeeTableEspresso for essential help on the C++ runtime.  Thanks to <a href="https://nlnet.nl">NLnet</a> for funding us.</p>

 
<a name="screencast"></a>
<h2>Screencast</h2>
<p><a href="https://asciinema.org/a/547312?t=30" target="_blank"><img src="https://asciinema.org/a/547312.svg" width="600"/></a></p>
<p>If you click on this screenshot, you&#39;ll see OSH running <code>./configure</code> from CPython&#39;s tarball, with GC debug output.</p>
<p>This is:</p>
<ul>
<li><strong>16K</strong> lines of gnarly shell generated by <a href="https://www.oilshell.org/cross-ref.html?tag=autotools#autotools">GNU autoconf</a></li>
<li>Running in our shell interpreter, written in ~40K lines of typed Python.
<ul>
<li><strong>But</strong>, it&#39;s translated to ~80K lines of <strong>pure C++</strong>!</li>
</ul>
</li>
<li>That generated C++ runs on top of a <strong>~4K line runtime</strong> of garbage collected data structures, and ~3K lines of OS bindings (<a href="https://www.oilshell.org/blog/2022/05/gc-heap.html">May 2022 blog post with background</a>).
<ul>
<li>The debug output is from our <code>OIL_GC_STATS=1</code> instrumentation.</li>
</ul>
</li>
</ul>
<p>It was a thrill to get this working!  Remember that the interpreter <a href="https://www.oilshell.org/blog/2019/02/05.html">took years to write</a>.</p>
<a name="process-metrics"></a>
<h3>Process Metrics</h3>
<p>Here&#39;s another way to look at it.  We now run benchmarks on every commit, including memory measurements with <code>getrusage()</code>.</p>
<p>In November, our &#34;leaky&#34; prototype used ~550 MB of memory running Python&#39;s <code>./configure</code>, which is 20x more than bash!</p>

<p><img src="https://app.oilshell.org/picdir/resize?name=1q8rfl1__leaky-transation.png&amp;max-width=700" alt="Leaky Translation (November)"/></p>
<p>When we turned on the garbage collector, the memory usage was reduced by 10x.</p>

<p><img src="https://app.oilshell.org/picdir/resize?name=1q5ms3k__gc-working.png&amp;max-width=700" alt="Garbage Collector Working (December)"/></p>
<p>Note that this is one of our hardest workloads.  On 3 other hand-written <code>./configure</code> scripts, OSH already matches the speed and memory usage of bash.  Most shell scripts are I/O bound.</p>
<p>We&#39;ve also made progress since then: as of the latest CI run, the autoconf-generated script uses <strong>1.6x</strong> more memory under OSH, not 2.0x.  It&#39;s now <strong>1.4x</strong> slower, not 1.9x slower.  After we fix a few &#34;dumb things&#34;, it should be just as fast.</p>


<a name="where-vs-when-rooting-policy-vs-safe-points"></a>
<h2>Where vs. When: Rooting Policy vs. &#34;Safe Points&#34;</h2>
<p>How did we get it working?  What were the <strong>wrong turns</strong>?  This section summarizes a part of this long journey.</p>
<hr/>
<p>In the <a href="https://www.oilshell.org/blog/2022/10/garbage-collector.html">last post</a>, I mentioned that we might change our <strong>rooting</strong> policy.  The rooting problem is: <em>Where does the collector start tracing</em>?</p>
<p>A major motivation was &#34;the <code>f(g(), h())</code> problem&#34;, which we found with <a href="https://www.oilshell.org/cross-ref.html?tag=asan#asan">ASAN</a>.  (I just noticed that LLVM&#39;s docs <a href="https://llvm.org/docs/GarbageCollection.html#quick-start">call out precisely this problem</a>, naming it <code>h(f(), g())</code>! )</p>
<p>I proposed a policy called &#34;Return Value Rooting&#34;, ran it by a few people, and mentioned it on the blog.</p>
<p>Some contributors were convinced by the logic, so I went ahead and implemented it, testing it on the same <a href="https://www.oilshell.org/release/0.13.1/benchmarks.wwz/mycpp-examples/">mycpp examples</a>.  It fixed 5 failures, but our recursive descent parsing test case <code>parse.py</code> <strong>failed</strong> in a new way.</p>
<pre><code>Parsing 1+2 =&gt;
=================================================================
==15704==ERROR: AddressSanitizer: heap-use-after-free on address 0x6020000023f0 at pc 0x55b1eeba4d01 bp 0x7ffde9fe6e90 sp 0x7ffde9fe6e80
READ of size 1 at 0x6020000023f0 thread T0
    #0 0x55b1eeba4d00 in ObjHeader(Obj*) /home/andy/git/oilshell/oil/mycpp/gc_obj.h:114
    #1 0x55b1eeba5f31 in MarkSweepHeap::MarkObjects(Obj*) mycpp/mark_sweep_heap.cc:125
    #2 0x55b1eeba6099 in MarkSweepHeap::MarkObjects(Obj*) mycpp/mark_sweep_heap.cc:136
    #3 0x55b1eeba54f3 in RootSet::MarkRoots(MarkSweepHeap*) mycpp/mark_sweep_heap.cc:11
    #4 0x55b1eeba687a in MarkSweepHeap::Collect() mycpp/mark_sweep_heap.cc:202
</code></pre>
<p>I realized that the problem is <strong>fundamental</strong>: it doesn&#39;t handle mutating member variables correctly!</p>
<p>I was discouraged.  This garbage collector seemed to have more failed attempts than any program I&#39;ve ever written!  I went back to the drawing board, reviewing my large collection of links, notes, and books.</p>
<p><img src="https://app.oilshell.org/picdir/resize?name=wgxpza__5B21F251-07BD-43AB-BCB6-95E19E6E0657.jpeg&amp;max-width=600&amp;rotation=1" alt="Books on Garbage Collection"/></p>
<p>My first thought was to pursue the simplest possible conservative/imprecise stack scanner, just to get something working (on one architecture).  It would temporarily &#34;unblock&#34; the project.</p>
<p>I had conjectured with contributors that Boehm GC was essentially a way of saying &#34;screw it&#34; to the rooting problem in C++, and thus to precise garbage collection.  That is, it&#39;s a hack that language implementers came up with ~30 years ago to work around exactly the problems we were having.</p>
<p>Here&#39;s one thread of notes: <a href="https://oilshell.zulipchat.com/#narrow/stream/121539-oil-dev/topic/Conservative.20GC.20Design.20Links">#oil-dev &gt; Conservative GC Design Links</a>.</p>
<p>It includes a <a href="https://github.com/JuliaLang/julia/issues/11714">long 2015 conversation on an option for conservative GC in Julia</a>, which basically <strong>scared me off</strong> again.  There is a fair amount of controversy about conservative collection.  (It now appears to be a workaround for integrating with unusual libraries, not Julia&#39;s main approach.)</p>
<hr/>
<p>To make a long story short, I went back to an even simpler solution, which I call:</p>
<ul>
<li><a href="https://oilshell.zulipchat.com/#narrow/stream/121539-oil-dev/topic/Manual.20Collection.20Points">#oil-dev &gt; Manual Collection Points</a></li>
</ul>
<p>We simply insert <code>mylib.MaybeCollect()</code> <strong>manually</strong> in the interpreter&#39;s Python source.  It gets preserved as <code>mylib::MaybeCollect()</code> in C++.</p>
<p>You could call these <em>ad hoc</em> GC <strong>safe points</strong>.  A safe point answers the question: <em>When does the GC have enough information to collect?</em></p>
<p>I noted that the term &#34;safe point&#34; doesn&#39;t appear in index of the Garbage Collection Handbook.  It&#39;s not an algorithm issue, but an implementation issue which is nonetheless difficult.</p>

<p>What&#39;s surprising is that we only need <strong>a handful</strong> of manual collection points in our 40K-line interpreter — primarily the Python loop that interprets shell <code>for</code> and <code>while</code> loops!  If you think about it, loops are the primary ways for programs to create unbounded garbage.</p>
<p>(It&#39;s possible for a single <code>MaybeCollect()</code> call to run after every shell statement, not just loops.  Max Bernstein pointed out that recursion in shell is possible, so we&#39;ll probably do this.)</p>
<a name="three-benefits-of-our-simple-solution"></a>
<h3>Three Benefits of Our Simple Solution</h3>
<p>Either way, this solution has a number of nice properties:</p>
<p>(1) It drastically reduces the <strong>state space explosion</strong> that collecting at every allocation creates.</p>
<p>The old policy turned every allocation into a <strong>branch</strong> — collect, or don&#39;t collect — which needs test coverage.</p>
<p>(2) It avoids the <code>f(g(), h())</code> problem, and more problems like <a href="https://oilshell.zulipchat.com/#narrow/stream/121539-oil-dev/topic/Allocating.20in.20constructor">#oil-dev&gt; Allocating in a constructor</a>, which CoffeeTableEspresso ran into.</p>
<pre><code>// Bug: if Foo::Foo() allocates a member variable, the instance 
// may be swept away before it&#39;s bound to myobj and thus rooted

myobj = Alloc&lt;Foo&gt;();
</code></pre>
<p>More problems: <a href="https://oilshell.zulipchat.com/#narrow/stream/121539-oil-dev/topic/Interactions.20Between.20C.2B.2B.20and.20GC">#oil-dev &gt; Interactions Between C++ and GC</a></p>
<p>(3) It let us <strong>delete all rooting annotations</strong> from hand-written code!</p>
<p>To tell the GC where to start tracing, <a href="https://www.oilshell.org/cross-ref.html?tag=mycpp#mycpp">mycpp</a> generates a line like this for every function:</p>
<pre><code> StackRoots _r({ &amp;local1, &amp;local2, ... });
</code></pre>
<p>But we also have ~7,000 lines of hand-written code, which means that hundreds of functions had such manual annotations.</p>
<p>With the new manual collection points, we can throw them all out!</p>
<p>This is because hand-written functions like <code>Str::strip()</code> and <code>posix::fork()</code> can never be <strong>lower on the stack</strong> than a manual collection point.  In the old scheme, <code>Str::strip()</code> could call a function that may collect.</p>
<p>So they&#39;re a now bit like &#34;leaf nodes&#34; of the call tree.</p>
<p>This slightly unexpected property makes it easier to work on Oil.  We try to write the simplest code possible.</p>
<a name="drawbacks"></a>
<h3>Drawbacks?</h3>
<p>Our runtime is instrumented  with <code>OIL_GC_STATS=1</code>, and we collect data on real shell programs in our CI.  If anything, we&#39;re still checking for collection <strong>too often</strong>, not too rarely.</p>
<p>So I don&#39;t see any real downsides!</p>
<p>While in theory the shell may use more memory than necessary in some cases, typical workloads consist of many tiny objects.  And there are many other ways we should optimize memory usage, mentioned below.</p>
<hr/>
<p>So I think I misconceptualized our bugs as a rooting issue — being fastidious about <strong>where</strong> to start tracing — but it&#39;s more useful to think about <strong>when</strong> to collect.</p>
<ul>
<li><a href="https://oilshell.zulipchat.com/#narrow/stream/121539-oil-dev/topic/Thought.3A.20Rooting.20Policy.20vs.20Safe.20Points">#oil-dev &gt; Rooting Policy vs. Safe Points</a></li>
</ul>
<a name="related-papers"></a>
<h3>Related Papers</h3>
<p>In <a href="https://old.reddit.com/r/ProgrammingLanguages/comments/y93yvv/oil_0127_garbage_collector_problems/">the Reddit comments to my last post</a>, two readers pointed out very relevant research.  (Thank you!  This is why I write these posts.)</p>
<p><img src="https://app.oilshell.org/picdir/resize?name=1g7zz0q__accurate-gc-paper.png&amp;max-width=600" alt="Accurate Garbage Collection in Uncooperative Environments"/></p>
<ul>
<li><a href="https://scholar.google.com/scholar?cluster=5268992856670164296&amp;hl=en&amp;as_sdt=0,39">Accurate Garbage Collection in an Uncooperative Environment</a> (Henderson, 2002)</li>
<li><a href="https://scholar.google.com/scholar?cluster=8090579484944932243&amp;hl=en&amp;as_sdt=0,39">Accurate Garbage Collection in Uncooperative Environments Revisited</a> (Vitek et al., 2009)</li>
</ul>
<p>I wrote <a href="https://www.oilshell.org/cross-ref.html?tag=zulip#zulip">Zulip</a> notes on these papers, as well as on Boehm GC, but here I&#39;ll just say that reading them made me feel better.</p>
<ul>
<li>They&#39;re from the early 2000&#39;s, not the 1970&#39;s!  Now I don&#39;t feel as bad about stumbling around this problem for several months.
<ul>
<li>When chatting with contributors, I said that GC rooting for C++ was a &#34;I didn&#39;t know what I didn&#39;t know&#34; problem. (Skimming this <a href="http://blog.pnkfx.org/blog/2016/01/01/gc-and-rust-part-2-roots-of-the-problem/">2016 blog post</a>, the analogous issues in Rust seem even harder!)</li>
</ul>
</li>
<li>One paper is by my former teammate at Google, Fergus Henderson!  I later noticed that it&#39;s cited in <a href="https://llvm.org/docs/GarbageCollection.html">LLVM&#39;s documentation on its GC support</a>.</li>
<li>We don&#39;t use these techniques literally, since one relates to generating C from a Prolog-like language, and the other isn&#39;t quite portable.  But they were useful reference points.</li>
</ul>
<a name="debugging-the-collector"></a>
<h2>Debugging the Collector</h2>
<p>So after switching to manual GC points, all of our tests passed under <a href="https://www.oilshell.org/cross-ref.html?tag=asan#asan">ASAN</a> and <code>#ifdef GC_ALWAYS</code>.  This feels good after months of latent segfaults, but it isn&#39;t too surprising, since there are many fewer code paths.</p>
<p>Does the shell run?  No, there were still quite a few crashes.</p>
<ul>
<li><a href="https://oilshell.zulipchat.com/#narrow/stream/121539-oil-dev/topic/Summary.20of.20GC.20Bugs">#oil-dev &gt; Summary of GC Bugs</a></li>
</ul>
<p>I&#39;ll recap that thread after giving some color on GC bugs in general, and our problem specifically.</p>
<a name="gc-bugs-are-hard-to-diagnose-and-they-lurk"></a>
<h3>GC Bugs Are Hard to Diagnose, and They Lurk</h3>
<p>From a former v8 lead, and WebAssembly co-author:</p>
<blockquote><p lang="en" dir="ltr">I utterly hate debugging garbage collection bugs. Besides stress mode, fuzzing, and tracing output, there isn&#39;t really much to help you. A good debugger is a must. But even then, I feel like it is a special kind of hell.</p>— Ben L. Titzer (@TitzerBL) <a href="https://twitter.com/TitzerBL/status/1564747763727962114?ref_src=twsrc%5Etfw">August 30, 2022</a></blockquote> 
<p>I definitely had this experience with the moving Cheney collector.  It had the additional complication of being at the <a href="https://www.oilshell.org/cross-ref.html?tag=metalanguage#metalanguage">metalanguage</a> level — i.e. where the stack is literally the C stack, laid out by a compiler we don&#39;t control.</p>
<p>The C++ translation essentially stalled because it was too difficult to debug!</p>
<hr/>
<p>Hans Boehm motivates conservative garbage collection:</p>
<blockquote>
<p>It is difficult to design a compiler such that the generated code is guaranteed to preserve garbage collection invariants.  [Errors] in the object code can potentially go unnoticed for long periods of time. Even when they do appear, the problem is difficult to isolate, since symptoms usually appear a
long time after the erroneous code was executed.</p>
</blockquote>
<blockquote>
<p>Garbage collection bugs tend to be among the last to be removed from a new programming language implementation.</p>
</blockquote>
<p>— <em>Garbage Collection in an Uncooperative Environment</em> (Boehm, 1988)</p>
<p>So how did we find and fix our GC bugs?  Are there more lurking?</p>
<a name="leaning-hard-on-asan"></a>
<h3>Leaning Hard on ASAN</h3>
<p>Again, the most useful technique is to use <a href="https://www.oilshell.org/cross-ref.html?tag=asan#asan">ASAN</a> as much as possible.  It&#39;s built into both Clang and GCC, and trivial to use (pass <code>-fsanitize=address</code>).  It compiles your program with runtime instrumentation of allocations.</p>
<p>It&#39;s mainly used to find classic C and C++ errors with manual memory management, but it works just as well for a garbage collector that uses <code>malloc()</code> and <code>free()</code>.  (We&#39;ll have a custom allocator for performance, but will always retain this option!)</p>
<p><img src="https://app.oilshell.org/picdir/resize?name=1ibpbp6__asan-cropped.png&amp;max-width=600" alt="ASAN Terminal"/></p>
<p>There were two common failure modes:</p>
<p>(A) <strong>Heap Use After Free</strong>.  A common sequence of events:</p>
<ol>
<li>You forget a GC root in hand-written code.  There might be an object referenced only by a C++ global.</li>
<li>The mark phase can&#39;t find this object.</li>
<li>So the sweep phase calls <code>free()</code> on it.</li>
<li>It&#39;s later used by the program, and <a href="https://www.oilshell.org/cross-ref.html?tag=asan#asan">ASAN</a> flags the use-after-free.</li>
</ol>
<p>(B) <strong>Seg Faults</strong>, e.g. due to missing object headers.  <a href="https://www.oilshell.org/cross-ref.html?tag=asan#asan">ASAN</a> basically gives you a stack trace, so in many cases you don&#39;t have to bother starting the debugger.</p>
<a name="a-reality-sandwich-of-statically-typed-bread"></a>
<h3>A &#34;Reality Sandwich&#34; of Statically Typed Bread</h3>
<p>Even though ASAN reliably turns use-after-free into crashes, and these bugs ultimately had simple causes, they were <strong>not</strong> trivial to diagnose.  The core problem is that by the time the crash happens, the debugger lacks <strong>type information</strong>.</p>
<p><img src="https://app.oilshell.org/picdir/resize?name=15sxo8h__Sandwich_Cross-section__49695872726_.jpg&amp;max-width=600" alt="Sandwich"/></p>

<p>I want to re-emphasize this <strong>&#34;reality sandwich&#34;</strong> view of garbage collection, <a href="https://www.oilshell.org/blog/2022/05/gc-heap.html">described in May</a>:</p>
<ul>
<li>The top layer is your application types: user-defined classes, <code>Dict</code>, <code>List</code>, <code>Str</code>, etc.</li>
<li>The middle layer is <strong>reality</strong>: the bits in memory.</li>
<li>The bottom layer is the garbage collector&#39;s <strong>homogeneous view</strong> of memory.  For us, it&#39;s a graph of <code>ObjHeader*</code>, with children traced by <code>HeapTag::FixedSize</code> and <code>HeapTag::Scanned</code>.</li>
</ul>
<p>The middle layer is carefully designed to be compatible with the top and bottom views.  <strong>Precise</strong> garbage collection requires this.</p>
<p>While you usually debug your program thinking about the <strong>top</strong> layer, the crashes happen in the <strong>bottom</strong> layer.</p>
<a name="techniques-gdb-watch-points"></a>
<h3>Techniques (GDB Watch Points)</h3>
<p>Here are more debugging techniques I used:</p>
<ol>
<li>
<p><strong>Validate the roots</strong> as soon they&#39;re registered, not just on collection.  Assert everything you can about the object headers, e.g. that they have valid tags like <code>HeapTag::FixedSize</code>.</p>
</li>
<li>
<p><a href="https://sourceware.org/gdb/download/onlinedocs/gdb/Set-Watchpoints.html">GDB watch points</a> using the command <code>awatch -l myvar</code>.</p>
</li>
</ol>
<p>This is useful because ASAN gives you 3 stack traces:</p>
<ol>
<li>Where the use-after-free occurred.
<ul>
<li>This is in the app code: the <strong>top</strong> layer.</li>
</ul>
</li>
<li>Where it was freed.
<ul>
<li>This may be in the <code>Sweep()</code> phase of collector: the <strong>bottom</strong> layer.</li>
</ul>
</li>
<li>Where it was originally allocated.
<ul>
<li>In the <strong>top</strong> layer again.</li>
</ul>
</li>
</ol>
<p>So by putting a watchpoint on a <strong>memory location</strong>, you can see where an object is touched by both &#34;bread&#34; layers.</p>
<a href="https://app.oilshell.org/picdir/resize?name=1qiauii__gdb-watchpoint.png&amp;max-width=1000">
<p><img src="https://app.oilshell.org/picdir/resize?name=1qiauii__gdb-watchpoint.png&amp;max-width=600" alt="GDB watchpoint thread"/></p>
</a>

<a name="gap-between-testing-and-production-9-bugs"></a>
<h2>Gap Between Testing and Production: 9 Bugs</h2>
<p>Now that we understand the debugging task, here&#39;s a summary of that Zulip thread: <a href="https://oilshell.zulipchat.com/#narrow/stream/121539-oil-dev/topic/Summary.20of.20GC.20Bugs">#oil-dev &gt; Summary of GC Bugs</a></p>
<p><strong>Logic errors</strong> generating GC metadata:</p>
<ol>
<li>The C++ compiler warned us that some of our <code>constexpr</code> <strong>field masks</strong>  overflowed 16 bits!  In other words, a few classes had more than 16 members.
<ul>
<li>I fixed this by putting all pointer fields first in classes without inheritance, which means they can use <code>Tag::Scanned</code> instead of <code>Tag::FixedSize</code>.</li>
</ul>
</li>
<li>Off-by-one error for <code>Tag::Scanned</code> objects in <a href="https://www.oilshell.org/cross-ref.html?tag=mycpp#mycpp">mycpp</a>.  This was due to a legacy of the Cheney collector, which has now been cleaned up.</li>
<li>Bad <code>Tag::Opaque</code> optimization.</li>
</ol>
<p><strong>Missing</strong> GC metadata:</p>
<ol start="4">
<li>Field masks in the <code>frontend/flag_gen.py</code> code generator.</li>
<li>Object headers in the <code>core/optview_gen.py</code> code generator.
<ul>
<li>Remember, we expanded Python reflection to textual code generation in C++!</li>
</ul>
</li>
<li>Object header in hand-written <code>ParserSpec</code> class.</li>
</ol>
<p>Missing <strong>global roots</strong>:</p>
<ol start="7">
<li>Shared signal handler state.  (We had it under the abandoned &#34;return value rooting&#34; scheme, but not the new, simpler design.)</li>
<li>Global <code>stdout</code> and <code>stderr</code>.</li>
</ol>
<p>(These are the only 3 globals in Oil!)</p>
<ol start="9">
<li>A trivial <strong>memory leak</strong> in the <code>getline()</code> binding, which <a href="https://www.oilshell.org/cross-ref.html?tag=asan#asan">ASAN</a> flagged.
<ul>
<li>The only issue here was that my machine didn&#39;t have symbols for <code>libc</code>, which means ASAN&#39;s stack trace was confusing.</li>
</ul>
</li>
</ol>
<a name="a-delicate-octopus-with-thousands-of-arms"></a>
<h3>A Delicate Octopus With Thousands of Arms</h3>
<p>So none of the bugs were in the collector itself; <strong>they were issues with the metadata</strong> used for rooting and tracing.</p>
<p>So I now envision a garbage collector as an <strong>octopus</strong>!</p>
<p><img src="https://app.oilshell.org/picdir/resize?name=1a1db51__1024px-Octopus_at_Kelly_Tarlton_s.jpg&amp;max-width=800" alt="Octopus"/></p>

<ol>
<li>It has a <strong>small head</strong>, which is say 500 or 2000 lines of elegant marking and sweeping logic.</li>
<li>It has <strong>tentacles</strong> that touch all of your program!  This is 50,000 or 500,000 lines of code that interact with garbage-collected objects.
<ul>
<li>Stack frames are being pushed and popped.</li>
<li>Variables are being mutated.</li>
<li>Meanwhile, the octopus is tracing all objects with its arms, and throwing out what it can&#39;t reach.</li>
</ul>
</li>
</ol>
<p>If there&#39;s a single mistake in the logic of the second part, the octopus&#39;s
<strong>brain explodes</strong>.</p>
<p>So this was the cause of essentially all 9 bugs.  Precise garbage collection
requires precise metadata, all over the program.</p>
<hr/>
<p>After this experience, I&#39;m now confident our collector will be reliable.  Why?</p>
<p>An unexpected benefit of writing the shell in Python is that the vast majority of GC metadata is in <strong>generated</strong> source code.  We don&#39;t have dozens or hundreds of bugs like Mozilla explained in <a href="https://blog.mozilla.org/javascript/2013/07/18/clawing-our-way-back-to-precision/">Clawing Our Way Back to Precision</a> (2013).</p>
<p>So our source code isn&#39;t littered with any of:</p>
<ol>
<li>Rooting annotations (remember that we deleted all of them in hand-written code)</li>
<li>Manually created object headers (with field masks)</li>
<li>Manual memory management</li>
<li>Reference counting annotations like <code>Py_INCREF</code> and <code>Py_DECREF</code></li>
</ol>
<p>So I expect that the C++ runtime will change slowly, and new features to the shell will be added in <strong>Python</strong>, where it&#39;s <strong>impossible</strong> to make mistakes with memory.</p>
<p>This <a href="https://www.pypy.org/posts/2018/09/the-first-15-years-of-pypy-3412615975376972020.html">great PyPy retrospective</a> makes a similar point:</p>
<blockquote>
<p>RPython is a garbage collected language, and the interpreter does not have to care much about GC in most cases. When the C source code is generated, a GC is automatically inserted. This is a source of great flexibility. Over time we experimented with a number of different GC approaches, from reference counting to Boehm to our current incremental generational collector</p>
</blockquote>
<p>In fact, I revived the Cheney collector, as an experiment in performance.  It may work well with our new manual GC points.</p>
<ul>
<li><a href="https://oilshell.zulipchat.com/#narrow/stream/121539-oil-dev/topic/Option.20to.20use.20Cheney.20collector.3F">#oil-dev &gt; Option to use Cheney collector?</a></li>
</ul>


<a name="performance"></a>
<h2>Performance</h2>
<p>I have a lot to say about performance, including describing 3 immediate fixes:</p>
<ol>
<li>Fixed thrashing in the collection policy</li>
<li>Removed hash table in favor of a mark bitmap
<ul>
<li>A &#34;lazy <code>free()</code>&#34; algorithm tweak fell out of recycling object IDs, and improved performance.</li>
</ul>
</li>
<li>Non-recursive marking (surprisingly didn&#39;t improve performance, but makes the collector more robust)</li>
</ol>
<p>And future plans:</p>
<ol start="4">
<li>True lazy sweeping, for O(num live objects) rather than O(num allocated), like Cheney</li>
<li>A custom allocator to take over small allocations</li>
<li>Consistently put the <code>ObjHeader</code> before any vtable pointer</li>
<li>Optimizations from the app side (big parser refactoring)</li>
<li>Small string optimization (hat tip to Max Bernstein), which interacts with GC</li>
<li>&#34;Boxless&#34; optimization for the interpreter</li>
</ol>
<p>This work is guided by many benchmarks:</p>
<ul>
<li><a href="https://github.com/oilshell/oil/blob/master/benchmarks/gc.sh">benchmarks/gc.sh</a></li>
<li><a href="https://github.com/oilshell/oil/blob/master/benchmarks/osh-runtime.sh">benchmarks/osh-runtime.sh</a></li>
<li><a href="https://github.com/oilshell/oil/blob/master/benchmarks/osh-parser.sh">benchmarks/osh-parser.sh</a></li>
</ul>

<hr/>
<p>This post is already long, so I won&#39;t go into detail.  Each piece of work above has a thread on <a href="https://www.oilshell.org/cross-ref.html?tag=zulip#zulip">Zulip</a>.</p>
<p>Follow <a href="https://www.oilshell.org/blog/2023/01/mastodon">our new Mastodon account</a> or <a href="https://www.oilshell.org/blog/2023/01/twitter">Twitter</a> account if you want to learn more.</p>
<a href="https://app.oilshell.org/picdir/resize?name=s4wony__osh-parse-flame.png&amp;max-width=2000">
<p><img src="https://app.oilshell.org/picdir/resize?name=s4wony__osh-parse-flame.png&amp;max-width=600" alt="Recursive Marking Flame Graph"/></p>
</a>
<a href="https://app.oilshell.org/picdir/resize?name=s9dm7d__osh-parse-flame-non-recursive.png&amp;max-width=2000)">
<p><img src="https://app.oilshell.org/picdir/resize?name=s9dm7d__osh-parse-flame-non-recursive.png&amp;max-width=600" alt="Non-recursive Marking Flame Graph"/></p>
</a>
<a name="summary"></a>
<h2>Summary</h2>
<p>Writing this collector was a lot of work, but we ended up with something that&#39;s simple and reliable.</p>
<ul>
<li>Concepts
<ul>
<li>Where vs. when: rooting vs. safe points.</li>
<li>Precise GC metadata for precise collection (vs. &#34;conservative&#34; collection)</li>
</ul>
</li>
<li>Analogies
<ul>
<li>The &#34;reality sandwich&#34; for modeling memory.</li>
<li>The delicate octopus.  The octopus is also the bottom layer of bread!</li>
</ul>
</li>
<li>Tools
<ul>
<li><a href="https://www.oilshell.org/cross-ref.html?tag=asan#asan">ASAN</a> is essential for flagging bugs during testing.</li>
<li>GDB watch points.</li>
<li>I hope to describe performance tools in a future post.  I converged on a good idiom for <strong>tables</strong> in shell, similar to what <a href="https://www.oilshell.org/blog/2021/07/blog-backlog-1.html#wiki-how-to-use-shell">I called the &#34;PPPT&#34; pattern</a>.</li>
</ul>
</li>
</ul>
<a name="whats-next"></a>
<h3>What&#39;s Next?</h3>
<p>It&#39;s now clear that the <a href="https://www.oilshell.org/cross-ref.html?tag=osh-language#osh-language">OSH</a> part of the project will &#34;exist&#34;.  We still have some work to do to replace the Python tarball with the <a href="https://www.oilshell.org/cross-ref.html?tag=oil-native#oil-native">oil-native</a> tarball, but it will happen.</p>
<p>But the <a href="https://www.oilshell.org/cross-ref.html?tag=oil-language#oil-language">Oil language</a> has stalled for nearly 6 months.  I&#39;ve gotten great feedback from people like Samuel Hierholzer and James Sully, which I hope to address soon.</p>
<p>I&#39;ve also been falling behind on <strong>shell advocacy</strong> (#<a href="https://www.oilshell.org/blog/tags.html?tag=shell-the-good-parts#shell-the-good-parts">shell-the-good-parts</a>).  For now, I&#39;ll point out that shell was the <a href="https://octoverse.github.com/2022/top-programming-languages">sixth fastest growing language on Github in 2022</a>.  We still need a new shell.</p>
<p>And the #1 fastest growing language is the <a href="https://github.com/hashicorp/hcl">Hashicorp Config Language</a>.  A new component of Oil is very similar to it — interleaved with a principled shell, and decoupled from any application:</p>
<ul>
<li><a href="https://www.oilshell.org/release/0.13.1/doc/hay.html">Hay - Custom Languages for Unix Systems</a>.</li>
</ul>
<p>To get these efforts going again, I&#39;ll try to <a href="https://hachyderm.io/@oilsforunix">get more people involved</a> with the project.  Let me know if you want to be paid to work on open source code!</p>
<a href="https://github.com/oilshell/oil/issues/1330">
<p><img src="https://app.oilshell.org/picdir/resize?name=1dzmj4x__todo-on-core-gc.png&amp;max-width=600" alt="Github bug: TODO on core GC"/></p>
</a>
<a name="appendix"></a>
<h2>Appendix</h2>
<a name="faq-why-should-a-shell-have-a-garbage-collector"></a>
<h3>FAQ: Why Should a Shell Have a Garbage Collector?</h3>
<ol>
<li>It will allow recursive JSON-like data structures in Oil.
<ul>
<li><a href="https://oilshell.zulipchat.com/#narrow/stream/266575-blog-ideas/topic/Shell.20and.20Awk.20Lack.20Garbage.20Collection.20and.20Are.20Limited">Awk shares this lack of data structures with Bourne shell</a>.</li>
</ul>
</li>
<li>It means that the Oil interpreter itself <strong>memory safe</strong>, not just Oil programs.
<ul>
<li>This is in contrast to every POSIX shell (bash, dash) and most language implementations (CPython, Ruby, v8, Lua).  They all have memory management logic littered throughout.</li>
</ul>
</li>
</ol>
<p>More answers for the curious:</p>
<ul>
<li><a href="https://github.com/oilshell/oil/wiki/FAQ%3A-Why-Not-Write-Oil-in-X%3F">FAQ: Why Not Write Oil in X?</a> (wiki)</li>
</ul>
<p>For example, why not write it in Go?  Go&#39;s runtime implements goroutines with OS threads, while shells use <code>fork()</code>-based concurrency.  Go also doesn&#39;t use <a href="https://www.oilshell.org/cross-ref.html?tag=libc#libc">libc</a>, which shells rely on extensively.</p>
<a name="we-must-relax-a-constraint"></a>
<h3>We Must Relax A Constraint</h3>
<p>Here&#39;s another way of looking at our &#34;manual collection point&#34; design choice.</p>
<ul>
<li><a href="https://oilshell.zulipchat.com/#narrow/stream/121539-oil-dev/topic/Relaxing.20GC.20Design.20Constraints">#oil-dev &gt; Relaxing GC Design Constraints</a></li>
</ul>
<p>I believe the original problem was <strong>over-constrained</strong>, to the point that was impossible to solve:</p>
<ol>
<li>We will generate <strong>C++ source code</strong> to make Oil fast.
<ul>
<li>For example, we don&#39;t use LLVM IR, because Oil should compile with a plain C++ compiler.  Shells run on every conceivable architecture.</li>
</ul>
</li>
<li>We should use and generate standard, <strong>portable</strong> C++ (to the degree possible).
<ul>
<li>Conservative stack scanning is inherently unportable.  It depends on how the compiler generates code for a particular CPU architecture, and on what optimizations it does.</li>
</ul>
</li>
<li>We should collect accurately / precisely.
<ul>
<li>Conservative collection should really be called <strong>imprecise</strong> collection — there&#39;s a low probability of missing garbage.</li>
</ul>
</li>
<li>The generated code should be <strong>readable</strong>.
<ul>
<li>In the <a href="https://www.oilshell.org/blog/2022/10/garbage-collector.html">last post</a>, I mentioned this as a reason for not doing bytecode or SSA-like transformations.  This seems like a trivial issue, until you&#39;re handed a blob of 90K lines of <code>var345</code> and <code>var346</code> to debug!  In contrast, our generated code is readable, and multiple contributors have debugged it with normal tools.</li>
</ul>
</li>
<li><a href="https://www.oilshell.org/cross-ref.html?tag=mycpp#mycpp">mycpp</a> mostly <strong>prints</strong> MyPy&#39;s typed AST.
<ul>
<li>Again, we&#39;re not doing compiler-like transformations on the code.</li>
</ul>
</li>
<li>We can collect at <strong>any allocation</strong>.</li>
</ol>
<p>When viewed this way, it&#39;s pretty clear to me that the sixth constraint is the one to relax.</p>
<p>Are there any other options?  I don&#39;t think so, other than changing the C++ language itself, which seems to have stalled:</p>
<ul>
<li><a href="https://dl.acm.org/doi/abs/10.1145/1542431.1542437">Garbage collection in the next C++ standard</a> (Boehm and Spertus, 2009)</li>
</ul>
<p>Manual collection points aren&#39;t fully general, but they solves exactly the problem <strong>we</strong> have.  That is, we&#39;re able to <strong>precisely</strong> collect garbage in a subset of portable C++ code.  It&#39;s easy to read, write, and generate code in this style.</p>
<a name="algorithm-animations"></a>
<h3>Algorithm Animations</h3>
<p>If you got this far and were disappointed by the pictures, I like these animations:</p>
<ul>
<li><a href="https://spin.atomicobject.com/2014/09/03/visualizing-garbage-collection-algorithms/">Visualizing Garbage Collection Algorithms</a> (2014) - <a href="https://github.com/kenfox/gc-viz">https://github.com/kenfox/gc-viz</a></li>
</ul>




</div>
  </body>
</html>
