<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://erikarow.land/notes/just-add-water">Original</a>
    <h1>Just Add Water</h1>
    
    <div id="readability-page-1" class="page"><section id="Just-Add-Water">

<p>Or, Using Partial Application In Elixir for Better Errors.</p>
<p>Today, I was adapting the generator for a <a href="https://grimgrains.com/site/about.html">recipe website</a> written by Hundred Rabbits into Elixir. While adapting their idiomatic C code into Elixir, I needed a way to pass a predefined list of ingredients to the builder API for Recipes.</p>
<p>To do this, I defined a function that returned a keyword list<label for="fn1"></label><span><span>The <code>cheese: cheese</code> syntax looks a bit funny, but it’s Elixir syntax sugar for <code>{:cheese, cheese}</code> where the second <code>cheese</code> is the bound variable.</span></span>:</p>
<pre><code>def ingredients do
  cheese = create_ingredient(...)

  salt = create_ingredient(...)

  [cheese: cheese, salt: salt]
end
</code></pre>
<p>And then in my builder API, I called that function inside the builder scope:</p>
<pre><code>def recipes do
  ingredients = Ingredients.ingredients()

  ...
end
</code></pre>
<p>In order to add an ingredient to a recipe, I used a function <code>add_ingredient_quantity/3</code>, used something like this:</p>
<pre><code>def recipes do 
  ingredients = Ingredients.ingredients()

  create_recipe(&#34;salted cheese&#34;)
  |&gt; add_ingredient_quantity(ingredient[:cheese], &#34;2 oz&#34;)
  |&gt; add_ingredient_quantity(ingredient[:salt], &#34;1 teaspoon&#34;)
end
</code></pre>
<p>This worked great for ingredients that I had already defined in my keyword list, but the <code>Access</code><label for="fn2"></label><span><span>Read more about <code>Access</code> <a href="https://hexdocs.pm/elixir/1.15.0/Access.html">here</a>.</span></span> behaviour that powers Elixir’s <code>[]</code> syntax returns <code>nil</code> if a key isn’t found in the accessed object.</p>
<p>I wanted a way to detect that I needed to define a new ingredient in a recipe, so that every ingredient gets its own page, like Grim Grains. My naive solution was to put a guard clause on <code>add_ingredient_quantity</code> that checked if the ingredient was nil:</p>
<pre><code>def add_ingredient_quantity(recipe, ingredient, quantity) when not is_nil(ingredient) do
  ...
end
</code></pre>
<p>This would certainly complain, because of a pattern match error. However, the <code>Access</code> had already returned a <code>nil</code>, so the missing ingredient’s atom wasn’t available for an error message.</p>
<p>This became evident when I tried to add water<label for="fn3"></label><span><span>You would want to drink some water if you were eating that much salted cheese, after all.</span></span> to my recipe:</p>
<pre><code>def recipes do 
  ingredients = Ingredients.ingredients()

  create_recipe(&#34;salted cheese&#34;)
  |&gt; add_ingredient_quantity(ingredient[:cheese], &#34;2 oz&#34;)
  |&gt; add_ingredient_quantity(ingredient[:salt], &#34;1 teaspoon&#34;)
  |&gt; add_ingredient_quantity(ingredient[:water], &#34;1 quart&#34;) 
end
</code></pre>
<p>This resulted in a pattern match error, but the error only knew that it was passed a <code>nil</code> with no context about where that <code>nil</code> came from.</p>
<section id="Partial-Application-in-Elixir">
<h2>Partial Application in Elixir</h2>
<p>To solve this, I replaced the <code>ingredient[:water]</code> call<label for="fn4"></label><span><span>I first thought about overriding the <code>Access</code> behaviour to return something other than <code>nil</code>, but I decided against it.</span></span> with a partial application.</p>
<p>In Elixir I can use an anonymous function to partially apply a named Elixir function. Here, I wanted to get a value out of a specific Keyword List, so I chose <code>Keyword.fetch</code>. <code>Keyword.fetch</code> takes two arguments: a keyword list and a key to get<label for="fn5"></label><span><span>Read more about <code>Keyword.fetch/2</code> <a href="https://hexdocs.pm/elixir/1.15.0/Keyword.html#fetch/2">here</a>.</span></span>. By partially applying <code>Keyword.fetch</code> with <code>ingredients</code> and wrapping it in a <code>with</code> statement I can raise a helpful error:</p>
<pre><code>def recipes do
  ingredients = Ingredients.ingredients()
  get_ingredient = fn key -&gt; 
    with {:ok, value} &lt;- Keyword.fetch(ingredients, key) do
      value
    else
      :error -&gt; raise &#34;#{key} not found in ingredients&#34;
    end
  end

  create_recipe(&#34;salted cheese&#34;)
  |&gt; add_ingredient_quantity(get_ingredient.(:cheese), &#34;2 oz&#34;)
  |&gt; add_ingredient_quantity(get_ingredient.(:salt), &#34;1 teaspoon&#34;)
  |&gt; add_ingredient_quantity(get_ingredient.(:water), &#34;1 quart&#34;) 
end
</code></pre>
<p>Note that we’re using an anonymous function, so <code>get_ingredient</code> needs to be applied with the <code>.</code> operator<label for="fn6"></label><span><span>I initially tried to ues the capture operator on <code>Keyword.get/3</code>, passing <code>raise</code> as the default as shown <a href="https://paste.sr.ht/~erikareads/ba76dc7b0e0d5b9e66363f6d999c215fadcd80b5">here</a>. This successfully raised a helpful error on a missing key, but it eagerly raised on every key!</span></span>.</p>
<p>Now, when I’m missing an ingredient I’ll get a helpful error message that reminds me to just add it.</p>
</section>
</section></div>
  </body>
</html>
