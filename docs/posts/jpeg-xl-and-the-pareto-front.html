<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://cloudinary.com/blog/jpeg-xl-and-the-pareto-front">Original</a>
    <h1>JPEG XL and the Pareto Front</h1>
    
    <div id="readability-page-1" class="page"><div>
        
<p>Version 0.10 of libjxl, the reference implementation for JPEG XL, has just been <a href="https://github.com/libjxl/libjxl/releases">released</a>. The main improvement this version brings, is that the so-called “streaming encoding” API has now been fully implemented. This API allows encoding a large image in “chunks.” Instead of processing the entire image at once, which may require a significant amount of RAM if the image is large, the image can now be processed in a more memory-friendly way. As a side effect, encoding also becomes faster, in particular when doing lossless compression of larger images.</p>








<p>Before version 0.10, lossless JPEG XL encoding was rather memory-intensive and could take quite some time. This could pose a serious problem when trying to encode large images, like for example <a href="https://earthobservatory.nasa.gov/features/NightLights#:~:text=Marble%20imagery.-,Earth%20at%20Night%3A%20Flat%20Maps,-Global%20Map%20Downloads">this 13500×6750 NASA image of Earth at night</a> (64 MB as a <a href="https://eoimages.gsfc.nasa.gov/images/imagerecords/144000/144898/BlackMarble_2016_3km_geo.tif">TIFF file</a>, 273 MB uncompressed).</p>



<figure><img decoding="async" src="https://res.cloudinary.com/jon/image/fetch/w_1000,f_auto,q_auto/https://eoimages.gsfc.nasa.gov/images/imagerecords/144000/144898/BlackMarble_2016_01deg.jpg" alt="A 13500x6750 NASA image of Earth at night"/></figure>



<p>Compressing this image required about 8 gigabytes of RAM in libjxl version 0.9, at the default effort (e7). It took over two minutes, and resulted in a jxl file of 33.7 MB, which is just under 3 bits per pixel. Using more threads did not help much: using a single thread it took 2m40s, using eight threads that was reduced to 2m06s. These timings were measured on a November 2023 Macbook Pro with a 12-core Apple M3 Pro CPU with 36 GB of RAM.</p>



<p>Upgrading to libjxl version 0.10, compressing this same image now requires only 0.7 gigabytes of RAM, takes 30 seconds using a single thread (or 5 seconds using eight threads), and results in a jxl file of 33.2 MB.</p>



<p>For other effort settings, these are the results for this particular image:</p>



<figure><table><tbody><tr><td>effort setting</td><td>memory 0.9.2</td><td>memory 0.10</td><td>time</td><td>time 0.10</td><td>compressed size 0.9</td><td>compressed size 0.10</td><td>memory reduction</td><td>speedup</td></tr><tr><td>e1, 1 thread</td><td>821 MB</td><td>289 MB</td><td>0.65s</td><td>0.3s</td><td>65.26 MB</td><td>67.03 MB</td><td>2.8x</td><td>2.2x</td></tr><tr><td>e1, 8 threads</td><td>842 MB</td><td>284 MB</td><td>0.21s</td><td>0.1s</td><td>65.26 MB</td><td>67.03 MB</td><td>2.9x</td><td>2.1x</td></tr><tr><td>e2, 1 thread</td><td>7,503 MB</td><td>786 MB</td><td>4.3s</td><td>3.6s</td><td>49.98 MB</td><td>44.78 MB</td><td>9.5x</td><td>1.2x</td></tr><tr><td>e2, 8 threads</td><td>6,657 MB</td><td>658 MB</td><td>2.2s</td><td>0.7s</td><td>49.98 MB</td><td>44.78 MB</td><td>10.1x</td><td>3.0x</td></tr><tr><td>e3, 8 threads</td><td>7,452 MB</td><td>708 MB</td><td>2.4s</td><td>1.3s</td><td>45.20 MB</td><td>44.23 MB</td><td>10.5x</td><td>1.8x</td></tr><tr><td>e7, 1 thread</td><td>9,361 MB</td><td>748 MB</td><td>2m40s</td><td>30s</td><td>33.77 MB</td><td>33.22 MB</td><td>12.5x</td><td>4.6x</td></tr><tr><td>e7, 8 threads</td><td>7,887 MB</td><td>648 MB</td><td>2m06s</td><td>5.4s</td><td>33.77 MB</td><td>33.22 MB</td><td>12.2x</td><td>23.6x</td></tr><tr><td>e8, 8 threads</td><td>9,288 MB</td><td>789 MB</td><td>7m38s</td><td>22.2s</td><td>32.98 MB</td><td>32.93 MB</td><td>11.8x</td><td>20.6x</td></tr><tr><td>e9, 8 threads</td><td>9,438 MB</td><td>858 MB</td><td>21m58s</td><td>1m46s</td><td>32.45 MB</td><td>32.20 MB</td><td>11.0x</td><td>12.4x</td></tr></tbody></table></figure>



<p>As you can see in the table above, compression is a game of diminishing returns: as you increase the amount of cpu time spent on the encoding, the compression improves, but not in a linear fashion. Spending one second instead of a tenth of a second (e2 instead of e1) can in this case shave off 22 megabytes; spending five seconds instead of one (e7 instead of e2) shaves off another 11 megabytes. But to shave off one more megabyte, you’ll have to wait almost two minutes (e9 instead of e7).</p>



<p>So it’s very much a matter of trade-offs, and it depends on the use case what makes the most sense. In an authoring workflow, when you’re saving an image locally while still editing it, you typically don’t need strong compression and low-effort encoding makes sense. But in a one-to-many delivery scenario, or for long-term archival, it may well be worth it to spend a significant amount of CPU time to shave off some more megabytes.</p>








<p>When comparing different compression techniques, it doesn’t suffice to only look at the compressed file sizes. The speed of encoding also matters. So there are two dimensions to consider: compression density and encode speed.</p>



<p>A specific method can be called Pareto-optimal if no other method can achieve the same (or better) compression density in less time. There might be other methods that compress better but take more time, or that compress faster but result in larger files. But a Pareto-optimal method delivers the smallest files for a given time budget, which is why it’s called “optimal.”</p>



<p>The set of Pareto-optimal methods is called the “<a href="https://en.wikipedia.org/wiki/Pareto_front">Pareto front</a>.” It can be visualized by putting the different methods on a chart that shows both dimensions — encode speed and compression density. Instead of looking at a single image, which may not be representative, we look at a set of images and look at the average speed and compression density for each encoder and effort setting. For example, for <a href="https://imagecompression.info/test_images/">this set of test images</a>, the chart looks like this:</p>



<figure><img width="1846" height="1596" decoding="async" loading="lazy" src="https://res.cloudinary.com/cloudinary-marketing/images/w_1846,h_1596/f_auto,q_auto/v1709058557/Web_Assets/blog/blog-pareto-front-1/blog-pareto-front-1-png?_i=AA" alt="" data-public-id="Web_Assets/blog/blog-pareto-front-1.png" data-format="png" data-transformations="f_auto,q_auto" data-version="1709058557" srcset="https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709058557/Web_Assets/blog/blog-pareto-front-1/blog-pareto-front-1-png?_i=AA 1846w, https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709058557/Web_Assets/blog/blog-pareto-front-1/blog-pareto-front-1-png?_i=AA 300w, https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709058557/Web_Assets/blog/blog-pareto-front-1/blog-pareto-front-1-png?_i=AA 768w, https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709058557/Web_Assets/blog/blog-pareto-front-1/blog-pareto-front-1-png?_i=AA 1024w, https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709058557/Web_Assets/blog/blog-pareto-front-1/blog-pareto-front-1-png?_i=AA 1536w" sizes="(max-width: 1846px) 100vw, 1846px"/></figure>



<p>The vertical axis shows the encode speed, in megapixels per second. It’s a logarithmic scale since it has to cover a broad range of speeds, from less than one megapixel per second to hundreds of megapixels per second. The horizontal axis shows the average bits per pixel for the compressed image (uncompressed 8-bit RGB is 24 bits per pixel).</p>


<div><p><strong>TL;DR</strong></p><p>Higher means faster, more to the left means better compression.</p>
</div>


<p>For AVIF, the darker points indicate a faster but slightly less dense tiled encoder setting (using –tilerowslog2 2 –tilecolslog2 2), which is faster because it can make better use of multi-threading, while the lighter points indicate the default non-tiled setting. For PNG, the result of libpng with default settings is shown here as a reference point; other PNG encoders and optimizers exist that reach different trade-offs.</p>



<p>The previous version of libjxl already achieved Pareto-optimal results across all speeds, producing smaller files than PNG and lossless AVIF or lossless WebP. The new version beats the previous version by a significant margin.</p>



<p>Not shown on the chart is <a href="https://github.com/phoboslab/qoi">QOI</a>, which clocked in at 154 Mpx/s to achieve 17 bpp, which may be “quite OK” but is quite far from Pareto-optimal, considering the lowest effort setting of libjxl compresses down to 11.5 bpp at 427 Mpx/s (so it is 2.7 times as fast and the result is 32.5% smaller).</p>








<p>Of course in these charts, quite a lot depends on the selection of test images. In the chart above, most images are photographs, which tend to be hard to compress losslessly: the naturally occurring noise in such images is inherently incompressible.</p>



<p>For non-photographic images, things are somewhat different. I took a random collection of manga images in various drawing styles (41 images with an average size of 7.3 megapixels) and these were the results:</p>



<p>These kinds of images compress significantly better, to around 4 bpp (compared to around 10 bpp for photographic images). For these images, lossless AVIF is not useful — it compresses worse than PNG, and reaches about the same density as QOI but is much slower. Lossless WebP on the other hand achieves very good compression for such images. For these types of images, QOI is indeed quite OK for its speed (and simplicity), though far from Pareto-optimal: low-effort JPEG XL encoding is twice as fast and 31% smaller.</p>



<figure><img width="1860" height="1594" decoding="async" loading="lazy" src="https://res.cloudinary.com/cloudinary-marketing/images/w_1860,h_1594/f_auto,q_auto/v1709058548/Web_Assets/blog/blog-pareto-front-2/blog-pareto-front-2-png?_i=AA" alt="" data-public-id="Web_Assets/blog/blog-pareto-front-2.png" data-format="png" data-transformations="f_auto,q_auto" data-version="1709058548" srcset="https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709058548/Web_Assets/blog/blog-pareto-front-2/blog-pareto-front-2-png?_i=AA 1860w, https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709058548/Web_Assets/blog/blog-pareto-front-2/blog-pareto-front-2-png?_i=AA 300w, https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709058548/Web_Assets/blog/blog-pareto-front-2/blog-pareto-front-2-png?_i=AA 768w, https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709058548/Web_Assets/blog/blog-pareto-front-2/blog-pareto-front-2-png?_i=AA 1024w, https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709058548/Web_Assets/blog/blog-pareto-front-2/blog-pareto-front-2-png?_i=AA 1536w" sizes="(max-width: 1860px) 100vw, 1860px"/></figure>



<p>For non-photographic images, the new version of libjxl again improves upon the previous version, by a significant margin. The previous version of libjxl could just barely beat WebP: e.g. default-effort WebP compressed these images to 4.30 bpp at 2.3 Mpx/s, while libjxl 0.9 at effort 5 compressed them to 4.27 bpp at 2.6 Mpx/s — only a slight improvement. However libjxl 0.10 at effort 5 compresses the images to 4.25 bpp at 12.2 Mpx/s (slightly better compression but much faster), and at effort 7 it compresses them to 4.04 bpp at 5.9 Mpx/s (significantly better compression and still twice as fast). Zooming in on the medium-speed part of the Pareto front on the above plot, the improvement going from libjxl 0.9 to 0.10 becomes clear:</p>



<figure><img width="1830" height="1578" decoding="async" loading="lazy" src="https://res.cloudinary.com/cloudinary-marketing/images/w_1830,h_1578/f_auto,q_auto/v1709058543/Web_Assets/blog/blog-pareto-front-3/blog-pareto-front-3-png?_i=AA" alt="" data-public-id="Web_Assets/blog/blog-pareto-front-3.png" data-format="png" data-transformations="f_auto,q_auto" data-version="1709058543" srcset="https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709058543/Web_Assets/blog/blog-pareto-front-3/blog-pareto-front-3-png?_i=AA 1830w, https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709058543/Web_Assets/blog/blog-pareto-front-3/blog-pareto-front-3-png?_i=AA 300w, https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709058543/Web_Assets/blog/blog-pareto-front-3/blog-pareto-front-3-png?_i=AA 768w, https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709058543/Web_Assets/blog/blog-pareto-front-3/blog-pareto-front-3-png?_i=AA 1024w, https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709058543/Web_Assets/blog/blog-pareto-front-3/blog-pareto-front-3-png?_i=AA 1536w" sizes="(max-width: 1830px) 100vw, 1830px"/></figure>








<p>Lossless compression is relatively easy to benchmark: all that matters is the compressed size and the speed. For lossy compression, there is a third dimension: image quality.</p>



<p>Lossy image codecs and encoders can perform differently at different quality points. An encoder that works very well for high-quality encoding does not necessarily also perform well for low-quality encoding, and the other way around.</p>



<p>Of these three dimensions (compression, speed and quality), often speed is simply ignored, and plots are made of compression versus quality (also known as bitrate-distortion plots). But this does not really allow evaluating the trade-offs between encode effort (speed) and compression performance. So if we really want to investigate the Pareto front for lossy compression, one way of doing it is to look at different “slices” of the three-dimensional space, at various quality points.</p>








<p>Image quality is a notoriously difficult thing to measure: in the end, it is subjective and somewhat different from one human to the next. The best way to measure image quality is still to run an experiment involving at least dozens of humans looking carefully at images and comparing or scoring them, according to rigorously defined test protocols. At Cloudinary, we have <a href="https://cloudinary.com/labs/cid22">done such experiments</a> in the past. But while this is the best way to assess image quality, it is a time-consuming and costly process, and it is not feasible to test all possible encoder configurations in this way.</p>



<p>For that reason, so-called objective metrics are being developed, which allow algorithmic estimates of image quality. These metrics are not “more objective” (in the sense of “more correct”) than scores obtained from testing with humans, in fact they are <em>less</em> “correct.” But they can give an indication of image quality much faster and cheaper (and more easily reproducible and consistent) than when humans are involved, which is what makes them useful.</p>



<p>The best metrics currently publicly available are <a href="https://github.com/cloudinary/ssimulacra2">SSIMULACRA2</a>, <a href="https://github.com/google/butteraugli">Butteraugli</a>, and <a href="https://github.com/kornelski/dssim">DSSIM</a>. These metrics try to model the human visual system and have the <a href="https://cloudinary.com/labs/cid22#:~:text=(SSIMULACRA%202),%2D0.7813">best correlation with subjective results</a>. Older, simpler metrics like PSNR or SSIM could also be used, but they do not correlate very well with human opinions about image quality. Care has to be taken not to measure results using a metric an encoder is specifically optimizing for, as that would skew the results in favor of such encoders. For example, higher-effort libjxl optimizes for Butteraugli, while libavif can optimize for PSNR or SSIM. In this respect, SSIMULACRA2 is “safe” since none of the encoders tested is using it internally for optimization.</p>








<p>Different metrics will say different things, but there are also different ways to aggregate results across a set of images. To keep things simple, I selected <a href="https://gist.github.com/jonsneyers/d317f51b4805c1a8f3ce0e86a9bce100">encoder settings</a> such that when using each setting on all images in the set, the average SSIMULACRA2 score was equal to (or close to) a specific value. Another method would have been to adjust the encoder settings per image so for each image the SSIMULACRA2 score is the same, or to select an encoder setting such that the <em>worst-case</em> SSIMULACRA2 score is equal to a specific value.</p>



<figure><img width="1182" height="1536" decoding="async" loading="lazy" src="https://res.cloudinary.com/cloudinary-marketing/images/w_1182,h_1536/f_auto,q_auto/v1709058535/Web_Assets/blog/blog-pareto-front-4/blog-pareto-front-4-png?_i=AA" alt="" data-public-id="Web_Assets/blog/blog-pareto-front-4.png" data-format="png" data-transformations="f_auto,q_auto" data-version="1709058535" srcset="https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709058535/Web_Assets/blog/blog-pareto-front-4/blog-pareto-front-4-png?_i=AA 1182w, https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709058535/Web_Assets/blog/blog-pareto-front-4/blog-pareto-front-4-png?_i=AA 231w, https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709058535/Web_Assets/blog/blog-pareto-front-4/blog-pareto-front-4-png?_i=AA 768w, https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709058535/Web_Assets/blog/blog-pareto-front-4/blog-pareto-front-4-png?_i=AA 788w" sizes="(max-width: 1182px) 100vw, 1182px"/></figure>



<p>Defining the quality points the way I did (using fixed settings and aligning by average metric score) is in the favor of WebP and AVIF; in practical usage you will likely want to align on worst-case metric score (or rather, worst-case <em>actual visual quality</em>), but I chose not to do that, in order to not favor JPEG XL.</p>








<p>Lossless compression offers 2:1 to 3:1 compression ratios (8 to 12 bpp) for photographic images. Lossy compression can reach much better compression ratios. It is tempting to see how lossy image codecs behave when they are pushed to their limits. Compression ratios of 50:1 or even 200:1 (0.1 to 0.5 bpp) can be obtained, at the cost of introducing compression artifacts. Here is an example of an image compressed to reach a SSIMULACRA2 score of 50, 30, and 10 using libjpeg-turbo, libjxl and libavif:</p>



<figure><a href="https://res.cloudinary.com/jon/qp-low.png" target="_blank" rel="noreferrer noopener"><img decoding="async" src="https://cloudinary-marketing-res.cloudinary.com/image/upload/v1709060139/qp-low.png" alt=""/></a></figure>


<div><p><strong>Note:</strong></p><p>Click on the animation to open it in another tab; view it full-size to properly see the artifacts.</p>
</div>


<p>This kind of quality is interesting to look at in experiments, but in most actual usage, it is not desirable to introduce such noticeable compression artifacts. In practice, the range of qualities that is relevant corresponds to SSIMULACRA2 scores ranging from 60 (medium quality) to 90 (visually lossless). These qualities look like this:</p>



<figure><a href="https://res.cloudinary.com/jon/qp.png" target="_blank" rel="noreferrer noopener"><img decoding="async" src="https://cloudinary-marketing-res.cloudinary.com/image/upload/v1709060138/qp.png" alt=""/></a></figure>



<p>Visually lossless quality (SSIMULACRA2 = 90) can be reached with a compression ratio of about 8:1 (3 bpp) with modern codecs such as AVIF and JPEG XL, or about 6:1 (4 bpp) with JPEG. At this point, the image is visually not distinguishable from the uncompressed original, even when looking very carefully. In cameras, when not shooting RAW, typically this is the kind of quality that is desired. For web delivery, it is overkill to use such a high quality.</p>



<p>High quality (SSIMULACRA2 = 80) can be reached with a compression ratio of 16:1 (1.5 bpp). When looking carefully, very small differences might be visible, but essentially the image is still as good as the original. This, or perhaps something in between high quality and visually lossless quality, is the highest quality useful for web delivery, for use cases where image fidelity really matters.</p>



<p>Medium-high quality (SSIMULACRA2 = 70) can be reached with a compression ratio of 30:1 (0.8 bpp). There are some small artifacts, but the image still looks good. This is a good target for most web delivery use cases, as it makes a good trade-off between fidelity and bandwidth optimization.</p>



<p>Medium quality (SSIMULACRA2 = 60) can be reached with a compression ratio of 40:1 (0.6 bpp). Compression artifacts start to become more noticeable, but they’re not problematic for casual viewing. For non-critical images on the web, this quality can be “good enough.”</p>



<p>Any quality lower than this is potentially risky: sure, bandwidth will be reduced by going even further, but at the cost of potentially ruining the images. For the web, in 2024, the relevant range is medium to high quality: <a href="https://almanac.httparchive.org/en/2022/media#bits-per-pixel-by-format">according to the HTTP Archive</a>, the median AVIF image on the web is compressed to 1 bpp, which corresponds to medium-high quality, while the median JPEG image is 2.1 bpp, which corresponds to high quality. For most non-web use cases (e.g. cameras), the relevant range is high to (visually) lossless quality.</p>








<p>In the following Pareto front plots, the following encoders were tested:</p>



<figure><table><tbody><tr><td>format</td><td>encoder</td><td>version</td></tr><tr><td>JPEG</td><td>libjpeg-turbo</td><td>libjpeg-turbo 2.1.5.1</td></tr><tr><td>JPEG</td><td>sjpeg</td><td>sjpeg @ e5ab130</td></tr><tr><td>JPEG</td><td>mozjpeg</td><td>mozjpeg version 4.1.5 (build 20240220)</td></tr><tr><td>JPEG</td><td>jpegli</td><td>from libjxl v0.10.0</td></tr><tr><td>AVIF</td><td>libavif / libaom</td><td>libavif 1.0.3 (aom [enc/dec]:3.8.1)</td></tr><tr><td>JPEG XL</td><td>libjxl</td><td>libjxl v0.10.0</td></tr><tr><td>WebP</td><td>libwebp</td><td>libwebp 1.3.2</td></tr><tr><td>HEIC</td><td>libheif</td><td>heif-enc libheif version: 1.17.6 (x265 3.5)</td></tr></tbody></table></figure>



<p>These are the most recent versions of each encoder at the time of writing (end of February 2024).</p>



<p>Encode speed was again measured on a November 2023 Macbook Pro (Apple M3 Pro), using 8 threads. For AVIF, both the tiled setting (with –tilerowslog2 2 –tilecolslog2 2) and the non-tiled settings were tested. The tiled setting, indicated with “MT”, is faster since it allows better multi-threading, but it comes at a cost in compression density.</p>








<p>Let’s start by looking at the results for medium quality, i.e., settings that result in a corpus average SSIMULACRA2 score of 60. This is more or less the lowest quality point that is used in practice. Some images will have visible compression artifacts with these encoder settings, so this quality point is most relevant when saving bandwidth and reducing page weight is more important than image fidelity.</p>



<figure><img width="1942" height="1620" decoding="async" loading="lazy" src="https://res.cloudinary.com/cloudinary-marketing/images/w_1942,h_1620/f_auto,q_auto/v1709058526/Web_Assets/blog/blog-pareto-front-5/blog-pareto-front-5-png?_i=AA" alt="" data-public-id="Web_Assets/blog/blog-pareto-front-5.png" data-format="png" data-transformations="f_auto,q_auto" data-version="1709058526" srcset="https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709058526/Web_Assets/blog/blog-pareto-front-5/blog-pareto-front-5-png?_i=AA 1942w, https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709058526/Web_Assets/blog/blog-pareto-front-5/blog-pareto-front-5-png?_i=AA 300w, https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709058526/Web_Assets/blog/blog-pareto-front-5/blog-pareto-front-5-png?_i=AA 768w, https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709058526/Web_Assets/blog/blog-pareto-front-5/blog-pareto-front-5-png?_i=AA 1024w, https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709058526/Web_Assets/blog/blog-pareto-front-5/blog-pareto-front-5-png?_i=AA 1536w" sizes="(max-width: 1942px) 100vw, 1942px"/></figure>



<p>First of all, note that even for the same format, different encoders and different effort settings can reach quite different results. Historically, the most commonly used JPEG encoder was libjpeg-turbo — often using its default setting (no Huffman optimization, not progressive), which is the point all the way in the top right. When Google first introduced WebP, it outperformed libjpeg-turbo in terms of compression density, as can be seen in the plot above. But Mozilla was not impressed, and they created their own JPEG encoder, mozjpeg, which is slower than libjpeg-turbo but offers better compression results. And indeed, we can see that mozjpeg is actually more Pareto-efficient than WebP (for this corpus, at this quality point).</p>



<p>More recently, the JPEG XL team at Google has built yet another JPEG encoder, jpegli, which is both faster and better than even mozjpeg. It is based on lessons learned from guetzli and libjxl, and offers a very attractive trade-off: it is very fast, compresses better than WebP and even high-speed AVIF, while still producing good old JPEG files that are supported everywhere.</p>



<p>Moving on to the newer codecs, we can see that both AVIF and HEIC can obtain a better compression density than JPEG and WebP, at the cost of slower encoding. JPEG XL can reach a similar compression density but encodes significantly faster. The current Pareto front for this quality point consists of JPEG XL and the various JPEG encoders for the “reasonable” speeds, and AVIF at the slower speeds (though the additional savings over default-effort JPEG XL are small).</p>








<p>At somewhat higher quality settings where the average SSIMULACRA2 score for the corpus is 70, the overall results look quite similar:</p>



<figure><img width="1999" height="1496" decoding="async" loading="lazy" src="https://res.cloudinary.com/cloudinary-marketing/images/w_1999,h_1496/f_auto,q_auto/v1709058518/Web_Assets/blog/blog-pareto-front-6/blog-pareto-front-6-png?_i=AA" alt="" data-public-id="Web_Assets/blog/blog-pareto-front-6.png" data-format="png" data-transformations="f_auto,q_auto" data-version="1709058518" srcset="https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709058518/Web_Assets/blog/blog-pareto-front-6/blog-pareto-front-6-png?_i=AA 1999w, https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709058518/Web_Assets/blog/blog-pareto-front-6/blog-pareto-front-6-png?_i=AA 300w, https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709058518/Web_Assets/blog/blog-pareto-front-6/blog-pareto-front-6-png?_i=AA 768w, https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709058518/Web_Assets/blog/blog-pareto-front-6/blog-pareto-front-6-png?_i=AA 1024w, https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709058518/Web_Assets/blog/blog-pareto-front-6/blog-pareto-front-6-png?_i=AA 1536w" sizes="(max-width: 1999px) 100vw, 1999px"/></figure>








<p>Moving on to the highest quality point that is relevant for the web (corpus average SSIMULACRA2 score of 85, to ensure that most images reach a score above 80), the differences become a little more pronounced.</p>



<figure><img width="1999" height="1612" decoding="async" loading="lazy" src="https://res.cloudinary.com/cloudinary-marketing/images/w_1999,h_1612/f_auto,q_auto/v1709058510/Web_Assets/blog/blog-pareto-front-7/blog-pareto-front-7-png?_i=AA" alt="" data-public-id="Web_Assets/blog/blog-pareto-front-7.png" data-format="png" data-transformations="f_auto,q_auto" data-version="1709058510" srcset="https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709058510/Web_Assets/blog/blog-pareto-front-7/blog-pareto-front-7-png?_i=AA 1999w, https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709058510/Web_Assets/blog/blog-pareto-front-7/blog-pareto-front-7-png?_i=AA 300w, https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709058510/Web_Assets/blog/blog-pareto-front-7/blog-pareto-front-7-png?_i=AA 768w, https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709058510/Web_Assets/blog/blog-pareto-front-7/blog-pareto-front-7-png?_i=AA 1024w, https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709058510/Web_Assets/blog/blog-pareto-front-7/blog-pareto-front-7-png?_i=AA 1536w" sizes="(max-width: 1999px) 100vw, 1999px"/></figure>



<p>At this point, mozjpeg no longer beats WebP, though jpegli still does. The Pareto front is now mostly covered by JPEG XL, though for very fast encoding, good old JPEG is still best. At this quality point, AVIF is not on the Pareto front: at its slowest settings (at 0.5 Mpx/s or slower) it matches the compression density of the second-fastest libjxl setting, which is over 100 times as fast (52 Mpx/s).</p>








<p>So far, we have only looked at compression density and encode speed. Decode speed is not really a significant problem on modern computers, but it is interesting to take a quick look at the numbers. The table below shows the same results as the plot above, but besides bits per pixel and encode speed, it also shows the decode speed. For completeness, the SSIMULACRA2 and Butteraugli 3-norm scores are also given for each encoder setting.</p>


<div>
<figure><img width="846" height="1298" data-public-id="Web_Assets/blog/Screen-Shot-2024-02-29-at-3.35.25-PM.png" decoding="async" loading="lazy" src="https://res.cloudinary.com/cloudinary-marketing/images/w_846,h_1298/f_auto,q_auto/v1709249796/Web_Assets/blog/Screen-Shot-2024-02-29-at-3.35.25-PM/Screen-Shot-2024-02-29-at-3-35-25-PM-png?_i=AA" alt="" data-format="png" data-transformations="f_auto,q_auto" data-version="1709249796" srcset="https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709249796/Web_Assets/blog/Screen-Shot-2024-02-29-at-3.35.25-PM/Screen-Shot-2024-02-29-at-3-35-25-PM-png?_i=AA 846w, https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709249796/Web_Assets/blog/Screen-Shot-2024-02-29-at-3.35.25-PM/Screen-Shot-2024-02-29-at-3-35-25-PM-png?_i=AA 196w, https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709249796/Web_Assets/blog/Screen-Shot-2024-02-29-at-3.35.25-PM/Screen-Shot-2024-02-29-at-3-35-25-PM-png?_i=AA 768w, https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709249796/Web_Assets/blog/Screen-Shot-2024-02-29-at-3.35.25-PM/Screen-Shot-2024-02-29-at-3-35-25-PM-png?_i=AA 667w" sizes="(max-width: 846px) 100vw, 846px"/></figure></div>


<p>Sequential JPEG is unbeatable in terms of decode speed — not surprising for a codec that was designed in the 1980s. Progressive JPEG (e.g. as produced by mozjpeg and default jpegli) is somewhat slower to decode, but still fast enough to load any reasonably-sized image in the blink of an eye. JPEG XL is somewhere in between those two.</p>



<p>Interestingly, the decode speed of AVIF depends on how the image was encoded: it is faster when using the faster-but-slightly-worse multi-tile encoding, slower when using the default single-tile encoding. Still, even the slowest decode speed measured here is probably “fast enough,” especially compared to the encode speeds.</p>








<p>Finally, let’s take a look at the results for visually lossless quality:</p>



<figure><img width="1999" height="1613" decoding="async" loading="lazy" src="https://res.cloudinary.com/cloudinary-marketing/images/w_1999,h_1613/f_auto,q_auto/v1709058502/Web_Assets/blog/blog-pareto-front-8/blog-pareto-front-8-png?_i=AA" alt="" data-public-id="Web_Assets/blog/blog-pareto-front-8.png" data-format="png" data-transformations="f_auto,q_auto" data-version="1709058502" srcset="https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709058502/Web_Assets/blog/blog-pareto-front-8/blog-pareto-front-8-png?_i=AA 1999w, https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709058502/Web_Assets/blog/blog-pareto-front-8/blog-pareto-front-8-png?_i=AA 300w, https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709058502/Web_Assets/blog/blog-pareto-front-8/blog-pareto-front-8-png?_i=AA 768w, https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709058502/Web_Assets/blog/blog-pareto-front-8/blog-pareto-front-8-png?_i=AA 1024w, https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709058502/Web_Assets/blog/blog-pareto-front-8/blog-pareto-front-8-png?_i=AA 1536w" sizes="(max-width: 1999px) 100vw, 1999px"/></figure>



<p>WebP is not on this chart since it simply cannot reach this quality point, at least not using its lossy mode. This is because 4:2:0 chroma subsampling is obligatory in WebP. Also clearly mozjpeg was not designed for this quality point, and performs worse than libjpeg-turbo in both compression and speed.</p>



<p>At their default speed settings, libavif is 20% smaller than libjpeg-turbo (though it takes an order of magnitude longer to encode), while libjxl is 20% smaller than libavif and 2.5 times as fast, at this quality point. The Pareto front consists of mostly JPEG XL but at the fastests speeds again also includes JPEG.</p>








<p>In the plots above, the <a href="https://people.xiph.org/~xiphmont/demo/daala/update1-tool2b.shtml">test set</a> consisted of web-sized images of about 1 megapixel each. This is relevant for the web, but for example when storing camera pictures, images are larger than this.</p>



<p>For a test set with larger images (the <a href="https://imagecompression.info/test_images/">same set we used before</a> to test lossless compression), at a high quality point, we get the following results:</p>



<figure><img width="1999" height="1358" decoding="async" loading="lazy" src="https://res.cloudinary.com/cloudinary-marketing/images/w_1999,h_1358/f_auto,q_auto/v1709058494/Web_Assets/blog/blog-pareto-front-9/blog-pareto-front-9-png?_i=AA" alt="" data-public-id="Web_Assets/blog/blog-pareto-front-9.png" data-format="png" data-transformations="f_auto,q_auto" data-version="1709058494" srcset="https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709058494/Web_Assets/blog/blog-pareto-front-9/blog-pareto-front-9-png?_i=AA 1999w, https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709058494/Web_Assets/blog/blog-pareto-front-9/blog-pareto-front-9-png?_i=AA 300w, https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709058494/Web_Assets/blog/blog-pareto-front-9/blog-pareto-front-9-png?_i=AA 768w, https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709058494/Web_Assets/blog/blog-pareto-front-9/blog-pareto-front-9-png?_i=AA 1024w, https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1709058494/Web_Assets/blog/blog-pareto-front-9/blog-pareto-front-9-png?_i=AA 1536w" sizes="(max-width: 1999px) 100vw, 1999px"/></figure>



<p>Now things look quite different than with the smaller, web-sized images. WebP, mozjpeg, and AVIF are worse than libjpeg-turbo (for these images, at this quality point). HEIC brings significant savings over libjpeg-turbo, though so does jpegli, at a much better speed. JPEG XL is the clear winner, compressing the images to less than 1.3 bpp while AVIF, libjpeg-turbo, and WebP require more than 2 bpp.</p>








<p>While not as dramatic as the improvements in lossless compression, also for lossy compression there have been improvements between libjxl 0.9 and libjxl 0.10. At the default effort setting (e7), this is how the memory and speed changed for a large (39 Mpx) image:</p>



<figure><table><tbody><tr><td>effort setting</td><td>memory 0.9.2</td><td>memory 0.10</td><td>time</td><td>time 0.10</td><td>compressed size 0.9</td><td>compressed size 0.10</td><td>memory reduction</td><td>speedup</td></tr><tr><td>e7, d1, 1 thread</td><td>4,052 MB</td><td>397 MB</td><td>9.6s</td><td>8.6s</td><td>6.57 MB</td><td>6.56 MB</td><td>10.2x</td><td>1.11x</td></tr><tr><td>e7, d1, 8 threads</td><td>3,113 MB</td><td>437 MB</td><td>3.1s</td><td>1.7s</td><td>6.57 MB</td><td>6.56 MB</td><td>7.1x</td><td>1.76x</td></tr></tbody></table></figure>








<p>The new version of libjxl brings a very substantial reduction in memory consumption, by an order of magnitude, for both lossy and lossless compression. Also the speed is improved, especially for multi-threaded lossless encoding where the default effort setting is now an order of magnitude faster.</p>



<p>This consolidates JPEG XL’s position as the best image codec currently available, for both lossless and lossy compression, across the quality range but in particular for high quality to visually lossless quality. It is Pareto-optimal across a wide range of speed settings.</p>



<p>Meanwhile, the old JPEG is still attractive thanks to better encoders. The new jpegli encoder brings a significant improvement over mozjpeg in terms of both speed and compression. Perhaps surprisingly, good old JPEG is still part of the Pareto front — when extremely fast encoding is needed, it can still be the best choice.</p>



<p>At Cloudinary, we are actively participating in improving the state of the art in image compression. We are continuously applying new insights and technologies in order to bring the best possible experience to our end-users. As new codecs emerge and encoders for existing codes improve, we keep making sure to deliver media according to the state of the art.</p>

      </div></div>
  </body>
</html>
