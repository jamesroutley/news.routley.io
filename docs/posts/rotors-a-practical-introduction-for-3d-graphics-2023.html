<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jacquesheunis.com/post/rotors/">Original</a>
    <h1>Rotors: A practical introduction for 3D graphics (2023)</h1>
    
    <div id="readability-page-1" class="page"><article><p>When putting 3D graphics on a screen, we need a way to express rotations of the geometry we’re rendering.
To avoid the problems that come with storing rotations as axes &amp; angles, we could use quaternions.
However quaternions require that we think in 4 distinct spatial dimensions, something humans are notoriously bad at. Thankfully there is an alternative that some argue is far more elegant and simpler to understand: Rotors.</p><p>Rotors come from an area of mathematics called geometric algebra. Over the past few years I’ve seen a steady increase in the number of people claiming we should bin quaternions entirely in 3D graphics and replace them with rotors. I know nothing about either so I figured I’d try out rotors. I struggled to find educational materials online that clicked well with how I think about these things though, so this post is my own explanation of rotors and the surrounding mathematical concepts. It’s written with the specific intention of implementing rotation for 3D graphics and is intended to be used partly as an educational text and partly as a reference page.</p><p>There are two sections: The first half is purely theoretical, where we’ll look at where rotors “come from”, investigate how they behave and see how we can use them to perform rotations. The second half will cover practical applications and includes example code for use-cases you’re likely to encounter in 3D graphics.</p><nav id="TableOfContents"><ul><li><a href="#a-word-on-notation">A word on notation</a></li><li><a href="#theory-adding-rotors-to-our-mathematical-toolbox">Theory: Adding rotors to our mathematical toolbox</a><ul><li><a href="#introducing-the-wedge-product">Introducing: The wedge product</a></li><li><a href="#wedge-product-of-non-basis-vectors">Wedge product of non-basis vectors</a></li><li><a href="#geometric-product">Geometric product</a></li><li><a href="#inverses-under-the-geometric-product">Inverses under the geometric product</a></li><li><a href="#reflections-with-the-geometric-product">Reflections with the geometric product</a></li><li><a href="#rotors-as-a-combination-of-two-reflections">Rotors as a combination of two reflections</a></li><li><a href="#the-identity-rotor">The identity rotor</a></li><li><a href="#axis-angle-representation-for-rotors">Axis-angle representation for rotors</a></li></ul></li><li><a href="#applications-putting-rotors-to-work">Applications: Putting rotors to work</a><ul><li><a href="#how-do-i-store-a-rotor-in-memory">How do I store a rotor in memory?</a></li><li><a href="#how-do-i-represent-an-orientation-as-opposed-to-a-rotation">How do I represent an <em>orientation</em> (as opposed to a <em>rotation</em>)?</a></li><li><a href="#how-do-i-produce-a-rotor-representing-a-rotation-from-orientation-a-to-orientation-b">How do I produce a rotor representing a rotation from orientation A to orientation B?</a></li><li><a href="#how-do-i-appendcombinemultiply-two-or-more-rotors">How do I append/combine/multiply two (or more) rotors?</a></li><li><a href="#how-do-i-invert-or-reverse-a-rotor-to-produce-the-same-rotation-in-the-opposite-direction">How do I invert or reverse a rotor to produce the same rotation in the opposite direction?</a></li><li><a href="#given-a-particular-rotor-how-do-i-actually-apply-it-to-a-vector-directly">Given a particular rotor, how do I actually apply it to a vector directly?</a></li><li><a href="#how-do-i-convert-a-rotor-to-a-matrix-so-i-can-use-it-in-my-graphics-pipeline">How do I convert a rotor to a matrix so I can use it in my graphics pipeline?</a></li><li><a href="#how-do-i-turn-a-quaternion-into-an-equivalent-3d-rotor">How do I turn a quaternion into an equivalent (3D) rotor?</a></li><li><a href="#how-do-i-smoothly--correctly-interpolate-between-two-rotors">How do I smoothly &amp; correctly interpolate between two rotors?</a></li></ul></li><li><a href="#summing-up">Summing up</a></li></ul></nav><h2 id="a-word-on-notation"><a href="#a-word-on-notation">A word on notation</a></h2><p>\(\global\def\v#1{\mathbf{#1}}\)</p><p>In this post we will write vectors, bivectors and trivectors in bold and lower-case (e.g \(\v{v}\) is a vector). Rotors will be written in bold and upper-case (e.g \(\v{R}\) is a rotor).</p><p>The basis elements of our 3D space are denoted \(\v{e_1, e_2, e_3}\), so for example \(\v{v} = v_1\v{e_1} + v_2\v{e_2} + v_3\v{e_3}\).</p><p>Where multiplication tables are given, the first argument is the entry on the far left column of the table and the second argument is the entry on the top row of the table.</p><p>Since this post is primarily concerned with 3D graphics &amp; simulation, we will restrict our examples to 3 dimensions of space. Rotors (unlike quaternions) can easily be extended to higher dimensions but this is left as an exercise for the reader.</p><h3 id="introducing-the-wedge-product"><a href="#introducing-the-wedge-product">Introducing: The wedge product</a></h3><p>We begin our journey by defining a new way to combine two vectors: the so-called “wedge product”, written as \(\v{a \wedge b}\). We define the wedge product of two vectors as an associative product that distributes over addition and which is zero when both arguments are the same:</p><p id="eqn:wedge-product-defining" data-equation-number="1">\[\begin{equation}
\v{v \wedge v} = 0
\tag{ 1 }
\end{equation} \]</p><p>From this we can show that the wedge product is also anticommutative:</p><details><summary>\(\v{(a \wedge b) = -(b \wedge a)}\)</summary><p>Given vectors \(\v{a}\) and \(\v{b}\):
\[
\begin{aligned}
(\v{a + b}) \wedge (\v{a + b}) &amp;= 0 \\
(\v{a \wedge a}) + (\v{a \wedge b}) + (\v{b \wedge a}) + (\v{b \wedge b}) &amp;= 0 \\
0 + (\v{a \wedge b}) + (\v{b \wedge a}) + 0 &amp;= 0 \\
(\v{a \wedge b}) &amp;= -(\v{b \wedge a})
\end{aligned}
\]</p></details><p>We have yet to specify how to actually “compute” a wedge product though. We know that it produces zero when both arguments are equivalent but what if they aren’t? In this case we “compute” the wedge product by expressing the arguments in terms of its basis elements and multiplying out.</p><p>When it comes down to a pair of basis vectors we just leave them be.
So for example we don’t simplify \(\v{e_1} \wedge \v{e_2}\) any further.
This is because \(\v{e_1} \wedge \v{e_2}\) is not a vector.
It’s a new kind of entity called a <em>bivector</em>.
If you think of an ordinary a vector as a point (offset from the origin), then the bivector produced by applying the wedge product to those two vectors can be visualised as the infinite plane containing the origin and those two points.
Equivalently, you can think of a bivector as the direction that is normal to the plane formed by the two vectors that we wedged together.
The bivector \(\v{e_1 \wedge e_2}\) is in some sense the normal going in the same direction as the vector \(\v{e_3}\).</p><p>In the same way that we have basis vectors (\(\v{e_1}, \v{e_2}, \v{e_3})\), we also have basis bivectors: \(\v{e_{12}}, \v{e_{23}}, \v{e_{31}}\).
Conveniently, these bivector basis elements are simple wedge products of the vector basis elements:
\[
\v{e_{12}} = \v{e_1} \wedge \v{e_2} \\
\v{e_{23}} = \v{e_2} \wedge \v{e_3} \\
\v{e_{31}} = \v{e_3} \wedge \v{e_1}
\]</p><p>Note that (as with vectors) we’re not restricted to a specific set of basis bivectors.
Some texts prefer to use \(\v{e_{12}}, \v{e_{13}}, \v{e_{23}}\).
The calculations work out a little differently but the logic is the same.
For this post we’ll use \(\v{e_{12}}, \v{e_{23}}, \v{e_{31}}\) throughout. An important thing to note is that the 3-dimensional case is a little misleading here. It is very easy to confuse vectors with bivectors because they have the same number of basis elements. This is not true in higher dimensions. In 4-dimensional space, for example, there are 4 basis vectors but 6 basis bivectors so we should always explicitly state what basis elements we’re using in our calculations.</p><p>One last realisation is that in 3D we can go one step further. On top of vectors (representing lines) and bivectors (representing planes), we also have trivectors, which represent volumes. Trivectors are as far as we can go in 3D though because the space itself is 3-dimensional, there’s no room for more dimensions! Trivectors in 3D are sometimes referred to as “pseudoscalars” since they have only 1 basis element: \(\v{e_{123}}\). Trivectors in 3D are oriented (in the sense that the coefficient of the trivector basis element can be negative) but otherwise contain no positional information.</p><p>Below is a multiplication table for the wedge product of our 3D basis vectors:</p><p>\[\begin{array}{c|c:c:c}
\wedge &amp; \v{e_1} &amp; \v{e_2} &amp; \v{e_3} \\ \hline
\v{e_1} &amp; 0 &amp; \v{e_{12}} &amp; -\v{e_{31}} \\
\v{e_2} &amp; -\v{e_{12}} &amp; 0 &amp; \v{e_{23}} \\
\v{e_3} &amp; \v{e_{31}} &amp; -\v{e_{23}} &amp; 0 \\
\end{array}\]</p><h3 id="wedge-product-of-non-basis-vectors"><a href="#wedge-product-of-non-basis-vectors">Wedge product of non-basis vectors</a></h3><p>Let us see what happens if we wedge together two arbitrary 3D vectors in the above manner:</p><details><summary>\(\v{v \wedge u} = (v_1u_2 - v_2u_1)\v{e_{12}} + (v_2u_3 - v_3u_2)\v{e_{23}} + (v_3u_1 - v_1u_3)\v{e_{31}}\)</summary><p>Given vectors \(\v{v} = v_1\v{e_1} + v_2\v{e_2} + v_3\v{e_3}\) and \(\v{u} = u_1\v{e_1} + u_2\v{e_2} + u_3\v{e_3}\):</p><p>\[
\begin{align*}
\v{v \wedge u} &amp;= (v_1\v{e_1} + v_2\v{e_2} + v_3\v{e_3}) \wedge (u_1\v{e_1} + u_2\v{e_2} + u_3\v{e_3}) \\
\v{v \wedge u} &amp;= (v_1\v{e_1} \wedge u_1\v{e_1}) + (v_1\v{e_1} \wedge u_2\v{e_2}) + (v_1\v{e_1} \wedge u_3\v{e_3}) \tag{distribute over +}\\
&amp;+ (v_2\v{e_2} \wedge u_1\v{e_1}) + (v_2\v{e_2} \wedge u_2\v{e_2}) + (v_2\v{e_2} \wedge u_3\v{e_3}) \\
&amp;+ (v_3\v{e_3} \wedge u_1\v{e_1}) + (v_3\v{e_3} \wedge u_2\v{e_2}) + (v_3\v{e_3} \wedge u_3\v{e_3}) \\
\v{v \wedge u} &amp;= v_1u_1(\v{e_1 \wedge e_1}) + v_1u_2(\v{e_1 \wedge e_2}) + v_1u_3(\v{e_1 \wedge e_3}) \tag{pull out coefficients}\\
&amp;+ v_2u_1(\v{e_2 \wedge e_1}) + v_2u_2(\v{e_2 \wedge e_2}) + v_2u_3(\v{e_2 \wedge e_3}) \\
&amp;+ v_3u_1(\v{e_3 \wedge e_1}) + v_3u_2(\v{e_3 \wedge e_2}) + v_3u_3(\v{e_3 \wedge e_3}) \\
\v{v \wedge u} &amp;= 0 + v_1u_2\v{e_{12}} - v_1u_3\v{e_{31}} \\
&amp;- v_2u_1\v{e_{12}} + 0 + v_2u_3\v{e_{23}} \\
&amp;+ v_3u_1\v{e_{31}} - v_3u_2\v{e_{23}} + 0 \\
\v{v \wedge u} &amp;= (v_1u_2 - v_2u_1)\v{e_{12}} + (v_2u_3 - v_3u_2)\v{e_{23}} + (v_3u_1 - v_1u_3)\v{e_{31}} \\
\end{align*}
\]</p></details><p>Well now, those coefficients look awfully familiar don’t they? They’re exactly the coefficients of the usual 3D cross-product.<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup> This lines up with our earlier claim that bivectors function as normals: If you look at which coefficients go with which bivector basis elements, you’ll see that the coefficient for \(\v{e_{23}}\) is the same as the coefficient of \(\v{x}\) in the usual 3D cross-product.</p><p>By virtue of “sharing” the equation for 3D vector cross product, we can conclude that the magnitude of the bivector \(\v{v \wedge u}\) is equal to the area of the parallelogram formed by \(\v{v}\) and \(\v{u}\). A neat <a href="https://math.stackexchange.com/questions/1304562/geometric-proof-of-the-cross-product-magnitude#1304618">geometric proof of this (with diagrams) can be found on the mathematics Stack Exchange</a>.
The sign of the area indicates the winding order of the parallelogram, although which direction is positive and which is negative will depend on the handedness of your coordinate system.</p><figure><img src="https://jacquesheunis.com/post/rotors/wedge-winding.webp"/><figcaption></figcaption></figure><p>Like vectors, bivectors can be written as the sum of some basis elements each multiplied by some scalar. It may not come as a surprise then that as with vectors, adding two bivectors together is simply a matter of adding each of the constituent components.</p><p>So we have vector addition and bivector addition. Can we add a vector to a bivector? Yes, but we leave them as separate terms. In the same way that we don’t try to “simplify” \(\v{e_1 + e_2}\), we also don’t try to simplify \(\v{e_1 + e_{12}}\). We just leave them as the sum of these two different entities.
The resulting object is neither a vector nor a bivector, but is a more general object called a “multivector”.
A multivector is just a sum of scalars, vectors, bivectors, trivectors etc.
All scalars, vectors, bivectors etc are also multivectors, except that they only have non-zero coefficients on one “type” of basis element.
So for example you could write the vector \(\v{e_1}\) as the multivector \(\v{e_1} + 0\v{e_{12}}\).</p><p>Multivectors are particularly relevant to the discussion of our second new operation and the protagonist of this post:</p><h3 id="geometric-product"><a href="#geometric-product">Geometric product</a></h3><p>The geometric product is defined for arbitrary multivectors, is associative, and distributes over addition.
Somewhat annoyingly (in an environment involving several types of products), it is denoted with no symbol, as just \(\v{ab}\).
If we have two vectors \(\v{a}\) and \(\v{b}\), we can calculate their geometric product as:</p><p id="eqn:geometric-product-complete" data-equation-number="2">\[\begin{equation}
\v{ab = (a \cdot b) + (a \wedge b)}
\tag{ 2 }
\end{equation} \]</p><p>Where \(\cdot\) is the usual dot product we know from traditional linear algebra. Note that if both inputs are the same then by equation <a href="#eqn:wedge-product-defining"><span data-equation-ref="wedge-product-defining">1</span></a> we get:</p><p id="eqn:geometric-product-samevec" data-equation-number="3">\[\begin{equation}
\v{aa} = \v{a \cdot a}
\tag{ 3 }
\end{equation} \]</p><p>This, and the fact that our basis vectors are all unit-length and perpendicular to one another leads us to: \(\v{e_ie_i} = \v{e_i} \cdot \v{e_i} = 1\) and \(\v{e_ie_j} = 0 + \v{e_i} \wedge \v{e_j} = -\v{e_je_i} ~~~\forall i \neq j\).</p><p>In particular this means that \(\v{e_1e_2} = \v{e_1 \wedge e_2} = \v{e_{12}}\) (and similarly for the other basis bivectors).
Indeed basis bivectors being the wedge product of basis vectors is now revealed to be a special case of being the <em>geometric</em> product of basis vectors.
This leads us to an analogous definition for trivectors: \(\v{e_{123}} = \v{e_1e_2e_3}\).</p><p>At this point we can compute a complete multiplication table for the geometric product with basis elements in 3D:</p><p>\[\begin{array}{c|c:c:c:c:c:c:c:c}
\cdot\wedge &amp; \v{e_1} &amp; \v{e_2} &amp; \v{e_3} &amp; \v{e_{12}} &amp; \v{e_{31}} &amp; \v{e_{23}} &amp; \v{e_{123}} \\ \hline
\v{e_1} &amp; 1 &amp; \v{e_{12}} &amp; -\v{e_{31}} &amp; \v{e_2} &amp; -\v{e_3} &amp; \v{e_{123}} &amp; \v{e_{23}} \\
\v{e_2} &amp; -\v{e_{12}} &amp; 1 &amp; \v{e_{23}} &amp; -\v{e_1} &amp; \v{e_{123}} &amp; \v{e_3} &amp; \v{e_{31}} \\
\v{e_3} &amp; \v{e_{31}} &amp; -\v{e_{23}} &amp; 1 &amp; \v{e_{123}} &amp; \v{e_1} &amp; -\v{e_2} &amp; \v{e_{12}} \\
\v{e_{12}} &amp; -\v{e_2} &amp; \v{e_1} &amp; \v{e_{123}} &amp; -1 &amp; \v{e_{23}} &amp; -\v{e_{31}} &amp; -\v{e_3} \\
\v{e_{31}} &amp; \v{e_3} &amp; \v{e_{123}} &amp; -\v{e_1} &amp; -\v{e_{23}} &amp; -1 &amp; \v{e_{12}} &amp; -\v{e_2} \\
\v{e_{23}} &amp; \v{e_{123}} &amp; -\v{e_3} &amp; \v{e_2} &amp; \v{e_{31}} &amp; -\v{e_{12}} &amp; -1 &amp; -\v{e_1} \\
\v{e_{123}} &amp; \v{e_{23}} &amp; \v{e_{31}} &amp; \v{e_{12}} &amp; -\v{e_3} &amp; -\v{e_2} &amp; -\v{e_1} &amp; -1 \\
\end{array}\]</p><details><summary>Some multiplication table entries derived</summary>
In case it&#39;s not clear how we can arrive at some of the values in the table above, here are some worked examples:
\[
\v{e_1e_3} = \v{e_1 \wedge e_3} = -(\v{e_3 \wedge e_1}) = -\v{e_{31}} \\
\v{e_1e_{12}} = \v{e_1(e_1e_2)} = \v{(e_1e_1)e_2} = 1\v{e_2} = \v{e_2} \\
\v{e_3e_{12}} = \v{e_3e_1e_2} = -\v{e_1e_3e_2} = \v{e_1e_2e_3} = \v{e_{123}} \\
\v{e_{12}e_{12}} = (\v{e_1e_2})(\v{e_1e_2}) = (-\v{e_2e_1})(\v{e_1e_2}) = -\v{e_2}(\v{e_1e_1})\v{e_2} = -\v{e_2e_2} = -1 \\
\v{e_{123}e_{2}} = \v{(e_1e_2e_3)e_2} = -(\v{e_1e_3e_2})\v{e_2} = -\v{e_1e_3}(\v{e_2e_2}) = -\v{e_1e_3} = \v{e_3e_1} = \v{e_{31}}\\
\]</details><p>To compute the geometric product of two arbitrary multivectors, we can break the arguments down into their constituent basis elements and manipulate only those (using the multiplication table above). We need to do this because equations <a href="#eqn:geometric-product-complete"><span data-equation-ref="geometric-product-complete">2</span></a> and <a href="#eqn:geometric-product-samevec"><span data-equation-ref="geometric-product-samevec">3</span></a> above apply only to <em>vectors</em>, and do <em>not</em> apply to bivectors (or trivectors etc).</p><h3 id="inverses-under-the-geometric-product"><a href="#inverses-under-the-geometric-product">Inverses under the geometric product</a></h3><p>Under the geometric product all non-zero vectors \(\v{v}\) have an inverse:</p><p id="eqn:geometric-vector-inverse" data-equation-number="4">\[\begin{equation}
\v{v}^{-1} = \frac{\v{v}}{|\v{v}|^2}
\tag{ 4 }
\end{equation} \]</p><details><summary>Proof: \(\v{v}^{-1} = \frac{\v{v}}{|\v{v}|^2}\)</summary>
Given a vector \(\v{v} \neq 0\) let&#39;s take \(\v{v^\prime} = \frac{\v{v}}{|\v{v}|^2}\), then:
\[\begin{aligned}
\v{vv^\prime} &amp;= \v{v \cdot v^\prime + v \wedge v^\prime} \\
\v{vv^\prime} &amp;= \frac{1}{|\v{v}|^2}(\v{v \cdot v}) + \frac{1}{|\v{v}|^2}(\v{v \wedge v}) \\
\v{vv^\prime} &amp;= \frac{1}{|\v{v}|^2}|\v{v}|^2 + \frac{1}{|\v{v}|^2}0 \\
\v{vv^\prime} &amp;= \frac{|\v{v}|^2}{|\v{v}|^2} \\
\v{vv^\prime} &amp;= 1 \\
\end{aligned}\]

and similarly if we multiply on the left side:
\[\begin{aligned}
\v{v^\prime v} &amp;= \v{v^\prime \cdot v + v^\prime \wedge v} \\
\v{v^\prime v} &amp;= \frac{1}{|\v{v}|^2}(\v{v \cdot v}) + \frac{1}{|\v{v}|^2}(\v{v \wedge v}) \\
\v{v^\prime v} &amp;= \frac{1}{|\v{v}|^2}|\v{v}|^2 + \frac{1}{|\v{v}|^2}0 \\
\v{v^\prime v} &amp;= \frac{|\v{v}|^2}{|\v{v}|^2} \\
\v{v^\prime v} &amp;= 1 \\
\end{aligned}\]

So \(\v{v^\prime} = \frac{\v{v}}{|\v{v}|^2} = \v{v^{-1}}\), the inverse of \(\v{v}\).</details><p>Similarly, the geometric product of two vectors \(\v{a}\) and \(\v{b}\) also has an inverse:</p><p id="eqn:inverse-of-geometric-product" data-equation-number="5">\[\begin{equation}
(\v{ab})^{-1} = \v{b}^{-1}\v{a}^{-1}
\tag{ 5 }
\end{equation} \]</p><details><summary>Proof: \((\v{ab})^{-1} = \v{b}^{-1}\v{a}^{-1}\)</summary>
Given any two vectors \(\v{a}\) and \(\v{b}\) then we can multiply on the right:
\[
(\v{ab})(\v{b}^{-1}\v{a}^{-1}) = \v{a}(\v{bb}^{-1})\v{a}^{-1} = \v{a}(1)\v{a}^{-1} = \v{aa}^{-1} = 1
\]
and on the left:
\[
(\v{b}^{-1}\v{a}^{-1})(\v{ab}) = \v{b}^{-1}(\v{a}^{-1}\v{a})\v{b} = \v{b}^{-1}(1)\v{b} = \v{b}^{-1}\v{b} = 1
\]
and conclude that \(\v{b}^{-1}\v{a}^{-1} = (\v{ab})^{-1}\), the (left and right) inverse of \(\v{ab}\).</details><p>Since every vector has an inverse, for any two vectors \(\v{a}\) and \(\v{b}\) we can write:
\[\begin{aligned}
\v{a} &amp;= \v{a} \\
\v{a} &amp;= \v{abb}^{-1} \\
\v{a} &amp;= \frac{1}{|\v{b}|^2} \v{(ab)b} \\
\v{a} &amp;= \frac{1}{|\v{b}|^2} \v{(a \cdot b + a \wedge b) b} \\
\v{a} &amp;= \frac{\v{a \cdot b}}{|\v{b}|^2} \v{b} + \frac{\v{a \wedge b}}{|\v{b}|^2} \v{b} \\
\end{aligned}\]</p><p>From this we conclude that for two arbitrary (non-zero) vectors \(\v{a}\) and \(\v{b}\), we can write one in terms of components parallel and perpendicular to the other:</p><p id="eqn:vector-parallel-and-perpendicular-split" data-equation-number="6">\[\begin{equation}
\v{a} = \v{a}_{\parallel b} + \v{a}_{\perp b}
\tag{ 6 }
\end{equation} \]</p><p>Where \(\v{a_{\parallel b}}\) is the component of \(\v{a}\) parallel to \(\v{b}\) (the <em>projection</em> of \(\v{a}\) onto \(\v{b}\)) and \(\v{a_{\perp b}}\) is the component of \(\v{a}\) perpendicular to \(\v{b}\) (the <em>rejection</em> of \(\v{a}\) from \(\v{b}\)).
We know from linear algebra that</p><p id="eqn:vector-parallel-component" data-equation-number="7">\[\begin{equation}
\v{a_{\parallel b}} = \frac{\v{a \cdot b}}{|\v{b}|^2}\v{b}
\tag{ 7 }
\end{equation} \]</p><p>Substituting into the calculation above we get \(\v{a} = \v{a_{\parallel b}} + \frac{\v{a \wedge b}}{|\v{b}|^2} \v{b} \) from which we conclude that</p><p id="eqn:vector-perpendicular-component" data-equation-number="8">\[\begin{equation}
\v{a_{\perp b}} = \frac{\v{a \wedge b}}{|\v{b}|^2}\v{b}
\tag{ 8 }
\end{equation} \]</p><h3 id="reflections-with-the-geometric-product"><a href="#reflections-with-the-geometric-product">Reflections with the geometric product</a></h3><p>Recall from linear algebra that given two non-zero vectors \(\v{a}\) and \(\v{v}\), we can write the reflection of \(\v{a}\) over \(\v{v}\) as:</p><p>\[
\v{a^\prime} = \v{a} - 2\v{a_{\perp v}} = \v{a}_{\parallel v} - \v{a}_{\perp v}
\]</p><p>If we substitute equations <a href="#eqn:vector-parallel-component"><span data-equation-ref="vector-parallel-component">7</span></a> and <a href="#eqn:vector-perpendicular-component"><span data-equation-ref="vector-perpendicular-component">8</span></a> we get:</p><p>\[\begin{aligned}
\v{a^\prime} &amp;= \v{a}_{\parallel v} - \v{a}_{\perp v} \\
&amp;= \frac{\v{v \cdot a}}{|\v{a}|^2} \v{a} - \frac{\v{v \wedge a}}{|\v{a}|^2} \v{a} \\
&amp;= (\v{v \cdot a})\frac{\v{a}}{|\v{a}|^2} - (\v{v \wedge a})\frac{\v{a}}{|\v{a}|^2} \\
&amp;= \v{(v \cdot a)a}^{-1} - (\v{v \wedge a})\v{a}^{-1} \\
&amp;= \v{(a \cdot v)a}^{-1} + (\v{a \wedge v})\v{a}^{-1} \\
&amp;= (\v{a \cdot v + a \wedge v})\v{a}^{-1} \\
&amp;= \v{(av)a}^{-1} \\
\v{a^\prime} &amp;= \v{ava}^{-1} \\
\end{aligned}\]</p><p>So we can reflect vectors using only the geometric product. \(\v{ava}^{-1}\) is a form we will see quite often, and is sometimes referred to as a “sandwich product”.</p><p>The first and last lines of the calculation above together demonstrate an important property:
Since \(\v{ava}^{-1} = \v{a}_{\parallel v} - \v{a}_{\perp v}\), we know that \(\v{ava}^{-1}\) is just a vector and contains no scalar, bivector (or trivector etc) components.
This means we can use the output of such a sandwich product as the input to another sandwich product, which we will do shortly.</p><p>For our own convenience, we can also produce an equation for the output of such a sandwich product:</p><details><summary>Equation for 3D sandwich product</summary>
\[\begin{align*}
&amp; \v{ava}^{-1} \\
=~&amp; (\v{av})\v{a}^{-1} \\
=~&amp; |a|^{-2} (\v{av})\v{a} \\
=~&amp; |a|^{-2} (\v{(a \cdot v) + (a \wedge v)})\v{a} \\
=~&amp; |a|^{-2} \lbrack \\
&amp; (a_1v_1 + a_2v_2 + a_3v_3) \\
&amp; + (a_1v_2 - a_2v_1)\v{e_{12}} \\
&amp; + (a_2v_3 - a_3v_2)\v{e_{23}} \\
&amp; + (a_3v_1 - a_1v_3)\v{e_{31}} \\
&amp; \rbrack (a_1 \v{e_1} + a_2 \v{e_2} + a_3 \v{e_3}) \\
=~&amp; |a|^{-2} \lbrack \\
&amp; (a_1v_1 + a_2v_2 + a_3v_3)(a_1 \v{e_1} + a_2 \v{e_2} + a_3 \v{e_3}) \\
&amp; + (a_1v_2 - a_2v_1)\v{e_{12}}(a_1 \v{e_1} + a_2 \v{e_2} + a_3 \v{e_3}) \\
&amp; + (a_2v_3 - a_3v_2)\v{e_{23}}(a_1 \v{e_1} + a_2 \v{e_2} + a_3 \v{e_3}) \\
&amp; + (a_3v_1 - a_1v_3)\v{e_{31}}(a_1 \v{e_1} + a_2 \v{e_2} + a_3 \v{e_3}) \\
\rbrack \\
=~&amp; |a|^{-2} \lbrack \tag{multiply out the brackets on the right} \\
&amp; (a_1v_1 + a_2v_2 + a_3v_3)a_1\v{e_1} + (a_1v_1 + a_2v_2 + a_3v_3)a_2\v{e_2} + (a_1v_1 + a_2v_2 + a_3v_3)a_3\v{e_3} \\
&amp; + (a_1v_2 - a_2v_1)a_1\v{e_{12}}\v{e_1} + (a_1v_2 - a_2v_1)a_2\v{e_{12}}\v{e_2} + (a_1v_2 - a_2v_1)a_3\v{e_{12}}\v{e_3} \\
&amp; + (a_2v_3 - a_3v_2)a_1\v{e_{23}}\v{e_1} + (a_2v_3 - a_3v_2)a_2\v{e_{23}}\v{e_2} + (a_2v_3 - a_3v_2)a_3\v{e_{23}}\v{e_3} \\
&amp; + (a_3v_1 - a_1v_3)a_1\v{e_{31}}\v{e_1} + (a_3v_1 - a_1v_3)a_2\v{e_{31}}\v{e_2} + (a_3v_1 - a_1v_3)a_3\v{e_{31}}\v{e_3} \\
\rbrack \\
=~&amp; |a|^{-2} \lbrack \tag{simplify the basis element products} \\
&amp; (a_1v_1 + a_2v_2 + a_3v_3)a_1\v{e_1} + (a_1v_1 + a_2v_2 + a_3v_3)a_2\v{e_2} + (a_1v_1 + a_2v_2 + a_3v_3)a_3\v{e_3} \\
&amp; - (a_1v_2 - a_2v_1)a_1\v{e_2} + (a_1v_2 - a_2v_1)a_2\v{e_1} + (a_1v_2 - a_2v_1)a_3\v{e_{123}} \\
&amp; + (a_2v_3 - a_3v_2)a_1\v{e_{123}} - (a_2v_3 - a_3v_2)a_2\v{e_3} + (a_2v_3 - a_3v_2)a_3\v{e_2} \\
&amp; + (a_3v_1 - a_1v_3)a_1\v{e_3} + (a_3v_1 - a_1v_3)a_2\v{e_{123}} - (a_3v_1 - a_1v_3)a_3\v{e_1} \\
\rbrack \\
=~&amp; |a|^{-2} \lbrack \tag{multiply out the remaining brackets} \\
&amp; a_1a_1v_1\v{e_1} + a_1a_2v_2\v{e_1} + a_3a_1v_3\v{e_1} \\
&amp; + a_1a_2v_1\v{e_2} + a_2a_2v_2\v{e_2} + a_2a_3v_3\v{e_2} \\
&amp; + a_3a_1v_1\v{e_3} + a_2a_3v_2\v{e_3} + a_3a_3v_3\v{e_3} \\
&amp; - a_1a_1v_2\v{e_2} + a_1a_2v_1\v{e_2} + a_1a_2v_2\v{e_1} - a_2a_2v_1\v{e_1} + a_3a_1v_2\v{e_{123}} - a_2a_3v_1\v{e_{123}} \\
&amp; + a_1a_2v_3\v{e_{123}} - a_3a_1v_2\v{e_{123}} - a_2a_2v_3\v{e_3} + a_2a_3v_2\v{e_3} + a_2a_3v_3\v{e_2} - a_3a_3v_2\v{e_2} \\
&amp; + a_3a_1v_1\v{e_3} - a_1a_1v_3\v{e_3} + a_2a_3v_1\v{e_{123}} - a_1a_2v_3\v{e_{123}} - a_3a_3v_1\v{e_1} + a_3a_1v_3\v{e_1} \\
\rbrack \\
=~&amp; |a|^{-2} \lbrack \tag{group by basis vector} \\
&amp; a_1a_1v_1\v{e_1} + a_1a_2v_2\v{e_1} + a_3a_1v_3\v{e_1} + a_1a_2v_2\v{e_1} - a_2a_2v_1\v{e_1} - a_3a_3v_1\v{e_1} + a_3a_1v_3\v{e_1} \\
&amp; + a_1a_2v_1\v{e_2} + a_2a_2v_2\v{e_2} + a_2a_3v_3\v{e_2} - a_1a_1v_2\v{e_2} + a_1a_2v_1\v{e_2} + a_2a_3v_3\v{e_2} - a_3a_3v_2\v{e_2} \\
&amp; + a_3a_1v_1\v{e_3} + a_2a_3v_2\v{e_3} + a_3a_3v_3\v{e_3} - a_2a_2v_3\v{e_3} + a_2a_3v_2\v{e_3} + a_3a_1v_1\v{e_3} - a_1a_1v_3\v{e_3} \\
&amp; + a_3a_1v_2\v{e_{123}} - a_2a_3v_1\v{e_{123}} + a_1a_2v_3\v{e_{123}} - a_3a_1v_2\v{e_{123}} + a_2a_3v_1\v{e_{123}} - a_1a_2v_3\v{e_{123}} \\
\rbrack \\
=~&amp; |a|^{-2} \lbrack \tag{pull out the basis element factors} \\
&amp; (a_1a_1v_1 + a_1a_2v_2 + a_3a_1v_3 + a_1a_2v_2 - a_2a_2v_1 - a_3a_3v_1 + a_3a_1v_3)\v{e_1} \\
&amp; + (a_1a_2v_1 + a_2a_2v_2 + a_2a_3v_3 - a_1a_1v_2 + a_1a_2v_1 + a_2a_3v_3 - a_3a_3v_2)\v{e_2} \\
&amp; + (a_3a_1v_1 + a_2a_3v_2 + a_3a_3v_3 - a_2a_2v_3 + a_2a_3v_2 + a_3a_1v_1 - a_1a_1v_3)\v{e_3} \\
&amp; + (a_3a_1v_2 - a_2a_3v_1 + a_1a_2v_3 - a_3a_1v_2 + a_2a_3v_1 - a_1a_2v_3)\v{e_{123}} \\
\rbrack \\
=~&amp; |a|^{-2} \lbrack \tag{simplify coefficients} \\
&amp; (a_1a_1v_1 - a_2a_2v_1 - a_3a_3v_1 + 2a_1a_2v_2 + 2a_3a_1v_3)\v{e_1} \\
&amp; + (2a_1a_2v_1 - a_1a_1v_2 + a_2a_2v_2 - a_3a_3v_2 + 2a_2a_3v_3)\v{e_2} \\
&amp; + (2a_3a_1v_1 + 2a_2a_3v_2 - a_2a_2v_3 - a_1a_1v_3 + a_3a_3v_3)\v{e_3} \\
&amp; + 0\v{e_{123}} \\
\rbrack \\
=~&amp; |a|^{-2} \lbrack (a_1^2v_1 - a_2^2v_1 - a_3^2v_1 + 2a_1a_2v_2 + 2a_3a_1v_3)\v{e_1} \\
&amp; + (2a_1a_2v_1 - a_1^2v_2 + a_2^2v_2 - a_3^2v_2 + 2a_2a_3v_3)\v{e_2} \\
&amp; + (2a_3a_1v_1 + 2a_2a_3v_2 - a_2^2v_3 - a_1^2v_3 + a_3^2v_3)\v{e_3} \rbrack \\
\end{align*}\]
That&#39;s a bit of a mouthful, but if we name the coefficients of each basis vector:<p id="eqn:sandwich-product-e1" data-equation-number="9">\[\begin{equation}
\rho_1 = a_1^2v_1 - a_2^2v_1 - a_3^2v_1 + 2a_1a_2v_2 + 2a_3a_1v_3
\tag{ 9 }
\end{equation} \]</p><p id="eqn:sandwich-product-e2" data-equation-number="10">\[\begin{equation}
\rho_2 = 2a_1a_2v_1 - a_1^2v_2 + a_2^2v_2 - a_3^2v_2 + 2a_2a_3v_3
\tag{ 10 }
\end{equation} \]</p><p id="eqn:sandwich-product-e3" data-equation-number="11">\[\begin{equation}
\rho_3 = 2a_3a_1v_1 + 2a_2a_3v_2 - a_2^2v_3 - a_1^2v_3 + a_3^2v_3
\tag{ 11 }
\end{equation} \]</p>then we&#39;re left with<p id="eqn:sandwich-product" data-equation-number="12">\[\begin{equation}
\v{ava}^{-1} = \frac{1}{|a|^2} (\rho_1 \v{e_1} + \rho_2 \v{e_2} + \rho_3 \v{e_3})
\tag{ 12 }
\end{equation} \]</p></details><h3 id="rotors-as-a-combination-of-two-reflections"><a href="#rotors-as-a-combination-of-two-reflections">Rotors as a combination of two reflections</a></h3><p>Now that we can safely achieve reflection of one vector over another by way of a geometric sandwich product, rotations are right around the corner: We just reflect <em>twice</em>.</p><p>Let \(\v{v}\) be our input vector (the one we’d like to rotate) and say we’d like to reflect over the vectors \(\v{a}\) and then \(\v{b}\). This is just a pair of sandwich products: \(\v{v}^{\prime\prime} = \v{bv}^\prime\v{b}^{-1} = \v{bava}^{-1}\v{b}^{-1}\).
If we let \(\v{R = ba}\) then by equation <a href="#eqn:inverse-of-geometric-product"><span data-equation-ref="inverse-of-geometric-product">5</span></a> this can be conveniently written as: \(\v{v}^{\prime\prime} = \v{RvR}^{-1}\) and \(\v{R}\) is our rotor.</p><p>To see how this works, consider the following example and corresponding diagrams:</p><details><summary>Rotation calculation example</summary><p>Let \(\v{R = ba}\) with \(\v{a} = (\frac{\sqrt{3}}{2}, \frac{1}{2}, 0)\) (which is \((1,0,0)\) rotated 30 degrees counter-clockwise around the Z-axis) and \(\v{b} = (\frac{1 - \sqrt{3}}{2\sqrt{2}}, \frac{1 + \sqrt{3}}{2\sqrt{2}}, 0)\) (which is \((1,0,0)\) rotated 105 degrees counter-clockwise around the Z-axis). We’re rotating around the Z-axis because in the diagrams, positive Z is up.</p><p>Let \(\v{v} = (1,0,1)\).</p><p>Our rotated vector is therefore \(\v{v}^{\prime\prime} = \v{bv}^\prime\v{b}^{-1} = \v{b}(\v{ava}^{-1})\v{b}^{-1}\).</p><p>Let’s start with \(\v{v}^\prime\), and apply equations <a href="#eqn:sandwich-product-e1"><span data-equation-ref="sandwich-product-e1">9</span></a>, <a href="#eqn:sandwich-product-e2"><span data-equation-ref="sandwich-product-e2">10</span></a>, <a href="#eqn:sandwich-product-e3"><span data-equation-ref="sandwich-product-e3">11</span></a>:</p><p>\[\begin{aligned}
\rho_{a,1} &amp;= a_1^2v_1 - a_2^2v_1 - a_3^2v_1 + 2a_1a_2v_2 + 2a_3a_1v_3 \\
\rho_{a,1} &amp;= \left(\frac{\sqrt{3}}{2}\right)^2(1) - \left(\frac{1}{2}\right)^2(1) - (0)^2(1) + 2\left(\frac{\sqrt{3}}{2}\right)\left(\frac{1}{2}\right)(0) + 2(0)\left(\frac{\sqrt{3}}{2}\right)(1) \\
\rho_{a,1} &amp;= \left(\frac{\sqrt{3}}{2}\right)^2 - \left(\frac{1}{2}\right)^2 \\
\rho_{a,1} &amp;= \frac{3}{4} - \frac{1}{4} = \frac{1}{2}\\
\\
\rho_{a,2} &amp;= 2a_1a_2v_1 - a_1^2v_2 + a_2^2v_2 - a_3^2v_2 + 2a_2a_3v_3 \\
\rho_{a,2} &amp;= 2\left(\frac{\sqrt{3}}{2}\right)\left(\frac{1}{2}\right)(1) - \left(\frac{\sqrt{3}}{2}\right)^2(0) + \left(\frac{1}{2}\right)^2(0) - (0)^2(0) + 2\left(\frac{1}{2}\right)(0)(1) \\
\rho_{a,2} &amp;= 2\left(\frac{\sqrt{3}}{2}\right)\left(\frac{1}{2}\right) \\
\rho_{a,2} &amp;= \frac{\sqrt{3}}{2} \\
\\
\rho_{a,3} &amp;= 2a_3a_1v_1 + 2a_2a_3v_2 - a_2^2v_3 - a_1^2v_3 + a_3^2v_3 \\
\rho_{a,3} &amp;= 2(0)\left(\frac{\sqrt{3}}{2}\right)(1) + 2\left(\frac{1}{2}\right)(0)(0) - \left(\frac{1}{2}\right)^2(1) - \left(\frac{\sqrt{3}}{2}\right)^2(1) + (0)^2(1) \\
\rho_{a,3} &amp;= -\frac{1}{4} - \frac{3}{4} \\
\rho_{a,3} &amp;= -1 \\
\end{aligned}\]</p><p>With this done, equation <a href="#eqn:sandwich-product"><span data-equation-ref="sandwich-product">12</span></a> gets us to:
\[\begin{aligned}
\v{ava}^{-1} &amp;= \frac{1}{|a|^2} (\rho_1 \v{e_1} + \rho_2 \v{e_2} + \rho_3 \v{e_3}) \\
&amp;= (1) \left(\frac{1}{2} \v{e_1} + \frac{\sqrt{3}}{2} \v{e_2} + (-1) \v{e_3}\right) \\
\v{ava}^{-1} = \v{v}^\prime &amp;= \frac{1}{2} \v{e_1} + \frac{\sqrt{3}}{2} \v{e_2} - \v{e_3} \\
\end{aligned}\]</p><p>Moving to our second reflection, we repeat the same process (although this time with rather more inconvenient numbers):
\[\begin{aligned}
\rho_{b,1} &amp;= b_1^2v^\prime_1 - b_2^2v^\prime_1 - b_3^2v^\prime_1 + 2b_1b_2v^\prime_2 + 2b_3b_1v^\prime_3 \\
\rho_{b,1} &amp;= \left(\frac{1-\sqrt{3}}{2\sqrt{2}}\right)^2\left(\frac{1}{2}\right) - \left(\frac{1+\sqrt{3}}{2\sqrt{2}}\right)^2\left(\frac{1}{2}\right) - (0)^2\left(\frac{1}{2}\right) \\
&amp; + 2\left(\frac{1-\sqrt{3}}{2\sqrt{2}}\right)\left(\frac{1+\sqrt{3}}{2\sqrt{2}}\right)\left(\frac{\sqrt{3}}{2}\right) + 2(0)\left(\frac{1-\sqrt{3}}{2\sqrt{2}}\right)(-1) \\
\rho_{b,1} &amp;= \left(\frac{1-\sqrt{3}}{2\sqrt{2}}\right)^2\left(\frac{1}{2}\right) - \left(\frac{1+\sqrt{3}}{2\sqrt{2}}\right)^2\left(\frac{1}{2}\right) + 2\left(\frac{1-\sqrt{3}}{2\sqrt{2}}\right)\left(\frac{1+\sqrt{3}}{2\sqrt{2}}\right)\left(\frac{\sqrt{3}}{2}\right) \\
\rho_{b,1} &amp;= \frac{(1-\sqrt{3})^2}{16} - \frac{(1+\sqrt{3})^2}{16} + \frac{\sqrt{3}(1-\sqrt{3})(1+\sqrt{3})}{8} \\
\rho_{b,1} &amp;= \frac{(4 - 2\sqrt{3}) - (4 + 2\sqrt{3})}{16} + \frac{\sqrt{3}(-2)}{8} \\
\rho_{b,1} &amp;= \frac{-4\sqrt{3}}{16} - \frac{\sqrt{3}}{4} \\
\rho_{b,1} &amp;= -\frac{\sqrt{3}}{2} \\
\\
\rho_{b,2} &amp;= 2b_1b_2v^\prime_1 - b_1^2v^\prime_2 + b_2^2v^\prime_2 - b_3^2v^\prime_2 + 2b_2b_3v^\prime_3 \\
\rho_{b,2} &amp;= 2\left(\frac{1-\sqrt{3}}{2\sqrt{2}}\right)\left(\frac{1+\sqrt{3}}{2\sqrt{2}}\right)\left(\frac{1}{2}\right) - \left(\frac{1-\sqrt{3}}{2\sqrt{2}}\right)^2\left(\frac{\sqrt{3}}{2}\right) + \left(\frac{1+\sqrt{3}}{2\sqrt{2}}\right)^2\left(\frac{\sqrt{3}}{2}\right) \\
&amp; - (0)^2\left(\frac{\sqrt{3}}{2}\right) + 2\left(\frac{1+\sqrt{3}}{2\sqrt{2}}\right)(0)(-1) \\
\rho_{b,2} &amp;= 2\left(\frac{1-\sqrt{3}}{2\sqrt{2}}\right)\left(\frac{1+\sqrt{3}}{2\sqrt{2}}\right)\left(\frac{1}{2}\right) - \left(\frac{1-\sqrt{3}}{2\sqrt{2}}\right)^2\left(\frac{\sqrt{3}}{2}\right) + \left(\frac{1+\sqrt{3}}{2\sqrt{2}}\right)^2\left(\frac{\sqrt{3}}{2}\right) \\
\rho_{b,2} &amp;= \frac{(1-\sqrt{3})(1+\sqrt{3})}{8} - \frac{\sqrt{3}(1-\sqrt{3})^2}{16} + \frac{\sqrt{3}(1+\sqrt{3})^2}{16} \\
\rho_{b,2} &amp;= \frac{-2}{8} - \frac{\sqrt{3}(4 - 2\sqrt{3})}{16} + \frac{\sqrt{3}(4 + 2\sqrt{3})}{16} \\
\rho_{b,2} &amp;= -\frac{1}{4} - \frac{\sqrt{3}(- 4\sqrt{3}))}{16} \\
\rho_{b,2} &amp;= -\frac{1}{4} + \frac{12}{16} \\
\rho_{b,2} &amp;= \frac{1}{2} \\
\\
\rho_{b,3} &amp;= 2b_3b_1v^\prime_1 + 2b_2b_3v^\prime_2 - b_2^2v^\prime_3 - b_1^2v^\prime_3 + b_3^2v^\prime_3 \\
\rho_{b,3} &amp;= 2(0)\left(\frac{1-\sqrt{3}}{2\sqrt{2}}\right)\left(\frac{1}{2}\right) + 2\left(\frac{1+\sqrt{3}}{2\sqrt{2}}\right)(0)\left(\frac{\sqrt{3}}{2}\right) - \left(\frac{1+\sqrt{3}}{2\sqrt{2}}\right)^2(-1) \\
&amp; - \left(\frac{1-\sqrt{3}}{2\sqrt{2}}\right)^2(-1) + (0)^2(-1) \\
\rho_{b,3} &amp;= - \left(\frac{1+\sqrt{3}}{2\sqrt{2}}\right)^2(-1) - \left(\frac{1-\sqrt{3}}{2\sqrt{2}}\right)^2(-1) \\
\rho_{b,3} &amp;= \frac{(1+\sqrt{3})^2}{8} + \frac{(1-\sqrt{3})^2}{8} \\
\rho_{b,3} &amp;= \frac{4 + 2\sqrt{3}}{8} + \frac{4 - 2\sqrt{3}}{8} \\
\rho_{b,3} &amp;= \frac{(4 + 2\sqrt{3}) + (4 - 2\sqrt{3})}{8} \\
\rho_{b,3} &amp;= 1 \\
\end{aligned}\]</p><p>Leading us finally to:</p><p>\[
\v{v}^{\prime\prime} = \v{bava}^{-1}\v{b}^{-1} = \v{bv}^\prime\v{b}^{-1} = \frac{-\sqrt{3}}{2}\v{e_1} + \frac{1}{2}\v{e_2} + \v{e_3}
\]</p><p>Of course usually you wouldn’t do it this way, you’d have \(\v{ba}\) precomputed (since that’s the rotor) and you’d just sandwich \(\v{v}\) with that. The calculation can also be simplified significantly because you know that the coefficient of \(\v{e_{123}}\) turns out to be zero. An example of this is given in the practical section below.</p></details><figure><img src="https://jacquesheunis.com/post/rotors/rotation_from_reflection_1.webp"/>
<img src="https://jacquesheunis.com/post/rotors/rotation_from_reflection_2.webp"/><figcaption>Reflection of \(\v{v}\) across \(\v{a}\) and \(\v{b}\) to produce \(\v{v}^{\prime\prime}\), shown in 3D (left) and a 2D top-down view (right).</figcaption></figure><p>You can see in the 2D diagram on the right, how each reflection inverts the angle between the input vector and the vector it’s being reflected across. In doing so twice, we have produced a total rotation by twice the angle between the two reflection vectors.</p><p>If you were to look <em>only</em> at the 2D diagram on the right however, you might be thinking that we only needed a single reflection.
You could indeed get from one point on the circle to any other point on the circle by reflecting over just one appropriately selected vector but this wouldn’t actually be a rotation.
The 3D diagram on the left demonstrates one of the reasons why this is not sufficient: We’d end up on the wrong side of the plane of reflection.
Having two reflections allows us to “rotate” part of the way with the first reflection, flipping over to the other side of the plane of rotation, and the second rotation “rotates” us the rest of the way around while getting us back across the plane of rotation to our intended rotated vector.</p><p>Does that mean that a single vector would be sufficient in 2D? Well no we still need two, because there’s another problem: Reflection is simply not the same transformation as rotation and will, well…reflect…the relative positions of the vectors it’s applied to. Here’s the same example, but with two extra initial vectors, offset slightly from \(\v{v}\):</p><figure><img src="https://jacquesheunis.com/post/rotors/single_reflection_wrong_ordering.webp"/><figcaption>The same transformation applied to \(\v{v}\) and two vectors offset slightly from it</figcaption></figure><p>You can see how our 3 input vectors are in the wrong “order” (if you imagine going around the circle) after the first reflection, but that is fixed by the second reflection.</p><p>I confess that this is a slightly hand-wavey geometric justification that leans on one’s intuition for what reflections and rotations should look like. For the stout of heart, Jaap Suter provides <a href="https://www.jaapsuter.com/geometric-algebra.pdf">a more rigorous algebraic derivation</a>.</p><h3 id="the-identity-rotor"><a href="#the-identity-rotor">The identity rotor</a></h3><p>When using rotors for rotation, you are likely to very quickly run into a situation where you want a “no-op” rotation. A rotation which transforms any input vector into itself. You want an identity rotor.</p><p>Any rotor that contains only a scalar component is an identity rotor.
To see this, recall that we constructed our rotors as the geometric product of two vectors (\(\v{R} = \v{ba}\)).
The rotor \(\v{R}\) produces a rotation by twice the angle between \(\v{a}\) and \(\v{b}\).
If that angle is zero then twice that angle is still zero and the rotor will produce no rotation.
If the angle between the two vectors is zero then we can express one of those vectors as a scalar multiple of the other (\(\v{b} = s\v{a}\) for \(\v{s \in \mathbb{R}}\)). Applying equation <a href="#eqn:geometric-product-complete"><span data-equation-ref="geometric-product-complete">2</span></a> then gives
\[\begin{aligned}
\v{R} &amp;= \v{b \cdot a + b \wedge a} \\
&amp;=(s\v{a}) \cdot \v{a} + (s\v{a}) \wedge \v{a} \\
&amp;=s(\v{a} \cdot \v{a}) + s(\v{a} \wedge \v{a}) \\
&amp;=s|a|^2 + s(0) \\
&amp;=s|a|^2
\end{aligned}\]</p><p>Since we’ve placed no restrictions on \(s\) or \(\v{a}\), we may choose \(\v{a} = (1, 0, 0) \implies |a| = 1 \implies \v{R} = 1\).</p><h3 id="axis-angle-representation-for-rotors"><a href="#axis-angle-representation-for-rotors">Axis-angle representation for rotors</a></h3><p>Recall from regular vector algebra that \(\v{a \cdot b} = |a| |b| cos\theta\) and \(|\v{a \times b}| = |\v{a \wedge b}| = |a| |b| sin\theta\).
With this we can modify equation <a href="#eqn:geometric-product-complete"><span data-equation-ref="geometric-product-complete">2</span></a> to get an “axis-angle-like” representation:</p><p>\[\begin{aligned}
\v{R} &amp;= \v{ba} \\
&amp;= \v{b \cdot a + b \wedge a} \\
&amp;= \v{b \cdot a} + |b \wedge a| \left(\frac{\v{b \wedge a}}{|b \wedge a|}\right) \\
&amp;= |b||a|cos\theta + |b||a|sin\theta \left(\frac{\v{b \wedge a}}{|b \wedge a|}\right) \\
\end{aligned}\]</p><p>If we consider just the case where \(\v{a}\) and \(\v{b}\) are unit vectors separated by an angle \(\theta\) then \(|b||a| = 1\) and we can change variables to \(\v{n} = \frac{\v{b \wedge a}}{|b \wedge a|}\) the unit bivector “plane” spanning \(\v{a}\) and \(\v{b}\), to get:</p><p>\[
\v{R} = cos\theta + sin\theta \v{n}
\]</p><p>Finally, recall that the rotor will produce a rotation equal to <em>twice</em> the angle between its constituent vectors and so we should actually use only half of the input angle:</p><p id="eqn:rotor-axis-angle" data-equation-number="13">\[\begin{equation}
\v{R} = cos\left(\frac{\theta}{2}\right) + sin\left(\frac{\theta}{2}\right) \v{n}
\tag{ 13 }
\end{equation} \]</p><p>Which <em>direction</em> this rotation goes in (clockwise or counter-clockwise) depends on the handedness of your coordinate system, as seen in the example below:</p><details><summary>Example axis-angle calculations</summary><p>Let’s take equation <a href="#eqn:rotor-axis-angle"><span data-equation-ref="rotor-axis-angle">13</span></a> and substitute \(\theta = 60\) degrees and \(\v{n} = (0,0,1)\) gives us:</p><p>\[
\v{R} = \frac{\sqrt{3}}{2} + \frac{1}{2}\v{e_{12}}
\]</p><p>and if we use this to rotate the vector \(\v{v} = (1, 0, 0)\) we get:</p><p>\[\begin{aligned}
\v{v^\prime} &amp;= \v{RvR^{-1}} \\
&amp;= \left(\frac{\sqrt{3}}{2} + \frac{1}{2}\v{e_{12}}\right)\v{e_1}\left(\frac{\sqrt{3}}{2} - \frac{1}{2}\v{e_{12}}\right) \\
&amp;= \left(\frac{1}{4}\right)(\sqrt{3} + \v{e_{12}})\v{e_1}(\sqrt{3} - \v{e_{12}}) \\
&amp;= \left(\frac{1}{4}\right)[(\sqrt{3} + \v{e_{12}})\v{e_1}](\sqrt{3} - \v{e_{12}}) \\
&amp;= \left(\frac{1}{4}\right)(\sqrt{3}\v{e_1} + \v{e_{12}}\v{e_1})(\sqrt{3} - \v{e_{12}}) \\
&amp;= \left(\frac{1}{4}\right)(\sqrt{3}\v{e_1} - \v{e_{2}})(\sqrt{3} - \v{e_{12}}) \\
&amp;= \left(\frac{1}{4}\right)[\sqrt{3}\v{e_1}(\sqrt{3} - \v{e_{12}}) - \v{e_{2}}(\sqrt{3} - \v{e_{12}})] \\
&amp;= \left(\frac{1}{4}\right)[(\sqrt{3}\v{e_1}\sqrt{3}) - (\sqrt{3}\v{e_1}\v{e_{12}}) - (\v{e_{2}}\sqrt{3}) + (\v{e_{2}}\v{e_{12}})] \\
&amp;= \left(\frac{1}{4}\right)[3\v{e_1} - \sqrt{3}\v{e_2} - \sqrt{3}\v{e_{2}} - \v{e_{1}}] \\
&amp;= \left(\frac{1}{4}\right)[2\v{e_1} - 2\sqrt{3}\v{e_2}] \\
&amp;= \left(\frac{1}{2}\right)[\v{e_1} - \sqrt{3}\v{e_2}] \\
&amp;= \frac{1}{2}\v{e_1} - \frac{\sqrt{3}}{2}\v{e_2} \\
&amp;= \left(\frac{1}{2}, -\frac{\sqrt{3}}{2}, 0\right) \\
\end{aligned}\]</p><p>Which is indeed \(v\) rotated 60 degrees around the \(z\)-axis. Notice how we did not need to know (or decide) the handedness of our coordinate system in order to compute this. The calculation is the same, it just looks different when you draw/render it.</p></details><figure><img src="https://jacquesheunis.com/post/rotors/axis_angle_lefthanded.webp"/>
<img src="https://jacquesheunis.com/post/rotors/axis_angle_righthanded.webp"/><figcaption>The same rotation (from the calculation above), shown in left-handed (left) and right-handed (right) coordinate systems</figcaption></figure><p>If you want to claim that a rotation is clockwise or counter-clockwise you need to give a reference viewpoint. If your reference is “looking along the axis” then the rotation in left-handed coordinates is going clockwise, while in the right-handed coordinates it’s counter-clockwise.</p><h2 id="applications-putting-rotors-to-work"><a href="#applications-putting-rotors-to-work">Applications: Putting rotors to work</a></h2><p>Now that we’ve seen the theory of rotors, let’s turn our attention to more practical concerns.
Below is a small collections of answers to questions I encountered myself when implementing rotors, with C++ code for reference.</p><h3 id="how-do-i-store-a-rotor-in-memory"><a href="#how-do-i-store-a-rotor-in-memory">How do I store a rotor in memory?</a></h3><p>A rotor is just the geometric product of the two vectors that form the plane of rotation. In 3D it contains a scalar component and 3 bivector components. So we just store it as a tuple of 4 numbers (as we would a 4D vector used in the usual homogeneous coordinates setup)</p><div><pre tabindex="0"><code data-lang="C"><span><span><span>struct</span> rotor3
</span></span><span><span>{
</span></span><span><span>    <span>float</span> scalar;
</span></span><span><span>    <span>float</span> xy;
</span></span><span><span>    <span>float</span> yz;
</span></span><span><span>    <span>float</span> zx;
</span></span><span><span>};
</span></span></code></pre></div><h3 id="how-do-i-represent-an-orientation-as-opposed-to-a-rotation"><a href="#how-do-i-represent-an-orientation-as-opposed-to-a-rotation">How do I represent an &lt;em&gt;orientation&lt;/em&gt; (as opposed to a &lt;em&gt;rotation&lt;/em&gt;)?</a></h3><p>Rotors (like quaternions) encode <em>rotations</em>. Transforms that, when applied to an orientation, produce a new orientation. There is no such thing as “a rotor pointing along the X-axis”, for example. This is great when we have something with a particular orientation (e.g a player character facing down the X axis) and want to transform it to some other orientation (e.g you want your player character to instead face down the Z axis), but doesn’t immediately help us encode “the player character is facing down the X axis” in the first place.</p><p>Thankfully we can select a convention for a “default” orientation (“facing down the X axis” for example) and then encode all orientations as rotations away from that default orientation.</p><h3 id="how-do-i-produce-a-rotor-representing-a-rotation-from-orientation-a-to-orientation-b"><a href="#how-do-i-produce-a-rotor-representing-a-rotation-from-orientation-a-to-orientation-b">How do I produce a rotor representing a rotation from orientation A to orientation B?</a></h3><p>Let’s represent an orientation as a unit vector along the “forward” direction of the orientation. Now we have two vectors representing the initial and final orientations and we want to rotate from the initial vector to the final vector.</p><p>We could create a rotor just from those two vectors directly, but while that would produce a rotation in the correct plane in the correct direction, it would rotate twice as far as we’d like (since the rotation you get by applying a rotor to a vector is twice the angle between the two vectors that defined the rotor). The naive approach would be to compute the angle between our two vectors and then use an existing axis-angle rotation function to produce a “half-way” vector and then construct our rotor from that:</p><div><pre tabindex="0"><code data-lang="C"><span><span>vec3 <span>axis_angle_rotate</span>(vec3 axis, <span>float</span> angle, vec3 vector_to_rotate);
</span></span><span><span>
</span></span><span><span>rotor3 <span>from_to_naive</span>(vec3 from_dir, vec3 to_dir)
</span></span><span><span>{
</span></span><span><span>    <span>// Calculations below assume the input directions are normalised
</span></span></span><span><span><span></span>    from_dir <span>=</span> from_dir.normalized();
</span></span><span><span>    to_dir <span>=</span> to_dir.normalized();
</span></span><span><span>
</span></span><span><span>    <span>// Get the angle between the input directions
</span></span></span><span><span><span></span>    <span>const</span> <span>float</span> theta <span>=</span> acosf(dot(from_dir, to_dir));
</span></span><span><span>
</span></span><span><span>    <span>// Get the axis of rotation/normal of the plane of rotation
</span></span></span><span><span><span></span>    <span>const</span> vec3 axis <span>=</span> cross(from_dir, to_dir).normalized();
</span></span><span><span>
</span></span><span><span>    <span>// Compute the second vector for our rotor, half way between from_dir and to_dir
</span></span></span><span><span><span></span>    <span>const</span> vec3 halfway <span>=</span> axis_angle_rotate(axis, theta<span>*</span><span>0.5f</span>, from_dir);
</span></span><span><span>
</span></span><span><span>    <span>const</span> vec3 wedge <span>=</span> {
</span></span><span><span>        (halfway.x <span>*</span> from_dir.y) <span>-</span> (halfway.y <span>*</span> from_dir.x),
</span></span><span><span>        (halfway.y <span>*</span> from_dir.z) <span>-</span> (halfway.z <span>*</span> from_dir.y),
</span></span><span><span>        (halfway.z <span>*</span> from_dir.x) <span>-</span> (halfway.x <span>*</span> from_dir.z),
</span></span><span><span>    };
</span></span><span><span>    rotor3 result <span>=</span> {};
</span></span><span><span>    result.scalar <span>=</span> dot(from_dir, halfway);
</span></span><span><span>    result.xy <span>=</span> wedge.x;
</span></span><span><span>    result.yz <span>=</span> wedge.y;
</span></span><span><span>    result.zx <span>=</span> wedge.z;
</span></span><span><span>    <span>return</span> result;
</span></span><span><span>}
</span></span></code></pre></div><p>Of course this assumes the existence of an <code>axis_angle_rotate()</code> function, but thankfully equation <a href="#eqn:rotor-axis-angle"><span data-equation-ref="rotor-axis-angle">13</span></a> provides exactly that.
If we normalise the from- and to-vectors and denote the resulting directions as \(\v{a}\) and \(\v{b}\) respectively then we can get the angle between them as \(\theta = cos^{-1}(\v{a \cdot b})\) and our from-to rotor is:</p><p id="eqn:rotor-from-to" data-equation-number="14">\[\begin{equation}
\v{R} = cos\left(\frac{\theta}{2}\right) + sin\left(\frac{\theta}{2}\right)\left(\frac{\v{b \wedge a}}{|b \wedge a|}\right)
\tag{ 14 }
\end{equation} \]</p><div><pre tabindex="0"><code data-lang="C"><span><span>rotor3 <span>from_to_rotor</span>(vec3 from_dir, vec3 to_dir)
</span></span><span><span>{
</span></span><span><span>    <span>// Calculations below assume the input directions are normalised
</span></span></span><span><span><span></span>    from_dir <span>=</span> from_dir.normalized();
</span></span><span><span>    to_dir <span>=</span> to_dir.normalized();
</span></span><span><span>
</span></span><span><span>    <span>// Get the angle between the input directions
</span></span></span><span><span><span></span>    <span>const</span> <span>float</span> theta <span>=</span> acosf(dot(from_dir, to_dir));
</span></span><span><span>    <span>const</span> <span>float</span> cos_half_theta <span>=</span> cosf(theta <span>*</span> <span>0.5f</span>);
</span></span><span><span>    <span>const</span> <span>float</span> sin_half_theta <span>=</span> sinf(theta <span>*</span> <span>0.5f</span>);
</span></span><span><span>
</span></span><span><span>    <span>// Compute the normalized &#34;to_dir wedge from_dir&#34; product
</span></span></span><span><span><span></span>    <span>const</span> vec3 wedge <span>=</span> vec3 {
</span></span><span><span>        (to_dir.x <span>*</span> from_dir.y) <span>-</span> (to_dir.y <span>*</span> from_dir.x),
</span></span><span><span>        (to_dir.y <span>*</span> from_dir.z) <span>-</span> (to_dir.z <span>*</span> from_dir.y),
</span></span><span><span>        (to_dir.z <span>*</span> from_dir.x) <span>-</span> (to_dir.x <span>*</span> from_dir.z),
</span></span><span><span>    }.normalized();
</span></span><span><span>
</span></span><span><span>    rotor3 result <span>=</span> {};
</span></span><span><span>    result.scalar <span>=</span> cos_half_theta;
</span></span><span><span>    result.xy <span>=</span> sin_half_theta <span>*</span> wedge.x;
</span></span><span><span>    result.yz <span>=</span> sin_half_theta <span>*</span> wedge.y;
</span></span><span><span>    result.zx <span>=</span> sin_half_theta <span>*</span> wedge.z;
</span></span><span><span>    <span>return</span> result;
</span></span><span><span>}
</span></span></code></pre></div><p>This will be correct but requires us to do a bunch of trigonometry and if we could achieve the same thing without trigonometry then that might be faster (but as with all performance-motivated changes, you should measure it).</p><p>Recall that a rotor defined as the product of two vectors will produce a rotation from one toward the other. The problem is that it will produce a rotation by <em>twice</em> the angle between the input vectors, so it will “rotate past” our destination vector if we just used the product of our input vectors.
Naturally then, we could swap out one of the arguments for a vector that is half-way between <code>from</code> and <code>to</code> such that twice the rotation will be precisely what we’re looking for!</p><div><pre tabindex="0"><code data-lang="C"><span><span>rotor3 <span>from_to_rotor_notrig</span>(vec3 from_dir, vec3 to_dir)
</span></span><span><span>{
</span></span><span><span>    from_dir <span>=</span> from_dir.normalized();
</span></span><span><span>    to_dir <span>=</span> to_dir.normalized();
</span></span><span><span>
</span></span><span><span>    <span>const</span> vec3 halfway <span>=</span> (from_dir <span>+</span> to_dir).normalized();
</span></span><span><span>
</span></span><span><span>    <span>const</span> vec3 wedge <span>=</span> {
</span></span><span><span>        (halfway.x <span>*</span> from_dir.y) <span>-</span> (halfway.y <span>*</span> from_dir.x),
</span></span><span><span>        (halfway.y <span>*</span> from_dir.z) <span>-</span> (halfway.z <span>*</span> from_dir.y),
</span></span><span><span>        (halfway.z <span>*</span> from_dir.x) <span>-</span> (halfway.x <span>*</span> from_dir.z),
</span></span><span><span>    };
</span></span><span><span>    Rotor3 result <span>=</span> {};
</span></span><span><span>    result.scalar <span>=</span> from_dir.dot(halfway);
</span></span><span><span>    result.xy <span>=</span> wedge.x;
</span></span><span><span>    result.yz <span>=</span> wedge.y;
</span></span><span><span>    result.zx <span>=</span> wedge.z;
</span></span><span><span>    <span>return</span> result;
</span></span><span><span>}
</span></span></code></pre></div><p>I should note, however, that both of these implementations have at least one downside: They fail at (or very close to) <code>from_dir == -to_dir</code>. In the trigonometry-free version, this is because at that point the “halfway” vector will be zero and can’t be normalized so you’ll get garbage. You’d need to either be sure this will not happen or check for it and do something else in that case.</p><h3 id="how-do-i-appendcombinemultiply-two-or-more-rotors"><a href="#how-do-i-appendcombinemultiply-two-or-more-rotors">How do I append/combine/multiply two (or more) rotors?</a></h3><p>Rotors can be combined by just multiplying them together with the geometric product. We know that a rotor \(\v{R}\) is applied to a vector \(\v{v}\) by way of the sandwich product \(\v{v}^\prime = \v{RvR}^{-1}\) so if we had two rotors \(\v{R}_1\) and \(\v{R}_2\) we’d just apply them in order: \(\v{v}^\prime = \v{R}_2\v{R}_1\v{v}\v{R}_1^{-1}\v{R}_2^{-1} = (\v{R}_2\v{R}_1)\v{v}(\v{R}_2\v{R}_1)^{-1}\) and we see that the combined rotor \(\v{R}_3 = \v{R}_2\v{R}_1\).</p><p>Of course this only works if the product of two rotors is again a rotor. In order to convince ourselves that this is the case we can just do the multiplication:</p><details><summary>Geometric product of two 3D rotors</summary><p>We’d like to verify that the product of two 3D rotors (each of which consist of one scalar component and 3 bivector components) is another rotor consisting of one scalar component and 3 bivector components.</p><p>Say we have two rotors:
\[
\v{S} = s_0 + s_{12}\v{e_{12}} + s_{23}\v{e_{23}} + s_{31}\v{e_{31}} \\
\v{T} = t_0 + t_{12}\v{e_{12}} + t_{23}\v{e_{23}} + t_{31}\v{e_{31}} \\
\]</p><p>We just multiply them out as usual:</p><p>\[\begin{aligned}
\v{ST} &amp;= (s_0 + s_{12}\v{e_{12}} + s_{23}\v{e_{23}} + s_{31}\v{e_{31}})(t_0 + t_{12}\v{e_{12}} + t_{23}\v{e_{23}} + t_{31}\v{e_{31}}) \\
\v{ST} &amp;= (s_0)(t_0 + t_{12}\v{e_{12}} + t_{23}\v{e_{23}} + t_{31}\v{e_{31}}) \\
&amp;+ (s_{12}\v{e_{12}})(t_0 + t_{12}\v{e_{12}} + t_{23}\v{e_{23}} + t_{31}\v{e_{31}}) \\
&amp;+ (s_{23}\v{e_{23}})(t_0 + t_{12}\v{e_{12}} + t_{23}\v{e_{23}} + t_{31}\v{e_{31}}) \\
&amp;+ (s_{31}\v{e_{31}})(t_0 + t_{12}\v{e_{12}} + t_{23}\v{e_{23}} + t_{31}\v{e_{31}}) \\
\v{ST} &amp;= (s_0 t_0) + (s_0 t_{12}\v{e_{12}}) + (s_0 t_{23}\v{e_{23}}) + (s_0 t_{31}\v{e_{31}}) \\
&amp;+ (s_{12}\v{e_{12}} t_0) + (s_{12}\v{e_{12}}t_{12}\v{e_{12}}) + (s_{12}\v{e_{12}}t_{23}\v{e_{23}}) + (s_{12}\v{e_{12}}t_{31}\v{e_{31}}) \\
&amp;+ (s_{23}\v{e_{23}}t_0) + (s_{23}\v{e_{23}}t_{12}\v{e_{12}}) + (s_{23}\v{e_{23}}t_{23}\v{e_{23}}) + (s_{23}\v{e_{23}}t_{31}\v{e_{31}}) \\
&amp;+ (s_{31}\v{e_{31}}t_0) + (s_{31}\v{e_{31}}t_{12}\v{e_{12}}) + (s_{31}\v{e_{31}}t_{23}\v{e_{23}}) + (s_{31}\v{e_{31}}t_{31}\v{e_{31}}) \\
\v{ST} &amp;= (s_0 t_0) + (s_0 t_{12}\v{e_{12}}) + (s_0 t_{23}\v{e_{23}}) + (s_0 t_{31}\v{e_{31}}) \\
&amp;+ (s_{12}t_0\v{e_{12}}) + (s_{12}t_{12}\v{e_{12}}\v{e_{12}}) + (s_{12}t_{23}\v{e_{12}}\v{e_{23}}) + (s_{12}t_{31}\v{e_{12}}\v{e_{31}}) \\
&amp;+ (s_{23}t_0\v{e_{23}}) + (s_{23}t_{12}\v{e_{23}}\v{e_{12}}) + (s_{23}t_{23}\v{e_{23}}\v{e_{23}}) + (s_{23}t_{31}\v{e_{23}}\v{e_{31}}) \\
&amp;+ (s_{31}t_0\v{e_{31}}) + (s_{31}t_{12}\v{e_{31}}\v{e_{12}}) + (s_{31}t_{23}\v{e_{31}}\v{e_{23}}) + (s_{31}t_{31}\v{e_{31}}\v{e_{31}}) \\
\v{ST} &amp;= s_0 t_0 + s_0 t_{12}\v{e_{12}} + s_0 t_{23}\v{e_{23}} + s_0 t_{31}\v{e_{31}} \\
&amp;+ s_{12}t_0\v{e_{12}} - s_{12}t_{12} - s_{12}t_{23}\v{e_{31}} + s_{12}t_{31}\v{e_{23}} \\
&amp;+ s_{23}t_0\v{e_{23}} + s_{23}t_{12}\v{e_{31}} - s_{23}t_{23} - s_{23}t_{31}\v{e_{12}} \\
&amp;+ s_{31}t_0\v{e_{31}} - s_{31}t_{12}\v{e_{23}} + s_{31}t_{23}\v{e_{12}} - s_{31}t_{31} \\
\v{ST} &amp;= (s_0 t_0 - s_{12}t_{12} - s_{23}t_{23} - s_{31}t_{31}) \\
&amp;+ (s_0 t_{12} + s_{12}t_0 - s_{23}t_{31} + s_{31}t_{23})\v{e_{12}} \\
&amp;+ (s_0 t_{23} + s_{12}t_{31} + s_{23}t_0 - s_{31}t_{12})\v{e_{23}} \\
&amp;+ (s_0 t_{31} - s_{12}t_{23} + s_{23}t_{12} + s_{31}t_0)\v{e_{31}} \\
\end{aligned}\]</p><p>So clearly \(\v{ST}\) has only scalar and bivector components, and we can use the product as a new rotor.</p></details><p>This multiplication also translates fairly directly into code:</p><div><pre tabindex="0"><code data-lang="C"><span><span>rotor3 <span>combine</span>(rotor3 lhs, rotor3 rhs)
</span></span><span><span>{
</span></span><span><span>    rotor3 result <span>=</span> {};
</span></span><span><span>    result.scalar <span>=</span> lhs.scalar<span>*</span>rhs.scalar <span>-</span> lhs.xy<span>*</span>rhs.xy <span>-</span> lhs.yz<span>*</span>rhs.yz <span>-</span> lhs.zx<span>*</span>rhs.zx;
</span></span><span><span>    result.xy <span>=</span> lhs.scalar<span>*</span>rhs.xy <span>+</span> lhs.xy<span>*</span>rhs.scalar <span>-</span> lhs.yz<span>*</span>rhs.zx <span>+</span> lhs.zx<span>*</span>rhs.yz;
</span></span><span><span>    result.yz <span>=</span> lhs.scalar<span>*</span>rhs.yz <span>+</span> lhs.xy<span>*</span>rhs.zx <span>+</span> lhs.yz<span>*</span>rhs.scalar <span>-</span> lhs.zx<span>*</span>rhs.xy;
</span></span><span><span>    result.zx <span>=</span> lhs.scalar<span>*</span>rhs.zx <span>-</span> lhs.xy<span>*</span>rhs.yz <span>+</span> lhs.yz<span>*</span>rhs.xy <span>+</span> lhs.zx<span>*</span>rhs.scalar;
</span></span><span><span>    <span>return</span> result;
</span></span><span><span>}
</span></span></code></pre></div><h3 id="how-do-i-invert-or-reverse-a-rotor-to-produce-the-same-rotation-in-the-opposite-direction"><a href="#how-do-i-invert-or-reverse-a-rotor-to-produce-the-same-rotation-in-the-opposite-direction">How do I invert or reverse a rotor to produce the same rotation in the opposite direction?</a></h3><p>Since the rotor produced by the geometric product of vectors \(\v{ba}\) is a rotation in the plane formed by those two vectors, by twice the angle between those vectors (in the direction from a to b), we can produce a rotation in the same plane by the same angle in the opposite direction by just swapping \(\v{a}\) and \(\v{b}\) to get: \(\v{R}^\prime = \v{ab} = \v{a \cdot b + a \wedge b} = \v{b \cdot a - b \wedge a}\) which we can produce with very little computation from \(\v{R}\) by just negating the bivector components:</p><div><pre tabindex="0"><code data-lang="C"><span><span>rotor3 <span>reverse</span>(rotor3 r)
</span></span><span><span>{
</span></span><span><span>    rotor3 result <span>=</span> {};
</span></span><span><span>    result.scalar <span>=</span> r.scalar,
</span></span><span><span>    result.xy <span>=</span> <span>-</span>r.xy;
</span></span><span><span>    result.yz <span>=</span> <span>-</span>r.yz;
</span></span><span><span>    result.zx <span>=</span> <span>-</span>r.zx;
</span></span><span><span>    <span>return</span> result;
</span></span><span><span>}
</span></span></code></pre></div><h3 id="given-a-particular-rotor-how-do-i-actually-apply-it-to-a-vector-directly"><a href="#given-a-particular-rotor-how-do-i-actually-apply-it-to-a-vector-directly">Given a particular rotor, how do I actually apply it to a vector directly?</a></h3><p>Earlier when we showed how to apply a rotor, we did it in two steps as two separate reflection calculations.
While mathematically equivalent, this requires that we store the vectors that make up our rotor (rather than just the scalar &amp; bivector components) and requires us to do far more arithmetic.
Instead we’ll sandwich the input vector directly with the entire, pre-computed rotor:</p><details><summary>Direct rotor sandwich</summary><p>Let \(\v{R} = r_0 + r_{12}\v{e_{12}} + r_{23}\v{e_{23}} + r_{31}\v{e_{31}}\) and \(\v{v} = v_1\v{e_1} + v_2\v{e_2} + v_3\v{e_3}\).</p><p>Now \(\v{R = ba}\), for vectors \(\v{a}\) and \(\v{b}\) so by equation <a href="#eqn:inverse-of-geometric-product"><span data-equation-ref="inverse-of-geometric-product">5</span></a> we have that \(\v{R^{-1} = (ba)^{-1} = a^{-1}b^{-1}}\) and equation <a href="#eqn:geometric-vector-inverse"><span data-equation-ref="geometric-vector-inverse">4</span></a> gives us \(\v{R^{-1}} = \frac{1}{|a||b|}\v{ab}\).</p><p>Our full sandwich product is therefore:</p><p>\[
\v{v^\prime} = \v{RvR}^{-1} = \v{(ba)v}\left(\frac{1}{|a||b|}\v{ab}\right) = \frac{1}{|a||b|}\v{(ba)v(ab)}
\]</p><p>To keep our equations a little shorter, let’s start by just computing the first product \(\v{S = Rv}\):</p><p>\[\begin{align*}
\v{S} =~&amp; \v{Rv} = \v{(ba)v} \\
=~&amp; (r_0 + r_{12}\v{e_{12}} + r_{23}\v{e_{23}} + r_{31}\v{e_{31}})(v_1\v{e_1} + v_2\v{e_2} + v_3\v{e_3}) \\
=~&amp; r_0(v_1\v{e_1} + v_2\v{e_2} + v_3\v{e_3}) \\
&amp; + r_{12}\v{e_{12}}(v_1\v{e_1} + v_2\v{e_2} + v_3\v{e_3}) \\
&amp; + r_{23}\v{e_{23}}(v_1\v{e_1} + v_2\v{e_2} + v_3\v{e_3}) \\
&amp; + r_{31}\v{e_{31}}(v_1\v{e_1} + v_2\v{e_2} + v_3\v{e_3}) \\
=~&amp; r_0v_1\v{e_1} + r_0v_2\v{e_2} + r_0v_3\v{e_3} \\
&amp; + r_{12}v_1\v{e_{12}}\v{e_1} + r_{12}v_2\v{e_{12}}\v{e_2} + r_{12}v_3\v{e_{12}}\v{e_3} \\
&amp; + r_{23}v_1\v{e_{23}}\v{e_1} + r_{23}v_2\v{e_{23}}\v{e_2} + r_{23}v_3\v{e_{23}}\v{e_3} \\
&amp; + r_{31}v_1\v{e_{31}}\v{e_1} + r_{31}v_2\v{e_{31}}\v{e_2} + r_{31}v_3\v{e_{31}}\v{e_3} \\
=~&amp; r_0v_1\v{e_1} + r_0v_2\v{e_2} + r_0v_3\v{e_3} \\
&amp; - r_{12}v_1\v{e_2} + r_{12}v_2\v{e_1} + r_{12}v_3\v{e_{123}} \\
&amp; + r_{23}v_1\v{e_{123}} - r_{23}v_2\v{e_3} + r_{23}v_3\v{e_2} \\
&amp; + r_{31}v_1\v{e_3} + r_{31}v_2\v{e_{123}} - r_{31}v_3\v{e_1} \\
=~&amp; (r_0v_1 + r_{12}v_2 - r_{31}v_3)\v{e_1} \\
&amp; + (r_0v_2 - r_{12}v_1 + r_{23}v_3)\v{e_2} \\
&amp; + (r_0v_3 - r_{23}v_2 + r_{31}v_1)\v{e_3} \\
&amp; + (r_{12}v_3 + r_{23}v_1 + r_{31}v_2)\v{e_{123}} \\
\end{align*}\]</p><p>To compute the final product we’ll write our calculations in terms of \(\v{S}\) rather than in terms of \(\v{R}\) and \(\v{v}\). This makes the equations shorter and also translates more easily into code.</p><p>Before we can do that though, we need a value for \(\v{ab}\). Since we already have \(\v{ba}\) in our original definition of \(\v{R}\), we can save ourselves having to compute \(\v{ab}\) by realising that its dot product term is commutative while its wedge product term is anti-commutative (equation <a href="#eqn:geometric-product-complete"><span data-equation-ref="geometric-product-complete">2</span></a>), so we can produce one from the other just by negating the bivector component:</p><p>\[\v{ab} = r_0 - r_{12}\v{e_{12}} - r_{23}\v{e_{23}} - r_{31}\v{e_{31}}\]</p><p>Now we can complete the calculation:</p><p>\[\begin{align*}
\v{v^\prime} =~&amp; \v{(ba)v}\left(\frac{1}{|a||b|}\v{ab}\right) = \frac{1}{|a||b|}\v{S(ab)} \\
=~&amp; \frac{1}{|a||b|} [ \\
&amp; s_1\v{e_1}(r_0 - r_{12}\v{e_{12}} - r_{23}\v{e_{23}} - r_{31}\v{e_{31}}) \\
&amp; + s_2\v{e_2}(r_0 - r_{12}\v{e_{12}} - r_{23}\v{e_{23}} - r_{31}\v{e_{31}}) \\
&amp; + s_3\v{e_3}(r_0 - r_{12}\v{e_{12}} - r_{23}\v{e_{23}} - r_{31}\v{e_{31}}) \\
&amp; + s_{123}\v{e_{123}}(r_0 - r_{12}\v{e_{12}} - r_{23}\v{e_{23}} - r_{31}\v{e_{31}}) \\
&amp; ] \\
=~&amp; \frac{1}{|a||b|} [ \tag{multiply out} \\
&amp; s_1r_0\v{e_1} - s_1r_{12}\v{e_1}\v{e_{12}} - s_1r_{23}\v{e_1}\v{e_{23}} - s_1r_{31}\v{e_1}\v{e_{31}} \\
&amp; + s_2r_0\v{e_2} - s_2r_{12}\v{e_2}\v{e_{12}} - s_2r_{23}\v{e_2}\v{e_{23}} - s_2r_{31}\v{e_2}\v{e_{31}} \\
&amp; + s_3r_0\v{e_3} - s_3r_{12}\v{e_3}\v{e_{12}} - s_3r_{23}\v{e_3}\v{e_{23}} - s_3r_{31}\v{e_3}\v{e_{31}} \\
&amp; + s_{123}r_0\v{e_{123}} - s_{123}r_{12}\v{e_{123}}\v{e_{12}} - s_{123}r_{23}\v{e_{123}}\v{e_{23}} - s_{123}r_{31}\v{e_{123}}\v{e_{31}} \\
&amp; ] \\
=~&amp; \frac{1}{|a||b|} [ \tag{simplify basis elements} \\
&amp; s_1r_0\v{e_1} - s_1r_{12}\v{e_2} - s_1r_{23}\v{e_{123}} + s_1r_{31}\v{e_3} \\
&amp; + s_2r_0\v{e_2} + s_2r_{12}\v{e_1} - s_2r_{23}\v{e_3} - s_2r_{31}\v{e_{123}} \\
&amp; + s_3r_0\v{e_3} - s_3r_{12}\v{e_{123}} + s_3r_{23}\v{e_2} - s_3r_{31}\v{e_1} \\
&amp; + s_{123}r_0\v{e_{123}} + s_{123}r_{12}\v{e_3} + s_{123}r_{23}\v{e_1} + s_{123}r_{31}\v{e_2} \\
&amp; ] \\
=~&amp; \frac{1}{|a||b|} [ \tag{collect similar terms} \\
&amp; (s_1r_0 + s_2r_{12} - s_3r_{31} + s_{123}r_{23})\v{e_1} \\
&amp; + (- s_1r_{12} + s_2r_0 + s_3r_{23} + s_{123}r_{31})\v{e_2} \\
&amp; + (s_1r_{31} - s_2r_{23} + s_3r_0 + s_{123}r_{12})\v{e_3} \\
&amp; + (- s_1r_{23} - s_2r_{31} - s_3r_{12} + s_{123}r_0)\v{e_{123}} \\
&amp; ] \\
\end{align*}\]</p><p>We actually already know from our rotation example calculation above that that the coefficient of \(\v{e_{123}}\) here is zero (in short: equation <a href="#eqn:sandwich-product"><span data-equation-ref="sandwich-product">12</span></a> has no trivector component). For completeness though, we can substitute in the coefficients of \(\v{S}\) and demonstrate it that way:</p><p>\[\begin{align*}
v^\prime_{123} =~&amp; - s_1r_{23} - s_2r_{31} - s_3r_{12} + s_{123}r_0 \\
=~&amp; -(r_0v_1 + r_{12}v_2 - r_{31}v_3)r_{23} \\
&amp; - (r_0v_2 - r_{12}v_1 + r_{23}v_3)r_{31} \\
&amp; - (r_0v_3 - r_{23}v_2 + r_{31}v_1)r_{12} \\
&amp; + (r_{12}v_3 + r_{23}v_1 + r_{31}v_2)r_0 \\
=~&amp; - r_0v_1r_{23} - r_{12}v_2r_{23} + r_{31}v_3r_{23} \tag{multiply out} \\
&amp; - r_0v_2r_{31} + r_{12}v_1r_{31} - r_{23}v_3r_{31} \\
&amp; - r_0v_3r_{12} + r_{23}v_2r_{12} - r_{31}v_1r_{12} \\
&amp; + r_{12}v_3r_0 + r_{23}v_1r_0 + r_{31}v_2r_0 \\
=~&amp; - r_0r_{23}v_1 - r_{12}r_{23}v_2 + r_{23}r_{31}v_3 \tag{rearrange factors} \\
&amp; - r_0r_{31}v_2 + r_{12}r_{31}v_1 - r_{23}r_{31}v_3 \\
&amp; - r_0r_{12}v_3 + r_{12}r_{23}v_2 - r_{12}r_{31}v_1 \\
&amp; + r_0r_{12}v_3 + r_0r_{23}v_1 + r_0r_{31}v_2 \\
=~&amp; (r_0r_{23}v_1 - r_0r_{23}v_1) \tag{collect similar terms}\\
&amp; + (r_{12}r_{23}v_2 - r_{12}r_{23}v_2) \\
&amp; + (r_{23}r_{31}v_3 - r_{23}r_{31}v_3) \\
&amp; + (r_{12}r_{31}v_1 - r_{12}r_{31}v_1) \\
&amp; + (r_0r_{31}v_2 - r_0r_{31}v_2) \\
&amp; + (r_0r_{12}v_3 - r_0r_{12}v_3) \\
=~&amp; 0 \tag{everything cancels out}
\end{align*}\]</p><p>So we can ignore the trivector term, and the output of our rotation is just a normal vector as expected.</p></details><p>These calculations can be fairly directly translated into code that we can apply to our rotor and vector types. Note that the code below assumes our rotor was constructed from two unit vectors (which is something we enforced in our <code>from_to()</code> code above).</p><div><pre tabindex="0"><code data-lang="C"><span><span>vec3 <span>transform</span>(rotor3 r, vec3 v) <span>const</span>
</span></span><span><span>{
</span></span><span><span>    <span>// Assume r is formed by the multiplication of two unit vectors.
</span></span></span><span><span><span></span>    <span>// Then S = Rv, result = SR^{-1} where R^{-1} is just R with the bivector coefficients negated
</span></span></span><span><span><span></span>    <span>const</span> <span>float</span> S_x <span>=</span> r.scalar<span>*</span>v.x <span>+</span> r.xy<span>*</span>v.y <span>-</span> r.zx<span>*</span>v.z;
</span></span><span><span>    <span>const</span> <span>float</span> S_y <span>=</span> r.scalar<span>*</span>v.y <span>-</span> r.xy<span>*</span>v.x <span>+</span> r.yz<span>*</span>v.z;
</span></span><span><span>    <span>const</span> <span>float</span> S_z <span>=</span> r.scalar<span>*</span>v.z <span>-</span> r.yz<span>*</span>v.y <span>+</span> r.zx<span>*</span>v.x;
</span></span><span><span>    <span>const</span> <span>float</span> S_xyz <span>=</span> r.xy<span>*</span>v.z <span>+</span> r.yz<span>*</span>v.x <span>+</span> r.zx<span>*</span>v.y;
</span></span><span><span>
</span></span><span><span>    vec3 result <span>=</span> {};
</span></span><span><span>    result.x <span>=</span> S_x<span>*</span>r.scalar <span>+</span>   S_y<span>*</span>r.xy <span>+</span> S_xyz<span>*</span>r.yz <span>-</span>   S_z<span>*</span>r.zx;
</span></span><span><span>    result.y <span>=</span> S_y<span>*</span>r.scalar <span>-</span>   S_x<span>*</span>r.xy <span>+</span>   S_z<span>*</span>r.yz <span>+</span> S_xyz<span>*</span>r.zx;
</span></span><span><span>    result.z <span>=</span> S_z<span>*</span>r.scalar <span>+</span> S_xyz<span>*</span>r.xy <span>-</span>   S_y<span>*</span>r.yz <span>+</span>   S_x<span>*</span>r.zx;
</span></span><span><span>    <span>return</span> result;
</span></span><span><span>}
</span></span></code></pre></div><h3 id="how-do-i-convert-a-rotor-to-a-matrix-so-i-can-use-it-in-my-graphics-pipeline"><a href="#how-do-i-convert-a-rotor-to-a-matrix-so-i-can-use-it-in-my-graphics-pipeline">How do I convert a rotor to a matrix so I can use it in my graphics pipeline?</a></h3><p>Think of rotation as a change of basis. We’re changing from the standard basis (the \(x\), \(y\) and \(z\) axes) to a new basis which is just the standard basis after undergoing our rotation.</p><p>As we know from linear algebra, the matrix that applies this change of basis is simply the one whose columns are the new (rotated) basis vectors (assuming you’re using column vectors).</p><p>Conveniently, showed how to apply a rotor to a vector directly above, so we can use that to transform each of the standard basis vectors and output a matrix with those vectors as its columns (and padded with zeroes to make it 4x4):</p><div><pre tabindex="0"><code data-lang="C"><span><span>mat4 <span>rotate</span>(rotor3 r)
</span></span><span><span>{
</span></span><span><span>    <span>const</span> vec3 new_x <span>=</span> transform(r, vec3{<span>1.0f</span>, <span>0.0f</span>, <span>0.0f</span>});
</span></span><span><span>    <span>const</span> vec3 new_y <span>=</span> transform(r, vec3{<span>0.0f</span>, <span>1.0f</span>, <span>0.0f</span>});
</span></span><span><span>    <span>const</span> vec3 new_z <span>=</span> transform(r, vec3{<span>0.0f</span>, <span>0.0f</span>, <span>1.0f</span>});
</span></span><span><span>    
</span></span><span><span>    mat4 result <span>=</span> {};
</span></span><span><span>    result.columns[<span>0</span>] <span>=</span> vec4{new_x.x, new_x.y, new_x.z, <span>0.0f</span>},
</span></span><span><span>    result.columns[<span>1</span>] <span>=</span> vec4{new_y.x, new_y.y, new_y.z, <span>0.0f</span>},
</span></span><span><span>    result.columns[<span>2</span>] <span>=</span> vec4{new_z.x, new_z.y, new_z.z, <span>0.0f</span>},
</span></span><span><span>    result.columns[<span>3</span>] <span>=</span> vec4{<span>0.0f</span>, <span>0.0f</span>, <span>0.0f</span>, <span>1.0f</span>},
</span></span><span><span>    <span>return</span> result;
</span></span><span><span>}
</span></span></code></pre></div><p>The many zeroes in our input vectors suggest that mathematically there will be many intermediate calculations that end up as zero and could be skipped. If you need extra performance you could try inlining <code>transform()</code> and removing all the multiplications by zero.</p><h3 id="how-do-i-turn-a-quaternion-into-an-equivalent-3d-rotor"><a href="#how-do-i-turn-a-quaternion-into-an-equivalent-3d-rotor">How do I turn a quaternion into an equivalent (3D) rotor?</a></h3><p>Given the number of similarities between quaternions and 3D rotors, it may not come as a surprise that they are in fact effectively the same mathematical object (they’re isomorphic).
All we need to turn one into the other is to know which quaternion basis elements correspond to which rotor basis elements.</p><p>By multiplying out our transform-a-vector-using-a-rotor calculations above and comparing the results to the quaternion representation of the <a href="https://en.wikipedia.org/wiki/Euler%E2%80%93Rodrigues_formula">Euler-Rodrigues formula</a>, we get the following mappings:</p><p>\[
\v{i} \to \v{-e_{23}} \\
\v{j} \to \v{-e_{31}} \\
\v{k} \to \v{-e_{12}} \\
\]</p><p>and the scalar components stay as the scalar components. Our transformation is therefore:</p><div><pre tabindex="0"><code data-lang="C"><span><span><span>struct</span> UnitQuaternion
</span></span><span><span>{
</span></span><span><span>    <span>float</span> w; <span>// scalar component
</span></span></span><span><span><span></span>    <span>float</span> x; <span>// coefficient of i
</span></span></span><span><span><span></span>    <span>float</span> y; <span>// coefficient of j
</span></span></span><span><span><span></span>    <span>float</span> z; <span>// coefficient of k
</span></span></span><span><span><span></span>};
</span></span><span><span>
</span></span><span><span>rotor3 <span>quaternion_to_rotor3</span>(UnitQuaternion q)
</span></span><span><span>{
</span></span><span><span>    rotor3 result <span>=</span> {};
</span></span><span><span>    result.scalar <span>=</span> q.w;
</span></span><span><span>    result.xy <span>=</span> <span>-</span>q.z;
</span></span><span><span>    result.yz <span>=</span> <span>-</span>q.x;
</span></span><span><span>    result.zx <span>=</span> <span>-</span>q.y;
</span></span><span><span>    <span>return</span> result;
</span></span><span><span>}
</span></span></code></pre></div><h3 id="how-do-i-smoothly--correctly-interpolate-between-two-rotors"><a href="#how-do-i-smoothly--correctly-interpolate-between-two-rotors">How do I smoothly &amp;amp; correctly interpolate between two rotors?</a></h3><p>Rotors (in 3D) are 4D vectors.
To simplify many calculations, we’ve added the requirement that they’re 4D <em>unit</em> vectors.
While there are many ways to interpolate between two 4D unit vectors, we will cover just two of them (the two you are most likely to use).</p><p>The first and simplest way to interpolate between two rotors is just standard 4D vector <code>lerp()</code> with the extra step to re-normalise the resulting value, sometimes called <code>nlerp()</code>:</p><div><pre tabindex="0"><code data-lang="C"><span><span><span>float</span> <span>lerp</span>(<span>float</span> a, <span>float</span> b, <span>float</span> t);
</span></span><span><span>
</span></span><span><span>rotor3 <span>nlerp_incorrect</span>(rotor3 lhs, rotor3 rhs, <span>float</span> t)
</span></span><span><span>{
</span></span><span><span>    rotor3 r <span>=</span> {};
</span></span><span><span>    r.scalar <span>=</span> lerp(lhs.scalar, rhs.scalar, t);
</span></span><span><span>    r.xy <span>=</span> lerp(lhs.xy, rhs.xy, t);
</span></span><span><span>    r.yz <span>=</span> lerp(lhs.yz, rhs.yz, t);
</span></span><span><span>    r.zx <span>=</span> lerp(lhs.zx, rhs.zx, t);
</span></span><span><span>
</span></span><span><span>    <span>const</span> <span>float</span> magnitude <span>=</span> sqrtf(r.scalar<span>*</span>r.scalar <span>+</span> r.xy<span>*</span>r.xy <span>+</span> r.yz<span>*</span>r.yz <span>+</span> r.zx<span>*</span>r.zx);
</span></span><span><span>    r.scalar <span>/=</span> magnitude;
</span></span><span><span>    r.xy <span>/=</span> magnitude;
</span></span><span><span>    r.yz <span>/=</span> magnitude;
</span></span><span><span>    r.zx <span>/=</span> magnitude;
</span></span><span><span>    <span>return</span> r;
</span></span><span><span>}
</span></span></code></pre></div><p>We’ll get back to the reason why this function is marked as incorrect in a minute.
First let’s take a look at the other approach: <code>slerp()</code>:</p><p>Slerp (“Spherical linear interpolation”) was introduced by <a href="https://www.cs.cmu.edu/~kiranb/animation/p245-shoemake.pdf">Ken Shoemake in a SIGGRAPH paper in 1985</a> for the purpose of interpolating quaternions (which are isomorphic to rotors).
<a href="https://en.wikipedia.org/wiki/Slerp">Wikipedia</a> helpfully summarises it as:</p><p>\[
\text{slerp}(\v{a}, \v{b}, t) = \frac{sin((1-t)\theta)}{sin(\theta)}\v{a} + \frac{sin(t\theta)}{sin(\theta)}\v{b}
\]</p><p>where \(\theta\) is the angle between \(\v{a}\) and \(\v{b}\). This translates fairly directly into code as:</p><div><pre tabindex="0"><code data-lang="C"><span><span>rotor3 <span>slerp_incorrect</span>(rotor3 from, rotor3 to, <span>float</span> t)
</span></span><span><span>{
</span></span><span><span>    <span>// Assume that `from` and `to` both have magnitude 1
</span></span></span><span><span><span></span>    <span>// (IE they are the product of two unit vectors)
</span></span></span><span><span><span></span>    <span>// then cos(theta) = dot(from, to)
</span></span></span><span><span><span></span>    <span>const</span> <span>float</span> cos_theta <span>=</span> from.scalar<span>*</span>to.scalar <span>+</span> from.xy<span>*</span>to.xy <span>+</span> from.yz<span>*</span>to.yz <span>+</span> from.zx<span>*</span>to.zx;
</span></span><span><span>
</span></span><span><span>    <span>const</span> <span>float</span> theta <span>=</span> acosf(cos_theta);
</span></span><span><span>    <span>const</span> <span>float</span> from_factor <span>=</span> sinf((<span>1.0f</span> <span>-</span> t)<span>*</span>theta)<span>/</span>sinf(theta);
</span></span><span><span>    <span>const</span> <span>float</span> to_factor <span>=</span> sinf(t<span>*</span>theta)<span>/</span>sinf(theta);
</span></span><span><span>
</span></span><span><span>    rotor3 result <span>=</span> {};
</span></span><span><span>    result.scalar <span>=</span> from_factor<span>*</span>from.scalar <span>+</span> to_factor<span>*</span>to.scalar;
</span></span><span><span>    result.xy <span>=</span> from_factor<span>*</span>from.xy <span>+</span> to_factor<span>*</span>to.xy;
</span></span><span><span>    result.yz <span>=</span> from_factor<span>*</span>from.yz <span>+</span> to_factor<span>*</span>to.yz;
</span></span><span><span>    result.zx <span>=</span> from_factor<span>*</span>from.zx <span>+</span> to_factor<span>*</span>to.zx;
</span></span><span><span>    <span>return</span> result;
</span></span><span><span>}
</span></span></code></pre></div><p>Both of these functions have been marked as “incorrect”. That is because they both suffer from the same problem: They don’t always give us the shortest path between the two inputs.</p><p>As we saw earlier, rotors lend themselves quite easily to the “axis-angle” view of rotations (equation <a href="#eqn:rotor-axis-angle"><span data-equation-ref="rotor-axis-angle">13</span></a>). So let’s compare two axis-angle-type rotations:
Picture, if you can, a rotation of 30 degrees clockwise around the positive Z axis.
Now picture a rotation of 30 degrees <em>counter</em>-clockwise around the <em>negative</em> Z axis.
These rotations are equivalent.
Negating both the axis and the angle produces an equivalent rotation and this is exactly what happens if we negate each component of a rotor, so given a rotor \(\v{R}\), both \(\v{R}\) and \(\v{-R}\) represent the same rotation.</p><p>If we’re only using our rotor to transform vectors then this fact is irrelevant, but if we want to interpolate between to rotors then it needs to be considered.
If we tried to interpolate between two rotors that where going “in the opposite direction”, our interpolation would take the long way around rather than the short way.</p><p>Thankfully controlling this is very easy: We just need to make sure that the dot product of our two rotors (taken as if they were 4D vectors) is positive.</p><p>The diagram below is an illustration of this effect. Here we have two green arrows, each representing a different rotor being applied to the same input vector.
The solid blue lines and the dashed red lines are the results of using <code>slerp()</code> to interpolate between those rotors.
If the dot product between the two rotors is positive, we get the solid blue lines. If it is negative, we get the dashed red lines.</p><figure><img src="https://jacquesheunis.com/post/rotors/slerp-dotproduct-importance.webp"/><figcaption>Slerp between two rotations. Blue solid lines show slerp when the dotproduct is positive, red dashed lines shown when it is negative. Labelled lines are thicker.</figcaption></figure><p>So under the assumption that we’re almost always going to want the shorter path between our input rotors, let’s amend our two functions:</p><div><pre tabindex="0"><code data-lang="C"><span><span>rotor3 <span>nlerp</span>(rotor3 lhs, rotor3 rhs, <span>float</span> t)
</span></span><span><span>{
</span></span><span><span>    <span>const</span> <span>float</span> dot <span>=</span> from.scalar<span>*</span>to.scalar <span>+</span> from.xy<span>*</span>to.xy <span>+</span> from.yz<span>*</span>to.yz <span>+</span> from.zx<span>*</span>to.zx;
</span></span><span><span>    <span>if</span>(dot <span>&lt;</span> <span>0.0f</span>)
</span></span><span><span>    {
</span></span><span><span>        to.scalar <span>=</span> <span>-</span>to.scalar;
</span></span><span><span>        to.xy <span>=</span> <span>-</span>to.xy;
</span></span><span><span>        to.yz <span>=</span> <span>-</span>to.yz;
</span></span><span><span>        to.zx <span>=</span> <span>-</span>to.zx;
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    rotor3 r <span>=</span> {};
</span></span><span><span>    r.scalar <span>=</span> lerp(lhs.scalar, rhs.scalar, t);
</span></span><span><span>    r.xy <span>=</span> lerp(lhs.xy, rhs.xy, t);
</span></span><span><span>    r.yz <span>=</span> lerp(lhs.yz, rhs.yz, t);
</span></span><span><span>    r.zx <span>=</span> lerp(lhs.zx, rhs.zx, t);
</span></span><span><span>
</span></span><span><span>    <span>const</span> <span>float</span> magnitude <span>=</span> sqrtf(r.scalar<span>*</span>r.scalar <span>+</span> r.xy<span>*</span>r.xy <span>+</span> r.yz<span>*</span>r.yz <span>+</span> r.zx<span>*</span>r.zx);
</span></span><span><span>    r.scalar <span>/=</span> magnitude;
</span></span><span><span>    r.xy <span>/=</span> magnitude;
</span></span><span><span>    r.yz <span>/=</span> magnitude;
</span></span><span><span>    r.zx <span>/=</span> magnitude;
</span></span><span><span>    <span>return</span> r;
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span>rotor3 <span>slerp_stillincorrect</span>(rotor3 from, rotor3 to, <span>float</span> t)
</span></span><span><span>{
</span></span><span><span>    <span>float</span> dot <span>=</span> from.scalar<span>*</span>to.scalar <span>+</span> from.xy<span>*</span>to.xy <span>+</span> from.yz<span>*</span>to.yz <span>+</span> from.zx<span>*</span>to.zx;
</span></span><span><span>    <span>if</span>(dot <span>&lt;</span> <span>0.0f</span>)
</span></span><span><span>    {
</span></span><span><span>        to.scalar <span>=</span> <span>-</span>to.scalar;
</span></span><span><span>        to.xy <span>=</span> <span>-</span>to.xy;
</span></span><span><span>        to.yz <span>=</span> <span>-</span>to.yz;
</span></span><span><span>        to.zx <span>=</span> <span>-</span>to.zx;
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>// Assume that `from` and `to` both have magnitude 1
</span></span></span><span><span><span></span>    <span>// (IE they are the product of two unit vectors)
</span></span></span><span><span><span></span>    <span>// then cos(theta) = dot(from, to)
</span></span></span><span><span><span></span>    <span>const</span> <span>float</span> cos_theta <span>=</span> dot;
</span></span><span><span>
</span></span><span><span>    <span>const</span> <span>float</span> theta <span>=</span> acosf(cos_theta);
</span></span><span><span>    <span>const</span> <span>float</span> from_factor <span>=</span> sinf((<span>1.0f</span> <span>-</span> t)<span>*</span>theta)<span>/</span>sinf(theta);
</span></span><span><span>    <span>const</span> <span>float</span> to_factor <span>=</span> sinf(t<span>*</span>theta)<span>/</span>sinf(theta);
</span></span><span><span>
</span></span><span><span>    rotor3 result <span>=</span> {};
</span></span><span><span>    result.scalar <span>=</span> from_factor<span>*</span>from.scalar <span>+</span> to_factor<span>*</span>to.scalar;
</span></span><span><span>    result.xy <span>=</span> from_factor<span>*</span>from.xy <span>+</span> to_factor<span>*</span>to.xy;
</span></span><span><span>    result.yz <span>=</span> from_factor<span>*</span>from.yz <span>+</span> to_factor<span>*</span>to.yz;
</span></span><span><span>    result.zx <span>=</span> from_factor<span>*</span>from.zx <span>+</span> to_factor<span>*</span>to.zx;
</span></span><span><span>    <span>return</span> result;
</span></span><span><span>}
</span></span></code></pre></div><p>Unfortunately, our <code>slerp()</code> implementation is <em>still</em> incorrect.
It still suffers from a numerical issue when the angle between <code>from</code> and <code>to</code> is very close (or exactly equal) to 0, causing us to divide by a value that is very close (or exactly equal) to 0.
Another possibility is that because floating-point numbers on actual, real-life computers have limited precision we could find ourselves in a situation where our dot product is actually greater than 1, leaving it outside of the domain of \(cos^{-1}\).</p><p>A common workaround for all of this is to just switch to <code>nlerp()</code> when the input rotors are very similar (dot product is very close to \(1\)):</p><div><pre tabindex="0"><code data-lang="C"><span><span>rotor3 <span>slerp</span>(rotor3 from, rotor3 to, <span>float</span> t)
</span></span><span><span>{
</span></span><span><span>    <span>float</span> dot <span>=</span> from.scalar<span>*</span>to.scalar <span>+</span> from.xy<span>*</span>to.xy <span>+</span> from.yz<span>*</span>to.yz <span>+</span> from.zx<span>*</span>to.zx;
</span></span><span><span>    <span>if</span>(dot <span>&lt;</span> <span>0.0f</span>)
</span></span><span><span>    {
</span></span><span><span>        to.scalar <span>=</span> <span>-</span>to.scalar;
</span></span><span><span>        to.xy <span>=</span> <span>-</span>to.xy;
</span></span><span><span>        to.yz <span>=</span> <span>-</span>to.yz;
</span></span><span><span>        to.zx <span>=</span> <span>-</span>to.zx;
</span></span><span><span>        dot <span>=</span> <span>-</span>dot;
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>// Avoid numerical stability issues with trig functions when
</span></span></span><span><span><span></span>    <span>// the angle between `from` and `to` is close to zero.
</span></span></span><span><span><span></span>    <span>// Also assumes `from` and `to` both have magnitude 1.
</span></span></span><span><span><span></span>    <span>if</span>(dot <span>&gt;</span> <span>0.99995f</span>)
</span></span><span><span>    {
</span></span><span><span>        <span>return</span> nlerp(from, to, t);
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>// Assume that `from` and `to` both have magnitude 1
</span></span></span><span><span><span></span>    <span>// (IE they are the product of two unit vectors)
</span></span></span><span><span><span></span>    <span>// then cos(theta) = dot(from, to)
</span></span></span><span><span><span></span>    <span>const</span> <span>float</span> cos_theta <span>=</span> dot;
</span></span><span><span>
</span></span><span><span>    <span>const</span> <span>float</span> theta <span>=</span> acosf(cos_theta);
</span></span><span><span>    <span>const</span> <span>float</span> from_factor <span>=</span> sinf((<span>1.0f</span> <span>-</span> t)<span>*</span>theta)<span>/</span>sinf(theta);
</span></span><span><span>    <span>const</span> <span>float</span> to_factor <span>=</span> sinf(t<span>*</span>theta)<span>/</span>sinf(theta);
</span></span><span><span>
</span></span><span><span>    rotor3 result <span>=</span> {};
</span></span><span><span>    result.scalar <span>=</span> from_factor<span>*</span>from.scalar <span>+</span> to_factor<span>*</span>to.scalar;
</span></span><span><span>    result.xy <span>=</span> from_factor<span>*</span>from.xy <span>+</span> to_factor<span>*</span>to.xy;
</span></span><span><span>    result.yz <span>=</span> from_factor<span>*</span>from.yz <span>+</span> to_factor<span>*</span>to.yz;
</span></span><span><span>    result.zx <span>=</span> from_factor<span>*</span>from.zx <span>+</span> to_factor<span>*</span>to.zx;
</span></span><span><span>    <span>return</span> result;
</span></span><span><span>}
</span></span></code></pre></div><p>So now we have two complete methods for interpolating between rotors. Great. Why did we need two?</p><p>Consider using both to interpolate between two orientations:</p><figure><img src="https://jacquesheunis.com/post/rotors/nlerp-vs-slerp.webp"/><figcaption>Interpolation between the two green arrows. Solid blue lines show slerp(a,b,t), dashed red lines show nlerp(a,b,t). Labelled lines are thicker.</figcaption></figure><p><code>slerp()</code> produces values that are spaced evenly apart, while <code>nlerp()</code> produces values that are further apart around \(t = 0.5\) and closer together around \(t = 0\) and \(t = 1\).
If this were an animation and \(t\) were the elapsed time, this would show up as the animation playing slightly more quickly near the beginning and end, and slightly more slowly around the middle.</p><p>How much of a problem this is depends on your use-case.
If people are going to be watching very closely and execution speed is not a concern, you probably want <code>slerp()</code>.
If execution speed is a priority and small errors are unlikely to matter (<a href="http://number-none.com/product/Understanding%20Slerp,%20Then%20Not%20Using%20It/">as Jonathan Blow argues is usually true in games</a>), you probably want <code>nlerp()</code>.</p><h2 id="summing-up"><a href="#summing-up">Summing up</a></h2><p>Well done on getting this far. Let’s take a quick step back and look at what we’ve covered:</p><p>We introduced the wedge &amp; geometric products, with which we combine vectors to get bivectors, and then trivectors (and more, if you venture into higher dimensions).
We saw how the geometric product can be used to produce reflection over a vector, and how two such reflections can be combined to produce a rotation.
A rotation constructed in such a way is a multivector with scalar and bivector components and is called a “rotor”.</p><p>Finally we took a look at how to actually achieve some common operations on rotors, with accompanying code to aid in understanding and practical usage.</p><p>I hope it’s been an enlightening journey but if you find (as I did) that this post and others have not plugged all the holes in your understanding then here are some of the excellent resources that I used along the way.
Maybe they better suite your way of thinking than my writing does.</p><ul><li><a href="https://marctenbosch.com/quaternions/">Let’s remove Quaternions from every 3D Engine, by Marc ten Bosch</a></li><li><a href="https://probablydance.com/2017/08/05/intuitive-quaternions/">Less Weird Quaternions, by Malte Skarupke</a></li><li><a href="https://www.jaapsuter.com/geometric-algebra.pdf">Geometric Algebra Primer, by Jaap Suter</a></li><li><a href="https://www.3dgep.com/understanding-quaternions">Understanding Quaternions</a></li><li><a href="https://bivector.net/tools.html">Geometric algebra calculator</a> (you want the “3D Vectorspace Geometric Algebra” version)</li><li><a href="https://foundationsofgameenginedev.com/">Foundations of Game Engine Development, Volume 1 (by Eric Lengyel), Chapter 4</a></li></ul><p>Finally, if you’ve found something in this post that appears to be incorrect, please feel free to <a href="mailto:contact@jacques2Xheunis_butwithoutthetwox.com">reach out via email</a> and I’ll do my best to correct it.</p></article></div>
  </body>
</html>
