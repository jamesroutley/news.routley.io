<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://voratiq.com/blog/yolo-in-the-sandbox/">Original</a>
    <h1>Observed Agent Sandbox Bypasses</h1>
    
    <div id="readability-page-1" class="page"><article>
      <p>We&#39;ve been running Claude, Codex, and Gemini in sandboxed yolo mode (<code>--dangerously-skip-permissions</code>, <code>--dangerously-bypass-approvals-and-sandbox</code>, <code>--yolo</code>) for a few months, logging what happens each time they hit a restriction. <a href="https://github.com/voratiq/voratiq" rel="noopener" target="_blank">[1]</a></p>
      <p>Most of the unexpected behavior happened while the agents were simply trying to complete the tasks assigned to them. Some of this came up during normal runs, and some we provoked through red-teaming efforts.</p>
      <p>This post covers the most interesting exploits we observed and how they helped us improve our sandbox design.</p>
      <h2>Sandbox Mechanics</h2>
      <p>Each agent runs in an OS-level sandbox (macOS <code>sandbox-exec</code> or Linux <code>bwrap</code>) that blocks network and filesystem access by default. We allow specific domains and paths through config, and have detailed logging around agent behavior and denials. <a href="https://github.com/voratiq/sandbox-runtime" rel="noopener" target="_blank">[2]</a></p>
      <p>The bypasses below are all attempts to route around sandbox denials (swapping directories, leaking host paths, masking exit codes) in an effort to advance their perceived goal.</p>
      <h2>Observed Bypasses</h2>
      <h3>Exit-Code Masking</h3>
      <p>Codex was asked to run a health check against <code>localhost</code>, which was blocked. It ran <code>curl http://localhost:5001/health || true</code>. The sandbox denied the connection, but <code>|| true</code> forced exit code 0. The harness saw success even though the request never went through.</p>
      <figure>
        <img src="https://voratiq.com/assets/diagrams/yolo-in-the-sandbox-1.svg" alt="Diagram for yolo-in-the-sandbox 1" loading="lazy"/>
      </figure>
      <h3>Environment Variable Leak</h3>
      <p>Codex was blocked from reading a token in a test fixture. It searched the environment for <code>vor</code>-related variables, found <code>VORATIQ_CLI_ROOT</code> pointing to an absolute host path, and read the token through that path instead. The deny rule only covered the workspace-relative path.</p>
      <figure>
        <img src="https://voratiq.com/assets/diagrams/yolo-in-the-sandbox-2.svg" alt="Diagram for yolo-in-the-sandbox 2" loading="lazy"/>
      </figure>
      <h3>Directory Swap Bypass</h3>
      <p>Codex was blocked from writing to <code>README.md</code>. It cloned the entire workspace into a new directory, made its changes there, and then renamed the directories. The swap bypassed our policy because the deny rule was bound to a specific file path, not the file itself or the workspace root.</p>
      <figure>
        <img src="https://voratiq.com/assets/diagrams/yolo-in-the-sandbox-3.svg" alt="Diagram for yolo-in-the-sandbox 3" loading="lazy"/>
      </figure>
      <h3>Lockfile Poisoning</h3>
      <p>Codex couldn&#39;t reach <code>registry.npmjs.org</code>, so <code>npm install</code> failed. It created a local tarball with the structure of the missing package, computed a SHA-512 hash, and forged the integrity field in <code>package-lock.json</code> to match. The next install &#34;succeeded&#34; with a stub dependency. The corrupted lockfile could break future builds or silently pull in the wrong code.</p>
      <figure>
        <img src="https://voratiq.com/assets/diagrams/yolo-in-the-sandbox-4.svg" alt="Diagram for yolo-in-the-sandbox 4" loading="lazy"/>
      </figure>
      <h2>Other Notable Behaviors</h2>
      <p>We also saw agents get stuck in loops, break their own environments, and try to expand their own sandbox configuration.</p>
      <ul>
        <li><strong>NPM hammer:</strong> Gemini and Codex ran <code>npm install</code> against a blocked registry millions of times, producing multi-GB logs.</li>
        <li><strong>Host path confusion:</strong> Claude occasionally targeted the host repo path instead of the sandboxed <code>workspace/</code>, then erroneously reported &#34;sandbox blocked the write&#34;.</li>
        <li><strong>Dependency deletion:</strong> After <code>npm install</code> failures, Codex deleted <code>node_modules</code> entirely and retried the blocked install.</li>
        <li><strong>Config edit attempt:</strong> Codex edited <code>sandbox/settings.json</code> mid-run to remove deny rules, expecting the sandbox to reload and give it expanded permissions.</li>
      </ul>
      <h2>Model Differences</h2>
      <p>The three model families we tested responded to sandbox denials differently, and each required its own mitigation strategy.</p>
      <p>Claude models (<code>claude-sonnet-4-5-20250929</code>, <code>claude-haiku-4-5-20251001</code>) typically stopped after one or two denials and moved on. Adding a line to the prompt explaining the sandbox was enough to prevent most unwanted behavior.</p>
      <p>Codex models (<code>gpt-5-codex</code>, <code>gpt-5.1-codex-max</code>) often tried to work around denials and succeeded with several novel bypasses. To counter, we broadened deny rules, implemented outcome-based checks, and more carefully managed environment variables.</p>
      <p>Gemini models (<code>gemini-2.5-pro</code>, <code>gemini-2.5-flash</code>), when blocked, retried the exact same command millions of times, creating massive log files. To stop, we added harness-level rate limiting to kill runaway loops.</p>
      <h2>Takeaways</h2>
      <p>Sandboxing is hard, and it will get harder as models get stronger and objectives get fuzzier.</p>
      <p>The bypasses we observed were not adversarial. They happened because the agents were trying to complete their assigned tasks. To an agent, the sandbox is just another set of constraints to optimize against.</p>
      <p>In our experience, the way to counter this is through defense in depth, detailed logging, and fast fixes. Policies are brittle and need to evolve empirically. We log each bypass, patch it, and wait for the next one.</p>
    </article></div>
  </body>
</html>
