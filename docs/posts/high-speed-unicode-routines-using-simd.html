<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/simdutf/simdutf">Original</a>
    <h1>High speed Unicode routines using SIMD</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text"><p dir="auto"><a href="https://github.com/lemire/simdutf/actions/workflows/alpine.yml"><img src="https://github.com/lemire/simdutf/actions/workflows/alpine.yml/badge.svg" alt="Alpine Linux"/></a>
<a href="https://github.com/lemire/simdutf/actions/workflows/msys2.yml"><img src="https://github.com/lemire/simdutf/actions/workflows/msys2.yml/badge.svg" alt="MSYS2-CI"/></a>
<a href="https://github.com/lemire/simdutf/actions/workflows/msys2-clang.yml"><img src="https://github.com/lemire/simdutf/actions/workflows/msys2-clang.yml/badge.svg" alt="MSYS2-CLANG-CI"/></a>
<a href="https://github.com/lemire/simdutf/actions/workflows/ubuntu20sani.yml"><img src="https://github.com/lemire/simdutf/actions/workflows/ubuntu20sani.yml/badge.svg" alt="Ubuntu 20.04 CI (GCC 9)"/></a></p>

<p dir="auto">Most modern software relies on the <a href="https://en.wikipedia.org/wiki/Unicode" rel="nofollow">Unicode standard</a>. In memory, Unicode strings are represented using either
UTF-8 or UTF-16. The UTF-8 format is the de facto standard on the web (JSON, HTML, etc.) and it has been adopted as the default in many popular
programming languages (Go, Rust, Swift, etc.). The UTF-16 format is standard in Java, C# and in many Windows technologies.</p>
<p dir="auto">Not all sequences of bytes are valid Unicode strings. It is unsafe to use Unicode strings in UTF-8 and UTF-16LE without first validating them. Furthermore, we often need to convert strings from one encoding to another, by a process called <a href="https://en.wikipedia.org/wiki/Transcoding" rel="nofollow">transcoding</a>. For security purposes, such transcoding should be validating: it should refuse to transcode incorrect strings.</p>
<p dir="auto">This library provide fast Unicode functions such as</p>
<ul dir="auto">
<li>ASCII, UTF-8, UTF-16LE/BE and UTF-32LE validation, with and without error identification,</li>
<li>UTF-8 to UTF-16LE/BE transcoding, with or without validation, with and without error identification,</li>
<li>UTF-8 to UTF-32LE transcoding, with or without validation, with and without error identification,</li>
<li>UTF-16LE/BE to UTF-8 transcoding, with or without validation, with and without error identification,</li>
<li>UTF-32LE to UTF-8 transcoding, with or without validation, with and without error identification,</li>
<li>UTF-32LE to UTF-16LE/BE transcoding, with or without validation, with and without error identification,</li>
<li>UTF-16LE/BE to UTF-32LE transcoding, with or without validation, with and without error identification,</li>
<li>From an UTF-8 string, compute the size of the UTF-16 equivalent string,</li>
<li>From an UTF-8 string, compute the size of the UTF-32 equivalent string (equivalent to UTF-8 character counting),</li>
<li>From an UTF-16LE/BE string, compute the size of the UTF-8 equivalent string,</li>
<li>From an UTF-32 string, compute the size of the UTF-8 or UTF-16LE equivalent string,</li>
<li>From an UTF-16LE/BE string, compute the size of the UTF-32 equivalent string (equivalent to UTF-16 character counting),</li>
<li>UTF-8 and UTF-16LE/BE character counting.</li>
<li>UTF-16 endianness change (UTF16-LE/BE to UTF-16-BE/LE)</li>
</ul>
<p dir="auto">The functions are accelerated using SIMD instructions (e.g., ARM NEON, SSE, AVX, etc.). When your strings contain hundreds of characters, we can often transcode them at speeds exceeding a billion characters per second. You should expect high speeds not only with English strings (ASCII) but also Chinese, Japanese, Arabic, and so forth. We handle the full character range (including, for example, emojis).</p>
<p dir="auto">The library compiles down to tens of kilobytes. Our functions are exception-free and non allocating. We have extensive tests.</p>
<h2 dir="auto"><a id="user-content-how-fast-is-it" aria-hidden="true" href="#how-fast-is-it"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>How fast is it?</h2>
<p dir="auto">Over a wide range of realistic data sources, we transcode a billion characters per second or more. Our approach can be 3 to 10 times faster than the popular ICU library on difficult (non-ASCII) strings. We can be 20x faster than ICU when processing easy strings (ASCII). Our good results apply to both recent x64 and ARM processors.</p>
<p dir="auto">To illustrate, we present a benchmark result with values are in billions of characters processed by second. Consider the following figures.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/simdutf/simdutf/blob/master/doc/utf8utf16.png"><img src="https://github.com/simdutf/simdutf/raw/master/doc/utf8utf16.png" width="70%"/></a></p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/simdutf/simdutf/blob/master/doc/utf16utf8.png"><img src="https://github.com/simdutf/simdutf/raw/master/doc/utf16utf8.png" width="70%"/></a></p>
<p dir="auto">Datasets: <a href="https://github.com/lemire/unicode_lipsum">https://github.com/lemire/unicode_lipsum</a></p>
<p dir="auto">Please refer to our benchmarking tool for a proper interpretation of the numbers. Our results are reproducible.</p>
<h2 dir="auto"><a id="user-content-requirements" aria-hidden="true" href="#requirements"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Requirements</h2>
<ul dir="auto">
<li>C++11 compatible compiler. We support LLVM clang, GCC, Visual Studio. (Our optional benchmark tool requires C++17.)</li>
<li>For high speed, you should have a recent 64-bit system (e.g., ARM or x64).</li>
<li>If you rely on CMake, you should use a recent CMake (at least 3.15) ; otherwise you may use the <a href="#single-header-version">single header version</a>. The library is also available from Microsoft&#39;s vcpkg.</li>
</ul>
<h2 dir="auto"><a id="user-content-usage-usage" aria-hidden="true" href="#usage-usage"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Usage (Usage)</h2>
<p dir="auto">We made a video to help you get started with the library.</p>
<p dir="auto"><a href="https://www.youtube.com/watch?v=H9NZtb7ykYs" rel="nofollow"><img src="https://camo.githubusercontent.com/ed49137e65d20b1cd108f310c604c238c478374e8d7f9d5f1f6e75324757a57e/687474703a2f2f696d672e796f75747562652e636f6d2f76692f48394e5a746237796b59732f302e6a7067" alt="the simdutf library" data-canonical-src="http://img.youtube.com/vi/H9NZtb7ykYs/0.jpg"/></a><br/></p>
<h2 dir="auto"><a id="user-content-usage-cmake" aria-hidden="true" href="#usage-cmake"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Usage (CMake)</h2>
<div data-snippet-clipboard-copy-content="cmake -B build
cmake --build build
cd build
ctest ."><pre><code>cmake -B build
cmake --build build
cd build
ctest .
</code></pre></div>
<p dir="auto">Visual Studio users must specify whether they want to build the Release or Debug version.</p>
<p dir="auto">To run benchmarks, execute the <code>benchmark</code> command. You can get help on its
usage by first building it and then calling it with the <code>--help</code> flag.
E.g., under Linux you may do the following:</p>
<div data-snippet-clipboard-copy-content="cmake -B build
cmake --build build
./build/benchmarks/benchmark --help"><pre><code>cmake -B build
cmake --build build
./build/benchmarks/benchmark --help
</code></pre></div>
<p dir="auto">Instructions are similar for Visual Studio users.</p>
<p dir="auto">Since ICU is so common and popular, we assume that you may have it already on your system. When
it is not found, it is simply omitted from the benchmarks. Thus, to benchmark against ICU, make
sure you have ICU installed on your machine and that cmake can find it. For macOS, you may
install it with brew using <code>brew install icu4c</code>. If you have ICU on your system but cmake cannot
find it, you may need to provide cmake with a path to ICU, such as <code>ICU_ROOT=/usr/local/opt/icu4c cmake -B build</code>.</p>
<h2 dir="auto"><a id="user-content-single-header-version" aria-hidden="true" href="#single-header-version"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Single-header version</h2>
<p dir="auto">You can create a single-header version of the library where
all of the code is put into two files (<code>simdutf.h</code> and <code>simdutf.cpp</code>).
We publish a zip archive containing these files, e.g., see
<a href="https://github.com/simdutf/simdutf/releases/download/v1.0.1/singleheader.zip">https://github.com/simdutf/simdutf/releases/download/v1.0.1/singleheader.zip</a></p>
<p dir="auto">You may generate it on your own using a Python script.</p>
<div data-snippet-clipboard-copy-content="python3 ./singleheader/amalgamate.py"><pre><code>python3 ./singleheader/amalgamate.py
</code></pre></div>
<p dir="auto">We require Python 3 or better.</p>
<p dir="auto">Under Linux and macOS, you may test it as follows:</p>
<div data-snippet-clipboard-copy-content="cd singleheader
c++ -o amalgamation_demo amalgamation_demo.cpp -std=c++17
./amalgamation_demo"><pre><code>cd singleheader
c++ -o amalgamation_demo amalgamation_demo.cpp -std=c++17
./amalgamation_demo
</code></pre></div>
<h2 dir="auto"><a id="user-content-example" aria-hidden="true" href="#example"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Example</h2>
<p dir="auto">Using the single-header version, you could compile the following program.</p>
<div dir="auto" data-snippet-clipboard-copy-content="#include &lt;iostream&gt;
#include &lt;memory&gt;

#include &#34;simdutf.cpp&#34;
#include &#34;simdutf.h&#34;

int main(int argc, char *argv[]) {
  const char *source = &#34;1234&#34;;
  // 4 == strlen(source)
  bool validutf8 = simdutf::validate_utf8(source, 4);
  if (validutf8) {
    std::cout &lt;&lt; &#34;valid UTF-8&#34; &lt;&lt; std::endl;
  } else {
    std::cerr &lt;&lt; &#34;invalid UTF-8&#34; &lt;&lt; std::endl;
    return EXIT_FAILURE;
  }
  // We need a buffer of size where to write the UTF-16LE words.
  size_t expected_utf16words = simdutf::utf16_length_from_utf8(source, 4);
  std::unique_ptr&lt;char16_t[]&gt; utf16_output{new char16_t[expected_utf16words]};
  // convert to UTF-16LE
  size_t utf16words =
      simdutf::convert_utf8_to_utf16le(source, 4, utf16_output.get());
  std::cout &lt;&lt; &#34;wrote &#34; &lt;&lt; utf16words &lt;&lt; &#34; UTF-16LE words.&#34; &lt;&lt; std::endl;
  // It wrote utf16words * sizeof(char16_t) bytes.
  bool validutf16 = simdutf::validate_utf16le(utf16_output.get(), utf16words);
  if (validutf16) {
    std::cout &lt;&lt; &#34;valid UTF-16LE&#34; &lt;&lt; std::endl;
  } else {
    std::cerr &lt;&lt; &#34;invalid UTF-16LE&#34; &lt;&lt; std::endl;
    return EXIT_FAILURE;
  }
  // convert it back:
  // We need a buffer of size where to write the UTF-8 words.
  size_t expected_utf8words =
      simdutf::utf8_length_from_utf16le(utf16_output.get(), utf16words);
  std::unique_ptr&lt;char[]&gt; utf8_output{new char[expected_utf8words]};
  // convert to UTF-8
  size_t utf8words = simdutf::convert_utf16le_to_utf8(
      utf16_output.get(), utf16words, utf8_output.get());
  std::cout &lt;&lt; &#34;wrote &#34; &lt;&lt; utf8words &lt;&lt; &#34; UTF-8 words.&#34; &lt;&lt; std::endl;
  std::string final_string(utf8_output.get(), utf8words);
  std::cout &lt;&lt; final_string &lt;&lt; std::endl;
  if (final_string != source) {
    std::cerr &lt;&lt; &#34;bad conversion&#34; &lt;&lt; std::endl;
    return EXIT_FAILURE;
  } else {
    std::cerr &lt;&lt; &#34;perfect round trip&#34; &lt;&lt; std::endl;
  }
  return EXIT_SUCCESS;
}"><pre>#<span>include</span> <span><span>&lt;</span>iostream<span>&gt;</span></span>
#<span>include</span> <span><span>&lt;</span>memory<span>&gt;</span></span>

#<span>include</span> <span><span>&#34;</span>simdutf.cpp<span>&#34;</span></span>
#<span>include</span> <span><span>&#34;</span>simdutf.h<span>&#34;</span></span>

<span>int</span> <span>main</span>(<span>int</span> argc, <span>char</span> *argv[]) {
  <span>const</span> <span>char</span> *source = <span><span>&#34;</span>1234<span>&#34;</span></span>;
  <span><span>//</span> 4 == strlen(source)</span>
  <span>bool</span> validutf8 = <span>simdutf::validate_utf8</span>(source, <span>4</span>);
  <span>if</span> (validutf8) {
    std::cout &lt;&lt; <span><span>&#34;</span>valid UTF-8<span>&#34;</span></span> &lt;&lt; std::endl;
  } <span>else</span> {
    std::cerr &lt;&lt; <span><span>&#34;</span>invalid UTF-8<span>&#34;</span></span> &lt;&lt; std::endl;
    <span>return</span> EXIT_FAILURE;
  }
  <span><span>//</span> We need a buffer of size where to write the UTF-16LE words.</span>
  <span>size_t</span> expected_utf16words = <span>simdutf::utf16_length_from_utf8</span>(source, <span>4</span>);
  std::unique_ptr&lt;<span>char16_t</span>[]&gt; utf16_output{<span>new</span> <span>char16_t</span>[expected_utf16words]};
  <span><span>//</span> convert to UTF-16LE</span>
  <span>size_t</span> utf16words =
      <span>simdutf::convert_utf8_to_utf16le</span>(source, <span>4</span>, utf16_output.<span>get</span>());
  std::cout &lt;&lt; <span><span>&#34;</span>wrote <span>&#34;</span></span> &lt;&lt; utf16words &lt;&lt; <span><span>&#34;</span> UTF-16LE words.<span>&#34;</span></span> &lt;&lt; std::endl;
  <span><span>//</span> It wrote utf16words * sizeof(char16_t) bytes.</span>
  <span>bool</span> validutf16 = <span>simdutf::validate_utf16le</span>(utf16_output.<span>get</span>(), utf16words);
  <span>if</span> (validutf16) {
    std::cout &lt;&lt; <span><span>&#34;</span>valid UTF-16LE<span>&#34;</span></span> &lt;&lt; std::endl;
  } <span>else</span> {
    std::cerr &lt;&lt; <span><span>&#34;</span>invalid UTF-16LE<span>&#34;</span></span> &lt;&lt; std::endl;
    <span>return</span> EXIT_FAILURE;
  }
  <span><span>//</span> convert it back:</span>
  <span><span>//</span> We need a buffer of size where to write the UTF-8 words.</span>
  <span>size_t</span> expected_utf8words =
      <span>simdutf::utf8_length_from_utf16le</span>(utf16_output.<span>get</span>(), utf16words);
  std::unique_ptr&lt;<span>char</span>[]&gt; utf8_output{<span>new</span> <span>char</span>[expected_utf8words]};
  <span><span>//</span> convert to UTF-8</span>
  <span>size_t</span> utf8words = <span>simdutf::convert_utf16le_to_utf8</span>(
      utf16_output.<span>get</span>(), utf16words, utf8_output.<span>get</span>());
  std::cout &lt;&lt; <span><span>&#34;</span>wrote <span>&#34;</span></span> &lt;&lt; utf8words &lt;&lt; <span><span>&#34;</span> UTF-8 words.<span>&#34;</span></span> &lt;&lt; std::endl;
  std::string <span>final_string</span>(utf8_output.<span>get</span>(), utf8words);
  std::cout &lt;&lt; final_string &lt;&lt; std::endl;
  <span>if</span> (final_string != source) {
    std::cerr &lt;&lt; <span><span>&#34;</span>bad conversion<span>&#34;</span></span> &lt;&lt; std::endl;
    <span>return</span> EXIT_FAILURE;
  } <span>else</span> {
    std::cerr &lt;&lt; <span><span>&#34;</span>perfect round trip<span>&#34;</span></span> &lt;&lt; std::endl;
  }
  <span>return</span> EXIT_SUCCESS;
}</pre></div>
<h2 dir="auto"><a id="user-content-api" aria-hidden="true" href="#api"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>API</h2>
<p dir="auto">Our API is made of a few non-allocating function. They typically take a pointer and a length as a parameter,
and they sometimes take a pointer to an output buffer. Users are responsible for memory allocation.</p>
<div dir="auto" data-snippet-clipboard-copy-content="namespace simdutf {

/**
 * Validate the ASCII string.
 *
 * Overridden by each implementation.
 *
 * @param buf the ASCII string to validate.
 * @param len the length of the string in bytes.
 * @return true if and only if the string is valid ASCII.
 */
simdutf_warn_unused bool validate_ascii(const char *buf, size_t len) noexcept;

/**
 * Validate the ASCII string and stop on error.
 *
 * Overridden by each implementation.
 *
 * @param buf the ASCII string to validate.
 * @param len the length of the string in bytes.
 * @return a result pair struct with an error code and either the position of the error if any or the number of words validated if successful.
 */
simdutf_warn_unused result validate_ascii_with_errors(const char *buf, size_t len) noexcept;

/**
 * Validate the UTF-8 string.
 *
 * Overridden by each implementation.
 *
 * @param buf the UTF-8 string to validate.
 * @param len the length of the string in bytes.
 * @return true if and only if the string is valid UTF-8.
 */
simdutf_warn_unused bool validate_utf8(const char *buf, size_t len) noexcept;

/**
 * Validate the UTF-8 string and stop on error.
 *
 * Overridden by each implementation.
 *
 * @param buf the UTF-8 string to validate.
 * @param len the length of the string in bytes.
 * @return a result pair struct with an error code and either the position of the error if any or the number of words validated if successful.
 */
simdutf_warn_unused result validate_utf8_with_errors(const char *buf, size_t len) noexcept;

/**
 * Validate the UTF-16LE string.
 *
 * Overridden by each implementation.
 *
 * This function is not BOM-aware.
 *
 * @param buf the UTF-16LE string to validate.
 * @param len the length of the string in number of 2-byte words (char16_t).
 * @return true if and only if the string is valid UTF-16LE.
 */
simdutf_warn_unused bool validate_utf16le(const char16_t *buf, size_t len) noexcept;

/**
 * Validate the UTF-16BE string.
 *
 * Overridden by each implementation.
 *
 * This function is not BOM-aware.
 *
 * @param buf the UTF-16BE string to validate.
 * @param len the length of the string in number of 2-byte words (char16_t).
 * @return true if and only if the string is valid UTF-16BE.
 */
simdutf_warn_unused bool validate_utf16be(const char16_t *buf, size_t len) noexcept;

/**
 * Validate the UTF-16LE string and stop on error.
 *
 * Overridden by each implementation.
 *
 * This function is not BOM-aware.
 *
 * @param buf the UTF-16LE string to validate.
 * @param len the length of the string in number of 2-byte words (char16_t).
 * @return a result pair struct with an error code and either the position of the error if any or the number of words validated if successful.
 */
simdutf_warn_unused result validate_utf16le_with_errors(const char16_t *buf, size_t len) noexcept;

/**
 * Validate the UTF-16BE string and stop on error.
 *
 * Overridden by each implementation.
 *
 * This function is not BOM-aware.
 *
 * @param buf the UTF-16BE string to validate.
 * @param len the length of the string in number of 2-byte words (char16_t).
 * @return a result pair struct with an error code and either the position of the error if any or the number of words validated if successful.
 */
simdutf_warn_unused result validate_utf16be_with_errors(const char16_t *buf, size_t len) noexcept;

/**
 * Validate the UTF-32LE string.
 *
 * Overridden by each implementation.
 *
 * This function is not BOM-aware.
 *
 * @param buf the UTF-32LE string to validate.
 * @param len the length of the string in number of 4-byte words (char32_t).
 * @return true if and only if the string is valid UTF-32LE.
 */
simdutf_warn_unused bool validate_utf32(const char32_t *buf, size_t len) noexcept;

/**
 * Validate the UTF-32LE string and stop on error.
 *
 * Overridden by each implementation.
 *
 * This function is not BOM-aware.
 *
 * @param buf the UTF-32LE string to validate.
 * @param len the length of the string in number of 4-byte words (char32_t).
 * @return a result pair struct with an error code and either the position of the error if any or the number of words validated if successful.
 */
simdutf_warn_unused result validate_utf32_with_errors(const char32_t *buf, size_t len) noexcept;


/**
 * Convert possibly broken UTF-8 string into UTF-16LE string.
 *
 * During the conversion also validation of the input string is done.
 * This function is suitable to work with inputs from untrusted sources.
 *
 * @param input         the UTF-8 string to convert
 * @param length        the length of the string in bytes
 * @param utf16_buffer  the pointer to buffer that can hold conversion result
 * @return the number of written char16_t; 0 if the input was not valid UTF-8 string
 */
simdutf_warn_unused size_t convert_utf8_to_utf16le(const char * input, size_t length, char16_t* utf16_output) noexcept;

/**
 * Convert possibly broken UTF-8 string into UTF-16BE string.
 *
 * During the conversion also validation of the input string is done.
 * This function is suitable to work with inputs from untrusted sources.
 *
 * @param input         the UTF-8 string to convert
 * @param length        the length of the string in bytes
 * @param utf16_buffer  the pointer to buffer that can hold conversion result
 * @return the number of written char16_t; 0 if the input was not valid UTF-8 string
 */
simdutf_warn_unused size_t convert_utf8_to_utf16be(const char * input, size_t length, char16_t* utf16_output) noexcept;

/**
 * Convert possibly broken UTF-8 string into UTF-16LE string and stop on error.
 *
 * During the conversion also validation of the input string is done.
 * This function is suitable to work with inputs from untrusted sources.
 *
 * @param input         the UTF-8 string to convert
 * @param length        the length of the string in bytes
 * @param utf16_buffer  the pointer to buffer that can hold conversion result
 * @return a result pair struct with an error code and either the position of the error if any or the number of char16_t written if successful.
 */
simdutf_warn_unused result convert_utf8_to_utf16le_with_errors(const char * input, size_t length, char16_t* utf16_output) noexcept;

/**
 * Convert possibly broken UTF-8 string into UTF-16BE string and stop on error.
 *
 * During the conversion also validation of the input string is done.
 * This function is suitable to work with inputs from untrusted sources.
 *
 * @param input         the UTF-8 string to convert
 * @param length        the length of the string in bytes
 * @param utf16_buffer  the pointer to buffer that can hold conversion result
 * @return a result pair struct with an error code and either the position of the error if any or the number of char16_t written if successful.
 */
simdutf_warn_unused result convert_utf8_to_utf16be_with_errors(const char * input, size_t length, char16_t* utf16_output) noexcept;

/**
 * Convert valid UTF-8 string into UTF-16LE string.
 *
 * This function assumes that the input string is valid UTF-8.
 *
 * @param input         the UTF-8 string to convert
 * @param length        the length of the string in bytes
 * @param utf16_buffer  the pointer to buffer that can hold conversion result
 * @return the number of written char16_t
 */
simdutf_warn_unused size_t convert_valid_utf8_to_utf16le(const char * input, size_t length, char16_t* utf16_buffer) noexcept;

/**
 * Convert valid UTF-8 string into UTF-16BE string.
 *
 * This function assumes that the input string is valid UTF-8.
 *
 * @param input         the UTF-8 string to convert
 * @param length        the length of the string in bytes
 * @param utf16_buffer  the pointer to buffer that can hold conversion result
 * @return the number of written char16_t
 */
simdutf_warn_unused size_t convert_valid_utf8_to_utf16be(const char * input, size_t length, char16_t* utf16_buffer) noexcept;

/**
 * Compute the number of 2-byte words that this UTF-8 string would require in UTF-16 format.
 *
 * This function does not validate the input.
 *
 * @param input         the UTF-8 string to process
 * @param length        the length of the string in bytes
 * @return the number of char16_t words required to encode the UTF-8 string as UTF-16
 */
simdutf_warn_unused size_t utf16_length_from_utf8(const char * input, size_t length) noexcept;

/**
 * Convert possibly broken UTF-8 string into UTF-32LE string.
 *
 * During the conversion also validation of the input string is done.
 * This function is suitable to work with inputs from untrusted sources.
 *
 * @param input         the UTF-8 string to convert
 * @param length        the length of the string in bytes
 * @param utf32_buffer  the pointer to buffer that can hold conversion result
 * @return the number of written char32_t; 0 if the input was not valid UTF-8 string
 */
simdutf_warn_unused size_t convert_utf8_to_utf32(const char * input, size_t length, char32_t* utf32_output) noexcept;

/**
 * Convert possibly broken UTF-8 string into UTF-32LE string and stop on error.
 *
 * During the conversion also validation of the input string is done.
 * This function is suitable to work with inputs from untrusted sources.
 *
 * @param input         the UTF-8 string to convert
 * @param length        the length of the string in bytes
 * @param utf32_buffer  the pointer to buffer that can hold conversion result
 * @return a result pair struct with an error code and either the position of the error if any or the number of char32_t written if successful.
 */
simdutf_warn_unused result convert_utf8_to_utf32_with_errors(const char * input, size_t length, char32_t* utf32_output) noexcept;

/**
 * Convert valid UTF-8 string into UTF-32LE string.
 *
 * This function assumes that the input string is valid UTF-8.
 *
 * @param input         the UTF-8 string to convert
 * @param length        the length of the string in bytes
 * @param utf32_buffer  the pointer to buffer that can hold conversion result
 * @return the number of written char32_t
 */
simdutf_warn_unused size_t convert_valid_utf8_to_utf32(const char * input, size_t length, char32_t* utf32_buffer) noexcept;

/**
 * Compute the number of 4-byte words that this UTF-8 string would require in UTF-32LE format.
 *
 * This function is equivalent to count_utf8
 *
 * This function does not validate the input.
 *
 * This function is not BOM-aware.
 *
 * @param input         the UTF-8 string to process
 * @param length        the length of the string in bytes
 * @return the number of char32_t words required to encode the UTF-8 string as UTF-32LE
 */
simdutf_warn_unused size_t utf32_length_from_utf8(const char * input, size_t length) noexcept;

/**
 * Convert possibly broken UTF-16LE string into UTF-8 string.
 *
 * During the conversion also validation of the input string is done.
 * This function is suitable to work with inputs from untrusted sources.
 *
 * This function is not BOM-aware.
 *
 * @param input         the UTF-16LE string to convert
 * @param length        the length of the string in 2-byte words (char16_t)
 * @param utf8_buffer   the pointer to buffer that can hold conversion result
 * @return number of written words; 0 if input is not a valid UTF-16LE string
 */
simdutf_warn_unused size_t convert_utf16le_to_utf8(const char16_t * input, size_t length, char* utf8_buffer) noexcept;

/**
 * Convert possibly broken UTF-16BE string into UTF-8 string.
 *
 * During the conversion also validation of the input string is done.
 * This function is suitable to work with inputs from untrusted sources.
 *
 * This function is not BOM-aware.
 *
 * @param input         the UTF-16BE string to convert
 * @param length        the length of the string in 2-byte words (char16_t)
 * @param utf8_buffer   the pointer to buffer that can hold conversion result
 * @return number of written words; 0 if input is not a valid UTF-16LE string
 */
simdutf_warn_unused size_t convert_utf16be_to_utf8(const char16_t * input, size_t length, char* utf8_buffer) noexcept;

/**
 * Convert possibly broken UTF-16LE string into UTF-8 string and stop on error.
 *
 * During the conversion also validation of the input string is done.
 * This function is suitable to work with inputs from untrusted sources.
 *
 * This function is not BOM-aware.
 *
 * @param input         the UTF-16LE string to convert
 * @param length        the length of the string in 2-byte words (char16_t)
 * @param utf8_buffer   the pointer to buffer that can hold conversion result
 * @return a result pair struct with an error code and either the position of the error if any or the number of char written if successful.
 */
simdutf_warn_unused result convert_utf16le_to_utf8_with_errors(const char16_t * input, size_t length, char* utf8_buffer) noexcept;

/**
 * Convert possibly broken UTF-16BE string into UTF-8 string and stop on error.
 *
 * During the conversion also validation of the input string is done.
 * This function is suitable to work with inputs from untrusted sources.
 *
 * This function is not BOM-aware.
 *
 * @param input         the UTF-16BE string to convert
 * @param length        the length of the string in 2-byte words (char16_t)
 * @param utf8_buffer   the pointer to buffer that can hold conversion result
 * @return a result pair struct with an error code and either the position of the error if any or the number of char written if successful.
 */
simdutf_warn_unused result convert_utf16be_to_utf8_with_errors(const char16_t * input, size_t length, char* utf8_buffer) noexcept;

/**
 * Convert valid UTF-16LE string into UTF-8 string.
 *
 * This function assumes that the input string is valid UTF-16LE.
 *
 * This function is not BOM-aware.
 *
 * @param input         the UTF-16LE string to convert
 * @param length        the length of the string in 2-byte words (char16_t)
 * @param utf8_buffer   the pointer to buffer that can hold the conversion result
 * @return number of written words; 0 if conversion is not possible
 */
simdutf_warn_unused size_t convert_valid_utf16le_to_utf8(const char16_t * input, size_t length, char* utf8_buffer) noexcept;

/**
 * Convert valid UTF-16BE string into UTF-8 string.
 *
 * This function assumes that the input string is valid UTF-16BE.
 *
 * This function is not BOM-aware.
 *
 * @param input         the UTF-16BE string to convert
 * @param length        the length of the string in 2-byte words (char16_t)
 * @param utf8_buffer   the pointer to buffer that can hold the conversion result
 * @return number of written words; 0 if conversion is not possible
 */
simdutf_warn_unused size_t convert_valid_utf16be_to_utf8(const char16_t * input, size_t length, char* utf8_buffer) noexcept;

/**
 * Compute the number of bytes that this UTF-16LE string would require in UTF-8 format.
 *
 * This function does not validate the input.
 *
 * @param input         the UTF-16LE string to convert
 * @param length        the length of the string in 2-byte words (char16_t)
 * @return the number of bytes required to encode the UTF-16LE string as UTF-8
 */
simdutf_warn_unused size_t utf8_length_from_utf16le(const char16_t * input, size_t length) noexcept;

/**
 * Compute the number of bytes that this UTF-16BE string would require in UTF-8 format.
 *
 * This function does not validate the input.
 *
 * @param input         the UTF-16BE string to convert
 * @param length        the length of the string in 2-byte words (char16_t)
 * @return the number of bytes required to encode the UTF-16BE string as UTF-8
 */
simdutf_warn_unused size_t utf8_length_from_utf16be(const char16_t * input, size_t length) noexcept;

/**
 * Convert possibly broken UTF-32LE string into UTF-8 string.
 *
 * During the conversion also validation of the input string is done.
 * This function is suitable to work with inputs from untrusted sources.
 *
 * This function is not BOM-aware.
 *
 * @param input         the UTF-32LE string to convert
 * @param length        the length of the string in 4-byte words (char32_t)
 * @param utf8_buffer   the pointer to buffer that can hold conversion result
 * @return number of written words; 0 if input is not a valid UTF-32LE string
 */
simdutf_warn_unused size_t convert_utf32_to_utf8(const char32_t * input, size_t length, char* utf8_buffer) noexcept;


/**
 * Convert possibly broken UTF-32LE string into UTF-8 string and stop on error.
 *
 * During the conversion also validation of the input string is done.
 * This function is suitable to work with inputs from untrusted sources.
 *
 * This function is not BOM-aware.
 *
 * @param input         the UTF-32LE string to convert
 * @param length        the length of the string in 4-byte words (char32_t)
 * @param utf8_buffer   the pointer to buffer that can hold conversion result
 * @return a result pair struct with an error code and either the position of the error if any or the number of char written if successful.
 */
simdutf_warn_unused result convert_utf32_to_utf8_with_errors(const char32_t * input, size_t length, char* utf8_buffer) noexcept;

/**
 * Convert valid UTF-32LE string into UTF-8 string.
 *
 * This function assumes that the input string is valid UTF-32LE.
 *
 * This function is not BOM-aware.
 *
 * @param input         the UTF-32LE string to convert
 * @param length        the length of the string in 4-byte words (char32_t)
 * @param utf8_buffer   the pointer to buffer that can hold the conversion result
 * @return number of written words; 0 if conversion is not possible
 */
simdutf_warn_unused size_t convert_valid_utf32_to_utf8(const char32_t * input, size_t length, char* utf8_buffer) noexcept;

/**
 * Convert possibly broken UTF-32LE string into UTF-16LE string.
 *
 * During the conversion also validation of the input string is done.
 * This function is suitable to work with inputs from untrusted sources.
 *
 * This function is not BOM-aware.
 *
 * @param input         the UTF-32LE string to convert
 * @param length        the length of the string in 4-byte words (char32_t)
 * @param utf16_buffer   the pointer to buffer that can hold conversion result
 * @return number of written words; 0 if input is not a valid UTF-32LE string
 */
simdutf_warn_unused size_t convert_utf32_to_utf16le(const char32_t * input, size_t length, char16_t* utf16_buffer) noexcept;

/**
 * Convert possibly broken UTF-32LE string into UTF-16BE string.
 *
 * During the conversion also validation of the input string is done.
 * This function is suitable to work with inputs from untrusted sources.
 *
 * This function is not BOM-aware.
 *
 * @param input         the UTF-32LE string to convert
 * @param length        the length of the string in 4-byte words (char32_t)
 * @param utf16_buffer   the pointer to buffer that can hold conversion result
 * @return number of written words; 0 if input is not a valid UTF-32LE string
 */
simdutf_warn_unused size_t convert_utf32_to_utf16be(const char32_t * input, size_t length, char16_t* utf16_buffer) noexcept;

/**
 * Convert possibly broken UTF-32LE string into UTF-16LE string and stop on error.
 *
 * During the conversion also validation of the input string is done.
 * This function is suitable to work with inputs from untrusted sources.
 *
 * This function is not BOM-aware.
 *
 * @param input         the UTF-32LE string to convert
 * @param length        the length of the string in 4-byte words (char32_t)
 * @param utf16_buffer   the pointer to buffer that can hold conversion result
 * @return a result pair struct with an error code and either the position of the error if any or the number of char16_t written if successful.
 */
simdutf_warn_unused result convert_utf32_to_utf16le_with_errors(const char32_t * input, size_t length, char16_t* utf16_buffer) noexcept;

/**
 * Convert possibly broken UTF-32LE string into UTF-16BE string and stop on error.
 *
 * During the conversion also validation of the input string is done.
 * This function is suitable to work with inputs from untrusted sources.
 *
 * This function is not BOM-aware.
 *
 * @param input         the UTF-32LE string to convert
 * @param length        the length of the string in 4-byte words (char32_t)
 * @param utf16_buffer   the pointer to buffer that can hold conversion result
 * @return a result pair struct with an error code and either the position of the error if any or the number of char16_t written if successful.
 */
simdutf_warn_unused result convert_utf32_to_utf16be_with_errors(const char32_t * input, size_t length, char16_t* utf16_buffer) noexcept;

/**
 * Convert valid UTF-32LE string into UTF-16LE string.
 *
 * This function assumes that the input string is valid UTF-32LE.
 *
 * This function is not BOM-aware.
 *
 * @param input         the UTF-32LE string to convert
 * @param length        the length of the string in 4-byte words (char32_t)
 * @param utf16_buffer   the pointer to buffer that can hold the conversion result
 * @return number of written words; 0 if conversion is not possible
 */
simdutf_warn_unused size_t convert_valid_utf32_to_utf16le(const char32_t * input, size_t length, char16_t* utf16_buffer) noexcept;

/**
 * Convert valid UTF-32LE string into UTF-16BE string.
 *
 * This function assumes that the input string is valid UTF-32LE.
 *
 * This function is not BOM-aware.
 *
 * @param input         the UTF-32LE string to convert
 * @param length        the length of the string in 4-byte words (char32_t)
 * @param utf16_buffer   the pointer to buffer that can hold the conversion result
 * @return number of written words; 0 if conversion is not possible
 */
simdutf_warn_unused size_t convert_valid_utf32_to_utf16be(const char32_t * input, size_t length, char16_t* utf16_buffer) noexcept;

/**
 * Compute the number of bytes that this UTF-32LE string would require in UTF-8 format.
 *
 * This function does not validate the input.
 *
 * @param input         the UTF-32LE string to convert
 * @param length        the length of the string in 4-byte words (char32_t)
 * @return the number of bytes required to encode the UTF-32LE string as UTF-8
 */
simdutf_warn_unused size_t utf8_length_from_utf32(const char32_t * input, size_t length) noexcept;

/**
 * Compute the number of two-byte words that this UTF-32LE string would require in UTF-16 format.
 *
 * This function does not validate the input.
 *
 * @param input         the UTF-32LE string to convert
 * @param length        the length of the string in 4-byte words (char32_t)
 * @return the number of bytes required to encode the UTF-32LE string as UTF-16
 */
simdutf_warn_unused size_t utf16_length_from_utf32(const char32_t * input, size_t length) noexcept;

/**
 * Convert possibly broken UTF-16LE string into UTF-32LE string.
 *
 * During the conversion also validation of the input string is done.
 * This function is suitable to work with inputs from untrusted sources.
 *
 * This function is not BOM-aware.
 *
 * @param input         the UTF-16LE string to convert
 * @param length        the length of the string in 2-byte words (char16_t)
 * @param utf32_buffer   the pointer to buffer that can hold conversion result
 * @return number of written words; 0 if input is not a valid UTF-16LE string
 */
simdutf_warn_unused size_t convert_utf16le_to_utf32(const char16_t * input, size_t length, char32_t* utf32_buffer) noexcept;

/**
 * Convert possibly broken UTF-16BE string into UTF-32LE string.
 *
 * During the conversion also validation of the input string is done.
 * This function is suitable to work with inputs from untrusted sources.
 *
 * This function is not BOM-aware.
 *
 * @param input         the UTF-16BE string to convert
 * @param length        the length of the string in 2-byte words (char16_t)
 * @param utf32_buffer   the pointer to buffer that can hold conversion result
 * @return number of written words; 0 if input is not a valid UTF-16LE string
 */
simdutf_warn_unused size_t convert_utf16be_to_utf32(const char16_t * input, size_t length, char32_t* utf32_buffer) noexcept;

/**
 * Convert possibly broken UTF-16LE string into UTF-32LE string and stop on error.
 *
 * During the conversion also validation of the input string is done.
 * This function is suitable to work with inputs from untrusted sources.
 *
 * This function is not BOM-aware.
 *
 * @param input         the UTF-16LE string to convert
 * @param length        the length of the string in 2-byte words (char16_t)
 * @param utf32_buffer   the pointer to buffer that can hold conversion result
 * @return a result pair struct with an error code and either the position of the error if any or the number of char32_t written if successful.
 */
simdutf_warn_unused result convert_utf16le_to_utf32_with_errors(const char16_t * input, size_t length, char32_t* utf32_buffer) noexcept;

/**
 * Convert possibly broken UTF-16BE string into UTF-32LE string and stop on error.
 *
 * During the conversion also validation of the input string is done.
 * This function is suitable to work with inputs from untrusted sources.
 *
 * This function is not BOM-aware.
 *
 * @param input         the UTF-16BE string to convert
 * @param length        the length of the string in 2-byte words (char16_t)
 * @param utf32_buffer   the pointer to buffer that can hold conversion result
 * @return a result pair struct with an error code and either the position of the error if any or the number of char32_t written if successful.
 */
simdutf_warn_unused result convert_utf16be_to_utf32_with_errors(const char16_t * input, size_t length, char32_t* utf32_buffer) noexcept;

/**
 * Convert valid UTF-16LE string into UTF-32LE string.
 *
 * This function assumes that the input string is valid UTF-16LE.
 *
 * This function is not BOM-aware.
 *
 * @param input         the UTF-16LE string to convert
 * @param length        the length of the string in 2-byte words (char16_t)
 * @param utf32_buffer   the pointer to buffer that can hold the conversion result
 * @return number of written words; 0 if conversion is not possible
 */
simdutf_warn_unused size_t convert_valid_utf16le_to_utf32(const char16_t * input, size_t length, char32_t* utf32_buffer) noexcept;

/**
 * Convert valid UTF-16BE string into UTF-32LE string.
 *
 * This function assumes that the input string is valid UTF-16LE.
 *
 * This function is not BOM-aware.
 *
 * @param input         the UTF-16BE string to convert
 * @param length        the length of the string in 2-byte words (char16_t)
 * @param utf32_buffer   the pointer to buffer that can hold the conversion result
 * @return number of written words; 0 if conversion is not possible
 */
simdutf_warn_unused size_t convert_valid_utf16be_to_utf32(const char16_t * input, size_t length, char32_t* utf32_buffer) noexcept;

/**
 * Compute the number of bytes that this UTF-16LE string would require in UTF-32LE format.
 *
 * This function is equivalent to count_utf16le.
 *
 * This function does not validate the input.
 *
 * This function is not BOM-aware.
 *
 * @param input         the UTF-16LE string to convert
 * @param length        the length of the string in 2-byte words (char16_t)
 * @return the number of bytes required to encode the UTF-16LE string as UTF-32LE
 */
simdutf_warn_unused size_t utf32_length_from_utf16le(const char16_t * input, size_t length) noexcept;

/**
 * Compute the number of bytes that this UTF-16BE string would require in UTF-32LE format.
 *
 * This function is equivalent to count_utf16be.
 *
 * This function does not validate the input.
 *
 * This function is not BOM-aware.
 *
 * @param input         the UTF-16BE string to convert
 * @param length        the length of the string in 2-byte words (char16_t)
 * @return the number of bytes required to encode the UTF-16BE string as UTF-32LE
 */
simdutf_warn_unused size_t utf32_length_from_utf16be(const char16_t * input, size_t length) noexcept;

/**
 * Count the number of code points (characters) in the string assuming that
 * it is valid.
 *
 * This function assumes that the input string is valid UTF-16LE.
 *
 * This function is not BOM-aware.
 *
 * @param input         the UTF-16LE string to process
 * @param length        the length of the string in 2-byte words (char16_t)
 * @return number of code points
 */
simdutf_warn_unused size_t count_utf16le(const char16_t * input, size_t length) noexcept;

/**
 * Count the number of code points (characters) in the string assuming that
 * it is valid.
 *
 * This function assumes that the input string is valid UTF-16BE.
 *
 * This function is not BOM-aware.
 *
 * @param input         the UTF-16BE string to process
 * @param length        the length of the string in 2-byte words (char16_t)
 * @return number of code points
 */
simdutf_warn_unused size_t count_utf16be(const char16_t * input, size_t length) noexcept;

/**
 * Count the number of code points (characters) in the string assuming that
 * it is valid.
 *
 * This function assumes that the input string is valid UTF-8.
 *
 * @param input         the UTF-8 string to process
 * @param length        the length of the string in bytes
 * @return number of code points
 */
simdutf_warn_unused size_t count_utf8(const char * input, size_t length) noexcept;

/**
 * Change the endianness of the input. Can be used to go from UTF-16LE to UTF-16BE or
 * from UTF-16BE to UTF-16LE.
 *
 * This function does not validate the input.
 *
 * This function is not BOM-aware.
 *
 * @param input         the UTF-16 string to process
 * @param length        the length of the string in 2-byte words (char16_t)
 * @param output        the pointer to buffer that can hold the conversion result
 */
void change_endianness_utf16(const char16_t * input, size_t length, char16_t * output) noexcept;

}"><pre><span>namespace</span> <span>simdutf</span> {

<span><span>/*</span>*</span>
<span> * Validate the ASCII string.</span>
<span> *</span>
<span> * Overridden by each implementation.</span>
<span> *</span>
<span> * @param buf the ASCII string to validate.</span>
<span> * @param len the length of the string in bytes.</span>
<span> * @return true if and only if the string is valid ASCII.</span>
<span> <span>*/</span></span>
simdutf_warn_unused <span>bool</span> <span>validate_ascii</span>(<span>const</span> <span>char</span> *buf, <span>size_t</span> len) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Validate the ASCII string and stop on error.</span>
<span> *</span>
<span> * Overridden by each implementation.</span>
<span> *</span>
<span> * @param buf the ASCII string to validate.</span>
<span> * @param len the length of the string in bytes.</span>
<span> * @return a result pair struct with an error code and either the position of the error if any or the number of words validated if successful.</span>
<span> <span>*/</span></span>
simdutf_warn_unused result <span>validate_ascii_with_errors</span>(<span>const</span> <span>char</span> *buf, <span>size_t</span> len) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Validate the UTF-8 string.</span>
<span> *</span>
<span> * Overridden by each implementation.</span>
<span> *</span>
<span> * @param buf the UTF-8 string to validate.</span>
<span> * @param len the length of the string in bytes.</span>
<span> * @return true if and only if the string is valid UTF-8.</span>
<span> <span>*/</span></span>
simdutf_warn_unused <span>bool</span> <span>validate_utf8</span>(<span>const</span> <span>char</span> *buf, <span>size_t</span> len) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Validate the UTF-8 string and stop on error.</span>
<span> *</span>
<span> * Overridden by each implementation.</span>
<span> *</span>
<span> * @param buf the UTF-8 string to validate.</span>
<span> * @param len the length of the string in bytes.</span>
<span> * @return a result pair struct with an error code and either the position of the error if any or the number of words validated if successful.</span>
<span> <span>*/</span></span>
simdutf_warn_unused result <span>validate_utf8_with_errors</span>(<span>const</span> <span>char</span> *buf, <span>size_t</span> len) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Validate the UTF-16LE string.</span>
<span> *</span>
<span> * Overridden by each implementation.</span>
<span> *</span>
<span> * This function is not BOM-aware.</span>
<span> *</span>
<span> * @param buf the UTF-16LE string to validate.</span>
<span> * @param len the length of the string in number of 2-byte words (char16_t).</span>
<span> * @return true if and only if the string is valid UTF-16LE.</span>
<span> <span>*/</span></span>
simdutf_warn_unused <span>bool</span> <span>validate_utf16le</span>(<span>const</span> <span>char16_t</span> *buf, <span>size_t</span> len) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Validate the UTF-16BE string.</span>
<span> *</span>
<span> * Overridden by each implementation.</span>
<span> *</span>
<span> * This function is not BOM-aware.</span>
<span> *</span>
<span> * @param buf the UTF-16BE string to validate.</span>
<span> * @param len the length of the string in number of 2-byte words (char16_t).</span>
<span> * @return true if and only if the string is valid UTF-16BE.</span>
<span> <span>*/</span></span>
simdutf_warn_unused <span>bool</span> <span>validate_utf16be</span>(<span>const</span> <span>char16_t</span> *buf, <span>size_t</span> len) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Validate the UTF-16LE string and stop on error.</span>
<span> *</span>
<span> * Overridden by each implementation.</span>
<span> *</span>
<span> * This function is not BOM-aware.</span>
<span> *</span>
<span> * @param buf the UTF-16LE string to validate.</span>
<span> * @param len the length of the string in number of 2-byte words (char16_t).</span>
<span> * @return a result pair struct with an error code and either the position of the error if any or the number of words validated if successful.</span>
<span> <span>*/</span></span>
simdutf_warn_unused result <span>validate_utf16le_with_errors</span>(<span>const</span> <span>char16_t</span> *buf, <span>size_t</span> len) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Validate the UTF-16BE string and stop on error.</span>
<span> *</span>
<span> * Overridden by each implementation.</span>
<span> *</span>
<span> * This function is not BOM-aware.</span>
<span> *</span>
<span> * @param buf the UTF-16BE string to validate.</span>
<span> * @param len the length of the string in number of 2-byte words (char16_t).</span>
<span> * @return a result pair struct with an error code and either the position of the error if any or the number of words validated if successful.</span>
<span> <span>*/</span></span>
simdutf_warn_unused result <span>validate_utf16be_with_errors</span>(<span>const</span> <span>char16_t</span> *buf, <span>size_t</span> len) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Validate the UTF-32LE string.</span>
<span> *</span>
<span> * Overridden by each implementation.</span>
<span> *</span>
<span> * This function is not BOM-aware.</span>
<span> *</span>
<span> * @param buf the UTF-32LE string to validate.</span>
<span> * @param len the length of the string in number of 4-byte words (char32_t).</span>
<span> * @return true if and only if the string is valid UTF-32LE.</span>
<span> <span>*/</span></span>
simdutf_warn_unused <span>bool</span> <span>validate_utf32</span>(<span>const</span> <span>char32_t</span> *buf, <span>size_t</span> len) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Validate the UTF-32LE string and stop on error.</span>
<span> *</span>
<span> * Overridden by each implementation.</span>
<span> *</span>
<span> * This function is not BOM-aware.</span>
<span> *</span>
<span> * @param buf the UTF-32LE string to validate.</span>
<span> * @param len the length of the string in number of 4-byte words (char32_t).</span>
<span> * @return a result pair struct with an error code and either the position of the error if any or the number of words validated if successful.</span>
<span> <span>*/</span></span>
simdutf_warn_unused result <span>validate_utf32_with_errors</span>(<span>const</span> <span>char32_t</span> *buf, <span>size_t</span> len) <span>noexcept</span>;


<span><span>/*</span>*</span>
<span> * Convert possibly broken UTF-8 string into UTF-16LE string.</span>
<span> *</span>
<span> * During the conversion also validation of the input string is done.</span>
<span> * This function is suitable to work with inputs from untrusted sources.</span>
<span> *</span>
<span> * @param input         the UTF-8 string to convert</span>
<span> * @param length        the length of the string in bytes</span>
<span> * @param utf16_buffer  the pointer to buffer that can hold conversion result</span>
<span> * @return the number of written char16_t; 0 if the input was not valid UTF-8 string</span>
<span> <span>*/</span></span>
simdutf_warn_unused <span>size_t</span> <span>convert_utf8_to_utf16le</span>(<span>const</span> <span>char</span> * input, <span>size_t</span> length, <span>char16_t</span>* utf16_output) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Convert possibly broken UTF-8 string into UTF-16BE string.</span>
<span> *</span>
<span> * During the conversion also validation of the input string is done.</span>
<span> * This function is suitable to work with inputs from untrusted sources.</span>
<span> *</span>
<span> * @param input         the UTF-8 string to convert</span>
<span> * @param length        the length of the string in bytes</span>
<span> * @param utf16_buffer  the pointer to buffer that can hold conversion result</span>
<span> * @return the number of written char16_t; 0 if the input was not valid UTF-8 string</span>
<span> <span>*/</span></span>
simdutf_warn_unused <span>size_t</span> <span>convert_utf8_to_utf16be</span>(<span>const</span> <span>char</span> * input, <span>size_t</span> length, <span>char16_t</span>* utf16_output) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Convert possibly broken UTF-8 string into UTF-16LE string and stop on error.</span>
<span> *</span>
<span> * During the conversion also validation of the input string is done.</span>
<span> * This function is suitable to work with inputs from untrusted sources.</span>
<span> *</span>
<span> * @param input         the UTF-8 string to convert</span>
<span> * @param length        the length of the string in bytes</span>
<span> * @param utf16_buffer  the pointer to buffer that can hold conversion result</span>
<span> * @return a result pair struct with an error code and either the position of the error if any or the number of char16_t written if successful.</span>
<span> <span>*/</span></span>
simdutf_warn_unused result <span>convert_utf8_to_utf16le_with_errors</span>(<span>const</span> <span>char</span> * input, <span>size_t</span> length, <span>char16_t</span>* utf16_output) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Convert possibly broken UTF-8 string into UTF-16BE string and stop on error.</span>
<span> *</span>
<span> * During the conversion also validation of the input string is done.</span>
<span> * This function is suitable to work with inputs from untrusted sources.</span>
<span> *</span>
<span> * @param input         the UTF-8 string to convert</span>
<span> * @param length        the length of the string in bytes</span>
<span> * @param utf16_buffer  the pointer to buffer that can hold conversion result</span>
<span> * @return a result pair struct with an error code and either the position of the error if any or the number of char16_t written if successful.</span>
<span> <span>*/</span></span>
simdutf_warn_unused result <span>convert_utf8_to_utf16be_with_errors</span>(<span>const</span> <span>char</span> * input, <span>size_t</span> length, <span>char16_t</span>* utf16_output) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Convert valid UTF-8 string into UTF-16LE string.</span>
<span> *</span>
<span> * This function assumes that the input string is valid UTF-8.</span>
<span> *</span>
<span> * @param input         the UTF-8 string to convert</span>
<span> * @param length        the length of the string in bytes</span>
<span> * @param utf16_buffer  the pointer to buffer that can hold conversion result</span>
<span> * @return the number of written char16_t</span>
<span> <span>*/</span></span>
simdutf_warn_unused <span>size_t</span> <span>convert_valid_utf8_to_utf16le</span>(<span>const</span> <span>char</span> * input, <span>size_t</span> length, <span>char16_t</span>* utf16_buffer) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Convert valid UTF-8 string into UTF-16BE string.</span>
<span> *</span>
<span> * This function assumes that the input string is valid UTF-8.</span>
<span> *</span>
<span> * @param input         the UTF-8 string to convert</span>
<span> * @param length        the length of the string in bytes</span>
<span> * @param utf16_buffer  the pointer to buffer that can hold conversion result</span>
<span> * @return the number of written char16_t</span>
<span> <span>*/</span></span>
simdutf_warn_unused <span>size_t</span> <span>convert_valid_utf8_to_utf16be</span>(<span>const</span> <span>char</span> * input, <span>size_t</span> length, <span>char16_t</span>* utf16_buffer) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Compute the number of 2-byte words that this UTF-8 string would require in UTF-16 format.</span>
<span> *</span>
<span> * This function does not validate the input.</span>
<span> *</span>
<span> * @param input         the UTF-8 string to process</span>
<span> * @param length        the length of the string in bytes</span>
<span> * @return the number of char16_t words required to encode the UTF-8 string as UTF-16</span>
<span> <span>*/</span></span>
simdutf_warn_unused <span>size_t</span> <span>utf16_length_from_utf8</span>(<span>const</span> <span>char</span> * input, <span>size_t</span> length) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Convert possibly broken UTF-8 string into UTF-32LE string.</span>
<span> *</span>
<span> * During the conversion also validation of the input string is done.</span>
<span> * This function is suitable to work with inputs from untrusted sources.</span>
<span> *</span>
<span> * @param input         the UTF-8 string to convert</span>
<span> * @param length        the length of the string in bytes</span>
<span> * @param utf32_buffer  the pointer to buffer that can hold conversion result</span>
<span> * @return the number of written char32_t; 0 if the input was not valid UTF-8 string</span>
<span> <span>*/</span></span>
simdutf_warn_unused <span>size_t</span> <span>convert_utf8_to_utf32</span>(<span>const</span> <span>char</span> * input, <span>size_t</span> length, <span>char32_t</span>* utf32_output) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Convert possibly broken UTF-8 string into UTF-32LE string and stop on error.</span>
<span> *</span>
<span> * During the conversion also validation of the input string is done.</span>
<span> * This function is suitable to work with inputs from untrusted sources.</span>
<span> *</span>
<span> * @param input         the UTF-8 string to convert</span>
<span> * @param length        the length of the string in bytes</span>
<span> * @param utf32_buffer  the pointer to buffer that can hold conversion result</span>
<span> * @return a result pair struct with an error code and either the position of the error if any or the number of char32_t written if successful.</span>
<span> <span>*/</span></span>
simdutf_warn_unused result <span>convert_utf8_to_utf32_with_errors</span>(<span>const</span> <span>char</span> * input, <span>size_t</span> length, <span>char32_t</span>* utf32_output) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Convert valid UTF-8 string into UTF-32LE string.</span>
<span> *</span>
<span> * This function assumes that the input string is valid UTF-8.</span>
<span> *</span>
<span> * @param input         the UTF-8 string to convert</span>
<span> * @param length        the length of the string in bytes</span>
<span> * @param utf32_buffer  the pointer to buffer that can hold conversion result</span>
<span> * @return the number of written char32_t</span>
<span> <span>*/</span></span>
simdutf_warn_unused <span>size_t</span> <span>convert_valid_utf8_to_utf32</span>(<span>const</span> <span>char</span> * input, <span>size_t</span> length, <span>char32_t</span>* utf32_buffer) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Compute the number of 4-byte words that this UTF-8 string would require in UTF-32LE format.</span>
<span> *</span>
<span> * This function is equivalent to count_utf8</span>
<span> *</span>
<span> * This function does not validate the input.</span>
<span> *</span>
<span> * This function is not BOM-aware.</span>
<span> *</span>
<span> * @param input         the UTF-8 string to process</span>
<span> * @param length        the length of the string in bytes</span>
<span> * @return the number of char32_t words required to encode the UTF-8 string as UTF-32LE</span>
<span> <span>*/</span></span>
simdutf_warn_unused <span>size_t</span> <span>utf32_length_from_utf8</span>(<span>const</span> <span>char</span> * input, <span>size_t</span> length) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Convert possibly broken UTF-16LE string into UTF-8 string.</span>
<span> *</span>
<span> * During the conversion also validation of the input string is done.</span>
<span> * This function is suitable to work with inputs from untrusted sources.</span>
<span> *</span>
<span> * This function is not BOM-aware.</span>
<span> *</span>
<span> * @param input         the UTF-16LE string to convert</span>
<span> * @param length        the length of the string in 2-byte words (char16_t)</span>
<span> * @param utf8_buffer   the pointer to buffer that can hold conversion result</span>
<span> * @return number of written words; 0 if input is not a valid UTF-16LE string</span>
<span> <span>*/</span></span>
simdutf_warn_unused <span>size_t</span> <span>convert_utf16le_to_utf8</span>(<span>const</span> <span>char16_t</span> * input, <span>size_t</span> length, <span>char</span>* utf8_buffer) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Convert possibly broken UTF-16BE string into UTF-8 string.</span>
<span> *</span>
<span> * During the conversion also validation of the input string is done.</span>
<span> * This function is suitable to work with inputs from untrusted sources.</span>
<span> *</span>
<span> * This function is not BOM-aware.</span>
<span> *</span>
<span> * @param input         the UTF-16BE string to convert</span>
<span> * @param length        the length of the string in 2-byte words (char16_t)</span>
<span> * @param utf8_buffer   the pointer to buffer that can hold conversion result</span>
<span> * @return number of written words; 0 if input is not a valid UTF-16LE string</span>
<span> <span>*/</span></span>
simdutf_warn_unused <span>size_t</span> <span>convert_utf16be_to_utf8</span>(<span>const</span> <span>char16_t</span> * input, <span>size_t</span> length, <span>char</span>* utf8_buffer) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Convert possibly broken UTF-16LE string into UTF-8 string and stop on error.</span>
<span> *</span>
<span> * During the conversion also validation of the input string is done.</span>
<span> * This function is suitable to work with inputs from untrusted sources.</span>
<span> *</span>
<span> * This function is not BOM-aware.</span>
<span> *</span>
<span> * @param input         the UTF-16LE string to convert</span>
<span> * @param length        the length of the string in 2-byte words (char16_t)</span>
<span> * @param utf8_buffer   the pointer to buffer that can hold conversion result</span>
<span> * @return a result pair struct with an error code and either the position of the error if any or the number of char written if successful.</span>
<span> <span>*/</span></span>
simdutf_warn_unused result <span>convert_utf16le_to_utf8_with_errors</span>(<span>const</span> <span>char16_t</span> * input, <span>size_t</span> length, <span>char</span>* utf8_buffer) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Convert possibly broken UTF-16BE string into UTF-8 string and stop on error.</span>
<span> *</span>
<span> * During the conversion also validation of the input string is done.</span>
<span> * This function is suitable to work with inputs from untrusted sources.</span>
<span> *</span>
<span> * This function is not BOM-aware.</span>
<span> *</span>
<span> * @param input         the UTF-16BE string to convert</span>
<span> * @param length        the length of the string in 2-byte words (char16_t)</span>
<span> * @param utf8_buffer   the pointer to buffer that can hold conversion result</span>
<span> * @return a result pair struct with an error code and either the position of the error if any or the number of char written if successful.</span>
<span> <span>*/</span></span>
simdutf_warn_unused result <span>convert_utf16be_to_utf8_with_errors</span>(<span>const</span> <span>char16_t</span> * input, <span>size_t</span> length, <span>char</span>* utf8_buffer) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Convert valid UTF-16LE string into UTF-8 string.</span>
<span> *</span>
<span> * This function assumes that the input string is valid UTF-16LE.</span>
<span> *</span>
<span> * This function is not BOM-aware.</span>
<span> *</span>
<span> * @param input         the UTF-16LE string to convert</span>
<span> * @param length        the length of the string in 2-byte words (char16_t)</span>
<span> * @param utf8_buffer   the pointer to buffer that can hold the conversion result</span>
<span> * @return number of written words; 0 if conversion is not possible</span>
<span> <span>*/</span></span>
simdutf_warn_unused <span>size_t</span> <span>convert_valid_utf16le_to_utf8</span>(<span>const</span> <span>char16_t</span> * input, <span>size_t</span> length, <span>char</span>* utf8_buffer) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Convert valid UTF-16BE string into UTF-8 string.</span>
<span> *</span>
<span> * This function assumes that the input string is valid UTF-16BE.</span>
<span> *</span>
<span> * This function is not BOM-aware.</span>
<span> *</span>
<span> * @param input         the UTF-16BE string to convert</span>
<span> * @param length        the length of the string in 2-byte words (char16_t)</span>
<span> * @param utf8_buffer   the pointer to buffer that can hold the conversion result</span>
<span> * @return number of written words; 0 if conversion is not possible</span>
<span> <span>*/</span></span>
simdutf_warn_unused <span>size_t</span> <span>convert_valid_utf16be_to_utf8</span>(<span>const</span> <span>char16_t</span> * input, <span>size_t</span> length, <span>char</span>* utf8_buffer) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Compute the number of bytes that this UTF-16LE string would require in UTF-8 format.</span>
<span> *</span>
<span> * This function does not validate the input.</span>
<span> *</span>
<span> * @param input         the UTF-16LE string to convert</span>
<span> * @param length        the length of the string in 2-byte words (char16_t)</span>
<span> * @return the number of bytes required to encode the UTF-16LE string as UTF-8</span>
<span> <span>*/</span></span>
simdutf_warn_unused <span>size_t</span> <span>utf8_length_from_utf16le</span>(<span>const</span> <span>char16_t</span> * input, <span>size_t</span> length) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Compute the number of bytes that this UTF-16BE string would require in UTF-8 format.</span>
<span> *</span>
<span> * This function does not validate the input.</span>
<span> *</span>
<span> * @param input         the UTF-16BE string to convert</span>
<span> * @param length        the length of the string in 2-byte words (char16_t)</span>
<span> * @return the number of bytes required to encode the UTF-16BE string as UTF-8</span>
<span> <span>*/</span></span>
simdutf_warn_unused <span>size_t</span> <span>utf8_length_from_utf16be</span>(<span>const</span> <span>char16_t</span> * input, <span>size_t</span> length) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Convert possibly broken UTF-32LE string into UTF-8 string.</span>
<span> *</span>
<span> * During the conversion also validation of the input string is done.</span>
<span> * This function is suitable to work with inputs from untrusted sources.</span>
<span> *</span>
<span> * This function is not BOM-aware.</span>
<span> *</span>
<span> * @param input         the UTF-32LE string to convert</span>
<span> * @param length        the length of the string in 4-byte words (char32_t)</span>
<span> * @param utf8_buffer   the pointer to buffer that can hold conversion result</span>
<span> * @return number of written words; 0 if input is not a valid UTF-32LE string</span>
<span> <span>*/</span></span>
simdutf_warn_unused <span>size_t</span> <span>convert_utf32_to_utf8</span>(<span>const</span> <span>char32_t</span> * input, <span>size_t</span> length, <span>char</span>* utf8_buffer) <span>noexcept</span>;


<span><span>/*</span>*</span>
<span> * Convert possibly broken UTF-32LE string into UTF-8 string and stop on error.</span>
<span> *</span>
<span> * During the conversion also validation of the input string is done.</span>
<span> * This function is suitable to work with inputs from untrusted sources.</span>
<span> *</span>
<span> * This function is not BOM-aware.</span>
<span> *</span>
<span> * @param input         the UTF-32LE string to convert</span>
<span> * @param length        the length of the string in 4-byte words (char32_t)</span>
<span> * @param utf8_buffer   the pointer to buffer that can hold conversion result</span>
<span> * @return a result pair struct with an error code and either the position of the error if any or the number of char written if successful.</span>
<span> <span>*/</span></span>
simdutf_warn_unused result <span>convert_utf32_to_utf8_with_errors</span>(<span>const</span> <span>char32_t</span> * input, <span>size_t</span> length, <span>char</span>* utf8_buffer) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Convert valid UTF-32LE string into UTF-8 string.</span>
<span> *</span>
<span> * This function assumes that the input string is valid UTF-32LE.</span>
<span> *</span>
<span> * This function is not BOM-aware.</span>
<span> *</span>
<span> * @param input         the UTF-32LE string to convert</span>
<span> * @param length        the length of the string in 4-byte words (char32_t)</span>
<span> * @param utf8_buffer   the pointer to buffer that can hold the conversion result</span>
<span> * @return number of written words; 0 if conversion is not possible</span>
<span> <span>*/</span></span>
simdutf_warn_unused <span>size_t</span> <span>convert_valid_utf32_to_utf8</span>(<span>const</span> <span>char32_t</span> * input, <span>size_t</span> length, <span>char</span>* utf8_buffer) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Convert possibly broken UTF-32LE string into UTF-16LE string.</span>
<span> *</span>
<span> * During the conversion also validation of the input string is done.</span>
<span> * This function is suitable to work with inputs from untrusted sources.</span>
<span> *</span>
<span> * This function is not BOM-aware.</span>
<span> *</span>
<span> * @param input         the UTF-32LE string to convert</span>
<span> * @param length        the length of the string in 4-byte words (char32_t)</span>
<span> * @param utf16_buffer   the pointer to buffer that can hold conversion result</span>
<span> * @return number of written words; 0 if input is not a valid UTF-32LE string</span>
<span> <span>*/</span></span>
simdutf_warn_unused <span>size_t</span> <span>convert_utf32_to_utf16le</span>(<span>const</span> <span>char32_t</span> * input, <span>size_t</span> length, <span>char16_t</span>* utf16_buffer) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Convert possibly broken UTF-32LE string into UTF-16BE string.</span>
<span> *</span>
<span> * During the conversion also validation of the input string is done.</span>
<span> * This function is suitable to work with inputs from untrusted sources.</span>
<span> *</span>
<span> * This function is not BOM-aware.</span>
<span> *</span>
<span> * @param input         the UTF-32LE string to convert</span>
<span> * @param length        the length of the string in 4-byte words (char32_t)</span>
<span> * @param utf16_buffer   the pointer to buffer that can hold conversion result</span>
<span> * @return number of written words; 0 if input is not a valid UTF-32LE string</span>
<span> <span>*/</span></span>
simdutf_warn_unused <span>size_t</span> <span>convert_utf32_to_utf16be</span>(<span>const</span> <span>char32_t</span> * input, <span>size_t</span> length, <span>char16_t</span>* utf16_buffer) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Convert possibly broken UTF-32LE string into UTF-16LE string and stop on error.</span>
<span> *</span>
<span> * During the conversion also validation of the input string is done.</span>
<span> * This function is suitable to work with inputs from untrusted sources.</span>
<span> *</span>
<span> * This function is not BOM-aware.</span>
<span> *</span>
<span> * @param input         the UTF-32LE string to convert</span>
<span> * @param length        the length of the string in 4-byte words (char32_t)</span>
<span> * @param utf16_buffer   the pointer to buffer that can hold conversion result</span>
<span> * @return a result pair struct with an error code and either the position of the error if any or the number of char16_t written if successful.</span>
<span> <span>*/</span></span>
simdutf_warn_unused result <span>convert_utf32_to_utf16le_with_errors</span>(<span>const</span> <span>char32_t</span> * input, <span>size_t</span> length, <span>char16_t</span>* utf16_buffer) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Convert possibly broken UTF-32LE string into UTF-16BE string and stop on error.</span>
<span> *</span>
<span> * During the conversion also validation of the input string is done.</span>
<span> * This function is suitable to work with inputs from untrusted sources.</span>
<span> *</span>
<span> * This function is not BOM-aware.</span>
<span> *</span>
<span> * @param input         the UTF-32LE string to convert</span>
<span> * @param length        the length of the string in 4-byte words (char32_t)</span>
<span> * @param utf16_buffer   the pointer to buffer that can hold conversion result</span>
<span> * @return a result pair struct with an error code and either the position of the error if any or the number of char16_t written if successful.</span>
<span> <span>*/</span></span>
simdutf_warn_unused result <span>convert_utf32_to_utf16be_with_errors</span>(<span>const</span> <span>char32_t</span> * input, <span>size_t</span> length, <span>char16_t</span>* utf16_buffer) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Convert valid UTF-32LE string into UTF-16LE string.</span>
<span> *</span>
<span> * This function assumes that the input string is valid UTF-32LE.</span>
<span> *</span>
<span> * This function is not BOM-aware.</span>
<span> *</span>
<span> * @param input         the UTF-32LE string to convert</span>
<span> * @param length        the length of the string in 4-byte words (char32_t)</span>
<span> * @param utf16_buffer   the pointer to buffer that can hold the conversion result</span>
<span> * @return number of written words; 0 if conversion is not possible</span>
<span> <span>*/</span></span>
simdutf_warn_unused <span>size_t</span> <span>convert_valid_utf32_to_utf16le</span>(<span>const</span> <span>char32_t</span> * input, <span>size_t</span> length, <span>char16_t</span>* utf16_buffer) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Convert valid UTF-32LE string into UTF-16BE string.</span>
<span> *</span>
<span> * This function assumes that the input string is valid UTF-32LE.</span>
<span> *</span>
<span> * This function is not BOM-aware.</span>
<span> *</span>
<span> * @param input         the UTF-32LE string to convert</span>
<span> * @param length        the length of the string in 4-byte words (char32_t)</span>
<span> * @param utf16_buffer   the pointer to buffer that can hold the conversion result</span>
<span> * @return number of written words; 0 if conversion is not possible</span>
<span> <span>*/</span></span>
simdutf_warn_unused <span>size_t</span> <span>convert_valid_utf32_to_utf16be</span>(<span>const</span> <span>char32_t</span> * input, <span>size_t</span> length, <span>char16_t</span>* utf16_buffer) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Compute the number of bytes that this UTF-32LE string would require in UTF-8 format.</span>
<span> *</span>
<span> * This function does not validate the input.</span>
<span> *</span>
<span> * @param input         the UTF-32LE string to convert</span>
<span> * @param length        the length of the string in 4-byte words (char32_t)</span>
<span> * @return the number of bytes required to encode the UTF-32LE string as UTF-8</span>
<span> <span>*/</span></span>
simdutf_warn_unused <span>size_t</span> <span>utf8_length_from_utf32</span>(<span>const</span> <span>char32_t</span> * input, <span>size_t</span> length) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Compute the number of two-byte words that this UTF-32LE string would require in UTF-16 format.</span>
<span> *</span>
<span> * This function does not validate the input.</span>
<span> *</span>
<span> * @param input         the UTF-32LE string to convert</span>
<span> * @param length        the length of the string in 4-byte words (char32_t)</span>
<span> * @return the number of bytes required to encode the UTF-32LE string as UTF-16</span>
<span> <span>*/</span></span>
simdutf_warn_unused <span>size_t</span> <span>utf16_length_from_utf32</span>(<span>const</span> <span>char32_t</span> * input, <span>size_t</span> length) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Convert possibly broken UTF-16LE string into UTF-32LE string.</span>
<span> *</span>
<span> * During the conversion also validation of the input string is done.</span>
<span> * This function is suitable to work with inputs from untrusted sources.</span>
<span> *</span>
<span> * This function is not BOM-aware.</span>
<span> *</span>
<span> * @param input         the UTF-16LE string to convert</span>
<span> * @param length        the length of the string in 2-byte words (char16_t)</span>
<span> * @param utf32_buffer   the pointer to buffer that can hold conversion result</span>
<span> * @return number of written words; 0 if input is not a valid UTF-16LE string</span>
<span> <span>*/</span></span>
simdutf_warn_unused <span>size_t</span> <span>convert_utf16le_to_utf32</span>(<span>const</span> <span>char16_t</span> * input, <span>size_t</span> length, <span>char32_t</span>* utf32_buffer) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Convert possibly broken UTF-16BE string into UTF-32LE string.</span>
<span> *</span>
<span> * During the conversion also validation of the input string is done.</span>
<span> * This function is suitable to work with inputs from untrusted sources.</span>
<span> *</span>
<span> * This function is not BOM-aware.</span>
<span> *</span>
<span> * @param input         the UTF-16BE string to convert</span>
<span> * @param length        the length of the string in 2-byte words (char16_t)</span>
<span> * @param utf32_buffer   the pointer to buffer that can hold conversion result</span>
<span> * @return number of written words; 0 if input is not a valid UTF-16LE string</span>
<span> <span>*/</span></span>
simdutf_warn_unused <span>size_t</span> <span>convert_utf16be_to_utf32</span>(<span>const</span> <span>char16_t</span> * input, <span>size_t</span> length, <span>char32_t</span>* utf32_buffer) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Convert possibly broken UTF-16LE string into UTF-32LE string and stop on error.</span>
<span> *</span>
<span> * During the conversion also validation of the input string is done.</span>
<span> * This function is suitable to work with inputs from untrusted sources.</span>
<span> *</span>
<span> * This function is not BOM-aware.</span>
<span> *</span>
<span> * @param input         the UTF-16LE string to convert</span>
<span> * @param length        the length of the string in 2-byte words (char16_t)</span>
<span> * @param utf32_buffer   the pointer to buffer that can hold conversion result</span>
<span> * @return a result pair struct with an error code and either the position of the error if any or the number of char32_t written if successful.</span>
<span> <span>*/</span></span>
simdutf_warn_unused result <span>convert_utf16le_to_utf32_with_errors</span>(<span>const</span> <span>char16_t</span> * input, <span>size_t</span> length, <span>char32_t</span>* utf32_buffer) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Convert possibly broken UTF-16BE string into UTF-32LE string and stop on error.</span>
<span> *</span>
<span> * During the conversion also validation of the input string is done.</span>
<span> * This function is suitable to work with inputs from untrusted sources.</span>
<span> *</span>
<span> * This function is not BOM-aware.</span>
<span> *</span>
<span> * @param input         the UTF-16BE string to convert</span>
<span> * @param length        the length of the string in 2-byte words (char16_t)</span>
<span> * @param utf32_buffer   the pointer to buffer that can hold conversion result</span>
<span> * @return a result pair struct with an error code and either the position of the error if any or the number of char32_t written if successful.</span>
<span> <span>*/</span></span>
simdutf_warn_unused result <span>convert_utf16be_to_utf32_with_errors</span>(<span>const</span> <span>char16_t</span> * input, <span>size_t</span> length, <span>char32_t</span>* utf32_buffer) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Convert valid UTF-16LE string into UTF-32LE string.</span>
<span> *</span>
<span> * This function assumes that the input string is valid UTF-16LE.</span>
<span> *</span>
<span> * This function is not BOM-aware.</span>
<span> *</span>
<span> * @param input         the UTF-16LE string to convert</span>
<span> * @param length        the length of the string in 2-byte words (char16_t)</span>
<span> * @param utf32_buffer   the pointer to buffer that can hold the conversion result</span>
<span> * @return number of written words; 0 if conversion is not possible</span>
<span> <span>*/</span></span>
simdutf_warn_unused <span>size_t</span> <span>convert_valid_utf16le_to_utf32</span>(<span>const</span> <span>char16_t</span> * input, <span>size_t</span> length, <span>char32_t</span>* utf32_buffer) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Convert valid UTF-16BE string into UTF-32LE string.</span>
<span> *</span>
<span> * This function assumes that the input string is valid UTF-16LE.</span>
<span> *</span>
<span> * This function is not BOM-aware.</span>
<span> *</span>
<span> * @param input         the UTF-16BE string to convert</span>
<span> * @param length        the length of the string in 2-byte words (char16_t)</span>
<span> * @param utf32_buffer   the pointer to buffer that can hold the conversion result</span>
<span> * @return number of written words; 0 if conversion is not possible</span>
<span> <span>*/</span></span>
simdutf_warn_unused <span>size_t</span> <span>convert_valid_utf16be_to_utf32</span>(<span>const</span> <span>char16_t</span> * input, <span>size_t</span> length, <span>char32_t</span>* utf32_buffer) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Compute the number of bytes that this UTF-16LE string would require in UTF-32LE format.</span>
<span> *</span>
<span> * This function is equivalent to count_utf16le.</span>
<span> *</span>
<span> * This function does not validate the input.</span>
<span> *</span>
<span> * This function is not BOM-aware.</span>
<span> *</span>
<span> * @param input         the UTF-16LE string to convert</span>
<span> * @param length        the length of the string in 2-byte words (char16_t)</span>
<span> * @return the number of bytes required to encode the UTF-16LE string as UTF-32LE</span>
<span> <span>*/</span></span>
simdutf_warn_unused <span>size_t</span> <span>utf32_length_from_utf16le</span>(<span>const</span> <span>char16_t</span> * input, <span>size_t</span> length) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Compute the number of bytes that this UTF-16BE string would require in UTF-32LE format.</span>
<span> *</span>
<span> * This function is equivalent to count_utf16be.</span>
<span> *</span>
<span> * This function does not validate the input.</span>
<span> *</span>
<span> * This function is not BOM-aware.</span>
<span> *</span>
<span> * @param input         the UTF-16BE string to convert</span>
<span> * @param length        the length of the string in 2-byte words (char16_t)</span>
<span> * @return the number of bytes required to encode the UTF-16BE string as UTF-32LE</span>
<span> <span>*/</span></span>
simdutf_warn_unused <span>size_t</span> <span>utf32_length_from_utf16be</span>(<span>const</span> <span>char16_t</span> * input, <span>size_t</span> length) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Count the number of code points (characters) in the string assuming that</span>
<span> * it is valid.</span>
<span> *</span>
<span> * This function assumes that the input string is valid UTF-16LE.</span>
<span> *</span>
<span> * This function is not BOM-aware.</span>
<span> *</span>
<span> * @param input         the UTF-16LE string to process</span>
<span> * @param length        the length of the string in 2-byte words (char16_t)</span>
<span> * @return number of code points</span>
<span> <span>*/</span></span>
simdutf_warn_unused <span>size_t</span> <span>count_utf16le</span>(<span>const</span> <span>char16_t</span> * input, <span>size_t</span> length) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Count the number of code points (characters) in the string assuming that</span>
<span> * it is valid.</span>
<span> *</span>
<span> * This function assumes that the input string is valid UTF-16BE.</span>
<span> *</span>
<span> * This function is not BOM-aware.</span>
<span> *</span>
<span> * @param input         the UTF-16BE string to process</span>
<span> * @param length        the length of the string in 2-byte words (char16_t)</span>
<span> * @return number of code points</span>
<span> <span>*/</span></span>
simdutf_warn_unused <span>size_t</span> <span>count_utf16be</span>(<span>const</span> <span>char16_t</span> * input, <span>size_t</span> length) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Count the number of code points (characters) in the string assuming that</span>
<span> * it is valid.</span>
<span> *</span>
<span> * This function assumes that the input string is valid UTF-8.</span>
<span> *</span>
<span> * @param input         the UTF-8 string to process</span>
<span> * @param length        the length of the string in bytes</span>
<span> * @return number of code points</span>
<span> <span>*/</span></span>
simdutf_warn_unused <span>size_t</span> <span>count_utf8</span>(<span>const</span> <span>char</span> * input, <span>size_t</span> length) <span>noexcept</span>;

<span><span>/*</span>*</span>
<span> * Change the endianness of the input. Can be used to go from UTF-16LE to UTF-16BE or</span>
<span> * from UTF-16BE to UTF-16LE.</span>
<span> *</span>
<span> * This function does not validate the input.</span>
<span> *</span>
<span> * This function is not BOM-aware.</span>
<span> *</span>
<span> * @param input         the UTF-16 string to process</span>
<span> * @param length        the length of the string in 2-byte words (char16_t)</span>
<span> * @param output        the pointer to buffer that can hold the conversion result</span>
<span> <span>*/</span></span>
<span>void</span> <span>change_endianness_utf16</span>(<span>const</span> <span>char16_t</span> * input, <span>size_t</span> length, <span>char16_t</span> * output) <span>noexcept</span>;

}</pre></div>
<h2 dir="auto"><a id="user-content-errors" aria-hidden="true" href="#errors"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Errors</h2>
<p dir="auto">For validation and transcoding, we also provide functions that will stop on error and return a result struct which is a pair of two fields:</p>
<div dir="auto" data-snippet-clipboard-copy-content="struct result {
  error_code error;
  size_t position;
};"><pre><span>struct</span> <span>result</span> {
  error_code error;
  <span>size_t</span> position;
};</pre></div>
<p dir="auto">On error, the <code>error</code> field indicates the type of error encountered and the <code>position</code> field indicates its word position in the input string.
We report six types of errors related to UTF-8, UTF-16 and UTF-32 encodings:</p>
<div dir="auto" data-snippet-clipboard-copy-content="enum error_code {
  SUCCESS = 0,
  HEADER_BITS,  // Any byte must have fewer than 5 header bits.
  TOO_SHORT,    // The leading byte must be followed by N-1 continuation bytes, where N is the UTF-8 character length
                // This is also the error when the input is truncated.
  TOO_LONG,     // The leading byte must not be a continuation byte.
  OVERLONG,     // The decoded character must be above U+7F for two-byte characters, U+7FF for three-byte characters,
                // and U+FFFF for four-byte characters.
  TOO_LARGE,    // The decoded character must be less than or equal to U+10FFFF OR less than or equal than U+7F for ASCII.
  SURROGATE,    // The decoded character must be not be in U+D800...DFFF (UTF-8 or UTF-32) OR
                // a high surrogate must be followed by a low surrogate and a low surrogate must be preceded by a high surrogate (UTF-16)
  OTHER         // Not related to validation/transcoding.
};"><pre><span>enum</span> error_code {
  SUCCESS = <span>0</span>,
  HEADER_BITS,  <span><span>//</span> Any byte must have fewer than 5 header bits.</span>
  TOO_SHORT,    <span><span>//</span> The leading byte must be followed by N-1 continuation bytes, where N is the UTF-8 character length</span>
                <span><span>//</span> This is also the error when the input is truncated.</span>
  TOO_LONG,     <span><span>//</span> The leading byte must not be a continuation byte.</span>
  OVERLONG,     <span><span>//</span> The decoded character must be above U+7F for two-byte characters, U+7FF for three-byte characters,</span>
                <span><span>//</span> and U+FFFF for four-byte characters.</span>
  TOO_LARGE,    <span><span>//</span> The decoded character must be less than or equal to U+10FFFF OR less than or equal than U+7F for ASCII.</span>
  SURROGATE,    <span><span>//</span> The decoded character must be not be in U+D800...DFFF (UTF-8 or UTF-32) OR</span>
                <span><span>//</span> a high surrogate must be followed by a low surrogate and a low surrogate must be preceded by a high surrogate (UTF-16)</span>
  OTHER         <span><span>//</span> Not related to validation/transcoding.</span>
};</pre></div>
<p dir="auto">On success, the <code>error</code> field is set to <code>SUCCESS</code> and the <code>position</code> field indicates either the number of words validated for validation functions or the number of written
words in the output format for transcoding functions.</p>
<h2 dir="auto"><a id="user-content-sutf" aria-hidden="true" href="#sutf"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>sutf</h2>
<p dir="auto">We also provide a command-line tool which can be build as follows:</p>
<div data-snippet-clipboard-copy-content="cmake -B build &amp;&amp; cmake --build build --target sutf"><pre><code>cmake -B build &amp;&amp; cmake --build build --target sutf
</code></pre></div>
<p dir="auto">This builds the executable in <code>./build/tool/</code>. sutf enables the user to easily transcode files from one encoding to another directly from the command line.
The usage is very similar to (iconv)[<a href="https://www.gnu.org/software/libiconv/" rel="nofollow">https://www.gnu.org/software/libiconv/</a>] (see <code>sutf --help</code> for more details). sutf relies on the simdutf library functions for fast transcoding of supported
formats (UTF-8, UTF-16LE, UTF-16BE and UTF-32LE). If iconv is found on the system, sutf falls back on iconv for other formats supported by iconv (a message lets the user know if iconv is available
during compilation). Example of transcoding two input files to an output file, from UTF-8 to UTF-16LE:</p>
<div data-snippet-clipboard-copy-content="sutf -f UTF-8 -t UTF-16LE -o output_file.txt first_input_file.txt second_input_file.txt"><pre><code>sutf -f UTF-8 -t UTF-16LE -o output_file.txt first_input_file.txt second_input_file.txt
</code></pre></div>
<h2 dir="auto"><a id="user-content-usage" aria-hidden="true" href="#usage"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Usage</h2>
<p dir="auto">The library used by <a href="https://github.com/haskell/text">haskell/text</a>.</p>
<h2 dir="auto"><a id="user-content-references" aria-hidden="true" href="#references"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>References</h2>
<ul dir="auto">
<li>Daniel Lemire, Wojciech Muła,  <a href="https://arxiv.org/abs/2109.10433" rel="nofollow">Transcoding Billions of Unicode Characters per Second with SIMD Instructions</a>, Software: Practice and Experience (to appear)</li>
</ul>
<h2 dir="auto"><a id="user-content-license" aria-hidden="true" href="#license"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>License</h2>
<p dir="auto">This code is made available under the <a href="https://www.apache.org/licenses/LICENSE-2.0.html" rel="nofollow">Apache License 2.0</a> as well as the MIT license.</p>
<p dir="auto">We include a few competitive solutions under the benchmarks/competition directory. They are provided for
research purposes only.</p>
</article>
          </div></div>
  </body>
</html>
