<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tidepool.leaflet.pub/3mcbegnuf2k2i">Original</a>
    <h1>Stop using natural language interfaces</h1>
    
    <div id="readability-page-1" class="page"><div><p id="0" data-index="0"><span>Natural language is a wonderful interface, but just because we suddenly </span><span>can </span><span>doesn&#39;t mean we always </span><span>should. </span><span>LLM inference is slow and expensive, often taking tens of seconds to complete. Natural language interfaces have orders of magnitude more latency than normal graphic user interfaces. This doesn&#39;t mean we shouldn&#39;t use LLMs, it just means we need to be smart about how we build interfaces around them.</span></p><h2 id="2" data-index="2"><span>The Latency Problem</span></h2><p id="3" data-index="3"><span>There&#39;s a classic CS diagram visualizing latency numbers for various compute operations: nanoseconds to lock a mutex, microseconds to reference memory, milliseconds to read 1 MB from disk. LLM inference usually takes 10s of seconds to complete. Streaming responses help compensate, but it&#39;s </span><span>slow.</span></p><p><img height="512" width="1024" src="https://flaviuspopan.com/api/atproto_images?did=did:plc:qvywnipfiyrd6v4qdf4x27wy&amp;cid=bafkreieb5yelu7aryalqfyl36vlr4uxtw7kr2qfi2ycod3r3fpn4gao77u"/></p><p id="5" data-index="5"><span>Compare interacting with an LLM over multiple turns to filling in a checklist, selecting items from a pulldown menu, setting a value on a slider bar, stepping through a series of such interactions as you fill out a multi-field dialogue. Graphic user interfaces are fast, with responses taking milliseconds, not seconds. But. But: they&#39;re not smart, they&#39;re not responsive, they don&#39;t shape themselves to the conversation with the full benefits of semantic understanding.</span></p><div id="6" data-index="6"><p><img alt="A popup dialogue with multiple conditional checkboxes, sliders, and text areas" height="523" width="903" src="https://flaviuspopan.com/api/atproto_images?did=did:plc:qvywnipfiyrd6v4qdf4x27wy&amp;cid=bafkreie73h5hzlxwldypecvxfoakvb2vjwlnkeo3xfca2i56btk7pupepq"/></p></div><p id="7" data-index="7"><span>This is a post about how to provide the best of both worlds: the clean affordances of structured user interfaces with the flexibility of natural language. Every part of the above interface was generated on the fly by an LLM.</span></p><h2 id="9" data-index="9"><span>Popup-MCP</span></h2><p id="10" data-index="10"><span>This is a post about a tool I made called </span><a href="https://github.com/inanna-malick/popup-mcp" target="_blank">popup-mcp</a><span> (MCP is a standardized tool-use interface for LLMs). I built it about 6 months ago and have been experimenting with it as a core part of my LLM interaction modality ever since. It&#39;s a big part of what has made me so fond of them, from such an early stage. Popup provides a single tool that when invoked spawns a popup with an arbitrary collection of GUI elements.</span></p><p id="12" data-index="12"><span>You can find popup </span><a href="https://github.com/inanna-malick/popup-mcp" target="_blank">here</a><span>, along with instructions on how to use it. It&#39;s a local MCP tool that uses stdio, which means the process needs to run on the same computer as your LLM client. Popup supports structured GUIs made up of elements including multiple choice checkboxes, drop downs, sliders, and text boxes. These let LLMs render popups like the following:</span></p><p><img height="321" width="826" src="https://flaviuspopan.com/api/atproto_images?did=did:plc:qvywnipfiyrd6v4qdf4x27wy&amp;cid=bafkreiaudad7f2bb5emzzjsibxirsqmxyvu4vydvdv24szpxe6qgumhjj4"/></p><p id="14" data-index="14"><span>The popup tool supports conditional visibility to allow for context-specific followup questions. Some elements start hidden, only becoming visible when conditions like &#39;checkbox clicked&#39;, &#39;slider value &gt; 7&#39;, or &#39;checkbox A clicked &amp;&amp; slider B &lt; 7 &amp;&amp; slider C &gt; 8&#39; become true. This lets LLMs construct complex and nuanced structures capturing not just their next stage of the conversation but </span><span>where they think the conversation might go from there</span><span>. Think of these as being a bit like conditional dialogue trees in CRPGs like Baldur&#39;s Gate or interview trees as used in consulting. The previous dialog, for example, expands as follows:</span></p><p><img height="618" width="1148" src="https://flaviuspopan.com/api/atproto_images?did=did:plc:qvywnipfiyrd6v4qdf4x27wy&amp;cid=bafkreieh3yet67ktdel4v4lq7unu6s247q5p5q37wmqyn2jcnos6wivwxm"/></p><p id="16" data-index="16"><span>Because constructing this tree requires registering nested hypotheticals about how a conversation might progress, it provides a useful window into an LLM&#39;s internal cognitive state. You don&#39;t just see the question it wants to ask you, you see the followup questions it would ask based on various answer combinations. This is incredibly useful and often shows where the LLM is making incorrect assumptions. More importantly, this is </span><span>fast</span><span>. You can quickly explore counterfactuals without having to waste minutes on back-and-forth conversational turns and restarting conversations from checkpoints.</span></p><p><img height="495" width="1157" src="https://flaviuspopan.com/api/atproto_images?did=did:plc:qvywnipfiyrd6v4qdf4x27wy&amp;cid=bafkreid56ezwkkrojlnrftxqpbyjvazkmv7qaiyqsjn52x337inbpwk7yi"/></p><p id="19" data-index="19"><span>Speaking of incorrect LLM assumptions: every multiselect or dropdown automatically includes an &#39;Other&#39; option, which - when selected - renders a textbox for the user to elaborate on what the LLM missed. This escape hatch started as an emergent pattern, but I recently modified the tool to _always_ auto-include an escape hatch option on all multiselects and dropdown menus.</span></p><p id="20" data-index="20"><span>This means that you can always intervene to </span><span>steer </span><span>the LLM when it has the wrong idea about where a conversation should go.</span></p><h2 id="22" data-index="22"><span>Why This Matters</span></h2><p id="23" data-index="23"><span>Remember how I started by talking about latency, about how long a single LLM response takes? This combination of nested dialogue trees and escape hatches cuts that by ~25-75%, depending on how well the LLM anticipates where the conversation is going. It&#39;s surprising how often a series dropdown with its top 3-5 predictions will contain your next answer, especially when defining technical specs, and when it doesn&#39;t there&#39;s always the natural-language escape hatch offered by &#39;Other&#39;.</span></p><p id="25" data-index="25"><span>Imagine generating a new RPG setting. Your LLM spawns a popup with options for the 5 most common patterns, with focused followup questions for each.</span></p><p><img height="532" width="1152" src="https://flaviuspopan.com/api/atproto_images?did=did:plc:qvywnipfiyrd6v4qdf4x27wy&amp;cid=bafkreieorvdy22u4m7mm7bk26rteg2u2pi777nftvwxaoerdtpoe7dd5ze"/></p><p id="27" data-index="27"><span>This isn&#39;t a generic GUI; it&#39;s fully specialized using everything the LLM knows about you, your project, and the interaction style you prefer. This captures 90% of what you&#39;re trying to do, so you select the relevant options and use &#39;Other&#39; escape hatches to clarify as necessary.</span></p><p><img height="697" width="1620" src="https://flaviuspopan.com/api/atproto_images?did=did:plc:qvywnipfiyrd6v4qdf4x27wy&amp;cid=bafkreiboyo3ocrfgqeixutelvsztbj4f3behvjxbvcnejyinfsiaszhtcu"/></p><p id="29" data-index="29"><span>These interactions have latency measured in milliseconds: when you check the &#39;Other&#39; checkbox, a text box instantly appears, without even a network round-trip&#39;s worth of latency. When you&#39;re done, your answers are returned to the LLM as a JSON tool response.</span></p><p id="31" data-index="31"><span>You should think of this pattern as providing a reduction in amortized interaction latency: it&#39;ll still take 10s of seconds to produce a followup response when you submit a popup dialog, but if your average popup replaces &gt; 1 rounds of chat you&#39;re still taking less time per unit of information exchanged.  That&#39;s what I mean by amortized latency: that single expensive LLM invocation is amortized over multiple cheap interactions with deterministically rendered GUI run on your local machine.</span></p><h2 id="33" data-index="33"><span>Claude Code Planning Mode</span></h2><p id="34" data-index="34"><span>I started hacking on this a few months before Claude Code released their AskUser tool (as used in planning mode). The AskUser tool provides a limited selection of TUI (terminal user interface) elements: multiple-choice and single-choice (with an always-included ‘Other’ option) and single-choice drop-downs. I originally chose not to publicize my library because of this, but I believe the addition of conditional elements is worth talking about.</span></p><p><img height="396" width="1518" src="https://flaviuspopan.com/api/atproto_images?did=did:plc:qvywnipfiyrd6v4qdf4x27wy&amp;cid=bafkreie5ayfyu6dyvhxsjjbvcabyycftya4okv6f26xndqrf45lhc3prxy"/></p><p id="36" data-index="36"><span>Further, I have some feature requests for Claude Code. If anyone at Anthropic happens to be reading this these would all be pretty easily to implement:</span></p><ul><li><p id="37.0" data-index="37.0"><span>Make the TUI interface used by the AskUserQuestion tool open and scriptable, such that plugins and user code can directly modify LLM-generated TUI interfaces, or directly generate their own without requiring a round-trip through the LLM to invoke the tool.</span></p></li><li><p id="37.1" data-index="37.1"><span>Provide pre and post-AskUser tool hooks so users can directly invoke code using TUI responses (eg filling templated prompts using TUI interface responses in certain contexts).</span></p></li><li><p id="37.2" data-index="37.2"><span>Extend the AskUser tool to support conditionally-rendered elements.</span></p></li></ul><h2 id="39" data-index="39"><span>Conclusion</span></h2><p id="40" data-index="40"><span>If you have an LLM chat app you should add inline structured GUI elements with conditionally visible followup questions to reduce amortized interaction latency. If you&#39;d like to build on my library or tool definition, or just to talk shop, please reach out. I&#39;d be happy to help. This technique is equally applicable to OS-native popups, terminal user interfaces, and web UIs.</span></p><p id="42" data-index="42"><span>I&#39;ll be writing more here. Publishing what I build is one of my core resolutions for 2026, and I have one hell of a backlog. Watch this space.</span></p></div></div>
  </body>
</html>
