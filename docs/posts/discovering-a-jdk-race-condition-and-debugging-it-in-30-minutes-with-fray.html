<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://aoli.al/blogs/jdk-bug/">Original</a>
    <h1>Discovering a JDK Race Condition, and Debugging It in 30 Minutes with Fray</h1>
    
    <div id="readability-page-1" class="page"><div>
  
<p>I’ve been adding more integration tests for <a href="https://github.com/cmu-pasta/fray">Fray</a> recently. To ensure Fray can handle different scenarios, I wrote many <a href="https://github.com/cmu-pasta/fray/tree/main/integration-test/src/main/java/org/pastalab/fray/test/core">creative test cases</a>. Many of them passed as expected, while some failures led to <a href="https://github.com/cmu-pasta/fray/commit/9bd359ecde65170d3da975443497a1aefa3d3517">epic fixes</a> in Fray. Then something unexpected happened: Fray threw a deadlock exception while testing the following seemingly innocent code:</p>
<div><pre tabindex="0"><code data-lang="java"><span><span> 1</span><span><span>private</span><span> </span><span>void</span><span> </span><span>test</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span> 2</span><span><span>    </span><span>ScheduledThreadPoolExecutor</span><span> </span><span>executor</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>ScheduledThreadPoolExecutor</span><span>(</span><span>1</span><span>);</span><span>
</span></span></span><span><span> 3</span><span><span>    </span><span>// Shutdown thread.</span><span>
</span></span></span><span><span> 4</span><span><span>    </span><span>new</span><span> </span><span>Thread</span><span>(()</span><span> </span><span>-&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span> 5</span><span><span>        </span><span>executor</span><span>.</span><span>shutdown</span><span>();</span><span>
</span></span></span><span><span> 6</span><span><span>    </span><span>}).</span><span>start</span><span>();</span><span>
</span></span></span><span><span> 7</span><span><span>    </span><span>try</span><span> </span><span>{</span><span>
</span></span></span><span><span> 8</span><span><span>        </span><span>ScheduledFuture</span><span>&lt;?&gt;</span><span> </span><span>future</span><span> </span><span>=</span><span> </span><span>executor</span><span>.</span><span>schedule</span><span>(()</span><span> </span><span>-&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span> 9</span><span><span>            </span><span>Thread</span><span>.</span><span>yield</span><span>();</span><span>
</span></span></span><span><span>10</span><span><span>        </span><span>},</span><span> </span><span>10</span><span>,</span><span> </span><span>TimeUnit</span><span>.</span><span>MILLISECONDS</span><span>);</span><span>
</span></span></span><span><span>11</span><span><span>        </span><span>try</span><span> </span><span>{</span><span>
</span></span></span><span><span>12</span><span><span>            </span><span>future</span><span>.</span><span>get</span><span>();</span><span>
</span></span></span><span><span>13</span><span><span>            </span><span>Thread</span><span>.</span><span>yield</span><span>();</span><span>
</span></span></span><span><span>14</span><span><span>        </span><span>}</span><span> </span><span>catch</span><span> </span><span>(</span><span>Throwable</span><span> </span><span>e</span><span>)</span><span> </span><span>{}</span><span>
</span></span></span><span><span>15</span><span><span>    </span><span>}</span><span> </span><span>catch</span><span> </span><span>(</span><span>RejectedExecutionException</span><span> </span><span>e</span><span>)</span><span> </span><span>{}</span><span>
</span></span></span><span><span>16</span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>This code creates a <code>ScheduledThreadPoolExecutor</code>, schedules a task, and shuts down the executor in another thread. Initially, I suspected a bug in Fray, but after investigation, I discovered that the deadlock was actually caused by a <a href="https://bugs.openjdk.org/browse/JDK-8358601">bug in the JDK</a> itself.</p>
<p>Debugging this issue was straightforward thanks to Fray’s deterministic replay and schedule visualization. To understand the deadlock, let’s first take a look of the implementation of <code>ScheduledThreadPoolExecutor</code>:</p>
<div><pre tabindex="0"><code data-lang="java"><span><span> 1</span><span><span>public</span><span> </span><span>class</span> <span>ScheduledThreadPoolExecutor</span><span> </span><span>extends</span><span> </span><span>ThreadPoolExecutor</span><span> </span><span>implements</span><span> </span><span>ScheduledExecutorService</span><span> </span><span>{</span><span>
</span></span></span><span><span> 2</span><span><span>    </span><span>public</span><span> </span><span>Future</span><span>&lt;?&gt;</span><span> </span><span>schedule</span><span>(</span><span>Runnable</span><span> </span><span>command</span><span>,</span><span> </span><span>long</span><span> </span><span>delay</span><span>,</span><span> </span><span>TimeUnit</span><span> </span><span>unit</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span> 3</span><span><span>        </span><span>// ...</span><span>
</span></span></span><span><span> 4</span><span><span>        </span><span>RunnableScheduledFuture</span><span>&lt;?&gt;</span><span> </span><span>task</span><span> </span><span>=</span><span> </span><span>decorateTask</span><span>(...);</span><span>
</span></span></span><span><span> 5</span><span><span>        </span><span>// delayedExecute method</span><span>
</span></span></span><span><span> 6</span><span><span>        </span><span>super</span><span>.</span><span>getQueue</span><span>().</span><span>add</span><span>(</span><span>task</span><span>);</span><span>
</span></span></span><span><span> 7</span><span><span>
</span></span></span><span><span> 8</span><span><span>        </span><span>// addWorker method</span><span>
</span></span></span><span><span> 9</span><span><span>        </span><span>for</span><span> </span><span>(</span><span>int</span><span> </span><span>c</span><span> </span><span>=</span><span> </span><span>ctl</span><span>.</span><span>get</span><span>();;)</span><span> </span><span>{</span><span>
</span></span></span><span><span>10</span><span><span>            </span><span>if</span><span> </span><span>(</span><span>runStateAtLeast</span><span>(</span><span>c</span><span>,</span><span> </span><span>SHUTDOWN</span><span>)</span><span>
</span></span></span><span><span>11</span><span><span>                </span><span>&amp;&amp;</span><span> </span><span>(</span><span>runStateAtLeast</span><span>(</span><span>c</span><span>,</span><span> </span><span>STOP</span><span>)</span><span>
</span></span></span><span><span>12</span><span><span>                    </span><span>||</span><span> </span><span>firstTask</span><span> </span><span>!=</span><span> </span><span>null</span><span>
</span></span></span><span><span>13</span><span><span>                    </span><span>||</span><span> </span><span>workQueue</span><span>.</span><span>isEmpty</span><span>()))</span><span>
</span></span></span><span><span>14</span><span><span>                </span><span>return</span><span> </span><span>...;</span><span>
</span></span></span><span><span>15</span><span><span>            </span><span>// add task to a worker thread</span><span>
</span></span></span><span><span>16</span><span><span>        </span><span>}</span><span>
</span></span></span><span><span>17</span><span><span>        </span><span>return</span><span> </span><span>task</span><span>;</span><span>
</span></span></span><span><span>18</span><span><span>    </span><span>}</span><span>
</span></span></span><span><span>19</span><span><span>
</span></span></span><span><span>20</span><span><span>    </span><span>public</span><span> </span><span>void</span><span> </span><span>shutdown</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span>21</span><span><span>        </span><span>// tryTerminate method</span><span>
</span></span></span><span><span>22</span><span><span>        </span><span>int</span><span> </span><span>c</span><span> </span><span>=</span><span> </span><span>ctl</span><span>.</span><span>get</span><span>();</span><span>
</span></span></span><span><span>23</span><span><span>        </span><span>if</span><span> </span><span>(</span><span>isRunning</span><span>(</span><span>c</span><span>)</span><span> </span><span>||</span><span>
</span></span></span><span><span>24</span><span><span>            </span><span>runStateAtLeast</span><span>(</span><span>c</span><span>,</span><span> </span><span>TIDYING</span><span>)</span><span> </span><span>||</span><span>
</span></span></span><span><span>25</span><span><span>            </span><span>(</span><span>runStateLessThan</span><span>(</span><span>c</span><span>,</span><span> </span><span>STOP</span><span>)</span><span> </span><span>&amp;&amp;</span><span> </span><span>!</span><span> </span><span>workQueue</span><span>.</span><span>isEmpty</span><span>()))</span><span>
</span></span></span><span><span>26</span><span><span>            </span><span>return</span><span>;</span><span>
</span></span></span><span><span>27</span><span><span>        </span><span>if</span><span> </span><span>(</span><span>workerCountOf</span><span>(</span><span>c</span><span>)</span><span> </span><span>!=</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span> </span><span>// Eligible to terminate</span><span>
</span></span></span><span><span>28</span><span><span>            </span><span>interruptIdleWorkers</span><span>(</span><span>ONLY_ONE</span><span>);</span><span>
</span></span></span><span><span>29</span><span><span>            </span><span>return</span><span>;</span><span>
</span></span></span><span><span>30</span><span><span>        </span><span>}</span><span>
</span></span></span><span><span>31</span><span><span>
</span></span></span><span><span>32</span><span><span>        </span><span>if</span><span> </span><span>(</span><span>ctl</span><span>.</span><span>compareAndSet</span><span>(</span><span>c</span><span>,</span><span> </span><span>ctlOf</span><span>(</span><span>TIDYING</span><span>,</span><span> </span><span>0</span><span>)))</span><span> </span><span>{</span><span>
</span></span></span><span><span>33</span><span><span>            </span><span>//...</span><span>
</span></span></span><span><span>34</span><span><span>            </span><span>ctl</span><span>.</span><span>set</span><span>(</span><span>ctlOf</span><span>(</span><span>TERMINATED</span><span>,</span><span> </span><span>0</span><span>));</span><span>
</span></span></span><span><span>35</span><span><span>        </span><span>}</span><span>
</span></span></span><span><span>36</span><span><span>    </span><span>}</span><span>
</span></span></span><span><span>37</span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><h2 id="bug-behavior">Bug Behavior</h2>
<p>The <code>ScheduledThreadPoolExecutor</code> schedules tasks by adding them to a work queue and executing them in worker threads. Depending on the executor’s state, users would expect the following behavior:</p>
<table>
  <thead>
      <tr>
          <th>State</th>
          <th><code>ScheduledThreadPoolExecutor.schedule</code></th>
          <th><code>FutureTask.get</code></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>RUNNING</td>
          <td>returns task</td>
          <td>blocks until task completes</td>
      </tr>
      <tr>
          <td>SHUTDOWN</td>
          <td>throws <code>RejectedExecutionException</code></td>
          <td>throws <code>CancellationException</code></td>
      </tr>
  </tbody>
</table>
<p>However, Fray revealed that when the <code>ScheduledThreadPoolExecutor</code> is in the <code>SHUTDOWN</code> state, the <code>FutureTask.get</code> method may block indefinitely waiting for the task to complete.</p>
<h2 id="how-the-bug-occurs">How the Bug Occurs</h2>
<p>The bug manifests when Fray interleaves the <code>schedule</code> method and the <code>shutdown</code> method. At line 9 of <code>ScheduledThreadPoolExecutor.schedule</code>, the executor tries to add a new worker to execute tasks. It first checks whether the executor is in a state that allows the task to run. If the executor is in the <code>SHUTDOWN</code> state, the <code>schedule</code> method assumes that the shutdown process will terminate the task, so it simply returns (Line 14) without creating a new worker thread. However, this assumption breaks when the shutdown method transitions to the <code>SHUTDOWN</code> state but will not terminate the task, leaving it in a limbo state.</p>
<p>The following stack traces illustrate the problematic interleaving. The main thread (test worker) is going to create a new worker for the task, while the shutdown thread (Thread-3) is executing <code>tryTerminate</code> and setting the state to <code>TIDYING</code>.</p>
<img src="https://aoli.al/images/jdk-bug/stack_1.png"/>
<p>Next, Fray yields to the main thread, which performs the condition check at line 10 of <code>ScheduledThreadPoolExecutor.schedule</code>. The executor is now in the <code>TIDYING</code> state, making both <code>runStateAtLeast(c, SHUTDOWN)</code> and <code>runStateAtLeast(c, STOP)</code> return true. The <code>schedule</code> method then returns the task without adding to a worker.</p>
<p>Meanwhile, in the shutdown thread, execution reaches <code>ctl.compareAndSet(c, ctlOf(TERMINATED, 0))</code> at line 16 of <code>ScheduledThreadPoolExecutor.shutdown</code>. The <code>ctl</code> is set to <code>TERMINATED</code>, and the shutdown thread completes. At this point, no thread will execute or interrupt the task, leaving it blocked forever.</p>
<img src="https://aoli.al/images/jdk-bug/stack_2.png"/>
<h2 id="more-details">More Details</h2>
<p>While the bug is conceptually simple, reaching this state is not straightforward because <code>ScheduledThreadPoolExecutor</code> and <code>ThreadPoolExecutor</code> are designed to prevent such situations. For example, in the <code>tryTerminate</code> method (Line 23-29), <code>ThreadPoolExecutor</code> checks whether the work queue is empty and workers are interrupted before setting the state to <code>TIDYING</code>. However, Fray demonstrates that this check can be bypassed if execution of <code>super.getQueue().add(task)</code> in the main thread is paused until the shutdown thread reaches the <code>ctl.compareAndSet(c, ctlOf(TIDYING, 0))</code> statement—a classic race condition.</p>
<h2 id="debugging-with-fray">Debugging with Fray</h2>
<p>Imagine discovering this bug in your codebase. You observe a thread blocked on <code>FutureTask.get</code>, but you don’t understand why. You cannot reproduce the bug because when you rerun the test, the deadlock disappears. Adding logging makes it disappear. Using a debugger makes it disappear. This is the notorious “Heisenbug” phenomenon common in concurrent programming.</p>
<p>This time, with Fray, you get a deterministic replay file that allows you to replay the execution step by step. You can observe the exact thread interleaving that triggers the bug and visualize the thread scheduling to understand the root cause.</p>
<h3 id="try-it-yourself">Try it Yourself!</h3>
<p>To experience this yourself, clone the <a href="https://github.com/aoli-al/JDK-ThreadPool-Bug-Demo">JDK bug repository</a> and open it with IntelliJ IDEA.</p>
<p>Then download the <a href="https://plugins.jetbrains.com/plugin/26623-fray-debugger">Fray plugin</a>.</p>
<p>In IntelliJ IDEA, open the <code>ScheduledThreadPoolExecutorTest</code> class and navigate to the <code>testWithFray</code> method.
Click the Run icon (▶️) next to the <code>testWithFray</code> method, select the first <code>Run &#39;ScheduledThreadPoolExecutorTest.testWithFray()&#39;</code> button, and then select <code>frayTest</code>. If Fray finds the bug, it will display messages in the Run tool window.</p>
<img src="https://aoli.al/images/jdk-bug/fray_run_output.png"/>
<p>Look for the output <code>2025-06-07 13:58:06 [INFO]: The recording is saved to PATH_TO_REPLAY_FILE</code> and note this path for replaying the bug.</p>
<h3 id="replay-and-understand-the-bug">Replay and Understand the Bug</h3>
<p>Copy the path to the replay file, navigate to the <code>replayWithFray</code> method, and paste the path into the <code>replay</code> field in the <code>@ConcurrencyTest</code> annotation. Click the Run icon (<i></i>) next to the <code>replayWithFray</code> method, select <code>Replay (Fray) &#39;ScheduledThreadPoolExecutorTest.replayWithFray()&#39;</code>, and then select <code>frayTest</code>.</p>
<img src="https://aoli.al/images/jdk-bug/fray_replay.png"/>
<p>Fray will replay the bug and pause at each context switch point (e.g., when the main thread is paused and yields to the shutdown thread). You can click the “Next step” button to step through the replay and observe how the bug unfolds. The Fray debugger also visualizes the thread timeline and highlights the currently executing lines in the editor.</p>
<p>Note that Fray is designed for application concurrency testing, so it hides highlights in JDK methods by default—you may only see highlights in the test code itself. However, since this capability proves valuable for testing the JDK, we plan to add a feature to show highlights in JDK methods in future releases.</p>
<h3 id="reporting-the-bug">Reporting the Bug</h3>
<p>When submitting this bug report, I created a <a href="https://github.com/aoli-al/jdk/commit/625420ba82d2b0ebac24d9954e09062e3fbc0378">patch</a> for the JDK that adds sleep statements to trigger the bug. However, the JDK team didn’t include this patch in the public bug report. Instead, the final report only described how to reproduce the bug using Fray.</p>
<p>Happy debugging.</p>

</div></div>
  </body>
</html>
