<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://taylor.town/code-blocks">Original</a>
    <h1>Using {blocks} in Rust and Go for fun and profit</h1>
    
    <div id="readability-page-1" class="page"><div>

<p>
Did you know you can just whip out curly-braces all over the place in Rust and Go?</p>
<pre><code>a := 1
a = 2

{ b := 1 }
b := 2</code></pre>
<pre><code>let mut a = 1;
a = 2;

{ let b = 1; };
let b = 2;

let c = {
  let mut d = 1;
  d = 2;
  d
};</code></pre>
<p>
But why on Earth would you even want to do this?</p>
<hr/>
<h2>
Creating “Construction-Zones”</h2>
<p>
When you’re creating a variable that demands multiple initialization steps, it’s tider to tuck the details into a block:</p>
<pre><code>// before
let person = Person(id);
person.authenticate(token).await;
let raw_email = person.fetchEmail().await;
let email = Email.parse(email);</code></pre>
<pre><code>// after
let email = {
  let person = Person(id);
  person.authenticate(token).await;
  let raw_email = person.fetchEmail().await;
  Email.parse(email)
}</code></pre>
<p>
In this example, it’s obvious that the “end-goal” is <code>email</code>. At a quick-glance, you can see which variables are important, and which are intermediate ephemera.</p>
<h2>
Containing Side-Effects and Error-Handling</h2>
<p>
Every golang programmer knows the pain of juggling <code>result</code> and <code>err</code> variables. With blocks, you can tidily handle each <code>err</code> and other variables without worrying about weird assignment problems with <code>:=</code> and <code>=</code>:</p>
<pre><code>id := 123
firstName := &#34;John&#34;
lastName := &#34;Smith&#34;

{
  result, err := db.Exec(
    `UPDATE usr SET first_name = $2 WHERE id = $1`,
    id,
    firstName,
  )
  if result.RowsAffected() = 0 || err != nil {
    return err
  }
}

{
  result, err := db.Exec(
    `UPDATE usr SET last_name = $2 WHERE id = $1`,
    id,
    lastName,
  )
  if result.RowsAffected() = 0 || err != nil {
    return err
  }
}</code></pre>
<h2>
Restricting Variable Lifetimes</h2>
<p>
I like creating tidy “workspaces” for each group of intermediate variables:</p>
<pre><code>// define vars
// do stuff with vars
{ 
  // define intermediate vars
  // manipulate top-level vars
}
// do more stuff with vars
{ 
  // define intermediate vars
  // manipulate top-level vars
}
// do even more stuff with vars</code></pre>
<p>
For example:</p>
<pre><code>email := &#34;<a href="https://taylor.town/cdn-cgi/l/email-protection" data-cfemail="7c16520f111508143c19041d110c1019521f1311">[email protected]</a>&#34;

usr := Usr{}
{
  var usrId int
  {
    err := db.QueryRow(
      `SELECT usr_id FROM usr_email WHERE email = $1`,
      email,
    ).Scan(&amp;usrId)
    if err != nil {
      return err
    }
  }

  {
    err := db.QueryRow(
      `SELECT * FROM usr WHERE id = $1`,
      usrId,
    ).Scan(&amp;usr)
    if err != nil {
      return err
    }
  }
}</code></pre>
<p>
In this very contrived example, you can easily see the purpose of everything just by glancing at the general structure:</p>
<ul>
<li>
<code>email</code> is at the beginning with an explicit value, so it’s a given input </li>
<li>
<code>usr</code> is declared empty, so the block directly beneath it will define it </li>
<li>
<code>usrId</code> is declared empty, so the block directly beneath it will define it </li>
<li>
<code>usr</code> and <code>email</code> are the only variables that we need to care about after this section </li>
</ul>
<hr/>
<h2>
Conclusion</h2>
<p>
Use <code>{}</code> blocks to prevent your variables from leaking everywhere.</p>
<p>
Your friends and coworkers will thank you.</p>
</div></div>
  </body>
</html>
