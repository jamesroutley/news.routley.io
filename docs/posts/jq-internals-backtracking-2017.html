<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/stedolan/jq/wiki/Internals:-backtracking">Original</a>
    <h1>Jq Internals: Backtracking (2017)</h1>
    
    <div id="readability-page-1" class="page"><div>
                <h2><a id="user-content-introduction" aria-hidden="true" href="#introduction"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Introduction</h2>
<p>The jq language is a generator/backtracking-type functional language.
Expressions produce zero, one, or more results.  Producing zero results
is the same backtracking, and as a result the <code>empty</code> builtin triggers
backtracking.</p>
<p>When backtracking, the VM unwinds the <a href="https://github.com/stedolan/jq/wiki/Internals:-the-stack">stack</a>, freeing garbage as it
goes, up to a saved point (a ”fork point“), restarting at that point.
The resumed instruction knows that a backtrack has occurred and can do a
variety of things as a result, such as: produce the next result in some
low-level operation (e.g., <code>EACH</code>, for <code>.[]</code>, <code>INDEX</code> for <code>.[expr]</code>).
Many built-in generators work by catching backtracking and producing the
next value until there are no more values to produce, in which case they
backtrack.</p>
<p>Fundamental generators in jq:</p>
<ul>
<li>the comma operator (<code>FORK</code> opcode)</li>
<li>
<code>.[]</code> (iterate values of <code>.</code>) (<code>EACH</code> opcode)</li>
<li>
<code>range(init;upto)</code> (<code>RANGE</code> opcode)</li>
<li>the <code>path()</code> builtin (<code>PATH_BEGIN</code> and <code>PATH_END</code> opcodes)</li>
<li>the last expression, the one that outputs values to the calling C
program (<code>RET</code> opcode)</li>
</ul>
<p>Generators can be implemented in terms of existing jq language
functionality.  For example, the new <code>range(init;upto;by)</code> builtin is a
jq-coded function, using only:</p>
<ul>
<li>the comma operator for generation</li>
<li>tail-call optimized recursion for iteration</li>
<li>sub-functions (yes, jq functions can define sub-functions!)</li>
</ul>
<h2><a id="user-content-deep-dive" aria-hidden="true" href="#deep-dive"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Deep dive</h2>
<p>Programmers familiar with the internals of Schemes, LISPs, or more esoteric languages like Prolog or Icon, will probably understand easily how jq generators and backtracking work.</p>
<p>Programmers familiar with GCC&#39;s local function extension to the C language will also easily understand how jq generators and backtracking work.</p>
<p>For everyone else the key to understanding jq generators and backtracking is as follows:</p>
<ul>
<li>Calling a function pushes a new call frame on the jq interpreted stack, much as one would expect in a typical C implementation</li>
<li>Returning from a function, however, is actually like a <code>yield</code> in Python and other such languages:
<ul>
<li>The RET instruction calls <code>frame_pop()</code>, which one would expect…</li>
<li>…but the <code>frame_pop()</code> function often does not pop anything from the stack, instead it changes the frame pointer to point to the previous frame.</li>
<li>The RET instruction then pushes a backtrack point onto the stack with <code>stack_push()</code>.  The ”return“ v</li>
</ul>
</li>
</ul>
<p>The effect of this is that returning from a jq function leaves the callee&#39;s frame on the stack and pushes a backtrack point.  Eventually the callee will be restarted by backtracking to its <code>RET</code> instruction, which will restore the current frame pointer to be the callee&#39;s.  If the caller being yielded to needs to push more things onto the stack, these get pushed past the callee&#39;s frame.  At some point the callee will have no more values to output, in which case it will backtrack.  Backtracking is more similar to returning in C than is yielding.</p>
<p>Note that frames are back-linked in a way that corresponds to the jq program&#39;s pipes.  The compiler counts the nesting level (number of pipes to cross) to get to a symbol such as a variable reference, and records this as a “level” in the bytecode produced for, e.g., a <code>LOADV</code> instruction.  The interpreter then traverses that many frames to find the frame in which the binder for that symbol is to be found.  Note that frames of callees are not in the caller&#39;s back-link list!  This is how lexical binding works in jq then, and it is akin to deep binding in that it requires iteration to find symbols, with global-most symbol references requiring the most iteration to resolve.  (The run-time could use something more like shallow binding, but the cost would be to copy, at frame-push time, all bound references that might be needed by the new frame&#39;s bytecode.)</p>
<p>A compilation to C with local functions would map the jq output/yield/return operation to a function call of a continuation, where a continuation is the function pointer of a local function that closes over local variables of its parent function.  Backtracking would map to a normal C function return, or perhaps to calling a computed goto (another GCC extension to C).</p>
<p>Of course, a better compilation to low-level code would avoid using extended C local functions as those require a system call to permit execution of the stack page where the local function object is allocated.  (The GCC local function implementation creates executable function objects on the stack in order to take their address; these are known as ”trampolines“.  In principle C could have larger pointers for local function pointers such that calling such a function pointer does not require an executable trampoline on the stack, but in practice the type name for such function pointers would have to indicate that the pointer is a closure pointer, and C has not been extended to make this possible, not even by GCC, therefore trampolines are unavoidably necessary.)  Instead a standard C function + callback argument could be used, or compilation to the LLVM IR could be used to bypass C altogether to produce even more optimized code.</p>

              </div></div>
  </body>
</html>
