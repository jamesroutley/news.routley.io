<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nixcademy.com/posts/secure-supply-chain-with-nix/">Original</a>
    <h1>Demonstrably Secure Software Supply Chains with Nix</h1>
    
    <div id="readability-page-1" class="page"><article>   <img src="https://nixcademy.com/_astro/philosophers-stone.CVjYUEeP_Z149ryM.webp" alt="Demonstrably Secure Software Supply Chains with Nix" width="2048" height="2048" loading="lazy" decoding="async"/> <div> <p>
📆
Mon May 12 2025 by Jacek Galowicz </p> <p>
(9 min. reading time)
</p> </div> <p>Maintaining secure software development environments, especially those that require
high levels of integrity guarantees, often comes with significant overhead.
Organizations frequently resort to air-gapped environments, extensive employee
vetting, and local forks of all software sources.
While these methods aim to enhance security, they can drastically slow down development,
introduce vulnerabilities due to outdated packages, and thus increase costs.
What if you could achieve ironclad supply chain integrity without these burdens?</p>
<p><img src="https://nixcademy.com/_astro/chain.ZEh5CqVG_L5FIR.webp" alt="" width="2333" height="1031" loading="lazy" decoding="async"/></p>
<p>Government authorities worldwide are demanding stronger proof that software used
in critical systems is secure.
Agencies like the USA’s <a href="https://www.cisa.gov/">CISA</a>/<a href="https://www.disa.mil/">DISA</a>,
Germany’s <a href="https://www.bsi.bund.de/">BSI</a>/<a href="https://www.bundeswehr.de/en/information-security-for-the-german-military-4506000">DeuMilSAA</a>,
France’s <a href="https://cyber.gouv.fr/en">ANSSI</a>/<a href="https://www.dgse.gouv.fr/en">DGSE</a>,
Italy’s <a href="https://www.acn.gov.it/">ACN</a>,
Spain’s <a href="https://www.ccn.cni.es/en/">CCN</a>, etc.
are setting strict requirements.
Meeting these rules is not optional for many organizations.</p>
<p>This article explores how Nix, a powerful package and depencency manager, offers a unique
and robust solution to meet these security standards while simultaneously saving costs,
freeing up developers to work with practically unconstrained software, and eliminating the
need for restrictive, air-gapped environments.
Nix allows you to prove the exact origin and integrity of your software before delivery without
impeding your development workflow.
Let developers use the latest and greatest toolchains and provide the supply chain
integrity proof for the release later!</p>
<p>Using Nix, you can achieve the high levels of transparency and verifiability required by regulators. It allows you to:</p>
<ul>
<li><strong>Prove Integrity</strong>: Guarantee that this exact set of sources produced this
image without third-party interference, satisfying regulatory requirements.</li>
<li><strong>Track Sources</strong>: Include all application sources and toolchains (e.g., compilers and their compilers)
for complete transparency and fully hermetic offline rebuilds.</li>
<li><strong>Audit Outputs</strong>: Export and archive the exact sources (typically a few GB of tarballs) of each release for
third-party audits, ensuring trust and accountability for compliance.</li>
</ul>
<p>While organizations are just starting to use Nix to address these requirements,
we believe that as regulators become more familiar with its capabilities,
demonstrating verifiable supply chain integrity with Nix will become a significant competitive advantage.
This article explains how Nix makes this possible.</p>
<h2 id="who-benefits">Who Benefits?</h2>
<ul>
<li><strong>Developers and DevOps Teams</strong>: Ensure reproducible, secure builds without maintaining forks of open source packages
and patch lists on top. Use the latest tools to meet your tight deadlines.</li>
<li><strong>Compliance Officers</strong>: Provide verifiable proof for audits required by government agencies.</li>
<li><strong>Security Professionals</strong>: Mitigate supply chain attacks with full transparency to meet regulatory demands.</li>
</ul>
<h2 id="whats-included-in-the-example">What’s Included in the Example</h2>
<p>Our example <a href="https://github.com/applicative-systems/secure-supply-chain">GitHub project applicative-systems/secure-supply-chain</a>
shows this vision in action.
It provides a relatively minimal bootable NixOS live CD/USB image with halfway realistic demo applications:</p>
<ul>
<li><strong>C++ Database Writer</strong>: Listens on a TCP port, pipes the user input to a PostgreSQL
database.</li>
<li><strong>Rust Database Reader</strong>: Serves database content over HTTP.</li>
</ul>
<p>The booted ISO runs these services.</p>
<p><img src="https://nixcademy.com/_astro/scenario.BA01ABN6_Z2cKLVu.webp" alt="" width="2296" height="2145" loading="lazy" decoding="async"/></p>
<p>We use this image as a halfway realistic demonstrator:
This could be your product image and we show how to rebuild everything completely from scratch to demonstrate your supply chain integrity.</p>
<p>The project’s <a href="https://github.com/applicative-systems/secure-supply-chain/blob/main/README.md">README.md</a> explains the full steps without much detail.
Follow the rest of this article for the explanation of what it does.</p>
<h2 id="the-nix-deep-dive-from-package-derivations-to-verifiable-closures">The Nix Deep Dive: From Package Derivations to Verifiable Closures</h2>
<p>The bootable ISO/USB image in the repository can be built by a simple <code>nix build .#iso</code> call.
This is great as it will work on any machine/computer the same, but it doesn’t explain where the sources really come from.
Also, it will not rebuild everything from source bacause it can download most of the packages from the typically
<em>trusted</em> <a href="https://cache.nixos.org/"><code>cache.nixos.org</code></a> - but that won’t give us the government authories’ acceptance.</p>
<p>When we run <code>nix derivation show</code> on the output of our system image Nix recipe, we get output like this:</p>
<pre tabindex="0" data-language="json"><code><span><span>$ nix derivation show $(nix build --print-out-paths .#iso)</span></span>
<span><span>{</span></span>
<span><span>  &#34;/nix/store/sd3cmxsjpjpl298v88csr96ywph1s39g-nixos-supply-chain-25.05pre-git-x86_64-linux.iso.drv&#34;</span><span>: {</span></span>
<span><span>    #</span><span> ...</span></span>
<span><span>    &#34;inputDrvs&#34;</span><span>: {</span></span>
<span><span>        #</span><span> list</span><span> of</span><span> derivations</span><span> that</span><span> this</span><span> derivation</span><span> depends</span><span> on</span></span>
<span><span>        &#34;/nix/store/abc123-bla.drv&#34;</span><span>: {</span></span>
<span><span>            #</span><span> ...</span></span>
<span><span>        },</span></span>
<span><span>    },</span></span>
<span><span>    &#34;inputSrcs&#34;</span><span>: [</span></span>
<span><span>        #</span><span> list</span><span> of</span><span> source</span><span> folders</span><span>, </span><span>scripts</span><span>, </span><span>and</span><span> other</span><span> directly</span></span>
<span><span>        #</span><span> referenced</span><span> files</span></span>
<span><span>    ],</span></span>
<span><span>    &#34;name&#34;</span><span>: </span><span>&#34;nixos-supply-chain-25.05pre-git-x86_64-linux.iso&#34;</span><span>,</span></span>
<span><span>    &#34;outputs&#34;</span><span>: {</span></span>
<span><span>        &#34;path&#34;</span><span>: </span><span>&#34;/nix/store/xvrwkzlz8a1jbvn910kvc0k27j6qhmjx-nixos-supply-chain-25.05pre-git-x86_64-linux.iso&#34;</span></span>
<span><span>      }</span></span>
<span><span>    },</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>This is the JSON-structured content of the <a href="https://nix.dev/manual/nix/2.25/language/derivations">Nix derivation</a>.
(Nix expressions that describe packages, evaluate to derivations.
Derivations are more machine-readable data structures that describe a complete build environment)
This one describes the <strong>inputs</strong> to our system image:</p>
<ul>
<li><code>inputSrcs</code>: These are files and folders that are directly referenced from e.g. a git repo or some download URL - this is typically the source code of a project, or scripts or patches, etc. If they are not there, they cannot be generated.</li>
<li><code>inputDrvs</code>: These are the <em>derivations</em> of the compilers, build systems, and all kinds of other tools. If they are not there, yet, they can be built from their own sources, or downloaded from a Nix binary cache (we aren’t allowed to do the latter if we want to prove supply chain integrity).</li>
</ul>
<p>(By the way: In our <a href="https://nixcademy.com">Nix &amp; NixOS 101 trainings</a>, we cover this topic thoroughly on the second day!)</p>
<p>For our system image, this data structure practically describes the <em>first level</em> dependency list.
In the following image these are the light blue boxes:</p>
<p><img src="https://nixcademy.com/_astro/deptree-simple.CsXTHx3H_Z3l7G3.webp" alt="" width="3993" height="2720" loading="lazy" decoding="async"/></p>
<p>(The dependencies are vastly simplified as the diagram’s complexity would increase a lot if we included everything)</p>
<h3 id="building-the-dependency-tree">Building the Dependency Tree</h3>
<p>As our derivation depends on other derivations, we could nest down into each and every derivation and obtain the next list of dependencies.
The <code>--recursive</code> flag of the last command does this:</p>
<pre tabindex="0" data-language="console"><code><span><span>$ nix derivation show --recursive $(</span><span>nix</span><span> build</span><span> --print-out-paths</span><span> .#iso</span><span>)</span></span>
<span></span></code></pre>
<p>The output of this command is a list of derivation data structures.
The following diagram shows the graph structure (again, a bit simplified) that this output describes.
Here, we can see that our build systems also need to be compiled from some source if they are not available already.
And the compiler needs to be bootstrapped from some other compiler, and so on:</p>
<p><img src="https://nixcademy.com/_astro/deptree.Clhpy8Ha_Z1nC7uv.webp" alt="" width="3749" height="5554" loading="lazy" decoding="async"/></p>
<p>After following all the dependencies’ dependencies, we arrive at source packages and the bootstrap compiler.
Nixpkgs defines the so-called <a href="https://github.com/NixOS/nixpkgs/blob/master/pkgs/stdenv/linux/make-bootstrap-tools.nix">bootstrap tarball</a>
which contains the bootstrap compiler, a minimal bootstrap shell, and minimized coreutils.
It is roughly 30MB small (which makes it itself nicely auditable) and is the only binary piece (which we can also build from source if we like)
that we need to start with to build <strong>everything</strong> else from source.</p>
<p><strong>To prove that this set of sources led to our product binary</strong>, we can do this:</p>
<ol>
<li>Strip all intermediate derivations and only keep downloadable and content-verifyable source packages.</li>
<li>Export these to an offline system. This system must have been set up (once) beforehand in such a way that the verifying authorities accept its integrity.</li>
<li>Rebuild everything from scratch on the offline system to produce the binary.</li>
</ol>
<p>In some sense, we are extracting the <em>leafs</em> from the <em>tree</em>.
But how do we do that?</p>
<h3 id="stripping-the-sources-from-the-dependency-tree">Stripping the Sources from the Dependency Tree</h3>
<p>This is simple with Nix:
All source packages and the bootstrap tarball are so-called
<a href="https://nix.dev/manual/nix/2.24/language/advanced-attributes.html?highlight=outputhash#adv-attr-outputHash"><em>fixed-output derivations</em> (FOD)</a>
and can be easily filtered out.</p>
<p>Compared to regular derivations, the builder process of a fixed-output derivation has access to the internet,
but only if it provides the promise of an <em>output hash</em>:</p>
<pre tabindex="0" data-language="nix"><code><span><span># example fixed-output derivation</span></span>
<span><span>builtins</span><span>.</span><span>fetchurl</span><span> {</span></span>
<span><span>  url</span><span> =</span><span> &#34;http://some/download/source.tar.gz&#34;</span><span>;</span></span>
<span><span>  sha256</span><span> =</span><span> &#34;1md7jsf123a45z73bz1kszpp01yw6x5ljkjk2hx7wl800any6465&#34;</span><span>;</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>Fixed-output derivations fail if the promished hash does not hold true for the output.
And if it doesn’t fail, we don’t even care if the download mirror is owned by some untrusted third party - as the
hash proves that the content is what we expected.
This kind of derivation is necessary for all source downloads - if we cannot access the source, we cannot generate it or magically let it appear.</p>
<p>The part that we are aiming for are all the packages in the “Fixed-output Derivations” box in this diagram:</p>
<p><img src="https://nixcademy.com/_astro/deptree-source.B_b6qVaj_Z14JaUe.webp" alt="" width="5533" height="6374" loading="lazy" decoding="async"/></p>
<p>We already had that information, it was just unfiltered.
This command extracts all the <em>FOD leafs</em>:</p>
<pre tabindex="0" data-language="console"><code><span><span>$ nix derivation show -r </span><span>&#34;$(</span><span>nix</span><span> build .#iso </span><span>--print-out-paths</span><span>)&#34;</span><span> |</span></span>
<span><span>  jq -r &#39;to_entries[] | select(.value.outputs.out.hash != null) | .key&#39;</span></span>
<span></span></code></pre>
<p><a href="https://jqlang.org/"><code>jq</code></a> is a useful JSON processor app that helps us filter all the derivations which have an <strong>output hash</strong>.
Every derivation that knows the hash of its own output is a <a href="https://nix.dev/manual/nix/2.24/language/advanced-attributes.html?highlight=outputhash#adv-attr-outputHash"><em>fixed-output derivation</em> (FOD)</a>.</p>
<p>Once we have all the fixed-output derivations in a list, we can export them from the Nix store into a single file:</p>
<pre tabindex="0" data-language="console"><code><span><span>$ nix-store --export </span><span>&#34;${</span><span>fixedOutputDerivations</span><span>[</span><span>@</span><span>]}&#34;</span><span> &gt;</span><span> source-export.closure</span></span>
<span></span></code></pre>
<p>This new file <code>source-export.closure</code> weighs 5.5 GB in our example project.
This is not small but might could realistically be audited by third parties.
(We can even easily append more meta information like the origin URLs etc.
to make that process easier)</p>
<h3 id="the-final-rebuild">The Final Rebuild</h3>
<p>Someone with security clearance could now take the <code>source-export.closure</code> file,
copy it on a USB stick or similar, carry it to a verified air-gapped system and
completely rebuild everything there from scratch.
This proves the integrity of the binary files created in the process
(assuming the system on which the offline build runs has been verified in a separate process).</p>
<p>On that offline system, we simply run:</p>
<pre tabindex="0" data-language="console"><code><span><span>$ nix-store --import </span><span>&lt;</span><span> source-export.closure</span></span>
<span><span>$ nix-build path/to/nix/expression.nix</span></span>
<span></span></code></pre>
<p>This system cannot download anything as it can’t access the internet, so it rebuilds
<em>eeeeeeverything</em> from scratch.
For the example repository, this took another ~12 hours on a regular laptop.
The result <em>must</em> have been created from the sources in the tarball and nothing else!</p>
<p>Because we not only demonstrate the integrity of our payload binaries, but also the
integrity of our compilers’ compilers, this demonstration goes arguably deeper than what
parties do who start with binary distributions (e.g. Debian, Ubuntu, Fedora, etc.).</p>
<h2 id="conclusion">Conclusion</h2>
<p>In essence, we’ve shown how Nix enables definitive proof that your system image is
derived solely from a specific, trusted set of sources—including all dependencies and build tools.
By gathering all necessary source materials into a single “source closure”,
a complete offline rebuild is feasible, providing verifiable supply chain integrity.</p>
<p>This capability transforms compliance from a development roadblock into a final verification step.
By decoupling development from stringent, upfront security protocols, teams can utilize the latest tools,
collaborate more effectively, and contribute to open source projects seamlessly.
The complex task of supply chain proof for regulatory bodies is streamlined to a manageable and cheap operation,
realistically achievable by a single individual with a single machine.</p>
<p><img src="https://nixcademy.com/_astro/intranet.BDTYrkUh_Z1jsok7.webp" alt="" width="3543" height="4084" loading="lazy" decoding="async"/></p>
<p>Nix’s power stems from its core features: reproducible builds, fixed-output derivations,
and the ability to create offline source closures.
While using Nix for the first time involves navigating unique challenges and adapting existing workflows,
it offers integrity and reproducibility like no other tool (btw. <a href="https://guix.gnu.org/">guix</a> also exists).
Nix makes software development with robust supply chain guarantees a realistic
and cheap post-development process, rather than a costly and restrictive constraint from the outset.</p>
<p>Please note that using the famous Nix patterns <a href="https://nixcademy.com/posts/what-is-ifd-ups-and-downs/">IFD</a> and
<a href="https://github.com/NixOS/nix/issues/6316">dynamic derivations</a> might reduce the simplicity of this process.
Of course, there are also solutions.</p>
<p>We at Nixcademy have extensive experience in guiding companies through this adoption process.
We help organizations understand the opportunities and risks at the management level and work alongside
engineering teams to implement these solutions effectively.
If you’re looking to leverage Nix to strengthen your supply chain security, streamline compliance, and
empower your development teams, we’re here to help.
Contact us to explore how we can tailor these powerful Nix-based solutions to fit your specific needs and processes.</p> </article></div>
  </body>
</html>
