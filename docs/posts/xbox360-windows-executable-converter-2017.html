<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/rexdex/recompiler">Original</a>
    <h1>Xbox360 â€“&gt; Windows Executable Converter (2017)</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text"><h2 tabindex="-1" dir="auto"><a id="user-content-current-release" aria-hidden="true" href="#current-release"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Current release</h2>
<p dir="auto"><a href="https://ci.appveyor.com/project/rexdex/recompiler" rel="nofollow"><img src="https://camo.githubusercontent.com/2507e50e98565989cbdaaa730ab5e14f944ea871f8768632a853c3f5ced07bf2/68747470733a2f2f63692e6170707665796f722e636f6d2f6170692f70726f6a656374732f7374617475732f30723537656469386a646161333430383f7376673d74727565" alt="Build status" data-canonical-src="https://ci.appveyor.com/api/projects/status/0r57edi8jdaa3408?svg=true"/></a></p>
<p dir="auto">Note that it still requires Microsoft Visual Studio 2015 or newer to be installed. Moving to clang/llvm soon :)</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-porting-xbox360-executables-to-windows" aria-hidden="true" href="#porting-xbox360-executables-to-windows"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Porting Xbox360 executables to Windows</h2>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/rexdex/recompiler/blob/master/_images/xbox_remcompiler.jpg"><img src="https://github.com/rexdex/recompiler/raw/master/_images/xbox_remcompiler.jpg" alt="DolphinDemoScreenshot"/></a></p>
<p dir="auto">The idea is simple: <em>what if you could take the Xbox360 game and run it on your PC?</em> Is this even possible in principle? I was pondering this question few years ago and that should not come as a surprise that there are some obvious technical difficulties in getting this done:</p>
<ul dir="auto">
<li>
<p dir="auto"><strong>Different CPUs</strong> - Xbox360 uses PowerPC based CPU, our PCs are based on x86 architecture. They are different in so many ways that I don&#39;t even know where to start :) PowerPC is RISC based, has shitloads of registers but very simple instructions. x86 is totally different on the other hand - not so many registers and many more instructions that are more complicated (addressing modes...). It&#39;s obvious that a simple transcription is not feasible.</p>
</li>
<li>
<p dir="auto"><strong>Memory Layout</strong> - Xbox360 uses BigEndian byte ordering, x86 CPUs use LittleEndian. To be compatible with incoming data that is being read from files and read/written into the memory all memory based operands must be byteswapped. This may pose a significant performance issue.</p>
</li>
<li>
<p dir="auto"><strong>Encrypted executable image</strong> - Yup, for various reasons the executables on Xbox360 are encrypted. There are some cleaver guys in Russia though that figured how :)</p>
</li>
<li>
<p dir="auto"><strong>Different and outdated GPU architecture</strong> - If we want to see any graphics rendered the GPU needs to be emulated. There are two hard nuts to crack: first, the shaders we see will be complied into the GPU compatible format, no HLSL on input, sorry. Those shaders will have to be reverse engineered as well. Secondly, the Xbox360 GPU was using ~10MB of internal memory called EDRAM that was serving as a temporary storage of render target for the duration of rendering. Although some cards today still use similar concept this is never exposed directly to the user. Since there a lot of different ways people used the EDRAM on Xbox this part has to be emulated. To be honest probably differently for every game.</p>
</li>
<li>
<p dir="auto"><strong>Inlining of graphics/kernel functions</strong> - Some of the functions used while compiling the executable were inlined directly into the compiled code making it much harder to write a simple API level wrapper. This kills the dream of making &#34;function level&#34; wrapper where we could just go and wrap the &#34;d3d-&gt;DrawPrimitive&#34; call directly. Nope, this is not going to happen.</p>
</li>
</ul>
<p dir="auto">Fortunately, every problem is solvable and the answer is <em><strong>YES</strong></em> in principle. If you want to know how, keep reading :)</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-current-state-of-the-project" aria-hidden="true" href="#current-state-of-the-project"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Current state of the project</h2>
<p dir="auto">Currently the published branch of the project allows to run simple Xbox360 demo apps (samples). I&#39;ve not yet attempted to run it with any real game as it probably would not work with anything big and serious. Also, on the legal side, this is a fine line because getting anything bigger is tricky as it requires going basically to the Torrent Sites and digging through old Xbox Live Arcade content or pirated game. Xbox360 is not yet abandonware :) For the same reason there are no source executables given, you need to get one &#34;from somewhere&#34;. Sorry :(</p>
<p dir="auto">Stuff currently implemented:</p>
<p dir="auto"><em><strong>Backend</strong></em> (offline processing):</p>
<ul dir="auto">
<li>XEX image loading, decryption and decompression</li>
<li>PowerPC instruction disassembly</li>
<li>Program blocks reconstruction</li>
<li>Generation C++ equivalent code for whole executable (&#34;recompilation&#34;)</li>
<li>96% of PowerPC CPU instructions implemented</li>
</ul>
<p dir="auto"><em><strong>Runtime</strong></em> (host):</p>
<ul dir="auto">
<li>Loading and running recompiled image (as DLL)</li>
<li>Basic kernel with threads, synchronization</li>
<li>Basic IO with file support</li>
<li>GPU command queue bootstrap</li>
<li>Tracing functionality (offline debugging)</li>
</ul>
<p dir="auto"><em><strong>GPU</strong></em>:</p>
<ul dir="auto">
<li>AMD Microcode shader disassembly and recompilation into DX11 HLSL shaders</li>
<li>Command buffer parser and executor</li>
<li>Very simple EDRAM simulator</li>
<li>Trace dump functionality</li>
</ul>
<p dir="auto"><em><strong>Debugging tools</strong></em></p>
<ul dir="auto">
<li>Basic IDE that allows to view the disassembly</li>
<li>Basic offline (trace based) debugger that allows to inspect every executed instruction</li>
<li>Basic GPU trace viewer that allows to inspect internal GPU state at each point</li>
<li><em>Time Machine</em> tool that makes it possible to find previous instruction that touched given register or memory</li>
</ul>
<h2 tabindex="-1" dir="auto"><a id="user-content-how-to-run-it-" aria-hidden="true" href="#how-to-run-it-"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>How to run it ?</h2>
<p dir="auto">(NOTE: You require Visual Studio 2015 to build and use this project - at present it is entirely Windows-specific with regards to the code and the build process.)</p>
<ul dir="auto">
<li>Get <code>wxWidgets 3.1.0</code> and compile it to obtain the x64 DLLs. Place them in <code>dev\external\wxWidgets-3.1.0\</code>.</li>
<li>Open the solution <code>recompile.sln</code> under <code>dev\src</code> with Visual Studio. This is the top-level VS solution that we will use to build the project.</li>
<li>Compile the whole solution. You should now have binaries and their associated symbols under <code>_bin\Debug</code> in your project root directory.</li>
</ul>
<p dir="auto">Now you have two ways to use a binary XEX file and obtain x86-64 code from it. The first way is to use the GUI, which can be launched using <code>recompiler_tools</code>. This way is straightforward - create a new project (or open an existing <code>.rep</code> project), add an image to it (this is your XEX file), and then use the toolbar to build the imported image. You will see a log window pop up and at the end of the process, you should be able to click on the <em>Run</em> button to run your newly recompiled binary.</p>
<p dir="auto">The second way is to use the command-line APIs as follows:</p>
<ul dir="auto">
<li>Run <code>recompiler_api -command=decompile -in=imagePath -out=outputPath</code> to decompile your image. <code>imagePath</code> should point to your XEX file, and <code>outputPath</code> should point to the folder where you want the output (uncompressed XEX, with the filename <code>output.pdi</code>) to go to.</li>
<li>Run <code>recompiler_api -command=recompile -in=pdiPath -out=outputPath -generator=cpp_msvc</code> to recompile the PDI output from the previous step into native code. At the end of the process you should have the recompiled binary, <code>code.bin</code> in <code>outputPath</code>.</li>
<li>Run <code>xenon_launcher -fsroot=dataPath -image=binPath</code> to launch the recompiled binary. <code>dataPath</code> refers to the folder where the assets of the binary can be found (example: <code>projects\xenon\dolphin</code> for the file <code>dolphin.xex</code>), and <code>binPath</code> is the location of the <code>.bin</code> file from the previous step.</li>
</ul>
<p dir="auto">To exit the app (or end the <code>xenon_launcher</code> process), simply close the GPU output window.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-references" aria-hidden="true" href="#references"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>References</h2>
<ul dir="auto">
<li><a href="http://www.openrce.org/forums/posts/111" rel="nofollow">XEX information</a></li>
<li><a href="http://fileadmin.cs.lth.se/cs/education/EDAN25/PowerISA_V2.07_PUBLIC.pdf" rel="nofollow">PowerPC ISA</a></li>
<li><a href="http://www.free60.org/wiki/XEX" rel="nofollow">Free60 description of the XEX</a></li>
<li><a href="https://github.com/Free60Project">Sourcecode of the Free60 project</a></li>
<li><a href="http://developer.amd.com/wordpress/media/2012/10/R600_Instruction_Set_Architecture.pdf" rel="nofollow">Radeon R600 ISA</a></li>
<li><a href="https://github.com/freedreno/freedreno/blob/master/includes/instr-a2xx.h">Radeon microcode decompiler</a></li>
<li><a href="http://amd-dev.wpengine.netdna-cdn.com/wordpress/media/2013/10/R6xx_R7xx_3D.pdf" rel="nofollow">Radeon R6xx/R7xx Acceleration</a></li>
<li><a href="http://cgit.freedesktop.org/xorg/driver/xf86-video-radeonhd/tree/src/r6xx_accel.c?id=3f8b6eccd9dba116cc4801e7f80ce21a879c67d2#n454" rel="nofollow">Radeon Linux Driver</a></li>
<li><a href="https://github.com/freedreno/amd-gpu/blob/master/include/reg/yamato/22/yamato_offset.h%5D">Radeon Driver parts</a></li>
<li><a href="https://github.com/freedreno/amd-gpu/blob/master/">Actual open source Radeon Driver</a></li>
<li><a href="http://fossies.org/dox/MesaLib-10.3.5/fd2__gmem_8c_source.html%5D" rel="nofollow">Mesa source code</a></li>
<li><a href="http://www.x.org/docs/AMD/old/evergreen_3D_registers_v2.pdf" rel="nofollow">Radeon Evergreen 3D Register Reference Guide</a></li>
<li><a href="https://github.com/freedreno/mesa/blob/master/src/mesa/drivers/dri/r200/r200_state.c">Radeon R200 OpenGL driver</a></li>
<li><a href="http://ftp.tku.edu.tw/NetBSD/NetBSD-current/xsrc/external/mit/xf86-video-ati/dist/src/r600_reg_auto_r6xx.h" rel="nofollow">Radeon R600 driver parts</a></li>
<li><a href="http://msdn.microsoft.com/en-us/library/windows/desktop/cc308051(v=vs.85).aspx" rel="nofollow">Legacy rendering formats</a></li>
<li><a href="https://code.google.com/p/crunch/source/browse/trunk/inc/crn_decomp.h#4104" rel="nofollow">Crunch texture decompression</a></li>
<li><a href="http://create.stephan-brumme.com/disclaimer.html%5D" rel="nofollow">CRC32 calculation</a></li>
<li><a href="http://www.intel.com/technology/comms/perfnet/download/CRC_generators.pdf" rel="nofollow">CRC calculation</a></li>
<li><a href="http://sourceforge.net/projects/slicing-by-8/" rel="nofollow">Slicing-by-8 CRC algorithm</a></li>
<li><a href="http://www.nirsoft.net/kernel_struct/vista/KOBJECTS.html" rel="nofollow">Kernel objects on Windows Vista</a></li>
<li><a href="http://www.nirsoft.net/kernel_struct/vista/SLIST_HEADER.html" rel="nofollow">More Windows kernel stuff</a></li>
<li><a href="http://www.drdobbs.com/inside-nts-asynchronous-procedure-call/184416590?pgno=1" rel="nofollow">APC on Windows</a></li>
<li><a href="http://msdn.microsoft.com/en-us/library/ff552263" rel="nofollow">RtlFillMemoryUlong reference</a></li>
<li><a href="http://code.google.com/p/vdash/source/browse/trunk/vdash/include/kernel.h" rel="nofollow">Dashboard for Xbox360</a></li>
<li><a href="https://www.google.com/patents/US20060055701" rel="nofollow">Tiled rendering patent</a></li>
<li><a href="http://tools.ietf.org/html/rfc1951" rel="nofollow">Deflate compression</a></li>
</ul>
<h2 tabindex="-1" dir="auto"><a id="user-content-xex" aria-hidden="true" href="#xex"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>XEX</h2>
<p dir="auto">First, the XEX (Xbox Executable) format must be ripped apart and the actual code has to be extracted. XEX is a Xbox360 specific executable packing/encryption format. It&#39;s not very complicated and quite good description can be found here: <a href="http://free60.org/wiki/Main_Page" rel="nofollow">Free60</a>. There are also some old references <a href="http://www.openrce.org/forums/posts/111" rel="nofollow">here</a>. Inside the XEX there are some platform specific headers (like file certificate, media/region information, file encryption key, etc) but also there&#39;s a normal
PE style executable, unfortunately it&#39;s packed and encrypted.</p>
<p dir="auto">Decryption of any actual executables requires knowing the secret AES key that is used internally by the loader to compute another AES key that is actually used to decrypt the file content. I found it on a Russian site few years ago but could not retrace my steps any more, most likely the site is down gone for good. The rest of the XEX format suggests strongly that it was basically built on top of existing PE image loader that existed in the OS. The compression used in the XEX is either simple block based compression or a variation of LZ compression. Both were identified and reversed years ago by people trying to break the Xbox360 anti-piracy protection.</p>
<p dir="auto">Anyway, after dealing with those two bumps on the road and unpacking the &#34;internal EXE&#34; from the XEX we follow normal disassembly procedure. In general case we end up with a list of sections:</p>
<div data-snippet-clipboard-copy-content=".rdata   0x00000400-0x0004C100 r__
.pdata   0x0004C200-0x00053358 r__
.text    0x00060000-0x0026B158 r_x
.data    0x00270000-0x00289D50 rw_
.XBMOVIE 0x00289E00-0x00289E08 rw_
.idata   0x00290000-0x00290268 rw_
.XBLD    0x002A0000-0x002A0090 r__
.reloc   0x002A0200-0x002B2EF4 r__"><pre><code>.rdata   0x00000400-0x0004C100 r__
.pdata   0x0004C200-0x00053358 r__
.text    0x00060000-0x0026B158 r_x
.data    0x00270000-0x00289D50 rw_
.XBMOVIE 0x00289E00-0x00289E08 rw_
.idata   0x00290000-0x00290268 rw_
.XBLD    0x002A0000-0x002A0090 r__
.reloc   0x002A0200-0x002B2EF4 r__
</code></pre></div>
<p dir="auto">The only section that contains executable code is the .text section and only that section requires disassembly. Rest of the sections must still be loaded into the memory when we try to execute the code since data may be read/written into those addresses. For now I did not implement any data relocation so the unpacked image must be loaded exactly under its base address. Fortunately on 64-bit systems this is achievable fairly easily.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-disassembly" aria-hidden="true" href="#disassembly"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Disassembly</h2>
<p dir="auto">Disassembling the PowerPC instructions is a pleasure. After we identify the .text (code) section in the PE executable the rest is straightforward. Every instruction is always 4 bytes so there is no ambiguity like with x86 instructions and even if we don&#39;t know how to decode a particular instruction we can easily continue with the rest of the code. This allows us to have semi-working solution way sooner than with x86. See the <a href="https://github.com/rexdex/recompiler/blob/master/dev/src/platforms/xenon/xenonDecompiler/xenonInstructionDecoding.cpp">actual file</a> for details.</p>
<p dir="auto">Basically in this project I&#39;ve tried 3 ways to approach the subject:</p>
<ul dir="auto">
<li>
<p dir="auto">Script based (for faster iteration) - I&#39;ve written a LUA script that was doing the disassembly. It was fast to iterate in small samples but very slow to run and disassemble millions of instructions in normal executables was taking minutes. Even to check if an instruction is valid instruction was taking way too much time.</p>
</li>
<li>
<p dir="auto">Data driven pattern matching - Basically a big XML with binary &#34;rules&#34; that were matching bit patterns and emitting instructions. This was much faster but because of the corner cases in the PowerPC instruction encoding it got messy in the end and required me to do a lot of copy-pasting. Performance wise it was fast and could work if not for a one little detail: it&#39;s not enough just to disassemble the code, we still need to extract some &#34;metadata&#34; out of the code (like register dependencies, calculated jump addresses, etc). This still requires us to know a little bit about the instruction that just its name. So, the template-based disassembler was producing an instruction named &#34;bc&#34; but I still had to write manual code to understand that it&#39;s a &#34;conditional branch&#34; and even more code to be able to evaluate this condition.</p>
</li>
<li>
<p dir="auto">Finally I ended up with an abstract CPUInstruction class that is implemented for every instruction that CPU implements + a big ass C++ switch() to do the disassembly. This is actually very nice and maintainable solution.</p>
</li>
</ul>
<p dir="auto">The <em><strong>biggest</strong></em> and most valuable resources on this topic were the official PowerPC instruction set documentation: <a href="http://fileadmin.cs.lth.se/cs/education/EDAN25/PowerISA_V2.07_PUBLIC.pdf" rel="nofollow">Power ISA Version 2.07</a></p>
<h2 tabindex="-1" dir="auto"><a id="user-content-testing-the-disassembler" aria-hidden="true" href="#testing-the-disassembler"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Testing the disassembler</h2>
<p dir="auto">I had lots of bugs in the disassembler. Of course, I could write a unit test for each instruction but that would just take ages. The fastest way I&#39;ve found to test the correctness of the disassembly is to compare the output with something that we know works. Basically, disassembling any big PowerPC executable by IDA or any other disassemble and comparing the output of tens of millions of instructions is a very good step towards some level of trust that the disassembler is working :)</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-xbox360-specific-instructions" aria-hidden="true" href="#xbox360-specific-instructions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>XBox360 specific instructions</h2>
<p dir="auto">Xbox360 has a special version of the PowerPC CPU that has 128 VMX registers (instead of 32 ones in the standard CPU). Those registers are used for vectorized math operations (similarly to SSE). There&#39;s no way to address 128 registers in normal PowerPC instructions because there are only 5 bits delegated to indicate the register index in every instruction and this pattern is CPU-wide. Unfortunately, the opcodes for those special instructions are not available on the internet (or are buried deeply). I ended up reversing the opcodes manually by observing the bit patters in the generated listing files. There&#39;s a simple tool I&#39;ve wrote for that <a href="https://github.com/rexdex/recompiler/blob/master/dev/tools/xprint/XOpPrint.cpp">XPrint</a>. Typical output of a decoded instruction bit pattern looks like this:</p>
<div data-snippet-clipboard-copy-content="Instruction &#39;vxor128&#39; (3 params)
 Mask: &#39;000101** ******** ******11 00*1****&#39;
  Field[0]: 27:1 (1)
  Field[1]: 22:4 (12)
  Field[2]: 0:6 (5)
    Variants for param 0 (10):
        Mask:            ------** ***----- -------- ----**--
        Variant    vr0:  ------00 000***** *****0-- --0-0000
        Variant    vr1:  ------00 0010000* 0000**-- --*-00**
		....
        Variant   vr97:  ------00 00100001 00001*-- --*-11**
    Variants for param 1 (10):
        Mask:            -------- ---***** -----*-- --*-----
        Variant    vr0:  ------** ***00000 *****0-- --0-0000
        Variant    vr1:  ------00 00*00001 0000*0-- --0-****
        Variant    vr2:  ------00 00000010 000000-- --0-0000
		....
        Variant   vr97:  ------00 00100001 000011-- --1-****
    Variants for param 2 (10):
        Mask:            -------- -------- *****--- ------**
        Variant    vr0:  ------** ******** 000000-- --0-0000
        Variant    vr1:  ------00 00*0000* 00001*-- --*-**00
        Variant    vr2:  ------00 00000000 000100-- --0-0000
		....
        Variant   vr97:  ------00 00100001 00001*-- --*-**11"><pre><code>Instruction &#39;vxor128&#39; (3 params)
 Mask: &#39;000101** ******** ******11 00*1****&#39;
  Field[0]: 27:1 (1)
  Field[1]: 22:4 (12)
  Field[2]: 0:6 (5)
    Variants for param 0 (10):
        Mask:            ------** ***----- -------- ----**--
        Variant    vr0:  ------00 000***** *****0-- --0-0000
        Variant    vr1:  ------00 0010000* 0000**-- --*-00**
		....
        Variant   vr97:  ------00 00100001 00001*-- --*-11**
    Variants for param 1 (10):
        Mask:            -------- ---***** -----*-- --*-----
        Variant    vr0:  ------** ***00000 *****0-- --0-0000
        Variant    vr1:  ------00 00*00001 0000*0-- --0-****
        Variant    vr2:  ------00 00000010 000000-- --0-0000
		....
        Variant   vr97:  ------00 00100001 000011-- --1-****
    Variants for param 2 (10):
        Mask:            -------- -------- *****--- ------**
        Variant    vr0:  ------** ******** 000000-- --0-0000
        Variant    vr1:  ------00 00*0000* 00001*-- --*-**00
        Variant    vr2:  ------00 00000000 000100-- --0-0000
		....
        Variant   vr97:  ------00 00100001 00001*-- --*-**11
</code></pre></div>
<h2 tabindex="-1" dir="auto"><a id="user-content-abstract-instruction" aria-hidden="true" href="#abstract-instruction"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Abstract instruction</h2>
<p dir="auto">The result of disassembly process is an &#34;unpacked instruction&#34;. The most useful thing is that the opcode and operands are unpacked so an easy &#34;ToString&#34; method can be written for presentation purposes. Surprisingly, this structure captures a lot of quirks of not only the PowerPC instructions but Intel as well. On PowerPC the operand type is closely related to the particular instruction type (add vs addi, etc). On Intel this is not the case and the same instruction (add) may be used with immediate value as well as memory location, etc. To capture this generalization the Operand structure is introduced.</p>
<div dir="auto" data-snippet-clipboard-copy-content="class  Instruction
{
public:
	// register reference (uses the CPU definition directly)
	typedef const platform::CPURegister* TReg;

	// opcode reference
	typedef const class platform::CPUInstruction* TOpcode;
		
	// operand addressing mode
	enum Type
	{
		eType_None,	// invalid (not defined)
		eType_Reg,	// register only, &#34;r&#34;
		eType_Imm,	// immediate only &#34;i&#34;
		eType_Mem,	// dereferenced register &#34;[r] or [r+d+idx*scale]&#34;
	};

	// instruction operand 
	struct Operand
	{
		Type    m_type;    // common
		uint8   m_scale;   // x86 only
		TReg    m_reg;     // common
		uint32  m_imm;     // immediate value, always SIGN EXTENDED if needed
		TReg    m_index;   // index register
		TReg    m_segment; // segment register

		inline Operand()
			: m_type( eType_None )
			, m_reg( nullptr )
			, m_scale( 1 )
			, m_imm( 0 )
			, m_index( nullptr )
			, m_segment( nullptr )
		{}
	};

protected:
	// size of the instruction (in bytes)
	uint8 m_codeSize;

	// size of used data in the instruction - 2, 4, 8
	uint8 m_dataSize;

	// size of address calculation registers, 2, 4, 8
	uint8 m_addrSize;

	// instruction opcode
	TOpcode m_opcode;

	// operands (not all instructions use all)
	Operand m_arg0;
	Operand m_arg1;
	Operand m_arg2;
	Operand m_arg3;
	Operand m_arg4;
	Operand m_arg5;
};"><pre><span>class</span>  <span>Instruction</span>
{
<span>public:</span>
	<span><span>//</span> register reference (uses the CPU definition directly)</span>
	<span>typedef</span> <span>const</span> platform::CPURegister* TReg;

	<span><span>//</span> opcode reference</span>
	<span>typedef</span> <span>const</span> <span>class</span> <span>platform</span>::CPUInstruction* TOpcode;
		
	<span><span>//</span> operand addressing mode</span>
	<span>enum</span> Type
	{
		eType_None,	<span><span>//</span> invalid (not defined)</span>
		eType_Reg,	<span><span>//</span> register only, &#34;r&#34;</span>
		eType_Imm,	<span><span>//</span> immediate only &#34;i&#34;</span>
		eType_Mem,	<span><span>//</span> dereferenced register &#34;[r] or [r+d+idx*scale]&#34;</span>
	};

	<span><span>//</span> instruction operand </span>
	<span>struct</span> <span>Operand</span>
	{
		Type    m_type;    <span><span>//</span> common</span>
		uint8   m_scale;   <span><span>//</span> x86 only</span>
		TReg    m_reg;     <span><span>//</span> common</span>
		uint32  m_imm;     <span><span>//</span> immediate value, always SIGN EXTENDED if needed</span>
		TReg    m_index;   <span><span>//</span> index register</span>
		TReg    m_segment; <span><span>//</span> segment register</span>

		<span>inline</span> <span>Operand</span>()
			: m_type( eType_None )
			, m_reg( <span>nullptr</span> )
			, m_scale( <span>1</span> )
			, m_imm( <span>0</span> )
			, m_index( <span>nullptr</span> )
			, m_segment( <span>nullptr</span> )
		{}
	};

<span>protected:</span>
	<span><span>//</span> size of the instruction (in bytes)</span>
	uint8 m_codeSize;

	<span><span>//</span> size of used data in the instruction - 2, 4, 8</span>
	uint8 m_dataSize;

	<span><span>//</span> size of address calculation registers, 2, 4, 8</span>
	uint8 m_addrSize;

	<span><span>//</span> instruction opcode</span>
	TOpcode m_opcode;

	<span><span>//</span> operands (not all instructions use all)</span>
	Operand m_arg0;
	Operand m_arg1;
	Operand m_arg2;
	Operand m_arg3;
	Operand m_arg4;
	Operand m_arg5;
};</pre></div>
<p dir="auto">In practice, the unpacked format is not good enough for many operations. After the disassembly is completed more work is needed to get the code to a useful state than just unpacking. For example, we need to identify the &#34;blocks&#34; - places in the code where execution enters a particular linear set of instruction that are going to be executed without interruptions until a &#34;jump&#34; or &#34;call&#34; to another block. It&#39;s nice and useful to abstract this instruction concept a little bit more. This is done by the following class:</p>
<div dir="auto" data-snippet-clipboard-copy-content="class InstructionExtendedInfo
{
public:
	static const uint32 MAX_REGISTERS = 8;

	enum EMemoryFlags
	{
		eMemoryFlags_Read		= 1 &lt;&lt; 0, // memory is being read by the instruction
		eMemoryFlags_Write		= 1 &lt;&lt; 1, // memory is being written by the instruction
		eMemoryFlags_Touch		= 1 &lt;&lt; 2, // memory is being touched but not read/write (cache)
		eMemoryFlags_Depends	= 1 &lt;&lt; 3, // instruction depends on the memory content in some obscure way
		eMemoryFlags_Aligned	= 1 &lt;&lt; 4, // instruction expects memory address to be aligned
		eMemoryFlags_Float		= 1 &lt;&lt; 5, // memory is expected to be loading point value
		eMemoryFlags_DirectMap  = 1 &lt;&lt; 6, // memory access is directly mapped (write/read instructions)
	};

	enum EInstructionFlags
	{
		eInstructionFlag_Nop		= 1 &lt;&lt; 0, // instruction can be removed
		eInstructionFlag_Jump		= 1 &lt;&lt; 1, // instruction represents a simple jump
		eInstructionFlag_Call		= 1 &lt;&lt; 2, // instruction represents a function call
		eInstructionFlag_Return		= 1 &lt;&lt; 3, // instruction represents a return from function
		eInstructionFlag_Diverge	= 1 &lt;&lt; 4, // instruction can diverge a flow of code (conditional branch)
		eInstructionFlag_Conditional= 1 &lt;&lt; 5, // instruction is conditional (uses condition registers or flags)
		eInstructionFlag_ModifyFlags= 1 &lt;&lt; 6, // instruction is modifying the flag registers
		eInstructionFlag_Static		= 1 &lt;&lt; 7, // instruction branch target is static
	};

	enum ERegDependencyMode
	{
		eReg_None = 0,
		eReg_Dependency = 1,
		eReg_Output = 2,
		eReg_Both = 3,
	};

	// instruction address and flags
	uint32 m_codeAddress;
	uint32 m_codeFlags;

	// speculated branch target (if known)
	uint64 m_branchTargetAddress;
	const platform::CPURegister* m_branchTargetReg;

	// memory access info (if any)
	uint64 m_memoryAddressOffset;
	const platform::CPURegister* m_memoryAddressBase;
	const platform::CPURegister* m_memoryAddressIndex;
	uint32 m_memoryAddressScale;
	uint32 m_memoryFlags;
	uint32 m_memorySize;

	// registers read (a fully modified register is NOT a dependency)
	const platform::CPURegister* m_registersDependencies[ MAX_REGISTERS ];
	uint32 m_registersDependenciesCount;

	// registers modified
	const platform::CPURegister* m_registersModified[ MAX_REGISTERS ];
	uint32 m_registersModifiedCount;
};"><pre><span>class</span> <span>InstructionExtendedInfo</span>
{
<span>public:</span>
	<span>static</span> <span>const</span> uint32 MAX_REGISTERS = <span>8</span>;

	<span>enum</span> EMemoryFlags
	{
		eMemoryFlags_Read		= <span>1</span> &lt;&lt; <span>0</span>, <span><span>//</span> memory is being read by the instruction</span>
		eMemoryFlags_Write		= <span>1</span> &lt;&lt; <span>1</span>, <span><span>//</span> memory is being written by the instruction</span>
		eMemoryFlags_Touch		= <span>1</span> &lt;&lt; <span>2</span>, <span><span>//</span> memory is being touched but not read/write (cache)</span>
		eMemoryFlags_Depends	= <span>1</span> &lt;&lt; <span>3</span>, <span><span>//</span> instruction depends on the memory content in some obscure way</span>
		eMemoryFlags_Aligned	= <span>1</span> &lt;&lt; <span>4</span>, <span><span>//</span> instruction expects memory address to be aligned</span>
		eMemoryFlags_Float		= <span>1</span> &lt;&lt; <span>5</span>, <span><span>//</span> memory is expected to be loading point value</span>
		eMemoryFlags_DirectMap  = <span>1</span> &lt;&lt; <span>6</span>, <span><span>//</span> memory access is directly mapped (write/read instructions)</span>
	};

	<span>enum</span> EInstructionFlags
	{
		eInstructionFlag_Nop		= <span>1</span> &lt;&lt; <span>0</span>, <span><span>//</span> instruction can be removed</span>
		eInstructionFlag_Jump		= <span>1</span> &lt;&lt; <span>1</span>, <span><span>//</span> instruction represents a simple jump</span>
		eInstructionFlag_Call		= <span>1</span> &lt;&lt; <span>2</span>, <span><span>//</span> instruction represents a function call</span>
		eInstructionFlag_Return		= <span>1</span> &lt;&lt; <span>3</span>, <span><span>//</span> instruction represents a return from function</span>
		eInstructionFlag_Diverge	= <span>1</span> &lt;&lt; <span>4</span>, <span><span>//</span> instruction can diverge a flow of code (conditional branch)</span>
		eInstructionFlag_Conditional= <span>1</span> &lt;&lt; <span>5</span>, <span><span>//</span> instruction is conditional (uses condition registers or flags)</span>
		eInstructionFlag_ModifyFlags= <span>1</span> &lt;&lt; <span>6</span>, <span><span>//</span> instruction is modifying the flag registers</span>
		eInstructionFlag_Static		= <span>1</span> &lt;&lt; <span>7</span>, <span><span>//</span> instruction branch target is static</span>
	};

	<span>enum</span> ERegDependencyMode
	{
		eReg_None = <span>0</span>,
		eReg_Dependency = <span>1</span>,
		eReg_Output = <span>2</span>,
		eReg_Both = <span>3</span>,
	};

	<span><span>//</span> instruction address and flags</span>
	uint32 m_codeAddress;
	uint32 m_codeFlags;

	<span><span>//</span> speculated branch target (if known)</span>
	uint64 m_branchTargetAddress;
	<span>const</span> platform::CPURegister* m_branchTargetReg;

	<span><span>//</span> memory access info (if any)</span>
	uint64 m_memoryAddressOffset;
	<span>const</span> platform::CPURegister* m_memoryAddressBase;
	<span>const</span> platform::CPURegister* m_memoryAddressIndex;
	uint32 m_memoryAddressScale;
	uint32 m_memoryFlags;
	uint32 m_memorySize;

	<span><span>//</span> registers read (a fully modified register is NOT a dependency)</span>
	<span>const</span> platform::CPURegister* m_registersDependencies[ MAX_REGISTERS ];
	uint32 m_registersDependenciesCount;

	<span><span>//</span> registers modified</span>
	<span>const</span> platform::CPURegister* m_registersModified[ MAX_REGISTERS ];
	uint32 m_registersModifiedCount;
};</pre></div>
<p dir="auto">By filling in this class the decompiler can express much more about the instruction - i.e. what is it going to do with the control flow of the program or what registers are being read/written by it. Each actual PowerPC instruction has its opcode class that is able to transform the Instruction into the InstructionExtendedInfo.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-blocks" aria-hidden="true" href="#blocks"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Blocks</h2>
<p dir="auto">After all instructions are disassembled it&#39;s important to identify blocks of instructions that can have known single place of entry. This is done by analyzing all the &#34;call&#34; and &#34;jump&#34; instructions that can be resolved. This is not foolproof as it does not identify properly the indirect calls (vtable, function pointers) and indirect jumps (switch statements). The more knowledge about a block we have and the more certainty about the points of entry the faster code we will be able to generate.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/rexdex/recompiler/blob/master/_images/xex_decompiled.jpg"><img src="https://github.com/rexdex/recompiler/raw/master/_images/xex_decompiled.jpg" alt="DolphinDemoScreenshot"/></a></p>
<h2 tabindex="-1" dir="auto"><a id="user-content-recompilation" aria-hidden="true" href="#recompilation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Recompilation</h2>
<p dir="auto">After all the code is disassembled we can start to decompile it into logically equivalent representation. The simple trick here is to realize that for the sake of just getting it to work we don&#39;t need to convert the code into any high-level language. What matters is to get the same execution results. The CPU state is represented as a structure:</p>
<div dir="auto" data-snippet-clipboard-copy-content="class CpuRegs : public runtime::RegisterBank
{
public:
	TReg		LR;
	TReg		CTR;
	TReg		MSR;
	XerReg		XER;

	ControlReg	CR[8];

	uint32		FPSCR;

	TReg		R0;
	TReg		R1;
	/* ... */
	TReg		R32;

	TFReg		FR0;
	TFReg		FR1;
	/* ... */
	TFReg		FR31;

	VReg		VR0;
	VReg		VR1;
	/* ... */
	VReg		VR127;

	Reservation* RES;	
};"><pre><span>class</span> <span>CpuRegs</span> : <span>public</span> <span>runtime</span>::RegisterBank
{
<span>public:</span>
	TReg		LR;
	TReg		CTR;
	TReg		MSR;
	XerReg		XER;

	ControlReg	CR[<span>8</span>];

	uint32		FPSCR;

	TReg		R0;
	TReg		R1;
	<span><span>/*</span> ... <span>*/</span></span>
	TReg		R32;

	TFReg		FR0;
	TFReg		FR1;
	<span><span>/*</span> ... <span>*/</span></span>
	TFReg		FR31;

	VReg		VR0;
	VReg		VR1;
	<span><span>/*</span> ... <span>*/</span></span>
	VReg		VR127;

	Reservation* RES;	
};</pre></div>
<p dir="auto">All the PowerPC instructions are rewritten as a heavily templatized and inlined C++ functions:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// addic - add immediate with the update of the carry flag
template &lt;uint8 CTRL&gt;
static inline void addic( CpuRegs&amp; regs, TReg* out, const TReg a, const uint32 imm )
{
	*out = a + EXTS(imm);
	regs.XER.ca = (*out &lt; a); // carry assuming there was no carry before
	if (CTRL) cmp::CmpSignedXER&lt;0&gt;(regs, *(int64*)out, 0);
}"><pre><span><span>//</span> addic - add immediate with the update of the carry flag</span>
<span>template </span>&lt;uint8 CTRL&gt;
<span>static</span> <span>inline</span> <span>void</span> <span>addic</span>( CpuRegs&amp; regs, TReg* out, <span>const</span> TReg a, <span>const</span> uint32 imm )
{
	*out = a + <span>EXTS</span>(imm);
	regs.<span>XER</span>.<span>ca</span> = (*out &lt; a); <span><span>//</span> carry assuming there was no carry before</span>
	<span>if</span> (CTRL) cmp::CmpSignedXER&lt;<span>0</span>&gt;(regs, *(int64*)out, <span>0</span>);
}</pre></div>
<p dir="auto">Finally all the blocks that were identified are transformed 1-1 into equivalent block functions. Blocks function signature is following:</p>
<div dir="auto" data-snippet-clipboard-copy-content="uint64 __fastcall _code__block82060508( uint64 ip, cpu::CpuRegs&amp; regs )"><pre>uint64 __fastcall <span>_code__block82060508</span>( uint64 ip, cpu::CpuRegs&amp; regs )</pre></div>
<p dir="auto">It takes the current IP (instruction pointer) directly as the argument + the current CPU state expressed by the &#34;regs&#34;. The returned value represents next address to execute. This is the lowest (slowest) code generation level that we have. In this mode we are putting <em><strong>ALL BURDEN</strong></em> of optimizing this to final assembly to the target compiler. Surprisingly, even using this naive approach most of the recompiled executables are running surprisingly well. Typical block looks like that:</p>
<div dir="auto" data-snippet-clipboard-copy-content="//////////////////////////////////////////////////////
// Block at 82060508h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82060508( uint64 ip, cpu::CpuRegs&amp; regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82060508) / 4;
	switch ( local_instr )
	{
		default:	cpu::invalid_address( ip, 0x82060508 );
		case 0: cpu::op::lis&lt;0&gt;(regs,&amp;regs.R11,0xFFFF8229);
		case 1: cpu::mem::load32z( regs, &amp;regs.R10, (uint32)(regs.R1 + 0x000000A0) );
		case 2: cpu::op::lis&lt;0&gt;(regs,&amp;regs.R9,0xFFFF8229);
		case 3: cpu::op::addi&lt;0&gt;(regs,&amp;regs.R3,regs.R1,0xA0);
		case 4: cpu::mem::load32z( regs, &amp;regs.R11, (uint32)(regs.R11 + 0xFFFF8BA8) );
		case 5: cpu::mem::load32z( regs, &amp;regs.R10, (uint32)(regs.R10 + 0x00000000) );
		case 6: cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0xFFFF8BA4) );
		case 7: regs.CTR = regs.R10;
		case 8: if ( 1 ) { regs.LR = 0x8206052C; return (uint32)regs.CTR; }
		case 9: cpu::op::cmpwi&lt;0&gt;(regs,regs.R3,0x00000000);
		case 10: if ( !regs.CR[0].lt ) { return 0x82060554;  }
		case 11: regs.R4 = regs.R30;
		case 12: regs.R3 = regs.R31;
		case 13: cpu::op::li&lt;0&gt;(regs,&amp;regs.R5,0x50);
		case 14: regs.LR = 0x82060544; return 0x820859E0;
		case 15: cpu::op::lis&lt;0&gt;(regs,&amp;regs.R11,0xFFFF8205);
		case 16: cpu::op::addi&lt;0&gt;(regs,&amp;regs.R3,regs.R11,0xFFFFA98C);
		case 17: regs.LR = 0x82060550; return 0x820859E0;
		case 18: regs.LR = 0x82060554; return 0x82267AF8;
	}
	return 0x82060554;
}"><pre><span><span>//</span>////////////////////////////////////////////////////</span>
<span><span>//</span> Block at 82060508h</span>
<span><span>//</span>////////////////////////////////////////////////////</span>
uint64 __fastcall <span>_code__block82060508</span>( uint64 ip, cpu::CpuRegs&amp; regs )
{
	<span>const</span> uint32 local_instr = (uint32)(ip - <span>0x82060508</span>) / <span>4</span>;
	<span>switch</span> ( local_instr )
	{
		<span>default</span>:	<span>cpu::invalid_address</span>( ip, <span>0x82060508</span> );
		<span>case</span> <span>0</span>: cpu::op::lis&lt;<span>0</span>&gt;(regs,&amp;regs.<span>R11</span>,<span>0xFFFF8229</span>);
		<span>case</span> <span>1</span>: <span>cpu::mem::load32z</span>( regs, &amp;regs.<span>R10</span>, (uint32)(regs.<span>R1</span> + <span>0x000000A0</span>) );
		<span>case</span> <span>2</span>: cpu::op::lis&lt;<span>0</span>&gt;(regs,&amp;regs.<span>R9</span>,<span>0xFFFF8229</span>);
		<span>case</span> <span>3</span>: cpu::op::addi&lt;<span>0</span>&gt;(regs,&amp;regs.<span>R3</span>,regs.<span>R1</span>,<span>0xA0</span>);
		<span>case</span> <span>4</span>: <span>cpu::mem::load32z</span>( regs, &amp;regs.<span>R11</span>, (uint32)(regs.<span>R11</span> + <span>0xFFFF8BA8</span>) );
		<span>case</span> <span>5</span>: <span>cpu::mem::load32z</span>( regs, &amp;regs.<span>R10</span>, (uint32)(regs.<span>R10</span> + <span>0x00000000</span>) );
		<span>case</span> <span>6</span>: <span>cpu::mem::store32</span>( regs, regs.<span>R11</span>, (uint32)(regs.<span>R9</span> + <span>0xFFFF8BA4</span>) );
		<span>case</span> <span>7</span>: regs.<span>CTR</span> = regs.<span>R10</span>;
		<span>case</span> <span>8</span>: <span>if</span> ( <span>1</span> ) { regs.<span>LR</span> = <span>0x8206052C</span>; <span>return</span> (uint32)regs.<span>CTR</span>; }
		<span>case</span> <span>9</span>: cpu::op::cmpwi&lt;<span>0</span>&gt;(regs,regs.<span>R3</span>,<span>0x00000000</span>);
		<span>case</span> <span>10</span>: <span>if</span> ( !regs.<span>CR</span>[<span>0</span>].<span>lt</span> ) { <span>return</span> <span>0x82060554</span>;  }
		<span>case</span> <span>11</span>: regs.<span>R4</span> = regs.<span>R30</span>;
		<span>case</span> <span>12</span>: regs.<span>R3</span> = regs.<span>R31</span>;
		<span>case</span> <span>13</span>: cpu::op::li&lt;<span>0</span>&gt;(regs,&amp;regs.<span>R5</span>,<span>0x50</span>);
		<span>case</span> <span>14</span>: regs.<span>LR</span> = <span>0x82060544</span>; <span>return</span> <span>0x820859E0</span>;
		<span>case</span> <span>15</span>: cpu::op::lis&lt;<span>0</span>&gt;(regs,&amp;regs.<span>R11</span>,<span>0xFFFF8205</span>);
		<span>case</span> <span>16</span>: cpu::op::addi&lt;<span>0</span>&gt;(regs,&amp;regs.<span>R3</span>,regs.<span>R11</span>,<span>0xFFFFA98C</span>);
		<span>case</span> <span>17</span>: regs.<span>LR</span> = <span>0x82060550</span>; <span>return</span> <span>0x820859E0</span>;
		<span>case</span> <span>18</span>: regs.<span>LR</span> = <span>0x82060554</span>; <span>return</span> <span>0x82267AF8</span>;
	}
	<span>return</span> <span>0x82060554</span>;
}</pre></div>
<p dir="auto">In case the block is confirmed to be single point of entry we can use following simplified form:</p>
<div dir="auto" data-snippet-clipboard-copy-content="//////////////////////////////////////////////////////
// Block at 82060508h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82060508( uint64 ip, cpu::CpuRegs&amp; regs )
{
	ASSERT(ip == 0x82060508);
	cpu::op::lis&lt;0&gt;(regs,&amp;regs.R11,0xFFFF8229);
	cpu::mem::load32z( regs, &amp;regs.R10, (uint32)(regs.R1 + 0x000000A0) );
	cpu::op::lis&lt;0&gt;(regs,&amp;regs.R9,0xFFFF8229);
	cpu::op::addi&lt;0&gt;(regs,&amp;regs.R3,regs.R1,0xA0);
	cpu::mem::load32z( regs, &amp;regs.R11, (uint32)(regs.R11 + 0xFFFF8BA8) );
	cpu::mem::load32z( regs, &amp;regs.R10, (uint32)(regs.R10 + 0x00000000) );
	cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0xFFFF8BA4) );
	regs.CTR = regs.R10;
	if ( 1 ) { regs.LR = 0x8206052C; return (uint32)regs.CTR; }
	cpu::op::cmpwi&lt;0&gt;(regs,regs.R3,0x00000000);
	if ( !regs.CR[0].lt ) { return 0x82060554;  }
	regs.R4 = regs.R30;
	regs.R3 = regs.R31;
	cpu::op::li&lt;0&gt;(regs,&amp;regs.R5,0x50);
	regs.LR = 0x82060544; return 0x820859E0;
	cpu::op::lis&lt;0&gt;(regs,&amp;regs.R11,0xFFFF8205);
	cpu::op::addi&lt;0&gt;(regs,&amp;regs.R3,regs.R11,0xFFFFA98C);
	regs.LR = 0x82060550; return 0x820859E0;
	regs.LR = 0x82060554; return 0x82267AF8;
	return 0x82060554;
}"><pre><span><span>//</span>////////////////////////////////////////////////////</span>
<span><span>//</span> Block at 82060508h</span>
<span><span>//</span>////////////////////////////////////////////////////</span>
uint64 __fastcall <span>_code__block82060508</span>( uint64 ip, cpu::CpuRegs&amp; regs )
{
	<span>ASSERT</span>(ip == <span>0x82060508</span>);
	cpu::op::lis&lt;<span>0</span>&gt;(regs,&amp;regs.<span>R11</span>,<span>0xFFFF8229</span>);
	<span>cpu::mem::load32z</span>( regs, &amp;regs.<span>R10</span>, (uint32)(regs.<span>R1</span> + <span>0x000000A0</span>) );
	cpu::op::lis&lt;<span>0</span>&gt;(regs,&amp;regs.<span>R9</span>,<span>0xFFFF8229</span>);
	cpu::op::addi&lt;<span>0</span>&gt;(regs,&amp;regs.<span>R3</span>,regs.<span>R1</span>,<span>0xA0</span>);
	<span>cpu::mem::load32z</span>( regs, &amp;regs.<span>R11</span>, (uint32)(regs.<span>R11</span> + <span>0xFFFF8BA8</span>) );
	<span>cpu::mem::load32z</span>( regs, &amp;regs.<span>R10</span>, (uint32)(regs.<span>R10</span> + <span>0x00000000</span>) );
	<span>cpu::mem::store32</span>( regs, regs.<span>R11</span>, (uint32)(regs.<span>R9</span> + <span>0xFFFF8BA4</span>) );
	regs.<span>CTR</span> = regs.<span>R10</span>;
	<span>if</span> ( <span>1</span> ) { regs.<span>LR</span> = <span>0x8206052C</span>; <span>return</span> (uint32)regs.<span>CTR</span>; }
	cpu::op::cmpwi&lt;<span>0</span>&gt;(regs,regs.<span>R3</span>,<span>0x00000000</span>);
	<span>if</span> ( !regs.<span>CR</span>[<span>0</span>].<span>lt</span> ) { <span>return</span> <span>0x82060554</span>;  }
	regs.<span>R4</span> = regs.<span>R30</span>;
	regs.<span>R3</span> = regs.<span>R31</span>;
	cpu::op::li&lt;<span>0</span>&gt;(regs,&amp;regs.<span>R5</span>,<span>0x50</span>);
	regs.<span>LR</span> = <span>0x82060544</span>; <span>return</span> <span>0x820859E0</span>;
	cpu::op::lis&lt;<span>0</span>&gt;(regs,&amp;regs.<span>R11</span>,<span>0xFFFF8205</span>);
	cpu::op::addi&lt;<span>0</span>&gt;(regs,&amp;regs.<span>R3</span>,regs.<span>R11</span>,<span>0xFFFFA98C</span>);
	regs.<span>LR</span> = <span>0x82060550</span>; <span>return</span> <span>0x820859E0</span>;
	regs.<span>LR</span> = <span>0x82060554</span>; <span>return</span> <span>0x82267AF8</span>;
	<span>return</span> <span>0x82060554</span>;
}</pre></div>
<p dir="auto">There are more optimization steps possible that I&#39;m currently working on - for example if all blocks in a function are &#34;well behaved&#34; - no indirect jumps are found and the function follows ABI rules - clear preamble can be identified + all return statements have proper cleanup code, then we can promote the whole function to a single C++ function pulling all blocks inside + defining all VOLATILE registers inside the function (on stack) and not using the ones in the <em>regs</em> structure.</p>
<p dir="auto">Next optimization step can occur when two &#34;well behaved&#34; functions are calling each other. Then, instead of going through the generic call via the returned &#34;next instruction address&#34; we can generate code like this:</p>
<div dir="auto" data-snippet-clipboard-copy-content="uint64 __fastcall _code__func82060508( uint64 ip, cpu::CpuRegs&amp; regs )
{
	ASSERT(ip == 0x82060508);
	
	/*...*/
	
	// the CALL_DIRECT checks if the returned address is what we expected 
	CALL_DIRECT(0x82060608, _code__func82010004(0x82010004, regs)); 

	/*...*/
	
	return 0x82060554;
}"><pre>uint64 __fastcall <span>_code__func82060508</span>( uint64 ip, cpu::CpuRegs&amp; regs )
{
	<span>ASSERT</span>(ip == <span>0x82060508</span>);
	
	<span><span>/*</span>...<span>*/</span></span>
	
	<span><span>//</span> the CALL_DIRECT checks if the returned address is what we expected </span>
	<span>CALL_DIRECT</span>(<span>0x82060608</span>, <span>_code__func82010004</span>(<span>0x82010004</span>, regs)); 

	<span><span>/*</span>...<span>*/</span></span>
	
	<span>return</span> <span>0x82060554</span>;
}</pre></div>
<p dir="auto">This again makes the generated code faster.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-the-thread-and-the-thread-execution" aria-hidden="true" href="#the-thread-and-the-thread-execution"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>The thread and the thread execution.</h2>
<p dir="auto">All the generated blocks are then compiled using standard C++ compiler and produce a DLL. Pointers to all block functions are then registered into a &#34;block table&#34;. Block table allows easily to retrieve the block that will contain the code for given IP (Instruction Pointer). Finally, the core of the simulated CPU thread boils down to this function:</p>
<div dir="auto" data-snippet-clipboard-copy-content="void CodeExecutor::Run()
{
	while (m_ip)
	{
		const auto relAddress = m_ip - m_startAddress;
		const auto func = m_blockTable[relAddress];
		m_ip = func(m_ip, *m_regs);
	}
}"><pre><span>void</span> <span>CodeExecutor::Run</span>()
{
	<span>while</span> (m_ip)
	{
		<span>const</span> <span>auto</span> relAddress = m_ip - m_startAddress;
		<span>const</span> <span>auto</span> func = m_blockTable[relAddress];
		m_ip = <span>func</span>(m_ip, *m_regs);
	}
}</pre></div>
<h2 tabindex="-1" dir="auto"><a id="user-content-imported-functions" aria-hidden="true" href="#imported-functions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Imported functions</h2>
<p dir="auto">The XEX image contains import of functions from another modules. Unlink the quite common &#34;named&#34; imports, the ones in the XEX executable are only ordinal based. A table is required that contains the &#34;human readable&#34; names of the functions as well as their ordering in the given lib. See <a href="https://github.com/rexdex/recompiler/blob/master/dev/src/platforms/xenon/xenonDecompiler/Recompiler.Xenon.Platform.exports">here</a>.</p>
<p dir="auto">When we load an image for decompiled executable we can patch the entries in the block table for given import stubs with a C++ reimplementation of that function. There is still the same and we have to &#34;unpack&#34; the arguments from the registers manually. For example:</p>
<div dir="auto" data-snippet-clipboard-copy-content="uint64 __fastcall XboxThreads_KeDelayExecutionThread( uint64 ip, cpu::CpuRegs&amp; regs )
{
	const uint32 processor_mode = (const uint32)regs.R3;
	const uint32 alertable = (const uint32)regs.R4;
	const uint32 internalPtr = (const uint32)regs.R5;
	const uint64 interval = mem::loadAddr&lt;uint64&gt;( internalPtr );

	auto* currentThread = xenon::KernelThread::GetCurrentThread();
	const uint32 result = currentThread-&gt;Delay(processor_mode, alertable, interval);

	RETURN_ARG(result);
}"><pre>uint64 __fastcall <span>XboxThreads_KeDelayExecutionThread</span>( uint64 ip, cpu::CpuRegs&amp; regs )
{
	<span>const</span> uint32 processor_mode = (<span>const</span> uint32)regs.<span>R3</span>;
	<span>const</span> uint32 alertable = (<span>const</span> uint32)regs.<span>R4</span>;
	<span>const</span> uint32 internalPtr = (<span>const</span> uint32)regs.<span>R5</span>;
	<span>const</span> uint64 interval = mem::loadAddr&lt;uint64&gt;( internalPtr );

	<span>auto</span>* currentThread = <span>xenon::KernelThread::GetCurrentThread</span>();
	<span>const</span> uint32 result = currentThread-&gt;<span>Delay</span>(processor_mode, alertable, interval);

	<span>RETURN_ARG</span>(result);
}</pre></div>
<p dir="auto">It takes around 300 functions to get the simple app to start. Most of the are very similar (if not exactly the same) as the Windows counterparts. The rest is mostly guess work.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-future-work" aria-hidden="true" href="#future-work"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Future Work</h2>
<p dir="auto">Well, it would be much cooler to run an actual game, maybe someday :)</p>
</article>
          </div></div>
  </body>
</html>
