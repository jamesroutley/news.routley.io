<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://eli.thegreenplace.net/2023/higher-order-functions-in-go/">Original</a>
    <h1>Higher-order functions in Go</h1>
    
    <div id="readability-page-1" class="page"><div>
                
                <p><a href="https://eli.thegreenplace.net/2023/building-abstractions-using-higher-order-functions/">A few weeks ago I wrote</a>
about the powerful abstractions that higher-order functions enable, using
Clojure code as an example.</p>
<p>In this post I want to show equivalent code using a modern statically-typed
language - Go. Please make sure to review the previous post first, since it
describes the problem statement in detail.</p>
<div id="go-and-higher-order-functions">
<h2>Go and higher-order functions</h2>
<p>While Go has many of the building blocks required to support functional
programming, at this time it&#39;s not considered a mainstream programming paradigm
for the language.</p>
<p>That said, my favorite part of functional programming is definitely supported
and widely used in Go - higher-order functions. Go makes it simple to pass
functions as arguments to other functions, and return functions from functions.
Moreover, it has first-class support for <em>closures</em>, which makes the
function-based design process much more powerful. This also meshes well with
Go&#39;s automatic memory management, mostly eliminating worries about values going
in and out of scope in closures.</p>
</div>
<div id="the-tree-search-example-in-go">
<h2>The tree search example in Go</h2>
<p>Let&#39;s reproduce the tree search example from <a href="https://eli.thegreenplace.net/2023/building-abstractions-using-higher-order-functions/">the previous post</a>
in Go; <a href="https://github.com/eliben/code-for-blog/tree/master/2023/go-higher-order-functions">the full code is here</a>.
The first task we run into is <em>types</em>; since Go is statically typed, we have to
define our types explicitly:</p>
<div><pre><span></span><span>type</span><span> </span><span>State</span><span> </span><span>int</span><span></span>
<span>type</span><span> </span><span>States</span><span> </span><span>[]</span><span>State</span><span></span>

<span>// GoalP takes a state and determines whether it&#39;s a goal state.</span><span></span>
<span>type</span><span> </span><span>GoalP</span><span> </span><span>func</span><span>(</span><span>s</span><span> </span><span>State</span><span>)</span><span> </span><span>bool</span><span></span>

<span>// Successors returns the successors of a state.</span><span></span>
<span>type</span><span> </span><span>Successors</span><span> </span><span>func</span><span>(</span><span>s</span><span> </span><span>State</span><span>)</span><span> </span><span>States</span><span></span>

<span>// Combiner determines the search strategy by combining successors of the</span><span></span>
<span>// current state with all the other states into a single list of states.</span><span></span>
<span>type</span><span> </span><span>Combiner</span><span> </span><span>func</span><span>(</span><span>succ</span><span> </span><span>States</span><span>,</span><span> </span><span>others</span><span> </span><span>States</span><span>)</span><span> </span><span>States</span><span></span>
</pre></div>
<p>And this is the tree search function:</p>
<div><pre><span></span><span>// treeSearch returns the state if it&#39;s found in the tree; returns -1 if such a</span><span></span>
<span>// state wasn&#39;t found.</span><span></span>
<span>func</span><span> </span><span>treeSearch</span><span>(</span><span>states</span><span> </span><span>States</span><span>,</span><span> </span><span>goalp</span><span> </span><span>GoalP</span><span>,</span><span> </span><span>succ</span><span> </span><span>Successors</span><span>,</span><span> </span><span>combiner</span><span> </span><span>Combiner</span><span>)</span><span> </span><span>State</span><span> </span><span>{</span><span></span>
<span>  </span><span>if</span><span> </span><span>len</span><span>(</span><span>states</span><span>)</span><span> </span><span>==</span><span> </span><span>0</span><span> </span><span>{</span><span></span>
<span>    </span><span>return</span><span> </span><span>-</span><span>1</span><span></span>
<span>  </span><span>}</span><span></span>

<span>  </span><span>first</span><span> </span><span>:=</span><span> </span><span>states</span><span>[</span><span>0</span><span>]</span><span></span>
<span>  </span><span>if</span><span> </span><span>goalp</span><span>(</span><span>first</span><span>)</span><span> </span><span>{</span><span></span>
<span>    </span><span>return</span><span> </span><span>first</span><span></span>
<span>  </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span></span>
<span>    </span><span>return</span><span> </span><span>treeSearch</span><span>(</span><span>combiner</span><span>(</span><span>succ</span><span>(</span><span>first</span><span>),</span><span> </span><span>states</span><span>[</span><span>1</span><span>:]),</span><span> </span><span>goalp</span><span>,</span><span> </span><span>succ</span><span>,</span><span> </span><span>combiner</span><span>)</span><span></span>
<span>  </span><span>}</span><span></span>
<span>}</span><span></span>
</pre></div>
<p>While it&#39;s somewhat more verbose, its logic follows the Clojure code very
closely. Now we&#39;re ready to define BFS search:</p>
<div><pre><span></span><span>// prependOthers is a Combiner function that prepends others to succ.</span><span></span>
<span>func</span><span> </span><span>prependOthers</span><span>(</span><span>succ</span><span> </span><span>States</span><span>,</span><span> </span><span>others</span><span> </span><span>States</span><span>)</span><span> </span><span>States</span><span> </span><span>{</span><span></span>
<span>  </span><span>return</span><span> </span><span>append</span><span>(</span><span>others</span><span>,</span><span> </span><span>succ</span><span>...</span><span>)</span><span></span>
<span>}</span><span></span>

<span>func</span><span> </span><span>bfsTreeSearch</span><span>(</span><span>start</span><span> </span><span>State</span><span>,</span><span> </span><span>goalp</span><span> </span><span>GoalP</span><span>,</span><span> </span><span>succ</span><span> </span><span>Successors</span><span>)</span><span> </span><span>State</span><span> </span><span>{</span><span></span>
<span>  </span><span>return</span><span> </span><span>treeSearch</span><span>(</span><span>States</span><span>{</span><span>start</span><span>},</span><span> </span><span>goalp</span><span>,</span><span> </span><span>succ</span><span>,</span><span> </span><span>prependOthers</span><span>)</span><span></span>
<span>}</span><span></span>
</pre></div>
<p>To see how this function is invoked, we&#39;ll define a general infinite binary
tree <tt>Successors</tt> function, and another for finite binary trees:</p>
<div><pre><span></span><span>func</span><span> </span><span>binaryTree</span><span>(</span><span>s</span><span> </span><span>State</span><span>)</span><span> </span><span>States</span><span> </span><span>{</span><span></span>
<span>  </span><span>return</span><span> </span><span>[]</span><span>State</span><span>{</span><span>s</span><span> </span><span>*</span><span> </span><span>2</span><span>,</span><span> </span><span>s</span><span>*</span><span>2</span><span> </span><span>+</span><span> </span><span>1</span><span>}</span><span></span>
<span>}</span><span></span>

<span>func</span><span> </span><span>finiteBinaryTree</span><span>(</span><span>n</span><span> </span><span>State</span><span>)</span><span> </span><span>Successors</span><span> </span><span>{</span><span></span>
<span>  </span><span>return</span><span> </span><span>func</span><span>(</span><span>s</span><span> </span><span>State</span><span>)</span><span> </span><span>States</span><span> </span><span>{</span><span></span>
<span>    </span><span>return</span><span> </span><span>filter</span><span>(</span><span>binaryTree</span><span>(</span><span>s</span><span>),</span><span> </span><span>func</span><span>(</span><span>item</span><span> </span><span>State</span><span>)</span><span> </span><span>bool</span><span> </span><span>{</span><span> </span><span>return</span><span> </span><span>item</span><span> </span><span>&lt;=</span><span> </span><span>n</span><span> </span><span>})</span><span></span>
<span>  </span><span>}</span><span></span>
<span>}</span><span></span>
</pre></div>
<p><tt>finiteBinaryTree</tt> is a nice example of higher-order functions in Go. It
takes a value and returns a function that adheres to the <tt>Successors</tt>
function type; in fact, it returns a new function created at runtime - a
<em>closure</em> that closes over the value <tt>n</tt>. Moreover, the function it returns
also makes use of higher-order functions in its body, because it invokes
<tt>filter</tt> with a filtering function as a parameter. <tt>filter</tt> is:</p>
<div><pre><span></span><span>// filter filters a slice based on a predicate, returning a new slice whose</span><span></span>
<span>// elements fulfill the predicate.</span><span></span>
<span>func</span><span> </span><span>filter</span><span>[</span><span>T</span><span> </span><span>any</span><span>](</span><span>s</span><span> </span><span>[]</span><span>T</span><span>,</span><span> </span><span>pred</span><span> </span><span>func</span><span>(</span><span>item</span><span> </span><span>T</span><span>)</span><span> </span><span>bool</span><span>)</span><span> </span><span>[]</span><span>T</span><span> </span><span>{</span><span></span>
<span>  </span><span>var</span><span> </span><span>result</span><span> </span><span>[]</span><span>T</span><span></span>
<span>  </span><span>for</span><span> </span><span>_</span><span>,</span><span> </span><span>item</span><span> </span><span>:=</span><span> </span><span>range</span><span> </span><span>s</span><span> </span><span>{</span><span></span>
<span>    </span><span>if</span><span> </span><span>pred</span><span>(</span><span>item</span><span>)</span><span> </span><span>{</span><span></span>
<span>      </span><span>result</span><span> </span><span>=</span><span> </span><span>append</span><span>(</span><span>result</span><span>,</span><span> </span><span>item</span><span>)</span><span></span>
<span>    </span><span>}</span><span></span>
<span>  </span><span>}</span><span></span>
<span>  </span><span>return</span><span> </span><span>result</span><span></span>
<span>}</span><span></span>
</pre></div>
<p>To call <tt>bfsTreeSearch</tt> we need to figure out another function parameter - the
goal function (<tt>GoalP</tt>). We can use a higher-order function for this as well:</p>
<div><pre><span></span><span>// stateIs returns a GoalP that checks a state for equality with n.</span><span></span>
<span>func</span><span> </span><span>stateIs</span><span>(</span><span>n</span><span> </span><span>State</span><span>)</span><span> </span><span>GoalP</span><span> </span><span>{</span><span></span>
<span>  </span><span>return</span><span> </span><span>func</span><span>(</span><span>s</span><span> </span><span>State</span><span>)</span><span> </span><span>bool</span><span> </span><span>{</span><span> </span><span>return</span><span> </span><span>n</span><span> </span><span>==</span><span> </span><span>s</span><span> </span><span>}</span><span></span>
<span>}</span><span></span>
</pre></div>
<p>Now we&#39;re ready to invoke <tt>bfsTreeSearch</tt>:</p>
<div><pre><span></span><span>treeLimit</span><span> </span><span>:=</span><span> </span><span>30</span><span></span>
<span>tree</span><span> </span><span>:=</span><span> </span><span>finiteBinaryTree</span><span>(</span><span>State</span><span>(</span><span>treeLimit</span><span>))</span><span></span>

<span>bfsFound</span><span> </span><span>:=</span><span> </span><span>bfsTreeSearch</span><span>(</span><span>1</span><span>,</span><span> </span><span>stateIs</span><span>(</span><span>17</span><span>),</span><span> </span><span>tree</span><span>)</span><span></span>
</pre></div>
<p>Note how similar this code is to the Clojure variant; Go supports all the same
higher-order function constructs, letting us build powerful abstractions using
them. The static types make the code somewhat more verbose, but this has
advantages as well!</p>
<p>Imagine that you don&#39;t remember in which order <tt>successors</tt> and <tt>combiner</tt>
should be passed to <tt><span>tree-search</span></tt> in the Clojure code; if you pass them in
the wrong order, the code will build fine and you will get an error at runtime
about invoking some function with the wrong number of arguments. This is lucky,
because these two functions just happen to have different arities; in less lucky
cases the error could come much later or be more obscure; or, there could be
no error at all and the result could be incorrect.</p>
<p>In Go if you pass <tt>succ</tt> after <tt>combiner</tt>, you&#39;ll just get a compile-time
type error.</p>
<p>Types have a benefit for documentation and code-reading purposes as well, but
I don&#39;t want to turn this post into a static vs. dynamic typing debate. Let&#39;s
look at some of the more advanced tree searching functions instead.</p>
</div>
<div id="even-more-higher-order-functions-in-best-first-search">
<h2>Even more higher-order functions in best-first search</h2>
<p>A slightly more advanced example involves a &#34;best&#34;-first search; a greedy
heuristic that sorts all state candidates by some criteria and pursues them in a
priority order. We can still reuse our <tt>treeSearch</tt> function for it, but have
to devise an appropriate <tt>Combiner</tt>. Let&#39;s start with a new function type:</p>
<div><pre><span></span><span>type</span><span> </span><span>CostFunc</span><span> </span><span>func</span><span>(</span><span>s</span><span> </span><span>State</span><span>)</span><span> </span><span>int</span><span></span>
</pre></div>
<p>Given a state <tt>s</tt>, a cost function returns the integer cost. Now we can write
our combiner that sorts a list of states based on a cost function:</p>
<div><pre><span></span><span>func</span><span> </span><span>sorter</span><span>(</span><span>cost</span><span> </span><span>CostFunc</span><span>)</span><span> </span><span>Combiner</span><span> </span><span>{</span><span></span>
<span>  </span><span>return</span><span> </span><span>func</span><span>(</span><span>succ</span><span> </span><span>States</span><span>,</span><span> </span><span>others</span><span> </span><span>States</span><span>)</span><span> </span><span>States</span><span> </span><span>{</span><span></span>
<span>    </span><span>all</span><span> </span><span>:=</span><span> </span><span>append</span><span>(</span><span>succ</span><span>,</span><span> </span><span>others</span><span>...</span><span>)</span><span></span>
<span>    </span><span>sort</span><span>.</span><span>Slice</span><span>(</span><span>all</span><span>,</span><span> </span><span>func</span><span>(</span><span>i</span><span>,</span><span> </span><span>j</span><span> </span><span>int</span><span>)</span><span> </span><span>bool</span><span> </span><span>{</span><span></span>
<span>      </span><span>return</span><span> </span><span>cost</span><span>(</span><span>all</span><span>[</span><span>i</span><span>])</span><span> </span><span>&lt;</span><span> </span><span>cost</span><span>(</span><span>all</span><span>[</span><span>j</span><span>])</span><span></span>
<span>    </span><span>})</span><span></span>
<span>    </span><span>return</span><span> </span><span>all</span><span></span>
<span>  </span><span>}</span><span></span>
<span>}</span><span></span>
</pre></div>
<p>Another nice example of higher-order functions in action. <tt>sorter</tt> can be seen
as a <em>generator</em> of <tt>Combiner</tt> functions; it can generate a new <tt>Combiner</tt>
given a cost function. At this point we have all we need to implement
<tt>bestCostTreeSearch</tt>:</p>
<div><pre><span></span><span>func</span><span> </span><span>bestCostTreeSearch</span><span>(</span><span>start</span><span> </span><span>State</span><span>,</span><span> </span><span>goalp</span><span> </span><span>GoalP</span><span>,</span><span> </span><span>succ</span><span> </span><span>Successors</span><span>,</span><span> </span><span>cost</span><span> </span><span>CostFunc</span><span>)</span><span> </span><span>State</span><span> </span><span>{</span><span></span>
<span>  </span><span>return</span><span> </span><span>treeSearch</span><span>(</span><span>States</span><span>{</span><span>start</span><span>},</span><span> </span><span>goalp</span><span>,</span><span> </span><span>succ</span><span>,</span><span> </span><span>sorter</span><span>(</span><span>cost</span><span>))</span><span></span>
<span>}</span><span></span>
</pre></div>
<p>The only thing remaining is figuring out what cost function we&#39;d like to pass
to the search. A simple one just measures the linear distance of a given state
from our goal state:</p>
<div><pre><span></span><span>// costDiffTarget creates a cost function that uses numerical distance from `n`</span><span></span>
<span>// as the cost.</span><span></span>
<span>func</span><span> </span><span>costDiffTarget</span><span>(</span><span>n</span><span> </span><span>State</span><span>)</span><span> </span><span>CostFunc</span><span> </span><span>{</span><span></span>
<span>  </span><span>return</span><span> </span><span>func</span><span>(</span><span>s</span><span> </span><span>State</span><span>)</span><span> </span><span>int</span><span> </span><span>{</span><span></span>
<span>    </span><span>delta</span><span> </span><span>:=</span><span> </span><span>int</span><span>(</span><span>s</span><span>)</span><span> </span><span>-</span><span> </span><span>int</span><span>(</span><span>n</span><span>)</span><span></span>
<span>    </span><span>if</span><span> </span><span>delta</span><span> </span><span>&lt;</span><span> </span><span>0</span><span> </span><span>{</span><span></span>
<span>      </span><span>return</span><span> </span><span>-</span><span>delta</span><span></span>
<span>    </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span></span>
<span>      </span><span>return</span><span> </span><span>delta</span><span></span>
<span>    </span><span>}</span><span></span>
<span>  </span><span>}</span><span></span>
<span>}</span><span></span>
</pre></div>
<p>Given a target state, <tt>costDiffTarget</tt> generates a function that can serve
as the cost function for search. We can now invoke <tt>bestCostTreeSearch</tt>:</p>
<div><pre><span></span><span>treeLimit</span><span> </span><span>:=</span><span> </span><span>30</span><span></span>
<span>tree</span><span> </span><span>:=</span><span> </span><span>finiteBinaryTree</span><span>(</span><span>State</span><span>(</span><span>treeLimit</span><span>))</span><span></span>

<span>bestFound</span><span> </span><span>:=</span><span> </span><span>bestCostTreeSearch</span><span>(</span><span>1</span><span>,</span><span> </span><span>stateIs</span><span>(</span><span>17</span><span>),</span><span> </span><span>tree</span><span>,</span><span> </span><span>costDiffTarget</span><span>(</span><span>17</span><span>))</span><span></span>
</pre></div>
</div>
<div id="conclusion">
<h2>Conclusion</h2>
<p>Go has complete and powerful support for higher-order functions - including
proper closures. While the syntax - mostly due to static typing - is somewhat
more verbose than in other languages, it&#39;s more of an issue for code samples
than it is for large code bases.</p>
<p>The verbosity issue is also in discussion by the Go developers, with proposals
like <a href="https://github.com/golang/go/issues/21498">Lightweight anonymous function syntax</a> promising terser syntax and more
powerful type inference. So there&#39;s hope for further improvement in this area.</p>
<p>Go itself uses higher-order functions extensively in the standard library;
some examples include <a href="https://pkg.go.dev/bufio#Scanner.Split">bufio.Scanner.Split</a>,
a whole array of <tt>*Func</tt> functions in the <tt>strings</tt> package (e.g. <a href="https://pkg.go.dev/strings#FieldsFunc">FieldsFunc</a>),
the <a href="https://pkg.go.dev/sort#Slice">sort.Slice</a> function used in this post
and of course <a href="https://pkg.go.dev/net/http#ServeMux.HandleFunc">net/http.ServeMux.HandleFunc</a>.</p>
<p>Examples of returning functions also abound; the best known is probably the
convention of the <tt>context</tt> package to return <tt>context.CancelFunc</tt> for
context cancellation. But there are other examples, like <a href="https://pkg.go.dev/net/http#ProxyURL">net/http.ProxyUrl</a>.</p>
<p>P.S. If you want to see a more mind-bending example of Go&#39;s higher-order
functions, check out <a href="https://eli.thegreenplace.net/2022/the-y-combinator-in-go-with-generics/">The Y combinator in Go with generics</a>.</p>
</div>

            </div></div>
  </body>
</html>
