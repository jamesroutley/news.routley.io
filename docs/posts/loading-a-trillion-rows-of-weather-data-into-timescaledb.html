<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://aliramadhan.me/2024/03/31/trillion-rows.html">Original</a>
    <h1>Loading a trillion rows of weather data into TimescaleDB</h1>
    
    <div id="readability-page-1" class="page"><p><i>Building a weather data warehouse part I: Loading a trillion rows of weather data into TimescaleDB</i>
            </p><div>
              <ol id="markdown-toc">
  <li><a href="#what-are-we-even-doing" id="markdown-toc-what-are-we-even-doing">What are we even doing?</a>    <ol>
      <li><a href="#why-build-a-weather-data-warehouse" id="markdown-toc-why-build-a-weather-data-warehouse">Why build a weather data warehouse?</a></li>
      <li><a href="#whats-the-data" id="markdown-toc-whats-the-data">What‚Äôs the data?</a></li>
    </ol>
  </li>
  <li><a href="#the-insert-statement" id="markdown-toc-the-insert-statement">The <code>insert</code> statement</a>    <ol>
      <li><a href="#starting-with-just-the-single-row-insert-statement" id="markdown-toc-starting-with-just-the-single-row-insert-statement">Starting with just the single-row <code>insert</code> statement</a></li>
      <li><a href="#multi-valued-insert" id="markdown-toc-multi-valued-insert">Multi-valued <code>insert</code></a></li>
    </ol>
  </li>
  <li><a href="#the-copy-statement" id="markdown-toc-the-copy-statement">The <code>copy</code> statement</a>    <ol>
      <li><a href="#upgrading-to-the-copy-statement" id="markdown-toc-upgrading-to-the-copy-statement">Upgrading to the <code>copy</code> statement</a></li>
      <li><a href="#sustaining-copy-insert-rates" id="markdown-toc-sustaining-copy-insert-rates">Sustaining <code>copy</code> insert rates</a></li>
      <li><a href="#parallel-copy" id="markdown-toc-parallel-copy">Parallel <code>copy</code></a></li>
    </ol>
  </li>
  <li><a href="#tools" id="markdown-toc-tools">Tools</a>    <ol>
      <li><a href="#pg_bulkload-and-timescaledb-parallel-copy" id="markdown-toc-pg_bulkload-and-timescaledb-parallel-copy">pg_bulkload and timescaledb-parallel-copy</a></li>
      <li><a href="#multiple-workers-with-timescaledb-parallel-copy" id="markdown-toc-multiple-workers-with-timescaledb-parallel-copy">Multiple workers with timescaledb-parallel-copy</a></li>
    </ol>
  </li>
  <li><a href="#tweaking-postgres-settings" id="markdown-toc-tweaking-postgres-settings">Tweaking Postgres settings</a></li>
  <li><a href="#so-whats-the-best-method" id="markdown-toc-so-whats-the-best-method">So what‚Äôs the best method?</a></li>
  <li><a href="#appendices" id="markdown-toc-appendices">Appendices</a>    <ol>
      <li><a href="#source-code" id="markdown-toc-source-code">Source code</a></li>
      <li><a href="#benchmarking-methodology" id="markdown-toc-benchmarking-methodology">Benchmarking methodology</a></li>
    </ol>
  </li>
  <li><a href="#footnotes" id="markdown-toc-footnotes">Footnotes</a></li>
</ol>

<figure>

  <p><img src="https://aliramadhan.me/img/trillion_rows/temperature_figure.png" alt="global surface temperature snapshot"/></p>

  <figcaption>Global snapshot of surface temperature at 2018-12-04 04:00:00 UTC.</figcaption>

</figure>



<h2 id="why-build-a-weather-data-warehouse">Why build a weather data warehouse?</h2>

<p>I think it would be cool to have historical weather data from around the world to analyze for signals of climate change we‚Äôve <em>already</em> had rather than think about potential future change.</p>

<p>If we had a huge weather data warehouse we could query it to figure out whether Jakarta is actually warmer or stormier these days and exactly how is it warmer (heat waves, winter highs, etc.). Or whether Chile is warming or getting cloudier as a whole, which could be region-specific. We could do this kind of analysis for every city or region on Earth to find out which places have already experienced the most climate change and what kind of change.</p>

<p>But to do this analysis globally we need to make querying the data warehouse fast, and there‚Äôs a lot of data. The first step is to load the data into a database of some kind. I‚Äôm going to try using PostgreSQL here. It should be a good learning experience and using TimescaleDB to speed up time-based queries and eventually PostGIS to speed up geospatial queries seems promising.</p>

<p>To get there though we first need to load all this data into Postgres and this is what this post is about. Initial attempts at loading the data seemed slow so I wanted to investigate how to do this fast, leading me down a rabbit hole and me writing this.<sup id="fnref:postgres-guide" role="doc-noteref"><a href="#fn:postgres-guide" rel="footnote">1</a></sup></p>

<p>Are we building a data warehouse? I think so‚Ä¶? Is a relational database even appropriate for gridded weather data? No idea but we‚Äôll find out.</p>

<h2 id="whats-the-data">What‚Äôs the data?</h2>

<p>We are not working with actual weather observations. They are great, but can be sparse in certain regions especially in the past. Instead, we will be working with the ERA5 climate reanalysis product<sup id="fnref:era5-explanation" role="doc-noteref"><a href="#fn:era5-explanation" rel="footnote">2</a></sup>. It‚Äôs our best estimate of the historical state of the Earth‚Äôs weather and is widely used in weather and climate research.</p>

<p>The data is output from a climate model run that is constrained to match weather observations. So where we have lots of weather observations, ERA5 should match it closely. And where we do not have any weather observations, ERA5 will be physically consistent and should match the climatology, i.e. the simulated weather‚Äôs statistics should match reality. At the top of this page is a snapshot of what global surface temperature looks like and below is a snapshot of global precipitation.</p>

<figure>

  <p><img src="https://aliramadhan.me/img/trillion_rows/precipitation_figure.png" alt="global precipitation snapshot"/></p>

  <figcaption>Global snapshot of precipitation rate at 2018-12-04 04:00:00 UTC.</figcaption>

</figure>

<p>Here‚Äôs what a time series of temperature looks like at one location.</p>

<figure>

  <p><img src="https://aliramadhan.me/img/trillion_rows/zoom_plot_temperature_Durban.png" alt="temperature time series"/></p>

  <figcaption>Time series of surface temperature near Durban, South Africa.</figcaption>

</figure>

<p>ERA5 covers the entire globe at 0.25 degree resolution, and stretches back in time to 1940 with hourly resolution. Hourly data stretching back to 1940 is 727,080 snapshots in time for each variable like temperature, precipitation, cloud cover, wind speed, etc. A regularly-spaced latitude-longitude grid at 0.25 degree resolution has 1,038,240 grid points or locations (1440 longitudes and 721 latitudes including both poles). Together that‚Äôs 753,836,544,000 or ~754 billion rows of data if indexed by time and location. That‚Äôs a good amount of data. And as I found out, it‚Äôs not trivial to quickly shove this data into a relational database, much less be able to query it quickly.</p>

<p>The ERA5 data is distributed as NetCDF<sup id="fnref:netcdf-explanation" role="doc-noteref"><a href="#fn:netcdf-explanation" rel="footnote">3</a></sup> files. You can query an API for the data or download it from certain providers but generally each file contains data for a day, a month, or a year. This chunking by time makes it quick and easy to query the dataset at single points in time, but looking at temporal patterns is very slow as many files need to be read to pull out a single time series. It takes like 20~30 minutes to pull out temperature data for one location to make the plot above! Complex geospatial queries, especially over time, will be slow and difficult to perform. Packages like <a href="https://xarray.dev/">xarray</a> and <a href="https://www.dask.org/">dask</a> (and efforts by <a href="https://pangeo.io/">Pangeo</a>) speed things up but it‚Äôs still a slow process.</p>

<p>We‚Äôll just load in temperature, zonal and meridional wind speeds, total cloud cover, precipitation, and snowfall for each time and location so we‚Äôll use this table schema:</p>

<pre><code>create table weather (
    time timestamptz not null,
    location_id int,
    latitude float4,
    longitude float4,
    temperature_2m float4,
    zonal_wind_10m float4,
    meridional_wind_10m float4,
    total_cloud_cover float4,
    total_precipitation float4,
    snowfall float4
);
</code></pre>

<p>And before you mention database normalization, yes I have both a <code>location_id</code> column and <code>latitude</code> and <code>longitude</code> columns. It‚Äôs for later benchmarking with queries and indexes.</p>



<h2 id="starting-with-just-the-single-row-insert-statement">Starting with just the single-row <code>insert</code> statement</h2>

<p>The simplest way to load data into a table is by using the <code>insert</code> command to insert a single row. This looks something like</p>

<pre><code>insert into weather (
    time,
    location_id,
    latitude,
    longitude,
    temperature_2m,
    zonal_wind_10m,
    meridional_wind_10m,
    total_cloud_cover,
    total_precipitation,
    snowfall
) values (&#39;1995-03-10 16:00:00+00&#39;, 346441, -30, 30.25, 15.466888,
          -2.0585022, 0.25202942, 0.9960022, 0.007845461, 0);
</code></pre>

<p>and so you can just loop over all the data doing this row-by-row. Unfortunately it is quite slow as quite a bit goes on behind the scenes here:</p>

<ol>
  <li>Postgres needs to parse the statement, validate table and column names, and plan the best way to execute it.</li>
  <li>Postgres may need to lock the table to ensure data integrity.<sup id="fnref:mvcc-explanation" role="doc-noteref"><a href="#fn:mvcc-explanation" rel="footnote">4</a></sup></li>
  <li>The data is written to a buffer as Postgres uses a write-ahead logging<sup id="fnref:wal-explanation" role="doc-noteref"><a href="#fn:wal-explanation" rel="footnote">5</a></sup> (or WAL) system.</li>
  <li>Data from the buffer is actually inserted into the table on disk (which may involve navigating through and updating indexes, but we won‚Äôt have any here).</li>
  <li>If the <code>insert</code> statement is part of a transaction<sup id="fnref:transaction-explanation" role="doc-noteref"><a href="#fn:transaction-explanation" rel="footnote">6</a></sup> that is committed, then the changes are made permanent.</li>
</ol>

<p>So there‚Äôs a lot of overhead associated with inserting single rows, especially if each <code>insert</code> gets its own transaction.</p>

<p>How many rows can we actually insert per second using single-row inserts? After loading the data from NetCDF into a pandas dataframe I found three<sup id="fnref:orm-explanation" role="doc-noteref"><a href="#fn:orm-explanation" rel="footnote">7</a></sup> ways to insert the data into Postgres from Python so let‚Äôs benchmark all three:</p>

<ol>
  <li><strong>pandas</strong>: You can insert data straight from a dataframe using the <code>df.to_sql()</code> function with the <code>chunksize=1</code> keyword argument to force single-row inserts.</li>
  <li><strong>psycopg3</strong>: You can use <a href="https://www.psycopg.org/psycopg3/docs/basic/params.html">parameterized queries</a> to protect against <a href="https://en.wikipedia.org/wiki/SQL_injection">SQL injection</a>, not that it‚Äôs a risk here (yet) but it‚Äôs good to practice safety I guess. All inserts are part of one transaction that is committed at the end.</li>
  <li><strong>SQLAlchemy</strong>: You can similarly use named parameters in a parameterized query to prevent SQL injection attacks.</li>
</ol>

<figure>

  <p><img src="https://aliramadhan.me/img/trillion_rows/benchmarks_insert.png" alt="single-row insert benchmarks"/></p>

  <figcaption>
    Blue bars show the median insert rate into a regular PostgreSQL table, while orange bars show the median insert rate into a TimescaleDB hypertable. Each benchmark inserted 20k rows and was repeated 10 times. The error bars show the range of insert rates given by the 10th and 90th percentiles.
</figcaption>

</figure>

<p>I benchmarked inserting into a regular Postgres table and a TimescaleDB hypertable<sup id="fnref:hypertable-explanation" role="doc-noteref"><a href="#fn:hypertable-explanation" rel="footnote">8</a></sup>.</p>

<p>Pandas and psycopg3 perform similarly, with a slight edge to psycopg3. SQLAlchemy is the slowest even though we‚Äôre not using its ORM tool. This may be because it introduces extra overhead with its abstractions around session management and compiled SQL expressions.</p>

<p>Inserting into a Timescale hypertable is a bit slower. This is maybe because rows are being inserted into a hypertable with chunks so there may be some overhead there, even if there‚Äôs only one chunk.</p>

<p>So at best we‚Äôre only getting ~3000 inserts per second with single-row inserts at which rate we‚Äôre gonna have to wait ~8 years for all the data to load ü¶• There must be a faster way.</p>

<h2 id="multi-valued-insert">Multi-valued <code>insert</code></h2>

<p>You can insert multiple rows with one <code>insert</code> statement. This is called a multi-valued or bulk insert and looks like this:</p>

<pre><code>insert into weather (
    time,
    location_id,
    latitude,
    longitude,
    temperature_2m,
    zonal_wind_10m,
    meridional_wind_10m,
    total_cloud_cover,
    total_precipitation,
    snowfall
) values
    (&#39;1995-03-02 04:00:00+00&#39;, 346444, -30, 31, 21.54013,
     7.1091003, 5.9887085, 1, 2.7820282, 0),
    (&#39;1995-03-02 05:00:00+00&#39;, 346444, -30, 31, 21.596466,
     7.0369415, 6.2397766, 0.95751953, 2.1944494, 0),
    (&#39;1995-03-02 06:00:00+00&#39;, 346444, -30, 31, 21.660583,
     6.303482, 6.017273, 0.88571167, 1.9253268, 0);
</code></pre>

<p>This is faster for a few reasons. There‚Äôs less network overhead as each single-row insert requires a network round trip for each row inserted. Postgres also only has to parse and plan once. Multi-row inserts can also be further optimized when it comes to updating indexes. It seems that you can bulk insert as many rows as you want as long as they fit in memory.</p>

<p>In pandas it sounds like you can do this by passing the <code>method=&#34;multi&#34;</code> keyword argument to the <code>df.to_sql()</code> function but I found this to be a bit slower than single-row inserts with <code>chunksize=1</code>. So I just didn‚Äôt set a method or chunk size and supposedly all rows will be written at once, and it was faster. With psycopg3 you can construct or stream a list of tuples, one for each row, and insert them all at once. With SQLAlchemy it‚Äôs a dict of tuples.</p>

<figure>

  <p><img src="https://aliramadhan.me/img/trillion_rows/benchmarks_multi_insert.png" alt="multi-valued insert benchmarks"/></p>

  <figcaption>This time each benchmark inserted 100k rows and was repeated 10 times.</figcaption>

</figure>

<p>Now there‚Äôs a clear winner with psycopg3 at 25~30k inserts/sec. I‚Äôm not sure why psycopg3 is faster but it looks like pandas is <a href="https://github.com/pandas-dev/pandas/blob/a671b5a8bf5dd13fb19f0e88edc679bc9e15c673/pandas/io/sql.py#L938-L968">using dictionaries to insert</a> which can be slower than just plain tuples. SQLAlchemy might be extra slow slow here because of additional overhead like with single-row inserts and I also passed it dictionaries.</p>

<p>With multi-row inserts there‚Äôs an order-of-magnitude improvement but at ~30k inserts per second, we‚Äôre still gonna have to wait ~0.8 years or almost 10 months for all the data to load üê¢</p>



<h2 id="upgrading-to-the-copy-statement">Upgrading to the <code>copy</code> statement</h2>

<p>For loading in larger amounts of data, Postgres has the <code>copy</code> statement allowing us to insert rows from a CSV file or from a binary file.<sup id="fnref:copy-binary-note" role="doc-noteref"><a href="#fn:copy-binary-note" rel="footnote">9</a></sup> <code>copy</code> is faster than multi-row inserts as Postgres reads data straight from the file and optimizes parsing, planning, and WAL usage knowing there is a lot of data to load.</p>

<p>Once you have a CSV file it‚Äôs as simple as</p>

<pre><code>copy weather from some_big.csv delimiter &#39;,&#39; csv header;
</code></pre>

<p>We have the option of saving data from NetCDF files as CSV files then using <code>copy</code>. This honestly feels inefficient as saving timestamps and floating-point numbers as plaintext to disk takes up more space that it should then reading it from disk seems like it would be slow, but Postgres seems to have optimized this operation. We also have the option of not saving the data into CSV files and streaming it straight into Postgres using psycopg3‚Äôs <code>cusor.copy()</code> function.</p>

<p>When benchmarking <code>copy</code> vs. <code>psycopg3.cursor.copy()</code> we are starting with a pandas dataframe so we must account for the time it takes to save all the data to CSV files on disk in the case of <code>copy csv</code>. In the case of <code>cursor.copy()</code> if we stream a list of tuples then the only overhead is creating the cursor and tuple generator.</p>

<figure>

  <p><img src="https://aliramadhan.me/img/trillion_rows/benchmarks_copy.png" alt="copy benchmarks"/></p>

  <figcaption>
    Here the full rate includes overhead (writing CSV files or constructing tuples) while the copy rate does not. This time each benchmark inserted 1,038,240 rows (1 day of ERA5 data) and was repeated 10 times.
</figcaption>

</figure>

<p>We see that <code>copy</code> can actually insert close to 400k rows per second, but that is if you already have the CSV file ready to go. Including overhead, both <code>copy</code> and psycopg3 can manage around 100k inserts/second with psycopg3 being a bit faster. For some reason there seems to be no difference between regular table and hypertable performance for psycopg3.</p>

<p>At ~100k inserts/second we‚Äôre still talking about ~3 months to load all the data üêå</p>

<h2 id="sustaining-copy-insert-rates">Sustaining <code>copy</code> insert rates</h2>

<p>When inserting <em>many</em> rows, Postgres may encounter bottlenecks<sup id="fnref:write-bottlenecks" role="doc-noteref"><a href="#fn:write-bottlenecks" rel="footnote">10</a></sup> so it‚Äôs important that the insert rate can be sustained. To look at this, we can insert hundreds of millions of rows and watch for fluctuations in the insert rate.</p>

<figure>

  <p><img src="https://aliramadhan.me/img/trillion_rows/benchmarks_copy_at_scale.png" alt="copy at scale benchmarks"/></p>

  <figcaption>
    For this benchmark, rows were inserted in 744 batches of 1,038,240 rows for a total of ~772 million rows. The overall insert rate is plotted. The dots show the insert rate for each batch while the solid lines show a 10-batch rolling mean. The straight horizontal lines show the mean insert rate over the entire benchmark. Note that the lines orange and blue straight lines are right on top of each other.
</figcaption>

</figure>

<p>It seems that, at least with one worker, we don‚Äôt see huge drops in insert rates although <code>copy csv</code> shows frequent drops and seems more susceptible to fluctuations. psycopg3 is generally faster and interestingly there isn‚Äôt much of a difference between copying into a regular table or hypertable.</p>

<h2 id="parallel-copy">Parallel <code>copy</code></h2>

<p>Inserting data with <code>copy</code> is fast but can we speed it up by executing multiple <code>copy</code> operations in parallel? Using the joblib package we can execute multiple <code>copy</code> statements or psycopg3 cursors in parallel.</p>

<figure>

  <p><img src="https://aliramadhan.me/img/trillion_rows/benchmarks_parallel_copy.png" alt="parallel copy benchmarks"/></p>

  <figcaption>
    The overall insert rate is plotted as a function of the number of workers. Each benchmark inserted 128 hours of ERA5 data (~133 million rows).
</figcaption>

</figure>

<p>Inserting data into a single table is not super parallelizable so it looks like performance generally plateaus after 16 workers.<sup id="fnref:better-parallel-benchmark" role="doc-noteref"><a href="#fn:better-parallel-benchmark" rel="footnote">11</a></sup></p>



<h2 id="pg_bulkload-and-timescaledb-parallel-copy">pg_bulkload and timescaledb-parallel-copy</h2>

<p>Beyond the <code>copy</code> statement, there are external tools for loading large amounts of data into Postgres. I‚Äôll benchmark two of them, <a href="https://github.com/ossc-db/pg_bulkload">pg_bulkload</a> and <a href="https://github.com/timescale/timescaledb-parallel-copy">timescaledb-parallel-copy</a>.</p>

<figure>

  <p><img src="https://aliramadhan.me/img/trillion_rows/benchmarks_tools.png" alt="tools benchmarks"/></p>

  <figcaption>
    Blue and orange bars show results from benchmarks that inserted 1,038,240 rows (1 day of ERA5 data) and were repeated 10 times. The sustained insert rates are from benchmarks that inserted 256 hours of ERA5 data (~266 million rows) into a hypertable. In these benchmarks the CSV files were already written to disk so the insert rate corresponds to the &#34;copy rate&#34; from the copy benchmarks. The insert rate including overhead accounts for the time it takes to write the CSV files to disk.
</figcaption>

</figure>

<p>At first it would seem that pg_bulkload is much faster, however, this is because by default it bypasses the shared buffers and skips WAL logging so data recovery following a crash may not be possible while timescaledb-parallel-copy does not and does things more safely. On a level playing field with <code>fsync</code> off (see next section for an explanation) timescaledb-parallel-copy with multiple workers beats out pg_bulkload.</p>

<h2 id="multiple-workers-with-timescaledb-parallel-copy">Multiple workers with timescaledb-parallel-copy</h2>

<p>timescaledb-parallel-copy lets you specify the number of workers inserting data in parallel. Let‚Äôs see how much performance we can squeeze out with more workers, and if that performance can be sustained.</p>

<figure>

  <p><img src="https://aliramadhan.me/img/trillion_rows/benchmarks_parallel_tpc.png" alt="timescaledb-parallel-copy benchmarks"/></p>

  <figcaption>
    The insert rate as a function of the number of rows inserted. In this benchmark the CSV files were already written to disk so the insert rate corresponds to the &#34;copy rate&#34; from the copy benchmarks. Each benchmark inserted 256 hours of ERA5 data (~266 million rows). Note the vertical log scale.
</figcaption>

</figure>

<p>Initial performance looks great! But eventually, before 100 million rows on my system, a bottleneck is reached and the insert rate tanks before picking back up in waves. The maximum sustained insert rate is around 600~700k inserts/sec for regular tables and ~300k for hypertables.</p>

<p>pg_bulkload doesn‚Äôt let you specify the number of threads or workers, but does have a <code>writer=parallel</code> option which uses multiple threads to do data reading, parsing and writing in parallel. We‚Äôll look at its insert rate later.</p>



<p>There are a couple of other things we can try to speed up inserts, but are basically some form of tweaking <a href="https://www.postgresql.org/docs/current/non-durability.html">Postgres‚Äô non-durable settings</a>.</p>

<p>Some extra performance can be squeezed out of tweaking non-durable settings specifically for loading data following suggestions by <a href="https://stackoverflow.com/a/12207237">Craig Ringer on StackOverflow</a>. Some of the settings can be dangerous for database integrity in the event of a crash though. The main settings to change are turning off <code>fsync</code> to avoid flushing data to disk and also turning off <code>full_page_writes</code> to avoid guarding against partial page writes.</p>

<p>You can also insert data into an unlogged table that generates no WAL and gets truncated upon crash recovery but is faster to write into. While inserting into an unlogged table might be fast, you still have to convert it to a regular logged table afterwards which can be a <a href="https://dba.stackexchange.com/a/195829">slow single-threaded process</a>. And hypertables cannot be unlogged, so if you want a hypertable you need to further convert/migrate the regular logged table to a hypertable which can also be slow.</p>



<p><strong>Short answer: Use psycopg3 to directly copy data into a hypertable. If you already have CSV files then use timescaledb-parallel-copy. For parallelization the sweet spot seems to be 12~16 workers on my system.</strong></p>

<p>We want to end up with a hypertable but it seems like inserting into a regular table is faster. So is it faster to insert into a regular table then convert it to a hypertable? Or is it faster to just insert data straight into a hypertable?</p>

<figure>

  <p><img src="https://aliramadhan.me/img/trillion_rows/conversion_time.png" alt="table conversion time"/></p>

  <figcaption>
    Blue bars show the wall clock time taken to insert data into the table and the orange bar shows the time taken to convert the regular table into a hypertable.
</figcaption>

</figure>

<p>A quick test with inserting ~772 million rows with psycopg3‚Äôs copy and 16 workers shows that inserting data into a hypertable is faster as it takes roughly 80% of the time in this case. This may not always be the case but inserting into a regular table then converting it to a hypertable and migrating the data will probably always be slower as the conversion/migration process is not super fast and seems to be single-threaded.</p>

<p>Now that we‚Äôve concluded we want to be inserting data into a hypertable, let‚Äôs take a look at the all hypertable insert rates we‚Äôve considered in one plot.</p>

<figure>

  <p><img src="https://aliramadhan.me/img/trillion_rows/benchmarks_summary.png" alt="benchmarks summary"/></p>

  <figcaption>
    Sustained hypertable insert rates including overhead (writing CSV files) for different insertion methods. Here &#34;tpc&#34; is short for timescaledb-parallel-copy and &#34;pgb&#34; is short for pg_bulkload. &#34;32W&#34; means 32 workers were used for that benchmark.
</figcaption>

</figure>

<p>For pg_bulkload with a single worker the the <code>writer=buffered</code> option was used. For multiple workers, the <code>writer=buffered</code> and <code>multi_process=yes</code> options were used. Then for multiple workers with fsync off, the <code>writer=parallel</code> option was used.</p>

<p>So what can we conclude?</p>

<ol>
  <li>At least on my hardware it seems there‚Äôs a ceiling of ~140k sustained inserts/sec with overhead when using a single worker with protections on. pg_bulkload wins here by quite a bit.</li>
  <li>You can use multiple workers to increase the sustained insert rate up to ~250k inserts/sec with psycopg3‚Äôs copy cursor while still being protected.</li>
  <li>The insertion process is not very parallelizable so the sweet spot is 4-16 workers. The benchmarks used 32 workers to maximize insert rates.</li>
  <li>If you‚Äôre okay living a bit dangerously you can turn off fsync and sustain an insert rate of ~462k inserts/sec with psycopg3! You‚Äôll also squeeze out a bit more performance out of timescaledb-parallell-copy.</li>
  <li>Be careful when using pg_bulkload as it disables <code>fsync</code> by default.</li>
  <li>These conclusions assume you need to do extra work to convert data to CSV files which is why psycopg3 was the clear winner, although it does seem pretty fast. If you‚Äôre starting with CSV files timescaledb-parallel-copy is probably faster (and quicker to set up).</li>
</ol>

<p>Some closing thoughts:</p>

<ol>
  <li>Want even faster inserts? You should probably upgrade your hardware. A nice enterprise-grade NvME SSD and lots of high-speed DDR5 RAM will help a lot. I used hardware that is roughly 5 years old so newer hardware should be able to easily beat these benchmarks.</li>
  <li>I know the general wisdom is to just dump this data into Snowflake or BigQuery and get fast analytics for relatively cheap. But I like working with my own hardware and learning this way. Plus I have no real budget for this project.</li>
  <li>I‚Äôd be curious how ClickHouse performs on these benchmarks. My impression is that it would probably be faster out of the box. But I want to learn PostgreSQL and like the fact that TimescaleDB is just a Postgres extension so I went with TimescaleDB.</li>
</ol>

<p>At a sustained ~462k inserts per second, we‚Äôre waiting ~20 days for our ~754 billion rows which is not bad I guess üê® It‚Äôs less time than it took me to write this post.</p>



<h2 id="source-code">Source code</h2>

<p>The code used to download the ERA5 data, create the tables, insert/copy data, run benchmarks, and plot figures is at the <a href="https://github.com/ali-ramadhan/timescaledb-insert-benchmarks">timescaledb-insert-benchmarks</a> repository.</p>

<h2 id="benchmarking-methodology">Benchmarking methodology</h2>

<p>To ensure a consistent environment for benchmarking, a new Docker container was spun up for each individual benchmark. No storage was persisted between Docker containers. Data including NetCDF and CSV files were read from a HDD and the database was stored on an NvME SSD.</p>

<p>Hardware:</p>

<ul>
  <li>CPU: 2x 12-core Intel Xeon Silver 4214</li>
  <li>RAM: 16x 16 GiB Samsung M393A2K40CB2-CTD ECC DDR4 2666 MT/s</li>
  <li>SSD: Intel SSDPEKNW020T8 2 TB NvME</li>
  <li>HDD: Seagate Exos X16 14TB 7200 RPM 256MB Cache</li>
</ul>

<p>Software:</p>

<ul>
  <li>Ubuntu 20.04 with Linux kernel 5.15</li>
  <li>PostgreSQL 15.5</li>
  <li>TimescaleDB 2.13.0</li>
  <li>pg_bulkload 3.1.20</li>
</ul>

<p>Postgres configuration chosen by <code>timescaledb-tune</code>:</p>

<pre><code>shared_buffers = 64144MB
effective_cache_size = 192434MB
maintenance_work_mem = 2047MB
work_mem = 13684kB
timescaledb.max_background_workers = 16
max_worker_processes = 67
max_parallel_workers_per_gather = 24
max_parallel_workers = 48

Recommendations based on 250.57 GB of available memory and 48 CPUs for PostgreSQL 15
wal_buffers = 16MB
min_wal_size = 512MB
default_statistics_target = 100
random_page_cost = 1.1
checkpoint_completion_target = 0.9
max_locks_per_transaction = 512
autovacuum_max_workers = 10
autovacuum_naptime = 10
effective_io_concurrency = 256
</code></pre>

<p>For benchmarking I set the WAL size:</p>

<pre><code>min_wal_size = 4GB
max_wal_size = 16GB
</code></pre>

<p>And for the <code>fsync</code> off benchmarks I set:</p>

<pre><code>max_wal_size = 32GB
fsync = off
full_page_writes = off
</code></pre>





            </div></div>
  </body>
</html>
