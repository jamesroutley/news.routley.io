<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/SubscriberLink/1022920/ad60263cd13c8a13/">Original</a>
    <h1>Asterinas: A new Linux-compatible kernel project</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>
Born from research at the <a href="https://www.sustech.edu.cn/en/">Southern University of Science and
Technology</a> (SUSTech) in Shenzen, China, <a href="https://asterinas.github.io/">Asterinas</a> is a new
Linux-ABI-compatible kernel project written in Rust, based on what the
authors call a &#34;framekernel architecture&#34;.  The project overlaps somewhat
with the goals of the <a href="https://rust-for-linux.com/">Rust for Linux
project</a>, but approaches the problem space from a different direction by
trying to get the best from both monolithic and microkernel designs.

</p><h4>What&#39;s a framekernel?</h4>

<p>
The framekernel concept is explained in the September 2024 paper &#34;<a href="https://dl.acm.org/doi/10.1145/3678015.3680492">Framekernel: A Safe
and Efficient Kernel Architecture via Rust-based Intra-kernel Privilege
Separation</a>&#34; by Yuke Peng et al.  <a href="https://arxiv.org/abs/2506.03876">A fuller version of the paper</a>
was published in early June.


</p><p>
Traditionally, monolithic kernels lump everything into one kernel-mode
address space, whereas microkernels only implement a minimal <a href="https://en.wikipedia.org/wiki/Trusted_computing_base">trusted
computing base (TCB)</a> in kernel space and rely on user-mode services for
much of the operating system&#39;s functionality.  This separation implies the
use of interprocess communication (IPC) between the microkernel and those
services. This IPC often has a performance impact, which is a big part of
why microkernels have remained relatively unpopular.

</p><blockquote>
<b>Stay on top of Linux kernel development</b> with <a href="https://lwn.net/Promo/kernel-1/claim">a one-month free trial subscription</a> to LWN, no credit card required.
</blockquote>

<p>
The core of Asterinas&#39;s &#34;framekernel&#34; design is the encapsulation of all
code that needs Rust&#39;s <tt>unsafe</tt> features inside a library, enabling
the rest of the kernel (the services) to be developed using safe
abstractions.  Those services remain within the kernel&#39;s address space, but
only have access to the resources that the core library gives to them.
This design is meant to improve the safety of the system while retaining
the simple and performant shared-memory architecture of monolithic
kernels. The <a href="https://asterinas.github.io/book/">Asterinas book</a>
on the project&#39;s website provides a nice <a href="https://asterinas.github.io/book/kernel/the-framekernel-architecture.html">
architectural mission statement and overview</a>.


</p><p>
The aptness of the &#34;framekernel&#34; nomenclature can perhaps be debated.  The
frame part refers to the development framework wrapping the unsafe
parts behind a memory-safe API.  The concept of the TCB is, of
course, not exclusive to microkernel architectures but, because there are
strong incentives to strictly scrutinize and, in some contexts, even <a href="https://en.wikipedia.org/wiki/Formal_verification">formally
verify</a> the TCB of a system, keeping the TCB as small as possible is a
central aspect of microkernel designs.


</p><p>
An update on the project is available on the Asterinas blog in the
JuneÂ 4 post titled &#34;<a href="https://asterinas.github.io/2025/06/04/kernel-memory-safety-mission-accomplished.html">Kernel
Memory Safety: Mission Accomplished</a>&#34;.  The post explains the team&#39;s
motivations and the need for the industry to address memory-safety
problems; it provides some illustrations that explain how the framekernel
is different from monolithic kernels and microkernels. It also takes a
moment to emphasize that the benefits of Rust don&#39;t stop with memory
safety; there are improvements to <a href="https://jacko.io/safety_and_soundness.html">soundness</a> as well.
Perhaps most importantly, the post highlights the upcoming Asterinas
presentation at the <a href="https://www.usenix.org/conference/atc25/technical-sessions">2025
USENIX Annual Technical Conference</a>.
</p><h4>Related work</h4>

<p>
In their paper, the authors compare Asterinas to some prior Rust-based
operating-system work, exploring the benefits of the language&#39;s
memory-safety features and explain how Asterinas differs from that previous
work.  Specifically, the paper contrasts Asterinas with <a href="https://www.usenix.org/conference/osdi20/presentation/narayanan-vikram">
RedLeaf</a>, an operating system written in Rust and presented at the 14th
USENIX Symposium on Operating Systems Design and Implementation (OSDI 20)
in 2020.  Asterinas uses hardware isolation to permit running user-space
programs written in any programming language, aims to be general-purpose,
and provides a Linux-compatible ABI, while RedLeaf is a microkernel that is
designed <i>not</i> to use the hardware&#39;s isolation features, and the
project focuses on different things.
</p><p>
Another project of interest is <a href="https://tockos.org/">Tock</a>, an
embedded system that targets SoCs with limited hardware protection
functionality. Like Asterinas, Tock also divides the kernel into a
trusted core allowed to use <tt>unsafe</tt> and untrusted &#34;capsules&#34; that
are not.  As mentioned, Asterinas does rely on hardware protection and
isn&#39;t intended for strictly embedded use, which differentiates it from
Tock.


</p><p>
It bears mentioning that the Rust for Linux project, which is introducing
Rust code into the upstream Linux kernel, has similar goals as
Asterinas. It also aims to encapsulate kernel interfaces with safe
abstractions in such a way that drivers can be written in Rust without any
need for <tt>unsafe</tt>.


</p><h4>Work toward formal verification</h4>

<p>
One goal of shrinking the TCB of an operating system is to make it feasible
to have it formally verified.  In February 2025, the Asterinas blog
featured <a href="https://asterinas.github.io/2025/02/13/towards-practical-formal-verification-for-a-general-purpose-os-in-rust.html">a
post detailing plans to do just that</a>.  The best known formally verified
kernel is <a href="https://sel4.systems/About/">seL4</a>, an L4-family
microkernel.

</p><p>
Asterinas aims to use the framekernel approach to achieve a system that has
a small, formally verified TCB akin to a lean microkernel, but also a
simple shared-memory architecture with Linux ABI compatibility, all at the
same time.  This is a radical departure from any previously formally
verified kernel; the blog post describes those kernels as deliberately
small and limited compared to &#34;<q>full-fledged, UNIX-style OSes</q>&#34;.


</p><p>
The Asterinas project is collaborating with a security-auditing company
called <a href="https://www.certik.com/">CertiK</a> to use <a href="https://github.com/verus-lang/verus">Verus</a> to formally verify the
kernel.  There is an extensive <a href="https://github.com/asterinas/slides/blob/f62c764ea9c4831a747dbe8fa415b56e48493482/slides/2025-01-28%20Asterinas%20Security%20Assessment%20by%20CertiK.pdf">
report</a> available from CertiK on how Asterinas was audited and the
issues that were found.


</p><h4>Libraries and tools</h4>

<p>
The Asterinas kernel is only one result of the project. The other two are
<a href="https://crates.io/crates/ostd">OSTD</a>, described as &#34;<q>a Rust
OS framework that facilitates the development of and innovation in OS
kernels written in Rust</q>&#34;, and <a href="https://asterinas.github.io/book/osdk/guide/index.html">OSDK</a>, a
Cargo addon to assist with the development, building, and testing of
kernels based on OSTD.


</p><p>
There are four stated goals for OSTD as a separate crate. One is to lower
the entry bar for operating-system innovation and to lay the groundwork for
newcomers to operating-system development. The second is to enhance memory
safety for operating systems written in Rust; other projects can benefit
from its encapsulation and abstraction of low-level operations. The third is
to promote code reuse across Rust-based operating-system projects. The
fourth is to boost productivity by enabling testing of new code in user
mode, allowing developers to iterate without having to reboot.


</p><p>
It is worth emphasizing that the kernels that can be written with OSTD do
not have to be Linux-compatible or, in any way, Unix-like. The APIs
provided are more generic than that; they are memory-safe abstractions for
functionality like x86 hardware management, booting, virtual memory, SMP,
tasks, users, and timers.  Like most Rust crates, OSTD is <a href="https://docs.rs/ostd/0.14.1/ostd/index.html">documented on
docs.rs</a>.


</p><p>
Asterinas reports Intel, among others, as a sponsor of the project.
Intel&#39;s interest is likely related to its <a href="https://www.intel.com/content/www/us/en/developer/tools/trust-domain-extensions/overview.html">Trust
Domain Extensions (TDX)</a> feature, which provides hardware modes and
features to facilitate isolation of virtual machines, and memory
encryption.  The Asterinas book has a brief <a href="https://asterinas.github.io/book/osdk/guide/intel-tdx.html">section
on TDX</a>, and the OSDK supports it.


</p><p>
The OSTD, or at least the parts that Asterinas ends up using, seems to
essentially be the restricted TCB that allows <tt>unsafe</tt>. For an
illustrative example, we could take a look at the <tt>network</tt> kernel
component&#39;s <a href="https://github.com/asterinas/asterinas/blob/ecb33ca98d2b2ac680daf1d2a48e4d011db2fbcf/kernel/comps/network/src/buffer.rs">source
code</a> and see that the buffer code uses DMA, locking, allocation, and
virtual-memory code from the OSTD through memory-safe APIs.


</p><h4>Current state</h4>
<p>
Asterinas was first released under the Mozilla Public License in early
2024; it has undergone rapid development over the past year.  GitHub <a href="https://github.com/asterinas/asterinas/graphs/contributors">lists 45
individual committers</a>, but the majority of the commits are from a
handful of PhD students from SUSTech, Peking University, and Fudan
University, as well as a Chinese company called <a href="https://www.antgroup.com/en">Ant Group</a>, which is a sponsor of
Asterinas.

</p><p>
At the time of writing, Asterinas supports two architectures, x86 and RISC-V.
In the January blog post linked above, it was reported that Asterinas
supported 180 Linux system calls, but the number has since grown to <a href="https://github.com/asterinas/asterinas/blob/1fe0fef41003c824b780b7b228f7b01a46497be0/kernel/src/syscall/arch/x86.rs">206
on x86</a>.  As of version 6.7, Linux has 368 system calls in total, so there is
some way to go yet.


</p><p>
Overall, Asterinas is in early development. There have been no releases,
release announcements, changelogs, or much of anything other than Git tags
and a short installation guide in the documentation.  The <a href="https://crates.io/crates/ostd/reverse_dependencies">Dependents
tab</a> of the OSTD crate on crates.io shows that no unrelated, published
crate yet uses OSTD.


</p><p>
It does not seem like Asterinas is able to run any applications yet.  <a href="https://github.com/asterinas/asterinas/issues/1868">Issue #1868</a>
in Asterinas&#39;s repository outlines preliminary plans toward a first
distribution.  The initial focus on a custom initramfs and some rudimentary
user-space applications, followed by being able to <a href="https://github.com/asterinas/asterinas/issues/1851">run
Docker</a>. There are initial plans to bootstrap a distribution based on
Nix. Notably (but unsurprisingly), this issue mentions that Asterinas
doesn&#39;t support loading Linux kernel modules, nor does it ever
plan to.


</p><h4>Near-future goals</h4>

<p>
The <a href="https://asterinas.github.io/book/kernel/roadmap.html">Roadmap</a>
section of the Asterinas book says that the near-term goals are to expand
the support for CPU architectures and hardware, as well as to focus on
real-world usability in the cloud by providing a host OS for virtual
machines.  Apparently, the support for Linux virtio devices is already
there, so a major hurdle has already been cleared.  In particular, the
Chinese cloud market, in the form of Aliyun (also known as Alibaba Cloud)
<a href="https://github.com/asterinas/asterinas/issues/1501">is a
focus</a>.  The primary plans involve creating a container host OS with a
tight, formally verified TCB and support for some trusted-computing
features in Intel hardware, for the Chinese cloud service.


</p><p>
While both Rust for Linux and Asterinas have similar goals (providing a
safer kernel by relying on Rust&#39;s memory safety), their scopes and
approaches are different.  Rust for Linux focuses on safe abstractions
strictly for new device drivers to be written in safe Rust, but this leaves
the rest of the kernel untouched.
Asterinas, on the other hand, aims to build a whole new kernel from the ground
up, restricting the <tt>unsafe</tt>-permitting core to the absolute minimum,
which can then be formally verified.  Asterinas also focuses on
containers and cloud computing, at least for now, while Rust for Linux looks to
benefit the whole of the Linux ecosystem.


</p><p>
Despite the stated cloud focus, there is more going on, for example building
support for <a href="https://github.com/asterinas/asterinas/issues/2008">X11</a>
and <a href="https://github.com/asterinas/asterinas/issues/2112">Xfce</a>.
Also, the OSTD could, of course, prove interesting for OS development
enthusiasts irrespective of the Asterinas project, but so far it remains unknown
and untested by a wider audience.

</p><p>
Asterinas is certainly a refreshingly innovative take on principles for
operating-system development, leaning on the safety and soundness
foundations provided by the Rust language and compiler. So far it is at an
early exploratory stage driven by enthusiastic Chinese researchers and
doesn&#39;t see any serious practical use, but it is worth keeping an eye
on. It will be interesting to see the reception it will get from the
Rust for Linux team and the Linux community at large.<br clear="all"/></p><table>
           <tbody><tr><th colspan="2">Index entries for this article</th></tr>
           <tr><td><a href="https://lwn.net/Archives/GuestIndex/">GuestArticles</a></td><td><a href="https://lwn.net/Archives/GuestIndex/#Koistinen_Ronja">Koistinen, Ronja</a></td></tr>
            </tbody></table></div></div>
  </body>
</html>
