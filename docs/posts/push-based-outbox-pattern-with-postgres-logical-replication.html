<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://event-driven.io/en/push_based_outbox_pattern_with_postgres_logical_replication/">Original</a>
    <h1>Push-based outbox pattern with Postgres logical replication</h1>
    
    <div id="readability-page-1" class="page"><div><p><strong>There are only a few patterns that I’m comfortable saying: <em>“You should use it always if you want to build mature system”</em>. One of them is the Outbox Pattern.</strong> Why? Because it guarantees that your business workflows and communication will not be stuck in the middle.</p>
<p>As I explained in <a href="https://event-driven.io/en/outbox_inbox_patterns_and_delivery_guarantees_explained/">Outbox, Inbox patterns and delivery guarantees explained</a>:</p>
<p><em><strong>Outbox Pattern ensures that a message was sent (e.g. to a queue) successfully at least once.</strong> With this pattern, instead of directly publishing a message to the queue, we store it in temporary storage (e.g. database table). We’re wrapping the entity save and message storing with the Unit of Work (transaction). By that, we’re ensuring that the message won’t be lost if the application data is stored. It will be published later through a background process. This process will check if there are any unsent messages in the table. When the worker finds any, it tries to send them. After it gets confirmation of publishing (e.g. ACK from the queue), it marks the event as sent.</em></p>
<p><span>
      <a href="https://event-driven.io/static/df0bc7f95463875eca32513aea9cf439/ba579/2022-10-13-cover.jpg" target="_blank" rel="noopener">
    <span></span>
  <img alt="cover" title="cover" src="https://event-driven.io/static/df0bc7f95463875eca32513aea9cf439/4b190/2022-10-13-cover.jpg" srcset="/static/df0bc7f95463875eca32513aea9cf439/e07e9/2022-10-13-cover.jpg 200w,
/static/df0bc7f95463875eca32513aea9cf439/066f9/2022-10-13-cover.jpg 400w,
/static/df0bc7f95463875eca32513aea9cf439/4b190/2022-10-13-cover.jpg 800w,
/static/df0bc7f95463875eca32513aea9cf439/e5166/2022-10-13-cover.jpg 1200w,
/static/df0bc7f95463875eca32513aea9cf439/b17f8/2022-10-13-cover.jpg 1600w,
/static/df0bc7f95463875eca32513aea9cf439/ba579/2022-10-13-cover.jpg 1680w" sizes="(max-width: 800px) 100vw, 800px" loading="lazy" decoding="async"/>
  </a>
    </span></p>
<p>Why does it provide at-least-once and not exactly-once? Writing to the database may fail (e.g. it will not respond). When that happens, the process handling outbox pattern will try to resend the event after some time and try to do it until the message is correctly marked as sent in the database._</p>
<p>We can use Outbox Pattern to publish any type of message. Typically we’re sending commands or publishing events (see more in <a href="https://event-driven.io/en/whats_the_difference_between_event_and_command/">What’s the difference between a command and an event?</a> to know why semantics matters).</p>
<p>If you’re using a relational database, you typically need to create the table for the messages.</p>
<p>The example structure could look as follows:</p>
<div data-language="sql"><pre><code><span>CREATE</span> <span>TABLE</span> publications<span>(</span>
   
   position        BIGSERIAL                 <span>PRIMARY</span> <span>KEY</span><span>,</span>
   
   publication_id  <span>VARCHAR</span><span>(</span><span>250</span><span>)</span>              <span>NOT</span> <span>NULL</span><span>,</span>
   
   message_id       <span>VARCHAR</span><span>(</span><span>250</span><span>)</span>             <span>NOT</span> <span>NULL</span><span>,</span>
   
   message_type     <span>VARCHAR</span><span>(</span><span>250</span><span>)</span>             <span>NOT</span> <span>NULL</span><span>,</span>
   
   <span>data</span>             JSONB                    <span>NOT</span> <span>NULL</span><span>,</span>
   
   scheduled       <span>TIMESTAMP</span> <span>WITH</span> <span>TIME</span> ZONE  <span>NOT</span> <span>NULL</span>    <span>default</span> <span>(</span><span>now</span><span>(</span><span>)</span><span>)</span><span>,</span>
<span>)</span><span>;</span></code></pre></div>
<p>If we’d like to have the option to have more than one subscriber and parallelise the publishing, then we should also define the table with information about the publishing process.</p>
<div data-language="sql"><pre><code><span>CREATE</span> <span>TABLE</span> subscribers
<span>(</span>
   
   subscription_id          <span>VARCHAR</span><span>(</span><span>250</span><span>)</span> <span>PRIMARY</span> <span>KEY</span><span>,</span>
   
   last_processed_position  <span>INTEGER</span>      <span>NULL</span><span>,</span>
   
   publication_id           <span>VARCHAR</span><span>(</span><span>250</span><span>)</span> <span>NOT</span> <span>NULL</span><span>,</span>
<span>)</span><span>;</span></code></pre></div>
<p>We can subscribe to the specific message sequence (called <em>publication</em>) with such a table structure. Once we handle the particular message, using its position, we update the subscription’s last processed position. Thanks to that, we can retry it from the previously known position even if the process breaks in the middle.</p>
<p><strong>Typically, this processing happens by polling.</strong> With a defined interval, we’re querying the messages table to get the new to publish. For instance:</p>
<div data-language="sql"><pre><code><span>SELECT</span> 
   p<span>.</span>position<span>,</span> p<span>.</span>publication_id<span>,</span> p<span>.</span>message_id<span>,</span> p<span>.</span>message_type<span>,</span> p<span>.</span><span>data</span><span>,</span> p<span>.</span>scheduled
<span>FROM</span> publication p
<span>WHERE</span>
   p<span>.</span>publication_id <span>=</span> subscription_publication_id
   p<span>.</span>last_processed_position  <span>&gt;</span> subscription_last_processed_position 
<span>LIMIT</span> <span>100</span> </code></pre></div>
<p>This is fine for many cases, but:</p>
<ul>
<li>it’s not easy to find the right interval. <a href="https://martendb.io/events/projections/async-daemon.html#async-projections-daemon">Marten Async Daemon</a> does fancy stuff to tune it depending on how fast new messages are appended. But still, it’s an approximation.</li>
<li>polling may require more resources and have more extensive memory pressure.</li>
<li>it’s not as easy as it seems to scale it in a reliable and resilient way (e.g. have multiple nodes, <a href="https://jeremydmiller.com/2020/05/05/using-postgresql-advisory-locks-for-leader-election/">leaders election</a> etc.),</li>
<li>may be harder to implement than it seems, check more in <a href="https://event-driven.io/en/ordering_in_postgres_outbox/">How Postgres sequences issues can impact your messaging guarantees</a>.</li>
</ul>
<p>It would be great if we could be notified by the database when new messages arrive, right?</p>
<p>If you’re using Postgres, then you may be the lucky person then!</p>
<h2 id="postgres-logical-replication"><a href="#postgres-logical-replication" aria-label="postgres logical replication permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Postgres Logical Replication</h2>
<p><strong>I’m not sure if you know, but <a href="https://event-driven.io/en/relational_databases_are_event_stores/">Relational databases work like event stores</a>. They have a concept called <em>“Write-Ahead Log”</em> (WAL).</strong> It is an append-only structure that records all the operations during transaction processing (Inserts, Updates, Deletes). When we commit a transaction, the data is firstly appended to the Write-Ahead Log. Then all operations are applied to tables, indexes, etc. Hence the name “Write-Ahead”: from this writing data to the log in advance of other changes. So from that perspective, tables and indexes are just read models for Write-Ahead Log.</p>
<p>Postgres is a rock-solid database with many superb features. One of them is JSON support we’re using in <a href="https://martendb.io">Marten</a>, and the other is logical replication that we’ll look closer at now.</p>
<p><strong>Logical replication takes the traditional approach to the next level. Instead of sending the raw binary stream of backed-up database files, we’re sending a stream of changes that were recorded in the Write-Ahead Log.</strong> It’s named logical, as it understands the operations’ semantics, plus the information about the tables it’s replicating. It’s highly flexible; it can be defined for one or multiple tables, filter records and copy a subset of data. It can inform you about changes to specific records. Thus it requires the replicated table to have primary keys.</p>
<p>The first step is to enable logical replication in Postgres config (<em>postgresql.conf</em>):</p>

<p>If Docker compose, you can configure it as:</p>
<div data-language="yml"><pre><code><span>version</span><span>:</span> <span>&#34;3&#34;</span>
<span>services</span><span>:</span>
  <span>postgres</span><span>:</span>
    <span>image</span><span>:</span> postgres<span>:</span>14.5<span>-</span>alpine
    <span>ports</span><span>:</span>
      <span>-</span> <span>&#34;5432:5432&#34;</span>
    <span>environment</span><span>:</span>
      <span>-</span> POSTGRES_DB=postgres
      <span>-</span> POSTGRES_PASSWORD=postgres
    <span>command</span><span>:</span>
      <span>-</span> <span>&#34;postgres&#34;</span>
      <span>-</span> <span>&#34;-c&#34;</span>
      <span>-</span> <span>&#34;wal_level=logical&#34;</span></code></pre></div>
<p>Similarly to the Outbox tables described above, it has publish-subscribe semantics.</p>
<p><strong>To define publication, we need to call the following SQL statement:</strong></p>
<div data-language="sql"><pre><code><span>CREATE</span> PUBLICATION outbox_pub <span>FOR</span> <span>TABLE</span> outbox<span>;</span></code></pre></div>
<p><strong>We also need to tell Postgres that it should retain Write-Ahead Log entries required to perform logical replications, even if replicas/subscribers are disconnected from the database. We do that by defining logical replication slot:</strong></p>
<div data-language="sql"><pre><code><span>SELECT</span> <span>*</span> <span>FROM</span> pg_create_logical_replication_slot<span>(</span><span>&#39;outbox_slot&#39;</span><span>,</span> <span>&#39;pgoutput&#39;</span><span>)</span><span>;</span></code></pre></div>
<p>The first parameter is just a freehand name. The other is the name of the logical decoding plugin we’d like to use. Logical replication is still performed with binary data of the defined format. It’s not super-readable for humans or even for other systems. To be able to translate the replication format, we can use logical decoding plugins. They’re plenty of them, from the most known; let me mention:</p>
<ul>
<li><a href="https://www.postgresql.org/docs/current/test-decoding.html">test-decoding</a> - allows to read replication data in the SQL format. A built-in one; as the name suggests, is made for quick tests.</li>
<li><a href="https://github.com/eulerto/wal2json">wal2json</a> - translates WAL changeset into JSON format.</li>
<li><a href="https://www.postgresql.org/docs/15/logical-replication-architecture.html">pg_output</a> - standard decoding plugin.</li>
</ul>
<p><em>pg_output</em> is probably the most popular. It’s used in the most known and mature tool <a href="https://debezium.io/documentation/reference/stable/postgres-plugins.html">Debezium</a>. It’s also used in <a href="https://www.npgsql.org/doc/replication.html">Npgsql</a>, .NET Postgres data provider. We’ll use it to show logical replication in practice.</p>
<h2 id="net-logical-replication-example"><a href="#net-logical-replication-example" aria-label="net logical replication example permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>.NET logical replication example</h2>
<p>Let’s say we’re using a simplified version of the Publication table presented above:</p>
<div data-language="sql"><pre><code><span>CREATE</span> <span>TABLE</span> outbox <span>(</span>
   position    BIGSERIAL     <span>PRIMARY</span> <span>KEY</span><span>,</span>
   event_type  <span>VARCHAR</span><span>(</span><span>250</span><span>)</span>  <span>NOT</span> <span>NULL</span><span>,</span>
   <span>data</span>        JSONB         <span>NOT</span> <span>NULL</span>
<span>)</span><span>;</span></code></pre></div>
<p><strong>Let’s start to shape the general API. Our subscription could look like this:</strong></p>
<div data-language="csharp"><pre><code><span>public</span> <span>interface</span> <span>IEventsSubscription</span>
<span>{</span>
    <span>IAsyncEnumerable<span>&lt;</span><span>object</span><span>&gt;</span></span> <span>Subscribe</span><span>(</span><span>EventsSubscriptionOptions</span> options<span>,</span> <span>CancellationToken</span> ct<span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>record</span> <span>EventsSubscriptionOptions</span><span>(</span>
    <span><span>string</span></span> ConnectionString<span>,</span>
    <span><span>string</span></span> SlotName<span>,</span>
    <span><span>string</span></span> PublicationName
<span>)</span><span>;</span></code></pre></div>
<p>We just have a single method that takes the subscription options and <em>CancellationToken</em> to be able to stop the subscription. Subscription returns <em>IAsyncEnumerable</em>, which is a .NET interface for getting the asynchronous stream of notifications. It suits well, the publish-subscribe semantics. We’ll get a stream of messages, as they may have various CLR types, and then we need to use the lowest common denominator: base <em>object</em> class. Subscriptions options are used to pass the connection string to the Postgres database plus slot and publication name to know what we’re subscribing.</p>
<p>Let’s now discuss the details of implementing our <em>Subscribe</em> method. The first thing is to open the connection and get the replication slot. We do that by:</p>
<div data-language="csharp"><pre><code><span>var</span> <span>(</span>connectionString<span>,</span> slotName<span>,</span> publicationName<span>)</span> <span>=</span> options<span>;</span>

<span>await</span> <span>using</span> <span><span>var</span></span> conn <span>=</span> <span>new</span> <span>LogicalReplicationConnection</span><span>(</span>connectionString<span>)</span><span>;</span>
<span>await</span> conn<span>.</span><span>Open</span><span>(</span>ct<span>)</span><span>;</span>

<span><span>var</span></span> slot <span>=</span> <span>new</span> <span>PgOutputReplicationSlot</span><span>(</span>slotName<span>)</span><span>;</span></code></pre></div>
<p><strong>Having that, we can start a subscription:</strong></p>
<div data-language="csharp"><pre><code><span>await</span> <span>foreach</span> <span>(</span><span><span>var</span></span> message <span>in</span> conn<span>.</span><span>StartReplication</span><span>(</span>slot<span>,</span> <span>new</span> <span>PgOutputReplicationOptions</span><span>(</span>publicationName<span>,</span> <span>1</span><span>)</span><span>,</span> ct<span>)</span><span>)</span>
<span>{</span>
    
    
    
    
    conn<span>.</span><span>SetReplicationStatus</span><span>(</span>message<span>.</span>WalEnd<span>)</span><span>;</span>
    
    <span>await</span> conn<span>.</span><span>SendStatusUpdate</span><span>(</span>ct<span>)</span><span>;</span>
<span>}</span></code></pre></div>
<p>We can use an asynchronous <em>foreach</em> loop. It will run infinitely until the connection with Postgres is down, or we cancel the subscription through <em>CancellationToken</em>. It will run for each replication message notification we get from Postgres. <em>pg_output</em> produces <a href="https://github.com/npgsql/npgsql/tree/main/src/Npgsql/Replication/PgOutput/Messages">multiple type of messages</a>. As our outbox table is append-only, let’s focus only on the insert part. Our full class implementation will look as follows:</p>
<div data-language="csharp"><pre><code><span>public</span> <span>class</span> <span>EventsSubscription</span><span>:</span> <span><span>IEventsSubscription</span></span>
<span>{</span>
    <span>public</span> <span>async</span> <span>IAsyncEnumerable<span>&lt;</span><span>object</span><span>&gt;</span></span> <span>Subscribe</span><span>(</span><span>EventsSubscriptionOptions</span> options<span>,</span> <span>[</span><span><span>EnumeratorCancellation</span></span><span>]</span> <span>CancellationToken</span> ct<span>)</span>
    <span>{</span>
        <span>var</span> <span>(</span>connectionString<span>,</span> slotName<span>,</span> publicationName<span>)</span> <span>=</span> options<span>;</span>
        <span>await</span> <span>using</span> <span><span>var</span></span> conn <span>=</span> <span>new</span> <span>LogicalReplicationConnection</span><span>(</span>connectionString<span>)</span><span>;</span>
        <span>await</span> conn<span>.</span><span>Open</span><span>(</span>ct<span>)</span><span>;</span>

        <span><span>var</span></span> slot <span>=</span> <span>new</span> <span>PgOutputReplicationSlot</span><span>(</span>slotName<span>)</span><span>;</span>

        <span>await</span> <span>foreach</span> <span>(</span><span><span>var</span></span> message <span>in</span> conn<span>.</span><span>StartReplication</span><span>(</span>slot<span>,</span> <span>new</span> <span>PgOutputReplicationOptions</span><span>(</span>publicationName<span>,</span> <span>1</span><span>)</span><span>,</span> ct<span>)</span><span>)</span>
        <span>{</span>
            <span>if</span> <span>(</span>message <span>is</span> <span>InsertMessage</span> insertMessage<span>)</span>
            <span>{</span>
                <span>yield</span> <span>return</span> <span>await</span> InsertMessageHandler<span>.</span><span>Handle</span><span>(</span>insertMessage<span>,</span> ct<span>)</span><span>;</span>
            <span>}</span>

            conn<span>.</span><span>SetReplicationStatus</span><span>(</span>message<span>.</span>WalEnd<span>)</span><span>;</span>
            <span>await</span> conn<span>.</span><span>SendStatusUpdate</span><span>(</span>ct<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span></code></pre></div>
<p>We’ll cede the message handling to the dedicated <em>InsertMessageHandler</em>.</p>
<div data-language="csharp"><pre><code><span>public</span> <span>static</span> <span>class</span> <span>InsertMessageHandler</span>
<span>{</span>
    <span>public</span> <span>static</span> <span>async</span> <span>Task<span>&lt;</span><span>object</span><span>&gt;</span></span> <span>Handle</span><span>(</span><span>InsertMessage</span> message<span>,</span> <span>CancellationToken</span> ct<span>)</span>
    <span>{</span>
        <span><span>var</span></span> columnNumber <span>=</span> <span>0</span><span>;</span>
        <span><span>var</span></span> eventTypeName <span>=</span> <span>string</span><span>.</span>Empty<span>;</span>

        <span>await</span> <span>foreach</span> <span>(</span><span><span>var</span></span> <span>value</span> <span>in</span> message<span>.</span>NewRow<span>)</span>
        <span>{</span>
            <span>switch</span> <span>(</span>columnNumber<span>)</span>
            <span>{</span>
                <span>case</span> <span>1</span><span>:</span>
                    eventTypeName <span>=</span> <span>await</span> <span>value</span><span>.</span><span>GetTextReader</span><span>(</span><span>)</span><span>.</span><span>ReadToEndAsync</span><span>(</span><span>)</span><span>;</span>
                    <span>break</span><span>;</span>
                <span>case</span> <span>2</span> <span>when</span> <span>value</span><span>.</span><span>GetDataTypeName</span><span>(</span><span>)</span><span>.</span><span>ToLower</span><span>(</span><span>)</span> <span>==</span> <span>&#34;jsonb&#34;</span><span>:</span>
                <span>{</span>
                    <span><span>var</span></span> eventType <span>=</span> Type<span>.</span><span>GetType</span><span>(</span>eventTypeName<span>)</span><span>;</span>
                    <span>if</span> <span>(</span>eventType <span>is</span> <span>null</span><span>)</span>
                        <span>throw</span> <span>new</span> <span>ArgumentOutOfRangeException</span><span>(</span><span>nameof</span><span>(</span>eventType<span>)</span><span>)</span><span>;</span>

                    <span><span>var</span></span> @<span>event</span> <span>=</span> <span>await</span> JsonSerialization<span>.</span><span>FromJsonAsync</span><span>(</span>eventType<span>,</span> <span>value</span><span>.</span><span>GetStream</span><span>(</span><span>)</span><span>,</span> ct<span>)</span><span>;</span>

                    <span>return</span> @<span>event</span><span>!</span><span>;</span>
                <span>}</span>
            <span>}</span>

            columnNumber<span>++</span><span>;</span>
        <span>}</span>

        <span>throw</span> <span>new</span> <span>InvalidOperationException</span><span>(</span><span>&#34;You should not get here&#34;</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span></code></pre></div>
<p>We’ll need to iterate through all the columns in the insert message. We assume that our subscription will get messages from our standardised outbox table. We need to get the message type from the second column and use it to deserialise the method. We assume that we’ll have the assembly-qualified name of the CLR type (Is it the best technique? In the long term, you may need to think about <a href="https://event-driven.io/en/simple_events_versioning_patterns/">messages versioning</a>, but that’s a different story). Having deserialised the message, we can return it and propagate it to the subscriber.</p>
<div data-language="csharp"><pre><code><span><span>var</span></span> subscriptionOptions <span>=</span> <span>new</span> <span>EventsSubscriptionOptions</span><span>(</span>ConnectrionString<span>,</span> <span>&#34;outbox_slot&#34;</span><span>,</span> <span>&#34;outbox_pub&#34;</span><span>)</span><span>;</span>
<span><span>var</span></span> subscription <span>=</span> <span>new</span> <span>EventsSubscription</span><span>(</span><span>)</span><span>;</span>

<span>await</span> <span>foreach</span> <span>(</span><span><span>var</span></span> readEvent <span>in</span> subscription<span>.</span><span>Subscribe</span><span>(</span>subscriptionOptions<span>,</span> ct<span>)</span><span>)</span>
<span>{</span>
    
    
<span>}</span></code></pre></div>
<p>What to do with the event? You can <a href="https://event-driven.io/en/how_to_build_simple_event_pipeline/">pipe it to in-memory handler</a>, <a href="https://event-driven.io/en/integrating_Marten/">forward it to message bus</a>, in general, do what your imagination and sanity allows you.</p>
<h2 id="summary"><a href="#summary" aria-label="summary permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Summary</h2>
<p><strong>Postgres invests a lot in each release to make logical replication the most robust.</strong> See what they did in <a href="https://www.postgresql.fastware.com/blog/how-postgresql-15-improved-communication-in-logical-replication">just released 15 version</a>. Did I use it on production? Not yet. But I’m planning to.</p>
<p>Some time ago, I did a <a href="https://github.com/oskardudycz/kafka-connect">proof of concept using Debezium to forward events from Marten to Kafka</a>. Now I’d like to step forward.</p>
<p>I started to play with logical replication, and this article summarises my current findings. You can find more in my <a href="https://github.com/oskardudycz/PostgresOutboxPatternWithCDC.NET">GitHub repository</a>. I’d like to provide a simple, focused on, append-only outbox solution for .NET. Then do extensive tests to see if I could make it production-ready. Maybe incorporate that in Marten or generalise it into some tool if that works out.</p>
<p>What are the next steps? I need to check:</p>
<ul>
<li>various scenarios like adding replication to the existing table,</li>
<li>subscriptions and replies,</li>
<li>scenarios around backups and, in general, fault tolerance.</li>
</ul>
<p>That sounds like a decent pet project, so stay tuned; more to come in the future!</p>
<p>Cheers!</p>
<p>Oskar</p>
<p>p.s. <strong>Ukraine is still under brutal Russian invasion. A lot of Ukrainian people are hurt, without shelter and need help.</strong> You can help in various ways, for instance, directly helping refugees, spreading awareness, putting pressure on your local government or companies. You can also support Ukraine by donating e.g. to <a href="https://www.icrc.org/en/donate/ukraine">Red Cross</a>, <a href="https://savelife.in.ua/en/donate/">Ukraine humanitarian organisation</a>. You may also consider joining <a href="https://techtotherescue.org/tech/tech-for-ukraine">Tech for Ukraine</a> initiative.</p></div></div>
  </body>
</html>
