<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gist.github.com/FeepingCreature/5dff669aad380a123b15659e195fb96c">Original</a>
    <h1>Don&#39;t pass structs bigger than 16 bytes on AMD64</h1>
    
    <div id="readability-page-1" class="page"><div>
  <div id="file-sixteen_bytes-md">
      
      <div id="file-sixteen_bytes-md-readme">
    <article itemprop="text">
<p dir="auto">Or &#34;How I sped up <a href="https://neat-lang.github.io" rel="nofollow">Neat</a> by a factor of 2x&#34;.</p>
<hr/>
<p dir="auto">If you check the <a href="https://github.com/jinyus/related_post_gen/">related_post_gen</a> benchmark, you will find that Neat,
my language, has moved up a few spots. How did I achieve this? Did I implement new high-level optimizer
passes that use language details to expose hidden optimization potential?</p>
<p dir="auto">I changed arrays to be passed as three pointer parameters instead of one parameter consisting of a
three-pointer struct. That&#39;s it.</p>
<p dir="auto">This problem has been vexing me for a long time. Neat seemed weirdly slower than it should have been,
particularly compared to D, and if I looked at a profiler I would be seeing a lot of weird stack moves.
The compiler seemed to be spending most of its time rearranging large amounts of the stack for function calls.</p>
<p dir="auto">Why are Neat arrays three pointers? As opposed to D, Neat employs a refcounter. That means that arrays, in addition
to start and end, also need a pointer to the base of the array object, where the reference count is stored.
It turns out the reason that D arrays are fast and Neat arrays are so slow is just because having 24 bytes instead of
16 puts them into a different regime of parameter passing.</p>
<p dir="auto">If we check <a href="https://refspecs.linuxbase.org/elf/x86_64-abi-0.99.pdf" rel="nofollow">the SystemV AMD64 ABI specification</a> (PDF),
it tells us that any struct greater than 16 bytes is passed by pointer.
(&#34;If the size of the aggregate exceeds two eightbytes and the first eightbyte isn’t SSE or any other
eightbyte isn’t SSEUP, the whole argument is passed in memory.&#34;)
To pass a struct by memory, we allocate a struct-sized spot on the stack, fill it with the values we pass, then
pass the pointer to the function.</p>
<p dir="auto">Now, LLVM is a very good optimizer, but this does not leave it much room. The value <em>has</em> to go on the stack, which
means there must be space for it there, it must be copied out of the register it is probably living in, and
it has to remember which parts of the stack are in use and which ones can be reused by another call, which it turns
out to be pretty poor at.</p>
<p dir="auto">We can demonstrate the issue with this benchmark:</p>
<pre><code>==========
harness.h:
==========

#define TYPE double

struct Vector { TYPE x, y, z; };

struct Vector vector_add_struct(struct Vector left, struct Vector right);

struct Vector vector_add_fields(
    TYPE left_x, TYPE left_y, TYPE left_z,
    TYPE right_x, TYPE right_y, TYPE right_z);

==========
harness.c:
==========

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &#34;harness.h&#34;

int main(int argc, const char *argv[])
{
    int mode = atoi(argv[1]);
    int length = atoi(argv[2]);
    struct Vector result = {0};
    if (mode == 0)
    {
        for (int i = 0; i &lt; length; i++)
            result = vector_add_struct(result, (struct Vector) {i, i, i});
    }
    else
    {
        for (int i = 0; i &lt; length; i++)
            result = vector_add_fields(result.x, result.y, result.z, i, i, i);
    }
    printf(&#34;result &lt;%f, %f, %f&gt;\n&#34;, result.x, result.y, result.z);
}

=======
impl.c:
=======

#include &#34;harness.h&#34;

struct Vector vector_add_struct(struct Vector left, struct Vector right)
{
    return (struct Vector) {
        left.x + right.x,
        left.y + right.y,
        left.z + right.z,
    };
}

struct Vector vector_add_fields(
    TYPE left_x, TYPE left_y, TYPE left_z,
    TYPE right_x, TYPE right_y, TYPE right_z)
{
    return (struct Vector) {
        left_x + right_x,
        left_y + right_y,
        left_z + right_z,
    };
}
</code></pre>
<p dir="auto">As you can see, depending on parameters, this either passes some values as separate parameters or a single large struct.
The mode and run length are passed on the commandline to prevent the optimizer from constant folding everything.</p>
<p dir="auto">We must compile impl.c separately to avoid inlining:</p>
<pre><code>clang -O3 impl.c -c -o impl.o
clang -O3 harness.c impl.o -o benchmark
time ./benchmark 0 1000000000
time ./benchmark 1 1000000000
</code></pre>
<p dir="auto">This is hardly subtle: with just the change of passing three separate fields instead of a vector struct, I go
from 12.3 seconds to 5.3 seconds!</p>
<p dir="auto">If we check the assembly, we can indeed see that a lot of instructions are occupied with stack shuffles.
In fact, a major benefit of the field version is that the parameters already enter the function in SSE registers, rather
than having to be loaded from the stack every time. This was the whole point of the SystemV ABI and its focus on
passing values in registers as much as possible, so it&#39;s kind of sad to see it fail here. I believe with the number of
registers available on AMD64, a benchmark would have shown by-value passing to be valuable even for types above 16 bytes.</p>
<p dir="auto">In fact, if you think about what the code does, by writing the fields on the stack and then (explicitly rather than
implicitly) passing a pointer, the (new, performant) AMD64 System V ABI has effectively regressed to the old x86 cdecl
ABI, where everything was passed on the stack! Cdecl, famously, was so known for its slowness that it spawned multiple
calling conventions aimed just at making it fast.</p>
<p dir="auto">Of course, in any real situation this code would be all inlined. In fact, turning on LTO with gcc (though interestingly
not clang!) erases any performance difference between the two versions. But still, not every function can or
should be inlined.</p>
<p dir="auto">Now, if you are calling a C API, you have to use the C ABI. But lots of high-level types internal to non-C languages,
though they may be presented to the compiler&#39;s backend as a struct (such as Neat&#39;s three-pointer arrays), don&#39;t strictly
speaking <em>need</em> to be expressed as one. You are the language writer, and it&#39;s up to you to decide how arrays,
tuples, sumtypes etc. are passed. That&#39;s why I chose to pass all of those (if above 16 bytes) as individual fields instead,
and the benchmark shows the benefit.</p>
<p dir="auto">So if you are on AMD64, and you&#39;re either working on languages or microoptimizing an API, I advise you to take
the free speedup. You should at least benchmark to see if you can benefit from splitting structs above 16 bytes manually.
Especially in inner loops, the benefit can be surprisingly large.</p>
<p dir="auto">Addendum:</p>
<ul dir="auto">
<li>Q: Sure, maybe this is true for structs of pointers. But <code>double</code> is in class SSE, according to the spec.
Why isn&#39;t the struct passed in SSE registers anyways?</li>
<li>A: Man I don&#39;t know. All I can tell you is that it doesn&#39;t.</li>
</ul>
</article>
  </div>

  </div>
</div></div>
  </body>
</html>
