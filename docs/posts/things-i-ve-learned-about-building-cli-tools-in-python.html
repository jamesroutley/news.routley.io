<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://simonwillison.net/2023/Sep/30/cli-tools-python/">Original</a>
    <h1>Things I&#39;ve learned about building CLI tools in Python</h1>
    
    <div id="readability-page-1" class="page"><div>



<p>30th September 2023</p>

<p>I build a lot of command-line tools in Python. It’s become my favorite way of quickly turning a piece of code into something I can use myself and package up for other people to use too.</p>
<p>My biggest CLI  projects are <a href="https://sqlite-utils.datasette.io/">sqlite-utils</a>, <a href="https://llm.datasette.io/">LLM</a>, <a href="https://shot-scraper.datasette.io/en/stable/">shot-scraper</a> and <a href="https://datasette.io/">Datasette</a>—but I have dozens of others and I build new ones at the rate of at least one a month. A fun recent example is <a href="https://github.com/simonw/blip-caption">blip-caption</a>, a tiny CLI wrapper around the Salesforce BLIP model that can generate usable captions for image files.</p>
<p>Here are some notes on what I’ve learned about designing and implementing CLI tools in Python so far.</p>
<h4 id="starting-with-a-template">Starting with a template</h4>
<p>I build enough CLI apps that I developed my own <a href="https://github.com/cookiecutter/cookiecutter">Cookiecutter</a> template for starting new ones.</p>
<p>That template is <a href="https://github.com/simonw/click-app">simonw/click-app</a>. You can create a new application from that template directly on GitHub, too—I wrote more about that in <a href="https://simonwillison.net/2021/Aug/28/dynamic-github-repository-templates/">Dynamic content for GitHub repository templates using cookiecutter and GitHub Actions</a>.</p>
<h4 id="arguments-options-and-conventions">Arguments, options and conventions</h4>
<p>Almost all of my tools are built using the <a href="https://click.palletsprojects.com/">Click</a> Python library. Click encourages a specific way of designing CLI tools which I really like—I find myself annoyed at the various tools from other ecosystems that don’t stick to the conventions that Click encourages.</p>
<p>I’ll try to summarize those conventions here.</p>
<ul>
<li>Commands have arguments and options. Arguments are positional—they are strings that you pass directly to the command, like <code>data.db</code> in <code>datasette data.db</code>. Arguments can be required or optional, and you can have commands which accept an unlimited number of arguments.</li>
<li>Options are, usually, optional. They are things like <code>--port 8000</code>. Options can also have a single character shortened version, such as <code>-p 8000</code>.
<ul>
<li>Very occasionally I’ll create an option that is required, usually because a command has so many positional arguments that forcing an option makes its usage easier to read.</li>
</ul>
</li>
<li>Some options are flags—they don’t take any additional parameters, they just switch something on. <code>shot-scraper --retina</code> is an example of this.</li>
<li>Flags with single character shortcuts can be easily combined—<code>symbex -in fetch_data</code> is short for <code>symbex --imports --no-file fetch_data</code> <a href="https://github.com/simonw/symbex/blob/1.4/README.md#usage">for example</a>.</li>
<li>Some options take multiple parameters. <code>datasette --setting sql_time_limit_ms 10000</code> is an example, taking both the name of the setting and the value it should be set to.</li>
<li>Commands can have sub-commands, each with their own family of commands. <a href="https://llm.datasette.io/en/stable/templates.html">llm templates</a> is an example of this, with <code>llm templates list</code> and <code>llm templates show</code> and <a href="https://llm.datasette.io/en/stable/help.html#llm-templates-help">several more</a>.</li>
<li>Every command should have help text—the more detailed the better. This can be viewed by running <code>llm --help</code>—or for sub-commands, <code>llm templates --help</code>.</li>
</ul>
<p>Click makes it absurdly easy and productive to build CLI tools that follow these conventions.</p>
<h4 id="consistency-is-everything">Consistency is everything</h4>
<p>As CLI utilities get larger, they can end up with a growing number of commands and options.</p>
<p>The most important thing in designing these is <em>consistency</em> with other existing commands and options (<a href="https://github.com/simonw/llm/issues/160#issuecomment-1682995315">example here</a>)—and with related tools that your user may have used before.</p>
<p>I often turn to GPT-4 for help with this: I’ll ask it for examples of existing CLI tools that do something similar to what I’m about to build, and see if there’s anything in their option design that I can emulate.</p>
<p>Since my various projects are designed to complement each other I try to stay consistent between them as well—I’ll often post an issue comment that says “similar to functionality in X”, with a copy of the <code>--help</code> output for the tool I’m about to imitate.</p>
<h4 id="cli-interfaces-are-an-api---version-appropriately">CLI interfaces are an API—version appropriately</h4>
<p>I try to stick to <a href="https://semver.org/">semantic versioning</a> for my projects, bumping the major version number on breaking changes and the minor version number for new features.</p>
<p>The command-line interface to a tool is absolutely part of that documented API. If someone writes a Bash script or a GitHub Actions automation that uses one of my tools, I’m cautious to avoid breaking that without bumping my major version number.</p>
<h4 id="include-usage-examples-in---help">Include usage examples in --help</h4>
<p>A habit I’ve formed more recently is trying to always including a working example of the command in the <code>--help</code> for that command.</p>
<p>I find I use this a lot for tools I’ve developed myself. All of my tools have extensive online documentation, but I like to be able to consult <code>--help</code> without opening a browser for most of their functionality.</p>
<p>Here’s one of my more involved examples—the help for the <a href="https://sqlite-utils.datasette.io/en/stable/cli.html#converting-data-in-columns">sqlite-utils convert</a> command:</p>
<pre><code>Usage: sqlite-utils convert [OPTIONS] DB_PATH TABLE COLUMNS... CODE

  Convert columns using Python code you supply. For example:

      sqlite-utils convert my.db mytable mycolumn \
          &#39;&#34;\n&#34;.join(textwrap.wrap(value, 10))&#39; \
          --import=textwrap

  &#34;value&#34; is a variable with the column value to be converted.

  Use &#34;-&#34; for CODE to read Python code from standard input.

  The following common operations are available as recipe functions:

  r.jsonsplit(value, delimiter=&#39;,&#39;, type=&lt;class &#39;str&#39;&gt;)

      Convert a string like a,b,c into a JSON array [&#34;a&#34;, &#34;b&#34;, &#34;c&#34;]

  r.parsedate(value, dayfirst=False, yearfirst=False, errors=None)

      Parse a date and convert it to ISO date format: yyyy-mm-dd
      
      - dayfirst=True: treat xx as the day in xx/yy/zz
      - yearfirst=True: treat xx as the year in xx/yy/zz
      - errors=r.IGNORE to ignore values that cannot be parsed
      - errors=r.SET_NULL to set values that cannot be parsed to null

  r.parsedatetime(value, dayfirst=False, yearfirst=False, errors=None)

      Parse a datetime and convert it to ISO datetime format: yyyy-mm-ddTHH:MM:SS
      
      - dayfirst=True: treat xx as the day in xx/yy/zz
      - yearfirst=True: treat xx as the year in xx/yy/zz
      - errors=r.IGNORE to ignore values that cannot be parsed
      - errors=r.SET_NULL to set values that cannot be parsed to null

  You can use these recipes like so:

      sqlite-utils convert my.db mytable mycolumn \
          &#39;r.jsonsplit(value, delimiter=&#34;:&#34;)&#39;

Options:
  --import TEXT                   Python modules to import
  --dry-run                       Show results of running this against first
                                  10 rows
  --multi                         Populate columns for keys in returned
                                  dictionary
  --where TEXT                    Optional where clause
  -p, --param &lt;TEXT TEXT&gt;...      Named :parameters for where clause
  --output TEXT                   Optional separate column to populate with
                                  the output
  --output-type [integer|float|blob|text]
                                  Column type to use for the output column
  --drop                          Drop original column afterwards
  --no-skip-false                 Don&#39;t skip falsey values
  -s, --silent                    Don&#39;t show a progress bar
  --pdb                           Open pdb debugger on first error
  -h, --help                      Show this message and exit.
</code></pre>
<h4 id="including---help-in-the-online-documentation">Including --help in the online documentation</h4>
<p>My larger tools tend to have extensive documentation independently of their help output. I update this documentation at the same time as the implementation and the tests, as described in <a href="https://simonwillison.net/2022/Oct/29/the-perfect-commit/">The Perfect Commit</a>.</p>
<p>I like to include the <code>--help</code> output in my documentation sites as well. This is mainly for my own purposes—having the help visible on a web page makes it much easier to review it and spot anything that needs updating.</p>
<p>Here are some example pages from my documentation that list <code>--help</code> output:</p>
<ul>
<li><a href="https://sqlite-utils.datasette.io/en/stable/cli-reference.html">sqlite-utils CLI reference</a></li>
<li><a href="https://llm.datasette.io/en/stable/help.html">LLM CLI reference</a></li>
<li><a href="https://docs.datasette.io/en/stable/cli-reference.html">Datasette CLI reference</a></li>
<li>
<code>shot-scraper</code> embeds help output on the relevant pages, e.g. <a href="https://shot-scraper.datasette.io/en/stable/screenshots.html#shot-scraper-shot-help">shot-scraper shot --help</a>
</li>
<li><a href="https://s3-credentials.readthedocs.io/en/stable/help.html">s3-credentials command help</a></li>
</ul>
<p>All of these pages are maintained automatically using <a href="https://github.com/nedbat/cog">Cog</a>. I described the pattern I use for this in <a href="https://til.simonwillison.net/python/cog-to-update-help-in-readme">Using cog to update --help in a Markdown README file</a>, or you can <a href="https://github.com/simonw/datasette/blob/1.0a7/docs/cli-reference.rst">view source</a> on the Datasette CLI reference for a more involved example.</p>




</div></div>
  </body>
</html>
