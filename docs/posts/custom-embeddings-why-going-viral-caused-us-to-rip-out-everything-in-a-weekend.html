<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.buildt.ai/blog/viral-ripout">Original</a>
    <h1>Custom Embeddings: Why going viral caused us to rip out everything in a weekend</h1>
    
    <div id="readability-page-1" class="page"><div id="page" role="main">
        
          
<article id="sections" data-page-sections="63daf57772bc814cc05cac92">
  
  
    
    


  


<section data-test="page-section" data-section-theme="" data-section-id="63daf57772bc814cc05cac94" data-controller="SectionWrapperController" data-current-styles="{
&#34;imageOverlayOpacity&#34;: 0.15,
&#34;backgroundWidth&#34;: &#34;background-width--full-bleed&#34;,
&#34;sectionHeight&#34;: &#34;section-height--medium&#34;,
&#34;horizontalAlignment&#34;: &#34;horizontal-alignment--center&#34;,
&#34;verticalAlignment&#34;: &#34;vertical-alignment--middle&#34;,
&#34;contentWidth&#34;: &#34;content-width--wide&#34;,
&#34;sectionAnimation&#34;: &#34;none&#34;,
&#34;backgroundMode&#34;: &#34;image&#34;
}" data-current-context="{
&#34;video&#34;: {
&#34;playbackSpeed&#34;: 0.5,
&#34;filter&#34;: 1,
&#34;filterStrength&#34;: 0,
&#34;zoom&#34;: 0,
&#34;videoSourceProvider&#34;: &#34;none&#34;
},
&#34;backgroundImageId&#34;: null,
&#34;backgroundMediaEffect&#34;: null,
&#34;divider&#34;: null,
&#34;typeName&#34;: &#34;blog-basic-grid&#34;
}" data-animation="none">
  
  <div>
    <div>
      
      
      
      
      
      
      <div data-content-field="main-content" data-item-id="">
  <article id="article-">
  
    <div>
      

      <div>
        <div><div data-layout-label="Post Body" data-type="item" id="item-63f6a6b28ac9814c501fd71f"><div><div><div data-block-type="2" id="block-22ccc2484a38d6be67fe"><p>Before I share my learnings I need to give a little preamble to set the scene; A few weeks ago we launched the V1 of our product, and it both did and didn’t go according to plan. We were lucky enough to recieve a great deal of exposure on Twitter and signups were flying in - the issue was two fold, our backend architecture was still very much in the ‘do things that don’t scale’ phase, and the general design of our product was incredibly inefficient. This early stress test highlighted that our current solution wouldn’t scale at all, and worst of all it’d be cripplingly expensive if we were to grow any further. We also had an office hours that week, where one of our group partners Tom Blomfield gave us the sage advice of stopping the onboarding of customers who were going to have a bad experience, as getting them to come back would be very tricky - we did this and it was good advice, I think we’d have disappointed a lot more people had we ignored it.</p></div><div data-block-type="5" id="block-yui_3_17_2_1_1677108916547_2612"><div>
































  

    
  
    <div data-test="image-block-inline-outer-wrapper">

      

      
        <figure>
          
        
        

        
          
            
          <div data-animation-role="image">
            <p><img data-src="https://images.squarespace-cdn.com/content/v1/63dac39a0ea2353d0e132a36/0f66d2cd-3dac-43c9-beee-73291f336f65/search%2Bexplain+%281%29+%281%29.gif" data-image="https://images.squarespace-cdn.com/content/v1/63dac39a0ea2353d0e132a36/0f66d2cd-3dac-43c9-beee-73291f336f65/search%2Bexplain+%281%29+%281%29.gif" data-image-dimensions="451x365" data-image-focal-point="0.5,0.5" alt="" data-load="false" data-image-id="63f6a71f12f2333934cdcb39" data-type="image"/>
                
            </p>
          </div>
        
          
        

        
      
        </figure>
      

    </div>
  


  


</div></div><div data-block-type="2" id="block-yui_3_17_2_1_1677108916547_3546"><p>The source of this bank-breaking cost was the core of our product – our core functionality has always been allowing you to ‘search for what your code does, not what it is’, enabling queries like ‘Find where we initialize Stripe in React and add some logging’ which would never have been possible using existing search solutions. Our approach to solving this problem was to both index your entire codebase (something you have to do whatever your approach is) but to also pass each snippet we index into an LLM, and use that LLM to describe the code, then embedding that description. This gives you the ‘what the code does’ functionality. However, it turns out that this approach is a sure-fire way to burn through thousands of dollars worth of tokens and stay pinned to your rate limit.</p></div><div data-block-type="5" id="block-yui_3_17_2_1_1677108916547_3923"><div>
































  

    
  
    <div data-test="image-block-inline-outer-wrapper">

      

      
        <figure>
          
        
        

        
          
            
          <div data-animation-role="image">
            <p><img data-src="https://images.squarespace-cdn.com/content/v1/63dac39a0ea2353d0e132a36/ec5df180-d30b-4a9d-a167-04a4c4dd0b51/Screenshot+2023-02-22+at+14.30.44.png" data-image="https://images.squarespace-cdn.com/content/v1/63dac39a0ea2353d0e132a36/ec5df180-d30b-4a9d-a167-04a4c4dd0b51/Screenshot+2023-02-22+at+14.30.44.png" data-image-dimensions="2092x112" data-image-focal-point="0.5,0.5" alt="" data-load="false" data-image-id="63f6a759676a671b87731f8d" data-type="image"/>
                
            </p>
          </div>
        
          
        

        
      
        </figure>
      

    </div>
  


  


</div></div><div data-block-type="2" id="block-yui_3_17_2_1_1677186390670_6387"><p><span data-text-attribute-id="fe04dc2b-0bb0-4bff-9574-45fa1f40eae4"><em>At our peak we were processing nearly a quarter of a billion tokens per day</em></span></p></div><div data-block-type="2" id="block-yui_3_17_2_1_1677108916547_4847"><div>

<p>We considered trying to use a self-hosted LLM as an alternative, but the costs would also have been extremely high for the amount of traffic we were processing. After inspection, the token/cost breakdown between the models we were using pointed that the idea of having an LLM in the loop simply wasn’t feasible (it may well be in the future, but in the current incarnation of these LLMs, it isn’t). This meant we were at a crossroads, everything our product was predicated on was no longer viable so we had to figure out a way to get the same functionality, but without an LLM.</p><h3>Our Solution</h3><p>This solution isn’t groundbreaking, in fact it’s freely available on OpenAI’s cookbook, but I think it flies under the radar and I also think we had an interesting approach to it. The approach involves the creation of a custom matrix which you multiply all of your embeddings by to bias them to your usecase. The idea is that you can take extreme examples of both positive and negative classifications and ensure that your answers are better separated into those classifications.</p><p>For example this is a graph of unoptimised embeddings for our usecase plotting cosine similarity: the red bars depict answers where the two vectors compared should be dissimilar/have a low cosine similarity, and the blue are pairs which should have a similarity value. As you can tell there is a huge amount of overlap which essentially equates to false-positives; instances where you are looking for one outcome but get the opposite.</p>


</div></div><div data-block-type="5" id="block-yui_3_17_2_1_1677108916547_5260"><div>
































  

    
  
    <div data-test="image-block-inline-outer-wrapper">

      

      
        <figure>
          
        
        

        
          
            
          <div data-animation-role="image">
            <p><img data-src="https://images.squarespace-cdn.com/content/v1/63dac39a0ea2353d0e132a36/b954ffc2-7715-4452-86a6-1a7aaf5efe19/Screenshot+2023-02-22+at+14.47.31.png" data-image="https://images.squarespace-cdn.com/content/v1/63dac39a0ea2353d0e132a36/b954ffc2-7715-4452-86a6-1a7aaf5efe19/Screenshot+2023-02-22+at+14.47.31.png" data-image-dimensions="588x380" data-image-focal-point="0.5,0.5" alt="" data-load="false" data-image-id="63f6a78aec5464052496b7bf" data-type="image"/>
                
            </p>
          </div>
        
          
        

        
      
        </figure>
      

    </div>
  


  


</div></div><div data-block-type="2" id="block-yui_3_17_2_1_1677108916547_6189"><p>After performing some training on examples and creating a bias matrix that we multiply all of our embeddings by we get this output:</p></div><div data-block-type="5" id="block-yui_3_17_2_1_1677108916547_6570"><div>
































  

    
  
    <div data-test="image-block-inline-outer-wrapper">

      

      
        <figure>
          
        
        

        
          
            
          <div data-animation-role="image">
            <p><img data-src="https://images.squarespace-cdn.com/content/v1/63dac39a0ea2353d0e132a36/7ae480fc-e2c8-4e55-9dd4-bb15f14e2ddf/Screenshot+2023-02-22+at+14.51.47.png" data-image="https://images.squarespace-cdn.com/content/v1/63dac39a0ea2353d0e132a36/7ae480fc-e2c8-4e55-9dd4-bb15f14e2ddf/Screenshot+2023-02-22+at+14.51.47.png" data-image-dimensions="578x314" data-image-focal-point="0.5,0.5" alt="" data-load="false" data-image-id="63f6a7a99398227cbb7f02ff" data-type="image"/>
                
            </p>
          </div>
        
          
        

        
      
        </figure>
      

    </div>
  


  


</div></div><div data-block-type="2" id="block-yui_3_17_2_1_1677108916547_7517"><div>

<p>As you can see, the over lap has been drasitcally reduced, so the chances of you successfully matching an answer that is relevant are drastically higher.</p><p>Our implementation of this was interesting, because obviously we needed to essentially bias the embeddings to be able to interpret what the code was doing, so that if someone was looking for that functionality the bias would allow us to better find them, despite not having the LLM in the loop. To that end we did the following: gathered a corpus of open-source code snippets from Github, and then got an LLM to label them - in this isntance the labelling involved generating synthetic user queries which would map to each snippet, these queries had to be very varied both in syntax, grammar, and type of search. Once we had these snippets-query pairs, we passed them into the <code>customize_embeddings</code> notebook from OpenAI’s Github repo and trained the model. The results were far higher than I’d anticipated, with ~90% accuracy compared to the 61% we were achieving before hand. Using this solution the embeddings are now doing the job that the LLM was doing prior, but at no additional cost whatsoever – you still use the same embeddings API as before, you just perform a matrix multiplication on the embedding once you get it back from the API, then it’s biased to your usecase.</p><h3>Some Tips</h3><ul data-rte-list="default"><li><p>In the cookbook example the notebook generates synthetic negatives of your data, i.e. the example pairs that shouldn’t match - it assumes that all of the pairs you input do match. The synthetics are generated by randomly pairing one half of a positive input pair with another pair, and assuming that the output will be dissimilar. The issue with this approach is that there may well be crossover between those randomly chosen input pairs, e.g. for us it might pair a synthetic question asking ‘where is the networking code’ with a code snippet form another pair which involves networking, but lables it as negative anyway. If you let these through you’ll still get a decent amount of false positives so it’s worth bearing in mind. We solved it by performing a cosine similarity on the random pair that was generated and ensuring that it was low, and assuming that it would be enough to ensure they weren’t that similar - it had a good effect.</p></li><li><p>On larger datasets run the training in Google Colab with a GPU - you can use an A100 and it speeds up the training process immensely.</p></li></ul><p>I’m always happy to chat about this subject, you can find me on Twitter @AlistairPullen and all of what I’ve described above is in our code search tool Buildt which is available on the VSCode extension marketplace <a href="https://marketplace.visualstudio.com/items?itemName=BuildtAI.buildt-vscode">here</a></p>


</div></div></div></div></div></div>

        

        
        
          
        
      </div>

      
    </div>
  
</article>

</div>
    </div>
  </div>
  
  
</section>

  
</article>


          

          
            
              

            
          
        
      </div></div>
  </body>
</html>
