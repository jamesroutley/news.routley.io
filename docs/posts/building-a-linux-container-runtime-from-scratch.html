<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://edera.dev/stories/styrolite">Original</a>
    <h1>Building a Linux Container Runtime from Scratch</h1>
    
    <div id="readability-page-1" class="page"><div><div><h2>Why build a new low-level container runtime?</h2><p>The idea of separating the low-level container runtime concerns into its own tool or microservice is not new. Outside of the Kubernetes CRI, which presents container lifecycle management as a pluggable microservice, there are simpler tools which provide a low-level container runtime as well, such as the unshare utility in util-linux, as well as another tool called Bubblewrap.</p><p>But these tools are either too high-level (like the Kubernetes CRI), or they are designed to be used via shell scripting: Bubblewrap has a high amount of configurability, but is only accessible via a very complicated CLI that is easy to get wrong, while util-linux’s unshare has basic functionality, but also locked behind a CLI. While CLIs allow for rapid iteration, we needed something different for Edera Protect: a rich programmatic interface for spawning and managing containers with precision. Styrolite provides the best of both worlds—a clean API directly usable from Rust, while preserving the rapid iteration capabilities of a CLI.</p><h2>How Styrolite Works: Linux Containers Under the Hood</h2><p>Importantly, we designed Styrolite with full awareness that Linux namespaces were never intended as hard security boundaries—a fact that explains why container escape vulnerabilities continue to emerge. Our approach acknowledges these limitations while providing a more robust foundation.</p><p>Containers in Linux – as opposed to <a href="https://docs.freebsd.org/en/books/handbook/jails/">other</a> <a href="https://illumos.org/man/7/zones">containerization</a> <a href="https://openvz.org/">efforts</a> <a href="http://linux-vserver.org/Welcome_to_Linux-VServer.org">elsewhere</a> – are built on <a href="https://man7.org/linux/man-pages/man7/namespaces.7.html">Linux namespaces</a>. A namespace in Linux allows for an alternative view of a given type of resource, for example: the mount namespace allows for an alternative view of the mount table, and thus an alternative view of the root filesystem, while the PID namespace allows for an alternative view of the system process set. Container runtimes compose these namespaces to provide containerized environments, allowing for great flexibility at the cost of higher complexity.</p><p>At the root of all container runtimes is the <a href="https://man7.org/linux/man-pages/man2/unshare.2.html">Linux unshare(2) syscall</a>.  This allows for a currently running process to dissociate from one or more of its current namespaces into a forked version of the namespace that can be modified.  In general, container runtimes unshare most namespaces by default because it is necessary to do:</p><ul role="list"><li>Mount namespaces are unshared from the host so that we can pivot into a modifiable copy of a container image as the container’s root filesystem.</li><li>PID namespaces are unshared from the host so that the containerized workload cannot view processes outside of the container.</li><li>IPC namespaces are unshared from the host so that the containerized workload cannot view or manipulate System V IPC resources unrelated to the containerized workload.</li><li>User namespaces are unshared from the host so that UIDs and GIDs inside the container are remapped to safer UIDs and GIDs in the host namespace.  In other words, root inside a container when running in a user namespace is usually running as an unprivileged UID outside the container environment.</li><li>Time namespaces may be unshared from the host to modify the visible system uptime.</li><li>UTS namespaces may be unshared from the host to change the visible system hostname.</li><li>Network namespaces may be unshared from the host to force the containerized workload to use an alternate networking path.</li></ul><p>On the Edera Protect platform, all of these namespaces are unshared at different levels in the stack.  Styrolite when used inside the Edera Protect platform is primarily responsible for dealing with the Mount, PID, IPC, User, Time and UTS namespaces, while networking is handled elsewhere in the platform.</p><h2>Simple, Programmatic Interface</h2><p>Here&#39;s a glimpse of how Styrolite simplifies container creation compared to traditional approaches:</p><pre contenteditable="false"><code><span>// Create a basic container with Styrolite</span><span>
</span><span></span><span>let</span><span> mut request = CreateRequestBuilder::</span><span>new</span><span>()
</span><span>    .with_rootfs(</span><span>&#34;/path/to/container/rootfs&#34;</span><span>)
</span>    .set_executable(“/bin/sh”)
    .set_arguments(vec![“-i”])
    .set_working_directory(“/”)
    .push_namespace(Namespace::User)
    .push_namespace(Namespace::Mount)
    .push_namespace(Namespace::Pid)
    .to_request();

<span></span><span>// Launch a process in the container</span><span>
</span><span></span><span>let</span><span> runner = Runner::</span><span>new</span><span>(“styrolite”);
</span>runner.run(request)?;</code></pre><p>This clean interface makes container creation and management more maintainable and less error-prone than complex CLI commands or shell scripts.</p><h2>Real-World Applications</h2><p>Styrolite powers several important use cases:</p><ul role="list"><li><strong>Secure microservices:</strong> Within Edera Protect, Styrolite enables fine-grained container isolation for security-critical workloads</li><li><strong>Application sandboxing</strong>: Our companion tool, styrojail, helps Linux users limit resource consumption and improve security for applications like web browsers that process untrusted input</li><li><strong>Custom CI/CD environments: </strong>Developers can use Styrolite to create isolated build environments with precise resource controls</li></ul><h2>Performance and Security</h2><p>Styrolite is designed with minimal overhead, providing container initialization times comparable to or faster than traditional CLI approaches while offering stronger programmatic guarantees about container state.</p><p>Our security-first design acknowledges the inherent limitations of Linux namespaces while providing a more robust foundation through careful defaults and explicit security controls.</p><h2>Join the Community</h2><p>When we decided to build a low-level containerization tool for our own use in Edera Protect, we immediately knew it would have other benefits to the greater OSS community. We welcome contributions from the community:</p><ul role="list"><li>Star and fork the project on <a href="https://github.com/edera-dev/styrolite">GitHub</a></li><li>Try out Styrojail for application sandboxing</li><li>Report issues or suggest improvements</li><li>Contribute code or documentation</li></ul><p>We&#39;re committed to Styrolite&#39;s continued development and look forward to seeing how the community builds with it!</p></div></div></div>
  </body>
</html>
