<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.redplanetlabs.com/2024/01/09/everything-wrong-with-databases-and-why-their-complexity-is-now-unnecessary/">Original</a>
    <h1>Databases and why their complexity is now unnecessary</h1>
    
    <div id="readability-page-1" class="page"><article id="post-1576">
	<!-- .entry-header -->

	<div>
		




<div><p>This post is not going to be about what’s wrong with individual databases. There are so many databases and so many individual API issues, operational problems, and arbitrary limitations that it would be take forever to cover all of them. This post is about what’s wrong with databases as a collection. It’s about what’s wrong with databases as they exist today conceptually and have existed for decades.</p>
<p>Of course, something can only be wrong if there’s a different, better way to do things. There is, and we’ll get to that too.</p>
</div>



<h2 id="Global_mutable_state_is_harmful">Global mutable state is harmful</h2>



<div><p>Every programmer learns early on to minimize the use of state in global variables. They do have the occasional legitimate use, but as a general rule they lead to tangled code that’s difficult to reason about.</p>
<p>Databases are global mutable state too. They’re actually even worse than global variables since interactions are frequently spread across multiple systems, making it even harder to reason about. Also, they’re durable. So if a mistake is made that corrupts the database, that corruption doesn’t get fixed by just fixing the bug. You have to manually figure out what got corrupted and fix it. In a lot of cases it’s impossible to figure out exactly what got corrupted, and you may not have enough information to correct the corruption perfectly. Your best option in these cases is to either revert to a backup or merge in partial data from a backup, neither of which are optimal.</p>
<p>Most programmers simultaneously believe global mutable state in variables is harmful while also believing global mutable state in a database is fine, even though they share most of the same issues.</p>
<p>The better approach, as we’ll get to later in this post, is <a href="https://martinfowler.com/eaaDev/EventSourcing.html">event sourcing</a> plus <a href="https://en.wikipedia.org/wiki/Materialized_view">materialized views</a>. There are many ways to go about applying that pattern, and it’s important to do so in a way that doesn’t create other complexities or performance regressions.</p>
</div>



<h2 id="Data_models_are_restrictive">Data models are restrictive</h2>



<div><p>Databases revolve around a “data model”, like “key/value”, “document”, “relational”, “column-oriented”, or “graph”. A database’s data model is how it indexes data, and a database exposes an API oriented around the kinds of queries that data model can efficiently support.</p>
<p>No single data model can support all use cases. This is a major reason why so many different databases exist with differing data models. So it’s common for companies to use multiple databases in order to handle their varying use cases.</p>
<p>There’a a better abstraction for specifying indexes, and it’s one that every programmer is already familiar with: data structures. Every data model is actually just a particular combination of data structures. For example:</p>
<ul>
<li><strong>Key/value</strong>: map</li>
<li><strong>Document</strong>: map of maps</li>
<li><strong>Relational</strong>: map of maps, with secondary indexes being additional maps</li>
<li><strong>Column-oriented</strong>: Map of sorted maps</li>
</ul>
<p>Data structures can be of huge size by being durable on disk, just like data models. This includes nested data structures. Read and write operations on durable data structures can be just as efficient as the corresponding operations on data models. If you can specify your indexes in terms of the simpler primitive of data structures, then your datastore can express any data model. Additionally, it can express <strong>infinite</strong> more by composing data structures in different ways.</p>
<p>Because only a tiny percentage of the possible data models are available in databases (since each database implements just one particular data model) it’s incredibly common for a database to not match an application’s needs perfectly. It’s extremely expensive to build a new database from scratch, so programmers frequently twist their domain model to fit the available databases. This creates complexity at the very base of an application. If you could instead mold your datastore to fit your domain model, by specifying the “shape” (data structures) precisely, this complexity goes away.</p>
<p>Specifying indexes in terms of data structures rather than data models is a big part of the approach to backend development we’ll look at later in this post.</p>
</div>



<h2 id="Normalization_versus_denormalization_problem">Normalization versus denormalization problem</h2>



<div><p>Every programmer using relational databases eventually runs into the normalization versus denormalization problem. It’s desirable to store data as <a href="https://en.wikipedia.org/wiki/Database_normalization#Normal_forms">normalized</a> as possible to have a clear source of truth and eliminate any possibility of inconsistency. However, storing data normalized can increase the work to perform queries by requiring more joins. Oftentimes, that extra work is so much you’re forced to <a href="https://en.wikipedia.org/wiki/Denormalization">denormalize</a> the database to improve performance.</p>
<p>Storing the same information multiple times creates the possibility of inconsistency if there’s a bug of any sort in processing. However, to meet performance constraints you’re forced to store the same information in multiple ways, whether in the same database or across multiple databases. And it’s not just RDBMS’s that have this problem. So the burden is on you, the engineer, to ensure complete fault-tolerance in achieving consistency for all code that updates those databases. Code like that is frequently spread across many services.</p>
<p>There’s a fundamental tension between being a source of truth versus being an indexed store that answers queries quickly. The traditional RDBMS architecture conflates these two concepts into the same datastore.</p>
<p>The solution is to treat these two concepts separately. One subsystem should be used for representing the source of truth, and another should be used for materializing any number of indexed stores off of that source of truth. If that second system is capable of recomputing indexes off of that source of truth, any bugs that introduce inconsistency can be corrected.</p>
<p>Once again, this is event sourcing plus materialized views. If those two systems are integrated, you don’t need to take any performance hit. More on this soon.</p>
</div>



<h2 id="Restrictive_schemas">Restrictive schemas</h2>



<div><p>Databases vary a ton regarding what kinds of values can be stored in them. Some only allow “blobs” (byte arrays), putting the burden of serializing and deserializing domain types on clients. Others allow a variety of types like integers, floating point numbers, strings, dates, and others.</p>
<p>It’s rare that you can store your domain representations in a first-class way in a database such that queries can reach inside your domain objects to fetch or aggregate information nested inside. Partially this is due to database implementation languages being distinct from application languages so they can’t interoperate in these ways. Sometimes you can extend a database to handle a language-neutral representation, like <a href="https://github.com/mpartel/postgres-protobuf">this extension</a> for Postgres, but it’s cumbersome and has limitations.</p>
<p>It’s common to instead use adapter libraries that map a domain representation to a database representation, such as <a href="https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping">ORMs</a>. However, such an abstraction frequently leaks and causes issues. This has been discussed extensively already, like <a href="https://medium.com/building-the-system/dont-be-a-sucker-and-stop-using-orms-190add65add4">here</a> and <a href="https://dev.to/harshhhdev/why-orms-arent-always-a-great-idea-41kg">here</a>, so I don’t need to go into all the issues with ORMs again.</p>
<p>Being forced to index data in a way that’s different from your ideal domain representation is pure complexity. At the very least, you have to write adapter code to translate between the representations. Frequently, the limitations restrict what kinds of queries can be performed efficiently. The restrictiveness of database schemas forces you to twist your application to fit the database in undesirable ways.</p>
<p>This issue has been so universal for so long, it can be hard to recognize that this complexity is unnecessary. When you can mold your datastore to fit your application, including your desired domain representations, this complexity goes away.</p>
</div>



<h2 id="Complex deployments">Complex deployments</h2>



<div><p>Databases do not exist in isolation. A complete backend requires using many tools: databases, processing systems, monitoring tools, schedulers, and so on. Large-scale backends oftentimes require dozens of different tools.</p>
<p>Updating an application can be a complex orchestration process of migrations, code updates, and infrastructure changes. It’s not uncommon for companies to have entire teams dedicated to deployment engineering.</p>
<p>On top of all this, to be production-ready you have to ensure everything has sufficient telemetry so you’re able to detect and diagnose any issues that may arise, whether performance or otherwise. Every tool has its own bespoke mechanisms for collecting telemetry, so getting everything gathered together into one monitoring dashboard is another non-trivial engineering task.</p>
<p>The complexity and cost of deployment is an artifact of the development model which currently dominates software engineering, what I call the “a la carte model”. On the surface, the a la carte model is attractive: pick the most optimal tool for each part of your architecture and make them work together.</p>
<p>The reality of the a la carte model doesn’t meet that ideal. As the tools are designed independently from one another, “making them work together” is oftentimes a ton of work, including the pain of building deployments. And as already discussed, the tools are usually far from optimal. Things like fixed data models and restrictive schemas mean you’re frequently twisting your application to fit your tools rather than molding your tools to fit your application.</p>
<p>If you take a step back and think about what we do as software engineers, the high cost of building applications doesn’t really make sense. We work in a field of engineering based on abstraction, automation, and reuse. Yet it takes hundreds or thousands of person-years to build applications that you can describe in total detail within hours – look at the sizes of the engineering teams behind pretty much every large-scale application. Even many small-scale applications require engineering effort that seems severely disproportionate to their functionality. What happened to abstraction, automation, and reuse? Why isn’t the engineering involved in building an application just what’s unique about that application?</p>
<p>The a la carte model exists because the software industry has operated without a cohesive model for constructing end-to-end application backends. When you use tooling that is built under a truly cohesive model, the complexities of the a la carte model melt away, the opportunity for abstraction, automation, and reuse skyrockets, and the cost of software development drastically decreases.</p>
</div>



<h2 id="A_cohesive_model_for_building_application_backends">A cohesive model for building application backends</h2>



<div><p>To go beyond databases to find a better approach to software development, you have to start from first principles. That’s the only way to break free from the shackles of decades of inertia of software architectures. So let’s clearly and rigorously define what a backend is, and then reason from there as to how backends should be structured.</p>
<p>The primary functions of a backend are receiving new data and answering questions on that data. Answering a question may involve fetching one piece of data that had been previously recorded (e.g. “What is Alice’s current location?”), and other questions may involve aggregations of lots of data (e.g. “What is the average bank account balance of people in Freedonia over the last three months?”). The most general way to answer a question is to literally run a function on all the data the backend has ever received:</p>
</div>




<div><table><tbody><tr><td><p>1<br/></p></td><td><p>query = function(all data)</p></td></tr></tbody></table></div>




<div><p>Forget for a moment the practicalities of this, that your dataset may be 10 petabytes in size and your queries need to be answered within milliseconds. What matters is this is a starting point from which to think about backend design. Unlike the data models of databases, this clearly encapsulates all possible backends. The closer your backend design is to this ideal while meeting the necessary practical constraints (e.g. latency, scalability, consistency, fault-tolerance), the more powerful it will be. How close can you get to this ideal? In other words, what is the smallest set of tradeoffs necessary to arrive at a practical system?</p>
<p>It turns out all you have to do is add the concept of an index, a precomputed view of your data that enables certain queries to be resolved quickly. And so the above model becomes:</p>
</div>









<p>Every backend that’s ever been built has been an instance of this model, though not formulated explicitly like this. Usually different tools are used for the different components of this model: data,

<code>function(data)</code>

, indexes, and

<code>function(indexes)</code>

. In a typical RDBMS backend, an RDBMS is used for both data and indexes, with possibly other databases like ElasticSearch used for more indexing. Computation (both

<code>function(data)</code>

and

<code>function(indexes)</code>

) is usually done either as part of an API server’s handlers or in background jobs managed with queues and workers.</p>
<p>Larger scale backends may use NoSQL databases like Cassandra, MongoDB, or Neo4j for indexing, Kafka for incoming data, and computation systems like Hadoop, Storm, or Kafka Streams for

<code>function(data)</code>

.</p>
<p>In all these cases backends are constructed with a hodgepodge of narrow tooling. None of these are general purpose tools for any of the components of backends (data,

<code>function(data)</code>

, indexes,

<code>function(indexes)</code>

), able to satisfy the needs of that component for all backends at all scales for all performance requirements.</p>



<div><p>What this model does is provide a framework for a next-generation tool that takes all the needs of a backend into account. If a tool could implement all these components in an integrated and general purpose way – at any scale, fault-tolerant, and with optimal performance – the complexities described earlier in this post could be avoided.</p>
<p>That brings us to <a href="https://redplanetlabs.com/docs/~/index.html">Rama</a>, a backend development platform designed with these first principles at its foundation.</p>
</div>



<h2 id="Rama">Rama</h2>



<div><p>We announced Rama on August 15th with the tagline “the 100x development platform”. Since that sounds so impossible on the face of it, we paired our announcement with a <a href="https://blog.redplanetlabs.com/2023/08/15/how-we-reduced-the-cost-of-building-twitter-at-twitter-scale-by-100x/">direct demonstration</a> of that cost reduction. We re-implemented <a href="https://joinmastodon.org/">Mastodon</a> (basically the same as the Twitter consumer product) in its entirety from scratch to be able to run at Twitter-scale. To demonstrate its scale, we operated the instance with 100M bots posting 3,500 times per second at 403 average fanout. Twitter wrote 1M lines of code and spent ~200 person-years building the equivalent (just the consumer product), and we did it with Rama with 10k lines of code and nine person-months. Our implementation is <a href="https://github.com/redplanetlabs/twitter-scale-mastodon">open-source</a>, complete, high-performance, and production-ready.</p>
<p>Twitter’s implementation was so much more expensive because of the complexities described earlier. For instance, to reach scale they had to build multiple specialized databases from scratch (e.g. social graph database, in-memory timeline database) because there were no databases that had the right data models. They have an extremely complex deployment consisting of a large number of different tools, with <a href="https://blog.twitter.com/engineering/en_us/topics/infrastructure/2017/the-infrastructure-behind-twitter-scale">over 1M lines</a> of just Puppet configuration.</p>
<p>These complexities and many others are completely avoided by our Rama-based implementation. Our solutions to the performance and scalability challenges of Twitter are similar (e.g. keep timelines in memory and reconstruct on read if lost, how we balance processing of an unbalanced social graph), but we were able to do it by simply composing the primitives of Rama together in different ways rather than build specialized infrastructure from scratch for each subproblem. Our <a href="https://blog.redplanetlabs.com/2023/08/15/how-we-reduced-the-cost-of-building-twitter-at-twitter-scale-by-100x/#Performance_and_scalability">performance numbers</a> for our Mastodon implementation are as good or better than Twitter’s numbers.</p>
<p>This is the programming model of Rama:</p>
</div>



<figure><img decoding="async" width="656" height="354" data-attachment-id="1451" data-permalink="https://blog.redplanetlabs.com/2023/10/11/introducing-ramas-clojure-api/rama-concepts-2/" data-orig-file="https://i0.wp.com/blog.redplanetlabs.com/wp-content/uploads/2023/10/rama-concepts.png?fit=1622%2C874&amp;ssl=1" data-orig-size="1622,874" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="rama-concepts" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/blog.redplanetlabs.com/wp-content/uploads/2023/10/rama-concepts.png?fit=300%2C162&amp;ssl=1" data-large-file="https://i0.wp.com/blog.redplanetlabs.com/wp-content/uploads/2023/10/rama-concepts.png?fit=656%2C354&amp;ssl=1" src="https://i0.wp.com/blog.redplanetlabs.com/wp-content/uploads/2023/10/rama-concepts.png?resize=656%2C354&amp;ssl=1" alt="" srcset="https://i0.wp.com/blog.redplanetlabs.com/wp-content/uploads/2023/10/rama-concepts.png?resize=1024%2C552&amp;ssl=1 1024w, https://i0.wp.com/blog.redplanetlabs.com/wp-content/uploads/2023/10/rama-concepts.png?resize=300%2C162&amp;ssl=1 300w, https://i0.wp.com/blog.redplanetlabs.com/wp-content/uploads/2023/10/rama-concepts.png?resize=768%2C414&amp;ssl=1 768w, https://i0.wp.com/blog.redplanetlabs.com/wp-content/uploads/2023/10/rama-concepts.png?resize=1536%2C828&amp;ssl=1 1536w, https://i0.wp.com/blog.redplanetlabs.com/wp-content/uploads/2023/10/rama-concepts.png?resize=1200%2C647&amp;ssl=1 1200w, https://i0.wp.com/blog.redplanetlabs.com/wp-content/uploads/2023/10/rama-concepts.png?w=1622&amp;ssl=1 1622w, https://i0.wp.com/blog.redplanetlabs.com/wp-content/uploads/2023/10/rama-concepts.png?w=1312&amp;ssl=1 1312w" sizes="(max-width: 656px) 100vw, 656px" data-recalc-dims="1"/></figure>



<p>These concepts correspond directly to the first principles described. What makes Rama so powerful is how it implements each piece so generally. Depots correspond to “data” and are distributed logs containing arbitrary data. “PStates” (short for “partitioned state”) correspond to indexes. You can make as many PStates as you need with each specified as an arbitrary combination of durable data structures. ETLs and queries are

<code>function(data)</code>

and

<code>function(indexes)</code>

respectively, and they’re expressed using a Turing-complete dataflow API that seamlessly distributes computation. Being Turing-complete is critical to be able to support arbitrary ETL and query logic.</p>



<div><p>How to use Rama is documented extensively <a href="https://redplanetlabs.com/docs/~/index.html">on our website</a>. That documentation contains a six-part tutorial that does a much better job introducing the API than I could possibly squeeze into this post. That tutorial explores Rama through the Java API, but Rama also has <a href="https://blog.redplanetlabs.com/2023/10/11/introducing-ramas-clojure-api/">a Clojure API</a>.</p>
<p>So let’s instead look at how Rama avoids the complexities that have plagued databases for so long. While Rama does everything a database does, like durably indexing data and <a href="https://redplanetlabs.com/docs/~/replication.html">replicating changes incrementally</a>, it also does so much more. Rama handling both computation and storage is a big part of how it’s able to avoid these complexities.</p>
<p>Let’s start with the first complexity we looked at, databases being global mutable state suffering from the same issues as global mutable state in regular programs. Rama’s PStates serve the same role that a database does, but they are only writable from the ETL topology that owns them. Since every write to a PState is in the same ETL code, it’s much easier to reason about their state.</p>
<p>Fundamentally, PStates are materialized views over an event sourced log. So it doesn’t make sense for anything but the owning ETL topology to write to them. The combination of event sourcing and materialized views also addresses the other issue discussed earlier, that a bug deployed to production can corrupt a database in a way that’s difficult or impossible to fully correct. In Rama, a PState can always be recomputed from the depot data, which is the source of truth. This can completely correct any sort of human error.</p>
<p>The next complexity of databases was the restrictiveness of data models. We discussed how data structures are a much better way to specify indexes, and that each data model is just a particular combination of data structures. Being able to specify indexes in terms of data structures allows not just every existing data model to be supported, but also infinite more.</p>
<p>Rama’s PStates are specified as data structures. When developing Rama applications it’s common to materialize many PStates to handle all the different use cases of an application. For example, our Mastodon implementation has 33 PStates with a wide variety of data structures just for profiles, statuses, and timelines. Sometimes one PState handles 10 different use cases, and other times a PState exists just to support one use case.</p>
<p>PStates are durable, partitioned, and incrementally replicated. Incremental replication means there’s always another partition ready to take over if the leader partition fails, and it guarantees anything visible on a current leader will still be visible on subsequent leaders. These properties make PStates suitable for any use case handled by databases, including large scale ones.</p>
<p>The next complexity we covered was the normalization versus denormalization problem. Through being based on first principles, Rama inherently solves that by explicitly distinguishing between data (depots) and views (PStates).</p>
<p>The next complexity was the restrictive schemas of databases. One of the joys of developing with Rama is using your domain representations in every context, whether appending to a depot, reading/writing to PStates, or doing distributed processing in ETLs or queries. Any data representation is allowed, whether plain data structures like hash maps or lists, <a href="https://protobuf.dev/">Protocol Buffers</a>, or nested object definitions. There’s no difference between using any of them. If you want to use a type Rama doesn’t already know about, you just have to register a <a href="https://redplanetlabs.com/docs/~/serialization.html">custom serializer</a>.</p>
<p>The last complexity we discussed was complex deployments, and Rama addresses that too. Rama is an integrated platform capable of building an entire backend end-to-end. Rama applications are called “modules”, and a module contains any number of depots, ETLs, PStates, and query topologies. Rama provides built-in mechanisms to deploy, update, and scale modules. Each of these is <a href="https://redplanetlabs.com/docs/~/operating-rama.html#_launching_modules">just a one-liner</a> at the terminal. All that complexity of deployment engineering when dealing with traditional architectures comprising dozens of pieces of infrastructure completely evaporates from Rama being an integrated system.</p>
<p>Some people get the wrong impression that Rama is an “all or nothing” tool, but in reality Rama is <a href="https://redplanetlabs.com/docs/~/integrating.html">very easy to integrate</a> with any other system. This allows Rama to be incrementally introduced into existing architectures.</p>
<p>Another great consequence of Rama being such a cohesive and integrated platform is the monitoring Rama provides out of the box. Since Rama is so general purpose, it’s capable of monitoring itself: collecting monitoring data, processing it, indexing it, and visualizing it. Rama provides <a href="https://redplanetlabs.com/docs/~/operating-rama.html#_cluster_ui">deep and detailed telemetry</a> on all aspects of a module. This telemetry is invaluable for understanding the performance of a module in production, detecting and diagnosing issues, and knowing when to scale.</p>
<p>That covers all the complexities about databases discussed earlier, and we’re just barely scratching the surface on Rama. The best ways to learn more about Rama are to go through <a href="https://redplanetlabs.com/docs/~/index.html">the documentation</a>, play with the <a href="https://redplanetlabs.com/docs/~/downloads-maven-local-dev.html">publicly available build of Rama</a>, study the short, self-contained, thoroughly commented examples in <a href="https://github.com/redplanetlabs/rama-demo-gallery">rama-demo-gallery</a>, or study our <a href="https://github.com/redplanetlabs/twitter-scale-mastodon">Twitter-scale Mastodon implementation</a>.</p>
</div>



<h2 id="Conclusion">Conclusion</h2>



<div><p>The software industry has been stuck near a local maximum for a long time with the a la carte model. The current state of databases is a consequence of backend development not being approached in a holistic manner.</p>
<p>Rama is a paradigm shift that breaks free of this local maximum. The complexities of databases that every programmer has gotten so used to are no longer necessary. The benefits of breaking out of that local maximum are very consequential, with a dramatically lower cost of development and maintenance. The 100x cost reduction we demonstrated with our Mastodon example translates to any other large-scale application. Small to medium scale applications won’t have as extreme a cost reduction, but the reduction in complexity is significant for smaller scale applications as well.</p>
<p>Finally, if you’d like to use Rama in production to build new features, scale your existing systems, or simplify your infrastructure, you can <a href="https://docs.google.com/forms/d/e/1FAIpQLSfrhmBwI0YAeaL8u4XmgfscW4UIUUDp2ZHSs4KmPH_TaDt1QQ/viewform">apply to our private beta</a>. We’re working closely with each private beta user to not only help them learn Rama, but also actively helping code, optimize, and test.</p>
</div>
			</div><!-- .entry-content -->

	<!-- .entry-footer -->

	</article></div>
  </body>
</html>
