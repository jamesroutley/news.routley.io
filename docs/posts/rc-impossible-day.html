<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.faridrener.com/2025/01/21/impossible-day.html">Original</a>
    <h1>RC Impossible Day!</h1>
    
    <div id="readability-page-1" class="page"><div>
      <div>
        <div>

  

  <article>
    <p>Today I chose, unwisely to try and get Rust compiled and flashed onto the Arduino Uno R4, which has a Renesas RA4M1 (Arm Cortex-M4) chip. There is a rust <a href="https://docs.rs/ra4m1/0.2.0/ra4m1/">hardware abstraction layer</a> crate for this chip, as well as a <a href="https://github.com/rust-embedded/cortex-m-quickstart/tree/master">compile target</a>.</p>

<p>I failed spectacularly, and the outcome of my efforts was the ability to get the Arduino into a boot loop. Hooray!</p>

<p>I started with the cortex-m quickstart, which requires you to enter the memory mapping information into a file called <code>memory.x</code>. I made this up to start with, thinking it would probably bite me later, but I wanted to keep moving.</p>

<p>Once I was able to compile the quickstart, I moved on to flashing the board. This was reasonably easy - I just converted the rust binary (<code>ELF</code>) file to a <code>.bin</code> that I assumed the board needed. Then I used the <code>bossac</code> command that arduino uses to flash to the arduino.</p>

<p>This worked!!</p>

<div><div><pre><code>❯ rust-objcopy target/thumbv7em-none-eabihf/release/examples/hello -O binary -j .text -j .data hello.bin
</code></pre></div></div>

<div><div><pre><code>❯  ~/.arduino15/packages/arduino/tools/bossac/1.9.1-arduino5/bossac <span>-d</span> <span>--port</span><span>=</span>ttyACM0 <span>-U</span> <span>-e</span> <span>-w</span> hello.bin <span>-R</span>
Set binary mode
version<span>()=</span>Arduino Bootloader <span>(</span>SAM-BA extended<span>)</span> 2.0 <span>[</span>Arduino:IKXYZ]
Connected at 921600 baud
identifyChip<span>()=</span>nRF52840-QIAA
write<span>(</span><span>addr</span><span>=</span>0,size<span>=</span>0x34<span>)</span>
writeWord<span>(</span><span>addr</span><span>=</span>0x30,value<span>=</span>0x400<span>)</span>
writeWord<span>(</span><span>addr</span><span>=</span>0x20,value<span>=</span>0<span>)</span>
Erase flash
chipErase<span>(</span><span>addr</span><span>=</span>0<span>)</span>

Done <span>in </span>0.001 seconds
Write 200 bytes to flash <span>(</span>1 pages<span>)</span>
<span>[</span>                              <span>]</span> 0% <span>(</span>0/1 pages<span>)</span>write<span>(</span><span>addr</span><span>=</span>0x34,size<span>=</span>0x1000<span>)</span>
writeBuffer<span>(</span><span>scr_addr</span><span>=</span>0x34, <span>dst_addr</span><span>=</span>0, <span>size</span><span>=</span>0x1000<span>)</span>
<span>[==============================]</span> 100% <span>(</span>1/1 pages<span>)</span>
Done <span>in </span>0.239 seconds
reset<span>()</span>

</code></pre></div></div>

<p>This seems to do what I thought it should, which is push my code the the arduino, then restart it. Awesome!</p>

<p>Then I went on to “writing some real code”. My goal for the day was just to flash the internal LED, which is connected to Pin 13 of the Arduino. I figured this should be easy enough - just find where Pin 13 is connected, and set that to high, like I would with the Arduino’s <code>digitalWrite(LED_BUILTIN, HIGH)</code> function. Turns out the beauty of the arduino is how abstracted the actual hardware is from the code you are writing!</p>

<p>First, using the <code>ra4m1</code> crate, I had to find what “pin 13” was called.</p>

<p>In the Arduino datasheet, we see that pin D13 is connected to P102 of the chip:</p>

<p><img src="https://www.faridrener.com/assets/images/Pasted%20image%2020250121164411.png" alt="Pasted image 20250121164411.png"/></p>

<p>I then spent a while trying to figure out how to reference pin 102 in the <code>ra4m1</code> crate. You actually need to set bits in a specific register to be able to use them. We see the following in the data sheet for the chip:
<img src="https://www.faridrener.com/assets/images/Pasted%20image%2020250121164705.png" alt="Pasted image 20250121164705.png"/></p>

<p>Se we need to set the <code>PDR</code> bit to select “output”, then the <code>PODR</code> bit to set this to high.</p>

<p>In the <code>ra4m1</code> hal, these are referenced behind a “PORT”, specifically:
<img src="https://www.faridrener.com/assets/images/Pasted%20image%2020250121164923.png" alt="Pasted image 20250121164705.png"/></p>

<p>P102 is on “PORT1”, and I think this means I have to set the third bit (b2) of the port:
<img src="https://www.faridrener.com/assets/images/Pasted%20image%2020250121165416.png" alt="Pasted image 20250121164705.png"/></p>

<p>So we have something like this, which I think should at least do something:</p>

<div><div><pre><code><span>#![no_main]</span>
<span>#![no_std]</span>

<span>use</span> <span>panic_halt</span> <span>as</span> <span>_</span><span>;</span>

<span>use</span> <span>cortex_m_rt</span><span>::</span><span>entry</span><span>;</span>
<span>use</span> <span>ra4m1</span><span>;</span>

<span>#[entry]</span>
<span>fn</span> <span>main</span><span>()</span> <span>-&gt;</span> <span>!</span> <span>{</span>
    <span>let</span> <span>p</span> <span>=</span> <span>unsafe</span> <span>{</span> <span>ra4m1</span><span>::</span><span>Peripherals</span><span>::</span><span>steal</span><span>()</span> <span>};</span>
    <span>let</span> <span>port</span> <span>=</span> <span>p</span><span>.PORT1</span><span>;</span>

    <span>port</span><span>.pdr</span><span>()</span><span>.modify</span><span>(|</span><span>_</span><span>,</span> <span>w</span><span>|</span> <span>unsafe</span> <span>{</span> <span>w</span><span>.bits</span><span>(</span><span>0b100</span><span>)</span> <span>});</span> <span>// set it to output?</span>
    <span>port</span><span>.podr</span><span>()</span><span>.modify</span><span>(|</span><span>_</span><span>,</span> <span>w</span><span>|</span> <span>unsafe</span> <span>{</span> <span>w</span><span>.bits</span><span>(</span><span>0b000</span><span>)</span> <span>});</span> <span>// turn it off</span>

    <span>loop</span> <span>{</span>
        <span>port</span><span>.podr</span><span>()</span><span>.modify</span><span>(|</span><span>_</span><span>,</span> <span>w</span><span>|</span> <span>unsafe</span> <span>{</span> <span>w</span><span>.bits</span><span>(</span><span>0b100</span><span>)</span> <span>});</span> <span>// turn it on?</span>
        <span>//sleep for a bit</span>
        <span>// port.podr().modify(|_, w| unsafe { w.bits(0b000) });</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>This compiles! That means it will definitely work. I’m excited to see my arduino’s light turn on.</p>

<p>But…. It didn’t work! The LED just slowly pulses in an out, which is what happens when it is in “bootloader mode” (you can get here by double-tapping the reset button).</p>

<p>This is where I ended up in a spiral of despair, and was me mostly floundering.</p>

<p>I figured that if the arduino couldn’t find my code, then it couldn’t start! My guess was that the memory information used in the linker (<code>memory.x</code>) is what was causing the boot loop - the arduino didn’t know what to do.</p>

<p>So… I spent a long time trying to glean the memory blocks from this image in the reference materials for the chip:</p>

<p><img src="https://www.faridrener.com/assets/images/Pasted%20image%2020250121163456.png" alt="Pasted image 20250121164705.png"/></p>

<p>I wasn’t sure which ones were relevant to what I was doing.</p>

<p>I tried looking at the sizes in a bare arduino sketch:</p>
<div><div><pre><code>❯  /home/farid/.arduino15/packages/arduino/tools/arm-none-eabi-gcc/7-2017q4/bin/arm-none-eabi-size -A /home/farid/.var/app/cc.arduino.IDE2/cache/arduino/sketches/9DC53CE91F29F6C0885D8121E1BB282E/BareMinimum.ino.elf
/home/farid/.var/app/cc.arduino.IDE2/cache/arduino/sketches/9DC53CE91F29F6C0885D8121E1BB282E/BareMinimum.ino.elf  :
section                    size         addr
.text                     57436        16384
.ARM.exidx                    8        73820
.fsp_dtc_vector_table         0    536870912
.data                       568    536870912
.noinit                      24    536871480
.bss                       6192    536871504
.heap                      8192    536877696
.stack_dummy               1024    536902400
.vector_table               256    536903424
.data_flash                   0   1074790400
.id_code                     28     16842776
.option_setting               0            0
.option_setting_ns            0            0
.option_setting_s             0            0
.ARM.attributes              48            0
.comment                    199            0
.debug_info             2464862            0
.debug_abbrev             93044            0
.debug_aranges             7192            0
.debug_ranges             24968            0
.debug_macro             161324            0
.debug_line              279977            0
.debug_str               582271            0
.debug_frame              24088            0
.debug_loc               159078            0
.stab                       180            0
.stabstr                    387            0
Total                   3871346

</code></pre></div></div>

<p>And then tried replicating that for the rust binary:</p>
<div><div><pre><code>❯  /home/farid/.arduino15/packages/arduino/tools/arm-none-eabi-gcc/7-2017q4/bin/arm-none-eabi-size -A target/thumbv7em-none-eabihf/release/examples/hello
target/thumbv7em-none-eabihf/release/examples/hello  :
section            size        addr
.vector_table      1024       16384
.text               168       32768
.rodata               0       32936
.data                 0   536870912
.gnu.sgstubs          0       32960
.bss                  4   536870912
.uninit               0   536870916
.debug_loc          229           0
.debug_abbrev      1347           0
.debug_info        8585           0
.debug_aranges      472           0
.debug_ranges      1160           0
.debug_str         7310           0
.comment             64           0
.ARM.attributes      58           0
.debug_frame        692           0
.debug_line        2272           0
.debug_pubnames     702           0
.debug_pubtypes      71           0
Total             24158

</code></pre></div></div>

<p>But there are many different sections that don’t line up…</p>

<p>After a while, I realized I could just grab this from the “real” arduino codebase, and found <code>fsp.ld</code> which was the same format as <code>memory.x</code>. I think I need to read more about what this format is, and what it does (apparently it’s written in <em>linker command language</em>, which defines how the input files are linked to the output files).</p>

<p>Copying that file and removing references to C code didn’t work as the rust linker complained that things weren’t lining up, which is true, it maps the different parts of memory to the same addresses.</p>

<p>There is a whole section in that file called <code>SECTIONS</code>, which is provided by the <code>cortex-m-rt</code> crate and is <a href="https://github.com/rust-embedded/cortex-m/blob/b02ec57506b353c904832cca053072dd396f0eb7/cortex-m-rt/link.x.in#L4">automatically included</a></p>

<p>I think this is where the problem lies. The arduino file contains things like:</p>
<div><div><pre><code>        /* .sketch_boot section supports the Arduino SxU libraries, which are second stage bootloaders.
         * The bootloaded sketch then starts aligned at next flash page after the SxU */
        KEEP(*(.sketch_boot))
</code></pre></div></div>

<p>Which I think means we need a sketch_boot section to bootstrap our code somehow?</p>

<p>This is a hole I haven’t yet dug myself out of, and might just say:</p>

<p>“This is impossible, for now!”</p>

  </article>

</div>

      </div>
    </div></div>
  </body>
</html>
