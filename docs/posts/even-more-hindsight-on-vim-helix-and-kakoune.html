<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://phaazon.net/blog/more-hindsight-vim-helix-kakoune">Original</a>
    <h1>Even more hindsight on Vim, Helix and Kakoune</h1>
    
    <div id="readability-page-1" class="page"><div>
      

      <section>
  <a href="https://nickdrozd.github.io/blog/more-hindsight-vim-helix-kakoune">
    
  </a>

  <h2>
    <div>
      <div>
        <p><em>editors, productivity-platforms</em>
        </p>
      </div>

      <div>
        <p>
          Wed May 24 11:50:00 2023 UTC, by Dimitri Sabadie —
          <a href="https://nickdrozd.github.io/blog/feed">
            <span>
              
              <span>feed</span>
            </span>
          </a>
        </p>
      </div>
    </div>
  </h2>

  <hr/>

  <div>
    <p>Oh my… 2023 has been such a trek so far… If you have missed my <a href="https://phaazon.net/blog/editors-in-2022">previous article</a>
about my thoughts about editors and development platforms, I think it’s probably the moment to have a look at it.</p>
<p>Today is the end of May 2023. <a href="https://helix-editor.com/">Helix</a> has been my primary editor for months now. I haven’t
come back to <a href="https://neovim.io/">Neovim</a>. In the previous article, I mentioned that I couldn’t give a fair opinion
about Helix because I had just started using it. Today, I think I have enough experience and usage (5 / 6 months) to
share what I think about Helix, and go a little bit further, especially regarding software development in general and,
of course, editing software.</p>
<p>However, before starting, I think I need to make a clear disclaimer. If you use Vim, Neovim, Emacs, VS Code, Sublime
Text, whatever, and you think that <em>“Everyone should just use whatever they want”</em>, then we agree and <strong>this is not
the point of this blog article</strong>. The goal is to discuss a little bit more than just speaking out obvious takes, but
please do not start waving off the topic because you think <em>“Everyone should use what they want”</em>. There is a place
for constructive debate even there. If you start arguing, then it means you want to debate, and then you need to be
ready to have someone with different arguments that will not necessarily go your way, nor your favorite editor.</p>
<p>Finally, if you think I haven’t used Vim / Neovim enough, just keep in mind that I have been using (notice the tense)
Vim (and by extension, Neovim) since I was 15, and I’m 31, so 16 years.</p>
<p>I have wrote that blog article already three times before deleting everything and starting over. I think I will make
another blog article about how I think about software, but here I want to stay focused on one topic: editors and
development environments.</p>

<p>From a vimmer perspective, Helix is weird. It reverses the verb and the motion (you don’t type <code>di(</code> to delete inside
parenthesis, but you type <code>mi(d</code> to first match the parenthesis and then delete). Then, you have the multi-selections
as a default way of doing things; Helix doesn’t really have the concept of a <em>cursor</em>, which is a design it gets from
<a href="https://kakoune.org/">Kakoune</a>, and I’ll explain what it means and implies later.</p>
<p>Some vimmers publicly talked about it. ThePrimeagen, for instance, made a Youtube video about it where he basically
just scratched the surface of the editor and <em>“Hell it’s not Vim so it’s not really good”</em>. He moved the video to
private then but I’m sure you can just look for Tweets. Many Vim afficionados react that way, which is not a very
serious way of trying out something new, especially if you happen to publicly talk about it to thousands of people. I
think it’s not fair to both the tool (here, Helix) and the people reading you, unless you are one of those Vim zealots
thinking you know everything better than everyone else and dismissing people’ points of views just because they are not
the same as yours.</p>
<p>Anyway, that reputation didn’t hold me from trying out, and the way I try software is simple: just give in and accept
to drop your habits and productivity. Of course, at work, I was still using Vim / Neovim, but switched to Helix on my
spare-time projects.</p>
<p>There are many aspects to talk about with Helix. The first one is that, contrary to what people who haven’t really and
seriously tried it, the difference with Vim is not only “reversed motion/verb and multi-cursors.” The first difference
is the <em>design</em> and the <em>direction</em>.</p>
<h2>Design and direction</h2>
<p>Helix is an editor that natively integrates many features that are most of the time plugins in others editors (even
in VS Code). The best examples here are <a href="https://tree-sitter.github.io/tree-sitter/">tree-sitter</a>, surrounding pairs (
being able to automatically surround regions of text with <code>(</code>, <code>[</code>, HTML tags, etc.), LSP UIs, fuzzy pickers, etc. This
is a <em>massive</em> and important difference because of two main things:</p>
<ol>
<li>Code maintenance.</li>
<li>User experience.</li>
</ol>
<p>About code maintenance, having all of those features natively integrated in the editor means that you are 100% sure that
if you get the editor to start, the features will work, and the editor developers will keep that updated within the
next iteration of the editor. For instance, having tree-sitter natively implemented (Rust) in Helix means that the
editor itself knows about tree-sitter and its grammars, highlights queries and features. The same thing goes for
surrounding-pairs or auto-pairs, for instance. If the team decides to change the way text is handled in buffers, then
the code for auto-pairs / surrounding-pairs <strong>will have to be updated for the editor to be releasable</strong>.</p>
<p>The user experience will then be better, because you get those nice features without having to start looking around
for a plugin doing it, with the problem of chosing the right one among a set of competing plugins. Plus the risk of
having your plugin break because it’s not written by the Helix team. Just install the software and start using those
features.</p>
<p>For now, Helix ships with a bunch of powerful features that makes it usable in a modern environment:</p>
<ul>
<li>tree-sitter support for semantic highligthing, semantic selection and navigation, etc. That also includes a native
support for getting grammars / queries from the CLI with <code>hx --grammar</code>.</li>
<li>LSP support, both in terms of features (go-to, references, implementations, incoming / outgoing calls, diagnostics,
inlay hints, etc. etc.) and in terms of UI. It’s the same UI for everyone.</li>
<li>DAP support for debugging (experimental at the time of writing).</li>
<li>Surrounding pairs.</li>
<li>Auto pairs.</li>
<li>Git integration (gutter diff on the right side of your buffer) and Git semantic object (go to next change, etc.).</li>
<li>Registers and user-defined registers (like in Vim), along with macros (but you won’t need them, trust me).</li>
<li>Native discoverability, including a command palette with <em>every possible available commands</em>, tagged with their
keybindings.</li>
<li>Many bundled themes (yes, <code>catppuccin</code> themes are there!).</li>
<li>Snappier than anything else.</li>
<li>Various integration with your system, including clipboards, external commands, etc.</li>
</ul>
<p>There is also one (major) thing I want to talk about and that deserves its own section: configuration.</p>
<h2>Configuration done right</h2>
<p>Helix treats configuration <em>the way it should be</em>: as data. Configuration in Helix is done in TOML. There is no
scripting implied, it’s only a rich object laid out as TOML sections. And this is a <em>joy</em> to use. For instance, this is
my current Helix configuration (excluding keys remapping, because my keyboard layout is bépo):</p>
<pre><code>theme = &#34;catppuccin_macchiato&#34;

[editor]
scroll-lines = 1
cursorline = true
auto-save = false
completion-trigger-len = 1
true-color = true
color-modes = true
auto-pairs = true
rulers = [120]
idle-timeout = 50

[editor.cursor-shape]
insert = &#34;bar&#34;
normal = &#34;block&#34;
select = &#34;underline&#34;

[editor.indent-guides]
render = true
character = &#34;▏&#34;

[editor.lsp]
display-messages = true
display-inlay-hints = true

[editor.statusline]
left = [&#34;mode&#34;, &#34;spinner&#34;, &#34;file-name&#34;, &#34;file-type&#34;, &#34;total-line-numbers&#34;, &#34;file-encoding&#34;]
center = []
right = [&#34;selections&#34;, &#34;primary-selection-length&#34;, &#34;position&#34;, &#34;position-percentage&#34;, &#34;spacer&#34;, &#34;diagnostics&#34;, &#34;workspace-diagnostics&#34;, &#34;version-control&#34;]
</code></pre>
<p>Notice the tree-sitter and LSP configuration. Yes. <em>None</em>.</p>
<p>This is so important to me. Because configuration is data, it is simple for Helix to expose it and present it to the 
user by reading the TOML file without caring about having any side-effects. Helix has a command line (<code>:</code>) where you can
tweak those options dynamically. And you can dynamically reload the configuration as well.</p>
<h2>Multi-selection centric</h2>
<p>The major difference, even before the reversed motion/verb thing, is the fact that Helix <em>doesn’t really</em> have a cursor.
It has the concept of <em>selections</em>. A selection is made of two entities:</p>
<ul>
<li>An <em>anchor</em>.</li>
<li>A <em>cursor</em>.</li>
</ul>
<p>The cursor is the part of the selection that moves when you extend the selection. The anchor, as the name implies, is
the other part that stays where it is: it’s anchored. <strong>By default, you have only one selection</strong> and the anchor is 
located at the same place as the cursor. It looks similar to any other editor. Things start to change when you begin
typing normal commands. Typing <code>l</code>, for instance, will move both the anchor and cursor to the right, making them a
single  visual entity. However, if you type <code>w</code>, the cursor will move to the end of the word while the anchor will move
to its beginning, visually selecting the word. If you type <code>W</code>, the anchor won’t move and only the cursor will move,
extending the selection. If you press <code>B</code>, it will move the cursor back one word, shrinking the selection. You can press
<code>&lt;a-;&gt;</code> to flip the anchor and the selection, which is useful when you want to extend on the left or on the right.</p>
<p>This concept of selection is really powerful because everything else is based on it. Pressing <code>J</code> will move the cursor
down one line, leaving the anchor on the current line, extending selected lines. Once something is selected, you can
operate on it, with <code>d</code>, <code>c</code>, <code>y</code>, <code>r</code>, etc. For instance, <code>wd</code> will select the word and delete it. <code>Jc</code> will extend the
selection with the next line and start changing. Selections in Helix are not just visual helps: they represent what
normal editing operations will work on, which is a great design, because you can extend, shrink and reason about them in
a much more seamless and natural way.</p>
<p>But it’s just starting. Remember earlier when I say that <strong>by default, you have only one selection</strong>? Well, you can have
many, and this is where Helix starts to really shine to me. The first way to create many selections is to press <code>C</code>. <code>C</code>
will duplicate your current selection on the next line. If you have the anchor at the same position as the cursor,
pressing <code>C</code> will make it like you have another cursor on the next line below. For instance, consider this text:</p>
<pre><code>I love su|shi.
But I also love pizza.
</code></pre>
<p>The <code>|</code> is our cursor (but also anchor). If you press <code>C</code>, you will see something like this:</p>
<pre><code>I love su|shi.
But I als|o love pizza.
</code></pre>
<p>But as I had mentioned, <code>C</code> duplicates <em>selections</em>. Let’s say you started like this, <code>&lt;</code> being the anchor and <code>|</code> the
cursor:</p>
<pre><code>I love &lt;sus|hi.
But I also love pizza.
</code></pre>
<p>Pressing <code>C</code> now will do this:</p>
<pre><code>I love &lt;sus|hi.
But I a&lt;lso| love pizza.
</code></pre>
<p>Once you have many selections, everything you type as normal commands will be applied to every selections. If I type
<code>f.</code>, it will set the anchor to the current cursor and extend the cursor to the next <code>.</code>, resulting in this:</p>
<pre><code>I love sus&lt;hi|.
But I also&lt; love pizza|.
</code></pre>
<p>Press <code>&lt;a-;&gt;</code> to swap anchors and cursors:</p>
<pre><code>I love sus|hi&lt;.
But I also| love pizza&lt;.
</code></pre>
<p>And then pressing <code>B</code> will do this:</p>
<pre><code>I love |sushi&lt;.
But I |also love pizza&lt;.
</code></pre>
<blockquote>
<p>Erratum: <code>B</code> is not defined to this behavior in a vanilla Helix. I have remapped it to the Kakoune behavior. It
doesn’t change much to what I’m saying here, though.</p>
</blockquote>
<p>Multi-cursor is then not only a nice visual help, but also a completely new way of editing your buffers. Once you get
the hang of it, you don’t really think in terms of a single cursor but many selections, ranges, however you like to call
them.</p>
<h2>Getting more cursors</h2>
<p><code>C</code> is great, but this not something we usually use. Instead, we use features that don’t exist in Vim. I’m not entirely
sure how to call those, but I like to call them <em>selection generators</em>. They come in many different flavors, so I’ll
start with the easiest one and will finish with the most interesting and (maybe a bit?) obscure at first.</p>
<h3>Matching matching matching!</h3>
<p>The <code>m</code> key is Helix is a wonderful key. It’s the <em>match</em> key. It expects a motion and will change all your selections
to match the motion. For instance, <code>mia</code> <em>“matches inside arguments”</em> (tree-sitter). Imagine this context:</p>
<pre><code>fn foo(x: i32, y: |i32) {}

fn bar(a: String, |b: bool) {}
</code></pre>
<p>Press <code>mia</code> to get this:</p>
<pre><code>fn foo(x: i32, &lt;y: i32|) {}

fn bar(a: String, &lt;b: bool|) {}
</code></pre>
<p>Then, for instance, press <code>&lt;a-;&gt;</code> to flip the anchor and the cursor:</p>
<pre><code>fn foo(x: i32, |y: i32&lt;) {}

fn bar(a: String, |b: bool&lt;) {}
</code></pre>
<p><code>F,</code> to select the previous <code>,</code>:</p>
<pre><code>fn foo(x: i32|, y: i32&lt;) {}

fn bar(a: String|, b: bool&lt;) {}
</code></pre>
<blockquote>
<p>Erratum: same thing as with <code>B</code>; I have remapped it in my config. The default <code>B</code> doesn’t extend like this.</p>
</blockquote>
<p>And just press <code>d</code>:</p>
<pre><code>fn foo(x: i32) {}

fn bar(a: String) {}
</code></pre>
<p>It’s so logical, easy to think about and natural. Someting interesting to notice, too, is that contrary to Vim, which
has many keys doing mainly the same thing, making things weird and not really well designed. For instance, <code>vd</code> selects
the current character and delete it. <code>vc</code> deletes the current character and puts you into insert mode. <code>s</code> does exactly 
the same. Why would you have a key in direct access doing something so specific? If you want to delete a word, you 
either press <code>vwd</code>, or more simply in Vim, <code>dw</code>. All of that is already confusing, but it doesn’t end there. <code>x</code> deletes
the current character, but <code>x</code> is actually <em>cut</em>, so if you select a line with <code>V</code> and press <code>x</code>, it will cut the line.
Press <code>Vc</code> to change a line… or just <code>S</code>. What?</p>
<p>All those shortcuts feel like exceptions you have to learn, and it’s a good example of a flawed design. On the other
side, Helix (which is actually a Kakoune design it’s based on), have a single character to delete something: <code>d</code>. Since
the editor has multi-selections as a native editing entity, all of those situations will imply using the <code>d</code> key:</p>
<ul>
<li>Deleting the current character: <code>d</code>.</li>
<li>Deleting the next word: <code>wd</code>.</li>
<li>Deleting the current line: <code>xd</code> (<code>x</code> selects and extend the line).</li>
<li>Deleting delimiters but not the content: <code>md(</code>.</li>
<li>Etc. etc.</li>
</ul>
<p>That applies to everything.</p>
<h3>Selecting, splitting, keeping and removing</h3>
<p>The design of editing in Helix (Kakoune) is to be interactive and iterative. For instance, consider the following:</p>
<pre><code>  pub fn new(
    line_start: usize,
    col_start: usize,
    line_end: usize,
    col_end: usize,
    face: impl Into&lt;String&gt;,
  ) -&gt; Self {
    Self {
      line_start,
      col_start,
      line_end,|
      col_end,
      face: face.into(),
    }
  }
</code></pre>
<p>Let’s say we would like, to begin with, select very quickly every arguments type and switch them to <code>i32</code>. Many ways
of doing that, but let’s see one introducing a great concept: <em>selecting</em>. Selecting allows you to create new 
selections that satisfy a regex. The default keybinding for that is <code>s</code> for… select (woah). <code>s</code> always applies to the 
current Selections (notice the use of plural, it will be useful later). We then need to start selecting something. Here,
we can just press <code>mip</code> to select inside the paragraph, since our cursor is right after <code>line_end</code>:</p>
<pre><code>&lt; pub fn new(
    line_start: usize,
    col_start: usize,
    line_end: usize,
    col_end: usize,
    face: impl Into&lt;String&gt;,
  ) -&gt; Self {
    Self {
      line_start,
      col_start,
      line_end,
      col_end,
      face: face.into(),
    }
  }|
</code></pre>
<p>We have the whole thing selected. Press <code>s</code> to start selecting with a regex. We want the arguments, so let’s select
everything with <code>:</code> and press <code>s:</code> and return:</p>
<pre><code>  pub fn new(
    line_start&lt;:| usize,
    col_start&lt;:| usize,
    line_end&lt;:| usize,
    col_end&lt;:| usize,
    face&lt;:| impl Into&lt;String&gt;,
  ) -&gt; Self {
    Self {
      line_start,
      col_start,
      line_end,
      col_end,
      face&lt;:| face.into(),
    }
  } 
</code></pre>
<p>See how it created a bunch of selections for us. Also, notice that it selected <code>face: face.into()</code>, which is not
correct. We want to <em>remove</em> that selection. Again, several ways of doing it. Something to know is that, Helix (Kakoune)
has the concept of <em>primary</em> selection. This is basically the selection on which you are going to apply actions first,
like LSP hover, etc (it would be a madness to have LSP hover applies to all selections otherwise!). You can cycle the
primary selection with <code>(</code> and <code>)</code>. Once you reach the one you want, you can press <code>&lt;a-,&gt;</code> to just drop the selection.
However, we don’t want to cycle things. We want a faster way.</p>
<p>Let’s talk about <em>removing</em> selections. The default keybinding is <code>&lt;A-K&gt;</code>. However, here, our selections are all
about the same content (the <code>:</code>). As mentioned before, pressing <code>x</code> will select the current line of every selections:</p>
<pre><code>  pub fn new(
&lt;   line_start: usize,|
&lt;   col_start: usize,|
&lt;   line_end: usize,|
&lt;   col_end: usize,|
&lt;   face: impl Into&lt;String&gt;,|
  ) -&gt; Self {
    Self {
      line_start,
      col_start,
      line_end,
      col_end,
&lt;     face: face.into(),|
    }
  } 
</code></pre>
<p>Let’s filter selection and remove the one matching a pattern. In our case, let’s remove selections with a
<code>(</code> in them: <code>&lt;A-K&gt;\(</code> and return:</p>
<pre><code>  pub fn new(
&lt;   line_start: usize,|
&lt;   col_start: usize,|
&lt;   line_end: usize,|
&lt;   col_end: usize,|
&lt;   face: impl Into&lt;String&gt;,|
  ) -&gt; Self {
    Self {
      line_start,
      col_start,
      line_end,
      col_end,
      face: face.into(),
    }
  } 
</code></pre>
<p>Now press <code>_</code> to shrink the selections to trim leading and trailing whitespaces:</p>
<pre><code>  pub fn new(
    &lt;line_start: usize,|
    &lt;col_start: usize,|
    &lt;line_end: usize,|
    &lt;col_end: usize,|
    &lt;face: impl Into&lt;String&gt;,|
  ) -&gt; Self {
    Self {
      line_start,
      col_start,
      line_end,
      col_end,
      face: face.into(),
    }
  } 
</code></pre>
<p>Imagine that we have changed our mind and now we actually want to change the <code>usize</code> to <code>i32</code>. We can use the <em>keep</em>
operator, which is bound to <code>K</code> by default. Press <code>Kusize</code> and return to get this:</p>
<pre><code>  pub fn new(
    &lt;line_start: usize,|
    &lt;col_start: usize,|
    &lt;line_end: usize,|
    &lt;col_end: usize,|
    face: impl Into&lt;String&gt;,
  ) -&gt; Self {
    Self {
      line_start,
      col_start,
      line_end,
      col_end,
      face: face.into(),
    }
  } 
</code></pre>
<p>Another possible way is to press <code>susize</code> to only select the <code>usize</code> directly, which might be wanted if you want to 
change them quickly to <code>i32</code>, for instance.</p>
<p>The last operation that I want to mention is <em>splitting</em>. It’s introduced with <code>S</code> and will spawn several cursors
separated by a regex. For instance, consider:</p>
<pre><code>let |array = [1.0, 20.32, 3., 4.35];
</code></pre>
<p>Let’s say you’d like to select the numbers. With the methods described above, it’s probably challenging. With the
splitting command, it’s much easier. Put your cursor anywhere in the list and press <code>mi[</code> to select inside of it:</p>
<pre><code>let array = [&lt;1.0, 20.32, 3., 4.35|];
</code></pre>
<p>Then simply press <code>S,</code> to split the selection into selections separated by commas. You should end up with this:</p>
<pre><code>let array = [|1.0&gt;,| 20.32&gt;,| 3.&gt;,| 4.35&gt;];
</code></pre>
<p>Pressing <code>_</code> will shrink the selections to remove leading and trailing spaces:</p>
<pre><code>let array = [|1.0&gt;, |20.32&gt;, |3.&gt;, |4.35&gt;];
</code></pre>
<p>And here you have it! Now remember that you can combine all of this methods with semantic objects, like <code>mif</code> for
<em>inside functions</em>, <code>mat</code> for <em>around type</em>, <code>mia</code> for <em>inside arguments</em>, and many more. Recall that you can do that
<em>on each selection</em>, allowing for really powerful workflows.</p>
<h3>Do I really use all that at work / spare time projects?</h3>
<p><strong>Hell yes.</strong> It’s a muscular memory thing. For instance, I oftentimes the need to not only replace occurrences of 
patterns, like <code>fooN</code> — with <code>N</code> being a number — into <code>logger.fooN</code>, <strong>but I often need to change the structure around
those occurrences.</strong> And here, Helix really stands out. In Vim, you’d have to use a super ugly regex, completely blind,
and eventually a macro. The interactive and iterative approach of Helix is so much more powerful to me. For instance,
for the case described above: <code>%</code> to select the whole buffer, <code>sfoo.</code> to select <code>foo</code> with a single character
afterwards, then return, <code>clogger.foo</code> to replace with <code>logger.foo</code>, and still in insert mode, <code>&lt;C-r&gt;&#34;</code> to paste what
was yanked by the <code>c</code> operation. Here, the default register, <code>&#34;</code>, makes a <em>lot</em> of sense, because this register is local
to each selection, making this replace operation trivial and interactive.</p>
<p>Another example is something like this:</p>
<pre><code>const COLORS: [Color; 3] = [
  Color {
    r: 255,
    g: 0,
    b: 0,
  },
  Color {
    r: 0,
    g: 255,
    b: 0,
  },
  Color {
    r: 0,
    g: 0,
    b: 255,
  },
];
</code></pre>
<p>Imagine that you want to change every <code>Color</code> constructor to a function call, that does something like
<code>Color::rgb(r, g, b)</code>. Doing that interactively and iteratively in Helix is so easy. I’d put my cursor anywhere in that
block, press <code>mi[</code> to select everything inside <code>[]</code>, then <code>sColor&lt;cr&gt;</code> to create three cursors on the <code>Cursor</code>, and from
that moment, it’s just ping-pong-ing between normal mode and insert mode like you would do with a single selection. You
will be using <code>f</code>, <code>t</code>, <code>miw</code> etc. select things but the idea is the same, and the three occurrences will be updated at
once.</p>
<h2>A simpler editor overall</h2>
<p>Contrary to other famous editors and IDEs, Helix is not supposed to be extendable; it doesn’t try to solve more
problems than it should (and you will see in the Kakoune section that we can even push that to another extreme).
Something like Neovim is a bit of a disguised IDE. Yes, a vanilla Neovim with no plugins and no configuration is just
a very basic (and I would dare say <em>featureless</em>) editor. It won’t have LSP working. It won’t have tree-sitter working
either. Nothing for git integrated. Nothing for delimiters, nothing for pickers, nothing for any modern development. The
power of something like Emacs, Neovim etc. is to build on <em>extensibility</em>.</p>
<p>I used to enjoy that, until I came to the realization that, <em>perhaps</em>, it would be great to put things into perspective: 
is extensibility something we actually want? What do we try to solve with it? Well, we extend tools to add new features 
and new behaviors. We extend things so that the native / core tool ships with minimal features but doesn’t prevent 
people from adding specific and customized capabilities.</p>
<h3>Extensibility</h3>
<p>But is extensibility the only way to achieve that goal? The thing with extensibility is that:</p>
<ol>
<li>You have to build in advance for it. You cannot ship an editor without any extensibility support and expect it to
be an emergent feature. You have to add a basic support for it, whether it’s a plugin system, a
dynamic / relocatable system (<code>.so</code> / <code>.dylib</code> / <code>.dll</code>), a scripting language, a JIT, etc.</li>
<li>Extensibility is always walled.</li>
</ol>
<p>The last point is important. Extending a software <strong>requires the environment to adapt to the specifities of what you’re
extending</strong>, and that will require the environment to know about the specifities. Here, the environment could be
anything <strong>outside of Neovim</strong>. What it means is that, you’re not going to use external tools, but you are going to use
the interfaces, scripting languages, DSLs etc. of the tool you want to extend.</p>
<p>For instance, people might argue that extending Neovim is great because it only requires learning Lua, which is not
specific to Neovim, but that it is not actually true nor acurate. You have to learn <em>“Neovim Lua”</em>, which is basically 
its own beast. It’s like the standard library, but for Neovim. It will provide you with APIs you can use — and only 
use — to add new features to Neovim.</p>
<p>The same argument can be made to <em>any extensible</em> editor. VS Code, Emacs, etc.</p>
<h3>Composability</h3>
<p>Another way to add features and behaviors is to add them <em>externally</em>, by leveraging the tools themselves and compose
them instead of pushing more features into them. That vision is not very popular and famous and I’m not entirely sure
why. For instance, Vim has <a href="https://github.com/tpope/vim-fugitive">vim-fugitive</a>, a Git client for Vim / Neovim. It has
2k commits, between 8k-9k lines of code… and can be used only in Vim and Neovim. Yes, it extends and adds features
<em>inside</em> those editors, but still. If at some point you decide to switch to another editor, you can forget about this
plugin. This is even worse with something like <a href="https://magit.vc/">magit</a>, which is the best Git client I haver ever
used. Yet I don’t use it anymore, because it’s an Emacs plugin. What a shame.</p>
<p>Now repeat that reasoning for all the plugins you use. That has led some people to just install as few plugins as
possible and switch to composability.</p>
<p>Composability is the same concept as in code. You have two systems <code>A</code> and <code>B</code> doing <code>thingA</code> and <code>thingB</code>, and you 
write some <em>piping</em> glue code / script to connect both. People use many different languages to glue things together. 
Among the most famous approaches:</p>
<ul>
<li>Python.</li>
<li>Perl, especially when dealing with filtering text.</li>
<li>The shell, and especially any POSIX.2 compliant shell (no, don’t start talking about <code>fish</code>).</li>
</ul>
<p>I have shell functions that I source when I start my shell; for instance, one called <code>p</code>, to switch to my spare-time
projects:</p>
<pre><code>p () {
  proj_dir=${PROJ_DIR:-~/dev}
  project=$(ls $proj_dir | sk --prompt &#34;Switch to project: &#34;)
  [ -n &#34;$project&#34; ] &amp;&amp; cd $proj_dir/$project
}
</code></pre>
<p>This is a great example of composability, which composes the content of a project directory (the <code>$PROJ_DIR</code> environment
variable, or <code>~/dev</code> by default), with the <code>sk</code> fuzzy finder, and then changes the directory to whatever the user has
picked. I use that script all the time to quickly move to my various projects.</p>
<p>Notice that, <code>sk</code>, <code>fzf</code>, etc. already are tools that implement fuzzy searching for arbitrary inputs. Tools such as
<code>find</code> or <code>fd</code>, who are so far in my experience the fastest programs to look for stuff, can be composed with shell
pipes as well and integrated into your work environment.</p>
<p>Then the question starts to appear: why do editors / plugins re-implement all of that to have it inside the editor? It’s
pretty apparent in the Neovim community, but it often ends up with abandonware plugins, and harder to maintain
editors.</p>
<p>While I was wondering about all that, I was getting pretty productive with Helix, enjoying its simpler design, data
configuration, better editing features and overall way more stable experience. I remembered that most of the Helix
design came from Kakoune. And I started to think about one (not so) crazy idea: should I have a look at Kakoune?</p>
<p>And let’s enter Kakoune.</p>

<p>As mentioned above, Helix is <em>heavily</em> inspired by Kakoune. The main difference, from the surface, with distance, is
that Helix comes with more bundled features, like LSP, tree-sitter, pickers, etc. However, there are more (drastic)
differences that I need to talk about.</p>
<p>The first thing is, again, the design. And for that, I really need to quote a part from the
<a href="https://github.com/mawww/kakoune/blob/master/doc/design.asciidoc">excellent design doc</a> written by
<a href="https://github.com/mawww">@mawww</a>. The part that is the most interesting to me is, obviously, <em>composability</em>.</p>
<blockquote>
<p>Being limited in scope to code editing should not isolate Kakoune from its environment. On the contrary, Kakoune is
expected to run on a Unix-like system alongside a lot of text-based tools, and should make it easy to interact with
these tools.</p>
<p>For example, sorting lines should be done using the Unix sort command, not with an internal implementation. Kakoune
should make it easy to do that, hence the <code>|</code> command for piping selected text through a filter.
The modern Unix environment is not limited to text filters. Most people use a graphical interface nowadays, and
Kakoune should be able to take advantage of that without hindering text mode support. For example, Kakoune enables
multiple windows by supporting many clients on the same editing session, not by reimplementing tiling and tabbing.
Those responsibilities are left to the system window manager.</p>
</blockquote>
<p>And this is one of the most important things about Kakoune to me. First, it goes into the direction I’ve been wanting
for years (I’ll let you read my previous blog articles about editors and production environments; I’m basically saying
the same thing). And second, it ensures that the native editor remains small and true to its scope, ensuring an easier
maintenance, hence less bugs and more stable. Also, it doesn’t blindly ignore what everyone else is doing.</p>
<p>Let’s start with an example. Yes, Kakoune doesn’t have a fuzzy picker to pick your files. However, as mentioned above,
it composes well with its environment. It does that via different mechanisms (shell blocks, FIFOs, UNIX sockets, etc.).
Here, we can just use whatever we like to get a list of files, and let Kakoune ask the user which files to open. We then
simply use the selected value and open it. In order to do that, you need to read the design doc to understand a couple
of other things, such as the section about <em>interactive use and scripting</em>. Quoting:</p>
<blockquote>
<p>As an effect of both Orthogonality and Simplicity, normal mode is not a layer of keys bound to a text editing language
layer. Normal mode <strong>is</strong> the text editing language.</p>
</blockquote>
<p>Typing normal commands in a <code>.kak</code> file is then the way to go. And then, coming back to the fuzzy picker example, here
are three commands defined in my <code>kakrc</code>:</p>
<pre><code>## Some pickers
define-command -hidden open_buffer_picker %{
  prompt buffer: -menu -buffer-completion %{
    buffer %val{text}
  }
}

define-command -hidden open_file_picker %{
  prompt file: -menu -shell-script-candidates &#39;fd --type=file&#39; %{
    edit -existing %val{text}
  }
}

define-command -hidden open_rg_picker %{
  prompt search: %{
    prompt refine: -menu -shell-script-candidates &#34;rg -in &#39;%val{text}&#39;&#34; %{
      eval &#34;edit -existing  %sh{(cut -d &#39; &#39; -f 1 | tr &#39;:&#39; &#39; &#39; ) &lt;&lt;&lt; $kak_text}&#34;
    }
  }
}
</code></pre>
<p>As you can see, it’s just about composing known and well written tools together. Another example? Alright. Kakoune
doesn’t have splits, but I still want them. Let’s go:</p>
<pre><code>## kitty integration
define-command -hidden kitty-split -params 1 -docstring &#39;split the current window according to the param (vsplit / hsplit)&#39; %sh{
  kitty @ launch --no-response --location $1 kak -c $kak_session
}

## zellij integration
define-command -hidden zellij-split -params 1 -docstring &#39;split (down / right)&#39; %sh{
  zellij action new-pane -cd $1 -- kak -c $kak_session
}

define-command -hidden zellij-move-pane -params 1 -docstring &#39;move to pane&#39; %sh{
  zellij action move-focus $1
}

## tmux integration
define-command tmux-split -params 1 -docstring &#39;split (down / right)&#39; %sh{
  tmux split-window $1 kak -c $kak_session
}

define-command tmux-select-pane -params 1 -docstring &#39;select pane&#39; %sh{
  tmux select-pane $1
}
</code></pre>
<p>The design is not extensible: it’s composable, and all in all, it makes so much more sense to me.</p>
<h2>Kakoune vs. the rest</h2>
<p>If you are used to Helix, then Kakoune with a bit of configuration will feel very similar to Helix. Of course, you will
have to look around for LSP and tree-sitter support. The way we do that is by adding external processes to interact with
Kakoune servers / clients via UNIX sockets, FIFO pipes, etc.. Kakoune doesn’t know anything about LSP or tree-sitter,
but you can write a binary in any language you want and send remote commands to control the behavior of Kakoune.</p>
<ul>
<li>For LSP: <a href="https://github.com/kak-lsp/kak-lsp">kak-lsp/kak-lsp</a></li>
<li>For tree-sitter: <a href="https://github.com/phaazon/kak-tree-sitter">phaazon/kak-tree-sitter</a> (I’m stil working on it and it
lacks documentation but is usable).</li>
</ul>
<p>The interesting aspect with those tools is that, in <em>theory</em>, we could adapt them to make them editor independent. If
more editors adopted the strategy of Kakoune (composing via the shell), we wouldn’t even have to write other binaries to
add LSP / tree-sitter support, which is an interesting aspect.</p>
<p>I plan on writing a blog article detailing the design of <code>kak-tree-sitter</code>, because I think it’s a good source of
knowledge regarding UNIX and tree-sitter.</p>
<p>Besides that, Kakoune is way more mature than Helix, in the sense that it has some specificities to some edge cases with
multi-selection features (such as, what happens when you have multiple cursors inside text looking like function
argument lists, and you type <code>mia</code> to select them, but some selections are actually not arguments? Kakoune will remove
the mismatched selections, which is what we would expect, while Helix…… erm it’s complicated! but currently, it will
keep the selections around, which is confusing and dangerous).</p>
<p>Kakoune has a <em>wonderful</em> feature called <strong>marks</strong>. Marks are different from what you have in Vim. They use a specific
register to record the current selections and eventually restore them later, supporting merging selections and editing
commands. An example that I love doing; imagine the following snippet:</p>
<pre><code>Thank you to [@NAME](https://github.com/NAME) for their contribution.
</code></pre>
<p>Let’s say you want to have a cursor on each <code>NAME</code>. Easy, with <code>s</code>. You just select the whole thing (you can select the
whole line with <code>x</code> for instance), then <code>sNAME</code>, return, then <code>c</code> to start changing with whatever you want.</p>
<p>Now, imagine this instead:</p>
<pre><code>Thank you to [@](https://github.com/) for their contribution.
</code></pre>
<p>How do you insert at the same time at the right of <code>@</code> and before the <code>)</code>? Getting two selections will be hard (or you
will end up writing crazy regexes; remember, we are not using Vim anymore!). A super easy way to do it is to move your
selection to <code>@</code>:</p>
<pre><code>Thank you to [@|](https://github.com/) for their contribution.
</code></pre>
<p>Press <code>Z</code> to register the current selection (you have only one). Then move the cursor to the <code>)</code>:</p>
<pre><code>Thank you to [@](https://github.com/|) for their contribution.
</code></pre>
<p>And then press <code>&lt;a-z&gt;a</code> to merge the current selection to the one(s) already stored. You end up with this:</p>
<pre><code>Thank you to [@|](https://github.com/|) for their contribution.
</code></pre>
<p>Two cursors at the right places! This is extremely powerful and a feature that should arrive in Helix, but not sure
exactly when.</p>
<p>A pretty other important thing to say about Kakoune is that it has a server/client design that allows to share session
contexts. That is the main mechanisms used to implement native splits (via Kitty, tmux, whatever), but also many other
features, such as project isolation, viewing the same buffers with different highlighters, etc. etc.</p>
<h2>…but it’s not perfect</h2>
<p>There is one important thing I need to mention. I have been playing with Kakoune for a while now, and I have been
working on <code>kak-tree-sitter</code> for almost as long as I’ve been working Kakoune (couple of months). And there is one issue
with the UNIX approach.</p>
<p>See, tree-sitter, LSP, DAP, git gutters, etc. All those things are pretty <em>fundamental</em> to a modern text editor.
Externalizing them (Kakoune) is an interesting take, but I’m not entirely sure Kakoune is still doing it completely
correctly.</p>
<p>The main problem is <em>social intelligence</em>. Because all tooling is now externalized, many people can come up with
their own efforts. For instance, <code>kak-lsp</code> and <code>kak-tree-sitter</code> are completely separate projects, and they should
remain that way (for many reasons; scopes, maintenance, dependencies, etc.). However, in order to operate on the editor
contents, both programs must interact with the editor. That implies:</p>
<ul>
<li>Retrieving buffer contents.</li>
<li>Performing some actions that can mutate (and overlap / hijack) each other.</li>
<li>Insert hooks that might be incompatible between them.</li>
</ul>
<p>This problem is important, because dumping the whole content of a big buffer to an external process is one thing, doing
it for every different external processes is a massive overhead. Because I have read a bit the source code of <code>kak-lsp</code>,
I know that we (<code>kak-tree-sitter</code>) are doing similar things: we do use FIFOs to write buffer content and communicate
with our servers / daemons without going through the disk. But we are doing it that <em>twice</em>. And it’s just two projects;
any dissociate projects needing to access the buffer content will probably perform similar things.</p>
<p>That is a massive problem to me and I’m not sure how I feel about it. I’m not against sending the content of a buffer
via a FIFO to an externalized program — I actually think it’s a pretty good design —, but doing it for every
integration… I’m not exactly sure what would be the best solution, but maybe something that would snapshot a buffer
inside some POSIX shared memory (with mutable lock access if needed) could be one way to go. Honestely, I am not sure.</p>
<p>All of that to say that, the take of Helix is pretty good here, because all of those UNIX problems are not there in that
editor: everything runs in the same process, inside the same memory region. I will come back to this problem with my
next article on <code>kak-tree-sitter</code> and its design.</p>

<p>Today, I’m mainly using both Kakoune and Helix. Helix still has some bugs, even with tree-sitter (which my daemon
doesn’t have, funnily!), so I sometimes use one or the other tool.</p>
<p>I have learned so many things lately, with both Helix and Kakoune (especially Kakoune, it made me love UNIX even more).
All of that echoes the disclaimer I made earlier: yes, Vim and Neovim are good, but Kakoune and Helix are so much better
to me. Better designs, better editing experiences, largely snappier, more confidence in the direction of the
native code (because a much, much smaller codebase). Helix is written in Rust, Kakoune in C++, but what matters is the
actual design. To me, Kakoune is by far the best designed software I have ever seen, and for that, I really admire the
work of <a href="https://github.com/mawww">@mawww</a> and everyone else involved in the project. My contribution to the Kakoune
world with <a href="https://github.com/phaazon/kak-tree-sitter">kak-tree-sitter</a> is, I hope, something that will help and drive
more people in. I will write another blog article about that, with the pros., cons. and tradeoffs. of composability in
editors.</p>
<p>In the meantime, have fun and use the editor you love, but remember to have a look around and stay open to change! Keep
the vibes!</p>
<blockquote>
<p>I would like to thank <a href="https://github.com/taupiqueur/">@Taupiqueur</a>, who played an important role into making me
undersand Kakoune and eventually fall in love with — the editor, I mean! :)</p>
</blockquote>

  </div>
</section>


      
    </div></div>
  </body>
</html>
