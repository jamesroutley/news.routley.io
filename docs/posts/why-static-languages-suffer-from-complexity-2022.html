<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hirrolot.github.io/posts/why-static-languages-suffer-from-complexity.html">Original</a>
    <h1>Why Static Languages Suffer from Complexity (2022)</h1>
    
    <div id="readability-page-1" class="page"><div><a href="#record-type-array"><h2 id="record-type-array">Record type – Array</h2></a><p>Consider your everyday manipulation with record types (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=945f3a2f34937369495b3733718598a5">playground</a>):</p><p>
<code>automobile-static.rs</code>
</p><div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1"></a><span>struct</span> Automobile <span>{</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>    wheels<span>:</span> <span>u8</span><span>,</span></span>
<span id="cb1-3"><a href="#cb1-3"></a>    seats<span>:</span> <span>u8</span><span>,</span></span>
<span id="cb1-4"><a href="#cb1-4"></a>    manufacturer<span>:</span> <span>String</span><span>,</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span>}</span></span>
<span id="cb1-6"><a href="#cb1-6"></a></span>
<span id="cb1-7"><a href="#cb1-7"></a><span>fn</span> main() <span>{</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>    <span>let</span> my_car <span>=</span> Automobile <span>{</span></span>
<span id="cb1-9"><a href="#cb1-9"></a>        wheels<span>:</span> <span>4</span><span>,</span></span>
<span id="cb1-10"><a href="#cb1-10"></a>        seats<span>:</span> <span>4</span><span>,</span></span>
<span id="cb1-11"><a href="#cb1-11"></a>        manufacturer<span>:</span> <span>String</span><span>::</span>from(<span>&#34;X&#34;</span>)<span>,</span></span>
<span id="cb1-12"><a href="#cb1-12"></a>    <span>};</span></span>
<span id="cb1-13"><a href="#cb1-13"></a></span>
<span id="cb1-14"><a href="#cb1-14"></a>    <span>println!</span>(</span>
<span id="cb1-15"><a href="#cb1-15"></a>        <span>&#34;My car has {} wheels and {} seats, and it was made by {}.&#34;</span><span>,</span></span>
<span id="cb1-16"><a href="#cb1-16"></a>        my_car<span>.</span>wheels<span>,</span> my_car<span>.</span>seats<span>,</span> my_car<span>.</span>manufacturer</span>
<span id="cb1-17"><a href="#cb1-17"></a>    )<span>;</span></span>
<span id="cb1-18"><a href="#cb1-18"></a><span>}</span></span></code></pre></div><p>The same can be done using arrays (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=1dc3af0998b22c401a0042b081f441e1">playground</a>):</p><p>
<code>automobile-dynamic.rs</code>
</p><div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1"></a><span>use</span> <span>std::any::</span><span>Any</span><span>;</span></span>
<span id="cb2-2"><a href="#cb2-2"></a></span>
<span id="cb2-3"><a href="#cb2-3"></a><span>#[</span>repr<span>(</span><span>usize</span><span>)]</span></span>
<span id="cb2-4"><a href="#cb2-4"></a><span>enum</span> MyCar <span>{</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>    Wheels<span>,</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>    Seats<span>,</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>    Manufacturer<span>,</span></span>
<span id="cb2-8"><a href="#cb2-8"></a><span>}</span></span>
<span id="cb2-9"><a href="#cb2-9"></a></span>
<span id="cb2-10"><a href="#cb2-10"></a><span>fn</span> main() <span>{</span></span>
<span id="cb2-11"><a href="#cb2-11"></a>    <span>let</span> my_car<span>:</span> [<span>Box</span><span>&lt;</span><span>dyn</span> <span>Any</span><span>&gt;;</span> <span>3</span>] <span>=</span> [<span>Box</span><span>::</span>new(<span>4</span>)<span>,</span> <span>Box</span><span>::</span>new(<span>4</span>)<span>,</span> <span>Box</span><span>::</span>new(<span>&#34;X&#34;</span>)]<span>;</span></span>
<span id="cb2-12"><a href="#cb2-12"></a></span>
<span id="cb2-13"><a href="#cb2-13"></a>    <span>println!</span>(</span>
<span id="cb2-14"><a href="#cb2-14"></a>        <span>&#34;My car has {} wheels and {} seats, and it was made by {}.&#34;</span><span>,</span></span>
<span id="cb2-15"><a href="#cb2-15"></a>        my_car[<span>MyCar::</span>Wheels <span>as</span> <span>usize</span>]</span>
<span id="cb2-16"><a href="#cb2-16"></a>            <span>.</span><span>downcast_ref::</span><span>&lt;</span><span>i32</span><span>&gt;</span>()</span>
<span id="cb2-17"><a href="#cb2-17"></a>            <span>.</span>unwrap()<span>,</span></span>
<span id="cb2-18"><a href="#cb2-18"></a>        my_car[<span>MyCar::</span>Seats <span>as</span> <span>usize</span>]<span>.</span><span>downcast_ref::</span><span>&lt;</span><span>i32</span><span>&gt;</span>()<span>.</span>unwrap()<span>,</span></span>
<span id="cb2-19"><a href="#cb2-19"></a>        my_car[<span>MyCar::</span>Manufacturer <span>as</span> <span>usize</span>]</span>
<span id="cb2-20"><a href="#cb2-20"></a>            <span>.</span><span>downcast_ref::</span><span>&lt;&amp;</span><span>&#39;static</span> <span>str</span><span>&gt;</span>()</span>
<span id="cb2-21"><a href="#cb2-21"></a>            <span>.</span>unwrap()</span>
<span id="cb2-22"><a href="#cb2-22"></a>    )<span>;</span></span>
<span id="cb2-23"><a href="#cb2-23"></a><span>}</span></span></code></pre></div><p>Yes, if we specify an incorrect type to <code>.downcast_ref</code>,
we will get a panic. But the very <strong>logic</strong> of the program
remains the same, only we elevate type checking to run-time.</p><p>Going further, we can encode static <code>Automobile</code> as a
heterogenous list:</p><p>
<code>automobile-hlist.rs</code>
</p><div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1"></a><span>use</span> <span>frunk::</span><span>{</span>hlist<span>,</span> HList<span>};</span></span>
<span id="cb3-2"><a href="#cb3-2"></a></span>
<span id="cb3-3"><a href="#cb3-3"></a><span>struct</span> Wheels(<span>u8</span>)<span>;</span></span>
<span id="cb3-4"><a href="#cb3-4"></a><span>struct</span> Seats(<span>u8</span>)<span>;</span></span>
<span id="cb3-5"><a href="#cb3-5"></a><span>struct</span> Manufacturer(<span>String</span>)<span>;</span></span>
<span id="cb3-6"><a href="#cb3-6"></a><span>type</span> Automobile <span>=</span> <span>HList!</span>[Wheels<span>,</span> Seats<span>,</span> Manufacturer]<span>;</span></span>
<span id="cb3-7"><a href="#cb3-7"></a></span>
<span id="cb3-8"><a href="#cb3-8"></a><span>fn</span> main() <span>{</span></span>
<span id="cb3-9"><a href="#cb3-9"></a>    <span>let</span> my_car<span>:</span> Automobile <span>=</span> <span>hlist!</span>[Wheels(<span>4</span>)<span>,</span> Seats(<span>4</span>)<span>,</span> Manufacturer(<span>String</span><span>::</span>from(<span>&#34;X&#34;</span>))]<span>;</span></span>
<span id="cb3-10"><a href="#cb3-10"></a></span>
<span id="cb3-11"><a href="#cb3-11"></a>    <span>println!</span>(</span>
<span id="cb3-12"><a href="#cb3-12"></a>        <span>&#34;My car has {} wheels and {} seats, and it was made by {}.&#34;</span><span>,</span></span>
<span id="cb3-13"><a href="#cb3-13"></a>        my_car<span>.</span><span>get::</span><span>&lt;</span>Wheels<span>,</span> _<span>&gt;</span>()<span>.</span><span>0</span><span>,</span></span>
<span id="cb3-14"><a href="#cb3-14"></a>        my_car<span>.</span><span>get::</span><span>&lt;</span>Seats<span>,</span> _<span>&gt;</span>()<span>.</span><span>0</span><span>,</span></span>
<span id="cb3-15"><a href="#cb3-15"></a>        my_car<span>.</span><span>get::</span><span>&lt;</span>Manufacturer<span>,</span> _<span>&gt;</span>()<span>.</span><span>0</span></span>
<span id="cb3-16"><a href="#cb3-16"></a>    )<span>;</span></span>
<span id="cb3-17"><a href="#cb3-17"></a><span>}</span></span></code></pre></div><p>This version enforces exactly the same type checks as
<code>automobile-static.rs</code>, but additionally provides <a href="https://docs.rs/frunk/0.4.0/frunk/hlist/struct.HCons.html#implementations">methods</a>
for manipulating with <code>type Automobile</code> as with ordinary
collections! E.g., we may want to reverse our automobile <a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a>:</p><div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1"></a><span>assert_eq!</span>(</span>
<span id="cb4-2"><a href="#cb4-2"></a>    my_car<span>.</span>into_reverse()<span>,</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>    <span>hlist!</span>[Manufacturer(<span>String</span><span>::</span>from(<span>&#34;X&#34;</span>))<span>,</span> Seats(<span>4</span>)<span>,</span> Wheels(<span>4</span>)]</span>
<span id="cb4-4"><a href="#cb4-4"></a>)<span>;</span></span></code></pre></div><p>Or we may want to zip our car with their car:</p><div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1"></a><span>let</span> their_car <span>=</span> <span>hlist!</span>[Wheels(<span>6</span>)<span>,</span> Seats(<span>4</span>)<span>,</span> Manufacturer(<span>String</span><span>::</span>from(<span>&#34;Y&#34;</span>))]<span>;</span></span>
<span id="cb5-2"><a href="#cb5-2"></a></span>
<span id="cb5-3"><a href="#cb5-3"></a><span>assert_eq!</span>(</span>
<span id="cb5-4"><a href="#cb5-4"></a>    my_car<span>.</span>zip(their_car)<span>,</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>    <span>hlist!</span>[</span>
<span id="cb5-6"><a href="#cb5-6"></a>        (Wheels(<span>4</span>)<span>,</span> Wheels(<span>6</span>))<span>,</span></span>
<span id="cb5-7"><a href="#cb5-7"></a>        (Seats(<span>4</span>)<span>,</span> Seats(<span>4</span>))<span>,</span></span>
<span id="cb5-8"><a href="#cb5-8"></a>        (Manufacturer(<span>String</span><span>::</span>from(<span>&#34;X&#34;</span>))<span>,</span> Manufacturer(<span>String</span><span>::</span>from(<span>&#34;Y&#34;</span>)))</span>
<span id="cb5-9"><a href="#cb5-9"></a>    ]</span>
<span id="cb5-10"><a href="#cb5-10"></a>)<span>;</span></span></code></pre></div><p>… And so forth.</p><p>However, sometimes we may want to apply type-level computation to
ordinary <code>struct</code>s and <code>enum</code>s, but we cannot do
it because we are unable to extract the very structure of a type
definition (fields and types/variants and their function signatures)
from a corresponding type name, especially if this type is external to
our crate and we cannot put a derive macro onto it <a href="#fn3" id="fnref3" role="doc-noteref"><sup>3</sup></a>. To
resolve the issue, Frunk developers decided to create such a procedural
macro that examines the internal structure of a type definition by
implementing the <a href="https://docs.rs/frunk/latest/frunk/generic/trait.Generic.html"><code>Generic</code></a>
trait for it; it has the <code>type Repr</code> associated type, which,
when implemented, equals to some form of a manipulatable heterogenous
list. Still, all other types (well, transparent ones, such as <a href="https://en.wikipedia.org/wiki/Data_transfer_object">DTOs</a>) that
do not have this derive macro, are left unexaminable, owing to the
aforementioned limitations of Rust.</p><p><img src="https://hirrolot.github.io/media/why-static-languages-suffer-from-complexity/rust-meme.png"/></p><a href="#sum-type-tree"><h2 id="sum-type-tree">Sum type – Tree</h2></a><p>One may find sum types good to represent an AST node (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=e5031b0c2888fe9ea336789ee1cdf049">playground</a>):</p><p>
<code>ast-static.rs</code>
</p><div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1"></a><span>use</span> <span>std::ops::</span><span>Deref</span><span>;</span></span>
<span id="cb6-2"><a href="#cb6-2"></a></span>
<span id="cb6-3"><a href="#cb6-3"></a><span>enum</span> Expr <span>{</span></span>
<span id="cb6-4"><a href="#cb6-4"></a>    Const(<span>i32</span>)<span>,</span></span>
<span id="cb6-5"><a href="#cb6-5"></a>    <span>Add</span>(<span>Box</span><span>&lt;</span>Expr<span>&gt;,</span> <span>Box</span><span>&lt;</span>Expr<span>&gt;</span>)<span>,</span></span>
<span id="cb6-6"><a href="#cb6-6"></a>    <span>Sub</span>(<span>Box</span><span>&lt;</span>Expr<span>&gt;,</span> <span>Box</span><span>&lt;</span>Expr<span>&gt;</span>)<span>,</span></span>
<span id="cb6-7"><a href="#cb6-7"></a>    <span>Mul</span>(<span>Box</span><span>&lt;</span>Expr<span>&gt;,</span> <span>Box</span><span>&lt;</span>Expr<span>&gt;</span>)<span>,</span></span>
<span id="cb6-8"><a href="#cb6-8"></a>    <span>Div</span>(<span>Box</span><span>&lt;</span>Expr<span>&gt;,</span> <span>Box</span><span>&lt;</span>Expr<span>&gt;</span>)<span>,</span></span>
<span id="cb6-9"><a href="#cb6-9"></a><span>}</span></span>
<span id="cb6-10"><a href="#cb6-10"></a></span>
<span id="cb6-11"><a href="#cb6-11"></a><span>use</span> <span>Expr::</span><span>*;</span></span>
<span id="cb6-12"><a href="#cb6-12"></a></span>
<span id="cb6-13"><a href="#cb6-13"></a><span>fn</span> eval(expr<span>:</span> <span>&amp;</span><span>Box</span><span>&lt;</span>Expr<span>&gt;</span>) <span>-&gt;</span> <span>i32</span> <span>{</span></span>
<span id="cb6-14"><a href="#cb6-14"></a>    <span>match</span> expr<span>.</span>deref() <span>{</span></span>
<span id="cb6-15"><a href="#cb6-15"></a>        Const(x) <span>=&gt;</span> <span>*</span>x<span>,</span></span>
<span id="cb6-16"><a href="#cb6-16"></a>        <span>Add</span>(lhs<span>,</span> rhs) <span>=&gt;</span> eval(<span>&amp;</span>lhs) <span>+</span> eval(<span>&amp;</span>rhs)<span>,</span></span>
<span id="cb6-17"><a href="#cb6-17"></a>        <span>Sub</span>(lhs<span>,</span> rhs) <span>=&gt;</span> eval(<span>&amp;</span>lhs) <span>-</span> eval(<span>&amp;</span>rhs)<span>,</span></span>
<span id="cb6-18"><a href="#cb6-18"></a>        <span>Mul</span>(lhs<span>,</span> rhs) <span>=&gt;</span> eval(<span>&amp;</span>lhs) <span>*</span> eval(<span>&amp;</span>rhs)<span>,</span></span>
<span id="cb6-19"><a href="#cb6-19"></a>        <span>Div</span>(lhs<span>,</span> rhs) <span>=&gt;</span> eval(<span>&amp;</span>lhs) <span>/</span> eval(<span>&amp;</span>rhs)<span>,</span></span>
<span id="cb6-20"><a href="#cb6-20"></a>    <span>}</span></span>
<span id="cb6-21"><a href="#cb6-21"></a><span>}</span></span>
<span id="cb6-22"><a href="#cb6-22"></a></span>
<span id="cb6-23"><a href="#cb6-23"></a><span>fn</span> main() <span>{</span></span>
<span id="cb6-24"><a href="#cb6-24"></a>    <span>let</span> expr<span>:</span> Expr <span>=</span> <span>Add</span>(</span>
<span id="cb6-25"><a href="#cb6-25"></a>        Const(<span>53</span>)<span>.</span>into()<span>,</span></span>
<span id="cb6-26"><a href="#cb6-26"></a>        <span>Sub</span>(</span>
<span id="cb6-27"><a href="#cb6-27"></a>            <span>Div</span>(Const(<span>155</span>)<span>.</span>into()<span>,</span> Const(<span>5</span>)<span>.</span>into())<span>.</span>into()<span>,</span></span>
<span id="cb6-28"><a href="#cb6-28"></a>            Const(<span>113</span>)<span>.</span>into()<span>,</span></span>
<span id="cb6-29"><a href="#cb6-29"></a>        )</span>
<span id="cb6-30"><a href="#cb6-30"></a>        <span>.</span>into()<span>,</span></span>
<span id="cb6-31"><a href="#cb6-31"></a>    )<span>;</span></span>
<span id="cb6-32"><a href="#cb6-32"></a></span>
<span id="cb6-33"><a href="#cb6-33"></a>    <span>println!</span>(<span>&#34;{}&#34;</span><span>,</span> eval(<span>&amp;</span>expr<span>.</span>into()))<span>;</span></span>
<span id="cb6-34"><a href="#cb6-34"></a><span>}</span></span></code></pre></div><p>The same can be done using tagged trees (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=6da60ed991ab6e6511c4572549047f62">playground</a>):</p><p>
<code>ast-dynamic.rs</code>
</p><div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1"></a><span>use</span> <span>std::any::</span><span>Any</span><span>;</span></span>
<span id="cb7-2"><a href="#cb7-2"></a></span>
<span id="cb7-3"><a href="#cb7-3"></a><span>struct</span> Tree <span>{</span></span>
<span id="cb7-4"><a href="#cb7-4"></a>    tag<span>:</span> <span>i32</span><span>,</span></span>
<span id="cb7-5"><a href="#cb7-5"></a>    value<span>:</span> <span>Box</span><span>&lt;</span><span>dyn</span> <span>Any</span><span>&gt;,</span></span>
<span id="cb7-6"><a href="#cb7-6"></a>    nodes<span>:</span> <span>Vec</span><span>&lt;</span><span>Box</span><span>&lt;</span>Tree<span>&gt;&gt;,</span></span>
<span id="cb7-7"><a href="#cb7-7"></a><span>}</span></span>
<span id="cb7-8"><a href="#cb7-8"></a></span>
<span id="cb7-9"><a href="#cb7-9"></a><span>const</span> AST_TAG_CONST<span>:</span> <span>i32</span> <span>=</span> <span>0</span><span>;</span></span>
<span id="cb7-10"><a href="#cb7-10"></a><span>const</span> AST_TAG_ADD<span>:</span> <span>i32</span> <span>=</span> <span>1</span><span>;</span></span>
<span id="cb7-11"><a href="#cb7-11"></a><span>const</span> AST_TAG_SUB<span>:</span> <span>i32</span> <span>=</span> <span>2</span><span>;</span></span>
<span id="cb7-12"><a href="#cb7-12"></a><span>const</span> AST_TAG_MUL<span>:</span> <span>i32</span> <span>=</span> <span>3</span><span>;</span></span>
<span id="cb7-13"><a href="#cb7-13"></a><span>const</span> AST_TAG_DIV<span>:</span> <span>i32</span> <span>=</span> <span>4</span><span>;</span></span>
<span id="cb7-14"><a href="#cb7-14"></a></span>
<span id="cb7-15"><a href="#cb7-15"></a><span>fn</span> eval(expr<span>:</span> <span>&amp;</span>Tree) <span>-&gt;</span> <span>i32</span> <span>{</span></span>
<span id="cb7-16"><a href="#cb7-16"></a>    <span>let</span> lhs <span>=</span> expr<span>.</span>nodes<span>.</span>get(<span>0</span>)<span>;</span></span>
<span id="cb7-17"><a href="#cb7-17"></a>    <span>let</span> rhs <span>=</span> expr<span>.</span>nodes<span>.</span>get(<span>1</span>)<span>;</span></span>
<span id="cb7-18"><a href="#cb7-18"></a></span>
<span id="cb7-19"><a href="#cb7-19"></a>    <span>match</span> expr<span>.</span>tag <span>{</span></span>
<span id="cb7-20"><a href="#cb7-20"></a>        AST_TAG_CONST <span>=&gt;</span> <span>*</span>expr<span>.</span>value<span>.</span><span>downcast_ref::</span><span>&lt;</span><span>i32</span><span>&gt;</span>()<span>.</span>unwrap()<span>,</span></span>
<span id="cb7-21"><a href="#cb7-21"></a>        AST_TAG_ADD <span>=&gt;</span> eval(<span>&amp;</span>lhs<span>.</span>unwrap()) <span>+</span> eval(<span>&amp;</span>rhs<span>.</span>unwrap())<span>,</span></span>
<span id="cb7-22"><a href="#cb7-22"></a>        AST_TAG_SUB <span>=&gt;</span> eval(<span>&amp;</span>lhs<span>.</span>unwrap()) <span>-</span> eval(<span>&amp;</span>rhs<span>.</span>unwrap())<span>,</span></span>
<span id="cb7-23"><a href="#cb7-23"></a>        AST_TAG_MUL <span>=&gt;</span> eval(<span>&amp;</span>lhs<span>.</span>unwrap()) <span>*</span> eval(<span>&amp;</span>rhs<span>.</span>unwrap())<span>,</span></span>
<span id="cb7-24"><a href="#cb7-24"></a>        AST_TAG_DIV <span>=&gt;</span> eval(<span>&amp;</span>lhs<span>.</span>unwrap()) <span>/</span> eval(<span>&amp;</span>rhs<span>.</span>unwrap())<span>,</span></span>
<span id="cb7-25"><a href="#cb7-25"></a>        _ <span>=&gt;</span> <span>panic!</span>(<span>&#34;Out of range&#34;</span>)<span>,</span></span>
<span id="cb7-26"><a href="#cb7-26"></a>    <span>}</span></span>
<span id="cb7-27"><a href="#cb7-27"></a><span>}</span></span>
<span id="cb7-28"><a href="#cb7-28"></a></span>
<span id="cb7-29"><a href="#cb7-29"></a><span>fn</span> main() <span>{</span></span>
<span id="cb7-30"><a href="#cb7-30"></a>    <span>let</span> expr <span>=</span> <span>/* Construction omitted... */</span><span>;</span></span>
<span id="cb7-31"><a href="#cb7-31"></a></span>
<span id="cb7-32"><a href="#cb7-32"></a>    <span>println!</span>(<span>&#34;{}&#34;</span><span>,</span> eval(<span>&amp;</span>expr))<span>;</span></span>
<span id="cb7-33"><a href="#cb7-33"></a><span>}</span></span></code></pre></div><p>Similarly to how we did with <code>struct Automobile</code>, we can
represent <code>enum Expr</code> as <a href="https://beachape.com/frunk/frunk/coproduct/enum.Coproduct.html"><code>frunk::Coproduct</code></a>.
This is left as an exercise to the reader.</p><a href="#value-associated-type"><h2 id="value-associated-type">Value – Associated type</h2></a><p>We may want to negate a boolean value using the standard operator
<code>!</code> (<a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=0dea07f96037bce0e82a2c93c77898b0">playground</a>):</p><p>
<code>negate-dynamic.rs</code>
</p><div id="cb8"><pre><code><span id="cb8-1"><a href="#cb8-1"></a><span>fn</span> main() <span>{</span></span>
<span id="cb8-2"><a href="#cb8-2"></a>    <span>assert_eq!</span>(<span>!</span><span>true</span><span>,</span> <span>false</span>)<span>;</span></span>
<span id="cb8-3"><a href="#cb8-3"></a>    <span>assert_eq!</span>(<span>!</span><span>false</span><span>,</span> <span>true</span>)<span>;</span></span>
<span id="cb8-4"><a href="#cb8-4"></a><span>}</span></span></code></pre></div><p>The same can be done through associated types <a href="#fn4" id="fnref4" role="doc-noteref"><sup>4</sup></a> (<a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=e101a1a384390a1d502aa514b21f9954">playground</a>):</p><p>
<code>negate-static.rs</code>
</p><div id="cb9"><pre><code><span id="cb9-1"><a href="#cb9-1"></a><span>use</span> <span>std::marker::</span>PhantomData<span>;</span></span>
<span id="cb9-2"><a href="#cb9-2"></a></span>
<span id="cb9-3"><a href="#cb9-3"></a><span>trait</span> Bool <span>{</span></span>
<span id="cb9-4"><a href="#cb9-4"></a>    <span>type</span> Value<span>;</span></span>
<span id="cb9-5"><a href="#cb9-5"></a><span>}</span></span>
<span id="cb9-6"><a href="#cb9-6"></a></span>
<span id="cb9-7"><a href="#cb9-7"></a><span>struct</span> True<span>;</span></span>
<span id="cb9-8"><a href="#cb9-8"></a><span>struct</span> False<span>;</span></span>
<span id="cb9-9"><a href="#cb9-9"></a></span>
<span id="cb9-10"><a href="#cb9-10"></a><span>impl</span> Bool <span>for</span> True <span>{</span> <span>type</span> Value <span>=</span> True<span>;</span> <span>}</span></span>
<span id="cb9-11"><a href="#cb9-11"></a><span>impl</span> Bool <span>for</span> False <span>{</span> <span>type</span> Value <span>=</span> False<span>;</span> <span>}</span></span>
<span id="cb9-12"><a href="#cb9-12"></a></span>
<span id="cb9-13"><a href="#cb9-13"></a><span>struct</span> Negate<span>&lt;</span>Cond<span>&gt;</span>(PhantomData<span>&lt;</span>Cond<span>&gt;</span>)<span>;</span></span>
<span id="cb9-14"><a href="#cb9-14"></a></span>
<span id="cb9-15"><a href="#cb9-15"></a><span>impl</span> Bool <span>for</span> Negate<span>&lt;</span>True<span>&gt;</span> <span>{</span></span>
<span id="cb9-16"><a href="#cb9-16"></a>    <span>type</span> Value <span>=</span> False<span>;</span></span>
<span id="cb9-17"><a href="#cb9-17"></a><span>}</span></span>
<span id="cb9-18"><a href="#cb9-18"></a></span>
<span id="cb9-19"><a href="#cb9-19"></a><span>impl</span> Bool <span>for</span> Negate<span>&lt;</span>False<span>&gt;</span> <span>{</span></span>
<span id="cb9-20"><a href="#cb9-20"></a>    <span>type</span> Value <span>=</span> True<span>;</span></span>
<span id="cb9-21"><a href="#cb9-21"></a><span>}</span></span>
<span id="cb9-22"><a href="#cb9-22"></a></span>
<span id="cb9-23"><a href="#cb9-23"></a><span>const</span> ThisIsFalse<span>:</span> <span>&lt;</span>Negate<span>&lt;</span>True<span>&gt;</span> <span>as</span> Bool<span>&gt;</span><span>::</span>Value <span>=</span> False<span>;</span></span>
<span id="cb9-24"><a href="#cb9-24"></a><span>const</span> ThisIsTrue<span>:</span> <span>&lt;</span>Negate<span>&lt;</span>False<span>&gt;</span> <span>as</span> Bool<span>&gt;</span><span>::</span>Value <span>=</span> True<span>;</span></span></code></pre></div><p>In fact, the <a href="https://sdleffler.github.io/RustTypeSystemTuringComplete/">Turing
completeness of Rust’s type system</a> is built upon this principle
combined with type induction (which we shall see a bit later). Every
time you see an ordinary value in terms of Rust, know that it has its
formal correspondence on the type-level, in the computational sense.
Every time you write some algorithm, it has its correspondence on the
type-level, using conceptually equivalent constructions! If you are
interested in <em>how</em>, the above article provides a
<strong>mathematical proof</strong>: first, the author implements
so-called Smallfuck using <em>dynamics</em>: a sum type, pattern
matching, recursion, and then using <em>statics</em>: logic on traits,
associated types, etc.</p><a href="#recursion-type-level-induction"><h2 id="recursion-type-level-induction">Recursion – Type-level
induction</h2></a><p>Let me show you one more example. But hold on tight this time (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=4b13a54fa1a41d928508546ef741700e">playground</a>)!</p><p>
<code>peano-dynamic.rs</code>
</p><div id="cb10"><pre><code><span id="cb10-1"><a href="#cb10-1"></a><span>use</span> <span>std::ops::</span><span>Deref</span><span>;</span></span>
<span id="cb10-2"><a href="#cb10-2"></a></span>
<span id="cb10-3"><a href="#cb10-3"></a><span>#[</span>derive<span>(</span><span>Clone</span><span>,</span> <span>Debug</span><span>,</span> <span>PartialEq</span><span>)]</span></span>
<span id="cb10-4"><a href="#cb10-4"></a><span>enum</span> Nat <span>{</span></span>
<span id="cb10-5"><a href="#cb10-5"></a>    Z<span>,</span></span>
<span id="cb10-6"><a href="#cb10-6"></a>    S(<span>Box</span><span>&lt;</span>Nat<span>&gt;</span>)<span>,</span></span>
<span id="cb10-7"><a href="#cb10-7"></a><span>}</span></span>
<span id="cb10-8"><a href="#cb10-8"></a></span>
<span id="cb10-9"><a href="#cb10-9"></a><span>fn</span> add(lhs<span>:</span> <span>&amp;</span><span>Box</span><span>&lt;</span>Nat<span>&gt;,</span> rhs<span>:</span> <span>&amp;</span><span>Box</span><span>&lt;</span>Nat<span>&gt;</span>) <span>-&gt;</span> Nat <span>{</span></span>
<span id="cb10-10"><a href="#cb10-10"></a>    <span>match</span> lhs<span>.</span>deref() <span>{</span></span>
<span id="cb10-11"><a href="#cb10-11"></a>        <span>Nat::</span>Z <span>=&gt;</span> rhs<span>.</span>deref()<span>.</span>clone()<span>,</span> <span>// I</span></span>
<span id="cb10-12"><a href="#cb10-12"></a>        <span>Nat::</span>S(next) <span>=&gt;</span> <span>Nat::</span>S(<span>Box</span><span>::</span>new(add(next<span>,</span> rhs)))<span>,</span> <span>// II</span></span>
<span id="cb10-13"><a href="#cb10-13"></a>    <span>}</span></span>
<span id="cb10-14"><a href="#cb10-14"></a><span>}</span></span>
<span id="cb10-15"><a href="#cb10-15"></a></span>
<span id="cb10-16"><a href="#cb10-16"></a><span>fn</span> main() <span>{</span></span>
<span id="cb10-17"><a href="#cb10-17"></a>    <span>let</span> one <span>=</span> <span>Nat::</span>S(<span>Nat::</span>Z<span>.</span>into())<span>;</span></span>
<span id="cb10-18"><a href="#cb10-18"></a>    <span>let</span> two <span>=</span> <span>Nat::</span>S(one<span>.</span>clone()<span>.</span>into())<span>;</span></span>
<span id="cb10-19"><a href="#cb10-19"></a>    <span>let</span> three <span>=</span> <span>Nat::</span>S(two<span>.</span>clone()<span>.</span>into())<span>;</span></span>
<span id="cb10-20"><a href="#cb10-20"></a></span>
<span id="cb10-21"><a href="#cb10-21"></a>    <span>assert_eq!</span>(add(<span>&amp;</span>one<span>.</span>into()<span>,</span> <span>&amp;</span>two<span>.</span>into())<span>,</span> three)<span>;</span></span>
<span id="cb10-22"><a href="#cb10-22"></a><span>}</span></span></code></pre></div><p>This is the <a href="https://en.wikipedia.org/wiki/Peano_axioms">Peano encoding</a> of
a natural number. In the <code>add</code> function, we use recursion to
compute a sum and pattern matching to find out where to stop.</p><p>As recursion corresponds to type induction and pattern matching
corresponds to multiple implementations, the same can be done at
compile-time (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=d4c34d5ca2d4ea81c704aeb22a443e0f">playground</a>):</p><p>
<code>peano-static.rs</code>
</p><div id="cb11"><pre><code><span id="cb11-1"><a href="#cb11-1"></a><span>use</span> <span>std::marker::</span>PhantomData<span>;</span></span>
<span id="cb11-2"><a href="#cb11-2"></a></span>
<span id="cb11-3"><a href="#cb11-3"></a><span>struct</span> Z<span>;</span></span>
<span id="cb11-4"><a href="#cb11-4"></a><span>struct</span> S<span>&lt;</span>Next<span>&gt;</span>(PhantomData<span>&lt;</span>Next<span>&gt;</span>)<span>;</span></span>
<span id="cb11-5"><a href="#cb11-5"></a></span>
<span id="cb11-6"><a href="#cb11-6"></a><span>trait</span> <span>Add</span><span>&lt;</span>Rhs<span>&gt;</span> <span>{</span></span>
<span id="cb11-7"><a href="#cb11-7"></a>    <span>type</span> Result<span>;</span></span>
<span id="cb11-8"><a href="#cb11-8"></a><span>}</span></span>
<span id="cb11-9"><a href="#cb11-9"></a></span>
<span id="cb11-10"><a href="#cb11-10"></a><span>// I</span></span>
<span id="cb11-11"><a href="#cb11-11"></a><span>impl</span><span>&lt;</span>Rhs<span>&gt;</span> <span>Add</span><span>&lt;</span>Rhs<span>&gt;</span> <span>for</span> Z <span>{</span></span>
<span id="cb11-12"><a href="#cb11-12"></a>    <span>type</span> Result <span>=</span> Rhs<span>;</span></span>
<span id="cb11-13"><a href="#cb11-13"></a><span>}</span></span>
<span id="cb11-14"><a href="#cb11-14"></a></span>
<span id="cb11-15"><a href="#cb11-15"></a><span>// II</span></span>
<span id="cb11-16"><a href="#cb11-16"></a><span>impl</span><span>&lt;</span>Lhs<span>:</span> <span>Add</span><span>&lt;</span>Rhs<span>&gt;,</span> Rhs<span>&gt;</span> <span>Add</span><span>&lt;</span>Rhs<span>&gt;</span> <span>for</span> S<span>&lt;</span>Lhs<span>&gt;</span> <span>{</span></span>
<span id="cb11-17"><a href="#cb11-17"></a>    <span>type</span> Result <span>=</span> S<span>&lt;&lt;</span>Lhs <span>as</span> <span>Add</span><span>&lt;</span>Rhs<span>&gt;&gt;</span><span>::</span><span>Result</span><span>&gt;;</span></span>
<span id="cb11-18"><a href="#cb11-18"></a><span>}</span></span>
<span id="cb11-19"><a href="#cb11-19"></a></span>
<span id="cb11-20"><a href="#cb11-20"></a><span>type</span> One <span>=</span> S<span>&lt;</span>Z<span>&gt;;</span></span>
<span id="cb11-21"><a href="#cb11-21"></a><span>type</span> Two <span>=</span> S<span>&lt;</span>One<span>&gt;;</span></span>
<span id="cb11-22"><a href="#cb11-22"></a><span>type</span> Three <span>=</span> S<span>&lt;</span>Two<span>&gt;;</span></span>
<span id="cb11-23"><a href="#cb11-23"></a></span>
<span id="cb11-24"><a href="#cb11-24"></a><span>const</span> THREE<span>:</span> <span>&lt;</span>One <span>as</span> <span>Add</span><span>&lt;</span>Two<span>&gt;&gt;</span><span>::</span><span>Result</span> <span>=</span> S(PhantomData)<span>;</span></span></code></pre></div><p>Here, <code>impl ... for Z</code> is the base case (termination
case), and <code>impl ... for S&lt;Lhs&gt;</code> is the induction step
(recursion case) – similar to how we did with pattern matching using
<code>match</code>. Likewise, as in the first example, the induction
works by reducing the first argument to <code>Z</code>:
<code>&lt;Lhs as Add&lt;Rhs&gt;&gt;::Result</code> works just like
<code>add(next, rhs)</code> – it invokes pattern matching once again to
drive the computation further. Note that the two trait implementations
indeed belong to the same logical function implementation; they look
detached because we perform pattern matching on our type-level number
(<code>Z</code> and <code>S&lt;Next&gt;</code>). This is somewhat
similar to what we are used to see in Haskell, where each pattern
matching case looks like a separate function definition:</p><p>
<code>peano-static.hs</code>
</p><div id="cb12"><pre><code><span id="cb12-1"><a href="#cb12-1"></a><span>import</span> <span>Control.Exception</span></span>
<span id="cb12-2"><a href="#cb12-2"></a></span>
<span id="cb12-3"><a href="#cb12-3"></a><span>data</span> <span>Nat</span> <span>=</span> <span>Z</span> <span>|</span> <span>S</span> <span>Nat</span> <span>deriving</span> <span>Eq</span></span>
<span id="cb12-4"><a href="#cb12-4"></a></span>
<span id="cb12-5"><a href="#cb12-5"></a><span>add ::</span> <span>Nat</span> <span>-&gt;</span> <span>Nat</span> <span>-&gt;</span> <span>Nat</span></span>
<span id="cb12-6"><a href="#cb12-6"></a>add <span>Z</span> rhs <span>=</span> rhs <span>-- I</span></span>
<span id="cb12-7"><a href="#cb12-7"></a>add (<span>S</span> next) rhs <span>=</span> <span>S</span>(add next rhs) <span>-- II</span></span>
<span id="cb12-8"><a href="#cb12-8"></a></span>
<span id="cb12-9"><a href="#cb12-9"></a>one <span>=</span> <span>S</span> <span>Z</span></span>
<span id="cb12-10"><a href="#cb12-10"></a>two <span>=</span> <span>S</span> one</span>
<span id="cb12-11"><a href="#cb12-11"></a>three <span>=</span> <span>S</span> two</span>
<span id="cb12-12"><a href="#cb12-12"></a></span>
<span id="cb12-13"><a href="#cb12-13"></a><span>main ::</span> <span>IO</span> ()</span>
<span id="cb12-14"><a href="#cb12-14"></a>main <span>=</span> assert ((add one two) <span>==</span> three) <span>$</span> <span>pure</span> ()</span></code></pre></div><a href="#type-level-logic-reified"><h2 id="type-level-logic-reified">Type-level logic reified</h2></a><p><img src="https://hirrolot.github.io/media/why-static-languages-suffer-from-complexity/chad-meme.png"/></p><p>The purpose of this writeup is only to convey the intuition behind
the statics-dynamics biformity and not to provide a formal proof – for
the latter, please refer to an awesome library called <a href="https://crates.io/crates/type-operators"><code>type-operators</code></a>
(by the same person who implemented Smallfuck on types). In essence, it
is an algorithmic macro eDSL that boils down to type-level manipulation
with traits: you can define algebraic data types and perform data
manipulations on them similar to how you normally do in Rust, but in the
end, the whole code will dwell on the type-level. For more details, see
the <a href="https://github.com/sdleffler/type-operators-rs/blob/master/src/lib.rs">translation
rules</a> and an <a href="https://github.com/sdleffler/type-operators-rs/blob/master/README.md">excellent
guide</a> by the same author. Another noteworthy project is <a href="https://github.com/Ashymad/fortraith">Fortraith</a>, which is a
“compile-time compiler that compiles Forth to compile-time trait
expressions”:</p><div id="cb13"><pre><code><span id="cb13-1"><a href="#cb13-1"></a><span>forth!</span>(</span>
<span id="cb13-2"><a href="#cb13-2"></a>    <span>:</span> factorial (n <span>--</span> n) <span>1</span> swap fact0 <span>;</span></span>
<span id="cb13-3"><a href="#cb13-3"></a>    <span>:</span> fact0 (n n <span>--</span> n) dup <span>1</span> <span>=</span> <span>if</span> drop <span>else</span> dup rot <span>*</span> swap pred fact0 then <span>;</span></span>
<span id="cb13-4"><a href="#cb13-4"></a>    <span>5</span> factorial <span>.</span></span>
<span id="cb13-5"><a href="#cb13-5"></a>)<span>;</span></span></code></pre></div><p>The above code translates a simple factorial implementation to
computation on traits and associated types. Later, you obtain a result
as follows:</p><div id="cb14"><pre><code><span id="cb14-1"><a href="#cb14-1"></a><span>println!</span>(</span>
<span id="cb14-2"><a href="#cb14-2"></a>    <span>&#34;{}&#34;</span><span>,</span></span>
<span id="cb14-3"><a href="#cb14-3"></a>    <span>&lt;&lt;&lt;</span>Empty <span>as</span> five<span>&gt;</span><span>::</span><span>Result</span> <span>as</span> factorial<span>&gt;</span><span>::</span><span>Result</span> <span>as</span> top<span>&gt;</span><span>::</span><span>Result</span><span>::</span>eval()</span>
<span id="cb14-4"><a href="#cb14-4"></a>)<span>;</span></span></code></pre></div><p>Having considered everything above, it is crystal clear that the
<strong>logic</strong> part remains the same, no matter how you call it:
be it statics or dynamics.</p><a href="#the-unfortunate-consequences-of-being-static"><h2 id="the-unfortunate-consequences-of-being-static">The unfortunate
consequences of being static</h2></a><blockquote>
<p>Are you quite sure that all those bells and whistles, all those
wonderful facilities of your so called powerful programming languages,
belong to the solution set rather than the problem set?</p>
</blockquote><p>Programming languages nowadays do not focus on the logic. They focus
on the mechanisms inferior to logic; they call boolean negation the most
simple operator that must exist from the very beginning but <a href="https://github.com/rust-lang/rfcs/issues/1834">negative trait
bounds</a> are considered a debatable concept with “a lot of issues”.
The majority of mainstream PLs support the tree data structure in their
standard libraries, but sum types <a href="https://bitbashing.io/std-visit.html">stay unimplemented for
decades</a>. I cannot imagine a single language without the
<code>if</code> operator, but only a few PLs accommodate full-fledged
trait bounds, not to mention pattern matching. This is
<strong>inconsistency</strong> – it compels software enginners design
low-quality APIs that either go dynamic and expose a very few
compile-time checks or go static and try to circumvent the fundamental
limitations of a host language, thereby making their usage more and more
abstruse. Combining statics and dynamics in a single working solution is
also complicated since you cannot invoke dynamics in a static context.
In terms of <a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">function
colours</a>, dynamics is coloured red, whereas statics is blue.</p><p>In addition to this inconsistency, we have the feature
<strong>biformity</strong>. In such languages as C++, Haskell, and Rust,
this biformity amounts to the most perverse forms; you can think of any
so-called “expressive” programming language as of two or more smaller
languages put together: C++ the language and C++ templates/macros, Rust
the language and type-level Rust + declarative macros, etc. With this
approach, each time you write something at a meta-level, you cannot
reuse it in the host language and vice versa, thus violating the <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY
principle</a> (as we shall see in a minute). Additionally, biformity
increases the learning curve, hardens language evolution, and finally
ends up in such a feature bloat that only the initiated can figure out
what is happening in the code. Take a look at any production code in
Haskell and you will immediately see those numerous GHC
<code>#LANGUAGE</code> clauses, each of which signifies a separate
language extension:</p><p>
<code>feature-bloat.hs</code>
</p><div id="cb15"><pre><code><span id="cb15-1"><a href="#cb15-1"></a><span>{-# LANGUAGE BangPatterns               #-}</span></span>
<span id="cb15-2"><a href="#cb15-2"></a><span>{-# LANGUAGE CPP                        #-}</span></span>
<span id="cb15-3"><a href="#cb15-3"></a><span>{-# LANGUAGE ConstraintKinds            #-}</span></span>
<span id="cb15-4"><a href="#cb15-4"></a><span>{-# LANGUAGE DefaultSignatures          #-}</span></span>
<span id="cb15-5"><a href="#cb15-5"></a><span>{-# LANGUAGE DeriveAnyClass             #-}</span></span>
<span id="cb15-6"><a href="#cb15-6"></a><span>{-# LANGUAGE DeriveGeneric              #-}</span></span>
<span id="cb15-7"><a href="#cb15-7"></a><span>{-# LANGUAGE DerivingStrategies         #-}</span></span>
<span id="cb15-8"><a href="#cb15-8"></a><span>{-# LANGUAGE FlexibleContexts           #-}</span></span>
<span id="cb15-9"><a href="#cb15-9"></a><span>{-# LANGUAGE FlexibleInstances          #-}</span></span>
<span id="cb15-10"><a href="#cb15-10"></a><span>{-# LANGUAGE GADTs                      #-}</span></span>
<span id="cb15-11"><a href="#cb15-11"></a><span>{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></span>
<span id="cb15-12"><a href="#cb15-12"></a><span>{-# LANGUAGE NamedFieldPuns             #-}</span></span>
<span id="cb15-13"><a href="#cb15-13"></a><span>{-# LANGUAGE OverloadedStrings          #-}</span></span>
<span id="cb15-14"><a href="#cb15-14"></a><span>{-# LANGUAGE PolyKinds                  #-}</span></span>
<span id="cb15-15"><a href="#cb15-15"></a><span>{-# LANGUAGE RecordWildCards            #-}</span></span>
<span id="cb15-16"><a href="#cb15-16"></a><span>{-# LANGUAGE ScopedTypeVariables        #-}</span></span>
<span id="cb15-17"><a href="#cb15-17"></a><span>{-# LANGUAGE TypeFamilies               #-}</span></span>
<span id="cb15-18"><a href="#cb15-18"></a><span>{-# LANGUAGE UndecidableInstances       #-}</span></span>
<span id="cb15-19"><a href="#cb15-19"></a><span>{-# LANGUAGE ViewPatterns               #-}</span></span></code></pre></div><p>
Adapted from <a href="https://github.com/haskell/haskell-language-server/blob/ee0a0cc78352c961f641443eea89a26b9e1d3974/hls-plugin-api/src/Ide/Types.hs">haskell/haskell-language-server</a>.
</p><p>When a host language does not provide enough static capabilities
needed for convenient development, some programmers go especially insane
and create whole new compile-time metalanguages and eDSLs atop of
existing ones. Thus, <strong>inconsistency has the treacherous property
of transforming into biformity</strong>:</p><ul>
<li>
<p>[<strong>C++</strong>] We have <a href="https://en.wikipedia.org/wiki/Template_metaprogramming">template
metaprogramming</a> libraries, such as <a href="https://github.com/boostorg/hana">Boost/Hana</a> and <a href="https://github.com/boostorg/mpl">Boost/MPL</a>, which copy the
functionality of C++ to be used at a meta-level:</p>
<p>
<code>take_while.cpp</code>
</p>
<div id="cb16"><pre><code><span id="cb16-1"><a href="#cb16-1"></a><span>BOOST_</span>HANA_CONSTANT_CHECK<span>(</span></span>
<span id="cb16-2"><a href="#cb16-2"></a>    hana<span>::</span>take_while<span>(</span>hana<span>::</span>tuple_c<span>&lt;</span><span>int</span><span>,</span> <span>0</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>&gt;,</span> hana<span>::</span>less<span>.</span>than<span>(</span><span>2_c</span><span>))</span></span>
<span id="cb16-3"><a href="#cb16-3"></a>    <span>==</span></span>
<span id="cb16-4"><a href="#cb16-4"></a>    hana<span>::</span>tuple_c<span>&lt;</span><span>int</span><span>,</span> <span>0</span><span>,</span> <span>1</span><span>&gt;</span></span>
<span id="cb16-5"><a href="#cb16-5"></a><span>);</span></span></code></pre></div>
<p>
Adapted from <a href="https://github.com/boostorg/hana/blob/998033e9dba8c82e3c9496c274a3ad1acf4a2f36/example/take_while.cpp">hana/example/take_while.cpp</a>.
</p>
<p>
<code>filter.cpp</code>
</p>
<div id="cb17"><pre><code><span id="cb17-1"><a href="#cb17-1"></a><span>constexpr</span> <span>auto</span> is_integral <span>=</span></span>
<span id="cb17-2"><a href="#cb17-2"></a>    hana<span>::</span>compose<span>(</span>hana<span>::</span>trait<span>&lt;</span><span>std::</span>is_integral<span>&gt;,</span> hana<span>::</span><span>typeid_</span><span>);</span></span>
<span id="cb17-3"><a href="#cb17-3"></a></span>
<span id="cb17-4"><a href="#cb17-4"></a><span>static_assert</span><span>(</span></span>
<span id="cb17-5"><a href="#cb17-5"></a>    hana<span>::</span>filter<span>(</span>hana<span>::</span>make_tuple<span>(</span><span>1</span><span>,</span> <span>2.0</span><span>,</span> <span>3</span><span>,</span> <span>4.0</span><span>),</span> is_integral<span>)</span></span>
<span id="cb17-6"><a href="#cb17-6"></a>    <span>==</span> hana<span>::</span>make_tuple<span>(</span><span>1</span><span>,</span> <span>3</span><span>),</span> <span>&#34;&#34;</span><span>);</span></span>
<span id="cb17-7"><a href="#cb17-7"></a><span>static_assert</span><span>(</span></span>
<span id="cb17-8"><a href="#cb17-8"></a>    hana<span>::</span>filter<span>(</span>hana<span>::</span>just<span>(</span><span>3</span><span>),</span> is_integral<span>)</span></span>
<span id="cb17-9"><a href="#cb17-9"></a>    <span>==</span> hana<span>::</span>just<span>(</span><span>3</span><span>),</span> <span>&#34;&#34;</span><span>);</span></span>
<span id="cb17-10"><a href="#cb17-10"></a><span>BOOST_</span>HANA_CONSTANT_CHECK<span>(</span></span>
<span id="cb17-11"><a href="#cb17-11"></a>    hana<span>::</span>filter<span>(</span>hana<span>::</span>just<span>(</span><span>3.0</span><span>),</span> is_integral<span>)</span> <span>==</span> hana<span>::</span>nothing<span>);</span></span></code></pre></div>
<p>
Adapted from <a href="https://github.com/boostorg/hana/blob/998033e9dba8c82e3c9496c274a3ad1acf4a2f36/example/filter.cpp">hana/example/filter.cpp</a>.
</p>
<p>
<code>iter_fold.cpp</code>
</p>
<div id="cb18"><pre><code><span id="cb18-1"><a href="#cb18-1"></a><span>typedef</span> vector_c<span>&lt;</span><span>int</span><span>,</span> <span>5</span><span>,</span> <span>-</span><span>1</span><span>,</span> <span>0</span><span>,</span> <span>7</span><span>,</span> <span>2</span><span>,</span> <span>0</span><span>,</span> <span>-</span><span>5</span><span>,</span> <span>4</span><span>&gt;</span> numbers<span>;</span></span>
<span id="cb18-2"><a href="#cb18-2"></a><span>typedef</span> iter_fold<span>&lt;</span></span>
<span id="cb18-3"><a href="#cb18-3"></a>    numbers<span>,</span></span>
<span id="cb18-4"><a href="#cb18-4"></a>    begin<span>&lt;</span>numbers<span>&gt;::</span>type<span>,</span></span>
<span id="cb18-5"><a href="#cb18-5"></a>    <span>if_</span><span>&lt;</span>less<span>&lt;</span>deref<span>&lt;</span>_1<span>&gt;,</span> deref<span>&lt;</span>_2<span>&gt;&gt;,</span> _2<span>,</span> _1<span>&gt;</span></span>
<span id="cb18-6"><a href="#cb18-6"></a><span>&gt;::</span>type max_element_iter<span>;</span></span>
<span id="cb18-7"><a href="#cb18-7"></a></span>
<span id="cb18-8"><a href="#cb18-8"></a><span>BOOST_</span>MPL_ASSERT_RELATION<span>(</span></span>
<span id="cb18-9"><a href="#cb18-9"></a>    deref<span>&lt;</span>max_element_iter<span>&gt;::</span>type<span>::</span>value<span>,</span> <span>==,</span> <span>7</span><span>);</span></span></code></pre></div>
<p>
Adapted from <a href="https://www.boost.org/doc/libs/1_78_0/libs/mpl/doc/refmanual/iter-fold.html">the
docs of MPL</a>.
</p>
</li>
<li>
<p>[<strong>C</strong>] My own compile-time metaprogramming framework <a href="https://github.com/Hirrolot/metalang99">Metalang99</a> does the
same job by (ab)using the C preprocessor. It came to such extent that I
was forced to literally <a href="https://github.com/Hirrolot/metalang99/blob/master/include/metalang99/eval/rec.h">re-implement
recursion</a> through the combination of a Lisp-like trampoline and <a href="https://en.wikipedia.org/wiki/Continuation-passing_style">Continuation-Passing
Style (CPS)</a> techniques. In the end, I had a cornucopia of list
functions in the standard library, such as <a href="https://metalang99.readthedocs.io/en/latest/list.html#c.ML99_listMap"><code>ML99_listMap</code></a>,
<a href="https://metalang99.readthedocs.io/en/latest/list.html#c.ML99_listIntersperse"><code>ML99_listIntersperse</code></a>,
and <a href="https://metalang99.readthedocs.io/en/latest/list.html#c.ML99_listFoldr"><code>ML99_listFoldr</code></a>,
which arguably makes Metalang99, as a pure data transformation language,
more expressive than C itself <a href="#fn5" id="fnref5" role="doc-noteref"><sup>5</sup></a>.</p>
</li>
<li>
<p>[<strong>Rust</strong>] In the first example of inconsistency
(<code>Automobile</code>), we used a heterogenous list from the <a href="https://docs.rs/frunk/latest/frunk/index.html">Frunk</a> library.
It is of no difficulty to see that Frunk <a href="https://github.com/lloydmeta/frunk/blob/master/core/src/hlist.rs">duplicates</a>
some of the functionality of collections and iterators just to elevate
them to type-level. It could be cool to apply <code>Iterator::map</code>
or <code>Iterator::intersperse</code> to heterogenous lists, but we
cannot. Even worse, if we nevertheless want to perform declarative
type-level data transformations, we have to maintain the 1-to-1
correspondence between the iterator adaptors and those of type-level;
each time a new utility is implemented for iterators, we have one
utility missing in <code>hlist</code>.</p>
</li>
<li>
<p>[<strong>Rust</strong>] <a href="https://docs.rs/typenum/latest/typenum/">Typenum</a> is yet
another popular type-level library: it performs integral calculations at
compile-time, by encoding integers as generics <a href="#fn6" id="fnref6" role="doc-noteref"><sup>6</sup></a>. By
doing this, the part of the language responsible for integers finds its
counterpart in the statics, thereby introducing even more biformity <a href="#fn7" id="fnref7" role="doc-noteref"><sup>7</sup></a>. We cannot just parameterise some
type with <code>(2 + 2) * 5</code>, we have to write something like
<code>&lt;&lt;P2 as Add&lt;P2&gt;&gt;::Output as Mul&lt;P5&gt;&gt;::Output</code>!
The best thing you could do is to write a macro that does the dirty job
for you, but it would only be syntax sugar – you would anyway see hordes
of compile-time errors with the aforementioned traits.</p>
</li>
</ul><p><img src="https://hirrolot.github.io/media/why-static-languages-suffer-from-complexity/tmp-meme.png"/></p><p>Sometimes, software engineers find their languages too primitive to
express their ideas even in dynamic code. But they do not give up:</p><ul>
<li>[<strong>Golang</strong>] <a href="https://github.com/kubernetes/kubernetes">Kubernetes</a>, one of
the largest codebases in Golang, has its own <a href="https://medium.com/@arschles/go-experience-report-generics-in-kubernetes-25da87430301">object-oriented
type system</a> implemented in the <a href="https://pkg.go.dev/k8s.io/apimachinery/pkg/runtime"><code>runtime</code>
package</a>.</li>
</ul><ul>
<li>[<strong>C</strong>] The <a href="https://github.com/videolan/vlc">VLC media player</a> has a
macro-based <a href="https://github.com/videolan/vlc/blob/271d3552b7ad097d796bc431e946931abbe15658/include/vlc_plugin.h">plugin
API</a> used to represent media codecs. Here is how <a href="https://github.com/videolan/vlc/blob/271d3552b7ad097d796bc431e946931abbe15658/modules/codec/opus.c#L57">Opus
is defined</a>.</li>
</ul><ul>
<li>[<strong>C</strong>] The <a href="https://github.com/qemu/qemu">QEMU
machine emulator</a> is built upon their custom <a href="https://github.com/qemu/qemu/tree/master/include/qapi/qmp">object
model</a>: <code>QObject</code>, <code>QNum</code>, <code>QNull</code>,
<code>QList</code>, <code>QString</code>, <code>QDict</code>,
<code>QBool</code>, etc.</li>
</ul><p>Recalling the famous <a href="https://en.wikipedia.org/wiki/Greenspun%27s_tenth_rule">Greenspun’s
tenth rule</a>, such handmade metalanguages are typically “ad-hoc,
informally-specified, bug-ridden, and slow”, with quite vague semantics
and awful documentation. The concept of a <a href="https://en.wikipedia.org/wiki/Metalinguistic_abstraction">metalinguistic
abstraction</a> simply does not work, albeit the rationale of creating
highly declarative, small domain-specific languages sounds so cool at
first sight. When a problem domain (or some intermediate machinery) is
expressed in terms of a host language, you need to understand how to
chain function calls together to get things done – this is what we
usually call an API; however, when this API is written in another
language, then, in addition to the calling sequence, you need to
understand the syntax and semantics of that language, which is very
unfortunate for two reasons: the mental burden it lays upon developers
and a very limited number of developers that can support such
metalanguages. From my experience, handmade metalinguistics tend to
quickly go out of hand and spread across the whole codebase, thereby
making it harder to dig into. Not only reasoning is impaired but also
compiler-developer interaction: have you ever tried to use a
sophisticated type or macro API? If yes, then you should be perfectly
acquainted with inscrutable compiler diagnostics, which can be
summarised in the following screenshot <a href="#fn8" id="fnref8" role="doc-noteref"><sup>8</sup></a>:</p><p><img src="https://hirrolot.github.io/media/whats-the-point-of-the-c-preprocessor-actually/2.jpg"/></p><p>This is woefully to say, but it seems that an “expressive” PL
nowadays means “Hey there, I have seriously messed up with the number of
features, but that is fine!”</p><p>Finally, a word has to be said about metaprogramming in a host
language. With such templating systems as <a href="https://wiki.haskell.org/A_practical_Template_Haskell_Tutorial">Template
Haskell</a> and <a href="https://doc.rust-lang.org/reference/procedural-macros.html">Rust’s
procedural macros</a>, we can manipulate an AST <a href="#fn9" id="fnref9" role="doc-noteref"><sup>9</sup></a> of
a host language using the same language, which is good in terms of
biformity but unpleasant in terms of general language inconsistency.
Macros are not functions: we cannot partially apply a macro and obtain a
partially applied function (or vice versa), since they are just
different concepts – this can turn out to be a pain in the ass if we are
to design a generic and easy-to-use library API. Personally, I do think
that procedural macros in Rust are a <strong>giant design
mistake</strong> that is comparable to <code>#define</code> macros in
plain C: aside from pure syntax, the macro system simply has no idea
about the language being manipulated; instead of a tool to extend and
work with a language gracefully, you get slightly enhanced text
substitution and nothing more <a href="#fn10" id="fnref10" role="doc-noteref"><sup>10</sup></a>. E.g., imagine there
is an enumeration called <code>Either</code>, whose definition is as
follows:</p><p>
<code>either.rs</code>
</p><div id="cb19"><pre><code><span id="cb19-1"><a href="#cb19-1"></a><span>pub</span> <span>enum</span> Either<span>&lt;</span>L<span>,</span> R<span>&gt;</span> <span>{</span></span>
<span id="cb19-2"><a href="#cb19-2"></a>    Left(L)<span>,</span></span>
<span id="cb19-3"><a href="#cb19-3"></a>    Right(R)<span>,</span></span>
<span id="cb19-4"><a href="#cb19-4"></a><span>}</span></span></code></pre></div><p>
Adapted from <a href="https://docs.rs/either/latest/either/enum.Either.html">either::Either</a>.
</p><p>Now imagine we have an arbitrary trait <code>Foo</code>, and we are
willing to implement this trait for <code>Either&lt;L, R&gt;</code>,
where <code>L</code> and <code>R</code> both implement <code>Foo</code>.
It turns out that we cannot apply a derive macro to <code>Either</code>
that implements this trait, even if the name is known because, in order
to do this, this macro must know all the signatures of <code>Foo</code>.
To make the situation even worse, <code>Foo</code> may be defined in a
separate library, meaning that we cannot augment its definition with
extra meta-information needed for the derivation for
<code>Either&lt;L, R&gt;</code>. While it may seem as a rare scanario,
in fact it is not; I highly encourage you to look at <a href="https://docs.rs/tokio-util/latest/tokio_util/">tokio-util</a>’s <a href="https://docs.rs/tokio-util/latest/tokio_util/either/enum.Either.html"><code>Either</code></a>,
which is <strong>exactly</strong> the same enumeration but it implements
Tokio-specific traits, such as <code>AsyncRead</code>,
<code>AsyncWrite</code>, <code>AsyncSeek</code>, etc <a href="#fn11" id="fnref11" role="doc-noteref"><sup>11</sup></a>.
<del>Now imagine you have five different <code>Either</code>s in your
project that came from different libraries – that would be a true
integration headache!</del> <a href="#fn12" id="fnref12" role="doc-noteref"><sup>12</sup></a> While type
introspection may be a compromise, it would nonetheless make the
language even more complex than it already is.</p><a href="#idris-the-way-out"><h2 id="idris-the-way-out">Idris: The way out?</h2></a><blockquote>
<p>One of the most fundamental features of Idris is that types and
expressions are part of the same language – you use the same syntax for
both.</p>
</blockquote><p>
<a href="https://www.type-driven.org.uk/edwinb/">Edwin Brady</a>, the
author of <a href="https://www.idris-lang.org/">Idris</a> <span data-cites="type-dd-with-idris">(Edwin Brady,
n.d.)</span>
</p><p>Let us think a little bit about how to workaround the issue. If we
make our languages fully dynamic, we will win biformity and
inconsistency <a href="#fn13" id="fnref13" role="doc-noteref"><sup>13</sup></a>, but will imminently lose the
pleasure of compile-time validation and will end up debugging our
programs at mid-nights. The misery of dynamic type systems is widely
known.</p><p>The only way to approach the problem is to make a language whose
features are both static and dynamic and not to split the same feature
into two parts. Thus, the ideal linguistic abstraction is both static
and dynamic; however, it is still a single concept and not two logically
similar concepts but with different interfaces <a href="#fn14" id="fnref14" role="doc-noteref"><sup>14</sup></a>.
A perfect example is <a href="https://en.wikipedia.org/wiki/Compile-time_function_execution">CTFE</a>,
colloquially known as <code>constexpr</code>: same code can be executed
at compile-time under a static context and at run-time under a dynamic
context (e.g., when requesting a user input from <code>stdin</code>.);
thus, we do not have to write different code for compile-time (statics)
and run-time (dynamics), instead we use the same representation.</p><p>One possible solution I have seen is dependent types. With dependent
types, we can parameterise types not only with other types but with
values, too. In a dependently typed language <a href="https://www.idris-lang.org/">Idris</a>, there is a type called
<code>Type</code> – it stands for the “type of all types”, thereby
<strong>weakening the dichotomy between type-level and
value-level</strong>. Having such a powerful thing at our disposal, we
can express <em>typed</em> abstractions that are usually either built
into a language compiler/environment or done via macros. Perhaps the
most common and descriptive example is a type-safe <code>printf</code>
that calculates types of its arguments on the fly, so let give us the
pleasure of mastering it in Idris <a href="#fn15" id="fnref15" role="doc-noteref"><sup>15</sup></a>!</p><p>First, define an inductive data type <code>Fmt</code> and a way to
get it from a format string:</p><div id="cb20"><pre><code><span id="cb20-1"><a href="#cb20-1"></a><span>data</span> <span>Fmt</span> <span>=</span> <span>FArg</span> <span>Fmt</span> <span>|</span> <span>FChar</span> <span>Char</span> <span>Fmt</span> <span>|</span> <span>FEnd</span></span>
<span id="cb20-2"><a href="#cb20-2"></a></span>
<span id="cb20-3"><a href="#cb20-3"></a><span>toFmt</span> <span>:</span> (fmt <span>:</span> <span>List</span> <span>Char</span>) <span>-&gt;</span> <span>Fmt</span></span>
<span id="cb20-4"><a href="#cb20-4"></a>toFmt (<span>&#39;*&#39;</span> <span>::</span> xs) <span>=</span> <span>FArg</span> (toFmt xs)</span>
<span id="cb20-5"><a href="#cb20-5"></a>toFmt (  x <span>::</span> xs) <span>=</span> <span>FChar</span> x (toFmt xs)</span>
<span id="cb20-6"><a href="#cb20-6"></a>toFmt [] <span>=</span> <span>FEnd</span></span></code></pre></div><p>Later, we will use it to generate a type for our <code>printf</code>
function. The syntax resembles Haskell a lot and should be
comprehensible for a reader.</p><p>Now the most interesting part:</p><div id="cb21"><pre><code><span id="cb21-1"><a href="#cb21-1"></a><span>PrintfType</span> <span>:</span> (fmt <span>:</span> <span>Fmt</span>) <span>-&gt;</span> <span>Type</span></span>
<span id="cb21-2"><a href="#cb21-2"></a><span>PrintfType</span> (<span>FArg</span> fmt) <span>=</span> ({ty <span>:</span> <span>Type</span>} <span>-&gt;</span> <span>Show</span> ty <span>=&gt;</span> (obj <span>:</span> ty) <span>-&gt;</span> <span>PrintfType</span> fmt)</span>
<span id="cb21-3"><a href="#cb21-3"></a><span>PrintfType</span> (<span>FChar</span> <span>_</span> fmt) <span>=</span> <span>PrintfType</span> fmt</span>
<span id="cb21-4"><a href="#cb21-4"></a><span>PrintfType</span> <span>FEnd</span> <span>=</span> <span>String</span></span></code></pre></div><p>What this function does? It <strong>calculates a type</strong> based
on the input argument <code>fmt</code>. As usual, we case-split
<code>fmt</code> into three cases and deal with them separately:</p><ol type="1">
<li><code>(FArg fmt)</code>. Since <code>FArg</code> indicates that we
are to provide a printable argument, this case produces a type signature
that takes an additional parameter:
<ol type="1">
<li><code>{ty : Type}</code> means that Idris will deduce a type
<code>ty</code> of this argument automatically (<a href="https://docs.idris-lang.org/en/latest/tutorial/miscellany.html#implicit-arguments">implicit
argument</a>).</li>
<li><code>Show ty</code> is a type constraint that says that
<code>ty</code> should implement <code>Show</code>.</li>
<li><code>(obj : ty)</code> is that printable argument we must provide
to <code>printf</code>.</li>
<li><code>PrintfType fmt</code> is a recursive call that deals with the
rest of the input <code>fmt</code>. In Idris, inductive types are
managed by inductive functions!</li>
</ol></li>
<li><code>(FChar _ fmt)</code>. <code>FChar</code> indicates an ordinary
character in a format string, so here we just ignore it and continue
with <code>PrintfType fmt</code>.</li>
<li><code>FEnd</code>. This is the end of input. Since we want our
<code>printf</code> to produce a <code>String</code>, we return
<code>String</code> as an ordinary type.</li>
</ol><p>Now say we have a format string <code>&#34;*x*&#34;</code>, or
<code>FArg (FChar (&#39;x&#39; (FArg FEnd)))</code>; what type will
<code>PrintfType</code> generate? Simple:</p><ol type="1">
<li><code>FArg</code>:
<code>{ty : Type} -&gt; Show ty =&gt; (obj : ty) -&gt; PrintfType (FChar (&#39;x&#39; (FArg FEnd)))</code></li>
<li><code>FChar</code>:
<code>{ty : Type} -&gt; Show ty =&gt; (obj : ty) -&gt; PrintfType (FArg FEnd)</code></li>
<li><code>FArg</code>:
<code>{ty : Type} -&gt; Show ty =&gt; (obj : ty) -&gt; {ty : Type} -&gt; Show ty =&gt; (obj : ty) -&gt; PrintfType FEnd</code></li>
<li><code>FEnd</code>:
<code>{ty : Type} -&gt; Show ty =&gt; (obj : ty) -&gt; {ty : Type} -&gt; Show ty =&gt; (obj : ty) -&gt; String</code></li>
</ol><p>Cool, now it is time to write the coveted <code>printf</code>:</p><div id="cb22"><pre><code><span id="cb22-1"><a href="#cb22-1"></a><span>printf</span> <span>:</span> (fmt <span>:</span> <span>String</span>) <span>-&gt;</span> <span>PrintfType</span> (toFmt <span>$</span> unpack fmt)</span>
<span id="cb22-2"><a href="#cb22-2"></a>printf fmt <span>=</span> printfAux (toFmt <span>$</span> unpack fmt) [] <span>where</span></span>
<span id="cb22-3"><a href="#cb22-3"></a>    <span>printfAux</span> <span>:</span> (fmt <span>:</span> <span>Fmt</span>) <span>-&gt;</span> <span>List</span> <span>Char</span> <span>-&gt;</span> <span>PrintfType</span> fmt</span>
<span id="cb22-4"><a href="#cb22-4"></a>    printfAux (<span>FArg</span> fmt) acc <span>=</span> <span>\</span>obj <span>=&gt;</span> printfAux fmt (acc <span>++</span> unpack (show obj))</span>
<span id="cb22-5"><a href="#cb22-5"></a>    printfAux (<span>FChar</span> c fmt) acc <span>=</span> printfAux fmt (acc <span>++</span> [c])</span>
<span id="cb22-6"><a href="#cb22-6"></a>    printfAux <span>FEnd</span> acc <span>=</span> pack acc</span></code></pre></div><p>As you can see, <code>PrintfType (toFmt $ unpack fmt)</code> occurs
in the type signature, meaning that the whole type of
<code>printf</code> <em>depends on the input argument</em>
<code>fmt</code>! But what does <code>unpack fmt</code> mean? Since
<code>printf</code> takes <code>fmt : String</code>, we should convert
it to <code>List Char</code> beforehand because we match this string in
<code>toFmt</code>; as far as I know, Idris does not allow matching an
ordinary <code>String</code> in the same way. Likewise, we do
<code>unpack fmt</code> before calling <code>printfAux</code>, since it
also takes <code>List Char</code> as a result accumulator.</p><p>Let us examine the <code>printfAux</code> implementation:</p><ol type="1">
<li><code>(FArg fmt)</code>. Here we return a lambda function that takes
<code>obj</code> and calls <code>show</code> on it, then appends to
<code>acc</code> by the <code>++</code> operator.</li>
<li><code>(FChar c fmt)</code>. Just append <code>c</code> to
<code>acc</code> and call <code>printfAux</code> once again on
<code>fmt</code>.</li>
<li><code>FEnd</code>. Since <code>acc</code> is typed
<code>List Char</code> but we have to return <code>String</code>
(according to the last case of <code>PrintfType</code>), we call
<code>pack</code> on it.</li>
</ol><p>Finally, test <code>printf</code>:</p><p>
<code>printf.idr</code>
</p><div id="cb23"><pre><code><span id="cb23-1"><a href="#cb23-1"></a><span>main</span> <span>:</span> <span>IO</span> ()</span>
<span id="cb23-2"><a href="#cb23-2"></a>main <span>=</span> putStrLn <span>$</span> printf <span>&#34;Mr. John has * contacts in *.&#34;</span> <span>42</span> <span>&#34;New York&#34;</span></span></code></pre></div><p>This prints <code>Mr. John has 42 contacts in &#34;New York&#34;.</code>. But
what if we do not provide <code>42</code> to <code>printf</code>?</p><div id="cb24"><pre><code><span id="cb24-1"><a href="#cb24-1"></a>Error: While processing right hand side of main. When unifying:</span>
<span id="cb24-2"><a href="#cb24-2"></a>    ?ty -&gt; PrintfType (toFmt [assert_total (prim__strIndex &#34;Mr. John has * contacts in *.&#34; (prim__cast_IntegerInt (natToInteger (length &#34;Mr. John has * contacts in *.&#34;)) - 1))])</span>
<span id="cb24-3"><a href="#cb24-3"></a>and:</span>
<span id="cb24-4"><a href="#cb24-4"></a>    String</span>
<span id="cb24-5"><a href="#cb24-5"></a>Mismatch</span>
<span id="cb24-6"><a href="#cb24-6"></a>between: ?ty -&gt; PrintfType (toFmt [assert_total (prim__strIndex &#34;Mr. John has * contacts in *.&#34; (prim__cast_IntegerInt (natToInteger (length &#34;Mr. John has * contacts in *.&#34;)) - 1))]) and String.</span>
<span id="cb24-7"><a href="#cb24-7"></a></span>
<span id="cb24-8"><a href="#cb24-8"></a>test:21:19--21:68</span>
<span id="cb24-9"><a href="#cb24-9"></a> 17 |     printfAux (FChar c fmt) acc = printfAux fmt (acc ++ [c])</span>
<span id="cb24-10"><a href="#cb24-10"></a> 18 |     printfAux FEnd acc = pack acc</span>
<span id="cb24-11"><a href="#cb24-11"></a> 19 | </span>
<span id="cb24-12"><a href="#cb24-12"></a> 20 | main : IO ()</span>
<span id="cb24-13"><a href="#cb24-13"></a> 21 | main = putStrLn $ printf &#34;Mr. John has * contacts in *.&#34; &#34;New York&#34;</span>
<span id="cb24-14"><a href="#cb24-14"></a>                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<span id="cb24-15"><a href="#cb24-15"></a></span>
<span id="cb24-16"><a href="#cb24-16"></a>Warning: compiling hole Main.main</span></code></pre></div><p>Yeah, Idris detects the error and produces a type mismatch! This is
basically how you implement type-safe <code>printf</code> with
first-class types. If you are curious about the same thing in Rust, take
a look at <a href="https://willcrichton.net/notes/type-safe-printf/">Will Crichton’s
attempt</a>, which relies heavily on heterogenous lists we have seen
above. The downside of this approach now should be perfectly clear to
you: in Rust, the language of the type system differs from the main
language, but in Idris, it is indeed the same thing – this is why we can
freely define type-level functions as regular functions returning a
<code>Type</code> and invoke them later in type signatures. Moreover,
because Idris is dependently typed, you can even compute a type based on
some run-time argument, which is impossible in such languages as <a href="https://ziglang.org/">Zig</a>.</p><p><img src="https://hirrolot.github.io/media/why-static-languages-suffer-from-complexity/printf-meme.png"/></p><p>I already anticipate the question: what is the problem of
implementing <code>printf</code> with macros? After all, <a href="https://doc.rust-lang.org/std/macro.println.html"><code>println!</code></a>
works just fine in Rust. The problem is macros. Think for yourself: why
a programming language needs heavy-duty macros? Because we may want to
extend it. Why may we want to extend it? Because a programming language
does not fit our needs: we cannot express something using regular
linguistic abstractions, and this is why we decide to extend the
language with ad-hoc meta-abstractions. In the main section, I provided
an argumentation why this approach sucks – because a macro system has no
clue about a language being manipulated; in fact, procedural macros in
Rust is just a fancy name for the <a href="https://en.wikipedia.org/wiki/M4_(computer_language)">M4
preprocessor</a>. You guys integrated M4 into your language. Of course,
this is <a href="https://hirrolot.github.io/posts/whats-the-point-of-the-c-preprocessor-actually.html">better than
external M4</a>, but it is nevertheless a method of the 20’th century;
proc. macros even cannot manipulate an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree"><em>abstract</em>
syntax tree</a>, because <a href="https://docs.rs/syn/latest/syn/enum.Item.html"><code>syn::Item</code></a>,
a common structure used to write proc. macros, is indeed known as a <a href="https://en.wikipedia.org/wiki/Parse_tree"><em>concrete</em> syntax
tree</a>, or “parse tree”. On the other hand, types are a natural part
of a host language, and this is why if we can express a programmatic
abstraction using types, we <em>reuse</em> linguistic abstractions
instead of resorting to ad-hoc machinery. Ideally, a programming
language should have either no macros or only a lightweight form of
syntax rewriting rules (like Scheme’s <a href="https://www2.ccs.neu.edu/racket/pubs/lasc1990-sf.pdf"><code>extend-syntax</code></a>
or <a href="https://docs.idris-lang.org/en/latest/tutorial/syntax.html">syntax
extensions</a> of Idris), in order to keep the language consistent and
well-suited to solve expected tasks.</p><p>That being said, Idris erases the first biformity “values-generics”
by introducing <code>Type</code>, the “type of all types”. By doing so,
it also resolves a bunch of other correspondences, such as recursion
vs. type-level induction, functions vs. trait machinery, and so forth;
this, in turn, allows programming in the same language as much as
possible, even when dealing with highly generic code. E.g., you can even
represent a list of types as <code>List Type</code>, just like
<code>List Nat</code> or <code>List String</code>, and deal with it as
usual! It is possible due to a <a href="https://docs.idris-lang.org/en/latest/faq/faq.html#does-idris-have-universe-polymorphism-what-is-the-type-of-type">cumulative
hierarchy of universes</a>: simply speaking, <code>Type</code> is of
type <code>Type 1</code>, <code>Type 1</code> is of type
<code>Type 2</code>, and so on. Since <a href="https://github.com/idris-lang/Idris2/blob/0d58282087a8dce89a036e31e192af13b9199850/libs/prelude/Prelude/Basics.idr#L164"><code>Data.List</code></a>’s
generic named <code>a</code> is “implicitly” typed <code>Type</code>, it
can be <code>Nat</code> and <code>String</code> as well as
<code>Type</code>; in the latter case, <code>a</code> would be deduced
as <code>Type 1</code>. Such an infinite sequence of types is needed to
avoid a variation of <a href="https://en.wikipedia.org/wiki/Russell%27s_paradox">Russell’s
paradox</a> by making an inhabitant “structurally smaller” than its
type.</p><p>Idris, however, is not a simple language. Our twenty line example of
<code>printf</code> already uses a “whole lotta features”, such as
inductive data types, dependent pattern matching, implicits, type
constraints, to mention a few. Additionally, Idris features <a href="http://docs.idris-lang.org/en/latest/effects/index.html">computational
effects</a>, <a href="http://docs.idris-lang.org/en/latest/elaboratorReflection/index.html">elaborator
reflection</a>, coinductive data types, and many-many stuff for theorem
proving. With such a pleiad of typing facilities, you typically twiddle
with your language machinery rather than doing some meaningful work. I
can hardly believe that in their current state, dependent types will
find massive production use; as for now, in the programming world, they
are no more than a fancy thing for PL researchers and random enthusiasts
like me. Dependent types alone are just too low-level.</p><a href="#zig-simpler-but-too-systems"><h2 id="zig-simpler-but-too-systems">Zig: Simpler, but too systems</h2></a><blockquote>
<p>In Zig, types are first-class citizens. They can be assigned to
variables, passed as parameters to functions, and returned from
functions.</p>
</blockquote><p>
The Zig manual <span data-cites="zig-comptime-params">(Zig developers, n.d.)</span>
</p><p>Our last patient would be the <a href="https://ziglang.org/">Zig</a>
programming language. Here is a compile-time <code>printf</code>
implementation in Zig (sorry no highlighting yet):</p><p>
<code>printf.zig</code>
</p><div id="cb25"><pre><code><span id="cb25-1"><a href="#cb25-1"></a>const std = @import(&#34;std&#34;);</span>
<span id="cb25-2"><a href="#cb25-2"></a></span>
<span id="cb25-3"><a href="#cb25-3"></a>fn printf(comptime fmt: []const u8, args: anytype) anyerror!void {</span>
<span id="cb25-4"><a href="#cb25-4"></a>    const stdout = std.io.getStdOut().writer();</span>
<span id="cb25-5"><a href="#cb25-5"></a></span>
<span id="cb25-6"><a href="#cb25-6"></a>    comptime var arg_idx: usize = 0;</span>
<span id="cb25-7"><a href="#cb25-7"></a></span>
<span id="cb25-8"><a href="#cb25-8"></a>    inline for (fmt) |c| {</span>
<span id="cb25-9"><a href="#cb25-9"></a>        if (c == &#39;*&#39;) {</span>
<span id="cb25-10"><a href="#cb25-10"></a>            try printArg(stdout, args[arg_idx]);</span>
<span id="cb25-11"><a href="#cb25-11"></a>            arg_idx += 1;</span>
<span id="cb25-12"><a href="#cb25-12"></a>        } else {</span>
<span id="cb25-13"><a href="#cb25-13"></a>            try stdout.print(&#34;{c}&#34;, .{c});</span>
<span id="cb25-14"><a href="#cb25-14"></a>        }</span>
<span id="cb25-15"><a href="#cb25-15"></a>    }</span>
<span id="cb25-16"><a href="#cb25-16"></a></span>
<span id="cb25-17"><a href="#cb25-17"></a>    comptime {</span>
<span id="cb25-18"><a href="#cb25-18"></a>        if (args.len != arg_idx) {</span>
<span id="cb25-19"><a href="#cb25-19"></a>            @compileError(&#34;Unused arguments&#34;);</span>
<span id="cb25-20"><a href="#cb25-20"></a>        }</span>
<span id="cb25-21"><a href="#cb25-21"></a>    }</span>
<span id="cb25-22"><a href="#cb25-22"></a>}</span>
<span id="cb25-23"><a href="#cb25-23"></a></span>
<span id="cb25-24"><a href="#cb25-24"></a>fn printArg(stdout: std.fs.File.Writer, arg: anytype) anyerror!void {</span>
<span id="cb25-25"><a href="#cb25-25"></a>    if (@typeInfo(@TypeOf(arg)) == .Pointer) {</span>
<span id="cb25-26"><a href="#cb25-26"></a>        try stdout.writeAll(arg);</span>
<span id="cb25-27"><a href="#cb25-27"></a>    } else {</span>
<span id="cb25-28"><a href="#cb25-28"></a>        try stdout.print(&#34;{any}&#34;, .{arg});</span>
<span id="cb25-29"><a href="#cb25-29"></a>    }</span>
<span id="cb25-30"><a href="#cb25-30"></a>}</span>
<span id="cb25-31"><a href="#cb25-31"></a></span>
<span id="cb25-32"><a href="#cb25-32"></a>pub fn main() !void {</span>
<span id="cb25-33"><a href="#cb25-33"></a>    try printf(&#34;Mr. John has * contacts in *.\n&#34;, .{ 42, &#34;New York&#34; });</span>
<span id="cb25-34"><a href="#cb25-34"></a>}</span></code></pre></div><p>Here, we use a feature called <a href="https://kristoff.it/blog/what-is-zig-comptime/"><code>comptime</code></a>:
a <code>comptime</code> function parameter means that it
<strong>must</strong> be known at the time of compilation. Not only it
allows for aggressive optimisations but also opens a Valhalla of
“metaprogramming” facilities, most notably without separate macro-level
or type-level sublanguages. The above code needs no further explanation
– the mundane logic should be clear to every programmer, unlike
<code>printf.idr</code> that seems to look like a fruit of a mad genius’
wet fantasies.</p><p>If we omit <code>42</code>, Zig will report a compilation error:</p><div id="cb26"><pre><code><span id="cb26-1"><a href="#cb26-1"></a>An error occurred:</span>
<span id="cb26-2"><a href="#cb26-2"></a>/tmp/playground2454631537/play.zig:10:38: error: field index 1 outside tuple &#39;struct:33:52&#39; which has 1 fields</span>
<span id="cb26-3"><a href="#cb26-3"></a>            try printArg(stdout, args[arg_idx]);</span>
<span id="cb26-4"><a href="#cb26-4"></a>                                     ^</span>
<span id="cb26-5"><a href="#cb26-5"></a>/tmp/playground2454631537/play.zig:33:15: note: called from here</span>
<span id="cb26-6"><a href="#cb26-6"></a>    try printf(&#34;Mr. John has * contacts in *.\n&#34;, .{ &#34;New York&#34; });</span>
<span id="cb26-7"><a href="#cb26-7"></a>              ^</span>
<span id="cb26-8"><a href="#cb26-8"></a>/tmp/playground2454631537/play.zig:32:21: note: called from here</span>
<span id="cb26-9"><a href="#cb26-9"></a>pub fn main() !void {</span>
<span id="cb26-10"><a href="#cb26-10"></a>                    ^</span></code></pre></div><p>The only inconvenience I experienced during the development of
<code>printf</code> is <a href="https://gist.github.com/Hirrolot/504dfe97627895c9f8f82697e27bb142">massive
errors…</a> Much like C++ templates. However, I admit that this can be
solved (or at least workarounded) by more explicit type constraints.
Overall, the design of Zig’s type system seems reasonable: there is a
type of all types called <code>type</code>, and using
<code>comptime</code>, we can <a href="https://ikrima.dev/dev-notes/zig/zig-metaprogramming/">compute
types</a> at compile-time via regular variables, loops, procedures, etc.
We can even perform type reflection through the <a href="https://ziglang.org/documentation/master/#typeInfo"><code>@typeInfo</code></a>,
<a href="https://ziglang.org/documentation/master/#typeName"><code>@typeName</code></a>,
and <a href="https://ziglang.org/documentation/master/#TypeOf"><code>@TypeOf</code></a>
built-ins! Yes, we can no longer depend on run-time values, but if you
do not need a theorem prover, probably full-blown dependent types are a
bit of overkill.</p><p><img src="https://hirrolot.github.io/media/why-static-languages-suffer-from-complexity/types-meme.png"/></p><p>Everything is good except that Zig is a systems language. On <a href="https://ziglang.org/">their official website</a>, Zig is described
as a “general-purpose programming language”, but I can hardly agree with
this statement. Yes, you can write virtually any software in Zig, but
should you? My experience in maintaining high-level code in Rust and C99
says <strong>NO</strong>. The first reason is safety: if you make a
systems language safe, you will make programmers deal with borrow
checker and ownership (or equivalent) issues that have absolutely
nothing to do with business logic (believe me, I know the pain);
otherwise, if you choose the C-way manual memory management, you will
make programmers debugging their code for long hours with the hope that
<code>-fsanitize=address</code> would show something meaningful.
Moreover, if you want to build new abstractions atop of pointers, you
will end up with <code>&amp;str</code>, <code>AsRef&lt;str&gt;</code>,
<code>Borrow&lt;str&gt;</code>, <code>Box&lt;str&gt;</code>, and the
similar. Come on, I just want a UTF-8 string; most of the time, I do not
really care whether it is one of those alternatives.</p><p>The second reason is concerned with a language runtime <a href="#fn16" id="fnref16" role="doc-noteref"><sup>16</sup></a>: for a language to be systems, to
avoid hidden performance penalties, it should have a minimum runtime –
no default GC, no default event loop, etc., but for particular
applications, it might be necessary to have a runtime – for asynchronous
ones, for instance, so actually you <em>must</em> deal with custom
runtime code in some way. Here we encounter a whole new set of problems
regarding <a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">function
colours</a> <a href="#fn17" id="fnref17" role="doc-noteref"><sup>17</sup></a>: e.g., having <code>async</code> in
your language and having no tools to <em>abstract over</em> synchronous
and asynchronous functions means that you divided your language into two
parts: synchronous and asynchronous, and say, if you have a generic
higher-order library, it will be inevitably marked <code>async</code> to
accept all kinds of user callbacks. To resolve the issue, you need to
implement some form of <a href="http://docs.idris-lang.org/en/latest/effects/index.html">effect
polymorphism</a> (e.g., monads or algebraic effects), which is still a
research topic. High-level languages have innately fewer problems to
deal with, and this is why most of the software is written in Java, C#,
Python, and JavaScript; in Golang, conceptually, every function is
<code>async</code>, thus facilitating consistency <em>by default</em>,
without resorting to sophisticated type features. On the contrary, Rust
is already considered a complex language and still has no standard means
to write truly generic asynchronous code.</p><p>Zig can still be used in large systems projects like web browsers,
interpreters, and operating system kernels – nobody wants these things
to freeze unexpectedly. Zig’s low-level programming features would
facilitate convenient operation with memory and hardware devices, while
its sane approach to metaprogramming (in the right hands) would
cultivate understandable code structure. Bringing it to high-level code
would just increase the mental burden without considerable benefits.</p><blockquote>
<p>Progress is possible only if we train ourselves to think about
programs without thinking of them as pieces of executable code.</p>
</blockquote><p>
<a href="https://en.wikipedia.org/wiki/Edsger_W._Dijkstra">Edsger
Dijkstra</a>
</p><a href="#final-words"><h2 id="final-words">Final words</h2></a><p>Static languages enforce compile-time checks; this is good. But they
suffer from feature biformity and inconsistency – this is bad. Dynamic
languages, on the other hand, suffer from these drawbacks to a lesser
extent, but they lack compile-time checks. A hypothetical solution
should take the best from the both worlds.</p><p>Programming languages ought to be rethought.</p><a href="#references"><h2 id="references">References</h2></a><div id="refs" role="doc-bibliography">
<div id="ref-dijkstra-pl-quote" role="doc-biblioentry"><p>
Edsger Dijkstra. n.d. <span>“On the Teaching of Programming, i.e. On the
Teaching of Thinking.”</span> <a href="https://www.cs.utexas.edu/users/EWD/transcriptions/EWD04xx/EWD473.html">https://www.cs.utexas.edu/users/EWD/transcriptions/EWD04xx/EWD473.html</a>.
</p></div>
<div id="ref-type-dd-with-idris" role="doc-biblioentry"><p>
Edwin Brady. n.d. <span>“Type-Driven Development with Idris.”</span>
Manning Publications Co. <a href="https://www.manning.com/books/type-driven-development-with-idris">https://www.manning.com/books/type-driven-development-with-idris</a>.
</p></div>

</div></div></div>
  </body>
</html>
