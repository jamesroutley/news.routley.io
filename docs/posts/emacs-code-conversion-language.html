<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://emacsninja.com/posts/code-conversion-language.html">Original</a>
    <h1>Emacs Code Conversion Language</h1>
    
    <div id="readability-page-1" class="page"><div>
<article>

<p><span>20/07/2019</span></p>


<p><strong>Update</strong>: I forgot that I did <a href="https://gist.github.com/wasamasa/e5f0489676e7ac769e91">a brief analysis</a> on this many
years ago, using ROT13 as example.</p>
<p><strong>Update</strong>: Noam Postavsky pointed out on <tt>#emacs</tt> that CCL is not
turing-complete after all as a full simulation (as opposed to just
interpreting a single line) requires an Emacs Lisp loop.  This loop
cannot be done in CCL itself as it doesn’t allow feeding its output
back in as input.  The I/O restrictions most likely put it into the
weaker category of <a href="https://en.wikipedia.org/wiki/Finite-state_transducer">finite-state transducers</a>.</p>
<p>Emacs is most famously, a re-imagination of a Lisp machine, with the
Emacs Lisp byte-code interpreter being at its core.  A lesser-known
fact is that there’s two more byte-code interpreters in its C sources,
one for compiled regular expressions and another designed for encoding
and decoding text, known as Code Conversion Language (CCL).  This blog
post will focus on the latter as it’s largely gone unnoticed and
hasn’t seen too much experimentation.</p>
<p>The CCL implementation is split into the byte-code interpreter
(<tt>ccl.c</tt>) and compiler (<tt>ccl.el</tt>) parts.  There is no official
documentation other than comments and docstrings found in these files.
From this I’ve learned that CCL programs are represented as integer
vectors and that there’s a higher-level language compiling to them,
described in the <tt><span>ccl-define-program</span></tt> docstring.  By reading that
information I’ve deduced the following:</p>
<ul>
<li>The VM has eight integer-sized registers <tt>r0</tt> to <tt>r7</tt> and an
instruction counter <tt>ic</tt></li>
<li>Register <tt>r7</tt> is used as a status register and may be clobbered at
any time by an arithmetic operation</li>
<li>A CCL program can either be run on a string and return a string,
alternatively it can be run standalone for side effects</li>
<li>The former mode requires you to provide a nine-element status vector
representing the registers and instruction counter, the latter an
eight-element status vector representing the registers only</li>
<li>As a side-effect, the status vector contains the new state of the
registers and instruction counter after executing the program</li>
<li>The VM supports the standard C arithmetic, comparison and assignment
operators</li>
<li>The language translates several control flow statements to
equivalent <tt>goto</tt> statements, such as <tt>if</tt>, <tt>branch</tt> (look-up
table) and <tt>loop</tt> with <tt>repeat</tt> inside</li>
<li>Statements are grouped by surrounding them with parentheses</li>
<li>When operating on a string, they are read in and written out in a
serial fashion, no random access whatsoever</li>
<li>It’s possible to do a look-up on an array, translation table or hash
table</li>
<li>There is a <tt>call</tt> operator, but no stack to save/restore arguments
to/from, so you’ll have to come up with a calling convention fitting
the available registers</li>
<li>Each CCL program specifies a magnification factor which determines
the ratio between output and input string size</li>
</ul>
<p>Armed with that knowledge I wrote some boiler plate code for
experimentation:</p>
<pre><span>;; -*- lexical-binding: t; -*-</span><span>

</span><span>(</span><span>require</span><span> </span><span>&#39;ccl</span><span>)</span><span>

</span><span>(</span><span>defvar</span><span> </span><span>ccl-status</span><span> </span><span>(</span><span>make-vector</span><span> </span><span>8</span><span> </span><span>0</span><span>))</span><span>
</span><span>(</span><span>defvar</span><span> </span><span>ccl-status+ic</span><span> </span><span>(</span><span>make-vector</span><span> </span><span>9</span><span> </span><span>0</span><span>))</span><span>

</span><span>(</span><span>defun</span><span> </span><span>ccl-init-status</span><span> </span><span>(</span><span>status</span><span> </span><span>args</span><span>)</span><span>
  </span><span>(</span><span>let</span><span> </span><span>((</span><span>i</span><span> </span><span>0</span><span>))</span><span>
    </span><span>(</span><span>fillarray</span><span> </span><span>status</span><span> </span><span>0</span><span>)</span><span>
    </span><span>(</span><span>dolist</span><span> </span><span>(</span><span>arg</span><span> </span><span>args</span><span>)</span><span>
      </span><span>(</span><span>aset</span><span> </span><span>status</span><span> </span><span>i</span><span> </span><span>arg</span><span>)</span><span>
      </span><span>(</span><span>setq</span><span> </span><span>i</span><span> </span><span>(</span><span>1+</span><span> </span><span>i</span><span>)))))</span><span>

</span><span>(</span><span>defun</span><span> </span><span>ccl-run</span><span> </span><span>(</span><span>program</span><span> </span><span>string</span><span> </span><span>&amp;rest</span><span> </span><span>args</span><span>)</span><span>
  </span><span>(</span><span>let</span><span> </span><span>((</span><span>status</span><span> </span><span>ccl-status+ic</span><span>))</span><span>
    </span><span>(</span><span>ccl-init-status</span><span> </span><span>status</span><span> </span><span>args</span><span>)</span><span>
    </span><span>(</span><span>ccl-execute-on-string</span><span> </span><span>program</span><span> </span><span>status</span><span> </span><span>string</span><span>)))</span><span>

</span><span>(</span><span>defun</span><span> </span><span>ccl-run-pure</span><span> </span><span>(</span><span>program</span><span> </span><span>&amp;rest</span><span> </span><span>args</span><span>)</span><span>
  </span><span>(</span><span>let</span><span> </span><span>((</span><span>status</span><span> </span><span>ccl-status</span><span>))</span><span>
    </span><span>(</span><span>ccl-init-status</span><span> </span><span>status</span><span> </span><span>args</span><span>)</span><span>
    </span><span>(</span><span>ccl-execute</span><span> </span><span>program</span><span> </span><span>status</span><span>)</span><span>
    </span><span>status</span><span>))</span>
</pre>
<p>There will be some benchmark numbers, none of these are to be taken
seriously.  Do your own benchmarks before using mine for decisions.</p>
<div id="hello-world">
<h2>Hello World!</h2>
<p>For starters I’ll focus on processing strings.  The easiest possible
program that still does something useful reads in output and writes
it out as is:</p>
<pre><span>(</span><span>define-ccl-program</span><span> </span><span>ccl-identity</span><span>
  </span><span>&#39;</span><span>(</span><span>1</span><span>
    </span><span>(</span><span>loop</span><span>
     </span><span>(</span><span>read</span><span> </span><span>r0</span><span>)</span><span>
     </span><span>(</span><span>write</span><span> </span><span>r0</span><span>)</span><span>
     </span><span>(</span><span>repeat</span><span>))))</span><span>

</span><span>(</span><span>ccl-run</span><span> </span><span>&#39;ccl-identity</span><span> </span><span>&#34;Hello World!&#34;</span><span>)</span><span> </span><span>;=&gt; &#34;Hello World!&#34;</span>
</pre>
<p>Let’s go through that program carefully.  The S-Expression starts with
a magnification factor of 1, meaning that the output buffer should be
as large as the input buffer.  If it were zero, no I/O would be
permitted in the first place, whereas a factor greater than one would
allocate enough space to produce a string larger than the input.</p>
<p>The magnification factor is followed by a s-expression that’s executed
until it’s done or an error occurred, such as there being no more
input.  It may be followed by another s-expression that’s executed
after the main one, no matter whether it failed with an error or not.</p>
<p><tt><span>ccl-identity</span></tt> uses a pattern that will come up a few more times in
this blog post.  It enters a loop, reads a character into the <tt>r0</tt>
register, writes out a character from the <tt>r0</tt> register and jumps to
the beginning of the loop.  If there are no more characters left, the
read operation fails and terminates the loop.  Let’s spice things up
by adding an extra processing step before writing out the character:</p>
<pre><span>(</span><span>define-ccl-program</span><span> </span><span>ccl-xor</span><span>
  </span><span>&#39;</span><span>(</span><span>1</span><span>
    </span><span>(</span><span>loop</span><span>
     </span><span>(</span><span>read</span><span> </span><span>r1</span><span>)</span><span>
     </span><span>(</span><span>r1</span><span> </span><span>^=</span><span> </span><span>r0</span><span>)</span><span>
     </span><span>(</span><span>write</span><span> </span><span>r1</span><span>)</span><span>
     </span><span>(</span><span>repeat</span><span>))))</span><span>

</span><span>(</span><span>ccl-run</span><span> </span><span>&#39;ccl-xor</span><span> </span><span>&#34;Secret&#34;</span><span> </span><span>42</span><span>)</span><span> </span><span>;=&gt; &#34;yOIXO^&#34;</span><span>
</span><span>(</span><span>ccl-run</span><span> </span><span>&#39;ccl-xor</span><span> </span><span>&#34;yOIXO^&#34;</span><span> </span><span>42</span><span>)</span><span> </span><span>;=&gt; &#34;Secret&#34;</span>
</pre>
<p>XOR is the bread and butter operator in modern cryptography.  A text
can be encrypted by replacing each character with the result of XORing
it against a secret byte, similarly it can be decrypted by applying
the same transformation again.  To pass the secret byte as an
argument, I’ve placed it in the <tt>r0</tt> register and read the string
into the <tt>r1</tt> register instead.  On each iteration of the loop
<tt>r1</tt> is set to <tt>r1 ^ r0</tt> and written out again.</p>
</div>
<div id="more-on-translation">
<h2>More on translation</h2>
<p>In the real world translating characters isn’t as simple as applying
some arithmetic to them.  Suppose I wanted to challenge the
<tt>upcase</tt> built-in:</p>
<pre><span>(</span><span>define-ccl-program</span><span> </span><span>ccl-upcase</span><span>
  </span><span>&#39;</span><span>(</span><span>1</span><span>
    </span><span>(</span><span>loop</span><span>
     </span><span>(</span><span>read</span><span> </span><span>r0</span><span>)</span><span>
     </span><span>(</span><span>if</span><span> </span><span>(</span><span>r0</span><span> </span><span>&gt;=</span><span> </span><span>?a</span><span>)</span><span>
         </span><span>(</span><span>if</span><span> </span><span>(</span><span>r0</span><span> </span><span>&lt;=</span><span> </span><span>?z</span><span>)</span><span>
             </span><span>(</span><span>r0</span><span> </span><span>-=</span><span> </span><span>32</span><span>)))</span><span>
     </span><span>(</span><span>write</span><span> </span><span>r0</span><span>)</span><span>
     </span><span>(</span><span>repeat</span><span>))))</span>
</pre>
<p>The processing step is a bit more involved this time.  If the read-in
character appears to be between the <tt>a</tt> and <tt>z</tt> characters,
transform it by subtracting 32.  Why 32?  Take a look at an ASCII
table and you’ll see that this is the distance between uppercase and
lowercase letters.  Unfortunately this implementation cannot challenge
<tt>upcase</tt> as it fails to translate non-ASCII characters correctly and
is slower than the real deal:</p>
<pre><span>(</span><span>ccl-run</span><span> </span><span>&#39;ccl-upcase</span><span> </span><span>&#34;Hello World!&#34;</span><span>)</span><span> </span><span>;=&gt; &#34;HELLO WORLD!&#34;</span><span>
</span><span>(</span><span>ccl-run</span><span> </span><span>&#39;ccl-upcase</span><span> </span><span>&#34;Mötley Crüe&#34;</span><span>)</span><span> </span><span>;=&gt; &#34;MöTLEY CRüE&#34;</span><span>
</span><span>(</span><span>benchmark</span><span> </span><span>100000</span><span> </span><span>&#39;</span><span>(</span><span>ccl-run</span><span> </span><span>&#39;ccl-upcase</span><span> </span><span>&#34;Hello World!&#34;</span><span>))</span><span>
</span><span>;; =&gt; &#34;Elapsed time: 0.165250s (0.072059s in 1 GCs)&#34;</span><span>
</span><span>(</span><span>benchmark</span><span> </span><span>100000</span><span> </span><span>&#39;</span><span>(</span><span>upcase</span><span> </span><span>&#34;Hello World!&#34;</span><span>))</span><span>
</span><span>;; =&gt; &#34;Elapsed time: 0.119050s (0.072329s in 1 GCs)&#34;</span>
</pre>
<p>Let’s try again with a different text transformation where I actually
have a chance to win, <a href="https://en.wikipedia.org/wiki/ROT13">ROT13</a>:</p>
<pre><span>(</span><span>define-ccl-program</span><span> </span><span>ccl-rot13</span><span>
  </span><span>&#39;</span><span>(</span><span>1</span><span>
    </span><span>(</span><span>loop</span><span>
     </span><span>(</span><span>read</span><span> </span><span>r0</span><span>)</span><span>
     </span><span>(</span><span>if</span><span> </span><span>(</span><span>r0</span><span> </span><span>&gt;=</span><span> </span><span>?a</span><span>)</span><span>
         </span><span>(</span><span>if</span><span> </span><span>(</span><span>r0</span><span> </span><span>&lt;=</span><span> </span><span>?z</span><span>)</span><span>
             </span><span>((</span><span>r0</span><span> </span><span>-=</span><span> </span><span>?a</span><span>)</span><span>
              </span><span>(</span><span>r0</span><span> </span><span>+=</span><span> </span><span>13</span><span>)</span><span>
              </span><span>(</span><span>r0</span><span> </span><span>%=</span><span> </span><span>26</span><span>)</span><span>
              </span><span>(</span><span>r0</span><span> </span><span>+=</span><span> </span><span>?a</span><span>))))</span><span>
     </span><span>(</span><span>if</span><span> </span><span>(</span><span>r0</span><span> </span><span>&gt;=</span><span> </span><span>?A</span><span>)</span><span>
         </span><span>(</span><span>if</span><span> </span><span>(</span><span>r0</span><span> </span><span>&lt;=</span><span> </span><span>?Z</span><span>)</span><span>
             </span><span>((</span><span>r0</span><span> </span><span>-=</span><span> </span><span>?A</span><span>)</span><span>
              </span><span>(</span><span>r0</span><span> </span><span>+=</span><span> </span><span>13</span><span>)</span><span>
              </span><span>(</span><span>r0</span><span> </span><span>%=</span><span> </span><span>26</span><span>)</span><span>
              </span><span>(</span><span>r0</span><span> </span><span>+=</span><span> </span><span>?A</span><span>))))</span><span>
     </span><span>(</span><span>write</span><span> </span><span>r0</span><span>)</span><span>
     </span><span>(</span><span>repeat</span><span>))))</span>
</pre>
<p>This time the program needs to recognize two different character
ranges to process, lowercase and uppercase ASCII characters.  In
either case they’re translated to their position in the alphabet,
rotated by 13, then translated back to ASCII again.  Surprisingly
enough, this is enough to beat both <tt><span>rot13-string</span></tt> and
<tt><span>rot13-region</span></tt>:</p>
<pre><span>(</span><span>ccl-run</span><span> </span><span>&#39;ccl-rot13</span><span> </span><span>&#34;Hello World!&#34;</span><span>)</span><span> </span><span>;=&gt; &#34;Uryyb Jbeyq!&#34;</span><span>
</span><span>(</span><span>ccl-run</span><span> </span><span>&#39;ccl-rot13</span><span> </span><span>(</span><span>ccl-run</span><span> </span><span>&#39;ccl-rot13</span><span> </span><span>&#34;Hello World!&#34;</span><span>))</span><span>
</span><span>;; =&gt; &#34;Hello World!&#34;</span><span>
</span><span>(</span><span>benchmark</span><span> </span><span>100000</span><span> </span><span>&#39;</span><span>(</span><span>ccl-run</span><span> </span><span>&#39;ccl-rot13</span><span> </span><span>&#34;Hello World!&#34;</span><span>))</span><span>
</span><span>;; =&gt; &#34;Elapsed time: 0.248791s (0.072622s in 1 GCs)&#34;</span><span>
</span><span>(</span><span>benchmark</span><span> </span><span>100000</span><span> </span><span>&#39;</span><span>(</span><span>rot13-string</span><span> </span><span>&#34;Hello World!&#34;</span><span>))</span><span>
</span><span>;; =&gt; &#34;Elapsed time: 6.108861s (2.360862s in 32 GCs)&#34;</span><span>
</span><span>(</span><span>with-temp-buffer</span><span>
  </span><span>(</span><span>insert</span><span> </span><span>&#34;Hello World!&#34;</span><span>)</span><span>
  </span><span>(</span><span>benchmark</span><span> </span><span>100000</span><span> </span><span>&#39;</span><span>(</span><span>rot13-region</span><span> </span><span>(</span><span>point-min</span><span>)</span><span> </span><span>(</span><span>point-max</span><span>))))</span><span>
</span><span>;; =&gt; &#34;Elapsed time: 1.489205s (1.017631s in 14 GCs)&#34;</span>
</pre>
<p>I then tried to use translation tables for a final example of a
“Vaporwave” converter, but failed.  Funnily enough this mirrors my
overall experience with Emacs, it’s easy to write fun things, but the
moment one tries to write something useful, you discover it’s not fun
and sometimes not even up to the task.  At least it’s possible to
salvage the translation tables and use them with <tt><span>translate-region</span></tt>
instead, the built-in used by <tt><span>rot13-string</span></tt> and <tt><span>rot13-region</span></tt>:</p>
<pre><span>(</span><span>defvar</span><span> </span><span>ccl-vaporwave-table</span><span>
  </span><span>(</span><span>make-translation-table-from-alist</span><span>
   </span><span>(</span><span>cons</span><span> </span><span>&#39;</span><span>(</span><span>?\s</span><span> </span><span>.</span><span> </span><span>12288</span><span>)</span><span>
         </span><span>(</span><span>mapcar</span><span> </span><span>(</span><span>lambda</span><span> </span><span>(</span><span>i</span><span>)</span><span> </span><span>(</span><span>cons</span><span> </span><span>i</span><span> </span><span>(</span><span>+</span><span> </span><span>i</span><span> </span><span>65248</span><span>)))</span><span>
                 </span><span>(</span><span>number-sequence</span><span> </span><span>33</span><span> </span><span>126</span><span>)))))</span><span>

</span><span>(</span><span>defun</span><span> </span><span>vaporwave-it</span><span> </span><span>(</span><span>string</span><span>)</span><span>
  </span><span>(</span><span>with-temp-buffer</span><span>
    </span><span>(</span><span>insert</span><span> </span><span>string</span><span>)</span><span>
    </span><span>(</span><span>translate-region</span><span> </span><span>(</span><span>point-min</span><span>)</span><span> </span><span>(</span><span>point-max</span><span>)</span><span> </span><span>ccl-vaporwave-table</span><span>)</span><span>
    </span><span>(</span><span>buffer-string</span><span>)))</span><span>

</span><span>(</span><span>vaporwave-it</span><span> </span><span>(</span><span>upcase</span><span> </span><span>&#34;aesthetic&#34;</span><span>))</span><span> </span><span>;=&gt; &#34;ＡＥＳＴＨＥＴＩＣ&#34;</span>
</pre>
</div>
<div id="edging-towards-general-purpose-computing">
<h2>Edging towards general-purpose computing</h2>
<p>All examples so far have worked on text.  If you limit yourself to
numbers, you can solve some basic arithmetic problems.  Here’s a
classic, calculating the factorial of a number:</p>
<pre><span>(</span><span>define-ccl-program</span><span> </span><span>ccl-factorial</span><span>
  </span><span>&#39;</span><span>(</span><span>0</span><span>
    </span><span>((</span><span>r1</span><span> </span><span>=</span><span> </span><span>1</span><span>)</span><span>
     </span><span>(</span><span>loop</span><span>
      </span><span>(</span><span>if</span><span> </span><span>r0</span><span>
          </span><span>((</span><span>r1</span><span> </span><span>*=</span><span> </span><span>r0</span><span>)</span><span>
           </span><span>(</span><span>r0</span><span> </span><span>-=</span><span> </span><span>1</span><span>)</span><span>
           </span><span>(</span><span>repeat</span><span>)))))))</span><span>

</span><span>(</span><span>defun</span><span> </span><span>factorial</span><span> </span><span>(</span><span>n</span><span>)</span><span>
  </span><span>(</span><span>let</span><span> </span><span>((</span><span>acc</span><span> </span><span>1</span><span>))</span><span>
    </span><span>(</span><span>while</span><span> </span><span>(</span><span>not</span><span> </span><span>(</span><span>zerop</span><span> </span><span>n</span><span>))</span><span>
      </span><span>(</span><span>setq</span><span> </span><span>acc</span><span> </span><span>(</span><span>*</span><span> </span><span>acc</span><span> </span><span>n</span><span>))</span><span>
      </span><span>(</span><span>setq</span><span> </span><span>n</span><span> </span><span>(</span><span>1-</span><span> </span><span>n</span><span>)))</span><span>
    </span><span>acc</span><span>))</span>
</pre>
<p>While the regular version is more concise, the logic is nearly the
same in both.  Here’s some numbers:</p>
<pre><span>(</span><span>aref</span><span> </span><span>(</span><span>ccl-run-pure</span><span> </span><span>&#39;ccl-factorial</span><span> </span><span>10</span><span>)</span><span> </span><span>1</span><span>)</span><span> </span><span>;=&gt; 3628800</span><span>
</span><span>(</span><span>factorial</span><span> </span><span>10</span><span>)</span><span> </span><span>;=&gt; 3628800</span><span>
</span><span>(</span><span>benchmark</span><span> </span><span>100000</span><span> </span><span>&#39;</span><span>(</span><span>ccl-run-pure</span><span> </span><span>&#39;ccl-factorial</span><span> </span><span>10</span><span>))</span><span>
</span><span>;; =&gt; &#34;Elapsed time: 0.069063s&#34;</span><span>
</span><span>(</span><span>benchmark</span><span> </span><span>100000</span><span> </span><span>&#39;</span><span>(</span><span>factorial</span><span> </span><span>10</span><span>))</span><span>
</span><span>;; =&gt; &#34;Elapsed time: 0.080212s&#34;</span>
</pre>
<p>This isn’t nearly as much of a speed-up as I’ve hoped for.  Perhaps
CCL pays off more when doing arithmetic than for looping?  Another
explanation is that the Emacs Lisp byte-code compiler has an edge over
CCL’s rather simple one.  Here’s a more entertaining example, printing
out the lyrics of 99 Bottles of Beer on the Wall:</p>
<pre><span>(</span><span>define-ccl-program</span><span> </span><span>ccl-print-bottle-count</span><span>
  </span><span>&#39;</span><span>(</span><span>1</span><span>
    </span><span>(</span><span>if</span><span> </span><span>(</span><span>r0</span><span> </span><span>&lt;</span><span> </span><span>10</span><span>)</span><span>
        </span><span>(</span><span>write</span><span> </span><span>(</span><span>r0</span><span> </span><span>+</span><span> </span><span>?0</span><span>))</span><span>
      </span><span>((</span><span>write</span><span> </span><span>((</span><span>r0</span><span> </span><span>/</span><span> </span><span>10</span><span>)</span><span> </span><span>+</span><span> </span><span>?0</span><span>))</span><span>
       </span><span>(</span><span>write</span><span> </span><span>((</span><span>r0</span><span> </span><span>%</span><span> </span><span>10</span><span>)</span><span> </span><span>+</span><span> </span><span>?0</span><span>))))))</span><span>

</span><span>(</span><span>define-ccl-program</span><span> </span><span>ccl-99-bottles</span><span>
  </span><span>&#39;</span><span>(</span><span>1</span><span>
    </span><span>(</span><span>loop</span><span>
     </span><span>(</span><span>if</span><span> </span><span>(</span><span>r0</span><span> </span><span>&gt;</span><span> </span><span>2</span><span>)</span><span>
         </span><span>((</span><span>call</span><span> </span><span>ccl-print-bottle-count</span><span>)</span><span>
          </span><span>(</span><span>write</span><span> </span><span>&#34; bottles of beer on the wall, &#34;</span><span>)</span><span>
          </span><span>(</span><span>call</span><span> </span><span>ccl-print-bottle-count</span><span>)</span><span>
          </span><span>(</span><span>write</span><span> </span><span>&#34; bottles of beer.\n&#34;</span><span>)</span><span>
          </span><span>(</span><span>write</span><span> </span><span>&#34;Take one down and pass it around, &#34;</span><span>)</span><span>
          </span><span>(</span><span>r0</span><span> </span><span>-=</span><span> </span><span>1</span><span>)</span><span>
          </span><span>(</span><span>call</span><span> </span><span>ccl-print-bottle-count</span><span>)</span><span>
          </span><span>(</span><span>write</span><span> </span><span>&#34; bottles of beer on the wall.\n\n&#34;</span><span>)</span><span>
          </span><span>(</span><span>repeat</span><span>))</span><span>
       </span><span>((</span><span>write</span><span> </span><span>&#34;2 bottles of beer on the wall, 2 bottles of beer.\n&#34;</span><span>)</span><span>
        </span><span>(</span><span>write</span><span> </span><span>&#34;Take one down and pass it around, 1 bottle of beer on the wall.\n\n&#34;</span><span>)</span><span>
        </span><span>(</span><span>write</span><span> </span><span>&#34;1 bottle of beer on the wall, 1 bottle of beer.\n&#34;</span><span>)</span><span>
        </span><span>(</span><span>write</span><span> </span><span>&#34;Take one down and pass it around, no more bottles of beer on the wall.\n\n&#34;</span><span>)</span><span>
        </span><span>(</span><span>write</span><span> </span><span>&#34;No more bottles of beer on the wall, no more bottles of beer.\n&#34;</span><span>)</span><span>
        </span><span>(</span><span>write</span><span> </span><span>&#34;Go to the store and buy some more, 99 bottles of beer on the wall.\n&#34;</span><span>))))))</span><span>

</span><span>(</span><span>defun</span><span> </span><span>99-bottles</span><span> </span><span>()</span><span>
  </span><span>(</span><span>with-output-to-string</span><span>
    </span><span>(</span><span>let</span><span> </span><span>((</span><span>i</span><span> </span><span>99</span><span>))</span><span>
      </span><span>(</span><span>while</span><span> </span><span>(</span><span>&gt;</span><span> </span><span>i</span><span> </span><span>2</span><span>)</span><span>
        </span><span>(</span><span>princ</span><span> </span><span>(</span><span>format</span><span> </span><span>&#34;%d bottles of beer on the wall, %d bottles of beer.\n&#34;</span><span> </span><span>i</span><span> </span><span>i</span><span>))</span><span>
        </span><span>(</span><span>princ</span><span> </span><span>(</span><span>format</span><span> </span><span>&#34;Take one down and pass it around, %d bottles of beer on the wall.\n\n&#34;</span><span> </span><span>(</span><span>1-</span><span> </span><span>i</span><span>)))</span><span>
        </span><span>(</span><span>setq</span><span> </span><span>i</span><span> </span><span>(</span><span>-</span><span> </span><span>i</span><span> </span><span>1</span><span>))))</span><span>
    </span><span>(</span><span>princ</span><span> </span><span>&#34;2 bottles of beer on the wall, 2 bottles of beer.\n&#34;</span><span>)</span><span>
    </span><span>(</span><span>princ</span><span> </span><span>&#34;Take one down and pass it around, 1 bottle of beer on the wall.\n\n&#34;</span><span>)</span><span>
    </span><span>(</span><span>princ</span><span> </span><span>&#34;1 bottle of beer on the wall, 1 bottle of beer.\n&#34;</span><span>)</span><span>
    </span><span>(</span><span>princ</span><span> </span><span>&#34;Take one down and pass it around, no more bottles of beer.\n\n&#34;</span><span>)</span><span>
    </span><span>(</span><span>princ</span><span> </span><span>&#34;No more bottles of beer on the wall, no more bottles of beer.\n&#34;</span><span>)</span><span>
    </span><span>(</span><span>princ</span><span> </span><span>&#34;Go to the store and buy some more, 99 bottles of beer on the wall.\n&#34;</span><span>)))</span>
</pre>
<p>This example shows a few more interesting things, generating text of
unknown length is rather hard, so I’m using the standard magnification
factor of 1 and estimate how big the buffer will be to create an
appropriately sized input string.  <tt>call</tt> is useful to not repeat
yourself, at the cost of having to carefully plan register usage.
Printing out the bottle count can be done if you’re limiting yourself
to whole numbers up to 100, a generic solution is going to be hard
without random access to the output string.  The performance numbers
for this one are somewhat surprising:</p>
<pre><span>(</span><span>let</span><span> </span><span>((</span><span>input</span><span> </span><span>(</span><span>make-string</span><span> </span><span>15000</span><span> </span><span>?\s</span><span>)))</span><span>
  </span><span>(</span><span>benchmark</span><span> </span><span>1000</span><span> </span><span>&#39;</span><span>(</span><span>ccl-run</span><span> </span><span>&#39;ccl-99-bottles</span><span> </span><span>input</span><span> </span><span>99</span><span>)))</span><span>
</span><span>;; =&gt; &#34;Elapsed time: 0.301170s (0.217804s in 3 GCs)&#34;</span><span>
</span><span>(</span><span>benchmark</span><span> </span><span>1000</span><span> </span><span>&#39;</span><span>(</span><span>my-99-bottles</span><span>))</span><span>
</span><span>;; =&gt; &#34;Elapsed time: 1.735386s (0.507231s in 7 GCs)&#34;</span>
</pre>
<p>This doesn’t make much sense.  Is using <tt>format</tt> that expensive?
It’s hard to tell in advance whether CCL will make a noticable
difference or not.</p>
</div>
<div id="but-is-it-turing-complete">
<h2>But is it Turing-complete?</h2>
<p>My experimentation so far left me wondering, is this language
turing-complete?  You can perform arithmetics, there’s <tt>goto</tt>, but
the I/O facilities, amount of registers and memory access are
limited.  The easiest way of proving this property is by implementing
another known turing-complete system on top of your current one.  I
researched a bit and found the following candidates:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Brainfuck">Brainfuck</a>: A classic, however it requires writable
memory. Registers could be used for this, but you don’t have many to
play with.  You’d need the <tt>branch</tt> instruction to simulate the
data pointer.</li>
<li><a href="https://en.wikipedia.org/wiki/One_instruction_set_computer#Subtract_and_branch_if_less_than_or_equal_to_zero">subleq</a>: Implementing <tt>subleq</tt> looks easy, but suffers from the
same problem as Brainfuck, it requires you to modify an arbitrary
memory location.  I’ve found a compiler from a C subset to
<tt>subleq</tt> that generates code operating beyond the handful of
registers, so that’s not an option either.</li>
<li><a href="https://en.wikipedia.org/wiki/Rule_110">Rule 110</a>: It’s basically Game of Life, but one-dimensional and
can be implemented in a serial fashion.  With some tricks it doesn’t
require random access either.  The proof of it being turing-complete
looks painful, but whatever, I don’t care.  It’s perfect.  There are
more elementary cellular automata, so I’ll try to implement it in a
generic fashion and demonstrate it on <a href="https://en.wikipedia.org/wiki/Rule_90">Rule 90</a> which produces the
<a href="https://en.wikipedia.org/wiki/Sierpi%C5%84ski_triangle">Sierpinski triangle</a>.</li>
</ul>
<pre><span>(</span><span>defmacro</span><span> </span><span>define-ccl-automaton</span><span> </span><span>(</span><span>n</span><span>)</span><span>
  </span><span>(</span><span>let</span><span> </span><span>((</span><span>print-sym</span><span> </span><span>(</span><span>intern</span><span> </span><span>(</span><span>format</span><span> </span><span>&#34;ccl-rule%d-print&#34;</span><span> </span><span>n</span><span>)))</span><span>
        </span><span>(</span><span>rule-sym</span><span> </span><span>(</span><span>intern</span><span> </span><span>(</span><span>format</span><span> </span><span>&#34;ccl-rule%d&#34;</span><span> </span><span>n</span><span>))))</span><span>
    </span><span>`</span><span>(</span><span>progn</span><span>
       </span><span>(</span><span>define-ccl-program</span><span> </span><span>,</span><span>print-sym</span><span>
         </span><span>&#39;</span><span>(</span><span>1</span><span>
           </span><span>((</span><span>r4</span><span> </span><span>=</span><span> </span><span>0</span><span>)</span><span>
            </span><span>(</span><span>if</span><span> </span><span>(</span><span>r0</span><span> </span><span>==</span><span> </span><span>?1</span><span>)</span><span>
                </span><span>(</span><span>r4</span><span> </span><span>+=</span><span> </span><span>4</span><span>))</span><span>
            </span><span>(</span><span>if</span><span> </span><span>(</span><span>r1</span><span> </span><span>==</span><span> </span><span>?1</span><span>)</span><span>
                </span><span>(</span><span>r4</span><span> </span><span>+=</span><span> </span><span>2</span><span>))</span><span>
            </span><span>(</span><span>if</span><span> </span><span>(</span><span>r2</span><span> </span><span>==</span><span> </span><span>?1</span><span>)</span><span>
                </span><span>(</span><span>r4</span><span> </span><span>+=</span><span> </span><span>1</span><span>))</span><span>
            </span><span>(</span><span>branch</span><span> </span><span>r4</span><span>
                    </span><span>(</span><span>write</span><span> </span><span>,</span><span>(</span><span>if</span><span> </span><span>(</span><span>zerop</span><span> </span><span>(</span><span>logand</span><span> </span><span>n</span><span> </span><span>1</span><span>))</span><span> </span><span>?0</span><span> </span><span>?1</span><span>))</span><span>
                    </span><span>(</span><span>write</span><span> </span><span>,</span><span>(</span><span>if</span><span> </span><span>(</span><span>zerop</span><span> </span><span>(</span><span>logand</span><span> </span><span>n</span><span> </span><span>2</span><span>))</span><span> </span><span>?0</span><span> </span><span>?1</span><span>))</span><span>
                    </span><span>(</span><span>write</span><span> </span><span>,</span><span>(</span><span>if</span><span> </span><span>(</span><span>zerop</span><span> </span><span>(</span><span>logand</span><span> </span><span>n</span><span> </span><span>4</span><span>))</span><span> </span><span>?0</span><span> </span><span>?1</span><span>))</span><span>
                    </span><span>(</span><span>write</span><span> </span><span>,</span><span>(</span><span>if</span><span> </span><span>(</span><span>zerop</span><span> </span><span>(</span><span>logand</span><span> </span><span>n</span><span> </span><span>8</span><span>))</span><span> </span><span>?0</span><span> </span><span>?1</span><span>))</span><span>
                    </span><span>(</span><span>write</span><span> </span><span>,</span><span>(</span><span>if</span><span> </span><span>(</span><span>zerop</span><span> </span><span>(</span><span>logand</span><span> </span><span>n</span><span> </span><span>16</span><span>))</span><span> </span><span>?0</span><span> </span><span>?1</span><span>))</span><span>
                    </span><span>(</span><span>write</span><span> </span><span>,</span><span>(</span><span>if</span><span> </span><span>(</span><span>zerop</span><span> </span><span>(</span><span>logand</span><span> </span><span>n</span><span> </span><span>32</span><span>))</span><span> </span><span>?0</span><span> </span><span>?1</span><span>))</span><span>
                    </span><span>(</span><span>write</span><span> </span><span>,</span><span>(</span><span>if</span><span> </span><span>(</span><span>zerop</span><span> </span><span>(</span><span>logand</span><span> </span><span>n</span><span> </span><span>64</span><span>))</span><span> </span><span>?0</span><span> </span><span>?1</span><span>))</span><span>
                    </span><span>(</span><span>write</span><span> </span><span>,</span><span>(</span><span>if</span><span> </span><span>(</span><span>zerop</span><span> </span><span>(</span><span>logand</span><span> </span><span>n</span><span> </span><span>128</span><span>))</span><span> </span><span>?0</span><span> </span><span>?1</span><span>))))))</span><span>
       </span><span>(</span><span>define-ccl-program</span><span> </span><span>,</span><span>rule-sym</span><span>
         </span><span>&#39;</span><span>(</span><span>1</span><span>
           </span><span>((</span><span>r6</span><span> </span><span>=</span><span> </span><span>,</span><span>n</span><span>)</span><span>
            </span><span>(</span><span>r0</span><span> </span><span>=</span><span> </span><span>0</span><span>)</span><span>
            </span><span>(</span><span>read</span><span> </span><span>r1</span><span>)</span><span>
            </span><span>(</span><span>read</span><span> </span><span>r2</span><span>)</span><span>
            </span><span>(</span><span>loop</span><span>
             </span><span>(</span><span>call</span><span> </span><span>,</span><span>print-sym</span><span>)</span><span>
             </span><span>(</span><span>read</span><span> </span><span>r3</span><span>)</span><span>
             </span><span>(</span><span>r0</span><span> </span><span>=</span><span> </span><span>r1</span><span>)</span><span>
             </span><span>(</span><span>r1</span><span> </span><span>=</span><span> </span><span>r2</span><span>)</span><span>
             </span><span>(</span><span>r2</span><span> </span><span>=</span><span> </span><span>r3</span><span>)</span><span>
             </span><span>(</span><span>repeat</span><span>)))</span><span>
           </span><span>((</span><span>r0</span><span> </span><span>=</span><span> </span><span>r1</span><span>)</span><span>
            </span><span>(</span><span>r1</span><span> </span><span>=</span><span> </span><span>r2</span><span>)</span><span>
            </span><span>(</span><span>r2</span><span> </span><span>=</span><span> </span><span>r5</span><span>)</span><span>
            </span><span>(</span><span>call</span><span> </span><span>,</span><span>print-sym</span><span>)))))))</span><span>

</span><span>(</span><span>define-ccl-automaton</span><span> </span><span>30</span><span>)</span><span>
</span><span>(</span><span>define-ccl-automaton</span><span> </span><span>90</span><span>)</span><span>
</span><span>(</span><span>define-ccl-automaton</span><span> </span><span>110</span><span>)</span><span>

</span><span>(</span><span>defun</span><span> </span><span>ccl-sierpinski</span><span> </span><span>()</span><span>
  </span><span>(</span><span>with-output-to-string</span><span>
    </span><span>(</span><span>let</span><span> </span><span>((</span><span>line</span><span> </span><span>&#34;0000000001000000000&#34;</span><span>))</span><span>
      </span><span>(</span><span>dotimes</span><span> </span><span>(</span><span>_</span><span> </span><span>20</span><span>)</span><span>
        </span><span>(</span><span>princ</span><span> </span><span>line</span><span>)</span><span>
        </span><span>(</span><span>terpri</span><span>)</span><span>
        </span><span>(</span><span>setq</span><span> </span><span>line</span><span> </span><span>(</span><span>ccl-run</span><span> </span><span>&#39;ccl-rule90</span><span> </span><span>line</span><span>))))))</span>
</pre>
<p>The macro may look scary, but all it does is defining two CCL
programs.  What an elementary cellular automaton does is looking at
the two cells around the current cell, map them to a cell depending to
a rule and emit it.  There are two edge cases with this for the first
and last cell, in my implementation the first cell assumes the
previous one was a zero and the last cell uses the first cell.  Since
there’s no random access, it’s stored into a spare register at the
beginning and accessed in a S-Expression after the main loop
terminated due to no more input.  The surrounding and current cell are
stored in three registers and rotated every time a new cell is read
in.  The mapping is done in the print program by summing up the ones
and zeroes, then using the <tt>branch</tt> instruction to apply the rule to
it.  If you find this hard to follow, here’s an Emacs Lisp version of
it using random access and less limited arithmetic to do the job:</p>
<pre><span>(</span><span>defun</span><span> </span><span>rule--evolve</span><span> </span><span>(</span><span>prev</span><span> </span><span>cur</span><span> </span><span>next</span><span> </span><span>n</span><span>)</span><span>
  </span><span>(</span><span>let</span><span> </span><span>((</span><span>acc</span><span> </span><span>(</span><span>+</span><span> </span><span>(</span><span>if</span><span> </span><span>(</span><span>=</span><span> </span><span>prev</span><span> </span><span>?1</span><span>)</span><span> </span><span>4</span><span> </span><span>0</span><span>)</span><span>
                </span><span>(</span><span>if</span><span> </span><span>(</span><span>=</span><span> </span><span>cur</span><span> </span><span>?1</span><span>)</span><span> </span><span>2</span><span> </span><span>0</span><span>)</span><span>
                </span><span>(</span><span>if</span><span> </span><span>(</span><span>=</span><span> </span><span>next</span><span> </span><span>?1</span><span>)</span><span> </span><span>1</span><span> </span><span>0</span><span>))))</span><span>
    </span><span>(</span><span>if</span><span> </span><span>(</span><span>zerop</span><span> </span><span>(</span><span>logand</span><span> </span><span>n</span><span> </span><span>(</span><span>ash</span><span> </span><span>1</span><span> </span><span>acc</span><span>)))</span><span> </span><span>?0</span><span> </span><span>?1</span><span>)))</span><span>

</span><span>(</span><span>defun</span><span> </span><span>rule-evolve</span><span> </span><span>(</span><span>line</span><span> </span><span>n</span><span>)</span><span>
  </span><span>(</span><span>let</span><span> </span><span>((</span><span>out</span><span> </span><span>(</span><span>make-string</span><span> </span><span>(</span><span>length</span><span> </span><span>line</span><span>)</span><span> </span><span>?0</span><span>)))</span><span>
    </span><span>(</span><span>dotimes</span><span> </span><span>(</span><span>i</span><span> </span><span>(</span><span>length</span><span> </span><span>line</span><span>))</span><span>
      </span><span>(</span><span>cond</span><span>
       </span><span>((</span><span>zerop</span><span> </span><span>i</span><span>)</span><span>
        </span><span>(</span><span>aset</span><span> </span><span>out</span><span> </span><span>i</span><span> </span><span>(</span><span>rule--evolve</span><span> </span><span>?0</span><span> </span><span>(</span><span>aref</span><span> </span><span>line</span><span> </span><span>i</span><span>)</span><span> </span><span>(</span><span>aref</span><span> </span><span>line</span><span> </span><span>(</span><span>1+</span><span> </span><span>i</span><span>))</span><span> </span><span>n</span><span>)))</span><span>
       </span><span>((</span><span>=</span><span> </span><span>i</span><span> </span><span>(</span><span>1-</span><span> </span><span>(</span><span>length</span><span> </span><span>line</span><span>)))</span><span>
        </span><span>(</span><span>aset</span><span> </span><span>out</span><span> </span><span>i</span><span> </span><span>(</span><span>rule--evolve</span><span> </span><span>(</span><span>aref</span><span> </span><span>line</span><span> </span><span>(</span><span>1-</span><span> </span><span>i</span><span>))</span><span> </span><span>(</span><span>aref</span><span> </span><span>line</span><span> </span><span>i</span><span>)</span><span> </span><span>(</span><span>aref</span><span> </span><span>line</span><span> </span><span>0</span><span>)</span><span> </span><span>n</span><span>)))</span><span>
       </span><span>(</span><span>t</span><span>
        </span><span>(</span><span>aset</span><span> </span><span>out</span><span> </span><span>i</span><span> </span><span>(</span><span>rule--evolve</span><span> </span><span>(</span><span>aref</span><span> </span><span>line</span><span> </span><span>(</span><span>1-</span><span> </span><span>i</span><span>))</span><span> </span><span>(</span><span>aref</span><span> </span><span>line</span><span> </span><span>i</span><span>)</span><span> </span><span>(</span><span>aref</span><span> </span><span>line</span><span> </span><span>(</span><span>1+</span><span> </span><span>i</span><span>))</span><span> </span><span>n</span><span>)))))</span><span>
    </span><span>out</span><span>))</span><span>

</span><span>(</span><span>defun</span><span> </span><span>sierpinski</span><span> </span><span>()</span><span>
  </span><span>(</span><span>with-output-to-string</span><span>
    </span><span>(</span><span>let</span><span> </span><span>((</span><span>line</span><span> </span><span>&#34;0000000001000000000&#34;</span><span>))</span><span>
      </span><span>(</span><span>dotimes</span><span> </span><span>(</span><span>_</span><span> </span><span>20</span><span>)</span><span>
        </span><span>(</span><span>princ</span><span> </span><span>line</span><span>)</span><span>
        </span><span>(</span><span>terpri</span><span>)</span><span>
        </span><span>(</span><span>setq</span><span> </span><span>line</span><span> </span><span>(</span><span>rule-evolve</span><span> </span><span>line</span><span> </span><span>90</span><span>))))))</span>
</pre>
<p>One more benchmark run, this time with less surprising performance
numbers:</p>
<pre><span>(</span><span>benchmark</span><span> </span><span>1000</span><span> </span><span>&#39;</span><span>(</span><span>ccl-sierpinski</span><span>))</span><span>
</span><span>;; =&gt; &#34;Elapsed time: 0.365031s (0.071827s in 1 GCs)&#34;</span><span>
</span><span>(</span><span>benchmark</span><span> </span><span>1000</span><span> </span><span>&#39;</span><span>(</span><span>sierpinski</span><span>))</span><span>
</span><span>;; =&gt; &#34;Elapsed time: 0.545512s (0.071829s in 1 GCs)&#34;</span>
</pre>
<p>If you want to see it in action, try evaluating <tt>(progn (princ
(sierpinski)) nil)</tt> in <tt><span>M-x</span> ielm</tt>.</p>
<p>Now for a big letdown, despite everything what I’ve demonstrated, this
system is not turing-complete after all.  While it’s capable of
processing a single line of input, the proof of <a href="https://en.wikipedia.org/wiki/Rule_110">Rule 110</a> being
turing-complete relies on feeding its output in as input over and over
again, however that part has been done in Emacs Lisp as it’s
impossible to do in CCL.  I’m not 100% sure what CCL’s computing power
is, Noam Postavsky suggested on <tt>#emacs</tt> that it’s most likely a
<a href="https://en.wikipedia.org/wiki/Finite-state_transducer">finite-state transducer</a>.</p>
</div>
<div id="final-words">
<h2>Final words</h2>
<p>You may ask yourself now whether you should rewrite all of your slow
code to CCL programs.  I don’t believe that’s the way to go for a
number of reasons:</p>
<ul>
<li>Speedups vary wildly, somewhere between -40% to 450%.  There’s no
obvious way of predicting whether the optimization is worth it.</li>
<li>It’s hard to write an equivalent program or sometimes even
impossible, especially if it requires you to use many variables or
random access read/write operations.</li>
<li>It’s hard to debug a CCL program.  While the compiler does a good
job at catching syntax errors, runtime errors are far harder to
figure out if you can only stare at the registers.  Maybe a debugger
could be built that uses the “continue” facility and instruction
counter register…</li>
<li>It’s hard to maintain a CCL program.  Not to mention, there’s hardly
people who know how to write them.  Most of the examples I’ve found
online do text encoding/decoding.  The only exception to this is
<tt><span>pgg-parse-crc24-string</span></tt> which lives in a file marked as obsolete.</li>
<li>This leads me to my last point, CCL may be obsoleted as well.
Granted, it will take time, but so far I haven’t seen people
enthusiastic about it being a thing.</li>
</ul>
<p>If you still believe that despite of this it’s worth giving CCL a try,
please let me know, especially if you’re doing something non-standard
with it, like advanced cryptography or number crunching.  Likewise, if
you’re not convinced that it’s turing-complete or that I could be
doing some things far better than presented, send me a message.</p>
</div>

<hr/></article></div></div>
  </body>
</html>
