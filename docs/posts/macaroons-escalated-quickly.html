<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fly.io/blog/macaroons-escalated-quickly/">Original</a>
    <h1>Macaroons Escalated Quickly</h1>
    
    <div id="readability-page-1" class="page"><article>
         <dl>
             <dt>Author</dt>
             <dd>
                 <img alt="Thomas Ptacek" src="https://angelolloti.com/static/images/thomas.webp"/>
               <dl>
                 <dt>Name</dt>
                 <dd>
                   Thomas Ptacek
                 </dd>
                  <dt>@tqbf</dt>
                  <dd>
                    <a href="https://twitter.com/tqbf" target="_blank">
                      @tqbf
                    </a>
                  </dd>
               </dl>
             </dd>
         </dl>

        <section>
            <figure>
                <img src="https://angelolloti.com/blog/macaroons-escalated-quickly/assets/evil-cookies-cover.webp" alt="Evil cookies!"/>
                <figcaption>
                  <span>Image by</span>
                  
<svg role="img" style="pointer-events: none; width: 17px; height: 17px;" viewBox="0 0 20 20" fill="currentColor" fill-rule="evenodd">
  <g buffered-rendering="static">
    <path fill-rule="evenodd" d="M1 8a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 018.07 3h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0016.07 6H17a2 2 0 012 2v7a2 2 0 01-2 2H3a2 2 0 01-2-2V8zm13.5 3a4.5 4.5 0 11-9 0 4.5 4.5 0 019 0zM10 14a3 3 0 100-6 3 3 0 000 6z" clip-rule="evenodd"></path>
  </g>
</svg>

                    <a href="https://annieruygtillustration.com/" target="_blank">
                      Annie Ruygt
                    </a>
                </figcaption>
            </figure>
          <p>We’re Fly.io and we transmute containers into VMs, running them on our hardware around the world. We built a new security token system, and can I tell you the good news about our lord and savior the Macaroon?</p><h2 id="1"><a href="#1" aria-label="Anchor"></a>1</h2>
<p>Let’s implement an API token together. It’s a design called “Macaroons”, but don’t get hung up on that yet.</p>

<p>First some . Then:</p>
<div id="includes" toggle-content="" aria-label="show very boring code"><div>
  <pre><code><span>import</span> <span>sys</span>
<span>import</span> <span>os</span>
<span>import</span> <span>json</span>
<span>import</span> <span>hmac</span> <span>as</span> <span>hm</span>
<span>from</span> <span>base64</span> <span>import</span> <span>b64encode</span><span>,</span> <span>b64decode</span>
<span>from</span> <span>hashlib</span> <span>import</span> <span>sha256</span>

<span>def</span> <span>hmac</span><span>(</span><span>k</span><span>,</span> <span>v</span><span>):</span> <span>return</span> <span>hm</span><span>.</span><span>new</span><span>(</span><span>k</span><span>,</span> <span>v</span><span>,</span> <span>sha256</span><span>).</span><span>digest</span><span>()</span>
<span>def</span> <span>enc</span><span>(</span><span>x</span><span>):</span> <span>return</span> <span>b64encode</span><span>(</span><span>x</span><span>)</span>
<span>def</span> <span>dec</span><span>(</span><span>x</span><span>):</span> <span>return</span> <span>b64decode</span><span>(</span><span>x</span><span>)</span>
</code></pre>
</div>
</div><div>
  <pre><code><span>def</span> <span>blank_token</span><span>(</span><span>uid</span><span>,</span> <span>key</span><span>):</span>
  <span>nonce</span> <span>=</span> <span>enc</span><span>(</span><span>&#34;:&#34;</span><span>.</span><span>join</span><span>([</span><span>str</span><span>(</span><span>uid</span><span>),</span> <span>os</span><span>.</span><span>urandom</span><span>(</span><span>16</span><span>)]))</span>
  <span>return</span> <span>json</span><span>.</span><span>dumps</span><span>([</span><span>nonce</span><span>,</span> <span>enc</span><span>(</span><span>hmac</span><span>(</span><span>key</span><span>,</span> <span>nonce</span><span>))])</span>
</code></pre>
</div>
<p>Bearer tokens: like cookies, blobs you attach to a request (usually in an HTTP header).</p>
<p>We’re going to build a minimally-stateful bearer token, a blob signed with HMAC. Nothing fancy so far. <a href="https://api.rubyonrails.org/classes/ActiveSupport/MessageVerifier.html">Rails has done this</a> for a decade and a half.</p>

<p>There’s a <a href="http://cryto.net/%7Ejoepie91/blog/2016/06/13/stop-using-jwt-for-sessions/">fashion in API security for stateless tokens</a>, which encode all the data you’d need to check any request accompanied by that token – without a database lookup. Stateless tokens have some nice properties, and some less-nice. Our tokens won’t be stateless: they carry a user ID, with which we’ll look up the HMAC key to verify it. But they’ll stake out a sort of middle ground.</p>
<div>
  <pre><code><span>def</span> <span>attenuate</span><span>(</span><span>macStr</span><span>,</span> <span>cav</span><span>):</span>
    <span>mac</span> <span>=</span> <span>json</span><span>.</span><span>loads</span><span>(</span><span>macStr</span><span>)</span>
    <span>cavStr</span> <span>=</span> <span>json</span><span>.</span><span>dumps</span><span>(</span><span>cav</span><span>)</span>
    <span>oldTail</span> <span>=</span> <span>dec</span><span>(</span><span>mac</span><span>[</span><span>-</span><span>1</span><span>])</span>         
    <span>newTail</span> <span>=</span> <span>enc</span><span>(</span><span>hmac</span><span>(</span><span>oldTail</span><span>,</span> <span>cavStr</span><span>))</span>    
    <span>return</span> <span>json</span><span>.</span><span>dumps</span><span>(</span><span>mac</span><span>[</span><span>0</span><span>:</span><span>-</span><span>1</span><span>]</span> <span>+</span> <span>[</span><span>cavStr</span><span>,</span> <span>newTail</span><span>])</span>

<span>m0</span> <span>=</span> <span>blank_token</span><span>(</span><span>10</span><span>,</span> <span>keys</span><span>[</span><span>10</span><span>])</span>
<span>m1</span> <span>=</span> <span>attenuate</span><span>(</span><span>m0</span><span>,</span> <span>{</span><span>&#39;path&#39;</span><span>:</span> <span>&#39;/images&#39;</span><span>})</span>
<span>m2</span> <span>=</span> <span>attenuate</span><span>(</span><span>m1</span><span>,</span> <span>{</span><span>&#39;op&#39;</span><span>:</span> <span>&#39;read&#39;</span><span>})</span>
</code></pre>
</div>

<p>Let’s add some stuff.</p>

<p>The meat of our tokens will be a series of claims we call “caveats”. We call them that because each claim restricts further what the token authorizes. After <code>{&#39;path&#39;: &#39;/images&#39;}</code>, this token only allows operations that happen underneath the <code>/images</code> directory. Then, after <code>{&#39;op&#39;: &#39;read&#39;}</code>, it allows only reads, not writes.</p>

<p>(I guess we’re building a file sharing system. Whatever.)</p>

<p>Some important things about things about this design. First: by implication from the fact that caveats further restrict tokens, a token with no caveats restricts nothing. It’s a god-mode token. Don’t honor it.</p>
<p>In other words: the ordering of caveats doesn’t matter.</p>
<p>Second: the rule of checking caveats is very simple: every single caveat must pass, evaluating <code>True</code> against the request that carries it, in isolation and without reference to any other caveat. If any caveat evaluates <code>False</code>, the request fails. In that way, we ensure that adding caveats to a token can only ever weaken it.</p>

<p>With that in mind, take a closer look at this code:</p>
<div>
  <pre><code><span>oldTail</span> <span>=</span> <span>dec</span><span>(</span><span>mac</span><span>[</span><span>-</span><span>1</span><span>])</span>         
<span>newTail</span> <span>=</span> <span>enc</span><span>(</span><span>hmac</span><span>(</span><span>oldTail</span><span>,</span> <span>cavStr</span><span>))</span>    
</code></pre>
</div>

<p>Every caveat is HMAC-signed independently, which is weird. Weirder still, the key for that HMAC is the output of the last HMAC. The caveats chain together, and the HMAC of the last caveat becomes the “tail” of the token.</p>

<p>Creating a new blank token for a particular user requires a key that the server (and probably only the server) knows. But adding a caveat doesn’t! Anybody can add a caveat. In our design, you, the user, can edit your own API token.</p>
<div>
  <pre><code><span>def</span> <span>verify</span><span>(</span><span>macStr</span><span>,</span> <span>keys</span><span>):</span>
    <span>mac</span> <span>=</span> <span>json</span><span>.</span><span>loads</span><span>(</span><span>macStr</span><span>)</span>
    <span>nonce</span> <span>=</span> <span>dec</span><span>(</span><span>mac</span><span>[</span><span>0</span><span>]).</span><span>split</span><span>(</span><span>&#34;:&#34;</span><span>)</span>
    <span>key</span> <span>=</span> <span>keys</span><span>[</span><span>int</span><span>(</span><span>nonce</span><span>[</span><span>0</span><span>])]</span>
    <span>tail</span> <span>=</span> <span>&#34;&#34;</span>
    <span>for</span> <span>cav</span> <span>in</span> <span>mac</span><span>[:</span><span>-</span><span>1</span><span>]:</span>
        <span>tail</span> <span>=</span> <span>hmac</span><span>(</span><span>key</span><span>,</span> <span>cav</span><span>)</span>
        <span>key</span> <span>=</span> <span>tail</span>
    <span>return</span> <span>hm</span><span>.</span><span>compare_digest</span><span>(</span><span>tail</span><span>,</span> <span>dec</span><span>(</span><span>mac</span><span>[</span><span>-</span><span>1</span><span>]))</span>

<span>verify</span><span>(</span><span>m2</span><span>,</span> <span>keys</span><span>)</span> <span># =&gt; True
</span></code></pre>
</div>

<p>For completeness, and to make a point, there’s the verification code. Look up the original secret key from the user ID,  and then it’s chained HMAC all the way down. The point I’m making is that Macaroons are very simple.</p>
<h2 id="2"><a href="#2" aria-label="Anchor"></a>2</h2>
<p>Back in 2014, Google published <a href="https://storage.googleapis.com/pub-tools-public-publication-data/pdf/41892.pdf">a paper at NDSS</a> introducing “Macaroons”, a new kind of cookie. Since then, they’ve become a sort of hipster shibboleth. But they’re more talked about than implemented, which is a nice way to say that practically nobody uses them.</p>

<p>Until now! I dragged Fly.io into implementing them. Suckers!</p>

<p>We had a problem: our API tokens were much too powerful. We needed to scope them down and let them express roles, and I scoped up that project to replace OAuth2 tokens altogether. We now have what I think is one of the more expansive Macaroon implementations on the Internet.</p>

<p>I dragged us into using Macaroons because I wanted us to use a hipster token format. Google designed Macaroons for a bigger reason: they hoped to replace browser cookies with something much more powerful.</p>

<p>The problem with simple bearer tokens, like browser cookies or JWTs, is that they’re prone to being stolen and replayed by attackers.</p>
<p>game-over: pentest jargon for “very bad”</p>
<p>Worse, a stolen token is usually a game-over condition. In most schemes, a bearer token is an all-access pass for the associated user. For some applications this isn’t that big a deal, but then, <a href="https://neilmadden.blog/2020/09/09/macaroon-access-tokens-for-oauth-part-2-transactional-auth/">think about banking</a>. A banking app token that authorizes arbitrary transactions is a recipe for having a small heart attack on every HTTP request.</p>
<p>(Perfectly minimized API tokens: a software security holy grail)</p>
<p>Macaroons are user-editable tokens that enable JIT-generated least-privilege tokens. With minimal ceremony and no additional API requests, a banking app Macaroon lets you authorize a request with a caveat like, I don’t know, <code>{&#39;maxAmount&#39;: &#39;$5&#39;}</code>. I mean, something way better than that, probably lots of caveats, not just one, but you get the idea: a token so minimized you feel safe sending it with your request. Ideally, a token that only authorizes that single, intended request.</p>
<h2 id="3"><a href="#3" aria-label="Anchor"></a>3</h2>
<p>That’s not why we like Macaroons. We already assume our tokens aren’t being stolen.</p>

<p>In most systems, the developers come up with a permissions system, and you’re stuck with it. We run a public cloud platform, and people want a lot of different things from our permissions. The dream is, we (the low-level platform developers on the team) design a single permission system, one time, and go about our jobs never thinking about this problem again.</p>

<p>Instead of thinking of all of our “roles” in advance, we just model our platform with caveats:</p>

<ol>
<li>Users belong to <code>Organizations</code>.
</li><li><code>Organizations</code> own <code>Apps</code>.
</li><li><code>Apps</code> contain <code>Machines</code> and <code>Volumes</code>.
</li><li>To any of these things, you can <code>Read</code>, <code>Write</code>, <code>Create</code>, <code>Delete</code>, and/or <code>Control</code> .
</li><li>Some administrivia, like expiration (<code>ValidityWindow</code>), locking tokens to specific Fly Machines (<code>FromMachineSource</code>), and escape hatches like <code>Mutation</code> (for our GraphQL API).
</li></ol>
<p>(this is a vibes-based notation, don’t think too hard about it)</p>
<p>Simplistic. But it expresses admin tokens: </p>
<div>
  <pre><code>Organization 4721, mask=*
</code></pre>
</div>

<p>And it expresses normal user tokens:</p>
<div>
  <pre><code>Organization 4721, mask=read,write,control
(App 123, mask=control), (App 345, mask=read, write, control)
</code></pre>
</div>

<p>And also an auditor-only token for that user:</p>
<div>
  <pre><code>Organization 4721, mask=read,write,control
(App 123, mask=control), (App 345, mask=read, write, control)
Organization 4721, mask=read
</code></pre>
</div>
<p>(our deploy tokens are more complicated than this)</p>
<p>Or a deployment-only token, for a CI/CD system:</p>
<div>
  <pre><code>Organization 4721, mask=write,control
(App 123, mask=*)
</code></pre>
</div>

<p>Those are just the roles we came up with. Users can invent others. The important thing is that they don’t have to bother me about them.</p>
<h2 id="4"><a href="#4" aria-label="Anchor"></a>4</h2>
<p>Astute readers will have noticed by now that we haven’t shown any code that actually evaluates a caveat. That’s because it’s boring, and I’m too lazy to write it out. Got an <code>Organization</code> token for <code>image-hosting</code> that allows <code>Reads</code>? Ok; check and make sure the incoming request is for an asset of <code>image-hosting</code>, and that it’s a <code>Read</code>. Whatever code you came up with, it’d be fine.</p>

<p>These straightforward restrictions are called “first party caveats”. The first party is us, the platform. We’ve got all the information we need to check them.</p>

<p>Let’s kit out our token format some more.</p>
<div>
  <pre><code><span>def</span> <span>third_party_caveat</span><span>(</span><span>ka</span><span>,</span> <span>msg</span><span>,</span> <span>url</span><span>):</span>
    <span>crk</span> <span>=</span> <span>os</span><span>.</span><span>urandom</span><span>(</span><span>16</span><span>)</span>
    <span>ticket</span> <span>=</span> <span>enc</span><span>(</span><span>encrypt</span><span>(</span><span>ka</span><span>,</span> <span>json</span><span>.</span><span>dumps</span><span>({</span>
        <span>&#39;crk&#39;</span><span>:</span> <span>enc</span><span>(</span><span>crk</span><span>),</span>
        <span>&#39;msg&#39;</span><span>:</span> <span>msg</span>
    <span>})))</span>
    <span>challenge</span> <span>=</span> <span>enc</span><span>(</span><span>encrypt</span><span>(</span><span>tag</span><span>,</span> <span>crk</span><span>))</span>
    <span>return</span> <span>{</span> <span>&#39;url&#39;</span><span>:</span> <span>url</span><span>,</span> <span>&#39;ticket&#39;</span><span>:</span> <span>ticket</span><span>,</span> <span>&#39;challenge&#39;</span> <span>:</span> <span>challenge</span> <span>}</span>

<span>key</span> <span>=</span> <span>bytes</span><span>(</span><span>&#34;YELLOWSUBMARINE&#34;</span><span>)</span>
<span>url</span> <span>=</span> <span>&#34;https://canary.service&#34;</span>
<span>c3</span> <span>=</span> <span>third_party_caveat</span><span>(</span><span>key</span><span>,</span> <span>url</span><span>,</span> <span>json</span><span>.</span><span>dumps</span><span>({</span><span>&#39;user&#39;</span><span>:</span> <span>&#39;bobson.dugnutt&#39;</span><span>}))</span>
<span>m3</span> <span>=</span> <span>attenuate</span><span>(</span><span>m2</span><span>,</span> <span>c3</span><span>)</span>
</code></pre>
</div>

<p>Up till now, we’ve gotten by with nothing but HMAC, which is one of the great charms of the design. Now we need to encrypt. There’s no authenticated encryption in the Python standard library, but that won’t stop us. </p>
<div id="hmac-ctr" toggle-content="" aria-label="show very silly code"><div>
  <pre><code><span># do i really need to say that i&#39;m not serious about this?
</span>
<span>def</span> <span>hmactr</span><span>(</span><span>k</span><span>,</span> <span>n</span><span>):</span>
     <span>ks</span> <span>=</span> <span>hm</span><span>.</span><span>new</span><span>(</span><span>k</span><span>+</span><span>n</span><span>)</span>
     <span>for</span> <span>counter</span> <span>in</span> <span>xrange</span><span>(</span><span>sys</span><span>.</span><span>maxint</span><span>):</span>
         <span>ks</span><span>.</span><span>update</span><span>(</span><span>str</span><span>(</span><span>counter</span><span>))</span>
         <span>kbs</span> <span>=</span> <span>ks</span><span>.</span><span>digest</span><span>()</span>
         <span>for</span> <span>i</span> <span>in</span> <span>xrange</span><span>(</span><span>16</span><span>):</span> <span>yield</span> <span>kbs</span><span>[</span><span>i</span><span>]</span>

<span>def</span> <span>encrypt</span><span>(</span><span>k</span><span>,</span> <span>buf</span><span>):</span>
    <span>ak</span> <span>=</span> <span>hm</span><span>.</span><span>new</span><span>(</span><span>k</span><span>,</span> <span>&#39;auth&#39;</span><span>).</span><span>digest</span><span>()</span>
    <span>nonce</span> <span>=</span> <span>os</span><span>.</span><span>urandom</span><span>(</span><span>16</span><span>)</span>
    <span>cipher</span> <span>=</span> <span>hmactr</span><span>(</span><span>hm</span><span>.</span><span>new</span><span>(</span><span>k</span><span>,</span> <span>&#39;enc&#39;</span><span>).</span><span>digest</span><span>(),</span> <span>nonce</span><span>)</span>
    <span>ctxt</span> <span>=</span> <span>bytearray</span><span>(</span><span>buf</span><span>)</span>
    <span>for</span> <span>i</span> <span>in</span> <span>xrange</span><span>(</span><span>len</span><span>(</span><span>buf</span><span>)):</span>
        <span>ctxt</span><span>[</span><span>i</span><span>]</span> <span>^=</span> <span>ord</span><span>(</span><span>cipher</span><span>.</span><span>next</span><span>())</span>
    <span>res</span> <span>=</span> <span>nonce</span> <span>+</span> <span>str</span><span>(</span><span>ctxt</span><span>)</span>
    <span>return</span> <span>res</span> <span>+</span> <span>hm</span><span>.</span><span>new</span><span>(</span><span>ak</span><span>,</span> <span>res</span><span>).</span><span>digest</span><span>()</span>

<span>def</span> <span>decrypt</span><span>(</span><span>k</span><span>,</span> <span>buf</span><span>):</span>
    <span>ak</span> <span>=</span> <span>hm</span><span>.</span><span>new</span><span>(</span><span>k</span><span>,</span> <span>&#39;auth&#39;</span><span>).</span><span>digest</span><span>()</span>
    <span>if</span> <span>not</span> <span>hm</span><span>.</span><span>compare_digest</span><span>(</span><span>buf</span><span>[</span><span>-</span><span>16</span><span>:],</span> <span>hm</span><span>.</span><span>new</span><span>(</span><span>ak</span><span>,</span> <span>buf</span><span>[:</span><span>-</span><span>16</span><span>]).</span><span>digest</span><span>()):</span>
        <span>return</span> <span>False</span>
    <span>nonce</span> <span>=</span> <span>buf</span><span>[:</span><span>16</span><span>]</span>
    <span>cipher</span> <span>=</span> <span>hmactr</span><span>(</span><span>hm</span><span>.</span><span>new</span><span>(</span><span>k</span><span>,</span> <span>&#39;enc&#39;</span><span>).</span><span>digest</span><span>(),</span> <span>nonce</span><span>)</span>
    <span>ptxt</span> <span>=</span> <span>bytearray</span><span>(</span><span>buf</span><span>[</span><span>16</span><span>:</span><span>-</span><span>16</span><span>])</span>
    <span>for</span> <span>i</span> <span>in</span> <span>xrange</span><span>(</span><span>len</span><span>(</span><span>buf</span><span>[</span><span>16</span><span>:</span><span>-</span><span>16</span><span>])):</span>
        <span>ptxt</span><span>[</span><span>i</span><span>]</span> <span>^=</span> <span>ord</span><span>(</span><span>cipher</span><span>.</span><span>next</span><span>())</span>
    <span>return</span> <span>str</span><span>(</span><span>ptxt</span><span>)</span>
</code></pre>
</div>
</div>
<p>With “third-party” caveats comes a cast of characters. We’re still the first party. You’ll play the second party. The third party is any other system in the world that you trust: an SSO system, an audit log, a revocation checker, whatever.</p>

<p>Here’s the trick of the third-party caveat: our platform doesn’t know what your caveat means, and it doesn’t have to. Instead, when you see a third-party caveat in your token, you tear a ticket off it and exchange it for a “discharge Macaroon” with that third party. You submit both Macaroons together to us.</p>

<p>Let’s attenuate our token with a third-party caveat hooking it up to a “canary” service that generates a notice approximately any time the token is used.</p>

<p><img src="https://angelolloti.com/blog/macaroons-escalated-quickly/assets/third-party.png?1/2&amp;wrap-left"/></p>

<p>To build that canary caveat, you first make a <code>ticket</code> that users of the token will hand to your canary, and then a <code>challenge</code> that Fly.io will use to verify discharges your checker spits out. The ticket and the challenge are both encrypted. The ticket is encrypted under <code>KA</code>, so your service can read it. The challenge is encrypted under the previous Macaroon tail, so only Fly.io can read it. Both hide yet another key, the random HMAC key <code>CRK</code> (“caveat root key”).</p>

<p>In addition to <code>CRK</code>, the ticket contains a message, which says whatever you want it to; Fly.io doesn’t care. Typically, the message describes some kind of additional checking you want your service to perform before spitting out a discharge token.</p>
<div>
  <pre><code><span>def</span> <span>discharge</span><span>(</span><span>ka</span><span>,</span> <span>ticket</span><span>):</span>
    <span>ptxt</span> <span>=</span> <span>decrypt</span><span>(</span><span>ka</span><span>,</span> <span>dec</span><span>(</span><span>ticket</span><span>))</span>
    <span>if</span> <span>ptxt</span> <span>==</span> <span>False</span><span>:</span> <span>return</span> <span>False</span>
    <span>tbody</span> <span>=</span> <span>json</span><span>.</span><span>loads</span><span>(</span><span>ptxt</span><span>)</span>
    <span># not shown: do something with tbody[&#39;msg&#39;]
</span>    <span>return</span> <span>json</span><span>.</span><span>dumps</span><span>([</span><span>ticket</span><span>,</span> <span>enc</span><span>(</span><span>hmac</span><span>(</span><span>dec</span><span>(</span><span>tbody</span><span>[</span><span>&#39;crk&#39;</span><span>]),</span> <span>ticket</span><span>))])</span>
</code></pre>
</div>

<p>To authorize a request with a token that includes a third-party caveat for the canary service, you need to get your hands on a corresponding discharge Macaroon. Normally, you do that by <code>POST</code>ing the ticket from the caveat to the service.</p>

<p>Discharging is simple. The service, which holds <code>KA</code>, uses it to decrypt the ticket. It checks the message and makes some decisions. Finally, it mints a new macaroon, using <code>CRK</code>, recovered from the ticket, as the root key. The ticket itself is the nonce.</p>

<p>If it wants, the third-party service can slap on a bunch of first-party caveats of its own. When we verify the Macaroon, we’ll copy those caveats out and enforce them. Attenuation of a third-party discharge macaroon works like a normal macaroon.</p>
<div>
  <pre><code><span>def</span> <span>verify_third_party</span><span>(</span><span>tag</span><span>,</span> <span>cav</span><span>,</span> <span>discharges</span><span>=</span><span>[]):</span>
    <span>crk</span> <span>=</span> <span>decrypt</span><span>(</span><span>tag</span><span>,</span> <span>dec</span><span>(</span><span>cav</span><span>[</span><span>&#39;challenge&#39;</span><span>]))</span>
    <span>if</span> <span>crk</span> <span>==</span> <span>False</span><span>:</span> <span>return</span> <span>False</span>
    <span>discharge</span> <span>=</span> <span>None</span>
    <span>for</span> <span>dcs</span> <span>in</span> <span>discharges</span><span>:</span>
        <span>if</span> <span>json</span><span>.</span><span>loads</span><span>(</span><span>dcs</span><span>)[</span><span>0</span><span>]</span> <span>==</span> <span>cav</span><span>[</span><span>&#39;ticket&#39;</span><span>]:</span>
            <span>discharge</span> <span>=</span> <span>dcs</span>
            <span>break</span>
    <span>if</span> <span>not</span> <span>discharge</span><span>:</span> <span>return</span> <span>False</span>
    <span>mac</span> <span>=</span> <span>json</span><span>.</span><span>loads</span><span>(</span><span>discharge</span><span>)</span>
    <span>key</span> <span>=</span> <span>crk</span>
    <span># boring old stuff ---------------------
</span>    <span>tag</span> <span>=</span> <span>&#34;&#34;</span>
    <span>for</span> <span>cav</span> <span>in</span> <span>mac</span><span>[:</span><span>-</span><span>1</span><span>]:</span>
        <span>tag</span> <span>=</span> <span>hmac</span><span>(</span><span>key</span><span>,</span> <span>cav</span><span>)</span>
        <span>key</span> <span>=</span> <span>tag</span>
    <span>return</span> <span>hm</span><span>.</span><span>compare_digest</span><span>(</span><span>tag</span><span>,</span> <span>dec</span><span>(</span><span>mac</span><span>[</span><span>-</span><span>1</span><span>]))</span>
</code></pre>
</div>

<p>To verify tokens that have third-party caveats, start with the root Macaroon, walking the caveats like usual. At each third-party caveat, match the <code>ticket</code> from the caveat with the <code>nonce</code> on the discharge Macaroon. The key for root Macaroon decrypts the <code>challenge</code> in the caveat, recovering <code>CRK</code>, which cryptographically verifies the discharge.</p>

<p>(The Macaroons paper uses different terms: “caveat identifier” or <code>cId</code> for “ticket”, and “verification-key identifier” or <code>vId</code> for “challenge”. These names are self-evidently bad and our contribution to the state of the art is to replace them.)</p>

<p>There’s two big applications for third-party caveats in Popular Macaroon Thought. First, they facilitate microservice-izing your auth logic, because you can stitch arbitrary policies together out of third-party caveats. And, they seem like <a href="https://github.com/go-macaroon-bakery/macaroon-bakery">fertile ground for an ecosystem of interoperable Macaroon services</a>: Okta and Google could stand up SSO dischargers, for instance, or someone can do a really good revocation service.</p>

<p>Neither of these light us up. We’re allergic to microservices. As for public protocols, well, it’s good to want things. So we almost didn’t even implement third-party caveats.</p>
<h2 id="5"><a href="#5" aria-label="Anchor"></a>5</h2>
<p>I’m glad we did though, because they’ve been pretty great.</p>

<p>The first problem third-party caveats solved for us was hazmat tokens. To the extent possible, we want Macaroon tokens to be safe to transmit between users. Our Macaroons express permissions, but not authentication, so it’s almost safe to email them.</p>

<p>The way it works is, our Macaroons all have a third-party caveat pointing to a “login service”, either identifying the proper bearer as a particular Fly.io user or as a member of some <code>Organization</code>. To allow a request with your token, you first need to collect the discharge from the login service, which requires authentication.</p>

<p>The login discharge is very sensitive, but there isn’t much reason to pass it around. The original permissions token is where all the interesting stuff is, and it’s not scary. So that’s nice.</p>

<p><img src="https://angelolloti.com/blog/macaroons-escalated-quickly/assets/fly-sso.png?1/3&amp;wrap-left"/></p>

<p>Ben then came up with <a href="https://community.fly.io/t/organization-required-sso/17560">third-party caveats that require Google or Github SSO logins.</a> If your token has one of those caveats, when you run <code>flyctl deploy</code>, a browser will pop up to log you into your SSO IdP (if you haven’t done so recently already).</p>

<p>We’ve put a <a href="https://fly.io/blog/tokenized-tokens/#tokenizer-the-fabled-4th-way">bunch of work into getting the guts of our SSO system working</a>, but that work has mostly been invisible to customers. But Macaroon-ized SSO has a subtle benefit: you can configure <a href="http://Fly.io">Fly.io</a> to automatically add SSO requirements to specific <code>Organizations</code> (so, for instance, a dev environment might not need SSO at all, and prod might need two).</p>

<p>SSO requirements in most applications are a brittle pain in the ass. Ours are flexible and straightforward, and that happened almost by accident. Macaroons, baby!</p>

<p>Here’s a fun thing you can do with a Macaroon system: stand up a Slack bot, and give it an HTTP <code>POST</code> handler that accepts third-party tickets. Then:</p>

<p><img src="https://angelolloti.com/blog/macaroons-escalated-quickly/assets/bot-ok.png?1/2&amp;center&amp;border"/></p>

<p>So, the bot is cute, but any platform could do that. What’s cool is the way our platform <em>doesn’t</em> work with Slack; in fact, nothing on our platform knows anything about Slack, and Slack doesn’t know anything about us. We didn’t reach out to a Slack endpoint. Everything was purely cryptographic.</p>

<p>That bot could, if I sunk some time into it, enforce arbitrary rules: it could selectively add caveats for the requests it authorizes, based on lookups of the users requesting them, at specific times of day, with specific logging. Theoretically, it could add third-party caveats of its own.</p>

<p>The win for us for third-party caveats is that they create a plugin system for our security tokens. That’s an unusual place to see a plugin interface! But Macaroons are easy to understand and keep in your head, so we’re pretty confident about the security issues.</p>
<h2 id="6"><a href="#6" aria-label="Anchor"></a>6</h2>
<p>Obviously, we didn’t write our Macaroon code in Python, or with HMAC-SHA256-CTR.</p>

<p>We landed on a primary implementation Golang (Ben subsequently wrote an Elixir implementation). Our hash is SHA256, our cipher is Chapoly. We encode in MsgPack.</p>
<p>We didn’t use the pre-existing public implementation because <a href="https://securitycryptographywhatever.com/2021/08/12/what-do-we-do-about-jwt-with-jonathan-rudenberg/">we were warned not to</a>. The Macaroon idea is simple, and it exists mostly as an academic paper, not a standard. The community that formed around building open source “standard” Macaroons decided to use untyped opaque blobs to represent candidates. We need things to be as rigidly unambiguous as they can be.</p>
<p><img src="https://angelolloti.com/blog/macaroons-escalated-quickly/assets/verifier-service.png?2/3&amp;center"/></p>

<p>The big strength of Macaroons as a cryptographic design — that it’s based almost entirely on HMAC — makes it a challenge to deploy. If you can verify a Macaroon, you can generate one.  We have thousands of servers. They can’t all be allowed to generate tokens.</p>

<p>What we did instead:</p>

<ul>
<li>We split token checking into “verification” of token HMAC tags and “clearing” of token caveats.
</li><li>Verification occurs only on a physically isolated token-verification service; to verify a token’s tag, you  HTTP <code>POST</code> the token to the verifier.
</li><li>Clearing of token caveats can happen anywhere. Token caveat clearing is domain-specific and subject to change; token verification is simple cryptography and  changes rarely.
</li><li>A token verification is cacheable. The client library for the token verifier does that, which speeds things up by exploiting the locality of token submissions.
</li><li>The verification service is backed by a <a href="https://fly.io/docs/litefs/">LiteFS-distributed SQLite database</a>, so verification is fast globally — a major step forward from our legacy OAuth2 tokens, which are only fast in Ashburn, VA.
</li></ul>

<p><img src="https://angelolloti.com/blog/macaroons-escalated-quickly/assets/service-token.png?2/3&amp;center"/></p>

<p>Now buckle up, because I’m about to try to get you to care about service tokens.</p>

<p>We operate “worker servers” all over the world to host apps for our customers. To do that, those workers need access to customer secrets, like the key to decrypt a customer volume. To retrieve those secrets, the workers have to talk to secrets management servers.</p>

<p>We manage a lot of workers. We trust them. But we don’t trust them that much, if you get my drift. You don’t want to just leave it up to the servers to decide which secrets they can access. The blast radius of a problem with a single worker should be no greater than the apps that are supposed to run there.</p>

<p>The gold standard for approving access to customer information is, naturally, explicit customer authorization. We almost have that with Macaroons! The first time an app runs on a worker, <a href="https://fly.io/blog/carving-the-scheduler-out-of-our-orchestrator/">the orchestrator code</a> has a token, and it can pass that along to the secret stores.</p>

<p>The problem is, you need that token more than once; not just when the user does a deploy, but potentially any time you restart the app or migrate it to a new worker. And you can’t just store and replay user Macaroons. They have expirations.</p>

<p>So our token verification service exposes an API that transforms a user token into a “service token”, which is just the token with the authentication caveat and expiration “stripped off”.</p>

<p>What’s cool is: components that receive service tokens can attenuate them. For instance, we could lock a token to a particular worker, or even a particular Fly Machine. Then we can expose the whole <a href="https://fly.io/docs/machines/working-with-machines/">Fly Machines API</a> to customer VMs while keeping access traceable to specific customer tokens. Stealing the token from a Fly Machine doesn’t help you since it’s locked to that Fly Machine by a caveat attackers can’t strip.</p>
<h2 id="7"><a href="#7" aria-label="Anchor"></a>7</h2>
<p>If a customer loses their tokens to an attacker, we can’t just blow that off and let the attacker keep compromising the account!</p>
<p>This cancels every token derived through attenuation by that nonce.</p>
<p>Every Macaroon we issue is identified by a unique nonce, and we can revoke tokens by that nonce. This is just a basic function of the token verification service we just described.</p>

<p>We host token caches all over our fleet. Token revocation invalidates the caches. Anything with a cache checks frequently whether to invalidate. Revocation is rare, so just keeping a revocation list and invalidating caches wholesale seems fine.</p>
<h2 id="8"><a href="#8" aria-label="Anchor"></a>8</h2>
<p>I get it, it’s tough to get me to shut up about Macaroons.</p>

<p>A couple years ago, I <a href="https://fly.io/blog/api-tokens-a-tedious-survey/">wrote a long survey of API token designs</a>, from JWTs (never!) to Biscuits. I had a <a href="https://fly.io/blog/api-tokens-a-tedious-survey/#macaroons">bunch to say about Macaroons</a>, not all of it positive, and said we’d be plowing forward with them at Fly.io.</p>

<p>My plan had been to follow up soon after with a deep dive on Macaroons as we planned them for Fly.io. I’m glad I didn’t do that, not just because it would’ve been embarrassing to announce a feature that took us over 2 years to launch, but also because the process of working on this with Ben Toews changed a lot of my thinking about them.</p>

<p>I think if you asked Ben, he’d say he had mixed feelings about how much complexity we wrangled to get this launched. On the other hand: we got a lot of things out of them without trying very hard:</p>

<ul>
<li>Security tokens you can (almost) email to your users and partners without putting your account at risk.
</li><li>A flexible permission system, encoded directly into the tokens, that users can drive without talking to our servers.
</li><li>A plugin system that users can (when we clean up the tooling) use themselves, to add things like Passkeys or two-person-approval rules or audit logging, without us getting in the middle.
</li><li>An SSO system that can stack different IdPs, mandate SSO login, and do that on a per-<code>Organization</code> basis. 
</li><li><a href="https://www.latacora.com/blog/2018/06/12/a-childs-garden/">Inter-service authorization</a> that is traceable back to customer actions, so our servers can’t just make up which apps they’re allowed to look at.
</li><li>An elegant way of exposing our own APIs to customer Fly Machines with ambient authentication, but without the <a href="https://github.com/SummitRoute/imdsv2_wall_of_shame/blob/main/README.md">AWS IMDSv1 credential theft problem</a>.
</li></ul>

<p>There are downsides and warts! I’m mostly not telling you about them! Pure restrictive caveats are an awkward way to express some roles. And, blinded by my hunger to get Macaroons deployed, I spat in the face of science and used internal database IDs as our public caveat format, an act for which JP will never forgive me.</p>

<p>If i’ve piqued your interest, <a href="https://github.com/superfly/macaroon">the code for this stuff is public</a>, along with some more <a href="https://github.com/superfly/macaroon/blob/main/macaroon-thought.md">detailed technical documentation</a>.</p>

          
        </section>
        <dl>
            <dt>
              Previous post  ↓
            </dt>
            <dd>
              <a href="https://angelolloti.com/blog/how-i-fly-yoko-li/">
                How Yoko Li makes towns, tamagoes, and tools for local AI
              </a>
            </dd>
        </dl>
      </article></div>
  </body>
</html>
