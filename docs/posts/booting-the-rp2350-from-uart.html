<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pfister.dev/blog/2025/rp2350-uart-bl.html">Original</a>
    <h1>Booting the RP2350 from UART</h1>
    
    <div id="readability-page-1" class="page"><div id="datagrid">
            <h2>03.05.2025</h2><p>The RP2350 is a nice microcontroller from Raspberry Pi. Recently I thougt about a new project, where a lot of PWM channels would be needed. The RP2350B has 24 PWM channels, which is a lot - but not enough. I would need at least 33 PWM channels, and also some more GPIOs, so the RP2350 alone isn&#39;t enough. So I thought about a port expander... But what about using a second RP2350 as a port expander?</p><p>The chip is relatively cheap (about $0.90), needs few components around it, and... firmware? Well, that&#39;s not an ideal solution. Dealing with different firmwares on multiple controllers on the same board can be challenging. Also I really like the idea of having a simple port expander and not needing to deal with version checks and incompatibility breaks between different firmware versions.</p><p>So I read the <a href="https://datasheets.raspberrypi.com/rp2350/rp2350-datasheet.pdf" rel="nofollow" target="_blank">datasheet</a> of RP2350 (Chapter 5.8). And the RP2350 not only comes with an USB bootloader, which is most likely how most people program their chips, but also an UART bootloader (a new RP2350 feature over the RP2040!). UART is a lot easier to implement on a microcontroller than USB, and it&#39;s also the way to go for communication between the chips.</p><p><em>I made a <a href="https://youtu.be/eno0hiFSr18" rel="nofollow" target="_blank">YouTube-Video</a> about this topic, watch it if you&#39;re interested!</em></p><h2>The theory</h2><p>The process to load the firmware on the chip via UART is relatively simple: Just do some &#34;unlocking&#34; with a magic pattern, and then send the firmware image in 32-byte-chunks to the chip. After that&#39;s done, just run it.</p><p>By the way, <a href="https://github.com/raspberrypi/pico-bootrom-rp2350/blob/master/src/nsboot/nsboot_uart_client.S" rel="nofollow" target="_blank">here</a> is the bootloader code of the RP2350.</p><p>Of course there are downsides:</p><ul><li>The firmware needs to run from SRAM, consuming space in SRAM. But the RP2350 comes with 520 kiB, that should be enough for a port expander, right? (It is!)</li><li>It takes some time on every boot. My first tests show, that it takes something below a second to send the image via UART (depends on the size). Not a problem in my application, but could be one.</li></ul><p>A short Google search showed me, that not many people on the internet already tried that, so let&#39;s go!</p><p>The hardware change to enable the UART-bootloader is simple: On the interface to the flash, CSn needs to be driven low (which also enables USB bootloader), and in addition drive SD1 high.</p><p>When the chip is coming up strapped like this, it will enable a 1MBaud UART on pins SD2 (TX) &amp; SD3 (RX).</p><p>Unfortunately I don&#39;t have a Pico 2, but I have a custom board (which will be explained in detail in the future), where I could make those modifications very easily, since I used a very big flash package:</p><p><img src="https://todaythings.substack.com/p/P1001178.jpg" title="P1001178.jpg" alt="" width="100%"/>
(The two jumpers are for CSn and SD1, the header is for TX and RX)</p><p>Now we have the following goals:</p><ul><li>Get a RP2350 binary running from SRAM</li><li>Get the binary on the board via UART</li><li>Embed it in another microcontroller&#39;s firmware</li><li>Booting from there</li><li>Think about a reliable connection, even with longer cables</li></ul><h2>A binary running from SRAM</h2><p>That&#39;s actually not very hard. Just go to your makefile and add the line <code>set(PICO_NO_FLASH 1)</code> (Actually, according to the <a href="https://datasheets.raspberrypi.com/pico/raspberry-pi-pico-c-sdk.pdf" rel="nofollow" target="_blank">SDK documentation</a>, chapter 6.4, <code>set(PICO_DEFAULT_BINARY_TYPE no_flash)</code> should be equivalent. But that doesn&#39;t work <a href="https://github.com/raspberrypi/pico-sdk/issues/2279" rel="nofollow" target="_blank">for now</a>.)</p><p>And that&#39;s it. As soon as you compiled it, you will have a bin-file in the subfolder &#34;build&#34;:</p><p><img title="" src="https://todaythings.substack.com/p/Bildschirmfoto%20vom%202025-02-16%2019-06-44.png" alt="Bildschirmfoto vom 2025-02-16 19-06-44.png" width="30%"/></p><p>That is the file to send via UART. To test it, you could use the also generated uf2-file and copy it via USB to the RP2350. But be aware that it will run from RAM and it will be gone after a power-cycle.</p><h2>Firmware-over-UART</h2><p>To start, I just wrote a quick Python-script. It sends the firmware, and I also implemented checking it. With a 7.3 KiB firmware, the sending took ~160ms, the verification ~150ms.</p><p>That&#39;s not especially bad, but let&#39;s quickly do the math.</p><h3>Baud-to-byte</h3><p>The UART mode here is <code>8n1</code>: One start bit, eight data bits, no parity and one stop bit. That makes 10 bit per symbol, but only eight of them are user data. So our speed is 1000000 Baud/s / 10 (Bits per symbol) * 8 (User data bits per symbol) / 8 (Bits per Byte) = <strong>100 kB/s</strong> (or 0.1 MB/s)</p><p>My test binary is exactly 7256 Bytes long, but we need to make 32-byte chunks, so the last chunk will be filled with zeros and we get a total length of 7264 Bytes. The write command before every chunk makes one more byte overhead, so we have 227 bytes overhead. Those 7491 Bytes should now we downloaded in 74.91ms.</p><p>I won&#39;t elaborate why my Python script took double of that (maybe I did a horrible mistake?). Obviously due to <em>anything</em>, not the complete possible time is used to transfer the data. I think it might be due to the Linux and USB-stuff that is in between, but I think it&#39;s not very relevant, so lets jump to the interesting part!</p><h2>Binaries in binaries</h2><p>To be able to boot our RP2350 from another microcontroller, we want the firmware for the first embedded in the firmware of the latter.</p><p>We could use one of the various online tools that creates a C header with a large array containing the binary&#39;s data.</p><p>But I wanted a more automated way, and it looks like at least with C++23, this feature was implemented as <a href="https://en.cppreference.com/w/c/preprocessor/embed" rel="nofollow" target="_blank">#embed preprocessor directive</a>.</p><p>However, I couldn&#39;t get it running with the version 2.1.0 of the pico SDK. Maybe I&#39;m just dumb, but setting <code>set(CMAKE_CXX_STANDARD 23)</code> did still result in an error. Maybe it&#39;s GCC, that <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=105863" rel="nofollow" target="_blank">as far as I can see</a>, did not yet implement C++23 #embed?</p><p>But I found a nice semi-automatic way at <a href="https://stackoverflow.com/a/56006001" rel="nofollow" target="_blank">Stackoverflow</a>. It just needed some tweaking, but it works (see my code <a href="https://codeberg.org/retsifp/rp2350_uart/src/branch/master/main_controller/CMakeLists.txt#L61" rel="nofollow" target="_blank">here</a>).</p><h2>Kickstarting the RP2350 from another microcontroller</h2><p>Now we&#39;re all set: We have a Python proof-of-concept, we have the firmware binary embedded in the binary of another microcontroller. I just ported the Python code more-or-less to C, and some infinite loops later... It works! See my code <a href="https://codeberg.org/retsifp/rp2350_uart/src/branch/master/main_controller/main_controller.cpp" rel="nofollow" target="_blank">here</a>.</p><p>Let&#39;s finally check the speed. The script gives the following output:</p><pre><code>Hello, world!
Device is there!
Start addr is 0x20001055
Finished sending FW, 7264 bytes were written!
The end. This took 74750 us</code></pre><p>That&#39;s 0.2 ms faster then the expected maximum speed. I have to think about how that&#39;s possible, but I won&#39;t complain ;-)</p><h2>Missing features</h2><p>I noticed, that the pins the bootloader uses, since they reside in another GPIO bank, can with the current SDK not be used as UART in your program. But as the internet is a great place, soon after I submitted that issue on <a href="https://github.com/raspberrypi/pico-sdk/issues/2280" rel="nofollow" target="_blank">GitHub</a>, someone already sent me a <a href="https://github.com/raspberrypi/pico-examples/pull/571" rel="nofollow" target="_blank">link</a> to a solution. I tested it, and it works perfectly. I guess it will eventually land in the SDK, so keep an eye on that issue!</p><h2>A reliable connection</h2><p>UART isn&#39;t known for being robust over long cables. I think we&#39;ll have a problem with signal integrity the longer the cables get, a lot more than one meter will be a problem.</p><p>The solution to that problem is very simple: We can convert the single-ended UART signal to a differential signal. I used TI&#39;s THVD1450 to translate the UART to RS-485. I made a simple PCB with two transceivers and a RJ-45 connector. RS-485 usually uses 120-Ohm cables, but I just used 100-Ohm ethernet cables, since they&#39;re just very easy to get and cheap.</p><p><img title="" src="https://todaythings.substack.com/p/P1001175.jpg" alt="P1001175.jpg" width="30%"/></p><p>With that board on both ends, I could boot the remote RP2350 over a ~10m cable, which was the longest I have at home. I guess it should work up to 100m, but 10m is more than enough for me.</p><p><img title="" src="https://todaythings.substack.com/p/P1001181.jpg" alt="P1001181.jpg" width="100%"/></p><p>Since the board works transparent, as if there would be a direct connection between the boards, it worked out of the box and very reliable. So for my use-case, I will go with that solution. Stay tuned!</p><p><em>If you have questions or comments, just contact me via mail, or write a comment at the <a href="https://youtu.be/eno0hiFSr18" rel="nofollow" target="_blank">YouTube-Video</a>.</em></p>
            
        </div></div>
  </body>
</html>
