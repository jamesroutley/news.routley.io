<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/rochus-keller/CspChan">Original</a>
    <h1>Show HN: A pure C89 implementation of Go channels, with blocking selects</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text"><p dir="auto">This C library implements channels, as introduced by Hoare (Communicating Sequential Processes, 1985) and popularized by the Go programming language.</p>
<p dir="auto">Buffered and unbuffered channels are supported (unbuffered are WIP), and also the select statement in its blocking and non-blocking variants, as in the Go programming language.</p>
<p dir="auto">The library currently works with Ptreads; support for Win32 threads is work in progress.</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-how-to-use" aria-hidden="true" tabindex="-1" href="#how-to-use"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>How to use</h3>
<p dir="auto">Just include the CspChan.h and CspChan.c files in your project, or build a shared library with the CspChan.c file.</p>
<p dir="auto">More information can be found in the source code.</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-example" aria-hidden="true" tabindex="-1" href="#example"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Example</h3>
<div dir="auto" data-snippet-clipboard-copy-content="#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &#34;CspChan.h&#34;

static void* senderA(void* arg) {
    CspChan_t* out = (CspChan_t*)arg;
    int i = 0;
    while(!CspChan_closed(out)) {
        CspChan_send(out,&amp;i);
        i++;
        CspChan_sleep(1000);
    }
    return 0;
}

static void* senderB(void* arg) {
    CspChan_t* out = (CspChan_t*)arg;
    int i = -1;
    while(!CspChan_closed(out)) {
        CspChan_sleep(1000);
        CspChan_send(out,&amp;i);
        i--;
        CspChan_sleep(1000);
    }
    return 0;
}

typedef struct receiverAB_arg {
    CspChan_t* a;
    CspChan_t* b;
} receiverAB_arg;

static void* receiverAB(void* arg) {
    receiverAB_arg* ra = (receiverAB_arg*)arg;
    while( !CspChan_closed(ra-&gt;a) &amp;&amp; !CspChan_closed(ra-&gt;b) ) {
        int a,b;
        CspChan_t* receivers[2] = { ra-&gt;a, ra-&gt;b };
        void* rData[2] = { &amp;a, &amp;b };
        switch( CspChan_select(receivers,rData,2, 0, 0, 0) ) {
        case 0:
            printf(&#34;a: %d\n&#34;,a);
            fflush(stdout);
            break;
        case 1:
            printf(&#34;b: %d\n&#34;,b);
            fflush(stdout);
            break;
        }
    }
    free(arg);
    return 0;
}

int main()
{
    CspChan_t* a = CspChan_create(0,4); /* unbuffered channel */
    CspChan_t* b = CspChan_create(1,4); /* buffered channel */
    CspChan_fork(senderA,a);
    CspChan_fork(senderB,b);
    receiverAB_arg* arg = (receiverAB_arg*)malloc(sizeof(receiverAB_arg));
    arg-&gt;a = a;
    arg-&gt;b = b;
    CspChan_fork(receiverAB,arg);

    CspChan_sleep(9000);
    CspChan_close(a);
    CspChan_close(b);

    CspChan_dispose(a);
    CspChan_dispose(b);
}"><pre><span>#include</span> <span>&lt;stdlib.h&gt;</span>
<span>#include</span> <span>&lt;stdio.h&gt;</span>
<span>#include</span> <span>&#34;CspChan.h&#34;</span>

<span>static</span> <span>void</span><span>*</span> <span>senderA</span>(<span>void</span><span>*</span> <span>arg</span>) {
    <span>CspChan_t</span><span>*</span> <span>out</span> <span>=</span> (<span>CspChan_t</span><span>*</span>)<span>arg</span>;
    <span>int</span> <span>i</span> <span>=</span> <span>0</span>;
    <span>while</span>(!<span>CspChan_closed</span>(<span>out</span>)) {
        <span>CspChan_send</span>(<span>out</span>,<span>&amp;</span><span>i</span>);
        <span>i</span><span>++</span>;
        <span>CspChan_sleep</span>(<span>1000</span>);
    }
    <span>return</span> <span>0</span>;
}

<span>static</span> <span>void</span><span>*</span> <span>senderB</span>(<span>void</span><span>*</span> <span>arg</span>) {
    <span>CspChan_t</span><span>*</span> <span>out</span> <span>=</span> (<span>CspChan_t</span><span>*</span>)<span>arg</span>;
    <span>int</span> <span>i</span> <span>=</span> <span>-1</span>;
    <span>while</span>(!<span>CspChan_closed</span>(<span>out</span>)) {
        <span>CspChan_sleep</span>(<span>1000</span>);
        <span>CspChan_send</span>(<span>out</span>,<span>&amp;</span><span>i</span>);
        <span>i</span><span>--</span>;
        <span>CspChan_sleep</span>(<span>1000</span>);
    }
    <span>return</span> <span>0</span>;
}

<span>typedef</span> <span>struct</span> <span>receiverAB_arg</span> {
    <span>CspChan_t</span><span>*</span> <span>a</span>;
    <span>CspChan_t</span><span>*</span> <span>b</span>;
} <span>receiverAB_arg</span>;

<span>static</span> <span>void</span><span>*</span> <span>receiverAB</span>(<span>void</span><span>*</span> <span>arg</span>) {
    <span>receiverAB_arg</span><span>*</span> <span>ra</span> <span>=</span> (<span>receiverAB_arg</span><span>*</span>)<span>arg</span>;
    <span>while</span>( !<span>CspChan_closed</span>(<span>ra</span><span>-&gt;</span><span>a</span>) <span>&amp;&amp;</span> !<span>CspChan_closed</span>(<span>ra</span><span>-&gt;</span><span>b</span>) ) {
        <span>int</span> <span>a</span>,<span>b</span>;
        <span>CspChan_t</span><span>*</span> <span>receivers</span>[<span>2</span>] <span>=</span> { <span>ra</span><span>-&gt;</span><span>a</span>, <span>ra</span><span>-&gt;</span><span>b</span> };
        <span>void</span><span>*</span> <span>rData</span>[<span>2</span>] <span>=</span> { <span>&amp;</span><span>a</span>, <span>&amp;</span><span>b</span> };
        <span>switch</span>( <span>CspChan_select</span>(<span>receivers</span>,<span>rData</span>,<span>2</span>, <span>0</span>, <span>0</span>, <span>0</span>) ) {
        <span>case</span> <span>0</span>:
            <span>printf</span>(<span>&#34;a: %d\n&#34;</span>,<span>a</span>);
            <span>fflush</span>(<span>stdout</span>);
            <span>break</span>;
        <span>case</span> <span>1</span>:
            <span>printf</span>(<span>&#34;b: %d\n&#34;</span>,<span>b</span>);
            <span>fflush</span>(<span>stdout</span>);
            <span>break</span>;
        }
    }
    <span>free</span>(<span>arg</span>);
    <span>return</span> <span>0</span>;
}

<span>int</span> <span>main</span>()
{
    <span>CspChan_t</span><span>*</span> <span>a</span> <span>=</span> <span>CspChan_create</span>(<span>0</span>,<span>4</span>); <span>/* unbuffered channel */</span>
    <span>CspChan_t</span><span>*</span> <span>b</span> <span>=</span> <span>CspChan_create</span>(<span>1</span>,<span>4</span>); <span>/* buffered channel */</span>
    <span>CspChan_fork</span>(<span>senderA</span>,<span>a</span>);
    <span>CspChan_fork</span>(<span>senderB</span>,<span>b</span>);
    <span>receiverAB_arg</span><span>*</span> <span>arg</span> <span>=</span> (<span>receiverAB_arg</span><span>*</span>)<span>malloc</span>(<span>sizeof</span>(<span>receiverAB_arg</span>));
    <span>arg</span><span>-&gt;</span><span>a</span> <span>=</span> <span>a</span>;
    <span>arg</span><span>-&gt;</span><span>b</span> <span>=</span> <span>b</span>;
    <span>CspChan_fork</span>(<span>receiverAB</span>,<span>arg</span>);

    <span>CspChan_sleep</span>(<span>9000</span>);
    <span>CspChan_close</span>(<span>a</span>);
    <span>CspChan_close</span>(<span>b</span>);

    <span>CspChan_dispose</span>(<span>a</span>);
    <span>CspChan_dispose</span>(<span>b</span>);
}</pre></div>
<p dir="auto">In addition, test.c includes some of the examples from Birch Hansen, Per (1987): Joyce - A Programming Language for Distributed Systems.</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-planned-or-work-in-progress-features" aria-hidden="true" tabindex="-1" href="#planned-or-work-in-progress-features"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Planned or work-in-progress features</h3>
<ul>
<li> Unix version with buffered channels and blocking and non-blocking select</li>
<li> Unix version with unbuffered channels</li>
<li> Windows version</li>
<li> Implement a thread-pool to re-use threads instead of starting a new one with each call to CspChan_fork to improve performance</li>
</ul>
<h3 tabindex="-1" dir="auto"><a id="user-content-related-work" aria-hidden="true" tabindex="-1" href="#related-work"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Related work</h3>
<p dir="auto">There are a couple of C++ implementations of CSP channels, e.g. <a href="https://www.cs.kent.ac.uk/projects/ofa/c++csp/" rel="nofollow">https://www.cs.kent.ac.uk/projects/ofa/c++csp/</a> or <a href="https://github.com/atollk/copper">https://github.com/atollk/copper</a>, but the intention of the present library is a C89 implementation of Go channels.</p>
<p dir="auto">For C there are also some libraries, partially with similar goals as the present one.</p>
<p dir="auto">Pipe (<a href="https://github.com/cgaebel/pipe">https://github.com/cgaebel/pipe</a>) is a C99 implementation of a thread-safe FIFO. The library is very well documented, but also more complex than the present one, and with more dynamic allocations (CspChan uses a simple fixed size ring buffer instead, like Go). The Pipe library has no select implementation, and adding one seems pretty complicated and requires changes to the library.</p>
<p dir="auto">The Chan library (<a href="https://github.com/tylertreat/chan">https://github.com/tylertreat/chan</a>) is a C implementation of Go channels and shares the same goals as the present library. There is even an implementation of Go select. The implementation is rather complex (with separate implementations for buffered and unbuffered channels) and also with more dynamic allocations than I would hope for; apparently only non-blocking selects are supported (i.e. only Go selects with default); adding blocking selects would require significant changes to the library.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-support" aria-hidden="true" tabindex="-1" href="#support"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Support</h2>
<p dir="auto">If you need support or would like to post issues or feature requests please use the Github issue list at <a href="https://github.com/rochus-keller/CspChan/issues">https://github.com/rochus-keller/CspChan/issues</a> or send an email to the author.</p>
</article>
          </div></div>
  </body>
</html>
