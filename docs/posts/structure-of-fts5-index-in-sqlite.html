<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://darksi.de/13.sqlite-fts5-structure/">Original</a>
    <h1>Structure of FTS5 Index in SQLite</h1>
    
    <div id="readability-page-1" class="page"><div id="skip">
			


<ul>
	<li><time datetime="2023-02-26">26 February 2023</time></li>
	<li><a href="https://darksi.de/tags/sqlite/">SQLite</a></li>
</ul>

<p>Recently <a href="https://signal.org/">Signal</a> has
<a href="https://github.com/signalapp/Signal-FTS5-Extension">open-sourced a SQLite extension</a>
that provides better support for non-latin languages (Chinese, Japanese, etc) in
the Full-Text Search (FTS) virtual table. I was one of the engineers
who worked on this extension and in the course of this endeavor I got to learn
about the structure of the SQLite&#39;s FTS implementation.
<a href="https://www.sqlite.org/fts5.html">The existing documentation</a> focuses mostly
on API and its use patterns, and even though it covers some of the internal
storage format, I found it a bit confusing. Thus this article was born. Not as
alternative documentation for FTS5, but as a complement for developers who want
to dive in past the officially documented bits.</p>
<h2 id="how-is-fts5-used" tabindex="-1">How is FTS5 used <a href="#how-is-fts5-used">#</a></h2>
<p>Before anything else, though, let&#39;s see what the FTS5 looks like to the API
consumer. As with many other features of SQLite we start by creating a table:</p>
<pre tabindex="0"><code><span>CREATE</span> VIRTUAL <span>TABLE</span> search</code></pre>
<p>This virtual table supports insertion, modification, and deletion of textual
content:</p>
<pre tabindex="0"><code><span>INSERT</span> <span>INTO</span> search<span>(</span>content<span>)</span> <span>VALUES</span></code></pre>
<p>As well as special full-text search queries that can find an entry that has a
word (term) starting with a certain prefix:</p>
<pre tabindex="0"><code><span>SELECT</span> content <span>FROM</span> search</code></pre>
<p>In addition to that you could match on multiple words (not necessarily adjacent)
and sort by the search rank. The details of this are
<a href="https://www.sqlite.org/fts5.html#fts5_phrases">covered by the official documentation</a>
so we won&#39;t be discussing them much more here.</p>
<h2 id="signal-s-fts5-extension" tabindex="-1">Signal&#39;s FTS5 extension <a href="#signal-s-fts5-extension">#</a></h2>
<p>In the example above you might have noticed that we inserted a phrase in
Simplified Chinese: <code>你好世界</code>. What happens if we search for the second word of
it (<code>世界</code>)?</p>
<pre tabindex="0"><code><span>SELECT</span> content <span>FROM</span> search</code></pre>
<p>No resulting rows! The reason for that is that the default tokenizer for FTS5
has segmented <code>你好世界</code> as a single word (term), instead of either splitting
it into two words (example in JavaScript):</p>
<pre tabindex="0"><code><span>const</span> segmenter <span>=</span> <span>new</span> <span>Intl<span>.</span>Segmenter</span><span>(</span><span>[</span><span>]</span><span>,</span> <span>{</span></code></pre>
<p>or at the very least into separate CJK symbols:</p>
<pre tabindex="0"><code><span>[</span> <span>&#39;你&#39;</span><span>,</span> <span>&#39;好&#39;</span><span>,</span> <span>&#39;世&#39;</span><span>,</span> <span>&#39;界&#39;</span> <span>]</span></code></pre>
<p>Since FTS5 only supports indexed searches by the start of the term - it cannot
search for Chinese/Japanese words in the middle of the sentence.</p>
<p>This is where <a href="https://github.com/signalapp/Signal-FTS5-Extension">Signal&#39;s FTS5 Extension</a> comes to the rescue.
It is a <a href="https://www.rust-lang.org/">Rust</a> crate that could be built as either static or shared
library. When plugged into SQLite this library provides an alternative
tokenizer conspicuously named <code>signal_tokenizer</code>. Creating a table with this
tokenizer is fairly straightforward and one could easily verify that the CJK
search works without issues now:</p>
<pre tabindex="0"><code></code></pre>
<p><em>Note that default <code>sqlite3</code> shell
doesn&#39;t support extensions so you&#39;d have to build your own or use Signal&#39;s
<a href="https://github.com/signalapp/better-sqlite3">fork of better-sqlite3</a> which
automatically loads <code>signal_tokenizer</code>.</em></p>
<h2 id="fts5-internal-structure" tabindex="-1">FTS5 Internal Structure <a href="#fts5-internal-structure">#</a></h2>
<p>With this context in mind, we are ready to take a look at the internal
structure of FTS5! Let&#39;s define the common terminology:</p>
<ul>
<li><strong>document</strong> - a <code>rowid</code> primary key along with one or more indexed text
columns (for simplicity we will assume one)</li>
<li><strong>term</strong> - a &#34;word&#34; in an indexed column. Tokenizer is responsible for
segmenting the text with multiple sentences into <code>term</code>s</li>
<li><strong>segment</strong> - a collection of pages/leaves</li>
<li><strong>page</strong> (<strong>leaf</strong>) - a sorted list of tokens and their positions in the
documents.</li>
</ul>
<h3 id="naive-idea" tabindex="-1">Naive Idea <a href="#naive-idea">#</a></h3>
<p>Naively, given a document we could imagine compiling a list of terms and their
positions sorted lexicographically by the term:</p>
<pre tabindex="0"><code>&#34;hello&#34;  -&gt; rowid1 + position of &#34;hello&#34; in the document</code></pre>
<p>A binary search could be then performed over the document to find the first
term (and the following terms) with a given prefix.
<a href="https://en.wikipedia.org/wiki/Big_O_notation">The cost</a> of lookups would be:
<code>O(log N)</code>, but the insertions are going to be painful (<code>O(N)</code>) since most
new entries would have to be put into the middle of the list and thus we&#39;d have
to move all older entries forward to make space for them.</p>
<h3 id="b-tree" tabindex="-1">B-Tree <a href="#b-tree">#</a></h3>
<p><a href="https://en.wikipedia.org/wiki/B-tree">B-Trees</a> were invented to compensate for
that. There is a lot to be said about them, but the only relevant part for our
discussion is that B-Trees work by splitting the data into pages, each
page individually sorted, and then organizing the pages into a binary tree-like
structure. Inserting new data then mostly touches a single page and some nodes
in the tree along the way to that page. This amortizes the insertion performance
to <code>O(log N)</code> (from <code>O(N)</code> of the &#34;big sorted list&#34; described above).</p>
<p>Because of these performance characteristics, B-Trees are ubiquitous in the
&#34;database world&#34;. Some version of them (e.g., <a href="https://en.wikipedia.org/wiki/B%2B_tree">B+ Tree</a>) is used in
practically every popular database.</p>
<h3 id="outline-of-fts5-approach" tabindex="-1">Outline of FTS5 Approach <a href="#outline-of-fts5-approach">#</a></h3>
<p>While the above approach would work for full-text search, it doesn&#39;t take in
account the specifics of it. Namely, users usually insert large documents that
consist of many terms, and commonly perform lookup by just a few terms.</p>
<p>I believe this was the motivation for the approach that SQLite took with FTS5.
Instead of plain <a href="https://en.wikipedia.org/wiki/B-tree">B-Trees</a> FTS5 uses a structure that has even better
amortization for insertions at a price of a slight overhead during the lookup.</p>
<p>Roughly the data is split into three tables:</p>
<ul>
<li><code>%_data</code> - holds the header of the structure with levels description, and
the contents of segments (sorted lists) of doclists (term + document rowid +
positions of the term in the document). This table is indexed by <a href="https://www.sqlite.org/rowidtable.html">rowid</a>
(i.e. an integer primary key)</li>
<li><code>%_idx</code> - holds the triples (segment id, term, page number) to index within
each segment. This table is indexed by <code>segment id</code> and <code>term</code>, so that we
could find the page number in a segment efficiently</li>
<li><code>%_content</code> - holds the full contents of the stored documents (note that this
table is omitted when FTS5 is configured to use
<a href="https://www.sqlite.org/fts5.html#external_content_and_contentless_tables">external content</a>).</li>
</ul>
<p><em>(Note: <code>&#34;%&#34;</code> is the virtual table name, e.g. <code>search</code> in our examples)</em></p>
<p>With the overview above, let&#39;s build the structure bottom up. When a new
document is inserted into the table:</p>
<ol>
<li>It is tokenized into multiple terms and their positions within the document</li>
<li>A new segment is created for all these terms, and it is essentially what we
called &#34;big sorted list&#34; above. A segment could be one page if it is small
(less than 1000 bytes, see <a href="https://www.sqlite.org/fts5.html#the_pgsz_configuration_option"><code>pgsz</code> config option</a>), or it could be
split into multiple sorted pages (leaves)</li>
<li>If the segment is split into multiple pages - we take a prefix of the first
term from each sorted page and put them into <code>%_idx</code> table. Thus we
indirectly create a <a href="https://en.wikipedia.org/wiki/B-tree">B-Tree</a>! <code>%_idx</code> becomes a tree part of B-Tree
(because it is indexed by a B+-Tree under the hood), and this tree points to
pages in the <code>%_data</code> table. Each page small enough that we could search it
for terms and their documents</li>
<li>Finally, if FTS5 isn&#39;t running in the &#34;external content&#34; mode - we insert the
original (non-tokenized) contents of the document into the <code>%_content</code> table.</li>
</ol>
<p>With this structure it is easy to see how FTS5 performs a search over a single
segment, but what if we insert multiple documents into the index over time?</p>
<h3 id="merging-segments" tabindex="-1">Merging segments <a href="#merging-segments">#</a></h3>
<p>Each time we insert a new document - we create a new segment with its terms
(just as described above). If the number of segments is small, when looking up a
term in the index we&#39;d just iterate through all of them starting with the newest
segments! This is the insertion amortization technique in the nutshell. We just
create a brand new B-Tree (through a combination of rows in <code>%_idx</code> and
<code>%_data</code>) and get a forest of them.</p>
<p>When the number of segments becomes too large, however, B-Tree forest can
quickly become impractical. Thus every now and then (every 64 insertions in
SQLite) SQLite has to perform &#34;merges&#34; of some of these segments and create
larger (but more efficient) B-Trees. There are various ways to configure how
these merges work, and how much data is merged. I previously
<a href="https://gist.github.com/indutny/ae44fd93dde2736205609d19a21b87cc">covered the mechanics of the merges</a>
so we won&#39;t concentrate on them here.</p>
<p>Every time a merge is performed - we have to combine together two segments and
move all their data into a new one. This sounds like it could be... slow, right?
In fact it very well would be if not for a trick that FTS5 employs! Instead of
just merging everything together any time we get too many segments - we assign
each segment a level. They all start with level 0 and the merges only affect
segments on the <strong>same level</strong>. When they are finally merged - the resulting
segment is one level above the source segments. Since we merge every 64
insertions, with each new level segments become ~64 times larger.
This way we reduce the merge frequency for older and larger segments on
a higher level, and perform most merges on the lower levels when they become
overcrowded.</p>
<h3 id="inspecting-the-structure" tabindex="-1">Inspecting the Structure <a href="#inspecting-the-structure">#</a></h3>
<p>Let&#39;s see how this works in practice. There is a &#34;secret&#34; test-only function in
FTS5 named <code>fts5_decode</code> that is unfortunately only available when <code>SQLITE_TEST</code>
was defined at the build time. <code>sqlite3</code> shell isn&#39;t supposed to be built with
this define, but with a <a href="https://gist.github.com/indutny/01cccb511059a0e2d657036e2fc9cb67">small patch</a> we could get it running:</p>
<pre tabindex="0"><code><span>CREATE</span> VIRTUAL <span>TABLE</span> search</code></pre>
<p>If we ignore the <code>{averages}</code> (it is used for ranking), we see that in the
<code>{structure}</code> we have one level (<code>lvl=0</code>) with one segment
(<code>nSeg=1 {id=1 leaves=1..1}</code>) that consists of a single page (<code>1..1</code>).</p>
<p>Row <code>137438953473</code> (0x2000000001, see
<a href="https://www.sqlite.org/fts5.html#data_structure">the official documentation on the value</a>)
has the actual segment page which contains a sorted list of terms and
their positions within the document (as promised!). They all start with &#34;0&#34;,
because FTS5 supports optional
<a href="https://www.sqlite.org/fts5.html#prefix_indexes">prefix indexes</a> which require
this encoding.</p>
<p>We can insert more data into the index:</p>
<pre tabindex="0"><code><span>INSERT</span> <span>INTO</span> search<span>(</span>content<span>)</span> <span>VALUES</span></code></pre>
<p>It is easy to see that the segment 1 wasn&#39;t changed, and we added one more
level zero segment (<code>{id=2 leaves=1..2}</code>) with two pages (<code>1..2</code>,
<code>0x4000000001</code> and <code>0x4000000002</code>) because the terms didn&#39;t all fit into a
single page. Each page is again a sorted list, and they are now inserted into
the <code>%_idx</code> table:</p>
<pre tabindex="0"><code><span>SELECT</span> <span>*</span> <span>FROM</span> search_idx<span>;</span></code></pre>
<p>One can see that for the newly inserted segment 2 we have two entries (one per
each page), and that they correctly start with <code>&#34;0y&#34;</code> term prefix which lets us
quickly find the page if we are searching by <code>&#34;y*&#34;</code>.</p>
<p>To finish this, let&#39;s simulate merging of the segments. We could insert 62 more
entries to trigger it, but a similar result could be achieved by running
<a href="https://www.sqlite.org/fts5.html#the_optimize_command"><code>optimize</code></a>:</p>
<pre tabindex="0"><code><span>INSERT</span> <span>INTO</span> search<span>(</span>search<span>)</span> <span>VALUES</span></code></pre>
<p>As promised, the segments 1 and 2 got merged into a segment 3 on the newly
created level 1. The result has three pages, where the last one has the left
over term position that didn&#39;t fit into page 2.</p>
<p>If we insert more data into the table - it will be put again on the level 0 so
the next automatic merge would only work with the segments of that level.</p>
<h2 id="closing-note" tabindex="-1">Closing Note <a href="#closing-note">#</a></h2>
<p>I don&#39;t know about you, but for me this was quite a wild ride! B-Trees,
tokenizers, merges... There&#39;s certainly a lot going on under the hood of
<a href="https://www.sqlite.org/mostdeployed.html">one of the most popular databases</a> in
the world. As it often is in engineering, by reusing and combining simple blocks
we can create a very complex structure that might be hard to understand when
approaching head on. In this article I attempted to deconstruct FTS5 down to its
roots (or at least a few levels lower), but there is still much more that could
be said (like compact encoding of terms and positions in the pages).</p>
<p>If you have any requests or ideas - feel free to &#34;toot&#34; at me on
<a href="https://fosstodon.org/@indutny">Mastodon</a>. Thanks for spending your time
reading this!</p>

<ul><li>Previous: <a href="https://darksi.de/12.hashwick-v8-vulnerability/">HashWick V8 Vulnerability</a></li>
</ul>

		</div></div>
  </body>
</html>
