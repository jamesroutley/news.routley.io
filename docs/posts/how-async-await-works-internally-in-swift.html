<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://swiftrocks.com/how-async-await-works-internally-in-swift">Original</a>
    <h1>How async/await works internally in Swift</h1>
    
    <div id="readability-page-1" class="page"><div>
    
  
<p>async/await in Swift was introduced with iOS 15, and I would guess that at this point you probably already know how to use it. But have you ever wondered <b>how</b> async/await works internally? Or maybe <b>why</b> it looks and behaves the way it does, or even <b>why was it even introduced in the first place?</b></p>

<p>In typical SwiftRocks fashion, we&#39;re going deep into the Swift compiler to answer these and other questions about <b>how async/await works internally in Swift</b>. This is not a tutorial on how to use async/await; we&#39;re going to take a deep dive into the feature&#39;s history and implementation so that we can understand how it works, <b>why it works</b>, what you can achieve with it, and most importantly, <b>what are the gotchas that you must be aware of when working with it.</b></p>



<blockquote>Disclaimer: As always, this is a result of my own research and reverse-engineering. As I never worked at Apple and have nothing to do with the development of async/await, some pieces of information might not be 100% accurate, especially when it comes to the history of Swift.</blockquote>



<h2>Swift, and the goal of memory safety</h2>



<p>Swift&#39;s async/await brought to the language a brand new way of working with asynchronous code. But before trying to understand how it works, we must take a step back to understand why Swift introduced it in the first place.</p>



<p>The concept of <b>undefined behavior</b> in programming languages is something that surely haunts anyone who ever needed to work with the so-called “precursor programming languages” like C++ or Obj-C.</p>



<p>Programming languages historically provided you with 100% freedom. There were no real guardrails in place to prevent you from making horrible mistakes; you could do anything you wanted, and the compilers would always assume that you knew what you were doing.</p>



<p>On one hand, this behavior on behalf of the languages made them extremely powerful, but on the other hand, it essentially made any piece of software written with them a minefield. Consider the following C code where we attempt to read an array&#39;s index that doesn&#39;t exist:</p>



<pre><code>// arr only has two elements</code>
<code>void readArray(int arr[]) {</code>
<code>    int i = arr[20];</code>
<code>    printf(&#34;%i&#34;, i);</code>
<code>}</code>
</pre>



<p>We know that in Swift this will trigger an exception, but we’re not talking about Swift yet, we’re talking about a precursor language that had complete trust in the developer. What will happen here? Will this crash? Will it work?</p>



<p>The short answer is that we don&#39;t know. Sometimes you&#39;ll get 0, sometimes you&#39;ll get a random number, and sometimes you&#39;ll get a crash. It completely depends on the contents of that specific memory address will be at that specific point in time, so in other words, the behavior of that assignment is <b>undefined.</b></p>



<p>But again, this was intentional. The language assumed that you knew what you were doing and allowed you to proceed with it, even though that turned out to almost always be a huge mistake.</p>



<p>Apple was one of the companies at the time that recognised the need for a safer, modern alternative to these languages. While no amount of compiler features can prevent you from introducing logic errors, they believed programming languages should be able to prevent undefined behavior, and this vision eventually led to the birth of Swift: a language that prioritized memory safety.</p>



<p>One of the main focuses of Swift is making undefined behavior impossible, and today this is achieved via a combination of compiler features (like explicit initialization, type-safety, and optional types) and runtime features (like throwing an exception when an array is accessed at an index that doesn’t exist. It’s still a crash, but it’s not undefined behavior anymore because now we know what’s supposed to happen!).</p>



<p>You could argue that this should come with the cost of making Swift an inferior language in terms of power and potential, but one interesting aspect of Swift is that it still allows you to tap into that raw power that came with the precursor languages when necessary. These are usually referred to within the language as “unsafe” operations, and you know when you’re dealing with one because they are literally prefixed with the “unsafe” keyword.</p>



<pre><code>let ptr: UnsafeMutablePointer&lt;Int&gt; = ...</code>
</pre>



<h2>The problem of concurrency in Swift</h2>



<p>But despite being designed for memory safety, Swift was never truly 100% memory safe because <b>concurrency</b> was still a large source of undefined behavior in the language.</p>






<p>The primary reason why this was the case is because Grand Central Dispatch (GCD), Apple’s main concurrency solution for iOS apps, was not a feature of the Swift compiler itself, but rather a C library (libdispatch) that was shipped into iOS as part of Foundation. Just as expected of a C library, GCD gave you a lot of freedom in regard to concurrency work, making it challenging for Swift to prevent common concurrency issues like <b>data races, race conditions, deadlocks, priority inversions, and thread explosion.</b></p>



<p>(If you’re not familiar with one or more of the terms above, here’s a quick glossary:)</p>



<ul>
<li>Data Race: Two threads accessing shared data at the same time, leading to unpredictable results</li>



<li>Race Condition: Failing at synchronize the execution of two or more threads, leading to events happening in the wrong order </li>



<li>Deadlock: Two threads waiting on each other, meaning neither is able to proceed</li>



<li>Priority inversion: Low-priority task holding a resource needed by a high-priority task, causing delays in execution</li>



<li>Thread explosion: Excessive number of threads in the program, leading to resource exhaustion and decreased system performance</li>
</ul>



<pre><code>let semaphore = DispatchSemaphore(value: 0)</code>
<code>highPrioQueue.async {</code>
<code>    semaphore.wait()</code>
<code>    // …</code>
<code>}</code>
<code></code>
<code>lowPrioQueue.async {</code>
<code>    semaphore.signal()</code>
<code>    // …</code>
<code>}</code>
</pre>



<p>The above is a classic example of a priority inversion in iOS. Although you as a developer know that the above semaphore will cause one queue to wait on another, GCD would not necessarily agree and fail to properly escalate the lower priority queue’s priority. To be clear, GCD <em>can</em> adjust itself in certain situations, but patterns like the above example were not covered by it.</p>



<p>Because the compiler was unable to assist you with such problems, concurrency <a href="https://swiftrocks.com/thread-safety-in-swift">(and thread safety specifically)</a> historically was one of the hardest things to get right in iOS development, and Apple was well aware of it. In 2017, Chris Lattner, one of the driving forces behind Swift, laid out his vision for making concurrency safe in his <a href="https://gist.github.com/lattner/31ed37682ef1576b16bca1432ea9f782">Swift Concurrency Manifesto</a>, and in 2020, <a href="https://forums.swift.org/t/swift-concurrency-roadmap/41611">a roadmap</a> materialized which envisioned new key features to Swift, which included:</p>



<ul>
<li>The async/await pattern</li>



<li>Task API and the concept of Structured Concurrency</li>



<li>Actors &amp; Actor Isolation</li>
</ul>



<p>But although what the roadmap proposed was new to the language, it was not new to tech itself. The async/await pattern, which was first introduced in 2007 as a feature of F#, has been an industry standard since 2012 (when C# made it mainstream) due to its ability to allow asynchronous code to be written as traditional synchronous ones, making concurrency-related code easier to read.</p>



<p>For example, before you might write:</p>



<pre><code>func loadWebResource(_ path: String, completionBlock: (result: Resource) -&gt; Void) { ... }</code>
<code>func decodeImage(_ r1: Resource, _ r2: Resource, completionBlock: (result: Image) -&gt; Void)</code>
<code>func dewarpAndCleanupImage(_ i : Image, completionBlock: (result: Image) -&gt; Void)</code>
<code></code>
<code>func processImageData1(completionBlock: (result: Image) -&gt; Void) {</code>
<code>    loadWebResource(&#34;dataprofile.txt&#34;) { dataResource in</code>
<code>        loadWebResource(&#34;imagedata.dat&#34;) { imageResource in</code>
<code>            decodeImage(dataResource, imageResource) { imageTmp in</code>
<code>                dewarpAndCleanupImage(imageTmp) { imageResult in</code>
<code>                    completionBlock(imageResult)</code>
<code>                }</code>
<code>            }</code>
<code>        }</code>
<code>    }</code>
<code>}</code>
</pre>



<p>whereas now you can write:</p>



<pre><code>func loadWebResource(_ path: String) async -&gt; Resource</code>
<code>func decodeImage(_ r1: Resource, _ r2: Resource) async -&gt; Image</code>
<code>func dewarpAndCleanupImage(_ i : Image) async -&gt; Image</code>
<code></code>
<code>func processImageData1() async -&gt; Image {</code>
<code>    let dataResource  = await loadWebResource(&#34;dataprofile.txt&#34;)</code>
<code>    let imageResource = await loadWebResource(&#34;imagedata.dat&#34;)</code>
<code>    let imageTmp      = await decodeImage(dataResource, imageResource)</code>
<code>    let imageResult   = await dewarpAndCleanupImage(imageTmp)</code>
<code>    return imageResult</code>
<code>}</code>
</pre>



<p>Introducing this pattern in Swift specifically would not only improve the experience of working with completion handlers but also technically allow the compiler to detect and prevent common concurrency mistakes. It’s easy to see why Chris Lattner made the pattern the central piece of his manifesto, in which he declared, in his own words: “I suggest that we do the obvious thing and support this in Swift.”</p>



<p>Over the years these features were gradually integrated into Swift, culminating in the Swift 5.5 release and the “official” release of async/await in Swift.</p>



<h2>Async/await under the hood</h2>



<p>Now that we understand why async/await became a part of Swift, we’re ready to take a look at how it works under the hood!</p>



<p>But first, I have to set some expectations with you. Because what we refer to as “async/await” is actually multiple different compiler features working in unison, and because each of these features is complicated enough to warrant their own separate article(s), there’s no way I can possibly cover every single detail of how it works in just one article. I would lose my sanity within the first section if I did that.</p>



<p>So instead of doing that, I’ve decided that a good plan would be to cover only what I believe to be async/await’s “core” functionality and to leave the remaining bits for future articles. But although we don’t go into details about those other bits here, I still made sure to mention some of them in the appropriate sections for you to know where they come into play. For simplicity, we’re also not going to cover compatibility modes and Obj-C bridging here.</p>



<p>With that said, let’s get started! When I reverse-engineer something to learn more about it, I always start from the bottom and move my way up. So when I decided that I wanted to understand how async/await works, my first question was: “Who is managing the program’s background threads?”</p>



<h2>The Cooperative Thread Pool</h2>



<p>One of the most important aspects of how async/await works in Swift, and one that we must cover before anything else, is that while async/await technically uses GCD under the hood, <b>it does not use the <code>DispatchQueues</code> that we are familiar with.</b> Instead, what powers async/await is a completely new feature of libdispatch called <b>The Cooperative Thread Pool.</b></p>



<p>Unlike traditional <code>DispatchQueues</code>, which creates and terminates threads dynamically as it deems necessary, the Cooperative Thread Pool manages a <b>fixed number of threads</b> that are constantly helping each other with their tasks.</p>



<p>The “fixed number”, which in this case is equal to the system’s number of CPU cores, is an intentional move that aims to prevent <b>thread explosion</b> and improve system performance in general, <a href="https://tclementdev.com/posts/what_went_wrong_with_the_libdispatch.html">something which DispatchQueues were notoriously not very good at.</a></p>



<p>In other words, the cooperative thread pool is similar to traditional GCD from an interface perspective (it’s a service that receives a job and arranges some thread to run it), but is more efficient and designed to better suit the Swift runtime’s special needs.</p>



<p>We can see exactly how the Cooperative Thread Pool works by exploring <a href="https://github.com/apple-oss-distributions/libdispatch">the open-source libdispatch repo</a>, but I would like to reserve that for a future article. In general, I find that <a href="https://developer.apple.com/videos/play/wwdc2021/10254/">this WWDC session from 2021</a> provides great information about how the pool works internally.</p>



<h3>Gotcha: Starving threads in the pool</h3>



<p>It must be noted that the fact that the pool holds a fixed number of threads has a significant impact on how asynchronous code is supposed to be written in the language. There is now an expectation that threads should always make f<em>orward progress</em>, which means you need to be really careful with when and how you do expensive operations in async/await in order to avoid starving the system&#39;s threads. <b>Swift&#39;s async/await has many gotchas like this</b>, and we&#39;ll uncover some of them as we proceed.</p>



<p>Let’s move up the abstraction layers. How does the compiler “speak” to the pool?</p>



<h2>Keep the jobs flowing: The Executors</h2>



<p>In Swift, you don&#39;t interact with the Cooperative Thread Pool directly. This is hidden by several layers of abstractions, and at the lowest of these layers, we can find the <b>executors</b>.</p>



<p>Executors, just like the pool itself, are<b> </b>services that accept jobs and arrange for some thread to run them. The core difference between them is that while the pool is just, well, the pool, executors come in many shapes and forms. They all end up forwarding jobs to the pool, but the way they do so may change depending on which type of executor you’re using. As of writing, executors can be either concurrent (jobs can run in parallel) or serial (one at a time), and the compiler provides built-in implementations for both of them.</p>



<h3>The Built-in Concurrent Executor</h3>



<p>The built-in concurrent executor is referred to internally as the <b>Global Concurrent Executor</b>.</p>



<p>The implementation of this executor in the Swift compiler is for the most part nothing more than an abstraction on top of the cooperative thread pool that we mentioned in the previous section. It starts by creating an instance of the new thread pool, which we can see is done by calling the good ol’ GCD API with a special new flag:</p>



<pre><code>constexpr size_t dispatchQueueCooperativeFlag = 4;</code>
<code>queue = dispatch_get_global_queue((dispatch_qos_class_t)priority,</code>
<code>                                  dispatchQueueCooperativeFlag);</code>
</pre>



<p>Then, when the executor is asked to run a job, it forwards it to the pool via a special <code>dispatch_async_swift_job</code> API:</p>



<pre><code>JobPriority priority = job-&gt;getPriority();</code>
<code>auto queue = getGlobalQueue(priority);</code>
<code>  dispatch_async_swift_job(queue, job, (dispatch_qos_class_t)priority,</code>
<code>                  DISPATCH_QUEUE_GLOBAL_EXECUTOR);</code>
</pre>



<p>I would like to leave the details of libdispatch and <code>dispatch_async_swift_job</code> for another time, but as mentioned in the previous section, this is supposed to be a special/more efficient variant of the regular <code>dispatch_async</code> API that iOS developers are familiar with that better suits the Swift runtime’s special needs.</p>



<p>Another aspect of this executor worth mentioning is that it&#39;s &#34;global&#34;, meaning there is only one instance of it for the entire program. The reasoning for this is similar to why a serial <code>DispatchQueue</code> would deep-down forward its jobs to the global ones: while from a systems perspective, it makes sense for the responsibilities to appear to be divided, from a performance perspective it would be a nightmare for each component to have their own dedicated threads. It&#39;s sensible then to have a single, global executor that will ultimately schedule most of the work in the system, and have everyone else forward their jobs to it.</p>



<p>The Global Concurrent Executor is Swift’s default executor in general. If your async code is not explicitly requesting that it should go through a specific executor (we will see some examples of that as we continue to explore the abstractions), this is the executor that will handle it.</p>



<p>(Swift uses a different global executor in platforms that don’t support libdispatch, but I will not go into details of that as the primary focus of this article is iOS development.)</p>



<h3>The Built-in Serial Executor</h3>



<p>Unlike the concurrent executor, the purpose of the serial executor is to make sure jobs are executed one by one and in the order in which they were submitted.</p>



<p>The built-in serial executor is referred internally to as the <b>&#34;Default Actor&#34;</b> (spoiler alert!), and it is in its essence an abstraction of the concurrent executor that keeps track of a linked list of jobs:</p>



<pre><code>class DefaultActorImpl : public HeapObject {</code>
<code>public:</code>
<code>  void initialize();</code>
<code>  void destroy();</code>
<code>  void enqueue(Job *job);</code>
<code>  bool tryAssumeThread(RunningJobInfo runner);</code>
<code>  void giveUpThread(RunningJobInfo runner);</code>
<code>}</code>
<code></code>
<code>struct alignas(2 * sizeof(void*)) State {</code>
<code>  JobRef FirstJob;</code>
<code>  struct Flags Flags;</code>
<code>};</code>
<code></code>
<code>enum class Status {</code>
<code>  Idle,</code>
<code>  Scheduled,</code>
<code>  Running,</code>
<code>};</code>
<code></code>
<code>swift::atomic&lt;State&gt; CurrentState;</code>
</pre>



<p>When a job is enqueued, instead of immediately forwarding it to the concurrent executor, it stores it in the linked list and waits until there’s no one in front of it before truly passing it forward.</p>



<pre><code>static void setNextJobInQueue(Job *job, JobRef next) {</code>
<code>  *reinterpret_cast&lt;JobRef*&gt;(job-&gt;SchedulerPrivate) = next;</code>
<code>}</code>
</pre>



<p>The full extent of what happens when a job is enqueued to the serial executor is one of those things that I said I have to skip in order to maintain my sanity because this executor is responsible for managing a <b>lot</b> of stuff relating to other async/await features (<a href="https://github.com/apple/swift/blob/main/stdlib/public/Concurrency/Actor.cpp">Actor.cpp</a> alone has 2077 lines of code).</p>



<p>But one interesting thing worth mentioning is how it attempts to prevent priority inversions. When a high-priority job is enqueued to a list that previously only had low-priority jobs, the executor escalates the priority of all jobs that came before it.</p>



<pre><code>if (priority &gt; oldState.getMaxPriority()) {</code>
<code>  newState = newState.withEscalatedPriority(priority);</code>
<code>}</code>
</pre>



<p>As the name implies, the Default Actor serial executor comes into play when writing async code via the <b>Actors</b> feature. We still have a couple of things to understand before we can look into actors though, so let’s move on for now.</p>



<h3>Custom Executors</h3>



<p>Besides the two built-in executors, it&#39;s also possible to build your own custom executor in Swift by creating a type that inherits from the Executor protocol:</p>



<pre><code>public protocol Executor: AnyObject, Sendable {</code>
<code>    func enqueue(_ job: consuming Job)</code>
<code>}</code>
</pre>



<p>For serial executors specifically, Swift even provides a more specific <code>SerialExecutor</code> protocol:</p>



<pre><code>public protocol SerialExecutor: Executor { ... }</code>
</pre>



<p>The ability to do so was added in Swift 5.9 alongside the ability to pass custom executors to certain APIs, but there&#39;s little reason why you would do such a thing. This was added as a support tool for developers who use Swift in other platforms and is not something an iOS developer would have to deal with. With that said, we do have one very important feature to cover in this article that relies on this ability, but we need to answer a couple more questions before we can look into what that feature is.</p>



<p>Let&#39;s keep moving up the abstraction layers. We now know that Swift&#39;s built-in executors are the ones passing jobs to the cooperative thread pool, but where do these jobs come from?</p>



<h2>Get me those jobs: The async/await pattern</h2>



<p>The next piece of the puzzle lies in the async/await pattern itself.</p>



<p>As you might know by now, the async/await pattern consists of two new keywords (<code>async</code> and <code>await</code>) that allow you to define an asynchronous function and wait for an asynchronous function to return, respectively:</p>



<pre><code>func example() async {</code>
<code>    let fooResult = await foo()</code>
<code>    let barResult = await bar()</code>
<code>    doSomething(fooResult, barResult)</code>
<code>}</code>
<code></code>
<code>func foo() async -&gt; FooResult {</code>
<code>    // Some async code</code>
<code>}</code>
<code></code>
<code>func bar() async -&gt; BarResult {</code>
<code>    // Some async code</code>
<code>}</code>
</pre>



<p>One of the main purposes of the async/await pattern is to allow you to write asynchronous code as if it were straight-line, synchronous code, and this might give you the impression that deep down this feature is just a compiler pass that is dividing a function into multiple components. This definition is important in order to understand how the machine is operating, but in reality, things are a lot more sophisticated than that!</p>



<p>Instead of thinking of an asynchronous function as just a syntax sugar for declaring a bunch of closures, think of it as an <b>ordinary function that has the special power to give up its thread and wait for something to happen.</b> When that thing is complete, the function bootstraps itself back up and resumes its execution.</p>



<p>This means that apart from how they wait for things to happen, asynchronous functions and synchronous ones are (sort of) the same thing in Swift! The only difference is that while the synchronous function gets to take full advantage of the thread and its stack, the asynchronous ones have the extra power of giving up that stack and maintaining their own, separate storage.</p>



<p>Although our main interest here is exploring memory safety, one interesting thing to mention is how this definition is important from a code architecture perspective; because asynchronous functions in Swift are effectively the same as synchronous ones, this means you can use them for things that you previously couldn’t do with completion handler closures, such as marking a function as <code>throws</code>:</p>



<pre><code>func foo() async throws {</code>
<code>    // …</code>
<code>    throw MyError.failed // Can’t do this without async/await!</code>
<code>}</code>
</pre>



<p>But enough theory. How does it work?</p>



<h3>Execution Contexts</h3>



<p>We can start understanding how the pattern is implemented by looking at what the Swift compiler does when it processes a line of code marked as <code>await</code>. By compiling the above example code with the <code>-emit-sil </code>flag, we can that the example’s Swift Intermediate Language output looks something like this (greatly simplified for readability):</p>



<pre><code>// example()</code>
<code>sil hidden @$s4test7exampleyyYaF : $@convention(thin) @async () -&gt; () {</code>
<code>bb0:</code>
<code>  hop_to_executor foo</code>
<code>  foo()</code>
<code>  hop_to_executor example</code>
<code>  hop_to_executor bar</code>
<code>  bar()</code>
<code>  hop_to_executor example</code>
<code>  return void</code>
<code>} // end sil function &#39;$s4test7exampleyyYaF&#39;</code>
</pre>



<p>The SIL of an async function looks exactly the same as the one from a regular synchronous function would, with the difference that Swift calls something called <code>hop_to_executor</code> before and after an await function is supposed to be called. According to the compiler’s documentation, the purpose of this symbol is to make sure that the code is running in the right executor. Hmmmm.</p>



<p>One important memory safety feature of Swift’s async/await is what it refers to as <b>execution contexts</b>. As we briefly mentioned when we talking about executors, whenever something runs asynchronously in Swift through async/await, it has to go through a specific executor; the majority of code will go through the default global concurrent one, but certain APIs may use different ones.</p>



<p>The reason why certain APIs may have specific executor requirements is to <b>prevent data races</b>. We’re not ready to explore this topic yet though, so for now just keep in mind that this is why different executors exist.</p>



<p>What <code>hop_to_executor</code> does in practice is check the current execution context. If the executor that the function is currently running on is the same as the function that we want to <code>await</code> expects, the code will run synchronously. But if it’s not, a <b>suspension point</b> is created; the function requests the necessary code to run in the correct context and gives up its thread while it waits for the result. This “request” is the job that we were looking for, and the same will happen when the job finishes in order to return to the original context and run the rest of the code.</p>



<pre><code>func example() async {</code>
<code>    (original executor)</code>
<code>    let fooResult = await foo() // POTENTIAL job 1 (go to foo’s executor)</code>
<code>    // POTENTIAL job 2 (back to original context)</code>
<code>    let barResult = await bar()  // POTENTIAL job 3 (go to bar’s executor)</code>
<code>    // POTENTIAL job 4 (back to original context)</code>
<code>    doSomething(fooResult, barResult)</code>
<code>}</code>
</pre>



<p>The word <b>potential</b> here is very important: As just mentioned, a suspension point is <b>only</b> created if we’re in the wrong context; If no context hopping is needed, the code will run synchronously. This is something that <code>DispatchQueues</code> notoriously could not do, and is a very welcome ability that we will mention again later in this article.</p>



<p>In fact, since <code>await</code> only marks a <em>potential</em> suspension point, this has the interesting side-effect of allowing <em>async</em> protocol requirements to be fulfilled by regular, synchronous ones:</p>



<pre><code>protocol MyProto {</code>
<code>    func asyncFunction() async</code>
<code>}</code>
<code></code>
<code>struct MyType: MyProto {</code>
<code>    func asyncFunction() {</code>
<code>        // This is not an async function, but the Swift is fine with it</code>
<code>        // because `async` and `await` doesn’t mean that the</code>
<code>        // function is _actually_ async, only that it _may_ be.</code>
<code>    }</code>
<code>}</code>
</pre>



<p>This is also why you can call synchronous functions from asynchronous ones but not vice-versa; asynchronous functions know how to synchronously wait for something, but synchronous ones don’t know how to create suspension points.</p>



<p>Suspension points are a major win for memory safety in Swift: because they result in the thread being released (as opposed to how a lock, semaphore, or <code>DispatchQueue.sync</code> would hold onto it until the result arrived), this means that <b>deadlocks cannot happen in async/await</b>! As long as you’re not mixing async/await code with other thread-safety mechanisms (which Apple says you shouldn’t <a href="https://developer.apple.com/videos/play/wwdc2021/10254/">in their 2021 session</a>), your code will always have a thread in which it can run.</p>



<h3>Gotcha: Reentrancy</h3>



<p>It must be noted though that this behavior has an important gotcha in terms of code architecture. Because suspension points may give up their thread while waiting for a result, it can (and will) happen that the thread that originated the request may start running <b>other jobs</b> while it waits for the result to arrive! In fact, unless you’re using Main Actors (which we will explore in detail later on), there’s no guarantee that the thread that will process the result will even be the same one that originated the request!</p>



<pre><code>func example() async {</code>
<code>    doSomething() // Running in thread A</code>
<code>    await somethingElse()</code>
<code>    doSomethingAgain() // This COULD also be running in thread A, but it’s probably not!</code>
<code>    // Also, thread A has likely moved on to do other things while we were waiting for somethingElse()!</code>
<code>}</code>
</pre>



<p>This means that in order to implement thread-safe objects in async/await, you must structure your code in a way so that it’s <b>never assuming or carrying state across suspension points</b> because any assumptions that you made about the program’s state prior to the suspension point might not be true anymore <em>after</em> the suspension point. This behavior of async/await is called <b>reentrancy</b> and is something we’ll explain in more detail further below when we start speaking about <b>race conditions</b> specifically. In short, reentrancy in Swift’s async/await is intentional, and is something you must keep in mind at all times when working with async/await code in Swift.</p>



<p>I would like to show you how exactly these suspension points and the re-bootstrapping work in the compiler’s code, but as of writing, I was not able to properly understand it. I’d still like to do that though, so I’ll update this article once I figure that out.</p>



<p>We still have one important puzzle piece to investigate though. If synchronous functions are not allowed to call asynchronous ones because they don’t have the power to create a suspension point, what is the “entry point” for an asynchronous function?</p>



<h2>Tasks and Structured Concurrency</h2>



<p>In Swift’s async/await, the way you call an asynchronous function the first time is by creating a <code>Task</code> object:</p>



<pre><code>Task {</code>
<code>    await foo()</code>
<code>}</code>
</pre>



<p>Because the closure of a task object is itself marked as <code>async</code>, you can use it to call other asynchronous functions. This is the “entry point” we were looking for.</p>



<p>Swift’s <code>Task</code> struct has a much bigger role than simply allowing you to call async code; they form a fundamental part of what Swift calls &#34;Structured Concurrency,&#34; where asynchronous code is structured as a hierarchy of &#34;tasks.&#34; This structuring allows parent tasks to manage their child tasks, sharing information like status, context, priority, and local values, as well as enabling the creation of child &#34;task groups&#34; that comprise multiple tasks that run in parallel. Structured Concurrency forms the backbone of Swift&#39;s async/await architecture, but is a topic large enough to warrant its own article. For the purposes of this article, we’re going to focus only on the core functionality of tasks.</p>



<p>Let’s get back to the original question. How is Task managing to create an async closure out of nowhere?</p>
<p>The key to understanding how Task bootstraps an async closure lies in its initializer. When a <code>Task</code> is created, the closure it captures is managed not by the <code>Task</code> struct itself, but by a function that lives deep within the Swift runtime:</p>



<pre><code>extension Task where Failure == Never {</code>
<code>  public init(</code>
<code>    priority: TaskPriority? = nil,</code>
<code>    @_inheritActorContext @_implicitSelfCapture operation: __owned @Sendable @escaping () async -&gt; Success</code>
<code>  ) {</code>
<code>    let flags = taskCreateFlags(</code>
<code>      priority: priority, isChildTask: false, copyTaskLocals: true,</code>
<code>      inheritContext: true, enqueueJob: true,</code>
<code>      addPendingGroupTaskUnconditionally: false,</code>
<code>      isDiscardingTask: false)</code>
<code></code>
<code>    let (task, _) = Builtin.createAsyncTask(flags, operation)</code>
<code>    self._task = task</code>
<code>  }</code>
<code>}</code>
</pre>



<p>The call to <code>Builtin.createAsyncTask</code> ultimately results in a call to <code>swift_task_create</code> in the Swift runtime, which creates a task based on a couple of flags that configure how the task should behave. The compiler conveniently takes that of that configuration automatically for you, and once the task is set up, it is immediately directed to the appropriate executor for execution.</p>



<pre><code>static AsyncTaskAndContext swift_task_create_commonImpl(…) {</code>
<code>  // The actual function is a lot more complicated than this.</code>
<code>  // This is just a pseudo-coded simplification for learning purposes.</code>
<code></code>
<code>  task.executor = task.parent.executor ?? globalConcurrentExecutor;</code>
<code></code>
<code>  task.checkIfItsChildTask(flags);</code>
<code>  task.checkIfItsTaskGroup(flags);</code>
<code>  task.inheritPriorityFromParentIfNeeded(flags);</code>
<code></code>
<code>  task.asJob.submitToExecutor();</code>
<code>}</code>
</pre>



<p>Structured Concurrency is the reason why the compiler knows all of this information. Similarly to how the serial executor tracks a linked list of jobs, the Swift runtime tracks a graph of all tasks running concurrently in the program. This tracking, in combination with a secondary map connecting asynchronous functions to the tasks that invoked them, allows Swift to infer all the necessary information to bootstrap a task, including the ability to make adjustments such as escalating the priority of a child task based on their parent&#39;s priority.</p>
<p>Interestingly enough, Swift actually provides you with APIs that allow you to access these graphs in your Swift code, although they make it very clear that should only be used in special cases. One example of this is <code>withUnsafeCurrentTask</code>, which allows functions to determine if they were called as part of a task.</p>



<pre><code>func synchronous() {</code>
<code>  withUnsafeCurrentTask { maybeUnsafeCurrentTask in </code>
<code>    if let unsafeCurrentTask = maybeUnsafeCurrentTask {</code>
<code>      print(&#34;Seems I was invoked as part of a Task!&#34;)</code>
<code>    } else {</code>
<code>      print(&#34;Not part of a task.&#34;)</code>
<code>    }</code>
<code>  }</code>
<code>}</code>
</pre>

<h3>Gotcha: Accidental Task Inheritance</h3>

<p>Because child tasks by default inherit the properties of their parent, and because the runtime handles that automatically for you, you might end up in situations where a task is inheriting things you didn&#39;t mean to:</p>

<pre><code>func example() async {</code>
<code>  Task {</code>
<code>    // This is NOT a parentless task, as much as it looks like one!</code>
<code>  }</code>
<code>}</code>
</pre>

<p>In the example above, what looks like a &#34;bland&#34; task is actually a <b>child task</b> of whatever job led to <code>example()</code> being called! This means this task will inherit that parent&#39;s properties, which <i>may</i> include things you don&#39;t want this particular task to inherit, such as the executor. One example case where this can be a problem is when dealing with code that interacts with the <code>MainActor</code>, which we will explore in detail further below.</p>
<p>In order to avoid this, you must use alternate task initializers like <code>Task.detached</code> which define &#34;unstructured&#34; tasks with no parent, but it must be noted that they <i>also</i> have their own gotchas, so make sure to read their API documentation before using them.</p>

<p>We’ve now covered all the core mechanics of async/await, but we still have one question left to answer. We’ve seen how async/await is able to prevent thread explosion, priority inversions, and deadlocks, but what about <b>data races</b>? We know that the concept of “execution contexts” is what’s supposed to prevent it, but we haven’t seen that in practice yet. </p>



<p>We also haven’t even begun to talk about the infamous <b>race conditions</b> that plague every iOS app. What does Swift’s async/await do to protect you from those?</p>



<h2>Protecting shared mutable state: Actors</h2>



<p>We have left Actors to last because they don’t relate to the core functionality of async/await, but when it comes to memory safety, they are just as important as the other features we’ve covered.</p>



<p>In Swift, an “actor” is a special type of class that is marked with the <code>actor</code> keyword:</p>



<pre><code>actor MyExample {</code>
<code>    var fooInt = 0</code>
<code>}</code>
</pre>



<p>Actors are mostly the same as classes, but they contain a special power: any mutable state managed by an actor can only be modified by the actor itself:</p>



<pre><code>func foo() {</code>
<code>    let example = MyExample()</code>
<code>    example.fooInt = 1 // Error: Actor-isolated `fooInt`</code>
<code>    // cannot be mutated from a non-isolated context</code>
<code>}</code>
</pre>



<p>In the example above, in other to mutate <code>fooInt</code>, we must somehow abstract that action so that it happens within the bounds of the actor:</p>



<pre><code>actor MyExample {</code>
<code>    var fooInt = 0</code>
<code>    func mutateFooInt() {</code>
<code>        fooInt = 1</code>
<code>    }</code>
<code>}</code>
</pre>



<p>This looks like it would make no difference, but this is where the actors’ second special power comes into play: only the actor is allowed to synchronously reference its methods and properties; everyone else must do it asynchronously:</p>



<pre><code>func foo() {</code>
<code>    let example = MyExample()</code>
<code>    Task {</code>
<code>        await example.mutateFooInt()</code>
<code>        // The actor itself is allowed to call mutateFooInt() synchronously,</code>
<code>        // but the example() function is not.</code>
<code>    }</code>
<code>}</code>
</pre>



<p>This is a concept called <b>actor isolation</b>, and when combined with the concept of <b>execution contexts</b> we’ve seen above, Swift’s async/await is able to <b>prevent you from introducing potential data races in your program.</b> To make it better, those checks happen in <b>compile time!</b></p>



<p>To be more specific, when you <code>await</code> on an actor, your code will be forwarded not to the default global concurrent executor, but a <b>serial</b> one that was created specifically for that actor instance. This has the effect of not allowing you to call two actor functions at the same time (one will end before the other one starts), and when combined with the fact that the compiler doesn’t allow you to “leak” an actor’s mutable state, you have essentially a situation where it’s not possible for your actor’s state to be mutated by two threads at the same time. But how does this work internally?</p>



<p>When it comes to their implementations, actors are surprisingly straightforward. In Swift, declaring an actor is just a syntax sugar for declaring a class that inherits from the <code>Actor</code> protocol:</p>



<pre><code>public protocol Actor: AnyObject, Sendable {</code>
<code>    nonisolated var unownedExecutor: UnownedSerialExecutor { get }</code>
<code>}</code>
</pre>



<p>The only property of the protocol is <code>unownedExecutor</code>, which is a pointer to the serial executor that is supposed to manage the jobs related to that actor. The purpose of the <code>UnownedSerialExecutor</code> type is to wrap a type conforming to the <code>SerialExecutor</code> protocol we saw previously as an unowned reference, which the documentation describes as necessary for optimization reasons.</p>



<pre><code>public struct UnownedSerialExecutor: Sendable {</code>
<code>    internal var executor: Builtin.Executor</code>
<code>    public init&lt;E: SerialExecutor&gt;(ordinary executor: __shared E) {</code>
<code>      self.executor = Builtin.buildOrdinarySerialExecutorRef(executor)</code>
<code>    }</code>
<code>}</code>
</pre>



<p>When you declare an actor via the syntax sugar, Swift automatically generates this conformance for you:</p>



<pre><code>// What you write:</code>
<code>actor MyActor {}</code>
<code></code>
<code>// What is compiled:</code>
<code>final class MyActor: Actor {</code>
<code></code>
<code>    nonisolated var unownedExecutor: UnownedSerialExecutor {</code>
<code>        return Builtin.buildDefaultActorExecutorRef(self)</code>
<code>    }</code>
<code></code>
<code>    init() {</code>
<code>        _defaultActorInitialize(self)</code>
<code>    }</code>
<code></code>
<code>    deinit {</code>
<code>        _defaultActorDestroy(self)</code>
<code>    }</code>
<code></code>
<code>}</code>
</pre>



<p>We already know what this generated code is doing; it initializes the <b>Default Actor</b> serial executor that we’ve covered at the beginning. Since actors are deeply ingrained into Swift, the compiler knows that whenever someone references it, the eventual call to <code>hop_to_executor</code> should point to the actor’s <code>unownedExecutor</code> property and not the global one.</p>



<h3>Gotcha: Actor Reentrancy (Actors and thread-safety)</h3>



<p>While actors naturally protect you from <b>data races</b>, it’s critical to remember that <b>they cannot protect you from logic mistakes like race conditions / straight-up incorrect code.</b> We have already covered why this is the case when we talked about suspension points and <b>reentrancy</b>, but I’d like to reiterate this because this is extra important when working with actors specifically.</p>



<p>When a suspension point is created, <b>the actor will allow other jobs in the serial queue to run.</b> This means that when the result for the original job finally arrives, it’s possible that the actor’s state may have changed in a way where whatever assumptions you made <em>before</em> the suspension point are no longer true!</p>



<p>In actors specifically, this is referred to as <b>Actor Reentrancy</b>, and is once again something you must keep in mind at all times when attempting to write thread-safe code with async/await. As suggested in the section about reentrancy in general, in order for your actors to be thread-safe, you must structure your code so that no state is assumed or carried over across suspension points.</p>



<h3>Sendable and nonisolated</h3>



<p>Like in the case of deadlocks, an actor’s solution for data races has important consequences in terms of code architecture. If you cannot “leak” an actor’s mutable state, how does anything ever happen?</p>



<p>Swift’s async/await provides two features to address this. The first one is the <code>Sendable</code> protocol, which marks types that can safely leave an actor:</p>



<pre><code>public protocol Sendable { }</code>
</pre>



<p>This protocol has no actual code; it’s simply a marker used by the compiler to determine which types are allowed to leave the actors that created them. This doesn’t mean that you can mark anything as <code>Sendable</code> through; Swift <em>really</em> doesn’t want you to introduce data races into your programs, so the compiler has very strict requirements of what can inherit it:</p>



<ul>
<li>Actors (does so by default)</li>



<li>Value types</li>



<li><code>final</code> classes that have no mutable properties</li>



<li>Functions and closures (by marking them with <code>@Sendable</code>)</li>
</ul>



<h4>Gotcha: Sendable contagion</h4>



<p>While <code>Sendable</code> solves this problem, it must be noted that this protocol has been the target of criticism in the Swift community due how the necessity of tagging “safe” types combined with how the compiler has the tendency to behave like an overprotective mother (it will complain that a type must be <code>Sendable</code> even when in situations where no data race could possibly happen) can quickly cause <code>Sendable</code> to “plague” your program’s entire architecture. There have been pitches on potential improvements in this area, but I believe as of writing no formal proposals have been submitted yet.</p>



<p>Aside from <code>Sendable</code>, the <code>nonisolated</code> keyword is also intended to assist with the problem of having to “leak” an actor’s state. As the name implies, this allows you to mark functions and properties that are allowed to ignore the actor’s isolation mechanism:</p>



<pre><code>actor BankAccount {</code>
<code>    nonisolated let accountNumber: Int</code>
<code>}</code>
</pre>



<p>When referenced, the compiler will pretend that the type didn’t originate from an actor and skip any and all protection mechanisms that would normally apply. However, similarly to <code>Sendable</code>, not everything can be marked as <code>nonisolated</code>. Only types that are <code>Sendable</code> can be marked as such.</p>



<h3>Actors and the Main Thread</h3>



<p>At this point, we’ve covered everything we needed regarding async/await in Swift, but there’s still one thing we still need to cover regarding iOS development specifically. <b>Where’s the main thread in all of this?</b></p>



<p>We’ve talked a lot about the new thread pool and how executors interact with them, but iOS developers will know that UI work <b>always</b> needs to run in the main thread. How can you do that if the cooperative thread pool has no concept of a “main” thread?</p>



<p>In Swift, this is where the ability to build custom executors that we’ve seen at the beginning of the article comes into play. Swift’s standard library ships a type called <code>MainActor</code>, which as the name implies, is a special type of actor that synchronizes all of its jobs to the main thread:</p>



<pre><code>@globalActor public final actor MainActor: GlobalActor {</code>
<code>  public static let shared = MainActor()</code>
<code></code>
<code>  public nonisolated var unownedExecutor: UnownedSerialExecutor {</code>
<code>    return UnownedSerialExecutor(Builtin.buildMainActorExecutorRef())</code>
<code>  }</code>
<code></code>
<code>  public nonisolated func enqueue(_ job: UnownedJob) {</code>
<code>    _enqueueOnMain(job)</code>
<code>  }</code>
<code>}</code>
</pre>



<p>The <code>MainActor</code> achieves this by overriding the default <code>unownedExecutor</code> with a custom <code>Builtin.buildMainActorExecutorRef()</code> one. Since we’re telling Swift that we don’t want to use the default serial executor for this actor, this will deep down cause the Swift runtime to call the MainActor’s custom-defined enqueue method instead.</p>



<p>In the case of <code>MainActor</code>, the call to <code>_enqueueOnMain</code> will cause the job to be forwarded to the global concurrent executor as usual, but this time via a special function that causes the job to be submitted to GCD’s main queue instead of the cooperative thread pool.</p>



<pre><code>// The function where “regular” async/await jobs ends up in</code>
<code>static void swift_task_enqueueGlobalImpl(Job *job) {</code>
<code>  auto queue = getCooperativeThreadPool();</code>
<code>  dispatchEnqueue(queue, job);</code>
<code>}</code>
<code></code>
<code>// The function where MainActor jobs ends up in</code>
<code>static void swift_task_enqueueMainExecutorImpl(Job *job) {</code>
<code>  auto mainQueue = dispatch_get_main_queue();</code>
<code>  dispatchEnqueue(mainQueue, job);</code>
<code>}</code>
</pre>



<p>In other words, code executed by the main actor is essentially the same thing as calling <code>DispatchQueue.main.async</code>, although not <i>literally</i> the same due to two facts that we have already covered: the fact that the Swift runtime uses a “special” version of <code>DispatchQueue.async</code> to submit its jobs, and the fact the dispatch will technically not happen if we’re already inside the main thread (<code>MainActor’s</code> “execution context”).</p>



<pre><code>// What you write:</code>
<code>Task {</code>
<code>    await myMainActorMethod()</code>
<code>}</code>
<code></code>
<code>// What (sort of) actually happens:</code>
<code>// (Actual behavior explained above)</code>
<code>Task {</code>
<code>    DispatchQueue.main.async {</code>
<code>        myMainActorMethod()</code>
<code>    }</code>
<code>}</code>
</pre>



<h3>Global Actors</h3>



<p>The final thing I’d like to show you is how actors like the MainActor are used in practice. We know that regular actors are created and passed around as normal objects, but doing so with the <code>MainActor</code> would not scale well. Even though the <code>MainActor</code> is available as a singleton, there’s a <em>lot</em> of stuff that needs to run in the main thread in iOS, so if we were treating it like a regular object, we would end up with a lot of code looking like this:</p>



<pre><code>extension MainActor {</code>
<code>    func myMainActorMethod() {}</code>
<code>}</code>
<code></code>
<code>func example() {</code>
<code>    Task {</code>
<code>        await MainActor.shared.myMainActorMethod()</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>///////////// or:</code>
<code></code>
<code>func example() {</code>
<code>    Task {</code>
<code>        await MainActor.run {</code>
<code>            myMainActorMethod()</code>
<code>        }</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>func myMainActorMethod() {}</code>
</pre>



<p>Although both solutions “work”, Swift saw potential for improvement by creating the concept of “global actors”, which describe actors that can not only be referenced <b>but also expanded</b> from anywhere in the program. Instead of forcing everyone to reference singletons everywhere, Swift&#39;s Global Actors feature allows you to easily indicate that a certain piece of code should be executed within the bounds of a specific global actor by marking it with a special annotation:</p>



<pre><code>@MainActor</code>
<code>func myMainActorMethod() {}</code>
</pre>



<p>This is essentially the same thing as the examples shown above, but with much less code. Instead of having to reference the <code>MainActor’s</code> singleton, we can now directly reference this method and be sure that it will be executed within the <code>MainActor’s</code> context.</p>



<pre><code>func example() {</code>
<code>    await myMainActorMethod() // This method is annotated as @MainActor,</code>
<code>    // so it will run in the MainActor’s context.</code>
<code>}</code>
</pre>



<p>In order to be able to do this, the actor in question must be marked with the <code>@globalActor</code> keyword, and is something that you can do for your own actors if you find that this behavior would be useful for them. As one would expect, the <code>MainActor</code> is itself a global actor.</p>

<p>Marking an actor as <code>@globalActor</code> is deep down a syntax sugar for declaring an actor that inherits from the <code>GlobalActor</code> protocol, which is essentially a variation of the regular <code>Actor</code> protocol that additionally defines a singleton that Swift can refer to when it finds one of those special annotations across the program.</p>



<pre><code>public protocol GlobalActor {</code>
<code>  associatedtype ActorType: Actor</code>
<code>  static var shared: ActorType { get }</code>
<code>}</code>
</pre>



<p>Then, during compilation time, when Swift encounters one of those annotations, it follows up by emitting the underlying <code>hop_to_executor</code> call with a reference to that actor’s singleton.</p>



<pre><code>func example() {</code>
<code>    // SIL: hop_to_executor(MainActor.shared)</code>
<code>    await myMainActorMethod()</code>
<code>    // SIL: hop_to_executor(DefaultExecutor)</code>
<code>}</code>
</pre>



<h2>Conclusion: Swift&#39;s async/await makes concurrency simpler, but not necessarily easier</h2>



<p>In general, I like async/await. I think this is a nice addition to Swift, and it makes working with concurrency a lot more interesting.</p>



<p>But you must not get this wrong. Although Swift prevents you from making memory-related mistakes, <b>it does NOT prevent you from making logic mistakes / writing <b>straight-up incorrect code</b></b>, and the way the feature works today makes it <b>very easy</b> for you to introduce such mistakes. We&#39;ve covered some of the pattern&#39;s gotchas in this article, but there are many more of them pertaining to features we didn&#39;t get to explore here.</p>



<p><a href="https://www.youtube.com/watch?v=HqjqwW12wpw">Matt Massicotte&#39;s &#34;The Bleeding Edge of Swift Concurrency&#34; talk from Swift TO 2023</a> goes into more detail about gotchas in async/await, and I believe is a talk that anyone working with async/await in Swift should watch.</p>

<p>For more information on thread safety in Swift specifically, <a href="https://swiftrocks.com/thread-safety-in-swift">check out my article about it.</a></p>

</div></div>
  </body>
</html>
