<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sr.ht/~icefox/oorandom/#a-brief-history-of-random-numbers">Original</a>
    <h1>A Brief History of Random Numbers</h1>
    
    <div id="readability-page-1" class="page"><div>
<div>
<div>
<div><h2 id="oorandom"><a href="#oorandom" rel="nofollow noopener">#</a>oorandom</h2>
<p><a href="https://crates.io/crates/oorandom" rel="nofollow noopener"><img alt="Crates.io" src="https://img.shields.io/crates/v/oorandom.svg"/></a>
<a href="https://docs.rs/oorandom" rel="nofollow noopener"><img alt="Docs" src="https://docs.rs/oorandom/badge.svg"/></a>
<a href="https://builds.sr.ht/~icefox/oorandom?" rel="nofollow noopener"><img alt="builds.sr.ht status" src="https://builds.sr.ht/~icefox/oorandom.svg"/></a></p>
<h2 id="what-is-this"><a href="#what-is-this" rel="nofollow noopener">#</a>What is this?</h2>
<p><code>oorandom</code> is a minimalistic pseudorandom number generator in Rust.  For
those times when the <code>rand</code> crate is just too big and you want something
a bit dumber.</p>
<p>More specifically, it implements ONE prng, which is currently a permuted
congruential generator (PCG).  It may change if something better comes
along, but that seems unlikely and will probably be a major version
bump.  It will give you <code>u32</code> or <code>u64</code>, and signed or floating-point
equivalents.  It is also <code>#[no_std]</code>.  Anything else is gravy.</p>
<p>Thanks to Lokathor for making
<a href="https://github.com/Lokathor/randomize" rel="nofollow noopener"><code>randomize</code></a>, which inspired me
to do my own equivalent.</p>
<p>The name comes from my attempts to find a good way to pronounce
<code>/dev/urandom</code>.</p>
<p>Please direct questions, discussions and bugs to the <a href="https://todo.sr.ht/~icefox/oorandom" rel="nofollow noopener">issue
tracker</a>.</p>
<h2 id="why-use-codeoorandomcode-instead-of"><a href="#why-use-codeoorandomcode-instead-of" rel="nofollow noopener">#</a>Why use <code>oorandom</code> instead of...</h2>
<ul>
<li><code>rand</code> -- <code>oorandom</code> is simpler and has zero choices you need to
make.  It also compiles in 1/10th the time and has a stable API.</li>
<li><code>getrandom</code> -- They solve different problems; <code>getrandom</code> gives you
whatever secure randomness the OS decides to give you, not a
deterministic and seedable PRNG.  It&#39;s generally a good idea to use
<code>getrandom</code> to seed this RNG though.</li>
<li><code>randomize</code> -- <code>randomize</code> used to be more complicated, but
<code>randomize</code> 3.x is quite similar to <code>oorandom</code> in functionality and
design.  Go for it.</li>
<li><code>rand_pcg</code> and <code>rand_core</code> -- Yes you can take <code>rand</code> apart into its
pieces and use those individually, if you want to abandon having an
all-in-one solution, still deal with the lack of stability in
<code>rand_core</code> and actually figure out which pieces you need.  It works
just fine.  Seems more complicated than it needs to be though.</li>
<li><code>nanorand</code> -- <code>nanorand</code> uses the
<a href="https://github.com/wangyi-fudan/wyhash" rel="nofollow noopener">WyRand</a> PRNG algorithm,
which is supposedly faster than PCG and at least as good quality.  I
haven&#39;t verified these claims, and I don&#39;t know of any <em>really</em>
thorough 3rd party investigation into them, though it apparently
passes <a href="https://github.com/lemire/testingRNG" rel="nofollow noopener">Dr. Lemire&#39;s tests</a>.
So for now I personally consider WyRand to be in the &#34;trust but
verify&#34; level of quality.  It&#39;s probably fine.</li>
<li><code>fastrand</code> -- Looks fine, uses the same algorithm as <code>oorandom</code>.
Made by the same people as the <code>smol</code> async runtime, which may be
good or bad for you.  Does slightly more than <code>oorandom</code> does, which
may be good or bad for you.  Use it if you like it.</li>
</ul>
<h2 id="this-is-not"><a href="#this-is-not" rel="nofollow noopener">#</a>This is not...</h2>
<p>This is not cryptographically secure, and if you use it for crypto you
will get what you deserve.  You are also in charge of choosing a useful
seed; the <code>getrandom</code> crate might be useful for that.</p>
<p>This is also not optimized to be stupidly fast, but is basically just
as fast as <code>rustc</code> feels like making it.  This means it is safe and robust
and portable and involves absolutely zero clever tricks.</p>
<h2 id="usage"><a href="#usage" rel="nofollow noopener">#</a>Usage</h2>
<div><pre><span></span><span>use</span><span> </span><span>oorandom</span><span>;</span><span></span>
<span>fn</span> <span>main</span><span>()</span><span> </span><span>{</span><span></span>
<span>    </span><span>let</span><span> </span><span>some_seed</span><span> </span><span>=</span><span> </span><span>4</span><span>;</span><span></span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>rng</span><span> </span><span>=</span><span> </span><span>oorandom</span>::<span>Rand32</span>::<span>new</span><span>(</span><span>some_seed</span><span>);</span><span></span>
<span>    </span><span>println!</span><span>(</span><span>&#34;Your random number is: {}&#34;</span><span>,</span><span> </span><span>rng</span><span>.</span><span>rand_float</span><span>());</span><span></span>
<span>}</span><span></span>
</pre></div>
<p>If you want a nondeterministic seed, I recommend using the <code>getrandom</code> crate to produce one.</p>
<h2 id="license"><a href="#license" rel="nofollow noopener">#</a>License</h2>
<p>MIT</p>
<h2 id="a-brief-history-of-random-numbers"><a href="#a-brief-history-of-random-numbers" rel="nofollow noopener">#</a>A brief history of random numbers</h2>
<p>The usefulness of random numbers has been known for a long, long time
to people who also knew how to use slide rules.  If you wanted to do
some math without the bother of coming up with all that pesky input
data from the real world, you might as well just use any ol&#39; random numbers,
as long as there weren&#39;t any patterns in them to heck up the patterns you were
trying to look at.  So in the first half
of the 20th century you had little old ladies named Edith spinning
roulette wheels or pulling bingo balls out of baskets and writing the
results down, which got assembled into giant tomes and published so
that engineering schools could buy them and have giant tomes sitting
on their shelves.  Anyone who wanted some meaningless numbers could
pull the tome down, flip it open to a presumably-random page, and
there were all the random numbers anyone could want.  The problem was
solved, and life was good.</p>
<p>In late 1940&#39;s computers were invented, but they were far too big and
expensive to be put on the task of <em>intentionally</em> generating
nonsense, and things carried on as before.  If you needed random
numbers in a computer program, you just got a pretty young lady named
Mary to transcribe part of the book to punch cards for you.</p>
<p>Around the early 1960&#39;s computers got fast enough that Edith and Mary
couldn&#39;t keep up with them, so they got downsized and replaced with
more computers.  To do this people came up with Linear Congruential
Generators (LCG&#39;s), which could generate lots of numbers numbers that
weren&#39;t really random, but sure looked random.  LCG&#39;s worked well on
computers that even a second-rate university could afford, and so the
problem was solved, and life was good.</p>
<p>At some unknown point in here, presumably sometime in the 60&#39;s or 70&#39;s,
someone seems to have invented Linear Feedback Shift Registers (LFSR&#39;s)
as well.  These made random-looking numbers and were really easy to
implement in hardware compared to the LCG, which needed to do
complicated things like multiply numbers.  The random-looking numbers
made by LFSR&#39;s were good enough for hardware people, so they started
using LFSR&#39;s whenever they needed to and never looked back.</p>
<p>Anyway, by the late 60&#39;s people who knew how to use slide rules had
realized that using numbers that only <em>looked</em> random could really heck
up their math pretty bad, and one of the more common LCG implmentations,
RANDU, was actually about as bad as possible.  So, just using any old
LCG wasn&#39;t good enough, you had to use one made by someone with a PhD in
mathematics.  Donald Knuth shook his fist at the world and shouted &#34;Hah!
I told you so!&#34;, published a book on how to do it Right that most people
didn&#39;t read, and then went back into his Fortress of Solitude to write
TeX.  Because it was created by IBM, RANDU&#39;s awfulness is now enshrined
forever in history documents like this one, and because the people
writing OS&#39;s and programming languages at the time weren&#39;t actually
doing much slide-rule stuff anymore and didn&#39;t actually <em>need</em> very good
random-looking numbers, everyone went back to using whatever old crap
RNG they were using anyway.  The problem was solved, or at least not
terribly problematic, and life was good.</p>
<p>Also, sometime in the 70&#39;s or 80&#39;s the arts of cryptography started
leaking from classified government works into the real world.  People
started thinking about how much money they could make from scrambling
satellite TV so that plebs with HAM radio licenses couldn&#39;t watch it,
and these people started giving more money to people who had PhD&#39;s in
mathematics to figure out how to make this work.  It was quickly
determined that neither LCG&#39;s nor LFSR&#39;s made numbers that were
random-looking enough to really get in the way of someone who knew how
to use a slide rule, and since Edith had long ago retired to a small
beach house in New Jersey, they needed to figure out how to get
computers to make better random-looking numbers.  But making numbers
look random enough that someone couldn&#39;t undo the process and get free
pay-per-view was slow and involved lots of details that nobody else
really cared about, so that topic went off on its own adventures and
will not be further mentioned.</p>
<p>Things more or less trundled along this way until the late 90&#39;s, when
suddenly computers were everywhere and there was a new generation of
people who had grown up too late to know how to use slide rules, so they
did all their math with computers.  They were doing a LOT of math by
now, and they looked around and realized that their random-looking
numbers really weren&#39;t very random-looking at all, and this was actually
something of a problem by now.  So the Mersenne Twister got invented.
It was pretty slow and used a lot of memory and made kinda mediocre
random numbers, but it was way better than a bad LCG, and most
importantly, it had a cool name. Most people didn&#39;t want to read Knuth&#39;s
book and figure out how to make a non-bad LCG, so everyone started using
the Mersenne Twister whenever possible.  The problem was solved, and
life was good.</p>
<p>This is where things stood until the early 2010&#39;s, when I finished my MS
and started paying attention again.  People suddenly realized it was
possible to make random-looking numbers better than the Mersenne Twister
using an algorithm called xorshift.  Xorshift was fast, it made good
pretty random-looking numbers, and it didn&#39;t need a whole 3 kilobytes of
state just sitting around taking up space and causing comment among the
neighbors at church.  It did sometimes have problems with some of its
numbers not looking random enough in a few select circumstances, but
people were gun-shy about their randomness by now so a few people with
PhD&#39;s in mathematics slowly and patiently spent years figuring out ways
to work around these problems, leading to a whole confusing family of
related things such as xoshiro, xoroshiro, xoroshiro+, xoroshiro*, and
so on.  Nobody else could really tell the difference between them, but
everyone agreed they were better than Mersenne Twister, easier to
implement, and the name was nearly as cool.  Many papers were published,
the problem was solved, and life was good.</p>
<p>However, at about the same time some bright young spark figured out that
it actually wasn&#39;t too hard, if you read Knuth&#39;s book and thought real
hard about what you were doing, to take the old LCG and hop it up on
cocaine and moon juice.  The result got called the Permuted Congruential
Generator, or PCG.  This quite miffed the people working on xorshift
generators by being almost as small and fast, and producing
random-looking numbers that satisfied even the people who had learned to
use slide rules for fun in this latter age.  It also used  xor&#39;s and bit
shifts, and that&#39;s xorshift&#39;s turf, dammit, it&#39;s right in the name!
Since nobody had figured out any downsides to PCG&#39;s yet, everyone
shrugged and said &#34;might as well just go with that then&#34;, and that is
where, as of 2019, the art currently stands.  The problem is solved, and
life is good.</p>
</div>
</div>
</div>
</div></div>
  </body>
</html>
