<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.reverberate.org/2025/02/10/tail-call-updates.html">Original</a>
    <h1>A Tail Calling Interpreter for Python (already landed in CPython)</h1>
    
    <div id="readability-page-1" class="page"><div>
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>It’s been nearly four years since I published <a href="https://blog.reverberate.org/2021/04/21/musttail-efficient-interpreters.html">Parsing Protobuf at 2+GB/s: How
I Learned To Love Tail Calls in
C</a>.
In that article, I presented a technique I co-developed for how to write really
fast interpreters through the use of tail calls and the <code>musttail</code> attribute.</p>

<p>While the article focused on Protocol Buffer parsers, the technique applies to
many kinds of parsers and VM interpreters.  I published the article in the
hopes that the technique would catch on and be adopted in other projects.</p>

<p>In the time since that article was published, there have been many exciting
developments in this space.  I want to take this opportunity to share some
updates.</p>



<p>I recently learned that a tail calling interpreter was going through <a href="https://github.com/python/cpython/issues/128563">PR review
on GitHub</a>.  Authored by <a href="https://x.com/kenjin4096/status/1887935698906529903">Ken
Jin as part of his Bachelor’s
theses</a>, it uses the
techniques described in my article and claims a 9-15% improvement geomean
improvement on <a href="https://github.com/python/pyperformance">pyperformance</a>, the
official Python
benchmark suite.</p>

<p>Last Friday that interpreter <a href="https://github.com/python/cpython/commit/cb640b659e14cb0a05767054f95a9d25787b472d">was
merged</a>,
and it is officially slated to be released in Python 3.14 (<a href="https://docs.python.org/3.14/whatsnew/3.14.html#whatsnew314-tail-call">release
notes</a>).</p>

<p>Note that the tail call interpreter is not the default yet.  It has to be enabled
at configuration time with <a href="https://docs.python.org/3.14/using/configure.html#cmdoption-with-tail-call-interp"><code>--with-tail-call-interp</code></a>.  Hopefully it will be the default in a future release.</p>

<p>I’m very excited to see this development.  In my original article, I made the
following prediction:</p>

<blockquote>
  <p>I think it’s likely that all of the major language interpreters written in C
(Python, Ruby, PHP, Lua, etc.) could get significant performance benefits by
adopting this technique.</p>
</blockquote>

<p>I’m happy to see that this seems to have come true for Python.  Congratulations
to Ken on this accomplishment.</p>



<p>In 2022-2024, Haoran Xu published a series of
<a href="https://sillycross.github.io/2022/11/22/2022-11-22/">articles</a> and
<a href="https://arxiv.org/abs/2411.11469">papers</a> about an ambitious and experimental
effort to automatically generate interpreters and JIT compilers from a
description of the language semantics.  This project is called
<a href="https://arxiv.org/abs/2411.11469">Deegen</a>, and Haoran used it to build <a href="https://github.com/luajit-remake/luajit-remake">LuaJIT
Remake</a>, an experimental
reimplementation of the famous <a href="https://luajit.org/">LuaJIT</a>.</p>

<p>Deegen uses the tail call pattern for its interpreters, arguing that <a href="https://sillycross.github.io/2022/11/22/2022-11-22/#Why-Assembly-After-All">this the
best way to get the compiler to generate good
code</a>.
This conclusion aligns with my 2021 article, and his analysis cites my work.</p>

<p>However, he concludes that C and C++ cannot achieve optimal performance for
tail calling interpreters because of limitations in the calling convention.
The main problem he cites is around callee-save registers, and how the C
calling convention forces all functions to preserve six registers, a steep cost
given how small these functions tend to be.</p>

<p>He also mentions the restrictions on <code>[[clang::musttail]]</code>, particularly on how
the caller and callee must have matching function signatures, which can be
inconvenient.  As a result, Deegen targets LLVM IR instead of C or C++.</p>

<p>The first issue has been largely addressed by the <code>preserve_none</code> attribute
(discussed below).  Promising developments are also occurring regarding the
second complaint, as detailed below in the “Nonportable Musttail” section.</p>

<p>LuaJIT Remake’s interpreter claims a 31% performance advantage over LuaJIT 2.1,
an impressive result given that LuaJIT already has one of the fastest
interpreters of any mainstream programming language.  It is still an
experimental project (for example, garbage collection is unimplemented, so the
performance comparison disables GC for LuaJIT too); it would be cool if Deegen
or something like it was eventually productionized and used in a mainstream
language interpreter.  Congratulations to Haoran on this accomplishment.</p>



<p>When I published my original article, GCC had no support for musttail.  I
<a href="https://gcc.gnu.org/pipermail/gcc/2021-April/235882.html">floated the idea of adding <code>musttail</code> to the GCC maintainers in
2021</a>, which
generated some interesting discussion, but no clear plan.</p>

<p>I’m happy to report that this <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=83324#c4">received renewed attention since
then</a>.  GCC added
support for a <code>musttail</code> attribute <a href="https://gcc.gnu.org/git/gitweb.cgi?p=gcc.git;h=7db47f7b915c5f5d645fa536547e26b92290afe3">in
C</a>
and <a href="https://gcc.gnu.org/git/gitweb.cgi?p=gcc.git;h=59dd1d7ab21ad9a7ebf641ec9aeea609c003ad2f">in
C++</a>
in July of 2024.  Thanks to the GCC team for this work.</p>

<p>GCC appears to be more strict than Clang in analyzing whether any pointers to
locals are referenced across the tail call.  I posted <a href="https://github.com/llvm/llvm-project/issues/72555#issuecomment-2644233781">some analysis of this
issue</a>
in the Clang bug tracker.</p>



<p>I recently heard that there is a proposal to add guaranteed tail calls to the C
standard as <code>return goto</code>.  The proposal is given in
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3266.htm#user-content-5-tail-call-elimination">n3266</a>.
The proposed syntax is:</p>

<div><div><pre><code><span>int</span> <span>a</span> <span>(</span><span>int</span><span>,</span> <span>int</span><span>);</span>

<span>int</span> <span>b</span> <span>(</span><span>int</span> <span>x</span><span>,</span> <span>int</span> <span>y</span><span>)</span> <span>{</span>
    <span>return</span> <span>goto</span> <span>a</span> <span>(</span><span>y</span><span>,</span> <span>x</span><span>);</span>  <span>// Proposed syntax.</span>
<span>}</span>
</code></pre></div></div>

<p>It’s very exciting to think that guaranteed tail calls might eventually be added
to standard C.  It is unclear whether it will be included in C2Y, but I am hopeful.</p>

<p>The rationale given in
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2920.pdf">n2920</a> does not
mention the use case of tail call interpreters, even though this was the
primary motivation for adding <code>musttail</code> to both Clang and GCC.  The use case
envisioned by the committee is that C is being used as a code generation target
for a language like Scheme that guarantees tail call optimization.  The
document goes so far as to say they do not expect the feature to see
significant use in user-written C code.</p>

<p>But even though they are not designing for the interpreter use case, the
proposed feature looks like a perfect fit for tail calling interpreters, so I’m
happy for that.</p>

<p>Interestingly, the proposed C standard is more lax than <code>[[clang::musttail]]</code>
about whether the caller and callee have to match in argument types.  For
various ABI reasons, some calls are impossible to tail call optimize.  Clang
enforces a set of rules that are intended to be “portable”, so that the
tail call can be performed on “any” architecture:</p>

<div><div><pre><code><span>int</span> <span>g</span><span>();</span>

<span>// Valid according to the proposed standard C feature,</span>
<span>// but the implementation is allowed to fail if this</span>
<span>// cannot be tail-call optimized for an implementation-specific</span>
<span>// reason.</span>
<span>int</span> <span>f</span><span>(</span><span>int</span> <span>x</span><span>)</span> <span>{</span> <span>return</span> <span>goto</span> <span>g</span><span>();</span> <span>}</span>

<span>// Always rejected by Clang currently, because the caller</span>
<span>// and callee do not perfectly match in function signature.</span>
<span>// This is rejected even if the implementation is capable of</span>
<span>// tail call optimizing the call, because Clang is trying to</span>
<span>// provide a &#34;portable&#34; guarantee:</span>
<span>int</span> <span>f</span><span>(</span><span>int</span> <span>x</span><span>)</span> <span>{</span> <span>[[</span><span>clang</span><span>::</span><span>musttail</span><span>]]</span> <span>return</span> <span>g</span><span>();</span> <span>}</span>
</code></pre></div></div>

<p>I think the standard is making a good call here.  Clang attempts to ensure
“portable” tail calls, but in retrospect, I believe this approach has
limitations.  We will discuss this further in the next section.</p>



<p>When I implemented <code>[[clang::musttail]]</code> in Clang, it merely exposed to C and
C++ some functionality that already existed in the LLVM backend.  The
<a href="https://llvm.org/docs/LangRef.html#id332"><code>musttail</code> attribute for LLVM</a> had
been added years earlier, and it already had a set of semantics which dictated
many things.  In particular, it dictated that the caller and callee prototypes
must match.</p>

<p>This disallowed code like the following, even though this can be successfully
tail call optimized on many platforms:</p>

<div><div><pre><code><span>int</span> <span>g</span><span>();</span>

<span>// Always rejected by Clang currently, because the caller</span>
<span>// and callee do not perfectly match in function signature.</span>
<span>// This is rejected even if the implementation is capable of</span>
<span>// tail call optimizing the call, because Clang is trying to</span>
<span>// provide a &#34;portable&#34; guarantee:</span>
<span>int</span> <span>f</span><span>(</span><span>int</span> <span>x</span><span>)</span> <span>{</span> <span>[[</span><span>clang</span><span>::</span><span>musttail</span><span>]]</span> <span>return</span> <span>g</span><span>();</span> <span>}</span>
</code></pre></div></div>

<p>To follow LLVM’s rules, we had to make Clang reject this code.</p>

<p>In theory, we are trading off flexibility for predictability.  Even though
<em>some</em> platforms are able to tail-call-optimize code like the above, some are
not, and it would be surprising if your program worked fine on some platforms
but failed to compile on others.  So we have a set of rules that, if followed,
should guarantee that the code can be tail call optimized on all platforms.</p>

<p>However, once the feature was launched, we started receiving <a href="https://github.com/llvm/llvm-project/issues/54964">complaints about
these rules</a>.  There were
two main complaints.  First, users were understandably frustrated that a tail
call would fail to compile on a platform where the tail call was totally
possible to optimize.  It seems a bit unhelpful for the compiler to reject your
program just because it <em>might</em> fail on a <em>different</em> platform.</p>

<p>Users also raised the point that this “guarantee” isn’t really a guarantee at
all.  Some platforms fundamentally do not support tail calls, like WASM without
the <a href="https://github.com/WebAssembly/tail-call/blob/main/proposals/tail-call/Overview.md">Tail Call
Extension</a>.</p>

<p>What this means is that the predictability that Clang/LLVM are trying to
provide is fundamentally impossible.  We’ve traded off flexibility, but we
didn’t even get predictability in return.</p>

<p>In response, users have proposed two possible resolutions:</p>

<ol>
  <li>We could relax <code>[[clang::musttail]]</code> so that it only fails if the tail call
is impossible on <em>this</em> platform.</li>
  <li>We could leave the <code>[[clang::musttail]]</code> attribute the way it is, and introduce
a new <code>[[clang::nonportable_musttail]]</code> which has the desired semantics.</li>
</ol>

<p>I believe option (1) is preferable, though I’m unable to implement it
currently. Hopefully, someone will address <a href="https://github.com/llvm/llvm-project/issues/54964">this
bug</a>. Since it requires
changes to both Clang and LLVM, it will be a more substantial undertaking than
my initial <code>[[clang::musttail]]</code> implementation. However, as it primarily
involves relaxing constraints, it should ultimately simplify the
implementation.</p>



<p>In the original article, I described some
<a href="https://blog.reverberate.org/2021/04/21/musttail-efficient-interpreters.html#limitations">limitations</a>
where the tail calling technique could result in really bad code.  In these
scenarios, you could get tons of register spills that were bad for performance
and code size.  At the time, there weren’t great options to mitigate these
problems except to contort the code to never make a non-tail call.</p>

<p>I am happy to report that this problem has been largely solved, at least in
Clang.  There are two calling conventions that can help.  <code>preserve_none</code>
optimizes the main interpreter functions that tail-call each other, while
<code>preserve_most</code> benefits functions called in non-tail positions.</p>

<div><div><pre><code><span>// preserve_none on tail calling functions optimizes register usage.</span>
<span>__attribute__</span><span>((</span><span>preserve_none</span><span>))</span> <span>const</span> <span>char</span> <span>*</span><span>Next</span><span>(</span><span>PARAMS</span><span>);</span>

<span>// preserve_most on non-tail-called functions can help optimize</span>
<span>// the caller.</span>
<span>//</span>
<span>// Caution: preserve_most adds overhead to the target function,</span>
<span>// and may not be worthwhile if the function is hot.</span>
<span>__attribute__</span><span>((</span><span>preserve_most</span><span>))</span> <span>const</span> <span>char</span> <span>*</span><span>RegularFunc</span><span>();</span>

<span>__attribute__</span><span>((</span><span>preserve_none</span><span>))</span> <span>const</span> <span>char</span> <span>*</span><span>Parse</span><span>(</span><span>PARAMS</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>!</span><span>ptr</span><span>)</span> <span>{</span>
    <span>ptr</span> <span>=</span> <span>RegularFunc</span><span>();</span>
  <span>}</span>
  <span>ptr</span><span>++</span><span>;</span>
  <span>__attribute__</span><span>((</span><span>musttail</span><span>))</span> <span>return</span> <span>Next</span><span>(</span><span>ARGS</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<h2 id="preserve_most">preserve_most</h2>

<p>If we use
<a href="https://clang.llvm.org/docs/AttributeReference.html#preserve-most"><code>__attribute__((preserve_most))</code></a>
on regular functions, it saves the caller from having to shuffle or spill any
of its registers prior to the call, which generally will make our tail calling
functions smaller and more efficient.</p>

<p>The <code>preserve_most</code> attribute existed when I wrote the original article, but I
noted that it seemed to cause unexplainable crashes.  This turned out to be a
bug in Clang, which was <a href="https://reviews.llvm.org/D141020">fixed in 2023</a>.</p>

<p>While <code>preserve_most</code> can theoretically solve the register shuffling/spilling
problem, it has a major weakness.  To get the desired effect, you have to apply
it to <em>all</em> functions that you call in non-tail position.  Whenever you are
modifying your interpreter, if you start calling a new function, you have to
add <code>preserve_most</code> to it.<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" rel="footnote">1</a></sup></p>

<p>But what if you are calling a standard library function like <code>strlen()</code>?  You
can’t modify the calling convention of a function you don’t own.  You would
have to create a separate wrapper function like <code>my_strlen()</code> and put
<code>preserve_most</code> on the wrapper.  If you don’t – if you forget this discipline
for even a single function – then you get these horrible pessimized prologues
and epilogues in the fast path.</p>

<p>While helpful, <code>preserve_most</code> introduces overhead to the target function
and should be used judiciously, particularly in hot code paths.</p>

<h2 id="preserve_none">preserve_none</h2>

<p>I had always felt that it was more promising to have a special calling
convention for the tail calling functions.  After all, they are all under our
control and they are “special” already: they all use a consistent set of
arguments, and we have to call them with the <code>musttail</code> attribute.</p>

<p>To pursue this opportunity, in 2021 I prototyped a <a href="https://github.com/haberman/llvm-project/commit/e8d9c75bb35ce9c802f8eac522a2c6ce003f857f">new calling convention I
called
<code>reverse_call</code></a>.
The calling convention was designed to be applied to the tail calling
functions, allowing us to get rid of all those gratuitous prologues and
epilogues.</p>

<p>The basic idea was to have no callee-saved registers, so our interpreter
functions are freed of the burden of preserving any registers.  And critically,
we also want our argument registers to be allocated in the opposite order from
a normal function (starting with callee-save registers, which are normally
never used as arguments at all).<sup id="fnref:0" role="doc-noteref"><a href="#fn:0" rel="footnote">2</a></sup>  The net effect is that when a
<code>reverse_call</code> function calls a normal function, the argument registers for
caller and callee do not overlap, and moreover the caller’s argument registers
will be preserved by the callee.  This allows the interpreter to keep its
arguments in registers across the call, without any register shuffling or
spilling required.  The results from my prototype were good, and I was pretty
excited about this idea.</p>

<p>While my initial <code>reverse_call</code> proposal didn’t gain traction, <a href="https://discourse.llvm.org/t/rfc-exposing-ghccc-calling-convention-as-preserve-none-to-clang/74233">subsequent
discussions on Clang mailing
list</a>
led to the <code>preserve_none</code> convention, addressing the same issue.
Implementations <a href="https://github.com/llvm/llvm-project/pull/76868">for x86</a>  and
<a href="https://github.com/llvm/llvm-project/issues/87423">for aarch64</a> landed in
Clang 19.1.0, though I haven’t found a corresponding release note for them.</p>

<p>Shortly after, another LLVM contributor re-discovered my idea of <a href="https://github.com/llvm/llvm-project/pull/76868#issuecomment-2035874303">assigning
arguments to registers starting with the normally callee-save
registers</a>,
and created <a href="https://github.com/llvm/llvm-project/pull/88333">a PR to implement
it</a>.  So in the end, the
<a href="https://clang.llvm.org/docs/AttributeReference.html#preserve-none"><code>preserve_none</code> convention in
Clang</a>
turned out to be almost exactly what I had envisioned with <code>reverse_call</code>.
Thanks to all of the Clang contributors who made this happen.</p>

<div><div><pre><code><span>// Uses preserve_none (landed in Clang in 19.1.0).</span>

<span>#define CC __attribute__((preserve_none))
</span>
<span>CC</span> <span>const</span> <span>char</span> <span>*</span><span>Next</span><span>(</span><span>PARAMS</span><span>);</span>
<span>const</span> <span>char</span> <span>*</span><span>Fallback</span><span>(</span><span>PARAMS</span><span>);</span>

<span>CC</span> <span>const</span> <span>char</span> <span>*</span><span>Parse</span><span>(</span><span>PARAMS</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>!</span><span>ptr</span><span>)</span> <span>{</span>
    <span>ptr</span> <span>=</span> <span>Fallback</span><span>(</span><span>ARGS</span><span>);</span>
  <span>}</span>
  <span>ptr</span><span>++</span><span>;</span>
  <span>__attribute__</span><span>((</span><span>musttail</span><span>))</span> <span>return</span> <span>Next</span><span>(</span><span>ARGS</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>The Python tail call interpreter uses <code>preserve_none</code>, and I think that all
tail call interpreters would benefit from doing the same.</p>



<p>All of these developments have been exciting to see.  I hope that in several
more years, we’ll see more progress towards standardizing <code>musttail</code> into
<code>return goto</code>, more support for <code>preserve_none</code> across compilers, and hopefully
even more programming language interpreters will adopt the technique.</p>


  </div>

</article>

      </div>
    </div></div>
  </body>
</html>
