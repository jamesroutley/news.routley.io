<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://spritely.institute/news/scheme-to-wasm-lambdas-recursion.html">Original</a>
    <h1>Directly compiling Scheme to WebAssembly: lambdas, recursion, iteration</h1>
    
    <div id="readability-page-1" class="page"><div><p><img src="https://spritely.institute/static/images/blog/hoot-fib.png" alt="Hoot logo in recursive fib style"/></p><p>It&#39;s been just over three months since we
<a href="https://spritely.institute/news/guile-on-web-assembly-project-underway.html">announced the Guile on WebAssembly project</a>
(codenamed <a href="https://gitlab.com/spritely/guile-hoot">Hoot</a>).
Since then we&#39;ve brought on two
<a href="https://spritely.institute/news/andy-wingo-leads-g2W.html">fantastic</a>
<a href="https://spritely.institute/news/robin-templeton-joins.html">hackers</a>
to develop the project and progress has been quick.</p><p>We now are at the point where we have things to show: we can now
compile various Scheme procedures <em>directly to WebAssembly.</em>
Let&#39;s clarify that: by compiling directly to WebAssembly, we mean they
compile and run <em>without any intermediate virtual machine.</em>
No C, no Rust, no Zig: Hoot outputs pure WebAssembly.
It&#39;s early, but Hoot compiled programs are starting to work...
and they&#39;re fast!</p><h2>Hoot by familiar Scheme examples</h2><p>The Hoot test suite
<a href="https://gitlab.com/spritely/guile-hoot/-/blob/main/test/test-constants.scm">includes some examples</a>
of fairly standard scheme procedures, compiled directly to WebAssembly
and executed against V8.
Let&#39;s take a look at some of those examples to contextualize what Hoot
provides.
(If you&#39;re not familiar with Scheme, you can focus on the text of this
blogpost rather than the code.
Or, you can read our <a href="https://spritely.institute/static/papers/scheme-primer.html">Scheme Primer</a>
as a way to get started on following along!)</p><p>Here&#39;s an all time favorite intro-to-Scheme example
(one of the <a href="https://sarabander.github.io/sicp/html/1_002e2.xhtml#g_t1_002e2_002e1">first examples in SICP</a>):</p><pre><code><span>(</span><span>test-call</span> <span>&#34;120&#34;</span>                                    <span>(</span><span>lambda</span> <span>(</span><span>n</span><span>)</span>                                <span>(</span><span>let</span> <span>fac</span> <span>(</span><span>(</span><span>n</span> <span>n</span><span>)</span><span>)</span>                           <span>(</span><span>if</span> <span>(</span><span>eq?</span> <span>n</span> <span>0</span><span>)</span>                                <span>1</span>                                        <span>(</span><span>*</span> <span>n</span> <span>(</span><span>fac</span> <span>(</span><span>1-</span> <span>n</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>            <span>5</span><span>)</span>                            </code></pre><p><code>test-call</code> takes two or more arguments: the value we expect to see V8
spit out from running the compiled WebAssembly code, a procedure we
want to test, and any more arguments are arguments to the function.</p><p>Hoot is compiling this program to WebAssembly directly.    Astoundingly, at the time of writing, the
size of the compiled WebAssembly program is <em>only 970 bytes</em>... less
than a kilobyte!  (Did you gasp?)</p><p>Other familiar intro-to-computer-science friends are also now available.
Who doesn&#39;t love the Fibonacci function?</p><pre><code><span>(</span><span>test-call</span> <span>&#34;9227465&#34;</span>                                <span>(</span><span>lambda</span> <span>(</span><span>n</span><span>)</span>                                <span>(</span><span>let</span> <span>fib</span> <span>(</span><span>(</span><span>n</span> <span>n</span><span>)</span><span>)</span>                           <span>(</span><span>if</span> <span>(</span><span>&lt;=</span> <span>n</span> <span>1</span><span>)</span>                                 <span>1</span>                                        <span>(</span><span>+</span> <span>(</span><span>fib</span> <span>(</span><span>-</span> <span>n</span> <span>1</span><span>)</span><span>)</span>                            <span>(</span><span>fib</span> <span>(</span><span>-</span> <span>n</span> <span>2</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>             <span>34</span><span>)</span>                           </code></pre><p>Now the astute reader may be looking at the above two functions and
observing that these are <em>recursive procedures!</em>
Yes, recursion is all fine and well in the land of Scheme, and it&#39;s
all fine and well in the land of Hoot, too.</p><p>Of course, the astute reader will <em>also</em> recognize that neither of
these is the most efficient way to implement either of these
functions: both grow more memory than necessary.
It&#39;s great that we <em>can</em> recurse, but <em>should we</em> recurse?</p><p>Well, it turns out that iteration can be defined in terms of recursion.
If a procedure doesn&#39;t need to do any more work, there&#39;s no need to
keep it on the stack anymore.
And if a procedure doesn&#39;t need to do any more work <em>and</em> it&#39;s just
calling itself, Scheme implementations are historically especially
smart about this, because we can just reuse the same procedure where
it was!</p><p>Which means, here&#39;s a very terse looking loop which <em>looks</em> kinda
recursive but in terms of computational work is merely iterative:</p><pre><code><span>(</span><span>test-call</span> <span>&#34;500000000&#34;</span>                              <span>(</span><span>lambda</span> <span>(</span><span>)</span>
             <span>(</span><span>let</span> <span>loop</span> <span>(</span><span>(</span><span>n</span> <span>0</span><span>)</span><span>)</span>                          <span>(</span><span>if</span> <span>(</span><span>&lt;</span> <span>n</span> <span>500000000</span><span>)</span>                          <span>(</span><span>loop</span> <span>(</span><span>1+</span> <span>n</span><span>)</span><span>)</span>                            <span>n</span><span>)</span><span>)</span><span>)</span><span>)</span>                 </code></pre><p>Once again, this program is less than 1 kilobyte when compiled, and
carries with it everything a Hoot-compiled program needs to execute.
That&#39;s cheap in terms of file size.
But how fast is it?</p><p>Well consider that Guile is
<a href="https://ecraven.github.io/r7rs-benchmarks/">actually fairly speedy</a>.
It&#39;s not the fastest Scheme out there (their role in programming
language research means that Schemes are a well trodden territory for
optimizing languages), but it&#39;s quite fast.
Shockingly then, the Hoot-compiled WebAssembly for the above executes,
on local tests, is <em>five times faster than native Guile!</em></p><p>Of course, looping over addition is a very limited benchmark.
Still, we&#39;re happy for this early indicator that Scheme to WebAssembly
is likely to be very performant.</p><h2>Hoot is also a mini WebAssembly toolkit!</h2><p>One of the interesting aspects of Hoot is that it takes advantage of
<a href="https://www.gnu.org/software/guile/manual/html_node/Compiler-Tower.html">Guile&#39;s compiler tower</a>.
Hoot is able to use all the optimizations that Guile already provides,
because <a href="https://gitlab.com/spritely/guile-hoot/-/blob/main/module/hoot/compile.scm">Hoot&#39;s compiler</a>
transforms Scheme code from Guile&#39;s
<a href="https://www.gnu.org/software/guile/manual/html_node/CPS-Soup.html">CPS Soup</a>
intermediate language directly to WebAssembly.</p><p>(Guile&#39;s compiler tower has some limited support for other toplevel languages
which are not Scheme; this also means that those too can compile directly
to WebAssembly.)</p><p>One nice aspect of WebAssembly is that its textual representation is
already very lispy, using parenthetical s-expression notation.
This means that WebAssembly is already ripe territory for lispers to
embrace, and Hoot has done just that.</p><p>Rather than use external tooling like
<a href="https://github.com/WebAssembly/binaryen">binaryen</a>
or <a href="https://github.com/WebAssembly/wabt">wabt</a>, Hoot provides its own suite
of tools for
<a href="https://gitlab.com/spritely/guile-hoot/-/blob/main/module/wasm/parse.scm">parsing</a>,
<a href="https://gitlab.com/spritely/guile-hoot/-/blob/main/module/wasm/assemble.scm">assembling</a>,
<a href="https://gitlab.com/spritely/guile-hoot/-/blob/main/module/wasm/disassemble.scm">disassembling</a>,
and <a href="https://gitlab.com/spritely/guile-hoot/-/blob/main/module/wasm/dump.scm">dumping</a>
WebAssembly directly.
This means Hoot isn&#39;t just useful as a way of compiling Scheme to WebAssembly,
it&#39;s a useful WebAssembly toolkit in and of itself!</p><h2>What Hoot means for other languages</h2><p>For a long time, programmers were given one real option to program in web
browsers: Javascript.
WebAssembly&#39;s initial introduction has provided a ripe ground for several
other non-garbage-collected languages to enter the space, such as C, C++, Rust,
and Zig.</p><p>But there is a large and beautiful array of programming languages available
to programmers in the world.
Many of those languages have been given less than ideal paths to
participating on the web.
Compiling an entire language environment or virtual machine to WebAssembly
is perhaps better than transpiling to Javascript, but it is still an
expensive operation.</p><p>This blogpost has primarily been centered around Scheme
(Spritely&#39;s core tooling is written in Guile Scheme, and Hoot is a project
to compile Scheme to WebAssembly, so this isn&#39;t too surprising).
But the Spritely Institute is just that, a research institution.
Hoot is breaking ground in some new spaces in WebAssembly land (and we are
participating in the WebAssembly standards processes accordingly).</p><p>The web should be for everyone.
We hope Hoot paves a path so that more languages may enter the web, including
Python, Lua, Haskell, ML, and friends.</p><h2>What Hoot means for Spritely</h2><p>We showed some exciting demos in this blogpost, but it remains true that
Hoot is still early.
Some Scheme simple procedures can compile, but we have a ways to go.
But we are on track, and the future looks bright.
Hoot has been made possible due to a generous grant from
<a href="https://consensys.net/">Consensys</a>/<a href="https://metamask.io/">Metamask</a>.
This grant was given was a knowingly ambitious project; we are grateful
for their support and are excited to be delivering towards those goals.</p><p>On the immediate roadmap is the compilation of the Scheme standard
<a href="https://small.r7rs.org/">r7rs-small</a>, with the goal to get Hoot compiled
programs to appear on the <a href="https://ecraven.github.io/r7rs-benchmarks/">r7rs benchmarks</a>
page.
After that, it&#39;s onto getting <a href="https://spritely.institute/goblins/">Goblins itself</a>
to run in the browser and in the (increasingly) many places WebAssembly
is supported.
We are excited to have an optimistic path to get Spritely&#39;s tooling in the
hands of as many users as possible.</p><p>We look forward to delivering more updates about Hoot as the project
progresses.
The future of WebAssembly (and Spritely) is bright!</p></div></div>
  </body>
</html>
