<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.gtf.io/musings/why-haskell">Original</a>
    <h1>Why Haskell?</h1>
    
    <div id="readability-page-1" class="page"><div><p data-pos="3:1-10:0">“Impractical”, “academic”, “niche”. These are a few of the reactions I get when someone discovers that my favourite programming language is Haskell, and not only my favourite in some sort of intellectually-masturbatory way, but favourite for building things, real things, mostly involving web servers. Hobby projects would be one thing, but it gets worse: I have actual teams at <a href="https://www.converge.io">Converge</a> working in Haskell, too.</p>
<p data-pos="11:1-20:0">I find this reaction quite curious: not only can any problem suitable to one general-purpose programming language be tackled in another, but a lot of the new features we see making their way into programming languages like Python, Rust, and Typescript, are either inspired by, or at least more robustly implemented in, Haskell. It seems to me that part of this response is a version of “choose boring technology” (although Haskell is far older than most of the most popular programming languages) twisted to suit another pernicious ideology: that programming is not maths, and that anything that smells of maths should be excised.</p>
<p data-pos="21:1-26:0">This comes up in all sorts of unlikely places in which it would be quite awkward to have to take my interlocutors through all the reasons I think Haskell is probably the best choice for whatever computational problems they are trying to solve themselves (e.g. dinner parties, the pub, etc.) and thus I find myself writing this apologia.</p>
<p data-pos="27:1-33:0">Indeed the remainder of this essay will consist of my attempt to reason around why I think Haskell is probably the best choice<a id="fnref1" href="#fn1" role="doc-noteref"><sup>1</sup></a> for most programmers<a id="fnref2" href="#fn2" role="doc-noteref"><sup>2</sup></a>, especially if one cares about being able to productively write robust software, and even more so if one wants to have fun while doing it (which is a frequently underrated aspect of writing software).</p>
<p data-pos="34:1-41:0">All mainstream, general purpose programming languages are (basically) Turing-complete, and therefore any programme you can write in one you can, in fact, write in another. There is a computational equivalence between them. The main differences are instead in the expressiveness of the languages, the guardrails they give you, and their performance characteristics (although this is possibly more of a runtime/compiler implementation question).</p>
<p data-pos="42:1-46:0">I think that the things that make Haskell great (meaning both more productive and more fun) can be grouped as follows: the things that stop you making mistakes; the things that make you more productive; and the things that help you reason better about your programmes.</p>
<section data-pos="47:1-101:0" id="Unlearning-and-relearning">
<h2 data-pos="47:1-48:0">Unlearning and relearning</h2>
<p data-pos="49:1-57:0">The first thing to say here is that most programmers in the 2020s have been brought up in some sort of imperative<a id="fnref3" href="#fn3" role="doc-noteref"><sup>3</sup></a> paradigm. As a result, the learning curve for a pure, functional language like Haskell will be steep. There are two aspects to this: one is the Haskell language <em>itself</em> which, if you constrain yourself to a simple subset of it, is actually quite easy to learn; and the second is functional programming, which requires a total shift in how the programmer approaches constructing a programme.</p>
<p data-pos="58:1-61:0">This process of unlearning and relearning is incredibly helpful and will make one a better programmer, regardless as to whether one uses Haskell thenceforth. As Alan Perlis writes:</p>
<blockquote data-pos="62:1-64:30">
<p data-pos="62:3-64:30">A language that doesn’t affect the way you think about programming is not worth knowing. ~ Perlisism #19 <a id="fnref4" href="#fn4" role="doc-noteref"><sup>4</sup></a></p>
</blockquote>
<section data-pos="66:1-101:0" id="A-small-note-on-syntax">
<h3 data-pos="66:1-67:0">A small note on syntax</h3>
<p data-pos="68:1-71:0">In the subsequent sections there will be simple snippets of Haskell. Since the syntax is quite distant from C-like syntax with which many readers will be familiar, here is a small guide:</p>
<ul data-pos="72:1-98:0">
<li>
<code>::</code> denotes a type signature (so <code>myThing :: String</code> says I have a name “myThing” and its value is of type <code>String</code>).
</li>
<li>
function calls do not use parentheses, you simply put the arguments, space-separated, after the function name. There are good reasons for this, but they’re beyond the scope of this explainer (so where in one language you may have <code>doSomething(withThis, withThat)</code> in Haskell you have <code>doSomething withThis withThat</code>).
</li>
<li>
lower-case letters in type-signatures are type-variables, and just represent any type (so <code>head :: [a] -&gt; a</code> just takes a list of any type <code>a</code> and returns a single value of the same type <code>a</code>).
</li>
<li>
you will see two types of “forward” arrows: <code>-&gt;</code> and <code>=&gt;</code>. A single arrow <code>-&gt;</code> is used to describe the type of a function: <code>add1 :: Int -&gt;
Int</code> describes a function which takes an integer and returns an integer. A double arrow <code>=&gt;</code> describes constraints on the type variables used, and always come first: <code>add1 :: Num a =&gt; a -&gt; a</code> describes a function which takes any type <code>a</code> which satisfies <code>Num a</code>, and returns a value of the same type.
</li>
<li>
comments start with <code>--</code>.
</li>
<li>
<code>return</code> does not mean what you think it means, it’s just a regular function.
</li>
<li>
<code>do</code> is syntactic sugar allowing you to write things that “look” imperative.
</li>
<li>
There are various ways of assigning values to local names (“variables”) which differ depending on the context. So you can recognise them they either take the form <code>let x = &lt;something&gt; in
&lt;expression&gt;</code> or <code>x &lt;- &lt;something&gt;</code>.
</li>
</ul>
<p data-pos="98:1-101:0">Otherwise the syntax should be fairly easy to parse, if not for a detailed understanding of every aspect, at least to a sufficient level to get the gist of what I am trying to convey.</p>
</section>
</section>
<section data-pos="102:1-611:0" id="Make-fewer-mistakes">
<h2 data-pos="102:1-103:0">Make fewer mistakes</h2>
<p data-pos="104:1-108:0">In many languages, the way one tries to make sure one’s code is “correct” (or, at least, will do the right thing in most circumstances) is through a large number of test cases, some of which may be automated, and some of which may be manual.</p>
<p data-pos="109:1-112:0">Two aspects of Haskell drastically reduce the test-case-writing burden typical in other languages: one is the type system and the other is pure functional programming.</p>
<p data-pos="113:1-121:0">Haskell’s type system is <em>very</em> strong, which is to say that it makes very specific guarantees about the programme, and enforces those guarantees very strictly. The concomitant expressiveness of the language gives the programmer the tools to more precisely and simply express the <em>meaning</em> of the programme within its domain, as well as the general domain of programming. These two properties of the type system, together, reduce the space of possible mistakes, resulting in a more correct programme with much less effort.</p>
<p data-pos="122:1-127:0">So far, so abstract. Some concrete features of the type system that reduce the “error surface” of your programme are: no nullable types; the ability to represent “failable” computations; pattern matching and completeness checks; and the avoidance of “primitive obsession” for free. Let’s take a look at each of those.</p>
<p data-pos="128:1-146:0">The availability of a <code>null</code> (or <code>nil</code> or <code>none</code>) value which can inhabit any (or the majority) of types in a language is often viewed as a convenience, but in practice it has a huge cost. In a language in which one can use such null values, the programmer can never know if the value they are handling is actually of the expected type or if it is null, and therefore is required to check wherever this value is consumed. Programmers can forget things, and the fact that the null value can inhabit many types means that the type system does not help prevent this, leading to errors of the sort “undefined is not a function” or “NoneType object has no attribute &lt;x&gt;”. These, however, are runtime errors, which both means that the programme has failed in its principal task and also that the errors are harder to find as they occur in the wild. Haskell does not have null values. You can define them in a particular data type (for example the <code>Maybe</code> type, which we will come onto shortly) but you have to explicitly define them and explicitly handle them. As such, the error surface available due to this flaw in language design is eliminated, and the programmer no longer has to think about it.</p>
<p data-pos="147:1-163:0">Null values, however, are often used to represent a “failed” computation. For example, what if you are getting the head of an empty list, how do you represent the result? In languages with null values, such functions will often return <code>null</code> in these circumstances. This is a specific case of the more general question of how to deal with computations which may fail. There are many examples: if you are parsing some user input and that input is malformed, this failure to parse is a valid state of your programme, and therefore you need some way to represent it. Similarly, network requests may time out, solvers may fail to find a solution, users may cancel actions, and so on. There are two common solutions, null values (which we have mentioned) and exception handling. Both of these solutions cause a new problem for the programmer: you have to remember to handle them, in the case of exceptions at the call site rather than where you consume the value as with null, and nothing in the type system is going to prevent you forgetting.</p>
<p data-pos="164:1-175:0">Haskell solves the problem of the representation of computations which may fail very differently: explicitly through the type system. There are types in Haskell to represent a computation which may fail, and because this is done in the type system, these are first-class entities and you can pass around your computation-result-which-may-or-may-not-be-a-failure as you like. When it comes to consuming the result of that computation, the type system forces you to reckon with the fact that there may be no result. This prevents a whole class of runtime errors without the mental burden of keeping track of values which may be present or which functions might throw an exception somewhere.</p>
<p data-pos="176:1-183:0">The two most common of these types are <code>Maybe</code> and <code>Either</code>. <code>Maybe</code> represents a computation which may or may not have a result. For example, if you want to get the first element of a list, but you do not know if the list is empty, then you may want to specify that your <code>head</code> function can return either a result or <code>Nothing</code>. Unlike null values, however, you cannot just pretend that the function must have returned a result, as the following snippet should demonstrate:</p>
<pre data-pos="184:1-210:3"><code>safeHead :: [a] -&gt; Maybe a
-- the implementation isn&#39;t important here, but I&#39;m including it
-- because it is simple and, for the curious, might be helpful
safeHead [] = Nothing
safeHead (x : _) = Just x

myFavouriteThings = [&#34;raindrops on roses&#34;, &#34;whiskers on kittens&#34;]
emptyList = []

faveThing = safeHead myFavouriteThings 
-- ^ but what is the type of this thing? 
-- It&#39;s not a string, it&#39;s `Maybe String`
-- and the value is, in fact, `Just &#34;raindrops on roses&#34;`

something = safeHead emptyList
-- ^ and what&#39;s the type of this thing?
-- again, it&#39;s a `Maybe String`, but in this
-- case the value is `Nothing` because the list
-- has no first element!

-- so how can we use the value we have computed?
printTheFirstThing :: [String] -&gt; IO ()
printTheFirstThing myList = case safeHead myList of
  Just something -&gt; putStrLn something
  Nothing -&gt; putStrLn &#34;You don&#39;t have any favourite things? How sad.&#34;
</code></pre>
<p data-pos="212:1-216:0">In this example you can see that when consuming the result of a computation that might fail, you have to explicitly handle the failure case. There are many ways of doing this, and the pattern matching ( <code>case x of ...</code>) above is just one to which we will come shortly.</p>
<p data-pos="217:1-221:0"><code>Maybe</code> can also be used when you might want a nullable field of a data structure. This is a specific case of a computation which may fail, but is often thought of as distinct. Here is how this would look in Haskell:</p>
<pre data-pos="222:1-228:3"><code>data Person = Person {
  name :: String,
  dob :: Day,
  favouriteThing :: Maybe String
}
</code></pre>
<p data-pos="230:1-234:0">As before, Haskell’s type system will not let you fail to handle the case that <code>favouriteThing</code> might be an empty value, so you will not end up with a runtime error as you might in a language in which you could forget to do so.</p>
<p data-pos="235:1-242:0"><code>Maybe</code> is useful in these situations in which the failure condition is obvious, but it doesn’t give you much resolution on <em>why</em> the computation failed, it only tells you <em>that</em> it has failed. By contrast, an <code>Either a b</code> can contain two values, <code>Left a</code> or <code>Right b</code>. By convention, <code>Left</code> contains a failure value, whereas <code>Right</code> contains a success value, so the type is often given as <code>Either e a</code> where <code>e</code> is for “error” and <code>a</code> is just the result type.</p>
<p data-pos="243:1-247:0">One way in which this could be used is in parsing or validating some user input, in which you may want to tell the user more than just that what they gave you is invalid, but rather in what way it is invalid. To that end you could have a <code>validate</code> function that looked like this:</p>
<pre data-pos="248:1-250:3"><code>validateAddress :: String -&gt; Either AddressParseError ValidAddress
</code></pre>
<p data-pos="252:1-256:0">This gives you the ability to return more helpful errors to the user, which are an expected path in your programme, but it prevents you from failing to handle the failure case, or from treating the failure case like a success case accidentally.</p>
<p data-pos="257:1-263:0">To be clear, this means that we no longer treat known error states as exceptions by throwing them up the call stack <a id="fnref5" href="#fn5" role="doc-noteref"><sup>5</sup></a>, and instead we treat them as potential values for the type of our expression. In turn, this means that we now can have a total description of all the failure modes from the point of the function call <em>down</em> the stack. Consider these two snippets of code:</p>
<pre data-pos="264:1-270:3"><code>def do_something():
  result = get_a_result()
  if result != &#34;a result&#34;:
    raise InvalidResultError(result)
  return 42
</code></pre>
<pre data-pos="272:1-279:3"><code>doSomething :: Either InvalidResultError Int
doSomething = 
  let result = getResult
   in if result /= &#34;a result&#34;
        then Left (InvalidResultError result)
        else Right 42
</code></pre>
<p data-pos="281:1-286:0">In the first snippet, we have no idea what possible exceptions may be raised by <code>do_something</code>, partly because we have no way of knowing what exceptions may be raised by <code>get_a_result</code>. By contrast, in the second snippet, we know <em>all</em> of the possible failure states immediately, because they are captured in the type system.</p>
<p data-pos="287:1-297:0">We can generalise this idea of being forced to handle the failure cases by saying that Haskell makes us write <strong>total</strong> functions rather than <strong>partial</strong> functions. This means that we have to handle the entire input domain rather than only part of the input domain, otherwise the compiler will complain at us and, sometimes, point-blank refuse to give us a programme. The easiest way to see how this works is to look at how pattern matching is done in Haskell, using a basic programme which helps us organise our evenings given a chosen option. Instead of implementing the entire programme, here is an extract to illustrate the use of pattern matching.</p>
<pre data-pos="298:1-316:3"><code>data Option =
  NightIn
  | Restaurant VenueName
  | Theatre VenueName EventName

data OrganiserResult = Success | NeedsSeatChoice [Seat] | Failure Reason

organiseMyEvening :: Option -&gt; IO OrganiserResult
organiseMyEvening NightIn = do
  cancelAllPlans 
  return Success
organiseMyEvening (Restaurant venue) = attemptBooking venue
organiseMyEvening (Theatre venue event) = do
  availableSeats &lt;- checkForSeats venue event
  case availableSeats of
    [] -&gt; return (Failure (Reason &#34;there are no seats available, sorry :(&#34;))
    seats -&gt; return (NeedsSeatChoice seats)
</code></pre>
<p data-pos="318:1-325:0">In the above example, if we were to add an additional option for what we may want to do with our evening, like going to the cinema, and <em>forget</em> to update the <code>organiseMyEvening</code> function accordingly, the compiler would complain to us until we fix it. Without this completeness check in the type system, we could end up with a runtime error, but with this type of check, we just do not have to worry about whether we have <em>remembered</em> to update all the places in which a given value is used.</p>
<p data-pos="326:1-337:0">The final major way in which Haskell’s type system makes it easy for us to avoid common errors when programming is related to how easy it is to avoid “primitive obsession”. There is a hint in our evening-organising snippet above: our <code>Restaurant</code> and <code>Theatre</code> constructors take a <code>VenueName</code> and <code>EventName</code>. These could, naturally, be represented as plain old strings, and in many languages they are, but Haskell gives us a very simple, zero-cost way of representing them as something with more semantic value, more meaning, than just a string. It may not be obvious why this is a problem worth solving, however. Let’s imagine we represented these as plain old strings, so we would have something like this:</p>
<pre data-pos="338:1-345:3"><code>data Option =
  NightIn
  | Restaurant String
  | Theatre String String -- venue name and event name respectively

checkForSeats :: String -&gt; String -&gt; IO [Seat]
</code></pre>
<p data-pos="347:1-366:0">This is probably <em>ok</em> the first time you write it, although you will need comments, as above, in order to remind yourself which value is which. This is where we come to our first annoyance (although not yet a problem) – the type system doesn’t help us remember what is what, we have to rely on arbitrary comments or documentation (or perhaps variable names) to remember, which is a lot of overhead. The problem comes, however, when using these values, such as in <code>checkForSeats</code>. We could easily mix up the venue name and event name, and we would always return zero seats (because we probably don’t know a theatre called <em>King Lear</em> in London where they are playing Shakespeare’s masterful <em>The National Theatre</em>). This is erroneous behaviour, but is easily done, and the type system will not help us out. “Primitive obsession” is the use of primitives (strings, numbers, booleans, etc.) to represent data, instead of types with more semantic value. The solution is to encode your domain in your type system, which prevents such errors. This can be very cumbersome in many imperative languages, but in Haskell we can simply wrap a value in a <code>newtype</code> and the type system suddenly stops us falling into the trap of using the wrong value. Therefore our code above becomes:</p>
<pre data-pos="367:1-377:3"><code>newtype VenueName = VenueName String
newtype EventName = EventName String

data Option =
  NightIn
  | Restaurant VenueName
  | Theatre VenueName EventName

checkForSeats :: VenueName -&gt; EventName -&gt; IO [Seat]
</code></pre>
<p data-pos="379:1-385:0">Above it is written that this is a “zero-cost” method, which means that unlike the normal way of creating a data structure to wrap around some values, <code>newtypes</code> have exactly the same representation in memory as the type they wrap (with the result that they can only wrap a single type), they therefore only exist at the level of the type system, but have no impact on your programme otherwise.</p>
<p data-pos="386:1-391:0">Thus far we have discussed four features of the type system which help us as programmers to write correct code with minimal mental overhead: the lack of nullable types, representations of “failable” computations, pattern matching and completeness checks, and the avoidance of “primitive obsession”.</p>
<p data-pos="392:1-398:0">Other languages have some of these features (notably Rust, whose type system was inspired by Haskell’s), but most of these other languages lack the second pillar: pure functional programming. There are two aspects of a pure functional language which help us avoid common errors: immutable data and explicit side-effects (which, together, give us purity and referential transparency).</p>
<p data-pos="399:1-413:0">Almost all data in Haskell are immutable. This means that a whole class of errors like data races, or objects changing between write and read, just do not exist. In single-threaded code this is great because you don’t have to think about mutating state anywhere, you just use things like folds or traversals to achieve your goals, but where this really shines is in concurrent code. For concurrent Haskell you do not have to worry about mutices and locks because your data can’t be mutated <em>anyway</em>. That means that if you want to parallelise a computation, you just fork it into different threads and wait for them all to come back without all of the hairy bugs of multi-threaded computations. Even when you do require some sort of shared, mutable state between your threads, the way this is constructed in Haskell (e.g. in the <a href="https://hackage.haskell.org/package/stm"><code>STM</code> library</a>) still avoids the problems solved by locks and mutices in other languages.</p>
<p data-pos="414:1-424:0">Immutability gets you halfway towards eliminating the sorts of errors found in imperative languages, but <em>purity</em> will get us the rest of the way. Haskell functions are pure, in the sense that they do not permit any side-effects, nor do they rely on anything except for the arguments passed into them. There are ways to encode side-effects, for, at some point, any useful programme needs to at least perform <em>some</em> I/O, and there are ways to include things in functions which are not <em>directly</em> passed as arguments (implicit parameters), but the way Haskell is constructed means that these ways do not violate the purity of the language because we use monads to encode these things.</p>
<p data-pos="425:1-431:0">Monads: at first they throw every novice Haskeller into disarray, and then nearly everyone feels the need to write their own monad tutorial. Exactly what monads are and why they are useful is beyond the scope of what we want to talk about here, but the specific benefit we <em>are</em> looking at is how this allows us to encode side-effects and why that is going to help you avoid mistakes when programming.</p>
<p data-pos="432:1-433:0">Let’s look at some functions for a basic online community:</p>
<pre data-pos="434:1-442:3"><code>data Response = Success | Failure FailureReason

sendGreetings :: User -&gt; IO Response

updateUser :: UserId -&gt; User -&gt; IO Response

findNewestUser :: [User] -&gt; Maybe User
</code></pre>
<p data-pos="444:1-451:0">In many imperative languages, the activity of finding the newest user and sending them some sort of greeting might all be done in one function, or a set of deeply nested functions. There would be nothing to stop you, however, making database calls, sending emails, or doing anything else inside the simple <code>findNewestUser</code> function. This can be a nightmare for tracking down bugs and performance issues, as well as preventing tight-coupling between functions.</p>
<p data-pos="452:1-464:0">The functions above take two forms: <code>findNewestUser</code> returns something by now familiar to us, <code>Maybe User</code> – if there is a newest user, it will return it, otherwise it will return <code>Nothing</code>. The other two functions return something we have not yet seen: <code>IO Response</code>. <code>IO</code>, like <code>Maybe</code> wraps another type (in this case: <code>Response</code>) but instead of representing a “failable” computation as <code>Maybe</code> does, it represents any context in which you are permitted to perform I/O actions (like talking to your database or sending emails, as our cases are above). It is not possible to perform I/O outside of the <code>IO</code> monad – your code will not compile – and, furthermore, I/O “colours” all the functions which call it, because if you are calling something which returns <code>IO</code>, then you have to be returning <code>IO</code> as well.</p>
<p data-pos="465:1-474:0">This might look like a lot of bureaucracy, but it actually does two very helpful things: firstly, it immediately tells the programmer “hey, this function performs side-effects in I/O” which means that they don’t have to read the code in order to understand what it does, just the type signature; secondly, it means that you cannot accidentally perform I/O in a function you thought was pure – this, in itself, eliminates whole classes of bugs in which one may think one understands all the dependencies of a function, but actually something is affecting it which you did not realise, because it can perform side-effects.</p>
<p data-pos="475:1-482:0">This is only partially satisfying, however, as wrapping everything that performs side-effects in <code>IO</code> is a bit imprecise in a similar way in which using primitive types for values with higher-level semantics in the domain is also imprecise, and it can cause similar classes of error: there is nothing to say “in this function you can send emails, but you can’t write to the database.” The type-system has helped you <em>a little bit</em> but stopped short of the guardrail we have come to expect by now.</p>
<p data-pos="483:1-493:0">Thankfully, due to two additional language features: namely ad hoc polymorphisms and typeclasses, we can <em>exactly</em> encode the effects we want a function to be permitted to perform, and make it impossible to perform any others. Let’s modify our example to take advantage of this, noting that <code>class X a where</code> means that we are declaring a <em>class</em> <code>X</code> of types with some associated functions for which we have to write concrete implementations. This is similar to interfaces in some languages, or traits in Rust (which were based on Haskell’s typeclasses). In this example, <code>m</code> is just a type variable representing a “2nd order”<a id="fnref6" href="#fn6" role="doc-noteref"><sup>6</sup></a> type (e.g. <code>IO</code> or <code>Maybe</code>).</p>
<pre data-pos="494:1-515:3"><code>data Response = Success | Failure FailureReason

class CanReadUsers m where
  getUsers :: m (Either FailureReason [User])

class CanWriteUsers m where
  updateUser :: UserId -&gt; User -&gt; m Response

class CanSendEmails m where
  sendEmail :: EmailAddress -&gt; Subject -&gt; Body -&gt; m Response

findNewestUser :: [User] -&gt; Maybe User

sendGreetings :: CanSendEmails m =&gt; User -&gt; m Response

greetNewestUser :: (
  CanReadUsers m,
  CanWriteUsers m,
  CanSendEmails m
  ) =&gt; m Response
</code></pre>
<p data-pos="517:1-527:0">We have introduced a new function here <code>greetNewestUser</code> to illustrate how we can compose these <em>constraints</em> on what we are able to do. Our implementation of this would do something like: find all the users, filter for the newest one, send an email, and mark the user as having been greeted. We have encoded these capabilities at the type level for <code>greetNewestUser</code>, whereas we have not for <code>sendGreetings</code>, so it would be impossible, in fact, for <code>sendGreetings</code> to fetch users from the database or to accidentally update the user information in the database<a id="fnref7" href="#fn7" role="doc-noteref"><sup>7</sup></a>. It can <em>only</em> send emails. To finish this example off, let’s see how the implementations of these functions might look:</p>
<pre data-pos="528:1-555:3"><code>-- these would be defined elsewhere, but just so you know the types
joinDate :: User -&gt; Day
emailAddress :: User -&gt; EmailAddress
setAlreadyGreeted :: User -&gt; User
hasBeenGreeted :: User -&gt; Bool
userId :: User -&gt; UserId

findNewestUser users = safeHead (sortOn joinDate users)

sendGreetings user = 
  let subject = Subject &#34;Welcome to the club!&#34;
      body = Body &#34;Remember: don&#39;t stare at the guests...&#34;
   in sendEmail (emailAddress user) subject body

greetNewestUser = do
  fetchResult &lt;- getUsers
  case fetchResult of
    Left err -&gt; return (Failure err)
    Right users -&gt; case findNewestUser users of
      Nothing -&gt; return (Failure NoUsers)
      Just user -&gt; if hasBeenGreeted user
        then return (Failure AlreadyGreetedUser)
        else do
          sendGreetings user
          let newUserData = setAlreadyGreeted user
           in updateUser (userId user) newUserData
</code></pre>
<p data-pos="557:1-566:0">While the exact syntax may be unfamiliar, everything in this section has been building up to this point: we represent “failable” computations with data types which encapsulate that they can fail and how they can fail; we use semantically meaningful types to describe our data, rather than primitives; we explicitly handle failure cases rather than being allowed to forget about them; we cannot mutate state so we create new copies of our data with the requisite updates; and we explicitly encode the side-effects we want to perform, rather than just firing them off willy-nilly.</p>
<p data-pos="567:1-574:0">That rounds off the section about the guardrails Haskell puts in place for you as a programmer, both through the strength of its type system and the purity and referential transparency of the language itself. Far from being an imposition on the programmer, this is incredibly freeing as it allows you to spend your mental energy <em>describing</em> your problem and thereby solving it, not worrying about keeping track of all the ways in which your programme could fail.</p>
<section data-pos="575:1-611:0" id="But-language-has-feature-too">
<h3 data-pos="575:1-576:0">But &lt;language&gt; has &lt;feature&gt;, too!</h3>
<p data-pos="577:1-581:0">Some of the features of Haskell above exist, or <em>look like</em> they exist, in other languages. Without trying to talk about every possible language, we can look at some of the common patterns and how they differ, or do not, from those in Haskell.</p>
<p data-pos="582:1-590:0">Pattern matching, for example, has been introduced into many languages. Some of those have the same characteristics as Haskell, like Rust’s pattern matching, which is exhaustive and enforced by the compiler, whereas some are quite different, especially in gradually-typed languages like Typescript and Python, where there is no guarantee that this sort of safety permeates the codebase, and there are often escape-hatches, because you are using optional tools external to the built-in toolchain.</p>
<p data-pos="591:1-595:0">Very few languages make use of higher-order types like <code>Either</code> and <code>Maybe</code> to represent computations which may fail, but Rust is a notable exception which, like Haskell, strongly encourages representing failure in this way.</p>
<p data-pos="596:1-606:0">Subclassing is commonly used in some languages to make it “easy” to avoid primitive obsession, but this is not as strict as Haskell’s <code>newtype</code>s. Python, for example, has a <code>NewType</code> construction, but it has two weaknesses common to this type of implementation: the first is that subclassing means that our <code>VenueName</code> and <code>EventName</code> types can be passed to functions expecting <code>String</code>, because they are not treated as completely different types, and the second is that, unlike in Haskell, you cannot hide the constructors of these types, which means there are certain patterns you cannot fully implement like the parsing pattern (as opposed to validating)<a id="fnref8" href="#fn8" role="doc-noteref"><sup>8</sup></a>.</p>
<p data-pos="607:1-611:0">Finally, while some libraries exist in other languages in order to isolate and control side-effects<a id="fnref9" href="#fn9" role="doc-noteref"><sup>9</sup></a>, they are not enforced as part of the language in the same way, because this would require purity to be built into the language itself.</p>
</section>
</section>
<section data-pos="612:1-738:0" id="The-things-which-make-you-more-productive">
<h2 data-pos="612:1-613:0">The things which make you more productive</h2>
<p data-pos="614:1-620:0">Providing guardrails, for all the reasons listed in the previous section, is a very useful feature of a language, but that alone might make for a very slow experience of building programmes. Haskell has several properties which actually make it <em>more</em> productive to construct such programmes, especially as those programmes grow in complexity (or sheer size).</p>
<p data-pos="621:1-627:0">As before, these properties derive from the two key characteristics of the language<a id="fnref10" href="#fn10" role="doc-noteref"><sup>10</sup></a>: the strength of the type-system and the pure-functional semantics of the language. These two together give us code which is highly declarative, and therefore easily and unambiguously manipulable, as well as a tendency towards heavy concept and code re-use.</p>
<p data-pos="628:1-635:0">Why are these useful? Starting with the former: if our programme is declarative rather than imperative, we can easily understand it ourselves, as well as simply generate other code from it (or documentation), and refactoring becomes a “fearless” activity. Taking the latter, this means that we can “discover” a set of core concepts and continue to build upon them, instead of having to learn disjoint sets of concepts for each domain or library one uses.</p>
<p data-pos="636:1-650:0">It can be hard to explain just how radically these things transform the way one constructs programmes without experiencing them, but to take a small example, the Haskell ecosystem has a tool called <a href="https://hoogle.haskell.org">“Hoogle”</a> which allows one to search for functions by type signature. Not only by full type signature with concrete types, but, even by partial type signature with type variables instead of actual types. That means that, instead of searching for something which applies a function to each string in a list of strings (<code>(String -&gt; String)
-&gt; [String] -&gt; [String]</code>), one can instead search for something which applies a function to a list of things, returning a list of the results: (<code>(a -&gt; b) -&gt; [a] -&gt; [b]</code>). You can even get the arguments the wrong way around, and Hoogle will still find you the right functions, so <code>[a] -&gt;
(a -&gt; b) -&gt; [b]</code> will give you the same answers (sorted differently) to <code>(a -&gt; b) -&gt; [a] -&gt; [b]</code>!</p>
<p data-pos="651:1-659:0">This works so well because Haskell’s semantics, standard library, and ecosystem all rely heavily on concept re-use. Almost every library builds upon the core set of concepts<a id="fnref11" href="#fn11" role="doc-noteref"><sup>11</sup></a>. This means that if you are wondering how to do something, and you are faced with one library or set of data types, you can probably search for the general pattern of what you want to achieve and you will get what you want. Almost no other ecosystem<a id="fnref12" href="#fn12" role="doc-noteref"><sup>12</sup></a> has something comparable to this.</p>
<p data-pos="660:1-663:0">In order to flesh out this idea of concept generalisation and re-use, let’s consider two examples: functors and monoids. Before we get there, we will start with lists.</p>
<p data-pos="664:1-672:0">A list is Haskell looks like this <code>myList = [1, 2, 3] :: [Int]</code>. You can do various things with lists, like apply a function to each member of the list (<code>map</code>) in order to obtain a new list, or stitch two lists together (<code>[1, 2] &lt;&gt; [3, 4]</code>). In this sense, we have described two properties of lists which we can generalise: a list is a container over which you can apply a function (a “functor”), and a list is an object which has a binary combining operator with an identity value <code>[]</code> (a “monoid”).</p>
<p data-pos="673:1-678:0">Lots of other structures exhibit these properties, for example a list is a functor, but so is a <code>Maybe</code> or an <code>Either</code>, or even a parser! As a result, if you understand the core concept of functors, you have a set of tools which can apply to all sorts of other data structures which you use day-to-day, but with no extra overhead:</p>
<pre data-pos="679:1-688:3"><code>fmap (+ 2) [1, 2, 3] -- [3, 4, 5]
fmap (+ 2) (Just 2) -- Just 4
fmap (+ 2) (Right 5) -- Right 7
number = fmap (+ 2) decimal :: Parser Int
-- parses a string representation of a decimal, adding 2 to it, but
-- the nice thing here is that we don&#39;t have to explicitly handle the
-- failure case with our `+ 2` function!
parseMaybe number &#34;4&#34; -- Just 6
</code></pre>
<p data-pos="690:1-696:0">Similarly, there are plenty of monoids lurking about. Obvious examples might be strings, but then, for example, the <a href="https://hackage.haskell.org/package/lucid"><code>Lucid</code> library</a> for writing HTML represents HTML as monoids, which allows you to compose them with the same tools you would use for any other monoid. Once again, you learn a single core concept, and it becomes applicable across a large part of the ecosystem.</p>
<pre data-pos="697:1-701:3"><code>[1, 2] &lt;&gt; [3, 4] -- [1, 2, 3, 4]
&#34;hello&#34; &lt;&gt; &#34; &#34; &lt;&gt; &#34;world&#34; -- &#34;hello world&#34;
myIntro = p_ (i_ &#34;Don&#39;t &#34; &lt;&gt; b_ &#34;panic&#34;) -- &lt;p&gt;&lt;i&gt;Don&#39;t &lt;/i&gt;&lt;b&gt;panic&lt;/b&gt;&lt;/p&gt;
</code></pre>
<p data-pos="703:1-708:0">You can even use this in your own code, and can write simple instances for your own data structures. This vastly reduces the amount of specialised code you have to write – instead, you can simply re-use code and concepts from elsewhere, whether the standard library or an extension to those concepts like bifunctors.</p>
<p data-pos="709:1-715:0">In short: Haskell’s semantics and standard library encourage generalised concepts which, in turn, heavily promote both concept and code reuse, and this has driven the development of the ecosystem in a similar direction. That re-use means that the programmer need only discover the core concepts once, rather than for each library, providing an accelerating rate of learning and a much more efficient use of code.</p>
<p data-pos="716:1-729:0">The final productivity boost to discuss here is “fearless refactoring”, a term often thrown about in the Haskell community, but what does it actually mean? The essential point here is that the intransigence of the compiler makes it a useful ally when refactoring code. In languages with a more forgiving compiler or weaker type-system, refactoring code can introduce new bugs which are only discovered at runtime. When refactoring Haskell, because the type-system gives you the power to express your programme domain correctly, the process normally works as a constant cycle of “change, compile, change, compile” until all the compilation errors are gone, at which point you can be very confident you will not encounter runtime bugs. This reduces the cognitive load on the programmer, making it far faster (and less scary) to make changes to a codebase, whether large or small.</p>
<p data-pos="730:1-738:0">This section goes beyond just providing guardrails, guardrails which are clearly inspiring other language maintainers to introduce them into their languages, to talk about something very fundamental to productivity in programming: composable, re-usable concepts and the ability to “fearlessly” make changes to your programme. These are not simply features which can be added into a language, they are characteristics of it, and they relate to the more abstract notions laid out in the next section.</p>
</section>
<section data-pos="739:1-898:0" id="Reason-about-your-programmes-more-easily">
<h2 data-pos="739:1-740:0">Reason about your programmes more easily</h2>
<p data-pos="741:1-750:0">In general, programming is about telling a machine about some problem domain: the ontology of it, and the logical rules governing it, and then asking it to compute some results. These results should have some sort of meaning we can interpret, which is going to depend on how well we understand what our programme actually <em>means</em>. Additionally, for us to be able to trust the results of the computations we ask of the machine, we need to be confident that we have done a good job describing the problem domain in terms that result in a “good” understanding on the part of the machine.</p>
<p data-pos="751:1-757:0">A programme can have essential complexity or accidental complexity. The essential complexity comes from precisely describing the problem domain, and some domains are more complex than others. The accidental complexity comes from our (in)ability to express the problem domain to the machine. We can refer to these as <em>complexity</em> and <em>complication</em> to differentiate them.</p>
<p data-pos="758:1-764:0">Complications are bad and should be eliminated. They make it hard to reason about our programmes and therefore hard to trust their results. It also makes it hard to write the programmes in the first place, because we have to deal with all these complications. It’s a bit like trying to embroider a tapestry using a Rube Goldberg machine operated with thick mittens: unlikely to give you what you want.</p>
<p data-pos="765:1-776:0">We could look at general purpose programming languages on a scale of how well we are able to express a problem domain to a machine, and therefore to what extent we are able to trust the results of the computations we ask of that machine. Assembly is at one end: it is all about moving bytes between registers and performing arithmetic on them. Yes, you can write anything in Assembly but it is really hard to reason about the results you will get. As we move along the scale towards “high-level” languages we gain a set of abstractions which allow us to forget about the semantics of the lower level (e.g. moving bytes between registers) because they give us new semantics which are closer to those of the problem domain.</p>
<blockquote data-pos="777:1-779:36">
<p data-pos="777:3-779:36">The purpose of abstracting is not to be vague, but to create a new semantic level in which one can be absolutely precise. ~ Dijkstra, 1972<a id="fnref13" href="#fn13" role="doc-noteref"><sup>13</sup></a></p>
</blockquote>
<p data-pos="781:1-788:0">Haskell improves upon most high-level languages in this regard, providing a level of expressivity that allows more precise descriptions of the problem domain, easily intelligible both to the programmer and the machine. Broadly there are three major contributing factors to this (perhaps all of them can fit under the idea of denotation semantics): algebraic data types, parametric and ad hoc polymorphism, and declarative programming.</p>
<p data-pos="789:1-793:0">We can distinguish declarative and imperative programming by saying that declarative programming describes what a computation is supposed to be with respect to the problem domain, whereas imperative programming describes how a computation is to be carried out, step-by-step.</p>
<p data-pos="794:1-801:0">This is useful distinction: in imperative programming the operational semantics of the programme (the steps a machine must execute in order to compute a result) are mixed into the problem domain, making it difficult to reason about the meaning of a programme and, therefore, its correctness. Declarative programming, however, does not bother with defining these execution steps, making programmes much simpler to understand and reason about.</p>
<p data-pos="802:1-812:0">In Haskell, everything is an expression. In fact, your entire programme is a <em>single</em> expression composed of sub-expressions. These sub-expressions have themselves some sort of meaning, as does their composition. This is different to imperative languages, in which is common for there to be many lines of function calls and loops, with, often, deeply nested function calls, but these are not essentially composable. Haskell’s purity forces concise programmes composed of meaningful sub-expressions with no side-effects. This means that it takes far less time to understand the purpose of a given expression, and therefore reason about whether it is correct or not.</p>
<p data-pos="813:1-818:0">As ever, we are back to our two familiar pillars: so far, we have discussed the pure-functional pillar (single expression, compositionality, no side-effects), but the type system gives us the tools for expressing ourselves clearly to the machine (and to ourselves).</p>
<p data-pos="819:1-828:0">In fact, most of the preceding sections touch upon this in one way or another: we have data types for expressing the idea that some computations can fail in well-defined ways; we have sum types like <code>data
Response = Success | Failure FailureReason</code> which allow us to define all the possible values we might get from a function; we have typeclasses we can use as constraints on a function to semantically express what the result is in the most general way (like <code>CanSendEmails</code>); and we have generalised concepts like <code>Functor</code> and <code>Monoid</code> which describe how things behave rather than the steps to implement those behaviours.</p>
<p data-pos="829:1-838:0">Algebraic data types and typeclasses (and other, similar mechanics which deal with various polymorphisms) allow us to construct our own domain-specific languages within Haskell with which to write our programmes, while building upon common, well-established concepts to do so. These are declarative rather than imperative, and therefore are easy to reason about and to understand <em>semantically</em> because you do not have to either weed out the operational semantics (the step-by-step instructions) nor do you have to translate from a layer of primitives into your own domain.</p>
<p data-pos="839:1-843:0">This section has been necessarily abstract, because the idea is hard to communicate if one has not stepped outside the imperative paradigms in which most of modern programming sits. To try to elucidate it somewhat, here is a small sample programme using the concepts discussed above.</p>
<p data-pos="844:1-847:0">This programme is a basic accounting tool: given some initial monetary value, and a set of transactions (either in or out) in a variety of currencies, allow us to calculate the final value of the account.</p>
<pre data-pos="848:1-897:3"><code>-- this is a bit like an &#34;enum&#34; of possible constructors of the type Currency
data Currency = GBP | EUR | USD 

data Money = Money {
  currency :: Currency,
  value :: Double
  }

convert :: Currency -&gt; Money -&gt; Money
convert = -- not interesting to implement here as it is basically a lookup table

zero :: Money
zero = Money GBP 0

-- Ord gives us ways of comparing things (a natural ordering)
instance Ord Money where
  compare m1 m2 
    | currency m1 == currency m2 = compare (value m1) (value m2)
    | otherwise                  = compare m1 (convert (currency m1) m2)

instance Monoid Money where
  m1 &lt;&gt; m2 = Money (currency m1) (convert (currency m1) m2)
  mempty = zero

instance Functor Money where
  fmap f (Money curr val) = Money curr (f val)

data Transaction = In Money | Out Money

instance Functor Transaction where
  fmap f (In m) = In (f m)
  fmap f (Out m) = Out (f m)

normalise :: Transaction -&gt; Transaction
normalise transaction =
  let m = money transaction
   in if m &lt; zero then Out m else In m

instance Monoid Transaction where
  t1 &lt;&gt; In m2 = normalise (fmap (&lt;&gt; m2) t1)
  t1 &lt;&gt; Out m2 = normalise (fmap (&lt;&gt; (fmap (* (-1)) m2)) t1)

apply :: Transaction -&gt; Money -&gt; Money
apply (In m) initial = initial &lt;&gt; m
apply (Out m) initial = initial &lt;&gt; fmap (* (-1)) m

getAccountValue :: Money -&gt; [Transaction] -&gt; Money
getAccountValue startValue transactions = apply (fold transactions) startValue
</code></pre>
</section>
<section data-pos="899:1-1003:73" id="Epilogue">
<h2 data-pos="899:1-900:0">Epilogue</h2>
<p data-pos="901:1-905:0">I love writing in Haskell, and there are many reasons beyond this apologia why that is the case, but I also think it is an excellent choice for general purpose programming for anyone who wants to write robust software confidently and efficiently, and, of course, enjoyably.</p>
<p data-pos="906:1-913:0">I think what makes Haskell unique is the combination of its type system and functional purity – it’s not enough just to have functional programming, much as I love LISPs, nor is it enough just to have the type system, much as Rust seems like a great language. Many languages have bits of these features, but only a few have all of them, and, of those languages (others include Idris, Agda, and Lean), Haskell is the most mature, and therefore has the largest ecosystem.</p>
<p data-pos="914:1-921:0">While other languages are certainly adding features which I have mentioned above, this combination of a strong and expressive type system and pure functional programming is fundamental to the language: other languages without these axiomatic characteristics simply will not be able to implement them (and attempts to build some of these things into non-functional languages with weaker type systems is often extremely awkward and not very useful).</p>
<p data-pos="922:1-928:0">Not everyone has the luxury of choosing their tools in a professional context, whether because there is history in their team or the decisions are made by others. Even in this case, if you never end up using Haskell professionally, it will change how you think about programming, and to invert Alan Perlis’ quotation from the start of this essay: any language which changes how you think about programming is worth learning.</p>
</section>
<section role="doc-endnotes">
<hr/>
<ol>
<li id="fn1">
<p data-pos="939:21-943:0">This is, however, not supposed to be an exhaustive list of all the things I think are great about Haskell, but just a subset of the most compelling reasons I recommend it to programmers. The rest they can discover for themselves.<a href="#fnref1" role="doc-backlink">↩︎</a></p>
</li>
<li id="fn2">
<p data-pos="944:26-947:0">Haskell is, of course, not always an appropriate choice. For example, it is never going to replace C or C++ for writing software for micro-controllers.<a href="#fnref2" role="doc-backlink">↩︎</a></p>
</li>
<li id="fn3">
<p data-pos="948:19-949:0">And quite possibly an “object-oriented” paradigm, to boot.<a href="#fnref3" role="doc-backlink">↩︎</a></p>
</li>
<li id="fn4">
<p data-pos="929:17-930:0">Perlis, A., “Epigrams in Programming” (<a href="http://cs.yale.edu/homes/perlis-alan/quotes.html">retrieved 2024-07-07</a>)<a href="#fnref4" role="doc-backlink">↩︎</a></p>
</li>
<li id="fn5">
<p data-pos="965:22-970:0">This is a bit like using <code>goto</code> to manage known failure states, which, I think, would be quite unintuitive if it hadn’t become such a dominant way of managing such failure states. In any case, I think it would make <a href="https://dl.acm.org/doi/10.1145/362929.362947">Dijkstra quite sad</a>.<a href="#fnref5" role="doc-backlink">↩︎</a></p>
</li>
<li id="fn6">
<p data-pos="987:9-996:0">This use of “2nd order” is not idiomatic in Haskell, as this is technically a higher-kinded type, whereas “order” is typically used to refer to functions, but just like a higher-order function is a function which takes another function as its argument, a higher-kinded type is a type which takes another type as an “argument”, and thereby produces a “concrete type”. Diogo Castro’s <a href="https://diogocastro.com/blog/2018/10/17/haskells-kind-system-a-primer/">2018 blog post “Haskell’s kind system – a primer”</a>  has more details on this.<a href="#fnref6" role="doc-backlink">↩︎</a></p>
</li>
<li id="fn7">
<p data-pos="997:9-1000:0">For those who are familiar with the idea, this is a bit like command-query segregation in the imperative world, but enforced by the type system.<a href="#fnref7" role="doc-backlink">↩︎</a></p>
</li>
<li id="fn8">
<p data-pos="971:25-980:0">To expand slightly on this, although it would be worth reading the <a href="https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/">excellent blog post by Alexis King</a>, this means that instead of <em>validating</em>, i.e. checking a value meets some criterion, we parse an “unknown” value into a “valid” value, and thereby change its type. The result is that you can write functions which are defined to take the “valid” type (e.g. <code>EmailAddress</code>) and which never have to worry that it might be invalid, because you simply cannot forget to verify it, as you can in a “validation” pattern.<a href="#fnref8" role="doc-backlink">↩︎</a></p>
</li>
<li id="fn9">
<p data-pos="981:32-986:0">Christopher Armstrong <a href="https://www.youtube.com/watch?v=D37dc9EoFus">gave an interesting talk at Strange Loop in 2015</a> on his python library, which includes an introduction to the motivation for this sort of pattern. This might be good follow-on content if you are interested.<a href="#fnref9" role="doc-backlink">↩︎</a></p>
</li>
<li id="fn10">
<p data-pos="954:21-958:0">Actually, what is really distinctive about Haskell is that it is a <strong>lazy</strong>, pure, functional language, but laziness can be confusing and is only lightly related to the benefits discussed in this essay, and so I am going to ignore it.<a href="#fnref10" role="doc-backlink">↩︎</a></p>
</li>
<li id="fn11">
<p data-pos="1001:21-1003:73">You can find a big map of how these concepts related to each other by checking out the <a href="https://wiki.haskell.org/Typeclassopedia#Introduction">Typeclassopedia</a>.<a href="#fnref11" role="doc-backlink">↩︎</a></p>
</li>
<li id="fn12">
<p data-pos="961:18-964:0">Unison <em>does</em> have something called Unison Share, but it was written by a Haskeller and directly inspired by Hoogle (and, in fact, Unison is based on Haskell).<a href="#fnref12" role="doc-backlink">↩︎</a></p>
</li>
<li id="fn13">
<p data-pos="935:23-936:0">Dijkstra, E.W., ACM Turing Lecture: “The Humble Programmer”, 1972 (<a href="https://www.cs.utexas.edu/~EWD/transcriptions/EWD03xx/EWD340.html">transcript</a>)<a href="#fnref13" role="doc-backlink">↩︎</a></p>
</li>
</ol>
</section>
</div></div>
  </body>
</html>
