<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://neodyme.io/en/blog/github_secrets/">Original</a>
    <h1>Hidden GitHub commits and how to reveal them</h1>
    
    <div id="readability-page-1" class="page"><div> <h2 id="tldr">TL;DR<a aria-hidden="true" tabindex="-1" href="#tldr"><span>¶</span></a></h2>
<p>We have created a tool for GitHub that can reveal commits that potentially contain sensitive information and are not accessible via the public Git history, but that may be of interest or were intentionally deleted.</p>
<h2 id="introduction">Introduction<a aria-hidden="true" tabindex="-1" href="#introduction"><span>¶</span></a></h2>
<p>GitHub is one of the most commonly used platforms and cloud-based services for software development and version control using Git.
People use it to share code, projects, or custom developments online; the project’s history is recorded in the commits (and the commit messages) and is available for viewing to anyone.
GitHub offers many additional features, some of which are well-known and widely used while others remain virtually unknown to users.</p>
<p>Sometimes, the shared data contains secrets, or information that should not have been published. There are ways to delete them, but they are not intuitive at all.
During a recent security evaluation, we had a repo with deleted commits, and identified a GitHub flaw that isn’t well known.
It allows access to commits not listed in the project’s history, including commits that have been removed using a forced push. We have created <code>github-secrets</code> to search for and find such commits on any public repository so that users can determine whether supposedly deleted commits are currently publicly visible in their repository.</p>
<p>We will now provide a brief overview of the process involved in deleting Git commits, emphasizing the challenges posed by a remote repository on GitHub with its caching and APIs, which make this task impossible without reaching out to GitHub customer support.</p>
<h2 id="table-of-contents">Table of contents<a aria-hidden="true" tabindex="-1" href="#table-of-contents"><span>¶</span></a></h2>
<ol>
<li><a href="#git-and-git-reset">Git and Git reset</a></li>
<li><a href="#github-api-and-its-additional-functions">GitHub API and its additional functions</a></li>
<li><a href="#security-implications">Security implications</a></li>
<li><a href="#github-secrets">Github Secrets</a></li>
<li><a href="#example">Example</a></li>
</ol>
<h2 id="git-and-git-reset">Git and Git reset<a aria-hidden="true" tabindex="-1" href="#git-and-git-reset"><span>¶</span></a></h2>
<p>Git is a powerful and efficient software for distributed version control.
It <a href="https://docs.github.com/en/get-started/using-git/about-git">tracks the changes in all files stored in the repository</a> and enables collaborative software development in the formats used by most programmers. The most common features are presumably well-known so we will not examine them more closely here.</p>
<center><figure><img src="https://neodyme.io/blog/github_secrets/xkcd_git.png"/><figcaption><p><a href="https://xkcd.com/1597/">xkcd git</a>, CC BY 2.5</p></figcaption></figure></center>
<p>Suppose, however, that you have accidentally committed and pushed an incorrect entry to a repository. What can you do about it?
You now have two options: you either create another commit and correct your error or — if you don’t want anybody to see the erroneous commit — you can follow the instructions you will find in a quick online search and execute the following two commands to undo the incorrect commit and clean the commit history:</p>
<pre tabindex="0"><code><span><span>git reset --hard HEAD^</span></span>
<span><span>git push origin -f</span></span></code></pre>
<p>Let’s discuss this option for a moment. The reset command is a versatile tool featuring a range of different options for undoing the changes in a repository.
A deep dive into the <code>git reset</code> command can be found in <a href="https://www.atlassian.com/git/tutorials/undoing-changes/git-reset">the atlassian tutorials</a>. In particular, this reset command with the flag <code>--hard HEAD^</code> reverses the most recent commit on this branch, essentially by undoing all file changes and making it appear that the commit never happened.
The following push command with the flag <code>-f</code> (for <code>force</code>) ignores all warnings and safety mechanisms of Git when pushing to the remote repository.
This is necessary as Git would normally prevent you from pushing over newer commits on a remote repository.
As previously mentioned, Git is most commonly used when working on projects cooperatively.
During development, it often happens that your local revision status is older than the remote status (because someone else pushed a commit after your checkout).
Normally, you would have to pull the remote repository again and either merge or rebase the newer commit.
In our case, however, we want to actively delete this “newer” commit. Using the <code>-f</code> flag, we tell Git we know what we are doing and the remote repository accepts our older status of the repository.</p>
<p>Our online research indicates that we can correct the changes and push a new commit without leaving behind any trace of our previous error.
<strong>But caution is advised</strong>: just because a commit is not accessible via the history does not mean that it cannot be retrieved.
Commands like <code>git reflog</code> or <code>git fsck --lost-found</code> will make these commits visible again and can even restore them if needed.
For example, <a href="https://git-scm.com/book/en/v2/Git-Internals-Maintenance-and-Data-Recovery">this blog post</a> describes how to restore a lost commit from the computer used to create and push it.
It is impossible, however, to use ‘git reflog´ to clone a repository from GitHub and see these commits.</p>
<center><figure><img src="https://neodyme.io/blog/github_secrets/git_reflog_local.png"/><figcaption><p>Local <code>git reflog</code></p></figcaption></figure><figure><img src="https://neodyme.io/blog/github_secrets/git_reflog_remote.png"/><figcaption><p>Remote <code>git reflog</code></p></figcaption></figure></center>
<p>So if we had accidentally pushed some secrets on GitHub, but force-pushed over the wrongful commit, we should be fine, right? Not at all!</p>
<p>Due to GitHub’s internal architecture, they don’t delete force-pushed commits! While they are <strong>not</strong> cloned with a normal clone and cannot be enumerated with reflog, they are accessible if we know the commit hash by simply specifying the hash in the GitHub URL. With that in mind, let us look at the GitHub API.</p>
<h2 id="github-api-and-its-additional-functions">GitHub API and its additional functions<a aria-hidden="true" tabindex="-1" href="#github-api-and-its-additional-functions"><span>¶</span></a></h2>
<p>When a Git repository is set up on GitHub, a lot of data and information besides the repository itself are set up.
For example, it is possible to watch or star repositories on GitHub, and this information needs to be stored somewhere; GitHub Insights need to be initialized, Issues, Project, Actions and many more additional functions must be set up for the newly created repository.
Apart from the general Git commands (which are equally usable in GitHub), GitHub offers an additional <a href="https://docs.github.com/en/rest/quickstart?apiVersion=2022-11-28">API</a> for interacting with all the extra functions that are not implemented in the standard Git software.
One example is the <a href="https://docs.github.com/en/rest/metrics/statistics?apiVersion=2022-11-28">statistics endpoint</a> that collects information about the general activity on the repository (such as an <a href="https://docs.github.com/en/rest/metrics/statistics?apiVersion=2022-11-28#get-the-hourly-commit-count-for-each-day">hourly commit count for each day</a>).
However, this information could also be gathered from the general UI.
A far more interesting public endpoint that is not visible in the general GitHub UI is the <a href="https://docs.github.com/en/rest/activity/events?apiVersion=2022-11-28">event endpoint</a>.
The endpoint lists a multitude of <a href="https://docs.github.com/en/rest/overview/github-event-types?apiVersion=2022-11-28">different events</a> such as WatchEvents, CommitCommentEvents, DeleteEvents, GollumEvents (if you’ve never heard of this one, no worries; it is the event for a wiki page creation or update) and even PushEvents on a particular repository.
You can query that endpoint for every public repository.</p>
<center><figure>
						<img src="https://neodyme.io/blog/github_secrets/all_events.png" alt="All events of a public repository"/>
						<figcaption>
							<p>
								All events of a public repository
							</p>
						</figcaption>
					</figure>
					</center>
<p>Given that we are discussing hidden commits, let’s take a look at the PushEvents. We specifically ask ourselves the following questions:
Does the commit history display all commits that have ever been pushed?
Do we find any information about our previously deleted, now hidden commit?
Let’s remember the situation we described above: We have pushed an incorrect commit and want to reverse this action.
Our first push with the incorrect commit created a PushEvent with an array of commit objects describing the pushed commits.
When we now force-push an older version onto the remote Git, we create an additional PushEvent.
Instead of generating a new commit, it simply rolls back the head of the remote repository.
The previous incorrect commit is no longer part of the history and is not visible in the GitHub commit history UI.
Some online sources discussing this topic (for example, <a href="https://stackoverflow.com/questions/448919/how-can-i-remove-a-commit-on-github">this StackOverflow thread</a>) mention that a force-pushed commit may still be accessible via its SHA1-Hash.
However, they don’t tell you how to find this hash if you didn’t see the commit while it was still in the regular history.
This might give people the impression that if the force-push was fast enough and nobody saw the commit and its associated hash, there is no trace of the commit anywhere (since it has been deleted from the history).
Don’t fall into this trap as it could give you a sense of false security of having ”<em>quick-fixed the error</em>”.
This is also the case if you change your repository setting from private to public.
The events endpoint still lists all PushEvents even from the time it was private and the hash of our incorrect commit can still be seen here. The commit we tried to hide with the force-push can be found by anybody accessing the public events API!</p>
<center><figure>
						<img src="https://neodyme.io/blog/github_secrets/force_push_event.png" alt="Example of a force-pushed repository, reset to an older commit"/>
						<figcaption>
							<p>
								Example of a force-pushed repository, reset to an older commit
							</p>
						</figcaption>
					</figure>
					</center>
<h2 id="security-implications">Security implications<a aria-hidden="true" tabindex="-1" href="#security-implications"><span>¶</span></a></h2>
<p>First, let’s be clear about one thing: as long as a pushed commit remains available in the normal Git history, anybody can clone or fork the repository with this status, so all sensitive data should be considered compromised no matter what.
We have also just described how one can retrieve all the information necessary to access the deleted commit by finding the corresponding PushEvent, extracting the SHA1-Hash and accessing the commit via the hash.
But this is not the only way to access commits that are no longer listed in the history.
Sometimes it is even possible to brute-force commits using no more than the first four characters of the hash described in the <a href="https://git-scm.com/book/en/v2/Git-Tools-Revision-Selection#Short-SHA-1">Short SHA-1</a> section of this git documentation.</p>
<p>The only <a href="https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/removing-sensitive-data-from-a-repository">official way</a> to completely delete an online commit (even from all cached views) is to contact the GitHub support directly.</p>
<h2 id="github-secrets">Github Secrets<a aria-hidden="true" tabindex="-1" href="#github-secrets"><span>¶</span></a></h2>
<p>We have developed a tool to identify these dangling or hidden commits and to see if any data are rendered currently visible by this error that should be deleted by the GitHub support.
Generally speaking, there could be more commits linked to your repository than those listed in the general commit history of any branch.
Not all of them are errors or force-pushed commits; this can also happen when merging pull requests etc.
Using a Github API key to scan larger repositories (which can be added as an environment variable) is advisable.</p>
<h2 id="example">Example<a aria-hidden="true" tabindex="-1" href="#example"><span>¶</span></a></h2>
<p>Example repository with a “deleted” commit (not online anymore):
<code>https://github.com/neodyme-labs/github-secrets-demo</code></p>
<center><figure>
						<img src="https://neodyme.io/blog/github_secrets/demo_repo.png" alt="Example repository"/>
						<figcaption>
							<p>
								Example repository
							</p>
						</figcaption>
					</figure>
					<figure>
						<img src="https://neodyme.io/blog/github_secrets/public_commits_demo_repo.png" alt="All commits in the GitHub UI"/>
						<figcaption>
							<p>
								All commits in the GitHub UI
							</p>
						</figcaption>
					</figure>
					</center>
<p>All events of this repository could have been accessed via:
<code>https://api.github.com/repos/neodyme-labs/github-secrets-demo/events</code></p>
<center><figure>
						<img src="https://neodyme.io/blog/github_secrets/all_events.png" alt="All events of a public repository"/>
						<figcaption>
							<p>
								All events of a public repository
							</p>
						</figcaption>
					</figure>
					</center>
<p>As you can see below, there is an empty PushEvent and the previous event has a commit that is not found in the GitHub UI:</p>
<center><figure>
						<img src="https://neodyme.io/blog/github_secrets/force_push_event.png" alt="Example of a force-pushed reset of the git head"/>
						<figcaption>
							<p>
								Example of a force-pushed reset of the git head
							</p>
						</figcaption>
					</figure>
					</center>
<p>Here is the deleted commit as recovered from the events api:
<code>https://github.com/neodyme-labs/github-secrets-demo/commit/ddc0ca8a18c4001fbca0ac433f1d2e7bdd882a68</code></p>
<center><figure>
						<img src="https://neodyme.io/blog/github_secrets/dangling_commit.png" alt="Dangling commit"/>
						<figcaption>
							<p>
								Dangling commit
							</p>
						</figcaption>
					</figure>
					</center>
<p>When you now run our tool, all commits will be displayed directly to you as shown here:</p>
<center><figure>
						<img src="https://neodyme.io/blog/github_secrets/tool_findings.png" alt="Dangling commits found with Github Secrets"/>
						<figcaption>
							<p>
								Dangling commits found with Github Secrets
							</p>
						</figcaption>
					</figure>
					</center>
<p>More information and the tool itself can be found at <a href="https://github.com/neodyme-labs/github-secrets">GitHub</a>.</p>
<p>We hope you have found this blog post and the accompanying tool helpful and informative. In the event that you have inadvertently disclosed sensitive information via a git commit, we highly recommend promptly cycling all affected secrets. It is crucial to take this precaution, as you never know who may have already pulled the information.</p>  </div></div>
  </body>
</html>
