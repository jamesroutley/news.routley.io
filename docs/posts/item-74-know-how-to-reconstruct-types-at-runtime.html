<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://effectivetypescript.com/2024/10/31/runtime-types/">Original</a>
    <h1>Item 74: Know How to Reconstruct Types at Runtime</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p><em>This is a sample item from Chapter 9 of the second edition of <a target="_blank" rel="noopener" href="https://amzn.to/3UjPrsK" onclick="return trackOutboundLink(&#39;item  know how to reconstruct types at runtime&#39;, &#39;https://amzn.to/3UjPrsK&#39;, event);">Effective TypeScript</a>, which was <a href="https://effectivetypescript.com/2024/05/21/second-edition/">released</a> in May of 2024. It explains your options when you need to access a type at runtime, for example to perform request validation.  If you like what you read, consider <a target="_blank" rel="noopener" href="https://amzn.to/3UjPrsK" onclick="return trackOutboundLink(&#39;item  know how to reconstruct types at runtime&#39;, &#39;https://amzn.to/3UjPrsK&#39;, event);">buying a copy</a> of the book!</em></p>
<p><em>The item tries to be balanced in presenting the pros and cons of each approach. But in my own projects, I avoid Zod and use the third option instead (Generate Runtime Values from Your Types). I like TypeScript, and I&#39;d like to define my types using its syntax!</em></p>
<p>At some point in the process of learning TypeScript, most developers have an epiphany when they realize that TypeScript types aren&#39;t &#34;real&#34;: they&#39;re <a target="_blank" rel="noopener" href="https://github.com/microsoft/typescript/wiki/faq#what-is-type-erasure" onclick="return trackOutboundLink(&#39;item  know how to reconstruct types at runtime&#39;, &#39;https://github.com/microsoft/typescript/wiki/faq#what-is-type-erasure&#39;, event);">erased</a> at runtime. This might be accompanied by a feeling of dread: if the types aren&#39;t real, how can you trust them?</p>
<p>The independence of types from runtime behavior is a key part of the relationship between TypeScript and JavaScript (<a target="_blank" rel="noopener" href="https://github.com/danvk/effective-typescript/blob/main/samples/ch-intro/ts-vs-js.md" onclick="return trackOutboundLink(&#39;item  know how to reconstruct types at runtime&#39;, &#39;https://github.com/danvk/effective-typescript/blob/main/samples/ch-intro/ts-vs-js.md&#39;, event);">Item 1</a>). And most of the time this system works very well. But there are undeniably times when it would be extremely convenient to have access to TypeScript types at runtime. This item explores how this situation might arise and what your options are.</p>
<p>Imagine you&#39;re implementing a web server and you define an API endpoint for creating a comment on a blog post. You define a TypeScript type for the request body:</p>
<figure><div><pre><code><span>interface</span> CreateComment {</code></pre></div></figure>

<p>Your request handler should validate the request. Some of this validation will be at the application level (does <code>postId</code> reference a post that exists and that the user can comment on?), but some will be at the type level (does the request have all the properties we expect, are they of the right type, and are there any extra properties?).</p>
<p>Here&#39;s what that might look like:</p>
<figure><div><pre><code>app.post(<span>&#39;/comment&#39;</span>, <span>(<span>request, response</span>) =&gt;</span> {</code></pre></div></figure>

<p>This is already a lot of validation code, even with just three properties. Worse, there&#39;s nothing to ensure that the checks are accurate and in sync with our type. Nothing checks that we spelled the properties correctly. And if we add a new property, we&#39;ll need to remember to add a check, too.</p>
<p>This is code duplication at its worst. We have two things (a type and validation logic) that need to stay in sync. It would be better if there was a single source of truth. The <code>interface</code> seems like the natural source of truth, but it&#39;s erased at runtime so it&#39;s unclear how you&#39;d use it in this way.</p>
<p>Let&#39;s look at a few possible solutions to this conundrum.</p>
<h2 id="Generate-the-Types-from-Another-Source"><a href="#Generate-the-Types-from-Another-Source" title="Generate the Types from Another Source"></a>Generate the Types from Another Source</h2><p>If your API is specified in some other form, perhaps using GraphQL or an OpenAPI schema, then you can use that as the source of truth and generate your TypeScript types from it.</p>
<p>This typically involves running an external tool to generate types and, possibly, validation code. An OpenAPI spec uses JSON Schema, for example, so you can use a tool like <a target="_blank" rel="noopener" href="https://github.com/bcherny/json-schema-to-typescript" onclick="return trackOutboundLink(&#39;generate the types from another source&#39;, &#39;https://github.com/bcherny/json-schema-to-typescript&#39;, event);">json-schema-to-typescript</a> to generate the TypeScript types, and a JSON Schema validator such as <a target="_blank" rel="noopener" href="https://ajv.js.org/" onclick="return trackOutboundLink(&#39;generate the types from another source&#39;, &#39;https://ajv.js.org/&#39;, event);">Ajv</a> to validate requests.</p>
<p>The downside of this approach is that it adds some complexity and a build step that must be run whenever your API schema changes. But if you&#39;re already specifying your API using OpenAPI or some other system, then this has the enormous advantage of not introducing any new sources of truth, and this is the approach that you should prefer.</p>
<p>If this is a good fit for your situation, then <a target="_blank" rel="noopener" href="https://github.com/danvk/effective-typescript/blob/main/samples/ch-design/consider-codegen.md" onclick="return trackOutboundLink(&#39;generate the types from another source&#39;, &#39;https://github.com/danvk/effective-typescript/blob/main/samples/ch-design/consider-codegen.md&#39;, event);">Item 42</a> of <a target="_blank" rel="noopener" href="https://amzn.to/3UjPrsK" onclick="return trackOutboundLink(&#39;generate the types from another source&#39;, &#39;https://amzn.to/3UjPrsK&#39;, event);"><em>Effective TypeScript</em></a> includes an example of generating TypeScript types from a schema.</p>
<h2 id="Define-Types-with-a-Runtime-Library"><a href="#Define-Types-with-a-Runtime-Library" title="Define Types with a Runtime Library"></a>Define Types with a Runtime Library</h2><p>TypeScript&#39;s design makes it impossible to derive runtime values from static types. But going the other direction (from a runtime value to a static type) is straightforward using the type-level <code>typeof</code> operator:</p>
<figure><div><pre><code><span>const</span> val = { <span>postId</span>: <span>&#39;123&#39;</span>, <span>title</span>: <span>&#39;First&#39;</span>, <span>body</span>: <span>&#39;That is all&#39;</span>};</code></pre></div></figure>

<p>So one option is to define your types using runtime constructs and derive the static types from those. This is typically done using a library. There are many of these, but at the moment the most popular is <a target="_blank" rel="noopener" href="https://zod.dev/" onclick="return trackOutboundLink(&#39;define types with a runtime library&#39;, &#39;https://zod.dev/&#39;, event);">Zod</a> (React&#39;s <code>PropTypes</code> is another example).</p>
<p>Here&#39;s how the request validation logic would look with Zod:</p>
<figure><div><pre><code><span>import</span> { z } <span>from</span> <span>&#39;zod&#39;</span>;</code></pre></div></figure>

<p>Zod has completely eliminated the duplication: the value <code>createCommentSchema</code> is now the source of truth, and both the static type <code>CreateComment</code> and the schema validation (<code>createCommentSchema.parse</code>) are derived from that.</p>
<p>Zod and the other runtime type libraries are quite effective at solving this problem. So what are the downsides to using them?</p>
<ul>
<li>You now have two ways to define types: Zod&#39;s syntax (<code>z.object</code>) and TypeScript&#39;s (<code>interface</code>). While these systems have many similarities, they&#39;re not exactly the same. You&#39;re already using TypeScript, so presumably your team has committed to learning how to define types using it. Now everyone needs to learn to use Zod as well.</li>
<li>Runtime type systems tend to be contagious: if <code>createCommentSchema</code> needs to reference another type, then that type will also need to be reworked into a runtime type. This may make it hard to interoperate with other sources of types, for example, if you wanted to reference a type from an external library or generate some types from your database using a tool like <a target="_blank" rel="noopener" href="https://github.com/adelsz/pgtyped" onclick="return trackOutboundLink(&#39;define types with a runtime library&#39;, &#39;https://github.com/adelsz/pgtyped&#39;, event);">PgTyped</a> or <a target="_blank" rel="noopener" href="https://github.com/danvk/pg-to-ts" onclick="return trackOutboundLink(&#39;define types with a runtime library&#39;, &#39;https://github.com/danvk/pg-to-ts&#39;, event);">pg-to-ts</a>.</li>
</ul>
<p>Having a distinct runtime type validation system also comes with a few advantages:</p>
<ul>
<li>Libraries like Zod can express many constraints that are hard to capture with TypeScript types, for example, &#34;a valid email address&#34; or &#34;an integer.&#34; If you don&#39;t use a tool like Zod, you&#39;ll have to write this sort of validation yourself.</li>
<li>There&#39;s no additional build step. Everything is done through TypeScript. If you expect your schema to change frequently, then this will eliminate a failure mode and tighten your iteration cycle.</li>
</ul>
<h2 id="Generate-Runtime-Values-from-Your-Types"><a href="#Generate-Runtime-Values-from-Your-Types" title="Generate Runtime Values from Your Types"></a>Generate Runtime Values from Your Types</h2><p>If you&#39;re willing to introduce a new tool and build step, then there&#39;s another possibility: you can reverse the approach from the previous section and generate a runtime value from your TypeScript type. JSON Schema is a popular target.</p>
<p>To make this work we&#39;ll put our API types in an <em>api.ts</em> file:</p>
<figure><div><pre><code><span>// api.ts</span></code></pre></div></figure>

<p>then we can run <a target="_blank" rel="noopener" href="https://github.com/YousefED/typescript-json-schema" onclick="return trackOutboundLink(&#39;generate runtime values from your types&#39;, &#39;https://github.com/YousefED/typescript-json-schema&#39;, event);">typescript-json-schema</a> to generate JSON Schema for this type:</p>
<figure><div><pre><code>$ npx typescript-json-schema api.ts <span>&#39;*&#39;</span> &gt; api.schema.json<br/></code></pre></div></figure>

<p>Here&#39;s what that file looks like:</p>
<figure><div><pre><code>{</code></pre></div></figure>

<p>Now we can load <em>api.schema.json</em> at runtime. If you enable TypeScript&#39;s <code>resolveJsonModule</code> option, this can be done with an ordinary <code>import</code>. You can perform validation using any JSON Schema validation library. Here we use the <a target="_blank" rel="noopener" href="https://ajv.js.org/" onclick="return trackOutboundLink(&#39;generate runtime values from your types&#39;, &#39;https://ajv.js.org/&#39;, event);">Ajv</a> library:</p>
<figure><div><pre><code><span>import</span> Ajv <span>from</span> <span>&#39;ajv&#39;</span>;</code></pre></div></figure>

<p>The great strength of generating values from your TypeScript types is that you can continue to use all the TypeScript tools you know and love to define your types. You don&#39;t need to learn a second way to define types since the JSON Schema is an implementation detail. Your API types can reference types from <code>@types</code> or other sources since they&#39;re just TypeScript types.</p>
<p>The downside is that you&#39;ve introduced a new tool and a new build step. Whenever you change <em>api.ts</em>, you&#39;ll need to regenerate <em>api.schema.json</em>. In practice, you&#39;d want to enforce that these stay in sync using your continuous integration system.</p>
<p>While you don&#39;t typically need to access TypeScript types at runtime, there are occasionally situations like input validation where it&#39;s extremely useful. We&#39;ve seen three approaches to this problem. So which one should you choose?</p>
<p>Unfortunately, there&#39;s no perfect answer. Each option is a trade-off. If your types are already expressed in some other form, like an OpenAPI schema, then use that as the source of truth for both your types and your validation logic. This will incur some tooling and process overhead, but it&#39;s worth it to have a single source of truth.</p>
<p>If not, then the decision is trickier. Would you rather introduce a build step or a second way to define types? If you need to reference types that are only defined using TypeScript types (perhaps they&#39;re coming from a library or are generated), then generating JSON Schema from your TypeScript types is the best option. Otherwise, you need to pick your poison!</p>
<h2 id="Things-to-Remember"><a href="#Things-to-Remember" title="Things to Remember"></a>Things to Remember</h2><ul>
<li>TypeScript types are erased before your code is run. You can&#39;t access them at runtime without additional tooling.</li>
<li>Know your options for runtime types: using a distinct runtime type system (such as Zod), generating TypeScript types from values (<code>json-schema-to-typescript</code>), and generating values from your TypeScript types (<code>typescript-json-schema</code>).</li>
<li>If you have another specification for your types (e.g., a schema), use that as the source of truth.</li>
<li>If you need to reference external TypeScript types, use <code>typescript-json-schema</code> or an equivalent.</li>
<li>Otherwise, weigh whether you prefer another build step or another system for specifying types.</li>
</ul>

          </div></div>
  </body>
</html>
