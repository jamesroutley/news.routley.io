<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/lucasvegi/Elixir-Code-Smells">Original</a>
    <h1>Catalog of Elixir-specific code smells</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto"><a href="https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2Flucasvegi%2FElixir-Code-Smells%2Fblob%2Fmain%2Fcode_smells.livemd" rel="nofollow"><img src="https://camo.githubusercontent.com/f11e6f405a80ab11c3e4490f864a761a780abf9f50bb8feeb7dc94ee299eba26/68747470733a2f2f6c697665626f6f6b2e6465762f62616467652f76312f626c61636b2e737667" alt="Run in Livebook" data-canonical-src="https://livebook.dev/badge/v1/black.svg"/></a></p>
<p dir="auto"><a href="https://github.com/lucasvegi/Elixir-Code-Smells/commits/main"><img src="https://camo.githubusercontent.com/7414d6a6aae4b046c15ed12afd5cbb6c51c19a82f5fcf6469151fc9da8205354/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f6c6173742d636f6d6d69742f6c75636173766567692f456c697869722d436f64652d536d656c6c73" alt="GitHub last commit" data-canonical-src="https://img.shields.io/github/last-commit/lucasvegi/Elixir-Code-Smells"/></a>
<a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Fgithub.com%2Flucasvegi%2FElixir-Code-Smells&amp;via=lucasvegi&amp;text=Catalog%20of%20Elixir-specific%20code%20smells%3A&amp;hashtags=MyElixirStatus%2CElixirLang" rel="nofollow"><img src="https://camo.githubusercontent.com/6f187bb5e9d0df68f3116f812ca51363e6b846932cfff09ef7bf3e9ba08d132b/68747470733a2f2f696d672e736869656c64732e696f2f747769747465722f75726c3f7374796c653d736f6369616c2675726c3d68747470732533412532462532466769746875622e636f6d2532466c7563617376656769253246456c697869722d436f64652d536d656c6c73" alt="Twitter URL" data-canonical-src="https://img.shields.io/twitter/url?style=social&amp;url=https%3A%2F%2Fgithub.com%2Flucasvegi%2FElixir-Code-Smells"/></a></p>
<h2 dir="auto"><a id="user-content-table-of-contents" aria-hidden="true" href="#table-of-contents"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Table of Contents</h2>
<ul dir="auto">
<li><strong><a href="#introduction">Introduction</a></strong></li>
<li><strong><a href="#design-related-smells">Design-related smells</a></strong>
<ul dir="auto">
<li><a href="#genserver-envy">GenServer Envy</a></li>
<li><a href="#agent-obsession">Agent Obsession</a></li>
<li><a href="#unsupervised-process">Unsupervised process</a></li>
<li><a href="#large-messages-between-processes">Large messages between processes</a></li>
<li><a href="#complex-multi-clause-function">Complex multi-clause function</a></li>
<li><a href="#complex-extraction-in-clauses">Complex extraction in clauses</a> <sup><a href="#user-content-fn-**-2462f38ac7ce1527b61dbf3da42f847a" id="user-content-fnref-**-2462f38ac7ce1527b61dbf3da42f847a" data-footnote-ref="" aria-describedby="footnote-label">1</a></sup></li>
<li><a href="#complex-branching">Complex branching</a></li>
<li><a href="#complex-else-clauses-in-with">Complex else clauses in with</a> <sup><a href="#user-content-fn-**-2462f38ac7ce1527b61dbf3da42f847a" id="user-content-fnref-**-2-2462f38ac7ce1527b61dbf3da42f847a" data-footnote-ref="" aria-describedby="footnote-label">1</a></sup></li>
<li><a href="#exceptions-for-control-flow">Exceptions for control-flow</a></li>
<li><a href="#untested-polymorphic-behavior">Untested polymorphic behavior</a></li>
<li><a href="#alternative-return-types">Alternative return types</a> <sup><a href="#user-content-fn-**-2462f38ac7ce1527b61dbf3da42f847a" id="user-content-fnref-**-3-2462f38ac7ce1527b61dbf3da42f847a" data-footnote-ref="" aria-describedby="footnote-label">1</a></sup></li>
<li><a href="#code-organization-by-process">Code organization by process</a></li>
<li><a href="#data-manipulation-by-migration">Data manipulation by migration</a></li>
</ul>
</li>
<li><strong><a href="#low-level-concerns-smells">Low-level concerns smells</a></strong>
<ul dir="auto">
<li><a href="#working-with-invalid-data">Working with invalid data</a></li>
<li><a href="#mapstruct-dynamic-access">Map/struct dynamic access</a></li>
<li><a href="#unplanned-value-extraction">Unplanned value extraction</a></li>
<li><a href="#modules-with-identical-names">Modules with identical names</a></li>
<li><a href="#unnecessary-macro">Unnecessary macro</a></li>
<li><a href="#large-code-generation">Large code generation</a> <sup><a href="#user-content-fn-**-2462f38ac7ce1527b61dbf3da42f847a" id="user-content-fnref-**-4-2462f38ac7ce1527b61dbf3da42f847a" data-footnote-ref="" aria-describedby="footnote-label">1</a></sup></li>
<li><a href="#app-configuration-for-code-libs">App configuration for code libs</a></li>
<li><a href="#compile-time-app-configuration">Compile-time app configuration</a></li>
<li><a href="#dependency-with-use-when-an-import-is-enough">Dependency with &#34;use&#34; when an &#34;import&#34; is enough</a></li>
</ul>
</li>
<li><strong><a href="#about">About</a></strong></li>
</ul>
<h2 dir="auto"><a id="user-content-introduction" aria-hidden="true" href="#introduction"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Introduction</h2>
<p dir="auto"><a href="http://elixir-lang.org" rel="nofollow">Elixir</a> is a new functional programming language whose popularity is rising in the industry <sup><a href="https://elixir-companies.com/" rel="nofollow">link</a></sup>. However, there are few works in the scientific literature focused on studying the internal quality of systems implemented in this language.</p>
<p dir="auto">In order to better understand the types of sub-optimal code structures that can harm the internal quality of Elixir systems, we scoured websites, blogs, forums, and videos (grey literature review), looking for specific code smells for Elixir that are discussed by its developers.</p>
<p dir="auto">As a result of this investigation, we have initially proposed a catalog of 18 new smells that are specific to Elixir systems. Other smells are being suggested by the community, so this catalog is constantly being updated <strong>(currently 22 smells)</strong>. These code smells are categorized into two different groups (<a href="#design-related-smells">design-related</a> and <a href="#low-level-concerns-smells">low-level concerns</a>), according to the type of impact and code extent they affect. This catalog of Elixir-specific code smells is presented below. Each code smell is documented using the following structure:</p>
<ul dir="auto">
<li><strong>Name:</strong> Unique identifier of the code smell. This name is important to facilitate communication between developers;</li>
<li><strong>Category:</strong> The portion of code affected by smell and its severity;</li>
<li><strong>Problem:</strong> How the code smell can harm code quality and what impacts this can have for developers;</li>
<li><strong>Example:</strong> Code and textual descriptions to illustrate the occurrence of the code smell;</li>
<li><strong>Refactoring:</strong> Ways to change smelly code in order to improve its qualities. Examples of refactored code are presented to illustrate these changes.</li>
</ul>
<p dir="auto">The objective of this catalog of code smells is to instigate the improvement of the quality of code developed in Elixir. For this reason, we are interested in knowing Elixir&#39;s community opinion about these code smells: <em>Do you agree that these code smells can be harmful? Have you seen any of them in production code? Do you have any suggestions about some Elixir-specific code smell not cataloged by us?...</em></p>
<p dir="auto">Please feel free to make pull requests and suggestions (<a href="https://github.com/lucasvegi/Elixir-Code-Smells/issues">Issues</a> tab). We want to hear from you!</p>
<p dir="auto"><a href="#table-of-contents">▲ back to Index</a></p>
<h2 dir="auto"><a id="user-content-design-related-smells" aria-hidden="true" href="#design-related-smells"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Design-related smells</h2>
<p dir="auto">Design-related smells are more complex, affect a coarse-grained code element, and are therefore harder to detect. In this section, 13 different smells classified as design-related are explained and exemplified:</p>
<h3 dir="auto"><a id="user-content-genserver-envy" aria-hidden="true" href="#genserver-envy"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>GenServer Envy</h3>
<ul dir="auto">
<li>
<p dir="auto"><strong>Category:</strong> Design-related smell.</p>
</li>
<li>
<p dir="auto"><strong>Problem:</strong> In Elixir, processes can be primitively created by <code>Kernel.spawn/1</code>, <code>Kernel.spawn/3</code>, <code>Kernel.spawn_link/1</code> and <code>Kernel.spawn_link/3</code> functions. Although it is possible to create them this way, it is more common to use abstractions (e.g., <a href="https://hexdocs.pm/elixir/1.13/Agent.html" rel="nofollow"><code>Agent</code></a>, <a href="https://hexdocs.pm/elixir/1.13/Task.html" rel="nofollow"><code>Task</code></a>, and <a href="https://hexdocs.pm/elixir/master/GenServer.html" rel="nofollow"><code>GenServer</code></a>) provided by Elixir to create processes. The use of each specific abstraction is not a code smell in itself; however, there can be trouble when either a <code>Task</code> or <code>Agent</code> is used beyond its suggested purposes, being treated like a <code>GenServer</code>.</p>
</li>
<li>
<p dir="auto"><strong>Example:</strong> As shown next, <code>Agent</code> and <code>Task</code> are abstractions to create processes with specialized purposes. In contrast, <code>GenServer</code> is a more generic abstraction used to create processes for many different purposes:</p>
<ul dir="auto">
<li><code>Agent</code>: As Elixir works on the principle of immutability, by default no value is shared between multiple places of code, enabling read and write as in a global variable. An <code>Agent</code> is a simple process abstraction focused on solving this limitation, enabling processes to share state.</li>
<li><code>Task</code>: This process abstraction is used when we only need to execute some specific action asynchronously, often in an isolated way, without communication with other processes.</li>
<li><code>GenServer</code>: This is the most generic process abstraction. The main benefit of this abstraction is explicitly segregating the server and the client roles, thus providing a better API for the organization of processes communication. Besides that, a <code>GenServer</code> can also encapsulate state (like an <code>Agent</code>), provide sync and async calls (like a <code>Task</code>), and more.</li>
</ul>
<p dir="auto">Examples of this code smell appear when <code>Agents</code> or <code>Tasks</code> are used for general purposes and not only for specialized ones such as their documentation suggests. To illustrate some smell occurrences, we will cite two specific situations. 1) When a <code>Task</code> is used not only to async execute an action, but also to frequently exchange messages with other processes; 2) When an <code>Agent</code>, beside sharing some global value between processes, is also frequently used to execute isolated tasks that are not of interest to other processes.</p>
</li>
<li>
<p dir="auto"><strong>Refactoring:</strong> When an <code>Agent</code> or <code>Task</code> goes beyond its suggested use cases and becomes painful, it is better to refactor it into a <code>GenServer</code>.</p>
</li>
</ul>
<p dir="auto"><a href="#table-of-contents">▲ back to Index</a></p>
<hr/>
<h3 dir="auto"><a id="user-content-agent-obsession" aria-hidden="true" href="#agent-obsession"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Agent Obsession</h3>
<ul dir="auto">
<li>
<p dir="auto"><strong>Category:</strong> Design-related smell.</p>
</li>
<li>
<p dir="auto"><strong>Problem:</strong> In Elixir, an <code>Agent</code> is a process abstraction focused on sharing information between processes by means of message passing. It is a simple wrapper around shared information, thus facilitating its read and update from any place in the code. The use of an <code>Agent</code> to share information is not a code smell in itself; however, when the responsibility for interacting directly with an <code>Agent</code> is spread across the entire system, this can be problematic. This bad practice can increase the difficulty of code maintenance and make the code more prone to bugs.</p>
</li>
<li>
<p dir="auto"><strong>Example:</strong> The following code seeks to illustrate this smell. The responsibility for interacting directly with the <code>Agent</code> is spread across four different modules (i.e, <code>A</code>, <code>B</code>, <code>C</code>, and <code>D</code>).</p>
<div data-snippet-clipboard-copy-content="defmodule A do
  #...
  def update(pid) do
    #...
    Agent.update(pid, fn _list -&gt; 123 end)
    #...
  end
end"><pre><span>defmodule</span> <span>A</span> <span>do</span>
  <span>#...</span>
  <span>def</span> <span>update</span><span>(</span><span>pid</span><span>)</span> <span>do</span>
    <span>#...</span>
    <span>Agent</span><span>.</span><span>update</span><span>(</span><span>pid</span><span>,</span> <span>fn</span> <span>_list</span> <span>-&gt;</span> <span>123</span> <span>end</span><span>)</span>
    <span>#...</span>
  <span>end</span>
<span>end</span></pre></div>
<div data-snippet-clipboard-copy-content="defmodule B do
  #...
  def update(pid) do
    #...
    Agent.update(pid, fn content -&gt; %{a: content} end)
    #...
  end
end"><pre><span>defmodule</span> <span>B</span> <span>do</span>
  <span>#...</span>
  <span>def</span> <span>update</span><span>(</span><span>pid</span><span>)</span> <span>do</span>
    <span>#...</span>
    <span>Agent</span><span>.</span><span>update</span><span>(</span><span>pid</span><span>,</span> <span>fn</span> <span>content</span> <span>-&gt;</span> <span>%</span><span>{</span><span>a: </span><span>content</span><span>}</span> <span>end</span><span>)</span>
    <span>#...</span>
  <span>end</span>
<span>end</span></pre></div>
<div data-snippet-clipboard-copy-content="defmodule C do
  #...
  def update(pid) do
    #...
    Agent.update(pid, fn content -&gt; [:atom_value | [content]] end)
    #...
  end
end"><pre><span>defmodule</span> <span>C</span> <span>do</span>
  <span>#...</span>
  <span>def</span> <span>update</span><span>(</span><span>pid</span><span>)</span> <span>do</span>
    <span>#...</span>
    <span>Agent</span><span>.</span><span>update</span><span>(</span><span>pid</span><span>,</span> <span>fn</span> <span>content</span> <span>-&gt;</span> <span>[</span><span>:atom_value</span> <span>|</span> <span>[</span><span>content</span><span>]</span><span>]</span> <span>end</span><span>)</span>
    <span>#...</span>
  <span>end</span>
<span>end</span></pre></div>
<div data-snippet-clipboard-copy-content="defmodule D do
  #...
  def get(pid) do
    #...
    Agent.get(pid, fn content -&gt; content end)
    #...
  end
end"><pre><span>defmodule</span> <span>D</span> <span>do</span>
  <span>#...</span>
  <span>def</span> <span>get</span><span>(</span><span>pid</span><span>)</span> <span>do</span>
    <span>#...</span>
    <span>Agent</span><span>.</span><span>get</span><span>(</span><span>pid</span><span>,</span> <span>fn</span> <span>content</span> <span>-&gt;</span> <span>content</span> <span>end</span><span>)</span>
    <span>#...</span>
  <span>end</span>
<span>end</span></pre></div>
<p dir="auto">This spreading of responsibility can generate duplicated code and make code maintenance more difficult. Also, due to the lack of control over the format of the shared data, complex composed data can be shared. This freedom to use any format of data is dangerous and can induce developers to introduce bugs.</p>
<div data-snippet-clipboard-copy-content="# start an agent with initial state of an empty list
iex(1)&gt; {:ok, agent} = Agent.start_link fn -&gt; [] end
{:ok, #PID&lt;0.135.0&gt;}

# many data format (i.e., List, Map, Integer, Atom) are
# combined through direct access spread across the entire system
iex(2)&gt; A.update(agent)
iex(3)&gt; B.update(agent)
iex(4)&gt; C.update(agent)

# state of shared information
iex(5)&gt; D.get(agent)
[:atom_value, %{a: 123}]"><pre><span># start an agent with initial state of an empty list</span>
<span>iex</span><span>(</span><span>1</span><span>)</span><span>&gt;</span> <span>{</span><span>:ok</span><span>,</span> <span>agent</span><span>}</span> <span>=</span> <span>Agent</span><span>.</span><span>start_link</span> <span>fn</span> <span>-&gt;</span> <span>[</span><span>]</span> <span>end</span>
<span>{</span><span>:ok</span><span>,</span> <span>#PID&lt;0.135.0&gt;}</span>

<span># many data format (i.e., List, Map, Integer, Atom) are</span>
<span># combined through direct access spread across the entire system</span>
<span>iex</span><span>(</span><span>2</span><span>)</span><span>&gt;</span> <span>A</span><span>.</span><span>update</span><span>(</span><span>agent</span><span>)</span>
<span>iex</span><span>(</span><span>3</span><span>)</span><span>&gt;</span> <span>B</span><span>.</span><span>update</span><span>(</span><span>agent</span><span>)</span>
iex<span>(</span><span>4</span><span>)</span><span>&gt;</span> <span>C</span><span>.</span><span>update</span><span>(</span><span>agent</span><span>)</span>

<span># state of shared information</span>
<span>iex</span><span>(</span><span>5</span><span>)</span><span>&gt;</span> <span>D</span><span>.</span><span>get</span><span>(</span><span>agent</span><span>)</span>
<span>[</span><span>:atom_value</span><span>,</span> <span>%</span><span>{</span><span>a: </span><span>123</span><span>}</span><span>]</span>
<span></span></pre></div>
</li>
<li>
<p dir="auto"><strong>Refactoring:</strong> Instead of spreading direct access to an <code>Agent</code> over many places in the code, it is better to refactor this code by centralizing the responsibility for interacting with an <code>Agent</code> in a single module. This refactoring improves the maintainability by removing duplicated code; it also allows you to limit the accepted format for shared data, reducing bug-proneness. As shown below, the module <code>KV.Bucket</code> is centralizing the responsibility for interacting with the <code>Agent</code>. Any other place in the code that needs to access shared data must now delegate this action to <code>KV.Bucket</code>. Also, <code>KV.Bucket</code> now only allows data to be shared in <code>Map</code> format.</p>
<div data-snippet-clipboard-copy-content="defmodule KV.Bucket do
  use Agent

  @doc &#34;&#34;&#34;
  Starts a new bucket.
  &#34;&#34;&#34;
  def start_link(_opts) do
    Agent.start_link(fn -&gt; %{} end)
  end

  @doc &#34;&#34;&#34;
  Gets a value from the `bucket` by `key`.
  &#34;&#34;&#34;
  def get(bucket, key) do
    Agent.get(bucket, &amp;Map.get(&amp;1, key))
  end

  @doc &#34;&#34;&#34;
  Puts the `value` for the given `key` in the `bucket`.
  &#34;&#34;&#34;
  def put(bucket, key, value) do
    Agent.update(bucket, &amp;Map.put(&amp;1, key, value))
  end
end"><pre><span>defmodule</span> <span>KV.Bucket</span> <span>do</span>
  <span>use</span> <span>Agent</span>

  <span>@</span><span>doc</span> <span>&#34;&#34;&#34;</span>
<span>  Starts a new bucket.</span>
<span>  &#34;&#34;&#34;</span>
  <span>def</span> <span>start_link</span><span>(</span><span>_opts</span><span>)</span> <span>do</span>
    <span>Agent</span><span>.</span><span>start_link</span><span>(</span><span>fn</span> <span>-&gt;</span> <span>%</span><span>{</span><span>}</span> <span>end</span><span>)</span>
  <span>end</span>

  <span>@</span><span>doc</span> <span>&#34;&#34;&#34;</span>
<span>  Gets a value from the `bucket` by `key`.</span>
<span>  &#34;&#34;&#34;</span>
  <span>def</span> <span>get</span><span>(</span><span>bucket</span><span>,</span> <span>key</span><span>)</span> <span>do</span>
    <span>Agent</span><span>.</span><span>get</span><span>(</span><span>bucket</span><span>,</span> <span>&amp;</span><span>Map</span><span>.</span><span>get</span><span>(</span><span>&amp;</span><span>1</span><span>,</span> <span>key</span><span>)</span><span>)</span>
  <span>end</span>

  <span>@</span><span>doc</span> <span>&#34;&#34;&#34;</span>
<span>  Puts the `value` for the given `key` in the `bucket`.</span>
<span>  &#34;&#34;&#34;</span>
  <span>def</span> <span>put</span><span>(</span><span>bucket</span><span>,</span> <span>key</span><span>,</span> <span>value</span><span>)</span> <span>do</span>
    <span>Agent</span><span>.</span><span>update</span><span>(</span><span>bucket</span><span>,</span> <span>&amp;</span><span>Map</span><span>.</span><span>put</span><span>(</span><span>&amp;</span><span>1</span><span>,</span> <span>key</span><span>,</span> <span>value</span><span>)</span><span>)</span>
  <span>end</span>
<span>end</span></pre></div>
<p dir="auto">The following are examples of how to delegate access to shared data (provided by an <code>Agent</code>) to <code>KV.Bucket</code>.</p>
<div data-snippet-clipboard-copy-content="# start an agent through a `KV.Bucket`
iex(1)&gt; {:ok, bucket} = KV.Bucket.start_link(%{})
{:ok, #PID&lt;0.114.0&gt;}

# add shared values to the keys `milk` and `beer`
iex(2)&gt; KV.Bucket.put(bucket, &#34;milk&#34;, 3)
iex(3)&gt; KV.Bucket.put(bucket, &#34;beer&#34;, 7)

# accessing shared data of specific keys
iex(4)&gt; KV.Bucket.get(bucket, &#34;beer&#34;)
7
iex(5)&gt; KV.Bucket.get(bucket, &#34;milk&#34;)
3"><pre><span># start an agent through a `KV.Bucket`</span>
<span>iex</span><span>(</span><span>1</span><span>)</span><span>&gt;</span> <span>{</span><span>:ok</span><span>,</span> <span>bucket</span><span>}</span> <span>=</span> <span>KV.Bucket</span><span>.</span><span>start_link</span><span>(</span><span>%</span><span>{</span><span>}</span><span>)</span>
<span>{</span><span>:ok</span><span>,</span> <span>#PID&lt;0.114.0&gt;}</span>

<span># add shared values to the keys `milk` and `beer`</span>
<span>iex</span><span>(</span><span>2</span><span>)</span><span>&gt;</span> <span>KV.Bucket</span><span>.</span><span>put</span><span>(</span><span>bucket</span><span>,</span> <span>&#34;milk&#34;</span><span>,</span> <span>3</span><span>)</span>
<span>iex</span><span>(</span><span>3</span><span>)</span><span>&gt;</span> <span>KV.Bucket</span><span>.</span><span>put</span><span>(</span><span>bucket</span><span>,</span> <span>&#34;beer&#34;</span><span>,</span> <span>7</span><span>)</span>

<span># accessing shared data of specific keys</span>
<span>iex</span><span>(</span><span>4</span><span>)</span><span>&gt;</span> <span>KV.Bucket</span><span>.</span><span>get</span><span>(</span><span>bucket</span><span>,</span> <span>&#34;beer&#34;</span><span>)</span>
<span>7</span>
<span>iex</span><span>(</span><span>5</span><span>)</span><span>&gt;</span> <span>KV.Bucket</span><span>.</span><span>get</span><span>(</span><span>bucket</span><span>,</span> <span>&#34;milk&#34;</span><span>)</span>
<span>3</span></pre></div>
<p dir="auto">These examples are based on code written in Elixir&#39;s official documentation. Source: <a href="https://elixir-lang.org/getting-started/mix-otp/agent.html#agents" rel="nofollow">link</a></p>
</li>
</ul>
<p dir="auto"><a href="#table-of-contents">▲ back to Index</a></p>
<hr/>
<h3 dir="auto"><a id="user-content-unsupervised-process" aria-hidden="true" href="#unsupervised-process"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Unsupervised process</h3>
<ul dir="auto">
<li>
<p dir="auto"><strong>Category:</strong> Design-related smell.</p>
</li>
<li>
<p dir="auto"><strong>Problem:</strong> In Elixir, creating a process outside a supervision tree is not a code smell in itself. However, when code creates a large number of long-running processes outside a supervision tree, this can make visibility and monitoring of these processes difficult, preventing developers from fully controlling their applications.</p>
</li>
<li>
<p dir="auto"><strong>Example:</strong> The following code example seeks to illustrate a library responsible for maintaining a numerical <code>Counter</code> through a <code>GenServer</code> process outside a supervision tree. Multiple counters can be created simultaneously by a client (one process for each counter), making these unsupervised processes difficult to manage. This can cause problems with the initialization, restart, and shutdown of a system.</p>
<div data-snippet-clipboard-copy-content="defmodule Counter do
  use GenServer

  @moduledoc &#34;&#34;&#34;
    Global counter implemented through a GenServer process
    outside a supervision tree.
  &#34;&#34;&#34;

  @doc &#34;&#34;&#34;
    Function to create a counter.
      initial_value: any integer value.
      pid_name: optional parameter to define the process name.
                Default is Counter.
  &#34;&#34;&#34;
  def start(initial_value, pid_name \\ __MODULE__)
    when is_integer(initial_value) do
    GenServer.start(__MODULE__, initial_value, name: pid_name)
  end

  @doc &#34;&#34;&#34;
    Function to get the counter&#39;s current value.
      pid_name: optional parameter to inform the process name.
                Default is Counter.
  &#34;&#34;&#34;
  def get(pid_name \\ __MODULE__) do
    GenServer.call(pid_name, :get)
  end

  @doc &#34;&#34;&#34;
    Function to changes the counter&#39;s current value.
    Returns the updated value.
      value: amount to be added to the counter.
      pid_name: optional parameter to inform the process name.
                Default is Counter.
  &#34;&#34;&#34;
  def bump(value, pid_name \\ __MODULE__) do
    GenServer.call(pid_name, {:bump, value})
    get(pid_name)
  end

  ## Callbacks

  @impl true
  def init(counter) do
    {:ok, counter}
  end

  @impl true
  def handle_call(:get, _from, counter) do
    {:reply, counter, counter}
  end

  def handle_call({:bump, value}, _from, counter) do
    {:reply, counter, counter + value}
  end
end

#...Use examples...

iex(1)&gt; Counter.start(0)
{:ok, #PID&lt;0.115.0&gt;}

iex(2)&gt; Counter.get()
0

iex(3)&gt; Counter.start(15, C2)
{:ok, #PID&lt;0.120.0&gt;}

iex(4)&gt; Counter.get(C2)
15

iex(5)&gt; Counter.bump(-3, C2)
12

iex(6)&gt; Counter.bump(7)
7"><pre><span>defmodule</span> <span>Counter</span> <span>do</span>
  <span>use</span> <span>GenServer</span>

  <span>@</span><span>moduledoc</span> <span>&#34;&#34;&#34;</span>
<span>    Global counter implemented through a GenServer process</span>
<span>    outside a supervision tree.</span>
<span>  &#34;&#34;&#34;</span>

  <span>@</span><span>doc</span> <span>&#34;&#34;&#34;</span>
<span>    Function to create a counter.</span>
<span>      initial_value: any integer value.</span>
<span>      pid_name: optional parameter to define the process name.</span>
<span>                Default is Counter.</span>
<span>  &#34;&#34;&#34;</span>
  <span>def</span> <span>start</span><span>(</span><span>initial_value</span><span>,</span> <span>pid_name</span> <span>\\</span> <span>__MODULE__</span><span>)</span>
    <span>when</span> <span>is_integer</span><span>(</span><span>initial_value</span><span>)</span> <span>do</span>
    <span>GenServer</span><span>.</span><span>start</span><span>(</span><span>__MODULE__</span><span>,</span> <span>initial_value</span><span>,</span> <span>name: </span><span>pid_name</span><span>)</span>
  <span>end</span>

  <span>@</span><span>doc</span> <span>&#34;&#34;&#34;</span>
<span>    Function to get the counter&#39;s current value.</span>
<span>      pid_name: optional parameter to inform the process name.</span>
<span>                Default is Counter.</span>
<span>  &#34;&#34;&#34;</span>
  <span>def</span> <span>get</span><span>(</span><span>pid_name</span> <span>\\</span> <span>__MODULE__</span><span>)</span> <span>do</span>
    <span>GenServer</span><span>.</span><span>call</span><span>(</span><span>pid_name</span><span>,</span> <span>:get</span><span>)</span>
  <span>end</span>

  <span>@</span><span>doc</span> <span>&#34;&#34;&#34;</span>
<span>    Function to changes the counter&#39;s current value.</span>
<span>    Returns the updated value.</span>
<span>      value: amount to be added to the counter.</span>
<span>      pid_name: optional parameter to inform the process name.</span>
<span>                Default is Counter.</span>
<span>  &#34;&#34;&#34;</span>
  <span>def</span> <span>bump</span><span>(</span><span>value</span><span>,</span> <span>pid_name</span> <span>\\</span> <span>__MODULE__</span><span>)</span> <span>do</span>
    <span>GenServer</span><span>.</span><span>call</span><span>(</span><span>pid_name</span><span>,</span> <span>{</span><span>:bump</span><span>,</span> <span>value</span><span>}</span><span>)</span>
    <span>get</span><span>(</span><span>pid_name</span><span>)</span>
  <span>end</span>

  <span>## Callbacks</span>

  <span>@</span><span>impl</span> <span>true</span>
  <span>def</span> <span>init</span><span>(</span><span>counter</span><span>)</span> <span>do</span>
    <span>{</span><span>:ok</span><span>,</span> <span>counter</span><span>}</span>
  <span>end</span>

  <span>@</span><span>impl</span> <span>true</span>
  <span>def</span> <span>handle_call</span><span>(</span><span>:get</span><span>,</span> <span>_from</span><span>,</span> <span>counter</span><span>)</span> <span>do</span>
    <span>{</span><span>:reply</span><span>,</span> <span>counter</span><span>,</span> <span>counter</span><span>}</span>
  <span>end</span>

  <span>def</span> <span>handle_call</span><span>(</span><span>{</span><span>:bump</span><span>,</span> <span>value</span><span>}</span><span>,</span> <span>_from</span><span>,</span> <span>counter</span><span>)</span> <span>do</span>
    <span>{</span><span>:reply</span><span>,</span> <span>counter</span><span>,</span> <span>counter</span> <span>+</span> <span>value</span><span>}</span>
  <span>end</span>
<span>end</span>

<span>#...Use examples...</span>

<span>iex</span><span>(</span><span>1</span><span>)</span><span>&gt;</span> <span>Counter</span><span>.</span><span>start</span><span>(</span><span>0</span><span>)</span>
<span>{</span><span>:ok</span><span>,</span> <span>#PID&lt;0.115.0&gt;}</span>

<span>iex</span><span>(</span><span>2</span><span>)</span>&gt; <span>Counter</span><span>.</span><span>get</span><span>(</span><span>)</span>
<span>0</span>

<span>iex</span><span>(</span><span>3</span><span>)</span>&gt; <span>Counter</span><span>.</span><span>start</span><span>(</span><span>15</span><span>,</span> <span>C2</span><span>)</span>
<span>{</span><span>:ok</span><span>,</span> <span>#PID&lt;0.120.0&gt;}</span>

<span>iex</span><span>(</span><span>4</span><span>)</span><span>&gt;</span> <span>Counter</span><span>.</span><span>get</span><span>(</span><span>C2</span><span>)</span>
<span>15</span>

<span>iex</span><span>(</span><span>5</span><span>)</span><span>&gt;</span> <span>Counter</span><span>.</span><span>bump</span><span>(</span><span>-</span><span>3</span><span>,</span> <span>C2</span><span>)</span>
<span>12</span>

iex<span>(</span><span>6</span><span>)</span><span>&gt;</span> <span>Counter</span><span>.</span><span>bump</span><span>(</span><span>7</span><span>)</span>
<span>7</span></pre></div>
</li>
<li>
<p dir="auto"><strong>Refactoring:</strong> To ensure that clients of a library have full control over their systems, regardless of the number of processes used and the lifetime of each one, all processes must be started inside a supervision tree. As shown below, this code uses a <code>Supervisor</code> <sup><a href="https://hexdocs.pm/elixir/master/Supervisor.html" rel="nofollow">link</a></sup> as a supervision tree. When this Elixir application is started, two different counters (<code>Counter</code> and <code>C2</code>) are also started as child processes of the <code>Supervisor</code> named <code>App.Supervisor</code>. Both are initialized with zero. By means of this supervision tree, it is possible to manage the lifecycle of all child processes (e.g., stopping or restarting each one), improving the visibility of the entire app.</p>
<div data-snippet-clipboard-copy-content="defmodule SupervisedProcess.Application do
  use Application

  @impl true
  def start(_type, _args) do
    children = [
      # The counters are Supervisor children started via Counter.start(0).
      %{
        id: Counter,
        start: {Counter, :start, [0]}
      },
      %{
        id: C2,
        start: {Counter, :start, [0, C2]}
      }
    ]

    opts = [strategy: :one_for_one, name: App.Supervisor]
    Supervisor.start_link(children, opts)
  end
end

#...Use examples...

iex(1)&gt; Supervisor.count_children(App.Supervisor)
%{active: 2, specs: 2, supervisors: 0, workers: 2}

iex(2)&gt; Counter.get(Counter)
0

iex(3)&gt; Counter.get(C2)
0

iex(4)&gt; Counter.bump(7, Counter)
7

iex(5)&gt; Supervisor.terminate_child(App.Supervisor, Counter)
iex(6)&gt; Supervisor.count_children(App.Supervisor)
%{active: 1, specs: 2, supervisors: 0, workers: 2}  #only one active

iex(7)&gt; Counter.get(Counter)   #Error because it was previously terminated
** (EXIT) no process: the process is not alive...

iex(8)&gt; Supervisor.restart_child(App.Supervisor, Counter)
iex(9)&gt; Counter.get(Counter)   #after the restart, this process can be accessed again
0"><pre><span>defmodule</span> <span>SupervisedProcess.Application</span> <span>do</span>
  <span>use</span> <span>Application</span>

  <span>@</span><span>impl</span> <span>true</span>
  <span>def</span> <span>start</span><span>(</span><span>_type</span><span>,</span> <span>_args</span><span>)</span> <span>do</span>
    <span>children</span> <span>=</span> <span>[</span>
      <span># The counters are Supervisor children started via Counter.start(0).</span>
      <span>%</span><span>{</span>
        <span>id: </span><span>Counter</span><span>,</span>
        <span>start: </span><span>{</span><span>Counter</span><span>,</span> <span>:start</span><span>,</span> <span>[</span><span>0</span><span>]</span><span>}</span>
      <span>}</span><span>,</span>
      <span>%</span><span>{</span>
        <span>id: </span><span>C2</span><span>,</span>
        <span>start: </span><span>{</span><span>Counter</span><span>,</span> <span>:start</span><span>,</span> <span>[</span><span>0</span><span>,</span> <span>C2</span><span>]</span><span>}</span>
      <span>}</span>
    <span>]</span>

    <span>opts</span> <span>=</span> <span>[</span><span>strategy: </span><span>:one_for_one</span><span>,</span> <span>name: </span><span>App.Supervisor</span><span>]</span>
    <span>Supervisor</span><span>.</span><span>start_link</span><span>(</span><span>children</span><span>,</span> <span>opts</span><span>)</span>
  <span>end</span>
<span>end</span>

<span>#...Use examples...</span>

<span>iex</span><span>(</span><span>1</span><span>)</span><span>&gt;</span> <span>Supervisor</span><span>.</span><span>count_children</span><span>(</span><span>App.Supervisor</span><span>)</span>
<span>%</span><span>{</span><span>active: </span><span>2</span><span>,</span> <span>specs: </span><span>2</span><span>,</span> <span>supervisors: </span><span>0</span><span>,</span> <span>workers: </span><span>2</span><span>}</span>

<span>iex</span><span>(</span><span>2</span><span>)</span><span>&gt;</span> <span>Counter</span><span>.</span><span>get</span><span>(</span><span>Counter</span><span>)</span>
<span>0</span>

<span>iex</span><span>(</span><span>3</span><span>)</span><span>&gt;</span> <span>Counter</span><span>.</span><span>get</span><span>(</span><span>C2</span><span>)</span>
<span>0</span>

<span>iex</span><span>(</span><span>4</span><span>)</span><span>&gt;</span> <span>Counter</span><span>.</span><span>bump</span><span>(</span><span>7</span><span>,</span> <span>Counter</span><span>)</span>
<span>7</span>

<span>iex</span><span>(</span><span>5</span><span>)</span><span>&gt;</span> <span>Supervisor</span><span>.</span><span>terminate_child</span><span>(</span><span>App.Supervisor</span><span>,</span> <span>Counter</span><span>)</span>
<span>iex</span><span>(</span><span>6</span><span>)</span><span>&gt;</span> <span>Supervisor</span><span>.</span><span>count_children</span><span>(</span><span>App.Supervisor</span><span>)</span>
<span>%</span><span>{</span><span>active: </span><span>1</span><span>,</span> <span>specs: </span><span>2</span><span>,</span> <span>supervisors: </span><span>0</span><span>,</span> <span>workers: </span><span>2</span><span>}</span>  <span>#only one active</span>

<span>iex</span><span>(</span><span>7</span><span>)</span><span>&gt;</span> <span>Counter</span><span>.</span><span>get</span><span>(</span><span>Counter</span><span>)</span>   <span>#Error because it was previously terminated</span>
<span>**</span> <span>(</span><span>EXIT</span><span>)</span> <span>no</span> <span>process: </span><span>the</span> <span>process</span> <span>is</span> <span>not</span> <span>alive</span><span>...</span>

<span>iex</span><span>(</span><span>8</span><span>)</span><span>&gt;</span> <span>Supervisor</span><span>.</span><span>restart_child</span><span>(</span><span>App.Supervisor</span><span>,</span> <span>Counter</span><span>)</span>
<span>iex</span><span>(</span><span>9</span><span>)</span><span>&gt;</span> <span>Counter</span><span>.</span><span>get</span><span>(</span><span>Counter</span><span>)</span>   <span>#after the restart, this process can be accessed again</span>
<span>0</span></pre></div>
<p dir="auto">These examples are based on codes written in Elixir&#39;s official documentation. Source: <a href="https://hexdocs.pm/elixir/master/library-guidelines.html#avoid-spawning-unsupervised-processes" rel="nofollow">link</a></p>
</li>
</ul>
<p dir="auto"><a href="#table-of-contents">▲ back to Index</a></p>
<hr/>
<h3 dir="auto"><a id="user-content-large-messages-between-processes" aria-hidden="true" href="#large-messages-between-processes"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Large messages between processes</h3>
<ul dir="auto">
<li>
<p dir="auto"><strong>Category:</strong> Design-related smell.</p>
</li>
<li>
<p dir="auto"><strong>Problem:</strong> In Elixir, processes run in an isolated manner, often concurrently with other Elixir. Communication between different processes is performed via message passing. The exchange of messages between processes is not a code smell in itself; however, when processes exchange messages, their contents are copied between them. For this reason, if a huge structure is sent as a message from one process to another, the sender can become blocked, compromising performance. If these large message exchanges occur frequently, the prolonged and frequent blocking of processes can cause a system to behave anomalously.</p>
</li>
<li>
<p dir="auto"><strong>Example:</strong> The following code is composed of two modules which will each run in a different process. As the names suggest, the <code>Sender</code> module has a function responsible for sending messages from one process to another (i.e., <code>send_msg/3</code>). The <code>Receiver</code> module has a function to create a process to receive messages (i.e., <code>create/0</code>) and another one to handle the received messages (i.e., <code>run/0</code>). If a huge structure, such as a list with 1_000_000 different values, is sent frequently from <code>Sender</code> to <code>Receiver</code>, the impacts of this smell could be felt.</p>
<div data-snippet-clipboard-copy-content="defmodule Receiver do
  @doc &#34;&#34;&#34;
    Function for receiving messages from processes.
  &#34;&#34;&#34;
  def run do
    receive do
      {:msg, msg_received} -&gt; msg_received
      {_, _} -&gt; &#34;won&#39;t match&#34;
    end
  end

  @doc &#34;&#34;&#34;
    Create a process to receive a message.
    Messages are received in the run() function of Receiver.
  &#34;&#34;&#34;
  def create do
    spawn(Receiver, :run, [])
  end
end"><pre><span>defmodule</span> <span>Receiver</span> <span>do</span>
  <span>@</span><span>doc</span> <span>&#34;&#34;&#34;</span>
<span>    Function for receiving messages from processes.</span>
<span>  &#34;&#34;&#34;</span>
  <span>def</span> <span>run</span> <span>do</span>
    <span>receive</span> <span>do</span>
      <span>{</span><span>:msg</span><span>,</span> <span>msg_received</span><span>}</span> <span>-&gt;</span> <span>msg_received</span>
      <span>{</span><span>_</span><span>,</span> <span>_</span><span>}</span> <span>-&gt;</span> <span>&#34;won&#39;t match&#34;</span>
    <span>end</span>
  <span>end</span>

  <span>@</span><span>doc</span> <span>&#34;&#34;&#34;</span>
<span>    Create a process to receive a message.</span>
<span>    Messages are received in the run() function of Receiver.</span>
<span>  &#34;&#34;&#34;</span>
  <span>def</span> <span>create</span> <span>do</span>
    <span>spawn</span><span>(</span><span>Receiver</span><span>,</span> <span>:run</span><span>,</span> <span>[</span><span>]</span><span>)</span>
  <span>end</span>
<span>end</span></pre></div>
<div data-snippet-clipboard-copy-content="defmodule Sender do
  @doc &#34;&#34;&#34;
    Function for sending messages between processes.
      pid_receiver: message recipient.
      msg: messages of any type and size can be sent.
      id_msg: used by receiver to decide what to do
              when a message arrives.
              Default is the atom :msg
  &#34;&#34;&#34;
  def send_msg(pid_receiver, msg, id_msg \\ :msg) do
    send(pid_receiver, {id_msg, msg})
  end
end"><pre><span>defmodule</span> <span>Sender</span> <span>do</span>
  <span>@</span><span>doc</span> <span>&#34;&#34;&#34;</span>
<span>    Function for sending messages between processes.</span>
<span>      pid_receiver: message recipient.</span>
<span>      msg: messages of any type and size can be sent.</span>
<span>      id_msg: used by receiver to decide what to do</span>
<span>              when a message arrives.</span>
<span>              Default is the atom :msg</span>
<span>  &#34;&#34;&#34;</span>
  <span>def</span> <span>send_msg</span><span>(</span><span>pid_receiver</span><span>,</span> <span>msg</span><span>,</span> <span>id_msg</span> <span>\\</span> <span>:msg</span><span>)</span> <span>do</span>
    <span>send</span><span>(</span><span>pid_receiver</span><span>,</span> <span>{</span><span>id_msg</span><span>,</span> <span>msg</span><span>}</span><span>)</span>
  <span>end</span>
<span>end</span></pre></div>
<p dir="auto">Examples of large messages between processes:</p>
<div data-snippet-clipboard-copy-content="iex(1)&gt; pid = Receiver.create
#PID&lt;0.144.0&gt;

#Simulating a message with large content - List with length 1_000_000
iex(2)&gt; msg = %{from: inspect(self()), to: inspect(pid), content: Enum.to_list(1..1_000_000)}

iex(3)&gt; Sender.send_msg(pid, msg)
{:msg,
  %{
    content: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
      20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,
      39, 40, 41, 42, 43, 44, 45, 46, 47, ...],
    from: &#34;#PID&lt;0.105.0&gt;&#34;,
    to: &#34;#PID&lt;0.144.0&gt;&#34;
  }}"><pre><span>iex</span><span>(</span><span>1</span><span>)</span><span>&gt;</span> <span>pid</span> <span>=</span> <span>Receiver</span><span>.</span><span>create</span>
<span>#PID&lt;0.144.0&gt;</span>

<span>#Simulating a message with large content - List with length 1_000_000</span>
<span>iex</span><span>(</span><span>2</span><span>)</span><span>&gt;</span> <span>msg</span> <span>=</span> <span>%</span><span>{</span><span>from: </span><span>inspect</span><span>(</span><span>self</span><span>(</span><span>)</span><span>)</span><span>,</span> <span>to: </span><span>inspect</span><span>(</span><span>pid</span><span>)</span><span>,</span> <span>content: </span><span>Enum</span><span>.</span><span>to_list</span><span>(</span><span>1</span><span>..</span><span>1_000_000</span><span>)</span><span>}</span>

<span>iex</span><span>(</span><span>3</span><span>)</span><span>&gt;</span> <span>Sender</span><span>.</span><span>send_msg</span><span>(</span><span>pid</span><span>,</span> <span>msg</span><span>)</span>
<span>{</span><span>:msg</span><span>,</span>
  <span>%</span><span>{</span>
    <span>content: </span><span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>,</span> <span>10</span><span>,</span> <span>11</span><span>,</span> <span>12</span><span>,</span> <span>13</span><span>,</span> <span>14</span><span>,</span> <span>15</span><span>,</span> <span>16</span><span>,</span> <span>17</span><span>,</span> <span>18</span><span>,</span> <span>19</span><span>,</span>
      <span>20</span><span>,</span> <span>21</span><span>,</span> <span>22</span><span>,</span> <span>23</span><span>,</span> <span>24</span><span>,</span> <span>25</span><span>,</span> <span>26</span><span>,</span> <span>27</span><span>,</span> <span>28</span><span>,</span> <span>29</span><span>,</span> <span>30</span><span>,</span> <span>31</span><span>,</span> <span>32</span><span>,</span> <span>33</span><span>,</span> <span>34</span><span>,</span> <span>35</span><span>,</span> <span>36</span><span>,</span> <span>37</span><span>,</span> <span>38</span><span>,</span>
      <span>39</span><span>,</span> <span>40</span><span>,</span> <span>41</span><span>,</span> <span>42</span><span>,</span> <span>43</span><span>,</span> <span>44</span><span>,</span> <span>45</span><span>,</span> <span>46</span><span>,</span> <span>47</span><span>,</span> <span>...</span><span>]</span><span>,</span>
    <span>from: </span><span>&#34;#PID&lt;0.105.0&gt;&#34;</span><span>,</span>
    <span>to: </span><span>&#34;#PID&lt;0.144.0&gt;&#34;</span>
  <span>}</span><span>}</span></pre></div>
<p dir="auto">This example is based on a original code by Samuel Mullen. Source: <a href="https://samuelmullen.com/articles/elixir-processes-send-and-receive/" rel="nofollow">link</a></p>
</li>
</ul>
<p dir="auto"><a href="#table-of-contents">▲ back to Index</a></p>
<hr/>
<h3 dir="auto"><a id="user-content-complex-multi-clause-function" aria-hidden="true" href="#complex-multi-clause-function"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Complex multi-clause function</h3>
<ul dir="auto">
<li>
<p dir="auto"><strong>Category:</strong> Design-related smell.</p>
</li>
<li>
<p dir="auto"><strong>Problem:</strong> Using multi-clause functions in Elixir, to group functions of the same name, is not a code smell in itself. However, due to the great flexibility provided by this programming feature, some developers may abuse the number of guard clauses and pattern matches when defining these grouped functions.</p>
</li>
<li>
<p dir="auto"><strong>Example:</strong> A recurrent example of abusive use of the multi-clause functions is when we’re trying to mix too much business logic into the function definitions. This makes it difficult to read and understand the logic involved in the functions, which may impair code maintainability. Some developers use documentation mechanisms such as <code>@doc</code> annotations to compensate for poor code readability, but unfortunately, with a multi-clause function, we can only use these annotations once per function name, particularly on the first or header function. As shown next, all other variations of the function need to be documented only with comments, a mechanism that cannot automate tests, leaving the code prone to bugs.</p>
<div data-snippet-clipboard-copy-content="@doc &#34;&#34;&#34;
  Update sharp product with 0 or empty count

  ## Examples

    iex&gt; Namespace.Module.update(...)
    expected result...
&#34;&#34;&#34;
def update(%Product{count: nil, material: material})
  when material in [&#34;metal&#34;, &#34;glass&#34;] do
  # ...
end

# update blunt product
def update(%Product{count: count, material: material})
  when count &gt; 0 and material in [&#34;metal&#34;, &#34;glass&#34;] do
  # ...
end

# update animal...
def update(%Animal{count: 1, skin: skin})
  when skin in [&#34;fur&#34;, &#34;hairy&#34;] do
  # ...
end"><pre><span>@</span><span>doc</span> <span>&#34;&#34;&#34;</span>
<span>  Update sharp product with 0 or empty count</span>
<span></span>
<span>  ## Examples</span>
<span></span>
<span>    iex&gt; Namespace.Module.update(...)</span>
<span>    expected result...</span>
<span>&#34;&#34;&#34;</span>
<span>def</span> <span>update</span><span>(</span><span>%</span><span>Product</span><span>{</span><span>count: </span><span>nil</span><span>,</span> <span>material: </span><span>material</span><span>}</span><span>)</span>
  <span>when</span> <span>material</span> <span>in</span> <span>[</span><span>&#34;metal&#34;</span><span>,</span> <span>&#34;glass&#34;</span><span>]</span> <span>do</span>
  <span># ...</span>
<span>end</span>

<span># update blunt product</span>
<span>def</span> <span>update</span><span>(</span><span>%</span><span>Product</span><span>{</span><span>count: </span><span>count</span><span>,</span> <span>material: </span><span>material</span><span>}</span><span>)</span>
  <span>when</span> <span>count</span> <span>&gt;</span> <span>0</span> <span>and</span> <span>material</span> <span>in</span> <span>[</span><span>&#34;metal&#34;</span><span>,</span> <span>&#34;glass&#34;</span><span>]</span> <span>do</span>
  <span># ...</span>
<span>end</span>

<span># update animal...</span>
<span>def</span> <span>update</span><span>(</span><span>%</span><span>Animal</span><span>{</span><span>count: </span><span>1</span><span>,</span> <span>skin: </span><span>skin</span><span>}</span><span>)</span>
  <span>when</span> <span>skin</span> <span>in</span> <span>[</span><span>&#34;fur&#34;</span><span>,</span> <span>&#34;hairy&#34;</span><span>]</span> <span>do</span>
  <span># ...</span>
<span>end</span></pre></div>
</li>
<li>
<p dir="auto"><strong>Refactoring:</strong> As shown below, a possible solution to this smell is to break the business rules that are mixed up in a single complex multi-clause function in several different simple functions. Each function can have a specific <code>@doc</code>, describing its behavior and parameters received. While this refactoring sounds simple, it can have a lot of impact on the function&#39;s current clients, so be careful!</p>
<div data-snippet-clipboard-copy-content="@doc &#34;&#34;&#34;
  Update sharp product

  ## Parameter
    struct: %Product{...}

  ## Examples

    iex&gt; Namespace.Module.update_sharp_product(%Product{...})
    expected result...
&#34;&#34;&#34;
def update_sharp_product(struct) do
  # ...
end

@doc &#34;&#34;&#34;
  Update blunt product

  ## Parameter
    struct: %Product{...}

  ## Examples

    iex&gt; Namespace.Module.update_blunt_product(%Product{...})
    expected result...
&#34;&#34;&#34;
def update_blunt_product(struct) do
  # ...
end

@doc &#34;&#34;&#34;
  Update animal

  ## Parameter
    struct: %Animal{...}

  ## Examples

    iex&gt; Namespace.Module.update_animal(%Animal{...})
    expected result...
&#34;&#34;&#34;
def update_animal(struct) do
  # ...
end"><pre><span>@</span><span>doc</span> <span>&#34;&#34;&#34;</span>
<span>  Update sharp product</span>
<span></span>
<span>  ## Parameter</span>
<span>    struct: %Product{...}</span>
<span></span>
<span>  ## Examples</span>
<span></span>
<span>    iex&gt; Namespace.Module.update_sharp_product(%Product{...})</span>
<span>    expected result...</span>
<span>&#34;&#34;&#34;</span>
<span>def</span> <span>update_sharp_product</span><span>(</span><span>struct</span><span>)</span> <span>do</span>
  <span># ...</span>
<span>end</span>

<span>@</span><span>doc</span> <span>&#34;&#34;&#34;</span>
<span>  Update blunt product</span>
<span></span>
<span>  ## Parameter</span>
<span>    struct: %Product{...}</span>
<span></span>
<span>  ## Examples</span>
<span></span>
<span>    iex&gt; Namespace.Module.update_blunt_product(%Product{...})</span>
<span>    expected result...</span>
<span>&#34;&#34;&#34;</span>
<span>def</span> <span>update_blunt_product</span><span>(</span><span>struct</span><span>)</span> <span>do</span>
  <span># ...</span>
<span>end</span>

<span>@</span><span>doc</span> <span>&#34;&#34;&#34;</span>
<span>  Update animal</span>
<span></span>
<span>  ## Parameter</span>
<span>    struct: %Animal{...}</span>
<span></span>
<span>  ## Examples</span>
<span></span>
<span>    iex&gt; Namespace.Module.update_animal(%Animal{...})</span>
<span>    expected result...</span>
<span>&#34;&#34;&#34;</span>
<span>def</span> <span>update_animal</span><span>(</span><span>struct</span><span>)</span> <span>do</span>
  <span># ...</span>
<span>end</span></pre></div>
<p dir="auto">This example is based on a original code by Syamil MJ (<a href="https://github.com/syamilmj">@syamilmj</a>). Source: <a href="https://syamilmj.com/2021-09-01-elixir-multi-clause-anti-pattern/" rel="nofollow">link</a></p>
</li>
</ul>
<p dir="auto"><a href="#table-of-contents">▲ back to Index</a></p>
<hr/>
<h3 dir="auto"><a id="user-content-complex-extraction-in-clauses" aria-hidden="true" href="#complex-extraction-in-clauses"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Complex extraction in clauses</h3>
<ul dir="auto">
<li>
<p dir="auto"><strong>Category:</strong> Design-related smell.</p>
</li>
<li>
<p dir="auto"><strong>Note:</strong> This smell was suggested by the community via issues (<a href="https://github.com/lucasvegi/Elixir-Code-Smells/issues/9" data-hovercard-type="issue" data-hovercard-url="/lucasvegi/Elixir-Code-Smells/issues/9/hovercard">#9</a>).</p>
</li>
<li>
<p dir="auto"><strong>Problem:</strong> When we use multi-clause functions, it is possible to extract values in the clauses for further usage and for pattern matching/guard checking. This extraction itself does not represent a code smell, but when you have too many clauses or too many arguments, it becomes hard to know which extracted parts are used for pattern/guards and what is used only inside the function body. This smell is related to <a href="#complex-multi-clause-function">Complex multi-clause function</a>, but with implications of its own. It impairs the code readability in a different way.</p>
</li>
<li>
<p dir="auto"><strong>Example:</strong> The following code, although simple, tries to illustrate the occurrence of this code smell. The multi-clause function <code>drive/1</code> is extracting fields of an <code>%User{}</code> struct in its clauses for further usage (<code>name</code>) and for pattern/guard checking (<code>age</code>).</p>
<div data-snippet-clipboard-copy-content="def drive(%User{name: name, age: age}) when age &gt;= 18 do
  &#34;#{name} can drive&#34;
end

def drive(%User{name: name, age: age}) when age &lt; 18 do
  &#34;#{name} cannot drive&#34;
end"><pre><span>def</span> <span>drive</span><span>(</span><span>%</span><span>User</span><span>{</span><span>name: </span><span>name</span><span>,</span> <span>age: </span><span>age</span><span>}</span><span>)</span> <span>when</span> <span>age</span> <span>&gt;=</span> <span>18</span> <span>do</span>
  <span>&#34;<span><span>#{</span><span>name</span><span>}</span></span> can drive&#34;</span>
<span>end</span>

<span>def</span> <span>drive</span><span>(</span><span>%</span><span>User</span><span>{</span><span>name: </span><span>name</span><span>,</span> <span>age: </span><span>age</span><span>}</span><span>)</span> <span>when</span> <span>age</span> <span>&lt;</span> <span>18</span> <span>do</span>
  <span>&#34;<span><span>#{</span><span>name</span><span>}</span></span> cannot drive&#34;</span>
<span>end</span></pre></div>
<p dir="auto">While the example is small and looks like a clear code, try to imagine a situation where <code>drive/1</code> was more complex, having many more clauses, arguments, and extractions. This is the really smelly code!</p>
</li>
<li>
<p dir="auto"><strong>Refactoring:</strong> As shown below, a possible solution to this smell is to extract only pattern/guard related variables in the signature once you have many arguments or multiple clauses:</p>
<div data-snippet-clipboard-copy-content="def drive(%User{age: age} = user) when age &gt;= 18 do
  %User{name: name} = user
  &#34;#{name} can drive&#34;
end

def drive(%User{age: age} = user) when age &lt; 18 do
  %User{name: name} = user
  &#34;#{name} cannot drive&#34;
end"><pre><span>def</span> <span>drive</span><span>(</span><span>%</span><span>User</span><span>{</span><span>age: </span><span>age</span><span>}</span> <span>=</span> <span>user</span><span>)</span> <span>when</span> <span>age</span> <span>&gt;=</span> <span>18</span> <span>do</span>
  <span>%</span><span>User</span><span>{</span><span>name: </span><span>name</span><span>}</span> <span>=</span> <span>user</span>
  <span>&#34;<span><span>#{</span><span>name</span><span>}</span></span> can drive&#34;</span>
<span>end</span>

<span>def</span> <span>drive</span><span>(</span><span>%</span><span>User</span><span>{</span><span>age: </span><span>age</span><span>}</span> <span>=</span> <span>user</span><span>)</span> <span>when</span> <span>age</span> <span>&lt;</span> <span>18</span> <span>do</span>
  <span>%</span><span>User</span><span>{</span><span>name: </span><span>name</span><span>}</span> <span>=</span> <span>user</span>
  <span>&#34;<span><span>#{</span><span>name</span><span>}</span></span> cannot drive&#34;</span>
<span>end</span></pre></div>
<p dir="auto">This example and the refactoring are proposed by José Valim (<a href="https://github.com/josevalim">@josevalim</a>)</p>
</li>
</ul>
<p dir="auto"><a href="#table-of-contents">▲ back to Index</a></p>
<hr/>
<h3 dir="auto"><a id="user-content-complex-branching" aria-hidden="true" href="#complex-branching"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Complex branching</h3>
<ul dir="auto">
<li>
<p dir="auto"><strong>Category:</strong> Design-related smell.</p>
</li>
<li>
<p dir="auto"><strong>Note:</strong> Formerly known as &#34;Complex API error handling&#34;.</p>
</li>
<li>
<p dir="auto"><strong>Problem:</strong> When a function assumes the responsibility of handling multiple errors alone, it can increase its cyclomatic complexity (metric of control-flow) and become incomprehensible. This situation can configure a specific instance of &#34;Long function&#34;, a traditional code smell, but has implications of its own. Under these circumstances, this function could get very confusing, difficult to maintain and test, and therefore bug-proneness.</p>
</li>
<li>
<p dir="auto"><strong>Example:</strong> An example of this code smell is when a function uses the <code>case</code> control-flow structure or other similar constructs (e.g., <code>cond</code>, or <code>receive</code>) to handle multiple variations of response types returned by the same API endpoint. This practice can make the function more complex, long, and difficult to understand, as shown next.</p>
<div data-snippet-clipboard-copy-content="def get_customer(customer_id) do
  case get(&#34;/customers/#{customer_id}&#34;) do
    {:ok, %Tesla.Env{status: 200, body: body}} -&gt; {:ok, body}
    {:ok, %Tesla.Env{body: body}} -&gt; {:error, body}
    {:error, _} = other -&gt; other
  end
end"><pre><span>def</span> <span>get_customer</span><span>(</span><span>customer_id</span><span>)</span> <span>do</span>
  <span>case</span> <span>get</span><span>(</span><span>&#34;/customers/<span><span>#{</span><span>customer_id</span><span>}</span></span>&#34;</span><span>)</span> <span>do</span>
    <span>{</span><span>:ok</span><span>,</span> <span>%</span><span>Tesla.Env</span><span>{</span><span>status: </span><span>200</span><span>,</span> <span>body: </span><span>body</span><span>}</span><span>}</span> <span>-&gt;</span> <span>{</span><span>:ok</span><span>,</span> <span>body</span><span>}</span>
    <span>{</span><span>:ok</span><span>,</span> <span>%</span><span>Tesla.Env</span><span>{</span><span>body: </span><span>body</span><span>}</span><span>}</span> <span>-&gt;</span> <span>{</span><span>:error</span><span>,</span> <span>body</span><span>}</span>
    <span>{</span><span>:error</span><span>,</span> <span>_</span><span>}</span> <span>=</span> <span>other</span> <span>-&gt;</span> <span>other</span>
  <span>end</span>
<span>end</span></pre></div>
<p dir="auto">Although <code>get_customer/1</code> is not really long in this example, it could be. Thinking about this more complex scenario, where a large number of different responses can be provided to the same endpoint, is not a good idea to concentrate all on a single function. This is a risky scenario, where a little typo, or any problem introduced by the programmer in handling a response type, could eventually compromise the handling of all responses from the endpoint (if the function raises an exception, for example).</p>
</li>
<li>
<p dir="auto"><strong>Refactoring:</strong> As shown below, in this situation, instead of concentrating all handlings within the same function,  creating a complex branching, it is better to delegate each branch (handling of a response type) to a different private function. In this way, the code will be cleaner, more concise, and readable.</p>
<div data-snippet-clipboard-copy-content="def get_customer(customer_id) when is_integer(customer_id) do
  case get(&#34;/customers/#{customer_id}&#34;) do
    {:ok, %Tesla.Env{status: 200, body: body}} -&gt; success_api_response(body)
    {:ok, %Tesla.Env{body: body}} -&gt; x_error_api_response(body)
    {:error, _} = other -&gt; y_error_api_response(other)
  end
end

defp success_api_response(body) do
  {:ok, body}
end

defp x_error_api_response(body) do
  {:error, body}
end

defp y_error_api_response(other) do
  other
end"><pre><span>def</span> <span>get_customer</span><span>(</span><span>customer_id</span><span>)</span> <span>when</span> <span>is_integer</span><span>(</span><span>customer_id</span><span>)</span> <span>do</span>
  <span>case</span> <span>get</span><span>(</span><span>&#34;/customers/<span><span>#{</span><span>customer_id</span><span>}</span></span>&#34;</span><span>)</span> <span>do</span>
    <span>{</span><span>:ok</span><span>,</span> <span>%</span><span>Tesla.Env</span><span>{</span><span>status: </span><span>200</span><span>,</span> <span>body: </span><span>body</span><span>}</span><span>}</span> <span>-&gt;</span> <span>success_api_response</span><span>(</span><span>body</span><span>)</span>
    <span>{</span><span>:ok</span><span>,</span> <span>%</span><span>Tesla.Env</span><span>{</span><span>body: </span><span>body</span><span>}</span><span>}</span> <span>-&gt;</span> <span>x_error_api_response</span><span>(</span><span>body</span><span>)</span>
    <span>{</span><span>:error</span><span>,</span> <span>_</span><span>}</span> <span>=</span> <span>other</span> <span>-&gt;</span> <span>y_error_api_response</span><span>(</span><span>other</span><span>)</span>
  <span>end</span>
<span>end</span>

<span>defp</span> <span>success_api_response</span><span>(</span><span>body</span><span>)</span> <span>do</span>
  <span>{</span><span>:ok</span><span>,</span> <span>body</span><span>}</span>
<span>end</span>

<span>defp</span> <span>x_error_api_response</span><span>(</span><span>body</span><span>)</span> <span>do</span>
  <span>{</span><span>:error</span><span>,</span> <span>body</span><span>}</span>
<span>end</span>

<span>defp</span> <span>y_error_api_response</span><span>(</span><span>other</span><span>)</span> <span>do</span>
  <span>other</span>
<span>end</span></pre></div>
<p dir="auto">While this example of refactoring <code>get_customer/1</code> might seem quite more verbose than the original code, remember to imagine a scenario where <code>get_customer/1</code> is responsible for handling a number much larger than three different types of possible responses. This is the smelly scenario!</p>
<p dir="auto">This example is based on code written by Zack <sup><a href="https://elixirforum.com/u/MrDoops" rel="nofollow">MrDoops</a></sup> and Dimitar Panayotov <sup><a href="https://elixirforum.com/u/dimitarvp" rel="nofollow">dimitarvp</a></sup>. Source: <a href="https://elixirforum.com/t/what-are-sort-of-smells-do-you-tend-to-find-in-elixir-code/14971" rel="nofollow">link</a>. We got suggestions from José Valim (<a href="https://github.com/josevalim">@josevalim</a>) on the refactoring.</p>
</li>
</ul>
<p dir="auto"><a href="#table-of-contents">▲ back to Index</a></p>
<hr/>
<h3 dir="auto"><a id="user-content-complex-else-clauses-in-with" aria-hidden="true" href="#complex-else-clauses-in-with"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Complex else clauses in with</h3>
<ul dir="auto">
<li>
<p dir="auto"><strong>Category:</strong> Design-related smell.</p>
</li>
<li>
<p dir="auto"><strong>Note:</strong> This smell was suggested by the community via issues (<a href="https://github.com/lucasvegi/Elixir-Code-Smells/issues/7" data-hovercard-type="issue" data-hovercard-url="/lucasvegi/Elixir-Code-Smells/issues/7/hovercard">#7</a>).</p>
</li>
<li>
<p dir="auto"><strong>Problem:</strong> This code smell refers to <code>with</code> statements that flatten all its error clauses into a single complex <code>else</code> block. This situation is harmful to the code readability and maintainability because difficult to know from which clause the error value came.</p>
</li>
<li>
<p dir="auto"><strong>Example:</strong> An example of this code smell, as shown below, is a function <code>open_decoded_file/1</code> that read a base 64 encoded string content from a file and returns a decoded binary string. This function uses a <code>with</code> statement that needs to handle two possible errors, all of which are concentrated in a single complex <code>else</code> block.</p>
<div data-snippet-clipboard-copy-content="def open_decoded_file(path) do
  with {:ok, encoded} &lt;- File.read(path),
       {:ok, value} &lt;- Base.decode64(encoded) do
    value
  else
      {:error, _} -&gt; :badfile
      :error -&gt; :badencoding
  end
end"><pre><span>def</span> <span>open_decoded_file</span><span>(</span><span>path</span><span>)</span> <span>do</span>
  <span>with</span> <span>{</span><span>:ok</span><span>,</span> <span>encoded</span><span>}</span> <span>&lt;-</span> <span>File</span><span>.</span><span>read</span><span>(</span><span>path</span><span>)</span><span>,</span>
       <span>{</span><span>:ok</span><span>,</span> <span>value</span><span>}</span> <span>&lt;-</span> <span>Base</span><span>.</span><span>decode64</span><span>(</span><span>encoded</span><span>)</span> <span>do</span>
    <span>value</span>
  <span>else</span>
      <span>{</span><span>:error</span><span>,</span> <span>_</span><span>}</span> <span>-&gt;</span> <span>:badfile</span>
      <span>:error</span> <span>-&gt;</span> <span>:badencoding</span>
  <span>end</span>
<span>end</span></pre></div>
</li>
<li>
<p dir="auto"><strong>Refactoring:</strong> As shown below, in this situation, instead of concentrating all error handlings within a single complex <code>else</code> block, it is better to normalize the return types in specific private functions. In this way, due to its organization, the code will be cleaner and more readable.</p>
<div data-snippet-clipboard-copy-content="def open_decoded_file(path) do
  with {:ok, encoded} &lt;- file_read(path),
       {:ok, value} &lt;- base_decode64(encoded) do
    value
  end
end

defp file_read(path) do
  case File.read(path) do
    {:ok, contents} -&gt; {:ok, contents}
    {:error, _} -&gt; :badfile
  end
end

defp base_decode64(contents) do
  case Base.decode64(contents) do
    {:ok, contents} -&gt; {:ok, contents}
    :error -&gt; :badencoding
  end
end"><pre><span>def</span> <span>open_decoded_file</span><span>(</span><span>path</span><span>)</span> <span>do</span>
  <span>with</span> <span>{</span><span>:ok</span><span>,</span> <span>encoded</span><span>}</span> <span>&lt;-</span> <span>file_read</span><span>(</span><span>path</span><span>)</span><span>,</span>
       <span>{</span><span>:ok</span><span>,</span> <span>value</span><span>}</span> <span>&lt;-</span> <span>base_decode64</span><span>(</span><span>encoded</span><span>)</span> <span>do</span>
    <span>value</span>
  <span>end</span>
<span>end</span>

<span>defp</span> <span>file_read</span><span>(</span><span>path</span><span>)</span> <span>do</span>
  <span>case</span> <span>File</span><span>.</span><span>read</span><span>(</span><span>path</span><span>)</span> <span>do</span>
    <span>{</span><span>:ok</span><span>,</span> <span>contents</span><span>}</span> <span>-&gt;</span> <span>{</span><span>:ok</span><span>,</span> <span>contents</span><span>}</span>
    <span>{</span><span>:error</span><span>,</span> <span>_</span><span>}</span> <span>-&gt;</span> <span>:badfile</span>
  <span>end</span>
<span>end</span>

<span>defp</span> <span>base_decode64</span><span>(</span><span>contents</span><span>)</span> <span>do</span>
  <span>case</span> <span>Base</span><span>.</span><span>decode64</span><span>(</span><span>contents</span><span>)</span> <span>do</span>
    <span>{</span><span>:ok</span><span>,</span> <span>contents</span><span>}</span> <span>-&gt;</span> <span>{</span><span>:ok</span><span>,</span> <span>contents</span><span>}</span>
    <span>:error</span> <span>-&gt;</span> <span>:badencoding</span>
  <span>end</span>
<span>end</span></pre></div>
<p dir="auto">This example and the refactoring are proposed by José Valim (<a href="https://github.com/josevalim">@josevalim</a>)</p>
</li>
</ul>
<p dir="auto"><a href="#table-of-contents">▲ back to Index</a></p>
<hr/>
<h3 dir="auto"><a id="user-content-exceptions-for-control-flow" aria-hidden="true" href="#exceptions-for-control-flow"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Exceptions for control-flow</h3>
<ul dir="auto">
<li>
<p dir="auto"><strong>Category:</strong> Design-related smell.</p>
</li>
<li>
<p dir="auto"><strong>Problem:</strong> This smell refers to code that forces developers to handle exceptions for control-flow. Exception handling itself does not represent a code smell, but this should not be the only alternative available to developers to handle an error in client code. When developers have no freedom to decide if an error is exceptional or not, this is considered a code smell.</p>
</li>
<li>
<p dir="auto"><strong>Example:</strong> An example of this code smell, as shown below, is when a library (e.g. <code>MyModule</code>) forces its clients to use <code>try .. rescue</code> statements to capture and evaluate errors. This library does not allow developers to decide if an error is exceptional or not in their applications.</p>
<div data-snippet-clipboard-copy-content="defmodule MyModule do
  def janky_function(value) do
    if is_integer(value) do
      #...
      &#34;Result...&#34;
    else
      raise RuntimeError, message: &#34;invalid argument. Is not integer!&#34;
    end
  end
end"><pre><span>defmodule</span> <span>MyModule</span> <span>do</span>
  <span>def</span> <span>janky_function</span><span>(</span><span>value</span><span>)</span> <span>do</span>
    <span>if</span> <span>is_integer</span><span>(</span><span>value</span><span>)</span> <span>do</span>
      <span>#...</span>
      <span>&#34;Result...&#34;</span>
    <span>else</span>
      <span>raise</span> <span>RuntimeError</span><span>,</span> <span>message: </span><span>&#34;invalid argument. Is not integer!&#34;</span>
    <span>end</span>
  <span>end</span>
<span>end</span></pre></div>
<div data-snippet-clipboard-copy-content="defmodule Client do

  # Client forced to use exceptions for control-flow.
  def foo(arg) do
    try do
      value = MyModule.janky_function(arg)
      &#34;All good! #{value}.&#34;
    rescue
      e in RuntimeError -&gt;
        reason = e.message
        &#34;Uh oh! #{reason}.&#34;
    end
  end

end

#...Use examples...

iex(1)&gt; Client.foo(1)
&#34;All good! Result....&#34;

iex(2)&gt; Client.foo(&#34;lucas&#34;)
&#34;Uh oh! invalid argument. Is not integer!.&#34;"><pre><span>defmodule</span> <span>Client</span> <span>do</span>

  <span># Client forced to use exceptions for control-flow.</span>
  <span>def</span> <span>foo</span><span>(</span><span>arg</span><span>)</span> <span>do</span>
    <span>try</span> <span>do</span>
      <span>value</span> <span>=</span> <span>MyModule</span><span>.</span><span>janky_function</span><span>(</span><span>arg</span><span>)</span>
      <span>&#34;All good! <span><span>#{</span><span>value</span><span>}</span></span>.&#34;</span>
    <span>rescue</span>
      <span>e</span> <span>in</span> <span>RuntimeError</span> <span>-&gt;</span>
        <span>reason</span> <span>=</span> <span>e</span><span>.</span><span>message</span>
        <span>&#34;Uh oh! <span><span>#{</span><span>reason</span><span>}</span></span>.&#34;</span>
    <span>end</span>
  <span>end</span>

<span>end</span>

<span>#...Use examples...</span>

<span>iex</span><span>(</span><span>1</span><span>)</span><span>&gt;</span> <span>Client</span><span>.</span><span>foo</span><span>(</span><span>1</span><span>)</span>
<span>&#34;All good! Result....&#34;</span>

<span>iex</span><span>(</span><span>2</span><span>)</span><span>&gt;</span> <span>Client</span><span>.</span><span>foo</span><span>(</span><span>&#34;lucas&#34;</span><span>)</span>
<span>&#34;Uh oh! invalid argument. Is not integer!.&#34;</span></pre></div>
</li>
<li>
<p dir="auto"><strong>Refactoring:</strong> Library authors should guarantee that clients are not required to use exceptions for control-flow in their applications. As shown below, this can be done by refactoring the library <code>MyModule</code>, providing two versions of the function that forces clients to use exceptions for control-flow (e.g., <code>janky_function</code>). 1) a version with the raised exceptions should have the same name as the smelly one, but with a trailing <code>!</code> (i.e., <code>janky_function!</code>); 2) Another version, without raised exceptions, should have a name identical to the original version (i.e., <code>janky_function</code>), and should return the result wrapped in a tuple.</p>
<div data-snippet-clipboard-copy-content="defmodule MyModule do
  @moduledoc &#34;&#34;&#34;
    Refactored library
  &#34;&#34;&#34;

  @doc &#34;&#34;&#34;
    Refactored version without exceptions for control-flow.
  &#34;&#34;&#34;
  def janky_function(value) do
    if is_integer(value) do
      #...
      {:ok, &#34;Result...&#34;}
    else
      {:error, &#34;invalid argument. Is not integer!&#34;}
    end
  end

  def janky_function!(value) do
    case janky_function(value) do
      {:ok, result} -&gt;
        result
      {:error, message} -&gt;
        raise RuntimeError, message: message
    end
  end
end"><pre><span>defmodule</span> <span>MyModule</span> <span>do</span>
  <span>@</span><span>moduledoc</span> <span>&#34;&#34;&#34;</span>
<span>    Refactored library</span>
<span>  &#34;&#34;&#34;</span>

  <span>@</span><span>doc</span> <span>&#34;&#34;&#34;</span>
<span>    Refactored version without exceptions for control-flow.</span>
<span>  &#34;&#34;&#34;</span>
  <span>def</span> <span>janky_function</span><span>(</span><span>value</span><span>)</span> <span>do</span>
    <span>if</span> <span>is_integer</span><span>(</span><span>value</span><span>)</span> <span>do</span>
      <span>#...</span>
      <span>{</span><span>:ok</span><span>,</span> <span>&#34;Result...&#34;</span><span>}</span>
    <span>else</span>
      <span>{</span><span>:error</span><span>,</span> <span>&#34;invalid argument. Is not integer!&#34;</span><span>}</span>
    <span>end</span>
  <span>end</span>

  <span>def</span> <span>janky_function!</span><span>(</span><span>value</span><span>)</span> <span>do</span>
    <span>case</span> <span>janky_function</span><span>(</span><span>value</span><span>)</span> <span>do</span>
      <span>{</span><span>:ok</span><span>,</span> <span>result</span><span>}</span> <span>-&gt;</span>
        <span>result</span>
      <span>{</span><span>:error</span><span>,</span> <span>message</span><span>}</span> <span>-&gt;</span>
        <span>raise</span> <span>RuntimeError</span><span>,</span> <span>message: </span><span>message</span>
    <span>end</span>
  <span>end</span>
<span>end</span></pre></div>
<p dir="auto">This refactoring gives clients more freedom to decide how to proceed in the event of errors, defining what is exceptional or not in different situations. As shown next, when an error is not exceptional, clients can use specific control-flow structures, such as the <code>case</code> statement along with pattern matching.</p>
<div data-snippet-clipboard-copy-content="defmodule Client do

  # Clients now can also choose to use control-flow structures
  # for control-flow when an error is not exceptional.
  def foo(arg) do
    case MyModule.janky_function(arg) do
      {:ok, value} -&gt; &#34;All good! #{value}.&#34;
      {:error, reason} -&gt; &#34;Uh oh! #{reason}.&#34;
    end
  end

end

#...Use examples...

iex(1)&gt; Client.foo(1)
&#34;All good! Result....&#34;

iex(2)&gt; Client.foo(&#34;lucas&#34;)
&#34;Uh oh! invalid argument. Is not integer!.&#34;"><pre><span>defmodule</span> <span>Client</span> <span>do</span>

  <span># Clients now can also choose to use control-flow structures</span>
  <span># for control-flow when an error is not exceptional.</span>
  <span>def</span> <span>foo</span><span>(</span><span>arg</span><span>)</span> <span>do</span>
    <span>case</span> <span>MyModule</span><span>.</span><span>janky_function</span><span>(</span><span>arg</span><span>)</span> <span>do</span>
      <span>{</span><span>:ok</span><span>,</span> <span>value</span><span>}</span> <span>-&gt;</span> <span>&#34;All good! <span><span>#{</span><span>value</span><span>}</span></span>.&#34;</span>
      <span>{</span><span>:error</span><span>,</span> <span>reason</span><span>}</span> <span>-&gt;</span> <span>&#34;Uh oh! <span><span>#{</span><span>reason</span><span>}</span></span>.&#34;</span>
    <span>end</span>
  <span>end</span>

<span>end</span>

<span>#...Use examples...</span>

<span>iex</span><span>(</span><span>1</span><span>)</span><span>&gt;</span> <span>Client</span><span>.</span><span>foo</span><span>(</span><span>1</span><span>)</span>
<span>&#34;All good! Result....&#34;</span>

<span>iex</span><span>(</span><span>2</span><span>)</span><span>&gt;</span> <span>Client</span><span>.</span><span>foo</span><span>(</span><span>&#34;lucas&#34;</span><span>)</span>
<span>&#34;Uh oh! invalid argument. Is not integer!.&#34;</span></pre></div>
<p dir="auto">This example is based on code written by Tim Austin <sup><a href="https://exercism.org/profiles/neenjaw" rel="nofollow">neenjaw</a></sup> and Angelika Tyborska <sup><a href="https://exercism.org/profiles/angelikatyborska" rel="nofollow">angelikatyborska</a></sup>. Source: <a href="https://exercism.org/tracks/elixir/concepts/try-rescue" rel="nofollow">link</a></p>
</li>
</ul>
<p dir="auto"><a href="#table-of-contents">▲ back to Index</a></p>
<hr/>
<h3 dir="auto"><a id="user-content-untested-polymorphic-behavior" aria-hidden="true" href="#untested-polymorphic-behavior"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Untested polymorphic behavior</h3>
<ul dir="auto">
<li>
<p dir="auto"><strong>Category:</strong> Design-related smell.</p>
</li>
<li>
<p dir="auto"><strong>Problem:</strong> This code smell refers to functions that have protocol-dependent parameters and are therefore polymorphic. A polymorphic function itself does not represent a code smell, but some developers implement these generic functions without accompanying guard clauses, allowing to pass parameters that do not implement the required protocol or that have no meaning.</p>
</li>
<li>
<p dir="auto"><strong>Example:</strong> An instance of this code smell happens when a function uses <code>to_string()</code> to convert data received by parameter. The function <code>to_string()</code> uses the protocol <code>String.Chars</code> for conversions. Many Elixir data types (e.g., <code>BitString</code>, <code>Integer</code>, <code>Float</code>, <code>URI</code>) implement this protocol. However, as shown below, other Elixir data types (e.g., <code>Map</code>) do not implement it and can cause an error in <code>dasherize/1</code> function. Depending on the situation, this behavior can be desired or not. Besides that, it may not make sense to dasherize a <code>URI</code> or a number as shown next.</p>
<div data-snippet-clipboard-copy-content="defmodule CodeSmells do
  def dasherize(data) do
    to_string(data)
    |&gt; String.replace(&#34;_&#34;, &#34;-&#34;)
  end
end

#...Use examples...

iex(1)&gt; CodeSmells.dasherize(&#34;Lucas_Vegi&#34;)
&#34;Lucas-Vegi&#34;

iex(2)&gt; CodeSmells.dasherize(10)  #&lt;= Makes sense?
&#34;10&#34;

iex(3)&gt; CodeSmells.dasherize(URI.parse(&#34;http://www.code_smells.com&#34;)) #&lt;= Makes sense?
&#34;http://www.code-smells.com&#34;

iex(4)&gt; CodeSmells.dasherize(%{last_name: &#34;vegi&#34;, first_name: &#34;lucas&#34;})
** (Protocol.UndefinedError) protocol String.Chars not implemented
for %{first_name: &#34;lucas&#34;, last_name: &#34;vegi&#34;} of type Map"><pre><span>defmodule</span> <span>CodeSmells</span> <span>do</span>
  <span>def</span> <span>dasherize</span><span>(</span><span>data</span><span>)</span> <span>do</span>
    <span>to_string</span><span>(</span><span>data</span><span>)</span>
    <span>|&gt;</span> <span>String</span><span>.</span><span>replace</span><span>(</span><span>&#34;_&#34;</span><span>,</span> <span>&#34;-&#34;</span><span>)</span>
  <span>end</span>
<span>end</span>

<span>#...Use examples...</span>

<span>iex</span><span>(</span><span>1</span><span>)</span><span>&gt;</span> <span>CodeSmells</span><span>.</span><span>dasherize</span><span>(</span><span>&#34;Lucas_Vegi&#34;</span><span>)</span>
<span>&#34;Lucas-Vegi&#34;</span>

<span>iex</span><span>(</span><span>2</span><span>)</span><span>&gt;</span> <span>CodeSmells</span><span>.</span><span>dasherize</span><span>(</span><span>10</span><span>)</span>  <span>#&lt;= Makes sense?</span>
<span>&#34;10&#34;</span>

<span>iex</span><span>(</span><span>3</span><span>)</span><span>&gt;</span> <span>CodeSmells</span><span>.</span><span>dasherize</span><span>(</span><span>URI</span><span>.</span><span>parse</span><span>(</span><span>&#34;http://www.code_smells.com&#34;</span><span>)</span><span>)</span> <span>#&lt;= Makes sense?</span>
<span>&#34;http://www.code-smells.com&#34;</span>

<span>iex</span><span>(</span><span>4</span><span>)</span><span>&gt;</span> <span>CodeSmells</span><span>.</span><span>dasherize</span><span>(</span><span>%</span><span>{</span><span>last_name: </span><span>&#34;vegi&#34;</span><span>,</span> <span>first_name: </span><span>&#34;lucas&#34;</span><span>}</span><span>)</span>
<span>**</span> <span>(</span><span>Protocol.UndefinedError</span><span>)</span> <span>protocol</span> <span>String.Chars</span> <span>not</span> <span>implemented</span>
<span>for</span> <span>%</span><span>{</span><span>first_name: </span><span>&#34;lucas&#34;</span><span>,</span> <span>last_name: </span><span>&#34;vegi&#34;</span><span>}</span> <span>of</span> <span>type</span> <span>Map</span></pre></div>
</li>
<li>
<p dir="auto"><strong>Refactoring:</strong> There are two main alternatives to improve code affected by this smell. <strong>1)</strong> You can either remove the protocol use (i.e., <code>to_string/1</code>), by adding multi-clauses on <code>dasherize/1</code> or just remove it; or <strong>2)</strong> You can document that <code>dasherize/1</code> uses the protocol <code>String.Chars</code> for conversions, showing its consequences. As shown next, we refactored using the first alternative, removing the protocol and restricting <code>dasherize/1</code> parameter only to desired data types (i.e., <code>BitString</code> and <code>Atom</code>). Besides that, we use <code>@doc</code> to validate <code>dasherize/1</code> for desired inputs and to document the behavior to some types that we think don&#39;t make sense for the function (e.g., <code>Integer</code> and <code>URI</code>).</p>
<div data-snippet-clipboard-copy-content="defmodule CodeSmells do
  @doc &#34;&#34;&#34;
    Function that converts underscores to dashes.

    ## Parameter
      data: only BitString and Atom are supported.

    ## Examples

        iex&gt; CodeSmells.dasherize(:lucas_vegi)
        &#34;lucas-vegi&#34;

        iex&gt; CodeSmells.dasherize(&#34;Lucas_Vegi&#34;)
        &#34;Lucas-Vegi&#34;

        iex&gt; CodeSmells.dasherize(%{last_name: &#34;vegi&#34;, first_name: &#34;lucas&#34;})
        ** (FunctionClauseError) no function clause matching in CodeSmells.dasherize/1

        iex&gt; CodeSmells.dasherize(URI.parse(&#34;http://www.code_smells.com&#34;))
        ** (FunctionClauseError) no function clause matching in CodeSmells.dasherize/1

        iex&gt; CodeSmells.dasherize(10)
        ** (FunctionClauseError) no function clause matching in CodeSmells.dasherize/1
  &#34;&#34;&#34;
  def dasherize(data) when is_atom(data) do
    dasherize(Atom.to_string(data))
  end

  def dasherize(data) when is_binary(data) do
    String.replace(data, &#34;_&#34;, &#34;-&#34;)
  end
end

#...Use examples...

iex(1)&gt; CodeSmells.dasherize(:lucas_vegi)
&#34;lucas-vegi&#34;

iex(2)&gt; CodeSmells.dasherize(&#34;Lucas_Vegi&#34;)
&#34;Lucas-Vegi&#34;

iex(3)&gt; CodeSmells.dasherize(10)
** (FunctionClauseError) no function clause matching in CodeSmells.dasherize/1"><pre><span>defmodule</span> <span>CodeSmells</span> <span>do</span>
  <span>@</span><span>doc</span> <span>&#34;&#34;&#34;</span>
<span>    Function that converts underscores to dashes.</span>
<span></span>
<span>    ## Parameter</span>
<span>      data: only BitString and Atom are supported.</span>
<span></span>
<span>    ## Examples</span>
<span></span>
<span>        iex&gt; CodeSmells.dasherize(:lucas_vegi)</span>
<span>        &#34;lucas-vegi&#34;</span>
<span></span>
<span>        iex&gt; CodeSmells.dasherize(&#34;Lucas_Vegi&#34;)</span>
<span>        &#34;Lucas-Vegi&#34;</span>
<span></span>
<span>        iex&gt; CodeSmells.dasherize(%{last_name: &#34;vegi&#34;, first_name: &#34;lucas&#34;})</span>
<span>        ** (FunctionClauseError) no function clause matching in CodeSmells.dasherize/1</span>
<span></span>
<span>        iex&gt; CodeSmells.dasherize(URI.parse(&#34;http://www.code_smells.com&#34;))</span>
<span>        ** (FunctionClauseError) no function clause matching in CodeSmells.dasherize/1</span>
<span></span>
<span>        iex&gt; CodeSmells.dasherize(10)</span>
<span>        ** (FunctionClauseError) no function clause matching in CodeSmells.dasherize/1</span>
<span>  &#34;&#34;&#34;</span>
  <span>def</span> <span>dasherize</span><span>(</span><span>data</span><span>)</span> <span>when</span> <span>is_atom</span><span>(</span><span>data</span><span>)</span> <span>do</span>
    <span>dasherize</span><span>(</span><span>Atom</span><span>.</span><span>to_string</span><span>(</span><span>data</span><span>)</span><span>)</span>
  <span>end</span>

  <span>def</span> <span>dasherize</span><span>(</span><span>data</span><span>)</span> <span>when</span> <span>is_binary</span><span>(</span><span>data</span><span>)</span> <span>do</span>
    <span>String</span><span>.</span><span>replace</span><span>(</span><span>data</span><span>,</span> <span>&#34;_&#34;</span><span>,</span> <span>&#34;-&#34;</span><span>)</span>
  <span>end</span>
<span>end</span>

<span>#...Use examples...</span>

<span>iex</span><span>(</span><span>1</span><span>)</span><span>&gt;</span> <span>CodeSmells</span><span>.</span><span>dasherize</span><span>(</span><span>:lucas_vegi</span><span>)</span>
<span>&#34;lucas-vegi&#34;</span>

<span>iex</span><span>(</span><span>2</span><span>)</span><span>&gt;</span> <span>CodeSmells</span><span>.</span><span>dasherize</span><span>(</span><span>&#34;Lucas_Vegi&#34;</span><span>)</span>
<span>&#34;Lucas-Vegi&#34;</span>

<span>iex</span><span>(</span><span>3</span><span>)</span><span>&gt;</span> <span>CodeSmells</span><span>.</span><span>dasherize</span><span>(</span><span>10</span><span>)</span>
<span>**</span> <span>(</span><span>FunctionClauseError</span><span>)</span> no function clause matching <span>in</span> <span>CodeSmells</span><span>.</span><span>dasherize</span><span>/</span><span>1</span></pre></div>
<p dir="auto">This example is based on code written by José Valim (<a href="https://github.com/josevalim">@josevalim</a>). Source: <a href="http://blog.plataformatec.com.br/2014/09/writing-assertive-code-with-elixir/" rel="nofollow">link</a></p>
</li>
</ul>
<p dir="auto"><a href="#table-of-contents">▲ back to Index</a></p>
<hr/>
<h3 dir="auto"><a id="user-content-alternative-return-types" aria-hidden="true" href="#alternative-return-types"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Alternative return types</h3>
<ul dir="auto">
<li>
<p dir="auto"><strong>Category:</strong> Design-related smell.</p>
</li>
<li>
<p dir="auto"><strong>Note:</strong> This smell was suggested by the community via issues (<a href="https://github.com/lucasvegi/Elixir-Code-Smells/issues/6" data-hovercard-type="issue" data-hovercard-url="/lucasvegi/Elixir-Code-Smells/issues/6/hovercard">#6</a>).</p>
</li>
<li>
<p dir="auto"><strong>Problem:</strong> This code smell refers to functions that receive options (e.g., <code>keyword list</code>) parameters that drastically change its return type. Because options are optional and sometimes set dynamically, if they change the return type it may be hard to understand what the function actually returns.</p>
</li>
<li>
<p dir="auto"><strong>Example:</strong> An example of this code smell, as shown below, is when a library (e.g. <code>AlternativeInteger</code>) has a multi-clause function <code>parse/2</code> with many alternative return types. Depending on the options received as a parameter, the function will have a different return type.</p>
<div data-snippet-clipboard-copy-content="defmodule AlternativeInteger do
  def parse(string, opts) when is_list(opts) do
    case opts[:discard_rest] do
      true -&gt; #only an integer value convert from string parameter
      _   -&gt;  #another return type (e.g., tuple)
    end
  end

  def parse(string, opts \\ :default) do
    #another return type (e.g., tuple)
  end
end

#...Use examples...

iex(1)&gt; AlternativeInteger.parse(&#34;13&#34;)
{13, &#34;...&#34;}

iex(2)&gt; AlternativeInteger.parse(&#34;13&#34;, discard_rest: true)
13

iex(3)&gt; AlternativeInteger.parse(&#34;13&#34;, discard_rest: false)
{13, &#34;...&#34;}"><pre><span>defmodule</span> <span>AlternativeInteger</span> <span>do</span>
  <span>def</span> <span>parse</span><span>(</span><span>string</span><span>,</span> <span>opts</span><span>)</span> <span>when</span> <span>is_list</span><span>(</span><span>opts</span><span>)</span> <span>do</span>
    <span>case</span> <span>opts</span><span>[</span><span>:discard_rest</span><span>]</span> <span>do</span>
      <span>true</span> <span>-&gt;</span> <span>#only an integer value convert from string parameter</span>
      <span>_</span>   <span>-&gt;</span>  <span>#another return type (e.g., tuple)</span>
    <span>end</span>
  <span>end</span>

  <span>def</span> <span>parse</span><span>(</span><span>string</span><span>,</span> <span>opts</span> <span>\\</span> <span>:default</span><span>)</span> <span>do</span>
    <span>#another return type (e.g., tuple)</span>
  <span>end</span>
<span>end</span>

<span>#...Use examples...</span>

<span>iex</span><span>(</span><span>1</span><span>)</span><span>&gt;</span> <span>AlternativeInteger</span><span>.</span><span>parse</span><span>(</span><span>&#34;13&#34;</span><span>)</span>
<span>{</span><span>13</span><span>,</span> <span>&#34;...&#34;</span><span>}</span>

<span>iex</span><span>(</span><span>2</span><span>)</span><span>&gt;</span> <span>AlternativeInteger</span><span>.</span><span>parse</span><span>(</span><span>&#34;13&#34;</span><span>,</span> <span>discard_rest: </span><span>true</span><span>)</span>
<span>13</span>

<span>iex</span><span>(</span><span>3</span><span>)</span><span>&gt;</span> <span>AlternativeInteger</span><span>.</span><span>parse</span><span>(</span><span>&#34;13&#34;</span><span>,</span> <span>discard_rest: </span><span>false</span><span>)</span>
<span>{</span><span>13</span><span>,</span> <span>&#34;...&#34;</span><span>}</span></pre></div>
</li>
<li>
<p dir="auto"><strong>Refactoring:</strong> To refactor this smell, as shown next, it&#39;s better to add in the library a specific function for each return type (e.g., <code>parse_no_rest/1</code>), no longer delegating this to an options parameter.</p>
<div data-snippet-clipboard-copy-content="defmodule AlternativeInteger do
  def parse_no_rest(string) do
    #only an integer value convert from string parameter
  end

  def parse(string) do
    #another return type (e.g., tuple)
  end
end

#...Use examples...

iex(1)&gt; AlternativeInteger.parse(&#34;13&#34;)
{13, &#34;...&#34;}

iex(2)&gt; AlternativeInteger.parse_no_rest(&#34;13&#34;)
13"><pre><span>defmodule</span> <span>AlternativeInteger</span> <span>do</span>
  <span>def</span> <span>parse_no_rest</span><span>(</span><span>string</span><span>)</span> <span>do</span>
    <span>#only an integer value convert from string parameter</span>
  <span>end</span>

  <span>def</span> <span>parse</span><span>(</span><span>string</span><span>)</span> <span>do</span>
    <span>#another return type (e.g., tuple)</span>
  <span>end</span>
<span>end</span>

<span>#...Use examples...</span>

<span>iex</span><span>(</span><span>1</span><span>)</span><span>&gt;</span> <span>AlternativeInteger</span><span>.</span><span>parse</span><span>(</span><span>&#34;13&#34;</span><span>)</span>
<span>{</span><span>13</span><span>,</span> <span>&#34;...&#34;</span><span>}</span>

<span>iex</span><span>(</span><span>2</span><span>)</span><span>&gt;</span> <span>AlternativeInteger</span><span>.</span><span>parse_no_rest</span><span>(</span><span>&#34;13&#34;</span><span>)</span>
<span>13</span></pre></div>
<p dir="auto">This example and the refactoring are proposed by José Valim (<a href="https://github.com/josevalim">@josevalim</a>)</p>
</li>
</ul>
<p dir="auto"><a href="#table-of-contents">▲ back to Index</a></p>
<hr/>
<h3 dir="auto"><a id="user-content-code-organization-by-process" aria-hidden="true" href="#code-organization-by-process"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Code organization by process</h3>
<ul dir="auto">
<li>
<p dir="auto"><strong>Category:</strong> Design-related smell.</p>
</li>
<li>
<p dir="auto"><strong>Problem:</strong> This smell refers to code that is unnecessarily organized by processes. A process itself does not represent a code smell, but it should only be used to model runtime properties (e.g., concurrency, access to shared resources, event scheduling). When a process is used for code organization, it can create bottlenecks in the system.</p>
</li>
<li>
<p dir="auto"><strong>Example:</strong> An example of this code smell, as shown below, is a library that implements arithmetic operations (e.g., add, subtract) by means of a <code>GenSever</code> process<sup><a href="https://hexdocs.pm/elixir/master/GenServer.html" rel="nofollow">link</a></sup>. If the number of calls to this single process grows, this code organization can compromise the system performance, therefore becoming a bottleneck.</p>
<div data-snippet-clipboard-copy-content="defmodule Calculator do
  use GenServer

  @moduledoc &#34;&#34;&#34;
    Calculator that performs two basic arithmetic operations.
    This code is unnecessarily organized by a GenServer process.
  &#34;&#34;&#34;

  @doc &#34;&#34;&#34;
    Function to perform the sum of two values.
  &#34;&#34;&#34;
  def add(a, b, pid) do
    GenServer.call(pid, {:add, a, b})
  end

  @doc &#34;&#34;&#34;
    Function to perform subtraction of two values.
  &#34;&#34;&#34;
  def subtract(a, b, pid) do
    GenServer.call(pid, {:subtract, a, b})
  end

  def init(init_arg) do
    {:ok, init_arg}
  end

  def handle_call({:add, a, b}, _from, state) do
    {:reply, a + b, state}
  end

  def handle_call({:subtract, a, b}, _from, state) do
    {:reply, a - b, state}
  end
end

# Start a generic server process
iex(1)&gt; {:ok, pid} = GenServer.start_link(Calculator, :init)
{:ok, #PID&lt;0.132.0&gt;}

#...Use examples...
iex(2)&gt; Calculator.add(1, 5, pid)
6

iex(3)&gt; Calculator.subtract(2, 3, pid)
-1"><pre><span>defmodule</span> <span>Calculator</span> <span>do</span>
  <span>use</span> <span>GenServer</span>

  <span>@</span><span>moduledoc</span> <span>&#34;&#34;&#34;</span>
<span>    Calculator that performs two basic arithmetic operations.</span>
<span>    This code is unnecessarily organized by a GenServer process.</span>
<span>  &#34;&#34;&#34;</span>

  <span>@</span><span>doc</span> <span>&#34;&#34;&#34;</span>
<span>    Function to perform the sum of two values.</span>
<span>  &#34;&#34;&#34;</span>
  <span>def</span> <span>add</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>,</span> <span>pid</span><span>)</span> <span>do</span>
    <span>GenServer</span><span>.</span><span>call</span><span>(</span><span>pid</span><span>,</span> <span>{</span><span>:add</span><span>,</span> <span>a</span><span>,</span> <span>b</span><span>}</span><span>)</span>
  <span>end</span>

  <span>@</span><span>doc</span> <span>&#34;&#34;&#34;</span>
<span>    Function to perform subtraction of two values.</span>
<span>  &#34;&#34;&#34;</span>
  <span>def</span> <span>subtract</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>,</span> <span>pid</span><span>)</span> <span>do</span>
    <span>GenServer</span><span>.</span><span>call</span><span>(</span><span>pid</span><span>,</span> <span>{</span><span>:subtract</span><span>,</span> <span>a</span><span>,</span> <span>b</span><span>}</span><span>)</span>
  <span>end</span>

  <span>def</span> <span>init</span><span>(</span><span>init_arg</span><span>)</span> <span>do</span>
    <span>{</span><span>:ok</span><span>,</span> <span>init_arg</span><span>}</span>
  <span>end</span>

  <span>def</span> <span>handle_call</span><span>(</span><span>{</span><span>:add</span><span>,</span> <span>a</span><span>,</span> <span>b</span><span>}</span><span>,</span> <span>_from</span><span>,</span> <span>state</span><span>)</span> <span>do</span>
    <span>{</span><span>:reply</span><span>,</span> <span>a</span> <span>+</span> <span>b</span><span>,</span> <span>state</span><span>}</span>
  <span>end</span>

  <span>def</span> <span>handle_call</span><span>(</span><span>{</span><span>:subtract</span><span>,</span> <span>a</span><span>,</span> <span>b</span><span>}</span><span>,</span> <span>_from</span><span>,</span> <span>state</span><span>)</span> <span>do</span>
    <span>{</span><span>:reply</span><span>,</span> <span>a</span> <span>-</span> <span>b</span><span>,</span> <span>state</span><span>}</span>
  <span>end</span>
<span>end</span>

<span># Start a generic server process</span>
<span>iex</span><span>(</span><span>1</span><span>)</span><span>&gt;</span> <span>{</span><span>:ok</span><span>,</span> <span>pid</span><span>}</span> <span>=</span> <span>GenServer</span><span>.</span><span>start_link</span><span>(</span><span>Calculator</span><span>,</span> <span>:init</span><span>)</span>
<span>{</span><span>:ok</span><span>,</span> <span>#PID&lt;0.132.0&gt;}</span>

<span>#...Use examples...</span>
<span>iex</span><span>(</span><span>2</span><span>)</span><span>&gt;</span> <span>Calculator</span><span>.</span><span>add</span><span>(</span><span>1</span><span>,</span> <span>5</span><span>,</span> <span>pid</span><span>)</span>
<span>6</span>

<span>iex</span><span>(</span><span>3</span><span>)</span><span>&gt;</span> <span>Calculator</span><span>.</span><span>subtract</span><span>(</span><span>2</span><span>,</span> <span>3</span><span>,</span> <span>pid</span><span>)</span>
<span>-</span><span>1</span>
<span></span></pre></div>
</li>
<li>
<p dir="auto"><strong>Refactoring:</strong> In Elixir, as shown next, code organization must be done only by modules and functions. Whenever possible, a library should not impose specific behavior (such as parallelization) on its clients. It is better to delegate this behavioral decision to the developers of clients, thus increasing the potential for code reuse of a library.</p>
<div data-snippet-clipboard-copy-content="defmodule Calculator do
  def add(a, b) do
    a + b
  end

  def subtract(a, b) do
    a - b
  end
end

#...Use examples...

iex(1)&gt; Calculator.add(1, 5)
6

iex(2)&gt; Calculator.subtract(2, 3)
-1"><pre><span>defmodule</span> <span>Calculator</span> <span>do</span>
  <span>def</span> <span>add</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>do</span>
    <span>a</span> <span>+</span> <span>b</span>
  <span>end</span>

  <span>def</span> <span>subtract</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>do</span>
    <span>a</span> <span>-</span> <span>b</span>
  <span>end</span>
<span>end</span>

<span>#...Use examples...</span>

<span>iex</span><span>(</span><span>1</span><span>)</span><span>&gt;</span> <span>Calculator</span><span>.</span><span>add</span><span>(</span><span>1</span><span>,</span> <span>5</span><span>)</span>
<span>6</span>

<span>iex</span><span>(</span><span>2</span><span>)</span><span>&gt;</span> <span>Calculator</span><span>.</span><span>subtract</span><span>(</span><span>2</span><span>,</span> <span>3</span><span>)</span>
<span>-</span><span>1</span></pre></div>
<p dir="auto">This example is based on code provided in Elixir&#39;s official documentation. Source: <a href="https://hexdocs.pm/elixir/master/library-guidelines.html#avoid-using-processes-for-code-organization" rel="nofollow">link</a></p>
</li>
</ul>
<p dir="auto"><a href="#table-of-contents">▲ back to Index</a></p>
<hr/>
<h3 dir="auto"><a id="user-content-data-manipulation-by-migration" aria-hidden="true" href="#data-manipulation-by-migration"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Data manipulation by migration</h3>
<ul dir="auto">
<li>
<p dir="auto"><strong>Category:</strong> Design-related smell.</p>
</li>
<li>
<p dir="auto"><strong>Problem:</strong> This code smell refers to modules that perform both data and structural changes in a database schema via <code>Ecto.Migration</code><sup><a href="https://hexdocs.pm/ecto_sql/Ecto.Migration.html" rel="nofollow">link</a></sup>. Migrations must be used exclusively to modify a database schema over time (e.g., by including or excluding columns and tables). When this responsibility is mixed with data manipulation code, the module becomes less cohesive, more difficult to test, and therefore more prone to bugs.</p>
</li>
<li>
<p dir="auto"><strong>Example:</strong> An example of this code smell is when an <code>Ecto.Migration</code> is used simultaneously to alter a table, adding a new column to it, and also to update all pre-existing data in that table, assigning a value to this new column. As shown below, in addition to adding the <code>is_custom_shop</code> column in the <code>guitars</code> table, this <code>Ecto.Migration</code> changes the value of this column for some specific guitar models.</p>
<div data-snippet-clipboard-copy-content="defmodule GuitarStore.Repo.Migrations.AddIsCustomShopToGuitars do
  use Ecto.Migration

  import Ecto.Query
  alias GuitarStore.Inventory.Guitar
  alias GuitarStore.Repo

  @doc &#34;&#34;&#34;
    A function that modifies the structure of table &#34;guitars&#34;,
    adding column &#34;is_custom_shop&#34; to it. By default, all data
    pre-stored in this table will have the value false stored
    in this new column.

    Also, this function updates the &#34;is_custom_shop&#34; column value
    of some guitar models to true.
  &#34;&#34;&#34;
  def change do
    alter table(&#34;guitars&#34;) do
      add :is_custom_shop, :boolean, default: false
    end
    create index(&#34;guitars&#34;, [&#34;is_custom_shop&#34;])

    custom_shop_entries()
    |&gt; Enum.map(&amp;update_guitars/1)
  end

  @doc &#34;&#34;&#34;
    A function that updates values of column &#34;is_custom_shop&#34; to true.
  &#34;&#34;&#34;
  defp update_guitars({make, model, year}) do
    from(g in Guitar,
      where: g.make == ^make and g.model == ^model and g.year == ^year,
      select: g
    )
    |&gt; Repo.update_all(set: [is_custom_shop: true])
  end

  @doc &#34;&#34;&#34;
    Function that defines which guitar models that need to have the values
    of the &#34;is_custom_shop&#34; column updated to true.
  &#34;&#34;&#34;
  defp custom_shop_entries() do
    [
      {&#34;Gibson&#34;, &#34;SG&#34;, 1999},
      {&#34;Fender&#34;, &#34;Telecaster&#34;, 2020}
    ]
  end
end"><pre><span>defmodule</span> <span>GuitarStore.Repo.Migrations.AddIsCustomShopToGuitars</span> <span>do</span>
  <span>use</span> <span>Ecto.Migration</span>

  <span>import</span> <span>Ecto.Query</span>
  <span>alias</span> <span>GuitarStore.Inventory.Guitar</span>
  <span>alias</span> <span>GuitarStore.Repo</span>

  <span>@</span><span>doc</span> <span>&#34;&#34;&#34;</span>
<span>    A function that modifies the structure of table &#34;guitars&#34;,</span>
<span>    adding column &#34;is_custom_shop&#34; to it. By default, all data</span>
<span>    pre-stored in this table will have the value false stored</span>
<span>    in this new column.</span>
<span></span>
<span>    Also, this function updates the &#34;is_custom_shop&#34; column value</span>
<span>    of some guitar models to true.</span>
<span>  &#34;&#34;&#34;</span>
  <span>def</span> <span>change</span> <span>do</span>
    <span>alter</span> <span>table</span><span>(</span><span>&#34;guitars&#34;</span><span>)</span> <span>do</span>
      <span>add</span> <span>:is_custom_shop</span><span>,</span> <span>:boolean</span><span>,</span> <span>default: </span><span>false</span>
    <span>end</span>
    <span>create</span> <span>index</span><span>(</span><span>&#34;guitars&#34;</span><span>,</span> <span>[</span><span>&#34;is_custom_shop&#34;</span><span>]</span><span>)</span>

    <span>custom_shop_entries</span><span>(</span><span>)</span>
    <span>|&gt;</span> <span>Enum</span><span>.</span><span>map</span><span>(</span><span>&amp;</span><span>update_guitars</span><span>/</span><span>1</span><span>)</span>
  <span>end</span>

  <span>@</span><span>doc</span> <span>&#34;&#34;&#34;</span>
<span>    A function that updates values of column &#34;is_custom_shop&#34; to true.</span>
<span>  &#34;&#34;&#34;</span>
  <span>defp</span> <span>update_guitars</span><span>(</span><span>{</span><span>make</span><span>,</span> <span>model</span><span>,</span> <span>year</span><span>}</span><span>)</span> <span>do</span>
    <span>from</span><span>(</span><span>g</span> <span>in</span> <span>Guitar</span><span>,</span>
      <span>where: </span><span>g</span><span>.</span><span>make</span> <span>==</span> <span>^</span><span>make</span> <span>and</span> <span>g</span><span>.</span><span>model</span> <span>==</span> <span>^</span><span>model</span> <span>and</span> <span>g</span><span>.</span><span>year</span> <span>==</span> <span>^</span><span>year</span><span>,</span>
      <span>select: </span><span>g</span>
    <span>)</span>
    <span>|&gt;</span> <span>Repo</span><span>.</span><span>update_all</span><span>(</span><span>set: </span><span>[</span><span>is_custom_shop: </span><span>true</span><span>]</span><span>)</span>
  <span>end</span>

  <span>@</span><span>doc</span> <span>&#34;&#34;&#34;</span>
<span>    Function that defines which guitar models that need to have the values</span>
<span>    of the &#34;is_custom_shop&#34; column updated to true.</span>
<span>  &#34;&#34;&#34;</span>
  <span>defp</span> <span>custom_shop_entries</span><span>(</span><span>)</span> <span>do</span>
    <span>[</span>
      <span>{</span><span>&#34;Gibson&#34;</span><span>,</span> <span>&#34;SG&#34;</span><span>,</span> <span>1999</span><span>}</span><span>,</span>
      <span>{</span><span>&#34;Fender&#34;</span><span>,</span> <span>&#34;Telecaster&#34;</span><span>,</span> <span>2020</span><span>}</span>
    <span>]</span>
  <span>end</span>
<span>end</span></pre></div>
<p dir="auto">You can run this smelly migration above by going to the root of your project and typing the next command via console:</p>

</li>
<li>
<p dir="auto"><strong>Refactoring:</strong> To remove this code smell, it is necessary to separate the data manipulation in a <code>mix task</code> <sup><a href="https://hexdocs.pm/mix/Mix.html#module-mix-task" rel="nofollow">link</a></sup> different from the module that performs the structural changes in the database via <code>Ecto.Migration</code>. This separation of responsibilities is a best practice for increasing code testability. As shown below, the module <code>AddIsCustomShopToGuitars</code> now use <code>Ecto.Migration</code> only to perform structural changes in the database schema:</p>
<div data-snippet-clipboard-copy-content="defmodule GuitarStore.Repo.Migrations.AddIsCustomShopToGuitars do
  use Ecto.Migration

  @doc &#34;&#34;&#34;
    A function that modifies the structure of table &#34;guitars&#34;,
    adding column &#34;is_custom_shop&#34; to it. By default, all data
    pre-stored in this table will have the value false stored
    in this new column.
  &#34;&#34;&#34;
  def change do
    alter table(&#34;guitars&#34;) do
      add :is_custom_shop, :boolean, default: false
    end

    create index(&#34;guitars&#34;, [&#34;is_custom_shop&#34;])
  end
end"><pre><span>defmodule</span> <span>GuitarStore.Repo.Migrations.AddIsCustomShopToGuitars</span> <span>do</span>
  <span>use</span> <span>Ecto.Migration</span>

  <span>@</span><span>doc</span> <span>&#34;&#34;&#34;</span>
<span>    A function that modifies the structure of table &#34;guitars&#34;,</span>
<span>    adding column &#34;is_custom_shop&#34; to it. By default, all data</span>
<span>    pre-stored in this table will have the value false stored</span>
<span>    in this new column.</span>
<span>  &#34;&#34;&#34;</span>
  <span>def</span> <span>change</span> <span>do</span>
    <span>alter</span> <span>table</span><span>(</span><span>&#34;guitars&#34;</span><span>)</span> <span>do</span>
      <span>add</span> <span>:is_custom_shop</span><span>,</span> <span>:boolean</span><span>,</span> <span>default: </span><span>false</span>
    <span>end</span>

    <span>create</span> <span>index</span><span>(</span><span>&#34;guitars&#34;</span><span>,</span> <span>[</span><span>&#34;is_custom_shop&#34;</span><span>]</span><span>)</span>
  <span>end</span>
<span>end</span></pre></div>
<p dir="auto">Furthermore, the new mix task <code>PopulateIsCustomShop</code>, shown next, has only the responsibility to perform data manipulation, thus improving testability:</p>
<div data-snippet-clipboard-copy-content="defmodule Mix.Tasks.PopulateIsCustomShop do
  @shortdoc &#34;Populates is_custom_shop column&#34;

  use Mix.Task

  import Ecto.Query
  alias GuitarStore.Inventory.Guitar
  alias GuitarStore.Repo

  @requirements [&#34;app.start&#34;]

  def run(_) do
    custom_shop_entries()
    |&gt; Enum.map(&amp;update_guitars/1)
  end

  defp update_guitars({make, model, year}) do
    from(g in Guitar,
      where: g.make == ^make and g.model == ^model and g.year == ^year,
      select: g
    )
    |&gt; Repo.update_all(set: [is_custom_shop: true])
  end

  defp custom_shop_entries() do
    [
      {&#34;Gibson&#34;, &#34;SG&#34;, 1999},
      {&#34;Fender&#34;, &#34;Telecaster&#34;, 2020}
    ]
  end
end"><pre><span>defmodule</span> <span>Mix.Tasks.PopulateIsCustomShop</span> <span>do</span>
  <span>@</span><span>shortdoc</span> <span>&#34;Populates is_custom_shop column&#34;</span>

  <span>use</span> <span>Mix.Task</span>

  <span>import</span> <span>Ecto.Query</span>
  <span>alias</span> <span>GuitarStore.Inventory.Guitar</span>
  <span>alias</span> <span>GuitarStore.Repo</span>

  <span>@</span><span>requirements</span> <span>[</span><span>&#34;app.start&#34;</span><span>]</span>

  <span>def</span> <span>run</span><span>(</span><span>_</span><span>)</span> <span>do</span>
    <span>custom_shop_entries</span><span>(</span><span>)</span>
    <span>|&gt;</span> <span>Enum</span><span>.</span><span>map</span><span>(</span><span>&amp;</span><span>update_guitars</span><span>/</span><span>1</span><span>)</span>
  <span>end</span>

  <span>defp</span> <span>update_guitars</span><span>(</span><span>{</span><span>make</span><span>,</span> <span>model</span><span>,</span> <span>year</span><span>}</span><span>)</span> <span>do</span>
    <span>from</span><span>(</span><span>g</span> <span>in</span> <span>Guitar</span><span>,</span>
      <span>where: </span><span>g</span><span>.</span><span>make</span> <span>==</span> <span>^</span><span>make</span> <span>and</span> <span>g</span><span>.</span><span>model</span> <span>==</span> <span>^</span><span>model</span> <span>and</span> <span>g</span><span>.</span><span>year</span> <span>==</span> <span>^</span><span>year</span><span>,</span>
      <span>select: </span><span>g</span>
    <span>)</span>
    <span>|&gt;</span> <span>Repo</span><span>.</span><span>update_all</span><span>(</span><span>set: </span><span>[</span><span>is_custom_shop: </span><span>true</span><span>]</span><span>)</span>
  <span>end</span>

  <span>defp</span> <span>custom_shop_entries</span><span>(</span><span>)</span> <span>do</span>
    <span>[</span>
      <span>{</span><span>&#34;Gibson&#34;</span><span>,</span> <span>&#34;SG&#34;</span><span>,</span> <span>1999</span><span>}</span><span>,</span>
      <span>{</span><span>&#34;Fender&#34;</span><span>,</span> <span>&#34;Telecaster&#34;</span><span>,</span> <span>2020</span><span>}</span>
    <span>]</span>
  <span>end</span>
<span>end</span></pre></div>
<p dir="auto">You can run this <code>mix task</code> above by typing the next command via console:</p>
<div data-snippet-clipboard-copy-content="  mix populate_is_custom_shop"><pre>  <span>mix</span> <span>populate_is_custom_shop</span></pre></div>
<p dir="auto">This example is based on code originally written by Carlos Souza. Source: <a href="https://www.idopterlabs.com.br/post/criando-uma-mix-task-em-elixir" rel="nofollow">link</a></p>
</li>
</ul>
<p dir="auto"><a href="#table-of-contents">▲ back to Index</a></p>
<h2 dir="auto"><a id="user-content-low-level-concerns-smells" aria-hidden="true" href="#low-level-concerns-smells"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Low-level concerns smells</h2>
<p dir="auto">Low-level concerns smells are more simple than design-related smells and affect a small part of the code. Next, all 9 different smells classified as low-level concerns are explained and exemplified:</p>
<h3 dir="auto"><a id="user-content-working-with-invalid-data" aria-hidden="true" href="#working-with-invalid-data"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Working with invalid data</h3>
<ul dir="auto">
<li>
<p dir="auto"><strong>Category:</strong> Low-level concerns smells.</p>
</li>
<li>
<p dir="auto"><strong>Problem:</strong> This code smell refers to a function that does not validate its parameters&#39; types and therefore can produce internal non-predicted behavior. When an error is raised inside a function due to an invalid parameter value, this can confuse the developers and make it harder to locate and fix the error.</p>
</li>
<li>
<p dir="auto"><strong>Example:</strong> An example of this code smell is when a function receives an invalid parameter and then passes it to a function from a third-party library. This will cause an error (raised deep inside the library function), which may be confusing for the developer who is working with invalid data. As shown next, the function <code>foo/1</code> is a client of a third-party library and doesn&#39;t validate its parameters at the boundary. In this way, it is possible that invalid data will be passed from <code>foo/1</code> to the library, causing a mysterious error.</p>
<div data-snippet-clipboard-copy-content="defmodule MyApp do
  alias ThirdPartyLibrary, as: Library

  def foo(invalid_data) do
    #...some code...
    Library.sum(1, invalid_data)
    #...some code...
  end
end

#...Use examples...

# with valid data is ok
iex(1)&gt; MyApp.foo(2)
3

#with invalid data cause a confusing error deep inside
iex(2)&gt; MyApp.foo(&#34;Lucas&#34;)
** (ArithmeticError) bad argument in arithmetic expression: 1 + &#34;Lucas&#34;
  :erlang.+(1, &#34;Lucas&#34;)
  library.ex:3: ThirdPartyLibrary.sum/2"><pre><span>defmodule</span> <span>MyApp</span> <span>do</span>
  <span>alias</span> <span>ThirdPartyLibrary</span><span>,</span> <span>as: </span><span>Library</span>

  <span>def</span> <span>foo</span><span>(</span><span>invalid_data</span><span>)</span> <span>do</span>
    <span>#...some code...</span>
    <span>Library</span><span>.</span><span>sum</span><span>(</span><span>1</span><span>,</span> <span>invalid_data</span><span>)</span>
    <span>#...some code...</span>
  <span>end</span>
<span>end</span>

<span>#...Use examples...</span>

<span># with valid data is ok</span>
<span>iex</span><span>(</span><span>1</span><span>)</span><span>&gt;</span> <span>MyApp</span><span>.</span><span>foo</span><span>(</span><span>2</span><span>)</span>
<span>3</span>

<span>#with invalid data cause a confusing error deep inside</span>
<span>iex</span><span>(</span><span>2</span><span>)</span><span>&gt;</span> <span>MyApp</span><span>.</span><span>foo</span><span>(</span><span>&#34;Lucas&#34;</span><span>)</span>
<span>**</span> <span>(</span><span>ArithmeticError</span><span>)</span> bad argument <span>in</span> <span>arithmetic</span> <span>expression: </span><span>1</span> <span>+</span> <span>&#34;Lucas&#34;</span>
  <span>:erlang</span><span>.</span><span>+</span><span>(</span><span>1</span><span>,</span> <span>&#34;Lucas&#34;</span><span>)</span>
  <span>library</span><span>.</span><span>ex</span>:<span>3</span>: T<span>hirdPartyLibrary</span><span>.</span><span>sum</span><span>/</span><span>2</span></pre></div>
</li>
<li>
<p dir="auto"><strong>Refactoring:</strong> To remove this code smell, client code must validate input parameters at the boundary with the user, via guard clauses or pattern matching. This will prevent errors from occurring deeply, making them easier to understand. This refactoring will also allow libraries to be implemented without worrying about creating internal protection mechanisms. The next code illustrates the refactoring of <code>foo/1</code>, removing this smell:</p>
<div data-snippet-clipboard-copy-content="defmodule MyApp do
  alias ThirdPartyLibrary, as: Library

  def foo(data) when is_integer(data) do
    #...some code...
    Library.sum(1, data)
    #...some code...
  end
end

#...Use examples...

#with valid data is ok
iex(1)&gt; MyApp.foo(2)
3

# with invalid data errors are easy to locate and fix
iex(2)&gt; MyApp.foo(&#34;Lucas&#34;)
** (FunctionClauseError) no function clause matching in MyApp.foo/1

  The following arguments were given to MyApp.foo/1:

      # 1
      &#34;Lucas&#34;

  my_app.ex:6: MyApp.foo/1"><pre><span>defmodule</span> <span>MyApp</span> <span>do</span>
  <span>alias</span> <span>ThirdPartyLibrary</span><span>,</span> <span>as: </span><span>Library</span>

  <span>def</span> <span>foo</span><span>(</span><span>data</span><span>)</span> <span>when</span> <span>is_integer</span><span>(</span><span>data</span><span>)</span> <span>do</span>
    <span>#...some code...</span>
    <span>Library</span><span>.</span><span>sum</span><span>(</span><span>1</span><span>,</span> <span>data</span><span>)</span>
    <span>#...some code...</span>
  <span>end</span>
<span>end</span>

<span>#...Use examples...</span>

<span>#with valid data is ok</span>
<span>iex</span><span>(</span><span>1</span><span>)</span><span>&gt;</span> <span>MyApp</span><span>.</span><span>foo</span><span>(</span><span>2</span><span>)</span>
<span>3</span>

<span># with invalid data errors are easy to locate and fix</span>
<span>iex</span><span>(</span><span>2</span><span>)</span><span>&gt;</span> <span>MyApp</span><span>.</span><span>foo</span><span>(</span><span>&#34;Lucas&#34;</span><span>)</span>
<span>**</span> <span>(</span><span>FunctionClauseError</span><span>)</span> no function clause matching <span>in</span> <span>MyApp</span><span>.</span><span>foo</span><span>/</span><span>1</span>

  <span>The</span> <span>following</span> <span>arguments</span> <span>were</span> <span>given</span> <span>to</span> <span>MyApp</span><span>.</span><span>foo</span><span>/</span><span>1</span>:

      <span># 1</span>
      <span>&#34;Lucas&#34;</span>

  <span>my_app</span><span>.</span><span>ex</span>:<span>6</span>: M<span>yApp</span><span>.</span><span>foo</span><span>/</span><span>1</span></pre></div>
<p dir="auto">This example is based on code provided in Elixir&#39;s official documentation. Source: <a href="https://hexdocs.pm/elixir/master/library-guidelines.html#avoid-working-with-invalid-data" rel="nofollow">link</a></p>
</li>
</ul>
<p dir="auto"><a href="#table-of-contents">▲ back to Index</a></p>
<hr/>
<h3 dir="auto"><a id="user-content-mapstruct-dynamic-access" aria-hidden="true" href="#mapstruct-dynamic-access"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Map/struct dynamic access</h3>
<ul dir="auto">
<li>
<p dir="auto"><strong>Category:</strong> Low-level concerns smells.</p>
</li>
<li>
<p dir="auto"><strong>Problem:</strong> In Elixir, it is possible to access values from <code>Maps</code>, which are key-value data structures, either strictly or dynamically. When trying to dynamically access the value of a key from a <code>Map</code>, if the informed key does not exist, a null value (<code>nil</code>) will be returned. This return can be confusing and does not allow developers to conclude whether the key is non-existent in the <code>Map</code> or just has no bound value. In this way, this code smell may cause bugs in the code.</p>
</li>
<li>
<p dir="auto"><strong>Example:</strong> The code shown below is an example of this smell. The function <code>plot/1</code> tries to draw a graphic to represent the position of a point in a cartesian plane. This function receives a parameter of <code>Map</code> type with the point attributes, which can be a point of a 2D or 3D cartesian coordinate system. To decide if a point is 2D or 3D, this function uses dynamic access to retrieve values of the <code>Map</code> keys:</p>
<div data-snippet-clipboard-copy-content="defmodule Graphics do
  def plot(point) do
    #...some code...

    # Dynamic access to use point values
    {point[:x], point[:y], point[:z]}

    #...some code...
  end
end

#...Use examples...
iex(1)&gt; point_2d = %{x: 2, y: 3}
%{x: 2, y: 3}

iex(2)&gt; point_3d = %{x: 5, y: 6, z: nil}
%{x: 5, y: 6, z: nil}

iex(3)&gt; Graphics.plot(point_2d)
{2, 3, nil}   # &lt;= ambiguous return

iex(4)&gt; Graphics.plot(point_3d)
{5, 6, nil}"><pre><span>defmodule</span> <span>Graphics</span> <span>do</span>
  <span>def</span> <span>plot</span><span>(</span><span>point</span><span>)</span> <span>do</span>
    <span>#...some code...</span>

    <span># Dynamic access to use point values</span>
    <span>{</span><span>point</span><span>[</span><span>:x</span><span>]</span><span>,</span> <span>point</span><span>[</span><span>:y</span><span>]</span><span>,</span> <span>point</span><span>[</span><span>:z</span><span>]</span><span>}</span>

    <span>#...some code...</span>
  <span>end</span>
<span>end</span>

<span>#...Use examples...</span>
<span>iex</span><span>(</span><span>1</span><span>)</span><span>&gt;</span> <span>point_2d</span> <span>=</span> <span>%</span><span>{</span><span>x: </span><span>2</span><span>,</span> <span>y: </span><span>3</span><span>}</span>
<span>%</span><span>{</span><span>x: </span><span>2</span><span>,</span> <span>y: </span><span>3</span><span>}</span>

<span>iex</span><span>(</span><span>2</span><span>)</span><span>&gt;</span> <span>point_3d</span> <span>=</span> <span>%</span><span>{</span><span>x: </span><span>5</span><span>,</span> <span>y: </span><span>6</span><span>,</span> <span>z: </span><span>nil</span><span>}</span>
<span>%</span><span>{</span><span>x: </span><span>5</span><span>,</span> <span>y: </span><span>6</span><span>,</span> <span>z: </span><span>nil</span><span>}</span>

<span>iex</span><span>(</span><span>3</span><span>)</span><span>&gt;</span> <span>Graphics</span><span>.</span><span>plot</span><span>(</span><span>point_2d</span><span>)</span>
<span>{</span><span>2</span><span>,</span> <span>3</span><span>,</span> <span>nil</span><span>}</span>   <span># &lt;= ambiguous return</span>

<span>iex</span><span>(</span><span>4</span><span>)</span><span>&gt;</span> <span>Graphics</span><span>.</span><span>plot</span><span>(</span><span>point_3d</span><span>)</span>
<span>{</span><span>5</span><span>,</span> <span>6</span><span>,</span> <span>nil</span><span>}</span></pre></div>
<p dir="auto">As can be seen in the example above, even when the key <code>:z</code> does not exist in the <code>Map</code> (<code>point_2d</code>), dynamic access returns the value <code>nil</code>. This return can be dangerous because of its ambiguity. It is not possible to conclude from it whether the <code>Map</code> has the key <code>:z</code> or not. If the function relies on the return value to make decisions about how to plot a point, this can be problematic and even cause errors when testing the code.</p>
</li>
<li>
<p dir="auto"><strong>Refactoring:</strong> To remove this code smell, whenever a <code>Map</code> has keys of <code>Atom</code> type, replace the dynamic access to its values per strict access. When a non-existent key is strictly accessed, Elixir raises an error immediately, allowing developers to find bugs faster. The next code illustrates the refactoring of <code>plot/1</code>, removing this smell:</p>
<div data-snippet-clipboard-copy-content="defmodule Graphics do
  def plot(point) do
    #...some code...

    # Strict access to use point values
    {point.x, point.y, point.z}

    #...some code...
  end
end

#...Use examples...
iex(1)&gt; point_2d = %{x: 2, y: 3}
%{x: 2, y: 3}

iex(2)&gt; point_3d = %{x: 5, y: 6, z: nil}
%{x: 5, y: 6, z: nil}

iex(3)&gt; Graphics.plot(point_2d)
** (KeyError) key :z not found in: %{x: 2, y: 3} # &lt;= explicitly warns that
  graphic.ex:6: Graphics.plot/1                  # &lt;= the z key does not exist!

iex(4)&gt; Graphics.plot(point_3d)
{5, 6, nil}"><pre><span>defmodule</span> <span>Graphics</span> <span>do</span>
  <span>def</span> <span>plot</span><span>(</span><span>point</span><span>)</span> <span>do</span>
    <span>#...some code...</span>

    <span># Strict access to use point values</span>
    <span>{</span><span>point</span><span>.</span><span>x</span><span>,</span> <span>point</span><span>.</span><span>y</span><span>,</span> <span>point</span><span>.</span><span>z</span><span>}</span>

    <span>#...some code...</span>
  <span>end</span>
<span>end</span>

<span>#...Use examples...</span>
<span>iex</span><span>(</span><span>1</span><span>)</span><span>&gt;</span> <span>point_2d</span> <span>=</span> <span>%</span><span>{</span><span>x: </span><span>2</span><span>,</span> <span>y: </span><span>3</span><span>}</span>
<span>%</span><span>{</span><span>x: </span><span>2</span><span>,</span> <span>y: </span><span>3</span><span>}</span>

<span>iex</span><span>(</span><span>2</span><span>)</span><span>&gt;</span> <span>point_3d</span> <span>=</span> <span>%</span><span>{</span><span>x: </span><span>5</span><span>,</span> <span>y: </span><span>6</span><span>,</span> <span>z: </span><span>nil</span><span>}</span>
<span>%</span><span>{</span><span>x: </span><span>5</span><span>,</span> <span>y: </span><span>6</span><span>,</span> <span>z: </span><span>nil</span><span>}</span>

<span>iex</span><span>(</span><span>3</span><span>)</span><span>&gt;</span> <span>Graphics</span><span>.</span><span>plot</span><span>(</span><span>point_2d</span><span>)</span>
<span>**</span> <span>(</span><span>KeyError</span><span>)</span> key <span>:z</span> <span>not</span> <span>found</span> <span>in: </span><span>%</span><span>{</span><span>x: </span><span>2</span><span>,</span> <span>y: </span><span>3</span><span>}</span> <span># &lt;= explicitly warns that</span>
  <span>graphic</span><span>.</span><span>ex</span>:<span>6</span>: G<span>raphics</span><span>.</span><span>plot</span><span>/</span><span>1</span>                  <span># &lt;= the z key does not exist!</span>

<span>iex</span><span>(</span><span>4</span><span>)</span><span>&gt;</span> <span>Graphics</span><span>.</span><span>plot</span><span>(</span><span>point_3d</span><span>)</span>
<span>{</span><span>5</span><span>,</span> <span>6</span><span>,</span> <span>nil</span><span>}</span></pre></div>
<p dir="auto">As shown below, another alternative to refactor this smell is to replace a <code>Map</code> with a <code>struct</code> (named map). By default, structs only support strict access to values. In this way, accesses will always return clear and objective results:</p>
<div data-snippet-clipboard-copy-content="defmodule Point do
  @enforce_keys [:x, :y]
  defstruct [x: nil, y: nil]
end

#...Use examples...
iex(1)&gt; point = %Point{x: 2, y: 3}
%Point{x: 2, y: 3}

iex(2)&gt; point.x   # &lt;= strict access to use point values
2

iex(3)&gt; point.z   # &lt;= trying to access a non-existent key
** (KeyError) key :z not found in: %Point{x: 2, y: 3}

iex(4)&gt; point[:x] # &lt;= by default, struct does not support dynamic access
** (UndefinedFunctionError) ... (Point does not implement the Access behaviour)"><pre><span>defmodule</span> <span>Point</span> <span>do</span>
  <span>@</span><span>enforce_keys</span> <span>[</span><span>:x</span><span>,</span> <span>:y</span><span>]</span>
  <span>defstruct</span> <span>[</span><span>x: </span><span>nil</span><span>,</span> <span>y: </span><span>nil</span><span>]</span>
<span>end</span>

<span>#...Use examples...</span>
<span>iex</span><span>(</span><span>1</span><span>)</span><span>&gt;</span> <span>point</span> <span>=</span> <span>%</span><span>Point</span><span>{</span><span>x: </span><span>2</span><span>,</span> <span>y: </span><span>3</span><span>}</span>
<span>%</span><span>Point</span><span>{</span><span>x: </span><span>2</span><span>,</span> <span>y: </span><span>3</span><span>}</span>

<span>iex</span><span>(</span><span>2</span><span>)</span><span>&gt;</span> <span>point</span><span>.</span><span>x</span>   <span># &lt;= strict access to use point values</span>
<span>2</span>

<span>iex</span><span>(</span><span>3</span><span>)</span><span>&gt;</span> <span>point</span><span>.</span><span>z</span>   <span># &lt;= trying to access a non-existent key</span>
<span>**</span> <span>(</span><span>KeyError</span><span>)</span> key <span>:z</span> <span>not</span> <span>found</span> <span>in: </span><span>%</span><span>Point</span><span>{</span><span>x: </span><span>2</span><span>,</span> <span>y: </span><span>3</span><span>}</span>

<span>iex</span><span>(</span><span>4</span><span>)</span><span>&gt;</span> <span>point</span><span>[</span><span>:x</span><span>]</span> <span># &lt;= by default, struct does not support dynamic access</span>
<span>**</span> <span>(</span><span>UndefinedFunctionError</span><span>)</span> <span>..</span><span>.</span> <span>(</span><span>Point</span> <span>do</span><span>es</span> <span>not</span> <span>implement</span> <span>the</span> <span>Access</span> behaviour<span>)</span></pre></div>
<p dir="auto">These examples are based on code written by José Valim (<a href="https://github.com/josevalim">@josevalim</a>). Source: <a href="http://blog.plataformatec.com.br/2014/09/writing-assertive-code-with-elixir/" rel="nofollow">link</a></p>
</li>
</ul>
<p dir="auto"><a href="#table-of-contents">▲ back to Index</a></p>
<hr/>
<h3 dir="auto"><a id="user-content-unplanned-value-extraction" aria-hidden="true" href="#unplanned-value-extraction"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Unplanned value extraction</h3>
<ul dir="auto">
<li>
<p dir="auto"><strong>Category:</strong> Low-level concerns smells.</p>
</li>
<li>
<p dir="auto"><strong>Problem:</strong> In Elixir, there are many ways to extract key-related values from a URL query string. However, when pattern matching is not used for this purpose, depending on the format of the URL query string, the code may have undesired behavior, such as being able to extract unplanned values instead of forcing a crash. This unplanned value extraction can give a false impression that the code is working correctly, causing bugs.</p>
</li>
<li>
<p dir="auto"><strong>Example:</strong> The code shown below is an example of this smell. The function <code>get_value/2</code> tries to extract a value from a specific key of a URL query string. As it is not implemented using pattern matching, <code>get_value/2</code> always returns a value, regardless of the format of the URL query string passed as a parameter in the call. Sometimes the returned value will be valid; however, if a URL query string with an unexpected format is used in the call, <code>get_value/2</code> will extract incorrect values from it:</p>
<div data-snippet-clipboard-copy-content="defmodule Extract do

  @doc &#34;&#34;&#34;
    Extract value from a key in a URL query string.
  &#34;&#34;&#34;
  def get_value(string, desired_key) do
    parts = String.split(string, &#34;&amp;&#34;)
    Enum.find_value(parts, fn pair -&gt;
      key_value = String.split(pair, &#34;=&#34;)
      Enum.at(key_value, 0) == desired_key &amp;&amp; Enum.at(key_value, 1)
    end)
  end

end

#...Use examples...

# URL query string according to with the planned format - OK!
iex(1)&gt; Extract.get_value(&#34;name=Lucas&amp;university=UFMG&amp;lab=ASERG&#34;, &#34;lab&#34;)
&#34;ASERG&#34;

iex(2)&gt; Extract.get_value(&#34;name=Lucas&amp;university=UFMG&amp;lab=ASERG&#34;, &#34;university&#34;)
&#34;UFMG&#34;

# Unplanned URL query string format - Unplanned value extraction!
iex(3)&gt; Extract.get_value(&#34;name=Lucas&amp;university=institution=UFMG&amp;lab=ASERG&#34;, &#34;university&#34;)
&#34;institution&#34;   # &lt;= why not &#34;institution=UFMG&#34;? or only &#34;UFMG&#34;?"><pre><span>defmodule</span> <span>Extract</span> <span>do</span>

  <span>@</span><span>doc</span> <span>&#34;&#34;&#34;</span>
<span>    Extract value from a key in a URL query string.</span>
<span>  &#34;&#34;&#34;</span>
  <span>def</span> <span>get_value</span><span>(</span><span>string</span><span>,</span> <span>desired_key</span><span>)</span> <span>do</span>
    <span>parts</span> <span>=</span> <span>String</span><span>.</span><span>split</span><span>(</span><span>string</span><span>,</span> <span>&#34;&amp;&#34;</span><span>)</span>
    <span>Enum</span><span>.</span><span>find_value</span><span>(</span><span>parts</span><span>,</span> <span>fn</span> <span>pair</span> <span>-&gt;</span>
      <span>key_value</span> <span>=</span> <span>String</span><span>.</span><span>split</span><span>(</span><span>pair</span><span>,</span> <span>&#34;=&#34;</span><span>)</span>
      <span>Enum</span><span>.</span><span>at</span><span>(</span><span>key_value</span><span>,</span> <span>0</span><span>)</span> <span>==</span> <span>desired_key</span> <span>&amp;&amp;</span> <span>Enum</span><span>.</span><span>at</span><span>(</span><span>key_value</span><span>,</span> <span>1</span><span>)</span>
    <span>end</span><span>)</span>
  <span>end</span>

<span>end</span>

<span>#...Use examples...</span>

<span># URL query string according to with the planned format - OK!</span>
<span>iex</span><span>(</span><span>1</span><span>)</span><span>&gt;</span> <span>Extract</span><span>.</span><span>get_value</span><span>(</span><span>&#34;name=Lucas&amp;university=UFMG&amp;lab=ASERG&#34;</span><span>,</span> <span>&#34;lab&#34;</span><span>)</span>
<span>&#34;ASERG&#34;</span>

<span>iex</span><span>(</span><span>2</span><span>)</span><span>&gt;</span> <span>Extract</span><span>.</span><span>get_value</span><span>(</span><span>&#34;name=Lucas&amp;university=UFMG&amp;lab=ASERG&#34;</span><span>,</span> <span>&#34;university&#34;</span><span>)</span>
<span>&#34;UFMG&#34;</span>

<span># Unplanned URL query string format - Unplanned value extraction!</span>
<span>iex</span><span>(</span><span>3</span><span>)</span><span>&gt;</span> <span>Extract</span><span>.</span><span>get_value</span><span>(</span><span>&#34;name=Lucas&amp;university=institution=UFMG&amp;lab=ASERG&#34;</span><span>,</span> <span>&#34;university&#34;</span><span>)</span>
<span>&#34;institution&#34;</span>   <span># &lt;= why not &#34;institution=UFMG&#34;? or only &#34;UFMG&#34;?</span></pre></div>
</li>
<li>
<p dir="auto"><strong>Refactoring:</strong> To remove this code smell, <code>get_value/2</code> can be refactored through the use of pattern matching. So, if an unexpected URL query string format is used, the function will be crash instead of returning an invalid value. This behavior, shown below, will allow clients to decide how to handle these errors and will not give a false impression that the code is working correctly when unexpected values are extracted:</p>
<div data-snippet-clipboard-copy-content="defmodule Extract do

  @doc &#34;&#34;&#34;
    Extract value from a key in a URL query string.
    Refactored by using pattern matching.
  &#34;&#34;&#34;
  def get_value(string, desired_key) do
    parts = String.split(string, &#34;&amp;&#34;)
    Enum.find_value(parts, fn pair -&gt;
      [key, value] = String.split(pair, &#34;=&#34;) # &lt;= pattern matching
      key == desired_key &amp;&amp; value
    end)
  end

end

#...Use examples...

# URL query string according to with the planned format - OK!
iex(1)&gt; Extract.get_value(&#34;name=Lucas&amp;university=UFMG&amp;lab=ASERG&#34;, &#34;name&#34;)
&#34;Lucas&#34;

# Unplanned URL query string format - Crash explaining the problem to the client!
iex(2)&gt; Extract.get_value(&#34;name=Lucas&amp;university=institution=UFMG&amp;lab=ASERG&#34;, &#34;university&#34;)
** (MatchError) no match of right hand side value: [&#34;university&#34;, &#34;institution&#34;, &#34;UFMG&#34;]
  extract.ex:7: anonymous fn/2 in Extract.get_value/2 # &lt;= left hand: [key, value] pair

iex(3)&gt; Extract.get_value(&#34;name=Lucas&amp;university&amp;lab=ASERG&#34;, &#34;university&#34;)
** (MatchError) no match of right hand side value: [&#34;university&#34;]
  extract.ex:7: anonymous fn/2 in Extract.get_value/2 # &lt;= left hand: [key, value] pair"><pre><span>defmodule</span> <span>Extract</span> <span>do</span>

  <span>@</span><span>doc</span> <span>&#34;&#34;&#34;</span>
<span>    Extract value from a key in a URL query string.</span>
<span>    Refactored by using pattern matching.</span>
<span>  &#34;&#34;&#34;</span>
  <span>def</span> <span>get_value</span><span>(</span><span>string</span><span>,</span> <span>desired_key</span><span>)</span> <span>do</span>
    <span>parts</span> <span>=</span> <span>String</span><span>.</span><span>split</span><span>(</span><span>string</span><span>,</span> <span>&#34;&amp;&#34;</span><span>)</span>
    <span>Enum</span><span>.</span><span>find_value</span><span>(</span><span>parts</span><span>,</span> <span>fn</span> <span>pair</span> <span>-&gt;</span>
      <span>[</span><span>key</span><span>,</span> <span>value</span><span>]</span> <span>=</span> <span>String</span><span>.</span><span>split</span><span>(</span><span>pair</span><span>,</span> <span>&#34;=&#34;</span><span>)</span> <span># &lt;= pattern matching</span>
      <span>key</span> <span>==</span> <span>desired_key</span> <span>&amp;&amp;</span> <span>value</span>
    <span>end</span><span>)</span>
  <span>end</span>

<span>end</span>

<span>#...Use examples...</span>

<span># URL query string according to with the planned format - OK!</span>
<span>iex</span><span>(</span><span>1</span><span>)</span><span>&gt;</span> <span>Extract</span><span>.</span><span>get_value</span><span>(</span><span>&#34;name=Lucas&amp;university=UFMG&amp;lab=ASERG&#34;</span><span>,</span> <span>&#34;name&#34;</span><span>)</span>
<span>&#34;Lucas&#34;</span>

<span># Unplanned URL query string format - Crash explaining the problem to the client!</span>
<span>iex</span><span>(</span><span>2</span><span>)</span><span>&gt;</span> <span>Extract</span><span>.</span><span>get_value</span><span>(</span><span>&#34;name=Lucas&amp;university=institution=UFMG&amp;lab=ASERG&#34;</span><span>,</span> <span>&#34;university&#34;</span><span>)</span>
<span>**</span> <span>(</span><span>MatchError</span><span>)</span> <span>no</span> <span>match</span> <span>of</span> <span>right</span> <span>hand</span> <span>side</span> <span>value: </span><span>[</span><span>&#34;university&#34;</span><span>,</span> <span>&#34;institution&#34;</span><span>,</span> <span>&#34;UFMG&#34;</span><span>]</span>
  <span>extract</span><span>.</span><span>ex</span>:<span>7</span>: <span>anonymous</span> <span>fn</span><span>/</span><span>2</span> <span>in</span> <span>Extract</span><span>.</span><span>get_value</span><span>/</span><span>2</span> <span># &lt;= left hand: [key, value] pair</span>

<span>iex</span><span>(</span><span>3</span><span>)</span>&gt; <span>Extract</span><span>.</span><span>get_value</span><span>(</span><span>&#34;name=Lucas&amp;university&amp;lab=ASERG&#34;</span><span>,</span> <span>&#34;university&#34;</span><span>)</span>
** <span>(</span><span>MatchError</span><span>)</span> <span>no</span> <span>match</span> <span>of</span> <span>right</span> <span>hand</span> <span>side</span> <span>value: </span><span>[</span><span>&#34;university&#34;</span><span>]</span>
  extract<span>.</span><span>ex</span>:<span>7</span>: <span>anonymous</span> <span>fn</span><span>/</span><span>2</span> <span>in</span> <span>Extract</span><span>.</span><span>get_value</span><span>/</span><span>2</span> <span># &lt;= left hand: [key, value] pair</span></pre></div>
<p dir="auto">These examples are based on code written by José Valim (<a href="https://github.com/josevalim">@josevalim</a>). Source: <a href="http://blog.plataformatec.com.br/2014/09/writing-assertive-code-with-elixir/" rel="nofollow">link</a></p>
</li>
</ul>
<p dir="auto"><a href="#table-of-contents">▲ back to Index</a></p>
<hr/>
<h3 dir="auto"><a id="user-content-modules-with-identical-names" aria-hidden="true" href="#modules-with-identical-names"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Modules with identical names</h3>
<ul dir="auto">
<li>
<p dir="auto"><strong>Category:</strong> Low-level concerns smells.</p>
</li>
<li>
<p dir="auto"><strong>Problem:</strong> This code smell is related to possible module name conflicts that can occur when a library is implemented. Due to a limitation of the Erlang VM (BEAM), also used by Elixir, only one instance of a module can be loaded at a time. If there are name conflicts between more than one module, they will be considered the same by BEAM and only one of them will be loaded. This can cause unwanted code behavior.</p>
</li>
<li>
<p dir="auto"><strong>Example:</strong> The code shown below is an example of this smell. Two different modules were defined with identical names (<code>Foo</code>). When BEAM tries to load both simultaneously, only the module defined in the file (<code>module_two.ex</code>) stay loaded, redefining the current version of <code>Foo</code> (<code>module_one.ex</code>) in memory. That makes it impossible to call <code>from_module_one/0</code>, for example:</p>
<div data-snippet-clipboard-copy-content="defmodule Foo do
  @moduledoc &#34;&#34;&#34;
    Defined in `module_one.ex` file.
  &#34;&#34;&#34;
  def from_module_one do
    &#34;Function from module one!&#34;
  end
end"><pre><span>defmodule</span> <span>Foo</span> <span>do</span>
  <span>@</span><span>moduledoc</span> <span>&#34;&#34;&#34;</span>
<span>    Defined in `module_one.ex` file.</span>
<span>  &#34;&#34;&#34;</span>
  <span>def</span> <span>from_module_one</span> <span>do</span>
    <span>&#34;Function from module one!&#34;</span>
  <span>end</span>
<span>end</span></pre></div>
<div data-snippet-clipboard-copy-content="defmodule Foo do
  @moduledoc &#34;&#34;&#34;
    Defined in `module_two.ex` file.
  &#34;&#34;&#34;
  def from_module_two do
    &#34;Function from module two!&#34;
  end
end"><pre><span>defmodule</span> <span>Foo</span> <span>do</span>
  <span>@</span><span>moduledoc</span> <span>&#34;&#34;&#34;</span>
<span>    Defined in `module_two.ex` file.</span>
<span>  &#34;&#34;&#34;</span>
  <span>def</span> <span>from_module_two</span> <span>do</span>
    <span>&#34;Function from module two!&#34;</span>
  <span>end</span>
<span>end</span></pre></div>
<p dir="auto">When BEAM tries to load both simultaneously, the name conflict causes only one of them to stay loaded:</p>
<div data-snippet-clipboard-copy-content="iex(1)&gt; c(&#34;module_one.ex&#34;)
[Foo]

iex(2)&gt; c(&#34;module_two.ex&#34;)
warning: redefining module Foo (current version defined in memory)
module_two.ex:1
[Foo]

iex(3)&gt; Foo.from_module_two()
&#34;Function from module two!&#34;

iex(4)&gt; Foo.from_module_one()  # &lt;= impossible to call due to name conflict
** (UndefinedFunctionError) function Foo.from_module_one/0 is undefined..."><pre><span>iex</span><span>(</span><span>1</span><span>)</span><span>&gt;</span> <span>c</span><span>(</span><span>&#34;module_one.ex&#34;</span><span>)</span>
<span>[</span><span>Foo</span><span>]</span>

<span>iex</span><span>(</span><span>2</span><span>)</span><span>&gt;</span> <span>c</span><span>(</span><span>&#34;module_two.ex&#34;</span><span>)</span>
<span>warning</span>: <span>redefining</span> <span>module</span> <span>Foo</span> <span>(</span><span>current</span> <span>version</span> <span>defined</span> <span>in</span> <span>memory</span><span>)</span>
<span>module_two</span><span>.</span><span>ex</span>:<span>1</span>
<span>[</span><span>Foo</span><span>]</span>

<span>iex</span><span>(</span><span>3</span><span>)</span><span>&gt;</span> <span>Foo</span><span>.</span><span>from_module_two</span><span>(</span><span>)</span>
<span>&#34;Function from module two!&#34;</span>

<span>iex</span><span>(</span><span>4</span><span>)</span><span>&gt;</span> <span>Foo</span><span>.</span><span>from_module_one</span><span>(</span><span>)</span>  <span># &lt;= impossible to call due to name conflict</span>
<span>**</span> <span>(</span><span>UndefinedFunctionError</span><span>)</span> <span>function</span> <span>Foo</span><span>.</span><span>from_module_one</span><span>/</span><span>0</span> <span>is</span> <span>undefined</span><span>...</span></pre></div>
</li>
<li>
<p dir="auto"><strong>Refactoring:</strong> To remove this code smell, a library must standardize the naming of its modules, always using its own name as a prefix (namespace) for all its module&#39;s names (e.g., <code>LibraryName.ModuleName</code>). When a module file is within subdirectories of a library, the names of the subdirectories must also be used in the module naming (e.g., <code>LibraryName.SubdirectoryName.ModuleName</code>). In the refactored code shown below, this module naming pattern was used. For this, the <code>Foo</code> module, defined in the file <code>module_two.ex</code>, was also moved to the <code>utils</code> subdirectory. This refactoring, in addition to eliminating the internal conflict of names within the library, will prevent the occurrence of name conflicts with client code:</p>
<div data-snippet-clipboard-copy-content="defmodule MyLibrary.Foo do
  @moduledoc &#34;&#34;&#34;
    Defined in `module_one.ex` file.
    Name refactored!
  &#34;&#34;&#34;
  def from_module_one do
    &#34;Function from module one!&#34;
  end
end"><pre><span>defmodule</span> <span>MyLibrary.Foo</span> <span>do</span>
  <span>@</span><span>moduledoc</span> <span>&#34;&#34;&#34;</span>
<span>    Defined in `module_one.ex` file.</span>
<span>    Name refactored!</span>
<span>  &#34;&#34;&#34;</span>
  <span>def</span> <span>from_module_one</span> <span>do</span>
    <span>&#34;Function from module one!&#34;</span>
  <span>end</span>
<span>end</span></pre></div>
<div data-snippet-clipboard-copy-content="defmodule MyLibrary.Utils.Foo do
  @moduledoc &#34;&#34;&#34;
    Defined in `module_two.ex` file.
    Name refactored!
  &#34;&#34;&#34;
  def from_module_two do
    &#34;Function from module two!&#34;
  end
end"><pre><span>defmodule</span> <span>MyLibrary.Utils.Foo</span> <span>do</span>
  <span>@</span><span>moduledoc</span> <span>&#34;&#34;&#34;</span>
<span>    Defined in `module_two.ex` file.</span>
<span>    Name refactored!</span>
<span>  &#34;&#34;&#34;</span>
  <span>def</span> <span>from_module_two</span> <span>do</span>
    <span>&#34;Function from module two!&#34;</span>
  <span>end</span>
<span>end</span></pre></div>
<p dir="auto">When BEAM tries to load them simultaneously, both will stay loaded successfully:</p>
<div data-snippet-clipboard-copy-content="iex(1)&gt; c(&#34;module_one.ex&#34;)
[MyLibrary.Foo]

iex(2)&gt; c(&#34;module_two.ex&#34;)
[MyLibrary.Utils.Foo]

iex(3)&gt; MyLibrary.Foo.from_module_one()
&#34;Function from module one!&#34;

iex(4)&gt; MyLibrary.Utils.Foo.from_module_two()
&#34;Function from module two!&#34;"><pre><span>iex</span><span>(</span><span>1</span><span>)</span><span>&gt;</span> <span>c</span><span>(</span><span>&#34;module_one.ex&#34;</span><span>)</span>
<span>[</span><span>MyLibrary.Foo</span><span>]</span>

<span>iex</span><span>(</span><span>2</span><span>)</span><span>&gt;</span> <span>c</span><span>(</span><span>&#34;module_two.ex&#34;</span><span>)</span>
<span>[</span><span>MyLibrary.Utils.Foo</span><span>]</span>

<span>iex</span><span>(</span><span>3</span><span>)</span><span>&gt;</span> <span>MyLibrary.Foo</span><span>.</span><span>from_module_one</span><span>(</span><span>)</span>
<span>&#34;Function from module one!&#34;</span>

<span>iex</span><span>(</span><span>4</span><span>)</span><span>&gt;</span> <span>MyLibrary.Utils.Foo</span><span>.</span><span>from_module_two</span><span>(</span><span>)</span>
<span>&#34;Function from module two!&#34;</span></pre></div>
<p dir="auto">This example is based on the description provided in Elixir&#39;s official documentation. Source: <a href="https://hexdocs.pm/elixir/master/library-guidelines.html#avoid-defining-modules-that-are-not-in-your-namespace" rel="nofollow">link</a></p>
</li>
</ul>
<p dir="auto"><a href="#table-of-contents">▲ back to Index</a></p>
<hr/>
<h3 dir="auto"><a id="user-content-unnecessary-macro" aria-hidden="true" href="#unnecessary-macro"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Unnecessary macro</h3>
<ul dir="auto">
<li>
<p dir="auto"><strong>Category:</strong> Low-level concerns smells.</p>
</li>
<li>
<p dir="auto"><strong>Problem:</strong> <code>Macros</code> are powerful meta-programming mechanisms that can be used in Elixir to extend the language. While implementing <code>macros</code> is not a code smell in itself, this meta-programming mechanism should only be used when absolutely necessary. Whenever a macro is implemented, and it was possible to solve the same problem using functions or other pre-existing Elixir structures, the code becomes unnecessarily more complex and less readable. Because <code>macros</code> are more difficult to implement and understand, their indiscriminate use can compromise the evolution of a system, reducing its maintainability.</p>
</li>
<li>
<p dir="auto"><strong>Example:</strong> The code shown below is an example of this smell. The <code>MyMacro</code> module implements the <code>sum/2</code> macro to perform the sum of two numbers received as parameters. While this code has no syntax errors and can be executed correctly to get the desired result, it is unnecessarily more complex. By implementing this functionality as a macro rather than a conventional function, the code became less clear and less objective:</p>
<div data-snippet-clipboard-copy-content="defmodule MyMacro do

  defmacro sum(v1, v2) do
    quote do
      unquote(v1) + unquote(v2)
    end
  end

end

#...Use examples...

iex(1)&gt; require MyMacro
MyMacro

iex(2)&gt; MyMacro.sum(3, 5)
8

iex(3)&gt; MyMacro.sum(3+1, 5+6)
15"><pre><span>defmodule</span> <span>MyMacro</span> <span>do</span>

  <span>defmacro</span> <span>sum</span><span>(</span><span>v1</span><span>,</span> <span>v2</span><span>)</span> <span>do</span>
    <span>quote</span> <span>do</span>
      <span>unquote</span><span>(</span><span>v1</span><span>)</span> <span>+</span> <span>unquote</span><span>(</span><span>v2</span><span>)</span>
    <span>end</span>
  <span>end</span>

<span>end</span>

<span>#...Use examples...</span>

<span>iex</span><span>(</span><span>1</span><span>)</span><span>&gt;</span> <span>require</span> <span>MyMacro</span>
<span>MyMacro</span>

<span>iex</span><span>(</span><span>2</span><span>)</span><span>&gt;</span> <span>MyMacro</span><span>.</span><span>sum</span><span>(</span><span>3</span><span>,</span> <span>5</span><span>)</span>
<span>8</span>

<span>iex</span><span>(</span><span>3</span><span>)</span><span>&gt;</span> <span>MyMacro</span><span>.</span><span>sum</span><span>(</span><span>3</span><span>+</span><span>1</span><span>,</span> <span>5</span><span>+</span><span>6</span><span>)</span>
<span>15</span></pre></div>
</li>
<li>
<p dir="auto"><strong>Refactoring:</strong> To remove this code smell, the developer must replace the unnecessary macro with structures that are simpler to write and understand, such as named functions. The code shown below is the result of the refactoring of the previous example. Basically, the <code>sum/2</code> macro has been transformed into a conventional named function:</p>
<div data-snippet-clipboard-copy-content="defmodule MyMacro do

  def sum(v1, v2) do   # &lt;= macro became a named function!
    v1 + v2
  end

end

#...Use examples...

iex(1)&gt; require MyMacro
MyMacro

iex(2)&gt; MyMacro.sum(3, 5)
8

iex(3)&gt; MyMacro.sum(3+1, 5+6)
15"><pre><span>defmodule</span> <span>MyMacro</span> <span>do</span>

  <span>def</span> <span>sum</span><span>(</span><span>v1</span><span>,</span> <span>v2</span><span>)</span> <span>do</span>   <span># &lt;= macro became a named function!</span>
    <span>v1</span> <span>+</span> <span>v2</span>
  <span>end</span>

<span>end</span>

<span>#...Use examples...</span>

<span>iex</span><span>(</span><span>1</span><span>)</span><span>&gt;</span> <span>require</span> <span>MyMacro</span>
<span>MyMacro</span>

<span>iex</span><span>(</span><span>2</span><span>)</span><span>&gt;</span> <span>MyMacro</span><span>.</span><span>sum</span><span>(</span><span>3</span><span>,</span> <span>5</span><span>)</span>
<span>8</span>

<span>iex</span><span>(</span><span>3</span><span>)</span><span>&gt;</span> <span>MyMacro</span><span>.</span><span>sum</span><span>(</span><span>3</span><span>+</span><span>1</span><span>,</span> <span>5</span><span>+</span><span>6</span><span>)</span>
<span>15</span></pre></div>
<p dir="auto">This example is based on the description provided in Elixir&#39;s official documentation. Source: <a href="https://hexdocs.pm/elixir/master/library-guidelines.html#avoid-macros" rel="nofollow">link</a></p>
</li>
</ul>
<p dir="auto"><a href="#table-of-contents">▲ back to Index</a></p>
<hr/>
<h3 dir="auto"><a id="user-content-large-code-generation" aria-hidden="true" href="#large-code-generation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Large code generation</h3>
<ul dir="auto">
<li>
<p dir="auto"><strong>Category:</strong> Low-level concerns smells.</p>
</li>
<li>
<p dir="auto"><strong>Note:</strong> This smell was suggested by the community via issues (<a href="https://github.com/lucasvegi/Elixir-Code-Smells/issues/13" data-hovercard-type="issue" data-hovercard-url="/lucasvegi/Elixir-Code-Smells/issues/13/hovercard">#13</a>).</p>
</li>
<li>
<p dir="auto"><strong>Problem:</strong> This code smell is related to <code>macros</code> that generate too much code. When a <code>macro</code> provides a large code generation, it impacts how the compiler or the runtime works. The reason for this is that Elixir may have to expand, compile, and execute a code multiple times, which will make compilation slower.</p>
</li>
<li>
<p dir="auto"><strong>Example:</strong> The code shown below is an example of this smell. Imagine you are defining a router for a web application, where you could have macros like <code>get/2</code>. On every invocation of the macro, which can be hundreds, the code inside <code>get/2</code> will be expanded and compiled, which can generate a large volume of code in total.</p>
<div data-snippet-clipboard-copy-content="defmodule Routes do
  ...

  defmacro get(route, handler) do
    quote do
      route = unquote(route)
      handler = unquote(handler)

      if not is_binary(route) do
        raise ArgumentError, &#34;route must be a binary&#34;
      end

      if not is_atom(handler) do
        raise ArgumentError, &#34;route must be a module&#34;
      end

      @store_route_for_compilation {route, handler}
    end
  end
end"><pre><span>defmodule</span> <span>Routes</span> <span>do</span>
  <span>...</span>

  <span>defmacro</span> <span>get</span><span>(</span><span>route</span><span>,</span> <span>handler</span><span>)</span> <span>do</span>
    <span>quote</span> <span>do</span>
      <span>route</span> <span>=</span> <span>unquote</span><span>(</span><span>route</span><span>)</span>
      <span>handler</span> <span>=</span> <span>unquote</span><span>(</span><span>handler</span><span>)</span>

      <span>if</span> <span>not</span> <span>is_binary</span><span>(</span><span>route</span><span>)</span> <span>do</span>
        <span>raise</span> <span>ArgumentError</span><span>,</span> <span>&#34;route must be a binary&#34;</span>
      <span>end</span>

      <span>if</span> <span>not</span> <span>is_atom</span><span>(</span><span>handler</span><span>)</span> <span>do</span>
        <span>raise</span> <span>ArgumentError</span><span>,</span> <span>&#34;route must be a module&#34;</span>
      <span>end</span>

      <span>@</span><span>store_route_for_compilation</span> <span>{</span><span>route</span><span>,</span> <span>handler</span><span>}</span>
    <span>end</span>
  <span>end</span>
<span>end</span></pre></div>
</li>
<li>
<p dir="auto"><strong>Refactoring:</strong> To remove this code smell, the developer must simplify the <code>macro</code>, delegating to other functions part of its work. As shown below, by encapsulating in the function <code>__define__/3</code> the functionality pre-existing inside the <code>quote</code>, we reduce the code that is expanded and compiled on every invocation of the <code>macro</code>, and instead we dispatch to a function to do the bulk of the work.</p>
<div data-snippet-clipboard-copy-content="defmodule Routes do
  ...

  defmacro get(route, handler) do
    quote do
      Routes.__define__(__MODULE__, unquote(route), unquote(handler))
    end
  end

  def __define__(module, route, handler) do

    if not is_binary(route) do
      raise ArgumentError, &#34;route must be a binary&#34;
    end

    if not is_atom(handler) do
      raise ArgumentError, &#34;route must be a module&#34;
    end

    Module.put_attribute(module, :store_route_for_compilation, {route, handler})
  end
end"><pre><span>defmodule</span> <span>Routes</span> <span>do</span>
  <span>...</span>

  <span>defmacro</span> <span>get</span><span>(</span><span>route</span><span>,</span> <span>handler</span><span>)</span> <span>do</span>
    <span>quote</span> <span>do</span>
      <span>Routes</span><span>.</span><span>__define__</span><span>(</span><span>__MODULE__</span><span>,</span> <span>unquote</span><span>(</span><span>route</span><span>)</span><span>,</span> <span>unquote</span><span>(</span><span>handler</span><span>)</span><span>)</span>
    <span>end</span>
  <span>end</span>

  <span>def</span> <span>__define__</span><span>(</span><span>module</span><span>,</span> <span>route</span><span>,</span> <span>handler</span><span>)</span> <span>do</span>

    <span>if</span> <span>not</span> <span>is_binary</span><span>(</span><span>route</span><span>)</span> <span>do</span>
      <span>raise</span> <span>ArgumentError</span><span>,</span> <span>&#34;route must be a binary&#34;</span>
    <span>end</span>

    <span>if</span> <span>not</span> <span>is_atom</span><span>(</span><span>handler</span><span>)</span> <span>do</span>
      <span>raise</span> <span>ArgumentError</span><span>,</span> <span>&#34;route must be a module&#34;</span>
    <span>end</span>

    <span>Module</span><span>.</span><span>put_attribute</span><span>(</span><span>module</span><span>,</span> <span>:store_route_for_compilation</span><span>,</span> <span>{</span><span>route</span><span>,</span> <span>handler</span><span>}</span><span>)</span>
  <span>end</span>
<span>end</span></pre></div>
<p dir="auto">This example and the refactoring are proposed by José Valim (<a href="https://github.com/josevalim">@josevalim</a>)</p>
</li>
</ul>
<p dir="auto"><a href="#table-of-contents">▲ back to Index</a></p>
<hr/>
<h3 dir="auto"><a id="user-content-app-configuration-for-code-libs" aria-hidden="true" href="#app-configuration-for-code-libs"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>App configuration for code libs</h3>
<ul dir="auto">
<li>
<p dir="auto"><strong>Category:</strong> Low-level concerns smells.</p>
</li>
<li>
<p dir="auto"><strong>Problem:</strong> The <code>Application Environment</code> <sup><a href="https://hexdocs.pm/elixir/1.13/Config.html" rel="nofollow">link</a></sup> is a global configuration mechanism and therefore can be used to parameterize values that will be used in several different places in a system implemented in Elixir. This parameterization mechanism can be very useful and therefore is not considered a code smell by itself. However, when <code>Application Environments</code> are used as a mechanism for configuring a library&#39;s functions, this can make these functions less flexible, making it impossible for a library-dependent application to reuse its functions with different behaviors in different places in the code. Libraries are created to foster code reuse, so this kind of limitation imposed by global configurations can be problematic in this scenario.</p>
</li>
<li>
<p dir="auto"><strong>Example:</strong> The <code>DashSplitter</code> module represents a library that configures the behavior of its functions through the global <code>Application Environment</code> mechanism. These configurations are concentrated in the <code>config/config.exs</code> file, shown below:</p>
<div data-snippet-clipboard-copy-content="import Config

config :app_config,
  parts: 3

import_config &#34;#{config_env()}.exs&#34;"><pre><span>import</span> <span>Config</span>

<span>config</span> <span>:app_config</span><span>,</span>
  <span>parts: </span><span>3</span>

<span>import_config</span> <span>&#34;<span><span>#{</span><span>config_env</span><span>(</span><span>)</span><span>}</span></span>.exs&#34;</span></pre></div>
<p dir="auto">One of the functions implemented by the <code>DashSplitter</code> library is <code>split/1</code>. This function has the purpose of separating a string received via parameter into a certain number of parts. The character used as a separator in <code>split/1</code> is always <code>&#34;-&#34;</code> and the number of parts the string is split into is defined globally by the <code>Application Environment</code>. This value is retrieved by the <code>split/1</code> function by calling <code>Application.fetch_env!/2</code>, as shown next:</p>
<div data-snippet-clipboard-copy-content="defmodule DashSplitter do
  def split(string) when is_binary(string) do
    parts = Application.fetch_env!(:app_config, :parts) # &lt;= retrieve global config
    String.split(string, &#34;-&#34;, parts: parts)             # &lt;= parts: 3
  end
end"><pre><span>defmodule</span> <span>DashSplitter</span> <span>do</span>
  <span>def</span> <span>split</span><span>(</span><span>string</span><span>)</span> <span>when</span> <span>is_binary</span><span>(</span><span>string</span><span>)</span> <span>do</span>
    <span>parts</span> <span>=</span> <span>Application</span><span>.</span><span>fetch_env!</span><span>(</span><span>:app_config</span><span>,</span> <span>:parts</span><span>)</span> <span># &lt;= retrieve global config</span>
    <span>String</span><span>.</span><span>split</span><span>(</span><span>string</span><span>,</span> <span>&#34;-&#34;</span><span>,</span> <span>parts: </span><span>parts</span><span>)</span>             <span># &lt;= parts: 3</span>
  <span>end</span>
<span>end</span></pre></div>
<p dir="auto">Due to this type of global configuration used by the <code>DashSplitter</code> library, all applications dependent on it can only use the <code>split/1</code> function with identical behavior in relation to the number of parts generated by string separation. Currently, this value is equal to 3, as we can see in the use examples shown below:</p>
<div data-snippet-clipboard-copy-content="iex(1)&gt; DashSplitter.split(&#34;Lucas-Francisco-Vegi&#34;)
[&#34;Lucas&#34;, &#34;Francisco&#34;, &#34;Vegi&#34;]

iex(2)&gt; DashSplitter.split(&#34;Lucas-Francisco-da-Matta-Vegi&#34;)
[&#34;Lucas&#34;, &#34;Francisco&#34;, &#34;da-Matta-Vegi&#34;]"><pre><span>iex</span><span>(</span><span>1</span><span>)</span><span>&gt;</span> <span>DashSplitter</span><span>.</span><span>split</span><span>(</span><span>&#34;Lucas-Francisco-Vegi&#34;</span><span>)</span>
<span>[</span><span>&#34;Lucas&#34;</span><span>,</span> <span>&#34;Francisco&#34;</span><span>,</span> <span>&#34;Vegi&#34;</span><span>]</span>

<span>iex</span><span>(</span><span>2</span><span>)</span><span>&gt;</span> <span>DashSplitter</span><span>.</span><span>split</span><span>(</span><span>&#34;Lucas-Francisco-da-Matta-Vegi&#34;</span><span>)</span>
<span>[</span><span>&#34;Lucas&#34;</span><span>,</span> <span>&#34;Francisco&#34;</span><span>,</span> <span>&#34;da-Matta-Vegi&#34;</span><span>]</span></pre></div>
</li>
<li>
<p dir="auto"><strong>Refactoring:</strong> To remove this code smell and make the library more adaptable and flexible, this type of configuration must be performed via parameters in function calls. The code shown below performs the refactoring of the <code>split/1</code> function by adding a new optional parameter of type <code>Keyword list</code>. With this new parameter it is possible to modify the default behavior of the function at the time of its call, allowing multiple different ways of using <code>split/2</code> within the same application:</p>
<div data-snippet-clipboard-copy-content="defmodule DashSplitter do
  def split(string, opts \\ []) when is_binary(string) and is_list(opts) do
    parts = Keyword.get(opts, :parts, 2) # &lt;= default config of parts == 2
    String.split(string, &#34;-&#34;, parts: parts)
  end
end

#...Use examples...

iex(1)&gt; DashSplitter.split(&#34;Lucas-Francisco-da-Matta-Vegi&#34;, [parts: 5])
[&#34;Lucas&#34;, &#34;Francisco&#34;, &#34;da&#34;, &#34;Matta&#34;, &#34;Vegi&#34;]

iex(2)&gt; DashSplitter.split(&#34;Lucas-Francisco-da-Matta-Vegi&#34;) #&lt;= default config is used!
[&#34;Lucas&#34;, &#34;Francisco-da-Matta-Vegi&#34;]"><pre><span>defmodule</span> <span>DashSplitter</span> <span>do</span>
  <span>def</span> <span>split</span><span>(</span><span>string</span><span>,</span> <span>opts</span> <span>\\</span> <span>[</span><span>]</span><span>)</span> <span>when</span> <span>is_binary</span><span>(</span><span>string</span><span>)</span> <span>and</span> <span>is_list</span><span>(</span><span>opts</span><span>)</span> <span>do</span>
    <span>parts</span> <span>=</span> <span>Keyword</span><span>.</span><span>get</span><span>(</span><span>opts</span><span>,</span> <span>:parts</span><span>,</span> <span>2</span><span>)</span> <span># &lt;= default config of parts == 2</span>
    <span>String</span><span>.</span><span>split</span><span>(</span><span>string</span><span>,</span> <span>&#34;-&#34;</span><span>,</span> <span>parts: </span><span>parts</span><span>)</span>
  <span>end</span>
<span>end</span>

<span>#...Use examples...</span>

<span>iex</span><span>(</span><span>1</span><span>)</span><span>&gt;</span> <span>DashSplitter</span><span>.</span><span>split</span><span>(</span><span>&#34;Lucas-Francisco-da-Matta-Vegi&#34;</span><span>,</span> <span>[</span><span>parts: </span><span>5</span><span>]</span><span>)</span>
<span>[</span><span>&#34;Lucas&#34;</span><span>,</span> <span>&#34;Francisco&#34;</span><span>,</span> <span>&#34;da&#34;</span><span>,</span> <span>&#34;Matta&#34;</span><span>,</span> <span>&#34;Vegi&#34;</span><span>]</span>

<span>iex</span><span>(</span><span>2</span><span>)</span><span>&gt;</span> <span>DashSplitter</span><span>.</span><span>split</span><span>(</span><span>&#34;Lucas-Francisco-da-Matta-Vegi&#34;</span><span>)</span> <span>#&lt;= default config is used!</span>
<span>[</span><span>&#34;Lucas&#34;</span><span>,</span> <span>&#34;Francisco-da-Matta-Vegi&#34;</span><span>]</span></pre></div>
<p dir="auto">These examples are based on code provided in Elixir&#39;s official documentation. Source: <a href="https://hexdocs.pm/elixir/master/library-guidelines.html#avoid-application-configuration" rel="nofollow">link</a></p>
</li>
</ul>
<p dir="auto"><a href="#table-of-contents">▲ back to Index</a></p>
<hr/>
<h3 dir="auto"><a id="user-content-compile-time-app-configuration" aria-hidden="true" href="#compile-time-app-configuration"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Compile-time app configuration</h3>
<ul dir="auto">
<li>
<p dir="auto"><strong>Category:</strong> Low-level concerns smells.</p>
</li>
<li>
<p dir="auto"><strong>Problem:</strong> As explained in the description of <a href="#app-configuration-for-code-libs">App configuration for code libs</a>, the <code>Application Environment</code> can be used to parameterize values in an Elixir system. Although it is not a good practice to use this mechanism in the implementation of libraries, sometimes this can be unavoidable. If these parameterized values are assigned to <code>module attributes</code>, it can be especially problematic. As <code>module attribute</code> values are defined at compile-time, when trying to assign <code>Application Environment</code> values to these attributes, warnings or errors can be triggered by Elixir. This happens because, when defining module attributes at compile time, the <code>Application Environment</code> is not yet available in memory.</p>
</li>
<li>
<p dir="auto"><strong>Example:</strong> The <code>DashSplitter</code> module represents a library. This module has an attribute <code>@parts</code> that has its constant value defined at compile-time by calling <code>Application.fetch_env!/2</code>. The <code>split/1</code> function, implemented by this library, has the purpose of separating a string received via parameter into a certain number of parts. The character used as a separator in <code>split/1</code> is always <code>&#34;-&#34;</code> and the number of parts the string is split into is defined by the module attribute <code>@parts</code>, as shown next:</p>
<div data-snippet-clipboard-copy-content="defmodule DashSplitter do
  @parts Application.fetch_env!(:app_config, :parts) # &lt;= define module attribute
                                                        # at compile-time
  def split(string) when is_binary(string) do
    String.split(string, &#34;-&#34;, parts: @parts) #&lt;= reading from a module attribute
  end

end"><pre><span>defmodule</span> <span>DashSplitter</span> <span>do</span>
  <span>@</span><span>parts</span> <span>Application</span><span>.</span><span>fetch_env!</span><span>(</span><span>:app_config</span><span>,</span> <span>:parts</span><span>)</span> <span># &lt;= define module attribute</span>
                                                        <span># at compile-time</span>
  <span>def</span> <span>split</span><span>(</span><span>string</span><span>)</span> <span>when</span> <span>is_binary</span><span>(</span><span>string</span><span>)</span> <span>do</span>
    <span>String</span><span>.</span><span>split</span><span>(</span><span>string</span><span>,</span> <span>&#34;-&#34;</span><span>,</span> <span>parts: </span><span>@</span><span>parts</span><span>)</span> <span>#&lt;= reading from a module attribute</span>
  <span>end</span>

<span>end</span></pre></div>
<p dir="auto">Due to this compile-time configuration based on the <code>Application Environment</code> mechanism, Elixir can raise warnings or errors, as shown next, during compilation:</p>
<div data-snippet-clipboard-copy-content="warning: Application.fetch_env!/2 is discouraged in the module body,
use Application.compile_env/3 instead...

** (ArgumentError) could not fetch application environment :parts
for application :app_config because the application was not loaded nor
configured"><pre><span>warning</span>: A<span>pplication</span><span>.</span><span>fetch_env!</span><span>/</span><span>2</span> is discouraged <span>in</span> <span>the</span> <span>module</span> <span>body</span><span>,</span>
<span>use</span> <span>Application</span><span>.</span><span>compile_env</span><span>/</span><span>3</span> <span>in</span><span>stead</span><span>...</span>

<span>**</span> <span>(</span><span>ArgumentError</span><span>)</span> <span>could</span> <span>not</span> <span>fetch</span> <span>application</span> <span>environment</span> <span>:parts</span>
<span>for</span> <span>application</span> <span>:app_config</span> <span>because</span> <span>the</span> <span>application</span> <span>was</span> <span>not</span> <span>loaded</span> <span>nor</span>
<span>configured</span></pre></div>
</li>
<li>
<p dir="auto"><strong>Refactoring:</strong> To remove this code smell, when it is really unavoidable to use the <code>Application Environment</code> mechanism to configure library functions, this should be done at runtime and not during compilation. That is, instead of calling <code>Application.fetch_env!(:app_config, :parts)</code> at compile-time to set <code>@parts</code>, this function must be called at runtime within <code>split/1</code>. This will mitigate the risk that <code>Application Environment</code> is not yet available in memory when it is necessary to use it. Another possible refactoring, as shown below, is to replace the use of the <code>Application.fetch_env!/2</code> function to define <code>@parts</code>, with the <code>Application.compile_env/3</code>. The third parameter of <code>Application.compile_env/3</code> defines a default value that is returned whenever that <code>Application Environment</code> is not available in memory during the definition of <code>@parts</code>. This prevents Elixir from raising an error at compile-time:</p>
<div data-snippet-clipboard-copy-content="defmodule DashSplitter do
  @parts Application.compile_env(:app_config, :parts, 3) # &lt;= default value 3 prevents an error!

  def split(string) when is_binary(string) do
    String.split(string, &#34;-&#34;, parts: @parts) #&lt;= reading from a module attribute
  end

end"><pre><span>defmodule</span> <span>DashSplitter</span> <span>do</span>
  <span>@</span><span>parts</span> <span>Application</span><span>.</span><span>compile_env</span><span>(</span><span>:app_config</span><span>,</span> <span>:parts</span><span>,</span> <span>3</span><span>)</span> <span># &lt;= default value 3 prevents an error!</span>

  <span>def</span> <span>split</span><span>(</span><span>string</span><span>)</span> <span>when</span> <span>is_binary</span><span>(</span><span>string</span><span>)</span> <span>do</span>
    <span>String</span><span>.</span><span>split</span><span>(</span><span>string</span><span>,</span> <span>&#34;-&#34;</span><span>,</span> <span>parts: </span><span>@</span><span>parts</span><span>)</span> <span>#&lt;= reading from a module attribute</span>
  <span>end</span>

<span>end</span></pre></div>
<p dir="auto">These examples are based on code provided in Elixir&#39;s official documentation. Source: <a href="https://hexdocs.pm/elixir/master/library-guidelines.html#avoid-application-configuration" rel="nofollow">link</a></p>
</li>
<li>
<p dir="auto"><strong>Remark:</strong> This code smell can be detected by <a href="https://hexdocs.pm/credo/overview.html" rel="nofollow">Credo</a>, a static code analysis tool. During its checks, Credo raises this <a href="https://hexdocs.pm/credo/Credo.Check.Warning.ApplicationConfigInModuleAttribute.html" rel="nofollow">warning</a> when this smell is found.</p>
</li>
</ul>
<p dir="auto"><a href="#table-of-contents">▲ back to Index</a></p>
<hr/>
<h3 dir="auto"><a id="user-content-dependency-with-use-when-an-import-is-enough" aria-hidden="true" href="#dependency-with-use-when-an-import-is-enough"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Dependency with &#34;use&#34; when an &#34;import&#34; is enough</h3>
<ul dir="auto">
<li>
<p dir="auto"><strong>Category:</strong> Low-level concerns smells.</p>
</li>
<li>
<p dir="auto"><strong>Problem:</strong> Elixir has mechanisms such as <code>import</code>, <code>alias</code>, and <code>use</code> to establish dependencies between modules. Establishing dependencies allows a module to call functions from other modules, facilitating code reuse. A code implemented with these mechanisms does not characterize a smell by itself; however, while the <code>import</code> and <code>alias</code> directives have lexical scope and only facilitate that a module to use functions of another, the <code>use</code> directive has a broader scope, something that can be problematic. The <code>use</code> directive allows a module to inject any type of code into another, including propagating dependencies. In this way, using the <code>use</code> directive makes code readability worse, because to understand exactly what will happen when it references a module, it is necessary to have knowledge of the internal details of the referenced module.</p>
</li>
<li>
<p dir="auto"><strong>Example:</strong> The code shown below is an example of this smell. Three different modules were defined -- <code>ModuleA</code>, <code>Library</code>, and <code>ClientApp</code>. <code>ClientApp</code> is reusing code from the <code>Library</code> via the <code>use</code> directive, but is unaware of its internal details. Therefore, when <code>Library</code> is referenced by <code>ClientApp</code>, it injects into <code>ClientApp</code> all the content present in its <code>__using__/1</code> macro. Due to the decreased readability of the code and the lack of knowledge of the internal details of the <code>Library</code>, <code>ClientApp</code> defines a local function <code>foo/0</code>. This will generate a conflict as <code>ModuleA</code> also has a function <code>foo/0</code>; when <code>ClientApp</code> referenced <code>Library</code> via the <code>use</code> directive, it has a dependency for <code>ModuleA</code> propagated to itself:</p>
<div data-snippet-clipboard-copy-content="defmodule ModuleA do
  def foo do
    &#34;From Module A&#34;
  end
end"><pre><span>defmodule</span> <span>ModuleA</span> <span>do</span>
  <span>def</span> <span>foo</span> <span>do</span>
    <span>&#34;From Module A&#34;</span>
  <span>end</span>
<span>end</span></pre></div>
<div data-snippet-clipboard-copy-content="defmodule Library do
  defmacro __using__(_opts) do
    quote do
      import ModuleA  # &lt;= propagating dependencies!

      def from_lib do
        &#34;From Library&#34;
      end
    end
  end

  def from_lib do
    &#34;From Library&#34;
  end
end"><pre><span>defmodule</span> <span>Library</span> <span>do</span>
  <span>defmacro</span> <span>__using__</span><span>(</span><span>_opts</span><span>)</span> <span>do</span>
    <span>quote</span> <span>do</span>
      <span>import</span> <span>ModuleA</span>  <span># &lt;= propagating dependencies!</span>

      <span>def</span> <span>from_lib</span> <span>do</span>
        <span>&#34;From Library&#34;</span>
      <span>end</span>
    <span>end</span>
  <span>end</span>

  <span>def</span> <span>from_lib</span> <span>do</span>
    <span>&#34;From Library&#34;</span>
  <span>end</span>
<span>end</span></pre></div>
<div data-snippet-clipboard-copy-content="defmodule ClientApp do
  use Library

  def foo do
    &#34;Local function from client app&#34;
  end

  def from_client_app do
    from_lib() &lt;&gt; &#34; - &#34; &lt;&gt; foo()
  end

end"><pre><span>defmodule</span> <span>ClientApp</span> <span>do</span>
  <span>use</span> <span>Library</span>

  <span>def</span> <span>foo</span> <span>do</span>
    <span>&#34;Local function from client app&#34;</span>
  <span>end</span>

  <span>def</span> <span>from_client_app</span> <span>do</span>
    <span>from_lib</span><span>(</span><span>)</span> <span>&lt;&gt;</span> <span>&#34; - &#34;</span> <span>&lt;&gt;</span> <span>foo</span><span>(</span><span>)</span>
  <span>end</span>

<span>end</span></pre></div>
<p dir="auto">When we try to compile <code>ClientApp</code>, Elixir will detect the conflict and throw the following error:</p>
<div data-snippet-clipboard-copy-content="iex(1)&gt; c(&#34;client_app.ex&#34;)

** (CompileError) client_app.ex:4: imported ModuleA.foo/0 conflicts with local function"><pre><span>iex</span><span>(</span><span>1</span><span>)</span><span>&gt;</span> <span>c</span><span>(</span><span>&#34;client_app.ex&#34;</span><span>)</span>

<span>**</span> <span>(</span><span>CompileError</span><span>)</span> client_app<span>.</span><span>ex</span>:<span>4</span>: <span>imported</span> <span>ModuleA</span><span>.</span><span>foo</span><span>/</span><span>0</span> <span>conflicts</span> <span>with</span> <span>local</span> <span>function</span></pre></div>
</li>
<li>
<p dir="auto"><strong>Refactoring:</strong> To remove this code smell, it may be possible to replace <code>use</code> with <code>alias</code> or <code>import</code> when creating a dependency between an application and a library. This will make code behavior clearer, due to improved readability. In the following code, <code>ClientApp</code> was refactored in this way, and with that, the conflict as previously shown no longer exists:</p>
<div data-snippet-clipboard-copy-content="defmodule ClientApp do
  import Library

  def foo do
    &#34;Local function from client app&#34;
  end

  def from_client_app do
    from_lib() &lt;&gt; &#34; - &#34; &lt;&gt; foo()
  end

end

#...Uses example...

iex(1)&gt; ClientApp.from_client_app()
&#34;From Library - Local function from client app&#34;"><pre><span>defmodule</span> <span>ClientApp</span> <span>do</span>
  <span>import</span> <span>Library</span>

  <span>def</span> <span>foo</span> <span>do</span>
    <span>&#34;Local function from client app&#34;</span>
  <span>end</span>

  <span>def</span> <span>from_client_app</span> <span>do</span>
    <span>from_lib</span><span>(</span><span>)</span> <span>&lt;&gt;</span> <span>&#34; - &#34;</span> <span>&lt;&gt;</span> <span>foo</span><span>(</span><span>)</span>
  <span>end</span>

<span>end</span>

<span>#...Uses example...</span>

<span>iex</span><span>(</span><span>1</span><span>)</span><span>&gt;</span> <span>ClientApp</span><span>.</span><span>from_client_app</span><span>(</span><span>)</span>
<span>&#34;From Library - Local function from client app&#34;</span></pre></div>
<p dir="auto">These examples are based on code provided in Elixir&#39;s official documentation. Source: <a href="https://hexdocs.pm/elixir/master/library-guidelines.html#avoid-use-when-an-import-is-enough" rel="nofollow">link</a></p>
</li>
</ul>
<p dir="auto"><a href="#table-of-contents">▲ back to Index</a></p>
<h2 dir="auto"><a id="user-content-about" aria-hidden="true" href="#about"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>About</h2>
<p dir="auto">This catalog was proposed by Lucas Vegi and Marco Tulio Valente, from <a href="http://aserg.labsoft.dcc.ufmg.br/" rel="nofollow">ASERG/DCC/UFMG</a>.</p>
<p dir="auto">For more info see the following paper:</p>
<ul dir="auto">
<li><a href="https://doi.org/10.48550/arXiv.2203.08877" rel="nofollow">Code Smells in Elixir: Early Results from a Grey Literature Review</a>, International Conference on Program Comprehension (ICPC), 2022.</li>
</ul>
<p dir="auto">Please feel free to make pull requests and suggestions (<a href="https://github.com/lucasvegi/Elixir-Code-Smells/issues">Issues</a> tab).</p>
<p dir="auto"><a href="#table-of-contents">▲ back to Index</a></p>

<section data-footnotes="">
<ol dir="auto">
<li id="user-content-fn-**-2462f38ac7ce1527b61dbf3da42f847a">
<p dir="auto">These code smells were suggested by the Elixir community. <a href="#user-content-fnref-**-2462f38ac7ce1527b61dbf3da42f847a" data-footnote-backref="" aria-label="Back to content"><g-emoji alias="leftwards_arrow_with_hook" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/21a9.png">↩</g-emoji></a> <a href="#user-content-fnref-**-2-2462f38ac7ce1527b61dbf3da42f847a" data-footnote-backref="" aria-label="Back to content"><g-emoji alias="leftwards_arrow_with_hook" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/21a9.png">↩</g-emoji><sup>2</sup></a> <a href="#user-content-fnref-**-3-2462f38ac7ce1527b61dbf3da42f847a" data-footnote-backref="" aria-label="Back to content"><g-emoji alias="leftwards_arrow_with_hook" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/21a9.png">↩</g-emoji><sup>3</sup></a> <a href="#user-content-fnref-**-4-2462f38ac7ce1527b61dbf3da42f847a" data-footnote-backref="" aria-label="Back to content"><g-emoji alias="leftwards_arrow_with_hook" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/21a9.png">↩</g-emoji><sup>4</sup></a></p>
</li>
</ol>
</section>
</article>
          </div></div>
  </body>
</html>
