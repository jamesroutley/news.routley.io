<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tavianator.com/2023/bfs_3.0.html">Original</a>
    <h1>Bfs 3.0: The Fastest Find Yet</h1>
    
    <div id="readability-page-1" class="page">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        

        <!-- Set the theme before any content is loaded, prevents flash -->
        

        <!-- Hide / unhide sidebar before it is displayed -->
        

        <nav id="sidebar" aria-label="Table of contents">
            
            
        </nav>

        <!-- Track and set sidebar scroll position -->
        

        <div id="page-wrapper">

            <div class="page">
                                
                

                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                

                <div id="content">
                    <main>
                        
<div>
<p><i></i> <time datetime="2023-07-18">2023-07-18</time>
<i></i> Tavian Barnes
<a href="https://github.com/tavianator/bfs"><i></i> GitHub</a></p>
</div>
<p><code>bfs</code> is a tool I wrote to do <strong>b</strong>readth-<strong>f</strong>irst <strong>s</strong>earch through a filesystem.
It <a href="https://github.com/tavianator/bfs/commit/72552f880f3ca52c0d98d875b1da783e5a2fa2e7">started out</a> simply enough, but over the years it&#39;s grown to include almost every feature from every other <a href="https://en.wikipedia.org/wiki/Find_(Unix)"><code>find</code></a> implementation I could find, plus many of its own innovations.
The new 3.0 release series includes the biggest new feature so far: asynchronous, parallel directory traversal.</p>
<h2 id="the-kitchen-sync"><a href="#the-kitchen-sync">The kitchen sync</a></h2>
<p>In pseudocode, the way <code>bfs</code> used to work looked like this:</p>
<pre><code>while (const char *path = popdir()) {
    DIR *dir = opendir(path);
    while (struct dirent *de = readdir(dir)) {
        if (visit(de)) {
            pushdir(de);
        }
    }
    closedir(dir);
}
</code></pre>
<p>Here, <code>visit()</code> is doing the filtering, printing, pruning, etc. that was written on the command line, e.g.</p>
<pre><code>$ bfs <span>-nohidden -name &#39;*.c&#39; -ls</span></code></pre>
<p>For today, we can ignore all of that and just focus on what dominates the execution time: <strong>I/O</strong>.
A timeline of the I/O operations that <code>bfs</code> does looks like this:</p>

<div>
<span><code>opendir()</code><span><code>openat()</code></span></span>
<span><code>readdir()</code><span><code>getdents()</code></span></span>
<span><code>readdir()</code></span>
<span><code>...</code></span>
<span><code>closedir()</code><span><code>close()</code></span></span>
<span><code>opendir()</code><span><code>openat()</code></span></span>
<span><code>...</code></span>
</div>
<p>The C library functions are shown on top, and the syscalls they call are <span>highlighted</span>.
These syscalls are invoked <em>synchronously</em>, meaning execution pauses and waits for them to complete before continuing.
It would be better to invoke them <em>asynchronously</em>, and do other useful work (i.e. <code>visit()</code>) while we wait for them to complete.</p>
<h2 id="io-queues"><a href="#io-queues">I/O queues</a></h2>
<p><code>bfs</code> 3.0 introduces <a href="https://github.com/tavianator/bfs/blob/3.0.1/src/ioq.h">I/O queues</a>, an API which offloads these syscalls to background threads, making them appear asynchronous.
The new main loop looks more like this now:</p>
<pre><code>while (DIR *dir = ioq_pop()) {
    while (struct dirent *de = readdir(dir)) {
        if (visit(de)) {
            ioq_opendir(path);
        }
    }
    ioq_closedir(dir);
}
</code></pre>
<p>(The <a href="https://github.com/tavianator/bfs/blob/3.0.1/src/bftw.c">real implementation</a> is somewhat more complicated, but the <a href="https://github.com/tavianator/bfs/blob/3.0.1/src/bftw.c#L1433-L1471">main loop</a> is largely similar.)
The timeline now looks something like this:</p>
<div>
<span><code>main</code></span>
<span><code>ioq_pop()</code></span>
<span><code>readdir()</code></span>
<span><code>ioq_opendir()</code></span>
<span><code>...</code></span>
<span><code>ioq_closedir()</code></span>
<span><code>ioq_pop()</code></span>
<span><code>...</code></span>
</div>
<div>
<span><code>ioq</code></span>
<span><code>opendir()</code><span><code>openat()</code></span></span>
<span><code>readdir()</code><span><code>getdents()</code></span></span>
<span><code>closedir()</code><span><code>close()</code></span></span>
<span><code>opendir()</code><span><code>openat()</code></span></span>
<span><code>readdir()</code><span><code>getdents()</code></span></span>
<span><code>...</code></span>
</div>
<p>By going asynchronous, <code>bfs</code> can be more efficient because it doesn&#39;t have to stall waiting for I/O.
The main thread may occasionally block waiting on the I/O queue, but in the best case it can pop entries with just a couple atomic memory operations.
This benefit is separate from parallelism—even on a single-core machine, <code>bfs</code> can now do useful work where it previously would have been blocked on I/O.
That said, parallelism is beneficial too:</p>
<div>
<span><code>main</code></span>
<span><code>ioq_pop()</code></span>
<span><code>readdir()</code></span>
<span><code>ioq_opendir()</code></span>
<span><code>...</code></span>
<span><code>ioq_closedir()</code></span>
<span><code>ioq_pop()</code></span>
<span><code>...</code></span>
</div>
<div>
<span><code>ioq</code></span>
<span><code>opendir()</code><span><code>openat()</code></span></span>
<span><code>readdir()</code><span><code>getdents()</code></span></span>
<span><code>closedir()</code><span><code>close()</code></span></span>
<span><code>...</code></span>
</div>
<div>
<span><code>ioq</code></span>
<span><code>opendir()</code><span><code>openat()</code></span></span>
<span><code>readdir()</code><span><code>getdents()</code></span></span>
<span><code>closedir()</code><span><code>close()</code></span></span>
<span><code>...</code></span>
</div>

<p><code>bfs</code> 3.0 will create up to 8 threads to process I/O queue operations, depending on how many cores you have.
It does not scale very well beyond that point, being bottlenecked on the single main thread.
You can override the default thread count choice with <code>-j1</code>, <code>-j2</code>, etc., (like <code>make</code>).</p>
<h2 id="what-about-io_uring"><a href="#what-about-io_uring">What about io_uring?</a></h2>
<p>If you&#39;ve been keeping up with recent developments in async I/O (at least on Linux), you may be wondering why <code>bfs</code> doesn&#39;t use <a href="https://en.wikipedia.org/wiki/Io_uring">io_uring</a>.
The answer is pretty simple: io_uring doesn&#39;t support the <code>getdents()</code> syscall that underlies <code>readdir()</code>.
There is a <a href="https://lore.kernel.org/io-uring/20230718132112.461218-1-hao.xu@linux.dev/T/">patchset</a> implementing it that&#39;s <a href="https://twitter.com/axboe/status/1679926006721966080">on track</a> to being merged, and <code>bfs</code> has a <a href="https://github.com/tavianator/bfs/pull/106">pull request</a> ready to take advantage of it.</p>
<p>Interestingly, just using a single io_uring instance was not competitive with <code>bfs</code>&#39;s I/O queues in my benchmarks.
My current best implementation uses one io_uring per thread, and uses the same I/O queue implementation to send commands back and forth with the main thread.
Of course, performance may be different once <code>IORING_OP_GETDENTS</code> is integrated into the kernel.</p>
<h2 id="so-how-fast-is-it"><a href="#so-how-fast-is-it">So how fast is it?</a></h2>
<p>The point of the <a href="https://github.com/tavianator/bfs/compare/2.6.3...3.0.1">~5,000 lines of code</a> it took to implement I/O queues was to improve performance.
To measure that benefit, I used a combination of <a href="https://github.com/sharkdp/hyperfine">hyperfine</a> and my new benchmark harness <a href="https://github.com/tavianator/tailfin">tailfin</a>.
The results speak for themselves.</p>
<p>For exploring my entire home directory (~7.6 million files), the new <code>bfs</code> is 2.2× faster than the previous release series, and almost 3× faster than GNU find.
Surprisingly, <a href="https://github.com/sharkdp/fd"><code>fd</code></a> was the slowest in this benchmark.</p>

<pre><code>Benchmark 1: fd -u &#39;^$&#39; ~
  Time (<span>mean</span> ± <span>σ</span>):      <span>8.209 s</span> ±  <span>0.023 s</span>    [User: 31.908 s, System: 339.069 s]
  Range (<span>min</span> … <span>max</span>):    <span>8.170 s</span> …  <span>8.250 s</span>    16 runs

Benchmark 2: find ~ -false
  Time (<span>mean</span> ± <span>σ</span>):      <span>7.021 s</span> ±  <span>0.045 s</span>    [User: 1.138 s, System: 5.783 s]
  Range (<span>min</span> … <span>max</span>):    <span>6.968 s</span> …  <span>7.103 s</span>    16 runs

Benchmark 3: bfs-2.6.3 ~ -false
  Time (<span>mean</span> ± <span>σ</span>):      <span>5.307 s</span> ±  <span>0.030 s</span>    [User: 0.779 s, System: 4.355 s]
  Range (<span>min</span> … <span>max</span>):    <span>5.268 s</span> …  <span>5.395 s</span>    16 runs

Benchmark 4: bfs-3.0.1 ~ -false
  Time (<span>mean</span> ± <span>σ</span>):      <span>2.416 s</span> ±  <span>0.023 s</span>    [User: 2.823 s, System: 11.547 s]
  Range (<span>min</span> … <span>max</span>):    <span>2.369 s</span> …  <span>2.454 s</span>    16 runs

Summary
  <span>bfs-3.0.1 ~ -false</span> ran
    <span>2.20</span> ± <span>0.02</span> times faster than <span>bfs-2.6.3 ~ -false</span>
    <span>2.91</span> ± <span>0.03</span> times faster than <span>find ~ -false</span>
    <span>3.40</span> ± <span>0.03</span> times faster than <span>fd -u &#39;^$&#39; ~</span></code></pre>
<p>I used the expression <code>-false</code> for these benchmarks so that <code>visit()</code> does the absolute minimum amount of work possible, and the benchmark focuses on just directory traversal.
Similarly, for <code>fd</code> I used the regex <code>^$</code> which never matches a filename.</p>
<h2 id="why-breadth-first"><a href="#why-breadth-first">Why breadth-first?</a></h2>
<p>A big motivation for <code>bfs</code> is that in my experience, if you&#39;re looking for a particular file, breadth-first search usually finds it earlier than depth-first.
That&#39;s because most <em>interesting</em> files tend to be close to the root (e.g. <code>~/Downloads/pay_slip.pdf</code>), while most <em>files</em> tend to be deeper in the tree.
(And if you&#39;re looking for a deep file, you&#39;ll probably have to search a large portion of the tree anyway.)
This makes it great for interactive use with things like <a href="https://github.com/junegunn/fzf">fzf</a>.</p>
<p>I measured its advantage for this use case using a command line that quits as soon as a match is found.
My whole home directory contains only one file with this name, at depth 3.</p>
<pre><code>Benchmark 1: fd -u1 &#39;kd-forest\.mkv&#39; ~
  Time (<span>mean</span> ± <span>σ</span>):      <span>3.727 s</span> ±  <span>1.292 s</span>    [User: 14.810 s, System: 153.457 s]
  Range (<span>min</span> … <span>max</span>):    <span>0.810 s</span> …  <span>5.149 s</span>    10 runs

Benchmark 2: find ~ -name kd-forest.mkv -quit
  Time (<span>mean</span> ± <span>σ</span>):      <span>4.675 s</span> ±  <span>0.018 s</span>    [User: 1.428 s, System: 3.197 s]
  Range (<span>min</span> … <span>max</span>):    <span>4.638 s</span> …  <span>4.695 s</span>    10 runs

Benchmark 3: bfs-2.6.3 ~ -name kd-forest.mkv -quit
  Time (<span>mean</span> ± <span>σ</span>):      <span>14.0 ms</span> ±   <span>2.7 ms</span>    [User: 6.5 ms, System: 7.5 ms]
  Range (<span>min</span> … <span>max</span>):     <span>6.5 ms</span> …  <span>17.5 ms</span>    166 runs

Benchmark 4: bfs-3.0.1 ~ -name kd-forest.mkv -quit
  Time (<span>mean</span> ± <span>σ</span>):      <span>10.4 ms</span> ±   <span>1.2 ms</span>    [User: 5.8 ms, System: 33.4 ms]
  Range (<span>min</span> … <span>max</span>):     <span>5.0 ms</span> …  <span>12.6 ms</span>    352 runs

Summary
  <span>bfs-3.0.1 ~ -name kd-forest.mkv -quit</span> ran
    <span>1.34</span> ± <span>0.31</span>   times faster than <span>bfs-2.6.3 ~ -name kd-forest.mkv -quit</span>
  <span>358.65</span> ± <span>131.44</span> times faster than <span>fd -u1 &#39;kd-forest\.mkv&#39; ~</span>
  <span>449.88</span> ± <span>53.65</span>  times faster than <span>find ~ -name kd-forest.mkv -quit</span></code></pre>
<p>This is the main use case I care about (basically recursive tab completion), and <code>bfs</code> is 450× faster than GNU find.</p>

                    </main>

                    
                </div>
            </div>

            

        </div>






        
        
        

        
        
        

        <!-- Custom JS scripts -->


    </div>
    

</div>
  </body>
</html>
