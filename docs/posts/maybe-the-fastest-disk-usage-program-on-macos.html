<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://healeycodes.com/maybe-the-fastest-disk-usage-program-on-macos">Original</a>
    <h1>Maybe the Fastest Disk Usage Program on macOS</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>I set out to write the fastest <code>du -sh</code> clone on macOS and I think I&#39;ve done it. On a large benchmark, <a href="https://github.com/healeycodes/dumac">dumac</a> is 6.4x faster than <code>du</code> and 2.58x faster than <a href="https://github.com/sharkdp/diskus">diskus</a> with a warm disk cache.</p><p>The odds were certainly in my favor as diskus does not use macOS-specific syscalls and instead uses standard POSIX APIs. As I&#39;ll go on to explain, I used <a href="https://docs.rs/tokio/latest/tokio/task/">tokio tasks</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=getattrlistbulk&amp;sektion=2&amp;manpath=macOS+13.6.5">getattrlistbulk</a> to be faster than the current crop of <code>du -sh</code> clones that run on macOS.</p><h2 id="the-challenge">The Challenge</h2><p>My benchmark is a directory with 12 levels, 100 small files per level, with a branching factor of two — 4095 directories, 409500 files.</p><p><code>du -sh</code> (disk usage, summarize, human-readable) works out the total size of a directory by traversing all the files and subdirectories. It must list every file and retrieve each file&#39;s size (in blocks) to sum the total.</p><p>On Unix-like systems a directory listing, like <code>readdir</code>, or the <code>fts</code> family of traversal functions, only provide filenames and inode numbers. It doesn&#39;t provide file sizes. So <code>du</code> needs to call <code>lstat</code> on every single file and hardlink it comes across.</p><p>In my benchmark this means making 4k+ syscalls for the directories and 400k+ syscalls for the files.</p><p>The traditional <code>du</code> (from GNU coreutils or BSD) is typically single-threaded and processes one file at a time. It doesn&#39;t use multiple CPU cores, or overlapping I/O operations, meaning the work is handled sequentially.</p><p>On my Apple M1 Pro, the CPU is not saturated and the majority of the time is spent waiting on each sequential syscall.</p><pre><div><div><p><span>time</span><span> </span><span>du</span><span> -sh ./deep</span></p><p><span></span><span>1</span><span>.6G    ./deep</span></p><p><span></span><span>du</span><span> -sh ./deep  </span><span>0</span><span>.04s user </span><span>1</span><span>.08s system </span><span>43</span><span>% cpu </span><span>2.570</span><span> total</span></p></div></div></pre><p>The performance of disk usage programs depends on the filesystem and the underlying hardware. Benchmarks for these projects are usually done on Linux with a cold or warm disk cache. For the cold runs, the disk cache is cleared between each run.</p><p>I couldn&#39;t find a reliable way of clearing the disk cache on macOS. However, on macOS with modern Apple hardware, I found that the performance of disk usage programs with a warm disk cache strongly correlates with cold disk cache performance. So to make my life easier, warm disk cache results are the only thing I&#39;m measuring and comparing.</p><h2 id="concurrency">Concurrency</h2><p>Previously, when I wrote about <a href="https://healeycodes.com/beating-grep-with-go">beating the performance of grep with Go</a>, I found that just adding goroutines was enough to outperform the stock <code>grep</code> that comes with macOS.</p><p>My first attempt to write a faster <code>du -sh</code> in Go did not go so well. I expected that my quick prototype, focused on the core problem of traversing and summing the block size, would be faster.</p><pre><div><div><p><span>var</span><span> sem </span><span>=</span><span> </span><span>make</span><span>(</span><span>chan</span><span> </span><span>struct</span><span>{</span><span>}</span><span>,</span><span> </span><span>16</span><span>)</span><span></span></p><p><span></span><span>func</span><span> </span><span>handleDir</span><span>(</span><span>rootDir </span><span>string</span><span>,</span><span> ch </span><span>chan</span><span> </span><span>int64</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    size </span><span>:=</span><span> </span><span>int64</span><span>(</span><span>0</span><span>)</span><span></span></p><p><span>    </span><span>// open()</span><span></span></p><p><span>    dir</span><span>,</span><span> err </span><span>:=</span><span> os</span><span>.</span><span>Open</span><span>(</span><span>rootDir</span><span>)</span><span></span></p><p><span>    </span><span>if</span><span> err </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span><span></span></p><p><span>        </span><span>panic</span><span>(</span><span>err</span><span>)</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span>    </span><span>defer</span><span> dir</span><span>.</span><span>Close</span><span>(</span><span>)</span><span></span></p><p><span>    </span><span>// readdir()</span><span></span></p><p><span>    files</span><span>,</span><span> err </span><span>:=</span><span> dir</span><span>.</span><span>Readdir</span><span>(</span><span>0</span><span>)</span><span></span></p><p><span>    </span><span>if</span><span> err </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span><span></span></p><p><span>        </span><span>panic</span><span>(</span><span>err</span><span>)</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span>    </span><span>for</span><span> </span><span>_</span><span>,</span><span> file </span><span>:=</span><span> </span><span>range</span><span> files </span><span>{</span><span></span></p><p><span>        sem </span><span>&lt;-</span><span> </span><span>struct</span><span>{</span><span>}</span><span>{</span><span>}</span><span></span></p><p><span>        </span><span>if</span><span> file</span><span>.</span><span>IsDir</span><span>(</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>            childCh </span><span>:=</span><span> </span><span>make</span><span>(</span><span>chan</span><span> </span><span>int64</span><span>)</span><span></span></p><p><span>            </span><span>go</span><span> </span><span>handleDir</span><span>(</span><span>filepath</span><span>.</span><span>Join</span><span>(</span><span>rootDir</span><span>,</span><span> file</span><span>.</span><span>Name</span><span>(</span><span>)</span><span>)</span><span>,</span><span> childCh</span><span>)</span><span></span></p><p><span>            childSize </span><span>:=</span><span> </span><span>&lt;-</span><span>childCh</span></p><p><span>            size </span><span>+=</span><span> childSize</span></p><p><span>        </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span></span></p><p><span>            </span><span>// stat()</span><span></span></p><p><span>            size </span><span>+=</span><span> file</span><span>.</span><span>Sys</span><span>(</span><span>)</span><span>.</span><span>(</span><span>*</span><span>syscall</span><span>.</span><span>Stat_t</span><span>)</span><span>.</span><span>Blocks </span><span>*</span><span> </span><span>512</span><span></span></p><p><span>        </span><span>}</span><span></span></p><p><span>        </span><span>&lt;-</span><span>sem</span></p><p><span>    </span><span>}</span><span></span></p><p><span>    ch </span><span>&lt;-</span><span> size</span></p><p><span></span><span>}</span></p></div></div></pre><p>It was slower than <code>du -sh</code>. It took twice as long on my benchmark.</p><pre><div><div><p><span>.</span><span>/</span><span>goroutines temp</span><span>/</span><span>deep  </span><span>0</span><span>.</span><span>30s user </span><span>3</span><span>.</span><span>12s system </span><span>68</span><span>%</span><span> cpu </span><span>4.987</span><span> total</span></p></div></div></pre><p>I ran a System Trace with macOS&#39;s Instruments to see what it was doing.</p><p><span><img alt="A list of system calls made by ./goroutines." fetchpriority="high" width="725" height="206.41176470588235" decoding="async" data-nimg="1" srcset="/_next/image?url=%2Fposts%2Fmaybe-the-fastest-disk-usage-program-on-macos%2Fsyscalls.png&amp;w=750&amp;q=100 1x, /_next/image?url=%2Fposts%2Fmaybe-the-fastest-disk-usage-program-on-macos%2Fsyscalls.png&amp;w=1920&amp;q=100 2x" src="https://mjg59.dreamwidth.org/_next/image?url=%2Fposts%2Fmaybe-the-fastest-disk-usage-program-on-macos%2Fsyscalls.png&amp;w=1920&amp;q=100"/></span></p><p>The high amount of <code>lstat64</code> calls is expected. That&#39;s fetching the attributes of each file. The <code>open</code> and <code>close</code> calls are also expected, roughly one per directory.</p><p><code>getdirentries64</code> calls is twice the number of directories in my benchmark. This is because it&#39;s designed to read directory entries into a buffer until it gets an empty result. This is the syscall that Go&#39;s <code>Readdir</code> uses under the hood on macOS.</p><p>The other syscalls here are related to the scheduling of goroutines and channels. I tried a few different designs (and different sized semaphores on the I/O) but it didn&#39;t affect performance that much.</p><p>I ran a CPU profile with pprof and saw that the majority of the time was spent doing the syscalls I saw above.</p><p><span><img alt="A Go CPU profile." fetchpriority="high" width="725" height="770.6605222734255" decoding="async" data-nimg="1" srcset="/_next/image?url=%2Fposts%2Fmaybe-the-fastest-disk-usage-program-on-macos%2Fgo-profile.png&amp;w=750&amp;q=100 1x, /_next/image?url=%2Fposts%2Fmaybe-the-fastest-disk-usage-program-on-macos%2Fgo-profile.png&amp;w=1920&amp;q=100 2x" src="https://mjg59.dreamwidth.org/_next/image?url=%2Fposts%2Fmaybe-the-fastest-disk-usage-program-on-macos%2Fgo-profile.png&amp;w=1920&amp;q=100"/></span></p><p>My understanding at this point was that there is an inherent system resource cost to getting this information out, with some bandwidth/contention limitations, and some per-syscall Go overhead too.</p><p>I went looking for a more efficient method of getting this information out of the kernel without making a syscall for each file.</p><h2 id="getattrlistbulk">getattrlistbulk</h2><p>macOS has a syscall called <a href="https://man.freebsd.org/cgi/man.cgi?query=getattrlistbulk&amp;sektion=2&amp;manpath=macOS+13.6.5">getattrlistbulk(2)</a> which allows you to read multiple directory entries and their metadata in one go. It&#39;s like a combined &#34;readdir + stat&#34; that returns a batch of file names along with requested attributes like file type, size, etc.</p><p>Instead of calling <code>stat</code> for every file, one <code>getattrlistbulk</code> call can return dozens or hundreds of entries at once. This means far fewer syscalls for my benchmark!</p><p>First you open a directory (one <code>open</code> call) and then make a <code>getattrlistbulk</code> call which will retrieve an amount of entries that fits in the passed buffer (128KB was optimal in my testing), along with the attributes you need to do the same work as <code>du -sh</code> like name, inode, type, and size. You loop and call it again until the directory is fully read (it returns <code>0</code> when done).</p><p>I found some background on this syscall in a <a href="https://lists.apple.com/archives/filesystem-dev/2014/Dec/msg00004.html">mailing list</a>:</p><blockquote><p>Also note that as of Yosemite, we have added a new API: getattrlistbulk(2), which is like getdirentriesattr(), but supported in VFS for all filesystems.  getdirentriesattr() is now deprecated.</p><p>The main advantage of the bulk call is that we can return results in most cases without having to create a vnode in-kernel, which saves on I/O: HFS+ on-disk layout is such that all of the directory entries in a given directory are clustered together and we can get multiple directory entries from the same cached on-disk blocks.</p></blockquote><p>My first attempt at wiring up this syscall used CGO. I wrote a C function that took a directory file descriptor and called <code>getattrlistbulk</code> in a loop until it had all the file info, and then returned the list of files and their attributes to Go.</p><pre><div><div><p><span>// File info structure to track size and inode</span><span></span></p><p><span></span><span>typedef</span><span> </span><span>struct</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>long</span><span> blocks</span><span>;</span><span></span></p><p><span>    </span><span>uint64_t</span><span> inode</span><span>;</span><span></span></p><p><span></span><span>}</span><span> </span><span>file_info_t</span><span>;</span><span></span></p><p><span></span><span>// Directory information and subdirectory names</span><span></span></p><p><span></span><span>typedef</span><span> </span><span>struct</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>file_info_t</span><span> </span><span>*</span><span>files</span><span>;</span><span></span></p><p><span>    </span><span>int</span><span> file_count</span><span>;</span><span></span></p><p><span>    </span><span>char</span><span> </span><span>*</span><span>*</span><span>subdirs</span><span>;</span><span></span></p><p><span>    </span><span>int</span><span> subdir_count</span><span>;</span><span></span></p><p><span></span><span>}</span><span> </span><span>dir_info_t</span><span>;</span><span></span></p><p><span></span><span>// Get directory info (called from Go)</span><span></span></p><p><span></span><span>dir_info_t</span><span>*</span><span> </span><span>get_dir_info</span><span>(</span><span>int</span><span> dirfd</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>struct</span><span> </span><span>attrlist</span><span> attrList </span><span>=</span><span> </span><span>{</span><span>0</span><span>}</span><span>;</span><span></span></p><p><span>    </span><span>// Describe what we want back</span><span></span></p><p><span>    attrList</span><span>.</span><span>bitmapcount </span><span>=</span><span> ATTR_BIT_MAP_COUNT</span><span>;</span><span></span></p><p><span>    attrList</span><span>.</span><span>commonattr </span><span>=</span><span> ATTR_CMN_RETURNED_ATTRS </span><span>|</span><span> ATTR_CMN_NAME </span><span>|</span><span> ATTR_CMN_ERROR </span><span>|</span><span> ATTR_CMN_OBJTYPE </span><span>|</span><span> ATTR_CMN_FILEID</span><span>;</span><span></span></p><p><span>    attrList</span><span>.</span><span>fileattr </span><span>=</span><span> ATTR_FILE_ALLOCSIZE</span><span>;</span><span></span></p><p><span>    </span><span>// Set buffer size (affects number of calls required)</span><span></span></p><p><span>    </span><span>char</span><span> attrBuf</span><span>[</span><span>128</span><span> </span><span>*</span><span> </span><span>1024</span><span>]</span><span>;</span><span></span></p><p><span>    </span><span>int</span><span> file_capacity </span><span>=</span><span> INITIAL_FILE_CAPACITY</span><span>;</span><span></span></p><p><span>    </span><span>file_info_t</span><span> </span><span>*</span><span>files </span><span>=</span><span> </span><span>(</span><span>file_info_t</span><span> </span><span>*</span><span>)</span><span>malloc</span><span>(</span><span>file_capacity </span><span>*</span><span> </span><span>sizeof</span><span>(</span><span>file_info_t</span><span>)</span><span>)</span><span>;</span><span></span></p><p><span>    </span><span>int</span><span> file_count </span><span>=</span><span> </span><span>0</span><span>;</span><span></span></p><p><span>    </span><span>int</span><span> subdir_capacity </span><span>=</span><span> INITIAL_SUBDIR_CAPACITY</span><span>;</span><span></span></p><p><span>    </span><span>char</span><span> </span><span>*</span><span>*</span><span>subdirs </span><span>=</span><span> </span><span>(</span><span>char</span><span> </span><span>*</span><span>*</span><span>)</span><span>malloc</span><span>(</span><span>subdir_capacity </span><span>*</span><span> </span><span>sizeof</span><span>(</span><span>char</span><span>*</span><span>)</span><span>)</span><span>;</span><span></span></p><p><span>    </span><span>int</span><span> subdir_count </span><span>=</span><span> </span><span>0</span><span>;</span><span></span></p><p><span>    </span><span>for</span><span> </span><span>(</span><span>;</span><span>;</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>        </span><span>int</span><span> retcount </span><span>=</span><span> </span><span>getattrlistbulk</span><span>(</span><span>dirfd</span><span>,</span><span> </span><span>&amp;</span><span>attrList</span><span>,</span><span> attrBuf</span><span>,</span><span> </span><span>sizeof</span><span>(</span><span>attrBuf</span><span>)</span><span>,</span><span> </span><span>0</span><span>)</span><span>;</span><span></span></p><p><span>        </span><span>if</span><span> </span><span>(</span><span>retcount </span><span>==</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>            </span><span>break</span><span>;</span><span></span></p><p><span>        </span><span>}</span><span></span></p><p><span>        </span><span>char</span><span> </span><span>*</span><span>entry </span><span>=</span><span> attrBuf</span><span>;</span><span></span></p><p><span>        </span><span>for</span><span> </span><span>(</span><span>int</span><span> i </span><span>=</span><span> </span><span>0</span><span>;</span><span> i </span><span>&lt;</span><span> retcount</span><span>;</span><span> i</span><span>++</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>          </span><span>// .. parsing code</span></p></div></div></pre><p>The Go-side of this looks quite similar to my initial prototype. The C types are automatically generated on the Go-side in my editor and during <code>go build</code>. To turn the C pointers into a Go slice or struct, you use <code>unsafe</code> functions.</p><p>You also need to then free the C memory by calling into CGO again.</p><pre><div><div><p><span>package</span><span> main</span></p><p><span></span><span>// #cgo CFLAGS: -O3 -march=native -Wall -flto</span><span></span></p><p><span></span><span>// #include &#34;lib.h&#34;</span><span></span></p><p><span></span><span>import</span><span> </span><span>&#34;C&#34;</span><span></span></p><p><span></span><span>// ..</span><span></span></p><p><span></span><span>func</span><span> </span><span>handleDir</span><span>(</span><span>rootDir </span><span>string</span><span>)</span><span> </span><span>int64</span><span> </span><span>{</span><span></span></p><p><span>    dir</span><span>,</span><span> err </span><span>:=</span><span> os</span><span>.</span><span>Open</span><span>(</span><span>rootDir</span><span>)</span><span></span></p><p><span>    </span><span>// ..</span><span></span></p><p><span>    info </span><span>:=</span><span> C</span><span>.</span><span>get_dir_info</span><span>(</span><span>C</span><span>.</span><span>int</span><span>(</span><span>dir</span><span>.</span><span>Fd</span><span>(</span><span>)</span><span>)</span><span>)</span><span></span></p><p><span>    </span><span>// Free the C objects&#39; memory</span><span></span></p><p><span>    </span><span>defer</span><span> C</span><span>.</span><span>free_dir_info</span><span>(</span><span>info</span><span>)</span><span></span></p><p><span>    size </span><span>:=</span><span> </span><span>int64</span><span>(</span><span>0</span><span>)</span><span></span></p><p><span>    </span><span>// Process files</span><span></span></p><p><span>    </span><span>if</span><span> info</span><span>.</span><span>file_count </span><span>&gt;</span><span> </span><span>0</span><span> </span><span>{</span><span></span></p><p><span>        files </span><span>:=</span><span> </span><span>(</span><span>*</span><span>[</span><span>1</span><span> </span><span>&lt;&lt;</span><span> </span><span>30</span><span>]</span><span>C</span><span>.</span><span>file_info_t</span><span>)</span><span>(</span><span>unsafe</span><span>.</span><span>Pointer</span><span>(</span><span>info</span><span>.</span><span>files</span><span>)</span><span>)</span><span>[</span><span>:</span><span>info</span><span>.</span><span>file_count</span><span>:</span><span>info</span><span>.</span><span>file_count</span><span>]</span><span></span></p><p><span>        </span><span>for</span><span> </span><span>_</span><span>,</span><span> file </span><span>:=</span><span> </span><span>range</span><span> files </span><span>{</span><span></span></p><p><span>            size </span><span>+=</span><span> </span><span>int64</span><span>(</span><span>file</span><span>.</span><span>blocks</span><span>)</span><span> </span><span>*</span><span> </span><span>512</span><span></span></p><p><span>        </span><span>}</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span>    </span><span>// Process subdirectories recursively</span><span></span></p><p><span>    </span><span>if</span><span> info</span><span>.</span><span>subdir_count </span><span>&gt;</span><span> </span><span>0</span><span> </span><span>{</span><span></span></p><p><span>        </span><span>var</span><span> wg sync</span><span>.</span><span>WaitGroup</span></p><p><span>        </span><span>var</span><span> totalSize </span><span>int64</span><span></span></p><p><span>        subdirs </span><span>:=</span><span> </span><span>(</span><span>*</span><span>[</span><span>1</span><span> </span><span>&lt;&lt;</span><span> </span><span>30</span><span>]</span><span>*</span><span>C</span><span>.</span><span>char</span><span>)</span><span>(</span><span>unsafe</span><span>.</span><span>Pointer</span><span>(</span><span>info</span><span>.</span><span>subdirs</span><span>)</span><span>)</span><span>[</span><span>:</span><span>info</span><span>.</span><span>subdir_count</span><span>:</span><span>info</span><span>.</span><span>subdir_count</span><span>]</span><span></span></p><p><span>        </span><span>for</span><span> i</span><span>,</span><span> subdir </span><span>:=</span><span> </span><span>range</span><span> subdirs </span><span>{</span><span></span></p><p><span>            wg</span><span>.</span><span>Add</span><span>(</span><span>1</span><span>)</span><span></span></p><p><span>            </span><span>go</span><span> </span><span>func</span><span>(</span><span>index </span><span>int</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>                </span><span>defer</span><span> wg</span><span>.</span><span>Done</span><span>(</span><span>)</span><span></span></p><p><span>                childSize </span><span>:=</span><span> </span><span>handleDir</span><span>(</span><span>filepath</span><span>.</span><span>Join</span><span>(</span><span>rootDir</span><span>,</span><span> C</span><span>.</span><span>GoString</span><span>(</span><span>subdir</span><span>)</span><span>)</span><span>)</span><span></span></p><p><span>                atomic</span><span>.</span><span>AddInt64</span><span>(</span><span>&amp;</span><span>totalSize</span><span>,</span><span> childSize</span><span>)</span><span></span></p><p><span>            </span><span>}</span><span>(</span><span>i</span><span>)</span><span></span></p><p><span>        </span><span>}</span><span></span></p><p><span>        wg</span><span>.</span><span>Wait</span><span>(</span><span>)</span><span></span></p><p><span>        size </span><span>+=</span><span> atomic</span><span>.</span><span>LoadInt64</span><span>(</span><span>&amp;</span><span>totalSize</span><span>)</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span>    </span><span>return</span><span> size</span></p><p><span></span><span>}</span></p></div></div></pre><p>The results were great. My Go program was now ~3x faster than <code>du -sh</code> for my benchmark.</p><pre><div><div><p><span>./cgo temp/deep  0.07s user 3.70s system 443% cpu 0.850 total</span></p></div></div></pre><p>I ran another CPU profile with pprof and saw that the majority of the time was spent in CGO, running my fairly optimized C code.</p><p><span><img alt="A Go CPU profile." fetchpriority="high" width="725" height="646.6216216216217" decoding="async" data-nimg="1" srcset="/_next/image?url=%2Fposts%2Fmaybe-the-fastest-disk-usage-program-on-macos%2Fcgo-profile.png&amp;w=750&amp;q=100 1x, /_next/image?url=%2Fposts%2Fmaybe-the-fastest-disk-usage-program-on-macos%2Fcgo-profile.png&amp;w=1920&amp;q=100 2x" src="https://mjg59.dreamwidth.org/_next/image?url=%2Fposts%2Fmaybe-the-fastest-disk-usage-program-on-macos%2Fcgo-profile.png&amp;w=1920&amp;q=100"/></span></p><p>This was where I wanted to spend CPU time: setting up the <code>getattrlistbulk</code> call, making it, and parsing the result. I optimized the buffer size (KB) and also tuned some of the memory allocations but then I hit a dead end. I couldn&#39;t get any faster without changing the overall design.</p><p>I had spent a few hours to get this far and now I wanted to go all the way. I knew that using CGO was suboptimal here because of the <a href="https://groups.google.com/g/golang-dev/c/XSkrp1_FdiU">overhead of calling into C from Go</a>. I&#39;ve seen some sources suggest that the cost is 40ns for trivial calls. Along with some extra allocations on the Go side that I was having trouble getting rid of, I suspected the per-directory overhead to be higher.</p><p>I wanted to go all the way and see how fast I could push the performance here. So I ported my program to Rust.</p><h2 id="rust">Rust</h2><p>By using Rust, I avoid a context switch between runtimes. I&#39;m making the same C function call underneath, <code>libc::getattrlistbulk</code>, but it&#39;s a zero-cost abstraction. My program calls into the kernel many times from Rust, but without bouncing back and forth between Go and C on each directory.</p><p>I also needed a new concurrency primitive. An alternative to Go&#39;s goroutines. I picked <a href="https://docs.rs/tokio/latest/tokio/task/">tokio tasks</a> as I understand them to be fairly analogous — light-weight, multiplexed green threads, and cheap to spawn.</p><pre><div><div><p><span>// Calculate total size recursively</span><span></span></p><p><span></span><span>fn</span><span> </span><span>calculate_size</span><span>(</span><span>root_dir</span><span>:</span><span> </span><span>String</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>Pin</span><span>&lt;</span><span>Box</span><span>&lt;</span><span>dyn</span><span> </span><span>Future</span><span>&lt;</span><span>Output</span><span> </span><span>=</span><span> </span><span>Result</span><span>&lt;</span><span>i64</span><span>,</span><span> </span><span>String</span><span>&gt;&gt;</span><span> </span><span>+</span><span> </span><span>Send</span><span>&gt;&gt;</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>Box</span><span>::</span><span>pin</span><span>(</span><span>async</span><span> </span><span>move</span><span> </span><span>{</span><span></span></p><p><span>        </span><span>// Get directory contents</span><span></span></p><p><span>        </span><span>let</span><span> dir_info </span><span>=</span><span> </span><span>tokio</span><span>::</span><span>task</span><span>::</span><span>spawn_blocking</span><span>(</span><span>{</span><span></span></p><p><span>            </span><span>let</span><span> root_dir </span><span>=</span><span> root_dir</span><span>.</span><span>clone</span><span>(</span><span>)</span><span>;</span><span></span></p><p><span>            </span><span>// Make the libc::getattrlistbulk call</span><span></span></p><p><span>            </span><span>move</span><span> </span><span>|</span><span>|</span><span> </span><span>get_dir_info</span><span>(</span><span>&amp;</span><span>root_dir</span><span>)</span><span></span></p><p><span>        </span><span>}</span><span>)</span><span>.</span><span>await</span><span>.</span><span>map_err</span><span>(</span><span>|</span><span>_</span><span>|</span><span> </span><span>&#34;task join error&#34;</span><span>.</span><span>to_string</span><span>(</span><span>)</span><span>)</span><span>?</span><span>?</span><span>;</span><span></span></p><p><span>        </span><span>let</span><span> </span><span>mut</span><span> total_size </span><span>=</span><span> </span><span>0i64</span><span>;</span><span></span></p><p><span>        </span><span>// Process files in this directory, deduplicating by inode</span><span></span></p><p><span>        </span><span>for</span><span> file </span><span>in</span><span> </span><span>&amp;</span><span>dir_info</span><span>.</span><span>files </span><span>{</span><span></span></p><p><span>            total_size </span><span>+=</span><span> </span><span>check_and_add_inode</span><span>(</span><span>file</span><span>.</span><span>inode</span><span>,</span><span> file</span><span>.</span><span>blocks</span><span>)</span><span>;</span><span></span></p><p><span>        </span><span>}</span><span></span></p><p><span>        </span><span>// Process subdirectories concurrently with limiting</span><span></span></p><p><span>        </span><span>if</span><span> </span><span>!</span><span>dir_info</span><span>.</span><span>subdirs</span><span>.</span><span>is_empty</span><span>(</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>            </span><span>let</span><span> semaphore </span><span>=</span><span> </span><span>Arc</span><span>::</span><span>new</span><span>(</span><span>Semaphore</span><span>::</span><span>new</span><span>(</span><span>MAX_CONCURRENT</span><span>)</span><span>)</span><span>;</span><span></span></p><p><span>            </span><span>let</span><span> futures</span><span>:</span><span> </span><span>Vec</span><span>&lt;</span><span>_</span><span>&gt;</span><span> </span><span>=</span><span> dir_info</span><span>.</span><span>subdirs</span><span>.</span><span>into_iter</span><span>(</span><span>)</span><span></span></p><p><span>                </span><span>.</span><span>map</span><span>(</span><span>|</span><span>subdir</span><span>|</span><span> </span><span>{</span><span></span></p><p><span>                    </span><span>let</span><span> semaphore </span><span>=</span><span> semaphore</span><span>.</span><span>clone</span><span>(</span><span>)</span><span>;</span><span></span></p><p><span>                    </span><span>let</span><span> subdir_path </span><span>=</span><span> </span><span>Path</span><span>::</span><span>new</span><span>(</span><span>&amp;</span><span>root_dir</span><span>)</span><span>.</span><span>join</span><span>(</span><span>&amp;</span><span>subdir</span><span>)</span><span>.</span><span>to_string_lossy</span><span>(</span><span>)</span><span>.</span><span>to_string</span><span>(</span><span>)</span><span>;</span><span></span></p><p><span>                    </span><span>tokio</span><span>::</span><span>spawn</span><span>(</span><span>async</span><span> </span><span>move</span><span> </span><span>{</span><span></span></p><p><span>                        </span><span>let</span><span> _permit </span><span>=</span><span> semaphore</span><span>.</span><span>acquire</span><span>(</span><span>)</span><span>.</span><span>await</span><span>.</span><span>unwrap</span><span>(</span><span>)</span><span>;</span><span></span></p><p><span>                        </span><span>calculate_size</span><span>(</span><span>subdir_path</span><span>)</span><span>.</span><span>await</span><span></span></p><p><span>                    </span><span>}</span><span>)</span><span></span></p><p><span>                </span><span>}</span><span>)</span><span></span></p><p><span>                </span><span>.</span><span>collect</span><span>(</span><span>)</span><span>;</span><span></span></p><p><span>            </span><span>// Collect all results</span><span></span></p><p><span>            </span><span>for</span><span> future </span><span>in</span><span> futures </span><span>{</span><span></span></p><p><span>                </span><span>match</span><span> future</span><span>.</span><span>await</span><span> </span><span>{</span><span></span></p><p><span>                    </span><span>Ok</span><span>(</span><span>Ok</span><span>(</span><span>size</span><span>)</span><span>)</span><span> </span><span>=&gt;</span><span> total_size </span><span>+=</span><span> size</span><span>,</span><span></span></p><p><span>                    </span><span>// ..</span><span></span></p><p><span>                </span><span>}</span><span></span></p><p><span>            </span><span>}</span><span></span></p><p><span>        </span><span>}</span><span></span></p><p><span>        </span><span>Ok</span><span>(</span><span>total_size</span><span>)</span><span></span></p><p><span>    </span><span>}</span><span>)</span><span></span></p><p><span></span><span>}</span></p></div></div></pre><p>Similar to my original Go prototype, it&#39;s a recursive traversal. I experimented with some concurrency limiting to avoid thrashing system resources and the overhead of context-switching and contention of threads. It didn&#39;t yield much performance improvements. Maybe 10% or so. I settled with a semaphore of 64.</p><p><code>du -sh</code> deduplicates hardlinks so, while working concurrently, every time we sum the block size of a file, we need to lock and check whether we&#39;ve seen the inode before.</p><p>I used a sharded inode set for this to lower the lock contention overhead.</p><pre><div><div><p><span>// Sharded inode tracking</span><span></span></p><p><span></span><span>const</span><span> </span><span>SHARD_COUNT</span><span>:</span><span> </span><span>usize</span><span> </span><span>=</span><span> </span><span>128</span><span>;</span><span></span></p><p><span></span><span>// Global sharded inode set for hardlink deduplication</span><span></span></p><p><span></span><span>static</span><span> </span><span>SEEN_INODES</span><span>:</span><span> </span><span>LazyLock</span><span>&lt;</span><span>[</span><span>Mutex</span><span>&lt;</span><span>HashSet</span><span>&lt;</span><span>u64</span><span>&gt;&gt;</span><span>;</span><span> </span><span>SHARD_COUNT</span><span>]</span><span>&gt;</span><span> </span><span>=</span><span> </span><span>LazyLock</span><span>::</span><span>new</span><span>(</span><span>|</span><span>|</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>std</span><span>::</span><span>array</span><span>::</span><span>from_fn</span><span>(</span><span>|</span><span>_</span><span>|</span><span> </span><span>Mutex</span><span>::</span><span>new</span><span>(</span><span>HashSet</span><span>::</span><span>new</span><span>(</span><span>)</span><span>)</span><span>)</span><span></span></p><p><span></span><span>}</span><span>)</span><span>;</span></p></div></div></pre><p>In my final benchmark results, I&#39;ve included diskus — a delightfully simple (and fast!) <code>du -sh</code> clone. It doesn&#39;t use macOS native APIs so it&#39;s a bit of an unfair comparison but it is the fastest <code>du -sh</code> clone I could find aside from my final Rust program which I&#39;ve called dumac.</p><pre><div><div><p><span>hyperfine --warmup 3 --min-runs 3 &#39;du -sh temp/deep&#39; &#39;diskus temp/deep&#39; &#39;./goroutines temp/deep&#39; &#39;./cgo temp/deep&#39; &#39;./target/release/dumac temp/deep&#39;</span></p><p><span>Benchmark 1: du -sh temp/deep</span></p><p><span>  Time (mean ± σ):      3.330 s ±  0.220 s    [User: 0.040 s, System: 1.339 s]</span></p><p><span>  Range (min … max):    3.115 s …  3.554 s    3 runs</span></p><p><span>Benchmark 2: diskus temp/deep</span></p><p><span>  Time (mean ± σ):      1.342 s ±  0.068 s    [User: 0.438 s, System: 7.728 s]</span></p><p><span>  Range (min … max):    1.272 s …  1.408 s    3 runs</span></p><p><span>Benchmark 3: ./goroutines temp/deep</span></p><p><span>  Time (mean ± σ):      6.810 s ±  0.010 s    [User: 0.290 s, System: 3.380 s]</span></p><p><span>  Range (min … max):    6.799 s …  6.816 s    3 runs</span></p><p><span>Benchmark 4: ./cgo temp/deep</span></p><p><span>  Time (mean ± σ):     564.6 ms ±  19.5 ms    [User: 51.1 ms, System: 2634.2 ms]</span></p><p><span>  Range (min … max):   542.6 ms … 591.0 ms    5 runs</span></p><p><span>Benchmark 5: ./target/release/dumac temp/deep</span></p><p><span>  Time (mean ± σ):     521.0 ms ±  24.1 ms    [User: 114.4 ms, System: 2424.5 ms]</span></p><p><span>  Range (min … max):   493.2 ms … 560.6 ms    6 runs</span></p><p><span>Summary</span></p><p><span>  ./target/release/dumac temp/deep ran</span></p><p><span>    1.08 ± 0.06 times faster than ./cgo temp/deep</span></p><p><span>    2.58 ± 0.18 times faster than diskus temp/deep</span></p><p><span>    6.39 ± 0.52 times faster than du -sh temp/deep</span></p><p><span>   13.07 ± 0.61 times faster than ./goroutines temp/deep</span></p></div></div></pre><p>I was able to remove ~43ms by moving from Go/CGO to Rust.</p><p>If my program is a success, it&#39;s because I&#39;ve tried to reduce the cost of all of the work that is not optimal syscalls.</p><p>The time spent on syscalls is ~91% of the time in the below flamegraph. Locking for the inode deduplication is ~1.5% and the remaining time is the scheduling overhead of tokio.</p><p><span><img alt="The result of cargo flamegraph" fetchpriority="high" width="725" height="534.7240915208614" decoding="async" data-nimg="1" srcset="/_next/image?url=%2Fposts%2Fmaybe-the-fastest-disk-usage-program-on-macos%2Fflamegraph.png&amp;w=750&amp;q=100 1x, /_next/image?url=%2Fposts%2Fmaybe-the-fastest-disk-usage-program-on-macos%2Fflamegraph.png&amp;w=1920&amp;q=100 2x" src="https://mjg59.dreamwidth.org/_next/image?url=%2Fposts%2Fmaybe-the-fastest-disk-usage-program-on-macos%2Fflamegraph.png&amp;w=1920&amp;q=100"/></span></p><h2 id="further-reading">Further Reading</h2><p>I have <a href="https://github.com/healeycodes/dumac/blob/main/previousattamps/gosyscall/main.go">a version</a> where I called <code>getattrlistbulk</code> from within Go like:</p><pre><div><div><p><span>syscall</span><span>.</span><span>RawSyscall6</span><span>(</span><span></span></p><p><span>            SYS_GETATTRLISTBULK</span><span>,</span><span></span></p><p><span>            </span><span>uintptr</span><span>(</span><span>fd</span><span>)</span><span>,</span><span></span></p><p><span>            </span><span>uintptr</span><span>(</span><span>unsafe</span><span>.</span><span>Pointer</span><span>(</span><span>&amp;</span><span>attrList</span><span>)</span><span>)</span><span>,</span><span></span></p><p><span>            </span><span>uintptr</span><span>(</span><span>unsafe</span><span>.</span><span>Pointer</span><span>(</span><span>&amp;</span><span>attrBuf</span><span>[</span><span>0</span><span>]</span><span>)</span><span>)</span><span>,</span><span></span></p><p><span>            </span><span>uintptr</span><span>(</span><span>len</span><span>(</span><span>attrBuf</span><span>)</span><span>)</span><span>,</span><span></span></p><p><span>            </span><span>0</span><span>,</span><span> </span><span>// options</span><span></span></p><p><span>            </span><span>0</span><span>,</span><span> </span><span>// unused</span><span></span></p><p><span>        </span><span>)</span></p></div></div></pre><p>But it was actually slower than using CGO.</p><p>The <a href="https://github.com/healeycodes/dumac">dumac repository</a> contains the source code for <a href="https://github.com/healeycodes/dumac/tree/main/previousattamps">my attempts</a> as I iterated towards my final Rust program.</p><p>I was inspired by the work behind <a href="https://codeberg.org/201984/dut">dut</a> (<a href="https://codeberg.org/201984/dut">Show HN: Dut – a fast Linux disk usage calculator</a>) which is sadly Linux-only. I&#39;m fairly confident that some of the ideas behind it could be ported to macOS native APIs and supersede the performance of my program. Especially when it comes to reducing the overhead of tokio&#39;s scheduler.</p><p>There are also some fast disk usage programs that show useful, and in some cases interactive, terminal output like <a href="https://github.com/bootandy/dust">dust</a> and <a href="https://github.com/Byron/dua-cli">dua</a>.</p><p>A fairly up-to-date blog post on the performance of reading directories on macOS is <a href="https://blog.tempel.org/2019/04/dir-read-performance.html">Performance considerations when reading directories on macOS</a>.</p></div></div></div>
  </body>
</html>
