<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ethanseal.com/articles/ors-are-expensive">Original</a>
    <h1>A SQL Heuristic: ORs Are Expensive</h1>
    
    <div id="readability-page-1" class="page"><div><p>Query planning is hard. <em>Sometimes</em>.</p><p>Queries often have more than one filter (using an <code>and</code> clause).</p><p>But the developer can often end up in situations requiring an <code>or</code> clause:</p><pre><code><i>select</i> <i>count</i><i>(</i><i>*</i><i>)</i>
<i>from</i> <i>application</i>
<i>where</i> <i>submitter_id</i> <i>=</i> :<i>user_id</i>
<i>or</i> <i>reviewer_id</i> <i>=</i> :<i>user_id</i><i>;</i>
</code></pre><p>But this is slow! With 1,000,000 applications and 1000 users uniformly distributed on both columns, it takes over 100ms.<sup><a aria-describedby="footnote-label" data-footnote-ref="" href="#user-content-fn-1" id="user-content-fnref-1">1</a></sup></p><p>If we rewrite it with only <code>and</code>s</p><pre><code><i>select</i> <i>(</i>
  <i>select</i> <i>count</i><i>(</i><i>*</i><i>)</i>
  <i>from</i> <i>application</i> <i>a</i>
  <i>where</i> <i>a</i><i>.</i><i>reviewer_id</i> <i>=</i> :<i>user_id</i>
<i>)</i> <i>+</i> <i>(</i>
  <i>select</i> <i>count</i><i>(</i><i>*</i><i>)</i>
  <i>from</i> <i>application</i> <i>a</i>
  <i>where</i> <i>a</i><i>.</i><i>submitter_id</i> <i>=</i> :<i>user_id</i>
<i>)</i> <i>-</i> <i>(</i>
  <i>select</i> <i>count</i><i>(</i><i>*</i><i>)</i>
  <i>from</i> <i>application</i> <i>a</i>
  <i>where</i> <i>a</i><i>.</i><i>submitter_id</i> <i>=</i> :<i>user_id</i>
  <i>and</i> <i>a</i><i>.</i><i>reviewer_id</i> <i>=</i> :<i>user_id</i>
<i>)</i><i>;</i>
</code></pre><p>This takes less than 1ms; Over 100 times faster! <sup><a aria-describedby="footnote-label" data-footnote-ref="" href="#user-content-fn-1" id="user-content-fnref-1-2">1</a></sup><sup><a aria-describedby="footnote-label" data-footnote-ref="" href="#user-content-fn-2" id="user-content-fnref-2">2</a></sup></p><p>This is surprising — we have indexes on the filtered columns.</p><p>But why? First, we need to develop some intuition about how and when indexes are used.</p><h2>Basic Query Planning Intuition</h2><p>Say you have a table with two columns and an index on each column.</p><pre><code><i>create</i> <i>table</i> <i>example_table</i> <i>(</i>
  text_column <i>varchar</i><i>(</i><i>2</i><i>)</i> <i>not</i> <i>null</i><i>,</i>
  num_column <i>int8</i> <i>not</i> <i>null</i>
<i>)</i><i>;</i>
</code></pre><p>Doing a simple lookup via a column is similar in time complexity to doing a lookup with a <code>BTreeMap&lt;String, ExampleTable&gt;</code> or <code>BTreeMap&lt;i64, ExampleTable&gt;</code>.</p><p>And if we use a compound index — <code>(text_column, num_column)</code>, it&#39;s like doing a lookup with <code>BTreeMap&lt;String, BTreeMap&lt;i64, ExampleTable&gt;&gt;</code>. So filtering with an <code>and</code> (or filtering by the first, then sorting by the latter) is natural with a compound index.</p><p>Now say we don&#39;t have a compound index, only individual indexes, then we have to be clever. We can use database statistics.</p><p>If we want to check where <code>text_column = &#39;ES&#39; and num_column = 1</code>, there&#39;s two options:</p><ol><li>lookup <code>&#39;ES&#39;</code>, then filter the results by the <code>num_column</code></li><li>lookup <code>1</code>, then filter by <code>text_column</code></li></ol><p>A couple problems to note here:</p><ul><li>If there&#39;s many <code>&#39;ES&#39;</code>s relative to the number of <code>1</code>s, or vice-versa, and we pick the wrong plan, we&#39;re reading more data from disk than we need. Remember, indexes are stored in chunks or pages on disk and that i/o is usually the bottleneck.</li><li>CPU and memory matter too! Loading large amounts of data into memory and processing it can be expensive. This gets worse as we start joining to other tables.</li></ul><p>To help us figure out the order, statistics can tell us how often each value shows up, helping us pick between the two options.</p><p>So now, our query plan will more strongly depend on the relative distribution of the two columns, not only our schema and scale.<sup><a aria-describedby="footnote-label" data-footnote-ref="" href="#user-content-fn-3" id="user-content-fnref-3">3</a></sup></p><p>Say we have a lot of <code>1</code>s, but not many <code>&#39;ES&#39;</code>s. We look at our statistics, which tell us that <code>1</code> is the most common value for the <code>num_column</code>. But we don&#39;t see <code>&#39;ES&#39;</code> in our list of common values for the <code>text_column</code>, based on that column&#39;s statistics.<sup><a aria-describedby="footnote-label" data-footnote-ref="" href="#user-content-fn-4" id="user-content-fnref-4">4</a></sup><sup><a aria-describedby="footnote-label" data-footnote-ref="" href="#user-content-fn-5" id="user-content-fnref-5">5</a></sup> All we need now is an index on the more specific side.</p><h3>Why ORs are Expensive</h3><p>Doing this with an <code>or</code> is a bit trickier. Assume we&#39;re doing <code>text_column = &#39;ES&#39; or num_column = 1</code>.</p><p>Two options:</p><ul><li>Do each filter separately, then merge them, effectively turning this into a <code>union distinct</code>.</li><li>Iterate through the all the data (i.e. a sequential scan), filtering the rows in memory.</li></ul><p>Statistics can still help when &#39;ES&#39; and 1 are both rare. We can do a lookup in the index (a page read) and read those rows (another page read), which is better than scanning the entire table (n page reads). Doing this twice for each filter and merging them with a <a href="https://pganalyze.com/docs/explain/other-nodes/bitmap-or">Bitwise Or</a>, we avoid the sequential scan, though it&#39;s still expensive — see our very first example.</p><p>Importantly, this idea of merging with Bitwise Or can be brittle. If we filter all the data with an extra condition (an <code>and</code> or a sort on a third column), then we need a compound index for each column (with that new column second). Otherwise, we&#39;ll be iterating through everything with a sequential scan. Try rewriting the query as a union (i.e. the <code>or</code> on the outside). <code>(x or y) and z = (x and z) or (y and z)</code>.<sup><a aria-describedby="footnote-label" data-footnote-ref="" href="#user-content-fn-7" id="user-content-fnref-7">6</a></sup></p><p>Also, an <code>and</code> (or intersection) decreases the amount of data, whereas an <code>or</code> (a union) will increase the amount of data returned, increasing the cost.<sup><a aria-describedby="footnote-label" data-footnote-ref="" href="#user-content-fn-6" id="user-content-fnref-6">7</a></sup></p><p>On a practical note, the most common operations in a relational database tend to be individual lookups or <code>and</code>s. E.g., Faceted search in an e-commerce site. Any good query planner need focus on optimizations for <code>and</code>s.</p><h2>Practical Tips</h2><p>There are two common issues in schema design that I see often:</p><ol><li>A table with multiple columns with the same type and constraints, usually a foreign key to the same table</li><li>Representing sum types as different tables</li></ol><p>Both of which are variations on the same concept: put the same data together (even if you have to give up some constraints).</p><h3>Just Add Another Table</h3><p>Going back to the first example:</p><pre><code><i>create</i> <i>table</i> <i>application</i> <i>(</i>
  application_id <i>int8</i> <i>not</i> <i>null</i><i>,</i>
  submitter_id <i>int8</i> <i>not</i> <i>null</i><i>,</i>
  reviewer_id <i>int8</i> <i>not</i> <i>null</i>
<i>)</i><i>;</i>
</code></pre><p>To query all <code>application</code>s that attached to a given user, we can create a secondary table to hold those users in a one-to-many relationship:</p><pre><code><i>create</i> <i>table</i> <i>application_user</i> <i>(</i>
  user_id <i>int8</i> <i>not</i> <i>null</i><i>,</i>
  application_id <i>int8</i> <i>not</i> <i>null</i><i>,</i>
  user_type <i>enum</i> <i>(</i><i>&#39;submitter&#39;</i><i>,</i> <i>&#39;reviewer&#39;</i><i>)</i> <i>not</i> <i>null</i>
<i>)</i><i>;</i>
</code></pre><p>We can rewrite our query to follow the indexes like this: <code>:user_id</code> -&gt; <code>application_user</code> -&gt; <code>user</code>.</p><pre><code><i>select</i> <i>*</i>
<i>from</i> <i>application</i> <i>a</i>
<i>join</i> <i>application_user</i> <i>au</i> <i>using</i> <i>(</i>application_id<i>)</i>
<i>where</i> <i>au</i><i>.</i><i>user_id</i> <i>=</i> :<i>user_id</i>
</code></pre><p>This is linear, making it very easy for the query planner. Now it&#39;s faster than the Bitwise Or that was used in our first example.</p><h3>Inheritance and Keyset Pagination</h3><p>Say we have two tables with a shared set of columns:</p><pre><code><i>create</i> <i>table</i> <i>post</i> <i>(</i>
  user_id <i>int8</i> <i>not</i> <i>null</i><i>,</i>
  title <i>text</i> <i>not</i> <i>null</i><i>,</i>
  body <i>text</i> <i>not</i> <i>null</i>
<i>)</i><i>;</i>
<i>create</i> <i>table</i> <i>comment</i> <i>(</i>
  user_id <i>int8</i> <i>not</i> <i>null</i><i>,</i>
  body <i>text</i> <i>not</i> <i>null</i><i>,</i>
  parent_id <i>int8</i> <i>not</i> <i>null</i>
<i>)</i><i>;</i>
</code></pre><p>If we want to find everything written by a user, the best we can do is rewrite it with a proper <code>union</code>.</p><p>But if we restructure our tables, we can &#34;inherit&#34; or &#34;extend&#34; from a base table, having one index for each shared column.</p><pre><code><i>create</i> <i>table</i> <i>writing</i> <i>(</i>
  writing_id <i>int8</i> <i>not</i> <i>null</i><i>,</i>
  user_id <i>int8</i> <i>not</i> <i>null</i><i>,</i>
  body <i>text</i> <i>not</i> <i>null</i>
<i>)</i><i>;</i>
<i>create</i> <i>table</i> <i>post</i> <i>(</i>
  writing_id <i>int8</i> <i>not</i> <i>null</i><i>,</i>
  title <i>text</i> <i>not</i> <i>null</i><i>,</i>
  <i>foreign</i> <i>key</i> writing_id references writing
<i>)</i><i>;</i>
<i>create</i> <i>table</i> <i>comment</i> <i>(</i>
  writing_id <i>int8</i> <i>not</i> <i>null</i><i>,</i>
  parent_id <i>int8</i> <i>not</i> <i>null</i><i>,</i>
  <i>foreign</i> <i>key</i> writing_id references writing
<i>)</i><i>;</i>
</code></pre><p>This isn&#39;t strictly necessary for all use cases; we can still do a <code>union</code> to get all the matches.</p><p>For instance, keyset pagination:</p><pre><code><i>select</i> <i>*</i>
<i>from</i> <i>(</i>
    <i>select</i> <i>p</i><i>.</i><i>post_id</i><i>,</i> <i><i>null</i></i> <i>comment_id</i><i>,</i> <i>p</i><i>.</i><i>title</i><i>,</i> <i>p</i><i>.</i><i>body</i><i>,</i> <i><i>null</i></i> <i>parent_id</i>
    <i>from</i> <i>post</i> <i>p</i>
    <i>where</i> <i>p</i><i>.</i><i>user_id</i> <i>=</i> :<i>user_id</i>
    <i>and</i> <i>p</i><i>.</i><i>post_id</i> <i>&amp;</i><i>gt</i><i>;</i> :post_id_start
    <i>order</i> <i>by</i> p<i>.</i>post_id
    <i>limit</i> :<i>page_size</i>
    <i>union</i>
    <i>select</i> <i><i>null</i></i> <i>post_id</i><i>,</i> <i>c</i><i>.</i><i>comment_id</i><i>,</i> <i><i>null</i></i><i>,</i> <i>c</i><i>.</i><i>body</i><i>,</i> <i>c</i><i>.</i><i>parent_id</i>
    <i>from</i> <i>comment</i> <i>c</i>
    <i>where</i> <i>c</i><i>.</i><i>user_id</i> <i>=</i> :<i>user_id</i>
    <i>and</i> <i>c</i><i>.</i><i>comment_id</i> <i>&amp;</i><i>gt</i><i>;</i> :comment_id_start
    <i>order</i> <i>by</i> c<i>.</i>comment_id
    <i>limit</i> :page_size
<i>)</i> keyset
<i>order</i> <i>by</i> keyset<i>.</i>post_id<i>,</i> keyset<i>.</i>comment_id
<i>limit</i> :page_size
</code></pre><p>However, this is <em>way</em> more complex and easy to get subtly wrong.</p><p>So, I always opt for the extension tables.</p><h2>The Moral</h2><p>Schema design is all about access patterns:</p><ul><li>What searches/multi-row scans are being done</li><li>Read-heavy vs write-heavy <ul><li>Same tables, could there be contention?</li></ul></li><li>etc.</li></ul><p>If you&#39;re never going to do an <code>or</code>, there&#39;s no need to worry about this!</p><p>Alas, requirements change...</p><h3>Addendum</h3><h4>Questions:</h4><ol><li>How do regular inverted indexes handle <code>or</code>s and negative searches efficiently?</li><li>Are there any writings on PostgreSQL Query Planning w.r.t <code>or</code>s digging into the code? Especially across tables, not only when filtering by the same column and table.</li><li>Any published research on <code>or</code> queries in general?</li><li>Is there a name for this &#34;extension&#34; pattern? There&#39;s a reference that it&#39;s common knowledge in <a href="https://www.scattered-thoughts.net/writing/against-sql#can-t-be-expressed">Jamie Brandon&#39;s Against SQL article</a>, but I&#39;ve never seen it directly talked about schema design or performance.</li><li>Has anyone experienced a case where added an extended index helped with or clauses on the same table?</li></ol></div></div>
  </body>
</html>
