<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://without.boats/blog/changing-the-rules-of-rust/">Original</a>
    <h1>Changing the Rules of Rust</h1>
    
    <div id="readability-page-1" class="page"><section><p>In Rust, there are certain API decisions about what is and isn’t sound that impact all Rust code.
That is, a decision was made to allow or not allow types which have certain safety requirements, and
now all users are committed to that decision. They can’t just use a different API with different
rules: <em>all</em> APIs must conform to these rules.</p><p>These rules are determined through certain “marker” traits. If a safe API could do something to a
value of a type which some types don’t support, the API must be bound by that marker trait, so that
users can not pass values of those types which don’t support that behavior to that API. In contrast,
if Rust allows APIs to perform that behavior on any type, without any sort of marker trait bound,
then types which don’t support that behavior cannot exist.</p><p>I’m going to give three examples to show what I mean, each of which Rust has considered at different
points, though only the first one actually exists in Rust.</p><h2 id="rules-of-rust">Rules of Rust</h2><h3 id="send"><code>Send</code></h3><p>Let’s say you want Rust to support types which can’t be sent across threads. There are a couple of
examples of <em>why</em> you would want this:</p><ul><li>The type provides shared ownership without synchronizing interior mutable writes to the reference
count (e.g. <code>Rc</code>)</li><li>The type may wrap an OS API that doesn’t guaranteee thread safety (e.g. <code>Args</code>, <code>MutexGuard</code>)</li></ul><p>To support this, you would include a marker trait called <code>Send</code>, which is the set of types which
<em>can</em> be sent across threads. Any API which might send a value to another thread needs to include a
<code>Send</code> bound, such as:</p><ul><li><code>thread::spawn</code>, which spawns a thread</li><li><code>rayon::join</code>, which runs two tasks on a thread pool</li><li><code>tokio::spawn</code>, which may move this task to another thread of the executor</li></ul><p>Of course, Rust chose to support types which can’t be sent across threads, and so it has a <code>Send</code>
bound. But an alternative Rust could have just as easily chosen that <em>all</em> types in Rust must
support sending across threads, and effectively all interior mutability would need to be
synchronized. Indeed, the <code>Send</code> trait is actually a decision fully enforced by the standard
library: someone could release an “alternative libcore” which imposes this requirement with no
change to rustc, though it wouldn’t be compatible with any of the Rust code that exists in the
world.</p><h3 id="move"><code>Move</code></h3><p>Let’s say you want Rust to support types which can’t be invalidated without running their destructor
once their address has been witnessed. This is a sort of wonky and specific definition of
“immoveable type,” but it happens to fit perfectly for what stackless coroutines and intrusive
data structures require.</p><p>To support this, you would include a marker trait called <code>Move</code>, which is the set of types that can
be moved freely. Unlike <code>Send</code>, <code>Move</code> requires some language support: I think the simplest way to
implement it would be to say that operations that take the address of something take ownership of
types if they don’t implement <code>Move</code> (so <code>let x = &amp;mut y;</code> takes ownership of <code>y</code>, effectively
preventing you from ever moving it again.) And the magic behavior of <code>Box</code> which lets you move out
of it would need to be bound by <code>Move</code> as well.</p><p>Additionally, certain APIs would need to be bounded by <code>Move</code>, which let you move out of a
reference, such as:</p><ul><li><code>mem::swap</code> lets you swap values behind two mutable references</li><li><code>mem::replace</code> lets you replace the value behind a mutable reference with another</li></ul><p>You’ll notice that Rust doesn’t have a <code>Move</code> trait; instead, it provides the same guarantees using
the <code>Pin</code> wrapper around pointer types. Even though the <code>Move</code> trait would have probably been a
much easier to use API, it proved difficult to add in a backward compatible way (I’ll explain why in
a moment), so instead the <code>Pin</code> API was added and used only in the new interfaces that required
these semantics.</p><h3 id="leak"><code>Leak</code></h3><p>Let’s say you want Rust to support types which can’t go out of scope without running their
destructor. This is one of the two different definitions of “linear types,” it is less expressive
than the other (which would also prevent a destructor from running, requiring the type to be
destructured as its final end), but it is the easier of the two to add to the language (because it
works better with generics), and it supports all of the most compelling use cases for linear types.</p><p>To support this, you would include a marker trait called <code>Leak</code>, which is the set of types that can
go out of scope without running their destructors. Like <code>Send</code> and unlike <code>Move</code>, this would require
no language support at all: its not possible to “leak” a value in the core language of Rust, you
have to use standard library APIs to do it.</p><p>Certain APIs would have to be bound by <code>Leak</code>:</p><ul><li>APIs that always leak a value (<code>mem::forget</code>)</li><li>APIs that make it your responsibility to run the destructor (<code>ManuallyDrop::new</code>)</li><li>APIs that allow cyclic shared ownership and can accidentally leak values (<code>Rc::new</code>, <code>Arc::new</code>)</li></ul><p>Of course, Rust doesn’t have the <code>Leak</code> trait, but it almost did. This discussion came to a head in
early 2015, when the scoped thread API that Rust was using was found to be unsound, because its
safety depended on its guard type never leaking. It was decided (in some haste, because the 1.0
release was scheduled within a few months of the controversy) that Rust would not support types that
can’t be leaked, and so the <code>Leak</code> trait would not be added.</p><h2 id="changing-the-rules">Changing the rules</h2><p>There’s been a renewed interest in supporting linear types in Rust, especially because of what I
called the <a href="https://without.boats/blog/the-scoped-task-trilemma">scoped task trilemma</a>, which is only true because of the fact that destructors
cannot be guaranteed to run. Unlike immoveable types, there is no isolated API addition that could
support guaranteeing that a destructor will run, the way there was with <code>Pin</code>. (You can guarantee a
destructor will run if you never give up ownership of the object and use a kind of closure passing
style, but this isn’t adequate for the “scoped task” use case). So some users would like to see Rust
add a <code>Leak</code> trait.</p><p>There are two possible ways a marker trait like <code>Leak</code> could be added to Rust:</p><ol><li><strong>Auto trait:</strong> you could add a new auto trait, like <code>Send</code> and <code>Sync</code></li><li><strong>?Trait:</strong> you could add a new “?Trait,” like <code>Sized</code></li></ol><p>Each of these presents certain challenges regarding backward compatibility.</p><h3 id="auto-traits">Auto traits</h3><p>At first glance, adding auto traits might seem like a backward compatible change. You add a new
trait, <code>Leak</code>, which says that a type can be leaked. Types that don’t implement this trait
cannot go out of scope without running their destructor. Because all types in Rust today necessarily
can be leaked (this is a consequence of the decision <em>not</em> to have a <code>Leak</code> trait), its perfectly
fine for all types to implement <code>Leak</code>. This is the semantics of an auto trait, so it sounds like it
should work great.</p><p>The problem comes when you go to add bounds to the APIs that can be used to leak values, like <code>mem::forget</code>. If you want to make it so that types that don’t implement <code>Leak</code>d
cannot be leaked, you need to add a bound to <code>mem::forget</code>. But there are two ways in which this
is not backward compatible.</p><p>First, it does not work with generics. This code is legal today, but would break if you add a
<code>Leak</code> bound to <code>mem::forget</code>:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>pub</span><span> </span><span>fn</span> <span>forget_generic</span><span>&lt;</span><span>T</span><span>&gt;</span><span>(</span><span>value</span>: <span>T</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>mem</span>::<span>forget</span><span>(</span><span>value</span><span>);</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>This is because there is no <code>Leak</code> bound on the type parameter for this function. Adding such a
bound to the API of <code>mem::forget</code> (or any other API that can forget values) would be a breaking
change.</p><p>Another way in which it is not backward compatible is that trait object types will not implement
<code>Leak</code> unless they add <code>+ Leak</code>. Trait object types do not inherit impls by way of auto traits,
because you don’t actually know what type the trait object is. So a trait object like <code>dyn Future</code>
does not implement <code>Leak</code>. For example:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>pub</span><span> </span><span>fn</span> <span>forget_trait_object</span><span>(</span><span>object</span>: <span>Box</span><span>&lt;</span><span>dyn</span><span> </span><span>Display</span><span>&gt;</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>mem</span>::<span>forget</span><span>(</span><span>object</span><span>);</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><h3 id="traits">?Traits</h3><p>So if adding an auto trait is not backward compatible, we are left turning to the <code>?Trait</code> solution.
But there are problems here as well.</p><p>in the strictest sense, adding a new trait like <code>?Leak</code> is backward compatible. Instead of adding
new bounds to APIs like <code>mem::forget</code>, you would be <em>relaxing</em> the bounds on other APIs. So all of
the code above would be fine, because to make a generic function that takes a linear type, you would
have to write a <code>?Leak</code> bound.</p><p>The first problem with this for something like <code>Leak</code> is that the vast majority of generic APIs in
Rust cannot possibly forget their value; after all, even though memory leaks are not undefined
behavior, they are still undesirable and mostly avoided. This is quite different from <code>Sized</code>:
because passing something by value requires <code>Sized</code>, the large majority of generic APIs in Rust
require <code>Sized</code>, and so <code>?Sized</code> bounds are relatively rare. In contrast, adding <code>?Leak</code> would
create a permanent scar across the ecosystem, as the vast majority of generics would gain a <code>T: ?Leak</code> bound.</p><p>The second problem is bigger, though: the interaction between <code>?Traits</code> and associated types means
that it is a breaking change to add a <code>?Trait</code> bound to an associated type. This means that any
stable associated type in the standard library cannot gain a <code>?Leak</code> bound.</p><p>Consider this example:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>pub</span><span> </span><span>fn</span> <span>forget_iterator</span><span>(</span><span>iter</span>: <span>impl</span><span> </span><span>Iterator</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>iter</span><span>.</span><span>for_each</span><span>(</span><span>mem</span>::<span>forget</span><span>);</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>This will forget every element of the iterator, even though the <code>Iterator::Item</code> associated type is
never mentioned. Therefore, <code>Iterator::Item</code> must implement <code>Leak</code>, always. The compiler is allowed
to assume that the item of every iterator implements <code>Leak</code>, and it would be a breaking change to
invalidate that assumption.</p><p>The implications of this are far reaching. If <code>Leak</code> were added as a <code>?Trait</code>, all of these things
would not be possible with linear types:</p><ul><li><strong>Iterator:</strong> You couldn’t construct an iterator of linear types.</li><li><strong>Future:</strong> You couldn’t construct a future that evaluates to a linear type (and so you couldn’t
return a linear type from an async function).</li><li><strong>Deref:</strong> You couldn’t dereference a Box containing a linear type, or dereference a vector of
linear types to a slice of linear types, or any other smart pointer type.</li><li><strong>Index:</strong> You couldn’t index a collection of a linear type, so you couldn’t index into a slice of
linear types or into a map with linear values.</li><li><strong>Add/Sub/Mul/Div:</strong> You couldn’t have a linear type as the output value of any overloaded
arithmetic operator.</li></ul><p>One special set of associated types is the return value of the <code>Fn</code> traits. The Rust project has
specifically made it difficult to refer to the <code>Output</code> associated type of these traits, so that it
would have flexibility to change this in the future. Still, certain issues were encountered in the
past when experimenting with a <code>Move</code> trait. It’s not clear to me if these issues would have been
encountered with other traits (like <code>Leak</code>) or if they were specific to the built-in semantics of
<code>Move</code>.</p><p>Basically, there is a very steep trade off in choosing to add a new <code>?Trait</code> - especially one that
wouldn’t be relevant to very many bounds, like <code>Leak</code> - because you will add confusing new syntax to
a huge variety of generic interfaces in exchange for getting a very limited new feature. I would
consider adopting something like <code>?Leak</code> a poor cost-benefit analysis, even if we do accept that the
current Rust rules are “wrong” and we wish Rust had linear types.</p><h3 id="editions">Editions</h3><p>The final thing that needs to be considered is the edition mechanism. Is it possible, using the
edition mechanism, to introduce one of these traits? Maybe.</p><p>Each edition in effect forms a “dialect” of Rust, all of which are supported by the same compiler.
So at first glance it sounds plausible that in one dialect of Rust, all types can be forgotten, and
in another dialect, the <code>Leak</code> trait exists. The problem is that a hard requirement on editions is
that crates from one edition can depend on crates from another edition, so that the upgrade from one
edition to the next is seamless and voluntary.</p><p>Consider that the Rust project decided to add the <code>Leak</code> trait in the 2024 edition. All of the
code in the 2021 edition needs to still work - including code like the examples I showed above.
Sure, you can use a tool like cargo fix to add <code>Leak</code> bounds everywhere and expect users to relax
them on their own as they move into the 2024 edition, but the code from the 2021 edition needs to
work without modification.</p><p>A way to possibly do this would be to make trait coherence depend on edition, so that in pre-2024
editions, every type meets the <code>Leak</code> bounds, even types that absolutely shouldn’t, like unbounded
generics, and trait object types that don’t mention <code>Leak</code>. If, in the pre-2024 editions, all
types implement <code>Leak</code>, then the added bounds will never fail.</p><p><em>However</em> - and this is the big, enormous caveat of this section - this would rely on the compiler
effectively implementing some kind of unbreakable firewall, to prevent a type that does not
implement <code>Leak</code> from ever getting used with pre-2024 code. This would mean:</p><ul><li>Any time post-2024 code instantiates a generic from pre-2024 code, it needes to check that the
type it instatiates it with implements <code>Leak</code>, even though the pre-2024 code doesn’t have such a
bound.</li><li>Any time pre-2024 code calls post-2024 code, it needs to check that the types it gets from that
API implement <code>Leak</code> (under the 2024 edition rules). Note that the standard library would be
considered post-2024 code, so every call to a std API would involve checking types for <code>Leak</code> in
the pre-2024 editions.</li></ul><p>I don’t know if this is even possible to implement, probably it would have pretty bad effect on
compile times at least on pre-2024 edition code, and it would likely create a very difficult
transition at first. But in the longer term at least it would leave <code>Leak</code> in the “right” state
(as an auto trait, which can be used with old associated types correctly, and not as a ?Trait).</p><h2 id="what-should-be-done">What should be done</h2><p>If I could go back in time to 2015, I think I would probably add both <code>Move</code> and <code>Leak</code> to Rust.
There are certain downsides, which were highlighted by the team at the time in their decision not to
add <code>Leak</code>: any trait object type which needs to meet these bounds needs to add <code>+ Move</code> or <code>+ Leak</code> to their definition. Having two auto traits of such global significance (<code>Send</code> and <code>Sync</code>)
was already considered enough of a burden.</p><p>But if I’m honest, I have the impression (I wasn’t there) that the decision to exclude <code>Leak</code> was at
least partly a matter of expediency: my understanding is that the Rust team at Mozilla was under
incredible pressure from their management to ship a 1.0 on the deadline they set, and this probably
influenced their decision not to make any last minute changes to the rules that could impact meeting
that deadline.</p><p>In a language with <code>Leak</code>, the scoped task trilemma wouldn’t exist, the simpler scoped thread API
would be safe, GC-integration would possibly be easier, and I’ve gotten the impression many systems
APIs would be easier to wrap safely (though I don’t know the details of this).</p><p>In a language with <code>Move</code>, the <code>Pin</code> type wouldn’t need to exist, users would therefore not have
such annoyance dealing with it, and so-called “pin projections” wouldn’t be an issue requiring
macros to solve, and making self-referential generators would present no complication for the
<code>Iterator</code> trait.</p><p>However, making these changes now is a much thornier problem. I think the edition-based technique is
the only viable solution for adding a new, globally relevant marker trait (except for certain unique
exceptions, like <code>DynSized</code>, not discussed here). And I think there are all kinds of reasons to
think that wouldn’t work - that it would be too difficult to implement, that the implementation
would have too many soundness holes, that the transition would be too disruptive, that it’s actually
totally impossible because I’ve missed something important.</p><p>This is why I’m very glad we found the <code>Pin</code> solution for immoveable types, and were able to ship
self-referential futures and async/await syntax on top of them, in a reasonable time frame without
major disruption to all existing users. When it comes to <code>Leak</code> and linear types, I just despair.</p></section></div>
  </body>
</html>
