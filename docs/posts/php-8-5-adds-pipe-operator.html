<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://thephp.foundation/blog/2025/07/11/php-85-adds-pipe-operator/">Original</a>
    <h1>PHP 8.5 adds pipe operator</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="text">
            <p>PHP 8.5, due out November of this year, will bring with it another long-sought-after feature: the <a href="https://wiki.php.net/rfc/pipe-operator-v3">pipe operator</a> (<code>|&gt;</code>).  It&#39;s a small feature with huge potential, yet it still took years to happen.</p>

<h2 id="what-is-a-pipe-operator%3F">What is a pipe operator?</h2>

<p>The pipe operator, spelled <code>|&gt;</code>, is deceptively simple.  It takes the value on its left side and passes it as the single argument to a function (or in PHP&#39;s case, <code>callable</code>) on its right side:</p>

<pre><code>$result = &#34;Hello World&#34; |&gt; strlen(...)

// Is equivalent to
$result = strlen(&#34;Hello World&#34;);
</code></pre>

<p>On its own, that is not all that interesting.  Where it becomes interesting is when it is repeated, or chained, to form a &#34;pipeline.&#34;  For example, here&#39;s real code from a real project I&#39;ve worked on, recast to use pipes:</p>

<pre><code>$arr = [
  new Widget(tags: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]),
  new Widget(tags: [&#39;c&#39;, &#39;d&#39;, &#39;e&#39;]),
  new Widget(tags: [&#39;x&#39;, &#39;y&#39;, &#39;a&#39;]),
];

$result = $arr
    |&gt; fn($x) =&gt; array_column($x, &#39;tags&#39;) // Gets an array of arrays
    |&gt; fn($x) =&gt; array_merge(...$x)       // Flatten into one big array
    |&gt; array_unique(...)                  // Remove duplicates
    |&gt; array_values(...)                  // Reindex the array.
;

// $result is [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;x&#39;, &#39;y&#39;]
</code></pre>

<p>The same code without pipes would require either this horribly ugly nest of evil:</p>

<pre><code>array_values(array_unique(array_merge(...array_column($arr, &#39;tags&#39;))));
</code></pre>

<p>Or manually creating a temporary variable for each step.  While temp variables are not the worst thing in the world, they are extra mental overhead, and mean that a chain like that cannot be used in a single-expression context, like a <code>match()</code> block.  A pipe chain can.</p>

<p>Anyone who has worked on the Unix/Linux command line will likely recognize the similarity to the shell pipe, <code>|</code>.  That&#39;s very deliberate, as it is effectively the same thing: Use the output from the left side as the input on the right side.</p>

<h2 id="where-did-it-come-from%3F">Where did it come from?</h2>

<p>The <code>|&gt;</code> operator appears in many languages, mostly in the functional world.  F# has essentially the exact same operator, as does OCaml.  Elixir has a slightly fancier version (which we considered but ultimately decided against for now).  Numerous PHP libraries exist in the wild that offer similar capability with many extra expensive steps, including my own <a href="https://github.com/Crell/fp/">Crell/fp</a>.</p>

<p>The story for PHP pipes, though, begins with Hack/HHVM, Facebook&#39;s PHP fork née competitive implementation.  Hack included many features beyond what PHP 5 of the day offered; many of them eventually ended up in later PHP versions.  One of its features was a unique spin on a pipe operator.</p>

<p>In 2016, Sara Golemon, long-time PHP contributor and former Open Source lead on the HHVM project, proposed porting <a href="https://wiki.php.net/rfc/pipe-operator">Hack&#39;s pipes</a> to PHP directly.  In that RFC, the right side of a pipe wasn&#39;t a <code>callable</code> but an expression, and used a magic <code>$$</code> token (lovingly called <code>T_BLING</code>, at least according to yours truly) to inject the left-side result into it.  In that case, the example above would look like this:</p>

<pre><code>$result = $arr
    |&gt; array_column($$, &#39;tags&#39;)
    |&gt; array_merge(...$$)
    |&gt; array_unique($$)
    |&gt; array_values($$)
;
</code></pre>

<p>While powerful, it was also somewhat limiting.  It was very non-standard, unlike any other language.  It also meant a weird, one-off syntax for partially-calling functions that worked only when paired with pipes.</p>

<p>That RFC didn&#39;t go as far as a vote.  Nothing much happened for several years, until 2020/2021.  That&#39;s when I, fresh off of writing a book on functional programming in PHP that talked about function composition, decided to take a swing at it.  In particular, I partnered with a team to work on <a href="https://wiki.php.net/rfc/partial_function_application">Partial Function Application</a> (PFA) as a separate RFC from a more <a href="https://wiki.php.net/rfc/pipe-operator-v2">traditional pipe</a>.  The idea was that turning a multi-parameter function (like <code>array_column()</code> above) into the single-parameter function that <code>|&gt;</code> needed was a useful feature on its own, and should be usable elsewhere.  The syntax was a bit different than the Hack version, in order to make it more flexible: <code>some_function(?, 5, ?, 3, ...)</code>, which would take a 5-or-more parameter function and turn it into a 3 parameter function.</p>

<p>Sadly, PFA didn&#39;t pass due to some engine complexity issues, and that largely undermined the v2 Pipe RFC, too.  However, we did get a consolation prize out of it: <a href="https://wiki.php.net/rfc/first_class_callable_syntax">First Class Callables</a> (the <code>array_values(...)</code> syntax), courtesy Nikita Popov, were by design a &#34;junior&#34;, degenerate version of partial function application.</p>

<p>Fast-forward to 2025, and I was sufficiently bored to take another swing at pipes.  This time with a better implementation with lots of hand-holding from Ilija Tovilo and Arnaud Le Blanc, both part of the PHP Foundation dev team, I was able to get it through.</p>

<p>Third time&#39;s the charm.</p>

<h2 id="more-than-the-sum-of-its-parts">More than the sum of its parts</h2>

<p>Above, we described pipes as &#34;deceptively simple.&#34;  The implementation itself is almost trivial; it&#39;s just syntax sugar for the temp variable version, effectively.  However, the best features are the ones that can combine with others or be used in novel ways to punch above their weight.</p>

<p>We saw above how a long array manipulation process could now be condensed into a single chained expression.  Now imagine using that in places where only a single expression is allowed, such as a <code>match()</code>:</p>

<pre><code>$string = &#39;something GoesHERE&#39;;

$newString = match ($format) {
    &#39;snake_case&#39; =&gt; $string
        |&gt; splitString(...)
        |&gt; fn($x) =&gt; implode(&#39;_&#39;, $x)
        |&gt; strtolower(...),
    &#39;lowerCamel&#39; =&gt; $string
        |&gt; splitString(...),
        |&gt; fn($x) =&gt; array_map(ucfirst(...), $x)
        |&gt; fn($x) =&gt; implode(&#39;&#39;, $x)
        |&gt; lcfirst(...),
    // Other case options here.
};
</code></pre>

<p>Or, consider that the right-side can also be a function call that returns a <code>Closure</code>.  That means with a few functions that return functions:</p>

<pre><code>$profit = [1, 4, 5] 
    |&gt; loadSeveral(...)
    |&gt; filter(isOnSale(...))
    |&gt; map(sellWidget(...))
    |&gt; array_sum(...);
</code></pre>

<p>Which... gives us mostly the same thing as the long-discussed scalar methods!  Only pipes are more flexible as you can use any function on the right-side, not just those that have been blessed by the language designers as methods.</p>

<p>At this point, pipe comes very close to being &#34;extension functions&#34;, a feature of Kotlin and C# that allows writing functions that look like methods on an object, but are actually just stand-alone functions.  It&#39;s spelled a bit differently (<code>|</code> instead of <code>-</code>), but it&#39;s 75% of the way there, for free.</p>

<p>Or take it a step further.  What if some steps in the pipe may return <code>null</code>?  We can, with a single function, &#34;lift&#34; the elements of our chain to handle <code>null</code> values in the same fashion as null-safe methods.</p>

<pre><code>function maybe(\Closure $c): \Closure
{
    return fn(mixed $arg) =&gt; $arg === null ? null : $c($arg);
}

$profit = [1, 4, 5] 
    |&gt; maybe(loadSeveral(...))
    |&gt; maybe(filter(isOnSale(...)))
    |&gt; maybe(map(sellWidget(...)))
    |&gt; maybe(array_sum(...));
</code></pre>

<p>That&#39;s right, we just implemented a Maybe Monad with a pipe and a single-line function.</p>

<p>Now, think about that for streams...</p>

<pre><code>fopen(&#39;pipes.md&#39;, &#39;rb&#39;) // No variable, so it will close automatically when GCed.
    |&gt; decode_rot13(...)
    |&gt; lines_from_charstream(...)
    |&gt; map(str_getcsv(...))
    |&gt; map(Product::create(...))
    |&gt; map($repo-&gt;save(...))
;
</code></pre>

<p>The potential is absolutely huge.  I don&#39;t think it&#39;s immodest to say that the pipe operator has one of the highest &#34;bangs for the buck&#34; of any feature in recent memory, alongside such niceties as constructor property promotion.  And all thanks to a little syntax sugar.</p>

<h2 id="what-comes-next%3F">What comes next?</h2>

<p>Although pipes are a major milestone, we&#39;re not done.  There is active work on not one but two follow-up RFCs.</p>

<p>The first is a second attempt at <a href="https://wiki.php.net/rfc/partial_function_application_v2">Partial Function Application</a>.  This is a larger feature, but with first-class callables already bringing in much of the necessary plumbing, which simplifies the implementation.  With pipes now providing a natural use case, as well as easy optimization points, it&#39;s worth a second attempt.  Whether it makes it into PHP 8.5, is delayed to 8.6, or is again rejected is still an open question as of this writing, though I am hopeful.  Major thanks to Arnaud Le Blanc from the PHP Foundation team for picking it up to update the implementation.</p>

<p>The second is a <a href="https://wiki.php.net/rfc/function-composition">function composition operator</a>.  Where pipe executes immediately, function composition creates a new function by sticking two functions end-to-end.  That would mean the streams example above could be further optimized by combining the <code>map()</code> calls:</p>

<pre><code>fopen(&#39;pipes.md&#39;, &#39;rb&#39;)
    |&gt; decode_rot13(...)
    |&gt; lines_from_charstream(...)
    |&gt; map(str_getcsv(...) + Product::create(...) + $repo-&gt;save(...))
;
</code></pre>

<p>This one is definitely not going to make it into PHP 8.5, but I am hopeful that we&#39;ll be able to get it into 8.6.  Stay tuned.</p>

<blockquote>
  <p>Special thanks to Ilija Tovilo and Arnaud Le Blanc from the PHP Foundation team for their assistance with the pipe implementation.  If you’d like to help push PHP forward, consider <a href="https://thephp.foundation/sponsor/">becoming a sponsor</a>.</p>
</blockquote>

        </div></div>
  </body>
</html>
