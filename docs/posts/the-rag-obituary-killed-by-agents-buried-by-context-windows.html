<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.nicolasbustamante.com/p/the-rag-obituary-killed-by-agents">Original</a>
    <h1>The RAG Obituary: Killed by agents, buried by context windows</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><article><div><div><div dir="auto"><p><span>I’ve been working in AI and search for a decade. First building Doctrine, the largest European legal search engine and now building </span><a href="https://fintool.com/" rel="">Fintool</a><span>, an AI-powered financial research platform that helps institutional investors analyze companies, screen stocks, and make investment decisions. </span></p><p>After three years of building, optimizing, and scaling LLMs with retrieval-augmented generation (RAG) systems, I believe we’re witnessing the twilight of RAG-based architectures. As context windows explode and agent-based architectures mature, my controversial opinion is that the current RAG infrastructure we spent so much time building and optimizing is on the decline.</p><p>In late 2022, ChatGPT took the world by storm. People started endless conversations, delegating crucial work only to realize that the underlying model, GPT-3.5 could only handle 4,096 tokens... roughly six pages of text!</p><p><span>The AI world faced a fundamental problem: </span><strong>how do you make an intelligent system work with knowledge bases that are orders of magnitude larger than what it can read at once?</strong></p><p>The answer became Retrieval-Augmented Generation (RAG), an architectural pattern that would dominate AI for the next three years. </p><p>GPT-3.5 could handle 4,096 token and the next model GPT-4 doubled it to 8,192 tokens, about twelve pages. This wasn’t just inconvenient; it was architecturally devastating. </p><p><span>Consider the numbers: </span><strong>A single SEC 10-K filing contains approximately 51,000 tokens (130+ pages).</strong></p><p>With 8,192 tokens, you could see less than 16% of a 10-K filing. It’s like reading a financial report through a keyhole!</p><p>RAG emerged as an elegant solution borrowed directly from search engines. Just as Google displays 10 blue links with relevant snippets for your query, RAG retrieves the most pertinent document fragments and feeds them to the LLM for synthesis.</p><p><span>The core idea is beautifully simple: </span><strong>if you can’t fit everything in context, find the most relevant pieces and use those</strong><span>. It turns LLMs into sophisticated search result summarizers.</span></p><p>Basically, LLMs can’t read the whole book but they can know who dies at the end; convenient!</p><p>Long documents need to be chunked into pieces and it’s when problems start. Those digestible pieces are typically 400-1,000 tokens each which is basically 300-750 words.</p><p>The problem? It isn’t as simple as cutting every 500 words.</p><p>Consider chunking a typical SEC 10-K annual report. The document has a complex hierarchical structure:</p><p>- Item 1: Business Overview (10-15 pages)</p><p>- Item 1A: Risk Factors (20-30 pages)</p><p>- Item 7: Management’s Discussion and Analysis (30-40 pages)</p><p>- Item 8: Financial Statements (40-50 pages)</p><p>After naive chunking at 500 tokens, critical information gets scattered:</p><p>- Revenue recognition policies split across 3 chunks</p><p>- A risk factor explanation broken mid-sentence</p><p>- Financial table headers separated from their data</p><p>- MD&amp;A narrative divorced from the numbers it’s discussing</p><p>If you search for “revenue growth drivers,” you might get a chunk mentioning growth but miss the actual numerical data in a different chunk, or the strategic context from MD&amp;A in yet another chunk!</p><p>At Fintool, we’ve developed sophisticated chunking strategies that go beyond naive text splitting:</p><p><span>- </span><strong>Hierarchical Structure Preservation</strong><span>: We maintain the nested structure from Item 1 (Business) down to sub-sections like geographic segments, creating a tree-like document representation</span></p><p><span>- </span><strong>Table Integrity</strong><span>: Financial tables are never split—income statements, balance sheets, and cash flow statements remain atomic units with headers and data together</span></p><p><span>- </span><strong>Cross-Reference Preservation</strong><span>: We maintain links between narrative sections and their corresponding financial data, preserving the “See Note X” relationships</span></p><p><span>- </span><strong>Temporal Coherence</strong><span>: Year-over-year comparisons and multi-period analyses stay together as single chunks</span></p><p><span>- </span><strong>Footnote Association</strong><span>: Footnotes remain connected to their referenced items through metadata linking</span></p><p>Each chunk at Fintool is enriched with extensive metadata:</p><p>- Filing type (10-K, 10-Q, 8-K)</p><p>- Fiscal period and reporting date</p><p>- Section hierarchy (Item 7 &gt; Liquidity &gt; Cash Position)</p><p>- Table identifiers and types</p><p>- Cross-reference mappings</p><p>- Company identifiers (CIK, ticker)</p><p>- Industry classification codes</p><p><span>This allows for more accurate retrieval but </span><strong>even our intelligent chunking can’t solve the fundamental problem: we’re still working with fragments instead of complete documents!</strong></p><p>Once you have the chunks, you need a way to search them. One way is to embed your chunks.</p><p>Each chunk is converted into a high‑dimensional vector (typically 1,536 dimensions in most embedding models). These vectors live in a space where, theoretically, similar concepts are close together.</p><p>When a user asks a question, that question also becomes a vector. The system finds the chunks whose vectors are closest to the query vector using cosine similarity.</p><p><strong>It’s elegant in theory and in practice, it’s a nightmare of edge cases.</strong></p><p>Embedding models are trained on general text and struggle with specific terminologies. They find similarities but they can’t distinguish between “revenue recognition” (accounting policy) and “revenue growth” (business performance).</p><p><span>Consider that example: Query: “</span><em>What is the company’s litigation exposure</em><span>?</span></p><p>RAG searches for “litigation” and returns 50 chunks:</p><p>- Chunks 1-10: Various mentions of “litigation” in boilerplate risk factors</p><p>- Chunks 11-20: Historical cases from 2019 (already settled)</p><p>- Chunks 21-30: Forward-looking safe harbor statements</p><p>- Chunks 31-40: Duplicate descriptions from different sections</p><p>- Chunks 41-50: Generic “we may face litigation” warnings</p><p><strong>What RAG Reports:</strong><span> $500M in litigation (from Legal Proceedings section)</span></p><p><strong>What’s Actually There:</strong></p><p>- $500M in Legal Proceedings (Item 3)</p><p>- $700M in Contingencies note (”not material individually”)</p><p>- $1B new class action in Subsequent Events</p><p>- $800M indemnification obligations (different section)</p><p>- $2B probable losses in footnotes (keyword “probable” not “litigation”)</p><p>The actual Exposure is $5.1B. 10x what RAG found. Oupsy! By late 2023, most builders realized pure vector search wasn’t enough.</p><p>Enter hybrid search: combine semantic search (embeddings) with the traditional keyword search (BM25). This is where things get interesting.</p><p>BM25 (Best Matching 25) is a probabilistic retrieval model that excels at exact term matching. Unlike embeddings, BM25:</p><p><span>- </span><strong>Rewards Exact Matches</strong><span>: When you search for “EBITDA,” you get documents with “EBITDA,” not “operating income” or “earnings”</span></p><p><span>- </span><strong>Handles Rare Terms Better</strong><span>: Financial jargon like “CECL” (Current Expected Credit Losses) or “ASC 606” gets proper weight</span></p><p><span>- </span><strong>Document Length Normalization</strong><span>: Doesn’t penalize longer documents</span></p><p><span>- </span><strong>Term Frequency Saturation</strong><span>: Multiple mentions of “revenue” don’t overshadow other important terms</span></p><p>At Fintool, we’ve built a sophisticated hybrid search system:</p><p><span>1. </span><strong>Parallel Processing</strong><span>: We run semantic and keyword searches simultaneously</span></p><p><span>2. </span><strong>Dynamic Weighting</strong><span>: Our system adjusts weights based on query characteristics:</span></p><p>- Specific financial metrics? BM25 gets 70% weight</p><p>- Conceptual questions? Embeddings get 60% weight</p><p>- Mixed queries? 50/50 split with result analysis</p><p><span>3. </span><strong>Score Normalization</strong><span>: Different scoring scales are normalized using:</span></p><p>- Min-max scaling for BM25 scores</p><p>- Cosine similarity already normalized for embeddings</p><p>- Z-score normalization for outlier handling</p><p>So at the end the embeddings search and the keywords search retrieve chunks and the search engine combines them using Reciprocal Rank Fusion. RRF merges rankings so items that consistently appear near the top across systems float higher, even if no system put them at #1!</p><p>So now you think it’s done right? But hell no!</p><p>Here’s what nobody talks about: even after all that retrieval work, you’re not done. You need to rerank the chunks one more time to get a good retrieval and it’s not easy. Rerankers are ML models that take the search results and reorder them by relevance to your specific query limiting the number of chunks sent to the LLM.</p><p><strong>Not only LLMs are context poor, they also struggle when dealing with too much information</strong><span>. It’s vital to reduce the number of chunks sent to the LLM for the final answer.</span></p><p><strong>The Reranking Pipeline:</strong></p><p>1. Initial search retrieval with embeddings + keywords gets you 100-200 chunks</p><p>2. Reranker ranks the top 10</p><p>3. Top 10 are fed to the LLM to answer the question</p><p>Here is the challenge with reranking:</p><p><span>- </span><strong>Latency Explosion</strong><span>: Rerank adds between 300-2000ms per query. Ouch.</span></p><p><span>- </span><strong>Cost Multiplication</strong><span>: it adds significant extra cost to every query. For instance, Cohere Rerank 3.5 costs $2.00 per 1,000 search units, making reranking expensive.</span></p><p><span>- </span><strong>Context Limits</strong><span>: Rerankers typically handle few chunks (Cohere Rerank supports only 4096 tokens), so if you need to re-rank more than that, you have to split it into different parallel API calls and merge them!</span></p><p><span>- </span><strong>Another Model to Manage</strong><span>: One more API, one more failure point</span></p><p>Re-rank is one more step in a complex pipeline.</p><p>What I find difficult with RAG is what I call the “cascading failure problem”.</p><p>1. Chunking can fail (split tables) or be too slow (especially when you have to ingest and chunk gigabytes of data in real-time)</p><p>2. Embedding can fail (wrong similarity)</p><p>3. BM25 can fail (term mismatch)</p><p>4. Hybrid fusion can fail (bad weights)</p><p>5. Reranking can fail (wrong priorities)</p><p>Each stage compounds the errors of the previous stage. Beyond the complexity of hybrid search itself, there’s an infrastructure burden that’s rarely discussed.</p><p>Running production Elasticsearch is not easy. You’re looking at maintaining TB+ of indexed data for comprehensive document coverage, which requires 128-256GB RAM minimum just to get decent performance. The real nightmare comes with re-indexing. Every schema change forces a full re-indexing that takes 48-72 hours for large datasets. On top of that, you’re constantly dealing with cluster management, sharding strategies, index optimization, cache tuning, backup and disaster recovery, and version upgrades that regularly include breaking changes.</p><p>Here are some structural limitations:</p><p><span>1. </span><strong>Context Fragmentation</strong></p><p>- Long documents are interconnected webs, not independent paragraphs</p><p>- A single question might require information from 20+ documents</p><p>- Chunking destroys these relationships permanently</p><p><span>2. </span><strong>Semantic Search Fails on Numbers</strong></p><p>- “$45.2M” and “$45,200,000” have different embeddings</p><p>- “Revenue increased 10%” and “Revenue grew by a tenth” rank differently</p><p>- Tables full of numbers have poor semantic representations</p><p><span>3. </span><strong>No Causal Understanding</strong></p><p>- RAG can’t follow “See Note 12” → Note 12 → Schedule K</p><p>- Can’t understand that discontinued operations affect continuing operations</p><p>- Can’t trace how one financial item impacts another</p><p><span>4. </span><strong>The Vocabulary Mismatch Problem</strong></p><p>- Companies use different terms for the same concept</p><p>- “Adjusted EBITDA” vs “Operating Income Before Special Items”</p><p>- RAG retrieves based on terms, not concepts</p><p><span>5. </span><strong>Temporal Blindness</strong></p><p>- Can’t distinguish Q3 2024 from Q3 2023 reliably</p><p>- Mixes current period with prior period comparisons</p><p>- No understanding of fiscal year boundaries</p><p>These aren’t minor issues. They’re fundamental limitations of the retrieval paradigm.</p><p>Three months ago I stumbled on an innovation on retrievial that blew my mind</p><p>In May 2025, Anthropic released Claude Code, an AI coding agent that works in the terminal. At first, I was surprised by the form factor. A terminal? Are we back in 1980? no UI?</p><p>Back then, I was using Cursor, a product that excelled at traditional RAG. I gave it access to my codebase to embed my files and Cursor ran a search n my codebase before answering my query. Life was good. But when testing Claude Code, one thing stood out:</p><p><strong>It was better and faster and not because their RAG was better but because there was no RAG.</strong></p><p>Instead of a complex pipeline of chunking, embedding, and searching, Claude Code uses direct filesystem tools:</p><p><span>1. </span><strong>Grep (Ripgrep)</strong><span> </span></p><p>- Lightning-fast regex search through file contents</p><p>- No indexing required. It searches live files instantly</p><p>- Full regex support for precise pattern matching</p><p>- Can filter by file type or use glob patterns</p><p>- Returns exact matches with context lines</p><p><span>2. </span><strong>Glob</strong><span> </span></p><p>- Direct file discovery by name patterns</p><p>- Finds files like `**/*.py` or `src/**/*.ts` instantly</p><p>- Returns files sorted by modification time (recency bias)</p><p>- Zero overhead—just filesystem traversal</p><p><span>3. </span><strong>Task Agents</strong></p><p>- Autonomous multi-step exploration</p><p>- Handle complex queries requiring investigation</p><p>- Combine multiple search strategies adaptively</p><p>- Build understanding incrementally</p><p>- Self-correct based on findings</p><p>By the way, Grep was invented in 1973. It’s so... primitive. And that’s the genius of it.</p><p><strong>Claude Code doesn’t retrieve. It investigates:</strong></p><p>- Runs multiple searches in parallel (Grep + Glob simultaneously)</p><p>- Starts broad, then narrows based on discoveries</p><p>- Follows references and dependencies naturally</p><p>- No embeddings, no similarity scores, no reranking</p><p><strong>It’s simple, it’s fast and it’s based on a new assumption that LLMs will go from context poor to context rich.</strong></p><p>Claude Code proved that with sufficient context and intelligent navigation, you don’t need RAG at all. The agent can:</p><p>- Load entire files or modules directly</p><p>- Follow cross-references in real-time</p><p>- Understand structure and relationships</p><p>- Maintain complete context throughout investigation</p><p>This isn’t just better than RAG—it’s a fundamentally different paradigm. And what works for code can work for any long documents that are not coding files.</p><p>The context window explosion made Claude Code possible:</p><p><strong>2022-2025 Context-Poor Era:</strong></p><p>- GPT-4: 8K tokens (~12 pages)</p><p>- GPT-4-32k: 32K tokens (~50 pages)</p><p><strong>2025 and beyond Context Revolution:</strong></p><p>- Claude Sonnet 4: 200k tokens (~700 pages)</p><p>- Gemini 2.5: 1M tokens (~3,000 pages)</p><p>- Grok 4-fast: 2M tokens (~6,000 pages)</p><p>At 2M tokens, you can fit an entire year of SEC filings for most companies.</p><p>The trajectory is even more dramatic: we’re likely heading toward 10M+ context windows by 2027, with Sam Altman hinting at billions of context tokens on the horizon. This represents a fundamental shift in how AI systems process information. Equally important, attention mechanisms are rapidly improving—LLMs are becoming far better at maintaining coherence and focus across massive context windows without getting “lost” in the noise.</p><p>Claude Code demonstrated that with enough context, search becomes navigation:</p><p>- No need to retrieve fragments when you can load complete files</p><p>- No need for similarity when you can use exact matches</p><p>- No need for reranking when you follow logical paths</p><p>- No need for embeddings when you have direct access</p><p>It’s mind-blowing. LLMs are getting really good at agentic behaviors meaning they can organize their work into tasks to accomplish an objective.</p><p>Here’s what tools like ripgrep bring to the search table:</p><p><span>- </span><strong>No Setup</strong><span>: No index. No overhead. Just point and search.</span></p><p><span>- </span><strong>Instant Availability</strong><span>: New documents are searchable the moment they hit the filesystem (no indexing latency!)</span></p><p><span>- </span><strong>Zero Maintenance</strong><span>: No clusters to manage, no indices to optimize, no RAM to provision</span></p><p><span>- </span><strong>Blazing Fast</strong><span>: For a 100K line codebase, Elasticsearch needs minutes to index. Ripgrep searches it in milliseconds with zero prep.</span></p><p><span>- </span><strong>Cost</strong><span>: $0 infrastructure cost vs a lot of $$$ for Elasticsearch</span></p><p>So back to our previous example on SEC filings. An agent can SEC filing structure intrinsically:</p><p><span>- </span><strong>Hierarchical Awareness</strong><span>: Knows that Item 1A (Risk Factors) relates to Item 7 (MD&amp;A)</span></p><p><span>- </span><strong>Cross-Reference Following</strong><span>: Automatically traces “See Note 12” references</span></p><p><span>- </span><strong>Multi-Document Coordination</strong><span>: Connects 10-K, 10-Q, 8-K, and proxy statements</span></p><p><span>- </span><strong>Temporal Analysis</strong><span>: Compares year-over-year changes systematically</span></p><p>For searches across thousands of companies or decades of filings, it might still use hybrid search, but now as a tool for agents:</p><p>- Initial broad search using hybrid retrieval</p><p>- Agent loads full documents for top results</p><p>- Deep analysis within full context</p><p>- Iterative refinement based on findings</p><p>My guess is traditional RAG is now a search tool among others and that agents will always prefer grep and reading the whole file because they are context rich and can handle long-running tasks.</p><p>Consider our $6.5B lease obligation question as an example:</p><p><strong>Step 1: Find “lease” in main financial statements</strong></p><p>→ Discovers “See Note 12”</p><p><strong>Step 2: Navigate to Note 12</strong></p><p>→ Finds “excluding discontinued operations (Note 23)”</p><p><strong>Step 3: Check Note 23</strong></p><p>→ Discovers $2B additional obligations</p><p><strong>Step 4: Cross-reference with MD&amp;A</strong></p><p>→ Identifies management’s explanation and adjustments</p><p><strong>Step 5: Search for “subsequent events”</strong></p><p>→ Finds post-balance sheet $500M lease termination</p><p><strong>Final answer: $5B continuing + $2B discontinued - $500M terminated = $6.5B</strong></p><p>The agent follows references like a human analyst would. No chunks. No embeddings. No reranking. Just intelligent navigation.</p><p>Basically, RAG is like a research assistant with perfect memory but no understanding:</p><p>- “Here are 50 passages that mention debt”</p><p>- Can’t tell you if debt is increasing or why</p><p>- Can’t connect debt to strategic changes</p><p>- Can’t identify hidden obligations</p><p>- Just retrieves text, doesn’t comprehend relationships</p><p>Agentic search is like a forensic accountant:</p><p>- Follows the money systematically</p><p>- Understands accounting relationships (assets = liabilities + equity)</p><p>- Identifies what’s missing or hidden</p><p>- Connects dots across time periods and documents</p><p>- Challenges management assertions with data</p><p><strong>1. Increasing Document Complexity</strong></p><p>- Documents are becoming longer and more interconnected</p><p>- Cross-references and external links are proliferating</p><p>- Multiple related documents need to be understood together</p><p>- Systems must follow complex trails of information</p><p><strong>2. Structured Data Integration</strong></p><p>- More documents combine structured and unstructured data</p><p>- Tables, narratives, and metadata must be understood together</p><p>- Relationships matter more than isolated facts</p><p>- Context determines meaning</p><p><strong>3. Real-Time Requirements</strong></p><p>- Information needs instant processing</p><p>- No time for re-indexing or embedding updates</p><p>- Dynamic document structures require adaptive approaches</p><p>- Live data demands live search</p><p><strong>4. Cross-Document Understanding</strong></p><p>Modern analysis requires connecting multiple sources:</p><p>- Primary documents</p><p>- Supporting materials</p><p>- Historical versions</p><p>- Related filings</p><p>RAG treats each document independently. Agentic search builds cumulative understanding.</p><p><strong>5. Precision Over Similarity</strong></p><p>- Exact information matters more than similar content</p><p>- Following references beats finding related text</p><p>- Structure and hierarchy provide crucial context</p><p>- Navigation beats retrieval</p><p>The evidence is becoming clear. While RAG served us well in the context-poor era, agentic search represents a fundamental evolution. The potential benefits of agentic search are compelling:</p><p>- Elimination of hallucinations from missing context</p><p>- Complete answers instead of fragments</p><p>- Faster insights through parallel exploration</p><p>- Higher accuracy through systematic navigation</p><p>- Massive infrastructure cost reduction</p><p>- Zero index maintenance overhead</p><p>The key insight? Complex document analysis—whether code, financial filings, or legal contracts—isn’t about finding similar text. It’s about understanding relationships, following references, and maintaining precision. The combination of large context windows and intelligent navigation delivers what retrieval alone never could.</p><p><strong>RAG was a clever workaround for a context-poor era</strong><span>. It helped us bridge the gap between tiny windows and massive documents, but it was always a band-aid. The future won’t be about splitting documents into fragments and juggling embeddings. It will be about agents that can navigate, reason, and hold entire corpora in working memory.</span></p><p>We are entering the post-retrieval age. The winners will not be the ones who maintain the biggest vector databases, but the ones who design the smartest agents to traverse abundant context and connect meaning across documents. In hindsight, RAG will look like training wheels. Useful, necessary, but temporary.</p><p>The next decade of AI search will belong to systems that read and reason end-to-end. Retrieval isn’t dead—it’s just been demoted.</p></div></div></div></article></div></div></div><div><div id="discussion"><div><h4>Discussion about this post</h4></div></div></div></div>
  </body>
</html>
