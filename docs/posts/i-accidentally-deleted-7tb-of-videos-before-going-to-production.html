<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.thevinter.com/posts/vimeo">Original</a>
    <h1>I Accidentally Deleted 7TB of Videos Before Going to Production</h1>
    
    <div id="readability-page-1" class="page"><div id="__next"><article><p>[Hello HN: You can read the discussion and comments <a target="_blank" rel="noopener" href="https://news.ycombinator.com/item?id=31271451">here</a>]</p><p>[I also want to preface this whole post by saying that I&#39;m a Junior Developer with less than one year of actual experience. Some of the things that might seem obvious to some might not be so for me, thanks!]</p><p>This is a story that some won&#39;t understand. It involves bad practices and errors from multiple parties in a world that might seem foreign to the &#34;Silicon Valley&#34; world but paints an accurate picture of what development is for small IT companies around the world.</p><p>I&#39;m currently working at a tiny development company (10 employees) in Italy. We develop and manage websites and tools for local businesses. Other than that we landed a big contract for one of the biggest gym companies in Italy, the UK and South Africa. You might expect that given the size they know what they&#39;re doing, but that&#39;s hardly the truth. It&#39;s easy to point the finger and accuse someone, but that&#39;s not what I will be doing here (especially since we all make mistakes and bad decisions as you will see) so I just want to objectively describe what&#39;s going on.</p><h3><span id="the-project"></span><a href="#the-project">The project<span aria-hidden="true">#</span></a></h3><p>I&#39;m under an NDA, so I can&#39;t disclose too much, but it suffices to say that we&#39;re currently working on a project that needs to use videos hosted on Vimeo. Currently the company uses VimeoOTT, a platform that provides a stock frontend for the content, and they wanted to migrate to Vimeo Enterprise. There were roughly 500 videos on VimeoOTT that had to be transferred to Enterprise and Vimeo doesn&#39;t provide an easy way of doing it. I wrote to the support team around October asking them if it was possible to do a migration, and they told us that they &#34;will look into it&#34; without letting us know anything ever since.</p><p>This meant that the upload had to be done again. I proposed to build a custom API script that downloads videos from OTT and uploads them to Enterprise (and our product as well) but the proposal was rejected by the management, and they decided to pay a person to do it manually instead. During the months following October said person uploaded the 500 videos from OTT + 400 new ones, thus reaching around 9TBs out of the 11 granted to us with the Enterprise plan, all was going well (even if it wasn&#39;t really efficient). Then April arrived.</p><h3><span id="the-problem"></span><a href="#the-problem">The problem<span aria-hidden="true">#</span></a></h3><p>At one point, without letting us know anything, Vimeo decided it was a great idea to comply with our request and dumped all the videos present on OTT onto the new platform. No questions were asked, and apparently no one at Vimeo cared that</p><ol><li>They were duplicating videos that were already uploaded.</li><li>The total size of the videos was now around 15TB, 4 over the limit.</li></ol><p>This meant that unless we deleted stuff no one was able to upload videos anymore. We asked Vimeo if it was possible to revert the change, but we received a negative answer. The worst part? We had to go live in about a week.</p><p>It was time to delete the extra videos, and I was the one in charge of doing it. Sadly, I made a giant mistake.</p><h3><span id="the-quotsolutionquot"></span><a href="#the-quotsolutionquot">The &#34;solution&#34;<span aria-hidden="true">#</span></a></h3><p>(For context, I&#39;ve been working with React for the last 7 months. This will kinda explain what went wrong in a bit)</p><p>Luckily in our DB we had a <code>VimeoId</code> assigned to each video, so the first solution that came to my mind was:</p><pre><code>for each video in vimeo:
    if video not in our_vimeo_ids:
    delete(&#34;api.vimeo.com/videos/{video}&#34;
</code></pre><p>Both requests were paginated (in a slightly different way) so the actual code I wrote was:</p><pre><code>page = 0
url = f&#34;https://api.ourservice.com/media?page={page}&amp;step=100&#34;
our_ids = []
for i in range(10):
    page = i
    res = requests.get(url)
    videos = res.json()[&#39;list&#39;]
    ids = [video[&#39;vimeoId&#39;] for video in videos]
    our_ids += ids

next = &#39;/me?page=1&#39;
vimeo_ids = []
while next is not None:
    res = requests.get(f&#39;https://api.vimeo.com/videos{next}&#39;)
    res = res.json()
    videos = res[&#39;data&#39;]
    ids = [video[&#39;id&#39;] for video in videos]
    vimeo_ids += ids
    next = res[&#39;pagination&#39;][&#39;next&#39;]

for id in vimeo_ids:
    if id not in our_ids:
        requests.delete(f&#39;https://api.vimeo.com/videos/{id}&#39;)
</code></pre><p>I think you can easily spot the error. I know I can, but at the time the code seemed completely correct to me. In case you want a spoiler because you can&#39;t see it here it is:</p><pre><code>url = f&#34;https://api.ourservice.com/media?page{page}&amp;step=100
our_ids = []
for i in range(10):
    page = i
    res = requests.get(url)
</code></pre><p>I was so used to React that for some reason my mind thought that <code>url</code> would refresh itself as soon as the <code>page</code> variable changed, which of course is not the case. That meant that with this script <strong>I deleted from Vimeo all videos that weren&#39;t in the first page of our db</strong></p><p>There was another issue here: I tested the code but to do it I used the same flawed loop in the first example.</p><pre><code>page = 0
url = f&#34;https://api.ourservice.com/media?page{page}&amp;step=100
our_ids = []
for i in range(10):
    page = i
    res = requests.get(url)
    videos = res.json()[&#39;list&#39;]
    ids = [video[&#39;vimeoId&#39;] for video in videos]
    for id in ids:
    res = requests.get(f&#39;https://api.vimeo.com/videos/{id}&#39;)
        if res.status_code != 200:
        print(f&#34;There was something wrong. You have deleted a wrong video -&gt; {id}&#34;)
</code></pre><p>I also did some manual testing, but the testing was done only on the first page of our db. A series of mistakes that could&#39;ve probably been easily prevented.</p><h3><span id="the-aftermath"></span><a href="#the-aftermath">The aftermath<span aria-hidden="true">#</span></a></h3><p>The good news that the videos were still physically backed up in a Google Drive folder and the info about them was still in our db. The bad news is that this was on Friday, and we needed to have the videos back up at most for Tuesday morning. We had to upload ~8TB of data with a 30MB/s connection. Not ideal, and I had to think about something fast.</p><p>The first solution that came to my mind was to use Google Drive APIs. We had the filenames of all the videos uploaded on our db, so I quickly wrote some code that looked like this:</p><pre><code>page = 0
file_names = get_our_filenames(page) # This time without the mistake in the for loop
for name in file_names:
    download_and_save_from_drive(name)
    upload_to_vimeo(name)
</code></pre><p>This meant that I could run the script multiple times with different pages, thus &#34;parallelizing&#34; the procedure on different networks. (I also thought to execute it in a high speed environment but at the moment we didn&#39;t have a convenient place without enormous egress fees). It was still non ideal since saturating our Upload for 4 days wasn&#39;t the best choice. Then an idea came to my mind:</p><h3><span id="the-solution"></span><a href="#the-solution">The solution<span aria-hidden="true">#</span></a></h3><p>Was there a possibility to directly upload videos from Google Drive to Vimeo? I checked on their Upload page and sure there was one! There was a small problem though: it was only a manual solution and there were no APIs to automate it. The good thing of it though was that the uploads were near instant. Maybe there is a better solution to this but I don&#39;t know of one, so my reaction to this discovery was to boot up Playwright.</p><p>Playwright is an automated E2E tool that can be used to simulate user interaction. That means that it can also programmatically click on websites, see where this is going?</p><p>Here&#39;s the code: (I just started using Playwright and it had to be written really quickly so excuse me for it being ugly)</p><pre><code>test(&#39;Videos&#39;, async ({ page }) =&gt; {
  // We login into vimeo
  await page.goto(&#39;https://vimeo.com/upload/videos&#39;);
  await page.fill(
    &#39;input[name=&#34;email&#34;]&#39;,
    &#39;xxx&#39;
  );
  await page.fill(&#39;input[name=&#34;password&#34;]&#39;, &#39;xxx&#39;);
  await page.click(&#39;input[type=submit]&#39;);

  // We click on the Drive button and then login into Google Drive
  // We need to manage it as an iframe
  const [popup] = await Promise.all([
    page.waitForEvent(&#39;popup&#39;),
    page.click(&#39;text=Drive&#39;),
  ]);
  await popup.fill(&#39;input[type=&#34;email&#34;]&#39;, &#39;xxx&#39;);
  await popup.click(&#39;button:has-text(&#34;Next&#34;)&#39;);
  await popup.fill(&#39;input[type=&#34;password&#34;]&#39;, &#39;xxx&#39;);
  await popup.click(&#39;button:has-text(&#34;Next&#34;)&#39;);
  await timeout(5000);

  // For all the filenames we obtained before we upload them
  for (let i = 0; i &lt; videos.length; i++) {
    if (i &gt; 0) {
      page.click(&#39;text=Drive&#39;);
      await timeout(5000);
    }
    let found = false;
    while(!found) {
    for (let frame of page.frames()) {
        const searchbox = await frame.$(&#39;input[aria-label=&#34;Search terms&#34;]&#39;);
        const button = await frame.$(&#39;div[data-tooltip=&#34;Search&#34;]&#39;);
        if (searchbox) {
            await temp.fill(videos[i]);
            await button.click();
            }
        }
    }
    await timeout(5000);

    // Whenever we search google regenerates the iframe so we have to search again
    for (let frame of page.frames()) {
      const temp = await frame.$(&#39;table[role=&#34;listbox&#34;]  div[tabindex=&#34;0&#34;]&#39;);
      if (temp) {
        const select = await frame.$(&#39;div[id=&#34;picker:ap:2&#34;]&#39;);
        await select.click();
      }
    }
    await page.goto(&#39;https://vimeo.com/upload/videos&#39;);
  }
});
</code></pre><p>This code is bad (notice the timeouts to combat the flakiness of the .click() in playwright) But it does its job, except for one important thing: I didn&#39;t manage to get the click working on the video that was found, only on the &#34;Select&#34; button. I have no clue to this day how to make it work, but that meant that with this code I had to manually click every 10 seconds to select the video and make the program continue. I did it for 10 minutes, then I asked myself why I was doing it.</p><p>I downloaded an autoclicker (xclicker) and set it to click every 5 seconds. Lo and behold, roughly 13 seconds per video, 1000 videos, 4 hours later all of the videos were uploaded. Only one thing left to do:</p><p>They now had new <code>vimeoIds</code> so I had to go back to our db and update all the videos with the correct values. This was simple to do with a python script similar to the previous ones.</p><p>And finally, all the videos were uploaded and the day was saved.</p><h3><span id="conclusion"></span><a href="#conclusion">Conclusion<span aria-hidden="true">#</span></a></h3><p>What does this teach us? Well, it teaches me to do more diverse tests when doing destructive operations. It also should probably teach something to Vimeo and to my contractor but I doubt it will (and yes, the upload for some reason is still manual to this day. Go figure!)</p><small><time>2022</time> © thevinter.<a href="https://blog.thevinter.com/feed.xml">RSS</a></small></article></div></div>
  </body>
</html>
