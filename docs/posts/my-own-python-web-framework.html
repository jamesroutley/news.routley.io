<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://healeycodes.com/my-own-python-web-framework">Original</a>
    <h1>My Own Python Web Framework</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>Over the past few months, I&#39;ve been building my own software tools from scratch – like a <a href="https://healeycodes.com/profiling-and-optimizing-an-interpreter">programming language</a>, a <a href="https://healeycodes.com/making-a-text-editor-with-a-game-engine">text editor</a>, and <a href="https://healeycodes.com/beating-grep-with-go">CLI tools</a>. At the weekend, I built a proof-of-concept web framework that deploys to Vercel via the <a href="https://vercel.com/blog/build-output-api">Build Output API</a>.</p><blockquote><p>A file-system-based specification that allows <em>any</em> framework to build for Vercel and take advantage of Vercel&#39;s infrastructure building blocks like Edge Functions, Edge Middleware, Incremental Static Regeneration (ISR), Image Optimization, and more.</p></blockquote><p><a href="https://github.com/healeycodes/jar">Jar</a> is a toy Python web framework, implemented in about 200 lines of code (see <a href="https://github.com/healeycodes/jar/blob/main/framework/cli.py">cli.py</a>). I built it to explore some ideas around framework APIs, and to explore frameworks from the author-side of things. Please don&#39;t actually use it. It&#39;s called Jar because it has almost no features and you need to fill it up yourself!</p><p>It uses file-system routing and supports:</p><ul><li>Build pages aka <a href="https://vercel.com/docs/build-output-api/v3#vercel-primitives/static-files">Static Files</a></li><li>Fresh pages aka <a href="https://vercel.com/docs/build-output-api/v3#vercel-primitives/serverless-functions">Serverless Functions</a></li><li>Regenerated pages aka <a href="https://vercel.com/docs/build-output-api/v3#vercel-primitives/prerender-functions">Prerender Functions</a></li></ul><p>Jar projects are structured like this:</p><pre><div><div><p><span>project/</span></p><p><span>├─ pages/</span></p><p><span>│  ├─ index.py</span></p><p><span>├─ public/</span></p><p><span>│  ├─ favicon.ico</span></p></div></div></pre><h2 id="api-ideas">API Ideas</h2><p>My personal use case for Jar is building small dynamic websites without a frontend framework. A little inspired by Next.js&#39;s APIs, like <code>getServerSideProps</code> and <code>getStaticProps</code>, Jar&#39;s API is defined by three function signatures.</p><ul><li>The data function is called at build time for build pages and regenerated pages. When it&#39;s called on the server, it receives a request object with method, path, headers, and body.</li><li>The render function receives the data function&#39;s return value, and returns a tuple of <code>body, info</code> where info can alter the status code and headers of the response.</li><li>The config function defines the type of page (build, fresh, or regenerated).</li></ul><p>Here&#39;s a regenerated page from the <a href="https://github.com/healeycodes/jar/tree/main/examples/kitchensink">kitchen sink example</a>:</p><pre><div><div><p><span>import</span><span> time</span></p><p><span></span><span>def</span><span> </span><span>render</span><span>(</span><span>data</span><span>)</span><span>:</span><span></span></p><p><span>    </span><span>return</span><span> </span><span>f&#34;&lt;h1&gt;Last regenerated at: </span><span>{</span><span>data</span><span>[</span><span>&#39;time&#39;</span><span>]</span><span>}</span><span>&lt;/h1&gt;&#34;</span><span>,</span><span> </span><span>{</span><span>}</span><span></span></p><p><span></span><span>def</span><span> </span><span>data</span><span>(</span><span>request</span><span>=</span><span>None</span><span>)</span><span>:</span><span></span></p><p><span>    </span><span>return</span><span> </span><span>{</span><span></span></p><p><span>        </span><span>&#34;time&#34;</span><span>:</span><span> time</span><span>.</span><span>time</span><span>(</span><span>)</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span></span><span>def</span><span> </span><span>config</span><span>(</span><span>)</span><span>:</span><span></span></p><p><span>    </span><span>return</span><span> </span><span>{</span><span></span></p><p><span>        </span><span>&#34;regenerate&#34;</span><span>:</span><span> </span><span>{</span><span></span></p><p><span>            </span><span>&#34;every&#34;</span><span>:</span><span> </span><span>5</span><span></span></p><p><span>        </span><span>}</span><span></span></p><p><span>    </span><span>}</span></p></div></div></pre><p>Because we&#39;re in Python-land, I wanted the API to be flexible. The data and config functions are optional (and they don&#39;t have to take any arguments). So the smallest possible Jar page looks like this:</p><pre><div><div><p><span>render </span><span>=</span><span> </span><span>lambda</span><span>:</span><span> </span><span>(</span><span>“Hi! I&#39;m a little page</span><span>.</span><span>”</span><span>,</span><span> </span><span>{</span><span>}</span><span>)</span></p></div></div></pre><h2 id="building-the-cli">Building the CLI</h2><p>While prototyping Jar&#39;s CLI, the Build Output API&#39;s <a href="https://vercel.com/docs/build-output-api/v3">documentation</a> and <a href="https://github.com/vercel/examples/tree/main/build-output-api">examples</a> were comprehensive enough that I didn&#39;t run into any major issues. With trial and error, it didn&#39;t take long before I was testing Jar by building and deploying real projects (which takes about six seconds end-to-end).</p><p>Jar needs to render pages at build time <em>and</em> on the server, and uses a lot of dynamic imports and metaprogramming to cut down on lines-of-code and complexity.</p><p>In order to treat user-written pages as Python modules, they&#39;re imported at run time like this:</p><pre><div><div><p><span>module_location </span><span>=</span><span> </span><span>&#34;project/pages/index.py&#34;</span><span></span></p><p><span>spec </span><span>=</span><span> importlib</span><span>.</span><span>util</span><span>.</span><span>spec_from_file_location</span><span>(</span><span>&#34;&#34;</span><span>,</span><span> module_location</span><span>)</span><span></span></p><p><span>page </span><span>=</span><span> importlib</span><span>.</span><span>util</span><span>.</span><span>module_from_spec</span><span>(</span><span>spec</span><span>)</span><span></span></p><p><span>spec</span><span>.</span><span>loader</span><span>.</span><span>exec_module</span><span>(</span><span>page</span><span>)</span><span></span></p><p><span></span><span># `page` can now be called like `page.render()`</span></p></div></div></pre><p>Which means dynamically imported build pages can be called at build time to generate static files:</p><pre><div><div><p><span># `page` is a dynamically imported module e.g. it exists at `pages/index.py`</span><span></span></p><p><span></span><span>with</span><span> </span><span>open</span><span>(</span><span>os</span><span>.</span><span>path</span><span>.</span><span>join</span><span>(</span><span>build_dir</span><span>,</span><span> </span><span>f&#34;.vercel/output/static/</span><span>{</span><span>request_path</span><span>}</span><span>&#34;</span><span>)</span><span>,</span><span> </span><span>&#34;w&#34;</span><span>)</span><span> </span><span>as</span><span> f</span><span>:</span><span></span></p><p><span>    res </span><span>=</span><span> call_render</span><span>(</span><span>page</span><span>)</span><span></span></p><p><span>    f</span><span>.</span><span>write</span><span>(</span><span>res</span><span>[</span><span>&#39;body&#39;</span><span>]</span><span>)</span><span></span></p><p><span>    build_config</span><span>[</span><span>&#39;overrides&#39;</span><span>]</span><span>[</span><span>request_path</span><span>]</span><span> </span><span>=</span><span> </span><span>{</span><span></span></p><p><span>        </span><span>&#39;contentType&#39;</span><span>:</span><span> res</span><span>[</span><span>&#39;headers&#39;</span><span>]</span><span>[</span><span>&#39;Content-Type&#39;</span><span>]</span><span></span></p><p><span>    </span><span>}</span></p></div></div></pre><p>To create fresh and regenerated pages, Jar creates <a href="https://vercel.com/docs/build-output-api/v3#vercel-primitives/serverless-functions">Serverless Functions</a> that use the <code>python3.9</code> <a href="https://github.com/vercel/vercel/blob/main/DEVELOPING_A_RUNTIME.md#lambdaruntime">runtime</a>. The same functions that are used to create build pages (e.g. <code>call_data</code>, <code>call_render</code>) are written to a handler file so they can run on the server as needed. And when I say <em>the same functions</em> I mean that they are literally read from memory.</p><pre><div><div><p><span>def</span><span> </span><span>create_handler</span><span>(</span><span>path</span><span>,</span><span> module_location</span><span>)</span><span>:</span><span></span></p><p><span>    </span><span># the following functions are used at build time to generated build pages</span><span></span></p><p><span>    </span><span># and are also used on the server to generated fresh/regenerated pages</span><span></span></p><p><span>    </span><span># so we bundle them into a handler file</span><span></span></p><p><span>    </span><span>with</span><span> </span><span>open</span><span>(</span><span>path</span><span>,</span><span> </span><span>&#34;w&#34;</span><span>)</span><span> </span><span>as</span><span> f</span><span>:</span><span></span></p><p><span>        </span><span># imports</span><span></span></p><p><span>        f</span><span>.</span><span>write</span><span>(</span><span>&#34;import json\nimport inspect\nimport importlib.util\n&#34;</span><span>)</span><span></span></p><p><span>        f</span><span>.</span><span>write</span><span>(</span><span>&#39;\n&#39;</span><span>)</span><span></span></p><p><span>        </span><span># request class</span><span></span></p><p><span>        request_source </span><span>=</span><span> inspect</span><span>.</span><span>getsource</span><span>(</span><span>Request</span><span>)</span><span></span></p><p><span>        f</span><span>.</span><span>write</span><span>(</span><span>request_source</span><span>)</span><span></span></p><p><span>        f</span><span>.</span><span>write</span><span>(</span><span>&#39;\n&#39;</span><span>)</span><span></span></p><p><span>        </span><span># call_data function</span><span></span></p><p><span>        call_data_source </span><span>=</span><span> inspect</span><span>.</span><span>getsource</span><span>(</span><span>call_data</span><span>)</span><span></span></p><p><span>        f</span><span>.</span><span>write</span><span>(</span><span>call_data_source</span><span>)</span><span></span></p><p><span>        f</span><span>.</span><span>write</span><span>(</span><span>&#39;\n&#39;</span><span>)</span><span></span></p><p><span>        </span><span># call_render function</span><span></span></p><p><span>        call_render_source </span><span>=</span><span> inspect</span><span>.</span><span>getsource</span><span>(</span><span>call_render</span><span>)</span><span></span></p><p><span>        f</span><span>.</span><span>write</span><span>(</span><span>call_render_source</span><span>)</span><span></span></p><p><span>        f</span><span>.</span><span>write</span><span>(</span><span>&#39;\n&#39;</span><span>)</span><span></span></p><p><span>        </span><span># app function</span><span></span></p><p><span>        app_source </span><span>=</span><span> inspect</span><span>.</span><span>getsource</span><span>(</span><span>app</span><span>)</span><span></span></p><p><span>        f</span><span>.</span><span>write</span><span>(</span><span>app_source</span><span>.</span><span>replace</span><span>(</span><span>&#34;__MODULE_LOCATION&#34;</span><span>,</span><span> module_location</span><span>)</span><span>)</span><span></span></p><p><span>        f</span><span>.</span><span>write</span><span>(</span><span>&#39;\n&#39;</span><span>)</span></p></div></div></pre><p>The Build Output API requires external files like packages to be included as part of the function&#39;s file system.</p><blockquote><p>A <a href="https://vercel.com/docs/concepts/functions/serverless-functions">Serverless Function</a> is represented on the file system as a directory with a <code>.func</code> suffix on the name, contained within the <code>.vercel/output/functions</code> directory.</p>
<p>Conceptually, you can think of this <code>.func</code> directory as a filesystem mount for a Serverless Function: the files below the <code>.func</code> directory are included (recursively) and files above the <code>.func</code> directory are not included. Private files may safely be placed within this directory because they will not be directly accessible to end-users. However, they can be referenced by code that will be executed by the Serverless Function.</p><p>A configuration file named <code>.vc-config.json</code> must be included within the <code>.func</code> directory, which contains information about how Vercel should construct the Serverless Function.</p></blockquote><p>In Jar, all the project files are copied to each function directory to keep things simple (a more mature framework would split <em>and</em> bundle to avoid size limits per function). The <code>.vc-config.json</code> file is the same for each too:</p><pre><div><div><p><span>{</span><span>&#34;handler&#34;</span><span>:</span><span> </span><span>&#34;__handler.app&#34;</span><span>,</span><span> </span><span>&#34;runtime&#34;</span><span>:</span><span> </span><span>&#34;python3.9&#34;</span><span>,</span><span> </span><span>&#34;environment&#34;</span><span>:</span><span> </span><span>{</span><span>}</span><span>}</span></p></div></div></pre><p>The only difference between functions is the module (aka the page file) that the handler imports at runtime.</p><p>A fresh/regenerated page in Jar maps one-to-one with a Serverless/Prerender Function. When a request hits Vercel&#39;s Edge Network, it&#39;s <a href="https://vercel.com/docs/concepts/functions/serverless-functions">eventually routed</a> to the handler file, which calls the relevant page&#39;s <code>data</code> and <code>render</code> function, and then replies to the client.</p><p>Some further reading on Vercel internals:</p><ul><li><a href="https://vercel.com/blog/behind-the-scenes-of-vercels-infrastructure">Behind the scenes of Vercel&#39;s infrastructure</a></li><li><a href="https://github.com/vercel/vercel/blob/main/DEVELOPING_A_RUNTIME.md">Runtime Developer Reference</a></li><li><a href="https://vercel.com/blog/build-your-own-web-framework">Build your own web framework</a></li><li>SvelteKit&#39;s <a href="https://github.com/sveltejs/kit/tree/master/packages/adapter-vercel">adapter-vercel</a></li><li>Vercel&#39;s CLI <a href="https://github.com/vercel/vercel">vercel/vercel</a></li></ul><h2 id="docs">Docs</h2><p>I like to write documentation for my side-projects no matter the size or number of users. It records a snapshot of my thinking, helps me catch any rough edges, and gives me the push I need to complete the final 10% of the project. It also means I can pick everything back up at any time in the future!</p><p>I wrote the docs for Jar … with Jar! See the <a href="https://github.com/healeycodes/jar/tree/main/examples/docs">project files here</a>. The docs use the <code>marko</code> markdown package and Prism.js for syntax highlighting (all Jar pages are plain Python, no imports or special syntax).</p><p>Serverless/Prerender Functions don&#39;t know about anything outside of their function directory, so when using a third-party package, it needs to be installed locally at the project&#39;s root. There are some mature methods to get this working (like Python virtual environments) but I haven&#39;t run into any issues so far by just installing the packages locally with <code>pip</code>&#39;s <code>--target</code> argument.</p><p>An example of this can be seen below, in the script that builds and deploys the <a href="https://jar-docs.vercel.app/">Jar docs website</a>:</p><pre><div><div><p><span>python3 framework/cli.py build examples/docs</span></p><p><span></span><span># project packages must be installed locally</span><span></span></p><p><span></span><span># so they are bundled correctly when deployed</span><span></span></p><p><span></span><span>cd</span><span> examples/docs </span><span>&amp;&amp;</span><span> pip3 </span><span>install</span><span> -r requirements.txt --target </span><span>.</span><span> </span><span>&amp;&amp;</span><span> </span><span>cd</span><span> </span><span>..</span><span>/</span><span>..</span><span></span></p><p><span></span><span>cd</span><span> build </span><span>&amp;&amp;</span><span> vercel --prebuilt --prod </span><span>&amp;&amp;</span><span> </span><span>cd</span><span> </span><span>..</span></p></div></div></pre><p>The docs cover this issue, as well as more details about the API, and examples of each type of page.</p><h2 id="tests">Tests</h2><p>There&#39;s this funny axiom that goes <a href="https://twitter.com/predraggruevski/status/1470206964043071491">everything is a compiler, a database, or a combination of both</a>. Web frameworks are definitely compilers — and a quick way to test compilers (which should have deterministic output) is snapshot testing.</p><p>Jar&#39;s <a href="https://github.com/healeycodes/jar/blob/main/framework/test_cli.py">test suite</a> builds two projects and snapshot tests the files. For true end-to-end testing, it could deploy and then curl them to verify that the behavior-in-production doesn&#39;t diverge.</p><p>Speaking of <em>deterministic output</em>, I actually ran into a bug where tests would sometimes fail in CI. The bug was due to how Python&#39;s <code>json.dumps</code> orders the keys when serializing the build config.</p><p>Here&#39;s the bug that took me thirty minutes to find and fix:</p><pre><div><div><p><span>with open(os.path.join(build_dir, &#39;.vercel/output/config.json&#39;), &#39;w&#39;) as f:</span></p><p><span></span><span>-</span><span>     json.dump(build_config, f)</span></p><p><span></span><span>+</span><span>     json.dump(build_config, f, sort_keys=True)</span></p></div></div></pre><p>After completing <a href="https://github.com/healeycodes/jar">this project</a>, going all the way from idea to production, it feels like I&#39;ve peeled back a few computing layers. I&#39;m more comfortable with the flow of web framework → compiler → production.</p><p><small>Thanks to <a href="https://samgeo.codes">Samuel Eisenhandler</a> for providing feedback on an early draft.</small></p></div></div></div>
  </body>
</html>
