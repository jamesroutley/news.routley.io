<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ethw.org/History_of_Lossless_Data_Compression_Algorithms">Original</a>
    <h1>History of Lossless Data Compression Algorithms</h1>
    
    <div id="readability-page-1" class="page"><div id="bodyContent">
						<!-- body text -->

						<div id="mw-content-text" lang="en" dir="ltr"><div><div>

<h2><span id="Introduction">Introduction</span><span><span>[</span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;veaction=edit&amp;section=1" title="Edit section: Introduction">edit</a><span> | </span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;action=edit&amp;section=1" title="Edit section: Introduction">edit source</a><span>]</span></span></h2>
<p>There are two major categories of compression algorithms: lossy and lossless. Lossy compression algorithms involve the reduction of a file’s size usually by removing small details that require a large amount of data to store at full fidelity. In lossy compression, it is impossible to restore the original file due to the removal of essential data. Lossy compression is most commonly used to store image and audio data, and while it can achieve very high compression ratios through data removal, it is not covered in this article. Lossless data compression is the size reduction of a file, such that a decompression function can restore the original file exactly with no loss of data. Lossless data compression is used ubiquitously in computing, from saving space on your personal computer to sending data over the web, communicating over a secure shell, or viewing a PNG or GIF image. 
</p><p>The basic principle that lossless compression algorithms work on is that any non-random file will contain duplicated information that can be condensed using statistical modeling techniques that determine the probability of a character or phrase appearing. These statistical models can then be used to generate codes for specific characters or phrases based on their probability of occurring, and assigning the shortest codes to the most common data. Such techniques include entropy encoding, run-length encoding, and compression using a dictionary. Using these techniques and others, an 8-bit character or a string of such characters could be represented with just a few bits resulting in a large amount of redundant data being removed. 
</p>
<h2><span id="History">History</span><span><span>[</span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;veaction=edit&amp;section=2" title="Edit section: History">edit</a><span> | </span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;action=edit&amp;section=2" title="Edit section: History">edit source</a><span>]</span></span></h2>
<div><div><p><a href="https://ethw.org/File:Compression_hierarchy.png"><img alt="" src="https://ethw.org/w/images/thumb/6/6d/Compression_hierarchy.png/406px-Compression_hierarchy.png" decoding="async" width="406" height="510" srcset="/w/images/thumb/6/6d/Compression_hierarchy.png/609px-Compression_hierarchy.png 1.5x, /w/images/thumb/6/6d/Compression_hierarchy.png/812px-Compression_hierarchy.png 2x"/></a></p><div><p>A Hierarchy of Lossless Compression Algorithms</p></div></div></div>
<p>Data compression has only played a significant role in computing since the 1970s, when the Internet was becoming more popular and the Lempel-Ziv algorithms were invented, but it has a much longer history outside of computing. Morse code, invented in 1838, is the earliest instance of data compression in that the most common letters in the English language such as “e” and “t” are given shorter Morse codes. Later, as mainframe computers were starting to take hold in 1949, Claude Shannon and <a href="https://ethw.org/Robert_M._Fano" title="Robert M. Fano">Robert Fano</a> invented Shannon-Fano coding. Their algorithm assigns codes to symbols in a given block of data based on the probability of the symbol occuring. The probability is of a symbol occuring is inversely proportional to the length of the code, resulting in a shorter way to represent the data. <sup id="cite_ref-refnum1_1-0"><a href="#cite_note-refnum1-1">[1]</a></sup>
</p><p>Two years later, David Huffman was studying information theory at MIT and had a class with Robert Fano. Fano gave the class the choice of writing a term paper or taking a final exam. Huffman chose the term paper, which was to be on finding the most efficient method of binary coding. After working for months and failing to come up with anything, Huffman was about to throw away all his work and start studying for the final exam in lieu of the paper. It was at that point that he had an epiphany, figuring out a very similar yet more efficient technique to Shannon-Fano coding. The key difference between Shannon-Fano coding and Huffman coding is that in the former the probability tree is built bottom-up, creating a suboptimal result, and in the latter it is built top-down.<sup id="cite_ref-refnum2_2-0"><a href="#cite_note-refnum2-2">[2]</a></sup> 
</p><p>Early implementations of Shannon-Fano and Huffman coding were done using hardware and hardcoded codes. It was not until the 1970s and the advent of the Internet and online storage that software compression was implemented that Huffman codes were dynamically generated based on the input data.<sup id="cite_ref-refnum1_1-1"><a href="#cite_note-refnum1-1">[1]</a></sup> Later, in 1977, Abraham Lempel and Jacob Ziv published their groundbreaking LZ77 algorithm, the first algorithm to use a dictionary to compress data. More specifically, LZ77 used a dynamic dictionary oftentimes called a sliding window.<sup id="cite_ref-refnum3_3-0"><a href="#cite_note-refnum3-3">[3]</a></sup> In 1978, the same duo published their LZ78 algorithm which also uses a dictionary; unlike LZ77, this algorithm parses the input data and generates a static dictionary rather than generating it dynamically.<sup id="cite_ref-refnum4_4-0"><a href="#cite_note-refnum4-4">[4]</a></sup>
</p>
<h3><span id="Legal_Issues">Legal Issues</span><span><span>[</span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;veaction=edit&amp;section=3" title="Edit section: Legal Issues">edit</a><span> | </span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;action=edit&amp;section=3" title="Edit section: Legal Issues">edit source</a><span>]</span></span></h3>
<p>Both the LZ77 and LZ78 algorithms grew rapidly in popularity, spawning many variants shown in the diagram to the right. Most of these algorithms have died off since their invention, with just a handful seeing widespread use today including DEFLATE, LZMA, and LZX. Most of the commonly used algorithms are derived from the LZ77 algorithm. This is not due to technical superiority, but because LZ78 algorithms became patent-encumbered after Sperry patented the derivative LZW algorithm in 1984 and began suing software vendors, server admins, and even end users for using the GIF format without a license. <sup id="cite_ref-refnum5_5-0"><a href="#cite_note-refnum5-5">[5]</a></sup><sup id="cite_ref-refnum6_6-0"><a href="#cite_note-refnum6-6">[6]</a></sup>
</p><p>At the time, the <a href="https://ethw.org/UNIX" title="UNIX">UNIX</a> compress utility used a very slight modification of the LZW algorithm called LZC and was later discontinued due to patent issues. Other UNIX developers also began to deviate from using the LZW algorithm in favor or open source ones. This led the UNIX community to adopt the DEFLATE-based gzip and the Burrows-Wheeler Transform-based bzip2 formats. In the long run, this was a benefit for the UNIX community because both the gzip and bzip2 formats nearly always achieve significantly higher compression ratios than the LZW format.<sup id="cite_ref-refnum6_6-1"><a href="#cite_note-refnum6-6">[6]</a></sup> The patent issues surrounding LZW have since subsided, as the patent on the LZW algorithm expired in 2003.<sup id="cite_ref-refnum5_5-1"><a href="#cite_note-refnum5-5">[5]</a></sup> Despite this, the LZW algorithm has largely been replaced and is only commonly used in GIF compression. There have also been some LZW derivatives since then but they do not enjoy widespread use either and LZ77 algorithms remain dominant. 
</p><p>Another legal battle erupted in 1993 regarding the LZS algorithm. LZS was developed by Stac Electronics for use in disk compression software such as Stacker. Microsoft used the LZS algorithm in developing disk compression software that was released with MS-DOS 6.0 that purported to double the capacity of a hard drive. When Stac Electronics found out its intellectual property was being used, it filed suit against Microsoft. Microsoft was later found guilty of patent infringement and ordered to pay Stac Electronics $120 million in damages minus $13.6 million awarded in a countersuit finding that Microsoft’s infringement was not willful.<sup id="cite_ref-refnum7_7-0"><a href="#cite_note-refnum7-7">[7]</a></sup> Although <i>Stac Electronics v. Microsoft</i> had a large judgment, it did not impede the development of Lempel-Ziv algorithms as the LZW patent dispute did. The only consequence seems to be that LZS has not been forked into any new algorithms.
</p>
<h3><span id="The_Rise_of_Deflate">The Rise of Deflate</span><span><span>[</span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;veaction=edit&amp;section=4" title="Edit section: The Rise of Deflate">edit</a><span> | </span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;action=edit&amp;section=4" title="Edit section: The Rise of Deflate">edit source</a><span>]</span></span></h3>
<p>Corporations and other large entities have used data compression since the Lempel-Ziv algorithms were published as they have ever-increasing storage needs and data compression allows them to meet those needs. However, data compression did not see widespread use until the Internet began to take off toward the late 1980s when a need for data compression emerged. Bandwidth was either limited, expensive, or both, and data compression helped to alleviate these bottlenecks. Compression became especially important when the World Wide Web was developed as people began to share more images and other formats which are considerably larger than text. To meet the demand, several new file formats were developed incorporating compression including ZIP, GIF, and PNG. 
</p><p>Thom Henderson released the first commercially successful archive format called ARC in 1985 through his company, System Enhancement Associates. ARC was especially popular in the BBS community, since it was one of the first programs capable of both bundling and compressing files and it was also made open source. The ARC format uses a modification to the LZW algorithm to compress data. A man named Phil Katz noticed ARC&#39;s popularity and decided to improve it by writing the compression and decompression routines in assembly language. He released his PKARC program as shareware in 1987 and was later sued by Henderson for copyright infringement. He was found guilty and forced to pay royalties and other penalties as part of a cross-licensing agreement. He was found guilty because PKARC was a blatant copy of ARC; in some instances even the typos in the comments were identical. <sup id="cite_ref-refnum16_8-0"><a href="#cite_note-refnum16-8">[8]</a></sup>
</p><p>Phil Katz could no longer sell PKARC after 1988 due to the cross-licensing agreement, so in 1989 he created a tweaked version of PKARC that is now known as the ZIP format. As a result of its use of LZW, it was considered patent encumbered and Katz later chose to switch to the new IMPLODE algorithm. The format was again updated in 1993, when Katz released PKZIP 2.0, which implemented the DEFLATE algorithm as well as other features like split volumes. This version of the ZIP format is found ubiquitously today, as almost all .zip files follow the PKZIP 2.0 format despite its great age. 
</p><p>The GIF, or Graphics Interchange Format, was developed by CompuServe in 1987 to allow bitmaps to be shared without data loss (although the format is limited to 256 colors per frame), while substantially reducing the file size to allow transmission over dialup modems. However, like the ZIP format, GIF is also based on the LZW algorithm. Despite being patent encumbered, Unisys was unable to enforce their patents adequately enough to stop the format from spreading. Even now, over 20 years later, the GIF remains in use especially for its capability of being animated. <sup id="cite_ref-refnum13_9-0"><a href="#cite_note-refnum13-9">[9]</a></sup>
</p><p>Although GIF could not be stopped, CompuServe sought a format unencumbered by patents and in 1994 introduced the Portable Network Graphics (PNG) format. Like ZIP, the PNG standard uses the DEFLATE algorithm to perform compression. Although DEFLATE was patented by Katz<sup id="cite_ref-refnum14_10-0"><a href="#cite_note-refnum14-10">[10]</a></sup> the patent was never enforced and thus PNG and other DEFLATE-based formats avoid infringing on patents. Although LZW took off in the early days of compression, due to Unisys&#39;s litigious nature it has more or less died off in favor of the faster and more efficient DEFLATE algorithm. DEFLATE is currently the most used data compression algorithm since it is a bit like the Swiss Army knife of compression. 
</p><p>Beyond its use in the PNG and ZIP formats, DEFLATE is also used very frequently elsewhere in computing. For example, the gzip (.gz) file format uses DEFLATE since it is essentially an open source version of ZIP. Other uses of DEFLATE include HTTP, SSL, and other technologies designed for efficient data compression over a network. 
</p><p>Sadly, Phil Katz did not live long enough to see his DEFLATE algorithm take over the computing world. He suffered from alcoholism for several years and his life began to fall apart in the late 1990s, having been arrested several times for drunk driving and other violations. Katz was found dead in a hotel room on April 14, 2000, at the age of 37. The cause of death was found to be acute pancreatic bleeding from his alcoholism, brought on by the many empty bottles of liquor found near his body. <sup id="cite_ref-refnum15_11-0"><a href="#cite_note-refnum15-11">[11]</a></sup>
</p>
<h3><span id="Current_Archival_Software">Current Archival Software</span><span><span>[</span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;veaction=edit&amp;section=5" title="Edit section: Current Archival Software">edit</a><span> | </span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;action=edit&amp;section=5" title="Edit section: Current Archival Software">edit source</a><span>]</span></span></h3>
<p>The ZIP format and other DEFLATE-based formats were king up until the mid 1990s when new and improved formats began to emerge. In 1993, Eugene Roshal released his archiver known as WinRAR which utilizes the proprietary RAR format. The latest version of RAR uses a combination of the PPM and LZSS algorithms, but not much is known about earlier implementations. RAR has become a standard format for sharing files over the Internet, specifically in the distribution of pirated media. An open-source implementation of the Burrows-Wheeler Transform called bzip2 was introduced in 1996 and rapidly grew in popularity on the UNIX platform against the DEFLATE-based gzip format. Another open-source compression program was released in 1999 as the 7-Zip or .7z format. 7-Zip could be the first format to challenge the dominance of ZIP and RAR due to its generally high compression ratio and the format&#39;s modularity and openness. This format is not limited to using one compression algorithm, but can instead choose between bzip2, LZMA, LZMA2, and PPMd algorithms among others. Finally, on the bleeding edge of archival software are the PAQ* formats. The first PAQ format was released by Matt Mahoney in 2002, called PAQ1. PAQ substantially improves on the PPM algorithm by using a technique known as context mixing which combines two or more statistical models to generate a better prediction of the next symbol than either of the models on their own. 
</p>
<h2><span id="Future_Developments">Future Developments</span><span><span>[</span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;veaction=edit&amp;section=6" title="Edit section: Future Developments">edit</a><span> | </span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;action=edit&amp;section=6" title="Edit section: Future Developments">edit source</a><span>]</span></span></h2>
<p>The future is never certain, but based on current trends some predictions can be made as to what may happen in the future of data compression. Context Mixing algorithms such as PAQ and its variants have started to attract popularity, and they tend to achieve the highest compression ratios but are usually slow. With the exponential increase in hardware speed following Moore&#39;s Law, context mixing algorithms will likely flourish as the speed penalties are overcome through faster hardware due to their high compression ratio. The algorithm that PAQ sought to improve, called Prediction by Partial Matching (PPM) may also see new variants. Finally, the Lempel-Ziv Markov chain Algorithm (LZMA) has consistently shown itself to have an excellent compromise between speed and high compression ratio and will likely spawn more variants in the future. LZMA may even be the &#34;winner&#34; as it is further developed, having already been adopted in numerous competing compression formats since it was introduced with the 7-Zip format. Another potential development is the use of compression via substring enumeration (CSE) which is an up-and-coming compression technique that has not seen many software implementations yet. In its naive form it performs similarly to bzip2 and PPM, and researchers have been working to improve its efficiency.<sup id="cite_ref-refnum20_12-0"><a href="#cite_note-refnum20-12">[12]</a></sup>
</p>
<h2><span id="Compression_Techniques">Compression Techniques</span><span><span>[</span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;veaction=edit&amp;section=7" title="Edit section: Compression Techniques">edit</a><span> | </span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;action=edit&amp;section=7" title="Edit section: Compression Techniques">edit source</a><span>]</span></span></h2>
<p>Many different techniques are used to compress data. Most compression techniques cannot stand on their own, but must be combined together to form a compression algorithm. Those that can stand alone are often more effective when joined together with other compression techniques. Most of these techniques fall under the category of entropy coders, but there are others such as Run-Length Encoding and the Burrows-Wheeler Transform that are also commonly used.
</p>
<h3><span id="Run-Length_Encoding">Run-Length Encoding</span><span><span>[</span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;veaction=edit&amp;section=8" title="Edit section: Run-Length Encoding">edit</a><span> | </span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;action=edit&amp;section=8" title="Edit section: Run-Length Encoding">edit source</a><span>]</span></span></h3>
<p>Run-Length Encoding is a very simple compression technique that replaces runs of  two or more of the same character with a number which represents the length of the run, followed by the original character; single characters are coded as runs of 1. RLE is useful for highly-redundant data, indexed images with many pixels of the same color in a row, or in combination with other compression techniques like the Burrows-Wheeler Transform. 
</p><p>Here is a quick example of RLE: 
</p><p>Input:    AAABBCCCCDEEEEEEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 
</p><p>Output: 3A2B4C1D6E38A
</p>
<h3><span id="Burrows-Wheeler_Transform">Burrows-Wheeler Transform</span><span><span>[</span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;veaction=edit&amp;section=9" title="Edit section: Burrows-Wheeler Transform">edit</a><span> | </span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;action=edit&amp;section=9" title="Edit section: Burrows-Wheeler Transform">edit source</a><span>]</span></span></h3>
<p>The Burrows-Wheeler Transform is a compression technique invented in 1994 that aims to reversibly transform a block of input data such that the amount of runs of identical characters is maximized. The BWT itself does not perform any compression operations, it simply transforms the input such that it can be more efficiently coded by a Run-Length Encoder or other secondary compression technique. 
</p><p>The algorithm for a BWT is simple: 
</p>
<ol><li>Create a string array.</li>
<li>Generate all possible rotations of the input string, storing each in the array.</li>
<li>Sort the array alphabetically.</li>
<li>Return the last column of the array.<sup id="cite_ref-refnum29_13-0"><a href="#cite_note-refnum29-13">[13]</a></sup></li></ol>
<p>BWT usually works best on long inputs with many alternating identical characters. Here is an example of the algorithm being run on an ideal input. Note that &amp; is an End of File character: 
</p>
<table>

<tbody><tr>
<td>Input<br/>
</td>
<td>Rotations<br/>
</td>
<td>Alpha-Sorted Rotations<br/>
</td>
<td>Output<br/>
</td></tr>
<tr>
<td rowspan="7">HAHAHA&amp;<br/>
</td>
<td>HAHAHA&amp;<br/>
</td>
<td>AHAHA&amp;<u><b>H</b></u><br/>
</td>
<td rowspan="7"><u><b>HHH&amp;AAA</b></u>
</td></tr>
<tr>
<td>&amp;HAHAHA<br/>
</td>
<td>AHA&amp;HA<u><b>H</b></u><br/>
</td></tr>
<tr>
<td>A&amp;HAHAH<br/>
</td>
<td>A&amp;HAHA<u><b>H</b></u><br/>
</td></tr>
<tr>
<td>HA&amp;HAHA<br/>
</td>
<td>HAHAHA<u><b>&amp;</b></u><br/>
</td></tr>
<tr>
<td>AHA&amp;HAH<br/>
</td>
<td>HAHA&amp;H<u><b>A</b></u><br/>
</td></tr>
<tr>
<td>HAHA&amp;HA<br/>
</td>
<td>HA&amp;HAH<u><b>A</b></u><br/>
</td></tr>
<tr>
<td>AHAHA&amp;H<br/>
</td>
<td>&amp;HAHAH<u><b>A</b></u><br/>
</td></tr></tbody></table>
<p>Because of its alternating identical characters, performing the BWT on this input generates an optimal result that another algorithm could further compress, such as RLE which would yield &#34;3H&amp;3A&#34;. While this example generated an optimal result, it does not generate optimal results on most real-world data.
</p>
<h3><span id="Entropy_Encoding">Entropy Encoding</span><span><span>[</span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;veaction=edit&amp;section=10" title="Edit section: Entropy Encoding">edit</a><span> | </span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;action=edit&amp;section=10" title="Edit section: Entropy Encoding">edit source</a><span>]</span></span></h3>
<p>Entropy in data compression means the smallest number of bits needed, on average, to represent a symbol or literal. A basic entropy coder combines a statistical model and a coder. The input file is parsed and used to generate a statistical model that consists of the probabilities of a given symbol appearing. Then, the coder will use the statistical model to determine what bit-or-bytecodes to assign to each symbol such that the most common symbols have the shortest codes and the least common symbols have the longest codes.<sup id="cite_ref-refnum8_14-0"><a href="#cite_note-refnum8-14">[14]</a></sup>
</p>
<h4><span id="Shannon-Fano_Coding">Shannon-Fano Coding</span><span><span>[</span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;veaction=edit&amp;section=11" title="Edit section: Shannon-Fano Coding">edit</a><span> | </span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;action=edit&amp;section=11" title="Edit section: Shannon-Fano Coding">edit source</a><span>]</span></span></h4>
<p>This is one of the earliest compression techniques, invented in 1949 by Claude Shannon and Robert Fano. This technique involves generating a binary tree to represent the probabilities of each symbol occurring. The symbols are ordered such that the most frequent symbols appear at the top of the tree and the least likely symbols appear at the bottom. 
</p><p>The code for a given symbol is obtained by searching for it in the Shannon-Fano tree, and appending to the code a value of 0 or 1 for each left or right branch taken, respectively. For example, if “A” is two branches to the left and one to the right its code would be “001<sub>2</sub>”. Shannon-Fano coding does not always produce optimal codes due to the way it builds the binary tree from the bottom up. For this reason, Huffman coding is used instead as it generates an optimal code for any given input. 
</p><p>The algorithm to generate Shannon-Fano codes is fairly simple 
</p>
<ol><li>Parse the input, counting the occurrence of each symbol.</li>
<li>Determine the probability of each symbol using the symbol count.</li>
<li>Sort the symbols by probability, with the most probable first.</li>
<li>Generate leaf nodes for each symbol.<br/></li>
<li>Divide the list in two while keeping the probability of the left branch roughly equal to those on the right branch.</li>
<li>Prepend 0 and 1 to the left and right nodes&#39; codes, respectively.</li>
<li>Recursively apply steps 5 and 6 to the left and right subtrees until each node is a leaf in the tree.<sup id="cite_ref-refnum9_15-0"><a href="#cite_note-refnum9-15">[15]</a></sup></li></ol>
<h4><span id="Huffman_Coding">Huffman Coding</span><span><span>[</span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;veaction=edit&amp;section=12" title="Edit section: Huffman Coding">edit</a><span> | </span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;action=edit&amp;section=12" title="Edit section: Huffman Coding">edit source</a><span>]</span></span></h4>
<p>Huffman Coding is another variant of entropy coding that works in a very similar manner to Shannon-Fano Coding, but the binary tree is built from the top down to generate an optimal result. 
</p><p>The algorithm to generate Huffman codes shares its first steps with Shannon-Fano: 
</p>
<ol><li>Parse the input, counting the occurrence of each symbol.</li>
<li>Determine the probability of each symbol using the symbol count.</li>
<li>Sort the symbols by probability, with the most probable first.</li>
<li>Generate leaf nodes for each symbol, including P, and add them to a queue.</li>
<li>While (Nodes in Queue &gt; 1)</li></ol>
<ul><li>Remove the two lowest probability nodes from the queue.</li>
<li>Prepend 0 and 1 to the left and right nodes&#39; codes, respectively.</li>
<li>Create a new node with value equal to the sum of the nodes’ probability.</li>
<li>Assign the first node to the left branch and the second node to the right branch.</li>
<li>Add the node to the queue</li></ul>
<p>     6. The last node remaining in the queue is the root of the Huffman tree.<sup id="cite_ref-refnum10_16-0"><a href="#cite_note-refnum10-16">[16]</a></sup>
</p>
<h4><span id="Arithmetic_Coding">Arithmetic Coding</span><span><span>[</span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;veaction=edit&amp;section=13" title="Edit section: Arithmetic Coding">edit</a><span> | </span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;action=edit&amp;section=13" title="Edit section: Arithmetic Coding">edit source</a><span>]</span></span></h4>
<p>This method was developed in 1979 at IBM, which was investigating data compression techniques for use in their mainframes. Arithmetic coding is arguably the most optimal entropy coding technique if the objective is the best compression ratio since it usually achieves better results than Huffman Coding. It is, however, quite complicated compared to the other coding techniques. 
</p><p>Rather than splitting the probabilities of symbols into a tree, arithmetic coding transforms the input data into a single rational number between 0 and 1 by changing the base and assigning a single value to each unique symbol from 0 up to the base. Then, it is further transformed into a fixed-point binary number which is the encoded result. The value can be decoded into the original output by changing the base from binary back to the original base and replacing the values with the symbols they correspond to.
</p><p>A general algorithm to compute the arithmetic code is:
</p>
<ol><li>Calculate the number of unique symbols in the input. This number represents the base b (e.g. base 2 is binary) of the arithmetic code.</li>
<li>Assign values from 0 to b to each unique symbol in the order they appear.</li>
<li>Using the values from step 2, replace the symbols in the input with their codes</li>
<li>Convert the result from step 3 from base b to a sufficiently long fixed-point binary number to preserve precision.</li>
<li>Record the length of the input string somewhere in the result as it is needed for decoding.<sup id="cite_ref-refnum11_17-0"><a href="#cite_note-refnum11-17">[17]</a></sup></li></ol>
<p>Here is an example of an encode operation, given the input “ABCDAABD”:
</p>
<ol><li>Found 4 unique symbols in input, therefore base = 4. Length = 8</li>
<li>Assigned values to symbols: A=0, B=1, C=2, D=3</li>
<li>Replaced input with codes: “0.01230013<sub>4</sub>” where the leading 0 is not a symbol.</li>
<li>Convert “0.01231123<sub>4</sub>” from base 4 to base 2: “0.01101100000111<sub>2</sub>”</li>
<li>Result found. Note in result that input length is 8.</li></ol>
<p>Assuming 8-bit characters, the input is 64 bits long, while its arithmetic coding is just 15 bits long resulting in an excellent compression ratio of 24%. This example demonstrates how arithmetic coding compresses well when given a limited character set. 
</p>
<h2><span id="Compression_Algorithms">Compression Algorithms</span><span><span>[</span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;veaction=edit&amp;section=14" title="Edit section: Compression Algorithms">edit</a><span> | </span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;action=edit&amp;section=14" title="Edit section: Compression Algorithms">edit source</a><span>]</span></span></h2>
<h3><span id="Sliding_Window_Algorithms">Sliding Window Algorithms</span><span><span>[</span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;veaction=edit&amp;section=15" title="Edit section: Sliding Window Algorithms">edit</a><span> | </span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;action=edit&amp;section=15" title="Edit section: Sliding Window Algorithms">edit source</a><span>]</span></span></h3>
<h4><span id="LZ77">LZ77</span><span><span>[</span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;veaction=edit&amp;section=16" title="Edit section: LZ77">edit</a><span> | </span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;action=edit&amp;section=16" title="Edit section: LZ77">edit source</a><span>]</span></span></h4>
<p>Published in 1977, LZ77 is the algorithm that started it all. It introduced the concept of a &#39;sliding window&#39; for the first time which brought about significant improvements in compression ratio over more primitive algorithms. LZ77 maintains a dictionary using triples representing offset, run length, and a deviating character. The offset is how far from the start of the file a given phrase starts at, and the run length is how many characters past the offset are part of the phrase. The deviating character is just an indication that a new phrase was found, and that phrase is equal to the phrase from offset to offset+length plus the deviating character. The dictionary used changes dynamically based on the sliding window as the file is parsed. For example, the sliding window could be 64MB which means that the dictionary will contain entries for the past 64MB of the input data.
</p><p>Given an input &#34;abbadabba&#34; the output would look something like &#34;abb(0,1,&#39;d&#39;)(0,3,&#39;a&#39;)&#34; as in the example below:<br/> 
</p>
<table>

<tbody><tr>
<td>Position<br/>
</td>
<td>Symbol<br/>
</td>
<td>Output
</td></tr>
<tr>
<td>0<br/>
</td>
<td>a<br/>
</td>
<td>  a<br/>
</td></tr>
<tr>
<td>1<br/>
</td>
<td>b<br/>
</td>
<td>  b<br/>
</td></tr>
<tr>
<td>2<br/>
</td>
<td>b<br/>
</td>
<td>  b<br/>
</td></tr>
<tr>
<td>3<br/>
</td>
<td>a<br/>
</td>
<td rowspan="2">  (0, 1, &#39;d&#39;)<br/>
</td></tr>
<tr>
<td>4<br/>
</td>
<td>d<br/>
</td></tr>
<tr>
<td>5<br/>
</td>
<td>a<br/>
</td>
<td rowspan="4">  (0, 3, &#39;a&#39;)
</td></tr>
<tr>
<td>6<br/>
</td>
<td>b<br/>
</td></tr>
<tr>
<td>7<br/>
</td>
<td>b<br/>
</td></tr>
<tr>
<td>8<br/>
</td>
<td>a
</td></tr></tbody></table>
<p>While this substitution is slightly larger than the input, it generally achieves a considerably smaller result given longer input data. <sup id="cite_ref-refnum3_3-1"><a href="#cite_note-refnum3-3">[3]</a></sup>
</p>
<h4><span id="LZR">LZR</span><span><span>[</span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;veaction=edit&amp;section=17" title="Edit section: LZR">edit</a><span> | </span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;action=edit&amp;section=17" title="Edit section: LZR">edit source</a><span>]</span></span></h4>
<p>LZR is a modification of LZ77 invented by Michael Rodeh in 1981. The algorithm aims to be a linear time alternative to LZ77. However, the encoded pointers can point to any offset in the file which means LZR consumes a considerable amount of memory. Combined with its poor compression ratio (LZ77 is often superior) it is an unfeasible variant.<sup id="cite_ref-refnum18_18-0"><a href="#cite_note-refnum18-18">[18]</a></sup><sup id="cite_ref-refnum12_19-0"><a href="#cite_note-refnum12-19">[19]</a></sup>
</p>
<h4><span id="DEFLATE">DEFLATE</span><span><span>[</span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;veaction=edit&amp;section=18" title="Edit section: DEFLATE">edit</a><span> | </span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;action=edit&amp;section=18" title="Edit section: DEFLATE">edit source</a><span>]</span></span></h4>
<p>DEFLATE was invented by Phil Katz in 1993 and is the basis for the majority of compression tasks today. It simply combines an LZ77 or LZSS preprocessor with Huffman coding on the backend to achieve moderately compressed results in a short time.
</p>
<h4><span id="DEFLATE64">DEFLATE64</span><span><span>[</span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;veaction=edit&amp;section=19" title="Edit section: DEFLATE64">edit</a><span> | </span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;action=edit&amp;section=19" title="Edit section: DEFLATE64">edit source</a><span>]</span></span></h4>
<p>DEFLATE64 is a proprietary extension of the DEFLATE algorithm which increases the dictionary size to 64kB (hence the name) and allows greater distance in the sliding window. It increases both performance and compression ratio compared to DEFLATE.<sup id="cite_ref-refnum19_20-0"><a href="#cite_note-refnum19-20">[20]</a></sup> However, the proprietary nature of DEFLATE64 and its modest improvements over DEFLATE has led to limited adoption of the format. Open source algorithms such as LZMA are generally used instead.
</p>
<h4><span id="LZSS">LZSS</span><span><span>[</span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;veaction=edit&amp;section=20" title="Edit section: LZSS">edit</a><span> | </span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;action=edit&amp;section=20" title="Edit section: LZSS">edit source</a><span>]</span></span></h4>
<p>The LZSS, or Lempel-Ziv-Storer-Szymanski algorithm was first published in 1982 by James Storer and Thomas Szymanski. LZSS improves on LZ77 in that it can detect whether a substitution will decrease the filesize or not. If no size reduction will be achieved, the input is left as a literal in the output. Otherwise, the section of the input is replaced with an (offset, length) pair where the offset is how many bytes from the start of the input and the length is how many characters to read from that position.<sup id="cite_ref-refnum21_21-0"><a href="#cite_note-refnum21-21">[21]</a></sup> Another improvement over LZ77 comes from the elimination of the &#34;next character&#34; and uses just an offset-length pair.
</p><p>Here is a brief example given the input &#34; these theses&#34; which yields &#34; these(0,6)s&#34; which saves just one byte, but saves considerably more on larger inputs.
</p>
<table>

<tbody><tr>
<td>Index<br/>
</td>
<td> 0
</td>
<td> 1<br/>
</td>
<td> 2<br/>
</td>
<td> 3<br/>
</td>
<td> 4<br/>
</td>
<td> 5<br/>
</td>
<td> 6<br/>
</td>
<td> 7<br/>
</td>
<td> 8<br/>
</td>
<td> 9 <br/>
</td>
<td>10
</td>
<td>11<br/>
</td>
<td>12<br/>
</td></tr>
<tr>
<td>Symbol<br/>
</td>
<td> 
</td>
<td> t<br/>
</td>
<td> h<br/>
</td>
<td> e<br/>
</td>
<td> s<br/>
</td>
<td> e<br/>
</td>
<td> <br/>
</td>
<td> t<br/>
</td>
<td> h<br/>
</td>
<td> e<br/>
</td>
<td> s<br/>
</td>
<td> e<br/>
</td>
<td> s<br/>
</td></tr>
<tr>
<td>Substituted<br/>
</td>
<td>  <br/>
</td>
<td> t<br/>
</td>
<td> h<br/>
</td>
<td> e<br/>
</td>
<td> s<br/>
</td>
<td> e<br/>
</td>
<td> (<br/>
</td>
<td> 0<br/>
</td>
<td> ,<br/>
</td>
<td> 6<br/>
</td>
<td> )<br/>
</td>
<td> s<br/>
</td>
<td><br/>
</td></tr></tbody></table>
<p>LZSS is still used in many popular archive formats, the best known of which is RAR. It is also sometimes used for network data compression.
</p>
<h4><span id="LZH">LZH</span><span><span>[</span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;veaction=edit&amp;section=21" title="Edit section: LZH">edit</a><span> | </span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;action=edit&amp;section=21" title="Edit section: LZH">edit source</a><span>]</span></span></h4>
<p>LZH was developed in 1987 and it stands for &#34;Lempel-Ziv Huffman.&#34; It is a variant of LZSS that utilizes Huffman coding to compress the pointers, resulting in slightly better compression. However, the improvements gained using Huffman coding are negligible and the compression is not worth the performance hit of using Huffman codes.<sup id="cite_ref-refnum12_19-1"><a href="#cite_note-refnum12-19">[19]</a></sup>
</p>
<h4><span id="LZB">LZB</span><span><span>[</span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;veaction=edit&amp;section=22" title="Edit section: LZB">edit</a><span> | </span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;action=edit&amp;section=22" title="Edit section: LZB">edit source</a><span>]</span></span></h4>
<p>LZB was also developed in 1987 by Timothy Bell et al as a variant of LZSS. Like LZH, LZB also aims to reduce the compressed file size by encoding the LZSS pointers more efficiently. The way it does this is by gradually increasing the size of the pointers as the sliding window grows larger. It can achieve higher compression than LZSS and LZH, but it is still rather slow compared to LZSS due to the extra encoding step for the pointers.<sup id="cite_ref-refnum12_19-2"><a href="#cite_note-refnum12-19">[19]</a></sup>
</p>
<h4><span id="ROLZ">ROLZ</span><span><span>[</span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;veaction=edit&amp;section=23" title="Edit section: ROLZ">edit</a><span> | </span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;action=edit&amp;section=23" title="Edit section: ROLZ">edit source</a><span>]</span></span></h4>
<p>ROLZ stands for &#34;Reduced Offset Lempel-Ziv&#34; and its goal is to improve LZ77 compression by restricting the offset length to reduce the amount of data required to encode the offset-length pair. This derivative of LZ77 was first seen in 1991 in Ross Williams&#39; LZRW4 algorithm. Other implementations include BALZ, QUAD, and RZM. Highly optimized ROLZ can achieve nearly the same compression ratios as LZMA; however, ROLZ suffers from a lack of popularity.
</p>
<h4><span id="LZP">LZP</span><span><span>[</span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;veaction=edit&amp;section=24" title="Edit section: LZP">edit</a><span> | </span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;action=edit&amp;section=24" title="Edit section: LZP">edit source</a><span>]</span></span></h4>
<p>LZP stands for &#34;Lempel-Ziv + Prediction.&#34; It is a special case of ROLZ algorithm where the offset is reduced to 1. There are several variations using different techniques to achieve either faster operation of better compression ratios. LZW4 implements an arithmetic encoder to achieve the best compression ratio at the cost of speed. <sup id="cite_ref-refnum17_22-0"><a href="#cite_note-refnum17-22">[22]</a></sup>
</p>
<h4><span id="LZRW1">LZRW1</span><span><span>[</span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;veaction=edit&amp;section=25" title="Edit section: LZRW1">edit</a><span> | </span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;action=edit&amp;section=25" title="Edit section: LZRW1">edit source</a><span>]</span></span></h4>
<p>Ron Williams created this algorithm in 1991, introducing the concept of a Reduced-Offset Lempel-Ziv compression for the first time. LZRW1 can achieve high compression ratios while remaining very fast and efficient. Ron Williams also created several variants that improve on LZRW1 such asa LZRW1-A, 2, 3, 3-A, and 4.<sup id="cite_ref-refnum22_23-0"><a href="#cite_note-refnum22-23">[23]</a></sup>
</p>
<h4><span id="LZJB">LZJB</span><span><span>[</span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;veaction=edit&amp;section=26" title="Edit section: LZJB">edit</a><span> | </span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;action=edit&amp;section=26" title="Edit section: LZJB">edit source</a><span>]</span></span></h4>
<p>Jeff Bonwick created his Lempel-Ziv Jeff Bonwick algorithm in 1998 for use in the Solaris Z File System (ZFS). It is considered a variant of the LZRW algorithm, specifically the LZRW1 variant which is aimed at maximum compression speed. Since it is used in a file system, speed is especially important to ensure that disk operations are not bottlenecked by the compression algorithm.
</p>
<h4><span id="LZS">LZS</span><span><span>[</span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;veaction=edit&amp;section=27" title="Edit section: LZS">edit</a><span> | </span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;action=edit&amp;section=27" title="Edit section: LZS">edit source</a><span>]</span></span></h4>
<p>The Lempel-Ziv-Stac algorithm was developed by Stac Electronics in 1994 for use in disk compression software. It is a modification to LZ77 which distinguishes between literal symbols in the output and offset-length pairs, in addition to removing the next encountered symbol. The LZS algorithm is functionally most similar to the LZSS algorithm.<sup id="cite_ref-refnum23_24-0"><a href="#cite_note-refnum23-24">[24]</a></sup>
</p>
<h4><span id="LZX">LZX</span><span><span>[</span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;veaction=edit&amp;section=28" title="Edit section: LZX">edit</a><span> | </span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;action=edit&amp;section=28" title="Edit section: LZX">edit source</a><span>]</span></span></h4>
<p>The LZX algorithm was developed in 1995 by Jonathan Forbes and Tomi Poutanen for the Amiga computer. The X in LZX has no special meaning. Forbes sold the algorithm to Microsoft in 1996 and went to work for them, where it was further improved upon for use in Microsoft&#39;s cabinet  (.CAB) format. This algorithm is also employed by Microsoft to compress Compressed HTML Help (CHM) files, Windows Imaging Format (WIM) files, and Xbox Live Avatars.<sup id="cite_ref-refnum24_25-0"><a href="#cite_note-refnum24-25">[25]</a></sup>
</p>
<h4><span id="LZO">LZO</span><span><span>[</span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;veaction=edit&amp;section=29" title="Edit section: LZO">edit</a><span> | </span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;action=edit&amp;section=29" title="Edit section: LZO">edit source</a><span>]</span></span></h4>
<p>LZO was developed by Markus Oberhumer in 1996 whose development goal was fast compression and decompression. It allows for adjustable compression levels and requires only 64kB of additional memory for the highest compression level, while decompression only requires the input and output buffers. LZO functions very similarly to the LZSS algorithm but is optimized for speed rather than compression ratio. <sup id="cite_ref-refnum25_26-0"><a href="#cite_note-refnum25-26">[26]</a></sup>
</p>
<h4><span id="LZMA">LZMA</span><span><span>[</span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;veaction=edit&amp;section=30" title="Edit section: LZMA">edit</a><span> | </span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;action=edit&amp;section=30" title="Edit section: LZMA">edit source</a><span>]</span></span></h4>
<p>The Lempel-Ziv Markov chain Algorithm was first published in 1998 with the release of the 7-Zip archiver for use in the .7z file format. It achieves better compression than bzip2, DEFLATE, and other algorithms in most cases. LZMA uses a chain of compression techniques to achieve its output. First, a modified LZ77 algorithm, which operates at a bitwise level rather than the traditional bytewise level, is used to parse the data. Then, the output of the LZ77 algorithm undergoes arithmetic coding. More techniques can be applied depending on the specific LZMA implementation. The result is considerably improved compression ratios over most other LZ variants mainly due to the bitwise method of compression rather than bytewise.<sup id="cite_ref-refnum26_27-0"><a href="#cite_note-refnum26-27">[27]</a></sup>
</p>
<h4><span id="LZMA2">LZMA2</span><span><span>[</span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;veaction=edit&amp;section=31" title="Edit section: LZMA2">edit</a><span> | </span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;action=edit&amp;section=31" title="Edit section: LZMA2">edit source</a><span>]</span></span></h4>
<p>LZMA2 is an incremental improvement to the original LZMA algorithm, first introduced in 2009<sup id="cite_ref-refnum27_28-0"><a href="#cite_note-refnum27-28">[28]</a></sup> in an update to the 7-Zip archive software. LZMA2 improves the multithreading capabilities and thus performance of the LZMA algorithm, as well as better handling of incompressible data resulting in slightly better compression.
</p>
<h4><span id="Statistical_Lempel-Ziv">Statistical Lempel-Ziv</span><span><span>[</span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;veaction=edit&amp;section=32" title="Edit section: Statistical Lempel-Ziv">edit</a><span> | </span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;action=edit&amp;section=32" title="Edit section: Statistical Lempel-Ziv">edit source</a><span>]</span></span></h4>
<p>Statistical Lempel-Ziv was a concept created by Dr. Sam Kwong and Yu Fan Ho in  2001. The basic principle it operates on is that a statistical analysis of the data can be combined with an LZ77-variant algorithm to further optimize what codes are stored in the dictionary. <sup id="cite_ref-refnum28_29-0"><a href="#cite_note-refnum28-29">[29]</a></sup>
</p>
<h3><span id="Dictionary_Algorithms">Dictionary Algorithms</span><span><span>[</span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;veaction=edit&amp;section=33" title="Edit section: Dictionary Algorithms">edit</a><span> | </span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;action=edit&amp;section=33" title="Edit section: Dictionary Algorithms">edit source</a><span>]</span></span></h3>
<h4><span id="LZ78">LZ78</span><span><span>[</span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;veaction=edit&amp;section=34" title="Edit section: LZ78">edit</a><span> | </span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;action=edit&amp;section=34" title="Edit section: LZ78">edit source</a><span>]</span></span></h4>
<p>LZ78 was created by Lempel and Ziv in 1978, hence the abbreviation. Rather than using a sliding window to generate the dictionary, the input data is either preprocessed to generate a dictionary wiith infinite scope of the input, or the dictionary is formed as the file is parsed. LZ78 employs the latter tactic. The dictionary size is usually limited to a few megabytes, or all codes up to a certain numbers of bytes such as 8; this is done to reduce memory requirements. How the algorithm handles the dictionary being full is what sets most LZ78 type algorithms apart.<sup id="cite_ref-refnum4_4-1"><a href="#cite_note-refnum4-4">[4]</a></sup>
</p><p>While parsing the file, the LZ78 algorithm adds each newly encountered character or string of characters to the dictionary. For each synbol in the input, a dictionary entry in the form (dictionary index, unknown symbol) is generated; if a symbol is already in the dictionary then the dictionary will be searched for substrings of the current symbol and the symbols following it. The index of the longest substring match is used for the dictionary index. The data pointed to by the dictionary index is added to the last character of the unknown substring. If the current symbol is unknown, then the dictionary index is set to 0 to indicate that it is a single character entry. The entries form a linked-list type data structure.<sup id="cite_ref-refnum12_19-3"><a href="#cite_note-refnum12-19">[19]</a></sup>
</p><p>An input such as &#34;abbadabbaabaad&#34; would generate the output &#34;(0,a)(0,b)(2,a)(0,d)(1,b)(3,a)(6,d)&#34;. You can see how this was derived in the following example:
</p>
<table>

<tbody><tr>
<td>Input:<br/>
</td>
<td> <br/>
</td>
<td> a<br/>
</td>
<td> b<br/>
</td>
<td>ba<br/>
</td>
<td> d<br/>
</td>
<td>ab<br/>
</td>
<td>baa<br/>
</td>
<td>baad<br/>
</td></tr>
<tr>
<td>Dictionary Index<br/>
</td>
<td>     0
</td>
<td> 1<br/>
</td>
<td> 2<br/>
</td>
<td> 3<br/>
</td>
<td> 4<br/>
</td>
<td> 5<br/>
</td>
<td>  6<br/>
</td>
<td> 7<br/>
</td></tr>
<tr>
<td>Output<br/>
</td>
<td> NULL<br/>
</td>
<td>(0,a)<br/>
</td>
<td>(0,b)<br/>
</td>
<td>(2,a)<br/>
</td>
<td>(0,d)<br/>
</td>
<td>(1,b)<br/>
</td>
<td>(3,a)
</td>
<td>(6,d)<br/>
</td></tr></tbody></table>
<h4><span id="LZW">LZW</span><span><span>[</span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;veaction=edit&amp;section=35" title="Edit section: LZW">edit</a><span> | </span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;action=edit&amp;section=35" title="Edit section: LZW">edit source</a><span>]</span></span></h4>
<p>LZW is the Lempel-Ziv-Welch algorithm created in 1984 by Terry Welch. It is the most commonly used derivative of the LZ78 family, despite being heavily patent-encumbered. LZW improves on LZ78 in a similar way to LZSS; it removes redundant characters in the output and makes the output entirely out of pointers. It also includes every character in the dictionary before starting compression, and employs other tricks to improve compression such as encoding the last character of every new phrase as the first character of the next phrase. LZW is commonly found in the Graphics Interchange Format, as well as in the early specificiations of the ZIP format and other specialized applications. LZW is very fast, but achieves poor compression compared to most newer algorithms and some algorithms are both faster and achieve better compression. <sup id="cite_ref-refnum12_19-4"><a href="#cite_note-refnum12-19">[19]</a></sup>
</p>
<h4><span id="LZC">LZC</span><span><span>[</span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;veaction=edit&amp;section=36" title="Edit section: LZC">edit</a><span> | </span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;action=edit&amp;section=36" title="Edit section: LZC">edit source</a><span>]</span></span></h4>
<p>LZC, or Lempel-Ziv Compress is a slight modification to the LZW algorithm used in the UNIX compress utility. The main difference between LZC and LZW is that LZC monitors the compression ratio of the output. Once the ratio crosses a certain threshold, the dictionary is discarded and rebuilt. <sup id="cite_ref-refnum12_19-5"><a href="#cite_note-refnum12-19">[19]</a></sup>
</p>
<h4><span id="LZT">LZT</span><span><span>[</span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;veaction=edit&amp;section=37" title="Edit section: LZT">edit</a><span> | </span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;action=edit&amp;section=37" title="Edit section: LZT">edit source</a><span>]</span></span></h4>
<p>Lempel-Ziv Tischer is a modification of LZC that, when the dictionary is full, deletes the least recently used phrase and replaces it with a new entry. There are some other incremental improvements, but neither LZC nor LZT is commonly used today. <sup id="cite_ref-refnum12_19-6"><a href="#cite_note-refnum12-19">[19]</a></sup>
</p>
<h4><span id="LZMW">LZMW</span><span><span>[</span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;veaction=edit&amp;section=38" title="Edit section: LZMW">edit</a><span> | </span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;action=edit&amp;section=38" title="Edit section: LZMW">edit source</a><span>]</span></span></h4>
<p>Invented in 1984 by Victor Miller and Mark Wegman, the LZMW algorithm is quite similar to LZT in that it employs the least recently used phrase substitution strategy. However, rather than joining together similar entries in the dictionary, LZMW joins together the last two phrases encoded and stores the result as a new entry. As a result, the size of the dictionary can expand quite rapidly and LRUs must be discarded more frequently. LZMW generally achieves better compression than LZT, however it is yet another algorithm that does not see much modern use. <sup id="cite_ref-refnum12_19-7"><a href="#cite_note-refnum12-19">[19]</a></sup>
</p>
<h4><span id="LZAP">LZAP</span><span><span>[</span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;veaction=edit&amp;section=39" title="Edit section: LZAP">edit</a><span> | </span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;action=edit&amp;section=39" title="Edit section: LZAP">edit source</a><span>]</span></span></h4>
<p>LZAP was created in 1988 by James Storer as a modification to the LZMW algorithm. The AP stands for &#34;all prefixes&#34; in that rather than storing a single phrase in the dictionary each iteration, the dictionary stores every permutation. For example, if the last phrase was &#34;last&#34; and the current phrase is &#34;next&#34; the dictionary would store &#34;lastn&#34;, &#34;lastne&#34;, &#34;lastnex&#34;, and &#34;lastnext&#34;. <sup id="cite_ref-refnum31_30-0"><a href="#cite_note-refnum31-30">[30]</a></sup>
</p>
<h4><span id="LZWL">LZWL</span><span><span>[</span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;veaction=edit&amp;section=40" title="Edit section: LZWL">edit</a><span> | </span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;action=edit&amp;section=40" title="Edit section: LZWL">edit source</a><span>]</span></span></h4>
<p>LZWL is a modification to the LZW algorithm created in 2006 that works with syllables rather than than single characters. LZWL is designed to work better with certain datasets with many commonly occuring syllables such as XML data. This type of algorithm is usually used with a preprocessor that decomposes the input data into syllables.<sup id="cite_ref-refnum30_31-0"><a href="#cite_note-refnum30-31">[31]</a></sup>
</p>
<h4><span id="LZJ">LZJ</span><span><span>[</span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;veaction=edit&amp;section=41" title="Edit section: LZJ">edit</a><span> | </span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;action=edit&amp;section=41" title="Edit section: LZJ">edit source</a><span>]</span></span></h4>
<p>Matti Jakobsson published the LZJ algorithm in 1985<sup id="cite_ref-refnum33_32-0"><a href="#cite_note-refnum33-32">[32]</a></sup> and it is one of the only LZ78 algorithms that deviates from LZW. The algorithm works by storing every unique string in the already processed input up to an arbitrary maximum length in the dictionary and assigning codes to each. When the dictionary is full, all entries that occurred only once are removed.<sup id="cite_ref-refnum12_19-8"><a href="#cite_note-refnum12-19">[19]</a></sup>
</p>
<h3><span id="Non-dictionary_Algorithms">Non-dictionary Algorithms</span><span><span>[</span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;veaction=edit&amp;section=42" title="Edit section: Non-dictionary Algorithms">edit</a><span> | </span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;action=edit&amp;section=42" title="Edit section: Non-dictionary Algorithms">edit source</a><span>]</span></span></h3>
<h4><span id="PPM">PPM</span><span><span>[</span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;veaction=edit&amp;section=43" title="Edit section: PPM">edit</a><span> | </span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;action=edit&amp;section=43" title="Edit section: PPM">edit source</a><span>]</span></span></h4>
<p>Prediction by Partial Matching is a statistical modeling technique that uses a set of previous symbols in the input to predict what the next symbol will be in order to reduce the entropy of the output data. This is different from a dictionary since PPM makes predictions about what the next symbol will be rather than trying to find the next symbols in the dictionary to code them. PPM is usually combined with an encoder on the back end, such as arithmetic coding or adaptive Huffman coding.<sup id="cite_ref-refnum34_33-0"><a href="#cite_note-refnum34-33">[33]</a></sup> PPM or a variant known as PPMd are implemented in many archive formats including 7-Zip and RAR.
</p>
<h4><span id="bzip2">bzip2</span><span><span>[</span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;veaction=edit&amp;section=44" title="Edit section: bzip2">edit</a><span> | </span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;action=edit&amp;section=44" title="Edit section: bzip2">edit source</a><span>]</span></span></h4>
<p>bzip2 is an open source implementation of the Burrows-Wheeler Transform. Its operating principles are simple, yet they achieve a very good compromise between speed and compression ratio that makes the bzip2 format very popular in UNIX environments. First, a Run-Length Encoder is applied to the data. Next, the Burrows-Wheeler Transform is applied. Then, a move-to-front transform is applied with the intent of creating a large amount of identical symbols forming runs for use in yet another Run-Length Encoder. Finally, the result is Huffman coded and wrapped  with a header.<sup id="cite_ref-refnum32_34-0"><a href="#cite_note-refnum32-34">[34]</a></sup>
</p>
<h4><span id="PAQ">PAQ</span><span><span>[</span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;veaction=edit&amp;section=45" title="Edit section: PAQ">edit</a><span> | </span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;action=edit&amp;section=45" title="Edit section: PAQ">edit source</a><span>]</span></span></h4>
<p>PAQ was created by Matt Mahoney in 2002 as an improvement upon older PPM(d) algorithms. The way it does this is by using a revolutionary technique called context mixing. Context mixing is when multiple statistical models (PPM is one example) are intelligently combined to make better predictions of the next symbol than either model by itself. PAQ is one of the most promising algorithms because of its extremely high compression ratio and very active development. Over 20 variants have been created since its inception, with some variants achieving record compression ratios. The biggest drawback of PAQ is its slow speed due to using multiple statistical models to get the best compression ratio. However, since hardware is constantly getting faster, it may be the standard of the future.<sup id="cite_ref-refnum35_35-0"><a href="#cite_note-refnum35-35">[35]</a></sup> PAQ is slowly being adopted, and a variant called PAQ8O which brings 64-bit support and major speed improvements can be found in the PeaZip program for Windows. Other PAQ formats are mostly command-line only.
</p>
<h2><span id="References">References</span><span><span>[</span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;veaction=edit&amp;section=46" title="Edit section: References">edit</a><span> | </span><a href="https://ethw.org/w/index.php?title=History_of_Lossless_Data_Compression_Algorithms&amp;action=edit&amp;section=46" title="Edit section: References">edit source</a><span>]</span></span></h2>
<div><ol>
<li id="cite_note-refnum1-1"><span>↑ <sup><a href="#cite_ref-refnum1_1-0">1.0</a></sup> <sup><a href="#cite_ref-refnum1_1-1">1.1</a></sup></span> <span>Wolfram, Stephen. A New Kind of Science. Champaign, IL: Wolfram Media, 2002. 1069. Print.</span>
</li>
<li id="cite_note-refnum2-2"><span><a href="#cite_ref-refnum2_2-0">↑</a></span> <span>Ken Huffman. Profile: David A. Huffman, Scientific American, September 1991, pp. 54–58.</span>
</li>
<li id="cite_note-refnum3-3"><span>↑ <sup><a href="#cite_ref-refnum3_3-0">3.0</a></sup> <sup><a href="#cite_ref-refnum3_3-1">3.1</a></sup></span> <span>Ziv J., Lempel A., “A Universal Algorithm for Sequential Data Compression”, IEEE Transactions on Information Theory, Vol. 23, No. 3 (1977), pp. 337-343. </span>
</li>
<li id="cite_note-refnum4-4"><span>↑ <sup><a href="#cite_ref-refnum4_4-0">4.0</a></sup> <sup><a href="#cite_ref-refnum4_4-1">4.1</a></sup></span> <span>Ziv J., Lempel A., “Compression of Individual Sequences via Variable-Rate Coding”, IEEE Transactions on Information Theory, Vol. 24, No. 5, pp. 530-536. </span>
</li>
<li id="cite_note-refnum5-5"><span>↑ <sup><a href="#cite_ref-refnum5_5-0">5.0</a></sup> <sup><a href="#cite_ref-refnum5_5-1">5.1</a></sup></span> <span>USPTO Patent #4814746. See <a target="_blank" rel="nofollow noreferrer noopener" href="http://www.theregister.co.uk/1999/09/01/unisys_demands_5k_licence_fee">http://www.theregister.co.uk/1999/09/01/unisys_demands_5k_licence_fee</a></span>
</li>
<li id="cite_note-refnum6-6"><span>↑ <sup><a href="#cite_ref-refnum6_6-0">6.0</a></sup> <sup><a href="#cite_ref-refnum6_6-1">6.1</a></sup></span> <span><a target="_blank" rel="nofollow noreferrer noopener" href="http://stephane.lesimple.fr/wiki/blog/lzop_vs_compress_vs_gzip_vs_bzip2_vs_lzma_vs_lzma2-xz_benchmark_reloaded">http://stephane.lesimple.fr/wiki/blog/lzop_vs_compress_vs_gzip_vs_bzip2_vs_lzma_vs_lzma2-xz_benchmark_reloaded</a></span>
</li>
<li id="cite_note-refnum7-7"><span><a href="#cite_ref-refnum7_7-0">↑</a></span> <span><a target="_blank" rel="nofollow noreferrer noopener" href="http://www.msversus.org/archive/stac.html">http://www.msversus.org/archive/stac.html</a></span>
</li>
<li id="cite_note-refnum16-8"><span><a href="#cite_ref-refnum16_8-0">↑</a></span> <span><a target="_blank" rel="nofollow noreferrer noopener" href="http://www.esva.net/~thom/philkatz.html">ARC Info</a> </span>
</li>
<li id="cite_note-refnum13-9"><span><a href="#cite_ref-refnum13_9-0">↑</a></span> <span><a target="_blank" rel="nofollow noreferrer noopener" href="http://www.faqs.org/faqs/compression-faq/part1/section-7.html">http://www.faqs.org/faqs/compression-faq/part1/section-7.html</a></span>
</li>
<li id="cite_note-refnum14-10"><span><a href="#cite_ref-refnum14_10-0">↑</a></span> <span>USPTO Patent #5051745 </span>
</li>
<li id="cite_note-refnum15-11"><span><a href="#cite_ref-refnum15_11-0">↑</a></span> <span><a target="_blank" rel="nofollow noreferrer noopener" href="http://www.bbsdocumentary.com/library/CONTROVERSY/LAWSUITS/SEA/katzbio.txt">Phil Katz&#39; Death</a> </span>
</li>
<li id="cite_note-refnum20-12"><span><a href="#cite_ref-refnum20_12-0">↑</a></span> <span>Iwata, K., Arimura, M., and Shima, Y., &#34;An Improvement in Lossless Data Compression via Substring Enumeration&#34;, , 2011 IEEE/ACIS 10th International Conference on Computer and Information Science (ICIS).</span>
</li>
<li id="cite_note-refnum29-13"><span><a href="#cite_ref-refnum29_13-0">↑</a></span> <span>Burrows M., and Wheeler, D. J. 1994. A Block-Sorting Lossless Data Compression Algorithm. SRC Research Report 124, Digital Systems Research Center.</span>
</li>
<li id="cite_note-refnum8-14"><span><a href="#cite_ref-refnum8_14-0">↑</a></span> <span><a target="_blank" rel="nofollow noreferrer noopener" href="http://www.cs.tau.ac.il/~dcor/Graphics/adv-slides/entropy.pdf">http://www.cs.tau.ac.il/~dcor/Graphics/adv-slides/entropy.pdf</a></span>
</li>
<li id="cite_note-refnum9-15"><span><a href="#cite_ref-refnum9_15-0">↑</a></span> <span>Shannon, C.E. (July 1948). &#34;A Mathematical Theory of Communication&#34;. Bell System Technical Journal 27: 379–423. </span>
</li>
<li id="cite_note-refnum10-16"><span><a href="#cite_ref-refnum10_16-0">↑</a></span> <span>HUFFMAN, D. A. 1952. A method for the construction of minimum-redundancy codes. In Proceedings of the Institute of Electrical and Radio Engineers 40, 9 (Sept.), pp. 1098-1101. </span>
</li>
<li id="cite_note-refnum11-17"><span><a href="#cite_ref-refnum11_17-0">↑</a></span> <span>RISSANEN, J., AND LANGDON, G. G. 1979. Arithmetic coding. IBM J. Res. Dev. 23, 2 (Mar.), 149-162. </span>
</li>
<li id="cite_note-refnum18-18"><span><a href="#cite_ref-refnum18_18-0">↑</a></span> <span>RODEH, M., PRATT, V. R., AND EVEN, S. 1981. Linear algorithm for data compression via string matching. J. ACM 28, 1 (Jan.), 16-24. </span>
</li>
<li id="cite_note-refnum12-19"><span>↑ <sup><a href="#cite_ref-refnum12_19-0">19.0</a></sup> <sup><a href="#cite_ref-refnum12_19-1">19.1</a></sup> <sup><a href="#cite_ref-refnum12_19-2">19.2</a></sup> <sup><a href="#cite_ref-refnum12_19-3">19.3</a></sup> <sup><a href="#cite_ref-refnum12_19-4">19.4</a></sup> <sup><a href="#cite_ref-refnum12_19-5">19.5</a></sup> <sup><a href="#cite_ref-refnum12_19-6">19.6</a></sup> <sup><a href="#cite_ref-refnum12_19-7">19.7</a></sup> <sup><a href="#cite_ref-refnum12_19-8">19.8</a></sup></span> <span>Bell, T., Witten, I., Cleary, J., &#34;Modeling for Text Compression&#34;, ACM Computing Surveys, Vol. 21, No. 4 (1989). </span>
</li>
<li id="cite_note-refnum19-20"><span><a href="#cite_ref-refnum19_20-0">↑</a></span> <span><a target="_blank" rel="nofollow noreferrer noopener" href="http://www.binaryessence.com/dct/apc/en000263.htm">DEFLATE64 benchmarks</a> </span>
</li>
<li id="cite_note-refnum21-21"><span><a href="#cite_ref-refnum21_21-0">↑</a></span> <span>STORER, J. A., AND SZYMANSKI, T. G. 1982. Data compression via textual substitution. J. ACM 29, 4 (Oct.), 928-951. </span>
</li>
<li id="cite_note-refnum17-22"><span><a href="#cite_ref-refnum17_22-0">↑</a></span> <span>Bloom, C., &#34;LZP: a new data compression algorithm&#34;, Data Compression Conference, 1996. DCC &#39;96. Proceedings, p. 425 10.1109/DCC.1996.488353. </span>
</li>
<li id="cite_note-refnum22-23"><span><a href="#cite_ref-refnum22_23-0">↑</a></span> <span><a target="_blank" rel="nofollow noreferrer noopener" href="http://www.ross.net/compression/">http://www.ross.net/compression/</a> </span>
</li>
<li id="cite_note-refnum23-24"><span><a href="#cite_ref-refnum23_24-0">↑</a></span> <span>&#34;Data Compression Method - Adaptive Coding witih Sliding Window for Information Interchange&#34;, American National Standard for Information Systems, August 30, 1994.</span>
</li>
<li id="cite_note-refnum24-25"><span><a href="#cite_ref-refnum24_25-0">↑</a></span> <span><a target="_blank" rel="nofollow noreferrer noopener" href="http://www.linkedin.com/pub/jonathan-forbes/3/70a/a4b">LZX Sold to Microsoft</a></span>
</li>
<li id="cite_note-refnum25-26"><span><a href="#cite_ref-refnum25_26-0">↑</a></span> <span><a target="_blank" rel="nofollow noreferrer noopener" href="http://www.oberhumer.com/opensource/lzo/">LZO Info</a></span>
</li>
<li id="cite_note-refnum26-27"><span><a href="#cite_ref-refnum26_27-0">↑</a></span> <span><a target="_blank" rel="nofollow noreferrer noopener" href="https://secure.wikimedia.org/wikipedia/en/wiki/Lempel–Ziv–Markov_chain_algorithm">LZMA</a> Accessed on 12/10/2011.</span>
</li>
<li id="cite_note-refnum27-28"><span><a href="#cite_ref-refnum27_28-0">↑</a></span> <span><a target="_blank" rel="nofollow noreferrer noopener" href="http://www.7-zip.org/history.txt">LZMA2 Release Date</a></span>
</li>
<li id="cite_note-refnum28-29"><span><a href="#cite_ref-refnum28_29-0">↑</a></span> <span>Kwong, S., Ho, Y.F., &#34;A Statistical Lempel-Ziv Compression Algorithm for Personal Digital Assistant (PDA)&#34;, IEEE Transactions on Consumer Electronics, Vol. 47, No. 1, February 2001, pp 154-162.</span>
</li>
<li id="cite_note-refnum31-30"><span><a href="#cite_ref-refnum31_30-0">↑</a></span> <span>David Salomon, Data Compression – The complete reference, 4th ed., page 212</span>
</li>
<li id="cite_note-refnum30-31"><span><a href="#cite_ref-refnum30_31-0">↑</a></span> <span>Chernik, K., Lansky, J., Galambos, L., &#34;Syllable-based Compression for XML Documents&#34;, Dateso 2006, pp 21-31, ISBN 80-248-1025-5.</span>
</li>
<li id="cite_note-refnum33-32"><span><a href="#cite_ref-refnum33_32-0">↑</a></span> <span>Jakobsson, M., &#34;Compression of Character Strings by an Adaptive Dictionary&#34;, BIT Computer Science and Numerical Mathematics, Vol. 25 No. 4 (1985). doi&gt;10.1007/BF01936138</span>
</li>
<li id="cite_note-refnum34-33"><span><a href="#cite_ref-refnum34_33-0">↑</a></span> <span>Cleary, J., Witten, I., &#34;Data Compression Using Adaptive Coding and Partial String Matching&#34;, IEEE Transactions on Communications, Vol. COM-32, No. 4, April 1984, pp 396-402. </span>
</li>
<li id="cite_note-refnum32-34"><span><a href="#cite_ref-refnum32_34-0">↑</a></span> <span>Seward, J., &#34;bzip2 and libbzip2&#34;, bzip2 Manual, March 2000.</span>
</li>
<li id="cite_note-refnum35-35"><span><a href="#cite_ref-refnum35_35-0">↑</a></span> <span>Mahoney, M., &#34;Adaptive Weighting of Context Models for Lossless Data Compression&#34;, Unknown, 2002.</span>
</li>
</ol></div>
<!-- 
NewPP limit report
Cached time: 20220628191828
Cache expiry: 86400
Dynamic content: false
Complications: []
[SMW] In‐text annotation parser time: 0 seconds
CPU time usage: 0.072 seconds
Real time usage: 0.074 seconds
Preprocessor visited node count: 570/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 16522/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 -total
-->

<!-- Saved in parser cache with key ethw:pcache:idhash:24770-0!canonical and timestamp 20220628191828 and revision id 172758
 -->
</div></div></div>

						<!-- end body text -->
						<!-- data blocks which should go somewhere after the body text, but not before the catlinks block-->
						
					</div></div>
  </body>
</html>
