<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lewiscampbell.tech/blog/250104.html">Original</a>
    <h1>Do Files want to be Actors?</h1>
    
    <div id="readability-page-1" class="page"><div><p>In the world of high performance linux apps, <a href="https://unixism.net/loti/what_is_io_uring.html#what-is-io-uring">io_uring</a> is changing how we communicate with the operating system.</p>
<p>The io_uring model is based on two queues:</p>
<ul>
<li>a submission queue, where you send the kernel an operation to execute</li>
<li>a completions queue, where you read the result of the execution</li>
</ul>
<p>Combined with an event loop, we have a new way of doing IO on linux without waiting on syscalls to complete before yielding back control to the program. You simply put things on the queue, and then you get right back to computing.</p>
<p>The async request sent to the kernel has this structure (see <code>man 7 io_uring</code>):</p>
<pre><code>      struct io_uring_sqe {
                   __u8    opcode;         /* type of operation for this sqe */
                   __s32   fd;             /* file descriptor to do IO on */
                   __u64   off;            /* offset into file */
                   __u64   addr;           /* pointer to buffer or iovecs */
                   __u32   len;            /* buffer size or number of iovecs */
                   __u64   user_data;      /* data to be passed back at completion time */
                   __u8    flags;          /* IOSQE_ flags */
                   ...
           };
</code></pre>
<p>The <code>opcode</code> represents the OS level syscall, ie <code>open</code>, <code>read</code>, <code>write</code> etc. So
even function call semantics are abstracted away by this OS interface.</p>
<p>Re-wind back to the 1970s, where Carl Hewitt and Henry Baker wrote the first paper about the actor model; <a href="https://dspace.mit.edu/bitstream/handle/1721.1/41962/AI_WP_134A.pdf?sequence=1&amp;isAllowed=y">Laws for Communicating Parallel Processes</a>. In it they describe a base model for concurrent computations:</p>
<p><em>The action in the actor model consists of objects called actors sending messages to other actors, called the targets of those messages...an event E is the receipt of the message &#34;message(E)&#34; by the actor &#34;target(E)&#34;. Upon receipt of this message in the event E, the target consults its script (the actor analogue of program text), and using its current local state and the message as parameters, sends new messages to other actors and computes a new local state for itself.</em></p>
<p>Is it just me, or are these two seemingly unrelated schools of computing converging on the exact same idea? You send messages to some target (ie, the file descriptor). You receive (or maybe you don&#39;t receive) responses back asynchronously. We&#39;re not concerned with function calls, or mutexes, or spinlocks - they&#39;re implementation details. We&#39;re concerned with sending messages concurrently.</p>
<p>The game has changed. Our operating systems want to do things asynchronously, on their own terms. They&#39;ll tell you when they&#39;re done. Maybe this is a new era. Maybe making syscalls from 1970s Unix directly is like a remote procedure call to another machine - a leaky abstraction, a feeble attempt to impose your old mental model onto a new reality.</p>
</div></div>
  </body>
</html>
