<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://scottarc.blog/2022/07/04/police-cyberalarm-uses-alarming-cryptography/">Original</a>
    <h1>Police CyberAlarm Uses Alarming Cryptography</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>Today we’re going to be talking about this code, shared on Twitter by <strong>Paul Moore</strong>.</p>



<figure><div>

</div></figure>



<p>It’s worth noting that this code snippet was <em>after</em> Paul attempted to alert them to security issues with the previous iteration of their encryption software, which looked like this:</p>



<figure><div>

</div></figure>



<p>If you’re interested in a deeper dive into the insecurity of their software, Paul published a series of posts about this topic.</p>



<ul><li><a href="https://paul.reviews/cyberalarm-an-independent-security-review-and-why-you-should-avoid-it/">CyberAlarm: An independent security review… and why you should avoid it</a></li><li><a href="https://paul.reviews/cyberalarm-testing-the-production-version-and-why-you-should-avoid-it/">CyberAlarm: Testing the “production version”… and why you should avoid it</a></li><li><a href="https://paul.reviews/police-cyberalarm-abysmal-security-yet-again/">Police CyberAlarm: Absymal security, yet again</a></li></ul>



<p>I’m not going to be as harsh as Paul–not out of any particular sentiment towards law enforcement, but because there’s enough vitriol in the security industry. I don’t feel like joining the incumbent tone or risk making a neophyte’s impostor syndrome worse than it already is.</p>



<h2>The Code in Question</h2>



<p>I have transcribed their source code from the screenshot on Twitter below.</p>


<div><pre title="">&lt;?php

function pervade_encrypt($data)
{
    $encryption_key = (defined(&#39;NEW_PERVADE_KEY&#39;) ? NEW_PERVADE_KEY : PERVADE_KEY);
    $iv = openssl_random_pseudo_bytes(openssl_cipher_iv_length(&#39;aes-256-cbc&#39;), $csprng_check);

    while((strpos($iv, &#39;::&#39;) !== false) || !$csprng_check) {
        $iv = openssl_random_pseudo_bytes(openssl_cipher_iv_length(&#39;aes-256-cbc&#39;), $csprng_check);
    }

    $encrypted = openssl_encrypt($data, &#39;aes-256-cbc&#39;, $encryption_key, 0, $iv);
    $length = strlen($encrypted);
    $hash = hash_hmac(&#39;sha256&#39;, $encrypted . $iv, $encryption_key);
    return base64_encode($encrypted . &#39;::&#39; . $length . &#39;-&#39; . $hash . &#39;::&#39; . $iv);
}

function pervade_decrypt($data)
{
    $encryption_key = (defined(&#39;NEW_PERVADE_KEY&#39;) ? NEW_PERVADE_KEY : PERVADE_KEY);
    $exp = explode(&#39;::&#39;, base64_decode($data), 3);

    if (isset($exp[2])) {
        $encrypted_data = $exp[0];
        $length = $exp[1];
        $iv = $exp[2];
        $lenexp = explode(&#39;-&#39;, $length);

        if (isset($lenexp[1])) {
            $hmac = str_replace($lenexp[0] . &#39;-&#39;, &#39;&#39;, $length);
            $length = $lenexp[0];
        }
        else {
            $hmac = hash_hmac(&#39;sha256&#39;, $encrypted_data . $iv, $encryption_key);
        }

        $hashcheck = hash_hmac(&#39;sha256&#39;, $encrypted_data . $iv, $encryption_key);
        if ((strlen($encrypted_data) == $length) &amp;&amp; ($hmac == $hashcheck)) {
            return @openssl_decrypt($encrypted_data, &#39;aes-256-cbc&#39;, $encryption_key, 0, $iv);
        }
    }
    else if (isset($exp[1])) {
        $encrypted_data = $exp[0];
        $iv = $exp[1];
        return @openssl_decrypt($encrypted_data, &#39;aes-256-cbc&#39;, $encryption_key, 0, $iv);
    }
}
</pre></div>


<p>If you’re interested in Paul’s challenge, take a moment to read this PHP code carefully and see if you can spot the flaws. There’s more than one.</p>



<figure><div>

</div></figure>



<hr/>



<h2>How to Review Cryptographic Protocols</h2>



<p>Whenever you are confronted with a novel cryptographic implementation (be it a custom protocol or a greenfield implementation of a standard design), always start with the reader, not the writer.</p>



<ul><li>With encryption, this means starting with the decrypt function.</li><li>With digital signatures or symmetric authenticators, this means starting with the verify function.</li></ul>



<p>The reasoning is simple: In most threat models, attackers have control over the data being fed into the reader. This lets them perform far more impactful attacks (e.g. padding oracle attacks) than passing information to the writer would reveal (i.e. chosen-plaintext attacks, which overwhelmingly aren’t relevant for protocols that use standard cryptographic algorithms; i.e. AES).</p>



<p>In this case, the <code>pervade_decrypt()</code> function is clearly written in order to support a data format migration from the original implementation to the new format.</p>



<p>To their credit, <code>pervade_encrypt()</code> only writes the new format, so they clearly intended to retire the old message format eventually. However, they never took the time to learn the proper way to handle cryptographic migrations.</p>



<h2>Vulnerabilities in the Decrypt Function</h2>



<h3>Downgrade Attack</h3>



<p>Take an encrypted message that you’re interested in decrypting.</p>



<pre><code>Zis1Q2FkbFVmYzRJbEMwczc0MWdyTFdvSWtGbWp3dkVMT0d6MVp2Q1lWST06OjQ0LThlODI2ZTFiZDVjZDM1YmYwZmQ5MzlkYmM5NDZlNjk4MzA0ZTIzN2FhMWI0ZTIyOTA4Mzk2MGI0ZjA5MThhOGE6OgVzUPsnsRFbrFySXaWdNt0=</code></pre>



<p>Base64-decode it. Remove the value between the first <code>::</code> and the second <code>::</code> (including one of the separators).</p>



<p>Re-encode it with base64, then feed this altered message into the system.</p>



<pre><code>Zis1Q2FkbFVmYzRJbEMwczc0MWdyTFdvSWtGbWp3dkVMT0d6MVp2Q1lWST06OgVzUPsnsRFbrFySXaWdNt0=</code></pre>



<h4>Exploit Code</h4>


<div><pre title="">function exploit1(string $chosen): string {
    $pieces = explode(&#39;::&#39;, base64_decode($chosen));
    unset($pieces[1]);
    return base64_encode(implode(&#39;::&#39;, $pieces));
}
</pre></div>


<p>Now you’ve successfully downgraded the message to the legacy format, which didn’t provide any authentication over the ciphertext.</p>



<h3>HMAC Verification Bypass</h3>



<p>Take an encrypted message that you’re interested in decrypting.</p>



<pre><code>Zis1Q2FkbFVmYzRJbEMwczc0MWdyTFdvSWtGbWp3dkVMT0d6MVp2Q1lWST06OjQ0LThlODI2ZTFiZDVjZDM1YmYwZmQ5MzlkYmM5NDZlNjk4MzA0ZTIzN2FhMWI0ZTIyOTA4Mzk2MGI0ZjA5MThhOGE6OgVzUPsnsRFbrFySXaWdNt0=</code></pre>



<p>Base64-decode it. After the first <code>::</code>, remove the length of the message and the hyphen.</p>



<pre><code>Zis1Q2FkbFVmYzRJbEMwczc0MWdyTFdvSWtGbWp3dkVMT0d6MVp2Q1lWST06OjQ0LThlODI2ZTFiZDVjZDM1YmYwZmQ5MzlkYmM5NDZlNjk4MzA0ZTIzN2FhMWI0ZTIyOTA4Mzk2MGI0ZjA5MThhOGE6OgVzUPsnsRFbrFySXaWdNt0=</code></pre>



<h4>Exploit Code</h4>


<div><pre title="">function exploit2(string $chosen): string {
    $pieces = explode(&#39;::&#39;, base64_decode($chosen));
	$pieces[1] = preg_replace(&#39;/^\-+/&#39;, &#39;&#39;, $pieces[1]);
    return base64_encode(implode(&#39;::&#39;, $pieces));
}
</pre></div>


<h4>Why does this work?</h4>



<p>Because this will put your verification logic into a separate branch that will compare the HMAC it computes… against the HMAC it computes, rather than the one provided.</p>


<div><pre title="">$lenexp = explode(&#39;-&#39;, $length);
// If this isset() call returns FALSE...
if (isset($lenexp[1])) {
    $hmac = str_replace($lenexp[0] . &#39;-&#39;, &#39;&#39;, $length);
    $length = $lenexp[0];
}
else {
     // ...then the value of $hmac...
     $hmac = hash_hmac(&#39;sha256&#39;, $encrypted_data . $iv, $encryption_key);
}
// ...will always be equal to $hashcheck
$hashcheck = hash_hmac(&#39;sha256&#39;, $encrypted_data . $iv, $encryption_key);
if ((strlen($encrypted_data) == $length) &amp;&amp; ($hmac == $hashcheck)) {
    return @openssl_decrypt($encrypted_data, &#39;aes-256-cbc&#39;, $encryption_key, 0, $iv);
}
</pre></div>


<p>With this method, we can completely bypass the HMAC check without stripping the HMAC off the message. Removing the length prefix is sufficient to defeat this security control.</p>



<h3>Padding Oracle Attack on AES-CBC Decryption</h3>



<p>Using either of the two methods, with the HMAC check completely bypassed, you’ve reduced the security of this construction to <em>unauthenticated AES-CBC</em> mode, which is vulnerable to a <a href="https://robertheaton.com/2013/07/29/padding-oracle-attack/">Padding Oracle Attack</a>.</p>



<h3>Timing Attack on HMAC Validation</h3>



<p>Not that it matters much, since you can just bypass the security control entirely, but <code>==</code> is not the correct way to compare hash function outputs.</p>



<p><a href="https://www.php.net/hash_equals">You want <code>hash_equals()</code> instead</a>.</p>



<h3>Confused Deputy Attack</h3>



<p>Modern encryption-at-rest software allows users to specify some Additional Authenticated Data to prevent ciphertexts from being reordered or replayed in an incorrect context.</p>



<p>The encryption used by Police CyberAlarm doesn’t expose an Additional Authenticated Data mechanism. All fields are also encrypted with the same, static, hard-coded key.</p>



<p>Imagine a situation where a user’s ZIP code and legal name are encrypted with <code>pervade_encrypt()</code>. You, as an attacker, have access to the database, but not to the source code. </p>



<p>You also have a limited access user account that lets you view zip codes in a directory listing, but not legal name.</p>



<p>To exploit this, simply overwrite the user’s <code>zip_code</code> field with their encrypted <code>legal_name</code> field and refresh your directory listing. Bob’s your uncle.</p>



<p>To mitigate confused deputy attacks, an AEAD construction is recommended. </p>



<p>It’s also possible to implement a custom protocol using AES-CBC and HMAC-SHA256 that includes AAD support, but extra care must be taken to prevent canonicalization attacks.</p>



<h2>Other Cryptography Design Flaws</h2>



<h3>Using the Same Key for Multiple Algorithms</h3>



<p>Police CyberAlarm uses the same encryption key for both AES-CBC encryption and for HMAC-SHA256. This violates one of the tenets of cryptography protocol design: <strong>Never use the same key for more than one purpose.</strong> </p>



<p>If you ever fail to uphold this tenet, you introduce <a href="https://crypto.stackexchange.com/a/8086/24405">the risk of related key and cross-protocol attacks in your application</a>. While this isn’t currently known to be exploitable with AES and HMAC, it is very much exploitable in some setups using AES and CBC-MAC.</p>



<p>Instead of reusing <code>$encryption_key</code> for both <code>openssl_encrypt()</code> and <code>hash_hmac()</code>, the correct thing to do is use a key derivation function (i.e. <a href="https://www.php.net/hash_hkdf">HKDF</a>) to split the incoming key into two different keys: One for encryption, the other for authentication.</p>


<div><pre title="">$ikm = (defined(&#39;NEW_PERVADE_KEY&#39;) ? NEW_PERVADE_KEY : PERVADE_KEY);
$encryption_key = hash_hkdf(&#39;sha256&#39;, $ikm, 32, &#39;encryption&#39;);
$hmac_key = hash_hkdf(&#39;sha256&#39;, $ikm, 32, &#39;hmac&#39;);
</pre></div>


<h3>OpenSSL CSPRNG Check Infinite Loop</h3>



<p>If this code sets <code>$csprng_check</code> to <code>false</code>, you will DoS your own application.</p>


<div><pre title="">$iv = openssl_random_pseudo_bytes(openssl_cipher_iv_length(&#39;aes-256-cbc&#39;), $csprng_check);

while((strpos($iv, &#39;::&#39;) !== false) || !$csprng_check) {
    $iv = openssl_random_pseudo_bytes(openssl_cipher_iv_length(&#39;aes-256-cbc&#39;), $csprng_check);
</pre></div>


<p>The reason is subtle: <code>$csprng_check</code> is kind of a useless feature. It’s vestigal to OpenSSL’s <code>RAND_pseudo_bytes()</code> API. In PHP, if the value is ever set to <code>false</code>, it will continue to be <code>false</code> for the duration of the process.</p>



<p>It’s also a superfluous check: If OpenSSL’s RNG is insecure (i.e. the Debian weak key debacle), would you trust OpenSSL to be aware of its insecurity?</p>



<p><a href="https://www.php.net/random_bytes">You want <code>random_bytes()</code> here.</a> For PHP 5, <a href="https://github.com/paragonie/random_compat">paragonie/random_compat</a>.</p>



<p>With <code>random_bytes()</code>, if the RNG fails, an <code>Exception</code> will be thrown. This will fail closed and prevent the application from proceeding with insecure randomness.</p>



<h2>Summary</h2>



<p>The cryptography used by Police CyberAlarm is not secure and should be replaced with something more secure.</p>



<p>A much better implementation is ext/sodium (PHP 7.2+) or <a href="https://github.com/paragonie/sodium_compat">paragonie/sodium_compat</a> (PHP 5.2+) provides <a href="https://latacora.micro.blog/2018/04/03/cryptographic-right-answers.html">the NaCl/libsodium default</a> that other experts recommend. To get started, refer to <a href="https://paragonie.com/blog/2017/06/libsodium-quick-reference-quick-comparison-similar-functions-and-which-one-use">this Quick Reference page</a>.</p>



<p>Alternatively, <a href="https://github.com/defuse/php-encryption">defuse/php-encryption</a> supports PHP 5 and provides authenticated encryption.</p>
</div></div>
  </body>
</html>
