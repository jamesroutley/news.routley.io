<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.miguelgrinberg.com/post/microdot-yet-another-python-web-framework">Original</a>
    <h1>Microdot: Yet Another Python Web Framework</h1>
    
    <div id="readability-page-1" class="page"><div><p>I just realized that I have never written on this blog about <a href="https://github.com/miguelgrinberg/microdot">Microdot</a>, my very own web framework for Python. I have released Microdot 2.0 a few days ago, so I guess this is a good time to make a belated announcement, and tell you why this world needs yet another Python web framework.</p>
<p>But before I tell you about the reasons and the history of Microdot, let me share some of its features:</p>
<ul>
<li>Flask-like syntax, but without the magical/obscure parts (no application/request contexts)</li>
<li>Small enough to work with MicroPython, while also being compatible with CPython</li>
<li>Fully compatible with asyncio</li>
<li>Websocket support</li>
<li>Server-Sent Events (SSE) support</li>
<li>Templating support with Jinja (CPython) and uTemplate (MicroPython)</li>
<li>Cross-Origin Request Sharing (CORS) support</li>
<li>User sessions stored on cryptographically signed cookies</li>
<li>Uses its own minimal web server on MicroPython, and integrates with any ASGI or WSGI web servers on CPython</li>
<li>Included test client to use in unit tests</li>
</ul>
<p>Interested? Keep reading to learn more about Microdot.</p>
<h2>Why Microdot</h2>
<p>Back in 2019, I was working on a hardware project based on the ESP8266 microcontroller. For the software portion of this project I used <a href="https://micropython.org/">MicroPython</a>, an alternative implementation of the Python language that is designed for small devices.</p>
<p>I wanted to host a small web-based interface on the device, and to my surprise I could not find any usable web frameworks. Things such as Flask or Bottle do not work under MicroPython because they are too big for it. The only MicroPython web framework I could find was one called &#34;picoweb&#34;, which required an unofficial fork of the MicroPython language, which to me was a deal breaker.</p>
<p>Microdot was born out of needing to have a web framework that was as close as possible to Flask, but designed to run on an official and actively maintained version of MicroPython.</p>
<p>I ended up creating Microdot, and used it to complete my project. I also put the source code on GitHub, since it was obvious to me that there was a hole in the MicroPython ecosystem in terms of web frameworks. While it has received growing attention from hardware inclined developers, it managed to stay below the radar for a lot of people in the Python community for almost 5 years now. Here is a timeline of the major events in Microdot&#39;s history:</p>
<table>
<thead>
<tr>
<th>Date</th>
<th>Event</th>
</tr>
</thead>
<tbody>
<tr>
<td>April 2019</td>
<td>Microdot 0.1, first public release</td>
</tr>
<tr>
<td>August 2022</td>
<td>Microdot 1.0, with a synchronous base implementation and an asyncio extension</td>
</tr>
<tr>
<td>December 2023</td>
<td>Microdot 2.0, redesigned as 100% asynchronous</td>
</tr>
</tbody>
</table>
<h2>How Does Microdot Code Look Like?</h2>
<p>Microdot is actually very similar to Flask. You write web routes as decorated functions:</p>
<pre><code>from microdot import Microdot

app = Microdot()

@app.get(&#39;/&#39;)
async def index(request):
    return {&#39;hello&#39;: &#39;world&#39;}

app.run(debug=True)
</code></pre>
<p>The <code>@app.get</code> decorator is used to define GET requests. There are similar decorators for POST, PATCH, PUT and DELETE. Like Flask, Microdot handles OPTIONS and HEAD requests automatically.</p>
<p>Microdot 2 is asynchronous, so it is best to write handler functions as <code>async def</code> functions. Under CPython, regular <code>def</code> functions execute in a thread executor (like FastAPI), but most hardware devices that run MicroPython lack threading support, so regular functions on that platform just block for as long as they run.</p>
<p>One aspect in Flask that I do not like is the use of application and request contexts, as these add an unnecessary layer of complexity. I did not want to have that, so request handler functions in Microdot just receive a request object as a first positional argument.</p>
<p>As with Flask, the return value from a handler function is the response, and Microdot automatically formats the response as JSON if a dictionary is returned. It also supports second and third returned values for custom status code and headers. Microdot also copies the way streamed responses work in Flask with the use of generators, and also supports asynchronous generators.</p>
<p>I like the functionality offered by Blueprints in Flask, but here once again I feel Flask makes everything too complicated. In Microdot, you can create multiple application instances and use the <code>mount()</code> method to combine them:</p>
<pre><code>api = Microdot()

@api.get(&#39;/users&#39;)
async def get_users():
    pass

main_app = Microdot()
main_app.mount(api, url_prefix=&#39;/api&#39;)  # /api/users route is added to main_app
</code></pre>
<p>Microdot has native support for WebSocket and Server-Sent Events. Here are example endpoints that use these features:</p>
<pre><code>from microdot.websocket import with_websocket
from microdot.sse import with_sse

@app.route(&#39;/echo&#39;)
@with_websocket
async def echo(request, ws):
    while True:
        data = await ws.receive()
        await ws.send(data)

@app.route(&#39;/events&#39;)
@with_sse
async def events(request, sse):
    for i in range(10):
        await asyncio.sleep(1)
        await sse.send({&#39;counter&#39;: i})
</code></pre>
<p>Hopefully there is nothing mysterious or magical in this code and you can understand it fully just from reading it.</p>
<p>If you want to render HTML templates, Microdot can use Jinja or uTemplate, the latter being the main (only?) templating library available for MicroPython. Templates can be rendered synchronously (blocking the asyncio loop) or asynchronously. For larger templates it is best to use the async interface as that improves concurrency. Templates can also be streamed as regular or asynchronous generators, one more way to improve performance and concurrency.</p>
<p>User sessions are implemented in a way that is also similar to Flask, but I decided to write user sessions as <a href="https://en.wikipedia.org/wiki/JSON_Web_Token">JWTs</a>, which are fairly easy to <a href="https://jwt.io/">debug</a>.</p>
<p>If you want to learn more about Microdot&#39;s features, I have written <a href="https://microdot.readthedocs.io/en/stable/">documentation</a> for it. I also offer a nice collection of <a href="https://github.com/miguelgrinberg/microdot/tree/main/examples">examples</a> in the GitHub repository.</p>
<h2>How Small is Microdot?</h2>
<p>This is not a straightforward question to answer, because unlike Flask, FastAPI and most other frameworks, Microdot has a modular structure, so there are a number of different configurations that can be measured depending on what features are used. When working with CPython this is not very important, but for MicroPython projects running on microcontrollers it is useful to be able to pick and choose exactly what you need and drop the parts that you don&#39;t.</p>
<p>The core Microdot framework comes in a single <em>microdot.py</em> Python source file. Below I used the <a href="https://github.com/AlDanial/cloc">cloc</a> utility to count how many lines of code the current version of this file has:</p>
<table>
<thead>
<tr>
<th></th>
<th>files</th>
<th>blank</th>
<th>comment</th>
<th>code</th>
</tr>
</thead>
<tbody>
<tr>
<td>Microdot 2.0.1 (minimal)</td>
<td>1</td>
<td>216</td>
<td>456</td>
<td>728</td>
</tr>
</tbody>
</table>
<p>Next I calculated the full Microdot configuration for the same version, including all of its features:</p>
<table>
<thead>
<tr>
<th></th>
<th>files</th>
<th>blank</th>
<th>comment</th>
<th>code</th>
</tr>
</thead>
<tbody>
<tr>
<td>Microdot 2.0.1 (full)</td>
<td>11</td>
<td>435</td>
<td>759</td>
<td>1577</td>
</tr>
</tbody>
</table>
<p>Just so that you have an idea of how small this is, let&#39;s see how big Flask and FastAPI are. To make this a more consistent comparison, I&#39;ve included Werkzeug with Flask, and Starlette with FastAPI.</p>
<table>
<thead>
<tr>
<th></th>
<th>files</th>
<th>blank</th>
<th>comment</th>
<th>code</th>
</tr>
</thead>
<tbody>
<tr>
<td>Flask 3.0.0</td>
<td>24</td>
<td>1775</td>
<td>3211</td>
<td>3854</td>
</tr>
<tr>
<td>Werkzeug 3.0.1</td>
<td>59</td>
<td>4043</td>
<td>5634</td>
<td>11704</td>
</tr>
<tr>
<td>Total</td>
<td>83</td>
<td>5818</td>
<td>8845</td>
<td>15558</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th></th>
<th>files</th>
<th>blank</th>
<th>comment</th>
<th>code</th>
</tr>
</thead>
<tbody>
<tr>
<td>FastAPI 0.106.0</td>
<td>40</td>
<td>2052</td>
<td>5884</td>
<td>9839</td>
</tr>
<tr>
<td>Starlette 0.27.0</td>
<td>34</td>
<td>1008</td>
<td>477</td>
<td>4969</td>
</tr>
<tr>
<td>Total</td>
<td>74</td>
<td>3060</td>
<td>6361</td>
<td>14808</td>
</tr>
</tbody>
</table>
<p>From this you can see that both Flask and FastAPI, when combined with their main supporting dependency have about 15K lines of code each, while Microdot has 1.5K or roughly 10% of the size of its bigger competitors (or 5% if you only need basic web routing features).</p>
<p>Since I&#39;m counting Werkzeug and Starlette as part of Flask and FastAPI respectively, you may be curious about what third-party dependencies Microdot relies on, and if there are any big ones. The single-file minimal version does not require any dependencies at all, and it even includes its own web server. Some of the optional features do require third-party dependencies, and this is comparable to the larger frameworks. Like Flask, you will need to add a templating library (Jinja or uTemplate) to use templates. For user sessions, Microdot relies on PyJWT, while Flask uses its own Itsdangerous package.</p>
<h2>Should I Switch to Microdot?</h2>
<p>For a MicroPython project I think Microdot is a great framework to use, even though there are now a couple others that did not exist back in 2019.</p>
<p>If you are using CPython you are certainly welcome to switch if you want to, but my recommendation would be to stay with your current web framework if you are happy with it. A good reason to switch would be if you want to make better use of your server&#39;s resources. It&#39;s really hard to make predictions, but depending on the project you may be able to fit an extra web server worker or two on the same hardware, just from RAM savings after switching from a larger framework to Microdot. But as I said, I wouldn&#39;t go through the pain of a migration unless size is very important to you.</p>
<p>What I would like to ask is that you keep Microdot in mind for when you start a new project. If you end up using it, I would like to know how it works for you, so please reach out!</p></div></div>
  </body>
</html>
