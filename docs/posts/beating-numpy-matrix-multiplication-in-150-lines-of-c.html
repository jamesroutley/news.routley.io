<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://salykova.github.io/matmul-cpu">Original</a>
    <h1>Beating NumPy matrix multiplication in 150 lines of C</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p><strong>TL;DR</strong>
The code from the tutorial is available at <a href="https://github.com/salykova/matmul.c">matmul.c</a>. This blog post is the result of my attempt to implement high-performance matrix multiplication on CPU while keeping the code simple, portable and scalable. The implementation follows the <a href="https://en.wikipedia.org/wiki/BLIS_(software)">BLIS</a> design, works for arbitrary matrix sizes, and, when fine-tuned for an AMD Ryzen 7700 (8 cores), outperforms NumPy (=<a href="https://en.wikipedia.org/wiki/OpenBLAS">OpenBLAS</a>), achieving over 1 TFLOPS of peak performance across a wide range of matrix sizes.
<img src="https://salykova.github.io/assets/matmul_cpu/benchmark_mt.png" alt="" width="90%"/></p>

<p>By efficiently parallelizing the code with <strong>just 3 lines of OpenMP directives</strong>, it’s both scalable and easy to understand. The implementation hasn’t been tested on other CPUs, so I would appreciate feedback on its performance on your hardware. Although the code is portable and targets Intel Core and AMD Zen CPUs with FMA3 and AVX instructions (i.e., all modern Intel Core and AMD Zen CPUs), please don’t expect peak performance without fine-tuning the hyperparameters, such as <em>the number of threads, kernel, and block sizes</em>, unless you are running it on a Ryzen 7700(X). Additionally, on some Intel CPUs, the OpenBLAS implementation might be notably faster due to AVX-512 instructions, which were intentionally omitted here to support a broader range of processors. Throughout this tutorial, we’ll implement matrix multiplication from scratch, learning how to optimize and parallelize C code using matrix multiplication as an example. This is my first time writing a blog post. If you enjoy it, please subscribe and share it! I would be happy to hear feedback from all of you. This is the first part of my planned two-part blog series. In the second part, we will learn how to optimize matrix multiplication on GPUs. Stay tuned!</p>

<h2 id="intro">Intro</h2>

<p>Matrix multiplication is an essential part of nearly all modern neural networks. For example, most of the time spent during inference in <a href="https://en.wikipedia.org/wiki/Transformer_(deep_learning_architecture)">Transformers</a>  is actually taken up by matrix multiplications. Despite using matmul daily in PyTorch, NumPy, or JAX, I’ve never really thought about how it is designed and implemented to maximize hardware efficiency. To achieve such speeds, NumPy, for instance, relies on external <a href="https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms">BLAS</a> (Basic Linear Algebra Subprograms) libraries. These libraries implement highly optimized common linear algebra operations such as dot product, matrix multiplication, vector addition, and scalar multiplication. Examples of BLAS implementations include:</p>

<ol>
  <li><a href="https://en.wikipedia.org/wiki/Math_Kernel_Library">Intel MKL</a> - optimized for Intel CPUs</li>
  <li><a href="https://developer.apple.com/documentation/accelerate">Accelerate</a> - optimized for Apple CPUs</li>
  <li><a href="https://en.wikipedia.org/wiki/BLIS_(software)">BLIS</a> - open-source, multi-vendor support</li>
  <li><a href="https://en.wikipedia.org/wiki/GotoBLAS">GotoBLAS</a> - open-source, multi-vendor support</li>
  <li><a href="https://en.wikipedia.org/wiki/OpenBLAS">OpenBLAS</a> - open-source, based on GotoBLAS</li>
  <li>etc.</li>
</ol>

<p>If you look at the OpenBLAS  <a href="https://github.com/OpenMathLib/OpenBLAS/blob/develop/kernel/x86_64/sgemm_kernel_8x4_haswell.c">code</a>, you’ll notice it’s a mix of C and low-level assembly code. In fact, OpenBLAS, GotoBLAS, and BLIS are all written in C/FORTRAN/Assembly and contain matmul implementations handcrafted for different CPU types. During runtime, the appropriate function is called depending on the detected CPU device. I challenged myself and asked if it is possible to write a high-performance matmul (across a wide range of matrix sizes) without diving deep into Assembly and Fortran code, at least for my CPU. After some searching on the internet, I found a couple of exciting and educational step-by-step tutorials on how to implement fast matmul from scratch, covering both theoretical and practical aspects:</p>

<ol>
  <li><a href="https://siboehm.com/articles/22/Fast-MMM-on-CPU">Fast Multidimensional Matrix Multiplication on CPU from Scratch</a> by Simon Boehm.</li>
  <li><a href="https://en.algorithmica.org/hpc/algorithms/matmul/">Matrix Multiplication</a> by Sergey Slotin.</li>
  <li><a href="https://en.wikipedia.org/wiki/George_Hotz">Geohot’s</a> famous stream <a href="https://www.youtube.com/watch?v=VgSQ1GOC86s">Can you multiply a matrix?</a></li>
</ol>

<p>I highly recommend checking out these well-written and well-spoken tutorials with alternative matmul implementations. They helped me better understand the topic and, in some sense, motivated me to write a different implementation. Why? The reason is that all three solutions above work only for specific matrix sizes and do not achieve NumPy’s multi-threaded speed (except for Geohot’s implementation, which is comparable to NumPy in terms of speed but again works only for specific matrix sizes and requires an extra <a href="https://github.com/tinygrad/tinygrad/blob/master/extra/gemm/gemm.c#L130">preswizzle</a> step, resulting in a full copy of one of the input matrices). So, I wasn’t satisfied with the results and continued researching until I stumbled across two fascinating papers: “<a href="https://www.cs.utexas.edu/~flame/pubs/GotoTOMS_final.pdf">Anatomy of High-Performance Matrix Multiplication</a>” and “<a href="https://www.cs.utexas.edu/~flame/pubs/blis3_ipdps14.pdf">Anatomy of High-Performance Many-Threaded Matrix Multiplication</a>”. The former presents the BLAS implementation known as GotoBLAS, developed by <a href="https://en.wikipedia.org/wiki/Kazushige_Goto">Kazushige Goto</a>. The latter briefly reviews the design of matmul op used in BLIS (an extended version of GotoBLAS) and discusses different parallelization possibilities for the matmul algorithm. After reading these papers I felt that the BLIS matmul design could potentially achieve all my goals:</p>

<ul>
  <li>NumPy-like multi-threading performance across a broad range of matrix sizes</li>
  <li>Simple, portable and scalable C code</li>
  <li>Support for a wide variety of processors</li>
</ul>

<p>In the next sections, we will implement the algorithm from the paper and compare it against NumPy.</p>

<h2 id="numpy-performance">NumPy Performance</h2>

<p>By default, if installed via <code>pip</code>, numpy uses OpenBLAS on AMD CPUs. Therefore, throughout this tutorial I will use numpy and OpenBLAS interchangeably. Before performing any benchmarks, it’s always good practice to specify your hardware specs and development environment to ensure the results can be reproduced:</p>
<ul>
  <li>CPU: Ryzen 7 7700 8 Cores, 16 Threads
    <ul>
      <li>Freq: 3.8 GHz</li>
      <li>Turbo Freq: 5.3 GHz</li>
      <li>L1 Cache: 64 KB (per core)</li>
      <li>L2 Cache: 1MB (per core)</li>
      <li>L3 Cache: 32MB (shared), 16-way associative</li>
    </ul>
  </li>
  <li>RAM: 32GB DDR5 6000 MHz CL36</li>
  <li>Numpy 1.26.4</li>
  <li>Compiler: clang-17</li>
  <li>Compiler flags: <code>-O2 -mno-avx512f -march=native</code></li>
  <li>OS: Ubuntu 22.04.4 LTS</li>
</ul>

<p>To multiply two <code>float32</code> matrices A of shape \(M \times K\) and B of shape \(K \times N\), for each element of the resulting matrix C of shape \(M \times N\), we need to calculate the dot product between a row of A and a column of B. This results in \(K\) (additions) + \(K\) (multiplications) = \(2K\) FLoating Point Operations (FLOP) per element of matrix C or \(2KMN\) FLOP in total.</p>

<p><img src="https://salykova.github.io/assets/matmul_cpu/matmul_naive.png" alt=""/></p>

<p>We will measure performance in terms of FLOP per second FLOP/s=FLOPS. In Python, this can be simply done as follows:</p>
<div><div><pre><code><span>import</span> <span>numpy</span> <span>as</span> <span>np</span>
<span>import</span> <span>time</span>

<span>A</span> <span>=</span> <span>np</span><span>.</span><span>random</span><span>.</span><span>randn</span><span>(</span><span>M</span><span>,</span> <span>K</span><span>).</span><span>astype</span><span>(</span><span>np</span><span>.</span><span>float32</span><span>)</span>
<span>B</span> <span>=</span> <span>np</span><span>.</span><span>random</span><span>.</span><span>randn</span><span>(</span><span>K</span><span>,</span> <span>N</span><span>).</span><span>astype</span><span>(</span><span>np</span><span>.</span><span>float32</span><span>)</span>
<span>FLOP</span> <span>=</span> <span>2</span><span>*</span><span>K</span><span>*</span><span>M</span><span>*</span><span>N</span>

<span>start</span> <span>=</span> <span>time</span><span>.</span><span>perf_counter</span><span>()</span>
<span>C</span> <span>=</span> <span>A</span> <span>@</span> <span>B</span>
<span>end</span> <span>=</span> <span>time</span><span>.</span><span>perf_counter</span><span>()</span>
<span>exec_time</span> <span>=</span> <span>end</span> <span>-</span> <span>start</span>
<span>FLOPS</span> <span>=</span> <span>FLOP</span><span>/</span><span>exec_time</span>
<span>GFLOPS</span> <span>=</span> <span>FLOPS</span><span>/</span><span>1e9</span>
</code></pre></div></div>

<blockquote>
  <p><strong>Important!</strong> When benchmarking code, try to minimize the number of running tasks, especially when measuring multi-threaded code. Results obtained on Windows are usually lower than on Linux.</p>
</blockquote>

<p>To benchmark numpy’s matmul, we will use <code>benchmark_numpy.py</code>, which executes the code snippet above for different matrix sizes in a loop and measures peak/average FLOPS. By default, numpy will use all available cores; however, we can easily change this by setting environment variables before importing numpy and matplotlib</p>
<div><div><pre><code><span>os</span><span>.</span><span>environ</span><span>[</span><span>&#34;OPENBLAS_NUM_THREADS&#34;</span><span>]</span> <span>=</span> <span>&#34;1&#34;</span>
<span>os</span><span>.</span><span>environ</span><span>[</span><span>&#34;MKL_NUM_THREADS&#34;</span><span>]</span> <span>=</span> <span>&#34;1&#34;</span>
<span>os</span><span>.</span><span>environ</span><span>[</span><span>&#34;OMP_NUM_THREADS&#34;</span><span>]</span> <span>=</span> <span>&#34;1&#34;</span>
<span>import</span> <span>numpy</span> <span>as</span> <span>np</span>
<span>import</span> <span>matplotlib.pyplot</span> <span>as</span> <span>plt</span>
</code></pre></div></div>

<p>To measure Numpy’s matmul performance, run</p>
<div><div><pre><code>python benchmark_numpy.py <span>-NITER</span><span>=</span>200 <span>-ST</span> <span>-SAVEFIG</span>
</code></pre></div></div>
<p>for single-threaded benchmark and</p>
<div><div><pre><code>python benchmark_numpy.py <span>-NITER</span><span>=</span>500 <span>-SAVEFIG</span>
</code></pre></div></div>
<p>for multi-threaded benchmark.</p>

<p>On my machine I got the following results:</p>

<p><img src="https://salykova.github.io/assets/matmul_cpu/benchmark_np_mt.png" alt="" width="90%"/></p>

<p><img src="https://salykova.github.io/assets/matmul_cpu/benchmark_np_st.png" alt="" width="90%"/></p>

<p>How close are we to the theoretical upper limit achievable on the CPU?</p>

<h2 id="theoretical-limit">Theoretical Limit</h2>

<p>Recall the computer’s memory hierarchy (for now, ignore the layers between registers and RAM; we will discuss them later).</p>

<p><img src="https://salykova.github.io/assets/matmul_cpu/cpu_mem_no_cache.png" alt="" width="70%"/></p>

<p>To perform arithmetic operations on data stored in RAM (off-chip memory, slow and large), the data must first be transferred to the CPU and eventually stored in CPU registers (on-chip memory, fast and small). Modern x86 CPUs support SIMD (Single Instruction Multiple Data) extensions, which allow multiple pieces of data to be processed in parallel. There are various SIMD extensions, but the ones relevant to our discussion are <a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions">Advanced Vector Extensions</a> (AVX) and <a href="https://en.wikipedia.org/wiki/FMA_instruction_set">Fused Multiply-Add</a> (FMA). Both AVX and FMA operate on data stored in special 256-bit YMM registers. Each YMM register can hold up to 256/32 = 8 packed single-precision (32-bit) floats. The FMA extension allows a multiply-add operation to be performed in one step on data stored in YMM registers. The corresponding assembly instruction is called <code>VFMADD213PS</code> (PS stands for PackedSingle) and takes three registers (<code>YMM1</code>, <code>YMM2</code>, <code>YMM3</code>) as input to calculate <code>YMM1 * YMM2 + YMM3</code> and store the result in <code>YMM3</code>, hence the “213” (there are also <code>vfmadd132ps</code>, <code>vfmadd231ps</code> variants).</p>

<p><img src="https://salykova.github.io/assets/matmul_cpu/fmadd.png" alt=""/></p>

<p>According to the <a href="https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html">intel intrinsics guide</a> or <a href="https://uops.info/table.html">https://uops.info/table.html</a>, the throughput (TP) of fused-multiply-add is 0.5 cycles/instruction or 2 instructions/cycle:
<img src="https://salykova.github.io/assets/matmul_cpu/fmadd_uops.png" alt=""/></p>

<p>Theoretically, the CPU can execute 32 FLOP per cycle = 8 (floats in YMM register) * 2 (add + mul) * 2 (1/TP). On my machine, the CPU boosts up to 5.1 GHz in single-threaded tasks and up to 4.7 GHz in multi-threaded tasks. Therefore, a rough estimation of the maximum achievable FLOPS can be calculated as 5.1GHz * 32 FLOP/cycle = <strong>163 GFLOPS</strong> for single-threaded matmul and 4.7GHz * 32 FLOP/cycle * 8 cores = <strong>1203 GFLOPS</strong> for multi-threaded matmul. Starting from \(M=N=K=1000\), numpy reaches on average 92% of the theoretical maximum single-threaded performance and 85% of the multi-threaded. Can we compete with NumPy using plain C code without thousands of lines of low-level assembly code?</p>

<h2 id="naive-implementation">Naive Implementation</h2>

<p>Without loss of generality in this implementation we will assume that matrices stored in column-major order. A matrix <code>A</code> of shape <code>MxN</code> is stored as contiguous array of length <code>M*N</code> and an element <code>A[row][col]</code> is accessed via C raw pointer <code>ptr[col*M + row]</code>, where <code>0 &lt;= col &lt;= N-1</code> and <code>0 &lt;= row &lt;= M-1</code>.
<img src="https://salykova.github.io/assets/matmul_cpu/mem_layout.png" alt="" width="80%"/></p>

<p>The naive implementation
<img src="https://salykova.github.io/assets/matmul_cpu/matmul_naive.png" alt=""/></p>

<p>can be implemented as follows:</p>
<div><div><pre><code><span>void</span> <span>matmul_naive</span><span>(</span><span>float</span><span>*</span> <span>A</span><span>,</span> <span>float</span><span>*</span> <span>B</span><span>,</span> <span>float</span><span>*</span> <span>C</span><span>,</span> <span>const</span> <span>int</span> <span>M</span><span>,</span> <span>const</span> <span>int</span> <span>N</span><span>,</span> <span>const</span> <span>int</span> <span>K</span><span>)</span> <span>{</span>
  <span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>M</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>int</span> <span>j</span> <span>=</span> <span>0</span><span>;</span> <span>j</span> <span>&lt;</span> <span>N</span><span>;</span> <span>j</span><span>++</span><span>)</span> <span>{</span>
      <span>for</span> <span>(</span><span>int</span> <span>p</span> <span>=</span> <span>0</span><span>;</span> <span>p</span> <span>&lt;</span> <span>K</span><span>;</span> <span>p</span><span>++</span><span>)</span> <span>{</span>
        <span>C</span><span>[</span><span>j</span> <span>*</span> <span>M</span> <span>+</span> <span>i</span><span>]</span> <span>+=</span> <span>A</span><span>[</span><span>p</span> <span>*</span> <span>M</span> <span>+</span> <span>i</span><span>]</span> <span>*</span> <span>B</span><span>[</span><span>j</span> <span>*</span> <span>K</span> <span>+</span> <span>p</span><span>];</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre></div></div>
<p>We iterate over all rows (first loop) and all columns (second loop) of the matrix <code>C</code> and for each element of <code>C</code> we calculate the dot product (third loop) between the corresponding rows and columns of matrices <code>A</code> and <code>B</code>. It’s always good to start with simple and robust implementation that can later be used to test optimized implementations for correctness. The file <code>matmul_nave.c</code> contains this implementation.</p>

<p>Running the naive implementation</p>
<div><div><pre><code>clang-17 <span>-O2</span> <span>-mno-avx512f</span> <span>-march</span><span>=</span>native matmul_naive.c <span>-o</span> matmul_naive.out <span>&amp;&amp;</span> ./matmul_naive.out
</code></pre></div></div>
<p>results in 2.7 GFLOPS on my machine. Nowhere near our target of 1 TFLOPS.</p>

<h2 id="kernel">Kernel</h2>

<p>Matrix multiplication $C=AB$ can be decomposed into smaller sub-problems. The idea now is that if the smaller sub-problems can be solved quickly, then the entire matmul will be fast. We first partition the matrix $C$ of shape $M \times N$ into small sub-matrices of shape $m_R \times n_R$,  where $n_R \ll N$ and $m_R \ll M$. To calculate $C=AB$, we iterate over $C$ and compute each of its $m_R \times n_R$ sub-matrices.
<img src="https://salykova.github.io/assets/matmul_cpu/matmul_kernel.png" alt=""/></p>

<p>The function that calculates these tiny $m_R \times n_R$ sub-matrices $\bar{C}$ of $C$ is called a <strong>kernel</strong> or <strong>micro-kernel</strong>. This is the heart of high-performance matrix multiplication. When we say that a matmul algorithm is optimized for a particular CPU architecture, it often involves kernel optimization. For example, in the BLIS library, the kernels optimized for different processor types can be found under <a href="https://github.com/flame/blis/tree/master/kernels">kernels</a>.</p>

<p>Let’s take a closer look at the kernel.
<img src="https://salykova.github.io/assets/matmul_cpu/kernel.png" alt=""/></p>

<p>To calculate a $m_R \times n_R$ sub-matrix $\bar{C}$ of matrix $C$, we multiply matrix $\bar{A}$ of size $m_R \times K$ and matrix $\bar{B}$ of size $K \times n_R$. If we do this in a naive manner using dot products, we would need to fetch $2K$ (=dot product) elements from RAM to calculate a single element of $\bar{C}$ or $2K m_R n_R$ elements in total to calculate $\bar{C}$. However, there is an alternative strategy that can reduce the number of fetched elements.</p>

<p>We first load matrix $\bar{C}$ into SIMD (=YMM) registers (note that we can do this because both $n_R$ and $m_R$ are small). The subscript $R$ in $n_R$ and $m_R$ stands for “registers”. Then we iterate over $K$ and in each iteration we load 1 column of $\bar{A}$ and 1 row of $\bar{B}$ into YMM registers (again, note that both the row and the column vectors are small and fit in the registers). Finally, we perform matrix multiplication between the column and the row vectors to update the matrix $\bar{C}$. After $K$ iterations (=rank-1 updates), the matrix $\bar{C}$ is fully computed.
<img src="https://salykova.github.io/assets/matmul_cpu/kernel_rank.png" alt=""/></p>

<blockquote>
  <p>Example of matrix multiplication between a column and a row vector. Each column of the resulting matrix is computed by multiplying vector $\mathbf{u}$ with a scalar element of the row vector.
<img src="https://salykova.github.io/assets/matmul_cpu/outer_product.png" alt=""/></p>
</blockquote>

<p>Overall we fetched $(m_R + n_R)K + m_R n_R \approx (m_R + n_R)K$  elements into registers. Compared to the naive strategy, we reduced the number by a factor of</p><p>

\[\frac{2m_Rn_RK}{(m_R + n_R)K} = \frac{2m_Rn_R}{m_R + n_R}\]

</p><p>The factor is maximized when both $m_R$, $n_R$ are large and $m_R = n_R$. The values $m_R$ and $n_R$ are usually limited by the available memory in the registers.</p>

<p>Now, let’s explore how a rank-1 update can be implemented using SIMD instructions. Each rank-1 update is a matrix multiplication between a column of $\bar{A}$ and a row of $\bar{B}$. Note how individual column of $\bar{C}$ is updated via scalar-vector multiplication between a column of $\bar{A}$ and a corresponding scalar element of a row of $\bar{B}$. Thanks to the FMA extension, the update + scalar-vector multiplication can be efficiently calculated via a fused multiply-add instruction. Before executing the FMA instruction, we only need to broadcast the scalar element of the row of $\bar{B}$ to a vector and load it into a YMM register. The parameter $m_R$ determines how many elements are stored in column vectors of $\bar{C}, \bar{A}$ and how many YMM registers we need for this. Since each YMM register can store up to 8 floats, we assume that $m_R$ is a multiple of 8 (8, 16, 24, 32…) and the elements in column vectors are packed into blocks of size 8. Then the number of YMM registers required to store the column vectors can be calculated as $m_R$ / 8. Note that we don’t need additional YMM registers for the broadcasted column vector of $\bar{B}$ since the same 8-float vector (YMM Register) can be reused to update all 8-float blocks of the column vector of $\bar{C}$.</p>

<p><img src="https://salykova.github.io/assets/matmul_cpu/kernel_registers.png" alt="" width="80%"/></p>

<p>Thus, the complete algorithm for a single rank-1 update of the matrix $\bar{C}$ is as follows:</p>
<ol>
  <li>Load matrix $\bar{C}$ into YMM registers</li>
  <li>Load the column vector of matrix $\bar{A}$</li>
  <li>Set n = 1</li>
  <li>Load the n-th scalar element of the row of $\bar{B}$, broadcast it to a vector and place it into YMM register.</li>
  <li>Update the n-th column of $\bar{C}$ via fused matrix multiply</li>
  <li>Increment n by 1.</li>
  <li>Repeat steps 4-6 until all columns of $\bar{C}$ are updated.</li>
</ol>

<p>The last thing we need to discuss before implementing the kernel in C is how to choose the kernel size = $m_R$ and $n_R$. CPUs that support AVX instructions have <strong>16 YMM registers</strong>. From our previous observations, we know that we need $n_R m_R / 8$ registers to store the matrix $\bar{C}$, $m_R/8$ registers to store the column vector of $\bar{A}$ and 1 register for the broadcasted vector of $\bar{B}$. We want $m_R, n_R$ as large as possible and satisfying  the following conditions</p>

<ul>
  <li>$n_R m_R/8 + m_R/8 + 1 &lt;= 16$</li>
  <li>$m_R$ is a multiple of 8</li>
</ul>

<p>In theory we also want $m_R \approx n_R$ to minimize the number of fetched elements. However, in practice, I’ve found out that the non-square $m_R \times n_R= 16 \times 6$ kernel shows the best results on my machine. You are free to try out different kernel sizes, for example, $8 \times 12$, $8 \times 13$, $8 \times 14$ and compare the performance on your CPU.</p>

<p>Let’s implement the $16 \times 6$ kernel in C. The code can be found in <code>matmul_kernel.c</code>. To use the SIMD instructions we need to include the <code>immintin.h</code> library.</p>


<p>the kernel function is declared as follows:</p>
<div><div><pre><code><span>void</span> <span>kernel_16x6</span><span>(</span><span>float</span><span>*</span> <span>A</span><span>,</span> <span>float</span><span>*</span> <span>B</span><span>,</span> <span>float</span><span>*</span> <span>C</span><span>,</span> <span>const</span> <span>int</span> <span>M</span><span>,</span> <span>const</span> <span>int</span> <span>N</span><span>,</span> <span>const</span> <span>int</span> <span>K</span><span>);</span>
</code></pre></div></div>
<p>The function takes as input 3 matrices + their dimensions and calculates a $16\times6$ sub-matrix $\bar{C}$ of $C$. Inside the function, first, declare the variables that reside in YMM registers:</p>
<div><div><pre><code><span>__m256</span> <span>C_buffer</span><span>[</span><span>2</span><span>][</span><span>6</span><span>];</span>
<span>__m256</span> <span>b_packFloat8</span><span>;</span>
<span>__m256</span> <span>a0_packFloat8</span><span>;</span>
<span>__m256</span> <span>a1_packFloat8</span><span>;</span>
</code></pre></div></div>
<p>The <code>__m256</code> datatype is a vector of 8 floats (8x32 = 256 bits) that resides in YMM register. <code>C_buffer</code> is a 16x6 sub-matrix of $C$ stored in YMM registers. The first dimension of <code>C_buffer</code> is <code>2</code>, because we need <code>16/8=2</code> registers to store 16 elements. <code>b_packFloat8</code>, <code>a0_packFloat8</code>, <code>a1_packFloat8</code> are column vectors of $\bar{B}$ and $\bar{A}$. Again, we need two vectors to store 16 elements of the column vector of $\bar{A}$.</p>

<p>Next, we load the sub-matrix $\bar{C}$ into YMM registers:</p>
<div><div><pre><code><span>for</span> <span>(</span><span>int</span> <span>j</span> <span>=</span> <span>0</span><span>;</span> <span>j</span> <span>&lt;</span> <span>6</span><span>;</span> <span>j</span><span>++</span><span>)</span> <span>{</span>
  <span>C_buffer</span><span>[</span><span>0</span><span>][</span><span>j</span><span>]</span> <span>=</span> <span>_mm256_loadu_ps</span><span>(</span><span>&amp;</span><span>C</span><span>[</span><span>j</span> <span>*</span> <span>M</span><span>]);</span>
  <span>C_buffer</span><span>[</span><span>1</span><span>][</span><span>j</span><span>]</span> <span>=</span> <span>_mm256_loadu_ps</span><span>(</span><span>&amp;</span><span>C</span><span>[</span><span>j</span> <span>*</span> <span>M</span> <span>+</span> <span>8</span><span>]);</span>
<span>}</span>
</code></pre></div></div>
<p>SIMD C functions are well documented and can be found in the <a href="https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html">Intel Intrinsics Guide</a>. For example, <a href="https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm256_loadu_ps&amp;ig_expand=4100">_mm256_loadu_ps</a></p>

<p><img src="https://salykova.github.io/assets/matmul_cpu/intel_intrin.png" alt=""/></p>

<p>In the next step, we iterate over <code>K</code> and, in each iteration, load a column vector of $\bar{A}$, broadcast a scalar value of $\bar{B}$ to a vector, and perform a fused multiply-add operation to update 1 column of <code>C_buffer</code>:</p>
<div><div><pre><code><span>for</span> <span>(</span><span>int</span> <span>p</span> <span>=</span> <span>0</span><span>;</span> <span>p</span> <span>&lt;</span> <span>K</span><span>;</span> <span>p</span><span>++</span><span>)</span> <span>{</span>
  <span>a0_packFloat8</span> <span>=</span> <span>_mm256_loadu_ps</span><span>(</span><span>&amp;</span><span>A</span><span>[</span><span>p</span> <span>*</span> <span>M</span><span>]);</span>
  <span>a1_packFloat8</span> <span>=</span> <span>_mm256_loadu_ps</span><span>(</span><span>&amp;</span><span>A</span><span>[</span><span>p</span> <span>*</span> <span>M</span> <span>+</span> <span>8</span><span>]);</span>
  <span>b_packFloat8</span> <span>=</span> <span>_mm256_broadcast_ss</span><span>(</span><span>&amp;</span><span>B</span><span>[</span><span>p</span><span>]);</span>
  <span>C_buffer</span><span>[</span><span>0</span><span>][</span><span>0</span><span>]</span> <span>=</span> <span>_mm256_fmadd_ps</span><span>(</span><span>a0_packFloat8</span><span>,</span> <span>b_packFloat8</span><span>,</span> <span>C_buffer</span><span>[</span><span>0</span><span>][</span><span>0</span><span>]);</span>
  <span>C_buffer</span><span>[</span><span>1</span><span>][</span><span>0</span><span>]</span> <span>=</span> <span>_mm256_fmadd_ps</span><span>(</span><span>a1_packFloat8</span><span>,</span> <span>b_packFloat8</span><span>,</span> <span>C_buffer</span><span>[</span><span>1</span><span>][</span><span>0</span><span>]);</span>
  <span>...</span>
<span>}</span>
</code></pre></div></div>
<p>Then repeat the step for the remaining 5 columns. We manually unroll the loop when updating 6 columns of <code>C_buffer</code> so that <code>clang</code> can optimize the code.</p>

<p>Finally, we write the sub-matrix <code>C_buffer</code> back to <code>C</code>:</p>
<div><div><pre><code><span>for</span> <span>(</span><span>int</span> <span>j</span> <span>=</span> <span>0</span><span>;</span> <span>j</span> <span>&lt;</span> <span>6</span><span>;</span> <span>j</span><span>++</span><span>)</span> <span>{</span>
  <span>_mm256_storeu_ps</span><span>(</span><span>&amp;</span><span>C</span><span>[</span><span>j</span> <span>*</span> <span>M</span><span>],</span> <span>C_buffer</span><span>[</span><span>0</span><span>][</span><span>j</span><span>]);</span>
  <span>_mm256_storeu_ps</span><span>(</span><span>&amp;</span><span>C</span><span>[</span><span>j</span> <span>*</span> <span>M</span> <span>+</span> <span>8</span><span>],</span> <span>C_buffer</span><span>[</span><span>1</span><span>][</span><span>j</span><span>]);</span>
<span>}</span>
</code></pre></div></div>

<p>To perform matrix multiplication, we simply iterate over the matrix $C$ and apply the kernel to it’s sub-matrices:</p>
<div><div><pre><code><span>#define MR 16
#define NR 6
</span>
<span>void</span> <span>matmul_kernel</span><span>(</span><span>float</span><span>*</span> <span>A</span><span>,</span> <span>float</span><span>*</span> <span>B</span><span>,</span> <span>float</span><span>*</span> <span>C</span><span>,</span> <span>const</span> <span>int</span> <span>M</span><span>,</span> <span>const</span> <span>int</span> <span>N</span><span>,</span> <span>const</span> <span>int</span> <span>K</span><span>)</span> <span>{</span>
  <span>assert</span><span>(</span><span>M</span> <span>%</span> <span>MR</span> <span>==</span> <span>0</span><span>);</span>
  <span>assert</span><span>(</span><span>N</span> <span>%</span> <span>NR</span> <span>==</span> <span>0</span><span>);</span>
  <span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>M</span><span>;</span> <span>i</span> <span>+=</span> <span>MR</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>int</span> <span>j</span> <span>=</span> <span>0</span><span>;</span> <span>j</span> <span>&lt;</span> <span>N</span><span>;</span> <span>j</span> <span>+=</span> <span>NR</span><span>)</span> <span>{</span>
        <span>kernel_16x6</span><span>(</span><span>&amp;</span><span>A</span><span>[</span><span>i</span><span>],</span> <span>&amp;</span><span>B</span><span>[</span><span>j</span> <span>*</span> <span>K</span><span>],</span> <span>&amp;</span><span>C</span><span>[</span><span>j</span> <span>*</span> <span>M</span> <span>+</span> <span>i</span><span>],</span> <span>M</span><span>,</span> <span>N</span><span>,</span> <span>K</span><span>);</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>The new implementation</p>
<div><div><pre><code>clang-17 <span>-O2</span> <span>-mno-avx512f</span> <span>-march</span><span>=</span>native <span>-DTEST</span> <span>-DNITER</span><span>=</span>100 matmul_kernel.c <span>-o</span> matmul_kernel.out <span>&amp;&amp;</span> ./matmul_kernel.out
</code></pre></div></div>
<p>results in 147 GFLOPS - a gigantic gain compared to the initial 2.7 GFLOPS. Additionally,
we can check the assembly code produced by the compiler via</p>
<div><div><pre><code>clang-17 <span>-O2</span> <span>-mno-avx512f</span> <span>-march</span><span>=</span>native matmul_kernel.c <span>-S</span> <span>&gt;</span> matmul_kernel.txt
</code></pre></div></div>
<p>to ensure that the SIMD instructions and the YMM registers are utilized:</p>
<div><div><pre><code>vbroadcastss	(%rsi,%rbp,4), %ymm14
vbroadcastss	(%rbx,%rbp,4), %ymm15
vfmadd231ps	%ymm14, %ymm12, %ymm3   # ymm3 = (ymm12 * ymm14) + ymm3
vfmadd231ps	%ymm14, %ymm13, %ymm1   # ymm1 = (ymm13 * ymm14) + ymm1
vbroadcastss	(%r13,%rbp,4), %ymm14
vfmadd231ps	%ymm12, %ymm15, %ymm11  # ymm11 = (ymm15 * ymm12) + ymm11
vfmadd231ps	%ymm15, %ymm13, %ymm10  # ymm10 = (ymm13 * ymm15) + ymm10
vfmadd231ps	%ymm14, %ymm12, %ymm2   # ymm2 = (ymm12 * ymm14) + ymm2
vfmadd231ps	%ymm14, %ymm13, %ymm0   # ymm0 = (ymm13 * ymm14) + ymm0
vbroadcastss	(%r12,%rbp,4), %ymm14
vfmadd231ps	%ymm14, %ymm12, %ymm5   # ymm5 = (ymm12 * ymm14) + ymm5
vfmadd231ps	%ymm14, %ymm13, %ymm4   # ymm4 = (ymm13 * ymm14) + ymm4
vbroadcastss	(%r15,%rbp,4), %ymm14
vfmadd231ps	%ymm14, %ymm12, %ymm7   # ymm7 = (ymm12 * ymm14) + ymm7
vfmadd231ps	%ymm14, %ymm13, %ymm6   # ymm6 = (ymm13 * ymm14) + ymm6
vbroadcastss	(%r14,%rbp,4), %ymm14
vfmadd231ps	%ymm14, %ymm12, %ymm9   # ymm9 = (ymm12 * ymm14) + ymm9
vfmadd231ps	%ymm14, %ymm13, %ymm8   # ymm8 = (ymm13 * ymm14) + ymm8
</code></pre></div></div>

<h2 id="masking-and-packing">Masking And Packing</h2>
<p>You might notice that the current kernel implementation works only for matrix sizes that are multiples of $m_R$ and $n_R$. To make the algorithm work for arbitrary matrix sizes, we need to handle edge cases where the kernel doesn’t fully overlap with matrix $C$.</p>

<p><img src="https://salykova.github.io/assets/matmul_cpu/kernel_mask.png" alt=""/></p>

<p>First of all, we when loading and storing the elements of $C$, we should pick the elements only within the matrix boundary. The case where the number of overlapped columns $n$ is less than $n_R$  is straightforward - we simply iterate over $n$ columns within the $C$ boundary:</p>
<div><div><pre><code><span># n - number of overlapped columns within C boundary
</span>
<span># &#34;j&lt;n&#34; instead &#34;j&lt;6&#34;, since n can be less than 6.
</span><span>for</span> <span>(</span><span>int</span> <span>j</span> <span>=</span> <span>0</span><span>;</span> <span>j</span> <span>&lt;</span> <span>n</span><span>;</span> <span>j</span><span>++</span><span>)</span> <span>{</span>
  <span>C_buffer</span><span>[</span><span>0</span><span>][</span><span>j</span><span>]</span> <span>=</span> <span>_mm256_loadu_ps</span><span>(</span><span>&amp;</span><span>C</span><span>[</span><span>j</span> <span>*</span> <span>M</span><span>]);</span>
  <span>C_buffer</span><span>[</span><span>1</span><span>][</span><span>j</span><span>]</span> <span>=</span> <span>_mm256_loadu_ps</span><span>(</span><span>&amp;</span><span>C</span><span>[</span><span>j</span> <span>*</span> <span>M</span> <span>+</span> <span>8</span><span>]);</span>
<span>}</span>
</code></pre></div></div>
<p>Handling the case where the number of overlapped rows $m$ differs from $m_R$ is a bit trickier because <code>_mm256_loadu_ps</code> loads 8 elements at once. Fortunately, there is a function called <code>_mm256_maskload_ps</code> which loads 8 floats based on mask bits associated with each data element. It takes as input 2 arguments: <code>const float* data</code> and <code>__m256i mask</code>. <code>__m256i</code> is a 256-bit vector of 8x32-bit integers. The most significant bit (MSB) of each integer represents the mask bits. If a mask bit is zero, the corresponding value in the memory location is not loaded and the corresponding field in the return value is set to zero. For example, MSB of unsigned integer <code>2147483648</code> (binary representation <code>10000000 00000000 00000000 00000000</code>) is <code>1</code>, hence corresponding float in <code>data</code> will be loaded. On the other hand, MSB of unsigned integer <code>2147483647</code> (binary format <code>01111111 11111111 11111111 11111111</code>) is <code>0</code>, hence the corresponding float in <code>data</code> will not be loaded. The function <code>_mm256_maskstore_ps</code> works similarly, except it stores data instead of loading.</p>

<p>If $m \neq m_R$ , we create integer masks by left-shifting the unsigned integer <code>65535</code> (=<code>00000000 00000000 11111111 111111111</code> in binary format) depending on the number of overlapped rows $m$. The function <code>_mm256_setr_epi32</code> creates an 8-integer vector from 8 32-bit integers.</p>
<div><div><pre><code><span>__m256i</span> <span>masks</span><span>[</span><span>2</span><span>];</span>
<span>if</span> <span>(</span><span>m</span> <span>!=</span> <span>MR</span><span>)</span> <span>{</span>
  <span>const</span> <span>unsigned</span> <span>int</span> <span>bit_mask</span> <span>=</span> <span>65535</span><span>;</span>
  <span>masks</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>_mm256_setr_epi32</span><span>(</span><span>bit_mask</span> <span>&lt;&lt;</span> <span>(</span><span>m</span> <span>+</span> <span>15</span><span>),</span> <span>bit_mask</span> <span>&lt;&lt;</span> <span>(</span><span>m</span> <span>+</span> <span>14</span><span>),</span>
                 <span>bit_mask</span> <span>&lt;&lt;</span> <span>(</span><span>m</span> <span>+</span> <span>13</span><span>),</span> <span>bit_mask</span> <span>&lt;&lt;</span> <span>(</span><span>m</span> <span>+</span> <span>12</span><span>),</span>
                 <span>bit_mask</span> <span>&lt;&lt;</span> <span>(</span><span>m</span> <span>+</span> <span>11</span><span>),</span> <span>bit_mask</span> <span>&lt;&lt;</span> <span>(</span><span>m</span> <span>+</span> <span>10</span><span>),</span>
                 <span>bit_mask</span> <span>&lt;&lt;</span> <span>(</span><span>m</span> <span>+</span> <span>9</span><span>),</span> <span>bit_mask</span> <span>&lt;&lt;</span> <span>(</span><span>m</span> <span>+</span> <span>8</span><span>));</span>
  <span>masks</span><span>[</span><span>1</span><span>]</span> <span>=</span> <span>_mm256_setr_epi32</span><span>(</span><span>bit_mask</span> <span>&lt;&lt;</span> <span>(</span><span>m</span> <span>+</span> <span>7</span><span>),</span> <span>bit_mask</span> <span>&lt;&lt;</span> <span>(</span><span>m</span> <span>+</span> <span>6</span><span>),</span>
                 <span>bit_mask</span> <span>&lt;&lt;</span> <span>(</span><span>m</span> <span>+</span> <span>5</span><span>),</span> <span>bit_mask</span> <span>&lt;&lt;</span> <span>(</span><span>m</span> <span>+</span> <span>4</span><span>),</span>
                 <span>bit_mask</span> <span>&lt;&lt;</span> <span>(</span><span>m</span> <span>+</span> <span>3</span><span>),</span> <span>bit_mask</span> <span>&lt;&lt;</span> <span>(</span><span>m</span> <span>+</span> <span>2</span><span>),</span>
                 <span>bit_mask</span> <span>&lt;&lt;</span> <span>(</span><span>m</span> <span>+</span> <span>1</span><span>),</span> <span>bit_mask</span> <span>&lt;&lt;</span> <span>m</span><span>);</span>

  <span>for</span> <span>(</span><span>int</span> <span>j</span> <span>=</span> <span>0</span><span>;</span> <span>j</span> <span>&lt;</span> <span>n</span><span>;</span> <span>j</span><span>++</span><span>)</span> <span>{</span>
    <span>C_buffer</span><span>[</span><span>0</span><span>][</span><span>j</span><span>]</span> <span>=</span> <span>_mm256_maskload_ps</span><span>(</span><span>&amp;</span><span>C</span><span>[</span><span>j</span> <span>*</span> <span>M</span><span>],</span> <span>masks</span><span>[</span><span>0</span><span>]);</span>
    <span>C_buffer</span><span>[</span><span>1</span><span>][</span><span>j</span><span>]</span> <span>=</span> <span>_mm256_maskload_ps</span><span>(</span><span>&amp;</span><span>C</span><span>[</span><span>j</span> <span>*</span> <span>M</span> <span>+</span> <span>8</span><span>],</span> <span>masks</span><span>[</span><span>1</span><span>]);</span>
  <span>}</span>
<span>}</span>
</code></pre></div></div>
<p>The same masks are used to store the results back after rank-1 updates.</p>

<p>Additionally, we copy and pad with zeros (if needed) $m \times K$, $K \times n$ blocks of $A$ and $B$ into arrays with static shapes $m_R \times K$, $n_R \times K$.</p>
<div><div><pre><code><span>void</span> <span>pack_blockA</span><span>(</span><span>float</span><span>*</span> <span>A</span><span>,</span> <span>float</span><span>*</span> <span>blockA_packed</span><span>,</span> <span>const</span> <span>int</span> <span>m</span><span>,</span> <span>const</span> <span>int</span> <span>M</span><span>,</span>
                 <span>const</span> <span>int</span> <span>K</span><span>)</span> <span>{</span>
  <span>for</span> <span>(</span><span>int</span> <span>p</span> <span>=</span> <span>0</span><span>;</span> <span>p</span> <span>&lt;</span> <span>K</span><span>;</span> <span>p</span><span>++</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>m</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span>{</span>
      <span>*</span><span>blockA_packed</span> <span>=</span> <span>A</span><span>[</span><span>p</span> <span>*</span> <span>M</span> <span>+</span> <span>i</span><span>];</span>
      <span>blockA_packed</span><span>++</span><span>;</span>
    <span>}</span>
    <span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>m</span><span>;</span> <span>i</span> <span>&lt;</span> <span>MR</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span>{</span>
      <span>*</span><span>blockA_packed</span> <span>=</span> <span>0</span><span>.</span><span>0</span><span>;</span>
      <span>blockA_packed</span><span>++</span><span>;</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre></div></div>
<p>These blocks with static shapes are then passed into the kernel, so that the rank-1 update inside the kernel can remain unchanged and be optimized during compilation time.</p>
<div><div><pre><code><span>void</span> <span>matmul_pack_mask</span><span>(</span><span>float</span><span>*</span> <span>A</span><span>,</span> <span>float</span><span>*</span> <span>B</span><span>,</span> <span>float</span><span>*</span> <span>C</span><span>,</span> <span>float</span><span>*</span> <span>blockA_packed</span><span>,</span>
                        <span>float</span><span>*</span> <span>blockB_packed</span><span>,</span> <span>const</span> <span>int</span> <span>M</span><span>,</span> <span>const</span> <span>int</span> <span>N</span><span>,</span>
                        <span>const</span> <span>int</span> <span>K</span><span>)</span> <span>{</span>
  <span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>M</span><span>;</span> <span>i</span> <span>+=</span> <span>MR</span><span>)</span> <span>{</span>
    <span>const</span> <span>int</span> <span>m</span> <span>=</span> <span>min</span><span>(</span><span>MR</span><span>,</span> <span>M</span> <span>-</span> <span>i</span><span>);</span>
    <span>pack_blockA</span><span>(</span><span>&amp;</span><span>A</span><span>[</span><span>i</span><span>],</span> <span>blockA_packed</span><span>,</span> <span>m</span><span>,</span> <span>M</span><span>,</span> <span>K</span><span>);</span>
    <span>for</span> <span>(</span><span>int</span> <span>j</span> <span>=</span> <span>0</span><span>;</span> <span>j</span> <span>&lt;</span> <span>N</span><span>;</span> <span>j</span> <span>+=</span> <span>NR</span><span>)</span> <span>{</span>
      <span>const</span> <span>int</span> <span>n</span> <span>=</span> <span>min</span><span>(</span><span>NR</span><span>,</span> <span>N</span> <span>-</span> <span>j</span><span>);</span>
      <span>pack_blockB</span><span>(</span><span>&amp;</span><span>B</span><span>[</span><span>j</span> <span>*</span> <span>K</span><span>],</span> <span>blockB_packed</span><span>,</span> <span>n</span><span>,</span> <span>N</span><span>,</span> <span>K</span><span>);</span>
      <span>kernel_16x6</span><span>(</span><span>blockA_packed</span><span>,</span> <span>blockB_packed</span><span>,</span> <span>&amp;</span><span>C</span><span>[</span><span>j</span> <span>*</span> <span>M</span> <span>+</span> <span>i</span><span>],</span> <span>m</span><span>,</span> <span>n</span><span>,</span> <span>M</span><span>,</span> <span>N</span><span>,</span> <span>K</span><span>);</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>The new implementation <code>matmul_cache.c</code> achieves “only” 56 GFLOPS on my machine:</p>
<div><div><pre><code>clang-17 <span>-O2</span> <span>-mno-avx512f</span> <span>-march</span><span>=</span>native <span>-DTEST</span> <span>-DNITER</span><span>=</span>100 matmul_pack_mask.c <span>-o</span> matmul_pack_mask.out <span>&amp;&amp;</span> ./matmul_pack_mask.out
</code></pre></div></div>
<p>We see roughly a 2.6x decrease in performance, mostly because of frequently copying large $K$ dimensional sub-matrices of $A$ and $B$ from main memory. For each $m_R \times K$ sub-matrix of $A$ the entire(!) matrix $B$ is copied. Let’s optimize data reuse and cache management to finally achieve numpy’s level of performance for arbitrary matrix sizes.</p>

<h2 id="caching">Caching</h2>

<p>Recall the CPU’s memory system diagram. Initially, we’ve ignored the intermediate layer between main-memory (DRAM) and the CPU’s registers - the CPU Cache.</p>

<p><img src="https://salykova.github.io/assets/matmul_cpu/cpu_mem.png" alt="" width="70%"/></p>

<p>Unlike DRAM, the cache is on-chip memory used to store frequently and recently accessed data from main memory. This minimizes data transfers between main memory and registers. Although faster than DRAM, the cache has limited capacity. CPUs typically employ a multi-level cache hierarchy for efficient data access. Levels like L1, L2, and L3 offer progressively larger capacities but slower access times, with L1 being the fastest and closest to the core.</p>

<p><img src="https://salykova.github.io/assets/matmul_cpu/cpu_arch.png" alt=""/></p>

<p><img src="https://salykova.github.io/assets/matmul_cpu/core_arch.png" alt=""/>
<em>Intel Core i9-13900K labelled die shot. Source: <a href="https://www.youtube.com/watch?v=dX9CGRZwD-w">How are Microchips Made?</a></em></p>

<p>To enhance access speed, CPUs transfer data between main memory and cache in fixed-size chunks called <strong>cache lines</strong> or <strong>cache blocks</strong>. When a cache line is transferred, a corresponding cache entry is created to store it. On Ryzen 7700, the cache line size is <a href="https://en.wikichip.org/wiki/amd/microarchitectures/zen_4#Memory_Hierarchy">64 bytes</a>. The cache takes advantage of how we typically access data. When a single floating-point number from a continuous array in memory is requested, the cache cleverly grabs the next 15 floats along the way and stores them as well. This is why reading data sequentially from a contiguous array is much faster than jumping around to random memory locations. When the processor needs to read or write to a memory location, it first checks the cache for a corresponding entry. If the processor finds the memory location in the cache, a <strong>cache hit</strong> occurs. However, if the memory location is not found in the cache, a <strong>cache miss</strong> occurs. In the case of a cache miss, the cache allocates a new entry and copies the data from main memory. If the cache is full, a <a href="https://en.wikipedia.org/wiki/Cache_replacement_policies">cache replacement policy</a> kicks in to determine which data gets evicted to make room for new information. Several cache replacement policies exist, with LRU (Least Recently Used), LFU (Least Frequently Used), and LFRU (Least Frequently Recently Used) being the most widely used.</p>

<p>Similar to registers, once data is loaded into the cache, we want to reuse the data as much as possible to reduce main memory accesses. Given the cache’s limited capacity, storing entire input matrices input matrices $C, B, A$  in the cache isn’t feasible. Instead, we divide them into smaller blocks, load these blocks into the cache, and reuse them for rank-1 updates. This technique is often referred to as <strong>tiling</strong> or <strong>cache blocking</strong>, allowing us to handle matrices of arbitrary size effectively.</p>

<p>The final single-threaded matrix multiplication implementation, including the cache blocking, can be visualized as shown in the image borrowed from the official <a href="https://github.com/flame/blis/blob/master/docs/Multithreading.md">BLIS repository</a>:</p>

<p><img src="https://salykova.github.io/assets/matmul_cpu/blis_design.png" alt=""/></p>

<p>Let’s step through the diagram and discuss it.
In the outer-most loop (5th loop) we iterate over dimension $N$, dividing matrix $C$ into blocks $C_j$ of size $M \times n_c$  and matrix $B$  into blocks $B_j$ of size $K \times n_c$. The subscript $c$ in $n_c$ stands for <em>cache</em>.
In the 4th loop we iterate over dimension $K$ and divide matrix $A$ into $A_j$ of size $M \times k_c$  and $B_j$ into $B_p$ of size $k_c \times n_c$. Notice $B_p$ has fixed, limited size and can now be loaded into the cache. $B_p$ is packed into $\tilde{B}_p$, padded with zeros, if necessary, and loaded into the L3 cache. I
In the 3rd loop we iterate over dimension $M$ and divide $C_j$ into $C_i$ (there is a typo in the diagram) of size $m_c \times n_c$ and $A_p$  into $A_j$ of size $m_c \times k_c$. Matrix $A_j$ is now restricted in size and can be loaded entirely into the L2 cache. $A_j$ is packed into $\tilde{A}_j$ and padded with zeros if needed. Note how we reuse the same $\tilde{B}_p$ block from the L3 cache for different $A_j$ blocks. Both $m_c$ and $n_c$ are chosen to be a multiple of $m_r$ and $n_r$ respectively.</p>

<p>In the last two loops we simply iterate over cached blocks and divide them into $m_R \times k_c$ and $k_c \times n_R$ panels. These panels are then passed to the kernel to perform rank-1 updates on the $m_R \times n_R$ sub-matrix of $C$, similarly to what we have already done in the previous chapter. Each panel of $\tilde{B}_p$ is loaded into the L1 cache and reused for multiple panels of $\tilde{A}_j$.
Keep in mind that $\tilde{A}_j$ and $\tilde{B}_p$ are packed differently. During rank-1 updates we sequentially read a panel of $\tilde{A}_j$ column by column and a panel of $\tilde{B}_p$ row by row. Thus,  each panel inside $\tilde{A}_j$ is stored in column-major order, while each panel inside $\tilde{B}_p$ is stored in row-major order.</p>

<p>Different CPU models have varying cache sizes. To achieve peak performance, it’s crucial to optimize three key parameters: cache sizes for L1, L2, and L3 cashes (represented by $k_c$​, $m_c$​, and $n_c$​ respectively). Theoretically, these parameters should be chosen so that:</p>

<ul>
  <li>The matrix $k_c​ \times n_c$​ fills the entire L3 cache.</li>
  <li>The matrix $m_c​ \times k_c​$ fills the entire L2 cache.</li>
  <li>The matrix $k_c​ \times n_R$​ fills the entire L1 cache.</li>
</ul>

<p>While these values provide a good starting point, using larger values often leads to better performance in practice. Unfortunately (or fortunately), we cannot manually place data into the cache or control which cache levels store the data; the CPU manages this automatically using cache replacement policies. Therefore, cache blocking and cache reuse must be implemented at the algorithm level through, for example, well-designed loops and strategic data access patterns.</p>

<p>The implementation straightforwardly follows the algorithm depicted in the diagram:</p>
<div><div><pre><code><span>void</span> <span>matmul_cache</span><span>(</span><span>float</span><span>*</span> <span>A</span><span>,</span> <span>float</span><span>*</span> <span>B</span><span>,</span> <span>float</span><span>*</span> <span>C</span><span>,</span> <span>const</span> <span>int</span> <span>M</span><span>,</span> <span>const</span> <span>int</span> <span>N</span><span>,</span>
                  <span>const</span> <span>int</span> <span>K</span><span>)</span> <span>{</span>
  <span>for</span> <span>(</span><span>int</span> <span>j</span> <span>=</span> <span>0</span><span>;</span> <span>j</span> <span>&lt;</span> <span>N</span><span>;</span> <span>j</span> <span>+=</span> <span>NC</span><span>)</span> <span>{</span> <span>// 5th loop</span>
    <span>const</span> <span>int</span> <span>nb</span> <span>=</span> <span>min</span><span>(</span><span>NC</span><span>,</span> <span>N</span> <span>-</span> <span>j</span><span>);</span>
    <span>for</span> <span>(</span><span>int</span> <span>p</span> <span>=</span> <span>0</span><span>;</span> <span>p</span> <span>&lt;</span> <span>K</span><span>;</span> <span>p</span> <span>+=</span> <span>KC</span><span>)</span> <span>{</span> <span>// 4th loop</span>
      <span>const</span> <span>int</span> <span>kb</span> <span>=</span> <span>min</span><span>(</span><span>KC</span><span>,</span> <span>K</span> <span>-</span> <span>p</span><span>);</span>
      <span>pack_blockB</span><span>(</span><span>&amp;</span><span>B</span><span>[</span><span>j</span> <span>*</span> <span>K</span> <span>+</span> <span>p</span><span>],</span> <span>blockB_packed</span><span>,</span> <span>nb</span><span>,</span> <span>kb</span><span>,</span> <span>K</span><span>);</span>
      <span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>M</span><span>;</span> <span>i</span> <span>+=</span> <span>MC</span><span>)</span> <span>{</span> <span>// 3rd loop</span>
        <span>const</span> <span>int</span> <span>mb</span> <span>=</span> <span>min</span><span>(</span><span>MC</span><span>,</span> <span>M</span> <span>-</span> <span>i</span><span>);</span>
        <span>pack_blockA</span><span>(</span><span>&amp;</span><span>A</span><span>[</span><span>p</span> <span>*</span> <span>M</span> <span>+</span> <span>i</span><span>],</span> <span>blockA_packed</span><span>,</span> <span>mb</span><span>,</span> <span>kb</span><span>,</span> <span>M</span><span>);</span>
        <span>for</span> <span>(</span><span>int</span> <span>jr</span> <span>=</span> <span>0</span><span>;</span> <span>jr</span> <span>&lt;</span> <span>nb</span><span>;</span> <span>jr</span> <span>+=</span> <span>NR</span><span>)</span> <span>{</span> <span>// 2nd loop</span>
          <span>const</span> <span>int</span> <span>nr</span> <span>=</span> <span>min</span><span>(</span><span>NR</span><span>,</span> <span>nb</span> <span>-</span> <span>jr</span><span>);</span>
          <span>for</span> <span>(</span><span>int</span> <span>ir</span> <span>=</span> <span>0</span><span>;</span> <span>ir</span> <span>&lt;</span> <span>mb</span><span>;</span> <span>ir</span> <span>+=</span> <span>MR</span><span>)</span> <span>{</span> <span>// 1st loop</span>
            <span>const</span> <span>int</span> <span>mr</span> <span>=</span> <span>min</span><span>(</span><span>MR</span><span>,</span> <span>mb</span> <span>-</span> <span>ir</span><span>);</span>
            <span>kernel_16x6</span><span>(</span><span>&amp;</span><span>blockA_packed</span><span>[</span><span>ir</span> <span>*</span> <span>kb</span><span>],</span> <span>&amp;</span><span>blockB_packed</span><span>[</span><span>jr</span> <span>*</span> <span>kb</span><span>],</span>
                        <span>&amp;</span><span>C</span><span>[(</span><span>j</span> <span>+</span> <span>jr</span><span>)</span> <span>*</span> <span>M</span> <span>+</span> <span>(</span><span>i</span> <span>+</span> <span>ir</span><span>)],</span> <span>mr</span><span>,</span> <span>nr</span><span>,</span> <span>kb</span><span>,</span> <span>M</span><span>);</span>
          <span>}</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre></div></div>
<p>Before implementing the multi-threaded version of the algorithm, let’s benchmark our current implementation and compare it against numpy:</p>
<div><div><pre><code>python benchmark_numpy.py <span>-ST</span>

clang-17 <span>-O2</span> <span>-mno-avx512f</span> <span>-march</span><span>=</span>native benchmark_st.c <span>-o</span> benchmark_st.out <span>&amp;&amp;</span> ./benchmark_st.out

python plot_benchmark.py
</code></pre></div></div>

<p><img src="https://salykova.github.io/assets/matmul_cpu/benchmark_st.png" alt=""/></p>

<h2 id="multithreading">Multithreading</h2>

<p>There are indeed many loops that can be potentially parallelized. To achieve high-performance, we want to parallelize both packing and arithmetic operations. Let’s start with the arithmetic operations. The 5th, 4th, 3rd loops around the micro-kernel iterate over matrix dimensions in chunks of cache block sizes $n_c$, $k_c$, $m_c$. To efficiently parallelize the loops and keep all threads busy, we want number of iterations (=matrix dimension / cache block size) to be at least = number of threads (generally, the more the better). In other words, the input matrix dimension should be at least = number of threads  * cache block size. As we discussed earlier, we also want cache blocks to fully occupy the corresponding cache levels. On modern CPUs, this second requirement results in cache block sizes of thousand(s) of elements. For example, on my Ryzen 7700, cache block sizes of $n_c=1535$, $m_c=1024, k_c=2000$ attain the best performance in the single-threaded case. Given the number of available threads on Ryzen 7700, $Nthreads=16$, we need input matrices with dimensions of at least $2000 \times 16$ to be able to distribute the work over all threads.</p>

<p><img src="https://salykova.github.io/assets/matmul_cpu/blis_design.png" alt=""/></p>

<p>In contrast, the last two loops iterate over cache blocks, dividing them into $m_r, n_r$ blocks. Since $n_r, m_r$ are typically very small (&lt;20), these loops are ideal candidates for parallelization. Moreover, we can choose $m_c, n_c$ to be multiples of $Nthreads$ so that the work is evenly distributed across all threads.</p>

<p>On my machine, parallelizing the second loop results in much better performance compared to the first loop (possibly due to large $n_c$ and little work in each iteration of the first loop). We will therefore parallelize the second loop using OpenMP directives (more on OpenMP <a href="https://ppc.cs.aalto.fi/ch2/openmp/">here</a>, <a href="https://ppc.cs.aalto.fi/ch3/">here</a> and <a href="https://curc.readthedocs.io/en/latest/programming/OpenMP-C.html">here</a>):</p>
<div><div><pre><code><span>#pragma omp parallel for num_threads(NTHREADS) schedule(static)
</span>  <span>for</span> <span>(</span><span>int</span> <span>jr</span> <span>=</span> <span>0</span><span>;</span> <span>jr</span> <span>&lt;</span> <span>nb</span><span>;</span> <span>jr</span> <span>+=</span> <span>NR</span><span>)</span>
</code></pre></div></div>
<blockquote>
  <p>It’s also possible to parallelize the 2nd and 1st loops using <code>#pragma omp parallel for collapse(2)</code>, which leads to similar performance when parallelizing only the 2nd loop.</p>
</blockquote>

<p>Together with arithmetic operations, we also want to accelerate the packing of both $\tilde{A}$ and $\tilde{B}$:</p>
<div><div><pre><code><span>void</span> <span>pack_blockA</span><span>(</span><span>float</span><span>*</span> <span>A</span><span>,</span> <span>float</span><span>*</span> <span>blockA_packed</span><span>,</span> <span>const</span> <span>int</span> <span>mb</span><span>,</span> <span>const</span> <span>int</span> <span>kb</span><span>,</span> <span>const</span> <span>int</span> <span>M</span><span>)</span>
<span>#pragma omp parallel for num_threads(NTHREADS) schedule(static)
</span>  <span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>mb</span><span>;</span> <span>i</span> <span>+=</span> <span>MR</span><span>)</span>
</code></pre></div></div>

<div><div><pre><code><span>void</span> <span>pack_blockB</span><span>(</span><span>float</span><span>*</span> <span>B</span><span>,</span> <span>float</span><span>*</span> <span>blockB_packed</span><span>,</span> <span>const</span> <span>int</span> <span>nb</span><span>,</span> <span>const</span> <span>int</span> <span>kb</span><span>,</span> <span>const</span> <span>int</span> <span>K</span><span>)</span>
<span>#pragma omp parallel for num_threads(NTHREADS) schedule(static)
</span>  <span>for</span> <span>(</span><span>int</span> <span>j</span> <span>=</span> <span>0</span><span>;</span> <span>j</span> <span>&lt;</span> <span>nb</span><span>;</span> <span>j</span> <span>+=</span> <span>NR</span><span>)</span>
</code></pre></div></div>
<p>Similar to arithmetic operations, the packing loops can be easily parallelized due to the high number of iterations and the flexibility of choosing  $m_c, k_c, n_c$.</p>

<p>Running</p>
<div><div><pre><code>clang-17 <span>-O2</span> <span>-mno-avx512f</span> <span>-march</span><span>=</span>native <span>-DNITER</span><span>=</span>100 <span>-fopenmp</span> matmul_parallel.c <span>-o</span> matmul_parallel.out <span>&amp;&amp;</span> ./matmul_parallel.out
</code></pre></div></div>
<p>shows around 1 TFLOPS. Don’t forget to add the <code>-fopenmp</code> compiler flag to use OpenMP directives. You might also need to install <code>libomp-dev</code> with <code>sudo apt install libomp-dev</code>.</p>

<p>Let’s check the CPU utilization</p>

<p><img src="https://salykova.github.io/assets/matmul_cpu/htop.png" alt=""/></p>

<p>and benchmark the multithreading implementation:</p>
<div><div><pre><code>python benchmark_numpy.py
clang-17 <span>-O2</span> <span>-mno-avx512f</span> <span>-march</span><span>=</span>native <span>-fopenmp</span> benchmark_mt.c <span>-o</span> benchmark_mt.out <span>&amp;&amp;</span> ./benchmark_mt.out
python plot_benchmark.py
</code></pre></div></div>
<p><img src="https://salykova.github.io/assets/matmul_cpu/benchmark_mt.png" alt=""/></p>

  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
