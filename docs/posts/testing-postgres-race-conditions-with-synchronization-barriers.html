<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.lirbank.com/harnessing-postgres-race-conditions">Original</a>
    <h1>Testing Postgres race conditions with synchronization barriers</h1>
    
    <div id="readability-page-1" class="page"><section> <article> <header> Mikael Lirbank — <time datetime="2026-02-13">February 2026</time> </header> 
<p>Without race condition tests, every possible race condition in your system is one refactor away from hitting production.</p>
<p>Synchronization barriers let you write those tests with confidence.</p>
<h2 id="what-a-race-condition-looks-like">What a race condition looks like</h2>
<p>You have a function that credits an account. It reads the current balance, adds an amount, and writes the new value back.</p>
<p>When two requests run this concurrently — two $50 credits to an account with a $100 balance — the timing can line up like this:</p>
<pre tabindex="0" data-language="plaintext"><code><span><span>P1: SELECT balance → 100</span></span>
<span><span>P2: SELECT balance → 100</span></span>
<span><span>     ── both read 100, now both write based on it ──</span></span>
<span><span>P1: UPDATE balance = 150</span></span>
<span><span>P2: UPDATE balance = 150</span></span></code></pre>
<p>Both read 100. Both compute 150. Both write 150. Final balance: $150 instead of $200. One $50 credit vanished. No error was raised. No transaction was rolled back. The database did exactly what it was told.</p>
<p>This is the shape of every write race condition: two operations read the same stale value, then both write based on it. The second write overwrites the first. In a system that handles money, that&#39;s a customer with a wrong balance and no error in any log to explain it.</p>
<h2 id="the-testing-challenge">The testing challenge</h2>
<p>Your test suite runs one request at a time. The interleaving above never happens. The test passes whether your code handles concurrency correctly or not.</p>
<p>Put the crediting logic in a function and run two calls concurrently:</p>
<pre tabindex="0" data-language="typescript"><code><span><span>// Naive implementation — no transaction, no lock</span></span>
<span><span>const</span><span> credit</span><span> =</span><span> async</span><span> (</span><span>accountId</span><span>:</span><span> number</span><span>, </span><span>amount</span><span>:</span><span> number</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span><span>  const</span><span> [</span><span>row</span><span>] </span><span>=</span><span> await</span><span> db.</span><span>execute</span><span>(</span></span>
<span><span>    sql</span><span>`SELECT balance FROM accounts WHERE id = ${</span><span>accountId</span><span>}`</span><span>,</span></span>
<span><span>  );</span></span>
<span><span>  const</span><span> newBalance</span><span> =</span><span> row.balance </span><span>+</span><span> amount;</span></span>
<span><span>  await</span><span> db.</span><span>execute</span><span>(</span></span>
<span><span>    sql</span><span>`UPDATE accounts SET balance = ${</span><span>newBalance</span><span>} WHERE id = ${</span><span>accountId</span><span>}`</span><span>,</span></span>
<span><span>  );</span></span>
<span><span>};</span></span>
<span></span>
<span><span>await</span><span> Promise</span><span>.</span><span>all</span><span>([</span><span>credit</span><span>(</span><span>1</span><span>, </span><span>50</span><span>), </span><span>credit</span><span>(</span><span>1</span><span>, </span><span>50</span><span>)]);</span></span>
<span><span>expect</span><span>(result.balance).</span><span>toBe</span><span>(</span><span>200</span><span>); </span><span>// passes — but we know the code has a race condition</span></span></code></pre>
<p>You could add <code>sleep()</code> between the two queries to try to force the overlap. This buys you a slow, flaky test that sometimes catches the bug and sometimes doesn&#39;t. You could run the test a thousand times and hope the timing lines up at least once. Both approaches are the same bet — you&#39;re not testing concurrency, you&#39;re rolling dice.</p>
<p>What you need is a way to force two operations to read the same stale value before either writes. Every time. Not probabilistically.</p>
<p>You know this pattern exists. You know it&#39;s dangerous. The problem isn&#39;t knowledge. It&#39;s proof.</p>
<h2 id="synchronization-barriers">Synchronization barriers</h2>
<p>A barrier is a synchronization point for concurrent operations. You tell it how many tasks to expect. Each task runs independently until it hits the barrier, then waits. When the last task arrives, all of them are released at once.</p>
<pre tabindex="0" data-language="typescript"><code><span><span>function</span><span> createBarrier</span><span>(</span><span>count</span><span>:</span><span> number</span><span>) {</span></span>
<span><span>  let</span><span> arrived </span><span>=</span><span> 0</span><span>;</span></span>
<span><span>  let</span><span> release</span><span>:</span><span> () </span><span>=&gt;</span><span> void</span><span>;</span></span>
<span></span>
<span><span>  const</span><span> barrier</span><span> =</span><span> new</span><span> Promise</span><span>&lt;</span><span>void</span><span>&gt;((</span><span>resolve</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span><span>    release </span><span>=</span><span> resolve;</span></span>
<span><span>  });</span></span>
<span></span>
<span><span>  return</span><span> async</span><span> () </span><span>=&gt;</span><span> {</span></span>
<span><span>    arrived</span><span>++</span><span>;</span></span>
<span></span>
<span><span>    if</span><span> (arrived </span><span>===</span><span> count) {</span></span>
<span><span>      release</span><span>();</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    await</span><span> barrier;</span></span>
<span><span>  };</span></span>
<span><span>}</span></span></code></pre>
<p><a href="https://github.com/starmode-base/neon-testing/blob/54e86d453158806fd4166e662361d82dd0955a81/src/barrier.ts">Source code for <code>createBarrier</code></a></p>
<p>A counter and a shared promise. Each caller increments the count. The last arrival resolves the promise. All callers await it — when it resolves, everyone proceeds. The function returns a barrier — call it and you&#39;re synchronized.</p>
<p>Place a barrier between the read and the write in concurrent code, and you force the exact interleaving from the previous section: every task reads before any task writes. That&#39;s the race condition, manufactured on demand.</p>
<h2 id="the-barrier-in-action">The barrier in action</h2>
<p><a href="https://github.com/starmode-base/neon-testing/blob/54e86d453158806fd4166e662361d82dd0955a81/examples/barriers/inline.test.ts">Runnable versions of every test in this section</a></p>
<p>Apply the barrier to the crediting function from earlier. Run the same test — two concurrent $50 credits — under three levels of protection. The results are instructive.</p>
<h3 id="1-bare-queries">1. Bare queries</h3>
<p>The simplest case: no transaction, just a SELECT and an UPDATE with a barrier between them:</p>
<pre tabindex="0" data-language="typescript"><code><span><span>import</span><span> { createBarrier } </span><span>from</span><span> &#34;neon-testing/utils&#34;</span><span>;</span></span>
<span></span>
<span><span>// Create a barrier that blocks until 2 tasks have arrived, then releases all of</span></span>
<span><span>// them at once.</span></span>
<span><span>const</span><span> barrier</span><span> =</span><span> createBarrier</span><span>(</span><span>2</span><span>);</span></span>
<span></span>
<span><span>const</span><span> credit</span><span> =</span><span> async</span><span> (</span><span>accountId</span><span>:</span><span> number</span><span>, </span><span>amount</span><span>:</span><span> number</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span><span>  // Step 1: read the current balance</span></span>
<span><span>  const</span><span> [</span><span>row</span><span>] </span><span>=</span><span> await</span><span> db.</span><span>execute</span><span>(</span></span>
<span><span>    sql</span><span>`SELECT balance FROM accounts WHERE id = ${</span><span>accountId</span><span>}`</span><span>,</span></span>
<span><span>  );</span></span>
<span></span>
<span><span>  // Step 2: wait here until the other task has also read. This guarantees both</span></span>
<span><span>  // tasks read before either writes.</span></span>
<span><span>  await</span><span> barrier</span><span>();</span></span>
<span></span>
<span><span>  // Step 3: compute and write the new balance</span></span>
<span><span>  const</span><span> newBalance</span><span> =</span><span> row.balance </span><span>+</span><span> amount;</span></span>
<span><span>  await</span><span> db.</span><span>execute</span><span>(</span></span>
<span><span>    sql</span><span>`UPDATE accounts SET balance = ${</span><span>newBalance</span><span>} WHERE id = ${</span><span>accountId</span><span>}`</span><span>,</span></span>
<span><span>  );</span></span>
<span><span>};</span></span>
<span></span>
<span><span>// Run two $50 credits at the same time</span></span>
<span><span>await</span><span> Promise</span><span>.</span><span>all</span><span>([</span><span>credit</span><span>(</span><span>1</span><span>, </span><span>50</span><span>), </span><span>credit</span><span>(</span><span>1</span><span>, </span><span>50</span><span>)]);</span></span>
<span></span>
<span><span>// Check the final balance</span></span>
<span><span>const</span><span> [</span><span>result</span><span>] </span><span>=</span><span> await</span><span> db.</span><span>execute</span><span>(</span></span>
<span><span>  sql</span><span>`SELECT balance FROM accounts WHERE id = 1`</span><span>,</span></span>
<span><span>);</span></span>
<span><span>expect</span><span>(result.balance).</span><span>toBe</span><span>(</span><span>200</span><span>); </span><span>// fails — balance is 150, not 200</span></span></code></pre>
<p>The test fails:</p>
<pre tabindex="0" data-language="plaintext"><code><span><span>P1: SELECT balance → 100</span></span>
<span><span>P2: SELECT balance → 100</span></span>
<span><span>     ── barrier releases both ──</span></span>
<span><span>P1: UPDATE balance = 150</span></span>
<span><span>P2: UPDATE balance = 150</span></span>
<span><span></span></span>
<span><span>Expected: 200</span></span>
<span><span>Received: 150  ✗</span></span></code></pre>
<p>The same interleaving from earlier, now happening inside your test suite. Deterministic. No timing tricks.</p>
<h3 id="2-adding-transactions">2. Adding transactions</h3>
<p>Wrap the operation in a transaction:</p>
<pre tabindex="0" data-language="typescript"><code><span><span>const</span><span> credit</span><span> =</span><span> async</span><span> (</span><span>accountId</span><span>:</span><span> number</span><span>, </span><span>amount</span><span>:</span><span> number</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span><span>  // Same logic, now inside a transaction</span></span>
<span><span>  await</span><span> db.</span><span>transaction</span><span>(</span><span>async</span><span> (</span><span>tx</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span><span>    const</span><span> [</span><span>row</span><span>] </span><span>=</span><span> await</span><span> tx.</span><span>execute</span><span>(</span></span>
<span><span>      sql</span><span>`SELECT balance FROM accounts WHERE id = ${</span><span>accountId</span><span>}`</span><span>,</span></span>
<span><span>    );</span></span>
<span><span>    await</span><span> barrier</span><span>();</span></span>
<span><span>    const</span><span> newBalance</span><span> =</span><span> row.balance </span><span>+</span><span> amount;</span></span>
<span><span>    await</span><span> tx.</span><span>execute</span><span>(</span></span>
<span><span>      sql</span><span>`UPDATE accounts SET balance = ${</span><span>newBalance</span><span>} WHERE id = ${</span><span>accountId</span><span>}`</span><span>,</span></span>
<span><span>    );</span></span>
<span><span>  });</span></span>
<span><span>};</span></span></code></pre>
<p>Same test, same barrier. Still fails:</p>
<pre tabindex="0" data-language="plaintext"><code><span><span>T1: BEGIN</span></span>
<span><span>T1: SELECT balance → 100</span></span>
<span><span>T2: BEGIN</span></span>
<span><span>T2: SELECT balance → 100</span></span>
<span><span>     ── barrier releases both ──</span></span>
<span><span>T1: UPDATE balance = 150</span></span>
<span><span>T1: COMMIT</span></span>
<span><span>T2: UPDATE balance = 150</span></span>
<span><span>T2: COMMIT</span></span>
<span><span></span></span>
<span><span>Expected: 200</span></span>
<span><span>Received: 150  ✗</span></span></code></pre>
<p>The transaction didn&#39;t help. Postgres&#39;s default isolation level is READ COMMITTED — each statement sees all data committed before that statement started.</p>
<p>A transaction gives you a consistent snapshot per statement. It does not give you a write lock. The barrier just proved these are different things.</p>
<h3 id="3-adding-write-locks">3. Adding write locks</h3>
<p><code>SELECT ... FOR UPDATE</code> acquires a row-level lock at read time. Another transaction trying to lock the same row blocks until the first one commits:</p>
<pre tabindex="0" data-language="typescript"><code><span><span>const</span><span> credit</span><span> =</span><span> async</span><span> (</span><span>accountId</span><span>:</span><span> number</span><span>, </span><span>amount</span><span>:</span><span> number</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span><span>  await</span><span> db.</span><span>transaction</span><span>(</span><span>async</span><span> (</span><span>tx</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span><span>    const</span><span> [</span><span>row</span><span>] </span><span>=</span><span> await</span><span> tx.</span><span>execute</span><span>(</span></span>
<span><span>      sql</span><span>`SELECT balance FROM accounts WHERE id = ${</span><span>accountId</span><span>} FOR UPDATE`</span><span>, </span><span>// lock the row</span></span>
<span><span>    );</span></span>
<span><span>    await</span><span> barrier</span><span>();</span></span>
<span><span>    const</span><span> newBalance</span><span> =</span><span> row.balance </span><span>+</span><span> amount;</span></span>
<span><span>    await</span><span> tx.</span><span>execute</span><span>(</span></span>
<span><span>      sql</span><span>`UPDATE accounts SET balance = ${</span><span>newBalance</span><span>} WHERE id = ${</span><span>accountId</span><span>}`</span><span>,</span></span>
<span><span>    );</span></span>
<span><span>  });</span></span>
<span><span>};</span></span></code></pre>
<p>Same barrier, same test. Something different happens:</p>
<pre tabindex="0" data-language="plaintext"><code><span><span>T1: BEGIN</span></span>
<span><span>T1: SELECT balance FOR UPDATE → 100 (acquires lock)</span></span>
<span><span>T2: BEGIN</span></span>
<span><span>T2: SELECT balance FOR UPDATE → ☐ blocked (waiting for T1&#39;s lock)</span></span>
<span><span>     ── T1 is at the barrier, waiting for T2.</span></span>
<span><span>        T2 is at the lock, waiting for T1.</span></span>
<span><span>        Neither can proceed. ──</span></span></code></pre>
<p>The first task executes <code>SELECT ... FOR UPDATE</code> and acquires the lock. The second task tries the same query and blocks — it can&#39;t read the row until the first task releases the lock. The second task never reaches the barrier. The barrier is waiting for two tasks, but only one arrived.</p>
<p>The barrier deadlocks.</p>
<h3 id="4-the-deadlock">4. The deadlock</h3>
<p>The deadlock proves the lock is there. You&#39;ve validated the behavior. But a hanging test can&#39;t live in CI. The pragmatic response is to accept the proof and move on — remove the barrier, disable the test, whatever gets the suite green again.</p>
<p>That works until a refactor rewrites the query. Nothing catches the lost lock.</p>
<p>The deadlock is not a dead end. It&#39;s a signal that the barrier is in the wrong place.</p>
<h3 id="5-moving-the-barrier">5. Moving the barrier</h3>
<p>Placing the barrier between read and write made sense for the earlier tests — it forced both tasks to read stale data before either could write, as we wanted. But with <code>FOR UPDATE</code>, the lock happens at read time.</p>
<p>The deadlock happened because one transaction held the lock while waiting at the barrier for the other — but the other was stuck on the lock and never arrived.</p>
<p>Move the barrier earlier — after BEGIN, before the SELECT — so both transactions have started before either tries to lock. Here&#39;s what happens with <code>FOR UPDATE</code> still in place:</p>
<pre tabindex="0" data-language="plaintext"><code><span><span>T1: BEGIN</span></span>
<span><span>T2: BEGIN</span></span>
<span><span>     ── barrier releases both ──</span></span>
<span><span>T1: SELECT balance FOR UPDATE → 100    -- acquires lock</span></span>
<span><span>T2: SELECT balance FOR UPDATE           -- blocks (waiting for T1&#39;s lock)</span></span>
<span><span>T1: UPDATE balance = 150</span></span>
<span><span>T1: COMMIT                              -- releases lock</span></span>
<span><span>T2: SELECT balance FOR UPDATE → 150     -- reads updated value</span></span>
<span><span>T2: UPDATE balance = 200</span></span>
<span><span>T2: COMMIT</span></span>
<span><span></span></span>
<span><span>Expected: 200</span></span>
<span><span>Received: 200 ✓</span></span></code></pre>
<p>The barrier releases both tasks into their SELECT simultaneously. <code>FOR UPDATE</code> serializes them — one gets the lock, the other waits. Which one goes first is arbitrary, but the result is the same: the second transaction reads the updated value. The test passes, runs to completion, and verifies the actual result.</p>
<p>The test passes. But we moved the barrier to fix the deadlock — does the test pass because of the lock, or because of the new barrier position? Remove the <code>FOR UPDATE</code> and find out:</p>
<pre tabindex="0" data-language="plaintext"><code><span><span>T1: BEGIN</span></span>
<span><span>T2: BEGIN</span></span>
<span><span>     ── barrier releases both ──</span></span>
<span><span>T1: SELECT balance → 100</span></span>
<span><span>T2: SELECT balance → 100</span></span>
<span><span>T1: UPDATE balance = 150</span></span>
<span><span>T1: COMMIT</span></span>
<span><span>T2: UPDATE balance = 150</span></span>
<span><span>T2: COMMIT</span></span>
<span><span></span></span>
<span><span>Expected: 200</span></span>
<span><span>Received: 150 ✗</span></span></code></pre>
<p>Same barrier, same position. Without the lock, both read stale data. The test fails — proof that the lock was doing the work. This is correct!</p>
<blockquote>
<p><strong>Important:</strong> A correct barrier test passes with the lock and fails without it. If it doesn&#39;t do both, it proves nothing. Every time you change the barrier or the code it tests, verify both directions.</p>
</blockquote>
<h2 id="putting-it-to-use">Putting it to use</h2>
<h3 id="testing-against-a-real-database">Testing against a real database</h3>
<p>These tests need a real Postgres instance — mocks have no locks, no transactions, no contention to reproduce. There are many ways to do this. I use <a href="https://www.npmjs.com/package/neon-testing">Neon Testing</a>, which also provides a <code>createBarrier</code> function.</p>
<h3 id="injecting-barriers-with-hooks">Injecting barriers with hooks</h3>
<p><a href="https://github.com/starmode-base/neon-testing/blob/54e86d453158806fd4166e662361d82dd0955a81/examples/barriers/hooks.test.ts">Runnable version of the hooks pattern</a></p>
<p>Barriers are test infrastructure — they shouldn&#39;t exist in production code. In the earlier examples, the barrier was baked into the function body. That works for a demonstration, but you need a way to inject the barrier only when running tests.</p>
<p>The solution is a hook: an optional callback that fires at the right point inside the transaction. Production callers don&#39;t pass it. Tests inject the barrier through it.</p>
<pre tabindex="0" data-language="typescript"><code><span><span>async</span><span> function</span><span> credit</span><span>(</span></span>
<span><span>  accountId</span><span>:</span><span> number</span><span>,</span></span>
<span><span>  amount</span><span>:</span><span> number</span><span>,</span></span>
<span><span>  hooks</span><span>?:</span><span> { </span><span>onTxBegin</span><span>?:</span><span> () </span><span>=&gt;</span><span> Promise</span><span>&lt;</span><span>void</span><span>&gt; </span><span>|</span><span> void</span><span> },</span></span>
<span><span>) {</span></span>
<span><span>  await</span><span> db.</span><span>transaction</span><span>(</span><span>async</span><span> (</span><span>tx</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span><span>    if</span><span> (hooks?.onTxBegin) {</span></span>
<span><span>      await</span><span> hooks.</span><span>onTxBegin</span><span>();</span></span>
<span><span>    }</span></span>
<span><span>    const</span><span> [</span><span>row</span><span>] </span><span>=</span><span> await</span><span> tx.</span><span>execute</span><span>(</span></span>
<span><span>      sql</span><span>`SELECT balance FROM accounts WHERE id = ${</span><span>accountId</span><span>} FOR UPDATE`</span><span>,</span></span>
<span><span>    );</span></span>
<span><span>    const</span><span> newBalance</span><span> =</span><span> row.balance </span><span>+</span><span> amount;</span></span>
<span><span>    await</span><span> tx.</span><span>execute</span><span>(</span></span>
<span><span>      sql</span><span>`UPDATE accounts SET balance = ${</span><span>newBalance</span><span>} WHERE id = ${</span><span>accountId</span><span>}`</span><span>,</span></span>
<span><span>    );</span></span>
<span><span>  });</span></span>
<span><span>}</span></span></code></pre>
<p>The hook fires after the transaction begins but before any queries execute. In production, <code>hooks</code> is undefined — the <code>if</code> check costs nothing. In tests, you pass the barrier:</p>
<pre tabindex="0" data-language="typescript"><code><span><span>import</span><span> { createBarrier } </span><span>from</span><span> &#34;neon-testing/utils&#34;</span><span>;</span></span>
<span></span>
<span><span>const</span><span> barrier</span><span> =</span><span> createBarrier</span><span>(</span><span>2</span><span>);</span></span>
<span><span>await</span><span> Promise</span><span>.</span><span>all</span><span>([</span></span>
<span><span>  credit</span><span>(</span><span>1</span><span>, </span><span>50</span><span>, { onTxBegin: barrier }),</span></span>
<span><span>  credit</span><span>(</span><span>1</span><span>, </span><span>50</span><span>, { onTxBegin: barrier }),</span></span>
<span><span>]);</span></span>
<span><span>const</span><span> [</span><span>result</span><span>] </span><span>=</span><span> await</span><span> db.</span><span>execute</span><span>(</span></span>
<span><span>  sql</span><span>`SELECT balance FROM accounts WHERE id = 1`</span><span>,</span></span>
<span><span>);</span></span>
<span><span>expect</span><span>(result.balance).</span><span>toBe</span><span>(</span><span>200</span><span>);</span></span></code></pre>
<p>Production code is unchanged:</p>
<pre tabindex="0" data-language="typescript"><code><span><span>await</span><span> credit</span><span>(</span><span>1</span><span>, </span><span>50</span><span>);</span></span></code></pre>
<p>No hooks, no barrier, no overhead.</p>
<h2 id="dont-ship-vanity-tests">Don&#39;t ship vanity tests</h2>
<p>Six months from now, someone refactors the data access layer. The query gets rewritten, the function gets restructured, the lock gets lost in the shuffle. With barrier testing in your suite, that regression doesn&#39;t ship. The test fails before it leaves the developer&#39;s machine.</p>
<p>But only if the test actually catches the regression. Every time you change the barrier or the business logic — like moving the barrier to fix the deadlock — remove the lock and confirm the test fails. If it passes both ways, it&#39;s a vanity test.</p>
<hr/>
<p>Without barrier tests, every possible race condition in your system is one refactor away from hitting production. Now you know.</p> </article> </section></div>
  </body>
</html>
