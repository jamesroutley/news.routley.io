<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://stripe.com/blog/secret-life-of-dns">Original</a>
    <h1>The secret life of DNS packets (2019)</h1>
    
    <div id="readability-page-1" class="page"><section>
    <p><a href="https://en.wikipedia.org/wiki/Domain_Name_System" data-js-controller="AnalyticsButton" data-analytics-category="Links" data-analytics-action="Clicked" data-analytics-label="">DNS</a> is a critical piece of infrastructure used to facilitate communication across networks. It’s often described as a phonebook: in its most basic form, DNS provides a way to look up a host’s address by an easy-to-remember name. For example, looking up the domain name stripe.com will direct clients to the IP address 53.187.159.182, where one of Stripe’s servers is located. Before any communication can take place, one of the first things a host must do is query a DNS server for the address of the destination host. Since these lookups are a prerequisite for communication, maintaining a reliable DNS service is extremely important. DNS issues can quickly lead to crippling, widespread outages, and you could find yourself in a real <a href="https://en.wikipedia.org/wiki/BIND" data-js-controller="AnalyticsButton" data-analytics-category="Links" data-analytics-action="Clicked" data-analytics-label="">bind</a>.</p><p>It’s important to establish good observability practices for these systems so when things go wrong, you can clearly understand how they’re failing and act quickly to minimize any impact. Well-instrumented systems provide visibility into how they operate; establishing a monitoring system and gathering robust metrics are both essential to effectively respond to incidents. This is critical for post-incident analysis when you’re trying to understand the root cause and prevent recurrences in the future.</p><p>In this post, I’ll describe how we monitor our DNS systems and how we used an array of tools to investigate and fix an unexpected spike in DNS errors that we encountered recently.</p><h2>DNS infrastructure at Stripe</h2><p>At Stripe, we operate a cluster of DNS servers running <a href="https://nlnetlabs.nl/projects/unbound/about/" data-js-controller="AnalyticsButton" data-analytics-category="Links" data-analytics-action="Clicked" data-analytics-label="">Unbound</a>, a popular open-source DNS resolver that can <a href="https://en.wikipedia.org/wiki/Domain_Name_System#Address_resolution_mechanism" data-js-controller="AnalyticsButton" data-analytics-category="Links" data-analytics-action="Clicked" data-analytics-label="">recursively resolve</a> DNS queries and cache the results. These resolvers are configured to forward DNS queries to different upstream destinations based on the domain in the request. Queries that are used for service discovery are forwarded to our Consul cluster. Queries for domains we configure in <a href="https://aws.amazon.com/route53/" data-js-controller="AnalyticsButton" data-analytics-category="Links" data-analytics-action="Clicked" data-analytics-label="">Route 53</a> and any other domains on the public Internet are forwarded to our cluster’s VPC resolver, which is a DNS resolver that AWS provides as part of their <a href="https://aws.amazon.com/vpc/" data-js-controller="AnalyticsButton" data-analytics-category="Links" data-analytics-action="Clicked" data-analytics-label="">VPC offering</a>. We also run resolvers locally on every host, which provides an additional layer of caching.</p><figure data-asset-count="1">
  <div>
  <picture>
      
        <source srcset="https://images.stripeassets.com/fzn2n1nzq965/5fOX3tvMCxWYlYIr9Pc50c/87f68a397aa47ca86a730b709ace0c19/diagram-1-8bcb1dab18d6178110f8b833b26d41ce41a2fd1f.png?w=1620&amp;q=80&amp;fm=webp" type="image/webp"/>
      

      

      <img alt="diagram" src="
        
          https://images.stripeassets.com/fzn2n1nzq965/5fOX3tvMCxWYlYIr9Pc50c/87f68a397aa47ca86a730b709ace0c19/diagram-1-8bcb1dab18d6178110f8b833b26d41ce41a2fd1f.png?w=1620&amp;q=80
        
      " width="2080" height="1604" loading="lazy"/>
    </picture>
</div>
  
    <figcaption><p>Unbound runs locally on every host as well as on the DNS servers.</p></figcaption>
  
</figure><p>Unbound exposes an extensive set of statistics that we <a href="https://github.com/stripe/datadog-checks/blob/master/checks.d/unbound.py" data-js-controller="AnalyticsButton" data-analytics-category="Links" data-analytics-action="Clicked" data-analytics-label="">collect</a> and feed into our metrics pipeline. This provides us with visibility into metrics like how many queries are being served, the types of queries, and cache hit ratios.</p><figure data-asset-count="1">
  <div>
  <picture>
      
        <source srcset="https://images.stripeassets.com/fzn2n1nzq965/YT2kpJLcsMKx51g9n1NYH/1693a55cb9a2beec508f37a6757010a5/chart1-queries-736dfb101adbe87e9f0ddd5e157aafa399812373.png?w=1620&amp;q=80&amp;fm=webp" type="image/webp"/>
      

      

      <img alt="chart1" src="
        
          https://images.stripeassets.com/fzn2n1nzq965/YT2kpJLcsMKx51g9n1NYH/1693a55cb9a2beec508f37a6757010a5/chart1-queries-736dfb101adbe87e9f0ddd5e157aafa399812373.png?w=1620&amp;q=80
        
      " width="983" height="247" loading="lazy"/>
    </picture>
</div>
  
</figure><figure data-asset-count="1">
  <div>
  <picture>
      
        <source srcset="https://images.stripeassets.com/fzn2n1nzq965/5djN3O949DMbaLDY5x4mEZ/8f63589a85f2f3a64511886577e4d188/chart1-queries-by-type-c7b21ed0c56e0559f6e71784db2a664f75ec1e17.png?w=1620&amp;q=80&amp;fm=webp" type="image/webp"/>
      

      

      <img alt="chart2" src="
        
          https://images.stripeassets.com/fzn2n1nzq965/5djN3O949DMbaLDY5x4mEZ/8f63589a85f2f3a64511886577e4d188/chart1-queries-by-type-c7b21ed0c56e0559f6e71784db2a664f75ec1e17.png?w=1620&amp;q=80
        
      " width="983" height="247" loading="lazy"/>
    </picture>
</div>
  
</figure><figure data-asset-count="1">
  <div>
  <picture>
      
        <source srcset="https://images.stripeassets.com/fzn2n1nzq965/703lK6jWygkkMq4EQA7BCy/466f5517eabdb534f5f3e33b2c05451f/chart1-cache-hit-ratio-6ca82445c056c18269344a17ce8d5ab1c6ccdc43.png?w=1620&amp;q=80&amp;fm=webp" type="image/webp"/>
      

      

      <img alt="chart3" src="
        
          https://images.stripeassets.com/fzn2n1nzq965/703lK6jWygkkMq4EQA7BCy/466f5517eabdb534f5f3e33b2c05451f/chart1-cache-hit-ratio-6ca82445c056c18269344a17ce8d5ab1c6ccdc43.png?w=1620&amp;q=80
        
      " width="983" height="247" loading="lazy"/>
    </picture>
</div>
  
</figure><figure data-asset-count="1">
  <div>
  <picture>
      
        <source srcset="https://images.stripeassets.com/fzn2n1nzq965/6ABNacuCIKPUjGEU4AmVmW/7d6b6f9ad1b2497d5d594c2895bd9af1/chart1-request-list-depth-f11aec68784e373a4158f794b5c890bf25e08bbd.png?w=1620&amp;q=80&amp;fm=webp" type="image/webp"/>
      

      

      <img alt="chart4" src="
        
          https://images.stripeassets.com/fzn2n1nzq965/6ABNacuCIKPUjGEU4AmVmW/7d6b6f9ad1b2497d5d594c2895bd9af1/chart1-request-list-depth-f11aec68784e373a4158f794b5c890bf25e08bbd.png?w=1620&amp;q=80
        
      " width="983" height="247" loading="lazy"/>
    </picture>
</div>
  
</figure><p>We recently observed that for several minutes every hour, the cluster’s DNS servers were returning SERVFAIL responses for a small percentage of internal requests. SERVFAIL is a generic response that DNS servers return when an error occurs, but it doesn’t tell us much about what caused the error.</p><figure data-asset-count="1">
  <div>
  <picture>
      
        <source srcset="https://images.stripeassets.com/fzn2n1nzq965/DmsurQtdAK9X5lwD09UbS/8debb58c3fcf81f0233e02830d9a3960/servfail-responses-1f3731aca3cd55c0412b69e4b3aa07bc1b2579f7.png?w=1620&amp;q=80&amp;fm=webp" type="image/webp"/>
      

      

      <img alt="chart5" src="
        
          https://images.stripeassets.com/fzn2n1nzq965/DmsurQtdAK9X5lwD09UbS/8debb58c3fcf81f0233e02830d9a3960/servfail-responses-1f3731aca3cd55c0412b69e4b3aa07bc1b2579f7.png?w=1620&amp;q=80
        
      " width="1082" height="412" loading="lazy"/>
    </picture>
</div>
  
</figure><p>Without much to go on initially, we found another clue in the request list depth metric. (You can think of this as Unbound’s internal todo list, where it keeps track of all the DNS requests it needs to resolve.)</p><figure data-asset-count="1">
  <div>
  <picture>
      
        <source srcset="https://images.stripeassets.com/fzn2n1nzq965/4EZz5Zq0yupvG2J73hDLvc/e9614715d5ef83eff9bf4e646db9eb44/request-list-depth-f6c410cf4f4c90d727265ad777a49227decd19bf.png?w=1620&amp;q=80&amp;fm=webp" type="image/webp"/>
      

      

      <img alt="chart6" src="
        
          https://images.stripeassets.com/fzn2n1nzq965/4EZz5Zq0yupvG2J73hDLvc/e9614715d5ef83eff9bf4e646db9eb44/request-list-depth-f6c410cf4f4c90d727265ad777a49227decd19bf.png?w=1620&amp;q=80
        
      " width="1084" height="412" loading="lazy"/>
    </picture>
</div>
  
</figure><p>An increase in this metric indicates that Unbound is unable to process messages in a timely fashion, which may be caused by an increase in load. However, the metrics didn’t show a significant increase in the number of DNS queries, and resource consumption didn’t appear to be hitting any limits. Since Unbound resolves queries by contacting external nameservers, another explanation could be that these upstream servers were taking longer to respond.</p><h2>Tracking down the source</h2><p>We followed this lead by logging into one of the DNS servers and inspecting Unbound’s request list.</p><p>This confirmed that requests were accumulating in the request list. We noticed some interesting details: most of the entries in the list corresponded to reverse DNS lookups (<a href="https://en.wikipedia.org/wiki/List_of_DNS_record_types#PTR" data-js-controller="AnalyticsButton" data-analytics-category="Links" data-analytics-action="Clicked" data-analytics-label="">PTR records</a>) and they were all waiting for a response from 10.0.0.2, which is the IP address of the VPC resolver.</p><p>We then used <a href="https://www.tcpdump.org/" data-js-controller="AnalyticsButton" data-analytics-category="Links" data-analytics-action="Clicked" data-analytics-label="">tcpdump</a> to capture the DNS traffic on one of the servers to get a better sense of what was happening and try to identify any patterns. We wanted to make sure we captured the traffic during one of these spikes, so we configured tcpdump to write data to files over a period of time. We split the files across 60 second collection intervals to keep file sizes small, which made it easier to work with them.</p><p>The packet captures revealed that during the hourly spike, 90% of requests made to the VPC resolver were reverse DNS queries for IPs in the 104.16.0.0/12 <a href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing" data-js-controller="AnalyticsButton" data-analytics-category="Links" data-analytics-action="Clicked" data-analytics-label="">CIDR range</a>. The vast majority of these queries failed with a SERVFAIL response. We used <a href="https://en.wikipedia.org/wiki/Dig_(command)" data-js-controller="AnalyticsButton" data-analytics-category="Links" data-analytics-action="Clicked" data-analytics-label="">dig</a> to query the VPC resolver with a few of these addresses and confirmed that it took longer to receive responses.</p><p>By looking at the source IPs of clients making the reverse DNS queries, we noticed they were all coming from hosts in our Hadoop cluster. We maintain a database of when Hadoop jobs start and finish, so we were able to correlate these times to the hourly spikes. We finally narrowed down the source of the traffic to one job that analyzes network activity logs and performs a reverse DNS lookup on the IP addresses found in those logs.</p><p>One more surprising detail we discovered in the tcpdump data was that the VPC resolver was not sending back responses to many of the queries. During one of the 60-second collection periods the DNS server sent 257,430 packets to the VPC resolver. The VPC resolver replied back with only 61,385 packets, which averages to 1,023 packets per second. We realized we may be hitting the <a href="https://docs.aws.amazon.com/vpc/latest/userguide/vpc-dns.html#vpc-dns-limits" data-js-controller="AnalyticsButton" data-analytics-category="Links" data-analytics-action="Clicked" data-analytics-label="">AWS limit</a> for how much traffic can be sent to a VPC resolver, which is 1,024 packets per second per interface. Our next step was to establish better visibility in our cluster to validate our hypothesis.</p><h2>Counting packets</h2><p>AWS exposes its VPC resolver through a <a href="https://docs.aws.amazon.com/vpc/latest/userguide/VPC_DHCP_Options.html#AmazonDNS" data-js-controller="AnalyticsButton" data-analytics-category="Links" data-analytics-action="Clicked" data-analytics-label="">static IP address</a> relative to the base IP of the VPC, plus two (for example, if the base IP is 10.0.0.0, then the VPC resolver will be at 10.0.0.2). We need to track the number of packets sent per second to this IP address. One tool that can help us here is <a href="https://en.wikipedia.org/wiki/Iptables" data-js-controller="AnalyticsButton" data-analytics-category="Links" data-analytics-action="Clicked" data-analytics-label="">iptables</a>, since it keeps track of the number of packets matched by a rule.</p><p>We created a rule that matches traffic headed to the VPC resolver IP address and added it to the <code>OUTPUT</code> chain, which is a set of iptables rules that are applied to all packets sent from the host.<code>
</code>We configured the rule to jump to a new chain called <code>VPC_RESOLVER</code> and added an empty rule to that chain. Since our hosts could contain other rules in the <code>OUTPUT</code> chain, we added this rule to isolate matches and make it a little easier to parse the output.</p><p>Listing the rules, we see the number of packets sent to the VPC resolver in the output:</p><p>With this, we wrote a simple service that reads the statistics from the <code>VPC_RESOLVER</code> chain and reports this value through our metrics pipeline.</p><p>Once we started collecting this metric, we could see that the hourly spikes in <code>SERVFAIL</code> responses lined up with periods where the servers were sending too much traffic to the VPC resolver.</p><figure data-asset-count="1">
  <div>
  <picture>
      
        <source srcset="https://images.stripeassets.com/fzn2n1nzq965/6zV4ZEvA8LO4p3Ex5Uy9l6/b59754c19077ad66b782cb5a2058d839/packets-per-second-692e98dd9a7b2dcdad8c3d86b1b291293af48955.png?w=1620&amp;q=80&amp;fm=webp" type="image/webp"/>
      

      

      <img alt="chart7" src="
        
          https://images.stripeassets.com/fzn2n1nzq965/6zV4ZEvA8LO4p3Ex5Uy9l6/b59754c19077ad66b782cb5a2058d839/packets-per-second-692e98dd9a7b2dcdad8c3d86b1b291293af48955.png?w=1620&amp;q=80
        
      " width="1638" height="412" loading="lazy"/>
    </picture>
</div>
  
</figure><h2>Traffic amplification</h2><p>The data we saw from iptables (the number of packets per second sent to the VPC resolver) indicated a significant increase in traffic to the VPC resolvers during these periods, and we wanted to better understand what was happening. Taking a closer look at the shape of the traffic coming into the DNS servers from the Hadoop job, we noticed the clients were sending the request five times for every failed reverse lookup. Since the reverse lookups were taking so long or being dropped at the server, the local caching resolver on each host was timing out and continually retrying the requests. On top of this, the DNS servers were also retrying requests, leading to request volume amplifying by an average of 7x.</p><figure data-asset-count="1">
  <div>
  <picture>
      
        <source srcset="https://images.stripeassets.com/fzn2n1nzq965/2Vi10HxfNjfn3xwDPGshhG/6f61eac6ab928c6119a88e45e121e2ac/diagram-2-73c73a6bce346000b4dc11d573166c526df38be1.png?w=1620&amp;q=80&amp;fm=webp" type="image/webp"/>
      

      

      <img alt="diagram" src="
        
          https://images.stripeassets.com/fzn2n1nzq965/2Vi10HxfNjfn3xwDPGshhG/6f61eac6ab928c6119a88e45e121e2ac/diagram-2-73c73a6bce346000b4dc11d573166c526df38be1.png?w=1620&amp;q=80
        
      " width="2080" height="1428" loading="lazy"/>
    </picture>
</div>
  
</figure><h2>Spreading the load</h2><p>One thing to remember is that the VPC resolver limit is imposed <em>per network interface</em>. Instead of performing the reverse lookups solely on our DNS servers, we could instead distribute the load and have each host contact the VPC resolver independently. With Unbound running on each host we can easily control this behavior. Unbound allows you to specify different forwarding rules per DNS zone. Reverse queries use the special domain <code>in-addr.arpa</code>, so configuring this behavior was a matter of adding a rule that forwards requests for this zone to the VPC resolver.</p><p>We knew that reverse lookups for private addresses stored in Route 53 would likely return faster than reverse lookups for public IPs that required communication with an external nameserver. So we decided to create two forwarding configurations, one for resolving private addresses (the <code>10.in-addr.arpa.</code> zone) and one for all other reverse queries (the <code>.in-addr.arpa.</code> zone). Both rules were configured to send requests to the VPC resolver. Unbound calculates <a href="https://nlnetlabs.nl/documentation/unbound/info-timeout/" data-js-controller="AnalyticsButton" data-analytics-category="Links" data-analytics-action="Clicked" data-analytics-label="">retry timeouts</a> based on a smoothed average of historical round trip times to upstream servers and maintains separate calculations per forwarding rule. Even if two rules share the same upstream destination the retry timeouts are computed independently, which helps isolate the impact of inconsistent query performance on timeout calculations.</p><p>After applying the forwarding configuration change to the local Unbound resolvers on the Hadoop nodes we saw that the hourly load spike to the VPC resolvers had gone away, eliminating the surge of <code>SERVFAILS</code> we were seeing:</p><figure data-asset-count="1">
  <div>
  <picture>
      
        <source srcset="https://images.stripeassets.com/fzn2n1nzq965/3iEiE80GjI6H3JwFtgDiXl/975e62ba0a722a29d62a07ddfcd25f01/packets-per-second-annotated-6dbc58c52db64a143df097a746791f654f09f9ca.png?w=1620&amp;q=80&amp;fm=webp" type="image/webp"/>
      

      

      <img alt="chart8" src="
        
          https://images.stripeassets.com/fzn2n1nzq965/3iEiE80GjI6H3JwFtgDiXl/975e62ba0a722a29d62a07ddfcd25f01/packets-per-second-annotated-6dbc58c52db64a143df097a746791f654f09f9ca.png?w=1620&amp;q=80
        
      " width="1638" height="412" loading="lazy"/>
    </picture>
</div>
  
</figure><p>Adding the VPC resolver packet rate metric gives us a more complete picture of what’s going on in our DNS infrastructure. It alerts us if we approach any resource limits and points us in the right direction when systems are unhealthy. Some other improvements we’re considering include collecting a rolling tcpdump of DNS traffic and periodically logging the output of some of Unbound’s debugging commands, such as the contents of the request list.</p><h2>Visibility into complex systems</h2><p>When operating such a critical piece of infrastructure like DNS, it’s crucial to understand the health of the various components of the system. The metrics and command line tools that Unbound provides gives us great visibility into one of the core components of our DNS systems. As we saw in this scenario, these types of investigations often uncover areas where monitoring can be improved, and it’s important to address these gaps to better prepare for incident response. Gathering data from multiple sources allows you to see what’s going on in the system from different angles, which can help you narrow in on the root cause during an investigation. This information will also identify if the remediations you put in place have the intended effect. As these systems grow to handle more scale and increase in complexity, how you monitor them must also evolve to understand how different components interact with each other and build confidence that your systems are operating effectively.</p>
  </section></div>
  </body>
</html>
