<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://buf.build/blog/hyperpb">Original</a>
    <h1>Hyperpb: 10x faster dynamic Protobuf parsing that&#39;s faster than generated code</h1>
    
    <div id="readability-page-1" class="page"><div><div id="single-article"><p>Today we’re announcing public availability of <a href="https://github.com/bufbuild/hyperpb-go" data-wf-native-id-path="0b04964f-f6f8-0038-c2ec-6e12bc060598" data-wf-ao-click-engagement-tracking="true" data-wf-element-id="0b04964f-f6f8-0038-c2ec-6e12bc060598">hyperpb</a>, a fully-dynamic Protobuf parser that is <strong>10x faster</strong> than <a href="https://pkg.go.dev/google.golang.org/protobuf/types/dynamicpb" data-wf-native-id-path="0b04964f-f6f8-0038-c2ec-6e12bc06059e" data-wf-ao-click-engagement-tracking="true" data-wf-element-id="0b04964f-f6f8-0038-c2ec-6e12bc06059e">dynamicpb</a>, the standard Go solution for dynamic Protobuf. In fact, it’s so efficient that it’s <strong>3x faster than parsing with generated code</strong>! It also matches or beats <a href="https://github.com/planetscale/vtprotobuf" data-wf-native-id-path="0b04964f-f6f8-0038-c2ec-6e12bc0605a4" data-wf-ao-click-engagement-tracking="true" data-wf-element-id="0b04964f-f6f8-0038-c2ec-6e12bc0605a4">vtprotobuf</a>’s generated code at almost every benchmark, without skimping on correctness.</p><p>Don’t believe us? We think our parsing benchmarks speak for themselves.</p><figure><p><img src="https://cdn.prod.website-files.com/6723e92f5d187330e4da8144/68791beebdc5f3f2e221d721_Misc.png" loading="lazy" alt=""/></p></figure><p>Here, we show two benchmark variants for hyperpb: out-of-the-box performance with no optimizations turned on, and real-time profile-guided optimization (PGO) with all optimizations we currently offer enabled.</p><p>This may seem like a niche issue. However, at Buf we believe that <a href="https://buf.build/blog/kafka-schema-driven-development" data-wf-native-id-path="e90a4be1-d7ba-9d25-98f8-e47e8165bfef" data-wf-ao-click-engagement-tracking="true" data-wf-element-id="e90a4be1-d7ba-9d25-98f8-e47e8165bfef">schema-driven development</a> is the future, and this means enabling services that are generic over <em>all</em> Protobuf message types.</p><p>Building a dynamic Protobuf parser with the throughput to match (or outperform) ahead-of-time generated code unlocks enormous possibilities. Products that were previously not possible at scale become ordinary, even essential.</p><p>Specifically, hyperpb enables us to process and validate large amounts of arbitrary streamed data in a type-aware manner. This is a bottleneck we encountered while building <a href="https://buf.build/product/bufstream" data-wf-native-id-path="604052bf-a51b-c93c-8b88-068463b447fe" data-wf-ao-click-engagement-tracking="true" data-wf-element-id="604052bf-a51b-c93c-8b88-068463b447fe">Bufstream</a>.</p><h2>Broker-side validation</h2><p>We have long been vocal about client-side validation in the world of Kafka. The downstream costs of invalid data slipping into a topic are very high, since it introduces server-side failure modes — but the high compute cost of broker-side validation is often cited as the reason for mitigating data corruption on an ongoing basis. This is the real reason that broker-side, schema-aware validation isn’t a big-ticket item for the big cloud players: they can’t figure it out.</p><p>But we can’t accept the status quo.</p><p>We built Bufstream to enable broker-side validation with Protobuf, an industry standard for high-performance, schema-enforced serialization. We also maintain <a href="https://github.com/bufbuild/protovalidate" data-wf-native-id-path="e90a4be1-d7ba-9d25-98f8-e47e8165c001" data-wf-ao-click-engagement-tracking="true" data-wf-element-id="e90a4be1-d7ba-9d25-98f8-e47e8165c001">Protovalidate</a>, the gold-standard semantic validation library for Protobuf. In a nutshell, Bufstream uses schemas to parse incoming data from our customers, and runs Protovalidate on the result, to determine whether or not the data producer sent us a bad message. The poor state of dynamic Protobuf parsing would otherwise make this process slow and resource-intensive.</p><p>Fortunately, Buf employs most of the world’s Protobuf experts. One of them is Miguel Young de la Sota, a compiler engineer who previously worked on Protobuf’s compiler, as well as the C++ and Rust runtimes. Seeing a major optimization opportunity, he set out to solve this problem in Go, once and for all.</p><p>The result is hyperpb, capable of handling all proto2, proto3, and editions-mode schemas, with a perfect match against Protobuf Go.</p><h2>How it works, in a nutshell</h2><p>hyperpb requires you to compile a parser at runtime, much like a regular expression library. The compilation step is pretty slow, because it’s an optimizing compiler!</p><p>Messages built from the compilation output can be used like any other Protobuf message type. They can be manipulated using reflection, much like <code>dynamicpb.Message</code>.</p><pre contenteditable="false"><code><span>package</span><span> main
</span>
<span></span><span>import</span><span> (
</span><span>    </span><span>&#34;fmt&#34;</span><span>
</span><span>    </span><span>&#34;log&#34;</span><span>
</span>
<span>    </span><span>&#34;buf.build/go/hyperpb&#34;</span><span>
</span><span>    </span><span>&#34;google.golang.org/protobuf/proto&#34;</span><span>
</span>
<span>    weatherv1 </span><span>&#34;buf.build/gen/go/bufbuild/hyperpb-examples/protocolbuffers/go/example/weather/v1&#34;</span><span>
</span>)
<!-- -->
<span></span><span>// Byte slice representation of a valid *weatherv1.WeatherReport.</span><span>
</span><span></span><span>var</span><span> weatherDataBytes = []</span><span>byte</span><span>{
</span><span>    </span><span>0x0a</span><span>, </span><span>0x07</span><span>, </span><span>0x53</span><span>, </span><span>0x65</span><span>, </span><span>0x61</span><span>, </span><span>0x74</span><span>, </span><span>0x74</span><span>, </span><span>0x6c</span><span>,
</span><span>    </span><span>0x65</span><span>, </span><span>0x12</span><span>, </span><span>0x1d</span><span>, </span><span>0x0a</span><span>, </span><span>0x05</span><span>, </span><span>0x4b</span><span>, </span><span>0x41</span><span>, </span><span>0x44</span><span>,
</span><span>    </span><span>0x39</span><span>, </span><span>0x33</span><span>, </span><span>0x15</span><span>, </span><span>0x66</span><span>, </span><span>0x86</span><span>, </span><span>0x22</span><span>, </span><span>0x43</span><span>, </span><span>0x1d</span><span>,
</span><span>    </span><span>0xcd</span><span>, </span><span>0xcc</span><span>, </span><span>0x34</span><span>, </span><span>0x41</span><span>, </span><span>0x25</span><span>, </span><span>0xd7</span><span>, </span><span>0xa3</span><span>, </span><span>0xf0</span><span>,
</span><span>    </span><span>0x41</span><span>, </span><span>0x2d</span><span>, </span><span>0x33</span><span>, </span><span>0x33</span><span>, </span><span>0x13</span><span>, </span><span>0x40</span><span>, </span><span>0x30</span><span>, </span><span>0x03</span><span>,
</span><span>    </span><span>0x12</span><span>, </span><span>0x1d</span><span>, </span><span>0x0a</span><span>, </span><span>0x05</span><span>, </span><span>0x4b</span><span>, </span><span>0x48</span><span>, </span><span>0x42</span><span>, </span><span>0x36</span><span>,
</span><span>    </span><span>0x30</span><span>, </span><span>0x15</span><span>, </span><span>0xcd</span><span>, </span><span>0x8c</span><span>, </span><span>0x22</span><span>, </span><span>0x43</span><span>, </span><span>0x1d</span><span>, </span><span>0x33</span><span>,
</span><span>    </span><span>0x33</span><span>, </span><span>0x5b</span><span>, </span><span>0x41</span><span>, </span><span>0x25</span><span>, </span><span>0x52</span><span>, </span><span>0xb8</span><span>, </span><span>0xe0</span><span>, </span><span>0x41</span><span>,
</span><span>    </span><span>0x2d</span><span>, </span><span>0x33</span><span>, </span><span>0x33</span><span>, </span><span>0xf3</span><span>, </span><span>0x3f</span><span>, </span><span>0x30</span><span>, </span><span>0x03</span><span>,
</span>}
<!-- -->
<span></span><span>func</span><span> </span><span>main</span><span>()</span><span> {
</span><span>    </span><span>// Compile a type for your message. Make sure to cache this!</span><span>
</span><span>    </span><span>// Here, we&#39;re using a compiled-in descriptor.</span><span>
</span>    msgType := hyperpb.CompileMessageDescriptor(
<span>        (*weatherv1.WeatherReport)(</span><span>nil</span><span>).ProtoReflect().Descriptor(),
</span>    )
<!-- -->
<span>    </span><span>// Allocate a fresh message using that type.</span><span>
</span>    msg := hyperpb.NewMessage(msgType)
<!-- -->
<span>    </span><span>// Parse the message, using proto.Unmarshal like any other message type.</span><span>
</span><span>    </span><span>if</span><span> err := proto.Unmarshal(weatherDataBytes, msg); err != </span><span>nil</span><span> {
</span><span>        </span><span>// Handle parse failure.</span><span>
</span><span>        log.Fatalf(</span><span>&#34;failed to parse weather data: %v&#34;</span><span>, err)
</span>    }
<!-- -->
<span>    </span><span>// Use reflection to read some fields. hyperpb currently only supports access</span><span>
</span><span>    </span><span>// by reflection. You can also look up fields by index using fields.Get(), which</span><span>
</span><span>    </span><span>// is less legible but doesn&#39;t hit a hashmap.</span><span>
</span>    fields := msgType.Descriptor().Fields()
<!-- -->
<span>    </span><span>// Get returns a protoreflect.Value, which can be printed directly...</span><span>
</span><span>    fmt.Println(msg.Get(fields.ByName(</span><span>&#34;region&#34;</span><span>)))
</span>
<span>    </span><span>// ... or converted to an explicit type to operate on, such as with List(),</span><span>
</span><span>    </span><span>// which converts a repeated field into something with indexing operations.</span><span>
</span><span>    stations := msg.Get(fields.ByName(</span><span>&#34;weather_stations&#34;</span><span>)).List()
</span><span>    </span><span>for</span><span> i := </span><span>range</span><span> stations.Len() {
</span><span>        </span><span>// Get returns a protoreflect.Value too, so we need to convert it into</span><span>
</span><span>        </span><span>// a message to keep extracting fields.</span><span>
</span>        station := stations.Get(i).Message()
<!-- -->        fields := station.Descriptor().Fields()
<!-- -->
<span>        </span><span>// Here we extract each of the fields we care about from the message.</span><span>
</span><span>        </span><span>// Again, we could use fields.Get if we know the indices.</span><span>
</span><span>        fmt.Println(</span><span>&#34;station:&#34;</span><span>, station.Get(fields.ByName(</span><span>&#34;station&#34;</span><span>)))
</span><span>        fmt.Println(</span><span>&#34;frequency:&#34;</span><span>, station.Get(fields.ByName(</span><span>&#34;frequency&#34;</span><span>)))
</span><span>        fmt.Println(</span><span>&#34;temperature:&#34;</span><span>, station.Get(fields.ByName(</span><span>&#34;temperature&#34;</span><span>)))
</span><span>        fmt.Println(</span><span>&#34;pressure:&#34;</span><span>, station.Get(fields.ByName(</span><span>&#34;pressure&#34;</span><span>)))
</span><span>        fmt.Println(</span><span>&#34;wind_speed:&#34;</span><span>, station.Get(fields.ByName(</span><span>&#34;wind_speed&#34;</span><span>)))
</span><span>        fmt.Println(</span><span>&#34;conditions:&#34;</span><span>, station.Get(fields.ByName(</span><span>&#34;conditions&#34;</span><span>)))
</span>    }
<!-- -->}</code></pre><p><code>hyperpb.CompileFileDescriptorSet</code> calls into hyperpb’s compiler, which lays out optimized structs for each message type to minimize memory usage (not unlike the new <a href="https://go.dev/blog/protobuf-opaque" data-wf-native-id-path="9933df2d-0daf-0f37-c0f3-43e8f4ecc63e" data-wf-ao-click-engagement-tracking="true" data-wf-element-id="9933df2d-0daf-0f37-c0f3-43e8f4ecc63e">Opaque API</a>, but more aggressive). It also generates a program for hyperpb’s parser, a carefully-optimized VM that interprets encoded Protobuf messages as its bytecode.</p><p>hyperpb also includes advanced features such as manual memory re-use, performance tuning knobs, “unsafe” modes, and profile-guided optimization. Profile-guided optimization in particular allows hyperpb to automatically tune its parser to the shape of data passing through your system in real time. This allows us to achieve another 50-100% more throughput.</p><h2>Releasing hyperpb</h2><p>hyperpb is a novel advancement in the state of the art for parsing Protobuf in pure Go. We developed a new approach to <em>table-driven parsing</em>, a paradigm first explored as a performance strategy by <a href="https://github.com/protocolbuffers/protobuf/tree/main/upb" data-wf-native-id-path="e90a4be1-d7ba-9d25-98f8-e47e8165c097" data-wf-ao-click-engagement-tracking="true" data-wf-element-id="e90a4be1-d7ba-9d25-98f8-e47e8165c097">UPB</a><strong>,</strong> a small C kernel for Protobuf runtimes.</p><p>So why release it into open source? Doesn’t this risk that our competitors might use it? We considered hyperpb a trade secret for a long time, and didn’t plan to open source it until recently. We changed our minds for a few reasons.</p><p>First, wider Protobuf adoption only helps our business and our mission. We have cultivated a reputation as the stewards of Protobuf in the industry. If you use Protobuf, you’ve at least heard of us. The largest companies in the world trust us to solve their Protobuf needs, be that with the <a href="https://buf.build/product/cli" data-wf-native-id-path="e90a4be1-d7ba-9d25-98f8-e47e8165c0a0" data-wf-ao-click-engagement-tracking="true" data-wf-element-id="e90a4be1-d7ba-9d25-98f8-e47e8165c0a0">Buf CLI</a>, the <a href="https://buf.build/product/bsr" data-wf-native-id-path="e90a4be1-d7ba-9d25-98f8-e47e8165c0a3" data-wf-ao-click-engagement-tracking="true" data-wf-element-id="e90a4be1-d7ba-9d25-98f8-e47e8165c0a3">BSR</a>, <a href="https://connectrpc.com/" data-wf-native-id-path="e90a4be1-d7ba-9d25-98f8-e47e8165c0a6" data-wf-ao-click-engagement-tracking="true" data-wf-element-id="e90a4be1-d7ba-9d25-98f8-e47e8165c0a6">Connect RPC</a>, or <a href="https://github.com/bufbuild/protovalidate" data-wf-native-id-path="e90a4be1-d7ba-9d25-98f8-e47e8165c0a9" data-wf-ao-click-engagement-tracking="true" data-wf-element-id="e90a4be1-d7ba-9d25-98f8-e47e8165c0a9">Protovalidate</a>.</p><p>When orgs try to send Protobuf over Kafka, sooner or later they’ll be talking to us, no matter what our competitors are selling; Protobuf will always be one of our core competencies. Redpanda, Confluent — come and get it. Getting more people on board with Protobuf and gRPC will always make us bigger in the end, and we’d love to open a dialogue with more of your customers.</p><p>Second, hyperpb is by far not our only innovation; we’ve been looking into this problem since last year, and internally we’re working on pushing the bleeding edge beyond what we’re releasing today. Thanks to hyperpb’s design, we can continue to improve its compiler and optimizations as we learn more about the types of schemas our customers need; much like a programing language compiler improves with feedback from its users.</p><p>Finally, our business is growing quickly, and we always have more irons in the fire than people to handle them. If your job is boring and novel work is of interest, get in touch at <a href="https://buf.build/careers" data-wf-native-id-path="e90a4be1-d7ba-9d25-98f8-e47e8165c0b2" data-wf-ao-click-engagement-tracking="true" data-wf-element-id="e90a4be1-d7ba-9d25-98f8-e47e8165c0b2">https://buf.build/careers</a>. We’d love to hear from you.</p><h2>Beyond release</h2><p>hyperpb is not magic; we’ve gone to great lengths to keep as much of the codebase understandable as possible (within the constraints of performance requirements). Miguel has a technical overview of hyperpb on his <a href="https://mcyoung.xyz/2025/07/16/hyperpb" data-wf-native-id-path="e90a4be1-d7ba-9d25-98f8-e47e8165c0b9" data-wf-ao-click-engagement-tracking="true" data-wf-element-id="e90a4be1-d7ba-9d25-98f8-e47e8165c0b9">performance optimization blog</a>. Additionally, in future posts, we look forward to discussing topics related to hyperpb’s implementation, including:</p><ul role="list"><li>Principles of table-driven parsing.</li><li>Threaded parser VM design.</li><li>Compiler optimizations, including profiling and sample collection.</li><li>How we make reflection as fast as possible.</li><li>Profile-driven layout optimizations.</li><li>Parsing repeated varint fields (incl. how we avoid decoding varints).</li><li>How our map implementation compares to Go’s.</li><li>Go compiler bugs we have to work around.</li><li>Debugging the threaded VM.</li></ul><h2>Stay Informed</h2><p>If you’d like to stay informed, subscribe to future blog posts, and <a href="https://github.com/bufbuild/hyperpb-go" data-wf-native-id-path="14da8206-9682-65b4-6068-b9228cb56e76" data-wf-ao-click-engagement-tracking="true" data-wf-element-id="14da8206-9682-65b4-6068-b9228cb56e76">watch and star hyperpb on GitHub</a>. Also feel free to <a href="https://buf.build/b/slack" data-wf-native-id-path="e6455617-0d9e-92c7-6bb2-878974d9ea50" data-wf-ao-click-engagement-tracking="true" data-wf-element-id="e6455617-0d9e-92c7-6bb2-878974d9ea50">join our Slack</a> to chat with us!</p></div></div></div>
  </body>
</html>
