<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://zelang-dev.github.io/c-events/">Original</a>
    <h1>C-events, yet another event loop, simpler, smaller, faster, safer</h1>
    
    <div id="readability-page-1" class="page"><div>
      <header>
        
        

        <ul>
          
            <li><a href="https://github.com/zelang-dev/c-events/zipball/main">Download ZIP</a></li>
            <li><a href="https://github.com/zelang-dev/c-events/tarball/main">Download TAR</a></li>
          
          <li><a href="https://github.com/zelang-dev/c-events">View On GitHub</a></li>
        </ul>

        
          
        

        
      </header>

      <section>
        

<p>A <em>tiny</em>, <em>lightning fast</em> <strong>event loop</strong>, utilizing single interface for <strong>epoll</strong>, <strong>kqueue</strong>, <strong>iocp</strong>.</p>

<p>This project takes up where <a href="https://github.com/kazuho/picoev">picoev</a> left off, it forks and remake, bringing in aspects from <a href="https://fastcgi-archives.github.io/FastCGI_A_High-Performance_Web_Server_Interface_FastCGI.html">FastCGI_A_High-Performance_Web_Server_Interface_FastCGI.html</a> source <a href="https://github.com/FastCGI-Archives/fcgi2">fcgi2</a>, specificity, how to make <strong>Windows</strong> <code>file descriptors</code> aka <em>fake</em> behave like on <strong>Linux</strong>. As such, this <strong>events</strong> library handles general non-blocking file I/O.</p>

<p>This system supports interfacing <a href="https://en.wikipedia.org/wiki/Epoll">epoll</a>, <a href="https://en.wikipedia.org/wiki/Kqueue">kqueue</a>, and <a href="https://en.wikipedia.org/wiki/Input/output_completion_port">iocp</a> <em>thru</em> <a href="https://github.com/piscisaureus/wepoll">wepoll</a>. In reading <a href="https://www.ulduzsoft.com/2014/01/practical-difference-between-epoll-and-windows-io-completion-ports-iocp/">Practical difference between epoll and Windows IO Completion Ports (IOCP)</a> discuss things where <strong>wepoll</strong> seem to fill.</p>

<p><strong>c-events</strong> provides function wrappers to some <strong>Linux</strong> like <em>functionality</em>, exp. <code>mkfifo</code> for <strong>Windows</strong>. However, this project is base around <em>adding/registering</em> an <code>event</code> for an <code>file descriptor</code>, and you reacting using general platform/OS calls.
It differs from <a href="https://software.schmorp.de/pkg/libev.html">libev</a>, <a href="https://software.schmorp.de/pkg/libeio.html">libeio</a>, <a href="https://libevent.org/">libevent</a>, and <a href="http://libuv.org/">libuv</a>. It <em>does not</em> provide complete handling using special functions. It’s more geared towards a supplement to <strong>libuv</strong>, for more finer grain control.</p>

<p>Some <strong>Libevent</strong> <a href="https://github.com/libevent/libevent/tree/master/sample">examples</a> and <a href="https://github.com/libevent/libevent/tree/master/test">tests</a> have been brought in and modified for <em>basic</em> testing this library.</p>

<h2 id="table-of-contents">Table of Contents</h2>

<ul>
  <li><a href="#features">Features</a>
    <ul>
      <li><a href="#todos">TODO’s</a></li>
    </ul>
  </li>
  <li><a href="#design">Design</a></li>
  <li><a href="#synopsis">Synopsis</a></li>
  <li><a href="#usage">Usage</a></li>
  <li><a href="#comparisons">Comparisons</a></li>
  <li><a href="#installation">Installation</a></li>
  <li><a href="#contributing">Contributing</a></li>
  <li><a href="#license">License</a></li>
</ul>

<h2 id="features">Features</h2>

<p><strong>events</strong> provides a mechanism to execute a callback function when a specific event occurs on a file descriptor or after a timeout has been reached. Every event represents a set of conditions, including:</p>

<ul>
  <li>A file descriptor being ready to read from or write to,
 <code>events_add(loop, listen_sock, EVENTS_READ | EVENTS_WRITE, 0, accept_callback, NULL)</code>.</li>
  <li>A file descriptor has close,
 <code>events_add(loop, listen_sock, EVENTS_READ | EVENTS_CLOSE, 0, accept_callback, NULL)</code>.</li>
  <li>A timeout expiring on file descriptor in <strong>5</strong> secods,
 <code>events_add(loop, listen_sock, EVENTS_READ | EVENTS_TIMEOUT, 5, accept_callback, NULL)</code>.</li>
  <li>A signal occurring,
 <code>events_add(loop, SIGINT, EVENTS_SIGNAL, 0, signal_cb, NULL)</code>.</li>
  <li>A user-triggered event, execute in <strong>500</strong> milliseconds,
 <code>actor_t *actor = events_actor(loop, 500, actor_cb, NULL)</code>, <code>events_repeat_actor(actor, seconds(2))</code>, <code>events_clear_actor(actor)</code>.</li>
</ul>

<p>Once you call <code>events_init(1024)</code> and <code>events_t *loop = events_create(60)</code> functions to set up <strong>c-events</strong> and associate it with an <em>event</em> ~loop~ <strong>thread pool</strong>, it becomes initialized. At this point, you can add ~file descriptors~, which makes it <em>active</em> in the <em>loop</em>.</p>

<p>When the conditions that would trigger an event occur (e.g., its file descriptor changes state or its timeout expires), the event becomes <em>ready</em>, and its (user-provided) callback function is run. All events are <em>persistent</em>, until <code>events_del(listen_sock)</code> is called, only user-triggered are one off, if not set to repeat. MUST call <code>events_once(loop, 5)</code> to monitor for changes, add a wait time in <em>seconds</em>, SHOULD be combined with <code>events_is_running(loop)</code> to ensure all events are captured.</p>

<h3 id="todos">TODO’s</h3>

<ul>
  <li>Convert <strong><a href="https://github.com/kazuho/picoev">picoev API</a></strong> to <strong>Events API</strong>, this removes the <strong>select(2)</strong> part of code base.</li>
  <li>Merge the <em>non-assembly</em> <strong>coroutine</strong> implementation from <a href="https://github.com/zelang-dev/c-raii">c-raii</a>.</li>
  <li>Merge <a href="https://github.com/piscisaureus/wepoll">wepoll</a>, a <strong>epoll</strong> emulation for <strong>Windows</strong>.</li>
  <li>Merge aspects of <strong><a href="https://github.com/FastCGI-Archives/fcgi2">fcgi2</a></strong>, the <em>pseudo file descriptors</em> creation implementation.</li>
  <li>Add/recreate <em>tests and examples</em> some derived from <strong><a href="https://github.com/libevent/libevent">libevent</a></strong>.</li>
  <li>Bug fix <em>tests and examples</em> for proper execution under <strong>Windows</strong> and <strong>Linux</strong>.</li>
  <li>Bug fix <em>tests and examples</em> for proper execution under <strong>Apple macOS</strong>.</li>
  <li>Complete implementation of <code>events_addtasks_pool()</code>, a <em>thread pool</em> creation function for <strong>Events API</strong> only.</li>
  <li>Complete implementation of a <strong>Linux</strong> <code>inotify_add_watch()</code> function for <strong>Windows</strong>.</li>
  <li>Complete implementation of <code>inotify_add_watch()</code> for <strong>Apple macOS</strong>.</li>
  <li>Implement <em>event</em> <code>EVENTS_FILEWATCH</code>, <code>EVENTS_DIRWATCH</code> <em>file descriptor</em> condition, for handling <code>inotify_add_watch()</code>.</li>
  <li>Completion of ALL OS <em>file system</em> function routines with matching <strong>thread</strong> ~async_fs_~ <em>version</em>.</li>
</ul>

<h2 id="design">Design</h2>

<p>This implementation is similar to what I call an outline, <em>how a coroutine should behave with an Event Loop interface</em>, as described in <strong>libev</strong> <a href="http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod#THREADS_COROUTINES_CONTINUATIONS_QUE">THREADS, COROUTINES, CONTINUATIONS, QUEUES… INSTEAD OF CALLBACKS</a> section.</p>

<p>The design layout is derived from the current <em>work in progress</em> in developing <a href="https://github.com/zelang-dev/c-asio">c-asio</a>. This was initially setup to supplement usage of using <strong>libuv</strong>, since they document there <strong>Event Loop API</strong> <code>handle</code> isn’t really <em>thread safe</em>. Few things needed reimplementing, in doing so, it revealed, <em>libuv</em> has much overhead not needed, see <a href="#comparisons">Comparisons</a>.</p>

<p>The basics of this project is base around the state of the <strong>file descriptor</strong>. In order to formulate execution of asynchrony aka concurrency, a <em>coroutine</em> like behavior is needed. It makes using <strong>epoll</strong>, <strong>kqueue</strong> or any <strong>multiplex</strong> interface system more <em>effective</em>. As just, all the additional memory allocations for structures not necessary. This includes another project <a href="https://github.com/zelang-dev/c-raii">c-raii</a>, the <strong>coroutine</strong> aspect merged in, with a few things handled and named differently now, seems some bugs was addressed with unnecessary workarounds, but now fixed correctly with less work.</p>

<p>Most function signatures are the same, just <strong>passthru</strong> to the <strong>Operating System</strong>. In order to get cross-platform like behavior, many calls are macros pointing to internal functions to cache parameters, and redirect to correct <strong>OS</strong> routine, mostly for Windows.</p>

<p>The Operating System <strong>file descriptor</strong> is represented by <code>fds_t</code> and <code>filefd_t</code>. For Windows, this system will create a <code>pseudo fd</code> that actually has all <a href="https://learn.microsoft.com/en-us/windows/win32/fileio/i-o-concepts">Windows event system</a> <strong>mechanisms</strong> <em>attached</em>. This action allows the creation of simpler a alternative <em>Linux</em> functions for <em>Windows</em> like <code>mkfifo()</code> <strong>IPC</strong>, and still in development <code>inotify_add_watch()</code> <strong>file/directory monitor</strong>, with same signatures. It’s also the basics for <code>spawn()</code> <strong>child process</strong> <em>input/output</em> control. The functions <code>events_new_fd()</code> and <code>events_assign_fd()</code> was mainly for <strong>Windows</strong>,  but also available for <strong>Linux</strong> using <a href="https://man7.org/linux/man-pages/man2/eventfd.2.html">eventfd</a> interface, and <strong>Apple macOS</strong> using <a href="https://developer.apple.com/documentation/darwinnotify">Darwin Notify</a> functionality.</p>

<p>This would also allow nonblocking file system handling. But for cross-platform simplicity, everything is a <em>pass-thru</em> to a thread pool instead. A default of <code>1</code>, which is automatically created with first <code>events_create()</code> <strong>loop</strong> <code>events_t</code> handle. An thread pool <code>os_worker_t</code> is created by calling <code>events_add_pool()</code> with a <strong>loop</strong> handle. The <code>os_worker_t</code> must be pass as first parameter to standard file system functions, a few currently implemented, all prefixed as <strong>~async_fs_~</strong>. These functions constructed as a wrapper call to <code>queue_work()</code> in coroutine to call thread handler. Using <code>events_add_pool()</code> is intended for <em>FileSystem/CPU</em> intensive workload offloading, NO actual <strong>Events API</strong> should be run in another thread, using this <em>thread pool</em>. That can be achieved using <code>events_addtasks_pool()</code>, see <a href="#todos">TODO’s</a>.</p>

<p>The <em>behavior/process</em> of coroutine <em>execution</em> in <strong>c-raii</strong> is setup for <em>automatically</em> creating/moving and putting <strong>coroutines</strong> in different <em>threads</em>. In which intergrating <strong>libuv</strong> into <strong>c-asio</strong> that feature had to be completely disabled on first <code>yield()</code> encounter, it’s possibale, but reqquire more complexity or <strong>thread local storage</strong> introduction to <strong>libuv</strong> source, a major breaking change. Where <code>events_addtasks_pool()</code> create a <code>os_tasks_t</code> thread pool, will be for explicitly running <strong>Events API</strong> in another <em>thread</em>.</p>

<p>The following “simple TCP proxy” example demonstrate the simplicity of using <code>events_add()</code> by way of a <code>async_wait()</code> call. The <code>read()</code> and <code>write()</code> functions only has <code>async_wait</code> called added. These routines only work correctly when user set <strong>file descriptor</strong> to <em>non-blocking</em>. The standard process of creating a <strong>socket</strong> is in embedded in <code>async_listener()</code>, <code>async_connect()</code>, <code>async_accept()</code>, and are the only functions that will set <strong>non-blocking</strong> by default. Functions <code>async_connect</code>, <code>async_accept</code> includes a <code>async_wait</code> call.</p>

<p><strong>Run:</strong></p>

<div><div><pre><code>tcp_proxy 1234 www.google.com 80
</code></pre></div></div>

<p><strong>Then visit <a href="http://localhost:1234/">http://localhost:1234/</a> and see Google.</strong></p>

<div><div><pre><code><span>#include</span> <span>&lt;events.h&gt;</span><span>
</span>
<span>char</span> <span>*</span><span>server</span><span>;</span>
<span>int</span> <span>local</span><span>,</span> <span>port</span><span>;</span>

<span>void</span> <span>*</span><span>rwtask</span><span>(</span><span>param_t</span> <span>v</span><span>)</span> <span>{</span>
 <span>int</span> <span>*</span><span>a</span><span>,</span> <span>rfd</span><span>,</span> <span>wfd</span><span>,</span> <span>n</span><span>;</span>
 <span>char</span> <span>buf</span><span>[</span><span>2048</span><span>];</span>

 <span>a</span> <span>=</span> <span>v</span><span>-&gt;</span><span>int_ptr</span><span>;</span>
 <span>rfd</span> <span>=</span> <span>a</span><span>[</span><span>0</span><span>];</span>
 <span>wfd</span> <span>=</span> <span>a</span><span>[</span><span>1</span><span>];</span>
 <span>free</span><span>(</span><span>a</span><span>);</span>

 <span>while</span> <span>((</span><span>n</span> <span>=</span> <span>async_read</span><span>(</span><span>rfd</span><span>,</span> <span>buf</span><span>,</span> <span>sizeof</span> <span>buf</span><span>))</span> <span>&gt;</span> <span>0</span><span>)</span>
  <span>async_write</span><span>(</span><span>wfd</span><span>,</span> <span>buf</span><span>,</span> <span>n</span><span>);</span>

 <span>shutdown</span><span>(</span><span>wfd</span><span>,</span> <span>SHUT_WR</span><span>);</span>
 <span>close</span><span>(</span><span>rfd</span><span>);</span>

 <span>return</span> <span>0</span><span>;</span>
<span>}</span>

<span>int</span> <span>*</span><span>mkfd2</span><span>(</span><span>int</span> <span>fd1</span><span>,</span> <span>int</span> <span>fd2</span><span>)</span> <span>{</span>
 <span>int</span> <span>*</span><span>a</span><span>;</span>

 <span>a</span> <span>=</span> <span>malloc</span><span>(</span><span>2</span> <span>*</span> <span>sizeof</span> <span>a</span><span>[</span><span>0</span><span>]);</span>
 <span>if</span> <span>(</span><span>a</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
  <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;out of memory</span><span>\n</span><span>&#34;</span><span>);</span>
  <span>abort</span><span>();</span>
 <span>}</span>
 <span>a</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>fd1</span><span>;</span>
 <span>a</span><span>[</span><span>1</span><span>]</span> <span>=</span> <span>fd2</span><span>;</span>

 <span>return</span> <span>a</span><span>;</span>
<span>}</span>

<span>void</span> <span>*</span><span>proxytask</span><span>(</span><span>param_t</span> <span>v</span><span>)</span> <span>{</span>
 <span>int</span> <span>fd</span><span>,</span> <span>remotefd</span><span>;</span>

 <span>fd</span> <span>=</span> <span>v</span><span>-&gt;</span><span>integer</span><span>;</span>
 <span>if</span> <span>((</span><span>remotefd</span> <span>=</span> <span>async_connect</span><span>(</span><span>server</span><span>,</span> <span>port</span><span>,</span> <span>true</span><span>))</span> <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
  <span>perror</span><span>(</span><span>&#34;async_connect&#34;</span><span>);</span>
  <span>close</span><span>(</span><span>fd</span><span>);</span>
  <span>return</span> <span>0</span><span>;</span>
 <span>}</span>

 <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;</span><span>\n</span><span>connected to %s:%d&#34;</span><span>CLR_LN</span><span>,</span> <span>server</span><span>,</span> <span>port</span><span>);</span>

 <span>async_task</span><span>(</span><span>rwtask</span><span>,</span> <span>1</span><span>,</span> <span>mkfd2</span><span>(</span><span>fd</span><span>,</span> <span>remotefd</span><span>));</span>
 <span>async_task</span><span>(</span><span>rwtask</span><span>,</span> <span>1</span><span>,</span> <span>mkfd2</span><span>(</span><span>remotefd</span><span>,</span> <span>fd</span><span>));</span>

 <span>return</span> <span>0</span><span>;</span>
<span>}</span>

<span>void</span> <span>*</span><span>main_main</span><span>(</span><span>param_t</span> <span>args</span><span>)</span> <span>{</span>
 <span>fds_t</span> <span>cfd</span><span>,</span> <span>fd</span><span>;</span>
 <span>int</span> <span>rport</span><span>;</span>
 <span>char</span> <span>remote</span><span>[</span><span>16</span><span>];</span>

 <span>local</span> <span>=</span> <span>atoi</span><span>(</span><span>args</span><span>[</span><span>0</span><span>].</span><span>char_ptr</span><span>);</span>
 <span>server</span> <span>=</span> <span>args</span><span>[</span><span>1</span><span>].</span><span>char_ptr</span><span>;</span>
 <span>port</span> <span>=</span> <span>atoi</span><span>(</span><span>args</span><span>[</span><span>2</span><span>].</span><span>char_ptr</span><span>);</span>

 <span>if</span> <span>((</span><span>fd</span> <span>=</span> <span>async_listener</span><span>(</span><span>OS_NULL</span><span>,</span> <span>local</span><span>,</span> <span>true</span><span>))</span> <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
  <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;cannot listen on tcp port %d: %s</span><span>\n</span><span>&#34;</span><span>,</span> <span>local</span><span>,</span> <span>strerror</span><span>(</span><span>errno</span><span>));</span>
  <span>exit</span><span>(</span><span>1</span><span>);</span>
 <span>}</span>

 <span>while</span> <span>((</span><span>cfd</span> <span>=</span> <span>async_accept</span><span>(</span><span>fd</span><span>,</span> <span>remote</span><span>,</span> <span>&amp;</span><span>rport</span><span>))</span> <span>&gt;=</span> <span>0</span><span>)</span> <span>{</span>
  <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;connection from %s:%d&#34;</span><span>CLR_LN</span><span>,</span> <span>remote</span><span>,</span> <span>rport</span><span>);</span>
  <span>async_task</span><span>(</span><span>proxytask</span><span>,</span> <span>1</span><span>,</span> <span>casting</span><span>(</span><span>cfd</span><span>));</span>
 <span>}</span>

 <span>return</span> <span>0</span><span>;</span>
<span>}</span>

<span>int</span> <span>main</span><span>(</span><span>int</span> <span>argc</span><span>,</span> <span>char</span> <span>**</span><span>argv</span><span>)</span> <span>{</span>
 <span>if</span> <span>(</span><span>argc</span> <span>!=</span> <span>4</span><span>)</span> <span>{</span>
  <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;usage: tcpproxy localport server remoteport</span><span>\n</span><span>&#34;</span><span>);</span>
  <span>exit</span><span>(</span><span>1</span><span>);</span>
 <span>}</span>

 <span>events_init</span><span>(</span><span>1024</span><span>);</span>
 <span>events_t</span> <span>*</span><span>loop</span> <span>=</span> <span>events_create</span><span>(</span><span>6</span><span>);</span>
 <span>async_task</span><span>(</span><span>main_main</span><span>,</span> <span>3</span><span>,</span> <span>argv</span><span>[</span><span>1</span><span>],</span> <span>argv</span><span>[</span><span>2</span><span>],</span> <span>argv</span><span>[</span><span>3</span><span>]);</span>
 <span>async_run</span><span>(</span><span>loop</span><span>);</span>
 <span>events_destroy</span><span>(</span><span>loop</span><span>);</span>

 <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<h2 id="synopsis">Synopsis</h2>

<div><div><pre><code><span>/* Setup custom internal memory allocation handling. */</span>
<span>C_API</span> <span>int</span> <span>events_set_allocator</span><span>(</span><span>malloc_func</span><span>,</span> <span>realloc_func</span><span>,</span> <span>calloc_func</span><span>,</span> <span>free_func</span><span>);</span>

<span>/* Sets I/O on the given fd to be non-blocking. */</span>
<span>C_API</span> <span>int</span> <span>events_set_nonblocking</span><span>(</span><span>fds_t</span> <span>fd</span><span>);</span>

<span>/* Creates a new event loop (defined by each backend). */</span>
<span>C_API</span> <span>events_t</span> <span>*</span><span>events_create</span><span>(</span><span>int</span> <span>max_timeout</span><span>);</span>

<span>/* Destroys a loop (defined by each backend). */</span>
<span>C_API</span> <span>int</span> <span>events_destroy</span><span>(</span><span>events_t</span> <span>*</span><span>loop</span><span>);</span>

<span>/* Initializes events. */</span>
<span>C_API</span> <span>int</span> <span>events_init</span><span>(</span><span>int</span> <span>max_fd</span><span>);</span>

<span>/* Deinitializes events. */</span>
<span>C_API</span> <span>void</span> <span>events_deinit</span><span>(</span><span>void</span><span>);</span>

<span>/* Registers a descriptor, with event, timeout, and callback argument to event loop. */</span>
<span>C_API</span> <span>int</span> <span>events_add</span><span>(</span><span>events_t</span> <span>*</span><span>loop</span><span>,</span> <span>fds_t</span> <span>sfd</span><span>,</span> <span>int</span> <span>events</span><span>,</span> <span>int</span> <span>timeout_in_secs</span><span>,</span> <span>events_cb</span> <span>callback</span><span>,</span> <span>void</span> <span>*</span><span>);</span>

<span>/* Unregister a file descriptor from event loop. */</span>
<span>C_API</span> <span>int</span> <span>events_del</span><span>(</span><span>fds_t</span> <span>sfd</span><span>);</span>

<span>/* Check if `fd` is registered. */</span>
<span>C_API</span> <span>bool</span> <span>events_is_registered</span><span>(</span><span>events_t</span> <span>*</span><span>loop</span><span>,</span> <span>fds_t</span> <span>sfd</span><span>);</span>

<span>/* Check if any `events` still running. */</span>
<span>C_API</span> <span>bool</span> <span>events_is_running</span><span>(</span><span>events_t</span> <span>*</span><span>loop</span><span>);</span>

<span>/* Updates timeout. */</span>
<span>C_API</span> <span>void</span> <span>events_set_timeout</span><span>(</span><span>fds_t</span> <span>sfd</span><span>,</span> <span>int</span> <span>secs</span><span>);</span>

<span>/* Sets events to be watched for given desriptor. */</span>
<span>C_API</span> <span>int</span> <span>events_set_event</span><span>(</span><span>fds_t</span> <span>sfd</span><span>,</span> <span>int</span> <span>event</span><span>);</span>

<span>/* Execute `event loop`, waiting `max_wait` for ~events~, `0` WILL check return immediately.
WILL return `number` of active `events`, or `-1` to indicate error condition.*/</span>
<span>C_API</span> <span>int</span> <span>events_once</span><span>(</span><span>events_t</span> <span>*</span><span>loop</span><span>,</span> <span>int</span> <span>max_wait</span><span>);</span>

<span>/* Tries to query the system for current time using `MONOTONIC` clock,
 or whatever method ~system/platform~ provides for `REALTIME`. */</span>
<span>C_API</span> <span>uint64_t</span> <span>events_now</span><span>(</span><span>void</span><span>);</span>
<span>C_API</span> <span>actor_t</span> <span>*</span><span>events_repeat_actor</span><span>(</span><span>actor_t</span> <span>*</span><span>actor</span><span>,</span> <span>int</span> <span>ms</span><span>);</span>
<span>C_API</span> <span>actor_t</span> <span>*</span><span>events_actor</span><span>(</span><span>events_t</span> <span>*</span><span>loop</span><span>,</span> <span>int</span> <span>ms</span><span>,</span> <span>actor_cb</span> <span>timer</span><span>,</span> <span>void</span> <span>*</span><span>args</span><span>);</span>
<span>C_API</span> <span>void</span> <span>events_clear_actor</span><span>(</span><span>actor_t</span> <span>*</span><span>actor</span><span>);</span>
<span>C_API</span> <span>events_t</span> <span>*</span><span>events_actor_loop</span><span>(</span><span>actor_t</span> <span>*</span><span>actor</span><span>);</span>
<span>C_API</span> <span>events_t</span> <span>*</span><span>events_loop</span><span>(</span><span>fds_t</span> <span>sfd</span><span>);</span>
<span>C_API</span> <span>int</span> <span>events_timeofday</span><span>(</span><span>struct</span> <span>timeval</span> <span>*</span><span>,</span> <span>struct</span> <span>timezone</span> <span>*</span><span>);</span>
<span>C_API</span> <span>fd_types</span> <span>events_fd_type</span><span>(</span><span>int</span> <span>fd</span><span>);</span>
<span>C_API</span> <span>sys_signal_t</span> <span>*</span><span>events_signals</span><span>(</span><span>void</span><span>);</span>

<span>/**
 * Set up for I/O descriptor masquerading.
 * Entry in `fdTable` is reserved to represent the socket/file.
 *
 * @returns
 * - `pseudo fd` an index `id`, which masquerades as a UNIX-style
 * &#34;small non-negative integer&#34; file/socket descriptor.
 *
 * - `-1` indicates failure.
 *
 */</span>
<span>C_API</span> <span>int</span> <span>events_new_fd</span><span>(</span><span>FILE_TYPE</span> <span>type</span><span>,</span> <span>int</span> <span>fd</span><span>,</span> <span>int</span> <span>desiredFd</span><span>);</span>

<span>/**
 * Set pseudo FD to create the `I/O completion port on Windows`
 * or `on Unix` to set `eventfd` to be used for async I/O.
 *
 */</span>
<span>C_API</span> <span>bool</span> <span>events_assign_fd</span><span>(</span><span>filefd_t</span> <span>handle</span><span>,</span> <span>int</span> <span>pseudo</span><span>);</span>

<span>/**
 * Free I/O descriptor entry in `fdTable`.
 */</span>
<span>C_API</span> <span>void</span> <span>events_free_fd</span><span>(</span><span>int</span> <span>pseudo</span><span>);</span>
<span>C_API</span> <span>uint32_t</span> <span>events_get_fd</span><span>(</span><span>int</span> <span>pseudo</span><span>);</span>
<span>C_API</span> <span>bool</span> <span>events_valid_fd</span><span>(</span><span>int</span> <span>pseudo</span><span>);</span>
<span>C_API</span> <span>int</span> <span>events_pseudo_fd</span><span>(</span><span>const</span> <span>char</span> <span>*</span><span>name</span><span>);</span>
<span>C_API</span> <span>void</span> <span>events_abort</span><span>(</span><span>const</span> <span>char</span> <span>*</span><span>message</span><span>,</span> <span>const</span> <span>char</span> <span>*</span><span>file</span><span>,</span> <span>int</span> <span>line</span><span>,</span> <span>const</span> <span>char</span> <span>*</span><span>function</span><span>);</span>

<span>/* Suspends the execution of current `Generator/Coroutine`, and passing ~data~.
WILL PANIC if not an ~Generator~ function called in.
WILL `yield` current `task` until ~data~ is retrived using `yielded()`. */</span>
<span>C_API</span> <span>void</span> <span>yielding</span><span>(</span><span>void</span> <span>*</span><span>);</span>

<span>/* Creates an `Generator task` of given function with arguments,
MUST use `yielding()` to pass data, and `yielded()` to get data. */</span>
<span>C_API</span> <span>generator_t</span> <span>generator</span><span>(</span><span>param_func_t</span><span>,</span> <span>size_t</span><span>,</span> <span>...);</span>

<span>/* Resume specified ~generator task~, returning data from `yielding`. */</span>
<span>C_API</span> <span>values_t</span> <span>yielded</span><span>(</span><span>generator_t</span><span>);</span>

<span>/* Return `generator id` in scope for last `yielded()` execution. */</span>
<span>C_API</span> <span>uint32_t</span> <span>gen_id</span><span>(</span><span>void</span><span>);</span>

<span>/* Return ~handle~ to current `task`. */</span>
<span>C_API</span> <span>tasks_t</span> <span>*</span><span>active_task</span><span>(</span><span>void</span><span>);</span>

<span>/* Yield execution to another `task` and ~reschedule~ current.

NOTE: This switches to thread ~schedular~ `run queue` to `execute` next `task`. */</span>
<span>C_API</span> <span>void</span> <span>yield_task</span><span>(</span><span>void</span><span>);</span>

<span>/* Suspends the execution of current `task`, and switch to the ~scheduler~. */</span>
<span>C_API</span> <span>void</span> <span>suspend_task</span><span>(</span><span>void</span><span>);</span>

<span>/* Explicitly give up the CPU for at least ms milliseconds.
Other tasks continue to run during this time.

- returns the actual amount of time slept, in milliseconds.

NOTE: Current `task` added to ~thread~ `sleep` queue,
will be added back to `thread` ~schedular~ `run queue` once `ms` expire. */</span>
<span>C_API</span> <span>uint32_t</span> <span>sleep_task</span><span>(</span><span>uint32_t</span> <span>ms</span><span>);</span>

<span>/* Returns result of an completed `task`, by `result id`.
Must call `task_is_ready()` or `task_is_terminated()` for ~completion~ status. */</span>
<span>C_API</span> <span>values_t</span> <span>results_for</span><span>(</span><span>uint32_t</span> <span>id</span><span>);</span>

<span>/* Creates/initialize the next series/collection of `task&#39;s` created to be part of `task group`,
same behavior of Go&#39;s `waitGroups`.

All `task` here behaves like regular functions, meaning they return values,
and indicate a terminated/finish status.

The initialization ends when `tasks_wait()` is called, as such current `task` will pause,
and execution will begin and wait for the group of `tasks` to finished. */</span>
<span>C_API</span> <span>task_group_t</span> <span>*</span><span>task_group</span><span>(</span><span>void</span><span>);</span>

 <span>/* Pauses current `task`, and begin execution of `tasks` in `task_group_t` object,
will wait for all to finish.

Returns `array` of `results id`, accessible using `results_for()` function. */</span>
<span>C_API</span> <span>array_t</span> <span>tasks_wait</span><span>(</span><span>task_group_t</span> <span>*</span><span>);</span>
<span>C_API</span> <span>size_t</span> <span>tasks_count</span><span>(</span><span>task_group_t</span> <span>*</span><span>wg</span><span>);</span>

<span>/* Return the unique `result id` for the current `task`. */</span>
<span>C_API</span> <span>uint32_t</span> <span>task_id</span><span>(</span><span>void</span><span>);</span>

<span>/* Check for `task` termination that has an result available. */</span>
<span>C_API</span> <span>bool</span> <span>task_is_ready</span><span>(</span><span>uint32_t</span> <span>id</span><span>);</span>

<span>/* Check for `task` termination/return. */</span>
<span>C_API</span> <span>bool</span> <span>task_is_terminated</span><span>(</span><span>tasks_t</span> <span>*</span><span>);</span>

<span>/* Print an `task` internal data state, only active in `debug` builds. */</span>
<span>C_API</span> <span>void</span> <span>tasks_info</span><span>(</span><span>tasks_t</span> <span>*</span><span>t</span><span>,</span> <span>int</span> <span>pos</span><span>);</span>

<span>/* Return `current` task ~user_data~. */</span>
<span>C_API</span> <span>void</span> <span>*</span><span>task_data</span><span>(</span><span>void</span><span>);</span>
<span>C_API</span> <span>int</span> <span>task_err_code</span><span>(</span><span>void</span><span>);</span>
<span>C_API</span> <span>ptrdiff_t</span> <span>task_code</span><span>(</span><span>void</span><span>);</span>

<span>/* Set tasks `user_data`, a ~per~ `task` storage place,
use for a `this` like object behavior. */</span>
<span>C_API</span> <span>void</span> <span>task_data_set</span><span>(</span><span>tasks_t</span> <span>*</span><span>t</span><span>,</span> <span>void</span> <span>*</span><span>data</span><span>);</span>

<span>/* Get tasks `user_data`, a ~per~ `task` storage place,
use for a `this` like object behavior. */</span>
<span>C_API</span> <span>void</span> <span>*</span><span>task_data_get</span><span>(</span><span>tasks_t</span> <span>*</span><span>t</span><span>);</span>

<span>/* Sets the current `task&#39;s` name.*/</span>
<span>C_API</span> <span>void</span> <span>task_name</span><span>(</span><span>char</span> <span>*</span><span>fmt</span><span>,</span> <span>...);</span>
<span>C_API</span> <span>size_t</span> <span>tasks_cpu_count</span><span>(</span><span>void</span><span>);</span>

<span>/* Check for at least `n` bytes left on the stack.
If not present, `abort` stack overflow has happen. */</span>
<span>C_API</span> <span>void</span> <span>tasks_stack_check</span><span>(</span><span>int</span> <span>n</span><span>);</span>

<span>/* Register an `event loop` handle to an `new` thread pool `os_worker_t` instance,
for `blocking` cpu ~system~ handling calls. */</span>
<span>C_API</span> <span>os_worker_t</span> <span>*</span><span>events_add_pool</span><span>(</span><span>events_t</span> <span>*</span><span>loop</span><span>);</span>
<span>C_API</span> <span>os_tasks_t</span> <span>*</span><span>events_addtasks_pool</span><span>(</span><span>events_t</span> <span>*</span><span>loop</span><span>);</span>

<span>/* Return `current` thread pool handle. */</span>
<span>C_API</span> <span>os_worker_t</span> <span>*</span><span>events_pool</span><span>(</span><span>void</span><span>);</span>

<span>/* This runs the function `fn` in thread `thrd` pool,
asynchronously in a separate `task`. Returns a `result id`
that will eventually hold the result of ~thread pool work~.

Similar to: https://en.cppreference.com/w/cpp/thread/async.html
https://en.cppreference.com/w/cpp/thread/packaged_task.html

MUST call `await_for()` to get any result.

NOTE: This is setup to be just an `pass thru` for any function in an separate thread. */</span>
<span>C_API</span> <span>uint32_t</span> <span>queue_work</span><span>(</span><span>os_worker_t</span> <span>*</span><span>thrd</span><span>,</span> <span>param_func_t</span> <span>fn</span><span>,</span> <span>size_t</span> <span>num_args</span><span>,</span> <span>...);</span>

<span>/* This waits aka `yield` until the `result id` termination, then retrieves
the value stored. This is mainly for `queue_work()`, but also useful elsewhere.

Similar to: https://en.cppreference.com/w/cpp/thread/future/get.html
and https://en.cppreference.com/w/cpp/thread/future/valid.html */</span>
<span>C_API</span> <span>values_t</span> <span>await_for</span><span>(</span><span>uint32_t</span> <span>id</span><span>);</span>

<span>/* Creates and returns an `result id`, for an ~coroutine~ aka `task`
of given `function` with `number` of args, then `arguments`.

NOTE: The `task` will be added to `current` thread ~schedular~ `run queue`,
same behavior as GoLang&#39;s `Go` statement. */</span>
<span>C_API</span> <span>uint32_t</span> <span>async_task</span><span>(</span><span>param_func_t</span> <span>fn</span><span>,</span> <span>uint32_t</span> <span>num_of_args</span><span>,</span> <span>...);</span>

<span>/*  Low-level call sitting underneath `async_read` and `async_write`.
 Puts task to ~sleep~ while waiting for I/O to be possible on `fd`.

 `rw` specifies type of I/O:
 - &#39;r&#39; means read
 - &#39;w&#39; means write

 Anything else means just exceptional conditions (hang up, etc.)
 The `&#39;r&#39;` and `&#39;w&#39;` also wake up for exceptional conditions. */</span>
<span>C_API</span> <span>void</span> <span>async_wait</span><span>(</span><span>int</span> <span>fd</span><span>,</span> <span>int</span> <span>rw</span><span>);</span>

<span>/* Run until there are no more `tasks` left, WILL execute `loop` events. */</span>
<span>C_API</span> <span>void</span> <span>async_run</span><span>(</span><span>events_t</span> <span>*</span><span>loop</span><span>);</span>

<span>/** Like regular `read()`, but puts task to ~sleep~ while waiting for
 data instead of blocking the whole program. */</span>
<span>C_API</span> <span>int</span> <span>async_read</span><span>(</span><span>int</span> <span>fd</span><span>,</span> <span>void</span> <span>*</span><span>buf</span><span>,</span> <span>int</span> <span>n</span><span>);</span>

<span>/** Like `async_read()` but always calls `async_wait()` before reading. */</span>
<span>C_API</span> <span>int</span> <span>async_read2</span><span>(</span><span>int</span> <span>fd</span><span>,</span> <span>void</span> <span>*</span><span>buf</span><span>,</span> <span>int</span> <span>n</span><span>);</span>

<span>/** Like regular `write()`, but puts task to ~sleep~ while waiting to
 write data instead of blocking the whole program. */</span>
<span>C_API</span> <span>int</span> <span>async_write</span><span>(</span><span>int</span> <span>fd</span><span>,</span> <span>void</span> <span>*</span><span>buf</span><span>,</span> <span>int</span> <span>n</span><span>);</span>

<span>/** Start a ~network~ listener `server` running on ~address~,
`port` number, with protocol, `proto_tcp` determents either TCP or UDP.

The ~address~ is a string version of a `host name` or `IP` address.
If `host name`, automatically calls `async_gethostbyname()` to preform a non-blocking DNS lockup.
If ~address~ is NULL, will bind to the given `port` on all available interfaces.

- Returns a `fd` to use with `async_accept()`. */</span>
<span>C_API</span> <span>fds_t</span> <span>async_listener</span><span>(</span><span>char</span> <span>*</span><span>server</span><span>,</span> <span>int</span> <span>port</span><span>,</span> <span>bool</span> <span>proto_tcp</span><span>);</span>

<span>/** Sleep `current` task, until next `client` connection comes in from `fd` ~async_listener()~.

- If `server` not NULL, it MUST be a buffer of `16 bytes` to hold remote IP address.
- If `port` not NULL, it&#39;s filled with report port.

Returns a `connected` ~client~ `fd`, SHOULD be used in an new `task` instance for handling.*/</span>
<span>C_API</span> <span>fds_t</span> <span>async_accept</span><span>(</span><span>fds_t</span> <span>fd</span><span>,</span> <span>char</span> <span>*</span><span>server</span><span>,</span> <span>int</span> <span>*</span><span>port</span><span>);</span>

<span>/** Create a ~new~ connection to `hostname`, port, with protocol,
`proto_tcp` determents either TCP or UDP.

- Hostname can be an `ip` address or a `domain name`.
- If `domain name`, automatically calls `async_gethostbyname()` to preform a non-blocking DNS lockup. */</span>
<span>C_API</span> <span>fds_t</span> <span>async_connect</span><span>(</span><span>char</span> <span>*</span><span>hostname</span><span>,</span> <span>int</span> <span>port</span><span>,</span> <span>bool</span> <span>proto_tcp</span><span>);</span>

<span>/* Return `ip` address from `async_gethostbyname()` execution. */</span>
<span>C_API</span> <span>char</span> <span>*</span><span>gethostbyname_ip</span><span>(</span><span>struct</span> <span>hostent</span> <span>*</span><span>host</span><span>);</span>

<span>/** Preform a non-blocking DNS lockup in separate `thrd` thread ~pool~ provided,
 returns ~struct~ `hostent` address. */</span>
<span>C_API</span> <span>struct</span> <span>hostent</span> <span>*</span><span>async_get_hostbyname</span><span>(</span><span>os_worker_t</span> <span>*</span><span>thrd</span><span>,</span> <span>char</span> <span>*</span><span>hostname</span><span>);</span>

<span>/** Preform a non-blocking DNS lockup in separate `thread`,
 returns ~struct~ `hostent` address. */</span>
<span>C_API</span> <span>struct</span> <span>hostent</span> <span>*</span><span>async_gethostbyname</span><span>(</span><span>char</span> <span>*</span><span>hostname</span><span>);</span>

<span>C_API</span> <span>int</span> <span>async_get_addrinfo</span><span>(</span><span>os_worker_t</span> <span>*</span><span>thrd</span><span>,</span> <span>const</span> <span>char</span> <span>*</span><span>name</span><span>,</span>
 <span>const</span> <span>char</span> <span>*</span><span>service</span><span>,</span> <span>const</span> <span>struct</span> <span>addrinfo</span> <span>*</span><span>hints</span><span>,</span> <span>addrinfo_t</span> <span>result</span><span>);</span>

<span>C_API</span> <span>int</span> <span>async_getaddrinfo</span><span>(</span><span>const</span> <span>char</span> <span>*</span><span>name</span><span>,</span>
 <span>const</span> <span>char</span> <span>*</span><span>service</span><span>,</span> <span>const</span> <span>struct</span> <span>addrinfo</span> <span>*</span><span>hints</span><span>,</span> <span>addrinfo_t</span> <span>result</span><span>);</span>

<span>C_API</span> <span>int</span> <span>async_fs_open</span><span>(</span><span>os_worker_t</span> <span>*</span><span>thrd</span><span>,</span> <span>const</span> <span>char</span> <span>*</span><span>path</span><span>,</span> <span>int</span> <span>flag</span><span>,</span> <span>int</span> <span>mode</span><span>);</span>
<span>C_API</span> <span>int</span> <span>fs_open</span><span>(</span><span>const</span> <span>char</span> <span>*</span><span>path</span><span>,</span> <span>int</span> <span>flag</span><span>,</span> <span>int</span> <span>mode</span><span>);</span>

<span>C_API</span> <span>int</span> <span>async_fs_read</span><span>(</span><span>os_worker_t</span> <span>*</span><span>thrd</span><span>,</span> <span>int</span> <span>fd</span><span>,</span> <span>void</span> <span>*</span><span>buf</span><span>,</span> <span>uint32_t</span> <span>count</span><span>);</span>
<span>C_API</span> <span>int</span> <span>fs_read</span><span>(</span><span>int</span> <span>fd</span><span>,</span> <span>void</span> <span>*</span><span>buf</span><span>,</span> <span>uint32_t</span> <span>count</span><span>);</span>

<span>C_API</span> <span>int</span> <span>async_fs_write</span><span>(</span><span>os_worker_t</span> <span>*</span><span>thrd</span><span>,</span> <span>int</span> <span>fd</span><span>,</span> <span>const</span> <span>void</span> <span>*</span><span>buf</span><span>,</span> <span>uint32_t</span> <span>count</span><span>);</span>
<span>C_API</span> <span>int</span> <span>fs_write</span><span>(</span><span>int</span> <span>fd</span><span>,</span> <span>const</span> <span>void</span> <span>*</span><span>buf</span><span>,</span> <span>uint32_t</span> <span>count</span><span>);</span>

<span>C_API</span> <span>ssize_t</span> <span>async_fs_sendfile</span><span>(</span><span>os_worker_t</span> <span>*</span><span>thrd</span><span>,</span> <span>int</span> <span>fd_out</span><span>,</span> <span>int</span> <span>fd_in</span><span>,</span> <span>off_t</span> <span>*</span><span>offset</span><span>,</span> <span>size_t</span> <span>length</span><span>);</span>
<span>C_API</span> <span>ssize_t</span> <span>fs_sendfile</span><span>(</span><span>int</span> <span>fd_out</span><span>,</span> <span>int</span> <span>fd_in</span><span>,</span> <span>off_t</span> <span>*</span><span>offset</span><span>,</span> <span>size_t</span> <span>length</span><span>);</span>

<span>C_API</span> <span>int</span> <span>async_fs_close</span><span>(</span><span>os_worker_t</span> <span>*</span><span>thrd</span><span>,</span> <span>int</span> <span>fd</span><span>);</span>
<span>C_API</span> <span>int</span> <span>fs_close</span><span>(</span><span>int</span> <span>fd</span><span>);</span>

<span>C_API</span> <span>int</span> <span>async_fs_unlink</span><span>(</span><span>os_worker_t</span> <span>*</span><span>thrd</span><span>,</span> <span>const</span> <span>char</span> <span>*</span><span>path</span><span>);</span>
<span>C_API</span> <span>int</span> <span>fs_unlink</span><span>(</span><span>const</span> <span>char</span> <span>*</span><span>path</span><span>);</span>

<span>C_API</span> <span>int</span> <span>async_fs_stat</span><span>(</span><span>os_worker_t</span> <span>*</span><span>thrd</span><span>,</span> <span>const</span> <span>char</span> <span>*</span><span>path</span><span>,</span> <span>struct</span> <span>stat</span> <span>*</span><span>st</span><span>);</span>
<span>C_API</span> <span>int</span> <span>fs_stat</span><span>(</span><span>const</span> <span>char</span> <span>*</span><span>path</span><span>,</span> <span>struct</span> <span>stat</span> <span>*</span><span>st</span><span>);</span>

<span>C_API</span> <span>int</span> <span>async_fs_access</span><span>(</span><span>os_worker_t</span> <span>*</span><span>thrd</span><span>,</span> <span>const</span> <span>char</span> <span>*</span><span>path</span><span>,</span> <span>int</span> <span>mode</span><span>);</span>
<span>C_API</span> <span>int</span> <span>fs_access</span><span>(</span><span>const</span> <span>char</span> <span>*</span><span>path</span><span>,</span> <span>int</span> <span>mode</span><span>);</span>

<span>C_API</span> <span>bool</span> <span>fs_exists</span><span>(</span><span>const</span> <span>char</span> <span>*</span><span>path</span><span>);</span>
<span>C_API</span> <span>size_t</span> <span>fs_filesize</span><span>(</span><span>const</span> <span>char</span> <span>*</span><span>path</span><span>);</span>

<span>C_API</span> <span>execinfo_t</span> <span>*</span><span>spawn</span><span>(</span><span>const</span> <span>char</span> <span>*</span><span>command</span><span>,</span> <span>const</span> <span>char</span> <span>*</span><span>args</span><span>,</span> <span>spawn_cb</span> <span>io_func</span><span>,</span> <span>exit_cb</span> <span>exit_func</span><span>);</span>
<span>C_API</span> <span>uintptr_t</span> <span>spawn_pid</span><span>(</span><span>execinfo_t</span> <span>*</span><span>child</span><span>);</span>
<span>C_API</span> <span>bool</span> <span>spawn_is_finish</span><span>(</span><span>execinfo_t</span> <span>*</span><span>child</span><span>);</span>
</code></pre></div></div>

<h2 id="usage">Usage</h2>

<p>Besides all <em>code snippets</em> above, this <em>example</em> recreate <strong>Google’s</strong> <a href="https://gobyexample.com/waitgroups">waitGroups</a> of <strong>goroutine’s</strong>.</p>

<table>
<tbody><tr>

<td>
<pre><code>
#include &#34;events.h&#34;

void *worker(param_t args) {
 int id = args[0].integer;
 printf(&#34;Worker %d starting, task id: #%d\n&#34;, id, task_id());

 sleep_task(seconds(1));

 printf(LN_CLR&#34;Worker %d done, task id: #%d\n&#34;, id, task_id());
 return 0;
}

void *main_main(param_t args) {
 int i;

 task_group_t *wg = task_group();
 for (i = 1; i &lt;= 5; i++) {
  async_task(worker, 1, i);
 }
 tasks_wait(wg);

 return 0;
}

int main(int argc, char **argv) {
 events_init(1024);
 async_task(main_main, 0);
 events_t *loop = events_create(6);
 async_run(loop);
 events_destroy(loop);

 return 0;
}
</code></pre>
</td>

<td>
<pre><code>
package main

import (
 &#34;fmt&#34;
 &#34;sync&#34;
 &#34;time&#34;
)

func worker(id int) {
 fmt.Printf(&#34;Worker %d starting\n&#34;, id)

 time.Sleep(time.Second)

 fmt.Printf(&#34;Worker %d done\n&#34;, id)
}

func main() {

 var wg sync.WaitGroup

 for i := 1; i &lt;= 5; i++ {
  wg.Add(1)

  i := i

  go func() {
   defer wg.Done()
   worker(i)
   }()
  }

  wg.Wait()
}
</code></pre>
</td>

</tr>
</tbody></table>

<h2 id="comparisons">Comparisons</h2>

<p>Same functions and behavior of Linux’s <code>mkfifo</code> for Windows also, minor changes in <strong>libevent</strong> <a href="https://github.com/libevent/libevent/blob/release-2.2.1-alpha/sample/event-read-fifo.c">event-read-fifo</a> sample, where it states <strong>Windows</strong> sections don’t work.</p>

<div><div><pre><code><span>#include</span> <span>&#34;events.h&#34;</span><span>
</span>
<span>static</span> <span>void</span> <span>fifo_read</span><span>(</span><span>fds_t</span> <span>fd</span><span>,</span> <span>int</span> <span>event</span><span>,</span> <span>void</span> <span>*</span><span>arg</span><span>)</span> <span>{</span>
 <span>char</span> <span>buf</span><span>[</span><span>255</span><span>];</span>
 <span>int</span> <span>len</span><span>;</span>

 <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;fifo_read called with fd: %d, event: %d, arg: %p</span><span>\n</span><span>&#34;</span><span>,</span> <span>socket2fd</span><span>(</span><span>fd</span><span>),</span> <span>event</span><span>,</span> <span>arg</span><span>);</span>
 <span>len</span> <span>=</span> <span>read</span><span>(</span><span>fd</span><span>,</span> <span>buf</span><span>,</span> <span>sizeof</span><span>(</span><span>buf</span><span>)</span> <span>-</span> <span>1</span><span>);</span>
 <span>if</span> <span>(</span><span>len</span> <span>&lt;=</span> <span>0</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>len</span> <span>==</span> <span>-</span><span>1</span><span>)</span>
   <span>perror</span><span>(</span><span>&#34;read&#34;</span><span>);</span>
  <span>else</span> <span>if</span> <span>(</span><span>len</span> <span>==</span> <span>0</span><span>)</span>
   <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;Connection closed</span><span>\n</span><span>&#34;</span><span>);</span>
  <span>events_del</span><span>(</span><span>fd</span><span>);</span>
  <span>return</span><span>;</span>
 <span>}</span>

 <span>buf</span><span>[</span><span>len</span><span>]</span> <span>=</span> <span>&#39;\0&#39;</span><span>;</span>
 <span>fprintf</span><span>(</span><span>stdout</span><span>,</span> <span>&#34;Read: %s</span><span>\n</span><span>&#34;</span><span>,</span> <span>buf</span><span>);</span>
<span>}</span>

<span>static</span> <span>void</span> <span>signal_cb</span><span>(</span><span>fds_t</span> <span>sig</span><span>,</span> <span>int</span> <span>event</span><span>,</span> <span>void</span> <span>*</span><span>arg</span><span>)</span> <span>{</span>
 <span>events_t</span> <span>*</span><span>loop</span> <span>=</span> <span>events_loop</span><span>(</span><span>sig</span><span>);</span>
 <span>unlink</span><span>(</span><span>mkfifo_name</span><span>());</span>
 <span>events_destroy</span><span>(</span><span>loop</span><span>);</span>
<span>}</span>

<span>int</span> <span>main</span><span>(</span><span>int</span> <span>argc</span><span>,</span> <span>char</span> <span>**</span><span>argv</span><span>)</span> <span>{</span>
 <span>events_t</span> <span>*</span><span>base</span><span>;</span>
 <span>struct</span> <span>stat</span> <span>st</span><span>;</span>
 <span>const</span> <span>char</span> <span>*</span><span>fifo</span> <span>=</span> <span>&#34;event.fifo&#34;</span><span>;</span>
 <span>int</span> <span>socket</span><span>;</span>

 <span>if</span> <span>(</span><span>lstat</span><span>(</span><span>fifo</span><span>,</span> <span>&amp;</span><span>st</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
  <span>if</span> <span>((</span><span>st</span><span>.</span><span>st_mode</span> <span>&amp;</span> <span>S_IFMT</span><span>)</span> <span>==</span> <span>S_IFREG</span><span>)</span> <span>{</span>
   <span>errno</span> <span>=</span> <span>EEXIST</span><span>;</span>
   <span>perror</span><span>(</span><span>&#34;lstat&#34;</span><span>);</span>
   <span>exit</span><span>(</span><span>1</span><span>);</span>
  <span>}</span>
 <span>}</span>

 <span>unlink</span><span>(</span><span>fifo</span><span>);</span>
 <span>if</span> <span>(</span><span>mkfifo</span><span>(</span><span>fifo</span><span>,</span> <span>0600</span><span>)</span> <span>==</span> <span>-</span><span>1</span><span>)</span> <span>{</span>
  <span>perror</span><span>(</span><span>&#34;mkfifo&#34;</span><span>);</span>
  <span>exit</span><span>(</span><span>1</span><span>);</span>
 <span>}</span>

 <span>/* Initialize the event library */</span>
 <span>base</span> <span>=</span> <span>events_create</span><span>(</span><span>6</span><span>);</span>

 <span>socket</span> <span>=</span> <span>open</span><span>(</span><span>fifo</span><span>,</span> <span>O_RDWR</span> <span>|</span> <span>O_NONBLOCK</span><span>,</span> <span>0</span><span>);</span>
 <span>if</span> <span>(</span><span>socket</span> <span>==</span> <span>-</span><span>1</span><span>)</span> <span>{</span>
  <span>perror</span><span>(</span><span>&#34;open&#34;</span><span>);</span>
  <span>unlink</span><span>(</span><span>mkfifo_name</span><span>());</span>
  <span>events_destroy</span><span>(</span><span>base</span><span>);</span>
  <span>exit</span><span>(</span><span>1</span><span>);</span>
 <span>}</span>

 <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;Write data to %s</span><span>\n</span><span>&#34;</span><span>,</span> <span>mkfifo_name</span><span>());</span>

 <span>/* catch SIGINT so that event.fifo can be cleaned up*/</span>
 <span>events_add</span><span>(</span><span>base</span><span>,</span> <span>SIGINT</span><span>,</span> <span>EVENTS_SIGNAL</span><span>,</span> <span>0</span><span>,</span> <span>signal_cb</span><span>,</span> <span>NULL</span><span>);</span>

 <span>/* Initialize one event */</span>
 <span>events_add</span><span>(</span><span>base</span><span>,</span> <span>socket</span><span>,</span> <span>EVENTS_READ</span><span>,</span> <span>0</span><span>,</span> <span>fifo_read</span><span>,</span> <span>NULL</span><span>);</span>

 <span>while</span> <span>(</span><span>events_is_running</span><span>(</span><span>base</span><span>))</span> <span>{</span>
  <span>events_once</span><span>(</span><span>base</span><span>,</span> <span>1</span><span>);</span>
 <span>}</span>

 <span>close</span><span>(</span><span>socket</span><span>);</span>
 <span>unlink</span><span>(</span><span>fifo</span><span>);</span>
 <span>events_destroy</span><span>(</span><span>base</span><span>);</span>

 <span>return</span> <span>(</span><span>0</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>A much simpler version of <strong>libuv</strong> <a href="https://github.com/libuv/libuv/blob/master/docs/code/dns/main.c">dns</a> example. This is same as <strong>c-asio</strong> <a href="https://github.com/zelang-dev/c-asio/tree/main/examples/dns.c">https://github.com/zelang-dev/c-asio/tree/main/examples/dns.c</a> intergrating <strong>libuv</strong>.</p>

<div><div><pre><code><span>#include</span> <span>&#34;events.h&#34;</span><span>
</span>
<span>void</span> <span>*</span><span>main_main</span><span>(</span><span>param_t</span> <span>args</span><span>)</span> <span>{</span>
 <span>char</span> <span>text</span><span>[</span><span>1024</span><span>]</span> <span>=</span> <span>{</span><span>0</span><span>};</span>
 <span>int</span> <span>len</span><span>;</span>
 <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;irc.libera.chat is...&#34;</span><span>CLR_LN</span><span>);</span>
 <span>struct</span> <span>hostent</span> <span>*</span><span>dns</span> <span>=</span> <span>async_gethostbyname</span><span>(</span><span>&#34;irc.libera.chat&#34;</span><span>);</span>

 <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;%s&#34;</span><span>CLR_LN</span><span>,</span> <span>gethostbyname_ip</span><span>(</span><span>dns</span><span>));</span>
 <span>fds_t</span> <span>server</span> <span>=</span> <span>async_connect</span><span>(</span><span>gethostbyname_ip</span><span>(</span><span>dns</span><span>),</span> <span>6667</span><span>,</span> <span>true</span><span>);</span>
 <span>while</span> <span>((</span><span>len</span> <span>=</span> <span>async_read</span><span>(</span><span>server</span><span>,</span> <span>text</span><span>,</span> <span>sizeof</span><span>(</span><span>text</span><span>))</span> <span>&gt;</span> <span>0</span><span>))</span> <span>{</span>
  <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>CLR</span><span>&#34;%s&#34;</span><span>,</span> <span>text</span><span>);</span>
  <span>memset</span><span>(</span><span>text</span><span>,</span> <span>0</span><span>,</span> <span>sizeof</span><span>(</span><span>text</span><span>));</span>
 <span>}</span>

 <span>return</span> <span>0</span><span>;</span>
<span>}</span>

<span>int</span> <span>main</span><span>(</span><span>int</span> <span>argc</span><span>,</span> <span>char</span> <span>**</span><span>argv</span><span>)</span> <span>{</span>
 <span>events_init</span><span>(</span><span>1024</span><span>);</span>
 <span>events_t</span> <span>*</span><span>loop</span> <span>=</span> <span>events_create</span><span>(</span><span>6</span><span>);</span>
 <span>async_task</span><span>(</span><span>main_main</span><span>,</span> <span>0</span><span>);</span>
 <span>async_run</span><span>(</span><span>loop</span><span>);</span>
 <span>events_destroy</span><span>(</span><span>loop</span><span>);</span>

 <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>A much simpler version of <strong>libuv</strong> <a href="https://github.com/libuv/libuv/blob/master/docs/code/uvcat/main.c">uvcat</a> example. This is same as <strong>c-asio</strong> <a href="https://github.com/zelang-dev/c-asio/tree/main/examples/uvcat.c">https://github.com/zelang-dev/c-asio/tree/main/examples/uvcat.c</a> intergrating <strong>libuv</strong>.</p>

<div><div><pre><code><span>#include</span> <span>&#34;events.h&#34;</span><span>
</span>
<span>void</span> <span>*</span><span>main_main</span><span>(</span><span>param_t</span> <span>args</span><span>)</span> <span>{</span>
 <span>char</span> <span>text</span><span>[</span><span>1024</span><span>];</span>
 <span>int</span> <span>len</span><span>,</span> <span>fd</span> <span>=</span> <span>fs_open</span><span>(</span><span>args</span><span>[</span><span>0</span><span>].</span><span>const_char_ptr</span><span>,</span> <span>O_RDONLY</span><span>,</span> <span>0</span><span>);</span>
 <span>if</span> <span>(</span><span>fd</span> <span>&gt;</span> <span>0</span><span>)</span> <span>{</span>
  <span>if</span> <span>((</span><span>len</span> <span>=</span> <span>fs_read</span><span>(</span><span>fd</span><span>,</span> <span>text</span><span>,</span> <span>sizeof</span><span>(</span><span>text</span><span>)))</span> <span>&gt;</span> <span>0</span><span>)</span>
   <span>fs_write</span><span>(</span><span>STDOUT_FILENO</span><span>,</span> <span>text</span><span>,</span> <span>len</span><span>);</span>

  <span>return</span> <span>casting</span><span>(</span><span>fs_close</span><span>(</span><span>fd</span><span>));</span>
 <span>}</span>

 <span>return</span> <span>casting</span><span>(</span><span>fd</span><span>);</span>
<span>}</span>

<span>int</span> <span>main</span><span>(</span><span>int</span> <span>argc</span><span>,</span> <span>char</span> <span>**</span><span>argv</span><span>)</span> <span>{</span>
 <span>if</span> <span>(</span><span>argc</span> <span>&lt;</span> <span>2</span><span>)</span> <span>{</span>
  <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;usage: _cat filepath</span><span>\n</span><span>&#34;</span><span>);</span>
  <span>exit</span><span>(</span><span>1</span><span>);</span>
 <span>}</span>

 <span>events_init</span><span>(</span><span>1024</span><span>);</span>
 <span>events_t</span> <span>*</span><span>loop</span> <span>=</span> <span>events_create</span><span>(</span><span>6</span><span>);</span>
 <span>async_task</span><span>(</span><span>main_main</span><span>,</span> <span>1</span><span>,</span> <span>argv</span><span>[</span><span>1</span><span>]);</span>
 <span>async_run</span><span>(</span><span>loop</span><span>);</span>
 <span>events_destroy</span><span>(</span><span>loop</span><span>);</span>

 <span>printf</span><span>(</span><span>LN_CLR</span> <span>CLR_LN</span><span>);</span>
 <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>A much simpler version of <strong>libuv</strong> <a href="https://github.com/libuv/libuv/blob/master/docs/code/spawn/main.c">spawn</a> example. This is same as <strong>c-asio</strong> <a href="https://github.com/zelang-dev/c-asio/tree/main/examples/spawn.c">https://github.com/zelang-dev/c-asio/tree/main/examples/spawn.c</a> intergrating <strong>libuv</strong>.</p>

<div><div><pre><code><span>#include</span> <span>&#34;events.h&#34;</span><span>
</span>
<span>void</span> <span>_on_exit</span><span>(</span><span>int</span> <span>exit_status</span><span>,</span> <span>int</span> <span>term_signal</span><span>)</span> <span>{</span>
 <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;</span><span>\n</span><span>Process exited with status %d, signal %d</span><span>\n</span><span>&#34;</span><span>,</span>
  <span>exit_status</span><span>,</span> <span>term_signal</span><span>);</span>
<span>}</span>

<span>void</span> <span>*</span><span>main_main</span><span>(</span><span>param_t</span> <span>args</span><span>)</span> <span>{</span>
 <span>execinfo_t</span> <span>*</span><span>child</span> <span>=</span> <span>spawn</span><span>(</span><span>&#34;child_command&#34;</span><span>,</span> <span>&#34;test-dir&#34;</span><span>,</span> <span>NULL</span><span>,</span> <span>_on_exit</span><span>);</span>
 <span>if</span> <span>(</span><span>child</span> <span>!=</span> <span>NULL</span><span>)</span> <span>{</span>
  <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;</span><span>\n</span><span>Launched process with ID %zu</span><span>\n</span><span>&#34;</span><span>,</span> <span>spawn_pid</span><span>(</span><span>child</span><span>));</span>
  <span>while</span> <span>(</span><span>!</span><span>spawn_is_finish</span><span>(</span><span>child</span><span>))</span>
   <span>yield_task</span><span>();</span>
 <span>}</span>

 <span>return</span> <span>0</span><span>;</span>
<span>}</span>

<span>int</span> <span>main</span><span>(</span><span>int</span> <span>argc</span><span>,</span> <span>char</span> <span>**</span><span>argv</span><span>)</span> <span>{</span>
 <span>events_init</span><span>(</span><span>1024</span><span>);</span>
 <span>events_t</span> <span>*</span><span>loop</span> <span>=</span> <span>events_create</span><span>(</span><span>1</span><span>);</span>
 <span>async_task</span><span>(</span><span>main_main</span><span>,</span> <span>0</span><span>);</span>
 <span>async_run</span><span>(</span><span>loop</span><span>);</span>
 <span>events_destroy</span><span>(</span><span>loop</span><span>);</span>

 <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<h2 id="installation">Installation</h2>

<p>Any <strong>commit</strong> with an <strong>tag</strong> is considered <em>stable</em> for <strong>release</strong> at that <em>version</em> point.</p>

<p>If there are no <em>binary</em> available for your platform under <strong>Releases</strong> then build using <strong>cmake</strong>,
which produces <strong>static</strong> libraries by default.</p>

<h3 id="linux">Linux</h3>

<div><div><pre><code><span>mkdir </span>build
<span>cd </span>build
cmake .. <span>-DCMAKE_BUILD_TYPE</span><span>=</span>Debug/Release <span>-D</span> <span>BUILD_TESTS</span><span>=</span>OFF <span>-D</span> <span>BUILD_EXAMPLES</span><span>=</span>OFF <span># use to not build tests and examples</span>
cmake <span>--build</span> <span>.</span>
</code></pre></div></div>

<h3 id="windows">Windows</h3>

<div><div><pre><code><span>mkdir </span>build
<span>cd </span>build
cmake .. <span>-D</span> <span>BUILD_TESTS</span><span>=</span>OFF <span>-D</span> <span>BUILD_EXAMPLES</span><span>=</span>OFF <span># use to not build tests and examples</span>
cmake <span>--build</span> <span>.</span> <span>--config</span> Debug/Release
</code></pre></div></div>

<h3 id="as-cmake-project-dependency">As cmake project dependency</h3>

<blockquote>
  <p>For <strong>CMake</strong> versions earlier than <code>3.14</code>, see <a href="https://cmake.org/cmake/help/v3.14/module/FetchContent.html">https://cmake.org/cmake/help/v3.14/module/FetchContent.html</a></p>
</blockquote>

<p>Add to <strong>CMakeLists.txt</strong></p>

<div><div><pre><code><span>find_package</span><span>(</span><span>events</span> <span>QUIET</span><span>)</span>
<span>if</span><span>(</span><span>NOT</span> <span>events_FOUND</span><span>)</span>
    <span>FetchContent_Declare</span><span>(</span><span>events</span>
        <span>URL</span> <span>https</span><span>:</span><span>//github.com/zelang-dev/c-events/archive/refs/tags/0.1.1.zip</span>
        <span>URL_MD5</span> <span>e2ec8e145bc702b052fe857d03c95c31</span>
    <span>)</span>
    <span>FetchContent_MakeAvailable</span><span>(</span><span>events</span><span>)</span>
<span>endif</span><span>()</span>

<span>target_include_directories</span><span>(</span><span>your_project</span> <span>PUBLIC</span> <span>$</span><span>&lt;</span><span>BUILD_INTERFACE</span><span>:</span><span>$</span><span>{</span><span>EVENTS_INCLUDE_DIR</span><span>}</span> <span>$</span><span>&lt;</span><span>INSTALL_INTERFACE</span><span>:</span><span>$</span><span>{</span><span>EVENTS_INCLUDE_DIR</span><span>})</span>
<span>target_link_libraries</span><span>(</span><span>your_project</span> <span>PUBLIC</span> <span>events</span><span>)</span>
</code></pre></div></div>

<h2 id="contributing">Contributing</h2>

<p>Contributions are encouraged and welcome; I am always happy to get feedback or pull requests on Github :) Create <a href="https://github.com/zelang-dev/c-events/issues">Github Issues</a> for bugs and new features and comment on the ones you are interested in.</p>

<h2 id="license">License</h2>

<p>The MIT License (MIT). Please see <a href="https://zelang-dev.github.io/c-events/LICENSE.md">License File</a> for more information.</p>

      </section>

      
    </div></div>
  </body>
</html>
