<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rednafi.com/go/reminiscing_cgi_scripts/">Original</a>
    <h1>Reminiscing CGI Scripts</h1>
    
    <div id="readability-page-1" class="page"><div><p>I’ve always had a thing for old-school web tech. By the time I joined the digital fray, CGI
scripts were pretty much relics, but the term kept popping up in tech forums and discussions
like ghosts from the past. So, I got curious, started reading about them, and wanted to see
if I could reason about them from the first principles. Writing one from the ground up with
nothing but Go’s standard library seemed like a good idea.</p><p>Turns out, the basis of the technology is deceptively simple, but CGI scripts mostly went
out of fashion because of their limitations around performance.</p><h2 id="what-are-those">What are those</h2><p>CGI scripts, or Common Gateway Interface scripts, emerged in the early 1990s as a solution
for creating dynamic web content. They acted as intermediaries between the web server and
external applications, allowing servers to process user input and return personalized
content. This made them essential for adding interactivity to websites, such as form
submissions and dynamic page updates.</p><p>The key function of CGI scripts was to handle data from web forms, process it, and then
generate an appropriate response. The server then takes this response and displays it on a
new web page. Here’s how the process might look:</p><p>sequenceDiagram
participant U as Client
participant S as Server
participant C as CGI Script
U-&gt;&gt;S: Post request with a dynamic field value
S-&gt;&gt;C: Execute the CGI script in a new process
Note right of C: CGI script receives the value
C--&gt;&gt;S: Process and return result
S--&gt;&gt;U: Respond with result</p><h2 id="how-to-write-one">How to write one</h2><p>CGI scripts are usually written in dynamic scripting languages like Perl, Ruby, Python, or
even Bash. However, they can also be written in a static language where the server will need
execute the compiled binary. For this demo, we’re going to write the server in Go using the
<code>cgi</code> stdlib, but the CGI script itself will be written in Bash.</p><p>Here’s the plan:</p><ul><li>Set up a basic HTTP server in Go.</li><li>The server will await an HTTP POST request containing a form field called <code>name</code>.</li><li>Upon receiving the request, the server will extract the value of <code>name</code>.</li><li>Next, it’ll set the <code>$name</code> environment variable for the current process.</li><li>A Bash CGI script is invoked, which uses the <code>$name</code> environment variable to echo an
HTML-formatted dynamic message.</li><li>Finally, the server will then return this HTML response to the client.</li></ul><p>The server lives in a single <code>main.go</code> script. I’m leaving out Go’s verbose error handling
for clarity.</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>package</span> <span>main</span>
</span></span><span><span>
</span></span><span><span><span>import</span> <span>(</span>
</span></span><span><span>    <span>&#34;net/http&#34;</span>
</span></span><span><span>    <span>&#34;net/http/cgi&#34;</span>
</span></span><span><span>    <span>&#34;os/exec&#34;</span>
</span></span><span><span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>// Leaves out error handling for clarity
</span></span></span><span><span><span></span><span>func</span> <span>cgiHandler</span><span>(</span><span>w</span> <span>http</span><span>.</span><span>ResponseWriter</span><span>,</span> <span>r</span> <span>*</span><span>http</span><span>.</span><span>Request</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>// Parse name from post request
</span></span></span><span><span><span></span>    <span>r</span><span>.</span><span>ParseForm</span><span>()</span>
</span></span><span><span>    <span>name</span> <span>:=</span> <span>r</span><span>.</span><span>FormValue</span><span>(</span><span>&#34;name&#34;</span><span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>// Execute the CGI script with the name as an environment variable
</span></span></span><span><span><span></span>    <span>cmd</span> <span>:=</span> <span>exec</span><span>.</span><span>Command</span><span>(</span><span>&#34;cgi-script.sh&#34;</span><span>)</span>
</span></span><span><span>    <span>cmd</span><span>.</span><span>Env</span> <span>=</span> <span>append</span><span>(</span><span>cmd</span><span>.</span><span>Env</span><span>,</span> <span>&#34;name=&#34;</span><span>+</span><span>name</span><span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>// Serve the CGI script
</span></span></span><span><span><span></span>    <span>handler</span> <span>:=</span> <span>cgi</span><span>.</span><span>Handler</span><span>{</span><span>Path</span><span>:</span> <span>cmd</span><span>.</span><span>Path</span><span>,</span> <span>Dir</span><span>:</span> <span>cmd</span><span>.</span><span>Dir</span><span>,</span> <span>Env</span><span>:</span> <span>cmd</span><span>.</span><span>Env</span><span>}</span>
</span></span><span><span>    <span>handler</span><span>.</span><span>ServeHTTP</span><span>(</span><span>w</span><span>,</span> <span>r</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>main</span><span>()</span> <span>{</span>
</span></span><span><span>    <span>http</span><span>.</span><span>HandleFunc</span><span>(</span><span>&#34;/&#34;</span><span>,</span> <span>cgiHandler</span><span>)</span>
</span></span><span><span>    <span>http</span><span>.</span><span>ListenAndServe</span><span>(</span><span>&#34;localhost:8080&#34;</span><span>,</span> <span>nil</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Upon every new request, the server above will execute a CGI script written in Bash. Name the
shell script as <code>cgi-script.sh</code> and place it in the same directory as the server’s <code>main.go</code>
file. Here’s how it looks:</p><div><pre tabindex="0"><code data-lang="sh"><span><span><span>#!/bin/bash
</span></span></span><span><span><span></span>
</span></span><span><span><span>set</span> -euo pipefail
</span></span><span><span>
</span></span><span><span><span>name</span><span>=</span><span>$name</span>
</span></span><span><span>
</span></span><span><span><span>echo</span> <span>&#34;Content-type: text/html&#34;</span>
</span></span><span><span><span>echo</span> <span>&#34;&#34;</span>
</span></span><span><span><span>echo</span> <span>&#39;&lt;html&gt;&lt;body&gt;&#39;</span>
</span></span><span><span><span>echo</span> <span>&#34;Hello </span><span>$name</span><span>, greetings from bash!&#34;</span>
</span></span><span><span><span>echo</span> <span>&#39;&lt;/body&gt;&lt;/html&gt;&#39;</span>
</span></span></code></pre></div><p>The script just reads <code>name</code> from the environment variable, sets the <code>Content-Type</code> header,
injects the value of <code>name</code> into the message, and echos the out the final HTML response. The
server then just relays it back to the client. To test this:</p><ul><li>Run the server with <code>go run main.go</code>.</li><li>Set the permission of the CGI script:<div><pre tabindex="0"><code data-lang="sh"><span><span>sudo chmod +x cgi-script.sh
</span></span></code></pre></div></li><li>Make a cURL request:<div><pre tabindex="0"><code data-lang="sh"><span><span>curl -X POST http://localhost:8080 -d <span>&#34;name=Redowan&#34;</span>
</span></span></code></pre></div></li></ul><p>This returns the following response:</p><div><pre tabindex="0"><code data-lang="txt"><span><span>&lt;html&gt;&lt;body&gt;
</span></span><span><span>Hello Redowan, greetings from bash!
</span></span><span><span>&lt;/body&gt;&lt;/html&gt;
</span></span></code></pre></div><h2 id="why-they-didnt-catch-on">Why they didn’t catch on</h2><p>CGI scripts have fallen out of favor primarily due to concerns related to performance and
security. When a CGI script is executed, it initiates a new process for each request. While
this approach is straightforward, it becomes increasingly inefficient as web traffic volume
grows. However, it’s worth noting that modern Linux kernels have made improvements in
process spawning, and solutions like FastCGI utilize persistent process pools to reduce the
overhead of creating new processes. Nevertheless, you still incur the VM startup cost for
each request when using interpreted languages like Python or Ruby.</p><p>Modern application servers like Uvicorn, Gunicorn, Puma, Unicorn or even Go’s standard
server have addressed these inefficiencies by maintaining persistent server processes. This,
along with the advantage of not having to bear the VM startup cost, has led people to opt
for these alternatives.</p><p>Another concern worth considering is the evident security issues associated with CGI
scripts. Even in our simple example, the Bash script accepts any value for the <code>name</code>
parameter and passes it directly to the response. This exposes a significant vulnerability
to injection attacks. While it’s possible to manually sanitize the input before passing it
to the next step, many of these security steps are automatically handled for you by almost
any modern web framework.</p><p>Fin!</p><h2>Recent posts</h2><li><a href="https://rednafi.com/python/escape_template_pattern/">Escaping the template pattern hellscape in Python</a></li><li><a href="https://rednafi.com/python/debug_dockerized_apps_in_vscode/">Debugging dockerized Python apps in VSCode</a></li><li><a href="https://rednafi.com/python/dataclasses_and_methods/">Banish state-mutating methods from data classes</a></li><li><a href="https://rednafi.com/zephyr/finding_flow_amid_chaos/">Finding flow amid chaos</a></li><li><a href="https://rednafi.com/zephyr/diminishing_half_life_of_knowledge/">The diminishing half-life of knowledge</a></li><li><a href="https://rednafi.com/zephyr/oh_my_poor_business_logic/">Oh my poor business logic</a></li><li><a href="https://rednafi.com/misc/pesky_little_scripts/">Pesky little scripts</a></li><li><a href="https://rednafi.com/zephyr/footnotes_for_the_win/">Footnotes for the win</a></li><li><a href="https://rednafi.com/misc/dotfile_stewardship_for_the_indolent/">Dotfile stewardship for the indolent</a></li><li><a href="https://rednafi.com/zephyr/an_ode_to_the_neo_grotesque_web/">An ode to the neo-grotesque web</a></li></div></div>
  </body>
</html>
