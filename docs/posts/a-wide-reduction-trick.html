<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://words.filippo.io/dispatches/wide-reduction/">Original</a>
    <h1>A Wide Reduction Trick</h1>
    
    <div id="readability-page-1" class="page"><div>
    <article>
        <span>
            <time datetime="2022-08-04">04 Aug 2022</time>
        </span>
        
        
        <section>
            <!--kg-card-begin: markdown--><p>In line with the original spirit of Cryptography Dispatches, this is a quick issue to talk about a neat bit of cryptography engineering I encountered.</p>
<h2 id="the-structure-of-an-ecc-implementation">The structure of an ECC implementation</h2>
<p>Elliptic curve cryptography implementations all roughly share the following structure: there&#39;s a base field implementation, the group logic, a scalar field implementation, and a higher level protocol (key exchange, signatures, ...) over the group.</p>
<p>The base field is the set of numbers modulo a large prime number (such as 2^255-19, from which Curve25519 takes its name). The implementation provides arithmetic operations in the field, such as modular addition, subtraction, multiplication, and inversion, as well as encoding and decoding of field elements to/from bytes.</p>
<p>The group is the set of points on the elliptic curve. The implementation represents a point in some coordinate system where each coordinate is a base field element, and then applies a point addition formula which is defined in terms of base field operations.</p>
<p>The scalar field is, like the base field, the set of numbers modulo a large prime. However, this large prime is not selected by the designers, but is instead the <em>order of the group</em>. That is, the number of times you need to add a point to itself before you get back to that point. In practice, the scalar field implementation is often very different from the base field implementation, for a few reasons:</p>
<ol>
<li>the performance of scalar field operations is less important to the high-level protocol performance than that of base field operations;</li>
<li>the prime modulus can&#39;t be selected to have a nice optimization-friendly shape, with cute reduction identities and such;</li>
<li>some high-level protocols only need a very restricted set of scalar field operations, or none at all (such as ECDH);</li>
<li>some other high-level protocols need scalar field operations that aren&#39;t relevant to the base field, such as a &#34;wide&#34; modular reduction from a value numerically much higher than the field order to a field element.</li>
</ol>
<p>In this issue we&#39;re going to talk about those wide modular reductions.</p>
<h2 id="fiat-crypto">fiat-crypto</h2>
<p>Field implementations are where some of the most subtle and terrifying bugs hide. Most bugs in group logic, protocol implementations, and the way these all interact can be reached with careful, extensive testing.</p>
<p>Carry bugs in field implementations can easily occur randomly for one in 2^64 inputs, only on some specific architecture, with no way to share test cases between implementations. Mentally reviewing the logic is <a href="https://go.googlesource.com/go/+/d95ca9138026cbe40e0857d76a81a16d03230871%5E%21/">awful</a>, and a tiny mistake is enough to <a href="https://i.blackhat.com/us-18/Wed-August-8/us-18-Valsorda-Squeezing-A-Key-Through-A-Carry-Bit-wp.pdf">exfiltrate keys</a>.</p>
<p>Enter <a href="https://github.com/mit-plv/fiat-crypto">fiat-crypto</a>. This un-Googleable project uses formal methods to prove the logic of field arithmetic operations correct, and generates code in a variety of languages to implement those operations. <a href="https://github.com/FiloSottile/edwards25519/blob/8c58ed0e35502a485538e4c5ec086070840f3410/scalar_fiat.go">The code is not the most readable</a> but the API is usable and the most common bugs are ruled out by the formal proof.</p>
<p>Between Go 1.17 and Go 1.19 I progressively replaced with it all NIST curves base field implementations in the Go standard library (except the most aggressively optimized assembly ones).</p>
<p>What about the scalar fields though?</p>
<h2 id="aside-the-christmas-tree">Aside: the Christmas tree</h2>
<p>Let&#39;s take a detour in cryptography engineering history.</p>
<p>Most cryptography implementations aren&#39;t written from scratch, and instead have somewhat of a lineage. The current Go edwards25519 implementation traces back to a port from C to Go by Adam Langley of the &#34;ref10&#34; public domain implementation by Daniel Bernstein, so called because it was distributed as the <code>crypto_sign/ed25519/ref10</code> subfolder of a benchmarking tarball called SUPERCOP. It was then extracted for use in github.com/gtank/ristretto255 by George Tankersley, Henry de Valence, and me, merged with an old 2017 assembly optimization by George Tankersley, and finally exposed as filippo.io/edwards25519. One year ago, <a href="https://go-review.googlesource.com/c/go/+/276272">I re-upstreamed it, replacing the code in the standard library it started from</a>.</p>
<p>Over the years, all the base field and group logic from ref10 was replaced, but the scalar field implementation was still the same. In fact, most of the edwards25519 implementations I am aware of use that scalar implementation, consisting of two large functions: <code>sc_muladd</code> which computes <code>a * b + c</code> and <code>sc_reduce</code> which reduces a 512-bit value. This <a href="https://github.com/jedisct1/supercop/blob/fe36cc1446cb8b1d5c82881e9d03fce82bbde370/crypto_sign/ed25519/ref10/sc_muladd.c">giant uncommented blob of hardcoded integer constants</a> is so infamous that it&#39;s affectionately referred to as &#34;the Christmas tree&#34; amongst practitioners, due to the <a href="https://github.com/FiloSottile/edwards25519/blob/37b8fb5359e55196500b70f5148bd97fb03e5ecd/scalar.go#L234-L256">shape of the large addition round of multiplication terms</a>.</p>
<p>(Imagine a pen-and-paper columnar multiplication between two large numbers with the same digit count. The rightmost digit of the result is the sum of one product, the second rightmost of two, and so on until the middle one, and then back down until the leftmost is the sum of one product again, ignoring carries. That&#39;s what gives the Christmas tree its shape. There is also an explanation <a href="https://github.com/FiloSottile/edwards25519/blob/37b8fb5359e55196500b70f5148bd97fb03e5ecd/field/fe_generic.go#L47-L77">in our edwards25519 base field implementation</a>.)</p>
<p>Anyway, George Tankersley&#39;s branch for the PR that replaced <code>scMulAdd</code> with fiat-crypto was called <code>gtank/war-on-christmas</code>. That is all.</p>
<h2 id="wide-reduction">Wide reduction</h2>
<p>fiat-crypto provides only one decoding function, which requires the input to already be lower than the field order. This is mostly not a problem with base fields, where non-canonical &#34;overflowing&#34; values are rejected. However, we often need to operate on and reduce scalar values higher than the scalar field order:</p>
<ul>
<li>the simplest constant-time way to select a random scalar, e.g. for EdDSA or hashing to the curve, is to take a random 512-bit value and reduce it modulo the scalar field order, making the bias negligibly small;</li>
<li>Ed25519 &#34;clamping&#34;—which is actually useless in a signature scheme but for some reason got copied from RFC 7748 to RFC 8032—sets the second most significant bit in a 32-byte string representing the scalar, making it by definition at least 2^254, while the scalar field order is a little over 2^252;</li>
<li>ECDSA takes a base field element and interprets it as a scalar field element because it&#39;s a horrible, <em>horrible</em> protocol, and the base field is a little larger than the scalar field.</li>
</ul>
<p>What do we do then if we have a value that might be as high as 2^512-1 and a field implementation that can only take inputs lower than the order (2^252 and change)?</p>
<p><em>My</em> answer was &#34;we find the lovely, helpful fiat-crypto authors at a cryptography workshop in Amsterdam and ask them to add a wide reduction function to fiat-crypto&#34; but it turns out that implementing that in the Montgomery backend (what you need for weirdly shaped primes like this) is not easy, especially if you need to reduce from above the square of the order, which we do.</p>
<p>Thankfully Frank Denis had a much, much better answer. The kind so simple (for a person who spends most of their time working on this stuff) that it clicks immediately and then you want to write a newsletter issue about.</p>
<blockquote><p lang="en" dir="ltr">I represent the  value as a+b*2^192+c*2^384 <a href="https://t.co/O0dwPKbzAL">https://t.co/O0dwPKbzAL</a></p>— Frank ⚡ (@jedisct1) <a href="https://twitter.com/jedisct1/status/1525228662492119040?ref_src=twsrc%5Etfw">May 13, 2022</a></blockquote>  
<h2 id="the-trick">The trick</h2>
<p>Here&#39;s the idea: take a large number, such as 712376532, and imagine we need to operate over it with a calculator that can only count up to 1041, and then wraps around to 0. The good news is that we want all our results modulo 1042.</p>
<p>First, we notice we can write <code>712376532 mod 1042</code> as</p>
<pre><code>712376532 = 712 * 1000000 + 376 * 1000 + 532 mod 1042
</code></pre>
<p>&#34;But wait&#34;, you&#39;ll say, &#34;1000000 is more than 1042!&#34; Yes, but since we are operating modulo 1042 we can precompute its reduction, like this</p>
<pre><code>712376532 = 712 * 722 + 376 * 1000 + 532 mod 1042
</code></pre>
<p>These are now all numbers that we can put into our calculator!</p>
<p><a href="https://github.com/FiloSottile/edwards25519/commit/63e0935134d650f03ae6ff8e0da6760f18e5f5f8">We do the same thing to use fiat-crypto for the edwards25519 scalar field.</a> We cut the 64 bytes wide value up into three pieces, two of 21 bytes and one of 22 bytes; we decode each of them with fiat-crypto, since they are all guaranteed to be less than 2^176; we multiply the two most significant ones by 2^336 (for which we precomputed the reduction) and 2^168; and finally we add it all together.</p>
<pre><code>x = c * 2^336 + b * 2^168 + a  mod l
</code></pre>
<p>The result is the correct value of the 2^521-wide input modulo the field order, but we got there through two additions and two multiplications of values below the field order, which is what fiat-crypto provides us.</p>
<p>With this, the last piece of the ref10 scalar implementation is gone, resulting in an <a href="https://go-review.googlesource.com/c/go/+/420454">overall change</a>, ignoring autogenerated code, of 268 insertions(+), 893 deletions(-).</p>
<p>Any day we get to delete 900 lines of unreadable crypto code is a good day.</p>
<h2 id="the-picture">The picture</h2>
<p>An especially good day if you get to do it on the side of a beautiful lake.</p>
<p><img src="https://words.filippo.io/content/images/2022/08/IMG_7123-Large.jpeg" alt="A picture of the side of a lake at night. In the foreground, a cement bench seen from behind with a yellow backpack on it, next to a tree that frames the picture at the top. Beyond it, a small pier with wooden poles stretches into the pitch balck water. In the distance the lights of a town on the other side of the lake." loading="lazy"/></p>


<!--kg-card-end: markdown-->
        </section>
    </article>
</div></div>
  </body>
</html>
