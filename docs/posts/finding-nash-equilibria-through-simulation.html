<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://coe.psu.ac.th/ad/nashSim/">Original</a>
    <h1>Finding Nash equilibria through simulation</h1>
    
    <div id="readability-page-1" class="page">


<pre> 
</pre>

<p>The <a href="https://blog.jacobvosmaer.nl/0027-synth-notes/simGameTheory.zip">Python code</a> described here focuses on the area of Game Theory involving simultaneous games, such as the Prisoner&#39;s Dilemma and Rock, Paper, Scissors. Each game is played multiple times between multiple participants to determine and then visualize the pure and mixed-strategy Nash Equilibria (NEs).</p>

<p>I developed these programs as part of a course based on William Spaniel&#39;s
<a href="https://williamspaniel.com/textbook/">&#34;Game Theory 101: The Complete Textbook&#34;</a>, and his excellent 
<a href="https://www.youtube.com/watch?v=NSVmOC_5zrE&amp;list=PLKI1h_nAkaQoDzI4xDIXzx6U2ergFmedo">videos on Youtube</a>. 
Indeed, most of my examples come from his videos and/or textbook. If you&#39;re unfamiliar with simultaneous games then I highly recommend chapters 1 and 3 and the corresponding videos, numbered #1 to #15 and #27 to #37.</p> 

<p>The four programs -- sim22.py, sim33.py, sim44.py, and simNN.py -- are named after the size of the payoff matrix they can process (sim22.py for 2x2, sim33.py for 3x3, sim44.py for 4x4, and simNN.py for NxN, where N &gt; 2).</p>


<h2>sim22.py</h2>

<p>The standard 2x2 payoff matrix for the Prisoner&#39;s Dilemma:</p>

<p><img src="https://blog.jacobvosmaer.nl/0027-synth-notes/pdMatrix.png" alt="Prisoner&#39;s Dilemma Matrix"/></p>

<p>The first player&#39;s preferences (to stay &#34;quiet&#34; or &#34;confess&#34;) appear in the rows, and the other player&#39;s preferences are in the columns. The first player&#39;s payoffs are listed first for each outcome, and the second player&#39;s are second. For example, if the first player keeps quiet and the second player confesses, then the game ends in the top right payoff pair with the first player receiving twelve months in jail and the second player walking free.</p> 

<p>sim22.py can use this payoff matrix to find NEs for the game: </p>

<pre>&gt; python sim22.py pd.txt
Reading pd.txt
Building 2 x 2 payoff...
Labels: [&#39;Prisoners Dilemma&#39;, &#39;quiet&#39;, &#39;confess&#39;]
Payoffs: [[(-1, -1), (-12, 0)], [(0, -12), (-8, -8)]]
</pre>

<p>The results are displayed as a 1-simplex of 
<a href="https://en.wikipedia.org/wiki/Barycentric_coordinate_system">barycentric coordinates</a> 
spread out along a diagonal representing the probabilities of selecting the two preferences (S1 and S2): </p>

<p><img src="https://blog.jacobvosmaer.nl/0027-synth-notes/one-simplex.png" alt="1-Simplex"/></p>

<p>The simplex generated for the pd.txt payoff matrix is:</p>

<p><img src="https://blog.jacobvosmaer.nl/0027-synth-notes/pd.png" alt="Prisoner&#39;s Dilemma Simplex Simplex"/></p>

<p>The first and second players&#39; preferences (labeled as P1 and P2) are shown on the same graph, and in this case coincide. P1 and P2 favor an almost pure strategy NE of (confess, confess). 
This matches the NE calculated in Spaniel&#39;s video
<a href="https://www.youtube.com/watch?v=DanTKx1FLY8&amp;list=PLKI1h_nAkaQoDzI4xDIXzx6U2ergFmedo&amp;index=2">Game Theory 101, #2</a>.</p>

<p>The actual output of sim22.py is a window containing <b>ten</b> copies of the 1-simplex. Repeated game play is used to accommodate the random way in which the code converges upon a NE. There may be several NEs for a given matrix, and by generating multiple graphs, we give the program a chance to converge on different results depending on how the random process develops. The benefits of this approach can be seen when processing the payoff matrix for &#34;Battle of the Sexes&#34;:</p>

<p><img src="https://blog.jacobvosmaer.nl/0027-synth-notes/sexesMatrix.png" alt="Battle of the Sexes Matrix"/></p>

<p>Calling:</p>
<pre>&gt; python sim22.py battle27.txt
Reading battle27.txt
Building 2 x 2 payoff...
Labels: [&#39;Battle of the Sexes&#39;, &#39;ballet&#39;, &#39;boxing&#39;]
Payoffs: [[(1, 4), (0, 0)], [(0, 0), (4, 1)]]
</pre>

<p>The ten graphs consist of multiple copies of two NEs:</p>

<p><img src="https://blog.jacobvosmaer.nl/0027-synth-notes/battle27.png" alt="Battle of the Sexes Simplex"/></p>

<p>As Spaniel explains in the 
<a href="https://www.youtube.com/watch?v=0aAss6_e_W0&amp;list=PLKI1h_nAkaQoDzI4xDIXzx6U2ergFmedo&amp;index=27">Game Theory 101, #27</a> video
there are two pure NE for this matrix: (boxing, boxing) and (ballet, ballet). There&#39;s also a mixed strategy which sadly doesn&#39;t appear as a separate graph in the output of sim22.py. Instead it affects the distributions of the probabilities in the &#39;pure&#39; results so that the choices for P2 in the left-hand graph, and P1 in right-hand graph, aren&#39;t concentrated solely on boxing and ballet. This issue appears in a number of the examples, when a mixed strategy NE has a lower payoff than pure strategies, causing the simulation to not converge completely upon a pure NE.</p>


<h2>sim33.py</h2>

<p>The standard example of a 3x3 payoff matrix is for the
&#34;Rock, Paper, Scissors&#34; game:</p>

<p><img src="https://blog.jacobvosmaer.nl/0027-synth-notes/rpsMatrix.png" alt="Rock, Paper, Scissors Matrix"/></p>

<p>Calling:</p>
<pre>&gt; python sim33.py rps36.txt
Reading rps36.txt
Building 3 x 3 payoff...
Labels: [&#39;RPS&#39;, &#39;rock&#39;, &#39;paper&#39;, &#39;scissors&#39;]
Payoffs: [[(0, 0), (-1, 1), (1, -1)], [(1, -1), (0, 0), (-1, 1)], [(-1, 1), (1, -1), (0, 0)]]
</pre>

<p>The result is a 2-simplex visualization of barycentric coordinates inside an equilateral triangle, where each vertex is one of the payoff preferences:</p> 

<p><img src="https://blog.jacobvosmaer.nl/0027-synth-notes/rps36.png" alt="RPS Simplex Pic"/></p>

<p>This indicates that the best strategy is (1/3, 1/3, 1/3), a mixed Nash equilibrium. For more details, see Spaniel&#39;s videos
<a href="https://www.youtube.com/watch?v=0aAss6_e_W0&amp;list=PLKI1h_nAkaQoDzI4xDIXzx6U2ergFmedo&amp;index=34">Game Theory 101, #34</a> and
<a href="https://www.youtube.com/watch?v=0aAss6_e_W0&amp;list=PLKI1h_nAkaQoDzI4xDIXzx6U2ergFmedo&amp;index=36">#36</a>.</p>

<p>The 2-simplex allow us to treat a barycentric coordinate as a point linked by &#39;springs&#39; of fractional strengths to the three vertices. For example, if the three springs have equal values (1/3, 1/3, 1/3) then the point will be located at the center of gravity of the triangle. A few other values are shown in the diagram below:</p>

<p><img src="https://blog.jacobvosmaer.nl/0027-synth-notes/two-simplex.png" alt="2-Simplex Pic"/></p>

<p>Note that whereas the other programs only utilize Matplotlib, sim33.py also depends on the 
<a href="https://github.com/marcharper/python-ternary">python-ternary</a> module, which needs to be installed separately.</p>

<p>A more visually interesting nonzero-sum variant of RPS is <a href="https://en.wikipedia.org/wiki/Fictitious_play">fictitious play</a> with the payoff matrix:</p>

<p><img src="https://blog.jacobvosmaer.nl/0027-synth-notes/fictMatrix.png" alt="Fictious Play Matrix"/></p>

<p>The sim33.py call and result:</p>
<pre>&gt; python sim33.py fictious.txt
Reading fictious.txt
Building 3 x 3 payoff...
Labels: [&#39;RPS&#39;, &#39;rock&#39;, &#39;paper&#39;, &#39;scissors&#39;]
Payoffs: [[(0, 0), (2, 1), (1, 2)], [(1, 2), (0, 0), (2, 1)], [(2, 1), (1, 2), (0, 0)]]
</pre>

<p><img src="https://blog.jacobvosmaer.nl/0027-synth-notes/fictious.png" alt="Fictious Play Simplex"/></p>

<p>Fictitious play doesn&#39;t always converge to a NE, which is reflected in the spread of points inside the simplex, and the number of different visualizations.</p>


<h2>sim44.py</h2>

<p>A typical payoff matrix using four preferences is the &#34;Units in a Battle&#34; game discussed in Spaniel&#39;s video 
<a href="https://www.youtube.com/watch?v=0aAss6_e_W0&amp;list=PLKI1h_nAkaQoDzI4xDIXzx6U2ergFmedo&amp;index=6">Game Theory 101, #6</a>:</p>

<p><img src="https://blog.jacobvosmaer.nl/0027-synth-notes/generalsMatrix.png" alt="Units in a Battle Matrix"/></p>

<p>Two generals each have three units and are preparing for an upcoming battle. Each can choose to send any number of units (up to 3) to the fight or none at all. The side with more troops wins the battle, but the fight will be a draw if there are equal forces. Victory is worth 1 point; defeat is rewarded with -1. If the two sides draw or at least one side sends no units, then both sides earn 0.</p>

<p>One way to visualize a 3-simplex is as a tetrahedron, allocating a preference to each vertex:</p>

<p><img src="https://blog.jacobvosmaer.nl/0027-synth-notes/three-simplex.png" alt="3-simplex"/></p>

<p>This approach is taken by sim44.py by using the 3D charting features of Matplotlib. For instance:</p>

<pre>&gt; python sim44.py generals.txt
Reading generals.txt
Building 4 x 4 payoff...
Labels: [&#39;Units in a Battle&#39;, &#39;Pass&#39;, &#39;One&#39;, &#39;Two&#39;, &#39;Three&#39;]
Payoffs: [[(0, 0), (0, 0), (0, 0), (0, 0)], [(0, 0), (0, 0), (-1, 1), (-1, 1)], 
[(0, 0), (1, -1), (0, 0), (-1, 1)], [(0, 0), (1, -1), (1, -1), (0, 0)]]
</pre>

<p><img src="https://blog.jacobvosmaer.nl/0027-synth-notes/generals.png" alt="Units in a Battle Simplex"/></p>

<p>Although there appears to be two distinct results generated across the ten games, they&#39;re actually identical since the 3D alpha blending of the orange and blue points sometimes favors one color over the other. In fat, there&#39;s a single NE at (Three, Three). However, Spaniel shows that there are four possible NEs, at (Pass, Pass), (Pass, Three), (Three, Pass), and (Three, Three). I admit to being unclear why the other three equilibria never appear in the sim44.py results.</p>


<h2>simNN.py</h2>

<p>simNN.py visualizes payoff matrices with three or more preferences by utilizing Wachspress coordinates which position generalized barycentric coordinates inside a convex polygon. Each payoff preference is assigned to a vertex, and a point p inside the polygon is located based on weights related to the triangle areas specified by the point and pairs of adjacent vertices:</p>

<p><img src="https://blog.jacobvosmaer.nl/0027-synth-notes/wachspress.png" alt="Wachspress coordinates"/></p>

<p>Weights for p are defined relative to every vertex i:</p>

<p><img src="https://blog.jacobvosmaer.nl/0027-synth-notes/wachEq1.png" alt="Wachspress Eq 1"/></p>

<p>where A(a,b,c) is the triangle area formed by the points (a,b,c).</p>

<p>These weights are normalized relative to the entire area of the polygon:</p>

<p><img src="https://blog.jacobvosmaer.nl/0027-synth-notes/wachEq2.png" alt="Wachspress Eq 2"/></p>
<p>where n is the number of vertices.</p>

<p>Note that Wachspress coordinates on the boundary of the polygon are undefined because of division by zero. Also, simNN.py employs a regular polygon of N sides as the simplex, where N is the number of preferences in the loaded payoff matrix. For example, the visualization of the 4x4 matrix for the &#34;Units in a Battle&#34; game from the last section utilizes a square:</p>

<pre>&gt; python simNN.py generals.txt
Reading generals.txt
Building 4 x 4 payoff...
Labels: [&#39;Units in a Battle&#39;, &#39;Pass&#39;, &#39;One&#39;, &#39;Two&#39;, &#39;Three&#39;]
Payoffs: [[(0, 0), (0, 0), (0, 0), (0, 0)], [(0, 0), (0, 0), (-1, 1), (-1, 1)], 
[(0, 0), (1, -1), (0, 0), (-1, 1)], [(0, 0), (1, -1), (1, -1), (0, 0)]]
</pre>

<p><img src="https://blog.jacobvosmaer.nl/0027-synth-notes/generalsNN.png" alt="Units in a Battle N-Simplex"/></p>

<p>Although simNN.py&#39;s output is less &#39;beautiful&#39; than sim22.py and sim33.py&#39;s for 3x3 and 4x4 payoff matrices, it does let the user click on a point, causing its barycentric coordinate to be printed to standard output. This is quite useful for larger polygons where the values for interior points are harder to determine. For instance, clicking a large dot near the &#34;Three&#34; vertex in the diagram above, produces <code>bary coords: [0.16, 0.04, 0.15, 0.65]</code>.</p>

<p>In section 1.2.2 of his textbook, Spaniel develops a 6x6 payoff matrix for duopolistic competition:</p>

<p><img src="https://blog.jacobvosmaer.nl/0027-synth-notes/duoCompMatrix.png" alt="Duo. Comp. Matrix"/></p>

<p>This can be processed by simNN.py:</p>

<pre>&gt; python simNN.py duoComp6.txt
Reading duoComp6.txt
Building 6 x 6 payoff...
Labels: [&#39;Duo Comp&#39;, &#39;Zero&#39;, &#39;One&#39;, &#39;Two&#39;, &#39;Three&#39;, &#39;Four&#39;, &#39;Five&#39;]
Payoffs: [[(0, 0), (0, 9), (0, 14), (0, 15), (0, 12), (0, 5)], 
[(9, 0), (7, 7), (5, 10), (3, 9), (1, 4), (-1, -5)], 
[(14, 0), (10, 5), (6, 6), (2, 3), (-2, -4), (-2, -5)], 
[(15, 0), (9, 3), (3, 2), (-3, -3), (-3, -4), (-3, -5)], 
[(12, 0), (4, 1), (-4, -2), (-4, -3), (-4, -4), (-4, -5)], 
[(5, 0), (-5, -1), (-5, -2), (-5, -4), (-5, -4), (-5, -5)]]
</pre>

<p><img src="https://blog.jacobvosmaer.nl/0027-synth-notes/duoCom6.png" alt="Duo. Comp. Simplex"/></p>

<p>Although the output is a bit messy, it confirms Spaniel&#39;s calculation that the NE occurs at (Two, Two). (The &#34;Zero&#34; preference is drawn on the positive x-axis, and subsequent preferences are placed counter-clockwise around the origin.)</p>

<p>A more serious problem is that the code takes over one minute to generate the ten graphs. This is a consequence of gtUtils.py implementing large n-dimensional arrays as nested lists. For example, the six preferences here require two <math><msup><mn>11</mn><mn>6</mn></msup></math> arrays for each simplex. An obvious improvement would be to switch to Numpy arrays.</p>


<h2>Implementation Details</h2>

<p>sim22.py, sim33.py, sim44.py, and simNN.py utilize the same  code for playing simultaneous games based on a payoff matrix by calling functions in gtUtils.py and instantiating multiple Player objects.</p>

<p>Initially, each preference is equally likely to be chosen, but their weights are updated at the end of each round of games. If the total score for a preference exceeds the average score for the round then the preference&#39;s weight is incremented, or decremented if it falls below. So, as multiple rounds (usually about 700) are played out, the weights are adjusted to favor the preferences producing the best score. Also, this process is carried out twice for each player to find the &#39;best&#39; preferences when the player goes first, and when it goes second.</p>

<p>For example, consider the processing of a 2x2 payoff matrix: at the end of one round, out of 10 players, 4 may favor preference 1, and 6 favor preference 2 (when playing first). This is recorded in a 10x10 <tt>stratsP1</tt> array by adding 1 to the <tt>stratsP1[4][6]</tt> cell.</p>

<p>By the end of all the rounds, <tt>stratsP1</tt> (and <tt>stratsP2</tt> when the player is second) are converted into a list of barycentric coordinates with associated sizes. For instance, if <tt>stratsP1[4][6]</tt> contains 20 then the resulting coordinate will be (4/10, 6/10) with point size 20. The division by the number of players ensures that the two floats add up to 1.</p>

 
<h2>Downloads</h2>

<ul>
<li>A zipped collection of the 
<a href="https://blog.jacobvosmaer.nl/0027-synth-notes/SimGameTheory.zip">game theory simulation</a> Python code and examples (20 KB). This requires <a href="https://matplotlib.org/">Matplotlib</a> and <a href="https://github.com/marcharper/python-ternary">python-ternary</a> which can be installed using <tt>pip</tt>.

</li></ul>

<pre> 
</pre>
<hr/>
Dr. Andrew Davison</div>
  </body>
</html>
