<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.visuality.pl/posts/a-simple-guide-to-pessimistic-locking-in-rails">Original</a>
    <h1>A simple guide to pessimistic locking in Rails</h1>
    
    <div id="readability-page-1" class="page"><section><p>In the Rails world, optimistic locking is relatively well known, while its pessimistic alternative is often overlooked. In this blog post, I will present how to effectively use pessimistic locking in Rails applications.</p>

<h3>What is it?</h3>

<p>Pessimistic locking works at the moment of retrieving the records from the database. One process blocks a particular record and others wait until it&#39;s unblocked. This ensures that a certain process will always use the newest version of the record (or raise an exception).</p>

<p>Pessimistic locking assumes that transaction conflicts occur frequently in the system. In such a situation optimistic locking wouldn&#39;t be much useful: it would cause irritating Stale Object errors too often. To address this challenge, a different approach is necessary.</p>

<p>The remarkable benefit of pessimistic locking is the fact that it doesn&#39;t affect the whole system. You don&#39;t have to change the database at all. Instead, you need to explicitly specify all areas which will utilize this technique. This way you have full control of which processes needs to care about locking. It&#39;s useful for fixing places with race conditions, without affecting other functionalities.</p>

<h3>Show me the code</h3>
<div><pre><code><span>ActiveRecord</span><span>::</span><span>Base</span><span>.</span><span>transaction</span> <span>do</span>
  <span># SELECT * FROM INVOICES WHERE id=? FOR UPDATE</span>
  <span>invoice</span> <span>=</span> <span>Invoice</span><span>.</span><span>lock</span><span>.</span><span>find</span><span>(</span><span>invoice_id</span><span>)</span>

  <span>return</span> <span>unless</span> <span>invoice</span><span>.</span><span>status</span> <span>==</span> <span>&#39;new&#39;</span>

  <span>invoice</span><span>.</span><span>create_payment</span>
  <span>invoice</span><span>.</span><span>update</span><span>(</span><span>status: </span><span>&#39;paid&#39;</span><span>)</span>
<span>end</span>
</code></pre></div>
<p>Selecting a particular invoice uses special SQL command: <code>SELECT ... FOR UPDATE</code>. It &#34;locks&#34; the rows returned by <code>SELECT</code> and prevents other processes from retrieving it until the transaction is done. At the same time, other places in the app could use the good old <code>Invoice.find(invoice_id)</code> statement without worrying about locks.</p>

<h3>Advanced stuff</h3>

<p>It is possible to use database-specific locking by passing custom clauses to the <code>lock</code> method, such as:</p>
<div><pre><code><span># raise an error if a record is already locked</span>
<span>invoice</span> <span>=</span> <span>Invoice</span><span>.</span><span>lock</span><span>(</span><span>&#34;FOR UPDATE NOWAIT&#34;</span><span>).</span><span>find</span><span>(</span><span>invoice_id</span><span>)</span>
</code></pre></div>
<p>There is also an alternative method for locking individual records:  <code>with_lock</code> . In this scenario, all operations happening within the block are wrapped into the transaction.</p>
<div><pre><code><span>invoice</span> <span>=</span> <span>Invoice</span><span>.</span><span>find</span><span>(</span><span>invoice_id</span><span>)</span>
<span>invoice</span><span>.</span><span>with_lock</span> <span>do</span>
  <span>(</span><span>..</span><span>)</span>
<span>end</span>
</code></pre></div>
<p>The general rule is: <strong>Always use pessimistic locking within a transaction.</strong> Theoretically, you can call <code>lock!</code> method on records outside of it, but it doesn’t make sense and won’t simply work.</p>

<h3>Testing pessimistic locking</h3>

<p>Testing pessimistic locking is not trivial. To simulate the real conditions, many processes must attempt to retrieve a record simultaneously. This can be achieved by using some concurrency mechanisms, like ruby threads:</p>
<div><pre><code><span>threads</span> <span>=</span> <span>[]</span>
<span>3</span><span>.</span><span>times</span> <span>do</span>
  <span>service</span><span>.</span><span>call</span>
<span>end</span>
<span>threads</span><span>.</span><span>each</span><span>(</span><span>&amp;</span><span>:join</span><span>)</span>

<span>expect</span><span>(</span><span>invoice</span><span>.</span><span>payments</span><span>.</span><span>count</span><span>).</span><span>to</span> <span>eq</span> <span>1</span> <span># this should fail without a lock</span>
</code></pre></div>
<h3>Summary</h3>

<p>There are certain scenarios when pessimistic locking is perfect. It&#39;s a valuable tool for resolving race conditions and maintaining data integrity. Use it when you don&#39;t want to introduce an extra <code>version</code> column for optimistic locking. Or, when you need to fix a specific place in your Ruby on Rails app without affecting the rest of the system.</p>
</section></div>
  </body>
</html>
