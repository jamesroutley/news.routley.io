<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/libsdl-org/SDL/pull/9312">Original</a>
    <h1>SDL3 new GPU API merged</h1>
    
    <div id="readability-page-1" class="page"><div disabled="" sortable="">
<div>
          <p dir="auto">Hello, I&#39;m the author so I&#39;ll take some time to explain this proposal.</p>
<p dir="auto">First, the shader situation.  This API&#39;s shader solution is a script called shaderbuild.py, it&#39;s essentially a frontend for offline shader building tools on the client&#39;s machine, and it globs various formats together so they can individually be sent to the appropriate render backends. I&#39;m aware that the original proposal included online shader compilation. This solution doesn&#39;t forbid this, because future SDLSL source could just be included in the binary and the CreateShaderModule function can translate it into the desired backend&#39;s bytecode on the fly. We wouldn&#39;t have to break the public API to allow this, which is a nice plus, and it prevents the shader compiler from being a blocker on using this API. When authoring a shader the API expects certain <code>set</code> layouts depending on the resource and shader stage: vertex samplers are set 0, fragment samplers are set 1, vertex uniforms are set 2 and fragment uniforms are set 3.</p>
<p dir="auto">This is a modern-style rendering API, so almost all tasks occur in a deferred context and are broken up into render passes, compute passes, and copy passes. All operations that write to a resource have the ability to cycle to avoid inter-frame dependencies - handles to graphics resources like GpuBuffers are just containers so we can cycle references to internal resources. There are some data quirks due to AMD D3D11 drivers being not great - this is why there are a few different WriteOptions enums. I&#39;d like to get rid of these but I haven&#39;t fully been able to work around the fact that D3D11 data APIs do not work as advertised on AMD.</p>
<p dir="auto">Presentation is handled via SDL_GpuAcquireSwapchainTexture, which associates the given command buffer with a swapchain image. When SDL_GpuSubmit is called with this command buffer, the presentation structures are automatically configured and submitted. SDL_GpuSubmit automatically handles submission fences, but the client can choose to explicitly synchronize by calling SDL_GpuSubmitAndAcquireFence and using the returned SDL_GpuFence handle.</p>
<p dir="auto">The rest of the API is fairly bog-standard binding, render, and compute dispatch calls.</p>
      </div>
</div></div>
  </body>
</html>
