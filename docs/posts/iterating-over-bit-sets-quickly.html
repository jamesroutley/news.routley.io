<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://alexharri.com/blog/bit-set-iteration">Original</a>
    <h1>Iterating over bit sets quickly</h1>
    
    <div id="readability-page-1" class="page"><div><main><div><div><p>Welcome to part 2 of my 2-part series on bit sets! If you&#39;re not very familiar with bit manipulation — or don&#39;t know what bit sets are — I recommend reading part 1 first: <a href="https://alexharri.com/blog/bit-sets" target="_blank">Bit Sets: An introduction to bit manipulation</a>.</p><p>If you know your bit manipulation, then you can freely skip part 1.</p></div></div>
<p><a target="_blank" href="https://en.wikipedia.org/wiki/Bit_array">Bit sets</a> — also known as bit arrays or bit vectors — are a highly compact data structure that stores a list of bits. They are often used to represent a set of integers or an array of booleans.</p>
<p>In <a href="https://alexharri.com/blog/bit-sets" target="_blank">part 1</a> we started writing a <code>BitSet</code> class, and implemented a few basic methods:</p>
<div><div><div><pre><p><span>class</span><span> </span><span>BitSet</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>private</span><span> words</span><span>:</span><span> </span><span>number</span><span>[</span><span>]</span><span>;</span><span></span></p><p><span>  </span><span>add</span><span>(</span><span>index</span><span>:</span><span> </span><span>number</span><span>)</span><span>:</span><span> </span><span>void</span><span>;</span><span></span></p><p><span>  </span><span>remove</span><span>(</span><span>index</span><span>:</span><span> </span><span>number</span><span>)</span><span>:</span><span> </span><span>void</span><span>;</span><span></span></p><p><span>  </span><span>has</span><span>(</span><span>index</span><span>:</span><span> </span><span>number</span><span>)</span><span>:</span><span> </span><span>boolean</span><span></span></p><p><span></span><span>}</span><span></span></p></pre></div></div></div>
<p>The bits of our bit set are stored in a <code>number[]</code> called <code>words</code>. Since JavaScript only <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number#fixed-width_number_conversion">supports 32-bit integers</a>, each <a target="_blank" href="https://en.wikipedia.org/wiki/Word_(computer_architecture)">word</a> stores 32 bits (the first word stores bits 1-32, the second word stores bits 33-64, and so on).</p>
<p>In this post, we&#39;ll tackle <code>BitSet.forEach</code>. We&#39;ll start off implementing the naive approach where we iterate over the bits and see how far we can optimize that approach.</p>
<p>We&#39;ll then learn about <a target="_blank" href="https://en.wikipedia.org/wiki/Two%27s_complement">two&#39;s complement</a> and <a target="_blank" href="https://en.wikipedia.org/wiki/Hamming_weight">Hamming weights</a>, and how exploiting those lets us iterate over bit sets <em>really</em> quickly.</p>
<h2>Implementing BitSet.forEach</h2>
<p>The <code>BitSet.forEach</code> method should invoke a callback for every bit that is set to 1, with the index of that bit.</p>
<div><div><div><pre><p><span>class</span><span> </span><span>BitSet</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>forEach</span><span>(</span><span>callback</span><span>:</span><span> </span><span>(</span><span>index</span><span>:</span><span> </span><span>number</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>void</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>}</span><span></span></p><p><span></span><span>}</span><span></span></p></pre></div></div></div>
<p>To start, we&#39;ll iterate over every word in <code>words</code>:</p>
<div><div><div><pre><p><span>const</span><span> words </span><span>=</span><span> </span><span>this</span><span>.</span><span>words</span><span>;</span><span></span></p><p><span></span><span>for</span><span> </span><span>(</span><span>let</span><span> wordIndex </span><span>=</span><span> </span><span>0</span><span>;</span><span> wordIndex </span><span>&lt;</span><span> words</span><span>.</span><span>length</span><span>;</span><span> wordIndex</span><span>++</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>const</span><span> word </span><span>=</span><span> words</span><span>[</span><span>wordIndex</span><span>]</span><span>;</span><span></span></p><p><span></span><span>}</span><span></span></p></pre></div></div></div>
<p>For each word, we&#39;ll run through the bits in ascending order:</p>
<div><div><div><pre><p><span>for</span><span> </span><span>(</span><span>let</span><span> i </span><span>=</span><span> </span><span>0</span><span>;</span><span> i </span><span>&lt;</span><span> </span><span>WORD_LEN</span><span>;</span><span> i</span><span>++</span><span>)</span><span> </span><span>{</span><span></span></p><p><span></span><span>}</span><span></span></p></pre></div></div></div>
<p><code>WORD_LEN</code> is set to 32: the number of bits in each <code>word</code></p>
<p>We can check whether the bit is set via <code>(word &amp; (1 &lt;&lt; i)) !== 0</code>:</p>
<div><div><div><pre><p><span>const</span><span> bitIsSetToOne </span><span>=</span><span> </span><span>(</span><span>word </span><span>&amp;</span><span> </span><span>(</span><span>1</span><span> </span><span>&lt;&lt;</span><span> i</span><span>)</span><span>)</span><span> </span><span>!==</span><span> </span><span>0</span><span>;</span><span></span></p></pre></div></div></div>
<p>If the bit is non-zero, we&#39;ll want to invoke <code>callback</code> with the index of the bit:</p>
<div><div><div><pre><p><span>for</span><span> </span><span>(</span><span>let</span><span> i </span><span>=</span><span> </span><span>0</span><span>;</span><span> i </span><span>&lt;</span><span> </span><span>WORD_LEN</span><span>;</span><span> i</span><span>++</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>const</span><span> bitIsSetToOne </span><span>=</span><span> </span><span>(</span><span>word </span><span>&amp;</span><span> </span><span>(</span><span>1</span><span> </span><span>&lt;&lt;</span><span> i</span><span>)</span><span>)</span><span> </span><span>!==</span><span> </span><span>0</span><span>;</span><span></span></p><p><span>  </span><span>if</span><span> </span><span>(</span><span>bitIsSetToOne</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>callback</span><span>(</span><span>index</span><span>)</span><span></span></p><div><div><div data-type="error"><p><span> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- -->// </span><span></span>Cannot find name &#39;index&#39;.</p></div></div></div><p><span>  </span><span>}</span><span></span></p><p><span></span><span>}</span><span></span></p></pre></div></div></div>
<p>We can compute the bit&#39;s <code>index</code> in the bit set like so:</p>
<div><div><div><pre><p><span>const</span><span> index </span><span>=</span><span> </span><span>(</span><span>wordIndex </span><span>&lt;&lt;</span><span> </span><span>WORD_LOG</span><span>)</span><span> </span><span>+</span><span> i</span><span>;</span><span></span></p></pre></div></div></div>
<p><code>WORD_LOG</code> is set to 5: the base 2 logarithm of 32</p>
<p>The expression <code>wordIndex &lt;&lt; WORD_LOG</code> is equivalent to <code>wordIndex * WORD_LEN</code> because left shifting by one is equivalent to multiplying by 2 (and <code>2 ** WORD_LOG</code> equals <code>WORD_LEN</code>).</p>
<div><div><div><pre><p><span>1</span><span> </span><span>&lt;&lt;</span><span> </span><span>WORD_LOG</span><span></span></p><p><span></span><span>3</span><span> </span><span>&lt;&lt;</span><span> </span><span>WORD_LOG</span><span></span></p></pre></div></div></div>
<p>And so, we have a basic implementation.</p>
<div><div><div><pre><p><span>class</span><span> </span><span>BitSet</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>forEach</span><span>(</span><span>callback</span><span>:</span><span> </span><span>(</span><span>index</span><span>:</span><span> </span><span>number</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>void</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>const</span><span> words </span><span>=</span><span> </span><span>this</span><span>.</span><span>words</span><span>;</span><span></span></p><p><span>    </span><span>for</span><span> </span><span>(</span><span>let</span><span> wordIndex </span><span>=</span><span> </span><span>0</span><span>;</span><span> wordIndex </span><span>&lt;</span><span> words</span><span>.</span><span>length</span><span>;</span><span> wordIndex</span><span>++</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>      </span><span>const</span><span> word </span><span>=</span><span> words</span><span>[</span><span>wordIndex</span><span>]</span><span>;</span><span></span></p><p><span>      </span><span>for</span><span> </span><span>(</span><span>let</span><span> i </span><span>=</span><span> </span><span>0</span><span>;</span><span> i </span><span>&lt;</span><span> </span><span>WORD_LEN</span><span>;</span><span> i</span><span>++</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>        </span><span>const</span><span> bitIsSetToOne </span><span>=</span><span> </span><span>(</span><span>word </span><span>&amp;</span><span> </span><span>(</span><span>1</span><span> </span><span>&lt;&lt;</span><span> i</span><span>)</span><span>)</span><span> </span><span>!==</span><span> </span><span>0</span><span>;</span><span></span></p><p><span>        </span><span>if</span><span> </span><span>(</span><span>bitIsSetToOne</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>          </span><span>const</span><span> index </span><span>=</span><span> </span><span>(</span><span>wordIndex </span><span>&lt;&lt;</span><span> </span><span>WORD_LOG</span><span>)</span><span> </span><span>+</span><span> i</span><span>;</span><span></span></p><p><span>          </span><span>callback</span><span>(</span><span>index</span><span>)</span><span>;</span><span></span></p><p><span>        </span><span>}</span><span></span></p><p><span>      </span><span>}</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span>  </span><span>}</span><span></span></p><p><span></span><span>}</span><span></span></p></pre></div></div></div>
<h2>Optimizing <code>BitSet.forEach</code></h2>
<p>We&#39;ve now got a working implementation for <code>BitSet.forEach</code>. Can we optimize it further?</p>
<p>The first thing that pops out to me is that we always iterate over every bit in every word. We can skip words with no set bits with a cheap <code>word === 0</code> check.</p>
<div><div><div><pre><p><span>for</span><span> </span><span>(</span><span>let</span><span> wordIndex </span><span>=</span><span> </span><span>0</span><span>;</span><span> wordIndex </span><span>&lt;</span><span> words</span><span>.</span><span>length</span><span>;</span><span> wordIndex</span><span>++</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>const</span><span> word </span><span>=</span><span> words</span><span>[</span><span>wordIndex</span><span>]</span><span>;</span><span></span></p><p><span>  </span><span>if</span><span> </span><span>(</span><span>word </span><span>===</span><span> </span><span>0</span><span>)</span><span> </span><span>continue</span><span>;</span><span> </span><span></span></p><p><span></span><span>}</span><span></span></p></pre></div></div></div>
<p>This won&#39;t do much for dense sets where most words have some bits set, but this skips a lot of work for sparse sets.</p>
<div><div><div><pre><p><span></span><span>[</span><span> </span><span>00000000</span><span>,</span><span> </span><span>01000000</span><span>,</span><span> </span><span>00000000</span><span>,</span><span> </span><span>00000000</span><span>,</span><span> </span><span>0000001</span><span> </span><span>]</span><span></span></p><p><span></span><span>[</span><span> </span><span>11101101</span><span>,</span><span> </span><span>01110001</span><span>,</span><span> </span><span>10110101</span><span>,</span><span> </span><span>11010001</span><span>,</span><span> </span><span>0101101</span><span> </span><span>]</span><span></span></p></pre></div></div></div>
<p>But how significant are the performance gains from this optimization? Let&#39;s figure it out by running some benchmarks.</p>
<p>We&#39;ll run our benchmarks for bit sets with various densities:</p>
<div><div><div><pre><p><span></span><span>const</span><span> densities </span><span>=</span><span> </span><span>[</span><span>1</span><span>,</span><span> </span><span>0.75</span><span>,</span><span> </span><span>0.5</span><span>,</span><span> </span><span>0.25</span><span>,</span><span> </span><span>0.1</span><span>,</span><span> </span><span>0.05</span><span>,</span><span> </span><span>0.01</span><span>,</span><span> </span><span>0.001</span><span>]</span><span>;</span><span></span></p></pre></div></div></div>
<p>For each density, we&#39;ll create a bit set with 100 million bits.</p>
<div><div><div><pre><p><span>const</span><span> bitsetsAndDensities </span><span>=</span><span> densities</span><span>.</span><span>map</span><span>(</span><span>(</span><span>density</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>(</span><span>{</span><span></span></p><p><span>  density</span><span>,</span><span></span></p><p><span>  bitset</span><span>:</span><span> </span><span>makeBitSet</span><span>(</span><span>100_000_000</span><span>,</span><span> density</span><span>)</span><span>,</span><span></span></p><p><span></span><span>}</span><span>)</span><span>)</span><span>;</span><span></span></p></pre></div></div></div>
<p>The <code>makeBitSet</code> method is implemented like so:</p>
<div><div><div><pre><p><span>function</span><span> </span><span>makeBitSet</span><span>(</span><span>size</span><span>:</span><span> </span><span>number</span><span>,</span><span> density</span><span>:</span><span> </span><span>number</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>const</span><span> bitset </span><span>=</span><span> </span><span>new</span><span> </span><span>BitSet</span><span>(</span><span>)</span><span>;</span><span></span></p><p><span>  </span><span>for</span><span> </span><span>(</span><span>let</span><span> i </span><span>=</span><span> </span><span>0</span><span>;</span><span> i </span><span>&lt;</span><span> size</span><span>;</span><span> i</span><span>++</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>if</span><span> </span><span>(</span><span>Math</span><span>.</span><span>random</span><span>(</span><span>)</span><span> </span><span>&lt;</span><span> density</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>      bitset</span><span>.</span><span>add</span><span>(</span><span>i</span><span>)</span><span>;</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span>  </span><span>}</span><span></span></p><p><span>  </span><span>return</span><span> bitset</span><span>;</span><span></span></p><p><span></span><span>}</span><span></span></p></pre></div></div></div>
<p>Now that we&#39;ve created our bit sets, we&#39;ll run the <code>forEach</code> method for each of them and log out how long it takes.</p>
<div><div><div><pre><p><span>for</span><span> </span><span>(</span><span>const</span><span> </span><span>{</span><span> bitset</span><span>,</span><span> density </span><span>}</span><span> </span><span>of</span><span> bitsetsAndDensities</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>profile</span><span>(</span><span></span></p><p><span>    </span><span>(</span><span>)</span><span> </span><span>=&gt;</span><span> bitset</span><span>.</span><span>forEach</span><span>(</span><span>(</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span>}</span><span>)</span><span>,</span><span></span></p><p><span>    </span><span>(</span><span>time</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>console</span><span>.</span><span>log</span><span>(</span><span>`</span><span>${</span><span>percentage</span><span>(</span><span>density</span><span>)</span><span>}</span><span> density: </span><span>${</span><span>time</span><span>}</span><span>`</span><span>)</span><span>,</span><span></span></p><p><span>  </span><span>)</span><span>;</span><span></span></p><p><span></span><span>}</span><span></span></p></pre></div></div></div>
<p>For the unoptimized version, we get:</p>
<div><div><div><pre><p><span>100.0% density:     95.2 ms</span></p><p><span> 75.0% density:    250.7 ms</span></p><p><span> 50.0% density:    343.3 ms</span></p><p><span> 25.0% density:    221.8 ms</span></p><p><span> 10.0% density:    141.6 ms</span></p><p><span>  1.0% density:     78.5 ms</span></p><p><span>  0.1% density:     66.7 ms</span></p></pre></div></div></div>
<p>With the <code>ìf (word === 0) continue;</code> optimization, we get:</p>
<div><div><div><pre><p><span>100.0% density:     95.4 ms</span></p><p><span> 75.0% density:    245.5 ms</span></p><p><span> 50.0% density:    336.3 ms</span></p><p><span> 25.0% density:    213.9 ms</span></p><p><span> 10.0% density:    132.4 ms</span></p><p><span>  1.0% density:     34.6 ms</span></p><p><span>  0.1% density:      5.6 ms</span></p></pre></div></div></div>
<p>Let&#39;s put this into a table and compare the performance:</p>
<table data-align="right"><tbody><tr><th></th><th colspan="2">Unoptimized (baseline)</th><th colspan="2">Skip 0s</th></tr><tr data-reduce-padding="true"><th>Density</th><th>Runtime</th><th>Speed <sup>*</sup></th><th>Runtime</th><th>Speed <sup>*</sup></th></tr><tr><td>100.0%</td><td>95.2 ms</td><td>1.0x</td><td>95.4 ms</td><td>1.0x</td></tr><tr><td>75.0%</td><td>250.7 ms</td><td>1.0x</td><td>245.5 ms</td><td>1.0x</td></tr><tr><td>50.0%</td><td>343.3 ms</td><td>1.0x</td><td>336.3 ms</td><td>1.0x</td></tr><tr><td>25.0%</td><td>221.8 ms</td><td>1.0x</td><td>213.9 ms</td><td>1.0x</td></tr><tr><td>10.0%</td><td>141.6 ms</td><td>1.0x</td><td>132.4 ms</td><td>1.0x</td></tr><tr><td>5.0%</td><td>114.5 ms</td><td>1.0x</td><td>95.9 ms</td><td>1.2x</td></tr><tr><td>1.0%</td><td>78.5 ms</td><td>1.0x</td><td>34.6 ms</td><td>2.3x</td></tr><tr><td>0.1%</td><td>66.7 ms</td><td>1.0x</td><td>5.6 ms</td><td>11.9x</td></tr></tbody></table>
<p>* Speed compared to baseline</p>
<p>We observe no significant difference in performance for densities above 10%, but once we reach densities of ≤5% we start to see significant performance improvements: <strong>&gt;2x faster</strong> at 1% density and <strong>&gt;10x faster</strong> at 0.1% density.</p>
<h3>Skipping halves</h3>
<p>We can take this method of optimization further by skipping <em>each half</em> of a word if it&#39;s all 0s. We&#39;ll create bitmasks for each half of a word:</p>
<div><div><div><pre><p><span></span><span>export</span><span> </span><span>const</span><span> </span><span>WORD_FIRST_HALF_MASK</span><span> </span><span>=</span><span> </span><span>0x0000ffff</span><span>;</span><span></span></p><p><span></span><span>export</span><span> </span><span>const</span><span> </span><span>WORD_LATTER_HALF_MASK</span><span> </span><span>=</span><span> </span><span>0xffff0000</span><span>;</span><span></span></p><p><span></span><span>console</span><span>.</span><span>log</span><span>(</span><span>WORD_FIRST_HALF_MASK</span><span>)</span><span>;</span><span></span></p><p><span></span><span>console</span><span>.</span><span>log</span><span>(</span><span>WORD_LATTER_HALF_MASK</span><span>)</span><span>;</span><span></span></p></pre></div></div></div>
<p>Using them, we want to</p>
<ul>
<li>only iterate over bits 1-16 if there are any set bits in the first half, and</li>
<li>only iterate over bits 17-32 if there are any set bits in the latter half.</li>
</ul>
<p>We can determine whether to iterate over the halves like so:</p>
<div><div><div><pre><p><span>const</span><span> iterFirstHalf  </span><span>=</span><span> </span><span>(</span><span>word </span><span>&amp;</span><span> </span><span>WORD_FIRST_HALF_MASK</span><span>)</span><span>  </span><span>!==</span><span> </span><span>0</span><span>;</span><span></span></p><p><span></span><span>const</span><span> iterLatterHalf </span><span>=</span><span> </span><span>(</span><span>word </span><span>&amp;</span><span> </span><span>WORD_LATTER_HALF_MASK</span><span>)</span><span> </span><span>!==</span><span> </span><span>0</span><span>;</span><span></span></p></pre></div></div></div>
<p>Which we use to determine the range of bits we iterate over:</p>
<div><div><div><pre><p><span>const</span><span> start </span><span>=</span><span> iterFirstHalf </span><span>?</span><span> </span><span>0</span><span> </span><span>:</span><span> </span><span>WORD_LEN_HALF</span><span>;</span><span></span></p><p><span></span><span>const</span><span> end </span><span>=</span><span> iterLatterHalf </span><span>?</span><span> </span><span>WORD_LEN</span><span> </span><span>:</span><span> </span><span>WORD_LEN_HALF</span><span>;</span><span></span></p><p><span></span><span>for</span><span> </span><span>(</span><span>let</span><span> i </span><span>=</span><span> start</span><span>;</span><span> i </span><span>&lt;</span><span> end</span><span>;</span><span> i</span><span>++</span><span>)</span><span> </span><span>{</span><span></span></p><p><span></span><span>}</span><span></span></p></pre></div></div></div>
<!-- -->
<p>Let&#39;s see the difference this makes:</p>
<table data-align="right"><tbody><tr><th></th><th colspan="2">Unoptimized (baseline)</th><th colspan="2">Skip 0s</th><th colspan="2">Skip 0s and halves</th></tr><tr data-reduce-padding="true"><th>Density</th><th>Runtime</th><th>Speed <sup>*</sup></th><th>Runtime</th><th>Speed <sup>*</sup></th><th>Runtime</th><th>Speed <sup>*</sup></th></tr><tr><td>100.0%</td><td>95.2 ms</td><td>1.0x</td><td>95.4 ms</td><td>1.0x</td><td>99.2 ms</td><td>1.0x</td></tr><tr><td>75.0%</td><td>250.7 ms</td><td>1.0x</td><td>245.5 ms</td><td>1.0x</td><td>246.3 ms</td><td>1.0x</td></tr><tr><td>50.0%</td><td>343.3 ms</td><td>1.0x</td><td>336.3 ms</td><td>1.0x</td><td>346.3 ms</td><td>1.0x</td></tr><tr><td>25.0%</td><td>221.8 ms</td><td>1.0x</td><td>213.9 ms</td><td>1.0x</td><td>215.5 ms</td><td>1.0x</td></tr><tr><td>10.0%</td><td>141.6 ms</td><td>1.0x</td><td>132.4 ms</td><td>1.0x</td><td>133.6 ms</td><td>1.1x</td></tr><tr><td>5.0%</td><td>114.5 ms</td><td>1.0x</td><td>95.9 ms</td><td>1.2x</td><td>93.7 ms</td><td>1.2x</td></tr><tr><td>1.0%</td><td>78.5 ms</td><td>1.0x</td><td>34.6 ms</td><td>2.3x</td><td>28.5 ms</td><td>2.8x</td></tr><tr><td>0.1%</td><td>66.7 ms</td><td>1.0x</td><td>5.6 ms</td><td>11.9x</td><td>5.7 ms</td><td>11.7x</td></tr></tbody></table>
<p>* Speed compared to baseline</p>
<p>We receive a tiny performance penalty for high-density sets, but we see a slight performance boost for sets at a sweet spot of roughly 1% density.</p>
<p>This optimization may or may not be worth it depending on your average set density, but it doesn&#39;t move the needle all that much.</p>
<hr/>
<p>It was at this point in my bit set journey that I discovered a different approach for iterating over bits that yields significantly better results across all set densities.</p>
<h2>Two&#39;s complement</h2>
<p>Iterating over individual bits is expensive and requires an <code>if</code> statement at each iteration to check whether to invoke the callback or not. This <code>if</code> statement creates a <a target="_blank" href="https://johnnysswlab.com/how-branches-influence-the-performance-of-your-code-and-what-can-you-do-about-it/">branch</a> that further degrades performance.</p>
<p>If we were able to somehow &#34;jump&#34; to the next set bit, we would eliminate the need to iterate over 0 bits and perform a bunch of <code>if</code> statements.</p>
<p>As it turns out, there&#39;s a very cheap method to find the least significant bit set to 1, which looks like so:</p>

<p>When I first saw this, it made no sense to me. I thought:</p>
<blockquote>
<p><em>“Doesn&#39;t making a number negative just set the sign bit to 1?</em></p>
<p><em>If so, then <code>x &amp; -x</code> just yields <code>x</code>.”</em></p>
</blockquote>
<p>That would be true if signed integers were represented using <a target="_blank" href="https://en.wikipedia.org/wiki/Signed_number_representations#Sign%E2%80%93magnitude">sign-magnitude</a>, where the leftmost bit is the sign bit and the rest of the bits denote the value (magnitude).</p>
<table data-pad-heading="true" data-align="center"><tbody><tr><th colspan="4">Numbers represented using sign-magnitude</th></tr><tr><th colspan="2">Positive</th><th colspan="2">Negative</th></tr><tr><th>Bits</th><th>Value</th><th>Bits</th><th>Value</th></tr><tr><td>00000000</td><td>0</td><td>10000000</td><td>-0</td></tr><tr><td>00000001</td><td>1</td><td>10000001</td><td>-1</td></tr><tr><td>00000010</td><td>2</td><td>10000010</td><td>-2</td></tr><tr><td>00000011</td><td>3</td><td>10000011</td><td>-3</td></tr><tr><td>00001001</td><td>9</td><td>10001001</td><td>-9</td></tr><tr><td>01111111</td><td>127</td><td>11111111</td><td>−127</td></tr></tbody></table>
<p>But as I learned, signed integers are most commonly represented using <a target="_blank" href="https://en.wikipedia.org/wiki/Two%27s_complement">two&#39;s complement</a>.</p>
<p>Two&#39;s complement is different from sign-magnitude (and <a target="_blank" href="https://en.wikipedia.org/wiki/Signed_number_representations#Ones&#39;_complement">one&#39;s complement</a>) in that it only has one representation for 0 (there&#39;s no -0).</p>
<table data-pad-heading="true" data-align="center"><tbody><tr><th colspan="4">Numbers represented using two&#39;s complement</th></tr><tr><th colspan="2">Positive</th><th colspan="2">Negative</th></tr><tr><th>Bits</th><th>Value</th><th>Bits</th><th>Value</th></tr><tr><td>00000000</td><td>0</td><td></td><td></td></tr><tr><td>00000001</td><td>1</td><td>11111111</td><td>-1</td></tr><tr><td>00000010</td><td>2</td><td>11111110</td><td>-2</td></tr><tr><td>00000011</td><td>3</td><td>11111101</td><td>-3</td></tr><tr><td>00001001</td><td>9</td><td>11110111</td><td>-9</td></tr><tr><td>01111111</td><td>127</td><td>10000001</td><td>−127</td></tr><tr><td></td><td></td><td>10000000</td><td>−128</td></tr></tbody></table>
<p>The two&#39;s complement of an integer is computed by:</p>
<ol>
<li>inverting the bits (including the sign bit), and</li>
<li>adding 1 to the number.</li>
</ol>
<div><div><div><pre><p><span>00010011</span><span> </span><span></span></p><p><span></span><span>11101100</span><span></span></p><p><span></span><span>11101101</span><span> </span><span></span></p></pre></div></div></div>
<p>Note: <!-- -->This also works in the opposite direction (from negative to positive)</p>
<p>The binary representation of <code>19</code> has a 1 as the least-significant bit. Inverting makes the least significant bit become 0, so adding one will always make the first bit 1. This makes <code>x &amp; -x</code> yield the 1st set bit for any number where the least-significant bit is 1.</p>
<p>Let&#39;s take a look at a number with some leading 0s:</p>
<div><div><div><pre><p><span>00110000</span><span> </span><span></span></p><p><span></span><span>11001111</span><span></span></p><p><span></span><span>11010000</span><span> </span><span></span></p></pre></div></div></div>
<p>Here we observe that all the bits before the least-significant set bit become 1 when inverted. When 1 is added to the number, the 1s are carried until they reach the least-significant 0 (which was the least-significant 1 pre-inversion). This makes <code>x &amp; -x</code> yield the 1st set bit for any number with leading 0s.</p>
<p>So when iterating over the bits of a word, we can always find the least significant set bit via <code>word &amp; -word</code>. What&#39;s neat is that we can then use bitwise XOR to unset the bit:</p>
<div><div><div><pre><p><span>while</span><span> </span><span>(</span><span>word </span><span>!==</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>const</span><span> lsb </span><span>=</span><span> word </span><span>&amp;</span><span> </span><span>-</span><span>word</span><span>;</span><span></span></p><p><span>  word </span><span>^=</span><span> lsb</span><span>;</span><span> </span><span></span></p><p><span></span><span>}</span><span></span></p></pre></div></div></div>
<p>We can now iterate over the set bits of a word, but we&#39;ve got a small problem. We want to invoke the callback with the <em>index of</em> the set bits, not the set bits themselves.</p>
<p>We&#39;ll find the index of the set bit through the use of <a target="_blank" href="https://en.wikipedia.org/wiki/Hamming_weight">Hamming weights</a>.</p>
<h3>Hamming weight</h3>
<p>Given an integer with one set bit, we want to be able to quickly find the index of said bit:</p>
<div><div><div><pre><p><span>indexOfFirstSetBit</span><span>(</span><span>0b00000100</span><span>)</span><span></span></p><p><span></span><span>indexOfFirstSetBit</span><span>(</span><span>0b00000001</span><span>)</span><span></span></p><p><span></span><span>indexOfFirstSetBit</span><span>(</span><span>0b00100000</span><span>)</span><span></span></p></pre></div></div></div>
<p>The brute-force approach would be to walk over the bits one by one, but then we&#39;re back to iterating over bits. That&#39;s a no-go.</p>
<p>One observation to make is that the index of the set bit is equal to the number of leading 0s.</p>

<p>Consider what happens when we subtract 1. The leading 0s turn into 1s, and the set bit becomes unset.</p>

<p>This transforms the problem from finding the index of the set bit in <code>x</code> into computing the number of set bits in <code>x - 1</code>. The number of non-zero bits is known as the <a target="_blank" href="https://en.wikipedia.org/wiki/Hamming_weight">Hamming weight</a>, and it turns out that we can <a target="_blank" href="https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation">compute the Hamming weight</a> of an integer very cheaply:</p>
<div><div><div><pre><p><span></span><span>function</span><span> </span><span>hammingWeight</span><span>(</span><span>n</span><span>:</span><span> </span><span>number</span><span>)</span><span>:</span><span> </span><span>number</span><span> </span><span>{</span><span></span></p><p><span>  n </span><span>-=</span><span> </span><span>(</span><span>n </span><span>&gt;&gt;</span><span> </span><span>1</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>0x55555555</span><span>;</span><span></span></p><p><span>  n </span><span>=</span><span> </span><span>(</span><span>n </span><span>&amp;</span><span> </span><span>0x33333333</span><span>)</span><span> </span><span>+</span><span> </span><span>(</span><span>(</span><span>n </span><span>&gt;&gt;&gt;</span><span> </span><span>2</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>0x33333333</span><span>)</span><span>;</span><span></span></p><p><span>  </span><span>return</span><span> </span><span>(</span><span>(</span><span>(</span><span>n </span><span>+</span><span> </span><span>(</span><span>n </span><span>&gt;&gt;&gt;</span><span> </span><span>4</span><span>)</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>0xf0f0f0f</span><span>)</span><span> </span><span>*</span><span> </span><span>0x1010101</span><span>)</span><span> </span><span>&gt;&gt;</span><span> </span><span>24</span><span>;</span><span></span></p><p><span></span><span>}</span><span></span></p></pre></div></div></div>
<p>How this works, precisely, is something that we won&#39;t get into. We&#39;ll just trust that this works.</p>
<p>We now have all the pieces we need.</p>
<h3>Making BitSet.forEach go fast</h3>
<p>As before, we iterate over each word:</p>
<div><div><div><pre><p><span>class</span><span> </span><span>BitSet</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>forEach</span><span>(</span><span>callback</span><span>:</span><span> </span><span>(</span><span>index</span><span>:</span><span> </span><span>number</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>void</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>const</span><span> words </span><span>=</span><span> </span><span>this</span><span>.</span><span>words</span><span>;</span><span></span></p><p><span>    </span><span>for</span><span> </span><span>(</span><span>let</span><span> wordIndex </span><span>=</span><span> </span><span>0</span><span>;</span><span> wordIndex </span><span>&lt;</span><span> words</span><span>.</span><span>length</span><span>;</span><span> wordIndex</span><span>++</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>      </span><span>let</span><span> word </span><span>=</span><span> words</span><span>[</span><span>wordIndex</span><span>]</span><span>;</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span>  </span><span>}</span><span></span></p><p><span></span><span>}</span><span></span></p></pre></div></div></div>
<p>While <code>word</code> is non-zero, we find the least-significant bit <code>lsb</code>:</p>
<div><div><div><pre><p><span>while</span><span> </span><span>(</span><span>word </span><span>!==</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>const</span><span> lsb </span><span>=</span><span> word </span><span>&amp;</span><span> </span><span>-</span><span>word</span><span>;</span><span></span></p><p><span></span><span>}</span><span></span></p></pre></div></div></div>
<p>Using <code>lsb</code> we can compute the index using the hamming weight of <code>lsb - 1</code>:</p>
<div><div><div><pre><p><span>const</span><span> index </span><span>=</span><span> </span><span>(</span><span>wordIndex </span><span>&lt;&lt;</span><span> </span><span>WORD_LOG</span><span>)</span><span> </span><span>+</span><span> </span><span>hammingWeight</span><span>(</span><span>lsb </span><span>-</span><span> </span><span>1</span><span>)</span><span>;</span><span></span></p><p><span></span><span>callback</span><span>(</span><span>index</span><span>)</span><span>;</span><span></span></p></pre></div></div></div>
<p>Before the next iteration, we unset the least significant bit via <code>word XOR lsb</code>, making <code>word</code> ready for the next iteration:</p>

<p>The full implementation looks like so:</p>
<div><div><div><pre><p><span>forEach</span><span>(</span><span>callback</span><span>:</span><span> </span><span>(</span><span>index</span><span>:</span><span> </span><span>number</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>void</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>const</span><span> words </span><span>=</span><span> </span><span>this</span><span>.</span><span>words</span><span>;</span><span></span></p><p><span>  </span><span>for</span><span> </span><span>(</span><span>let</span><span> wordIndex </span><span>=</span><span> </span><span>0</span><span>;</span><span> wordIndex </span><span>&lt;</span><span> words</span><span>.</span><span>length</span><span>;</span><span> wordIndex</span><span>++</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>let</span><span> word </span><span>=</span><span> words</span><span>[</span><span>wordIndex</span><span>]</span><span>;</span><span></span></p><p><span>    </span><span>while</span><span> </span><span>(</span><span>word </span><span>!==</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>      </span><span>const</span><span> lsb </span><span>=</span><span> word </span><span>&amp;</span><span> </span><span>-</span><span>word</span><span>;</span><span></span></p><p><span>      </span><span>const</span><span> index </span><span>=</span><span> </span><span>(</span><span>wordIndex </span><span>&lt;&lt;</span><span> </span><span>WORD_LOG</span><span>)</span><span> </span><span>+</span><span> </span><span>hammingWeight</span><span>(</span><span>lsb </span><span>-</span><span> </span><span>1</span><span>)</span><span>;</span><span></span></p><p><span>      </span><span>callback</span><span>(</span><span>index</span><span>)</span><span>;</span><span></span></p><p><span>      word </span><span>^=</span><span> lsb</span><span>;</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span>  </span><span>}</span><span></span></p><p><span></span><span>}</span><span></span></p></pre></div></div></div>
<p>But how fast is this optimized version? Let&#39;s run our benchmark and compare.</p>
<table data-align="right"><tbody><tr><th></th><th colspan="2">Unoptimized (baseline)</th><th colspan="2">Skip 0s</th><th colspan="2">Optimized</th></tr><tr data-reduce-padding="true"><th>Density</th><th>Runtime</th><th>Speed <sup>*</sup></th><th>Runtime</th><th>Speed <sup>*</sup></th><th>Runtime</th><th>Speed <sup>*</sup></th></tr><tr><td>100.0%</td><td>95.2 ms</td><td>1.0x</td><td>95.4 ms</td><td>1.0x</td><td>53.4 ms</td><td>1.8x</td></tr><tr><td>75.0%</td><td>250.7 ms</td><td>1.0x</td><td>245.5 ms</td><td>1.0x</td><td>91.9 ms</td><td>2.7x</td></tr><tr><td>50.0%</td><td>343.3 ms</td><td>1.0x</td><td>336.3 ms</td><td>1.0x</td><td>68.4 ms</td><td>5.0x</td></tr><tr><td>25.0%</td><td>221.8 ms</td><td>1.0x</td><td>213.9 ms</td><td>1.0x</td><td>44.4 ms</td><td>5.0x</td></tr><tr><td>10.0%</td><td>141.6 ms</td><td>1.0x</td><td>132.4 ms</td><td>1.0x</td><td>30.1 ms</td><td>4.7x</td></tr><tr><td>5.0%</td><td>114.5 ms</td><td>1.0x</td><td>95.9 ms</td><td>1.2x</td><td>24.8 ms</td><td>4.6x</td></tr><tr><td>1.0%</td><td>78.5 ms</td><td>1.0x</td><td>34.6 ms</td><td>2.3x</td><td>10.0 ms</td><td>7.8x</td></tr><tr><td>0.1%</td><td>66.7 ms</td><td>1.0x</td><td>5.6 ms</td><td>11.9x</td><td>4.0 ms</td><td>16.7x</td></tr></tbody></table>
<p>* Speed compared to baseline</p>
<p>For densities of 5-50%, we receive a <strong>~5x increase in performance</strong>. Higher densities of 75% and above receive a notable speedup of &gt;2x, while the densities below 5% see a <strong>5-17x increase in performance</strong>.</p>
<h2>A full BitSet implementation</h2>
<p>I&#39;ve recently published a performant and feature-complete <code>BitSet</code> package <a target="_blank" href="https://www.npmjs.com/package/bitset-mut">on npm</a>.</p>
<p>If you want to explore the full implementation, take a look at the <a target="_blank" href="https://github.com/alexharri/bitset-mut">GitHub repo</a>.</p>
<h2>Further reading</h2>
<p><a target="_blank" href="https://lemire.me/blog/">Daniel Lemire</a> has written <a target="_blank" href="https://lemire.me/blog/2018/02/21/iterating-over-set-bits-quickly/">lots</a> <a target="_blank" href="https://lemire.me/blog/2012/11/13/fast-sets-of-integers/">of</a> <a target="_blank" href="https://lemire.me/blog/2019/05/03/really-fast-bitset-decoding-for-average-densities/">posts</a> about bit sets. His <a target="_blank" href="https://github.com/lemire/FastBitSet.js"><code>FastBitSet</code> implementation</a> is where I discovered this trick for optimizing over set bits. If you&#39;re into software performance, he&#39;s written <em>a lot</em> on that topic.</p>
<h2>Parting thoughts</h2>
<p>Any given piece of code can be optimized, but taking a different approach will often outperform those local optimizations.</p>
<p>Different algorithms will often favor some inputs over others, as we saw with low vs high-density sets in this post. It&#39;s useful to keep these sorts of trade-offs in mind when considering which way to go. Benchmark when possible!</p>
<hr/>
<p>Anyway, thanks for reading this short series on bit set! If you haven&#39;t read part 1 yet, you can find it here: <a href="https://alexharri.com/blog/bit-sets" target="_blank">Bit Sets: An introduction to bit manipulation</a>.</p>
<p>I may write a part 3, taking an in-depth look at bit set performance for boolean operations (and, or, xor, andNot, etc), but I&#39;ve thought about bit sets quite enough for now.</p>
<p>— Alex Harri</p></main></div></div>
  </body>
</html>
