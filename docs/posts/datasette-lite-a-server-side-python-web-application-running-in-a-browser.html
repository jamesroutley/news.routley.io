<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://simonwillison.net/2022/May/4/datasette-lite/">Original</a>
    <h1>Datasette Lite: a server-side Python web application running in a browser</h1>
    
    <div id="readability-page-1" class="page"><div id="primary">

<div>




<p><a href="https://github.com/simonw/datasette-lite">Datasette Lite</a> is a new way to run <a href="https://datasette.io/">Datasette</a>: entirely in a browser, taking advantage of the incredible <a href="https://pyodide.org/">Pyodide</a> project which provides Python compiled to WebAssembly plus a whole suite of useful extras.</p>
<p>You can try it out here:</p>
<p><a href="https://simonw.github.io/datasette-lite/">https://simonw.github.io/datasette-lite/</a></p>
<p><img alt="A screenshot of the pypi_packages database table running in Google Chrome in a page with the URL of simonw.github.io/datasette-lite/#/content/pypi_packages?_facet=author" src="https://static.simonwillison.net/static/2022/datasette-lite.jpg"/></p>
<p>The initial example loads two databases—the classic <a href="https://latest.datasette.io/fixtures">fixtures.db</a> used by the Datasette test suite, and the <a href="https://datasette.io/content">content.db</a> database that powers the official <a href="https://datasette.io/">datasette.io</a> website (described in some detail in <a href="https://simonwillison.net/2021/Jul/28/baked-data/">my post about Baked Data</a>).</p>
<p>You can instead use the “Load database by URL to a SQLite DB” button to paste in a URL to your own database. That file will need to be served with CORS headers that allow it to be fetched by the website (<a href="https://github.com/simonw/datasette-lite/#opening-other-databases">see README</a>).</p>
<p>Try this URL, for example:</p>
<pre><code>https://congress-legislators.datasettes.com/legislators.db
</code></pre>
<p>You can <a href="https://simonw.github.io/datasette-lite/?url=https%3A%2F%2Fcongress-legislators.datasettes.com%2Flegislators.db">follow this link</a> to open that database in Datasette Lite.</p>
<p>Datasette Lite supports almost all of Datasette’s regular functionality: you can view tables, apply facets, run your own custom SQL results and export the results as CSV or JSON.</p>
<p>It’s basically the full Datasette experience, except it’s running entirely in your browser with no server (other than the static file hosting provided here by GitHub Pages) required.</p>
<p>I’m pretty stunned that this is possible now.</p>
<p>I had to make some small changes to Datasette to get this to work, detailed below, but really nothing extravagant—the demo is running the exact same Python code as the regular server-side Datasette application, just inside a web worker process in a browser rather than on a server.</p>
<p>The implementation is pretty small—around 300 lines of JavaScript. You can see the code in the <a href="https://github.com/simonw/datasette-lite">simonw/datasette-lite</a> repository—in two files, <a href="https://github.com/simonw/datasette-lite/blob/6ae4cacf140f0c7c6eafa8cf0f92a2dae44425ff/index.html">index.html</a> and <a href="https://github.com/simonw/datasette-lite/blob/main/webworker.js">webworker.js</a></p>
<h4>Why build this?</h4>
<p>I built this because I want as many people as possible to be able to use my software.</p>
<p>I’ve invested a ton of effort in reducing the friction to getting started with Datasette. I’ve <a href="https://docs.datasette.io/en/stable/installation.html">documented the install process</a>, I’ve <a href="https://formulae.brew.sh/formula/datasette">packaged it for Homebrew</a>, I’ve written guides to <a href="https://docs.datasette.io/en/stable/getting_started.html#try-datasette-without-installing-anything-using-glitch">running it on Glitch</a>, I’ve built tools to help deploy it to <a href="https://docs.datasette.io/en/stable/publish.html#publishing-to-heroku">Heroku</a>, <a href="https://docs.datasette.io/en/stable/publish.html#publishing-to-google-cloud-run">Cloud Run</a>, <a href="https://docs.datasette.io/en/stable/publish.html#publishing-to-vercel">Vercel</a> and <a href="https://simonwillison.net/2022/Feb/15/fly-volumes/">Fly.io</a>. I even taught myself Electron and built a macOS <a href="https://datasette.io/desktop">Datasette Desktop</a> application, so people could install it without having to think about their Python environment.</p>
<p>Datasette Lite is my latest attempt at this. Anyone with a browser that can run WebAssembly can now run Datasette in it—if they can afford the 10MB load (which in many places with metered internet access is way too much).</p>
<p>I also built this because I’m fascinated by WebAssembly and I’ve been looking for an opportunity to really try it out.</p>
<p>And, I find this project deeply amusing. Running a Python server-side web application in a browser still feels like an absurd thing to do. I love that it works.</p>
<p>I’m deeply inspired by <a href="https://jupyterlite.readthedocs.io/en/latest/">JupyterLite</a>. Datasette Lite’s name is a tribute to that project.</p>
<h4>How it works: Python in a Web Worker</h4>
<p>Datasette Lite does most of its work in a <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers">Web Worker</a>—a separate process that can run expensive CPU operations (like an entire Python interpreter) without blocking the main browser’s UI thread.</p>
<p>The worker starts running when you load the page. It loads a WebAssembly compiled Python interpreter from a CDN, then installs Datasette and its dependencies into that interpreter using <a href="https://pyodide.org/en/stable/usage/loading-packages.html#micropip">micropip</a>.</p>
<p>It also downloads the specified SQLite database files using the browser’s HTTP fetching mechanism and writes them to a virtual in-memory filesystem managed by Pyodide.</p>
<p>Once everything is installed, it imports <code>datasette</code> and creates a <code>Datasette()</code> object called <code>ds</code>. This object stays resident in the web worker.</p>
<p>To render pages, the <code>index.html</code> page sends a message to the web worker specifying which Datasette path has been requested—<code>/</code> for the homepage, <code>/fixtures</code> for the database index page, <code>/fixtures/facetable</code> for a table page and so on.</p>
<p>The web worker then simulates an HTTP GET against that path within Datasette using the following code:</p>
<pre><span>response</span> <span>=</span> <span>await</span> <span>ds</span>.<span>client</span>.<span>get</span>(<span>path</span>, <span>follow_redirects</span><span>=</span><span>True</span>)</pre>
<p>This takes advantage of a really useful internal Datasette API: <a href="https://docs.datasette.io/en/stable/internals.html#datasette-client">datasette.client</a> is an <a href="https://www.python-httpx.org/">HTTPX</a> client object that can be used to execute HTTP requests against Datasette internally, without doing a round-trip across the network.</p>
<p>I initially added <code>datasette.client</code> with the goal of making any JSON APIs that Datasette provides available for internal calls by plugins as well, and to make it easier to write automated tests. It turns out to have other interesting applications too!</p>
<p>The web worker sends a message back to <code>index.html</code> with the status code, content type and content retrieved from Datasette. JavaScript in <code>index.html</code> then injects that HTML into the page using <code>.innerHTML</code>.</p>
<p>To get internal links working, Datasette Lite uses a trick I originally learned from jQuery: it applies a capturing event listener to the area of the page displaying the content, such that any link clicks or form submissions will be intercepted by a JavaScript function. That JavaScript can then turn them into new messages to the web worker rather than navigating to another page.</p>
<h4>Some annotated code</h4>
<p>Here are annotated versions of the most important pieces of code. In <code>index.html</code> this code manages the worker and updates the page when it recieves messages from it:</p>
<div><pre><span>// Load the worker script</span>
<span>const</span> <span>datasetteWorker</span> <span>=</span> <span>new</span> <span>Worker</span><span>(</span><span>&#34;webworker.js&#34;</span><span>)</span><span>;</span>

<span>// Extract the ?url= from the current page&#39;s URL</span>
<span>const</span> <span>initialUrl</span> <span>=</span> <span>new</span> <span>URLSearchParams</span><span>(</span><span>location</span><span>.</span><span>search</span><span>)</span><span>.</span><span>get</span><span>(</span><span>&#39;url&#39;</span><span>)</span><span>;</span>

<span>// Message that to the worker: {type: &#39;startup&#39;, initialUrl: url}</span>
<span>datasetteWorker</span><span>.</span><span>postMessage</span><span>(</span><span>{</span><span>type</span>: <span>&#39;startup&#39;</span><span>,</span> initialUrl<span>}</span><span>)</span><span>;</span>

<span>// This function does most of the work - it responds to messages sent</span>
<span>// back from the worker to the index page:</span>
<span>datasetteWorker</span><span>.</span><span>onmessage</span> <span>=</span> <span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>// {type: log, line: ...} messages are appended to a log textarea:</span>
  <span>var</span> <span>ta</span> <span>=</span> <span>document</span><span>.</span><span>getElementById</span><span>(</span><span>&#39;loading-logs&#39;</span><span>)</span><span>;</span>
  <span>if</span> <span>(</span><span>event</span><span>.</span><span>data</span><span>.</span><span>type</span> <span>==</span> <span>&#39;log&#39;</span><span>)</span> <span>{</span>
    <span>loadingLogs</span><span>.</span><span>push</span><span>(</span><span>event</span><span>.</span><span>data</span><span>.</span><span>line</span><span>)</span><span>;</span>
    <span>ta</span><span>.</span><span>value</span> <span>=</span> <span>loadingLogs</span><span>.</span><span>join</span><span>(</span><span>&#34;\n&#34;</span><span>)</span><span>;</span>
    <span>ta</span><span>.</span><span>scrollTop</span> <span>=</span> <span>ta</span><span>.</span><span>scrollHeight</span><span>;</span>
    <span>return</span><span>;</span>
  <span>}</span>
  <span>let</span> <span>html</span> <span>=</span> <span>&#39;&#39;</span><span>;</span>
  <span>// If it&#39;s an {error: ...} message show it in a &lt;pre&gt; in a &lt;div&gt;</span>
  <span>if</span> <span>(</span><span>event</span><span>.</span><span>data</span><span>.</span><span>error</span><span>)</span> <span>{</span>
    <span>html</span> <span>=</span> <span>`&lt;div style=&#34;padding: 0.5em&#34;&gt;&lt;h3&gt;Error&lt;/h3&gt;&lt;pre&gt;<span><span>${</span><span>escapeHtml</span><span>(</span><span>event</span><span>.</span><span>data</span><span>.</span><span>error</span><span>)</span><span>}</span></span>&lt;/pre&gt;&lt;/div&gt;`</span><span>;</span>
  <span>// If contentType is text/html, show it as straight HTML</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span><span><span>/</span><span>^</span>text<span>\/</span>html<span>/</span></span><span>.</span><span>exec</span><span>(</span><span>event</span><span>.</span><span>data</span><span>.</span><span>contentType</span><span>)</span><span>)</span> <span>{</span>
    <span>html</span> <span>=</span> <span>event</span><span>.</span><span>data</span><span>.</span><span>text</span><span>;</span>
  <span>// For contentType of application/json parse and pretty-print it</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span><span><span>/</span><span>^</span>application<span>\/</span>json<span>/</span></span><span>.</span><span>exec</span><span>(</span><span>event</span><span>.</span><span>data</span><span>.</span><span>contentType</span><span>)</span><span>)</span> <span>{</span>
    <span>html</span> <span>=</span> <span>`&lt;pre style=&#34;padding: 0.5em&#34;&gt;<span><span>${</span><span>escapeHtml</span><span>(</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span><span>JSON</span><span>.</span><span>parse</span><span>(</span><span>event</span><span>.</span><span>data</span><span>.</span><span>text</span><span>)</span><span>,</span> <span>null</span><span>,</span> <span>4</span><span>)</span><span>)</span><span>}</span></span>&lt;/pre&gt;`</span><span>;</span>
  <span>// Anything else (likely CSV data) escape it and show in a &lt;pre&gt;</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>html</span> <span>=</span> <span>`&lt;pre style=&#34;padding: 0.5em&#34;&gt;<span><span>${</span><span>escapeHtml</span><span>(</span><span>event</span><span>.</span><span>data</span><span>.</span><span>text</span><span>)</span><span>}</span></span>&lt;/pre&gt;`</span><span>;</span>
  <span>}</span>
  <span>// Add the result to &lt;div id=&#34;output&#34;&gt; using innerHTML</span>
  <span>document</span><span>.</span><span>getElementById</span><span>(</span><span>&#34;output&#34;</span><span>)</span><span>.</span><span>innerHTML</span> <span>=</span> <span>html</span><span>;</span>
  <span>// Update the document.title if a &lt;title&gt; element is present</span>
  <span>let</span> <span>title</span> <span>=</span> <span>document</span><span>.</span><span>getElementById</span><span>(</span><span>&#34;output&#34;</span><span>)</span><span>.</span><span>querySelector</span><span>(</span><span>&#34;title&#34;</span><span>)</span><span>;</span>
  <span>if</span> <span>(</span><span>title</span><span>)</span> <span>{</span>
    <span>document</span><span>.</span><span>title</span> <span>=</span> <span>title</span><span>.</span><span>innerText</span><span>;</span>
  <span>}</span>
  <span>// Scroll to the top of the page after each new page is loaded</span>
  <span>window</span><span>.</span><span>scrollTo</span><span>(</span><span>{</span><span>top</span>: <span>0</span><span>,</span> <span>left</span>: <span>0</span><span>}</span><span>)</span><span>;</span>
  <span>// If we&#39;re showing the initial loading indicator, hide it</span>
  <span>document</span><span>.</span><span>getElementById</span><span>(</span><span>&#39;loading-indicator&#39;</span><span>)</span><span>.</span><span>style</span><span>.</span><span>display</span> <span>=</span> <span>&#39;none&#39;</span><span>;</span>
<span>}</span><span>;</span></pre></div>
<p>The <code>webworker.js</code> script is where the real magic happens:</p>
<div><pre><span>// Load Pyodide from the CDN</span>
<span>importScripts</span><span>(</span><span>&#34;https://cdn.jsdelivr.net/pyodide/dev/full/pyodide.js&#34;</span><span>)</span><span>;</span>

<span>// Deliver log messages back to the index.html page</span>
<span>function</span> <span>log</span><span>(</span><span>line</span><span>)</span> <span>{</span>
  <span>self</span><span>.</span><span>postMessage</span><span>(</span><span>{</span><span>type</span>: <span>&#39;log&#39;</span><span>,</span> <span>line</span>: <span>line</span><span>}</span><span>)</span><span>;</span>
<span>}</span>

<span>// This function initializes Pyodide and installs Datasette</span>
<span>async</span> <span>function</span> <span>startDatasette</span><span>(</span><span>initialUrl</span><span>)</span> <span>{</span>
  <span>// Mechanism for downloading and saving specified DB files</span>
  <span>let</span> <span>toLoad</span> <span>=</span> <span>[</span><span>]</span><span>;</span>
  <span>if</span> <span>(</span><span>initialUrl</span><span>)</span> <span>{</span>
    <span>let</span> <span>name</span> <span>=</span> <span>initialUrl</span><span>.</span><span>split</span><span>(</span><span>&#39;.db&#39;</span><span>)</span><span>[</span><span>0</span><span>]</span><span>.</span><span>split</span><span>(</span><span>&#39;/&#39;</span><span>)</span><span>.</span><span>slice</span><span>(</span><span>-</span><span>1</span><span>)</span><span>[</span><span>0</span><span>]</span><span>;</span>
    <span>toLoad</span><span>.</span><span>push</span><span>(</span><span>[</span><span>name</span><span>,</span> <span>initialUrl</span><span>]</span><span>)</span><span>;</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>// If no ?url= provided, loads these two demo databases instead:</span>
    <span>toLoad</span><span>.</span><span>push</span><span>(</span><span>[</span><span>&#34;fixtures.db&#34;</span><span>,</span> <span>&#34;https://latest.datasette.io/fixtures.db&#34;</span><span>]</span><span>)</span><span>;</span>
    <span>toLoad</span><span>.</span><span>push</span><span>(</span><span>[</span><span>&#34;content.db&#34;</span><span>,</span> <span>&#34;https://datasette.io/content.db&#34;</span><span>]</span><span>)</span><span>;</span>
  <span>}</span>
  <span>// This does a LOT of work - it pulls down the WASM blob and starts it running</span>
  <span>self</span><span>.</span><span>pyodide</span> <span>=</span> <span>await</span> <span>loadPyodide</span><span>(</span><span>{</span>
    <span>indexURL</span>: <span>&#34;https://cdn.jsdelivr.net/pyodide/dev/full/&#34;</span>
  <span>}</span><span>)</span><span>;</span>
  <span>// We need these packages for the next bit of code to work</span>
  <span>await</span> <span>pyodide</span><span>.</span><span>loadPackage</span><span>(</span><span>&#39;micropip&#39;</span><span>,</span> <span>log</span><span>)</span><span>;</span>
  <span>await</span> <span>pyodide</span><span>.</span><span>loadPackage</span><span>(</span><span>&#39;ssl&#39;</span><span>,</span> <span>log</span><span>)</span><span>;</span>
  <span>await</span> <span>pyodide</span><span>.</span><span>loadPackage</span><span>(</span><span>&#39;setuptools&#39;</span><span>,</span> <span>log</span><span>)</span><span>;</span> <span>// For pkg_resources</span>
  <span>try</span> <span>{</span>
    <span>// Now we switch to Python code</span>
    <span>await</span> <span>self</span><span>.</span><span>pyodide</span><span>.</span><span>runPythonAsync</span><span>(</span><span>`</span>
<span>    # Here&#39;s where we download and save those .db files - they are saved</span>
<span>    # to a virtual in-memory filesystem provided by Pyodide</span>
<span>
<span>    # pyfetch is a wrapper around the JS fetch() function - calls using</span>
<span>    # it are handled by the browser&#39;s regular HTTP fetching mechanism</span>
<span>    from pyodide.http import pyfetch</span>
<span>    names = []</span>
<span>    for name, url in <span><span>${</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span><span>toLoad</span><span>)</span><span>}</span></span>:</span>
<span>        response = await pyfetch(url)</span>
<span>        with open(name, &#34;wb&#34;) as fp:</span>
<span>            fp.write(await response.bytes())</span>
<span>        names.append(name)</span>
<span>
<span>    import micropip</span>
<span>    # Workaround for Requested &#39;h11&lt;0.13,&gt;=0.11&#39;, but h11==0.13.0 is already installed</span>
<span>    await micropip.install(&#34;h11==0.12.0&#34;)</span>
<span>    # Install Datasette itself!</span>
<span>    await micropip.install(&#34;datasette==0.62a0&#34;)</span>
<span>    # Now we can create a Datasette() object that can respond to fake requests</span>
<span>    from datasette.app import Datasette</span>
<span>    ds = Datasette(names, settings={</span>
<span>        &#34;num_sql_threads&#34;: 0,</span>
<span>    }, metadata = {</span>
<span>        # This metadata is displayed in Datasette&#39;s footer</span>
<span>        &#34;about&#34;: &#34;Datasette Lite&#34;,</span>
<span>        &#34;about_url&#34;: &#34;https://github.com/simonw/datasette-lite&#34;</span>
<span>    })</span>
<span>    `</span><span>)</span><span>;</span>
    <span>datasetteLiteReady</span><span>(</span><span>)</span><span>;</span>
  <span>}</span> <span>catch</span> <span>(</span><span>error</span><span>)</span> <span>{</span>
    <span>self</span><span>.</span><span>postMessage</span><span>(</span><span>{</span><span>error</span>: <span>error</span><span>.</span><span>message</span><span>}</span><span>)</span><span>;</span>
  <span>}</span>
<span>}</span>

<span>// Outside promise pattern</span>
<span>// https://github.com/simonw/datasette-lite/issues/25#issuecomment-1116948381</span>
<span>let</span> <span>datasetteLiteReady</span><span>;</span>
<span>let</span> <span>readyPromise</span> <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>function</span><span>(</span><span>resolve</span><span>)</span> <span>{</span>
  <span>datasetteLiteReady</span> <span>=</span> <span>resolve</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

<span>// This function handles messages sent from index.html to webworker.js</span>
<span>self</span><span>.</span><span>onmessage</span> <span>=</span> <span>async</span> <span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>// The first message should be that startup message, carrying the URL</span>
  <span>if</span> <span>(</span><span>event</span><span>.</span><span>data</span><span>.</span><span>type</span> <span>==</span> <span>&#39;startup&#39;</span><span>)</span> <span>{</span>
    <span>await</span> <span>startDatasette</span><span>(</span><span>event</span><span>.</span><span>data</span><span>.</span><span>initialUrl</span><span>)</span><span>;</span>
    <span>return</span><span>;</span>
  <span>}</span>
  <span>// This promise trick ensures that we don&#39;t run the next block until we</span>
  <span>// are certain that startDatasette() has finished and the ds.client</span>
  <span>// Python object is ready to use</span>
  <span>await</span> <span>readyPromise</span><span>;</span>
  <span>// Run the reuest in Python to get a status code, content type and text</span>
  <span>try</span> <span>{</span>
    <span>let</span> <span>[</span><span>status</span><span>,</span> <span>contentType</span><span>,</span> <span>text</span><span>]</span> <span>=</span> <span>await</span> <span>self</span><span>.</span><span>pyodide</span><span>.</span><span>runPythonAsync</span><span>(</span>
      <span>`</span>
<span>      import json</span>
<span>      # ds.client.get(path) simulates running a request through Datasette</span>
<span>      response = await ds.client.get(</span>
<span>          # Using json here is a quick way to generate a quoted string</span>
<span>          <span><span>${</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span><span>event</span><span>.</span><span>data</span><span>.</span><span>path</span><span>)</span><span>}</span></span>,</span>
<span>          # If Datasette redirects to another page we want to follow that</span>
<span>          follow_redirects=True</span>
<span>      )</span>
<span>      [response.status_code, response.headers.get(&#34;content-type&#34;), response.text]</span>
<span>      `</span>
    <span>)</span><span>;</span>
    <span>// Message the results back to index.html</span>
    <span>self</span><span>.</span><span>postMessage</span><span>(</span><span>{</span>status<span>,</span> contentType<span>,</span> text<span>}</span><span>)</span><span>;</span>
  <span>}</span> <span>catch</span> <span>(</span><span>error</span><span>)</span> <span>{</span>
    <span>// If an error occurred, send that back as a {error: ...} message</span>
    <span>self</span><span>.</span><span>postMessage</span><span>(</span><span>{</span><span>error</span>: <span>error</span><span>.</span><span>message</span><span>}</span><span>)</span><span>;</span>
  <span>}</span>
<span>}</span><span>;</span></span></span></pre></div>
<p>One last bit of code: here’s the JavaScript in <code>index.html</code> which intercepts clicks on links and turns them into messages to the worker:</p>
<div><pre><span>let</span> <span>output</span> <span>=</span> <span>document</span><span>.</span><span>getElementById</span><span>(</span><span>&#39;output&#39;</span><span>)</span><span>;</span>
<span>// This captures any click on any element within &lt;div id=&#34;output&#34;&gt;</span>
<span>output</span><span>.</span><span>addEventListener</span><span>(</span><span>&#39;click&#39;</span><span>,</span> <span>(</span><span>ev</span> <span>=&gt;</span> <span>{</span>
  <span>// .closest(&#34;a&#34;) traverses up the DOM to find if this is an a</span>
  <span>// or an element nested in an a. We ignore other clicks.</span>
  <span>var</span> <span>link</span> <span>=</span> <span>ev</span><span>.</span><span>srcElement</span><span>.</span><span>closest</span><span>(</span><span>&#34;a&#34;</span><span>)</span><span>;</span>
  <span>if</span> <span>(</span><span>link</span> <span>&amp;&amp;</span> <span>link</span><span>.</span><span>href</span><span>)</span> <span>{</span>
    <span>// It was a click on a &lt;a href=&#34;...&#34;&gt; link! Cancel the event:</span>
    <span>ev</span><span>.</span><span>stopPropagation</span><span>(</span><span>)</span><span>;</span>
    <span>ev</span><span>.</span><span>preventDefault</span><span>(</span><span>)</span><span>;</span>
    <span>// I want #fragment links to still work, using scrollIntoView()</span>
    <span>if</span> <span>(</span><span>isFragmentLink</span><span>(</span><span>link</span><span>.</span><span>href</span><span>)</span><span>)</span> <span>{</span>
      <span>// Jump them to that element, but don&#39;t update the URL bar</span>
      <span>// since we use # in the URL to mean something else</span>
      <span>let</span> <span>fragment</span> <span>=</span> <span>new</span> <span>URL</span><span>(</span><span>link</span><span>.</span><span>href</span><span>)</span><span>.</span><span>hash</span><span>.</span><span>replace</span><span>(</span><span>&#34;#&#34;</span><span>,</span> <span>&#34;&#34;</span><span>)</span><span>;</span>
      <span>if</span> <span>(</span><span>fragment</span><span>)</span> <span>{</span>
        <span>let</span> <span>el</span> <span>=</span> <span>document</span><span>.</span><span>getElementById</span><span>(</span><span>fragment</span><span>)</span><span>;</span>
        <span>el</span><span>.</span><span>scrollIntoView</span><span>(</span><span>)</span><span>;</span>
      <span>}</span>
      <span>return</span><span>;</span>
    <span>}</span>
    <span>let</span> <span>href</span> <span>=</span> <span>link</span><span>.</span><span>getAttribute</span><span>(</span><span>&#34;href&#34;</span><span>)</span><span>;</span>
    <span>// Links to external sites should open in a new window</span>
    <span>if</span> <span>(</span><span>isExternal</span><span>(</span><span>href</span><span>)</span><span>)</span> <span>{</span>
      <span>window</span><span>.</span><span>open</span><span>(</span><span>href</span><span>)</span><span>;</span>
      <span>return</span><span>;</span>
    <span>}</span>
    <span>// It&#39;s an internal link navigation - send it to the worker</span>
    <span>loadPath</span><span>(</span><span>href</span><span>)</span><span>;</span>
  <span>}</span>
<span>}</span><span>)</span><span>,</span> <span>true</span><span>)</span><span>;</span>

<span>function</span> <span>loadPath</span><span>(</span><span>path</span><span>)</span> <span>{</span>
  <span>// We don&#39;t want anything after #, and we only want the /path</span>
  <span>path</span> <span>=</span> <span>path</span><span>.</span><span>split</span><span>(</span><span>&#34;#&#34;</span><span>)</span><span>[</span><span>0</span><span>]</span><span>.</span><span>replace</span><span>(</span><span>&#34;http://localhost&#34;</span><span>,</span> <span>&#34;&#34;</span><span>)</span><span>;</span>
  <span>// Update the URL with the new # location</span>
  <span>history</span><span>.</span><span>pushState</span><span>(</span><span>{</span><span>path</span>: <span>path</span><span>}</span><span>,</span> <span>path</span><span>,</span> <span>&#34;#&#34;</span> <span>+</span> <span>path</span><span>)</span><span>;</span>
  <span>// Plausible analytics, see:</span>
  <span>// https://github.com/simonw/datasette-lite/issues/22</span>
  <span>useAnalytics</span> <span>&amp;&amp;</span> <span>plausible</span><span>(</span><span>&#39;pageview&#39;</span><span>,</span> <span>{</span><span>u</span>: <span>location</span><span>.</span><span>href</span><span>.</span><span>replace</span><span>(</span><span>&#39;?url=&#39;</span><span>,</span> <span>&#39;&#39;</span><span>)</span><span>.</span><span>replace</span><span>(</span><span>&#39;#&#39;</span><span>,</span> <span>&#39;/&#39;</span><span>)</span><span>}</span><span>)</span><span>;</span>
  <span>// Send a {path: &#34;/path&#34;} message to the worker</span>
  <span>datasetteWorker</span><span>.</span><span>postMessage</span><span>(</span><span>{</span>path<span>}</span><span>)</span><span>;</span>
<span>}</span></pre></div>
<h4>Getting Datasette to work in Pyodide</h4>
<p><a href="https://pyodide.org/">Pyodide</a> is the secret sauce that makes this all possible. That project provides several key components:</p>
<ul>
<li>A custom WebAssembly build of the core Python interpreter, bundling the standard library (including a compiled WASM version of SQLite)</li>
<li>
<a href="https://pyodide.org/en/stable/usage/loading-packages.html#micropip">micropip</a>—a package that can install additional Python dependencies by downloading them from <a href="https://pypi.org/">PyPI</a>
</li>
<li>A comprehensive JavaScript to Python bridge, including mechanisms for <a href="https://pyodide.org/en/stable/usage/type-conversions.html">translating Python objects</a> to JavaScript and vice-versa</li>
<li>A <a href="https://pyodide.org/en/stable/usage/api/js-api.html">JavaScript API</a> for launching and then managing a Python interpreter process</li>
</ul>
<p>I found the documentation on <a href="https://pyodide.org/en/stable/usage/webworker.html">Using Pyodide in a web worker</a> particularly helpful.</p>
<p>I had to make a few changes to Datasette to get it working with Pyodide. My <a href="https://github.com/simonw/datasette/issues/1733">tracking issue for that</a> has the full details, but the short version is:</p>
<ul>
<li>Ensure each of Datasette’s dependencies had a wheel package on PyPI (as opposed to just a <code>.tar.gz</code>)—<code>micropip</code> only works with wheels. I ended up removing <code>python-baseconv</code> as a dependency and replacing <code>click-default-group</code> with my own <code>click-default-group-wheel</code> forked package (<a href="https://github.com/simonw/click-default-group-wheel">repo here</a>). I got <code>sqlite-utils</code> working in Pyodide with this change too, see the <a href="https://sqlite-utils.datasette.io/en/stable/changelog.html#v3-26-1">3.26.1 release notes</a>.</li>
<li>Work around an error caused by importing <code>uvicorn</code>. Since Datasette Lite doesn’t actually run its own web server that dependency wasn’t necessary, so I changed my code to catch the <code>ImportError</code> in the right place.</li>
<li>The biggest change: WebAssembly can’t run threads, which means Python can’t run threads, which means any attempts to start a thread in Python cause an error. Datasette only uses threads in one place: to execute SQL queries in a thread pool where they won’t block the event loop. I added a new <code>--setting num_sql_threads 0</code> feature for disabling threading entirely, see <a href="https://github.com/simonw/datasette/issues/1735">issue 1735</a>.</li>
</ul>
<p>Having made those changes I shipped them in a <a href="https://github.com/simonw/datasette/releases/tag/0.62a0">Datasette 0.62a0</a> release. It’s this release that Datasette Lite installs from PyPI.</p>
<h4>Fragment hashes for navigation</h4>
<p>You may have noticed that as you navigate through Datasette Lite the URL bar updates with URLs that look like the following:</p>
<p><a href="https://simonw.github.io/datasette-lite/#/content/pypi_packages?_facet=author">https://simonw.github.io/datasette-lite/#/content/pypi_packages?_facet=author</a></p>
<p>I’m using the <code>#</code> here to separate out the path within the virtual Datasette instance from the URL to the Datasette Lite application itself.</p>
<p>Maintaining the state in the URL like this means that the Back and Forward browser buttons work, and also means that users can bookmark pages within the application and share links to them.</p>
<p>I usually like to avoid <code>#</code> URLs—the HTML history API makes it possible to use “real” URLs these days, even for JavaScript applications. But in the case of Datasette Lite those URLs wouldn’t actually work—if someone attempted to refresh the page or navigate to a link GitHub Pages wouldn’t know what file to serve.</p>
<p>I could run this on my own domain with a catch-all page handler that serves the Datasette Lite HTML and JavaScript no matter what path is requested, but I wanted to keep this as pure and simple as possible.</p>
<p>This also means I can reserve Datasette Lite’s own query string for things like specifying the database to load, and potentially other options in the future.</p>
<h4>Web Workers or Service Workers?</h4>
<p>My initial idea for this project was to build it with <a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers">Service Workers</a>.</p>
<p>Service Workers are some deep, deep browser magic: they let you install a process that can intercept browser traffic to a specific domain (or path within that domain) and run custom code to return a result. Effectively they let you run your own server-side code in the browser itself.</p>
<p>They’re mainly designed for building offline applications, but my hope was that I could use them to offer a full simulation of a server-side application instead.</p>
<p>Here’s my TIL on <a href="https://til.simonwillison.net/service-workers/intercept-fetch">Intercepting fetch in a service worker</a> that came out of my initial research.</p>
<p>I managed to get a server-side JavaScript “hello world” demo working, but when I tried to add Pyodide I ran into some unavoidable road blocks. It turns out Service Workers are very restricted in which APIs they provide—in particular, they don’t allow <code>XMLHttpRequest</code> calls. Pyodide apparently depends on <code>XMLHttpRequest</code>, so it was unable to run in a Service Worker at all. I <a href="https://github.com/pyodide/pyodide/issues/2432">filed an issue</a> about it with the Pyodide project.</p>
<p>Initially I thought this would block the whole project, but eventually I figured out a way to achieve the same goals using Web Workers instead.</p>
<h3>Is this an SPA or an MPA?</h3>
<p>SPAs are Single Page Applications. MPAs are Multi Page Applications. Datasette Lite is a weird hybrid of the two.</p>
<p>This amuses me greatly.</p>
<p>Datasette itself is very deliberately architected as a multi page application.</p>
<p>I think SPAs, as developed over the last decade, have mostly been a mistake. In my experience they take longer to build, have more bugs and provide worse performance than a server-side, multi-page alternatives implementation.</p>
<p>Obviously if you are building Figma or VS Code then SPAs are the right way to go. But most web applications are not Figma, and don’t need to be!</p>
<p>(I used to think Gmail was a shining example of an SPA, but it’s so sludgy and slow loading these days that I now see it as more of an argument against the paradigm.)</p>
<p>Datasette Lite is an SPA wrapper around an MPA. It literally simulates the existing MPA by running it in a web worker.</p>
<p>It’s very heavy—it loads 11MB of assets before it can show you anything. But it also inherits many of the benefits of the underlying MPA: it has obvious distinctions between pages, a deeply interlinked interface, working back and forward buttons, it’s bookmarkable and it’s easy to maintain and add new features.</p>
<p>I’m not sure what my conclusion here is. I’m skeptical of SPAs, and now I’ve built a particularly weird one. Is this even a good idea? I’m looking forward to finding that out for myself.</p>
<h4>Coming soon: JavaScript!</h4>
<p>Another amusing detail about Datasette Lite is that the one part of Datasette that doesn’t work yet is Datasette’s existing JavaScript features!</p>
<p>Datasette currently makes very sparing use of JavaScript in the UI: it’s used to add some drop-down interactive menus (including the handy “cog” menu on column headings) and for a CodeMirror-enhanced SQL editing interface.</p>
<p>JavaScript is used much more extensively by several popular Datasette plugins, including <a href="https://datasette.io/plugins/datasette-cluster-map">datasette-cluster-map</a> and <a href="https://datasette.io/plugins/datasette-vega">datasette-vega</a>.</p>
<p>Unfortunately none of this works in Datasette Lite at the moment—because I don’t yet have a good way to turn <code>&lt;script src=&#34;...&#34;&gt;</code> links into things that can load content from the Web Worker.</p>
<p>This is one of the reasons I was initially hopeful about Service Workers.</p>
<p>Thankfully, since Datasette is built on the principles of progressive enhancement this doesn’t matter: the application remains usable even if none of the JavaScript enhancements are applied.</p>
<p>I have an <a href="https://github.com/simonw/datasette-lite/issues/8">open issue for this</a>. I welcome suggestions as to how I can get all of Datasette’s existing JavaScript working in the new environment with as little effort as possible.</p>
<h4 id="bonus-shot-scraper">Bonus: Testing it with shot-scraper</h4>
<p>In building Datasette Lite, I’ve committed to making Pyodide a supported runtime environment for Datasette. How can I ensure that future changes I make to Datasette—accidentally introducing a new dependency that doesn’t work there for example—don’t break in Pyodide without me noticing?</p>
<p>This felt like a great opportunity to exercise my <a href="https://datasette.io/tools/shot-scraper">shot-scraper</a> CLI tool, in particular its ability to run some JavaScript against a page and <a href="https://github.com/simonw/shot-scraper/blob/0.13/README.md#handling-javascript-errors">pass or fail a CI job</a> depending on if that JavaScript throws an error.</p>
<p>Pyodide needs you to run it from a real web server, not just an HTML file saved to disk—so I put together a <a href="https://github.com/simonw/datasette/blob/280ff372ab30df244f6c54f6f3002da57334b3d7/test-in-pyodide-with-shot-scraper.sh">very scrappy shell script</a> which builds a Datasette wheel package, starts a localhost file server (using <code>python3 -m http.server</code>), then uses <code>shot-scraper javascript</code> to execute a test against it that installs Datasette from the wheel using <code>micropip</code> and confirms that it can execute a simple SQL query via the JSON API.</p>
<p>Here’s the script in full, with extra comments:</p>
<div><pre><span><span>#!</span>/bin/bash</span>
<span>set</span> -e
<span><span>#</span> I always forget to do this in my bash scripts - without it, any</span>
<span><span>#</span> commands that fail in the script won&#39;t result in the script itself</span>
<span><span>#</span> returning a non-zero exit code. I need it for running tests in CI.</span>

<span><span>#</span> Build the wheel - this generates a file with a name similar to</span>
<span><span>#</span> dist/datasette-0.62a0-py3-none-any.whl</span>
python3 -m build

<span><span>#</span> Find the name of that wheel file, strip off the dist/</span>
wheel=<span><span>$(</span>basename <span><span>$(</span>ls dist/<span>*</span>.whl<span>)</span></span><span>)</span></span>
<span><span>#</span> $wheel is now datasette-0.62a0-py3-none-any.whl</span>

<span><span>#</span> Create a blank index page that loads Pyodide</span>
<span>echo</span> <span><span>&#39;</span></span>
<span>&lt;script src=&#34;https://cdn.jsdelivr.net/pyodide/v0.20.0/full/pyodide.js&#34;&gt;&lt;/script&gt;</span>
<span><span>&#39;</span></span> <span>&gt;</span> dist/index.html

<span><span>#</span> Run a localhost web server for that dist/ folder, in the background</span>
<span><span>#</span> so we can do more stuff in this script</span>
<span>cd</span> dist
python3 -m http.server 8529 <span>&amp;</span>
<span>cd</span> ..

<span><span>#</span> Now we use shot-scraper to run a block of JavaScript against our</span>
<span><span>#</span> temporary web server. This will execute in the context of that</span>
<span><span>#</span> index.html page we created earlier, which has loaded Pyodide</span>
shot-scraper javascript http://localhost:8529/ <span><span>&#34;</span></span>
<span>async () =&gt; {</span>
<span>  // Load Pyodide and all of its necessary assets</span>
<span>  let pyodide = await loadPyodide();</span>
<span>  // We also need these packages for Datasette to work</span>
<span>  await pyodide.loadPackage([&#39;micropip&#39;, &#39;ssl&#39;, &#39;setuptools&#39;]);</span>
<span>  // We need to escape the backticks because of Bash escaping rules</span>
<span>  let output = await pyodide.runPythonAsync(<span>\`</span></span>
<span>    import micropip</span>
<span>    // This is needed to avoid a dependency conflict error</span>
<span>    await micropip.install(&#39;h11==0.12.0&#39;)</span>
<span>    // Here we install the Datasette wheel package we created earlier</span>
<span>    await micropip.install(&#39;http://localhost:8529/<span>$wheel</span>&#39;)</span>
<span>    // These imports avoid Pyodide errors importing datasette itself</span>
<span>    import ssl</span>
<span>    import setuptools</span>
<span>    from datasette.app import Datasette</span>
<span>    // num_sql_threads=0 is essential or Datasette will crash, since</span>
<span>    // Pyodide and WebAssembly cannot start threads</span>
<span>    ds = Datasette(memory=True, settings={&#39;num_sql_threads&#39;: 0})</span>
<span>    // Simulate a hit to execute &#39;select 55 as itworks&#39; and return the text</span>
<span>    (await ds.client.get(</span>
<span>      &#39;/_memory.json?sql=select+55+as+itworks&amp;_shape=array&#39;</span>
<span>    )).text</span>
<span>  <span>\`</span>);</span>
<span>  // The last expression in the runPythonAsync block is returned, here</span>
<span>  // that&#39;s the text returned by the simulated HTTP response to the JSON API</span>
<span>  if (JSON.parse(output)[0].itworks != 55) {</span>
<span>    // This throws if the JSON API did not return the expected result</span>
<span>    // shot-scraper turns that into a non-zero exit code for the script</span>
<span>    // which will cause the CI task to fail</span>
<span>    throw &#39;Got &#39; + output + &#39;, expected itworks: 55&#39;;</span>
<span>  }</span>
<span>  // This gets displayed on the console, with a 0 exit code for a pass</span>
<span>  return &#39;Test passed!&#39;;</span>
<span>}</span>
<span><span>&#34;</span></span>

<span><span>#</span> Shut down the server we started earlier, by searching for and killing</span>
<span><span>#</span> a process that&#39;s running on the port we selected</span>
pkill -f <span><span>&#39;</span>http.server 8529<span>&#39;</span></span></pre></div>




</div>

</div></div>
  </body>
</html>
