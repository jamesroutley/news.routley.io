<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://cgit.freebsd.org/src/commit/?id=7e5bf68495cc0a8c9793a338a8a02009a7f6dbb6">Original</a>
    <h1>Netlink Added to FreeBSD â€“ Unmodified Linux IP(8) Correctly Works</h1>
    
    <div id="readability-page-1" class="page"><p>Netlinks is a communication protocol currently used in Linux kernel to modify,
 read and subscribe for nearly all networking state. Interfaces, addresses, routes,
 firewall, fibs, vnets, etc are controlled via netlink.
It is async, TLV-based protocol, providing 1-1 and 1-many communications.

The current implementation supports the subset of NETLINK_ROUTE
family. To be more specific, the following is supported:
* Dumps:
 - routes
 - nexthops / nexthop groups
 - interfaces
 - interface addresses
 - neighbors (arp/ndp)
* Notifications:
 - interface arrival/departure
 - interface address arrival/departure
 - route addition/deletion
* Modifications:
 - adding/deleting routes
 - adding/deleting nexthops/nexthops groups
 - adding/deleting neghbors
 - adding/deleting interfaces (basic support only)
* Rtsock interaction
 - route events are bridged both ways

The implementation also supports the NETLINK_GENERIC family framework.

Implementation notes:
Netlink is implemented via loadable/unloadable kernel module,
 not touching many kernel parts.
Each netlink socket uses dedicated taskqueue to support async operations
 that can sleep, such as interface creation. All message processing is
 performed within these taskqueues.

Compatibility:
Most of the Netlink data models specified above maps to FreeBSD concepts
 nicely. Unmodified ip(8) binary correctly works with
interfaces, addresses, routes, nexthops and nexthop groups. Some
software such as net/bird require header-only modifications to compile
and work with FreeBSD netlink.

Reviewed by:	imp
Differential Revision: <a href="https://reviews.freebsd.org/D36002">https://reviews.freebsd.org/D36002</a>
MFC after:	2 months
</p><div summary="diff"><tbody><tr><td><div><p>diff --git a/etc/mtree/BSD.include.dist b/etc/mtree/BSD.include.dist</p></div><p>@@ -269,6 +269,10 @@</p><p>     ..</p><p>     netinet6</p><p>     ..</p><p>+    netlink</p><p>+        route</p><p>+        ..</p><p>+    ..</p><p>     netipsec</p><p>     ..</p><p>     netnatm</p><div><p>diff --git a/sys/modules/Makefile b/sys/modules/Makefile</p></div><p>@@ -266,6 +266,7 @@ SUBDIR=	\</p><p> 	my \</p><p> 	${_nctgpio} \</p><p> 	${_neta} \</p><p>+	netlink \</p><p> 	${_netgraph} \</p><p> 	${_nfe} \</p><p> 	nfscl \</p><div><p>diff --git a/sys/modules/netlink/Makefile b/sys/modules/netlink/Makefile</p></div><p>@@ -0,0 +1,17 @@</p><p>+.PATH:	${SRCTOP}/sys/netlink</p><p>+KMOD=	netlink</p><p>+</p><p>+SRCS =	netlink_module.c netlink_domain.c netlink_io.c \</p><p>+	netlink_message_parser.c netlink_message_writer.c  netlink_generic.c \</p><p>+	netlink_route.c route/iface.c route/iface_drivers.c route/neigh.c \</p><p>+	route/nexthop.c route/route.c</p><p>+</p><p>+EXPORT_SYMS=</p><p>+EXPORT_SYMS+=	nlmsg_get_chain_writer</p><p>+EXPORT_SYMS+=	nlmsg_refill_buffer</p><p>+EXPORT_SYMS+=	nlmsg_end</p><p>+EXPORT_SYMS+=	nlmsg_flush</p><p>+</p><p>+EXPORT_SYMS= YES</p><p>+</p><p>+.include &lt;bsd.kmod.mk&gt;</p><div><p>diff --git a/sys/net/route.c b/sys/net/route.c</p></div><p>@@ -694,3 +694,14 @@ rt_routemsg_info(int cmd, struct rt_addrinfo *info, int fibnum)</p><p> 	return (rtsock_routemsg_info(cmd, info, fibnum));</p><p> }</p><p>+</p><p>+/* Netlink-related callbacks needed to glue rtsock, netlink and linuxolator */</p><p>+static void</p><p>+ignore_route_event(uint32_t fibnum, const struct rib_cmd_info *rc)</p><p>+{</p><p>+}</p><p>+static struct rtbridge ignore_cb = { .route_f = ignore_route_event };</p><p>+</p><p>+void *linux_netlink_p = NULL; /* Callback pointer for Linux translator functions */</p><p>+struct rtbridge *rtsock_callback_p = &amp;ignore_cb;</p><p>+struct rtbridge *netlink_callback_p = &amp;ignore_cb;</p><div><p>diff --git a/sys/net/route/route_ctl.h b/sys/net/route/route_ctl.h</p></div><p>@@ -189,4 +189,11 @@ void rib_unsubscribe_locked(struct rib_subscription *rs);</p><p> void rib_notify(struct rib_head *rnh, enum rib_subscription_type type,</p><p>     struct rib_cmd_info *rc);</p><p>+/* Event bridge */</p><p>+typedef void route_event_f(uint32_t fibnum, const struct rib_cmd_info *rc);</p><p>+struct rtbridge{</p><p>+	route_event_f	*route_f;</p><p>+};</p><p>+extern struct rtbridge *rtsock_callback_p;</p><p>+extern struct rtbridge *netlink_callback_p;</p><p> #endif</p><div><p>diff --git a/sys/net/rtsock.c b/sys/net/rtsock.c</p></div><p>@@ -219,6 +219,7 @@ static void	send_rtm_reply(struct socket *so, struct rt_msghdr *rtm,</p><p> 			int rtm_errno);</p><p> static bool	can_export_rte(struct ucred *td_ucred, bool rt_is_host,</p><p> 			const struct sockaddr *rt_dst);</p><p>+static void	rtsock_notify_event(uint32_t fibnum, const struct rib_cmd_info *rc);</p><p> static struct netisr_handler rtsock_nh = {</p><p> 	.nh_name = &#34;rtsock&#34;,</p><p>@@ -275,6 +276,45 @@ VNET_SYSUNINIT(vnet_rts_uninit, SI_SUB_PROTO_DOMAIN, SI_ORDER_THIRD,</p><p> #endif</p><p> static void</p><p>+report_route_event(const struct rib_cmd_info *rc, void *_cbdata)</p><p>+{</p><p>+	uint32_t fibnum = (uint32_t)(uintptr_t)_cbdata;</p><p>+	struct nhop_object *nh;</p><p>+</p><p>+	nh = rc-&gt;rc_cmd == RTM_DELETE ? rc-&gt;rc_nh_old : rc-&gt;rc_nh_new;</p><p>+	rt_routemsg(rc-&gt;rc_cmd, rc-&gt;rc_rt, nh, fibnum);</p><p>+}</p><p>+</p><p>+static void</p><p>+rts_handle_route_event(uint32_t fibnum, const struct rib_cmd_info *rc)</p><p>+{</p><p>+#ifdef ROUTE_MPATH</p><p>+	if ((rc-&gt;rc_nh_new &amp;&amp; NH_IS_NHGRP(rc-&gt;rc_nh_new)) ||</p><p>+	    (rc-&gt;rc_nh_old &amp;&amp; NH_IS_NHGRP(rc-&gt;rc_nh_old))) {</p><p>+		rib_decompose_notification(rc, report_route_event,</p><p>+		    (void *)(uintptr_t)fibnum);</p><p>+	} else</p><p>+#endif</p><p>+		report_route_event(rc, (void *)(uintptr_t)fibnum);</p><p>+}</p><p>+static struct rtbridge rtsbridge = { .route_f = rts_handle_route_event };</p><p>+static struct rtbridge *rtsbridge_orig_p;</p><p>+</p><p>+static void</p><p>+rtsock_notify_event(uint32_t fibnum, const struct rib_cmd_info *rc)</p><p>+{</p><p>+	netlink_callback_p-&gt;route_f(fibnum, rc);</p><p>+}</p><p>+</p><p>+static void</p><p>+rtsock_init(void)</p><p>+{</p><p>+	rtsbridge_orig_p = rtsock_callback_p;</p><p>+	rtsock_callback_p = &amp;rtsbridge;</p><p>+}</p><p>+SYSINIT(rtsock_init, SI_SUB_PROTO_DOMAIN, SI_ORDER_THIRD, rtsock_init, NULL);</p><p>+</p><p>+static void</p><p> rts_handle_ifnet_arrival(void *arg __unused, struct ifnet *ifp)</p><p> {</p><p> 	rt_ifannouncemsg(ifp, IFAN_ARRIVAL);</p><p>@@ -1074,6 +1114,7 @@ rts_send(struct socket *so, int flags, struct mbuf *m,</p><p> 		}</p><p> 		error = rib_action(fibnum, rtm-&gt;rtm_type, &amp;info, &amp;rc);</p><p> 		if (error == 0) {</p><p>+			rtsock_notify_event(fibnum, &amp;rc);</p><p> #ifdef ROUTE_MPATH</p><p> 			if (NH_IS_NHGRP(rc.rc_nh_new) ||</p><p> 			    (rc.rc_nh_old &amp;&amp; NH_IS_NHGRP(rc.rc_nh_old))) {</p><p>@@ -1095,6 +1136,7 @@ rts_send(struct socket *so, int flags, struct mbuf *m,</p><p> 	case RTM_DELETE:</p><p> 		error = rib_action(fibnum, RTM_DELETE, &amp;info, &amp;rc);</p><p> 		if (error == 0) {</p><p>+			rtsock_notify_event(fibnum, &amp;rc);</p><p> #ifdef ROUTE_MPATH</p><p> 			if (NH_IS_NHGRP(rc.rc_nh_old) ||</p><p> 			    (rc.rc_nh_new &amp;&amp; NH_IS_NHGRP(rc.rc_nh_new))) {</p><div><p>diff --git a/sys/netlink/netlink.h b/sys/netlink/netlink.h</p></div><p>@@ -0,0 +1,257 @@</p><p>+/*-</p><p>+ * SPDX-License-Identifier: BSD-2-Clause-FreeBSD</p><p>+ *</p><p>+ * Copyright (c) 2021 Ng Peng Nam Sean</p><p>+ * Copyright (c) 2022 Alexander V. Chernikov &lt;melifaro@FreeBSD.org&gt;</p><p>+ *</p><p>+ * Redistribution and use in source and binary forms, with or without</p><p>+ * modification, are permitted provided that the following conditions</p><p>+ * are met:</p><p>+ * 1. Redistributions of source code must retain the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer.</p><p>+ * 2. Redistributions in binary form must reproduce the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer in the</p><p>+ *    documentation and/or other materials provided with the distribution.</p><p>+ *</p><p>+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&#39;&#39; AND</p><p>+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</p><p>+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</p><p>+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE</p><p>+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</p><p>+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</p><p>+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</p><p>+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</p><p>+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</p><p>+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</p><p>+ * SUCH DAMAGE.</p><p>+ *</p><p>+ * Copyright (C) The Internet Society (2003).  All Rights Reserved.</p><p>+ *</p><p>+ * This document and translations of it may be copied and furnished to</p><p>+ * others, and derivative works that comment on or otherwise explain it</p><p>+ * or assist in its implementation may be prepared, copied, published</p><p>+ * and distributed, in whole or in part, without restriction of any</p><p>+ * kind, provided that the above copyright notice and this paragraph are</p><p>+ * included on all such copies and derivative works.  However, this</p><p>+ * document itself may not be modified in any way, such as by removing</p><p>+ * the copyright notice or references to the Internet Society or other</p><p>+ * Internet organizations, except as needed for the purpose of</p><p>+ * developing Internet standards in which case the procedures for</p><p>+ * copyrights defined in the Internet Standards process must be</p><p>+ * followed, or as required to translate it into languages other than</p><p>+ * English.</p><p>+ *</p><p>+ * The limited permissions granted above are perpetual and will not be</p><p>+ * revoked by the Internet Society or its successors or assignees.</p><p>+ *</p><p>+ * This document and the information contained herein is provided on an</p><p>+ * &#34;AS IS&#34; basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING</p><p>+ * TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING</p><p>+ * BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION</p><p>+ * HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF</p><p>+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.</p><p>+</p><p>+ */</p><p>+</p><p>+/*</p><p>+ * This file contains structures and constants for RFC 3549 (Netlink)</p><p>+ * protocol. Some values have been taken from Linux implementation.</p><p>+ */</p><p>+</p><p>+#ifndef _NETLINK_NETLINK_H_</p><p>+#define _NETLINK_NETLINK_H_</p><p>+</p><p>+#include &lt;sys/types.h&gt;</p><p>+#include &lt;sys/socket.h&gt;</p><p>+</p><p>+struct sockaddr_nl {</p><p>+	uint8_t		nl_len;		/* sizeof(sockaddr_nl) */</p><p>+	sa_family_t	nl_family;	/* netlink family */</p><p>+	uint16_t	nl_pad;		/* reserved, set to 0 */</p><p>+	uint32_t	nl_pid;		/* desired port ID, 0 for auto-select */</p><p>+	uint32_t	nl_groups;	/* multicast groups mask to bind to */</p><p>+};</p><p>+</p><p>+#define	SOL_NETLINK			270</p><p>+</p><p>+/* Netlink socket options */</p><p>+#define NETLINK_ADD_MEMBERSHIP		1 /* Subscribe for the specified group notifications */</p><p>+#define NETLINK_DROP_MEMBERSHIP		2 /* Unsubscribe from the specified group */</p><p>+#define NETLINK_PKTINFO			3 /* XXX: not supported */</p><p>+#define NETLINK_BROADCAST_ERROR		4 /* XXX: not supported */</p><p>+#define NETLINK_NO_ENOBUFS		5 /* XXX: not supported */</p><p>+#define NETLINK_RX_RING			6 /* XXX: not supported */</p><p>+#define NETLINK_TX_RING			7 /* XXX: not supported */</p><p>+#define NETLINK_LISTEN_ALL_NSID		8 /* XXX: not supported */</p><p>+</p><p>+#define NETLINK_LIST_MEMBERSHIPS	9</p><p>+#define NETLINK_CAP_ACK			10 /* Send only original message header in the reply */</p><p>+#define NETLINK_EXT_ACK			11 /* Ack support for receiving additional TLVs in ack */</p><p>+#define NETLINK_GET_STRICT_CHK		12 /* Strict header checking */</p><p>+</p><p>+</p><p>+/*</p><p>+ * RFC 3549, 2.3.2 Netlink Message Header</p><p>+ */</p><p>+struct nlmsghdr {</p><p>+	uint32_t nlmsg_len;   /* Length of message including header */</p><p>+	uint16_t nlmsg_type;  /* Message type identifier */</p><p>+	uint16_t nlmsg_flags; /* Flags (NLM_F_) */</p><p>+	uint32_t nlmsg_seq;   /* Sequence number */</p><p>+	uint32_t nlmsg_pid;   /* Sending process port ID */</p><p>+};</p><p>+</p><p>+/*</p><p>+ * RFC 3549, 2.3.2 standard flag bits (nlmsg_flags)</p><p>+ */</p><p>+#define NLM_F_REQUEST		0x01	/* Indicateds request to kernel */</p><p>+#define NLM_F_MULTI		0x02	/* Message is part of a group terminated by NLMSG_DONE msg */</p><p>+#define NLM_F_ACK		0x04	/* Reply with ack message containing resulting error code */</p><p>+#define NLM_F_ECHO		0x08	/* (not supported) Echo this request back */</p><p>+#define NLM_F_DUMP_INTR		0x10	/* Dump was inconsistent due to sequence change */</p><p>+#define NLM_F_DUMP_FILTERED	0x20	/* Dump was filtered as requested */</p><p>+</p><p>+/*</p><p>+ * RFC 3549, 2.3.2 Additional flag bits for GET requests</p><p>+ */</p><p>+#define NLM_F_ROOT		0x100	/* Return the complete table */</p><p>+#define NLM_F_MATCH		0x200	/* Return all entries matching criteria */</p><p>+#define NLM_F_ATOMIC		0x400	/* Return an atomic snapshot (ignored) */</p><p>+#define NLM_F_DUMP		(NLM_F_ROOT | NLM_F_MATCH)</p><p>+</p><p>+/*</p><p>+ * RFC 3549, 2.3.2 Additional flag bits for NEW requests</p><p>+ */</p><p>+#define NLM_F_REPLACE		0x100	/* Replace existing matching config object */</p><p>+#define NLM_F_EXCL		0x200	/* Don&#39;t replace the object if exists */</p><p>+#define NLM_F_CREATE		0x400	/* Create if it does not exist */</p><p>+#define NLM_F_APPEND		0x800	/* Add to end of list */</p><p>+</p><p>+/* Modifiers to DELETE requests */</p><p>+#define NLM_F_NONREC		0x100	/* Do not delete recursively */</p><p>+</p><p>+/* Flags for ACK message */</p><p>+#define NLM_F_CAPPED		0x100	/* request was capped */</p><p>+#define NLM_F_ACK_TLVS		0x200	/* extended ACK TVLs were included */</p><p>+</p><p>+/*</p><p>+ * RFC 3549, 2.3.2 standard message types (nlmsg_type).</p><p>+ */</p><p>+#define NLMSG_NOOP		0x1	/* Message is ignored. */</p><p>+#define NLMSG_ERROR		0x2	/* reply error code reporting */</p><p>+#define NLMSG_DONE		0x3	/* Message terminates a multipart message. */</p><p>+#define NLMSG_OVERRUN		0x4	/* overrun detected, data is lost */</p><p>+</p><p>+#define NLMSG_MIN_TYPE		0x10	/* &lt; 0x10: reserved control messages */</p><p>+</p><p>+/*</p><p>+ * Defition of numbers assigned to the netlink subsystems.</p><p>+ */</p><p>+#define NETLINK_ROUTE		0	/* Routing/device hook */</p><p>+#define NETLINK_UNUSED		1	/* not supported */</p><p>+#define NETLINK_USERSOCK	2	/* not supported */</p><p>+#define NETLINK_FIREWALL	3	/* not supported */</p><p>+#define NETLINK_SOCK_DIAG	4	/* not supported */</p><p>+#define NETLINK_NFLOG		5	/* not supported */</p><p>+#define NETLINK_XFRM		6	/* (not supported) PF_SETKEY */</p><p>+#define NETLINK_SELINUX		7	/* not supported */</p><p>+#define NETLINK_ISCSI		8	/* not supported */</p><p>+#define NETLINK_AUDIT		9	/* not supported */</p><p>+#define NETLINK_FIB_LOOKUP	10	/* not supported */</p><p>+#define NETLINK_CONNECTOR	11	/* not supported */</p><p>+#define NETLINK_NETFILTER	12	/* not supported */</p><p>+#define NETLINK_IP6_FW		13	/* not supported  */</p><p>+#define NETLINK_DNRTMSG		14	/* not supported */</p><p>+#define NETLINK_KOBJECT_UEVENT	15	/* not supported */</p><p>+#define NETLINK_GENERIC		16	/* Generic netlink (dynamic families) */</p><p>+</p><p>+/*</p><p>+ * RFC 3549, 2.3.2.2 The ACK Netlink Message</p><p>+ */</p><p>+struct nlmsgerr {</p><p>+	int	error;</p><p>+	struct	nlmsghdr msg;</p><p>+};</p><p>+</p><p>+enum nlmsgerr_attrs {</p><p>+	NLMSGERR_ATTR_UNUSED,</p><p>+	NLMSGERR_ATTR_MSG	= 1, /* string, error message */</p><p>+	NLMSGERR_ATTR_OFFS	= 2, /* u32, offset of the invalid attr from nl header */</p><p>+	NLMSGERR_ATTR_COOKIE	= 3, /* binary, data to pass to userland */</p><p>+	NLMSGERR_ATTR_POLICY	= 4, /* not supported */</p><p>+	__NLMSGERR_ATTR_MAX,</p><p>+	NLMSGERR_ATTR_MAX = __NLMSGERR_ATTR_MAX - 1</p><p>+};</p><p>+</p><p>+</p><p>+#ifndef roundup2</p><p>+#define	roundup2(x, y)	(((x)+((y)-1))&amp;(~((y)-1))) /* if y is powers of two */</p><p>+#endif</p><p>+#define	NL_ITEM_ALIGN_SIZE		sizeof(uint32_t)</p><p>+#define	NL_ITEM_ALIGN(_len)		roundup2(_len, NL_ITEM_ALIGN_SIZE)</p><p>+#define	NL_ITEM_DATA(_ptr, _off)	((void *)((char *)(_ptr) + _off))</p><p>+#define	NL_ITEM_DATA_CONST(_ptr, _off)	((const void *)((const char *)(_ptr) + _off))</p><p>+</p><p>+#define	NL_ITEM_OK(_ptr, _len, _hlen, _LEN_M)	\</p><p>+	((_len) &gt;= _hlen &amp;&amp; _LEN_M(_ptr) &gt;= _hlen &amp;&amp; _LEN_M(_ptr) &lt;= (_len))</p><p>+#define	NL_ITEM_NEXT(_ptr, _LEN_M)	((typeof(_ptr))((char *)(_ptr) + _LEN_M(_ptr)))</p><p>+#define	NL_ITEM_ITER(_ptr, _len, _LEN_MACRO)	\</p><p>+	((_len) -= _LEN_MACRO(_ptr), NL_ITEM_NEXT(_ptr, _LEN_MACRO))</p><p>+</p><p>+</p><p>+#ifndef _KERNEL</p><p>+/* part of netlink(3) API */</p><p>+#define NLMSG_ALIGNTO			NL_ITEM_ALIGN_SIZE</p><p>+#define NLMSG_ALIGN(_len)		NL_ITEM_ALIGN(_len)</p><p>+#define NLMSG_HDRLEN			((int)sizeof(struct nlmsghdr))</p><p>+#define NLMSG_LENGTH(_len)		((_len) + NLMSG_HDRLEN)</p><p>+#define NLMSG_SPACE(len)		NLMSG_ALIGN(NLMSG_LENGTH(_len))</p><p>+#define NLMSG_DATA(_hdr)		NL_ITEM_DATA(_hdr, NLMSG_HDRLEN)</p><p>+#define	_NLMSG_LEN(_hdr)		((int)(_hdr)-&gt;nlmsg_len)</p><p>+#define	_NLMSG_ALIGNED_LEN(_hdr)	NLMSG_ALIGN(_NLMSG_LEN(_hdr))</p><p>+#define	NLMSG_OK(_hdr, _len)		NL_ITEM_OK(_hdr, _len, NLMSG_HDRLEN, _NLMSG_LEN)</p><p>+#define NLMSG_PAYLOAD(_hdr,_len)	(_NLMSG_LEN(_hdr) - NLMSG_SPACE((_len)))</p><p>+#define	NLMSG_NEXT(_hdr, _len)		NL_ITEM_ITER(_hdr, _len, _NLMSG_ALIGNED_LEN)</p><p>+</p><p>+#else</p><p>+#define NLMSG_ALIGNTO 4U</p><p>+#define NLMSG_ALIGN(len) (((len) + NLMSG_ALIGNTO - 1) &amp; ~(NLMSG_ALIGNTO - 1))</p><p>+#define NLMSG_HDRLEN ((int)NLMSG_ALIGN(sizeof(struct nlmsghdr)))</p><p>+#endif</p><p>+</p><p>+/*</p><p>+ * Base netlink attribute TLV header.</p><p>+ */</p><p>+struct nlattr {</p><p>+	uint16_t nla_len;	/* Total attribute length */</p><p>+	uint16_t nla_type;	/* Attribute type */</p><p>+};</p><p>+</p><p>+/*</p><p>+ *</p><p>+ * nl_type field enconding:</p><p>+ *</p><p>+ * 0                   1</p><p>+ * 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6</p><p>+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p>+ * |N|O|  Attribute type           |</p><p>+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p>+ * N - attribute contains other attributes (mostly unused)</p><p>+ * O - encoded in network byte order (mostly unused)</p><p>+ * Note: N &amp; O are mutually exclusive</p><p>+ *</p><p>+ * Note: attribute type value scope normally is either parent attribute</p><p>+ * or the message/message group.</p><p>+ */</p><p>+</p><p>+#define NLA_F_NESTED (1 &lt;&lt; 15)</p><p>+#define NLA_F_NET_BYTEORDER (1 &lt;&lt; 14)</p><p>+#define NLA_TYPE_MASK ~(NLA_F_NESTED | NLA_F_NET_BYTEORDER)</p><p>+</p><p>+#ifndef _KERNEL</p><p>+#define	NLA_ALIGNTO	NL_ITEM_ALIGN_SIZE</p><p>+#define	NLA_ALIGN(_len)	NL_ITEM_ALIGN(_len)</p><p>+#define	NLA_HDRLEN	((int)sizeof(struct nlattr))</p><p>+#endif</p><p>+</p><p>+#endif</p><div><p>diff --git a/sys/netlink/netlink_ctl.h b/sys/netlink/netlink_ctl.h</p></div><p>@@ -0,0 +1,102 @@</p><p>+/*-</p><p>+ * SPDX-License-Identifier: BSD-2-Clause-FreeBSD</p><p>+ *</p><p>+ * Copyright (c) 2022 Alexander V. Chernikov &lt;melifaro@FreeBSD.org&gt;</p><p>+ *</p><p>+ * Redistribution and use in source and binary forms, with or without</p><p>+ * modification, are permitted provided that the following conditions</p><p>+ * are met:</p><p>+ * 1. Redistributions of source code must retain the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer.</p><p>+ * 2. Redistributions in binary form must reproduce the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer in the</p><p>+ *    documentation and/or other materials provided with the distribution.</p><p>+ *</p><p>+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&#39;&#39; AND</p><p>+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</p><p>+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</p><p>+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE</p><p>+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</p><p>+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</p><p>+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</p><p>+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</p><p>+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</p><p>+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</p><p>+ * SUCH DAMAGE.</p><p>+ */</p><p>+</p><p>+#ifndef _NETLINK_NETLINK_CTL_H_</p><p>+#define _NETLINK_NETLINK_CTL_H_</p><p>+</p><p>+/*</p><p>+ * This file provides headers for the public KPI of the netlink</p><p>+ * subsystem</p><p>+ */</p><p>+</p><p>+MALLOC_DECLARE(M_NETLINK);</p><p>+</p><p>+/*</p><p>+ * Macro for handling attribute TLVs</p><p>+ */</p><p>+#define _roundup2(x, y)         (((x)+((y)-1))&amp;(~((y)-1)))</p><p>+</p><p>+#define NETLINK_ALIGN_SIZE      sizeof(uint32_t)</p><p>+#define NETLINK_ALIGN(_len)     _roundup2(_len, NETLINK_ALIGN_SIZE)</p><p>+</p><p>+#define NLA_ALIGN_SIZE          sizeof(uint32_t)</p><p>+#define NLA_ALIGN(_len)         _roundup2(_len, NLA_ALIGN_SIZE)</p><p>+#define	NLA_HDRLEN		((int)sizeof(struct nlattr))</p><p>+#define	NLA_DATA_LEN(_nla)	((int)((_nla)-&gt;nla_len - NLA_HDRLEN))</p><p>+#define	NLA_DATA(_nla)		NL_ITEM_DATA(_nla, NLA_HDRLEN)</p><p>+#define	NLA_DATA_CONST(_nla)	NL_ITEM_DATA_CONST(_nla, NLA_HDRLEN)</p><p>+#define	NLA_TYPE(_nla)		((_nla)-&gt;nla_type &amp; 0x3FFF)</p><p>+</p><p>+#ifndef	typeof</p><p>+#define	typeof	__typeof</p><p>+#endif</p><p>+</p><p>+#define NLA_NEXT(_attr) (struct nlattr *)((char *)_attr + NLA_ALIGN(_attr-&gt;nla_len))</p><p>+#define	_NLA_END(_start, _len)	((char *)(_start) + (_len))</p><p>+#define NLA_FOREACH(_attr, _start, _len)      \</p><p>+        for (typeof(_attr) _end = (typeof(_attr))_NLA_END(_start, _len), _attr = (_start);		\</p><p>+		((char *)_attr &lt; (char *)_end) &amp;&amp; \</p><p>+		((char *)NLA_NEXT(_attr) &lt;= (char *)_end);	\</p><p>+		_attr = (_len -= NLA_ALIGN(_attr-&gt;nla_len), NLA_NEXT(_attr)))</p><p>+</p><p>+#define	NL_ARRAY_LEN(_a)	(sizeof(_a) / sizeof((_a)[0]))</p><p>+</p><p>+#include &lt;netlink/netlink_message_writer.h&gt;</p><p>+#include &lt;netlink/netlink_message_parser.h&gt;</p><p>+</p><p>+</p><p>+/* Protocol handlers */</p><p>+struct nl_pstate;</p><p>+typedef int (*nl_handler_f)(struct nlmsghdr *hdr, struct nl_pstate *npt);</p><p>+</p><p>+bool netlink_register_proto(int proto, const char *proto_name, nl_handler_f handler);</p><p>+bool netlink_unregister_proto(int proto);</p><p>+</p><p>+/* Common helpers */</p><p>+bool nl_has_listeners(int netlink_family, uint32_t groups_mask);</p><p>+bool nlp_has_priv(struct nlpcb *nlp, int priv);</p><p>+</p><p>+/* netlink_generic.c */</p><p>+struct genl_cmd {</p><p>+	const char	*cmd_name;</p><p>+	nl_handler_f	cmd_cb;</p><p>+	uint32_t	cmd_flags;</p><p>+	uint32_t	cmd_priv;</p><p>+	uint32_t	cmd_num;</p><p>+};</p><p>+</p><p>+uint32_t genl_register_family(const char *family_name, size_t hdrsize,</p><p>+    int family_version, int max_attr_idx);</p><p>+bool genl_unregister_family(const char *family_name);</p><p>+bool genl_register_cmds(const char *family_name, const struct genl_cmd *cmds,</p><p>+    int count);</p><p>+uint32_t genl_register_group(const char *family_name, const char *group_name);</p><p>+</p><p>+/* Debug */</p><p>+uint32_t nlp_get_pid(const struct nlpcb *nlp);</p><p>+</p><p>+#endif</p><div><p>diff --git a/sys/netlink/netlink_debug.h b/sys/netlink/netlink_debug.h</p></div><p>@@ -0,0 +1,82 @@</p><p>+/*-</p><p>+ * Copyright (c) 2022 Alexander V. Chernikov &lt;melifaro@FreeBSD.org&gt;</p><p>+ *</p><p>+ * Redistribution and use in source and binary forms, with or without</p><p>+ * modification, are permitted provided that the following conditions</p><p>+ * are met:</p><p>+ * 1. Redistributions of source code must retain the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer.</p><p>+ * 2. Redistributions in binary form must reproduce the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer in the</p><p>+ *    documentation and/or other materials provided with the distribution.</p><p>+ * 3. Neither the name of the University nor the names of its contributors</p><p>+ *    may be used to endorse or promote products derived from this software</p><p>+ *    without specific prior written permission.</p><p>+ *</p><p>+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS&#39;&#39; AND</p><p>+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</p><p>+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</p><p>+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE</p><p>+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</p><p>+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</p><p>+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</p><p>+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</p><p>+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</p><p>+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</p><p>+ * SUCH DAMAGE.</p><p>+ *</p><p>+ * $FreeBSD$</p><p>+ */</p><p>+</p><p>+#ifndef _NETLINK_NETLINK_DEBUG_H_</p><p>+#define	_NETLINK_NETLINK_DEBUG_H_</p><p>+</p><p>+#define	_DEBUG_SYSCTL_OID	_net_netlink_debug</p><p>+#include &lt;net/route/route_debug.h&gt;</p><p>+</p><p>+SYSCTL_DECL(_net_netlink_debug);</p><p>+</p><p>+/*</p><p>+ * Generic debug</p><p>+ * [nl_domain] func_name: debug text</p><p>+ */</p><p>+#define	NL_LOG	RT_LOG</p><p>+</p><p>+/*</p><p>+ * Logging for events specific for particular process</p><p>+ * Example: [nl_domain] PID 4834 fdump_sa: unsupported family: 45</p><p>+ */</p><p>+#define	NL_RAW_PID_LOG(_l, _pid, _fmt, ...)	NL_RAW_PID_LOG_##_l(_l, _pid, _fmt, ## __VA_ARGS__)</p><p>+#define	_NL_RAW_PID_LOG(_l, _pid, _fmt, ...)	if (_DEBUG_PASS_MSG(_l)) {	\</p><p>+	_output(&#34;[&#34; DEBUG_PREFIX_NAME &#34;] PID %u %s: &#34; _fmt &#34;\n&#34;, _pid, __func__, ##__VA_ARGS__); \</p><p>+}</p><p>+</p><p>+#define	NLP_LOG(_l, _nlp, _fmt, ...)	NL_RAW_PID_LOG_##_l(_l, nlp_get_pid(_nlp), _fmt, ## __VA_ARGS__)</p><p>+</p><p>+#if DEBUG_MAX_LEVEL&gt;=LOG_DEBUG3</p><p>+#define	NL_RAW_PID_LOG_LOG_DEBUG3	_NL_RAW_PID_LOG</p><p>+#else</p><p>+#define	NL_RAW_PID_LOG_LOG_DEBUG3(_l, _pid, _fmt, ...)</p><p>+#endif</p><p>+#if DEBUG_MAX_LEVEL&gt;=LOG_DEBUG2</p><p>+#define	NL_RAW_PID_LOG_LOG_DEBUG2	_NL_RAW_PID_LOG</p><p>+#else</p><p>+#define	NL_RAW_PID_LOG_LOG_DEBUG2(_l, _pid, _fmt, ...)</p><p>+#endif</p><p>+#if DEBUG_MAX_LEVEL&gt;=LOG_DEBUG</p><p>+#define	NL_RAW_PID_LOG_LOG_DEBUG	_NL_RAW_PID_LOG</p><p>+#else</p><p>+#define	NL_RAW_PID_LOG_LOG_DEBUG(_l, _pid, _fmt, ...)</p><p>+#endif</p><p>+#if DEBUG_MAX_LEVEL&gt;=LOG_INFO</p><p>+#define	NL_RAW_PID_LOG_LOG_INFO	_NL_RAW_PID_LOG</p><p>+#else</p><p>+#define	NL_RAW_PID_LOG_LOG_INFO(_l, _pid, _fmt, ...)</p><p>+#endif</p><p>+#define	NL_RAW_PID_LOG_LOG_NOTICE	_NL_RAW_PID_LOG</p><p>+#define	NL_RAW_PID_LOG_LOG_ERR         _NL_RAW_PID_LOG</p><p>+#define	NL_RAW_PID_LOG_LOG_WARNING	_NL_RAW_PID_LOG</p><p>+</p><p>+</p><p>+</p><p>+#endif</p><div><p>diff --git a/sys/netlink/netlink_domain.c b/sys/netlink/netlink_domain.c</p></div><p>@@ -0,0 +1,689 @@</p><p>+/*-</p><p>+ * SPDX-License-Identifier: BSD-2-Clause-FreeBSD</p><p>+ *</p><p>+ * Copyright (c) 2021 Ng Peng Nam Sean</p><p>+ * Copyright (c) 2022 Alexander V. Chernikov &lt;melifaro@FreeBSD.org&gt;</p><p>+ *</p><p>+ * Redistribution and use in source and binary forms, with or without</p><p>+ * modification, are permitted provided that the following conditions</p><p>+ * are met:</p><p>+ * 1. Redistributions of source code must retain the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer.</p><p>+ * 2. Redistributions in binary form must reproduce the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer in the</p><p>+ *    documentation and/or other materials provided with the distribution.</p><p>+ *</p><p>+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&#39;&#39; AND</p><p>+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</p><p>+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</p><p>+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE</p><p>+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</p><p>+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</p><p>+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</p><p>+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</p><p>+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</p><p>+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</p><p>+ * SUCH DAMAGE.</p><p>+ */</p><p>+</p><p>+/*</p><p>+ * This file contains socket and protocol bindings for netlink.</p><p>+ */</p><p>+</p><p>+#include &lt;sys/param.h&gt;</p><p>+#include &lt;sys/malloc.h&gt;</p><p>+#include &lt;sys/lock.h&gt;</p><p>+#include &lt;sys/rmlock.h&gt;</p><p>+#include &lt;sys/domain.h&gt;</p><p>+#include &lt;sys/mbuf.h&gt;</p><p>+#include &lt;sys/protosw.h&gt;</p><p>+#include &lt;sys/ck.h&gt;</p><p>+#include &lt;sys/socket.h&gt;</p><p>+#include &lt;sys/socketvar.h&gt;</p><p>+#include &lt;sys/sysent.h&gt;</p><p>+#include &lt;sys/syslog.h&gt;</p><p>+#include &lt;sys/priv.h&gt; /* priv_check */</p><p>+</p><p>+#include &lt;netlink/netlink.h&gt;</p><p>+#include &lt;netlink/netlink_ctl.h&gt;</p><p>+#include &lt;netlink/netlink_var.h&gt;</p><p>+</p><p>+#define	DEBUG_MOD_NAME	nl_domain</p><p>+#define	DEBUG_MAX_LEVEL	LOG_DEBUG3</p><p>+#include &lt;netlink/netlink_debug.h&gt;</p><p>+_DECLARE_DEBUG(LOG_DEBUG);</p><p>+</p><p>+</p><p>+#define	NLCTL_TRACKER		struct rm_priotracker nl_tracker</p><p>+#define	NLCTL_RLOCK(_ctl)	rm_rlock(&amp;((_ctl)-&gt;ctl_lock), &amp;nl_tracker)</p><p>+#define	NLCTL_RUNLOCK(_ctl)	rm_runlock(&amp;((_ctl)-&gt;ctl_lock), &amp;nl_tracker)</p><p>+</p><p>+#define	NLCTL_WLOCK(_ctl)	rm_wlock(&amp;((_ctl)-&gt;ctl_lock))</p><p>+#define	NLCTL_WUNLOCK(_ctl)	rm_wunlock(&amp;((_ctl)-&gt;ctl_lock))</p><p>+</p><p>+static u_long nl_sendspace = NLSNDQ;</p><p>+SYSCTL_ULONG(_net_netlink, OID_AUTO, sendspace, CTLFLAG_RW, &amp;nl_sendspace, 0,</p><p>+    &#34;Default netlink socket send space&#34;);</p><p>+</p><p>+static u_long nl_recvspace = NLSNDQ;</p><p>+SYSCTL_ULONG(_net_netlink, OID_AUTO, recvspace, CTLFLAG_RW, &amp;nl_recvspace, 0,</p><p>+    &#34;Default netlink socket receive space&#34;);</p><p>+</p><p>+extern u_long sb_max_adj;</p><p>+static u_long nl_maxsockbuf = 512 * 1024 * 1024; /* 512M, XXX: init based on physmem */</p><p>+</p><p>+uint32_t</p><p>+nlp_get_pid(const struct nlpcb *nlp)</p><p>+{</p><p>+	return (nlp-&gt;nl_process_id);</p><p>+}</p><p>+</p><p>+/*</p><p>+ * Looks up a nlpcb struct based on the @portid. Need to claim nlsock_mtx.</p><p>+ * Returns nlpcb pointer if present else NULL</p><p>+ */</p><p>+static struct nlpcb *</p><p>+nl_port_lookup(uint32_t port_id)</p><p>+{</p><p>+	struct nlpcb *nlp;</p><p>+</p><p>+	CK_LIST_FOREACH(nlp, &amp;V_nl_ctl-&gt;ctl_port_head, nl_port_next) {</p><p>+		if (nlp-&gt;nl_port == port_id)</p><p>+			return (nlp);</p><p>+	}</p><p>+	return (NULL);</p><p>+}</p><p>+</p><p>+static void</p><p>+nl_update_groups_locked(struct nlpcb *nlp, uint64_t nl_groups)</p><p>+{</p><p>+	/* Update group mask */</p><p>+	NL_LOG(LOG_DEBUG2, &#34;socket %p, groups 0x%lX -&gt; 0x%lX&#34;,</p><p>+	    nlp-&gt;nl_socket, nlp-&gt;nl_groups, nl_groups);</p><p>+	nlp-&gt;nl_groups = nl_groups;</p><p>+}</p><p>+</p><p>+/*</p><p>+ * Broadcasts message @m to the protocol @proto group specified by @group_id</p><p>+ */</p><p>+void</p><p>+nl_send_group(struct mbuf *m, int num_messages, int proto, int group_id)</p><p>+{</p><p>+	struct nlpcb *nlp_last = NULL;</p><p>+	struct nlpcb *nlp;</p><p>+	NLCTL_TRACKER;</p><p>+</p><p>+	IF_DEBUG_LEVEL(LOG_DEBUG2) {</p><p>+		struct nlmsghdr *hdr = mtod(m, struct nlmsghdr *);</p><p>+		NL_LOG(LOG_DEBUG2, &#34;MCAST mbuf len %u msg type %d len %u to group %d/%d&#34;,</p><p>+		    m-&gt;m_len, hdr-&gt;nlmsg_type, hdr-&gt;nlmsg_len, proto, group_id);</p><p>+	}</p><p>+</p><p>+	struct nl_control *ctl = atomic_load_ptr(&amp;V_nl_ctl);</p><p>+	if (__predict_false(ctl == NULL)) {</p><p>+		/*</p><p>+		 * Can be the case when notification is sent within VNET</p><p>+		 * which doesn&#39;t have any netlink sockets.</p><p>+		 */</p><p>+		m_freem(m);</p><p>+		return;</p><p>+	}</p><p>+</p><p>+	NLCTL_RLOCK(ctl);</p><p>+</p><p>+	int io_flags = NL_IOF_UNTRANSLATED;</p><p>+	uint64_t groups_mask = 1 &lt;&lt; ((uint64_t)group_id - 1);</p><p>+</p><p>+	CK_LIST_FOREACH(nlp, &amp;ctl-&gt;ctl_pcb_head, nl_next) {</p><p>+		if (nlp-&gt;nl_groups &amp; groups_mask &amp;&amp; nlp-&gt;nl_proto == proto) {</p><p>+			if (nlp_last != NULL) {</p><p>+				struct mbuf *m_copy;</p><p>+				m_copy = m_copym(m, 0, M_COPYALL, M_NOWAIT);</p><p>+				if (m_copy != NULL)</p><p>+					nl_send_one(m_copy, nlp_last, num_messages, io_flags);</p><p>+				else {</p><p>+					NLP_LOCK(nlp_last);</p><p>+					if (nlp_last-&gt;nl_socket != NULL)</p><p>+						sorwakeup(nlp_last-&gt;nl_socket);</p><p>+					NLP_UNLOCK(nlp_last);</p><p>+				}</p><p>+			}</p><p>+			nlp_last = nlp;</p><p>+		}</p><p>+	}</p><p>+	if (nlp_last != NULL)</p><p>+		nl_send_one(m, nlp_last, num_messages, io_flags);</p><p>+	else</p><p>+		m_freem(m);</p><p>+</p><p>+	NLCTL_RUNLOCK(ctl);</p><p>+}</p><p>+</p><p>+bool</p><p>+nl_has_listeners(int netlink_family, uint32_t groups_mask)</p><p>+{</p><p>+	return (V_nl_ctl != NULL);</p><p>+}</p><p>+</p><p>+bool</p><p>+nlp_has_priv(struct nlpcb *nlp, int priv)</p><p>+{</p><p>+	return (priv_check_cred(nlp-&gt;nl_cred, priv) == 0);</p><p>+}</p><p>+</p><p>+static uint32_t</p><p>+nl_find_port() {</p><p>+	/*</p><p>+	 * app can open multiple netlink sockets.</p><p>+	 * Start with current pid, if already taken,</p><p>+	 * try random numbers in 65k..256k+65k space,</p><p>+	 * avoiding clash with pids.</p><p>+	 */</p><p>+	if (nl_port_lookup(curproc-&gt;p_pid) == NULL)</p><p>+		return (curproc-&gt;p_pid);</p><p>+	for (int i = 0; i &lt; 16; i++) {</p><p>+		uint32_t nl_port = (arc4random() % 65536) + 65536 * 4;</p><p>+		if (nl_port_lookup(nl_port) == 0)</p><p>+			return (nl_port);</p><p>+		NL_LOG(LOG_DEBUG3, &#34;tried %u\n&#34;, nl_port);</p><p>+	}</p><p>+	return (curproc-&gt;p_pid);</p><p>+}</p><p>+</p><p>+static int</p><p>+nl_bind_locked(struct nlpcb *nlp, struct sockaddr_nl *snl)</p><p>+{</p><p>+	if (nlp-&gt;nl_bound) {</p><p>+		if (nlp-&gt;nl_port != snl-&gt;nl_pid) {</p><p>+			NL_LOG(LOG_DEBUG,</p><p>+			    &#34;bind() failed: program pid %d &#34;</p><p>+			    &#34;is different from provided pid %d&#34;,</p><p>+			    nlp-&gt;nl_port, snl-&gt;nl_pid);</p><p>+			return (EINVAL); // XXX: better error</p><p>+		}</p><p>+	} else {</p><p>+		if (snl-&gt;nl_pid == 0)</p><p>+			snl-&gt;nl_pid = nl_find_port();</p><p>+		if (nl_port_lookup(snl-&gt;nl_pid) != NULL)</p><p>+			return (EADDRINUSE);</p><p>+		nlp-&gt;nl_port = snl-&gt;nl_pid;</p><p>+		nlp-&gt;nl_bound = true;</p><p>+		CK_LIST_INSERT_HEAD(&amp;V_nl_ctl-&gt;ctl_port_head, nlp, nl_port_next);</p><p>+	}</p><p>+	nl_update_groups_locked(nlp, snl-&gt;nl_groups);</p><p>+</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+static int</p><p>+nl_pru_attach(struct socket *so, int proto, struct thread *td)</p><p>+{</p><p>+	struct nlpcb *nlp;</p><p>+	int error;</p><p>+</p><p>+	if (__predict_false(netlink_unloading != 0))</p><p>+		return (EAFNOSUPPORT);</p><p>+</p><p>+	error = nl_verify_proto(proto);</p><p>+	if (error != 0)</p><p>+		return (error);</p><p>+</p><p>+	bool is_linux = SV_PROC_ABI(td-&gt;td_proc) == SV_ABI_LINUX;</p><p>+	NL_LOG(LOG_DEBUG2, &#34;socket %p, %sPID %d: attaching socket to %s&#34;,</p><p>+	    so, is_linux ? &#34;(linux) &#34; : &#34;&#34;, curproc-&gt;p_pid,</p><p>+	    nl_get_proto_name(proto));</p><p>+</p><p>+	/* Create per-VNET state on first socket init */</p><p>+	struct nl_control *ctl = atomic_load_ptr(&amp;V_nl_ctl);</p><p>+	if (ctl == NULL)</p><p>+		ctl = vnet_nl_ctl_init();</p><p>+	KASSERT(V_nl_ctl != NULL, (&#34;nl_attach: vnet_sock_init() failed&#34;));</p><p>+</p><p>+	MPASS(sotonlpcb(so) == NULL);</p><p>+</p><p>+	nlp = malloc(sizeof(struct nlpcb), M_PCB, M_WAITOK | M_ZERO);</p><p>+	error = soreserve(so, nl_sendspace, nl_recvspace);</p><p>+	if (error != 0) {</p><p>+		free(nlp, M_PCB);</p><p>+		return (error);</p><p>+	}</p><p>+	so-&gt;so_pcb = nlp;</p><p>+	nlp-&gt;nl_socket = so;</p><p>+	/* Copy so_cred to avoid having socket_var.h in every header */</p><p>+	nlp-&gt;nl_cred = so-&gt;so_cred;</p><p>+	nlp-&gt;nl_proto = proto;</p><p>+	nlp-&gt;nl_process_id = curproc-&gt;p_pid;</p><p>+	nlp-&gt;nl_linux = is_linux;</p><p>+	nlp-&gt;nl_active = true;</p><p>+	NLP_LOCK_INIT(nlp);</p><p>+	refcount_init(&amp;nlp-&gt;nl_refcount, 1);</p><p>+	nl_init_io(nlp);</p><p>+</p><p>+	nlp-&gt;nl_taskqueue = taskqueue_create(&#34;netlink_socket&#34;, M_WAITOK,</p><p>+	    taskqueue_thread_enqueue, &amp;nlp-&gt;nl_taskqueue);</p><p>+	TASK_INIT(&amp;nlp-&gt;nl_task, 0, nl_taskqueue_handler, nlp);</p><p>+	taskqueue_start_threads(&amp;nlp-&gt;nl_taskqueue, 1, PWAIT,</p><p>+	    &#34;netlink_socket (PID %u)&#34;, nlp-&gt;nl_process_id);</p><p>+</p><p>+	NLCTL_WLOCK(ctl);</p><p>+	/* XXX: check ctl is still alive */</p><p>+	CK_LIST_INSERT_HEAD(&amp;ctl-&gt;ctl_pcb_head, nlp, nl_next);</p><p>+	NLCTL_WUNLOCK(ctl);</p><p>+</p><p>+	soisconnected(so);</p><p>+</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+static void</p><p>+nl_pru_abort(struct socket *so)</p><p>+{</p><p>+	NL_LOG(LOG_DEBUG3, &#34;socket %p, PID %d&#34;, so, curproc-&gt;p_pid);</p><p>+	MPASS(sotonlpcb(so) != NULL);</p><p>+	soisdisconnected(so);</p><p>+}</p><p>+</p><p>+static int</p><p>+nl_pru_bind(struct socket *so, struct sockaddr *sa, struct thread *td)</p><p>+{</p><p>+	struct nl_control *ctl = atomic_load_ptr(&amp;V_nl_ctl);</p><p>+	struct nlpcb *nlp = sotonlpcb(so);</p><p>+	struct sockaddr_nl *snl = (struct sockaddr_nl *)sa;</p><p>+	int error;</p><p>+</p><p>+	NL_LOG(LOG_DEBUG3, &#34;socket %p, PID %d&#34;, so, curproc-&gt;p_pid);</p><p>+	if (snl-&gt;nl_len != sizeof(*snl)) {</p><p>+		NL_LOG(LOG_DEBUG, &#34;socket %p, wrong sizeof(), ignoring bind()&#34;, so);</p><p>+		return (EINVAL);</p><p>+	}</p><p>+</p><p>+</p><p>+	NLCTL_WLOCK(ctl);</p><p>+	NLP_LOCK(nlp);</p><p>+	error = nl_bind_locked(nlp, snl);</p><p>+	NLP_UNLOCK(nlp);</p><p>+	NLCTL_WUNLOCK(ctl);</p><p>+	NL_LOG(LOG_DEBUG2, &#34;socket %p, bind() to %u, groups %u, error %d&#34;, so,</p><p>+	    snl-&gt;nl_pid, snl-&gt;nl_groups, error);</p><p>+</p><p>+	return (error);</p><p>+}</p><p>+</p><p>+</p><p>+static int</p><p>+nl_assign_port(struct nlpcb *nlp, uint32_t port_id)</p><p>+{</p><p>+	struct nl_control *ctl = atomic_load_ptr(&amp;V_nl_ctl);</p><p>+	struct sockaddr_nl snl = {</p><p>+		.nl_pid = port_id,</p><p>+	};</p><p>+	int error;</p><p>+</p><p>+	NLCTL_WLOCK(ctl);</p><p>+	NLP_LOCK(nlp);</p><p>+	snl.nl_groups = nlp-&gt;nl_groups;</p><p>+	error = nl_bind_locked(nlp, &amp;snl);</p><p>+	NLP_UNLOCK(nlp);</p><p>+	NLCTL_WUNLOCK(ctl);</p><p>+</p><p>+	NL_LOG(LOG_DEBUG3, &#34;socket %p, port assign: %d, error: %d&#34;, nlp-&gt;nl_socket, port_id, error);</p><p>+	return (error);</p><p>+}</p><p>+</p><p>+/*</p><p>+ * nl_autobind_port binds a unused portid to @nlp</p><p>+ * @nlp: pcb data for the netlink socket</p><p>+ * @candidate_id: first id to consider</p><p>+ */</p><p>+static int</p><p>+nl_autobind_port(struct nlpcb *nlp, uint32_t candidate_id)</p><p>+{</p><p>+	struct nl_control *ctl = atomic_load_ptr(&amp;V_nl_ctl);</p><p>+	uint32_t port_id = candidate_id;</p><p>+	NLCTL_TRACKER;</p><p>+	bool exist;</p><p>+	int error;</p><p>+</p><p>+	for (int i = 0; i &lt; 10; i++) {</p><p>+		NL_LOG(LOG_DEBUG3, &#34;socket %p, trying to assign port %d&#34;, nlp-&gt;nl_socket, port_id);</p><p>+		NLCTL_RLOCK(ctl);</p><p>+		exist = nl_port_lookup(port_id) != 0;</p><p>+		NLCTL_RUNLOCK(ctl);</p><p>+		if (!exist) {</p><p>+			error = nl_assign_port(nlp, port_id);</p><p>+			if (error != EADDRINUSE)</p><p>+				break;</p><p>+		}</p><p>+		port_id++;</p><p>+	}</p><p>+	NL_LOG(LOG_DEBUG3, &#34;socket %p, autobind to %d, error: %d&#34;, nlp-&gt;nl_socket, port_id, error);</p><p>+	return (error);</p><p>+}</p><p>+</p><p>+static int</p><p>+nl_pru_connect(struct socket *so, struct sockaddr *sa, struct thread *td)</p><p>+{</p><p>+	struct sockaddr_nl *snl = (struct sockaddr_nl *)sa;</p><p>+	struct nlpcb *nlp;</p><p>+</p><p>+	NL_LOG(LOG_DEBUG3, &#34;socket %p, PID %d&#34;, so, curproc-&gt;p_pid);</p><p>+	if (snl-&gt;nl_len != sizeof(*snl)) {</p><p>+		NL_LOG(LOG_DEBUG, &#34;socket %p, wrong sizeof(), ignoring bind()&#34;, so);</p><p>+		return (EINVAL);</p><p>+	}</p><p>+</p><p>+	nlp = sotonlpcb(so);</p><p>+	if (!nlp-&gt;nl_bound) {</p><p>+		int error = nl_autobind_port(nlp, td-&gt;td_proc-&gt;p_pid);</p><p>+		if (error != 0) {</p><p>+			NL_LOG(LOG_DEBUG, &#34;socket %p, nl_autobind() failed: %d&#34;, so, error);</p><p>+			return (error);</p><p>+		}</p><p>+	}</p><p>+	/* XXX: Handle socket flags &amp; multicast */</p><p>+	soisconnected(so);</p><p>+</p><p>+	NL_LOG(LOG_DEBUG2, &#34;socket %p, connect to %u&#34;, so, snl-&gt;nl_pid);</p><p>+</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+static void</p><p>+destroy_nlpcb(struct nlpcb *nlp)</p><p>+{</p><p>+	NLP_LOCK(nlp);</p><p>+	nl_free_io(nlp);</p><p>+	NLP_LOCK_DESTROY(nlp);</p><p>+	free(nlp, M_PCB);</p><p>+}</p><p>+</p><p>+static void</p><p>+destroy_nlpcb_epoch(epoch_context_t ctx)</p><p>+{</p><p>+	struct nlpcb *nlp;</p><p>+</p><p>+	nlp = __containerof(ctx, struct nlpcb, nl_epoch_ctx);</p><p>+</p><p>+	destroy_nlpcb(nlp);</p><p>+}</p><p>+</p><p>+</p><p>+static void</p><p>+nl_pru_detach(struct socket *so)</p><p>+{</p><p>+	struct nl_control *ctl = atomic_load_ptr(&amp;V_nl_ctl);</p><p>+	MPASS(sotonlpcb(so) != NULL);</p><p>+	struct nlpcb *nlp;</p><p>+</p><p>+	NL_LOG(LOG_DEBUG2, &#34;detaching socket %p, PID %d&#34;, so, curproc-&gt;p_pid);</p><p>+	nlp = sotonlpcb(so);</p><p>+</p><p>+	/* Mark as inactive so no new work can be enqueued */</p><p>+	NLP_LOCK(nlp);</p><p>+	bool was_bound = nlp-&gt;nl_bound;</p><p>+	nlp-&gt;nl_active = false;</p><p>+	NLP_UNLOCK(nlp);</p><p>+</p><p>+	/* Wait till all scheduled work has been completed  */</p><p>+	taskqueue_drain_all(nlp-&gt;nl_taskqueue);</p><p>+	taskqueue_free(nlp-&gt;nl_taskqueue);</p><p>+</p><p>+	NLCTL_WLOCK(ctl);</p><p>+	NLP_LOCK(nlp);</p><p>+	if (was_bound) {</p><p>+		CK_LIST_REMOVE(nlp, nl_port_next);</p><p>+		NL_LOG(LOG_DEBUG3, &#34;socket %p, unlinking bound pid %u&#34;, so, nlp-&gt;nl_port);</p><p>+	}</p><p>+	CK_LIST_REMOVE(nlp, nl_next);</p><p>+	nlp-&gt;nl_socket = NULL;</p><p>+	NLP_UNLOCK(nlp);</p><p>+	NLCTL_WUNLOCK(ctl);</p><p>+</p><p>+	so-&gt;so_pcb = NULL;</p><p>+</p><p>+	NL_LOG(LOG_DEBUG3, &#34;socket %p, detached&#34;, so);</p><p>+</p><p>+	/* XXX: is delayed free needed? */</p><p>+	epoch_call(net_epoch_preempt, destroy_nlpcb_epoch, &amp;nlp-&gt;nl_epoch_ctx);</p><p>+}</p><p>+</p><p>+static int</p><p>+nl_pru_disconnect(struct socket *so)</p><p>+{</p><p>+	NL_LOG(LOG_DEBUG3, &#34;socket %p, PID %d&#34;, so, curproc-&gt;p_pid);</p><p>+	MPASS(sotonlpcb(so) != NULL);</p><p>+	return (ENOTCONN);</p><p>+}</p><p>+</p><p>+static int</p><p>+nl_pru_peeraddr(struct socket *so, struct sockaddr **sa)</p><p>+{</p><p>+	NL_LOG(LOG_DEBUG3, &#34;socket %p, PID %d&#34;, so, curproc-&gt;p_pid);</p><p>+	MPASS(sotonlpcb(so) != NULL);</p><p>+	return (ENOTCONN);</p><p>+}</p><p>+</p><p>+static int</p><p>+nl_pru_shutdown(struct socket *so)</p><p>+{</p><p>+	NL_LOG(LOG_DEBUG3, &#34;socket %p, PID %d&#34;, so, curproc-&gt;p_pid);</p><p>+	MPASS(sotonlpcb(so) != NULL);</p><p>+	socantsendmore(so);</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+static int</p><p>+nl_pru_sockaddr(struct socket *so, struct sockaddr **sa)</p><p>+{</p><p>+	struct sockaddr_nl *snl;</p><p>+</p><p>+	snl = malloc(sizeof(struct sockaddr_nl), M_SONAME, M_WAITOK | M_ZERO);</p><p>+	/* TODO: set other fields */</p><p>+	snl-&gt;nl_len = sizeof(struct sockaddr_nl);</p><p>+	snl-&gt;nl_family = AF_NETLINK;</p><p>+	snl-&gt;nl_pid = sotonlpcb(so)-&gt;nl_port;</p><p>+	*sa = (struct sockaddr *)snl;</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+static void</p><p>+nl_pru_close(struct socket *so)</p><p>+{</p><p>+	NL_LOG(LOG_DEBUG3, &#34;socket %p, PID %d&#34;, so, curproc-&gt;p_pid);</p><p>+	MPASS(sotonlpcb(so) != NULL);</p><p>+	soisdisconnected(so);</p><p>+}</p><p>+</p><p>+static int</p><p>+nl_pru_output(struct mbuf *m, struct socket *so, ...)</p><p>+{</p><p>+</p><p>+	if (__predict_false(m == NULL ||</p><p>+	    ((m-&gt;m_len &lt; sizeof(struct nlmsghdr)) &amp;&amp;</p><p>+		(m = m_pullup(m, sizeof(struct nlmsghdr))) == NULL)))</p><p>+		return (ENOBUFS);</p><p>+	MPASS((m-&gt;m_flags &amp; M_PKTHDR) != 0);</p><p>+</p><p>+	NL_LOG(LOG_DEBUG3, &#34;sending message to kernel async processing&#34;);</p><p>+	nl_receive_async(m, so);</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+</p><p>+static int</p><p>+nl_pru_send(struct socket *so, int flags, struct mbuf *m, struct sockaddr *sa,</p><p>+    struct mbuf *control, struct thread *td)</p><p>+{</p><p>+        NL_LOG(LOG_DEBUG2, &#34;sending message to kernel&#34;);</p><p>+</p><p>+	if (__predict_false(control != NULL)) {</p><p>+		if (control-&gt;m_len) {</p><p>+			m_freem(control);</p><p>+			return (EINVAL);</p><p>+		}</p><p>+		m_freem(control);</p><p>+	}</p><p>+</p><p>+	return (nl_pru_output(m, so));</p><p>+}</p><p>+</p><p>+static int</p><p>+nl_pru_rcvd(struct socket *so, int flags)</p><p>+{</p><p>+	NL_LOG(LOG_DEBUG3, &#34;socket %p, PID %d&#34;, so, curproc-&gt;p_pid);</p><p>+	MPASS(sotonlpcb(so) != NULL);</p><p>+</p><p>+	nl_on_transmit(sotonlpcb(so));</p><p>+</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+static int</p><p>+nl_getoptflag(int sopt_name)</p><p>+{</p><p>+	switch (sopt_name) {</p><p>+	case NETLINK_CAP_ACK:</p><p>+		return (NLF_CAP_ACK);</p><p>+	case NETLINK_EXT_ACK:</p><p>+		return (NLF_EXT_ACK);</p><p>+	case NETLINK_GET_STRICT_CHK:</p><p>+		return (NLF_STRICT);</p><p>+	}</p><p>+</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+static int</p><p>+nl_ctloutput(struct socket *so, struct sockopt *sopt)</p><p>+{</p><p>+	struct nl_control *ctl = atomic_load_ptr(&amp;V_nl_ctl);</p><p>+	struct nlpcb *nlp = sotonlpcb(so);</p><p>+	uint32_t flag;</p><p>+	uint64_t groups, group_mask;</p><p>+	int optval, error = 0;</p><p>+	NLCTL_TRACKER;</p><p>+</p><p>+	NL_LOG(LOG_DEBUG2, &#34;%ssockopt(%p, %d)&#34;, (sopt-&gt;sopt_dir) ? &#34;set&#34; : &#34;get&#34;,</p><p>+	    so, sopt-&gt;sopt_name);</p><p>+</p><p>+	switch (sopt-&gt;sopt_dir) {</p><p>+	case SOPT_SET:</p><p>+		switch (sopt-&gt;sopt_name) {</p><p>+		case NETLINK_ADD_MEMBERSHIP:</p><p>+		case NETLINK_DROP_MEMBERSHIP:</p><p>+			sooptcopyin(sopt, &amp;optval, sizeof(optval), sizeof(optval));</p><p>+			if (optval &lt;= 0 || optval &gt;= 64) {</p><p>+				error = ERANGE;</p><p>+				break;</p><p>+			}</p><p>+			group_mask = (uint64_t)1 &lt;&lt; (optval - 1);</p><p>+			NL_LOG(LOG_DEBUG2, &#34;ADD/DEL group %d mask (%lX)&#34;, optval, group_mask);</p><p>+</p><p>+			NLCTL_WLOCK(ctl);</p><p>+			if (sopt-&gt;sopt_name == NETLINK_ADD_MEMBERSHIP)</p><p>+				groups = nlp-&gt;nl_groups | group_mask;</p><p>+			else</p><p>+				groups = nlp-&gt;nl_groups &amp; ~group_mask;</p><p>+			nl_update_groups_locked(nlp, groups);</p><p>+			NLCTL_WUNLOCK(ctl);</p><p>+			break;</p><p>+		case NETLINK_CAP_ACK:</p><p>+		case NETLINK_EXT_ACK:</p><p>+		case NETLINK_GET_STRICT_CHK:</p><p>+			sooptcopyin(sopt, &amp;optval, sizeof(optval), sizeof(optval));</p><p>+</p><p>+			flag = nl_getoptflag(sopt-&gt;sopt_name);</p><p>+</p><p>+			NLCTL_WLOCK(ctl);</p><p>+			if (optval != 0)</p><p>+				nlp-&gt;nl_flags |= flag;</p><p>+			else</p><p>+				nlp-&gt;nl_flags &amp;= ~flag;</p><p>+			NLCTL_WUNLOCK(ctl);</p><p>+			break;</p><p>+		default:</p><p>+			error = ENOPROTOOPT;</p><p>+		}</p><p>+		break;</p><p>+	case SOPT_GET:</p><p>+		switch (sopt-&gt;sopt_name) {</p><p>+		case NETLINK_LIST_MEMBERSHIPS:</p><p>+			NLCTL_RLOCK(ctl);</p><p>+			optval = nlp-&gt;nl_groups;</p><p>+			NLCTL_RUNLOCK(ctl);</p><p>+			error = sooptcopyout(sopt, &amp;optval, sizeof(optval));</p><p>+			break;</p><p>+		case NETLINK_CAP_ACK:</p><p>+		case NETLINK_EXT_ACK:</p><p>+		case NETLINK_GET_STRICT_CHK:</p><p>+			NLCTL_RLOCK(ctl);</p><p>+			optval = (nlp-&gt;nl_flags &amp; nl_getoptflag(sopt-&gt;sopt_name)) != 0;</p><p>+			NLCTL_RUNLOCK(ctl);</p><p>+			error = sooptcopyout(sopt, &amp;optval, sizeof(optval));</p><p>+			break;</p><p>+		default:</p><p>+			error = ENOPROTOOPT;</p><p>+		}</p><p>+		break;</p><p>+	default:</p><p>+		error = ENOPROTOOPT;</p><p>+	}</p><p>+</p><p>+	return (error);</p><p>+}</p><p>+</p><p>+static int</p><p>+nl_setsbopt(struct socket *so, struct sockopt *sopt)</p><p>+{</p><p>+	int error, optval;</p><p>+	bool result;</p><p>+</p><p>+	if (sopt-&gt;sopt_name != SO_RCVBUF)</p><p>+		return (sbsetopt(so, sopt));</p><p>+</p><p>+	/* Allow to override max buffer size in certain conditions */</p><p>+</p><p>+	error = sooptcopyin(sopt, &amp;optval, sizeof optval, sizeof optval);</p><p>+	if (error != 0)</p><p>+		return (error);</p><p>+	NL_LOG(LOG_DEBUG2, &#34;socket %p, PID %d, SO_RCVBUF=%d&#34;, so, curproc-&gt;p_pid, optval);</p><p>+	if (optval &gt; sb_max_adj) {</p><p>+		if (priv_check(curthread, PRIV_NET_ROUTE) != 0)</p><p>+			return (EPERM);</p><p>+	}</p><p>+</p><p>+	SOCK_RECVBUF_LOCK(so);</p><p>+	result = sbreserve_locked_limit(so, SO_RCV, optval, nl_maxsockbuf, curthread);</p><p>+	SOCK_RECVBUF_UNLOCK(so);</p><p>+</p><p>+	return (result ? 0 : ENOBUFS);</p><p>+}</p><p>+</p><p>+static struct protosw netlinksw = {</p><p>+	.pr_type = SOCK_RAW,</p><p>+	.pr_flags = PR_ATOMIC | PR_ADDR | PR_WANTRCVD,</p><p>+	.pr_ctloutput = nl_ctloutput,</p><p>+	.pr_setsbopt = nl_setsbopt,</p><p>+	.pr_abort = nl_pru_abort,</p><p>+	.pr_attach = nl_pru_attach,</p><p>+	.pr_bind = nl_pru_bind,</p><p>+	.pr_connect = nl_pru_connect,</p><p>+	.pr_detach = nl_pru_detach,</p><p>+	.pr_disconnect = nl_pru_disconnect,</p><p>+	.pr_peeraddr = nl_pru_peeraddr,</p><p>+	.pr_send = nl_pru_send,</p><p>+	.pr_rcvd = nl_pru_rcvd,</p><p>+	.pr_shutdown = nl_pru_shutdown,</p><p>+	.pr_sockaddr = nl_pru_sockaddr,</p><p>+	.pr_close = nl_pru_close</p><p>+};</p><p>+</p><p>+static struct domain netlinkdomain = {</p><p>+	.dom_family = PF_NETLINK,</p><p>+	.dom_name = &#34;netlink&#34;,</p><p>+	.dom_flags = DOMF_UNLOADABLE,</p><p>+	.dom_nprotosw =		1,</p><p>+	.dom_protosw =		{ &amp;netlinksw },</p><p>+};</p><p>+</p><p>+DOMAIN_SET(netlink);</p><div><p>diff --git a/sys/netlink/netlink_generic.c b/sys/netlink/netlink_generic.c</p></div><p>@@ -0,0 +1,472 @@</p><p>+/*-</p><p>+ * SPDX-License-Identifier: BSD-2-Clause-FreeBSD</p><p>+ *</p><p>+ * Copyright (c) 2022 Alexander V. Chernikov &lt;melifaro@FreeBSD.org&gt;</p><p>+ *</p><p>+ * Redistribution and use in source and binary forms, with or without</p><p>+ * modification, are permitted provided that the following conditions</p><p>+ * are met:</p><p>+ * 1. Redistributions of source code must retain the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer.</p><p>+ * 2. Redistributions in binary form must reproduce the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer in the</p><p>+ *    documentation and/or other materials provided with the distribution.</p><p>+ *</p><p>+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&#39;&#39; AND</p><p>+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</p><p>+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</p><p>+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE</p><p>+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</p><p>+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</p><p>+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</p><p>+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</p><p>+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</p><p>+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</p><p>+ * SUCH DAMAGE.</p><p>+ */</p><p>+</p><p>+#include &lt;sys/cdefs.h&gt;</p><p>+__FBSDID(&#34;$FreeBSD$&#34;);</p><p>+#include &lt;sys/types.h&gt;</p><p>+#include &lt;sys/malloc.h&gt;</p><p>+#include &lt;sys/priv.h&gt;</p><p>+#include &lt;sys/socket.h&gt;</p><p>+#include &lt;sys/ck.h&gt;</p><p>+</p><p>+#include &lt;netlink/netlink.h&gt;</p><p>+#include &lt;netlink/netlink_ctl.h&gt;</p><p>+#include &lt;netlink/netlink_var.h&gt;</p><p>+#include &lt;netlink/netlink_generic.h&gt;</p><p>+</p><p>+#define	DEBUG_MOD_NAME	nl_generic</p><p>+#define	DEBUG_MAX_LEVEL	LOG_DEBUG3</p><p>+#include &lt;netlink/netlink_debug.h&gt;</p><p>+_DECLARE_DEBUG(LOG_DEBUG3);</p><p>+</p><p>+#define	MAX_FAMILIES	20</p><p>+#define	MAX_GROUPS	20</p><p>+</p><p>+#define	MIN_GROUP_NUM	48</p><p>+</p><p>+static struct sx sx_lock;</p><p>+</p><p>+#define	GENL_LOCK_INIT()	sx_init(&amp;sx_lock, &#34;genetlink lock&#34;)</p><p>+#define	GENL_LOCK_DESTROY()	sx_destroy(&amp;sx_lock)</p><p>+#define	GENL_LOCK()		sx_xlock(&amp;sx_lock)</p><p>+#define	GENL_UNLOCK()		sx_xunlock(&amp;sx_lock)</p><p>+</p><p>+struct genl_family {</p><p>+	const char	*family_name;</p><p>+	uint16_t	family_hdrsize;</p><p>+	uint16_t	family_id;</p><p>+	uint16_t	family_version;</p><p>+	uint16_t	family_attr_max;</p><p>+	uint16_t	family_cmd_size;</p><p>+	uint16_t	family_num_groups;</p><p>+	struct genl_cmd	*family_cmds;</p><p>+};</p><p>+</p><p>+static struct genl_family	families[MAX_FAMILIES];</p><p>+</p><p>+</p><p>+struct genl_group {</p><p>+	struct genl_family	*group_family;</p><p>+	const char		*group_name;</p><p>+};</p><p>+static struct genl_group	groups[MAX_GROUPS];</p><p>+</p><p>+</p><p>+static int dump_family(struct nlmsghdr *hdr, struct genlmsghdr *ghdr,</p><p>+    const struct genl_family *gf, struct nl_writer *nw);</p><p>+static void nlctrl_notify(const struct genl_family *gf, int action);</p><p>+</p><p>+static struct genl_family *</p><p>+find_family(const char *family_name)</p><p>+{</p><p>+	for (int i = 0; i &lt; MAX_FAMILIES; i++) {</p><p>+		struct genl_family *gf = &amp;families[i];</p><p>+		if (gf-&gt;family_name != NULL &amp;&amp; !strcmp(gf-&gt;family_name, family_name))</p><p>+			return (gf);</p><p>+	}</p><p>+</p><p>+	return (NULL);</p><p>+}</p><p>+</p><p>+uint32_t</p><p>+genl_register_family(const char *family_name, size_t hdrsize, int family_version,</p><p>+    int max_attr_idx)</p><p>+{</p><p>+	uint32_t family_id = 0;</p><p>+</p><p>+	MPASS(family_name != NULL);</p><p>+	if (find_family(family_name) != NULL)</p><p>+		return (0);</p><p>+</p><p>+	GENL_LOCK();</p><p>+	for (int i = 0; i &lt; MAX_FAMILIES; i++) {</p><p>+		struct genl_family *gf = &amp;families[i];</p><p>+		if (gf-&gt;family_name == NULL) {</p><p>+			gf-&gt;family_name = family_name;</p><p>+			gf-&gt;family_version = family_version;</p><p>+			gf-&gt;family_hdrsize = hdrsize;</p><p>+			gf-&gt;family_attr_max = max_attr_idx;</p><p>+			gf-&gt;family_id = i + GENL_MIN_ID;</p><p>+			NL_LOG(LOG_DEBUG2, &#34;Registered family %s id %d&#34;,</p><p>+			    gf-&gt;family_name, gf-&gt;family_id);</p><p>+			family_id = gf-&gt;family_id;</p><p>+			nlctrl_notify(gf, CTRL_CMD_NEWFAMILY);</p><p>+			break;</p><p>+		}</p><p>+	}</p><p>+	GENL_UNLOCK();</p><p>+</p><p>+	return (family_id);</p><p>+}</p><p>+</p><p>+static void</p><p>+free_family(struct genl_family *gf)</p><p>+{</p><p>+	if (gf-&gt;family_cmds != NULL)</p><p>+		free(gf-&gt;family_cmds, M_NETLINK);</p><p>+}</p><p>+</p><p>+/*</p><p>+ * Can sleep, I guess</p><p>+ */</p><p>+bool</p><p>+genl_unregister_family(const char *family_name)</p><p>+{</p><p>+	bool found = false;</p><p>+</p><p>+	GENL_LOCK();</p><p>+	struct genl_family *gf = find_family(family_name);</p><p>+</p><p>+	nlctrl_notify(gf, CTRL_CMD_DELFAMILY);</p><p>+</p><p>+	if (gf != NULL) {</p><p>+		found = true;</p><p>+		/* TODO: zero pointer first */</p><p>+		free_family(gf);</p><p>+		bzero(gf, sizeof(*gf));</p><p>+	}</p><p>+	GENL_UNLOCK();</p><p>+</p><p>+	return (found);</p><p>+}</p><p>+</p><p>+bool</p><p>+genl_register_cmds(const char *family_name, const struct genl_cmd *cmds, int count)</p><p>+{</p><p>+	GENL_LOCK();</p><p>+	struct genl_family *gf = find_family(family_name);</p><p>+	if (gf == NULL) {</p><p>+		GENL_UNLOCK();</p><p>+		return (false);</p><p>+	}</p><p>+</p><p>+	int cmd_size = gf-&gt;family_cmd_size;</p><p>+</p><p>+	for (int i = 0; i &lt; count; i++) {</p><p>+		MPASS(cmds[i].cmd_cb != NULL);</p><p>+		if (cmds[i].cmd_num &gt;= cmd_size)</p><p>+			cmd_size = cmds[i].cmd_num + 1;</p><p>+	}</p><p>+</p><p>+	if (cmd_size &gt; gf-&gt;family_cmd_size) {</p><p>+		/* need to realloc */</p><p>+		size_t sz = cmd_size * sizeof(struct genl_cmd);</p><p>+		void *data = malloc(sz, M_NETLINK, M_WAITOK | M_ZERO);</p><p>+</p><p>+		memcpy(data, gf-&gt;family_cmds, gf-&gt;family_cmd_size * sizeof(struct genl_cmd));</p><p>+		void *old_data = gf-&gt;family_cmds;</p><p>+		gf-&gt;family_cmds = data;</p><p>+		gf-&gt;family_cmd_size = cmd_size;</p><p>+		free(old_data, M_NETLINK);</p><p>+	}</p><p>+</p><p>+	for (int i = 0; i &lt; count; i++) {</p><p>+		const struct genl_cmd *cmd = &amp;cmds[i];</p><p>+		MPASS(gf-&gt;family_cmds[cmd-&gt;cmd_num].cmd_cb == NULL);</p><p>+		gf-&gt;family_cmds[cmd-&gt;cmd_num] = cmds[i];</p><p>+		NL_LOG(LOG_DEBUG2, &#34;Adding cmd %s(%d) to family %s&#34;,</p><p>+		    cmd-&gt;cmd_name, cmd-&gt;cmd_num, gf-&gt;family_name);</p><p>+	}</p><p>+	GENL_UNLOCK();</p><p>+	return (true);</p><p>+}</p><p>+</p><p>+static struct genl_group *</p><p>+find_group(const struct genl_family *gf, const char *group_name)</p><p>+{</p><p>+	for (int i = 0; i &lt; MAX_GROUPS; i++) {</p><p>+		struct genl_group *gg = &amp;groups[i];</p><p>+		if (gg-&gt;group_family == gf &amp;&amp; !strcmp(gg-&gt;group_name, group_name))</p><p>+			return (gg);</p><p>+	}</p><p>+	return (NULL);</p><p>+}</p><p>+</p><p>+uint32_t</p><p>+genl_register_group(const char *family_name, const char *group_name)</p><p>+{</p><p>+	uint32_t group_id = 0;</p><p>+</p><p>+	MPASS(family_name != NULL);</p><p>+	MPASS(group_name != NULL);</p><p>+</p><p>+	GENL_LOCK();</p><p>+	struct genl_family *gf = find_family(family_name);</p><p>+</p><p>+	if (gf == NULL || find_group(gf, group_name) != NULL) {</p><p>+		GENL_UNLOCK();</p><p>+		return (0);</p><p>+	}</p><p>+</p><p>+	for (int i = 0; i &lt; MAX_GROUPS; i++) {</p><p>+		struct genl_group *gg = &amp;groups[i];</p><p>+		if (gg-&gt;group_family == NULL) {</p><p>+			gf-&gt;family_num_groups++;</p><p>+			gg-&gt;group_family = gf;</p><p>+			gg-&gt;group_name = group_name;</p><p>+			group_id = i + MIN_GROUP_NUM;</p><p>+			break;</p><p>+		}</p><p>+	}</p><p>+	GENL_UNLOCK();</p><p>+</p><p>+	return (group_id);</p><p>+}</p><p>+</p><p>+/*</p><p>+ * Handler called by netlink subsystem when matching netlink message is received</p><p>+ */</p><p>+static int</p><p>+genl_handle_message(struct nlmsghdr *hdr, struct nl_pstate *npt)</p><p>+{</p><p>+	struct nlpcb *nlp = npt-&gt;nlp;</p><p>+	int error = 0;</p><p>+</p><p>+	int family_id = (int)hdr-&gt;nlmsg_type - GENL_MIN_ID;</p><p>+</p><p>+	if (__predict_false(family_id &lt; 0 || family_id &gt; MAX_FAMILIES)) {</p><p>+		NLP_LOG(LOG_DEBUG, nlp, &#34;invalid message type: %d&#34;, hdr-&gt;nlmsg_type);</p><p>+		return (ENOTSUP);</p><p>+	}</p><p>+</p><p>+	if (__predict_false(hdr-&gt;nlmsg_len &lt; sizeof(hdr) + GENL_HDRLEN)) {</p><p>+		NLP_LOG(LOG_DEBUG, nlp, &#34;invalid message size: %d&#34;, hdr-&gt;nlmsg_len);</p><p>+		return (EINVAL);</p><p>+	}</p><p>+</p><p>+	struct genl_family *gf = &amp;families[family_id];</p><p>+</p><p>+	struct genlmsghdr *ghdr = (struct genlmsghdr *)(hdr + 1);</p><p>+</p><p>+	if (ghdr-&gt;cmd &gt;= gf-&gt;family_cmd_size || gf-&gt;family_cmds[ghdr-&gt;cmd].cmd_cb == NULL) {</p><p>+		NLP_LOG(LOG_DEBUG, nlp, &#34;family %s: invalid cmd %d&#34;,</p><p>+		    gf-&gt;family_name, ghdr-&gt;cmd);</p><p>+		return (ENOTSUP);</p><p>+	}</p><p>+</p><p>+	struct genl_cmd *cmd = &amp;gf-&gt;family_cmds[ghdr-&gt;cmd];</p><p>+</p><p>+	if (cmd-&gt;cmd_priv != 0 &amp;&amp; !nlp_has_priv(nlp, cmd-&gt;cmd_priv)) {</p><p>+		NLP_LOG(LOG_DEBUG, nlp, &#34;family %s: cmd %d priv_check() failed&#34;,</p><p>+		    gf-&gt;family_name, ghdr-&gt;cmd);</p><p>+		return (EPERM);</p><p>+	}</p><p>+</p><p>+	NLP_LOG(LOG_DEBUG2, nlp, &#34;received family %s cmd %s(%d) len %d&#34;,</p><p>+	    gf-&gt;family_name, cmd-&gt;cmd_name, ghdr-&gt;cmd, hdr-&gt;nlmsg_len);</p><p>+</p><p>+	error = cmd-&gt;cmd_cb(hdr, npt);</p><p>+</p><p>+	return (error);</p><p>+}</p><p>+</p><p>+static uint32_t</p><p>+get_cmd_flags(const struct genl_cmd *cmd)</p><p>+{</p><p>+	uint32_t flags = cmd-&gt;cmd_flags;</p><p>+	if (cmd-&gt;cmd_priv != 0)</p><p>+		flags |= GENL_ADMIN_PERM;</p><p>+	return (flags);</p><p>+}</p><p>+</p><p>+static int</p><p>+dump_family(struct nlmsghdr *hdr, struct genlmsghdr *ghdr,</p><p>+    const struct genl_family *gf, struct nl_writer *nw)</p><p>+{</p><p>+	if (!nlmsg_reply(nw, hdr, sizeof(struct genlmsghdr)))</p><p>+		goto enomem;</p><p>+</p><p>+	struct genlmsghdr *ghdr_new = nlmsg_reserve_object(nw, struct genlmsghdr);</p><p>+	ghdr_new-&gt;cmd = ghdr-&gt;cmd;</p><p>+	ghdr_new-&gt;version = gf-&gt;family_version;</p><p>+	ghdr_new-&gt;reserved = 0;</p><p>+</p><p>+        nlattr_add_string(nw, CTRL_ATTR_FAMILY_NAME, gf-&gt;family_name);</p><p>+        nlattr_add_u16(nw, CTRL_ATTR_FAMILY_ID, gf-&gt;family_id);</p><p>+        nlattr_add_u32(nw, CTRL_ATTR_VERSION, gf-&gt;family_version);</p><p>+        nlattr_add_u32(nw, CTRL_ATTR_HDRSIZE, gf-&gt;family_hdrsize);</p><p>+        nlattr_add_u32(nw, CTRL_ATTR_MAXATTR, gf-&gt;family_attr_max);</p><p>+</p><p>+	if (gf-&gt;family_cmd_size &gt; 0) {</p><p>+		int off = nlattr_add_nested(nw, CTRL_ATTR_OPS);</p><p>+		if (off == 0)</p><p>+			goto enomem;</p><p>+		for (int i = 0, cnt=0; i &lt; gf-&gt;family_cmd_size; i++) {</p><p>+			struct genl_cmd *cmd = &amp;gf-&gt;family_cmds[i];</p><p>+			if (cmd-&gt;cmd_cb == NULL)</p><p>+				continue;</p><p>+			int cmd_off = nlattr_add_nested(nw, ++cnt);</p><p>+			if (cmd_off == 0)</p><p>+				goto enomem;</p><p>+</p><p>+			nlattr_add_u32(nw, CTRL_ATTR_OP_ID, cmd-&gt;cmd_num);</p><p>+			nlattr_add_u32(nw, CTRL_ATTR_OP_FLAGS, get_cmd_flags(cmd));</p><p>+			nlattr_set_len(nw, cmd_off);</p><p>+		}</p><p>+		nlattr_set_len(nw, off);</p><p>+	}</p><p>+	if (gf-&gt;family_num_groups &gt; 0) {</p><p>+		int off = nlattr_add_nested(nw, CTRL_ATTR_MCAST_GROUPS);</p><p>+		if (off == 0)</p><p>+			goto enomem;</p><p>+		for (int i = 0, cnt = 0; i &lt; MAX_GROUPS; i++) {</p><p>+			struct genl_group *gg = &amp;groups[i];</p><p>+			if (gg-&gt;group_family != gf)</p><p>+				continue;</p><p>+</p><p>+			int cmd_off = nlattr_add_nested(nw, ++cnt);</p><p>+			if (cmd_off == 0)</p><p>+				goto enomem;</p><p>+			nlattr_add_u32(nw, CTRL_ATTR_MCAST_GRP_ID, i + MIN_GROUP_NUM);</p><p>+			nlattr_add_string(nw, CTRL_ATTR_MCAST_GRP_NAME, gg-&gt;group_name);</p><p>+			nlattr_set_len(nw, cmd_off);</p><p>+		}</p><p>+		nlattr_set_len(nw, off);</p><p>+	}</p><p>+	if (nlmsg_end(nw))</p><p>+		return (0);</p><p>+enomem:</p><p>+        NL_LOG(LOG_DEBUG, &#34;unable to dump family %s state (ENOMEM)&#34;, gf-&gt;family_name);</p><p>+        nlmsg_abort(nw);</p><p>+	return (ENOMEM);</p><p>+}</p><p>+</p><p>+</p><p>+/* Declare ourself as a user */</p><p>+#define	CTRL_FAMILY_NAME	&#34;nlctrl&#34;</p><p>+</p><p>+static uint32_t ctrl_family_id;</p><p>+static uint32_t ctrl_group_id;</p><p>+</p><p>+struct nl_parsed_family {</p><p>+	uint32_t	family_id;</p><p>+	char		*family_name;</p><p>+	uint8_t		version;</p><p>+};</p><p>+</p><p>+#define	_IN(_field)	offsetof(struct genlmsghdr, _field)</p><p>+#define	_OUT(_field)	offsetof(struct nl_parsed_family, _field)</p><p>+static const struct nlfield_parser nlf_p_generic[] = {</p><p>+	{ .off_in = _IN(version), .off_out = _OUT(version), .cb = nlf_get_u8 },</p><p>+};</p><p>+</p><p>+static struct nlattr_parser nla_p_generic[] = {</p><p>+	{ .type = CTRL_ATTR_FAMILY_ID , .off = _OUT(family_id), .cb = nlattr_get_uint32 },</p><p>+	{ .type = CTRL_ATTR_FAMILY_NAME , .off = _OUT(family_id), .cb = nlattr_get_string },</p><p>+};</p><p>+#undef _IN</p><p>+#undef _OUT</p><p>+NL_DECLARE_PARSER(genl_parser, struct genlmsghdr, nlf_p_generic, nla_p_generic);</p><p>+</p><p>+static int</p><p>+nlctrl_handle_getfamily(struct nlmsghdr *hdr, struct nl_pstate *npt)</p><p>+{</p><p>+	int error = 0;</p><p>+</p><p>+	struct nl_parsed_family attrs = {};</p><p>+	error = nl_parse_nlmsg(hdr, &amp;genl_parser, npt, &amp;attrs);</p><p>+	if (error != 0)</p><p>+		return (error);</p><p>+</p><p>+	struct genlmsghdr ghdr = {</p><p>+		.cmd = CTRL_CMD_NEWFAMILY,</p><p>+	};</p><p>+</p><p>+	for (int i = 0; i &lt; MAX_FAMILIES; i++) {</p><p>+		struct genl_family *gf = &amp;families[i];</p><p>+		if (gf-&gt;family_name == NULL)</p><p>+			continue;</p><p>+		if (attrs.family_id != 0 &amp;&amp; attrs.family_id != gf-&gt;family_id)</p><p>+			continue;</p><p>+		if (attrs.family_name != NULL &amp;&amp; strcmp(attrs.family_name, gf-&gt;family_name))</p><p>+			continue;</p><p>+		error = dump_family(hdr, &amp;ghdr, &amp;families[i], npt-&gt;nw);</p><p>+		if (error != 0)</p><p>+			break;</p><p>+	}</p><p>+</p><p>+	return (error);</p><p>+}</p><p>+</p><p>+static void</p><p>+nlctrl_notify(const struct genl_family *gf, int cmd)</p><p>+{</p><p>+	struct nlmsghdr hdr = {.nlmsg_type = NETLINK_GENERIC };</p><p>+	struct genlmsghdr ghdr = { .cmd = cmd };</p><p>+	struct nl_writer nw = {};</p><p>+</p><p>+	if (nlmsg_get_group_writer(&amp;nw, NLMSG_SMALL, NETLINK_GENERIC, ctrl_group_id)) {</p><p>+		dump_family(&amp;hdr, &amp;ghdr, gf, &amp;nw);</p><p>+		nlmsg_flush(&amp;nw);</p><p>+		return;</p><p>+	}</p><p>+	NL_LOG(LOG_DEBUG, &#34;error allocating group writer&#34;);</p><p>+}</p><p>+</p><p>+static const struct genl_cmd nlctrl_cmds[] = {</p><p>+	{</p><p>+		.cmd_num = CTRL_CMD_GETFAMILY,</p><p>+		.cmd_name = &#34;GETFAMILY&#34;,</p><p>+		.cmd_cb = nlctrl_handle_getfamily,</p><p>+		.cmd_flags = GENL_CMD_CAP_DO | GENL_CMD_CAP_DUMP, GENL_CMD_CAP_HASPOL,</p><p>+	},</p><p>+};</p><p>+</p><p>+static void</p><p>+genl_nlctrl_init()</p><p>+{</p><p>+	ctrl_family_id = genl_register_family(CTRL_FAMILY_NAME, 0, 2, CTRL_ATTR_MAX);</p><p>+	genl_register_cmds(CTRL_FAMILY_NAME, nlctrl_cmds, NL_ARRAY_LEN(nlctrl_cmds));</p><p>+	ctrl_group_id = genl_register_group(CTRL_FAMILY_NAME, &#34;notify&#34;);</p><p>+}</p><p>+</p><p>+static void</p><p>+genl_nlctrl_destroy()</p><p>+{</p><p>+	genl_unregister_family(CTRL_FAMILY_NAME);</p><p>+}</p><p>+</p><p>+static const struct nlhdr_parser *all_parsers[] = { &amp;genl_parser };</p><p>+</p><p>+static void</p><p>+genl_load(void *u __unused)</p><p>+{</p><p>+	GENL_LOCK_INIT();</p><p>+	NL_VERIFY_PARSERS(all_parsers);</p><p>+	netlink_register_proto(NETLINK_GENERIC, &#34;NETLINK_GENERIC&#34;, genl_handle_message);</p><p>+	genl_nlctrl_init();</p><p>+}</p><p>+SYSINIT(genl_load, SI_SUB_PROTO_DOMAIN, SI_ORDER_THIRD, genl_load, NULL);</p><p>+</p><p>+static void</p><p>+genl_unload(void *u __unused)</p><p>+{</p><p>+	genl_nlctrl_destroy();</p><p>+	GENL_LOCK_DESTROY();</p><p>+	epoch_wait_preempt(net_epoch_preempt);</p><p>+}</p><p>+SYSUNINIT(genl_unload, SI_SUB_PROTO_DOMAIN, SI_ORDER_THIRD, genl_unload, NULL);</p><div><p>diff --git a/sys/netlink/netlink_generic.h b/sys/netlink/netlink_generic.h</p></div><p>@@ -0,0 +1,112 @@</p><p>+/*-</p><p>+ * SPDX-License-Identifier: BSD-2-Clause-FreeBSD</p><p>+ *</p><p>+ * Copyright (c) 2022 Alexander V. Chernikov &lt;melifaro@FreeBSD.org&gt;</p><p>+ *</p><p>+ * Redistribution and use in source and binary forms, with or without</p><p>+ * modification, are permitted provided that the following conditions</p><p>+ * are met:</p><p>+ * 1. Redistributions of source code must retain the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer.</p><p>+ * 2. Redistributions in binary form must reproduce the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer in the</p><p>+ *    documentation and/or other materials provided with the distribution.</p><p>+ *</p><p>+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&#39;&#39; AND</p><p>+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</p><p>+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</p><p>+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE</p><p>+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</p><p>+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</p><p>+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</p><p>+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</p><p>+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</p><p>+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</p><p>+ * SUCH DAMAGE.</p><p>+ */</p><p>+</p><p>+/*</p><p>+ * Generic netlink message header and attributes</p><p>+ */</p><p>+#ifndef _NETLINK_NETLINK_GENERIC_H_</p><p>+#define	_NETLINK_NETLINK_GENERIC_H_</p><p>+</p><p>+/* Base header for all of the relevant messages */</p><p>+struct genlmsghdr {</p><p>+	uint8_t		cmd;		/* CTRL_CMD_ */</p><p>+	uint8_t		version;	/* ABI version for the cmd */</p><p>+	uint16_t	reserved;	/* reserved: set to 0 */</p><p>+};</p><p>+#define GENL_HDRLEN	NL_ITEM_ALIGN(sizeof(struct genlmsghdr))</p><p>+</p><p>+/* Dynamic family number range, inclusive */</p><p>+#define	GENL_MIN_ID	NLMSG_MIN_TYPE</p><p>+#define	GENL_MAX_ID	1023</p><p>+</p><p>+/* Pre-defined family numbers */</p><p>+#define	GENL_ID_CTRL	GENL_MIN_ID</p><p>+</p><p>+/* Available commands */</p><p>+enum {</p><p>+	CTRL_CMD_UNSPEC		= 0,</p><p>+	CTRL_CMD_NEWFAMILY	= 1,</p><p>+	CTRL_CMD_DELFAMILY	= 2,</p><p>+	CTRL_CMD_GETFAMILY	= 3, /* lists all (or matching) genetlink families */</p><p>+	CTRL_CMD_NEWOPS		= 4,</p><p>+	CTRL_CMD_DELOPS		= 5,</p><p>+	CTRL_CMD_GETOPS		= 6,</p><p>+	CTRL_CMD_NEWMCAST_GRP	= 7,</p><p>+	CTRL_CMD_DELMCAST_GRP	= 8,</p><p>+	CTRL_CMD_GETMCAST_GRP	= 9,</p><p>+	CTRL_CMD_GETPOLICY	= 10,</p><p>+	__CTRL_CMD_MAX,</p><p>+};</p><p>+#define	CTRL_CMD_MAX	(__CTRL_CMD_MAX - 1)</p><p>+</p><p>+/* Generic attributes */</p><p>+enum {</p><p>+	CTRL_ATTR_UNSPEC,</p><p>+	CTRL_ATTR_FAMILY_ID	= 1, /* u16, dynamically-assigned ID */</p><p>+	CTRL_ATTR_FAMILY_NAME	= 2, /* string, family name */</p><p>+	CTRL_ATTR_VERSION	= 3, /* u32, command version */</p><p>+	CTRL_ATTR_HDRSIZE	= 4, /* u32, family header size */</p><p>+	CTRL_ATTR_MAXATTR	= 5, /* u32, maximum family attr # */</p><p>+	CTRL_ATTR_OPS		= 6, /* nested, available operations */</p><p>+	CTRL_ATTR_MCAST_GROUPS	= 7,</p><p>+	CTRL_ATTR_POLICY	= 8,</p><p>+	CTRL_ATTR_OP_POLICY	= 9,</p><p>+	CTRL_ATTR_OP		= 10,</p><p>+	__CTRL_ATTR_MAX,</p><p>+};</p><p>+#define	CTRL_ATTR_MAX	(__CTRL_ATTR_MAX - 1)</p><p>+</p><p>+#define	GENL_NAMSIZ	16 /* max family name length including \0 */</p><p>+</p><p>+/* CTRL_ATTR_OPS attributes */</p><p>+enum {</p><p>+	CTRL_ATTR_OP_UNSPEC,</p><p>+	CTRL_ATTR_OP_ID		= 1, /* u32, operation # */</p><p>+	CTRL_ATTR_OP_FLAGS	= 2, /* u32, flags-based op description */</p><p>+	__CTRL_ATTR_OP_MAX,</p><p>+};</p><p>+#define	CTRL_ATTR_OP_MAX	(__CTRL_ATTR_OP_MAX - 1)</p><p>+</p><p>+/* CTRL_ATTR_OP_FLAGS values */</p><p>+#define GENL_ADMIN_PERM		0x0001 /* Requires elevated permissions */</p><p>+#define GENL_CMD_CAP_DO		0x0002 /* Operation is a modification request */</p><p>+#define GENL_CMD_CAP_DUMP	0x0004 /* Operation is a get/dump request */</p><p>+#define GENL_CMD_CAP_HASPOL	0x0008 /* Operation has a validation policy */</p><p>+#define GENL_UNS_ADMIN_PERM	0x0010</p><p>+</p><p>+/* CTRL_ATTR_MCAST_GROUPS attributes */</p><p>+enum {</p><p>+	CTRL_ATTR_MCAST_GRP_UNSPEC,</p><p>+	CTRL_ATTR_MCAST_GRP_NAME,	/* string, group name */</p><p>+	CTRL_ATTR_MCAST_GRP_ID,		/* u32, dynamically-assigned group id */</p><p>+	__CTRL_ATTR_MCAST_GRP_MAX,</p><p>+};</p><p>+#define	CTRL_ATTR_MCAST_GRP_MAX	(CTRL_ATTR_MCAST_GRP_MAX - 1)</p><p>+</p><p>+</p><p>+#endif</p><p>+</p><div><p>diff --git a/sys/netlink/netlink_io.c b/sys/netlink/netlink_io.c</p></div><p>@@ -0,0 +1,528 @@</p><p>+/*-</p><p>+ * SPDX-License-Identifier: BSD-2-Clause-FreeBSD</p><p>+ *</p><p>+ * Copyright (c) 2021 Ng Peng Nam Sean</p><p>+ * Copyright (c) 2022 Alexander V. Chernikov &lt;melifaro@FreeBSD.org&gt;</p><p>+ *</p><p>+ * Redistribution and use in source and binary forms, with or without</p><p>+ * modification, are permitted provided that the following conditions</p><p>+ * are met:</p><p>+ * 1. Redistributions of source code must retain the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer.</p><p>+ * 2. Redistributions in binary form must reproduce the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer in the</p><p>+ *    documentation and/or other materials provided with the distribution.</p><p>+ *</p><p>+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&#39;&#39; AND</p><p>+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</p><p>+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</p><p>+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE</p><p>+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</p><p>+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</p><p>+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</p><p>+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</p><p>+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</p><p>+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</p><p>+ * SUCH DAMAGE.</p><p>+ */</p><p>+</p><p>+#include &lt;sys/cdefs.h&gt;</p><p>+__FBSDID(&#34;$FreeBSD$&#34;);</p><p>+#include &lt;sys/param.h&gt;</p><p>+#include &lt;sys/malloc.h&gt;</p><p>+#include &lt;sys/lock.h&gt;</p><p>+#include &lt;sys/mbuf.h&gt;</p><p>+#include &lt;sys/ck.h&gt;</p><p>+#include &lt;sys/socket.h&gt;</p><p>+#include &lt;sys/socketvar.h&gt;</p><p>+#include &lt;sys/syslog.h&gt;</p><p>+</p><p>+#include &lt;netlink/netlink.h&gt;</p><p>+#include &lt;netlink/netlink_ctl.h&gt;</p><p>+#include &lt;netlink/netlink_linux.h&gt;</p><p>+#include &lt;netlink/netlink_var.h&gt;</p><p>+</p><p>+#define	DEBUG_MOD_NAME	nl_io</p><p>+#define	DEBUG_MAX_LEVEL	LOG_DEBUG3</p><p>+#include &lt;netlink/netlink_debug.h&gt;</p><p>+_DECLARE_DEBUG(LOG_DEBUG);</p><p>+</p><p>+/*</p><p>+ * The logic below provide a p2p interface for receiving and</p><p>+ * sending netlink data between the kernel and userland.</p><p>+ */</p><p>+</p><p>+static const struct sockaddr_nl _nl_empty_src = {</p><p>+	.nl_len = sizeof(struct sockaddr_nl),</p><p>+	.nl_family = PF_NETLINK,</p><p>+	.nl_pid = 0 /* comes from the kernel */</p><p>+};</p><p>+static const struct sockaddr *nl_empty_src = (const struct sockaddr *)&amp;_nl_empty_src;</p><p>+</p><p>+static struct mbuf *nl_process_mbuf(struct mbuf *m, struct nlpcb *nlp);</p><p>+</p><p>+</p><p>+static void</p><p>+queue_push(struct nl_io_queue *q, struct mbuf *mq)</p><p>+{</p><p>+	while (mq != NULL) {</p><p>+		struct mbuf *m = mq;</p><p>+		mq = mq-&gt;m_nextpkt;</p><p>+		m-&gt;m_nextpkt = NULL;</p><p>+</p><p>+		q-&gt;length += m_length(m, NULL);</p><p>+		STAILQ_INSERT_TAIL(&amp;q-&gt;head, m, m_stailqpkt);</p><p>+	}</p><p>+}</p><p>+</p><p>+static void</p><p>+queue_push_head(struct nl_io_queue *q, struct mbuf *m)</p><p>+{</p><p>+	MPASS(m-&gt;m_nextpkt == NULL);</p><p>+</p><p>+	q-&gt;length += m_length(m, NULL);</p><p>+	STAILQ_INSERT_HEAD(&amp;q-&gt;head, m, m_stailqpkt);</p><p>+}</p><p>+</p><p>+static struct mbuf *</p><p>+queue_pop(struct nl_io_queue *q)</p><p>+{</p><p>+	if (!STAILQ_EMPTY(&amp;q-&gt;head)) {</p><p>+		struct mbuf *m = STAILQ_FIRST(&amp;q-&gt;head);</p><p>+		STAILQ_REMOVE_HEAD(&amp;q-&gt;head, m_stailqpkt);</p><p>+		m-&gt;m_nextpkt = NULL;</p><p>+		q-&gt;length -= m_length(m, NULL);</p><p>+</p><p>+		return (m);</p><p>+	}</p><p>+	return (NULL);</p><p>+}</p><p>+</p><p>+static struct mbuf *</p><p>+queue_head(const struct nl_io_queue *q)</p><p>+{</p><p>+	return (STAILQ_FIRST(&amp;q-&gt;head));</p><p>+}</p><p>+</p><p>+static inline bool</p><p>+queue_empty(const struct nl_io_queue *q)</p><p>+{</p><p>+	return (q-&gt;length == 0);</p><p>+}</p><p>+</p><p>+static void</p><p>+queue_free(struct nl_io_queue *q)</p><p>+{</p><p>+	while (!STAILQ_EMPTY(&amp;q-&gt;head)) {</p><p>+		struct mbuf *m = STAILQ_FIRST(&amp;q-&gt;head);</p><p>+		STAILQ_REMOVE_HEAD(&amp;q-&gt;head, m_stailqpkt);</p><p>+		m-&gt;m_nextpkt = NULL;</p><p>+		m_freem(m);</p><p>+	}</p><p>+	q-&gt;length = 0;</p><p>+}</p><p>+</p><p>+</p><p>+static void</p><p>+nl_schedule_taskqueue(struct nlpcb *nlp)</p><p>+{</p><p>+	if (!nlp-&gt;nl_task_pending) {</p><p>+		nlp-&gt;nl_task_pending = true;</p><p>+		taskqueue_enqueue(nlp-&gt;nl_taskqueue, &amp;nlp-&gt;nl_task);</p><p>+		NL_LOG(LOG_DEBUG3, &#34;taskqueue scheduled&#34;);</p><p>+	} else {</p><p>+		NL_LOG(LOG_DEBUG3, &#34;taskqueue schedule skipped&#34;);</p><p>+	}</p><p>+}</p><p>+</p><p>+int</p><p>+nl_receive_async(struct mbuf *m, struct socket *so)</p><p>+{</p><p>+	struct nlpcb *nlp = sotonlpcb(so);</p><p>+	int error = 0;</p><p>+</p><p>+	m-&gt;m_nextpkt = NULL;</p><p>+</p><p>+	NLP_LOCK(nlp);</p><p>+</p><p>+	if ((__predict_true(nlp-&gt;nl_active))) {</p><p>+		sbappend(&amp;so-&gt;so_snd, m, 0);</p><p>+		NL_LOG(LOG_DEBUG3, &#34;enqueue %u bytes&#34;, m_length(m, NULL));</p><p>+		nl_schedule_taskqueue(nlp);</p><p>+	} else {</p><p>+		NL_LOG(LOG_DEBUG, &#34;ignoring %u bytes on non-active socket&#34;,</p><p>+		    m_length(m, NULL));</p><p>+		m_free(m);</p><p>+		error = EINVAL;</p><p>+	}</p><p>+</p><p>+	NLP_UNLOCK(nlp);</p><p>+</p><p>+	return (error);</p><p>+}</p><p>+</p><p>+static bool</p><p>+tx_check_locked(struct nlpcb *nlp)</p><p>+{</p><p>+	if (queue_empty(&amp;nlp-&gt;tx_queue))</p><p>+		return (true);</p><p>+</p><p>+	/*</p><p>+	 * Check if something can be moved from the internal TX queue</p><p>+	 * to the socket queue.</p><p>+	 */</p><p>+</p><p>+	bool appended = false;</p><p>+	struct sockbuf *sb = &amp;nlp-&gt;nl_socket-&gt;so_rcv;</p><p>+	SOCKBUF_LOCK(sb);</p><p>+</p><p>+	while (true) {</p><p>+		struct mbuf *m = queue_head(&amp;nlp-&gt;tx_queue);</p><p>+		if (m &amp;&amp; sbappendaddr_locked(sb, nl_empty_src, m, NULL) != 0) {</p><p>+			/* appended successfully */</p><p>+			queue_pop(&amp;nlp-&gt;tx_queue);</p><p>+			appended = true;</p><p>+		} else</p><p>+			break;</p><p>+	}</p><p>+</p><p>+	SOCKBUF_UNLOCK(sb);</p><p>+</p><p>+	if (appended)</p><p>+		sorwakeup(nlp-&gt;nl_socket);</p><p>+</p><p>+	return (queue_empty(&amp;nlp-&gt;tx_queue));</p><p>+}</p><p>+</p><p>+static bool</p><p>+nl_process_received_one(struct nlpcb *nlp)</p><p>+{</p><p>+	bool reschedule = false;</p><p>+</p><p>+	NLP_LOCK(nlp);</p><p>+	nlp-&gt;nl_task_pending = false;</p><p>+</p><p>+	if (!tx_check_locked(nlp)) {</p><p>+		/* TX overflow queue still not empty, ignore RX */</p><p>+		NLP_UNLOCK(nlp);</p><p>+		return (false);</p><p>+	}</p><p>+</p><p>+	if (queue_empty(&amp;nlp-&gt;rx_queue)) {</p><p>+		/*</p><p>+		 * Grab all data we have from the socket TX queue</p><p>+		 * and store it the internal queue, so it can be worked on</p><p>+		 * w/o holding socket lock.</p><p>+		 */</p><p>+		struct sockbuf *sb = &amp;nlp-&gt;nl_socket-&gt;so_snd;</p><p>+</p><p>+		SOCKBUF_LOCK(sb);</p><p>+		unsigned int avail = sbavail(sb);</p><p>+		if (avail &gt; 0) {</p><p>+			NL_LOG(LOG_DEBUG3, &#34;grabbed %u bytes&#34;, avail);</p><p>+			queue_push(&amp;nlp-&gt;rx_queue, sbcut_locked(sb, avail));</p><p>+		}</p><p>+		SOCKBUF_UNLOCK(sb);</p><p>+	} else {</p><p>+		/* Schedule another pass to read from the socket queue */</p><p>+		reschedule = true;</p><p>+	}</p><p>+</p><p>+	int prev_hiwat = nlp-&gt;tx_queue.hiwat;</p><p>+	NLP_UNLOCK(nlp);</p><p>+</p><p>+	while (!queue_empty(&amp;nlp-&gt;rx_queue)) {</p><p>+		struct mbuf *m = queue_pop(&amp;nlp-&gt;rx_queue);</p><p>+</p><p>+		m = nl_process_mbuf(m, nlp);</p><p>+		if (m != NULL) {</p><p>+			queue_push_head(&amp;nlp-&gt;rx_queue, m);</p><p>+			reschedule = false;</p><p>+			break;</p><p>+		}</p><p>+	}</p><p>+	if (nlp-&gt;tx_queue.hiwat &gt; prev_hiwat) {</p><p>+		NLP_LOG(LOG_DEBUG, nlp, &#34;TX override peaked to %d&#34;, nlp-&gt;tx_queue.hiwat);</p><p>+</p><p>+	}</p><p>+</p><p>+	return (reschedule);</p><p>+}</p><p>+</p><p>+static void</p><p>+nl_process_received(struct nlpcb *nlp)</p><p>+{</p><p>+	NL_LOG(LOG_DEBUG3, &#34;taskqueue called&#34;);</p><p>+</p><p>+	while (nl_process_received_one(nlp))</p><p>+		;</p><p>+}</p><p>+</p><p>+void</p><p>+nl_init_io(struct nlpcb *nlp)</p><p>+{</p><p>+	STAILQ_INIT(&amp;nlp-&gt;rx_queue.head);</p><p>+	STAILQ_INIT(&amp;nlp-&gt;tx_queue.head);</p><p>+}</p><p>+</p><p>+void</p><p>+nl_free_io(struct nlpcb *nlp)</p><p>+{</p><p>+	queue_free(&amp;nlp-&gt;rx_queue);</p><p>+	queue_free(&amp;nlp-&gt;tx_queue);</p><p>+}</p><p>+</p><p>+/*</p><p>+ * Called after some data have been read from the socket.</p><p>+ */</p><p>+void</p><p>+nl_on_transmit(struct nlpcb *nlp)</p><p>+{</p><p>+	NLP_LOCK(nlp);</p><p>+</p><p>+	struct socket *so = nlp-&gt;nl_socket;</p><p>+	if (__predict_false(nlp-&gt;nl_dropped_bytes &gt; 0 &amp;&amp; so != NULL)) {</p><p>+		uint64_t dropped_bytes = nlp-&gt;nl_dropped_bytes;</p><p>+		uint64_t dropped_messages = nlp-&gt;nl_dropped_messages;</p><p>+		nlp-&gt;nl_dropped_bytes = 0;</p><p>+		nlp-&gt;nl_dropped_messages = 0;</p><p>+</p><p>+		struct sockbuf *sb = &amp;so-&gt;so_rcv;</p><p>+		NLP_LOG(LOG_DEBUG, nlp,</p><p>+		    &#34;socket RX overflowed, %lu messages (%lu bytes) dropped. &#34;</p><p>+		    &#34;bytes: [%u/%u] mbufs: [%u/%u]&#34;, dropped_messages, dropped_bytes,</p><p>+		    sb-&gt;sb_ccc, sb-&gt;sb_hiwat, sb-&gt;sb_mbcnt, sb-&gt;sb_mbmax);</p><p>+		/* TODO: send netlink message */</p><p>+	}</p><p>+</p><p>+	nl_schedule_taskqueue(nlp);</p><p>+	NLP_UNLOCK(nlp);</p><p>+}</p><p>+</p><p>+void</p><p>+nl_taskqueue_handler(void *_arg, int pending)</p><p>+{</p><p>+	struct nlpcb *nlp = (struct nlpcb *)_arg;</p><p>+</p><p>+	CURVNET_SET(nlp-&gt;nl_socket-&gt;so_vnet);</p><p>+	nl_process_received(nlp);</p><p>+	CURVNET_RESTORE();</p><p>+}</p><p>+</p><p>+static __noinline void</p><p>+queue_push_tx(struct nlpcb *nlp, struct mbuf *m)</p><p>+{</p><p>+	queue_push(&amp;nlp-&gt;tx_queue, m);</p><p>+	nlp-&gt;nl_tx_blocked = true;</p><p>+</p><p>+	if (nlp-&gt;tx_queue.length &gt; nlp-&gt;tx_queue.hiwat)</p><p>+		nlp-&gt;tx_queue.hiwat = nlp-&gt;tx_queue.length;</p><p>+}</p><p>+</p><p>+/*</p><p>+ * Tries to send @m to the socket @nlp.</p><p>+ *</p><p>+ * @m: mbuf(s) to send to. Consumed in any case.</p><p>+ * @nlp: socket to send to</p><p>+ * @cnt: number of messages in @m</p><p>+ * @io_flags: combination of NL_IOF_* flags</p><p>+ *</p><p>+ * Returns true on success.</p><p>+ * If no queue overrunes happened, wakes up socket owner.</p><p>+ */</p><p>+bool</p><p>+nl_send_one(struct mbuf *m, struct nlpcb *nlp, int num_messages, int io_flags)</p><p>+{</p><p>+	bool untranslated = io_flags &amp; NL_IOF_UNTRANSLATED;</p><p>+	bool ignore_limits = io_flags &amp; NL_IOF_IGNORE_LIMIT;</p><p>+	bool result = true;</p><p>+</p><p>+	IF_DEBUG_LEVEL(LOG_DEBUG2) {</p><p>+		struct nlmsghdr *hdr = mtod(m, struct nlmsghdr *);</p><p>+		NLP_LOG(LOG_DEBUG2, nlp,</p><p>+		    &#34;TX mbuf len %u msgs %u msg type %d first hdrlen %u io_flags %X&#34;,</p><p>+		    m_length(m, NULL), num_messages, hdr-&gt;nlmsg_type, hdr-&gt;nlmsg_len,</p><p>+		    io_flags);</p><p>+	}</p><p>+</p><p>+	if (__predict_false(nlp-&gt;nl_linux &amp;&amp; linux_netlink_p != NULL &amp;&amp; untranslated)) {</p><p>+		m = linux_netlink_p-&gt;mbufs_to_linux(nlp-&gt;nl_proto, m, nlp);</p><p>+		if (m == NULL)</p><p>+			return (false);</p><p>+	}</p><p>+</p><p>+	NLP_LOCK(nlp);</p><p>+</p><p>+	if (__predict_false(nlp-&gt;nl_socket == NULL)) {</p><p>+		NLP_UNLOCK(nlp);</p><p>+		m_freem(m);</p><p>+		return (false);</p><p>+	}</p><p>+</p><p>+	if (!queue_empty(&amp;nlp-&gt;tx_queue)) {</p><p>+		if (ignore_limits) {</p><p>+			queue_push_tx(nlp, m);</p><p>+		} else {</p><p>+			m_free(m);</p><p>+			result = false;</p><p>+		}</p><p>+		NLP_UNLOCK(nlp);</p><p>+		return (result);</p><p>+	}</p><p>+</p><p>+	struct socket *so = nlp-&gt;nl_socket;</p><p>+	if (sbappendaddr(&amp;so-&gt;so_rcv, nl_empty_src, m, NULL) != 0) {</p><p>+		sorwakeup(so);</p><p>+		NLP_LOG(LOG_DEBUG3, nlp, &#34;appended data &amp; woken up&#34;);</p><p>+	} else {</p><p>+		if (ignore_limits) {</p><p>+			queue_push_tx(nlp, m);</p><p>+		} else {</p><p>+			/*</p><p>+			 * Store dropped data so it can be reported</p><p>+			 * on the next read</p><p>+			 */</p><p>+			nlp-&gt;nl_dropped_bytes += m_length(m, NULL);</p><p>+			nlp-&gt;nl_dropped_messages += num_messages;</p><p>+			NLP_LOG(LOG_DEBUG2, nlp, &#34;RX oveflow: %lu m (+%d), %lu b (+%d)&#34;,</p><p>+			    nlp-&gt;nl_dropped_messages, num_messages,</p><p>+			    nlp-&gt;nl_dropped_bytes, m_length(m, NULL));</p><p>+			soroverflow(so);</p><p>+			m_freem(m);</p><p>+			result = false;</p><p>+		}</p><p>+	}</p><p>+	NLP_UNLOCK(nlp);</p><p>+</p><p>+	return (result);</p><p>+}</p><p>+</p><p>+static int</p><p>+nl_receive_message(struct nlmsghdr *hdr, int remaining_length,</p><p>+    struct nlpcb *nlp, struct nl_pstate *npt)</p><p>+{</p><p>+	nl_handler_f handler = nl_handlers[nlp-&gt;nl_proto].cb;</p><p>+	int error = 0;</p><p>+</p><p>+	NL_LOG(LOG_DEBUG2, &#34;msg len: %d type: %d&#34;, hdr-&gt;nlmsg_len,</p><p>+	    hdr-&gt;nlmsg_type);</p><p>+</p><p>+	if (__predict_false(hdr-&gt;nlmsg_len &gt; remaining_length)) {</p><p>+		NLP_LOG(LOG_DEBUG, nlp, &#34;message is not entirely present: want %d got %d&#34;,</p><p>+		    hdr-&gt;nlmsg_len, remaining_length);</p><p>+		return (EINVAL);</p><p>+	} else if (__predict_false(hdr-&gt;nlmsg_len &lt; sizeof(*hdr))) {</p><p>+		NL_LOG(LOG_DEBUG, &#34;message too short: %d&#34;, hdr-&gt;nlmsg_len);</p><p>+		return (EINVAL);</p><p>+	}</p><p>+	/* Stamp each message with sender pid */</p><p>+	hdr-&gt;nlmsg_pid = nlp-&gt;nl_port;</p><p>+</p><p>+	npt-&gt;hdr = hdr;</p><p>+</p><p>+	if (hdr-&gt;nlmsg_flags &amp; NLM_F_REQUEST &amp;&amp; hdr-&gt;nlmsg_type &gt;= NLMSG_MIN_TYPE) {</p><p>+		NL_LOG(LOG_DEBUG2, &#34;handling message with msg type: %d&#34;,</p><p>+		   hdr-&gt;nlmsg_type);</p><p>+</p><p>+		if (nlp-&gt;nl_linux &amp;&amp; linux_netlink_p != NULL) {</p><p>+			struct nlmsghdr *hdr_orig = hdr;</p><p>+			hdr = linux_netlink_p-&gt;msg_from_linux(nlp-&gt;nl_proto, hdr, npt);</p><p>+			if (hdr == NULL) {</p><p>+				npt-&gt;hdr = hdr_orig;</p><p>+				if (hdr-&gt;nlmsg_flags &amp; NLM_F_ACK)</p><p>+					nlmsg_ack(nlp, EAGAIN, hdr, npt);</p><p>+				return (0);</p><p>+			}</p><p>+		}</p><p>+		error = handler(hdr, npt);</p><p>+		NL_LOG(LOG_DEBUG2, &#34;retcode: %d&#34;, error);</p><p>+	}</p><p>+	if ((hdr-&gt;nlmsg_flags &amp; NLM_F_ACK) || (error != 0 &amp;&amp; error != EINTR)) {</p><p>+		NL_LOG(LOG_DEBUG3, &#34;ack&#34;);</p><p>+		nlmsg_ack(nlp, error, hdr, npt);</p><p>+		NL_LOG(LOG_DEBUG3, &#34;done&#34;);</p><p>+	}</p><p>+</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+static void</p><p>+npt_clear(struct nl_pstate *npt)</p><p>+{</p><p>+	lb_clear(&amp;npt-&gt;lb);</p><p>+	npt-&gt;error = 0;</p><p>+	npt-&gt;err_msg = NULL;</p><p>+	npt-&gt;err_off = 0;</p><p>+	npt-&gt;hdr = NULL;</p><p>+}</p><p>+</p><p>+/*</p><p>+ * Processes an incoming packet, which can contain multiple netlink messages</p><p>+ */</p><p>+static struct mbuf *</p><p>+nl_process_mbuf(struct mbuf *m, struct nlpcb *nlp)</p><p>+{</p><p>+	int offset, buffer_length;</p><p>+	struct nlmsghdr *hdr;</p><p>+	char *buffer;</p><p>+	int error;</p><p>+</p><p>+	NL_LOG(LOG_DEBUG3, &#34;RX netlink mbuf %p on %p&#34;, m, nlp-&gt;nl_socket);</p><p>+</p><p>+	struct nl_writer nw = {};</p><p>+	if (!nlmsg_get_unicast_writer(&amp;nw, NLMSG_SMALL, nlp)) {</p><p>+		m_freem(m);</p><p>+		NL_LOG(LOG_DEBUG, &#34;error allocating socket writer&#34;);</p><p>+		return (NULL);</p><p>+	}</p><p>+</p><p>+	nlmsg_ignore_limit(&amp;nw);</p><p>+	/* TODO: alloc this buf once for nlp */</p><p>+	int data_length = m_length(m, NULL);</p><p>+	buffer_length = roundup2(data_length, 8) + SCRATCH_BUFFER_SIZE;</p><p>+	if (nlp-&gt;nl_linux)</p><p>+		buffer_length += roundup2(data_length, 8);</p><p>+	buffer = malloc(buffer_length, M_NETLINK, M_NOWAIT | M_ZERO);</p><p>+	if (buffer == NULL) {</p><p>+		m_freem(m);</p><p>+		nlmsg_flush(&amp;nw);</p><p>+		NL_LOG(LOG_DEBUG, &#34;Unable to allocate %d bytes of memory&#34;,</p><p>+		    buffer_length);</p><p>+		return (NULL);</p><p>+	}</p><p>+	m_copydata(m, 0, data_length, buffer);</p><p>+</p><p>+	struct nl_pstate npt = {</p><p>+		.nlp = nlp,</p><p>+		.lb.base = &amp;buffer[roundup2(data_length, 8)],</p><p>+		.lb.size = buffer_length - roundup2(data_length, 8),</p><p>+		.nw = &amp;nw,</p><p>+		.strict = nlp-&gt;nl_flags &amp; NLF_STRICT,</p><p>+	};</p><p>+</p><p>+	for (offset = 0; offset + sizeof(struct nlmsghdr) &lt;= data_length;) {</p><p>+		hdr = (struct nlmsghdr *)&amp;buffer[offset];</p><p>+		/* Save length prior to calling handler */</p><p>+		int msglen = NLMSG_ALIGN(hdr-&gt;nlmsg_len);</p><p>+		NL_LOG(LOG_DEBUG3, &#34;parsing offset %d/%d&#34;, offset, data_length);</p><p>+		npt_clear(&amp;npt);</p><p>+		error = nl_receive_message(hdr, data_length - offset, nlp, &amp;npt);</p><p>+		offset += msglen;</p><p>+		if (__predict_false(error != 0 || nlp-&gt;nl_tx_blocked))</p><p>+			break;</p><p>+	}</p><p>+	NL_LOG(LOG_DEBUG3, &#34;packet parsing done&#34;);</p><p>+	free(buffer, M_NETLINK);</p><p>+	nlmsg_flush(&amp;nw);</p><p>+</p><p>+	if (nlp-&gt;nl_tx_blocked) {</p><p>+		NLP_LOCK(nlp);</p><p>+		nlp-&gt;nl_tx_blocked = false;</p><p>+		NLP_UNLOCK(nlp);</p><p>+		m_adj(m, offset);</p><p>+		return (m);</p><p>+	} else {</p><p>+		m_freem(m);</p><p>+		return (NULL);</p><p>+	}</p><p>+}</p><div><p>diff --git a/sys/netlink/netlink_linux.h b/sys/netlink/netlink_linux.h</p></div><p>@@ -0,0 +1,54 @@</p><p>+/*-</p><p>+ * SPDX-License-Identifier: BSD-2-Clause-FreeBSD</p><p>+ *</p><p>+ * Copyright (c) 2022 Alexander V. Chernikov &lt;melifaro@FreeBSD.org&gt;</p><p>+ *</p><p>+ * Redistribution and use in source and binary forms, with or without</p><p>+ * modification, are permitted provided that the following conditions</p><p>+ * are met:</p><p>+ * 1. Redistributions of source code must retain the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer.</p><p>+ * 2. Redistributions in binary form must reproduce the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer in the</p><p>+ *    documentation and/or other materials provided with the distribution.</p><p>+ *</p><p>+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&#39;&#39; AND</p><p>+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</p><p>+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</p><p>+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE</p><p>+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</p><p>+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</p><p>+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</p><p>+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</p><p>+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</p><p>+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</p><p>+ * SUCH DAMAGE.</p><p>+ */</p><p>+</p><p>+#ifndef _NETLINK_LINUX_VAR_H_</p><p>+#define _NETLINK_LINUX_VAR_H_</p><p>+</p><p>+/*</p><p>+ * The file contains headers for the bridge interface between</p><p>+ * linux[_common] module and the netlink module</p><p>+ */</p><p>+struct nlpcb;</p><p>+struct nl_pstate;</p><p>+</p><p>+typedef struct mbuf *mbufs_to_linux_cb_t(int netlink_family, struct mbuf *m,</p><p>+    struct nlpcb *nlp);</p><p>+typedef struct mbuf *msgs_to_linux_cb_t(int netlink_family, char *buf, int data_length,</p><p>+    struct nlpcb *nlp);</p><p>+typedef struct nlmsghdr *msg_from_linux_cb_t(int netlink_family, struct nlmsghdr *hdr,</p><p>+    struct nl_pstate *npt);</p><p>+</p><p>+struct linux_netlink_provider {</p><p>+	mbufs_to_linux_cb_t	*mbufs_to_linux;</p><p>+	msgs_to_linux_cb_t	*msgs_to_linux;</p><p>+	msg_from_linux_cb_t	*msg_from_linux;</p><p>+</p><p>+};</p><p>+</p><p>+extern struct linux_netlink_provider *linux_netlink_p;</p><p>+</p><p>+#endif</p><div><p>diff --git a/sys/netlink/netlink_message_parser.c b/sys/netlink/netlink_message_parser.c</p></div><p>@@ -0,0 +1,472 @@</p><p>+/*-</p><p>+ * SPDX-License-Identifier: BSD-2-Clause-FreeBSD</p><p>+ *</p><p>+ * Copyright (c) 2022 Alexander V. Chernikov &lt;melifaro@FreeBSD.org&gt;</p><p>+ *</p><p>+ * Redistribution and use in source and binary forms, with or without</p><p>+ * modification, are permitted provided that the following conditions</p><p>+ * are met:</p><p>+ * 1. Redistributions of source code must retain the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer.</p><p>+ * 2. Redistributions in binary form must reproduce the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer in the</p><p>+ *    documentation and/or other materials provided with the distribution.</p><p>+ *</p><p>+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&#39;&#39; AND</p><p>+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</p><p>+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</p><p>+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE</p><p>+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</p><p>+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</p><p>+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</p><p>+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</p><p>+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</p><p>+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</p><p>+ * SUCH DAMAGE.</p><p>+ */</p><p>+</p><p>+#include &lt;sys/cdefs.h&gt;</p><p>+__FBSDID(&#34;$FreeBSD$&#34;);</p><p>+#include &#34;opt_inet.h&#34;</p><p>+#include &#34;opt_inet6.h&#34;</p><p>+#include &lt;sys/types.h&gt;</p><p>+#include &lt;sys/malloc.h&gt;</p><p>+#include &lt;sys/rmlock.h&gt;</p><p>+#include &lt;sys/socket.h&gt;</p><p>+</p><p>+#include &lt;machine/stdarg.h&gt;</p><p>+</p><p>+#include &lt;net/if.h&gt;</p><p>+#include &lt;net/route.h&gt;</p><p>+#include &lt;net/route/nhop.h&gt;</p><p>+</p><p>+#include &lt;net/route/route_ctl.h&gt;</p><p>+#include &lt;netlink/netlink.h&gt;</p><p>+#include &lt;netlink/netlink_ctl.h&gt;</p><p>+#include &lt;netlink/netlink_var.h&gt;</p><p>+#include &lt;netlink/netlink_route.h&gt;</p><p>+</p><p>+#define	DEBUG_MOD_NAME	nl_parser</p><p>+#define	DEBUG_MAX_LEVEL	LOG_DEBUG3</p><p>+#include &lt;netlink/netlink_debug.h&gt;</p><p>+_DECLARE_DEBUG(LOG_DEBUG);</p><p>+</p><p>+bool</p><p>+nlmsg_report_err_msg(struct nl_pstate *npt, const char *fmt, ...)</p><p>+{</p><p>+	va_list ap;</p><p>+</p><p>+	if (npt-&gt;err_msg != NULL)</p><p>+		return (false);</p><p>+	char *buf = npt_alloc(npt, NL_MAX_ERROR_BUF);</p><p>+	if (buf == NULL)</p><p>+		return (false);</p><p>+	va_start(ap, fmt);</p><p>+	vsnprintf(buf, NL_MAX_ERROR_BUF, fmt, ap);</p><p>+	va_end(ap);</p><p>+</p><p>+	npt-&gt;err_msg = buf;</p><p>+	return (true);</p><p>+}</p><p>+</p><p>+bool</p><p>+nlmsg_report_err_offset(struct nl_pstate *npt, uint32_t off)</p><p>+{</p><p>+	if (npt-&gt;err_off != 0)</p><p>+		return (false);</p><p>+	npt-&gt;err_off = off;</p><p>+	return (true);</p><p>+}</p><p>+</p><p>+static const struct nlattr_parser *</p><p>+search_states(const struct nlattr_parser *ps, int pslen, int key)</p><p>+{</p><p>+	int left_i = 0, right_i = pslen - 1;</p><p>+</p><p>+	if (key &lt; ps[0].type || key &gt; ps[pslen - 1].type)</p><p>+		return (NULL);</p><p>+</p><p>+	while (left_i + 1 &lt; right_i) {</p><p>+		int mid_i = (left_i + right_i) / 2;</p><p>+		if (key &lt; ps[mid_i].type)</p><p>+			right_i = mid_i;</p><p>+		else if (key &gt; ps[mid_i].type)</p><p>+			left_i = mid_i + 1;</p><p>+		else</p><p>+			return (&amp;ps[mid_i]);</p><p>+	}</p><p>+	if (ps[left_i].type == key)</p><p>+		return (&amp;ps[left_i]);</p><p>+	else if (ps[right_i].type == key)</p><p>+		return (&amp;ps[right_i]);</p><p>+	return (NULL);</p><p>+}</p><p>+</p><p>+int</p><p>+nl_parse_attrs_raw(struct nlattr *nla_head, int len, const struct nlattr_parser *ps, int pslen,</p><p>+    struct nl_pstate *npt, void *target)</p><p>+{</p><p>+	struct nlattr *nla = NULL;</p><p>+	int error = 0;</p><p>+</p><p>+	NL_LOG(LOG_DEBUG3, &#34;parse %p remaining_len %d&#34;, nla_head, len);</p><p>+	int orig_len = len;</p><p>+	NLA_FOREACH(nla, nla_head, len) {</p><p>+		NL_LOG(LOG_DEBUG3, &#34;&gt;&gt; parsing %p attr_type %d len %d (rem %d)&#34;, nla, nla-&gt;nla_type, nla-&gt;nla_len, len);</p><p>+		if (nla-&gt;nla_len &lt; sizeof(struct nlattr)) {</p><p>+			NLMSG_REPORT_ERR_MSG(npt, &#34;Invalid attr %p type %d len: %d&#34;,</p><p>+			    nla, nla-&gt;nla_type, nla-&gt;nla_len);</p><p>+			uint32_t off = (char *)nla - (char *)npt-&gt;hdr;</p><p>+			nlmsg_report_err_offset(npt, off);</p><p>+			return (EINVAL);</p><p>+		}</p><p>+</p><p>+		int nla_type = nla-&gt;nla_type &amp; NLA_TYPE_MASK;</p><p>+		const struct nlattr_parser *s = search_states(ps, pslen, nla_type);</p><p>+		if (s != NULL) {</p><p>+			void *ptr = (void *)((char *)target + s-&gt;off);</p><p>+			error = s-&gt;cb(nla, npt, s-&gt;arg, ptr);</p><p>+			if (error != 0) {</p><p>+				uint32_t off = (char *)nla - (char *)npt-&gt;hdr;</p><p>+				nlmsg_report_err_offset(npt, off);</p><p>+				NL_LOG(LOG_DEBUG3, &#34;parse failed att offset %u&#34;, off);</p><p>+				return (error);</p><p>+			}</p><p>+		} else {</p><p>+			/* Ignore non-specified attributes */</p><p>+			NL_LOG(LOG_DEBUG3, &#34;ignoring attr %d&#34;, nla-&gt;nla_type);</p><p>+		}</p><p>+	}</p><p>+	if (len &gt;= sizeof(struct nlattr)) {</p><p>+		nla = (struct nlattr *)((char *)nla_head + (orig_len - len));</p><p>+		NL_LOG(LOG_DEBUG3, &#34; &gt;&gt;&gt; end %p attr_type %d len %d&#34;, nla,</p><p>+		    nla-&gt;nla_type, nla-&gt;nla_len);</p><p>+	}</p><p>+	NL_LOG(LOG_DEBUG3, &#34;end parse: %p remaining_len %d&#34;, nla, len);</p><p>+</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+int</p><p>+nl_parse_attrs(struct nlmsghdr *hdr, int hdrlen, struct nlattr_parser *ps, int pslen,</p><p>+    struct nl_pstate *npt, void *target)</p><p>+{</p><p>+	int off = NLMSG_HDRLEN + NETLINK_ALIGN(hdrlen);</p><p>+	int len = hdr-&gt;nlmsg_len - off;</p><p>+	struct nlattr *nla_head = (struct nlattr *)((char *)hdr + off);</p><p>+</p><p>+	return (nl_parse_attrs_raw(nla_head, len, ps, pslen, npt, target));</p><p>+}</p><p>+</p><p>+int</p><p>+nlattr_get_flag(struct nlattr *nla, struct nl_pstate *npt, const void *arg, void *target)</p><p>+{</p><p>+	if (__predict_false(NLA_DATA_LEN(nla) != 0)) {</p><p>+		NLMSG_REPORT_ERR_MSG(npt, &#34;nla type %d size(%u) is not a flag&#34;,</p><p>+		    nla-&gt;nla_type, NLA_DATA_LEN(nla));</p><p>+		return (EINVAL);</p><p>+	}</p><p>+</p><p>+	*((uint8_t *)target) = 1;</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+static struct sockaddr *</p><p>+parse_rta_ip4(void *rta_data, struct nl_pstate *npt, int *perror)</p><p>+{</p><p>+	struct sockaddr_in *sin;</p><p>+</p><p>+	sin = (struct sockaddr_in *)npt_alloc_sockaddr(npt, sizeof(struct sockaddr_in));</p><p>+	if (__predict_false(sin == NULL)) {</p><p>+		*perror = ENOBUFS;</p><p>+		return (NULL);</p><p>+	}</p><p>+	sin-&gt;sin_len = sizeof(struct sockaddr_in);</p><p>+	sin-&gt;sin_family = AF_INET;</p><p>+	memcpy(&amp;sin-&gt;sin_addr, rta_data, sizeof(struct in_addr));</p><p>+	return ((struct sockaddr *)sin);</p><p>+}</p><p>+</p><p>+static struct sockaddr *</p><p>+parse_rta_ip6(void *rta_data, struct nl_pstate *npt, int *perror)</p><p>+{</p><p>+	struct sockaddr_in6 *sin6;</p><p>+</p><p>+	sin6 = (struct sockaddr_in6 *)npt_alloc_sockaddr(npt, sizeof(struct sockaddr_in6));</p><p>+	if (__predict_false(sin6 == NULL)) {</p><p>+		*perror = ENOBUFS;</p><p>+		return (NULL);</p><p>+	}</p><p>+	sin6-&gt;sin6_len = sizeof(struct sockaddr_in6);</p><p>+	sin6-&gt;sin6_family = AF_INET6;</p><p>+	memcpy(&amp;sin6-&gt;sin6_addr, rta_data, sizeof(struct in6_addr));</p><p>+	return ((struct sockaddr *)sin6);</p><p>+}</p><p>+</p><p>+static struct sockaddr *</p><p>+parse_rta_ip(struct rtattr *rta, struct nl_pstate *npt, int *perror)</p><p>+{</p><p>+	void *rta_data = NL_RTA_DATA(rta);</p><p>+	int rta_len = NL_RTA_DATA_LEN(rta);</p><p>+</p><p>+	if (rta_len == sizeof(struct in_addr)) {</p><p>+		return (parse_rta_ip4(rta_data, npt, perror));</p><p>+	} else if (rta_len == sizeof(struct in6_addr)) {</p><p>+		return (parse_rta_ip6(rta_data, npt, perror));</p><p>+	} else {</p><p>+		NLMSG_REPORT_ERR_MSG(npt, &#34;unknown IP len: %d for rta type %d&#34;,</p><p>+		    rta_len, rta-&gt;rta_type);</p><p>+		*perror = ENOTSUP;</p><p>+		return (NULL);</p><p>+	}</p><p>+	return (NULL);</p><p>+}</p><p>+</p><p>+int</p><p>+nlattr_get_ip(struct nlattr *nla, struct nl_pstate *npt, const void *arg, void *target)</p><p>+{</p><p>+	int error = 0;</p><p>+</p><p>+	struct sockaddr *sa = parse_rta_ip((struct rtattr *)nla, npt, &amp;error);</p><p>+</p><p>+	*((struct sockaddr **)target) = sa;</p><p>+	return (error);</p><p>+}</p><p>+</p><p>+static struct sockaddr *</p><p>+parse_rta_via(struct rtattr *rta, struct nl_pstate *npt, int *perror)</p><p>+{</p><p>+	struct rtvia *via = NL_RTA_DATA(rta);</p><p>+	int data_len = NL_RTA_DATA_LEN(rta);</p><p>+</p><p>+	if (__predict_false(data_len) &lt; sizeof(struct rtvia)) {</p><p>+		NLMSG_REPORT_ERR_MSG(npt, &#34;undersized RTA_VIA(%d) attr: len %d&#34;,</p><p>+		    rta-&gt;rta_type, data_len);</p><p>+		*perror = EINVAL;</p><p>+		return (NULL);</p><p>+	}</p><p>+	data_len -= offsetof(struct rtvia, rtvia_addr);</p><p>+</p><p>+	switch (via-&gt;rtvia_family) {</p><p>+	case AF_INET:</p><p>+		if (__predict_false(data_len &lt; sizeof(struct in_addr))) {</p><p>+			*perror = EINVAL;</p><p>+			return (NULL);</p><p>+		}</p><p>+		return (parse_rta_ip4(via-&gt;rtvia_addr, npt, perror));</p><p>+	case AF_INET6:</p><p>+		if (__predict_false(data_len &lt; sizeof(struct in6_addr))) {</p><p>+			*perror = EINVAL;</p><p>+			return (NULL);</p><p>+		}</p><p>+		return (parse_rta_ip6(via-&gt;rtvia_addr, npt, perror));</p><p>+	default:</p><p>+		*perror = ENOTSUP;</p><p>+		return (NULL);</p><p>+	}</p><p>+}</p><p>+</p><p>+int</p><p>+nlattr_get_ipvia(struct nlattr *nla, struct nl_pstate *npt, const void *arg, void *target)</p><p>+{</p><p>+	int error = 0;</p><p>+</p><p>+	struct sockaddr *sa = parse_rta_via((struct rtattr *)nla, npt, &amp;error);</p><p>+</p><p>+	*((struct sockaddr **)target) = sa;</p><p>+	return (error);</p><p>+}</p><p>+</p><p>+</p><p>+int</p><p>+nlattr_get_uint16(struct nlattr *nla, struct nl_pstate *npt, const void *arg, void *target)</p><p>+{</p><p>+	if (__predict_false(NLA_DATA_LEN(nla) != sizeof(uint16_t))) {</p><p>+		NLMSG_REPORT_ERR_MSG(npt, &#34;nla type %d size(%u) is not uint32&#34;,</p><p>+		    nla-&gt;nla_type, NLA_DATA_LEN(nla));</p><p>+		return (EINVAL);</p><p>+	}</p><p>+	*((uint16_t *)target) = *((const uint16_t *)NL_RTA_DATA_CONST(nla));</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+int</p><p>+nlattr_get_uint32(struct nlattr *nla, struct nl_pstate *npt, const void *arg, void *target)</p><p>+{</p><p>+	if (__predict_false(NLA_DATA_LEN(nla) != sizeof(uint32_t))) {</p><p>+		NLMSG_REPORT_ERR_MSG(npt, &#34;nla type %d size(%u) is not uint32&#34;,</p><p>+		    nla-&gt;nla_type, NLA_DATA_LEN(nla));</p><p>+		return (EINVAL);</p><p>+	}</p><p>+	*((uint32_t *)target) = *((const uint32_t *)NL_RTA_DATA_CONST(nla));</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+int</p><p>+nlattr_get_uint64(struct nlattr *nla, struct nl_pstate *npt, const void *arg, void *target)</p><p>+{</p><p>+	if (__predict_false(NLA_DATA_LEN(nla) != sizeof(uint64_t))) {</p><p>+		NLMSG_REPORT_ERR_MSG(npt, &#34;nla type %d size(%u) is not uint64&#34;,</p><p>+		    nla-&gt;nla_type, NLA_DATA_LEN(nla));</p><p>+		return (EINVAL);</p><p>+	}</p><p>+	memcpy(target, NL_RTA_DATA_CONST(nla), sizeof(uint64_t));</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+static int</p><p>+nlattr_get_ifp_internal(struct nlattr *nla, struct nl_pstate *npt,</p><p>+    void *target, bool zero_ok)</p><p>+{</p><p>+	if (__predict_false(NLA_DATA_LEN(nla) != sizeof(uint32_t))) {</p><p>+		NLMSG_REPORT_ERR_MSG(npt, &#34;nla type %d size(%u) is not uint32&#34;,</p><p>+		    nla-&gt;nla_type, NLA_DATA_LEN(nla));</p><p>+		return (EINVAL);</p><p>+	}</p><p>+	uint32_t ifindex = *((const uint32_t *)NLA_DATA_CONST(nla));</p><p>+</p><p>+	if (ifindex == 0 &amp;&amp; zero_ok) {</p><p>+		*((struct ifnet **)target) = NULL;</p><p>+		return (0);</p><p>+	}</p><p>+</p><p>+	NET_EPOCH_ASSERT();</p><p>+</p><p>+	struct ifnet *ifp = ifnet_byindex(ifindex);</p><p>+	if (__predict_false(ifp == NULL)) {</p><p>+		NLMSG_REPORT_ERR_MSG(npt, &#34;nla type %d: ifindex %u invalid&#34;,</p><p>+		    nla-&gt;nla_type, ifindex);</p><p>+		return (ENOENT);</p><p>+	}</p><p>+	*((struct ifnet **)target) = ifp;</p><p>+	NL_LOG(LOG_DEBUG3, &#34;nla type %d: ifindex %u -&gt; %s&#34;, nla-&gt;nla_type,</p><p>+	    ifindex, if_name(ifp));</p><p>+</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+int</p><p>+nlattr_get_ifp(struct nlattr *nla, struct nl_pstate *npt, const void *arg, void *target)</p><p>+{</p><p>+	return (nlattr_get_ifp_internal(nla, npt, target, false));</p><p>+}</p><p>+</p><p>+int</p><p>+nlattr_get_ifpz(struct nlattr *nla, struct nl_pstate *npt, const void *arg, void *target)</p><p>+{</p><p>+	return (nlattr_get_ifp_internal(nla, npt, target, true));</p><p>+}</p><p>+</p><p>+int</p><p>+nlattr_get_string(struct nlattr *nla, struct nl_pstate *npt, const void *arg, void *target)</p><p>+{</p><p>+	int maxlen = NLA_DATA_LEN(nla);</p><p>+</p><p>+	if (__predict_false(strnlen((char *)NLA_DATA(nla), maxlen) &gt;= maxlen)) {</p><p>+		NLMSG_REPORT_ERR_MSG(npt, &#34;nla type %d size(%u) is not NULL-terminated&#34;,</p><p>+		    nla-&gt;nla_type, maxlen);</p><p>+		return (EINVAL);</p><p>+	}</p><p>+</p><p>+	*((char **)target) = (char *)NLA_DATA(nla);</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+int</p><p>+nlattr_get_stringn(struct nlattr *nla, struct nl_pstate *npt, const void *arg, void *target)</p><p>+{</p><p>+	int maxlen = NLA_DATA_LEN(nla);</p><p>+</p><p>+	char *buf = npt_alloc(npt, maxlen + 1);</p><p>+	if (buf == NULL)</p><p>+		return (ENOMEM);</p><p>+	buf[maxlen] = &#39;\0&#39;;</p><p>+	memcpy(buf, NLA_DATA(nla), maxlen);</p><p>+</p><p>+	*((char **)target) = buf;</p><p>+	return (0);</p><p>+}</p><p>+int</p><p>+nlattr_get_nla(struct nlattr *nla, struct nl_pstate *npt, const void *arg, void *target)</p><p>+{</p><p>+	NL_LOG(LOG_DEBUG3, &#34;STORING %p len %d&#34;, nla, nla-&gt;nla_len);</p><p>+	*((struct nlattr **)target) = nla;</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+int</p><p>+nlattr_get_nested(struct nlattr *nla, struct nl_pstate *npt, const void *arg, void *target)</p><p>+{</p><p>+	const struct nlhdr_parser *p = (const struct nlhdr_parser *)arg;</p><p>+	int error;</p><p>+</p><p>+	/* Assumes target points to the beginning of the structure */</p><p>+	error = nl_parse_header(NLA_DATA(nla), NLA_DATA_LEN(nla), p, npt, target);</p><p>+	return (error);</p><p>+}</p><p>+</p><p>+int</p><p>+nlf_get_ifp(void *src, struct nl_pstate *npt, void *target)</p><p>+{</p><p>+	int ifindex = *((const int *)src);</p><p>+</p><p>+	NET_EPOCH_ASSERT();</p><p>+</p><p>+	struct ifnet *ifp = ifnet_byindex(ifindex);</p><p>+	if (ifp == NULL) {</p><p>+		NL_LOG(LOG_DEBUG, &#34;ifindex %u invalid&#34;, ifindex);</p><p>+		return (ENOENT);</p><p>+	}</p><p>+	*((struct ifnet **)target) = ifp;</p><p>+</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+int</p><p>+nlf_get_ifpz(void *src, struct nl_pstate *npt, void *target)</p><p>+{</p><p>+	int ifindex = *((const int *)src);</p><p>+</p><p>+	NET_EPOCH_ASSERT();</p><p>+</p><p>+	struct ifnet *ifp = ifnet_byindex(ifindex);</p><p>+	if (ifindex != 0 &amp;&amp; ifp == NULL) {</p><p>+		NL_LOG(LOG_DEBUG, &#34;ifindex %u invalid&#34;, ifindex);</p><p>+		return (ENOENT);</p><p>+	}</p><p>+	*((struct ifnet **)target) = ifp;</p><p>+</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+int</p><p>+nlf_get_u8(void *src, struct nl_pstate *npt, void *target)</p><p>+{</p><p>+	uint8_t val = *((const uint8_t *)src);</p><p>+</p><p>+	*((uint8_t *)target) = val;</p><p>+</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+int</p><p>+nlf_get_u8_u32(void *src, struct nl_pstate *npt, void *target)</p><p>+{</p><p>+	*((uint32_t *)target) = *((const uint8_t *)src);</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+int</p><p>+nlf_get_u16(void *src, struct nl_pstate *npt, void *target)</p><p>+{</p><p>+	*((uint16_t *)target) = *((const uint16_t *)src);</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+int</p><p>+nlf_get_u32(void *src, struct nl_pstate *npt, void *target)</p><p>+{</p><p>+	*((uint32_t *)target) = *((const uint32_t *)src);</p><p>+	return (0);</p><p>+}</p><p>+</p><div><p>diff --git a/sys/netlink/netlink_message_parser.h b/sys/netlink/netlink_message_parser.h</p></div><p>@@ -0,0 +1,270 @@</p><p>+/*-</p><p>+ * SPDX-License-Identifier: BSD-2-Clause-FreeBSD</p><p>+ *</p><p>+ * Copyright (c) 2022 Alexander V. Chernikov &lt;melifaro@FreeBSD.org&gt;</p><p>+ *</p><p>+ * Redistribution and use in source and binary forms, with or without</p><p>+ * modification, are permitted provided that the following conditions</p><p>+ * are met:</p><p>+ * 1. Redistributions of source code must retain the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer.</p><p>+ * 2. Redistributions in binary form must reproduce the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer in the</p><p>+ *    documentation and/or other materials provided with the distribution.</p><p>+ *</p><p>+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&#39;&#39; AND</p><p>+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</p><p>+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</p><p>+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE</p><p>+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</p><p>+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</p><p>+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</p><p>+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</p><p>+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</p><p>+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</p><p>+ * SUCH DAMAGE.</p><p>+ */</p><p>+</p><p>+#ifndef _NETLINK_NETLINK_MESSAGE_PARSER_H_</p><p>+#define _NETLINK_NETLINK_MESSAGE_PARSER_H_</p><p>+</p><p>+/*</p><p>+ * It is not meant to be included directly</p><p>+ */</p><p>+</p><p>+/* Parsing state */</p><p>+struct linear_buffer {</p><p>+	char		*base;	/* Base allocated memory pointer */</p><p>+	uint32_t	offset;	/* Currently used offset */</p><p>+	uint32_t	size;	/* Total buffer size */</p><p>+};</p><p>+</p><p>+static inline void *</p><p>+lb_alloc(struct linear_buffer *lb, int len)</p><p>+{</p><p>+	len = roundup2(len, sizeof(uint64_t));</p><p>+	if (lb-&gt;offset + len &gt; lb-&gt;size)</p><p>+		return (NULL);</p><p>+	void *data = (void *)(lb-&gt;base + lb-&gt;offset);</p><p>+	lb-&gt;offset += len;</p><p>+	return (data);</p><p>+}</p><p>+</p><p>+static inline void</p><p>+lb_clear(struct linear_buffer *lb)</p><p>+{</p><p>+	memset(lb-&gt;base, 0, lb-&gt;size);</p><p>+	lb-&gt;offset = 0;</p><p>+}</p><p>+</p><p>+#define	NL_MAX_ERROR_BUF	128</p><p>+#define	SCRATCH_BUFFER_SIZE	(1024 + NL_MAX_ERROR_BUF)</p><p>+struct nl_pstate {</p><p>+        struct linear_buffer    lb;		/* Per-message scratch buffer */</p><p>+        struct nlpcb		*nlp;		/* Originator socket */</p><p>+	struct nl_writer	*nw;		/* Message writer to use */</p><p>+	struct nlmsghdr		*hdr;		/* Current parsed message header */</p><p>+	uint32_t		err_off;	/* error offset from hdr start */</p><p>+        int			error;		/* last operation error */</p><p>+	char			*err_msg;	/* Description of last error */</p><p>+	bool			strict;		/* Strict parsing required */</p><p>+};</p><p>+</p><p>+static inline void *</p><p>+npt_alloc(struct nl_pstate *npt, int len)</p><p>+{</p><p>+	return (lb_alloc(&amp;npt-&gt;lb, len));</p><p>+}</p><p>+#define npt_alloc_sockaddr(_npt, _len)  ((struct sockaddr *)(npt_alloc(_npt, _len)))</p><p>+</p><p>+typedef int parse_field_f(void *hdr, struct nl_pstate *npt,</p><p>+    void *target);</p><p>+struct nlfield_parser {</p><p>+	uint16_t	off_in;</p><p>+	uint16_t	off_out;</p><p>+	parse_field_f	*cb;</p><p>+};</p><p>+static const struct nlfield_parser nlf_p_empty[] = {};</p><p>+</p><p>+int nlf_get_ifp(void *src, struct nl_pstate *npt, void *target);</p><p>+int nlf_get_ifpz(void *src, struct nl_pstate *npt, void *target);</p><p>+int nlf_get_u8(void *src, struct nl_pstate *npt, void *target);</p><p>+int nlf_get_u16(void *src, struct nl_pstate *npt, void *target);</p><p>+int nlf_get_u32(void *src, struct nl_pstate *npt, void *target);</p><p>+int nlf_get_u8_u32(void *src, struct nl_pstate *npt, void *target);</p><p>+</p><p>+</p><p>+struct nlattr_parser;</p><p>+typedef int parse_attr_f(struct nlattr *attr, struct nl_pstate *npt,</p><p>+    const void *arg, void *target);</p><p>+struct nlattr_parser {</p><p>+	uint16_t			type;	/* Attribute type */</p><p>+	uint16_t			off;	/* field offset in the target structure */</p><p>+	parse_attr_f			*cb;	/* parser function to call */</p><p>+	const void			*arg;</p><p>+};</p><p>+</p><p>+typedef bool strict_parser_f(void *hdr, struct nl_pstate *npt);</p><p>+</p><p>+struct nlhdr_parser {</p><p>+	int				nl_hdr_off; /* aligned netlink header size */</p><p>+	int				out_hdr_off; /* target header size */</p><p>+	int				fp_size;</p><p>+	int				np_size;</p><p>+	const struct nlfield_parser	*fp; /* array of header field parsers */</p><p>+	const struct nlattr_parser	*np; /* array of attribute parsers */</p><p>+	strict_parser_f			*sp; /* Parser function */</p><p>+};</p><p>+</p><p>+#define	NL_DECLARE_PARSER(_name, _t, _fp, _np)		\</p><p>+static const struct nlhdr_parser _name = {		\</p><p>+	.nl_hdr_off = sizeof(_t),			\</p><p>+	.fp = &amp;((_fp)[0]),				\</p><p>+	.np = &amp;((_np)[0]),				\</p><p>+	.fp_size = NL_ARRAY_LEN(_fp),			\</p><p>+	.np_size = NL_ARRAY_LEN(_np),			\</p><p>+}</p><p>+</p><p>+#define	NL_DECLARE_STRICT_PARSER(_name, _t, _sp, _fp, _np)\</p><p>+static const struct nlhdr_parser _name = {		\</p><p>+	.nl_hdr_off = sizeof(_t),			\</p><p>+	.fp = &amp;((_fp)[0]),				\</p><p>+	.np = &amp;((_np)[0]),				\</p><p>+	.fp_size = NL_ARRAY_LEN(_fp),			\</p><p>+	.np_size = NL_ARRAY_LEN(_np),			\</p><p>+	.sp = _sp,					\</p><p>+}</p><p>+</p><p>+#define	NL_DECLARE_ARR_PARSER(_name, _t, _o, _fp, _np)	\</p><p>+static const struct nlhdr_parser _name = {		\</p><p>+	.nl_hdr_off = sizeof(_t),			\</p><p>+	.out_hdr_off = sizeof(_o),			\</p><p>+	.fp = &amp;((_fp)[0]),				\</p><p>+	.np = &amp;((_np)[0]),				\</p><p>+	.fp_size = NL_ARRAY_LEN(_fp),			\</p><p>+	.np_size = NL_ARRAY_LEN(_np),			\</p><p>+}</p><p>+</p><p>+#define	NL_DECLARE_ATTR_PARSER(_name, _np)		\</p><p>+static const struct nlhdr_parser _name = {		\</p><p>+	.np = &amp;((_np)[0]),				\</p><p>+	.np_size = NL_ARRAY_LEN(_np),			\</p><p>+}</p><p>+</p><p>+struct nlarr_hdr {</p><p>+	int num_items;</p><p>+	int max_items;</p><p>+};</p><p>+</p><p>+int nl_parse_attrs_raw(struct nlattr *nla_head, int len, const struct nlattr_parser *ps,</p><p>+    int pslen, struct nl_pstate *npt, void *target);</p><p>+int nl_parse_attrs(struct nlmsghdr *hdr, int hdrlen, struct nlattr_parser *ps,</p><p>+    int pslen, struct nl_pstate *npt, void *target);</p><p>+</p><p>+int nlattr_get_flag(struct nlattr *nla, struct nl_pstate *npt,</p><p>+    const void *arg, void *target);</p><p>+int nlattr_get_ip(struct nlattr *nla, struct nl_pstate *npt,</p><p>+    const void *arg, void *target);</p><p>+int nlattr_get_uint16(struct nlattr *nla, struct nl_pstate *npt,</p><p>+    const void *arg, void *target);</p><p>+int nlattr_get_uint32(struct nlattr *nla, struct nl_pstate *npt,</p><p>+    const void *arg, void *target);</p><p>+int nlattr_get_uint64(struct nlattr *nla, struct nl_pstate *npt,</p><p>+    const void *arg, void *target);</p><p>+int nlattr_get_ifp(struct nlattr *nla, struct nl_pstate *npt,</p><p>+    const void *arg, void *target);</p><p>+int nlattr_get_ifpz(struct nlattr *nla, struct nl_pstate *npt,</p><p>+    const void *arg, void *target);</p><p>+int nlattr_get_ipvia(struct nlattr *nla, struct nl_pstate *npt,</p><p>+    const void *arg, void *target);</p><p>+int nlattr_get_string(struct nlattr *nla, struct nl_pstate *npt,</p><p>+    const void *arg, void *target);</p><p>+int nlattr_get_stringn(struct nlattr *nla, struct nl_pstate *npt,</p><p>+    const void *arg, void *target);</p><p>+int nlattr_get_nla(struct nlattr *nla, struct nl_pstate *npt,</p><p>+    const void *arg, void *target);</p><p>+int nlattr_get_nested(struct nlattr *nla, struct nl_pstate *npt,</p><p>+    const void *arg, void *target);</p><p>+</p><p>+bool nlmsg_report_err_msg(struct nl_pstate *npt, const char *fmt, ...);</p><p>+</p><p>+#define	NLMSG_REPORT_ERR_MSG(_npt, _fmt, ...) {	\</p><p>+	nlmsg_report_err_msg(_npt, _fmt, ## __VA_ARGS__); \</p><p>+	NLP_LOG(LOG_DEBUG, (_npt)-&gt;nlp, _fmt, ## __VA_ARGS__); \</p><p>+}</p><p>+</p><p>+bool nlmsg_report_err_offset(struct nl_pstate *npt, uint32_t off);</p><p>+</p><p>+/*</p><p>+ * Have it inline so compiler can optimize field accesses into</p><p>+ * the list of direct function calls without iteration.</p><p>+ */</p><p>+static inline int</p><p>+nl_parse_header(void *hdr, int len, const struct nlhdr_parser *parser,</p><p>+    struct nl_pstate *npt, void *target)</p><p>+{</p><p>+	int error;</p><p>+</p><p>+	if (__predict_false(len &lt; parser-&gt;nl_hdr_off)) {</p><p>+		nlmsg_report_err_msg(npt, &#34;header too short: expected %d, got %d&#34;,</p><p>+		    parser-&gt;nl_hdr_off, len);</p><p>+		return (EINVAL);</p><p>+	}</p><p>+</p><p>+	if (npt-&gt;strict &amp;&amp; parser-&gt;sp != NULL &amp;&amp; !parser-&gt;sp(hdr, npt))</p><p>+		return (EINVAL);</p><p>+</p><p>+	/* Extract fields first */</p><p>+	for (int i = 0; i &lt; parser-&gt;fp_size; i++) {</p><p>+		const struct nlfield_parser *fp = &amp;parser-&gt;fp[i];</p><p>+		void *src = (char *)hdr + fp-&gt;off_in;</p><p>+		void *dst = (char *)target + fp-&gt;off_out;</p><p>+</p><p>+		error = fp-&gt;cb(src, npt, dst);</p><p>+		if (error != 0)</p><p>+			return (error);</p><p>+	}</p><p>+</p><p>+	struct nlattr *nla_head = (struct nlattr *)((char *)hdr + parser-&gt;nl_hdr_off);</p><p>+	error = nl_parse_attrs_raw(nla_head, len - parser-&gt;nl_hdr_off, parser-&gt;np,</p><p>+	    parser-&gt;np_size, npt, target);</p><p>+</p><p>+	return (error);</p><p>+}</p><p>+</p><p>+static inline int</p><p>+nl_parse_nested(struct nlattr *nla, const struct nlhdr_parser *parser,</p><p>+    struct nl_pstate *npt, void *target)</p><p>+{</p><p>+	struct nlattr *nla_head = (struct nlattr *)NLA_DATA(nla);</p><p>+</p><p>+	return (nl_parse_attrs_raw(nla_head, NLA_DATA_LEN(nla), parser-&gt;np,</p><p>+	    parser-&gt;np_size, npt, target));</p><p>+}</p><p>+</p><p>+/*</p><p>+ * Checks that attributes are sorted by attribute type.</p><p>+ */</p><p>+static inline void</p><p>+nl_verify_parsers(const struct nlhdr_parser **parser, int count)</p><p>+{</p><p>+	for (int i = 0; i &lt; count; i++) {</p><p>+		const struct nlhdr_parser *p = parser[i];</p><p>+		int attr_type = 0;</p><p>+		for (int j = 0; j &lt; p-&gt;np_size; j++) {</p><p>+			MPASS(p-&gt;np[j].type &gt; attr_type);</p><p>+			attr_type = p-&gt;np[j].type;</p><p>+		}</p><p>+	}</p><p>+}</p><p>+void nl_verify_parsers(const struct nlhdr_parser **parser, int count);</p><p>+#define	NL_VERIFY_PARSERS(_p)	nl_verify_parsers((_p), NL_ARRAY_LEN(_p))</p><p>+</p><p>+static inline int</p><p>+nl_parse_nlmsg(struct nlmsghdr *hdr, const struct nlhdr_parser *parser,</p><p>+    struct nl_pstate *npt, void *target)</p><p>+{</p><p>+	return (nl_parse_header(hdr + 1, hdr-&gt;nlmsg_len - sizeof(*hdr), parser, npt, target));</p><p>+}</p><p>+</p><p>+#endif</p><div><p>diff --git a/sys/netlink/netlink_message_writer.c b/sys/netlink/netlink_message_writer.c</p></div><p>@@ -0,0 +1,686 @@</p><p>+/*-</p><p>+ * SPDX-License-Identifier: BSD-2-Clause-FreeBSD</p><p>+ *</p><p>+ * Copyright (c) 2022 Alexander V. Chernikov &lt;melifaro@FreeBSD.org&gt;</p><p>+ *</p><p>+ * Redistribution and use in source and binary forms, with or without</p><p>+ * modification, are permitted provided that the following conditions</p><p>+ * are met:</p><p>+ * 1. Redistributions of source code must retain the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer.</p><p>+ * 2. Redistributions in binary form must reproduce the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer in the</p><p>+ *    documentation and/or other materials provided with the distribution.</p><p>+ *</p><p>+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&#39;&#39; AND</p><p>+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</p><p>+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</p><p>+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE</p><p>+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</p><p>+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</p><p>+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</p><p>+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</p><p>+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</p><p>+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</p><p>+ * SUCH DAMAGE.</p><p>+ */</p><p>+</p><p>+#include &lt;sys/cdefs.h&gt;</p><p>+__FBSDID(&#34;$FreeBSD$&#34;);</p><p>+#include &lt;sys/param.h&gt;</p><p>+#include &lt;sys/malloc.h&gt;</p><p>+#include &lt;sys/lock.h&gt;</p><p>+#include &lt;sys/rmlock.h&gt;</p><p>+#include &lt;sys/mbuf.h&gt;</p><p>+#include &lt;sys/ck.h&gt;</p><p>+#include &lt;sys/socket.h&gt;</p><p>+#include &lt;sys/socketvar.h&gt;</p><p>+#include &lt;sys/syslog.h&gt;</p><p>+</p><p>+#include &lt;netlink/netlink.h&gt;</p><p>+#include &lt;netlink/netlink_ctl.h&gt;</p><p>+#include &lt;netlink/netlink_linux.h&gt;</p><p>+#include &lt;netlink/netlink_var.h&gt;</p><p>+</p><p>+#define	DEBUG_MOD_NAME	nl_writer</p><p>+#define	DEBUG_MAX_LEVEL	LOG_DEBUG3</p><p>+#include &lt;netlink/netlink_debug.h&gt;</p><p>+_DECLARE_DEBUG(LOG_DEBUG);</p><p>+</p><p>+/*</p><p>+ * The goal of this file is to provide convenient message writing KPI on top of</p><p>+ * different storage methods (mbufs, uio, temporary memory chunks).</p><p>+ *</p><p>+ * The main KPI guarantee is the the (last) message always resides in the contiguous</p><p>+ *  memory buffer, so one is able to update the header after writing the entire message.</p><p>+ *</p><p>+ * This guarantee comes with a side effect of potentially reallocating underlying</p><p>+ *  buffer, so one needs to update the desired pointers after something is added</p><p>+ *  to the header.</p><p>+ *</p><p>+ * Messaging layer contains hooks performing transparent Linux translation for the messages.</p><p>+ *</p><p>+ * There are 3 types of supported targets:</p><p>+ *  * socket (adds mbufs to the socket buffer, used for message replies)</p><p>+ *  * group (sends mbuf/chain to the specified groups, used for the notifications)</p><p>+ *  * chain (returns mbuf chain, used in Linux message translation code)</p><p>+ *</p><p>+ * There are 3 types of storage:</p><p>+ * * NS_WRITER_TYPE_MBUF (mbuf-based, most efficient, used when a single message</p><p>+ *    fits in MCLBYTES)</p><p>+ * * NS_WRITER_TYPE_BUF (fallback, malloc-based, used when a single message needs</p><p>+ *    to be larger than one supported by NS_WRITER_TYPE_MBUF)</p><p>+ * * NS_WRITER_TYPE_LBUF (malloc-based, similar to NS_WRITER_TYPE_BUF, used for</p><p>+ *    Linux sockets, calls translation hook prior to sending messages to the socket).</p><p>+ *</p><p>+ * Internally, KPI switches between different types of storage when memory requirements</p><p>+ *  change. It happens transparently to the caller.</p><p>+ */</p><p>+</p><p>+</p><p>+typedef bool nlwriter_op_init(struct nl_writer *nw, int size, bool waitok);</p><p>+typedef bool nlwriter_op_write(struct nl_writer *nw, void *buf, int buflen, int cnt);</p><p>+</p><p>+struct nlwriter_ops {</p><p>+	nlwriter_op_init	*init;</p><p>+	nlwriter_op_write	*write_socket;</p><p>+	nlwriter_op_write	*write_group;</p><p>+	nlwriter_op_write	*write_chain;</p><p>+};</p><p>+</p><p>+/*</p><p>+ * NS_WRITER_TYPE_BUF</p><p>+ * Writes message to a temporary memory buffer,</p><p>+ * flushing to the socket/group when buffer size limit is reached</p><p>+ */</p><p>+static bool</p><p>+nlmsg_get_ns_buf(struct nl_writer *nw, int size, bool waitok)</p><p>+{</p><p>+	int mflag = waitok ? M_WAITOK : M_NOWAIT;</p><p>+	nw-&gt;_storage = malloc(size, M_NETLINK, mflag | M_ZERO);</p><p>+	if (__predict_false(nw-&gt;_storage == NULL))</p><p>+		return (false);</p><p>+	nw-&gt;alloc_len = size;</p><p>+	nw-&gt;offset = 0;</p><p>+	nw-&gt;hdr = NULL;</p><p>+	nw-&gt;data = nw-&gt;_storage;</p><p>+	nw-&gt;writer_type = NS_WRITER_TYPE_BUF;</p><p>+	nw-&gt;malloc_flag = mflag;</p><p>+	nw-&gt;num_messages = 0;</p><p>+	nw-&gt;enomem = false;</p><p>+	return (true);</p><p>+}</p><p>+</p><p>+static bool</p><p>+nlmsg_write_socket_buf(struct nl_writer *nw, void *buf, int datalen, int cnt)</p><p>+{</p><p>+	NL_LOG(LOG_DEBUG2, &#34;IN: ptr: %p len: %d arg: %p&#34;, buf, datalen, nw);</p><p>+	if (__predict_false(datalen == 0)) {</p><p>+		free(buf, M_NETLINK);</p><p>+		return (true);</p><p>+	}</p><p>+</p><p>+	struct mbuf *m = m_getm2(NULL, datalen, nw-&gt;malloc_flag, MT_DATA, M_PKTHDR);</p><p>+	if (__predict_false(m == NULL)) {</p><p>+		/* XXX: should we set sorcverr? */</p><p>+		free(buf, M_NETLINK);</p><p>+		return (false);</p><p>+	}</p><p>+	m_append(m, datalen, buf);</p><p>+	free(buf, M_NETLINK);</p><p>+</p><p>+	int io_flags = (nw-&gt;ignore_limit) ? NL_IOF_IGNORE_LIMIT : 0;</p><p>+        return (nl_send_one(m, (struct nlpcb *)(nw-&gt;arg_ptr), cnt, io_flags));</p><p>+}</p><p>+</p><p>+static bool</p><p>+nlmsg_write_group_buf(struct nl_writer *nw, void *buf, int datalen, int cnt)</p><p>+{</p><p>+	NL_LOG(LOG_DEBUG2, &#34;IN: ptr: %p len: %d arg: %p&#34;, buf, datalen, nw-&gt;arg_ptr);</p><p>+	if (__predict_false(datalen == 0)) {</p><p>+		free(buf, M_NETLINK);</p><p>+		return (true);</p><p>+	}</p><p>+</p><p>+	struct mbuf *m = m_getm2(NULL, datalen, nw-&gt;malloc_flag, MT_DATA, M_PKTHDR);</p><p>+	if (__predict_false(m == NULL)) {</p><p>+		free(buf, M_NETLINK);</p><p>+		return (false);</p><p>+	}</p><p>+	bool success = m_append(m, datalen, buf) != 0;</p><p>+	free(buf, M_NETLINK);</p><p>+</p><p>+	if (!success)</p><p>+		return (false);</p><p>+</p><p>+        nl_send_group(m, cnt, nw-&gt;arg_uint &gt;&gt; 16, nw-&gt;arg_uint &amp; 0xFFFF);</p><p>+	return (true);</p><p>+}</p><p>+</p><p>+static bool</p><p>+nlmsg_write_chain_buf(struct nl_writer *nw, void *buf, int datalen, int cnt)</p><p>+{</p><p>+	struct mbuf **m0 = (struct mbuf **)(nw-&gt;arg_ptr);</p><p>+	NL_LOG(LOG_DEBUG2, &#34;IN: ptr: %p len: %d arg: %p&#34;, buf, datalen, nw-&gt;arg_ptr);</p><p>+</p><p>+	if (__predict_false(datalen == 0)) {</p><p>+		free(buf, M_NETLINK);</p><p>+		return (true);</p><p>+	}</p><p>+</p><p>+	if (*m0 == NULL) {</p><p>+		struct mbuf *m;</p><p>+</p><p>+		m = m_getm2(NULL, datalen, nw-&gt;malloc_flag, MT_DATA, M_PKTHDR);</p><p>+		if (__predict_false(m == NULL)) {</p><p>+			free(buf, M_NETLINK);</p><p>+			return (false);</p><p>+		}</p><p>+		*m0 = m;</p><p>+	}</p><p>+	if (__predict_false(m_append(*m0, datalen, buf) == 0)) {</p><p>+		free(buf, M_NETLINK);</p><p>+		return (false);</p><p>+	}</p><p>+        return (true);</p><p>+}</p><p>+</p><p>+</p><p>+/*</p><p>+ * NS_WRITER_TYPE_MBUF</p><p>+ * Writes message to the allocated mbuf,</p><p>+ * flushing to socket/group when mbuf size limit is reached.</p><p>+ * This is the most efficient mechanism as it avoids double-copying.</p><p>+ *</p><p>+ * Allocates a single mbuf suitable to store up to @size bytes of data.</p><p>+ * If size &lt; MHLEN (around 160 bytes), allocates mbuf with pkghdr</p><p>+ * If size &lt;= MCLBYTES (2k), allocate a single mbuf cluster</p><p>+ * Otherwise, return NULL.</p><p>+ */</p><p>+static bool</p><p>+nlmsg_get_ns_mbuf(struct nl_writer *nw, int size, bool waitok)</p><p>+{</p><p>+	struct mbuf *m;</p><p>+</p><p>+	int mflag = waitok ? M_WAITOK : M_NOWAIT;</p><p>+        m = m_get2(size, mflag, MT_DATA, M_PKTHDR);</p><p>+        if (__predict_false(m == NULL))</p><p>+                return (false);</p><p>+        nw-&gt;alloc_len = M_TRAILINGSPACE(m);</p><p>+        nw-&gt;offset = 0;</p><p>+        nw-&gt;hdr = NULL;</p><p>+	nw-&gt;_storage = (void *)m;</p><p>+	nw-&gt;data = mtod(m, void *);</p><p>+	nw-&gt;writer_type = NS_WRITER_TYPE_MBUF;</p><p>+	nw-&gt;malloc_flag = mflag;</p><p>+	nw-&gt;num_messages = 0;</p><p>+	nw-&gt;enomem = false;</p><p>+        NL_LOG(LOG_DEBUG2, &#34;alloc mbuf %p req_len %d alloc_len %d data_ptr %p&#34;,</p><p>+            m, size, nw-&gt;alloc_len, nw-&gt;data);</p><p>+        return (true);</p><p>+}</p><p>+</p><p>+static bool</p><p>+nlmsg_write_socket_mbuf(struct nl_writer *nw, void *buf, int datalen, int cnt)</p><p>+{</p><p>+	struct mbuf *m = (struct mbuf *)buf;</p><p>+	NL_LOG(LOG_DEBUG2, &#34;IN: ptr: %p len: %d arg: %p&#34;, buf, datalen, nw-&gt;arg_ptr);</p><p>+</p><p>+	if (__predict_false(datalen == 0)) {</p><p>+		m_freem(m);</p><p>+		return (true);</p><p>+	}</p><p>+</p><p>+	m-&gt;m_pkthdr.len = datalen;</p><p>+	m-&gt;m_len = datalen;</p><p>+	int io_flags = (nw-&gt;ignore_limit) ? NL_IOF_IGNORE_LIMIT : 0;</p><p>+        return (nl_send_one(m, (struct nlpcb *)(nw-&gt;arg_ptr), cnt, io_flags));</p><p>+}</p><p>+</p><p>+static bool</p><p>+nlmsg_write_group_mbuf(struct nl_writer *nw, void *buf, int datalen, int cnt)</p><p>+{</p><p>+	struct mbuf *m = (struct mbuf *)buf;</p><p>+	NL_LOG(LOG_DEBUG2, &#34;IN: ptr: %p len: %d arg: %p&#34;, buf, datalen, nw-&gt;arg_ptr);</p><p>+</p><p>+	if (__predict_false(datalen == 0)) {</p><p>+		m_freem(m);</p><p>+		return (true);</p><p>+	}</p><p>+</p><p>+	m-&gt;m_pkthdr.len = datalen;</p><p>+	m-&gt;m_len = datalen;</p><p>+        nl_send_group(m, cnt, nw-&gt;arg_uint &gt;&gt; 16, nw-&gt;arg_uint &amp; 0xFFFF);</p><p>+	return (true);</p><p>+}</p><p>+</p><p>+static bool</p><p>+nlmsg_write_chain_mbuf(struct nl_writer *nw, void *buf, int datalen, int cnt)</p><p>+{</p><p>+	struct mbuf *m_new = (struct mbuf *)buf;</p><p>+	struct mbuf **m0 = (struct mbuf **)(nw-&gt;arg_ptr);</p><p>+</p><p>+	NL_LOG(LOG_DEBUG2, &#34;IN: ptr: %p len: %d arg: %p&#34;, buf, datalen, nw-&gt;arg_ptr);</p><p>+</p><p>+	if (__predict_false(datalen == 0)) {</p><p>+		m_freem(m_new);</p><p>+		return (true);</p><p>+	}</p><p>+</p><p>+	m_new-&gt;m_pkthdr.len = datalen;</p><p>+	m_new-&gt;m_len = datalen;</p><p>+</p><p>+	if (*m0 == NULL) {</p><p>+		*m0 = m_new;</p><p>+	} else {</p><p>+		struct mbuf *m_last;</p><p>+		for (m_last = *m0; m_last-&gt;m_next != NULL; m_last = m_last-&gt;m_next)</p><p>+			;</p><p>+		m_last-&gt;m_next = m_new;</p><p>+		(*m0)-&gt;m_pkthdr.len += datalen;</p><p>+	}</p><p>+</p><p>+        return (true);</p><p>+}</p><p>+</p><p>+/*</p><p>+ * NS_WRITER_TYPE_LBUF</p><p>+ * Writes message to the allocated memory buffer,</p><p>+ * flushing to socket/group when mbuf size limit is reached.</p><p>+ * Calls linux handler to rewrite messages before sending to the socket.</p><p>+ */</p><p>+static bool</p><p>+nlmsg_get_ns_lbuf(struct nl_writer *nw, int size, bool waitok)</p><p>+{</p><p>+	int mflag = waitok ? M_WAITOK : M_NOWAIT;</p><p>+	size = roundup2(size, sizeof(void *));</p><p>+	int add_size = sizeof(struct linear_buffer) + SCRATCH_BUFFER_SIZE;</p><p>+	char *buf = malloc(add_size + size * 2, M_NETLINK, mflag | M_ZERO);</p><p>+	if (__predict_false(buf == NULL))</p><p>+		return (false);</p><p>+</p><p>+	/* Fill buffer header first */</p><p>+	struct linear_buffer *lb = (struct linear_buffer *)buf;</p><p>+	lb-&gt;base = &amp;buf[sizeof(struct linear_buffer) + size];</p><p>+	lb-&gt;size = size + SCRATCH_BUFFER_SIZE;</p><p>+</p><p>+	nw-&gt;alloc_len = size;</p><p>+	nw-&gt;offset = 0;</p><p>+	nw-&gt;hdr = NULL;</p><p>+	nw-&gt;_storage = buf;</p><p>+	nw-&gt;data = (char *)(lb + 1);</p><p>+	nw-&gt;malloc_flag = mflag;</p><p>+	nw-&gt;writer_type = NS_WRITER_TYPE_LBUF;</p><p>+	nw-&gt;num_messages = 0;</p><p>+	nw-&gt;enomem = false;</p><p>+	return (true);</p><p>+}</p><p>+</p><p>+</p><p>+static bool</p><p>+nlmsg_write_socket_lbuf(struct nl_writer *nw, void *buf, int datalen, int cnt)</p><p>+{</p><p>+	struct linear_buffer *lb = (struct linear_buffer *)buf;</p><p>+	char *data = (char *)(lb + 1);</p><p>+	struct nlpcb *nlp = (struct nlpcb *)(nw-&gt;arg_ptr);</p><p>+</p><p>+	if (__predict_false(datalen == 0)) {</p><p>+		free(buf, M_NETLINK);</p><p>+		return (true);</p><p>+	}</p><p>+</p><p>+	struct mbuf *m = NULL;</p><p>+	if (linux_netlink_p != NULL)</p><p>+		m = linux_netlink_p-&gt;msgs_to_linux(nlp-&gt;nl_proto, data, datalen, nlp);</p><p>+	free(buf, M_NETLINK);</p><p>+</p><p>+	if (__predict_false(m == NULL)) {</p><p>+		/* XXX: should we set sorcverr? */</p><p>+		return (false);</p><p>+	}</p><p>+</p><p>+	int io_flags = (nw-&gt;ignore_limit) ? NL_IOF_IGNORE_LIMIT : 0;</p><p>+        return (nl_send_one(m, nlp, cnt, io_flags));</p><p>+}</p><p>+</p><p>+/* Shouldn&#39;t be called (maybe except Linux code originating message) */</p><p>+static bool</p><p>+nlmsg_write_group_lbuf(struct nl_writer *nw, void *buf, int datalen, int cnt)</p><p>+{</p><p>+	struct linear_buffer *lb = (struct linear_buffer *)buf;</p><p>+	char *data = (char *)(lb + 1);</p><p>+</p><p>+	if (__predict_false(datalen == 0)) {</p><p>+		free(buf, M_NETLINK);</p><p>+		return (true);</p><p>+	}</p><p>+</p><p>+	struct mbuf *m = m_getm2(NULL, datalen, nw-&gt;malloc_flag, MT_DATA, M_PKTHDR);</p><p>+	if (__predict_false(m == NULL)) {</p><p>+		free(buf, M_NETLINK);</p><p>+		return (false);</p><p>+	}</p><p>+	m_append(m, datalen, data);</p><p>+	free(buf, M_NETLINK);</p><p>+</p><p>+        nl_send_group(m, cnt, nw-&gt;arg_uint &gt;&gt; 16, nw-&gt;arg_uint &amp; 0xFFFF);</p><p>+	return (true);</p><p>+}</p><p>+</p><p>+struct nlwriter_ops nlmsg_writers[] = {</p><p>+	/* NS_WRITER_TYPE_MBUF */</p><p>+	{</p><p>+		.init = nlmsg_get_ns_mbuf,</p><p>+		.write_socket = nlmsg_write_socket_mbuf,</p><p>+		.write_group = nlmsg_write_group_mbuf,</p><p>+		.write_chain = nlmsg_write_chain_mbuf,</p><p>+	},</p><p>+	/* NS_WRITER_TYPE_BUF */</p><p>+	{</p><p>+		.init = nlmsg_get_ns_buf,</p><p>+		.write_socket = nlmsg_write_socket_buf,</p><p>+		.write_group = nlmsg_write_group_buf,</p><p>+		.write_chain = nlmsg_write_chain_buf,</p><p>+	},</p><p>+	/* NS_WRITER_TYPE_LBUF */</p><p>+	{</p><p>+		.init = nlmsg_get_ns_lbuf,</p><p>+		.write_socket = nlmsg_write_socket_lbuf,</p><p>+		.write_group = nlmsg_write_group_lbuf,</p><p>+	},</p><p>+};</p><p>+</p><p>+static void</p><p>+nlmsg_set_callback(struct nl_writer *nw)</p><p>+{</p><p>+	struct nlwriter_ops *pops = &amp;nlmsg_writers[nw-&gt;writer_type];</p><p>+</p><p>+	switch (nw-&gt;writer_target) {</p><p>+	case NS_WRITER_TARGET_SOCKET:</p><p>+		nw-&gt;cb = pops-&gt;write_socket;</p><p>+		break;</p><p>+	case NS_WRITER_TARGET_GROUP:</p><p>+		nw-&gt;cb = pops-&gt;write_group;</p><p>+		break;</p><p>+	case NS_WRITER_TARGET_CHAIN:</p><p>+		nw-&gt;cb = pops-&gt;write_chain;</p><p>+		break;</p><p>+	default:</p><p>+		panic(&#34;not implemented&#34;);</p><p>+	}</p><p>+}</p><p>+</p><p>+static bool</p><p>+nlmsg_get_buf_type(struct nl_writer *nw, int size, int type, bool waitok)</p><p>+{</p><p>+	MPASS(type + 1 &lt;= sizeof(nlmsg_writers) / sizeof(nlmsg_writers[0]));</p><p>+	NL_LOG(LOG_DEBUG3, &#34;Setting up nw %p size %d type %d&#34;, nw, size, type);</p><p>+	return (nlmsg_writers[type].init(nw, size, waitok));</p><p>+}</p><p>+</p><p>+static bool</p><p>+nlmsg_get_buf(struct nl_writer *nw, int size, bool waitok, bool is_linux)</p><p>+{</p><p>+	int type;</p><p>+</p><p>+	if (!is_linux) {</p><p>+		if (__predict_true(size &lt;= MCLBYTES))</p><p>+			type = NS_WRITER_TYPE_MBUF;</p><p>+		else</p><p>+			type = NS_WRITER_TYPE_BUF;</p><p>+	} else</p><p>+		type = NS_WRITER_TYPE_LBUF;</p><p>+	return (nlmsg_get_buf_type(nw, size, type, waitok));</p><p>+}</p><p>+</p><p>+bool</p><p>+nlmsg_get_unicast_writer(struct nl_writer *nw, int size, struct nlpcb *nlp)</p><p>+{</p><p>+        if (!nlmsg_get_buf(nw, size, false, nlp-&gt;nl_linux))</p><p>+                return (false);</p><p>+        nw-&gt;arg_ptr = (void *)nlp;</p><p>+	nw-&gt;writer_target = NS_WRITER_TARGET_SOCKET;</p><p>+	nlmsg_set_callback(nw);</p><p>+        return (true);</p><p>+}</p><p>+</p><p>+bool</p><p>+nlmsg_get_group_writer(struct nl_writer *nw, int size, int protocol, int group_id)</p><p>+{</p><p>+        if (!nlmsg_get_buf(nw, size, false, false))</p><p>+                return (false);</p><p>+        nw-&gt;arg_uint = (uint64_t)protocol &lt;&lt; 16 | (uint64_t)group_id;</p><p>+	nw-&gt;writer_target = NS_WRITER_TARGET_GROUP;</p><p>+	nlmsg_set_callback(nw);</p><p>+        return (true);</p><p>+}</p><p>+</p><p>+bool</p><p>+nlmsg_get_chain_writer(struct nl_writer *nw, int size, struct mbuf **pm)</p><p>+{</p><p>+        if (!nlmsg_get_buf(nw, size, false, false))</p><p>+                return (false);</p><p>+	*pm = NULL;</p><p>+        nw-&gt;arg_ptr = (void *)pm;</p><p>+	nw-&gt;writer_target = NS_WRITER_TARGET_CHAIN;</p><p>+	nlmsg_set_callback(nw);</p><p>+	NL_LOG(LOG_DEBUG3, &#34;setup cb %p (need %p)&#34;, nw-&gt;cb, &amp;nlmsg_write_chain_mbuf);</p><p>+        return (true);</p><p>+}</p><p>+</p><p>+void</p><p>+nlmsg_ignore_limit(struct nl_writer *nw)</p><p>+{</p><p>+	nw-&gt;ignore_limit = true;</p><p>+}</p><p>+</p><p>+bool</p><p>+nlmsg_flush(struct nl_writer *nw)</p><p>+{</p><p>+</p><p>+        if (__predict_false(nw-&gt;hdr != NULL)) {</p><p>+                /* Last message has not been completed, skip it. */</p><p>+                int completed_len = (char *)nw-&gt;hdr - nw-&gt;data;</p><p>+		/* Send completed messages */</p><p>+		nw-&gt;offset -= nw-&gt;offset - completed_len;</p><p>+		nw-&gt;hdr = NULL;</p><p>+        }</p><p>+</p><p>+	NL_LOG(LOG_DEBUG2, &#34;OUT&#34;);</p><p>+        bool result = nw-&gt;cb(nw, nw-&gt;_storage, nw-&gt;offset, nw-&gt;num_messages);</p><p>+        nw-&gt;_storage = NULL;</p><p>+</p><p>+        if (!result) {</p><p>+                NL_LOG(LOG_DEBUG, &#34;nw %p offset %d: flush with %p() failed&#34;, nw, nw-&gt;offset, nw-&gt;cb);</p><p>+        }</p><p>+</p><p>+        return (result);</p><p>+}</p><p>+</p><p>+/*</p><p>+ * Flushes previous data and allocates new underlying storage</p><p>+ *  sufficient for holding at least @required_len bytes.</p><p>+ * Return true on success.</p><p>+ */</p><p>+bool</p><p>+nlmsg_refill_buffer(struct nl_writer *nw, int required_len)</p><p>+{</p><p>+        struct nl_writer ns_new = {};</p><p>+        int completed_len, new_len;</p><p>+</p><p>+	if (nw-&gt;enomem)</p><p>+		return (false);</p><p>+</p><p>+	NL_LOG(LOG_DEBUG3, &#34;no space at offset %d/%d (want %d), trying to reclaim&#34;,</p><p>+	    nw-&gt;offset, nw-&gt;alloc_len, required_len);</p><p>+</p><p>+        /* Calculated new buffer size and allocate it s*/</p><p>+	completed_len = (nw-&gt;hdr != NULL) ? (char *)nw-&gt;hdr - nw-&gt;data : nw-&gt;offset;</p><p>+	if (completed_len &gt; 0 &amp;&amp; required_len &lt; MCLBYTES) {</p><p>+		/* We already ran out of space, use the largest effective size */</p><p>+		new_len = max(nw-&gt;alloc_len, MCLBYTES);</p><p>+	} else {</p><p>+		if (nw-&gt;alloc_len &lt; MCLBYTES)</p><p>+			new_len = MCLBYTES;</p><p>+		else</p><p>+			new_len = nw-&gt;alloc_len * 2;</p><p>+		while (new_len &lt; required_len)</p><p>+			new_len *= 2;</p><p>+	}</p><p>+	bool waitok = (nw-&gt;malloc_flag == M_WAITOK);</p><p>+	bool is_linux = (nw-&gt;writer_type == NS_WRITER_TYPE_LBUF);</p><p>+        if (!nlmsg_get_buf(&amp;ns_new, new_len, waitok, is_linux)) {</p><p>+		nw-&gt;enomem = true;</p><p>+		NL_LOG(LOG_DEBUG, &#34;getting new buf failed, setting ENOMEM&#34;);</p><p>+                return (false);</p><p>+	}</p><p>+	if (nw-&gt;ignore_limit)</p><p>+		nlmsg_ignore_limit(&amp;ns_new);</p><p>+</p><p>+	/* Update callback data */</p><p>+	ns_new.writer_target = nw-&gt;writer_target;</p><p>+	nlmsg_set_callback(&amp;ns_new);</p><p>+	ns_new.arg_uint = nw-&gt;arg_uint;</p><p>+</p><p>+        /* Copy last (unfinished) header to the new storage */</p><p>+        int last_len = nw-&gt;offset - completed_len;</p><p>+	if (last_len &gt; 0) {</p><p>+		memcpy(ns_new.data, nw-&gt;hdr, last_len);</p><p>+		ns_new.hdr = (struct nlmsghdr *)ns_new.data;</p><p>+		ns_new.offset = last_len;</p><p>+	}</p><p>+</p><p>+        NL_LOG(LOG_DEBUG2, &#34;completed: %d bytes, copied: %d bytes&#34;, completed_len, last_len);</p><p>+</p><p>+        /* Flush completed headers &amp; switch to the new nw */</p><p>+	nlmsg_flush(nw);</p><p>+	memcpy(nw, &amp;ns_new, sizeof(struct nl_writer));</p><p>+        NL_LOG(LOG_DEBUG2, &#34;switched buffer: used %d/%d bytes&#34;, nw-&gt;offset, nw-&gt;alloc_len);</p><p>+</p><p>+        return (true);</p><p>+}</p><p>+</p><p>+bool</p><p>+nlmsg_add(struct nl_writer *nw, uint32_t portid, uint32_t seq, uint16_t type,</p><p>+    uint16_t flags, uint32_t len)</p><p>+{</p><p>+	struct nlmsghdr *hdr;</p><p>+</p><p>+	MPASS(nw-&gt;hdr == NULL);</p><p>+</p><p>+	int required_len = NETLINK_ALIGN(len + sizeof(struct nlmsghdr));</p><p>+        if (__predict_false(nw-&gt;offset + required_len &gt; nw-&gt;alloc_len)) {</p><p>+		if (!nlmsg_refill_buffer(nw, required_len))</p><p>+			return (false);</p><p>+        }</p><p>+</p><p>+        hdr = (struct nlmsghdr *)(&amp;nw-&gt;data[nw-&gt;offset]);</p><p>+</p><p>+        hdr-&gt;nlmsg_len = len;</p><p>+        hdr-&gt;nlmsg_type = type;</p><p>+        hdr-&gt;nlmsg_flags = flags;</p><p>+        hdr-&gt;nlmsg_seq = seq;</p><p>+        hdr-&gt;nlmsg_pid = portid;</p><p>+</p><p>+        nw-&gt;hdr = hdr;</p><p>+        nw-&gt;offset += sizeof(struct nlmsghdr);</p><p>+</p><p>+        return (true);</p><p>+}</p><p>+</p><p>+bool</p><p>+nlmsg_end(struct nl_writer *nw)</p><p>+{</p><p>+	MPASS(nw-&gt;hdr != NULL);</p><p>+</p><p>+	if (nw-&gt;enomem) {</p><p>+		NL_LOG(LOG_DEBUG, &#34;ENOMEM when dumping message&#34;);</p><p>+		nlmsg_abort(nw);</p><p>+		return (false);</p><p>+	}</p><p>+</p><p>+        nw-&gt;hdr-&gt;nlmsg_len = (uint32_t)(nw-&gt;data + nw-&gt;offset - (char *)nw-&gt;hdr);</p><p>+        nw-&gt;hdr = NULL;</p><p>+	nw-&gt;num_messages++;</p><p>+	return (true);</p><p>+}</p><p>+</p><p>+void</p><p>+nlmsg_abort(struct nl_writer *nw)</p><p>+{</p><p>+        if (nw-&gt;hdr != NULL) {</p><p>+                nw-&gt;offset = (uint32_t)((char *)nw-&gt;hdr - nw-&gt;data);</p><p>+                nw-&gt;hdr = NULL;</p><p>+        }</p><p>+}</p><p>+</p><p>+void</p><p>+nlmsg_ack(struct nlpcb *nlp, int error, struct nlmsghdr *hdr,</p><p>+    struct nl_pstate *npt)</p><p>+{</p><p>+	struct nlmsgerr *errmsg;</p><p>+	int payload_len;</p><p>+	uint32_t flags = nlp-&gt;nl_flags;</p><p>+	struct nl_writer *nw = npt-&gt;nw;</p><p>+	bool cap_ack;</p><p>+</p><p>+	payload_len = sizeof(struct nlmsgerr);</p><p>+</p><p>+	/*</p><p>+	 * The only case when we send the full message in the</p><p>+	 * reply is when there is an error and NETLINK_CAP_ACK</p><p>+	 * is not set.</p><p>+	 */</p><p>+	cap_ack = (error == 0) || (flags &amp; NLF_CAP_ACK);</p><p>+	if (!cap_ack)</p><p>+		payload_len += hdr-&gt;nlmsg_len - sizeof(struct nlmsghdr);</p><p>+	payload_len = NETLINK_ALIGN(payload_len);</p><p>+</p><p>+	uint16_t nl_flags = cap_ack ? NLM_F_CAPPED : 0;</p><p>+	if ((npt-&gt;err_msg || npt-&gt;err_off) &amp;&amp; nlp-&gt;nl_flags &amp; NLF_EXT_ACK)</p><p>+		nl_flags |= NLM_F_ACK_TLVS;</p><p>+</p><p>+	/*</p><p>+	 * TODO: handle cookies</p><p>+	 */</p><p>+</p><p>+	NL_LOG(LOG_DEBUG3, &#34;acknowledging message type %d seq %d&#34;,</p><p>+	    hdr-&gt;nlmsg_type, hdr-&gt;nlmsg_seq);</p><p>+</p><p>+	if (!nlmsg_add(nw, nlp-&gt;nl_port, hdr-&gt;nlmsg_seq, NLMSG_ERROR, nl_flags, payload_len))</p><p>+		goto enomem;</p><p>+</p><p>+	errmsg = nlmsg_reserve_data(nw, payload_len, struct nlmsgerr);</p><p>+	errmsg-&gt;error = error;</p><p>+	/* In case of error copy the whole message, else just the header */</p><p>+	memcpy(&amp;errmsg-&gt;msg, hdr, cap_ack ? sizeof(*hdr) : hdr-&gt;nlmsg_len);</p><p>+</p><p>+	if (npt-&gt;err_msg != NULL &amp;&amp; nlp-&gt;nl_flags &amp; NLF_EXT_ACK)</p><p>+		nlattr_add_string(nw, NLMSGERR_ATTR_MSG, npt-&gt;err_msg);</p><p>+	if (npt-&gt;err_off != 0 &amp;&amp; nlp-&gt;nl_flags &amp; NLF_EXT_ACK)</p><p>+		nlattr_add_u32(nw, NLMSGERR_ATTR_OFFS, npt-&gt;err_off);</p><p>+</p><p>+	if (nlmsg_end(nw))</p><p>+		return;</p><p>+enomem:</p><p>+	NLP_LOG(LOG_DEBUG, nlp, &#34;error allocating ack data for message %d seq %u&#34;,</p><p>+	    hdr-&gt;nlmsg_type, hdr-&gt;nlmsg_seq);</p><p>+	nlmsg_abort(nw);</p><p>+}</p><p>+</p><p>+bool</p><p>+nlmsg_end_dump(struct nl_writer *nw, int error, struct nlmsghdr *hdr)</p><p>+{</p><p>+	if (!nlmsg_add(nw, hdr-&gt;nlmsg_pid, hdr-&gt;nlmsg_seq, NLMSG_DONE, 0, sizeof(int))) {</p><p>+		NL_LOG(LOG_DEBUG, &#34;Error finalizing table dump&#34;);</p><p>+		return (false);</p><p>+	}</p><p>+	/* Save operation result */</p><p>+	int *perror = nlmsg_reserve_object(nw, int);</p><p>+	NL_LOG(LOG_DEBUG2, &#34;record error=%d at off %d (%p)&#34;, error,</p><p>+	    nw-&gt;offset, perror);</p><p>+	*perror = error;</p><p>+	nlmsg_end(nw);</p><p>+</p><p>+	return (true);</p><p>+}</p><div><p>diff --git a/sys/netlink/netlink_message_writer.h b/sys/netlink/netlink_message_writer.h</p></div><p>@@ -0,0 +1,250 @@</p><p>+/*-</p><p>+ * SPDX-License-Identifier: BSD-2-Clause-FreeBSD</p><p>+ *</p><p>+ * Copyright (c) 2021 Ng Peng Nam Sean</p><p>+ * Copyright (c) 2022 Alexander V. Chernikov &lt;melifaro@FreeBSD.org&gt;</p><p>+ *</p><p>+ * Redistribution and use in source and binary forms, with or without</p><p>+ * modification, are permitted provided that the following conditions</p><p>+ * are met:</p><p>+ * 1. Redistributions of source code must retain the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer.</p><p>+ * 2. Redistributions in binary form must reproduce the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer in the</p><p>+ *    documentation and/or other materials provided with the distribution.</p><p>+ *</p><p>+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&#39;&#39; AND</p><p>+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</p><p>+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</p><p>+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE</p><p>+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</p><p>+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</p><p>+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</p><p>+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</p><p>+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</p><p>+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</p><p>+ * SUCH DAMAGE.</p><p>+ */</p><p>+</p><p>+#ifndef _NETLINK_NETLINK_MESSAGE_WRITER_H_</p><p>+#define _NETLINK_NETLINK_MESSAGE_WRITER_H_</p><p>+</p><p>+/*</p><p>+ * It is not meant to be included directly</p><p>+ */</p><p>+</p><p>+struct mbuf;</p><p>+struct nl_writer;</p><p>+typedef bool nl_writer_cb(struct nl_writer *nw, void *buf, int buflen, int cnt);</p><p>+</p><p>+struct nl_writer {</p><p>+	int			alloc_len;	/* allocated buffer length */</p><p>+	int			offset;		/* offset from the start of the buffer */</p><p>+	struct nlmsghdr		*hdr;		/* Pointer to the currently-filled msg */</p><p>+	char			*data;		/* pointer to the contiguous storage */</p><p>+	void			*_storage;	/* Underlying storage pointer */</p><p>+	nl_writer_cb		*cb;		/* Callback to flush data */</p><p>+	union {</p><p>+		void		*arg_ptr;	/* Callback argument as pointer */</p><p>+		uint64_t	arg_uint;	/* Callback argument as int */</p><p>+	};</p><p>+	int			num_messages;	/* Number of messages in the buffer */</p><p>+	int			malloc_flag;	/* M_WAITOK or M_NOWAIT */</p><p>+	uint8_t			writer_type;	/* NS_WRITER_TYPE_* */</p><p>+	uint8_t			writer_target;	/* NS_WRITER_TARGET_*  */</p><p>+	bool			ignore_limit;	/* If true, ignores RCVBUF limit */</p><p>+	bool			enomem;		/* True if ENOMEM occured */</p><p>+};</p><p>+#define	NS_WRITER_TARGET_SOCKET	0</p><p>+#define	NS_WRITER_TARGET_GROUP	1</p><p>+#define	NS_WRITER_TARGET_CHAIN	2</p><p>+</p><p>+#define	NS_WRITER_TYPE_MBUF	0</p><p>+#define NS_WRITER_TYPE_BUF	1</p><p>+#define NS_WRITER_TYPE_LBUF	2</p><p>+#define NS_WRITER_TYPE_MBUFC	3</p><p>+</p><p>+</p><p>+#define	NLMSG_SMALL	128</p><p>+#define	NLMSG_LARGE	2048</p><p>+</p><p>+/* Message and attribute writing */</p><p>+</p><p>+struct nlpcb;</p><p>+bool nlmsg_get_unicast_writer(struct nl_writer *nw, int expected_size, struct nlpcb *nlp);</p><p>+bool nlmsg_get_group_writer(struct nl_writer *nw, int expected_size, int proto, int group_id);</p><p>+bool nlmsg_get_chain_writer(struct nl_writer *nw, int expected_size, struct mbuf **pm);</p><p>+bool nlmsg_flush(struct nl_writer *nw);</p><p>+void nlmsg_ignore_limit(struct nl_writer *nw);</p><p>+</p><p>+bool nlmsg_refill_buffer(struct nl_writer *nw, int required_size);</p><p>+bool nlmsg_add(struct nl_writer *nw, uint32_t portid, uint32_t seq, uint16_t type,</p><p>+    uint16_t flags, uint32_t len);</p><p>+bool nlmsg_end(struct nl_writer *nw);</p><p>+void nlmsg_abort(struct nl_writer *nw);</p><p>+</p><p>+bool nlmsg_end_dump(struct nl_writer *nw, int error, struct nlmsghdr *hdr);</p><p>+</p><p>+static inline bool</p><p>+nlmsg_reply(struct nl_writer *nw, const struct nlmsghdr *hdr, int payload_len)</p><p>+{</p><p>+	return (nlmsg_add(nw, hdr-&gt;nlmsg_pid, hdr-&gt;nlmsg_seq, hdr-&gt;nlmsg_type,</p><p>+	    hdr-&gt;nlmsg_flags, payload_len));</p><p>+}</p><p>+</p><p>+#define nlmsg_data(_hdr)        ((void *)((_hdr) + 1))</p><p>+</p><p>+/*</p><p>+ * KPI similar to mtodo():</p><p>+ * current (uncompleted) header is guaranteed to be contiguous,</p><p>+ *  but can be reallocated, thus pointers may need to be readjusted.</p><p>+ */</p><p>+static inline int</p><p>+nlattr_save_offset(const struct nl_writer *nw)</p><p>+{</p><p>+        return (nw-&gt;offset - ((char *)nw-&gt;hdr - nw-&gt;data));</p><p>+}</p><p>+</p><p>+static inline void *</p><p>+_nlattr_restore_offset(const struct nl_writer *nw, int off)</p><p>+{</p><p>+	return ((void *)((char *)nw-&gt;hdr + off));</p><p>+}</p><p>+#define	nlattr_restore_offset(_ns, _off, _t)	((_t *)_nlattr_restore_offset(_ns, _off))</p><p>+</p><p>+static inline void</p><p>+nlattr_set_len(const struct nl_writer *nw, int off)</p><p>+{</p><p>+	struct nlattr *nla = nlattr_restore_offset(nw, off, struct nlattr);</p><p>+	nla-&gt;nla_len = nlattr_save_offset(nw) - off;</p><p>+}</p><p>+</p><p>+static inline void *</p><p>+nlmsg_reserve_data_raw(struct nl_writer *nw, size_t sz)</p><p>+{</p><p>+        if (__predict_false(nw-&gt;offset + NETLINK_ALIGN(sz) &gt; nw-&gt;alloc_len)) {</p><p>+		if (!nlmsg_refill_buffer(nw, NETLINK_ALIGN(sz)))</p><p>+			return (NULL);</p><p>+        }</p><p>+</p><p>+        void *data_ptr = &amp;nw-&gt;data[nw-&gt;offset];</p><p>+        nw-&gt;offset += NLMSG_ALIGN(sz);</p><p>+</p><p>+        return (data_ptr);</p><p>+}</p><p>+#define nlmsg_reserve_object(_ns, _t)	((_t *)nlmsg_reserve_data_raw(_ns, NLA_ALIGN(sizeof(_t))))</p><p>+#define nlmsg_reserve_data(_ns, _sz, _t)	((_t *)nlmsg_reserve_data_raw(_ns, _sz))</p><p>+</p><p>+static inline int</p><p>+nlattr_add_nested(struct nl_writer *nw, uint16_t nla_type)</p><p>+{</p><p>+	int off = nlattr_save_offset(nw);</p><p>+	struct nlattr *nla = nlmsg_reserve_data(nw, sizeof(struct nlattr), struct nlattr);</p><p>+	if (__predict_false(nla == NULL))</p><p>+		return (0);</p><p>+	nla-&gt;nla_type = nla_type;</p><p>+	return (off);</p><p>+}</p><p>+</p><p>+static inline void *</p><p>+_nlmsg_reserve_attr(struct nl_writer *nw, uint16_t nla_type, uint16_t sz)</p><p>+{</p><p>+	sz += sizeof(struct nlattr);</p><p>+</p><p>+	struct nlattr *nla = nlmsg_reserve_data(nw, sz, struct nlattr);</p><p>+	if (__predict_false(nla == NULL))</p><p>+		return (NULL);</p><p>+	nla-&gt;nla_type = nla_type;</p><p>+	nla-&gt;nla_len = sz;</p><p>+</p><p>+	return ((void *)(nla + 1));</p><p>+}</p><p>+#define	nlmsg_reserve_attr(_ns, _at, _t)	((_t *)_nlmsg_reserve_attr(_ns, _at, NLA_ALIGN(sizeof(_t))))</p><p>+</p><p>+static inline bool</p><p>+nlattr_add(struct nl_writer *nw, int attr_type, int attr_len, const void *data)</p><p>+{</p><p>+	int required_len = NLA_ALIGN(attr_len + sizeof(struct nlattr));</p><p>+</p><p>+        if (__predict_false(nw-&gt;offset + required_len &gt; nw-&gt;alloc_len)) {</p><p>+		if (!nlmsg_refill_buffer(nw, required_len))</p><p>+			return (false);</p><p>+	}</p><p>+</p><p>+        struct nlattr *nla = (struct nlattr *)(&amp;nw-&gt;data[nw-&gt;offset]);</p><p>+</p><p>+        nla-&gt;nla_len = attr_len + sizeof(struct nlattr);</p><p>+        nla-&gt;nla_type = attr_type;</p><p>+        if (attr_len &gt; 0) {</p><p>+		if ((attr_len % 4) != 0) {</p><p>+			/* clear padding bytes */</p><p>+			bzero((char *)nla + required_len - 4, 4);</p><p>+		}</p><p>+                memcpy((nla + 1), data, attr_len);</p><p>+	}</p><p>+        nw-&gt;offset += required_len;</p><p>+        return (true);</p><p>+}</p><p>+</p><p>+static inline bool</p><p>+nlattr_add_u8(struct nl_writer *nw, int attrtype, uint8_t value)</p><p>+{</p><p>+	return (nlattr_add(nw, attrtype, sizeof(uint8_t), &amp;value));</p><p>+}</p><p>+</p><p>+static inline bool</p><p>+nlattr_add_u16(struct nl_writer *nw, int attrtype, uint16_t value)</p><p>+{</p><p>+	return (nlattr_add(nw, attrtype, sizeof(uint16_t), &amp;value));</p><p>+}</p><p>+</p><p>+static inline bool</p><p>+nlattr_add_u32(struct nl_writer *nw, int attrtype, uint32_t value)</p><p>+{</p><p>+	return (nlattr_add(nw, attrtype, sizeof(uint32_t), &amp;value));</p><p>+}</p><p>+</p><p>+static inline bool</p><p>+nlattr_add_u64(struct nl_writer *nw, int attrtype, uint64_t value)</p><p>+{</p><p>+	return (nlattr_add(nw, attrtype, sizeof(uint64_t), &amp;value));</p><p>+}</p><p>+</p><p>+static inline bool</p><p>+nlattr_add_s8(struct nl_writer *nw, int attrtype, int8_t value)</p><p>+{</p><p>+	return (nlattr_add(nw, attrtype, sizeof(int8_t), &amp;value));</p><p>+}</p><p>+</p><p>+static inline bool</p><p>+nlattr_add_s16(struct nl_writer *nw, int attrtype, int16_t value)</p><p>+{</p><p>+	return (nlattr_add(nw, attrtype, sizeof(int16_t), &amp;value));</p><p>+}</p><p>+</p><p>+static inline bool</p><p>+nlattr_add_s32(struct nl_writer *nw, int attrtype, int32_t value)</p><p>+{</p><p>+	return (nlattr_add(nw, attrtype, sizeof(int32_t), &amp;value));</p><p>+}</p><p>+</p><p>+static inline bool</p><p>+nlattr_add_s64(struct nl_writer *nw, int attrtype, int64_t value)</p><p>+{</p><p>+	return (nlattr_add(nw, attrtype, sizeof(int64_t), &amp;value));</p><p>+}</p><p>+</p><p>+static inline bool</p><p>+nlattr_add_flag(struct nl_writer *nw, int attrtype)</p><p>+{</p><p>+	return (nlattr_add(nw, attrtype, 0, NULL));</p><p>+}</p><p>+</p><p>+static inline bool</p><p>+nlattr_add_string(struct nl_writer *nw, int attrtype, const char *str)</p><p>+{</p><p>+	return (nlattr_add(nw, attrtype, strlen(str) + 1, str));</p><p>+}</p><p>+</p><p>+</p><p>+#endif</p><div><p>diff --git a/sys/netlink/netlink_module.c b/sys/netlink/netlink_module.c</p></div><p>@@ -0,0 +1,228 @@</p><p>+/*-</p><p>+ * SPDX-License-Identifier: BSD-2-Clause-FreeBSD</p><p>+ *</p><p>+ * Copyright (c) 2021 Ng Peng Nam Sean</p><p>+ * Copyright (c) 2022 Alexander V. Chernikov &lt;melifaro@FreeBSD.org&gt;</p><p>+ *</p><p>+ * Redistribution and use in source and binary forms, with or without</p><p>+ * modification, are permitted provided that the following conditions</p><p>+ * are met:</p><p>+ * 1. Redistributions of source code must retain the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer.</p><p>+ * 2. Redistributions in binary form must reproduce the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer in the</p><p>+ *    documentation and/or other materials provided with the distribution.</p><p>+ *</p><p>+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&#39;&#39; AND</p><p>+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</p><p>+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</p><p>+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE</p><p>+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</p><p>+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</p><p>+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</p><p>+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</p><p>+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</p><p>+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</p><p>+ * SUCH DAMAGE.</p><p>+ */</p><p>+</p><p>+#include &lt;sys/cdefs.h&gt;</p><p>+__FBSDID(&#34;$FreeBSD$&#34;);</p><p>+#include &lt;sys/param.h&gt;</p><p>+#include &lt;sys/malloc.h&gt;</p><p>+#include &lt;sys/module.h&gt;</p><p>+</p><p>+#include &lt;sys/lock.h&gt;</p><p>+#include &lt;sys/rmlock.h&gt;</p><p>+#include &lt;sys/ck.h&gt;</p><p>+#include &lt;sys/syslog.h&gt;</p><p>+</p><p>+#include &lt;netlink/netlink.h&gt;</p><p>+#include &lt;netlink/netlink_ctl.h&gt;</p><p>+#include &lt;netlink/netlink_var.h&gt;</p><p>+</p><p>+#include &lt;machine/atomic.h&gt;</p><p>+</p><p>+MALLOC_DEFINE(M_NETLINK, &#34;netlink&#34;, &#34;Memory used for netlink packets&#34;);</p><p>+</p><p>+#define	DEBUG_MOD_NAME	nl_mod</p><p>+#define	DEBUG_MAX_LEVEL	LOG_DEBUG3</p><p>+#include &lt;netlink/netlink_debug.h&gt;</p><p>+_DECLARE_DEBUG(LOG_DEBUG);</p><p>+</p><p>+SYSCTL_NODE(_net, OID_AUTO, netlink, CTLFLAG_RD, 0, &#34;&#34;);</p><p>+SYSCTL_NODE(_net_netlink, OID_AUTO, debug, CTLFLAG_RD | CTLFLAG_MPSAFE, 0, &#34;&#34;);</p><p>+</p><p>+#define NL_MAX_HANDLERS	20</p><p>+struct nl_proto_handler _nl_handlers[NL_MAX_HANDLERS];</p><p>+struct nl_proto_handler *nl_handlers = _nl_handlers;</p><p>+</p><p>+CK_LIST_HEAD(nl_control_head, nl_control);</p><p>+static struct nl_control_head vnets_head = CK_LIST_HEAD_INITIALIZER();</p><p>+</p><p>+VNET_DEFINE(struct nl_control *, nl_ctl) = NULL;</p><p>+</p><p>+struct mtx nl_global_mtx;</p><p>+MTX_SYSINIT(nl_global_mtx, &amp;nl_global_mtx, &#34;global netlink lock&#34;, MTX_DEF);</p><p>+</p><p>+#define NL_GLOBAL_LOCK()	mtx_lock(&amp;nl_global_mtx)</p><p>+#define NL_GLOBAL_UNLOCK()	mtx_unlock(&amp;nl_global_mtx)</p><p>+</p><p>+int netlink_unloading = 0;</p><p>+</p><p>+static void</p><p>+free_nl_ctl(struct nl_control *ctl)</p><p>+{</p><p>+	rm_destroy(&amp;ctl-&gt;ctl_lock);</p><p>+	free(ctl, M_NETLINK);</p><p>+}</p><p>+</p><p>+struct nl_control *</p><p>+vnet_nl_ctl_init(void)</p><p>+{</p><p>+	struct nl_control *ctl;</p><p>+</p><p>+	ctl = malloc(sizeof(struct nl_control), M_NETLINK, M_WAITOK | M_ZERO);</p><p>+	rm_init(&amp;ctl-&gt;ctl_lock, &#34;netlink lock&#34;);</p><p>+	CK_LIST_INIT(&amp;ctl-&gt;ctl_port_head);</p><p>+	CK_LIST_INIT(&amp;ctl-&gt;ctl_pcb_head);</p><p>+</p><p>+	NL_GLOBAL_LOCK();</p><p>+</p><p>+	struct nl_control *tmp = atomic_load_ptr(&amp;V_nl_ctl);</p><p>+</p><p>+	if (tmp == NULL) {</p><p>+		atomic_store_ptr(&amp;V_nl_ctl, ctl);</p><p>+		CK_LIST_INSERT_HEAD(&amp;vnets_head, ctl, ctl_next);</p><p>+		NL_LOG(LOG_DEBUG2, &#34;VNET %p init done, inserted %p into global list&#34;,</p><p>+		    curvnet, ctl);</p><p>+	} else {</p><p>+		NL_LOG(LOG_DEBUG, &#34;per-VNET init clash, dropping this instance&#34;);</p><p>+		free_nl_ctl(ctl);</p><p>+		ctl = tmp;</p><p>+	}</p><p>+</p><p>+	NL_GLOBAL_UNLOCK();</p><p>+</p><p>+	return (ctl);</p><p>+}</p><p>+</p><p>+static void</p><p>+vnet_nl_ctl_destroy(const void *unused __unused)</p><p>+{</p><p>+	struct nl_control *ctl;</p><p>+</p><p>+	/* Assume at the time all of the processes / sockets are dead */</p><p>+</p><p>+	NL_GLOBAL_LOCK();</p><p>+	ctl = atomic_load_ptr(&amp;V_nl_ctl);</p><p>+	atomic_store_ptr(&amp;V_nl_ctl, NULL);</p><p>+	if (ctl != NULL) {</p><p>+		NL_LOG(LOG_DEBUG2, &#34;Removing %p from global list&#34;, ctl);</p><p>+		CK_LIST_REMOVE(ctl, ctl_next);</p><p>+	}</p><p>+	NL_GLOBAL_UNLOCK();</p><p>+</p><p>+	if (ctl != NULL)</p><p>+		free_nl_ctl(ctl);</p><p>+}</p><p>+VNET_SYSUNINIT(vnet_nl_ctl_destroy, SI_SUB_PROTO_IF, SI_ORDER_ANY,</p><p>+    vnet_nl_ctl_destroy, NULL);</p><p>+</p><p>+int</p><p>+nl_verify_proto(int proto)</p><p>+{</p><p>+	if (proto &lt; 0 || proto &gt;= NL_MAX_HANDLERS) {</p><p>+		return (EINVAL);</p><p>+	}</p><p>+	int handler_defined = nl_handlers[proto].cb != NULL;</p><p>+	return (handler_defined ? 0 : EPROTONOSUPPORT);</p><p>+}</p><p>+</p><p>+const char *</p><p>+nl_get_proto_name(int proto)</p><p>+{</p><p>+	return (nl_handlers[proto].proto_name);</p><p>+}</p><p>+</p><p>+bool</p><p>+netlink_register_proto(int proto, const char *proto_name, nl_handler_f handler)</p><p>+{</p><p>+	if ((proto &lt; 0) || (proto &gt;= NL_MAX_HANDLERS))</p><p>+		return (false);</p><p>+	NL_GLOBAL_LOCK();</p><p>+	KASSERT((nl_handlers[proto].cb == NULL), (&#34;netlink handler %d is already set&#34;, proto));</p><p>+	nl_handlers[proto].cb = handler;</p><p>+	nl_handlers[proto].proto_name = proto_name;</p><p>+	NL_GLOBAL_UNLOCK();</p><p>+	NL_LOG(LOG_DEBUG, &#34;Registered netlink %s(%d) handler&#34;, proto_name, proto);</p><p>+	return (true);</p><p>+}</p><p>+</p><p>+bool</p><p>+netlink_unregister_proto(int proto)</p><p>+{</p><p>+	if ((proto &lt; 0) || (proto &gt;= NL_MAX_HANDLERS))</p><p>+		return (false);</p><p>+	NL_GLOBAL_LOCK();</p><p>+	KASSERT((nl_handlers[proto].cb != NULL), (&#34;netlink handler %d is not set&#34;, proto));</p><p>+	nl_handlers[proto].cb = NULL;</p><p>+	nl_handlers[proto].proto_name = NULL;</p><p>+	NL_GLOBAL_UNLOCK();</p><p>+	NL_LOG(LOG_DEBUG, &#34;Unregistered netlink proto %d handler&#34;, proto);</p><p>+	return (true);</p><p>+}</p><p>+</p><p>+static bool</p><p>+can_unload(void)</p><p>+{</p><p>+	struct nl_control *ctl;</p><p>+	bool result = true;</p><p>+</p><p>+	NL_GLOBAL_LOCK();</p><p>+</p><p>+	CK_LIST_FOREACH(ctl, &amp;vnets_head, ctl_next) {</p><p>+		NL_LOG(LOG_DEBUG2, &#34;Iterating VNET head %p&#34;, ctl);</p><p>+		if (!CK_LIST_EMPTY(&amp;ctl-&gt;ctl_pcb_head)) {</p><p>+			NL_LOG(LOG_NOTICE, &#34;non-empty socket list in ctl %p&#34;, ctl);</p><p>+			result = false;</p><p>+			break;</p><p>+		}</p><p>+	}</p><p>+</p><p>+	NL_GLOBAL_UNLOCK();</p><p>+</p><p>+	return (result);</p><p>+}</p><p>+</p><p>+static int</p><p>+netlink_modevent(module_t mod __unused, int what, void *priv __unused)</p><p>+{</p><p>+	int ret = 0;</p><p>+</p><p>+	switch (what) {</p><p>+	case MOD_LOAD:</p><p>+		NL_LOG(LOG_DEBUG, &#34;Loading&#34;);</p><p>+		NL_LOG(LOG_NOTICE, &#34;netlink support is in BETA stage&#34;);</p><p>+		break;</p><p>+</p><p>+	case MOD_UNLOAD:</p><p>+		NL_LOG(LOG_DEBUG, &#34;Unload called&#34;);</p><p>+		if (can_unload()) {</p><p>+			NL_LOG(LOG_WARNING, &#34;unloading&#34;);</p><p>+			netlink_unloading = 1;</p><p>+		} else</p><p>+			ret = EBUSY;</p><p>+		break;</p><p>+</p><p>+	default:</p><p>+		ret = EOPNOTSUPP;</p><p>+		break;</p><p>+	}</p><p>+</p><p>+	return (ret);</p><p>+}</p><p>+static moduledata_t netlink_mod = { &#34;netlink&#34;, netlink_modevent, NULL };</p><p>+</p><p>+DECLARE_MODULE(netlink, netlink_mod, SI_SUB_PSEUDO, SI_ORDER_ANY);</p><p>+MODULE_VERSION(netlink, 1);</p><div><p>diff --git a/sys/netlink/netlink_route.c b/sys/netlink/netlink_route.c</p></div><p>@@ -0,0 +1,135 @@</p><p>+/*-</p><p>+ * SPDX-License-Identifier: BSD-2-Clause-FreeBSD</p><p>+ *</p><p>+ * Copyright (c) 2022 Alexander V. Chernikov &lt;melifaro@FreeBSD.org&gt;</p><p>+ *</p><p>+ * Redistribution and use in source and binary forms, with or without</p><p>+ * modification, are permitted provided that the following conditions</p><p>+ * are met:</p><p>+ * 1. Redistributions of source code must retain the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer.</p><p>+ * 2. Redistributions in binary form must reproduce the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer in the</p><p>+ *    documentation and/or other materials provided with the distribution.</p><p>+ *</p><p>+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&#39;&#39; AND</p><p>+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</p><p>+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</p><p>+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE</p><p>+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</p><p>+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</p><p>+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</p><p>+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</p><p>+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</p><p>+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</p><p>+ * SUCH DAMAGE.</p><p>+ */</p><p>+</p><p>+#include &lt;sys/cdefs.h&gt;</p><p>+__FBSDID(&#34;$FreeBSD$&#34;);</p><p>+#include &lt;sys/types.h&gt;</p><p>+#include &lt;sys/malloc.h&gt;</p><p>+#include &lt;sys/socket.h&gt;</p><p>+#include &lt;sys/ck.h&gt;</p><p>+</p><p>+#include &lt;net/route.h&gt;</p><p>+#include &lt;net/route/route_ctl.h&gt;</p><p>+#include &lt;netlink/netlink.h&gt;</p><p>+#include &lt;netlink/netlink_ctl.h&gt;</p><p>+#include &lt;netlink/netlink_var.h&gt;</p><p>+#include &lt;netlink/netlink_route.h&gt;</p><p>+#include &lt;netlink/route/route_var.h&gt;</p><p>+</p><p>+#define	DEBUG_MOD_NAME	nl_route_core</p><p>+#define	DEBUG_MAX_LEVEL	LOG_DEBUG3</p><p>+#include &lt;netlink/netlink_debug.h&gt;</p><p>+_DECLARE_DEBUG(LOG_DEBUG);</p><p>+</p><p>+#define	HANDLER_MAX_NUM	(NL_RTM_MAX + 10)</p><p>+static const struct rtnl_cmd_handler *rtnl_handler[HANDLER_MAX_NUM] = {};</p><p>+</p><p>+bool</p><p>+rtnl_register_messages(const struct rtnl_cmd_handler *handlers, int count)</p><p>+{</p><p>+	for (int i = 0; i &lt; count; i++) {</p><p>+		if (handlers[i].cmd &gt;= HANDLER_MAX_NUM)</p><p>+			return (false);</p><p>+		MPASS(rtnl_handler[handlers[i].cmd] == NULL);</p><p>+	}</p><p>+	for (int i = 0; i &lt; count; i++)</p><p>+		rtnl_handler[handlers[i].cmd] = &amp;handlers[i];</p><p>+	return (true);</p><p>+}</p><p>+</p><p>+/*</p><p>+ * Handler called by netlink subsystem when matching netlink message is received</p><p>+ */</p><p>+static int</p><p>+rtnl_handle_message(struct nlmsghdr *hdr, struct nl_pstate *npt)</p><p>+{</p><p>+	const struct rtnl_cmd_handler *cmd;</p><p>+	struct epoch_tracker et;</p><p>+	struct nlpcb *nlp = npt-&gt;nlp;</p><p>+	int error = 0;</p><p>+</p><p>+	if (__predict_false(hdr-&gt;nlmsg_type &gt;= HANDLER_MAX_NUM)) {</p><p>+		NLMSG_REPORT_ERR_MSG(npt, &#34;unknown message type: %d&#34;, hdr-&gt;nlmsg_type);</p><p>+		return (ENOTSUP);</p><p>+	}</p><p>+</p><p>+	cmd = rtnl_handler[hdr-&gt;nlmsg_type];</p><p>+	if (__predict_false(cmd == NULL)) {</p><p>+		NLMSG_REPORT_ERR_MSG(npt, &#34;unknown message type: %d&#34;, hdr-&gt;nlmsg_type);</p><p>+		return (ENOTSUP);</p><p>+	}</p><p>+</p><p>+	NLP_LOG(LOG_DEBUG2, nlp, &#34;received msg %s(%d) len %d&#34;, cmd-&gt;name,</p><p>+	    hdr-&gt;nlmsg_type, hdr-&gt;nlmsg_len);</p><p>+</p><p>+	if (cmd-&gt;priv != 0 &amp;&amp; !nlp_has_priv(nlp, cmd-&gt;priv)) {</p><p>+		NLP_LOG(LOG_DEBUG2, nlp, &#34;priv %d check failed for msg %s&#34;, cmd-&gt;priv, cmd-&gt;name);</p><p>+		return (EPERM);</p><p>+	} else if (cmd-&gt;priv != 0)</p><p>+		NLP_LOG(LOG_DEBUG3, nlp, &#34;priv %d check passed for msg %s&#34;, cmd-&gt;priv, cmd-&gt;name);</p><p>+</p><p>+	bool need_epoch = !(cmd-&gt;flags &amp; RTNL_F_NOEPOCH);</p><p>+</p><p>+	if (need_epoch)</p><p>+		NET_EPOCH_ENTER(et);</p><p>+	error = cmd-&gt;cb(hdr, nlp, npt);</p><p>+	if (need_epoch)</p><p>+		NET_EPOCH_EXIT(et);</p><p>+</p><p>+	NLP_LOG(LOG_DEBUG3, nlp, &#34;message %s -&gt; error %d&#34;, cmd-&gt;name, error);</p><p>+</p><p>+	return (error);</p><p>+}</p><p>+</p><p>+static struct rtbridge nlbridge = { .route_f = rtnl_handle_route_event };</p><p>+static struct rtbridge *nlbridge_orig_p;</p><p>+</p><p>+static void</p><p>+rtnl_load(void *u __unused)</p><p>+{</p><p>+	NL_LOG(LOG_NOTICE, &#34;rtnl loading&#34;);</p><p>+	nlbridge_orig_p = netlink_callback_p;</p><p>+	netlink_callback_p = &amp;nlbridge;</p><p>+	rtnl_neighs_init();</p><p>+	rtnl_ifaces_init();</p><p>+	rtnl_nexthops_init();</p><p>+	rtnl_routes_init();</p><p>+	netlink_register_proto(NETLINK_ROUTE, &#34;NETLINK_ROUTE&#34;, rtnl_handle_message);</p><p>+}</p><p>+SYSINIT(rtnl_load, SI_SUB_PROTO_DOMAIN, SI_ORDER_THIRD, rtnl_load, NULL);</p><p>+</p><p>+static void</p><p>+rtnl_unload(void *u __unused)</p><p>+{</p><p>+	netlink_callback_p = nlbridge_orig_p;</p><p>+	rtnl_ifaces_destroy();</p><p>+	rtnl_neighs_destroy();</p><p>+</p><p>+	/* Wait till all consumers read nlbridge data */</p><p>+	epoch_wait_preempt(net_epoch_preempt);</p><p>+}</p><p>+SYSUNINIT(rtnl_unload, SI_SUB_PROTO_DOMAIN, SI_ORDER_THIRD, rtnl_unload, NULL);</p><div><p>diff --git a/sys/netlink/netlink_route.h b/sys/netlink/netlink_route.h</p></div><p>@@ -0,0 +1,43 @@</p><p>+/*-</p><p>+ * SPDX-License-Identifier: BSD-2-Clause-FreeBSD</p><p>+ *</p><p>+ * Copyright (c) 2022 Alexander V. Chernikov &lt;melifaro@FreeBSD.org&gt;</p><p>+ *</p><p>+ * Redistribution and use in source and binary forms, with or without</p><p>+ * modification, are permitted provided that the following conditions</p><p>+ * are met:</p><p>+ * 1. Redistributions of source code must retain the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer.</p><p>+ * 2. Redistributions in binary form must reproduce the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer in the</p><p>+ *    documentation and/or other materials provided with the distribution.</p><p>+ *</p><p>+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&#39;&#39; AND</p><p>+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</p><p>+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</p><p>+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE</p><p>+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</p><p>+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</p><p>+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</p><p>+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</p><p>+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</p><p>+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</p><p>+ * SUCH DAMAGE.</p><p>+ */</p><p>+#ifndef _NETLINK_NETLINK_ROUTE_H_</p><p>+#define	_NETLINK_NETLINK_ROUTE_H_</p><p>+</p><p>+#include &lt;sys/types.h&gt;</p><p>+</p><p>+#include &lt;net/if.h&gt;</p><p>+#include &lt;net/if_types.h&gt;</p><p>+#include &lt;net/if_var.h&gt;</p><p>+</p><p>+#include &lt;netlink/route/common.h&gt;</p><p>+#include &lt;netlink/route/ifaddrs.h&gt;</p><p>+#include &lt;netlink/route/interface.h&gt;</p><p>+#include &lt;netlink/route/neigh.h&gt;</p><p>+#include &lt;netlink/route/route.h&gt;</p><p>+#include &lt;netlink/route/nexthop.h&gt;</p><p>+</p><p>+#endif</p><div><p>diff --git a/sys/netlink/netlink_var.h b/sys/netlink/netlink_var.h</p></div><p>@@ -0,0 +1,142 @@</p><p>+/*-</p><p>+ * SPDX-License-Identifier: BSD-2-Clause-FreeBSD</p><p>+ *</p><p>+ * Copyright (c) 2021 Ng Peng Nam Sean</p><p>+ * Copyright (c) 2022 Alexander V. Chernikov &lt;melifaro@FreeBSD.org&gt;</p><p>+ *</p><p>+ * Redistribution and use in source and binary forms, with or without</p><p>+ * modification, are permitted provided that the following conditions</p><p>+ * are met:</p><p>+ * 1. Redistributions of source code must retain the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer.</p><p>+ * 2. Redistributions in binary form must reproduce the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer in the</p><p>+ *    documentation and/or other materials provided with the distribution.</p><p>+ *</p><p>+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&#39;&#39; AND</p><p>+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</p><p>+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</p><p>+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE</p><p>+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</p><p>+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</p><p>+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</p><p>+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</p><p>+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</p><p>+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</p><p>+ * SUCH DAMAGE.</p><p>+ */</p><p>+#ifndef _NETLINK_NETLINK_VAR_H_</p><p>+#define _NETLINK_NETLINK_VAR_H_</p><p>+</p><p>+#include &lt;sys/ck.h&gt;</p><p>+#include &lt;sys/epoch.h&gt;</p><p>+#include &lt;sys/sysctl.h&gt;</p><p>+#include &lt;sys/taskqueue.h&gt;</p><p>+#include &lt;net/vnet.h&gt;</p><p>+</p><p>+#define	NLSNDQ  65536 /* Default socket sendspace */</p><p>+#define	NLRCVQ	65536 /* Default socket recvspace */</p><p>+</p><p>+struct ucred;</p><p>+</p><p>+struct nl_io_queue {</p><p>+	STAILQ_HEAD(, mbuf)	head;</p><p>+	int			length;</p><p>+	int			hiwat;</p><p>+};</p><p>+</p><p>+struct nlpcb {</p><p>+        struct socket           *nl_socket;</p><p>+	uint64_t	        nl_groups;</p><p>+	uint32_t                nl_port;</p><p>+	uint32_t	        nl_flags;</p><p>+	uint32_t	        nl_process_id;</p><p>+        int                     nl_proto;</p><p>+        bool			nl_active;</p><p>+	bool			nl_bound;</p><p>+        bool			nl_task_pending;</p><p>+	bool			nl_tx_blocked; /* No new requests accepted */</p><p>+	bool			nl_linux; /* true if running under compat */</p><p>+	struct nl_io_queue	rx_queue;</p><p>+	struct nl_io_queue	tx_queue;</p><p>+	struct taskqueue	*nl_taskqueue;</p><p>+	struct task		nl_task;</p><p>+	struct ucred		*nl_cred; /* Copy of nl_socket-&gt;so_cred */</p><p>+	uint64_t		nl_dropped_bytes;</p><p>+	uint64_t		nl_dropped_messages;</p><p>+        CK_LIST_ENTRY(nlpcb)    nl_next;</p><p>+        CK_LIST_ENTRY(nlpcb)    nl_port_next;</p><p>+	volatile u_int		nl_refcount;</p><p>+	struct mtx		nl_lock;</p><p>+	struct epoch_context	nl_epoch_ctx;</p><p>+};</p><p>+#define sotonlpcb(so)       ((struct nlpcb *)(so)-&gt;so_pcb)</p><p>+</p><p>+#define	NLP_LOCK_INIT(_nlp)	mtx_init(&amp;((_nlp)-&gt;nl_lock), &#34;nlp mtx&#34;, NULL, MTX_DEF)</p><p>+#define	NLP_LOCK_DESTROY(_nlp)	mtx_destroy(&amp;((_nlp)-&gt;nl_lock))</p><p>+#define	NLP_LOCK(_nlp)		mtx_lock(&amp;((_nlp)-&gt;nl_lock))</p><p>+#define	NLP_UNLOCK(_nlp)	mtx_unlock(&amp;((_nlp)-&gt;nl_lock))</p><p>+</p><p>+#define	ALIGNED_NL_SZ(_data)	roundup2((((struct nlmsghdr *)(_data))-&gt;nlmsg_len), 16)</p><p>+</p><p>+/* nl_flags */</p><p>+#define NLF_CAP_ACK             0x01 /* Do not send message body with errmsg */</p><p>+#define NLF_EXT_ACK             0x02 /* Allow including extended TLVs in ack */</p><p>+#define	NLF_STRICT		0x04 /* Perform strict header checks */</p><p>+</p><p>+SYSCTL_DECL(_net_netlink);</p><p>+</p><p>+struct nl_io {</p><p>+	struct callout				callout;</p><p>+	struct mbuf				*head;</p><p>+	struct mbuf 				*last;</p><p>+	int64_t					length;</p><p>+};</p><p>+</p><p>+struct nl_control {</p><p>+	CK_LIST_HEAD(nl_pid_head, nlpcb)	ctl_port_head;</p><p>+	CK_LIST_HEAD(nlpcb_head, nlpcb)		ctl_pcb_head;</p><p>+	CK_LIST_ENTRY(nl_control)		ctl_next;</p><p>+	struct nl_io				ctl_io;</p><p>+	struct rmlock				ctl_lock;</p><p>+};</p><p>+VNET_DECLARE(struct nl_control *, nl_ctl);</p><p>+#define	V_nl_ctl	VNET(nl_ctl)</p><p>+</p><p>+</p><p>+struct sockaddr_nl;</p><p>+struct sockaddr;</p><p>+struct nlmsghdr;</p><p>+</p><p>+/* netlink_module.c */</p><p>+struct nl_control *vnet_nl_ctl_init(void);</p><p>+</p><p>+int nl_verify_proto(int proto);</p><p>+const char *nl_get_proto_name(int proto);</p><p>+</p><p>+extern int netlink_unloading;</p><p>+</p><p>+struct nl_proto_handler {</p><p>+	nl_handler_f	cb;</p><p>+	const char	*proto_name;</p><p>+};</p><p>+extern struct nl_proto_handler *nl_handlers;</p><p>+</p><p>+/* netlink_domain.c */</p><p>+void nl_send_group(struct mbuf *m, int cnt, int proto, int group_id);</p><p>+</p><p>+/* netlink_io.c */</p><p>+#define	NL_IOF_UNTRANSLATED	0x01</p><p>+#define	NL_IOF_IGNORE_LIMIT	0x02</p><p>+bool nl_send_one(struct mbuf *m, struct nlpcb *nlp, int cnt, int io_flags);</p><p>+void nlmsg_ack(struct nlpcb *nlp, int error, struct nlmsghdr *nlmsg,</p><p>+    struct nl_pstate *npt);</p><p>+void nl_on_transmit(struct nlpcb *nlp);</p><p>+void nl_init_io(struct nlpcb *nlp);</p><p>+void nl_free_io(struct nlpcb *nlp);</p><p>+</p><p>+void nl_taskqueue_handler(void *_arg, int pending);</p><p>+int nl_receive_async(struct mbuf *m, struct socket *so);</p><p>+void nl_process_receive_locked(struct nlpcb *nlp);</p><p>+</p><p>+#endif</p><div><p>diff --git a/sys/netlink/route/common.h b/sys/netlink/route/common.h</p></div><p>@@ -0,0 +1,213 @@</p><p>+/*-</p><p>+ * SPDX-License-Identifier: BSD-2-Clause-FreeBSD</p><p>+ *</p><p>+ * Copyright (c) 2022 Alexander V. Chernikov &lt;melifaro@FreeBSD.org&gt;</p><p>+ *</p><p>+ * Redistribution and use in source and binary forms, with or without</p><p>+ * modification, are permitted provided that the following conditions</p><p>+ * are met:</p><p>+ * 1. Redistributions of source code must retain the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer.</p><p>+ * 2. Redistributions in binary form must reproduce the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer in the</p><p>+ *    documentation and/or other materials provided with the distribution.</p><p>+ *</p><p>+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&#39;&#39; AND</p><p>+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</p><p>+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</p><p>+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE</p><p>+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</p><p>+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</p><p>+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</p><p>+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</p><p>+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</p><p>+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</p><p>+ * SUCH DAMAGE.</p><p>+ */</p><p>+</p><p>+/*</p><p>+ * Common defines for all parts of the NETLINK_ROUTE family</p><p>+ */</p><p>+#ifndef _NETLINK_ROUTE_COMMON_H_</p><p>+#define _NETLINK_ROUTE_COMMON_H_</p><p>+</p><p>+/* Defined NETLINK_ROUTE messages */</p><p>+enum {</p><p>+	NL_RTM_BASE		= 16,</p><p>+	NL_RTM_NEWLINK		= 16, /* creates new interface */</p><p>+	NL_RTM_DELLINK		= 17, /* deletes matching interface */</p><p>+	NL_RTM_GETLINK		= 18, /* lists matching interfaces */</p><p>+	NL_RTM_SETLINK		= 19, /* not supported */</p><p>+	NL_RTM_NEWADDR		= 20, /* not supported */</p><p>+	NL_RTM_DELADDR		= 21, /* not supported */</p><p>+	NL_RTM_GETADDR		= 22, /* lists matching ifaddrs */</p><p>+	NL_RTM_NEWROUTE		= 24, /* adds or changes a route */</p><p>+	NL_RTM_DELROUTE		= 25, /* deletes matching route */</p><p>+	NL_RTM_GETROUTE		= 26, /* lists matching routes */</p><p>+	NL_RTM_NEWNEIGH		= 28, /* creates new arp/ndp entry */</p><p>+	NL_RTM_DELNEIGH		= 29, /* deletes matching arp/ndp entry */</p><p>+	NL_RTM_GETNEIGH		= 30, /* lists matching arp/ndp entry */</p><p>+	NL_RTM_NEWRULE		= 32, /* not supported */</p><p>+	NL_RTM_DELRULE		= 33, /* not supported */</p><p>+	NL_RTM_GETRULE		= 34, /* not supported */</p><p>+	NL_RTM_NEWQDISC		= 36, /* not supported */</p><p>+	NL_RTM_DELQDISC		= 37, /* not supported */</p><p>+	NL_RTM_GETQDISC		= 38, /* not supported */</p><p>+	NL_RTM_NEWTCLASS	= 40, /* not supported */</p><p>+	NL_RTM_DELTCLASS	= 41, /* not supported */</p><p>+	NL_RTM_GETTCLASS	= 42, /* not supported */</p><p>+	NL_RTM_NEWTFILTER	= 44, /* not supported */</p><p>+	NL_RTM_DELTFILTER	= 45, /* not supported */</p><p>+	NL_RTM_GETTFILTER	= 46, /* not supported */</p><p>+	NL_RTM_NEWACTION	= 48, /* not supported */</p><p>+	NL_RTM_DELACTION	= 49, /* not supported */</p><p>+	NL_RTM_GETACTION	= 50, /* not supported */</p><p>+	NL_RTM_NEWPREFIX	= 52, /* not supported */</p><p>+	NL_RTM_GETMULTICAST	= 58, /* not supported */</p><p>+	NL_RTM_GETANYCAST	= 62, /* not supported */</p><p>+	NL_RTM_NEWNEIGHTBL	= 64, /* not supported */</p><p>+	NL_RTM_GETNEIGHTBL	= 66, /* not supported */</p><p>+	NL_RTM_SETNEIGHTBL	= 67, /* not supported */</p><p>+	NL_RTM_NEWNDUSEROPT	= 68, /* not supported */</p><p>+	NL_RTM_NEWADDRLABEL	= 72, /* not supported */</p><p>+	NL_RTM_DELADDRLABEL	= 73, /* not supported */</p><p>+	NL_RTM_GETADDRLABEL	= 74, /* not supported */</p><p>+	NL_RTM_GETDCB		= 78, /* not supported */</p><p>+	NL_RTM_SETDCB		= 79, /* not supported */</p><p>+	NL_RTM_NEWNETCONF	= 80, /* not supported */</p><p>+	NL_RTM_GETNETCONF	= 82, /* not supported */</p><p>+	NL_RTM_NEWMDB		= 84, /* not supported */</p><p>+	NL_RTM_DELMDB		= 85, /* not supported */</p><p>+	NL_RTM_GETMDB		= 86, /* not supported */</p><p>+	NL_RTM_NEWNSID		= 88, /* not supported */</p><p>+	NL_RTM_DELNSID		= 89, /* not supported */</p><p>+	NL_RTM_GETNSID		= 90, /* not supported */</p><p>+	NL_RTM_NEWSTATS		= 92, /* not supported */</p><p>+	NL_RTM_GETSTATS		= 94, /* not supported */</p><p>+	NL_RTM_NEWNEXTHOP	= 104, /* creates new user nexhtop */</p><p>+	NL_RTM_DELNEXTHOP	= 105, /* deletes matching nexthop */</p><p>+	NL_RTM_GETNEXTHOP	= 106, /* lists created user nexthops */</p><p>+	__NL_RTM_MAX,</p><p>+};</p><p>+#define NL_RTM_MAX (((__NL_RTM_MAX + 3) &amp; ~3) - 1)</p><p>+</p><p>+#ifndef _KERNEL</p><p>+/*</p><p>+ * RTM_* namespace clashes with BSD rtsock namespace.</p><p>+ * Use NL_RTM_ prefix in the kernel and map it to RTM_</p><p>+ * for userland.</p><p>+ */</p><p>+#define RTM_BASE	NL_RTM_BASE</p><p>+#define RTM_NEWLINK 	NL_RTM_NEWLINK</p><p>+#define RTM_DELLINK 	NL_RTM_DELLINK</p><p>+#define RTM_GETLINK 	NL_RTM_GETLINK</p><p>+#define RTM_SETLINK 	NL_RTM_SETLINK</p><p>+#define RTM_NEWADDR	NL_RTM_NEWADDR</p><p>+#define RTM_DELADDR	NL_RTM_DELADDR</p><p>+#define RTM_GETADDR 	NL_RTM_GETADDR</p><p>+#define RTM_NEWROUTE 	NL_RTM_NEWROUTE</p><p>+#define RTM_DELROUTE 	NL_RTM_DELROUTE</p><p>+#define RTM_GETROUTE 	NL_RTM_GETROUTE</p><p>+#define	RTM_NEWNEXTHOP	NL_RTM_NEWNEXTHOP</p><p>+#define	RTM_DELNEXTHOP	NL_RTM_DELNEXTHOP</p><p>+#define	RTM_GETNEXTHOP	NL_RTM_GETNEXTHOP</p><p>+#endif</p><p>+</p><p>+#ifndef _KERNEL</p><p>+/* rtnetlink multicast groups - backwards compatibility for userspace */</p><p>+#define RTMGRP_LINK		0x01</p><p>+#define RTMGRP_NOTIFY		0x02</p><p>+#define RTMGRP_NEIGH		0x04</p><p>+#define RTMGRP_TC		0x08</p><p>+</p><p>+#define RTMGRP_IPV4_IFADDR	0x10</p><p>+#define RTMGRP_IPV4_MROUTE	0x20</p><p>+#define RTMGRP_IPV4_ROUTE	0x40</p><p>+#define RTMGRP_IPV4_RULE	0x80</p><p>+</p><p>+#define RTMGRP_IPV6_IFADDR	0x100</p><p>+#define RTMGRP_IPV6_MROUTE	0x200</p><p>+#define RTMGRP_IPV6_ROUTE	0x400</p><p>+#define RTMGRP_IPV6_IFINFO	0x800</p><p>+</p><p>+#define RTMGRP_DECnet_IFADDR	0x1000</p><p>+#define RTMGRP_DECnet_ROUTE	0x4000</p><p>+</p><p>+#define RTMGRP_IPV6_PREFIX	0x20000</p><p>+#endif</p><p>+</p><p>+/* Defined NETLINK_ROUTE multicast groups */</p><p>+enum rtnetlink_groups {</p><p>+	RTNLGRP_NONE,</p><p>+#define RTNLGRP_NONE		RTNLGRP_NONE</p><p>+	RTNLGRP_LINK,</p><p>+#define RTNLGRP_LINK		RTNLGRP_LINK</p><p>+	RTNLGRP_NOTIFY,</p><p>+#define RTNLGRP_NOTIFY		RTNLGRP_NOTIFY</p><p>+	RTNLGRP_NEIGH,</p><p>+#define RTNLGRP_NEIGH		RTNLGRP_NEIGH</p><p>+	RTNLGRP_TC,</p><p>+#define RTNLGRP_TC		RTNLGRP_TC</p><p>+	RTNLGRP_IPV4_IFADDR,</p><p>+#define RTNLGRP_IPV4_IFADDR	RTNLGRP_IPV4_IFADDR</p><p>+	RTNLGRP_IPV4_MROUTE,</p><p>+#define RTNLGRP_IPV4_MROUTE	RTNLGRP_IPV4_MROUTE</p><p>+	RTNLGRP_IPV4_ROUTE,</p><p>+#define RTNLGRP_IPV4_ROUTE	RTNLGRP_IPV4_ROUTE</p><p>+	RTNLGRP_IPV4_RULE,</p><p>+#define RTNLGRP_IPV4_RULE	RTNLGRP_IPV4_RULE</p><p>+	RTNLGRP_IPV6_IFADDR,</p><p>+#define RTNLGRP_IPV6_IFADDR	RTNLGRP_IPV6_IFADDR</p><p>+	RTNLGRP_IPV6_MROUTE,</p><p>+#define RTNLGRP_IPV6_MROUTE	RTNLGRP_IPV6_MROUTE</p><p>+	RTNLGRP_IPV6_ROUTE,</p><p>+#define RTNLGRP_IPV6_ROUTE	RTNLGRP_IPV6_ROUTE</p><p>+	RTNLGRP_IPV6_IFINFO,</p><p>+#define RTNLGRP_IPV6_IFINFO	RTNLGRP_IPV6_IFINFO</p><p>+	RTNLGRP_DECnet_IFADDR,</p><p>+#define RTNLGRP_DECnet_IFADDR	RTNLGRP_DECnet_IFADDR</p><p>+	RTNLGRP_NOP2,</p><p>+	RTNLGRP_DECnet_ROUTE,</p><p>+#define RTNLGRP_DECnet_ROUTE	RTNLGRP_DECnet_ROUTE</p><p>+	RTNLGRP_DECnet_RULE,</p><p>+#define RTNLGRP_DECnet_RULE	RTNLGRP_DECnet_RULE</p><p>+	RTNLGRP_NOP4,</p><p>+	RTNLGRP_IPV6_PREFIX,</p><p>+#define RTNLGRP_IPV6_PREFIX	RTNLGRP_IPV6_PREFIX</p><p>+	RTNLGRP_IPV6_RULE,</p><p>+#define RTNLGRP_IPV6_RULE	RTNLGRP_IPV6_RULE</p><p>+	RTNLGRP_ND_USEROPT,</p><p>+#define RTNLGRP_ND_USEROPT	RTNLGRP_ND_USEROPT</p><p>+	RTNLGRP_PHONET_IFADDR,</p><p>+#define RTNLGRP_PHONET_IFADDR	RTNLGRP_PHONET_IFADDR</p><p>+	RTNLGRP_PHONET_ROUTE,</p><p>+#define RTNLGRP_PHONET_ROUTE	RTNLGRP_PHONET_ROUTE</p><p>+	RTNLGRP_DCB,</p><p>+#define RTNLGRP_DCB		RTNLGRP_DCB</p><p>+	RTNLGRP_IPV4_NETCONF,</p><p>+#define RTNLGRP_IPV4_NETCONF	RTNLGRP_IPV4_NETCONF</p><p>+	RTNLGRP_IPV6_NETCONF,</p><p>+#define RTNLGRP_IPV6_NETCONF	RTNLGRP_IPV6_NETCONF</p><p>+	RTNLGRP_MDB,</p><p>+#define RTNLGRP_MDB 		RTNLGRP_MDB</p><p>+	RTNLGRP_MPLS_ROUTE,</p><p>+#define RTNLGRP_MPLS_ROUTE	RTNLGRP_MPLS_ROUTE</p><p>+	RTNLGRP_NSID,</p><p>+#define RTNLGRP_NSID		RTNLGRP_NSID</p><p>+	RTNLGRP_MPLS_NETCONF,</p><p>+#define RTNLGRP_MPLS_NETCONF	RTNLGRP_MPLS_NETCONF</p><p>+	RTNLGRP_IPV4_MROUTE_R,</p><p>+#define RTNLGRP_IPV4_MROUTE_R	RTNLGRP_IPV4_MROUTE_R</p><p>+	RTNLGRP_IPV6_MROUTE_R,</p><p>+#define RTNLGRP_IPV6_MROUTE_R	RTNLGRP_IPV6_MROUTE_R</p><p>+	RTNLGRP_NEXTHOP,</p><p>+#define RTNLGRP_NEXTHOP		RTNLGRP_NEXTHOP</p><p>+	RTNLGRP_BRVLAN,</p><p>+#define RTNLGRP_BRVLAN		RTNLGRP_BRVLAN</p><p>+	__RTNLGRP_MAX</p><p>+};</p><p>+#define RTNLGRP_MAX (__RTNLGRP_MAX - 1)</p><p>+</p><p>+</p><p>+#endif</p><p>+</p><div><p>diff --git a/sys/netlink/route/iface.c b/sys/netlink/route/iface.c</p></div><p>@@ -0,0 +1,857 @@</p><p>+/*-</p><p>+ * SPDX-License-Identifier: BSD-2-Clause-FreeBSD</p><p>+ *</p><p>+ * Copyright (c) 2022 Alexander V. Chernikov &lt;melifaro@FreeBSD.org&gt;</p><p>+ *</p><p>+ * Redistribution and use in source and binary forms, with or without</p><p>+ * modification, are permitted provided that the following conditions</p><p>+ * are met:</p><p>+ * 1. Redistributions of source code must retain the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer.</p><p>+ * 2. Redistributions in binary form must reproduce the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer in the</p><p>+ *    documentation and/or other materials provided with the distribution.</p><p>+ *</p><p>+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&#39;&#39; AND</p><p>+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</p><p>+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</p><p>+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE</p><p>+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</p><p>+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</p><p>+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</p><p>+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</p><p>+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</p><p>+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</p><p>+ * SUCH DAMAGE.</p><p>+ */</p><p>+</p><p>+#include &lt;sys/cdefs.h&gt;</p><p>+__FBSDID(&#34;$FreeBSD$&#34;);</p><p>+#include &#34;opt_inet.h&#34;</p><p>+#include &#34;opt_inet6.h&#34;</p><p>+#include &lt;sys/types.h&gt;</p><p>+#include &lt;sys/malloc.h&gt;</p><p>+#include &lt;sys/socket.h&gt;</p><p>+#include &lt;sys/sockio.h&gt;</p><p>+#include &lt;sys/syslog.h&gt;</p><p>+</p><p>+#include &lt;net/if.h&gt;</p><p>+#include &lt;net/if_dl.h&gt;</p><p>+#include &lt;net/if_media.h&gt;</p><p>+#include &lt;net/if_var.h&gt;</p><p>+#include &lt;net/if_clone.h&gt;</p><p>+#include &lt;net/route.h&gt;</p><p>+#include &lt;net/route/nhop.h&gt;</p><p>+#include &lt;net/route/route_ctl.h&gt;</p><p>+#include &lt;netlink/netlink.h&gt;</p><p>+#include &lt;netlink/netlink_ctl.h&gt;</p><p>+#include &lt;netlink/netlink_route.h&gt;</p><p>+#include &lt;netlink/route/route_var.h&gt;</p><p>+</p><p>+#include &lt;netinet6/scope6_var.h&gt; /* scope deembedding */</p><p>+</p><p>+#define	DEBUG_MOD_NAME	nl_iface</p><p>+#define	DEBUG_MAX_LEVEL	LOG_DEBUG3</p><p>+#include &lt;netlink/netlink_debug.h&gt;</p><p>+_DECLARE_DEBUG(LOG_DEBUG);</p><p>+</p><p>+struct netlink_walkargs {</p><p>+	struct nl_writer *nw;</p><p>+	struct nlmsghdr hdr;</p><p>+	struct nlpcb *so;</p><p>+	uint32_t fibnum;</p><p>+	int family;</p><p>+	int error;</p><p>+	int count;</p><p>+	int dumped;</p><p>+};</p><p>+</p><p>+static eventhandler_tag ifdetach_event, ifattach_event, ifaddr_event;</p><p>+</p><p>+static SLIST_HEAD(, nl_cloner) nl_cloners = SLIST_HEAD_INITIALIZER(nl_cloners);</p><p>+</p><p>+static struct sx rtnl_cloner_lock;</p><p>+SX_SYSINIT(rtnl_cloner_lock, &amp;rtnl_cloner_lock, &#34;rtnl cloner lock&#34;);</p><p>+</p><p>+/*</p><p>+ * RTM_GETLINK request</p><p>+ * sendto(3, {{len=32, type=RTM_GETLINK, flags=NLM_F_REQUEST|NLM_F_DUMP, seq=1641940952, pid=0},</p><p>+ *  {ifi_family=AF_INET, ifi_type=ARPHRD_NETROM, ifi_index=0, ifi_flags=0, ifi_change=0}}, 32, 0, NULL, 0) = 32</p><p>+ *</p><p>+ * Reply:</p><p>+ * {ifi_family=AF_UNSPEC, ifi_type=ARPHRD_ETHER, ifi_index=if_nametoindex(&#34;enp0s31f6&#34;), ifi_flags=IFF_UP|IFF_BROADCAST|IFF_RUNNING|IFF_MULTICAST|IFF_LOWER_UP, ifi_change=0},</p><p>+{{nla_len=10, nla_type=IFLA_ADDRESS}, &#34;\xfe\x54\x00\x52\x3e\x90&#34;}</p><p>+</p><p>+[</p><p>+{{nla_len=14, nla_type=IFLA_IFNAME}, &#34;enp0s31f6&#34;},</p><p>+{{nla_len=8, nla_type=IFLA_TXQLEN}, 1000},</p><p>+{{nla_len=5, nla_type=IFLA_OPERSTATE}, 6},</p><p>+{{nla_len=5, nla_type=IFLA_LINKMODE}, 0},</p><p>+{{nla_len=8, nla_type=IFLA_MTU}, 1500},</p><p>+{{nla_len=8, nla_type=IFLA_MIN_MTU}, 68},</p><p>+ {{nla_len=8, nla_type=IFLA_MAX_MTU}, 9000},</p><p>+{{nla_len=8, nla_type=IFLA_GROUP}, 0},</p><p>+{{nla_len=8, nla_type=IFLA_PROMISCUITY}, 0},</p><p>+{{nla_len=8, nla_type=IFLA_NUM_TX_QUEUES}, 1},</p><p>+{{nla_len=8, nla_type=IFLA_GSO_MAX_SEGS}, 65535},</p><p>+{{nla_len=8, nla_type=IFLA_GSO_MAX_SIZE}, 65536},</p><p>+{{nla_len=8, nla_type=IFLA_NUM_RX_QUEUES}, 1},</p><p>+{{nla_len=5, nla_type=IFLA_CARRIER}, 1},</p><p>+{{nla_len=13, nla_type=IFLA_QDISC}, &#34;fq_codel&#34;},</p><p>+{{nla_len=8, nla_type=IFLA_CARRIER_CHANGES}, 2},</p><p>+{{nla_len=5, nla_type=IFLA_PROTO_DOWN}, 0},</p><p>+{{nla_len=8, nla_type=IFLA_CARRIER_UP_COUNT}, 1},</p><p>+{{nla_len=8, nla_type=IFLA_CARRIER_DOWN_COUNT}, 1},</p><p>+ */</p><p>+</p><p>+struct if_state {</p><p>+	uint8_t		ifla_operstate;</p><p>+	uint8_t		ifla_carrier;</p><p>+};</p><p>+</p><p>+static void</p><p>+get_operstate_ether(struct ifnet *ifp, struct if_state *pstate)</p><p>+{</p><p>+	struct ifmediareq ifmr = {};</p><p>+	int error;</p><p>+	error = (*ifp-&gt;if_ioctl)(ifp, SIOCGIFMEDIA, (void *)&amp;ifmr);</p><p>+</p><p>+	if (error != 0) {</p><p>+		NL_LOG(LOG_DEBUG, &#34;error calling SIOCGIFMEDIA on %s: %d&#34;,</p><p>+		    if_name(ifp), error);</p><p>+		return;</p><p>+	}</p><p>+</p><p>+	switch (IFM_TYPE(ifmr.ifm_active)) {</p><p>+	case IFM_ETHER:</p><p>+		if (ifmr.ifm_status &amp; IFM_ACTIVE) {</p><p>+			pstate-&gt;ifla_carrier = 1;</p><p>+			if (ifp-&gt;if_flags &amp; IFF_MONITOR)</p><p>+				pstate-&gt;ifla_operstate = IF_OPER_DORMANT;</p><p>+			else</p><p>+				pstate-&gt;ifla_operstate = IF_OPER_UP;</p><p>+		} else</p><p>+			pstate-&gt;ifla_operstate = IF_OPER_DOWN;</p><p>+	}</p><p>+}</p><p>+</p><p>+static bool</p><p>+get_stats(struct nl_writer *nw, struct ifnet *ifp)</p><p>+{</p><p>+	struct rtnl_link_stats64 *stats;</p><p>+</p><p>+	int nla_len = sizeof(struct nlattr) + sizeof(*stats);</p><p>+	struct nlattr *nla = nlmsg_reserve_data(nw, nla_len, struct nlattr);</p><p>+	if (nla == NULL)</p><p>+		return (false);</p><p>+	nla-&gt;nla_type = IFLA_STATS64;</p><p>+	nla-&gt;nla_len = nla_len;</p><p>+	stats = (struct rtnl_link_stats64 *)(nla + 1);</p><p>+</p><p>+	stats-&gt;rx_packets = ifp-&gt;if_get_counter(ifp, IFCOUNTER_IPACKETS);</p><p>+	stats-&gt;tx_packets = ifp-&gt;if_get_counter(ifp, IFCOUNTER_OPACKETS);</p><p>+	stats-&gt;rx_bytes = ifp-&gt;if_get_counter(ifp, IFCOUNTER_IBYTES);</p><p>+	stats-&gt;tx_bytes = ifp-&gt;if_get_counter(ifp, IFCOUNTER_OBYTES);</p><p>+	stats-&gt;rx_errors = ifp-&gt;if_get_counter(ifp, IFCOUNTER_IERRORS);</p><p>+	stats-&gt;tx_errors = ifp-&gt;if_get_counter(ifp, IFCOUNTER_OERRORS);</p><p>+	stats-&gt;rx_dropped = ifp-&gt;if_get_counter(ifp, IFCOUNTER_IQDROPS);</p><p>+	stats-&gt;tx_dropped = ifp-&gt;if_get_counter(ifp, IFCOUNTER_OQDROPS);</p><p>+	stats-&gt;multicast = ifp-&gt;if_get_counter(ifp, IFCOUNTER_IMCASTS);</p><p>+	stats-&gt;rx_nohandler = ifp-&gt;if_get_counter(ifp, IFCOUNTER_NOPROTO);</p><p>+</p><p>+	return (true);</p><p>+}</p><p>+</p><p>+static void</p><p>+get_operstate(struct ifnet *ifp, struct if_state *pstate)</p><p>+{</p><p>+	pstate-&gt;ifla_operstate = IF_OPER_UNKNOWN;</p><p>+	pstate-&gt;ifla_carrier = 0; /* no carrier */</p><p>+</p><p>+	switch (ifp-&gt;if_type) {</p><p>+	case IFT_ETHER:</p><p>+		get_operstate_ether(ifp, pstate);</p><p>+		break;</p><p>+	case IFT_LOOP:</p><p>+		if (ifp-&gt;if_flags &amp; IFF_UP) {</p><p>+			pstate-&gt;ifla_operstate = IF_OPER_UP;</p><p>+			pstate-&gt;ifla_carrier = 1;</p><p>+		} else</p><p>+			pstate-&gt;ifla_operstate = IF_OPER_DOWN;</p><p>+		break;</p><p>+	}</p><p>+}</p><p>+</p><p>+static unsigned</p><p>+ifp_flags_to_netlink(const struct ifnet *ifp)</p><p>+{</p><p>+        return (ifp-&gt;if_flags | ifp-&gt;if_drv_flags);</p><p>+}</p><p>+</p><p>+#define LLADDR_CONST(s) ((const void *)((s)-&gt;sdl_data + (s)-&gt;sdl_nlen))</p><p>+static bool</p><p>+dump_sa(struct nl_writer *nw, int attr, const struct sockaddr *sa)</p><p>+{</p><p>+        uint32_t addr_len = 0;</p><p>+        const void *addr_data = NULL;</p><p>+        struct in6_addr addr6;</p><p>+</p><p>+        if (sa == NULL)</p><p>+                return (true);</p><p>+</p><p>+        switch (sa-&gt;sa_family) {</p><p>+        case AF_INET:</p><p>+                addr_len = sizeof(struct in_addr);</p><p>+                addr_data = &amp;((const struct sockaddr_in *)sa)-&gt;sin_addr;</p><p>+                break;</p><p>+        case AF_INET6:</p><p>+                in6_splitscope(&amp;((const struct sockaddr_in6 *)sa)-&gt;sin6_addr, &amp;addr6, &amp;addr_len);</p><p>+                addr_len = sizeof(struct in6_addr);</p><p>+                addr_data = &amp;addr6;</p><p>+                break;</p><p>+        case AF_LINK:</p><p>+                addr_len = ((const struct sockaddr_dl *)sa)-&gt;sdl_alen;</p><p>+                addr_data = LLADDR_CONST((const struct sockaddr_dl *)sa);</p><p>+                break;</p><p>+        default:</p><p>+                NL_LOG(LOG_DEBUG, &#34;unsupported family: %d, skipping&#34;, sa-&gt;sa_family);</p><p>+                return (true);</p><p>+        }</p><p>+</p><p>+        return (nlattr_add(nw, attr, addr_len, addr_data));</p><p>+}</p><p>+</p><p>+/*</p><p>+ * Dumps interface state, properties and metrics.</p><p>+ * @nw: message writer</p><p>+ * @ifp: target interface</p><p>+ * @hdr: template header</p><p>+ *</p><p>+ * This function is called without epoch and MAY sleep.</p><p>+ */</p><p>+static bool</p><p>+dump_iface(struct nl_writer *nw, struct ifnet *ifp, const struct nlmsghdr *hdr)</p><p>+{</p><p>+        struct ifinfomsg *ifinfo;</p><p>+</p><p>+        NL_LOG(LOG_DEBUG3, &#34;dumping interface %s data&#34;, if_name(ifp));</p><p>+</p><p>+	if (!nlmsg_reply(nw, hdr, sizeof(struct ifinfomsg)))</p><p>+		goto enomem;</p><p>+</p><p>+        ifinfo = nlmsg_reserve_object(nw, struct ifinfomsg);</p><p>+        ifinfo-&gt;ifi_family = AF_UNSPEC;</p><p>+        ifinfo-&gt;__ifi_pad = 0;</p><p>+        ifinfo-&gt;ifi_type = ifp-&gt;if_type;</p><p>+        ifinfo-&gt;ifi_index = ifp-&gt;if_index;</p><p>+        ifinfo-&gt;ifi_flags = ifp_flags_to_netlink(ifp);</p><p>+        ifinfo-&gt;ifi_change = 0;</p><p>+</p><p>+        nlattr_add_string(nw, IFLA_IFNAME, if_name(ifp));</p><p>+</p><p>+	struct if_state ifs = {};</p><p>+	get_operstate(ifp, &amp;ifs);</p><p>+</p><p>+        nlattr_add_u8(nw, IFLA_OPERSTATE, ifs.ifla_operstate);</p><p>+        nlattr_add_u8(nw, IFLA_CARRIER, ifs.ifla_carrier);</p><p>+</p><p>+/*</p><p>+        nlattr_add_u8(nw, IFLA_PROTO_DOWN, val);</p><p>+        nlattr_add_u8(nw, IFLA_LINKMODE, val);</p><p>+*/</p><p>+        if ((ifp-&gt;if_addr != NULL)) {</p><p>+                dump_sa(nw, IFLA_ADDRESS, ifp-&gt;if_addr-&gt;ifa_addr);</p><p>+        }</p><p>+</p><p>+        if ((ifp-&gt;if_broadcastaddr != NULL)) {</p><p>+		nlattr_add(nw, IFLA_BROADCAST, ifp-&gt;if_addrlen,</p><p>+		    ifp-&gt;if_broadcastaddr);</p><p>+        }</p><p>+</p><p>+        nlattr_add_u32(nw, IFLA_MTU, ifp-&gt;if_mtu);</p><p>+/*</p><p>+        nlattr_add_u32(nw, IFLA_MIN_MTU, 60);</p><p>+        nlattr_add_u32(nw, IFLA_MAX_MTU, 9000);</p><p>+        nlattr_add_u32(nw, IFLA_GROUP, 0);</p><p>+*/</p><p>+	get_stats(nw, ifp);</p><p>+</p><p>+	uint32_t val = (ifp-&gt;if_flags &amp; IFF_PROMISC) != 0;</p><p>+        nlattr_add_u32(nw, IFLA_PROMISCUITY, val);</p><p>+</p><p>+        if (nlmsg_end(nw))</p><p>+		return (true);</p><p>+</p><p>+enomem:</p><p>+        NL_LOG(LOG_DEBUG, &#34;unable to dump interface %s state (ENOMEM)&#34;, if_name(ifp));</p><p>+        nlmsg_abort(nw);</p><p>+        return (false);</p><p>+}</p><p>+</p><p>+static bool</p><p>+check_ifmsg(void *hdr, struct nl_pstate *npt)</p><p>+{</p><p>+	struct ifinfomsg *ifm = hdr;</p><p>+</p><p>+	if (ifm-&gt;__ifi_pad != 0 || ifm-&gt;ifi_type != 0 ||</p><p>+	    ifm-&gt;ifi_flags != 0 || ifm-&gt;ifi_change != 0) {</p><p>+		nlmsg_report_err_msg(npt,</p><p>+		    &#34;strict checking: non-zero values in ifinfomsg header&#34;);</p><p>+		return (false);</p><p>+	}</p><p>+</p><p>+	return (true);</p><p>+}</p><p>+</p><p>+#define	_IN(_field)	offsetof(struct ifinfomsg, _field)</p><p>+#define	_OUT(_field)	offsetof(struct nl_parsed_link, _field)</p><p>+static const struct nlfield_parser nlf_p_if[] = {</p><p>+	{ .off_in = _IN(ifi_type), .off_out = _OUT(ifi_type), .cb = nlf_get_u16 },</p><p>+	{ .off_in = _IN(ifi_index), .off_out = _OUT(ifi_index), .cb = nlf_get_u32 },</p><p>+};</p><p>+</p><p>+static const struct nlattr_parser nla_p_linfo[] = {</p><p>+	{ .type = IFLA_INFO_KIND, .off = _OUT(ifla_cloner), .cb = nlattr_get_stringn },</p><p>+	{ .type = IFLA_INFO_DATA, .off = _OUT(ifla_idata), .cb = nlattr_get_nla },</p><p>+};</p><p>+NL_DECLARE_ATTR_PARSER(linfo_parser, nla_p_linfo);</p><p>+</p><p>+static const struct nlattr_parser nla_p_if[] = {</p><p>+	{ .type = IFLA_IFNAME, .off = _OUT(ifla_ifname), .cb = nlattr_get_string },</p><p>+	{ .type = IFLA_MTU, .off = _OUT(ifla_mtu), .cb = nlattr_get_uint32 },</p><p>+	{ .type = IFLA_LINK, .off = _OUT(ifi_index), .cb = nlattr_get_uint32 },</p><p>+	{ .type = IFLA_LINKINFO, .arg = &amp;linfo_parser, .cb = nlattr_get_nested },</p><p>+	{ .type = IFLA_GROUP, .off = _OUT(ifla_group), .cb = nlattr_get_string },</p><p>+	{ .type = IFLA_ALT_IFNAME, .off = _OUT(ifla_ifname), .cb = nlattr_get_string },</p><p>+};</p><p>+#undef _IN</p><p>+#undef _OUT</p><p>+NL_DECLARE_STRICT_PARSER(ifmsg_parser, struct ifinfomsg, check_ifmsg, nlf_p_if, nla_p_if);</p><p>+</p><p>+static bool</p><p>+match_iface(struct nl_parsed_link *attrs, struct ifnet *ifp)</p><p>+{</p><p>+	if (attrs-&gt;ifi_index != 0 &amp;&amp; attrs-&gt;ifi_index != ifp-&gt;if_index)</p><p>+		return (false);</p><p>+	if (attrs-&gt;ifi_type != 0 &amp;&amp; attrs-&gt;ifi_index != ifp-&gt;if_type)</p><p>+		return (false);</p><p>+	if (attrs-&gt;ifla_ifname != NULL &amp;&amp; strcmp(attrs-&gt;ifla_ifname, if_name(ifp)))</p><p>+		return (false);</p><p>+	/* TODO: add group match */</p><p>+</p><p>+	return (true);</p><p>+}</p><p>+</p><p>+/*</p><p>+ * {nlmsg_len=52, nlmsg_type=RTM_GETLINK, nlmsg_flags=NLM_F_REQUEST, nlmsg_seq=1662842818, nlmsg_pid=0},</p><p>+ *  {ifi_family=AF_PACKET, ifi_type=ARPHRD_NETROM, ifi_index=0, ifi_flags=0, ifi_change=0},</p><p>+ *   [</p><p>+ *    [{nla_len=10, nla_type=IFLA_IFNAME}, &#34;vnet9&#34;],</p><p>+ *    [{nla_len=8, nla_type=IFLA_EXT_MASK}, RTEXT_FILTER_VF]</p><p>+ *   ]</p><p>+ */</p><p>+static int</p><p>+rtnl_handle_getlink(struct nlmsghdr *hdr, struct nlpcb *nlp, struct nl_pstate *npt)</p><p>+{</p><p>+	struct epoch_tracker et;</p><p>+        struct ifnet *ifp;</p><p>+	int error = 0;</p><p>+</p><p>+	struct nl_parsed_link attrs = {};</p><p>+	error = nl_parse_nlmsg(hdr, &amp;ifmsg_parser, npt, &amp;attrs);</p><p>+	if (error != 0)</p><p>+		return (error);</p><p>+</p><p>+	struct netlink_walkargs wa = {</p><p>+		.so = nlp,</p><p>+		.nw = npt-&gt;nw,</p><p>+		.hdr.nlmsg_pid = hdr-&gt;nlmsg_pid,</p><p>+		.hdr.nlmsg_seq = hdr-&gt;nlmsg_seq,</p><p>+		.hdr.nlmsg_flags = hdr-&gt;nlmsg_flags | NLM_F_MULTI,</p><p>+		.hdr.nlmsg_type = NL_RTM_NEWLINK,</p><p>+	};</p><p>+</p><p>+	/* Fast track for an interface w/ explicit index match */</p><p>+	if (attrs.ifi_index != 0) {</p><p>+		NET_EPOCH_ENTER(et);</p><p>+		ifp = ifnet_byindex_ref(attrs.ifi_index);</p><p>+		NET_EPOCH_EXIT(et);</p><p>+		NLP_LOG(LOG_DEBUG3, nlp, &#34;fast track -&gt; searching index %u&#34;, attrs.ifi_index);</p><p>+		if (ifp != NULL) {</p><p>+			if (match_iface(&amp;attrs, ifp)) {</p><p>+				if (!dump_iface(wa.nw, ifp, &amp;wa.hdr))</p><p>+					error = ENOMEM;</p><p>+			} else</p><p>+				error = ESRCH;</p><p>+			if_rele(ifp);</p><p>+		} else</p><p>+			error = ESRCH;</p><p>+		return (error);</p><p>+	}</p><p>+</p><p>+	/*</p><p>+	 * Fetching some link properties require performing ioctl&#39;s that may be blocking.</p><p>+	 * Address it by saving referenced pointers of the matching links,</p><p>+	 * exiting from epoch and going through the list one-by-one.</p><p>+	 */</p><p>+</p><p>+	NL_LOG(LOG_DEBUG2, &#34;Start dump&#34;);</p><p>+</p><p>+	struct ifnet **match_array;</p><p>+	int offset = 0, base_count = 16; /* start with 128 bytes */</p><p>+	match_array = malloc(base_count * sizeof(void *), M_TEMP, M_NOWAIT);</p><p>+</p><p>+	NLP_LOG(LOG_DEBUG3, nlp, &#34;MATCHING: index=%u type=%d name=%s&#34;,</p><p>+	    attrs.ifi_index, attrs.ifi_type, attrs.ifla_ifname);</p><p>+	NET_EPOCH_ENTER(et);</p><p>+        CK_STAILQ_FOREACH(ifp, &amp;V_ifnet, if_link) {</p><p>+		wa.count++;</p><p>+		if (match_iface(&amp;attrs, ifp)) {</p><p>+			if (offset &lt; base_count) {</p><p>+				if (!if_try_ref(ifp))</p><p>+					continue;</p><p>+				match_array[offset++] = ifp;</p><p>+				continue;</p><p>+			}</p><p>+			/* Too many matches, need to reallocate */</p><p>+			struct ifnet **new_array;</p><p>+			int sz = base_count * sizeof(void *);</p><p>+			base_count *= 2;</p><p>+			new_array = malloc(sz * 2, M_TEMP, M_NOWAIT);</p><p>+			if (new_array == NULL) {</p><p>+				error = ENOMEM;</p><p>+				break;</p><p>+			}</p><p>+			memcpy(new_array, match_array, sz);</p><p>+			free(match_array, M_TEMP);</p><p>+			match_array = new_array;</p><p>+                }</p><p>+        }</p><p>+	NET_EPOCH_EXIT(et);</p><p>+</p><p>+	NL_LOG(LOG_DEBUG2, &#34;Matched %d interface(s), dumping&#34;, offset);</p><p>+	for (int i = 0; error == 0 &amp;&amp; i &lt; offset; i++) {</p><p>+		if (!dump_iface(wa.nw, match_array[i], &amp;wa.hdr))</p><p>+			error = ENOMEM;</p><p>+	}</p><p>+	for (int i = 0; i &lt; offset; i++)</p><p>+		if_rele(match_array[i]);</p><p>+	free(match_array, M_TEMP);</p><p>+</p><p>+	NL_LOG(LOG_DEBUG2, &#34;End dump, iterated %d dumped %d&#34;, wa.count, wa.dumped);</p><p>+</p><p>+	if (!nlmsg_end_dump(wa.nw, error, &amp;wa.hdr)) {</p><p>+                NL_LOG(LOG_DEBUG, &#34;Unable to finalize the dump&#34;);</p><p>+                return (ENOMEM);</p><p>+        }</p><p>+</p><p>+	return (error);</p><p>+}</p><p>+</p><p>+/*</p><p>+ * sendmsg(3, {msg_name={sa_family=AF_NETLINK, nl_pid=0, nl_groups=00000000}, msg_namelen=12, msg_iov=[{iov_base=[</p><p>+ * {nlmsg_len=60, nlmsg_type=RTM_NEWLINK, nlmsg_flags=NLM_F_REQUEST|NLM_F_ACK|NLM_F_EXCL|NLM_F_CREATE, nlmsg_seq=1662715618, nlmsg_pid=0},</p><p>+ *  {ifi_family=AF_UNSPEC, ifi_type=ARPHRD_NETROM, ifi_index=0, ifi_flags=0, ifi_change=0},</p><p>+ *   {nla_len=11, nla_type=IFLA_IFNAME}, &#34;dummy0&#34;],</p><p>+ *   [</p><p>+ *    {nla_len=16, nla_type=IFLA_LINKINFO},</p><p>+ *     [</p><p>+ *      {nla_len=9, nla_type=IFLA_INFO_KIND}, &#34;dummy&#34;...</p><p>+ *     ]</p><p>+ *    ]</p><p>+ */</p><p>+</p><p>+static int</p><p>+rtnl_handle_dellink(struct nlmsghdr *hdr, struct nlpcb *nlp, struct nl_pstate *npt)</p><p>+{</p><p>+	struct epoch_tracker et;</p><p>+        struct ifnet *ifp;</p><p>+	int error;</p><p>+</p><p>+	struct nl_parsed_link attrs = {};</p><p>+	error = nl_parse_nlmsg(hdr, &amp;ifmsg_parser, npt, &amp;attrs);</p><p>+	if (error != 0)</p><p>+		return (error);</p><p>+</p><p>+	NET_EPOCH_ENTER(et);</p><p>+	ifp = ifnet_byindex_ref(attrs.ifi_index);</p><p>+	NET_EPOCH_EXIT(et);</p><p>+	if (ifp == NULL) {</p><p>+		NLP_LOG(LOG_DEBUG, nlp, &#34;unable to find interface %u&#34;, attrs.ifi_index);</p><p>+		return (ENOENT);</p><p>+	}</p><p>+	NLP_LOG(LOG_DEBUG3, nlp, &#34;mapped ifindex %u to %s&#34;, attrs.ifi_index, if_name(ifp));</p><p>+</p><p>+	sx_xlock(&amp;ifnet_detach_sxlock);</p><p>+	error = if_clone_destroy(if_name(ifp));</p><p>+	sx_xunlock(&amp;ifnet_detach_sxlock);</p><p>+</p><p>+	NLP_LOG(LOG_DEBUG2, nlp, &#34;deleting interface %s returned %d&#34;, if_name(ifp), error);</p><p>+</p><p>+	if_rele(ifp);</p><p>+	return (error);</p><p>+}</p><p>+</p><p>+static int</p><p>+rtnl_handle_newlink(struct nlmsghdr *hdr, struct nlpcb *nlp, struct nl_pstate *npt)</p><p>+{</p><p>+	struct nl_cloner *cloner;</p><p>+	int error;</p><p>+</p><p>+	struct nl_parsed_link attrs = {};</p><p>+	error = nl_parse_nlmsg(hdr, &amp;ifmsg_parser, npt, &amp;attrs);</p><p>+	if (error != 0)</p><p>+		return (error);</p><p>+</p><p>+	if (attrs.ifla_ifname == NULL || strlen(attrs.ifla_ifname) == 0) {</p><p>+		/* Applications like ip(8) verify RTM_NEWLINK existance</p><p>+		 * by calling it with empty arguments. Always return &#34;innocent&#34;</p><p>+		 * error.</p><p>+		 */</p><p>+		NLMSG_REPORT_ERR_MSG(npt, &#34;empty IFLA_IFNAME attribute&#34;);</p><p>+		return (EPERM);</p><p>+	}</p><p>+</p><p>+	if (attrs.ifla_cloner == NULL || strlen(attrs.ifla_cloner) == 0) {</p><p>+		NLMSG_REPORT_ERR_MSG(npt, &#34;empty IFLA_INFO_KIND attribute&#34;);</p><p>+		return (EINVAL);</p><p>+	}</p><p>+</p><p>+	sx_slock(&amp;rtnl_cloner_lock);</p><p>+	SLIST_FOREACH(cloner, &amp;nl_cloners, next) {</p><p>+		if (!strcmp(attrs.ifla_cloner, cloner-&gt;name)) {</p><p>+			error = cloner-&gt;create_f(&amp;attrs, nlp, npt);</p><p>+			sx_sunlock(&amp;rtnl_cloner_lock);</p><p>+			return (error);</p><p>+		}</p><p>+	}</p><p>+	sx_sunlock(&amp;rtnl_cloner_lock);</p><p>+</p><p>+	/* TODO: load cloner module if not exists &amp; privilege permits */</p><p>+	NLMSG_REPORT_ERR_MSG(npt, &#34;interface type %s not supported&#34;, attrs.ifla_cloner);</p><p>+	return (ENOTSUP);</p><p>+</p><p>+	return (error);</p><p>+}</p><p>+</p><p>+/*</p><p>+</p><p>+{ifa_family=AF_INET, ifa_prefixlen=8, ifa_flags=IFA_F_PERMANENT, ifa_scope=RT_SCOPE_HOST, ifa_index=if_nametoindex(&#34;lo&#34;)},</p><p>+ [</p><p>+        {{nla_len=8, nla_type=IFA_ADDRESS}, inet_addr(&#34;127.0.0.1&#34;)},</p><p>+        {{nla_len=8, nla_type=IFA_LOCAL}, inet_addr(&#34;127.0.0.1&#34;)},</p><p>+        {{nla_len=7, nla_type=IFA_LABEL}, &#34;lo&#34;},</p><p>+        {{nla_len=8, nla_type=IFA_FLAGS}, IFA_F_PERMANENT},</p><p>+        {{nla_len=20, nla_type=IFA_CACHEINFO}, {ifa_prefered=4294967295, ifa_valid=4294967295, cstamp=3619, tstamp=3619}}]},</p><p>+---</p><p>+</p><p>+{{len=72, type=RTM_NEWADDR, flags=NLM_F_MULTI, seq=1642191126, pid=566735},</p><p>+ {ifa_family=AF_INET6, ifa_prefixlen=96, ifa_flags=IFA_F_PERMANENT, ifa_scope=RT_SCOPE_UNIVERSE, ifa_index=if_nametoindex(&#34;virbr0&#34;)},</p><p>+   [</p><p>+    {{nla_len=20, nla_type=IFA_ADDRESS}, inet_pton(AF_INET6, &#34;2a01:4f8:13a:70c:ffff::1&#34;)},</p><p>+   {{nla_len=20, nla_type=IFA_CACHEINFO}, {ifa_prefered=4294967295, ifa_valid=4294967295, cstamp=4283, tstamp=4283}},</p><p>+   {{nla_len=8, nla_type=IFA_FLAGS}, IFA_F_PERMANENT}]},</p><p>+*/</p><p>+</p><p>+static uint8_t</p><p>+ifa_get_scope(const struct ifaddr *ifa)</p><p>+{</p><p>+        const struct sockaddr *sa;</p><p>+        uint8_t addr_scope = RT_SCOPE_UNIVERSE;</p><p>+</p><p>+        sa = ifa-&gt;ifa_addr;</p><p>+        switch (sa-&gt;sa_family) {</p><p>+        case AF_INET:</p><p>+                {</p><p>+                        struct in_addr addr;</p><p>+                        addr = ((const struct sockaddr_in *)sa)-&gt;sin_addr;</p><p>+                        if (IN_LOOPBACK(addr.s_addr))</p><p>+                                addr_scope = RT_SCOPE_HOST;</p><p>+                        else if (IN_LINKLOCAL(addr.s_addr))</p><p>+                                addr_scope = RT_SCOPE_LINK;</p><p>+                        break;</p><p>+                }</p><p>+        case AF_INET6:</p><p>+                {</p><p>+                        const struct in6_addr *addr;</p><p>+                        addr = &amp;((const struct sockaddr_in6 *)sa)-&gt;sin6_addr;</p><p>+                        if (IN6_IS_ADDR_LOOPBACK(addr))</p><p>+                                addr_scope = RT_SCOPE_HOST;</p><p>+                        else if (IN6_IS_ADDR_LINKLOCAL(addr))</p><p>+                                addr_scope = RT_SCOPE_LINK;</p><p>+                        break;</p><p>+                }</p><p>+        }</p><p>+</p><p>+        return (addr_scope);</p><p>+}</p><p>+</p><p>+static uint8_t</p><p>+inet6_get_plen(const struct in6_addr *addr)</p><p>+{</p><p>+</p><p>+	return (bitcount32(addr-&gt;s6_addr32[0]) + bitcount32(addr-&gt;s6_addr32[1]) +</p><p>+	    bitcount32(addr-&gt;s6_addr32[2]) + bitcount32(addr-&gt;s6_addr32[3]));</p><p>+}</p><p>+</p><p>+static uint8_t</p><p>+get_sa_plen(const struct sockaddr *sa)</p><p>+{</p><p>+        const struct in6_addr *paddr6;</p><p>+        const struct in_addr *paddr;</p><p>+</p><p>+        switch (sa-&gt;sa_family) {</p><p>+        case AF_INET:</p><p>+                if (sa == NULL)</p><p>+                        return (32);</p><p>+                paddr = &amp;(((const struct sockaddr_in *)sa)-&gt;sin_addr);</p><p>+                return bitcount32(paddr-&gt;s_addr);;</p><p>+        case AF_INET6:</p><p>+                if (sa == NULL)</p><p>+                        return (128);</p><p>+                paddr6 = &amp;(((const struct sockaddr_in6 *)sa)-&gt;sin6_addr);</p><p>+                return inet6_get_plen(paddr6);</p><p>+        }</p><p>+</p><p>+        return (0);</p><p>+}</p><p>+</p><p>+</p><p>+/*</p><p>+ * {&#39;attrs&#39;: [(&#39;IFA_ADDRESS&#39;, &#39;12.0.0.1&#39;),</p><p>+           (&#39;IFA_LOCAL&#39;, &#39;12.0.0.1&#39;),</p><p>+           (&#39;IFA_LABEL&#39;, &#39;eth10&#39;),</p><p>+           (&#39;IFA_FLAGS&#39;, 128),</p><p>+           (&#39;IFA_CACHEINFO&#39;, {&#39;ifa_preferred&#39;: 4294967295, &#39;ifa_valid&#39;: 4294967295, &#39;cstamp&#39;: 63745746, &#39;tstamp&#39;: 63745746})],</p><p>+ */</p><p>+static bool</p><p>+dump_iface_addr(struct nl_writer *nw, struct ifnet *ifp, struct ifaddr *ifa,</p><p>+    const struct nlmsghdr *hdr)</p><p>+{</p><p>+        struct ifaddrmsg *ifamsg;</p><p>+        struct sockaddr *sa = ifa-&gt;ifa_addr;</p><p>+</p><p>+        NL_LOG(LOG_DEBUG3, &#34;dumping ifa %p type %s(%d) for interface %s&#34;,</p><p>+            ifa, rib_print_family(sa-&gt;sa_family), sa-&gt;sa_family, if_name(ifp));</p><p>+</p><p>+	if (!nlmsg_reply(nw, hdr, sizeof(struct ifaddrmsg)))</p><p>+		goto enomem;</p><p>+</p><p>+        ifamsg = nlmsg_reserve_object(nw, struct ifaddrmsg);</p><p>+        ifamsg-&gt;ifa_family = sa-&gt;sa_family;</p><p>+        ifamsg-&gt;ifa_prefixlen = get_sa_plen(ifa-&gt;ifa_netmask);</p><p>+        ifamsg-&gt;ifa_flags = 0; // ifa_flags is useless</p><p>+        ifamsg-&gt;ifa_scope = ifa_get_scope(ifa);</p><p>+        ifamsg-&gt;ifa_index = ifp-&gt;if_index;</p><p>+</p><p>+        struct sockaddr *dst_sa = ifa-&gt;ifa_dstaddr;</p><p>+        if ((dst_sa == NULL) || (dst_sa-&gt;sa_family != sa-&gt;sa_family))</p><p>+                dst_sa = sa;</p><p>+        dump_sa(nw, IFA_ADDRESS, dst_sa);</p><p>+        dump_sa(nw, IFA_LOCAL, sa);</p><p>+        nlattr_add_string(nw, IFA_LABEL, if_name(ifp));</p><p>+</p><p>+        uint32_t val = 0; // ifa-&gt;ifa_flags;</p><p>+        nlattr_add_u32(nw, IFA_FLAGS, val);</p><p>+</p><p>+	if (nlmsg_end(nw))</p><p>+		return (true);</p><p>+enomem:</p><p>+        NL_LOG(LOG_DEBUG, &#34;Failed to dump ifa type %s(%d) for interface %s&#34;,</p><p>+            rib_print_family(sa-&gt;sa_family), sa-&gt;sa_family, if_name(ifp));</p><p>+        nlmsg_abort(nw);</p><p>+        return (false);</p><p>+}</p><p>+</p><p>+static int</p><p>+rtnl_handle_getaddr(struct nlmsghdr *hdr, struct nlpcb *nlp, struct nl_pstate *npt)</p><p>+{</p><p>+        struct ifaddr *ifa;</p><p>+        struct ifnet *ifp;</p><p>+	int error = 0;</p><p>+</p><p>+	struct netlink_walkargs wa = {</p><p>+		.so = nlp,</p><p>+		.nw = npt-&gt;nw,</p><p>+		.hdr.nlmsg_pid = hdr-&gt;nlmsg_pid,</p><p>+		.hdr.nlmsg_seq = hdr-&gt;nlmsg_seq,</p><p>+		.hdr.nlmsg_flags = hdr-&gt;nlmsg_flags | NLM_F_MULTI,</p><p>+		.hdr.nlmsg_type = NL_RTM_NEWADDR,</p><p>+	};</p><p>+</p><p>+	NL_LOG(LOG_DEBUG2, &#34;Start dump&#34;);</p><p>+</p><p>+        CK_STAILQ_FOREACH(ifp, &amp;V_ifnet, if_link) {</p><p>+                CK_STAILQ_FOREACH(ifa, &amp;ifp-&gt;if_addrhead, ifa_link) {</p><p>+                        if (wa.family != 0 &amp;&amp; wa.family != ifa-&gt;ifa_addr-&gt;sa_family)</p><p>+                                continue;</p><p>+                        if (ifa-&gt;ifa_addr-&gt;sa_family == AF_LINK)</p><p>+                                continue;</p><p>+			wa.count++;</p><p>+                        if (!dump_iface_addr(wa.nw, ifp, ifa, &amp;wa.hdr)) {</p><p>+                                error = ENOMEM;</p><p>+                                break;</p><p>+                        }</p><p>+			wa.dumped++;</p><p>+                }</p><p>+                if (error != 0)</p><p>+                        break;</p><p>+        }</p><p>+</p><p>+	NL_LOG(LOG_DEBUG2, &#34;End dump, iterated %d dumped %d&#34;, wa.count, wa.dumped);</p><p>+</p><p>+	if (!nlmsg_end_dump(wa.nw, error, &amp;wa.hdr)) {</p><p>+                NL_LOG(LOG_DEBUG, &#34;Unable to finalize the dump&#34;);</p><p>+                return (ENOMEM);</p><p>+        }</p><p>+</p><p>+	return (error);</p><p>+}</p><p>+</p><p>+static void</p><p>+rtnl_handle_ifaddr(void *arg __unused, struct ifaddr *ifa, int cmd)</p><p>+{</p><p>+	struct nlmsghdr hdr = {};</p><p>+	struct nl_writer nw = {};</p><p>+	uint32_t group = 0;</p><p>+</p><p>+	switch (ifa-&gt;ifa_addr-&gt;sa_family) {</p><p>+	case AF_INET:</p><p>+		group = RTNLGRP_IPV4_IFADDR;</p><p>+		break;</p><p>+	case AF_INET6:</p><p>+		group = RTNLGRP_IPV6_IFADDR;</p><p>+		break;</p><p>+	default:</p><p>+		NL_LOG(LOG_DEBUG2, &#34;ifa notification for unknown AF: %d&#34;,</p><p>+		    ifa-&gt;ifa_addr-&gt;sa_family);</p><p>+		return;</p><p>+	}</p><p>+</p><p>+	if (!nl_has_listeners(NETLINK_ROUTE, group))</p><p>+		return;</p><p>+</p><p>+	if (!nlmsg_get_group_writer(&amp;nw, NLMSG_LARGE, NETLINK_ROUTE, group)) {</p><p>+		NL_LOG(LOG_DEBUG, &#34;error allocating group writer&#34;);</p><p>+		return;</p><p>+	}</p><p>+</p><p>+	hdr.nlmsg_type = (cmd == RTM_DELETE) ? NL_RTM_DELADDR : NL_RTM_NEWADDR;</p><p>+</p><p>+	dump_iface_addr(&amp;nw, ifa-&gt;ifa_ifp, ifa, &amp;hdr);</p><p>+	nlmsg_flush(&amp;nw);</p><p>+}</p><p>+</p><p>+static void</p><p>+rtnl_handle_ifattach(void *arg, struct ifnet *ifp)</p><p>+{</p><p>+	struct nlmsghdr hdr = { .nlmsg_type = NL_RTM_NEWLINK };</p><p>+	struct nl_writer nw = {};</p><p>+</p><p>+	if (!nl_has_listeners(NETLINK_ROUTE, RTNLGRP_LINK))</p><p>+		return;</p><p>+</p><p>+	if (!nlmsg_get_group_writer(&amp;nw, NLMSG_LARGE, NETLINK_ROUTE, RTNLGRP_LINK)) {</p><p>+		NL_LOG(LOG_DEBUG, &#34;error allocating mbuf&#34;);</p><p>+		return;</p><p>+	}</p><p>+	dump_iface(&amp;nw, ifp, &amp;hdr);</p><p>+        nlmsg_flush(&amp;nw);</p><p>+}</p><p>+</p><p>+static void</p><p>+rtnl_handle_ifdetach(void *arg, struct ifnet *ifp)</p><p>+{</p><p>+	struct nlmsghdr hdr = { .nlmsg_type = NL_RTM_DELLINK };</p><p>+	struct nl_writer nw = {};</p><p>+</p><p>+	if (!nl_has_listeners(NETLINK_ROUTE, RTNLGRP_LINK))</p><p>+		return;</p><p>+</p><p>+	if (!nlmsg_get_group_writer(&amp;nw, NLMSG_LARGE, NETLINK_ROUTE, RTNLGRP_LINK)) {</p><p>+		NL_LOG(LOG_DEBUG, &#34;error allocating mbuf&#34;);</p><p>+		return;</p><p>+	}</p><p>+	dump_iface(&amp;nw, ifp, &amp;hdr);</p><p>+        nlmsg_flush(&amp;nw);</p><p>+}</p><p>+</p><p>+static const struct rtnl_cmd_handler cmd_handlers[] = {</p><p>+	{</p><p>+		.cmd = NL_RTM_GETLINK,</p><p>+		.name = &#34;RTM_GETLINK&#34;,</p><p>+		.cb = &amp;rtnl_handle_getlink,</p><p>+		.flags = RTNL_F_NOEPOCH,</p><p>+	},</p><p>+	{</p><p>+		.cmd = NL_RTM_DELLINK,</p><p>+		.name = &#34;RTM_DELLINK&#34;,</p><p>+		.cb = &amp;rtnl_handle_dellink,</p><p>+		.priv = PRIV_NET_IFDESTROY,</p><p>+		.flags = RTNL_F_NOEPOCH,</p><p>+	},</p><p>+	{</p><p>+		.cmd = NL_RTM_NEWLINK,</p><p>+		.name = &#34;RTM_NEWLINK&#34;,</p><p>+		.cb = &amp;rtnl_handle_newlink,</p><p>+		.priv = PRIV_NET_IFCREATE,</p><p>+		.flags = RTNL_F_NOEPOCH,</p><p>+	},</p><p>+	{</p><p>+		.cmd = NL_RTM_GETADDR,</p><p>+		.name = &#34;RTM_GETADDR&#34;,</p><p>+		.cb = &amp;rtnl_handle_getaddr,</p><p>+	},</p><p>+	{</p><p>+		.cmd = NL_RTM_NEWADDR,</p><p>+		.name = &#34;RTM_NEWADDR&#34;,</p><p>+		.cb = &amp;rtnl_handle_getaddr,</p><p>+	},</p><p>+	{</p><p>+		.cmd = NL_RTM_DELADDR,</p><p>+		.name = &#34;RTM_DELADDR&#34;,</p><p>+		.cb = &amp;rtnl_handle_getaddr,</p><p>+	},</p><p>+};</p><p>+</p><p>+static const struct nlhdr_parser *all_parsers[] = { &amp;ifmsg_parser };</p><p>+</p><p>+void</p><p>+rtnl_iface_add_cloner(struct nl_cloner *cloner)</p><p>+{</p><p>+	sx_xlock(&amp;rtnl_cloner_lock);</p><p>+	SLIST_INSERT_HEAD(&amp;nl_cloners, cloner, next);</p><p>+	sx_xunlock(&amp;rtnl_cloner_lock);</p><p>+}</p><p>+</p><p>+void rtnl_iface_del_cloner(struct nl_cloner *cloner)</p><p>+{</p><p>+	sx_xlock(&amp;rtnl_cloner_lock);</p><p>+	SLIST_REMOVE(&amp;nl_cloners, cloner, nl_cloner, next);</p><p>+	sx_xunlock(&amp;rtnl_cloner_lock);</p><p>+}</p><p>+</p><p>+void</p><p>+rtnl_ifaces_init(void)</p><p>+{</p><p>+	ifattach_event = EVENTHANDLER_REGISTER(</p><p>+	    ifnet_arrival_event, rtnl_handle_ifattach, NULL,</p><p>+	    EVENTHANDLER_PRI_ANY);</p><p>+	ifdetach_event = EVENTHANDLER_REGISTER(</p><p>+	    ifnet_departure_event, rtnl_handle_ifdetach, NULL,</p><p>+	    EVENTHANDLER_PRI_ANY);</p><p>+	ifaddr_event = EVENTHANDLER_REGISTER(</p><p>+	    rt_addrmsg, rtnl_handle_ifaddr, NULL,</p><p>+	    EVENTHANDLER_PRI_ANY);</p><p>+	NL_VERIFY_PARSERS(all_parsers);</p><p>+	rtnl_iface_drivers_register();</p><p>+	rtnl_register_messages(cmd_handlers, NL_ARRAY_LEN(cmd_handlers));</p><p>+}</p><p>+</p><p>+void</p><p>+rtnl_ifaces_destroy(void)</p><p>+{</p><p>+	EVENTHANDLER_DEREGISTER(ifnet_arrival_event, ifattach_event);</p><p>+	EVENTHANDLER_DEREGISTER(ifnet_departure_event, ifdetach_event);</p><p>+	EVENTHANDLER_DEREGISTER(rt_addrmsg, ifaddr_event);</p><p>+}</p><div><p>diff --git a/sys/netlink/route/iface_drivers.c b/sys/netlink/route/iface_drivers.c</p></div><p>@@ -0,0 +1,165 @@</p><p>+/*-</p><p>+ * SPDX-License-Identifier: BSD-2-Clause-FreeBSD</p><p>+ *</p><p>+ * Copyright (c) 2022 Alexander V. Chernikov &lt;melifaro@FreeBSD.org&gt;</p><p>+ *</p><p>+ * Redistribution and use in source and binary forms, with or without</p><p>+ * modification, are permitted provided that the following conditions</p><p>+ * are met:</p><p>+ * 1. Redistributions of source code must retain the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer.</p><p>+ * 2. Redistributions in binary form must reproduce the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer in the</p><p>+ *    documentation and/or other materials provided with the distribution.</p><p>+ *</p><p>+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&#39;&#39; AND</p><p>+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</p><p>+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</p><p>+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE</p><p>+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</p><p>+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</p><p>+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</p><p>+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</p><p>+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</p><p>+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</p><p>+ * SUCH DAMAGE.</p><p>+ */</p><p>+</p><p>+#include &lt;sys/cdefs.h&gt;</p><p>+__FBSDID(&#34;$FreeBSD$&#34;);</p><p>+#include &#34;opt_inet.h&#34;</p><p>+#include &#34;opt_inet6.h&#34;</p><p>+#include &lt;sys/types.h&gt;</p><p>+#include &lt;sys/malloc.h&gt;</p><p>+#include &lt;sys/socket.h&gt;</p><p>+#include &lt;sys/sockio.h&gt;</p><p>+#include &lt;sys/syslog.h&gt;</p><p>+#include &lt;sys/socketvar.h&gt;</p><p>+</p><p>+#include &lt;net/ethernet.h&gt;</p><p>+#include &lt;net/if.h&gt;</p><p>+#include &lt;net/if_dl.h&gt;</p><p>+#include &lt;net/if_media.h&gt;</p><p>+#include &lt;net/if_var.h&gt;</p><p>+#include &lt;net/if_clone.h&gt;</p><p>+#include &lt;net/if_vlan_var.h&gt;</p><p>+#include &lt;net/route.h&gt;</p><p>+#include &lt;net/route/nhop.h&gt;</p><p>+#include &lt;net/route/route_ctl.h&gt;</p><p>+#include &lt;netlink/netlink.h&gt;</p><p>+#include &lt;netlink/netlink_ctl.h&gt;</p><p>+#include &lt;netlink/netlink_route.h&gt;</p><p>+#include &lt;netlink/route/route_var.h&gt;</p><p>+</p><p>+#include &lt;netinet6/scope6_var.h&gt; /* scope deembedding */</p><p>+</p><p>+#define	DEBUG_MOD_NAME	nl_iface_drivers</p><p>+#define	DEBUG_MAX_LEVEL	LOG_DEBUG3</p><p>+#include &lt;netlink/netlink_debug.h&gt;</p><p>+_DECLARE_DEBUG(LOG_DEBUG);</p><p>+</p><p>+/*</p><p>+ *</p><p>+ * {len=76, type=RTM_NEWLINK, flags=NLM_F_REQUEST|NLM_F_ACK|NLM_F_EXCL|NLM_F_CREATE, seq=1662892737, pid=0},</p><p>+ *  {ifi_family=AF_UNSPEC, ifi_type=ARPHRD_NETROM, ifi_index=0, ifi_flags=0, ifi_change=0},</p><p>+ *   [</p><p>+ *    {{nla_len=8, nla_type=IFLA_LINK}, 2},</p><p>+ *    {{nla_len=12, nla_type=IFLA_IFNAME}, &#34;xvlan22&#34;},</p><p>+ *    {{nla_len=24, nla_type=IFLA_LINKINFO},</p><p>+ *     [</p><p>+ *      {{nla_len=8, nla_type=IFLA_INFO_KIND}, &#34;vlan&#34;...},</p><p>+ *      {{nla_len=12, nla_type=IFLA_INFO_DATA}, &#34;\x06\x00\x01\x00\x16\x00\x00\x00&#34;}]}]}, iov_len=76}], msg_iovlen=1, msg_controllen=0, msg_flags=0}, 0) = 76</p><p>+ */</p><p>+</p><p>+struct nl_parsed_vlan {</p><p>+	uint16_t vlan_id;</p><p>+	uint16_t vlan_proto;</p><p>+	struct ifla_vlan_flags vlan_flags;</p><p>+};</p><p>+</p><p>+#define	_OUT(_field)	offsetof(struct nl_parsed_vlan, _field)</p><p>+static const struct nlattr_parser nla_p_vlan[] = {</p><p>+	{ .type = IFLA_VLAN_ID, .off = _OUT(vlan_id), .cb = nlattr_get_uint16 },</p><p>+	{ .type = IFLA_VLAN_FLAGS, .off = _OUT(vlan_flags), .cb = nlattr_get_nla },</p><p>+	{ .type = IFLA_VLAN_PROTOCOL, .off = _OUT(vlan_proto), .cb = nlattr_get_uint16 },</p><p>+};</p><p>+#undef _OUT</p><p>+NL_DECLARE_ATTR_PARSER(vlan_parser, nla_p_vlan);</p><p>+</p><p>+static int</p><p>+create_vlan(struct nl_parsed_link *lattrs, struct nlpcb *nlp, struct nl_pstate *npt)</p><p>+{</p><p>+	struct epoch_tracker et;</p><p>+        struct ifnet *ifp;</p><p>+	int error;</p><p>+</p><p>+	/*</p><p>+	 * lattrs.ifla_ifname is the new interface name</p><p>+	 * lattrs.ifi_index contains parent interface index</p><p>+	 * lattrs.ifla_idata contains un-parsed vlan data</p><p>+	 */</p><p>+</p><p>+	struct nl_parsed_vlan attrs = {</p><p>+		.vlan_id = 0xFEFE,</p><p>+		.vlan_proto = ETHERTYPE_VLAN</p><p>+	};</p><p>+	NLP_LOG(LOG_DEBUG3, nlp, &#34;nested: %p len %d&#34;, lattrs-&gt;ifla_idata, lattrs-&gt;ifla_idata-&gt;nla_len);</p><p>+</p><p>+	if (lattrs-&gt;ifla_idata == NULL) {</p><p>+		NLMSG_REPORT_ERR_MSG(npt, &#34;vlan id is required, guessing not supported&#34;);</p><p>+		return (ENOTSUP);</p><p>+	}</p><p>+</p><p>+	error = nl_parse_nested(lattrs-&gt;ifla_idata, &amp;vlan_parser, npt, &amp;attrs);</p><p>+	if (error != 0)</p><p>+		return (error);</p><p>+	if (attrs.vlan_id &gt; 4095) {</p><p>+		NLMSG_REPORT_ERR_MSG(npt, &#34;Invalid VID: %d&#34;, attrs.vlan_id);</p><p>+		return (EINVAL);</p><p>+	}</p><p>+	if (attrs.vlan_proto != ETHERTYPE_VLAN &amp;&amp; attrs.vlan_proto != ETHERTYPE_QINQ) {</p><p>+		NLMSG_REPORT_ERR_MSG(npt, &#34;Unsupported ethertype: 0x%04X&#34;, attrs.vlan_proto);</p><p>+		return (ENOTSUP);</p><p>+	}</p><p>+</p><p>+	NET_EPOCH_ENTER(et);</p><p>+	ifp = ifnet_byindex_ref(lattrs-&gt;ifi_index);</p><p>+	NET_EPOCH_EXIT(et);</p><p>+	if (ifp == NULL) {</p><p>+		NLP_LOG(LOG_DEBUG, nlp, &#34;unable to find parent interface %u&#34;,</p><p>+		    lattrs-&gt;ifi_index);</p><p>+		return (ENOENT);</p><p>+	}</p><p>+</p><p>+	/* Waiting till if_clone changes lands */</p><p>+/*</p><p>+	struct vlanreq params = {</p><p>+		.vlr_tag = attrs.vlan_id,</p><p>+		.vlr_proto = attrs.vlan_proto,</p><p>+	};</p><p>+*/</p><p>+	int ifname_len = strlen(lattrs-&gt;ifla_ifname) + 1;</p><p>+	error = if_clone_create(lattrs-&gt;ifla_ifname, ifname_len, (char *)NULL);</p><p>+</p><p>+	NLP_LOG(LOG_DEBUG2, nlp, &#34;clone for %s returned %d&#34;, lattrs-&gt;ifla_ifname, error);</p><p>+</p><p>+	if_rele(ifp);</p><p>+	return (error);</p><p>+}</p><p>+</p><p>+static struct nl_cloner vlan_cloner = {</p><p>+	.name = &#34;vlan&#34;,</p><p>+	.create_f = create_vlan,</p><p>+</p><p>+};</p><p>+</p><p>+static const struct nlhdr_parser *all_parsers[] = { &amp;vlan_parser };</p><p>+</p><p>+void</p><p>+rtnl_iface_drivers_register(void)</p><p>+{</p><p>+	rtnl_iface_add_cloner(&amp;vlan_cloner);</p><p>+	NL_VERIFY_PARSERS(all_parsers);</p><p>+}</p><p>+</p><p>+</p><div><p>diff --git a/sys/netlink/route/ifaddrs.h b/sys/netlink/route/ifaddrs.h</p></div><p>@@ -0,0 +1,90 @@</p><p>+/*-</p><p>+ * SPDX-License-Identifier: BSD-2-Clause-FreeBSD</p><p>+ *</p><p>+ * Copyright (c) 2022 Alexander V. Chernikov &lt;melifaro@FreeBSD.org&gt;</p><p>+ *</p><p>+ * Redistribution and use in source and binary forms, with or without</p><p>+ * modification, are permitted provided that the following conditions</p><p>+ * are met:</p><p>+ * 1. Redistributions of source code must retain the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer.</p><p>+ * 2. Redistributions in binary form must reproduce the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer in the</p><p>+ *    documentation and/or other materials provided with the distribution.</p><p>+ *</p><p>+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&#39;&#39; AND</p><p>+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</p><p>+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</p><p>+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE</p><p>+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</p><p>+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</p><p>+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</p><p>+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</p><p>+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</p><p>+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</p><p>+ * SUCH DAMAGE.</p><p>+ */</p><p>+</p><p>+/*</p><p>+ * Interface address-related (RTM_&lt;NEW|DEL|GET&gt;ADDR) message header and attributes.</p><p>+ */</p><p>+</p><p>+#ifndef _NETLINK_ROUTE_IFADDRS_H_</p><p>+#define _NETLINK_ROUTE_IFADDRS_H_</p><p>+</p><p>+/* Base header for all of the relevant messages */</p><p>+struct ifaddrmsg {</p><p>+	uint8_t		ifa_family;	/* Address family */</p><p>+	uint8_t		ifa_prefixlen;	/* Prefix length */</p><p>+	uint8_t		ifa_flags;	/* Address-specific flags */</p><p>+	uint8_t		ifa_scope;	/* Address scope */</p><p>+	uint32_t	ifa_index;	/* Link ifindex */</p><p>+};</p><p>+</p><p>+#ifndef _KERNEL</p><p>+#define	_NL_IFA_HDRLEN		((int)sizeof(struct ifaddrmsg))</p><p>+#define	IFA_RTA(_ifa)		((struct rtattr *)(NL_ITEM_DATA(_ifa, _NL_IFA_HDRLEN)))</p><p>+#define	IFA_PAYLOAD(_hdr)	NLMSG_PAYLOAD(_hdr, _NL_IFA_HDRLEN)</p><p>+#endif</p><p>+</p><p>+/* Defined attributes */</p><p>+enum {</p><p>+	IFA_UNSPEC,</p><p>+	IFA_ADDRESS		= 1, /* binary, prefix address (destination for p2p) */</p><p>+	IFA_LOCAL		= 2, /* binary, interface address */</p><p>+	IFA_LABEL		= 3, /* not supported */</p><p>+	IFA_BROADCAST		= 4, /* binary, broadcast ifa */</p><p>+	IFA_ANYCAST		= 5, /* not supported */</p><p>+	IFA_CACHEINFO		= 6, /* not supported */</p><p>+	IFA_MULTICAST		= 7, /* not supported */</p><p>+	IFA_FLAGS		= 8, /* not supported */</p><p>+	IFA_RT_PRIORITY		= 9, /* not supported */</p><p>+	IFA_TARGET_NETNSID	= 10, /* not supported */</p><p>+	__IFA_MAX,</p><p>+};</p><p>+#define IFA_MAX (__IFA_MAX - 1)</p><p>+</p><p>+/* IFA_FLAGS attribute flags */</p><p>+#define IFA_F_SECONDARY		0x0001</p><p>+#define IFA_F_TEMPORARY		IFA_F_SECONDARY</p><p>+#define IFA_F_NODAD		0x0002</p><p>+#define IFA_F_OPTIMISTIC	0x0004</p><p>+#define IFA_F_DADFAILED		0x0008</p><p>+#define IFA_F_HOMEADDRESS	0x0010</p><p>+#define IFA_F_DEPRECATED	0x0020</p><p>+#define IFA_F_TENTATIVE		0x0040</p><p>+#define IFA_F_PERMANENT		0x0080</p><p>+#define IFA_F_MANAGETEMPADDR	0x0100</p><p>+#define IFA_F_NOPREFIXROUTE	0x0200</p><p>+#define IFA_F_MCAUTOJOIN	0x0400</p><p>+#define IFA_F_STABLE_PRIVACY	0x0800</p><p>+</p><p>+/* IFA_CACHEINFO value */</p><p>+struct ifa_cacheinfo {</p><p>+	uint32_t ifa_prefered;</p><p>+	uint32_t ifa_valid;</p><p>+	uint32_t cstamp;</p><p>+	uint32_t tstamp;</p><p>+};</p><p>+</p><p>+#endif</p><div><p>diff --git a/sys/netlink/route/interface.h b/sys/netlink/route/interface.h</p></div><p>@@ -0,0 +1,245 @@</p><p>+/*-</p><p>+ * SPDX-License-Identifier: BSD-2-Clause-FreeBSD</p><p>+ *</p><p>+ * Copyright (c) 2022 Alexander V. Chernikov &lt;melifaro@FreeBSD.org&gt;</p><p>+ *</p><p>+ * Redistribution and use in source and binary forms, with or without</p><p>+ * modification, are permitted provided that the following conditions</p><p>+ * are met:</p><p>+ * 1. Redistributions of source code must retain the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer.</p><p>+ * 2. Redistributions in binary form must reproduce the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer in the</p><p>+ *    documentation and/or other materials provided with the distribution.</p><p>+ *</p><p>+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&#39;&#39; AND</p><p>+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</p><p>+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</p><p>+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE</p><p>+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</p><p>+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</p><p>+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</p><p>+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</p><p>+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</p><p>+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</p><p>+ * SUCH DAMAGE.</p><p>+ */</p><p>+</p><p>+/*</p><p>+ * Interface-related (RTM_&lt;NEW|DEL|GET|SET&gt;LINK) message header and attributes.</p><p>+ */</p><p>+</p><p>+#ifndef _NETLINK_ROUTE_INTERFACE_H_</p><p>+#define _NETLINK_ROUTE_INTERFACE_H_</p><p>+</p><p>+/* Base header for all of the relevant messages */</p><p>+struct ifinfomsg {</p><p>+	unsigned char	ifi_family;	/* not used */</p><p>+	unsigned char	__ifi_pad;</p><p>+	unsigned short	ifi_type;	/* ARPHRD_* */</p><p>+	int		ifi_index;	/* Inteface index */</p><p>+	unsigned	ifi_flags;	/* IFF_* flags */</p><p>+	unsigned	ifi_change;	/* IFF_* change mask */</p><p>+};</p><p>+</p><p>+#ifndef _KERNEL</p><p>+/* Compatilbility helpers */</p><p>+#define	_IFINFO_HDRLEN		((int)sizeof(struct ifinfomsg))</p><p>+#define	IFLA_RTA(_ifi)		((struct rtattr *)NL_ITEM_DATA(_ifi, _IFINFO_HDRLEN))</p><p>+#define	IFLA_PAYLOAD(_ifi)	NLMSG_PAYLOAD(_ifi, _IFINFO_HDRLEN)</p><p>+#endif</p><p>+</p><p>+enum {</p><p>+	IFLA_UNSPEC	= 0,</p><p>+	IFLA_ADDRESS	= 1,	/* binary: Link-level address (MAC) */</p><p>+#define	IFLA_ADDRESS IFLA_ADDRESS</p><p>+	IFLA_BROADCAST	= 2,	/* binary: link-level broadcast address */</p><p>+#define	IFLA_BROADCAST IFLA_BROADCAST</p><p>+	IFLA_IFNAME	= 3,	/* string: Interface name */</p><p>+#define	IFLA_IFNAME IFLA_IFNAME</p><p>+	IFLA_MTU	= 4,	/* u32: Current interface L3 mtu */</p><p>+#define	IFLA_MTU IFLA_MTU</p><p>+	IFLA_LINK	= 5,	/* u32: interface index */</p><p>+#define	IFLA_LINK IFLA_LINK</p><p>+	IFLA_QDISC	= 6,	/* string: Queing policy (not supported) */</p><p>+#define	IFLA_QDISC IFLA_QDISC</p><p>+	IFLA_STATS	= 7,	/* Interface counters */</p><p>+#define	IFLA_STATS IFLA_STATS</p><p>+	IFLA_COST	= 8,	/* not supported */</p><p>+#define IFLA_COST IFLA_COST</p><p>+	IFLA_PRIORITY	= 9,	/* not supported */</p><p>+#define IFLA_PRIORITY IFLA_PRIORITY</p><p>+	IFLA_MASTER	= 10,	/* u32: parent interface ifindex */</p><p>+#define IFLA_MASTER IFLA_MASTER</p><p>+	IFLA_WIRELESS	= 11,	/* not supported */</p><p>+#define IFLA_WIRELESS IFLA_WIRELESS</p><p>+	IFLA_PROTINFO	= 12,	/* protocol-specific data */</p><p>+#define IFLA_PROTINFO IFLA_PROTINFO</p><p>+	IFLA_TXQLEN	= 13,	/* u32: transmit queue length */</p><p>+#define IFLA_TXQLEN IFLA_TXQLEN</p><p>+	IFLA_MAP	= 14,	/* not supported */</p><p>+#define IFLA_MAP IFLA_MAP</p><p>+	IFLA_WEIGHT	= 15,	/* not supported */</p><p>+#define IFLA_WEIGHT IFLA_WEIGHT</p><p>+	IFLA_OPERSTATE	= 16,	/* u8: ifOperStatus per RFC 2863 */</p><p>+#define	IFLA_OPERSTATE IFLA_OPERSTATE</p><p>+	IFLA_LINKMODE	= 17,	/* u8: ifmedia (not supported) */</p><p>+#define	IFLA_LINKMODE IFLA_LINKMODE</p><p>+	IFLA_LINKINFO	= 18,	/* nested: IFLA_INFO_ */</p><p>+#define IFLA_LINKINFO IFLA_LINKINFO</p><p>+	IFLA_NET_NS_PID	= 19,	/* u32: vnet id (not supported) */</p><p>+#define	IFLA_NET_NS_PID IFLA_NET_NS_PID</p><p>+	IFLA_IFALIAS	= 20,	/* not supported */</p><p>+#define	IFLA_IFALIAS IFLA_IFALIAS</p><p>+	IFLA_NUM_VF	= 21,	/* not supported */</p><p>+#define	IFLA_NUM_VF IFLA_NUM_VF</p><p>+	IFLA_VFINFO_LIST= 22,	/* not supported */</p><p>+#define	IFLA_VFINFO_LIST IFLA_VFINFO_LIST</p><p>+	IFLA_STATS64	= 23,	/* rtnl_link_stats64: iface stats */</p><p>+#define	IFLA_STATS64 IFLA_STATS64</p><p>+	IFLA_VF_PORTS,</p><p>+	IFLA_PORT_SELF,</p><p>+	IFLA_AF_SPEC,</p><p>+	IFLA_GROUP, /* Group the device belongs to */</p><p>+	IFLA_NET_NS_FD,</p><p>+	IFLA_EXT_MASK,	  /* Extended info mask, VFs, etc */</p><p>+	IFLA_PROMISCUITY, /* Promiscuity count: &gt; 0 means acts PROMISC */</p><p>+#define IFLA_PROMISCUITY IFLA_PROMISCUITY</p><p>+	IFLA_NUM_TX_QUEUES,</p><p>+	IFLA_NUM_RX_QUEUES,</p><p>+	IFLA_CARRIER,</p><p>+	IFLA_PHYS_PORT_ID,</p><p>+	IFLA_CARRIER_CHANGES,</p><p>+	IFLA_PHYS_SWITCH_ID,</p><p>+	IFLA_LINK_NETNSID,</p><p>+	IFLA_PHYS_PORT_NAME,</p><p>+	IFLA_PROTO_DOWN,</p><p>+	IFLA_GSO_MAX_SEGS,</p><p>+	IFLA_GSO_MAX_SIZE,</p><p>+	IFLA_PAD,</p><p>+	IFLA_XDP,</p><p>+	IFLA_EVENT,</p><p>+	IFLA_NEW_NETNSID,</p><p>+	IFLA_IF_NETNSID,</p><p>+	IFLA_TARGET_NETNSID = IFLA_IF_NETNSID, /* new alias */</p><p>+	IFLA_CARRIER_UP_COUNT,</p><p>+	IFLA_CARRIER_DOWN_COUNT,</p><p>+	IFLA_NEW_IFINDEX,</p><p>+	IFLA_MIN_MTU,</p><p>+	IFLA_MAX_MTU,</p><p>+	IFLA_PROP_LIST,</p><p>+	IFLA_ALT_IFNAME, /* Alternative ifname */</p><p>+	IFLA_PERM_ADDRESS,</p><p>+	IFLA_PROTO_DOWN_REASON,</p><p>+	__IFLA_MAX</p><p>+};</p><p>+#define IFLA_MAX (__IFLA_MAX - 1)</p><p>+</p><p>+/*</p><p>+ * Attributes that can be used as filters:</p><p>+ *  IFLA_IFNAME, IFLA_GROUP, IFLA_ALT_IFNAME</p><p>+ * Headers that can be used as filters:</p><p>+ *  ifi_index, ifi_type</p><p>+ */</p><p>+</p><p>+/*</p><p>+ * IFLA_OPERSTATE.</p><p>+ * The values below represent the possible</p><p>+ * states of ifOperStatus defined by RFC 2863</p><p>+ */</p><p>+enum {</p><p>+	IF_OPER_UNKNOWN		= 0, /* status can not be determined */</p><p>+	IF_OPER_NOTPRESENT	= 1, /* some (hardware) component not present */</p><p>+	IF_OPER_DOWN		= 2, /* down */</p><p>+	IF_OPER_LOWERLAYERDOWN	= 3, /* some lower-level interface is down */</p><p>+	IF_OPER_TESTING		= 4, /* in some test mode */</p><p>+	IF_OPER_DORMANT		= 5, /* &#34;up&#34; but waiting for some condition (802.1X) */</p><p>+	IF_OPER_UP		= 6, /* ready to pass packets */</p><p>+};</p><p>+</p><p>+/* IFLA_STATS */</p><p>+struct rtnl_link_stats {</p><p>+	uint32_t rx_packets;	/* total RX packets (IFCOUNTER_IPACKETS) */</p><p>+	uint32_t tx_packets;	/* total TX packets (IFCOUNTER_OPACKETS) */</p><p>+	uint32_t rx_bytes;	/* total RX bytes (IFCOUNTER_IBYTES) */</p><p>+	uint32_t tx_bytes;	/* total TX bytes (IFCOUNTER_OBYTES) */</p><p>+	uint32_t rx_errors;	/* RX errors (IFCOUNTER_IERRORS) */</p><p>+	uint32_t tx_errors;	/* RX errors (IFCOUNTER_OERRORS) */</p><p>+	uint32_t rx_dropped;	/* RX drop (no space in ring/no bufs) (IFCOUNTER_IQDROPS) */</p><p>+	uint32_t tx_dropped;	/* TX drop (IFCOUNTER_OQDROPS) */</p><p>+	uint32_t multicast;	/* RX multicast packets (IFCOUNTER_IMCASTS) */</p><p>+	uint32_t collisions;	/* not supported */</p><p>+	uint32_t rx_length_errors;	/* not supported */</p><p>+	uint32_t rx_over_errors;	/* not supported */</p><p>+	uint32_t rx_crc_errors;		/* not supported */</p><p>+	uint32_t rx_frame_errors;	/* not supported */</p><p>+	uint32_t rx_fifo_errors;	/* not supported */</p><p>+	uint32_t rx_missed_errors;	/* not supported */</p><p>+	uint32_t tx_aborted_errors;	/* not supported */</p><p>+	uint32_t tx_carrier_errors;	/* not supported */</p><p>+	uint32_t tx_fifo_errors;	/* not supported */</p><p>+	uint32_t tx_heartbeat_errors;	/* not supported */</p><p>+	uint32_t tx_window_errors;	/* not supported */</p><p>+	uint32_t rx_compressed;		/* not supported */</p><p>+	uint32_t tx_compressed;		/* not supported */</p><p>+	uint32_t rx_nohandler;	/* dropped due to no proto handler (IFCOUNTER_NOPROTO) */</p><p>+};</p><p>+</p><p>+/* IFLA_STATS64 */</p><p>+struct rtnl_link_stats64 {</p><p>+	uint64_t rx_packets;	/* total RX packets (IFCOUNTER_IPACKETS) */</p><p>+	uint64_t tx_packets;	/* total TX packets (IFCOUNTER_OPACKETS) */</p><p>+	uint64_t rx_bytes;	/* total RX bytes (IFCOUNTER_IBYTES) */</p><p>+	uint64_t tx_bytes;	/* total TX bytes (IFCOUNTER_OBYTES) */</p><p>+	uint64_t rx_errors;	/* RX errors (IFCOUNTER_IERRORS) */</p><p>+	uint64_t tx_errors;	/* RX errors (IFCOUNTER_OERRORS) */</p><p>+	uint64_t rx_dropped;	/* RX drop (no space in ring/no bufs) (IFCOUNTER_IQDROPS) */</p><p>+	uint64_t tx_dropped;	/* TX drop (IFCOUNTER_OQDROPS) */</p><p>+	uint64_t multicast;	/* RX multicast packets (IFCOUNTER_IMCASTS) */</p><p>+	uint64_t collisions;	/* not supported */</p><p>+	uint64_t rx_length_errors;	/* not supported */</p><p>+	uint64_t rx_over_errors;	/* not supported */</p><p>+	uint64_t rx_crc_errors;		/* not supported */</p><p>+	uint64_t rx_frame_errors;	/* not supported */</p><p>+	uint64_t rx_fifo_errors;	/* not supported */</p><p>+	uint64_t rx_missed_errors;	/* not supported */</p><p>+	uint64_t tx_aborted_errors;	/* not supported */</p><p>+	uint64_t tx_carrier_errors;	/* not supported */</p><p>+	uint64_t tx_fifo_errors;	/* not supported */</p><p>+	uint64_t tx_heartbeat_errors;	/* not supported */</p><p>+	uint64_t tx_window_errors;	/* not supported */</p><p>+	uint64_t rx_compressed;		/* not supported */</p><p>+	uint64_t tx_compressed;		/* not supported */</p><p>+	uint64_t rx_nohandler;	/* dropped due to no proto handler (IFCOUNTER_NOPROTO) */</p><p>+};</p><p>+</p><p>+/* IFLA_LINKINFO child nlattr types */</p><p>+enum {</p><p>+	IFLA_INFO_UNSPEC,</p><p>+	IFLA_INFO_KIND		= 1, /* string, link type (&#34;vlan&#34;) */</p><p>+	IFLA_INFO_DATA		= 2, /* Per-link-type custom data */</p><p>+	IFLA_INFO_XSTATS	= 3,</p><p>+	IFLA_INFO_SLAVE_KIND	= 4,</p><p>+	IFLA_INFO_SLAVE_DATA	= 5,</p><p>+	__IFLA_INFO_MAX,</p><p>+};</p><p>+#define IFLA_INFO_MAX	(__IFLA_INFO_MAX - 1)</p><p>+</p><p>+/* IFLA_INFO_DATA vlan attributes */</p><p>+enum {</p><p>+	IFLA_VLAN_UNSPEC,</p><p>+	IFLA_VLAN_ID,</p><p>+	IFLA_VLAN_FLAGS,</p><p>+	IFLA_VLAN_EGRESS_QOS,</p><p>+	IFLA_VLAN_INGRESS_QOS,</p><p>+	IFLA_VLAN_PROTOCOL,</p><p>+	__IFLA_VLAN_MAX,</p><p>+};</p><p>+</p><p>+#define IFLA_VLAN_MAX	(__IFLA_VLAN_MAX - 1)</p><p>+struct ifla_vlan_flags {</p><p>+	uint32_t flags;</p><p>+	uint32_t mask;</p><p>+};</p><p>+</p><p>+#endif</p><div><p>diff --git a/sys/netlink/route/neigh.c b/sys/netlink/route/neigh.c</p></div><p>@@ -0,0 +1,571 @@</p><p>+/*-</p><p>+ * SPDX-License-Identifier: BSD-2-Clause-FreeBSD</p><p>+ *</p><p>+ * Copyright (c) 2022 Alexander V. Chernikov &lt;melifaro@FreeBSD.org&gt;</p><p>+ *</p><p>+ * Redistribution and use in source and binary forms, with or without</p><p>+ * modification, are permitted provided that the following conditions</p><p>+ * are met:</p><p>+ * 1. Redistributions of source code must retain the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer.</p><p>+ * 2. Redistributions in binary form must reproduce the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer in the</p><p>+ *    documentation and/or other materials provided with the distribution.</p><p>+ *</p><p>+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&#39;&#39; AND</p><p>+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</p><p>+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</p><p>+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE</p><p>+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</p><p>+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</p><p>+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</p><p>+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</p><p>+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</p><p>+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</p><p>+ * SUCH DAMAGE.</p><p>+ */</p><p>+</p><p>+#include &lt;sys/cdefs.h&gt;</p><p>+__FBSDID(&#34;$FreeBSD$&#34;);</p><p>+#include &#34;opt_inet.h&#34;</p><p>+#include &#34;opt_inet6.h&#34;</p><p>+#include &lt;sys/types.h&gt;</p><p>+#include &lt;sys/malloc.h&gt;</p><p>+#include &lt;sys/socket.h&gt;</p><p>+#include &lt;sys/syslog.h&gt;</p><p>+</p><p>+#include &lt;net/if.h&gt;</p><p>+#include &lt;net/if_llatbl.h&gt;</p><p>+#include &lt;netlink/netlink.h&gt;</p><p>+#include &lt;netlink/netlink_ctl.h&gt;</p><p>+#include &lt;netlink/netlink_route.h&gt;</p><p>+#include &lt;netlink/route/route_var.h&gt;</p><p>+</p><p>+#include &lt;netinet6/in6_var.h&gt;		/* nd6.h requires this */</p><p>+#include &lt;netinet6/nd6.h&gt;		/* nd6 state machine */</p><p>+#include &lt;netinet6/scope6_var.h&gt;	/* scope deembedding */</p><p>+</p><p>+#define	DEBUG_MOD_NAME	nl_neigh</p><p>+#define	DEBUG_MAX_LEVEL	LOG_DEBUG3</p><p>+#include &lt;netlink/netlink_debug.h&gt;</p><p>+_DECLARE_DEBUG(LOG_DEBUG);</p><p>+</p><p>+static int lle_families[] = { AF_INET, AF_INET6 };</p><p>+</p><p>+static eventhandler_tag lle_event_p;</p><p>+</p><p>+struct netlink_walkargs {</p><p>+	struct nl_writer *nw;</p><p>+	struct nlmsghdr hdr;</p><p>+	struct nlpcb *so;</p><p>+	struct ifnet *ifp;</p><p>+	int family;</p><p>+	int error;</p><p>+	int count;</p><p>+	int dumped;</p><p>+};</p><p>+</p><p>+static int</p><p>+lle_state_to_nl_state(int family, struct llentry *lle)</p><p>+{</p><p>+	int state = lle-&gt;ln_state;</p><p>+</p><p>+	switch (family) {</p><p>+	case AF_INET:</p><p>+		if (lle-&gt;la_flags &amp; (LLE_STATIC | LLE_IFADDR))</p><p>+			state = 1;</p><p>+		switch (state) {</p><p>+		case 0: /* ARP_LLINFO_INCOMPLETE */</p><p>+			return (NUD_INCOMPLETE);</p><p>+		case 1: /* ARP_LLINFO_REACHABLE  */</p><p>+			return (NUD_REACHABLE);</p><p>+		case 2: /* ARP_LLINFO_VERIFY */</p><p>+			return (NUD_PROBE);</p><p>+		}</p><p>+		break;</p><p>+	case AF_INET6:</p><p>+		switch (state) {</p><p>+		case ND6_LLINFO_INCOMPLETE:</p><p>+			return (NUD_INCOMPLETE);</p><p>+		case ND6_LLINFO_REACHABLE:</p><p>+			return (NUD_REACHABLE);</p><p>+		case ND6_LLINFO_STALE:</p><p>+			return (NUD_STALE);</p><p>+		case ND6_LLINFO_DELAY:</p><p>+			return (NUD_DELAY);</p><p>+		case ND6_LLINFO_PROBE:</p><p>+			return (NUD_PROBE);</p><p>+		}</p><p>+		break;</p><p>+	}</p><p>+</p><p>+	return (NUD_NONE);</p><p>+}</p><p>+</p><p>+static uint32_t</p><p>+lle_flags_to_nl_flags(const struct llentry *lle)</p><p>+{</p><p>+	uint32_t nl_flags = 0;</p><p>+</p><p>+	if (lle-&gt;la_flags &amp; LLE_IFADDR)</p><p>+		nl_flags |= NTF_SELF;</p><p>+	if (lle-&gt;la_flags &amp; LLE_PUB)</p><p>+		nl_flags |= NTF_PROXY;</p><p>+	if (lle-&gt;la_flags &amp; LLE_STATIC)</p><p>+		nl_flags |= NTF_STICKY;</p><p>+	if (lle-&gt;ln_router != 0)</p><p>+		nl_flags |= NTF_ROUTER;</p><p>+</p><p>+	return (nl_flags);</p><p>+}</p><p>+</p><p>+static int</p><p>+dump_lle_locked(struct llentry *lle, void *arg)</p><p>+{</p><p>+	struct netlink_walkargs *wa = (struct netlink_walkargs *)arg;</p><p>+	struct nlmsghdr *hdr = &amp;wa-&gt;hdr;</p><p>+	struct nl_writer *nw = wa-&gt;nw;</p><p>+	struct ndmsg *ndm;</p><p>+	union {</p><p>+		struct in_addr	in;</p><p>+		struct in6_addr	in6;</p><p>+	} addr;</p><p>+</p><p>+	IF_DEBUG_LEVEL(LOG_DEBUG2) {</p><p>+		char llebuf[NHOP_PRINT_BUFSIZE];</p><p>+		llentry_print_buf_lltable(lle, llebuf, sizeof(llebuf));</p><p>+		NL_LOG(LOG_DEBUG2, &#34;dumping %s&#34;, llebuf);</p><p>+	}</p><p>+</p><p>+	if (!nlmsg_reply(nw, hdr, sizeof(struct ndmsg)))</p><p>+		goto enomem;</p><p>+</p><p>+	ndm = nlmsg_reserve_object(nw, struct ndmsg);</p><p>+	ndm-&gt;ndm_family = wa-&gt;family;</p><p>+	ndm-&gt;ndm_ifindex = wa-&gt;ifp-&gt;if_index;</p><p>+	ndm-&gt;ndm_state = lle_state_to_nl_state(wa-&gt;family, lle);</p><p>+	ndm-&gt;ndm_flags = lle_flags_to_nl_flags(lle);</p><p>+</p><p>+	switch (wa-&gt;family) {</p><p>+#ifdef INET</p><p>+	case AF_INET:</p><p>+		addr.in = lle-&gt;r_l3addr.addr4;</p><p>+		nlattr_add(nw, NDA_DST, 4, &amp;addr);</p><p>+		break;</p><p>+#endif</p><p>+#ifdef INET6</p><p>+	case AF_INET6:</p><p>+		addr.in6 = lle-&gt;r_l3addr.addr6;</p><p>+		in6_clearscope(&amp;addr.in6);</p><p>+		nlattr_add(nw, NDA_DST, 16, &amp;addr);</p><p>+		break;</p><p>+#endif</p><p>+	}</p><p>+</p><p>+	if (lle-&gt;r_flags &amp; RLLE_VALID) {</p><p>+		/* Has L2 */</p><p>+		int addrlen = wa-&gt;ifp-&gt;if_addrlen;</p><p>+		nlattr_add(nw, NDA_LLADDR, addrlen, lle-&gt;ll_addr);</p><p>+	}</p><p>+</p><p>+	nlattr_add_u32(nw, NDA_PROBES, lle-&gt;la_asked);</p><p>+</p><p>+	struct nda_cacheinfo *cache;</p><p>+	cache = nlmsg_reserve_attr(nw, NDA_CACHEINFO, struct nda_cacheinfo);</p><p>+	if (cache == NULL)</p><p>+		goto enomem;</p><p>+	/* TODO: provide confirmed/updated */</p><p>+	cache-&gt;ndm_refcnt = lle-&gt;lle_refcnt;</p><p>+</p><p>+        if (nlmsg_end(nw))</p><p>+		return (0);</p><p>+enomem:</p><p>+        NL_LOG(LOG_DEBUG, &#34;unable to dump lle state (ENOMEM)&#34;);</p><p>+        nlmsg_abort(nw);</p><p>+        return (ENOMEM);</p><p>+}</p><p>+</p><p>+static int</p><p>+dump_lle(struct lltable *llt, struct llentry *lle, void *arg)</p><p>+{</p><p>+	int error;</p><p>+</p><p>+	LLE_RLOCK(lle);</p><p>+	error = dump_lle_locked(lle, arg);</p><p>+	LLE_RUNLOCK(lle);</p><p>+	return (error);</p><p>+}</p><p>+</p><p>+static bool</p><p>+dump_llt(struct lltable *llt, struct netlink_walkargs *wa)</p><p>+{</p><p>+	lltable_foreach_lle(llt, dump_lle, wa);</p><p>+</p><p>+	return (true);</p><p>+}</p><p>+</p><p>+static int</p><p>+dump_llts_iface(struct netlink_walkargs *wa, struct ifnet *ifp, int family)</p><p>+{</p><p>+	int error = 0;</p><p>+</p><p>+	wa-&gt;ifp = ifp;</p><p>+	for (int i = 0; i &lt; sizeof(lle_families) / sizeof(int); i++) {</p><p>+		int fam = lle_families[i];</p><p>+		struct lltable *llt = lltable_get(ifp, fam);</p><p>+		if (llt != NULL &amp;&amp; (family == 0 || family == fam)) {</p><p>+			wa-&gt;count++;</p><p>+			wa-&gt;family = fam;</p><p>+			if (!dump_llt(llt, wa)) {</p><p>+				error = ENOMEM;</p><p>+				break;</p><p>+			}</p><p>+			wa-&gt;dumped++;</p><p>+		}</p><p>+	}</p><p>+	return (error);</p><p>+}</p><p>+</p><p>+static int</p><p>+dump_llts(struct netlink_walkargs *wa, struct ifnet *ifp, int family)</p><p>+{</p><p>+	NL_LOG(LOG_DEBUG, &#34;Start dump ifp=%s family=%d&#34;, ifp ? if_name(ifp) : &#34;NULL&#34;, family);</p><p>+</p><p>+	wa-&gt;hdr.nlmsg_flags |= NLM_F_MULTI;</p><p>+</p><p>+	if (ifp != NULL) {</p><p>+		dump_llts_iface(wa, ifp, family);</p><p>+	} else {</p><p>+		CK_STAILQ_FOREACH(ifp, &amp;V_ifnet, if_link) {</p><p>+			dump_llts_iface(wa, ifp, family);</p><p>+		}</p><p>+	}</p><p>+</p><p>+	NL_LOG(LOG_DEBUG, &#34;End dump, iterated %d dumped %d&#34;, wa-&gt;count, wa-&gt;dumped);</p><p>+</p><p>+	if (!nlmsg_end_dump(wa-&gt;nw, wa-&gt;error, &amp;wa-&gt;hdr)) {</p><p>+                NL_LOG(LOG_DEBUG, &#34;Unable to add new message&#34;);</p><p>+                return (ENOMEM);</p><p>+        }</p><p>+</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+static int</p><p>+get_lle(struct netlink_walkargs *wa, struct ifnet *ifp, int family, struct sockaddr *dst)</p><p>+{</p><p>+	struct lltable *llt = lltable_get(ifp, family);</p><p>+	if (llt == NULL)</p><p>+		return (ESRCH);</p><p>+</p><p>+#ifdef INET6</p><p>+	if (dst-&gt;sa_family == AF_INET6) {</p><p>+		struct sockaddr_in6 *dst6 = (struct sockaddr_in6 *)dst;</p><p>+</p><p>+		if (IN6_IS_SCOPE_LINKLOCAL(&amp;dst6-&gt;sin6_addr))</p><p>+			in6_set_unicast_scopeid(&amp;dst6-&gt;sin6_addr, ifp-&gt;if_index);</p><p>+	}</p><p>+#endif</p><p>+	struct llentry *lle = lla_lookup(llt, LLE_UNLOCKED, dst);</p><p>+	if (lle == NULL)</p><p>+		return (ESRCH);</p><p>+</p><p>+	wa-&gt;ifp = ifp;</p><p>+	wa-&gt;family = family;</p><p>+</p><p>+	return (dump_lle(llt, lle, wa));</p><p>+}</p><p>+</p><p>+struct nl_parsed_neigh {</p><p>+	struct sockaddr	*nda_dst;</p><p>+	struct ifnet	*nda_ifp;</p><p>+	struct nlattr	*nda_lladdr;</p><p>+	uint32_t	ndm_flags;</p><p>+	uint16_t	ndm_state;</p><p>+	uint8_t		ndm_family;</p><p>+};</p><p>+</p><p>+#define	_IN(_field)	offsetof(struct ndmsg, _field)</p><p>+#define	_OUT(_field)	offsetof(struct nl_parsed_neigh, _field)</p><p>+static struct nlfield_parser nlf_p_neigh[] = {</p><p>+	{ .off_in = _IN(ndm_family), .off_out = _OUT(ndm_family), .cb = nlf_get_u8 },</p><p>+	{ .off_in = _IN(ndm_flags), .off_out = _OUT(ndm_flags), .cb = nlf_get_u8_u32 },</p><p>+	{ .off_in = _IN(ndm_state), .off_out = _OUT(ndm_state), .cb = nlf_get_u16 },</p><p>+	{ .off_in = _IN(ndm_ifindex), .off_out = _OUT(nda_ifp), .cb = nlf_get_ifpz },</p><p>+};</p><p>+</p><p>+static struct nlattr_parser nla_p_neigh[] = {</p><p>+	{ .type = NDA_DST, .off = _OUT(nda_dst), .cb = nlattr_get_ip },</p><p>+	{ .type = NDA_LLADDR, .off = _OUT(nda_lladdr), .cb = nlattr_get_nla },</p><p>+	{ .type = NDA_IFINDEX, .off = _OUT(nda_ifp), .cb = nlattr_get_ifp },</p><p>+	{ .type = NDA_FLAGS_EXT, .off = _OUT(ndm_flags), .cb = nlattr_get_uint32 },</p><p>+};</p><p>+#undef _IN</p><p>+#undef _OUT</p><p>+NL_DECLARE_PARSER(ndmsg_parser, struct ndmsg, nlf_p_neigh, nla_p_neigh);</p><p>+</p><p>+</p><p>+/*</p><p>+ * type=RTM_NEWNEIGH, flags=NLM_F_REQUEST|NLM_F_ACK|NLM_F_EXCL|NLM_F_CREATE, seq=1661941473, pid=0},</p><p>+ * {ndm_family=AF_INET6, ndm_ifindex=if_nametoindex(&#34;enp0s31f6&#34;), ndm_state=NUD_PERMANENT, ndm_flags=0, ndm_type=RTN_UNSPEC},</p><p>+ * [</p><p>+ *  {{nla_len=20, nla_type=NDA_DST}, inet_pton(AF_INET6, &#34;2a01:4f8:13a:70c::3&#34;)},</p><p>+ *  {{nla_len=10, nla_type=NDA_LLADDR}, 20:4e:71:62:ae:f2}]}, iov_len=60}</p><p>+ */</p><p>+</p><p>+static int</p><p>+rtnl_handle_newneigh(struct nlmsghdr *hdr, struct nlpcb *nlp, struct nl_pstate *npt)</p><p>+{</p><p>+	int error;</p><p>+</p><p>+	struct nl_parsed_neigh attrs = {};</p><p>+	error = nl_parse_nlmsg(hdr, &amp;ndmsg_parser, npt, &amp;attrs);</p><p>+	if (error != 0)</p><p>+		return (error);</p><p>+</p><p>+	if (attrs.nda_ifp == NULL || attrs.nda_dst == NULL || attrs.nda_lladdr == NULL) {</p><p>+		if (attrs.nda_ifp == NULL)</p><p>+			NLMSG_REPORT_ERR_MSG(npt, &#34;NDA_IFINDEX / ndm_ifindex not set&#34;);</p><p>+		if (attrs.nda_dst == NULL)</p><p>+			NLMSG_REPORT_ERR_MSG(npt, &#34;NDA_DST not set&#34;);</p><p>+		if (attrs.nda_lladdr == NULL)</p><p>+			NLMSG_REPORT_ERR_MSG(npt, &#34;NDA_LLADDR not set&#34;);</p><p>+		return (EINVAL);</p><p>+	}</p><p>+</p><p>+	if (attrs.nda_dst-&gt;sa_family != attrs.ndm_family) {</p><p>+		NLMSG_REPORT_ERR_MSG(npt,</p><p>+		    &#34;NDA_DST family (%d) is different from ndm_family (%d)&#34;,</p><p>+		    attrs.nda_dst-&gt;sa_family, attrs.ndm_family);</p><p>+		return (EINVAL);</p><p>+	}</p><p>+</p><p>+	int addrlen = attrs.nda_ifp-&gt;if_addrlen;</p><p>+	if (attrs.nda_lladdr-&gt;nla_len != sizeof(struct nlattr) + addrlen) {</p><p>+		NLMSG_REPORT_ERR_MSG(npt,</p><p>+		    &#34;NDA_LLADDR address length (%ld) is different from expected (%d)&#34;,</p><p>+		    attrs.nda_lladdr-&gt;nla_len - sizeof(struct nlattr), addrlen);</p><p>+		return (EINVAL);</p><p>+	}</p><p>+</p><p>+	if (attrs.ndm_state != NUD_PERMANENT) {</p><p>+		NLMSG_REPORT_ERR_MSG(npt, &#34;ndm_state %d not supported&#34;, attrs.ndm_state);</p><p>+		return (ENOTSUP);</p><p>+	}</p><p>+</p><p>+	const uint16_t supported_flags = NTF_PROXY | NTF_STICKY;</p><p>+	if ((attrs.ndm_flags &amp; supported_flags) != attrs.ndm_flags) {</p><p>+		NLMSG_REPORT_ERR_MSG(npt, &#34;ndm_flags %X not supported&#34;,</p><p>+		    attrs.ndm_flags &amp;~ supported_flags);</p><p>+		return (ENOTSUP);</p><p>+	}</p><p>+</p><p>+	/* Replacement requires new entry creation anyway */</p><p>+	if ((hdr-&gt;nlmsg_flags &amp; (NLM_F_CREATE | NLM_F_REPLACE)) == 0)</p><p>+		return (ENOTSUP);</p><p>+</p><p>+	struct lltable *llt = lltable_get(attrs.nda_ifp, attrs.ndm_family);</p><p>+	if (llt == NULL)</p><p>+		return (EAFNOSUPPORT);</p><p>+</p><p>+</p><p>+	uint8_t linkhdr[LLE_MAX_LINKHDR];</p><p>+	size_t linkhdrsize = sizeof(linkhdr);</p><p>+	int lladdr_off = 0;</p><p>+	if (lltable_calc_llheader(attrs.nda_ifp, attrs.ndm_family,</p><p>+	    (char *)(attrs.nda_lladdr + 1), linkhdr, &amp;linkhdrsize, &amp;lladdr_off) != 0) {</p><p>+		NLMSG_REPORT_ERR_MSG(npt, &#34;unable to calculate lle prepend data&#34;);</p><p>+		return (EINVAL);</p><p>+	}</p><p>+</p><p>+	int lle_flags = LLE_STATIC | ((attrs.ndm_flags &amp; NTF_PROXY) ? LLE_PUB : 0);</p><p>+	struct llentry *lle = lltable_alloc_entry(llt, lle_flags, attrs.nda_dst);</p><p>+	if (lle == NULL)</p><p>+		return (ENOMEM);</p><p>+	lltable_set_entry_addr(attrs.nda_ifp, lle, linkhdr, linkhdrsize, lladdr_off);</p><p>+</p><p>+	/* llentry created, try to insert or update :*/</p><p>+	IF_AFDATA_WLOCK(attrs.nda_ifp);</p><p>+	LLE_WLOCK(lle);</p><p>+	struct llentry *lle_tmp = lla_lookup(llt, LLE_EXCLUSIVE, attrs.nda_dst);</p><p>+	if (lle_tmp != NULL) {</p><p>+		if (hdr-&gt;nlmsg_flags &amp; NLM_F_EXCL) {</p><p>+			LLE_WUNLOCK(lle_tmp);</p><p>+			lle_tmp = NULL;</p><p>+			error = EEXIST;</p><p>+		} else if (hdr-&gt;nlmsg_flags &amp; NLM_F_REPLACE) {</p><p>+			lltable_unlink_entry(llt, lle_tmp);</p><p>+			lltable_link_entry(llt, lle);</p><p>+		} else</p><p>+			error = EEXIST;</p><p>+	} else {</p><p>+		if (hdr-&gt;nlmsg_flags &amp; NLM_F_CREATE)</p><p>+			lltable_link_entry(llt, lle);</p><p>+		else</p><p>+			error = ENOENT;</p><p>+	}</p><p>+	IF_AFDATA_WUNLOCK(attrs.nda_ifp);</p><p>+</p><p>+	if (error != 0) {</p><p>+		if (lle != NULL)</p><p>+			llentry_free(lle);</p><p>+		return (error);</p><p>+	}</p><p>+</p><p>+	if (lle_tmp != NULL)</p><p>+		llentry_free(lle_tmp);</p><p>+</p><p>+	/* XXX: We&#39;re inside epoch */</p><p>+	EVENTHANDLER_INVOKE(lle_event, lle, LLENTRY_RESOLVED);</p><p>+	LLE_WUNLOCK(lle);</p><p>+</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+static int</p><p>+rtnl_handle_delneigh(struct nlmsghdr *hdr, struct nlpcb *nlp, struct nl_pstate *npt)</p><p>+{</p><p>+	int error;</p><p>+</p><p>+	struct nl_parsed_neigh attrs = {};</p><p>+	error = nl_parse_nlmsg(hdr, &amp;ndmsg_parser, npt, &amp;attrs);</p><p>+	if (error != 0)</p><p>+		return (error);</p><p>+</p><p>+	if (attrs.nda_dst == NULL) {</p><p>+		NLMSG_REPORT_ERR_MSG(npt, &#34;NDA_DST not set&#34;);</p><p>+		return (EINVAL);</p><p>+	}</p><p>+</p><p>+	if (attrs.nda_ifp == NULL) {</p><p>+		NLMSG_REPORT_ERR_MSG(npt, &#34;no ifindex provided&#34;);</p><p>+		return (EINVAL);</p><p>+	}</p><p>+</p><p>+	struct lltable *llt = lltable_get(attrs.nda_ifp, attrs.ndm_family);</p><p>+	if (llt == NULL)</p><p>+		return (EAFNOSUPPORT);</p><p>+</p><p>+	IF_AFDATA_WLOCK(attrs.nda_ifp);</p><p>+	struct llentry *lle = lla_lookup(llt, LLE_EXCLUSIVE, attrs.nda_dst);</p><p>+	if (lle != NULL) {</p><p>+		if ((lle-&gt;la_flags &amp; LLE_IFADDR) != 0) {</p><p>+			LLE_WUNLOCK(lle);</p><p>+			lle = NULL;</p><p>+			error = EPERM;</p><p>+		} else</p><p>+			lltable_unlink_entry(llt, lle);</p><p>+	} else</p><p>+		error = ENOENT;</p><p>+	IF_AFDATA_WUNLOCK(attrs.nda_ifp);</p><p>+</p><p>+	if (error == 0 &amp;&amp; lle != NULL)</p><p>+		EVENTHANDLER_INVOKE(lle_event, lle, LLENTRY_DELETED);</p><p>+</p><p>+	if (lle != NULL)</p><p>+		llentry_free(lle);</p><p>+</p><p>+	return (error);</p><p>+}</p><p>+</p><p>+static int</p><p>+rtnl_handle_getneigh(struct nlmsghdr *hdr, struct nlpcb *nlp, struct nl_pstate *npt)</p><p>+{</p><p>+	int error;</p><p>+</p><p>+	struct nl_parsed_neigh attrs = {};</p><p>+	error = nl_parse_nlmsg(hdr, &amp;ndmsg_parser, npt, &amp;attrs);</p><p>+	if (error != 0)</p><p>+		return (error);</p><p>+</p><p>+	if (attrs.nda_dst != NULL &amp;&amp; attrs.nda_ifp == NULL) {</p><p>+		NLMSG_REPORT_ERR_MSG(npt, &#34;has NDA_DST but no ifindex provided&#34;);</p><p>+		return (EINVAL);</p><p>+	}</p><p>+</p><p>+	struct netlink_walkargs wa = {</p><p>+		.so = nlp,</p><p>+		.nw = npt-&gt;nw,</p><p>+		.hdr.nlmsg_pid = hdr-&gt;nlmsg_pid,</p><p>+		.hdr.nlmsg_seq = hdr-&gt;nlmsg_seq,</p><p>+		.hdr.nlmsg_flags = hdr-&gt;nlmsg_flags,</p><p>+		.hdr.nlmsg_type = NL_RTM_NEWNEIGH,</p><p>+	};</p><p>+</p><p>+	if (attrs.nda_dst == NULL)</p><p>+		error = dump_llts(&amp;wa, attrs.nda_ifp, attrs.ndm_family);</p><p>+	else</p><p>+		error = get_lle(&amp;wa, attrs.nda_ifp, attrs.ndm_family, attrs.nda_dst);</p><p>+</p><p>+	return (error);</p><p>+}</p><p>+</p><p>+static const struct rtnl_cmd_handler cmd_handlers[] = {</p><p>+	{</p><p>+		.cmd = NL_RTM_NEWNEIGH,</p><p>+		.name = &#34;RTM_NEWNEIGH&#34;,</p><p>+		.cb = &amp;rtnl_handle_newneigh,</p><p>+	},</p><p>+	{</p><p>+		.cmd = NL_RTM_DELNEIGH,</p><p>+		.name = &#34;RTM_DELNEIGH&#34;,</p><p>+		.cb = &amp;rtnl_handle_delneigh,</p><p>+		.priv = PRIV_NET_ROUTE,</p><p>+	},</p><p>+	{</p><p>+		.cmd = NL_RTM_GETNEIGH,</p><p>+		.name = &#34;RTM_GETNEIGH&#34;,</p><p>+		.cb = &amp;rtnl_handle_getneigh,</p><p>+		.priv = PRIV_NET_ROUTE,</p><p>+	}</p><p>+};</p><p>+</p><p>+static void</p><p>+rtnl_lle_event(void *arg __unused, struct llentry *lle, int evt)</p><p>+{</p><p>+	struct ifnet *ifp;</p><p>+	int family;</p><p>+</p><p>+	LLE_WLOCK_ASSERT(lle);</p><p>+</p><p>+	ifp = lltable_get_ifp(lle-&gt;lle_tbl);</p><p>+	family = lltable_get_af(lle-&gt;lle_tbl);</p><p>+</p><p>+	if (family != AF_INET &amp;&amp; family != AF_INET6)</p><p>+		return;</p><p>+</p><p>+	int nlmsgs_type = evt == LLENTRY_RESOLVED ? NL_RTM_NEWNEIGH : NL_RTM_DELNEIGH;</p><p>+</p><p>+	struct nl_writer nw = {};</p><p>+	if (!nlmsg_get_group_writer(&amp;nw, NLMSG_SMALL, NETLINK_ROUTE, RTNLGRP_NEIGH)) {</p><p>+		NL_LOG(LOG_DEBUG, &#34;error allocating group writer&#34;);</p><p>+		return;</p><p>+	}</p><p>+</p><p>+	struct netlink_walkargs wa = {</p><p>+		.hdr.nlmsg_type = nlmsgs_type,</p><p>+		.nw = &amp;nw,</p><p>+		.ifp = ifp,</p><p>+		.family = family,</p><p>+	};</p><p>+</p><p>+	dump_lle_locked(lle, &amp;wa);</p><p>+	nlmsg_flush(&amp;nw);</p><p>+}</p><p>+</p><p>+static const struct nlhdr_parser *all_parsers[] = { &amp;ndmsg_parser };</p><p>+</p><p>+void</p><p>+rtnl_neighs_init()</p><p>+{</p><p>+	NL_VERIFY_PARSERS(all_parsers);</p><p>+	rtnl_register_messages(cmd_handlers, NL_ARRAY_LEN(cmd_handlers));</p><p>+	lle_event_p = EVENTHANDLER_REGISTER(lle_event, rtnl_lle_event, NULL,</p><p>+	    EVENTHANDLER_PRI_ANY);</p><p>+}</p><p>+</p><p>+void</p><p>+rtnl_neighs_destroy()</p><p>+{</p><p>+	EVENTHANDLER_DEREGISTER(lle_event, lle_event_p);</p><p>+}</p><div><p>diff --git a/sys/netlink/route/neigh.h b/sys/netlink/route/neigh.h</p></div><p>@@ -0,0 +1,105 @@</p><p>+/*-</p><p>+ * SPDX-License-Identifier: BSD-2-Clause-FreeBSD</p><p>+ *</p><p>+ * Copyright (c) 2022 Alexander V. Chernikov &lt;melifaro@FreeBSD.org&gt;</p><p>+ *</p><p>+ * Redistribution and use in source and binary forms, with or without</p><p>+ * modification, are permitted provided that the following conditions</p><p>+ * are met:</p><p>+ * 1. Redistributions of source code must retain the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer.</p><p>+ * 2. Redistributions in binary form must reproduce the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer in the</p><p>+ *    documentation and/or other materials provided with the distribution.</p><p>+ *</p><p>+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&#39;&#39; AND</p><p>+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</p><p>+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</p><p>+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE</p><p>+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</p><p>+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</p><p>+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</p><p>+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</p><p>+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</p><p>+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</p><p>+ * SUCH DAMAGE.</p><p>+ */</p><p>+</p><p>+/*</p><p>+ * Neighbors-related (RTM_&lt;NEW|DEL|GET&gt;NEIGH) message header and attributes.</p><p>+ */</p><p>+</p><p>+#ifndef _NETLINK_ROUTE_NEIGH_H_</p><p>+#define _NETLINK_ROUTE_NEIGH_H_</p><p>+</p><p>+/* Base header for all of the relevant messages */</p><p>+struct ndmsg {</p><p>+	uint8_t		ndm_family;</p><p>+	uint8_t		ndm_pad1;</p><p>+	uint16_t	ndm_pad2;</p><p>+	int32_t		ndm_ifindex;</p><p>+	uint16_t	ndm_state;</p><p>+	uint8_t		ndm_flags;</p><p>+	uint8_t		ndm_type;</p><p>+};</p><p>+</p><p>+/* Attributes */</p><p>+enum {</p><p>+	NDA_UNSPEC,</p><p>+	NDA_DST,		/* binary: neigh l3 address */</p><p>+	NDA_LLADDR,		/* binary: neigh link-level address */</p><p>+	NDA_CACHEINFO,		/* binary, struct nda_cacheinfo */</p><p>+	NDA_PROBES,		/* XXX */</p><p>+	NDA_VLAN,		/* upper 802.1Q tag */</p><p>+	NDA_PORT,		/* not supported */</p><p>+	NDA_VNI,		/* not supported */</p><p>+	NDA_IFINDEX,		/* interface index */</p><p>+	NDA_MASTER,		/* not supported */</p><p>+	NDA_LINK_NETNSID,	/* not supported */</p><p>+	NDA_SRC_VNI,		/* not supported */</p><p>+	NDA_PROTOCOL,		/* XXX */</p><p>+	NDA_NH_ID,		/* not supported */</p><p>+	NDA_FDB_EXT_ATTRS,	/* not supported */</p><p>+	NDA_FLAGS_EXT,		/* u32: ndm_flags */</p><p>+	NDA_NDM_STATE_MASK,	/* XXX */</p><p>+	NDA_NDM_FLAGS_MASK,	/* XXX */</p><p>+	__NDA_MAX</p><p>+};</p><p>+</p><p>+#define	NDA_MAX	(__NDA_MAX - 1)</p><p>+</p><p>+</p><p>+/* ndm_flags / NDA_FLAGS_EXT */</p><p>+#define	NTF_USE			0x0001	/* XXX */</p><p>+#define	NTF_SELF		0x0002	/* local station */</p><p>+#define	NTF_MASTER		0x0004	/* XXX */</p><p>+#define	NTF_PROXY		0x0008	/* proxy entry */</p><p>+#define	NTF_EXT_LEARNED		0x0010	/* not used */</p><p>+#define	NTF_OFFLOADED		0x0020	/* not used */</p><p>+#define	NTF_STICKY		0x0040	/* permament entry */</p><p>+#define	NTF_ROUTER		0x0080	/* dst indicated itself as a router */</p><p>+/* start of NDA_FLAGS_EXT */</p><p>+#define	NTF_EXT_MANAGED		0x0100	/* not used */</p><p>+</p><p>+/* ndm_state */</p><p>+#define	NUD_INCOMPLETE		0x01	/* No lladdr, address resolution in progress */</p><p>+#define	NUD_REACHABLE		0x02	/* reachable &amp; recently resolved */</p><p>+#define	NUD_STALE		0x04	/* has lladdr but it&#39;s stale */</p><p>+#define	NUD_DELAY		0x08	/* has lladdr, is stale, probes delayed */</p><p>+#define	NUD_PROBE		0x10	/* has lladdr, is stale, probes sent */</p><p>+#define	NUD_FAILED		0x20	/* unused */</p><p>+</p><p>+/* Dummy states */</p><p>+#define	NUD_NOARP		0x40	/* not used */</p><p>+#define	NUD_PERMANENT		0x80	/* not flushed */</p><p>+#define	NUD_NONE		0x00</p><p>+</p><p>+/* NDA_CACHEINFO */</p><p>+struct nda_cacheinfo {</p><p>+	uint32_t	ndm_confirmed;	/* seconds since ARP/ND was received from neigh */</p><p>+	uint32_t	ndm_used;	/* seconds since last used (not provided) */</p><p>+	uint32_t	ndm_updated;	/* seconds since state was updated last */</p><p>+	uint32_t	ndm_refcnt;	/* number of references held */</p><p>+};</p><p>+</p><p>+#endif</p><div><p>diff --git a/sys/netlink/route/nexthop.c b/sys/netlink/route/nexthop.c</p></div><p>@@ -0,0 +1,1000 @@</p><p>+/*-</p><p>+ * SPDX-License-Identifier: BSD-2-Clause-FreeBSD</p><p>+ *</p><p>+ * Copyright (c) 2022 Alexander V. Chernikov &lt;melifaro@FreeBSD.org&gt;</p><p>+ *</p><p>+ * Redistribution and use in source and binary forms, with or without</p><p>+ * modification, are permitted provided that the following conditions</p><p>+ * are met:</p><p>+ * 1. Redistributions of source code must retain the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer.</p><p>+ * 2. Redistributions in binary form must reproduce the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer in the</p><p>+ *    documentation and/or other materials provided with the distribution.</p><p>+ *</p><p>+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&#39;&#39; AND</p><p>+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</p><p>+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</p><p>+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE</p><p>+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</p><p>+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</p><p>+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</p><p>+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</p><p>+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</p><p>+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</p><p>+ * SUCH DAMAGE.</p><p>+ */</p><p>+</p><p>+#include &lt;sys/cdefs.h&gt;</p><p>+__FBSDID(&#34;$FreeBSD$&#34;);</p><p>+#include &#34;opt_inet.h&#34;</p><p>+#include &#34;opt_inet6.h&#34;</p><p>+#include &lt;sys/types.h&gt;</p><p>+#include &lt;sys/malloc.h&gt;</p><p>+#include &lt;sys/rmlock.h&gt;</p><p>+#include &lt;sys/socket.h&gt;</p><p>+#include &lt;sys/ck.h&gt;</p><p>+</p><p>+#include &lt;net/if.h&gt;</p><p>+#include &lt;net/route.h&gt;</p><p>+#include &lt;net/route/nhop.h&gt;</p><p>+#include &lt;net/route/nhop_utils.h&gt;</p><p>+</p><p>+#include &lt;net/route/route_ctl.h&gt;</p><p>+#include &lt;net/route/route_var.h&gt;</p><p>+#include &lt;netinet6/scope6_var.h&gt;</p><p>+#include &lt;netlink/netlink.h&gt;</p><p>+#include &lt;netlink/netlink_ctl.h&gt;</p><p>+#include &lt;netlink/netlink_var.h&gt;</p><p>+#include &lt;netlink/netlink_route.h&gt;</p><p>+#include &lt;netlink/route/route_var.h&gt;</p><p>+</p><p>+#define	DEBUG_MOD_NAME	nl_nhop</p><p>+#define	DEBUG_MAX_LEVEL	LOG_DEBUG3</p><p>+#include &lt;netlink/netlink_debug.h&gt;</p><p>+_DECLARE_DEBUG(LOG_DEBUG3);</p><p>+</p><p>+/*</p><p>+ * This file contains the logic to maintain kernel nexthops and</p><p>+ *  nexhop groups based om the data provided by the user.</p><p>+ *</p><p>+ * Kernel stores (nearly) all of the routing data in the nexthops,</p><p>+ *  including the prefix-specific flags (NHF_HOST and NHF_DEFAULT).</p><p>+ *</p><p>+ * Netlink API provides higher-level abstraction for the user. Each</p><p>+ *  user-created nexthop may map to multiple kernel nexthops.</p><p>+ *</p><p>+ * The following variations require separate kernel nexthop to be</p><p>+ *  created:</p><p>+ *  * prefix flags (NHF_HOST, NHF_DEFAULT)</p><p>+ *  * using IPv6 gateway for IPv4 routes</p><p>+ *  * different fibnum</p><p>+ *</p><p>+ * These kernel nexthops have the lifetime bound to the lifetime of</p><p>+ *  the user_nhop object. They are not collected until user requests</p><p>+ *  to delete the created user_nhop.</p><p>+ *</p><p>+ */</p><p>+struct user_nhop {</p><p>+        uint32_t                        un_idx; /* Userland-provided index */</p><p>+	uint32_t			un_fibfam; /* fibnum+af(as highest byte) */</p><p>+	uint8_t				un_protocol; /* protocol that install the record */</p><p>+	struct nhop_object		*un_nhop; /* &#34;production&#34; nexthop */</p><p>+	struct nhop_object		*un_nhop_src; /* nexthop to copy from */</p><p>+	struct weightened_nhop		*un_nhgrp_src; /* nexthops for nhg */</p><p>+	uint32_t			un_nhgrp_count; /* number of nexthops */</p><p>+        struct user_nhop		*un_next; /* next item in hash chain */</p><p>+        struct user_nhop		*un_nextchild; /* master -&gt; children */</p><p>+	struct epoch_context		un_epoch_ctx;	/* epoch ctl helper */</p><p>+};</p><p>+</p><p>+/* produce hash value for an object */</p><p>+#define	unhop_hash_obj(_obj)	(hash_unhop(_obj))</p><p>+/* compare two objects */</p><p>+#define	unhop_cmp(_one, _two)	(cmp_unhop(_one, _two))</p><p>+/* next object accessor */</p><p>+#define	unhop_next(_obj)	(_obj)-&gt;un_next</p><p>+</p><p>+CHT_SLIST_DEFINE(unhop, struct user_nhop);</p><p>+</p><p>+struct unhop_ctl {</p><p>+	struct unhop_head	un_head;</p><p>+	struct rmlock		un_lock;</p><p>+};</p><p>+#define	UN_LOCK_INIT(_ctl)	rm_init(&amp;(_ctl)-&gt;un_lock, &#34;unhop_ctl&#34;)</p><p>+#define	UN_TRACKER		struct rm_priotracker un_tracker</p><p>+#define	UN_RLOCK(_ctl)		rm_rlock(&amp;((_ctl)-&gt;un_lock), &amp;un_tracker)</p><p>+#define	UN_RUNLOCK(_ctl)	rm_runlock(&amp;((_ctl)-&gt;un_lock), &amp;un_tracker)</p><p>+</p><p>+#define	UN_WLOCK(_ctl)		rm_wlock(&amp;(_ctl)-&gt;un_lock);</p><p>+#define	UN_WUNLOCK(_ctl)	rm_wunlock(&amp;(_ctl)-&gt;un_lock);</p><p>+</p><p>+VNET_DEFINE_STATIC(struct unhop_ctl *, un_ctl) = NULL;</p><p>+#define V_un_ctl	VNET(un_ctl)</p><p>+</p><p>+static void consider_resize(struct unhop_ctl *ctl, uint32_t new_size);</p><p>+static int cmp_unhop(const struct user_nhop *a, const struct user_nhop *b);</p><p>+static unsigned int hash_unhop(const struct user_nhop *obj);</p><p>+</p><p>+static void destroy_unhop(struct user_nhop *unhop);</p><p>+static struct nhop_object *clone_unhop(const struct user_nhop *unhop,</p><p>+    uint32_t fibnum, int family, int nh_flags);</p><p>+</p><p>+static int</p><p>+cmp_unhop(const struct user_nhop *a, const struct user_nhop *b)</p><p>+{</p><p>+        return (a-&gt;un_idx == b-&gt;un_idx &amp;&amp; a-&gt;un_fibfam == b-&gt;un_fibfam);</p><p>+}</p><p>+</p><p>+/*</p><p>+ * Hash callback: calculate hash of an object</p><p>+ */</p><p>+static unsigned int</p><p>+hash_unhop(const struct user_nhop *obj)</p><p>+{</p><p>+        return (obj-&gt;un_idx ^ obj-&gt;un_fibfam);</p><p>+}</p><p>+</p><p>+#define	UNHOP_IS_MASTER(_unhop)	((_unhop)-&gt;un_fibfam == 0)</p><p>+</p><p>+/*</p><p>+ * Factory interface for creating matching kernel nexthops/nexthop groups</p><p>+ *</p><p>+ * @uidx: userland nexhop index used to create the nexthop</p><p>+ * @fibnum: fibnum nexthop will be used in</p><p>+ * @family: upper family nexthop will be used in</p><p>+ * @nh_flags: desired nexthop prefix flags</p><p>+ * @perror: pointer to store error to</p><p>+ *</p><p>+ * Returns referenced nexthop linked to @fibnum/@family rib on success.</p><p>+ */</p><p>+struct nhop_object *</p><p>+nl_find_nhop(uint32_t fibnum, int family, uint32_t uidx,</p><p>+    int nh_flags, int *perror)</p><p>+{</p><p>+	struct unhop_ctl *ctl = atomic_load_ptr(&amp;V_un_ctl);</p><p>+        UN_TRACKER;</p><p>+</p><p>+	if (__predict_false(ctl == NULL))</p><p>+		return (NULL);</p><p>+</p><p>+	struct user_nhop key= {</p><p>+		.un_idx = uidx,</p><p>+		.un_fibfam = fibnum  | ((uint32_t)family) &lt;&lt; 24,</p><p>+	};</p><p>+	struct user_nhop *unhop;</p><p>+</p><p>+	nh_flags = nh_flags &amp; (NHF_HOST | NHF_DEFAULT);</p><p>+</p><p>+	if (__predict_false(family == 0))</p><p>+		return (NULL);</p><p>+</p><p>+	UN_RLOCK(ctl);</p><p>+	CHT_SLIST_FIND_BYOBJ(&amp;ctl-&gt;un_head, unhop, &amp;key, unhop);</p><p>+	if (unhop != NULL) {</p><p>+		struct nhop_object *nh = unhop-&gt;un_nhop;</p><p>+		UN_RLOCK(ctl);</p><p>+		*perror = 0;</p><p>+		nhop_ref_any(nh);</p><p>+		return (nh);</p><p>+	}</p><p>+</p><p>+	/*</p><p>+	 * Exact nexthop not found. Search for template nexthop to clone from.</p><p>+	 */</p><p>+	key.un_fibfam = 0;</p><p>+	CHT_SLIST_FIND_BYOBJ(&amp;ctl-&gt;un_head, unhop, &amp;key, unhop);</p><p>+	if (unhop == NULL) {</p><p>+		UN_RUNLOCK(ctl);</p><p>+		*perror = ESRCH;</p><p>+		return (NULL);</p><p>+	}</p><p>+</p><p>+	UN_RUNLOCK(ctl);</p><p>+</p><p>+	/* Create entry to insert first */</p><p>+	struct user_nhop *un_new, *un_tmp;</p><p>+	un_new = malloc(sizeof(struct user_nhop), M_NETLINK, M_NOWAIT | M_ZERO);</p><p>+	if (un_new == NULL) {</p><p>+		*perror = ENOMEM;</p><p>+		return (NULL);</p><p>+	}</p><p>+	un_new-&gt;un_idx = uidx;</p><p>+	un_new-&gt;un_fibfam = fibnum  | ((uint32_t)family) &lt;&lt; 24;</p><p>+</p><p>+	/* Relying on epoch to protect unhop here */</p><p>+	un_new-&gt;un_nhop = clone_unhop(unhop, fibnum, family, nh_flags);</p><p>+	if (un_new-&gt;un_nhop == NULL) {</p><p>+		free(un_new, M_NETLINK);</p><p>+		*perror = ENOMEM;</p><p>+		return (NULL);</p><p>+	}</p><p>+</p><p>+	/* Insert back and report */</p><p>+	UN_WLOCK(ctl);</p><p>+</p><p>+	/* First, find template record once again */</p><p>+	CHT_SLIST_FIND_BYOBJ(&amp;ctl-&gt;un_head, unhop, &amp;key, unhop);</p><p>+	if (unhop == NULL) {</p><p>+		/* Someone deleted the nexthop during the call */</p><p>+		UN_WUNLOCK(ctl);</p><p>+		*perror = ESRCH;</p><p>+		destroy_unhop(un_new);</p><p>+		return (NULL);</p><p>+	}</p><p>+</p><p>+	/* Second, check the direct match */</p><p>+	CHT_SLIST_FIND_BYOBJ(&amp;ctl-&gt;un_head, unhop, un_new, un_tmp);</p><p>+	struct nhop_object *nh;</p><p>+	if (un_tmp != NULL) {</p><p>+		/* Another thread already created the desired nextop, use it */</p><p>+		nh = un_tmp-&gt;un_nhop;</p><p>+	} else {</p><p>+		/* Finally, insert the new nexthop and link it to the primary */</p><p>+		nh = un_new-&gt;un_nhop;</p><p>+		CHT_SLIST_INSERT_HEAD(&amp;ctl-&gt;un_head, unhop, un_new);</p><p>+		un_new-&gt;un_nextchild = unhop-&gt;un_nextchild;</p><p>+		unhop-&gt;un_nextchild = un_new;</p><p>+		un_new = NULL;</p><p>+		NL_LOG(LOG_DEBUG2, &#34;linked cloned nexthop %p&#34;, nh);</p><p>+	}</p><p>+</p><p>+	UN_WUNLOCK(ctl);</p><p>+</p><p>+	if (un_new != NULL)</p><p>+		destroy_unhop(un_new);</p><p>+</p><p>+	*perror = 0;</p><p>+	nhop_ref_any(nh);</p><p>+	return (nh);</p><p>+}</p><p>+</p><p>+static struct user_nhop *</p><p>+nl_find_base_unhop(struct unhop_ctl *ctl, uint32_t uidx)</p><p>+{</p><p>+	struct user_nhop key= { .un_idx = uidx };</p><p>+	struct user_nhop *unhop = NULL;</p><p>+	UN_TRACKER;</p><p>+</p><p>+	UN_RLOCK(ctl);</p><p>+	CHT_SLIST_FIND_BYOBJ(&amp;ctl-&gt;un_head, unhop, &amp;key, unhop);</p><p>+	UN_RUNLOCK(ctl);</p><p>+</p><p>+	return (unhop);</p><p>+}</p><p>+</p><p>+#define MAX_STACK_NHOPS	4</p><p>+static struct nhop_object *</p><p>+clone_unhop(const struct user_nhop *unhop, uint32_t fibnum, int family, int nh_flags)</p><p>+{</p><p>+	const struct weightened_nhop *wn;</p><p>+	struct weightened_nhop *wn_new, wn_base[MAX_STACK_NHOPS];</p><p>+	struct nhop_object *nh = NULL;</p><p>+	uint32_t num_nhops;</p><p>+	int error;</p><p>+</p><p>+	if (unhop-&gt;un_nhop_src != NULL) {</p><p>+		IF_DEBUG_LEVEL(LOG_DEBUG2) {</p><p>+			char nhbuf[NHOP_PRINT_BUFSIZE];</p><p>+			nhop_print_buf_any(unhop-&gt;un_nhop_src, nhbuf, sizeof(nhbuf));</p><p>+			FIB_NH_LOG(LOG_DEBUG2, unhop-&gt;un_nhop_src,</p><p>+			    &#34;cloning nhop %s -&gt; %u.%u flags 0x%X&#34;, nhbuf, fibnum,</p><p>+			    family, nh_flags);</p><p>+		}</p><p>+		struct nhop_object *nh;</p><p>+		nh = nhop_alloc(fibnum, AF_UNSPEC);</p><p>+		if (nh == NULL)</p><p>+			return (NULL);</p><p>+		nhop_copy(nh, unhop-&gt;un_nhop_src);</p><p>+		/* Check that nexthop gateway is compatible with the new family */</p><p>+		if (!nhop_set_upper_family(nh, family)) {</p><p>+			nhop_free(nh);</p><p>+			return (NULL);</p><p>+		}</p><p>+		nhop_set_uidx(nh, unhop-&gt;un_idx);</p><p>+		nhop_set_pxtype_flag(nh, nh_flags);</p><p>+		return (nhop_get_nhop(nh, &amp;error));</p><p>+	}</p><p>+</p><p>+	wn = unhop-&gt;un_nhgrp_src;</p><p>+	num_nhops = unhop-&gt;un_nhgrp_count;</p><p>+</p><p>+	if (num_nhops &gt; MAX_STACK_NHOPS) {</p><p>+		wn_new = malloc(num_nhops * sizeof(struct weightened_nhop), M_TEMP, M_NOWAIT);</p><p>+		if (wn_new == NULL)</p><p>+			return (NULL);</p><p>+	} else</p><p>+		wn_new = wn_base;</p><p>+</p><p>+	for (int i = 0; i &lt; num_nhops; i++) {</p><p>+		uint32_t uidx = nhop_get_uidx(wn[i].nh);</p><p>+		MPASS(uidx != 0);</p><p>+		wn_new[i].nh = nl_find_nhop(fibnum, family, uidx, nh_flags, &amp;error);</p><p>+		if (error != 0)</p><p>+			break;</p><p>+		wn_new[i].weight = wn[i].weight;</p><p>+	}</p><p>+</p><p>+	if (error == 0) {</p><p>+		struct rib_head *rh = nhop_get_rh(wn_new[0].nh);</p><p>+		struct nhgrp_object *nhg;</p><p>+</p><p>+		error = nhgrp_get_group(rh, wn_new, num_nhops, unhop-&gt;un_idx, &amp;nhg);</p><p>+		nh = (struct nhop_object *)nhg;</p><p>+	}</p><p>+</p><p>+	if (wn_new != wn_base)</p><p>+		free(wn_new, M_TEMP);</p><p>+	return (nh);</p><p>+}</p><p>+</p><p>+static void</p><p>+destroy_unhop(struct user_nhop *unhop)</p><p>+{</p><p>+	if (unhop-&gt;un_nhop != NULL)</p><p>+		nhop_free_any(unhop-&gt;un_nhop);</p><p>+	if (unhop-&gt;un_nhop_src != NULL)</p><p>+		nhop_free_any(unhop-&gt;un_nhop_src);</p><p>+	free(unhop, M_NETLINK);</p><p>+}</p><p>+</p><p>+static void</p><p>+destroy_unhop_epoch(epoch_context_t ctx)</p><p>+{</p><p>+	struct user_nhop *unhop;</p><p>+</p><p>+	unhop = __containerof(ctx, struct user_nhop, un_epoch_ctx);</p><p>+</p><p>+	destroy_unhop(unhop);</p><p>+}</p><p>+</p><p>+static uint32_t</p><p>+find_spare_uidx(struct unhop_ctl *ctl)</p><p>+{</p><p>+	struct user_nhop *unhop, key = {};</p><p>+	uint32_t uidx = 0;</p><p>+	UN_TRACKER;</p><p>+</p><p>+	UN_RLOCK(ctl);</p><p>+	/* This should return spare uid with 75% of 65k used in ~99/100 cases */</p><p>+	for (int i = 0; i &lt; 16; i++) {</p><p>+		key.un_idx = (arc4random() % 65536) + 65536 * 4;</p><p>+		CHT_SLIST_FIND_BYOBJ(&amp;ctl-&gt;un_head, unhop, &amp;key, unhop);</p><p>+		if (unhop == NULL) {</p><p>+			uidx = key.un_idx;</p><p>+			break;</p><p>+		}</p><p>+	}</p><p>+	UN_RUNLOCK(ctl);</p><p>+</p><p>+	return (uidx);</p><p>+}</p><p>+</p><p>+</p><p>+/*</p><p>+ * Actual netlink code</p><p>+ */</p><p>+struct netlink_walkargs {</p><p>+	struct nl_writer *nw;</p><p>+	struct nlmsghdr hdr;</p><p>+	struct nlpcb *so;</p><p>+	int family;</p><p>+	int error;</p><p>+	int count;</p><p>+	int dumped;</p><p>+};</p><p>+#define	ENOMEM_IF_NULL(_v)	if ((_v) == NULL) goto enomem</p><p>+</p><p>+static bool</p><p>+dump_nhgrp(const struct user_nhop *unhop, struct nlmsghdr *hdr,</p><p>+    struct nl_writer *nw)</p><p>+{</p><p>+</p><p>+	if (!nlmsg_reply(nw, hdr, sizeof(struct nhmsg)))</p><p>+		goto enomem;</p><p>+</p><p>+	struct nhmsg *nhm = nlmsg_reserve_object(nw, struct nhmsg);</p><p>+	nhm-&gt;nh_family = AF_UNSPEC;</p><p>+	nhm-&gt;nh_scope = 0;</p><p>+	nhm-&gt;nh_protocol = unhop-&gt;un_protocol;</p><p>+	nhm-&gt;nh_flags = 0;</p><p>+</p><p>+	nlattr_add_u32(nw, NHA_ID, unhop-&gt;un_idx);</p><p>+	nlattr_add_u16(nw, NHA_GROUP_TYPE, NEXTHOP_GRP_TYPE_MPATH);</p><p>+</p><p>+	struct weightened_nhop *wn = unhop-&gt;un_nhgrp_src;</p><p>+	uint32_t num_nhops = unhop-&gt;un_nhgrp_count;</p><p>+	/* TODO: a better API? */</p><p>+	int nla_len = sizeof(struct nlattr);</p><p>+	nla_len += NETLINK_ALIGN(num_nhops * sizeof(struct nexthop_grp));</p><p>+	struct nlattr *nla = nlmsg_reserve_data(nw, nla_len, struct nlattr);</p><p>+	if (nla == NULL)</p><p>+		goto enomem;</p><p>+	nla-&gt;nla_type = NHA_GROUP;</p><p>+	nla-&gt;nla_len = nla_len;</p><p>+	for (int i = 0; i &lt; num_nhops; i++) {</p><p>+		struct nexthop_grp *grp = &amp;((struct nexthop_grp *)(nla + 1))[i];</p><p>+		grp-&gt;id = nhop_get_uidx(wn[i].nh);</p><p>+		grp-&gt;weight = wn[i].weight;</p><p>+		grp-&gt;resvd1 = 0;</p><p>+		grp-&gt;resvd2 = 0;</p><p>+	}</p><p>+</p><p>+        if (nlmsg_end(nw))</p><p>+		return (true);</p><p>+enomem:</p><p>+	NL_LOG(LOG_DEBUG, &#34;error: unable to allocate attribute memory&#34;);</p><p>+        nlmsg_abort(nw);</p><p>+	return (false);</p><p>+}</p><p>+</p><p>+static bool</p><p>+dump_nhop(const struct user_nhop *unhop, struct nlmsghdr *hdr,</p><p>+    struct nl_writer *nw)</p><p>+{</p><p>+	struct nhop_object *nh = unhop-&gt;un_nhop_src;</p><p>+</p><p>+	if (!nlmsg_reply(nw, hdr, sizeof(struct nhmsg)))</p><p>+		goto enomem;</p><p>+</p><p>+	struct nhmsg *nhm = nlmsg_reserve_object(nw, struct nhmsg);</p><p>+	ENOMEM_IF_NULL(nhm);</p><p>+	nhm-&gt;nh_family = nhop_get_neigh_family(nh);</p><p>+	nhm-&gt;nh_scope = 0; // XXX: what&#39;s that?</p><p>+	nhm-&gt;nh_protocol = unhop-&gt;un_protocol;</p><p>+	nhm-&gt;nh_flags = 0;</p><p>+</p><p>+	nlattr_add_u32(nw, NHA_ID, unhop-&gt;un_idx);</p><p>+	if (nh-&gt;nh_flags &amp; NHF_BLACKHOLE) {</p><p>+		nlattr_add_flag(nw, NHA_BLACKHOLE);</p><p>+		goto done;</p><p>+	}</p><p>+	nlattr_add_u32(nw, NHA_OIF, nh-&gt;nh_ifp-&gt;if_index);</p><p>+</p><p>+	switch (nh-&gt;gw_sa.sa_family) {</p><p>+#ifdef INET</p><p>+	case AF_INET:</p><p>+		nlattr_add(nw, NHA_GATEWAY, 4, &amp;nh-&gt;gw4_sa.sin_addr);</p><p>+		break;</p><p>+#endif</p><p>+#ifdef INET6</p><p>+	case AF_INET6:</p><p>+		{</p><p>+			struct in6_addr addr = nh-&gt;gw6_sa.sin6_addr;</p><p>+			in6_clearscope(&amp;addr);</p><p>+			nlattr_add(nw, NHA_GATEWAY, 16, &amp;addr);</p><p>+			break;</p><p>+		}</p><p>+#endif</p><p>+	}</p><p>+</p><p>+done:</p><p>+        if (nlmsg_end(nw))</p><p>+		return (true);</p><p>+enomem:</p><p>+	nlmsg_abort(nw);</p><p>+	return (false);</p><p>+}</p><p>+</p><p>+static void</p><p>+dump_unhop(const struct user_nhop *unhop, struct nlmsghdr *hdr,</p><p>+    struct nl_writer *nw)</p><p>+{</p><p>+	if (unhop-&gt;un_nhop_src != NULL)</p><p>+		dump_nhop(unhop, hdr, nw);</p><p>+	else</p><p>+		dump_nhgrp(unhop, hdr, nw);</p><p>+}</p><p>+</p><p>+static int</p><p>+delete_unhop(struct unhop_ctl *ctl, struct nlmsghdr *hdr, uint32_t uidx)</p><p>+{</p><p>+	struct user_nhop *unhop_ret, *unhop_base, *unhop_chain;</p><p>+</p><p>+	struct user_nhop key = { .un_idx = uidx };</p><p>+</p><p>+	UN_WLOCK(ctl);</p><p>+</p><p>+	CHT_SLIST_FIND_BYOBJ(&amp;ctl-&gt;un_head, unhop, &amp;key, unhop_base);</p><p>+</p><p>+	if (unhop_base != NULL) {</p><p>+		CHT_SLIST_REMOVE(&amp;ctl-&gt;un_head, unhop, unhop_base, unhop_ret);</p><p>+		IF_DEBUG_LEVEL(LOG_DEBUG2) {</p><p>+			char nhbuf[NHOP_PRINT_BUFSIZE];</p><p>+			nhop_print_buf_any(unhop_base-&gt;un_nhop, nhbuf, sizeof(nhbuf));</p><p>+			FIB_NH_LOG(LOG_DEBUG3, unhop_base-&gt;un_nhop,</p><p>+			    &#34;removed base nhop %u: %s&#34;, uidx, nhbuf);</p><p>+		}</p><p>+		/* Unlink all child nexhops as well, keeping the chain intact */</p><p>+		unhop_chain = unhop_base-&gt;un_nextchild;</p><p>+		while (unhop_chain != NULL) {</p><p>+			CHT_SLIST_REMOVE(&amp;ctl-&gt;un_head, unhop, unhop_chain,</p><p>+			    unhop_ret);</p><p>+			MPASS(unhop_chain == unhop_ret);</p><p>+			IF_DEBUG_LEVEL(LOG_DEBUG3) {</p><p>+				char nhbuf[NHOP_PRINT_BUFSIZE];</p><p>+				nhop_print_buf_any(unhop_chain-&gt;un_nhop,</p><p>+				    nhbuf, sizeof(nhbuf));</p><p>+				FIB_NH_LOG(LOG_DEBUG3, unhop_chain-&gt;un_nhop,</p><p>+				    &#34;removed child nhop %u: %s&#34;, uidx, nhbuf);</p><p>+			}</p><p>+			unhop_chain = unhop_chain-&gt;un_nextchild;</p><p>+		}</p><p>+	}</p><p>+</p><p>+	UN_WUNLOCK(ctl);</p><p>+</p><p>+	if (unhop_base == NULL) {</p><p>+		NL_LOG(LOG_DEBUG, &#34;unable to find unhop %u&#34;, uidx);</p><p>+		return (ENOENT);</p><p>+	}</p><p>+</p><p>+	/* Report nexthop deletion */</p><p>+	struct netlink_walkargs wa = {</p><p>+		.hdr.nlmsg_pid = hdr-&gt;nlmsg_pid,</p><p>+		.hdr.nlmsg_seq = hdr-&gt;nlmsg_seq,</p><p>+		.hdr.nlmsg_flags = hdr-&gt;nlmsg_flags,</p><p>+		.hdr.nlmsg_type = NL_RTM_DELNEXTHOP,</p><p>+	};</p><p>+</p><p>+	struct nl_writer nw = {};</p><p>+	if (!nlmsg_get_group_writer(&amp;nw, NLMSG_SMALL, NETLINK_ROUTE, RTNLGRP_NEXTHOP)) {</p><p>+		NL_LOG(LOG_DEBUG, &#34;error allocating message writer&#34;);</p><p>+		return (ENOMEM);</p><p>+	}</p><p>+</p><p>+	dump_unhop(unhop_base, &amp;wa.hdr, &amp;nw);</p><p>+	nlmsg_flush(&amp;nw);</p><p>+</p><p>+	while (unhop_base != NULL) {</p><p>+		unhop_chain = unhop_base-&gt;un_nextchild;</p><p>+		epoch_call(net_epoch_preempt, destroy_unhop_epoch,</p><p>+		    &amp;unhop_base-&gt;un_epoch_ctx);</p><p>+		unhop_base = unhop_chain;</p><p>+	}</p><p>+</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+static void</p><p>+consider_resize(struct unhop_ctl *ctl, uint32_t new_size)</p><p>+{</p><p>+	void *new_ptr = NULL;</p><p>+	size_t alloc_size;</p><p>+</p><p>+        if (new_size == 0)</p><p>+                return;</p><p>+</p><p>+	if (new_size != 0) {</p><p>+		alloc_size = CHT_SLIST_GET_RESIZE_SIZE(new_size);</p><p>+		new_ptr = malloc(alloc_size, M_NETLINK, M_NOWAIT | M_ZERO);</p><p>+                if (new_ptr == NULL)</p><p>+                        return;</p><p>+	}</p><p>+</p><p>+	NL_LOG(LOG_DEBUG, &#34;resizing hash: %u -&gt; %u&#34;, ctl-&gt;un_head.hash_size, new_size);</p><p>+	UN_WLOCK(ctl);</p><p>+	if (new_ptr != NULL) {</p><p>+		CHT_SLIST_RESIZE(&amp;ctl-&gt;un_head, unhop, new_ptr, new_size);</p><p>+	}</p><p>+	UN_WUNLOCK(ctl);</p><p>+</p><p>+</p><p>+	if (new_ptr != NULL)</p><p>+		free(new_ptr, M_NETLINK);</p><p>+}</p><p>+</p><p>+static bool __noinline</p><p>+vnet_init_unhops()</p><p>+{</p><p>+        uint32_t num_buckets = 16;</p><p>+        size_t alloc_size = CHT_SLIST_GET_RESIZE_SIZE(num_buckets);</p><p>+</p><p>+        struct unhop_ctl *ctl = malloc(sizeof(struct unhop_ctl), M_NETLINK,</p><p>+            M_NOWAIT | M_ZERO);</p><p>+        if (ctl == NULL)</p><p>+                return (false);</p><p>+</p><p>+        void *ptr = malloc(alloc_size, M_NETLINK, M_NOWAIT | M_ZERO);</p><p>+        if (ptr == NULL) {</p><p>+		free(ctl, M_NETLINK);</p><p>+                return (false);</p><p>+	}</p><p>+        CHT_SLIST_INIT(&amp;ctl-&gt;un_head, ptr, num_buckets);</p><p>+	UN_LOCK_INIT(ctl);</p><p>+</p><p>+	if (!atomic_cmpset_ptr((uintptr_t *)&amp;V_un_ctl, (uintptr_t)NULL, (uintptr_t)ctl)) {</p><p>+                free(ptr, M_NETLINK);</p><p>+                free(ctl, M_NETLINK);</p><p>+	}</p><p>+</p><p>+	if (atomic_load_ptr(&amp;V_un_ctl) == NULL)</p><p>+		return (false);</p><p>+</p><p>+	NL_LOG(LOG_NOTICE, &#34;UNHOPS init done&#34;);</p><p>+</p><p>+        return (true);</p><p>+}</p><p>+</p><p>+static void</p><p>+vnet_destroy_unhops(const void *unused __unused)</p><p>+{</p><p>+	struct unhop_ctl *ctl = atomic_load_ptr(&amp;V_un_ctl);</p><p>+	struct user_nhop *unhop, *tmp;</p><p>+</p><p>+	if (ctl == NULL)</p><p>+		return;</p><p>+	V_un_ctl = NULL;</p><p>+</p><p>+	/* Wait till all unhop users finish their reads */</p><p>+	epoch_wait_preempt(net_epoch_preempt);</p><p>+</p><p>+	UN_WLOCK(ctl);</p><p>+	CHT_SLIST_FOREACH_SAFE(&amp;ctl-&gt;un_head, unhop, unhop, tmp) {</p><p>+		destroy_unhop(unhop);</p><p>+	} CHT_SLIST_FOREACH_SAFE_END;</p><p>+	UN_WUNLOCK(ctl);</p><p>+</p><p>+	free(ctl-&gt;un_head.ptr, M_NETLINK);</p><p>+	free(ctl, M_NETLINK);</p><p>+}</p><p>+VNET_SYSUNINIT(vnet_destroy_unhops, SI_SUB_PROTO_IF, SI_ORDER_ANY,</p><p>+    vnet_destroy_unhops, NULL);</p><p>+</p><p>+static int</p><p>+nlattr_get_nhg(struct nlattr *nla, struct nl_pstate *npt, const void *arg, void *target)</p><p>+{</p><p>+	int error = 0;</p><p>+</p><p>+	/* Verify attribute correctness */</p><p>+	struct nexthop_grp *grp = NLA_DATA(nla);</p><p>+	int data_len = NLA_DATA_LEN(nla);</p><p>+</p><p>+	int count = data_len / sizeof(*grp);</p><p>+	if (count == 0 || (count * sizeof(*grp) != data_len)) {</p><p>+		NL_LOG(LOG_DEBUG, &#34;Invalid length for RTA_GROUP: %d&#34;, data_len);</p><p>+		return (EINVAL);</p><p>+	}</p><p>+</p><p>+	*((struct nlattr **)target) = nla;</p><p>+	return (error);</p><p>+}</p><p>+</p><p>+struct nl_parsed_nhop {</p><p>+	uint32_t	nha_id;</p><p>+	uint8_t		nha_blackhole;</p><p>+	uint8_t		nha_groups;</p><p>+	struct ifnet	*nha_oif;</p><p>+	struct sockaddr	*nha_gw;</p><p>+	struct nlattr	*nha_group;</p><p>+	uint8_t		nh_family;</p><p>+	uint8_t		nh_protocol;</p><p>+};</p><p>+</p><p>+#define	_IN(_field)	offsetof(struct nhmsg, _field)</p><p>+#define	_OUT(_field)	offsetof(struct nl_parsed_nhop, _field)</p><p>+static const struct nlfield_parser nlf_p_nh[] = {</p><p>+	{ .off_in = _IN(nh_family), .off_out = _OUT(nh_family), .cb = nlf_get_u8 },</p><p>+	{ .off_in = _IN(nh_protocol), .off_out = _OUT(nh_protocol), .cb = nlf_get_u8 },</p><p>+};</p><p>+</p><p>+static const struct nlattr_parser nla_p_nh[] = {</p><p>+	{ .type = NHA_ID, .off = _OUT(nha_id), .cb = nlattr_get_uint32 },</p><p>+	{ .type = NHA_GROUP, .off = _OUT(nha_group), .cb = nlattr_get_nhg },</p><p>+	{ .type = NHA_BLACKHOLE, .off = _OUT(nha_blackhole), .cb = nlattr_get_flag },</p><p>+	{ .type = NHA_OIF, .off = _OUT(nha_oif), .cb = nlattr_get_ifp },</p><p>+	{ .type = NHA_GATEWAY, .off = _OUT(nha_gw), .cb = nlattr_get_ip },</p><p>+	{ .type = NHA_GROUPS, .off = _OUT(nha_groups), .cb = nlattr_get_flag },</p><p>+};</p><p>+#undef _IN</p><p>+#undef _OUT</p><p>+NL_DECLARE_PARSER(nhmsg_parser, struct nhmsg, nlf_p_nh, nla_p_nh);</p><p>+</p><p>+static bool</p><p>+eligible_nhg(const struct nhop_object *nh)</p><p>+{</p><p>+	return (nh-&gt;nh_flags &amp; NHF_GATEWAY);</p><p>+}</p><p>+</p><p>+static int</p><p>+newnhg(struct unhop_ctl *ctl, struct nl_parsed_nhop *attrs, struct user_nhop *unhop)</p><p>+{</p><p>+	struct nexthop_grp *grp = NLA_DATA(attrs-&gt;nha_group);</p><p>+	int count = NLA_DATA_LEN(attrs-&gt;nha_group) / sizeof(*grp);</p><p>+	struct weightened_nhop *wn;</p><p>+</p><p>+	wn = malloc(sizeof(*wn) * count, M_NETLINK, M_NOWAIT | M_ZERO);</p><p>+	if (wn == NULL)</p><p>+		return (ENOMEM);</p><p>+</p><p>+	for (int i = 0; i &lt; count; i++) {</p><p>+		struct user_nhop *unhop;</p><p>+		unhop = nl_find_base_unhop(ctl, grp[i].id);</p><p>+		if (unhop == NULL) {</p><p>+			NL_LOG(LOG_DEBUG, &#34;unable to find uidx %u&#34;, grp[i].id);</p><p>+			free(wn, M_NETLINK);</p><p>+			return (ESRCH);</p><p>+		} else if (unhop-&gt;un_nhop_src == NULL) {</p><p>+			NL_LOG(LOG_DEBUG, &#34;uidx %u is a group, nested group unsupported&#34;,</p><p>+			    grp[i].id);</p><p>+			free(wn, M_NETLINK);</p><p>+			return (ENOTSUP);</p><p>+		} else if (!eligible_nhg(unhop-&gt;un_nhop_src)) {</p><p>+			NL_LOG(LOG_DEBUG, &#34;uidx %u nhop is not mpath-eligible&#34;,</p><p>+			    grp[i].id);</p><p>+			free(wn, M_NETLINK);</p><p>+			return (ENOTSUP);</p><p>+		}</p><p>+		/*</p><p>+		 * TODO: consider more rigid eligibility checks:</p><p>+		 * restrict nexthops with the same gateway</p><p>+		 */</p><p>+		wn[i].nh = unhop-&gt;un_nhop_src;</p><p>+		wn[i].weight = grp[i].weight;</p><p>+	}</p><p>+	unhop-&gt;un_nhgrp_src = wn;</p><p>+	unhop-&gt;un_nhgrp_count = count;</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+static int</p><p>+newnhop(struct nl_parsed_nhop *attrs, struct user_nhop *unhop)</p><p>+{</p><p>+	struct ifaddr *ifa = NULL;</p><p>+	struct nhop_object *nh;</p><p>+	int error;</p><p>+</p><p>+	if (!attrs-&gt;nha_blackhole) {</p><p>+		if (attrs-&gt;nha_gw == NULL) {</p><p>+			NL_LOG(LOG_DEBUG, &#34;missing NHA_GATEWAY&#34;);</p><p>+			return (EINVAL);</p><p>+		}</p><p>+		if (attrs-&gt;nha_oif == NULL) {</p><p>+			NL_LOG(LOG_DEBUG, &#34;missing NHA_OIF&#34;);</p><p>+			return (EINVAL);</p><p>+		}</p><p>+		if (ifa == NULL)</p><p>+			ifa = ifaof_ifpforaddr(attrs-&gt;nha_gw, attrs-&gt;nha_oif);</p><p>+		if (ifa == NULL) {</p><p>+			NL_LOG(LOG_DEBUG, &#34;Unable to determine default source IP&#34;);</p><p>+			return (EINVAL);</p><p>+		}</p><p>+	}</p><p>+</p><p>+	int family = attrs-&gt;nha_gw != NULL ? attrs-&gt;nha_gw-&gt;sa_family : attrs-&gt;nh_family;</p><p>+</p><p>+	nh = nhop_alloc(RT_DEFAULT_FIB, family);</p><p>+	if (nh == NULL) {</p><p>+		NL_LOG(LOG_DEBUG, &#34;Unable to allocate nexthop&#34;);</p><p>+		return (ENOMEM);</p><p>+	}</p><p>+	nhop_set_uidx(nh, attrs-&gt;nha_id);</p><p>+</p><p>+	if (attrs-&gt;nha_blackhole)</p><p>+		nhop_set_blackhole(nh, NHF_BLACKHOLE);</p><p>+	else {</p><p>+		nhop_set_gw(nh, attrs-&gt;nha_gw, true);</p><p>+		nhop_set_transmit_ifp(nh, attrs-&gt;nha_oif);</p><p>+		nhop_set_src(nh, ifa);</p><p>+	}</p><p>+</p><p>+	error = nhop_get_unlinked(nh);</p><p>+	if (error != 0) {</p><p>+		NL_LOG(LOG_DEBUG, &#34;unable to finalize nexthop&#34;);</p><p>+		return (error);</p><p>+	}</p><p>+</p><p>+	IF_DEBUG_LEVEL(LOG_DEBUG2) {</p><p>+		char nhbuf[NHOP_PRINT_BUFSIZE];</p><p>+		nhop_print_buf(nh, nhbuf, sizeof(nhbuf));</p><p>+		NL_LOG(LOG_DEBUG2, &#34;Adding unhop %u: %s&#34;, attrs-&gt;nha_id, nhbuf);</p><p>+	}</p><p>+</p><p>+	unhop-&gt;un_nhop_src = nh;</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+static int</p><p>+rtnl_handle_newnhop(struct nlmsghdr *hdr, struct nlpcb *nlp,</p><p>+    struct nl_pstate *npt)</p><p>+{</p><p>+	struct user_nhop *unhop;</p><p>+	int error;</p><p>+</p><p>+        if ((__predict_false(V_un_ctl == NULL)) &amp;&amp; (!vnet_init_unhops()))</p><p>+		return (ENOMEM);</p><p>+	struct unhop_ctl *ctl = V_un_ctl;</p><p>+</p><p>+	struct nl_parsed_nhop attrs = {};</p><p>+	error = nl_parse_nlmsg(hdr, &amp;nhmsg_parser, npt, &amp;attrs);</p><p>+	if (error != 0)</p><p>+		return (error);</p><p>+</p><p>+	/*</p><p>+	 * Get valid nha_id. Treat nha_id == 0 (auto-assignment) as a second-class</p><p>+	 *  citizen.</p><p>+	 */</p><p>+	if (attrs.nha_id == 0) {</p><p>+		attrs.nha_id = find_spare_uidx(ctl);</p><p>+		if (attrs.nha_id == 0) {</p><p>+			NL_LOG(LOG_DEBUG, &#34;Unable to get spare uidx&#34;);</p><p>+			return (ENOSPC);</p><p>+		}</p><p>+	}</p><p>+</p><p>+	NL_LOG(LOG_DEBUG, &#34;IFINDEX %d&#34;, attrs.nha_oif ? attrs.nha_oif-&gt;if_index : 0);</p><p>+</p><p>+	unhop = malloc(sizeof(struct user_nhop), M_NETLINK, M_NOWAIT | M_ZERO);</p><p>+	if (unhop == NULL) {</p><p>+		NL_LOG(LOG_DEBUG, &#34;Unable to allocate user_nhop&#34;);</p><p>+		return (ENOMEM);</p><p>+	}</p><p>+	unhop-&gt;un_idx = attrs.nha_id;</p><p>+	unhop-&gt;un_protocol = attrs.nh_protocol;</p><p>+</p><p>+	if (attrs.nha_group)</p><p>+		error = newnhg(ctl, &amp;attrs, unhop);</p><p>+	else</p><p>+		error = newnhop(&amp;attrs, unhop);</p><p>+</p><p>+	if (error != 0) {</p><p>+		free(unhop, M_NETLINK);</p><p>+		return (error);</p><p>+	}</p><p>+</p><p>+	UN_WLOCK(ctl);</p><p>+	/* Check if uidx already exists */</p><p>+	struct user_nhop *tmp = NULL;</p><p>+	CHT_SLIST_FIND_BYOBJ(&amp;ctl-&gt;un_head, unhop, unhop, tmp);</p><p>+	if (tmp != NULL) {</p><p>+		UN_WUNLOCK(ctl);</p><p>+		NL_LOG(LOG_DEBUG, &#34;nhop idx %u already exists&#34;, attrs.nha_id);</p><p>+		destroy_unhop(unhop);</p><p>+		return (EEXIST);</p><p>+	}</p><p>+	CHT_SLIST_INSERT_HEAD(&amp;ctl-&gt;un_head, unhop, unhop);</p><p>+	uint32_t num_buckets_new = CHT_SLIST_GET_RESIZE_BUCKETS(&amp;ctl-&gt;un_head);</p><p>+	UN_WUNLOCK(ctl);</p><p>+</p><p>+	/* Report addition of the next nexhop */</p><p>+	struct netlink_walkargs wa = {</p><p>+		.hdr.nlmsg_pid = hdr-&gt;nlmsg_pid,</p><p>+		.hdr.nlmsg_seq = hdr-&gt;nlmsg_seq,</p><p>+		.hdr.nlmsg_flags = hdr-&gt;nlmsg_flags,</p><p>+		.hdr.nlmsg_type = NL_RTM_NEWNEXTHOP,</p><p>+	};</p><p>+</p><p>+	struct nl_writer nw = {};</p><p>+	if (!nlmsg_get_group_writer(&amp;nw, NLMSG_SMALL, NETLINK_ROUTE, RTNLGRP_NEXTHOP)) {</p><p>+		NL_LOG(LOG_DEBUG, &#34;error allocating message writer&#34;);</p><p>+		return (ENOMEM);</p><p>+	}</p><p>+</p><p>+	dump_unhop(unhop, &amp;wa.hdr, &amp;nw);</p><p>+	nlmsg_flush(&amp;nw);</p><p>+</p><p>+	consider_resize(ctl, num_buckets_new);</p><p>+</p><p>+        return (0);</p><p>+}</p><p>+</p><p>+static int</p><p>+rtnl_handle_delnhop(struct nlmsghdr *hdr, struct nlpcb *nlp,</p><p>+    struct nl_pstate *npt)</p><p>+{</p><p>+	struct unhop_ctl *ctl = atomic_load_ptr(&amp;V_un_ctl);</p><p>+	int error;</p><p>+</p><p>+	if (__predict_false(ctl == NULL))</p><p>+		return (ESRCH);</p><p>+</p><p>+	struct nl_parsed_nhop attrs = {};</p><p>+	error = nl_parse_nlmsg(hdr, &amp;nhmsg_parser, npt, &amp;attrs);</p><p>+	if (error != 0)</p><p>+		return (error);</p><p>+</p><p>+	if (attrs.nha_id == 0) {</p><p>+		NL_LOG(LOG_DEBUG, &#34;NHA_ID not set&#34;);</p><p>+		return (EINVAL);</p><p>+	}</p><p>+</p><p>+	error = delete_unhop(ctl, hdr, attrs.nha_id);</p><p>+</p><p>+        return (error);</p><p>+}</p><p>+</p><p>+static bool</p><p>+match_unhop(const struct nl_parsed_nhop *attrs, struct user_nhop *unhop)</p><p>+{</p><p>+	if (attrs-&gt;nha_id != 0 &amp;&amp; unhop-&gt;un_idx != attrs-&gt;nha_id)</p><p>+		return (false);</p><p>+	if (attrs-&gt;nha_groups != 0 &amp;&amp; unhop-&gt;un_nhgrp_src == NULL)</p><p>+		return (false);</p><p>+	if (attrs-&gt;nha_oif != NULL &amp;&amp;</p><p>+	    (unhop-&gt;un_nhop_src == NULL || unhop-&gt;un_nhop_src-&gt;nh_ifp != attrs-&gt;nha_oif))</p><p>+		return (false);</p><p>+</p><p>+	return (true);</p><p>+}</p><p>+</p><p>+static int</p><p>+rtnl_handle_getnhop(struct nlmsghdr *hdr, struct nlpcb *nlp,</p><p>+    struct nl_pstate *npt)</p><p>+{</p><p>+	struct unhop_ctl *ctl = atomic_load_ptr(&amp;V_un_ctl);</p><p>+	struct user_nhop *unhop;</p><p>+	UN_TRACKER;</p><p>+	int error;</p><p>+</p><p>+	if (__predict_false(ctl == NULL))</p><p>+		return (ESRCH);</p><p>+</p><p>+	struct nl_parsed_nhop attrs = {};</p><p>+	error = nl_parse_nlmsg(hdr, &amp;nhmsg_parser, npt, &amp;attrs);</p><p>+	if (error != 0)</p><p>+		return (error);</p><p>+</p><p>+	struct netlink_walkargs wa = {</p><p>+		.nw = npt-&gt;nw,</p><p>+		.hdr.nlmsg_pid = hdr-&gt;nlmsg_pid,</p><p>+		.hdr.nlmsg_seq = hdr-&gt;nlmsg_seq,</p><p>+		.hdr.nlmsg_flags = hdr-&gt;nlmsg_flags,</p><p>+		.hdr.nlmsg_type = NL_RTM_NEWNEXTHOP,</p><p>+	};</p><p>+</p><p>+	if (attrs.nha_id != 0) {</p><p>+		NL_LOG(LOG_DEBUG2, &#34;searching for uidx %u&#34;, attrs.nha_id);</p><p>+		struct user_nhop key= { .un_idx = attrs.nha_id };</p><p>+		UN_RLOCK(ctl);</p><p>+		CHT_SLIST_FIND_BYOBJ(&amp;ctl-&gt;un_head, unhop, &amp;key, unhop);</p><p>+		UN_RUNLOCK(ctl);</p><p>+</p><p>+		if (unhop == NULL)</p><p>+			return (ESRCH);</p><p>+		dump_unhop(unhop, &amp;wa.hdr, wa.nw);</p><p>+		return (0);</p><p>+	}</p><p>+</p><p>+	UN_RLOCK(ctl);</p><p>+	wa.hdr.nlmsg_flags |= NLM_F_MULTI;</p><p>+	CHT_SLIST_FOREACH(&amp;ctl-&gt;un_head, unhop, unhop) {</p><p>+		if (UNHOP_IS_MASTER(unhop) &amp;&amp; match_unhop(&amp;attrs, unhop))</p><p>+			dump_unhop(unhop, &amp;wa.hdr, wa.nw);</p><p>+	} CHT_SLIST_FOREACH_END;</p><p>+	UN_RUNLOCK(ctl);</p><p>+</p><p>+	if (wa.error == 0) {</p><p>+		if (!nlmsg_end_dump(wa.nw, wa.error, &amp;wa.hdr))</p><p>+			return (ENOMEM);</p><p>+	}</p><p>+        return (0);</p><p>+}</p><p>+</p><p>+static const struct rtnl_cmd_handler cmd_handlers[] = {</p><p>+	{</p><p>+		.cmd = NL_RTM_NEWNEXTHOP,</p><p>+		.name = &#34;RTM_NEWNEXTHOP&#34;,</p><p>+		.cb = &amp;rtnl_handle_newnhop,</p><p>+		.priv = PRIV_NET_ROUTE,</p><p>+	},</p><p>+	{</p><p>+		.cmd = NL_RTM_DELNEXTHOP,</p><p>+		.name = &#34;RTM_DELNEXTHOP&#34;,</p><p>+		.cb = &amp;rtnl_handle_delnhop,</p><p>+		.priv = PRIV_NET_ROUTE,</p><p>+	},</p><p>+	{</p><p>+		.cmd = NL_RTM_GETNEXTHOP,</p><p>+		.name = &#34;RTM_GETNEXTHOP&#34;,</p><p>+		.cb = &amp;rtnl_handle_getnhop,</p><p>+	}</p><p>+};</p><p>+</p><p>+static const struct nlhdr_parser *all_parsers[] = { &amp;nhmsg_parser };</p><p>+</p><p>+void</p><p>+rtnl_nexthops_init()</p><p>+{</p><p>+	NL_VERIFY_PARSERS(all_parsers);</p><p>+	rtnl_register_messages(cmd_handlers, NL_ARRAY_LEN(cmd_handlers));</p><p>+}</p><div><p>diff --git a/sys/netlink/route/nexthop.h b/sys/netlink/route/nexthop.h</p></div><p>@@ -0,0 +1,102 @@</p><p>+/*-</p><p>+ * SPDX-License-Identifier: BSD-2-Clause-FreeBSD</p><p>+ *</p><p>+ * Copyright (c) 2022 Alexander V. Chernikov &lt;melifaro@FreeBSD.org&gt;</p><p>+ *</p><p>+ * Redistribution and use in source and binary forms, with or without</p><p>+ * modification, are permitted provided that the following conditions</p><p>+ * are met:</p><p>+ * 1. Redistributions of source code must retain the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer.</p><p>+ * 2. Redistributions in binary form must reproduce the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer in the</p><p>+ *    documentation and/or other materials provided with the distribution.</p><p>+ *</p><p>+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&#39;&#39; AND</p><p>+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</p><p>+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</p><p>+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE</p><p>+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</p><p>+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</p><p>+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</p><p>+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</p><p>+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</p><p>+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</p><p>+ * SUCH DAMAGE.</p><p>+ */</p><p>+</p><p>+/*</p><p>+ * NEXTHOP-related (RTM_&lt;NEW|DEL|GET&gt;NEXTHOP) message header and attributes.</p><p>+ */</p><p>+</p><p>+#ifndef _NETLINK_ROUTE_NEXTHOP_H_</p><p>+#define _NETLINK_ROUTE_NEXTHOP_H_</p><p>+</p><p>+/* Base header for all of the relevant messages */</p><p>+struct nhmsg {</p><p>+        unsigned char	nh_family;	/* transport family */</p><p>+	unsigned char	nh_scope;	/* ignored on RX, filled by kernel */</p><p>+	unsigned char	nh_protocol;	/* Routing protocol that installed nh */</p><p>+	unsigned char	resvd;</p><p>+	unsigned int	nh_flags;	/* RTNH_F_* flags from route.h */</p><p>+};</p><p>+</p><p>+enum {</p><p>+	NHA_UNSPEC,</p><p>+	NHA_ID,		/* u32: nexthop userland index, auto-assigned if 0 */</p><p>+	NHA_GROUP,	/* binary: array of struct nexthop_grp */</p><p>+	NHA_GROUP_TYPE,	/* u16: set to NEXTHOP_GRP_TYPE */</p><p>+	NHA_BLACKHOLE,	/* flag: nexthop used to blackhole packets */</p><p>+	NHA_OIF,	/* u32: transmit ifindex */</p><p>+	NHA_GATEWAY,	/* network: IPv4/IPv6 gateway addr */</p><p>+	NHA_ENCAP_TYPE, /* not supported */</p><p>+	NHA_ENCAP,	/* not supported */</p><p>+	NHA_GROUPS,	/* flag: match nexthop groups */</p><p>+	NHA_MASTER,	/* not supported */</p><p>+	NHA_FDB,	/* not supported */</p><p>+	NHA_RES_GROUP,	/* not supported */</p><p>+	NHA_RES_BUCKET,	/* not supported */</p><p>+	__NHA_MAX,</p><p>+};</p><p>+#define NHA_MAX	(__NHA_MAX - 1)</p><p>+</p><p>+/*</p><p>+ * Attributes that can be used as filters:</p><p>+ * NHA_ID (nexhop or group), NHA_OIF, NHA_GROUPS,</p><p>+ */</p><p>+</p><p>+/*</p><p>+ * NHA_GROUP: array of the following structures.</p><p>+ * If attribute is set, the only other valid attributes are</p><p>+ *  NHA_ID and NHA_GROUP_TYPE.</p><p>+ *  NHA_RES_GROUP and NHA_RES_BUCKET are not supported yet</p><p>+ */</p><p>+struct nexthop_grp {</p><p>+	uint32_t	id;		/* nexhop userland index */</p><p>+	uint8_t		weight;         /* weight of this nexthop */</p><p>+	uint8_t		resvd1;</p><p>+	uint16_t	resvd2;</p><p>+};</p><p>+</p><p>+/* NHA_GROUP_TYPE: u16 */</p><p>+enum {</p><p>+	NEXTHOP_GRP_TYPE_MPATH,		/* default nexthop group */</p><p>+	NEXTHOP_GRP_TYPE_RES,		/* resilient nexthop group */</p><p>+	__NEXTHOP_GRP_TYPE_MAX,</p><p>+};</p><p>+#define NEXTHOP_GRP_TYPE_MAX (__NEXTHOP_GRP_TYPE_MAX - 1)</p><p>+</p><p>+</p><p>+/* NHA_RES_GROUP */</p><p>+enum {</p><p>+	NHA_RES_GROUP_UNSPEC,</p><p>+	NHA_RES_GROUP_PAD = NHA_RES_GROUP_UNSPEC,</p><p>+	NHA_RES_GROUP_BUCKETS,</p><p>+	NHA_RES_GROUP_IDLE_TIMER,</p><p>+	NHA_RES_GROUP_UNBALANCED_TIMER,</p><p>+	NHA_RES_GROUP_UNBALANCED_TIME,</p><p>+	__NHA_RES_GROUP_MAX,</p><p>+};</p><p>+#define NHA_RES_GROUP_MAX	(__NHA_RES_GROUP_MAX - 1)</p><p>+</p><p>+#endif</p><div><p>diff --git a/sys/netlink/route/route.c b/sys/netlink/route/route.c</p></div><p>@@ -0,0 +1,972 @@</p><p>+/*-</p><p>+ * SPDX-License-Identifier: BSD-2-Clause-FreeBSD</p><p>+ *</p><p>+ * Copyright (c) 2021 Ng Peng Nam Sean</p><p>+ * Copyright (c) 2022 Alexander V. Chernikov &lt;melifaro@FreeBSD.org&gt;</p><p>+ *</p><p>+ * Redistribution and use in source and binary forms, with or without</p><p>+ * modification, are permitted provided that the following conditions</p><p>+ * are met:</p><p>+ * 1. Redistributions of source code must retain the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer.</p><p>+ * 2. Redistributions in binary form must reproduce the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer in the</p><p>+ *    documentation and/or other materials provided with the distribution.</p><p>+ *</p><p>+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&#39;&#39; AND</p><p>+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</p><p>+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</p><p>+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE</p><p>+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</p><p>+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</p><p>+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</p><p>+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</p><p>+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</p><p>+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</p><p>+ * SUCH DAMAGE.</p><p>+ */</p><p>+</p><p>+#include &lt;sys/cdefs.h&gt;</p><p>+__FBSDID(&#34;$FreeBSD$&#34;);</p><p>+#include &#34;opt_inet.h&#34;</p><p>+#include &#34;opt_inet6.h&#34;</p><p>+#include &#34;opt_route.h&#34;</p><p>+#include &lt;sys/types.h&gt;</p><p>+#include &lt;sys/malloc.h&gt;</p><p>+#include &lt;sys/rmlock.h&gt;</p><p>+#include &lt;sys/socket.h&gt;</p><p>+</p><p>+#include &lt;net/if.h&gt;</p><p>+#include &lt;net/route.h&gt;</p><p>+#include &lt;net/route/nhop.h&gt;</p><p>+#include &lt;net/route/route_ctl.h&gt;</p><p>+#include &lt;net/route/route_var.h&gt;</p><p>+#include &lt;netlink/netlink.h&gt;</p><p>+#include &lt;netlink/netlink_ctl.h&gt;</p><p>+#include &lt;netlink/netlink_route.h&gt;</p><p>+#include &lt;netlink/route/route_var.h&gt;</p><p>+</p><p>+#define	DEBUG_MOD_NAME	nl_route</p><p>+#define	DEBUG_MAX_LEVEL	LOG_DEBUG3</p><p>+#include &lt;netlink/netlink_debug.h&gt;</p><p>+_DECLARE_DEBUG(LOG_DEBUG);</p><p>+</p><p>+static unsigned char</p><p>+get_rtm_type(const struct nhop_object *nh)</p><p>+{</p><p>+	int nh_flags = nh-&gt;nh_flags;</p><p>+</p><p>+	/* Use the fact that nhg runtime flags are only NHF_MULTIPATH */</p><p>+	if (nh_flags &amp; NHF_BLACKHOLE)</p><p>+		return (RTN_BLACKHOLE);</p><p>+	else if (nh_flags &amp; NHF_REJECT)</p><p>+		return (RTN_PROHIBIT);</p><p>+	return (RTN_UNICAST);</p><p>+}</p><p>+</p><p>+static uint8_t</p><p>+nl_get_rtm_protocol(const struct nhop_object *nh)</p><p>+{</p><p>+	if (NH_IS_NHGRP(nh)) {</p><p>+		const struct nhgrp_object *nhg = (const struct nhgrp_object *)nh;</p><p>+		uint8_t origin = nhgrp_get_origin(nhg);</p><p>+		if (origin != RTPROT_UNSPEC)</p><p>+			return (origin);</p><p>+		nh = nhg-&gt;nhops[0];</p><p>+	}</p><p>+	uint8_t origin = nhop_get_origin(nh);</p><p>+	if (origin != RTPROT_UNSPEC)</p><p>+		return (origin);</p><p>+	/* TODO: remove guesswork once all kernel users fill in origin */</p><p>+	int rt_flags = nhop_get_rtflags(nh);</p><p>+	if (rt_flags &amp; RTF_PROTO1)</p><p>+		return (RTPROT_ZEBRA);</p><p>+	if (rt_flags &amp; RTF_STATIC)</p><p>+		return (RTPROT_STATIC);</p><p>+	return (RTPROT_KERNEL);</p><p>+}</p><p>+</p><p>+static int</p><p>+get_rtmsg_type_from_rtsock(int cmd)</p><p>+{</p><p>+	switch (cmd) {</p><p>+	case RTM_ADD:</p><p>+	case RTM_CHANGE:</p><p>+	case RTM_GET:</p><p>+		return NL_RTM_NEWROUTE;</p><p>+	case RTM_DELETE:</p><p>+		return NL_RTM_DELROUTE;</p><p>+	}</p><p>+</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+/*</p><p>+ * fibnum heuristics</p><p>+ *</p><p>+ * if (dump &amp;&amp; rtm_table == 0 &amp;&amp; !rta_table) RT_ALL_FIBS</p><p>+ * msg                rtm_table     RTA_TABLE            result</p><p>+ * RTM_GETROUTE/dump          0             -       RT_ALL_FIBS</p><p>+ * RTM_GETROUTE/dump          1             -                 1</p><p>+ * RTM_GETROUTE/get           0             -                 0</p><p>+ *</p><p>+ */</p><p>+</p><p>+static struct nhop_object *</p><p>+rc_get_nhop(const struct rib_cmd_info *rc)</p><p>+{</p><p>+	return ((rc-&gt;rc_cmd == RTM_DELETE) ? rc-&gt;rc_nh_old : rc-&gt;rc_nh_new);</p><p>+}</p><p>+</p><p>+static void</p><p>+dump_rc_nhop_gw(struct nl_writer *nw, const struct nhop_object *nh)</p><p>+{</p><p>+	int upper_family;</p><p>+</p><p>+	switch (nhop_get_neigh_family(nh)) {</p><p>+	case AF_LINK:</p><p>+		/* onlink prefix, skip */</p><p>+		break;</p><p>+	case AF_INET:</p><p>+		nlattr_add(nw, NL_RTA_GATEWAY, 4, &amp;nh-&gt;gw4_sa.sin_addr);</p><p>+		break;</p><p>+	case AF_INET6:</p><p>+		upper_family = nhop_get_upper_family(nh);</p><p>+		if (upper_family == AF_INET6) {</p><p>+			nlattr_add(nw, NL_RTA_GATEWAY, 16, &amp;nh-&gt;gw6_sa.sin6_addr);</p><p>+		} else if (upper_family == AF_INET) {</p><p>+			/* IPv4 over IPv6 */</p><p>+			char buf[20];</p><p>+			struct rtvia *via = (struct rtvia *)&amp;buf[0];</p><p>+			via-&gt;rtvia_family = AF_INET6;</p><p>+			memcpy(via-&gt;rtvia_addr, &amp;nh-&gt;gw6_sa.sin6_addr, 16);</p><p>+			nlattr_add(nw, NL_RTA_VIA, 17, via);</p><p>+		}</p><p>+		break;</p><p>+	}</p><p>+}</p><p>+</p><p>+static void</p><p>+dump_rc_nhop_mtu(struct nl_writer *nw, const struct nhop_object *nh)</p><p>+{</p><p>+	int nla_len = sizeof(struct nlattr) * 2 + sizeof(uint32_t);</p><p>+	struct nlattr *nla = nlmsg_reserve_data(nw, nla_len, struct nlattr);</p><p>+</p><p>+	if (nla == NULL)</p><p>+		return;</p><p>+	nla-&gt;nla_type = NL_RTA_METRICS;</p><p>+	nla-&gt;nla_len = nla_len;</p><p>+	nla++;</p><p>+	nla-&gt;nla_type = NL_RTAX_MTU;</p><p>+	nla-&gt;nla_len = sizeof(struct nlattr) + sizeof(uint32_t);</p><p>+	*((uint32_t *)(nla + 1)) = nh-&gt;nh_mtu;</p><p>+}</p><p>+</p><p>+static void</p><p>+dump_rc_nhg(struct nl_writer *nw, const struct nhgrp_object *nhg, struct rtmsg *rtm)</p><p>+{</p><p>+	uint32_t uidx = nhgrp_get_uidx(nhg);</p><p>+	uint32_t num_nhops;</p><p>+	const struct weightened_nhop *wn = nhgrp_get_nhops(nhg, &amp;num_nhops);</p><p>+	uint32_t base_rtflags = nhop_get_rtflags(wn[0].nh);</p><p>+</p><p>+	if (uidx != 0)</p><p>+		nlattr_add_u32(nw, NL_RTA_NH_ID, uidx);</p><p>+</p><p>+	nlattr_add_u32(nw, NL_RTA_RTFLAGS, base_rtflags);</p><p>+	int off = nlattr_add_nested(nw, NL_RTA_MULTIPATH);</p><p>+	if (off == 0)</p><p>+		return;</p><p>+</p><p>+	for (int i = 0; i &lt; num_nhops; i++) {</p><p>+		int nh_off = nlattr_save_offset(nw);</p><p>+		struct rtnexthop *rtnh = nlmsg_reserve_object(nw, struct rtnexthop);</p><p>+		if (rtnh == NULL)</p><p>+			return;</p><p>+		rtnh-&gt;rtnh_flags = 0;</p><p>+		rtnh-&gt;rtnh_ifindex = wn[i].nh-&gt;nh_ifp-&gt;if_index;</p><p>+		rtnh-&gt;rtnh_hops = wn[i].weight;</p><p>+		dump_rc_nhop_gw(nw, wn[i].nh);</p><p>+		uint32_t rtflags = nhop_get_rtflags(wn[i].nh);</p><p>+		if (rtflags != base_rtflags)</p><p>+			nlattr_add_u32(nw, NL_RTA_RTFLAGS, rtflags);</p><p>+		if (rtflags &amp; RTF_FIXEDMTU)</p><p>+			dump_rc_nhop_mtu(nw, wn[i].nh);</p><p>+		rtnh = nlattr_restore_offset(nw, nh_off, struct rtnexthop);</p><p>+		/*</p><p>+		 * nlattr_add() allocates 4-byte aligned storage, no need to aligh</p><p>+		 * length here</p><p>+		 * */</p><p>+		rtnh-&gt;rtnh_len = nlattr_save_offset(nw) - nh_off;</p><p>+	}</p><p>+	nlattr_set_len(nw, off);</p><p>+}</p><p>+</p><p>+static void</p><p>+dump_rc_nhop(struct nl_writer *nw, const struct nhop_object *nh, struct rtmsg *rtm)</p><p>+{</p><p>+	if (NH_IS_NHGRP(nh)) {</p><p>+		dump_rc_nhg(nw, (const struct nhgrp_object *)nh, rtm);</p><p>+		return;</p><p>+	}</p><p>+</p><p>+	uint32_t rtflags = nhop_get_rtflags(nh);</p><p>+</p><p>+	/*</p><p>+	 * IPv4 over IPv6</p><p>+	 *    (&#39;RTA_VIA&#39;, {&#39;family&#39;: 10, &#39;addr&#39;: &#39;fe80::20c:29ff:fe67:2dd&#39;}), (&#39;RTA_OIF&#39;, 2),</p><p>+	 * IPv4 w/ gw</p><p>+	 *    (&#39;RTA_GATEWAY&#39;, &#39;172.16.107.131&#39;), (&#39;RTA_OIF&#39;, 2)],</p><p>+	 * Direct route:</p><p>+	 *    (&#39;RTA_OIF&#39;, 2)</p><p>+	 */</p><p>+	if (nh-&gt;nh_flags &amp; NHF_GATEWAY)</p><p>+		dump_rc_nhop_gw(nw, nh);</p><p>+</p><p>+	uint32_t uidx = nhop_get_uidx(nh);</p><p>+	if (uidx != 0)</p><p>+		nlattr_add_u32(nw, NL_RTA_NH_ID, uidx);</p><p>+	nlattr_add_u32(nw, NL_RTA_KNH_ID, nhop_get_idx(nh));</p><p>+	nlattr_add_u32(nw, NL_RTA_RTFLAGS, rtflags);</p><p>+</p><p>+	if (rtflags &amp; RTF_FIXEDMTU)</p><p>+		dump_rc_nhop_mtu(nw, nh);</p><p>+	uint32_t nh_expire = nhop_get_expire(nh);</p><p>+	if (nh_expire &gt; 0)</p><p>+		nlattr_add_u32(nw, NL_RTA_EXPIRES, nh_expire - time_uptime);</p><p>+</p><p>+	/* In any case, fill outgoing interface */</p><p>+	nlattr_add_u32(nw, NL_RTA_OIF, nh-&gt;nh_ifp-&gt;if_index);</p><p>+}</p><p>+</p><p>+/*</p><p>+ * Dumps output from a rib command into an rtmsg</p><p>+ */</p><p>+</p><p>+static int</p><p>+dump_px(uint32_t fibnum, const struct nlmsghdr *hdr,</p><p>+    const struct rtentry *rt, struct route_nhop_data *rnd,</p><p>+    struct nl_writer *nw)</p><p>+{</p><p>+	struct rtmsg *rtm;</p><p>+	int error = 0;</p><p>+</p><p>+	NET_EPOCH_ASSERT();</p><p>+</p><p>+	if (!nlmsg_reply(nw, hdr, sizeof(struct rtmsg)))</p><p>+		goto enomem;</p><p>+</p><p>+	int family = rt_get_family(rt);</p><p>+	int rtm_off = nlattr_save_offset(nw);</p><p>+	rtm = nlmsg_reserve_object(nw, struct rtmsg);</p><p>+	rtm-&gt;rtm_family = family;</p><p>+	rtm-&gt;rtm_dst_len = 0;</p><p>+	rtm-&gt;rtm_src_len = 0;</p><p>+	rtm-&gt;rtm_tos = 0;</p><p>+	if (fibnum &lt; 255)</p><p>+		rtm-&gt;rtm_table = (unsigned char)fibnum;</p><p>+	rtm-&gt;rtm_scope = RT_SCOPE_UNIVERSE;</p><p>+	if (!NH_IS_NHGRP(rnd-&gt;rnd_nhop)) {</p><p>+		rtm-&gt;rtm_protocol = nl_get_rtm_protocol(rnd-&gt;rnd_nhop);</p><p>+		rtm-&gt;rtm_type = get_rtm_type(rnd-&gt;rnd_nhop);</p><p>+	} else {</p><p>+		rtm-&gt;rtm_protocol = RTPROT_UNSPEC; /* TODO: protocol from nhg? */</p><p>+		rtm-&gt;rtm_type = RTN_UNICAST;</p><p>+	}</p><p>+</p><p>+	nlattr_add_u32(nw, NL_RTA_TABLE, fibnum);</p><p>+</p><p>+	int plen = 0;</p><p>+	uint32_t scopeid = 0;</p><p>+	switch (family) {</p><p>+	case AF_INET:</p><p>+		{</p><p>+			struct in_addr addr;</p><p>+			rt_get_inet_prefix_plen(rt, &amp;addr, &amp;plen, &amp;scopeid);</p><p>+			nlattr_add(nw, NL_RTA_DST, 4, &amp;addr);</p><p>+			break;</p><p>+		}</p><p>+	case AF_INET6:</p><p>+		{</p><p>+			struct in6_addr addr;</p><p>+			rt_get_inet6_prefix_plen(rt, &amp;addr, &amp;plen, &amp;scopeid);</p><p>+			nlattr_add(nw, NL_RTA_DST, 16, &amp;addr);</p><p>+			break;</p><p>+		}</p><p>+	default:</p><p>+		FIB_LOG(LOG_NOTICE, fibnum, family, &#34;unsupported rt family: %d&#34;, family);</p><p>+		error = EAFNOSUPPORT;</p><p>+		goto flush;</p><p>+	}</p><p>+</p><p>+	rtm = nlattr_restore_offset(nw, rtm_off, struct rtmsg);</p><p>+	if (plen &gt; 0)</p><p>+		rtm-&gt;rtm_dst_len = plen;</p><p>+	dump_rc_nhop(nw, rnd-&gt;rnd_nhop, rtm);</p><p>+</p><p>+	if (nlmsg_end(nw))</p><p>+		return (0);</p><p>+enomem:</p><p>+	error = ENOMEM;</p><p>+flush:</p><p>+	nlmsg_abort(nw);</p><p>+	return (error);</p><p>+}</p><p>+</p><p>+static int</p><p>+family_to_group(int family)</p><p>+{</p><p>+	switch (family) {</p><p>+	case AF_INET:</p><p>+		return (RTNLGRP_IPV4_ROUTE);</p><p>+	case AF_INET6:</p><p>+		return (RTNLGRP_IPV6_ROUTE);</p><p>+	}</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+</p><p>+static void</p><p>+report_operation(uint32_t fibnum, struct rib_cmd_info *rc,</p><p>+    struct nlpcb *nlp, struct nlmsghdr *hdr)</p><p>+{</p><p>+	struct nl_writer nw;</p><p>+</p><p>+	uint32_t group_id = family_to_group(rt_get_family(rc-&gt;rc_rt));</p><p>+	if (nlmsg_get_group_writer(&amp;nw, NLMSG_SMALL, NETLINK_ROUTE, group_id)) {</p><p>+		struct route_nhop_data rnd = {</p><p>+			.rnd_nhop = rc_get_nhop(rc),</p><p>+			.rnd_weight = rc-&gt;rc_nh_weight,</p><p>+		};</p><p>+		hdr-&gt;nlmsg_flags &amp;= ~(NLM_F_REPLACE | NLM_F_CREATE);</p><p>+		hdr-&gt;nlmsg_flags &amp;= ~(NLM_F_EXCL | NLM_F_APPEND);</p><p>+		switch (rc-&gt;rc_cmd) {</p><p>+		case RTM_ADD:</p><p>+			hdr-&gt;nlmsg_type = NL_RTM_NEWROUTE;</p><p>+			hdr-&gt;nlmsg_flags |= NLM_F_CREATE | NLM_F_EXCL;</p><p>+			break;</p><p>+		case RTM_CHANGE:</p><p>+			hdr-&gt;nlmsg_type = NL_RTM_NEWROUTE;</p><p>+			hdr-&gt;nlmsg_flags |= NLM_F_REPLACE;</p><p>+			break;</p><p>+		case RTM_DELETE:</p><p>+			hdr-&gt;nlmsg_type = NL_RTM_DELROUTE;</p><p>+			break;</p><p>+		}</p><p>+		dump_px(fibnum, hdr, rc-&gt;rc_rt, &amp;rnd, &amp;nw);</p><p>+		nlmsg_flush(&amp;nw);</p><p>+	}</p><p>+</p><p>+	rtsock_callback_p-&gt;route_f(fibnum, rc);</p><p>+}</p><p>+</p><p>+struct rta_mpath_nh {</p><p>+	struct sockaddr	*gw;</p><p>+	struct ifnet	*ifp;</p><p>+	uint8_t		rtnh_flags;</p><p>+	uint8_t		rtnh_weight;</p><p>+};</p><p>+</p><p>+#define	_IN(_field)	offsetof(struct rtnexthop, _field)</p><p>+#define	_OUT(_field)	offsetof(struct rta_mpath_nh, _field)</p><p>+const static struct nlattr_parser nla_p_rtnh[] = {</p><p>+	{ .type = NL_RTA_GATEWAY, .off = _OUT(gw), .cb = nlattr_get_ip },</p><p>+	{ .type = NL_RTA_VIA, .off = _OUT(gw), .cb = nlattr_get_ipvia },</p><p>+};</p><p>+const static struct nlfield_parser nlf_p_rtnh[] = {</p><p>+	{ .off_in = _IN(rtnh_flags), .off_out = _OUT(rtnh_flags), .cb = nlf_get_u8 },</p><p>+	{ .off_in = _IN(rtnh_hops), .off_out = _OUT(rtnh_weight), .cb = nlf_get_u8 },</p><p>+	{ .off_in = _IN(rtnh_ifindex), .off_out = _OUT(ifp), .cb = nlf_get_ifpz },</p><p>+};</p><p>+#undef _IN</p><p>+#undef _OUT</p><p>+NL_DECLARE_PARSER(mpath_parser, struct rtnexthop, nlf_p_rtnh, nla_p_rtnh);</p><p>+</p><p>+struct rta_mpath {</p><p>+	int num_nhops;</p><p>+	struct rta_mpath_nh nhops[0];</p><p>+};</p><p>+</p><p>+static int</p><p>+nlattr_get_multipath(struct nlattr *nla, struct nl_pstate *npt, const void *arg, void *target)</p><p>+{</p><p>+	int data_len = nla-&gt;nla_len - sizeof(struct nlattr);</p><p>+	struct rtnexthop *rtnh;</p><p>+</p><p>+	int max_nhops = data_len / sizeof(struct rtnexthop);</p><p>+</p><p>+	struct rta_mpath *mp = npt_alloc(npt, (max_nhops + 2) * sizeof(struct rta_mpath_nh));</p><p>+	mp-&gt;num_nhops = 0;</p><p>+</p><p>+	for (rtnh = (struct rtnexthop *)(nla + 1); data_len &gt; 0; ) {</p><p>+		struct rta_mpath_nh *mpnh = &amp;mp-&gt;nhops[mp-&gt;num_nhops++];</p><p>+</p><p>+		int error = nl_parse_header(rtnh, rtnh-&gt;rtnh_len, &amp;mpath_parser,</p><p>+		    npt, mpnh);</p><p>+		if (error != 0) {</p><p>+			NLMSG_REPORT_ERR_MSG(npt, &#34;RTA_MULTIPATH: nexhop %d: parse failed&#34;,</p><p>+			    mp-&gt;num_nhops - 1);</p><p>+			return (error);</p><p>+		}</p><p>+</p><p>+		int len = NL_ITEM_ALIGN(rtnh-&gt;rtnh_len);</p><p>+		data_len -= len;</p><p>+		rtnh = (struct rtnexthop *)((char *)rtnh + len);</p><p>+	}</p><p>+	if (data_len != 0 || mp-&gt;num_nhops == 0) {</p><p>+		NLMSG_REPORT_ERR_MSG(npt, &#34;invalid RTA_MULTIPATH attr&#34;);</p><p>+		return (EINVAL);</p><p>+	}</p><p>+</p><p>+	*((struct rta_mpath **)target) = mp;</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+</p><p>+struct nl_parsed_route {</p><p>+	struct sockaddr		*rta_dst;</p><p>+	struct sockaddr		*rta_gw;</p><p>+	struct ifnet		*rta_oif;</p><p>+	struct rta_mpath	*rta_multipath;</p><p>+	uint32_t		rta_table;</p><p>+	uint32_t		rta_rtflags;</p><p>+	uint32_t		rta_nh_id;</p><p>+	uint32_t		rtax_mtu;</p><p>+	uint8_t			rtm_family;</p><p>+	uint8_t			rtm_dst_len;</p><p>+};</p><p>+</p><p>+#define	_IN(_field)	offsetof(struct rtmsg, _field)</p><p>+#define	_OUT(_field)	offsetof(struct nl_parsed_route, _field)</p><p>+static struct nlattr_parser nla_p_rtmetrics[] = {</p><p>+	{ .type = NL_RTAX_MTU, .off = _OUT(rtax_mtu), .cb = nlattr_get_uint32 },</p><p>+};</p><p>+NL_DECLARE_ATTR_PARSER(metrics_parser, nla_p_rtmetrics);</p><p>+</p><p>+static const struct nlattr_parser nla_p_rtmsg[] = {</p><p>+	{ .type = NL_RTA_DST, .off = _OUT(rta_dst), .cb = nlattr_get_ip },</p><p>+	{ .type = NL_RTA_OIF, .off = _OUT(rta_oif), .cb = nlattr_get_ifp },</p><p>+	{ .type = NL_RTA_GATEWAY, .off = _OUT(rta_gw), .cb = nlattr_get_ip },</p><p>+	{ .type = NL_RTA_METRICS, .arg = &amp;metrics_parser, .cb = nlattr_get_nested },</p><p>+	{ .type = NL_RTA_MULTIPATH, .off = _OUT(rta_multipath), .cb = nlattr_get_multipath },</p><p>+	{ .type = NL_RTA_RTFLAGS, .off = _OUT(rta_rtflags), .cb = nlattr_get_uint32 },</p><p>+	{ .type = NL_RTA_TABLE, .off = _OUT(rta_table), .cb = nlattr_get_uint32 },</p><p>+	{ .type = NL_RTA_VIA, .off = _OUT(rta_gw), .cb = nlattr_get_ipvia },</p><p>+	{ .type = NL_RTA_NH_ID, .off = _OUT(rta_nh_id), .cb = nlattr_get_uint32 },</p><p>+};</p><p>+</p><p>+static const struct nlfield_parser nlf_p_rtmsg[] = {</p><p>+	{.off_in = _IN(rtm_family), .off_out = _OUT(rtm_family), .cb = nlf_get_u8 },</p><p>+	{.off_in = _IN(rtm_dst_len), .off_out = _OUT(rtm_dst_len), .cb = nlf_get_u8 },</p><p>+};</p><p>+#undef _IN</p><p>+#undef _OUT</p><p>+NL_DECLARE_PARSER(rtm_parser, struct rtmsg, nlf_p_rtmsg, nla_p_rtmsg);</p><p>+</p><p>+struct netlink_walkargs {</p><p>+	struct nl_writer *nw;</p><p>+	struct route_nhop_data rnd;</p><p>+	struct nlmsghdr hdr;</p><p>+	struct nlpcb *nlp;</p><p>+	uint32_t fibnum;</p><p>+	int family;</p><p>+	int error;</p><p>+	int count;</p><p>+	int dumped;</p><p>+	int dumped_tables;</p><p>+};</p><p>+</p><p>+static int</p><p>+dump_rtentry(struct rtentry *rt, void *_arg)</p><p>+{</p><p>+	struct netlink_walkargs *wa = (struct netlink_walkargs *)_arg;</p><p>+	int error;</p><p>+</p><p>+	wa-&gt;count++;</p><p>+	if (wa-&gt;error != 0)</p><p>+		return (0);</p><p>+	wa-&gt;dumped++;</p><p>+</p><p>+	rt_get_rnd(rt, &amp;wa-&gt;rnd);</p><p>+</p><p>+	error = dump_px(wa-&gt;fibnum, &amp;wa-&gt;hdr, rt, &amp;wa-&gt;rnd, wa-&gt;nw);</p><p>+</p><p>+	IF_DEBUG_LEVEL(LOG_DEBUG3) {</p><p>+		char rtbuf[INET6_ADDRSTRLEN + 5];</p><p>+		FIB_LOG(LOG_DEBUG3, wa-&gt;fibnum, wa-&gt;family,</p><p>+		    &#34;Dump %s, offset %u, error %d&#34;,</p><p>+		    rt_print_buf(rt, rtbuf, sizeof(rtbuf)),</p><p>+		    wa-&gt;nw-&gt;offset, error);</p><p>+	}</p><p>+	wa-&gt;error = error;</p><p>+</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+static void</p><p>+dump_rtable_one(struct netlink_walkargs *wa, uint32_t fibnum, int family)</p><p>+{</p><p>+	FIB_LOG(LOG_DEBUG2, fibnum, family, &#34;Start dump&#34;);</p><p>+	wa-&gt;count = 0;</p><p>+	wa-&gt;dumped = 0;</p><p>+</p><p>+	rib_walk(fibnum, family, false, dump_rtentry, wa);</p><p>+</p><p>+	wa-&gt;dumped_tables++;</p><p>+</p><p>+	FIB_LOG(LOG_DEBUG2, fibnum, family, &#34;End dump, iterated %d dumped %d&#34;,</p><p>+	    wa-&gt;count, wa-&gt;dumped);</p><p>+	NL_LOG(LOG_DEBUG2, &#34;Current offset: %d&#34;, wa-&gt;nw-&gt;offset);</p><p>+}</p><p>+</p><p>+static int</p><p>+dump_rtable_fib(struct netlink_walkargs *wa, uint32_t fibnum, int family)</p><p>+{</p><p>+	wa-&gt;fibnum = fibnum;</p><p>+</p><p>+	if (family == AF_UNSPEC) {</p><p>+		for (int i = 0; i &lt; AF_MAX; i++) {</p><p>+			if (rt_tables_get_rnh(fibnum, i) != 0) {</p><p>+				wa-&gt;family = i;</p><p>+				dump_rtable_one(wa, fibnum, i);</p><p>+				if (wa-&gt;error != 0)</p><p>+					break;</p><p>+			}</p><p>+		}</p><p>+	} else {</p><p>+		if (rt_tables_get_rnh(fibnum, family) != 0) {</p><p>+			wa-&gt;family = family;</p><p>+			dump_rtable_one(wa, fibnum, family);</p><p>+		}</p><p>+	}</p><p>+</p><p>+	return (wa-&gt;error);</p><p>+}</p><p>+</p><p>+static int</p><p>+handle_rtm_getroute(struct nlpcb *nlp, struct nl_parsed_route *attrs,</p><p>+    struct nlmsghdr *hdr, struct nl_pstate *npt)</p><p>+{</p><p>+	RIB_RLOCK_TRACKER;</p><p>+	struct rib_head *rnh;</p><p>+	struct rtentry *rt;</p><p>+	uint32_t fibnum = attrs-&gt;rta_table;</p><p>+	sa_family_t family = attrs-&gt;rtm_family;</p><p>+</p><p>+	if (attrs-&gt;rta_dst == NULL) {</p><p>+		NLMSG_REPORT_ERR_MSG(npt, &#34;No RTA_DST supplied&#34;);</p><p>+			return (EINVAL);</p><p>+	}</p><p>+</p><p>+	FIB_LOG(LOG_DEBUG, fibnum, family, &#34;getroute called&#34;);</p><p>+</p><p>+	rnh = rt_tables_get_rnh(fibnum, family);</p><p>+	if (rnh == NULL)</p><p>+		return (EAFNOSUPPORT);</p><p>+</p><p>+	RIB_RLOCK(rnh);</p><p>+</p><p>+	rt = (struct rtentry *)rnh-&gt;rnh_matchaddr(attrs-&gt;rta_dst, &amp;rnh-&gt;head);</p><p>+	if (rt == NULL) {</p><p>+		RIB_RUNLOCK(rnh);</p><p>+		return (ESRCH);</p><p>+	}</p><p>+</p><p>+	struct route_nhop_data rnd;</p><p>+	rt_get_rnd(rt, &amp;rnd);</p><p>+	rnd.rnd_nhop = nhop_select_func(rnd.rnd_nhop, 0);</p><p>+</p><p>+	RIB_RUNLOCK(rnh);</p><p>+</p><p>+	IF_DEBUG_LEVEL(LOG_DEBUG2) {</p><p>+		char rtbuf[NHOP_PRINT_BUFSIZE] __unused, nhbuf[NHOP_PRINT_BUFSIZE] __unused;</p><p>+		FIB_LOG(LOG_DEBUG2, fibnum, family, &#34;getroute completed: got %s for %s&#34;,</p><p>+		    nhop_print_buf_any(rnd.rnd_nhop, nhbuf, sizeof(nhbuf)),</p><p>+		    rt_print_buf(rt, rtbuf, sizeof(rtbuf)));</p><p>+	}</p><p>+</p><p>+	hdr-&gt;nlmsg_type = NL_RTM_NEWROUTE;</p><p>+	dump_px(fibnum, hdr, rt, &amp;rnd, npt-&gt;nw);</p><p>+</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+static int</p><p>+handle_rtm_dump(struct nlpcb *nlp, uint32_t fibnum, int family,</p><p>+    struct nlmsghdr *hdr, struct nl_writer *nw)</p><p>+{</p><p>+	struct netlink_walkargs wa = {</p><p>+		.nlp = nlp,</p><p>+		.nw = nw,</p><p>+		.hdr.nlmsg_pid = hdr-&gt;nlmsg_pid,</p><p>+		.hdr.nlmsg_seq = hdr-&gt;nlmsg_seq,</p><p>+		.hdr.nlmsg_type = NL_RTM_NEWROUTE,</p><p>+		.hdr.nlmsg_flags = hdr-&gt;nlmsg_flags | NLM_F_MULTI,</p><p>+	};</p><p>+</p><p>+	if (fibnum == RT_TABLE_UNSPEC) {</p><p>+		for (int i = 0; i &lt; V_rt_numfibs; i++) {</p><p>+			dump_rtable_fib(&amp;wa, fibnum, family);</p><p>+			if (wa.error != 0)</p><p>+				break;</p><p>+		}</p><p>+	} else</p><p>+		dump_rtable_fib(&amp;wa, fibnum, family);</p><p>+</p><p>+	if (wa.error == 0 &amp;&amp; wa.dumped_tables == 0) {</p><p>+		FIB_LOG(LOG_DEBUG, fibnum, family, &#34;incorrect fibnum/family&#34;);</p><p>+		wa.error = ESRCH;</p><p>+		// How do we propagate it?</p><p>+	}</p><p>+</p><p>+	if (!nlmsg_end_dump(wa.nw, wa.error, &amp;wa.hdr)) {</p><p>+                NL_LOG(LOG_DEBUG, &#34;Unable to finalize the dump&#34;);</p><p>+                return (ENOMEM);</p><p>+        }</p><p>+</p><p>+	return (wa.error);</p><p>+}</p><p>+</p><p>+static struct nhop_object *</p><p>+finalize_nhop(struct nhop_object *nh, int *perror)</p><p>+{</p><p>+	/*</p><p>+	 * The following MUST be filled:</p><p>+	 *  nh_ifp, nh_ifa, nh_gw</p><p>+	 */</p><p>+	if (nh-&gt;gw_sa.sa_family == 0) {</p><p>+		/*</p><p>+		 * Empty gateway. Can be direct route with RTA_OIF set.</p><p>+		 */</p><p>+		if (nh-&gt;nh_ifp != NULL)</p><p>+			nhop_set_direct_gw(nh, nh-&gt;nh_ifp);</p><p>+		else {</p><p>+			NL_LOG(LOG_DEBUG, &#34;empty gateway and interface, skipping&#34;);</p><p>+			*perror = EINVAL;</p><p>+			return (NULL);</p><p>+		}</p><p>+		/* Both nh_ifp and gateway are set */</p><p>+	} else {</p><p>+		/* Gateway is set up, we can derive ifp if not set */</p><p>+		if (nh-&gt;nh_ifp == NULL) {</p><p>+			struct ifaddr *ifa = ifa_ifwithnet(&amp;nh-&gt;gw_sa, 1, nhop_get_fibnum(nh));</p><p>+			if (ifa == NULL) {</p><p>+				NL_LOG(LOG_DEBUG, &#34;Unable to determine ifp, skipping&#34;);</p><p>+				*perror = EINVAL;</p><p>+				return (NULL);</p><p>+			}</p><p>+			nhop_set_transmit_ifp(nh, ifa-&gt;ifa_ifp);</p><p>+		}</p><p>+	}</p><p>+	/* Both nh_ifp and gateway are set */</p><p>+	if (nh-&gt;nh_ifa == NULL) {</p><p>+		struct ifaddr *ifa = ifaof_ifpforaddr(&amp;nh-&gt;gw_sa, nh-&gt;nh_ifp);</p><p>+		if (ifa == NULL) {</p><p>+			NL_LOG(LOG_DEBUG, &#34;Unable to determine ifa, skipping&#34;);</p><p>+			*perror = EINVAL;</p><p>+			return (NULL);</p><p>+		}</p><p>+		nhop_set_src(nh, ifa);</p><p>+	}</p><p>+</p><p>+	return (nhop_get_nhop(nh, perror));</p><p>+}</p><p>+</p><p>+static int</p><p>+get_pxflag(const struct nl_parsed_route *attrs)</p><p>+{</p><p>+	int pxflag = 0;</p><p>+	switch (attrs-&gt;rtm_family) {</p><p>+	case AF_INET:</p><p>+		if (attrs-&gt;rtm_dst_len == 32)</p><p>+			pxflag = NHF_HOST;</p><p>+		else if (attrs-&gt;rtm_dst_len == 0)</p><p>+			pxflag = NHF_DEFAULT;</p><p>+		break;</p><p>+	case AF_INET6:</p><p>+		if (attrs-&gt;rtm_dst_len == 32)</p><p>+			pxflag = NHF_HOST;</p><p>+		else if (attrs-&gt;rtm_dst_len == 0)</p><p>+			pxflag = NHF_DEFAULT;</p><p>+		break;</p><p>+	}</p><p>+</p><p>+	return (pxflag);</p><p>+}</p><p>+</p><p>+static int</p><p>+get_op_flags(int nlm_flags)</p><p>+{</p><p>+	int op_flags = 0;</p><p>+</p><p>+	op_flags |= (nlm_flags &amp; NLM_F_REPLACE) ? RTM_F_REPLACE : 0;</p><p>+	op_flags |= (nlm_flags &amp; NLM_F_EXCL) ? RTM_F_EXCL : 0;</p><p>+	op_flags |= (nlm_flags &amp; NLM_F_CREATE) ? RTM_F_CREATE : 0;</p><p>+	op_flags |= (nlm_flags &amp; NLM_F_APPEND) ? RTM_F_APPEND : 0;</p><p>+</p><p>+	return (op_flags);</p><p>+}</p><p>+</p><p>+static int</p><p>+create_nexthop_one(struct nl_parsed_route *attrs, struct rta_mpath_nh *mpnh,</p><p>+    struct nl_pstate *npt, struct nhop_object **pnh)</p><p>+{</p><p>+	int error;</p><p>+</p><p>+	if (mpnh-&gt;gw == NULL)</p><p>+		return (EINVAL);</p><p>+</p><p>+	struct nhop_object *nh = nhop_alloc(attrs-&gt;rta_table, attrs-&gt;rtm_family);</p><p>+	if (nh == NULL)</p><p>+		return (ENOMEM);</p><p>+</p><p>+	nhop_set_gw(nh, mpnh-&gt;gw, true);</p><p>+	if (mpnh-&gt;ifp != NULL)</p><p>+		nhop_set_transmit_ifp(nh, mpnh-&gt;ifp);</p><p>+	nhop_set_rtflags(nh, attrs-&gt;rta_rtflags);</p><p>+</p><p>+	*pnh = finalize_nhop(nh, &amp;error);</p><p>+</p><p>+	return (error);</p><p>+}</p><p>+</p><p>+static struct nhop_object *</p><p>+create_nexthop_from_attrs(struct nl_parsed_route *attrs,</p><p>+    struct nl_pstate *npt, int *perror)</p><p>+{</p><p>+	struct nhop_object *nh;</p><p>+	int error = 0;</p><p>+</p><p>+	if (attrs-&gt;rta_multipath != NULL) {</p><p>+		/* Multipath w/o explicit nexthops */</p><p>+		int num_nhops = attrs-&gt;rta_multipath-&gt;num_nhops;</p><p>+		struct weightened_nhop *wn = npt_alloc(npt, sizeof(*wn) * num_nhops);</p><p>+		nh = NULL;</p><p>+</p><p>+		for (int i = 0; i &lt; num_nhops; i++) {</p><p>+			struct rta_mpath_nh *mpnh = &amp;attrs-&gt;rta_multipath-&gt;nhops[i];</p><p>+</p><p>+			error = create_nexthop_one(attrs, mpnh, npt, &amp;wn[i].nh);</p><p>+			if (error != 0) {</p><p>+				for (int j = 0; j &lt; i; j++)</p><p>+					nhop_free(wn[j].nh);</p><p>+				break;</p><p>+			}</p><p>+			wn[i].weight = mpnh-&gt;rtnh_weight &gt; 0 ? mpnh-&gt;rtnh_weight : 1;</p><p>+		}</p><p>+		if (error == 0) {</p><p>+			struct rib_head *rh = nhop_get_rh(wn[0].nh);</p><p>+</p><p>+			error = nhgrp_get_group(rh, wn, num_nhops, 0,</p><p>+			    (struct nhgrp_object **)&amp;nh);</p><p>+</p><p>+			for (int i = 0; i &lt; num_nhops; i++)</p><p>+				nhop_free(wn[i].nh);</p><p>+		}</p><p>+		*perror = error;</p><p>+	} else {</p><p>+		nh = nhop_alloc(attrs-&gt;rta_table, attrs-&gt;rtm_family);</p><p>+		if (nh == NULL) {</p><p>+			*perror = ENOMEM;</p><p>+			return (NULL);</p><p>+		}</p><p>+		if (attrs-&gt;rta_gw != NULL)</p><p>+			nhop_set_gw(nh, attrs-&gt;rta_gw, true);</p><p>+		if (attrs-&gt;rta_oif != NULL)</p><p>+			nhop_set_transmit_ifp(nh, attrs-&gt;rta_oif);</p><p>+		if (attrs-&gt;rtax_mtu != 0)</p><p>+			nhop_set_mtu(nh, attrs-&gt;rtax_mtu, true);</p><p>+		if (attrs-&gt;rta_rtflags &amp; RTF_BROADCAST)</p><p>+			nhop_set_broadcast(nh, true);</p><p>+		if (attrs-&gt;rta_rtflags &amp; RTF_BLACKHOLE)</p><p>+			nhop_set_blackhole(nh, NHF_BLACKHOLE);</p><p>+		if (attrs-&gt;rta_rtflags &amp; RTF_REJECT)</p><p>+			nhop_set_blackhole(nh, NHF_REJECT);</p><p>+		nhop_set_rtflags(nh, attrs-&gt;rta_rtflags);</p><p>+		nh = finalize_nhop(nh, perror);</p><p>+	}</p><p>+</p><p>+	return (nh);</p><p>+}</p><p>+</p><p>+static int</p><p>+rtnl_handle_newroute(struct nlmsghdr *hdr, struct nlpcb *nlp,</p><p>+    struct nl_pstate *npt)</p><p>+{</p><p>+	struct rib_cmd_info rc = {};</p><p>+	struct nhop_object *nh = NULL;</p><p>+	int error;</p><p>+</p><p>+	struct nl_parsed_route attrs = {};</p><p>+	error = nl_parse_nlmsg(hdr, &amp;rtm_parser, npt, &amp;attrs);</p><p>+	if (error != 0)</p><p>+		return (error);</p><p>+</p><p>+	/* Check if we have enough data */</p><p>+	if (attrs.rta_dst == NULL) {</p><p>+		NL_LOG(LOG_DEBUG, &#34;missing RTA_DST&#34;);</p><p>+		return (EINVAL);</p><p>+	}</p><p>+</p><p>+	if (attrs.rta_nh_id != 0) {</p><p>+		/* Referenced uindex */</p><p>+		int pxflag = get_pxflag(&amp;attrs);</p><p>+		nh = nl_find_nhop(attrs.rta_table, attrs.rtm_family, attrs.rta_nh_id,</p><p>+		    pxflag, &amp;error);</p><p>+		if (error != 0)</p><p>+			return (error);</p><p>+	} else {</p><p>+		nh = create_nexthop_from_attrs(&amp;attrs, npt, &amp;error);</p><p>+		if (error != 0) {</p><p>+			NL_LOG(LOG_DEBUG, &#34;Error creating nexthop&#34;);</p><p>+			return (error);</p><p>+		}</p><p>+	}</p><p>+</p><p>+	int weight = NH_IS_NHGRP(nh) ? 0 : RT_DEFAULT_WEIGHT;</p><p>+	struct route_nhop_data rnd = { .rnd_nhop = nh, .rnd_weight = weight };</p><p>+	int op_flags = get_op_flags(hdr-&gt;nlmsg_flags);</p><p>+</p><p>+	error = rib_add_route_px(attrs.rta_table, attrs.rta_dst, attrs.rtm_dst_len,</p><p>+	    &amp;rnd, op_flags, &amp;rc);</p><p>+	if (error == 0)</p><p>+		report_operation(attrs.rta_table, &amp;rc, nlp, hdr);</p><p>+	return (error);</p><p>+}</p><p>+</p><p>+static int</p><p>+path_match_func(const struct rtentry *rt, const struct nhop_object *nh, void *_data)</p><p>+{</p><p>+	struct nl_parsed_route *attrs = (struct nl_parsed_route *)_data;</p><p>+</p><p>+	if ((attrs-&gt;rta_gw != NULL) &amp;&amp; !rib_match_gw(rt, nh, attrs-&gt;rta_gw))</p><p>+		return (0);</p><p>+</p><p>+	if ((attrs-&gt;rta_oif != NULL) &amp;&amp; (attrs-&gt;rta_oif != nh-&gt;nh_ifp))</p><p>+		return (0);</p><p>+</p><p>+	return (1);</p><p>+}</p><p>+</p><p>+static int</p><p>+rtnl_handle_delroute(struct nlmsghdr *hdr, struct nlpcb *nlp,</p><p>+    struct nl_pstate *npt)</p><p>+{</p><p>+	struct rib_cmd_info rc;</p><p>+	int error;</p><p>+</p><p>+	struct nl_parsed_route attrs = {};</p><p>+	error = nl_parse_nlmsg(hdr, &amp;rtm_parser, npt, &amp;attrs);</p><p>+	if (error != 0)</p><p>+		return (error);</p><p>+</p><p>+	if (attrs.rta_dst == NULL) {</p><p>+		NLMSG_REPORT_ERR_MSG(npt, &#34;RTA_DST is not set&#34;);</p><p>+		return (ESRCH);</p><p>+	}</p><p>+</p><p>+	error = rib_del_route_px(attrs.rta_table, attrs.rta_dst,</p><p>+	    attrs.rtm_dst_len, path_match_func, &amp;attrs, 0, &amp;rc);</p><p>+	if (error == 0)</p><p>+		report_operation(attrs.rta_table, &amp;rc, nlp, hdr);</p><p>+	return (error);</p><p>+}</p><p>+</p><p>+static int</p><p>+rtnl_handle_getroute(struct nlmsghdr *hdr, struct nlpcb *nlp, struct nl_pstate *npt)</p><p>+{</p><p>+	int error;</p><p>+</p><p>+	struct nl_parsed_route attrs = {};</p><p>+	error = nl_parse_nlmsg(hdr, &amp;rtm_parser, npt, &amp;attrs);</p><p>+	if (error != 0)</p><p>+		return (error);</p><p>+</p><p>+	if (hdr-&gt;nlmsg_flags &amp; NLM_F_DUMP)</p><p>+		error = handle_rtm_dump(nlp, attrs.rta_table, attrs.rtm_family, hdr, npt-&gt;nw);</p><p>+	else</p><p>+		error = handle_rtm_getroute(nlp, &amp;attrs, hdr, npt);</p><p>+</p><p>+	return (error);</p><p>+}</p><p>+</p><p>+void</p><p>+rtnl_handle_route_event(uint32_t fibnum, const struct rib_cmd_info *rc)</p><p>+{</p><p>+	int family, nlm_flags = 0;</p><p>+</p><p>+	struct nl_writer nw;</p><p>+</p><p>+	family = rt_get_family(rc-&gt;rc_rt);</p><p>+</p><p>+	/* XXX: check if there are active listeners first */</p><p>+</p><p>+	/* TODO: consider passing PID/type/seq */</p><p>+	switch (rc-&gt;rc_cmd) {</p><p>+	case RTM_ADD:</p><p>+		nlm_flags = NLM_F_EXCL | NLM_F_CREATE;</p><p>+		break;</p><p>+	case RTM_CHANGE:</p><p>+		nlm_flags = NLM_F_REPLACE;</p><p>+		break;</p><p>+	case RTM_DELETE:</p><p>+		nlm_flags = 0;</p><p>+		break;</p><p>+	}</p><p>+	IF_DEBUG_LEVEL(LOG_DEBUG2) {</p><p>+		char rtbuf[NHOP_PRINT_BUFSIZE] __unused;</p><p>+		FIB_LOG(LOG_DEBUG2, fibnum, family,</p><p>+		    &#34;received event %s for %s / nlm_flags=%X&#34;,</p><p>+		    rib_print_cmd(rc-&gt;rc_cmd),</p><p>+		    rt_print_buf(rc-&gt;rc_rt, rtbuf, sizeof(rtbuf)),</p><p>+		    nlm_flags);</p><p>+	}</p><p>+</p><p>+	struct nlmsghdr hdr = {</p><p>+		.nlmsg_flags = nlm_flags,</p><p>+		.nlmsg_type = get_rtmsg_type_from_rtsock(rc-&gt;rc_cmd),</p><p>+	};</p><p>+</p><p>+	struct route_nhop_data rnd = {</p><p>+		.rnd_nhop = rc_get_nhop(rc),</p><p>+		.rnd_weight = rc-&gt;rc_nh_weight,</p><p>+	};</p><p>+</p><p>+	uint32_t group_id = family_to_group(family);</p><p>+	if (!nlmsg_get_group_writer(&amp;nw, NLMSG_SMALL, NETLINK_ROUTE, group_id)) {</p><p>+		NL_LOG(LOG_DEBUG, &#34;error allocating event buffer&#34;);</p><p>+		return;</p><p>+	}</p><p>+</p><p>+	dump_px(fibnum, &amp;hdr, rc-&gt;rc_rt, &amp;rnd, &amp;nw);</p><p>+	nlmsg_flush(&amp;nw);</p><p>+}</p><p>+</p><p>+static const struct rtnl_cmd_handler cmd_handlers[] = {</p><p>+	{</p><p>+		.cmd = NL_RTM_GETROUTE,</p><p>+		.name = &#34;RTM_GETROUTE&#34;,</p><p>+		.cb = &amp;rtnl_handle_getroute,</p><p>+	},</p><p>+	{</p><p>+		.cmd = NL_RTM_DELROUTE,</p><p>+		.name = &#34;RTM_DELROUTE&#34;,</p><p>+		.cb = &amp;rtnl_handle_delroute,</p><p>+		.priv = PRIV_NET_ROUTE,</p><p>+	},</p><p>+	{</p><p>+		.cmd = NL_RTM_NEWROUTE,</p><p>+		.name = &#34;RTM_NEWROUTE&#34;,</p><p>+		.cb = &amp;rtnl_handle_newroute,</p><p>+		.priv = PRIV_NET_ROUTE,</p><p>+	}</p><p>+};</p><p>+</p><p>+static const struct nlhdr_parser *all_parsers[] = {&amp;mpath_parser, &amp;metrics_parser, &amp;rtm_parser};</p><p>+</p><p>+void</p><p>+rtnl_routes_init()</p><p>+{</p><p>+	NL_VERIFY_PARSERS(all_parsers);</p><p>+	rtnl_register_messages(cmd_handlers, NL_ARRAY_LEN(cmd_handlers));</p><p>+}</p><div><p>diff --git a/sys/netlink/route/route.h b/sys/netlink/route/route.h</p></div><p>@@ -0,0 +1,366 @@</p><p>+/*-</p><p>+ * SPDX-License-Identifier: BSD-2-Clause-FreeBSD</p><p>+ *</p><p>+ * Copyright (c) 2022 Alexander V. Chernikov &lt;melifaro@FreeBSD.org&gt;</p><p>+ *</p><p>+ * Redistribution and use in source and binary forms, with or without</p><p>+ * modification, are permitted provided that the following conditions</p><p>+ * are met:</p><p>+ * 1. Redistributions of source code must retain the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer.</p><p>+ * 2. Redistributions in binary form must reproduce the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer in the</p><p>+ *    documentation and/or other materials provided with the distribution.</p><p>+ *</p><p>+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&#39;&#39; AND</p><p>+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</p><p>+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</p><p>+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE</p><p>+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</p><p>+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</p><p>+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</p><p>+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</p><p>+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</p><p>+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</p><p>+ * SUCH DAMAGE.</p><p>+ */</p><p>+</p><p>+/*</p><p>+ * Route-related (RTM_&lt;NEW|DEL|GET&gt;ROUTE) message header and attributes.</p><p>+ */</p><p>+</p><p>+#ifndef _NETLINK_ROUTE_ROUTE_H_</p><p>+#define _NETLINK_ROUTE_ROUTE_H_</p><p>+</p><p>+/* Base header for all of the relevant messages */</p><p>+struct rtmsg {</p><p>+	unsigned char	rtm_family;	/* address family */</p><p>+	unsigned char	rtm_dst_len;	/* Prefix length */</p><p>+	unsigned char	rtm_src_len;	/* Source prefix length (not used) */</p><p>+	unsigned char	rtm_tos;	/* Type of service (not used) */</p><p>+	unsigned char	rtm_table;	/* rtable id */</p><p>+	unsigned char	rtm_protocol;	/* Routing protocol id (RTPROT_) */</p><p>+	unsigned char	rtm_scope;	/* Route distance (RT_SCOPE_) */</p><p>+	unsigned char	rtm_type;	/* Route type (RTN_) */</p><p>+	unsigned 	rtm_flags;	/* Route flags (RTM_F_) */</p><p>+};</p><p>+</p><p>+/*</p><p>+ * RFC 3549, 3.1.1, route type (rtm_type field).</p><p>+ */</p><p>+enum {</p><p>+	RTN_UNSPEC,</p><p>+	RTN_UNICAST,		/* Unicast route */</p><p>+	RTN_LOCAL,		/* Accept locally (not supported) */</p><p>+	RTN_BROADCAST,		/* Accept locally as broadcast, send as broadcast */</p><p>+	RTN_ANYCAST,		/* Accept locally as broadcast, but send as unicast */</p><p>+	RTN_MULTICAST,		/* Multicast route */</p><p>+	RTN_BLACKHOLE,		/* Drop traffic towards destination */</p><p>+	RTN_UNREACHABLE,	/* Destination is unreachable */</p><p>+	RTN_PROHIBIT,		/* Administratively prohibited */</p><p>+	RTN_THROW,		/* Not in this table (not supported) */</p><p>+	RTN_NAT,		/* Translate this address (not supported) */</p><p>+	RTN_XRESOLVE,		/* Use external resolver (not supported) */</p><p>+	__RTN_MAX,</p><p>+};</p><p>+#define RTN_MAX (__RTN_MAX - 1)</p><p>+</p><p>+/*</p><p>+ * RFC 3549, 3.1.1, protocol (Identifies what/who added the route).</p><p>+ * Values larger than RTPROT_STATIC(4) are not interpreted by the</p><p>+ * kernel, they are just for user information.</p><p>+ */</p><p>+#define	RTPROT_UNSPEC		0</p><p>+#define RTPROT_REDIRECT		1 /* Route installed by ICMP redirect */</p><p>+#define RTPROT_KERNEL		2 /* Route installed by kernel */</p><p>+#define RTPROT_BOOT		3 /* Route installed during boot */</p><p>+#define RTPROT_STATIC		4 /* Route installed by administrator */</p><p>+</p><p>+#define	RTPROT_GATED		8</p><p>+#define RTPROT_RA		9</p><p>+#define RTPROT_MRT		1</p><p>+#define RTPROT_ZEBRA		11</p><p>+#define RTPROT_BIRD		12</p><p>+#define RTPROT_DNROUTED		13</p><p>+#define RTPROT_XORP		14</p><p>+#define RTPROT_NTK		15</p><p>+#define RTPROT_DHCP		16</p><p>+#define RTPROT_MROUTED		17</p><p>+#define RTPROT_KEEPALIVED	18</p><p>+#define RTPROT_BABEL		42</p><p>+#define RTPROT_OPENR		99</p><p>+#define RTPROT_BGP		186</p><p>+#define RTPROT_ISIS		187</p><p>+#define RTPROT_OSPF		188</p><p>+#define RTPROT_RIP		189</p><p>+#define RTPROT_EIGRP		192</p><p>+</p><p>+/*</p><p>+ * RFC 3549 3.1.1 Route scope (valid distance to destination).</p><p>+ *</p><p>+ * The values between RT_SCOPE_UNIVERSE(0) and RT_SCOPE_SITE(200)</p><p>+ *  are available to the user.</p><p>+ */</p><p>+enum rt_scope_t {</p><p>+	RT_SCOPE_UNIVERSE = 0,</p><p>+	/* User defined values  */</p><p>+	RT_SCOPE_SITE = 200,</p><p>+	RT_SCOPE_LINK = 253,</p><p>+	RT_SCOPE_HOST = 254,</p><p>+	RT_SCOPE_NOWHERE = 255</p><p>+};</p><p>+</p><p>+/*</p><p>+ * RFC 3549 3.1.1 Route flags (rtm_flags).</p><p>+ * Is a composition of RTNH_F flags (0x1..0x40 range), RTM_F flags (below)</p><p>+ * and per-protocol (IPv4/IPv6) flags.</p><p>+ */</p><p>+#define RTM_F_NOTIFY		0x00000100 /* not supported */</p><p>+#define RTM_F_CLONED		0x00000200 /* not supported */</p><p>+#define RTM_F_EQUALIZE		0x00000400 /* not supported */</p><p>+#define RTM_F_PREFIX		0x00000800 /* not supported */</p><p>+#define RTM_F_LOOKUP_TABLE	0x00001000 /* not supported */</p><p>+#define RTM_F_FIB_MATCH		0x00002000 /* not supported */</p><p>+#define RTM_F_OFFLOAD		0x00004000 /* not supported */</p><p>+#define RTM_F_TRAP		0x00008000 /* not supported */</p><p>+#define RTM_F_OFFLOAD_FAILED	0x20000000 /* not supported */</p><p>+</p><p>+/* Compatibility handling helpers */</p><p>+#ifndef _KERNEL</p><p>+#define	NL_RTM_HDRLEN		((int)sizeof(struct rtmsg))</p><p>+#define	RTM_RTA(_rtm)		((struct rtattr *)((char *)(_rtm) + NL_RTM_HDRLEN))</p><p>+#define	RTM_PAYLOAD(_hdr)	NLMSG_PAYLOAD((_hdr), NL_RTM_HDRLEN)</p><p>+#endif</p><p>+</p><p>+/*</p><p>+ * Routing table identifiers.</p><p>+ * FreeBSD route table numbering starts from 0, where 0 is a valid default routing table.</p><p>+ * Indicating &#34;all tables&#34; via netlink can be done by not including RTA_TABLE attribute</p><p>+ * and keeping rtm_table=0 (compatibility) or setting RTA_TABLE value to RT_TABLE_UNSPEC.</p><p>+ */</p><p>+#define	RT_TABLE_MAIN	0		/* RT_DEFAULT_FIB */</p><p>+#define	RT_TABLE_UNSPEC	0xFFFFFFFF	/* RT_ALL_FIBS */</p><p>+</p><p>+enum rtattr_type_t {</p><p>+	NL_RTA_UNSPEC,</p><p>+	NL_RTA_DST		= 1, /* binary, IPv4/IPv6 destination */</p><p>+	NL_RTA_SRC		= 2, /* binary, preferred source address */</p><p>+	NL_RTA_IIF		= 3, /* not supported */</p><p>+	NL_RTA_OIF		= 4, /* u32, transmit ifindex */</p><p>+	NL_RTA_GATEWAY		= 5, /* binary: IPv4/IPv6 gateway */</p><p>+	NL_RTA_PRIORITY		= 6, /* not supported */</p><p>+	NL_RTA_PREFSRC		= 7, /* not supported */</p><p>+	NL_RTA_METRICS		= 8, /* nested, list of NL_RTAX* attrs */</p><p>+	NL_RTA_MULTIPATH	= 9, /* binary, array of struct rtnexthop */</p><p>+	NL_RTA_PROTOINFO	= 10, /* not supported / deprecated */</p><p>+	NL_RTA_KNH_ID		= 10, /* u32, FreeBSD specific, kernel nexthop index */</p><p>+	NL_RTA_FLOW		= 11, /* not supported */</p><p>+	NL_RTA_CACHEINFO	= 12, /* not supported */</p><p>+	NL_RTA_SESSION		= 13, /* not supported / deprecated */</p><p>+	NL_RTA_MP_ALGO		= 14, /* not supported / deprecated */</p><p>+	NL_RTA_RTFLAGS		= 14, /* u32, FreeBSD specific, */</p><p>+	NL_RTA_TABLE		= 15, /* u32, fibnum */</p><p>+	NL_RTA_MARK		= 16, /* not supported */</p><p>+	NL_RTA_MFC_STATS	= 17, /* not supported */</p><p>+	NL_RTA_VIA		= 18, /* binary, struct rtvia */</p><p>+	NL_RTA_NEWDST		= 19, /* not supported */</p><p>+	NL_RTA_PREF		= 20, /* not supported */</p><p>+	NL_RTA_ENCAP_TYPE	= 21, /* not supported */</p><p>+	NL_RTA_ENCAP		= 22, /* not supported */</p><p>+	NL_RTA_EXPIRES		= 23, /* u32, seconds till expiration */</p><p>+	NL_RTA_PAD		= 24, /* not supported */</p><p>+	NL_RTA_UID		= 25, /* not supported */</p><p>+	NL_RTA_TTL_PROPAGATE	= 26, /* not supported */</p><p>+	NL_RTA_IP_PROTO		= 27, /* not supported */</p><p>+	NL_RTA_SPORT		= 28, /* not supported */</p><p>+	NL_RTA_DPORT		= 29, /* not supported */</p><p>+	NL_RTA_NH_ID		= 30, /* u32, nexthop/nexthop group index */</p><p>+	__RTA_MAX</p><p>+};</p><p>+#define NL_RTA_MAX (__RTA_MAX - 1)</p><p>+</p><p>+/*</p><p>+ * Attributes that can be used as filters:</p><p>+ *</p><p>+ */</p><p>+</p><p>+#ifndef _KERNEL</p><p>+/*</p><p>+ * RTA_* space has clashes with rtsock namespace.</p><p>+ * Use NL_RTA_ prefix in the kernel and map to</p><p>+ * RTA_ for userland.</p><p>+ */</p><p>+#define RTA_UNSPEC		NL_RTA_UNSPEC</p><p>+#define RTA_DST			NL_RTA_DST</p><p>+#define RTA_SRC			NL_RTA_SRC</p><p>+#define RTA_IIF			NL_RTA_IIF</p><p>+#define RTA_OIF			NL_RTA_OIF</p><p>+#define RTA_GATEWAY		NL_RTA_GATEWAY</p><p>+#define RTA_PRIORITY		NL_RTA_PRIORITY</p><p>+#define RTA_PREFSRC		NL_RTA_PREFSRC</p><p>+#define RTA_METRICS		NL_RTA_METRICS</p><p>+#define RTA_MULTIPATH		NL_RTA_MULTIPATH</p><p>+#define	RTA_PROTOINFO		NL_RTA_PROTOINFO</p><p>+#define	RTA_KNH_ID		NL_RTA_KNH_ID</p><p>+#define RTA_FLOW		NL_RTA_FLOW</p><p>+#define RTA_CACHEINFO		NL_RTA_CACHEINFO</p><p>+#define	RTA_SESSION		NL_RTA_SESSION</p><p>+#define	RTA_MP_ALGO		NL_RTA_MP_ALGO</p><p>+#define RTA_TABLE		NL_RTA_TABLE</p><p>+#define RTA_MARK		NL_RTA_MARK</p><p>+#define RTA_MFC_STATS		NL_RTA_MFC_STATS</p><p>+#define RTA_VIA			NL_RTA_VIA</p><p>+#define RTA_NEWDST		NL_RTA_NEWDST</p><p>+#define RTA_PREF		NL_RTA_PREF</p><p>+#define RTA_ENCAP_TYPE		NL_RTA_ENCAP_TYPE</p><p>+#define RTA_ENCAP		NL_RTA_ENCAP</p><p>+#define RTA_EXPIRES		NL_RTA_EXPIRES</p><p>+#define RTA_PAD			NL_RTA_PAD</p><p>+#define RTA_UID			NL_RTA_UID</p><p>+#define RTA_TTL_PROPAGATE	NL_RTA_TTL_PROPAGATE</p><p>+#define RTA_IP_PROTO		NL_RTA_IP_PROTO</p><p>+#define RTA_SPORT		NL_RTA_SPORT</p><p>+#define RTA_DPORT		NL_RTA_DPORT</p><p>+#define RTA_NH_ID		NL_RTA_NH_ID</p><p>+#define	RTA_MAX			NL_RTA_MAX</p><p>+#endif</p><p>+</p><p>+/* route attribute header */</p><p>+struct rtattr {</p><p>+	unsigned short rta_len;</p><p>+	unsigned short rta_type;</p><p>+};</p><p>+</p><p>+#define	NL_RTA_ALIGN_SIZE	NL_ITEM_ALIGN_SIZE</p><p>+#define	NL_RTA_ALIGN		NL_ITEM_ALIGN</p><p>+#define	NL_RTA_HDRLEN		((int)sizeof(struct rtattr))</p><p>+#define	NL_RTA_DATA_LEN(_rta)	((int)((_rta)-&gt;rta_len - NL_RTA_HDRLEN))</p><p>+#define	NL_RTA_DATA(_rta)	NL_ITEM_DATA(_rta, NL_RTA_HDRLEN)</p><p>+#define	NL_RTA_DATA_CONST(_rta)	NL_ITEM_DATA_CONST(_rta, NL_RTA_HDRLEN)</p><p>+</p><p>+/* Compatibility attribute handling helpers */</p><p>+#ifndef _KERNEL</p><p>+#define	RTA_ALIGNTO		NL_RTA_ALIGN_SIZE</p><p>+#define	RTA_ALIGN(_len)		NL_RTA_ALIGN(_len)</p><p>+#define	_RTA_LEN(_rta)		((int)(_rta)-&gt;rta_len)</p><p>+#define	_RTA_ALIGNED_LEN(_rta)	RTA_ALIGN(_RTA_LEN(_rta))</p><p>+#define	RTA_OK(_rta, _len)	NL_ITEM_OK(_rta, _len, NL_RTA_HDRLEN, _RTA_LEN)</p><p>+#define	RTA_NEXT(_rta, _len)	NL_ITEM_ITER(_rta, _len, _RTA_ALIGNED_LEN)</p><p>+#define	RTA_LENGTH(_len)	(NL_RTA_HDRLEN + (_len))</p><p>+#define	RTA_SPACE(_len)		RTA_ALIGN(RTA_LENGTH(_len))</p><p>+#define	RTA_DATA(_rta)		NL_RTA_DATA(_rta)</p><p>+#define	RTA_PAYLOAD(_rta)	((int)(_RTA_LEN(_rta) - NL_RTA_HDRLEN))</p><p>+#endif</p><p>+</p><p>+/* RTA attribute headers */</p><p>+</p><p>+/* RTA_VIA */</p><p>+struct rtvia {</p><p>+	sa_family_t	rtvia_family;</p><p>+	uint8_t		rtvia_addr[0];</p><p>+};</p><p>+</p><p>+/*</p><p>+ * RTA_METRICS is a nested attribute, consisting of a list of</p><p>+ * TLVs with types defined below.</p><p>+ */</p><p>+ enum {</p><p>+	NL_RTAX_UNSPEC,</p><p>+	NL_RTAX_LOCK			= 1, /* not supported */</p><p>+	NL_RTAX_MTU			= 2, /* desired path MTU */</p><p>+	NL_RTAX_WINDOW			= 3, /* not supported */</p><p>+	NL_RTAX_RTT			= 4, /* not supported */</p><p>+	NL_RTAX_RTTVAR			= 5, /* not supported */</p><p>+	NL_RTAX_SSTHRESH		= 6, /* not supported */</p><p>+	NL_RTAX_CWND			= 7, /* not supported */</p><p>+	NL_RTAX_ADVMSS			= 8, /* not supported  */</p><p>+	NL_RTAX_REORDERING		= 9, /* not supported */</p><p>+	NL_RTAX_HOPLIMIT		= 10, /* not supported */</p><p>+	NL_RTAX_INITCWND		= 11, /* not supporrted */</p><p>+	NL_RTAX_FEATURES		= 12, /* not supported */</p><p>+	NL_RTAX_RTO_MIN			= 13, /* not supported */</p><p>+	NL_RTAX_INITRWND		= 14, /* not supported */</p><p>+	NL_RTAX_QUICKACK		= 15, /* not supported */</p><p>+	NL_RTAX_CC_ALGO			= 15, /* not supported */</p><p>+	NL_RTAX_FASTOPEN_NO_COOKIE	= 16, /* not supported */</p><p>+	__NL_RTAX_MAX</p><p>+};</p><p>+#define NL_RTAX_MAX (__NL_RTAX_MAX - 1)</p><p>+</p><p>+#define RTAX_FEATURE_ECN (1 &lt;&lt; 0)</p><p>+#define RTAX_FEATURE_SACK (1 &lt;&lt; 1)</p><p>+#define RTAX_FEATURE_TIMESTAMP (1 &lt;&lt; 2)</p><p>+#define RTAX_FEATURE_ALLFRAG (1 &lt;&lt; 3)</p><p>+</p><p>+#define RTAX_FEATURE_MASK                                                \</p><p>+	(RTAX_FEATURE_ECN | RTAX_FEATURE_SACK | RTAX_FEATURE_TIMESTAMP | \</p><p>+	    RTAX_FEATURE_ALLFRAG)</p><p>+</p><p>+#ifndef _KERNEL</p><p>+</p><p>+/*</p><p>+ * RTAX_* space clashes with rtsock namespace.</p><p>+ * Use NL_RTAX_ prefix in the kernel and map to</p><p>+ * RTAX_ for userland.</p><p>+ */</p><p>+#define RTAX_UNSPEC		NL_RTAX_UNSPEC</p><p>+#define RTAX_LOCK		NL_RTAX_LOCK</p><p>+#define RTAX_MTU		NL_RTAX_MTU</p><p>+#define RTAX_WINDOW		NL_RTAX_WINDOW</p><p>+#define RTAX_RTT		NL_RTAX_RTT</p><p>+#define RTAX_RTTVAR		NL_RTAX_RTTVAR</p><p>+#define RTAX_SSTHRESH		NL_RTAX_SSTHRESH</p><p>+#define RTAX_CWND		NL_RTAX_CWND</p><p>+#define RTAX_ADVMSS		NL_RTAX_ADVMSS</p><p>+#define RTAX_REORDERING		NL_RTAX_REORDERING</p><p>+#define RTAX_HOPLIMIT		NL_RTAX_HOPLIMIT</p><p>+#define RTAX_INITCWND		NL_RTAX_INITCWND</p><p>+#define RTAX_FEATURES		NL_RTAX_FEATURES</p><p>+#define RTAX_RTO_MIN		NL_RTAX_RTO_MIN</p><p>+#define RTAX_INITRWND		NL_RTAX_INITRWND</p><p>+#define RTAX_QUICKACK		NL_RTAX_QUICKACK</p><p>+#define RTAX_CC_ALGO		NL_RTAX_CC_ALGO</p><p>+#define RTAX_FASTOPEN_NO_COOKIE	NL_RTAX_FASTOPEN_NO_COOKIE</p><p>+#endif</p><p>+</p><p>+/*</p><p>+ * RTA_MULTIPATH consists of an array of rtnexthop structures.</p><p>+ * Each rtnexthop structure contains RTA_GATEWAY or RTA_VIA</p><p>+ * attribute following the header.</p><p>+ */</p><p>+struct rtnexthop {</p><p>+	unsigned short		rtnh_len;</p><p>+	unsigned char		rtnh_flags;</p><p>+	unsigned char		rtnh_hops;	/* nexthop weight */</p><p>+	int			rtnh_ifindex;</p><p>+};</p><p>+</p><p>+/* rtnh_flags */</p><p>+#define RTNH_F_DEAD		0x01	/* not supported */</p><p>+#define RTNH_F_PERVASIVE	0x02	/* not supported */</p><p>+#define RTNH_F_ONLINK		0x04	/* not supported */</p><p>+#define RTNH_F_OFFLOAD		0x08	/* not supported */</p><p>+#define RTNH_F_LINKDOWN		0x10	/* not supported */</p><p>+#define RTNH_F_UNRESOLVED	0x20	/* not supported */</p><p>+#define RTNH_F_TRAP		0x40	/* not supported */</p><p>+</p><p>+#define RTNH_COMPARE_MASK	(RTNH_F_DEAD | RTNH_F_LINKDOWN | \</p><p>+				 RTNH_F_OFFLOAD | RTNH_F_TRAP)</p><p>+</p><p>+/* Macros to handle hexthops */</p><p>+#define	RTNH_ALIGNTO		NL_ITEM_ALIGN_SIZE</p><p>+#define	RTNH_ALIGN(_len)	NL_ITEM_ALIGN(_len)</p><p>+#define	RTNH_HDRLEN		((int)sizeof(struct rtnexthop))</p><p>+#define	_RTNH_LEN(_nh)		((int)(_nh)-&gt;rtnh_len)</p><p>+#define	_RTNH_ALIGNED_LEN(_nh)	RTNH_ALIGN(_RTNH_LEN(_nh))</p><p>+#define	RTNH_OK(_nh, _len)	NL_ITEM_OK(_nh, _len, RTNH_HDRLEN, _RTNH_LEN)</p><p>+#define	RTNH_NEXT(_nh)		((struct rtnexthop *)((char *)(_nh) + _RTNH_ALIGNED_LEN(_nh)))</p><p>+#define	RTNH_LENGTH(_len)	(RTNH_HDRLEN + (_len))</p><p>+#define	RTNH_SPACE(_len)	RTNH_ALIGN(RTNH_LENGTH(_len))</p><p>+#define	RTNH_DATA(_nh)		((struct rtattr *)NL_ITEM_DATA(_nh, RTNH_HDRLEN))</p><p>+</p><p>+struct rtgenmsg {</p><p>+	unsigned char rtgen_family;</p><p>+};</p><p>+</p><p>+#endif</p><div><p>diff --git a/sys/netlink/route/route_var.h b/sys/netlink/route/route_var.h</p></div><p>@@ -0,0 +1,101 @@</p><p>+/*-</p><p>+ * SPDX-License-Identifier: BSD-2-Clause-FreeBSD</p><p>+ *</p><p>+ * Copyright (c) 2022 Alexander V. Chernikov &lt;melifaro@FreeBSD.org&gt;</p><p>+ *</p><p>+ * Redistribution and use in source and binary forms, with or without</p><p>+ * modification, are permitted provided that the following conditions</p><p>+ * are met:</p><p>+ * 1. Redistributions of source code must retain the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer.</p><p>+ * 2. Redistributions in binary form must reproduce the above copyright</p><p>+ *    notice, this list of conditions and the following disclaimer in the</p><p>+ *    documentation and/or other materials provided with the distribution.</p><p>+ *</p><p>+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&#39;&#39; AND</p><p>+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</p><p>+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</p><p>+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE</p><p>+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</p><p>+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</p><p>+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</p><p>+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</p><p>+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</p><p>+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</p><p>+ * SUCH DAMAGE.</p><p>+ */</p><p>+</p><p>+/*</p><p>+ * This file contains definitions shared among NETLINK_ROUTE family</p><p>+ */</p><p>+#ifndef _NETLINK_ROUTE_ROUTE_VAR_H_</p><p>+#define _NETLINK_ROUTE_ROUTE_VAR_H_</p><p>+</p><p>+#include &lt;sys/priv.h&gt; /* values for priv_check */</p><p>+</p><p>+struct nlmsghdr;</p><p>+struct nlpcb;</p><p>+struct nl_pstate;</p><p>+</p><p>+typedef int rtnl_msg_cb_f(struct nlmsghdr *hdr, struct nlpcb *nlp,</p><p>+    struct nl_pstate *npt);</p><p>+</p><p>+struct rtnl_cmd_handler {</p><p>+	int		cmd;</p><p>+	const char	*name;</p><p>+	rtnl_msg_cb_f	*cb;</p><p>+	int		priv;</p><p>+	int		flags;</p><p>+};</p><p>+</p><p>+#define	RTNL_F_NOEPOCH	0x01</p><p>+</p><p>+bool rtnl_register_messages(const struct rtnl_cmd_handler *handlers, int count);</p><p>+</p><p>+/* route.c */</p><p>+struct rib_cmd_info;</p><p>+void rtnl_handle_route_event(uint32_t fibnum, const struct rib_cmd_info *rc);</p><p>+void rtnl_routes_init(void);</p><p>+</p><p>+/* neigh.c */</p><p>+void rtnl_neighs_init(void);</p><p>+void rtnl_neighs_destroy(void);</p><p>+</p><p>+/* iface.c */</p><p>+struct nl_parsed_link {</p><p>+	char		*ifla_group;</p><p>+	char		*ifla_ifname;</p><p>+	char		*ifla_cloner;</p><p>+	struct nlattr	*ifla_idata;</p><p>+	unsigned short	ifi_type;</p><p>+	int		ifi_index;</p><p>+	uint32_t	ifla_mtu;</p><p>+};</p><p>+</p><p>+typedef int rtnl_iface_create_f(struct nl_parsed_link *lattrs, struct nlpcb *nlp,</p><p>+    struct nl_pstate *npt);</p><p>+typedef int rtnl_iface_modify_f(struct nl_parsed_link *lattrs, struct nlpcb *nlp,</p><p>+    struct nl_pstate *npt);</p><p>+</p><p>+struct nl_cloner {</p><p>+	const char		*name;</p><p>+	rtnl_iface_create_f	*create_f;</p><p>+	rtnl_iface_modify_f	*modify_f;</p><p>+	SLIST_ENTRY(nl_cloner)	next;</p><p>+};</p><p>+</p><p>+void rtnl_ifaces_init(void);</p><p>+void rtnl_ifaces_destroy(void);</p><p>+void rtnl_iface_add_cloner(struct nl_cloner *cloner);</p><p>+void rtnl_iface_del_cloner(struct nl_cloner *cloner);</p><p>+</p><p>+/* iface_drivers.c */</p><p>+void rtnl_iface_drivers_register(void);</p><p>+</p><p>+/* nexthop.c */</p><p>+void rtnl_nexthops_init(void);</p><p>+struct nhop_object *nl_find_nhop(uint32_t fibnum, int family,</p><p>+    uint32_t uidx, int nh_flags, int *perror);</p><p>+</p><p>+</p><p>+#endif</p></td></tr></tbody></div></div>
  </body>
</html>
