<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://thegradient.pub/mamba-explained/">Original</a>
    <h1>Mamba Explained</h1>
    
    <div id="readability-page-1" class="page"><div>
          <figure><img src="https://lh7-us.googleusercontent.com/Vv2LBVlbspbhtzNqDFAAZ8xgkHKAzJiEoef9HZTlGVFpxAbWCMavNmhj408DdeOPZbj53vySwQR81e2zXlo52xA8OrJCq00V_z5VGwEMgfcvSW2uh60hFdjYliY-GAa_Kptz2XFbUf8S_-WrJqyhI4k" alt="Mamba vs Transformer" loading="lazy" width="300" height="168"/></figure><p>Right now, AI is eating the world.</p><p>And by AI, I mean Transformers. Practically all the big breakthroughs in AI over the last few years are due to Transformers.</p><p><strong>Mamba</strong>, however, is one of an alternative class of models called <strong>State Space Models</strong> (<strong>SSMs</strong>). Importantly, for the first time, Mamba promises similar performance (and crucially similar <a href="https://arxiv.org/pdf/2203.15556.pdf"><em>scaling laws</em></a>) as the Transformer whilst being feasible at long sequence lengths (say 1 million tokens). To achieve this long context, the Mamba authors remove the ‚Äúquadratic bottleneck‚Äù in the Attention Mechanism. Mamba also runs <em>fast</em> - like ‚Äúup to 5x faster than Transformer fast‚Äù<a href="https://thegradient.pub/mamba-explained/#1"><sup>1</sup></a>.</p><figure><img src="https://lh7-us.googleusercontent.com/uIkOGdo_oOuGilrgILP7E0KvNC8Y7ZL93om_wMUQCJEEIeSo0GtO4dzQ4bHMq5sdZu2ldL-fMrFy3KcLAr5_A8JhNOqqPyxFbYPPx016x1Djhr9VJ0lGzcEMvDDe5a-r0Wv-xvtneEYUSMJAsVS0OTY" alt="Scaling Laws for Mamba vs other Language Models" loading="lazy" width="572" height="277"/><figcaption>Mamba performs similarly (or slightly better than) other Language Models on The Pile (<a href="https://arxiv.org/abs/2312.00752">source</a>)</figcaption></figure><p>Gu and Dao, the Mamba authors write:</p><p><em>Mamba enjoys fast inference and linear scaling in sequence length, and its performance improves on real data up to million-length sequences. As a general sequence model backbone, Mamba achieves state-of-the-art performance across several modalities such as language, audio, and genomics. On language modelling, our Mamba-3B model outperforms Transformers of the same size and matches Transformers twice its size, both in pretraining and downstream evaluation.</em></p><p>Here we‚Äôll discuss:</p><ul><li>The advantages (and disadvantages) of Mamba (üêç) vs Transformers (ü§ñ),</li><li>Analogies and intuitions for thinking about Mamba, and</li><li>What Mamba means for Interpretability, AI Safety and Applications.</li></ul><h2 id="problems-with-transformersmaybe-attention-isn%E2%80%99t-all-you-need">Problems with Transformers - Maybe Attention <em>Isn‚Äôt</em> All You Need</h2><p>We‚Äôre very much in the Transformer-era of history. ML used to be about detecting cats and dogs. Now, with Transformers, we‚Äôre <a href="https://openai.com/research/gpt-4">generating human-like poetry</a>, <a href="https://storage.googleapis.com/deepmind-media/AlphaCode2/AlphaCode2_Tech_Report.pdf">coding better than the median competitive programmer</a>, and <a href="https://www.nature.com/articles/s41586-021-03819-2">solving the protein folding problem</a>.</p><p>But Transformers have one core problem. In a transformer, every token can look back at every previous token when making predictions. For this lookback, we cache detailed information about each token in the so-called KV cache.</p><figure><img src="https://lh7-us.googleusercontent.com/dTD7M6vcg6ZBJPUyvFw_sOLbcZl6s6WXQbQ9Nfo3gq92G7bFIDBmr4Zj-Lahw7rZyHh6yKxRrSe790W04cyWAcRyM2rKkNz2wmsF_XJfP9mNJI5pSdst688I6o-brks05LF4N_5fNUPlQ1vvF8dOOdE" alt="attention" loading="lazy" width="602" height="393"/><figcaption>When using the Attention Mechanism, information from all previous tokens can be passed to the current token</figcaption></figure><p>This pairwise communication means a forward pass is O(n¬≤) time complexity in training (the dreaded quadratic bottleneck), and each new token generated autoregressively takes O(n) time. In other words, as the context size increases, the model gets <em>slower</em>.</p><p>To add insult to injury, storing this key-value (KV) cache requires O(n) space. ¬†Consequently, the dreaded CUDA out-of-memory (OOM) error becomes a significant threat as the memory footprint expands. If space were the only concern, we might consider adding more GPUs; however, with latency increasing quadratically, simply adding more compute might not be a viable solution.</p><p>On the margin, we can mitigate the quadratic bottleneck with techniques like <a href="https://paperswithcode.com/method/sliding-window-attention">Sliding Window Attention</a> or clever CUDA optimisations like <a href="https://arxiv.org/pdf/2205.14135.pdf">FlashAttention</a>. But ultimately, for super long context windows (like a chatbot which remembers every conversation you‚Äôve shared), we need a different approach.</p><h3 id="foundation-model-backbones">Foundation Model Backbones</h3><p>Fundamentally, all good ML architecture backbones have components for two important operations:</p><ol><li><strong>Communication</strong> <em>between</em> tokens</li><li><strong>Computation</strong> <em>within</em> a token</li></ol><figure><img src="https://lh7-us.googleusercontent.com/WpckyY81cA3zGS1j1vq5lH-nZKiRdelILLO6OdiX05s4Psqe3oBpIZiy1IavhsutFkz4oa7V9ZjzGhjxcdMxD9Q_Z3pYelK04_7YA1-I-_PVu3SLDfBBK1c4-M3QcHh0MwzQcUR7wccwPKvjoXzS06I" alt="Transformer Block" loading="lazy" width="602" height="412"/><figcaption>The Transformer Block</figcaption></figure><p>In transformers, this is <strong>Attention</strong> (communication) and <strong>MLPs</strong> (computation). We improve transformers by optimising these two operations<sup><a href="https://thegradient.pub/mamba-explained/#ft2">2</a></sup>.</p><p>We would like to substitute the Attention component<sup><a href="https://thegradient.pub/mamba-explained/#ft3">3</a></sup> with an alternative mechanism for facilitating inter-token communication. Specifically, <strong>Mamba</strong> employs a Control Theory-inspired State Space Model, or <strong>SSM,</strong> for Communication purposes while retaining Multilayer Perceptron (MLP)-style projections for Computation.</p><figure><img src="https://lh7-us.googleusercontent.com/T4MbDYFoOq5yAKl9uEEs9tjMy-CxBYy2S2rxnKbo5PmlnumyMs3DWV5chNooGG2hGp8ES9vXLEkmjHqlEzoCocVAnN2nquNhcBVK4hnrsfDJfBjJs5RZvx2bMSZEkm5yZtrTt7wBZfMW_iQXp4u8cU0" alt="Mamba Block" loading="lazy" width="602" height="340"/><figcaption>The Mamba Block</figcaption></figure><p>Like a Transformer made up of stacked transformer blocks, Mamba is made up of stacked Mamba blocks as above.</p><p>We would like to understand and motivate the choice of the SSM for sequence transformations.</p><h2 id="motivating-mambaa-throwback-to-temple-run">Motivating Mamba - A Throwback to Temple Run</h2><p>Imagine we‚Äôre building a Temple Run agent<sup><a href="https://thegradient.pub/mamba-explained/#ft4">4</a></sup>. It chooses if the runner should move left or right at any time.</p><figure><img src="https://thegradient.pub/content/images/2024/03/temple_run.png" alt="Temple Run" loading="lazy" width="900" height="822" srcset="https://thegradient.pub/content/images/size/w600/2024/03/temple_run.png 600w, https://thegradient.pub/content/images/2024/03/temple_run.png 900w" sizes="(min-width: 720px) 720px"/></figure><p>To successfully pick the correct direction, we need information about our surroundings. Let‚Äôs call the collection of relevant information the state. Here the state likely includes your current position and velocity, the position of the nearest obstacle, weather conditions, etc.</p><blockquote><em>Claim 1: if you know the current state of the world and how the world is evolving, then you can use this to determine the direction to move.</em></blockquote><p>Note that you don‚Äôt need to look at the whole screen all the time. You can figure out what will happen to most of the screen by noting that as you run, the obstacles move down the screen. You only need to look at the top of the screen to understand the new information and then simulate the rest.</p><figure><img src="https://lh7-us.googleusercontent.com/09a_eDMzBRh-usMcrg1W-JnkWE59PbsAtAW3Q8z8NmeyHGCpGsKG58dJtHNTnVUunlBbGb7xKt8nExTChRxMdcs1a125J7p11vDMR77GzigsI3j797VQxLLB9e_ILa1l8A-BCy7psxnYBIoQzk6-2GQ" alt="Temple Run" loading="lazy" width="602" height="295"/></figure><p>This lends itself to a natural formulation. Let h be the hidden state, relevant knowledge about the world. Also let x be the input, the observation that you get each time. h‚Äô then represents the derivative of the hidden state, i.e. how the state is evolving. We‚Äôre trying to predict y, the optimal next move (right or left).</p><p>Now, Claim 1 states that from the hidden state h, h‚Äô, and the new observation x, you can figure out y.</p><p>More concretely, h, the state, can be represented as a differential equation (Eq 1a):</p><!--kg-card-begin: markdown--><p>$h‚Äô(t) = \mathbf{A}h(t) + \mathbf{B}x(t)$</p>
<!--kg-card-end: markdown--><p>Knowing h allows you to determine your next move y (Eq 1b):</p><!--kg-card-begin: markdown--><p>$y(t) = \mathbf{C}h(t) + \mathbf{D}x(t)$</p>
<!--kg-card-end: markdown--><p>The system&#39;s evolution is determined by its current state and newly acquired observations. A small new observation is enough, as the majority of the state can be inferred by applying known state dynamics to its previous state. That is, most of the screen isn‚Äôt new, it‚Äôs just a continuation of the previous state&#39;s natural downward trajectory. A full understanding of the state would enable optimal selection of the subsequent action, denoted as y.</p><p>You can learn a lot about the system dynamics by observing the top of the screen. For instance, increased velocity of this upper section suggests an acceleration of the rest of the screen as well, so we can infer that the game is speeding up<sup><a href="https://thegradient.pub/mamba-explained/#ft5">5</a></sup>. In this way, even if we start off knowing nothing about the game and only have limited observations, it becomes possible to gain a holistic understanding of the screen dynamics fairly rapidly.</p><h3 id="what%E2%80%99s-the-state">What‚Äôs the State?</h3><p>Here, <strong>state</strong> refers to the variables that, when combined with the input variables, fully determine the future system behaviour. In theory, once we have the state, there‚Äôs nothing else we need to know about the past to predict the future. With this choice of state, the system is converted to a <strong>Markov Decision Process</strong>. Ideally, the state is a fairly small amount of information which captures the essential properties of the system. That is, <strong>the state is a compression of the past</strong><sup><a href="https://thegradient.pub/mamba-explained/#ft6">6</a></sup>.</p><h2 id="discretisationhow-to-deal-with-living-in-a-quantised-world">Discretisation - How To Deal With Living in a Quantised World</h2><p>Okay, great! So, given some state and input observation, we have an autoregressive-style system to determine the next action. Amazing!</p><p>In practice though, there‚Äôs a little snag here. We‚Äôre modelling time as continuous. But in real life, we get new inputs and take new actions at discrete time steps<sup><a href="https://thegradient.pub/mamba-explained/#ft7">7</a></sup>.</p><figure><img src="https://lh7-us.googleusercontent.com/_A8UqIDZgHLXm-YwGNfpfE7gSg6fA5-PhsNKZEHAbHNS2-XBYRrZpDGUvJgiOIBCg126L7s2GYMxn98LSdgkVJNC5_sL5HNsDjazFLArizSkJbEAJAVmL3BpajxCbWO-5Hgtq9CEfW_lfzmUscSZTPg" alt="Reality is Quantised" loading="lazy" width="602" height="601"/></figure><p>We would like to convert this <em>continuous-time differential equation</em> into a <em>discrete-time difference equation</em>. This conversion process is known as discretisation. Discretisation is a well-studied problem in the literature. Mamba uses the <a href="https://en.wikipedia.org/wiki/Zero-order_hold">Zero-Order Hold</a> (ZOH) discretisation<sup><a href="https://thegradient.pub/mamba-explained/#ft8">8</a></sup>. To give an idea of what‚Äôs happening morally, consider a naive first-order approximation<sup><a href="https://thegradient.pub/mamba-explained/#ft9">9</a></sup>.</p><p>From Equation 1a, we have</p><!--kg-card-begin: markdown--><p>$h‚Äô(t) = \mathbf{A}h(t) + \mathbf{B}x(t)$</p>
<!--kg-card-end: markdown--><p>And for small ‚àÜ,</p><!--kg-card-begin: markdown--><p>$h‚Äô(t) \approx \frac{h(t+\Delta) - h(t)}{\Delta}$</p>
<!--kg-card-end: markdown--><p>by the definition of the derivative.</p><p>We let:</p><!--kg-card-begin: markdown--><p>$h_t = h(t)$</p>
<!--kg-card-end: markdown--><p>and</p><!--kg-card-begin: markdown--><p>$h_{t+1} = h(t + \Delta)$</p>
<!--kg-card-end: markdown--><p>and substitute into Equation 1a giving:</p><!--kg-card-begin: markdown--><p>$h_{t+1} - h_t \approx \Delta (\mathbf{A}h_t + \mathbf{B}x_t)$</p>
<!--kg-card-end: markdown--><p>Hence, after renaming the coefficients and relabelling indices, we have the discrete representations:</p><figure><img src="https://lh7-us.googleusercontent.com/JNkElXh35QPUmp4Sl625go-1PnrKWpzDdV5BObpnSg6-bbhKDxr83Y0AZi7XT8CQdxF1CeByNH4sbFyDc-aTRWyXeXrBDL499-BXjte-iYGD01UR4udyI-a9J7D-w9Ao6COYZC7HpDcoQxzOqzqA5IY" alt="Equation 2" loading="lazy" width="384" height="127"/><figcaption>The Discretised Version of the SSM Equation</figcaption></figure><p>If you‚Äôve ever looked at an RNN before<sup><a href="https://thegradient.pub/mamba-explained/#ft10">10</a></sup> and this feels familiar - <em>trust your instincts</em>:</p><p><em>We have some input x, which is combined with the previous hidden state by some transform to give the new hidden state. Then we use the hidden state to calculate the output at each time step.</em></p><h2 id="understanding-the-ssm-matrices">Understanding the SSM Matrices</h2><p>Now, we can interpret the A, B, C, D matrices more intuitively:</p><ul><li>A is the transition state matrix. It shows how you transition the current state into the next state. It asks ‚ÄúHow should I forget the less relevant parts of the state over time?‚Äù</li><li>B is mapping the new input into the state, asking ‚ÄúWhat part of my new input should I remember?‚Äù<sup><a href="https://thegradient.pub/mamba-explained/#ft11">11</a></sup></li><li>C is mapping the state to the output of the SSM. It asks, ‚ÄúHow can I use the state to make a good next prediction?‚Äù<sup><a href="https://thegradient.pub/mamba-explained/#ft12">12</a></sup></li><li>D is how the new input passes through to the output. It‚Äôs a kind of modified skip connection that asks ‚ÄúHow can I use the new input in my prediction?‚Äù</li></ul><figure><img src="https://lh7-us.googleusercontent.com/Vj3X7tBhV9WaGqNTB8t5zXJ9zRPzd0G075JEPazSOJ-D9S0-UYKwrjHFkGxIZBM1HucvGw4UQazcZJ3Kl7kN8hoqKVaRB8i1qRGjWz56mFA2SrBJBL9XKT72950OZCblDZ7AB0TLqXl4fWAx8BO-P-o" alt="Visual SSM Equations" loading="lazy" width="602" height="335"/><figcaption>Visual Representation of The SSM Equations</figcaption></figure><p>Additionally, ‚àÜ has a nice interpretation - it‚Äôs the step size, or what we might call the linger time or the dwell time. For large ‚àÜ, you focus more on that token; for small ‚àÜ, you skip past the token immediately and don‚Äôt include it much in the next state.</p><figure><img src="https://lh7-us.googleusercontent.com/t1ikATLC5zPLHbXwvx0qTGnvEKAROGmpKl6QZgKfV4hs-2jjr9BvLYoecz0XRXsxHelPl23DoFE6G4P8oeuef2JuQvF0NhSg4N3YIqGmIF9oXBAXtNBrTH6ilcnboFsZPW306EVyZ--TcIHrOqxTbpQ" alt="" loading="lazy" width="602" height="224"/><figcaption>(<a href="https://arxiv.org/abs/2312.00752">source</a>)</figcaption></figure><p>And that‚Äôs it! That‚Äôs the SSM, our ~drop-in replacement for Attention (Communication) in the Mamba block. The Computation in the Mamba architecture comes from regular linear projections, non-linearities, and local convolutions.</p><p>Okay great, that‚Äôs the theory - but does this work? Well‚Ä¶</p><h2 id="effectiveness-vs-efficiency-attention-is-focus-selectivity-is-prioritisation">Effectiveness vs Efficiency: Attention is Focus, Selectivity is Prioritisation</h2><p>At WWDC ‚Äò97, Steve Jobs famously noted that ‚Äú<a href="https://www.youtube.com/watch?v=H8eP99neOVs&amp;t=98s">focusing is about saying no</a>‚Äù. Focus is ruthless prioritisation. It‚Äôs common to think about Attention <em>positively</em> as choosing what to <em>notice</em>. In the Steve Jobs sense, we might instead frame Attention <em>negatively</em> as choosing what to <em>discard</em>.</p><p>There‚Äôs a classic intuition pump in Machine Learning known as the Cocktail Party Problem<sup><a href="https://thegradient.pub/mamba-explained/#ft13">13</a></sup>. Imagine a party with dozens of simultaneous loud conversations:</p><p>Question:</p><p><em>How do we recognise what one person is saying when others are talking at the same time?<sup><a href="https://thegradient.pub/mamba-explained/#ft14">14</a></sup></em></p><p>Answer:</p><p><em>The brain solves this problem by focusing your ‚Äúattention‚Äù on a particular stimulus and hence drowning out all other sounds as much as possible.</em></p><figure><img src="https://lh7-us.googleusercontent.com/C18AUAf7863Uq5SHEwb4aQFcFoA4HW8olFXz_MvZ9HttqJNF2hvIfm3TEsNLhRkXyEJTOwhbtUyOh4QKV2qiGUXwA1sq2_CSTjO7FWPvK2YRnJgYvN859kqXo8pOkZffsXC0iO9z5yajWbc_9CvtwO8" alt="Cocktail Party" loading="lazy" width="602" height="376"/></figure><hr/><p>Transformers use Dot-Product Attention to focus on the most relevant tokens. A big reason Attention is so great is that you have the potential to look back at everything that ever happened in its context. This is like photographic memory when done right.<sup><a href="https://thegradient.pub/mamba-explained/#ft15">15</a></sup></p><p>Transformers (ü§ñ) are extremely <strong>effective</strong>. But they aren‚Äôt very <strong>efficient</strong>. They store everything from the past so that they can look back at tokens with theoretically perfect recall.</p><p>Traditional RNNs (üîÅ) are the opposite - they forget a lot, only recalling a small amount in their hidden state and discarding the rest. They are very <strong>efficient</strong> - their state is small. Yet they are less <strong>effective</strong> as discarded information cannot be recovered.</p><p>We‚Äôd like something closer to the Pareto frontier of the effectiveness/efficiency tradeoff. Something that‚Äôs more effective than traditional RNNs and more efficient than transformers.</p><figure><img src="https://lh7-us.googleusercontent.com/V2BPTE_TEzO_CAXFnp54TL-nAzSpkiHN_PWZeWOgMN7TInAXL8i3hLgS8ruinxworyEl0248jU6y4Y86Wg1TJca-UjzjCrMQrmSpWceXJ-C4LIg6SJvJykJFfDBb12rIQi84B-aHKdPG_gWsxVkxT20" alt="Pareto Frontier" loading="lazy" width="602" height="407"/></figure><p>The Mamba Architecture seems to offer a solution which pushes out the Pareto frontier of effectiveness/efficiency.</p><p>SSMs are as <strong>efficient</strong> as RNNs, but we might wonder how <strong>effective</strong> they are. After all, it seems like they would have a hard time discarding only <em>unnecessary</em> information and keeping everything relevant. If each token is being processed the same way, applying the same A and B matrices as if in a factory assembly line for tokens, there is no context-dependence. We would like the forgetting and remembering matrices (A and B respectively) to vary and dynamically adapt to inputs.</p><h3 id="the-selection-mechanism">The Selection Mechanism</h3><p><strong>Selectivity</strong> allows each token to be transformed into the state in a way that is unique to its own needs. Selectivity is what takes us from vanilla SSM models (applying the same A (forgetting) and B (remembering) matrices to every input) to Mamba, the <em><strong>Selective</strong></em> <em>State Space Model</em>.</p><p>In regular SSMs, A, B, C and D are learned matrices - that is</p><!--kg-card-begin: markdown--><p>$\mathbf{A} = \mathbf{A}_{\theta}$ etc. (where Œ∏ represents the learned parameters)</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>With the Selection Mechanism in Mamba, A, B, C and D are also functions of x. That is $\mathbf{A} = \mathbf{A}_{\theta(x)}$ etc; the matrices are context dependent rather than static.</p>
<!--kg-card-end: markdown--><figure><img src="https://lh7-us.googleusercontent.com/wATzvqFAg8l5HWS9BSCi_OGZRkZ7XmoPfpuZkIaCgLNE1jwrocWaKn_j6OrSG_4n5uULQN6yYK1oWkR4_AbCTXnpaJDTw9PPmeF7btcFa4-7h1QESJIBxTPK4D5vbzFvGJKjxUu-kXqYnRi_oPiVAD4" alt="SSM Algorithm" loading="lazy" width="602" height="184"/><figcaption>Mamba (right) differs from traditional SSMs by allowing A,B,C matrices to be <strong>selective </strong>i.e. context dependent (<a href="https://arxiv.org/abs/2312.00752">source</a>)</figcaption></figure><p>Making A and B functions of x allows us to get the best of both worlds:</p><ul><li>We‚Äôre selective about what we include in the state, which improves <strong>effectiveness</strong> vs traditional SSMs.</li><li>Yet, since the state size is bounded, we improve on <strong>efficiency</strong> relative to the Transformer. We have O(1), not O(n) space and O(n) not O(n¬≤) time requirements.</li></ul><p>The Mamba paper authors write:</p><p><em>The efficiency vs. effectiveness tradeoff of sequence models is characterized by how well they compress their state: efficient models must have a small state, while effective models must have a state that contains all necessary information from the context. In turn, we propose that a fundamental principle for building sequence models is selectivity: or the context-aware ability to focus on or filter out inputs into a sequential state. In particular, a selection mechanism controls how information propagates or interacts along the sequence dimension.</em></p><hr/><p>Humans (mostly) don‚Äôt have photographic memory for everything they experience within a lifetime - or even within a day! There‚Äôs just way too much information to retain it all. Subconsciously, we select what to remember by choosing to forget, throwing away most information as we encounter it. Transformers (ü§ñ) decide what to focus on at <strong>recall time</strong>. Humans (üßë) also decide what to throw away at <strong>memory-making time</strong>. Humans filter out information early and often.</p><p>If we had infinite capacity for memorisation, it‚Äôs clear the transformer approach is better than the human approach - it truly is more effective. But it‚Äôs less efficient - transformers have to store so much information about the past that might not be relevant. Transformers (ü§ñ) only decide what‚Äôs relevant at <strong>recall time</strong>. The innovation of Mamba (üêç) is allowing the model better ways of forgetting earlier - it‚Äôs focusing by choosing what to <em>discard</em> using <strong>Selectivity</strong>, throwing away less relevant information at <strong>memory-making time</strong><sup><a href="https://thegradient.pub/mamba-explained/#ft16">16</a></sup>.</p><h3 id="the-problems-of-selectivity">The Problems of Selectivity</h3><p>Applying the Selection Mechanism does have its gotchas though. Non-selective SSMs (i.e. A,B not dependent on x) are fast to compute in training. This is because the component of</p><p>Yt which depends on xi can be expressed as a linear map, i.e. a single matrix that can be precomputed!</p><p>For example (ignoring the D component, the skip connection):</p><!--kg-card-begin: markdown--><p>$$y_2 = \mathbf{C}\mathbf{B}x_2 + \mathbf{C}\mathbf{A}\mathbf{B}x_1 +</p>
<!--kg-card-end: markdown--><p>If we‚Äôre paying attention, we might spot something even better here - this expression can be written as a convolution. Hence we can apply the Fast Fourier Transform and the Convolution Theorem to compute this <em>very</em> efficiently on hardware as in Equation 3 below.</p><figure><img src="https://lh7-us.googleusercontent.com/SnLnXqZ4ArJyiJmMNiUiDMpZ0WYRXuaWO-ZS_Ogj-hThlMVbZz8B3F9g09H5V5CQG6mjgiSphIpjOz4ATr_JYLxCZ9T-EjG5dNy1-mpL1JwL-XWJbymVgyEGhdxpfUT34B1v4iJ_vQAiNUGeTs2FMXs" alt="Equations 2 and 3" loading="lazy" width="602" height="93"/></figure><p>We can calculate Equation 2, the SSM equations, efficiently in the Convolutional Form, Equation 3.</p><p>Unfortunately, with the Selection Mechanism, we lose the convolutional form. Much attention is given to making Mamba efficient on modern GPU hardware using similar hardware optimisation tricks to Tri Dao‚Äôs Flash Attention<sup><a href="https://thegradient.pub/mamba-explained/#ft17">17</a></sup>. With the hardware optimisations, Mamba is able to run faster than comparably sized Transformers.</p><h3 id="machine-learning-for-political-economistshow-large-should-the-state-be">Machine Learning for Political Economists - How Large Should The State Be?</h3><p>The Mamba authors write, ‚Äúthe efficiency vs. effectiveness tradeoff of sequence models is characterised by how well they compress their state‚Äù. In other words, like in political economy<sup><a href="https://thegradient.pub/mamba-explained/#ft18">18</a></sup>, the fundamental problem is how to manage the state.</p><p>üîÅ <strong>Traditional RNNs are anarchic</strong></p><p><em>They have a small, minimal state. The size of the state is bounded. The compression of state is poor.</em></p><p>ü§ñ <strong>Transformers are communist</strong></p><p><em>They have a maximally large state. The ‚Äústate‚Äù is just a cache of the entire history with no compression. Every context token is treated equally until recall time.</em></p><p>üêç<strong>Mamba has a compressed state</strong></p><p><em>‚Ä¶but it‚Äôs selective about what goes in. Mamba says we can get away with a small state if the state is well focused and effective<sup><a href="https://thegradient.pub/mamba-explained/#ft19">19</a></sup>.</em></p><figure><img src="https://lh7-us.googleusercontent.com/rkN6fi0try__wiIKQ1D9gbHvCrW_dHsKV0jckG85H7P3_Lx1Vm2vHfeb7Zs6N50lnjVx04A3QTQb2JSjMltn8C0kFmvB4DPUgsjj_DEAGu8O-LcKlY7G0RLgLCCsDV_R1W4pkkE67_2rnyx0vCMnayM" alt="Language Models and State Size" loading="lazy" width="602" height="275"/><figcaption>Language Models and State Size</figcaption></figure><p>The upshot is that state<strong> representation is critical</strong>. A smaller state is more efficient; a larger state is more effective. The key is to <strong>selectively</strong> and <strong>dynamically</strong> compress data into the state. Mamba‚Äôs Selection Mechanism allows for context-dependent reasoning, focusing and ignoring. For both performance and interpretability, understanding the state seems to be very useful.</p><h2 id="information-flow-in-transformer-vs-mamba">Information Flow in Transformer vs Mamba</h2><p>How do Transformers know anything? At initialization, a transformer isn‚Äôt very smart. It learns in two ways:</p><ol><li>Training data (Pretraining, SFT, RLHF etc)</li><li>In context-data</li></ol><h4 id="training-data">Training Data</h4><p>Models learn from their training data. This is a kind of lossy compression of input data into the weights. We can think of the effect of pretraining data on the transformer kinda like the effect of your ancestor‚Äôs experiences on your genetics - you can‚Äôt recall their experiences, you just have vague instincts about them<sup><a href="https://thegradient.pub/mamba-explained/#ft20">20</a></sup>.</p><h4 id="in-context-data">In Context-Data</h4><p>Transformers use their context as short-term memory, which they can recall with ~perfect fidelity. So we get <a href="https://thegradient.pub/in-context-learning-in-context/">In-Context Learning</a>, e.g. using induction heads to solve the <a href="https://arxiv.org/pdf/2211.00593.pdf">Indirect Object Identification</a> task, or <a href="https://proceedings.neurips.cc/paper_files/paper/2022/file/c529dba08a146ea8d6cf715ae8930cbe-Paper-Conference.pdf">computing Linear Regression</a>.</p><h4 id="retrieval">Retrieval</h4><p>Note that Transformers don‚Äôt filter their context at all until recall time. So if we have a bunch of information we think <em>might</em> be useful to the Transformer, we filter it <em>outside</em> the Transformer (using Information Retrieval strategies) and then stuff the results into the prompt. This process is known as Retrieval Augmented Generation (RAG). RAG determines relevant information for the context window of a transformer. A human with the internet is kinda like a RAG system - you still have to know what to search but whatever you retrieve is as salient as short-term memory to you.</p><h4 id="information-flow-for-mamba">Information Flow for Mamba</h4><p>Training Data acts similarly for Mamba. However, the lines are slightly blurred for in-context data and retrieval. In-context data for Mamba <em>is</em> compressed/filtered similar to retrieval data for transformers. This in-context data is also accessible for look-up like for transformers (although with somewhat lower fidelity).</p><figure><img src="https://lh7-us.googleusercontent.com/0dxiIk5NUI9g_P7G5lr5CSziEVKABYdtIW-R4Rxi6OHwWV_vLYVb1wtetVmzNtRWcLngldL4A8WUQA2jhIQj-IJmpaYr97xt-2Du_dxVOe5ppA4EcRNxEbjQvmjbND_DhyKhO6nsnS4nf1NxvRLwx-o" alt="The Information Flow in Mamba" loading="lazy" width="602" height="236"/></figure><p>Transformer context is to Mamba states what short-term is to long-term memory. Mamba doesn‚Äôt just have ‚ÄúRAM‚Äù, it has a hard drive<sup><a href="https://thegradient.pub/mamba-explained/#ft21">21</a></sup> <a href="https://thegradient.pub/mamba-explained/#ft22"><sup>22</sup></a>.</p><h3 id="swapping-states-as-a-new-prompting-paradigm">Swapping States as a New Prompting Paradigm</h3><p>Currently, we often use RAG to give a transformer contextual information.</p><p>With Mamba-like models, you could instead imagine having a library of states created by running the model over specialised data. States could be shared kinda like <a href="https://paperswithcode.com/paper/lora-low-rank-adaptation-of-large-language">LoRAs</a> for image models.</p><p>For example, I could do inference on 20 physics textbooks and, say, 100 physics questions and answers. Then I have a state which I can give to you. Now you don‚Äôt need to add any few-shot examples; you just simply ask your question. <strong>The in-context learning is in the state</strong>.</p><p>In other words, you can drag and drop downloaded states into your model, like literal plug-in cartridges. And note that ‚Äútraining‚Äù a state doesn‚Äôt require any backprop. It‚Äôs more like a highly specialised one-pass fixed-size compression algorithm. This is unlimited in-context learning applied at inference time for zero-compute or latency<a href="https://thegradient.pub/mamba-explained/#ft23"><sup>23</sup></a>.</p><p>The structure of an effective LLM call goes from‚Ä¶</p><ol><li>System Prompt</li><li>Preamble</li><li>Few shot-examples</li><li>Question</li></ol><p>‚Ä¶for Transformers, to simply‚Ä¶</p><ol><li>Inputted state (with problem context, initial instructions, textbooks, and few-shot examples)</li><li>Short question</li></ol><p>‚Ä¶for Mamba.</p><p>This is cheaper and faster than few-shot prompting (as the state is infinitely reusable without inference cost). It‚Äôs also MUCH cheaper than finetuning and doesn‚Äôt require any gradient updates. We could imagine retrieving states in addition to context.</p><h2 id="mamba-mechanistic-interpretability">Mamba &amp; Mechanistic Interpretability</h2><p>Transformer interpretability typically involves:</p><ol><li>understanding token relationships via attention,</li><li>understanding circuits, and</li><li>using <a href="https://www.kolaayonrinde.com/blog/2023/11/03/dictionary-learning.html">Dictionary Learning</a> for unfolding MLPs.</li></ol><p>Most of the ablations that we would like to do for Mamba are still valid, but understanding token communication (1) is now more nuanced. All information moves between tokens via hidden states instead of the Attention Mechanism which can ‚Äúteleport‚Äù information from one sequence position to another.</p><p>For understanding in-context learning (ICL) tasks with Mamba, we will look to intervene on the SSM state. A classic task in-context learning task is <a href="https://arxiv.org/pdf/2211.00593.pdf">Indirect Object Identification</a> in which a model has to finish a paragraph like:</p><p><em>Then, Shelby and Emma had a lot of fun at the school. [Shelby/Emma] gave an apple to [BLANK]</em></p><p>The model is expected to fill in the blank with the name that is not repeated in the paragraph. In the chart below we can see that information is passed from the [Shelby/Emma] position to the final position via the hidden state (see the two blue lines in the top chart).</p><figure><img src="https://lh7-us.googleusercontent.com/ZDBpRS1yEscEZcsJtevlPaM5URUP58dgJ2csAIcWP-hmQcje8kBi-u4zAWYnbeE26YXWemOh32pdHM2TgaSanGePOVgRiss8svxP17nLPBvg1YjLE4W1uIGkTmDI9PbZO42u_4KfYoSeaRnZz_W4HfY" alt="Patching State" loading="lazy" width="602" height="256"/></figure><figure><img src="https://lh7-us.googleusercontent.com/j8aQ6XIxedX6Zut0rz7CE_e02KgBjyJvg7QQ7U9FkM2TjSWWSNk1v7gFVeGSsETqwQGvF8flh0lIUmSLIVqW9rwHC69rImw5MPj0vA0Y4XihacOzZnhUeKMZpf3bWtJTM_TB67EDYKIyfp2DeX4pNFU" alt="Patching Residual Stream" loading="lazy" width="602" height="256"/></figure><p>Since it‚Äôs hypothesised that much of In-Context Learning in Transformers is downstream of more primitive sequence position operations (like <a href="https://transformer-circuits.pub/2022/in-context-learning-and-induction-heads/index.html">Induction Heads</a>), Mamba being able to complete this task suggests a more general In-Context Learning ability.</p><h2 id="what%E2%80%99s-next-for-mamba-ssms">What‚Äôs Next for Mamba &amp; SSMs?</h2><p>Mamba-like models are likely to excel in scenarios requiring extremely long context and long-term memory. Examples include:</p><ul><li>Processing DNA</li><li>Generating (or reasoning over) video</li><li>Writing novels</li></ul><p>An illustrative example is agents with long-term goals.</p><p><em>Suppose you have an agent interacting with the world. Eventually, its experiences become too much for the context window of a transformer. The agent then has to compress or summarise its experiences into some more compact representation.</em></p><p><em>But how do you decide what information is the most useful as a summary? If the task is language, LLMs are actually fairly good at summaries - okay, yeah, you‚Äôll lose some information, but the most important stuff can be retained.</em></p><p><em>However, for other disciplines, it might not be clear how to summarise. For example, what‚Äôs the best way to summarise a 2 hour movie?<a href="https://thegradient.pub/mamba-explained/#ft24"><sup>24</sup></a>. Could the model itself learn to do this naturally rather than a hacky workaround like trying to describe the aesthetics of the movie in text?</em></p><p>This is what Mamba allows. Actual long-term memory. A real state where the model learns to keep what‚Äôs important. <a href="https://arxiv.org/pdf/2309.10668.pdf">Prediction is compression</a> - learning what‚Äôs useful to predict what‚Äôs coming next inevitably leads to building a useful compression of the previous tokens.</p><hr/><p>The implications for Assistants are clear:</p><p>Your chatbot co-evolves with you. It remembers.</p><figure><img src="https://lh7-us.googleusercontent.com/agZClF-xa6q13BlEbfZLFKP3DM0hJiRy9kC0MRFoNPi8kdWCh8_BUa5oLC0V_6jTmcNQQfmMr7GGa6gwIe3CEGVeK79AFMhE1gMnbdhEoQ8iFCRuO7Yc6Xi2M3kaVIGZ4LTfDKqITQ6ap1DylOqbWs4" alt="Her" loading="lazy" width="602" height="339"/></figure><p>The film HER is looking better and better as time goes on üò≥</p><h3 id="agents-ai-safety">Agents &amp; AI Safety</h3><p>One reason for positive updates in existential risk from AGI is Language Models. Previously, Deep-RL agents trained via self-play looked set to be the first AGIs. Language models are inherently much safer since they aren‚Äôt trained with long-term goals<a href="https://thegradient.pub/mamba-explained/#ft25"><sup>25</sup></a>.</p><p>The potential for long-term sequence reasoning here brings back the importance of agent-based AI safety. Few agent worries are relevant to Transformers with an 8k context window. Many are relevant to systems with impressive long-term memories and possible instrumental goals.</p><h3 id="the-best-collab-since-taco-bell-kfc-%F0%9F%A4%96-x-%F0%9F%90%8D">The Best Collab Since Taco Bell &amp; KFC: ü§ñ x üêç</h3><p>The Mamba authors show that there‚Äôs value in combining Mamba‚Äôs long context with the Transformer‚Äôs high fidelity over short sequences. For example, if you‚Äôre making long videos, you likely can‚Äôt fit a whole movie into a Transformer‚Äôs context for attention<a href="https://thegradient.pub/mamba-explained/#ft26"><sup>26</sup></a>. You could imagine having Attention look at the most recent frames for short-term fluidity and an SSM for long-term narrative consistency<a href="https://thegradient.pub/mamba-explained/#ft27"><sup>27</sup></a>.</p><hr/><p>This isn‚Äôt the end for Transformers. Their high effectiveness is exactly what‚Äôs needed for many tasks. But now Transformers aren‚Äôt the only option. Other architectures are genuinely feasible.</p><p>So we‚Äôre not in the post-Transformer era. But for the first time, we‚Äôre living in the post-only-Transformers era<a href="https://thegradient.pub/mamba-explained/#ft28"><sup>28</sup></a>. And this blows the possibilities wide open for sequence modelling with extreme context lengths and native long-term memory.</p><p>Two ML researchers, Sasha Rush (HuggingFace, Annotated Transformer, Cornell Professor) and Jonathan Frankle (Lottery Ticket Hypothesis, MosaicML, Harvard Professor), currently have a bet <a href="http://www.isattentionallyouneed.com/">here</a>.</p><figure><img src="https://lh7-us.googleusercontent.com/-_S7CaQ4OxepapriZhhAs25xq-H_dSnavPxXkm0_lMMZjtno4kgWfjS1PAcLhYpbMz6BNNYd-RoxBA_Fy45CemDdvofbP7oPVQ3ygHBQNQ8pMVf7l5YnLSCgE3L1J9muCpoFmTSz09zcX9xEigRrKnc" alt="Attention Wager" loading="lazy" width="602" height="324"/></figure><p>Currently Transformers are far and away in the lead. With 3 years left, there‚Äôs now a research direction with a fighting chance.</p><p>All that remains to ask is: <strong>Is Attention All We Need?</strong><br/></p><hr/><!--kg-card-begin: html--><p>
    <a name="ft1">1.</a> see Figure 8 in the Mamba paper.
    </p><!--kg-card-end: html--><p>Kola Ayonrinde is a Research Scientist and Machine Learning Engineer with a flair for writing. He integrates technology and creativity, focusing on applying machine learning in innovative ways and exploring the societal impacts of tech advancements.</p><h2 id="acknowledgements">Acknowledgements</h2><p>This post was originally posted on <a href="https://www.kolaayonrinde.com/blog/2024/02/11/mamba.html">Kola&#39;s personal blog</a>.</p><p><em>Thanks to Gon√ßalo for reading an early draft, Jaden for the nnsight library used for the Interpretability analysis and Tessa for Mamba patching visualisations.Also see: </em><a href="https://arxiv.org/pdf/2312.00752.pdf"><em>Mamba paper</em></a><em>, Mamba Python code, </em><a href="https://srush.github.io/annotated-s4/"><em>Annotated S4</em></a><em>, </em><a href="https://www.cognitiverevolution.ai/emergency-pod-mamba-memory-and-the-ssm-moment/"><em>Nathan Labenz podcast</em></a></p><h2 id="citation">Citation</h2><p>For attribution in academic contexts or books, please cite this work as</p><pre><code>Kola Ayonrinde, &#34;Mamba Explained,&#34; The Gradient, 2024</code></pre><pre><code>@article{Ayonrinde2024mamba,
    author = {Kola Ayonrinde},
    title = {Mamba Explained},
    journal = {The Gradient},
    year = {2024},
    howpublished = {\url{https://thegradient.pub/mamba-explained},
}</code></pre>
        </div></div>
  </body>
</html>
