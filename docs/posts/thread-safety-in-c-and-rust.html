<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.reverberate.org/2021/12/18/thread-safety-cpp-rust.html">Original</a>
    <h1>Thread Safety in C&#43;&#43; and Rust</h1>
    
    <div id="readability-page-1" class="page"><div>
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>Lately I’ve been experimenting with Rust, and I want to report some of what
I’ve learned about thread-safety.  I am an enthusiastic dabbler in Rust: I
spend most of my time in C and C++, but I’m always looking for an excuse to
learn more about Rust’s approach to the techniques I use every day in C and
C++.</p>

<p>When studying Rust’s threading model, I came to see some correspondence between
C++ and Rust terminology that I had not seen published previously.  Here are my
findings, which hopefully can help people with C++ background understand Rust
(or vice-versa).</p>



<p>The C++ standard does not define the term “thread-safe”, but it is <a href="https://abseil.io/blog/20180531-regular-types#data-races-and-thread-safety-properties">common
practice now within the C++
community</a>
to define it in the following way:</p>

<ul>
  <li><strong>thread-safe</strong>: A type is <em>thread-safe</em> if it is is safe to invoke <strong>any</strong> of
its methods concurrently.  To provide this guarantee, a type must generally
take some special measures to avoid data races, eg. using a mutex or atomic
operations internally.  This generally comes with performance and/or
complexity costs, so most types will not be thread-safe.</li>
  <li><strong>thread-compatible</strong>: A type is <em>thread-compatible</em> if it is safe to invoke
<strong><code>const</code></strong> methods concurrently.  Any concurrent call to a non-<code>const</code>
method must be synchronized by the caller.  Most types in C++ are
thread-compatible, as this guarantee comes mostly comes for free: it happens
naturally for any type that is const-correct (ie. avoids <code>mutable</code> members or
<code>const_cast</code>).</li>
</ul>

<p>Thread-compatible types compose nicely and avoid synchronization overheads.
Suppose you have 10 thread-compatible objects that you want to access
concurrently together.  You can wrap a <code>Mutex</code> around all 10 and pay only a
single synchronization cost.  If you have 10 thread-safe objects, you pay 10
separate synchronization costs as each of them perform their own internal
synchronization.  If you are using an object in only one thread, you may not
need synchronization at all, but the thread-safe type won’t know this and will
pay the cost regardless.  For all of these reasons, thread-compatible types are
generally preferred.</p>

<p>Here is an example of a thread-safe type in C++.  It achieves thread-safety
by using <code>std::atomic</code>:</p>

<div><div><pre><code><span>// C++ Usage of thread-safe type.</span>
<span>#include &lt;atomic&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
</span>
<span>// A very simple thread-safe type.</span>
<span>class</span> <span>ThreadSafeCounter</span> <span>{</span>
 <span>public:</span>
  <span>ThreadSafeCounter</span><span>()</span> <span>:</span> <span>counter_</span><span>(</span><span>0</span><span>)</span> <span>{}</span>
  <span>void</span> <span>Increment</span><span>()</span> <span>{</span> <span>counter_</span><span>++</span><span>;</span> <span>}</span>
  <span>int</span> <span>GetCount</span><span>()</span> <span>const</span> <span>{</span> <span>return</span> <span>counter_</span><span>;</span> <span>}</span>

 <span>private:</span>
  <span>std</span><span>::</span><span>atomic</span><span>&lt;</span><span>int</span><span>&gt;</span> <span>counter_</span><span>;</span>
<span>};</span>

<span>int</span> <span>main</span><span>()</span> <span>{</span>
  <span>ThreadSafeCounter</span> <span>counter</span><span>;</span>
  <span>const</span> <span>int</span> <span>n</span> <span>=</span> <span>10</span><span>;</span>
  <span>std</span><span>::</span><span>vector</span><span>&lt;</span><span>std</span><span>::</span><span>thread</span><span>&gt;</span> <span>threads</span><span>;</span>

  <span>// Spawn `n` threads that all share a single counter.</span>
  <span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>n</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span>{</span>
    <span>threads</span><span>.</span><span>push_back</span><span>(</span><span>std</span><span>::</span><span>thread</span><span>([</span><span>&amp;</span><span>counter</span><span>]</span> <span>{</span>
      <span>// Unsynchronized call of a non-const method.</span>
      <span>// Only safe because the type is thread-safe.</span>
      <span>counter</span><span>.</span><span>Increment</span><span>();</span>
    <span>}));</span>
  <span>}</span>
  <span>for</span> <span>(</span><span>auto</span><span>&amp;</span> <span>thread</span> <span>:</span> <span>threads</span><span>)</span> <span>{</span> <span>thread</span><span>.</span><span>join</span><span>();</span> <span>}</span>

  <span>// This will ultimately print `n`.</span>
  <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>counter</span><span>.</span><span>GetCount</span><span>()</span> <span>&lt;&lt;</span> <span>&#34;</span><span>\n</span><span>&#34;</span><span>;</span>
  <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre></div></div>



<p>Rust’s model for thread-safety has some notable differences.  Rust’s
thread-safety story centers around two traits:</p>

<ul>
  <li>The <code>Sync</code> trait indicates that a type can be safely shared between threads.</li>
  <li>The <code>Send</code> trait indicates that a type can be safely moved between threads.</li>
</ul>

<p>The <code>Sync</code> trait ends up mapping closely to the C++ concept of
<em>thread-compatible</em>.  It indicates that concurrent access of a type is safe, as
long as neither of the concurrent operations operates on a mutable reference.
Just as most types in C++ are thread-compatible, most types in Rust are <code>Sync</code>.</p>

<p>However, Rust and C++ differ far more when we talk about thread-safe types.
Rust forbids shared mutable access at the language level.  That means that the
C++ way of modeling thread-safety won’t work at all in Rust.  Even if we tried
to make a Rust type that offered the C++ thread-safety guarantee, safe Rust
code would never be able to take advantage of this guarantee, because the code
would fail to compile.</p>

<p>For example, let’s try to port the C++ code above to Rust:</p>

<div><div><pre><code><span>use</span> <span>std</span><span>::</span><span>thread</span><span>;</span>
<span>use</span> <span>std</span><span>::</span><span>sync</span><span>::</span><span>atomic</span><span>::{</span><span>AtomicI32</span><span>,</span> <span>Ordering</span><span>};</span>

<span>struct</span> <span>ThreadSafeCounter</span> <span>{</span>
    <span>count</span><span>:</span> <span>AtomicI32</span><span>,</span>
<span>}</span>

<span>impl</span> <span>ThreadSafeCounter</span> <span>{</span>
    <span>fn</span> <span>increment</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>)</span> <span>{</span> <span>self</span><span>.count</span><span>.fetch_add</span><span>(</span><span>1</span><span>,</span> <span>Ordering</span><span>::</span><span>SeqCst</span><span>);</span> <span>}</span>
<span>}</span>

<span>pub</span> <span>fn</span> <span>main</span><span>()</span> <span>{</span>
    <span>let</span> <span>n</span> <span>=</span> <span>10</span><span>;</span>
    <span>let</span> <span>mut</span> <span>counter</span> <span>=</span> <span>ThreadSafeCounter</span> <span>{</span> <span>count</span><span>:</span> <span>AtomicI32</span><span>::</span><span>new</span><span>(</span><span>0</span><span>)</span> <span>};</span>
    <span>let</span> <span>mut</span> <span>threads</span> <span>=</span> <span>Vec</span><span>::</span><span>new</span><span>();</span>
    <span>for</span> <span>_</span> <span>in</span> <span>0</span><span>..</span><span>n</span> <span>{</span>
        <span>threads</span><span>.push</span><span>(</span><span>thread</span><span>::</span><span>spawn</span><span>(</span> <span>||</span> <span>{</span>
            <span>// Rust won&#39;t allow this.  We are attempting to mutably borrow</span>
            <span>// the same value multiple times.</span>
            <span>counter</span><span>.increment</span><span>();</span>
        <span>}));</span>
    <span>}</span>
    <span>for</span> <span>thread</span> <span>in</span> <span>threads</span> <span>{</span> <span>thread</span><span>.join</span><span>();</span> <span>}</span>
    <span>println!</span><span>(</span><span>&#34;{}&#34;</span><span>,</span> <span>counter</span><span>.count</span><span>.load</span><span>(</span><span>Ordering</span><span>::</span><span>SeqCst</span><span>));</span>
<span>}</span>
</code></pre></div></div>

<p>This fails to compile with:</p>

<div><div><pre><code>error[E0499]: cannot borrow `counter` as mutable more than once at a time
  --&gt; &lt;source&gt;:18:37
   |
18 |           threads.push(thread::spawn( || {
   |                        -              ^^ `counter` was mutably borrowed here in the previous iteration of the loop
   |  ______________________|
   | |
19 | |             // Rust won&#39;t allow this.  We are attempting to mutably borrow
20 | |             // the same value multiple times.
21 | |             counter.increment();
   | |             ------- borrows occur due to use of `counter` in closure
22 | |         }));
   | |__________- argument requires that `counter` is borrowed for `&#39;static`
</code></pre></div></div>

<p>Because Rust fundamentally allows only a single mutable reference to any given
object, we have to express the C++ concept of thread-safety in a different way.</p>

<p>The Rust answer to thread-safety is to allow mutation on an immutable
reference.  Rust calls this “interior mutability.”  As a C++ programmer,
interior mutability strikes me as a bit of a fib: an operation that is in fact
mutable, both logically and physically, is allowed on an immutable reference.
This is very similar to <code>mutable</code> and <code>const_cast</code> in C++, which are both
frowned on.</p>

<p>I found a nice explanation of the Rust perspective <a href="https://stackoverflow.com/a/63490856/77070">in this Stack Overflow
answer</a>:</p>

<blockquote>
  <p>In a way, Rust’s <code>mut</code> keyword actually has two meanings. In a pattern it
means “mutable” and in a reference type it means “exclusive”. The difference
between <code>&amp;self</code> and <code>&amp;mut self</code> is not really whether self can be mutated or
not, but whether it can be <em>aliased</em>.</p>
</blockquote>

<p>This helps explain the rationale behind interior mutability.  When applied to a
reference, “immutable” in Rust doesn’t really mean “immutable”, it means
“non-exclusive.”</p>

<p>There was even <a href="http://smallcultfollowing.com/babysteps/blog/2014/05/13/focusing-on-ownership/">a proposal several years
back</a>
to rename <code>&amp;mut</code> to <code>&amp;my</code>, <code>&amp;only</code>, or <code>&amp;uniq</code>, to emphasize that the key
property of such references is not that they are mutable, but that they are
<em>unique</em>.</p>

<p>A type we would consider thread-safe in C++ will need to use interior
mutability in Rust and implement the <code>Sync</code> trait. It will need to allow
mutating operations to be performed through an immutable reference.</p>

<p>A good example is <code>mutex</code>:</p>

<ul>
  <li>In C++,
<a href="https://en.cppreference.com/w/cpp/thread/mutex/lock"><code>std::mutex::lock()</code></a>
is a non-<code>const</code> operation.  This makes sense, as the operation does in fact
mutate the mutex. Callers have to read the documentation to know that
concurrent calls to this non-<code>const</code> method are safe.</li>
  <li>In Rust,
<a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html#method.lock"><code>std::sync::Mutex::lock()</code></a>
is an immutable operation (takes a non-<code>mut</code> reference).  This is the
interior mutability “fib” (as <code>lock()</code> will in fact mutate the mutex), but it
has the benefit of expressing the the type’s thread-safety guarantee within
the type system, which allows the compiler to automatically check it.</li>
</ul>



<p>The analysis above leaves us with the following mapping between terms:</p>

<table>
  <thead>
    <tr>
      <th>C++</th>
      <th>Rust</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>thread-compatible</td>
      <td>implements <code>Sync</code></td>
      <td>most types (eg. <code>Vec</code> or <code>vector</code>)</td>
    </tr>
    <tr>
      <td>thread-safe</td>
      <td>implements <code>Sync</code> with interior mutability</td>
      <td><code>mutex</code></td>
    </tr>
    <tr>
      <td>thread-unsafe</td>
      <td>doesn’t implement <code>Sync</code></td>
      <td><code>Cell</code>, <code>RefCell</code> in Rust</td>
    </tr>
  </tbody>
</table>

<p>We can also put things in quadrants like so:</p>

<table>
  <tbody><tr>
    <th></th>
    <th><code>Sync</code></th>
    <th><code>!Sync</code></th>
  </tr>
  <tr>
    <th>interior mutability</th>
    <td>thread-safe (<code>mutex</code>)</td>
    <td>thread-unsafe (<code>Cell</code>)</td>
  </tr>
  <tr>
    <th>no interior mutability</th>
    <td>thread-compatible (<code>Vec</code>)</td>
    <td>thread-unsafe (<code>proc_macro</code>)</td>
  </tr>
</tbody></table>

<p>The two quadrants under <code>!Sync</code> are both labeled “thread-unsafe.” The C++
terminology does not distinguish between these two cases, and neither does the
type system.  In Rust there are interesting differences between them.  With
interior mutability come types like <code>Cell</code> and <code>RefCell</code> that can provide safe
interior mutability by constraining the circumstances under which mutation can
occur.  The “no interior mutability” case here initially seems not useful, but
<a href="https://lobste.rs/s/bmejfu/thread_safety_c_rust#c_weauz9">as pointed out to me on
lobste.rs</a>, it can
actually be quite useful when combined with <code>!Send</code>, as it allows one to create
a handle to thread-local data that can only be safely used within a single
thread.</p>



<p><em>Thanks to Matt Brubeck for reading a draft version of this article.
Matt has <a href="https://limpet.net/mbrubeck/2019/02/07/rust-a-unique-perspective.html">an article that delves more deeply into unique vs shared
references</a>.</em></p>

  </div>

</article>

      </div>
    </div></div>
  </body>
</html>
