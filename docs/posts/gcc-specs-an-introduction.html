<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wozniak.ca/blog/2024/01/02/1/index.html">Original</a>
    <h1>GCC Specs: An Introduction</h1>
    
    <div id="readability-page-1" class="page"><div id="content">

<p>
If you&#39;ve ever used the <a href="https://gcc.gnu.org/">GNU Compiler Collection</a> (GCC) then you&#39;ve
worked with the <code>gcc</code> binary.  For those who don&#39;t know, <code>gcc</code> is a
driver, not a compiler.  It runs the compiler/assembler/linker as
required and coordinates the input and output between them.  Use of
the driver is so ubiquitous that everyone calls it the compiler and
tends to take the assembly and linking actions for granted.
</p>

<p>
I&#39;m not here to be a nitpicky pedant and admonish you to use the
correct terms.  There&#39;s no reason to start saying &#34;well actuallyâ€¦&#34;
about what <code>gcc</code> is and what it does.  Keep calling it the compiler
and don&#39;t worry about the assembler and linker unless it matters to
you.  The whole point of the driver is to abstract those
(annoying!) details away.
</p>

<p>
But then, how does the driver make it so you don&#39;t have to bother with
those details?  Somehow the driver has to take all the arguments you
provide, organize them, then run the appropriate subprograms using
those arguments stitched together in some way to process the input and
provide some output.
</p>

<p>
This article is about how the driver sets up the argument vectors for
subprograms.  Arguments are determined using <i>specification strings</i>,
or just <i>specs</i>.  Specs are a rather obscure and unintuitive
language that describe how and under what conditions the driver runs
each subprogram.  They are partially documented in the GCC manual in
the section <a href="https://gcc.gnu.org/onlinedocs/gcc-13.2.0/gcc/Spec-Files.html">Specifying Subprocesses and the Switches to Pass to Them</a>,
which is probably not the name you would have looked for if I said to
find the documentation for specs.
</p>

<div id="outline-container-org037864e">
<h2 id="org037864e">Lifting the curtain</h2>
<div id="text-org037864e">
<p>
Have you ever passed <code>-v</code> to the driver and studied the output?
There&#39;s a lot of stuff in there that is revealing.  It&#39;s also a good
way to understand what specs are and why they exist.
</p>

<p>
Because the output from <code>-v</code> is so extensive I&#39;m going to use one
example, broken up into parts.  Not all of it is relevant for
understanding specs, but it may be of general interest to some.
</p>

<p>
To get the output, I ran the following command on an amd64 machine
running Debian 12, which is using GCC 12.2.
</p>

<pre id="org01f3a3a">gcc -v t.c
</pre>

<p>
The content of the source file is not important, only that the program
is in a single file.  (Use <code>int main (void) {}</code> if you have nothing
sitting around.)  I&#39;ve reformatted the output where needed.  In some
cases I&#39;ve omitted output and indicate it with <code>(...)</code>.
</p>

<pre id="org1929ad6">Using built-in specs.
COLLECT_GCC=gcc
COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/12/lto-wrapper
OFFLOAD_TARGET_NAMES=nvptx-none:amdgcn-amdhsa
OFFLOAD_TARGET_DEFAULT=1
Target: x86_64-linux-gnu
Configured with: ../src/configure -v (...)
Thread model: posix
Supported LTO compression algorithms: zlib zstd
gcc version 12.2.0 (Debian 12.2.0-14) 
COLLECT_GCC_OPTIONS=&#39;-v&#39; &#39;-mtune=generic&#39; &#39;-march=x86-64&#39; &#39;-dumpdir&#39; &#39;a-&#39;
</pre>

<p>
The first line says where the driver is getting its specs.  It&#39;s
possible to override the builtin specs but that is for a later
discussion.
</p>

<p>
What follows are some environment variables that are set by <code>gcc</code> to
communicate with the subprograms and various other information.  There
is also the &#34;Configured with&#34; line that tells you how GCC was
configured, which is useful if you want to build it yourself.
</p>

<p>
In our example the driver has to compile the source using the C
compiler, assemble it into an object file, then link the object into
an executable.  The first subprogram run is the compiler.  <code>cc1</code> is
the C compiler, <code>cc1plus</code> is the C++ compiler.  Note that subprogram
invocations in the output are lines that start with a single space.
</p>

<pre id="orgd7ca7ad"> /usr/lib/gcc/x86_64-linux-gnu/12/cc1 \
   -quiet \
   -v \
   -imultiarch x86_64-linux-gnu \
   t.c \
   -quiet \
   -dumpdir a- \
   -dumpbase t.c \
   -dumpbase-ext .c \
   -mtune=generic \
   -march=x86-64 \
   -version \
   -fasynchronous-unwind-tables \
   -o /tmp/ccJOdUuR.s
(...)
</pre>

<p>
We only provided the arguments <code>-v</code> and <code>t.c</code> to the driver yet the
compiler has many more.  Some are even provided twice.  If you look at
the <a href="https://gcc.gnu.org/onlinedocs/gcc-13.2.0/gcc/Invoking-GCC.html">documentation</a> for options you won&#39;t find the &#34;dump&#34; ones listed,
for example, so the compiler doesn&#39;t use the same options as the
driver.  That said, some of them match.
<code>-fasynchronous-unwind-tables</code> is a code generation option helpful
when debugging if the target machine supports it.  <code>-march</code> and
<code>-mtune</code> control what kind of code is generated for the processor.
These are options specific to the target or host.  It would be tedious
to specify them every time.
</p>

<p>
I&#39;ve trimmed all the compiler output because it&#39;s mostly version info,
although it does print the C standard it is using, some of the
compiler&#39;s heuristic data, and the compiler executable checksum.  It
will also print the search order for headers which can be very handy
when debugging header problems or just knowing where system headers
reside.
</p>

<p>
As a side note, it&#39;s worth pointing out that you can run the compiler
directly if you want.  You can even pass it <code>--help</code> to see the
extensive set of options it accepts.  Running the compiler directly
isn&#39;t something you need to do very often, even when debugging it,
because <code>gcc</code> has a <a href="https://gcc.gnu.org/onlinedocs/gcc-13.2.0/gcc/Overall-Options.html#index-wrapper">-wrapper</a> option to do this for you.
</p>

<p>
The compiler outputs assembler source, so the next step is for the
driver is to run the assembler.
</p>

<pre id="org665d584"> as -v --64 -o /tmp/ccj7Fe2p.o /tmp/ccJOdUuR.s
(...)
</pre>

<p>
Note that the input is a temporary file, as is the output.  The driver
has to manage all these temporaries and coordinate them across the
subprograms.  If you pass <code>-save-temps</code> then it will change the way
this is done and use more intuitive names.
</p>

<p>
Finally, we have the linker<sup><a id="fnr.1" href="#fn.1" role="doc-backlink">1</a></sup> invocation, complete with the
messiest and most complex set of arguments.
</p>

<pre id="org84b688c">/usr/lib/gcc/x86_64-linux-gnu/12/collect2 \
   -plugin /usr/lib/gcc/x86_64-linux-gnu/12/liblto_plugin.so \
   -plugin-opt=/usr/lib/gcc/x86_64-linux-gnu/12/lto-wrapper \
   -plugin-opt=-fresolution=/tmp/cc7cMZRs.res \
   -plugin-opt=-pass-through=-lgcc \
   -plugin-opt=-pass-through=-lgcc_s \
   -plugin-opt=-pass-through=-lc \
   -plugin-opt=-pass-through=-lgcc \
   -plugin-opt=-pass-through=-lgcc_s \
   --build-id --eh-frame-hdr -m elf_x86_64 \
   --hash-style=gnu --as-needed \
   -dynamic-linker /lib64/ld-linux-x86-64.so.2 -pie \
   /usr/lib/gcc/x86_64-linux-gnu/12/../../../x86_64-linux-gnu/Scrt1.o \
   /usr/lib/gcc/x86_64-linux-gnu/12/../../../x86_64-linux-gnu/crti.o \
   /usr/lib/gcc/x86_64-linux-gnu/12/crtbeginS.o \
   -L/usr/lib/gcc/x86_64-linux-gnu/12 \
   -L/usr/lib/gcc/x86_64-linux-gnu/12/../../../x86_64-linux-gnu \
   -L/usr/lib/gcc/x86_64-linux-gnu/12/../../../../lib \
   -L/lib/x86_64-linux-gnu \
   -L/lib/../lib \
   -L/usr/lib/x86_64-linux-gnu \
   -L/usr/lib/../lib \
   -L/usr/lib/gcc/x86_64-linux-gnu/12/../../.. \
   /tmp/ccj7Fe2p.o \
   -lgcc \
   --push-state --as-needed -lgcc_s --pop-state \
   -lc -lgcc \
   --push-state --as-needed -lgcc_s --pop-state \
   /usr/lib/gcc/x86_64-linux-gnu/12/crtendS.o \
   /usr/lib/gcc/x86_64-linux-gnu/12/../../../x86_64-linux-gnu/crtn.o
</pre>

<p>
What the options mean is beyond the scope of this article, but it&#39;s
worth noting what arguments are needed.  There are object files (the
<code>.o</code> suffix) and libraries (<code>-l</code> options) and library search paths
(<code>-L</code> options).  The order of these options matters, too, and the
driver has to get this right.  Furthermore, which system object files
to use (found in <code>/usr/lib</code> in this example) can be non-obvious, so we
should appreciate all the work the driver does behind the scenes.
Manually specifying a link is tedious.
</p>

<p>
To round out the discussion of the files that the driver has to manage,
all the temporary files created during the compile/assemble/link
sequence are deleted before the driver exits.
</p>

<p>
All the arguments passed to the subprograms and the management of
files are done with specs.
</p>
</div>
</div>

<div id="outline-container-orgc7b0dcc">
<h2 id="orgc7b0dcc">What is a spec?</h2>
<div id="text-orgc7b0dcc">
<p>
The driver determines what subprograms to run based on the arguments
it is given.  For example, if you give it a file name with the <code>.c</code>
suffix it will know to run the C compiler for that file; give it a
file with a <code>.cpp</code> suffix and it will use the C++ compiler.  It
<a href="https://gcc.gnu.org/onlinedocs/gcc-13.2.0/gcc/Overall-Options.html">recognizes</a> many file extensions and you can specify the language it
should use with the <a href="https://gcc.gnu.org/onlinedocs/gcc-13.2.0/gcc/Overall-Options.html#index-x"><code>-x</code> option</a>.  Some options tell it not to run the
assembler or the linker.
</p>

<p>
The driver determines how to run a subprogram based on a spec for the
language.  Each language has its own spec that has the name of the
subprogram and the arguments to pass to it.  A spec is a string made
up of zero or more lines.  Each line corresponds to a program to run
so it&#39;s possible for you to run more than one program for each
language or &#34;stage&#34; being handled.
</p>

<p>
Since the arguments needed for a subprogram can vary significantly
from one invocation to the next they are rarely given directly.
Instead, they are provided with directives that expand to arguments
based on what the user supplied.  The syntax of these directives is
inspired by the ones used for <code>printf</code>, albeit with very different
semantics.
</p>

<p>
This may sound somewhat elegant but let me dissuade you of any notion
of elegance right now.  We are about to wade into an ad hoc
mini-language where the only reliable way to get the result you want
is to experiment to find out what happens, although admittedly the
lack of consistent (and documented) semantics only tends to show up
when you start doing the advanced stuff.
</p>
</div>
</div>

<div id="outline-container-org8e53fc6">
<h2 id="org8e53fc6">How to read a spec (the basics)</h2>
<div id="text-org8e53fc6">
<p>
We&#39;re going to focus on the assembler invocation since it is the
subprogram with the fewest arguments and is the easiest to follow.
The goal is to trace through how it gets its arguments.
</p>

<p>
To do this you have to learn how to read a spec.  This is accomplished
by looking at the <a href="https://gcc.gnu.org/onlinedocs/gcc-13.2.0/gcc/Spec-Files.html">spec documentation</a> and casting your eyes on arguably
the ugliest output GCC can produce: <code>gcc -dumpspecs</code>.
</p>

<p>
The full output of <code>-dumpspecs</code> is a beast, so here&#39;s a snippet of the
dumped specs that provides one of the above options.  I&#39;ve reformatted
the output slightly to put each directive from the spec string on its
own line so it&#39;s easier to read, but keep in mind that you&#39;re not
going to get output this agreeable most of the time.
</p>

<pre id="orgabe0bb5">*asm:
%{m16|m32:--32} \
  %{m16|m32|mx32:;:--64} \
  %{mx32:--x32} \
  %{msse2avx:%{!mavx:-msse2avx}}
</pre>

<p>
The <code>*asm:</code> line declares this is a named spec with the name <code>asm</code>.
This happens to be the builtin spec name for options passed to the
assembler.  Confusingly, this is not how <i>all</i> the options are passed,
but we&#39;ll get to that shortly.
</p>

<p>
Let&#39;s look closely at the following directive, which is how the <code>--64</code>
option is passed to the assembler.  It&#39;s one pattern you&#39;re going to
see a lot.
</p>

<pre id="orgb3f3206">%{m16|m32|mx32:;:--64}
</pre>

<p>
This says that if any of the arguments <code>-m16</code>, <code>-m32</code>, or <code>-mx32</code> has
been passed to the driver then substitute nothing, otherwise
substitute in the string <code>--64</code>.  Let&#39;s go over it in more detail.
</p>

<p>
The general form is <code>%{S:X;:D}</code>.  This says that if the argument <code>-S</code>
has been given then substitute <code>X</code>, otherwise substitute <code>D</code>.
(Clearly, <code>S</code> can also be a combination of arguments separated with
the pipe symbol <code>|</code>.)  This is a conditional and is the primary way
you control the way arguments are passed.
</p>

<p>
In the above case <code>X</code> is empty which is why it looks so confusing.
The first <code>:</code> indicates the end of the condition.  The <code>;</code> indicates
the end of the substitution.  Since there is nothing there, nothing
(well, the empty string) is substituted.  The last <code>:</code> indicates the
start of the last substitution.  You can add white space to make it
more readable, but it may or may not help.  You can nest them and when
they nest deeply (which they will), they can be very difficult to
follow.
</p>

<p>
Our example at the beginning only passed the arguments <code>-v</code> and
<code>t.c</code>.  Since none of <code>-m16</code>, <code>-m32</code>, or <code>-mx32</code> was passed, <code>--64</code>
is passed to the assembler.
</p>

<p>
If you look at the other directives in the <code>asm</code> spec you&#39;ll see other
forms of conditionals.
</p>

<ul>
<li>
<code>%{m16|m32:--32}</code> means that if either <code>-m16</code> or <code>-m32</code> was passed,
substitute <code>--32</code>.  Otherwise, substitute nothing.  This is a
conditional with only one clause and is very common.  You could
write it as <code>%{m16|m32:--32;:}</code> but that adds needless line noise so
it&#39;s better not to.</li>
<li>
<code>%{mx32:--x32}</code> should be clear by now: substitute <code>--x32</code> if <code>-mx32</code> was
given.</li>
<li>
<code>%{msse2avx:%{!mavx:-msse2avx}}</code> is interesting because it is how
you do conjunctions.  The other examples we&#39;ve looked at were
disjunctions.  Conjunctions are done by nesting.  This is where
things can get really hairy.  This one says that if <code>-msse2avx</code> was
given and not <code>-mavx</code> then substitute <code>-msse2avx</code>.  (You may think
&#34;oh, conjunctions aren&#39;t too bad&#34;.  I invite you to take a look at
the <code>link_command</code> spec.  Come back and we can share a story or
two.)</li>
</ul>

<p>
There are few other points to note about these directives.
</p>

<ul>
<li>The options in the condition are written without leading hyphens.
This is a good thing because adding them would make reading a spec
even harder.  Internally, the driver has already decoded the options
when matching happens so the hyphens are gone.</li>
<li>The substitution doesn&#39;t have to be an option, it can be any string.
Usually you want it to be an option, but it can also be another
directive.  If it is another directive, it will be processed as one.</li>
<li>You have negation with the <code>!</code> syntax.  There are other &#34;operators&#34;
but they are not common.</li>
<li>You can substitute an option directly if it was given, or nothing if
it wasn&#39;t, by writing <code>%{S}</code> where <code>S</code> is the option.  This is a
simple short form for <code>%{S:-S;:}</code>.</li>
<li>The full conditional syntax allows for any number of clauses.  For
example, you could write <code>%{m16|m32|mx32:;:--64}</code> as <code>%{m16:; m32:;
  mx32:; :--64}</code>.  I call this form the &#34;maximal confusion&#34; form
because if it&#39;s used it&#39;s rarely short and always difficult to read.</li>
<li>There doesn&#39;t seem to be a way to match option patterns or option
arguments.  There is a way, but we haven&#39;t gotten there yet.</li>
</ul>
</div>
</div>

<div id="outline-container-orgcdae7fa">
<h2 id="orgcdae7fa">From spec to arguments</h2>
<div id="text-orgcdae7fa">
<p>
We&#39;ve covered all this ground and so far we&#39;ve only explained one
argument.  And it seems to get there by magic.  The documentation says
that the <code>asm</code> spec specifies the options to pass to the assembler.
Clearly there are more than just the one.  What gives?
</p>

<p>
What gives is that the documentation does not tell the whole story.
The full spec for the assembler is actually in the <a href="https://gcc.gnu.org/git/?p=gcc.git;a=blob;f=gcc/gcc.cc;h=bb07cc244e30fbeccc701816db888f497d65eb08;hb=2ee5e4300186a92ad73f1a1a64cb918dc76c8d67#l1476">source code</a>.  It&#39;s
not large so I&#39;ll reproduce it here.
</p>

<pre id="org48f1ed1">%{!M:%{!MM:%{!E:%{!S:as %(asm_debug) %(asm_options) %i %A }}}}
</pre>

<p>
Here you can see the messiness of specs starting to show up.  If we
strip away the conditionals<sup><a id="fnr.2" href="#fn.2" role="doc-backlink">2</a></sup> we get something more manageable.
</p>

<pre id="orgb77deab">as %(asm_debug) %(asm_options) %i %A
</pre>

<p>
The <code>%(asm_debug)</code> and <code>%(asm_options)</code> directives reference named
specs.  They substitute in the value of that spec for further
processing.  If you look at the output of <code>-dumpspecs</code> you should find
both <code>asm_debug</code> and <code>asm_options</code>.  On my system they are long and
mostly of no consequence so I won&#39;t completely reproduce them here,
but we can go through the ones that actually produce the options.
Then we can look at a few other notable ones.
</p>

<p>
<code>asm_debug</code> doesn&#39;t substitute anything in our running example, so
let&#39;s turn our attention to <code>asm_options</code>.
</p>

<p>
Here&#39;s an abbreviated version of the spec.  Parts that are omitted are
denoted with <code>(...)</code>.  You should see something similar if you are
using a recent version of GCC.
</p>

<pre id="orge6a1e9b">*asm_options:
(...) %{v} (...) %a %Y %{c:%W{o*}%{!o*:-o %w%b%O}}%{!c:-o %d%w%u%O}
</pre>

<p>
Not all of these substitute anything, but they are notable so I have
included them.
</p>

<p>
To see how we go from spec to assembler invocation, I will show the
conceptual version of the full assembler spec at this point with the
final assembler invocation.  The conceptual version bypasses
<code>asm_debug</code> since it substitutes nothing and substitutes in the
abbreviated version of the <code>asm_options</code> spec.
</p>

<pre id="org8f37933">as %{v} %a %Y %{c:%W{o*}%{!o*:-o %w%b%O}}%{!c:-o %d%w%u%O} %i %A
</pre>

<pre id="orgd5de9a0">as -v --64 -o /tmp/ccj7Fe2p.o /tmp/ccJOdUuR.s
</pre>

<p>
We will go through each directive and show what happens.
</p>

<ul>
<li>
<code>%{v}</code> should be clear from earlier discussion: substitute <code>-v</code>
because <code>-v</code> was passed.</li>
<li>
<code>%a</code> and <code>%Y</code> are special builtin specs.  <code>%a</code> substitutes the <code>asm</code>
spec.  (Why have a special one and not just say <code>%(asm)</code>?  I don&#39;t
know.)  This is how we get the <code>--64</code> option as described in the
previous section.  <code>%Y</code> is used to substitute any assembler
arguments that are passed via <code>-Wa</code>, which is the way you tell the
driver that an argument is meant specifically for the assembler.
It&#39;s how you pass through an argument without the driver validating
it.  We did not pass any of those so it substitutes nothing.</li>
<li>The next directive is conditional and only substitutes if <code>-c</code> was
passed to the driver.  It substitutes nothing in our example.  I
included it, however, because it is written directly beside the next
spec.  This may seem significant but it actually isn&#39;t.  All
directives, once substituted, have spaces around them so you can&#39;t
piece together multiple arguments into one argument.  Why was this
not written as a conditional with an else clause?  Probably as a
matter of style.</li>
<li>The directive <code>%{!c:-o %d%w%u%O}</code> is going to give us the arguments
for the output file, but it looks like random gibberish so take it
one step at a time and look them up in the documentation.
<ul>
<li>
<code>%d</code> marks the argument as a temporary file which will be deleted
when the driver is done.  It substitutes nothing.</li>
<li>
<code>%w</code> marks the argument as the designated output file and also
substitutes nothing.</li>
<li>
<code>%u%O</code> substitutes the file name.  <code>%u</code> generates and substitutes
the temporary file name with the suffix substituted by <code>%O</code>.</li>
</ul>
</li>
<li>After the directives that give the output we have <code>%i</code> which
substitutes the input file.  This is the assembler file generated by
the compiler.</li>
<li>Finally, <code>%A</code> substitutes the <code>asm_final</code> spec.  This lets you run
some post processing on the assembler.  It does nothing in our case,
but if you&#39;re using the <code>-gsplit-dwarf</code> option with a recent version
of GCC you might want to check it out.</li>
</ul>

<p>
That&#39;s it!  That&#39;s the (mostly) complete trace of how the driver
determines how to call the assembler.
</p>
</div>
</div>

<div id="outline-container-org4b3b3fb">
<h2 id="org4b3b3fb">Experimenting with specs, the easy way</h2>
<div id="text-org4b3b3fb">
<p>
At this point we&#39;ve traced through how the assembler got its arguments
from the driver in some detailâ€”and there is plenty more that we
could cover.  I&#39;m going to do that in a later article, but in the
meantime I can show you the easiest way to experiment with specs that
doesn&#39;t involve writing them or changing the source.
</p>

<p>
If you pass the option <code>-###</code> to the driver it will print all the
commands it would run without actually running them.  Using this &#34;dry
run&#34; mode you can see how options are substituted without having to
bother with making the subprogram actually accept them.
</p>

<p>
Earlier in the <code>asm_options</code> spec I omitted an interesting directive:
<code>%{I*}</code>.  This is a spec that matches any option that starts with <code>-I</code>
<i>and</i> its option.  In this case it will substitute all the <code>-I</code>
options that were passed.  For example, if we had passed <code>-I dir1</code> and
<code>-Ipath/to/headers</code> to the driver, both of them would be substituted
in for <code>%{I*}</code>.  You can see this by running
</p>

<pre id="org8eb803b">gcc &#39;-###&#39; -I dir1 -Ipath/to/headers t.c
</pre>

<p>
and looking for the assembler command.  The <code>-###</code> command is quoted
to prevent the shell from possibly interpreting it as a comment or a
pattern.
</p>

<pre id="org998f04d">% gcc &#39;-###&#39; t.c -I dir -Ipath/to/headers 2&gt;&amp;1 | grep &#39;^ as&#39;
 as -I dir -I path/to/headers --64 -o /tmp/ccNz0vob.o /tmp/ccVtbBuj.s
</pre>
</div>
</div>

<div id="outline-container-org6d528d3">
<h2 id="org6d528d3">Experimenting with specs, the more interesting way</h2>
<div id="text-org6d528d3">
<p>
If you want to explore specs a bit more and don&#39;t want to start
changing the compiler, a good way is to use a custom spec that will
show you what gets substituted by defining a new file type.
</p>

<p>
You can do this easily with the following spec file.
</p>

<pre id="org041ace7">.xx:
./test.sh %i
</pre>

<p>
This will register a new file extension <code>.xx</code> and run the compiler
<code>./test.sh</code> passing it the input file as the argument.  All <code>test.sh</code>
has to do is echo its arguments.
</p>

<p>
You can run the driver like this to use your custom specs and
&#34;compiler&#34;.
</p>

<pre id="org389943b">gcc -c -specs=custom.specs file.xx
</pre>

<p>
You want to pass <code>-c</code> so that the driver does not try to run any other
subprograms.  Change the custom spec to your liking.  Here&#39;s an
example that will transform all options that start with <code>-m</code> to ones
that start with <code>-k</code>.  See the documentation for more details.
</p>

<pre id="orgbe414b7">.xx:
./test.sh %{m*:-k%*}
</pre>

<p>
If you pass <code>-m32 -march=blah</code> it will be passed to your &#34;compiler&#34; as
<code>-k32 -karch=blah</code>.
</p>
</div>
</div>

<div id="outline-container-org6d4453a">
<h2 id="org6d4453a">Summary</h2>
<div id="text-org6d4453a">
<p>
The GCC driver coordinates and runs multiple subprograms.  To manage
how it specifies all the arguments to these programs it uses something
called <i>specs</i>.  These are strings with <code>printf</code>-like directives that
are processed and substituted with values based on the arguments
passed to the driver and various contextual information.
</p>

<p>
You can view most, but not all, of the builtin specs to the driver by
running <code>gcc -dumpspecs</code>.  To get the full spec for a subprogram you
need to look in the driver source code.
</p>

<p>
Once you have these specs you can trace the logic behind an option,
but it is tedious work.  Specs are not known for their readability.
And it&#39;s pretty uncommon for anyone to have to debug the driver.
</p>

<p>
Nevertheless, specs can help you understand what the driver is doing.
It&#39;s one of those odd mysteries of a common tool that aren&#39;t really
explained anywhere.
</p>

<p>
In a future article I&#39;ll show some of the more esoteric parts of spec
usage, how to use specs to affect the driver itself, and the
idiosyncrasies of writing spec functions.
</p>

<p>
(Thanks to <a href="https://www.amazon.ca/More-Than-Good-Enough-Holmes/dp/099194755X">Matt L. Holmes</a> for reviewing this.)
</p>
</div>
</div>
<div id="footnotes">
<h2>Footnotes: </h2>
<div id="text-footnotes">

<div>
<p><sup><a id="fn.1" href="#fnr.1" role="doc-backlink">1</a></sup></p><p>
Strictly speaking, <code>collect2</code> is a wrapper for the actual
linker.  Explaining <code>collect2</code> is something else entirely.
</p>
</div>

<div>
<p><sup><a id="fn.2" href="#fnr.2" role="doc-backlink">2</a></sup></p><p>
The options in the conditionals are those that tell the
driver not to run the assembler.
</p>
</div>


</div>
</div>
</div></div>
  </body>
</html>
