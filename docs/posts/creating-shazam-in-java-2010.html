<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.royvanrijn.com/blog/2010/06/creating-shazam-in-java/">Original</a>
    <h1>Creating Shazam in Java (2010)</h1>
    
    <div id="readability-page-1" class="page"><div>
      <p><a itemprop="mainEntityOfPage" href="https://www.royvanrijn.com/blog/2010/06/creating-shazam-in-java/" title="Creating Shazam in Java">
        
          <img itemprop="image" src="https://www.royvanrijn.com/thumbnails/default.jpg" alt="Creating Shazam in Java" width="100" height="100"/>
        
      </a>
      </p>
      <p>
        Written by  (<span itemprop="publisher" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">royvanrijn.com</span></span>) on 
        <span itemprop="dateModified" content="2010-06-01T01:43:08+02:00">
        <span itemprop="datePublished" content="2010-06-01T01:43:08+02:00">
          Jun 1, 2010 01:43:08
        </span>
      </span></p>
      
    </div><div itemprop="articleBody">
    <p>A couple of days ago I encountered this article: <a href="http://laplacian.wordpress.com/2009/01/10/how-shazam-works/">How Shazam Works</a></p>

<p>This got me interested in how a program like Shazam works… And more importantly, how hard is it to program something similar in Java?</p>



<p>Shazam is an application which you can use to analyse/match music. When you install it on your phone, and hold the microphone to some music for about 20 to 30 seconds, it will tell you which song it is.</p>

<p>When I first used it it gave me a magical feeling. “How did it do that!?”. And even today, after using it a lot, it still has a bit of magical feel to it.</p>



<p>First things first, get the music sample to analyse we first need to listen to the microphone in our Java application…! This is something I hadn’t done yet in Java, so I had no idea how hard this was going to be.</p>

<p>But it turned out it was very easy:</p>

<figure><pre><code data-lang="java"><span>final</span> <span>AudioFormat</span> <span>format</span> <span>=</span> <span>getFormat</span><span>();</span> <span>//Fill AudioFormat with the wanted settings
</span>
<span>DataLine</span><span>.</span><span>Info</span> <span>info</span> <span>=</span> <span>new</span> <span>DataLine</span><span>.</span><span>Info</span><span>(</span><span>TargetDataLine</span><span>.</span><span>class</span><span>,</span> <span>format</span><span>);</span>
<span>final</span> <span>TargetDataLine</span> <span>line</span> <span>=</span> <span>(</span><span>TargetDataLine</span><span>)</span> <span>AudioSystem</span><span>.</span><span>getLine</span><span>(</span><span>info</span><span>);</span>
<span>line</span><span>.</span><span>open</span><span>(</span><span>format</span><span>);</span>
<span>line</span><span>.</span><span>start</span><span>();</span></code></pre></figure>

<p>Now we can read the data from the TargetDataLine just like a normal InputStream:</p>

<figure><pre><code data-lang="java"><span>// In another thread I start:
</span>

<span>OutputStream</span> <span>out</span> <span>=</span> <span>new</span> <span>ByteArrayOutputStream</span><span>();</span>
<span>running</span> <span>=</span> <span>true</span><span>;</span>

<span>try</span> <span>{</span>
    <span>while</span> <span>(</span><span>running</span><span>)</span> <span>{</span>
        <span>int</span> <span>count</span> <span>=</span> <span>line</span><span>.</span><span>read</span><span>(</span><span>buffer</span><span>,</span> <span>0</span><span>,</span> <span>buffer</span><span>.</span><span>length</span><span>);</span>
        <span>if</span> <span>(</span><span>count</span> <span>&gt;</span> <span>0</span><span>)</span> <span>{</span>
            <span>out</span><span>.</span><span>write</span><span>(</span><span>buffer</span><span>,</span> <span>0</span><span>,</span> <span>count</span><span>);</span>
        <span>}</span>
    <span>}</span>
    <span>out</span><span>.</span><span>close</span><span>();</span>
<span>}</span> <span>catch</span> <span>(</span><span>IOException</span> <span>e</span><span>)</span> <span>{</span>
    <span>System</span><span>.</span><span>err</span><span>.</span><span>println</span><span>(</span><span>&#34;I/O problems: &#34;</span> <span>+</span> <span>e</span><span>);</span>
    <span>System</span><span>.</span><span>exit</span><span>(-</span><span>1</span><span>);</span>
<span>}</span></code></pre></figure>

<p>Using this method it is easy to open the microphone and record all the sounds! The AudioFormat I’m currently using is:</p>

<figure><pre><code data-lang="java"><span>private</span> <span>AudioFormat</span> <span>getFormat</span><span>()</span> <span>{</span>
    <span>float</span> <span>sampleRate</span> <span>=</span> <span>44100</span><span>;</span>
    <span>int</span> <span>sampleSizeInBits</span> <span>=</span> <span>8</span><span>;</span>
    <span>int</span> <span>channels</span> <span>=</span> <span>1</span><span>;</span> <span>//mono
</span>
    <span>boolean</span> <span>signed</span> <span>=</span> <span>true</span><span>;</span>
    <span>boolean</span> <span>bigEndian</span> <span>=</span> <span>true</span><span>;</span>
    <span>return</span> <span>new</span> <span>AudioFormat</span><span>(</span><span>sampleRate</span><span>,</span> <span>sampleSizeInBits</span><span>,</span> <span>channels</span><span>,</span> <span>signed</span><span>,</span> <span>bigEndian</span><span>);</span>
<span>}</span></code></pre></figure>

<p>So, now we have the recorded data in a ByteArrayOutputStream, great! Step 1 complete.</p>



<p>The next challenge is analyzing the data, when I outputted the data I received in my byte array I got a long list of numbers, like this:</p>

<figure><pre><code data-lang="text">0
0
1
2
4
7
6
3
-1
-2
-4
-2
-5
-7
-8
(etc)</code></pre></figure>

<p>Erhm… yes? This is sound?</p>

<p>To see if the data could be visualized I took the output and placed it in Open Office to generate a line graph:</p>

<p><a href="https://www.royvanrijn.com/images/graph.png"><img src="https://www.royvanrijn.com/images/graph-300x248.png" alt="graph"/></a></p>

<p>Ah yes! This kind of looks like ‘sound’. It looks like what you see when using for example Windows Sound Recorder.</p>

<p>This data is actually known as <a href="http://en.wikipedia.org/wiki/Time_domain">time domain</a>. But these numbers are currently basically useless to us… if you read the above article on how Shazam works you’ll read that they use a <a href="http://en.wikipedia.org/wiki/Spectrum_analyzer">spectrum analysis</a> instead of direct time domain data.</p>



<p>To turn our data into usable data we need to apply the so called <a href="http://en.wikipedia.org/wiki/Discrete_Fourier_transform">Discrete Fourier Transformation</a>. This turns the data from time domain into frequency domain.</p>

<p>To solve this we need a sliding window. We take chunks of data (in my case 4096 bytes of data) and transform just this bit of information. Then we know the magnitude of all frequencies that occur during just these 4096 bytes.</p>



<p>Instead of worrying about the Fourier Transformation I googled a bit and found code for the so called FFT (Fast Fourier Transformation). I’m calling this code with the chunks:</p>

<figure><pre><code data-lang="java"><span>byte</span> <span>audio</span><span>[]</span> <span>=</span> <span>out</span><span>.</span><span>toByteArray</span><span>();</span>

<span>final</span> <span>int</span> <span>totalSize</span> <span>=</span> <span>audio</span><span>.</span><span>length</span><span>;</span>

<span>int</span> <span>amountPossible</span> <span>=</span> <span>totalSize</span><span>/</span><span>Harvester</span><span>.</span><span>CHUNK_SIZE</span><span>;</span>

<span>//When turning into frequency domain we&#39;ll need complex numbers:
</span>
<span>Complex</span><span>[][]</span> <span>results</span> <span>=</span> <span>new</span> <span>Complex</span><span>[</span><span>amountPossible</span><span>][];</span>

<span>//For all the chunks:
</span>
<span>for</span><span>(</span><span>int</span> <span>times</span> <span>=</span> <span>0</span><span>;</span><span>times</span> <span>&lt;</span> <span>amountPossible</span><span>;</span> <span>times</span><span>++)</span> <span>{</span>
    <span>Complex</span><span>[]</span> <span>complex</span> <span>=</span> <span>new</span> <span>Complex</span><span>[</span><span>Harvester</span><span>.</span><span>CHUNK_SIZE</span><span>];</span>
    <span>for</span><span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span><span>i</span> <span>&lt;</span> <span>Harvester</span><span>.</span><span>CHUNK_SIZE</span><span>;</span><span>i</span><span>++)</span> <span>{</span>
        <span>//Put the time domain data into a complex number with imaginary part as 0:
</span>
        <span>complex</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>new</span> <span>Complex</span><span>(</span><span>audio</span><span>[(</span><span>times</span><span>*</span><span>Harvester</span><span>.</span><span>CHUNK_SIZE</span><span>)+</span><span>i</span><span>],</span> <span>0</span><span>);</span>
    <span>}</span>
    <span>//Perform FFT analysis on the chunk:
</span>
    <span>results</span><span>[</span><span>times</span><span>]</span> <span>=</span> <span>FFT</span><span>.</span><span>fft</span><span>(</span><span>complex</span><span>);</span>
<span>}</span>

<span>//Done!</span></code></pre></figure>

<p>Now we have a double array containing all chunks as Complex[]. This array contains data about all frequencies. To visualize this data I decided to implement a full spectrum analyzer (just to make sure I got the math right).</p>

<figure><pre><code data-lang="java"><span>for</span><span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>results</span><span>.</span><span>length</span><span>;</span> <span>i</span><span>++)</span> <span>{</span>
    <span>int</span> <span>freq</span> <span>=</span> <span>1</span><span>;</span>
    <span>for</span><span>(</span><span>int</span> <span>line</span> <span>=</span> <span>1</span><span>;</span> <span>line</span> <span>&lt;</span> <span>size</span><span>;</span> <span>line</span><span>++)</span> <span>{</span>
        <span>// To get the magnitude of the sound at a given frequency slice
</span>
        <span>// get the abs() from the complex number.
</span>
        <span>// In this case I use Math.log to get a more managable number (used for color)
</span>
        <span>double</span> <span>magnitude</span> <span>=</span> <span>Math</span><span>.</span><span>log</span><span>(</span><span>results</span><span>[</span><span>i</span><span>][</span><span>freq</span><span>].</span><span>abs</span><span>()+</span><span>1</span><span>);</span>

        <span>// The more blue in the color the more intensity for a given frequency point:
</span>
        <span>g2d</span><span>.</span><span>setColor</span><span>(</span><span>new</span> <span>Color</span><span>(</span><span>0</span><span>,(</span><span>int</span><span>)</span><span>magnitude</span><span>*</span><span>10</span><span>,(</span><span>int</span><span>)</span><span>magnitude</span><span>*</span><span>20</span><span>));</span>
        <span>// Fill:
</span>
        <span>g2d</span><span>.</span><span>fillRect</span><span>(</span><span>i</span><span>*</span><span>blockSizeX</span><span>,</span> <span>(</span><span>size</span><span>-</span><span>line</span><span>)*</span><span>blockSizeY</span><span>,</span><span>blockSizeX</span><span>,</span><span>blockSizeY</span><span>);</span>
		
        <span>// I used a improviced logarithmic scale and normal scale:
</span>
        <span>if</span> <span>(</span><span>logModeEnabled</span> <span>&amp;&amp;</span> <span>(</span><span>Math</span><span>.</span><span>log10</span><span>(</span><span>line</span><span>)</span> <span>*</span> <span>Math</span><span>.</span><span>log10</span><span>(</span><span>line</span><span>))</span> <span>&gt;</span> <span>1</span><span>)</span> <span>{</span>
            <span>freq</span> <span>+=</span> <span>(</span><span>int</span><span>)</span> <span>(</span><span>Math</span><span>.</span><span>log10</span><span>(</span><span>line</span><span>)</span> <span>*</span> <span>Math</span><span>.</span><span>log10</span><span>(</span><span>line</span><span>));</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>freq</span><span>++;</span>
        <span>}</span>
    <span>}</span>
<span>}</span></code></pre></figure>



<p>This seems a bit of OT (off-topic), but I’d like to tell you about a electronic musician called Aphex Twin (Richard David James). He makes crazy electronic music… but some songs have an interesting feature. His biggest hit for example, <a href="http://en.wikipedia.org/wiki/Windowlicker">Windowlicker</a> has a spectrogram image in it.</p>

<p>When running this song against my spectral analyzer I get the following result:</p>

<p><a href="https://www.royvanrijn.com/images/face.png"><img src="https://www.royvanrijn.com/images/face-299x300.png" alt="face"/></a></p>

<p>Not perfect, but it seems to be Twin’s face!</p>



<p>The next step in Shazam’s algorithm is to determine some key points in the song, save those points as a hash and then try to match on them against their database of over 8 million songs. This is done for speed, the lookup of a hash is O(1) speed. That explains a lot of the awesome performance of Shazam!</p>

<p>Because I wanted to have everything working in one weekend (this is my maximum attention span sadly enough, then I need a new project to work on) I kept my algorithm as simple as possible. And to my surprise it worked.</p>

<p>For each line the in spectrum analysis I take the points with the highest magnitude from certain ranges. In my case: 40-80, 80-120, 120-180, 180-300.</p>

<figure><pre><code data-lang="java"><span>//For every line of data:
</span>

<span>for</span> <span>(</span><span>int</span> <span>freq</span> <span>=</span> <span>LOWER_LIMIT</span><span>;</span> <span>freq</span> <span>&lt;</span> <span>UPPER_LIMIT</span><span>-</span><span>1</span><span>;</span> <span>freq</span><span>++)</span> <span>{</span>
    <span>//Get the magnitude:
</span>
    <span>double</span> <span>mag</span> <span>=</span> <span>Math</span><span>.</span><span>log</span><span>(</span><span>results</span><span>[</span><span>freq</span><span>].</span><span>abs</span><span>()</span> <span>+</span> <span>1</span><span>);</span>

    <span>//Find out which range we are in:
</span>
    <span>int</span> <span>index</span> <span>=</span> <span>getIndex</span><span>(</span><span>freq</span><span>);</span>

    <span>//Save the highest magnitude and corresponding frequency:
</span>
    <span>if</span> <span>(</span><span>mag</span> <span>&gt;</span> <span>highscores</span><span>[</span><span>index</span><span>])</span> <span>{</span>
        <span>highscores</span><span>[</span><span>index</span><span>]</span> <span>=</span> <span>mag</span><span>;</span>
        <span>recordPoints</span><span>[</span><span>index</span><span>]</span> <span>=</span> <span>freq</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>//Write the points to a file:
</span>
<span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>AMOUNT_OF_POINTS</span><span>;</span> <span>i</span><span>++)</span> <span>{</span>
    <span>fw</span><span>.</span><span>append</span><span>(</span><span>recordPoints</span><span>[</span><span>i</span><span>]</span> <span>+</span> <span>&#34;\t&#34;</span><span>);</span>
<span>}</span>
<span>fw</span><span>.</span><span>append</span><span>(</span><span>&#34;\n&#34;</span><span>);</span>

<span>// ... snip ...
</span>


<span>public</span> <span>static</span> <span>final</span> <span>int</span><span>[]</span> <span>RANGE</span> <span>=</span> <span>new</span> <span>int</span><span>[]</span> <span>{</span><span>40</span><span>,</span><span>80</span><span>,</span><span>120</span><span>,</span><span>180</span><span>,</span> <span>UPPER_LIMIT</span><span>+</span><span>1</span><span>};</span>

<span>//Find out in which range
</span>
<span>public</span> <span>static</span> <span>int</span> <span>getIndex</span><span>(</span><span>int</span> <span>freq</span><span>)</span> <span>{</span>
    <span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span>
    <span>while</span><span>(</span><span>RANGE</span><span>[</span><span>i</span><span>]</span> <span>&lt;</span> <span>freq</span><span>)</span> <span>i</span><span>++;</span>
        <span>return</span> <span>i</span><span>;</span>
    <span>}</span>
<span>}</span></code></pre></figure>

<p>When we record a song now, we get a list of numbers such as:</p>

<figure><pre><code data-lang="text">33	56	99	121	195	
30	41	84	146	199	
33	51	99	133	183	
33	47	94	137	193	
32	41	106	161	191	
33	76	95	123	185	
40	68	110	134	232	
30	62	88	125	194	
34	57	83	121	182	
34	42	89	123	182	
33	56	99	121	195	
30	41	84	146	199	
33	51	99	133	183	
33	47	94	137	193	
32	41	106	161	191	
33	76	95	123	185</code></pre></figure>

<p>If I record a song and look at it visually it looks like this:</p>

<p><a href="https://www.royvanrijn.com/images/points.png"><img src="https://www.royvanrijn.com/images/points-228x300.png" alt="points"/></a></p>



<p>With this algorithm in place I decided to index all my 3000 songs. Instead of using the microphone you can just open mp3 files, convert them to the correct format, and read them the same way we did with the microphone, using an AudioInputStream. Converting stereo music into mono-channel audio was a bit trickier then I hoped. Examples can be found online (requires a bit too much code to paste here) have to change the sampling a bit.</p>



<p>The most important part of the program is the matching process. Reading Shazams paper they use hashing to get matches and the decide which song was the best match.</p>

<p>Instead of using difficult point-groupings in time I decided to use a line of our data (for example “33, 47, 94, 137”) as one hash: 1370944733</p>

<p>Example hash-code using 4 points per line:</p>

<figure><pre><code data-lang="java"><span>//Using a little bit of error-correction, damping
</span>
<span>private</span> <span>static</span> <span>final</span> <span>int</span> <span>FUZ_FACTOR</span> <span>=</span> <span>2</span><span>;</span>

<span>private</span> <span>long</span> <span>hash</span><span>(</span><span>String</span> <span>line</span><span>)</span> <span>{</span>
    <span>String</span><span>[]</span> <span>p</span> <span>=</span> <span>line</span><span>.</span><span>split</span><span>(</span><span>&#34;\t&#34;</span><span>);</span>
    <span>long</span> <span>p1</span> <span>=</span> <span>Long</span><span>.</span><span>parseLong</span><span>(</span><span>p</span><span>[</span><span>0</span><span>]);</span>
    <span>long</span> <span>p2</span> <span>=</span> <span>Long</span><span>.</span><span>parseLong</span><span>(</span><span>p</span><span>[</span><span>1</span><span>]);</span>
    <span>long</span> <span>p3</span> <span>=</span> <span>Long</span><span>.</span><span>parseLong</span><span>(</span><span>p</span><span>[</span><span>2</span><span>]);</span>
    <span>long</span> <span>p4</span> <span>=</span> <span>Long</span><span>.</span><span>parseLong</span><span>(</span><span>p</span><span>[</span><span>3</span><span>]);</span>
    <span>return</span>  <span>(</span><span>p4</span><span>-(</span><span>p4</span><span>%</span><span>FUZ_FACTOR</span><span>))</span> <span>*</span> <span>100000000</span> <span>+</span> <span>(</span><span>p3</span><span>-(</span><span>p3</span><span>%</span><span>FUZ_FACTOR</span><span>))</span> <span>*</span> <span>100000</span> <span>+</span> <span>(</span><span>p2</span><span>-(</span><span>p2</span><span>%</span><span>FUZ_FACTOR</span><span>))</span> <span>*</span> <span>100</span> <span>+</span> <span>(</span><span>p1</span><span>-(</span><span>p1</span><span>%</span><span>FUZ_FACTOR</span><span>));</span>
<span>}</span></code></pre></figure>

<p>Now I create two data sets:</p>

<p>- A list of songs, List<string> (List index is Song-ID, String is songname)  
\- Database of hashes: Map&lt;Long, List<datapoint>&gt;</datapoint></string></p>

<p>The long in the database of hashes represents the hash itself, and it has a bucket of DataPoints.</p>

<p>A DataPoint looks like:</p>

<figure><pre><code data-lang="java"><span>private</span> <span>class</span> <span>DataPoint</span> <span>{</span>

    <span>private</span> <span>int</span> <span>time</span><span>;</span>
    <span>private</span> <span>int</span> <span>songId</span><span>;</span>

    <span>public</span> <span>DataPoint</span><span>(</span><span>int</span> <span>songId</span><span>,</span> <span>int</span> <span>time</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span><span>songId</span> <span>=</span> <span>songId</span><span>;</span>
        <span>this</span><span>.</span><span>time</span> <span>=</span> <span>time</span><span>;</span>
    <span>}</span>
	
    <span>public</span> <span>int</span> <span>getTime</span><span>()</span> <span>{</span>
        <span>return</span> <span>time</span><span>;</span>
    <span>}</span>
    <span>public</span> <span>int</span> <span>getSongId</span><span>()</span> <span>{</span>
        <span>return</span> <span>songId</span><span>;</span>
    <span>}</span>
<span>}</span></code></pre></figure>

<p>Now we already have everything in place to do a lookup. First I read all the songs and generate hashes for each point of data. This is put into the hash-database.</p>

<p>There is just one problem, for each hash there are some hits, but how do we determine which song is the correct song..? Looking at the amount of matches? No, this doesn’t work…</p>

<p>By looking at the data I discovered something interesting, because we have the following data:</p>

<p>- A hash of the recording</p>

<p>Now we can substract the current time in our recording (for example, line 34) with the time of the hash-match (for example, line 1352). This difference is stored together with the song ID. Because this offset, this difference, tells us where we possibly could be in the song.</p>



<p>For example, when listening to The Kooks - Match Box for just 20 seconds, this is the output of my program:</p>

<figure><pre><code data-lang="text">Done loading: 2921 songs

Start matching song...

Top 20 matches:

01: 08_the_kooks_-_match_box.mp3 with 16 matches.
02: 04 Racoon - Smoothly.mp3 with 8 matches.
03: 05 Röyksopp - Poor Leno.mp3 with 7 matches.
04: 07_athlete_-_yesterday_threw_everyting_a_me.mp3 with 7 matches.
05: Flogging Molly - WMH - Dont Let Me Dia Still Wonderin.mp3 with 7 matches.
06: coldplay - 04 - sparks.mp3 with 7 matches.
07: Coldplay - Help Is Round The Corner (yellow b-side).mp3 with 7 matches.
08: the arcade fire - 09 - rebellion (lies).mp3 with 7 matches.
09: 01-coldplay-_clocks.mp3 with 6 matches.
10: 02 Scared Tonight.mp3 with 6 matches.
11: 02-radiohead-pyramid_song-ksi.mp3 with 6 matches.
12: 03 Shadows Fall.mp3 with 6 matches.
13: 04 Röyksopp - In Space.mp3 with 6 matches.
14: 04 Track04.mp3 with 6 matches.
15: 05 - Dress Up In You.mp3 with 6 matches.
16: 05 Supergrass - Can&#39;t Get Up.mp3 with 6 matches.
17: 05 Track05.mp3 with 6 matches.
18: 05The Fox In The Snow.mp3 with 6 matches.
19: 05_athlete_-_wires.mp3 with 6 matches.
20: 06 Racoon - Feel Like Flying.mp3 with 6 matches.

Matching took: 259 ms

Final prediction: 08_the_kooks_-_match_box.mp3.song with 16 matches.</code></pre></figure>

<p>It works!!</p>

<p>Listening for 20 seconds it can match almost all the songs I have. And even this <a href="http://www.youtube.com/watch?v=sLR9d4sMcq4">live recording of the Editors</a> could be matched to the correct song after listening 40 seconds!</p>

<p>Again it feels like magic! :-)</p>

<p>Currently, the code isn’t in a releasable state and it doesn’t work perfectly. It has been a pure weekend-hack, more like a proof-of-concept / algorithm exploration.</p>

<p>Maybe, if enough people ask about it, I’ll clean it up and release it somewhere.</p>



<p>The Shazam patent holders lawyers are sending me emails to stop me from releasing the code and removing this blogpost, read the story <a href="https://www.royvanrijn.com/blog/2010/07/patent-infringement/">here</a>.</p>


    </div></div>
  </body>
</html>
