<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://daniel.haxx.se/blog/2023/05/28/the-gemini-protocol-seen-by-this-http-client-person/">Original</a>
    <h1>The Gemini protocol seen by this HTTP client person</h1>
    
    <div id="readability-page-1" class="page"><div>
		
<p>There is again <a href="https://github.com/curl/curl/pull/11170">a pull-request</a> submitted to the curl project to bring support for <a href="https://en.wikipedia.org/wiki/Gemini_(protocol)">the Gemini protocol</a>. It seems like a worthwhile effort that I support, even if it is also a lot of work involved and it might take some time before it reaches the state in which it can be merged. A previous attempt at doing this was abandoned a while ago.</p>



<p>This renewed interest made me take a fresh tour through the current Gemini protocol spec and I decided to write down some observations for you. So here I am. These are comments based on my reading of the 0.16.1 version of the protocol spec. I have implemented Internet application protocols client side for some thirty years. I have not actually implemented the Gemini protocol.</p>



<h2>Motivations for existence</h2>



<p>Gemini is the result of a kind of a <em>movement</em> that tries to act against some developments they think are wrong on the current web. Gemini is not only a new wire protocol, but also features a new documentation format and more. They also say its not “the web” at all but a new thing. As a sign of this, the protocol is designed by the pseudonymous “Solderpunk” – and the IETF or other suitable or capable organizations have not been involved – <em>and it shows</em>.</p>



<h3>Counter surveillance</h3>



<p>Gemini has no cookies, no negotiations, no authentication, no compression and basically no (other) headers either in a stated effort to prevent surveillance and tracking. It instead insists on using TLS client certificates (!) for keeping state between requests.</p>



<p>A Gemini response from a server is just a two-digit response code, a single media type and the binary payload. Nothing else.</p>



<h3>Reduce complexity</h3>



<p>They insist that thanks to reduced complexity it enables more implementations, both servers and clients, and that seems logical. The reduced complexity however also makes it less visually pleasing to users and by taking shortcuts in the protocol, it <em>risks adding complexities elsewhere instead</em>. Its quite similar to going back to GOPHER.</p>



<h3>Form over content</h3>



<p>This value judgement is repeated among Gemini fans. They think “the web” favors form over content and they say Gemini intentionally is the opposite. It seems to be true because Gemini documents certainly are never visually very attractive. Like GOPHER.</p>



<p>But of course, the protocol is also so simple that it lacks the power to do a lot of things you can otherwise do on the web.</p>



<h2>The spec</h2>



<p>The only protocol specification is a <a href="https://gemini.circumlunar.space/docs/specification.gmi">single fairly short page</a> that documents the over-the-wire format mostly in plain English (undoubtedly featuring interpretation conflicts),  includes the URL format specification (very briefly) and oddly enough also features the <code>text/gemini</code> media type: a new document format that is “<em>a kind of lightweight hypertext format, which takes inspiration from gophermaps and from Markdown</em>“.</p>



<p>The spec says “<em>Although not finalised yet, further changes to the specification are likely to be relatively small</em>.” The protocol itself however has no version number or anything and there is no room for doing a Gemini v2 in a forward-compatible way. This way of a “living document” seems to be popular these days, even if rather problematic for implementers.</p>



<h2>Gopher revival</h2>



<p>The Gemini protocol reeks of GOPHER and HTTP/0.9 vibes. Application protocol style anno mid 1990s with TLS on top. Designed to serve single small text documents <em>from servers you have a relation to</em>.</p>



<h2>Short-lived connections</h2>



<p>The protocol enforces closing the connection after every response, forcibly making connection reuse impossible. This is terrible for performance if you ever want to get more than one resource off a server. I also presume (but there is no mention of this in the spec) that they discourage use of TLS session ids/tickets for subsequent transfers (since they can be used for tracking), making subsequent transfers even slower.</p>



<p>We know from HTTP and a primary reason for the <a href="https://www.rfc-editor.org/rfc/rfc2068">introduction of HTTP/1.1</a> back in 1997 that doing short-lived bursty TCP  connections makes it almost impossible to reach high transfer speeds due to the slow-starts. Also, re-doing the TCP and TLS handshakes over and over could  also be seen a plain energy waste.</p>



<p>The main reason they went with this design seem to be to avoid having a way to signal the size of payloads or do some kind of “chunked” transfers. Easier to document and to implement: yes. But also slower and more wasteful.</p>



<p>Serving an average HTML page using a number of linked resources/images over this protocol is going to be <em>significantly slower</em> than with HTTP/1.1 or later. Especially for servers far away. My guess is that people will not serve “normal” HTML content over this protocol.</p>



<p>Gemini only exists done over TLS. There is no clear text version.</p>



<h2>GET-only</h2>



<p>There are no other methods or ways to send data to the server besides the query component of the URL. There are no POST or PUT equivalents. There is basically only a GET method. In fact, there is no method at all but it is implied to be “GET”.</p>



<p>The request is also size-limited to a 1024 byte URL so even using the query method, a Gemini client cannot send much data to a server. More on the URL further down.</p>



<h2>Query</h2>



<p>There is a mechanism for a server to send back a single-line prompt asking for “text input” which a client then can pass to it in the URL query component in a follow-up request. But there is no extra meta data or syntax, just a single line text prompt (no longer than 1024 bytes) and free form “text” sent back.</p>



<p>There is nothing written about how a client should deal with the <em>existing</em> query part in this situation. Like if you want to send a query <em>and</em> answer the prompt. Or how to deal with the fact that the entire URL, including the now added query part, still needs to fit within the URL size limit.</p>



<p>Better use a short host name and a short path name to be able to send as much data as possible.</p>



<h2>TOFU</h2>



<blockquote>
<p>the strongly RECOMMENDED approach is to implement a lightweight “TOFU” certificate-pinning system which treats self-signed certificates as first- class citizens.</p>
<cite>(From the Gemini protocol spec 0.16.1 section 4.2)</cite></blockquote>



<p>Trust on first use (TOFU) as a concept works fairly well when you interface a limited set of servers with which you have some relationship. Therefore it often works fine for SSH for example. (I say “fine” for even with ssh, people often have the habit of just saying yes and accepting changed keys even when they perhaps should not.)</p>



<p>There are multiple problems with doing TOFU for a client/server document browsing system like Gemini.</p>



<p>A challenge is of course that on the first visit a client cannot spot an impostor, and neither can it when the server updates its certificates down the line. Maybe an attacker did it? It trains users on just saying “yes” when asked if they should trust it. Since you as a user might not have a clue about how runs that particular server or whatever the reason is why the certificate changes.</p>



<p>The concept of storing certificates to compare against later is a scaling challenge in multiple dimensions:</p>



<ul>
<li>Certificates need to be stored for a long time (years?)</li>



<li>Each host name + port number combination has its own certificate. In a world that goes beyond thousands of Gemini hosts, this becomes a challenge for clients to deal with in a convenient (and fast) manner.</li>



<li>Presumably each user on a system has its own certificate store. What user A trusts, user B does not necessarily have to trust.</li>



<li>Does each Gemini client keep its own certificate store? Do they share? Who can update? How do they update the store? What’s the file format? A common db somehow?</li>



<li>When storing the certificates, you might also want to do like modern SSH does: not store the host names in cleartext as it is a rather big privacy leak showing exactly which servers you have visited.</li>
</ul>



<p>I strongly suspect that many existing Gemini clients avoid this huge mess by simply not verifying the server certificates at all or by just storing the certificates temporarily in memory.</p>



<p>You can opt to store a hash or fingerprint of the certificate instead of the whole one, but that does not change things much.</p>



<p>I think insisting on TOFU is one of Gemini’s weakest links and I cannot see how this system can ever scale to a larger audience or even just many servers. I foresee that they need to accept Certificate Authorities or use <a href="https://en.wikipedia.org/wiki/DNS-based_Authentication_of_Named_Entities">DANE</a> in a future.</p>



<h2>Gemini Proxying</h2>



<p>By insisting on passing on the entire URL in the requests, it is primarily a way to solve name based virtual hosting, but it is also easy for a Gemini server to act as a proxy for other servers. On purpose. And maybe I should write “easy”.</p>



<p>Since Gemini is (supposed to be) end-to-end TLS, proxying requests to another server is not actually possible while also maintaining security. The proxy would have to for example respond with the certificate retrieved from the remote server (in addition to its own) but the spec mentions nothing of this so we can guess existing clients and proxies don’t do it. I <em>think</em> this can be fixed by just adjusting the spec. But would add some rather kludgy complexity for a maybe a not too exciting feature.</p>



<p>Proxying to <code>gopher://</code> URLs should be possible with the existing wording because there is no TLS to the server end. It could also proxy <code>http://</code> URLs too but risk having to download the entire thing first before it can send the response.</p>



<h2>URLs</h2>



<p>The Gemini URL scheme is explained in 138 words, which is of course very tense and assumes quite a lot. It includes “<em>This scheme is syntactically compatible with the generic URI syntax defined in RFC 3986</em>“.</p>



<p>The spec then goes on to explain that the URL needs be <strong>UTF-8 encoded</strong> when sent over the wire, which I find peculiar because a normal RFC 3986 URL is just a set of plain octets. A Gemini client thus needs to know the charset that was used for or to assume for the original URL in order to convert it to UTF-8. </p>



<p>Example: if there is a <code>%C5</code> in the URL and the charset was ISO-8859-1. That means the octet is a LATIN CAPITAL LETTER A WITH RING ABOVE. The UTF-8 version of said character is the two-byte sequence <strong>0xC3 0x85</strong>. But if the original charset instead was ISO-8859-6, the same <code>%C5</code> octet means ARABIC LETTER ALEF WITH HAMZA BELOW, encoded as <strong>0xD8 0xA5</strong> in UTF-8.</p>



<p>To me this does not rhyme well with <em>reduced complexity</em>. This conversion alone will cause challenges when done in curl because applications pass an RFC 3986 URL to the library and it does not currently have enough information on how to convert that to UTF-8. Not to mention that libcurl completely lacks UTF-8 conversion functions.</p>



<p>This makes me suspect that the intention is probably that only the <em>host name</em> in the URL should be UTF-8 encoded for IDN reasons and the rest should be left as-is? The spec could use a few more words to explain this.</p>



<p>One of the Gemini clients that I checked out to see how they do this, in order to better understand the spec, even use the punycode version of the host name quoting “Pending possible Gemini spec change”. What is left to UTF-8 then? That client did not UTF-8 encode anything of the URL, which adds to my suspicion that people don’t actually follow this spec detail but rather just interoperate…</p>



<p>The UTF-8 converted version of the URL must not be longer than 1024 bytes when included in a Gemini request.</p>



<p>The fact that the URL size limit is for the UTF-8 encoded version of the URL makes it hard to error out early because the source version of the URL might be shorter than 1024 bytes only to have it grow past the size limit in the encoding phase.</p>



<h2>Origin</h2>



<p>The document is carelessly thinking “host name” is a good authority boundary to TLS client certificates, totally ignoring the fact that “the web” <a href="https://www.rfc-editor.org/rfc/rfc6454">learned this lesson</a> long time ago. It needs to restrict it to the host name <em>plus port number</em>. Not doing that opens up Gemini for rather bad security flaws. This can be fixed by improving the spec.</p>



<h2>Media type</h2>



<p>The <code>text/gemini</code> media type should simply be moved out the protocol spec and be put elsewhere. It documents content that may or may not be transferred over Gemini. Similarly, we don’t document HTML in the HTTP spec.</p>



<h2>Misunderstandings?</h2>



<p>I am fairly sure that once I push publish on this blog post, some people will insist that I have misunderstood parts or most of the protocol spec. I think that is entirely plausible and kind of my point: the spec is written in such an open-ended way that it will not avoid this. We basically cannot implement this protocol by only reading the spec.</p>



<h2>Future?</h2>



<p>It is impossible to tell if this will fly for real or not. This is not a protocol designed for the masses to replace anything at high volumes. That is of course totally fine and it can still serve its community perfectly fine. There seems to be interest enough to keep the protocol and ecosystem alive for the moment at least. Possibly for a long time into the future as well.</p>



<h2>What I would change</h2>



<p>As I believe you might have picked up by now, I am not a big fan of this protocol but I still believe it can work and serve its community. If anyone would ask me, here are a few things I would consider changing in order to take it up a few notches.</p>



<ol>
<li>Split the spec into three separate ones: protocol, URL syntax, media type. Expand the protocol parts with more exact syntax descriptions and examples to supplement the English.</li>



<li>Clarify the client certificate use to be origin based, not host name.</li>



<li>Drop the TOFU idea, it makes for a too weak security story that does not scale and introduces massive complexities for clients.</li>



<li>Clarify the UTF-8 encoding requirement for URLs. It is confusing and possibly bringing in a lot of complexity. Simplify?</li>



<li>Clarify how proxying is actually supposed to work in regards to TLS and secure connections. Maybe drop the proxy idea completely to keep the simplicity.</li>



<li>Consider a way to re-use connections, even if that means introducing some kind of “chunks” HTTP-style.</li>
</ol>
	</div></div>
  </body>
</html>
