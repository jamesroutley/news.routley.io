<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://madebyevan.com/algos/crdt-text-buffer/">Original</a>
    <h1>CRDT: Text Buffer</h1>
    
    <div id="readability-page-1" class="page"><div>
      <section>
        

  

  
  <p>
    Collaboratively editing strings of text is a common desire in peer-to-peer applications. For example, a note-taking
    app might represent each document as a single collaboratively-edited string of text.
  </p>
  <p>
    The algorithm presented here is one way to do this. It comes from a family of algorithms called
    <a href="https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type">CRDTs</a>, which I will not describe
    here. It&#39;s similar to the approaches taken by popular collaborative text editing libraries such as
    <a href="https://github.com/yjs/yjs">Yjs</a> and <a href="https://github.com/automerge/automerge">Automerge</a>.
    Other articles have already been written about these similar approaches (see the
    <a href="#references">references</a> section below), but this article also has a nice interactive visualization of
    what goes on under the hood.
  </p>
  <p>
    <b><i>The algorithm:</i></b>
  </p>
  <ul>
    <li>
      <p>
        Each character is assigned a unique identifier consisting of <code>site</code> (the identifier of the creator)
        and <code>clock</code> (a site-specific integer that is incremented after every operation) as well as a
        (possibly null) <code>parent</code> pointer to a previous character.
      </p>
    </li>
    <li>
      <p>
        To insert a character, set its <code>parent</code> pointer to the character immediately before the insertion
        point at the time of insertion (or to null when inserting at the beginning). The character order is determined
        by a pre-order tree traversal that places parents before their children. This is
        <a href="https://madebyevan.com/algos/crdt-tree-based-indexing/">tree-based indexing</a>.
      </p>
    </li>
    <li>
      <p>
        To order characters with the same parent, have each character also store a <code>counter</code> value and sort
        first by <code>counter</code> (use descending order), then by the <code>site</code> of the character (use
        arbitrary but consistent order). When inserting before a character with the same parent, use its counter
        incremented by 1 to be ordered before it. This order is unique because doing this means the same site will never
        reuse the same counter in the same spot.
      </p>
    </li>
    <li>
      <p>
        To delete a character, put that character&#39;s identifier in a deleted set. Note that this means deleted characters
        persist forever, which is known as a &#34;tombstone&#34; in CRDT literature. Deleted character values can be forgotten
        but the positions must be remembered to be able to correctly order incoming changes that use one of the
        now-deleted characters as a parent.
      </p>
    </li>
  </ul>
  <p>
    This is not as expensive as it sounds because of three important optimizations:
  </p>
  <ul>
    <li>
      <p>
        Successive inserts from the same site can all be merged into a single block in memory, so for example pasting a
        large chunk of text uses the same amount of metadata as inserting a single character. This works because
        character identifiers are carefully designed to be able to be implicit in a contiguous run of text (each
        character will the same <code>site</code> and <code>counter</code> and have a <code>clock</code> that&#39;s 1 more
        than the previous character&#39;s <code>clock</code>).
      </p>
    </li>
    <li>
      <p>
        These blocks of memory can be stored contiguously in a single array that&#39;s pre-sorted in document order.
        Inserting a new block just involves inserting into that array at the correct position. This avoids needing to
        store the tree data structure explicitly (e.g. with arrays of children and/or sibling pointers) and also takes
        advantage of CPU optimizations for reading memory sequentially.
      </p>
    </li>
    <li>
      <p>
        The delete set can be represented more efficiently using a range-based representation. A series of deletes with
        the same <code>site</code> and with consecutive <code>clock</code> values can be represented with a single
        range. Note that this range is contiguous in identifier-space but not necessarily in document-space.
      </p>
    </li>
  </ul>
  <p>
    Below is a demo of what this looks like in practice. Each quadrant represents a peer, and peers send messages to
    each other with a simulated network delay. Click on a peer&#39;s text to edit it. Temporarily disable the simulated
    network with the pause button to construct simultaneous editing scenarios. You can use your browser&#39;s &#34;view source&#34;
    feature to view the <a href="https://madebyevan.com/algos/crdt-text-buffer/crdt-text-buffer.js">source code for this demo</a>.
  </p>

  </section>
  
  <section>

    <p>
      This technique has the following benefits and drawbacks:
    </p>
    <p>
      <b>Benefits:</b>
    </p>
    <ul>
      <li>
        <p>Memory usage: The metadata overhead needed to track collaborative edits is reasonable and is also likely to
          compress well as it contains runs of similar values.</p>
      </li>
      <li>
        <p>Performance: It&#39;s possible to implement most of the queries and/or updates to the data structure in O(log n)
          time using either binary trees or arrays with binary search.</p>
      </li>
    </ul>
    <p>
      <b>Drawbacks:</b>
    </p>
    <ul>
      <li>
        <p>Complexity: The logic for splitting and merging is complicated and hard to implement correctly. Fuzz testing
          is likely essential for a correct implementation.</p>
      </li>
      <li>
        <p>Grow-only: Deleting data does not reduce the size of the metadata. Addressing this properly is quite
          challenging as it involves coordinating between peers to ensure data is only removed when it&#39;s no longer
          needed by any peer in the system. It also can break down when a peer goes offline and never comes back online,
          but the system supports peers being offline for arbitrary lengths of time. This algorithm does not attempt to
          address that problem.</p>
      </li>
    </ul>

    <p>
      <b id="references">References:</b>
    </p>
    <p>
      Here are some excellent resources on CRDT text buffers that I found helpful when implementing this algorithm:
    </p>
    <ul>
      <li>
        <a href="https://josephg.com/blog/crdts-go-brrr/">https://josephg.com/blog/crdts-go-brrr/</a>
        <p>Talks about how to implement text-based CRDTs efficiently. Covers some of the optimizations used here
          including storing runs of text together and storing insertions in a flat list.</p>
      </li>
      <li>
        <a href="http://archagon.net/blog/2018/03/24/data-laced-with-history/">http://archagon.net/blog/2018/03/24/data-laced-with-history/</a>
        <p>Goes over tree-based indexing (which it calls &#34;causal trees&#34;) in a lot of depth. Discusses a possible
          approach to distributed garbage collection as well as the complexities that come with it. Has lots of
          additional references at the bottom.</p>
      </li>
      <li>
        <a href="https://www.bartoszsypytkowski.com/yrs-architecture/">https://www.bartoszsypytkowski.com/yrs-architecture/</a>
        <p>Goes over the internals of Yjs in more detail, which is relevant because what I implemented is similar to
          what Yjs does. Some high-level differences are that a) Yjs doesn&#39;t store delete sets explicitly and sends all
          of them all over again each time syncing starts and b) Yjs gives each insert an additional rightward pointer
          for resolving ordering between children with the same parent.</p>
      </li>
      <li>
        <a href="https://www.inkandswitch.com/peritext/">https://www.inkandswitch.com/peritext/</a>
        <p>&#34;Rich text&#34; involves attaching formatting attributes (e.g. bold or italic) to individual characters. Doing
          this in a collaborative environment requires careful algorithm to preserve the original human intention after
          an automatic merge. This article presents a way to do that.</p>
      </li>
    </ul>

    
    
    

      </section>
    </div></div>
  </body>
</html>
