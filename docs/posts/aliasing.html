<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://xania.org/202512/15-aliasing-in-general">Original</a>
    <h1>Aliasing</h1>
    
    <div id="readability-page-1" class="page"><div>
    <div>
        <h2>Aliasing</h2>

        <p>Written by me, proof-read by an LLM.
</p>
<p><a href="https://xania.org/202512/14-licm-when-it-doesnt">Yesterday</a> we ended on a bit of a downer: aliasing stopped optimisations dead in their tracks. I know this is supposed to be the <em>Advent of Compiler Optimisations</em>, not the <em>Advent of Compiler Giving Up</em>! Knowing why your compiler can’t optimise is just as important as knowing all the clever tricks it can pull off.</p>
<p>Let’s take a simple example of a counter class<sup id="fnref:actually"><a href="#fn:actually">1</a></sup>. It accumulates integers into a member variable <code>total</code>. I’ve used C++ templates to show two versions of the code: one that accumulates in an <code>int</code> and one that accumulates in an <code>long</code>.</p>


<p>At first glance, the two loop bodies look almost identical, as you might expect. In one case we’ll accumulate in <code>eax</code>, and the other in <code>rax</code>, right? The truth is more subtle. Let’s first look at the <code>int</code> case:</p>
<div><pre><code><span>  </span><span>mov</span><span> </span><span>eax</span><span>,</span><span> </span><span>DWORD</span><span> </span><span>PTR</span><span> </span><span>[</span><span>rdi</span><span>]</span><span>      </span><span>; eax = total</span>
<span>.L3:</span>
<span>  </span><span>add</span><span> </span><span>eax</span><span>,</span><span> </span><span>DWORD</span><span> </span><span>PTR</span><span> </span><span>[</span><span>rsi</span><span>]</span><span>      </span><span>; add element to total</span>
<span>  </span><span>add</span><span> </span><span>rsi</span><span>,</span><span> </span><span>4</span><span>                    </span><span>; move to next element</span>
<span>  </span><span>mov</span><span> </span><span>DWORD</span><span> </span><span>PTR</span><span> </span><span>[</span><span>rdi</span><span>],</span><span> </span><span>eax</span><span>      </span><span>; total = eax</span>
<span>  </span><span>cmp</span><span> </span><span>rsi</span><span>,</span><span> </span><span>rdx</span><span>                  </span><span>; are we finished?</span>
<span>  </span><span>jne</span><span> </span><span>.L3</span><span>                       </span><span>; loop if not</span>
<span>  </span><span>ret</span>
</code></pre></div>

<p>Looks pretty reasonable, right? Now let’s look at the <code>long</code> version:</p>
<div><pre><code><span>  </span><span>mov</span><span> </span><span>rax</span><span>,</span><span> </span><span>QWORD</span><span> </span><span>PTR</span><span> </span><span>[</span><span>rdi</span><span>]</span><span>      </span><span>; rax = total</span>
<span>.L9:</span>
<span>  </span><span>movsx</span><span> </span><span>rdx</span><span>,</span><span> </span><span>DWORD</span><span> </span><span>PTR</span><span> </span><span>[</span><span>rsi</span><span>]</span><span>    </span><span>; read &amp; sign extend next element</span>
<span>  </span><span>add</span><span> </span><span>rsi</span><span>,</span><span> </span><span>4</span><span>                    </span><span>; move to next element</span>
<span>  </span><span>add</span><span> </span><span>rax</span><span>,</span><span> </span><span>rdx</span><span>                  </span><span>; rax += element</span>
<span>  </span><span>cmp</span><span> </span><span>rcx</span><span>,</span><span> </span><span>rsi</span><span>                  </span><span>; are we finished?</span>
<span>  </span><span>jne</span><span> </span><span>.L9</span><span>                       </span><span>; loop if not</span>
<span>  </span><span>mov</span><span> </span><span>QWORD</span><span> </span><span>PTR</span><span> </span><span>[</span><span>rdi</span><span>],</span><span> </span><span>rax</span><span>      </span><span>; total = rax</span>
<span>  </span><span>ret</span><span>                           </span><span>; return</span>
</code></pre></div>

<p>The first change from the 32-bit case you’ll notice is the <code>movsx</code> to turn the 32-bit signed integer into a 64-bit signed integer. That’s all but free on modern CPUs, and so while it looks like the loop is doing more work than the 32-bit version, it’s not as bad as it seems.</p>
<p>The important difference here is the update of <code>total</code>: In the first version, each loop iteration updates the member variable <code>total</code>. In the second version everything remains in registers until the end of the loop, and then <code>total</code> is only updated at the end. CPU caches are super fast, but it’s still best to avoid redundant stores in hot loops!</p>
<p>So, why this difference? Of course it’s aliasing: In the <code>int</code> version the compiler can’t be sure that the <code>span</code> passed in to <code>count</code> doesn’t cover the <code>Counter</code>’s member variable <code>total</code>. They are the same type, and so that would be perfectly OK by the type-based aliasing rules of C++.</p>
<p>In the <code>long</code> version, the types differ (<code>int</code> vs <code>long</code>), and under C++’s strict aliasing rules, it would be undefined behaviour for them to overlap in memory. Since the compiler can assume the program doesn’t invoke undefined behaviour, it knows they don’t alias and can safely optimise. That lets it cache the <code>total</code> in a register and only update the member variable at the end. As we’ll see later in the series, being aliasing-free helps other optimisations too, like vectorisation.</p>
<p>To fix this issue, we have a couple of choices. The easy way would be to rewrite to accumulate in a local variable, and then update the total at the end: Using <code>total += std::accumulate(span.begin(), span.end(), 0)</code> would fix this <em>and</em> be more intention-revealing.</p>
<p>The other, non-standard way to work around this issue is to use <code>__restrict</code>. This GNU extension (borrowed from C) lets us decorate pointers and essentially promises that this pointer uniquely refers to the object it points at. In our case, the thing we need to prove is unique is the <code>Counter</code>’s “this pointer” itself. Adding <code>__restrict</code> after the parameter list (where you would add <code>const</code> for a const member function) works. But again - this is very non-standard, so use at your peril<sup id="fnref:vectorise"><a href="#fn:vectorise">2</a></sup>.</p>
<p>Aliasing is one of C++’s sneakier gotchas, especially when you’re working with base types like <code>int</code> and <code>float</code> - you can’t avoid using them, and they’re prime candidates for aliasing with each other<sup id="fnref:rust"><a href="#fn:rust">3</a></sup>. It’s perfectly legal to have overlapping same-type pointers, so the compiler assumes the worst and peppers your hot loops with memory accesses. The fix may be as simple as only using local variables within your loop - but first you have to spot it. Fire up <a href="https://godbolt.org">Compiler Explorer</a>, look for those unexpected writes to memory when you’d expect everything to stay in registers, and you’ll know when aliasing is holding you back!</p>
<p><em>See <a href="https://youtu.be/PPJtJzT2U04">the video</a> that accompanies this post.</em></p>
<hr/>
<p><em>This post is day 15 of <a href="https://xania.org/AoCO2025">Advent of Compiler Optimisations 2025</a>,
a 25-day series exploring how compilers transform our code.</em></p>
<p><em>This post was written by a human (<a href="https://xania.org/MattGodbolt">Matt Godbolt</a>) and reviewed and proof-read by LLMs and humans.</em></p>
<p><em>Support Compiler Explorer on <a href="https://patreon.com/c/mattgodbolt">Patreon</a>
or <a href="https://github.com/sponsors/compiler-explorer">GitHub</a>,
or by buying CE products in the <a href="https://shop.compiler-explorer.com">Compiler Explorer Shop</a></em>.</p>

    </div>
</div></div>
  </body>
</html>
