<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/SubscriberLink/882799/cb8f313c57c6d8a6/">Original</a>
    <h1>Handling argc==0 in the Linux kernel</h1>
    
    <div id="readability-page-1" class="page"><div>
<!-- $Id: slink-none,v 1.2 2005-11-04 22:11:18 corbet Exp $ -->
<blockquote>
<div>
<h3>Welcome to LWN.net</h3>
<p>
The following subscription-only content has been made available to you 
by an LWN subscriber.  Thousands of subscribers depend on LWN for the 
best news from the Linux and free software communities.  If you enjoy this 
article, please consider <a href="https://lwn.net/subscribe/">subscribing to LWN</a>.  Thank you
for visiting LWN.net!
</p></div>
</blockquote>
<p>
By now, most readers are likely to be familiar with the <a href="https://lwn.net/Articles/882609/">Polkit vulnerability</a> known as CVE-2021-4034.
The fix for Polkit is relatively straightforward and is being rolled out
across the net.  The root of this problem, though, lies in a
misunderstanding about how programs are run on Unix-like systems.  This
problem is highly likely to exist in other programs, so it would be nice to
find a more general solution.  The best place to address this issue may be
in the kernel, but properly working around this
misunderstanding without causing regressions is not an easy task.
</p><h4>I&#39;d like to have an argument, please</h4>
<p>
Most developers are familiar with the prototype of the main program as
expressed in the C language:
</p><pre>    int main(int argc, char *argv[], char *envp[]);
</pre>
<p>
The program is invoked with its command-line arguments in <tt>argv</tt> and
the environment in <tt>envp</tt>; both are pointers to null-terminated
arrays of
<tt>char *</tt> strings.  The number of non-null entries in
<tt>argv</tt> is stored in <tt>argc</tt>.  This API is a user-space
creation, though; what happens when the kernel first runs a program is a
little bit different: on Linux, that program is passed a single pointer to the
<tt>argv</tt> array.  The <tt>envp</tt> array begins immediately after the
<tt>NULL</tt> value that terminates <tt>argv</tt>.  Thus, in a C program,
the following statement will be true on entry to <tt>main()</tt>:
</p><pre>    envp == argv + argc + 1
</pre>
<p>
By convention, <tt>argv[0]</tt> is the name of the program that is being
executed, and many programs rely on that convention.  As it happens,
though, this convention is exactly that: a convention, but not a guarantee.
The actual contents of <tt>argv</tt> are entirely under the control of
whoever calls <a href="https://man7.org/linux/man-pages/man2/execve.2.html"><tt>execve()</tt></a>
to run the program in the first place, and that caller is not required to
put the program name in <tt>argv[0]</tt>.
</p><p>
Indeed, the caller is not required to provide <tt>argv[0]</tt> at all.  If
the <tt>argv</tt> array passed to <tt>execve()</tt> is empty (or the
<tt>argv</tt> pointer is simply <tt>NULL</tt>), the first pointer in the
new program&#39;s <tt>argv</tt> array will be <tt>NULL</tt>, 
and the <tt>envp</tt> array will start immediately thereafter.
Unfortunately, Polkit (or, more specifically, the setuid <tt>pkexec</tt> utility)
&#34;knew&#34; that <tt>argv[0]</tt> would always be present,
so it performed its argument processing by iterating over the <tt>argv</tt>
array starting at <tt>argv[1]</tt>.  If there are no arguments at all,
<tt>argv[1]</tt> is the same as <tt>envp</tt>, so <tt>pkexec</tt> was iterating
through its environment variables instead.  Throw in some in-place argument
modification (<tt>pkexec</tt> overwrites its <tt>argv</tt> array), and
<tt>pkexec</tt> could be convinced to rewrite its environment 
variables, thus bypassing the sanitizing of those variables done for setuid
programs.  At that point, the game was over.
</p><p>
This problem is not new, and neither is awareness of it.  Ryan Mallon <a href="https://ryiron.wordpress.com/2013/12/16/argv-silliness/">wrote about
it in 2013</a>, noting that &#34;<span>it does allow for some amusing behaviour
from setuid binaries</span>&#34;; he also evidently <a href="https://twitter.com/ryiron/status/1486207465918468097">sent a Polkit
patch</a> to address it, but that patch was never applied.  Even further
back, in 2007, Michael Kerrisk <a href="https://bugzilla.kernel.org/show_bug.cgi?id=8408">reported the
kernel&#39;s behavior as a bug</a>, but the report was closed with little
discussion.  So the problem persisted, culminating in the vulnerability
administrators are scrambling to patch now.
</p><h4>Toward a more general fix</h4>
<p>
Fixing this issue is a simple matter of making <tt>pkexec</tt> check that
<tt>argc</tt> is at least one.  But there are surely other programs out
there containing similar assumptions.  Given the strength of the
<tt>argv[0]</tt> convention, it is natural to ask whether it makes sense to
allow programs to be run with an empty <tt>argv</tt> array at all.  Perhaps
it doesn&#39;t, but the current API has a lot of history and cannot be changed
without a lot of thought.
</p><p>
Ariadne Conill <a href="https://lwn.net/ml/linux-kernel/20220126043947.10058-1-ariadne@dereferenced.org/">started
the linux-kernel discussion</a> with a patch that would simply disallow
calls to <tt>execve()</tt> without at least one <tt>argv</tt> entry.
Offending callers would get an <tt>EFAULT</tt> return value instead.  This would
solve the problem by providing a guarantee that <tt>argv</tt> would not be
empty, but at the potential cost of introducing problems of its own.
One is that, as Kees Cook <a href="https://lwn.net/ml/linux-kernel/39480927-B17F-4573-B335-7FCFD81AB997@chromium.org/">discovered</a>,
there is actually a fair amount of code out there that calls
<tt>execve()</tt> with an empty <tt>argv</tt> array.  Conill <a href="https://lwn.net/ml/linux-kernel/44b4472d-1d50-c43f-dbb1-953532339fb4@dereferenced.org/">wrote
those off</a> as &#34;<span>lazily-written test cases which should be
fixed</span>&#34;, but regressions in lazily-written test cases are still
regressions.  Also, as <a href="https://lwn.net/ml/linux-kernel/YfE%2FowUY+gVnn2b%2F@selene.zem.fi/">Heikki
Kallasjoki</a> and <a href="https://lwn.net/ml/linux-kernel/20220126132729.GA7942@brightrain.aerifal.cx/">Rich
Felker</a> both pointed out, an empty <tt>argv</tt> array is actually
allowed by the POSIX standard.
</p><p>
Felker also suggested an alternative with less potential for regressions:
only enforce a non-empty <tt>argv</tt> at privilege boundaries — when
<tt>execve()</tt> is being called to run a setuid program, in other words.
Cook <a href="https://lwn.net/ml/linux-kernel/202201261210.E0E7EB83@keescook/">said</a>
that he would rather avoid taking the privilege boundary into account if
possible, though.
He proposed <a href="https://lwn.net/ml/linux-kernel/20220126175747.3270945-1-keescook@chromium.org/">a
different solution</a> to the problem: inject an extra null pointer at the
end of an empty <tt>argv</tt> array so that even code that tries to skip
<tt>argv[0]</tt> will notice that there is nothing there.  This solution
will not work either, as it turns out: the ABI promise is that <tt>envp</tt> starts
immediately after <tt>argv</tt>, and the extra <tt>NULL</tt> breaks that
promise.  There are evidently programs that rely on that layout and would
break if it were changed.
</p><p>
Yet another approach, first <a href="https://lwn.net/ml/linux-kernel/877damwi2u.fsf@email.froward.int.ebiederm.org/">suggested</a>
by Eric Biederman, would be to replace an empty <tt>argv</tt> with one
containing a single pointer to an empty string.  This proposal had some
support (though nobody has implemented it as of this writing), but also
provoked some worries of its own.  Perhaps there are programs out there
that will respond badly to an empty-string argument, or which do something
special when <tt>argc</tt> is zero.  Changing the number of arguments
passed to the program run by <tt>execve()</tt> just looks like it could
create surprises.
</p><p>
Cook eventually <a href="https://lwn.net/ml/linux-kernel/202201261440.0C13601104@keescook/">summarized the
situation</a> this way:
</p><blockquote>
	Given the code we&#39;ve found that depends on NULL argv, I think we
	likely can&#39;t make the change outright, so we&#39;re down this weird
	rabbit hole of trying to reject what we can and create work-around
	behaviors for the cases that currently exist.
</blockquote>
<p>
That notwithstanding, he then went on to express a preference for the
initial change (simply 
disallowing a zero-argument <tt>execve()</tt> call anyway, albeit with an
<tt>EINVAL</tt> return rather than <tt>EFAULT</tt>), with a suggestion to
fix a <a href="https://valgrind.org/">Valgrind</a> test that is already
known to break with that restriction.

Conill responded <a href="https://lwn.net/ml/linux-kernel/20220127000724.15106-1-ariadne@dereferenced.org/">with
a new version of the original patch</a>; this time it emits a warning
before failing an empty-<tt>argv</tt> call to <tt>execve()</tt> with
<tt>EINVAL</tt>.  Cook <a href="https://lwn.net/ml/linux-kernel/202201262119.105FA8BCA9@keescook/">acked the
patch</a>, saying: &#34;<span>Let&#39;s do it and see what breaks</span>&#34;; Biederman
<a href="https://lwn.net/ml/linux-kernel/87r18tt952.fsf@email.froward.int.ebiederm.org/">concurred</a>:
&#34;<span>Especially since you are signing up to help fix the tests</span>&#34;.
</p><p>
That is where the discussion stands as of this writing, but it is far from
clear that this is how the problem will eventually be addressed.  This
patch has, crucially, not yet survived its first encounter with Linus
Torvalds, who may take a dim view of its potential for regressions.  It
<i>is</i> an ABI change, after all, and there may well be code out there
that responds badly to it, though the fact that BSD systems already
prohibit an empty <tt>argv</tt> will, with luck, have already shaken out
most of those. 
Should unfortunate regressions arise anyway, a different 
solution will almost certainly need to be found.</p>
               </div></div>
  </body>
</html>
