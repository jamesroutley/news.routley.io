<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/saulshanabrook/saulshanabrook/discussions/40">Original</a>
    <h1>bad research idea: false statements in e-graphs</h1>
    
    <div id="readability-page-1" class="page"><div role="presentation" data-paste-markdown-skip="">
    <tbody data-target-translation-id="11655144" data-target-translation-type="comment">
        <tr>
    <td>
        <p dir="auto">OK after much squinting at the progression of rewrite rules... I think I have found an example of where the logic goes wrong.</p>
<p dir="auto">Can you spot the error?</p>
<a target="_blank" rel="noopener noreferrer" href="https://private-user-images.githubusercontent.com/1186124/398305556-c3b64a4a-2e74-4180-9a4a-dfbbd6224b77.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MzUzNDE2MjMsIm5iZiI6MTczNTM0MTMyMywicGF0aCI6Ii8xMTg2MTI0LzM5ODMwNTU1Ni1jM2I2NGE0YS0yZTc0LTQxODAtOWE0YS1kZmJiZDYyMjRiNzcucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQVZDT0RZTFNBNTNQUUs0WkElMkYyMDI0MTIyNyUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNDEyMjdUMjMxNTIzWiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9YTc5MDA2MjAwOGFkZWNiYTg1Njg4YzYwNzlmOTFiOThkNGFlZjNjMDcwY2QxOTJmMGIxMWY2ODFkZGY3NWVkMyZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QifQ.yrRlhbj_QdhhnHiEEyGWioqSmd6NNttnXunJ2Ew-Fho"><img width="1324" alt="Screenshot 2024-12-23 at 10 06 52â€¯PM" src="https://private-user-images.githubusercontent.com/1186124/398305556-c3b64a4a-2e74-4180-9a4a-dfbbd6224b77.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MzUzNDE2MjMsIm5iZiI6MTczNTM0MTMyMywicGF0aCI6Ii8xMTg2MTI0LzM5ODMwNTU1Ni1jM2I2NGE0YS0yZTc0LTQxODAtOWE0YS1kZmJiZDYyMjRiNzcucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQVZDT0RZTFNBNTNQUUs0WkElMkYyMDI0MTIyNyUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNDEyMjdUMjMxNTIzWiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9YTc5MDA2MjAwOGFkZWNiYTg1Njg4YzYwNzlmOTFiOThkNGFlZjNjMDcwY2QxOTJmMGIxMWY2ODFkZGY3NWVkMyZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QifQ.yrRlhbj_QdhhnHiEEyGWioqSmd6NNttnXunJ2Ew-Fho"/></a>
<p dir="auto">The issue here is that the empty int list <code>TupleInt.EMPTY</code> is unified with <code>TupleInt(0, partial(lambda i, self, j: Int.if_(j == self.length(), i, self[j])), 101, TupleInt.empty)</code> aka <code>TupleInt(0, lambda j: Int.if_(j == 0, 101, TupleInt.EMPTY[j])))</code></p>
<p dir="auto">Now let&#39;s say we do a naive index the empty list like <code>TupleInt.EMPTY[0]</code>. We could say this incorrect, or how we can represent it is that it unifies with <code>Int.NEVER</code>. But it can show up in the e-graph, because in <code>if_</code> conditionals, the false branch can end up doing indexing that is not allowed. So we want it to not mess things up.</p>
<p dir="auto">And in this case then, it will evaluate to <code>(lambda j: Int.if_(j == 0, 101, TupleInt.EMPTY[j])))(0)</code> which is <code>Int.if_(0 == 0, 101, TupleInt.EMPTY[0]))</code> which is <code>101</code>... So then what we get is that <code>101</code> is unified with <code>Int.NEVER</code> which... isn&#39;t good! Is really bad! Because it means all numbers can be unified together basically, i.e. false is true whatever.</p>
<p dir="auto">So how do we fix this? We can see that our normal indexing replacement is <code>TupleInt(l, idx_fn)[idx] -&gt; idx_fn(idx)</code> gives us this issue, when we substitute <code>0</code> in to the indexing function and compare against 0... We want that comparison to never resolve, because the index is invalid in this case. It shouldn&#39;t ever index.</p>
<p dir="auto">So we could do something like &#34;only do a replacement of the indexing function when the index is in the correct range&#34; but this forces us to add <code>in_range(i, length)</code> as a node to the graph and then condition on that... Which I guess we could do. But it means we will never resolve an indexing function if we have just some var <code>t[Int.var(&#39;x&#39;)]</code>... So I think another thing we could do is to basically say &#34;rewrite it to call the index function, but the index function is only defined over the domain of valid indexes, so assert the index is valid first&#34; so like <code>TupleInt(l, idx_fn)[idx] -&gt; idx_fn(assert_valid_idx(idx, l))</code> where <code>assert_valid_idx</code> will resolve to the index itself if we can prove its valid (between 0 and the length). Otherwise it is kept unresolved.</p>
<p dir="auto">Full debug visualizer: <a href="https://gist.github.com/saulshanabrook/767a1df922ebca071b1d5dae092bff58">https://gist.github.com/saulshanabrook/767a1df922ebca071b1d5dae092bff58</a></p>
    </td>
  </tr>

    </tbody>
  </div></div>
  </body>
</html>
