<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://seriot.ch/projects/pschess.html">Original</a>
    <h1>PSChess â€“ A chess engine in PostScript</h1>
    
    <div id="readability-page-1" class="page">
<h3>seriot.ch</h3>
<h4><a href="https://seriot.ch/">About</a> | <a href="https://seriot.ch/projects/index.html">Projects</a> | <a href="https://seriot.ch/trail/">Trail</a></h4>

<p>Here is a quick overview about the making and inner working of PSChess.</p>
<p>GitHub repo: <a href="https://github.com/nst/PSChess">https://github.com/nst/PSChess</a></p>
<p>See also my remarks about <a href="https://seriot.ch/projects/programming_in_postscript.html">programming in PostScript</a>.</p>
<h4>Motivation</h4>
<ul>
<li>To what extend can we execute arbitrary code on a printer?</li>
<li>How to implement a chess engine in PostScript?</li>
<li>Can you play chess against your printer?</li>
</ul>
<h4>Usage</h4>
<p>You can use PSChess in GhostScript with the following arguments:</p>
<pre><code>$ gs -DNOSAFER -dBATCH -dNOPAUSE -sDEVICE=pdfwrite -sOutputFile=&#34;%d.pdf&#34; main.ps
</code></pre>
<p>The user plays by entering moves like <code>d2d4</code>.</p>
<p>The output is produced on both the console and PDF documents.</p>
<p>Console output:</p>
<pre><code>r...r...        black h8 e8
pppkb.Q.        320
..bqp...
...p..Np        P...............
...B.Pn.        npp.............
..P...PB
PP.NP..P        -
..KR...R        white turn
</code></pre>
<p>PDF output:</p>
<p><img src="https://seriot.ch/images/pschess/pschess.png" width="700"/></p>
<h4>Limitations</h4>
<ul>
<li>human plays white, computer plays black</li>
<li>pawns convert into queens only</li>
</ul>
<h4>Project Status</h4>
<p>The project can be broken down in five steps:</p>
<ol>
<li>draw a chess board</li>
<li>implement a user interface so that user can move pieces</li>
<li>implement chess game rules and logic</li>
<li>implement an algorithm so that the computer can play</li>
<li>run the program on a printer, prompting user for the next move</li>
</ol>
<p>All 4 first steps are done. You can play chess agaist <a href="https://www.ghostscript.com/">GhostScript</a>, a PostScript interpreter.</p>
<p>I&#39;ve started working on step 5 (see <a href="https://seriot.ch/projects/programming_in_postscript.html#3">Programming in PostScript</a> but I&#39;m not totally sure yet about the actuably feasibility.</p>
<h4>Program Structure</h4>
<p>PSChess code is structured in three files:</p>
<pre><code>logic_board.ps  - data structure and primitives to deal with the board
logic_chess.ps  - chess rules, evaluation function, min-max algorithm
drawing.ps      - draw chess board and game state
</code></pre>
<p>And three consumers of these basic layers:</p>
<pre><code>main.ps         - user input
tests_logic.ps  - unit tests
tests_visual.ps - visual tests to check possible moves
</code></pre>
<p>Or in a software layer diagram:</p>
<p><img src="https://seriot.ch/images/pschess/layer_diagram.png" width="700"/></p>
<h4>The Board</h4>
<p>The board is represented by a PostScript string:</p>
<pre><code>(\
rnbqkbnr\
pppppppp\
........\
........\
........\
........\
PPPPPPPP\
RNBQKBNR\
)
</code></pre>
<p>Pieces are moved with the <code>putinterval</code> instruction. Moving black pawn from a7 to a6 is:</p>
<pre><code>board 16 (p) putinterval
board  8 (.) putinterval
</code></pre>
<p>The game state is kept in a dictionary. It mostly consist in the board, the current player and the captured pieces. </p>
<h4>Pieces Moves</h4>
<p>Pieces moves are encoded with their offsets, postive and negative. A moving procedure implements capture rules and ensures that pieces cannot go off the board.</p>
<pre><code>/DirectionsForPiece
&lt;&lt;
    /N -8 def
    /E  1 def
    /S  8 def
    /W -1 def

    (P) [N N N add N W add N E add]
    (p) [S S S add S E add  S W add]
    (n) [N N E add add
         E N E add add
         E S E add add
         S S E add add
         S S W add add
         W S W add add
         W N W add add
         N N W add add]
    (b) [N E add S E add S W add N W add]
    (r) [N E S W]
    (q) [N E S W N E add S E add S W add N W add]
    (k) [N E S W N E add S E add S W add N W add]
    (.) []
&gt;&gt; def
</code></pre>
<h4>Document UI</h4>
<p>In addition to the text UI, PSChess will show a page after each and every move.</p>
<p>When it will be working on an actual printer, a page will be printed after each and every move.</p>
<h4>Drawing</h4>
<p>All pieces are drawn in a vector format on a 20x20 grid.</p>
<pre><code>/PiecesPathsDict
&lt;&lt;
    /m { moveto } bind def
    /l { lineto } bind def

    /p { newpath SQUARE_SIZE 2 div SQUARE_SIZE 2 div 4 0 360 arc closepath }

    /r { newpath 5 15 m 7 15 l 7 13 l 9 13 l 9 15 l 11 15 l 11 13 l 13 13 l
         13 15 l 15 15 l 15 11 l 13 10 l 13 3 l 7 3 l 7 10 l 5 11 l 5 15 l
         closepath }

    /n { newpath 12 15 m 14 3 l 6 3 l 10 9 l 6 9 l closepath }

    /b { newpath 14 3 m 12 10 l 10 12 3 -30 30 arc
        10 12 l 10 12 3 80 210 arc 8 10 l 6 3 l closepath }

    /q { newpath 4 12 m 8 10 l 10 15 l 12 10 l 16 12 l 12 3 l 8 3 l closepath }

    /k { newpath 8 3 m 5 9 l 9 9 l 9 11 l 7 11 l 7 13 l 9 13 l 9 15 l 11 15 l
        11 13 l 13 13 l 13 11 l 11 11 l 11 9 l 15 9 l 12 3 l closepath }

    /. {}
&gt;&gt; def
</code></pre>
<h4>Evaluation Function</h4>
<p>Each board configuration can be evaluated. High positives values indicate that the configuration is best for white. Conversely, low negative values indicate that configuration is best for black.</p>
<p>PSChess implements the <a href="https://www.chessprogramming.org/Simplified_Evaluation_Function">simplified evaluation function</a> from Tomasz Michniewski.</p>
<p>In short, all pieces have an intrinsic value + a positional value, depending on where they stand on the board.</p>
<p>Intrinsic values:</p>
<pre><code>P = 100
N = 320 # knight
B = 330
R = 500
Q = 900
K = 20000
</code></pre>
<p>Positional value of white knights:</p>
<pre><code>-50,-40,-30,-30,-30,-30,-40,-50,
-40,-20,  0,  0,  0,  0,-20,-40,
-30,  0, 10, 15, 15, 10,  0,-30,
-30,  5, 15, 20, 20, 15,  5,-30,
-30,  0, 15, 20, 20, 15,  0,-30,
-30,  5, 10, 15, 15, 10,  5,-30,
-40,-20,  0,  5,  5,  0,-20,-40,
-50,-40,-30,-30,-30,-30,-40,-50,
</code></pre>
<p>So, a white knight on a2 is worth 320 - 20 = 300 points.</p>
<p>When computer plays, it considers all his possible moves, and plays the move that will minimize the best human answer to his move (min-max algorithm).</p>
<h4>Visual Tests</h4>
<p>Running the <code>tests_visual.ps</code> file contains a sample chessboard, iterates through all squares and output PDF files representing all possible moves.</p>
<p><img src="https://seriot.ch/images/pschess/pschess.gif" width="600"/></p>


</div>
  </body>
</html>
