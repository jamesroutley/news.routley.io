<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://smoores.dev/post/phonetic_matching/">Original</a>
    <h1>Phonetic Matching</h1>
    
    <div id="readability-page-1" class="page"><div><article><p>Nov. 12, 2024</p><section id="intro"><p>Just as heads up: This post starts out somewhat technical and includes a discussion of interesting algorithmic topics, like forced alignment and phonetic matching. But it ends by delving into some deeper social and human topics that might not be what everyone is looking for in a blog that’s mostly about software.</p><p>Recently, I’ve spent quite a lot of time working on<!-- --> <a href="https://smoores.gitlab.io/storyteller/">Storyteller</a>. It’s an open source, self-hostable platform for automatically syncing audiobooks and ebooks. You give Storyteller the ebook and audiobook files for the same book, and it spits out a new ebook file with the audio embedded, such that the text can be highlighted while the audio is playing. In order to do this, Storyteller has to answer a pretty challenging question:</p><blockquote>How do you automatically align the text with the corresponding audio?</blockquote></section><section id="forced-alignment"><p><span><span>In computer science</span></span>, this problem is called “forced alignment”, and there are multiple ways to approach it. Storyteller’s approach is to transcribe the audio to text — with timestamps for each word — and then use a fuzzy matching algorithm to attempt to line up each sentence in the text with the corresponding transcription. Since there are timestamps for each word in the transcription, this allows Storyteller to determine when a given sentence starts and ends in the audio.</p><p>Storyteller delegates the first part of this solution, transcribing the audio, to dedicated tools like<!-- --> <a href="https://github.com/openai/whisper">Whisper AI</a>. This is a very, very hard problem, and one that is genuinely best solved by large neural networks like Whisper. Even Whisper isn’t perfect, though, and even if it were, audiobook narrators don’t always perfectly narrate the written text. In fact, sometimes there are significant, intentional differences between the narration and what’s in the text version of the book!</p><p>To account for this, Storyteller has to use a fuzzy matching algorithm to attempt to determine which part of the transcription matches a given sentence. The basic idea is to walk through the text of the book one sentence at a time, and for each sentence, compare it to the next chunk of transcription and find the place that looks the least different. For example, in the book Moby Dick, The actual text of the book contains this sentence:</p><blockquote>Some years ago—never mind how long precisely—having little or no money in my purse, and nothing particular to interest me on shore, I thought I would sail about a little and see the watery part of the world.</blockquote><p>Which Whisper transcribed as this:</p><blockquote>Call me Ishmael. Some years ago, never mind how long precisely, having little or no money in my purse and nothing particular to interest me on sure. I thought I would sail about a little and see the watery part of the world. It is a way I have of driving off the spleen and regulating the circulation.</blockquote><p>Storyteller’s goal is to identify that the sentence starts at character 17 in the transcription, and ends at character 254, because that’s the closest match to the text. It must account for the fact that the transcription used commas instead of dashes in the first clause, the fact that “shore” was spelled “sure,” and the fact that the transcription breaks this sentence up into two sentences, with the first ending after the word “sure.” It does this using something called the<!-- --> <strong>Levenshtein distance</strong>, which is a measure of how many edits need to be made to one string of characters to turn it into another string. For example, the Levenshtein distance between the words “shore” and “sure” is 2, because we would need to make 2 edits to “shore” to turn it into “sure”:</p><ol><li><p>Replace the “o” with an “u”:<!-- --> <strong>shure</strong></p></li><li><p>Delete the “h”: <strong>sure</strong></p></li></ol><p>This example actually reveals a flaw with this approach for forced alignment: <em>English spelling is weird</em>. “Shore” and “sure” are pronounced almost identically, but they’re spelled differently. We had to make two edits to “shore,” which is only five letters long. This situation is fairly common, because transcription tools will often “mishear” a spoken word as a different, valid word, which may be spelled very differently, despite sounding similar.</p><p>For over a year, this has been the status quo for Storyteller. Levenshtein distance calculations were good enough for most use cases, and if sometimes Storyteller missed a sentence or two... well, it’s a fully automated process, it’ll never be perfect!</p><p>Then, about two weeks ago, a Storyteller user made a suggestion:</p><blockquote>Have you considering using Soundex or another phonetic encoding on both texts before performing the forced alignment? It can be used with Levenshtein distance and might be more robust to inaccurate transcriptions since you’re comparing similar sounding words rather than similar spellings of words.</blockquote><p>In fact, I had not considered using a phonetic encoding for Storyteller, because, of course, I had never <em>heard</em> of phonetic encodings. So, with shores on my mind, I started researching the world of phonetic encodings.</p></section><section id="phonetic-encoding"><p><span><span>In 1922</span></span>, Robert C. Russell and Margaret Kind Odell patented an algorithm called <strong>Soundex</strong>. It was a variation on a patent that Russell had acquired four years earlier, and it was part of a collection of indexing-related patents that Russell’s company owned and sold. They sold it to companies and government organizations as an indexing system that would group together names that were pronounced the same, even if they were spelled differently.</p><p>Years later, as part of President Franklin D. Roosevelt’s Works Progress Administration, a variation on the algorithm was developed and named “American Soundex”. It was initially used by the Census Bureau to assist in finding records for people who needed official proof of age, because many states did not have uniform birth registries. There was no guarantee that someone with the surname “Mayer” wouldn’t have been registered under the misspelled name “Meyer”, for example. But both “Mayer” and “Meyer” are encoded as<!-- --> <code>M600</code> in Soundex!</p><p>It’s worth noting that Soundex predates modern computing by several decades. At the time people manually encoded records by hand, which was part of why the algorithm was so simple. Since then, and especially in more recent years, with the explosion in computing power, several more elaborate phonetic encoding algorithms have been developed.</p><ul><li><p>In 1970, New York State introduced “New York State Identification and Intelligence System (NYSIIS)”, an improvement over the American Soundex system.</p></li><li><p>In 1985, genealogists Gary Mokotoff and Randy Daitch developed Daitch-Mokotoff Soundex, after encountering issues trying to apply the original Russell Soundex to Germanic and Slavic Jewish surnames.</p></li><li><p>In 1990, Lawrence Phillips — an analyst working at an insurance agency at the time — developed an alternative to Soundex, called Metaphone, which attempts to index words (not just names) by their English pronunciation. He now runs Anthropomorphic Software, a company that owns and sells licenses for Metaphone 3, the most recent iteration of this encoding algorithm.</p></li><li><p>In 2008, mathematician and genealogist Alexander Beider and computer and software engineer Stephen Morse developed the Beider-Morse Phonetic Matching algorithm to aid in their Jewish genealogical research.</p></li></ul><p>Beider-Morse Phonetic Matching (BMPM) stands out from the rest of the algorithms. The authors developed their own limited alphabet of phonetic tokens, and thousands of contextual rules for encoding. The results are remarkable. Taking a look at our “shore”/“sure” example from earlier, we can see that BMPM knows that they can be pronounced the same way, despite the different spelling:</p><div><div><p><code>&gt; encode(&#34;shore&#34;, approx)</code></p><ol><li>sDr</li><li>sor</li><li>sur</li><li>sDrY</li><li>sDri</li><li>sorY</li><li>sori</li><li>surY</li><li>suri</li></ol></div><div><p><code>&gt; encode(&#34;sure&#34;, approx)</code></p><ol><li>siur</li><li>siurY</li><li>siuri</li><li>sur</li><li>surY</li><li>suri</li></ol></div></div><p>The encodings for both words contain <code>sur</code>,<!-- --> <code>surY</code>, and <code>suri</code>. Without having to even use a Levenshtein distance-based matching step, we can already see that these words might be pronounced the same way. Even better, BMPM encodings include far fewer false positives than previous encodings, making them much more useful for automated searches, like the kind that Storyteller does.</p></section><section id="bmpm-jewishness"><p><span><span>In the paper announcing BMPM</span></span>, Morse walks through an example usage of the BMPM algorithm, using his own grandfather’s surname as the example query. He talks about how, years ago, he found “Grandpa Louis’s” immigration ship record by using microfilm readers and manually, physically searching through historical immigration records. Then, when the Ellis Island database was put online, he used the Datch-Mokotoff Soundex algorithm to search for names that sounded like “Matinsky”, his grandfather’s surname before he got married and changed it to Morse.</p><p>This new algorithm that he developed with Beider enabled him to find out that his grandfather had two cousins, Abraham and Judel, that lived in Manhattan. Their names had been transcribed by immigration agents as “Meistinsky”, rather than “Matinsky”.</p><p>Beider and Morse, and Daitch and Mokotoff before them, represent something integral about what it means to be a Jew in the Diaspora. Something about peeling back layers, about searching for connection and history in a world that has tried quite hard to remove them from us.</p></section><section id="yom-kippur"><p><span><span>This past Yom Kippur</span></span>, my wife and I drove two hours to spend the afternoon at my aunt’s house, with my cousins. As the night drew on, conversation roamed from television shows and books to politics and philosophy. The circle grew as we touched on increasingly sensitive and challenging topics, drawing us in.</p><p>We didn’t agree, per se. We were engaging in debate as often as we were engaging in conversation. But we all love each other deeply, and the amount of care and restraint that went into how each person expressed their disagreement was palpable.</p><p>The conversation died down as we started cleaning up from dinner and packing away the outdoor furniture. One of my cousins, with whom I had been in disagreement most during the group debates, came up to me, and we started talking again. As we did, we realized that we had both been fixated on the same thought recently: to be Jewish is to be constantly reminded that you might not be safe. Through that lens, our disagreements started to look… different. This was a lens through which she and I would always be able to understand each other. It’s a lens through which I can understand almost every Jewish person that I meet, no matter how little our other perspectives overlap.</p></section><section id="dachau"><p><span><span>On Morse’s website</span></span>, in addition to a BMPM index of the Ellis Island database, is an index of the Dachau Concentration Camp Records. Just another reminder. Another lens to see through.</p></section></article></div></div>
  </body>
</html>
