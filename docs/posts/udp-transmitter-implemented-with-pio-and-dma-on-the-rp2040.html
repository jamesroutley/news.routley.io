<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://vanhunteradams.com/Pico/Ethernet/UPD_TX.html">Original</a>
    <h1>UDP transmitter implemented with PIO and DMA on the RP2040</h1>
    
    <div id="readability-page-1" class="page"><div><div>
<div>
<h2 id="Objective">Objective<a href="#Objective">¶</a></h2><p>The objective for this project was to implement a UDP transmitter for use on the RP2040 that would consume <em>zero</em> CPU time. The system described on this webpage is implemented with 3 PIO state machines, 12 DMA channels, and 1 PWM channel. It generates an NLP, performs packet checksum calculations, and performs packet transactions with no CPU interaction beyond specifying the data which should be transmitted. It uses the unique ID for the flash chip to generate a MAC address for the RP2040.</p>
<p>For applications which don&#39;t require additional DMA channels (since they&#39;re all consumed by the UDP machine described below), the exclusive use of peripherals for UDP transactions should make for particularly simple integration into application code, and maximizes the data rate out of the RP2040. This was constructed as a piece of course infrastructure for <a href="https://ece4760.github.io">ECE 4760</a> at Cornell, for use in student projects.</p>
<p><strong><a href="https://github.com/vha3/Hunter-Adams-RP2040-Demos/tree/master/Ethernet/UDP_Transmitter">Link to git repo which contains all code</a></strong></p>

</div>
</div>
</div><div><div>
<div>
<h2 id="TLDR,-how-do-I-use-it?">TLDR, how do I use it?<a href="#TLDR,-how-do-I-use-it?">¶</a></h2><p>Please find some demo code <a href="https://github.com/vha3/Hunter-Adams-RP2040-Demos/tree/master/Ethernet/UDP_Transmitter">here</a>, and see the video below for a demonstration.</p>
<ol>
<li>Navigate to <code>udp_tx_parameters.h</code> and modify the UDP payload size, ethernet source/destination addresses, IP source/destination addresses, and source/destination ports, as necessary.</li>
</ol>
<!-- 
```c
// The size of the UDP payload (measured in bytes, set at compile time).
// This is what establishes the length of the udp_payload character array.
#define DEF_UDP_PAYLOAD_SIZE    (18)

// UDP payload (modified at runtime! this is just an initialization)
char udp_payload[DEF_UDP_PAYLOAD_SIZE] = "Hello from Pico: 0" ;

// Ethernet destination address (MAC)
unsigned char ethernet_destination[6] = {0x8c, 0xae, 0x4c, 0xde, 0x72, 0x91};
// Ethernet source address (auto-generated from Pico's unique flash ID)
// If you want to specify this, comment out GenerateUniqueMAC() from AssemblePacket().
unsigned char ethernet_source[6]      = {} ;

// IP source and destination addresses. Source address will be that of the Pico
unsigned char ip_source[4]  = {169, 254, 123, 101};
unsigned char ip_dest[4]    = {169, 254, 177, 93};

// UPD source and destination ports (set to a default of 1024)
unsigned char udp_src_port[2] = {0x04, 0x00} ; // 1024
unsigned char udp_dst_port[2] = {0x04, 0x00} ; // 1024
``` -->

<ol>
<li>In <code>main</code> for your application code, overclock to 240MHz <em>before you do anything else</em>. This is required to get the PIO state machine timing right.</li>
</ol>
<div><pre><span></span><span>set_sys_clock_khz</span><span>(</span><span>240000</span><span>,</span> <span>true</span><span>)</span> <span>;</span>
</pre></div>
<ol>
<li><p>Call <code>initUDP(unsigned int txminus_in, irq_handler_t handler)</code>. The first argument specifies the GPIO number which should be associated with the TX- line (the TX+ line will be mapped to this GPIO number, plus one). The second argument is the name of the interrupt service routine which should be called upon transmission completion.</p>
</li>
<li><p>Call <code>SEND_PACKET ;</code> to send a packet! You can modify the UDP data by modifying the values in the <code>udp_payload</code> array, and then calling <code>SEND_PACKET</code> again will transmit this new data. Each call to <code>SEND_PACKET</code> is non-blocking. Transmit complete will be signalled by entering the ISR that you specified in step 3.</p>
</li>
<li><p>Plug TX+ into pin 1 of an <a href="https://www.sparkfun.com/products/13021">RJ45 connector</a>, and TX- into pin 2. Plug an ethernet cable into this connector, and connect the other end to a device or switch.</p>
</li>
<li><p>For testing on your own computer, you can use this Python code (just make sure to change the IP and port number to whatever you specified in step 1, and the argument to sock.recv to whatever you specified as the <code>DEF_UDP_PAYLOAD_SIZE</code> in step 1)</p>
</li>
</ol>
<div><pre><span></span><span>import</span> <span>socket</span>

<span>sock</span> <span>=</span> <span>socket</span><span>.</span><span>socket</span><span>(</span><span>socket</span><span>.</span><span>AF_INET</span><span>,</span> <span>socket</span><span>.</span><span>SOCK_DGRAM</span><span>)</span>
<span>sock</span><span>.</span><span>bind</span><span>((</span><span>&#39;169.254.177.93&#39;</span><span>,</span> <span>1024</span><span>))</span>  <span># (host, port) because AF_INET</span>
<span>print</span><span>(</span><span>&#34;Listening...&#34;</span><span>)</span>

<span>while</span> <span>True</span><span>:</span>
    <span>print</span><span>(</span><span>sock</span><span>.</span><span>recv</span><span>(</span><span>18</span><span>))</span> <span># buffer size</span>
</pre></div>

</div>
</div>
</div><div><div>
<div>
<h2 id="System-overview">System overview<a href="#System-overview">¶</a></h2><p>Though the UDP transmitter described on this webpage supports dynamic modification of the source and destination addresses for transactions, it is optimized for static source address, destination address, and payload size. The user configures these parameters, and the only portion of the packet which is modified by the user application code during runtime is the UDP data (which can be done as quickly as the system can modify the values in an array). The user application code modifies this data, and starts DMA channel 2. This initiates a sequence of DMA events that will:</p>
<ol>
<li>Stop the PWM channel, so that no normal link pulses are generated during the transaction.</li>
<li>Zero the PWM counter, so that it counts back up from zero when re-enabled after the transaction (like a watchdog)</li>
<li>Initializes the DMA sniffer data register.</li>
<li>Resets the read pointer for the DMA channel which will send the UDP Ethernet packet to PIO state machine 0.</li>
<li>Sends the preamble/SFD to PIO state machine 0, which serializes it out to the TX+ and TX- pins.</li>
<li>Sends the UDP Ethernet packet to PIO state machine 0, which serializes it out to the TX+/TX- pins. Note that the DMA sniffer is attached to this channel! So the Ethernet checksum is automatically computed during this transaction, and stored in the <code>sniffer data</code> register.</li>
<li>Moves the checksum (32 bits) to a buffer character array.</li>
<li>Sends this checksum character array to PIO state machine 0, which serializes it out to PIO state machine 0.</li>
<li>Sends a delay time to PIO state machine 2, which will wait for the specified amount of time (for the checksum transaction to complete), and then generate the TP_IDL signal. This PIO state machine will also generate an interrupt to signal to the processors that the transaction is complete.</li>
<li>Re-enables the PWM channel to resume generating the normal link pulse.</li>
</ol>
<p>This sequence of events is illustrated in the diagram below. Each of the red arrows reads as &#34;chains to.&#34; So, you can follow the sequence of events by following the red arrows. Note that DMA channels 0 and 1, which are responsible for interacting with the PIO state machine which generates the normal link pulse, are independent from the other channels. They only see the <code>DREQ</code> generated by the PWM channel. So, this PWM channel is the sole mechanism for interaction between the NLP state machine and the UDP ethernet state machines.</p>
<p>The advantage of all this DMA footwork is that the ethernet transactions are <em>completely non-blocking</em>. For long payloads, this is a really nice feature! User application code can generate the next packet (gather sensor data, perform computations, etc.) while the previous packet is being transmitted. This maximizes the data rate out of the RP2040.</p>
<figure>
    <img width="800" height="500" src="https://vanhunteradams.com/Pico/Ethernet/overview.png" alt="missing"/>
    <center><figcaption> </figcaption></center>
</figure>
</div>
</div>
</div><div><div>
<div>
<h2 id="Initializing-the-UDP-packet-information">Initializing the UDP packet information<a href="#Initializing-the-UDP-packet-information">¶</a></h2><p>There&#39;s a lot of information in a UDP packet, most of which does not need to change from one transmission to the next. The parameters that the user will need to modify are consolidated in <code>udp_tx_parameters.h</code>. The rest of the parameters (which some users may wish to modify for niche applications) are at the very top of <code>udp_tx.h</code>. During initialization, a helper function uses all these parameters to populate an array which includes the ethernet information, IP information, UDP information, and UDP payload in the correct order. The full packet includes:</p>
<ul>
<li>Destination MAC address (user specified) - 6 bytes</li>
<li>Source MAC address (user specified or generated from flash ID) - 6 bytes</li>
<li>Ethernet type (set to &#34;IP&#34;) - 2 bytes</li>
<li>IP version (v4) and header length (5, for 20 bytes, which is 5 32-bit increments) - 1 byte</li>
<li>IP type of service - 1 byte</li>
<li>IP total length - 2 bytes</li>
<li>IP identifier - 2 bytes</li>
<li>IP flags and fragmentation settings - 2 bytes</li>
<li>IP time to live - 1 byte</li>
<li>IP protocol - 1 byte</li>
<li>IP checksum - 2 bytes</li>
<li>IP source address (user specified) - 4 bytes</li>
<li>IP destination address (user specified) - 4 bytes</li>
<li>UDP source port (user specified) - 2 bytes</li>
<li>UDP payload port (user specified) - 2 bytes</li>
<li>UDP payload length (user specified) - 2 bytes</li>
<li>UDP checksum (unused, set to 0) - 2 bytes</li>
<li>UDP payload (user specified data and length)</li>
</ul>
<p>The checksum is 4 bytes, and is computed from the entire packet above. A DMA sniffer is used to compute this checksum at runtime, and without CPU interaction. In the user application code, the UDP payload can be changed and the checksum will automatically be recomputed during transmission for no overhead.</p>

</div>
</div>
</div><div><div>
<div>
<h2 id="Generating-the-Normal-Link-Pulse">Generating the Normal Link Pulse<a href="#Generating-the-Normal-Link-Pulse">¶</a></h2><p>For a 10BASE-T connection, in the absence of network traffic, a pulse must be sent every 16ms +/- 8ms to keep the link alive. In order to implement this, we want <em>something like</em> a watchdog timer. That is, we want for a timer to count down from 16ms and, in the event that it reaches 0, it should trigger an NLP. However, we should have this timer be <em>reset</em> every time we finish sending a packet.</p>
<p>We will use a PIO state machine to generate these pulses, and the state machine will stall on a <code>pull</code> command until a DMA channel moves data into its TX FIFO. The watchdog timer peripheral does not have a <code>DREQ</code> signal visible to the DMA channels, so we&#39;ll use a PWM channel as a watchdog!</p>
<h3 id="PWM-based-watchdog">PWM-based watchdog<a href="#PWM-based-watchdog">¶</a></h3><p>The PWM channel is configured with a clock divider of 64 and a wrapval of 60,000. With the system overclocked to 240MHz, this gives a period of 16ms. A DMA channel is configured with <code>DREQ_PWM_WRAP</code> as its DREQ, and it writes to the TX FIFO of the PIO state machine that generates the NLP. This state machine stalls on an <code>out</code> command (with autopull enabled) until the DMA channel puts some dummy data into the FIFO. A second DMA channel is configured to re-enable the first.</p>
<p>To stop the NLP for a transaction, another DMA channel need only to disable the PWM channel. As soon as it is re-enabled and the <code>DREQ</code> starts again, the DMA channel will start triggering NLP&#39;s as before.</p>
<div><pre><span></span><span>// Wrapval and clock div for 16ms PWM period</span>
    <span>#define WRAPVAL 60000</span>
    <span>#define CLKDIV  64</span>

    <span>// Slice number chosen arbitrarily</span>
    <span>int</span> <span>slice_num</span> <span>=</span> <span>7</span> <span>;</span>

    <span>// Experimentation shows we don&#39;t need to map this to a GPIO</span>
    <span>// or configure a particular duty cycle. Configured for a wraptime</span>
    <span>// of 16ms (NLP interval)</span>
    <span>pwm_set_wrap</span><span>(</span><span>slice_num</span><span>,</span> <span>WRAPVAL</span><span>)</span> <span>;</span>
    <span>pwm_set_clkdiv</span><span>(</span><span>slice_num</span><span>,</span> <span>CLKDIV</span><span>)</span> <span>;</span>
    <span>pwm_set_enabled</span><span>(</span><span>slice_num</span><span>,</span> <span>true</span><span>)</span> <span>;</span>

    <span>///////////////////////////////////////////////////////////////////</span>
    <span>////////////////////////// DMA NLP SETUP //////////////////////////</span>
    <span>///////////////////////////////////////////////////////////////////</span>

    <span>// Triggers the NLP machine, started by PWM watchdog channel</span>
    <span>dma_channel_config</span> <span>c0</span> <span>=</span> <span>dma_channel_get_default_config</span><span>(</span><span>chan_0</span><span>);</span> <span>// default configs</span>
    <span>channel_config_set_transfer_data_size</span><span>(</span><span>&amp;</span><span>c0</span><span>,</span> <span>DMA_SIZE_32</span><span>);</span>        <span>// 32-bit txfers</span>
    <span>channel_config_set_read_increment</span><span>(</span><span>&amp;</span><span>c0</span><span>,</span> <span>false</span><span>);</span>                  <span>// no read incrementing</span>
    <span>channel_config_set_write_increment</span><span>(</span><span>&amp;</span><span>c0</span><span>,</span> <span>false</span><span>);</span>                 <span>// no write incrementing</span>
    <span>channel_config_set_dreq</span><span>(</span><span>&amp;</span><span>c0</span><span>,</span> <span>DREQ_PWM_WRAP7</span><span>)</span> <span>;</span>                  <span>// DREQ_PWM_WRAP7 pacing</span>
    <span>channel_config_set_chain_to</span><span>(</span><span>&amp;</span><span>c0</span><span>,</span> <span>chan_1</span><span>);</span>                       <span>// chain to chan 1</span>

    <span>dma_channel_configure</span><span>(</span>
        <span>chan_0</span><span>,</span>                <span>// Channel to be configured</span>
        <span>&amp;</span><span>c0</span><span>,</span>                   <span>// The configuration we just created</span>
        <span>&amp;</span><span>pio</span><span>-&gt;</span><span>txf</span><span>[</span><span>sm_nlp</span><span>],</span>     <span>// write address (NLP PIO TX FIFO)</span>
        <span>&amp;</span><span>nlp_dummy</span><span>,</span>            <span>// The initial read address (dummy value)</span>
        <span>1</span><span>,</span>                     <span>// Number of transfers; in this case each is 4 byte.</span>
        <span>false</span>                  <span>// Don&#39;t start immediately.</span>
    <span>);</span>

    <span>// Channel One (resets NLP pulse machine)</span>
    <span>dma_channel_config</span> <span>c1</span> <span>=</span> <span>dma_channel_get_default_config</span><span>(</span><span>chan_1</span><span>);</span>  <span>// default configs</span>
    <span>channel_config_set_transfer_data_size</span><span>(</span><span>&amp;</span><span>c1</span><span>,</span> <span>DMA_SIZE_32</span><span>);</span>         <span>// 32-bit txfers</span>
    <span>channel_config_set_read_increment</span><span>(</span><span>&amp;</span><span>c1</span><span>,</span> <span>false</span><span>);</span>                   <span>// no read incrementing</span>
    <span>channel_config_set_write_increment</span><span>(</span><span>&amp;</span><span>c1</span><span>,</span> <span>false</span><span>);</span>                  <span>// no write incrementing</span>
    <span>channel_config_set_chain_to</span><span>(</span><span>&amp;</span><span>c1</span><span>,</span> <span>chan_0</span><span>);</span>                        <span>// chain back to chan 0</span>

    <span>dma_channel_configure</span><span>(</span>
        <span>chan_1</span><span>,</span>            <span>// Channel to be configured</span>
        <span>&amp;</span><span>c1</span><span>,</span>               <span>// The configuration we just created</span>
        <span>&amp;</span><span>dummy_dest</span><span>,</span>       <span>// write address (dummy)</span>
        <span>&amp;</span><span>dummy_source</span><span>,</span>     <span>// The initial read address (dummy)</span>
        <span>1</span><span>,</span>                 <span>// Number of transfers; in this case each is 4 byte.</span>
        <span>false</span>              <span>// Don&#39;t start immediately.</span>
    <span>);</span>
</pre></div>
<h3 id="PIO-state-machine">PIO state machine<a href="#PIO-state-machine">¶</a></h3><p>The NLP PIO state machine simply stalls on an <code>out</code> command, then sets the TX+/TX- pins for 100ns, and puts the lines back to idle. <code>irq 0</code> is used to prevent the packet serializing state machine from attempting to take control of the data lines in the middle of a normal link pulse.</p>

<pre><code>    out x, 32           ;   32 bits from OSR to x scratch (autopull enabled, stalls here)
    irq 0               ;   Assert interrupt 0
    set pins, 2 [5]     ;   Pulse for 100 ns
    set pins, 0 [5]     ;   End pulse (both lines idle)
    irq clear 0         ;   Clear interrupt 0</code></pre>

</div>
</div>
</div><div><div>
<div>
<h2 id="Transmitting-the-UDP-packet">Transmitting the UDP packet<a href="#Transmitting-the-UDP-packet">¶</a></h2><p>When the user initiates a UDP transfer, a sequence of DMA events occur which move the preamble, SFD, ethernet information, IP information, UDP information, UDP data, and ethernet checksum from memory to a PIO state machine which manchester encodes each bit and puts it out onto the TX+ and TX- pins. All of this happens separately from the ARM processors (i.e., it&#39;s non-blocking) so that the user&#39;s application code can start computing the next packet while the previous one is being transmitted.</p>
<p>This section briefly summarizes this sequence of DMA events.</p>
<h3 id="Disabling-the-PWM-watchdog">Disabling the PWM watchdog<a href="#Disabling-the-PWM-watchdog">¶</a></h3><p>When the user initiates a transfer, disabling and resetting the PWM watchdog is the first thing that happens. This prevents the NLP from being generated during a transmission. To disable the watchdog, DMA channel 2 writes to the <code>csr</code> register of the particular PWM slice that is being used to generate <code>DREQ</code> signals. It writes all zeroes to this register, which disables <em>all</em> PWM channels. For a user application that required a PWM channel to remain active, the value written to this register would be modified to only turn off one slice in particular.</p>
<p>DMA channel 2 chains to DMA channel 3, which writes to the <code>ctr</code> register of the PWM slice which was just disabled. It zeroes the counter so that, when the PWM is re-enabled after the UDP transmission, the counter begins counting up from zero rather than wherever it left off when we disabled the channel. DMA channel 3 then chains to channel 4, which resets the sniffer accumulator.</p>
<div><pre><span></span><span>// Disable the PWM channel</span>
    <span>dma_channel_config</span> <span>c2</span> <span>=</span> <span>dma_channel_get_default_config</span><span>(</span><span>chan_2</span><span>);</span>  <span>// default configs</span>
    <span>channel_config_set_transfer_data_size</span><span>(</span><span>&amp;</span><span>c2</span><span>,</span> <span>DMA_SIZE_32</span><span>);</span>         <span>// 32-bit txfers</span>
    <span>channel_config_set_read_increment</span><span>(</span><span>&amp;</span><span>c2</span><span>,</span> <span>false</span><span>);</span>                   <span>// no read incrementing</span>
    <span>channel_config_set_write_increment</span><span>(</span><span>&amp;</span><span>c2</span><span>,</span> <span>false</span><span>);</span>                  <span>// no write incrementing</span>
    <span>channel_config_set_chain_to</span><span>(</span><span>&amp;</span><span>c2</span><span>,</span> <span>chan_3</span><span>);</span>                        <span>// chain to channel 3</span>

    <span>dma_channel_configure</span><span>(</span>
        <span>chan_2</span><span>,</span>                                 <span>// Channel to be configured</span>
        <span>&amp;</span><span>c2</span><span>,</span>                                    <span>// The configuration we just created</span>
        <span>&amp;</span><span>pwm_hw</span><span>-&gt;</span><span>slice</span><span>[</span><span>slice_num</span><span>].</span><span>csr</span><span>,</span>          <span>// write address (csr reg of pwm)</span>
        <span>&amp;</span><span>pwm_kill</span><span>,</span>                              <span>// The initial read address (zero variable)</span>
        <span>1</span><span>,</span>                                      <span>// Number of transfers; in this case each is 4 byte.</span>
        <span>false</span>                                   <span>// Don&#39;t start immediately.</span>
    <span>);</span>

    <span>// Zero PWM counter</span>
    <span>dma_channel_config</span> <span>c3</span> <span>=</span> <span>dma_channel_get_default_config</span><span>(</span><span>chan_3</span><span>);</span>  <span>// default configs</span>
    <span>channel_config_set_transfer_data_size</span><span>(</span><span>&amp;</span><span>c3</span><span>,</span> <span>DMA_SIZE_32</span><span>);</span>         <span>// 32-bit txfers</span>
    <span>channel_config_set_read_increment</span><span>(</span><span>&amp;</span><span>c3</span><span>,</span> <span>false</span><span>);</span>                   <span>// no read incrementing</span>
    <span>channel_config_set_write_increment</span><span>(</span><span>&amp;</span><span>c3</span><span>,</span> <span>false</span><span>);</span>                  <span>// no write incrementing</span>
    <span>channel_config_set_chain_to</span><span>(</span><span>&amp;</span><span>c3</span><span>,</span> <span>chan_4</span><span>);</span>                        <span>// chain to channel 4</span>

    <span>dma_channel_configure</span><span>(</span>
        <span>chan_3</span><span>,</span>                                 <span>// Channel to be configured</span>
        <span>&amp;</span><span>c3</span><span>,</span>                                    <span>// The configuration we just created</span>
        <span>&amp;</span><span>pwm_hw</span><span>-&gt;</span><span>slice</span><span>[</span><span>slice_num</span><span>].</span><span>ctr</span><span>,</span>          <span>// write address (pwm counter register)</span>
        <span>&amp;</span><span>pwm_counter_reset</span><span>,</span>                     <span>// The initial read address (zero variable)</span>
        <span>1</span><span>,</span>                                      <span>// Number of transfers; in this case each is 4 byte.</span>
        <span>false</span>                                   <span>// Don&#39;t start immediately.</span>
    <span>);</span>
</pre></div>
<h3 id="Reset-the-sniffer-accumulator">Reset the sniffer accumulator<a href="#Reset-the-sniffer-accumulator">¶</a></h3><p>The DMA sniffer will compute a checksum on data that passes through the FIFO of a specified DMA channel. The checksum includes information about each byte as it passes through the FIFO and, as such, it must be reset between transactions. DMA channel 4 writes to the <code>sniff_data</code> register to initialize it for the next transaction. In particular, it initializes it with a value of <code>0xFFFFFFFF</code>. DMA channel 4 then chains to channel 5.</p>
<div><pre><span></span><span>// Reset the sniffer accumulator</span>
    <span>dma_channel_config</span> <span>c4</span> <span>=</span> <span>dma_channel_get_default_config</span><span>(</span><span>chan_4</span><span>);</span> <span>// default configs</span>
    <span>channel_config_set_transfer_data_size</span><span>(</span><span>&amp;</span><span>c4</span><span>,</span> <span>DMA_SIZE_32</span><span>);</span>        <span>// 32-bit txfers</span>
    <span>channel_config_set_read_increment</span><span>(</span><span>&amp;</span><span>c4</span><span>,</span> <span>false</span><span>);</span>                  <span>// no read incrementing</span>
    <span>channel_config_set_write_increment</span><span>(</span><span>&amp;</span><span>c4</span><span>,</span> <span>false</span><span>);</span>                 <span>// no write incrementing</span>
    <span>channel_config_set_chain_to</span><span>(</span><span>&amp;</span><span>c4</span><span>,</span> <span>chan_5</span><span>);</span>                       <span>// chain to channel 5</span>

    <span>dma_channel_configure</span><span>(</span>
        <span>chan_4</span><span>,</span>                <span>// Channel to be configured</span>
        <span>&amp;</span><span>c4</span><span>,</span>                   <span>// The configuration we just created</span>
        <span>&amp;</span><span>dma_hw</span><span>-&gt;</span><span>sniff_data</span><span>,</span>   <span>// write address (sniffer data reg)</span>
        <span>&amp;</span><span>sniff_init</span><span>,</span>           <span>// The initial read address (variable containing 0xffffffff)</span>
        <span>1</span><span>,</span>                     <span>// Number of transfers; in this case each is 4 byte.</span>
        <span>false</span>                  <span>// Don&#39;t start immediately.</span>
    <span>);</span>
</pre></div>
<h3 id="Reset-the-packet-read-pointer">Reset the packet read pointer<a href="#Reset-the-packet-read-pointer">¶</a></h3><p>The UDP payload is of a user-specified (but fixed) length. As such, we cannot make any assumptions about its length. We cannot use the ring-wrap feature of the DMA channel to reset the read pointer of the DMA channel which moves the packet over to the PIO state machine which puts it onto the pins. We must therefore reset the read pointer of the DMA channel which moves the packet to the PIO state machine (DMA channel 7) between each transaction. DMA channel 5 accomplishes this by writing to the <code>read_addr</code> register of DMA channel 7. In particular, it writes a pointer to the address of the start of the Ethernet packet that we would like to transmit. DMA channel 5 chains to channel 6.</p>
<div><pre><span></span><span>// Reset packet read pointer</span>
    <span>dma_channel_config</span> <span>c5</span> <span>=</span> <span>dma_channel_get_default_config</span><span>(</span><span>chan_5</span><span>);</span>  <span>// default configs</span>
    <span>channel_config_set_transfer_data_size</span><span>(</span><span>&amp;</span><span>c5</span><span>,</span> <span>DMA_SIZE_32</span><span>);</span>         <span>// 32-bit txfers</span>
    <span>channel_config_set_read_increment</span><span>(</span><span>&amp;</span><span>c5</span><span>,</span> <span>false</span><span>);</span>                   <span>// no read incrementing</span>
    <span>channel_config_set_write_increment</span><span>(</span><span>&amp;</span><span>c5</span><span>,</span> <span>false</span><span>);</span>                  <span>// no write incrementing</span>
    <span>channel_config_set_chain_to</span><span>(</span><span>&amp;</span><span>c5</span><span>,</span> <span>chan_6</span><span>);</span>                        <span>// chain to channel 6</span>

    <span>dma_channel_configure</span><span>(</span>
        <span>chan_5</span><span>,</span>                                 <span>// Channel to be configured</span>
        <span>&amp;</span><span>c5</span><span>,</span>                                    <span>// The configuration we just created</span>
        <span>&amp;</span><span>dma_hw</span><span>-&gt;</span><span>ch</span><span>[</span><span>chan_7</span><span>].</span><span>read_addr</span><span>,</span>          <span>// write address (dma 7 read address)</span>
        <span>&amp;</span><span>assembled_packet_pointer</span><span>,</span>              <span>// The initial read address (pointer to address)</span>
        <span>1</span><span>,</span>                                      <span>// Number of transfers; in this case each is 4 byte.</span>
        <span>false</span>                                   <span>// Don&#39;t start immediately.</span>
    <span>);</span>
</pre></div>
<h3 id="Send-the-preamble/SFD">Send the preamble/SFD<a href="#Send-the-preamble/SFD">¶</a></h3><p>Channel 6 moves data from an 8-byte array in memory to the PIO state machine which manchester encodes each bit before moving it to the TX+/TX- pins. This array contains the preamble (alternating zeroes and ones), followed by the start frame delimiter. These bytes are stored separately from the rest of the packet for two reasons. The first is that they do not contribute to the ethernet checksum calculation, and so it&#39;s convenient to have them transmitted by a <em>separate</em> DMA channel (so that we don&#39;t need to toggle the sniffer on and off). Secondly, the preamble/SFD is 8 bytes long, so we can ring-wrap the DMA read pointer to save ourselves an additional DMA channel for resetting this pointer.</p>
<p>Note that the DMA transactions are paced by the <code>DREQ_PIO0_TX0</code> data request flag. Channel 6 chains to channel 7.</p>
<div><pre><span></span><span>// Do preamble transaction (8 bytes long, ring wrap to avoid a read pointer reset)</span>
    <span>dma_channel_config</span> <span>c6</span> <span>=</span> <span>dma_channel_get_default_config</span><span>(</span><span>chan_6</span><span>);</span> <span>// default configs</span>
    <span>channel_config_set_transfer_data_size</span><span>(</span><span>&amp;</span><span>c6</span><span>,</span> <span>DMA_SIZE_8</span><span>);</span>         <span>// 8-bit txfers</span>
    <span>channel_config_set_read_increment</span><span>(</span><span>&amp;</span><span>c6</span><span>,</span> <span>true</span><span>);</span>                   <span>// yes read incrementing</span>
    <span>channel_config_set_write_increment</span><span>(</span><span>&amp;</span><span>c6</span><span>,</span> <span>false</span><span>);</span>                 <span>// no write incrementing</span>
    <span>channel_config_set_ring</span><span>(</span><span>&amp;</span><span>c6</span><span>,</span> <span>false</span><span>,</span> <span>3</span><span>)</span> <span>;</span>                        <span>// ring wrap read address!</span>
    <span>channel_config_set_dreq</span><span>(</span><span>&amp;</span><span>c6</span><span>,</span> <span>DREQ_PIO0_TX0</span><span>)</span> <span>;</span>                   <span>// DREQ_PIO0_TX0 pacing (FIFO)</span>
    <span>channel_config_set_chain_to</span><span>(</span><span>&amp;</span><span>c6</span><span>,</span> <span>chan_7</span><span>);</span>                       <span>// chain to channel 7</span>

    <span>dma_channel_configure</span><span>(</span>
        <span>chan_6</span><span>,</span>                 <span>// Channel to be configured</span>
        <span>&amp;</span><span>c6</span><span>,</span>                    <span>// The configuration we just created</span>
        <span>&amp;</span><span>pio</span><span>-&gt;</span><span>txf</span><span>[</span><span>sm_tx</span><span>],</span>       <span>// write address (TX FIFO for packet serializer PIO)</span>
        <span>&amp;</span><span>preamble</span><span>[</span><span>0</span><span>],</span>           <span>// The initial read address (pointer to character array)</span>
        <span>PREAMBLE_LEN</span><span>,</span>           <span>// Number of transfers; in this case each is 1 byte.</span>
        <span>false</span>                   <span>// Don&#39;t start immediately.</span>
    <span>);</span>
</pre></div>
<p>The same PIO state machine is used to manchester-encode and serialize the preamble/SFD, packet, and checksum. That state machine is included below. The machine will stall on the <code>out x, 1</code> command until data appears in the TX FIFO. That <code>out</code> command will then shift one bit from the OSR (autopull is enabled, so data automatically moves from the TX FIFO to the OSR) to the x scratch register. The state machine waits on an <code>irq</code> to confirm that there is not presently an NLP, then either jumps to either the <code>do_0</code> location or wraps to the <code>do_1</code> location depending if the value of the bit is a zero or a one. If it is a zero, then the state machine puts a high to low transmission on the TX+/TX- lines. Otherwise, it puts a low-to-high transmission on the lines. Thus, the state machine manchester encodes all bits that it receives, and puts them out differentially on TX+ and TX-.</p>

<pre><code>.wrap_target
do_1:
    nop         side 0b01 [3] ; Low for 3 cycles (2 delay, +1 for nop)
    jmp get_bit side 0b10     ; High for 1 cycles. &#39;get_bit&#39; takes another 2 cycles
do_0:
    nop         side 0b10 [3] ; Output high for 3 cycles
    nop         side 0b01     ; Output low for 1 cycles
public start:
get_bit:
    out x, 1               ; Always shift out one bit from OSR to X, so we can
    wait 0 irq 0           ; Make sure pulse is not active
    jmp !x do_0            ; branch on it. Autopull refills the OSR when empty.
.wrap</code></pre>
<h3 id="Send-the-packet">Send the packet<a href="#Send-the-packet">¶</a></h3><p>Channel 7 steps through the UPD ethernet packet stored in memory and sends it, byte by byte, to the PIO state machine which manchester encodes it and serializes it out to the TX+/TX- pins. The sniffer is enabled for this channel, so that a checksum is computed on all the bytes communicated by this channel to the PIO state machine. This sniffer is highly configurable, and finding the correct configuration took some trial and error. I used <a href="https://github.com/raspberrypi/pico-feedback/issues/247">this webpage</a> as a resource.</p>
<p>The particular set of sniffer settings that ended up working involved inverting the output bits, and reversing the output bits. This led to the correct checksum being computed and stored in the <code>sniff_data</code> register, but in byte-reversed order. DMA channel 8, chained to by channel 7, solved that problem.</p>
<div><pre><span></span><span>dma_channel_config</span> <span>c7</span> <span>=</span> <span>dma_channel_get_default_config</span><span>(</span><span>chan_7</span><span>);</span> <span>// default configs</span>
    <span>channel_config_set_transfer_data_size</span><span>(</span><span>&amp;</span><span>c7</span><span>,</span> <span>DMA_SIZE_8</span><span>);</span>         <span>// 8-bit txfers</span>
    <span>channel_config_set_read_increment</span><span>(</span><span>&amp;</span><span>c7</span><span>,</span> <span>true</span><span>);</span>                   <span>// yes read incrementing</span>
    <span>channel_config_set_write_increment</span><span>(</span><span>&amp;</span><span>c7</span><span>,</span> <span>false</span><span>);</span>                 <span>// no write incrementing</span>
    <span>channel_config_set_dreq</span><span>(</span><span>&amp;</span><span>c7</span><span>,</span> <span>DREQ_PIO0_TX0</span><span>)</span> <span>;</span>                   <span>// DREQ_PIO0_TX0 pacing (FIFO)</span>
    <span>channel_config_set_chain_to</span><span>(</span><span>&amp;</span><span>c7</span><span>,</span> <span>chan_8</span><span>);</span>                       <span>// chain to channel 8</span>

    <span>dma_channel_configure</span><span>(</span>
        <span>chan_7</span><span>,</span>                 <span>// Channel to be configured</span>
        <span>&amp;</span><span>c7</span><span>,</span>                    <span>// The configuration we just created</span>
        <span>&amp;</span><span>pio</span><span>-&gt;</span><span>txf</span><span>[</span><span>sm_tx</span><span>],</span>       <span>// write address (TX FIFO for packet serializer PIO)</span>
        <span>&amp;</span><span>assembled_packet</span><span>[</span><span>0</span><span>],</span>   <span>// The initial read address (pointer to packet array)</span>
        <span>PACKET_LEN</span><span>,</span>             <span>// Number of transfers; in this case each is 1 byte.</span>
        <span>false</span>                   <span>// Don&#39;t start immediately.</span>
    <span>);</span>

    <span>// Configure the sniffer! Rather tricky setup, this is what worked.</span>
    <span>dma_sniffer_enable</span><span>(</span><span>chan_7</span><span>,</span> <span>1</span><span>,</span> <span>true</span><span>);</span>
    <span>hw_set_bits</span><span>(</span><span>&amp;</span><span>dma_hw</span><span>-&gt;</span><span>sniff_ctrl</span><span>,</span> <span>(</span><span>DMA_SNIFF_CTRL_OUT_INV_BITS</span> <span>|</span> <span>DMA_SNIFF_CTRL_OUT_REV_BITS</span><span>));</span>
</pre></div>
<h3 id="Move-checksum-to-byte-array">Move checksum to byte array<a href="#Move-checksum-to-byte-array">¶</a></h3><p>The sniffed checksum appears in the 32-bit <code>sniff_data</code> register, but we want to communicate the checksum to the PIO state machine one byte at a time. In order to do this, it&#39;s convenient to move the checksum to a 4-element character array before moving it from the character array to the PIO. DMA channel 8 performs a 32-bit transaction from the <code>sniff_data</code> register to the first element of the character array. Because we are doing a 32-bit transaction to an array of 4 chars, this reverses the bytes (solving the byte reversal problem from earlier).</p>
<div><pre><span></span><span>// Send sniffed CRC to character array </span>
    <span>dma_channel_config</span> <span>c8</span> <span>=</span> <span>dma_channel_get_default_config</span><span>(</span><span>chan_8</span><span>);</span> <span>// default configs</span>
    <span>channel_config_set_transfer_data_size</span><span>(</span><span>&amp;</span><span>c8</span><span>,</span> <span>DMA_SIZE_32</span><span>);</span>        <span>// 32-bit txfers</span>
    <span>channel_config_set_read_increment</span><span>(</span><span>&amp;</span><span>c8</span><span>,</span> <span>false</span><span>);</span>                  <span>// no read incrementing</span>
    <span>channel_config_set_write_increment</span><span>(</span><span>&amp;</span><span>c8</span><span>,</span> <span>false</span><span>);</span>                 <span>// no write incrementing</span>
    <span>channel_config_set_bswap</span><span>(</span><span>&amp;</span><span>c8</span><span>,</span> <span>false</span><span>);</span>                           <span>// not necessary b/c char array</span>
    <span>channel_config_set_chain_to</span><span>(</span><span>&amp;</span><span>c8</span><span>,</span> <span>chan_9</span><span>);</span>                       <span>// chain to channel 9</span>

    <span>dma_channel_configure</span><span>(</span>
        <span>chan_8</span><span>,</span>                <span>// Channel to be configured</span>
        <span>&amp;</span><span>c8</span><span>,</span>                   <span>// The configuration we just created</span>
        <span>&amp;</span><span>crc_dest</span><span>[</span><span>0</span><span>],</span>          <span>// write address (checksum buffer character array)</span>
        <span>&amp;</span><span>dma_hw</span><span>-&gt;</span><span>sniff_data</span><span>,</span>   <span>// The initial read address (DMA sniffer data)</span>
        <span>1</span><span>,</span>                     <span>// Number of transfers; in this case each is 4 byte.</span>
        <span>false</span>                  <span>// Don&#39;t start immediately.</span>
    <span>);</span>
</pre></div>
<h3 id="Send-the-checksum">Send the checksum<a href="#Send-the-checksum">¶</a></h3><p>DMA channel 9, chained to by channel 8, moves the checksum from the character array to the PIO state machine. Ring wrapping is used for this DMA channel also, since the byte array is of length 4 (a power of two), saving us an additional DMA channel for resetting a read pointer.</p>
<div><pre><span></span><span>// Send sniffed character array to PIO (use ring wrap to avoid a reset channel)</span>
    <span>dma_channel_config</span> <span>c9</span> <span>=</span> <span>dma_channel_get_default_config</span><span>(</span><span>chan_9</span><span>);</span> <span>// default configs</span>
    <span>channel_config_set_transfer_data_size</span><span>(</span><span>&amp;</span><span>c9</span><span>,</span> <span>DMA_SIZE_8</span><span>);</span>         <span>// 8-bit txfers</span>
    <span>channel_config_set_read_increment</span><span>(</span><span>&amp;</span><span>c9</span><span>,</span> <span>true</span><span>);</span>                   <span>// yes read incrementing</span>
    <span>channel_config_set_write_increment</span><span>(</span><span>&amp;</span><span>c9</span><span>,</span> <span>false</span><span>);</span>                 <span>// no write incrementing</span>
    <span>channel_config_set_ring</span><span>(</span><span>&amp;</span><span>c9</span><span>,</span> <span>false</span><span>,</span> <span>2</span><span>)</span> <span>;</span>                        <span>// ring wrap read addrsses!</span>
    <span>channel_config_set_dreq</span><span>(</span><span>&amp;</span><span>c9</span><span>,</span> <span>DREQ_PIO0_TX0</span><span>)</span> <span>;</span>                   <span>// DREQ_PIO0_TX0 pacing (FIFO)</span>
    <span>channel_config_set_chain_to</span><span>(</span><span>&amp;</span><span>c9</span><span>,</span> <span>chan_10</span><span>);</span>                      <span>// chain to channel 10</span>

    <span>dma_channel_configure</span><span>(</span>
        <span>chan_9</span><span>,</span>                 <span>// Channel to be configured</span>
        <span>&amp;</span><span>c9</span><span>,</span>                    <span>// The configuration we just created</span>
        <span>&amp;</span><span>pio</span><span>-&gt;</span><span>txf</span><span>[</span><span>sm_tx</span><span>],</span>       <span>// write address (TX FIFO for packet serializer PIO)</span>
        <span>&amp;</span><span>crc_dest</span><span>[</span><span>0</span><span>],</span>           <span>// The initial read address (pointer to checksum array)</span>
        <span>CRC_LEN</span><span>,</span>                <span>// Number of transfers; in this case each is 1 byte.</span>
        <span>false</span>                   <span>// Don&#39;t start immediately.</span>
    <span>);</span>
</pre></div>
<h3 id="Trigger-TP_IDL">Trigger TP_IDL<a href="#Trigger-TP_IDL">¶</a></h3><p>Each transmission ends with a TP_IDL signal (a positive pulse of about 3 bit-times, followed by an idle period). A separate PIO state machine generates this signal.</p>
<div><pre><span></span><span>// Trigger a TP_IDL pulse (another PIO machine)</span>
    <span>dma_channel_config</span> <span>c10</span> <span>=</span> <span>dma_channel_get_default_config</span><span>(</span><span>chan_10</span><span>);</span>   <span>// default configs</span>
    <span>channel_config_set_transfer_data_size</span><span>(</span><span>&amp;</span><span>c10</span><span>,</span> <span>DMA_SIZE_32</span><span>);</span>           <span>// 32-bit txfers</span>
    <span>channel_config_set_read_increment</span><span>(</span><span>&amp;</span><span>c10</span><span>,</span> <span>false</span><span>);</span>                     <span>// no read incrementing</span>
    <span>channel_config_set_write_increment</span><span>(</span><span>&amp;</span><span>c10</span><span>,</span> <span>false</span><span>);</span>                    <span>// no write incrementing</span>
    <span>channel_config_set_dreq</span><span>(</span><span>&amp;</span><span>c10</span><span>,</span> <span>DREQ_PIO0_TX2</span><span>)</span> <span>;</span>                      <span>// DREQ_PIO0_TX2 pacing</span>
    <span>channel_config_set_chain_to</span><span>(</span><span>&amp;</span><span>c10</span><span>,</span> <span>chan_11</span><span>);</span>                         <span>// chain to channel 11</span>

    <span>dma_channel_configure</span><span>(</span>
        <span>chan_10</span><span>,</span>                <span>// Channel to be configured</span>
        <span>&amp;</span><span>c10</span><span>,</span>                   <span>// The configuration we just created</span>
        <span>&amp;</span><span>pio</span><span>-&gt;</span><span>txf</span><span>[</span><span>sm_idl</span><span>],</span>      <span>// write address (TP_IDL PIO state machine TX fifo)</span>
        <span>&amp;</span><span>idl_delay</span><span>,</span>             <span>// The initial read address (variable holding wait time)</span>
        <span>1</span><span>,</span>                      <span>// Number of transfers; in this case each is 4 byte.</span>
        <span>false</span>                   <span>// Don&#39;t start immediately.</span>
    <span>);</span>
</pre></div>
<p>This PIO state machine stalls on an <code>out</code> command until DMA channel 10, chained to by DMA channel 9, puts some data into its TX FIFO. The state machine then waits for the checksum to complete before generating the TP_IDL signal. It stalls in the <code>pause</code> state while decrementing scratch register x, then generates the pulse, and sets the pins to an idle state for about 64 bit times. The state machine then uses <code>irq 1</code> to send an interrupt back to the CPU, signalling that the transmission has completed.</p>

<pre><code>start:
    out x, 32          ;   32 bits from OSR to x scratch (autopull enabled, stalls here)
pause:
    jmp x-- pause      ;

set pins, 2    [23] ;   Pulse high for 3 bit times (8 cycles per bit)
set pins, 0    [31] ;   Pulse low for idle time
set pins, 0    [31] ;
set pins, 0    [31] ;
set pins, 0    [31] ;
set pins, 0    [31] ;
set pins, 0    [31] ;
set pins, 0    [31] ;
set pins, 0    [31] ;
set pins, 0    [31] ;
set pins, 0    [31] ;
set pins, 0    [31] ;
set pins, 0    [31] ;
set pins, 0    [31] ;
set pins, 0    [31] ;
set pins, 0    [31] ;
set pins, 0    [31] ;
irq 1               ;   Signal transaction complete to CPU</code></pre>
<h3 id="Re-enabling-the-PWM-watchdog">Re-enabling the PWM watchdog<a href="#Re-enabling-the-PWM-watchdog">¶</a></h3><p>Finally, DMA channel 11 revives the PWM watchdog by writing to the <code>csr</code> register. The PWM channel will resume generating <code>DREQ</code> signals which will be consumed by DMA channel 0 to initiate NLP&#39;s.</p>
<div><pre><span></span><span>// Revive the PWM channel after packet transaction</span>
    <span>dma_channel_config</span> <span>c11</span> <span>=</span> <span>dma_channel_get_default_config</span><span>(</span><span>chan_11</span><span>);</span>   <span>// default configs</span>
    <span>channel_config_set_transfer_data_size</span><span>(</span><span>&amp;</span><span>c11</span><span>,</span> <span>DMA_SIZE_32</span><span>);</span>           <span>// 32-bit txfers</span>
    <span>channel_config_set_read_increment</span><span>(</span><span>&amp;</span><span>c11</span><span>,</span> <span>false</span><span>);</span>                     <span>// no read incrementing</span>
    <span>channel_config_set_write_increment</span><span>(</span><span>&amp;</span><span>c11</span><span>,</span> <span>false</span><span>);</span>                    <span>// no write incrementing</span>

    <span>dma_channel_configure</span><span>(</span>
        <span>chan_11</span><span>,</span>                           <span>// Channel to be configured</span>
        <span>&amp;</span><span>c11</span><span>,</span>                              <span>// The configuration we just created</span>
        <span>&amp;</span><span>pwm_hw</span><span>-&gt;</span><span>slice</span><span>[</span><span>slice_num</span><span>].</span><span>csr</span><span>,</span>     <span>// write address (pwm csr register)</span>
        <span>&amp;</span><span>pwm_revive</span><span>,</span>                       <span>// The initial read address (1 variable)</span>
        <span>1</span><span>,</span>                                 <span>// Number of transfers; in this case each is 4 byte.</span>
        <span>false</span>                              <span>// Don&#39;t start immediately.</span>
    <span>);</span>
</pre></div>

</div>
</div>
</div></div>
  </body>
</html>
