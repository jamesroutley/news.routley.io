<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.sqlite.org/cli.html#index_recommendations_sqlite_expert_">Original</a>
    <h1>The SQLite Index Suggester</h1>
    
    <div id="readability-page-1" class="page"><div>
<div>
<p>
Command Line Shell For SQLite
</p>


</div>






<p>The SQLite project provides a simple command-line program named
<b>sqlite3</b> (or <b>sqlite3.exe</b> on Windows)
that allows the user to manually enter and execute SQL
statements against an SQLite database or against a
<a href="#zipdb">ZIP archive</a>.  This document provides a brief
introduction on how to use the <b>sqlite3</b> program.

</p><p>Start the <b>sqlite3</b> program by typing &#34;sqlite3&#34; at the
command prompt, optionally followed 
by the name the file that holds the SQLite database
(or <a href="#zipdb">ZIP archive</a>).  If the named
file does not exist, a new database file with the given name will be
created automatically.  If no database file is specified on the
command-line, a temporary database is created and automatically deleted when 
the &#34;sqlite3&#34; program exits.

</p><p>On startup, the <b>sqlite3</b> program will show a brief banner
message then prompt you to enter SQL.  Type in SQL statements (terminated
by a semicolon), press &#34;Enter&#34; and the SQL will be executed.</p>

<p>For example, to create a new SQLite database named &#34;ex1&#34; 
with a single table named &#34;tbl1&#34;, you might do this:</p>

<div><pre>$ <b>sqlite3 ex1</b>
SQLite version 3.36.0 2021-06-18 18:36:39
Enter &#34;.help&#34; for usage hints.
sqlite&gt; <b>create table tbl1(one text, two int);</b>
sqlite&gt; <b>insert into tbl1 values(&#39;hello!&#39;,10);</b>
sqlite&gt; <b>insert into tbl1 values(&#39;goodbye&#39;, 20);</b>
sqlite&gt; <b>select * from tbl1;</b>
hello!|10
goodbye|20
sqlite&gt;
</pre></div>

<p>Terminate the sqlite3 program by typing your system
End-Of-File character (usually a Control-D).  Use the interrupt
character (usually a Control-C) to stop a long-running SQL statement.</p>

<p>Make sure you type a semicolon at the end of each SQL command!
The sqlite3 program looks for a semicolon to know when your SQL command is
complete.  If you omit the semicolon, sqlite3 will give you a
continuation prompt and wait for you to enter more text to 
complete the SQL command.  This feature allows you to
enter SQL commands that span multiple lines.  For example:</p>


<div><pre>sqlite&gt; <b>CREATE TABLE tbl2 (</b>
   ...&gt; <b>  f1 varchar(30) primary key,</b>
   ...&gt; <b>  f2 text,</b>
   ...&gt; <b>  f3 real</b>
   ...&gt; <b>);</b>
sqlite&gt;
</pre></div>



<p>Windows users can double-click on the <b>sqlite3.exe</b> icon to cause
the command-line shell to pop-up a terminal window running SQLite.  However,
because double-clicking starts the sqlite3.exe without command-line arguments,
no database file will have been specified, so SQLite will use a temporary
database that is deleted when the session exits.
To use a persistent disk file as the database, enter the &#34;.open&#34; command
immediately after the terminal window starts up:

</p><div><pre>SQLite version 3.36.0 2021-06-18 18:36:39
Enter &#34;.help&#34; for usage hints.
Connected to a transient in-memory database.
Use &#34;.open FILENAME&#34; to reopen on a persistent database.
sqlite&gt; <b>.open ex1.db</b>
sqlite&gt;
</pre></div>

<p>The example above causes the database file named &#34;ex1.db&#34; to be opened
and used.  The &#34;ex1.db&#34; file is created if it does not previously exist.
You might want to
use a full pathname to ensure that the file is in the directory that you
think it is in.  Use forward-slashes as the directory separator character.
In other words use &#34;c:/work/ex1.db&#34;, not &#34;c:\work\ex1.db&#34;.</p>

<p>Alternatively, you can create a new database using the default temporary
storage, then save that database into a disk file using the &#34;.save&#34; command:

</p><div><pre>SQLite version 3.36.0 2021-06-18 18:36:39
Enter &#34;.help&#34; for usage hints.
Connected to a transient in-memory database.
Use &#34;.open FILENAME&#34; to reopen on a persistent database.
sqlite&gt; <i>... many SQL commands omitted ...</i>
sqlite&gt; <b>.save ex1.db</b>
sqlite&gt;
</pre></div>

<p>Be careful when using the &#34;.save&#34; command as it will overwrite any
preexisting database files having the same name without prompting for
confirmation.  As with the &#34;.open&#34; command, you might want to use a
full pathname with forward-slash directory separators to avoid ambiguity.

<a name="dotcmd"></a>

</p>

<p>
Most of the time, sqlite3 just reads lines of input and passes them
on to the SQLite library for execution.
But input lines that begin with a dot (&#34;.&#34;)
are intercepted and interpreted by the sqlite3 program itself.
These &#34;dot commands&#34; are typically used to change the output format
of queries, or to execute certain prepackaged query statements.
There were originally just a few dot commands, but over the years
many new features have accumulated so that today there are over 60.
</p>

<p>
For a listing of the available dot commands, you can enter &#34;.help&#34; with
no arguments.  Or enter &#34;.help TOPIC&#34; for detailed information about TOPIC.
The list of available dot-commands follows:
</p>

<div><pre>sqlite&gt; <b>.help</b>
.archive ...             Manage SQL archives
.auth ON|OFF             Show authorizer callbacks
.backup ?DB? FILE        Backup DB (default &#34;main&#34;) to FILE
.bail on|off             Stop after hitting an error.  Default OFF
.binary on|off           Turn binary output on or off.  Default OFF
.cd DIRECTORY            Change the working directory to DIRECTORY
.changes on|off          Show number of rows changed by SQL
.check GLOB              Fail if output since .testcase does not match
.clone NEWDB             Clone data into NEWDB from the existing database
.connection [close] [#]  Open or close an auxiliary database connection
.databases               List names and files of attached databases
.dbconfig ?op? ?val?     List or change sqlite3_db_config() options
.dbinfo ?DB?             Show status information about the database
.dump ?OBJECTS?          Render database content as SQL
.echo on|off             Turn command echo on or off
.eqp on|off|full|...     Enable or disable automatic EXPLAIN QUERY PLAN
.excel                   Display the output of next command in spreadsheet
.exit ?CODE?             Exit this program with return-code CODE
.expert                  EXPERIMENTAL. Suggest indexes for queries
.explain ?on|off|auto?   Change the EXPLAIN formatting mode.  Default: auto
.filectrl CMD ...        Run various sqlite3_file_control() operations
.fullschema ?--indent?   Show schema and the content of sqlite_stat tables
.headers on|off          Turn display of headers on or off
.help ?-all? ?PATTERN?   Show help text for PATTERN
.import FILE TABLE       Import data from FILE into TABLE
.imposter INDEX TABLE    Create imposter table TABLE on index INDEX
.indexes ?TABLE?         Show names of indexes
.limit ?LIMIT? ?VAL?     Display or change the value of an SQLITE_LIMIT
.lint OPTIONS            Report potential schema issues.
.load FILE ?ENTRY?       Load an extension library
.log FILE|off            Turn logging on or off.  FILE can be stderr/stdout
.mode MODE ?TABLE?       Set output mode
.nonce STRING            Disable safe mode for one command if the nonce matches
.nullvalue STRING        Use STRING in place of NULL values
.once ?OPTIONS? ?FILE?   Output for the next SQL command only to FILE
.open ?OPTIONS? ?FILE?   Close existing database and reopen FILE
.output ?FILE?           Send output to FILE or stdout if FILE is omitted
.parameter CMD ...       Manage SQL parameter bindings
.print STRING...         Print literal STRING
.progress N              Invoke progress handler after every N opcodes
.prompt MAIN CONTINUE    Replace the standard prompts
.quit                    Exit this program
.read FILE               Read input from FILE
.recover                 Recover as much data as possible from corrupt db.
.restore ?DB? FILE       Restore content of DB (default &#34;main&#34;) from FILE
.save FILE               Write in-memory database into FILE
.scanstats on|off        Turn sqlite3_stmt_scanstatus() metrics on or off
.schema ?PATTERN?        Show the CREATE statements matching PATTERN
.selftest ?OPTIONS?      Run tests defined in the SELFTEST table
.separator COL ?ROW?     Change the column and row separators
.session ?NAME? CMD ...  Create or control sessions
.sha3sum ...             Compute a SHA3 hash of database content
.shell CMD ARGS...       Run CMD ARGS... in a system shell
.show                    Show the current values for various settings
.stats ?ARG?             Show stats or turn stats on or off
.system CMD ARGS...      Run CMD ARGS... in a system shell
.tables ?TABLE?          List names of tables matching LIKE pattern TABLE
.testcase NAME           Begin redirecting output to &#39;testcase-out.txt&#39;
.testctrl CMD ...        Run various sqlite3_test_control() operations
.timeout MS              Try opening locked tables for MS milliseconds
.timer on|off            Turn SQL timer on or off
.trace ?OPTIONS?         Output each SQL statement as it is run
.vfsinfo ?AUX?           Information about the top-level VFS
.vfslist                 List all available VFSes
.vfsname ?AUX?           Print the name of the VFS stack
.width NUM1 NUM2 ...     Set minimum column widths for columnar output
sqlite&gt;
</pre></div>



<h2 id="line_structure"><span>4.1. </span>Line Structure</h2>

<p>The CLI&#39;s input is parsed into a sequence consisting of:
  </p><ul>
    <li>SQL statements;</li>
    <li>dot-commands; or</li>
    <li>CLI comments</li>
  </ul>
<p>SQL statements are free-form, and can be spread across multiple lines,
  with whitespace or SQL comments embedded anywhere.
  They are terminated by either a &#39;;&#39; character at the end of an input line,
  or a &#39;/&#39; character or the word &#34;go&#34; on a line by itself.
  When not at the end of an input line, the &#39;;&#39; character
  acts to separate SQL statements.
  Trailing whitespace is ignored for purposes of termination.
</p><p>A dot-command has a more restrictive structure:
</p><ul>
<li>It must begin with its &#34;.&#34; at the left margin
    with no preceding whitespace.</li>
<li>It must be entirely contained on a single input line.</li>
<li>It cannot occur in the middle of an ordinary SQL
    statement.  In other words, it cannot occur at a
    continuation prompt.</li>
<li>There is no comment syntax for dot-commands.</li>
</ul>
<p>The CLI also accepts whole-line comments that
begin with a &#39;#&#39; character and extend to the end of the line.
There can be no with whitespace prior to the &#39;#&#39;.

</p><h2 id="dot_command_arguments"><span>4.2. </span>Dot-command arguments</h2>
<p>The arguments passed to dot-commands are parsed from the command tail, 
  per these rules:
</p><ol>
  <li>The trailing newline and any other trailing whitespace is discarded;</li>
  <li>Whitespace immediately following the dot-command name, or any argument
    input end bound is discarded;</li>
  <li>An argument input begins with any non-whitespace character;</li>
  <li>An argument input ends with a character which
    depends upon its leading character thusly:</li>
  <ul>
    <li>for a leading single-quote (&#39;), a single-quote acts
      as the end delimiter;</li>
    <li>for a leading double-quote (&#34;), an unescaped double-quote
      acts as the end delimiter;</li>
    <li>for any other leading character, the end delimiter is
      any whitespace; and</li>
    <li>the command tail end acts as the end delimiter for any argument;</li>
  </ul>
  <li>Within a double-quoted argument input, a backslash-escaped double-quote
    is part of the argument rather than its terminating quote;</li>
  <li>Within a double-quoted argument, traditional C-string literal, backslash
    escape sequence translation is done; and</li>
  <li>Argument input delimiters (the bounding quotes or whitespace)
    are discarded to yield the passed argument.</li>
</ol>

<h2 id="dot_command_execution"><span>4.3. </span>Dot-command execution</h2>
<p>The dot-commands
are interpreted by the sqlite3.exe command-line program, not by
SQLite itself.  So none of the dot-commands will work as an argument
to SQLite interfaces such as <a href="https://www.sqlite.org/c3ref/prepare.html">sqlite3_prepare()</a> or <a href="https://www.sqlite.org/c3ref/exec.html">sqlite3_exec()</a>.

<a name="dotmode"></a>

</p>

<p>The sqlite3 program is able to show the results of a query
in 14 different output formats:
</p><div>
<ul>
<li> ascii
</li><li> box
</li><li> csv
</li><li> column
</li><li> html
</li><li> insert
</li><li> json
</li><li> line
</li><li> list
</li><li> markdown
</li><li> quote
</li><li> table
</li><li> tabs
</li><li> tcl
</li></ul></div>

<p>You can use the &#34;.mode&#34; dot command to switch between these output
formats.
The default output mode is &#34;list&#34;.  In
list mode, each row of a query result is written on one line of
output and each column within that row is separated by a specific
separator string.  The default separator is a pipe symbol (&#34;|&#34;).
List mode is especially useful when you are going to send the output
of a query to another program (such as AWK) for additional processing.</p>

<div><pre>sqlite&gt; <b>.mode list</b>
sqlite&gt; <b>select * from tbl1;</b>
hello!|10
goodbye|20
sqlite&gt;
</pre></div>

<p>Type &#34;.mode&#34; with no arguments to show the current mode:

</p><div><pre>sqlite&gt; <b>.mode</b>
current output mode: list
sqlite&gt;
</pre></div>

<p>Use the &#34;.separator&#34; dot command to change the separator.
For example, to change the separator to a comma and
a space, you could do this:</p>

<div><pre>sqlite&gt; <b>.separator &#34;, &#34;</b>
sqlite&gt; <b>select * from tbl1;</b>
hello!, 10
goodbye, 20
sqlite&gt;
</pre></div>

<p>The next &#34;.mode&#34; command might reset the &#34;.separator&#34; back to some
default value (depending on its arguments).
So you will likely need to repeat the &#34;.separator&#34; command whenever you
change modes if you want to continue using a non-standard separator.

<a name="dotmodequote"></a>

</p><p>In &#34;quote&#34; mode, the output is formatted as SQL literals.  Strings are
enclosed in single-quotes and internal single-quotes are escaped by doubling.
Blobs are displayed in hexadecimal blob literal notation (Ex: x&#39;abcd&#39;).
Numbers are displayed as ASCII text and NULL values are shown as &#34;NULL&#34;.
All columns are separated from each other by a comma (or whatever alternative
character is selected using &#34;.separator&#34;).

</p><div><pre>sqlite&gt; <b>.mode quote</b>
sqlite&gt; <b>select * from tbl1;</b>
&#39;hello!&#39;,10
&#39;goodbye&#39;,20
sqlite&gt;
</pre></div>

<p>In &#34;line&#34; mode, each column in a row of the database
is shown on a line by itself.  Each line consists of the column
name, an equal sign and the column data.  Successive records are
separated by a blank line.  Here is an example of line mode
output:</p>

<div><pre>sqlite&gt; <b>.mode line</b>
sqlite&gt; <b>select * from tbl1;</b>
one = hello!
two = 10

one = goodbye
two = 20
sqlite&gt;
</pre></div>

<p>In column mode, each record is shown on a separate line with the
data aligned in columns.  For example:</p>

<div><pre>sqlite&gt; <b>.mode column</b>
sqlite&gt; <b>select * from tbl1;</b>
one       two       
--------  ---
hello!    10        
goodbye   20        
sqlite&gt;
</pre></div>

<p>In &#34;column&#34; mode (and also in &#34;box&#34;, &#34;table&#34;, and &#34;markdown&#34; modes)
the width of columns adjusts automatically.  But you can override this,
providing a speicified width for each column using the &#34;.width&#34; command.
The arguments to &#34;.width&#34; are integers which are the number of
characters to devote to each column.  Negative numbers mean right-justify.
Thus:</p>

<div><pre>sqlite&gt; <b>.width 12 -6</b>
sqlite&gt; <b>select * from tbl1;</b>
one              two
------------  ------
hello!            10
goodbye           20
sqlite&gt;
</pre></div>

<p>A width of 0 means the column width is chosen automatically.
Unspecified column widths become zero.  Hence, the command
&#34;.width&#34; with no arguments resets all column widths to zero and
hence causes all column widths to be determined automatically.

</p><p>The &#34;column&#34; mode is a tabular output format.  Other
tabular output formats are &#34;box&#34;, &#34;markdown&#34;, and &#34;table&#34;:

</p><div><pre>sqlite&gt; <b>.width</b>
sqlite&gt; <b>.mode markdown</b>
sqlite&gt; <b>select * from tbl1;</b>
|   one   | two |
|---------|-----|
| hello!  | 10  |
| goodbye | 20  |
sqlite&gt; <b>.mode table</b>
sqlite&gt; <b>select * from tbl1;</b>
+---------+-----+
|   one   | two |
+---------+-----+
| hello!  | 10  |
| goodbye | 20  |
+---------+-----+
sqlite&gt; <b>.mode box</b>
sqlite&gt; <b>select * from tbl1;</b>
┌─────────┬─────┐
│   one   │ two │
├─────────┼─────┤
│ hello!  │ 10  │
│ goodbye │ 20  │
└─────────┴─────┘
sqlite&gt;
</pre></div>

<p>The columnar modes accept some addition options to control formatting.
The &#34;--wrap <i>N</i>&#34; option (where <i>N</i> is an integer) causes columns
to wrap text that is longer than N characters.  Wrapping is disabled if
N is zero.

</p><div><pre>sqlite&gt; <b>insert into tbl1 values(&#39;The quick fox jumps over a lazy brown dog.&#39;,99);</b>
sqlite&gt; <b>.mode box --wrap 30</b>
sqlite&gt; <b>select * from tbl1 where two&gt;50;</b>
┌────────────────────────────────┬─────┐
│              one               │ two │
├────────────────────────────────┼─────┤
│ The quick fox jumps over a laz │ 90  │
│ y brown dog.                   │     │
└────────────────────────────────┴─────┘
sqlite&gt;
</pre></div>

<p>Wrapping happens after exactly <i>N</i> characters, 
which might be in the middle of a word.
To wrap at a word boundary, add the &#34;--wordwrap on&#34; option 
(or just &#34;-ww&#34; for short):

</p><div><pre>sqlite&gt; <b>.mode box --wrap 30 -ww</b>
sqlite&gt; <b>select * from tbl1 where two&gt;50;</b>
┌─────────────────────────────┬─────┐
│             one             │ two │
├─────────────────────────────┼─────┤
│ The quick fox jumps over a  │ 90  │
│ lazy brown dog.             │     │
└─────────────────────────────┴─────┘
sqlite&gt;
</pre></div>

<p>The &#34;--quote&#34; option causes the results in each column to be
quoted like an SQL literal, as in the &#34;quote&#34; mode.  See the on-line
help for additional options.

<a name="qbox"></a>

</p><p>The command &#34;.mode box --wrap 60 --quote&#34; is so useful for general-purpose
database queries that it is given its own alias.  Instead of typing out
that whole 27-character command, you can just say &#34;.mode qbox&#34;.

</p><p>Another useful output mode is &#34;insert&#34;.  In insert mode, the output
is formatted to look like SQL INSERT statements.  Use insert
mode to generate text that can later be used to input data into a 
different database.</p>

<p>When specifying insert mode, you have to give an extra argument
which is the name of the table to be inserted into.  For example:</p>

<div><pre>sqlite&gt; <b>.mode insert new_table</b>
sqlite&gt; <b>select * from tbl1 where two&lt;50;</b>
INSERT INTO &#34;new_table&#34; VALUES(&#39;hello&#39;,10);
INSERT INTO &#34;new_table&#34; VALUES(&#39;goodbye&#39;,20);
sqlite&gt;
</pre></div>


<p>Other output modes include &#34;csv&#34;, &#34;json&#34;, and &#34;tcl&#34;.  Try these
yourself to see what they do.
</p>



<p>The sqlite3 program provides several convenience commands that
are useful for looking at the schema of the database.  There is
nothing that these commands do that cannot be done by some other
means.  These commands are provided purely as a shortcut.</p>

<p>For example, to see a list of the tables in the database, you
can enter &#34;.tables&#34;.</p>


<div><pre>sqlite&gt; <b>.tables</b>
tbl1 tbl2
sqlite&gt;
</pre></div>


<p>The &#34;.tables&#34; command is similar to setting list mode then
executing the following query:</p>

<div><pre>SELECT name FROM sqlite_schema 
WHERE type IN (&#39;table&#39;,&#39;view&#39;) AND name NOT LIKE &#39;sqlite_%&#39;
ORDER BY 1
</pre></div>

<p>But the &#34;.tables&#34; command does more.  It queries the <a href="https://www.sqlite.org/schematab.html">sqlite_schema</a> table
for all <a href="https://www.sqlite.org/lang_attach.html">attached</a> databases, not just the primary database.  And it arranges
its output into neat columns.

</p><p>The &#34;.indexes&#34; command works in a similar way to list all of
the indexes. If the &#34;.indexes&#34; command is given an argument which is
the name of a table, then it shows just indexes on that table.

<a name="dschema"></a>

</p><p>The &#34;.schema&#34; command shows the complete schema for the database,
or for a single table if an optional tablename argument is provided:

</p><div><pre>sqlite&gt; <b>.schema</b>
create table tbl1(one varchar(10), two smallint)
CREATE TABLE tbl2 (
  f1 varchar(30) primary key,
  f2 text,
  f3 real
);
sqlite&gt; <b>.schema tbl2</b>
CREATE TABLE tbl2 (
  f1 varchar(30) primary key,
  f2 text,
  f3 real
);
sqlite&gt;
</pre></div>


<p>The &#34;.schema&#34; command is roughly the same as setting
list mode, then entering the following query:</p>

<div><pre>SELECT sql FROM sqlite_schema
ORDER BY tbl_name, type DESC, name
</pre></div>

<p>As with &#34;.tables&#34;, the &#34;.schema&#34; command shows the schema for
all <a href="https://www.sqlite.org/lang_attach.html">attached</a> databases.  If you only want to see the schema for
a single database (perhaps &#34;main&#34;) then you can add an argument
to &#34;.schema&#34; to restrict its output:

</p>

<p>The &#34;.schema&#34; command can be augmented with the &#34;--indent&#34; option,
in which case it tries to reformat the various CREATE statements of
the schema so that they are more easily readable by humans.

<a name="dotdatabases"></a>

</p><p>The &#34;.databases&#34; command shows a list of all databases open in
the current connection.  There will always be at least 2.  The first
one is &#34;main&#34;, the original database opened.  The second is &#34;temp&#34;,
the database used for temporary tables. There may be additional 
databases listed for databases attached using the ATTACH statement.
The first output column is the name the database is attached with, 
and the second result column is the filename of the external file.
There may be a third result column which will be either &#34;&#39;r/o&#39;&#34; or
&#34;&#39;r/w&#39;&#34; depending on whether the database file is read-only or read-write.
And there might be a fourth result column showing the result of
<a href="https://www.sqlite.org/c3ref/txn_state.html">sqlite3_txn_state()</a> for that database file.

</p>

<p>The &#34;.fullschema&#34; dot-command works like the &#34;.schema&#34; command in
that it displays the entire database schema.  But &#34;.fullschema&#34; also
includes dumps of the statistics tables &#34;sqlite_stat1&#34;, &#34;sqlite_stat3&#34;,
and &#34;sqlite_stat4&#34;, if they exist.  The &#34;.fullschema&#34; command normally
provides all of the information needed to exactly recreate a query
plan for a specific query.  When reporting suspected problems with
the SQLite query planner to the SQLite development team, developers
are requested to provide the complete &#34;.fullschema&#34; output as part
of the trouble report.  Note that the sqlite_stat3 and sqlite_stat4
tables contain samples of index entries and so might contain sensitive
data, so do not send the &#34;.fullschema&#34; output of a proprietary database
over a public channel.</p>



<p>The &#34;.open&#34; command opens a new database connection, after first closing the
previously opened database command.  In its simplest form, the &#34;.open&#34; command merely
invokes <a href="https://www.sqlite.org/c3ref/open.html">sqlite3_open()</a> on the file named as its argument.  Use the name &#34;:memory:&#34;
to open a new in-memory database that disappears when the CLI exits or when the
&#34;.open&#34; command is run again.

</p><p>If the --new option is included with &#34;.open&#34;, then the database is reset prior
to being opened.  Any prior data is destroyed.  This is a destructive overwrite of
prior data and no confirmation is requested, so use this option carefully.

</p><p>The --readonly option opens the database in read-only mode.  Write will be
prohibited.

</p><p>The --deserialize option causes the entire content of the on-disk file to be
read into memory and then opened as an in-memory database using the
<a href="https://www.sqlite.org/c3ref/deserialize.html">sqlite3_deserialize()</a> interface.  This will, of course, require a lot of memory
if you have a large database.  Also, any changes you make to the database will not
be saved back to disk unless you explicitly save them using the &#34;.save&#34; or &#34;.backup&#34;
commands.

</p><p>The --append option causes the SQLite database to be appended to an existing
file rather than working as a stand-alone file.  See the 
<a href="https://www.sqlite.org/src/file/ext/misc/appendvfs.c">appendvfs extension</a> for
more information.

</p><p>The --zip option causes the specified input file to be interpreted as a ZIP archive
instead of as an SQLite database file.

</p><p>The --hexdb option causes the database content to be to be read from subsequent
lines of input in a hex format, rather than from a separate file on disk.  
The &#34;dbtotxt&#34; command-line tool can be used to generate
the appropriate text for a database.  The --hexdb option is intended for use by the
SQLite developers for testing purposes.  We do not know of any use cases for this
option outside of internal SQLite testing and development.

</p>

<h2 id="writing_results_to_a_file"><span>8.1. </span>Writing results to a file</h2>

<p>By default, sqlite3 sends query results to standard output.  You
can change this using the &#34;.output&#34; and &#34;.once&#34; commands.  Just put 
the name of an output file as an argument to .output and all subsequent
query results will be written to that file.  Or use the .once command
instead of .output and output will only be redirected for the single next
command before reverting to the console.  Use .output with no arguments to
begin writing to standard output again.  For example:</p>

<div><pre>sqlite&gt; <b>.mode list</b>
sqlite&gt; <b>.separator |</b>
sqlite&gt; <b>.output test_file_1.txt</b>
sqlite&gt; <b>select * from tbl1;</b>
sqlite&gt; <b>.exit</b>
$ <b>cat test_file_1.txt</b>
hello|10
goodbye|20
$
</pre></div>

<p>If the first character of the &#34;.output&#34; or &#34;.once&#34; filename is a pipe
symbol (&#34;|&#34;) then the remaining characters are treated as a command and the
output is sent to that command.  This makes it easy to pipe the results
of a query into some other process.  For example, the 
&#34;open -f&#34; command on a Mac opens a text editor to display the content that
it reads from standard input.  So to see the results of a query
in a text editor, one could type:</p>

<div><pre>sqlite&gt; <b>.once | open -f</b>
sqlite&gt; <b>SELECT * FROM bigTable;</b>
</pre></div>

<p>If the &#34;.output&#34; or &#34;.once&#34; commands have an argument of &#34;-e&#34; then
output is collected into a temporary file and the system text editor is
invoked on that text file.  Thus, the command &#34;.once -e&#34; achieves the
same result as &#34;.once &#39;|open -f&#39;&#34; but with the benefit of being portable
across all systems.

</p><p>If the &#34;.output&#34; or &#34;.once&#34; commands have a &#34;-x&#34; argument, that causes
them to accumulate output as Comma-Separated-Values (CSV) in a temporary
file, then invoke the default system utility for viewing CSV files
(usually a spreadsheet program) on the result.  This is a quick way of
sending the result of a query to a spreadsheet for easy viewing:

</p><div><pre>sqlite&gt; <b>.once -x</b>
sqlite&gt; <b>SELECT * FROM bigTable;</b>
</pre></div>

<p>The &#34;.excel&#34; command is an alias for &#34;.once -x&#34;.  It does exactly the same
thing.

<a name="dotread"></a>

</p><h2 id="reading_sql_from_a_file"><span>8.2. </span>Reading SQL from a file</h2>

<p>In interactive mode, sqlite3 reads input text (either SQL statements
or <a href="https://www.sqlite.org/cli.html#dotcmd">dot-commands</a>) from the keyboard.  You can also redirect input from
a file when you launch sqlite3, of course, but then you do not have the
ability to interact with the program.  Sometimes it is useful to run an
SQL script contained in a file entering other commands from the command-line.
For this, the &#34;.read&#34; dot-command is provided.

</p><p>The &#34;.read&#34; command takes a single argument which is (usually) the name
of a file from which to read input text.

</p><div><pre>sqlite&gt; <b>.read myscript.sql</b>
</pre></div>

<p>The &#34;.read&#34; command temporarily stops reading from the keyboard and instead
takes its input from the file named.  Upon reaching the end of the file,
input reverts back to the keyboard.  The script file may contain dot-commands,
just like ordinary interactive input.

</p><p>If the argument to &#34;.read&#34; begins with the &#34;|&#34; character, then instead of
opening the argument as a file, it runs the argument (without the leading &#34;|&#34;)
as a command, then uses the output of that command as its input.  Thus, if you
have a script that generates SQL, you can execute that SQL directly using
a command similar to the following:

</p><div><pre>sqlite&gt; <b>.read |myscript.bat</b>
</pre></div>


<h2 id="file_i_o_functions"><span>8.3. </span>File I/O Functions</h2>

<p>The command-line shell adds two <a href="https://www.sqlite.org/appfunc.html">application-defined SQL functions</a> that
facilitate reading content from a file into a table column, and writing the
content of a column into a file, respectively.

</p><p>The readfile(X) SQL function reads the entire content of the file named
X and returns that content as a BLOB.  This can be used to load content into
a table.  For example:

</p><div><pre>sqlite&gt; <b>CREATE TABLE images(name TEXT, type TEXT, img BLOB);</b>
sqlite&gt; <b>INSERT INTO images(name,type,img</b>)
   ...&gt; <b>  VALUES(&#39;icon&#39;,&#39;jpeg&#39;,readfile(&#39;icon.jpg&#39;));</b>
</pre></div>

<p>The writefile(X,Y) SQL function write the blob Y into the file named X
and returns the number of bytes written.  Use this function to extract
the content of a single table column into a file.  For example:

</p><div><pre>sqlite&gt; <b>SELECT writefile(&#39;icon.jpg&#39;,img) FROM images WHERE name=&#39;icon&#39;;</b>
</pre></div>

<p>Note that the readfile(X) and writefile(X,Y) functions are extension
functions and are not built into the core SQLite library.  These routines
are available as a <a href="https://www.sqlite.org/loadext.html">loadable extension</a> in the
<a href="http://www.sqlite.org/src/artifact?ci=trunk&amp;filename=ext/misc/fileio.c">ext/misc/fileio.c</a>
source file in the <a href="https://www.sqlite.org/download.html#srctree">SQLite source code repositories</a>.

<a name="editfunc"></a>

</p><h2 id="the_edit_sql_function"><span>8.4. </span>The edit() SQL function</h2>

<p>The CLI has another built-in SQL function named edit().  Edit() takes
one or two arguments.  The first argument is a value - often a large
multi-line string to be edited.  The second argument is the invocation
for a text editor. (It may include options to affect the editor&#39;s
behavior.) If the second argument is omitted, the VISUAL environment
variable is used.  The edit() function writes its first argument into a
temporary file, invokes the editor on the temporary file, rereads the file
back into memory after the editor is done, then returns the edited text.

</p><p>The edit() function can be used to make changes to large text
values.  For example:

</p><div><pre>sqlite&gt; <b>UPDATE docs SET body=edit(body) WHERE name=&#39;report-15&#39;;</b>
</pre></div>

<p>In this example, the content of the docs.body field for the entry where
docs.name is &#34;report-15&#34; will be sent to the editor.  After the editor returns,
the result will be written back into the docs.body field.

</p><p>The default operation of edit() is to invoke a text editor.  But by using
an alternative edit program in the second argument, you can also get it to edit
images or other non-text resources.  For example, if you want to modify a JPEG
image that happens to be stored in a field of a table, you could run:

</p><div><pre>sqlite&gt; <b>UPDATE pics SET img=edit(img,&#39;gimp&#39;) WHERE id=&#39;pic-1542&#39;;</b>
</pre></div>

<p>The edit program can also be used as a viewer, by simply ignoring the
return value.  For example, to merely look at the image above, you might run:

</p><div><pre>sqlite&gt; <b>SELECT length(edit(img,&#39;gimp&#39;)) WHERE id=&#39;pic-1542&#39;;</b>
</pre></div>

<h2 id="importing_files_as_csv_or_other_formats"><span>8.5. </span>Importing files as CSV or other formats</h2>

<p>Use the &#34;.import&#34; command to import CSV (comma separated value)
or similarly delimited data into an SQLite table.
The &#34;.import&#34; command takes two arguments which are the
source from which data is to be read and the name of the
SQLite table into which the data is to be inserted. The source argument
is the name of a file to be read or, if it begins with a &#34;|&#34; character,
it specifies a command which will be run to produce the input data.

</p><p>Note that it may be important to set the &#34;mode&#34; before running the
 &#34;.import&#34; command.  This is prudent to prevent the command-line shell
from trying to interpret the input file text as some format other than
how the file is structured. If the --csv or --ascii options are used,
they control import input delimiters. Otherwise, the delimiters are
those in effect for the current output mode.

</p><p>To import into a table not in the &#34;main&#34; schema, the --schema option
may be used to specify that the table is in some other schema. This can
be useful for ATTACH&#39;ed databases or to import into a TEMP table.

</p><p>When .import is run, its treatment of the first input row depends
upon whether the target table already exists. If it does not exist,
the table is automatically created and the content of the first input
row is used to set the name of all the columns in the table. In this
case, the table data content is taken from the second and subsequent
input rows. If the target table already exists, every row of the
input, including the first, is taken to be actual data content.  If
the input file contains an initial row of column labels, you can make
the .import command skip that initial row using the &#34;--skip 1&#34; option.

</p><p>Here is an example usage, loading a pre-existing temporary table
from a CSV file which has column names in its first row:

</p><div><pre>sqlite&gt; <b>.import --csv --skip 1 --schema temp C:/work/somedata.csv tab1</b>
</pre></div>

<h2 id="export_to_csv"><span>8.6. </span>Export to CSV</h2>

<p>To export an SQLite table (or part of a table) as CSV, simply set
the &#34;mode&#34; to &#34;csv&#34; and then run a query to extract the desired rows
of the table.

</p><div><pre>sqlite&gt; <b>.headers on</b>
sqlite&gt; <b>.mode csv</b>
sqlite&gt; <b>.once c:/work/dataout.csv</b>
sqlite&gt; <b>SELECT * FROM tab1;</b>
sqlite&gt; <b>.system c:/work/dataout.csv</b>
</pre></div>

<p>In the example above, the &#34;.headers on&#34; line causes column labels to
be printed as the first row of output.  This means that the first row of
the resulting CSV file will contain column labels.  If column labels are
not desired, set &#34;.headers off&#34; instead. (The &#34;.headers off&#34; setting is
the default and can be omitted if the headers have not been previously
turned on.)

</p><p>The line &#34;.once <i>FILENAME</i>&#34; causes all query output to go into
the named file instead of being printed on the console.  In the example
above, that line causes the CSV content to be written into a file named
&#34;C:/work/dataout.csv&#34;.

</p><p>The final line of the example (the &#34;.system c:/work/dataout.csv&#34;)
has the same effect as double-clicking on the c:/work/dataout.csv file
in windows.  This will typically bring up a spreadsheet program to display
the CSV file.

</p><p>That command only works as written on Windows.  
The equivalent line on a Mac would be:

</p><div><pre>sqlite&gt; <b>.system open dataout.csv</b>
</pre></div>

<p>On Linux and other unix systems you will need to enter something like:


</p><div><pre>sqlite&gt; <b>.system xdg-open dataout.csv</b>
</pre></div>

<h3 id="_export_to_excel_"><span>8.6.1. </span> Export to Excel </h3>

<p>To simplify export to a spreadsheet, the CLI provides the
&#34;.excel&#34; command which captures the output of a single query and sends
that output to the default spreadsheet program on the host computer.
Use it like this:

</p><div><pre>sqlite&gt; <b>.excel</b>
sqlite&gt; <b>SELECT * FROM tab;</b>
</pre></div>

<p>
The command above writes the output of the query as CSV into a temporary
file, invokes the default handler for CSV files (usually the preferred
spreadsheet program such as Excel or LibreOffice), then deletes the
temporary file.  This is essentially a short-hand method of doing
the sequence of &#34;.csv&#34;, &#34;.once&#34;, and &#34;.system&#34; commands described above.

</p><p>
The &#34;.excel&#34; command is really an alias for &#34;.once -x&#34;.  The -x option
to .once causes it to writes results as CSV into a temporary file that
is named with a &#34;.csv&#34; suffix, then invoke the systems default handler
for CSV files.

</p><p>
There is also a &#34;.once -e&#34; command which works similarly, except that
it names the temporary file with a &#34;.txt&#34; suffix so that the default
text editor for the system will be invoked, instead of the default
spreadsheet.



<a name="zipdb"></a>

</p>

<p>In addition to reading and writing SQLite database files,
the <b>sqlite3</b> program will also read and write ZIP archives.
Simply specify a ZIP archive filename in place of an SQLite database
filename on the initial command line, or in the &#34;.open&#34; command,
and <b>sqlite3</b> will automatically detect that the file is a
ZIP archive instead of an SQLite database and will open it as such.
This works regardless of file suffix.  So you can open JAR, DOCX,
and ODP files and any other file format that is really a ZIP
archive and SQLite will read it for you.

</p><p>A ZIP archive appears to be a database containing a single table
with the following schema:

</p><div><pre>CREATE TABLE zip(
  name,     // Name of the file
  mode,     // Unix-style file permissions
  mtime,    // Timestamp, seconds since 1970
  sz,       // File size after decompression
  rawdata,  // Raw compressed file data
  data,     // Uncompressed file content
  method    // ZIP compression method code
);
</pre></div>

<p>So, for example, if you wanted to see the compression efficiency
(expressed as the size of the compressed content relative to the
original uncompressed file size) for all files in the ZIP archive,
sorted from most compressed to least compressed, you could run a
query like this:

</p><div><pre>sqlite&gt; SELECT name, (100.0*length(rawdata))/sz FROM zip ORDER BY 2;
</pre></div>

<p>Or using <a href="https://www.sqlite.org/cli.html#fileio">file I/O functions</a>, you can extract elements of the
ZIP archive:

</p><div><pre>sqlite&gt; SELECT writefile(name,content) FROM zip
   ...&gt; WHERE name LIKE &#39;docProps/%&#39;;
</pre></div>

<h2 id="how_zip_archive_access_is_implemented"><span>9.1. </span>How ZIP archive access is implemented</h2>

<p>The command-line shell uses the <a href="https://www.sqlite.org/zipfile.html">Zipfile virtual table</a> to
access ZIP archives.  You can see this by running the &#34;.schema&#34;
command when a ZIP archive is open:

</p><div><pre>sqlite&gt; .schema
CREATE VIRTUAL TABLE zip USING zipfile(&#39;document.docx&#39;)
/* zip(name,mode,mtime,sz,rawdata,data,method) */;
</pre></div>

<p>When opening a file, if the command-line client discovers that the
file is ZIP archive instead of an SQLite database, it actually opens
an <a href="https://www.sqlite.org/inmemorydb.html">in-memory database</a> and then in that in-memory database it creates
an instance of the <a href="https://www.sqlite.org/zipfile.html">Zipfile virtual table</a> that is attached to the
ZIP archive.

</p><p>The special processing for opening ZIP archives is a trick of the
command-line shell, not the core SQLite library.  So if you want to
open a ZIP archive as a database in your application, you will need to
activate the <a href="https://www.sqlite.org/zipfile.html">Zipfile virtual table</a> module then run an appropriate
<a href="https://www.sqlite.org/lang_createvtab.html">CREATE VIRTUAL TABLE</a> statement.


<a name="dump"></a>

</p>

<p>Use the &#34;.dump&#34; command to convert the entire contents of a
database into a single UTF-8 text file.  This file can be converted
back into a database by piping it back into <b>sqlite3</b>.</p>

<p>A good way to make an archival copy of a database is this:</p>


<div><pre>$ <b>sqlite3 ex1 .dump | gzip -c &gt;ex1.dump.gz</b>
</pre></div>


<p>This generates a file named <b>ex1.dump.gz</b> that contains everything
you need to reconstruct the database at a later time, or on another
machine.  To reconstruct the database, just type:</p>


<div><pre>$ <b>zcat ex1.dump.gz | sqlite3 ex2</b>
</pre></div>


<p>The text format is pure SQL so you
can also use the .dump command to export an SQLite database
into other popular SQL database engines.  Like this:</p>


<div><pre>$ <b>createdb ex2</b>
$ <b>sqlite3 ex1 .dump | psql ex2</b>
</pre></div>



<p>Like the &#34;.dump&#34; command, &#34;.recover&#34; attempts to convert the entire 
contents of a database file to text. The difference is that instead of
reading data using the normal SQL database interface, &#34;.recover&#34;
attempts to reassemble the database based on data extracted directly from 
as many database pages as possible. If the database is corrupt, &#34;.recover&#34;
is usually able to recover data from all uncorrupted parts of the database,
whereas &#34;.dump&#34; stops when the first sign of corruption is encountered.

</p><p>If the &#34;.recover&#34; command recovers one or more rows that it cannot 
attribute to any database table, the output script creates a &#34;lost_and_found&#34;
table to store the orphaned rows. The schema of the lost_and_found
table is as follows:

</p><div><pre>CREATE TABLE lost_and_found(
    rootpgno INTEGER,             -- root page of tree pgno is a part of
    pgno INTEGER,                 -- page number row was found on
    nfield INTEGER,               -- number of fields in row
    id INTEGER,                   -- value of rowid field, or NULL
    c0, c1, c2, c3...             -- columns for fields of row
);
</pre></div>

<p>The &#34;lost_and_found&#34; table contains one row for each orphaned row recovered
from the database. Additionally, there is one row for each recovered index
entry that cannot be attributed to any SQL index. This is because, in an
SQLite database, the same format is used to store SQL index entries and
WITHOUT ROWID table entries.

</p><table striped="1">
  <tbody><tr><th>Column</th><th>Contents
  </th></tr><tr><td>rootpgno</td><td> Even though it may not be possible to attribute the 
      row to a specific database table, it may be part of a tree structure
      within the database file. In this case, the root page number of that
      tree structure is stored in this column. Or, if the page the row was
      found on is not part of a tree structure, this column stores a copy of
      the value in column &#34;pgno&#34; - the page number of the page the row was
      found on. In many, although not all, cases, all rows in the
      lost_and_found table with the same value in this column belong to the
      same table.

  </td></tr><tr><td>pgno</td><td> The page number of the page on which this row was found.

  </td></tr><tr><td>nfield</td><td> The number of fields in this row.

  </td></tr><tr><td>id</td><td> If the row comes from a WITHOUT ROWID table, this column 
      contains NULL. Otherwise, it contains the 64-bit integer rowid value for
      the row.

  </td></tr><tr><td>c0, c1, c2...</td><td> The values for each column of the row
      are stored in these columns. The &#34;.recover&#34; command creates the
      lost_and_found table with as many columns as required by the longest
      orphaned row.
</td></tr></tbody></table>

<p>If the recovered database schema already contains a table named
&#34;lost_and_found&#34;, the &#34;.recover&#34; command uses the name &#34;lost_and_found0&#34;. If
the name &#34;lost_and_found0&#34; is also already taken, &#34;lost_and_found1&#34;, and so
on. The default name &#34;lost_and_found&#34; may be overridden by invoking &#34;.recover&#34;
with the --lost-and-found switch. For example, to have the output script call
the table &#34;orphaned_rows&#34;:

</p><div><pre>sqlite&gt; .recover --lost-and-found orphaned_rows
</pre></div>



<p>You can add new custom <a href="https://www.sqlite.org/appfunc.html">application-defined SQL functions</a>,
<a href="https://www.sqlite.org/datatype3.html#collation">collating sequences</a>, <a href="https://www.sqlite.org/vtab.html">virtual tables</a>, and <a href="https://www.sqlite.org/vfs.html">VFSes</a> to the command-line
shell at run-time using the &#34;.load&#34; command.  First, build the
extension as a DLL or shared library (as described in the
<a href="https://www.sqlite.org/loadext.html">Run-Time Loadable Extensions</a> document) then type:

</p><div><pre>sqlite&gt; .load /path/to/my_extension
</pre></div>

<p>Note that SQLite automatically adds the appropriate extension suffix
(&#34;.dll&#34; on windows, &#34;.dylib&#34; on Mac, &#34;.so&#34; on most other unixes) to the
extension filename.  It is generally a good idea to specify the full
pathname of the extension.

</p><p>SQLite computes the entry point for the extension based on the extension
filename.  To override this choice, simply add the name of the extension
as a second argument to the &#34;.load&#34; command.

</p><p>Source code for several useful extensions can be found in the
<a href="http://www.sqlite.org/src/tree?name=ext/misc&amp;ci=trunk">ext/misc</a>
subdirectory of the SQLite source tree.  You can use these extensions
as-is, or as a basis for creating your own custom extensions to address
your own particular needs.


<a name="sha3sum"></a>

</p>

<p>The &#34;.sha3sum&#34; dot-command computes a
<a href="https://en.wikipedia.org/wiki/SHA-3">SHA3</a> hash of the <em>content</em>
of the database.  To be clear, the hash is computed over the database content,
not its representation on disk.  This means, for example, that a <a href="https://www.sqlite.org/lang_vacuum.html">VACUUM</a>
or similar data-preserving transformation does not change the hash.

</p><p>The &#34;.sha3sum&#34; command supports options &#34;--sha3-224&#34;, &#34;--sha3-256&#34;, 
&#34;--sha3-384&#34;, and &#34;--sha3-512&#34; to define which variety of SHA3 to use
for the hash.  The default is SHA3-256.

</p><p>The database schema (in the <a href="https://www.sqlite.org/schematab.html">sqlite_schema</a> table) is not normally
included in the hash, but can be added by the &#34;--schema&#34; option.

</p><p>The &#34;.sha3sum&#34; command takes a single optional argument which is a
<a href="https://www.sqlite.org/lang_expr.html#like">LIKE</a> pattern.  If this option is present, only tables whose names match
the <a href="https://www.sqlite.org/lang_expr.html#like">LIKE</a> pattern will be hashed.

</p><p>The &#34;.sha3sum&#34; command is implemented with the help of the
<a href="https://www.sqlite.org/src/file/ext/misc/shathree.c">extension function &#34;sha3_query()&#34;</a>
that is included with the command-line shell.

<a name="selftest"></a>

</p>

<p>The &#34;.selftest&#34; command attempts to verify that a database is
intact and is not corrupt.  
The .selftest command looks for a table in schema named &#34;selftest&#34;
and defined as follows:

</p><div><pre>CREATE TABLE selftest(
  tno INTEGER PRIMARY KEY,  -- Test number
  op TEXT,                  -- &#39;run&#39; or &#39;memo&#39;
  cmd TEXT,                 -- SQL command to run, or text of &#34;memo&#34;
  ans TEXT                  -- Expected result of the SQL command
);
</pre></div>

<p>The .selftest command reads the rows of the selftest table in
selftest.tno order.
For each &#39;memo&#39; row, it writes the text in &#39;cmd&#39; to the output.  For
each &#39;run&#39; row, it runs the &#39;cmd&#39; text as SQL and compares the result
to the value in &#39;ans&#39;, and shows an error message if the results differ.

</p><p>If there is no selftest table, the &#34;.selftest&#34; command runs
<a href="https://www.sqlite.org/pragma.html#pragma_integrity_check">PRAGMA integrity_check</a>.

</p><p>The &#34;.selftest --init&#34; command creates the selftest table if it
does not already exists, then appends entries that check the SHA3
hash of the content of all tables.  Subsequent runs of &#34;.selftest&#34;
will verify that the database has not been changed in any way.  To
generate tests to verify that a subset of the tables is unchanged,
simply run &#34;.selftest --init&#34; then <a href="https://www.sqlite.org/lang_delete.html">DELETE</a> the selftest rows that
refer to tables that are not constant.  

<a name="sqlar"></a>

</p>

<p>The &#34;.archive&#34; dot-command and the &#34;-A&#34; command-line option
provide built-in support for the 
<a href="https://www.sqlite.org/sqlar.html">SQLite Archive format</a>. The interface is similar to
that of the &#34;tar&#34; command on unix systems. Each invocation of the &#34;.ar&#34;
command must specify a single command option. The following commands
are available for &#34;.archive&#34;:

</p><table striped="1">
  <tbody><tr><th>Option</th><th>Long Option</th><th>Purpose
  </th></tr><tr><td>-c</td><td>--create</td><td>Create a new archive containing specified files.
  </td></tr><tr><td>-x</td><td>--extract</td><td>Extract specified files from archive.
  </td></tr><tr><td>-i</td><td>--insert</td><td>Add files to existing archive.
  </td></tr><tr><td>-r</td><td>--remove</td><td>Remove files from the archive.
  </td></tr><tr><td>-t</td><td>--list</td><td>List the files in the archive.
  </td></tr><tr><td>-u</td><td>--update</td><td>Add files to existing archive <em>if</em> they have changed.
</td></tr></tbody></table>

<p>As well as the command option, each invocation of &#34;.ar&#34; may specify
one or more modifier options. Some modifier options require an argument,
some do not. The following modifier options are available:

</p><table striped="1">
  <tbody><tr><th>Option</th><th>Long Option</th><th>Purpose
  </th></tr><tr><td>-v</td><td>--verbose</td><td>List each file as it is processed.
  </td></tr><tr><td>-f FILE</td><td>--file FILE</td><td>If specified, use file FILE as the
  archive. Otherwise, assume that the current &#34;main&#34; database is the 
  archive to be operated on.
  </td></tr><tr><td>-a FILE</td><td>--append FILE</td><td>Like --file, use file FILE as the
  archive, but open the file using the 
  <a href="https://sqlite.org/src/file/ext/misc/appendvfs.c">apndvfs VFS</a> so that
  the archive will be appended to the end of FILE if FILE already exists.
  </td></tr><tr><td>-C DIR</td><td>--directory DIR</td><td>If specified, interpret all relative
  paths as relative to DIR, instead of the current working directory.
  </td></tr><tr><td>-g</td><td>--glob</td><td>Use <a href="https://www.sqlite.org/lang_corefunc.html#glob">glob(<i>Y</i>,<i>X</i>)</a> to match arguments
  against names in the archive.
  </td></tr><tr><td>-n</td><td>--dryrun</td><td>Show the SQL that would be run to carry out the
                       archive operation, but do not actually change anything.
  </td></tr><tr><td>--</td><td>--</td><td>All subsequent command line words are command arguments,
  not options.
</td></tr></tbody></table>

<p>
For command-line usage, add the short style command-line options immediately
following the &#34;-A&#34;, without an intervening space.  All subsequent arguments
are considered to be part of the .archive command.  For example, the following 
commands are equivalent:

</p><div><pre>sqlite3 new_archive.db -Acv file1 file2 file3
sqlite3 new_archive.db &#34;.ar -cv file1 file2 file3&#34;
</pre></div>

<p>
Long and short style options may be mixed. For example, the following are
equivalent:

</p><div><pre><i>-- Two ways to create a new archive named &#34;new_archive.db&#34; containing</i>
<i>-- files &#34;file1&#34;, &#34;file2&#34; and &#34;file3&#34;.</i>
.ar -c --file new_archive.db file1 file2 file3
.ar -f new_archive.db --create file1 file2 file3
</pre></div>

<p>Alternatively, the first argument following to &#34;.ar&#34; may be the concatenation
of the short form of all required options (without the &#34;-&#34; characters). In 
this case arguments for options requiring them are read from the command line
next, and any remaining words are considered command arguments. For example:

</p><div><pre><i>-- Create a new archive &#34;new_archive.db&#34; containing files &#34;file1&#34; and</i>
<i>-- &#34;file2&#34; from directory &#34;dir1&#34;.</i>
.ar cCf dir1 new_archive.db file1 file2 file3
</pre></div>

<h2 id="_sqlite_archive_create_command_"><span>15.1. </span> SQLite Archive Create Command </h2>

<p>Create a new archive, overwriting any existing archive (either in the current
&#34;main&#34; db or in the file specified by a --file option). Each argument following
the options is a file to add to the archive. Directories are imported
recursively. See above for examples.

</p><h2 id="_sqlite_archive_extract_command_"><span>15.2. </span> SQLite Archive Extract Command </h2>

<p>Extract files from the archive (either to the current working directory or
to the directory specified by a --directory option). 
Files or directories whose names match the arguments,
as affected by the --glob option, are extracted. 
Or, if no arguments follow the options, all files and directories are extracted.
Any specified directories are extracted recursively. It is an error if any
specified names or match patterns cannot be found in the archive.

</p><div><pre><i>-- Extract all files from the archive in the current &#34;main&#34; db to the</i>
<i>-- current working directory. List files as they are extracted. </i>
.ar --extract --verbose

<i>-- Extract file &#34;file1&#34; from archive &#34;ar.db&#34; to directory &#34;dir1&#34;.</i>
.ar fCx ar.db dir1 file1

<i>-- Extract files with &#34;.h&#34; extension to directory &#34;headers&#34;.</i>
.ar -gCx headers *.h
</pre></div>

<h2 id="_sqlite_archive_list_command_"><span>15.3. </span> SQLite Archive List Command </h2>

<p>List the contents of the archive. If no arguments are specified, then all
files are listed. Otherwise, only those which match the arguments,
as affected by the --glob option, are listed. Currently,
the --verbose option does not change the behaviour of this command. That may
change in the future.

</p><div><pre><i>-- List contents of archive in current &#34;main&#34; db.</i>.
.ar --list
</pre></div>

<h2 id="_sqlite_archive_insert_and_update_commands_"><span>15.4. </span> SQLite Archive Insert And Update Commands </h2>

<p> The --update and --insert commands work like --create command, except that 
they do not delete the current archive before commencing. New versions of
files silently replace existing files with the same names, but otherwise
the initial contents of the archive (if any) remain intact.

</p><p> For the --insert command, all files listed are inserted into the archive.
For the --update command, files are only inserted if they do not previously
exist in the archive, or if their &#34;mtime&#34; or &#34;mode&#34; is different from what
is currently in the archive.

</p><p> Compatibility node:  Prior to SQLite version 3.28.0 (2019-04-16) only
the --update option was supported but that option worked like --insert in that
it always reinserted every file regardless of whether or not it had changed.

</p><h2 id="_sqlite_archive_remove_command_"><span>15.5. </span> SQLite Archive Remove Command </h2>

<p> The --remove command deletes files and directories which match the
provided arguments (if any) as affected by the --glob option.
It is an error to provide arguments which match nothing in the archive.

</p><h2 id="_operations_on_zip_archives_"><span>15.6. </span> Operations On ZIP Archives </h2>

<p>If FILE is a ZIP archive rather than an SQLite Archive, the &#34;.archive&#34;
command and the &#34;-A&#34; command-line option still work.  This is accomplished
using of the <a href="https://www.sqlite.org/zipfile.html">zipfile</a> extension.
Hence, the following commands are roughly equivalent,
differing only in output formatting:

</p><table striped="1">
  <tbody><tr><th>Traditional Command</th><th>Equivalent sqlite3.exe Command
  </th></tr><tr><td>unzip archive.zip</td><td>sqlite3 -Axf archive.zip
  </td></tr><tr><td>unzip -l archive.zip</td><td>sqlite3 -Atvf archive.zip
  </td></tr><tr><td>zip -r archive2.zip dir</td><td>sqlite3 -Acf archive2.zip dir
</td></tr></tbody></table>

<h2 id="_sql_used_to_implement_sqlite_archive_operations_"><span>15.7. </span> SQL Used To Implement SQLite Archive Operations </h2>

<p>The various SQLite Archive Archive commands are implemented using SQL statements.
Application developers can easily add SQLite Archive Archive reading and writing
support to their own projects by running the appropriate SQL.

</p><p>To see what SQL statements are used to implement an SQLite Archive
operation, add the --dryrun or -n option.  This causes the SQL to be
displayed but inhibits the execution of the SQL.

</p><p>The SQL statements used to implement SQLite Archive operations make use of
various <a href="https://www.sqlite.org/loadext.html">loadable extensions</a>.  These extensions are all available in
the <a href="https://sqlite.org/src">SQLite source tree</a> in the
<a href="https://sqlite.org/src/file/ext/misc">ext/misc/ subfolder</a>.
The extensions needed for full SQLite Archive support include:

</p><ol>
<li><p>
<a href="https://sqlite.org/src/file/ext/misc/fileio.c">fileio.c</a> —
This extension adds SQL functions readfile() and writefile() for
reading and writing content from files on disk.  The fileio.c
extension also includes fsdir() table-valued function for listing
the contents of a directory and the lsmode() function for converting
numeric st_mode integers from the stat() system call into human-readable
strings after the fashion of the &#34;ls -l&#34; command.

</p></li><li><p>
<a href="https://sqlite.org/src/file/ext/misc/sqlar.c">sqlar.c</a> —
This extension adds the sqlar_compress() and sqlar_uncompress()
functions that are needed to compress and uncompress file content
as it is inserted and extracted from an SQLite Archive.

</p></li><li><p>
<a href="https://www.sqlite.org/zipfile.html">zipfile.c</a> —
This extension implements the &#34;zipfile(FILE)&#34; table-valued function
which is used to read ZIP archives.  This extension is only needed
when reading ZIP archives instead of SQLite archives.

</p></li><li><p>
<a href="https://sqlite.org/src/file/ext/misc/appendvfs.c">appendvfs.c</a> —
This extension implements a new <a href="https://www.sqlite.org/vfs.html">VFS</a> that allows an SQLite database
to be appended to some other file, such as an executable.  This
extension is only needed if the --append option to the .archive
command is used.
</p></li></ol>



<p>SQLite allows <a href="https://www.sqlite.org/lang_expr.html#varparam">bound parameters</a> to appear in an SQL statement anywhere
that a literal value is allowed.  The values for these parameters are set
using the <a href="https://www.sqlite.org/c3ref/bind_blob.html">sqlite3_bind_...()</a> family of APIs.

</p><p>Parameters can be either named or unnamed.  An unnamed parameter is a single
question mark (&#34;?&#34;).  Named parameters are a &#34;?&#34; followed immediately by a number
(ex: &#34;?15&#34; or &#34;?123&#34;) or one of the characters &#34;$&#34;, &#34;:&#34;, or &#34;@&#34; followed by an
alphanumeric name (ex: &#34;$var1&#34;, &#34;:xyz&#34;, &#34;@bingo&#34;).

</p><p>This command-line shell leaves unnamed parameters unbound, meaning that they
will have a value of an SQL NULL, but named parameters might be assigned values.
If there exists a TEMP table named &#34;sqlite_parameters&#34; with a schema like this:

</p><div><pre>CREATE TEMP TABLE sqlite_parameters(
  key TEXT PRIMARY KEY,
  value
) WITHOUT ROWID;
</pre></div>

<p>And if there is an entry in that table where the key column exactly matches
the name of parameter (including the initial &#34;?&#34;, &#34;$&#34;, &#34;:&#34;, or &#34;@&#34; character)
then the parameter is assigned the value of the value column.  If no entry exists,
the parameter defaults to NULL.

</p><p>The &#34;.parameter&#34; command exists to simplify managing this table.  The
&#34;.parameter init&#34; command (often abbreviated as just &#34;.param init&#34;) creates
the temp.sqlite_parameters table if it does not already exist.  The &#34;.param list&#34;
command shows all entries in the temp.sqlite_parameters table.  The &#34;.param clear&#34;
command drops the temp.sqlite_parameters table.  The &#34;.param set KEY VALUE&#34; and
&#34;.param unset KEY&#34; commands create or delete entries from the 
temp.sqlite_parameters table.

</p><p>The VALUE passed to &#34;.param set KEY VALUE&#34; can be either a SQL literal
or any other SQL expression or query which can be evaluated to yield a value.
This allows values of differing types to be set.
If such evaluation fails, the provided VALUE is instead quoted and inserted
as text.
Because such initial evaluation may or may not fail depending upon
the VALUE content, the reliable way to get a text value is to enclose it
with single-quotes protected from the above-described command-tail parsing.
For example, (unless one intends a value of -1365):<br/>
</p><div><pre>.parameter init
.parameter set @phoneNumber &#34;&#39;202-456-1111&#39;&#34;
</pre></div>
<p>Note that the double-quotes serve to protect the single-quotes
and ensure that the quoted text is parsed as one argument.

</p><p>The temp.sqlite_parameters table only provides values for parameters in the
command-line shell.  The temp.sqlite_parameter table has no effect on queries
that are run directly using the SQLite C-language API.  Individual applications
are expected to implement their own parameter binding.  You can search for 
&#34;sqlite_parameters&#34; in the 
<a href="https://sqlite.org/src/file/src/shell.c.in">command-line shell source code</a>
to see how the command-line shell does parameter binding, and use that as
a hint for how to implement it yourself.

<a name="expert"></a>

</p>

<p><b>Note: This command is experimental. It may be removed or the 
interface modified in incompatible ways at some point in the future.

</b></p><p>For most non-trivial SQL databases, the key to performance is creating
the right SQL indexes. In this context &#34;the right SQL indexes&#34; means those
that cause the queries that an application needs to optimize run fast. The
&#34;.expert&#34; command can assist with this by proposing indexes that might
assist with specific queries, were they present in the database.

</p><p>The &#34;.expert&#34; command is issued first, followed by the SQL query 
on a separate line. For example, consider the following session:

</p><div><pre>sqlite&gt; CREATE TABLE x1(a, b, c);                  <i>-- Create table in database </i>
sqlite&gt; .expert
sqlite&gt; SELECT * FROM x1 WHERE a=? AND b&gt;?;        <i>-- Analyze this SELECT </i>
CREATE INDEX x1_idx_000123a7 ON x1(a, b);

0|0|0|SEARCH TABLE x1 USING INDEX x1_idx_000123a7 (a=? AND b&gt;?)

sqlite&gt; CREATE INDEX x1ab ON x1(a, b);             <i>-- Create the recommended index </i>
sqlite&gt; .expert
sqlite&gt; SELECT * FROM x1 WHERE a=? AND b&gt;?;        <i>-- Re-analyze the same SELECT </i>
(no new indexes)

0|0|0|SEARCH TABLE x1 USING INDEX x1ab (a=? AND b&gt;?)
</pre></div>

<p>In the above, the user creates the database schema (a single table - &#34;x1&#34;),
and then uses the &#34;.expert&#34; command to analyze a query, in this case 
&#34;SELECT * FROM x1 WHERE a=? AND b&gt;?&#34;. The shell tool recommends that the
user create a new index (index &#34;x1_idx_000123a7&#34;) and outputs the plan
that the query would use in <a href="https://www.sqlite.org/eqp.html">EXPLAIN QUERY PLAN</a> format. The user then creates
an index with an equivalent schema and runs the analysis on the same query
again. This time the shell tool does not recommend any new indexes, and 
outputs the plan that SQLite will use for the query given the existing 
indexes.

</p><p>The &#34;.expert&#34; command accepts the following options:

</p><table striped="1">
<tbody><tr><th> Option </th><th> Purpose
</th></tr><tr><td> ‑‑verbose
    </td><td> If present, output a more verbose report for each query analyzed.
</td></tr><tr><td> ‑‑sample PERCENT 
    </td><td> This parameter defaults to 0, causing the &#34;.expert&#34; command to
         recommend indexes based on the query and database schema alone.
         This is similar to the way the <a href="https://www.sqlite.org/optoverview.html">SQLite query planner</a> selects
         indexes for queries if the user has not run the <a href="https://www.sqlite.org/lang_analyze.html">ANALYZE</a> command
         on the database to generate data distribution statistics. 
         <div><p>
         If this option is passed a non-zero argument, the &#34;.expert&#34; command
         generates similar data distribution statistics for all indexes
         considered based on PERCENT percent of the rows currently stored in
         each database table. For databases with unusual data distributions,
         this may lead to better index recommendations, particularly if the
         application intends to run ANALYZE.
         </p><p>
         For small databases and modern CPUs, there is usually no reason not
         to pass &#34;--sample 100&#34;. However, gathering data distribution
         statistics can be expensive for large database tables. If the
         operation is too slow, try passing a smaller value for the --sample
         option.
</p></div></td></tr></tbody></table>

<p>The functionality described in this section may be integrated into other
applications or tools using the 
<a href="http://www.sqlite.org/src/dir?ci=trunk&amp;name=ext/expert">
SQLite expert extension</a> code.

</p><p>A database schema which incorporate SQL custom functions made available
via the extension load mechanism may need special provision to work with
the .expert feature. Because the feature uses additional connections to
implement its functionality, those custom functions must be made available
to those additional connections. This can be done by means of the extension
load/usage options described at 
<a href="https://www.sqlite.org/c3ref/auto_extension.html">
Automatically Load Statically Linked Extensions</a>
and <a href="https://www.sqlite.org/loadext.html#persist">
Persistent Loadable Extensions</a>.

<a name="dotconn"></a>

</p>

<p>
Beginning with version 3.37.0 (2021-11-27), the CLI has the ability to
hold multiple <a href="https://www.sqlite.org/c3ref/sqlite3.html">database connections</a> open at once.  Only one database connection
is active at a time.  The inactive connections are still open but are idle.

</p><p>
Use the &#34;.connection&#34; dot-command (often abbreviated as just &#34;.conn&#34;) to see a
list of database connections and an indication of which one is currently active.
Each database connection is identified by an integer between 0 and 9.  (There
can be at most 10 simultaneously open connections.)  Change to another database
connection, creating it if it does not already exist, by typing the &#34;.conn&#34;
command followed by its number.  Close a database connection by typing
&#34;.conn close N&#34; where N is the connection number.

</p><p>
Though the underlying SQLite database connections are completely independent
of one another, many of the CLI settings, such as the output format, are
shared across all database connections.  Thus, changing the <a href="https://www.sqlite.org/cli.html#dotmode">output mode</a> in
one connection will change it in them all.  On the other hand, some
<a href="https://www.sqlite.org/cli.html#dotcmd">dot-commands</a> such as <a href="https://www.sqlite.org/cli.html#dotopen">.open</a> only affect the current connection.

<a name="dotother"></a>

</p>

<p>There are many other dot-commands available in the command-line
shell.  See the &#34;.help&#34; command for a complete list for any particular
version and build of SQLite.

<a name="insh"></a>

</p>

<p>
One way to use sqlite3 in a shell script is to use &#34;echo&#34; or
&#34;cat&#34; to generate a sequence of commands in a file, then invoke sqlite3
while redirecting input from the generated command file.  This
works fine and is appropriate in many circumstances.  But as
an added convenience, sqlite3 allows a single SQL command to be
entered on the command line as a second argument after the
database name.  When the sqlite3 program is launched with two
arguments, the second argument is passed to the SQLite library
for processing, the query results are printed on standard output
in list mode, and the program exits.  This mechanism is designed
to make sqlite3 easy to use in conjunction with programs like
&#34;awk&#34;.  For example:</p>

<div><pre>$ <b>sqlite3 ex1 &#39;select * from tbl1&#39; \</b>
&gt; <b> | awk &#39;{printf &#34;&lt;tr&gt;&lt;td&gt;%s&lt;td&gt;%s\n&#34;,$1,$2 }&#39;</b>
&lt;tr&gt;&lt;td&gt;hello&lt;td&gt;10
&lt;tr&gt;&lt;td&gt;goodbye&lt;td&gt;20
$
</pre></div>



<p>
SQLite commands are normally terminated by a semicolon.  In the CLI
you can also use the word &#34;GO&#34; (case-insensitive) or a slash character 
&#34;/&#34; on a line by itself to end a command.  These are used by SQL Server 
and Oracle, respectively, and are supported by the SQLite CLI for
compatibility.  These won&#39;t work in <b>sqlite3_exec()</b>, 
because the CLI translates these inputs into a semicolon before passing 
them down into the SQLite core.</p>



<p>
There are many command-line options available to the CLI.  Use the --help
command-line option to see a list:

</p><div><pre>$ <b>sqlite3 --help</b>
Usage: ./sqlite3 [OPTIONS] FILENAME [SQL]
FILENAME is the name of an SQLite database. A new database is created
if the file does not previously exist.
OPTIONS include:
   -A ARGS...           run &#34;.archive ARGS&#34; and exit
   -append              append the database to the end of the file
   -ascii               set output mode to &#39;ascii&#39;
   -bail                stop after hitting an error
   -batch               force batch I/O
   -box                 set output mode to &#39;box&#39;
   -column              set output mode to &#39;column&#39;
   -cmd COMMAND         run &#34;COMMAND&#34; before reading stdin
   -csv                 set output mode to &#39;csv&#39;
   -deserialize         open the database using sqlite3_deserialize()
   -echo                print commands before execution
   -init FILENAME       read/process named file
   -[no]header          turn headers on or off
   -help                show this message
   -html                set output mode to HTML
   -interactive         force interactive I/O
   -json                set output mode to &#39;json&#39;
   -line                set output mode to &#39;line&#39;
   -list                set output mode to &#39;list&#39;
   -lookaside SIZE N    use N entries of SZ bytes for lookaside memory
   -markdown            set output mode to &#39;markdown&#39;
   -maxsize N           maximum size for a --deserialize database
   -memtrace            trace all memory allocations and deallocations
   -mmap N              default mmap size set to N
   -newline SEP         set output row separator. Default: &#39;\n&#39;
   -nofollow            refuse to open symbolic links to database files
   -nonce STRING        set the safe-mode escape nonce
   -nullvalue TEXT      set text string for NULL values. Default &#39;&#39;
   -pagecache SIZE N    use N slots of SZ bytes each for page cache memory
   -quote               set output mode to &#39;quote&#39;
   -readonly            open the database read-only
   -safe                enable safe-mode
   -separator SEP       set output column separator. Default: &#39;|&#39;
   -stats               print memory stats before each finalize
   -table               set output mode to &#39;table&#39;
   -tabs                set output mode to &#39;tabs&#39;
   -version             show SQLite version
   -vfs NAME            use NAME as the default VFS
   -zip                 open the file as a ZIP Archive
</pre></div>

<p>The CLI is flexible regarding command-line option formatting.
Either one or two leading &#34;-&#34; characters are permitted.
Thus &#34;-box&#34; and &#34;--box&#34; mean the same thing.
Command-line options are processed from left to right.
Hence a &#34;--box&#34; option will override a prior &#34;--quote&#34; option.

</p><p>
Most of the command-line options are self-explanatory, but a few merit additional
discussion below.

<a name="safemode"></a>

</p><h2 id="the_safe_command_line_option"><span>22.1. </span>The --safe command-line option</h2>

<p>The --safe command-line option attempts to disable all features of the CLI that
might cause any changes to the host computer other than changes to the specific database
file named on the command-line.  The idea is that if you receive a large SQL script
from an unknown or untrusted source, you can run that script to see what it does without
risking an exploit by using the --safe option.  The --safe option disables (among other
things):

</p><ul>
<li> The <a href="https://www.sqlite.org/cli.html#dotopen">.open command</a>, unless the --hexdb option is used or the filename is &#34;:memory:&#34;.
     This prevents the script from reading or writing any database files not named on
     the original command-line.
</li><li> The <a href="https://www.sqlite.org/lang_attach.html">ATTACH</a> SQL command.
</li><li> SQL functions that have potentially harmful side-effects, such as
     edit(), fts3_tokenizer(), load_extension(), readfile() and writefile().
</li><li> The <a href="https://www.sqlite.org/cli.html#sqlar">.archive command</a>.
</li><li> The .backup and .save commands.
</li><li> The <a href="https://www.sqlite.org/cli.html#csv">.import command</a>.
</li><li> The <a href="https://www.sqlite.org/cli.html#dotload">.load command</a>.
</li><li> The .log command.
</li><li> The .shell and .system commands.
</li><li> The .excel, .once and .output commands.
</li><li> Other commands that can have deleterious side effects.

</li></ul>

<p>Basically, any feature of the CLI that reads or writes from a file on disk other
than the main database file is disabled.

</p><h3 id="bypassing_safe_restrictions_for_specific_commands"><span>22.1.1. </span>Bypassing --safe restrictions for specific commands</h3>

<p>If the &#34;--nonce NONCE&#34; option is also included on the command-line, for some
large and arbitrary NONCE string, then the &#34;.nonce NONCE&#34; command (with the
same large nonce string) will permit the next SQL statement or dot-command
to bypass the --safe restrictions.

</p><p>Suppose you want to run a suspicious script and the script requires one or
two of the features that --safe normally disables.  For example, suppose it
needs to ATTACH one additional database.  Or suppose the script needs to load
a specific extension. This can be accomplished by preceding the (carefully
audited) ATTACH statement or the &#34;.load&#34; command with an appropriate &#34;.nonce&#34;
command and supplying the same nonce value using the &#34;--nonce&#34; command-line
option.  Those specific commands will then be allowed to execute normally,
but all other unsafe commands will still be restricted.

</p><p>The use of &#34;.nonce&#34; is dangerous in the sense that a mistake can allow a
hostile script to damage your system.  Therefore, use &#34;.nonce&#34; carefully,
sparingly, and as a last resort when there are no other ways to get a
script to run under --safe mode.

<a name="compiling"></a>

</p>

<p>
To compile the command-line shell on unix systems and on Windows with MinGW,
the usual configure-make command works:

</p>

<p>
The configure-make works whether you are building from the canonical sources
from the source tree, or from an amalgamated bundle.  There are few
dependencies.  When building from canonical sources, a working 
<a href="https://www.tcl.tk/man/tcl8.3/UserCmd/tclsh.htm">tclsh</a> is required.
If using an amalgamation bundle, all the preprocessing work normally 
done by tclsh will have already been carried out and only normal build
tools are required.

</p><p>
A working <a href="https://zlib.net">zlib compression library</a> is
needed in order for the <a href="https://www.sqlite.org/cli.html#sqlar">.archive command</a> to operate.

</p><p>
On Windows with MSVC, use nmake with the Makefile.msc:

</p>

<p>
For correct operation of the <a href="https://www.sqlite.org/cli.html#sqlar">.archive command</a>, make a copy of the
<a href="https://zlib.net">zlib source code</a> into the compat/zlib subdirectory 
of the source tree and compile this way:

</p><div><pre>nmake /f Makefile.msc USE_ZLIB=1
</pre></div>

<h2 id="_do_it_yourself_builds_"><span>23.1. </span> Do-It-Yourself Builds </h2>

<p>
The source code to the sqlite3 command line interface is in a single
file named &#34;shell.c&#34;.  The shell.c source file is generated from other
sources, but most of the code for shell.c can be found in
<a href="https://sqlite.org/src/file/src/shell.c.in">src/shell.c.in</a>.
(Regenerate shell.c by typing &#34;make shell.c&#34; from the canonical source tree.)
<a href="https://www.sqlite.org/howtocompile.html">Compile</a> the shell.c file (together
with the <a href="https://www.sqlite.org/amalgamation.html">sqlite3 library source code</a>) to generate
the executable.  For example:</p>

<div><pre>gcc -o sqlite3 shell.c sqlite3.c -ldl -lpthread -lz -lm
</pre></div>

<p>
The following additional compile-time options are recommended in order to
provide a full-featured command-line shell:

</p><ul>
<li> <a href="https://www.sqlite.org/compile.html#threadsafe">-DSQLITE_THREADSAFE=0</a>
</li><li> <a href="https://www.sqlite.org/compile.html#enable_explain_comments">-DSQLITE_ENABLE_EXPLAIN_COMMENTS</a>
</li><li> <a href="https://www.sqlite.org/compile.html#have_zlib">-DSQLITE_HAVE_ZLIB</a>
</li><li> <a href="https://www.sqlite.org/compile.html#introspection_pragmas">-DSQLITE_INTROSPECTION_PRAGMAS</a>
</li><li> <a href="https://www.sqlite.org/compile.html#enable_unknown_sql_function">-DSQLITE_ENABLE_UNKNOWN_SQL_FUNCTION</a>
</li><li> <a href="https://www.sqlite.org/compile.html#enable_stmtvtab">-DSQLITE_ENABLE_STMTVTAB</a>
</li><li> <a href="https://www.sqlite.org/compile.html#enable_dbpage_vtab">-DSQLITE_ENABLE_DBPAGE_VTAB</a>
</li><li> <a href="https://www.sqlite.org/compile.html#enable_dbstat_vtab">-DSQLITE_ENABLE_DBSTAT_VTAB</a>
</li><li> <a href="https://www.sqlite.org/compile.html#enable_offset_sql_func">-DSQLITE_ENABLE_OFFSET_SQL_FUNC</a>
</li><li> <a href="https://www.sqlite.org/compile.html#enable_json1">-DSQLITE_ENABLE_JSON1</a>
</li><li> <a href="https://www.sqlite.org/compile.html#enable_rtree">-DSQLITE_ENABLE_RTREE</a>
</li><li> <a href="https://www.sqlite.org/compile.html#enable_fts4">-DSQLITE_ENABLE_FTS4</a>
</li><li> <a href="https://www.sqlite.org/compile.html#enable_fts5">-DSQLITE_ENABLE_FTS5</a>
</li></ul>

</div></div>
  </body>
</html>
