<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.bejarano.io/terraform-stateless/">Original</a>
    <h1>Terraform should have remained stateless</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
<p>So the other day I was looking into <mark>why Terraform needs state</mark>.</p>
<p>It promises to explain why “state is required” and why stateless Terraform “would require shifting massive amounts of complexity from one place to another”.</p>
<p>I’m <mark>not sold on the documents’ reasoning</mark> though, here’s why.</p>
<h3 id="mapping-to-the-real-world-1-of-the-time">Mapping to the real world… 1% of the time</h3>
<p>The first reason Terraform gives in order to justify the use of state is that it <mark>needs a way to map <em>resources in configuration</em> to <em>resources in the provider</em></mark>.</p>
<p>They explain how “Terraform could use tags” but then again “not all providers have tags”. <strong>Therefore, state.</strong></p>
<p><mark>I get the feeling that few other options have been explored</mark> in mapping resources in a stateless manner. For example:</p>
<pre><code>// map on one attribute:
resource &#34;aws_instance&#34; &#34;foo&#34; {
  name = &#34;foo&#34; @id
}

// composite primary key:
resource &#34;aws_instance&#34; &#34;bar&#34; {
  name = &#34;bar&#34; @id
  tags = {
    environment = &#34;production&#34; @id
  }
}

// only an axample, not necessarily my best proposal
</code></pre>
<p>If an instance with the same attribute values <strong>does not exist</strong>, create it.</p>
<p>This, of course, does not apply to all providers and resources. Some don’t have any arbitrary string attribute for Terraform to map with.</p>
<p>But <mark>major provider API resources all have at least one</mark> attribute that meets all the requirements: mainstream AWS stuff, everything in Kubernetes, local provider resources, etc.</p>
<p>Point being, <strong>are we adding state because 1% of the resources couldn’t be mapped otherwise? If I don’t need it, can I skip it?</strong></p>
<h3 id="metadata-is-not-a-hard-requirement">Metadata… is not a hard requirement</h3>
<p>The second reason stated in the document is storing metadata “such as resource dependencies”.
Specifically “when you delete a resource from Terraform configuration, Terraform must know how to delete it”.</p>
<p><strong>But… <code>depends_on</code> already exists.</strong> This allows declaring dependencies between any two resources, whatever the provider.</p>
<p><mark>I’m not sure why “the complexity for this approach quickly explodes”</mark>, according to the document. Feel free to counterexample me.</p>
<h3 id="performance-is-optional">Performance… is optional</h3>
<p>This is <mark>admittedly optional</mark>, according to the document.</p>
<h3 id="syncing-is-not-a-problem">Syncing… is not a problem</h3>
<p><mark>This is a problem <em>caused by</em> state, not a problem <em>solved by</em> state</mark>.</p>

<p>When using Terraform, we have:</p>
<ol>
<li>
<p>Terraform configuration (or, <strong>how we want the universe to be</strong>);</p>
</li>
<li>
<p>Terraform state (or, <strong>how Terraform sees the universe</strong>); and</p>
</li>
<li>
<p>the provider APIs state (or, <strong>how the universe really is</strong>).</p>
</li>
</ol>
<p><mark><strong>We already know <em>what we want</em> and <em>what we have</em>.</strong></mark></p>
<p>Besides, there’s <mark>only so much Terraform can do to keep its picture of the universe up-to-date</mark>. This has tons of implications:</p>
<ul>
<li>
<p>resources <strong>created</strong> out-of-Terraform, have to be imported into state;</p>
</li>
<li>
<p>if <strong>deleted</strong>, plan fails and humans must remove them out of state; and</p>
</li>
<li>
<p>if <strong>modified</strong>, behavior varies by changes, resource and provider! 🤯</p>
</li>
</ul>
<p>Also, if Terraform configuration is refactored, for example, to wrap a bunch of frequently copy-pasted resources into a module, <mark>state must be manually reconciled</mark> before proceeding.</p>
<p><mark><strong>State makes Terraform painful to maintain.</strong></mark></p>
<p>Additionally, requiring state creates a very dumb chicken-and-egg problem, in that you can’t use Terraform to create the state backend that will hold Terraform’s state. This is anecdotal, but ugly nonetheless.</p>

<p><mark>Yes!</mark></p>
<p><a href="https://www.ansible.com/">Ansible</a>, <a href="https://puppet.com/">Puppet</a>, etc. don’t have intermediate stores of the hosts’ configuration, but then again they are used for different things.</p>
<p><a href="https://github.com/octodns/octodns">OctoDNS</a>, on the other hand, is <mark>the perfect example</mark>:</p>
<ul>
<li>
<p>absolutely stateless, just a Git repo and some CI code;</p>
</li>
<li>
<p>you can <code>cron</code> it to ensure “what you have” is “what you want”;</p>
</li>
<li>
<p>you can plan before apply just like Terraform; etc.</p>
</li>
</ul>
<p><mark>I don’t see any reason why Terraform couldn’t work just like OctoDNS.</mark></p>

<p>I’m <strong>leaning towards yes</strong>.</p>
<p>Am I asking for a stateless Terraform rework? <strong>Definitely not.</strong></p>
<p>A more sensible option could be <mark>implementing a “none” state backend</mark> that pulls state right from providers when planning.</p>
<p>I am totally unaware of what the implications of adding such backend would be, which is why <strong>I’ve carefully picked my words</strong> throughout this post, so that my points <mark>don’t come across as facts, but rather as questions</mark> I get from using Terraform.</p>
</div></div>
  </body>
</html>
