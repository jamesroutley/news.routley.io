<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://int10h.org/blog/2021/03/simulating-non-crt-monitors-ffmpeg-flat-panels/">Original</a>
    <h1>Simulating Non-CRT Monitors with FFmpeg: Flat Panel Displays (2021)</h1>
    
    <div id="readability-page-1" class="page"><article>
		
		<div>
			
			

<div>

<p>
  <iframe src="//www.youtube.com/embed/sZdc655YefA?" allowfullscreen="" frameborder="0" title="YouTube Video"></iframe>
</p>
<p><span>Sample video (watch @ 1080p)</span>
</p></div>

<p><span><em>Part of an update series on <a href="https://github.com/viler-int10h/FFmpeg-CRT-transform" target="_blank">FFcrt</a>.  See also:</em></span>
</p><ol>
    <li><a href="https://int10h.org/blog/2021/01/simulating-crt-monitors-ffmpeg-pt-1-color/">CRTs Part 1: Color</a></li>
    <li><a href="https://int10h.org/blog/2021/02/simulating-crt-monitors-ffmpeg-pt-2-monochrome/">CRTs Part 2: Monochrome</a></li>
    <li>Flat-Panel Displays</li>
</ol>
<hr/>

<p>Yes: if emulating CRT monitors the <em>slow</em> way wasn&#39;t your thing, now you can sluggishly simulate various types of old flat-panel displays, too!  All with the same FFmpeg script - which is still named <em>FFcrt</em>, in the grand old tradition of expanding a project&#39;s scope so that its name no longer reflects what it does!  Makes it feel all <em>mature</em> and stuff.</p>

<p>But first, a bit about some other changes that have made it into the <a href="https://github.com/viler-int10h/FFmpeg-CRT-transform" target="_blank">script</a>:</p>

<p><strong>Aspect correction</strong> is now entirely unrelated to input pre-scaling.  Previously, both were taken care of in one nearest-neighbor scaling stage.  If you were going for a pixel aspect of say 5/6, your input scaling factors had to be multiples of that - X*5 and Y*6, or X*10 and Y*12, and so on.  Problem is, as the factors get larger, the &#34;so on&#34; part starts chewing up RAM like candy.</p>

<p>Now there&#39;s just a single <strong>PRESCALE_BY</strong> factor (which controls nearest-neighbor scaling of both X and Y), and a separate <strong>PX_ASPECT</strong> setting which is applied afterwards to X alone, using bilinear filtering.  A little slower, but more flexible and easier on your RAM; also, nothing&#39;s stopping you now from having pixel aspects like <strong>117/125</strong> (PAL Commodore 64), or some other such atrocity.  Rejoice!</p>

<p><strong>Aliasing artifacts</strong> should now be history, after a couple of tweaks to the <em>lenscorrection</em> filter usage.  Curved bezel edges don&#39;t get the jaggies anymore, and scanline-induced moiré patterns are also gone (for any sane resolution, at least).  The boring details mean that the curvature steps will have to stay separate, against my earlier hope of unifying them for the sake of efficiency, but we&#39;ll live with that.</p>

<p>Also, the console output isn&#39;t a huge mess anymore, and there are a couple of other minor changes that do improve efficiency.  But you can look those up in the commit log, so let&#39;s get to the point.</p>

<h3 id="flat-panel-display-options">Flat-Panel Display Options</h3>

<p>There are some fresh new parameters in the sample .cfg presets: additional options for <strong>MONITOR_COLOR</strong>, and a new section for &#34;NON-CRT/<wbr/>flat-panel effects&#34;.  It&#39;s all commented as usual, so you can figure out what&#39;s what, but <strong>FLAT_PANEL</strong> has to be <strong><em>yes</em></strong> for the rest of them to take effect.</p>

<p>This lets FFcrt mimic three major types of flat panels, as common in older portable PCs - monochrome/grayscale LCDs (of various types and forergound/<wbr/>background colors), orange plasma panels, and electroluminescent displays:</p>



<p>As you might expect, the general type is determined by what you set as the <strong>MONITOR_COLOR</strong>, which now accepts these values in addition to the old ones:</p>

<ul>
<li><p><strong>PLASMA</strong>: emulates the type of orange flat panels using neon plasma cells, as seen in portables like the later Toshiba T-series (T3100, T3200, T5100...), the Compaq Portable III and 386, and the IBM PS/2 models P70/<wbr/>P75.  The original plasma displays dating back to PLATO terminals were 1-bit, but by the time they started cropping up in portables, they generally sported multiple shades (brightness levels) of orange.</p></li>

<li><p><strong>ELD</strong>: electroluminescent displays (as opposed to LCD displays that simply used electroluminescent backlighting).  These uses phosphors for light emission, but unlike CRTs the phosphor resides in a thin layer between two electrodes in a matrix, and its electrons are directly manipulated by high-voltage AC power.  Most commonly yellow (AKA &#34;golden&#34;) and strictly 1-bit; seen e.g. in some GRiD Compass and GRiDCASE models, later Data General/One laptops, and a few other portables.</p></li>

<li><p><strong>LCD</strong>: cheaper and much more common, at the cost of contrast, viewing angle and pixel response time (latency).  This option aims to reproduce the baseline variety, a twisted-nematic (later Supertwist) monochrome LCD with a bluish-gray foreground color, a pale green background and no backlight.</p></li>

<li><p><strong>LCD-LITE</strong>: similar to the above, but with a brighter green backround for extra range and contrast.  Can be used to simulate backlit versions of the more common monochrome LCD panels.</p></li>

<li><p><strong>LCD-LWHITE</strong>: this one simulates later monochrome LCD panels with a grayish foreground and a white backlight, typically with better contrast; very common in later laptops before color LCD panels started becoming a thing.</p></li>

<li><p><strong>LCD-LBLUE</strong>: less commonly, some backlit LCD panels had a vivid blue tint to their activated pixels.  As seen in the final revision of the IBM PC Convertible (5140), but also the Compaq LTE and LTE/286, the NEC Ultralite, and probably a few others.</p></li>
</ul>

<p><a href="https://archive.org/details/PC-Mag-1987-07-01/page/n239/mode/2up" target="_blank"><img src="https://int10h.org/blog/img/ffmpeg-crt/pcmag87-laptops.jpg#floatleft" alt="PC Magazine Laptop Screen Comparison"/></a></p>

<p>That doesn&#39;t really cover everything: early flat panels (especially LCDs) came in a big and confusing bunch of colors and lighting technologies, as you can see in the adjoining PC Magazine comparison.  To vary the contrast range (and sometimes the hue, a little bit) you can play with the <strong>BRIGHTEN</strong> and <strong>BLACKPOINT</strong> configuration parameters.</p>

<p>Sizes and aspect ratios were similarly all over the place, and that&#39;s where you can play with <strong>PX_ASPECT</strong> (the pixel aspect ratio) and <strong>OASPECT</strong> (the output, AKA display aspect ratio) to achieve just about any of them.  The emulated <em>storage</em> aspect ratio (SAR) is already determined by the resolution of the input.</p>

<p>Given the nature of these early LCDs, &#34;on&#34; pixels were dark and &#34;off&#34; pixels allowed light through, so the image was typically the inverse of what a CRT, plasma or ELD display would show.  A lot of laptop LCDs did let you flip the signal and get light-on-dark instead, so FFcrt lets you do both, with the <strong>INVERT_INPUT</strong> parameter.  Of course, these things wouldn&#39;t be the same without pixel response times that bordered on the criminal, and that&#39;s what the <strong>LATENCY</strong> option is for.</p>

<p>There&#39;s just one more thing to tackle: as mentioned, some of these flat-panel displays were strictly 1-bit - pixels were either on or off, without such decadent luxuries as true greyscale shading.  That goes for ELDs (probably all of them) and a lot of early LCD panels.  But as simulated in the images/video above, many of them could still <em>fake</em> it well enough, and I&#39;ve added an quick-n&#39;-dirty extra tool for that.</p>

<h3 id="simulated-grayscale-shading-on-1-bit-monochrome-displays">Simulated Grayscale &#34;Shading&#34; on 1-Bit Monochrome Displays</h3>

<p><strong>Sim-rgbi1bpp</strong> (yet another batch file in the <a href="https://github.com/viler-int10h/FFmpeg-CRT-transform" target="_blank">FFcrt repository</a>)
<em>approximates</em> the methods used by certain display controllers to show RGBI video (AKA the 16 IBM PC colors) on true monochrome displays.  It&#39;s intended to process your input <em>before</em> you feed it to FFcrt; use it only if you really want to simulate such a setup - for true grayscale, this is not needed.</p>

<p>These hardware solutions typically replaced each RGBI color with a modulated dot-pattern, either static (&#34;bit-dithered&#34;) or dynamic (cycling across frames, a sort of refresh rate-limited PWM).  Obviously, this is very different from what you get with dither algorithms intended for image processing, so this script twists FFmpeg&#39;s arm a little bit and uses brute-force (read: slow) color replacement to implement this.</p>

<p>Such trickery often relied on the fact that the target display had (at least) twice the resolution of the video mode in question, so 200-scanline modes were doubled to 400.  If required, sim-rgbi1bpp will likewise upscale the input before it applies the effect.</p>

<p>You can see the readme for usage directions, but while we&#39;re here, it might be helpful to show some examples.  First we have the static methods, which can be used for still images as well as video:</p>

<figure>
    <img src="https://int10h.org/blog/img/ffmpeg-crt/1bitmethod-original.png#pixels" alt="Original RGBI image"/>
    <figcaption>Original RGBI image</figcaption>
</figure>



<p>&#34;4x1a&#34; is the simplest method, which basically interprets CGA mode 4 as if it were mode 6 (640x200 mono); this is similar to running SIMCGA on a Hercules Graphics Card, and I believe this is what the IBM 5140 does.  The HP 100/200LX palmtops use similar methods: &#34;4x1a&#34; also corresponds to HP&#39;s shading mode 00b (bit-dithered), and &#34;4x1b&#34; to shading mode 11b.  The other methods above are basically made up, but the principle is similar.</p>

<p>The &#39;t&#39; methods add a <strong>temporal</strong> component, by modulating the bit-patterns on successive frames.  That means they&#39;re video-only, and won&#39;t work with still images:</p>



<p>Of course, these methods introduces massive flicker; but in the real world, this approach was mostly used on monochrome LCD panels, with enough pixel latency to make it less of a problem.  For instance, <em>frame-based</em> shading mode 11b on the HP 100/200LX is pretty much the same as &#34;t4x1&#34;.  When feeding the results to FFcrt, use the LATENCY parameter to mimic that - this is what I did in the video.</p>

<p>As a counter-example, the GRiDCASE 1537&#39;s electroluminescent display had no such mitigating factors (<a href="https://www.youtube.com/watch?v=jSnIVRvwFo0?t=84" target="_blank">video sample</a>) -
the flicker there actually looks much worse than any of the above methods, but that might just be a frame-rate mismatch in that particular video.</p>

<p>Anyway, none of these methods duplicate the <em>exact</em> implementation used by a specific type of video hardware, just the general principle.  The HP 100/200LX is the only machine for which I was able to find precise implementation details.  If you have the technical documentation on any other real-world examples, let me know.</p>



		</div>
		

	</article></div>
  </body>
</html>
