<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://quuxplusone.github.io/blog/2024/03/03/infinite-craft-theory/">Original</a>
    <h1>The algebraic structure of Infinite Craft</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p>Last month I <a href="https://quuxplusone.github.io/blog/2024/02/08/infinite-craft/">wrote</a> about Neal Agarwal’s web game <a href="https://neal.fun/infinite-craft/"><em>Infinite Craft</em></a>.
Tom Fang wrote to tell me he’s created <a href="https://szdytom.github.io/infinite-craft-dictionary/">a dictionary</a>
of <em>Infinite Craft</em> elements, along with their uses and recipes. This got me thinking about the
game’s mathematical structure.</p>

<p>By “mathematical structure,” I mean something like how we make recipes and the metrics by which we
might compare one recipe to another. For example, if our goal is to make Sandwich, we could do it like this:</p>

<div><div><pre><code>Wave = Water + Wind
Steam = Fire + Water
Plant = Earth + Water
Sand = Earth + Wave
Tea = Plant + Steam
Sandwich = Sand + Tea
</code></pre></div></div>

<p>Or like this:</p>

<div><div><pre><code>Wave = Water + Wind
Sand = Earth + Wave
Glass = Fire + Sand
Wine = Glass + Water
Sandwich = Sand + Wine
</code></pre></div></div>

<p>If we diagram these recipes, we find that the first one is <em>shallower</em>, in the sense that we combine only the
primitive elements, elements made <em>from</em> the primitives (Wave, Steam, Plant), and elements made from <em>those</em>
elements (Sand, Tea). But the second one is <em>terser</em>, in the sense that it is five lines long instead of six.</p>

<p>At first glance, the world of <em>Infinite Craft</em> forms a <a href="https://en.wikipedia.org/wiki/Hypergraph">directed hypergraph</a>
with a lot of structure: each directed hyperedge connects a set of one or two vertices to a set of exactly one vertex.
But a recipe isn’t merely a “path” on that hypergraph!
Mathematicians define the hypergraph analogue of a “path” as a set of incident hyperedges — “incidence”
meaning that the edges share <em>at least one</em> vertex. In this sense there is a “path” from the starting elements
to Sandwich that consists of only a single hyperedge; namely,</p>

<div><div><pre><code>Sandwich = Wind + Grilled Cheese
</code></pre></div></div>

<p>That definition of “path” doesn’t help us.</p>

<p><a href="https://mathoverflow.net/questions/466176/what-is-the-proper-name-for-this-tersest-path-problem-in-infinite-craft">I asked MathOverflow</a>,
and they pointed me to another example of the same problem: <a href="https://en.wikipedia.org/wiki/Addition_chain">addition chains</a>.
An “addition chain” for an integer \(n\) is a sequence starting with 1 and ending with \(n\), such that each
element in the sequence is the sum of exactly two previous elements. For example,
we might make 31 in any of these three ways:</p>

<div><div><pre><code>2 = 1 + 1              2 = 1 + 1              2 = 1 + 1
3 = 1 + 2              3 = 1 + 2              3 = 1 + 2
6 = 3 + 3              4 = 2 + 2              6 = 3 + 3
7 = 1 + 6              8 = 4 + 4              12 = 6 + 6
14 = 7 + 7             12 = 8 + 4             14 = 2 + 12
15 = 1 + 14            16 = 8 + 8             17 = 3 + 14
30 = 15 + 15           28 = 12 + 16           31 = 14 + 17
31 = 1 + 30            31 = 3 + 28
</code></pre></div></div>

<p>The middle chain is <em>shallowest</em>, but the right-hand one is <em>tersest</em>.</p>

<p>Addition chains are idiomatically written as just an increasing sequence of integers: (1 2 3 6 12 14 17 31).
We don’t need to specify how each integer (say, 17) is constructed from the preceding elements, because it’s
obvious. We could represent <em>Infinite Craft</em> recipes just as concisely — (Wave Sand Glass Wine Sandwich) — but
that wouldn’t be very reader-friendly because it’s not obvious <em>which</em> two preceding elements combine to make,
say, Wine.</p>

<hr/>

<p>Finding the tersest addition chain is directly relevant to the world of computer programming.
Suppose we want to calculate the 31st power of an unknown number in register <code>A</code>,
using only multiplication. Then we can do any of:</p>

<div><div><pre><code>mul A, A, B  # A^2     mul A, A, B  # A^2     mul A, A, B  # A^2
mul A, B, C  # A^3     mul A, B, C  # A^3     mul A, B, C  # A^3
mul C, C, D  # A^6     mul B, B, D  # A^4     mul C, C, D  # A^6
mul A, C, E  # A^7     mul D, D, E  # A^8     mul D, D, E  # A^12
mul E, E, F  # A^14    mul D, E, F  # A^12    mul B, E, F  # A^14
mul A, F, G  # A^15    mul E, E, G  # A^16    mul C, F, G  # A^17
mul G, G, H  # A^30    mul F, G, H  # A^28    mul F, G, R  # A^31
mul A, H, R  # A^31    mul C, H, R  # A^31
</code></pre></div></div>

<p>Our “shallowness” metric translates into a measure of the <a href="https://en.wikipedia.org/wiki/Data_dependency">data dependencies</a>
involved in these computations. The middle program, being the shallowest,
is also the <em>fastest</em> on any machine with at least two multiplier units.</p>

<p>Another practically relevant metric for the “goodness” of a chain is its <em>width</em>: the number of
registers it uses in its most optimal <a href="https://en.wikipedia.org/wiki/Register_allocation#Graph-coloring_allocation">coloring</a>.
The left-hand recipe above is the <em>narrowest</em>, with width 2, whereas the others have width 3:</p>

<div><div><pre><code>mul A, A, B  # A^2     mul A, A, B  # A^2     mul A, A, B  # A^2
mul A, B, B  # A^3     mul A, B, A  # A^3     mul A, B, A  # A^3
mul B, B, B  # A^6     mul B, B, C  # A^4     mul A, A, C  # A^6
mul A, B, B  # A^7     mul C, C, B  # A^8     mul C, C, C  # A^12
mul B, B, B  # A^14    mul C, B, C  # A^12    mul B, C, C  # A^14
mul A, B, B  # A^15    mul B, B, B  # A^16    mul A, C, A  # A^17
mul B, B, B  # A^30    mul C, B, B  # A^28    mul C, A, R  # A^31
mul A, B, R  # A^31    mul A, B, R  # A^31
</code></pre></div></div>

<p>The left-hand recipe corresponds to <a href="https://en.wikipedia.org/wiki/Ancient_Egyptian_multiplication">Russian peasant multiplication</a>,
which always generates an addition chain of width 2. For in-depth coverage of various algorithms to generate
addition chains, see <a href="https://amzn.to/49zv6Gs">Knuth Volume 2</a> §4.6.3 “Evaluation of Powers.”</p>

<hr/>

<p>Surprisingly, the “tersest chain” problem is non-trivial in both <em>Infinite Craft</em> and addition-chains.
Knuth writes:</p>

<blockquote>
  <p>Several authors have published statements (without proof) that the binary method
[that is, Russian peasant multiplication] actually gives the minimum possible number of
multiplications. But that is not true. The smallest counterexample is \(n = 15\),
when the binary method needs six multiplications, yet we can calculate \(y = x^3\)
in two multiplications and \(x^{15} = y^5\) in three more, achieving the desired result
with only five multiplications.</p>
</blockquote>

<p>This suggests the algorithm Knuth calls the “factor method”; but yet again, you can find numbers
whose optimal chain eludes both the binary method and the factor method! It appears that there
is no fast (non-exponential-time) algorithm that generates an optimal addition chain for <em>every</em> input.</p>

<p>To get an intuitive sense of the difficulty — in particular, why no greedy algorithm helps —
look again at our tersest route to Sandwich:</p>

<div><div><pre><code>Wave = Water + Wind
Sand = Earth + Wave
Glass = Fire + Sand
Wine = Glass + Water
Sandwich = Sand + Wine
</code></pre></div></div>

<p>This route to Sandwich passes through Wine on the fourth step.
Now, the tersest route to Wine itself is only three steps:</p>

<div><div><pre><code>Plant = Earth + Water
Dandelion = Plant + Wind
Wine = Dandelion + Water
</code></pre></div></div>

<p>But if you make Wine by that route, you’ll never reach Sandwich in the optimum number of steps!</p>

<p>Similarly, our tersest route to 31 was (1 2 3 6 12 14 17 31), passing through 17 on the sixth step.
There are two routes that make 17 in only five steps:</p>

<div><div><pre><code>(1 2 4 8 9 17)
(1 2 4 8 16 17)
</code></pre></div></div>

<p>But if you make 17 by either of these routes, you’ll never reach 31 in the optimum number of steps!</p>

<blockquote>
  <p>Neill Clift of <a href="http://additionchains.com/">AdditionChains.com</a> produced this example for me —
my utmost thanks to him! According to Neill, there are exactly five optimal chains for 31 that
contain the number 17: none of those chains contain (1 2 4 8). Meanwhile there are seventy-two
other optimal chains for 31 that don’t contain 17 at all.</p>
</blockquote>

<hr/>

<p>Still, knowing that <em>Infinite Craft</em> and addition chains are two examples of the same hypergraph
structure doesn’t tell me whether there’s an accepted name <em>for</em> this particular hypergraph structure.
If you have any leads, please pop over to <a href="https://mathoverflow.net/questions/466176/what-is-the-proper-name-for-this-tersest-path-problem-in-infinite-craft">MathOverflow</a>
and/or send me an email!</p>

<p>Observe that the addition-chain structure is commutative <em>and associative</em>, whereas
the <em>Infinite Craft</em> structure is commutative but non-associative:</p>

<div><div><pre><code>Plant = Water + Earth
Lava = Earth + Fire
Smoke = (Water + Earth) + Fire
Stone = Water + (Earth + Fire)
</code></pre></div></div>

<p>This makes much of Knuth’s discussion (particularly “Graphical representation” and the
generation of equivalent <em>dual</em> addition chains) inapplicable to <em>Infinite Craft</em>.</p>

<hr/>

<p>To explore the <em>Infinite Craft</em> hypergraph offline — without stressing Neal’s backend or needing
to evade his Cloudflare bot-detection filter — you can download a compressed database containing
about 30,000 elements from Tom Fang’s GitHub, <a href="https://github.com/szdytom/infinite-craft-dictionary/">szdytom/infinite-craft-dictionary</a>.
Computing the tersest recipe for each element, and inventing a compact way to represent such a
recipe in the database, is left as an exercise for the reader!</p>

  </div></div>
  </body>
</html>
