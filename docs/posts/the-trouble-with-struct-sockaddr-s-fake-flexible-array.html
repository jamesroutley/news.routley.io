<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/Articles/997094/">Original</a>
    <h1>The trouble with struct sockaddr&#39;s fake flexible array</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>
Flexible arrays — arrays that are declared as the final member of a
structure and which have a size determined at run time — have long drawn
the attention of developers seeking to harden the kernel against
buffer-overflow vulnerabilities.  These arrays have reliably been a source
of bugs, so anything that can be done to ensure that operations on them
stay within bounds is a welcome improvement.  While many improvements,
including the recent <a href="https://lwn.net/Articles/936728/">counted-by work</a>, have
been made, one of the most difficult cases remains.  Now, however,
developers who are interested in using recent compiler bounds-checking
features are trying to get a handle on </p><tt>struct sockaddr</tt><p>.
</p><h4>The many faces of <tt>struct sockaddr</tt></h4>
<p>
The <tt>sockaddr</tt> structure dates back to the beginning of the BSD
socket API; it is used to hold an address corresponding to one side of a
network connection.  The <a href="https://digitalassets.lib.berkeley.edu/techreports/ucb/text/CSD-83-146.pdf">4.2
BSD networking implementation notes</a> from 1983 give its format as:
</p><pre>    struct sockaddr {
        short sa_family;
	char sa_data[14];
    };
</pre>
<p>
The <tt>sa_family</tt> field describes which address family is in use —
<tt>AF_INET</tt> for an IPv4 address, for example.  <tt>sa_data</tt> holds
the actual address, the format of which will vary depending on the family.
The implementation notes say that: &#34;<q>the size of the data field,
14 bytes, was selected based on a study of current address
formats</q>&#34;.  In other words, 14 bytes — much longer than the four
needed for an IPv4 address — should really be enough for anybody.
<!-- middle-ad -->
</p><p>
Need it be said that 14 bytes turned out not to be enough?  As new
protocols came along, they brought address formats that were longer than
would fit in <tt>sa_data</tt>.  But the <tt>sockaddr</tt> structure was
firmly set in stone as user-space API and could not be changed.  It appears
in essentially the same form in any modern Unix-like system; on Linux the
type of <tt>sa_family</tt> is now <tt>sa_family_t</tt>, but otherwise the
structure is the same.
</p><p>
The result was one of the (many) historic kludges of the Unix API.  New
protocol implementations typically brought with them a variant of
<tt>struct sockaddr</tt> that was suitably sized for the addresses in use;
<tt>struct sockaddr_in6</tt> for IPv6 addresses, for example, or <tt>struct
sockaddr_ax25</tt> for AX.25.  All of the socket API interfaces still
specified <tt>struct sockaddr</tt>, but implementations on both sides would
use the appropriate structure for the protocol in use.  Code on both sides
of the API would cast pointers to and from <tt>struct sockaddr</tt> as
needed.
</p><p>
Even now, the documented APIs for system calls like <a href="https://man7.org/linux/man-pages/man2/connect.2.html"><tt>connect()</tt></a>
and library functions like <a href="https://man7.org/linux/man-pages/man3/getaddrinfo.3.html"><tt>getaddrinfo()</tt></a>
use <tt>struct sockaddr</tt>.  As a result, both user-space programs and
the kernel contain a whole set of casts between that type and the type they
are (hopefully) actually using.  Needless to say, these casts can be error
prone; casting a pointer between different structure types is also deemed
to be undefined behavior in current C.  But that&#39;s the price we pay
for API compatibility.
</p><p>
The advent of IPv6 also brought another type: <tt>struct
sockaddr_storage</tt>; it is defined as starting with the same
<tt>sa_family</tt> field, but being large enough to hold any of the other
<tt>sockaddr</tt> variants.  Code dealing with network addresses can
allocate a structure of this type and be sure of having enough space to
store any address.  This structure is now what is often allocated, but it
never appears explicitly in the system-call interface.
</p><h4>Making the flexible array explicit</h4>
<p>
The C language has accumulated a few idioms for the declaration of flexible
arrays over the years; specifying a dimension of zero or one are both
common (though deprecated) examples.  The syntax blessed by the language
standard, though, is to omit the dimension entirely:
</p><pre>    struct something {
        /* ... */
	int flex_member[]; /* A flexible array */
    };
</pre>
<p>
This syntax makes it clear that a flexible array is in use and that the
type declaration cannot be used, on its own, to check for overflows of that
array.  In no convention is it deemed reasonable to use a dimension
of 14 for a flexible array, but that is exactly what now happens with
<tt>struct sockaddr</tt>.  The actual length of <tt>sa_data</tt> is not
known, and has a good chance of being larger than the declared size.
It is a flexible array disguised as an ordinary array.
</p><p>
That usage complicates checking of <tt>struct sockaddr</tt> usage for
overflows, but the effects go beyond that; it makes detection of flexible
arrays harder across the kernel.  As Kees Cook noted in <a href="https://lwn.net/ml/all/20221018095503.never.671-kees@kernel.org/">this 2022
patch</a>:
</p><blockquote>
	One of the worst offenders of &#34;fake flexible arrays&#34; is struct
	sockaddr, as it is the classic example of why GCC and Clang have
	been traditionally forced to treat all trailing arrays as fake
	flexible arrays: in the distant misty past, sa_data became too
	small, and code started just treating it as a flexible array, even
	though it was fixed-size.
</blockquote>
<p>
As long as this usage remains, the checking tools built into both compilers
must treat <i>any</i> trailing array in a structure as if it were flexible;
that can disable overflow checking on that array entirely.
</p><p>
It would be nice to change this usage but, as was noted above, the layout
of <tt>struct sockaddr</tt> is wired deeply into the socket interface and
cannot be changed without breaking applications.  But that doesn&#39;t mean
that the kernel must treat <tt>sa_data</tt> as anything but a flexible
array.  To enable that without changing the binary interface, Cook
redefined <tt>struct sockaddr</tt> within the kernel to:
</p><pre>    struct sockaddr {
        sa_family_t	sa_family;
	union {
	    char sa_data_min[14];
	    DECLARE_FLEX_ARRAY(char, sa_data);
	};
    };
</pre>
<p>
(The <a href="https://elixir.bootlin.com/linux/v6.11.6/source/include/linux/stddef.h#L83"><tt>DECLARE_FLEX_ARRAY()</tt>
macro</a> jumps through some hoops needed to declare a flexible array
within a union).  This change made it clear that <tt>sa_data</tt> is a
flexible array, which helped, in turn, in the goal of allowing the
compilers to treat trailing arrays as non-flexible unless they are
explicitly declared as such.
</p><p>
This patch was merged for the 6.2 release, and all seemed to be well.  But,
as Gustavo A. R. Silva pointed out in <a href="https://lwn.net/ml/all/cover.1729802213.git.gustavoars@kernel.org">this patch
series</a>, there is a problem with this approach.  There are many places
in the kernel where <tt>struct sockaddr</tt> is embedded within another
structure, usually not at the end.  That has the result of placing a
flexible array in the middle of the embedding structure, which is
problematic for fairly obvious reasons; the compiler no longer knows what
the offsets to the members after <tt>struct sockaddr</tt> should be.  That
has resulted in &#34;<q>thousands of warnings</q>&#34; when the suitable check is
enabled in the compiler.
</p><p>
Silva&#39;s solution was to introduce yet another variant with a familiar form:
</p><pre>    struct sockaddr_legacy {
        sa_family_t	sa_family;
	char		sa_data[14];
    };
</pre>
<p>
This structure, which lacks the flexible-array member, was then embedded in
the other structures, making the warning go away.  Since the embedding
cases did not use <tt>sa_data</tt> as a flexible array (otherwise things
would never have worked in the first place), this change was deemed safe to
make.
</p><p>
Networking maintainer Jakub Kicinski <a href="https://lwn.net/ml/all/20241031180145.01e14e38@kernel.org/">was not convinced</a>
about this change, though.  He suggested that perhaps Cook&#39;s patch should
be reverted instead, and a new type should be added for places where a
flexible array is actually needed.  Cook <a href="https://lwn.net/ml/all/202411031920.BEF6CEBCD@keescook/">acknowledged</a> this
suggestion as &#34;<q>a pretty reasonable position</q>&#34; and started to ponder
on alternatives.  He concluded: &#34;<q>Now, if we want to get to a place with
the least ambiguity, we need to abolish sockaddr from the kernel
internally, and I think that might take a while.</q>&#34;
</p><h4>Leaving <tt>struct sockaddr</tt> behind</h4>
<p>
In early November, Cook returned with <a href="https://lwn.net/ml/all/20241104221450.work.053-kees@kernel.org">a brief patch
series</a> meant to show what that approach would look like.  It begins by
reverting the 2022 patch, returning <tt>struct sockaddr</tt> to its
original non-flexible form.  There is <a href="https://lwn.net/ml/all/20241104222513.3469025-2-kees@kernel.org">a patch</a> adding
comments to places in the networking code that are known to use this
structure within its original bounds; they do not need to be changed, and
do not need <tt>sa_data</tt> to be flexible.  But that still leaves many uses of
<tt>struct sockaddr</tt> where the data area may, in reality, be larger
than 14 bytes.
</p><p>
The solution for many of those places is just to use <tt>struct
sockaddr_storage</tt> instead.  Indeed, parts of the network stack already
use that structure, but then cast pointers to <tt>struct sockaddr</tt> for
functions that expect that type.  One example is <a href="https://elixir.bootlin.com/linux/v6.11.6/source/net/core/utils.c#L402"><tt>inet_addr_is_any()</tt></a>,
which takes a <tt>struct sockaddr *</tt> argument, but is only called by
functions using <tt>struct sockaddr_storage</tt>.  In this case, <a href="https://lwn.net/ml/all/20241104222513.3469025-4-kees@kernel.org">the solution</a> is
to change the prototype of the function to match what is really being
passed to it and remove the casts from the callers.
</p><p>
Some changes will require more churn, even if they are conceptually simple.
The <tt>getname()</tt> callback (in the <a href="https://elixir.bootlin.com/linux/v6.11.6/source/include/linux/net.h#L162"><tt>proto_ops</tt>
structure</a>) has long expected a pointer to a <tt>sockaddr_storage</tt>
structure, but its prototype was never changed to match.  The <a href="https://lwn.net/ml/all/20241104222513.3469025-5-kees@kernel.org">patch</a>
eliminating the use of <tt>struct sockaddr</tt> for <tt>getname()</tt>
mostly consists of name changes and cast removal, but it touches
66 files.  It also, as Cook noted in the cover letter, is still lying to
the compiler in cases where the backing structure is actually smaller than
<tt>struct sockaddr_storage</tt>, &#34;<q>these remain just as safe as they
used to be. :)</q>&#34;
</p><p>
This series shows that truly eliminating the use of this structure&#39;s
<tt>sa_data</tt> field as a flexible array in disguise will involve a fair
amount of work and code churn.  Even so, Kicinski <a href="https://lwn.net/ml/all/20241105171607.48c0c24d@kernel.org">commented</a> that it
&#34;<q>feels like the right direction</q>&#34;.  So, while <tt>struct
sockaddr</tt> will likely remain part of the kernel&#39;s system-call API
forever, its use within the kernel can be expected to fade away over time.
A design miscalculation made over 40 years ago may finally stop
impeding the use of modern memory-safety tools.<br clear="all"/></p><table>
           <tbody><tr><th colspan="2">Index entries for this article</th></tr>
           <tr><td><a href="https://lwn.net/Kernel/Index">Kernel</a></td><td><a href="https://lwn.net/Kernel/Index#Flexible_arrays">Flexible arrays</a></td></tr>
            </tbody></table></div></div>
  </body>
</html>
