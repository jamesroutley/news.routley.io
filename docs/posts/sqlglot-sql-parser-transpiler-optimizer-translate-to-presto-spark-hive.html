<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/tobymao/sqlglot">Original</a>
    <h1>SQLGlot: SQL parser, transpiler, optimizer â€“ translate to Presto, Spark, Hive</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto">SQLGlot is a no dependency Python SQL parser, transpiler, and optimizer. It can be used to format SQL or translate between different dialects like Presto, Spark, and Hive. It aims to read a wide variety of SQL inputs and output syntatically correct SQL in the targeted dialects.</p>
<p dir="auto">It is currently the <a href="#benchmarks">fastest</a> pure-Python SQL parser.</p>
<p dir="auto">You can easily customize the parser to support UDF&#39;s across dialects as well through the transform API.</p>
<p dir="auto">Syntax errors are highlighted and dialect incompatibilities can warn or raise depending on configurations.</p>
<h2 dir="auto"><a id="user-content-install" aria-hidden="true" href="#install"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Install</h2>
<p dir="auto">From PyPI</p>

<p dir="auto">Or with a local checkout</p>

<h2 dir="auto"><a id="user-content-examples" aria-hidden="true" href="#examples"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Examples</h2>
<p dir="auto">Easily translate from one dialect to another. For example, date/time functions vary from dialects and can be hard to deal with.</p>
<div data-snippet-clipboard-copy-content="import sqlglot
sqlglot.transpile(&#34;SELECT EPOCH_MS(1618088028295)&#34;, read=&#39;duckdb&#39;, write=&#39;hive&#39;)"><pre><span>import</span> <span>sqlglot</span>
<span>sqlglot</span>.<span>transpile</span>(<span>&#34;SELECT EPOCH_MS(1618088028295)&#34;</span>, <span>read</span><span>=</span><span>&#39;duckdb&#39;</span>, <span>write</span><span>=</span><span>&#39;hive&#39;</span>)</pre></div>
<div data-snippet-clipboard-copy-content="SELECT TO_UTC_TIMESTAMP(FROM_UNIXTIME(1618088028295 / 1000, &#39;yyyy-MM-dd HH:mm:ss&#39;), &#39;UTC&#39;)"><pre><span>SELECT</span> TO_UTC_TIMESTAMP(FROM_UNIXTIME(<span>1618088028295</span> <span>/</span> <span>1000</span>, <span><span>&#39;</span>yyyy-MM-dd HH:mm:ss<span>&#39;</span></span>), <span><span>&#39;</span>UTC<span>&#39;</span></span>)</pre></div>
<p dir="auto">SQLGlot can even translate custom time formats.</p>
<div data-snippet-clipboard-copy-content="import sqlglot
sqlglot.transpile(&#34;SELECT STRFTIME(x, &#39;%y-%-m-%S&#39;)&#34;, read=&#39;duckdb&#39;, write=&#39;hive&#39;)"><pre><span>import</span> <span>sqlglot</span>
<span>sqlglot</span>.<span>transpile</span>(<span>&#34;SELECT STRFTIME(x, &#39;%y-%-m-%S&#39;)&#34;</span>, <span>read</span><span>=</span><span>&#39;duckdb&#39;</span>, <span>write</span><span>=</span><span>&#39;hive&#39;</span>)</pre></div>
<div data-snippet-clipboard-copy-content="SELECT DATE_FORMAT(x, &#39;yy-M-ss&#39;)&#34;"><pre><span>SELECT</span> DATE_FORMAT(x, <span><span>&#39;</span>yy-M-ss<span>&#39;</span></span>)<span><span>&#34;</span></span></pre></div>
<h3 dir="auto"><a id="user-content-formatting-and-transpiling" aria-hidden="true" href="#formatting-and-transpiling"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Formatting and Transpiling</h3>
<p dir="auto">Read in a SQL statement with a CTE and CASTING to a REAL and then transpiling to Spark.</p>
<p dir="auto">Spark uses backticks as identifiers and the REAL type is transpiled to FLOAT.</p>
<div data-snippet-clipboard-copy-content="import sqlglot

sql = &#34;&#34;&#34;WITH baz AS (SELECT a, c FROM foo WHERE a = 1) SELECT f.a, b.b, baz.c, CAST(&#34;b&#34;.&#34;a&#34; AS REAL) d FROM foo f JOIN bar b ON f.a = b.a LEFT JOIN baz ON f.a = baz.a&#34;&#34;&#34;
sqlglot.transpile(sql, write=&#39;spark&#39;, identify=True, pretty=True)[0]"><pre><span>import</span> <span>sqlglot</span>

<span>sql</span> <span>=</span> <span>&#34;&#34;&#34;WITH baz AS (SELECT a, c FROM foo WHERE a = 1) SELECT f.a, b.b, baz.c, CAST(&#34;b&#34;.&#34;a&#34; AS REAL) d FROM foo f JOIN bar b ON f.a = b.a LEFT JOIN baz ON f.a = baz.a&#34;&#34;&#34;</span>
<span>sqlglot</span>.<span>transpile</span>(<span>sql</span>, <span>write</span><span>=</span><span>&#39;spark&#39;</span>, <span>identify</span><span>=</span><span>True</span>, <span>pretty</span><span>=</span><span>True</span>)[<span>0</span>]</pre></div>
<div data-snippet-clipboard-copy-content="WITH `baz` AS (
  SELECT
    `a`,
    `c`
  FROM `foo`
  WHERE
    `a` = 1
)
SELECT
  `f`.`a`,
  `b`.`b`,
  `baz`.`c`,
  CAST(`b`.`a` AS FLOAT) AS `d`
FROM `foo` AS `f`
JOIN `bar` AS `b`
  ON `f`.`a` = `b`.`a`
LEFT JOIN `baz`
  ON `f`.`a` = `baz`.`a`"><pre>WITH <span><span>`</span>baz<span>`</span></span> <span>AS</span> (
  <span>SELECT</span>
    <span><span>`</span>a<span>`</span></span>,
    <span><span>`</span>c<span>`</span></span>
  <span>FROM</span> <span><span>`</span>foo<span>`</span></span>
  <span>WHERE</span>
    <span><span>`</span>a<span>`</span></span> <span>=</span> <span>1</span>
)
<span>SELECT</span>
  <span><span>`</span>f<span>`</span></span>.<span><span>`</span>a<span>`</span></span>,
  <span><span>`</span>b<span>`</span></span>.<span><span>`</span>b<span>`</span></span>,
  <span><span>`</span>baz<span>`</span></span>.<span><span>`</span>c<span>`</span></span>,
  CAST(<span><span>`</span>b<span>`</span></span>.<span><span>`</span>a<span>`</span></span> <span>AS</span> FLOAT) <span>AS</span> <span><span>`</span>d<span>`</span></span>
<span>FROM</span> <span><span>`</span>foo<span>`</span></span> <span>AS</span> <span><span>`</span>f<span>`</span></span>
<span>JOIN</span> <span><span>`</span>bar<span>`</span></span> <span>AS</span> <span><span>`</span>b<span>`</span></span>
  <span>ON</span> <span><span>`</span>f<span>`</span></span>.<span><span>`</span>a<span>`</span></span> <span>=</span> <span><span>`</span>b<span>`</span></span>.<span><span>`</span>a<span>`</span></span>
<span>LEFT JOIN</span> <span><span>`</span>baz<span>`</span></span>
  <span>ON</span> <span><span>`</span>f<span>`</span></span>.<span><span>`</span>a<span>`</span></span> <span>=</span> <span><span>`</span>baz<span>`</span></span>.<span><span>`</span>a<span>`</span></span></pre></div>
<h3 dir="auto"><a id="user-content-metadata" aria-hidden="true" href="#metadata"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Metadata</h3>
<p dir="auto">You can explore SQL with expression helpers to do things like find columns and tables.</p>
<div data-snippet-clipboard-copy-content="from sqlglot import parse_one, exp

for column in parse_one(&#34;SELECT a, b + 1 AS c FROM d&#34;).find_all(exp.Column):
  print(column.alias_or_name)"><pre><span>from</span> <span>sqlglot</span> <span>import</span> <span>parse_one</span>, <span>exp</span>

<span>for</span> <span>column</span> <span>in</span> <span>parse_one</span>(<span>&#34;SELECT a, b + 1 AS c FROM d&#34;</span>).<span>find_all</span>(<span>exp</span>.<span>Column</span>):
  <span>print</span>(<span>column</span>.<span>alias_or_name</span>)</pre></div>
<h3 dir="auto"><a id="user-content-customization" aria-hidden="true" href="#customization"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Customization</h3>
<h4 dir="auto"><a id="user-content-custom-types" aria-hidden="true" href="#custom-types"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Custom Types</h4>
<p dir="auto">A simple transform on types can be accomplished by providing a corresponding mapping:</p>
<div data-snippet-clipboard-copy-content="
from sqlglot import *

transpile(&#34;SELECT CAST(a AS INT) FROM x&#34;, type_mapping={exp.DataType.Type.INT: &#34;SPECIAL INT&#34;})[0]"><pre><span>from</span> <span>sqlglot</span> <span>import</span> <span>*</span>

<span>transpile</span>(<span>&#34;SELECT CAST(a AS INT) FROM x&#34;</span>, <span>type_mapping</span><span>=</span>{<span>exp</span>.<span>DataType</span>.<span>Type</span>.<span>INT</span>: <span>&#34;SPECIAL INT&#34;</span>})[<span>0</span>]</pre></div>
<div data-snippet-clipboard-copy-content="SELECT CAST(a AS SPECIAL INT) FROM x"><pre><span>SELECT</span> CAST(a <span>AS</span> SPECIAL <span>INT</span>) <span>FROM</span> x</pre></div>
<p dir="auto">More complicated transforms can be accomplished by using the Tokenizer, Parser, and Generator directly.</p>
<h4 dir="auto"><a id="user-content-custom-functions" aria-hidden="true" href="#custom-functions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Custom Functions</h4>
<p dir="auto">In  this example, we want to parse a UDF SPECIAL_UDF and then output another version called SPECIAL_UDF_INVERSE with the arguments switched.</p>
<div data-snippet-clipboard-copy-content="from sqlglot import *
from sqlglot.expressions import Func

class SpecialUdf(Func):
    arg_types = {&#39;a&#39;: True, &#39;b&#39;: True}

tokens = Tokenizer().tokenize(&#34;SELECT SPECIAL_UDF(a, b) FROM x&#34;)"><pre><span>from</span> <span>sqlglot</span> <span>import</span> <span>*</span>
<span>from</span> <span>sqlglot</span>.<span>expressions</span> <span>import</span> <span>Func</span>

<span>class</span> <span>SpecialUdf</span>(<span>Func</span>):
    <span>arg_types</span> <span>=</span> {<span>&#39;a&#39;</span>: <span>True</span>, <span>&#39;b&#39;</span>: <span>True</span>}

<span>tokens</span> <span>=</span> <span>Tokenizer</span>().<span>tokenize</span>(<span>&#34;SELECT SPECIAL_UDF(a, b) FROM x&#34;</span>)</pre></div>
<p dir="auto">Here is the output of the tokenizer:</p>
<div data-snippet-clipboard-copy-content="[
    &lt;Token token_type: TokenType.SELECT, text: SELECT, line: 0, col: 0&gt;,
    &lt;Token token_type: TokenType.VAR, text: SPECIAL_UDF, line: 0, col: 7&gt;,
    &lt;Token token_type: TokenType.L_PAREN, text: (, line: 0, col: 18&gt;,
    &lt;Token token_type: TokenType.VAR, text: a, line: 0, col: 19&gt;,
    &lt;Token token_type: TokenType.COMMA, text: ,, line: 0, col: 20&gt;,
    &lt;Token token_type: TokenType.VAR, text: b, line: 0, col: 22&gt;,
    &lt;Token token_type: TokenType.R_PAREN, text: ), line: 0, col: 23&gt;,
    &lt;Token token_type: TokenType.FROM, text: FROM, line: 0, col: 25&gt;,
    &lt;Token token_type: TokenType.VAR, text: x, line: 0, col: 30&gt;,
]
"><pre><code>[
    &lt;Token token_type: TokenType.SELECT, text: SELECT, line: 0, col: 0&gt;,
    &lt;Token token_type: TokenType.VAR, text: SPECIAL_UDF, line: 0, col: 7&gt;,
    &lt;Token token_type: TokenType.L_PAREN, text: (, line: 0, col: 18&gt;,
    &lt;Token token_type: TokenType.VAR, text: a, line: 0, col: 19&gt;,
    &lt;Token token_type: TokenType.COMMA, text: ,, line: 0, col: 20&gt;,
    &lt;Token token_type: TokenType.VAR, text: b, line: 0, col: 22&gt;,
    &lt;Token token_type: TokenType.R_PAREN, text: ), line: 0, col: 23&gt;,
    &lt;Token token_type: TokenType.FROM, text: FROM, line: 0, col: 25&gt;,
    &lt;Token token_type: TokenType.VAR, text: x, line: 0, col: 30&gt;,
]

</code></pre></div>
<div data-snippet-clipboard-copy-content="expression = Parser(functions={
    **SpecialUdf.default_parser_mappings(),
}).parse(tokens)[0]"><pre><span>expression</span> <span>=</span> <span>Parser</span>(<span>functions</span><span>=</span>{
    <span>**</span><span>SpecialUdf</span>.<span>default_parser_mappings</span>(),
}).<span>parse</span>(<span>tokens</span>)[<span>0</span>]</pre></div>
<p dir="auto">The expression tree produced by the parser:</p>
<div data-snippet-clipboard-copy-content="(SELECT distinct: False, expressions:
  (SPECIALUDF a:
    (COLUMN this:
      (IDENTIFIER this: a, quoted: False)), b:
    (COLUMN this:
      (IDENTIFIER this: b, quoted: False))), from:
  (FROM expressions:
    (TABLE this:
      (IDENTIFIER this: x, quoted: False))))"><pre><code>(SELECT distinct: False, expressions:
  (SPECIALUDF a:
    (COLUMN this:
      (IDENTIFIER this: a, quoted: False)), b:
    (COLUMN this:
      (IDENTIFIER this: b, quoted: False))), from:
  (FROM expressions:
    (TABLE this:
      (IDENTIFIER this: x, quoted: False))))
</code></pre></div>
<p dir="auto">Finally generating the new SQL:</p>
<div data-snippet-clipboard-copy-content="Generator(transforms={
    SpecialUdf: lambda self, e: f&#34;SPECIAL_UDF_INVERSE({self.sql(e, &#39;b&#39;)}, {self.sql(e, &#39;a&#39;)})&#34;
}).generate(expression)"><pre><span>Generator</span>(<span>transforms</span><span>=</span>{
    <span>SpecialUdf</span>: <span>lambda</span> <span>self</span>, <span>e</span>: <span>f&#34;SPECIAL_UDF_INVERSE(<span><span>{</span><span>self</span>.<span>sql</span>(<span>e</span>, <span>&#39;b&#39;</span>)<span>}</span></span>, <span><span>{</span><span>self</span>.<span>sql</span>(<span>e</span>, <span>&#39;a&#39;</span>)<span>}</span></span>)&#34;</span>
}).<span>generate</span>(<span>expression</span>)</pre></div>
<div data-snippet-clipboard-copy-content="SELECT SPECIAL_UDF_INVERSE(b, a) FROM x"><pre><span>SELECT</span> SPECIAL_UDF_INVERSE(b, a) <span>FROM</span> x</pre></div>
<h3 dir="auto"><a id="user-content-parser-errors" aria-hidden="true" href="#parser-errors"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Parser Errors</h3>
<p dir="auto">A syntax error will result in a parser error.</p>
<div data-snippet-clipboard-copy-content="transpile(&#34;SELECT foo( FROM bar&#34;)"><pre><span>transpile</span>(<span>&#34;SELECT foo( FROM bar&#34;</span>)</pre></div>
<div data-snippet-clipboard-copy-content="sqlglot.errors.ParseError: Expected )
  SELECT foo( __FROM__ bar"><pre><code>sqlglot.errors.ParseError: Expected )
  SELECT foo( __FROM__ bar
</code></pre></div>
<h3 dir="auto"><a id="user-content-unsupported-errors" aria-hidden="true" href="#unsupported-errors"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Unsupported Errors</h3>
<p dir="auto">Presto APPROX_DISTINCT supports the accuracy argument which is not supported in Spark.</p>
<div data-snippet-clipboard-copy-content="transpile(
    &#39;SELECT APPROX_DISTINCT(a, 0.1) FROM foo&#39;,
    read=&#39;presto&#39;,
    write=&#39;spark&#39;,
)"><pre><span>transpile</span>(
    <span>&#39;SELECT APPROX_DISTINCT(a, 0.1) FROM foo&#39;</span>,
    <span>read</span><span>=</span><span>&#39;presto&#39;</span>,
    <span>write</span><span>=</span><span>&#39;spark&#39;</span>,
)</pre></div>
<div data-snippet-clipboard-copy-content="WARNING:root:APPROX_COUNT_DISTINCT does not support accuracy

SELECT APPROX_COUNT_DISTINCT(a) FROM foo"><pre>WARNING:root:APPROX_COUNT_DISTINCT does not support accuracy

<span>SELECT</span> APPROX_COUNT_DISTINCT(a) <span>FROM</span> foo</pre></div>
<h3 dir="auto"><a id="user-content-build-and-modify-sql" aria-hidden="true" href="#build-and-modify-sql"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Build and Modify SQL</h3>
<p dir="auto">SQLGlot supports incrementally building sql expressions.</p>
<div data-snippet-clipboard-copy-content="from sqlglot import select, condition

where = condition(&#34;x=1&#34;).and_(&#34;y=1&#34;)
select(&#34;*&#34;).from_(&#34;y&#34;).where(where).sql()"><pre><span>from</span> <span>sqlglot</span> <span>import</span> <span>select</span>, <span>condition</span>

<span>where</span> <span>=</span> <span>condition</span>(<span>&#34;x=1&#34;</span>).<span>and_</span>(<span>&#34;y=1&#34;</span>)
<span>select</span>(<span>&#34;*&#34;</span>).<span>from_</span>(<span>&#34;y&#34;</span>).<span>where</span>(<span>where</span>).<span>sql</span>()</pre></div>
<p dir="auto">Which outputs:</p>
<div data-snippet-clipboard-copy-content="SELECT * FROM y WHERE x = 1 AND y = 1"><pre><span>SELECT</span> <span>*</span> <span>FROM</span> y <span>WHERE</span> x <span>=</span> <span>1</span> <span>AND</span> y <span>=</span> <span>1</span></pre></div>
<p dir="auto">You can also modify a parsed tree:</p>
<div data-snippet-clipboard-copy-content="from sqlglot import parse_one

parse_one(&#34;SELECT x FROM y&#34;).from_(&#34;z&#34;).sql()"><pre><span>from</span> <span>sqlglot</span> <span>import</span> <span>parse_one</span>

<span>parse_one</span>(<span>&#34;SELECT x FROM y&#34;</span>).<span>from_</span>(<span>&#34;z&#34;</span>).<span>sql</span>()</pre></div>
<p dir="auto">Which outputs:</p>

<p dir="auto">There is also a way to recursively transform the parsed tree by applying a mapping function to each tree node:</p>
<div data-snippet-clipboard-copy-content="from sqlglot import exp, parse_one

expression_tree = parse_one(&#34;SELECT a FROM x&#34;)

def transformer(node):
    if isinstance(node, exp.Column) and node.name == &#34;a&#34;:
        return parse_one(&#34;FUN(a)&#34;)
    return node

transformed_tree = expression_tree.transform(transformer)
transformed_tree.sql()"><pre><span>from</span> <span>sqlglot</span> <span>import</span> <span>exp</span>, <span>parse_one</span>

<span>expression_tree</span> <span>=</span> <span>parse_one</span>(<span>&#34;SELECT a FROM x&#34;</span>)

<span>def</span> <span>transformer</span>(<span>node</span>):
    <span>if</span> <span>isinstance</span>(<span>node</span>, <span>exp</span>.<span>Column</span>) <span>and</span> <span>node</span>.<span>name</span> <span>==</span> <span>&#34;a&#34;</span>:
        <span>return</span> <span>parse_one</span>(<span>&#34;FUN(a)&#34;</span>)
    <span>return</span> <span>node</span>

<span>transformed_tree</span> <span>=</span> <span>expression_tree</span>.<span>transform</span>(<span>transformer</span>)
<span>transformed_tree</span>.<span>sql</span>()</pre></div>
<p dir="auto">Which outputs:</p>

<h3 dir="auto"><a id="user-content-sql-annotations" aria-hidden="true" href="#sql-annotations"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>SQL Annotations</h3>
<p dir="auto">SQLGlot supports annotations in the sql expression. This is an experimental feature that is not part of any of the SQL standards but it can be useful when needing to annotate what a selected field is supposed to be. Below is an example:</p>
<div data-snippet-clipboard-copy-content="SELECT
  user #primary_key,
  country
FROM users"><pre><span>SELECT</span>
  user <span><span>#</span>primary_key,</span>
  country
<span>FROM</span> users</pre></div>
<h3 dir="auto"><a id="user-content-sql-optimizer" aria-hidden="true" href="#sql-optimizer"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>SQL Optimizer</h3>
<p dir="auto">SQLGlot can rewrite queries into an &#34;optimized&#34; form. It performs a variety of <a href="https://github.com/tobymao/sqlglot/blob/main/sqlglot/optimizer/optimizer.py">techniques</a> to create a new canonical AST. This AST can be used to standaradize queries or provide the foundations for implementing an actual engine.</p>
<div data-snippet-clipboard-copy-content="import sqlglot
from sqlglot.optimizer import optimize

&gt;&gt;&gt;
optimize(
    sqlglot.parse_one(&#34;&#34;&#34;
    SELECT A OR (B OR (C AND D))
    FROM x
    WHERE Z = date &#39;2021-01-01&#39; + INTERVAL &#39;1&#39; month OR 1 = 0
    &#34;&#34;&#34;),
    schema={&#34;x&#34;: {&#34;A&#34;: &#34;INT&#34;, &#34;B&#34;: &#34;INT&#34;, &#34;C&#34;: &#34;INT&#34;, &#34;D&#34;: &#34;INT&#34;, &#34;Z&#34;: &#34;STRING&#34;}}
).sql(pretty=True)

&#34;&#34;&#34;
SELECT
  (
    &#34;x&#34;.&#34;A&#34;
    OR &#34;x&#34;.&#34;B&#34;
    OR &#34;x&#34;.&#34;C&#34;
  )
  AND (
    &#34;x&#34;.&#34;A&#34;
    OR &#34;x&#34;.&#34;B&#34;
    OR &#34;x&#34;.&#34;D&#34;
  ) AS &#34;_col_0&#34;
FROM &#34;x&#34; AS &#34;x&#34;
WHERE
  &#34;x&#34;.&#34;Z&#34; = CAST(&#39;2021-02-01&#39; AS DATE)
&#34;&#34;&#34;"><pre><span>import</span> <span>sqlglot</span>
<span>from</span> <span>sqlglot</span>.<span>optimizer</span> <span>import</span> <span>optimize</span>

<span>&gt;&gt;</span><span>&gt;</span>
<span>optimize</span>(
    <span>sqlglot</span>.<span>parse_one</span>(<span>&#34;&#34;&#34;</span>
<span>    SELECT A OR (B OR (C AND D))</span>
<span>    FROM x</span>
<span>    WHERE Z = date &#39;2021-01-01&#39; + INTERVAL &#39;1&#39; month OR 1 = 0</span>
<span>    &#34;&#34;&#34;</span>),
    <span>schema</span><span>=</span>{<span>&#34;x&#34;</span>: {<span>&#34;A&#34;</span>: <span>&#34;INT&#34;</span>, <span>&#34;B&#34;</span>: <span>&#34;INT&#34;</span>, <span>&#34;C&#34;</span>: <span>&#34;INT&#34;</span>, <span>&#34;D&#34;</span>: <span>&#34;INT&#34;</span>, <span>&#34;Z&#34;</span>: <span>&#34;STRING&#34;</span>}}
).<span>sql</span>(<span>pretty</span><span>=</span><span>True</span>)

<span>&#34;&#34;&#34;</span>
<span>SELECT</span>
<span>  (</span>
<span>    &#34;x&#34;.&#34;A&#34;</span>
<span>    OR &#34;x&#34;.&#34;B&#34;</span>
<span>    OR &#34;x&#34;.&#34;C&#34;</span>
<span>  )</span>
<span>  AND (</span>
<span>    &#34;x&#34;.&#34;A&#34;</span>
<span>    OR &#34;x&#34;.&#34;B&#34;</span>
<span>    OR &#34;x&#34;.&#34;D&#34;</span>
<span>  ) AS &#34;_col_0&#34;</span>
<span>FROM &#34;x&#34; AS &#34;x&#34;</span>
<span>WHERE</span>
<span>  &#34;x&#34;.&#34;Z&#34; = CAST(&#39;2021-02-01&#39; AS DATE)</span>
<span>&#34;&#34;&#34;</span></pre></div>
<h3 dir="auto"><a id="user-content-benchmarks" aria-hidden="true" href="#benchmarks"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Benchmarks</h3>
<p dir="auto"><a href="https://github.com/tobymao/sqlglot/blob/main/benchmarks">Benchmarks</a> run on Python 3.9.6 in seconds.</p>
<table>
<thead>
<tr>
<th>Query</th>
<th>sqlglot</th>
<th><a href="https://github.com/andialbrecht/sqlparse">sqlparse</a></th>
<th><a href="https://github.com/klahnakoski/mo-sql-parsing">moz_sql_parser</a></th>
<th><a href="https://github.com/wseaton/sqloxide/">sqloxide</a></th>
</tr>
</thead>
<tbody>
<tr>
<td>short</td>
<td>0.00038</td>
<td>0.00104</td>
<td>0.00174</td>
<td>0.000060</td>
</tr>
<tr>
<td>long</td>
<td>0.00508</td>
<td>0.01522</td>
<td>0.02162</td>
<td>0.000597</td>
</tr>
<tr>
<td>crazy</td>
<td>0.01871</td>
<td>3.49415</td>
<td>0.35346</td>
<td>0.003104</td>
</tr>
</tbody>
</table>
<h2 dir="auto"><a id="user-content-run-tests-and-lint" aria-hidden="true" href="#run-tests-and-lint"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Run Tests and Lint</h2>
<div data-snippet-clipboard-copy-content="pip install -r requirements.txt
./format_code.sh
./run_checks.sh"><pre><code>pip install -r requirements.txt
./format_code.sh
./run_checks.sh
</code></pre></div>
<h2 dir="auto"><a id="user-content-optional-dependencies" aria-hidden="true" href="#optional-dependencies"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Optional Dependencies</h2>
<p dir="auto">SQLGlot uses <a href="https://github.com/dateutil/dateutil">dateutil</a> to simplify literal timedelta expressions. The optimizer will not simplify expressions like</p>

<p dir="auto">if the module cannot be found.</p>
</article>
          </div></div>
  </body>
</html>
