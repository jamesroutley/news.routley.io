<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fossil-scm.org/home/doc/trunk/www/sync.wiki">Original</a>
    <h1>The Fossil Sync Protocol</h1>
    
    <div id="readability-page-1" class="page"><div><p>This document describes the wire protocol used to synchronize
content between two Fossil repositories.

</p><h2>1.0 Overview</h2>

<p>The global state of a fossil repository consists of an unordered
<a href="https://fossil-scm.org/home/doc/trunk/www/fileformat.wiki">collection of artifacts</a>.  Each artifact is 
identified by a cryptographic
hash of its content, expressed as a lower-case hexadecimal string.
Synchronization is the process of sharing artifacts between
repositories so that all repositories have copies of all artifacts.  Because
artifacts are unordered, the order in which artifacts are received
is unimportant.  It is assumed that the hash names
of artifacts are unique - that every artifact has a different hash.
To a first approximation, synchronization proceeds by sharing lists
of hashes for available artifacts, then sharing the content of artifacts
whose names are missing from one side or the other of the connection.
In practice, a repository might contain millions of artifacts.  The list of
hash names for this many artifacts can be large.  So optimizations are
employed that usually reduce the number of hashes that need to be
shared to a few dozen.

</p><p>Each repository also has local state.  The local state determines
the web-page formatting preferences, authorized users, ticket formats,
and similar information that varies from one repository to another.
The local state is not usually transferred during a sync.  Except,
some local state is transferred during a <a href="https://fossil-scm.org/home/help?cmd=clone">clone</a>
in order to initialize the local state of the new repository.  Also,
an administrator can sync local state using
the <a href="https://fossil-scm.org/home/help?cmd=configuration">config push</a> and
<a href="https://fossil-scm.org/home/help?cmd=configuration">config pull</a>
commands.

</p><h3 id="crdt">1.1 Conflict-Free Replicated Datatypes</h3>

<p>The &#34;bag of artifacts&#34; data model used by Fossil is apparently an
implementation of a particular
<a href="https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type">Conflict-Free
Replicated Datatype (CRDT)</a> called a &#34;G-Set&#34; or &#34;Grow-only Set&#34;.  The
academic literature on CRDTs only began to appear in about 2011, and
Fossil predates that research by at least 4 years.  But it is nice to
know that theorists have now proven that the underlying data model of
Fossil can provide strongly-consistent replicas using only
peer-to-peer communication and without any kind of central
authority.

</p><p>If you are already familiar with CRDTs and were wondering if Fossil
used them, the answer is &#34;yes&#34;.  We just don&#39;t call them by that name.

</p><h2>2.0 Transport</h2>

<p>All communication between client and server is via HTTP requests.
The server is listening for incoming HTTP requests.  The client
issues one or more HTTP requests and receives replies for each
request.

</p><p>The server might be running as an independent server
using the <a href="https://fossil-scm.org/home/help?cmd=server">&#34;fossil server&#34; command</a>, or it
might be launched from inetd or xinetd using the
<a href="https://fossil-scm.org/home/wiki?name=%22fossil+http%22+command">/help?cmd=http</a>.  Or the server might
be <a href="https://fossil-scm.org/home/doc/trunk/www/server/any/cgi.md">launched from CGI</a> or from
<a href="https://fossil-scm.org/home/doc/trunk/www/server/any/scgi.md">SCGI</a>.
(See &#34;<a href="https://fossil-scm.org/home/doc/trunk/www/server/">How To Configure A Fossil Server</a>&#34; for details.)
The specifics of how the server listens
for incoming HTTP requests is immaterial to this protocol.
The important point is that the server is listening for requests and
the client is the issuer of the requests.

</p><p>A single <a href="https://fossil-scm.org/home/help?cmd=push">push</a>, 
<a href="https://fossil-scm.org/home/help?cmd=pull">pull</a>, or <a href="https://fossil-scm.org/home/help?cmd=sync">sync</a>
might involve multiple HTTP requests.
The client maintains state between all requests.  But on the server
side, each request is independent.  The server does not preserve
any information about the client from one request to the next.

</p><p>Note: Throughout this article, we use the terms &#34;server&#34; and &#34;client&#34;
to represent the listener and initiator of the interaction, respectively.
Nothing in this protocol requires that the server actually be a back-room
processor housed in a datacenter, nor does the client need to be a desktop
or handheld device.  For the purposes of this article &#34;client&#34; simply means
the repository that initiates the conversation and &#34;server&#34; is the repository
that responds.  Nothing more.

</p><h4>2.0.1 HTTPS Transport</h4>

<p>HTTPS differs from HTTP only in that the HTTPS protocol is
encrypted as it travels over the wire.  The underlying protocol
is the same.  This document describes only the underlying, unencrypted
messages that go client to server and back to client.
Whether or not those messages are encrypted does not come into play
in this document.

</p><p>Fossil includes built-in 
<a href="https://fossil-scm.org/home/doc/trunk/www/ssl-server.md">support for HTTPS encryption</a> in both client and server.

</p><h4>2.0.2 SSH Transport</h4>

<p>When doing a sync using an &#34;ssh:...&#34; URL, the same HTTP transport protocol
is used.  Fossil simply uses <a href="https://en.wikipedia.org/wiki/Secure_Shell">ssh</a>
to start an instance of the <a href="https://fossil-scm.org/home/help?cmd=test-http">fossil test-http</a> command
running on the remote machine.  It then sends HTTP requests and gets back HTTP
replies over the SSH connection, rather than sending and receiving over an
internet socket.  To see the specific &#34;ssh&#34; command that the Fossil client
runs in order to set up a connection, add either of the the &#34;--httptrace&#34; or
&#34;--sshtrace&#34; options to the &#34;fossil sync&#34; command line.

</p><h4>2.0.3 FILE Transport</h4>

<p>When doing a sync using a &#34;file:...&#34; URL, the same HTTP protocol is
still used.  But instead of sending each HTTP request over a socket or
via SSH, the HTTP request is written into a temporary file.  The client
then invokes the <a href="https://fossil-scm.org/home/help?cmd=http">fossil http</a> command in a subprocess
to process the request and and generate a reply.  The client then reads
the HTTP reply out of a temporary file on disk, and deletes the two
temporary files.  To see the specific &#34;fossil http&#34; command that is run
in order to implement the &#34;file:&#34; transport, add the &#34;--httptrace&#34;
option to the &#34;fossil sync&#34; command.

</p><h3>2.1 Server Identification</h3>

<p>The server is identified by a URL argument that accompanies the
push, pull, or sync command on the client.  (As a convenience to
users, the URL can be omitted on the client command and the same URL
from the most recent push, pull, or sync will be reused.  This saves
typing in the common case where the client does multiple syncs to
the same server.)

</p><p>The client modifies the URL by appending the method name &#34;<b>/xfer</b>&#34;
to the end.  For example, if the URL specified on the client command
line is

</p><pre>https://fossil-scm.org/fossil</pre>

<p>Then the URL that is really used to do the synchronization will
be:

</p><pre>https://fossil-scm.org/fossil/xfer</pre>

<h3>2.2 HTTP Request Format</h3>

<p>The client always sends a POST request to the server.  The
general format of the POST request is as follows:

</p><pre>POST /fossil/xfer HTTP/1.0
Host: fossil-scm.hwaci.com:80
Content-Type: application/x-fossil
Content-Length: 4216
</pre>

<pre><i>content...</i></pre>

<p>In the example above, the pathname given after the POST keyword
on the first line is a copy of the URL pathname.  The Host: parameter
is also taken from the URL.  The content type is always either
&#34;application/x-fossil&#34; or &#34;application/x-fossil-debug&#34;.  The &#34;x-fossil&#34;
content type is the default.  The only difference is that &#34;x-fossil&#34;
content is compressed using zlib whereas &#34;x-fossil-debug&#34; is sent
uncompressed.

</p><p>A typical reply from the server might look something like this:

</p><pre>HTTP/1.0 200 OK
Date: Mon, 10 Sep 2007 12:21:01 GMT
Connection: close
Cache-control: private
Content-Type: application/x-fossil; charset=US-ASCII
Content-Length: 265
</pre>

<pre><i>content...</i></pre>

<p>The content type of the reply is always the same as the content type
of the request.

</p><h2>3.0 Fossil Synchronization Content</h2>

<p>A synchronization request between a client and server consists of
one or more HTTP requests as described in the previous section.  This
section details the &#34;x-fossil&#34; content type.

</p><h3>3.1 Line-oriented Format</h3>

<p>The x-fossil content type consists of zero or more &#34;cards&#34;.  Cards
are separated by the newline character (&#34;\n&#34;).  Leading and trailing
whitespace on a card is ignored.  Blank cards are ignored.

</p><p>Each card is divided into zero or more space separated tokens.
The first token on each card is the operator.  Subsequent tokens
are arguments.  The set of operators understood by servers is slightly
different from the operators understood by clients, though the two
are very similar.

</p><h3>3.2 Login Cards</h3>

<p>Every message from client to server begins with one or more login
cards.  Each login card has the following format:

</p><pre><b>login</b>  <i>userid  nonce  signature</i></pre>

<p>The userid is the name of the user that is requesting service
from the server.  The nonce is the SHA1 hash of the remainder of
the message - all text that follows the newline character that
terminates the login card.  The signature is the SHA1 hash of
the concatenation of the nonce and the users password.

</p><p>For each login card, the server looks up the user and verifies
that the nonce matches the SHA1 hash of the remainder of the
message.  It then checks the signature hash to make sure the
signature matches.  If everything
checks out, then the client is granted all privileges of the
specified user.

</p><p>Privileges are cumulative.  There can be multiple successful
login cards.  The session privilege is the union of all
privileges from all login cards.

</p><h3>3.3 File Cards</h3>

<p>Artifacts are transferred using either &#34;file&#34; cards, or &#34;cfile&#34;
or &#34;uvfile&#34; cards.
The name &#34;file&#34; card comes from the fact that most artifacts correspond to
files that are under version control.
The &#34;cfile&#34; name is an abbreviation for &#34;compressed file&#34;.
The &#34;uvfile&#34; name is an abbreviation for &#34;unversioned file&#34;.

</p><h4>3.3.1 Ordinary File Cards</h4>

<p>For sync protocols, artifacts are transferred using &#34;file&#34;
cards.  File cards come in two different formats depending
on whether the artifact is sent directly or as a 
<a href="https://fossil-scm.org/home/doc/trunk/www/delta_format.wiki">delta</a> from some
other artifact.

</p><pre><b>file</b> <i>artifact-id size</i> <b>\n</b> <i>content</i>
<b>file</b> <i>artifact-id delta-artifact-id size</i> <b>\n</b> <i>content</i>
</pre>

<p>File cards are followed by in-line &#34;payload&#34; data.
The content of the artifact
or the artifact delta is the first <i>size</i> bytes of the
x-fossil content that immediately follow the newline that
terminates the file card.

</p><p>The first argument of a file card is the ID of the artifact that
is being transferred.  The artifact ID is the lower-case hexadecimal
representation of the name hash for the artifact.
The last argument of the file card is the number of bytes of
payload that immediately follow the file card.  If the file
card has only two arguments, that means the payload is the
complete content of the artifact.  If the file card has three
arguments, then the payload is a 
<a href="https://fossil-scm.org/home/doc/trunk/www/delta_format.wiki">delta</a> and the second argument is
the ID of another artifact that is the source of the delta.

</p><p>File cards are sent in both directions: client to server and
server to client.  A delta might be sent before the source of
the delta, so both client and server should remember deltas
and be able to apply them when their source arrives.

</p><h4>3.3.2 Compressed File Cards</h4>

<p>A client that sends a clone protocol version &#34;3&#34; or greater will
receive artifacts as &#34;cfile&#34; cards while cloning.  This card was
introduced to improve the speed of the transfer of content by sending the
compressed artifact directly from the server database to the client.

</p><p>Compressed File cards are similar to File cards, sharing the same
in-line &#34;payload&#34; data characteristics and also the same treatment of
direct content or delta content.  Cfile cards come in two different formats
depending on whether the artifact is sent directly or as a delta from
some other artifact.

</p><pre><b>cfile</b> <i>artifact-id usize csize</i> <b>\n</b> <i>content</i>
<b>cfile</b> <i>artifact-id delta-artifact-id usize csize</i> <b>\n</b> <i>content</i>
</pre>

<p>The first argument of the cfile card is the ID of the artifact that
is being transferred.  The artifact ID is the lower-case hexadecimal
representation of the name hash for the artifact.  The second argument of
the cfile card is the original size in bytes of the artifact.  The last
argument of the cfile card is the number of compressed bytes of payload
that immediately follow the cfile card.  If the cfile card has only
three arguments, that means the payload is the complete content of the
artifact.  If the cfile card has four arguments, then the payload is a
delta and the second argument is the ID of another artifact that is the
source of the delta and the third argument is the original size of the
delta artifact.

</p><p>Unlike file cards, cfile cards are only sent in one direction during a
clone from server to client for clone protocol version &#34;3&#34; or greater.

</p><h4>3.3.3 Private artifacts</h4>

<p>&#34;Private&#34; content consist of artifacts that are not normally synced.
However, private content will be synced when the
the <a href="https://fossil-scm.org/home/help?cmd=sync">fossil sync</a> command includes the &#34;--private&#34; option.

</p><p>Private content is marked by a &#34;private&#34; card:

</p><pre><b>private</b></pre>

<p>The private card has no arguments and must directly precede a
file card that contains the private content.

</p><h4>3.3.4 Unversioned File Cards</h4>

<p>Unversioned content is sent in both directions (client to server and
server to client) using &#34;uvfile&#34; cards in the following format:

</p><pre><b>uvfile</b> <i>name mtime hash size flags</i> <b>\n</b> <i>content</i></pre>

<p>The <i>name</i> field is the name of the unversioned file.  The
<i>mtime</i> is the last modification time of the file in seconds
since 1970.  The <i>hash</i> field is the hash of the content
for the unversioned file, or &#34;<b>-</b>&#34; for deleted content.
The <i>size</i> field is the (uncompressed) size of the content
in bytes.  The <i>flags</i> field is an integer which is interpreted
as an array of bits.  The 0x0004 bit of <i>flags</i> indicates that
the <i>content</i> is to be omitted.  The content might be omitted if
it is too large to transmit, or if the sender merely wants to update the
modification time of the file without changing the files content.
The <i>content</i> is the (uncompressed) content of the file.

</p><p>The receiver should only accept the uvfile card if the hash and
size match the content and if the mtime is newer than any existing
instance of the same file held by the receiver.  The sender will not
normally transmit a uvfile card unless all these constraints are true,
but the receiver should double-check.

</p><p>A server will only accept uvfile cards if the login user has
the &#34;y&#34; write-unversioned permission.

</p><p>Servers send uvfile cards in response to uvgimme cards received from
the client.  Clients send uvfile cards when they determine that the server
needs the content based on uvigot cards previously received from the server.

</p><h3>3.4 Push and Pull Cards</h3>

<p>Among the first cards in a client-to-server message are
the push and pull cards.  The push card tells the server that
the client is pushing content.  The pull card tells the server
that the client wants to pull content.  In the event of a sync,
both cards are sent.  The format is as follows:

</p><pre><b>push</b> <i>servercode projectcode</i>
<b>pull</b> <i>servercode projectcode</i>
</pre>

<p>The <i>servercode</i> argument is the repository ID for the
client.  The <i>projectcode</i> is the identifier
of the software project that the client repository contains.
The projectcode for the client and server must match in order
for the transaction to proceed.

</p><p>The server will also send a push card back to the client
during a clone.  This is how the client determines what project
code to put in the new repository it is constructing.

</p><p>The <i>servercode</i> argument is currently unused.

</p><h3>3.5 Clone Cards</h3>

<p>A clone card works like a pull card in that it is sent from
client to server in order to tell the server that the client
wants to pull content.  The clone card comes in two formats.  Older
clients use the no-argument format and newer clients use the
two-argument format.

</p><pre><b>clone</b>
<b>clone</b> <i>protocol-version sequence-number</i>
</pre>

<h4>3.5.1 Protocol 3</h4>

<p>The latest clients send a two-argument clone message with a
protocol version of &#34;3&#34;.   (Future versions of Fossil might use larger
protocol version numbers.)  Version &#34;3&#34; of the protocol enhanced version
&#34;2&#34; by introducing the &#34;cfile&#34; card which is intended to speed up clone
operations.  Instead of sending &#34;file&#34; cards, the server will send &#34;cfile&#34;
cards

</p><h4>3.5.2 Protocol 2</h4>

<p>The sequence-number sent is the number
of artifacts received so far.  For the first clone message, the
sequence number is 0.  The server will respond by sending file
cards for some number of artifacts up to the maximum message size.

</p><p>The server will also send a single &#34;clone_seqno&#34; card to the client
so that the client can know where the server left off.

</p><pre><b>clone_seqno</b>  <i>sequence-number</i>
</pre>

<p>The clone message in subsequent HTTP requests for the same clone
operation will use the sequence-number from the
clone_seqno of the previous reply.

</p><p>In response to an initial clone message, the server also sends the client
a push message so that the client can discover the projectcode for
this project.

</p><h4>3.5.3 Legacy Protocol</h4>

<p>Older clients send a clone card with no argument.  The server responds
to a blank clone card by sending an &#34;igot&#34; card for every artifact in the
repository.  The client will then issue &#34;gimme&#34; cards to pull down all the
content it needs.

</p><p>The legacy protocol works well for smaller repositories (50MB with 50,000
artifacts) but is too slow and unwieldy for larger repositories.
The version 2 protocol is an effort to improve performance.  Further
performance improvements with higher-numbered clone protocols are
possible in future versions of Fossil.

</p><h3>3.6 Igot Cards</h3>

<p>An igot card can be sent from either client to server or from
server to client in order to indicate that the sender holds a copy
of a particular artifact.  The format is:

</p><pre><b>igot</b> <i>artifact-id</i> ?<i>flag</i>?
</pre>

<p>The first argument of the igot card is the ID of the artifact that
the sender possesses.
The receiver of an igot card will typically check to see if
it also holds the same artifact and if not it will request the artifact
using a gimme card in either the reply or in the next message.

</p><p>If the second argument exists and is &#34;1&#34;, then the artifact
identified by the first argument is private on the sender and should
be ignored unless a &#34;--private&#34; <a href="https://fossil-scm.org/home/help?cmd=sync">sync</a> is occurring.

</p><p>The name &#34;igot&#34; comes from the English slang expression &#34;I got&#34; meaning
&#34;I have&#34;.

</p><h4>3.6.1 Unversioned Igot Cards</h4>

<p>Zero or more &#34;uvigot&#34; cards are sent from server to client when
synchronizing unversioned content.  The format of a uvigot card is
as follows:

</p><pre><b>uvigot</b> <i>name mtime hash size</i>
</pre>

<p>The <i>name</i> argument is the name of an unversioned file.
The <i>mtime</i> is the last modification time of the unversioned file
in seconds since 1970.
The <i>hash</i> is the SHA1 or SHA3-256 hash of the unversioned file
content, or &#34;<b>-</b>&#34; if the file has been deleted.
The <i>size</i> is the uncompressed size of the file in bytes.

</p><p>When the server sees a &#34;pragma uv-hash&#34; card for which the hash
does not match, it sends uvigot cards for every unversioned file that it
holds.  The client will use this information to figure out which
unversioned files need to be synchronized.
The server might also send a uvigot card when it receives a uvgimme card
but its reply message size is already oversized and hence unable to hold
the usual uvfile reply.

</p><p>When a client receives a &#34;uvigot&#34; card, it checks to see if the
file needs to be transferred from client to server or from server to client.
If a client-to-server transmission is needed, the client schedules that
transfer to occur on a subsequent HTTP request.  If a server-to-client
transfer is needed, then the client sends a &#34;uvgimme&#34; card back to the
server to request the file content.

</p><h3>3.7 Gimme Cards</h3>

<p>A gimme card is sent from either client to server or from server
to client.  The gimme card asks the receiver to send a particular
artifact back to the sender.  The format of a gimme card is this:

</p><pre><b>gimme</b> <i>artifact-id</i>
</pre>

<p>The argument to the gimme card is the ID of the artifact that
the sender wants.  The receiver will typically respond to a
gimme card by sending a file card in its reply or in the next
message.

</p><p>The &#34;gimme&#34; name means &#34;give me&#34;.  The imperative &#34;give me&#34; is
pronounced as if it were a single word &#34;gimme&#34; in some dialects of 
English (including the dialect spoken by the original author of Fossil).

</p><h4>3.7.1 Unversioned Gimme Cards</h4>

<p>Sync synchronizing unversioned content, the client may send &#34;uvgimme&#34;
cards to the server.  A uvgimme card requests that the server send
unversioned content to the client.  The format of a uvgimme card is
as follows:

</p><pre><b>uvgimme</b> <i>name</i>
</pre>

<p>The <i>name</i> is the name of the unversioned file found on the
server that the client would like to have.  When a server sees a
uvgimme card, it normally responses with a uvfile card, though it might
also send another uvigot card if the HTTP reply is already oversized.

</p><h3>3.8 Cookie Cards</h3>

<p>A cookie card can be used by a server to record a small amount
of state information on a client.  The server sends a cookie to the
client.  The client sends the same cookie back to the server on
its next request.  The cookie card has a single argument which
is its payload.

</p><pre><b>cookie</b> <i>payload</i>
</pre>

<p>The client is not required to return the cookie to the server on
its next request.  Or the client might send a cookie from a different
server on the next request.  So the server must not depend on the
cookie and the server must structure the cookie payload in such
a way that it can tell if the cookie it sees is its own cookie or
a cookie from another server.  (Typically the server will embed
its servercode as part of the cookie.)

</p><h3>3.9 Request-Configuration Cards</h3>

<p>A request-configuration or &#34;reqconfig&#34; card is sent from client to
server in order to request that the server send back &#34;configuration&#34;
data.  &#34;Configuration&#34; data is information about users or website
appearance or other administrative details which are not part of the
persistent and versioned state of the project.  For example, the &#34;name&#34;
of the project, the default Cascading Style Sheet (CSS) for the web-interface,
and the project logo displayed on the web-interface are all configuration
data elements.

</p><p>The reqconfig card is normally sent in response to the
&#34;fossil configuration pull&#34; command.  The format is as follows:

</p><pre><b>reqconfig</b> <i>configuration-name</i>
</pre>

<p>As of 2018-06-04, the configuration-name must be one of the
following values:

</p><table>
<tbody><tr><td>
<ul>
<li> css
</li><li> header
</li><li> footer
</li><li> details
</li><li> logo-mimetype
</li><li> logo-image
</li><li> background-mimetype
</li><li> background-image
</li><li> index-page
</li><li> timeline-block-markup
</li><li> timeline-max-comment
</li><li> timeline-plaintext
</li><li> adunit
</li><li> adunit-omit-if-admin
</li><li> adunit-omit-if-user
<ul></ul></li></ul></td><td><ul>
<li> th1-docs
</li><li> th1-hooks
</li><li> th1-setup
</li><li> tcl
</li><li> tcl-setup
</li><li> project-name
</li><li> short-project-name
</li><li> project-description
</li><li> index-page
</li><li> manifest
</li><li> binary-glob
</li><li> clean-glob
</li><li> ignore-glob
</li><li> keep-glob
</li><li> crlf-glob
<ul></ul></li></ul></td><td><ul>
<li> crnl-glob
</li><li> encoding-glob
</li><li> empty-dirs
</li><li> <s title="removed 2020-08, version 2.12.1">allow-symlinks</s>
</li><li> dotfiles
</li><li> parent-project-code
</li><li> parent-projet-name
</li><li> hash-policy
</li><li> mv-rm-files
</li><li> ticket-table
</li><li> ticket-common
</li><li> ticket-change
</li><li> ticket-newpage
</li><li> ticket-viewpage
</li><li> ticket-editpage
<ul></ul></li></ul></td><td><ul>
<li> ticket-reportlist
</li><li> ticket-report-template
</li><li> ticket-key-template
</li><li> ticket-title-expr
</li><li> ticket-closed-expr
</li><li> xfer-common-script
</li><li> xfer-push-script
</li><li> xfer-commit-script
</li><li> xfer-ticket-script
</li><li> @reportfmt
</li><li> @user
</li><li> @concealed
</li><li> @shun
</li></ul></td></tr>
</tbody></table>

<p>New configuration-names are likely to be added in future releases of
Fossil.  If the server receives a configuration-name that it does not
understand, the entire reqconfig card is silently ignored.  The reqconfig
card might also be ignored if the user lacks sufficient privilege to
access the requested information.

</p><p>The configuration-names that begin with an alphabetic character refer
to values in the &#34;config&#34; table of the server database.  For example,
the &#34;logo-image&#34; configuration item refers to the project logo image
that is configured on the Admin page of the <a href="https://fossil-scm.org/home/doc/trunk/www/webui.wiki">web-interface</a>.
The value of the configuration item is returned to the client using a
&#34;config&#34; card.

</p><p>If the configuration-name begins with &#34;@&#34;, that refers to a class of
values instead of a single value.  The content of these configuration items
is returned in a &#34;config&#34; card that contains pure SQL text that is
intended to be evaluated by the client.

</p><p>The @user and @concealed configuration items contain sensitive information
and are ignored for clients without sufficient privilege.

</p><h3>3.10 Configuration Cards</h3>

<p>A &#34;config&#34; card is used to send configuration information from client
to server (in response to a &#34;fossil configuration push&#34; command) or
from server to client (in response to a &#34;fossil configuration pull&#34; or
&#34;fossil clone&#34; command).  The format is as follows:

</p><pre><b>config</b> <i>configuration-name size</i> <b>\n</b> <i>content</i>
</pre>

<p>The server will only accept a config card if the user has
&#34;Admin&#34; privilege.  A client will only accept a config card if
it had sent a corresponding reqconfig card in its request.

</p><p>The content of the configuration item is used to overwrite the
corresponding configuration data in the receiver.

</p><h3>3.11 Pragma Cards</h3>

<p>The client may try to influence the behavior of the server by
issuing a pragma card:

</p><pre><b>pragma <i>name value...</i>
</b></pre>

<p>The &#34;pragma&#34; card has at least one argument which is the pragma name.
The pragma name defines what the pragma does.
A pragma might have zero or more &#34;value&#34; arguments
depending on the pragma name.

</p><p>New pragma names may be added to the protocol from time to time
in order to enhance the capabilities of Fossil.
Unknown pragmas are silently ignored, for backwards compatibility.

</p><p>The following are the known pragma names as of 2019-06-30:

</p><ol>
<li><b>send-private</b> The send-private pragma instructs the server to send all of its
private artifacts to the client.  The server will only obey this
request if the user has the &#34;x&#34; or &#34;Private&#34; privilege.

</li><li><p><b>send-catalog</b> The send-catalog pragma instructs the server to transmit igot
cards for every known artifact.  This can help the client and server
to get back in synchronization after a prior protocol error.  The
&#34;--verily&#34; option to the <a href="https://fossil-scm.org/home/help?cmd=sync">fossil sync</a> command causes
the send-catalog pragma to be transmitted.

</p></li><li><p><b>uv-hash</b> <i>HASH</i> The uv-hash pragma is sent from client to server to provoke a
synchronization of unversioned content.  The <i>HASH</i> is a SHA1
hash of the names, modification times, and individual hashes of all
unversioned files on the client.  If the unversioned content hash
from the client does not match the unversioned content hash on the
server, then the server will reply with either a &#34;pragma uv-push-ok&#34;
or &#34;pragma uv-pull-only&#34; card followed by one &#34;uvigot&#34; card for
each unversioned file currently held on the server.  The collection
of &#34;uvigot&#34; cards sent in response to a &#34;uv-hash&#34; pragma is called
the &#34;unversioned catalog&#34;.  The client will used the unversioned
catalog to figure out which files (if any) need to be synchronized
between client and server and send appropriate &#34;uvfile&#34; or &#34;uvgimme&#34;
cards on the next HTTP request.

</p><p>If a client sends a uv-hash pragma and does not receive back
either a uv-pull-only or uv-push-ok pragma, that means that the
content on the server exactly matches the content on the client and
no further synchronization is required.

</p></li><li><p><b>uv-pull-only</b> A server sends the uv-pull-only pragma to the client in response
to a uv-hash pragma with a mismatched content hash argument.  This
pragma indicates that there are differences in unversioned content
between the client and server but that content can only be transferred
from server to client.  The server is unwilling to accept content from
the client because the client login lacks the &#34;write-unversioned&#34;
permission.

</p></li><li><p><b>uv-push-ok</b> A server sends the uv-push-ok pragma to the client in response
to a uv-hash pragma with a mismatched content hash argument.  This
pragma indicates that there are differences in unversioned content
between the client and server and that content can be transferred
in either direction.  The server is willing to accept content from
the client because the client login has the &#34;write-unversioned&#34;
permission.

</p></li><li><p><b>ci-lock</b> <i>CHECKIN-HASH CLIENT-ID</i> A client sends the &#34;ci-lock&#34; pragma to the server to indicate
that it is about to add a new check-in as a child of the
CHECKIN-HASH check-in and on the same branch as CHECKIN-HASH.
If some other client has already indicated that it was also
trying to commit against CHECKIN-HASH, that indicates that a
fork is about to occur, and the server will reply with
a &#34;ci-lock-fail&#34; pragma (see below).  Check-in locks
automatically expire when the check-in actually occurs, or
after a timeout (currently one minute but subject to change).

</p></li><li><p><b>ci-lock-fail</b> <i>LOGIN MTIME</i> When a server receives two or more &#34;ci-lock&#34; pragma messages
for the same check-in but from different clients, the second a
subsequent ci-lock will provoke a ci-lock-fail pragma in the
reply to let the client know that it if continues with the
check-in it will likely generate a fork.  The LOGIN and MTIME
arguments are intended to provide information to the client to
help it generate a more useful error message.

</p></li><li><p><b>ci-unlock</b> <i>CLIENT-ID</i> A client sends the &#34;ci-unlock&#34; pragma to the server after
a successful commit.  This instructs the server to release
any lock on any check-in previously held by that client.
The ci-unlock pragma helps to avoid false-positive lock warnings
that might arise if a check-in is aborted and then restarted
on a branch.
</p></li></ol>

<h3>3.12 Comment Cards</h3>

<p>Any card that begins with &#34;#&#34; (ASCII 0x23) is a comment card and
is silently ignored.

</p><h3>3.13 Message and Error Cards</h3>

<p>If the server discovers anything wrong with a request, it generates
an error card in its reply.  When the client sees the error card,
it displays an error message to the user and aborts the sync
operation.  An error card looks like this:

</p><pre><b>error</b> <i>error-message</i>
</pre>

<p>The error message is English text that is encoded in order to
be a single token.
A space (ASCII 0x20) is represented as &#34;\s&#34; (ASCII 0x5C, 0x73).  A
newline (ASCII 0x0a) is &#34;\n&#34; (ASCII 0x6C, x6E).  A backslash
(ASCII 0x5C) is represented as two backslashes &#34;\\&#34;.  Apart from
space and newline, no other whitespace characters nor any
unprintable characters are allowed in
the error message.

</p><p>The server can also send a message card that also prints a
message on the client console, but which is not an error:

</p><pre><b>message</b> <i>message-text</i>
</pre>

<p>The message-text uses the same format as an error message.

</p><h3>3.14 Unknown Cards</h3>

<p>If either the client or the server sees a card that is not
described above, then it generates an error and aborts.

</p><h2>4.0 Phantoms And Clusters</h2>

<p>When a repository knows that an artifact exists and knows the ID of
that artifact, but it does not know the artifact content, then it stores that
artifact as a &#34;phantom&#34;.  A repository will typically create a phantom when
it receives an igot card for an artifact that it does not hold or when it
receives a file card that references a delta source that it does not
hold.  When a server is generating its reply or when a client is
generating a new request, it will usually send gimme cards for every
phantom that it holds.

</p><p>A cluster is a special artifact that tells of the existence of other
artifacts.  Any artifact in the repository that follows the syntactic rules
of a cluster is considered a cluster.

</p><p>A cluster is line oriented.  Each line of a cluster
is a card.  The cards are separated by the newline (&#34;\n&#34;) character.
Each card consists of a single character card type, a space, and a
single argument.  No extra whitespace and no trailing or leading
whitespace is allowed.  All cards in the cluster must occur in
strict lexicographical order.

</p><p>A cluster consists of one or more &#34;M&#34; cards followed by a single
&#34;Z&#34; card.  Each M card holds an argument which is an artifact ID for an
artifact in the repository.  The Z card has a single argument which is the
lower-case hexadecimal representation of the MD5 checksum of all
preceding M cards up to and included the newline character that
occurred just before the Z that starts the Z card.

</p><p>Any artifact that does not match the specifications of a cluster
exactly is not a cluster.  There must be no extra whitespace in
the artifact.  There must be one or more M cards.  There must be a
single Z card with a correct MD5 checksum.  And all cards must
be in strict lexicographical order.

</p><h3>4.1 The Unclustered Table</h3>

<p>Every repository maintains a table named &#34;<b>unclustered</b>&#34;
which records the identity of every artifact and phantom it holds that is not
mentioned in a cluster.  The entries in the unclustered table can
be thought of as leaves on a tree of artifacts.  Some of the unclustered
artifacts will be other clusters.  Those clusters may contain other clusters,
which might contain still more clusters, and so forth.  Beginning
with the artifacts in the unclustered table, one can follow the chain
of clusters to find every artifact in the repository.

</p><h2>5.0 Synchronization Strategies</h2>

<h3>5.1 Pull</h3>

<p>A typical pull operation proceeds as shown below.  Details
of the actual implementation may very slightly but the gist of
a pull is captured in the following steps:

</p><ol>
<li>The client sends login and pull cards.
</li><li>The client sends a cookie card if it has previously received a cookie.
</li><li>The client sends gimme cards for every phantom that it holds.
<hr/>
</li><li>The server checks the login password and rejects the session if
the user does not have permission to pull.
</li><li>If the number of entries in the unclustered table on the server is
greater than 100, then the server constructs a new cluster artifact to
cover all those unclustered entries.
</li><li>The server sends file cards for every gimme card it received
from the client.
</li><li>The server sends igot cards for every artifact in its unclustered
table that is not a phantom.
<hr/>
</li><li>The client adds the content of file cards to its repository.
</li><li>The client creates a phantom for every igot card in the server reply
that mentions an artifact that the client does not possess.
</li><li>The client creates a phantom for the delta source of file cards when
the delta source is an artifact that the client does not possess.
</li></ol>

<p>These ten steps represent a single HTTP round-trip request.
The first three steps are the processing that occurs on the client
to generate the request.  The middle four steps are processing
that occurs on the server to interpret the request and generate a
reply.  And the last three steps are the processing that the
client does to interpret the reply.

</p><p>During a pull, the client will keep sending HTTP requests
until it holds all artifacts that exist on the server.

</p><p>Note that the server tries
to limit the size of its reply message to something reasonable
(usually about 1MB) so that it might stop sending file cards as
described in step (6) if the reply becomes too large.

</p><p>Step (5) is the only way in which new clusters can be created.
By only creating clusters on the server, we hope to minimize the
amount of overlap between clusters in the common configuration where
there is a single server and many clients.  The same synchronization
protocol will continue to work even if there are multiple servers
or if servers and clients sometimes change roles.  The only negative
effects of these unusual arrangements is that more than the minimum
number of clusters might be generated.

</p><h3>5.2 Push</h3>

<p>A typical push operation proceeds roughly as shown below.  As
with a pull, the actual implementation may vary slightly.

</p><ol>
<li>The client sends login and push cards.
</li><li>The client sends file cards for any artifacts that it holds that have
never before been pushed - artifacts that come from local check-ins.
</li><li>If this is the second or later cycle in a push, then the
client sends file cards for any gimme cards that the server sent
in the previous cycle.
</li><li>The client sends igot cards for every artifact in its unclustered table
that is not a phantom.
<hr/>
</li><li>The server checks the login and push cards and issues an error if
anything is amiss.
</li><li>The server accepts file cards from the client and adds those artifacts
to its repository.
</li><li>The server creates phantoms for igot cards that mention artifacts it
does not possess or for file cards that mention delta source artifacts that
it does not possess.
</li><li>The server issues gimme cards for all phantoms.
<hr/>
</li><li>The client remembers the gimme cards from the server so that it
can generate file cards in reply on the next cycle.
</li></ol>

<p>As with a pull, the steps of a push operation repeat until the
server knows all artifacts that exist on the client.  Also, as with
pull, the client attempts to keep the size of the request from
growing too large by suppressing file cards once the
size of the request reaches 1MB.

</p><h3 id="sync">5.3 Sync</h3>

<p>A sync is just a pull and a push that happen at the same time.
The first three steps of a pull are combined with the first five steps
of a push.  Steps (4) through (7) of a pull are combined with steps
(5) through (8) of a push.  And steps (8) through (10) of a pull
are combined with step (9) of a push.

</p><h3>5.4 Unversioned File Sync</h3>

<p>&#34;Unversioned files&#34; are files held in the repository
where only the most recent version of the file is kept rather than
the entire change history.  Unversioned files are intended to be
used to store ephemeral content, such as compiled binaries of the
most recent release.

</p><p>Unversioned files are identified by name and timestamp (mtime).
Only the most recent version of each file (the version with
the largest mtime value) is retained.

</p><p>Unversioned files are synchronized using the
<a href="https://fossil-scm.org/home/help?cmd=unversioned">fossil unversioned sync</a> command.

</p><p>A schematic of an unversioned file synchronization is as follows:

</p><ol>
<li>The client sends a &#34;pragma uv-hash&#34; card to the server.  The argument
    to the uv-hash pragma is a hash of all filesnames, mtimes, and
    content hashes for the unversioned files held by the client.
    <hr/>
</li><li>If the unversioned content hash from the client matches the unversioned
    content hash on the server, then nothing needs to be done and the
    server no-ops.  But if the hashes are different, then the server
    replies with either a uv-pull-only or a uv-push-ok pragma followed by
    uvigot cards for all unversioned files held on the server.
    <hr/>
</li><li>The client examines the uvigot cards received from the server and
    determines which unversioned files need to be exchanged in order
    to bring the client and server into synchronization.  The client
    then sends appropriate &#34;uvgimme&#34; or &#34;uvfile&#34; cards back to the
    server.
    <hr/>
</li><li>The server updates its unversioned file store with received &#34;uvfile&#34;
    cards and answers &#34;uvgimme&#34; cards with &#34;uvfile&#34; cards in its reply.
</li></ol>

<p>The last two steps might be repeated multiple
times if there is more unversioned content to be transferred than will
fit comfortably in a single HTTP request.

</p><h2>6.0 Summary</h2>

<p>Here are the key points of the synchronization protocol:

</p><ol>
<li>The client sends one or more PUSH HTTP requests to the server.
    The request and reply content type is &#34;application/x-fossil&#34;.
</li><li>HTTP request content is compressed using zlib.
</li><li>The content of request and reply consists of cards with one
    card per line.
</li><li>Card formats are:
    <ul>
    <li> <b>login</b> <i>userid nonce signature</i>
    </li><li> <b>push</b> <i>servercode projectcode</i>
    </li><li> <b>pull</b> <i>servercode projectcode</i>
    </li><li> <b>clone</b>
    </li><li> <b>clone_seqno</b> <i>sequence-number</i>
    </li><li> <b>file</b> <i>artifact-id size</i> <b>\n</b> <i>content</i>
    </li><li> <b>file</b> <i>artifact-id delta-artifact-id size</i> <b>\n</b> <i>content</i>
    </li><li> <b>cfile</b> <i>artifact-id size</i> <b>\n</b> <i>content</i>
    </li><li> <b>cfile</b> <i>artifact-id delta-artifact-id size</i> <b>\n</b> <i>content</i>
    </li><li> <b>uvfile</b> <i>name mtime hash size flags</i> <b>\n</b> <i>content</i>
    </li><li> <b>private</b>
    </li><li> <b>igot</b> <i>artifact-id</i> ?<i>flag</i>?
    </li><li> <b>uvigot</b> <i>name mtime hash size</i>
    </li><li> <b>gimme</b> <i>artifact-id</i>
    </li><li> <b>uvgimme</b> <i>name</i>
    </li><li> <b>cookie</b>  <i>cookie-text</i>
    </li><li> <b>reqconfig</b> <i>parameter-name</i>
    </li><li> <b>config</b> <i>parameter-name size</i> <b>\n</b> <i>content</i>
    </li><li> <b>pragma</b> <i>name</i> <i>value...</i>
    </li><li> <b>error</b> <i>error-message</i>
    </li><li> <b>message</b> <i>text-messate</i>
    </li><li> <b>#</b> <i>arbitrary-text...</i>
    </li></ul>
</li><li>Phantoms are artifacts that a repository knows exist but does not possess.
</li><li>Clusters are artifacts that contain IDs of other artifacts.
</li><li>Clusters are created automatically on the server during a pull.
</li><li>Repositories keep track of all artifacts that are not named in any
cluster and send igot messages for those artifacts.
</li><li>Repositories keep track of all the phantoms they hold and send
gimme messages for those artifacts.
</li></ol>

<h2>7.0 Troubleshooting And Debugging Hints</h2>

<p>If you run the <a href="https://fossil-scm.org/home/help?cmd=sync">fossil sync</a> command
(or <a href="https://fossil-scm.org/home/help?cmd=pull">pull</a> or <a href="https://fossil-scm.org/home/help?cmd=push">push</a> or
<a href="https://fossil-scm.org/home/help?cmd=clone">clone</a>) with the --httptrace option, Fossil
will keep a copy of each HTTP request and reply in files
named:
</p><ul>
<li> <tt>http-request-</tt><i>N</i><tt>.txt</tt>
</li><li> <tt>http-reply-</tt><i>N</i><tt>.txt</tt>
</li></ul>

<p>In the above, <i>N</i> is an integer that increments with each
round-trip.  If you are having trouble on the server side,
you can run the &#34;<a href="https://fossil-scm.org/home/help?cmd=test-http">fossil test-http</a>&#34; command in a
debugger using one the &#34;http-request-N.txt&#34; files as input and
single step through the processing performed by the server.

</p><p>The &#34;--transport-command CMD&#34; option on <a href="https://fossil-scm.org/home/help?cmd=sync">fossil sync</a>
(and similar) causes the external program &#34;CMD&#34; to be used to move
the sync message to the server and retrieve the sync reply.  The
CMD is given three arguments:
</p><ol>
<li> The URL of the server
</li><li> The name of a temporary file that contains the output-bound sync
     protocol text, with the HTTP headers
</li><li> The name of a temporary file into which the CMD should write the
     reply sync protocol text, again without any HTTP headers
</li></ol>

<p>In a complex debugging situation, you can run the command
&#34;fossil sync --transport-command ./debugging_script&#34; where
&#34;debugging_script&#34; is some script of your own that invokes
the anomolous behavior your are trying to debug.



</p></div></div>
  </body>
</html>
