<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dev.arie.bovenberg.net/blog/python-datetime-pitfalls/">Original</a>
    <h1>Python datetime pitfalls, and what libraries are (not) doing about it</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
      <p>Itâ€™s no secret that the Python datetime library has its quirks.
Not only are there probably more than you think;
third-party libraries donâ€™t address most of them!
I created a <a href="https://github.com/ariebovenberg/whenever">new library</a> to explore what a better datetime library could look like.</p>

<p>ğŸ’¬ <a href="https://www.reddit.com/r/Python/comments/1ag6uxc/ten_python_datetime_pitfalls_and_what_libraries/">Discuss this post on Reddit</a></p>


<h2 id="whats-a-pitfall">
  
  
    Whatâ€™s a pitfall? <a href="#whats-a-pitfall">#</a>
  
  
</h2>
    

<p>Two notes before we start:</p>

<ul>
  <li>Pitfalls arenâ€™t bugs. Theyâ€™re cases where <code>datetime</code> behaves in a way
that is surprising or confusing. Itâ€™s always a bit
subjective whether something is a pitfall or not.</li>
  <li>Many pitfalls exist simply because the authors couldnâ€™t
possibly anticipate all future needs.
Adding big features over 20 yearsâ€”without breaking compatibilityâ€”isnâ€™t easy.</li>
</ul>
<h2 id="libraries-considered">
  
  
    Libraries considered <a href="#libraries-considered">#</a>
  
  
</h2>
    

<p>With that out of the way, these are the third-party datetime
libraries Iâ€™m looking at in this post:</p>

<ul>
  <li><a href="https://github.com/arrow-py/arrow"><code>arrow</code></a> â€” Probably the most historically popular
datetime library. Its goal is to make datetime easier to use,
and to add features that many people feel are missing from the standard library.</li>
  <li><a href="https://github.com/sdispater/pendulum"><code>pendulum</code></a> â€” The only library that
rivals arrow in popularity. It has similar goals, while explicitly improving
on Arrowâ€™s handling of Daylight Saving Time (DST).</li>
  <li><a href="https://github.com/glyph/DateType"><code>DateType</code></a> â€” a library that allows
type-checkers to distinguish between naÃ¯ve and aware datetimes.
It doesnâ€™t change the runtime behavior of <code>datetime</code>.</li>
  <li><a href="https://github.com/channable/heliclockter"><code>heliclockter</code></a> â€” a young library
that offers datetime subclasses for UTC, local, and zoned datetimes.</li>
</ul>

<p>These libraries Iâ€™m <em>not</em> looking at:</p>

<ul>
  <li><code>pytz</code> and <code>python-dateutil</code>, which arenâ€™t (full) datetime replacements</li>
  <li><code>delorean</code>, <code>maya</code>, and <code>moment</code> which all appear abandoned</li>
</ul>

<p>Now: on to the pitfalls!</p>
<h2 id="1-incompatible-concepts-are-squeezed-into-one-class">
  
  
    1. Incompatible concepts are squeezed into one class <a href="#1-incompatible-concepts-are-squeezed-into-one-class">#</a>
  
  
</h2>
    

<p>Itâ€™s an infamous pain point that a <code>datetime</code> instance can be either naÃ¯ve or aware,
and that they canâ€™t be mixed.
In any complex codebase, itâ€™s difficult to be sure you wonâ€™t accidentally mix them
without actually running the code.
As a result, you end up writing redundant runtime checks,
or hoping all developers diligently read the docstrings.</p>

<div><div><pre><code><span># ğŸ§¨ naÃ¯ve or aware? No way to tell...
</span><span>def</span> <span>plan_mission</span><span>(</span><span>launch_utc</span><span>:</span> <span>datetime</span><span>)</span> <span>-&gt;</span> <span>None</span><span>:</span> <span>...</span>
</code></pre></div></div>

<p>Thereâ€™s also the question whether distinguishing aware and naÃ¯ve is enough,
since within the â€œawareâ€ category there are actually several different kinds
of datetimes.
While compatible,
the semantics of UTC/offset and IANA timezones are notably different when
it comes to ambiguity, for example.</p>
<h4 id="whats-being-done-about-it">
  
  
    Whatâ€™s being done about it?
  
  
</h4>
    

<ul>
  <li>âœ… <code>heliclockter</code> has separate classes for local, zoned, and UTC datetimes.</li>
  <li>âœ… <code>DateType</code> allows type-checkers to distinguish naÃ¯ve or aware datetimes</li>
  <li>âŒ <code>arrow</code> and <code>pendulum</code> still have one class for naÃ¯ve and aware.</li>
</ul>
<h2 id="2-operators-ignore-daylight-saving-time-dst">
  
  
    2. Operators ignore Daylight Saving Time (DST) <a href="#2-operators-ignore-daylight-saving-time-dst">#</a>
  
  
</h2>
    

<p>Given that <code>datetime</code> supports timezones with DST transitions,
youâ€™d reasonably expect that the <code>+/-</code> operators would take
them into accountâ€”but they donâ€™t!</p>

<div><div><pre><code><span>paris</span> <span>=</span> <span>ZoneInfo</span><span>(</span><span>&#34;Europe/Paris&#34;</span><span>)</span>
<span># On the eve of moving the clock forward
</span><span>bedtime</span> <span>=</span> <span>datetime</span><span>(</span><span>2023</span><span>,</span> <span>3</span><span>,</span> <span>25</span><span>,</span> <span>22</span><span>,</span> <span>tzinfo</span><span>=</span><span>paris</span><span>)</span>
<span>wake_up</span> <span>=</span> <span>datetime</span><span>(</span><span>2023</span><span>,</span> <span>3</span><span>,</span> <span>26</span><span>,</span> <span>7</span><span>,</span> <span>tzinfo</span><span>=</span><span>paris</span><span>)</span>

<span># It says 9 hours, but it&#39;s actually 8!
# (because we skipped directly from 2am to 3am due to DST)
</span><span>sleep</span> <span>=</span> <span>wake_up</span> <span>-</span> <span>bedtime</span>
</code></pre></div></div>
<h4 id="whats-being-done-about-it-1">
  
  
    Whatâ€™s being done about it?
  
  
</h4>
    

<ul>
  <li>âœ… <code>pendulum</code> explicitly fixes this issue</li>
  <li>âŒ <code>heliclockter</code>, <code>arrow</code>, and <code>DateType</code> donâ€™t address it</li>
</ul>
<h2 id="3-the-meaning-of-naÃ¯ve-is-inconsistent">
  
  
    3. The meaning of â€œnaÃ¯veâ€ is inconsistent <a href="#3-the-meaning-of-naÃ¯ve-is-inconsistent">#</a>
  
  
</h2>
    

<p>In various parts of the standard library, â€œnaÃ¯veâ€ datetimes are interpreted
differently. Ostensibly, â€œnaÃ¯veâ€ means â€œdetached from the real worldâ€,
but in the datetime library it is often implicitly treated as local time.
Confusingly, it is sometimes treated as UTC<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" rel="footnote">1</a></sup>, while in other places it is
treated as neither!</p>

<div><div><pre><code><span># a naÃ¯ve datetime
</span><span>d</span> <span>=</span> <span>datetime</span><span>(</span><span>2024</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>)</span>

<span># âš ï¸ here: treated as a local time
</span><span>d</span><span>.</span><span>timestamp</span><span>()</span>
<span>d</span><span>.</span><span>astimezone</span><span>(</span><span>UTC</span><span>)</span>

<span># ğŸ§¨ here: assumed UTC
</span><span>d</span><span>.</span><span>utctimetuple</span><span>()</span>
<span>email</span><span>.</span><span>utils</span><span>.</span><span>format_datetime</span><span>(</span><span>d</span><span>)</span>
<span>datetime</span><span>.</span><span>utcnow</span><span>()</span>

<span># ğŸ¤· here: neither! (error)
</span><span>d</span> <span>&gt;=</span> <span>datetime</span><span>.</span><span>now</span><span>(</span><span>UTC</span><span>)</span>
</code></pre></div></div>
<h4 id="whats-being-done-about-it-2">
  
  
    Whatâ€™s being done about it?
  
  
</h4>
    

<ul>
  <li>âŒ While <code>pendulum</code> and <code>arrow</code> do discourage using naÃ¯ve datetimes,
they still support the same inconsistent semantics.</li>
  <li>âŒ <code>DateType</code> and <code>heliclockter</code> donâ€™t address this</li>
</ul>
<h2 id="4-non-existent-datetimes-pass-silently">
  
  
    4. Non-existent datetimes pass silently <a href="#4-non-existent-datetimes-pass-silently">#</a>
  
  
</h2>
    

<p>When the clock in a timezone is set forward, a â€œgapâ€ is created. For example,
if DST moves the clock forward from 2am to 3am, the time 2:30am is skipped.
The standard library doesnâ€™t warn you when you create such a non-existent time.
As soon as you operate on these objects, you run into problems.</p>

<div><div><pre><code><span># âš ï¸ This time doesn&#39;t exist on this date
</span><span>d</span> <span>=</span> <span>datetime</span><span>(</span><span>2023</span><span>,</span> <span>3</span><span>,</span> <span>26</span><span>,</span> <span>2</span><span>,</span> <span>30</span><span>,</span> <span>tzinfo</span><span>=</span><span>paris</span><span>)</span>

<span># ğŸ§¨ No timestamp exists, so it just makes one up
</span><span>t</span> <span>=</span> <span>d</span><span>.</span><span>timestamp</span><span>()</span>
<span>datetime</span><span>.</span><span>fromtimestamp</span><span>(</span><span>t</span><span>)</span> <span>==</span> <span>d</span>  <span># False ğŸ¤·
</span></code></pre></div></div>
<h4 id="whats-being-done-about-it-3">
  
  
    Whatâ€™s being done about it?
  
  
</h4>
    

<ul>
  <li>âŒ <code>pendulum</code> replaces the current silent behavior with another: it
fast-forwards to a valid time <a href="https://github.com/sdispater/pendulum/issues/697">without warning</a>.</li>
  <li>âŒ <code>arrow</code>, <code>DateType</code> and <code>heliclockter</code> donâ€™t address this issue</li>
</ul>
<h2 id="5-guessing-in-the-face-of-ambiguity">
  
  
    5. Guessing in the face of ambiguity <a href="#5-guessing-in-the-face-of-ambiguity">#</a>
  
  
</h2>
    

<p>When the clock in a timezone is set backwards, an ambiguity is created.
For example, if DST sets the clock one hour back at 3am, the time 2:30am exists
twice: before and <em>after</em> the change.
The <code>fold</code> attribute <a href="https://peps.python.org/pep-0495/">was introduced</a>
to resolve these ambiguities</p>

<p>The problem is that there is no objective default value for <code>fold</code>:
whether you want the â€œearlierâ€ or â€œlaterâ€
option will depend on the particular context.
For backwards compatibility, the standard library defaults to <code>0</code>,
which has the effect of silently assuming that you want the earlier occurrence<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" rel="footnote">2</a></sup>.</p>

<div><div><pre><code><span># ğŸ§¨ Guesses your intent without warning
</span><span>d</span> <span>=</span> <span>datetime</span><span>(</span><span>2023</span><span>,</span> <span>10</span><span>,</span> <span>29</span><span>,</span> <span>2</span><span>,</span> <span>30</span><span>,</span> <span>tzinfo</span><span>=</span><span>paris</span><span>)</span>
</code></pre></div></div>
<h4 id="whats-being-done-about-it-4">
  
  
    Whatâ€™s being done about it?
  
  
</h4>
    

<ul>
  <li>âŒ <code>pendulum</code> also guesses, but rather arbitrarily decides that <code>1</code>
is the better default<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" rel="footnote">3</a></sup>.</li>
  <li>âŒ <code>arrow</code>, <code>DateType</code> and <code>heliclockter</code> donâ€™t address the issue.</li>
</ul>
<h2 id="6-disambiguation-breaks-equality">
  
  
    6. Disambiguation breaks equality <a href="#6-disambiguation-breaks-equality">#</a>
  
  
</h2>
    

<p>Even though <code>fold</code> was introduced to disambiguate times,
comparisons of disambiguated times between timezones <em>always</em> evaluate false due to
<a href="https://peps.python.org/pep-0495/#id12">backwards compatibility reasons</a>.</p>

<div><div><pre><code><span># A properly disambiguated time...
</span><span>d</span> <span>=</span> <span>datetime</span><span>(</span><span>2023</span><span>,</span> <span>10</span><span>,</span> <span>29</span><span>,</span> <span>2</span><span>,</span> <span>30</span><span>,</span> <span>tzinfo</span><span>=</span><span>paris</span><span>,</span> <span>fold</span><span>=</span><span>1</span><span>)</span>

<span>d_utc</span> <span>=</span> <span>d</span><span>.</span><span>astimezone</span><span>(</span><span>UTC</span><span>)</span>
<span>d_utc</span><span>.</span><span>timestamp</span><span>()</span> <span>==</span> <span>d</span><span>.</span><span>timestamp</span><span>()</span>  <span># True: same moment in time
</span><span>d_utc</span> <span>==</span> <span>d</span>  <span># ğŸ§¨ but oddly: False!
</span></code></pre></div></div>
<h4 id="whats-being-done-about-it-5">
  
  
    Whatâ€™s being done about it?
  
  
</h4>
    

<ul>
  <li>âŒ None of the libraries addresses this issue</li>
</ul>
<h2 id="7-inconsistent-equality-within-timezone">
  
  
    7. Inconsistent equality within timezone <a href="#7-inconsistent-equality-within-timezone">#</a>
  
  
</h2>
    

<p>In a mirror image of the previous pitfall, there is a false positive
when comparing two datetimes with the exact same <code>tzinfo</code> object.
In that case, they are compared by their â€œwall timeâ€.
This is mostly the same <em>except</em> when <code>fold</code> is involvedâ€¦</p>

<div><div><pre><code><span># two times one hour apart (due to DST transition)
</span><span>earlier</span> <span>=</span> <span>datetime</span><span>(</span><span>2023</span><span>,</span> <span>10</span><span>,</span> <span>29</span><span>,</span> <span>2</span><span>,</span> <span>30</span><span>,</span> <span>tzinfo</span><span>=</span><span>paris</span><span>,</span> <span>fold</span><span>=</span><span>0</span><span>)</span>
<span>later</span> <span>=</span> <span>datetime</span><span>(</span><span>2023</span><span>,</span> <span>10</span><span>,</span> <span>29</span><span>,</span> <span>2</span><span>,</span> <span>30</span><span>,</span> <span>tzinfo</span><span>=</span><span>paris</span><span>,</span> <span>fold</span><span>=</span><span>1</span><span>)</span>

<span>earlier</span><span>.</span><span>timestamp</span><span>()</span> <span>==</span> <span>later</span><span>.</span><span>timestamp</span><span>()</span>  <span># false, as expected
</span><span>earlier</span> <span>==</span> <span>later</span>  <span># ğŸ§¨ oddly: true!
</span></code></pre></div></div>

<p>Remember I said <em>exact same</em> <code>tzinfo</code> object? If you
compare with the same timezone, but you get its object from <code>dateutil.tz</code>
instead of <code>ZoneInfo</code>, youâ€™ll get a different result!</p>

<div><div><pre><code><span>from</span> <span>dateutil</span> <span>import</span> <span>tz</span>
<span>later2</span> <span>=</span> <span>later</span><span>.</span><span>replace</span><span>(</span><span>tzinfo</span><span>=</span><span>tz</span><span>.</span><span>gettz</span><span>(</span><span>&#34;Europe/Paris&#34;</span><span>))</span>
<span>earlier</span> <span>==</span> <span>later2</span>  <span># now false
</span></code></pre></div></div>
<h4 id="whats-being-done-about-it-6">
  
  
    Whatâ€™s being done about it?
  
  
</h4>
    

<ul>
  <li>âŒ None of the libraries addresses this issue</li>
</ul>
<h2 id="8-datetime-inherits-from-date">
  
  
    8. Datetime inherits from date <a href="#8-datetime-inherits-from-date">#</a>
  
  
</h2>
    

<p>You may be surprised to know that <code>datetime</code> is a subclass of <code>date</code>.
This doesnâ€™t seem problematic at first, but it leads to odd behavior.
Most notably, the fact that <code>date</code> and <code>datetime</code> cannot be compared
violates <a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle">basic assumptions</a>
of how subclasses should work.
The <code>datetime/date</code> inheritance is now
<a href="https://discuss.python.org/t/renaming-datetime-datetime-to-datetime-datetime/26279/2">widely considered</a>
to be a <a href="https://github.com/python/typeshed/issues/4802">design flaw</a>
in the standard library.</p>

<div><div><pre><code><span># ğŸ§¨ Breaks on a datetime, even though it&#39;s a subclass
</span><span>def</span> <span>is_future</span><span>(</span><span>d</span><span>:</span> <span>date</span><span>)</span> <span>-&gt;</span> <span>bool</span><span>:</span>
    <span>return</span> <span>d</span> <span>&gt;</span> <span>date</span><span>.</span><span>today</span><span>()</span>

<span># ğŸ§¨ Some methods inherited from `date` don&#39;t make sense
</span><span>datetime</span><span>.</span><span>today</span><span>()</span>  <span># fun exercise: what does this return?
</span></code></pre></div></div>
<h4 id="whats-being-done-about-it-7">
  
  
    Whatâ€™s being done about it?
  
  
</h4>
    

<ul>
  <li>âœ… <code>DateType</code> was explicitly developed to fix this inheritance relationship
at type-checking time.</li>
  <li>âŒ <code>arrow</code>, <code>pendulum</code>, and <code>heliclockter</code> donâ€™t address the issue.
Their datetime classes all inherit from <code>datetime</code> (and thus also <code>date</code>).</li>
</ul>
<h2 id="9-datetimetimezone-isnt-enough-for-timezone-support">
  
  
    9. <code>datetime.timezone</code> isnâ€™t enough for timezone support <a href="#9-datetimetimezone-isnt-enough-for-timezone-support">#</a>
  
  
</h2>
    

<p>OKâ€”so this is maybe something you learn once and then never forget.
But itâ€™s still confusing that <code>datetime.timezone</code> is only for fixed offsets,
and you need <code>ZoneInfo</code> to express real-world timezone behavior with DST transitions.
For beginners that donâ€™t know the difference, this is an unfortunate trap.</p>

<div><div><pre><code><span>from</span> <span>datetime</span> <span>import</span> <span>timezone</span><span>,</span> <span>datetime</span><span>,</span> <span>timedelta</span>
<span>from</span> <span>zoneinfo</span> <span>import</span> <span>ZoneInfo</span>

<span># ğŸ§¨ Wrong: it&#39;s a fixed offset only valid in winter!
</span><span>paris_tz</span> <span>=</span> <span>timezone</span><span>(</span><span>timedelta</span><span>(</span><span>hours</span><span>=</span><span>1</span><span>),</span> <span>&#34;CET&#34;</span><span>)</span>

<span># âœ… This is what you want
</span><span>paris_tz</span> <span>=</span> <span>ZoneInfo</span><span>(</span><span>&#34;Europe/Paris&#34;</span><span>)</span>
</code></pre></div></div>

<ul>
  <li>âœ… Both <code>arrow</code> and <code>pendulum</code> side-step this issue by specifying
timezones as strings instead of requiring special class instance.</li>
  <li>âŒ <code>heliclockter</code> and <code>DateType</code> donâ€™t address this issue</li>
</ul>
<h2 id="10-the-local-timezone-is-dst-unaware">
  
  
    10. The local timezone is DST-unaware <a href="#10-the-local-timezone-is-dst-unaware">#</a>
  
  
</h2>
    

<p>Calling <code>astimezone()</code> without arguments gives you the time in the local system
timezone. However, it returns it as a fixed offset (<code>datetime.timezone</code>) instead of a
full timezone (<code>ZoneInfo</code>) that knows about DST transitions.
In Paris, for example, <code>astimezone()</code> returns a fixed offset of UTC+1
or UTC+2 (depending on whether itâ€™s winter or summer) instead
of the full <code>Europe/Paris</code> timezone.</p>

<div><div><pre><code><span># you think you&#39;ve got the local timezone
</span><span>my_tz</span> <span>=</span> <span>datetime</span><span>(</span><span>2023</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>).</span><span>astimezone</span><span>().</span><span>tzinfo</span>
<span># but you actually only have the wintertime variant
</span><span>print</span><span>(</span><span>my_tz</span><span>)</span>  <span># timezone(offset=timedelta(hours=1), &#34;CET&#34;)
</span><span>datetime</span><span>(</span><span>2023</span><span>,</span> <span>7</span><span>,</span> <span>1</span><span>,</span> <span>tzinfo</span><span>=</span><span>my_tz</span><span>)</span>  <span># ğŸ§¨ not valid for summer!
</span></code></pre></div></div>
<h4 id="whats-being-done-about-it-8">
  
  
    Whatâ€™s being done about it?
  
  
</h4>
    

<ul>
  <li>âœ… <code>pendulum</code> and <code>arrow</code> have methods to convert to the full local timezone.</li>
  <li>âŒ <code>heliclockter</code> has a local datetime type with the same issue,
although a fix is in the works.</li>
  <li>âŒ <code>DateType</code> doesnâ€™t address this issue</li>
</ul>
<h2 id="datetime-library-scorecard">
  
  
    Datetime library scorecard <a href="#datetime-library-scorecard">#</a>
  
  
</h2>
    

<p>Below is a summary of how the libraries address the pitfalls (âœ…) or not (âŒ).</p>

<table>
  <thead>
    <tr>
      <th>Pitfall</th>
      <th>Arrow</th>
      <th>Pendulum</th>
      <th>DateType</th>
      <th>Heliclockter</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>aware/naÃ¯ve in one class</td>
      <td>âŒ</td>
      <td>âŒ</td>
      <td>âœ…</td>
      <td>âœ…</td>
    </tr>
    <tr>
      <td>Operators ignore DST</td>
      <td>âŒ</td>
      <td>âœ…</td>
      <td>âŒ</td>
      <td>âŒ</td>
    </tr>
    <tr>
      <td>Unclear â€œnaÃ¯veâ€ semantics</td>
      <td>âŒ</td>
      <td>âŒ</td>
      <td>âŒ</td>
      <td>âŒ</td>
    </tr>
    <tr>
      <td>Silent non-existence</td>
      <td>âŒ</td>
      <td>âŒ</td>
      <td>âŒ</td>
      <td>âŒ</td>
    </tr>
    <tr>
      <td>Guesses on ambiguity</td>
      <td>âŒ</td>
      <td>âŒ</td>
      <td>âŒ</td>
      <td>âŒ</td>
    </tr>
    <tr>
      <td>Disambiguation breaks equality</td>
      <td>âŒ</td>
      <td>âŒ</td>
      <td>âŒ</td>
      <td>âŒ</td>
    </tr>
    <tr>
      <td>Inconsistent equality within zone</td>
      <td>âŒ</td>
      <td>âŒ</td>
      <td>âŒ</td>
      <td>âŒ</td>
    </tr>
    <tr>
      <td>datetime inherits from date</td>
      <td>âŒ</td>
      <td>âŒ</td>
      <td>âœ…</td>
      <td>âŒ</td>
    </tr>
    <tr>
      <td><code>timezone</code> isnâ€™t enough for timezone support</td>
      <td>âœ…</td>
      <td>âœ…</td>
      <td>âŒ</td>
      <td>âŒ</td>
    </tr>
    <tr>
      <td>DST-unaware local timezone</td>
      <td>âœ…</td>
      <td>âœ…</td>
      <td>âŒ</td>
      <td>âŒ</td>
    </tr>
  </tbody>
</table>
<h2 id="why-should-you-care">
  
  
    Why should you care? <a href="#why-should-you-care">#</a>
  
  
</h2>
    

<p>The pitfalls roughly fall into two categories:
<em>confusing design</em> and <em>surprising edge cases</em>.
Here is why you should care about both.</p>
<h3 id="confusing-design">
  
  
    Confusing design
  
  
</h3>
    

<p>Confusing design is the larger problem,
because it amplifies the biggest source of bugs: human error.
While good design helps minimize the chance of mistakes,
bad design introduces more opportunities for them.
Looking at other languages, itâ€™s clear that better designs are possible.
Java, C#, and Rust all have distinct classes for naÃ¯ve and aware datetimes (and more).
We can also see that redesigns are worth the substantial effort:
Java <a href="https://jcp.org/en/jsr/detail?id=310">adopted Joda-Time</a>,
and JavaScript is <a href="https://tc39.es/proposal-temporal/docs/">modernizing as well</a>.
Will Pythonâ€™s datetime be left behind?</p>
<h3 id="surprising-edge-cases">
  
  
    Surprising edge cases
  
  
</h3>
    

<p>Because these pitfalls are rare, you may think theyâ€™re not worth worrying about.
After all, DST transitions only represent about 0.02% of the year.
While this sentiment is understandable, Iâ€™d argue that the opposite is true:</p>

<ul>
  <li>Getting timezones right is one of the main <em>reasons for existence</em> of
a datetime library. If it canâ€™t do that reliably, whatâ€™s the point?</li>
  <li>Rare cases are the most dangerous: they are the ones youâ€™re least likely to test,
and allow bad actors to trip up your code.</li>
  <li>Rare is still too common for such a fundamental concept as time.
Would you run your business on <code>numpy</code> if it had a
0.02% chance of returning the wrong result?
Would you accept a language in which 1 in 4000 booleans would arbitrarily be flipped?
There is no reason why these pitfalls shouldnâ€™t be corrected.</li>
</ul>
<h2 id="imagining-a-solution">
  
  
    Imagining a solution <a href="#imagining-a-solution">#</a>
  
  
</h2>
    

<p>Inspired by these findings, I created a
<a href="https://github.com/ariebovenberg/whenever">new library</a> to explore
what a better datetime library could look like.
Here is how it addresses the pitfalls:</p>

<ol>
  <li>
    <p>It has distinct classes for the most common use cases:</p>

    <div><div><pre><code><span>from</span> <span>whenever</span> <span>import</span> <span>(</span>
    <span># For the &#34;UTC everywhere&#34; case
</span>    <span>UTCDateTime</span><span>,</span>
    <span># Simple localization sans DST
</span>    <span>OffsetDateTime</span><span>,</span>
    <span># Full-featured IANA timezones
</span>    <span>ZonedDateTime</span><span>,</span>
    <span># The local system timezone
</span>    <span>LocalDateTime</span><span>,</span>
    <span># Detached from any timezones
</span>    <span>NaiveDateTime</span><span>,</span>
<span>)</span>
</code></pre></div>    </div>
  </li>
  <li>Addition and subtraction take DST into account.</li>
  <li>NaÃ¯ve is always naÃ¯ve. UTC and local time have their own separate classes.</li>
  <li>Creating non-existent datetimes raises an exception.</li>
  <li>
    <p>Ambiguous datetimes must be explicitly disambiguated.</p>

    <div><div><pre><code><span>ZonedDateTime</span><span>(</span>
    <span>2023</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>tz</span><span>=</span><span>&#34;Europe/Paris&#34;</span><span>,</span>
<span>)</span>  <span># ok: not ambiguous
</span><span>ZonedDateTime</span><span>(</span>
    <span>2023</span><span>,</span> <span>10</span><span>,</span> <span>29</span><span>,</span> <span>2</span><span>,</span> <span>tz</span><span>=</span><span>&#34;Europe/Paris&#34;</span><span>,</span>
<span>)</span>  <span># ERROR: ambiguous!
</span><span>ZonedDateTime</span><span>(</span>
    <span>2023</span><span>,</span> <span>10</span><span>,</span> <span>29</span><span>,</span> <span>2</span><span>,</span> <span>tz</span><span>=</span><span>&#34;Europe/Paris&#34;</span><span>,</span>
    <span>disambiguate</span><span>=</span><span>&#34;later&#34;</span>
<span>)</span>  <span># that&#39;s better!
</span></code></pre></div>    </div>
  </li>
  <li>Disambiguated datetimes work correctly in comparisons.</li>
  <li>
    <p>Aware datetimes are equal if they occur at the same moment. No exceptions.</p>

    <div><div><pre><code><span>a</span> <span>==</span> <span>b</span>
<span># always equivalent to:
</span><span>a</span><span>.</span><span>as_utc</span><span>()</span> <span>==</span> <span>b</span><span>.</span><span>as_utc</span><span>()</span>
</code></pre></div>    </div>
  </li>
  <li>The datetime classes donâ€™t inherit from date.</li>
  <li>IANA timezones are used everywhere, no separate classes are needed.</li>
  <li>Local datetimes handle DST transitions correctly.</li>
</ol>

<p>Feedback is welcome! â­ï¸</p>
<h2 id="changelog">
  
  
    Changelog <a href="#changelog">#</a>
  
  
</h2>
    

<p>See the <a href="https://github.com/ariebovenberg/ariebovenberg.github.io/commits/main/_posts/2024-01-20-python-datetime-pitfalls.md">git history</a>
for exact changes to this article since initial publication.</p>
<h3 id="2024-02-01-1814000100">
  
  
    2024-02-01 18:14:00+01:00
  
  
</h3>
    

<ul>
  <li>Clarified wording and code comments in pitfall #3.</li>
</ul>
<h3 id="2024-02-02-1013000100">
  
  
    2024-02-02 10:13:00+01:00
  
  
</h3>
    

<ul>
  <li>Clarified wording around timezones and IANA tz database in pitfall #9,
and throughout the article.</li>
  <li>Added reddit link</li>
</ul>
<h3 id="2024-02-13-0840000100">
  
  
    2024-02-13 08:40:00+01:00
  
  
</h3>
    

<ul>
  <li>Clarified wording on distinguishing â€œawareâ€ types in pitfall #1.</li>
  <li>Added note about RFC 5545 in pitfall #5.</li>
</ul>



  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
