<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dev.arie.bovenberg.net/blog/python-datetime-pitfalls/">Original</a>
    <h1>Python datetime pitfalls, and what libraries are (not) doing about it</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
      <p>It’s no secret that the Python datetime library has its quirks.
Not only are there probably more than you think;
third-party libraries don’t address most of them!
I created a <a href="https://github.com/ariebovenberg/whenever">new library</a> to explore what a better datetime library could look like.</p>

<p>💬 <a href="https://www.reddit.com/r/Python/comments/1ag6uxc/ten_python_datetime_pitfalls_and_what_libraries/">Discuss this post on Reddit</a></p>


<h2 id="whats-a-pitfall">
  
  
    What’s a pitfall? <a href="#whats-a-pitfall">#</a>
  
  
</h2>
    

<p>Two notes before we start:</p>

<ul>
  <li>Pitfalls aren’t bugs. They’re cases where <code>datetime</code> behaves in a way
that is surprising or confusing. It’s always a bit
subjective whether something is a pitfall or not.</li>
  <li>Many pitfalls exist simply because the authors couldn’t
possibly anticipate all future needs.
Adding big features over 20 years—without breaking compatibility—isn’t easy.</li>
</ul>
<h2 id="libraries-considered">
  
  
    Libraries considered <a href="#libraries-considered">#</a>
  
  
</h2>
    

<p>With that out of the way, these are the third-party datetime
libraries I’m looking at in this post:</p>

<ul>
  <li><a href="https://github.com/arrow-py/arrow"><code>arrow</code></a> — Probably the most historically popular
datetime library. Its goal is to make datetime easier to use,
and to add features that many people feel are missing from the standard library.</li>
  <li><a href="https://github.com/sdispater/pendulum"><code>pendulum</code></a> — The only library that
rivals arrow in popularity. It has similar goals, while explicitly improving
on Arrow’s handling of Daylight Saving Time (DST).</li>
  <li><a href="https://github.com/glyph/DateType"><code>DateType</code></a> — a library that allows
type-checkers to distinguish between naïve and aware datetimes.
It doesn’t change the runtime behavior of <code>datetime</code>.</li>
  <li><a href="https://github.com/channable/heliclockter"><code>heliclockter</code></a> — a young library
that offers datetime subclasses for UTC, local, and zoned datetimes.</li>
</ul>

<p>These libraries I’m <em>not</em> looking at:</p>

<ul>
  <li><code>pytz</code> and <code>python-dateutil</code>, which aren’t (full) datetime replacements</li>
  <li><code>delorean</code>, <code>maya</code>, and <code>moment</code> which all appear abandoned</li>
</ul>

<p>Now: on to the pitfalls!</p>
<h2 id="1-incompatible-concepts-are-squeezed-into-one-class">
  
  
    1. Incompatible concepts are squeezed into one class <a href="#1-incompatible-concepts-are-squeezed-into-one-class">#</a>
  
  
</h2>
    

<p>It’s an infamous pain point that a <code>datetime</code> instance can be either naïve or aware,
and that they can’t be mixed.
In any complex codebase, it’s difficult to be sure you won’t accidentally mix them
without actually running the code.
As a result, you end up writing redundant runtime checks,
or hoping all developers diligently read the docstrings.</p>

<div><div><pre><code><span># 🧨 naïve or aware? No way to tell...
</span><span>def</span> <span>plan_mission</span><span>(</span><span>launch_utc</span><span>:</span> <span>datetime</span><span>)</span> <span>-&gt;</span> <span>None</span><span>:</span> <span>...</span>
</code></pre></div></div>

<p>There’s also the question whether distinguishing aware and naïve is enough,
since within the “aware” category there are actually several different kinds
of datetimes.
While compatible,
the semantics of UTC/offset and IANA timezones are notably different when
it comes to ambiguity, for example.</p>
<h4 id="whats-being-done-about-it">
  
  
    What’s being done about it?
  
  
</h4>
    

<ul>
  <li>✅ <code>heliclockter</code> has separate classes for local, zoned, and UTC datetimes.</li>
  <li>✅ <code>DateType</code> allows type-checkers to distinguish naïve or aware datetimes</li>
  <li>❌ <code>arrow</code> and <code>pendulum</code> still have one class for naïve and aware.</li>
</ul>
<h2 id="2-operators-ignore-daylight-saving-time-dst">
  
  
    2. Operators ignore Daylight Saving Time (DST) <a href="#2-operators-ignore-daylight-saving-time-dst">#</a>
  
  
</h2>
    

<p>Given that <code>datetime</code> supports timezones with DST transitions,
you’d reasonably expect that the <code>+/-</code> operators would take
them into account—but they don’t!</p>

<div><div><pre><code><span>paris</span> <span>=</span> <span>ZoneInfo</span><span>(</span><span>&#34;Europe/Paris&#34;</span><span>)</span>
<span># On the eve of moving the clock forward
</span><span>bedtime</span> <span>=</span> <span>datetime</span><span>(</span><span>2023</span><span>,</span> <span>3</span><span>,</span> <span>25</span><span>,</span> <span>22</span><span>,</span> <span>tzinfo</span><span>=</span><span>paris</span><span>)</span>
<span>wake_up</span> <span>=</span> <span>datetime</span><span>(</span><span>2023</span><span>,</span> <span>3</span><span>,</span> <span>26</span><span>,</span> <span>7</span><span>,</span> <span>tzinfo</span><span>=</span><span>paris</span><span>)</span>

<span># It says 9 hours, but it&#39;s actually 8!
# (because we skipped directly from 2am to 3am due to DST)
</span><span>sleep</span> <span>=</span> <span>wake_up</span> <span>-</span> <span>bedtime</span>
</code></pre></div></div>
<h4 id="whats-being-done-about-it-1">
  
  
    What’s being done about it?
  
  
</h4>
    

<ul>
  <li>✅ <code>pendulum</code> explicitly fixes this issue</li>
  <li>❌ <code>heliclockter</code>, <code>arrow</code>, and <code>DateType</code> don’t address it</li>
</ul>
<h2 id="3-the-meaning-of-naïve-is-inconsistent">
  
  
    3. The meaning of “naïve” is inconsistent <a href="#3-the-meaning-of-naïve-is-inconsistent">#</a>
  
  
</h2>
    

<p>In various parts of the standard library, “naïve” datetimes are interpreted
differently. Ostensibly, “naïve” means “detached from the real world”,
but in the datetime library it is often implicitly treated as local time.
Confusingly, it is sometimes treated as UTC<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" rel="footnote">1</a></sup>, while in other places it is
treated as neither!</p>

<div><div><pre><code><span># a naïve datetime
</span><span>d</span> <span>=</span> <span>datetime</span><span>(</span><span>2024</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>)</span>

<span># ⚠️ here: treated as a local time
</span><span>d</span><span>.</span><span>timestamp</span><span>()</span>
<span>d</span><span>.</span><span>astimezone</span><span>(</span><span>UTC</span><span>)</span>

<span># 🧨 here: assumed UTC
</span><span>d</span><span>.</span><span>utctimetuple</span><span>()</span>
<span>email</span><span>.</span><span>utils</span><span>.</span><span>format_datetime</span><span>(</span><span>d</span><span>)</span>
<span>datetime</span><span>.</span><span>utcnow</span><span>()</span>

<span># 🤷 here: neither! (error)
</span><span>d</span> <span>&gt;=</span> <span>datetime</span><span>.</span><span>now</span><span>(</span><span>UTC</span><span>)</span>
</code></pre></div></div>
<h4 id="whats-being-done-about-it-2">
  
  
    What’s being done about it?
  
  
</h4>
    

<ul>
  <li>❌ While <code>pendulum</code> and <code>arrow</code> do discourage using naïve datetimes,
they still support the same inconsistent semantics.</li>
  <li>❌ <code>DateType</code> and <code>heliclockter</code> don’t address this</li>
</ul>
<h2 id="4-non-existent-datetimes-pass-silently">
  
  
    4. Non-existent datetimes pass silently <a href="#4-non-existent-datetimes-pass-silently">#</a>
  
  
</h2>
    

<p>When the clock in a timezone is set forward, a “gap” is created. For example,
if DST moves the clock forward from 2am to 3am, the time 2:30am is skipped.
The standard library doesn’t warn you when you create such a non-existent time.
As soon as you operate on these objects, you run into problems.</p>

<div><div><pre><code><span># ⚠️ This time doesn&#39;t exist on this date
</span><span>d</span> <span>=</span> <span>datetime</span><span>(</span><span>2023</span><span>,</span> <span>3</span><span>,</span> <span>26</span><span>,</span> <span>2</span><span>,</span> <span>30</span><span>,</span> <span>tzinfo</span><span>=</span><span>paris</span><span>)</span>

<span># 🧨 No timestamp exists, so it just makes one up
</span><span>t</span> <span>=</span> <span>d</span><span>.</span><span>timestamp</span><span>()</span>
<span>datetime</span><span>.</span><span>fromtimestamp</span><span>(</span><span>t</span><span>)</span> <span>==</span> <span>d</span>  <span># False 🤷
</span></code></pre></div></div>
<h4 id="whats-being-done-about-it-3">
  
  
    What’s being done about it?
  
  
</h4>
    

<ul>
  <li>❌ <code>pendulum</code> replaces the current silent behavior with another: it
fast-forwards to a valid time <a href="https://github.com/sdispater/pendulum/issues/697">without warning</a>.</li>
  <li>❌ <code>arrow</code>, <code>DateType</code> and <code>heliclockter</code> don’t address this issue</li>
</ul>
<h2 id="5-guessing-in-the-face-of-ambiguity">
  
  
    5. Guessing in the face of ambiguity <a href="#5-guessing-in-the-face-of-ambiguity">#</a>
  
  
</h2>
    

<p>When the clock in a timezone is set backwards, an ambiguity is created.
For example, if DST sets the clock one hour back at 3am, the time 2:30am exists
twice: before and <em>after</em> the change.
The <code>fold</code> attribute <a href="https://peps.python.org/pep-0495/">was introduced</a>
to resolve these ambiguities</p>

<p>The problem is that there is no objective default value for <code>fold</code>:
whether you want the “earlier” or “later”
option will depend on the particular context.
For backwards compatibility, the standard library defaults to <code>0</code>,
which has the effect of silently assuming that you want the earlier occurrence<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" rel="footnote">2</a></sup>.</p>

<div><div><pre><code><span># 🧨 Guesses your intent without warning
</span><span>d</span> <span>=</span> <span>datetime</span><span>(</span><span>2023</span><span>,</span> <span>10</span><span>,</span> <span>29</span><span>,</span> <span>2</span><span>,</span> <span>30</span><span>,</span> <span>tzinfo</span><span>=</span><span>paris</span><span>)</span>
</code></pre></div></div>
<h4 id="whats-being-done-about-it-4">
  
  
    What’s being done about it?
  
  
</h4>
    

<ul>
  <li>❌ <code>pendulum</code> also guesses, but rather arbitrarily decides that <code>1</code>
is the better default<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" rel="footnote">3</a></sup>.</li>
  <li>❌ <code>arrow</code>, <code>DateType</code> and <code>heliclockter</code> don’t address the issue.</li>
</ul>
<h2 id="6-disambiguation-breaks-equality">
  
  
    6. Disambiguation breaks equality <a href="#6-disambiguation-breaks-equality">#</a>
  
  
</h2>
    

<p>Even though <code>fold</code> was introduced to disambiguate times,
comparisons of disambiguated times between timezones <em>always</em> evaluate false due to
<a href="https://peps.python.org/pep-0495/#id12">backwards compatibility reasons</a>.</p>

<div><div><pre><code><span># A properly disambiguated time...
</span><span>d</span> <span>=</span> <span>datetime</span><span>(</span><span>2023</span><span>,</span> <span>10</span><span>,</span> <span>29</span><span>,</span> <span>2</span><span>,</span> <span>30</span><span>,</span> <span>tzinfo</span><span>=</span><span>paris</span><span>,</span> <span>fold</span><span>=</span><span>1</span><span>)</span>

<span>d_utc</span> <span>=</span> <span>d</span><span>.</span><span>astimezone</span><span>(</span><span>UTC</span><span>)</span>
<span>d_utc</span><span>.</span><span>timestamp</span><span>()</span> <span>==</span> <span>d</span><span>.</span><span>timestamp</span><span>()</span>  <span># True: same moment in time
</span><span>d_utc</span> <span>==</span> <span>d</span>  <span># 🧨 but oddly: False!
</span></code></pre></div></div>
<h4 id="whats-being-done-about-it-5">
  
  
    What’s being done about it?
  
  
</h4>
    

<ul>
  <li>❌ None of the libraries addresses this issue</li>
</ul>
<h2 id="7-inconsistent-equality-within-timezone">
  
  
    7. Inconsistent equality within timezone <a href="#7-inconsistent-equality-within-timezone">#</a>
  
  
</h2>
    

<p>In a mirror image of the previous pitfall, there is a false positive
when comparing two datetimes with the exact same <code>tzinfo</code> object.
In that case, they are compared by their “wall time”.
This is mostly the same <em>except</em> when <code>fold</code> is involved…</p>

<div><div><pre><code><span># two times one hour apart (due to DST transition)
</span><span>earlier</span> <span>=</span> <span>datetime</span><span>(</span><span>2023</span><span>,</span> <span>10</span><span>,</span> <span>29</span><span>,</span> <span>2</span><span>,</span> <span>30</span><span>,</span> <span>tzinfo</span><span>=</span><span>paris</span><span>,</span> <span>fold</span><span>=</span><span>0</span><span>)</span>
<span>later</span> <span>=</span> <span>datetime</span><span>(</span><span>2023</span><span>,</span> <span>10</span><span>,</span> <span>29</span><span>,</span> <span>2</span><span>,</span> <span>30</span><span>,</span> <span>tzinfo</span><span>=</span><span>paris</span><span>,</span> <span>fold</span><span>=</span><span>1</span><span>)</span>

<span>earlier</span><span>.</span><span>timestamp</span><span>()</span> <span>==</span> <span>later</span><span>.</span><span>timestamp</span><span>()</span>  <span># false, as expected
</span><span>earlier</span> <span>==</span> <span>later</span>  <span># 🧨 oddly: true!
</span></code></pre></div></div>

<p>Remember I said <em>exact same</em> <code>tzinfo</code> object? If you
compare with the same timezone, but you get its object from <code>dateutil.tz</code>
instead of <code>ZoneInfo</code>, you’ll get a different result!</p>

<div><div><pre><code><span>from</span> <span>dateutil</span> <span>import</span> <span>tz</span>
<span>later2</span> <span>=</span> <span>later</span><span>.</span><span>replace</span><span>(</span><span>tzinfo</span><span>=</span><span>tz</span><span>.</span><span>gettz</span><span>(</span><span>&#34;Europe/Paris&#34;</span><span>))</span>
<span>earlier</span> <span>==</span> <span>later2</span>  <span># now false
</span></code></pre></div></div>
<h4 id="whats-being-done-about-it-6">
  
  
    What’s being done about it?
  
  
</h4>
    

<ul>
  <li>❌ None of the libraries addresses this issue</li>
</ul>
<h2 id="8-datetime-inherits-from-date">
  
  
    8. Datetime inherits from date <a href="#8-datetime-inherits-from-date">#</a>
  
  
</h2>
    

<p>You may be surprised to know that <code>datetime</code> is a subclass of <code>date</code>.
This doesn’t seem problematic at first, but it leads to odd behavior.
Most notably, the fact that <code>date</code> and <code>datetime</code> cannot be compared
violates <a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle">basic assumptions</a>
of how subclasses should work.
The <code>datetime/date</code> inheritance is now
<a href="https://discuss.python.org/t/renaming-datetime-datetime-to-datetime-datetime/26279/2">widely considered</a>
to be a <a href="https://github.com/python/typeshed/issues/4802">design flaw</a>
in the standard library.</p>

<div><div><pre><code><span># 🧨 Breaks on a datetime, even though it&#39;s a subclass
</span><span>def</span> <span>is_future</span><span>(</span><span>d</span><span>:</span> <span>date</span><span>)</span> <span>-&gt;</span> <span>bool</span><span>:</span>
    <span>return</span> <span>d</span> <span>&gt;</span> <span>date</span><span>.</span><span>today</span><span>()</span>

<span># 🧨 Some methods inherited from `date` don&#39;t make sense
</span><span>datetime</span><span>.</span><span>today</span><span>()</span>  <span># fun exercise: what does this return?
</span></code></pre></div></div>
<h4 id="whats-being-done-about-it-7">
  
  
    What’s being done about it?
  
  
</h4>
    

<ul>
  <li>✅ <code>DateType</code> was explicitly developed to fix this inheritance relationship
at type-checking time.</li>
  <li>❌ <code>arrow</code>, <code>pendulum</code>, and <code>heliclockter</code> don’t address the issue.
Their datetime classes all inherit from <code>datetime</code> (and thus also <code>date</code>).</li>
</ul>
<h2 id="9-datetimetimezone-isnt-enough-for-timezone-support">
  
  
    9. <code>datetime.timezone</code> isn’t enough for timezone support <a href="#9-datetimetimezone-isnt-enough-for-timezone-support">#</a>
  
  
</h2>
    

<p>OK—so this is maybe something you learn once and then never forget.
But it’s still confusing that <code>datetime.timezone</code> is only for fixed offsets,
and you need <code>ZoneInfo</code> to express real-world timezone behavior with DST transitions.
For beginners that don’t know the difference, this is an unfortunate trap.</p>

<div><div><pre><code><span>from</span> <span>datetime</span> <span>import</span> <span>timezone</span><span>,</span> <span>datetime</span><span>,</span> <span>timedelta</span>
<span>from</span> <span>zoneinfo</span> <span>import</span> <span>ZoneInfo</span>

<span># 🧨 Wrong: it&#39;s a fixed offset only valid in winter!
</span><span>paris_tz</span> <span>=</span> <span>timezone</span><span>(</span><span>timedelta</span><span>(</span><span>hours</span><span>=</span><span>1</span><span>),</span> <span>&#34;CET&#34;</span><span>)</span>

<span># ✅ This is what you want
</span><span>paris_tz</span> <span>=</span> <span>ZoneInfo</span><span>(</span><span>&#34;Europe/Paris&#34;</span><span>)</span>
</code></pre></div></div>

<ul>
  <li>✅ Both <code>arrow</code> and <code>pendulum</code> side-step this issue by specifying
timezones as strings instead of requiring special class instance.</li>
  <li>❌ <code>heliclockter</code> and <code>DateType</code> don’t address this issue</li>
</ul>
<h2 id="10-the-local-timezone-is-dst-unaware">
  
  
    10. The local timezone is DST-unaware <a href="#10-the-local-timezone-is-dst-unaware">#</a>
  
  
</h2>
    

<p>Calling <code>astimezone()</code> without arguments gives you the time in the local system
timezone. However, it returns it as a fixed offset (<code>datetime.timezone</code>) instead of a
full timezone (<code>ZoneInfo</code>) that knows about DST transitions.
In Paris, for example, <code>astimezone()</code> returns a fixed offset of UTC+1
or UTC+2 (depending on whether it’s winter or summer) instead
of the full <code>Europe/Paris</code> timezone.</p>

<div><div><pre><code><span># you think you&#39;ve got the local timezone
</span><span>my_tz</span> <span>=</span> <span>datetime</span><span>(</span><span>2023</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>).</span><span>astimezone</span><span>().</span><span>tzinfo</span>
<span># but you actually only have the wintertime variant
</span><span>print</span><span>(</span><span>my_tz</span><span>)</span>  <span># timezone(offset=timedelta(hours=1), &#34;CET&#34;)
</span><span>datetime</span><span>(</span><span>2023</span><span>,</span> <span>7</span><span>,</span> <span>1</span><span>,</span> <span>tzinfo</span><span>=</span><span>my_tz</span><span>)</span>  <span># 🧨 not valid for summer!
</span></code></pre></div></div>
<h4 id="whats-being-done-about-it-8">
  
  
    What’s being done about it?
  
  
</h4>
    

<ul>
  <li>✅ <code>pendulum</code> and <code>arrow</code> have methods to convert to the full local timezone.</li>
  <li>❌ <code>heliclockter</code> has a local datetime type with the same issue,
although a fix is in the works.</li>
  <li>❌ <code>DateType</code> doesn’t address this issue</li>
</ul>
<h2 id="datetime-library-scorecard">
  
  
    Datetime library scorecard <a href="#datetime-library-scorecard">#</a>
  
  
</h2>
    

<p>Below is a summary of how the libraries address the pitfalls (✅) or not (❌).</p>

<table>
  <thead>
    <tr>
      <th>Pitfall</th>
      <th>Arrow</th>
      <th>Pendulum</th>
      <th>DateType</th>
      <th>Heliclockter</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>aware/naïve in one class</td>
      <td>❌</td>
      <td>❌</td>
      <td>✅</td>
      <td>✅</td>
    </tr>
    <tr>
      <td>Operators ignore DST</td>
      <td>❌</td>
      <td>✅</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
    <tr>
      <td>Unclear “naïve” semantics</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
    <tr>
      <td>Silent non-existence</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
    <tr>
      <td>Guesses on ambiguity</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
    <tr>
      <td>Disambiguation breaks equality</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
    <tr>
      <td>Inconsistent equality within zone</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
    <tr>
      <td>datetime inherits from date</td>
      <td>❌</td>
      <td>❌</td>
      <td>✅</td>
      <td>❌</td>
    </tr>
    <tr>
      <td><code>timezone</code> isn’t enough for timezone support</td>
      <td>✅</td>
      <td>✅</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
    <tr>
      <td>DST-unaware local timezone</td>
      <td>✅</td>
      <td>✅</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
  </tbody>
</table>
<h2 id="why-should-you-care">
  
  
    Why should you care? <a href="#why-should-you-care">#</a>
  
  
</h2>
    

<p>The pitfalls roughly fall into two categories:
<em>confusing design</em> and <em>surprising edge cases</em>.
Here is why you should care about both.</p>
<h3 id="confusing-design">
  
  
    Confusing design
  
  
</h3>
    

<p>Confusing design is the larger problem,
because it amplifies the biggest source of bugs: human error.
While good design helps minimize the chance of mistakes,
bad design introduces more opportunities for them.
Looking at other languages, it’s clear that better designs are possible.
Java, C#, and Rust all have distinct classes for naïve and aware datetimes (and more).
We can also see that redesigns are worth the substantial effort:
Java <a href="https://jcp.org/en/jsr/detail?id=310">adopted Joda-Time</a>,
and JavaScript is <a href="https://tc39.es/proposal-temporal/docs/">modernizing as well</a>.
Will Python’s datetime be left behind?</p>
<h3 id="surprising-edge-cases">
  
  
    Surprising edge cases
  
  
</h3>
    

<p>Because these pitfalls are rare, you may think they’re not worth worrying about.
After all, DST transitions only represent about 0.02% of the year.
While this sentiment is understandable, I’d argue that the opposite is true:</p>

<ul>
  <li>Getting timezones right is one of the main <em>reasons for existence</em> of
a datetime library. If it can’t do that reliably, what’s the point?</li>
  <li>Rare cases are the most dangerous: they are the ones you’re least likely to test,
and allow bad actors to trip up your code.</li>
  <li>Rare is still too common for such a fundamental concept as time.
Would you run your business on <code>numpy</code> if it had a
0.02% chance of returning the wrong result?
Would you accept a language in which 1 in 4000 booleans would arbitrarily be flipped?
There is no reason why these pitfalls shouldn’t be corrected.</li>
</ul>
<h2 id="imagining-a-solution">
  
  
    Imagining a solution <a href="#imagining-a-solution">#</a>
  
  
</h2>
    

<p>Inspired by these findings, I created a
<a href="https://github.com/ariebovenberg/whenever">new library</a> to explore
what a better datetime library could look like.
Here is how it addresses the pitfalls:</p>

<ol>
  <li>
    <p>It has distinct classes for the most common use cases:</p>

    <div><div><pre><code><span>from</span> <span>whenever</span> <span>import</span> <span>(</span>
    <span># For the &#34;UTC everywhere&#34; case
</span>    <span>UTCDateTime</span><span>,</span>
    <span># Simple localization sans DST
</span>    <span>OffsetDateTime</span><span>,</span>
    <span># Full-featured IANA timezones
</span>    <span>ZonedDateTime</span><span>,</span>
    <span># The local system timezone
</span>    <span>LocalDateTime</span><span>,</span>
    <span># Detached from any timezones
</span>    <span>NaiveDateTime</span><span>,</span>
<span>)</span>
</code></pre></div>    </div>
  </li>
  <li>Addition and subtraction take DST into account.</li>
  <li>Naïve is always naïve. UTC and local time have their own separate classes.</li>
  <li>Creating non-existent datetimes raises an exception.</li>
  <li>
    <p>Ambiguous datetimes must be explicitly disambiguated.</p>

    <div><div><pre><code><span>ZonedDateTime</span><span>(</span>
    <span>2023</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>tz</span><span>=</span><span>&#34;Europe/Paris&#34;</span><span>,</span>
<span>)</span>  <span># ok: not ambiguous
</span><span>ZonedDateTime</span><span>(</span>
    <span>2023</span><span>,</span> <span>10</span><span>,</span> <span>29</span><span>,</span> <span>2</span><span>,</span> <span>tz</span><span>=</span><span>&#34;Europe/Paris&#34;</span><span>,</span>
<span>)</span>  <span># ERROR: ambiguous!
</span><span>ZonedDateTime</span><span>(</span>
    <span>2023</span><span>,</span> <span>10</span><span>,</span> <span>29</span><span>,</span> <span>2</span><span>,</span> <span>tz</span><span>=</span><span>&#34;Europe/Paris&#34;</span><span>,</span>
    <span>disambiguate</span><span>=</span><span>&#34;later&#34;</span>
<span>)</span>  <span># that&#39;s better!
</span></code></pre></div>    </div>
  </li>
  <li>Disambiguated datetimes work correctly in comparisons.</li>
  <li>
    <p>Aware datetimes are equal if they occur at the same moment. No exceptions.</p>

    <div><div><pre><code><span>a</span> <span>==</span> <span>b</span>
<span># always equivalent to:
</span><span>a</span><span>.</span><span>as_utc</span><span>()</span> <span>==</span> <span>b</span><span>.</span><span>as_utc</span><span>()</span>
</code></pre></div>    </div>
  </li>
  <li>The datetime classes don’t inherit from date.</li>
  <li>IANA timezones are used everywhere, no separate classes are needed.</li>
  <li>Local datetimes handle DST transitions correctly.</li>
</ol>

<p>Feedback is welcome! ⭐️</p>
<h2 id="changelog">
  
  
    Changelog <a href="#changelog">#</a>
  
  
</h2>
    

<p>See the <a href="https://github.com/ariebovenberg/ariebovenberg.github.io/commits/main/_posts/2024-01-20-python-datetime-pitfalls.md">git history</a>
for exact changes to this article since initial publication.</p>
<h3 id="2024-02-01-1814000100">
  
  
    2024-02-01 18:14:00+01:00
  
  
</h3>
    

<ul>
  <li>Clarified wording and code comments in pitfall #3.</li>
</ul>
<h3 id="2024-02-02-1013000100">
  
  
    2024-02-02 10:13:00+01:00
  
  
</h3>
    

<ul>
  <li>Clarified wording around timezones and IANA tz database in pitfall #9,
and throughout the article.</li>
  <li>Added reddit link</li>
</ul>
<h3 id="2024-02-13-0840000100">
  
  
    2024-02-13 08:40:00+01:00
  
  
</h3>
    

<ul>
  <li>Clarified wording on distinguishing “aware” types in pitfall #1.</li>
  <li>Added note about RFC 5545 in pitfall #5.</li>
</ul>



  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
