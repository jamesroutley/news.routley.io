<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/gorenje/erlang-red">Original</a>
    <h1>Show HN: Visual flow-based programming for Erlang, inspired by Node-RED</h1>
    
    <div id="readability-page-1" class="page"><section>
            <p>It&#39;s been two or three weeks since the last lab note. I&#39;ve been on vacation with my family for two weeks, and then caught a cold this last week when I got back. I&#39;ve been doing two things:</p><ul><li>Continuing the implementation of DBSP</li><li>Trying to see if generating a prompt to vibe code would work.</li></ul><h3 id="a-blurb-on-what-dbsp-is">A blurb on what DBSP is</h3><p>The idea behind DBSP is to build a computational circuit that can be incrementalized. Hence, when the input changes a little, we can compute exactly how the output changes a little, rather than recomputing from scratch. DBSP differents from previous formulations of incrementalization.[1] Rather than requiring the user to define a differential version of every operator they use, DBSP borrows from Digital Signal Processing (DSP) and uses a delay to compute differentials. </p><p>From this basic delay along with the unary and binary lifting operator, we can compose more complicated operators. However, we must adhere to very specific constraints: the operators are linear time-invariant, the incrementalization is homomorphic over the circuit algebra, and the elements of the data stream are carriers of an abelian group. That&#39;s a lot to live up to! But if we can keep to those constraints, we can compose them together to build more complicated circuits like differentiators, integrals, and distinct.</p><p>Would the constraints only limit us to useless operators? Apparently not. The paper was able to build incrementalized versions of all the major parts of SQL. This means you can build incremental SQL queries with DBSP.</p><p>I&#39;ve been able to build out the basic operators, as well as diff, integral and distinct. However, I had to do a lot of refactoring as my understanding of it matured. Right now, I&#39;m pulling out any state from the description of the circuit, so that I can operate on pure values representing the computation. The talks on DBSP gloss over a compilation step to optimize the incremental circuit. While not strictly necessary, it does make it practical. So that&#39;s where I&#39;m at the moment. </p><h3 id="prompting-to-generate-prompts">Prompting to generate prompts</h3><p>This particular refactor touches a lot of things. Recently I was lamenting that I&#39;d love to be able to vibe code this stuff, like Geordi La Forge, but my experience has been that LLMs just aren&#39;t very good if you&#39;re anywhere off the beaten path. And that&#39;s where I am currently: implementing new types of reactive or incremental code, sometimes from papers, in a functional style.</p><p>When I was building a sample AI app that you can chat with about Zig, I was able to one-shot the web interface. It was great! But trying to one-shot some of these off-the-beaten path refactors or implementations, it just wasn&#39;t very good. Currently, I can&#39;t tell if the capabilities aren&#39;t up to snuff, or if it&#39;s my prompting skills. Back when I was evaluating GPT-3, I had written it off because I wasn&#39;t aware of RAG techniques. So I&#39;m always wondering if I&#39;m doing something wrong. I&#39;m willing to admit that there&#39;s a new way of working with code, and willing to try it out.</p><p>This time, I have an extensive <a href="https://gist.github.com/iamwilhelm/c042e832661d0ca4cd341408280dd7ac?ref=interjectedfuture.com#file-claude-md" rel="noreferrer">CLAUDE.md/CODEX.md</a> file with instructions and information about the current project. I also used o3 to <a href="https://gist.github.com/iamwilhelm/c042e832661d0ca4cd341408280dd7ac?ref=interjectedfuture.com#file-refactor_streams_to_state-md" rel="noreferrer">write a prompt</a> to give to OpenAI Codex and Claude Code.</p><p>As you can see, it&#39;s more extensive than the usual prompt to &#34;do this&#34; or &#34;refactor that.&#34; I don&#39;t know if I need to format it more as a PRD, but this is more detailed than my usual prompting. I also found that I needed to restart it two or three times, when it started doing something I didn&#39;t think up and needed to update my prompt.</p><p>The results? Better than when I was doing interactive prompting. I gave them free rein to just run with any changes they wanted to do and run tests. However, none of them really made it to the finish line</p><p>Codex got through some of the refactor for basic components, but then got afraid of making changes without breaking tests. It simply kept talking about submitting PRs and wouldn&#39;t make patches, even though I told it I&#39;d tip it and that it should just do it.</p><p>Claude actually made it through the refactor and got all the tests to pass. However, its taste for the separation between the description of the circuit and the evaluation is still not very good. They&#39;re quite tangled with each other. However, I think for easier tasks, I can probably almost treat it like a co-worker. Too bad it&#39;s 3x as expensive as Codex. But I&#39;d rather pay more for something better to waste less time.</p><p>I haven&#39;t tried it out with Llama yet, as I suspect it&#39;ll do worse. But I can&#39;t wait til these models I can run on my machine get good enough to edit code, especially if I can run it on other machines. It&#39;ll be an accelerator, and the problem will then be how to coordinate the work. But until then, I think the overhead is currently too much...it&#39;s just that we&#39;re starting to see that it&#39;s possible.</p><p>So far, I find that writing out the prompt, even if it&#39;s generated, is more work than just trying to do it myself. I also don&#39;t enjoy having to babysit its output. And when I don&#39;t babysit its output every step of the way, I don&#39;t enjoy finding out subtle difference in API or mental model the LLM had that I need to correct later. It&#39;s hard to catch all of those in diffs that are too large or too small. I haven&#39;t yet figured out how to communicate the right size of a chunk to edit to the LLMs yet. </p><p>I burned about $40 of credits in total for both. If I actually got a usable changeset out of this, it&#39;d be worth it. But given that I burned a lot of time and I have no changeset, that&#39;s pretty expensive.</p><p>The only value that I derive is seeing the output for some limited aspect of the design that was fuzzy to me. It was the whole reason for reaching for the LLM in the first place. It&#39;s just that its other decisions make it hard for it to proceed and complete the task. </p><p>Hence, I think the value for LLMs right now will go back to interpreting error messages and doing design sketches given the repo context, without expecting it to do code changedâ€“with the exception of run-of-the-mill web code. </p><p>Lastly being sick this past week made me take a step back for a moment. The <a href="https://interjectedfuture.com/lab-note-068-dealing-with-collections-incrementally/" rel="noreferrer">original problem</a> is a way to incrementally deal with a collection with reactive functions. For that problem, I don&#39;t need DBSP. Diving into DBSP was certainly indulgent, but now I wonder if I should keep going if it doesn&#39;t serve my immediate goals. We&#39;ll see what happens this next week.</p><hr/><p>I haven&#39;t been sitting at my computer a lot these past two weeks, so I&#39;ll have a list of links next week.</p><p>[1] That I&#39;m aware of. I haven&#39;t taken a survey of the landscape. I&#39;ve only picked out what looks good and promising in search of a solution.</p>
        </section></div>
  </body>
</html>
