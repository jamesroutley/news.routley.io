<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://noamf.ink/blog/posts/quarto-isolated-python-envs/">Original</a>
    <h1>Isolated Python Environments for Quarto Blogs</h1>
    
    <div id="readability-page-1" class="page"><div id="quarto-content">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main id="quarto-document-content">





<p>I recently moved this blog over to <a href="https://quarto.org/">Quarto</a>, mostly to make it easier to integrate relevant pieces of code into a few upcoming posts. Quarto files integrate markdown with executable code. The resulting documents are a bit like Jupyter notebooks in the sense that they interleave code and commentary. Unlike Jupyter notebooks, they can be edited in any text editor, which is an important feature for me as a long time Vim user. Quarto also has native support for blogging and better support for compilation to multiple formats. So far, I’ve had a good experience.</p>
<p>The one issue I’ve come across has to do with Quarto’s handling of Python environments. Quarto provides some documentation about using it alongside <a href="https://quarto.org/docs/projects/virtual-environments.html">virtual environments</a>, but the documentation seems to assume one virtual environment per project. For the purposes of a blog, I’d like one virtual environment per post; otherwise changing the environment can break rendering of an earlier post.</p>
<p>Helpfully, Quarto documents support <a href="https://quarto.org/docs/computations/python.html#kernel-selection">specifying a Jupyter kernel</a> to use for rendering. Without a bit more structure, though, this option can lead to loose ends. Kernels dependencies can be altered iteratively, which can make them very difficult to reproduce. Even if they are created programmatically from environment specifications, manually recreating environments and kernels can be tedious.</p>
<p>In Quarto blogs, each post lives in <a href="https://quarto.org/docs/websites/website-blog.html#posts-directory">its own directory</a> For my purposes, I wanted it to be clear exactly what’s needed for each post’s code. I also wanted to be able to trivially reconstruct all the relevant kernels from their corresponding <code>requirements.txt</code> files. This is primarily because I believe in the principle of reproducibility and want others to be able to run the code easily. A secondary reason is that I edit this blog on two computers, and don’t want to have to worry about keeping environments up-to-date between them.</p>
<p>The result I landed on has two steps. The first is two include a <code>requirements.txt</code> file in the directory of each post that has executable python code. This puts the environment spec close to the relevant code, and makes it clear how to construct an environment that can run the code in that specific post. On its own, though, this leaves the problem of having to manually register and update kernels with Jupyter.</p>
<p>This leads to the second step, which is a bash script, copied below. The script searches for <code>requirements.txt</code> files in the posts directory, automatically creates a corresponding venv from each one, and registers that venv as a Jupyter kernel under the same name as the blog post’s directory. This reduces the setup for isolated python environments to running a single script. Now, we just need to specify the Jupyter kernel for the post, as linked above, in each post.</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span># Install jupyter into the current enviornment if not already present</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span>pip</span> install jupyter</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span># Create directory for virtualenvs</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span>mkdir</span> <span>&#34;</span><span>${HOME}</span><span>/venvs&#34;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span># For each post that has a requirements.txt file, create the corresponding kernel</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span>find</span> <span>&#34;quarto-site/blog/posts&#34;</span> <span>-type</span> f <span>-name</span> <span>&#34;requirements.txt&#34;</span> <span>|</span> <span>while</span> <span>read</span> <span>requirements_file</span><span>;</span> <span>do</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span># Get the name of the post corresponding to this requirements.txt file</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span>dir_path</span><span>=</span><span>$(</span><span>dirname</span> <span>&#34;</span><span>${requirements_file}</span><span>&#34;</span><span>)</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span>dir_name</span><span>=</span><span>$(</span><span>basename</span> <span>&#34;</span><span>${dir_path}</span><span>&#34;</span><span>)</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span># Create, activate, and install requirements for the venv</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span>venv_path</span><span>=</span><span>&#34;</span><span>${HOME}</span><span>/venvs/</span><span>${dir_name}</span><span>&#34;</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span>python</span> <span>-m</span> venv <span>&#34;</span><span>${venv_path}</span><span>&#34;</span> <span>--clear</span> </span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    <span>source</span> <span>&#34;</span><span>${venv_path}</span><span>/bin/activate&#34;</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span>pip</span> install <span>-r</span> <span>&#34;</span><span>${requirements_file}</span><span>&#34;</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    <span># Register the venv as a Jupyter kernel</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    <span>pip</span> install ipykernel</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    <span>python</span> <span>-m</span> ipykernel install <span>--user</span> <span>--name</span> <span>&#34;</span><span>${dir_name}</span><span>&#34;</span> <span>--display-name</span> <span>&#34;</span><span>${dir_name}</span><span>&#34;</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    <span># Deactivate the venv</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    <span>deactivate</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span>done</span></span></code></pre></div>



</main> <!-- /main -->

</div></div>
  </body>
</html>
