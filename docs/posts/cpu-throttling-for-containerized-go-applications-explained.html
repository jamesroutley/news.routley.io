<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://kanishk.io/posts/cpu-throttling-in-containerized-go-apps/">Original</a>
    <h1>CPU Throttling for containerized Go applications explained</h1>
    
    <div id="readability-page-1" class="page"><div>
				<p>It’s been a long time since I wrote something here. Past few years I’ve been busy at work which is where most of my writing is done these days. This particular entry comes as an offshoot of a production disaster I saw and then took the opportunity to dive deep and learn more. What seemed like a convoluted problem at the outset, ended up being pretty fascinating in the end.</p>
<p>It’s a bit of a shock to me that even though the majority of Go applications are deployed in containerized environments, there’s very little awareness (from what I’ve seen) about this gotcha (as you will come to learn ahead) which can have major consequences.</p>
<p>This is a problem I had already solved for some of our services a few months ago, but when it came to explaining WHY it worked, I realized my understanding was somewhat broken. So, when we faced an issue caused by CPU throttling in another one of our services, I took the opportunity to dive deeper and understand why exactly this worked the way it did. I had a lot of fun learning how Kubernetes enforces CPU limits, and I hope you do too, and that this might save you a lot of headache and heartache before you ever run into this.</p>
<p>In this blog, I’ll attempt to answer the following questions:</p>
<ul>
<li><a href="#what-could-happen-when-a-service-experiences-cpu-throttling">What could happen when a service experiences CPU throttling?</a></li>
<li><a href="#how-are-cpu-limits-enforced-by-kubernetes">How are CPU limits defined and enforced by Kubernetes?</a></li>
<li><a href="#why-would-a-go-program-experience-throttling">Why would a Go program experience CPU throttling?</a></li>
<li><a href="#to-limit-or-not-to-limit">Should I be defining CPU limits for my services?</a></li>
<li><a href="#i-use-cpu-limits-how-do-i-set-gomaxprocs-appropriately">What can I do to prevent or minimize CPU throttling for my services?</a></li>
<li><a href="#will-setting-gomaxprocs-to-my-cpu-limit-lower-my-service-throughput">Can setting <code>GOMAXPROCS</code> lower service throughput?</a></li>
</ul>
<p>This is going to be a bit of a lengthy read, and you might have to read a few sections again and again to let them sink in. So, please grab a cup of coffee before I start my yapping.</p>
<h2 id="what-could-happen-when-a-service-experiences-cpu-throttling">What could happen when a service experiences CPU throttling?</h2>
<p>The possibilities are on a spectrum. On one end, you could have increased latencies in your application. On the other, under extremely high traffic your application will stop responding to liveness checks, leading to Kubernetes restarting your pods, which in turn would result in a further pile up of connections on a load balancer which results in overloading the load balancer where it stops serving traffic to other services in the network too. So yeah, the consequences range from somewhat bearable to outright catastrophe.</p>
<h2 id="the-example">The example</h2>
<p>We shall use the following example going ahead.</p>
<p>For simplicity’s sake, let’s assume we have a single node cluster with 2 CPU cores. On this cluster, we’re deploying a single service consisting of a single container. The deployment environment is a Kubernetes cluster.</p>
<p>These are the service resource definitions:</p>
<div><pre><code data-lang="yaml">spec:
  containers:
 - name: app
    image: images.my-company.example/app:v4
    resources:
      requests:
        cpu: <span>&#34;100m&#34;</span>
      limits:
        cpu: <span>&#34;1000m&#34;</span>
</code></pre></div><p>For this blog, the memory requests and limits are irrelevant.</p>
<p><img src="https://olu.online/images/mason.jpg" alt="What do requests and limits signify?" title="What are these numbers?!"/></p>
<p>What does the notation <code>100m</code> &amp; <code>1000m</code> mean exactly?</p>
<p>100m translates to 0.1 (or 10%) of a CPU core.
1000m translates to 1 full CPU core.</p>
<h3 id="requests--limits">Requests &amp; Limits</h3>
<p>Requests define the amount of resources guaranteed to your service. If Kubernetes cannot find <code>100m</code> worth of CPU on any nodes, it will fail to schedule the pods for your service. Since we have a limit of <code>100m</code>, it means Kubernetes guarantees we’ll get 0.1 core for our service at all times.</p>
<p>Limits define the maximum amount of resources your service can utilize. Since we have a limit of <code>1000m</code>, it means our service has a CPU Quota of 1 CPU core. Meaning this is the maximum utilization allowed for our service.</p>
<h2 id="how-are-cpu-limits-enforced-by-kubernetes">How are CPU limits enforced by Kubernetes?</h2>
<p>Kubernetes uses something known as the Linux Completely Fair Scheduler (CFS) to monitor, ensure, and enforce resource usage and limits. Resources being CPU and Memory on a node.</p>
<p>The job of CFS is fairly simple:</p>
<ul>
<li>Ensure every container receives CPU time equal to what’s set under <code>resources.request.cpu</code></li>
<li>Prevent any container from using more CPU time than what’s set under <code>resources.limits.cpu</code></li>
</ul>
<p>The CFS period is 100ms by default. Every 100ms, CFS will check if the service is using CPU time equivalent to its limit. This means your service is allowed to use CPU for the entire 100ms period (since proportionally 100ms means 100% of the CPU, which is what we meant by 1000m above)</p>
<p><strong>Note:</strong> Kubernetes allows changing the CFS period value from its default of 100ms but the configuration is per node (not per service). You can always assume it stays unchanged unless your k8s admin has specified otherwise. I won’t be diving into why this is adjustable or where you might need to adjust it at all.</p>
<p>The quota is calculated as:</p>
<div><pre><code data-lang="fallback">Quota per period    = CPU Limit * Period

CPU limit is 1000m  = 1 core
Period              = 100ms (default)

Thus, Quota in a single period = 1 * 100 = 100ms
</code></pre></div><p>This would essentially mean, your service will have 1 core to itself for a period of 100ms. This is what they mean when they say 1000m = 1 core.</p>
<h2 id="go-concurrency-primer">Go concurrency primer</h2>
<p>Before we get into the why, let’s take a little trip to understand how Go models its concurrency. If you’re already aware of this, feel free to skip to the next section.</p>
<p>Go works on the principle of maximizing the concurrency of the application by leveraging parallelism on multi-core hardware.</p>
<p><img src="https://olu.online/images/go_concurrency_model.png" alt="Go concurrency model" title="How Go routines are scheduled over OS threads"/></p>
<p>Let’s break this down, right to left.</p>
<ul>
<li>G - Goroutines. These are user-space threads operated by the Go runtime. This is where your code runs. These are also said to be cheaper to create and use (in comparison to a machine thread). This isn’t exactly unique to Go, and other languages support what are known as Green Threads which are akin to these goroutines.</li>
<li>P - Processors. This is a Go construct, used to schedule a goroutine on to the machine threads. The Go scheduler is responsible for moving goroutines on and off these Processors. <strong>This is the PROC in GOMAXPROCS</strong></li>
<li>M - Machine threads. Also known as OS threads or kernel threads as they operate in kernel space. These are expensive so the GO scheduler is designed to reuse them as much as possible.</li>
</ul>
<p>This is a simplified model and there are a lot of nuances to how the GO scheduler works. If you’re interested, I’ve linked an amazing talk by Kavya Joshi <a href="#further-reading">down below</a> where she walks us through the design principles of the Go scheduler.</p>
<p>The relevant part for us here is that <code>GOMAXPROCS</code> controls the number of Ps your application has, and that in turn determines how many simultaneously running Ms your application will have. Put plainly, this decides how many goroutines will be running simultaneously in your application.</p>
<p>During initialization, the Go runtime will create Ms equal to the value of your <code>GOMAXPROCS</code>. By default, it’s set to the value returned by <code>runtime.NumCPU()</code>. You can also set it with:</p>
<ul>
<li><code>runtime.GOMAXPROCS(n)</code></li>
<li><code>GOMAXPROCS</code> environment variable.</li>
</ul>
<h2 id="why-would-a-go-program-experience-throttling">Why would a Go program experience throttling?</h2>
<p>We didn’t set an explicit value for <code>GOMAXPROCS</code> for our service. What do you think will be the default value of <code>GOMAXPROCS</code> when the service is deployed on our cluster?</p>
<p>We specified in our deployment that the CPU request is <code>100m</code> and the limit is <code>1000m</code>. However, when the application is running inside a container, the Go runtime isn’t aware of the fact that the container is allotted just 1 core (1000m = 1 core). It sees all the available cores on the node. So, <code>GOMAXPROCS</code> is instead set to 2! Why is this? What the frick Go?!</p>
<h3 id="the-gotcha">The Gotcha!</h3>
<p><code>runtime.NumCPU()</code> returns the total number of logical cores on the NODE and not the cores allotted to the CONTAINER! This is because the file inside Linux from which Go reads CPU information is not modified by Linux when a container is created. Meaning, looking from inside a container and trying to find the available CPU cores, Go will end up seeing all cores on the node (which can be a VM or a bare metal server). <strong>This is the root of our problems</strong>.</p>
<h3 id="how-are-we-throttled">How are we throttled?</h3>
<p>The CPU utilization will look something like this:
<img src="https://olu.online/images/go_svc_throttled.png" alt="Go service throttled" title="Go service with GOMAXPROCS=2 and CPU limit of 1 core is throttled in first 50ms of a CFS period"/></p>
<p>If Go schedules some goroutines to carry out operations on both cores, they may start using the CPUs, and within the first 50ms of the period, CFS will realize that the service has exhausted its quota of 100ms, and throttle the ongoing CPU usage, i.e. prevent the service from using CPU for the rest of the 50ms remaining in the period. This is important because now your service can only resume its work after 50ms when the next period of 100ms starts. <strong>This is key to understanding how CPU throttling impacts your application latencies.</strong></p>
<h2 id="will-setting-my-requests--limit-prevent-throttling">Will setting my requests == limit prevent throttling?</h2>
<p>Even in this scenario, without an appropriate value for <code>GOMAXPROCS</code>, your Go application still sees all cores on the node and thus, spawns the same number of machine threads to schedule work. Your usage is still split across a large number of cores, and you have a limit, so it’s measured against your quota. You might still end up consuming your quota very early and being throttled for the remaining duration of a CFS period. Remember, <strong>this effect worsens the more cores you have available on your node</strong>.</p>
<p>Setting requests == limits ensures Kubernetes provides a “Guaranteed” QoS for your container. You can learn more about that that means <a href="https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/">here</a>. If you go for this, I’d recommend configuring a proper value for <code>GOMAXPROCS</code> as well to ensure efficient usage of the CPU.</p>
<h2 id="a-note-on-limit--1-and-gomaxprocs">A note on limit &lt; 1 and <code>GOMAXPROCS</code></h2>
<p>Even if you do set <code>GOMAXPROCS</code> but define a value &lt; 1 for CPU limit, you may still end up being throttled if the GO service uses a significant amount of CPU.</p>
<p>Consider that you’re tuning your <code>GOMAXPROCS=1</code> (it can’t go any lower than this) and your service has a CPU limit of 100m.</p>
<p>Using the quota formula we saw previously, let’s quickly calculate the maximum CPU time we’ll be allowed to use in a single 100ms period.</p>
<div><pre><code data-lang="fallback">CPU Limit = 100m = 0.1 core
CPU Period = 100ms

Quota per period = 0.1 * 100 = 10ms
</code></pre></div><p>If your service attempts to use more than 10ms of CPU time, even though it’s using a single core (because <code>GOMAXPROCS=1</code>), it will be throttled if the operation it’s carrying out requires more CPU time than your quota. Assume one of these operations takes 30ms, your CPU usage would then look something like this:</p>
<p><img src="https://olu.online/images/fractional_cpu_svc_throttled.png" alt="throttled-svc" title="Service on a single core throttled since it has a fractional CPU quota but higher CPU requirements"/></p>
<p>If you do experience this, I’d recommend setting your limit to a whole CPU. This ensures your service gets uninterrupted CPU time.</p>
<h2 id="to-limit-or-not-to-limit">To limit or not to limit?</h2>
<p>CFS throttling is enforced by measuring your usage against your limits, and the big idea behind reducing throttling is to set your <code>GOMAXPROCS</code> according to your CPU limit. But what if you don’t set limits for your service?</p>
<p>A very popular opinion is that services should set reasonable CPU requests and not set limits at all. We shouldn’t assume this will solve our throttling woes because we get away with setting <code>GOMAXPROCS</code>. While most services get throttled because they exceed their CFS quotas, during node pressure CFS must ensure all other pods on the node get their <code>request</code>-ed amount of CPU time, which is when it will throttle your service beyond its CPU <code>request</code>.</p>
<p><a href="https://www.datadoghq.com/blog/kubernetes-cpu-requests-limits/#when-to-set-cpu-limits">This section from DataDog’s blog on limits &amp; requests</a> discusses cases when you should set limits. I agree with their argument for bringing predictability to your application performance by setting limits since you may be deploying on a cluster with multiple different services owned by multiple teams (as it is in my case) and you get a predictable performance for your application, whether or not there’s node pressure.</p>
<p>On the other side of the ring, there are <a href="https://home.robusta.dev/blog/stop-using-cpu-limits">folks</a> arguing for <a href="https://www.numeratorengineering.com/requests-are-all-you-need-cpu-limits-and-throttling-in-kubernetes/">not</a> setting limits. This makes sense to me when I’m the owner of the cluster and aware of what’s running on my cluster at all times. This might not likely be the case if a Platform Engineering team owns and manages your cluster.</p>
<p>If you do not set CPU limits, I’d still recommend setting your <code>GOMAXPROCS</code> somewhere around 1x or 2x your CPU <code>request</code> to get predictable performance.</p>
<p>I leave it up to the reader to decide on this.</p>
<h2 id="i-use-cpu-limits-how-do-i-set-gomaxprocs-appropriately">I use CPU limits, how do I set <code>GOMAXPROCS</code> appropriately?</h2>
<p>There are various ways.</p>
<h3 id="automaxprocs">automaxprocs</h3>
<p>The one I use is <a href="https://github.com/uber-go/automaxprocs">automaxprocs</a>. This is a one-line import into the cmd of your application which sets your <code>GOMAXPROCS</code> at startup time by reading the cgroup quota information inside the container.</p>
<div><pre><code data-lang="go"><span>import</span> _ <span>&#34;go.uber.org/automaxprocs&#34;</span>

<span>func</span> main() {
  <span>// Your application logic here.
</span><span></span>}
</code></pre></div><h3 id="via-resourcefieldref">Via <code>resourceFieldRef</code></h3>
<p>You could also just set the <code>GOMAXPROCS</code> env var for your service to the <code>resources.limits.cpu</code> parameter using <code>resourceFieldRef</code></p>
<div><pre><code data-lang="yaml">env:
- name: GOMAXPROCS
  valueFrom:
    resourceFieldRef:
      resource: limits.cpu
</code></pre></div><p>I learned of this from <a href="https://blog.howardjohn.info/posts/gomaxprocs/">Howard John’s blog</a>. Take a look to know how this works.</p>
<h3 id="wait-for-go-runtime-to-be-cfs-aware">Wait for Go runtime to be CFS aware</h3>
<p><a href="https://github.com/golang/go/issues/33803">This</a> is a long-standing open issue with the maintainers of Go. There doesn’t seem to be an end in sight for this and it looks like until this happens, we will need to be mindful when deploying Go in containers. I expect this to be eventually incorporated into the runtime, given that everyone almost universally deploys Go in containers and the fact that other languages like Java have followed suit and made JVM CFS aware.</p>
<h2 id="will-setting-gomaxprocs-to-my-cpu-limit-lower-my-service-throughput">Will setting <code>GOMAXPROCS</code> to my CPU limit lower my service throughput?</h2>
<p>Consider the alternative where your service had CPU limits but didn’t have <code>GOMAXPROCS</code> set. There, your service was ultimately throttled and lost out on CPU time to finish its work. Knowing this, it’s common sense that your service wasn’t getting sustained and continuous CPU time, thereby limiting its ability to process more work. With a proper value for <code>GOMAXPROCS</code>, you’d ensure your CPU gets uninterrupted CPU time. This should help maximize your throughput and also impact your P99 latencies positively.</p>
<p>Uber’s automaxprocs contains <a href="https://github.com/uber-go/automaxprocs#performance">results of benchmark</a> they ran comparing their service’s throughput and P99 latencies where it’s apparent that when you set <code>GOMAXPROCS</code> = quota, you get the best results.</p>
<p>A frequently asked question that I come across is:</p>
<blockquote>
<p>By setting GOMAXPROCS=1, am I limiting my application to use 1 goroutine only?</p>
</blockquote>
<p>And the answer is No! What you are limiting is how many simultaneously running goroutines you can have in your application at any given instant. Remember, goroutines can be in orders of thousands and millions but only a small number of them (=<code>GOMAXPROCS</code>) will ever be in running state. The rest will either be waiting to be scheduled or in a blocked state (due to several different reasons like blocking OS calls like Disk or Network I/O or waiting on mutexes, listening on a channel, etc.)</p>
<h2 id="takeaways--closing-notes">Takeaways &amp; closing notes</h2>
<p>A go application running in K8s isn’t aware it’s running inside a container and is thereby subject to its cgroup limits. This behavior isn’t talked about enough, IMO. The effects of CPU throttling on performance get worse the more cores your node has. In my case, the application was deployed over a 128-core node with a limit of a measly 4 CPUs, so you can extrapolate the above examples and realize how bad it can get.</p>
<p><a href="https://www.datadoghq.com/blog/kubernetes-cpu-requests-limits">This blog from DataDog</a> shows metrics to watch for to monitor CPU usage and throttling for your service. These metrics are generally exposed to nearly every metrics stack (including Prometheus). I’d recommend everyone periodically take a look at their service’s CPU/Memory metrics to help decide if re-sizing is required.</p>
<p>Having a good understanding of how things like CPU/Memory quotas work and are enforced under the hood carries a lot more value than simply knowing things for the sake of trivia. It allows you to be mindful of how you size your service’s resource requirements. I’ve found this endeavor to be illuminating and I expect that I will probably need to re-learn this in the future, which is why I’m documenting it here, not just for you, but for a future me!</p>
<p>Through the course of my research, I came across some very good material on how Go &amp; Kubernetes work under the hood. I’ve linked to some of those materials in the next section and I hope you’ll take some time to go through them.</p>
<h2 id="further-reading">Further reading</h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=YHRO5WQGh0k">Gophercon 2018: Kavya Joshi - The Scheduler Saga</a> - An amazing and enjoyable talk on the design principles of the Go scheduler. I learned quite a few things about the inner workings of the Go scheduler.</li>
<li><a href="https://github.com/golang/go/blob/master/src/runtime/proc.go#L22">runtime/proc.go</a> - Go is written in Go. You can check this file to see how the scheduler works. I’ll recommend coming to this after you’ve seen Kavya’s talk.</li>
<li><a href="https://golang.org/s/go11sched">Go Scheduler Design Doc</a></li>
<li><a href="https://christopher-batey.medium.com/cpu-considerations-for-java-applications-running-in-docker-and-kubernetes-7925865235b7">CPU considerations for Java applications running in Docker and Kubernetes</a> - Relates more to Java but also has a good explanation for Kubernetes limits.</li>
</ul>

			</div></div>
  </body>
</html>
