<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/facebookresearch/large_concept_model">Original</a>
    <h1>Large Concept Models: Language modeling in a sentence representation space</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<div dir="auto"><h2 tabindex="-1" dir="auto">Language Modeling in a Sentence Representation Space</h2><a id="user-content-language-modeling-in-a-sentence-representation-space" aria-label="Permalink: Language Modeling in a Sentence Representation Space" href="#language-modeling-in-a-sentence-representation-space"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><a href="https://ai.meta.com/blog/meta-fair-updates-agents-robustness-safety-architecture/" rel="nofollow">[Blog]</a> <a href="https://ai.meta.com/research/publications/large-concept-models-language-modeling-in-a-sentence-representation-space/" rel="nofollow">[Paper]</a></p>
<p dir="auto">This repository provides the official implementations and experiments for <a href="https://ai.meta.com/research/publications/large-concept-models-language-modeling-in-a-sentence-representation-space/" rel="nofollow">Large Concept Models</a> (<strong>LCM</strong>).</p>
<p dir="auto">
<a target="_blank" rel="noopener noreferrer" href="https://github.com/facebookresearch/large_concept_model/blob/main/space.svg"><img src="https://github.com/facebookresearch/large_concept_model/raw/main/space.svg" width="50%"/></a>
</p>
<p dir="auto">The LCM operates on an explicit higher-level semantic representation,
which we name a &#34;concept&#34;. Concepts are language- and modality-agnostic and represent a higher
level idea. In this work, a concept corresponds to a sentence, and we use the <a href="https://github.com/facebookresearch/SONAR">SONAR</a>
embedding space, which supports up to 200 languages in text and 57 languages in speech. See the list of supported languages <a href="https://github.com/facebookresearch/SONAR?tab=readme-ov-file#supported-languages-and-download-links">here</a>.</p>

<p dir="auto">
<a target="_blank" rel="noopener noreferrer" href="https://github.com/facebookresearch/large_concept_model/blob/main/lcm.svg"><img src="https://github.com/facebookresearch/large_concept_model/raw/main/lcm.svg" width="70%"/></a>
</p>
<p dir="auto">The LCM is a sequence-to-sequence model in the concepts space trained to perform auto-regressive sentence prediction.
We explore multiple approaches:</p>
<ul dir="auto">
<li>MSE regression (<code>base_lcm</code> in this code).</li>
<li>Variants of diffusion-based generation (we include <code>two_tower_diffusion_lcm</code> in this release).</li>
<li>Models operating in a quantized SONAR space (coming soon).</li>
</ul>
<p dir="auto">These explorations are performed using 1.6B parameter models and training data in the order of 1.3T tokens. We include in this repository recipes to reproduce the training and finetuning of 1.6B MSE LCM and Two-tower diffusion LCM. See instructions <a href="#usage">below</a>.</p>


<p dir="auto">The LCM repository relies on fairseq2. If you have <code>uv</code> installed on your system, you can install a virtual environment with all the necessary packages by running the following commands:</p>
<div dir="auto" data-snippet-clipboard-copy-content="uv sync --extra cpu --extra eval --extra data"><pre>uv sync --extra cpu --extra <span>eval</span> --extra data</pre></div>
<p dir="auto">You can also use <code>uv run</code> to run the demo commands with the correct environment.</p>
<p dir="auto">Note that we only provide requirements for <code>cpu</code> dependencies, if you want to use GPU support, you will have to choose the variants of torch and fairseq2 that work for your system.
For example for torch 2.5.1 with cuda 1.21, You would do something like:</p>
<div data-snippet-clipboard-copy-content="uv pip install torch==2.5.1 --extra-index-url https://download.pytorch.org/whl/cu121 --upgrade
uv pip install fairseq2==v0.3.0rc1 --pre --extra-index-url  https://fair.pkg.atmeta.com/fairseq2/whl/rc/pt2.5.1/cu121 --upgrade"><pre><code>uv pip install torch==2.5.1 --extra-index-url https://download.pytorch.org/whl/cu121 --upgrade
uv pip install fairseq2==v0.3.0rc1 --pre --extra-index-url  https://fair.pkg.atmeta.com/fairseq2/whl/rc/pt2.5.1/cu121 --upgrade
</code></pre></div>
<p dir="auto">Check <a href="https://github.com/facebookresearch/fairseq2?tab=readme-ov-file#variants">fairseq2 variants</a> for possible variants. Note that LCM currently relies on the release candidate for fairseq2 0.3.0 rc1.</p>

<p dir="auto">To install with pip, the commands are very similar, but you will have to manage your own environment and make sure to install fairseq2 manually first. For instance, for a <code>cpu</code> install.</p>
<div dir="auto" data-snippet-clipboard-copy-content="pip install --upgrade pip
pip install fairseq2==v0.3.0rc1 --pre --extra-index-url  https://fair.pkg.atmeta.com/fairseq2/whl/rc/pt2.5.1/cpu
pip install -e &#34;.[data,eval]&#34;"><pre>pip install --upgrade pip
pip install fairseq2==v0.3.0rc1 --pre --extra-index-url  https://fair.pkg.atmeta.com/fairseq2/whl/rc/pt2.5.1/cpu
pip install -e <span><span>&#34;</span>.[data,eval]<span>&#34;</span></span></pre></div>
<p dir="auto">If <a href="https://github.com/facebookresearch/fairseq2">fairseq2</a> does not provide a build for your machine, check the readme of that project to build it locally.</p>

<div dir="auto"><p dir="auto"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p><p dir="auto">If using <code>uv</code> prefix all commands with <code>uv run</code> to use the environment created by default in <code>.venv</code>, e.g.,
<code>uv run torchrun --standalone</code>.
Alternatively, you can activate the environment once and for all with <code>source .venv/bin/activate</code>.</p>
</div>

<p dir="auto">The LCM can be trained and evaluated using textual data split in sentences and embedded with <a href="https://github.com/facebookresearch/SONAR/">SONAR</a>. We provide a sample processing pipeline that can be used to prepare such training data, you can run it with:</p>
<div data-snippet-clipboard-copy-content=" uv run --extra data scripts/prepare_wikipedia.py /output/dir/for/the/data"><pre><code> uv run --extra data scripts/prepare_wikipedia.py /output/dir/for/the/data
</code></pre></div>
<p dir="auto">This pipeline shows how to get a dataset from huggingface and process it with SONAR and <a href="https://arxiv.org/abs/2406.16678" rel="nofollow">SaT</a>. Check out the file for more details on processing your own data. While the script provides an example pulling data from huggingface, we also provide <a href="https://github.com/facebookresearch/stopes/tree/main/stopes/utils/sharding">APIs</a> to process jsonl, parquet and CSV.</p>

<p dir="auto">The trainer described below relies on datacards configuring the datasets. These datacards are yaml files with pointers to the dataset files (locally or on s3) and information on its schema. We provide some sample datacards in <a href="https://github.com/facebookresearch/large_concept_model/blob/main/lcm/datacards/datacards.yaml"><code>lcm/datacards/datacards.yaml</code></a>. Once you have processed some data, you can update the datacards with your paths.</p>

<p dir="auto">To fit a new embedding space normalizer on a given weighted mixture of datasets
one can use the following command :</p>
<div dir="auto" data-snippet-clipboard-copy-content="python scripts/fit_embedding_normalizer.py --ds dataset1:4 dataset2:1 dataset3:10 --save_path &#34;path/to/new/normalizer.pt&#34; --max_nb_samples 1000000"><pre>python scripts/fit_embedding_normalizer.py --ds dataset1:4 dataset2:1 dataset3:10 --save_path <span><span>&#34;</span>path/to/new/normalizer.pt<span>&#34;</span></span> --max_nb_samples 1000000</pre></div>
<p dir="auto">Here, <code>dataset1</code>, <code>dataset2</code>, <code>dataset3</code> are the names of datasets declared in the datacards as shown above
and <code>(4, 1, 10)</code> their respective relative weights.
The resulting normalizer can be next declared as a model as shown in <code>lcm/cards/sonar_normalizer.yaml</code>
and referenced in all model training configs.</p>


<p dir="auto">To train an MSE LCM, we will use one of the following commands:</p>
<p dir="auto"><strong>Option 1.</strong> Training with SLURM using <a href="https://github.com/facebookincubator/submitit">submitit</a> via <a href="https://github.com/facebookresearch/stopes/tree/main">stopes</a>&#39;s launcher:</p>
<div dir="auto" data-snippet-clipboard-copy-content="python -m lcm.train \
    +pretrain=mse \
    ++trainer.output_dir=&#34;checkpoints/mse_lcm&#34; \
    ++trainer.experiment_name=training_mse_lcm \"><pre>python -m lcm.train \
    +pretrain=mse \
    ++trainer.output_dir=<span><span>&#34;</span>checkpoints/mse_lcm<span>&#34;</span></span> \
    ++trainer.experiment_name=training_mse_lcm \</pre></div>
<p dir="auto">With this command, we will submit a slurm job named <code>training_mse_lcm</code> with the recipe&#39;s requirements, in this case:</p>
<div dir="auto" data-snippet-clipboard-copy-content="requirements:
  nodes: 4
  tasks_per_node: 8
  gpus_per_node: 8
  cpus_per_task: 32
  mem_gb: 0
  timeout_min: 10000"><pre><span>requirements</span>:
  <span>nodes</span>: <span>4</span>
  <span>tasks_per_node</span>: <span>8</span>
  <span>gpus_per_node</span>: <span>8</span>
  <span>cpus_per_task</span>: <span>32</span>
  <span>mem_gb</span>: <span>0</span>
  <span>timeout_min</span>: <span>10000</span></pre></div>
<p dir="auto">You can override the job&#39;s requirements like the timeout limit and the launcher&#39;s slurm partition with:</p>
<div dir="auto" data-snippet-clipboard-copy-content="python -m lcm.train \
    +pretrain=mse \
    ++trainer.output_dir=&#34;checkpoints/mse_lcm&#34; \
    ++trainer.experiment_name=training_mse_lcm \
    ++trainer.requirements.timeout_min=100 \
    ++trainer.requirements.cpus_per_task=8 \
    ++launcher.partition=$partition_name"><pre>python -m lcm.train \
    +pretrain=mse \
    ++trainer.output_dir=<span><span>&#34;</span>checkpoints/mse_lcm<span>&#34;</span></span> \
    ++trainer.experiment_name=training_mse_lcm \
    ++trainer.requirements.timeout_min=100 \
    ++trainer.requirements.cpus_per_task=8 \
    ++launcher.partition=<span>$partition_name</span></pre></div>
<p dir="auto"><strong>Option 2.</strong> Training locally with <code>torchrun</code> (e.g. using only 2 GPUs) with a smaller batch size (overriding <code>++trainer.data_loading_config.max_tokens=1000</code>):</p>
<div dir="auto" data-snippet-clipboard-copy-content="CUDA_VISIBLE_DEVICES=0,1 torchrun --standalone --nnodes=1 --nproc-per-node=2 \
    -m lcm.train launcher=standalone \
    +pretrain=mse \
    ++trainer.data_loading_config.max_tokens=1000 \
    ++trainer.output_dir=&#34;checkpoints/mse_lcm&#34; \
    +trainer.use_submitit=false \"><pre>CUDA_VISIBLE_DEVICES=0,1 torchrun --standalone --nnodes=1 --nproc-per-node=2 \
    -m lcm.train launcher=standalone \
    +pretrain=mse \
    ++trainer.data_loading_config.max_tokens=1000 \
    ++trainer.output_dir=<span><span>&#34;</span>checkpoints/mse_lcm<span>&#34;</span></span> \
    +trainer.use_submitit=false \</pre></div>
<div dir="auto"><p dir="auto"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 1.75C0 .784.784 0 1.75 0h12.5C15.216 0 16 .784 16 1.75v9.5A1.75 1.75 0 0 1 14.25 13H8.06l-2.573 2.573A1.458 1.458 0 0 1 3 14.543V13H1.75A1.75 1.75 0 0 1 0 11.25Zm1.75-.25a.25.25 0 0 0-.25.25v9.5c0 .138.112.25.25.25h2a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.749.749 0 0 1 .53-.22h6.5a.25.25 0 0 0 .25-.25v-9.5a.25.25 0 0 0-.25-.25Zm7 2.25v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 9a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>Important</p><p dir="auto">Since we&#39;re changing the number of GPUs required by the recipe, this will not reproduce the experimental setup of the paper.</p>
</div>
<p dir="auto">The checkpoints directory <code>checkpoints/mse_lcm</code> will be structured as:</p>
<div data-snippet-clipboard-copy-content=".
├── checkpoints
│   ├── step_2000
│   ├── ...
│   └── step_250000
├── config_logs
├── executor_logs
├── model_card.yaml
├── tb   # tensorboard logs
└── wandb  # W&amp;B logs"><pre><code>.
├── checkpoints
│   ├── step_2000
│   ├── ...
│   └── step_250000
├── config_logs
├── executor_logs
├── model_card.yaml
├── tb   # tensorboard logs
└── wandb  # W&amp;B logs
</code></pre></div>
<p dir="auto">Note that W&amp;B logging is skipped unless <code>wandb</code> is available.
You can install <code>wandb</code> with <code>uv pip install wandb</code>.
W&amp;B arguments can be changed by overriding Hydra config values in the recipe:</p>
<div dir="auto" data-snippet-clipboard-copy-content="++trainer.wandb_project=$project_name
++trainer.wandb_run_name=$run_name"><pre>++trainer.wandb_project=<span>$project_name</span>
++trainer.wandb_run_name=<span>$run_name</span></pre></div>

<p dir="auto">Similar to the base MSE LCM we can submit a training job following the recipe in <a href="https://github.com/facebookresearch/large_concept_model/blob/main/recipes/train/pretrain/two_tower.yaml">./recipes/train/pretrain/two_tower.yaml</a> via:</p>
<div dir="auto" data-snippet-clipboard-copy-content="python -m lcm.train \
    +pretrain=two_tower \
    ++trainer.output_dir=&#34;checkpoints/two_tower_lcm&#34; \
    ++trainer.experiment_name=training_two_tower_lcm \"><pre>python -m lcm.train \
    +pretrain=two_tower \
    ++trainer.output_dir=<span><span>&#34;</span>checkpoints/two_tower_lcm<span>&#34;</span></span> \
    ++trainer.experiment_name=training_two_tower_lcm \</pre></div>
<div dir="auto"><p dir="auto"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M8 1.5c-2.363 0-4 1.69-4 3.75 0 .984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75 0 0 1-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456 0 0 0-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863 0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751 0 0 1-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304 0-2.06-1.637-3.75-4-3.75ZM5.75 12h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5ZM6 15.25a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 1 0 1.5h-2.5a.75.75 0 0 1-.75-.75Z"></path></svg>Tip</p><p dir="auto">To understand the different ingredients of training recipes, check <a href="https://github.com/facebookresearch/large_concept_model/blob/main/recipes/train/README.md">this README</a>.</p>
</div>

<p dir="auto">To finetune the previously pre-trained two-tower diffusion LCM on supervised data,  follow these steps:</p>
<p dir="auto"><strong>Step 1.</strong> Register the pre-trained checkpoint as a fairseq2 asset.</p>
<p dir="auto">You can finetune the final checkpoint with the card <code>checkpoints/two_tower_lcm/model_card.yaml</code> or any checkpoint after a specific number of training steps, e.g., <code>checkpoints/two_tower_lcm/checkpoints/step_2000/model_card.yaml</code>.
To register the selected checkpoint, copy the automatically created yaml file to <code>./lcm/cards/mycards.yaml</code> and rename the model to replace the default <code>on_the_fly_lcm</code>.
<code>./lcm/cards/mycards.yaml</code> will look like:</p>
<div dir="auto" data-snippet-clipboard-copy-content="__source__: inproc
 checkpoint: file://path_to/large_concept_model/checkpoints/two_tower_lcm/checkpoints/step_2000/model.pt
 model_arch: two_tower_diffusion_lcm_1_6B
 model_family: two_tower_diffusion_lcm
 name: my_pretrained_two_tower"><pre><span>__source__</span>: <span>inproc</span>
 <span>checkpoint</span>: <span>file://path_to/large_concept_model/checkpoints/two_tower_lcm/checkpoints/step_2000/model.pt</span>
 <span>model_arch</span>: <span>two_tower_diffusion_lcm_1_6B</span>
 <span>model_family</span>: <span>two_tower_diffusion_lcm</span>
 <span>name</span>: <span>my_pretrained_two_tower</span></pre></div>
<p dir="auto">For more on how to manage fairseq2 assets, see <a href="https://facebookresearch.github.io/fairseq2/nightly/basics/assets.html" rel="nofollow">documentation</a>.</p>
<p dir="auto"><strong>Step 2.</strong> Launch a finetuning job pointing to the model to finetune, in this instance <code>my_pretrained_two_tower</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="CUDA_VISIBLE_DEVICES=0,1 torchrun --standalone --nnodes=1 --nproc-per-node=2 \
    -m lcm.train launcher=standalone \
    +finetune=two_tower \
    ++trainer.output_dir=&#34;checkpoints/finetune_two_tower_lcm&#34; \
    ++trainer.data_loading_config.max_tokens=1000 \
    +trainer.use_submitit=false \
    ++trainer.model_config_or_name=my_pretrained_two_tower"><pre>CUDA_VISIBLE_DEVICES=0,1 torchrun --standalone --nnodes=1 --nproc-per-node=2 \
    -m lcm.train launcher=standalone \
    +finetune=two_tower \
    ++trainer.output_dir=<span><span>&#34;</span>checkpoints/finetune_two_tower_lcm<span>&#34;</span></span> \
    ++trainer.data_loading_config.max_tokens=1000 \
    +trainer.use_submitit=false \
    ++trainer.model_config_or_name=my_pretrained_two_tower</pre></div>
<p dir="auto">or</p>
<div dir="auto" data-snippet-clipboard-copy-content="python -m lcm.train \
    +finetune=two_tower \
    ++trainer.output_dir=&#34;checkpoints/finetune_two_tower_lcm&#34; \
    ++trainer.experiment_name=finetune_two_tower_lcm \
    ++trainer.model_config_or_name=my_pretrained_two_tower"><pre>python -m lcm.train \
    +finetune=two_tower \
    ++trainer.output_dir=<span><span>&#34;</span>checkpoints/finetune_two_tower_lcm<span>&#34;</span></span> \
    ++trainer.experiment_name=finetune_two_tower_lcm \
    ++trainer.model_config_or_name=my_pretrained_two_tower</pre></div>
<p dir="auto">Similarly, to finetune an MSE LCM, follow the same instructions for registering a pre-trained checkpoint and submit a finetuning job with the appropriate recipe (<a href="https://github.com/facebookresearch/large_concept_model/blob/main/recipes/train/finetune/mse.yaml">./recipes/train/finetune/mse.yaml</a>) via:</p>
<div dir="auto" data-snippet-clipboard-copy-content="python -m lcm.train \
    +finetune=mse \
    ++trainer.output_dir=&#34;checkpoints/finetune_mse_lcm&#34; \
    ++trainer.experiment_name=finetune_mse_lcm \
    ++trainer.model_config_or_name=my_pretrained_mse_lcm"><pre>python -m lcm.train \
    +finetune=mse \
    ++trainer.output_dir=<span><span>&#34;</span>checkpoints/finetune_mse_lcm<span>&#34;</span></span> \
    ++trainer.experiment_name=finetune_mse_lcm \
    ++trainer.model_config_or_name=my_pretrained_mse_lcm</pre></div>


<p dir="auto"><strong>Step 0.</strong> Download NLTK data required for evaluating ROUGE:</p>
<div dir="auto" data-snippet-clipboard-copy-content="python -m nltk.downloader punkt_tab"><pre><span>python</span> <span>-</span><span>m</span> <span>nltk</span>.<span>downloader</span> <span>punkt_tab</span></pre></div>
<p dir="auto"><strong>Step 1.</strong>
Generate and score outputs of a model either by pointing to its <code>model_card</code> yaml file or after registering it as a fairseq2 asset (the same way we registerd <code>my_pretrained_two_tower</code>):</p>
<div dir="auto" data-snippet-clipboard-copy-content="model_card=./checkpoints/finetune_two_tower_lcm/checkpoints/step_1000/model_card.yaml
OUTPUT_DIR=evaluation_outputs/two_tower

torchrun --standalone --nnodes=1 --nproc-per-node=1 -m lcm.evaluation  \
  --predictor two_tower_diffusion_lcm  \
  --show_progress true \
  --data_loading.max_samples 100 \
  --model_card ${model_card} \
  --launcher standalone \
  --dataset.source_suffix_text &#39;[MODEL]:&#39; \
  --tasks finetuning_data_lcm.validation \
   --task_args &#39;{&#34;max_gen_len&#34;: 10, &#34;eos_config&#34;: {&#34;text&#34;: &#34;End of text.&#34;}}&#39; \
  --data_loading.batch_size 4  --generator_batch_size 4 \
  --dump_dir ${OUTPUT_DIR} \
  --inference_timesteps 40 \
  --initial_noise_scale 0.6 \
  --guidance_scale 3 \
  --guidance_rescale 0.7"><pre>model_card=./checkpoints/finetune_two_tower_lcm/checkpoints/step_1000/model_card.yaml
OUTPUT_DIR=evaluation_outputs/two_tower

torchrun --standalone --nnodes=1 --nproc-per-node=1 -m lcm.evaluation  \
  --predictor two_tower_diffusion_lcm  \
  --show_progress <span>true</span> \
  --data_loading.max_samples 100 \
  --model_card <span>${model_card}</span> \
  --launcher standalone \
  --dataset.source_suffix_text <span><span>&#39;</span>[MODEL]:<span>&#39;</span></span> \
  --tasks finetuning_data_lcm.validation \
   --task_args <span><span>&#39;</span>{&#34;max_gen_len&#34;: 10, &#34;eos_config&#34;: {&#34;text&#34;: &#34;End of text.&#34;}}<span>&#39;</span></span> \
  --data_loading.batch_size 4  --generator_batch_size 4 \
  --dump_dir <span>${OUTPUT_DIR}</span> \
  --inference_timesteps 40 \
  --initial_noise_scale 0.6 \
  --guidance_scale 3 \
  --guidance_rescale 0.7</pre></div>
<p dir="auto">where in the example we are evaluating 100 samples only (<code>--data_loading.max_samples 100</code>) and limiting the model output length to 10 sentences (<code>--task_args &#39;{&#34;max_gen_len&#34;: 10}&#39;</code>).</p>
<p dir="auto">Outputs dumped in <code>./evaluation_outputs/two_tower</code> will be structured as:</p>
<div data-snippet-clipboard-copy-content=".
├── metadata.jsonl
├── metrics.eval.jsonl
├── raw_results
├── results
└── tb"><pre><code>.
├── metadata.jsonl
├── metrics.eval.jsonl
├── raw_results
├── results
└── tb
</code></pre></div>
<p dir="auto">where <code>metrics.eval.jsonl</code> contains corpus-level scores.</p>
<p dir="auto">To evaluate an MSE LCM, we use the associated predictor (<code>base_lcm</code>) and evaluate with:</p>
<div dir="auto" data-snippet-clipboard-copy-content="model_card=./checkpoints/finetune_mse_lcm/checkpoints/step_1000/model_card.yaml
OUTPUT_DIR=evaluation_outputs/mse_lcm

torchrun --standalone --nnodes=1 --nproc-per-node=1 -m lcm.evaluation  \
  --predictor base_lcm --sample_latent_variable False \
  --show_progress true \
  --data_loading.max_samples 100 \
  --model_card ${model_card} \
  --launcher standalone \
  --dataset.source_suffix_text &#39;[MODEL]:&#39; \
  --tasks finetuning_data_lcm.validation \
   --task_args &#39;{&#34;max_gen_len&#34;: 10, &#34;eos_config&#34;: {&#34;text&#34;: &#34;End of text.&#34;}}&#39; \
  --data_loading.batch_size 4  --generator_batch_size 4 \
  --dump_dir ${OUTPUT_DIR} \"><pre>model_card=./checkpoints/finetune_mse_lcm/checkpoints/step_1000/model_card.yaml
OUTPUT_DIR=evaluation_outputs/mse_lcm

torchrun --standalone --nnodes=1 --nproc-per-node=1 -m lcm.evaluation  \
  --predictor base_lcm --sample_latent_variable False \
  --show_progress <span>true</span> \
  --data_loading.max_samples 100 \
  --model_card <span>${model_card}</span> \
  --launcher standalone \
  --dataset.source_suffix_text <span><span>&#39;</span>[MODEL]:<span>&#39;</span></span> \
  --tasks finetuning_data_lcm.validation \
   --task_args <span><span>&#39;</span>{&#34;max_gen_len&#34;: 10, &#34;eos_config&#34;: {&#34;text&#34;: &#34;End of text.&#34;}}<span>&#39;</span></span> \
  --data_loading.batch_size 4  --generator_batch_size 4 \
  --dump_dir <span>${OUTPUT_DIR}</span> \</pre></div>
<p dir="auto">Note that in this example, we only show how to evaluate the LCM on the same finetuning dataset (validation split). To evaluate in a downstream task, and compare results with the LLM, refer to the <a href="https://github.com/facebookresearch/large_concept_model/blob/main/examples/evaluation/README.md">Evaluation documentation</a>.</p>

<p dir="auto">See the <a href="https://github.com/facebookresearch/large_concept_model/blob/main/CONTRIBUTING.md">CONTRIBUTING</a> file for how to help out.</p>

<p dir="auto">If you use this codebase, please cite:</p>
<div data-snippet-clipboard-copy-content="@article{lcm2024,
  author = {{LCM team}, Lo\&#34;{i}c Barrault, Paul-Ambroise Duquenne, Maha Elbayad, Artyom Kozhevnikov, Belen Alastruey, Pierre Andrews, Mariano Coria, Guillaume Couairon, Marta R. Costa-juss\`{a}, David Dale, Hady Elsahar, Kevin Heffernan, Jo\~{a}o Maria Janeiro, Tuan Tran, Christophe Ropers, Eduardo Sánchez, Robin San Roman, Alexandre Mourachko, Safiyyah Saleem, Holger Schwenk},
  title = {{Large Concept Models}: Language Modeling in a Sentence Representation Space},
  publisher = {arXiv},
  year = {2024},
  url = {https://arxiv.org/abs/2412.08821},
}"><pre><code>@article{lcm2024,
  author = {{LCM team}, Lo\&#34;{i}c Barrault, Paul-Ambroise Duquenne, Maha Elbayad, Artyom Kozhevnikov, Belen Alastruey, Pierre Andrews, Mariano Coria, Guillaume Couairon, Marta R. Costa-juss\`{a}, David Dale, Hady Elsahar, Kevin Heffernan, Jo\~{a}o Maria Janeiro, Tuan Tran, Christophe Ropers, Eduardo Sánchez, Robin San Roman, Alexandre Mourachko, Safiyyah Saleem, Holger Schwenk},
  title = {{Large Concept Models}: Language Modeling in a Sentence Representation Space},
  publisher = {arXiv},
  year = {2024},
  url = {https://arxiv.org/abs/2412.08821},
}
</code></pre></div>

<p dir="auto">This code is released under the MIT license (see <a href="https://github.com/facebookresearch/large_concept_model/blob/main/LICENSE">LICENSE</a>).</p>
</article></div></div>
  </body>
</html>
