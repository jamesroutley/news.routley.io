<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/howerj/lfsr-vhdl">Original</a>
    <h1>LFSR CPU Running Forth</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<ul dir="auto">
<li>Author: Richard James Howe</li>
<li>License: 0BSD / Public Domain</li>
<li>Email: <a href="mailto:howe.r.j.89@gmail.com">mailto:howe.r.j.89@gmail.com</a></li>
<li>Repo: <a href="https://github.com/howerj/lfsr-vhdl">https://github.com/howerj/lfsr-vhdl</a></li>
</ul>
<p dir="auto">This project contains a CPU written in <a href="https://en.wikipedia.org/wiki/VHDL" rel="nofollow">VHDL</a> for an <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array" rel="nofollow">FPGA</a> using a Linear Feedback Shift
Register (<a href="https://en.wikipedia.org/wiki/Linear-feedback_shift_register" rel="nofollow">LFSR</a>) instead of a Program Counter, this was sometimes done to save space as
a <a href="https://en.wikipedia.org/wiki/Linear-feedback_shift_register" rel="nofollow">LFSR</a> requires fewer gates than an adder, however on an FPGA it will make very
little difference as the units that make an FPGA (Slices/Configurable Logic
Blocks) have carry chains in them. The saving would perhaps be more apparent if
making the system out of <a href="https://en.wikipedia.org/wiki/7400-series_integrated_circuits" rel="nofollow">7400</a> series ICs, or if laying transistors out by hand.</p>
<p dir="auto">See <a href="https://github.com/howerj/lfsr">https://github.com/howerj/lfsr</a> for more information.</p>
<p dir="auto">The system contains a fully working <a href="https://en.wikipedia.org/wiki/Forth_(programming_language)" rel="nofollow">Forth</a> interpreter.</p>
<p dir="auto">The project currently works in simulation (it outputs the startup message
&#34;eForth 3.3&#34; with a new line) and accepts input (try typing &#34;words&#34; when the
simulation in <a href="http://ghdl.free.fr/" rel="nofollow">GHDL</a> is running).</p>
<p dir="auto">Here is an example session of the simulator running:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/howerj/lfsr-vhdl/blob/master/lfsr-0.gif"><img src="https://github.com/howerj/lfsr-vhdl/raw/master/lfsr-0.gif" alt="C Simulator Running eForth" data-animated-image=""/></a></p>
<p dir="auto">And the VHDL running under GHDL for a limited number of cycles:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/howerj/lfsr-vhdl/blob/master/lfsr-1.gif"><img src="https://github.com/howerj/lfsr-vhdl/raw/master/lfsr-1.gif" alt="VHDL Simulator Running eForth" data-animated-image=""/></a></p>

<p dir="auto">The system runs can run at 151.768MHz (on a Spartan-6) according to the timing
report. The CPU itself is quite small, here is a cut-down report on the
resources consumed for commit <code>7dc4c9b7e03082364b09540bb2d97105d2858d0b</code>:</p>
<div data-snippet-clipboard-copy-content="+------------------------------------------------------------+
| Module     | Slices | Slice Reg | LUTs  | BRAM/FIFO | BUFG | 
+------------------------------------------------------------+
| top/       | 3/53   | 9/105     | 1/151 | 0/8       | 1/1  | 
| +system    | 0/27   | 0/47      | 0/85  | 0/8       | 0/0  | 
| ++bram     | 0/0    | 0/0       | 0/0   | 8/8       | 0/0  | 
| ++cpu      | 27/27  | 47/47     | 85/85 | 0/0       | 0/0  | 
| +uart_rx_0 | 12/12  | 24/24     | 39/39 | 0/0       | 0/0  | 
| +uart_tx_0 | 11/11  | 25/25     | 26/26 | 0/0       | 0/0  | 
+------------------------------------------------------------+
No LUTRAM/BUFIO/DSP48A1/BUFR/DCM/PLL_ADV used"><pre><code>+------------------------------------------------------------+
| Module     | Slices | Slice Reg | LUTs  | BRAM/FIFO | BUFG | 
+------------------------------------------------------------+
| top/       | 3/53   | 9/105     | 1/151 | 0/8       | 1/1  | 
| +system    | 0/27   | 0/47      | 0/85  | 0/8       | 0/0  | 
| ++bram     | 0/0    | 0/0       | 0/0   | 8/8       | 0/0  | 
| ++cpu      | 27/27  | 47/47     | 85/85 | 0/0       | 0/0  | 
| +uart_rx_0 | 12/12  | 24/24     | 39/39 | 0/0       | 0/0  | 
| +uart_tx_0 | 11/11  | 25/25     | 26/26 | 0/0       | 0/0  | 
+------------------------------------------------------------+
No LUTRAM/BUFIO/DSP48A1/BUFR/DCM/PLL_ADV used
</code></pre></div>
<p dir="auto">The above is indicative only as the actual resources used may vary from
commit to commit, but also because of the tool chain and FPGA targeted.</p>
<p dir="auto">Even given that though it is clear that this system is <em>small</em>. The CPU
only occupies 27 slices, which is only a little larger than the bit-serial
CPU available at <a href="https://github.com/howerj/bit-serial">https://github.com/howerj/bit-serial</a>, and this 16-bit CPU
is <em>much</em> faster.</p>

<p dir="auto">To build you will need <code>make</code>. To make the C Virtual Machine you will need a C
compiler of your choosing.</p>
<p dir="auto">To run the C VM type:</p>

<p dir="auto">You should be greeted by the message <code>eforth 3.3</code>. Type <code>bye</code> and hit <code>ENTER</code>
to quit (<code>CTRL-D</code> will not work, this is not a bug). Type <code>words</code> for a list of
defined Forth words. An example session:</p>
<div data-snippet-clipboard-copy-content=": ahoy cr .&#34; GOODBYE, CRUEL WORLD!&#34; cr ;
ahoy
2 2 + . cr
bye"><pre><code>: ahoy cr .&#34; GOODBYE, CRUEL WORLD!&#34; cr ;
ahoy
2 2 + . cr
bye
</code></pre></div>
<p dir="auto">This is not a Forth tutorial. For a Forth tutorial look elsewhere. Try &#34;the
internet&#34;. I am sure they have something.</p>
<p dir="auto">Making the simulation requires <code>GHDL</code>:</p>

<p dir="auto">There is a configuration file for the simulation in the file <code>tb.cfg</code> that
allows changing many test bench parameters without recompiling the test bench.
GHDL also allows you to set generics via the command line, which is done in the
<code>makefile</code>. For example <code>make simulation DEBUG=2</code> sets the top level debug
generic to <code>2</code>, bear in mind when changing the generics in <code>tb.vhd</code> that the
<code>makefile</code> can override these constants!</p>
<p dir="auto">To build for an FPGA you will need <code>Xilinx ISE 14.7</code>:</p>
<div data-snippet-clipboard-copy-content="make synthesis implementation bitfile"><pre><code>make synthesis implementation bitfile
</code></pre></div>
<p dir="auto">The system has not been tested on an FPGA at the moment. If you have any luck,
let me know.</p>

<p dir="auto">A short summary of the instruction set and design:</p>
<ul dir="auto">
<li>The machine is an accumulator based machine.</li>
<li>All instructions are 16-bits in length.</li>
<li>The top four bits determine the instruction.</li>
<li>The lowest four bits are the operand parameter.</li>
<li>Addresses are in number of 16-bit cells, not bytes.</li>
<li>The program counter is 8-bits in size and is advanced with a LFSR.</li>
<li>The top most bit determined whether the operand is used directly or
whether or it loaded first.</li>
</ul>
<p dir="auto">The instruction set has been carefully chosen so that it
should be very simple to implement in a traditional manner,
or in a bit-serial fashion (much like my other CPU project at
<a href="https://github.com/howerj/bit-serial">https://github.com/howerj/bit-serial</a> that runs on an FPGA). It has
also been designed so that it should be possible to implement in 7400
series logic ICs (excluding ROM and RAM) as well as on an FPGA. There
may be no savings in logic on an FPGA due to the fact that slices
have a built in carry chain (usually), but a comparison could be made
when the system is implemented on an FPGA (This has been done, there
is very little difference).</p>
<p dir="auto">As the Program Counter does not use addition, it was decided that
addition should be removed from the instruction set. It would be a
bit weird to worry about all the gates the Program Counter is using and
then just include an adder elsewhere. The ADD instruction is sorely
missed and makes the Forth code more complex and slows it down. The
only other instruction that feels like it should be present (to me)
is bit-wise OR, in practice it is not used that much within the
interpreter so it not missed, it is reimplemented using bitwise AND
and INVERT (XOR against all bits set).</p>
<p dir="auto">The instruction layout is:</p>
<div data-snippet-clipboard-copy-content="+----------+---------------+-------------------+
|  BIT 15  | BITS 12 to 14 |    BITS 0 to 11   |
+----------+---------------+-------------------+
| INDIRECT | INSTRUCTION   | VALUE   / ADDRESS |
+----------+---------------+-------------------+"><pre><code>+----------+---------------+-------------------+
|  BIT 15  | BITS 12 to 14 |    BITS 0 to 11   |
+----------+---------------+-------------------+
| INDIRECT | INSTRUCTION   | VALUE   / ADDRESS |
+----------+---------------+-------------------+
</code></pre></div>
<p dir="auto">The <code>INDIRECT</code> flag determined whether bits 0 to 11 are treated as
a value (not set) or an address (<code>INDIRECT</code> is set).</p>
<p dir="auto">The <code>INSTRUCTION</code> field is 3-bits in size, the instructions are:</p>
<div data-snippet-clipboard-copy-content="0 : XOR   : ACC = ACC ^ ARG
1 : AND   : ACC = ACC &amp; ARG
2 : LLS1  : ACC = ARG &lt;&lt; 1
3 : LRS1  : ACC = ARG &gt;&gt; 1
4 : LOAD  : ACC = MEM[ARG]
5 : STORE : MEM[ARG] = ACC
6 : JUMP  : PC = ARG
7 : JUMPZ : IF (ACC == 0) { PC = ARG }"><pre><code>0 : XOR   : ACC = ACC ^ ARG
1 : AND   : ACC = ACC &amp; ARG
2 : LLS1  : ACC = ARG &lt;&lt; 1
3 : LRS1  : ACC = ARG &gt;&gt; 1
4 : LOAD  : ACC = MEM[ARG]
5 : STORE : MEM[ARG] = ACC
6 : JUMP  : PC = ARG
7 : JUMPZ : IF (ACC == 0) { PC = ARG }
</code></pre></div>
<p dir="auto">All instructions advance the program counter except <code>JUMP</code>, and
(conditionally) <code>JUMPZ</code>. All instruction affect or use the accumulator
except the jump instructions. <code>MEM</code> consists of a linear array of
16-bit values.</p>
<p dir="auto">There is one special address, address 0. This address is never
incremented after an instruction is run as this is a lock up state for
the LFSR, the current instruction will be executed indefinitely. A way
to exit this condition is for the first instruction to be a jump to
address <code>1</code>, however any non-zero address will do. The system starts
up executing from address zero. Conditional jumps could be used to
determine whether to reset or halt the system if needed. Alternatively
a LFSR that used XNOR could have been used (the lockup state for which
is all ones) but it was not.</p>
<p dir="auto"><code>ACC</code> is the 16-bit accumulator.</p>
<p dir="auto"><code>ARG</code> is either the zero extended 12-bit operand (the lowest 12-bits
of the instruction) as is, or the 16-bit value <code>MEM[operand]</code> if the
topmost bit of the instruction is set.</p>
<p dir="auto">Input and Output is memory mapped, reading from a negative address
(high bit set) causes a byte to be read or output. This is triggered
from reading or writing to any negative address, if multiple
peripherals are to be added the address will have to be decoded
correctly.</p>
<p dir="auto">For the purposes of simulation <code>JUMP</code> will cause the CPU to halt if
the jump address is the same as the program counter. This will not
be implemented in hardware.</p>
<p dir="auto">The program counter uses a 8-bit LFSR to advance, that means only 256
16-bit values can be directly addressed by this CPU, this is not a
limitation that matters for the purpose of the software running on this
system, a complete Forth Programming Language image, as the Virtual
Machine that supports Forth can be written in under 256 instructions
for this system. That Forth Virtual Machine can address more memory
by using LOAD/STORE to access values outside the 256 instruction range.</p>
<p dir="auto">This instruction set might change depending on the implementation,
or when it comes to implementation, to make things easier and smaller
still.</p>

<p dir="auto">The following can be used to create a state-machine diagram with
Graphviz, this can be done online, see <a href="https://dreampuf.github.io/GraphvizOnline/" rel="nofollow">https://dreampuf.github.io/GraphvizOnline/</a>:</p>
<div data-snippet-clipboard-copy-content="digraph LfsrCpu {
	fetch -&gt; fetch [label = &#34;pause = 1\nor next instr&#34;];
	fetch -&gt; indirect;
	fetch -&gt; load;
	fetch -&gt; store;
	indirect -&gt; fetch;
	indirect -&gt; load;
	indirect -&gt; store;
	load -&gt; load [label = &#34;ihav = 0\nand input&#34;];
	load -&gt; next;
	store -&gt; next;
	store -&gt; store [label = &#34;obsy = 1\nand output&#34;];
	next -&gt; fetch;
}"><pre><code>digraph LfsrCpu {
	fetch -&gt; fetch [label = &#34;pause = 1\nor next instr&#34;];
	fetch -&gt; indirect;
	fetch -&gt; load;
	fetch -&gt; store;
	indirect -&gt; fetch;
	indirect -&gt; load;
	indirect -&gt; store;
	load -&gt; load [label = &#34;ihav = 0\nand input&#34;];
	load -&gt; next;
	store -&gt; next;
	store -&gt; store [label = &#34;obsy = 1\nand output&#34;];
	next -&gt; fetch;
}
</code></pre></div>
<p dir="auto">Alternatively, here is a veritable feast of a PNG file for both your lovely eye balls
to take in and gaze upon with wonder, or to just look at, whatever:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/howerj/lfsr-vhdl/blob/master/lfsr-sm.png"><img src="https://github.com/howerj/lfsr-vhdl/raw/master/lfsr-sm.png" alt="CPU State Machine"/></a></p>

<p dir="auto">Edit <code>tb.cfg</code> and ensure that the number of clocks to run for is over <code>90000000</code> (or equal
to), and that we are running in interactive mode, the following configuration
file should work:</p>
<div data-snippet-clipboard-copy-content="Clocks.. # Number of clock cycles to run for
90000000
Forever. # If greater than zero run forever
0
Interact # Is this session interactive?
2
InWaitMs # Time to wait before getting user input
10
UartRep. # UART reporting level, if non zero `report` UART chars
1
LogFor.. # Extra debug logging for this many cycles
100
1Line... # Exit after getting one line of input if non zero
1
UChDelay # Delay (ms) between sending UART characters
1
CRLF.EOF # Line ending CRLF (1) or LF (0)?
0"><pre><code>Clocks.. # Number of clock cycles to run for
90000000
Forever. # If greater than zero run forever
0
Interact # Is this session interactive?
2
InWaitMs # Time to wait before getting user input
10
UartRep. # UART reporting level, if non zero `report` UART chars
1
LogFor.. # Extra debug logging for this many cycles
100
1Line... # Exit after getting one line of input if non zero
1
UChDelay # Delay (ms) between sending UART characters
1
CRLF.EOF # Line ending CRLF (1) or LF (0)?
0
</code></pre></div>
<p dir="auto">Then run the command:</p>
<div data-snippet-clipboard-copy-content="echo &#34;bye&#34; | make simulation DEBUG=2 &gt; vhdl.txt"><pre><code>echo &#34;bye&#34; | make simulation DEBUG=2 &gt; vhdl.txt
</code></pre></div>
<p dir="auto">And then:</p>
<div data-snippet-clipboard-copy-content="echo &#34;bye&#34; | DEBUG=1 ./lfsr lfsr.hex 2&gt; c.txt"><pre><code>echo &#34;bye&#34; | DEBUG=1 ./lfsr lfsr.hex 2&gt; c.txt
</code></pre></div>
<p dir="auto">And compare with:</p>

<p dir="auto">You will notice differences, however they should be minor, obvious, and mostly
related to VHDL report messages. The instructions executed should be identical
so long as the input is identical, to make sure this is the case the line
endings also need to be made to be identical for both inputs.</p>
<p dir="auto">Empirically the system averages 2.4 clock cycles (or 2.4 state changes) to execute a
single instruction, this was measured by executing the default Forth image and feeding
it a line of text with the quit/halt word &#34;bye&#34; in it. This was calculated from the
following table, which contains the number of times the instruction has been encountered,
whether the instruction is the indirect variant (marked with an &#39;i&#39;), the instruction,
the number of cycles needed to execute that instruction and the cycles multiplied by
instruction cycle length.</p>
<div data-snippet-clipboard-copy-content="+--------+--------+----------+---------+---------+
| cycles | indir? | instr?   | cyc/ins |         |
+--------+--------+----------+---------+---------+
| 369492 |        |  a_jmp   | 1       | 369492  |
| 241070 |        |  a_jmpz  | 1       | 241070  |
| 880098 |        |  a_load  | 3       | 2640294 |
| 1450   |        |  a_lsr1  | 1       | 1450    |
| 880388 |        |  a_store | 3       | 2641164 |
| 206102 | i      |  a_and   | 2       | 412204  |
| 65755  | i      |  a_jmp   | 2       | 131510  |
| 32042  | i      |  a_jmpz  | 2       | 64084   |
| 53057  | i      |  a_load  | 4       | 212228  |
| 173287 | i      |  a_lsl1  | 2       | 346574  |
| 17053  | i      |  a_store | 4       | 68212   |
| 173513 | i      |  a_xor   | 2       | 347026  |
+--------+--------+----------+---------+---------+
Total Instructions executed: 3093307 
Total Instruction cycles: 7475308"><pre><code>+--------+--------+----------+---------+---------+
| cycles | indir? | instr?   | cyc/ins |         |
+--------+--------+----------+---------+---------+
| 369492 |        |  a_jmp   | 1       | 369492  |
| 241070 |        |  a_jmpz  | 1       | 241070  |
| 880098 |        |  a_load  | 3       | 2640294 |
| 1450   |        |  a_lsr1  | 1       | 1450    |
| 880388 |        |  a_store | 3       | 2641164 |
| 206102 | i      |  a_and   | 2       | 412204  |
| 65755  | i      |  a_jmp   | 2       | 131510  |
| 32042  | i      |  a_jmpz  | 2       | 64084   |
| 53057  | i      |  a_load  | 4       | 212228  |
| 173287 | i      |  a_lsl1  | 2       | 346574  |
| 17053  | i      |  a_store | 4       | 68212   |
| 173513 | i      |  a_xor   | 2       | 347026  |
+--------+--------+----------+---------+---------+
Total Instructions executed: 3093307 
Total Instruction cycles: 7475308
</code></pre></div>

<ul dir="auto">
<li>Improve the documentation; the addition of timing diagrams, terminal capture
of the simulation running, state-machine diagrams and the like would all
help. Much of the documentation from the sister project could be incorporated
into this one.</li>
<li>Optimize the CPU core:
<ul dir="auto">
<li>The Input/Output system could be reworked, making I/O truly memory mapped.</li>
</ul>
</li>
<li>See <a href="https://github.com/howerj/lfsr">https://github.com/howerj/lfsr</a> for more information and suggestions.</li>
<li>The number of these devices that could fit on one device could be quite
large, limited perhaps by the number of Block RAMs available. Modifications
would have to be made to program and interact with a matrix of these CPUs,
but it might be a neat thing to do. They could take their input from the same
UART and the same starting commands or boot image, synchronization could be
partially achieved with <code>pause</code>, <code>ihav</code> and <code>obsy</code> signals. Each CPU would
need an identifier assigned to it. It might be a good idea to have a way for
each CPU to talk to its immediate neighbors. Most of these problems could be
solved with a adjustments to the I/O system and the addition of peripherals
and pseudo peripherals.</li>
<li>The <code>lfsr.vhd</code> file is quite configurable with many generics, the tool-chain
could be made to generate Forth images that deal with the variants.</li>
<li>A Dual-Port version of the CPU would be faster, although require more resources,
this CPU in its current form can share one half a Dual Port Block RAM allowing
very fast memory mapped I/O.</li>
<li>The eForth image could be turned into ROM sections (the Forth Virtual Machine
and the initial Forth dictionary could go here) and sections that can be stored
in RAM. This ROM/RAM version would also execute faster, provided only the Forth
VM was to be stored in ROM.</li>
<li>A bit-serial version of this CPU could be made, it might be smaller, it would
certainly be slower.</li>
<li>A simulation written in VHDL using components based off of real 7400 series
devices could be made. This should make it easier to build a physical version
of this system out of 7400 series ICs, and will most likely be faster than
other digital simulators. This would involve making components for each 7400
series IC we would want to use, sticking to the common ones (NAND gates,
counters, multiplexors, flip flops, comparators, decoders) would be best,
as some of the more exotic devices (such as ALUs, adders, ...) can be harder
to find.</li>
<li>The article <a href="https://www.fpgarelated.com/showarticle/797.php" rel="nofollow">https://www.fpgarelated.com/showarticle/797.php</a>, or
Inside the Spartan-6: Using LUTs to optimize circuits by Victor Yurkovsky,
publish June 24, 2015, contains information about optimizing LUT usage
by explicitly instantiating and placing LUTs and other FPGA logic. If we
really want to shrink this system, we could do the same here. There is also
an interesting article about outputting VGA signals in only 7 slices:
<a href="https://www.fpgarelated.com/showarticle/42.php" rel="nofollow">https://www.fpgarelated.com/showarticle/42.php</a>.</li>
<li>The instruction set could be played around with, there are some really
interesting instructions such as <code>execute this register as an instruction</code>
(which is appropriate for a register machine and not an accumulator machine,
adding a full rotate and removing the shift left/right by one instructions, or
perhaps my favorite, using a Lookup Table (LUT) to determine what the output
should be for two inputs which would allow all two input logic gates to be
implemented, see <a href="https://arnaud-carre.github.io/2024-10-06-vpternlogd/" rel="nofollow">https://arnaud-carre.github.io/2024-10-06-vpternlogd/</a> for
an example of a three input version. Setting the LUT would require setting a
4-bit register for a 2-input LUT, which could be tacked on to the JUMP
instruction as we have bits to spare (we only use 8-bits).</li>
<li>LFSR, and the related Cyclic Redundancy Checks (CRC), have many uses, Pseudo Random
Number Generation (PRNG), test vector generation and checking, Built In Self
Tests (BIST), and more. Using LFSR for test vector generation, in both a test
bench and in hardware, would allow us to query the CPU with many test
patterns and efficiently compare this to a result, in hardware this could be
part of a BIST peripheral that sets a pin high on success.</li>
<li>This project would be a good candidate for the <a href="https://tinytapeout.com/" rel="nofollow">Tiny Tapeout</a> project,
amongst my others projects. Tiny Tapeout allows designers to cheaply make
their own physical silicon. The interface would be a problem and would
require shifting data in and out N-bits at a time as there are a limited
number of pins available to interface with external memory (both RAM and
ROM ICs would be required). This would mean we would need to be able to
pause the CPU in any state, or other modifications would need to be made.
Perhaps <a href="https://github.com/howerj/bit-serial">https://github.com/howerj/bit-serial</a> would make a better candidate?</li>
</ul>

<ul dir="auto">
<li><a href="https://github.com/howerj/lfsr">https://github.com/howerj/lfsr</a></li>
<li><a href="https://github.com/howerj/subleq">https://github.com/howerj/subleq</a></li>
<li><a href="https://github.com/howerj/bit-serial">https://github.com/howerj/bit-serial</a></li>
<li><a href="https://github.com/howerj/7400">https://github.com/howerj/7400</a></li>
<li><a href="https://github.com/howerj/subleq-vhdl">https://github.com/howerj/subleq-vhdl</a></li>
<li><a href="https://www.amazon.com/SUBLEQ-EFORTH-Forth-Metacompilation-Machine-ebook/dp/B0B5VZWXPL" rel="nofollow">https://www.amazon.com/SUBLEQ-EFORTH-Forth-Metacompilation-Machine-ebook/dp/B0B5VZWXPL</a></li>
<li><a href="http://ghdl.free.fr/" rel="nofollow">http://ghdl.free.fr/</a></li>
<li><a href="https://www.righto.com/2020/11/reverse-engineering-ram-storage-in.html" rel="nofollow">https://www.righto.com/2020/11/reverse-engineering-ram-storage-in.html</a></li>
<li><a href="https://sheep-thrills.net/NES_lockout_chip_address_smartness.html" rel="nofollow">https://sheep-thrills.net/NES_lockout_chip_address_smartness.html</a></li>
<li><a href="https://en.wikipedia.org/wiki/Texas_Instruments_TMS1000" rel="nofollow">https://en.wikipedia.org/wiki/Texas_Instruments_TMS1000</a></li>
<li><a href="https://hackmii.com/2010/01/the-weird-and-wonderful-cic/" rel="nofollow">https://hackmii.com/2010/01/the-weird-and-wonderful-cic/</a></li>
<li><a href="https://www.eetimes.com/tutorial-linear-feedback-shift-registers-lfsrs-part-3/" rel="nofollow">https://www.eetimes.com/tutorial-linear-feedback-shift-registers-lfsrs-part-3/</a></li>
<li><a href="https://stackoverflow.com/questions/28179701/" rel="nofollow">https://stackoverflow.com/questions/28179701/</a></li>
<li><a href="https://en.wikipedia.org/wiki/Computation_of_cyclic_redundancy_checks" rel="nofollow">https://en.wikipedia.org/wiki/Computation_of_cyclic_redundancy_checks</a></li>
<li><a href="https://stackoverflow.com/questions/5781458/" rel="nofollow">https://stackoverflow.com/questions/5781458/</a></li>
<li><a href="https://crypto.stackexchange.com/questions/67670/" rel="nofollow">https://crypto.stackexchange.com/questions/67670/</a></li>
<li><a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check" rel="nofollow">https://en.wikipedia.org/wiki/Cyclic_redundancy_check</a></li>
</ul>
</article></div></div>
  </body>
</html>
