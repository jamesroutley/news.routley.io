<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/Alanma23/tinytinyTPU-co">Original</a>
    <h1>TinyTinyTPU: 2×2 systolic-array TPU-style matrix-multiply unit deployed on FPGA</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">A minimal 2×2 systolic-array TPU-style matrix-multiply unit, implemented in SystemVerilog and deployed on FPGA.</p>
<a target="_blank" rel="noopener noreferrer" href="https://private-user-images.githubusercontent.com/68415438/531458515-0fa29f4b-eec1-4c61-814c-23a8cc3b80ba.png?jwt=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3Njc0MjUwNDAsIm5iZiI6MTc2NzQyNDc0MCwicGF0aCI6Ii82ODQxNTQzOC81MzE0NTg1MTUtMGZhMjlmNGItZWVjMS00YzYxLTgxNGMtMjNhOGNjM2I4MGJhLnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNjAxMDMlMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjYwMTAzVDA3MTkwMFomWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPTViMTY2OGMxM2ZmYzU3NDQ3NTAxY2ExYzM0Y2IzMjVkYWRmZjE0ZTc2MTlkM2M0MWMwNTEzYWI2YzcwYjkxZTEmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0In0.ELds5F6Xt2teqEqnWSeoQg2emCWUpwkhUPF_1XQ31_s"><img width="1900" height="1244" alt="image" src="https://private-user-images.githubusercontent.com/68415438/531458515-0fa29f4b-eec1-4c61-814c-23a8cc3b80ba.png?jwt=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3Njc0MjUwNDAsIm5iZiI6MTc2NzQyNDc0MCwicGF0aCI6Ii82ODQxNTQzOC81MzE0NTg1MTUtMGZhMjlmNGItZWVjMS00YzYxLTgxNGMtMjNhOGNjM2I4MGJhLnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNjAxMDMlMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjYwMTAzVDA3MTkwMFomWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPTViMTY2OGMxM2ZmYzU3NDQ3NTAxY2ExYzM0Y2IzMjVkYWRmZjE0ZTc2MTlkM2M0MWMwNTEzYWI2YzcwYjkxZTEmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0In0.ELds5F6Xt2teqEqnWSeoQg2emCWUpwkhUPF_1XQ31_s"/></a>
<p dir="auto">This project implements a complete TPU architecture including:</p>
<ul dir="auto">
<li>2×2 systolic array (4 processing elements)</li>
<li>Full post-MAC pipeline (accumulator, activation, normalization, quantization)</li>
<li>UART-based host interface</li>
<li>Multi-layer MLP inference capability</li>
<li>FPGA deployment on Basys3 (Xilinx Artix-7)</li>
</ul>
<p dir="auto"><strong>Resource Usage (Basys3 XC7A35T):</strong>
<a target="_blank" rel="noopener noreferrer" href="https://private-user-images.githubusercontent.com/68415438/531458568-4df73d8c-6068-4ba8-a65d-c223d89de3aa.png?jwt=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3Njc0MjUwNDAsIm5iZiI6MTc2NzQyNDc0MCwicGF0aCI6Ii82ODQxNTQzOC81MzE0NTg1NjgtNGRmNzNkOGMtNjA2OC00YmE4LWE2NWQtYzIyM2Q4OWRlM2FhLnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNjAxMDMlMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjYwMTAzVDA3MTkwMFomWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPTg3MWE5ZGEzNDNiNzhkMjgzZTA3MmZjNmM4MDZiNTc3ZWQyMDYyOWY4MWEwODhiMGFlNTA5MzUyYTdhZTkwMWImWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0In0.JdTV9dy3bqBdLhZec-ZhnQkXeQJ7gliDoLmSGR4l0YY"><img width="2000" height="2000" alt="image" src="https://private-user-images.githubusercontent.com/68415438/531458568-4df73d8c-6068-4ba8-a65d-c223d89de3aa.png?jwt=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3Njc0MjUwNDAsIm5iZiI6MTc2NzQyNDc0MCwicGF0aCI6Ii82ODQxNTQzOC81MzE0NTg1NjgtNGRmNzNkOGMtNjA2OC00YmE4LWE2NWQtYzIyM2Q4OWRlM2FhLnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNjAxMDMlMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjYwMTAzVDA3MTkwMFomWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPTg3MWE5ZGEzNDNiNzhkMjgzZTA3MmZjNmM4MDZiNTc3ZWQyMDYyOWY4MWEwODhiMGFlNTA5MzUyYTdhZTkwMWImWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0In0.JdTV9dy3bqBdLhZec-ZhnQkXeQJ7gliDoLmSGR4l0YY"/></a></p>
<ul dir="auto">
<li>LUTs: ~1,000 (5% utilization)</li>
<li>Flip-Flops: ~1,000 (3% utilization)</li>
<li>DSP48E1: 8 slices</li>
<li>BRAM: ~10-15 blocks</li>
<li>Estimated Gate Count: ~25,000 gates</li>
</ul>
<hr/>

<ol dir="auto">
<li><a href="#project-overview">Project Overview</a></li>
<li><a href="#quick-start">Quick Start</a></li>
<li><a href="#simulation--testing">Simulation &amp; Testing</a></li>
<li><a href="#fpga-build--deployment">FPGA Build &amp; Deployment</a></li>
<li><a href="#running-inference">Running Inference</a></li>
<li><a href="#project-structure">Project Structure</a></li>
<li><a href="#architecture-details">Architecture Details</a></li>
<li><a href="#open-source-tooling-yosysnextpnr">Open Source Tooling (Yosys/nextpnr)</a></li>
</ol>
<hr/>

<p dir="auto">TinyTinyTPU is an educational implementation of Google&#39;s TPU architecture, scaled down to a 2×2 systolic array. It demonstrates:</p>
<ul dir="auto">
<li><strong>Systolic Array Architecture</strong>: Data flows horizontally (activations) and vertically (partial sums)</li>
<li><strong>Diagonal Wavefront Weight Loading</strong>: Staggered weight capture for proper systolic timing</li>
<li><strong>Full MLP Pipeline</strong>: Weight FIFO → MMU → Accumulator → Activation → Normalization → Quantization</li>
<li><strong>Multi-Layer Inference</strong>: Supports sequential layer processing with double-buffered activations</li>
</ul>

<p dir="auto">This is a <strong>minimal, educational-scale TPU</strong> designed for:</p>
<ul dir="auto">
<li>Learning TPU architecture principles</li>
<li>Understanding systolic array dataflow</li>
<li>FPGA prototyping and experimentation</li>
<li>Small-scale ML inference (2×2 matrices)</li>
</ul>
<p dir="auto">For production workloads, scale up the array size (e.g., 256×256 like Google TPU v1).</p>
<hr/>


<p dir="auto"><strong>For Simulation:</strong></p>
<ul dir="auto">
<li>Verilator 5.022 or later</li>
<li>Python 3.8+</li>
<li>cocotb</li>
<li>GTKWave or Surfer (for waveform viewing)</li>
</ul>
<p dir="auto"><strong>For FPGA Build:</strong></p>
<ul dir="auto">
<li>Xilinx Vivado 2020.1 or later (for Basys3)</li>
<li>OR Yosys + nextpnr (open source alternative, see <a href="#open-source-tooling-yosysnextpnr">Open Source Tooling</a>)</li>
</ul>
<p dir="auto"><strong>For Running Inference:</strong></p>
<ul dir="auto">
<li>Basys3 FPGA board</li>
<li>USB cable for programming</li>
<li>Python 3.8+ with pyserial</li>
</ul>

<div dir="auto" data-snippet-clipboard-copy-content="# Clone the repository
git clone &lt;repository-url&gt;
cd tinytinyTPU-co

# Set up simulation environment
cd sim
python3 -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate
pip install -r requirements.txt"><pre><span><span>#</span> Clone the repository</span>
git clone <span>&lt;</span>repository-url<span>&gt;</span>
<span>cd</span> tinytinyTPU-co

<span><span>#</span> Set up simulation environment</span>
<span>cd</span> sim
python3 -m venv venv
<span>source</span> venv/bin/activate  <span><span>#</span> On Windows: venv\Scripts\activate</span>
pip install -r requirements.txt</pre></div>
<hr/>


<p dir="auto">All simulation commands must be run from the <code>sim/</code> directory:</p>
<div dir="auto" data-snippet-clipboard-copy-content="cd sim

# Run all tests
make test

# Run all tests with waveform generation
make test WAVES=1

# Run specific module tests
make test_pe
make test_mmu
make test_mlp
make test_uart
make test_tpu_system

# Run with waveforms
make test_pe WAVES=1"><pre><span>cd</span> sim

<span><span>#</span> Run all tests</span>
make <span>test</span>

<span><span>#</span> Run all tests with waveform generation</span>
make <span>test</span> WAVES=1

<span><span>#</span> Run specific module tests</span>
make test_pe
make test_mmu
make test_mlp
make test_uart
make test_tpu_system

<span><span>#</span> Run with waveforms</span>
make test_pe WAVES=1</pre></div>

<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Test File</th>
<th>Module</th>
<th>Coverage</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>test_pe.py</code></td>
<td>Processing Element</td>
<td>Reset, MAC operations, weight capture</td>
</tr>
<tr>
<td><code>test_mmu.py</code></td>
<td>2×2 Systolic Array</td>
<td>Weight loading, matrix multiply</td>
</tr>
<tr>
<td><code>test_weight_fifo.py</code></td>
<td>Weight FIFO</td>
<td>Push/pop, wraparound</td>
</tr>
<tr>
<td><code>test_dual_weight_fifo.py</code></td>
<td>Dual Weight FIFO</td>
<td>Column independence, skew timing</td>
</tr>
<tr>
<td><code>test_accumulator.py</code></td>
<td>Accumulator</td>
<td>Alignment, buffering, accumulate/overwrite modes</td>
</tr>
<tr>
<td><code>test_activation_func.py</code></td>
<td>Activation Function</td>
<td>ReLU positive/negative/zero cases</td>
</tr>
<tr>
<td><code>test_normalizer.py</code></td>
<td>Normalizer</td>
<td>Gain, bias, shift operations</td>
</tr>
<tr>
<td><code>test_activation_pipeline.py</code></td>
<td>Activation Pipeline</td>
<td>Full pipeline, saturation handling</td>
</tr>
<tr>
<td><code>test_mlp_integration.py</code></td>
<td>MLP Top</td>
<td>Multi-layer MLP inference</td>
</tr>
<tr>
<td><code>test_uart_controller.py</code></td>
<td>UART Controller</td>
<td>Command parsing, response generation</td>
</tr>
<tr>
<td><code>test_tpu_system.py</code></td>
<td>TPU Top</td>
<td>End-to-end system integration</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>

<div dir="auto" data-snippet-clipboard-copy-content="# List available waveforms
make waves

# Open specific waveform
make waves MODULE=pe
make waves MODULE=mmu
make waves MODULE=mlp_top"><pre><span><span>#</span> List available waveforms</span>
make waves

<span><span>#</span> Open specific waveform</span>
make waves MODULE=pe
make waves MODULE=mmu
make waves MODULE=mlp_top</pre></div>
<hr/>


<p dir="auto"><strong>Basys3 Pinout:</strong></p>
<ul dir="auto">
<li><strong>UART RX</strong> (B18): Receives commands from PC</li>
<li><strong>UART TX</strong> (A18): Sends responses to PC</li>
<li><strong>Clock</strong>: 100 MHz (onboard oscillator)</li>
<li><strong>Reset</strong>: Center button (BTNC, U18)</li>
<li><strong>LEDs</strong>: Status display (see <code>fpga/README.md</code> for LED modes)</li>
</ul>
<p dir="auto"><strong>UART Settings:</strong></p>
<ul dir="auto">
<li>Baud Rate: 115200</li>
<li>Data Bits: 8</li>
<li>Parity: None</li>
<li>Stop Bits: 1</li>
</ul>
<hr/>


<p dir="auto">The project includes a Python driver for communicating with the FPGA:</p>
<div dir="auto" data-snippet-clipboard-copy-content="cd host

# Basic inference demo
python3 inference_demo.py

# Gesture recognition demo (requires trained model)
python3 gesture_demo.py

# Interactive test
python3 test_tpu_driver.py"><pre><span>cd</span> host

<span><span>#</span> Basic inference demo</span>
python3 inference_demo.py

<span><span>#</span> Gesture recognition demo (requires trained model)</span>
python3 gesture_demo.py

<span><span>#</span> Interactive test</span>
python3 test_tpu_driver.py</pre></div>

<p dir="auto">The <code>inference_demo.py</code> script demonstrates:</p>
<ol dir="auto">
<li>Loading weights into the TPU</li>
<li>Loading input activations</li>
<li>Executing inference</li>
<li>Reading results</li>
</ol>
<p dir="auto"><strong>Example Usage:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="from tpu_driver import TPUDriver

# Connect to FPGA (adjust port as needed)
tpu = TPUDriver(&#39;/dev/ttyUSB0&#39;)  # Linux
# tpu = TPUDriver(&#39;COM3&#39;)         # Windows

# Load 2×2 weight matrix
weights = [[1, 2], [3, 4]]
tpu.write_weights(weights)

# Load 2×2 activation matrix
activations = [[5, 6], [7, 8]]
tpu.write_activations(activations)

# Execute inference
tpu.execute()

# Read results
result = tpu.read_result()
print(f&#34;Result: {result}&#34;)"><pre><span>from</span> <span>tpu_driver</span> <span>import</span> <span>TPUDriver</span>

<span># Connect to FPGA (adjust port as needed)</span>
<span>tpu</span> <span>=</span> <span>TPUDriver</span>(<span>&#39;/dev/ttyUSB0&#39;</span>)  <span># Linux</span>
<span># tpu = TPUDriver(&#39;COM3&#39;)         # Windows</span>

<span># Load 2×2 weight matrix</span>
<span>weights</span> <span>=</span> [[<span>1</span>, <span>2</span>], [<span>3</span>, <span>4</span>]]
<span>tpu</span>.<span>write_weights</span>(<span>weights</span>)

<span># Load 2×2 activation matrix</span>
<span>activations</span> <span>=</span> [[<span>5</span>, <span>6</span>], [<span>7</span>, <span>8</span>]]
<span>tpu</span>.<span>write_activations</span>(<span>activations</span>)

<span># Execute inference</span>
<span>tpu</span>.<span>execute</span>()

<span># Read results</span>
<span>result</span> <span>=</span> <span>tpu</span>.<span>read_result</span>()
<span>print</span>(<span>f&#34;Result: <span><span>{</span><span>result</span><span>}</span></span>&#34;</span>)</pre></div>

<p dir="auto">The <code>gesture_demo.py</code> script implements a simple gesture classifier:</p>
<ul dir="auto">
<li>Trains a 2-layer MLP on mouse movement data</li>
<li>Classifies gestures as &#34;Horizontal&#34; or &#34;Vertical&#34;</li>
<li>Real-time inference on FPGA</li>
</ul>
<p dir="auto"><strong>Running the Demo:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="cd host
python3 gesture_demo.py"><pre><span>cd</span> host
python3 gesture_demo.py</pre></div>
<p dir="auto"><strong>Model Training:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="cd model
python3 train.py
# Generates: gesture_model.json"><pre><span>cd</span> model
python3 train.py
<span><span>#</span> Generates: gesture_model.json</span></pre></div>

<p dir="auto">The TPU uses a simple byte-based UART protocol:</p>
<p dir="auto"><strong>Commands:</strong></p>
<ul dir="auto">
<li><code>0x01</code>: Write Weight (4 bytes: W00, W01, W10, W11)</li>
<li><code>0x02</code>: Write Activation (4 bytes: A00, A01, A10, A11)</li>
<li><code>0x03</code>: Execute (start inference)</li>
<li><code>0x04</code>: Read Result (returns 4 bytes: acc0[31:0])</li>
<li><code>0x05</code>: Read Result Column 1 (returns 4 bytes: acc1[31:0])</li>
<li><code>0x06</code>: Read Status (returns 1 byte: state[3:0] | cycle_cnt[3:0])</li>
</ul>
<p dir="auto">See <code>host/tpu_driver.py</code> for full protocol implementation.</p>
<hr/>

<div data-snippet-clipboard-copy-content="tinytinyTPU-co/
├── rtl/                          # SystemVerilog RTL source files
│   ├── pe.sv                     # Processing Element (MAC unit)
│   ├── mmu.sv                    # 2×2 Matrix Multiply Unit (systolic array)
│   ├── weight_fifo.sv            # Single-column weight FIFO
│   ├── dual_weight_fifo.sv       # Dual-column weight FIFO with skew
│   ├── accumulator.sv            # Top-level accumulator
│   ├── accumulator_align.sv      # Column alignment logic
│   ├── accumulator_mem.sv        # Double-buffered accumulator memory
│   ├── activation_func.sv        # ReLU/ReLU6 activation
│   ├── normalizer.sv             # Gain/bias/shift normalization
│   ├── loss_block.sv             # L1 loss computation
│   ├── activation_pipeline.sv    # Full post-accumulator pipeline
│   ├── unified_buffer.sv          # Ready/valid output FIFO
│   ├── mlp_top.sv                # Top-level MLP integration
│   ├── tpu_bridge.sv              # UART-to-MLP bridge
│   ├── uart_controller.sv         # UART command processor
│   ├── uart_rx.sv                # UART receiver
│   ├── uart_tx.sv                # UART transmitter
│   └── tpu_top.sv                # Complete TPU system
│
├── sim/                          # Simulation environment
│   ├── Makefile                  # Build and test automation
│   ├── requirements.txt          # Python dependencies
│   ├── tests/                    # cocotb Python testbenches
│   │   ├── test_pe.py
│   │   ├── test_mmu.py
│   │   ├── test_weight_fifo.py
│   │   ├── test_dual_weight_fifo.py
│   │   ├── test_accumulator.py
│   │   ├── test_activation_func.py
│   │   ├── test_normalizer.py
│   │   ├── test_activation_pipeline.py
│   │   ├── test_mlp_integration.py
│   │   ├── test_uart_controller.py
│   │   └── test_tpu_system.py
│   └── waves/                    # Generated VCD waveforms
│
├── fpga/                         # FPGA deployment files
│   ├── basys3_top.sv             # Top-level FPGA wrapper
│   ├── basys3.xdc                # Pin constraints
│   ├── build_vivado.tcl          # Automated build script
│   ├── basys3_top.bit            # Generated bitstream
│   └── README.md                 # FPGA-specific documentation
│
├── host/                         # Python host interface
│   ├── tpu_driver.py             # TPU communication driver
│   ├── tpu_compiler.py           # Model compilation utilities
│   ├── inference_demo.py          # Basic inference demo
│   ├── gesture_demo.py           # Gesture recognition demo
│   └── test_tpu_driver.py        # Driver unit tests
│
├── model/                        # ML model training
│   ├── train.py                  # Model training script
│   └── gesture_model.json        # Trained model (JSON format)
│
└── README.md                     # This file"><pre><code>tinytinyTPU-co/
├── rtl/                          # SystemVerilog RTL source files
│   ├── pe.sv                     # Processing Element (MAC unit)
│   ├── mmu.sv                    # 2×2 Matrix Multiply Unit (systolic array)
│   ├── weight_fifo.sv            # Single-column weight FIFO
│   ├── dual_weight_fifo.sv       # Dual-column weight FIFO with skew
│   ├── accumulator.sv            # Top-level accumulator
│   ├── accumulator_align.sv      # Column alignment logic
│   ├── accumulator_mem.sv        # Double-buffered accumulator memory
│   ├── activation_func.sv        # ReLU/ReLU6 activation
│   ├── normalizer.sv             # Gain/bias/shift normalization
│   ├── loss_block.sv             # L1 loss computation
│   ├── activation_pipeline.sv    # Full post-accumulator pipeline
│   ├── unified_buffer.sv          # Ready/valid output FIFO
│   ├── mlp_top.sv                # Top-level MLP integration
│   ├── tpu_bridge.sv              # UART-to-MLP bridge
│   ├── uart_controller.sv         # UART command processor
│   ├── uart_rx.sv                # UART receiver
│   ├── uart_tx.sv                # UART transmitter
│   └── tpu_top.sv                # Complete TPU system
│
├── sim/                          # Simulation environment
│   ├── Makefile                  # Build and test automation
│   ├── requirements.txt          # Python dependencies
│   ├── tests/                    # cocotb Python testbenches
│   │   ├── test_pe.py
│   │   ├── test_mmu.py
│   │   ├── test_weight_fifo.py
│   │   ├── test_dual_weight_fifo.py
│   │   ├── test_accumulator.py
│   │   ├── test_activation_func.py
│   │   ├── test_normalizer.py
│   │   ├── test_activation_pipeline.py
│   │   ├── test_mlp_integration.py
│   │   ├── test_uart_controller.py
│   │   └── test_tpu_system.py
│   └── waves/                    # Generated VCD waveforms
│
├── fpga/                         # FPGA deployment files
│   ├── basys3_top.sv             # Top-level FPGA wrapper
│   ├── basys3.xdc                # Pin constraints
│   ├── build_vivado.tcl          # Automated build script
│   ├── basys3_top.bit            # Generated bitstream
│   └── README.md                 # FPGA-specific documentation
│
├── host/                         # Python host interface
│   ├── tpu_driver.py             # TPU communication driver
│   ├── tpu_compiler.py           # Model compilation utilities
│   ├── inference_demo.py          # Basic inference demo
│   ├── gesture_demo.py           # Gesture recognition demo
│   └── test_tpu_driver.py        # Driver unit tests
│
├── model/                        # ML model training
│   ├── train.py                  # Model training script
│   └── gesture_model.json        # Trained model (JSON format)
│
└── README.md                     # This file
</code></pre></div>
<hr/>


<div data-snippet-clipboard-copy-content="PE00 -&gt; PE01    Activations flow horizontally (right)
  |       |     
PE10 -&gt; PE11    Partial sums flow vertically (down)
  |       |
acc0    acc1    Outputs to accumulator"><pre><code>PE00 -&gt; PE01    Activations flow horizontally (right)
  |       |     
PE10 -&gt; PE11    Partial sums flow vertically (down)
  |       |
acc0    acc1    Outputs to accumulator
</code></pre></div>
<p dir="auto"><strong>Weight Loading (Diagonal Wavefront):</strong></p>
<ul dir="auto">
<li>Cycle 0: W10 → col0, no capture</li>
<li>Cycle 1: W00 → col0 (capture), W11 → col1 (no capture)</li>
<li>Cycle 2: W01 → col1 (capture)</li>
</ul>
<p dir="auto"><strong>Activation Flow:</strong></p>
<ul dir="auto">
<li>Row 0: A00 → PE00 → PE01</li>
<li>Row 1: A10 → PE10 → PE11 (with 1-cycle skew)</li>
</ul>

<ol dir="auto">
<li><strong>Weight FIFO</strong>: Stores weights, outputs with column skew</li>
<li><strong>MMU (Systolic Array)</strong>: Matrix multiply-accumulate</li>
<li><strong>Accumulator</strong>: Aligns columns, double-buffered storage</li>
<li><strong>Activation Pipeline</strong>:
<ul dir="auto">
<li>Activation function (ReLU/ReLU6)</li>
<li>Normalization (gain × bias + shift)</li>
<li>Quantization (int8 with saturation)</li>
</ul>
</li>
<li><strong>Unified Buffer</strong>: Output FIFO with ready/valid handshaking</li>
</ol>

<p dir="auto">The MLP controller manages sequential layer processing:</p>
<div data-snippet-clipboard-copy-content="State Machine:
IDLE → LOAD_WEIGHT → LOAD_ACT → COMPUTE → DRAIN → TRANSFER → NEXT_LAYER → WAIT_WEIGHTS → ..."><pre><code>State Machine:
IDLE → LOAD_WEIGHT → LOAD_ACT → COMPUTE → DRAIN → TRANSFER → NEXT_LAYER → WAIT_WEIGHTS → ...
</code></pre></div>
<ul dir="auto">
<li><strong>Double Buffering</strong>: Activations ping-pong between buffers for layer-to-layer transfer</li>
<li><strong>Weight Loading</strong>: Weights loaded per layer via UART</li>
<li><strong>Pipeline Overlap</strong>: While layer N drains, layer N+1 weights can be loaded</li>
</ul>
<hr/>
<div dir="auto"><h2 tabindex="-1" dir="auto">Open Source Tooling (Yosys/nextpnr)</h2><a id="user-content-open-source-tooling-yosysnextpnr" aria-label="Permalink: Open Source Tooling (Yosys/nextpnr)" href="#open-source-tooling-yosysnextpnr"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>

<p dir="auto">While Vivado is the standard toolchain for Xilinx FPGAs, open-source alternatives exist:</p>
<ul dir="auto">
<li><strong>Yosys</strong>: Synthesis (RTL → netlist)</li>
<li><strong>nextpnr</strong>: Place &amp; Route (netlist → bitstream)</li>
</ul>

<p dir="auto"><strong>Installation (Ubuntu/Debian):</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="# Install Yosys
sudo apt-get install yosys

# Install nextpnr (for Xilinx 7-series)
# Requires building from source - see nextpnr documentation
git clone https://github.com/YosysHQ/nextpnr.git
cd nextpnr
cmake . -DARCH=xilinx
make -j$(nproc)
sudo make install"><pre><span><span>#</span> Install Yosys</span>
sudo apt-get install yosys

<span><span>#</span> Install nextpnr (for Xilinx 7-series)</span>
<span><span>#</span> Requires building from source - see nextpnr documentation</span>
git clone https://github.com/YosysHQ/nextpnr.git
<span>cd</span> nextpnr
cmake <span>.</span> -DARCH=xilinx
make -j<span><span>$(</span>nproc<span>)</span></span>
sudo make install</pre></div>
<p dir="auto"><strong>Installation (macOS):</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="brew install yosys
# nextpnr requires manual build"><pre>brew install yosys
<span><span>#</span> nextpnr requires manual build</span></pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">Building with Yosys/nextpnr</h3><a id="user-content-building-with-yosysnextpnr" aria-label="Permalink: Building with Yosys/nextpnr" href="#building-with-yosysnextpnr"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><strong>Step 1: Synthesis (Yosys)</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="cd fpga

# Create synthesis script
cat &gt; synth.ys &lt;&lt; &#39;EOF&#39;
# Read RTL files
read_verilog -sv ../rtl/pe.sv
read_verilog -sv ../rtl/mmu.sv
read_verilog -sv ../rtl/weight_fifo.sv
read_verilog -sv ../rtl/dual_weight_fifo.sv
read_verilog -sv ../rtl/accumulator_align.sv
read_verilog -sv ../rtl/accumulator_mem.sv
read_verilog -sv ../rtl/accumulator.sv
read_verilog -sv ../rtl/activation_func.sv
read_verilog -sv ../rtl/normalizer.sv
read_verilog -sv ../rtl/loss_block.sv
read_verilog -sv ../rtl/activation_pipeline.sv
read_verilog -sv ../rtl/unified_buffer.sv
read_verilog -sv ../rtl/mlp_top.sv
read_verilog -sv ../rtl/uart_rx.sv
read_verilog -sv ../rtl/uart_tx.sv
read_verilog -sv ../rtl/uart_controller.sv
read_verilog -sv ../rtl/tpu_bridge.sv
read_verilog -sv ../rtl/tpu_top.sv
read_verilog -sv basys3_top.sv

# Set top module
hierarchy -top basys3_top

# Synthesize
synth_xilinx -top basys3_top -family xc7

# Write netlist
write_verilog basys3_top_synth.v
write_json basys3_top.json
EOF

# Run synthesis
yosys synth.ys"><pre><span>cd</span> fpga

<span><span>#</span> Create synthesis script</span>
cat <span>&gt;</span> synth.ys <span><span>&lt;&lt;</span> &#39;<span>EOF</span>&#39;</span>
<span># Read RTL files</span>
<span>read_verilog -sv ../rtl/pe.sv</span>
<span>read_verilog -sv ../rtl/mmu.sv</span>
<span>read_verilog -sv ../rtl/weight_fifo.sv</span>
<span>read_verilog -sv ../rtl/dual_weight_fifo.sv</span>
<span>read_verilog -sv ../rtl/accumulator_align.sv</span>
<span>read_verilog -sv ../rtl/accumulator_mem.sv</span>
<span>read_verilog -sv ../rtl/accumulator.sv</span>
<span>read_verilog -sv ../rtl/activation_func.sv</span>
<span>read_verilog -sv ../rtl/normalizer.sv</span>
<span>read_verilog -sv ../rtl/loss_block.sv</span>
<span>read_verilog -sv ../rtl/activation_pipeline.sv</span>
<span>read_verilog -sv ../rtl/unified_buffer.sv</span>
<span>read_verilog -sv ../rtl/mlp_top.sv</span>
<span>read_verilog -sv ../rtl/uart_rx.sv</span>
<span>read_verilog -sv ../rtl/uart_tx.sv</span>
<span>read_verilog -sv ../rtl/uart_controller.sv</span>
<span>read_verilog -sv ../rtl/tpu_bridge.sv</span>
<span>read_verilog -sv ../rtl/tpu_top.sv</span>
<span>read_verilog -sv basys3_top.sv</span>
<span></span>
<span># Set top module</span>
<span>hierarchy -top basys3_top</span>
<span></span>
<span># Synthesize</span>
<span>synth_xilinx -top basys3_top -family xc7</span>
<span></span>
<span># Write netlist</span>
<span>write_verilog basys3_top_synth.v</span>
<span>write_json basys3_top.json</span>
<span><span>EOF</span></span>

<span><span>#</span> Run synthesis</span>
yosys synth.ys</pre></div>
<p dir="auto"><strong>Step 2: Place &amp; Route (nextpnr)</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="# Generate bitstream
nextpnr-xilinx \
    --xdc basys3.xdc \
    --json basys3_top.json \
    --write basys3_top_routed.json \
    --fasm basys3_top.fasm

# Generate bitstream (requires Xilinx tools or open-source fasm2bit)
# Note: fasm2bit conversion may require Xilinx tools or open-source alternatives"><pre><span><span>#</span> Generate bitstream</span>
nextpnr-xilinx \
    --xdc basys3.xdc \
    --json basys3_top.json \
    --write basys3_top_routed.json \
    --fasm basys3_top.fasm

<span><span>#</span> Generate bitstream (requires Xilinx tools or open-source fasm2bit)</span>
<span><span>#</span> Note: fasm2bit conversion may require Xilinx tools or open-source alternatives</span></pre></div>
<hr/>

<p dir="auto">The project includes a TCL script for automated Vivado builds:</p>
<div dir="auto" data-snippet-clipboard-copy-content="cd fpga

# Build bitstream (synthesis + implementation + bitgen)
vivado -mode batch -source build_vivado.tcl

# Expected build time: 5-10 minutes
# Output: basys3_top.bit"><pre><span>cd</span> fpga

<span><span>#</span> Build bitstream (synthesis + implementation + bitgen)</span>
vivado -mode batch -source build_vivado.tcl

<span><span>#</span> Expected build time: 5-10 minutes</span>
<span><span>#</span> Output: basys3_top.bit</span></pre></div>
<p dir="auto"><strong>Build Script Details:</strong></p>
<ul dir="auto">
<li>Creates Vivado project: <code>vivado_project/tinytinyTPU_basys3</code></li>
<li>Synthesizes all RTL files from <code>../rtl/</code></li>
<li>Implements design with timing constraints</li>
<li>Generates bitstream: <code>basys3_top.bit</code></li>
<li>Creates reports: utilization, timing, DRC</li>
</ul>
<p dir="auto"><strong>Resource Utilization (Post-Implementation):</strong></p>
<ul dir="auto">
<li>Check <code>vivado_project/tinytinyTPU_basys3.runs/impl_1/utilization_post_impl.rpt</code></li>
<li>Check <code>vivado_project/tinytinyTPU_basys3.runs/impl_1/timing_summary_post_impl.rpt</code></li>
</ul>

<p dir="auto"><strong>Via Vivado Hardware Manager (GUI):</strong></p>
<ol dir="auto">
<li>Connect Basys3 board via USB</li>
<li>Open Vivado</li>
<li>Open Hardware Manager</li>
<li>Auto-connect to target</li>
<li>Program with <code>basys3_top.bit</code></li>
</ol>
<p dir="auto"><strong>Via Command Line:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="vivado -mode tcl
open_hw_manager
connect_hw_server
open_hw_target
set_property PROGRAM.FILE {basys3_top.bit} [get_hw_devices xc7a35t_0]
program_hw_devices [get_hw_devices xc7a35t_0]"><pre>vivado -mode tcl
open_hw_manager
connect_hw_server
open_hw_target
set_property PROGRAM.FILE {basys3_top.bit} [get_hw_devices xc7a35t_0]
program_hw_devices [get_hw_devices xc7a35t_0]</pre></div>
<p dir="auto"><strong>Via OpenOCD (Alternative):</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="# If using OpenOCD with Digilent cable
openocd -f interface/ftdi/digilent_jtag_hs3.cfg -f target/xc7a35t.cfg
# Then use GDB or other tools to program"><pre><span><span>#</span> If using OpenOCD with Digilent cable</span>
openocd -f interface/ftdi/digilent_jtag_hs3.cfg -f target/xc7a35t.cfg
<span><span>#</span> Then use GDB or other tools to program</span></pre></div>
<hr/>
<div dir="auto"><h3 tabindex="-1" dir="auto">Limitations &amp; Considerations</h3><a id="user-content-limitations--considerations" aria-label="Permalink: Limitations &amp; Considerations" href="#limitations--considerations"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><strong>Current Status:</strong></p>
<ul dir="auto">
<li>Yosys synthesis works well for most SystemVerilog constructs</li>
<li>nextpnr supports Xilinx 7-series but may have timing/routing challenges</li>
<li>Bitstream generation (fasm2bit) may require Xilinx tools or open-source alternatives</li>
</ul>
<p dir="auto"><strong>Recommendations:</strong></p>
<ul dir="auto">
<li>For development: Use Vivado for reliable builds</li>
<li>For open-source exploration: Use Yosys for synthesis, verify with Vivado</li>
<li>For production: Stick with Vivado until open-source toolchain matures</li>
</ul>
<p dir="auto"><strong>Future Work:</strong></p>
<ul dir="auto">
<li>Create automated Yosys/nextpnr build script</li>
<li>Document fasm2bit conversion process</li>
<li>Benchmark open-source vs. Vivado results</li>
</ul>
<hr/>


<p dir="auto"><strong>Verilator Errors:</strong></p>
<ul dir="auto">
<li>Ensure Verilator 5.022+ is installed</li>
<li>Check SystemVerilog syntax (use <code>make lint</code>)</li>
</ul>
<p dir="auto"><strong>Test Failures:</strong></p>
<ul dir="auto">
<li>Run with <code>WAVES=1</code> to generate waveforms for debugging</li>
<li>Check <code>sim/test_output.log</code> for detailed error messages</li>
</ul>

<p dir="auto"><strong>Synthesis Errors:</strong></p>
<ul dir="auto">
<li>Check RTL files are in <code>rtl/</code> directory</li>
<li>Verify SystemVerilog syntax (Vivado may be stricter than Verilator)</li>
</ul>
<p dir="auto"><strong>Timing Violations:</strong></p>
<ul dir="auto">
<li>Check <code>timing_summary_post_impl.rpt</code></li>
<li>May need to add pipeline stages or reduce clock frequency</li>
</ul>
<p dir="auto"><strong>Place &amp; Route Failures:</strong></p>
<ul dir="auto">
<li>Check utilization reports</li>
<li>Verify constraints in <code>basys3.xdc</code></li>
</ul>

<p dir="auto"><strong>UART Not Working:</strong></p>
<ul dir="auto">
<li>Verify COM port: <code>ls /dev/ttyUSB*</code> (Linux) or Device Manager (Windows)</li>
<li>Check baud rate: 115200</li>
<li>Verify TX/RX pins in constraints file</li>
</ul>
<p dir="auto"><strong>LEDs Not Responding:</strong></p>
<ul dir="auto">
<li>Check bitstream programmed correctly</li>
<li>Verify reset button (center button)</li>
<li>Check switch settings for LED modes (see <code>fpga/README.md</code>)</li>
</ul>
<hr/>

<p dir="auto">Contributions welcome! Areas for improvement:</p>
<ul dir="auto">
<li>Additional test coverage</li>
<li>Performance optimizations</li>
<li>Documentation improvements</li>
<li>Open-source toolchain support</li>
<li>Larger array sizes</li>
</ul>
<hr/>

<ul dir="auto">
<li><a href="https://arxiv.org/abs/1704.04760" rel="nofollow">Google TPU Paper</a></li>
<li><a href="https://chewingonchips.substack.com/" rel="nofollow">TPU Architecture Blog</a></li>
<li><a href="https://en.wikipedia.org/wiki/Systolic_array" rel="nofollow">Systolic Arrays</a></li>
<li><a href="https://digilent.com/reference/programmable-logic/basys-3/reference-manual" rel="nofollow">Basys3 Reference Manual</a></li>
</ul>
<hr/>

<ul dir="auto">
<li>Inspired by Google&#39;s TPU architecture (thank you Cliff and Richard for your time!)</li>
<li>The boys from the TinyTPU team!!</li>
<li>Edmund and the Yosys / Symbiotic EDA crew</li>
<li>Stanford FAF for the support, funding, and community!</li>
<li>Princeton ECE Dept for the Basys 3 to play around with :)</li>
</ul>
</article></div></div>
  </body>
</html>
