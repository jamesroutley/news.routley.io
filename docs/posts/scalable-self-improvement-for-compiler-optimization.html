<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://research.google/blog/scalable-self-improvement-for-compiler-optimization/">Original</a>
    <h1>Scalable self-improvement for compiler optimization</h1>
    
    <div id="readability-page-1" class="page"><div data-gt-publish-date="20241023">
                    
                    
    


<section>
    <div>
        
  <div data-gt-id="rich_text" data-gt-component-name="">
    




    <p data-block-key="wr9te">Most systems we regularly interact with, such as computer operating systems, are faced with the challenge of providing good performance, while managing limited resources like computational time and memory. Since it is challenging to optimally manage these resources, there is increasing interest in the use of machine learning (ML) to make this decision-making data driven rather than heuristic. In compiler optimization, <a href="https://en.wikipedia.org/wiki/Inline_expansion" target="_blank" rel="noopener noreferrer">inlining</a> is the process of replacing a call to a function in a program with the body of that function. <i>Inlining for size</i> aims to minimize the size of the final <a href="https://en.wikipedia.org/wiki/Binary_file" target="_blank" rel="noopener noreferrer">binary file</a> by removing redundant code.</p><p data-block-key="e6iut">Size is a constraining factor for many applications, such as on-device products, where an increase can hinder performance or even prevent the updating and use of some products. Inlining decisions are a key component that a compiler can optimize, with changes in this decision resulting in a final software binary of significantly different size. <a href="http://research.google/blog/mlgo-a-machine-learning-framework-for-compiler-optimization/">Prior work</a> has successfully applied <a href="https://en.wikipedia.org/wiki/Reinforcement_learning" target="_blank" rel="noopener noreferrer">reinforcement learning</a> (RL) algorithms to train effective inlining policies, which have been deployed in several systems. However, most RL algorithms are sensitive to reward signals and require careful hyperparameter tuning to avoid instability and poor performance. Consequently, as the underlying system changes, the RL algorithms must be run again, which is both costly and unreliable in deployment.</p><p data-block-key="a72o0">To that end, in “<a href="https://arxiv.org/abs/2403.19462" target="_blank" rel="noopener noreferrer">Offline Imitation Learning from Multiple Baselines with Applications to Compiler Optimization</a>”, to be presented at the <a href="https://mlforsystems.org/" target="_blank" rel="noopener noreferrer">ML For Systems</a> workshop at <a href="https://neurips.cc/Conferences/2024" target="_blank" rel="noopener noreferrer">NeurIPS 2024</a>, we introduce Iterative BC-Max, a novel technique that aims to reduce the size of the compiled binary files by improving inlining decisions. Iterative BC-Max produces a decision-making policy by solving carefully designed supervised learning problems instead of using unstable and computationally demanding RL algorithms. We describe several benefits to using this approach, including fewer compiler interactions, robustness to unreliable reward signals, and only solving binary classification problems instead of more cumbersome RL problems.</p>
</div>

    </div>
</section>

                    
                    
    


<section>
    
</section>

                    
                    
    


<section>
    <div>
        
  <p data-block-key="wr9te">As described in <a href="http://research.google/blog/mlgo-a-machine-learning-framework-for-compiler-optimization/">prior work</a>, real code has thousands of functions that call each other, forming a <a href="https://en.wikipedia.org/wiki/Call_graph" target="_blank" rel="noopener noreferrer">call graph</a>. In the inlining process, a compiler reviews each caller-callee pair to decide if it should be inlined or not. Precisely, at each decision point, we observe a set of features or inputs (called a “state”) associated with the local call graph at the function we are considering for inlining. Each feature captures relevant information for the inlining decision. We have two decisions or actions to choose from {inline, not inline}, and the chosen decision can alter the call graph, influencing future inlining decisions and the final outcome.</p>

    </div>
</section>

                    
                    
    


<section>
    
</section>

                    
                    
    


<section>
    <div>
        
  <p data-block-key="wr9te">The goal is to design an inlining decision policy, that can make inlining decisions at all observed states as we compile a program, with the goal of reducing the size of the resulting binary.</p>

    </div>
</section>

                    
                    
    


<section>
    
</section>

                    
                    
    


<section>
    <div>
        
  <div data-gt-id="rich_text" data-gt-component-name="">
    


    <p>
        
            
                <h2>Iterative BC-Max: Offline imitation learning for the inlining problem</h2>
            
        
        
    </p>



    
</div>

    </div>
</section>

                    
                    
    


<section>
    <div>
        
  <div data-gt-id="rich_text" data-gt-component-name="">
    




    <p data-block-key="wr9te">We address the inlining for size problem by developing Iterative BC-Max, a novel <a href="https://proceedings.neurips.cc/paper_files/paper/1988/file/812b4ba287f5ee0bc9d43bbf5bbe87fb-Paper.pdf" target="_blank" rel="noopener noreferrer"><i>imitation</i></a> <a href="https://arxiv.org/pdf/1011.0686" target="_blank" rel="noopener noreferrer"><i>learning</i></a> approach that constructs and solves a sequence of carefully designed classification problems. When given the input state, the inlining for size classification problem must make an inlining decision by choosing the correct label (i.e., <i>inline</i> or <i>not inline</i>). At a high-level, Iterative BC-Max alternates between program compilation and learning a new compilation policy. The compilation step compiles a large corpus of programs in parallel, while the learning step trains a new policy, performing many updates until the classification problem is solved accurately.</p><p data-block-key="be4q5">Iterative BC-Max interleaves compilation of all programs with the training of a new policy on classification problems. When applying Iterative BC-Max to the inlining for size problem, we only need to repeat the compilation step a few times, using significantly fewer compilation passes than standard RL algorithms. Further, the binary classification approach is more robust to sparse or unreliable reward signals, which are common for systems problems.</p>
</div>

    </div>
</section>

                    
                    
    


<section>
    
</section>

                    
                    
    


<section>
    <div>
        
  <div data-gt-id="rich_text" data-gt-component-name="">
    




    <p data-block-key="wr9te">The first step of our algorithm is to compile the program corpus, consisting of representative programs of the binaries we target for size reduction, using a set of baseline policies, so that every program is compiled with every policy. Examples of baseline policies correspond to various hand-designed heuristics or even previously learned policies. This determines the best baseline for each program, that is the baseline whose inlining decisions result in the smallest compiled program size. We note that each program is different, and we want to compile each one in the best possible way.</p><p data-block-key="5qdkm">We create a dataset composed of the best inlining decisions for each state within every program in the corpus to be used in the learning step of the algorithm. Compilation is distributed on as many machines as possible. Further, we introduce additional exploration when compiling a fixed program with an inlining policy by selecting steps in the compilation where we deviate from the inlining policy’s decision. The initial set of baseline policies can be as small as a single policy, which we assume is always available.</p>
</div>

    </div>
</section>

                    
                    
    


<section>
    <div>
        
  <div data-gt-id="rich_text" data-gt-component-name="">
    


    <p>
        
            
                <h3>Imitation learning for best per-program baseline</h3>
            
        
        
    </p>



    
</div>

    </div>
</section>

                    
                    
    


<section>
    <div>
        
  <div data-gt-id="rich_text" data-gt-component-name="">
    




    <p data-block-key="wr9te">Next, Iterative BC-Max learns a new policy by imitating the sequence of inlining decisions that lead to the best performance for each program as depicted in the figure below. This is achieved by training the policy to match the decision from the inlining dataset, which contains the best sequence of decisions for each program. The dataset saved after compiling the program corpus consists of state-inline decision pairs. The learning algorithm then tries to find a new policy that consists of the inlining decision for every pair in the dataset.</p><p data-block-key="br3mi">This can be cast as a standard classification problem, where inputs are the observed states and labels are the desired inlining decision for the state, which we collected in the previous step. Such classification problems can be solved using standard ML techniques.</p>
</div>

    </div>
</section>

                    
                    
    


<section>
    
</section>

                    
                    
    


<section>
    <div>
        
  <p data-block-key="wr9te">Typically, supervised learning algorithms minimize the average classification error, that is the returned policy will be accurate on average across all inlining decisions in the training set. RL experts familiar with imitation learning will recognize that this approach can suffer from distribution shift. That is, the returned policy, trained on the data collected with the baselines, might result in a very different program size, when all inlining decisions are made according to this new policy. To combat such behavior we add weights to the classification objective which leads to a new policy, shown as <i><span>𝜋</span></i><i><sub><span>new</span></sub></i> above, that maximizes the size savings over the worst program in the dataset, making the trained policy more robust to distribution shift.</p>

    </div>
</section>

                    
                    
    


<section>
    
</section>

                    
                    
    


<section>
    <div>
        
  <p data-block-key="wr9te">In practice, Iterative BC-Max starts with a set of baseline policies, then at each iteration it alternates between compiling a corpus of programs and learning to follow the best per program inlining decisions. At the end of the <i>K</i>-th iteration the algorithm obtains the new policy, <i><span>𝜋</span></i><i><sub><span>new</span></sub></i>. If the policy has desirable performance in terms of sizes of the compiled programs, we stop and return this policy to be subsequently referenced by the compiler for future inlining decisions. If not, we add <i><span>𝜋</span></i><i><sub><span><span>K+1</span></span></sub></i> to the <i>K</i> previous policies <i><span>𝜋</span></i><i><sub><span>1</span></sub></i><i>,</i><i><span>𝜋</span></i><i><sub><span>2</span></sub></i><i>,...,</i><i><span>𝜋</span></i><i><sub><span>K</span></sub></i>. This creates a self-improvement loop where we improve on the best policy so far. In practice the value of <i>K</i> is usually between 5 to 10.</p>

    </div>
</section>

                    
                    
    


<section>
    
</section>

                    
                    
    


<section>
    
</section>

                    
                    
    


<section>
    <div>
        
  <p data-block-key="wr9te">We apply Iterative BC-Max to an inlining for size problem where the programs make up a search application binary and there are approximately 30,000 programs. The baseline policy set is initialized with a hand-designed heuristic inlining policy, and another policy trained using <a href="https://github.com/google/ml-compiler-opt/releases/tag/inlining-Oz-v1.1" target="_blank" rel="noopener noreferrer">an</a> <a href="https://research.google/blog/mlgo-a-machine-learning-framework-for-compiler-optimization/">evolutionary strategy</a>. After seven iterations of our algorithm we find a size reduction of approximately 1% compared to the evolutionary strategy baseline. See the <a href="https://arxiv.org/abs/2403.19462" target="_blank" rel="noopener noreferrer">paper</a> for more detailed results.</p>

    </div>
</section>

                    
                    
    


<section>
    <div>
        
  <div data-gt-id="rich_text" data-gt-component-name="">
    


    <p>
        
            
                <h2>Extensions and future work</h2>
            
        
        
    </p>



    
</div>

    </div>
</section>

                    
                    
    


<section>
    <div>
        
  <p data-block-key="wr9te">Iterative BC-Max is very general and can be applied to multiple different systems optimization problems, even beyond compiler optimization. One immediate application is for <i>register allocation for speed</i> and <i>inlining for speed</i>, where the goal is to produce binaries with improved runtime performance. Other possible applications include optimizing the <a href="https://openxla.org/xla" target="_blank" rel="noopener noreferrer">XLA compiler</a>. We are excited to explore such novel directions.</p>

    </div>
</section>

                    
                    
    


<section>
    
</section>

                    
                    
    


<section>
    <div>
        
  <p data-block-key="wr9te"><i>We would like to thank Mircea Trofin for all of his contributions that led to successfully deploying this algorithm, including implementation, help with the compiler side, and fostering tight collaboration with other Google teams. Thanks to Yundi Qian for introducing us to the MLGO effort and initial compiler optimization problems. We also thank Jacob Hegna for help with the RL interface. Finally, thanks to Hans Wennborg and Jin Xin Ng for facilitating the product deployment in external facing Google products.</i></p>

    </div>
</section>

                    
                </div></div>
  </body>
</html>
