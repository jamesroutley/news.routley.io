<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://the-dam.org/docs/explanations/suc.html">Original</a>
    <h1>Simple Unix Chat</h1>
    
    <div id="readability-page-1" class="page"><div id="content">

<p>
The title oversells the content a bit:
</p>
<ul>
<li>first, Slack (or Mattermost, or even the Internet Relay Chat (IRC)) offer
slightly more features than the <i>Simple Unix Chat</i> system (<code>suc</code>), the topic
of this piece;</li>
<li>then, <code>suc</code>’s actual line count exceeds five.</li>
</ul>

<p>
Nevertheless, <code>suc</code>’s core indeed consists of five lines of bash;
and <code>suc</code> provides Slack, Mattermost, <i>etc.</i>’s core features:
</p>
<ul>
<li>Real-time, rich-text chat,</li>
<li>File sharing,</li>
<li>Fine-grained access control,</li>
<li>Straightforward automation and integration with other tools,</li>
<li>Data encryption in transit</li>
<li>and optionally at rest,</li>
<li>state-of-the-art user authentication.</li>
</ul>


<p>
This paper shows how <code>suc</code> implements those features.
<code>suc</code> stays small by leveraging the consistent and composable primitives offered by modern UNIX implementations
<sup><a id="fnr.1" href="#fn.1" role="doc-backlink">1</a></sup>.
</p>

<div id="outline-container-orgefe782e">
<h2 id="orgefe782e">Line count matters</h2>
<div id="text-orgefe782e">
<blockquote>
<p>
One of my most productive days was throwing away 1000 lines of code.
– Ken Thompson, <a href="https://skeptics.stackexchange.com/questions/43800/did-the-creator-of-unix-say-one-of-my-most-productive-days-was-throwing-away-10">apparently</a>
</p>
</blockquote>
<blockquote>
<p>
Measuring programming progress by lines of code is like measuring aircraft
building progress by weight.
– Bill Gates, (probably apocryphal)
</p>
</blockquote>
<blockquote>
<p>
Some of the managers decided that it would be a good idea to track the progress
of each individual engineer in terms of the amount of code that they wrote from
week to week.
[…]
When he got to the lines of code part, [Bill Atkinson] […] wrote in the number: -2000.
– <a href="https://www.folklore.org/StoryView.py?story=Negative_2000_Lines_Of_Code.txt">https://www.folklore.org/StoryView.py?story=Negative_2000_Lines_Of_Code.txt</a>
</p>
</blockquote>
<blockquote>
<p>
Their fundamental design flaws are completely hidden by their superficial design
flaws.
– Douglas Adams
</p>
</blockquote>
<blockquote>
<p>
There are two ways of constructing a software design: One way is to make it so
simple that there are obviously no deficiencies, and the other way is to make it
so complicated that there are no obvious deficiencies.
– Tony Hoare
</p>
</blockquote>
<p>
Despite the wide consensus among competent programmers that <a href="https://wiki.c2.com/?SoftwareAsLiability">code is a liability</a>,
almost every widely-distributed piece of software is a complexity behemoth.
</p>

<p>
Case in point, let’s examine Mattermost’s line count:
</p>
<div>
<pre><span>cd</span> /tmp
<span>git</span> clone --depth=<span>1</span> https://github.com/mattermost/mattermost-server
<span>cd</span> mattermost-server
guix shell cloc -- cloc --quiet --timeout <span>0</span> .
</pre>
</div>

<pre id="org6c7ec21">github.com/AlDanial/cloc v 1.96  T=14.34 s (606.7 files/s, 139790.0 lines/s)
-------------------------------------------------------------------------------
Language                     files          blank        comment           code
-------------------------------------------------------------------------------
Go                            1805          96705          26782         501249
JSON                           177              5              0         492604
TypeScript                    4125          74236          24557         480491
JavaScript                     811          21494          20745          68653
SCSS                           557           9164            359          51464
HTML                            54           6108           1167          37814
JSX                             92           3473           1054          29707
SQL                            807           3553           2253          18266
Text                            11           3824              0          10638
YAML                            45            126             96           7972
SVG                             68              6             12           2586
Markdown                        73            906             88           2168
make                             8            234             68            974
GraphQL                          4             65              2            596
XML                             29             10              1            572
Bourne Shell                    18            128             17            492
CSS                              5             70              0            385
Dockerfile                       4             14              8             46
CSV                              2              0              0             25
diff                             2              1             13              9
INI                              1              2              0              7
-------------------------------------------------------------------------------
SUM:                          8698         220124          77222        1706718
-------------------------------------------------------------------------------
</pre>

<p>
<b><b>Half a million lines</b></b> of Go, and again <b><b>half a million</b></b> lines of
TypeScript. Just for the server !
</p>

<p>
Let’s compare with <code>suc</code>:
</p>
<div>
<pre><span>cd</span> /tmp
<span>git</span> clone --depth=<span>1</span>  https://gitlab.com/edouardklein/suc
<span>cd</span> suc
guix shell cloc -- cloc --quiet --timeout <span>0</span> .
</pre>
</div>

<pre id="orga4ac3ca">github.com/AlDanial/cloc v 1.96  T=0.01 s (475.8 files/s, 8207.6 lines/s)
--------------------------------------------------------------------------------
Language                      files          blank        comment           code
--------------------------------------------------------------------------------
Bourne Again Shell                1              2              2             19
C                                 1              3              3             17
make                              1              3              0             14
Bourne Shell                      1              0              1              5
--------------------------------------------------------------------------------
SUM:                              4              8              6             55
--------------------------------------------------------------------------------
</pre>
<p>
<code>suc</code> can implement Mattermost’s core features <b><b>with 0.005% of the code</b></b>. This is madness !
</p>
</div>
</div>
<div id="outline-container-orga8279f6">
<h2 id="orga8279f6"><code>suc</code>’s core loop</h2>
<div id="text-orga8279f6">
<p>
Behold the five lines of bash that do as much as half a million lines of Go:
</p>
<div>
<pre><span>while</span> /usr/bin/true
<span>do</span>
    <span>read</span> -r line || <span>exit</span> <span>0</span>  <span># </span><span>EOF</span>
    /usr/bin/echo <span>&#34;</span><span>$(/usr/bin/date --iso-8601=seconds)</span><span>&#34;</span><span>\</span>
        <span>&#34;</span><span>$(printf &#34;%-9s&#34; &#34;$(/usr/bin/id --user --name --real)</span><span>&#34;)&#34;</span> <span>\</span>
        <span>&#34;</span><span>$</span><span>line</span><span>&#34;</span> &gt;&gt; /var/lib/suc/<span>&#34;</span><span>$</span><span>1</span><span>&#34;</span>
<span>done</span>
</pre>
</div>
<p>
This infinite loop:
</p>
<ul>
<li>reads a line from standard input,</li>
<li>prefixes it with:
<ul>
<li>the date,</li>
<li>the real user name,</li>
</ul></li>
<li>and appends it to a file in <code>/var/lib/suc/</code></li>
</ul>


<p>
Surely, you think, this cannot do. What about authentication, access control, encryption, rich text, <i>etc.</i> ?
</p>

<p>
<code>suc</code> does all that by leveraging SSH, UNIX’s access control API, and UNIX’s text-based modularity.
</p>
</div>
</div>
<div id="outline-container-org14b6181">
<h2 id="org14b6181">Authentication</h2>
<div id="text-org14b6181">
<p>
The <code>suc</code> process can only be launched by an authenticated user
<sup><a id="fnr.2" href="#fn.2" role="doc-backlink">2</a></sup>.
Therefore, <code>suc</code> contains no authentication code at all.
All the authentication stuff happens before <code>suc</code> even starts.
</p>

<p>
As with almost all UNIX servers nowadays,
remote authentication is handled by <code>ssh</code>.
Before granting them the ability to start <code>suc</code>, <code>ssh</code> requires users to prove their identity.
</p>

<p>
This proof can take the form
</p>
<ul>
<li>of a shared secret (<i>i.e.</i> a password),</li>
<li>of a cryptographic challenge (as is the case on <a href="https://the-dam.org">the dam</a>),</li>
<li>of the use of a One-Time-Passord (OTP) generating device,</li>
<li>or of any combination of the above (also known as Multi-Factor Authentication, MFA).</li>
</ul>


<p>
<code>ssh</code> also authenticates the server to the client,
thus preventing <i>Man-in-the-Middle</i> (MitM) attacks.
</p>

<p>
Last but not least, <code>ssh</code> encrypts all data between the clients and the server.
</p>

<p>
A successful installation of <code>suc</code> therefore depends on a correct configuration
of the UNIX host and its <code>ssh</code> server.
To use <code>suc</code>, a user needs to exist on the system;
and the <code>ssh</code> server needs to be configured to let her remotely log in.
</p>

<p>
Most UNIX distribution provide the <code>useradd</code>, <code>passwd</code>, <i>etc.</i> commands for user management
(creation, deletion, assignation to one or more groups, <i>etc.</i>).
The <code>ssh</code> server reads its configuration from a text file in <code>/etc/</code>
(typically <code>/etc/ssh/sshd_config</code>), and from public key files
(typically in <code>/home/&lt;user&gt;/.ssh/authorized_keys</code>).
</p>

<p>
<a href="https://the-dam.org">The dam</a> server uses GNU Guix.
GNU Guix differs from almost all other UNIX distributions,
because it uses declarative configuration.
This means that <code>root</code> just has to say what she wishes the configuration to be.
The system then complies and reconfigures itself to match <code>root</code>’s declaration.
</p>

<p>
For example, granting <code>ssh</code> access to <code>alice</code> on a GNU Guix system
<sup><a id="fnr.3" href="#fn.3" role="doc-backlink">3</a></sup>
requires only the following line in the system’s configuration file:
</p>
<div>
<pre> (ssh-user <span>&#34;alice&#34;</span> <span>#:groups</span> &#39;(<span>&#34;c3n&#34;</span> <span>&#34;frenchies&#34;</span>)
                   <span>#:keys</span> &#39;((plain-file <span>&#34;alice.pub&#34;</span> <span>&#34;SOMESSHKEY&#34;</span>)))
</pre>
</div>
<p>
User <code>alice</code> exists on the system only as long as the line exists in the configuration file.
When the line disappears, the reconfiguration process removes user <code>alice</code>, and she can no longer log in.
</p>

<p>
Some big advantages of declarative configuration systems include:
</p>
<ul>
<li>removing the need for clean up actions when removing functionality:
once it is no longer part of the declaration,
it will be removed from the system automatically.</li>
<li>the ability to clone a specific configuration
by just replicating the declaration;
useful for back-ups, failovers, <i>etc.</i>.</li>
</ul>


<p>
Among the disadvantages,
one counts an increased difficulty for quick and dirty setups
(usually for a quick test to try out a piece of software).
New tools (such as e.g. <code>guix shell</code>) allows one to sidestep this difficulty.
</p>

<p>
In such a declarative system,
<code>suc</code>’s overhead per user is limited to a single line in the global configuration file.
One cannot need less,
and current chat systems need more.
</p>
</div>
</div>
<div id="outline-container-orgc7dc063">
<h2 id="orgc7dc063">Access control</h2>
<div id="text-orgc7dc063">
<p>
As with authentication, <code>suc</code> contains no access control code whatsoever.
This combination of caring about neither authentication nor access control is called <i>security agnosticism</i>.
<i>Security anosticism</i> allows <code>suc</code> to be lean,
and therefore more probably correct (and so, paradoxically, more secure) than its heavier counterparts.
</p>

<p>
On UNIX, software can afford to be <i>security agnostic</i>
because the system provides a clean and powerful API for access control:
the kernel knows about
</p>
<ul>
<li>users and groups,</li>
<li>processes and files.</li>
</ul>


<p>
Let’s dive in.
</p>

<p>
UNIX veterans will have noticed that <code>suc</code> prefixes the user’s messages with her <i>real</i> name.
Indeed, files have an owner (a user),
whereas processes have two owners (two users). The <i>real</i> one and the <i>effective</i> one.
</p>

<p>
Most of the time, <i>real</i> and <i>effective</i> owners are the same.
<code>suc</code>’s ownership differs:  it <i>effectively</i> belongs to a special user also named <code>suc</code>;
it <i>really</i> belongs to whoever (<i>e.g.</i> user <code>alice</code>) launched the <code>suc</code> command
<sup><a id="fnr.4" href="#fn.4" role="doc-backlink">4</a></sup>.
</p>

<p>
The kernel examines the <i>effective</i> ownership of a process
to determine said process’ ability to read or write to files.
</p>

<p>
With that in mind, let’s examine the content of <code>/var/lib/suc</code> on <a href="https://the-dam.org">the dam</a>:
</p>
<div>
<pre>ssh -i ~/.ssh/id_rsa edk@the-dam.org <span>ls</span> -l /var/lib/suc
</pre>
</div>

<pre>total 92
-rw-r----- 1 suc c3n            44368 Apr 13 19:18 banane
-rw-r----- 1 suc forbiddenlands  6234 Apr 13 21:04 forbiddenlands
-rw-r----- 1 suc frenchies         62 Apr 21 22:23 frenchies
-rw-r----- 1 suc guixdevs           0 Apr 22 15:39 guix
-rw-r----- 1 suc iwp9            4181 Apr 21 21:46 iwp9
-rw-r----- 1 suc users          18241 Jun 30 07:14 the-dam
-rw-r----- 1 suc wb3c             188 May 10 11:56 wb3c
</pre>


<p>
The files in <code>/var/lib/suc</code> belong to <code>suc</code>;
only <code>suc</code> can read and write those files
<sup><a id="fnr.5" href="#fn.5" role="doc-backlink">5</a></sup>.
</p>

<p>
Any other user, such as <code>alice</code>, may read some of the files (e.g. <code>banane</code>),
provided she belongs to the appropriate <i>group</i> (e.g. <code>c3n</code>).
</p>

<p>
With this configuration,
<code>suc</code> does not need to care about access control at all.
For example <code>suc</code> need not match a user against the list of authorized readers or writers of a <i>channel</i>.
</p>

<p>
Instead, <code>usuc</code><sup><a id="fnr.6" href="#fn.6" role="doc-backlink">6</a></sup>
will just happily always <i>try</i> to read or write the file.
The kernel will do the matching and prevent any unauthorized access.
</p>

<p>
On <a href="https://the-dam.org">the dam</a>, everyone can start <code>suc</code>, whose <i>effective</i> owner will be the user
<code>suc</code>, who has the right to write into any channel. By design, any user on <a href="https://the-dam.org">the dam</a>
can request membership into a group by blindly writing a request to the
group’s channel.
</p>

<p>
Less loosely-managed communities may wish to restrict channel write access to members only.
<code>root</code> achieves this by maintaining multiple copies of the <code>suc</code> binary.
</p>

<p>
Let’s assume that
</p>
<ul>
<li><code>alice</code> and <code>bob</code> belong to the <code>blue</code> group,</li>
<li>while <code>eve</code> and <code>mallory</code> belong to the <code>red</code> group.</li>
</ul>


<p>
<code>root</code> creates <code>nobody</code>-like<sup><a id="fnr.7" href="#fn.7" role="doc-backlink">7</a></sup> users <code>red</code> and <code>blue</code>. She then creates two copies of <code>suc</code>, one for
each group:
</p>
<div>
<pre><span>ls</span> -l /usr/bin/suc*
total <span>32</span>
-rwsr-xr-- <span>1</span> red     red      <span>15624</span> Jun  <span>4</span> 10:51 suc_red
-rwsr-xr-- <span>1</span> blue    blue     <span>15624</span> Jun  <span>4</span> 10:56 suc_blue
</pre>
</div>
<p>
And she also creates one channel for each team:
</p>
<div>
<pre><span>ls</span> -l /var/lib/suc/
total <span>16</span>
-rw-r----- <span>1</span> blue     blue     <span>11027</span> Jun  <span>4</span> 11:30 blue
-rw-r----- <span>1</span> red      red      <span>17</span>    Jun  <span>4</span> 10:53 red
</pre>
</div>
<p>
One can see that:
</p>
<ul>
<li><code>alice</code> and <code>bob</code> belong to group <code>blue</code>.
<ul>
<li>They can read the <code>blue</code> channel. Indeed the file <code>/var/lib/suc/blue</code>
belongs to group <code>blue</code> and has mode <code>-rw-r-----</code> : the second <code>r</code> means
that members of the owning group (here, <code>blue</code>), can read the file (but not
write to it).</li>
<li>They cannot directly write to the file.
Only user <code>blue</code> can.</li>
<li>They can however launch the <code>/usr/bin/suc_blue</code> program,
because group <code>blue</code> owns it,
and it has mode <code>-rwsr-xr--</code> .
The <code>x</code> means that members of the owning group (here, <code>blue</code>) can start the program.</li>
<li>This program will run with user <code>blue</code> as the <i>effective</i> owner:
User <code>blue</code> owns the file
and <code>root</code> has set its setuid bit
(the <code>s</code> in the mode line says so).</li>
<li>Therefore, <code>alice</code> and <code>bob</code>, being members of the <code>blue</code> group, can launch the <code>/usr/bin/suc_blue</code> program,
which being <i>effectively</i> owned by user <code>blue</code>
(despite being launched by <code>alice</code> or <code>bob</code> who will be the <i>real</i>, but not <i>effective</i> owner)
can write to the <code>/var/lib/suc/blue</code> file.</li>
</ul></li>
<li><code>eve</code> and <code>mallory</code> belong to group <code>red</code> (but not group <code>blue</code>).
<ul>
<li>They cannot read the <code>blue</code> channel.
Indeed, people other than user <code>blue</code> or members of group <code>blue</code> have no rights on the <code>/var/lib/suc/blue</code> file
(the end of its mode line is <code>---</code>).</li>
<li>They cannot write to the <code>blue</code> channel directly,
only user <code>blue</code> can.</li>
<li>They cannot start the <code>/usr/bin/suc_blue</code> program,
because they do not belong to group <code>blue</code>.
The only thing they can do to this file is read it (its mode line ends in <code>r--</code>).</li>
<li>Therefore they can neither read nor write the <code>blue</code> channel.</li>
</ul></li>
</ul>


<p>
To relieve <code>root</code> from the cumbersome and error-prone process of setting this all up,
<code>suc</code> provides an 80-something-lines long helper script called <a href="https://gitlab.com/edouardklein/suc/-/blob/master/suc_channel.sh"><code>suc_channel.sh</code></a>.
</p>

<p>
GNU Guix users can create a <code>suc</code> channel by
adding a single line to the system’s configuration file:
</p>
<pre>(suc-private-channel &#34;red&#34; &#34;red&#34;)
</pre>

<p>
This line takes care of creating the necessary
</p>
<ul>
<li><code>suc_red</code> setuid binary,</li>
<li><code>red</code> user</li>
<li><code>red</code> group</li>
<li><code>red</code> channel file.</li>
</ul>


<p>
Here, GNU Guix’s declarative configuration paradigm shines again. The
<code>suc_channel.sh</code> script may fail halfway, leaving the system in an undetermined
state, whereas GNU Guix provides <i>transactional</i> updates: either the transition
happens fully or it does not at all. The system always stays in a known clean
state. One can even roll-back to a previous working state (see <a href="https://guix.gnu.org/en/blog/2018/multi-dimensional-transactions-and-rollbacks-oh-my/">Multi-dimensional
transactions and rollbacks, oh my!</a>).
</p>

<p>
GNU Guix also automatically computes which groups, users, and setuid binaries
should exist on the system. When <code>root</code> removes a private channel (e.g. <code>red</code>),
she must assess whether the associated group (also named <code>red</code>), user (also
<code>red</code>), and setuid binary (<code>suc_red</code>) should stay or go. That entails looking at
the other channels to see if any of them is still owned by user <code>red</code> or group
<code>red</code>. Again, a cumbersome and error prone task whereas on GNU Guix, <code>root</code> just
removes the channel’s line from the system declaration. The <code>red</code> group, <code>red</code>
user, and <code>suc_red</code> binary will stay if and only if another part of the system
needs them.
</p>

<p>
As an illustration, here is a full system declaration for the above example. One
can hardly be simpler than that.
</p>
<div>
<pre>(<span>begin</span> (use-modules
        (gnu packages base)
        (guix gexp)
        (beaver system)
        (beaver packages plan9)
        (beaver functional-services))
       (-&gt; (minimal-ovh)
           (ssh-user <span>&#34;alice&#34;</span>   <span>#:groups</span> &#39;(<span>&#34;suc&#34;</span> <span>&#34;blue&#34;</span>) <span>#:keys</span> &#39;())
           (ssh-user <span>&#34;bob&#34;</span>     <span>#:groups</span> &#39;(<span>&#34;suc&#34;</span> <span>&#34;blue&#34;</span>) <span>#:keys</span> &#39;())
           (ssh-user <span>&#34;eve&#34;</span>     <span>#:groups</span> &#39;(<span>&#34;suc&#34;</span> <span>&#34;red&#34;</span>)  <span>#:keys</span> &#39;())
           (ssh-user <span>&#34;mallory&#34;</span> <span>#:groups</span> &#39;(<span>&#34;suc&#34;</span> <span>&#34;red&#34;</span>)  <span>#:keys</span> &#39;())
           (suc-private-channel <span>&#34;red&#34;</span> <span>&#34;red&#34;</span>)
           (suc-private-channel <span>&#34;blue&#34;</span> <span>&#34;blue&#34;</span>)
           (suc-public-channel <span>&#34;purple&#34;</span>)))
</pre>
</div>
</div>
</div>
<div id="outline-container-org76ce31c">
<h2 id="org76ce31c">Fancy text</h2>
<div id="text-org76ce31c">
<p>
We have seen how <code>suc</code> is <i>security-agnostic</i>, relying on:
</p>
<ul>
<li><code>ssh</code> for authentication,</li>
<li>UNIX’s file and process ownership and permission model for access control.</li>
</ul>


<p>
Let’s now dive into the featureful side of things by first looking at some bells
and whistles: rich text.
</p>

<p>
Most chat applications nowadays piggyback on an HTML engine to render the chat’s
text. For example <a href="https://github.com/mattermost/desktop">mattermost’s client</a> uses <a href="https://www.electronjs.org/">Electron</a>. There go another few tens of
thousand of lines of code.
</p>

<p>
On the one hand, this adds tremendous complexity and increases the attack
surface of the application. On the other hand it lets the chat display elements
in a complex layout, or embed interactive widgets within the messages (such as
emoji reactions), etc.
</p>

<p>
<code>suc</code> uses one file per channel. This text file is meant to be displayed to the
user with a command-line tool such as <code>tail</code> or <code>cat</code>.
</p>

<p>
Before everything got shoehorned into an HTML rendering engine, people managed
to display rich text, boxes, and even primitive graphics on their terminals.
These capabilities more-or-less coalesced into something called ANSI escape
codes<sup><a id="fnr.8" href="#fn.8" role="doc-backlink">8</a></sup>. Almost all terminal emulators support
those. Together with proper UTF-8 support, they allow for the colorful,
emoji-filled experience of your average corporate slack channel, with ~5% of the
memory footprint.
</p>

<p>
If you paid attention to the 5 lines of bash that <code>suc</code> consists of, you have
noticed that while <code>suc</code> writes into the channel file, it does not read from it.
</p>

<p>
This job befalls to <code>usuc</code>. Why two separate binaries ? Because <code>suc</code> is a
privileged binary, which runs under the powerful effective ownership of whoever
can write to a channel. One must be careful to keep the logic and external
dependencies of <code>suc</code> to a bare minimum to minimize the attack surface, and
avoid any complex logic where bugs like to hide.
</p>

<p>
<code>usuc</code>, conversely, runs with both effective and real owners set to the
calling user. It can go crazy with the features, as whatever happens can not
impact the channel file, except through <code>suc</code>, whose logic is so simple
there should not be any bugs in it.
</p>

<p>
Here is as of <span><span>&lt;2023-06-29 Thu&gt; </span></span> the code for usuc:
</p>
<div>
<pre><span>#</span><span>!/usr/bin/</span><span>bash</span>
<span>set</span> -euo pipefail

<span># </span><span>Autowrap self in rlwrap</span>
<span>if</span> [ -z <span>&#34;</span><span>$</span><span>{RLWRAP:-}</span><span>&#34;</span> ]
<span>then</span>
    <span>RLWRAP</span>=<span>1</span> rlwrap <span>&#34;</span><span>$</span><span>0</span><span>&#34;</span> <span>&#34;</span><span>$</span><span>@</span><span>&#34;</span>
    <span>exit</span> <span>0</span>
<span>fi</span>

<span>chan_owner</span>=$(<span>ls</span> -l /var/lib/suc/<span>&#34;</span><span>$</span><span>1</span><span>&#34;</span> | cut -d<span>&#39; &#39;</span> -f <span>3</span>)
<span>if</span> [ <span>&#34;</span><span>$</span><span>chan_owner</span><span>&#34;</span> != suc ]
<span>then</span>
    <span>SUC</span>=suc_<span>&#34;</span><span>$</span><span>chan_owner</span><span>&#34;</span>
<span>else</span>
    <span>SUC</span>=suc
<span>fi</span>
<span># </span><span>Tail the channel</span>
tail -f -n <span>20</span> /var/lib/suc/<span>&#34;</span><span>$</span><span>1</span><span>&#34;</span>&amp;
<span>while</span> true
<span>do</span>
    <span>read</span> -r line || <span>exit</span> <span>0</span>
    <span>if</span> [ <span>&#34;</span><span>$</span><span>{line::1}</span><span>&#34;</span> == <span>&#34;:&#34;</span> ]
    <span>then</span>
        <span>echo</span> <span>&#39;*runs* `&#39;</span> <span>&#34;</span><span>$</span><span>{line:1}</span><span>&#34;</span> <span>&#39;`&#39;</span> | pygmentize -l md -f <span>256</span> | <span>&#34;</span><span>$</span><span>SUC</span><span>&#34;</span> <span>&#34;</span><span>$</span><span>1</span><span>&#34;</span>
        bash -c <span>&#34;</span><span>$</span><span>{line:1}</span><span>&#34;</span> | <span>&#34;</span><span>$</span><span>SUC</span><span>&#34;</span> <span>&#34;</span><span>$</span><span>1</span><span>&#34;</span>
    <span>else</span>
        <span>echo</span> <span>&#34;</span><span>$</span><span>line</span><span>&#34;</span> | pygmentize -l md -f <span>256</span> | <span>&#34;</span><span>$</span><span>SUC</span><span>&#34;</span> <span>&#34;</span><span>$</span><span>1</span><span>&#34;</span>
    <span>fi</span>
<span>done</span>
</pre>
</div>
<p>
<code>usuc</code>:
</p>
<ul>
<li>makes sure to prefix its own call with <code>rlwrap</code>, which provides history and line
editing capabilities,</li>
<li>selects the correct setuid <code>suc</code> binary to run depending on who owns the channel file,</li>
<li>calls <code>tail -f</code>, displaying the last 20 lines of the channel and then
anything that get subsequently written to it,</li>
<li>check whether the line typed by the user starts with “:” (see the next section),</li>
<li>pipe anything the user typed through <code>pygmentize</code>.</li>
</ul>


<p>
Pygmentize is a nifty Python module for syntax coloring. Here it runs expecting
markdown on its standard input, and outputting ANSI color coded text on its
standard output. That way, a user can use markup syntax like <code>**bold**</code>, and get
<b>bold</b> output. <code>suc</code> gets markdown support in a single line of code.
</p>
</div>
</div>
<div id="outline-container-orgabf779c">
<h2 id="orgabf779c">Chat commands</h2>
<div id="text-orgabf779c">
<p>
Other tools can, like <code>pygmentize</code>, output ANSI-styled text. One of those is e.g.
<a href="https://github.com/charmbracelet/gum"><code>gum</code></a>.
</p>

<p>
To invoke <code>gum</code> directly from the chat interface, one just has to start a
message with <code>:</code>. <code>usuc</code> will catch that and will not pipe the text to <code>suc</code>
like it would for a normal message. It will instead run the command, and pipe
its <i>output</i> to <code>suc</code>.
</p>

<p>
One can therefore type:
</p>
<pre>: gum style --border=rounded --bold --foreground=#F00 &#34;Hello World !&#34;
</pre>

<p>
as a <code>suc</code> message and see something that looks like the following appear in the channel:
</p>
<pre>╭─────────────╮
│<span>Hello World !</span>│
╰─────────────╯
</pre>

<p>
Any command that exists in the namespace of the user who called <code>usuc</code> can run
that way. Its output will appear in the chat.
</p>

<p>
We use that on <a href="https://the-dam.org/">the dam</a> to roll dice when we play table-top role playing games:
</p>
<pre>: roll 2d6
2023-04-13T21:04:57+00:00 gm        *runs* ` roll 2d6 `
2023-04-13T21:04:58+00:00 gm        [6, 2]
</pre>


<p>
Again, it all happens in the namespace of the user. Any user can customize
her environment to keep useful chat macros on hand, without any impact on the
other users.
</p>
</div>
</div>
<div id="outline-container-orgd2b464b">
<h2 id="orgd2b464b">Piping text to <code>suc</code></h2>
<div id="text-orgd2b464b">
<p>
Instead of using <code>usuc</code>’s command-calling facility, one can pipe right into
<code>suc</code> the output of any command, from one’s shell.
</p>

<p>
For example if you want to pretty-print a piece of source code to a relevant
channel, you can invoke <a href="https://github.com/sharkdp/bat"><code>bat</code></a>:
</p>
<pre>bat --force-colorization --paging=never --style=full toto.c | suc greybeards
</pre>

<p>
and you will get a syntactically-colored listing of your code in the channel.
</p>

<p>
Complex chat system like Mattermost, Slack, etc. offer many
<a href="https://mattermost.com/integrations-overview/">integrations</a>, that is, ways to interact with other software.
</p>

<p>
<code>suc</code> is text-based ; integrating it with other tools feels natural in a UNIX
environment. For example consider the following bash one-liner:
</p>
<div>
<pre><span>make</span> test &gt; testlog || (suc devops &lt; testlog ; <span>exit</span> <span>1</span>)
</pre>
</div>
<p>
This code will run the tests of a software project, and send the logs to the
<code>devops</code> channel on failure.
</p>

<p>
With the necessary boilerplate, this oneliner fits into the <a href="https://www.atlassian.com/git/tutorials/git-hooks">git hook</a> <code>update</code> of
a git repo:
</p>
<div>
<pre><span>#</span><span>!/usr/bin/</span><span>bash</span>
<span>set</span> -euxo pipefail
<span>newrev</span>=<span>&#34;</span><span>$</span><span>3</span><span>&#34;</span>

<span>GIT_DIR</span>=$(realpath <span>&#34;</span><span>$</span><span>GIT_DIR</span><span>&#34;</span>)
<span>cd</span> <span>&#34;</span><span>$(mktemp -d)</span><span>&#34;</span>
<span>git</span> clone <span>&#34;</span><span>$</span><span>GIT_DIR</span><span>&#34;</span> .
<span>git</span> checkout <span>&#34;</span><span>$</span><span>newrev</span><span>&#34;</span>

<span>make</span> test &gt; test_log || (suc devops &lt; test_log ;  <span>exit</span> <span>1</span>)
<span>exit</span> <span>0</span>
</pre>
</div>
<p>
And voilà ! You get a <code>git/suc</code> integration in 11 lines of bash. Any push to
the repo will trigger the test, reject the update on failure, and ring the
DevOps team so they can solve the problem.
</p>
</div>
</div>
<div id="outline-container-org26050c9">
<h2 id="org26050c9">Reading from a <code>suc</code> channel</h2>
<div id="text-org26050c9">
<p>
<code>suc</code> users continually update a text file (the channel). By calling <code>tail -f</code>
on that text file, you can process the new lines as they arrive.
</p>

<p>
For example, to get notified when a new message gets posted in a channel, just run:
</p>
<div>
<pre>tail -n0 -f /var/lib/suc/some-chan | (<span>while</span> true;
                                      <span>do </span><span>read</span> -r line;
                                         notify-send <span>&#34;</span><span>$</span><span>line</span><span>&#34;</span>;
                                      <span>done</span>)
</pre>
</div>

<p>
Too many notifications ? Reduce the noise by grepping for keywords:
</p>
<div>
<pre>tail -n0 -f /var/lib/suc/some-chan | <span>\</span>
    stdbuf -i0 -o0 <span>grep</span> -E <span>&#34;(myname|build failure|fire)&#34;</span> | <span>\</span>
    (<span>while</span> true; <span>do </span><span>read</span> -r line; notify-send <span>&#34;</span><span>$</span><span>line</span><span>&#34;</span>; <span>done</span>)
</pre>
</div>

<p>
Don’t want to open as many windows as channels you follow ? Coalesce them all in
a single feed:
</p>
<pre>tail -f /var/lib/suc/*
</pre>

<p>
Or use the more powerful <a href="https://lnav.org/">lnav</a> (a log file viewer), which will
</p>
<ul>
<li>remember where you left off,</li>
<li>set bookmarks,</li>
<li>assign a color to each channel,</li>
<li>parse the date, username, or any custom field that may appear in the text,</li>
<li>let you filter the messages,</li>
<li>run SQL queries on the messages.</li>
</ul>


<p>
Try to do that with Slack…
</p>
</div>
</div>
<div id="outline-container-orgfc27392">
<h2 id="orgfc27392">Bots</h2>
<div id="text-orgfc27392">
<p>
If you can write and read to a <code>suc</code> channel, you can do both at once. Chat
systems often host bots and semi-automated “assistants”. These provide a text-based
interface to e.g. tickets, continuous integration, corporate directory, server
logs, etc. Have a look below at the code of a bot that convert into meters any
length given in feet:
</p>
<div>
<pre><span>#</span><span>!/usr/bin/</span><span>bash</span>
<span>feet_to_meters</span> (){
    <span>feetexpr</span>=<span>&#34;</span><span>$</span><span>1</span><span>&#34;</span>
    <span>echo</span> -e <span>&#34;</span><span>$</span><span>feetexpr</span><span> \n m&#34;</span> | units | <span>grep</span> -Eo <span>&#34;\* [0-9.]*&#34;</span> | tr -d <span>&#39;*&#39;</span>
}

tail -n0 -f /var/lib/suc/<span>&#34;</span><span>$</span><span>1</span><span>&#34;</span> | <span>\</span>
    stdbuf -i0 -o0 <span>grep</span> -v <span>&#34;metric_bot&#34;</span>  | <span>\</span>
    stdbuf -i0 -o0 <span>grep</span> -Eo <span>&#34;[0-9]+[[:blank:]]*(feet|ft)&#34;</span> | <span>\</span>
    (<span>while</span> true;
     <span>do </span><span>read</span> -r line;
        <span>echo</span> <span>&#34;[metric_bot] </span><span>$</span><span>line</span><span> is </span><span>$(feet_to_meters &#34;</span><span>$</span><span>line</span><span>&#34;)</span><span> meters.&#34;</span> | suc <span>&#34;</span><span>$</span><span>1</span><span>&#34;</span>
     <span>done</span>)
</pre>
</div>
<pre id="org5024b6d">2023-06-30T11:20:47+02:00 edouard   The plane flew at 33000 ft.
2023-06-30T11:20:47+02:00 bots      [metric_bot] 33000 ft is  10058.4 meters.
</pre>
</div>
</div>
<div id="outline-container-org2edb71a">
<h2 id="org2edb71a">Conclusion</h2>
<div id="text-org2edb71a">
<p>
<code>suc</code> piggybacks on SSH for authentication and on UNIX for access control and
composability. It provides almost all the features offered by Mattermost,
Slack, <i>etc.</i> with such a ridiculously small fraction of the code that one
wonders why such complex systems even exist.
</p>

<p>
Using text files as the base for <code>suc</code> channels lets user leverage UNIX tools
for reading (<code>tail</code>, <code>bat</code>, <code>lnav</code>, <code>less</code>, <code>grep</code>, etc.), writing (<code>gum</code>,
<code>bat</code>, <code>pygmentize</code>, etc.), or semi-automated extension with bots, hooks, and
scripts.
</p>

<p>
Tools can be written in any language, as long as they read and write text.
</p>
</div>
</div>
<div id="outline-container-org26136f6">
<h2 id="org26136f6">Advertisement</h2>
<div id="text-org26136f6">
<p>
If you want to play with <code>suc</code> but don’t want to bother with installing it, or
if you don’t have any friends to share a <code>suc</code> instance with, come and join us
at <a href="https://the-dam.org">the dam</a> ! For a measly 10€/year, you can enjoy sharing <code>suc</code> on a GNU Guix
server with people from all over the world.
</p>

<p>
If you would like your own instance of <code>suc</code>, don’t hesitate and rent a VPS from
<a href="https://guix-hosting.com">Guix hosting</a> ! For 100€/year, you get a GNU Guix VPS. Adding <code>suc</code> is just one
line of configuration away. There are no usage-based restrictions, your data
stays yours, and you can use your VPS to provide other services as well.
</p>
</div>
</div>
</div></div>
  </body>
</html>
