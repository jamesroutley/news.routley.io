<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wingolog.org/archives/2023/11/13/i-accidentally-a-scheme">Original</a>
    <h1>I accidentally a scheme</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>Good evening, dear hackfriends.  Tonight&#39;s missive is an apology: not
quite in the sense of expiation, though not quite
<i>not</i> that, either; rather, apology in the sense of explanation, of
exegesis: apologia.  See, I accidentally made a Scheme.  I know I have
enough Scheme implementations already, but I went and made another one.
It&#39;s for a maybe good reason, though!</p><h3>one does not simply a scheme</h3><p>I feel like we should make this the decade of leaning into your problems,
and I have a Scheme problem, so here we are.  See, I co-maintain
<a href="https://gnu.org/s/guile">Guile</a>, and have been noodling on a new
garbage collector (GC) for Guile,
<a href="https://github.com/wingo/whippet">Whippet</a>.  Whippet is designed to be
embedded in the project that uses it, so one day I hope it will be just
copied into Guile&#39;s source tree, replacing the venerable
<a href="https://github.com/ivmai/bdwgc">BDW-GC</a> that we currently use.</p><p>The thing is, though, that GC implementations are complicated.  A bug in
a GC usually manifests itself far away in time and space from the code
that caused the bug.  Language implementations are also complicated, for
similar reasons.  Swapping one GC for another is something to be done
very carefully.  This is even more the case when the switching cost is
high, which is the case with BDW-GC: as a collector written as a library
to link into <a href="https://hboehm.info/spe_gc_paper/">&#34;uncooperative&#34;</a>
programs, there is more cost to moving to a conventional collector than
in the case where the embedding program is already aware that (for
example) garbage collection may relocate objects.</p><p>So, you need to start small.  First, we need to <a href="https://wingolog.org/archives/2023/02/07/whippet-towards-a-new-local-maximum">prove that the new GC
implementation is promising in some way</a>, that it might improve on
BDW-GC.  Then... embed it directly into Guile?  That sounds like a bug
farm.  Is there not any intermediate step that one might take?</p><p>But also, how do you actually test that a GC algorithm or
implementation is interesting?  You need a workload, and you need the
ability to compare the new collector to the old, for that workload.  In
Whippet I had been writing some benchmarks in C
(<a href="https://github.com/wingo/whippet/blob/main/benchmarks/mt-gcbench.c">example</a>),
but this approach wasn&#39;t scaling: besides not sparking joy, I was
starting to wonder if what I was testing would actually reflect usage in
Guile.</p><p>I had an early approach to rewrite a simple language implementation like
the <a href="https://wingolog.org/archives/2022/08/18/just-in-time-code-generation-within-webassembly">other Scheme implementation I made to demonstrate JIT code
generation in
WebAssembly</a>,
but that soon foundered against what seemed to me an unlikely rock: the
compiler itself.  In my <a href="https://github.com/wingo/wasm-jit/">wasm-jit</a>
work, the &#34;compiler&#34; itself was in C++, using the C++ allocator for
compile-time allocations, and the result was a tree of AST nodes that were
interpreted at run-time.  But to embed the benchmarks in Whippet itself
I needed something C, which is less amenable to abstraction of any
kind...  Here I think I could have made a different choice: to somehow
allow C++ or something as a dependency to write tests, or to do more
mallocation in the &#34;compiler&#34;...</p><p>But that wasn&#39;t fun.  A lesson I learned long ago is that if something
isn&#39;t fun, I need to turn it into a compiler.  So I started writing a
compiler to a little bytecode VM, initially in C, then in Scheme because
C is a drag and why not?  Why not just generate the bytecode C file from
Scheme?  Same dependency set, once the C file is generated.  And then,
as long as you&#39;re generating C, why go through bytecode at all?  Why not
just, you know, generate C?</p><h3>after all, why not?  why shouldn&#39;t i keep it?</h3><p>And that&#39;s how I accidentally made a
Scheme, <a href="https://github.com/wingo/whiffle">Whiffle</a>.  Tomorrow I&#39;ll write a little
more on what Whiffle is and isn&#39;t, and what it&#39;s doing for me.  Until
then, happy hacking!</p></div></div></div>
  </body>
</html>
