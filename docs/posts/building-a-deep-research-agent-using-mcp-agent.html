<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://thealliance.ai/blog/building-a-deep-research-agent-using-mcp-agent">Original</a>
    <h1>Building a Deep Research Agent Using MCP-Agent</h1>
    
    <div id="readability-page-1" class="page"><section data-slice-type="content_block" data-slice-variation="default"><div><div><p>Documenting my journey building a general-purpose deep research agent powered by MCP, and sharing the valuable (and sometimes painful) lessons learned along the way.</p><h2 id="background">Background</h2><p>My name is <a target="_blank" href="https://www.linkedin.com/in/sarmadqadri/" rel="noreferrer">Sarmad Qadri</a> and I&#39;m the creator of the open source project, mcp-agent. My philosophy for agent development in 2025 can be summarized as – <strong>MCP is all you need</strong>. Or more verbosely: Connect state-of-the-art LLMs to MCP servers, and leverage simple design patterns to let them make tool calls, gather context and make decisions.</p><p>Over the past few months, I&#39;ve been asked many times when mcp-agent would support deep research workflows. So I set out to build an open source general purpose agent that can work like Claude Code for complex tasks, including deep research, but also multi-step workflows that require making MCP tool calls.</p><p>Turns out this is a lot more complex than expected, even if the architectural underpinnings are conceptually simple. This post is about lessons I wanted to share to help others build their own deep research agents.</p><p>You can find the open-source Deep Orchestrator agent here: <a target="_blank" href="https://github.com/lastmile-ai/mcp-agent/tree/main/src/mcp_agent/workflows/deep_orchestrator" rel="noreferrer"><strong>https://github.com/lastmile-ai/mcp-agent/src/mcp_agent/workflows/deep_orchestrator/</strong></a></p><h2 id="objective-deep-research-but-with-mcp">Objective: Deep Research, but with MCP</h2><p>The first deep research agents started out with access to the internet and filesystem only. The promise of MCP is to dramatically expand that list of tools while adhering to the same architecture. The goal is to be able to do deep research connected to an internal data warehouse, or any data source accessible via an MCP tool or resource. Plus, being able to mutate state by performing tool calls turns the agent from just a research agent to something much more powerful and general-purpose.</p><p>So following the Deep Research approach, I settled on the following requirements:</p><ul><li><strong>Core Functionality</strong> - Be able to complete complex tasks (including deep research and multi-step workflows) by making multiple MCP tool calls</li><li><strong>Context Management</strong> - Use the outputs from sequential steps to gather context and make informed decisions for later steps</li><li><strong>MCP Integration</strong> - Use MCP servers for everything (i.e. the agent shouldn&#39;t need specialized tools beyond the ability to connect to tools via MCP servers)</li><li><strong>General Purpose Design</strong> - Be sufficiently general-purpose to work across multiple domain spaces</li></ul><p>With these goals in mind, my first instinct was to build an Orchestrator to manage complex queries.</p><h2 id="take-1-orchestrator-january-2025-">Take 1: Orchestrator (January 2025)</h2><p>I implemented the Orchestrator pattern from Anthropic&#39;s <a target="_blank" href="https://www.anthropic.com/engineering/building-effective-agents" rel="noreferrer">Building Effective Agents</a> blog post.</p><p><img src="https://images.prismic.io/ai-alliance/aMCJJ2GNHVfTO2z3_Frame162607%5B59%5D.jpg?auto=format,compress"/></p><p><strong>Architecture Components:</strong></p><ul><li><strong>Planning Layer</strong> - A planner LLM breaks down the user objective into sub-tasks and assigns them to predefined sub-agents</li><li><strong>Execution Layer</strong> - The sub-agents execute, build up context progressively (since one sub-agent could chain into another)</li><li><strong>Synthesis Layer</strong> - A synthesizer LLM combines all the sub-agent results into a single final response</li></ul><p>The first attempt worked somewhat well. The Orchestrator usually did a good job defining and executing a plan, and the architecture was simple and elegant. It was particularly effective for tasks where a full plan could be determined upfront.</p><p>For example, for this objective, here&#39;s how the Orchestrator would break it down into a Plan:</p><p><em>Load the student&#39;s short story from short_story.md, and generate a report with feedback across proofreading, factuality/logical consistency and style adherence. Use the style rules from <a target="_blank" href="https://owl.purdue.edu/owl/research_and_citation/apa_style/apa_formatting_and_style_guide/general_format.html" rel="noreferrer">https://owl.purdue.edu/owl/research_and_citation/apa_style/apa_formatting_and_style_guide/general_format.html</a> Write the graded report to graded_report.md in the same directory as short_story.md</em></p><p><img src="https://images.prismic.io/ai-alliance/aMCJYmGNHVfTO20H_76576%5B37%5D.jpg?auto=format,compress"/></p><p>However, the Orchestrator approach also uncovered a number of challenges:</p><ul><li><strong>Hallucination Issues</strong> - Subagents had to be pre-defined, and the Orchestrator would sometimes hallucinate MCP server names or try to call agents that didn&#39;t exist</li><li><strong>Token Inefficiency</strong> - The context from each step was aggregated and passed onto the next step. So by the last step, the context included everything from previous steps. This often meant that context windows were overwhelmed, and calls could be quite expensive without much improvement in the final result</li><li><strong>Fixed Planning</strong> - For complex tasks where the Orchestrator couldn&#39;t plan everything upfront, the Orchestrator continued to push through to a final answer, not incorporating important context that should change sequential steps. The Orchestrator lacked a reflection step where it could reason on whether the current plan was sufficient to accomplish the task at hand</li></ul><p>To make plans more dynamic, I tried implementing an &#34;iterative&#34; plan mode, whereby the planner would only think of the immediate next step, then re-evaluate once that was completed, and keep going until the objective was accomplished.</p><p>The most counterintuitive learning was that asking for the Orchestrator to identify only the <strong>next</strong> immediate step worked substantially worse than expected. Instinctively, giving the LLM more granular reasoning tasks should provide high quality outputs. However, in practice, asking the Orchestrator for a high-level plan to begin with had dramatically improved the output.</p><p>I suspect the reason is that asking the LLM to think of <strong>all</strong> steps requires it to reason more deliberately.</p><p>This Orchestrator pattern is pretty useful for certain types of tasks, and is part of <a target="_blank" href="https://github.com/lastmile-ai/mcp-agent/tree/main/src/mcp_agent/workflows/orchestrator" rel="noreferrer">mcp-agent</a>.  But it certainly isn&#39;t the general-purpose deep research agent that I was after.</p><h2 id="take-2-adaptive-workflow">Take 2: Adaptive Workflow</h2><p>Over the past few months, several AI companies came out with deep research agents. Some of them published detailed blogs on their approaches (<a target="_blank" href="https://www.anthropic.com/engineering/multi-agent-research-system" rel="noreferrer">Anthropic</a>, <a target="_blank" href="https://jina.ai/news/a-practical-guide-to-implementing-deepsearch-deepresearch/" rel="noreferrer">Jina AI</a>).</p><p>Armed with their learnings and my own from Take 1, I set out to build an &#34;Orchestrator&#34; workflow which would &#34;adapt&#34; its plan and subtasks based on the objective. I named it &#34;<a target="_blank" href="https://github.com/lastmile-ai/mcp-agent/pull/346" rel="noreferrer">AdaptiveWorkflow</a>&#34;, which felt appropriate.</p><p>Compared to Take 1, the main architectural updates were:</p><ul><li><strong>Dynamic Subagents</strong> - The planner LLM can now define subagents dynamically after analyzing the user&#39;s objective, instead of defining all the MCP servers and subagents upfront</li><li><strong>FIFO TODO Queue</strong> - Similar to &#34;Steps in Plan,&#34; but explicitly defining a queue data structure. The theory is that new tasks (ie, decomposed queries) are solved upfront to enable better context and performance for later stage tasks</li><li><strong>External Memory and Knowledge</strong> - In the original orchestrator, the prompt context window would be accumulating ALL previous steps&#39; results, so knowledge and memory were bound by context window. For Adaptive orchestrator, I created external knowledge/memory banks. Each task would lead to knowledge being extracted, which could then be injected into subsequent tasks more efficiently (by relevancy or recency)</li><li><strong>Budget Management</strong> - I added deep <a target="_blank" href="https://github.com/lastmile-ai/mcp-agent/blob/main/src/mcp_agent/tracing/token_counter.py" rel="noreferrer">token tracking</a> throughout mcp-agent, where each agent, LLM and workflow could push/pop token context nodes, allowing you to see exactly how many tokens are being used at each substep. This let me set up a budget manager for Adaptive orchestrator – if we exceeded the time/cost/token budget, it would end the workflow</li><li><strong>Beast Mode</strong> - Taking inspiration from <a target="_blank" href="https://jina.ai/news/a-practical-guide-to-implementing-deepsearch-deepresearch/" rel="noreferrer">Jina AI</a>, I added a &#34;beast mode&#34; agent that would trigger and generate a response based on accumulated knowledge once a constraint was hit (budget, timeout, etc). Something is better than nothing</li><li><strong>Mode Detection</strong> - I wrote a lot of complex logic to determine which mode the workflow would operate in based on the task: simple, research or hybrid. The basic idea is that we can bring the right amount of &#34;firepower&#34; based on knowledge accumulation and planning for the task</li></ul><p>I was really excited about Adaptive Workflow to address some of the shortcomings that my original Orchestrator uncovered. With better workflow planning, budget management, external memory, more dynamic agent selection and mode detection, my deep research agent should be more versatile and efficient!</p><p>The hundreds of unit tests Claude and I wrote all passed, the individual components were all working correctly. Time to press the On button to try it out!</p><p>And lo and behold… it didn&#39;t work on real-world examples:</p><ul><li><strong>Navigation Problems</strong> - Adaptive Workflow would get lost or sidetracked a lot</li><li><strong>Performance Issues</strong> - Queries took way too long</li><li><strong>Complexity Overhead</strong> - For simpler tasks, the base orchestrator actually performed much better</li></ul><p>All of the ingredients for a deep research agent were there, matching the theory and architecture I had read, but for some reason, the whole wasn&#39;t greater than the sum of the parts.</p><h2 id="take-3-deep-orchestrator-august-2025-finally-getting-somewhere-">Take 3: Deep Orchestrator (August 2025) – Finally getting somewhere!</h2><p>The key observation came from cases where the original Orchestrator was outperforming the AdaptiveWorkflow despite all its bells and whistles.</p><p>I started debugging the queries where the Orchestrator outperformed my Adaptive Workflow and unlocked a key insight: <strong>simpler architecture consistently wins</strong>.</p><p>So I wiped the slate clean and started by running the original Orchestrator in a loop:</p><ul><li><strong>Input Processing</strong> - Input user objective</li><li><strong>Plan Development</strong> - Develop a full plan, with steps and subtasks</li><li><strong>Execution Phase</strong> - Run through all steps</li><li><strong>New Verification Step</strong> - Add an objective verification.  </li><li>If objective verification is not satisfied, replan and repeat</li></ul><p><img src="https://images.prismic.io/ai-alliance/aMCJjGGNHVfTO20W_14134134135-1-%5B65%5D.jpg?auto=format,compress"/></p><p>Next, I rewrote all the components I had built for Adaptive Workflow, but with new insights from what worked well in the base Orchestrator:</p><h3>TODO Queue</h3><p>I instructed the LLM to generate a full plan upfront, so the queue is built with multiple steps (not just the next TODO step). Additionally, added parallelism into sub-tasks for performance and sequential steps.</p><h3>Memory and Knowledge</h3><p>The original Orchestrator was token-inefficient but context-rich – each task would get full context from previous steps.</p><p>I reused most of the architecture for external memory and knowledge extraction from Adaptive Workflow, but improved how tasks utilized memory. The planner now specifies dependencies between tasks when generating the plan, determining when context should be fed in and building a dependency graph that determines when to propagate memory.</p><p><strong>Additions to the Task and Plan models between Take 2 and Take 3:</strong></p><p><img src="https://images.prismic.io/ai-alliance/aLrpl2GNHVfTOtJb_Frame162608.png?auto=format,compress"/></p><p>I also added a &#34;full context propagation mode,&#34; but this is much less token efficient and usually not necessary.</p><h3>Plan, but verify (deterministically)</h3><p>LLMs hallucinate. They&#39;re better than they were before, but they&#39;re still not perfect. So I added deterministic plan verification before the plan is executed. The verification validates:</p><ul><li><strong>Dependency Validation</strong> - Task dependency graph</li><li><strong>Server Verification</strong> - Check to ensure that the MCP servers being called are real</li><li><strong>Agent Verification</strong> - Confirm that predefined agents that the plan will call actually exist</li></ul><p>If the plan verification fails, Deep Orchestrator generates an error message prompt with all the issues identified and asks the Planner LLM to create a new plan to address the issues (this is similar to the Evaluator-Optimizer pattern explained in <a target="_blank" href="https://www.anthropic.com/engineering/building-effective-agents" rel="noreferrer">Building Effective Agents</a>, but involves deterministic verification).</p><p><strong>The combination of incorporating deterministic (code-based) validation in conjunction with LLM execution was a powerful improvement to the architecture.</strong></p><p><em>There&#39;s more to agents than just LLMs. If we can check something deterministically with code, always prefer that over doing the same with an LLM.</em></p><h3>The art / science of good prompting</h3><p>Good prompting really matters. Just take a look at the r<a target="_blank" href="https://github.com/kn1026/cc/blob/main/claudecode.md" rel="noreferrer">everse-engineered Claude Code system prompt</a>. One thing I learned from <a target="_blank" href="https://github.com/RooCodeInc/Roo-Code/tree/main/src/core/prompts" rel="noreferrer">Roo Code</a> is to build up the prompts progressively in a functional/programmatic way instead of just long, giant strings.</p><p>So I added functions that can add sections to prompts, and to organize them all, I switched to XML tags (there are other approaches too).</p><p>You can see some of this in action in <a target="_blank" href="https://github.com/lastmile-ai/mcp-agent/blob/main/src/mcp_agent/workflows/deep_orchestrator/prompts.py" rel="noreferrer"><strong>mcp-agent/src/mcp_agent/workflows/deep_orchestrator/prompts.py</strong></a>. For example, this is building up a prompt for synthesizing given different knowledge artifacts:</p><p><img src="https://images.prismic.io/ai-alliance/aLrplmGNHVfTOtJZ_12123.png?auto=format,compress"/></p><p>Also, XML tags (or some structured language within the string) to disambiguate really helped.</p><p><img src="https://images.prismic.io/ai-alliance/aMCNR2GNHVfTO25I_6356356.jpg?auto=format,compress"/></p><h3>Simple policy engine</h3><p>Finally, I got rid of the complex Mode Detection from Adaptive Workflow and instead built a simple policy engine that would decide whether to:</p><ul><li><strong>Continue Executing</strong> - Proceed with current plan</li><li><strong>Trigger Replanning</strong> - Revise approach based on new information</li><li><strong>Emergency Stop</strong> - Halt due to repeated failures</li><li><strong>Force Completion</strong> - Complete due to budget overruns</li></ul><p>Having a module dedicated to decision-making helped simplify the architecture and showed me that my complex mode selection was a hack masquerading as a feature.</p><p><img src="https://images.prismic.io/ai-alliance/aMCNHWGNHVfTO240_Frame162610%5B18%5D.jpg?auto=format,compress"/></p><p>Putting all these new pieces together worked pretty well! You can try it out in this <a target="_blank" href="https://thealliance.ai/" rel="noreferrer">AI Alliance</a> example application, <a target="_blank" href="https://github.com/The-AI-Alliance/deep-research-agent-for-finance" rel="noreferrer"><strong>Deep Research Agent for Finance</strong>.</a></p><p>The full Deep Orchestrator flow (<a target="_blank" href="https://github.com/lastmile-ai/mcp-agent/blob/main/src/mcp_agent/workflows/deep_orchestrator/README.md" rel="noreferrer">link to source</a>):</p><p><img src="https://images.prismic.io/ai-alliance/aMCNLWGNHVfTO248_Frame162611%5B1%5D.jpg?auto=format,compress"/></p><h2 id="key-learnings">Key Learnings</h2><h3>1. Simple architecture wins</h3><p>I over-complicated things with Adaptive Workflow, even though the base components were correct (TODO queue, external memory/knowledge, lead planner, etc), they didn&#39;t work well together because each component was individually too complex.</p><h3>2. MCP is all you need</h3><p>I didn&#39;t implement anything specifically for deep research when building Deep Orchestrator. The fundamental building block of MCP-Agent is MCP servers, so the same agent that&#39;s performing general tasks can also be used for deep research. This is the power of the generalizability of MCP.</p><h3>3. The little details matter</h3><p>A little cliche, but the difference between an agent that works well and one that doesn&#39;t is in the many small decisions made along the way. The base components of Adaptive Workflow (attempt 2) and Deep Orchestrator (attempt 3) are really similar, but it took a lot of small tweaks to actually get Deep Orchestrator to work well.</p><h2 id="what-s-next">What&#39;s Next</h2><p>I&#39;m really happy with the progress so far to bring us to Deep Orchestrator, but there are a few things that I&#39;m excited about to take it to the next level.</p><ul><li><strong>Remote Execution</strong> - MCP-Agent already supports temporal orchestration, and I want to expose it as an MCP server that you can call to perform arbitrary operations when certain conditions are met</li><li><strong>Intelligent Tool Selection</strong> - Right now, many MCP servers are relatively simple, but in the near future, we will have hundreds or thousands of possible MCP servers, each with dozens or hundreds of tools. Deep Orchestrator needs to be able to intelligently create subagents with access to the right servers/tools, and those subagents in turn need to intelligently filter tools they expose to the LLM (usually 20-30 tools per step work well)</li><li><strong>Memory and Knowledge as MCP Resources</strong> - MCP has an underutilized concept of <a target="_blank" href="https://modelcontextprotocol.io/specification/2025-06-18/server/resources" rel="noreferrer">resources</a> to reference data by URI. I want to see if I can represent all the knowledge and memory components of the Deep Orchestrator as MCP resources on a Memory Server. That way, they can be stored remotely and reused elsewhere as needed</li><li><strong>Dynamic Model Selection</strong> - Core to the Deep Research Orchestrator is using a strong reasoning model for planning. For both latency and costs, a faster, smaller LLM can be used for simple tool calls</li></ul><p>For the latest improvements and projects with MCP-Agent, check out the open source repo: <strong>mcp-agent</strong>.</p><p>Check out <a target="_blank" href="https://github.com/The-AI-Alliance/deep-research-agent-for-finance" rel="noreferrer">AI Alliance&#39;s AI in Finance open source project</a>, which uses the Deep Research architecture for searching financial information.</p></div></div></section></div>
  </body>
</html>
