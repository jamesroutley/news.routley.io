<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://the.scapegoat.dev/you-the-developer-are-a-user-too/">Original</a>
    <h1>You, the developer, are a user too</h1>
    
    <div id="readability-page-1" class="page"><div>
<div><p>Approaching building systems by thinking of developers as its first users not only ensures smoother engineering processes and developer happiness but also sheds light on unclear parts of the design and enforces good practices from the start.</p>
<h2 id="products-have-many-users">Products have many users</h2>
<p>It’s easy when designing and building systems to forget that they serve more than one user.</p>
<p>Take, for example, a favorite of janky system design interviews everywhere, the URL shortener service. You could naively assume, as many do, that the user is the person that wants their URLs shortened and the person that wants their shortened URL to redirect to a full URL.</p>
<p>But the actual users of the system are altogether different:</p>
<ul>
<li>advertisers</li>
<li>SREs</li>
<li>paying customers</li>
<li>customer support agents</li>
<li>sales</li>
</ul>
<p>Even when broadening the scope like that, it is easy to miss the earliest user of them all: ourselves, the developer.</p>
<h2 id="designing-for-developers">Designing for developers</h2>
<p>As a developer, the ways we interact with the URL shortener are:</p>
<ul>
<li>writing and reading its code</li>
<li>testing and validating it before release</li>
<li>communicating with colleagues and stakeholders about the project</li>
<li>fixing bugs and adding new features</li>
</ul>
<p>These interactions are, of course, served by external tools (an editor, a source control system, a code review platform, and agile workflows). The actual product design is how the code we write can leverage, augment and benefit from these tools.</p>
<p>I like to approach system design by first listing the interactions users want to have in as technology-agnostic a way as I can. Say hello to user stories!</p>
<p>Centering the developer as a user can lead to stories like these:</p>
<ul>
<li>As a developer, I want to be able to get how many errors happened in the component I worked on in the last beta release and correlate them against my pull requests</li>
<li>As a developer, I want to be able to load-test my software and share the results</li>
<li>As a developer, I want to share my current work version with other users and gather their feedback</li>
<li>As a developer, I want to get notified when someone reports a bug on a feature I worked on</li>
<li>As a developer, I want to spin up a local copy of the production environment and replay the sequence of events that led to an error</li>
</ul>
<p>Approaching these interactions with a product mindset exposes synergies we might otherwise miss.</p>
<p>All the traditional UX design approaches work wonders: user stories, wireframes, storyboards, domain modeling, and prototypes.</p>
<p>The best about this is: because we are designing for developers, we can take a lot of shortcuts. We can use complex software when necessary; command-line tooling, python notebooks, and excel exports are all fair game. What matters is that developers can do what their stories describe.</p>

<p>I am a fan of <a href="https://dev.to/wesen/14-great-tips-to-make-amazing-cli-applications-3gp3">command-line tools</a> that allow developers to access valuable information from both development and production systems quickly.</p>
<p>How often has this particular exception been hit in the last seven weeks? How many URLs did the system shorten for each version seeded to beta customers?
Can you quickly deploy a branch and share its URL for testing?</p>
<p>Because the command-line tool itself is often just a tiny layer in front of the actual codebase, the design of a command-line tool as a product profoundly influences the architecture of the code.</p>
<ul>
<li>Being able to quickly gather the error logs corresponding to a specific git revision and a specific source component requires us to do properly structured logging</li>
<li>Sharing a work-in-progress with other users requires a quick way to set up and tear down staging environments</li>
</ul>
<p>The good thing about replacing manual processes with command-line tools is that you can compose them. Processes become easier to compose once you start following a few guidelines:</p>
<ul>
<li>Data output gets emitted in structured formats (CSV, JSON, YAML, …)</li>
<li>Data gets stored immutably in the cloud and referred to by ids (or, in general, basic analytics hygiene). Immutable, persistent data makes reports reproducible across machines and ensures that other users can review and reproduce our findings.</li>
</ul>
<p>Another advantage of command-line tools is that they offer an “index” into your codebase. Not only do they allow a user to discover what is possible by passing in the <code>-help</code> flag, but because the script is just a facade to the codebase, it allows a developer to discover which APIs exist and how they are used.</p>
<h2 id="a-concrete-example-generating-a-load-test-report">A concrete example: generating a load-test report</h2>
<p>Let’s imagine that we are working on the following story:</p>
<p>“As a developer, Anna wants to create a staging environment that matches production two weeks ago and stress it with a synthesized test load that matches black Friday traffic.”</p>
<p>We sketch out what this could look like in a shell script (not how Anna could give this script and its accompanying black-friday.yaml to her colleague Bob, and Bob would have no problem running his version of the load-test, getting his immutable report data back):</p>
<div><pre><span></span><span>RELEASE</span><span>=$</span><span>(</span><span>./</span><span>tool</span><span> </span><span>query</span><span> </span><span>-</span><span>version</span><span> </span><span>-</span><span>date</span><span>=</span><span>&#39;2 weeks ago&#39;</span><span> </span><span>-</span><span>target</span><span> </span><span>production</span><span>)</span><span></span>
<span>DEPLOY_ID</span><span>=$</span><span>(</span><span>./</span><span>tool</span><span> </span><span>deploy</span><span> </span><span>-</span><span>staging</span><span> </span><span>-</span><span>version</span><span>=$</span><span>{</span><span>RELEASE</span><span>})</span><span></span>
<span>TEST_ID</span><span>=$</span><span>(</span><span>./</span><span>tool</span><span> </span><span>load</span><span>-</span><span>test</span><span> </span><span>-</span><span>target</span><span> </span><span>$</span><span>{</span><span>DEPLOY_ID</span><span>}</span><span> </span><span>-</span><span>template</span><span> </span><span>black</span><span>-</span><span>friday</span><span>.</span><span>yaml</span><span>)</span><span></span>
<span>REPORT_ID</span><span>=$</span><span>(</span><span>./</span><span>tool</span><span> </span><span>generate</span><span>-</span><span>report</span><span> </span><span>-</span><span>type</span><span> </span><span>load</span><span>-</span><span>test</span><span> </span><span>-</span><span>from</span><span> </span><span>$</span><span>{</span><span>TEST_ID</span><span>})</span><span></span>
<span>REPORT_URL</span><span>=$</span><span>(</span><span>./</span><span>tool</span><span> </span><span>get</span><span>-</span><span>report</span><span>-</span><span>url</span><span> </span><span>$</span><span>{</span><span>REPORT_ID</span><span>})</span><span></span>
<span>echo</span><span> </span><span>&#34;Load test report for ${RELEASE}: ${REPORT_URL}&#34;</span><span></span>
</pre></div>

<p>From there, it is relatively straightforward to implement the necessary functionality.</p>
<p>It might seem like a lot of effort for something that could potentially be hacked into the shell; in fact, it might be a tremendous amount of effort if you can’t easily create a staging environment, but it will pay off many times throughout the project’s lifetime (due to shortened feedback loops, but that’s a topic for another time).</p>
</div>
</div></div>
  </body>
</html>
