<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nickdrozd.github.io/2025/10/18/recursive-type-definitions-in-rust.html">Original</a>
    <h1>Recursive Type Definitions in Rust</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>I am pleased to announce that I was able to <strong><a href="https://github.com/rust-lang/rust-clippy/pull/15566">add a new feature</a></strong> to the <strong>Rust Clippy linter</strong>. Namely: the <code>use_self</code> lint will now notify that the <strong><code>Self</code> keyword</strong> can be used in <strong>recursive type definitions</strong>. This feature is now officially available in the Nightly release. Hip hip hooray.</p>

<p>Recursive type definitions? <code>Self</code> keyword? Let’s look at some examples. First, consider the humble linked list, the nodes of which contain some data and possibly also a link to another node:</p>

<figure><pre><code data-lang="rust"><span>struct</span> <span>LinkedList</span> <span>{</span>
    <span>data</span><span>:</span> <span>u8</span><span>,</span>
    <span>link</span><span>:</span> <span>Option</span><span>&lt;</span><span>Box</span><span>&lt;</span><span>LinkedList</span><span>&gt;&gt;</span><span>,</span>
<span>}</span></code></pre></figure>

<p>The <code>link</code> field refers back to the object’s own type, so this is a recursive type definition. In this case, the <code>data</code> field contains a <code>u8</code>. Except, actually, the requirements just changed. Now the <code>data</code> needs to be generic. Okay, just a little change to make:</p>

<figure><pre><code data-lang="rust"><span>struct</span> <span>LinkedList</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>{</span>
    <span>data</span><span>:</span> <span>T</span><span>,</span>
    <span>link</span><span>:</span> <span>Option</span><span>&lt;</span><span>Box</span><span>&lt;</span><span>LinkedList</span><span>&lt;</span><span>T</span><span>&gt;&gt;&gt;</span><span>,</span>
<span>}</span></code></pre></figure>

<p>Obviously the <code>data</code> field was updated, and the struct had to be made generic accordingly. But on top of that, the recursive field also had to be updated. Kind of annoying, but it should be fine going forward. Except, no, wait, the requirements changed again. Now instead of an owned value, we’re going to take a reference. Gotta update with a lifetime now:</p>

<figure><pre><code data-lang="rust"><span>struct</span> <span>LinkedList</span><span>&lt;</span><span>&#39;t</span><span>,</span> <span>T</span><span>&gt;</span> <span>{</span>
    <span>data</span><span>:</span> <span>&amp;</span><span>&#39;t</span> <span>T</span><span>,</span>
    <span>link</span><span>:</span> <span>Option</span><span>&lt;</span><span>Box</span><span>&lt;</span><span>LinkedList</span><span>&lt;</span><span>&#39;t</span><span>,</span> <span>T</span><span>&gt;&gt;&gt;</span><span>,</span>
<span>}</span></code></pre></figure>

<p>Okay I am starting not to like this. Every time the struct gets updated, the recursive field gets updated too. Lifetime soup. There’s gotta be a better way. Oh hey, there is. Clippy says:</p>

<figure><pre><code data-lang="nil">error: unnecessary structure name repetition
  |
  |     link: Option&lt;Box&lt;LinkedList&lt;&#39;t, T&gt;&gt;&gt;,
  |                      ^^^^^^^^^^^^^^^^^ help: use the applicable keyword: `Self`</code></pre></figure>

<p>Instead of explicitly referring to the object by name, the <code>Self</code> keyword can be used instead:</p>

<figure><pre><code data-lang="rust"><span>struct</span> <span>LinkedList</span><span>&lt;</span><span>&#39;t</span><span>,</span> <span>T</span><span>&gt;</span> <span>{</span>
    <span>data</span><span>:</span> <span>&amp;</span><span>&#39;t</span> <span>T</span><span>,</span>
    <span>link</span><span>:</span> <span>Option</span><span>&lt;</span><span>Box</span><span>&lt;</span><span>Self</span><span>&gt;&gt;</span><span>,</span>
<span>}</span></code></pre></figure>

<p>Well would you look at that. Now the type definition can undergo further changes and the recursive field can be left undisturbed.</p>

<p><code>Self</code> is not just for <code>struct</code>. It is also for <code>enum</code>. For example, the definition of a basic Lisp language:</p>

<figure><pre><code data-lang="rust"><span>enum</span> <span>Expr</span><span>&lt;</span><span>NumType</span><span>,</span> <span>SymType</span><span>&gt;</span> <span>{</span>
    <span>Number</span><span>(</span><span>NumType</span><span>),</span>
    <span>Symbol</span><span>(</span><span>SymType</span><span>),</span>
    <span>Define</span><span>(</span><span>SymType</span><span>,</span> <span>Box</span><span>&lt;</span><span>Self</span><span>&gt;</span><span>),</span>
    <span>Call</span><span>(</span><span>Box</span><span>&lt;</span><span>Self</span><span>&gt;</span><span>,</span> <span>Vec</span><span>&lt;</span><span>Self</span><span>&gt;</span><span>),</span>
    <span>Lambda</span><span>(</span><span>Vec</span><span>&lt;</span><span>SymType</span><span>&gt;</span><span>,</span> <span>Box</span><span>&lt;</span><span>Self</span><span>&gt;</span><span>),</span>
    <span>If</span><span>(</span><span>Box</span><span>&lt;</span><span>Self</span><span>&gt;</span><span>,</span> <span>Box</span><span>&lt;</span><span>Self</span><span>&gt;</span><span>,</span> <span>Box</span><span>&lt;</span><span>Self</span><span>&gt;</span><span>),</span>
<span>}</span></code></pre></figure>

<p><a href="https://doc.rust-lang.org/reference/types.html#recursive-types">The language reference</a> also says that <code>union</code> can be recursive. But unions are already unsafe, so I didn’t implement this new feature for them. Recursive unions are not just unsafe, but exotically unsafe, and probably shouldn’t be messed with.</p>

<p>It might be argued that using <code>Self</code> in type defintiions is not idiomatic. Certainly it is not very common. But to me that just means it is a good language feature that is poorly publicized. I myself didn’t learn about it until I had to update a recursive struct to be generic. I was annoyed that the <code>use_self</code> lint hadn’t alread told me that <code>Self</code> could be used there. Hence the new feature.</p>

<p>But still, what if you have recursive type definitions and you enable the opt-in <code>use_self</code> lint and you really, really do not want to use <code>Self</code>? Well there is something for you too. Just add <code>recursive-self-in-type-definitions = false</code> to your Clippy configuration file and you won’t have to hear about it.</p>



<ol>
  <li>Have you used <code>Self</code> in recursive type definitions?</li>
  <li>Were you aware that this is even possible?</li>
  <li>Have you used <code>Self</code> in <code>impl</code> blocks?</li>
  <li>Does the new check have any false negatives?</li>
  <li>Does the new check have any false positives?</li>
  <li>Are there any uses for recursive unions?</li>
</ol>

  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
