<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.grisp.org/blog/posts/2025-06-11-grisp-nano-codebeam-sto">Original</a>
    <h1>Erlang 28 on GRiSP Nano using only 16 MB</h1>
    
    <div id="readability-page-1" class="page"><div data-v-39a288b8=""><div data-v-39a288b8=""><div><p><img src="https://www.grisp.org/images/GRiSP-nano.png" alt="GRiSP Nano" width="300px"/></p><p>Last Monday (2 June) at <a href="https://codebeamstockholm.com/talks/Squeezing-the-BEAM-into-16MB/" target="_blank" rel="noreferrer">Code BEAM Light Stockholm</a> Peer opened his presentation with the question <em><strong>Can the BEAM fit into 16 MB?</strong></em> Two days later, the GRiSP Nano prototype answered with an Erlang shell prompt. That success rests on work weâ€™ve carried out since mid-2024.</p><p><img src="https://www.grisp.org/images/blog/can-BEAM-fit-into-16MB.jpg" alt="Alt text"/></p><h2 id="the-16-mb-hardware-budget" tabindex="-1">The 16 MB Hardware Budget <a href="#the-16-mb-hardware-budget" aria-label="Permalink to &#34;The 16 MB Hardware Budget&#34;">â€‹</a></h2><p><img src="https://www.grisp.org/images/blog/this-is-fine.jpg" alt="Alt text"/></p><p><a href="https://www.grisp.org/hardware#grisp-nano-details-section" target="_blank" rel="noopener noreferrer">GRiSP Nano</a> pairs an <strong>STM32U5 Cortex-M33</strong> (3â€¯MB internal SRAM) with <strong>16â€¯MB</strong> of <strong>OctoSPI DRAM</strong>. A <strong>micro-SD</strong> slot handles storage; <strong>4 PMODâ„¢ connectors</strong> expose SPI, IÂ²C, and UART. <strong>Micro-USB</strong> provides console access. <strong>USB-C</strong>, with OTG support, can act as a programmable host or client. Power can be supplied through either port, and in addition, from an energy harvester.</p><p>We initially planned for 32â€¯MB. But after the PCBs were made, a CPU erratum came to light. We had to search for a pin-compatible RAM chip with the right characteristics to keep things running. Thatâ€™s how we landed at 16â€¯MB. The constraint wasnâ€™t planned, but it shaped the result.</p><p><strong>ONLY 16â€¯MB!</strong> <em>This is fine</em> ğŸ”¥ğŸ¶ Zero chill: embedded limits, Erlang charm, and the joy of doing more with less.</p><h2 id="closing-the-gap" tabindex="-1">Closing the Gap <a href="#closing-the-gap" aria-label="Permalink to &#34;Closing the Gap&#34;">â€‹</a></h2><p><img src="https://www.grisp.org/images/blog/unicode.jpg" alt="Alt text"/></p><p>By conference day the prototype could load most of OTP but stopped short of the prompt. The blocker was <strong>Unicode</strong>ğŸš«. Two days later, we applied a targeted patch:</p><ul><li>Added a stub module <code>unicode_util_rtems.erl</code> that replaces the standard <code>unicode_util</code> on RTEMS.</li><li>Adjusted the <code>Makefile</code> to use that stub.</li><li>ğŸ”— <a href="https://github.com/grisp/grisp/blob/sylane/grisp-nano/grisp/grisp_nano/28/build/patches/00700-disable-unicode.patch" target="_blank" rel="noreferrer">Patch Link</a></li></ul><p>With Unicode disabled, NANO finally booted on 4 June. We were so close! âš¡ï¸ğŸŒˆ</p><div><p><span>erlang</span></p><pre tabindex="0"><code><span><span>Eshell V16.</span><span>0</span><span> â€¦</span></span>
<span><span>1</span><span>&gt;</span><span> ls</span><span>().</span></span>
<span><span>.Spotlight</span><span>-</span><span>V100   </span><span>erl_inetrc</span><span>   etc</span></span>
<span><span>grisp</span><span>.</span><span>ini</span><span>         manifest</span><span>     nano</span></span>
<span><span>ok</span></span></code></pre></div><h2 id="â›ï¸-how-we-carved-out-enough-memory-â›ï¸" tabindex="-1">â›ï¸ How We Carved Out Enough Memory â›ï¸ <a href="#â›ï¸-how-we-carved-out-enough-memory-â›ï¸" aria-label="Permalink to &#34;â›ï¸ How We Carved Out Enough Memory â›ï¸&#34;">â€‹</a></h2><ul><li><strong>Baseline:</strong> first boot managed only <strong>7 modules</strong> with <strong>7.4 MB free</strong>; the loader crashed soon after.</li><li><strong>Crypto out + aggressive compile/link flags:</strong> removing crypto (temporarily) and building OTP with <code>-Os -fomit-frame-pointer -ffunction-sections -fdata-sections -Wl,--gc-sections</code> raised free memory to <strong>8.5 MB</strong>, allowing <strong>45 additional modules</strong> to load.</li><li><strong>Strip BEAM files:</strong> running <code>beam_lib:strip_release/1</code> saved a further <strong>16 kB</strong> and squeezed in <strong>2 more modules</strong>.</li><li><strong>RTEMS tweaks + internal RAM + per-module GC:</strong> a small slice of CPU internal RAM plus a forced garbage-collection after each module bumped free space to <strong>9.4 MB</strong> and reduced the BEAM binary to <strong>4.1 MB</strong>, gaining <strong>25 more modules</strong>.</li><li><strong>GC sanity check:</strong> disabling the per-module GC let us load 2 modules more than step 4 with essentially the same free-memory figure.</li><li><strong>Allocator surgery &amp; deeper RTEMS/libbsd optimisations:</strong> enabling <code>ll_alloc</code> with custom flags, adding allocator debugging and disabling per-thread allocators pushed us to <strong>10.2 MB free</strong> with a <strong>2.95 MB</strong> BEAM binary (small enough to fit in internal RAM or flash!).</li></ul><p>With those six steps complete, <strong>Unicode</strong>ğŸš« remained the sole blocker. Its lookup tables required an additional allocation of roughly <strong>500 kB</strong>, which exhausted the remaining free block. Replacing those tables with the stub module <code>unicode_util_rtems.erl</code> removed that final obstacle and the system reached the Erlang shell prompt.</p><h2 id="what-s-next" tabindex="-1">What&#39;s Next <a href="#what-s-next" aria-label="Permalink to &#34;What&#39;s Next&#34;">â€‹</a></h2><p>Reaching the prompt is definitely a milestone, however, not the finish line.</p><p><strong>Our roadmap:</strong></p><ul><li>Relocate selected code into internal RAM or Flash, and then, make internal RAM fully usable.</li><li>Ship kernel &amp; stdlib â€œlightâ€ variants.</li><li>Add energy-aware boot logic for harvested-power scenarios.</li><li>Launch a Kickstarter to fund the first production batch later this year.</li><li>Develop a Unicode-light build that keeps common UTF-8 support without the full 500 kB tables.</li></ul><p>Weâ€™ll keep sharing logs, benchmarks, and lessons learned. If running Erlang in a 16 MB footprint sparks ideas, join the <a href="https://erlanger.slack.com/?redir=%2Farchives%2Fgrisp%3Fname%3Dgrisp" target="_blank" rel="noreferrer">Erlang Coomunity #grisp Slack channel</a> or â­ï¸ the <a href="https://github.com/grisp/grisp" target="_blank" rel="noreferrer">repo</a>, your feedback helps shape what comes next.</p><p>ğŸ”— More details at <a href="https://www.grisp.org" target="_blank" rel="noreferrer">GRiSP.org</a> or reach out directly if you have questions.</p></div></div></div></div>
  </body>
</html>
