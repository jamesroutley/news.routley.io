<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/borkdude/grasp">Original</a>
    <h1>Grasp: Grep Clojure code using clojure.spec regexes</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto">Grep Clojure code using clojure.spec regexes. Inspired by <a href="https://github.com/bfontaine/grape">grape</a>.</p>
<h2 dir="auto"><a id="user-content-why" aria-hidden="true" href="#why"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Why</h2>
<p dir="auto">This tool allows you to find patterns in Clojure code. I use it as a research
tool for <a href="https://github.com/borkdude/sci/issues/485" data-hovercard-type="issue" data-hovercard-url="/babashka/sci/issues/485/hovercard">sci</a>,
<a href="https://github.com/borkdude/clj-kondo">clj-kondo</a> or Clojure
<a href="https://clojure.atlassian.net/browse/CLJ-1656" rel="nofollow">tickets</a>.</p>
<h2 dir="auto"><a id="user-content-dependency" aria-hidden="true" href="#dependency"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Dependency</h2>
<h3 dir="auto"><a id="user-content-depsedn" aria-hidden="true" href="#depsedn"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>deps.edn</h3>
<div dir="auto" data-snippet-clipboard-copy-content="io.github.borkdude/grasp {:mvn/version &#34;0.0.3&#34;}"><pre>io.github.borkdude/grasp {<span>:mvn/version</span> <span><span>&#34;</span>0.0.3<span>&#34;</span></span>}</pre></div>
<h2 dir="auto"><a id="user-content-api" aria-hidden="true" href="#api"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>API</h2>
<p dir="auto">The <code>grasp.api</code> namespace currently exposes:</p>
<ul dir="auto">
<li><code>(grasp path-or-paths spec)</code>: returns matched sexprs in path or paths for
spec. Accept source file, directory, jar file or classpath as string as well
as a collection of strings for passing multiple paths. In case of a directory,
it will be scanned recursively for source files ending with <code>.clj</code>, <code>.cljs</code> or
<code>.cljc</code>.</li>
<li><code>(grasp-string string spec)</code>: returns matched sexprs in string for spec.</li>
<li><code>resolve-symbol</code>: returns the resolved symbol for a symbol, taking into
account aliases and refers. You can also use <code>rsym</code> to create a spec that
matches a fully-qualified, resolved symbol.</li>
<li><code>unwrap</code>: see <a href="#finding-keywords">Finding keywords</a>.</li>
<li><code>cat</code>, <code>or</code>, <code>seq</code>, <code>vec</code>: see <a href="#convenience-macros">Convenience macros</a>.</li>
<li><code>*</code>, <code>?</code>, <code>+</code>: aliases for <code>(s/* any?)</code>, etc.</li>
</ul>
<h2 dir="auto"><a id="user-content-status" aria-hidden="true" href="#status"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Status</h2>
<p dir="auto">Very alpha. API will almost certainly change.</p>
<h2 dir="auto"><a id="user-content-example-usage" aria-hidden="true" href="#example-usage"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Example usage</h2>
<p dir="auto">Assuming you have the following requires:</p>
<div dir="auto" data-snippet-clipboard-copy-content="(require &#39;[clojure.java.io :as io]
         &#39;[clojure.pprint :as pprint]
         &#39;[clojure.string :as str]
         &#39;[clojure.spec.alpha :as s]
         &#39;[grasp.api :as g])"><pre>(<span>require</span> &#39;[clojure.java.io <span>:as</span> io]
         &#39;[clojure.pprint <span>:as</span> pprint]
         &#39;[clojure.string <span>:as</span> str]
         &#39;[clojure.spec.alpha <span>:as</span> s]
         &#39;[grasp.api <span>:as</span> g])</pre></div>
<h3 dir="auto"><a id="user-content-find-reify-usages" aria-hidden="true" href="#find-reify-usages"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Find reify usages</h3>
<p dir="auto">Find <code>reify</code> usage with more than one interface:</p>
<div dir="auto" data-snippet-clipboard-copy-content="(def clojure-core (slurp (io/resource &#34;clojure/core.clj&#34;)))

(s/def ::clause (s/cat :sym symbol? :lists (s/+ list?)))

(s/def ::reify
  (s/cat :reify #{&#39;reify}
         :clauses (s/cat :clause ::clause :clauses (s/+ ::clause))))

(def matches (g/grasp-string clojure-core ::reify))

(doseq [m matches]
  (prn (meta m))
  (pprint/pprint m)
  (println))"><pre>(<span>def</span> <span>clojure-core</span> (<span>slurp</span> (<span>io/resource</span> <span><span>&#34;</span>clojure/core.clj<span>&#34;</span></span>)))

(<span>s/def</span> <span>::clause</span> (<span>s/cat</span> <span>:sym</span> symbol? <span>:lists</span> (<span>s/+</span> list?)))

(<span>s/def</span> <span>::reify</span>
  (<span>s/cat</span> <span>:reify</span> #{&#39;reify}
         <span>:clauses</span> (<span>s/cat</span> <span>:clause</span> <span>::clause</span> <span>:clauses</span> (<span>s/+</span> <span>::clause</span>))))

(<span>def</span> <span>matches</span> (<span>g/grasp-string</span> clojure-core <span>::reify</span>))

(<span>doseq</span> [m matches]
  (<span>prn</span> (<span>meta</span> m))
  (<span>pprint/pprint</span> m)
  (<span>println</span>))</pre></div>
<p dir="auto">This outputs:</p>
<div dir="auto" data-snippet-clipboard-copy-content="{:line 6974, :column 5, :end-line 6988, :end-column 56}
(reify
 clojure.lang.IDeref
 (deref [_] (deref-future fut))
 clojure.lang.IBlockingDeref
 (deref
  [_ timeout-ms timeout-val]
  (deref-future fut timeout-ms timeout-val))
 ...)

{:line 7107, :column 5, :end-line 7125, :end-column 16}
(reify
 clojure.lang.IDeref
 ...)"><pre>{<span>:line</span> <span>6974</span>, <span>:column</span> <span>5</span>, <span>:end-line</span> <span>6988</span>, <span>:end-column</span> <span>56</span>}
(<span>reify</span>
 clojure.lang.IDeref
 (<span>deref</span> [_] (<span>deref-future</span> fut))
 clojure.lang.IBlockingDeref
 (<span>deref</span>
  [_ timeout-ms timeout-val]
  (<span>deref-future</span> fut timeout-ms timeout-val))
 ...)

{<span>:line</span> <span>7107</span>, <span>:column</span> <span>5</span>, <span>:end-line</span> <span>7125</span>, <span>:end-column</span> <span>16</span>}
(<span>reify</span>
 clojure.lang.IDeref
 ...)</pre></div>
<p dir="auto">(output abbreviated for readability)</p>
<h3 dir="auto"><a id="user-content-find-usages-based-on-resolved-symbol" aria-hidden="true" href="#find-usages-based-on-resolved-symbol"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Find usages based on resolved symbol</h3>
<p dir="auto">Find all usages of <code>clojure.set/difference</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="(defn table-row [sexpr]
  (-&gt; (meta sexpr)
      (select-keys [:uri :line :column])
      (assoc :sexpr sexpr)))

(-&gt;&gt;
   (g/grasp &#34;/Users/borkdude/git/clojure/src&#34;
            ;; Alt 1: using rsym:
            (g/rsym &#39;clojure.set/difference)
            ;; Alt 2: do it manually:
            #_(fn [sym]
              (when (symbol? sym)
                (= &#39;clojure.set/difference (g/resolve-symbol sym)))))
   (map table-row)
   pprint/print-table)"><pre>(<span>defn</span> <span>table-row</span> [sexpr]
  (<span>-&gt;</span> (<span>meta</span> sexpr)
      (<span>select-keys</span> [<span>:uri</span> <span>:line</span> <span>:column</span>])
      (<span>assoc</span> <span>:sexpr</span> sexpr)))

(<span>-&gt;&gt;</span>
   (<span>g/grasp</span> <span><span>&#34;</span>/Users/borkdude/git/clojure/src<span>&#34;</span></span>
            <span><span>;</span>; Alt 1: using rsym:</span>
            (<span>g/rsym</span> &#39;clojure.set/difference)
            <span><span>;</span>; Alt 2: do it manually:</span>
            #_(<span>fn</span> [sym]
              (<span>when</span> (<span>symbol?</span> sym)
                (<span>=</span> &#39;clojure.set/difference (<span>g/resolve-symbol</span> sym)))))
   (<span>map</span> table-row)
   pprint/print-table)</pre></div>
<p dir="auto">This outputs:</p>
<div dir="auto" data-snippet-clipboard-copy-content="|                                                         :uri | :line | :column |         :sexpr |
|--------------------------------------------------------------+-------+---------+----------------|
|     file:/Users/borkdude/git/clojure/src/clj/clojure/set.clj |    49 |       7 |     difference |
|     file:/Users/borkdude/git/clojure/src/clj/clojure/set.clj |    62 |      14 |     difference |
|     file:/Users/borkdude/git/clojure/src/clj/clojure/set.clj |   172 |       2 |     difference |
|    file:/Users/borkdude/git/clojure/src/clj/clojure/data.clj |   112 |      19 | set/difference |
|    file:/Users/borkdude/git/clojure/src/clj/clojure/data.clj |   113 |      19 | set/difference |
| file:/Users/borkdude/git/clojure/src/clj/clojure/reflect.clj |   107 |      37 | set/difference |"><pre>|                                                         <span>:uri</span> | <span>:line</span> | <span>:column</span> |         <span>:sexpr</span> |
|--------------------------------------------------------------+-------+---------+----------------|
|     file:/Users/borkdude/git/clojure/src/clj/clojure/set.clj |    <span>49</span> |       <span>7</span> |     difference |
|     file:/Users/borkdude/git/clojure/src/clj/clojure/set.clj |    <span>62</span> |      <span>14</span> |     difference |
|     file:/Users/borkdude/git/clojure/src/clj/clojure/set.clj |   <span>172</span> |       <span>2</span> |     difference |
|    file:/Users/borkdude/git/clojure/src/clj/clojure/data.clj |   <span>112</span> |      <span>19</span> | set/difference |
|    file:/Users/borkdude/git/clojure/src/clj/clojure/data.clj |   <span>113</span> |      <span>19</span> | set/difference |
| file:/Users/borkdude/git/clojure/src/clj/clojure/reflect.clj |   <span>107</span> |      <span>37</span> | set/difference |</pre></div>
<h3 dir="auto"><a id="user-content-find-a-function-call" aria-hidden="true" href="#find-a-function-call"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Find a function call</h3>
<p dir="auto">Find all calls to <code>clojure.core/map</code> that take 1 argument:</p>
<div dir="auto" data-snippet-clipboard-copy-content="(g/grasp-string &#34;(comment (map identity))&#34; (g/seq (g/rsym &#39;clojure.core/map) any?))
; =&gt; [(map identity)]"><pre>(<span>g/grasp-string</span> <span><span>&#34;</span>(comment (map identity))<span>&#34;</span></span> (<span>g/seq</span> (<span>g/rsym</span> &#39;clojure.core/map) any?))
<span><span>;</span> =&gt; [(map identity)]</span></pre></div>
<h3 dir="auto"><a id="user-content-grasp-a-classpath" aria-hidden="true" href="#grasp-a-classpath"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Grasp a classpath</h3>
<p dir="auto">Grasp the entire classpath for usage of <code>frequencies</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="(-&gt;&gt; (g/grasp (System/getProperty &#34;java.class.path&#34;) #{&#39;frequencies})
     (take 2)
     (map (comp #(select-keys % [:uri :line]) meta)))"><pre>(<span>-&gt;&gt;</span> (<span>g/grasp</span> (<span>System/getProperty</span> <span><span>&#34;</span>java.class.path<span>&#34;</span></span>) #{&#39;frequencies})
     (<span>take</span> <span>2</span>)
     (<span>map</span> (<span>comp</span> #(<span>select-keys</span> % [<span>:uri</span> <span>:line</span>]) meta)))</pre></div>
<p dir="auto">Output:</p>
<div dir="auto" data-snippet-clipboard-copy-content="({:uri &#34;file:/Users/borkdude/.gitlibs/libs/borkdude/sci/cb96d7fb2a37a7c21c78fc145948d6867c30936a/src/sci/impl/namespaces.cljc&#34;, :line 815}
 {:uri &#34;file:/Users/borkdude/.gitlibs/libs/borkdude/sci/cb96d7fb2a37a7c21c78fc145948d6867c30936a/src/sci/impl/namespaces.cljc&#34;, :line 815})"><pre>({<span>:uri</span> <span><span>&#34;</span>file:/Users/borkdude/.gitlibs/libs/borkdude/sci/cb96d7fb2a37a7c21c78fc145948d6867c30936a/src/sci/impl/namespaces.cljc<span>&#34;</span></span>, <span>:line</span> <span>815</span>}
 {<span>:uri</span> <span><span>&#34;</span>file:/Users/borkdude/.gitlibs/libs/borkdude/sci/cb96d7fb2a37a7c21c78fc145948d6867c30936a/src/sci/impl/namespaces.cljc<span>&#34;</span></span>, <span>:line</span> <span>815</span>})</pre></div>
<h3 dir="auto"><a id="user-content-finding-keywords" aria-hidden="true" href="#finding-keywords"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Finding keywords</h3>
<p dir="auto">When searching for keywords you will run into the problem that they do not have
location information because they can&#39;t carry metadata. To solve this problem,
grasp lets you wrap non-metadata supporting forms in a container. Grasp exposes
the <code>unwrap</code> function to get hold of the form, while you can access the location
of that form using the container&#39;s metadata. Say we would like to find all
occurrences of <code>:my.cljs.app.subs/my-data</code> in this example:</p>
<p dir="auto"><code>/tmp/code.clj</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="(ns my.cljs.app.views
  (:require [my.cljs.app.subs :as subs]
            [re-frame.core :refer [subscribe]]))

(subscribe [::subs/my-data])
(subscribe [:my.cljs.app.subs/my-data])"><pre>(<span>ns</span> <span>my.cljs.app.views</span>
  (<span>:require</span> [my.cljs.app.subs <span>:as</span> subs]
            [re-frame.core <span>:refer</span> [subscribe]]))

(<span>subscribe</span> [<span>::subs/my-data</span>])
(<span>subscribe</span> [<span>:my.cljs.app.subs/my-data</span>])</pre></div>
<p dir="auto">We can find them like this:</p>
<div dir="auto" data-snippet-clipboard-copy-content="(s/def ::subscription (fn [x] (= :my.cljs.app.subs/my-data (unwrap x))))

(def matches
  (grasp &#34;/tmp/code.clj&#34; ::subscription {:wrap true}))

(run! prn (map meta matches))"><pre>(<span>s/def</span> <span>::subscription</span> (<span>fn</span> [x] (<span>=</span> <span>:my.cljs.app.subs/my-data</span> (<span>unwrap</span> x))))

(<span>def</span> <span>matches</span>
  (<span>grasp</span> <span><span>&#34;</span>/tmp/code.clj<span>&#34;</span></span> <span>::subscription</span> {<span>:wrap</span> <span>true</span>}))

(<span>run!</span> prn (<span>map</span> meta matches))</pre></div>
<p dir="auto">Note that you explicitly have to provide <code>:wrap true</code> to make grasp wrap
keywords.</p>
<p dir="auto">The output:</p>
<div dir="auto" data-snippet-clipboard-copy-content="{:line 5, :column 13, :end-line 5, :end-column 27, :uri &#34;file:/tmp/code.clj&#34;}
{:line 6, :column 13, :end-line 6, :end-column 38, :uri &#34;file:/tmp/code.clj&#34;}"><pre>{<span>:line</span> <span>5</span>, <span>:column</span> <span>13</span>, <span>:end-line</span> <span>5</span>, <span>:end-column</span> <span>27</span>, <span>:uri</span> <span><span>&#34;</span>file:/tmp/code.clj<span>&#34;</span></span>}
{<span>:line</span> <span>6</span>, <span>:column</span> <span>13</span>, <span>:end-line</span> <span>6</span>, <span>:end-column</span> <span>38</span>, <span>:uri</span> <span><span>&#34;</span>file:/tmp/code.clj<span>&#34;</span></span>}</pre></div>
<h3 dir="auto"><a id="user-content-keep-fn" aria-hidden="true" href="#keep-fn"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Keep-fn</h3>
<p dir="auto">Grasp supports a custom <code>:keep-fn</code>, the function which decides whether to
collect a matched result. The default <code>:keep-fn</code> is:</p>
<div dir="auto" data-snippet-clipboard-copy-content="(defn default-keep-fn
  [{:keys [spec expr uri]}]
  (when (s/valid? spec expr)
    (impl/with-uri expr uri)))"><pre>(<span>defn</span> <span>default-keep-fn</span>
  [{<span>:keys</span> [spec expr uri]}]
  (<span>when</span> (<span>s/valid?</span> spec expr)
    (<span>impl/with-uri</span> expr uri)))</pre></div>
<p dir="auto">When a spec result is valid, then the URI is attached to the result&#39;s metadata and kept.</p>
<p dir="auto">In a custom <code>:keep-fn</code> you are able to call <code>s/conform</code> and keep that result around:</p>
<div dir="auto" data-snippet-clipboard-copy-content="(defn keep-fn [{:keys [spec expr uri]}]
  (let [conformed (s/conform spec expr)]
    (when-not (s/invalid? conformed)
      {:var-name (grasp/resolve-symbol (second expr))
       :expr expr
       :uri uri})))"><pre>(<span>defn</span> <span>keep-fn</span> [{<span>:keys</span> [spec expr uri]}]
  (<span>let</span> [conformed (<span>s/conform</span> spec expr)]
    (<span>when-not</span> (<span>s/invalid?</span> conformed)
      {<span>:var-name</span> (<span>grasp/resolve-symbol</span> (<span>second</span> expr))
       <span>:expr</span> expr
       <span>:uri</span> uri})))</pre></div>
<p dir="auto">Now the result of <code>g/grasp</code> will be a seq of maps instead of expressions and you
can do whatever you want with it.</p>
<h3 dir="auto"><a id="user-content-matching-on-source-string" aria-hidden="true" href="#matching-on-source-string"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Matching on source string</h3>
<p dir="auto">Using the option <code>:source true</code>, grasp will attach the source string as metadata
on parsed s-expressions. This can be used to match on things like function
literals like <code>#(foo %)</code> or keywords like <code>::foo</code>. For example: we can grasp for
function literals that have more than one argument:</p>
<div dir="auto" data-snippet-clipboard-copy-content="(s/def ::fn-literal
  (fn [x] (and (seq? x) (= &#39;fn* (first x)) (&gt; (count (second x)) 1)
               (some-&gt; x meta :source (str/starts-with? &#34;#(&#34;))))))

(def match (first (g/grasp-string &#34;#(+ % %2)&#34; ::fn-literal {:source true})))

(prn [match (meta match)])"><pre>(<span>s/def</span> <span>::fn-literal</span>
  (<span>fn</span> [x] (<span>and</span> (<span>seq?</span> x) (<span>=</span> &#39;fn* (<span>first</span> x)) (<span>&gt;</span> (<span>count</span> (<span>second</span> x)) <span>1</span>)
               (<span>some-&gt;</span> x meta <span>:source</span> (<span>str/starts-with?</span> <span><span>&#34;</span>#(<span>&#34;</span></span>))))))

(<span>def</span> <span>match</span> (<span>first</span> (<span>g/grasp-string</span> <span><span>&#34;</span>#(+ % %2)<span>&#34;</span></span> <span>::fn-literal</span> {<span>:source</span> <span>true</span>})))

(<span>prn</span> [match (<span>meta</span> match)])</pre></div>
<p dir="auto">Output:</p>
<div dir="auto" data-snippet-clipboard-copy-content="[(fn* [%1 %2] (+ %1 %2)) {:source &#34;#(+ % %2)&#34;, :line 1, :column 1, :end-line 1, :end-column 10}]"><pre>[(<span>fn*</span> [%<span>1</span> %<span>2</span>] (<span>+</span> %<span>1</span> %<span>2</span>)) {<span>:source</span> <span><span>&#34;</span>#(+ % %2)<span>&#34;</span></span>, <span>:line</span> <span>1</span>, <span>:column</span> <span>1</span>, <span>:end-line</span> <span>1</span>, <span>:end-column</span> <span>10</span>}]</pre></div>
<h3 dir="auto"><a id="user-content-more-examples" aria-hidden="true" href="#more-examples"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>More examples</h3>
<p dir="auto">More examples in <a href="https://github.com/borkdude/grasp/blob/master/examples">examples</a>.</p>
<h2 dir="auto"><a id="user-content-convenience-macros" aria-hidden="true" href="#convenience-macros"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Convenience macros</h2>
<p dir="auto">Grasp exposes the <code>cat</code>, <code>seq</code>, <code>vec</code> and <code>or</code> convenience macros.</p>
<p dir="auto">All of these macros support passing in a single quoted value for matching a
literal thing <code>&#39;foo</code> for matching that symbol instead of
<code>#{&#39;foo}</code>. Additionally, they let you write specs without names for each parsed
item: <code>(g/cat &#39;foo int?)</code> instead of <code>(s/cat :s #{&#39;foo} :i int?)</code>. The <code>seq</code>
and <code>vec</code> macros are like the <code>cat</code> macro but additionally check for <code>seq?</code> and
<code>vector?</code> respectively.</p>
<h2 dir="auto"><a id="user-content-binary" aria-hidden="true" href="#binary"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Binary</h2>
<p dir="auto">A CLI binary can be obtained from Github releases.</p>
<p dir="auto">It can be invoked like this:</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ ./grasp ~/git/spec.alpha/src -e &#34;(set-opts! {:wrap true}) (fn [k] (= :clojure.spec.alpha/invalid (unwrap k)))&#34; | grep file | wc -l
      68"><pre>$ ./grasp <span>~</span>/git/spec.alpha/src -e <span><span>&#34;</span>(set-opts! {:wrap true}) (fn [k] (= :clojure.spec.alpha/invalid (unwrap k)))<span>&#34;</span></span> <span>|</span> grep file <span>|</span> wc -l
      68</pre></div>
<p dir="auto">The binary supports the following options:</p>
<div dir="auto" data-snippet-clipboard-copy-content="-p, --path: path
-e, --expr: spec from expr
-f, --file: spec from file"><pre>-p, --path: path
-e, --expr: spec from expr
-f, --file: spec from file</pre></div>
<p dir="auto">The path and spec may also be provided without flags, like <code>grasp &lt;path&gt; &lt;spec&gt;</code>. Use <code>-</code> for grasping from stdin.</p>
<p dir="auto">The evaluated code from <code>-e</code> or <code>-f</code> may return a spec (or spec keyword) or call
<code>set-opts!</code> with a map that contains <code>:spec</code> and other options. E.g.:</p>
<div dir="auto" data-snippet-clipboard-copy-content="(require &#39;[clojure.spec.alpha :as s])
(require &#39;[grasp.api :as g])

(s/def ::spec (fn [x] (= :clojure.spec.alpha/invalid (g/unwrap x))))

(g/set-opts! {:spec ::spec :wrap true})"><pre>(<span>require</span> &#39;[clojure.spec.alpha <span>:as</span> s])
(<span>require</span> &#39;[grasp.api <span>:as</span> g])

(<span>s/def</span> <span>::spec</span> (<span>fn</span> [x] (<span>=</span> <span>:clojure.spec.alpha/invalid</span> (<span>g/unwrap</span> x))))

(<span>g/set-opts!</span> {<span>:spec</span> <span>::spec</span> <span>:wrap</span> <span>true</span>})</pre></div>
<p dir="auto">If <code>nil</code> is returned from the evaluated code and <code>set-opts!</code> wasn&#39;t called, the
CLI assumes that code will handle the results and no printing will be
done. These programs may call <code>g/grasp</code> and pass <code>g/*path*</code> which contains the
path that was passed to the CLI.</p>
<p dir="auto">Full example:</p>
<p dir="auto"><code>fn_literal.clj</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="(require &#39;[clojure.pprint :as pprint]
         &#39;[clojure.spec.alpha :as s]
         &#39;[clojure.string :as str]
         &#39;[grasp.api :as g])

(s/def ::fn-literal
  (fn [x] (and (seq? x) (= &#39;fn* (first x)) (&gt; (count (second x)) 1)
               (some-&gt; x meta :source (str/starts-with? &#34;#(&#34;)))))

(let [matches (g/grasp g/*path* ::fn-literal {:source true})
      rows (map (fn [match]
                  (let [m (meta match)]
                    {:source (:source m)
                     :match match}))
                matches)]
  (pprint/print-table rows))"><pre>(<span>require</span> &#39;[clojure.pprint <span>:as</span> pprint]
         &#39;[clojure.spec.alpha <span>:as</span> s]
         &#39;[clojure.string <span>:as</span> str]
         &#39;[grasp.api <span>:as</span> g])

(<span>s/def</span> <span>::fn-literal</span>
  (<span>fn</span> [x] (<span>and</span> (<span>seq?</span> x) (<span>=</span> &#39;fn* (<span>first</span> x)) (<span>&gt;</span> (<span>count</span> (<span>second</span> x)) <span>1</span>)
               (<span>some-&gt;</span> x meta <span>:source</span> (<span>str/starts-with?</span> <span><span>&#34;</span>#(<span>&#34;</span></span>)))))

(<span>let</span> [matches (<span>g/grasp</span> g/*path* <span>::fn-literal</span> {<span>:source</span> <span>true</span>})
      rows (<span>map</span> (<span>fn</span> [match]
                  (<span>let</span> [m (<span>meta</span> match)]
                    {<span>:source</span> (<span>:source</span> m)
                     <span>:match</span> match}))
                matches)]
  (<span>pprint/print-table</span> rows))</pre></div>
<div dir="auto" data-snippet-clipboard-copy-content="$ grasp - fn_literal.clj &lt;&lt;&lt; &#34;#(foo %1 %2)&#34;

|  :uri | :line |      :source |                    :match |
|-------+-------+--------------+---------------------------|
| stdin |     1 | #(foo %1 %2) | (fn* [%1 %2] (foo %1 %2)) |"><pre>$ grasp - fn_literal.clj &lt;&lt;&lt; <span><span>&#34;</span>#(foo %1 %2)<span>&#34;</span></span>

|  <span>:uri</span> | <span>:line</span> |      <span>:source</span> |                    <span>:match</span> |
|-------+-------+--------------+---------------------------|
| stdin |     <span>1</span> | #(<span>foo</span> %<span>1</span> %<span>2</span>) | (<span>fn*</span> [%<span>1</span> %<span>2</span>] (<span>foo</span> %<span>1</span> %<span>2</span>)) |</pre></div>
<h3 dir="auto"><a id="user-content-pattern-matching" aria-hidden="true" href="#pattern-matching"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Pattern matching</h3>
<p dir="auto">The matched s-expressions can be conformed and then pattern-matched using
libraries like <a href="https://github.com/noprompt/meander">meander</a>.</p>
<p dir="auto">Revisiting the <code>::reify</code> spec which finds reify usage with more than one
interface:</p>
<div dir="auto" data-snippet-clipboard-copy-content="(s/def ::clause (s/cat :sym symbol? :lists (s/+ list?)))

(s/def ::reify
  (s/cat :reify #{&#39;reify}
         :clauses (s/cat :clause ::clause :clauses (s/+ ::clause))))

(def clojure-core (slurp (io/resource &#34;clojure/core.clj&#34;)))

(def matches (g/grasp-string clojure-core ::reify))

(def conformed (map #(s/conform ::reify %) matches))"><pre>(<span>s/def</span> <span>::clause</span> (<span>s/cat</span> <span>:sym</span> symbol? <span>:lists</span> (<span>s/+</span> list?)))

(<span>s/def</span> <span>::reify</span>
  (<span>s/cat</span> <span>:reify</span> #{&#39;reify}
         <span>:clauses</span> (<span>s/cat</span> <span>:clause</span> <span>::clause</span> <span>:clauses</span> (<span>s/+</span> <span>::clause</span>))))

(<span>def</span> <span>clojure-core</span> (<span>slurp</span> (<span>io/resource</span> <span><span>&#34;</span>clojure/core.clj<span>&#34;</span></span>)))

(<span>def</span> <span>matches</span> (<span>g/grasp-string</span> clojure-core <span>::reify</span>))

(<span>def</span> <span>conformed</span> (<span>map</span> #(<span>s/conform</span> <span>::reify</span> %) matches))</pre></div>
<h4 dir="auto"><a id="user-content-matchete" aria-hidden="true" href="#matchete"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><a href="https://github.com/xapix-io/matchete">Matchete</a></h4>
<div dir="auto" data-snippet-clipboard-copy-content="(require &#39;[matchete.core :as mc])

(def pattern
  {:clauses
   {:clause {:sym &#39;!interface}
    :clauses (mc/each {:sym &#39;!interface})}})

(first (mc/matches pattern (first conformed)))"><pre>(<span>require</span> &#39;[matchete.core <span>:as</span> mc])

(<span>def</span> <span>pattern</span>
  {<span>:clauses</span>
   {<span>:clause</span> {<span>:sym</span> &#39;!interface}
    <span>:clauses</span> (<span>mc/each</span> {<span>:sym</span> &#39;!interface})}})

(<span>first</span> (<span>mc/matches</span> pattern (<span>first</span> conformed)))</pre></div>
<p dir="auto">Returns:</p>
<div dir="auto" data-snippet-clipboard-copy-content="{!interface [clojure.lang.IDeref clojure.lang.IBlockingDeref clojure.lang.IPending java.util.concurrent.Future]}"><pre>{!interface [clojure.lang.IDeref clojure.lang.IBlockingDeref clojure.lang.IPending java.util.concurrent.Future]}</pre></div>
<h4 dir="auto"><a id="user-content-meander" aria-hidden="true" href="#meander"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><a href="https://github.com/noprompt/meander">Meander</a></h4>
<div data-snippet-clipboard-copy-content="(require &#39;[meander.epsilon :as m])

(m/find
  (first conformed)
  {:clauses {:clause {:sym !interface} :clauses [{:sym !interface} ...]}}
  !interface)"><pre><code>(require &#39;[meander.epsilon :as m])

(m/find
  (first conformed)
  {:clauses {:clause {:sym !interface} :clauses [{:sym !interface} ...]}}
  !interface)
</code></pre></div>
<p dir="auto">Returns:</p>
<div dir="auto" data-snippet-clipboard-copy-content="[clojure.lang.IDeref clojure.lang.IBlockingDeref clojure.lang.IPending java.util.concurrent.Future]"><pre>[clojure.lang.IDeref clojure.lang.IBlockingDeref clojure.lang.IPending java.util.concurrent.Future]</pre></div>
<h3 dir="auto"><a id="user-content-build" aria-hidden="true" href="#build"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Build</h3>
<p dir="auto">Run <code>script/compile</code> to compile the <code>grasp</code> binary using
<a href="https://www.graalvm.org/downloads" rel="nofollow">GraalVM</a></p>
<h2 dir="auto"><a id="user-content-license" aria-hidden="true" href="#license"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>License</h2>
<p dir="auto">Copyright © 2020 Michiel Borkent</p>
<p dir="auto">Distributed under the EPL License. See LICENSE.</p>
</article>
          </div></div>
  </body>
</html>
