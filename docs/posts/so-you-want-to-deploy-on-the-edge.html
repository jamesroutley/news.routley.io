<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://zknill.io/posts/edge-database/">Original</a>
    <h1>So, you want to deploy on the edge?</h1>
    
    <div id="readability-page-1" class="page"><div id="content"><p>Application developers often deploy their apps into a single area, generally represented by a handful of AZs in a single region.
No matter where their users make requests from, those requests get served by the region where the developers’ apps run.</p><p>If a user makes a request from Europe, and the apps run in US East, that adds an extra 100-150ms of latency just by round-tripping across the Atlantic.</p><p>Edge computing tries to solve this problem, by letting app developers deploy their applications across the globe, so that apps serve the user requests closer to the user.
This removes a lot of the round-trip latency because the request has to travel less far before getting to a data center that hosts the app.</p><p>Edge computing sounds great for reducing response times for users, but <strong>the main thing stopping developers from adopting edge computing is data consistency.</strong></p><h2 id="latency-to-the-database">Latency to the database</h2><p><img src="https://zknill.io/svg/loading.min.svg" data-src="/img/latency-to-database.png#center" data-srcset="/img/latency-to-database.png#center, /img/latency-to-database.png#center 1.5x, /img/latency-to-database.png#center 2x" data-sizes="auto" alt="/img/latency-to-database.png#center" title="Apps generally make lots of database requests for a single user request"/></p><p>Apps often make lots of requests to the database for a single request from the user.
So the cumulative latency becomes much higher because the request/response time includes the higher latency cost multiple times.</p><table><thead><tr><th>Request</th><th>Time</th><th>Multiplier</th><th>Total</th></tr></thead><tbody><tr><td>user to app</td><td>20ms</td><td>1x</td><td>20ms</td></tr><tr><td>app to db</td><td>150ms</td><td>2x</td><td>300ms</td></tr><tr><td>-</td><td>-</td><td>-</td><td>320ms</td></tr></tbody></table><p>If the app is making multiple requests to the database for a single user request,
then it makes sense to put the app and the database as close together as possible to minimise this app to db latency.</p><p><img src="https://zknill.io/svg/loading.min.svg" data-src="/img/latency-to-app.png#center" data-srcset="/img/latency-to-app.png#center, /img/latency-to-app.png#center 1.5x, /img/latency-to-app.png#center 2x" data-sizes="auto" alt="/img/latency-to-app.png#center" title="App close to the database to reduce the overall latency"/></p><table><thead><tr><th>Request</th><th>Time</th><th>Multiplier</th><th>Total</th></tr></thead><tbody><tr><td>user to app</td><td>150ms</td><td>1x</td><td>150ms</td></tr><tr><td>app to db</td><td>20ms</td><td>2x</td><td>40ms</td></tr><tr><td>-</td><td>-</td><td>-</td><td>190ms</td></tr></tbody></table><p>By keeping the app and database close together, we can <strong>reduce the total response time for the user by 40%.</strong></p><h2 id="edge-computing-and-latency">Edge computing and latency</h2><p><img src="https://zknill.io/svg/loading.min.svg" data-src="/img/edge-to-database.png#center" data-srcset="/img/edge-to-database.png#center, /img/edge-to-database.png#center 1.5x, /img/edge-to-database.png#center 2x" data-sizes="auto" alt="/img/edge-to-database.png#center" title="Edge apps with centralised database"/></p><p>Edge computing encourages you to run your apps closer to where the users are making requests from,
under the premise that running closer to the users produces faster response times.</p><p>But as we’ve seen, the responses times for lots of round trips to a centralised database are slower than if the app was deployed near to the database.</p><p>Logically the next step is top get a copy of your data as close to all the edge locations.</p><p><img src="https://zknill.io/svg/loading.min.svg" data-src="/img/database-near-edge.png#center" data-srcset="/img/database-near-edge.png#center, /img/database-near-edge.png#center 1.5x, /img/database-near-edge.png#center 2x" data-sizes="auto" alt="/img/database-near-edge.png#center" title="Edge apps with distributed databases"/></p><h2 id="data-consistency">Data consistency</h2><p>Imagine a new user signs up to your app. All users need a unique username because that’s how your app identifies them:
<strong>how do you make sure the username is unique across all the copies of your data running on the edge?</strong></p><p>We are left with the problem that: the main blocker to developers adopting edge computing is data consistency.</p><p>You need some way of checking that the username the user is registering with is unique.
The only safe way to do that is to ask/be told by the other copies of the data if that username is unique or not.
But to consult all the other copies of the data, we’d need to contact them.
To contact the other copies of the data we will encounter the same cross-region latency that we suffered from when we had the database in a single location.</p><p><img src="https://zknill.io/svg/loading.min.svg" data-src="/img/cross-region-db-latency.png#center" data-srcset="/img/cross-region-db-latency.png#center, /img/cross-region-db-latency.png#center 1.5x, /img/cross-region-db-latency.png#center 2x" data-sizes="auto" alt="/img/cross-region-db-latency.png#center" title="Cross region database latency"/></p><h2 id="two-choices">Two choices</h2><p>If we want to maintain a copy of the data close to the edge app, and by extension close to the user,
and if we want the data to be consistent,
we have to deal with the cross region latency at some point.</p><p>The two choices we have boil down to; when do we want to deal with the cross-region latency required to make the data consistent?</p><ol><li>On writes – we can choose to contact the other copies of the data when writing a record, to make sure that no other users have already registered that username.</li><li>On reads – we can choose to handle the data consistency problems on reads.</li></ol><blockquote><p>Strictly, we can choose to do both, because my usage of “consistent” so far in this post is quite vague, but we will come to that in a moment.</p></blockquote><p>Lets start with <strong>writes</strong>. We know that we can’t have two users with the same username.</p><ul><li>Best case; the username isn’t taken,</li><li>Middle case; the username is taken,</li><li>Worst case; the username is being registered <em>just</em> as we are trying to register the username.</li></ul><p>Best and middle cases are quite similar, we just need to know if the username is taken or now. The worst case is a little harder, because in this example we have two competing
requests that are racing to register the username. We need a way to decide which one will (and did) win.</p><h2 id="append-only-logs">Append-only logs</h2><p>Pretty much all databases solve the problem of two competing requests with an append-only log.
Often called a Write-ahead log or WAL.
Even if the database consists of only a single database server, the database still has to manage conflicting concurrent requests, and will still use a log.</p><p>These logs are append only - that is the database can only write to them - individual log events cannot be deleted. (Although outdated records in the log can be trimmed as a whole.)</p><p>The database has exactly one writer to the log,
and when our two competing requests try and “write” (register the username),
exactly one of those requests will be first,
and the second will be rejected.</p><p><img src="https://zknill.io/svg/loading.min.svg" data-src="/img/append-only-log.png#center" data-srcset="/img/append-only-log.png#center, /img/append-only-log.png#center 1.5x, /img/append-only-log.png#center 2x" data-sizes="auto" alt="/img/append-only-log.png#center" title="Append only log"/></p><p>To guarantee that there’s exactly one writer to the log that our ‘register username’ write will go into, we need one database server to be responsible for that log.
This database server called the “leader” or “master”.</p><p><img src="https://zknill.io/svg/loading.min.svg" data-src="/img/write-forwarding.png#center" data-srcset="/img/write-forwarding.png#center, /img/write-forwarding.png#center 1.5x, /img/write-forwarding.png#center 2x" data-sizes="auto" alt="/img/write-forwarding.png#center" title="Write forwarding"/></p><p>In this diagram, the user is registering a username. The database in Australia is forwarding the write to the database in the USA. The database in the USA is the ’leader’ for the
username’s log, and writes the username to the log. The username is now ’taken’, and can’t be registered by anyone else.</p><p>We are dealing with the cross-region latency between Australia and USA when the write happens, to make sure that the data is consistent.
(To make sure that no two users can register the same username).</p><p>The problem is that the write is now in the USA database, but not in the Australia database.
If the user were to immediately make a request for their username, it wouldn’t exist in the Australia database (yet).</p><p>This property of the system / database (or lack of) is called <strong>read-your-own-writes</strong>. And describes a system where some data is available to be read immediately after its been
written.
Not being able to read your own writes creates a weird user experience for the user,
where they are unsure if they have actually completed the task they wanted to,
because they can’t immediately see the data they have just written.</p><p>To read the writes, we need replication. The log needs to be replicated back to the Australia database.</p><p><img src="https://zknill.io/svg/loading.min.svg" data-src="/img/read-own-writes.png#center" data-srcset="/img/read-own-writes.png#center, /img/read-own-writes.png#center 1.5x, /img/read-own-writes.png#center 2x" data-sizes="auto" alt="/img/read-own-writes.png#center" title="Read your own writes"/></p><p>The Australia database should only return a successful response to the user once it has received a segment of the log that contains the write that was originally forwarded to the USA database. This ensure that the Australia database can read its own writes.</p><p>If we didn’t care about the read-your-own-writes property, we could return to the user immediately and assume the replication would happen sometime later.</p><p>When touched on the <strong>‘Two choices’</strong> earlier, we covered writes but not reads. We saw how the database suffers from the inter-region latency when forwarding a write.</p><p>The thing about reads is; we might not care.
We might be perfectly happy that the France, etc database is slightly behind the other USA database.
We might not care that the most recent write has not been replicated to the France database yet.</p><h2 id="eventually-consistent">Eventually consistent</h2><p>If we don’t care that the most recent write on the database leader (USA) has not yet been replicated to the France database, then we call this system <strong>eventually consistent</strong>.
That is, <em>eventually</em> the write will be replicated to the France database, but we don’t know exactly when. And we possibly don’t care (depending on the exact usage of the system).</p><p>If we <em>did</em> care, we’d call this system <strong>strongly consistent</strong> and we would require the leader to only consider the write successful once it had been fully replicated to all the
other databases.
In this case, all the databases would have all the data all the time, but writes would be much slower, as we would have to wait for all the databases to receive and reflect the
write.</p><h2 id="on-reads">On reads</h2><p>There is one final way to get <strong>strongly consistent</strong> properties of the databases, without requiring the inter-region latency hit on writes. (As we have just been discussing, the
new data is replicated across the regions when it’s written).</p><p>This is number 2, from when we covered the <em>‘Two choices’</em>. On reads.</p><p><img src="https://zknill.io/svg/loading.min.svg" data-src="/img/read-forwarding.png#center" data-srcset="/img/read-forwarding.png#center, /img/read-forwarding.png#center 1.5x, /img/read-forwarding.png#center 2x" data-sizes="auto" alt="/img/read-forwarding.png#center" title="Read forwarding"/></p><p>Imagine that we hadn’t required the write to be replicated to the Australia database when it was added to the log, and instead embraced an <strong>eventually consistent</strong> system.</p><p>But we had a small number of cases where we needed to make sure that the read we were performing was <strong>strongly consistent</strong>
(that is, it reads exactly the data that any database has, not just the data that this database has received yet from replication.)</p><p>To perform a one-off strongly consistent read, we could forward that read to the leader (USA), add that read to the database log, and wait for the read to be replicated back to the Australia database.
Once the Australia database receives the read in the log, it knows that it has all the most up to date data for that specific point in time, and can safely execute the read from
its local datastore.</p><p>But once again, we have to suffer the cross-region latency for the read to be forwarded to the leader database and the log to be replicated back again.</p><h2 id="what-do-we-do">What do we do?</h2><p>As I said at the start:</p><blockquote><p>The main thing stopping developers from adopting edge computing is data consistency.</p></blockquote><p>We can put the apps near the users, and a copy of the data near the apps, but in doing so we sacrifice data consistency or we suffer network latency costs.</p><p>We can’t beat physics, and data can only be transmitted so fast across the network between regions. This means that we have to make choices about what kind of data consistency we
want, and importantly <strong>we have to decide: at which point do we want to deal with the latency</strong>.</p><p>Most internet apps are read-heavy, there are more reads than writes, so largely it makes sense to deal with the latency on writes.
We can do this by forwarding the writes to some leader for that piece of data (e.g. the log for usernames),
and waiting until that write is replicated back to us (so we can read our own writes).</p><h2 id="some-examples">Some examples</h2><p>The following are some examples of database systems that are optimised for read-heavy applications where we eat the latency cost on writes.</p><ul><li><a href="https://turso.tech" target="_blank" rel="noopener noreffer">Turso</a>: writes are forwarded to the leader, reads are local.</li><li><a href="https://github.com/superfly/litefs" target="_blank" rel="noopener noreffer">Litefs</a>: writes are forwarded to the leader, reads are local.</li><li><a href="https://www.postgresql.org/docs/current/warm-standby.html#SYNCHRONOUS-REPLICATION" target="_blank" rel="noopener noreffer">Postgres warm standby in ‘synchronous’ mode</a>: writes are committed to the leader and replica at the same time, reads can be from the replica.</li></ul><p>–</p><p>Finally it’s worth mentioning, some databases try and beat the system by structuring data in a specific way.
For example, giving the Australia database ownership over all the Australian data and user requests, and not letting region-specific datasets overlap with each other.
This can work, but it add some other difficult constraints when you want to query across datasets or join them together.</p></div></div>
  </body>
</html>
