<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://andersmurphy.com/2025/04/07/clojure-realtime-collaborative-web-apps-without-clojurescript.html">Original</a>
    <h1>Clojure: Realtime collaborative web apps without ClojureScript</h1>
    
    <div id="readability-page-1" class="page"><article><hgroup><p><time datetime="2025-04-07T00:00:00+00:00">07 Apr 2025</time></p></hgroup><hr/><p>Last week I made a fun little multiplayer web app. I&#39;ve embedded it below:</p><p>A few things to note about this web app:</p><ul><li>It is streaming the whole <code>&lt;main&gt;</code> element of the page from the server to the client every 200ms over SSE (server sent events).</li><li>It has zero ClojureScript.</li><li>It has zero user written JS.</li><li>It uses a tiny 11.4kb (brotli compressed) hypermedia framework called <a href="https://data-star.dev">Datastar</a>.</li></ul><h2 id="what_about_performance%3F">What about performance?</h2><p>Surely sending down the whole main body on every change is terrible for performance?!</p><p><img src="https://andersmurphy.com/assets/naive.png" alt="event listener image"/></p><p>There&#39;s no canvas here. There&#39;s no SVG. There&#39;s just a 1600 cell grid, each cell with it&#39;s own on-click listener. This is an incredibly naive implementation. Partly, to show how well it performs. Your CRUD app will be fine.</p><p>Under the hood Datastar uses a very fast morph algorithm that merges the old <code>&lt;main&gt;</code> fragment with the new <code>&lt;main&gt;</code> fragment only updating what has changed.</p><p><em>Update: It was pointed out on the Datastar discord that there is no reason not to leverage HTML bubble up events. Honestly, I completely forgot you could do this (too much time with react I guess?). So now there&#39;s only one top level event listener. I&#39;ve bumped the number of cells to 2500 to keep the volume of data over the wire roughly the same.</em></p><h2 id="what_about_the_network%3F">What about the network?</h2><p>Surely sending down the whole main body on every change is terrible for bandwidth?! </p><p>Turns out streaming compression is really good. Brotli compression over SSE (server sent events) can give you a 100-230:1 compression ratio over a series of backend re-renders. The compression is so good that in my experience it&#39;s more network efficient and more performant that fine grained updates with diffing (without any of the additional complexity). This approach also avoids the additional challenges of view and session maintenance.</p><h2 id="isn%27t_this_just_another_phoenix_live_view_clone%3F">Isn&#39;t this just another Phoenix Live View clone?</h2><p>No, it&#39;s much simpler than that. There&#39;s no connection state, server side diffing or web sockets. There&#39;s no reason the client has to connect/communicate with the same node. Effectively making it stateless.</p><h2 id="wait_did_you_say_sse%3F_why_not_websockets%3F">Wait did you say SSE? Why not websockets?</h2><p>Websockets sound great on paper. But, operationally they are a nightmare. I have had the misfortune of having to use them at scale (the author of Datastar had a similar experience). To list some of the challenges: </p><ul><li>firewalls and proxies, blocked ports</li><li>unlimited connections non multiplexed (so bugs lead to ddos)</li><li>load balancing nightmare</li><li>no compression.</li><li>no automatic handling of disconnect/reconnect.</li><li>no cross site hijacking protection</li><li>Worse tooling (you can inspect SSE in the browser).</li><li>Nukes mobile battery because it hammers the duplex antenna.</li></ul><p>You can fix some of these problems with websockets, but these fixes mostly boil down to sending more data... to send more data... to get you back to your own implementation of HTTP.</p><p>SSE on the other hand, by virtue of being regular HTTP,  work out of the box with, headers, multiplexing, compression, disconnect/reconnect handling, h2/h3, etc. </p><p>If SSE is not performant enough for you then you should probably be rolling your own protocol on UDP rather than using websockets. Or wait until <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebTransport">WebTransport</a> is supported in Safari (any day now ðŸ˜¬).</p><h2 id="do_i_have_to_learn_a_new_ui_model%3F">Do I have to learn a new UI model?</h2><p>With Datastar you can still use the same <code>view = f (state)</code> model that react uses. The difference is  the <code>view</code> is on the client and <code>f (state)</code> stays on the server.</p><h2 id="show_me_the_code%21">Show me the code!</h2><p>In this example I&#39;ll be using <a href="https://github.com/andersmurphy/hyperlith">hyperlith</a> an experimental mini framework that builds on Datastar. It handles a few things for us that you&#39;d normally have to manage yourself with Datastar (SSE, compression, connections, re-render rate, missed events, etc).</p><p><em>Note: Datastar itself is both backend language and framework agnostic.</em></p><p>Lets start with a minimal shim, this is for the initial page load:</p><pre><code><span>(</span>def <strong>default-shim-handler</strong>
  <span>(</span>h/shim-handler
    <span>(</span>h/html
      [:link#css {:rel &#34;stylesheet&#34; :type &#34;text/css&#34; :href <span>(</span>css :path<span>)</span>}]
      [:title nil &#34;Game of Life&#34;]
      [:meta {:content &#34;Conway&#39;s Game of Life&#34; :name &#34;description&#34;}]<span>)))</span>
</code></pre><p>Then we have a hiccup render function with a separate component <code>board-state</code> component:</p><pre><code><span>(</span>def <strong>board-state</strong>
  <span>(</span>h/cache
    <span>(</span>fn [db]
      <span>(</span>map-indexed
        <span>(</span>fn [id color-class]
          <span>(</span>h/html
            [:div.tile
             {:class         color-class
              :id            id}]<span>))</span>
        <span>(</span>:board @db<span>)))))</span>

<span>(</span>defn <strong>render-home</strong> [{:keys [db] :as _req}]
  <span>(</span>h/html
    [:link#css {:rel &#34;stylesheet&#34; :type &#34;text/css&#34; :href <span>(</span>css :path<span>)</span>}]
    [:main#morph.main
     [:h1 &#34;Game of Life <span>(</span>multiplayer<span>)</span>&#34;]
     [:div
      [:div.board {:data-on-click <span>(</span>format &#34;@post<span>(</span>&#39;/tap?id=%s&#39;<span>)</span>&#34; id<span>)</span>}
       <span>(</span>board-state db<span>)</span>]]]<span>))</span>
</code></pre><p>A user action:</p><pre><code><span>(</span>defn <strong>action-tap-cell</strong> [{:keys [sid db] {:strs [id]} :query-params}]
  <span>(</span>swap! db fill-cross <span>(</span>parse-long id<span>)</span> sid<span>))</span>
</code></pre><p>Some routes:</p><pre><code><span>(</span>def <strong>router</strong>
  <span>(</span>h/router
    {[:get <span>(</span>css :path<span>)</span>] <span>(</span>css :handler<span>)</span>
     [:get  &#34;/&#34;]        default-shim-handler
     [:post &#34;/&#34;]        <span>(</span>h/render-handler #&#39;render-home<span>)</span>
     [:post &#34;/tap&#34;]     <span>(</span>h/action-handler #&#39;action-tap-cell<span>)</span>}<span>))</span>
</code></pre><p>We pass the <code>render-home</code> and <code>action-tap-cell</code> functions into some helper functions that build handlers and we are good to go.</p><h2 id="so_how_do_you_change_this_code_to_make_it_multiplayer%3F">So how do you change this code to make it multiplayer?</h2><p>That&#39;s the neat part, you don&#39;t. It already is multiplayer. The function we defined in <code>render-home</code> does not distinguish between users so everyone sees the same thing! If we wanted to render different views for different users, we would just generate user specific views in that function.</p><p>The function <code>action-tap-cell</code> does distinguish between users though. It picks a colour based on their <code>sid</code>.</p><p>If you&#39;ve played around with <a href="https://github.com/hyperfiddle/electric">Electric Clojure</a> you might find this familiar.</p><h2 id="conclusion">Conclusion</h2><p><a href="https://data-star.dev">Datastar</a> pairs really well with Clojure and can make it trivial to implement highly interactive and collaborative web apps without ClojureScript. You should give it a go!</p><p>The full Datastar game of life source code can <a href="https://github.com/andersmurphy/hyperlith/blob/master/examples/game_of_life/src/app/main.clj">be found here</a>.</p><p><strong>Further Reading:</strong></p><ul><li><a href="https://github.com/kaepr/game-of-life-cljs">Original cljs game of life by Shagun Agrawal</a></li><li><a href="https://data-star.dev/guide/getting_started">Datastar docs</a></li><li><a href="https://github.com/andersmurphy/hyperlith/tree/master/examples">More hyperlith examples</a></li><li><a href="https://github.com/andersmurphy/hyperlith?tab=readme-ov-file#rational-more-like-a-collection-of-opinions">More of my thoughts on using Datastar</a></li><li><a href="https://example.andersmurphy.com">Direct link to the game</a>.</li></ul></article></div>
  </body>
</html>
