<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://thewebivore.com/using-ffmpeg-to-cut-trim-songs-together-with-crossfade/">Original</a>
    <h1>Using ffmpeg to cut/trim songs together with crossfade</h1>
    
    <div id="readability-page-1" class="page"><div>
			    <p>While doing something completely not-tech for a while, I’ve been teaching partner dancing at a local studio. Every Friday, we have a social dance.</p>
<p>At a social dance, we put on a playlist, but you don’t want to use regular Spotify or the like if you can avoid it … people are often dancing with folks they don’t know, and four minutes is a long time (most songs are between three and five minutes … and could be more!) to dance to one song. And depending on the dance, tiring!</p>
<p>So one of the teachers spends time custom-making these playlists, where the songs are only ~2-3 minutes long, and then it moves onto the next. And a variety of styles of dance.</p>
<p>I’ve used <a href="https://ffmpeg.org/">ffmpeg</a> often in conjunction my livecode music to prep field recordings (taken as video) into audio I can use in a set. And lo, of course, if I’ve got an audio [or video] thing to do, ffmpeg is the one to do it!</p>
<p>ffmpeg is so cool, and lots of StackOverflow/StackExchange questions helped me out. I commented my very inefficient, could definitely be much better, bash code below to try to illustrate how this worked.</p>
<pre><code>#!bin/bash
# Scoop up all the music you put in a folder and ordered
# ahead of this.
# Could you do that with computers? Definitely.
# Probably machine-learning something to ID dances and
# create a mixture so one dance isn&#39;t next to another.
# Or you can make an ordered folder.
arr=(music/*)

# Convert that first file (these are all mp3s) to a wav
# and cut it down.
# This way so we can operate in lossless wav land.
# atrim trims the audio from the start (0) to 160 seconds in
ffmpeg -i &#34;${arr[0]}&#34; -filter_complex &#34;atrim=0:160.0&#34; next_mix0.wav

# Keep going in the array now that you&#39;ve got inputs to start with.
# Start i at 1 though since next_mix0 exists
for ((i=1; i&lt;${#arr[@]}; i++)); do
    y=$(($i-1))
    echo &#34;Concatting next_mix$y.wav and ${arr[$i]}&#34;
    ffmpeg -i next_mix$y.wav -i &#34;${arr[$i]}&#34; -filter_complex &#34;[1]atrim=0:160.0[b];
        [0][b]acrossfade=d=10.0&#34; -y next_mix${i}.wav
    # Clean up previous file for tidiness
    rm next_mix$y.wav
done
</code></pre>
<h2>Hurdles</h2>
<p>Understanding &amp; debugging <strong>filter_complex</strong> is tough. What are those [bracket-y] things doing? I didn’t exactly successfully find great docs on this, so here’s my understanding.</p>
<p>The brackets before a filter argument (ex. “atrim”, which trims the audio) references the input(s) to send to that filter. So the [0] is the first argument. After the filter, there might be another [bracket] and that’s a labelled output. That output can then get used, ex. in the [0][b]acrossfade filter.</p>
<p><strong>Not</strong> <strong>re-encoding</strong>. At first, I was operating on all mp3s, and it took a while to run this. When it eventually worked (to my shock) I spot-checked the track and some of it sounded “watery”. Shout out to DuckDuckGo for understanding my question “ffmpeg sounds watery” enough to lead to the word “distorted”. This led back to one of the first Q&amp;A answers I found, <a href="https://superuser.com/questions/1363461/crossfade-many-audio-files-into-one-with-ffmpeg">“Crossfade many audio files into one”</a>.</p>
<p>Since an mp3 is compressed but a wav is not (*note, there’s probably much more nuance to this), working with wav both removed the distortion, <em>and</em> I could run the script wildly faster. Like, so fast.</p>
<h2>Things I learned</h2>
<p>I learned about atrim to trim audio in the filter_complex arg.</p>
<p>I learned about crossfade.</p>
<p>I learned about inputs/outputs in filter_complex, or, at least how I think they work.</p>
<p>I learned a bit about mp3 vs wav!</p>
<p>Some additional shout outs to the <a href="https://github.com/Luisin13/Youtube-mp3-cli">Youtube-mp3-cli</a> for no particular reason at all 👼🏻 and someone’s <a href="https://github.com/jac241/power_hour_creator">power hour creator program</a> that I didn’t use, but was like “good, I’m glad someone has done this” [0].</p>

<p>[0] A “power hour” is a drinking game popular in U.S. universities where you drink every minute/every time the song changes. It’s not a good idea.</p>
		    </div></div>
  </body>
</html>
