<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://thewebivore.com/using-ffmpeg-to-cut-trim-songs-together-with-crossfade/">Original</a>
    <h1>Using ffmpeg to cut/trim songs together with crossfade</h1>
    
    <div id="readability-page-1" class="page"><div>
			    <p>While doing something completely not-tech for a while, Iâ€™ve been teaching partner dancing at a local studio. Every Friday, we have a social dance.</p>
<p>At a social dance, we put on a playlist, but you donâ€™t want to use regular Spotify or the like if you can avoid it â€¦ people are often dancing with folks they donâ€™t know, and four minutes is a long time (most songs are between three and five minutes â€¦ and could be more!) to dance to one song. And depending on the dance, tiring!</p>
<p>So one of the teachers spends time custom-making these playlists, where the songs are only ~2-3 minutes long, and then it moves onto the next. And a variety of styles of dance.</p>
<p>Iâ€™ve used <a href="https://ffmpeg.org/">ffmpeg</a> often in conjunction my livecode music to prep field recordings (taken as video) into audio I can use in a set. And lo, of course, if Iâ€™ve got an audio [or video] thing to do, ffmpeg is the one to do it!</p>
<p>ffmpeg is so cool, and lots of StackOverflow/StackExchange questions helped me out. I commented my very inefficient, could definitely be much better, bash code below to try to illustrate how this worked.</p>
<pre><code>#!bin/bash
# Scoop up all the music you put in a folder and ordered
# ahead of this.
# Could you do that with computers? Definitely.
# Probably machine-learning something to ID dances and
# create a mixture so one dance isn&#39;t next to another.
# Or you can make an ordered folder.
arr=(music/*)

# Convert that first file (these are all mp3s) to a wav
# and cut it down.
# This way so we can operate in lossless wav land.
# atrim trims the audio from the start (0) to 160 seconds in
ffmpeg -i &#34;${arr[0]}&#34; -filter_complex &#34;atrim=0:160.0&#34; next_mix0.wav

# Keep going in the array now that you&#39;ve got inputs to start with.
# Start i at 1 though since next_mix0 exists
for ((i=1; i&lt;${#arr[@]}; i++)); do
    y=$(($i-1))
    echo &#34;Concatting next_mix$y.wav and ${arr[$i]}&#34;
    ffmpeg -i next_mix$y.wav -i &#34;${arr[$i]}&#34; -filter_complex &#34;[1]atrim=0:160.0[b];
        [0][b]acrossfade=d=10.0&#34; -y next_mix${i}.wav
    # Clean up previous file for tidiness
    rm next_mix$y.wav
done
</code></pre>
<h2>Hurdles</h2>
<p>Understanding &amp; debugging <strong>filter_complex</strong> is tough. What are those [bracket-y] things doing? I didnâ€™t exactly successfully find great docs on this, so hereâ€™s my understanding.</p>
<p>The brackets before a filter argument (ex. â€œatrimâ€, which trims the audio) references the input(s) to send to that filter. So the [0] is the first argument. After the filter, there might be another [bracket] and thatâ€™s a labelled output. That output can then get used, ex. in the [0][b]acrossfade filter.</p>
<p><strong>Not</strong> <strong>re-encoding</strong>. At first, I was operating on all mp3s, and it took a while to run this. When it eventually worked (to my shock) I spot-checked the track and some of it sounded â€œwateryâ€. Shout out to DuckDuckGo for understanding my question â€œffmpeg sounds wateryâ€ enough to lead to the word â€œdistortedâ€. This led back to one of the first Q&amp;A answers I found, <a href="https://superuser.com/questions/1363461/crossfade-many-audio-files-into-one-with-ffmpeg">â€œCrossfade many audio files into oneâ€</a>.</p>
<p>Since an mp3 is compressed but a wav is not (*note, thereâ€™s probably much more nuance to this), working with wav both removed the distortion, <em>and</em> I could run the script wildly faster. Like, so fast.</p>
<h2>Things I learned</h2>
<p>I learned about atrim to trim audio in the filter_complex arg.</p>
<p>I learned about crossfade.</p>
<p>I learned about inputs/outputs in filter_complex, or, at least how I think they work.</p>
<p>I learned a bit about mp3 vs wav!</p>
<p>Some additional shout outs to the <a href="https://github.com/Luisin13/Youtube-mp3-cli">Youtube-mp3-cli</a> for no particular reason at all ğŸ‘¼ğŸ» and someoneâ€™s <a href="https://github.com/jac241/power_hour_creator">power hour creator program</a> that I didnâ€™t use, but was like â€œgood, Iâ€™m glad someone has done thisâ€ [0].</p>

<p>[0] A â€œpower hourâ€ is a drinking game popular in U.S. universities where you drink every minute/every time the song changes. Itâ€™s not a good idea.</p>
		    </div></div>
  </body>
</html>
