<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://interrupt.memfault.com/blog/cpp-17-for-embedded">Original</a>
    <h1>C&#43;&#43;17’s useful features for embedded systems</h1>
    
    <div id="readability-page-1" class="page"><div>

        <p>Recently, our team at Meteksan Defense is upgrading its development environment to use newer versions of many tools and programming languages. One of the more difficult transitions has been the upgrade of our C++11 code base to C++17 for our embedded applications.</p>

<!-- excerpt start -->

<p>In this article, I will be showing some features of C++17 that can also be helpful in the embedded world.</p>

<!-- excerpt end -->

<p>Note that the migration from C++11 to C++17 covers C++14 also, hence I will touch upon some aspects of it as well.</p>

<p>The full list of features can be found <a href="https://github.com/AnthonyCalandra/modern-cpp-features#c17-language-features" target="_blank">on Anthony Calandra’s GitHub page</a>. I will be referencing it frequently.</p>

<p>Like Interrupt? <a href="https://go.memfault.com/interrupt-subscribe" target="_blank">Subscribe</a> to get our latest posts straight to your mailbox.</p>



<h2 id="notable-changes-in-c14">Notable Changes in C++14</h2>
<p>C++14 had smaller upgrades compared to the ones we saw when migrating to C++11 from C++03. Hence, there are only a few features in C++14 that you can use in an embedded system.</p>

<h3 id="binary-literals">Binary Literals</h3>

<p>If you are frequently dealing with bitwise operations and modifying registers, you will love these literals. Some compilers had extensions that support such literals, but now they have a place in the actual standard.</p>

<div><div><pre><code><span>uint8_t</span> <span>a</span> <span>=</span> <span>0b110</span><span>;</span>        <span>// == 6</span>
<span>uint8_t</span> <span>b</span> <span>=</span> <span>0b1111&#39;1111</span><span>;</span>  <span>// == 255</span>
</code></pre></div></div>

<h3 id="constraint-relaxed-constexpr">Constraint relaxed <em>constexpr</em>**</h3>

<p>With C++14, the syntax you can use in a constexpr function is expanded. Check out <a href="https://stackoverflow.com/a/31410986/10400598" target="_blank">this post on StackOverflow</a>.
The constexpr is beneficial in the embedded world since it can make calculations at compile time and reduce some code to constants. Note that an expression can only be calculated during the compile-time if all its requirements can be determined during the compilation.</p>

<div><div><pre><code><span>constexpr</span> <span>int</span> <span>factorial</span><span>(</span><span>int</span> <span>n</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>n</span> <span>&lt;=</span> <span>1</span><span>)</span> <span>{</span>
        <span>return</span> <span>1</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>return</span> <span>n</span> <span>*</span> <span>factorial</span><span>(</span><span>n</span> <span>-</span> <span>1</span><span>);</span>
    <span>}</span>
<span>}</span>
<span>factorial</span><span>(</span><span>5</span><span>);</span> <span>// == 120 (Calculated at compile time)</span>
</code></pre></div></div>

<h2 id="the-world-of-c17">The World of C++17</h2>
<p>In contrast to C++14, the C++17 standard changed the aura of C++ much more. Don’t get scared, you will still be able to continue using whatever you were using through this time. In addition to all you had before, you will now have a more powerful syntax and libraries with C++17.</p>

<h3 id="attributes">Attributes</h3>
<p>Let’s start with these three new attributes: <code>[[fallthrough]]</code>, <code>[[nodiscard]]</code>, and <code>[[maybe_unused]]</code>. As they are only considered at compile-time, you don’t need to worry about their efficiency at all. They exist only to enhance your code development phase.</p>

<h4 id="fallthrough">[[fallthrough]]</h4>

<p>With this attribute, you can now merge the bodies of two adjacent case branches in a switch without getting any warnings from the compiler. By using it, you tell the compiler that the prior case body is non-terminated intentionally.</p>

<div><div><pre><code><span>switch</span> <span>(</span><span>n</span><span>)</span> <span>{</span>
    <span>case</span> <span>1</span><span>:</span> <span>[[</span><span>fallthrough</span><span>]]</span>
        <span>// ...</span>
        <span>// no `break;`</span>
    <span>case</span> <span>2</span><span>:</span>
        <span>// ...</span>
        <span>break</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<h4 id="nodiscard">[[nodiscard]]</h4>

<p>I’m pretty sure you forgot to check the return value of your functions at least a hundred times. With this attribute, discarding the return values will become a reason for compiler warnings.</p>

<div><div><pre><code><span>[[</span><span>nodiscard</span><span>]]</span> <span>bool</span> <span>do_something</span><span>()</span> <span>{</span>
    <span>return</span> <span>is_success</span><span>;</span> <span>// true for success, false for failure</span>
<span>}</span>

<span>do_something</span><span>();</span> <span>/* warning: ignoring the return value of function declared with attribute &#39;nodiscard&#39; */</span>
</code></pre></div></div>

<h4 id="maybe_unused">[[maybe_unused]]</h4>

<p>Are you tired of casting the unused variables to void to suppress the warnings? Then, try this attribute to get rid of that irritating warnings.</p>

<div><div><pre><code><span>void</span> <span>my_callback</span><span>(</span><span>std</span><span>::</span><span>string</span> <span>msg</span><span>,</span> <span>[[</span><span>maybe_unused</span><span>]]</span> <span>bool</span> <span>error</span><span>)</span> <span>{</span>
    <span>// Don&#39;t care if `msg` is an error message, just log it.</span>
    <span>log</span><span>(</span><span>msg</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<h3 id="power-of-compile-time">Power of Compile-Time</h3>
<p>The power of checking things at compile-time fascinates me the most in C++. With C++17, this ability is further enhanced with some new features. Checking things without even deploying the code is quite beneficial when you think of the cumbersome debugging process in many embedded systems. Even transferring the executables to the target and preparing the environment for the execution and testing can be harsh and time-consuming. With compile-time programming, some parts of that tiring procedures can be eliminated.</p>

<h4 id="static-assertion-without-a-message">Static Assertion without a message</h4>

<p>You might think that we already had the <code>static_assert(..)</code> to check things at compile time. This time, the assertion mechanism works without providing an error message. This way, your code will look more clear.</p>



<h4 id="if-constexpr">if constexpr</h4>

<p><em>One of my favorites!</em> By using <code>if constexpr</code>, we can write code that is instantiated depending on compile-time conditions.</p>

<div><div><pre><code><span>template</span><span>&lt;</span><span>typename</span> <span>T</span><span>&gt;</span>
<span>auto</span> <span>length</span><span>(</span><span>const</span> <span>T</span><span>&amp;</span> <span>value</span><span>)</span> <span>noexcept</span> <span>{</span>
    <span>if</span> <span>constexpr</span> <span>(</span><span>std</span><span>::</span><span>integral</span><span>&lt;</span><span>T</span><span>&gt;::</span><span>value</span><span>)</span> <span>{</span> <span>// is number</span>
        <span>return</span> <span>value</span><span>;</span>
    <span>}</span>
    <span>else</span> <span>{</span>
        <span>return</span> <span>value</span><span>.</span><span>length</span><span>();</span>
    <span>}</span>
<span>}</span>

<span>int</span> <span>main</span><span>()</span> <span>noexcept</span> <span>{</span>
    <span>int</span> <span>a</span> <span>=</span> <span>5</span><span>;</span>
    <span>std</span><span>::</span><span>string</span> <span>b</span> <span>=</span> <span>&#34;foo&#34;</span><span>;</span>

    <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>length</span><span>(</span><span>a</span><span>)</span> <span>&lt;&lt;</span> <span>&#39; &#39;</span> <span>&lt;&lt;</span> <span>length</span><span>(</span><span>b</span><span>)</span> <span>&lt;&lt;</span> <span>&#39;\n&#39;</span><span>;</span> <span>// Prints &#34;5 3&#34;</span>
<span>}</span>
</code></pre></div></div>

<p>Before C++17, the above code would have needed to be two different functions for the string and integer inputs like below.</p>

<div><div><pre><code><span>int</span> <span>length</span><span>(</span><span>const</span> <span>int</span><span>&amp;</span> <span>value</span><span>)</span> <span>noexcept</span> <span>{</span>
    <span>return</span> <span>value</span><span>;</span>
<span>}</span>
<span>std</span><span>::</span><span>size_t</span> <span>length</span><span>(</span><span>const</span> <span>std</span><span>::</span><span>string</span><span>&amp;</span> <span>value</span><span>)</span> <span>noexcept</span> <span>{</span>
        <span>return</span> <span>value</span><span>.</span><span>length</span><span>();</span>
<span>}</span>
</code></pre></div></div>

<h4 id="constexpr-lambda">constexpr lambda</h4>

<p>If you also like using lambda expressions in your code, you will love this feature. Lambdas can also be invoked at compile-time by declaring them as constexpr.</p>

<div><div><pre><code><span>auto</span> <span>identity</span> <span>=</span> <span>[](</span><span>int</span> <span>n</span><span>)</span> <span>constexpr</span> <span>{</span> <span>return</span> <span>n</span><span>;</span> <span>};</span>

<span>static_assert</span><span>(</span><span>identity</span><span>(</span><span>123</span><span>)</span> <span>==</span> <span>123</span><span>);</span>
</code></pre></div></div>

<h3 id="syntactic-sugar">Syntactic Sugar</h3>
<p>In C++17, there are some features that help you to write your code in more beautiful ways. Even though their existence doesn’t affect the runtime performance dramatically, you will like using them.</p>

<h4 id="fold-expressions">Fold Expressions</h4>

<p>If you had a chance to use the variadic templates to elaborate a recursive algorithm with a variable amount of inputs or iterations, then you might face the issue of having to implement a terminator for that variadic template function. For example, the code below is written in C++11 and it accumulates the given numbers.</p>

<div><div><pre><code><span>int</span> <span>sum</span><span>()</span> <span>{</span> <span>return</span> <span>0</span><span>;</span> <span>}</span> <span>// Termination function</span>

<span>template</span><span>&lt;</span><span>typename</span> <span>...</span><span>Args</span><span>&gt;</span>
<span>int</span> <span>sum</span><span>(</span><span>const</span> <span>int</span><span>&amp;</span> <span>arg</span><span>,</span> <span>Args</span><span>...</span> <span>args</span><span>)</span> <span>{</span>
    <span>return</span> <span>arg</span> <span>+</span> <span>sum</span><span>(</span><span>args</span><span>...);</span>
<span>}</span>
</code></pre></div></div>
<p>This code wouldn’t compile if we didn’t implement the terminator that doesn’t take any inputs. Thanks to the fold expressions, you don’t have to implement a terminator anymore and your code will look way better than the old one. See below.</p>

<div><div><pre><code><span>template</span><span>&lt;</span><span>typename</span> <span>...</span><span>Args</span><span>&gt;</span>
<span>int</span> <span>sum</span><span>(</span><span>Args</span><span>&amp;&amp;</span><span>...</span> <span>args</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span><span>args</span> <span>+</span> <span>...);</span>
<span>}</span>
</code></pre></div></div>

<h4 id="nested-namespace">Nested Namespace</h4>

<p>I don’t know how the committee of C++ didn’t think of this before. No need to explain actually, see the difference between the nested namespace definitions below in C++11 and C++17 respectively.
s</p>
<div><div><pre><code><span>// C++11</span>
<span>namespace</span> <span>A</span> <span>{</span>
    <span>namespace</span> <span>B</span> <span>{</span>
        <span>namespace</span> <span>C</span> <span>{</span>
        <span>int</span> <span>i</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

<span>// C++17</span>
<span>namespace</span> <span>A</span><span>::</span><span>B</span><span>::</span><span>C</span> <span>{</span>
    <span>int</span> <span>i</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<h4 id="enhanced-conditional-statements">Enhanced Conditional Statements</h4>

<p>Wouldn’t it be more powerful if all conditional statements have the initialization section like the <code>for</code> statement has? With C++17, we now have the initialization part in conditional statements also.</p>

<p>This is one of the most powerful features I’ve seen so far since the variables that you create before entering a sequence of if-else statements or a switch-case will no more crowd in your local variable set.</p>

<div><div><pre><code><span>if</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>4</span><span>;</span> <span>i</span> <span>%</span> <span>2</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
    <span>cout</span> <span>&lt;&lt;</span> <span>i</span> <span>&lt;&lt;</span> <span>&#34; is even number&#34;</span> <span>&lt;&lt;</span> <span>endl</span><span>;</span>
<span>}</span>

<span>switch</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>rand</span><span>()</span> <span>%</span> <span>100</span><span>;</span> <span>i</span><span>)</span> <span>{</span>
    <span>default:</span>
        <span>cout</span> <span>&lt;&lt;</span> <span>&#34;i = &#34;</span> <span>&lt;&lt;</span> <span>i</span> <span>&lt;&lt;</span> <span>endl</span><span>;</span>
        <span>break</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<h4 id="inline-variables">Inline Variables</h4>

<p>Before C++17, we had to instantiate the in-class static variables in the source file. With the inline variables, you can merge the declaration and the initial assignment inside the class definition as below.</p>

<div><div><pre><code><span>struct</span> <span>BabaMrb</span> <span>{</span>
    <span>static</span> <span>const</span> <span>int</span> <span>value</span> <span>=</span> <span>10</span><span>;</span>
    <span>static</span> <span>inline</span> <span>std</span><span>::</span><span>string</span> <span>className</span> <span>=</span> <span>&#34;Hello Class&#34;</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<h3 id="miscellaneous">Miscellaneous</h3>
<p>There are numerous other features in C++17 that I couldn’t classify easily. We will cover them in this section.</p>

<h4 id="guaranteed-copy-elision">Guaranteed Copy Elision</h4>

<p>Copy elision, <em>i.e. return value optimization</em>, is an optimization implemented by most compilers to prevent extra copies in certain situations. As of C++17, copy elision is guaranteed when an object is returned directly. In some situations, even a single copy operation affects the performance of a system, <em>e.g. systems with strict real-time requirements</em>. In such cases, it’s better to make certain that you avoid copying in order not to deteriorate system performance.</p>

<div><div><pre><code><span>struct</span> <span>C</span> <span>{</span>
    <span>C</span><span>()</span> <span>{</span> <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>&#34;Default constructor&#34;</span> <span>&lt;&lt;</span> <span>std</span><span>::</span><span>endl</span><span>;</span> <span>}</span>
    <span>C</span><span>(</span><span>const</span> <span>C</span><span>&amp;</span><span>)</span> <span>{</span> <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>&#34;Copy constructor&#34;</span> <span>&lt;&lt;</span> <span>std</span><span>::</span><span>endl</span><span>;</span> <span>}</span>
<span>};</span>

<span>C</span> <span>f</span><span>()</span> <span>{</span>
    <span>return</span> <span>C</span><span>();</span>  <span>// Definitely performs copy elision</span>
<span>}</span>
<span>C</span> <span>g</span><span>()</span> <span>{</span>
    <span>C</span> <span>c</span><span>;</span>
    <span>return</span> <span>c</span><span>;</span>    <span>// May perform copy elision</span>
<span>}</span>

<span>int</span> <span>main</span><span>()</span> <span>{</span>
    <span>C</span> <span>obj</span> <span>=</span> <span>f</span><span>();</span> <span>// Copy constructor isn&#39;t called</span>
<span>}</span>
</code></pre></div></div>



<p>With the shared mutex, many readers can read an object on demand without locking it, while a write call will lock the object normally as you did before with a regular mutex. With that feature, read-only access operations will be faster as they will be able to occur simultaneously. <a href="https://ncona.com/2019/03/read-write-mutex-with-shared_mutex/" target="_blank">(Images)</a></p>

<h4 id="hardware-interference-size">Hardware Interference Size</h4>

<p>This new library feature helps you to determine the L1 cache line size during compilation. With this feature, you will be able to align your structures, buffers, etc. according to the L1 cache line size.
For me, this would be helpful when I was implementing a low-level, bare-metal DMA driver for an ARM Cortex-A9 core with C++11 where I had to manage the coherency between the cache and main memory manually. If you would like to know further, please take a look at <a href="https://stackoverflow.com/questions/68949450/invalidating-a-specific-area-of-data-cache-without-flushing-its-content" target="_blank">this post</a> of mine.</p>

<p>Although this feature is quite powerful, it isn’t implemented in any versions of GCC until version 12, so it is highly possible that your current compiler doesn’t even support it. Check out the code below to have a better understanding. You may need this feature one day.</p>

<div><div><pre><code><span>#ifdef __cpp_lib_hardware_interference_size // Undefined prior to C++17
</span>    <span>using</span> <span>std</span><span>::</span><span>hardware_constructive_interference_size</span><span>;</span>
    <span>using</span> <span>std</span><span>::</span><span>hardware_destructive_interference_size</span><span>;</span>
<span>#else
</span>    <span>// 64 bytes on x86-64 │ L1_CACHE_BYTES │ L1_CACHE_SHIFT │ __cacheline_aligned │ ...</span>
    <span>constexpr</span> <span>std</span><span>::</span><span>size_t</span> <span>hardware_constructive_interference_size</span>   <span>=</span> <span>64</span><span>;</span>
    <span>constexpr</span> <span>std</span><span>::</span><span>size_t</span> <span>hardware_destructive_interference_size</span>    <span>=</span> <span>64</span><span>;</span>
<span>#endif
</span><span>struct</span> <span>alignas</span><span>(</span><span>hardware_constructive_interference_size</span><span>)</span> <span>OneCacheLiner</span> <span>{</span> <span>// occupies one cache line</span>
    <span>std</span><span>::</span><span>atomic_uint64_t</span> <span>x</span><span>{};</span>
    <span>std</span><span>::</span><span>atomic_uint64_t</span> <span>y</span><span>{};</span>
<span>};</span>
</code></pre></div></div>

<h2 id="conclusion">Conclusion</h2>
<p>As opposed to C++14, C++17 came with many new features. Some of those features are beneficial in the world of embedded systems and some of them are not. I inspected the ones that I liked the most by directly utilizing them in my current designs.</p>

<p>The computation power range of embedded devices varies considerably between different products. Some of the features that I chose might not be appropriate in your firmware due to several reasons such as CPU performance, lack of compiler support, verification necessity, etc. Migration to C++17 might cost you a severe amount of time and effort. It’s better to know whether you require the migration or not.</p>

<!-- Interrupt Keep START -->

<p>Like Interrupt? <a href="https://go.memfault.com/interrupt-subscribe" target="_blank">Subscribe</a> to get our latest posts straight to your mailbox.</p>

<p>See anything you&#39;d like to change? Submit a pull request or open an issue at <a href="https://github.com/memfault/interrupt" target="_blank">GitHub</a></p>

<!-- Interrupt Keep END -->



    </div><p><span>
                <a href="https://interrupt.memfault.com/authors/caglayan">Çağlayan Dökme</a> is a young embedded software engineer who believes in the power of knowledge sharing.</span>

        </p></div>
  </body>
</html>
