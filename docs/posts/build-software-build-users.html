<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dima.day/blog/build-software-build-users/">Original</a>
    <h1>Build Software. Build Users</h1>
    
    <div id="readability-page-1" class="page"><div>  <p>Vibe coding has enabled us to build software incredibly quickly, but it’s also raised the question of software quality to new heights.
What does it mean for software to be high quality? Does it mean writing unit/integration/e2e tests for all possible code execution branches? Measuring code coverage? Having a comprehensive suite of test cases? And how do we even measure test comprehensiveness? Should we focus on happy paths or negative checks? Performance and stress testing? Accessibility? Running every possible test on each pull request? Security testing? Usability? The list goes on.</p>
<p>That’s a lot of testing types. But even if we write all of them, does that guarantee quality software?
Practice shows the answer is no. There’s a meme that illustrates this perfectly:</p>
<blockquote>
<p>A QA engineer walks into a bar and orders a beer.
She orders 2 beers, 0 beers, -1 beers.
The first customer comes in an orders a beer. They finish their drink, and then ask where the bathroom is.</p>
<p>The bar explodes.</p>
</blockquote>
<p>The beer ordering module was spotless—it could handle every possible way to order a beer. And yet the bar exploded.</p>
<h2 id="why-did-the-bar-explode">Why did the bar explode?</h2>
<p>The problem was that the engineers who built the bar hadn’t put themselves in their users’ shoes. They didn’t realize that people who order and drink beers in a bar typically need to use the bathroom after a couple of pints.
They could have known this if they’d studied their target users more deeply.
We can’t know every aspect of our users’ lives. But now we have LLMs—trained on essentially the entire internet. LLMs likely have a much better understanding of what our users need and want. So why not vibe code the users themselves?</p>
<h2 id="vibe-coding-users">Vibe coding users</h2>
<p>The idea is simple: choose your target users and understand them inside and out.
You could create a folder structure like this:</p>
<pre tabindex="0" data-language="txt"><code><span><span>/users</span></span>
<span><span>  /group1</span></span>
<span><span>    user.md</span></span>
<span><span>    /happy-paths</span></span>
<span><span>        requirement.flow.md</span></span>
<span><span></span></span></code></pre>
<p>In this example, <code>group1</code> represents a group of users who interact with our software. <code>user.md</code> contains the user profile—a description of who they are and what they do throughout their day, with our software being just one step in their life. <code>happy-paths</code> is a folder containing files that describe user flows through our software. These happy paths can be built the same way as <a href="https://agentskills.io/what-are-skills">agent skills</a>—using natural language, pseudocode, or actual code, depending on how precise the flow needs to be.</p>
<h2 id="workflow">Workflow</h2>
<p>The process is iterative:</p>
<pre tabindex="0" data-language="txt"><code><span><span>Vibe code users → Vibe code software</span></span>
<span><span>      ^                    |</span></span>
<span><span>      |                    |               </span></span>
<span><span>      |____________________|</span></span>
<span><span></span></span></code></pre>
<p>Step by step, you get closer to truly understanding your users while making your software simpler for them.</p>
<h2 id="simplicity-is-the-ultimate-sophistication">Simplicity is the ultimate sophistication</h2>
<p>Quality software, in my view, looks simple to its users. But achieving that simplicity requires deep understanding—the user’s workflows, capabilities, background knowledge, essentially everything about them and how our software fits into their lives.
We can run users as sub-agents that perform <code>happy paths</code> through our software and provide feedback. If we understand our target audience well enough to simulate their behavior using an agent (general-purpose agents like Claude Code, Open Code, Cline, or Copilot) with good accuracy, we unlock almost infinite potential to simplify our software and increase its quality. We can automate this process—having an agent vibe code the application while consulting with simulated users. In this paradigm, the human developer becomes just another user telling the agent what to build.</p>
<h2 id="how-is-it-different-from-personas-and-user-stories">How is it different from personas and user stories?</h2>
<p>This approach is quite similar to traditional personas and user stories. The key difference is that we vibe code the personas just like we vibe code the software— we start with the personas and user stories first. Building the software comes second. The personas and their stories become LLM agents that actually use your software—clicking buttons, reading information, and fulfilling their needs just like real users would.</p>
<h2 id="how-is-it-different-from-testing">How is it different from testing?</h2>
<p>This approach resembles current software testing practices, but with a crucial difference: the starting point. Typically, we vibe-code software first, then test it, trying to cover already-developed features with functional and non-functional tests.
Test-driven development exists, but it faces fundamental questions: What tests should we write? How do we know if tests/requirements are sensible and actually validate/represent what the software should do? And what <em>should</em> the software do in the first place?
In practice, TDD works well at the unit level, where the “user” of a function (usually another function) is well understood. But at the e2e level, everything becomes harder because we’re now dealing with actual human users—and we rarely understand them well enough.</p>
<h2 id="conclusion">Conclusion</h2>
<p>The key is to understand users first. Build an agent that represents your software’s user before you build the software itself. Then iterate: create an agentic user, build software, let users (both real and agentic) interact with it, refine the agentic user, improve the software, and repeat.
This is how we achieve truly quality software—software that’s simple in the eyes of those who actually use it.</p>  </div></div>
  </body>
</html>
