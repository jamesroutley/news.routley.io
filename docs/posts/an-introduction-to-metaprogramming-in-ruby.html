<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.appsignal.com/2023/07/26/an-introduction-to-metaprogramming-in-ruby.html">Original</a>
    <h1>An introduction to metaprogramming in Ruby</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>You&#39;ve heard of metaprogramming: code you write that generates other code dynamically. Without it, Rails as we know it wouldn&#39;t (and couldn&#39;t) exist. But there&#39;s a good chance you&#39;ve never done it yourself, and it&#39;s not hard to see why; even a brief excursion into the realm of metaprogramming can leave you beset with strange and foreign methods, unfamiliar syntax, and downright mystifying blocks of code.</p>
<p>It&#39;s true: metaprogramming <em>is</em> a relatively advanced topic. If you want to <em>really</em> dig in and leverage it on a deep level, it will take time, effort, and a different way of thinking than you&#39;re used to. But there&#39;s good news: You don&#39;t need to wade too deeply into the metaprogramming waters to discover useful methods and techniques to make your life and workflow a little easier.</p>
<p>In this post, we&#39;ll take a look at metaprogramming methods like <code>send</code>, <code>define_method</code>, and <code>method_missing</code> and show how they can solve problems we sometimes run into, even in normal Rails applications. But first, let&#39;s briefly define metaprogramming and explore when it might come in handy.</p>

<p>Maybe you&#39;ve got a couple of models in your app that, while being very similar, aren&#39;t identical — they have different attributes and methods. But both need to be acted on in a job, and you don&#39;t want to write what is essentially the same code more than once.</p>
<p>Maybe once (or twice), you hacked together a <del>kludge</del> masterpiece for a tight deadline on a new feature that got the job done, but you modified an existing model rather than creating a new one the way you would have if you&#39;d had more time. Now that feature needs to be expanded, requiring you to do it the &#34;right&#34; way. This can be intimidating, especially if your codebase references your current implementation all over your app.</p>
<p>Or maybe you rely on a third-party gem that isn&#39;t well-maintained, and you discover far too late that it&#39;s got a bug in it — right in the middle of a line of code full of metaprogramming.</p>
<p>I&#39;ve had all these things happen, and I solved them by leveraging some light metaprogramming, all without having to be an expert, and without too much effort. You can, too.</p>

<p>Metaprogramming is a set of techniques that Ruby offers us to write code that dynamically writes other code for us. Rather than working on data, metaprogramming works on other code. This is great because it means we can write more dynamic, flexible, and adaptable code if the situation calls for it.</p>
<p>It can help DRY up portions of our code, dynamically define methods we might need, and write useful and reusable pieces of software (like gems!) to make our lives easier.</p>
<p>In fact, Rails leverages metaprogramming on a large scale and to great effect. Any time anyone talks about Rails&#39; magic, they&#39;re really talking about its use of metaprogramming.</p>
<h2 id="caveats">Caveats</h2>
<p>Despite how useful metaprogramming is, it isn&#39;t without its drawbacks.</p>
<p>One issue is <strong>readability</strong>: a little metaprogramming here and there can go a long way and likely won&#39;t cause many headaches, but lots of it will hurt the readability of your code.
Many Rails engineers probably are not very familiar with it, so relying on it too heavily can prove frustrating both to your future self and to others who need to work on your code.</p>
<p><strong>Maintainability</strong> is also a concern; heavy use of metaprogramming can be mind-bending for even experienced Ruby developers. This means you should <em>document your code</em>. Ruby is an incredibly expressive, intuitive, and readable language, but if you&#39;re doing things others might find confusing, you should leave comments. You should also use access modifiers - e.g., <code>private</code>, <code>protected</code> - the way you would with other methods.</p>
<p>Another potential source of trouble: <strong>monkeypatching</strong>. While monkeypatching (dynamic modification of a class — typically, a Rails core class) can be useful, it should also be used sparingly and carefully. If we&#39;re not mindful, we can modify behavior in ways that, while perhaps solving one of our problems, can easily create dozens of others. For example, rather than fixing a small bug, adding a new, uniquely-named method, or simply extending the capabilities of a class, we might modify the behavior of existing methods used not just by our own application but by our gems (and even Rails itself), with potentially disastrous consequences. Check out our post <a href="https://blog.appsignal.com/2021/08/24/responsible-monkeypatching-in-ruby.html">Responsible Monkeypatching in Ruby</a> for more on monkeypatching.</p>
<p>Lastly, metaprogramming can make it <strong>hard to find things you&#39;re looking for</strong>, especially if you didn&#39;t write the code in the first place. If you find yourself trying to figure out how it&#39;s possible <code>CompanySpecificClass#our_special_method</code> exists on an object but isn&#39;t defined anywhere, metaprogramming could be the culprit (in this case, probably the use of <code>define_method</code>).</p>

<p>Let&#39;s explore some of the methods we mentioned earlier: <code>send</code>, <code>define_method</code>, and <code>method_missing</code>.</p>
<p>First, we&#39;ll take a look at <code>send</code>, what it does, and how it can help us DRY up our code.</p>
<h3 id="using-send">Using <code>send</code></h3>
<p>Remember the example we mentioned earlier (under the header &#39;When Is Metaprogramming Useful?&#39;) of a couple of similar models with different attributes and methods? In this case, both models need to be acted on in a job in a more or less identical manner.</p>
<p>Essentially, invoking <code>.send</code> allows us to dynamically pass methods (along with arguments) to an object, without necessarily knowing what that object (or method) might be at the time we write the code.</p>
<p>First, a word of caution: <code>send</code> can actually call both public and private methods. If you want to be very explicit (and careful), you can use <code>public_send</code> to ensure it&#39;s clear you&#39;re calling a public method. I&#39;ve never done this, but I&#39;ve also never used it to call any <code>private</code> or <code>protected</code> methods; if you do, you might want to use <code>public_send</code> and <code>send</code> for each use case.</p>
<p>So how does it work? Pretty simply. You just pass the method&#39;s name to the object you want to call like this: <code>my_object.send(:method_name)</code>. If you need to pass parameters/arguments, you can do so: <code>my_object.send(:method_name, argument1, argument2...)</code>. <code>send</code> accepts parameters the same way other methods do, so you can use named arguments, too.</p>
<p>So rather than doing something verbose like this:</p>


<p>We can simply pass our method as an argument and call it with <code>send</code>:</p>

<p><em><strong>Note</strong>: For the sake of simplicity and brevity, we&#39;re not raising an error if our object doesn&#39;t <code>respond_to?</code> the action passed into our above methods. But in a real app, we&#39;d probably want to raise an error to bring our attention to the fact something in our codebase is calling a non-existent method/attribute on the object.</em></p>
<h3 id="send-an-example-scenario"><code>send</code>: An Example Scenario</h3>
<p>Let&#39;s consider the following example. We&#39;ve got a <code>Purchase</code> model, representing a given purchase from an online store. That purchase could be anything from a single item of one type to many different items.</p>
<p>In the instance below, we&#39;re interested in people who bought a particular subscription, which may contain tickets to events (<code>purchase_events</code>), and/or vouchers for products (<code>purchase_products</code>).</p>
<p>Products and events are different things, but there&#39;s a lot of overlap, like <code>price</code>, <code>status</code> (sold, returned), etc. In this example, we will refund all instances of a particular item from a subscription, because customers were unable to redeem their purchase (an event was rained off, a company we source from ran out of a collectible, etc.).</p>

<p>What have we done here? Ordinarily, we might have ended up writing some if/else logic and duplicating most of this code or even two separate jobs. Instead, we&#39;ve dynamically sent the appropriate association and foreign key to objects within our query, keeping our code DRY.</p>
<p>We&#39;ve laid out the keys and associations here explicitly, but they could be passed in as arguments if we set up our call to the job differently. Our customers have now been refunded for the particular item(s) in this subscription cycle! (Let&#39;s assume there&#39;s a callback on those models that refunds the user when the item is marked <code>&#34;refunded&#34;</code>).</p>
<h3 id="using-define_method">Using <code>define_method</code></h3>
<p>Now, let&#39;s look at <code>define_method</code> and how it can help us with our earlier example where we moved over from storing data on one model where it didn&#39;t really belong to a new dedicated model.</p>
<p>Let&#39;s say we currently have a <code>Presentation</code> model. When we first added video capabilities to our app, we did it because our biggest customer had to play a single, long video about their business to their shareholders. We had a tight deadline, so rather than create a new, dedicated model, we just tacked on a few columns to our <code>Presentation</code> table, and it got the job done.</p>
<p>Now, though, because we&#39;ve advertised our app&#39;s recording and streaming capabilities, other clients are interested — and they need more than one video per <code>Presentation</code>. Unfortunately, we&#39;re still in a bit of a time crunch and have to roll this out fast.</p>
<p>We decide the quickest way to accomplish this without changing tons of code is to:</p>
<ul>
<li>Create a new <code>VideoAsset</code> model</li>
<li>Move existing columns over from <code>Presentation</code></li>
<li>Set a boolean <code>current_asset</code> which will update when our clients select the video they want</li>
</ul>

<p>What&#39;s going on here? We&#39;re dynamically defining methods on our <code>Presentation</code> model to replace the columns we dropped and moved over to <code>VideoAsset</code>. The existing calls in our codebase to <code>@presentation</code> objects will now first find the current <code>VideoAsset</code> associated with our <code>Presentation</code> and then call the corresponding column. We don&#39;t have to go around updating controllers and views everywhere!</p>
<p><em>It&#39;s worth noting that the methods defined above could also have been accomplished using ActiveSupport&#39;s <a href="https://api.rubyonrails.org/classes/Module.html#method-i-delegate">delegate</a> helper. <code>delegate</code> allows you to use this pattern more often, abstracting away the metaprogramming implementation:</em></p>

<h3 id="using-method_missing">Using <code>method_missing</code></h3>
<p>Finally, let&#39;s look at <code>method_missing</code>. It does pretty much what you&#39;d expect, given its name — it allows you to account for methods that don&#39;t exist but are called on an object or class. Let&#39;s take a look at turning methods we&#39;ve placed in our classes into methods that test for truthiness.</p>

<p>So, what&#39;s happening here?</p>
<p>Well, we&#39;ve basically recreated an <code>ActiveRecord</code> feature for our <code>User</code> model. Any column that exists on a table in Rails has an identically-named method ending in a <code>?</code> added to instances of its corresponding class. We&#39;ve done something similar with our <code>User</code> class — any undefined instance method called on a user object ending in a <code>?</code> will be tried against a method of the same name without its question mark, and turn the result into a boolean.</p>
<p>So, for example, <code>@user.purchase_totals?</code> will (rather than return a decimal representing the total amount of money a user has spent in our app) simply return <code>true</code> if the number is nonzero — otherwise, <code>false</code>.</p>
<p>Note the use of <code>present?</code> here. It accounts for things like empty strings and arrays, which otherwise would return true if we&#39;d used a double-bang to assess if it was truthy or not.</p>
<p>If there&#39;s no match, we default to calling <a href="https://www.rubyguides.com/2018/09/ruby-super-keyword/">super</a>, resulting in the expected behavior (a <code>NoMethodError</code> being thrown).</p>

<p>We&#39;ve covered some useful methods that can be used sparingly to help us out in everyday situations. But what about more advanced uses of metaprogramming? What else is it good for?</p>
<ul>
<li><strong><a href="https://en.wikipedia.org/wiki/Domain-specific_language">DSLs</a></strong>: As mentioned, ActiveRecord, the <a href="https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping">ORM</a> (and DSL) that ships with Rails heavily leverages metaprogramming. That&#39;s where all those automatic methods on our objects come from. Every column we add to a table becomes two methods on our instances — <code>column</code> and <code>column=</code> (and <code>column?</code> for those who were paying attention!). It isn&#39;t magic that&#39;s making this happen, it&#39;s metaprogramming — in fact, the use of the same <code>method_missing</code> method we talked about earlier! Metaprogramming is also responsible for Rails&#39; ability to automatically create methods like <code>find_by_first_name</code> and <code>find_by(first_name: &#34;name&#34;)</code>.</li>
<li><strong>Gems</strong>: If you&#39;re building a gem, chances are you&#39;ll want it to be flexible, adaptable, and to work with more than just one specific Rails stack. Most of the gems you regularly use have at least some degree of metaprogramming, and many use a lot to achieve the level of flexibility they offer.</li>
<li><strong>Dynamic APIs</strong>: Metaprogramming can help us design dynamic APIs by allowing us to define methods on the fly based on runtime information, rather than hardcoding every possible method. For example, a RESTful API might expose resources with dynamic paths and attributes based on the data model of the underlying application (this may sound familiar — Rails&#39; routing system does this). We can generate methods for each resource at runtime based on the database schema and dynamically respond to HTTP requests.</li>
<li><strong>Frameworks</strong>: As mentioned, Rails wouldn&#39;t be Rails without metaprogramming. While it&#39;s a particularly magical framework, almost any framework you build will need plenty of metaprogramming. If you&#39;re going to build your own (presumably far more lightweight) framework, you&#39;ll need to leverage metaprogramming.</li>
</ul>
<h2 id="wrapping-up">Wrapping Up</h2>
<p>We&#39;ve covered some real ground here! We learned about dynamic method definition with <code>define_method</code> and <code>method_missing</code>, and about dynamic method invocation with <code>send</code> and <code>public_send</code>.</p>
<p>We also talked about metaprogramming&#39;s pitfalls, including its issues with readability, maintainability, and searchability. Finally, we touched on more advanced use cases like writing gems, DSLs, and frameworks.</p>
<h2 id="further-learning">Further Learning</h2>
<p>There are a lot of resources out there for taking Ruby metaprogramming further.</p>
<p>RubyMonk offers a <a href="https://rubymonk.com/learning/books/2-metaprogramming-in-ruby">short but free course</a>.</p>
<p>A couple of other paid courses include:</p>
<ul>
<li><a href="https://www.udemy.com/course/ruby-metaprogramming/">Ruby Metaprogramming — Complete Course</a> from Udemy</li>
<li>Chris Oliver&#39;s comprehensive <a href="https://courses.gorails.com/advanced-ruby-for-rails-devs">Advanced Ruby: Behind the Magic</a>. In addition to digging deep into Rails, this also has a section on metaprogramming <em>and</em> DSLs.</li>
</ul>
<p>An oft-recommended book is <a href="https://www.amazon.co.uk/Metaprogramming-Ruby-Program-Like-Facets/dp/1941222129">Metaprogramming Ruby 2: Facets of Ruby</a>.</p>
<p>I hope you found this post useful. Thanks for reading!</p>
<p><strong>P.S. If you&#39;d like to read Ruby Magic posts as soon as they get off the press, <a href="https://blog.appsignal.com/ruby-magic">subscribe to our Ruby Magic newsletter and never miss a single post</a>!</strong></p></div></div></div>
  </body>
</html>
