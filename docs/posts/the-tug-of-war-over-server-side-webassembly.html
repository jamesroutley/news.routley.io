<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://digest.browsertech.com/archive/browsertech-digest-the-webassembly-rift/">Original</a>
    <h1>The tug-of-war over server-side WebAssembly</h1>
    
    <div id="readability-page-1" class="page"><div>

                

                
                    
                        <p>There is an ongoing tug-of-war over the future of server-side WebAssembly.</p>
<p>One side embraces the idea that Wasm was designed in the context of a broader <strong>web platform</strong>. Their approach to running Wasm outside of the browser is to transplant relevant parts of the web platform onto the server, and run Wasm within this browser-like context.</p>
<p>The other side sees Wasm as a CPU-independent bytecode, for which the browser is just one use case. Their approach is to standardize a syscall-like interface (<strong>WASI</strong>), akin to the one an operating system provides to native code.</p>
<p>The source of the rift is that Wasm doesn’t specify a particular interface with the outside world, by design. While Wasm itself is portable across platforms, it’s only really useful when paired with such an interface.</p>
<p>Although both sides generally imagine the industry converging on common standards so that code is interoperable between platforms, they are pulling towards <em>fundamentally incompatible visions</em> of what those common standards should look like.</p>
<h2>The Web Platform Side</h2>
<p>Compilers that produce browser-ready Wasm generate (at least) two files: the Wasm module itself, and a JavaScript shim. The JavaScript shim implements a bespoke <a href="https://en.wikipedia.org/wiki/Application_binary_interface" target="_blank">ABI</a> that exposes any relevant browser APIs to the module.</p>
<p><img alt="Diagram showing that the compiler produces app.wasm and app.js, which share a bespoke interface. app.js talks directly to browser APIs." src="https://buttondown-attachments.s3.us-west-2.amazonaws.com/images/d2121473-bf5a-4dfd-a040-4e8ddef381cf.png"/></p>
<p>Platforms that run Wasm outside of the browser piggyback on this compiler infrastructure by running the Wasm module inside a JavaScript runtime, typically <a href="https://v8.dev/" target="_blank">V8</a>. They can either mock existing browser APIs, or create their own interfaces that are compatible with the JavaScript shim generator.</p>
<p>This is <a href="https://github.com/cloudflare/workers-rs" target="_blank">how Cloudflare</a> supports Rust, for example. It’s also <a href="https://www.assemblyscript.org/standards-objections.html" target="_blank">advocated for</a> by AssemblyScript, one of the <a href="https://blog.scottlogic.com/2022/06/20/state-of-wasm-2022.html" target="_blank">most popular</a> Wasm-targeting languages.</p>
<p>Interoperability of this approach between runtimes depends on the underlying JavaScript APIs being interoperable. For example, a Wasm module is only cross-compatible between Node.js and Deno to the extent that the JavaScript APIs it calls (via the shim) are available on both.</p>
<p><img src="https://buttondown-attachments.s3.us-west-2.amazonaws.com/images/a01f192d-bf15-4505-9848-81314b9d6793.png" alt="WinterCG logo"/></p>
<p><a href="https://wintercg.org/" target="_blank">WinterCG</a> is an effort towards cross-runtime interoperability between browsers and non-browser runtimes. It has the support of a number of vendors including Cloudflare, Deno, Netlify, and Vercel.</p>
<p>The ultimate vision here is a world where JS and Wasm code can both be packaged into modules and run <a href="https://en.wikipedia.org/wiki/Isomorphic_JavaScript" target="_blank">isomorphically</a> in the server and in the browser.</p>
<p>The upside of this approach is that if a platform already supports JavaScript, it can support Wasm without really even knowing: Wasm just becomes an implementation detail of the module.</p>
<p>The downside of this approach is that it is inherently tied to JavaScript. JavaScript runtimes are heavyweight compared to Wasm-only runtimes, and doing interop through them requires spending extra CPU cycles casting datatypes into JavaScript values.</p>
<h2>The WASI Side</h2>
<p>The main alternative to shipping a JavaScript engine is to use a runtime that implements the <a href="https://wasi.dev/" target="_blank">WebAssembly Standard Interface</a> (WASI).</p>
<p>WASI comes from the <a href="https://bytecodealliance.org/" target="_blank">Bytecode Alliance</a>, an industry group which counts Google, Mozilla, Docker, and Fastly among its members.</p>
<p>WASI provides a POSIX-inspired (but <a href="https://github.com/bytecodealliance/wasmtime/blob/main/docs/WASI-rationale.md" target="_blank">deliberately non-POSIX</a>) ABI.</p>
<p><img alt="Diagram showing that the compiler generates app.wasm, which talks to a WASI runtime with the WASI ABI." src="https://buttondown-attachments.s3.us-west-2.amazonaws.com/images/971ec1f5-550f-4d49-b549-307497a59e2e.png"/></p>
<p>Currently, most WASI calls are thin wrappers around OS syscalls that provide access to stdio, filesystems, the system clock, and random number generation. In the future, WASI’s scope will likely include network sockets and threads.</p>
<p>Docker creator Solomon Hykes <a href="https://twitter.com/solomonstre/status/1111004913222324225" target="_blank">famously tweeted</a> that if WASI was around in 2008, Docker wouldn’t exist.</p>
<p><img alt="Solomon Hykes: If WASM+WASI existed in 2008, we wouldn’t have needed to create Docker. That’s how important it is. WebAssembly on the server is the future of computing. A standardized system interface was the missing link. Let’s hope WASI is up to the task!" src="https://buttondown-attachments.s3.us-west-2.amazonaws.com/images/2d73f74d-a15c-4367-ae44-11a08c58c6fa.png"/> </p>
<p>Four years after that tweet, though, WASI on its own still isn’t powerful enough to do table-stakes things like make an HTTP request.</p>
<p>Typically, vendors provide their own ABIs to fill such gaps: Fermyon uses <a href="https://github.com/deislabs/wasi-experimental-http" target="_blank">wasi-experimental-http</a>; wasmCloud provides an <a href="https://cosmonic.com/docs/capabilities/http_client/httpclient" target="_blank">HTTP capability</a>; Fastly defines a <a href="https://docs.rs/fastly/latest/fastly/struct.Request.html" target="_blank">Request</a> struct; WasmEdge provides a <a href="https://wasmedge.org/book/en/write_wasm/rust/networking.html" target="_blank">request API</a>. <a href="https://lunatic.solutions/" target="_blank">Lunatic</a> goes a level lower and provides a <a href="https://docs.rs/lunatic-networking-api/0.13.0/lunatic_networking_api/" target="_blank">TCP API</a>.</p>
<p>The problem with this state of things is that Wasm code becomes bound to a particular platform, and any language libraries that touch I/O need to be patched or replaced for each one.</p>
<p>For all the work that’s gone into making Wasm portable across CPU architectures, we’ve ended up with modules that are not even portable across platform vendors. After all, <em>wasn’t that the selling point of Docker?</em></p>
<h2>Will the component model save us?</h2>
<p>I’m optimistic about the Wasm <a href="https://github.com/WebAssembly/component-model" target="_blank">component model</a> becoming a forcing function for standardization here: as it matures, vendors will feel pressure to rip out their proprietary ABIs and replace them with components, and as they do, standard component interfaces will emerge.</p>
<p>There’s always a risk that the component model will just be a <a href="https://xkcd.com/927/" target="_blank">fifteenth competing standard</a>. But I’m hopeful, because the tech looks solid and the industry generally seems willing to embrace it.</p>
<h2>Where I land</h2>
<p>As much as I’m broadly in favor of (or at least, resigned to) the web platform becoming a <a href="https://driftingin.space/posts/all-software-is-web-software" target="_blank">universal operating system</a> of sorts, I’m rooting for the WASI/components side here.</p>
<p>I don’t think applications should have to pay the JavaScript tax every time they interact with the outside world. But more importantly, <em>it just feels more right</em>.</p>
<p>Case in point: the Rust crate <code>getrandom</code> is implemented on both the web and WASI. Compare the <a href="https://github.com/rust-random/getrandom/blob/master/src/js.rs" target="_blank">web platform implementation</a> to the <a href="https://github.com/rust-random/getrandom/blob/master/src/wasi.rs" target="_blank">WASI implementation</a>.</p>
<p>(This is a bit unfair because the former also handles the case of running on Node.js, but also consider that the WASI code can stand on its own whereas the web platform version also needs to generate JavaScript code to run.)</p>
<p>I’m hopeful that WASI will evolve over time to cover enough of <code>libc</code> that a lot of existing libraries (like database drivers and file loaders) can be compiled to it without major rewrites. If this happens, those proprietary ABIs can be torn down like scaffolding on a completed cathedral.</p>
<hr/>
<h2>Me elsewhere</h2>
<ul>
<li>I talked to Jack Bridger on <a href="https://www.youtube.com/watch?v=CmQfdU4ntlw" target="_blank">Scaling DevTools</a> about how we started the Browsertech meetups and this digest, among other things.</li>
<li>I spoke at <a href="https://www.youtube.com/watch?v=U7GJJzNtxlQ&amp;t=5976s" target="_blank">Real World React</a> about why multiplayer apps don’t have to be hard.</li>
</ul>
<p>Until next time,</p>
<p>– Paul</p>
                    
                
            </div></div>
  </body>
</html>
