<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://playfulprogramming.blogspot.com/2023/12/about-time.html">Original</a>
    <h1>How to unit test code that depends on time</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-8880646256958210359" itemprop="description articleBody">
<p>Suppose that the logic of your program depends on time. That is, you need to keep track of when something in the past happened, and what time it is now, and the logic of what to do depends on how much time passed between that previous event and now.</p><p>There are many programs with this kind of behaviour. My experience is primarily from networking, where we need to figure out if a response is timely or late. Such systems often uses timers, i.e. on some action, request a notification at a specific point in time in the future.</p><p>How do you design such a system so that it is testable?</p><p>The naïve approach, to just call <span>std::chrono::&lt;some_clock&gt;::now()</span>, whenever you need a time stamp, makes unit-tests more or less impossible, so avoid that.<br/></p><h2>Approach 1, the alias clock</h2><p>Instead of directly referring to  <span>std::chrono::&lt;some_clock&gt;::now()</span><span> in your code, you refer to </span><span>app_clock::now()</span><span>, and in system builds </span><span>app_clock</span><span> is defined to be </span><span>std::chrono::&lt;some_clock&gt;</span><span>, but in unit-tests, they&#39;re some test clock.</span></p><p><span>This is an improvement. In the tests, you now have a means to control what time it is and how time advances. However, a major drawback is that you need to have different builds of your unit under test depending on situation.</span></p><h2><span>Approach 2, template specialization access</span></h2><p><span>This is a neat trick, using (abusing?) how the template machinery works in C++.</span></p><p><span>Create an encapsulation like this:</span></p><!--HTML generated using hilite.me--><div><table><tbody><tr><td><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></td><td><pre><span>template</span> <span>&lt;</span><span>typename</span> ...<span>&gt;</span>
constexpr <span>auto</span> clock_impl <span>=</span> std<span>::</span>chrono<span>::</span>some_clock{};

<span>template</span> <span>&lt;</span><span>typename</span> ... Ts<span>&gt;</span>
<span>struct</span> app_clock
{
    <span>static</span>
    std<span>::</span>chrono<span>::</span>some_clock<span>::</span>time_point now()
    {
        <span>return</span> clock_impl<span>&lt;</span>Ts...<span>&gt;</span>.now();
    }
};
</pre></td></tr></tbody></table></div>
<p><span>Now whenever you call </span><span>app_clock::now()</span><span>, it will call </span><span>clock_impl&lt;&gt;.now()</span><span> which is </span><span>std::chrono::&lt;some_clock&gt;::now()</span><span>.</span></p><p><span>For our tests, we can define a test_clock.</span></p><div><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8</pre></td><td><pre><span>struct</span> test_clock
{
    <span>using</span> time_point <span>=</span> std<span>::</span>chrono<span>::</span>some_clock<span>::</span>time_point;
    <span>static</span> time_point <span>now</span>() { <span>return</span> {};}
};

<span>template</span> <span>&lt;&gt;</span>
constexpr <span>auto</span> clock_impl<span>&lt;&gt;</span> <span>=</span> test_clock{};
</pre></td></tr></tbody></table></div><p><span>Now we have a specialization for </span><span>clock_impl</span><span> that is our </span><span>test_clock</span><span>. It is imperative that the signatures of </span><span>test_clock::now()</span><span> and the default </span><span>std::chrono::some_clock::now()</span><span> are identical.</span></p><p><span>See an example at <a href="https://godbolt.org/z/GbWYaGc7q">https://godbolt.org/z/GbWYaGc7q</a> <br/></span></p><p><span>This overcomes the need for having separate compilations for tests and production.<br/></span></p><h2>Approach 3, the clock factory</h2><p> In this case, whenever the program needs to know what time it is, it calls <span>clock_factory::get_clock()</span>, which in production code returns some encapsulation of <span>std::chrono::&lt;some_clock&gt;</span>.</p><p>This is better. Now the only code that differs between a unit test build and a production build is what <span>clock_factory::get_clock()</span> returns.</p><p>Unfortunately these factories tends to be singletons, with all the problems that they bring.</p><p>If you want to model your test clock as a mock, you have the additional problem of how to ensure that the test code and the unit under test sees the same clock. It&#39;s also really difficult to correctly provide all the right expectations for the mock without over constraining the tests (exactly how many times should the time be asked for, and what time should be reported on each call?)<br/></p><h2>Approach 4, clocks from above</h2><p>Instead of having code ask for clocks from factories, you can model your program so that every class that needs to know the time has a constructor that accepts a clock and stores it as a member variable.</p><p>This gets rid of the singleton (yay!!!), but it adds a lot of extra storage and all the other problems remain.<br/></p><h2>Approach 5, pass time stamps</h2><p>Here the problem is turned on its head. What if the code doesn&#39;t need to ask for the time, but can be told what time it is?</p><p>An observation is that many systems like this only need to know the time at a few places in the code, typically at the source of events. Get the time when a message is received. Get the time on user input. Get the time when receiving a signal. Get the time when a timer fires.</p><p>Then, all actions that come as a result of these events, are passed the time stamp.</p><p>Passing a <span>chrono</span> <span>time_point</span> is cheap (it&#39;s typically a 64-bit value passed in a register).</p><p>Now tests become easy. All tests of code that needs to know the time are given time points as input, controlled in full by the test code.</p><p>An additional advantage is that you can (should!) instrument your timer code so that for every timer that fires, you keep track of how late (or early!) it fired. This is typically much more interesting than to measure CPU-load.</p><p>The disadvantage is a loss in precision of time. Some cycles will pass between getting the time stamp at the event source and the logic decision that depends on the time. The programs that I have experience in writing are not bothered with that loss of precision. Your program may be different, in which case one of the other approaches may be a better choice.</p><h2>Which to choose?</h2><p>If you can live with the loss of precision from Approach 5, pass time stamps, I think that is the preferred way. It makes everything so much easier. If the loss of precision is unacceptable, Alternative 2, template specialization access is probably the best option.<br/></p>

</div></div>
  </body>
</html>
