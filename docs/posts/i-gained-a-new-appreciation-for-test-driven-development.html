<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.worthe-it.co.za/blog/2023-02-09-i-was-saved-by-test-driven-development.html">Original</a>
    <h1>I gained a new appreciation for Test Driven Development</h1>
    
    <div id="readability-page-1" class="page"><div><section><div><h2>Abstract</h2><p>This is a short story about how I gained a new appreciation for Test Driven
Development.</p></div><p>I have two children. My second was born about a year ago. Now everybody warns
you before your first kid how tired you&#39;re going to be. How you&#39;re going to be
up in the middle of the night. When the second is on the way, you assume that
you know what you&#39;re in for. I learned the hard way that it&#39;s much harder with
two! You can&#39;t sleep when the baby sleeps if you also have a toddler to look
after.</p><p>About a month after my second child was born, I needed to go back to work. Being
tired meant that I had a short attention span, I was easily distracted, and I
couldn&#39;t keep as many details in my head as I usually would. Foolishly, I still
picked up the next most important feature on the team&#39;s backlog, and it was a
complex one.</p><p>So I had a complex issue I needed to get done, and I wasn&#39;t thinking very
well. I needed a plan. My saviour ended up being Test Driven Development.</p></section><h2>What is Test Driven Development</h2><section><p>Test Driven Development (TDD) is a way of writing software where you write
automated tests as an integral part of the software design and development
process. Specifically, it&#39;s a <b>test first</b> methodology, where you constantly
write a small test for something that isn&#39;t implemented, then implement it.</p><p>The TDD cycle is only three steps: Red, Green and Refactor.</p><ul><li><p>Red: Write a test (or update an existing test) to demonstrate the thing you
  want to be different. Run the test to verify that it actually tests what
  you&#39;re trying to change, and that it fails for the reason you think it
  should. Often in compiled languages it won&#39;t even compile at this point,
  because you write the test against the interface that you <b>want to exist</b>, not
  necessarily the interface you already have. This is usually called the &#34;red&#34;
  phase because most testing tools will highlight failed tests in red.</p></li><li><p>Green: Make the smallest change you can to make that test pass without
  breaking any of the other tests. It&#39;s fine at this point if the code is messy,
  doesn&#39;t solve the whole problem in a completely general way or has lots of
  duplication. Most test tools will give you a green summary if all tests pass,
  so this is the green step.</p></li><li><p>Refactor: Clean up any sins which were committed to get the tests to
  green. For example, if you copy pasted some code to get to green, this is the
  phase to remove the duplication. After this, the tests should still all be
  passing, since refactoring should maintain the same functionality.</p></li></ul><p>On the side, you keep a list of missing functionality so that you can focus on
one thing at a time without losing track of the big picture.</p><p>In a broader context, TDD is also often associated with <a href="https://www.goodreads.com/book/show/67833.Extreme_Programming_Explained">Extreme Programming</a>. The
practices of extreme programming include writing automated tests and writing
them before writing the code they&#39;re testing, so proponents of Extreme
Programming will also generally support TDD.</p></section><h2>I haven&#39;t quite followed a strict test first methodology up to now</h2><section><p>I wouldn&#39;t claim to be a TDD expert. I admit that I haven&#39;t always written my
tests before the code it&#39;s meant to test. I do generally write tests, but I
haven&#39;t always strictly added an automated test when I felt a feature was
trivial.</p><p>However, I am fortunate enough to have worked with people who were evangelical
about TDD. I&#39;d already learned the steps of TDD. I&#39;d done training courses like
<a href="https://www.coderetreat.org/">Code Retreats</a> facilitated by fantastic software engineers to practice TDD.</p><p>In other words, I had TDD in my tool belt even if it wasn&#39;t part of my daily
practice.</p></section><h2>How did it save me?</h2><section><p>Coming back from paternity leave, I was tired. Sleep deprivation is a better
word for it. Also, since I work from home, I still had regular baby
distractions. I really liked that I could still be around my family while
returning to work, but I couldn&#39;t rely on my usual ability to keep a lot of
moving parts in my head anymore. Instead, I pulled out TDD, and used it to chunk
the work down into tiny manageable pieces.</p><p>I started with writing a TODO list of tests which I felt I would need. In this
case, it was just unimplemented tests right in the source code. Luckily it
doesn&#39;t take much sustained focus to write a list like this. You can jot them
down in any order, and keep adding to the list later as new ideas occur.</p><p>Then, I picked just one test case. All I needed to do was write the code to
demonstrate what that part of the functionality should do. I don&#39;t need to
implement the functionality itself or anything, just the test.</p><p>Watching it fail was an important step. I was writing JavaScript, and there&#39;s a
bunch of ways to accidentally write tests that don&#39;t assert anything. For
example, you might forget to <code>await</code> a promise, and assert that that promise
itself is truthy rather than its result. See the test fail, and check that it
fails for the reason you think it should fail.</p><p>Next, I implemented just enough code for that one test. I didn&#39;t do something
silly like return hard coded wrong results, but I also didn&#39;t bother to think too
far ahead. I just needed enough focus to get the one test passing.</p><p>When the test was green, I knew that feature was locked in. If I accidentally
broke it (and I did accidentally break it), I would know about it immediately and
could change course.</p><p>While working, I did come up with new tests I would need. I added them to my
TODO list of unimplemented tests. When I&#39;d implemented all the tests, and they
were all passing, I knew I was done! That code has been fairly stable, even
though I wrote it when I wasn&#39;t at my best. Personally, I have a new
appreciation for TDD, and use it more than I did before as a default way of
working. Maybe I don&#39;t need it when I&#39;m at my best, but it really helps me to
keep the quality up when things are rough.</p></section><h2>Wrapping up, how can you learn more?</h2><section><p>So that&#39;s my story. I now try to be more disciplined about working in small
verifiable steps by writing one test at a time and implementing it.</p><p>If you want to learn more about TDD, I&#39;d recommend starting with Kent Beck&#39;s
book, <a href="https://www.goodreads.com/book/show/387190.Test_Driven_Development">Test Driven Development By Example</a>. There are many resources about TDD
online, but this book is the best one I&#39;ve found so far to go in depth
explaining what TDD is and how to practice it.</p><p>After that, go looking for people practicing TDD on systems similar to
yours. Same language, same type of application, etc. I&#39;ve gotten some great
insights about writing tests in Rust by reading <a href="https://matklad.github.io/2021/05/31/how-to-test.html">Matklad&#39;s article &#34;How to Test&#34;</a>.</p><p>I hope that you too take inspiration from my story to try out Test Driven
Development, even if you&#39;ve tried it before and it didn&#39;t stick.</p></section></div><p>I believe that software is an engineering discipline. In this article,
I make that argument by summarising the work of a few other authors
who have written on this topic, and offer my perspective on why this
terminology matters.</p><p>Property based testing is a useful technique for testing software. In
this article, I discuss property based testing, and show an example of
how I used a property based testing approach when competing in the
Entelect Challenge.</p></div>
  </body>
</html>
