<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.di.ens.fr/~cousot/AI/IntroAbsInt.html">Original</a>
    <h1>Abstract Interpretation in a Nutshell</h1>
    
    <div id="readability-page-1" class="page">
<hr/>




<hr/>

<!-- BeginIntoAbsInt -->
<p>This introduction to static analysis by abstract interpretation has the
objective of being simple, intuitive and informal. More technical
introductions as well as bibliographic references are provided in
[<a href="#Cousot81-1" name="CITECousot81-1">1</a>,<a href="#Cousot00-Dagstuhl-Paper" name="CITECousot00-Dagstuhl-Paper">2</a>,<a href="#Cousot00-TSI" name="CITECousot00-TSI">3</a>].</p>

 <h2><a name="tth_sEc1">1.</a>  Concrete semantics of programs</h2>

<p>The <em>concrete semantics</em> of programs formalizes the set of
all possible executions of this program in all possible execution
environments. If an execution is represented by a curve showing the
evolution of the vector <i>x</i>(<i>t</i>) of values of the input,
state and output variables of the program as a function of the time
<i>t</i>, this concrete semantics can be represented by a set of
curves (with continuous time for short):</p>


<h2><a name="tth_sEc2">2.</a>  Undecidability</h2>

<p>
The  concrete semantics of a program is an &#34;infinite&#34; mathematical object
which is <em>not computable</em>:
it is not possible to write a program
able to represent and to compute all possible executions of any program
in all its possible execution environments.</p>

<p>Hence, all non trivial questions about the concrete semantics of a
program are <em>undecidable</em>: it is not possible to write a program
able to answer any question about the possible executions of any program
(since the concrete semantics of this program would have to be
computable).</p>

<p>
The mathematical analogy is that there is no theorem prover
able, for example, to prove any theorem of arithmetics without
human assistance.</p>

<h2><a name="tth_sEc3">3.</a>  Specification of Safety Properties</h2>

<p>Safety properties of a program express that no possible execution of the 
program when considering all possible execution environments can reach an
erroneous state. Graphically, the set of these erroneous states can be
represented as a forbidden zone:
</p>

<h2><a name="tth_sEc4">4.</a>  Proof of Safety Properties</h2>

<p>The verification of safety properties consists in proving that the
intersection of the concrete semantics of the program with the forbidden
zone is empty. Since the program concrete semantics is not computable,
the verification problem is undecidable. It is not always possible to
answer the safety questions completely automatically, with finite computer
resources, without any uncertainty about the answer and without any
human intervention.</p>

<h2><a name="tth_sEc5">5.</a>  Testing/Debugging</h2>

<p>Testing/debugging consists in considering a subset of the possible executions:
</p>
 
<p>Testing/debugging is not a proof, since some erroneous trajectories
might be forgotten. This is the problem of <em>absence of coverage</em>.</p>

<h2><a name="tth_sEc6">6.</a>  Bounded model checking</h2>

<p>Bounded model checking consists in exploring the prefixes of the possible executions:
</p>
 
<p>Bounded model checking is not a proof, since late errors can be missed. This is the same problem of <em>absence of coverage</em>.</p>



<h2><a name="tth_sEc7">7.</a>  Abstract Interpretation</h2>

<p>Abstract interpretation consists in considering an <em>abstract semantics</em>,
that is a superset of the concrete program semantics:
</p>

<p>
The abstract semantics covers all possible cases. Whence, if the
abstract semantics is safe (i.e. does not intersect the forbidden zone)
then so is the concrete semantics.</p>

<h2><a name="tth_sEc8">8.</a>  Formal Methods</h2>

<p><em>Formal methods</em> are abstract interpretations which differ in
the way the abstract semantics is obtained. In all cases, the abstract
semantics must be chosen to be computer representable.</p>

<ul>
<li> In <em>model-checking</em>, the abstract semantics is provided manually
by the user in the form of a finitary model of the program execution
(for example a finite automaton) [<a href="#CousotCousot00-POPL" name="CITECousotCousot00-POPL">9</a>]. In some
cases the model can be computed automatically, by methods relevant to
static analysis.
</li>

<li> In <em>deductive methods</em> the abstract semantics is specified by
verification conditions and must be provided by the user in the form of
inductive properties (true at each program step, such as loop
invariants) satisfying these verification conditions
[<a href="#Cousot02-TCS" name="CITECousot02-TCS">5</a>]. The inductive properties must be found manually by
the user and the theorem prover sometimes needs assistance to prove that
they are indeed inductive. To help the user in this discovery task, some
of these  inductive properties can be computed automatically, by
techniques relevant to static analysis.
</li>

<li> In <em>static analysis</em>,
the abstract semantics is computed
automatically thanks to predefined approximations
[<a href="#Cousot81-1" name="CITECousot81-1">1</a>,<a href="#CousotCousot77-1" name="CITECousotCousot77-1">6</a>,<a href="#CousotCousot79-1" name="CITECousotCousot79-1">7</a>,<a href="#CousotCousot92-4" name="CITECousotCousot92-4">8</a>],
possibly manually parameterizable by the user.
</li>
</ul>

<p>In all cases, the abstract semantics should be sound
(section <a href="#sec-soundness">1.8</a>
), remain sufficiently precise to avoid false alarms
(section <a href="#sec-false-alarm">1.10</a>
) while remaining as simple as possible to avoid
combinatorial explosion phenomena (section <a href="#sec-Invariants">1.13</a>
).</p>

 <h2><a name="tth_sEc9">9.</a>  Erroneous Abstractions</h2>
<a name="sec-soundness">
</a>
<p>In formal methods the abstract semantics must be chosen as a superset
of the concrete semantics since otherwise reasonings in the abstract
might not be correct in the concrete:
</p>

<p>We say that an abstraction is <em>sound</em> (or <em>correct</em>) if the
abstract semantics covers all possible cases of the concrete semantics.
All formal methods are required to use sound abstractions: if a
potential error is not signaled that it should be definitely impossible.
Contrary to testing/debugging formal methods provide full coverage.</p>

 <h2><a name="tth_sEc10">10.</a>  Examples of Erroneous Abstractions</h2>

<p>Yet, some methods, presented as formal, do not explore
all possible trajectories, but only prefixes (such as
the &#34;bounded model-checking&#34;) or may not terminate
(such as the &#34;refinement model-checking&#34;) and therefore
should be considered as incorrect, since some errors
can be forgotten:
</p>

<h2><a name="tth_sEc11">11.</a>  False Alarms</h2>
<a name="sec-false-alarm"></a>

The abstract semantics on which formal methods rely are:
<ul>
<li> correct/sound, that is a superset of the concrete semantics, and

</li>

<li> simple, or at least simple enough to be representable in a machine.

</li>
</ul>

<p>In absence of alarms, this yields a corectness proof. However, the
consequence of the overapproximation of the possible executions is that
inexisting executions are considered, some of which are erroneous, which
leads to <em>false alarms</em> (also called <em>false positives</em>). A
false alarm corresponds to the case when the abstract semantics
intersects the forbidden zone while the concrete semantics does not
intersect this forbidden zone. So a potential error  is signaled which can
never occur in reality:
</p>

<h2><a name="tth_sEc12">12.</a>  Incompleteness of Formal Methods</h2>

<p>Automatic formal methods are all <em>incomplete</em>: there exists
an infinity of programs for which potential errors at execution
are signaled, even if they are definitely impossible in reality.</p>

<ul>
<li> In <em>model-checking</em> an alarm in the model may not correspond to an
inevitable error in the modelized system<a href="#tthFtNtAAB" name="tthFrefAAB"><sup>1</sup></a>.

</li>

<li> In <em>deductive methods</em>, false alarms may be
due to the impossibility to prove automatically that the user provided
invariant is indeed inductive.

</li>

<li> In <em>static analysis</em>, false alarms are due
to a lack of precision of the analysis.

</li>
</ul>

<p>Such false alarms are inevitable because all questions that formal
methods try to solve are undecidable. Il will always be possible to find
a program without any run-time error for which the abstract semantics
will be too imprecise to prove the absence of error fully automatically,
without any human intervention. The imprecision problem can often be
solved by choosing a more refined abstract semantics, which is more
precise and so often more complex, which results in larger computation
costs.</p>

 <h2><a name="tth_sEc13">13.</a>  Excluded Miracle</h2>

<p>In summary, with testing/debugging a subset of the possible program
executions is considered, so that errors can be forgotten. With abstract
interpretation-based formal methods, a superset of the possible
program executions is considered, so that, because of the potential
imprecision, one can invent errors that do not exist in reality (so
called &#34;false alarms&#34;).</p>

<p>Hence one would like to have correct formal methods (without erroneous
abstractions by absence of coverage) and complete (without false alarms
due to over-coverage). Such an abstraction does exists mathematically
[<a href="#Cousot00-SARA" name="CITECousot00-SARA">4</a>], but it is impossible to compute, and this because
if undecidability, which amounts to say that it is impossible to execute
the program in all possible execution environment in a finite time with
a finite memory.</p>

<h2><a name="tth_sEc15">14.</a>  Invariants</h2><a name="sec-Invariants">
</a>

<p>An <em>invariant</em> is a property which holds for all trajectories.</p>

<p>In the example below, a first invariant would be that all states
reachable during the course of the computation can be on any
trajectory. This is already an approximation since this leaves the
possibility to jump from one trajectory to another, and even to go
backwards.</p>

<p>A second invariant, less precise, would be that all trajectories are in
the green zone 
<img src="https://www.di.ens.fr/~cousot/AI/pict/vert.gif" alt="vert" width="15" height="15"/>
. This is a less precise
approximation which leaves the possibility to reach points out of any
trajectory:
</p>

<p>This second invariant imples a third one, even less precise, stating that all
trajectories are outside the forbidden red zone 
<img src="https://www.di.ens.fr/~cousot/AI/pict/rouge.gif" alt="rouge" width="15" height="15"/>:
</p>

<h2><a name="tth_sEc15">15.</a>  Program Abstract Invariants</h2>

<p>A <em>program invariant</em> is a program property which holds during the
program execution. The ASTRÉE static analyzer computes automatically
an abstract semantics which consists of <em>local abstract invariants</em>
attached to program points or to program blocks stating properties about
part of the program variables which are visible at that program point or
withing that block. These local invariants holds of the involved
variables whenever control reaches that program point or stays within
that block.</p>

<h2><a name="tth_sEc17">16.</a>  Abstract Domains</h2>

<p>An <em>abstract domain</em> of the ASTRÉE static analyzer is a
computer representation of a given category of invariants and of the
operations involved in the computation of these abstract invariants.
ASTRÉE uses a great number of abstract domains which are combined to
obtain complex abstract invariants. The term &#34;abstract&#34; makes
reference to the fact that the computed invariants are correct
approximations of the program concrete semantics.</p>

<p>A classical abstract domain is that of <em>intervals</em>
[<a href="#Cousot81-1" name="CITECousot81-1">2</a>,<a href="#CousotCousot77-1" name="CITECousotCousot77-1">6</a>,<a href="#CousotCousot92-4" name="CITECousotCousot92-4">8</a>] which approximate an
ordered set of values by their minimum and their maximum. Applied to our
example, this interval abstraction yields the following invariant:
</p>

<h2><a name="tth_sEc17">17.</a>  More on abstract interrpetation</h2>

More <a href="http://www.di.ens.fr/~cousot/AI/">topcis and references on abstract interrpetation</a> and a course [<a href="#CousotAIMIT" name="CousotAIMIT">10</a>]
are also available online.

<!-- EndIntoAbsInt -->

<h2>Bibliography</h2>

<dl compact="">
<!--
 <dt><a href="#BlanchetCousotEtAl02-NJ" name="BlanchetCousotEtAl02-NJ">[1]</a></dt><dd>
B. Blanchet, P. Cousot, R. Cousot, J. Feret, L. Mauborgne, A.
  Miné, D. Monniaux, and X. Rival.
 <a href="http://www.di.ens.fr/~cousot/COUSOTpapers/Jones-Festschrift-02.shtml">Design and implementation of a special-purpose static program
  analyzer for safety-critical real-time embedded software</a>, invited chapter.
 In T. Mogensen, D.A. Schmidt, and I.H. Sudborough, editors,
  <em>The Essence of Computation: Complexity, Analysis, Transformation. Essays
  Dedicated to Neil D. Jones</em>, LNCS 2566, pages 85-108. Springer, 2002.

</dd>
-->
<!--
 <dt><a href="#BlanchetCousotEtAl03-PLDI" name="BlanchetCousotEtAl03-PLDI">[2]</a></dt><dd>
B. Blanchet, P. Cousot, R. Cousot, J. Feret, L. Mauborgne, A.
  Miné, D. Monniaux, and X. Rival.
 <a href="http://www.di.ens.fr/~cousot/COUSOTpapers/PLDI03.shtml">A static analyzer for large safety-critical software</a>.
 In <em>Proc. ACM SIGPLAN '2003 Conf. PLDI</em>, pages 196-207,
  San Diego, CA, US, 7-14 June 2003. ACM Press.

</dd>
-->
 <dt><a href="#Cousot81-1" name="Cousot81-1">[1]</a></dt><dd>
P. Cousot.
 <a href="http://www.di.ens.fr/~cousot/COUSOTpapers/PFA81.shtml">Semantic foundations of program analysis</a>.
 In S.S. Muchnick and N.D. Jones, editors, <em>Program Flow
  Analysis: Theory and Applications</em>, chapter 10, pages 303-342.
  PrenticeHall, 1981.

</dd>
 <dt><a href="#Cousot00-Dagstuhl-Paper" name="Cousot00-Dagstuhl-Paper">[2]</a></dt><dd>
P. Cousot.
 <a href="http://www.di.ens.fr/~cousot/COUSOTpapers/LNCS2000-01.shtml">Abstract interpretation based formal methods and future challenges</a>,
  invited paper.
 In R. Wilhelm, editor, <em>« Informatics - 10 Years Back, 10
  Years Ahead »</em>, volume 2000 of <em>LNCS</em>, pages 138-156. Springer, 2000.


</dd>
 <dt><a href="#Cousot00-TSI" name="Cousot00-TSI">[3]</a></dt><dd>
P. Cousot.
 <a href="http://www.di.ens.fr/~cousot/COUSOTpapers/TSI00.shtml">Interprétation abstraite</a>.
 <em>TSI</em>, 19(1-2-3):155-164, Jan. 2000.


</dd>
 <dt><a href="#Cousot00-SARA" name="Cousot00-SARA">[4]</a></dt><dd>
P. Cousot.
 <a href="http://www.di.ens.fr/~cousot/COUSOTpapers/SARA-00.shtml">Partial completeness of abstract fixpoint checking</a>, invited paper.
 In B.Y. Choueiry and T. Walsh, editors, <em>Proc.
  4<sup><i>th</i></sup> Int. Symp. SARA &#39;2000</em>, Horseshoe Bay, TX, US,
  LNAI 1864, pages 1-25. Springer, 26-29 Jul. 2000.


</dd>
 <dt><a href="#Cousot02-TCS" name="Cousot02-TCS">[5]</a></dt><dd>
P. Cousot.
 <a href="http://www.di.ens.fr/~cousot/COUSOTpapers/TCS02-1.shtml">Constructive design of a hierarchy of semantics of a transition
  system by abstract interpretation</a>.
 <em>Theoret. Comput. Sci.</em>, 277(1-2):47-103, 2002.


</dd>
 <dt><a href="#CousotCousot77-1" name="CousotCousot77-1">[6]</a></dt><dd>
P. Cousot and R. Cousot.
 <a href="http://www.di.ens.fr/~cousot/COUSOTpapers/POPL77.shtml">Abstract interpretation: a unified lattice model for static analysis
  of programs by construction or approximation of fixpoints</a>.
 In <em>4<sup><i>th</i></sup> POPL</em>, pages 238-252, Los Angeles, CA,
  1977. ACM Press.


</dd>
 <dt><a href="#CousotCousot79-1" name="CousotCousot79-1">[7]</a></dt><dd>
P. Cousot and R. Cousot.
 <a href="http://www.di.ens.fr/~cousot/COUSOTpapers/POPL79.shtml">Systematic design of program analysis frameworks</a>.
 In <em>6<sup><i>th</i></sup> POPL</em>, pages 269-282, San Antonio, TX,
  1979. ACM Press.


</dd>
 <dt><a href="#CousotCousot92-4" name="CousotCousot92-4">[8]</a></dt><dd>
P. Cousot and R. Cousot.
 <a href="http://www.di.ens.fr/~cousot/COUSOTpapers/PLILP92.shtml">Comparing the Galois connection and widening/narrowing approaches
  to abstract interpretation</a>, invited paper.
 In M. Bruynooghe and M. Wirsing, editors, <em>Proc.
  4<sup><i>th</i></sup> Int. Symp. PLILP &#39;92</em>, Leuven, BE, 26-28 Aug.
  1992, LNCS 631, pages 269-295. Springer, 1992.


</dd>
 <dt><a href="#CousotCousot00-POPL" name="CousotCousot00-POPL">[9]</a></dt><dd>
P. Cousot and R. Cousot.
 <a href="http://www.di.ens.fr/~cousot/COUSOTpapers/POPL00.shtml">Temporal abstract interpretation</a>.
 In <em>27<sup><i>th</i></sup> POPL</em>, pages 12-25, Boston, MA, Jan.
  2000. ACM Press.

</dd>
</dl>

<h2>Online courses on abstract interpretation</h2>


 <dt><a href="#CousotAIMIT" name="CousotAIMIT">[10]</a></dt><dd>
P. Cousot.
 <a href="http://web.mit.edu/afs/athena.mit.edu/course/16/16.399/www/">MIT 
 Course 16.399: Abstract Interpretation</a>.
 <a href="http://web.mit.edu/afs/athena.mit.edu/course/16/16.399/www/"><tt>http://web.mit.edu/afs/athena.mit.edu/course/16/16.399/www/</tt></a>, 2005.

</dd>



<hr/><h3>Notes:</h3>


<a name="tthFtNtAAB"></a><a href="#tthFrefAAB"><sup>1</sup></a> One must also note the
possibility of <em>false negatives</em> corresponding to properties which
are true of the model but are false of the concrete semantics of the
modelized system, which is too often the case of &#34;liveness&#34;
properties.

<hr/>


</div>
  </body>
</html>
