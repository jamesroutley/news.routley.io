<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://doublefree.dev/go-race-mutex-blindspot/">Original</a>
    <h1>Go’s race detector has a mutex blind spot</h1>
    
    <div id="readability-page-1" class="page"><div>
    

    
        
    

    
        

        <p>
            <i>
                <time datetime="2025-07-28T05:01Z">
                    28 Jul, 2025
                </time>
            </i>
        </p>
    

    <p>I recently read Ralf Jung&#39;s blog post &#34;<a href="https://www.ralfj.de/blog/2025/07/24/memory-safety.html">There is no memory safety without thread safety</a>&#34; which mentions that Go is not a memory safe language in the presence of data races.</p>
<p>&#34;But Go comes with a built in data race detector&#34; some might say.</p>
<p>This reminded me of a quirk in Go&#39;s dynamic data race detection that causes it to miss data races in executed code that could easily be spotted by a human.</p>
<p>Here is the code the data race detector struggles with:</p>
<div><pre><span></span><span>package</span><span> </span><span>main</span>

<span>import</span><span> </span><span>(</span>
<span>        </span><span>&#34;fmt&#34;</span>
<span>        </span><span>&#34;sync&#34;</span>
<span>)</span>

<span>var</span><span> </span><span>counter</span><span> </span><span>int</span>
<span>var</span><span> </span><span>mutex</span><span> </span><span>sync</span><span>.</span><span>Mutex</span>

<span>func</span><span> </span><span>increment</span><span>(</span><span>wg</span><span> </span><span>*</span><span>sync</span><span>.</span><span>WaitGroup</span><span>,</span><span> </span><span>id</span><span> </span><span>int</span><span>)</span><span> </span><span>{</span>
<span>        </span><span>defer</span><span> </span><span>wg</span><span>.</span><span>Done</span><span>()</span>
<span>        </span><span>mutex</span><span>.</span><span>Lock</span><span>()</span>
<span>        </span><span>counter</span><span>++</span>
<span>        </span><span>fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;Counter: %d\n&#34;</span><span>,</span><span> </span><span>counter</span><span>)</span>
<span>        </span><span>mutex</span><span>.</span><span>Unlock</span><span>()</span>
<span>        </span><span>if</span><span> </span><span>id</span><span> </span><span>==</span><span> </span><span>1</span><span> </span><span>{</span>
<span>            </span><span>counter</span><span>++</span><span>;</span>
<span>        </span><span>}</span>
<span>}</span>

<span>func</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span>
<span>        </span><span>var</span><span> </span><span>wg</span><span> </span><span>sync</span><span>.</span><span>WaitGroup</span>
<span>        </span><span>wg</span><span>.</span><span>Add</span><span>(</span><span>2</span><span>)</span>

<span>        </span><span>go</span><span> </span><span>increment</span><span>(</span><span>&amp;</span><span>wg</span><span>,</span><span> </span><span>0</span><span>)</span>
<span>        </span><span>go</span><span> </span><span>increment</span><span>(</span><span>&amp;</span><span>wg</span><span>,</span><span> </span><span>1</span><span>)</span>

<span>        </span><span>wg</span><span>.</span><span>Wait</span><span>()</span>
<span>        </span><span>fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;Final: %d\n&#34;</span><span>,</span><span> </span><span>counter</span><span>)</span>
<span>}</span>
</pre></div>
<p>Threads 0 and 1 increment a shared counter, guarded by a lock. Thread 1 then performs an additional increment on the counter, not guarded by the lock.</p>
<p>If thread 1 acquires the lock first, it is possible for the unguarded write to happen at the same time as the guarded write on thread 0.</p>
<p>The race detector confirms this:</p>
<div><pre><span></span>%<span> </span>go<span> </span>run<span> </span>-race<span> </span>race.go
Counter:<span> </span><span>1</span>
<span>==================</span>
WARNING:<span> </span>DATA<span> </span>RACE
Read<span> </span>at<span> </span>0x000105026dd0<span> </span>by<span> </span>goroutine<span> </span><span>6</span>:
<span>  </span>main.increment<span>()</span>
<span>      </span>/Users/brad/race.go:14<span> </span>+0x80
<span>  </span>main.main.gowrap1<span>()</span>
<span>      </span>/Users/brad/race.go:26<span> </span>+0x38

Previous<span> </span>write<span> </span>at<span> </span>0x000105026dd0<span> </span>by<span> </span>goroutine<span> </span><span>7</span>:
<span>  </span>main.increment<span>()</span>
<span>      </span>/Users/brad/race.go:18<span> </span>+0x158
<span>  </span>main.main.gowrap2<span>()</span>
<span>      </span>/Users/brad/race.go:27<span> </span>+0x38

Goroutine<span> </span><span>6</span><span> </span><span>(</span>running<span>)</span><span> </span>created<span> </span>at:
<span>  </span>main.main<span>()</span>
<span>      </span>/Users/brad/race.go:26<span> </span>+0xac

Goroutine<span> </span><span>7</span><span> </span><span>(</span>finished<span>)</span><span> </span>created<span> </span>at:
<span>  </span>main.main<span>()</span>
<span>      </span>/Users/brad/race.go:27<span> </span>+0x110
<span>==================</span>
Counter:<span> </span><span>3</span>
Final:<span> </span><span>3</span>
Found<span> </span><span>1</span><span> </span>data<span> </span>race<span>(</span>s<span>)</span>
</pre></div>
<p>... but only sometimes ...</p>
<div><pre><span></span>%<span> </span>go<span> </span>run<span> </span>-race<span> </span>race.go
Counter:<span> </span><span>1</span>
Counter:<span> </span><span>2</span>
Final:<span> </span><span>3</span>
</pre></div>
<p>Go&#39;s data race detector is pretty neat. It detects unsynchronized concurrent accesses to shared memory, regardless of the actual timing during execution. For example, even if you add a sleep to ensure the threads never actually run simultaneously, Go will still report a race because they access the same variable without synchronization.</p>
<div><pre><span></span><span>func</span><span> </span><span>increment</span><span>(</span><span>wg</span><span> </span><span>*</span><span>sync</span><span>.</span><span>WaitGroup</span><span>,</span><span> </span><span>id</span><span> </span><span>int</span><span>)</span><span> </span><span>{</span>
<span>        </span><span>defer</span><span> </span><span>wg</span><span>.</span><span>Done</span><span>()</span>
<span>        </span><span>if</span><span> </span><span>id</span><span> </span><span>==</span><span> </span><span>1</span><span> </span><span>{</span>
<span>           </span><span>time</span><span>.</span><span>Sleep</span><span>(</span><span>10</span><span> </span><span>*</span><span> </span><span>time</span><span>.</span><span>Second</span><span>)</span>
<span>        </span><span>}</span>
<span>        </span><span>counter</span><span>++</span>
<span>        </span><span>fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;Counter: %d\n&#34;</span><span>,</span><span> </span><span>counter</span><span>)</span>
<span>}</span>
</pre></div>
<p>This is useful for detecting cases that rely on specific timing. For example, the tool would be much less useful if the race below could only be detected when <code>bar()</code> returns quickly.</p>
<div><pre><span></span><span>func</span><span> </span><span>foo</span><span>(</span><span>wg</span><span> </span><span>*</span><span>sync</span><span>.</span><span>WaitGroup</span><span>,</span><span> </span><span>id</span><span> </span><span>int</span><span>)</span><span> </span><span>{</span>
<span>        </span><span>defer</span><span> </span><span>wg</span><span>.</span><span>Done</span><span>()</span>
<span>        </span><span>if</span><span> </span><span>id</span><span> </span><span>==</span><span> </span><span>1</span><span> </span><span>{</span>
<span>           </span><span>bar</span><span>()</span><span> </span><span>// usually slow, sometimes fast</span>
<span>        </span><span>}</span>
<span>        </span><span>counter</span><span>++</span>
<span>}</span>
</pre></div>
<p>However, in the original mutex case above, the unguarded write is always executed by thread 1, and yet Go is missing the race unless it actually occurs at runtime.</p>
<p>It has been a while, so things may have changed or I may be misremembering, but I believe it is due to how locks are modeled in the data race detector&#39;s analysis.</p>
<p>The data race detector creates a graph of &#34;happens-before&#34; relationships. Operation A &#34;happens-before&#34; operation B if we can guarantee A completes before B starts. The detector uses these relationships to determine if two memory accesses could occur simultaneously. For example,</p>
<ul>
<li>a thread spawn must happen before the thread starts executing</li>
<li>a thread must complete before it is joined</li>
</ul>
<p>Therefore, all instructions before a thread is spawned happen before all instructions run in the thread, which must happen before all instructions that happen after the thread join.</p>
<p>The data race detector checks for a happens before relationship when two threads access the same location in memory. If neither access is reachable from the other, a data race is reported.</p>
<p>This is how Go is able to detect the sleep example. Sleep does not create a happens before edge between threads and so the race is detected regardless of how the threads are actually scheduled.</p>
<p>However, locks don&#39;t fit cleanly into this model. Go forces locks to fit by modeling acquire/release as happens before relationships. If thread 0 acquires a lock first, the unlock call on thread 0 must happen before the lock call on thread 1.</p>
<p>Here&#39;s a rough chart of what the graph looks like.</p>
<div><pre><span></span>Time↓  Thread 0          Thread 1         Main Thread
═════ ═══════════       ═══════════       ═══════════
  │   START &lt;----------------------------- go increment(&amp;wg, 0)
  |                     START &lt;----------- go increment(&amp;wg, 1)         
  │                     mutex.Lock()
  |.                    counter++
  │                     fmt.Printf() 
  │   mutex.Lock() &lt;--- mutex.Unlock() 
  │   counter++         counter++ (RACE)
  │   fmt.Printf()      wg.Done()-----┐     
  │   mutex.Unlock()                  |
  │   wg.Done() ------------------------&gt; wg.Wait()
  │                      

Legend:
B&lt;-A : A must happen before B
C-&gt;D : C must happen before D
</pre></div>
<p>In the racy schedule, thread 1 acquires the lock first, causing a happens before edge from the unlock on thread 1 to the lock thread 0. The guarded write on thread 0 cannot reach the unguarded write on thread 1, and vice versa, and the race is successfully detected.</p>
<p>Now let&#39;s look at the &#34;safe&#34; schedule.</p>
<div><pre><span></span>Time↓  Thread 0          Thread 1         Main Thread
═════ ═══════════       ═══════════       ═══════════
  │   START &lt;----------------------------- go increment(&amp;wg, 0)
  |                     START &lt;----------- go increment(&amp;wg, 1)         
  │   mutex.Lock()      
  │   counter++  
  │   fmt.Printf()      
  │   mutex.Unlock() -&gt; mutex.Lock() 
  |                     counter++
  │                     fmt.Printf()    
  │                     mutex.Unlock() 
  │                     counter++ 
  │                     wg.Done()-----┐ 
  │    wg.Done() ------------------------&gt; wg.Wait()

Legend:
B&lt;-A : A must happen before B
C-&gt;D : C must happen before D
</pre></div>
<p>The two guarded writes are safe because the guarded write on thread 1 is reachable from the guarded write on thread 0 via the happens before relationship between the lock and unlock.</p>
<p>However, this also means the <em>unguarded</em> write on thread 1 is reachable from the guarded write on thread 0. And so, Go does not report a race. While technically correct for this execution, the threads could just as easily have acquired the locks in a different order. The end result is a possible race was missed in executed code.</p>
<p>Even so, Go&#39;s data race detector remains a best-in-industry tool. No other language has better tooling for easily getting useful reports on data races.</p>
<p>Modeling locks as synchronization points causes blind spots, but this was likely a design decision made to ensure high performance and no false positives.</p>
<p>Like any tool, Go&#39;s data race detector works best when you understand its boundaries, and I thought this was a neat non-obvious pattern that it can miss. Just because code is covered and go reports no races, does not necessarily mean the code is race free.</p>



    

    
        

        
            


        
    


  </div></div>
  </body>
</html>
