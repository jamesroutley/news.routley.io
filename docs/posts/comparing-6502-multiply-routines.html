<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/TobyLobster/multiply_test">Original</a>
    <h1>Comparing 6502 Multiply Routines</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<h2 tabindex="-1" dir="auto"><a id="user-content-contents" aria-hidden="true" tabindex="-1" href="#contents"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Contents</h2>
<ul dir="auto">
<li><a href="#introduction">Introduction</a></li>
<li><a href="#the-implementations">The Implementations</a></li>
<li><a href="#the-results">The Results</a></li>
<li><a href="#the-algorithms">The Algorithms</a>
<ul dir="auto">
<li><a href="#1-binary-multiplication-shift-and-add">Binary Multiplication (Shift and Add)</a></li>
<li><a href="#2-modified-shift-and-add">Modified Shift and Add</a></li>
<li><a href="#3-tables-of-squares">Tables of Squares</a></li>
<li><a href="#4-logarithms">Logarithms</a></li>
<li><a href="#5-four-bit-multiply">Four bit multiply</a></li>
<li><a href="#6-booths-algorithm">Booth&#39;s Algorithm</a></li>
<li><a href="#7-hardware-support">Hardware support</a></li>
<li><a href="#8-repeated-addition">Repeated addition</a></li>
</ul>
</li>
<li><a href="#customising">Customising</a></li>
<li><a href="#how-to-run-the-tests">How to run the tests</a></li>
</ul>
<h2 tabindex="-1" dir="auto"><a id="user-content-introduction" aria-hidden="true" tabindex="-1" href="#introduction"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Introduction</h2>
<blockquote>
<p dir="auto">&#34;The search for the ultimate multiply routine seems never-ending.&#34; - Brooke W. Boering (December 1980)</p>
</blockquote>
<p dir="auto">This document compares the runtime performance and memory used by a wide variety of general purpose multiplication routines for the 6502 CPU. Over 120 different routines have been exhaustively tested, cycle counted, and the results plotted.</p>
<p dir="auto">There is no one &#39;best&#39; routine or algorithm, because there are always trade-offs between speed and memory. By <em>speed</em>, I mean the average, best and worst cases of how many cycles are needed to perform the multiplication. By <em>memory</em> I mean the total number of bytes needed for the code itself and all necessary data tables.</p>
<p dir="auto">There may be other gains based on the context in which it is being used, e.g. the memory cost can be shared if data tables can be reused by other routines (for example a square root or division routine). Perhaps the multiplicands are more likely to lie in a given range. So it is not possible to recommend a single routine as &#39;best&#39;. What we can say is that some routines are almost always, or actually always, worse than others. In practice, only a few are worth considering.</p>
<p dir="auto">The most common routines available are for unsigned numbers, either 8 bit x 8 bit with a 16 bit result, or 16 bit x 16 bit with a 32 bit result. These are the natural focus, however several other routines are listed further down. There is also a section later that discusses how to how to customise the routines, e.g. how to handle signed numbers, adjusting to different bit sizes, etc.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-the-implementations" aria-hidden="true" tabindex="-1" href="#the-implementations"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>The Implementations</h2>
<p dir="auto">I have tested the following routines:</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-unsigned-multiply" aria-hidden="true" tabindex="-1" href="#unsigned-multiply"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Unsigned multiply</h3>
<table>
<thead>
<tr>
<th>Source code</th>
<th>Bits</th>
<th>Method</th>
<th>From</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult1.a">mult1.a</a></td>
<td>16x16=32</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://archive.org/details/6502softwaredesi0000scan/page/124/mode/1up" rel="nofollow"><em>6502 Software Design</em></a> by Leo J Scanlon (1980) and <a href="https://www.codebase64.org/doku.php?id=base:16bit_multiplication_32-bit_product" rel="nofollow">codebase64</a> (2015)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult2.a">mult2.a</a></td>
<td>16x16=32</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><em>The Merlin 128 Macro Assembler</em> disk (Commodore 128) by Glen Bredon (1986), via <a href="http://www.ffd2.com/fridge/math/mult-div.s" rel="nofollow">The Fridge</a></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult3.a">mult3.a</a></td>
<td>16x16=32</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://llx.com/Neil/a2/mult.html" rel="nofollow">Neil Parker</a> (2005)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult4.a">mult4.a</a></td>
<td>16x16=32</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td>mult39 combined into a 16 bit multiply by TobyLobster (2022)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult5.a">mult5.a</a></td>
<td>8x8=16</td>
<td><a href="#3-tables-of-squares">tables of squares</a></td>
<td><a href="https://everything2.com/user/yerricde/writeups/Fast+6502+multiplication" rel="nofollow">yerricde at everything2</a> (2001)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult6.a">mult6.a</a></td>
<td>8x8=16</td>
<td><a href="#3-tables-of-squares">tables of squares</a></td>
<td><a href="https://everything2.com/user/eurorusty/writeups/Fast+6502+multiplication" rel="nofollow">eurorusty at everything2</a> (2013)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult7.a">mult7.a</a></td>
<td>8x8=16</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="http://www.txbobsc.com/aal/1986/aal8601.html#a5" rel="nofollow"><em>Apple Assembly Line</em>, January 1986</a></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult8.a">mult8.a</a></td>
<td>8x8=16</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="http://www.txbobsc.com/aal/1986/aal8601.html#a5" rel="nofollow"><em>Apple Assembly Line</em>, January 1986</a></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult9.a">mult9.a</a></td>
<td>8x8=16</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="http://www.ffd2.com/fridge/math/mult-div8.s" rel="nofollow">The Fridge</a> (2000)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult10.a">mult10.a</a></td>
<td>8x8=16</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://www.codebase64.org/doku.php?id=base:8bit_multiplication_16bit_product" rel="nofollow">White Flame at codebase64</a> (2015)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult11.a">mult11.a</a></td>
<td>8x8=16</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://www.codebase64.org/doku.php?id=base:short_8bit_multiplication_16bit_product" rel="nofollow">graham at codebase64</a> (2015)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult12.a">mult12.a</a></td>
<td>8x8=16</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://www.codebase64.org/doku.php?id=base:8bit_multiplication_16bit_product_fast_no_tables" rel="nofollow">djmips at codebase64</a> (2020)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult13.a">mult13.a</a></td>
<td>8x8=16</td>
<td><a href="#3-tables-of-squares">tables of squares</a></td>
<td><a href="http://www.txbobsc.com/aal/1986/aal8603.html#a5" rel="nofollow"><em>Apple Assembly Line</em>, March 1986</a></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult14.a">mult14.a</a></td>
<td>8x8=16</td>
<td><a href="#3-tables-of-squares">tables of squares</a></td>
<td><a href="https://codebase64.org/doku.php?id=base:seriously_fast_multiplication" rel="nofollow">Jackasser at codebase64</a> (2015)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult15.a">mult15.a</a></td>
<td>16x16=32</td>
<td><a href="#3-tables-of-squares">tables of squares</a></td>
<td><a href="https://www.codebase64.org/doku.php?id=base:fastest_multiplication" rel="nofollow">Repose at codebase64</a> (2017)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult16.a">mult16.a</a></td>
<td>8x8=16</td>
<td><a href="#3-tables-of-squares">tables of squares</a></td>
<td><a href="https://www.codebase64.org/doku.php?id=base:another_fast_8bit_multiplication" rel="nofollow">litwr (Vladimir Lidovski) and Urusergi codebase64</a> (2015)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult17.a">mult17.a</a></td>
<td>8x8=16</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://www.bbcelite.com/cassette/main/subroutine/mu11.html" rel="nofollow"><em>Elite</em> (BBC Micro)</a> (1984)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult18.a">mult18.a</a></td>
<td>8x8=16</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://www.bbcelite.com/master/main/subroutine/mu11.html" rel="nofollow"><em>Elite</em> (BBC Master version)</a> (1986)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult19.a">mult19.a</a></td>
<td>8x8=16</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://archive.org/details/apc_1984_08/page/115/mode/2up?q=6502+multiplication" rel="nofollow">Australian Personal Computer, Aug 1984</a> and <a href="https://www.llx.com/Neil/a2/mult.html" rel="nofollow">Neil Parker</a> (2005)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult20.a">mult20.a</a></td>
<td>8x8=16</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://becomingjulie.blogspot.com/2020/07/multiplying-on-6502-but-faster.html" rel="nofollow">Becoming Julie</a> (2020)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult21.a">mult21.a</a></td>
<td>8x8=16</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://archive.org/details/shiva-machine-code-for-the-atmos-and-oric-i/page/78/mode/2up" rel="nofollow"><em>Machine Code for the Atmos and Oric-I</em></a> by Bruce Smith (1984) and <a href="https://www.lysator.liu.se/~nisse/misc/6502-mul.html" rel="nofollow">Niels Möller</a> (2015)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult22.a">mult22.a</a></td>
<td>8x8=16</td>
<td><a href="#3-tables-of-squares">tables of squares</a></td>
<td><a href="https://www.lysator.liu.se/~nisse/misc/6502-mul.html" rel="nofollow">Niels Möller</a> (2015)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult23.a">mult23.a</a></td>
<td>8x8=16</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://www.nesdev.org/wiki/8-bit_Multiply" rel="nofollow">tepples at NesDev</a> (2017)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult24.a">mult24.a</a></td>
<td>8x8=16</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://www.nesdev.org/wiki/8-bit_Multiply" rel="nofollow">tepples unrolled at NesDev</a> (2017)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult25.a">mult25.a</a></td>
<td>8x8=16</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://www.nesdev.org/wiki/8-bit_Multiply" rel="nofollow">Bregalad at NesDev</a> (2009)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult26.a">mult26.a</a></td>
<td>8x8=16</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://www.nesdev.org/wiki/8-bit_Multiply" rel="nofollow">frantik at NesDev</a> (2017)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult27.a">mult27.a</a></td>
<td>8x8=16</td>
<td><a href="#3-tables-of-squares">tables of squares</a></td>
<td><a href="https://sites.google.com/site/h2obsession/programming/6502" rel="nofollow">H2Obsession</a> (2013)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult28.a">mult28.a</a></td>
<td>8x8=16</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="http://www.txbobsc.com/aal/1986/aal8601.html#a5" rel="nofollow"><em>Apple Assembly Line</em>, January 1986</a></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult29.a">mult29.a</a></td>
<td>8x8=16</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="http://www.txbobsc.com/aal/1986/aal8601.html#a5" rel="nofollow"><em>Apple Assembly Line</em>, January 1986</a> (unrolled)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult30.a">mult30.a</a></td>
<td>8x8=16</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://www.nesdev.org/wiki/8-bit_Multiply" rel="nofollow">tepples unrolled at NesDev</a> (2017) (adjusted)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult31.a">mult31.a</a></td>
<td>16x16=32</td>
<td><a href="#3-tables-of-squares">tables of squares</a></td>
<td><a href="https://codebase64.org/doku.php?id=base:seriously_fast_multiplication" rel="nofollow">Jackasser at codebase64</a> (2015)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult32.a">mult32.a</a></td>
<td>8x8=16</td>
<td><a href="#5-four-bit-multiply">4 bit multiply</a></td>
<td><a href="https://everything2.com/user/keldon/writeups/Fast+6502+multiplication" rel="nofollow">keldon at everything2</a> (2017)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult33.a">mult33.a</a></td>
<td>16x16=32</td>
<td><a href="#3-tables-of-squares">tables of squares</a></td>
<td><a href="https://retro64.altervista.org/ProgrammingExamples/AssemblyLanguage/fast_mult_16bit_v05_pres.txt" rel="nofollow">Retro64</a> (2019)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult34.a">mult34.a</a></td>
<td>8x8=16</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://archive.org/details/ataribooks-atari-roots/page/n169/mode/2up" rel="nofollow"><em>Atari Roots</em></a> by Mark Andrews (1984)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult35.a">mult35.a</a></td>
<td>8x8=16</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://archive.org/details/ataribooks-atari-roots/page/n173/mode/2up" rel="nofollow"><em>Atari Roots</em></a> by Mark Andrews (1984)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult36.a">mult36.a</a></td>
<td>16x16=32</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://archive.org/details/assembler-routines-for-the-6502/page/162/mode/2up" rel="nofollow"><em>Best of Personal Computer World, ASSEMBLER ROUTINES FOR THE 6502</em></a> by David Barrow (1985)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult37.a">mult37.a</a></td>
<td>8x8=16</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://codeburst.io/lets-write-some-harder-assembly-language-code-c7860dcceba" rel="nofollow">Andrew Blance, at codeburst</a> (2020)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult38.a">mult38.a</a></td>
<td>8x8=16</td>
<td><a href="#5-four-bit-multiply">4 bit multiply</a></td>
<td><a href="https://aviator.bbcelite.com/source/main/subroutine/multiply8x8.html" rel="nofollow"><em>Aviator</em> (BBC Micro)</a> (1983)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult39.a">mult39.a</a></td>
<td>8x8=16</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://revs.bbcelite.com/source/main/subroutine/multiply8x8.html" rel="nofollow"><em>Revs</em> (BBC Micro)</a> (1985)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult40.a">mult40.a</a></td>
<td>8x8=16</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://gitlab.riscosopen.org/RiscOS/Sources/Apps/Diversions/Meteors/-/blob/master/Srce6502/MetSrc" rel="nofollow"><em>Meteors</em> (BBC Micro)</a> (1982)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult41.a">mult41.a</a></td>
<td>16x16=32</td>
<td><a href="#3-tables-of-squares">tables of squares</a></td>
<td>mult13 combined into a 16 bit multiply by TobyLobster (2022)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult42.a">mult42.a</a></td>
<td>16x16=32</td>
<td><a href="#3-tables-of-squares">tables of squares</a></td>
<td>mult16 combined into a 16 bit multiply by TobyLobster (2022)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult43.a">mult43.a</a></td>
<td>8x8=16</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://archive.org/details/6502-assembly-language-programming/page/n251/mode/2up" rel="nofollow"><em>6502 assembly language programming</em></a> by Lance A. Leventhal</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult44.a">mult44.a</a></td>
<td>8x8=16</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="http://level7.org.uk/miscellany/the-sentinel-disassembly.txt" rel="nofollow"><em>The Sentinel</em> (BBC Micro)</a> (1988)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult45.a">mult45.a</a></td>
<td>16x16=32</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://archive.org/details/Using_6502_Assembly_Language/page/n197/mode/2up" rel="nofollow"><em>How to program the Apple II Using 6502 Assembly Language</em></a> by Randy Hyde (1981)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult46.a">mult46.a</a></td>
<td>16x16=32</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://archive.org/details/sams-apple-programmers-handbook/page/220/mode/2up?q=multiply" rel="nofollow"><em>Apple Programmers Handbook</em></a> by Paul Irwin (1984)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult47.a">mult47.a</a></td>
<td>8x8=16</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://llx.com/Neil/a2/mult.html" rel="nofollow"><em>Neil Parker</em></a> (2005)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult48.a">mult48.a</a></td>
<td>16x16=32</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://archive.org/details/micro-6502-journal-31/page/n73/mode/2up" rel="nofollow">Micro 6502 Journal Issue 31, Dec 1980, p71-74</a> by Brooke Boering</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult49.a">mult49.a</a></td>
<td>16x16=32</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://archive.org/details/micro-6502-journal-31/page/n73/mode/2up" rel="nofollow">Micro 6502 Journal Issue 31, Dec 1980, p71-74</a> by Brooke Boering, with 8x16 multiply &#39;shortcut&#39; removed</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult50.a">mult50.a</a></td>
<td>16x16=32</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td>mult2 unrolled by TobyLobster (2023)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult51.a">mult51.a</a></td>
<td>16x16=32</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td>mult2 unrolled by TobyLobster (2023)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult52.a">mult52.a</a></td>
<td>16x16=32</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td>mult2 unrolled by TobyLobster (2023)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult53.a">mult53.a</a></td>
<td>16x16=32</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td>mult2 unrolled by TobyLobster (2023)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult54.a">mult54.a</a></td>
<td>16x16=32</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td>mult2 unrolled by TobyLobster (2023)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult55.a">mult55.a</a></td>
<td>16x16=32</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td>mult2 fully unrolled by TobyLobster (2023)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult56.a">mult56.a</a></td>
<td>16x16=32</td>
<td><a href="#3-tables-of-squares">tables of squares</a></td>
<td>mult27 combined into a 16 bit multiply by TobyLobster (2023)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult57.a">mult57.a</a></td>
<td>8x8=16</td>
<td><a href="#3-tables-of-squares">tables of squares</a></td>
<td><a href="https://sites.google.com/site/h2obsession/programming/6502" rel="nofollow">H2Obsession</a> smaller memory version without idTab (2013)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult58.a">mult58.a</a></td>
<td>16x16=32</td>
<td><a href="#3-tables-of-squares">tables of squares</a></td>
<td>mult16 combined into a 16 bit multiply by TobyLobster (2023)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult59.a">mult59.a</a></td>
<td>16x16=32</td>
<td><a href="#2-modified-shift-and-add">modified shift and add</a></td>
<td><a href="http://forum.6502.org/viewtopic.php?f=9&amp;t=689&amp;start=0#p19958" rel="nofollow">Dr Jefyll</a> (2012)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult60.a">mult60.a</a></td>
<td>16x16=32</td>
<td><a href="#2-modified-shift-and-add">modified shift and add</a></td>
<td><a href="http://forum.6502.org/viewtopic.php?f=9&amp;t=689&amp;start=0#p19958" rel="nofollow">Dr Jefyll</a> (2012) with modifications by TobyLobster (2023)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult61.a">mult61.a</a></td>
<td>16x16=32</td>
<td><a href="#2-modified-shift-and-add">modified shift and add</a></td>
<td><a href="http://forum.6502.org/viewtopic.php?f=9&amp;t=689&amp;start=0#p19958" rel="nofollow">Dr Jefyll</a> (2012) with modifications and unrolling by TobyLobster (2023)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult62.a">mult62.a</a></td>
<td>16x16=32</td>
<td><a href="#2-modified-shift-and-add">modified shift and add</a></td>
<td><a href="http://forum.6502.org/viewtopic.php?f=9&amp;t=689&amp;start=0#p19958" rel="nofollow">Dr Jefyll</a> (2012) with modifications and unrolling by TobyLobster (2023)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult63.a">mult63.a</a></td>
<td>16x16=32</td>
<td><a href="#2-modified-shift-and-add">modified shift and add</a></td>
<td><a href="http://forum.6502.org/viewtopic.php?f=9&amp;t=689&amp;start=0#p19958" rel="nofollow">Dr Jefyll</a> (2012) with modifications and unrolling by TobyLobster (2023)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult64.a">mult64.a</a></td>
<td>16x16=32</td>
<td><a href="#2-modified-shift-and-add">modified shift and add</a></td>
<td><a href="http://forum.6502.org/viewtopic.php?f=9&amp;t=689&amp;start=0#p19958" rel="nofollow">Dr Jefyll</a> (2012) with modifications and unrolling by TobyLobster (2023)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult65.a">mult65.a</a></td>
<td>8x8=16</td>
<td><a href="#3-tables-of-squares">tables of squares</a></td>
<td><a href="https://github.com/simondotm/bbc-micro-3d/tree/master/source">Nick Jameson&#39;s 3D Demo</a> for the BBC Micro (1994)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult66.a">mult66.a</a></td>
<td>8x8=16</td>
<td><a href="#3-tables-of-squares">tables of squares</a></td>
<td>TobyLobster (2023), based on <a href="https://github.com/simondotm/bbc-micro-3d/tree/master/source">Nick Jameson&#39;s 3D Demo</a> for the BBC Micro (1994)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult67.a">mult67.a</a></td>
<td>16x16=32</td>
<td><a href="#3-tables-of-squares">tables of squares</a></td>
<td><a href="https://stardot.org.uk/forums/viewtopic.php?p=380587#p380587" rel="nofollow">julie_m at stardot</a> (Note: preserves carry) (2023)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult68.a">mult68.a</a></td>
<td>8x8=16</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://archive.org/details/Programming_the_6502_OCR/page/n89/mode/2up" rel="nofollow"><em>Programming The 6502</em></a> by Rodnay Zaks (1983)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult69.a">mult69.a</a></td>
<td>16x16=32</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://archive.org/details/Compute_s_Machine_Language_Routines_for_the_Commodore_64_and_128/page/363/mode/2up*" rel="nofollow"><em>Machine Language Routines for the Commodore 64 and 128</em></a> by Todd D Heimarck and Patrick Parrish (1987)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult70.a">mult70.a</a></td>
<td>8x8=16</td>
<td><a href="#8-repeated-addition">repeated addition</a></td>
<td><a href="https://archive.org/details/Compute_s_Machine_Language_Routines_for_the_Commodore_64_and_128/page/357/mode/2up*" rel="nofollow"><em>Machine Language Routines for the Commodore 64 and 128</em></a> by Todd D Heimarck and Patrick Parrish (1987)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult70.a">mult71.a</a></td>
<td>8x8=16</td>
<td><a href="#8-repeated-addition">repeated addition</a></td>
<td><a href="https://archive.org/details/Compute_s_Machine_Language_Routines_for_the_Commodore_64_and_128/page/359/mode/2up*" rel="nofollow"><em>Machine Language Routines for the Commodore 64 and 128</em></a> by Todd D Heimarck and Patrick Parrish (1987)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult72.a">mult72.a</a></td>
<td>8x8=16</td>
<td><a href="#8-repeated-addition">repeated addition</a></td>
<td>TobyLobster (2023)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult73.a">mult73.a</a></td>
<td>8x8=16</td>
<td><a href="#8-repeated-addition">repeated addition</a></td>
<td>TobyLobster (2023)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult74.a">mult74.a</a></td>
<td>16x16=32</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><em>Mikroprozessoren 6502, 6800, 8080, Z80, 9900</em> by Harald Schumny (1983)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult75.a">mult75.a</a></td>
<td>8x8=16</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><em>Practical Microcomputer Programming</em> by Walter J Weller (1980)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult76.a">mult76.a</a></td>
<td>8x8=16</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://archive.org/details/kilobaudmagazine-1981-06/page/n109/mode/2up" rel="nofollow"><em>Microcomputing</em> magazine (June 1981)</a> article by Leo Scanlon</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult77.a">mult77.a</a></td>
<td>8x8=16</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://archive.org/details/instrumentationo00babb/page/108/mode/2up" rel="nofollow"><em>Instrumentation of a Savonius Wind Turbine</em></a> by Samuel Martin Babb (1979)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult78.a">mult78.a</a></td>
<td>8x8=16</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://archive.org/details/Commodore_128_Assembly_Language_Programming/page/n165/mode/2up" rel="nofollow"><em>Commodore 128 Assembly Language Programming</em></a> by Mark Andrews (1986)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult78.a">mult79.a</a></td>
<td>8x8=16</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://archive.org/details/NASA_NTRS_Archive_19820015020/page/n65/mode/2up" rel="nofollow"><em>NASA Report</em></a> (1981)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult80.a">mult80.a</a></td>
<td>8x8=16</td>
<td><a href="#5-four-bit-multiply">4 bit multiply</a></td>
<td><a href="http://sleepingelephant.com/ipw-web/bulletin/bb/viewtopic.php?p=82071#p82071" rel="nofollow">Kakemoms at <em>Denial, the Commodore Vic 20 Forum</em></a> (2015)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult81.a">mult81.a</a></td>
<td>8x8=16</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="http://www.computinghistory.org.uk/det/18670/Graphics%20Extension%20ROM%20for%20the%20BBC%20Microcomputer/" rel="nofollow"><em>Graphics Extension ROM</em></a> by Acornsoft (1985) at $b8d4</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult82.a">mult82.a</a></td>
<td>8x8=16</td>
<td><a href="#3-tables-of-squares">tables of squares</a></td>
<td><a href="http://www.retrosoftware.co.uk/wiki/index.php?title=Fast_multiplication_routines" rel="nofollow"><em>Retro Software</em></a> (2008)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult83.a">mult83.a</a></td>
<td>8x8=16</td>
<td><a href="#3-tables-of-squares">tables of squares</a></td>
<td><a href="http://www.retrosoftware.co.uk/wiki/index.php?title=Fast_multiplication_routines" rel="nofollow"><em>Retro Software</em></a> (2008)</td>
</tr>
</tbody>
</table>
<h3 tabindex="-1" dir="auto"><a id="user-content-signed-multiply" aria-hidden="true" tabindex="-1" href="#signed-multiply"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Signed multiply</h3>
<table>
<thead>
<tr>
<th>Source code</th>
<th>Bits</th>
<th>Method</th>
<th>From</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/smult1.a">smult1.a</a></td>
<td>8x8=16   (<em>signed</em>)</td>
<td><a href="#3-tables-of-squares">tables of squares</a></td>
<td><a href="https://codebase64.org/doku.php?id=base:seriously_fast_multiplication" rel="nofollow">Jackasser at codebase64</a> (2015)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/smult2.a">smult2.a</a></td>
<td>8x8=16   (<em>signed</em>)</td>
<td><a href="#6-booths-algorithm">Booth&#39;s algorithm</a></td>
<td><a href="https://markusthill.github.io/programming/an-efficient-implementation-of-the-booth-algorithm-in-6502-assembler/" rel="nofollow">Marcus Thill</a> (2017)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/smult3.a">smult3.a</a></td>
<td>16x16=32 (<em>signed</em>)</td>
<td><a href="#3-tables-of-squares">tables of squares</a></td>
<td><a href="https://codebase64.org/doku.php?id=base:seriously_fast_multiplication" rel="nofollow">Jackasser at codebase64</a> (2015)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/smult4.a">smult4.a</a></td>
<td>8x8=16   (<em>signed</em>)</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://llx.com/Neil/a2/mult.html" rel="nofollow">Neil Parker</a> (2005)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/smult5.a">smult5.a</a></td>
<td>8x8=16   (<em>signed</em>)</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td>mult9 converted to signed multiply by TobyLobster (2022)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/smult6.a">smult6.a</a></td>
<td>8x8=16   (<em>signed</em>)</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://archive.org/details/edn-1979_09_05/page/118/mode/2up" rel="nofollow"><em>EDN</em> magazine (5th Sept 1979)</a>, article by Arch D Robison</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/smult7.a">smult7.a</a></td>
<td>8x8=16   (<em>signed</em>)</td>
<td><a href="#3-tables-of-squares">tables of squares</a></td>
<td><a href="https://www.codebase64.org/doku.php?id=base:fast_8bit_multiplication_16bit_product" rel="nofollow">Oswald/Resource at codebase64</a> (2015)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/smult8.a">smult8.a</a></td>
<td>8x8=16   (<em>signed</em>)</td>
<td><a href="#3-tables-of-squares">tables of squares</a></td>
<td>mult65 converted to signed multiply by TobyLobster (2022)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/smult9.a">smult9.a</a></td>
<td>16x16=32 (<em>signed</em>)</td>
<td><a href="#2-modified-shift-and-add">modified shift and add</a></td>
<td><a href="http://forum.6502.org/viewtopic.php?f=9&amp;t=689&amp;start=0#p19958" rel="nofollow">Dr Jefyll</a> (2012) with modifications by TobyLobster (2023)</td>
</tr>
</tbody>
</table>
<h3 tabindex="-1" dir="auto"><a id="user-content-miscellaneous-multiply" aria-hidden="true" tabindex="-1" href="#miscellaneous-multiply"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Miscellaneous multiply</h3>
<p dir="auto">Specialised multiply routines often find their niche in games. Partial results (a result with fewer bits than expected) are common for fixed point arithmetic. Even approximate results can be used in cases where speed is more important than absolute accuracy.</p>
<table>
<thead>
<tr>
<th>Source code</th>
<th>Bits</th>
<th>Method</th>
<th>From</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult1.a">omult1.a</a></td>
<td>16x16=16 (<em>partial result,low 16 bits only</em>)</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://archive.org/details/0893037893ProgrammingThe65816/page/n295/mode/2up?q=multiply" rel="nofollow"><em>Programming the 65816</em></a> by David Eyes (1986)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult2.a">omult2.a</a></td>
<td>8x8=8    (<em>partial result, low byte only</em>)</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://archive.org/details/BBCMicroCompendium/page/38/mode/2up" rel="nofollow"><em>The BBC Micro Compendium</em></a> by Jeremy Ruston (1983), also <a href="http://level7.org.uk/miscellany/nightshade-disassembly.txt" rel="nofollow"><em>Nightshade</em></a> (1985) at $6121</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult3.a">omult3.a</a></td>
<td>8x8=8    (<em>partial result, high byte only</em>)</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://www.bbcelite.com/cassette/main/subroutine/fmltu.html" rel="nofollow"><em>Elite</em> for the BBC Micro</a> (1984)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult4.a">omult4.a</a></td>
<td>24x8=32  (<em>sign-magnitude</em> numbers)</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://www.bbcelite.com/cassette/main/subroutine/mult3.html" rel="nofollow"><em>Elite</em> for the BBC Micro</a> (1984)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult5.a">omult5.a</a></td>
<td>16x16=16 (approximate 2 high bytes only)</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="http://level7.org.uk/miscellany/the-sentinel-disassembly.txt" rel="nofollow"><em>The Sentinel</em> for the BBC Micro</a> (1988)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult6.a">omult6.a</a></td>
<td>16x16=16 (<em>low 16 bit result</em>, or carry set if overflow occurs)</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://github.com/mist64/c64ref/blob/master/Source/c64disasm/c64disasm_en.txt">The Commodore 64 BASIC/KERNAL ROM</a> at $b357 and <a href="https://6502disassembly.com/a2-rom/Applesoft.html" rel="nofollow">Applesoft II BASIC</a> at $e2b8</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult7.a">omult7.a</a></td>
<td>8x8=8    (<em>partial result, approx high byte</em>)</td>
<td><a href="#4-logarithms">log and exp tables</a></td>
<td><a href="https://www.bbcelite.com/master/main/subroutine/fmltu.html" rel="nofollow"><em>Elite</em>, BBC Master version</a> (1986) and <a href="https://6502disassembly.com/a2-elite/Elite.html#SymFMLTU" rel="nofollow">APPLE II <em>Elite</em></a> (1985)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult8.a">omult8.a</a></td>
<td>8x8=8    (<em>partial result, approx high byte</em>)</td>
<td><a href="#4-logarithms">log and exp tables</a></td>
<td><a href="https://www.bbcelite.com/6502sp/main/subroutine/fmltu.html" rel="nofollow"><em>Elite</em>, Second Processor version</a> (1985)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult9.a">omult9.a</a></td>
<td>8x8=8    (<em>partial result, approx high byte</em>)</td>
<td><a href="#4-logarithms">log and exp tables</a></td>
<td>from articles by Gunnar &#39;Krill&#39; Ruthenburg / Plush in the German <em>GO64!</em> magazine (2000), via <a href="https://codebase64.org/doku.php?id=base:mathematics_in_assembly_part_6" rel="nofollow">codebase64</a></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult10.a">omult10.a</a></td>
<td>16x32=32 (<em>partial result,low 32 bits only</em>)</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://archive.org/details/BBCMicroCompendium/page/364/mode/2up" rel="nofollow">BBC BASIC ROM</a> integer multiply code (1981)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult11.a">omult11.a</a></td>
<td>8x8=8    (<em>partial result, high byte only</em>)</td>
<td><a href="#3-tables-of-squares">tables of squares</a></td>
<td>mult13 reduced to return high byte only by TobyLobster (2023)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult12.a">omult12.a</a></td>
<td>8x8=8    (<em>partial result, low byte only</em>)</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="http://bringerp.free.fr/RE/Gta/downloads.php5" rel="nofollow"><em>Gateway to Apshai</em>, for the Atari 8-bit family</a> (1983)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult13.a">omult13.a</a></td>
<td>16x8=16  (<em>partial result</em>, div 128)</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://6502disassembly.com/a2-stellar7/ROCK1.html" rel="nofollow"><em>Stellar 7</em>, for the Apple II</a> (1983)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult14.a">omult14.a</a></td>
<td>16x16=16 (<em>partial result,low 16 bits only</em>)</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://github.com/dmsc/fastbasic/blob/master/src/interp/mul.asm">FastBasic</a> BASIC interpreter for the Atari 8-bit computers (2017)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult15.a">omult15.a</a></td>
<td>16x16=16 (<em>partial result,low 16 bits only</em>)</td>
<td><a href="#2-modified-shift-and-add">modified shift and add</a></td>
<td><a href="http://forum.6502.org/viewtopic.php?f=9&amp;t=689&amp;start=0#p19958" rel="nofollow">Dr Jefyll</a> (2012) with modifications by TobyLobster (2023)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult16.a">omult16.a</a></td>
<td>16x16=16 (<em>partial result,low 16 bits only</em>)</td>
<td><a href="#3-tables-of-squares">tables of squares</a></td>
<td><a href="https://archive.org/details/BBCMicroCompendium/page/302/mode/1up?q=9236" rel="nofollow">BBC BASIC ROM</a> multidimensional array access code (1981)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult17.a">omult17.a</a></td>
<td>16x8=16  (<em>partial result,low 16 bits only</em>)</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://archive.org/details/howtoprogrammicr00bard/page/192/mode/2up" rel="nofollow"><em>How to program microcomputers</em></a> by William T Barden (1977)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult18.a">omult18.a</a></td>
<td>mxn=n+m (<em>variable size multiply</em>)</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://archive.org/details/kilobaudmagazine-1981-06/page/n113/mode/2up" rel="nofollow"><em>Microcomputing</em> magazine (June 1981)</a> article by Leo J Scanlon</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult19.a">omult19.a</a></td>
<td>24x24=48</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="http://www.computinghistory.org.uk/det/18670/Graphics%20Extension%20ROM%20for%20the%20BBC%20Microcomputer/" rel="nofollow"><em>Graphics Extension ROM</em></a> by Acornsoft (1985) at $beb5</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult20.a">omult20.a</a></td>
<td>32x32=64</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="http://6502.org/source/integers/32muldiv.htm" rel="nofollow">6502.org</a> based on <a href="https://archive.org/details/6502softwaredesi0000scan/page/124/mode/1up" rel="nofollow"><em>6502 Software Design</em></a> by Leo J Scanlon (1980), expanded by Greg (1999)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult21.a">omult21.a</a></td>
<td>24x24=48</td>
<td><a href="#2-modified-shift-and-add">modified shift and add</a></td>
<td><a href="http://forum.6502.org/viewtopic.php?f=9&amp;t=689&amp;start=0#p19958" rel="nofollow">Dr Jefyll</a> (2012) with modifications and expanded to 24 bit by TobyLobster (2023)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult22.a">omult22.a</a></td>
<td>32x32=64</td>
<td><a href="#2-modified-shift-and-add">modified shift and add</a></td>
<td><a href="http://forum.6502.org/viewtopic.php?f=9&amp;t=689&amp;start=0#p19958" rel="nofollow">Dr Jefyll</a> (2012) with modifications and expanded to 32 bit by TobyLobster (2023)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult23.a">omult23.a</a></td>
<td>mxn=n+m (<em>variable size multiply</em>)</td>
<td><a href="#2-modified-shift-and-add">modified shift and add</a></td>
<td><a href="http://forum.6502.org/viewtopic.php?f=9&amp;t=689&amp;start=0#p19958" rel="nofollow">Dr Jefyll</a> (2012) with modifications and generalised to mxn by TobyLobster (2023)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult24.a">omult24.a</a></td>
<td>24x24=24</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://www.codebase64.org/doku.php?id=base:24bit_multiplication_24bit_product" rel="nofollow">Neils at codebase64</a> (2018)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult25.a">omult25.a</a></td>
<td>3x8=8 (<em>partial result, high 8 bits only</em>)</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="http://www.level7.org.uk/miscellany/starship-command-disassembly.txt" rel="nofollow"><em>Starship Command</em></a> at $1e69 (1983)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult26.a">omult26.a</a></td>
<td>8x8=8 (<em>partial result, high 8 bits only</em>)</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="http://www.level7.org.uk/miscellany/starship-command-disassembly.txt" rel="nofollow"><em>Starship Command</em></a> at $0fc3 (1983)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult27.a">omult27.a</a></td>
<td>16x8=16 (<em>partial result, high 16 bits only</em>)</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="http://www.level7.org.uk/miscellany/starship-command-disassembly.txt" rel="nofollow"><em>Starship Command</em></a> at $0fa8 and $10be (1983)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult28.a">omult28.a</a></td>
<td>24x8=24 (<em>partial result, high 24 bits only</em>)</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="http://www.level7.org.uk/miscellany/starship-command-disassembly.txt" rel="nofollow"><em>Starship Command</em></a> at $1095 (1983)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult29.a">omult29.a</a></td>
<td>16x8=16 (<em>partial result, low 16 bits only</em>)</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td><a href="https://site.acornatom.nl/boeken/splitting-the-atom.pdf" rel="nofollow"><em>Splitting the Atom (The Acorn Recommended Advanced User Guide)</em></a> by J.R. Stevenson and John C. Rockett (early 1980s)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult30.a">omult30.a</a></td>
<td>24x8=24 (<em>partial result, high 24 bits only</em>)</td>
<td><a href="#1-binary-multiplication-shift-and-add">shift and add</a></td>
<td>TobyLobster (2023)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult31.a">omult31.a</a></td>
<td>24x8=24 (<em>partial result, high 24 bits only</em>)</td>
<td><a href="#3-tables-of-squares">tables of squares</a></td>
<td>TobyLobster (2023)</td>
</tr>
</tbody>
</table>
<h2 tabindex="-1" dir="auto"><a id="user-content-the-results" aria-hidden="true" tabindex="-1" href="#the-results"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>The Results</h2>
<h3 tabindex="-1" dir="auto"><a id="user-content-8-bit-x-8-bit-unsigned-multiply-with-16-bit-result" aria-hidden="true" tabindex="-1" href="#8-bit-x-8-bit-unsigned-multiply-with-16-bit-result"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>8 bit x 8 bit unsigned multiply, with 16 bit result</h3>
<p dir="auto">In the diagrams below, grey dots are the also-rans. They are are beaten for both cycles and memory by the better orange dots.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/TobyLobster/multiply_test/blob/main/results/6502_8x8=16.svg"><img src="https://github.com/TobyLobster/multiply_test/raw/main/results/6502_8x8=16.svg" alt="Results of 8 x 8 bit unsigned multiply"/></a></p>
<p dir="auto">Take note that the fastest routines vary largely in size, but with very little difference in cycle counts.</p>
<p dir="auto">There&#39;s one trick however: if you are multiplying lots of numbers by the same multiplier then these routines can be optimised further. e.g. The largest (mult14) takes 45.99 cycles on average normally but takes just 27.99 cycles if the multiplier (in A) doesn&#39;t change between calls. This is because the first instructions of the routine are setup code based on the multiplier that takes 18 cycles. This only needs to be done once, leaving a faster multiply. This same trick can also be done for a smaller benefit (6 cycles) to mult66, mult27 and mult57.</p>
<p dir="auto">To see the results of the smaller routines more clearly, here is a zoomed in view of the same results:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/TobyLobster/multiply_test/blob/main/results/6502_8x8=16_detail.svg"><img src="https://github.com/TobyLobster/multiply_test/raw/main/results/6502_8x8=16_detail.svg" alt="Results of 8 x 8 bit unsigned multiply (detail)"/></a></p>
<p dir="auto">All cycle counts and byte counts include the final RTS (1 byte, 6 cycles), but do not include any initial JSR mult (3 bytes, 6 cycles).</p>
<table>
<thead>
<tr>
<th>Source code</th>
<th>Average Cycles</th>
<th>Memory (bytes)</th>
<th>My Changes</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult5.a">mult5.a</a></td>
<td>92.01</td>
<td>834</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult6.a">mult6.a</a></td>
<td>137.21</td>
<td>620</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult7.a">mult7.a</a></td>
<td>133.53</td>
<td>36</td>
<td>with slight change to swap output parameters</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult8.a">mult8.a</a></td>
<td>153.45</td>
<td>29</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult9.a">mult9.a</a></td>
<td>162.00</td>
<td>17</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult10.a">mult10.a</a></td>
<td>221.08</td>
<td>27</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult11.a">mult11.a</a></td>
<td>162.00</td>
<td>17</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult12.a">mult12.a</a></td>
<td>108.64</td>
<td>71</td>
<td>slightly tweaked</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult13.a">mult13.a</a></td>
<td>54.00</td>
<td>1075</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult14.a">mult14.a</a></td>
<td>45.99</td>
<td>2077</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult16.a">mult16.a</a></td>
<td>67.48</td>
<td>574</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult17.a">mult17.a</a></td>
<td>150.47</td>
<td>28</td>
<td>tweaked to handle X=0 on input</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult18.a">mult18.a</a></td>
<td>111.62</td>
<td>73</td>
<td>tweaked to handle X=0 on input  and unrolled</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult19.a">mult19.a</a></td>
<td>185.00</td>
<td>18</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult20.a">mult20.a</a></td>
<td>244.00</td>
<td>27</td>
<td><em>bug fixed</em></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult21.a">mult21.a</a></td>
<td>150.00</td>
<td>18</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult22.a">mult22.a</a></td>
<td>77.49</td>
<td>563</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult23.a">mult23.a</a></td>
<td>153.00</td>
<td>21</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult24.a">mult24.a</a></td>
<td>110.63</td>
<td>70</td>
<td>slightly tweaked</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult25.a">mult25.a</a></td>
<td>243.00</td>
<td>28</td>
<td><em>bug fixed</em>, tweaked parameter passing</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult26.a">mult26.a</a></td>
<td>278.14</td>
<td>47</td>
<td><em>bug fixed</em></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult27.a">mult27.a</a></td>
<td>51.49</td>
<td>1316</td>
<td>slightly tweaked</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult28.a">mult28.a</a></td>
<td>130.00</td>
<td>27</td>
<td>tweaked</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult29.a">mult29.a</a></td>
<td>120.00</td>
<td>43</td>
<td>tweaked</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult30.a">mult30.a</a></td>
<td>114.00</td>
<td>74</td>
<td>tweaked</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult32.a">mult32.a</a></td>
<td>117.14</td>
<td>592</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult34.a">mult34.a</a></td>
<td>280.00</td>
<td>36</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult35.a">mult35.a</a></td>
<td>188.00</td>
<td>20</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult37.a">mult37.a</a></td>
<td>278.00</td>
<td>35</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult38.a">mult38.a</a></td>
<td>97.00</td>
<td>1345</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult39.a">mult39.a</a></td>
<td>107.00</td>
<td>69</td>
<td>tweaked slightly</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult40.a">mult40.a</a></td>
<td>278.00</td>
<td>35</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult43.a">mult43.a</a></td>
<td>208.90</td>
<td>26</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult44.a">mult44.a</a></td>
<td>109.00</td>
<td>69</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult47.a">mult47.a</a></td>
<td>175.00</td>
<td>20</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult57.a">mult57.a</a></td>
<td>48.49</td>
<td>1058</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult65.a">mult65.a</a></td>
<td>47.49</td>
<td>1061</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult66.a">mult66.a</a></td>
<td>45.49</td>
<td>1580</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult68.a">mult68.a</a></td>
<td>188.00</td>
<td>20</td>
<td>at label &#39;noadd&#39; use &#39;ror&#39; not &#39;lsr&#39; as seen in some editions of the book</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult70.a">mult70.a</a></td>
<td>1987.11</td>
<td>31</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult71.a">mult71.a</a></td>
<td>1572.91</td>
<td>41</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult72.a">mult72.a</a></td>
<td>1544.56</td>
<td>16</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult73.a">mult73.a</a></td>
<td>1174.08</td>
<td>28</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult75.a">mult75.a</a></td>
<td>205.90</td>
<td>24</td>
<td><em>bugs fixed</em></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult76.a">mult76.a</a></td>
<td>185.00</td>
<td>18</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult77.a">mult77.a</a></td>
<td>288.00</td>
<td>43</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult78.a">mult78.a</a></td>
<td>188.00</td>
<td>20</td>
<td>fixed misleading variable names</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult79.a">mult79.a</a></td>
<td>399.00</td>
<td>39</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult80.a">mult80.a</a></td>
<td>110.00</td>
<td>325</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult81.a">mult81.a</a></td>
<td>199.00</td>
<td>26</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult82.a">mult82.a</a></td>
<td>67.24</td>
<td>827</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult83.a">mult83.a</a></td>
<td>56.00</td>
<td>1079</td>
<td></td>
</tr>
</tbody>
</table>
<h3 tabindex="-1" dir="auto"><a id="user-content-16-bit-x-16-bit-unsigned-multiply-with-32-bit-result" aria-hidden="true" tabindex="-1" href="#16-bit-x-16-bit-unsigned-multiply-with-32-bit-result"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>16 bit x 16 bit unsigned multiply, with 32 bit result</h3>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/TobyLobster/multiply_test/blob/main/results/6502_16x16=32.svg"><img src="https://github.com/TobyLobster/multiply_test/raw/main/results/6502_16x16=32.svg" alt="Results of 16 x 16 bit unsigned multiply"/></a></p>
<p dir="auto">To see the results of the smaller routines more clearly, here is a zoomed in view of the same results:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/TobyLobster/multiply_test/blob/main/results/6502_16x16=32_detail.svg"><img src="https://github.com/TobyLobster/multiply_test/raw/main/results/6502_16x16=32_detail.svg" alt="Results of 16 x 16 bit unsigned multiply (detail)"/></a></p>
<table>
<thead>
<tr>
<th>Source</th>
<th>Average Cycles</th>
<th>Memory (bytes)</th>
<th>My Changes</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult1.a">mult1.a</a></td>
<td>751.00</td>
<td>38</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult2.a">mult2.a</a></td>
<td>578.00</td>
<td>33</td>
<td>optimised slightly</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult3.a">mult3.a</a></td>
<td>711.00</td>
<td>36</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult4.a">mult4.a</a></td>
<td>567.00</td>
<td>137</td>
<td>I use mult39 from <em>Revs</em> and combine to make 16x16</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult15.a">mult15.a</a></td>
<td>206.60</td>
<td>2181</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult31.a">mult31.a</a></td>
<td>238.07</td>
<td>2219</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult33.a">mult33.a</a></td>
<td>609.86</td>
<td>1276</td>
<td>with test code removed, and tables page aligned. Stores numbers in MSB order</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult36.a">mult36.a</a></td>
<td>957.01</td>
<td>55</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult41.a">mult41.a</a></td>
<td>350.00</td>
<td>1149</td>
<td>I use mult13 and combine to make 16x16</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult42.a">mult42.a</a></td>
<td>403.83</td>
<td>647</td>
<td>I use mult16 and combine to make 16x16</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult45.a">mult45.a</a></td>
<td>695.00</td>
<td>38</td>
<td>optimised slightly</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult46.a">mult46.a</a></td>
<td>655.00</td>
<td>40</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult48.a">mult48.a</a></td>
<td>707.11</td>
<td>69</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult49.a">mult49.a</a></td>
<td>703.00</td>
<td>43</td>
<td>version of mult48 with 8x16 multiply &#39;shortcut&#39; removed</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult50.a">mult50.a</a></td>
<td>534.00</td>
<td>55</td>
<td>unrolled mult2</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult51.a">mult51.a</a></td>
<td>524.00</td>
<td>69</td>
<td>unrolled mult2</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult52.a">mult52.a</a></td>
<td>519.00</td>
<td>75</td>
<td>unrolled mult2</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult53.a">mult53.a</a></td>
<td>514.00</td>
<td>95</td>
<td>unrolled mult2</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult54.a">mult54.a</a></td>
<td>497.00</td>
<td>192</td>
<td>unrolled mult2</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult55.a">mult55.a</a></td>
<td>483.50</td>
<td>344</td>
<td>fully unrolled mult2</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult56.a">mult56.a</a></td>
<td>259.96</td>
<td>1210</td>
<td>I use mult27 and combine to make 16x16</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult58.a">mult58.a</a></td>
<td>365.03</td>
<td>772</td>
<td>I use mult16 and combine to make 16x16</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult59.a">mult59.a</a></td>
<td>553.99</td>
<td>67</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult60.a">mult60.a</a></td>
<td>527.00</td>
<td>39</td>
<td>mult59 but I use fixed zero page addresses, remove &#39;decrement to avoid clc&#39;</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult61.a">mult61.a</a></td>
<td>482.00</td>
<td>57</td>
<td>...then unrolled the outer loop</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult62.a">mult62.a</a></td>
<td>442.00</td>
<td>93</td>
<td>...then unrolled the two inner loops once</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult63.a">mult63.a</a></td>
<td>422.00</td>
<td>165</td>
<td>...then unrolled the two inner loops twice</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult64.a">mult64.a</a></td>
<td>392.00</td>
<td>285</td>
<td>...then unrolled the two inner loops fully, and optimise register use</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult67.a">mult67.a</a></td>
<td>633.00</td>
<td>37</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult69.a">mult69.a</a></td>
<td>946.52</td>
<td>65</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/mult74.a">mult74.a</a></td>
<td>1358.00</td>
<td>86</td>
<td><em>bug fixed</em></td>
</tr>
</tbody>
</table>
<h3 tabindex="-1" dir="auto"><a id="user-content-signed-multiply-1" aria-hidden="true" tabindex="-1" href="#signed-multiply-1"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Signed multiply</h3>
<p dir="auto">Here are some example signed multiply routines. The signed routines are usually just an unsigned routine with adjustments made before and/or after it. See below for how to adapt an unsigned multiply into a signed multiply routine.</p>
<table>
<thead>
<tr>
<th>Source</th>
<th>Average cycles</th>
<th>Memory (bytes)</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/smult1.a">smult1.a</a></td>
<td>62.99</td>
<td>2095</td>
<td>8 x 8 bit <em>signed</em> multiply (16 bit result), tweaked for size and speed (based on mult14.a)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/smult2.a">smult2.a</a></td>
<td>329.67</td>
<td>49</td>
<td>8 x 8 bit <em>signed</em> multiply (16 bit result), Booth&#39;s Algorithm, <em>bug fixed</em> and optimised</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/smult3.a">smult3.a</a></td>
<td>277.57</td>
<td>2253</td>
<td>16 x 16 bit <em>signed</em> multiply (32 bit result), tweaked slightly (based on mult31.a)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/smult4.a">smult4.a</a></td>
<td>242.52</td>
<td>67</td>
<td>8 x 8 bit <em>signed</em> multiply (16 bit result) based on the unsigned mult19</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/smult5.a">smult5.a</a></td>
<td>180.50</td>
<td>35</td>
<td>8 x 8 bit <em>signed</em> multiply (16 bit result) based on the unsigned mult9</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/smult6.a">smult6.a</a></td>
<td>158.00</td>
<td>39</td>
<td>8 x 8 bit <em>signed</em> multiply (16 bit result)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/smult7.a">smult7.a</a></td>
<td>88.50</td>
<td>1400</td>
<td>8 x 8 bit <em>signed</em> multiply (16 bit result) with <em>bug fix</em></td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/smult8.a">smult8.a</a></td>
<td>62.99</td>
<td>1068</td>
<td>8 x 8 bit <em>signed</em> multiply (16 bit result) based on the unsigned mult65</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/smult9.a">smult9.a</a></td>
<td>570.00</td>
<td>81</td>
<td>16 x 16 bit <em>signed</em> multiply (32 bit result) based on the unsigned mult60</td>
</tr>
</tbody>
</table>
<h3 tabindex="-1" dir="auto"><a id="user-content-miscellaneous-multiply-1" aria-hidden="true" tabindex="-1" href="#miscellaneous-multiply-1"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Miscellaneous multiply</h3>
<p dir="auto">Other miscellaneous multiply routines with something &#39;specialised&#39; about it e.g. only returning an approximate result, or with different bit depths.
A decent variable bit length multiply is available in omult23.a, but for other maths operations, see <a href="https://archive.org/details/bbc-micro-machine-code-portfolio/page/87/mode/2up" rel="nofollow"><em>BBC Micro Machine Code Portfolio</em></a> by Bruce Smith (1984).</p>
<table>
<thead>
<tr>
<th>Source</th>
<th>Average cycles</th>
<th>Memory (bytes)</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult1.a">omult1.a</a></td>
<td>649.00</td>
<td>33</td>
<td>16 x 16 bit unsigned multiply, <em>ONLY low 16 bit</em> result</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult2.a">omult2.a</a></td>
<td>145.00</td>
<td>16</td>
<td>8 x 8 bit unsigned multiply, <em>ONLY low 8 bit</em> result</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult3.a">omult3.a</a></td>
<td>128.00</td>
<td>24</td>
<td>8 x 8 bit unsigned multiply, <em>ONLY high 8 bit</em> result</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult3.a">omult4.a</a></td>
<td>686.88</td>
<td>70</td>
<td>24 x 8 bit <em>sign-magnitude</em> multiply, 32 bit result</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult5.a">omult5.a</a></td>
<td>492.96</td>
<td>196</td>
<td>16 x 16 bit <em>signed/sign-magnitude</em> multiply, 16 bit signed <em>approximate</em> result</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult6.a">omult6.a</a></td>
<td>153.46</td>
<td>38</td>
<td>16 x 16 bit unsigned multiply, <em>ONLY low 16 bit</em> result (or carry set on overflow)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult7.a">omult7.a</a></td>
<td>46.72</td>
<td>802</td>
<td>8 x 8 bit unsigned multiply, 8 bit high byte <em>approximate</em> result</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult8.a">omult8.a</a></td>
<td>49.20</td>
<td>1075</td>
<td>8 x 8 bit unsigned multiply, 8 bit high byte <em>approximate</em> result</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult9.a">omult9.a</a></td>
<td>22.97</td>
<td>780</td>
<td>8 x 8 bit unsigned multiply, 8 bit high byte <em>approximate</em> result</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult10.a">omult10.a</a></td>
<td>909.00</td>
<td>50</td>
<td>16 x 32 bit unsigned multiply, 32 bit low bytes result</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult11.a">omult11.a</a></td>
<td>43.00</td>
<td>547</td>
<td>8 x 8 bit unsigned multiply, <em>ONLY approximate high 8 bit</em> result</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult12.a">omult12.a</a></td>
<td>181.04</td>
<td>27</td>
<td>8 x 8 bit unsigned multiply, <em>ONLY low 8 bit</em> result</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult13.a">omult13.a</a></td>
<td>202.01</td>
<td>179</td>
<td>16 signed x 8 bit sign-magnitude, 16 bit result, div 128</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult14.a">omult14.a</a></td>
<td>575.00</td>
<td>43</td>
<td>16 x 16 bit unsigned multiply, <em>ONLY low 16 bit</em> result</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult15.a">omult15.a</a></td>
<td>390.00</td>
<td>47</td>
<td>16 x 16 bit unsigned multiply, <em>ONLY low 16 bit</em> result</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult16.a">omult16.a</a></td>
<td>223.69</td>
<td>33</td>
<td>16 x 16 bit unsigned multiply, <em>ONLY low 16 bit</em> result (or carry set on overflow)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult17.a">omult17.a</a></td>
<td>267.00</td>
<td>34</td>
<td>16 x 8 bit unsigned multiply, <em>ONLY low 16 bit</em> result</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult18.a">omult18.a</a></td>
<td>2036.00</td>
<td>76</td>
<td>variable m x n byte unsigned multiply (all 16 bit x 16 bit multiplies tested)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult19.a">omult19.a</a></td>
<td>2169.00</td>
<td>48</td>
<td>24 x 24 bit unsigned multiply, 48 bit result (tested over millions of random inputs, and all 16 bit inputs)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult20.a">omult20.a</a></td>
<td>2741.00</td>
<td>66</td>
<td>32 x 32 bit unsigned multiply, 64 bit result (tested over millions of random inputs, and all 16 bit inputs)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult21.a">omult21.a</a></td>
<td>1014.00</td>
<td>49</td>
<td>24 x 24 bit unsigned multiply, 48 bit result (tested over millions of random inputs, and all 16 bit inputs)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult22.a">omult22.a</a></td>
<td>1653.00</td>
<td>59</td>
<td>32 x 32 bit unsigned multiply, 64 bit result (tested over millions of random inputs, and all 16 bit inputs)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult23.a">omult23.a</a></td>
<td>1381.00</td>
<td>76</td>
<td>variable m x n byte unsigned multiply (all 16 bit x 16 bit multiplies tested)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult24.a">omult24.a</a></td>
<td>1356.94</td>
<td>61</td>
<td>24 x 24 bit unsigned multiply, <em>ONLY low 24 bit</em> result (tested over millions of random inputs, and all 16 bit inputs)</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult25.a">omult25.a</a></td>
<td>60.00</td>
<td>16</td>
<td>3 x 8 bit unsigned multiply, <em>ONLY high 8 bit</em> result</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult26.a">omult26.a</a></td>
<td>145.00</td>
<td>16</td>
<td>8 x 8 bit unsigned multiply, <em>ONLY high 8 bit</em> result</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult27.a">omult27.a</a></td>
<td>444.00</td>
<td>22</td>
<td>16 x 8 bit unsigned multiply, <em>ONLY high 16 bit</em> result</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult28.a">omult28.a</a></td>
<td>897.00</td>
<td>24</td>
<td>24 x 8 bit unsigned multiply, <em>ONLY high 24 bit</em> result</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult29.a">omult29.a</a></td>
<td>267.00</td>
<td>34</td>
<td>16 x 8 bit unsigned multiply, <em>ONLY low 16 bit</em> result</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult30.a">omult30.a</a></td>
<td>310.00</td>
<td>40</td>
<td>24 x 8 bit unsigned multiply, <em>ONLY high 24 bit</em> result</td>
</tr>
<tr>
<td><a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult31.a">omult31.a</a></td>
<td>168.90</td>
<td>2162</td>
<td>24 x 8 bit unsigned multiply, <em>ONLY high 24 bit</em> result</td>
</tr>
</tbody>
</table>
<h2 tabindex="-1" dir="auto"><a id="user-content-the-algorithms" aria-hidden="true" tabindex="-1" href="#the-algorithms"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>The Algorithms</h2>
<h3 tabindex="-1" dir="auto"><a id="user-content-1-binary-multiplication-shift-and-add" aria-hidden="true" tabindex="-1" href="#1-binary-multiplication-shift-and-add"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>1. Binary Multiplication (Shift and Add)</h3>
<p dir="auto">This is the classic algorithm found in all good textbooks, similar to pen and paper &#39;long multiplication&#39;, but in base 2. A friendly introduction is found <a href="https://www.llx.com/Neil/a2/mult.html" rel="nofollow">here</a>. In short, one number is shifted left (doubled) each time around a loop, and the binary bits of the other number are used to determine whether to add this shifted number to a running total.</p>
<p dir="auto">This is the method used by most programs that need multiplication. It has the advantage that the code is small and it performs reasonably well. Also known as <a href="https://en.wikipedia.org/wiki/Ancient_Egyptian_multiplication" rel="nofollow">Ancient Egyptian multiplication</a>.</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-2-modified-shift-and-add" aria-hidden="true" tabindex="-1" href="#2-modified-shift-and-add"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>2. Modified Shift and Add</h3>
<p dir="auto">This is a clever variation of the standard shift and add algorithm that reduces the number of shifts required for a 16 bit multiply (and larger). In the standard algorithm each of the 16 loop iterations requires four byte shifts. In this variant each iteration only requires three shifts. This was found by Dr Jefyll in 2012, and is described <a href="http://forum.6502.org/viewtopic.php?p=19958#p19958" rel="nofollow">here</a>. The animated diagram is instructive.</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-3-tables-of-squares" aria-hidden="true" tabindex="-1" href="#3-tables-of-squares"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>3. Tables of Squares</h3>
<p dir="auto">By storing tables of square numbers, we can speed up multiplication. This uses:</p>
<p dir="auto"><math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7e9844113eff26573889ca9ae07ca73b">$$ab = f(a+b) - f(a-b),   where f(x) = \frac{x^2} {4}$$</math-renderer></p>
<p dir="auto">So using two table lookups, an addition and two subtractions, we can multiply. This is faster than &#39;shift and add&#39;. The downside is how much memory needed to store the data. For 8 bit multiplication, the amount of data varies depending on the exact implementation, but is either 2k of data (fastest), or 1k (only marginally slower), or 512 bytes (slightly slower again).</p>
<p dir="auto">An added feature of the 1k and 2k routines particularly is that if many multiplications are being done with one of the inputs unchanging then some setup code can be skipped, for even better performance. For example if a number of points are being rotated by some known angle.</p>
<p dir="auto">The data tables can be either loaded from storage, or initialised in code.</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-4-logarithms" aria-hidden="true" tabindex="-1" href="#4-logarithms"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>4. Logarithms</h3>
<p dir="auto">This is an approximation for multiplication. This uses:</p>
<p dir="auto"><math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7e9844113eff26573889ca9ae07ca73b">$$log(ab) = log(a) + log(b)$$</math-renderer></p>
<p dir="auto">By using a log and exponentiation tables, we can multiply using just three table lookups and one addition. This is fast.</p>
<p dir="auto">However, since we are working with integers and not floating point, this is only an approximation. In particular, when multiplying 8 bit x 8 bit and returning an 8 bit (high byte) result only, this can give a reasonable approximation.</p>
<p dir="auto">The method is described further here <a href="https://codebase64.org/doku.php?id=base:mathematics_in_assembly_part_6" rel="nofollow">here</a>. It has an implementation we look at next, and compare it with others:</p>
<h4 tabindex="-1" dir="auto"><a id="user-content-go64-magazine-articles-omult9a" aria-hidden="true" tabindex="-1" href="#go64-magazine-articles-omult9a"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><em>GO64!</em> magazine articles (<a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult9.a">omult9.a</a>)</h4>
<p dir="auto">This uses a 256 byte log table and a 511 byte antilog table (total: 767 bytes of data).</p>
<p dir="auto">Note that its formula for the antilog table <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7e9844113eff26573889ca9ae07ca73b">$y=2^{(x/f-8)}+.5$</math-renderer> should not have the <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7e9844113eff26573889ca9ae07ca73b">$+.5$</math-renderer> as this makes the results less accurate. In particular, testing with <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7e9844113eff26573889ca9ae07ca73b">$+.5$</math-renderer> over all 65536 possible inputs we get the following results:</p>
<div data-snippet-clipboard-copy-content="Error: -5  count: 1
Error: -4  count: 32
Error: -3  count: 262
Error: -2  count: 1086
Error: -1  count: 3934
Error: 0  count: 26871
Error: 1  count: 28384
Error: 2  count: 3937
Error: 3  count: 833
Error: 4  count: 180
Error: 5  count: 16

Root-mean-square deviation: 257.06 (smaller is better)"><pre><code>Error: -5  count: 1
Error: -4  count: 32
Error: -3  count: 262
Error: -2  count: 1086
Error: -1  count: 3934
Error: 0  count: 26871
Error: 1  count: 28384
Error: 2  count: 3937
Error: 3  count: 833
Error: 4  count: 180
Error: 5  count: 16

Root-mean-square deviation: 257.06 (smaller is better)
</code></pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/TobyLobster/multiply_test/blob/main/results/log9a.svg"><img src="https://github.com/TobyLobster/multiply_test/raw/main/results/log9a.svg" alt="omult9 results with 0.5 bias"/></a></p>
<p dir="auto">which is more often wrong than it is right. Without the <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7e9844113eff26573889ca9ae07ca73b">$+.5$</math-renderer> the code gives more accurate results:</p>
<div data-snippet-clipboard-copy-content="Error: -5  count: 9
Error: -4  count: 93
Error: -3  count: 468
Error: -2  count: 2088
Error: -1  count: 10529
Error: 0  count: 41848
Error: 1  count: 8275
Error: 2  count: 1753
Error: 3  count: 411
Error: 4  count: 61
Error: 5  count: 1

Root-mean-square deviation: 211.64 (smaller is better)"><pre><code>Error: -5  count: 9
Error: -4  count: 93
Error: -3  count: 468
Error: -2  count: 2088
Error: -1  count: 10529
Error: 0  count: 41848
Error: 1  count: 8275
Error: 2  count: 1753
Error: 3  count: 411
Error: 4  count: 61
Error: 5  count: 1

Root-mean-square deviation: 211.64 (smaller is better)
</code></pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/TobyLobster/multiply_test/blob/main/results/log9.svg"><img src="https://github.com/TobyLobster/multiply_test/raw/main/results/log9.svg" alt="omult9 results without 0.5 bias"/></a></p>
<h4 tabindex="-1" dir="auto"><a id="user-content-elite-master-version-omult7a" aria-hidden="true" tabindex="-1" href="#elite-master-version-omult7a"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><em>Elite</em>, Master version (<a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult7.a">omult7.a</a>)</h4>
<p dir="auto">The Master and Second Processor versions of <em>Elite</em> for the BBC Micro also use logarithms for approximating some 8 bit x 8 bit = 8 bit (high byte) multiplications (see <a href="https://www.bbcelite.com/deep_dives/multiplication_and_division_using_logarithms.html" rel="nofollow">here</a>).</p>
<p dir="auto">The BBC Master and Apple II versions of <em>Elite</em> have identical routines with two log tables and an antilog table (total: 768 bytes of data) for a version that is wrong by no more than six:</p>
<div data-snippet-clipboard-copy-content="Error -6: 10
Error -5: 119
Error -4: 626
Error -3: 2590
Error -2: 7082
Error -1: 20656
Error 0: 34451
Error 1: 2

Root-mean-square deviation: 292.66 (smaller is better)"><pre><code>Error -6: 10
Error -5: 119
Error -4: 626
Error -3: 2590
Error -2: 7082
Error -1: 20656
Error 0: 34451
Error 1: 2

Root-mean-square deviation: 292.66 (smaller is better)
</code></pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/TobyLobster/multiply_test/blob/main/results/log7.svg"><img src="https://github.com/TobyLobster/multiply_test/raw/main/results/log7.svg" alt="omult7 results"/></a></p>
<h4 tabindex="-1" dir="auto"><a id="user-content-elite-second-processor-version-omult8a" aria-hidden="true" tabindex="-1" href="#elite-second-processor-version-omult8a"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><em>Elite</em>, Second Processor version (<a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult8.a">omult8.a</a>)</h4>
<p dir="auto">The Second Processor version of <em>Elite</em> has a more accurate version using an extra antilog table (total: 1024 bytes of data), for a version that is wrong by no more than three:</p>
<div data-snippet-clipboard-copy-content="Error -3: 90
Error -2: 1981
Error -1: 19356
Error 0: 44109

Root-mean-square deviation: 167.60 (smaller is better)"><pre><code>Error -3: 90
Error -2: 1981
Error -1: 19356
Error 0: 44109

Root-mean-square deviation: 167.60 (smaller is better)
</code></pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/TobyLobster/multiply_test/blob/main/results/log8.svg"><img src="https://github.com/TobyLobster/multiply_test/raw/main/results/log8.svg" alt="omult8 results"/></a></p>
<h4 tabindex="-1" dir="auto"><a id="user-content-alternative-a-table-of-squares-approximation-omult11a" aria-hidden="true" tabindex="-1" href="#alternative-a-table-of-squares-approximation-omult11a"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Alternative: a table-of-squares approximation (<a href="https://github.com/TobyLobster/multiply_test/blob/main/tests/omult11.a">omult11.a</a>)</h4>
<p dir="auto">The same log and antilog tables can be used to implement an approximate division.</p>
<p dir="auto">If division is not needed however, then a table of squares method can be used (total: 512 bytes of data), and assuming (as with log based methods above) only the high byte of the product is required, the code for the low byte can be removed, for a version that is wrong by no more than one:</p>
<div data-snippet-clipboard-copy-content="Error -1: 4707
Error 0: 43681
Error 1: 17148
Root-mean-square deviation: 147.83 (smaller is better)"><pre><code>Error -1: 4707
Error 0: 43681
Error 1: 17148
Root-mean-square deviation: 147.83 (smaller is better)
</code></pre></div>
<p dir="auto">The table has been biased by &#39;-0.74&#39; by manual experimentation to minimize the root mean square deviation.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/TobyLobster/multiply_test/blob/main/results/log11.svg"><img src="https://github.com/TobyLobster/multiply_test/raw/main/results/log11.svg" alt="omult11 results"/></a></p>
<h3 tabindex="-1" dir="auto"><a id="user-content-5-four-bit-multiply" aria-hidden="true" tabindex="-1" href="#5-four-bit-multiply"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>5. Four bit multiply</h3>
<p dir="auto">Instead of &#39;binary multiplication&#39; using base 2 (as described above), we use base 16 (hexadecimal). We use a 256 byte table that stores the result of multiplying two 4 bit numbers together.</p>
<p dir="auto">To get an 8 bit x 8 bit multiply, we think of our two 8 bit numbers as being two pairs of hex digits AB and CD. We multiply each pair of hex digits together using the lookup table, and add them together as shown below. This is the same method as regular pen and paper &#39;long multiplication&#39;:</p>
<div data-snippet-clipboard-copy-content="        AB
       *CD
      ----
        xx      (B*D)+
       xx0      (A*D*16)+
       xx0      (B*C*16)+
      xx00      (A*C*256)"><pre><code>        AB
       *CD
      ----
        xx      (B*D)+
       xx0      (A*D*16)+
       xx0      (B*C*16)+
      xx00      (A*C*256)
</code></pre></div>
<p dir="auto">This algorithm is not the fastest, it&#39;s nearly 2 times slower than a regular shift and add.</p>
<p dir="auto"><em>Aviator</em> for the BBC Micro uses this method (see <a href="https://aviator.bbcelite.com/deep_dives/times_tables_and_nibble_arithmetic.html" rel="nofollow">here</a>).</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-6-booths-algorithm" aria-hidden="true" tabindex="-1" href="#6-booths-algorithm"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>6. Booth&#39;s Algorithm</h3>
<p dir="auto">The classic shift and add algorithm can sometimes end up doing a lot of addition. For instance multiplying by 15 involves four additions since 15 = 1+2+4+8, corresponding to a run of set bits in the multiplier. It would be quicker to multiply by 16 and subtract the original number.</p>
<p dir="auto"><a href="https://en.wikipedia.org/wiki/Booth&#39;s_multiplication_algorithm" rel="nofollow">Booth&#39;s Algorithm</a> tracks when successive bits of the multiplier <em>change</em> and either adds or subtracts the other number from the total as needed.</p>
<p dir="auto">Unusually, this method is designed for signed numbers, not unsigned.</p>
<p dir="auto">This method turns out to be ~2.7 times slower on the 6502 than an equivalent &#39;shift-and-add&#39; routine, so doesn&#39;t seem to be used much in practice. It&#39;s used more in designing hardware circuits.</p>
<p dir="auto">Further explanation of Booth&#39;s algorithm <a href="https://archive.org/details/AdvancedMicroDevices-AMD-SchottkyAndLow-PowerSchottkyDataBook1977OCR/page/n545/mode/2up" rel="nofollow">here</a>.</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-7-hardware-support" aria-hidden="true" tabindex="-1" href="#7-hardware-support"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>7. Hardware support</h3>
<p dir="auto">Some hardware has multiplication support in silicon. These are likely to be fastest where available. For instance, the <a href="https://en.wikipedia.org/wiki/Ricoh_5A22" rel="nofollow">SNES CPU</a> with its extended 6502 instruction set has hardware for &#39;unsigned 8 bit x 8 bit = 16 bit&#39; and &#39;signed 16 bit x 8 bit = 24 bit&#39; routines.</p>
<p dir="auto">Some early vector based arcade machines like <em>Tempest</em> and <em>Battlezone</em> were programmed in 6502, with an external processor (Atari&#39;s <a href="https://6502disassembly.com/va-battlezone/mathbox.html" rel="nofollow"><em>Math Box</em></a>) to handle the vector maths, including multiply routines.</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-8-repeated-addition" aria-hidden="true" tabindex="-1" href="#8-repeated-addition"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>8. Repeated addition</h3>
<p dir="auto">To multiply m*n, just add m, n times. This is stupidly slow for anything that isn&#39;t very small in n, so avoid in general. With 8 bit multiply, if I show them with all the others, the graph looks like this:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/TobyLobster/multiply_test/blob/main/results/6502_8x8=16_all.svg"><img src="https://github.com/TobyLobster/multiply_test/raw/main/results/6502_8x8=16_all.svg" alt="all results"/></a></p>
<p dir="auto">Only one (mult72, being smallest) is <em>just</em> worthy of an orange dot, in the unlikely scenario that you can afford 16 bytes but not 17:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/TobyLobster/multiply_test/blob/main/results/6502_8x8=16_repeated_addition.svg"><img src="https://github.com/TobyLobster/multiply_test/raw/main/results/6502_8x8=16_repeated_addition.svg" alt="repeated addition results"/></a></p>
<p dir="auto">The booby prize for the least efficient multiply goes to mult70 at nearly 2000 cycles average.</p>
<p dir="auto">So it&#39;s better generally to use binary multiplication instead (e.g. mult9 or mult11 are 17 bytes). However, for multiplying by small numbers (between 0 and 24), mult72 is more efficient than mult9.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-customising" aria-hidden="true" tabindex="-1" href="#customising"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Customising</h2>
<h3 tabindex="-1" dir="auto"><a id="user-content-1-changing-the-number-of-bits" aria-hidden="true" tabindex="-1" href="#1-changing-the-number-of-bits"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>1. Changing the number of bits</h3>
<p dir="auto">The most common routines I&#39;ve found either multiply two 8 bit values to get a 16 bit result, or multiply two 16 bit values to get a 32 bit result.</p>
<p dir="auto">These are useful, but in practice what you may need is something different, something custom made. For example you may need to multiply a 24 bit number by an 8 bit number, scaling the result down by 256 to get a new 24 bit number.</p>
<p dir="auto">The shift-and-add method is straightforward to extend to larger the number of bits, since the principles are the same no matter how many bits are used. An m-bit by n-bit multiply needs a result of m+n bits.</p>
<p dir="auto">It also helps to realise that you can make these routines by building on your favourite standard 8 bit x 8 bit = 16 bit routine.</p>
<p dir="auto">Just as binary multiplication works in base 2, this works in base 256. Each byte is one digit. For example, to make a 16 x 16 bit multiply:</p>
<div data-snippet-clipboard-copy-content="        AB
       *CD
      ----
        xx      (B*D)+
       xx0      (A*D*256)+
       xx0      (B*C*256)+
      xx00      (A*C*256*256)"><pre><code>        AB
       *CD
      ----
        xx      (B*D)+
       xx0      (A*D*256)+
       xx0      (B*C*256)+
      xx00      (A*C*256*256)
</code></pre></div>
<p dir="auto">Adding the four partial results as shown.</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-2-changing-the-in-and-out-parameters" aria-hidden="true" tabindex="-1" href="#2-changing-the-in-and-out-parameters"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>2. Changing the In and Out Parameters</h3>
<p dir="auto">Routines can take input values either from registers or from memory.
It can also return results in registers and/or memory.</p>
<h4 tabindex="-1" dir="auto"><a id="user-content-8-bit-x-8-bit--16-bit" aria-hidden="true" tabindex="-1" href="#8-bit-x-8-bit--16-bit"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>8 bit x 8 bit = 16 bit</h4>
<p dir="auto">The 8 bit routines I have presented here will generally use whichever parameter method is fastest.</p>
<p dir="auto">However, the calling code may want to use registers for the parameters for the multiply for both input and output as this is often most efficient. You may want to adjust the in/out parameters of the routine depending on your usage.</p>
<p dir="auto">In particular, if on exiting the routine the low byte of the result is in A, then it can be used as the starting point for a subsequent add or subtract, as used when combining to make a larger bit multiply. Sometimes carry is guaranteed clear after the multiply which also helps with optimising a subsequent addition.</p>
<h4 tabindex="-1" dir="auto"><a id="user-content-16-bit-x-16-bit--32-bit" aria-hidden="true" tabindex="-1" href="#16-bit-x-16-bit--32-bit"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>16 bit x 16 bit = 32 bit</h4>
<p dir="auto">These routines mostly use memory locations for in/out parameters, as there are too many values to hold in the registers.</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-3-only-using-partial-results" aria-hidden="true" tabindex="-1" href="#3-only-using-partial-results"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>3. Only Using Partial Results</h3>
<p dir="auto">For speed, some routines only provide a partial answer. e.g. it may return only the high byte of the result (as an approximation, often used with fixed point calculations) or the low byte (for multiplying small numbers that don&#39;t lead to results larger than one byte).</p>
<p dir="auto">For example, if a routine wants to multiply a 16 bit number by the sine of an angle this is a problem for an integer routine since the sine of an angle is a floating point number not an integer. By scaling up the fractional value to an integer e.g. <code>N=256*sin(angle)</code>, then the integer multiplication by N can happen and the result scaled down by 256. Note also that negative numbers will need special treatment:</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-4-making-signed-multiply-routines" aria-hidden="true" tabindex="-1" href="#4-making-signed-multiply-routines"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>4. Making Signed Multiply Routines</h3>
<p dir="auto">Two&#39;s complement representation is most commonly used to represent signed numbers. Occasionally routines use a sign-magnitude representation (e.g. omult4.a), but I will assume here the standard two&#39;s complement representation is used.</p>
<p dir="auto">There are two methods of dealing with multiplying signed numbers; one obvious, the other less obvious but faster. The more obvious method is:</p>
<ol dir="auto">
<li>remember if the sign of the two input numbers differ</li>
<li>remove the sign of each input value (abs)</li>
<li>do a regular unsigned multiply</li>
<li>recall if the signs differ and negate the result if needed</li>
</ol>
<p dir="auto">The faster, craftier method is:</p>
<ol dir="auto">
<li>do a regular unsigned multiply</li>
<li>If the first input is negative, subtract the second input from the high byte(s) of the result.</li>
<li>If the second input is negative, subtract the first input from the high byte(s) of the result.</li>
</ol>
<p dir="auto">This takes less memory and fewer cycles than the more obvious method. See <a href="http://www.ffd2.com/fridge/chacking/c=hacking16.txt" rel="nofollow">C=Hacking16</a> for more details.</p>
<p dir="auto">Caveat: If you are using a shift-and-add (or modified shift-and-add) then a small negative number like -1 will have lots of bits set, meaning lots of adds occur in the unsigned multiply. But it works well for table-of-squares routines.</p>
<p dir="auto">The code to do this can be optimised to be quite small. For instance smult1.a has:</p>
<div data-snippet-clipboard-copy-content="    ; Step 1: Unsigned multiply
    ;     &lt;do an unsigned multiply here&gt;
    ; Suppose at this point:
    ;     X=one of the original input numbers
    ;     A=high byte of result
    ;     Y=low byte of result

    ; Step 2: apply sign.
    cpx #$80             ; check the sign of one input              2 cycles
    bcc +                ; branch if positive.                      2/3/4
    sbc sm1              ; take off the other input.                3
+
    bit sm1              ; check the sign with of the other input.  3
    bpl +                ; branch if positive.                      2/3/4
    stx temp             ; store the amount to subtract.            4
    sec                  ; prepare carry for subtract.              2
temp = * + 1
    sbc #0               ; subtract (self modifying code).          2
+"><pre><code>    ; Step 1: Unsigned multiply
    ;     &lt;do an unsigned multiply here&gt;
    ; Suppose at this point:
    ;     X=one of the original input numbers
    ;     A=high byte of result
    ;     Y=low byte of result

    ; Step 2: apply sign.
    cpx #$80             ; check the sign of one input              2 cycles
    bcc +                ; branch if positive.                      2/3/4
    sbc sm1              ; take off the other input.                3
+
    bit sm1              ; check the sign with of the other input.  3
    bpl +                ; branch if positive.                      2/3/4
    stx temp             ; store the amount to subtract.            4
    sec                  ; prepare carry for subtract.              2
temp = * + 1
    sbc #0               ; subtract (self modifying code).          2
+
</code></pre></div>
<p dir="auto"><em>Corollary</em>: For an 8 bit x 8 bit multiply where only the low 8 bits of the result are required, there is no difference between the unsigned and signed result, the same answer works for both.
For a 16 bit x 16 bit multiply where only the lower 16 bits are required, the same is true.</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-5-self-modifying-code" aria-hidden="true" tabindex="-1" href="#5-self-modifying-code"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>5. Self modifying code</h3>
<p dir="auto">If not running from ROM, self-modifying code can be used to optimise for speed. The table of squares routines often do this, for example.
Implementations that use the shift-and-add algorithm will often add the multiplicand in a single location in the loop.
It may be possible to replace these &#39;adc multiplicand&#39; and &#39;adc multiplicand+1&#39; instructions with immediate versions &#39;adc #0&#39;
and write the multiplicand into the adc operands directly from the caller code.</p>
<p dir="auto">If using self-modifying code, putting the code itself in zero page can make it run a little faster, if you have the space!</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-6-multiply-using-binary-coded-decimal-bcd" aria-hidden="true" tabindex="-1" href="#6-multiply-using-binary-coded-decimal-bcd"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>6. Multiply using Binary Coded Decimal (BCD)</h3>
<p dir="auto">This can be done, but not very efficiently. <a href="https://llx.com/Neil/a2/decimal.html" rel="nofollow">Here</a> is an implementation that uses the &#39;<a href="https://en.wikipedia.org/wiki/Ancient_Egyptian_multiplication#Russian_peasant_multiplication" rel="nofollow">Russian peasant multiplication</a>&#39;.
There is discussion of various methods on the <a href="http://forum.6502.org/viewtopic.php?t=4978" rel="nofollow">6502.org forum</a>.
A multibyte BCD multiply (for numbers up to 255 bytes long!) is in <a href="https://archive.org/details/6502_Assembly_Lanuage_Rountines_part_2/page/n15/mode/2up" rel="nofollow">6502 Assembly Lanuage Routines</a>.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-how-to-run-the-tests" aria-hidden="true" tabindex="-1" href="#how-to-run-the-tests"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>How to run the tests</h2>
<h3 tabindex="-1" dir="auto"><a id="user-content-dependencies" aria-hidden="true" tabindex="-1" href="#dependencies"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Dependencies</h3>
<ul dir="auto">
<li>I use the <a href="https://github.com/redcode/6502">MOS Technology 6502 CPU Emulator</a> to emulate the 6502.</li>
<li>I use the <a href="https://github.com/redcode/Z">Z</a> header only library as it is required by the emulator.</li>
<li>I use the <a href="http://www.libpng.org/pub/png/libpng.html" rel="nofollow">libpng</a> library to plot the log error images.</li>
<li>I use <a href="https://matplotlib.org" rel="nofollow">matplotlib</a> python library to plot the graphs.</li>
<li>I use the <a href="https://github.com/meonwax/acme">acme</a> assembler.</li>
<li>I use clang to compile the C code.</li>
<li>I use python3 to create the graphs.</li>
</ul>
<h3 tabindex="-1" dir="auto"><a id="user-content-go" aria-hidden="true" tabindex="-1" href="#go"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Go</h3>
<ul dir="auto">
<li>I&#39;m set up for macOS. The &#39;go&#39; script specifies which tests to execute. Uncomment the test(s) you want to run. Run the &#39;go&#39; script to execute the tests.</li>
<li>The &#39;tests&#39; folder contains a number of 6502 assembly language files (&#39;.a&#39; files) to test.</li>
<li>The testing is configured by a small associated &#39;.c&#39; file.</li>
<li>The test results are written to the results/ folder.</li>
<li>Tests can be executed on multiple threads for speed. Adjust this in the go script: <code>-n&lt;number&gt;</code> on the command line for the tester program specifies the number of threads.</li>
<li>The &#39;go_plot&#39; script is used to create the graphs from the results as svg files.</li>
</ul>
<h3 tabindex="-1" dir="auto"><a id="user-content-how-testing-works" aria-hidden="true" tabindex="-1" href="#how-testing-works"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>How testing works</h3>
<ul dir="auto">
<li>The assembly language code is assembled into a binary file using the acme assembler.</li>
<li>The tester C code is compiled (using clang) along with the test parameters &#39;.c&#39; file.</li>
<li>The 6502 binary is loaded and executed (simulated) multiple times, over all possible inputs (specified by the test&#39;s &#39;.c&#39; file).</li>
<li>Any unexpected results (e.g. due to errors in the algorithm or the test) are reported. The test case that failed is re-run with a full disassembly output to aid debugging.</li>
<li>The average cycle count is reported and results are output to a json file.</li>
</ul>
<h2 tabindex="-1" dir="auto"><a id="user-content-see-also" aria-hidden="true" tabindex="-1" href="#see-also"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>See Also</h2>
<p dir="auto">See also my <a href="https://github.com/TobyLobster/sqrt_test">sqrt_test</a> repository for comparing implementations of square root.</p>
</article>
          </div></div>
  </body>
</html>
