<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://maskray.me/blog/2025-03-09-compiling-c&#43;&#43;-with-clang-api">Original</a>
    <h1>Compiling C&#43;&#43; with the Clang API</h1>
    
    <div id="readability-page-1" class="page"><div id="wrap">
      

      <div>
        <section id="main"><article id="post-compiling-c++-with-clang-api" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting">
  
  <div>
    
    
      <header>
        
  
    
  

      </header>
    
    <div itemprop="articleBody">
      
        <p>This post describes how to compile a single C++ source file to an
object file with the Clang API. Here is the code. It behaves like a
simplified <code>clang</code> executable that handles <code>-c</code>
and <code>-S</code>.</p>
<figure><table><tbody><tr><td><pre><span>1</span><br/></pre></td><td><pre><span><span>cat</span> &gt; main.cc &lt;&lt;<span>eof</span></span><br/></pre></td></tr></tbody></table></figure>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span>#<span>include</span> <span>&lt;clang/CodeGen/CodeGenAction.h&gt;</span> </span></span></pre></td></tr></tbody></table></figure>
<figure><table><tbody><tr><td><pre><span>1</span><br/></pre></td><td><pre><span>eof</span><br/></pre></td></tr></tbody></table></figure>
<h2 id="building-the-code-with-cmake">Building the code with CMake</h2>
<p>Let&#39;s write a <code>CMakeLists.txt</code> that links against the
needed Clang and LLVM libraries.</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span>cat</span> &gt; CMakeLists.txt &lt;&lt;<span>eof</span></span></pre></td></tr></tbody></table></figure>
<p>We need an LLVM and Clang installation that provides both
<code>lib/cmake/llvm/LLVMConfig.cmake</code> and
<code>lib/cmake/clang/ClangConfig.cmake</code>. You can grab these from
system packages (dev versions may be required) or build LLVM
yourself-I&#39;ll skip the detailed steps here. For a DIY build, use:</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span># cmake ... -DLLVM_ENABLE_PROJECTS=&#39;clang&#39;</span></pre></td></tr></tbody></table></figure>
<p>No <code>install</code> step is needed. Next, create a build
directory with the CMake configuration above:</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span>cmake -S. -Bout/debug -G Ninja -DCMAKE_BUILD_TYPE=Debug -DCMAKE_CXX_COMPILER=<span>$HOME</span>/Stable/bin/clang++ -DCMAKE_PREFIX_PATH=<span>&#34;<span>$HOME</span>/llvm/out/stable&#34;</span></span></pre></td></tr></tbody></table></figure>
<p>I&#39;ve set a prebuilt Clang as <code>CMAKE_CXX_COMPILER</code>-just a
habit of mine. llvm-project isn&#39;t guaranteed to build warning-free with
GCC, since GCC <code>-Wall -Wextra</code> has many false positives and
LLVM developers avoid cluttering the codebase.</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span>% echo &#39;void f() {}&#39; &gt; a.cc</span></pre></td></tr></tbody></table></figure>
<h2 id="anonymous-files">Anonymous files</h2>
<p>The input source file and the output ELF file are stored in the
filesystem. We could create a temporary file and delete it with a RAII
class <code>llvm::FileRemover</code>:</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span>std::error_code ec = llvm::sys::fs::<span>createTemporaryFile</span>(<span>&#34;clang&#34;</span>, <span>&#34;cc&#34;</span>, fdIn, tempPath);</span></pre></td></tr></tbody></table></figure>
<p>On Linux, we could utilzie <code>memfd_create</code> to create a file
in RAM with a volatile backing storage.</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span>int</span> fdIn = <span>memfd_create</span>(<span>&#34;input&#34;</span>, MFD_CLOEXEC);</span></pre></td></tr></tbody></table></figure>
<h2 id="llvminitialize"><code>LLVMInitialize*</code></h2>
<p>To generate x86 code, we need a few LLVM X86 libraries defined by
<code>llvm/lib/Target/X86/**/CMakeLists.txt</code> files.</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span>LLVMInitializeX86AsmPrinter</span>();</span></pre></td></tr></tbody></table></figure>
<p>If inline assembly is used, we will also need the AsmParser
library:</p>
<figure><table><tbody><tr><td><pre><span>1</span><br/></pre></td><td><pre><span><span>LLVMInitializeX86AsmParser</span>();</span><br/></pre></td></tr></tbody></table></figure>
<p>We could also call <code>LLVMInitializeAll*</code> functions instead,
which initialize all supported targets (build-time
<code>LLVM_TARGETS_TO_BUILD</code>).</p>
<p>Here are some notes about the LLVMX86 libraries:</p>
<ul>
<li>LLVMX86Info: <code>llvm/lib/Target/X86/TargetInfo/</code></li>
<li>LLVMX86Desc: <code>llvm/lib/Target/X86/MCTargetDesc/</code> (depends
on LLVMX86Info)</li>
<li>LLVMX86AsmParser: <code>llvm/lib/Target/X86/AsmParser</code>
(depends on LLVMX86Info and LLVMX86Desc)</li>
<li>LLVMX86CodeGen: <code>llvm/lib/Target/X86/</code> (depends on
LLVMX86Info and LLVMX86Desc)</li>
</ul>
<h2 id="emitassembly-and-emitobj"><code>EmitAssembly</code> and
<code>EmitObj</code></h2>
<p>The code supports two frontend actions, <code>EmitAssembly</code>
(<code>-S</code>) and <code>EmitObj</code> (<code>-c</code>).</p>
<p>You could also utilize the API in
<code>clang/include/clang/FrontendTool/Utils.h</code>, but that would
pull in another library <code>clangFrontendTool</code> (different from
<code>clangFrontend</code>).</p>
<h2 id="diagnostics">Diagnostics</h2>
<p>The diagnostics system is quite complex. We have
<code>DiagnosticConsumer</code>, <code>DiagnosticsEngine</code>, and
<code>DiagnosticOptions</code>.</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span>DiagnosticsEngine</span></pre></td></tr></tbody></table></figure>
<p>We define a simple <code>DiagnosticConsumer</code> that handles
notes, warnings, errors, and fatal errors. When macro expansion comes
into play, we report two key locations:</p>
<ul>
<li>The physical location (<code>fileLoc</code>), where the expanded
token triggers an issue-matching Clang&#39;s error line, and</li>
<li>The spelling location within the macro&#39;s replacement list
(<code>sm.getSpellingLoc(loc)</code>).</li>
</ul>
<p>Although Clang also highlights intermediate locations for chained
expansions, our simple approach offers a solid approximation.</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span>% cat a.h</span></pre></td></tr></tbody></table></figure>
<p>We call a convenience function
<code>CompilerInstance::ExecuteAction</code>, which wraps lower-level
API like <code>BeginSource</code>, <code>Execute</code>, and
<code>EndSource</code>. However, it will print
<code>1 warning and 1 error generated.</code> unless we set
<code>ShowCarets</code> to false.</p>
<h2 id="clangcreateinvocation"><code>clang::createInvocation</code></h2>
<p><code>clang::createInvocation</code>, renamed from <a target="_blank" rel="noopener" href="https://reviews.llvm.org/D124971"><code>createInvocationFromCommandLine</code></a>
in 2022, combines <code>clang::Driver::BuildCompilation</code> and
<code>clang::CompilerInvocation::CreateFromArgs</code>. While it saves a
few lines for certain tasks, it lacks the flexibility we need for our
specific use cases.</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="https://maskray.me/blog/2025-02-17-migrating-comments-to-giscus" id="article-nav-older">
      <strong>Older</strong>
      <p>Migrating comments to giscus</p>
    </a>
  
</nav>

  
</article>








</section>
        
          
        
      </div>
      

    </div></div>
  </body>
</html>
