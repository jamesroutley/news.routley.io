<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.infoq.com/articles/java-virtual-threads/">Original</a>
    <h1>Virtual Threads: New Foundations for High-Scale Java Applications</h1>
    
    <div id="readability-page-1" class="page"><div>
							
								<div>
									<h3>Key Takeaways</h3>
									<ul>
	<li> Virtual threads are a lightweight implementation of Java threads, delivered as a preview feature in Java 19.</li>
	<li> Virtual threads dramatically reduce the effort of writing, maintaining, and observing high-throughput concurrent applications.</li>
	<li> Virtual threads breathe new life into the familiar thread-per-request style of programming, allowing it to scale with near-optimal hardware utilization.</li>
	<li> Virtual threads are fully compatible with the existing `Thread` API, so existing applications and libraries can support them with minimal change.</li>
	<li> Virtual threads support the existing debugging and profiling interfaces, enabling easy troubleshooting, debugging, and profiling of virtual threads with existing tools and techniques.</li>
</ul>

									
								</div>
							
							
								
								<p>Java 19 brings the first <a href="https://openjdk.java.net/jeps/12">preview</a> of <a href="https://openjdk.java.net/jeps/425"><em>virtual threads</em></a> to the Java platform; this is the main deliverable of OpenJDKs <a href="https://wiki.openjdk.org/display/loom/Main">Project Loom</a>. This is one of the biggest changes to come to Java in a long time -- and at the same time, is an almost imperceptible change. Virtual threads fundamentally change how the Java runtime interacts with the underlying operating system, eliminating significant impediments to scalability -- but change relatively little about how we build and maintain concurrent programs. There is almost zero new API surface, and virtual threads behave almost exactly like the threads we already know. Indeed, to use virtual threads effectively, there is more <em>unlearning</em> than learning to be done.</p>

<h2>Threads</h2>

<p>Threads are foundational in Java. When we run a Java program, its main method is invoked as the first call frame of the <code>&#34;main&#34;</code> thread, which is created by the Java launcher. When one method calls another, the callee runs on the same thread as the caller, and where to return to is recorded on the threads stack. When a method uses local variables, they are stored in that methods call frame on the threads stack. When something goes wrong, we can reconstruct the context of how we got to the current point -- a stack trace -- by walking the current threads stack. Threads give us so many things we take for granted every day: sequential control flow, local variables, exception handling, single-step debugging, and profiling. Threads are also the basic unit of scheduling in Java programs; when a thread blocks waiting for a storage device, network connection, or a lock, the thread is descheduled so another thread can run on that CPU. Java was the first mainstream language to feature integrated support for thread-based concurrency, including a cross-platform memory model; threads are foundational to Javas model of concurrency.</p>

<p>Despite all this, threads often get a bad reputation, because most developers experience with threads is in trying to implement or debug shared-state concurrency. Indeed, shared-state concurrency -- often referred to as &#34;programming with threads and locks&#34; -- can be difficult. Unlike many other aspects of programming on the Java platform, the answers are not all to be found in the language specification or API documentation; writing safe, performant concurrent code that manages shared mutable state requires understanding subtle concepts like memory visibility, and a great deal of discipline. (If it were easier, the authors own <a href="https://jcip.net/"><em>Java Concurrency in Practice</em></a> would not weigh in at almost 400 pages.)</p>


								
								
									








								
								<p>Despite the legitimate apprehension that developers have when approaching concurrency, it is easy to forget that the other 99% of the time, threads are quietly and reliably making our lives much easier, giving us exception handling with informative stack traces, serviceability tools that let us observe what is going on in each thread, remote debugging, and the illusion of sequentiality that makes our code easier to reason about.</p>

<h3>Platform threads</h3>

<p>Java achieved write-once, run-anywhere for concurrent programs by ensuring that the language and APIs provided a complete, portable abstraction for threads, inter-thread coordination mechanisms, and a memory model that gives predictable semantics to the effects of threads on memory, that could be efficiently mapped to a number of different underlying implementations.</p>

<p>Most JVM implementations today implement Java threads as thin wrappers around operating system threads; well call these heavyweight, OS-managed threads <em>platform threads</em>. This isnt required -- in fact, Javas threading model predates widespread OS support for threads -- but because modern OSes now have good support for threads (in most OSes today, the thread is the basic unit of scheduling), there are good reasons to lean on the underlying platform threads. But this reliance on OS threads has a downside: because of how most OSes implement threads, thread creation is relatively expensive and resource-heavy. This implicitly places a practical limit on how many we can create, which in turn has consequences for how we use threads in our programs.</p>


								
								
									
								
								<p>Operating systems typically allocate thread stacks as monolithic blocks of memory at thread creation time that cannot be resized later. This means that threads carry with them megabyte-scale chunks of memory to manage the native and Java call stacks. Stack size can be tuned both with command-line switches and <code>Thread</code> constructors, but tuning is risky in both directions. If stacks are overprovisioned, we will use even more memory; if they are underprovisioned, we risk <code>StackOverflowException</code> if the wrong code is called at the wrong time. We generally lean towards overprovisioning thread stacks as being the lesser of evils, but the result is a relatively low limit on how many concurrent threads we can have for a given amount of memory.</p>

<p>Limiting how many threads we can create is problematic because the simplest approach to building server applications is the thread-per-task approach: assign each incoming request to a single thread for the lifetime of the task.</p>

<p>Until now, Java developers who wanted to service large volumes of concurrent requests had several bad choices: constrain how code is written so it can use substantially smaller stack sizes (which usually means giving up on most third-party libraries), throw more hardware at the problem, or switch to an &#34;async&#34; or &#34;reactive&#34; style of programming. While the &#34;async&#34; model has had some popularity recently, it means programming in a highly constrained style which requires us to give up many of the benefits that threads give us, such as readable stack traces, debugging, and observability. Due to the design patterns employed by most async libraries, it also means giving up many of the benefits the Java language gives us as well, because async libraries essentially become rigid domain-specific languages that want to manage the entirety of the computation. This sacrifices many of the things that make programming in Java productive.</p>

<h2>Virtual threads</h2>

<p>Virtual threads are an alternative implementation of <code>java.lang.Thread</code> which store their stack frames in Javas garbage-collected heap rather than in monolithic blocks of memory allocated by the operating system. We dont have to guess how much stack space a thread might need, or make a one-size-fits-all estimate for all threads; the memory footprint for a virtual thread starts out at only a few hundred bytes, and is expanded and shrunk automatically as the call stack expands and shrinks.</p>

<p>The operating system only knows about platform threads, which remain the unit of scheduling. To run code in a virtual thread, the Java runtime arranges for it to run by <em>mounting</em> it on some platform thread, called a <em>carrier thread</em>. Mounting a virtual thread means temporarily copying the needed stack frames from the heap to the stack of the carrier thread, and borrowing the carriers stack while it is mounted.</p>

<p>When code running in a virtual thread would otherwise block for IO, locking, or other resource availability, it can be <em>unmounted</em> from the carrier thread, and any modified stack frames copied are back to the heap, freeing the carrier thread for something else (such as running another virtual thread.) Nearly all blocking points in the JDK have been adapted so that when encountering a blocking operation on a virtual thread, the virtual thread is unmounted from its carrier instead of blocking.</p>

<p>Mounting and unmounting a virtual thread on a carrier thread is an implementation detail that is entirely invisible to Java code. Java code cannot observe the identity of the current carrier (calling <code>Thread::currentThread</code> always returns the virtual thread); <code>ThreadLocal</code> values of the carrier thread are not visible to a mounted virtual thread; the stack frames of the carrier do not show up in exceptions or thread dumps for the virtual thread. During the virtual threads lifetime, it may run on many different carrier threads, but anything depending on thread identity, such as locking, will see a consistent picture of what thread it is running on.</p>

<p>Virtual threads are so-named because they share characteristics with virtual memory. With virtual memory, applications have the illusion that they have access to the entire memory address space, not limited by the available physical memory. The hardware completes this illusion by temporarily mapping plentiful virtual memory to scarce physical memory as needed, and when some other virtual page needs that physical memory, the old contents are first paged out to disk. Similarly, virtual threads are cheap and plentiful, and share the scarce and expensive platform threads as needed, and inactive virtual thread stacks are &#34;paged&#34; out to the heap.</p>

<p>Virtual threads have relatively little new API surface. There are several new methods for creating virtual threads (e.g., <a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Thread.html#ofVirtual()"><code>Thread::ofVirtual</code></a>), but after creation, they are ordinary <code>Thread</code> objects and behave like the threads we already know. Existing APIs such as <code>Thread::currentThread</code>, <code>ThreadLocal</code>, interruption, stack walking, etc, work exactly the same on virtual threads as on platform threads, which means we can run existing code confidently on virtual threads.</p>

<p>The following example illustrates using virtual threads to concurrently fetch two URLs and aggregate their results as part of handling a request. It creates an <a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/concurrent/ExecutorService.html"><code>ExecutorService</code></a> that runs each task in a new virtual thread, submits two tasks to it, and waits for the results. <code>ExecutorService</code> has been retrofitted to implement <code>AutoCloseable</code>, so it can be used with <code>try-with-resources</code>, and the <code>close</code> method shuts down the executor and waits for tasks to complete.<code> </code></p>

<pre><code>void handle(Request request, Response response) {
    var url1 = ...
    var url2 = ...

    try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
        var future1 = executor.submit(() -&gt; fetchURL(url1));
        var future2 = executor.submit(() -&gt; fetchURL(url2));
        response.send(future1.get() + future2.get());
    } catch (ExecutionException | InterruptedException e) {
        response.fail(e);
    }
}

String fetchURL(URL url) throws IOException {
    try (var in = url.openStream()) {
        return new String(in.readAllBytes(), StandardCharsets.UTF_8);
    }
}</code></pre>

<p>On reading this code, we might initially worry it is somehow profligate to create threads for such short-lived activities or a thread pool for so few tasks, but this is just something we will have to unlearn -- this code is a perfectly responsible use of virtual threads</p>

<h3>Isnt this just &#34;green threads&#34;?</h3>

<p>Java developers may recall that in the Java 1.0 days, some JVMs implemented threads using <a href="https://docs.oracle.com/cd/E19455-01/806-3461/ch2mt-41/index.html">user-mode</a>, or &#34;green&#34;, threads. Virtual threads bear a superficial similarity to green threads in that they are both managed by the JVM rather than the OS, but this is where the similarity ends. The green threads of the 90s still had large, monolithic stacks. They were very much a product of their time, when systems were single-core and OSes didnt have thread support at all. Virtual threads have more in common with the user-mode threads found in other languages, such as <a href="https://go.dev/tour/concurrency/1">goroutines</a> in <a href="https://go.dev/tour/welcome/1">Go</a> or <a href="https://www.erlang.org/doc/reference_manual/processes.html">processes</a> in <a href="https://www.erlang.org/">Erlang</a> -- but have the advantage of being semantically identical to the threads we already have.</p>

<h3>It&#39;s about scalability</h3>

<p>Despite the difference in creation costs, virtual threads are not <em>faster</em> than platform threads; we cant do any more computation with one virtual thread in one second than we can with a platform thread. Nor can we schedule any more <em>actively running</em> virtual threads than we can platform threads; both are limited by the number of available CPU cores. So, what is the benefit? Because they are so lightweight, we can have many more <em>inactive</em> virtual threads than we can with platform threads. At first, this may not sound like a big benefit at all! But &#34;lots of inactive threads&#34; actually describes the majority of server applications. Requests in server applications spend much more time doing network, file, or database I/O than computation. So if we run each task in its own thread, most of the time that thread will be blocked on I/O or other resource availability. Virtual threads allow IO-bound thread-per-task applications to <em>scale better</em> by removing the most common scaling bottleneck -- the maximum number of threads -- which in turn enables better hardware utilization. Virtual threads allow us to have the best of both worlds: a programming style that is in harmony with the platform rather than working against it, while allowing optimal hardware utilization.</p>

<p>For CPU-bound workloads, we already have tools to get to optimal CPU utilization, such as the <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/ForkJoinPool.html">fork-join</a> framework and <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/stream/package-summary.html">parallel streams</a>. Virtual threads offer a complementary benefit to these. Parallel streams make it easier to scale CPU-bound workloads, but offer relatively little for IO-bound workloads; virtual threads offer a scalability benefit for IO-bound workloads, but relatively little for CPU-bound ones.</p>

<h3>Littles Law</h3>

<p>The scalability of a stable system is governed by <a href="https://en.wikipedia.org/wiki/Little%27s_law"><em>Littles Law</em></a>, which relates latency, concurrency, and throughput. If each request has a duration (or latency) of <em>d</em>, and we can perform <em>N</em> tasks concurrently, then throughput <em>T</em> is given by</p>

<pre><code><span>T</span> = <span>N</span> / d
</code></pre>

<p>Littles Law doesnt care about what portion of the time is spent &#34;doing work&#34; vs &#34;waiting&#34;, or whether the unit of concurrency is a thread, a CPU, an ATM machine, or a human bank teller. It just states that to scale up the throughput, we either have to proportionally scale down the latency or scale up the number of requests we can handle concurrently. When we hit the limit on concurrent threads, the throughput of the thread-per-task model is limited by Littles Law. Virtual threads address this in a graceful way by giving us more concurrent threads rather than asking us to change our programming model.</p>

<h3>Virtual threads in action</h3>

<p>Virtual threads do not replace platform threads; they are complementary. However, many server applications will choose virtual threads (often through the configuration of a framework) to achieve greater scalability.</p>

<p>The following example creates 100,000 virtual threads that simulate an IO-bound operation by sleeping for one second. It creates a virtual-thread-per-task executor and submits the tasks as lambdas.</p>

<pre><code>try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
    IntStream.range(0, 100_000).forEach(i -&gt; {
        executor.submit(() -&gt; {
            Thread.sleep(Duration.ofSeconds(1));
            return i;
        });
    });
}  // close() called implicitly
</code></pre>

<p>On a modest desktop system with no special configuration options, running this program takes about 1.6 seconds in a cold start, and about 1.1 seconds after warmup. If we try running this program with a cached thread pool instead, depending on how much memory is available, it may well crash with <code>OutOfMemoryError</code> before all the tasks are submitted. And if we ran it with a fixed-sized thread pool with 1000 threads, it wont crash, but Littles Law accurately predicts it will take 100 seconds to complete.</p>

<h2>Things to unlearn</h2>

<p>Because virtual threads are threads and have little new API surface of their own, there is relatively little to learn in order to use virtual threads. But there are actually quite a few things we need to <em>unlearn</em> in order to use them effectively.</p>

<h3>Everyone out of the pool</h3>

<p>The biggest thing to unlearn is the patterns surrounding thread creation. Java 5 brought with it the <code>java.util.concurrent</code> package, including the <code>ExecutorService</code> framework, and Java developers have (correctly!) learned that it is generally far better to let <code>ExecutorService</code> manage and pool threads in a policy-driven manner than to create threads directly. But when it comes to virtual threads, pooling becomes an antipattern. (We dont have to give up using <code>ExecutorService</code> or the encapsulation of policy that it provides; we can use the new factory method <a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/concurrent/Executors.html#newVirtualThreadPerTaskExecutor()"><code>Executors::newVirtualThreadPerTaskExecutor</code></a> to get an <code>ExecutorService</code> that creates a new virtual thread per task.)</p>

<p>Because the initial footprint of virtual threads is so small, creating virtual threads is dramatically cheaper in both time and memory than creating platform threads -- so much so, that our intuitions around thread creation need to be revisited. With platform threads, we are in the habit of pooling them, both to place a bound on resource utilization (because its easy to run out of memory otherwise), and to amortize the cost of thread startup over multiple requests. On the other hand, creating virtual threads is so cheap that it is actively a <em>bad</em> idea to pool them! We would gain little in terms of bounding memory usage, because the footprint is so small; it would take millions of virtual threads to use even 1G of memory. We also gain little in terms of amortizing creation overhead, because the creation cost is so small. And while it is easy to forget because pooling has historically been a forced move, it comes with its own problems, such as <code>ThreadLocal</code> pollution (where <code>ThreadLocal</code> values are left behind and accumulate in long-lived threads, causing memory leaks.)</p>

<p>If it is necessary to limit concurrency to bound consumption of some resource other than the threads themselves, such as database connections, we can use a <code>Semaphore</code> and have each virtual thread that needs the scarce resource acquire a permit.</p>

<p>Virtual threads are so lightweight that it is perfectly OK to create a virtual thread even for short-lived tasks, and counterproductive to try to reuse or recycle them. Indeed, virtual threads were designed with such short-lived tasks in mind, such as an HTTP fetch or a JDBC query.</p>

<h3>Overuse of ThreadLocal</h3>

<p>Libraries may also need to adjust their use of <code>ThreadLocal</code> in light of virtual threads. One of the ways in which <code>ThreadLocal</code> is sometimes used (some would say abused) is to cache resources that are expensive to allocate, not thread-safe, or simply to avoid repeated allocation of a commonly used object (e.g., ASM uses a <code>ThreadLocal</code> to maintain a per-thread <code>char[]</code> buffer, used for formatting operations.) When a system has a few hundred threads, the resource usage from such a pattern is usually not excessive, and it may be cheaper than reallocating each time it is needed. But the calculus changes dramatically with a few million threads that each only perform a single task, because there are potentially many more instances allocated and there is much less chance of each being reused. Using a <code>ThreadLocal</code> to amortize the creation cost of a costly resource across multiple tasks that may execute in the same thread is an ad-hoc form of pooling; if these things need to be pooled, they should be pooled explicitly.</p>

<h2>What about Reactive?</h2>

<p>A number of so-called &#34;async&#34; or &#34;reactive&#34; frameworks offer a path to fuller hardware utilization by asking developers to trade the thread-per-request style in favor of asynchronous IO, callbacks, and thread sharing. In such a model, when an activity needs to perform IO, it initiates an asynchronous operation which will invoke a callback when complete. The framework will invoke that callback on some thread, but not necessarily the same thread that initiated the operation. This means developers must break their logic down into alternating IO and computational steps which are stitched together into a sequential workflow. Because a request only uses a thread when it is actually computing something, the number of concurrent requests is not bounded by the number of threads, and so the limit on the number of threads is less likely to be the limiting factor in application throughput.</p>

<p>But, this scalability comes at a great cost -- you often have to give up some of the fundamental features of the platform and ecosystem. In the thread-per-task model, if you want to do two things sequentially, you just do them sequentially. If you want to structure your workflow with loops, conditionals, or try-catch blocks, you just do that. But in the asynchronous style, you often cannot use the sequential composition, iteration, or other features the language gives you to structure the workflow; these must be done with API calls that simulate these constructs within the asynchronous framework. An API for simulating loops or conditionals will never be as flexible or familiar as the constructs built into the language. And if we are using libraries that perform blocking operations, and have not been adapted to work in the asynchronous style, we may not be able to use these either. So we may get scalability from this model, but we have to give up on using parts of the language and ecosystem to get it.</p>

<p>These frameworks also make us give up a number of the runtime features that make developing in Java easier. Because each stage of a request might execute in a different thread, and service threads may interleave computations belonging to different requests, the usual tools we use when things go wrong, such as stack traces, debuggers, and profilers, are much less helpful than in the thread-per-task model. This programming style is at odds with the Java Platform because the frameworks unit of concurrency -- a stage of an asynchronous pipeline -- is not the same as the platforms unit of concurrency. Virtual threads, on the other hand, allow us to gain the same throughput benefit without giving up key language and runtime features.</p>

<h3>What about async/await?</h3>

<p>A number of languages have embraced <code>async</code> methods (a form of stackless coroutines) as a means of managing blocking operations, which can be called either by other <code>async</code> methods or by ordinary methods using the <code>await</code> statement. Indeed, there was some popular call to add <code>async/await</code> to Java, as <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/"><code>C#</code></a> and <a href="https://kotlinlang.org/docs/async-programming.html">Kotlin</a> have.</p>

<p>Virtual threads offer some significant advantages that <code>async/await</code> does not. Virtual threads are not just syntactic sugar for an asynchronous framework, but an overhaul to the JDK libraries to be more &#34;blocking-aware&#34;. Without that, an errant call to a synchronous blocking method from an async task will still tie up a platform thread for the duration of the call. Merely making it syntactically easier to manage asynchronous operations does not offer any scalability benefit unless you find <em>every</em> blocking operation in your system and turn it into an <code>async</code> method.</p>

<p>A more serious problem with <code>async/await</code> is the <a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">&#34;function color&#34;</a> problem, where methods are divided into two kinds -- one designed for threads and another designed for async methods -- and the two do not interoperate perfectly. This is a cumbersome programming model, often with significant duplication, and would require the new construct to be introduced into every layer of libraries, frameworks, and tooling in order to get a seamless result. Why would we implement yet another unit of concurrency -- one that is only syntax-deep -- which does not align with the threads we already have? This might be more attractive in another language, where language-runtime co-evolution was not an option, but fortunately we didnt have to make that choice.</p>

<h2>API and platform changes</h2>

<p>Virtual threads, and their related APIs, are a <a href="https://openjdk.java.net/jeps/12"><em>preview feature</em></a>. This means that the <code>--enable-preview</code> flag is needed to enable virtual thread support.</p>

<p>Virtual threads are implementations of <code>java.lang.Thread</code>, so there is no new <code>VirtualThread</code> base type. However, the <code>Thread</code> API has been extended with some new API points for creating and inspecting threads. There are new factory methods for <code>Thread::ofVirtual</code> and <a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Thread.html#ofPlatform()"><code>Thread::ofPlatform</code></a>, a new <a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Thread.Builder.html"><code>Thread.Builder</code></a> class, and <code>Thread::startVirtualThread</code> to create a start a task on a virtual thread in one go. The existing thread constructors continue to work as before, but are only for creating platform threads.</p>

<p>There are a few behavioral differences between virtual and platform threads. Virtual threads are always daemon threads; the <code>Thread::setDaemon</code> method has no effect on them. Virtual threads always have priority <code>Thread.NORM_PRIORITY</code> which cannot be changed. Virtual threads do not support some (flawed) legacy mechanisms, such as <code>ThreadGroup</code> and the <code>Thread</code> methods <code>stop</code>, <code>suspend</code>, and <code>remove</code>. <code>Thread::isVirtual</code> will reveal whether a thread is virtual or not.</p>

<p>Unlike platform thread stacks, virtual threads can be reclaimed by the garbage collector if nothing else is keeping them alive. This means that if a virtual thread is blocked, say, on <code>BlockingQueue::take</code>, but neither the virtual thread nor the queue is reachable by any platform thread, then the thread and its stack can be garbage collected. (This is safe because in this case the virtual thread can never be interrupted or unblocked.)</p>

<p>Initially, carrier threads for virtual threads are threads in a <a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/concurrent/ForkJoinPool.html"><code>ForkJoinPool</code></a> that operates in FIFO mode. The size of this pool defaults to the number of available processors. In the future, there may be more options to create custom schedulers.</p>

<h3>Preparing the JDK</h3>

<p>While virtual threads are the primary deliverable of Project Loom, there was a number of improvements behind the scenes in the JDK to ensure that applications would have a good experience using virtual threads:</p>

<ul>
	<li><strong>New socket implementations.</strong> <a href="https://openjdk.java.net/jeps/353">JEP 353</a> (Reimplement the Legacy Socket API) and <a href="https://openjdk.java.net/jeps/373">JEP 373</a> (Reimplement the Legacy DatagramSocket API) replaced the implementations of <code>Socket</code>, <code>ServerSocket</code>, and <code>DatagramSocket</code> to better support virtual threads (including making blocking methods interruptible in virtual threads.)</li>
	<li><strong>Virtual-thread-awareness.</strong> Nearly all blocking points in the JDK were made aware of virtual threads, and will unmount a virtual thread rather than blocking it.</li>
	<li><strong>Revisiting the use of <code>ThreadLocal</code>.</strong> Many uses of <code>ThreadLocal</code> in the JDK were revised in light of the expected changing usage patterns of threads.</li>
	<li><strong>Revisiting locking.</strong> Because acquiring an intrinsic lock (<code>synchronized</code>) currently pins a virtual thread to its carrier, critical intrinsic locks were replaced with <code>ReentrantLock</code>, which does not share this behavior. (The interaction between virtual threads and intrinsic locks is likely to be improved in the future.)</li>
	<li><strong>Improved thread dumps.</strong> Greater control over thread dumps, such as those produced by <code>jcmd</code>, is provided to filter out virtual threads, group related virtual threads together, or produce dumps in machine-readable formats that can be post-processed for better observability.</li>
</ul>

<h3>Related work</h3>

<p>While virtual threads are the main course of Project Loom, there are several other Loom sub-projects that further enhance virtual threads. One is a simple framework for <a href="https://openjdk.org/jeps/428"><em>structured concurrency</em></a>, which offers a powerful means to coordinate and manage cooperating groups of virtual threads. The other is <em>extent local variables</em>, which are similar to thread locals, but more suitable (and performant) for use in virtual threads. These will be the topics of upcoming articles.</p>

							
							
							









  
    

						</div></div>
  </body>
</html>
