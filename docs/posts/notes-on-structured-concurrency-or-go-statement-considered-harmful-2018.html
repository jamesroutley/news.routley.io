<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/">Original</a>
    <h1>Notes on structured concurrency, or: Go statement considered harmful (2018)</h1>
    
    <div id="readability-page-1" class="page"><div><!-- gross hack to trick pelican into including the .woff file in the
output dir
it's referenced from the .svg files, thanks to running

python ~/bin/svg-add-font-face.py "DejaVu Sans Mono" deja-vu-sans-mono.woff *.svg

I also did:

python ~/bin/svg-add-style.py "@import url('https://fonts.googleapis.com/css?family=Montserrat');" *.svg

Next time, it might be better to use - -export-text-to-path to batch
convert everything instead -->
<!-- gross hack to make the SVGs shrink down on mobile to be visible
within the viewport

Apparently overflow-x: auto would help if placed on a <div> wrapped
around the <object>, but I don't have one of those -->
<p>Every concurrency API needs a way to run code concurrently. Here&#39;s
some examples of what that looks like using different APIs:</p>
<div><pre><span></span>go myfunc();                                // Golang

pthread_create(&amp;thread_id, NULL, &amp;myfunc);  /* C with POSIX threads */

spawn(modulename, myfuncname, [])           % Erlang

threading.Thread(target=myfunc).start()     # Python with threads

asyncio.create_task(myfunc())               # Python with asyncio
</pre></div>
<p>There are lots of variations in the notation and terminology, but the
semantics are the same: these all arrange for <tt>myfunc</tt> to start
running concurrently to the rest of the program, and then return
immediately so that the parent can do other things.</p>
<p>Another option is to use callbacks:</p>
<div><pre><span></span>QObject::connect(&amp;emitter, SIGNAL(event()),        // C++ with Qt
                 &amp;receiver, SLOT(myfunc()))

g_signal_connect(emitter, &#34;event&#34;, myfunc, NULL)   /* C with GObject */

document.getElementById(&#34;myid&#34;).onclick = myfunc;  // Javascript

promise.then(myfunc, errorhandler)                 // Javascript with Promises

deferred.addCallback(myfunc)                       # Python with Twisted

future.add_done_callback(myfunc)                   # Python with asyncio
</pre></div>
<p>Again, the notation varies, but these all accomplish the same thing:
they arrange that from now on, if and when a certain event occurs,
then <tt>myfunc</tt> will run. Then once they&#39;ve set that up, they
immediately return so the caller can do other things. (Sometimes
callbacks get dressed up with fancy helpers like <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all">promise</a>
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race">combinators</a>,
or <a href="https://twistedmatrix.com/documents/current/core/howto/servers.html">Twisted-style protocols/transports</a>,
but the core idea is the same.)</p>
<p>And... that&#39;s it. Take any real-world, general-purpose concurrency
API, and you&#39;ll probably find that it falls into one or the other of
those buckets (or sometimes both, like asyncio).</p>
<p>But my new library <a href="https://trio.readthedocs.io">Trio</a> is weird. It
doesn&#39;t use either approach. Instead, if we want to run <tt>myfunc</tt> and
<tt>anotherfunc</tt> concurrently, we write something like:</p>
<div><pre><span></span><span>async</span> <span>with</span> <span>trio</span><span>.</span><span>open_nursery</span><span>()</span> <span>as</span> <span>nursery</span><span>:</span>
    <span>nursery</span><span>.</span><span>start_soon</span><span>(</span><span>myfunc</span><span>)</span>
    <span>nursery</span><span>.</span><span>start_soon</span><span>(</span><span>anotherfunc</span><span>)</span>
</pre></div>
<!-- This runs ``myfunc`` and ``anotherfunc`` concurrently, and waits for
them both to finish; if one of them raises an exception, then the
other one is cancelled and the exception propagates into the caller. -->
<p>When people first encounter this &#34;nursery&#34; construct, they tend to
find it confusing. Why is there an indented block? What&#39;s this
<tt>nursery</tt> object, and why do I need one before I can spawn a task?
Then they realize that it prevents them from using patterns they&#39;ve
gotten used to in other frameworks, and they get really annoyed. It
feels quirky and idiosyncratic and too high-level to be a basic
primitive. These are understandable reactions! But bear with me.</p>
<p><strong>In this post, I want to convince you that nurseries aren&#39;t quirky or
idiosyncratic at all, but rather a new control flow primitive that&#39;s
just as fundamental as for loops or function calls. And furthermore,
the other approaches we saw above – thread spawning and callback
registration – should be removed entirely and replaced with
nurseries.</strong></p>
<p>Sound unlikely? Something similar has actually happened before: the
<tt>goto</tt> statement was once the king of control flow. Now it&#39;s a
<a href="https://xkcd.com/292/">punchline</a>. A few languages still have
something they call <tt>goto</tt>, but it&#39;s different and far weaker than
the original <tt>goto</tt>. And most languages don&#39;t even have that. What
happened? This was so long ago that most people aren&#39;t familiar with
the story anymore, but it turns out to be surprisingly relevant. So
we&#39;ll start by reminding ourselves what a <tt>goto</tt> was, exactly, and
then see what it can teach us about concurrency APIs.</p>

<div id="what-is-a-goto-statement-anyway">
<h2><a href="#id9">What is a <tt>goto</tt> statement anyway?</a></h2>
<p>Let&#39;s review some history: Early computers were programmed using
<a href="https://en.wikipedia.org/wiki/Assembly_language">assembly language</a>, or other even
more primitive mechanisms. This kinda sucked. So in the 1950s, people
like <a href="https://en.wikipedia.org/wiki/John_Backus">John Backus</a> at
IBM and <a href="https://en.wikipedia.org/wiki/Grace_Hopper">Grace Hopper</a>
at Remington Rand started to develop languages like <a href="https://en.wikipedia.org/wiki/Fortran">FORTRAN</a> and <a href="https://en.wikipedia.org/wiki/FLOW-MATIC">FLOW-MATIC</a> (better known for its
direct successor <a href="https://en.wikipedia.org/wiki/COBOL">COBOL</a>).</p>
<p>FLOW-MATIC was very ambitious for its time. You can think of it as
Python&#39;s great-great-great-...-grandparent: the first language that
was designed for humans first, and computers second. Here&#39;s some
FLOW-MATIC code to give you a taste of what it looked like:</p>
<p>You&#39;ll notice that unlike modern languages, there&#39;s no <tt>if</tt> blocks,
loop blocks, or function calls here – in fact there&#39;s no block
delimiters or indentation at all. It&#39;s just a flat list of statements.
That&#39;s not because this program happens to be too short to use fancier
control syntax – it&#39;s because block syntax wasn&#39;t invented yet!</p>
<p>Instead, FLOW-MATIC had two options for flow control. Normally, it was
sequential, just like you&#39;d expect: start at the top and move
downwards, one statement at a time. But if you execute a special
statement like <tt>JUMP TO</tt>, then it could directly transfer control
somewhere else. For example, statement (13) jumps back to statement
(2):</p>
<p>Just like for our concurrency primitives at the beginning, there was
some disagreement about what to call this &#34;do a one-way jump&#34;
operation. Here it&#39;s <tt>JUMP TO</tt>, but the name that stuck was <tt>goto</tt>
(like &#34;go to&#34;, get it?), so that&#39;s what I&#39;ll use here.</p>
<!-- FLOW-MATIC also has conditional jumps: you'll notice the word ``IF``
appears, but it's different from a modern ``if`` statement: it checks
some condition, but then instead of having different blocks it
executes, it jumps to different places:

.. image:: {attach}flow-matic-3.svg
   :width: 440px -->
<p>Here&#39;s the complete set of <tt>goto</tt> jumps in this little program:</p>
<p>If you think this looks confusing, you&#39;re not alone! This style of
jump-based programming is something that FLOW-MATIC inherited pretty
much directly from assembly language. It&#39;s powerful, and a good fit to
how computer hardware actually works, but it&#39;s super confusing to work
with directly. That tangle of arrows is why the term &#34;spaghetti code&#34;
was invented. Clearly, we needed something better.</p>
<p>But... what is it about <tt>goto</tt> that causes all these problems? Why
are some control structures OK, and some not? How do we pick the good
ones? At the time, this was really unclear, and it&#39;s hard to fix a
problem if you don&#39;t understand it.</p>
</div>
<div id="what-is-a-go-statement-anyway">
<h2><a href="#id10">What is a <tt>go</tt> statement anyway?</a></h2>
<p>But let&#39;s hit pause on the history for a moment – everyone knows
<tt>goto</tt> was bad. What does this have to do with concurrency? Well,
consider Golang&#39;s famous <tt>go</tt> statement, used to spawn a new
&#34;goroutine&#34; (lightweight thread):</p>

<p>Can we draw a diagram of its control flow? Well, it&#39;s a little
different from either of the ones we saw above, because control
actually splits. We might draw it like:</p>
<p>Here the colors are intended to indicate that <em>both</em> paths are taken.
From the perspective of the parent goroutine (green line), control
flows sequentially: it comes in the top, and then immediately comes
out the bottom. Meanwhile, from the perspective of the child (lavender
line), control comes in the top, and then jumps over to the body of
<tt>myfunc</tt>. Unlike a regular function call, this jump is one-way: when
running <tt>myfunc</tt> we switch to a whole new stack, and the runtime
immediately forgets where we came from.</p>
<p>But this doesn&#39;t just apply to Golang. This is the flow control
diagram for <em>all</em> of the primitives we listed at the beginning of this
post:</p>
<ul>
<li>Threading libraries usually provide some sort of handle object that
lets you <tt>join</tt> the thread later – but this is an independent
operation that the language doesn&#39;t know anything about. The actual
thread spawning primitive has the control flow shown above.</li>
<li>Registering a callback is semantically equivalent to starting a
background thread that (a) blocks until some event occurs, and
then (b) runs the callback. (Though obviously the implementation is
different.) So in terms of high-level control flow, registering a
callback is essentially a <tt>go</tt> statement.</li>
<li>Futures and promises are the same too: when you call a function and
it returns a promise, that means it&#39;s scheduled the work to happen
in the background, and then given you a handle object to join the
work later (if you want). In terms of control flow semantics, this
is just like spawning a thread. Then you register callbacks on the
promise, so see the previous bullet point.</li>
</ul>
<p>This same exact pattern shows up in many, many forms: the key
similarity is that in all these cases, control flow splits, with one
side doing a one-way jump and the other side returning to the caller.
Once you know what to look for, you&#39;ll start seeing it all over the
place – it&#39;s a fun game! <a href="#id5" id="id1">[1]</a></p>
<p>Annoyingly, though, there is no standard name for this category of
control flow constructs. So just like &#34;<tt>goto</tt> statement&#34; became the
umbrella term for all the different <tt>goto</tt>-like constructs, I&#39;m
going to use &#34;<tt>go</tt> statement&#34; as a umbrella term for these. Why
<tt>go</tt>? One reason is that Golang gives us a particularly pure example
of the form. And the other is... well, you&#39;ve probably guessed where
I&#39;m going with all this. Look at these two diagrams. Notice any
similarities?</p>
<p>That&#39;s right: <strong>go statements are a form of goto statement.</strong></p>
<p>Concurrent programs are notoriously difficult to write and reason
about. So are <tt>goto</tt>-based programs. Is it possible that this might
be for some of the same reasons? In modern languages, the problems
caused by <tt>goto</tt> are largely solved. If we study how they fixed
<tt>goto</tt>, will it teach us how to make more usable concurrency APIs?
Let&#39;s find out.</p>
</div>
<div id="what-happened-to-goto">
<h2><a href="#id11">What happened to <tt>goto</tt>?</a></h2>
<p>So what is it about <tt>goto</tt> that makes it cause so many problems? In
the late 1960s, <a href="https://en.wikipedia.org/wiki/Edsger_W._Dijkstra">Edsger W. Dijkstra</a> wrote a pair of
now-famous papers that helped make this much clearer: <a href="https://scholar.google.com/scholar?cluster=15335993203437612903&amp;hl=en&amp;as_sdt=0,5">Go to statement
considered harmful</a>,
and <a href="https://www.cs.utexas.edu/~EWD/ewd02xx/EWD249.PDF">Notes on structured programming</a> (PDF).</p>
<div id="goto-the-destroyer-of-abstraction">
<h3><a href="#id12"><tt>goto</tt>: the destroyer of abstraction</a></h3>
<p>In these papers, Dijkstra was worried about the problem of how you
write non-trivial software and get it correct. I can&#39;t give them due
justice here; there&#39;s all kinds of fascinating insights. For example,
you may have heard this quote:</p>
<p><img alt="Testing can be used to show the presence of bugs, but never to show their absence!" src="https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/testing.png"/></p><p>Yep, that&#39;s from <em>Notes on structured programming</em>. But his major
concern was <em>abstraction</em>. He wanted to write programs that are too
big to hold in your head all at once. To do this, you need to treat
parts of the program like a black box – like when you see a Python
program do:</p>

<p>then you don&#39;t need to know all the details of how <tt>print</tt> is
implemented (string formatting, buffering, cross-platform differences,
...). You just need to know that it will somehow print the text you
give it, and then you can spend your energy thinking about whether
that&#39;s what you want to have happen at this point in your code.
Dijkstra wanted languages to support this kind of abstraction.</p>
<p>By this point, block syntax had been invented, and languages like
ALGOL had accumulated ~5 distinct types of control structure: they
still had sequential flow and <tt>goto</tt>:</p>
<p>And had also acquired variants on if/else, loops, and function calls:</p>
<p>You can implement these higher-level constructs using <tt>goto</tt>, and
early on, that&#39;s how people thought of them: as a convenient
shorthand. But what Dijkstra pointed out is that if you look at these
diagrams, there&#39;s a big difference between <tt>goto</tt> and the rest. For
everything except <tt>goto</tt>, flow control comes in the top → [stuff
happens] → flow control comes out the bottom. We might call this the
&#34;black box rule&#34;: if a control structure has this shape, then in
contexts where you don&#39;t care about the details of what happens
internally, you can ignore the [stuff happens] part, and treat the
whole thing as regular sequential flow. And even better, this is also
true of any code that&#39;s <em>composed</em> out of those pieces. When I look at
this code:</p>

<p>I don&#39;t have to go read the definition of <tt>print</tt> and all its
transitive dependencies just to figure out how the control flow works.
Maybe inside <tt>print</tt> there&#39;s a loop, and inside the loop there&#39;s an
if/else, and inside the if/else there&#39;s another function call... or
maybe it&#39;s something else. It doesn&#39;t really matter: I know control
will flow into <tt>print</tt>, the function will do its thing, and then
eventually control will come back to the code I&#39;m reading.</p>
<p>It may seem like this is obvious, but if you have a language with
<tt>goto</tt> – a language where functions and everything else are built on
top of <tt>goto</tt>, and <tt>goto</tt> can jump anywhere, at any time – then
these control structures aren&#39;t black boxes at all! If you have a
function, and inside the function there&#39;s a loop, and inside the loop
there&#39;s an if/else, and inside the if/else there&#39;s a <tt>goto</tt>... then
that <tt>goto</tt> could send the control anywhere it wants. Maybe control
will suddenly return from another function entirely, one you haven&#39;t
even called yet. You don&#39;t know!</p>
<p>And this breaks abstraction: it means that <em>every function call is
potentially a</em> <tt>goto</tt> <em>statement in disguise, and the only way to
know is to keep the entire source code of your system in your head at
once.</em> As soon as <tt>goto</tt> is in your language, you stop being able do
local reasoning about flow control. That&#39;s <em>why</em> <tt>goto</tt> leads to
spaghetti code.</p>
<p>And now that Dijkstra understood the problem, he was able to solve it.
Here&#39;s his revolutionary proposal: we should stop thinking of
if/loops/function calls as shorthands for <tt>goto</tt>, but rather as
fundamental primitives in their own rights – and we should remove
<tt>goto</tt> entirely from our languages.</p>
<p>From here in 2018, this seems obvious enough. But have you seen how
programmers react when you try to take away their toys because they&#39;re
not smart enough to use them safely? Yeah, some things never change.
In 1969, this proposal was <em>incredibly controversial</em>. <a href="https://en.wikipedia.org/wiki/Donald_Knuth">Donald Knuth</a> <a href="https://scholar.google.com/scholar?cluster=17147143327681396418&amp;hl=en&amp;as_sdt=0,5">defended</a>
<tt>goto</tt>. People who had become experts on writing code with <tt>goto</tt>
quite reasonably resented having to basically learn how to program
again in order to express their ideas using the newer, more
constraining constructs. And of course it required building a whole
new set of languages.</p>
<div>
<p><img alt="On the left, a photo of a snarling wolf. On the right, a photo of a grumpy bulldog." src="https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/wolf-and-bulldog.jpg"/></p><p>Left: A traditional <tt>goto</tt>. Right: A domesticated <tt>goto</tt>, as
seen in C, C#, Golang, etc. The inability to cross function
boundaries means it can still pee on your shoes, but it probably
won&#39;t rip your face off.</p>
</div>
<p>In the end, modern languages are a bit less strict about this than
Dijkstra&#39;s original formulation. They&#39;ll let you break out of multiple
nested structures at once using constructs like <tt>break</tt>,
<tt>continue</tt>, or <tt>return</tt>. But fundamentally, they&#39;re all designed
around Dijkstra&#39;s idea; even these constructs that push the boundaries
do so only in strictly limited ways. In particular, functions – which
are the fundamental tool for wrapping up control flow inside a black
box – are considered inviolate. You can&#39;t <tt>break</tt> out of one
function and into another, and a <tt>return</tt> can take you out of the
current function, but no further. Whatever control flow shenanigans a
function gets up to internally, other functions don&#39;t have to care.</p>
<p>This even extends to <tt>goto</tt> itself. You&#39;ll find a few languages that
still have something they call <tt>goto</tt>, like C, C#, Golang, ... but
they&#39;ve added heavy restrictions. At the very least, they won&#39;t let
you jump out of one function body and into another. Unless you&#39;re
working in assembly <a href="#id6" id="id2">[2]</a>, the classic, unrestricted <tt>goto</tt> is gone.
Dijkstra won.</p>
</div>
<div id="a-surprise-benefit-removing-goto-statements-enables-new-features">
<h3><a href="#id13">A surprise benefit: removing <tt>goto</tt> statements enables new features</a></h3>
<p>And once <tt>goto</tt> disappeared, something interesting happened:
language designers were able to start adding features that depend on
control flow being structured.</p>
<p>For example, Python has some nice syntax for resource cleanup: the
<tt>with</tt> statement. You can write things like:</p>
<div><pre><span></span><span># Python</span>
<span>with</span> <span>open</span><span>(</span><span>&#34;my-file&#34;</span><span>)</span> <span>as</span> <span>file_handle</span><span>:</span>
    <span>...</span>
</pre></div>
<p>and it guarantees that the file will be open during the <tt>...</tt> code,
but then closed immediately afterward. Most modern languages have some
equivalent (RAII, <tt>using</tt>, try-with-resource, <tt>defer</tt>, ...). And
they all assume that control flows in an orderly, structured way. If
we used <tt>goto</tt> to jump into the middle of our <tt>with</tt> block... what
would that even do? Is the file open or not? What if we jumped out
again, instead of exiting normally? Would the file get closed? This
feature just doesn&#39;t work in any coherent way if your language has
<tt>goto</tt> in it.</p>
<p>Error handling has a similar problem: when something goes wrong, what
should your code do? Often the answer is to pass the buck up the stack
to your code&#39;s caller, let them figure out how to deal with it. Modern
languages have constructs specifically to make this easier, like
exceptions, or other forms of <a href="https://doc.rust-lang.org/std/result/index.html#the-question-mark-operator-">automatic error propagation</a>.
But your language can only provide this help if it <em>has</em> a stack, and
a reliable concept of &#34;caller&#34;. Look again at the control-flow
spaghetti in our FLOW-MATIC program and imagine that in the middle of
that it tried to raise an exception. Where would it even go?</p>
</div>
<div id="goto-statements-not-even-once">
<h3><a href="#id14"><tt>goto</tt> statements: not even once</a></h3>
<p>So <tt>goto</tt> – the traditional kind that ignores function boundaries –
isn&#39;t just the regular kind of bad feature, the kind that&#39;s hard to
use correctly. If it were, it might have survived – lots of bad
features have. But it&#39;s much worse.</p>
<blockquote>
<!-- I mean, sure, if you do have to use it,
then there are better and worse ways to do that, and it's probably a
good idea to build better tools on top and then use those as much as
possible. But this doesn't really fix the problem. -->
</blockquote>
<p>Even if you don&#39;t use <tt>goto</tt> yourself, merely having it as an option
in your language makes <em>everything</em> harder to use. Whenever you start
using a third-party library, you can&#39;t treat it as a black box – you
have to go read through it all to find out which functions are regular
functions, and which ones are idiosyncratic flow control constructs in
disguise. This is a serious obstacle to local reasoning. And you lose
powerful language features like reliable resource cleanup and
automatic error propagation. Better to remove <tt>goto</tt> entirely, in
favor of control flow constructs that follow the &#34;black box&#34; rule.</p>
</div>
</div>
<div id="go-statement-considered-harmful">
<h2><a href="#id15"><tt>go</tt> statement considered harmful</a></h2>
<p>So that&#39;s the history of <tt>goto</tt>. Now, how much of this applies to
<tt>go</tt> statements? Well... basically, all of it! The analogy turns out
to be shockingly exact.</p>
<p><strong>Go statements break abstraction.</strong> Remember how we said that if our
language allows <tt>goto</tt>, then any function might be a <tt>goto</tt> in
disguise? In most concurrency frameworks, <tt>go</tt> statements cause the
exact same problem: whenever you call a function, it might or might
not spawn some background task. The function seemed to return, but is
it still running in the background? There&#39;s no way to know without
reading all its source code, transitively. When will it finish? Hard
to say. If you have <tt>go</tt> statements, then functions are no longer
black boxes with respect to control flow. In my <a href="https://vorpus.org/blog/some-thoughts-on-asynchronous-api-design-in-a-post-asyncawait-world/">first post on
concurrency APIs</a>,
I called this &#34;violating causality&#34;, and found that it was the root
cause of many common, real-world issues in programs using asyncio and
Twisted, like problems with backpressure, problems with shutting down
properly, and so forth.</p>
<p><strong>Go statements break automatic resource cleanup.</strong> Let&#39;s look again
at that <tt>with</tt> statement example:</p>
<div><pre><span></span><span># Python</span>
<span>with</span> <span>open</span><span>(</span><span>&#34;my-file&#34;</span><span>)</span> <span>as</span> <span>file_handle</span><span>:</span>
    <span>...</span>
</pre></div>
<p>Before, we said that we were &#34;guaranteed&#34; that the file will be open
while the <tt>...</tt> code is running, and then closed afterwards. But
what if the <tt>...</tt> code spawns a background task? Then our guarantee
is lost: the operations that <em>look</em> like they&#39;re inside the <tt>with</tt>
block might actually keep running <em>after</em> the <tt>with</tt> block ends, and
then crash because the file gets closed while they&#39;re still using it.
And again, you can&#39;t tell from local inspection; to know if this is
happening you have to go read the source code to all the functions
called inside the <tt>...</tt> code.</p>
<p>If we want this code to work properly, we need to somehow keep track
of any background tasks, and manually arrange for the file to be
closed only when they&#39;re finished. It&#39;s doable – unless we&#39;re using
some library that doesn&#39;t provide any way to get notified when the
task is finished, which is distressingly common (e.g. because it
doesn&#39;t expose any task handle that you can join on). But even in the
best case, the unstructured control flow means the language can&#39;t help
us. We&#39;re back to implementing resource cleanup by hand, like in the
bad old days.</p>
<p><strong>Go statements break error handling.</strong> Like we discussed above,
modern languages provide powerful tools like exceptions to help us
make sure that errors are detected and propagated to the right place.
But these tools depend on having a reliable concept of &#34;the current
code&#39;s caller&#34;. As soon as you spawn a task or register a callback,
that concept is broken. As a result, every mainstream concurrency
framework I know of simply gives up. If an error occurs in a
background task, and you don&#39;t handle it manually, then the runtime
just... drops it on the floor and crosses its fingers that it wasn&#39;t
too important. If you&#39;re lucky it might print something on the
console. (The only other software I&#39;ve used that thinks &#34;print
something and keep going&#34; is a good error handling strategy is grotty
old Fortran libraries, but here we are.) Even Rust – the language
voted Most Obsessed With Threading Correctness by its high school
class – is guilty of this. If a background thread panics, Rust
<a href="https://doc.rust-lang.org/std/thread/">discards the error and hopes for the best</a>.</p>
<p>Of course you <em>can</em> handle errors properly in these systems, by
carefully making sure to join every thread, or by building your own
error propagation mechanism like <a href="https://twistedmatrix.com/documents/current/core/howto/defer.html#visual-explanation">errbacks in Twisted</a>
or <a href="https://hackernoon.com/promises-and-error-handling-4a11af37cb0e">Promise.catch in Javascript</a>.
But now you&#39;re writing an ad-hoc, fragile reimplementation of the
features your language already has. You&#39;ve lost useful stuff like
&#34;tracebacks&#34; and &#34;debuggers&#34;. All it takes is forgetting to call
<tt>Promise.catch</tt> once and suddenly you&#39;re dropping serious errors on
the floor without even realizing. And even if you do somehow solve all
these problems, you&#39;ll still end up with two redundant systems for
doing the same thing.</p>
<div id="go-statements-not-even-once">
<h3><a href="#id16"><tt>go</tt> statements: not even once</a></h3>
<p>Just like <tt>goto</tt> was the obvious primitive for the first practical
high-level languages, <tt>go</tt> was the obvious primitive for the first
practical concurrency frameworks: it matches how the underlying
schedulers actually work, and it&#39;s powerful enough to implement any
other concurrent flow pattern. But again like <tt>goto</tt>, it breaks
control flow abstractions, so that merely having it as an option in
your language makes everything harder to use.</p>
<p>The good news, though, is that these problems can all be solved:
Dijkstra showed us how! We need to:</p>
<ul>
<li>Find a replacement for <tt>go</tt> statements that has similar power, but
follows the &#34;black box rule&#34;,</li>
<li>Build that new construct into our concurrency framework as a
primitive, and don&#39;t include any form of <tt>go</tt> statement.</li>
</ul>
<p>And that&#39;s what Trio did.</p>
</div>
</div>
<div id="nurseries-a-structured-replacement-for-go-statements">
<h2><a href="#id17">Nurseries: a structured replacement for <tt>go</tt> statements</a></h2>
<p>Here&#39;s the core idea: every time our control splits into multiple
concurrent paths, we want to make sure that they join up again. So for
example, if we want to do three things at the same time, our control
flow should look something like this:</p>
<p>Notice that this has just one arrow going in the top and one coming
out the bottom, so it follows Dijkstra&#39;s black box rule. Now, how can
we turn this sketch into a concrete language construct? There are some
existing constructs that meet this constraint, but (a) my proposal is
slightly different than all the ones I&#39;m aware of and has advantages
over them (especially in the context of wanting to make this a
standalone primitive), and (b) the concurrency literature is vast and
complicated, and trying to pick apart all the history and tradeoffs
would totally derail the argument, so I&#39;m going to defer that to a
separate post. Here, I&#39;ll just focus on explaining my solution. But
please be aware that I&#39;m not claiming to have like, invented the idea
of concurrency or something, this draws inspiration from many sources,
I&#39;m standing on the shoulders of giants, etc. <a href="#id7" id="id3">[3]</a></p>
<p>Anyway, here&#39;s how we&#39;re going to do it: first, we declare that a
parent task cannot start any child tasks unless it first creates a
place for the children to live: a <em>nursery</em>. It does this by opening a
<em>nursery block</em>; in Trio, we do this using Python&#39;s <tt>async with</tt>
syntax:</p>
<p>Opening a nursery block automatically creates an object representing
this nursery, and the <tt>as nursery</tt> syntax assigns this object to the
variable named <tt>nursery</tt>. Then we can use the nursery object&#39;s
<tt>start_soon</tt> method to start concurrent tasks: in this case, one
task calling the function <tt>myfunc</tt>, and another calling the function
<tt>anotherfunc</tt>. Conceptually, these tasks execute <em>inside</em> the
nursery block. In fact, it&#39;s often convenient to think of the code
written inside the nursery block as being an initial task that&#39;s
automatically started when the block is created.</p>
<p>Crucially, the nursery block doesn&#39;t exit until all the tasks inside
it have exited – if the parent task reaches the end of the block
before all the children are finished, then it pauses there and waits
for them. The nursery automatically expands to hold the children.</p>
<p>Here&#39;s the control flow: you can see how it matches the basic pattern
we showed at the beginning of this section:</p>
<p>This design has a number of consequences, not all of which are
obvious. Let&#39;s think through some of them.</p>
<div id="nurseries-preserve-the-function-abstraction">
<h3><a href="#id18">Nurseries preserve the function abstraction.</a></h3>
<p>The fundamental problem with <tt>go</tt> statements is that when you call a
function, you don&#39;t know whether it&#39;s going to spawn some background
task that keeps running after it&#39;s finished. With nurseries, you don&#39;t
have to worry about this: any function can open a nursery and run
multiple concurrent tasks, but the function can&#39;t return until they&#39;ve
all finished. So when a function does return, you know it&#39;s really
done.</p>
</div>
<div id="nurseries-support-dynamic-task-spawning">
<h3><a href="#id19">Nurseries support dynamic task spawning.</a></h3>
<p>Here&#39;s a simpler primitive that would also satisfy our flow control
diagram above. It takes a list of thunks, and runs them all
concurrently:</p>
<div><pre><span></span><span>run_concurrently</span><span>([</span><span>myfunc</span><span>,</span> <span>anotherfunc</span><span>])</span>
</pre></div>
<p>But the problem with this is that you have to know up front the
complete list of tasks you&#39;re going to run, which isn&#39;t always true.
For example, server programs generally have <tt>accept</tt> loops, that
take incoming connections and start a new task to handle each of them.
Here&#39;s a minimal <tt>accept</tt> loop in Trio:</p>
<div><pre><span></span><span>async</span> <span>with</span> <span>trio</span><span>.</span><span>open_nursery</span><span>()</span> <span>as</span> <span>nursery</span><span>:</span>
    <span>while</span> <span>True</span><span>:</span>
        <span>incoming_connection</span> <span>=</span> <span>await</span> <span>server_socket</span><span>.</span><span>accept</span><span>()</span>
        <span>nursery</span><span>.</span><span>start_soon</span><span>(</span><span>connection_handler</span><span>,</span> <span>incoming_connection</span><span>)</span>
</pre></div>
<p>With nurseries, this is trivial, but implementing it using
<tt>run_concurrently</tt> would be <em>much</em> more awkward. And if you wanted
to, it would be easy to implement <tt>run_concurrently</tt> on top of
nurseries – but it&#39;s not really necessary, since in the simple cases
<tt>run_concurrently</tt> can handle, the nursery notation is just as
readable.</p>
</div>
<div id="there-is-an-escape">
<h3><a href="#id20">There is an escape.</a></h3>
<p>The nursery object also gives us an escape hatch. What if you really
do need to write a function that spawns a background task, where the
background task outlives the function itself? Easy: pass the function
a nursery object. There&#39;s no rule that only the code directly inside
the <tt>async with open_nursery()</tt> block can call
<tt>nursery.start_soon</tt> – so long as the nursery block remains open
<a href="#id8" id="id4">[4]</a>, then anyone who acquires a reference to the nursery object gets
the capability of spawning tasks into that nursery. You can pass it in
as a function argument, send it through a queue, whatever.</p>
<p>In practice, this means that you can write functions that &#34;break the
rules&#34;, but within limits:</p>
<ul>
<li>Since nursery objects have to be passed around explicitly, you can
immediately identify which functions violate normal flow control by
looking at their call sites, so local reasoning is still possible.</li>
<li>Any tasks the function spawns are still bound by the lifetime of the
nursery that was passed in.</li>
<li>And the calling code can only pass in nursery objects that it itself
has access to.</li>
</ul>
<p>So this is still very different from the traditional model where any
code can at any moment spawn a background task with unbounded
lifetime.</p>
<p>One place this is useful is in the proof that nurseries have
equivalent expressive power to <tt>go</tt> statements, but this post is
already long enough so I&#39;ll leave that for another day.</p>
</div>
<div id="you-can-define-new-types-that-quack-like-a-nursery">
<h3><a href="#id21">You can define new types that quack like a nursery.</a></h3>
<p>The standard nursery semantics provide a solid foundation, but
sometimes you want something different. Perhaps you&#39;re envious of
Erlang and its supervisors, and want to define a nursery-like class
that handles exceptions by restarting the child task. That&#39;s totally
possible, and to your users, it&#39;ll look just like a regular nursery:</p>
<div><pre><span></span><span>async</span> <span>with</span> <span>my_supervisor_library</span><span>.</span><span>open_supervisor</span><span>()</span> <span>as</span> <span>nursery_alike</span><span>:</span>
    <span>nursery_alike</span><span>.</span><span>start_soon</span><span>(</span><span>...</span><span>)</span>
</pre></div>
<p>If you have a function that takes a nursery as an argument, then you
can pass it one of these instead to control the error-handling policy
for the tasks it spawns. Pretty nifty. But there is one subtlety here
that pushes Trio towards different conventions than asyncio or some
other libraries: it means that <tt>start_soon</tt> has to take a function,
not a coroutine object or a <tt>Future</tt>. (You can call a function
multiple times, but there&#39;s no way to restart a coroutine object or a
<tt>Future</tt>.) I think this is the better convention anyway for a number
of reasons (especially since Trio doesn&#39;t even have <tt>Future</tt>s!),
but still, worth mentioning.</p>
</div>
<div id="no-really-nurseries-always-wait-for-the-tasks-inside-to-exit">
<h3><a href="#id22">No, really, nurseries <em>always</em> wait for the tasks inside to exit.</a></h3>
<p>It&#39;s also worth talking about how task cancellation and task joining
interact, since there are some subtleties here that could – if handled
incorrectly – break the nursery invariants.</p>
<p>In Trio, it&#39;s possible for code to receive a cancellation request at
any time. After a cancellation is requested, then the next time the
code executes a &#34;checkpoint&#34; operation (<a href="https://trio.readthedocs.io/en/latest/reference-core.html#checkpoints">details</a>),
a <tt>Cancelled</tt> exception is raised. This means that there&#39;s a gap
between when a cancellation is <em>requested</em> and when it actually
<em>happens</em> – it might be a while before the task executes a checkpoint,
and then after that the exception has to unwind the stack, run cleanup
handlers, etc. When this happens, the nursery always waits for the
full cleanup to happen. We <em>never</em> terminate a task without giving it
a chance to run cleanup handlers, and we <em>never</em> leave a task to run
unsupervised outside of the nursery, even if it&#39;s in the process of
being cancelled.</p>
</div>
<div id="automatic-resource-cleanup-works">
<h3><a href="#id23">Automatic resource cleanup works.</a></h3>
<p>Because nurseries follow the black box rule, they make <tt>with</tt> blocks
work again. There&#39;s no chance that, say, closing a file at the end of
a <tt>with</tt> block will accidentally break a background task that&#39;s
still using that file.</p>
</div>
<div id="automated-error-propagation-works">
<h3><a href="#id24">Automated error propagation works.</a></h3>
<p>As noted above, in most concurrency systems, unhandled errors in
background tasks are simply discarded. There&#39;s literally nothing else
to do with them.</p>
<p>In Trio, since every task lives inside a nursery, and every nursery is
part of a parent task, and parent tasks are required to wait for the
tasks inside the nursery... we <em>do</em> have something we can do with
unhandled errors. If a background task terminates with an exception,
we can rethrow it in the parent task. The intuition here is that a
nursery is something like a &#34;concurrent call&#34; primitive: we can think
of our example above as calling <tt>myfunc</tt> and <tt>anotherfunc</tt> at the
same time, so our call stack has become a tree. And exceptions
propagate up this call tree towards the root, just like they propagate
up a regular call stack.</p>
<p>There is one subtlety here though: when we re-raise an exception in
the parent task, it will start propagating in the parent task.
Generally, that means that the parent task will exit the nursery
block. But we&#39;ve already said that the parent task cannot leave the
nursery block while there are still child tasks running. So what do we
do?</p>
<p>The answer is that when an unhandled exception occurs in a child, Trio
immediately cancels all the other tasks in the same nursery, and then
waits for them to finish before re-raising the exception. The
intuition here is that exceptions cause the stack to unwind, and if we
want to unwind past a branch point in our stack tree, we need to
unwind the other branches, by cancelling them.</p>
<p>This does mean though that if you want to implement nurseries in your
language, you may need some kind of integration between the nursery
code and your cancellation system. This might be tricky if you&#39;re
using a language like C# or Golang where cancellation is usually
managed through manual object passing and convention, or (even worse)
one that doesn&#39;t have a generic cancellation mechanism.</p>
</div>
<div id="a-surprise-benefit-removing-go-statements-enables-new-features">
<h3><a href="#id25">A surprise benefit: removing <tt>go</tt> statements enables new features</a></h3>
<p>Eliminating <tt>goto</tt> allowed previous language designers to make
stronger assumptions about the structure of programs, which enabled
new features like <tt>with</tt> blocks and exceptions; eliminating <tt>go</tt>
statements has a similar effect. For example:</p>
<ul>
<li>Trio&#39;s cancellation system is easier to use and more reliable than
competitors, because it can assume that tasks are nested in a
regular tree structure; see <a href="https://vorpus.org/blog/timeouts-and-cancellation-for-humans/">Timeouts and cancellation for humans</a>
for a full discussion.</li>
<li>Trio is the only Python concurrency library where control-C works
the way Python developers expect (<a href="https://vorpus.org/blog/control-c-handling-in-python-and-trio/">details</a>).
This would be impossible without nurseries providing a reliable
mechanism for propagating exceptions.</li>
</ul>
</div>
</div>
<div id="nurseries-in-practice">
<h2><a href="#id26">Nurseries in practice</a></h2>
<p>So that&#39;s the theory. How&#39;s it work in practice?</p>
<p>Well... that&#39;s an empirical question: you should try it and find out!
But seriously, we just won&#39;t know for sure until lots of people have
pounded on it. At this point I&#39;m pretty confident that the foundation
is sound, but maybe we&#39;ll realize we need to make some tweaks, like
how the early structured programming advocates eventually backed off
from eliminating <tt>break</tt> and <tt>continue</tt>.</p>
<p>And if you&#39;re an experienced concurrent programmer who&#39;s just learning
Trio, then you should expect to find it a bit rocky at times. You&#39;ll
have to <a href="https://stackoverflow.com/questions/48282841/in-trio-how-can-i-have-a-background-task-that-lives-as-long-as-my-object-does">learn new ways to do things</a>
– just like programmers in the 1970s found it challenging to learn how
to write code without <tt>goto</tt>.</p>
<p>But of course, that&#39;s the point. As Knuth wrote (<a href="https://scholar.google.com/scholar?cluster=17147143327681396418&amp;hl=en&amp;as_sdt=0,5">Knuth,
1974</a>,
p. 275):</p>
<blockquote>
Probably the worst mistake any one can make with respect to the
subject of <strong>go to</strong> statements is to assume that &#34;structured
programming&#34; is achieved by writing programs as we always have and
then eliminating the <strong>go to</strong>&#39;s. Most <strong>go to</strong>&#39;s shouldn&#39;t be
there in the first place! What we really want is to conceive of our
program in such a way that we rarely even <em>think</em> about <strong>go to</strong>
statements, because the real need for them hardly ever arises. The
language in which we express our ideas has a strong influence on
our thought processes. Therefore, Dijkstra asks for more new
language features – structures which encourage clear thinking – in
order to avoid the <strong>go to</strong>&#39;s temptations towards complications.</blockquote>
<p>And so far, that&#39;s been my experience with using nurseries: they
encourage clear thinking. They lead to designs that are more robust,
easier to use, and just better all around. And the limitations
actually make it easier to solve problems, because you spend less time
being tempted towards unnecessary complications. Using Trio has, in a
very real sense, taught me to be a better programmer.</p>
<p>For example, consider the Happy Eyeballs algorithm (<a href="https://tools.ietf.org/html/rfc8305">RFC 8305</a>), which is a simple
concurrent algorithm for speeding up the establishment of TCP
connections. Conceptually, the algorithm isn&#39;t complicated – you race
several connection attempts against each other, with a staggered start
to avoid overloading the network. But if you look at <a href="https://github.com/twisted/twisted/compare/trunk...glyph:statemachine-hostnameendpoint">Twisted&#39;s best
implementation</a>,
it&#39;s almost 600 lines of Python, and still has <a href="https://twistedmatrix.com/trac/ticket/9345">at least one logic
bug</a>. The equivalent in
Trio is more than <strong>15x</strong> shorter. More importantly, using Trio I was
able to write it in minutes instead of months, and I got the logic
correct on my first try. I never could have done this in any other
framework, even ones where I have much more experience. For more
details, you can <a href="https://www.youtube.com/watch?v=i-R704I8ySE">watch my talk at Pyninsula last month</a>. Is this typical?
Time will tell. But it&#39;s certainly promising.</p>
</div>
<div id="conclusion">
<h2><a href="#id27">Conclusion</a></h2>
<p>The popular concurrency primitives – <tt>go</tt> statements, thread
spawning functions, callbacks, futures, promises, ... they&#39;re all
variants on <tt>goto</tt>, in theory and in practice. And not even the
modern domesticated <tt>goto</tt>, but the old-testament fire-and-brimstone
<tt>goto</tt>, that could leap across function boundaries. These primitives
are dangerous even if we don&#39;t use them directly, because they
undermine our ability to reason about control flow and compose complex
systems out of abstract modular parts, and they interfere with useful
language features like automatic resource cleanup and error
propagation. Therefore, like <tt>goto</tt>, they have no place in a modern
high-level language.</p>
<p>Nurseries provide a safe and convenient alternative that preserves the
full power of your language, enables powerful new features (as
demonstrated by Trio&#39;s cancellation scopes and control-C handling),
and can produce dramatic improvements in readability, productivity,
and correctness.</p>
<p>Unfortunately, to fully capture these benefits, we do need to remove
the old primitives entirely, and this probably requires building new
concurrency frameworks from scratch – just like eliminating <tt>goto</tt>
required designing new languages. But as impressive as FLOW-MATIC was
for its time, most of us are glad that we&#39;ve upgraded to something
better. I don&#39;t think we&#39;ll regret switching to nurseries either, and
Trio demonstrates that this is a viable design for practical,
general-purpose concurrency frameworks.</p>
</div>



</div></div>
  </body>
</html>
