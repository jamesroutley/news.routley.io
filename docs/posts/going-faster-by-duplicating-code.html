<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://voidstar.tech/code_duplication/">Original</a>
    <h1>Going Faster by Duplicating Code</h1>
    
    <div id="readability-page-1" class="page">




<p>Functions often do work with information not known until run time:</p>

<div>
  <pre><code><span>// scale some values by a common factor</span>
void multiply(vector<int>&amp; Values, const int Factor){

  for( auto&amp; V : Values ) { V = <span>V * Factor</span>; } <span>imul edx, esi</span>
}</int></code></pre>
</div>

<p>This function doesn&#39;t know the value being multiplied until it is called.
The compiler (gcc, O2) emits a generic integer multiply instruction in its loop
body.</p>

<p>Sometimes we know a better way to handle certain cases, and act on this
explicitly:</p>

<div>
  <pre><code><span>// same function signature as before</span>
void multiply(vector<int>&amp; Values, const int Factor){

  if( <span>Factor == 2</span> ){
    <span>// multiplying by two is the same as shifting by one</span>

    for( auto&amp; V : Values ) { V = <span>V &lt;&lt; 1</span>; } <span>sal [rax]</span>
  } else {
    <span>// default implementation for any value</span>

    for( auto&amp; V : Values ) { V = <span>V * Factor</span>; } <span>imul edx, esi</span>
  }
}</int></code></pre>
</div>

<p>The function does the same work, but will use a faster method for certain
arguments, without users having to opt-in to a better version.</p>

<p>The condition check has to be up front, outside the loop. Checks within
loops are less helpful or even harmful:</p>

<div>
  <pre><code>for( auto&amp; V : Values ){
  if( <span>Factor == 2</span> ){
    V = <span>V &lt;&lt; 1</span>;
  } else {
    V = <span>V * Factor</span>;
  }
}</code></pre>
</div>

<p>This example is contrived, but the pattern arises naturally, because our
default thinking is first of algorithmic iteration, then of case handling.
Last-minute decision-making thus creeps into code.

</p><p>Compilers try to hoist constant conditions outside of
loops but they&#39;re bad at it. Even in the trivial example above, on -O2 gcc does
a redundant check with every loop iteration.</p>

<p>Using precondition checks to dispatch to different implementations at run
time is great if you know a certain technique applies. But the observation that
motivates this post is <b>adding special cases can improve code generation even
when the implementation in each branch is identical:</b>

</p><div>
  <pre><code>void multiply(vector<int>&amp; Values, const int Factor){

  if( <span>Factor == 2</span> ){
    <span>// no special handling; just multiplies</span>
    for( auto&amp; V : Values ) { V = <span>V * Factor</span>; } <span>sal [rax]</span>
  } else {
    <span>// identical loop body to above</span>
    for( auto&amp; V : Values ) { V = <span>V * Factor</span>; } <span>imul edx, esi</span>
  }
}</int></code></pre>
</div>

<p>View these examples on <a href="https://godbolt.org/z/Pq5nz6Mfo" target="blank">Compiler Explorer</a></p>

<p>All we did was copy the source code, but the compiler has converted the
multiply to a shift for us in the appropriate branch.</p>


<p>I emphasize this is not a static branch (<code>if constexpr</code>),
constant value, or call-site specific optimization. It is a regular run time if
statement, branching on the value of an opaque function argument. But its
existence has added an opportunity at compile time to exploit information we
anticipate to have at run time.</p>

<p>Compilers will try to add their own fast path handling to your code to take
advantage of run time information, such as for autovectorization. But compilers
lack knowledge of the distribution of expected values for your application, and
are limited to generic checks likely to pay off. <b>By adding a branch
ourselves, we have brought into existence a code path in which certain
conditions will always be true</b>, that can be optimized accordingly.</p>

<p>An advantage of this method is that we&#39;re giving the compiler an opportunity
to do something better without forcing it. Programmers often put in speed hacks
based on performance knowledge which is outdated or inapplicable to the target
platform. Separating cases lets the programmer supply their high-level knowledge
about what values are likely to be encountered, which the compiler can optimize
to the platform based on its low-level information.</p>

<p>For this to work, the value being used in the if statement should be
  directly used later in the branch. So <code>if( X == 42 )</code> provides an
  easy optimization opportunity if <code>X</code> is directly used later. But
  the compiler often does nothing if there&#39;s any indirection - <code>if( X*2 ==
  84)</code> does not provide the same cue to do something useful.</p>

<p>For values known at compile time, we could get a specialized implementation
for each use with a template. But templates have their drawbacks. We might not
  want separate code generation for every combination of parameters, only a few
  cases we detect. Properties that are unchanging at run time might not be part
  of an object&#39;s static information for a template to access. Templates in
  headers for an API are frustrating to use compared single functions. For
  these reasons it is often preferred to have one function which dispatches to
  different implementations internally to take advantage of run time
  knowledge.</p>


<h2>Motivating example: Integer upscaling</h2>

<p>I came across this technique when speeding up a simple nearest-neighbor
scaling function, which composits one 2D buffer of dynamic size into another.
Any combination of source/destination size is supported, but a common usage
is upscaling small images by an integer ratio:</p>

<video src="upscale_example.webm" autoplay="" loop="" muted=""></video>

<p>Starting with a naive version assembled from convenience functions, I gained
speed from manual inlining and hoisting, and specializing for an integer ratio
upscale. But it was still annoyingly slow, particularly when filling a larger
window at the highest multiple.</p>

<p>Base integer upscale implementation</p>
<p>It is not necessary you follow this closely.</p>
<div>
<div id="upscale_basic">


<pre><code>void comp_nearest(buffer<rgba>&amp; <span>Dest</span>, const buffer<rgba>&amp; <span>Src</span>){

  const auto <span>d_h</span> = <span>Dest</span>.height();
  const auto <span>d_w</span> = <span>Dest</span>.width();
  const auto <span>s_w</span> = <span>Src</span>.width();
  const auto <span>s_h</span> = <span>Src</span>.height();

  if(     (<span>d_h</span> &gt; <span>s_h</span>) &amp;&amp;  (<span>d_w</span> &gt; <span>s_w</span>)      <span>// we are upscaling, and</span>
      &amp;&amp; !(<span>d_h</span> % <span>s_h</span>) &amp;&amp; !(<span>d_w</span> % <span>s_w</span>) ) {  <span>// integer ratio</span>

    const int <span>ratio_y</span> = <span>d_h</span>/<span>s_h</span>;
    const int <span>ratio_x</span> = <span>d_w</span>/<span>s_w</span>;

    <span>// destination buffer, iterated sequentially</span>
    rgba* <span>d_buf</span> = &amp;<span>Dest</span>.at(0,0);
    <span>// start of current row in source</span>
    const rgba* <span>s_buf</span> = &amp;<span>Src</span>.at(0,0);

    <span>// number of times we have used the current source row</span>
    int <span>sc_y</span> = 0;

    for (int <span>d_y</span> = 0; <span>d_y</span> &lt; <span>d_h</span>; ++<span>d_y</span>){

      <span>// copy of pointer to advance through the current row in the source</span>
      const rgba* <span>s_row_iter</span> = <span>s_buf</span>;

      <span>// number of times we have used the current source pixel</span>
      int <span>sc_x</span> = 0;

      for (int <span>d_x</span> = 0; <span>d_x</span> &lt; <span>d_w</span>; ++<span>d_x</span>){

        <span>// do not advance src pointer immediately because
        // we are using it multiple times</span>
        *(<span>d_buf</span>++) = *(<span>s_row_iter</span>);

        <span>// advance to next pixel in source row if we have
        // used it a sufficient number of times</span>
        if( ++<span>sc_x</span> == <span>ratio_x</span> ) { ++<span>s_row_iter</span>; <span>sc_x</span> = 0; }
      }

      <span>// advance to the next row in the source if we have
      // used it a sufficient number of times</span>
      if( ++<span>sc_y</span> == <span>ratio_y</span> ) { <span>s_buf</span> += <span>s_w</span>; <span>sc_y</span> = 0; }
    }

    return;
  }
  <span>// omitted: fallback implementation for non-integer ratio</span>
}
</rgba></rgba></code></pre>

<p>There are several ways to write this function; This is not
intended to be optimal.</p>

</div>

<p onclick="toggle_collapsed(&#39;upscale_basic&#39;)">expand</p>

</div>

<p>Without changing anything else, I added a check for the case of a 4x ratio,
with the same implementation copied in both branches:</p>

<div>
  <pre><span>// ...</span>

const int <span>ratio_y</span> = <span>d_h</span>/<span>s_h</span>;
const int <span>ratio_x</span> = <span>d_w</span>/<span>s_w</span>;

if( <span><span>ratio_x</span> == 4 &amp;&amp; <span>ratio_y</span> == 4</span> ){
  <span>// remainder of stock integer upscale implementation</span>
} else {
  <span>// identical code copied here</span>
}

<span>// ...</span>
</pre>
</div>

<p>This simple change made the 4x scaling several times faster at the O2
optimization level:</p>

<img src="https://voidstar.tech/code_duplication/optimization_log.png"/>
<p>Notes from optimization attempts</p>

<p>Overall this was a 10x improvement, which was good enough so I didn&#39;t
investigate much further. Recreating this test and doing more rigorous timing
for this post, results still showed a speed up from specialization, but not as
  consistent:</p>

<div>

<p>Time for 4x 960x640 upscale</p>
<p>10 iterations per test</p>

<table>
  <tbody><tr>
    <th>Version</th>
    <th>O2</th>
    <th>O3</th>
  </tr>
  <tr>
    <td>Default integer upscale</td>
    <td>500-678 µs</td>
    <td>438-548 µs</td>
  </tr>
  <tr>
    <td>Specialization for 4x ratio</td>
    <td>300-320 µs</td>
    <td>408-436 µs</td>
  </tr>
</tbody></table>

</div>

<p>These times are rough; Sometimes the specialization benefit
disappeared.</p>

<p>Why is it sometimes faster? I&#39;m still unsure. The only consistent difference I
observed is a comparison against the ratio inside the loop uses a constant
value in the branch where the ratio is known at compile time:</p>

<p><code>cmp</code> instruction difference when ratio is known</p>

<div>
  <pre><code>const int <span>ratio_x</span> = <span>d_w</span>/<span>s_w</span>;

if( <span><span>ratio_x</span> == 4</span> ){

  <span>// known ratio</span>
  if( <span>sc_x</span> == <span>ratio_x</span> ){} <span>cmp edx, 4</span>
} else {
  <span>// any ratio</span>
  if( <span>sc_x</span> == <span>ratio_x</span> ){} <span>cmp ebp, eax</span>
}
</code></pre>
</div>

<p>Stripped-down example</p>

<p>I wrote several shorter test functions to try and exercise this difference,
but none of them were faster.  Published instruction tables do not show any
speed difference for comparing against a constant vs. a register. A speedup may
come from an interaction with branch prediction when different instructions are
used. The big improvement sometimes appeared and disappeared between different
runs of the same build.  But it was never slower, and the specialization was
worth keeping.</p>

<div>

  <p><b>Forcing code separation</b></p>

  <p>At O3, gcc may combine both branches into one which is faster for most
  values, but loses specialization for a particular value. If we want to force
  separation we can move each branch into a separate function or internal
  template with inlining prohibited.</p>

  <p>Code can be separated in situ with an immediately invoked lambda:</p>

  <div>
    <pre><code>if( condition ){
<span>  [&amp;]() <span>__attribute__ ((noinline))</span> {</span>
    <span>// specialized implementation</span>
  <span>}();</span>
} else {
  <span>// default implementation</span>
}
</code></pre>
  </div>

  <p>Thanks to <a href="https://xania.org/201209/forcing-code-out-of-line-in-gcc" target="blank">Matt Godbolt&#39;s blog</a> for showing where the function attribute has to be put
  on a lambda.</p>

  <p>This should be done sparingly. Giving the compiler an opportunity to do something is
  useful, but measure carefully before forcing it.</p>

</div>


<h2>Generating branches automatically</h2>

<p>Outside of a template, we often want to generate code to handle different
possibilities. C++ lacks a general reflection mechanism for emitting
switch-case code for e.g. each option of an enum, forcing use of external code
  generation or manual copying.</p>

<p>The only language tool I know that can be used to this effect is
<code>std::visit</code>, which uses <a href="https://github.com/microsoft/STL/blob/main/stl/inc/variant" target="blank">template and macro horrors</a> to generate an
exhaustive call site invoking a callable object for each possible alternative in a
<code>std::variant</code>. This can be used in combination with a generic
callable to get an otherwise impossible <i>template-for-each</i> construct.</p>

<p>Each case gets a unique instantiation which can act on static information,
and presents an opportunity for separate optimization. The below example
generates implementations for four variant alternatives using a generic lambda:</p>

<p>Case generation with <code>std::visit</code></p>

<p>View on <a href="https://godbolt.org/z/rKdWjMjf8" target="blank">Compiler Explorer</a></p>

<div>
<pre><code><span>
struct one   { constexpr static int <span>value</span> = 1;};
struct two   { constexpr static int <span>value</span> = 2;};
struct three { constexpr static int <span>value</span> = 3;};
struct four  { constexpr static int <span>value</span> = 4;};</span>

using <span>scale_factor</span> = variant&lt;one, two, three, four&gt;;

void <span>scale_vector</span>(vector&lt;int&gt;&amp; <span>Vector</span>, scale_factor <span>Option</span>){

  auto <span>Visitor</span> = [&amp;]<span>&lt;typename T&gt;</span><span>(T)</span> <span>__attribute__ ((noinline))</span> {
    for( auto&amp; <span>V</span> : <span>Vector</span> ){
      <span>V</span> = <span>V</span> * <span>T::value</span>;  <span>// multiplies not by a variable, but a 
                         // constant associated with the template type</span>
    }
  };

  visit(<span>Visitor</span>, <span>Option</span>);
}
</code></pre>



<p><span>Static information</span> maps
types to constant values, because we can only have a variant of types.  These
can also be used as compile-time lookup tables, such as mapping argument types
to a corresponding return type.</p>

<p><span>Familiar template
syntax</span> gives a name to the type this body is being instantiated for;
This is sometimes necessary for deducing a <code>T</code> which is not the same
as the argument type (e.g. the variant alternative is
<code>foo&lt;T&gt;</code>, and we wish to name the inner
<code>T</code>.)</p>

<p>The <span>noinline attribute</span>,
included here for exposition, forces each lambda body to get a separate
function for comparison. This attribute can also be used to restrict the
compiler&#39;s freedom to optimize across cases that we wish to remain
separate.</p>

<p>The <span>argument type</span> keys
the template but doesn&#39;t need to be given a name if we aren&#39;t using the
contained value at run time. It only exists to instantiate a template and
facilitate lookups of <span>compile-time
information</span> necessary for the specialization.</p>

</div>

<p>This function multiplies by one of four values, but because all are known
and handled by unique loops, <b>the resulting code contains no multiply
instructions</b>. Each case has been separately optimized:</p>

<ul>

  <li><b>x1</b> is redundant and is replaced by an early return. No lambda body
  for this option is present in the output because even though it was
    instantiated its only use was removed.</li>

  <li><b>x2 and x4</b> are replaced by a left shift by one and two, respectively.</li>

  <li><b>x3</b> is accomplished using the <code>lea</code> instruction.</li>

</ul>

<p>This technique is limited to cases where <code>std::variant</code> is
usable, which is unfortunate because variant is a cumbersome type that is not
nice for APIs. But I have used this for systems in which a user-facing type gets
stored in a variant at a boundary, then internal operations on it use a generic
lambda to generate a unique body for each type, with each instantiation able to
statically look up associated companion types and values to use in their
implementation. This is preferable to maintaining dozens of otherwise identical
cases in a switch statement.</p>



</div>
  </body>
</html>
