<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jennyjams.net/blog/copygc/">Original</a>
    <h1>Babyâ€™s Second Garbage Collector</h1>
    
    <div id="readability-page-1" class="page">
    
    
    
<p>This blog post is meant to an iteration on the tutorial and introduction to garbage collection implementation presented in <a href="https://journal.stuffwithstuff.com/2013/12/08/babys-first-garbage-collector/">this classic blog post</a>. We are still working with simple garbage collectors, but this time another one with a bit more complexity.</p>
<p>I thought this would be cool because the original code already has a tiny but functional mutator and a set of tests meant to stress it; this means we can compare both the performance and implementation of the copying collector as well as the normal collector.</p>
<h2 id="source-code-for-this-article">Source code for this article</h2>
<p>The source code can be found at <a href="https://github.com/JennysJam/copygc">This github repo</a>.</p>
<p>The code is also hosted locally on this site, and you can download it as well with:</p>
<pre data-lang="bash"><code data-lang="bash"><span><span><span>wget</span></span><span> https://jennyjams.net/copygc/src.zip</span>
</span></code></pre>
<h2 id="copying-collectors">Copying collectors</h2>
<p>A <em>copying collector</em> is a garbage collector design that ties itself intimately in with the backing allocation system: you have two logical (and here, physical) memory regions. One of these is set to be <em>active</em> region, and all new memory is allocated from this region.</p>
<p>When the garbage collection subsystem determines that enough memory has been used that garbage needs to be collected, then the active region is swapped to inactive and vice-versa, then the garbage collector determines the set of live objects and <em>evacuates</em> these objects from the now-inactive region to the newly active region. Then, we take any pointers in the now moved object, and check if the pointers they pointed to in the old region have already forwarded. If so, use the forwarded pointer, if not, perform evacuation.</p>
<p>If an object has already been moved, then the object in the inactive-region can be reused to contain a pointer pointing to it&#39;s evacuated counterpart; this helps preserve the topology of the object graph and fix all of the reference cycles code tends to create.</p>
<h2 id="cheney-s-algorithm">Cheney&#39;s algorithm</h2>
<p>The particular algorithm used here is <a href="https://dl.acm.org/doi/10.1145/362790.362798">Cheney&#39;s Algorithm</a>, and it comes to us from the venerable 1970s.</p>
<ol>
<li>Swap the active heap</li>
<li>Walk the set of roots, and evacuate the pointer to the new heap.</li>
<li>After evacuating all of the objects, start walking through all of the newly allocated objects and inspecting each of their fields. If the field is a pointer and points into the old region, check if it has a forwarding address. If it does, set the field to the forwarding address. If not evacuate it.</li>
</ol>
<p>Or, in pseudocode terms:</p>
<pre data-lang="py"><code data-lang="py"><span>
</span><span><span><span><span>def</span></span> <span><span>collect_garbage</span></span></span><span><span>(</span></span><span><span>)</span></span><span><span>:</span></span>
</span><span>  <span><span><span><span>swap_heap</span></span></span></span><span><span>(</span><span>)</span></span>
</span><span>  <span><span>for</span> <span>root</span> <span>in</span></span><span> <span><span>roots</span></span></span><span><span>:</span></span>
</span><span>    <span><span>if</span> <span><span>field</span></span> <span>in</span> <span><span>old_region</span></span><span>:</span></span>
</span><span>      <span><span>root</span><span>.</span><span>pointer</span></span> <span>=</span> <span><span><span><span>evacuate</span></span></span></span><span><span>(</span><span><span>root</span><span>.</span><span>pointer</span></span><span>)</span></span>
</span><span>  
</span><span>  <span><span>while</span> <span>not</span> <span><span><span>worklist</span></span><span><span>.</span></span><span><span><span>is_empty</span></span></span></span><span><span>(</span><span>)</span></span><span>:</span></span>
</span><span>    <span><span>obj</span></span> <span>=</span> <span><span><span>worklist</span></span><span><span>.</span></span><span><span><span>pop</span></span></span></span><span><span>(</span><span>)</span></span>
</span><span>    <span><span>for</span> <span>field</span> <span>in</span></span><span> <span><span><span>obj</span></span><span><span>.</span></span><span><span><span>fields</span></span></span></span><span><span>(</span><span>)</span></span></span><span><span>:</span></span>
</span><span>      <span><span>if</span> <span><span>field</span><span>.</span><span>pointer</span></span> <span>is</span> <span>in</span> <span><span>old_region</span></span><span>:</span></span>
</span><span>        <span><span>field</span><span>.</span><span>pointer</span></span> <span>=</span> <span><span><span><span>evacuate</span></span></span></span><span><span>(</span><span><span>root</span><span>.</span><span>pointer</span></span><span>)</span></span>
</span><span>
</span><span><span><span><span>def</span></span> <span><span>evacuate</span></span></span><span><span>(</span></span><span><span>ptr</span><span>)</span></span><span><span>:</span></span>
</span><span>  <span><span>if</span> <span><span><span><span>has_forward_address</span></span></span></span><span><span>(</span><span><span>ptr</span></span><span>)</span></span><span>:</span></span>
</span><span>    <span>return</span> <span><span>ptr</span><span>.</span><span>forward</span></span>
</span><span>  <span><span>new_object</span></span> <span>=</span> <span><span><span><span>allocate_from_active</span></span></span></span><span><span>(</span><span>)</span></span>
</span><span>  <span><span><span><span>copy</span></span></span></span><span><span>(</span><span><span>new_object</span></span><span>,</span> <span><span>ptr</span></span><span>)</span></span>
</span><span>  <span><span>ptr</span><span>.</span><span>forward</span></span> <span>=</span> <span><span>new_object</span></span>
</span><span>  <span><span><span>worklist</span></span><span><span>.</span></span><span><span><span>append</span></span></span></span><span><span>(</span><span><span>new_object</span></span><span>)</span></span>
</span><span>
</span></code></pre>
<p>However, I feel like a lot of GC stuff can feel extremely abstract, especially when you start dealing with the quasi-recursive stuff, so I&#39;m laying it out in pictures instead.</p>
<h2 id="cheney-s-algorithm-this-time-in-pictures">Cheney&#39;s Algorithm, this time in pictures.</h2>
<p><img src="https://jennyjams.net/blog/copygc/./img/copy-1.svg" alt=""/></p>
<p>First, our initial state shows how one of the heaps is full of memory, and the collector has decided to begin garbage collecting. The set of boxes on the left is the Root Set (represented as a stack with 3 active members), and the two boxes on the right are the 2 heap regions.</p>
<p><img src="https://jennyjams.net/blog/copygc/./img/copy-2.svg" alt=""/></p>
<p>We begin by walking through each of the roots. The blue color represents objects that have yet to be processed.</p>
<p><img src="https://jennyjams.net/blog/copygc/./img/copy-3.svg" alt=""/></p>
<p>The first root is pointing to an un-forwarded object in the from-heap, so we forward it to the to-heap and update the from-heap object to point to it (represented by the purple and curved, dotted line).</p>
<p><img src="https://jennyjams.net/blog/copygc/./img/copy-4.svg" alt=""/></p>
<p>Now that we&#39;ve forward what the first root was pointing at, we set it to point at the evacuated object in the to-heap, and remove it from the set of objects we care about, rendering it again in brown.</p>
<p><img src="https://jennyjams.net/blog/copygc/./img/copy-5.svg" alt=""/></p>
<p>Next, we handle the second root. Because it is pointing to an object that has already been forwarded because we handled it previously, we simply set the root to point at the evacuated object in the to-heap and remove the 2nd root from my concern.</p>
<p><img src="https://jennyjams.net/blog/copygc/./img/copy-6.svg" alt=""/></p>
<p>Next, we handle the final root. This is pointing to an object that itself has a pointer, so first we evacuate it and set the from-heap object to forward to it. However, because we just copied it, the evacuated object is itself still pointing to a from-heap object.</p>
<p><img src="https://jennyjams.net/blog/copygc/./img/copy-7.svg" alt=""/></p>
<p>Next, we set the final root to point toward the evacuated pointer. We are now finished with all of the root set, and next must begin handling the objects in the to-heap to move any objects that were not directly pointed to from the roots.</p>
<p><img src="https://jennyjams.net/blog/copygc/./img/copy-8.svg" alt=""/></p>
<p>We handle the first object in the from-heap. Because it simply holds an integer, there is no need to do any more work and we move to the next object.</p>
<p><img src="https://jennyjams.net/blog/copygc/./img/copy-9.svg" alt=""/></p>
<p>The second item in the to-heap is an object that contains a pointer pointing towards an object in the from heap. We must evacuate and forward that object, and add it to the set of object&#39;s we care about.</p>
<p><img src="https://jennyjams.net/blog/copygc/./img/copy-10.svg" alt=""/></p>
<p>Now that the second item in the to-heap is pointing to a forwarded pointer, we can fix it&#39;s pointer to point to the evacuated object in the to-heap, and thus remove it from our concerns.</p>
<p><img src="https://jennyjams.net/blog/copygc/./img/copy-11.svg" alt=""/></p>
<p>Next, we handle the final object. Because it contains no pointers, we simply remove it from our concerns.</p>
<p><img src="https://jennyjams.net/blog/copygc/./img/copy-12.svg" alt=""/></p>
<p>Finally, we have no more items to work through in either the roots or the heap. We can then clear the old heap and blow all previous objects.</p>
<p>Garbage collection is now Complete.</p>
<h2 id="the-world-smallest-allocator">The world smallest allocator</h2>
<p>Unlike mark and sweep, a copying collector relies on it&#39;s allocator to free memory, and thus we cannot use the standard library <code>malloc()</code> and <code>free()</code> function -- instead of calling a function to free memory on every object we&#39;ve determined to be non-live, we implicitly free it when we swap the heap because all of the data in our allocator gets reused for future allocation.</p>
<p>Thus, we will need an allocator!</p>
<p>The simplest possible allocator is a <em>bump</em> allocator: just a large contiguous region of memory, and an offset. Whenever an <code>allocate(size)</code> call is perform, it returns a pointer to the memory that is <code>offset</code> bytes into the memory region. The offset is then incremented by this size.</p>
<p>This allocator doesn&#39;t really have a coherent <code>free()</code> operation -- even if you logically free memory earlier on in the allocator, the allocator itself can&#39;t reuse it. Thus, the only meaningful way to reset memory is to wipe <em>all</em> allocations and reset the <code>offset</code> to 0.</p>
<p>This property makes this allocator-pattern genuinely useful for situations like web-servers or video games, where a request or individual frame might generate large amounts of data that is not meaningful useful to keep around afterwards; the <code>clear()</code> operation would be much faster than attempting to deallocate each of the objects.</p>
<p><img src="https://jennyjams.net/blog/copygc/./img/bump-1.svg" alt=""/></p>
<p>This is a diagram showing a set of objects that will be populated by pointers to objects allocated by the bump allocator, and the bump allocator itself. The bump allocator consists of a offset (or pointer) into the backing allocation, along with a large chunk of memory itself.</p>
<p><img src="https://jennyjams.net/blog/copygc/./img/bump-2.svg" alt=""/></p>
<p>Allocation is performed -- the object&#39;s pointer is set to point at the memory chunk plus the offset. Then the offset is moved down to point to the next free area of memory.</p>
<p><img src="https://jennyjams.net/blog/copygc/./img/bump-3.svg" alt=""/></p>
<p>And again, with a different size.</p>
<p><img src="https://jennyjams.net/blog/copygc/./img/bump-4.svg" alt=""/></p>
<p>And again.</p>
<p><img src="https://jennyjams.net/blog/copygc/./img/bump-5.svg" alt=""/></p>
<p>Next, we call <code>clear()</code> and reset the offset to point to the start of the memory chunk, effectively freeing the memory; on more security minded systems we might <code>memset()</code> the allocated areas to zero to prevent possibly leaking any information. All of the previous pointers into the memory are now dangling pointers -- even though they are pointing into valid memory that is mapped, the pointers to that memory are likely of the wrong type or value, and will be pointing into the middle of another object.</p>
<p><img src="https://jennyjams.net/blog/copygc/./img/bump-6.svg" alt=""/></p>
<p>Next, we allocate memory again, and we begin allocating from the beginning of the memory chunk.</p>
<h2 id="now-to-the-code">Now, to the code</h2>
<p>Next, I present the code for each of the major parts we change out, and attempt to highlight code where I&#39;m rewriting old code.</p>
<h2 id="fixin-up-our-unified-object-model">Fixin&#39; up our unified object model</h2>
<p>Since we&#39;re updating an existing codebase to swap the GC strategy out, we need to perform some code to change things.</p>
<p>First, we update the object model for our VM to remove the intrusive link list pointer, and to add another case to our union for the forwarding pointer. This is one of the canonical benefits of copying over more traditional mark-sweep, mark-compact, and reference-counting schemes: we don&#39;t need any extra metadata inside of the header.</p>
<p>However, we do need to utilize a forwarding pointer. You&#39;d think that might mean we&#39;d need the overhead of another pointer, but since an object being repurposes to point to a new object has no other meaningful significance, we can just reuse the space for one of it&#39;s fields</p>
<pre data-lang="c"><code data-lang="c"><span><span>typedef</span> <span>struct</span> sObject <span><span>{</span>
</span></span><span><span>  ObjectType type<span>;</span>
</span></span><mark><span><span>  <span><span>//</span> remove ``struct sObject* next;``
</span></span></span></mark><span><span>  <span>union</span> <span><span>{</span>
</span></span></span><span><span><span>    <span><span>/*</span> OBJ_INT <span>*/</span></span>
</span></span></span><span><span><span>    <span>int</span> value<span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    <span><span>/*</span> OBJ_PAIR <span>*/</span></span>
</span></span></span><span><span><span>    <span>struct</span> <span><span>{</span>
</span></span></span></span><span><span><span><span>      <span>struct</span> <span>sObject</span><span>*</span> head<span>;</span>
</span></span></span></span><span><span><span><span>      <span>struct</span> <span>sObject</span><span>*</span> tail<span>;</span>
</span></span></span></span><span><span><span><span>    <span>}</span></span><span>;</span>
</span></span></span><mark><span><span><span>    <span>struct</span> <span>sObject</span><span>*</span> forward<span>;</span>
</span></span></span></mark><span><span><span>  <span>}</span></span><span>;</span>
</span></span><span><span><span>}</span></span> <span>Object</span><span>;</span>
</span></code></pre>
<p>We also need a new tag to indicate an object is forwarded.</p>
<pre data-lang="c"><code data-lang="c"><span><span>typedef</span> <span>enum</span> <span><span>{</span>
</span></span><span><span>  OBJ_INT<span>,</span>
</span></span><span><span>  OBJ_PAIR<span>,</span>
</span></span><mark><span><span><span>  OBJ_FRWD
</span></span></span></mark><span><span><span>}</span></span> <span>ObjectType</span><span>;</span>
</span><span>
</span></code></pre>
<p>Next, we update the VM model to store the code for the beginning and end of the heap work-list</p>
<pre data-lang="c"><code data-lang="c"><span><span>typedef</span> <span>struct</span> <span><span>{</span>
</span></span><span><span>  Object<span>*</span> stack<span><span>[</span>STACK_MAX<span>]</span></span><span>;</span>
</span></span><span><span>  <span>int</span> stackSize<span>;</span>
</span></span><span><span>
</span></span><span><span>  <span><span>/*</span> First and last object in heap <span>*/</span></span>
</span></span><span><span>  Object<span>*</span> firstObject<span>;</span>
</span></span><mark><span><span>  Object<span>*</span> lastObject<span>;</span>
</span></span></mark><span><span>
</span></span><span><span>  <span><span>/*</span> The total number of currently allocated objects. <span>*/</span></span>
</span></span><span><span>  <span>int</span> numObjects<span>;</span>
</span></span><span><span>
</span></span><span><span>  <span><span>/*</span> The number of objects required to trigger a GC. <span>*/</span></span>
</span></span><span><span>  <span>int</span> maxObjects<span>;</span>
</span></span><span><span>
</span></span><span><span><span>}</span></span> <span>VM</span><span>;</span>
</span></code></pre>
<h2 id="the-world-s-smallest-allocator-twice">The world&#39;s smallest allocator, twice</h2>
<p>In our case, we actually need 2 bump-allocators. Because only one one is every being allocated from, we can keep around a single offset, and also keep an extra bit of state describing which pool is being used. The boring names would be Region 1 and 2, or Regions A and B; I want to be cute and name them Regions <a href="https://en.wikipedia.org/wiki/Bouba/kiki_effect">Boba and Kiki instead</a> instead. Because I cannot spell and cannot be asked to double check things, all of the code uses Boba instead of Bouba. Consider this your daily reminder to go buy Boba.</p>
<p>First, we need a reasonable max size -- I simply choose 2^16:</p>
<pre data-lang="c"><code data-lang="c"><span><span><span>#define</span></span><span> <span>HEAP_MAX</span></span><span> <span>65536</span></span>
</span></code></pre>
<p>Next, the data structure. In following the language in Cheney&#39;s algorithm and other papers, we call this a <em>heap</em>.</p>
<pre data-lang="c"><code data-lang="c"><span><span>typedef</span> <span>struct</span> <span><span>{</span>
</span></span><span><span>  <span>size_t</span> bump_offset<span>;</span>
</span></span><span><span>  Region region<span>;</span>
</span></span><span><span>  <span>unsigned</span> <span>char</span> region_boba<span><span>[</span>HEAP_MAX<span>]</span></span><span>;</span>
</span></span><span><span>  <span>unsigned</span> <span>char</span> region_kiki<span><span>[</span>HEAP_MAX<span>]</span></span><span>;</span>
</span></span><span><span><span>}</span></span> <span>Heap</span><span>;</span>
</span></code></pre>
<p>First, we need some code to generate a new Heap object. We <code>memset()</code> the memory to zero to ensure no previous data remains.</p>
<pre data-lang="c"><code data-lang="c"><span><span><span>//</span> Allocates and creates new Heap
</span></span><span>Heap<span>*</span> <span><span>newHeap</span></span><span><span><span>(</span></span></span><span><span><span>)</span></span></span><span> </span><span><span><span>{</span></span></span><span><span>
</span></span></span><span><span><span>  Heap<span>*</span> heap <span>=</span> <span><span>malloc</span><span><span>(</span></span></span><span><span><span>sizeof</span><span><span>(</span></span><span>Heap</span><span><span>)</span></span></span></span><span><span><span>)</span></span></span><span>;</span>
</span></span></span><span><span><span>  <span><span>memset</span><span><span>(</span></span></span><span><span>heap<span>-&gt;</span>region_boba<span>,</span> <span>0</span><span>,</span> <span>sizeof</span> heap<span>-&gt;</span>region_boba</span></span><span><span><span>)</span></span></span><span>;</span>
</span></span></span><span><span><span>  <span><span>memset</span><span><span>(</span></span></span><span><span>heap<span>-&gt;</span>region_kiki<span>,</span> <span>0</span><span>,</span> <span>sizeof</span> heap<span>-&gt;</span>region_kiki</span></span><span><span><span>)</span></span></span><span>;</span>
</span></span></span><span><span><span>  heap<span>-&gt;</span>region <span>=</span> RGN_BOBA<span>;</span>
</span></span></span><span><span><span>  heap<span>-&gt;</span>bump_offset <span>=</span> <span>0</span><span>;</span>
</span></span></span><span><span><span>  <span>return</span> heap<span>;</span>
</span></span></span><span><span><span></span></span><span><span><span>}</span></span></span>
</span></code></pre>
<p>It seem a little strange that, after writing a custom allocator, we would just <code>malloc()</code> to get the memory for the allocator, but this is pretty common -- unless you are yourself implementing <code>malloc()</code> or the lowest-level memory allocator for a system, normally you have to rely on <em>some</em> function call to get you backing memory. And <code>malloc()</code> is conveniently right here!</p>
<p>Next, allocation!</p>
<pre data-lang="c"><code data-lang="c"><span><span>void</span><span>*</span> <span><span>heapAlloc</span></span><span><span><span>(</span></span></span><span><span>Heap<span>*</span> <span>heap</span><span>,</span> <span>size_t</span> <span>size</span><span>)</span></span></span><span> </span><span><span><span>{</span></span></span><span><span>
</span></span></span><span><span><span>  <span><span>assert</span><span><span>(</span></span></span><span><span>heap<span>-&gt;</span>bump_offset <span>+</span> size <span>&lt;</span> HEAP_MAX<span>,</span> 
</span></span></span></span></span><span><span><span><span><span>      <span><span>&#34;</span>Attempted to allocate more items that can be in heap<span>&#34;</span></span></span></span><span><span><span>)</span></span></span><span>;</span>
</span></span></span><span><span><span>  <span>void</span><span>*</span> pointer <span>=</span> <span>NULL</span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>  <span>if</span> <span><span>(</span>heap<span>-&gt;</span>region <span>==</span> RGN_BOBA<span>)</span></span> <span><span>{</span>
</span></span></span></span><span><span><span><span>    pointer <span>=</span> heap<span>-&gt;</span>region_boba <span>+</span> heap<span>-&gt;</span>bump_offset<span>;</span>
</span></span></span></span><span><span><span><span>  <span>}</span></span>
</span></span></span><span><span><span>  <span>else</span> <span><span>{</span>
</span></span></span></span><span><span><span><span>    pointer <span>=</span> heap<span>-&gt;</span>region_kiki <span>+</span> heap<span>-&gt;</span>bump_offset<span>;</span>
</span></span></span></span><span><span><span><span>  <span>}</span></span>
</span></span></span><span><span><span>  heap<span>-&gt;</span>bump_offset <span>+=</span> size<span>;</span>
</span></span></span><span><span><span>  <span>return</span> pointer<span>;</span>
</span></span></span><span><span><span></span></span><span><span><span>}</span></span></span>
</span></code></pre>
<p>We can&#39;t utilize this allocator unless we have a way of clearing out the dump allocator. Instead of the <code>clear()</code> interface discussed above, we swap the active heap over, and then reset the offset to 0. This also updates some data in the VM to allow for our later step of pointer fixup, so we pass a pointer to the VM in rather than to the Heap.</p>
<pre data-lang="c"><code data-lang="c"><span><span>void</span> <span><span>swapHeap</span></span><span><span><span>(</span></span></span><span><span>VM<span>*</span> <span>vm</span><span>)</span></span></span><span> </span><span><span><span>{</span></span></span><span><span>
</span></span></span><span><span><span>  <span>if</span> <span><span>(</span>vm<span>-&gt;</span>heap<span>-&gt;</span>region <span>==</span> RGN_BOBA<span>)</span></span> <span><span>{</span>
</span></span></span></span><span><span><span><span>    vm<span>-&gt;</span>heap<span>-&gt;</span>region <span>=</span> RGN_KIKI<span>;</span>
</span></span></span></span><span><span><span><span>    vm<span>-&gt;</span>firstObject <span>=</span> vm<span>-&gt;</span>lastObject <span>=</span> <span><span>(</span>Object<span>*</span><span>)</span></span> vm<span>-&gt;</span>heap<span>-&gt;</span>region_kiki<span>;</span>
</span></span></span></span><span><span><span><span>  <span>}</span></span>
</span></span></span><span><span><span>  <span>else</span> <span><span>{</span>
</span></span></span></span><span><span><span><span>    vm<span>-&gt;</span>heap<span>-&gt;</span>region <span>=</span> RGN_BOBA<span>;</span>
</span></span></span></span><span><span><span><span>    vm<span>-&gt;</span>firstObject <span>=</span> vm<span>-&gt;</span>lastObject <span>=</span> <span><span>(</span>Object<span>*</span><span>)</span></span> vm<span>-&gt;</span>heap<span>-&gt;</span>region_boba<span>;</span>
</span></span></span></span><span><span><span><span>  <span>}</span></span>
</span></span></span><span><span><span>  vm<span>-&gt;</span>heap<span>-&gt;</span>bump_offset <span>=</span> <span>0</span><span>;</span>
</span></span></span><span><span><span></span></span><span><span><span>}</span></span></span>
</span></code></pre>
<p>Also, since we&#39;re no longer using <code>malloc()</code> to allocate objects, we have to update our <code>newObject()</code> function.</p>
<p>We also update how we allocate objects to remove the code from the intrusive linked list.</p>
<pre data-lang="c"><code data-lang="c"><span>Object<span>*</span> <span><span>newObject</span></span><span><span><span>(</span></span></span><span><span>VM<span>*</span> <span>vm</span><span>,</span> ObjectType <span>type</span><span>)</span></span></span><span> </span><span><span><span>{</span></span></span><span><span>
</span></span></span><span><span><span>  <span>if</span> <span><span>(</span>vm<span>-&gt;</span>numObjects <span>==</span> vm<span>-&gt;</span>maxObjects<span>)</span></span> <span><span>gc</span><span><span>(</span></span></span><span><span>vm</span></span><span><span><span>)</span></span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><mark><span><span><span>  Object<span>*</span> object <span>=</span> <span><span>heapAlloc</span><span><span>(</span></span></span><span><span>vm<span>-&gt;</span>heap<span>,</span> <span>sizeof</span><span><span>(</span></span><span>Object</span><span><span>)</span></span></span></span><span><span><span>)</span></span></span><span>;</span>
</span></span></span></mark><span><span><span>  object<span>-&gt;</span>type <span>=</span> type<span>;</span>
</span></span></span><mark><span><span><span>  vm<span>-&gt;</span>numObjects<span>++</span><span>;</span>
</span></span></span></mark><span><span><span>
</span></span></span><span><span><span>  <span>return</span> object<span>;</span>
</span></span></span><span><span><span></span></span><span><span><span>}</span></span></span>
</span></code></pre>
<p>Finally, we want to update our VM object to contain a Heap pointer. We also add the <code>lastObject</code> pointer field that we use during the collection step.</p>
<pre data-lang="c"><code data-lang="c"><span>VM<span>*</span> <span><span>newVM</span></span><span><span><span>(</span></span></span><span><span><span>)</span></span></span><span> </span><span><span><span>{</span></span></span><span><span>
</span></span></span><span><span><span>  VM<span>*</span> vm <span>=</span> <span><span>malloc</span><span><span>(</span></span></span><span><span><span>sizeof</span><span><span>(</span></span><span>VM</span><span><span>)</span></span></span></span><span><span><span>)</span></span></span><span>;</span>
</span></span></span><span><span><span>  vm<span>-&gt;</span>stackSize <span>=</span> <span>0</span><span>;</span>
</span></span></span><span><span><span>  vm<span>-&gt;</span>firstObject <span>=</span> <span>NULL</span><span>;</span>
</span></span></span><mark><span><span><span>  vm<span>-&gt;</span>lastObject <span>=</span> <span>NULL</span><span>;</span>
</span></span></span></mark><span><span><span>  vm<span>-&gt;</span>numObjects <span>=</span> <span>0</span><span>;</span>
</span></span></span><span><span><span>  vm<span>-&gt;</span>maxObjects <span>=</span> INIT_OBJ_NUM_MAX<span>;</span>
</span></span></span><mark><span><span><span>  vm<span>-&gt;</span>heap <span>=</span> <span><span>newHeap</span><span><span>(</span></span></span><span></span><span><span><span>)</span></span></span><span>;</span>
</span></span></span></mark><span><span><span>  <span>return</span> vm<span>;</span>
</span></span></span><span><span><span></span></span><span><span><span>}</span></span></span>
</span></code></pre>
<p>Finally, as good responsible C citizens we free the heap object we&#39;ve <code>malloc()</code>&#39;d when we free it&#39;s own VM.</p>
<pre data-lang="c"><code data-lang="c"><span><span>void</span> <span><span>freeVM</span></span><span><span><span>(</span></span></span><span><span>VM <span>*</span><span>vm</span><span>)</span></span></span><span> </span><span><span><span>{</span></span></span><span><span>
</span></span></span><span><span><span>  vm<span>-&gt;</span>stackSize <span>=</span> <span>0</span><span>;</span>
</span></span></span><span><span><span>  <span><span>gc</span><span><span>(</span></span></span><span><span>vm</span></span><span><span><span>)</span></span></span><span>;</span>
</span></span></span><mark><span><span><span>  <span><span>free</span><span><span>(</span></span></span><span><span>vm<span>-&gt;</span>heap</span></span><span><span><span>)</span></span></span><span>;</span>
</span></span></span></mark><span><span><span>  <span><span>free</span><span><span>(</span></span></span><span><span>vm</span></span><span><span><span>)</span></span></span><span>;</span>
</span></span></span><span><span><span></span></span><span><span><span>}</span></span></span>
</span></code></pre>
<h2 id="no-more-marking-only-forwarding">No more marking, only forwarding.</h2>
<p>Since we neither engage in marking nor sweeping, we can rip out almost all code related to mark and sweep code (which would no longer compile correctly anymore because we updated our VM and Object types).</p>
<p>We need to first handle all of our roots. To do this, we simply walk over each of the root, and perform evacuation and forwarding on each of the pointed to objects:</p>
<pre data-lang="c"><code data-lang="c"><span><span>void</span> <span><span>processRoots</span></span><span><span><span>(</span></span></span><span><span>VM<span>*</span> <span>vm</span><span>)</span></span></span><span> </span><span><span><span>{</span></span></span><span><span>
</span></span></span><span><span><span>  <span>for</span> <span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> vm<span>-&gt;</span>stackSize<span>;</span> i<span>++</span><span>)</span></span> <span><span>{</span>
</span></span></span></span><span><span><span><span>    vm<span>-&gt;</span>stack<span><span>[</span>i<span>]</span></span> <span>=</span> <span><span>forward</span><span><span>(</span></span></span><span><span>vm<span>,</span> vm<span>-&gt;</span>stack<span><span>[</span>i<span>]</span></span></span></span><span><span><span>)</span></span></span><span>;</span>
</span></span></span></span><span><span><span><span>  <span>}</span></span>
</span></span></span><span><span><span></span></span><span><span><span>}</span></span></span>
</span></code></pre>
<p>When we forward an object, we first check to see if it has already been forwarded.</p>
<p>If it has, we just return the forwarded pointer, which we know is in the to-heap.</p>
<pre data-lang="c"><code data-lang="c"><span>Object<span>*</span> <span><span>forward</span></span><span><span><span>(</span></span></span><span><span>VM<span>*</span> <span>vm</span><span>,</span> Object<span>*</span> <span>object</span><span>)</span></span></span><span> </span><span><span><span>{</span></span></span><span><span>
</span></span></span><span><span><span>  <span><span>assert</span><span><span>(</span></span></span><span><span><span><span>inFromHeap</span><span><span>(</span></span></span><span><span>vm<span>-&gt;</span>heap<span>,</span> object</span></span><span><span><span>)</span></span></span><span>,</span> <span><span>&#34;</span>Object must be in from-heap.<span>&#34;</span></span></span></span><span><span><span>)</span></span></span><span>;</span>
</span></span></span><span><span><span>  
</span></span></span><span><span><span>  <span>if</span> <span><span>(</span>object<span>-&gt;</span>type <span>==</span> OBJ_FRWD<span>)</span></span> <span>return</span> object<span>-&gt;</span>forward<span>;</span>
</span></span></span><span><span><span>  <span><span>//</span>...
</span></span></span></span><span><span><span></span></span><span><span><span>}</span></span></span>
</span></code></pre>
<p>If it hasn&#39;t, then we allocate a new object in the to-heap, copy the contents of object in the from-heap over.
We then update the <code>vm-&gt;lastObject</code> field to point one past the currently allocated object. This is one of the times in this codebase where i&#39;m taking advantage of the fact all objects have the same overall size; if they were of a different size it would look more like <code>vm-&gt;lastObject  = (Object*) ((char*)copied + getObjectSize(copied)</code>.</p>
<pre data-lang="c"><code data-lang="c"><span>Object<span>*</span> <span><span>forward</span></span><span><span><span>(</span></span></span><span><span>VM<span>*</span> <span>vm</span><span>,</span> Object<span>*</span> <span>object</span><span>)</span></span></span><span> </span><span><span><span>{</span></span></span><span><span>
</span></span></span><span><span><span>  <span><span>assert</span><span><span>(</span></span></span><span><span><span><span>inFromHeap</span><span><span>(</span></span></span><span><span>vm<span>-&gt;</span>heap<span>,</span> object</span></span><span><span><span>)</span></span></span><span>,</span> <span><span>&#34;</span>Object must be in from-heap.<span>&#34;</span></span></span></span><span><span><span>)</span></span></span><span>;</span>
</span></span></span><span><span><span>  
</span></span></span><span><span><span>  <span>if</span> <span><span>(</span>object<span>-&gt;</span>type <span>==</span> OBJ_FRWD<span>)</span></span> <span>return</span> object<span>-&gt;</span>forward<span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>  Object<span>*</span> copied <span>=</span> <span><span>heapAlloc</span><span><span>(</span></span></span><span><span>vm<span>-&gt;</span>heap<span>,</span> <span>sizeof</span><span><span>(</span></span><span>Object</span><span><span>)</span></span></span></span><span><span><span>)</span></span></span><span>;</span>
</span></span></span><span><span><span>  vm<span>-&gt;</span>numObjects<span>++</span><span>;</span>
</span></span></span><span><span><span>  <span><span>memcpy</span><span><span>(</span></span></span><span><span>copied<span>,</span> object<span>,</span> <span>sizeof</span><span><span>(</span></span><span>Object</span><span><span>)</span></span></span></span><span><span><span>)</span></span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>  vm<span>-&gt;</span>lastObject <span>=</span> copied <span>+</span> <span>1</span><span>;</span>
</span></span></span><span><span><span>  <span>return</span> copied<span>;</span>
</span></span></span><span><span><span></span></span><span><span><span>}</span></span></span>
</span></code></pre>
<p>Finally, we set our old object to hold a forwarding pointer:</p>
<pre data-lang="c"><code data-lang="c"><span>Object<span>*</span> <span><span>forward</span></span><span><span><span>(</span></span></span><span><span>VM<span>*</span> <span>vm</span><span>,</span> Object<span>*</span> <span>object</span><span>)</span></span></span><span> </span><span><span><span>{</span></span></span><span><span>
</span></span></span><span><span><span>  <span><span>assert</span><span><span>(</span></span></span><span><span><span><span>inFromHeap</span><span><span>(</span></span></span><span><span>vm<span>-&gt;</span>heap<span>,</span> object</span></span><span><span><span>)</span></span></span><span>,</span> <span><span>&#34;</span>Object must be in from-heap.<span>&#34;</span></span></span></span><span><span><span>)</span></span></span><span>;</span>
</span></span></span><span><span><span>  
</span></span></span><span><span><span>  <span>if</span> <span><span>(</span>object<span>-&gt;</span>type <span>==</span> OBJ_FRWD<span>)</span></span> <span>return</span> object<span>-&gt;</span>forward<span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>  Object<span>*</span> copied <span>=</span> <span><span>heapAlloc</span><span><span>(</span></span></span><span><span>vm<span>-&gt;</span>heap<span>,</span> <span>sizeof</span><span><span>(</span></span><span>Object</span><span><span>)</span></span></span></span><span><span><span>)</span></span></span><span>;</span>
</span></span></span><span><span><span>  vm<span>-&gt;</span>numObjects<span>++</span><span>;</span>
</span></span></span><span><span><span>  <span><span>memcpy</span><span><span>(</span></span></span><span><span>copied<span>,</span> object<span>,</span> <span>sizeof</span><span><span>(</span></span><span>Object</span><span><span>)</span></span></span></span><span><span><span>)</span></span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>  vm<span>-&gt;</span>lastObject <span>=</span> copied <span>+</span> <span>1</span><span>;</span>
</span></span></span><span><span><span>  
</span></span></span><span><span><span>  <span><span>//</span>set forwarding pointer
</span></span></span></span><span><span><span>  object<span>-&gt;</span>type <span>=</span> OBJ_FRWD<span>;</span>
</span></span></span><span><span><span>  object<span>-&gt;</span>forward <span>=</span> copied<span>;</span>
</span></span></span><span><span><span> 
</span></span></span><span><span><span>  <span>return</span> copied<span>;</span>
</span></span></span><span><span><span></span></span><span><span><span>}</span></span></span>
</span></code></pre>
<h2 id="to-all-of-the-indirectly-traversable-objects-that-i-ve-left-behind">To all of the indirectly traversable objects that I&#39;ve left behind</h2>
<p>Now that we&#39;ve built the mechanism to forward our pointers, all managed objects pointed to by the roots have been handled. Next, we have to handle the objects that those moved objects still point to.</p>
<p>In the original mark-sweep scheme, reachability had been solved before any memory management had occurred -- we recursively walk the object graph, bail if an object has already been marked to prevent loops, and then walk the linked list to purge all of the unmarked objects.</p>
<p>Here, the reachability and marking works intermingled: we iterate through each of the objects in the new heap, and when we see it has a field pointing into the from-heap, we moved it and stick it onto the end of our heap, meaning, and once we get to scanning it we fix up any of it&#39;s pointers, until we hit the end.</p>
<p>Taking advantage that all objects in our VM are the same size, we can just increment a pointer. If we didn&#39;t, we&#39;d need to do work to increment via the object&#39;s size.</p>
<pre data-lang="c"><code data-lang="c"><span><span>void</span> <span><span>processWorklist</span></span><span><span><span>(</span></span></span><span><span>VM<span>*</span> <span>vm</span><span>)</span></span></span><span> </span><span><span><span>{</span></span></span><span><span>
</span></span></span><span><span><span>  <span>while</span> <span><span>(</span>vm<span>-&gt;</span>firstObject <span>!=</span> vm<span>-&gt;</span>lastObject<span>)</span></span> <span><span>{</span>
</span></span></span></span><span><span><span><span>    <span><span>//</span>forward sub-pointers of Pair object
</span></span></span></span></span><span><span><span><span>    <span>if</span> <span><span>(</span>vm<span>-&gt;</span>firstObject<span>-&gt;</span>type <span>==</span> OBJ_PAIR<span>)</span></span> <span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>      vm<span>-&gt;</span>firstObject<span>-&gt;</span>head <span>=</span> <span><span>forward</span><span><span>(</span></span></span><span><span>vm<span>,</span> vm<span>-&gt;</span>firstObject<span>-&gt;</span>head</span></span><span><span><span>)</span></span></span><span>;</span>
</span></span></span></span></span><span><span><span><span><span>      
</span></span></span></span></span><span><span><span><span><span>      vm<span>-&gt;</span>firstObject<span>-&gt;</span>tail <span>=</span> <span><span>forward</span><span><span>(</span></span></span><span><span>vm<span>,</span> vm<span>-&gt;</span>firstObject<span>-&gt;</span>tail</span></span><span><span><span>)</span></span></span><span>;</span>
</span></span></span></span></span><span><span><span><span><span>    <span>}</span></span>
</span></span></span></span><span><span><span><span>
</span></span></span></span><span><span><span><span>    vm<span>-&gt;</span>firstObject<span>++</span><span>;</span>
</span></span></span></span><span><span><span><span>  <span>}</span></span>
</span></span></span><span><span><span></span></span><span><span><span>}</span></span></span>
</span></code></pre>
<h2 id="tying-the-garbage-bag-together">Tying the garbage bag together</h2>
<p>Finally, we change the <code>gc()</code> function so that we now call into our new mark and compact scheme.</p>
<pre data-lang="c"><code data-lang="c"><span><span>void</span> <span><span>gc</span></span><span><span><span>(</span></span></span><span><span>VM<span>*</span> <span>vm</span><span>)</span></span></span><span> </span><span><span><span>{</span></span></span><span><span>
</span></span></span><span><span><span>  <span>int</span> numObjects <span>=</span> vm<span>-&gt;</span>numObjects<span>;</span>
</span></span></span><span><span><span>  vm<span>-&gt;</span>numObjects <span>=</span> <span>0</span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><mark><span><span><span>  <span><span>swapHeap</span><span><span>(</span></span></span><span><span>vm</span></span><span><span><span>)</span></span></span><span>;</span>
</span></span></span></mark><mark><span><span><span>  <span><span>processRoots</span><span><span>(</span></span></span><span><span>vm</span></span><span><span><span>)</span></span></span><span>;</span>
</span></span></span></mark><mark><span><span><span>  <span><span>processWorklist</span><span><span>(</span></span></span><span><span>vm</span></span><span><span><span>)</span></span></span><span>;</span>
</span></span></span></mark><mark><span><span><span>  vm<span>-&gt;</span>lastObject <span>=</span> <span>NULL</span><span>;</span>
</span></span></span></mark><mark><span><span><span>  vm<span>-&gt;</span>firstObject <span>=</span> <span>NULL</span><span>;</span>
</span></span></span></mark><span><span><span>
</span></span></span><span><span><span>  vm<span>-&gt;</span>maxObjects <span>=</span> vm<span>-&gt;</span>numObjects <span>==</span> <span>0</span> <span>?</span> INIT_OBJ_NUM_MAX <span>:</span> vm<span>-&gt;</span>numObjects <span>*</span> <span>2</span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>  <span><span>printf</span><span><span>(</span></span></span><span><span><span><span>&#34;</span>Collected <span>%d</span> objects, <span>%d</span> remaining.<span>\n</span><span>&#34;</span></span><span>,</span> numObjects <span>-</span> vm<span>-&gt;</span>numObjects<span>,</span>
</span></span></span></span></span><span><span><span><span><span>         vm<span>-&gt;</span>numObjects</span></span><span><span><span>)</span></span></span><span>;</span>
</span></span></span><span><span><span></span></span><span><span><span>}</span></span></span>
</span></code></pre>
<h2 id="pros-and-cons-of-a-copy-collector">Pros and Cons of a copy-collector</h2>
<p>So, now we have a copying collector. What did we gain, and what will we tearfully grieve?</p>
<h3 id="pro-removed-object-list-overhead">Pro: Removed object list overhead.</h3>
<p>Directly, we&#39;ve removed the overhead of an additional pointer that the VM only uses during garbage collection, which does save us 8 bytes per object, and that sort of cost per-item can turn out to be quite large.</p>
<p>But in addition to that, we&#39;ve also removed a temporal overhead in addition to a spatial overhead -- we no longer traversing a linked list, and that can be a huge change due to <a href="https://en.wikipedia.org/wiki/Cache_coherence">Cache coherency</a>. Because we&#39;re only ever stepping over an array, we won&#39;t clear the cache out, and we (potentially) might have no more issues with blowing out our memory cache and repopulating it.</p>
<p>We also have a <em>much</em> simpler allocator than your systems <code>malloc()</code>/<code>free()</code>, but we do so at the cost of that systems flexibility, as giving up any effects of hardening against possible exploitation or preventing data races. That isn&#39;t a big deal with our tiny mutator in a system that&#39;ll never go into production, but is something worth considering for more serious projects.</p>
<h3 id="pro-active-work-depends-on-the-number-of-live-objects">Pro: Active work depends on the number of live objects</h3>
<p>A mark and sweep collector needs to traverse the entire object graphs while cleaning up objects. In contrast, the copy-collector only needs to work for each of the roots, and each of the objects that has been moved into the to-heap. If we have a very large number of dead objects and a very small number of live objects, this can be a massive gain on the mark and sweep implementation.</p>
<h3 id="pro-reduces-fragmentation">Pro: Reduces fragmentation</h3>
<p>A mark and sweep garbage collector using <code>malloc()</code> (or any other allocator that deals with variably-sized data) has to content with <em>fragmentation</em> -- after long cycles of freeing and releasing memory, it&#39;s possible that we might have enough memory to allocate it, but we don&#39;t have contiguous chunks of memory that it could fit. When copying collectors move objects, they push them all to one side of the heap, meaning we now have a large contiguous area to allocate new memory from, and there&#39;s no awkwardly sized gaps.</p>
<h3 id="con-halves-the-effective-free-space">Con: Halves the effective free space</h3>
<p>All of this talk about the utility and benefits we get from cache coherency is nice and all, but we&#39;re also overlooking a bit of a big one:</p>
<p>We are only ever using half of our allocation space. The rest of it is always just sitting there, without anything to do, just dead. That&#39;s kind of a scary amount of stuff to give up -- normally when we think of overhead or potentially unusable space, it&#39;s small little chunks that add up, not a huge compromise outright.</p>
<h3 id="con-we-can-t-do-extra-work-per-deleted-object">Con: We can&#39;t do extra work per deleted object?</h3>
<p>Also a bit of a weird one, but one of the biggest benefits of bump allocators is also a weakness -- we blow away all of our unused memory with one simple command. This is perfect for the small mutator we work with, but if we were using C++ and those objects had non-trivial destructors, or we were implementing a language with <a href="https://en.wikipedia.org/wiki/Finalizer">finalizers</a>, then we lose access to all of those objects that might need to have additional code run, and we&#39;d need to add some sort of mechanism to find and walk through all of the objects that need to be destroyed.</p>
<h3 id="con-pointers-to-objects-aren-t-stable-and-we-need-to-patch-up-root-objects">Con: pointers to objects aren&#39;t stable and we need to patch up root objects.</h3>
<p>Many programming languages need to offer an ability for code that isn&#39;t handled as part of the garbage collection system, like <a href="https://docs.python.org/3/extending/extending.html">C extensions in CPython</a>. In Mark and Sweep schemes (or in CPython&#39;s case, a hybrid reference-counting/sweep scheme), pointers to objects handled by the garbage collector are stable until their free&#39;d, so you can extend your system to tell the GC that these objects should be treated as roots themselves and not be de-allocated until their marked as no-longer a root. But in a system that moves the object, we need to update any pointer to the old object to it&#39;s evacuated counterpart, and this can significantly complicate the language API.</p>
<h2 id="go-forward-and-copy">Go forward and copy</h2>
<p>And, well, that&#39;s a copying collector! Much like the original, this is a pretty trivial project and implementing this in production will probably run into huge number of bottlenecks and potential issues, but it&#39;s certainly not an unusable toy either -- this <em>was</em> cutting edge research at one point! And versions of it are used in production, like in <a href="https://youtu.be/1uLzSXWWfDg?t=818">the android runtime(Video link)</a>.</p>
<p>And also, I think this is doing some nice work describing a useful piece of low-level tech that certainly has explainers online and in textbooks, but not any as in-depth as either Nystrom&#39;s original post, nor with as nice pictures.</p>


    


</div>
  </body>
</html>
