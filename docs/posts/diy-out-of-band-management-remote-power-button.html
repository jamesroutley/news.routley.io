<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://michael.stapelberg.ch/posts/2022-10-09-remote-power-button/">Original</a>
    <h1>DIY out-of-band management: remote power button</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
  <p>I was pleasantly surprised by how easy it was to make it possible to push a PC’s
power button remotely via MQTT by wiring up an ESP32 microcontroller, a MOSFET,
a resistor, and a few jumper wires.</p>
<p>While a commercial solution like IPMI offers many more features like remote
serial, or remote image mounting, this DIY solution feels really magical, and
has great price performance if all you need is power management.</p>















<p><a href="https://michael.stapelberg.ch/posts/2022-10-09-remote-power-button/IMG_1085_featured.jpg"><img srcset="https://michael.stapelberg.ch/posts/2022-10-09-remote-power-button/IMG_1085_featured_huf7f7db33074cb268ff172c7a33b2b9a7_1568716_1200x0_resize_q75_box.jpg 2x,https://michael.stapelberg.ch/posts/2022-10-09-remote-power-button/IMG_1085_featured_huf7f7db33074cb268ff172c7a33b2b9a7_1568716_1800x0_resize_q75_box.jpg 3x" src="https://michael.stapelberg.ch/posts/2022-10-09-remote-power-button/IMG_1085_featured_huf7f7db33074cb268ff172c7a33b2b9a7_1568716_600x0_resize_q75_box.jpg" alt="The inside of a PC case, where an ESP32 micro controller on an Adafruit Perma-Proto bread board is mounted inside the case and wired up to the mainboard with jumper wires for remote power control" title="The inside of a PC case, where an ESP32 micro controller on an Adafruit Perma-Proto bread board is mounted inside the case and wired up to the mainboard with jumper wires for remote power control" width="600" height="450" loading="lazy"/></a></p><h2 id="motivation">Motivation</h2>
<p>To save power, I want to shut down my <a href="https://michael.stapelberg.ch/posts/2019-10-23-nas/">network storage PC</a> when it isn’t currently needed.</p>
<p>For this plan to work out, my daily backup automation needs to be able to turn on the network storage PC, and power it back off when done.</p>
<p>Usually, I implement that via <a href="https://en.wikipedia.org/wiki/Wake-on-LAN">Wake On LAN
(WOL)</a>. But, for this particular
machine, I don’t have an ethernet network link, I only <a href="https://michael.stapelberg.ch/posts/2020-08-09-fiber-link-home-network/">have a fiber
link</a>. Unfortunately, it seems like
none of the 3 different 10 Gbit/s network cards I tested has functioning Wake On
LAN, and when I asked on Twitter, none of my followers had ever seen functioning
WOL on any 10 Gbit/s card. I suppose it’s not a priority for the typical target
audience of these network cards, which go into always-on servers.</p>
<p>I didn’t want to run an extra 10 Gbit/s switch just for WOL over an ethernet
connection, because switches like the MikroTik CRS305-1G-4S+IN consume at least
10W. As the network storage PC only consumes about 20W overall, I wanted a more
power-efficient option.</p>
<h2 id="hardware-and-wiring">Hardware and Wiring</h2>
<p>The core of this DIY remote power button is a WiFi-enabled micro controller such
as the ESP32. To power the micro controller, I use the 5V standby power on the
mainboard’s USB 2.0 pin headers, which is also available when the PC is turned
off and only the power supply (PSU) is turned on. A micro controller with an
on-board 5V voltage regulator is convenient for this.</p>


<p>Aside from the micro controller, we also need a transistor or logic-level MOSFET
to simulate a push of the power button, and a resistor to control the
transistor. An opto coupler is not needed, since the ESP32 is powered from the
mainboard, not from a separate power supply.</p>
<p>The mainboard’s front panel header contains a <code>POWERBTN#</code> signal (3.3V), and a
<code>GND</code> signal. When connecting a typical PC case power button to the header, you
don’t need to pay attention to the polarity. This is because the power button
just physically connects the two signals.</p>
<p>In our case, the polarity matters, because we need the 3.3V on the transistor’s
drain pin, otherwise we won’t be able to control the transistor via its base
pin. The <code>POWERBTN#</code> 3.3V signal is typically labeled <code>+</code> on the mainboard (or
in the manual), whereas <code>GND</code> is labeled <code>-</code>. If you are unsure, double-check
the voltage using a multimeter.</p>
<h2 id="bill-of-materials">Bill of Materials</h2>
<ul>
<li>WiFi-enabled microcontroller with 5V power input, e.g. the <a href="https://docs.platformio.org/en/latest/boards/espressif32/pico32.html#board-espressif32-pico32">Espressif ESP32
Pico
Kit</a></li>
<li>transistor or logic-level MOSFET for working with 3.3V, e.g. <a href="https://www.digikey.com/en/products/detail/onsemi/2N7000/244278">2N7000
(→digikey)</a></li>
<li>1K resistor for controlling the transistor,
e.g. <a href="https://www.digikey.com/en/products/detail/stackpole-electronics-inc/CF14JT1K00/1741314">CF14JT1K00</a></li>
<li>a bread board and/or case for mounting, e.g. <a href="https://www.adafruit.com/product/571">Adafruit
Perma-Proto</a>.</li>
</ul>
<h2 id="schematic">Schematic</h2>
<p><a href="https://michael.stapelberg.ch/posts/2022-10-09-remote-power-button/2022-10-08-remote-power-button.svg"><img src="https://michael.stapelberg.ch/posts/2022-10-09-remote-power-button/2022-10-08-remote-power-button.svg" width="100%"/></a></p>
<h2 id="software-esphome">Software: ESPHome</h2>
<p>I wanted a quick solution (with ideally no custom firmware development) and was
already familiar with <a href="https://esphome.io/">ESPHome</a>, which turns out to very
easily implement the functionality I wanted :)</p>
<p>In addition to a standard ESPHome configuration, I have added the following
lines to make the GPIO pin available through MQTT, and make it a momentary
switch instead of a toggle switch, so that it briefly presses the power button
and doesn’t hold the power button:</p>
<div><pre tabindex="0"><code data-lang="yaml"><span><span><span>switch</span>:<span>
</span></span></span><span><span><span>  </span>- <span>platform</span>:<span> </span>gpio<span>
</span></span></span><span><span><span>    </span><span>pin</span>:<span> </span><span>25</span><span>
</span></span></span><span><span><span>    </span><span>id</span>:<span> </span>powerbtn<span>
</span></span></span><span><span><span>    </span><span>name</span>:<span> </span><span>&#34;powerbtn&#34;</span><span>
</span></span></span><span><span><span>    </span><span>restore_mode</span>:<span> </span>ALWAYS_OFF<span>
</span></span></span><span><span><span>    </span><span>on_turn_on</span>:<span>
</span></span></span><span><span><span>    </span>- <span>delay</span>:<span> </span>500ms<span>
</span></span></span><span><span><span>    </span>- <span>switch.turn_off</span>:<span> </span>powerbtn<span>
</span></span></span></code></pre></div><p>I have elided the full configuration for brevity, but you can click here to see it:</p>
<details>
<summary>full ESPHome YAML configuration</summary>
<div><pre tabindex="0"><code data-lang="yaml"><span><span><span>esphome</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>poweresp<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>esp32</span>:<span>
</span></span></span><span><span><span>  </span><span>board</span>:<span> </span>pico32<span>
</span></span></span><span><span><span>  </span><span>framework</span>:<span>
</span></span></span><span><span><span>    </span><span>type</span>:<span> </span>arduino<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span># Enable logging</span><span>
</span></span></span><span><span><span></span><span>logger</span>:<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>mqtt</span>:<span>
</span></span></span><span><span><span>  </span><span>broker</span>:<span> </span><span>10.0.0.54</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>ota</span>:<span>
</span></span></span><span><span><span>  </span><span>password</span>:<span> </span><span>&#34;&#34;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>wifi</span>:<span>
</span></span></span><span><span><span>  </span><span>ssid</span>:<span> </span><span>&#34;essid&#34;</span><span>
</span></span></span><span><span><span>  </span><span>password</span>:<span> </span><span>&#34;secret&#34;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>  </span><span># Enable fallback hotspot (captive portal) in case wifi connection fails</span><span>
</span></span></span><span><span><span>  </span><span>ap</span>:<span>
</span></span></span><span><span><span>    </span><span>ssid</span>:<span> </span><span>&#34;Poweresp Fallback Hotspot&#34;</span><span>
</span></span></span><span><span><span>    </span><span>password</span>:<span> </span><span>&#34;secret2&#34;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>captive_portal</span>:<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>switch</span>:<span>
</span></span></span><span><span><span>  </span>- <span>platform</span>:<span> </span>gpio<span>
</span></span></span><span><span><span>    </span><span>pin</span>:<span> </span><span>25</span><span>
</span></span></span><span><span><span>    </span><span>id</span>:<span> </span>powerbtn<span>
</span></span></span><span><span><span>    </span><span>name</span>:<span> </span><span>&#34;powerbtn&#34;</span><span>
</span></span></span><span><span><span>    </span><span>restore_mode</span>:<span> </span>ALWAYS_OFF<span>
</span></span></span><span><span><span>    </span><span>on_turn_on</span>:<span>
</span></span></span><span><span><span>    </span>- <span>delay</span>:<span> </span>500ms<span>
</span></span></span><span><span><span>    </span>- <span>switch.turn_off</span>:<span> </span>powerbtn<span>
</span></span></span></code></pre></div></details>
<p>For the first flash, I used:</p>
<pre tabindex="0"><code>docker run --rm \
  -v &#34;${PWD}&#34;:/config \
  --device=/dev/ttyUSB0 \
  -it \
  esphome/esphome \
    run poweresp.yaml
</code></pre><p>To update over the network after making changes (serial connection no longer needed), I used:</p>
<pre tabindex="0"><code>docker run --rm \
  -v &#34;${PWD}&#34;:/config \
  -it \
  esphome/esphome \
    run poweresp.yaml
</code></pre><p>In case you want to learn more about the relevant ESPHome concepts, here are a
few pointers:</p>
<ul>
<li><a href="https://esphome.io/components/wifi.html">https://esphome.io/components/wifi.html</a> might need to set <code>use_address</code></li>
<li><a href="https://esphome.io/components/switch/index.html">https://esphome.io/components/switch/index.html</a>
<ul>
<li>and <a href="https://esphome.io/components/switch/gpio.html">https://esphome.io/components/switch/gpio.html</a></li>
</ul>
</li>
<li><a href="https://esphome.io/components/mqtt.html">https://esphome.io/components/mqtt.html</a></li>
</ul>
<h2 id="integration-into-automation">Integration into automation</h2>
<p>To push the power button remotely from Go, I’m using the following code:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>pushMainboardPower</span>(mqttBroker, clientID <span>string</span>) <span>error</span> {
</span></span><span><span>	opts <span>:=</span> mqtt.<span>NewClientOptions</span>().<span>AddBroker</span>(mqttBroker)
</span></span><span><span>	<span>if</span> hostname, err <span>:=</span> os.<span>Hostname</span>(); err <span>==</span> <span>nil</span> {
</span></span><span><span>		clientID <span>+=</span> <span>&#34;@&#34;</span> <span>+</span> hostname
</span></span><span><span>	}
</span></span><span><span>	opts.<span>SetClientID</span>(clientID)
</span></span><span><span>	opts.<span>SetConnectRetry</span>(<span>true</span>)
</span></span><span><span>	mqttClient <span>:=</span> mqtt.<span>NewClient</span>(opts)
</span></span><span><span>	<span>if</span> token <span>:=</span> mqttClient.<span>Connect</span>(); token.<span>Wait</span>() <span>&amp;&amp;</span> token.<span>Error</span>() <span>!=</span> <span>nil</span> {
</span></span><span><span>		<span>return</span> fmt.<span>Errorf</span>(<span>&#34;connecting to MQTT: %v&#34;</span>, token.<span>Error</span>())
</span></span><span><span>	}
</span></span><span><span>
</span></span><span><span>	<span>const</span> topic = <span>&#34;poweresp/switch/powerbtn/command&#34;</span>
</span></span><span><span>	<span>const</span> qos = <span>0</span> <span>// at most once (no re-transmissions)
</span></span></span><span><span><span></span>	<span>const</span> retained = <span>false</span>
</span></span><span><span>	token <span>:=</span> mqttClient.<span>Publish</span>(topic, qos, retained, <span>string</span>(<span>&#34;on&#34;</span>))
</span></span><span><span>	<span>if</span> token.<span>Wait</span>() <span>&amp;&amp;</span> token.<span>Error</span>() <span>!=</span> <span>nil</span> {
</span></span><span><span>		<span>return</span> fmt.<span>Errorf</span>(<span>&#34;publishing to MQTT: %v&#34;</span>, token.<span>Error</span>())
</span></span><span><span>	}
</span></span><span><span>
</span></span><span><span>	<span>return</span> <span>nil</span>
</span></span><span><span>}
</span></span></code></pre></div><h2 id="conclusion">Conclusion</h2>
<p>I hope this small project write-up is useful to others in a similar situation!</p>
<p>If you need more features than that, check out the next step on the feature and
complexity ladder: <a href="https://pikvm.org/">PiKVM</a> or
<a href="https://tinypilotkvm.com/">TinyPilot</a>. See also <a href="https://www.jeffgeerling.com/blog/2021/raspberry-pi-kvms-compared-tinypilot-and-pi-kvm-v3">this comparison by Jeff
Geerling</a>.</p>

</div></div>
  </body>
</html>
