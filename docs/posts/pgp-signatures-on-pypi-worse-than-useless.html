<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.yossarian.net/2023/05/21/PGP-signatures-on-PyPI-worse-than-useless">Original</a>
    <h1>PGP signatures on PyPI: worse than useless</h1>
    
    <div id="readability-page-1" class="page">


<h2><em>Programming, philosophy, pedaling.</em></h2>

<ul>
    <li><a href="https://blog.yossarian.net/">Home</a></li>
    <li><a href="https://blog.yossarian.net/tags">Tags</a></li>
    <li><a href="https://blog.yossarian.net/series">Series</a></li>
    <li><a href="https://blog.yossarian.net/favorites">Favorites</a></li>
    <li><a href="https://blog.yossarian.net/archive">Archive</a></li>
    
      <li><a href="https://yossarian.net">Main Site</a></li>
    
</ul>

<hr/>



<h2>
  <p>
    <span><em>May 21, 2023</em></span>

       

    
      <span>
        Tags:
        
        
          <a href="https://blog.yossarian.net/tags#cryptography">cryptography</a>,
        
          <a href="https://blog.yossarian.net/tags#devblog">devblog</a>,
        
          <a href="https://blog.yossarian.net/tags#programming">programming</a>,
        
          <a href="https://blog.yossarian.net/tags#python">python</a>,
        
          <a href="https://blog.yossarian.net/tags#rant">rant</a>
        
      </span>
    

       

    
  </p>
</h2>

<hr/>

<p>TL;DR: A large number of PGP signatures on PyPI <strong>can’t be correlated</strong> to any well-known
PGP key and, of the signatures that can be correlated, many are generated from <strong>weak keys or
malformed certificates</strong>. The results suggest widespread misuse of GPG and other PGP implementations by Python
packagers, with said misuse being encouraged by the PGP ecosystem’s poor defaults, opaque
and user-hostile interfaces, and
<a href="https://gnupg.org/faq/gnupg-faq.html#define_dsa">outright dangerous recommendations</a>.</p>

<h3 id="preword">Preword</h3>

<p>I’ve been sitting on this post for a few months, in part because of travel
and in part because its (intended) scope was beginning to reflect PGP’s own fractal complexity.</p>

<p>The version that I’m publishing now has been <strong>significantly pared down</strong> to remove extended
digressions on how bad PGP’s packet format is, all the different ways in which a signature or
certificate packet can be broken, incorrectly bound, &amp;c.</p>

<p>I’ve removed those things because I think the results, as present, are <strong>sufficient evidence</strong>
for the actual claims I’d like to make, namely:</p>

<ol>
  <li>
    <p>That existing PGP signatures on PyPI serve no security purpose, and that all evidence
points to <strong>nobody ever attempting to verify them</strong>;</p>
  </li>
  <li>
    <p>Even advanced technical communities, as a whole, <strong>largely fail to reduce PGP’s complexity
and unnecessary agility</strong> into a reasonable and tractable subset.</p>
  </li>
</ol>

<p>And, just in case it needs to be said:</p>

<ol>
  <li>
    <p>This post isn’t intended to disparage PyPI: PyPI has <strong>done everything right</strong>, including
<a href="https://github.com/pypi/warehouse/issues/3356">purposely removing frontend support for PGP years ago</a>.</p>
  </li>
  <li>
    <p>This post isn’t intended to disparage individual packagers and maintainers still uploading
signatures to PyPI. I suspect that much of the ongoing signature uploading is a result
of long-forgotten automation and, even when it isn’t: developers <strong>cannot</strong> be blamed for
their misuse of obtuse tools. Security tools, <em>especially</em> cryptographic ones, are
<strong>only as good as their least-informed<sup id="fnref:domain" role="doc-noteref"><a href="#fn:domain" rel="footnote">1</a></sup> and most distracted user</strong>.</p>
  </li>
</ol>

<hr/>

<h2 id="background">Background</h2>

<p>PyPI has supported PGP signatures in some form or another for a very long time<sup id="fnref:time" role="doc-noteref"><a href="#fn:time" rel="footnote">2</a></sup>.</p>

<p>To this date, PGP is still (minimally) supported: package uploaders can still sign for their package
distributions and upload the resulting <code>.asc</code> to PyPI for inclusion in the index. The
<a href="https://twine.readthedocs.io/en/stable/">official uploading utility</a> even supports invoking
<code>gpg</code> directly via the <code>--sign</code> and <code>--sign-with</code> arguments!</p>

<p>To a novice Python programmer looking to publish their first package to PyPI, this might give the
following impressions:</p>

<ol>
  <li>That PGP offers secure and modern cryptographic primtives;</li>
  <li>That PyPI <em>encourages</em> users to upload PGP signatures or that doing so is <em>best practice</em>;</li>
  <li>That <em>others</em> expect PGP signatures, and that package adoption is (in part) predicated
on supplying PGP signatures.</li>
</ol>

<p>The first two are <em>just wrong</em>:</p>

<ol>
  <li>
    <p>PGP is an <a href="https://latacora.micro.blog/2019/07/16/the-pgp-problem.html">insecure</a> and
<a href="https://moxie.org/2015/02/24/gpg-and-me.html">outdated</a> ecosystem that hasn’t reflected
cryptographic best practices
<a href="https://blog.cryptographyengineering.com/2014/08/13/whats-matter-with-pgp/">in decades</a>.</p>
  </li>
  <li>
    <p>PyPI’s support is vestigial in nature: signatures are not shown as part of the web interface,
and are only obliquely referenced in the <a href="https://peps.python.org/pep-0503/">PEP 503</a> and JSON
APIs.</p>
  </li>
</ol>

<p>The third is harder to immediately refute: PyPI still hosts signatures, after all. Absent any
other information, it’s <em>entirely possible</em> that companies and end users are quietly and diligently
verifying whatever signatures are present, using trust sets, tracking revoked and expired keys,
and so forth.</p>

<p>Thus, my goal with this blog post:</p>

<ol>
  <li>Determine <em>how many</em> signatures are on PyPI;</li>
  <li>Correlate those signatures to their signing keys;</li>
  <li>Analyze those signing keys for their practical value: their strength, liveness, &amp;c.</li>
</ol>

<h2 id="methodology">Methodology</h2>

<p>Relatively early in the process I decided not to collect <em>every single</em> signature on PyPI,
for two main reasons:</p>

<ol>
  <li>
    <p>Relevance: PyPI hosts many old package distributions, including distributions
for Python 2.7 (and earlier!). Given that Python 2 has been EOL for over three years at
this point, it didn’t feel relevant (or efficient) to retrieve large quantities of
signatures that nobody is likely to ever try install the distributions for.</p>
  </li>
  <li>
    <p>Fairness: both PGP and Python have a lot of history, much of which predates
modern understandings around cryptographic best practices.
Given that, it didn’t feel <em>fair</em> to analyze extremely old
signatures, especially if doing so would bias the statistics away from newer users
who are doing more responsible things.</p>
  </li>
</ol>

<p>Given these considerations, I decided to limit my analysis to <em>only signatures uploaded to PyPI
on or after <strong>2020-03-27</strong></em>. I chose that date somewhat arbitrarily<sup id="fnref:arbitrary" role="doc-noteref"><a href="#fn:arbitrary" rel="footnote">3</a></sup> while
also satisfying a few constraints:</p>

<ul>
  <li>
    <p>It’s well after the 2018 deployment of the <a href="https://github.com/pypi/warehouse">new PyPI</a>,
which didn’t emphasize support for PGP signatures (while still retaining it). In other words:
signatures uploaded in 2020 or later were either done by automation (implying some degree
of sophistication) <em>or</em> were likely a conscious decision by a packager to continue signing
with PGP.</p>
  </li>
  <li>
    <p>It’s <em>very</em> recent, and best practices around digital signatures have not changed
substantially since 2020. In other words: a best-practices signature (and key) made in 2020
should look very similar to a best-practices signature (and key) made in 2023, and someone
signing in 2020 would have no good excuses for not making reasonable choices.</p>
  </li>
</ul>

<p>Actually retrieving the signatures was a multi-step process. To start, I used
<a href="https://packaging.python.org/en/latest/guides/analyzing-pypi-package-downloads/">PyPI’s BigQuery dataset</a>
to give me some basic metadata on every distribution file with an associated signature:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
</pre></td><td><pre><span>SELECT</span> <span>name</span><span>,</span> <span>version</span><span>,</span> <span>filename</span><span>,</span> <span>python_version</span><span>,</span> <span>blake2_256_digest</span>
<span>FROM</span> <span>`bigquery-public-data.pypi.distribution_metadata`</span>
<span>WHERE</span> <span>has_signature</span>
<span>AND</span> <span>upload_time</span> <span>&gt;</span> <span>TIMESTAMP</span><span>(</span><span>&#34;2020-03-27 00:00:00&#34;</span><span>)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>This produced 52900 distributions uploaded since 2020-03-27 for which PyPI also
had a signature (subtract 1 for the CSV header):</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
</pre></td><td><pre><span>$ </span><span>wc</span> <span>-l</span> inputs/dists-with-signatures.csv
52901 inputs/dists-with-signatures.csv

<span>$ </span><span>head</span> <span>-2</span> inputs/dists-with-signatures.csv
name,version,filename,python_version,blake2_256_digest
pantsbuild.pants.testutil,1.30.0,pantsbuild.pants.testutil-1.30.0-py36.py37.py38-none-any.whl,py36.py37.py38,7ecbe47906ddbe8a2f1ee2505c2edb7f9313348d4925855e429be1d316660a00
</pre></td></tr></tbody></table></code></pre></div></div>

<p>From here, I needed to retrieve each release distribution’s detached signature, i.e.
the adjacent <code>.asc</code> URL in PyPI’s object storage.</p>

<p>I initially did this with the “conveyor” service, which turns
<a href="https://peps.python.org/pep-0491/#file-name-convention">PEP 491</a> names into URLs like so:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre>https://files.pythonhosted.org/packages/source/{version}/{name[0]}/{name}/{dist}.asc
</pre></td></tr></tbody></table></code></pre></div></div>

<p>However, this was pretty lossy: for whatever reason<sup id="fnref:version" role="doc-noteref"><a href="#fn:version" rel="footnote">4</a></sup> my URLs were slightly off about 20% of the
time, resulting in lots of missed signatures. I eventually realized that the BigQuery dataset
<em>also</em> includes the Blake2 digest for each distribution, meaning that I could use the <em>actual</em>
package URLs instead:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre>https://files.pythonhosted.org/packages/{digest[0:2]}/{digest[2:4]}/{digest[4:]}/{dist}.asc
</pre></td></tr></tbody></table></code></pre></div></div>

<p>…and this was perfectly reliable.</p>

<p>From here, I wanted to figure out (roughly) how many unique keys produced these ~50k signatures.
I decided to use PGPy<sup id="fnref:mistake" role="doc-noteref"><a href="#fn:mistake" rel="footnote">5</a></sup> for that; excerpted from <a href="https://github.com/woodruffw/pypi-pgp-statistics/blob/main/dists-by-keyid.py"><code>dists-by-keyid.py</code></a>:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td><pre><span>sig</span> <span>=</span> <span>pgpy</span><span>.</span><span>PGPSignature</span><span>.</span><span>from_blob</span><span>(</span><span>sig_resp</span><span>.</span><span>content</span><span>)</span>
<span>try</span><span>:</span>
    <span># https://github.com/SecurityInnovation/PGPy/issues/433
</span>    <span>sig</span>
    <span>sig</span><span>.</span><span>signer</span>
<span>except</span> <span>AttributeError</span><span>:</span>
    <span>print</span><span>(</span><span>&#34;barf: couldn&#39;t get signer, probably ancient&#34;</span><span>,</span> <span>file</span><span>=</span><span>sys</span><span>.</span><span>stderr</span><span>)</span>
    <span>_KEY_ID_MAP</span><span>[</span><span>&#34;&lt;invalid signer&gt;&#34;</span><span>].</span><span>append</span><span>(</span><span>rec</span><span>)</span>
    <span>continue</span>

<span>_KEY_ID_MAP</span><span>[</span><span>sig</span><span>.</span><span>signer</span><span>].</span><span>append</span><span>(</span><span>rec</span><span>)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>This left me with a big map of PGP key IDs<sup id="fnref:keyid" role="doc-noteref"><a href="#fn:keyid" rel="footnote">6</a></sup> to a list of distributions
signed by them, including 26 distributions whose signatures PGPy couldn’t parse:</p>

<table>
  <tbody><tr>
    
    <th>Package name</th>
    
    <th>Distribution count</th>
    
  </tr>
  
  <tr>
    
    <td>agraph-python</td>
    
    <td>2</td>
    
  </tr>
  
  <tr>
    
    <td>excerpt-html</td>
    
    <td>4</td>
    
  </tr>
  
  <tr>
    
    <td>lektor-index-pages</td>
    
    <td>6</td>
    
  </tr>
  
  <tr>
    
    <td>lektor-expression-type</td>
    
    <td>2</td>
    
  </tr>
  
  <tr>
    
    <td>lektor-git-timestamp</td>
    
    <td>2</td>
    
  </tr>
  
  <tr>
    
    <td>lektor-datetime-helpers</td>
    
    <td>3</td>
    
  </tr>
  
  <tr>
    
    <td>lektor-limit-dependencies</td>
    
    <td>2</td>
    
  </tr>
  
  <tr>
    
    <td>lektorlib</td>
    
    <td>2</td>
    
  </tr>
  
  <tr>
    
    <td>lektor-polymorphic-type</td>
    
    <td>3</td>
    
  </tr>
  
</tbody></table>

<p>This is a tiny failure (26 distributions out of 52900, or roughly 0.5%), but it
sets the tone for the rest of the post.</p>

<p>Apart from these 26 failures, the remaining 52874 signatures were produced from
1067 “unique”<sup id="fnref:unique" role="doc-noteref"><a href="#fn:unique" rel="footnote">7</a></sup> PGP keys.</p>

<h2 id="results">Results</h2>

<p>At this point, I had 1067 unique <em>key IDs</em>, each of which needed to be retrieved
from a keyserver.</p>

<p>My expectation was that this wouldn’t be a significant challenge,
despite the <a href="https://gist.github.com/rjhansen/67ab921ffb4084c865b3618d6955275f">widely publicized implosion</a> of the SKS keyserver network back in
2018: there are still a few <a href="https://keys.openpgp.org/">major</a>
<a href="https://keyserver.ubuntu.com/">keyservers</a> running, and package authors
pushing to PyPI <em>should</em> have the presence of mind to upload their keys. Right?</p>

<p><img src="https://blog.yossarian.net/assets/what-me-worry.jpeg" alt=""/>
<em>Pictured: your author immediately before trying to retrieve PGP keys in 2023.</em></p>

<p><strong>Wrong</strong>. Of the 1067 keys IDs collected through signatures on PyPI, a full <strong>308</strong>
(or roughly <strong>29%</strong>) had <em>no publicly discoverable key</em> on the major remaining
keyservers. In other words: roughly 1/3rd of all signatures added to PyPI <em>since 2020</em>
are bound to keys that aren’t discoverable by the PGP ecosystem’s own tooling.
They <em>might</em> exist, hidden on personal domains and documentation pages, but, for
all intents and purposes, these 29% of keys are <strong>useless</strong><sup id="fnref:easy" role="doc-noteref"><a href="#fn:easy" rel="footnote">8</a></sup>.</p>

<p>So, our first graphic of the post: discoverable keys versus undiscoverable ones:</p>

<p><img src="https://blog.yossarian.net/assets/pgp-disco.png" alt=""/>
<em>Pictured: a very normal and healthy signing ecosystem.</em></p>

<p>That left 759 discovered keys to <em>actually</em> audit. To keep things
simple<sup id="fnref:pgpkeydump" role="doc-noteref"><a href="#fn:pgpkeydump" rel="footnote">9</a></sup>, I limited my analysis to just the following considerations:</p>

<ul>
  <li>
    <p>Does the key’s certificate have a binding signature<sup id="fnref:binding" role="doc-noteref"><a href="#fn:binding" rel="footnote">10</a></sup>?</p>
  </li>
  <li>
    <p>What algorithm does the key use?</p>
    <ul>
      <li>Additionally, if it’s a subkey, what algorithm does the primary key use?</li>
      <li>For RSA keys, what parameters does the key use?</li>
    </ul>
  </li>
</ul>

<p>If that seems like a limited analysis, it’s because it is: there are <em>too many
ways</em> to produce a weirdly shaped PGP certificate and/or key packet sequence,
and the existing tooling (things like <a href="(https://github.com/kazu-yamamoto/pgpdump)"><code>pgpdump</code></a>
and <a href="https://www.mailpile.is/blog/2014-10-07_Some_Thoughts_on_GnuPG.html"><code>pgp --with-colons</code></a>) weren’t up to the task.</p>

<p>Instead, <a href="https://blog.yossarian.net/2023/04/14/Introducing-pgpkeydump">I wrote a little tool</a> (<a href="https://github.com/woodruffw/pgpkeydump"><code>pgpkeydump</code></a>) to give me machine-readable
dumps of PGP keys<sup id="fnref:certs" role="doc-noteref"><a href="#fn:certs" rel="footnote">11</a></sup>, and then wrapped it in a <a href="https://github.com/woodruffw/pypi-pgp-statistics/blob/main/key-audit.py">bulk auditing script</a>
that does some basic statistics on the results.</p>

<p>To summarize the results:</p>

<ul>
  <li>Of the 759 discovered keys, <strong>298</strong> (<strong>39%</strong>) had no binding signature at their specified
creation time. In other words: these keys’ certificates came with no verifiable proof for
an associated identity, expiry, or <em>any</em> of the other basic metadata conceptually associated
with a PGP key, including its intended purpose.</li>
  <li><strong>375</strong> (<strong>49%</strong>) had no binding signature at the time of the audit (2023-05-19), meaning that
any binding signature that was present had already expired. In other words: <strong>half of all
keys used to sign on PyPI since 2020 are already expired</strong>. This strongly suggests that
nobody is attempting to verify signatures from PyPI on any meaningful scale.</li>
</ul>

<p>Then, on the algorithm and parameter sides<sup id="fnref:missing" role="doc-noteref"><a href="#fn:missing" rel="footnote">12</a></sup>:</p>

<p>Primary keys:</p>

<table>
  <tbody><tr>
    
    <th>Key type</th>
    
    <th>Count</th>
    
  </tr>
  
  <tr>
    
    <td>RSA-4096</td>
    
    <td>497</td>
    
  </tr>
  
  <tr>
    
    <td>RSA-2048</td>
    
    <td>127</td>
    
  </tr>
  
  <tr>
    
    <td>RSA-3072</td>
    
    <td>45</td>
    
  </tr>
  
  <tr>
    
    <td>DSA-1024</td>
    
    <td>40</td>
    
  </tr>
  
  <tr>
    
    <td>EdDSA</td>
    
    <td>35</td>
    
  </tr>
  
  <tr>
    
    <td>DSA-3072</td>
    
    <td>7</td>
    
  </tr>
  
  <tr>
    
    <td>DSA-2048</td>
    
    <td>4</td>
    
  </tr>
  
  <tr>
    
    <td>NIST P-521</td>
    
    <td>1</td>
    
  </tr>
  
  <tr>
    
    <td>RSA-4064</td>
    
    <td>1</td>
    
  </tr>
  
  <tr>
    
    <td>RSA-4032</td>
    
    <td>1</td>
    
  </tr>
  
</tbody></table>

<p>“Effective”<sup id="fnref:effective" role="doc-noteref"><a href="#fn:effective" rel="footnote">13</a></sup> keys:</p>

<table>
  <tbody><tr>
    
    <th>RSA-4096</th>
    
    <th>471</th>
    
  </tr>
  
  <tr>
    
    <td>RSA-2048</td>
    
    <td>151</td>
    
  </tr>
  
  <tr>
    
    <td>RSA-3072</td>
    
    <td>47</td>
    
  </tr>
  
  <tr>
    
    <td>EdDSA</td>
    
    <td>43</td>
    
  </tr>
  
  <tr>
    
    <td>DSA-1024</td>
    
    <td>31</td>
    
  </tr>
  
  <tr>
    
    <td>DSA-3072</td>
    
    <td>7</td>
    
  </tr>
  
  <tr>
    
    <td>DSA-2048</td>
    
    <td>5</td>
    
  </tr>
  
  <tr>
    
    <td>NIST P-521</td>
    
    <td>1</td>
    
  </tr>
  
  <tr>
    
    <td>brainpoolP512r1</td>
    
    <td>1</td>
    
  </tr>
  
  <tr>
    
    <td>RSA-4032</td>
    
    <td>1</td>
    
  </tr>
  
</tbody></table>

<p>Or again, as pretty charts:</p>

<p><img src="https://blog.yossarian.net/assets/pgp-primary-keys-by-type.png" alt=""/></p>

<p><img src="https://blog.yossarian.net/assets/pgp-effective-keys-by-type.png" alt=""/></p>

<p>First, the “good” parts:</p>

<ol>
  <li>While <a href="https://www.youtube.com/watch?v=lElHzac8DDI">normally a bad choice</a>, RSA is <em>literally</em>
the best you can do in terms of standard<sup id="fnref:rfc4880" role="doc-noteref"><a href="#fn:rfc4880" rel="footnote">14</a></sup> asymmetric signing algorithms in PGP. Over
two thirds of keys used to sign on PyPI are using it, and they’re using reasonable<sup id="fnref:rsa-size" role="doc-noteref"><a href="#fn:rsa-size" rel="footnote">15</a></sup>
key sizes (4096 and 3072).</li>
</ol>

<p>Then, the meh:</p>

<ol>
  <li>
    <p>A sizeable minority (20% of effective keys, and 17% of primary keys) are RSA-2048.
NIST considers RSA-2048 to be equivalent to roughly 112 bits of security<sup id="fnref:discouraged" role="doc-noteref"><a href="#fn:discouraged" rel="footnote">16</a></sup>, and
<a href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar2.pdf">does not recommend</a> its use on data that’s expected to have a security life
of 15 years…<strong>starting in 2015</strong>. That means that PyPI-hosted signatures against RSA-2048 keys
have roughly 7 years of “shelf life” in them. Version turnover in packaging ecosystems
has accelerated over the last decade; let’s hope that applies here too!</p>
  </li>
  <li>
    <p>Some enterprising people are on the <a href="https://datatracker.ietf.org/doc/html/draft-ietf-openpgp-rfc4880bis-10">“bleeding edge”</a>: they’re using
EdDSA and a few different ECDSA curves. It’s hard to say whether this is good or bad: it’s
good in the sense that these are <em>almost certainly</em> better than anything offered by
strictly RFC 4880 PGP implementations, but pointless in the sense that support for verifying
these signatures is limited<sup id="fnref:limited" role="doc-noteref"><a href="#fn:limited" rel="footnote">17</a></sup> to just a few clients. It’s also probably
pointlessly slow (for P-521 and brainpoolP512r1 in particular).</p>
  </li>
</ol>

<p>And finally, the insane:</p>

<ul>
  <li>
    <p>Roughly 5% of all keys used to sign for packages on PyPI are DSA. The majority
of those are DSA-1024, which is roughly equivalent in strength to RSA-1024.
<a href="https://buttondown.email/cryptography-dispatches/archive/cryptography-dispatches-dsa-is-past-its-prime/">DSA of any size is already very bad</a>,
and DSA-1024 is <em>well</em> outside of any acceptable safety margin for signatures in
2023, much less 2020 or even 2010.</p>
  </li>
  <li>
    <p>RSA-4064 and RSA-4032. I have no idea why anyone would do this<sup id="fnref:checking" role="doc-noteref"><a href="#fn:checking" rel="footnote">18</a></sup>. Maybe some
misguided attempt to calculate a precise security margin, or a misreading of someone else’s
recommendations?</p>
  </li>
  <li>
    <p>One of the RSA-2048 keys has a public exponent of <code>41</code>, rather than <code>65537</code> (which <em>every other
RSA key in the dataset uses</em>). Again, I have no idea why anyone would do this: it’s pointlessly
slower and opens up padding concerns that <code>e = 65537</code> is resilient against.</p>
  </li>
</ul>

<h2 id="takeaways">Takeaways</h2>

<p>To summarize: of <em>just</em> the PGP signatures uploaded to PyPI in the last three years:</p>

<ul>
  <li>A small handful (26) are so malformed or old that they can’t be correlated to a key ID;</li>
  <li>Of those that can be correlated to a key ID, <strong>nearly a third cannot be discovered</strong>
through the PGP ecosystem’s <em>intended key discovery mechanism</em>;</li>
  <li>
    <p>Of the remaining discoverable keys:</p>

    <ul>
      <li>
        <p>Nearly half (<strong>49%</strong>) have no active binding signature when retrieved from
a keyserver, giving them indefinite (at the absolute best) identity properties.</p>
      </li>
      <li>
        <p>A sizeable minority (<strong>20%</strong>) are using weak RSA keys with less than a decade
before NIST considers them insecure.</p>
      </li>
      <li>
        <p>A smaller but still appreciable minority (<strong>5%</strong>) are using DSA-1024 keys,
which have been considered insecure for well over a decade.</p>
      </li>
    </ul>
  </li>
</ul>

<p>By all rights, these numbers represent the <strong>best possible case</strong> for PGP signatures on
PyPI. Expanding the audit to 2015 or even earlier would likely reveal far worse practices.</p>

<p>In one sense, none of this is a problem: the breadth and depth of issues here
suggests that <strong>nobody (thankfully!) is actually relying on these signatures</strong>,
and the continued presence of new signatures on PyPI is primarily a vestige of
forgotten automation and outdated tutorials.</p>

<p>On the other hand, these results present a strong case against attempting
to “rehabilitate” PGP signatures for PyPI, or any other packaging ecosystem:
all evidence points to end users (i.e., signers) being unable<sup id="fnref:fault" role="doc-noteref"><a href="#fn:fault" rel="footnote">19</a></sup> to distinguish
between the “good” and “bad” parts of PGP, much less <em>use</em> them at all (e.g. keyservers).</p>

<p>So, for final conclusions:</p>

<ul>
  <li>Given how broken the PGP signatures and keys present on PyPI are, it’s <em>unlikely</em> that anybody
is currently doing wide-scale verification against them.</li>
  <li>If anybody is (and I’d be interested to hear if you are!), then it’s almost certainly
<em>inadvisable</em>: “verifying” these signatures is, on average, likely to provide a
<em>false degree</em> of confidence in their value.</li>
</ul>

<p>As with previous posts, I’ve tried to make my steps and data reproducible, and have
checked them all into <a href="https://github.com/woodruffw/pypi-pgp-statistics">this repo</a>. I welcome any discoveries of mistakes I’ve made, as
well as any attempts to improve the overall detail or fidelity of the results!</p>

<hr/>




<hr/>


<span>
  Discussions:
  
  <a href="https://reddit.com/r/enosuchblog/comments/13nvtw2/pgp_signatures_on_pypi_worse_than_useless/">Reddit</a>
  
  <a href="https://infosec.exchange/@yossarian/110407034911802514">Mastodon</a>
  
  <a href="https://bsky.app/profile/yossarian.net/post/3jwan7odmcv2x">Bluesky</a>
  
</span>
<hr/>



  






</div>
  </body>
</html>
