<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.swift.org/blog/announcing-swift-homomorphic-encryption/">Original</a>
    <h1>Swift Homomorphic Encryption</h1>
    
    <div id="readability-page-1" class="page"><div role="main">
<article>
  <header>
    

    <time pubdate="" datetime="2024-07-30T06:00:00-04:00">July 30, 2024</time>
    
  </header>

  <p>We’re excited to announce a new open source Swift package for homomorphic
encryption in Swift:
<a href="https://github.com/apple/swift-homomorphic-encryption">swift-homomorphic-encryption</a>.</p>

<p>Homomorphic encryption (HE) is a cryptographic technique that enables
computation on encrypted data <em>without</em> revealing the underlying unencrypted
data to the operating process. It provides a means for clients to send encrypted
data to a server, which operates on that encrypted data and returns a result
that the client can decrypt. During the execution of the request, the server
itself never decrypts the original data or even has access to the decryption
key. Such an approach presents new opportunities for cloud services to operate
while protecting the privacy and security of a user’s data, which is obviously
highly attractive for many scenarios.</p>

<p>At Apple, we’re using homomorphic encryption in our own work; we’re therefore
delighted to share this Swift implementation in the community for others to use
and contribute to.</p>

<p>One example of how we’re using this implementation in iOS 18, is the new <a href="https://developer.apple.com/documentation/sms_and_call_reporting/getting_up-to-date_calling_and_blocking_information_for_your_app">Live
Caller ID
Lookup</a>
feature, which provides caller ID and spam blocking services. Live Caller ID
Lookup uses homomorphic encryption to send an encrypted query to a server that
can provide information about a phone number without the server knowing the
specific phone number in the request. To demonstrate this, we are also sharing
<a href="https://github.com/apple/live-caller-id-lookup-example">live-caller-id-lookup-example</a>,
which provides a functional example backend to test the Live Caller ID Lookup
feature using homomorphic encryption.</p>

<p>These two packages take full advantage of features such as:</p>
<ul>
  <li><a href="https://www.swift.org/documentation/server/">Swift on Server</a>, including the Hummingbird HTTP framework and cross-platform support</li>
  <li>easy benchmarking with the <a href="https://github.com/ordo-one/package-benchmark">Benchmark</a> library</li>
  <li>performant low-level cryptography primitives in <a href="https://github.com/apple/swift-crypto">Swift Crypto</a>.</li>
</ul>


<p>Live Caller ID Lookup relies on <em>Private Information Retrieval (PIR)</em>, a form of private key-value database lookup.
In the PIR setting, a client has a private keyword (such as a phone number) and wants to retrieve the associated value from a server.
Because the keyword is private, the client wants to perform this lookup without the server learning the keyword.</p>

<p>A trivial implementation of PIR is to have the server send the entire database to the client for local processing.
While this does prevent the server from knowing what queries are being made, it is only feasible for small databases with infrequent updates.</p>

<p>In contrast, our PIR implementation, which relies on homomorphic encryption, only needs to sync a small amount of database metadata with the client.
This metadata changes infrequently, which allows efficient handling of very large databases with a high volume of updates.</p>


<p>As mentioned above, homomorphic encryption enables computation on encrypted data without decryption or access to the decryption key.</p>

<p>A typical workflow for homomorphic encryption might be as follows:</p>
<ul>
  <li>The client encrypts its sensitive data and sends the result to the server.</li>
  <li>The server performs computation on the ciphertext (perhaps incorporating its
own plaintext inputs), without learning what any ciphertext decrypts to.</li>
  <li>The server sends the resulting ciphertext response to the client.</li>
  <li>The client decrypts the resulting response.</li>
</ul>

<p>The Swift implementation of homomorphic encryption implements the
Brakerski-Fan-Vercauteren (BFV) HE scheme
(<a href="https://eprint.iacr.org/2012/078">https://eprint.iacr.org/2012/078</a>,
<a href="https://eprint.iacr.org/2012/144">https://eprint.iacr.org/2012/144</a>). BFV
is based on the ring learning with errors (RLWE) hardness problem, which is
quantum resistant.</p>

<p>The Live Caller ID Lookup feature requires BFV parameters
with post-quantum 128-bit security, to provide strong security against both classical and
potential future quantum attacks, previously explained in <a href="https://security.apple.com/blog/imessage-pq3/">https://security.apple.com/blog/imessage-pq3/</a>.</p>


<p>We believe developers will find homomorphic encryption useful for a wide variety
of standalone privacy-preserving applications both inside and outside the Apple
ecosystem, including private set intersection, secure aggregation, and machine
learning.</p>

<p>Below is a basic example for how to use Swift Homomorphic Encryption.</p>
<div><div><pre><code><span>import</span> <span>HomomorphicEncryption</span>

<span>// We start by choosing some encryption parameters for the Bfv&lt;UInt64&gt; scheme.</span>
<span>// *These encryption parameters are insecure, suitable for testing only.*</span>
<span>let</span> <span>encryptParams</span> <span>=</span>
    <span>try</span> <span>EncryptionParameters</span><span>&lt;</span><span>Bfv</span><span>&lt;</span><span>UInt64</span><span>&gt;&gt;</span><span>(</span><span>from</span><span>:</span> <span>.</span><span>insecure_n_8_logq_5x18_logt_5</span><span>)</span>
<span>// Perform pre-computation for HE computation with these parameters.</span>
<span>let</span> <span>context</span> <span>=</span> <span>try</span> <span>Context</span><span>(</span><span>encryptionParameters</span><span>:</span> <span>encryptParams</span><span>)</span>

<span>// We encode N values using coefficient encoding.</span>
<span>let</span> <span>values</span><span>:</span> <span>[</span><span>UInt64</span><span>]</span> <span>=</span> <span>[</span><span>8</span><span>,</span> <span>5</span><span>,</span> <span>12</span><span>,</span> <span>12</span><span>,</span> <span>15</span><span>,</span> <span>0</span><span>,</span> <span>8</span><span>,</span> <span>5</span><span>]</span>
<span>let</span> <span>plaintext</span><span>:</span> <span>Bfv</span><span>&lt;</span><span>UInt64</span><span>&gt;.</span><span>CoeffPlaintext</span> <span>=</span> <span>try</span> <span>context</span><span>.</span><span>encode</span><span>(</span>
    <span>values</span><span>:</span> <span>values</span><span>,</span>
    <span>format</span><span>:</span> <span>.</span><span>coefficient</span><span>)</span>

<span>// We generate a secret key and use it to encrypt the plaintext.</span>
<span>let</span> <span>secretKey</span> <span>=</span> <span>try</span> <span>context</span><span>.</span><span>generateSecretKey</span><span>()</span>
<span>let</span> <span>ciphertext</span> <span>=</span> <span>try</span> <span>plaintext</span><span>.</span><span>encrypt</span><span>(</span><span>using</span><span>:</span> <span>secretKey</span><span>)</span>

<span>// Decrypting the plaintext yields the original values.</span>
<span>let</span> <span>decrypted</span> <span>=</span> <span>try</span> <span>ciphertext</span><span>.</span><span>decrypt</span><span>(</span><span>using</span><span>:</span> <span>secretKey</span><span>)</span>
<span>let</span> <span>decoded</span><span>:</span> <span>[</span><span>UInt64</span><span>]</span> <span>=</span> <span>try</span> <span>decrypted</span><span>.</span><span>decode</span><span>(</span><span>format</span><span>:</span> <span>.</span><span>coefficient</span><span>)</span>
<span>precondition</span><span>(</span><span>decoded</span> <span>==</span> <span>values</span><span>)</span>
</code></pre></div></div>

<p>We look forward to working with others to enhance this package: you can read more about contributing at the repositories on GitHub.
We also encourage you to file issues to <a href="https://github.com/apple/swift-homomorphic-encryption/issues">swift-homomorphic-encryption</a> and <a href="https://github.com/apple/live-caller-id-lookup-example/issues">live-caller-id-lookup-examples</a> if you encounter any problems or have suggestions for improvements.</p>

<p>We’re excited to see how homomorphic encryption can empower developers and
researchers in the Swift community to enable new use cases!</p>


  
</article>
</div></div>
  </body>
</html>
