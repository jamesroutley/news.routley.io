<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nbd.neocities.org/slidepresentation/Slide%20presentation%20about%20slides">Original</a>
    <h1>HTML Slides with notes</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>... in 22 lines of JavaScript</p>
<pre>let slides = [...document.getElementsByClassName(&#34;slide&#34;)]
  .map((slide, i) =&gt; [
      slide,
      (i = slide.nextElementSibling)?.className === &#34;slidenote&#34; ? i : slide
  ]),
  current = 0
  viewSlides = 0,
  jump = () =&gt; slides[current][viewSlides].scrollIntoView(),
  bc = new BroadcastChannel(&#34;slide_switching&#34;),
  l = slides.length-1;
bc.onmessage = ({data}) =&gt; {
  viewSlides = 1 ^ data.viewSlides;
  current = data.current;
  jump();
};
document.addEventListener(&#34;keypress&#34;,  ({key}) =&gt; {
  current += (key == &#34;j&#34;) - (key == &#34;k&#34;);
  current = current &lt; 0 ? 0 : current &gt; l : l : current;
  viewSlides ^= (key == &#34;n&#34;);
  bc.postMessage({current, viewSlides});
  jump();
});
</pre><p><small>(Use <kbd>j</kbd> and <kbd>k</kbd> to navigate, <kbd>n</kbd> to swap notes and slides)</small></p></div>
<p>Don&#39;t worry, I&#39;ll walk you all through it in a readable font size!</p>
<div>
<p>... in 22 lines, or 371 bytes of JavaScript</p>
<pre>let a=[...document.getElementsByClassName(&#34;slide&#34;)].map((a,b)=&gt;[
a,&#34;slidenote&#34;==(b=a.nextElementSibling)?.className?b:a]),b=0,c=0,
d=()=&gt;a[b][c].scrollIntoView(),e=new BroadcastChannel(&#34;s&#34;),l=a.
length-1;d();e.onmessage=({data:a})=&gt;{c^=a.c,b=a.b,d()};document.
addEventListener(&#34;keypress&#34;,({key:f})=&gt;{b+=(f==&#34;j&#34;)-(f==
&#34;k&#34;);b=b&lt;0?0:b&gt;l?l:b;c^=f==&#34;n&#34;;e.postMessage({c,b});d()})
</pre></div>
<p>... but not before pointing out that this really minifies to super-tiny code - and still is practical to use!</p>
<div><h2 id="but-first-some-attribution">But first, some attribution</h2>
<p>This code builds on minslides (<a href="https://ratfactor.com/minslides/">https://ratfactor.com/minslides/</a>) by Dave Gaur.</p>
<pre><i>// golfed minslides, 173 bytes</i>
let a=document.getElementsByClassName(&#34;slide&#34;),b=0,c=a.length-1;
document.addEventListener(&#34;keypress&#34;,({key:d})=&gt;{b+=(&#34;j&#34;==d)-
(&#34;k&#34;==d),b=0&gt;b?0:b&gt;l?l:b,a[b].scrollIntoView()})
</pre>
<p>My addition: notes in a second window</p>
<p>(Also the hand-optimized minifaction)</p>
</div>
<div><p>I want to credit Dave Gaur for coming up with minslides.</p>
<p>For me it was yet another reminder that browsers are &#34;batteries included&#34; for surprisingly many scenarios as long as you bother to dig into the APIs available.</p>
<p>Case-in-point: it turned out to be ridiculously simple to add note support in a second window!</p>
<p>Here, let me show you by switching between notes and slides with a keypress (<code>n</code>, to be exact) </p>
</div>
<div><h2 id="lets-define-our-slide">Let&#39;s define our slide</h2>
<pre>  &lt;div class=&#34;slide&#34;&gt;
    Anything in here is one slide (who needs components?)
  &lt;/div&gt;
  &lt;div class=&#34;slidenote&#34;&gt;
    (optional) Anything in here is a slide note for the slide above
  &lt;/div&gt;
</pre>
<p>Notes are optional, but must follow the slides that they are for. To switch
to the note view, press <kbd>n</kbd></p>
</div>
<div><p>So how to determine is something is a slide? Well, why not use plain old <code>&lt;div&gt;</code> with a <code>slide</code> class? And let&#39;s define slide notes as a <code>div</code> with a <code>slidenote</code> class. Easy.</p>
<p>This also lets us put <em>anything</em> in our slide that we are allowed to put into a plain webpage.</p>
<p>Also, we can write a plain old markdown file (or whatever you prefer), and separate the slides by inserting those div tags (like I did for these slides, actually)</p>
</div>
<div><h2 id="css-to-make-a-slide-fit-the-screen">CSS to make a slide fit the screen</h2>
<pre>  div.slide, div.slidenote {
    height: 100vh;
    width: 100vw;
    /* Other slide styling options below */
    ...
    ...
  }
</pre>
<p>Yes, it&#39;s that simple</p>
</div>
<div><p>Of course, we want our slides to be exactly as big as the screen in full-screen, and as big as the window when windowed.</p>
<p>Turns out modern CSS has a ludicrously simple way to do that.</p>
</div>
<div>
<pre>let slides = document.getElementsByClassName(&#34;slide&#34;);</pre></div>
<div><p><code>getElementsByClassName</code> returns an array-like object with all children of the node it is called on (or the entire page is called on document, like we&#39;re doing here).</p>
<p>Conveniently, these children will be in the order that they appear in the document</p>
<p>So we now have an array of all slides, in order. Nice!</p>
</div>
<div>
<pre>let slides = document.getElementsByClassName(&#34;slide&#34;),
  current = 0,
  jump = () =&gt; slides[current].scrollIntoView();
jump();</pre>
</div>
<div><p>By default, <code>scrollIntoView()</code> instantly jumps to the element that it is called on. And since our slide divs fill the screen, that is equivalent to changing a slide. Convenient!</p>
<p>We can sneakily put other stuff <em>around</em> our slides and nobody will see it as long as we avoid scrolling manually!</p>
<p>How many of you knew of <code>scrollIntoView</code>? For the record, it&#39;s been supported since IE 8, Chrome 1 and Firefox 1.</p>
</div>
<div><h2 id="switch-slides-on-keypress">Switch slides on keypress</h2>
<pre>document.addEventListener(&#34;keypress&#34;, ({key}) =&gt; {
  if(key === &#34;j&#34;) current++;
  if(key === &#34;k&#34;) current--;
  if(current &lt; 0) current = 0;
  if(current &gt;= slides.length) current = slides.length - 1;
  jump();
});
</pre>

<p>And with that we already have basic slide functionality!</p>
</div>
<div><p>All we have to do now for feature parity with minslides is add navigation.</p>
<p>Just add a listener for keypress events, change our <code>current</code> variable and jump.</p>
<p>Yes, it&#39;s that simple.</p>
</div>
<div><h2 id="note-support-1">Note support (1)</h2>
<p>First version: add a <code>notes</code> array synced to the <code>slides</code> array-like</p>
<pre>const notes = [...slides].map(slide =&gt; {
  const note = slide.nextElementSibling;
  return note?.className === &#34;slidenote&#34; ? note : slide;
});</pre></div>
<div><p>Ok, so to support notes, we want to check if a slide is followed by a div with <code>slidenote</code> class.</p>
<p>Luckily, each element has a <code>nextElementSibling</code> property that lets us fetch the node that follows it (if any).</p>
<p>Then we simply check that sibling&#39;s class name (if it exists, hence the optional chaining)</p>
<p>Also, remember how <code>slides</code> is an array-<em>like</em> instead of an actual array? Because of that we can&#39;t directly use map on it,
so we force it into an actual array with the spread syntax.</p>
</div>
<div><h2 id="note-support-2">Note support (2)</h2>
<p>Modify the jump function to pick slides or notes depending on view mode:</p>
<pre>let slides = document.getElementsByClassName(&#34;slide&#34;),
  current = 0,
  <b>viewSlides = true,
  jump = () =&gt; {
    if (viewSlides) slides[current].scrollIntoView();
    else notes[current].scrollIntoView();
  }</b>;
jump();
</pre></div>
<div><p>Now we modify the jump function to jump to slides or notes depending on our view mode.</p>
<p>Straightforward</p>
</div>
<div><h2 id="note-support-3">Note support (3)</h2>
<p>Add key to switch modes</p>
<pre>document.addEventListener(&#34;keypress&#34;, ({key}) =&gt; {
  if(key === &#34;j&#34;) current++;
  if(key === &#34;k&#34;) current--;
  if(current &lt; 0){ current = 0; }
  if(current &gt;= slides.length){ current = slides.length - 1; }
  <b>if(key === &#34;n&#34;) viewSlides = !viewSlides;</b>
  jump();
});
</pre></div>
<p>Of course, then we also need a way to switch these mode. Let&#39;s pick <code>n</code> for <code>notes</code></p>
<div><h2 id="note-support-4">Note support (4)</h2>
<pre><b>const bc = new BroadcastChannel(&#34;slide_switching_channel&#34;);

bc.onmessage = ({data}) =&gt; {
  current = data.current;
  viewSlides = !data.viewSlides;
  jump();
};</b>

document.addEventListener(&#34;keypress&#34;, ({key}) =&gt; {
    /* ... the previous stuff ... */
    <b>bc.postMessage({current, viewSlides});</b>
  });</pre>
<p>Done! Multiple windows supported!</p>
</div>
<div><p>Now all we&#39;re missing is having notes in a separate window synchronized with the slides.</p>
<p>For that we can use a <code>BroadcastChannel</code> to communicate state between open windows on the same url. It&#39;s basically event-based message passing.</p>
<p>When we receive an event, we sync the <code>current</code> value, then look at the view mode of the sender and pick the opposite, then jump.</p>
<p>So if the &#34;notes&#34; window has focus and moves a slide, the &#34;slides&#34; window is synced and forced to slide view, and vice versa.</p>
</div>
<div><h2 id="golfing-time-⛳">Golfing time ⛳</h2>
<p>Replace <code>notes</code> with <code>[slide, note]</code> pairs, also shortens <code>jump()</code> code</p>
<pre>let slides = [...document.getElementsByClassName(&#34;slide&#34;)]
  .map((slide<b>, i) =&gt; [
    slide, 
    (i = slide.nextElementSibling)?.className == &#34;slidenote&#34; ? i : slide
  ])</b>,
  current = 0,
  viewSlides = <b>0</b>,
  jump = () =&gt; slides[current]<b>[viewSlides]</b>.scrollIntoView()</pre></div>
<div><p>Ok, that&#39;s the readable version, but not the version I showed on the first slides. If I have time left I can explain the golf abuse, otherwise you&#39;ll have to read these slides on the internet later.</p>
<p>First, let&#39;s get rid of that branch in <code>jump</code> by zipping slides and notes into one array of pairs, picking between the pair based on view mode.</p>
<p>Also, yes, we&#39;re abusing the fact that <code>map</code> lets us pass the index as a second parameter to shave some characters off of initializing a temporary variable</p>
</div>
<div><h2 id="golfing-time-⛳">Golfing time ⛳</h2>
<pre> bc.onmessage = ({data}) =&gt; {
  viewSlides = <b>data.viewSlides^1</b>;
  current = data.current;
  jump();
};
document.addEventListener(&#34;keypress&#34;,  ({key}) =&gt; {
  if (key <b>==</b> &#34;j&#34;) ++current;
  if (key <b>==</b> &#34;k&#34;) --current;
  if (current &lt; 0) current = 0;
  if (current &gt;= slides.length) current = slides.length - 1;
  if (key <b>==</b> &#34;n&#34;) <b>viewSlides ^= 1</b>;
  bc.postMessage({current, viewSlides});
  jump();
});</pre></div>
<p>We made <code>viewSlides</code> an integer, so we&#39;ll use xor bitmasking to switch it between zero and one.</p>
<div><h2 id="golfing-time---continued-⛳">Golfing time - continued ⛳</h2>
<pre> let ...,
  <b>l = slides.length-1;</b>
  
  ...
  
document.addEventListener(&#34;keypress&#34;,  ({key}) =&gt; {
  <b>current += (key == &#34;j&#34;) - (key == &#34;k&#34;);
  current = current &lt; 0 ? 0 : current &gt; l : l : current;
  viewSlides ^= (key == &#34;n&#34;);</b>
  bc.postMessage({current, viewSlides});
  jump();
});</pre>
<p>Throw it through a minifier, do a bit of clean-up, and it&#39;s 371 bytes of JavaScript</p>
</div>
<p>And that&#39;s basically it! Throw this whole thing through a minifier (wrapped in a function so it&#39;s free to mangle variable names), do a bit of clean-up, and we end up with the 371 character minified version I showed at the beginning.</p>



	

</div>
  </body>
</html>
