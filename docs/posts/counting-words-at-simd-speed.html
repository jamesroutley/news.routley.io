<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://healeycodes.com/counting-words-at-simd-speed">Original</a>
    <h1>Counting Words at SIMD Speed</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>I&#39;ve written some progressively faster word counting programs. First, we&#39;ll start with Python, and then we&#39;ll drop down to C, and finally, we&#39;ll use single instruction, multiple data (SIMD) programming to go as fast as possible.</p><p>The task is to count the words in an ASCII text file. For example, <code>Hello there!</code> contains <code>2</code> words, and my 1 GiB benchmark text file contains 65 million words.</p><p>At a high level: read bytes, scan while tracking minimal state, write the count to stdout.</p><p>These are the results from my Apple M1 Pro that I&#39;ll dig into:</p><ul><li>Python (byte loop): <code>89.6 s</code></li><li>Python + re: <code>13.7 s</code></li><li>C (scalar loop): <code>1.205 s</code></li><li>C + ARM NEON SIMD: <code>249 ms</code></li><li>C + ARM NEON SIMD + threads: <code>181 ms</code></li></ul><p>You can also jump straight to the <a href="https://github.com/healeycodes/counting-words-at-simd-speed">source files</a>.</p><h2 id="first-try-896-seconds">First try (89.6 seconds)</h2><p>Here&#39;s a reasonable first attempt, but you might spot some obvious performance-related deficiencies.</p><p>We read each byte and check if it&#39;s part of a set of whitespace characters, while tracking the word count, and whether there was previous whitespace.</p><pre><div><div><p><span># 0_mvp.py</span><span></span></p><p><span>ws </span><span>=</span><span> </span><span>set</span><span>(</span><span>b&#34; \n\r\t\v\f&#34;</span><span>)</span><span></span></p><p><span>prev_ws </span><span>=</span><span> </span><span>True</span><span></span></p><p><span>words </span><span>=</span><span> </span><span>0</span><span></span></p><p><span></span><span>with</span><span> </span><span>open</span><span>(</span><span>sys</span><span>.</span><span>argv</span><span>[</span><span>1</span><span>]</span><span>,</span><span> </span><span>&#34;rb&#34;</span><span>)</span><span> </span><span>as</span><span> f</span><span>:</span><span></span></p><p><span>    </span><span>for</span><span> byte_value </span><span>in</span><span> f</span><span>.</span><span>read</span><span>(</span><span>)</span><span>:</span><span></span></p><p><span>        cur_ws </span><span>=</span><span> byte_value </span><span>in</span><span> ws</span></p><p><span>        </span><span>if</span><span> </span><span>not</span><span> cur_ws </span><span>and</span><span> prev_ws</span><span>:</span><span></span></p><p><span>            words </span><span>+=</span><span> </span><span>1</span><span></span></p><p><span>        prev_ws </span><span>=</span><span> cur_ws</span></p><p><span></span><span>print</span><span>(</span><span>words</span><span>)</span></p></div></div></pre><p>This program is horrendously slow. It takes 89.6 seconds on my Apple M1 Pro. Python code runs for every byte, incurring interpreter dispatch and object checks again and again.</p><h2 id="using-cpython-efficiently-137-seconds">Using CPython efficiently (13.7 seconds)</h2><p>There&#39;s a big improvement we can make before having to leave Python behind. We can make the program faster by making sure all the work happens in C, in tight loops, with no per-byte Python overhead.</p><p>CPython&#39;s <code>re</code> module is a thin Python wrapper around a C extension named <code>_sre</code>, &#34;Secret Labs&#39; Regular Expression Engine.&#34; Patterns are parsed in Python into a compact bytecode, then executed by the C engine. So a call like <code>re.finditer(pattern, data)</code> spends nearly all of its time inside C, scanning contiguous memory with pointer arithmetic and table lookups.</p><pre><div><div><p><span># 1_c_regex.py</span><span></span></p><p><span>words </span><span>=</span><span> </span><span>0</span><span></span></p><p><span></span><span>with</span><span> </span><span>open</span><span>(</span><span>sys</span><span>.</span><span>argv</span><span>[</span><span>1</span><span>]</span><span>,</span><span> </span><span>&#34;rb&#34;</span><span>)</span><span> </span><span>as</span><span> f</span><span>:</span><span></span></p><p><span>    pattern </span><span>=</span><span> </span><span>rb&#34;[^ \n\r\t\v\f]+&#34;</span><span></span></p><p><span>    data </span><span>=</span><span> f</span><span>.</span><span>read</span><span>(</span><span>)</span><span></span></p><p><span>    words </span><span>=</span><span> </span><span>sum</span><span>(</span><span>1</span><span> </span><span>for</span><span> _ </span><span>in</span><span> re</span><span>.</span><span>finditer</span><span>(</span><span>pattern</span><span>,</span><span> data</span><span>)</span><span>)</span><span></span></p><p><span></span><span>print</span><span>(</span><span>words</span><span>)</span></p></div></div></pre><p>This version is ~6× faster than the initial Python version.</p><h2 id="first-try-in-c-1205-milliseconds">First try in C (1205 milliseconds)</h2><p>I think the above Python version is very close to the limit that we can get with straightforward Python (e.g. no NumPy, no threads).</p><p>By porting our first Python attempt to C, we&#39;re rewarded with a ~74× speedup.</p><pre><div><div><p><span>// 2_mvp.c</span><span></span></p><p><span></span><span>size_t</span><span> nread </span><span>=</span><span> </span><span>fread</span><span>(</span><span>data</span><span>,</span><span> </span><span>1</span><span>,</span><span> file_size</span><span>,</span><span> fp</span><span>)</span><span>;</span><span></span></p><p><span></span><span>fclose</span><span>(</span><span>fp</span><span>)</span><span>;</span><span></span></p><p><span></span><span>// ..</span><span></span></p><p><span></span><span>size_t</span><span> words </span><span>=</span><span> </span><span>0</span><span>;</span><span></span></p><p><span>bool prev_ws </span><span>=</span><span> true</span><span>;</span><span></span></p><p><span></span><span>for</span><span> </span><span>(</span><span>size_t</span><span> i </span><span>=</span><span> </span><span>0</span><span>;</span><span> i </span><span>&lt;</span><span> nread</span><span>;</span><span> </span><span>++</span><span>i</span><span>)</span><span></span></p><p><span></span><span>{</span><span></span></p><p><span>    </span><span>unsigned</span><span> </span><span>char</span><span> c </span><span>=</span><span> data</span><span>[</span><span>i</span><span>]</span><span>;</span><span></span></p><p><span>    bool cur_ws </span><span>=</span><span> </span><span>is_ws</span><span>(</span><span>c</span><span>)</span><span>;</span><span></span></p><p><span>    </span><span>if</span><span> </span><span>(</span><span>!</span><span>cur_ws </span><span>&amp;&amp;</span><span> prev_ws</span><span>)</span><span></span></p><p><span>    </span><span>{</span><span></span></p><p><span>        </span><span>++</span><span>words</span><span>;</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span>    prev_ws </span><span>=</span><span> cur_ws</span><span>;</span><span></span></p><p><span></span><span>}</span><span></span></p><p><span></span><span>free</span><span>(</span><span>data</span><span>)</span><span>;</span><span></span></p><p><span></span><span>printf</span><span>(</span><span>&#34;%zu\n&#34;</span><span>,</span><span> words</span><span>)</span><span>;</span></p></div></div></pre><p>Why is it so much quicker? Before, <code>re.finditer(...)</code> was creating a Python <code>Match</code> object for every word (millions of heap allocations + GC pressure).</p><p>The regex engine was also doing extra work when it searched, matched, backtracked, and performed bookkeeping. Even though that&#39;s in C, it&#39;s still building Python objects for the iterator.</p><p>In comparison, this version&#39;s C loop is a single pass over bytes with two booleans (<code>prev_ws</code>, <code>cur_ws</code>) and a simple branch. Compilers turn this into very tight code, i.e., no per-word allocations, and no callbacks into the interpreter.</p><h2 id="adding-simd-249-milliseconds">Adding SIMD (249 milliseconds)</h2><p><a href="https://en.wikipedia.org/wiki/Single_instruction,_multiple_data">Single instruction, multiple data</a> (SIMD) is a form of data-level parallelism where one instruction operates on multiple data elements in parallel. For example, we can create a mask of all the space characters in a 16-byte chunk of our input, with one instruction, like this:</p><pre><div><div><p><span>// bytes: [H , e , l , l , o ,   ,   ,   , t , h , e , r , e , ! ,   ,   ]</span><span></span></p><p><span></span><span>// ws1:   [00, 00, 00, 00, 00, FF, FF, FF, 00, 00, 00, 00, 00, 00, FF, FF]</span><span></span></p><p><span></span><span>uint8x16_t</span><span> ws1 </span><span>=</span><span> </span><span>vceqq_u8</span><span>(</span><span>bytes</span><span>,</span><span> </span><span>vdupq_n_u8</span><span>(</span><span>&#39; &#39;</span><span>)</span><span>)</span><span>;</span></p></div></div></pre><p>But our word counting program doesn&#39;t require us to count the <em>space characters</em>. We need to count non-whitespace bytes that immediately follow a whitespace byte (any of six different whitespace characters).</p><p>Looping over each 16-byte chunk from our buffer, we need to:</p><ul><li>Load the bytes into a register</li><li>Create a whitespace mask</li><li>Create a previous-byte whitespace mask</li><li>Create a word-start mask (combine the whitespace and previous-byte whitespace mask)</li><li>Sum the word-start mask to get the word count for this chunk</li><li>Carry forward the whitespace state</li></ul><p>Here&#39;s the core section of this C version with NEON SIMD instructions, showing examples of what the masks look like.</p><pre><div><div><p><span>// 3_simd.c</span><span></span></p><p><span></span><span>size_t</span><span> words </span><span>=</span><span> </span><span>0</span><span>;</span><span></span></p><p><span></span><span>// (0) Previous-byte whitespace (defaults to whitespace for start-of-file)</span><span></span></p><p><span></span><span>uint8x16_t</span><span> prev_ws_vec </span><span>=</span><span> </span><span>vdupq_n_u8</span><span>(</span><span>prev_ws </span><span>?</span><span> </span><span>0xFF</span><span> </span><span>:</span><span> </span><span>0x00</span><span>)</span><span>;</span><span></span></p><p><span></span><span>size_t</span><span> nvec </span><span>=</span><span> nread </span><span>&amp;</span><span> </span><span>~</span><span>(</span><span>size_t</span><span>)</span><span>15</span><span>;</span><span></span></p><p><span></span><span>for</span><span> </span><span>(</span><span>;</span><span> i </span><span>&lt;</span><span> nvec</span><span>;</span><span> i </span><span>+=</span><span> </span><span>16</span><span>)</span><span></span></p><p><span></span><span>{</span><span></span></p><p><span>    </span><span>// (1) Load 16-bytes from buffer</span><span></span></p><p><span>    </span><span>// [H , e , l , l , o ,   ,   ,   , t , h , e , r , e , ! ,   ,   ]</span><span></span></p><p><span>    </span><span>uint8x16_t</span><span> bytes </span><span>=</span><span> </span><span>vld1q_u8</span><span>(</span><span>buffer </span><span>+</span><span> i</span><span>)</span><span>;</span><span></span></p><p><span>    </span><span>// (2) Per-lane whitespace masks (0xFF for ws, 0x00 for non-ws)</span><span></span></p><p><span>    </span><span>uint8x16_t</span><span> ws1 </span><span>=</span><span> </span><span>vceqq_u8</span><span>(</span><span>bytes</span><span>,</span><span> </span><span>vdupq_n_u8</span><span>(</span><span>&#39; &#39;</span><span>)</span><span>)</span><span>;</span><span></span></p><p><span>    </span><span>uint8x16_t</span><span> ws2 </span><span>=</span><span> </span><span>vceqq_u8</span><span>(</span><span>bytes</span><span>,</span><span> </span><span>vdupq_n_u8</span><span>(</span><span>&#39;\n&#39;</span><span>)</span><span>)</span><span>;</span><span></span></p><p><span>    </span><span>uint8x16_t</span><span> ws3 </span><span>=</span><span> </span><span>vceqq_u8</span><span>(</span><span>bytes</span><span>,</span><span> </span><span>vdupq_n_u8</span><span>(</span><span>&#39;\r&#39;</span><span>)</span><span>)</span><span>;</span><span></span></p><p><span>    </span><span>uint8x16_t</span><span> ws4 </span><span>=</span><span> </span><span>vceqq_u8</span><span>(</span><span>bytes</span><span>,</span><span> </span><span>vdupq_n_u8</span><span>(</span><span>&#39;\t&#39;</span><span>)</span><span>)</span><span>;</span><span></span></p><p><span>    </span><span>uint8x16_t</span><span> ws5 </span><span>=</span><span> </span><span>vceqq_u8</span><span>(</span><span>bytes</span><span>,</span><span> </span><span>vdupq_n_u8</span><span>(</span><span>&#39;\v&#39;</span><span>)</span><span>)</span><span>;</span><span></span></p><p><span>    </span><span>uint8x16_t</span><span> ws6 </span><span>=</span><span> </span><span>vceqq_u8</span><span>(</span><span>bytes</span><span>,</span><span> </span><span>vdupq_n_u8</span><span>(</span><span>&#39;\f&#39;</span><span>)</span><span>)</span><span>;</span><span></span></p><p><span>    </span><span>// (3) Combine all masks into a single mask</span><span></span></p><p><span>    </span><span>// [00, 00, 00, 00, 00, FF, FF, FF, 00, 00, 00, 00, 00, 00, FF, FF]</span><span></span></p><p><span>    </span><span>uint8x16_t</span><span> ws </span><span>=</span><span> </span><span>vorrq_u8</span><span>(</span><span>ws1</span><span>,</span><span> ws2</span><span>)</span><span>;</span><span></span></p><p><span>    ws </span><span>=</span><span> </span><span>vorrq_u8</span><span>(</span><span>ws</span><span>,</span><span> ws3</span><span>)</span><span>;</span><span></span></p><p><span>    ws </span><span>=</span><span> </span><span>vorrq_u8</span><span>(</span><span>ws</span><span>,</span><span> ws4</span><span>)</span><span>;</span><span></span></p><p><span>    ws </span><span>=</span><span> </span><span>vorrq_u8</span><span>(</span><span>ws</span><span>,</span><span> ws5</span><span>)</span><span>;</span><span></span></p><p><span>    ws </span><span>=</span><span> </span><span>vorrq_u8</span><span>(</span><span>ws</span><span>,</span><span> ws6</span><span>)</span><span>;</span><span></span></p><p><span>    </span><span>// (4) Previous-byte whitespace for each lane</span><span></span></p><p><span>    </span><span>// [FF, 00, 00, 00, 00, 00, FF, FF, FF, 00, 00, 00, 00, 00, 00, FF]</span><span></span></p><p><span>    </span><span>uint8x16_t</span><span> prev_ws_shifted </span><span>=</span><span> </span><span>vextq_u8</span><span>(</span><span>prev_ws_vec</span><span>,</span><span> ws</span><span>,</span><span> </span><span>15</span><span>)</span><span>;</span><span></span></p><p><span>    </span><span>// (5) Word start mask: non-ws AND prev-ws (two word starts, &#39;H&#39; and &#39;t&#39;)</span><span></span></p><p><span>    </span><span>// [FF, 00, 00, 00, 00, 00, 00, 00, FF, 00, 00, 00, 00, 00, 00, 00]</span><span></span></p><p><span>    </span><span>uint8x16_t</span><span> non_ws </span><span>=</span><span> </span><span>vmvnq_u8</span><span>(</span><span>ws</span><span>)</span><span>;</span><span></span></p><p><span>    </span><span>uint8x16_t</span><span> start_mask </span><span>=</span><span> </span><span>vandq_u8</span><span>(</span><span>non_ws</span><span>,</span><span> prev_ws_shifted</span><span>)</span><span>;</span><span></span></p><p><span>    </span><span>// (6) Convert lanes to 1 by shifting right by 7 bits</span><span></span></p><p><span>    </span><span>// [1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]</span><span></span></p><p><span>    </span><span>uint8x16_t</span><span> ones </span><span>=</span><span> </span><span>vshrq_n_u8</span><span>(</span><span>start_mask</span><span>,</span><span> </span><span>7</span><span>)</span><span>;</span><span> </span><span>// 2 ones</span><span></span></p><p><span>    </span><span>// (7) Sum all lanes</span><span></span></p><p><span>    words </span><span>+=</span><span> </span><span>(</span><span>size_t</span><span>)</span><span>vaddvq_u8</span><span>(</span><span>ones</span><span>)</span><span>;</span><span> </span><span>// 2</span><span></span></p><p><span>    </span><span>// (8) Carry state for the next iteration</span><span></span></p><p><span>    prev_ws_vec </span><span>=</span><span> ws</span><span>;</span><span></span></p><p><span></span><span>}</span><span></span></p><p><span></span><span>// Remainder is handled with a scalar loop</span></p></div></div></pre><p>This SIMD version is 5× faster because it does less work per byte of input.</p><p>Even though there are many more lines of code, it compiles down to efficient operations that run on 16-byte chunks. The compiler (<code>clang -O3</code>) adds further optimizations. For example, there are six <code>vceqq_u8</code> calls in this version, for each of the whitespace characters: <code>b&#34; \n\r\t\v\f&#34;</code>.</p><p>This doesn&#39;t result in six vector compare-equal (<code>cmeq</code>) instructions because the compiler is able to work out that, while we need exact-match checks for <code>&#39; &#39;</code> and <code>&#39;\n&#39;</code>, there are more efficient steps for the following groups:</p><ul><li><code>&#39;\t&#39;</code> (<code>0x09</code>) and <code>&#39;\r&#39;</code> (<code>0x0D</code>)
  <ul><li>Perform a bitwise AND with <code>0xFB</code> and check if the result equals <code>0x09</code>.
</li></ul></li><li><code>&#39;\v&#39;</code> (<code>0x0B</code>) and <code>&#39;\f&#39;</code> (<code>0x0C</code>)
  <ul><li>Add <code>0xF5</code> (unsigned 8-bit add with wraparound) and check if the result is less than <code>2</code>.
</li></ul></li></ul><p>While it <em>looks</em> like more instructions are touching the data, the key thing is that we&#39;re replacing an expensive sequence (another equality compare + mask merge + constant load) with a very cheap transform plus a single comparison.</p><p>Finding the rest of the compiler&#39;s optimizations is left as an exercise to the reader: <a href="https://godbolt.org/z/81r9Ts8Wb">https://godbolt.org/z/81r9Ts8Wb</a>.</p><h2 id="using-the-rest-of-the-cpu-181-milliseconds">Using the rest of the CPU (181 milliseconds)</h2><p>When we applied SIMD instructions above, we reached near-optimal single-core performance. However, my laptop and the device you’re reading this on have multiple cores — which my programs haven&#39;t been using.</p><p>Counting the number of words in a text file is a classic example of something that can be parallelized across threads. The file can be chunked up, and then each chunk is handed to a thread to count the words. When each thread finishes, their counts are summed.</p><p>There is one wrinkle, in that we need to check the previous byte to the start of the chunk so we understand the current whitespace state.</p><p>For example, with an input like <code>[a,  ,M , i, c, r, o, s, e, c, o, n, d,  ,  ,  ]</code>.</p><p>Thread one gets <code>[a,  ,M , i, c, r, o, s]</code> and counts <code>a</code> and <code>M</code> as word-starts (2).</p><p>Thread two gets <code>[e, c, o, n, d,  ,  ,  ]</code> but knows that the <code>e</code> is not a word-start (0).</p><p>The word count is the sum of these totals: <code>2 + 0 = 2</code>.</p><p>The previous version&#39;s &#34;count words&#34; function is unchanged, but we call per-chunk.</p><pre><div><div><p><span>// 4_threads.c</span><span></span></p><p><span></span><span>// Count words in a contiguous memory range using NEON, given the starting prev-ws state</span><span></span></p><p><span></span><span>static</span><span> </span><span>size_t</span><span> </span><span>count_words_neon</span><span>(</span><span></span></p><p><span>  </span><span>const</span><span> </span><span>unsigned</span><span> </span><span>char</span><span> </span><span>*</span><span>data</span><span>,</span><span></span></p><p><span>  </span><span>size_t</span><span> len</span><span>,</span><span></span></p><p><span>  bool prev_ws</span></p><p><span></span><span>)</span><span></span></p><p><span></span><span>// Args for each thread</span><span></span></p><p><span></span><span>typedef</span><span> </span><span>struct</span><span> </span><span>ThreadArgs</span><span></span></p><p><span></span><span>{</span><span></span></p><p><span>    </span><span>const</span><span> </span><span>unsigned</span><span> </span><span>char</span><span> </span><span>*</span><span>base</span><span>;</span><span></span></p><p><span>    </span><span>size_t</span><span> length</span><span>;</span><span></span></p><p><span>    bool start_prev_ws</span><span>;</span><span> </span><span>// Derived from previous byte or SOF</span><span></span></p><p><span>    </span><span>size_t</span><span> result</span><span>;</span><span></span></p><p><span></span><span>}</span><span> ThreadArgs</span><span>;</span><span></span></p><p><span></span><span>// Worker which handles an equal chunk of the file</span><span></span></p><p><span></span><span>static</span><span> </span><span>void</span><span> </span><span>*</span><span>worker</span><span>(</span><span>void</span><span> </span><span>*</span><span>p</span><span>)</span><span></span></p><p><span></span><span>{</span><span></span></p><p><span>    ThreadArgs </span><span>*</span><span>args </span><span>=</span><span> </span><span>(</span><span>ThreadArgs </span><span>*</span><span>)</span><span>p</span><span>;</span><span></span></p><p><span>    args</span><span>-&gt;</span><span>result </span><span>=</span><span> </span><span>count_words_neon</span><span>(</span><span>args</span><span>-&gt;</span><span>base</span><span>,</span><span> args</span><span>-&gt;</span><span>length</span><span>,</span><span> args</span><span>-&gt;</span><span>start_prev_ws</span><span>)</span><span>;</span><span></span></p><p><span>    </span><span>return</span><span> </span><span>NULL</span><span>;</span><span></span></p><p><span></span><span>}</span><span></span></p><p><span></span><span>int</span><span> </span><span>main</span><span>(</span><span>int</span><span> argc</span><span>,</span><span> </span><span>char</span><span> </span><span>*</span><span>*</span><span>argv</span><span>)</span><span></span></p><p><span></span><span>{</span><span></span></p><p><span>    </span><span>// .. </span><span></span></p><p><span>    </span><span>size_t</span><span> launched </span><span>=</span><span> </span><span>0</span><span>;</span><span></span></p><p><span>    </span><span>for</span><span> </span><span>(</span><span>size_t</span><span> t </span><span>=</span><span> </span><span>0</span><span>;</span><span> t </span><span>&lt;</span><span> max_threads</span><span>;</span><span> </span><span>++</span><span>t</span><span>)</span><span></span></p><p><span>    </span><span>{</span><span></span></p><p><span>        </span><span>size_t</span><span> start </span><span>=</span><span> t </span><span>*</span><span> chunk</span><span>;</span><span></span></p><p><span>        </span><span>if</span><span> </span><span>(</span><span>start </span><span>&gt;=</span><span> filesize</span><span>)</span><span></span></p><p><span>            </span><span>break</span><span>;</span><span></span></p><p><span>        </span><span>size_t</span><span> end </span><span>=</span><span> start </span><span>+</span><span> chunk</span><span>;</span><span></span></p><p><span>        </span><span>if</span><span> </span><span>(</span><span>end </span><span>&gt;</span><span> filesize</span><span>)</span><span></span></p><p><span>            end </span><span>=</span><span> filesize</span><span>;</span><span></span></p><p><span>        </span><span>size_t</span><span> len </span><span>=</span><span> end </span><span>-</span><span> start</span><span>;</span><span></span></p><p><span>        </span><span>// For each chunk, we need to seed with the previous-byte whitespace.</span><span></span></p><p><span>        </span><span>// Start-of-file is &#34;as if&#34; preceded by whitespace</span><span></span></p><p><span>        bool start_prev_ws </span><span>=</span><span> true</span><span>;</span><span> </span></p><p><span>        </span><span>if</span><span> </span><span>(</span><span>start </span><span>&gt;</span><span> </span><span>0</span><span>)</span><span></span></p><p><span>        </span><span>{</span><span></span></p><p><span>            start_prev_ws </span><span>=</span><span> </span><span>is_ws_scalar</span><span>(</span><span>data</span><span>[</span><span>start </span><span>-</span><span> </span><span>1</span><span>]</span><span>)</span><span>;</span><span></span></p><p><span>        </span><span>}</span><span></span></p><p><span>        args</span><span>[</span><span>launched</span><span>]</span><span>.</span><span>base </span><span>=</span><span> data </span><span>+</span><span> start</span><span>;</span><span></span></p><p><span>        args</span><span>[</span><span>launched</span><span>]</span><span>.</span><span>length </span><span>=</span><span> len</span><span>;</span><span></span></p><p><span>        args</span><span>[</span><span>launched</span><span>]</span><span>.</span><span>start_prev_ws </span><span>=</span><span> start_prev_ws</span><span>;</span><span></span></p><p><span>        args</span><span>[</span><span>launched</span><span>]</span><span>.</span><span>result </span><span>=</span><span> </span><span>0</span><span>;</span><span></span></p><p><span>        </span><span>if</span><span> </span><span>(</span><span>pthread_create</span><span>(</span><span>&amp;</span><span>threads</span><span>[</span><span>launched</span><span>]</span><span>,</span><span> </span><span>NULL</span><span>,</span><span> worker</span><span>,</span><span> </span><span>&amp;</span><span>args</span><span>[</span><span>launched</span><span>]</span><span>)</span><span> </span><span>!=</span><span> </span><span>0</span><span>)</span><span></span></p><p><span>        </span><span>{</span><span></span></p><p><span>            </span><span>perror</span><span>(</span><span>&#34;pthread_create&#34;</span><span>)</span><span>;</span><span></span></p><p><span>            </span><span>free</span><span>(</span><span>data</span><span>)</span><span>;</span><span></span></p><p><span>            </span><span>return</span><span> </span><span>1</span><span>;</span><span></span></p><p><span>        </span><span>}</span><span></span></p><p><span>        </span><span>++</span><span>launched</span><span>;</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span>    </span><span>size_t</span><span> total_words </span><span>=</span><span> </span><span>0</span><span>;</span><span></span></p><p><span>    </span><span>for</span><span> </span><span>(</span><span>size_t</span><span> i </span><span>=</span><span> </span><span>0</span><span>;</span><span> i </span><span>&lt;</span><span> launched</span><span>;</span><span> </span><span>++</span><span>i</span><span>)</span><span></span></p><p><span>    </span><span>{</span><span></span></p><p><span>        </span><span>(</span><span>void</span><span>)</span><span>pthread_join</span><span>(</span><span>threads</span><span>[</span><span>i</span><span>]</span><span>,</span><span> </span><span>NULL</span><span>)</span><span>;</span><span></span></p><p><span>        total_words </span><span>+=</span><span> args</span><span>[</span><span>i</span><span>]</span><span>.</span><span>result</span><span>;</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span>    </span><span>// ..</span><span></span></p><p><span>    </span><span>printf</span><span>(</span><span>&#34;%zu\n&#34;</span><span>,</span><span> total_words</span><span>)</span><span>;</span><span></span></p><p><span>    </span><span>return</span><span> </span><span>0</span><span>;</span><span></span></p><p><span></span><span>}</span></p></div></div></pre><p>My expectation was that this version would be N times faster with N threads than the previous version. This was based on the fact that the work that each thread is doing is entirely independent and each can saturate a CPU core. But it is only ~1.38 times faster.</p><p>My understanding is that my NEON loop is already so fast that it&#39;s likely limited by memory bandwidth, not CPU speed. So once one or two threads are streaming bytes at near-max RAM speed, the extra threads just fight over the same bandwidth giving little benefit.</p><p>The final results:</p><pre><div><div><p><span>.</span><span>/</span><span>bench</span><span>.</span><span>sh</span></p><p><span>Benchmark </span><span>1</span><span>:</span><span> python3 </span><span>0</span><span>_mvp</span><span>.</span><span>py bench</span><span>.</span><span>txt</span></p><p><span>  </span><span>Time</span><span> </span><span>(</span><span>mean ± σ</span><span>)</span><span>:</span><span>     </span><span>89.556</span><span> s ±  </span><span>7.214</span><span> s    </span><span>[</span><span>User</span><span>:</span><span> </span><span>87.205</span><span> s</span><span>,</span><span> System</span><span>:</span><span> </span><span>0.484</span><span> s</span><span>]</span><span></span></p><p><span>  </span><span>Range</span><span> </span><span>(</span><span>min … max</span><span>)</span><span>:</span><span>   </span><span>82.393</span><span> s … </span><span>96.820</span><span> s    </span><span>3</span><span> runs</span></p><p><span>Benchmark </span><span>2</span><span>:</span><span> python3 </span><span>1</span><span>_c_regex</span><span>.</span><span>py bench</span><span>.</span><span>txt</span></p><p><span>  </span><span>Time</span><span> </span><span>(</span><span>mean ± σ</span><span>)</span><span>:</span><span>     </span><span>13.739</span><span> s ±  </span><span>0.136</span><span> s    </span><span>[</span><span>User</span><span>:</span><span> </span><span>13.433</span><span> s</span><span>,</span><span> System</span><span>:</span><span> </span><span>0.158</span><span> s</span><span>]</span><span></span></p><p><span>  </span><span>Range</span><span> </span><span>(</span><span>min … max</span><span>)</span><span>:</span><span>   </span><span>13.659</span><span> s … </span><span>13.896</span><span> s    </span><span>3</span><span> runs</span></p><p><span>Benchmark </span><span>3</span><span>:</span><span> </span><span>.</span><span>/</span><span>bin</span><span>/</span><span>2</span><span>_mvp bench</span><span>.</span><span>txt</span></p><p><span>  </span><span>Time</span><span> </span><span>(</span><span>mean ± σ</span><span>)</span><span>:</span><span>      </span><span>1.205</span><span> s ±  </span><span>0.008</span><span> s    </span><span>[</span><span>User</span><span>:</span><span> </span><span>1.015</span><span> s</span><span>,</span><span> System</span><span>:</span><span> </span><span>0.115</span><span> s</span><span>]</span><span></span></p><p><span>  </span><span>Range</span><span> </span><span>(</span><span>min … max</span><span>)</span><span>:</span><span>    </span><span>1.198</span><span> s …  </span><span>1.214</span><span> s    </span><span>3</span><span> runs</span></p><p><span>Benchmark </span><span>4</span><span>:</span><span> </span><span>.</span><span>/</span><span>bin</span><span>/</span><span>3</span><span>_simd bench</span><span>.</span><span>txt</span></p><p><span>  </span><span>Time</span><span> </span><span>(</span><span>mean ± σ</span><span>)</span><span>:</span><span>     </span><span>249.2</span><span> ms ±   </span><span>6.3</span><span> ms    </span><span>[</span><span>User</span><span>:</span><span> </span><span>79.5</span><span> ms</span><span>,</span><span> System</span><span>:</span><span> </span><span>100.5</span><span> ms</span><span>]</span><span></span></p><p><span>  </span><span>Range</span><span> </span><span>(</span><span>min … max</span><span>)</span><span>:</span><span>   </span><span>243.8</span><span> ms … </span><span>262.6</span><span> ms    </span><span>11</span><span> runs</span></p><p><span>Benchmark </span><span>5</span><span>:</span><span> </span><span>.</span><span>/</span><span>bin</span><span>/</span><span>4</span><span>_threads bench</span><span>.</span><span>txt</span></p><p><span>  </span><span>Time</span><span> </span><span>(</span><span>mean ± σ</span><span>)</span><span>:</span><span>     </span><span>181.1</span><span> ms ±   </span><span>4.1</span><span> ms    </span><span>[</span><span>User</span><span>:</span><span> </span><span>96.5</span><span> ms</span><span>,</span><span> System</span><span>:</span><span> </span><span>93.5</span><span> ms</span><span>]</span><span></span></p><p><span>  </span><span>Range</span><span> </span><span>(</span><span>min … max</span><span>)</span><span>:</span><span>   </span><span>177.4</span><span> ms … </span><span>193.7</span><span> ms    </span><span>16</span><span> runs</span></p><p><span>Summary</span></p><p><span>  </span><span>.</span><span>/</span><span>bin</span><span>/</span><span>4</span><span>_threads bench</span><span>.</span><span>txt ran</span></p><p><span>    </span><span>1.38</span><span> ± </span><span>0.05</span><span> times faster than </span><span>.</span><span>/</span><span>bin</span><span>/</span><span>3</span><span>_simd bench</span><span>.</span><span>txt</span></p><p><span>    </span><span>6.65</span><span> ± </span><span>0.16</span><span> times faster than </span><span>.</span><span>/</span><span>bin</span><span>/</span><span>2</span><span>_mvp bench</span><span>.</span><span>txt</span></p><p><span>   </span><span>75.84</span><span> ± </span><span>1.86</span><span> times faster than python3 </span><span>1</span><span>_c_regex</span><span>.</span><span>py bench</span><span>.</span><span>txt</span></p><p><span>  </span><span>494.38</span><span> ± </span><span>41.35</span><span> times faster than python3 </span><span>0</span><span>_mvp</span><span>.</span><span>py bench</span><span>.</span><span>txt</span></p></div></div></pre><p>With the SIMD + threads version processing at ~5.52 GiB/s.</p><p>If the SIMD stuff went over your head, <a href="https://lemire.me/blog/2025/08/09/why-do-we-even-need-simd-instructions/">Why do we even need SIMD instructions?</a> is a great introduction by Daniel Lemire who&#39;s written a lot of interesting stuff about SIMD optimizations e.g. <a href="https://lemire.me/blog/2024/06/08/scan-html-faster-with-simd-instructions-chrome-edition/">Scan HTML faster with SIMD instructions: Chrome edition</a>.</p><p>Let me know if I&#39;ve missed any obvious optimizations.</p><p>All the source files, and the benchmark script, can be found at <a href="https://github.com/healeycodes/counting-words-at-simd-speed">healeycodes/counting-words-at-simd-speed</a>.</p></div></div></div>
  </body>
</html>
