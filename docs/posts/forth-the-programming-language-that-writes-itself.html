<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ratfactor.com/forth/forth_talk_2023.html">Original</a>
    <h1>Forth: The programming language that writes itself</h1>
    
    <div id="readability-page-1" class="page">

<div>
    <p><img src="https://ratfactor.com/forth/talkimg/intro_chuck.png" alt="drawing of chuck moore with his real head"/></p>
    <p>Charles H. Moore and the pursuit of simplicity.
    </p><p>
    A talk by <a href="http://ratfactor.com/">Dave Gauer</a>, 2023. Made with <a href="http://ratfactor.com/minslides/">minslides</a>, <i>which I made for this talk</i>.
    </p><div>
        <p>Hello! These are my talk notes. The slides start out with
        fairly complete text and stand on their own, but they get
        more terse and cryptic later. I also use these notes to store the
        reference links and additional quotes for individual slides.
        </p><p>I might also flesh the notes out to include a sort-of transcript of
            the spoken part of the talk. Stay tuned.
        </p><p><i>Something that I will have in the actual talk:</i>
                Raise your hand (and keep it raised) if you&#39;ve:
		</p><ul>
			<li><b>heard</b> of Forth
			</li><li><b>written</b> any Forth
			</li><li><b>implemented</b> a Forth or Forth-like
			</li><li><b>you are</b> Chuck Moore
		</li></ul>
    </div>
</div>

<div>
    
    <p>When I was a wee programmer, I would sit around the virtual Usenet campires listening
       to the tall tales and legends of the elders.
    <img src="https://ratfactor.com/forth/talkimg/usenet_campfires.png" alt="usenet campfires on a desert scene: comp.lang.forth comp.lang.lisp and alt.religion.kibology"/>
</p></div>

<div>
    
    <p>I learned about magical languages with lots of (((((parenthesis))))).
    <img src="https://ratfactor.com/forth/talkimg/ycombo.png" alt="third eye open to the y combinator"/>
</p></div>



<div>
    
    <p>And I heard tell of a programming language so flexible that you could
       change the values of integers.
</p></div>

<div>
    
    <p><img src="https://ratfactor.com/forth/talkimg/wizard_chuck.png" alt="chuck moore as an adorable wizard"/></p><p>They said that language was called <b>Forth</b> and it was created
       by a mad wizard called <b>Chuck Moore</b> who could write any program in
       a couple screens of code.
</p></div>

<div>
    
    <p>Years went by and I wrote a lot of PHP. I lost friends to the Internet Explorer 6 wars.
    </p><p>But I never forgot about the legend of <b>Forth</b>.
</p></div>



<p>So I went on an adventure and I came back and I think I have some answers.
    <img src="https://ratfactor.com/forth/talkimg/forthwarrior.png" alt="a tired warrior returns from forth mountain"/>
</p>

<p>(Oh, and I confirmed the legend. I can make any integer equal anything I
       want.  Stick around &#39;til the end to see that Forth magic trick.)
</p>

<div>
	
    <p><img src="https://ratfactor.com/forth/talkimg/hp35.png" alt="hp-35 calculator with rpn syntax"/></p><p>I thought this was what Forth was all about:
    </p><pre>        3 4 +
        7
    </pre>
</div>

<div>
    
    <pre><i>$ bc
bc 1.07.1
Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006,
2008, 2012-2017 Free Software Foundation, Inc.
This is free software with ABSOLUTELY NO WARRANTY.
For details type `warranty&#39;.</i>
(3 * 4) + (5 * 6)
42
    </pre>
</div>





<p>That&#39;s <b>true</b>, but then I learned some more...
</p>

<div>
    
    <p><img src="https://ratfactor.com/forth/talkimg/pushswapdup.png" alt="drawing of three stacks illustrating push swap and dup operations"/>
</p></div>

<div>
    <pre>        Op   The Stack
        --   ---------
        3     3
        4     3  4
        *     12
        5     12 5
        6     12 5  6
        *     12 30
        +     42
        .
    </pre>
</div>

<div><p>
    REMOVED SLIDE:
    </p><p>Using &#34;the stack&#34; in i386 assembly:
    </p><pre>        mov eax, 3
        mov ebx, 4
        mul eax, ebx
        push eax
        mov eax, 5
        mov ebx, 6
        mul eax, ebx
        pop ebx
        add eax, ebx
        <i>eax=42</i>
    </pre>
</div>



<div>
    <p>Lack of explicit names for intermediate values.
    </p><p>If I ask you to add these numbers:
    </p><pre>        2 6 1 3 7
    </pre>
    <p>Do you feel a need to give a <i>name</i> to each sum pair...or even the running total?
</p></div>

<p>That&#39;s <b>true</b>, but then I learned some more...
</p>

<div>
    
    <p><img src="https://ratfactor.com/forth/talkimg/computer_cat.png" alt="a confused cat working on an old pc"/></p><p>Ah, <i>this</i> must be it because it sounds fancy.
</p></div>

<div>
    <p>Contrast with <b>applicative</b> language:
    </p><pre>        eat(bake(prove(mix(<b>ingredients</b>))))
    </pre>
    <p>Concatenative language:
    </p><pre>        <b>ingredients</b> mix prove bake eat
    </pre>
</div>

<p>The canonical example of a concatenative language is <b>Joy</b>
</p>

<div>
    
    <p><b>Manfred von Thun</b> inspired by Backus&#39;s 1977 ACM Turing Award lecture:
    <img src="https://ratfactor.com/forth/talkimg/backus.jpg" alt="top of the john backus paper Can Programming Be Liberated from the von Neumann Style? A Functional Style and Its Algebra of Programs"/>
</p></div>

<div>
    
    <p><b>Joy</b> is kind of like starting with a  Lisp
    </p><p>Minus function parameters
    </p><p>Minus variables
    </p><p>Minus traditional control structures
</p></div>

<div>
    
    <p>All functions are unary (an arity of 1)
    </p><p>Stack in, stack out
    </p><p>A program is a list of data and functions
    </p><p><b>Joy&#39;s</b> superpower: combinators
    </p>
</div>

<div>
    
    <p>Higher-order functions like <b>map</b>:
    </p><pre>        inc = function(n){ return n + 1; };

        bigger = list.<b>map</b>(inc);
    </pre><p>

    Concatenatively:

    </p><pre>        list [inc] <b>map</b>
    </pre>
    <p>
        Note the lack of a variable &#34;bigger&#34; here. This is a halmark
        of concatenative programming - we don&#39;t need to name every
        intermediate value which can be a blessing...or curse
    </p>
</div>

<p><i>To Mock a Mockingbird</i>
    </p>



<div>
    <p><b>K</b> and <b>S</b>
    </p><pre>        (K x y) = x

        (S x y z) = (x z (y z))
    </pre>
</div>

<p><i>Combinators: A Centennial View</i>
    </p>

<div><p>
    REMOVED SLIDE (I don&#39;t think I was explaining this right and
    at any rate, when I did my first read-through, it took me 2 hours!)
    </p><p>A function using a combinator to reverse lists in <b>Joy</b>:
    </p><pre>        reverselist == [] swap infra
    </pre>
	<div>
		<p><b>infra</b> takes a list as one param and a program as a second
        and uses the list as temp stack and executes the program.
        </p><p>The <b>swap</b> here is just to get the param order correct for
        infra, it has nothing to do with reversing the input list.
	</p></div>
</div>

<div>
    <p>Combinators let us factor out explicit loops.
    </p><pre>        foo<b>.map</b>(bar)
    </pre><p>
    equals
    </p><pre>        <b>temp = [];</b>
        <b>for(i=0; i&lt;</b>foo<b>.length; i++){
            temp[i] = </b>bar(<b>foo[i]</b>)<b>;
        }</b>
    </pre>
</div>

<div>
    <p>And in <b>Joy</b>, combinators can factor out all sorts of logic
    </p><p>Even different flavors of recursion made feasable by the
        uniformly unary functions.
    </p><p>Here&#39;s a factorial definition:
    </p><pre>fac  == [null] [succ] [dup pred] [*] <b>linrec</b>
    </pre>
    <!-- where linrec is linear recursion and it takes 4 params -->
</div>

<div>
    <p>Forth has higher order functions too with word &#34;execution tokens&#34; (function pointers).
    </p><pre>        EXECUTE
    </pre>
    <p>You can very compactly define words such as
        <b>MAP</b>, <b>FOLD</b>, and
        <b>REDUCE</b>.
</p></div>

<p>Forth is definitely concatenative.
</p>

<div>
    <p>However,
    </p><pre>        2 3 +
    </pre>
    <p><b>Forth:</b> &#34;Push <code>2</code>, then 3 on the stack; pop both and add them;
        push the result, 5, on the stack.&#34;
    </p><p><b>Joy:</b> &#34;The <i>composition</i> of the functions 2, 3, and +
        is identical to the function 5.&#34;
</p></div>

<div>
    <p>All these aspects of Forth:
    </p><ul>
        <li>Postfix notation (RPN)
        </li><li>Stack-oriented
        </li><li>Concatenative programming style
    </li></ul>
    <p>Are true.
    </p><p>They are all perfectly valid and complementary ways of describing the
        <i>language</i> Forth:
    </p><pre>        CAKE EAT
    </pre>
</div>

<div>
    <p><img src="https://ratfactor.com/forth/talkimg/zuse_z3_computer.png" alt="drawing of konrad zuse&#39;s z3 computer"/></p><p>Yes, <b>postfix</b> notation was definitely in the air (Zuse&#39;s Z3 1938).
    </p><p>And yes, <b>stacks</b> were <i>known</i> in the time of Forth&#39;s origins, but generally limited (2-4 items in registers).
    </p><p>But Joy (and the term &#34;<b>concatenative programming</b>&#34;) come from the 1980s.
</p></div>

<div>
    <p><img src="https://ratfactor.com/forth/talkimg/chuck_to_the_future.png" alt="chuck moore as marty in a drawing of the back to the future poster"/></p><p>We need to go back to the 1950s.
</p></div>

<div>
    
    <p><img src="https://ratfactor.com/forth/talkimg/ibm_704.png" alt="chuck moore operating an IBM 704"/>
</p></div>

<div>
    <p>Fortran on punchards
    </p><p>&#34;Compiling took 30 minutes...you got one shot per day&#34;
    </p><p>-- Chuck Moore, Forth, the Early years
    </p><div>
        <p>SAO and MIT are really close to each other. So the story isn&#39;t as
            confusing as it first seems in <i>Forth - The Early Years</i>.
            Is Chuck at SAO or MIT or Stanford? The answer, geographically, is yes.
        </p><p>As for the computer:
        <a href="https://en.wikipedia.org/wiki/IBM_704">https://en.wikipedia.org/wiki/IBM_704</a>
        </p><p>&#34;In its day, the 704 was an exceptionally reliable machine. Being a vacuum-tube machine, however, the IBM 704 had very poor reliability by today&#39;s standards. On average, the machine failed around every 8 hours, which limited the program size that the first Fortran compilers could successfully translate because the machine would fail before a successful compilation of a large program.&#34;
    </p></div>
</div>

<div>
    <p>Made an interactive interpreter.
    </p><p>On a computer with nothing we would recognize as a terminal.
    </p><p>Control an astronomical calculation program using
        statement numbers.
    <img src="https://ratfactor.com/forth/talkimg/fortran_punchcard.png" alt="fortran on a punchcard"/>
    </p><div>
        <p>Specifically: &#34;Moore&#39;s programming career began in the late 1950s at the Smithsonian Astrophysical Observatory with programs to compute ephemerides, orbital elements, satellite station positions, etc. His source code filled two card trays. To minimize recompiling this large program, he developed a simple interpreter to read cards controlling the program. This enabled him to compose different equations for several satellites without recompiling...&#34;
        </p><p>Free-form input was more efficient (smaller and faster) and more
            reliable than Fortran column-formatted, which resulted in re-runs
            due to mis-aligned columns.
        </p><p>
        <a href="https://www.forth.com/resources/forth-programming-language/">https://www.forth.com/resources/forth-programming-language/</a>
    </p></div>
</div>

<div>
    <p>Arguably, this really is the origins of the thing that will be named
        <b>Forth</b>.
    </p><p>And the statement numbers would be equivalent to the words:
    </p><pre>        WORD
        NUMBER
        INTERPRET
        ABORT
    </pre>
    <p>Free-form input unusual at the time, but super handy
        alternative to recompiling every time you want to change
        the numbers.
</p></div>

<div>
    
    <p><img src="https://ratfactor.com/forth/talkimg/burroughs_b5500_computer.png" alt="drawing of chuck at the stanford burroughs b5500 system"/></p>
</div>

<div>
    <p>CURVE written in Stanford&#39;s own Algol implementation.
    </p><p>A much more sophisticated interpreter.
    </p><p>Now has a data stack and stack manipulation operators:
    </p><pre>        + - * IF ELSE DUP DROP SWAP
    </pre>
</div>

<div>
    
    <p><img src="https://ratfactor.com/forth/talkimg/teletype33.png" alt="a teletype 33 with paper tape reader and writer"/></p><p>&#34;With the TTY came paper-tape and some of the
        most un-friendly software imaginable - hours of editing and punching
        and loading and assembling and printing and loading and testing
        and repeating.&#34;
    </p><p>-- Chuck Moore, Forth, the Early years
    </p><p>&#34;Punched tape was used as a way of storing messages for teletypewriters. Operators typed in the message to the paper tape, and then sent the message at the maximum line speed from the tape. This permitted the operator to prepare the message &#34;off-line&#34; at the operator&#39;s best typing speed, and permitted the operator to correct any error prior to transmission. An experienced operator could prepare a message at 135 words per minute (WPM) or more for short periods.&#34;
        <a href="https://en.wikipedia.org/wiki/Punched_tape">https://en.wikipedia.org/wiki/Punched_tape</a>
    </p>
</div>

<div>
    <p>And terminals! terminal input and output
    </p><pre>        KEY EMIT CR SPACE DIGIT
    </pre>
    <p>Also, in-forth editor (kinda IDE, kinda OS).
</p></div>

<div>
    
    <p>IBM 1130 minicomputer at a big textiles manufacturer.
    <img src="https://ratfactor.com/forth/talkimg/ibm_1130.png" alt="drawing of chuck at an IBM 1130 minicomputer"/>
</p></div>

<div>
    <p><img src="https://ratfactor.com/forth/talkimg/ibm_1130.png" alt="drawing of chuck at an IBM 1130 minicomputer"/></p><p>16 bit, 8k ram.
    </p><p>Backup was via punch/reader.
    </p><p>With disks, now we can have file names!
    </p><p>Limited to 5 characters.
    </p><p>Moore&#39;s &#34;fourth generation&#34; system becomes FORTH.
</p></div>

<div>
    <p>Now have a return call stack, allowing nested definitions
    </p><pre>        : double dup + ;
        : quad double double ;
    </pre>
</div>

<div>
    <p><img src="https://ratfactor.com/forth/talkimg/univac_1108.png" alt="drawing of chuck at a univac 1108 console"/></p>
    <p>Univac 1108
    </p><p>Same textile company.
    </p><p>Written in assembler and could call COBOL modules because that&#39;s
        what the corporate suits wanted in 1970.
    </p><p>Moore <b>hates complexity</b>
</p></div>

<div>
    
    <p>National Radio Astronomy Observatory
     - Computer control software for radio telescopes.
    <img src="https://ratfactor.com/forth/talkimg/nrao.png" alt="drawing of radio telescope dishes from NRAO"/>
</p></div>

<div>
    <p>At this time, there are talks of patenting Forth.
    </p><p>Moore believes <b>ideas shouldn&#39;t be patented</b>.
</p></div>

<div>
    <p>He also rejects the standardization of Forth.
    </p><p>&#34;All of my fears of the standard and none of the advantages of the standard have come to pass. Any spirit of innovation has been thoroughly quelched.
    </p><p>-- Chuck Moore, 1997
    </p>
</div>

<p>Ported to the IBM 360/50
    <img src="https://ratfactor.com/forth/talkimg/ibm_360_50.png" alt="drawing of chuck using an ibm 360/50 computer"/>
</p>

<p>And to the Honeywell 316
    <img src="https://ratfactor.com/forth/talkimg/honeywell_316.png" alt="drawing of chuck using a honeywell 316computer"/>
</p>

<p>And to the Honeywell DDP-116
    <img src="https://ratfactor.com/forth/talkimg/ddp_116.png" alt="drawing of chuck using a honeywell DDP-116 computer"/>
</p>

<p>And to the DEC PDP-11 (yes, <i>that</i> PDP-11)
    <img src="https://ratfactor.com/forth/talkimg/dec_pdp_11.png" alt="drawing of chuck using a DEC PDP-11 computer"/>
</p>

<div>
    <p>All of this porting possible because of <b>indirect threaded code</b>.
    <img src="https://ratfactor.com/forth/talkimg/threaded_code_abstract.png" alt="an abstract drawing of boxes and arrows representing threaded code in memory"/>
    </p>
</div>

<div>
    <p><b>Threaded code</b> is <i>not</i> related to concurrency, i.e. &#34;multi-threaded programming&#34;.
    </p><p>It&#39;s code that consists almost completely of calls to subroutines.
    </p><p>Could be machine code or interpreted.
</p></div>

<div>
    <p>Direct calls:
    </p><pre>        call 0x0804000
        call eax
    or
        jmp 0x0804000
        jmp eax
    </pre>
</div>

<div>
    <p>Indirect calls:
    </p><pre>        call [eax]
    or
        jmp [eax]
    </pre>
</div>

<div>
    <p>Indirect threaded code:
    </p><pre>        call [eax]
        call [eax]
        call [eax]
        call [eax]
    </pre>
</div>

<div>
    <p>X-treme indirect threaded code:
    </p><pre>        [eax]
        [eax]
        [eax]
        [eax]
    </pre>
</div>

<div>
    <p><img src="https://ratfactor.com/forth/talkimg/16k_memory.png" alt="drawing of a minicomputer saying &#39;i have 16k of core!&#39;"/></p><p><b>Threaded code</b> was much more common in the days of yore.
    </p><p>It is very dense, compact on disk and in memory.
</p></div>

<div>
    <p><img src="https://ratfactor.com/forth/talkimg/chuck_hero.png" alt="drawing of chuck moore as a superhero with a cape and bowtie"/></p><p>That&#39;s Forth&#39;s <b>origin story</b>.
    </p><ul>
        <li>Postfix notation (RPN)
        </li><li>Stack-oriented
        </li><li>Concatenative programming style
        </li><li>Interpreted
        </li><li>Highly adaptable to machine architectures
        </li><li>Extremely compact
    </li></ul>
    <p>This gives us the <i>why</i>.
    </p><div>
        <p>Forth is postfix because that&#39;s the most natural order
            for a computer: get the values, operate on them;
        </p><p>Stack oriented because that&#39;s an incredibly minimalistic
            and compact and convenient
            way to store values without having to create variables
            (and name them!);
        </p><p>Concatenative because building a language that can
            operate as a string of words is incredibly flexible
            and can adapt to any (?) programming style without
            any help from the language itself. Especially with
            combinators;
        </p><p>Interpreted because that is interactive and allows
            changes on the fly. Again, because Forth is all about
            absolute maximum adaptibility;
        </p><p>Highly adaptable because you can bootstrap a Forth
            implementation from a handful of words implemented in
            assembly and then write the rest in Forth;
        </p><p>Extremely compact because computers at the time had
            extremely limited memory. And the ubiquitous low-power
            computers of the future may also demand this. The microcontrollers
            that control just about everything certainly do.
    </p></div>
</div>

<p>But somewhere along the way, I came across these quotes...
</p>

<div>
    <p>&#34;To understand Forth, you have to implement a Forth.&#34;
    </p><p>-- Somebody on the Internet
</p></div>

<div>
    <p>&#34;Take a look at JonesForth.&#34;
    </p><p>-- Everybody on the Internet
</p></div>

<p><img src="https://ratfactor.com/forth/talkimg/assembly-nights.jpg" alt="My faithful asus eeepc 701 waiting romantically on the bed text reads &#39;Assembly Nights&#39;"/>
</p>

<div>
    
	<p><img src="https://ratfactor.com/forth/talkimg/nasmjf.png" alt="my giant gold on gray logo for nasmjf"/></p><p>My NASM port of JonesForth: <code>nasmjf</code>
    </p><p>Opening the third eye by (re)implementing Forth.
</p></div>

<p>JonesForth ascii art:
    <img src="https://ratfactor.com/forth/talkimg/jonesforth1.png" alt="jonesforth ascii art explaining flow of threaded code"/>
</p>

<p><code>nasmjf</code> ascii art:
    <img src="https://ratfactor.com/forth/talkimg/nasmjf1.png" alt="my nasmjf ascii art explaining flow of threaded code"/>
</p>

<div>
    <p>But that&#39;s just the tip of the iceberg!
    </p><p><code>nasmjf</code> inner/outer interpreter diagram:
    <img src="https://ratfactor.com/forth/talkimg/forth-diagram.png" alt="my nasmjf diagram showing outer and inner interpreter"/>
</p></div>

<div>
    <p>To get from one <b>code word</b> to another uses a bit of
       assembly pasted at the end of each in a chunk called
       the <b>NEXT</b> macro. Here it is from <code>nasmjf</code>:
    </p><pre>%macro NEXT 0
    lodsd     ; NEXT: Load from memory into eax, inc esi to point to next word.
    jmp [eax] ; Jump to whatever code we&#39;re now pointing at.
%endmacro
    </pre>
</div>

<div>
    <p>To get from one <b>colon word</b> to another uses a bit of
       assembly pasted at the end of each in a chunk called
       the <b>EXIT</b> macro. Here it is from <code>nasmjf</code>:
    </p><pre>DEFCODE &#34;EXIT&#34;,EXIT,0
    POPRSP esi            ; pop return stack into esi
NEXT
    </pre>
</div>

<div>
    <p>My comment in <code>nasmjf</code> attempting to explain the
		execution of indirect threaded
        code as a nested sequence of 
        sequence of <b>NEXT</b> and <b>EXIT</b> and <b>QUIT</b>:
    </p><pre>; QUIT (INTERPRET)
;     * regular word
;         DOCOL
;         NEXT
;         * regular word
;             DOCOL (codeword
;             NEXT
;             * code word
;                 &lt;machine code&gt;
;             NEXT
;             * code word
;                 &lt;machine code&gt;
;             NEXT
;         EXIT
;         NEXT
;    EXIT
;    NEXT
; QUIT (BRANCH -8 back to INTERPRET for more)
</pre></div>

<p>Absolutely nothing else drives the flow of an indirect
		threaded Forth application. It&#39;s addresses stored in
		registers and one or two line assembly instructions
		at the end of the word that manipulate the return
		stack as needed and jump to the next instruction.
</p>

<div>
    <p>Don&#39;t you see how simple it is?
    <img src="https://ratfactor.com/forth/talkimg/crazy_chuck.png" alt="drawing of chuck as crazy charlie explaining a theory with wild eyes and a wall covered in paper and strings"/>
    </p>
</div>

<p>Forth <i>is</i> complex when taken as a whole. But it is made of tiny
        pieces, each of which is <i>very</i> simple. The concept was created
        over a period of years on very constrained systems.
        Each part created only as needed.
    <img src="https://ratfactor.com/forth/talkimg/threaded_code_abstract.png" alt="an abstract drawing of boxes and arrows representing threaded code in memory"/>
</p>

<div>
    
    <p>Simple:
    </p><pre>DEFCODE &#34;SWAP&#34;,SWAP,0
    pop eax
    pop ebx
    push eax
    push ebx
NEXT
    </pre>
</div>

<div>
    
    <p>Simpler:
    </p><pre>DEFCODE &#34;DUP&#34;,DUP,0
    mov eax, [esp]
    push eax
NEXT
    </pre>
    <p>
        From JonesForth:
        &#34;In this FORTH, we are using the normal stack pointer (%esp) for the
        parameter stack.  We will use the i386&#39;s &#34;other&#34; stack pointer (%ebp,
        usually called the &#34;frame pointer&#34;) for our return stack.&#34;
    </p>
</div>

<div>
    
    <p>Simplest:
    </p><pre>DEFCODE &#34;DROP&#34;,DROP,0
    pop eax
NEXT
    </pre>
</div>

<div>
    
    <pre>8 7      <i>8 7</i>
SWAP     <i>7 8</i>
DROP     <i>7</i>
DUP      <i>7 7</i>
    </pre>
</div>

<div>
    
    <p><code>nasmjf</code> has 130 code words. Mostly for efficiency.
</p></div>



<div>
    
    <pre>: SDD SWAP DROP DUP ;
8 7      <i>8 7</i>
SDD      <i>7 7</i>
    </pre>
</div>

<div>
    
    <pre>: SDD SWAP DROP DUP ;
    </pre>
	<p>Colon (<code>:</code>) fetches the word name and sets &#34;compile mode&#34;.
	</p><p>Semicolon (<code>;</code>) completes the word&#39;s entry in the <b>dictionary</b> and unsets &#34;compile mode&#34;.
</p></div>

<div><p>
	&#34;Compiling&#34; in Forth means:
	</p><ul>
		<li>Putting the address of a word in memory
		</li><li>Putting the code to push a literal onto the stack
	</li></ul>
</div>

<p>
	Compiling is very similar to interpreting, but we&#39;re storing
	addresses instead of executing them.
</p>

<div>
    <p>Almost no syntax = simple interpreter
    </p><ul>
        <li>WORD (Overloaded term, sorry. Blame Chuck!)
        </li><li>Is it in the dictionary? (Compiling?)
        </li><li>Is it a literal? (Compiling?)
        </li><li>Otherwise, error!
    </li></ul>
    <pre>8 7 SWAP DUP DROP

: SDD SWAP DROP DUP ; 8 7 SDD
    </pre>
</div>

<div>
    <p>Almost no syntax = extreme extensibility.
    </p><p>The definition of <b>IF...THEN</b> from jonesforth.f:
    </p><pre>: IF IMMEDIATE &#39; 0BRANCH , HERE @ 0 , ;

: THEN IMMEDIATE DUP HERE @ SWAP - SWAP ! ;
    </pre>
</div>

<div>
    <p>Almost no syntax = extreme extensibility!!!!!
    </p><p>The definition of <b>( )</b> <i>nested comments</i> from jonesforth.f:
    </p><pre>: ( IMMEDIATE
    1
    BEGIN
        KEY DUP &#39;(&#39; = IF DROP 1+
        ELSE &#39;)&#39; = IF 1- THEN
        THEN
    DUP 0= UNTIL
    DROP
;

(
    From now on we can use ( ... ) for comments.
...
    </pre>
</div>

<div>
	<p>The <b>dictionary</b> uses a linked list and word
		matching is done from the most recently defined word, so:
	</p><ul>
		<li>You can redefine <i>any</i> word, even ones originally
			defined in assembly.
		</li><li>Uses of previous definitions don&#39;t break because the
			links to the previous words still point to the
			original.
		</li><li><i>You</i> are in complete control.
		</li><li>Forth = freedom
	</li></ul>
</div>

<div>
	<p><img src="https://ratfactor.com/forth/talkimg/apple_bw.png" alt="grayscale apple"/></p><p>It&#39;s not just the language itself that is unusually flexible,
		the <i>usage</i> of Forth allows for really surprising
		flexibility.
	</p><p>Example paraphrased from <i>Thinking Forth</i>. Say we create a variable to
		hold a number of apples:
	</p><pre>VARIABLE APPLES
20 APPLES !
APPLES ? <i>20</i>
	</pre>
	<p>Forth variables put <i>addresses</i> on the stack.
	</p>
</div>

<div>
	<p>We pepper our program with this <b>APPLES</b> variable.
	</p><p>Then we are told that we must now keep track of two different
		kinds of apples: red and green. What to do?
	</p><p><img src="https://ratfactor.com/forth/talkimg/apple_red.png" alt="red apple"/>
		<img src="https://ratfactor.com/forth/talkimg/apple_green.png" alt="green apple"/>
	</p>
</div>

<div>
    <p>A new variable will store the current type of apples.
	</p><pre>VARIABLE COLOR
	</pre>
</div>

<div>
	<p><img src="https://ratfactor.com/forth/talkimg/apple_red.png" alt="red apple"/></p><p>A new variable and word will deal with red apples. The word sets the
       type of apple by storing the address of REDS in COLOR.
	</p><pre>VARIABLE REDS
: RED REDS COLOR ! ;
	</pre>
</div>

<div>
	<p><img src="https://ratfactor.com/forth/talkimg/apple_green.png" alt="green apple"/></p><p>Same for green.
	</p><pre>VARIABLE GREENS
: GREEN GREENS COLOR ! ;
	</pre>
</div>

<div>
	<p>And change <b>APPLES</b> from a variable to a word that gets the current count by color:
	</p><pre>: APPLES COLOR @ ;
	</pre>
	<p><img src="https://ratfactor.com/forth/talkimg/apple_bw.png" alt="grayscale apple"/>
		<img src="https://ratfactor.com/forth/talkimg/apple_red.png" alt="red apple"/>
		<img src="https://ratfactor.com/forth/talkimg/apple_green.png" alt="green apple"/>
	</p>
    <p>Now we have to re-write any use of <b>APPLES</b>, right?
</p></div>

<div>
    <p>Wrong! The use of <b>APPLES</b> is <i>identical</i>. The syntax hasn&#39;t
        changed one bit for any existing code. We just need to make sure we&#39;ve
        set the right color.
	</p><pre>20 RED APPLES !
30 GREEN APPLES !

GREEN APPLES ? <i>30</i>
APPLES ? <i>30</i>

RED
APPLES ? <i>20</i>
	</pre>
	<p><img src="https://ratfactor.com/forth/talkimg/apple_bw.png" alt="grayscale apple"/>
		<img src="https://ratfactor.com/forth/talkimg/apple_red.png" alt="red apple"/>
		<img src="https://ratfactor.com/forth/talkimg/apple_green.png" alt="green apple"/>
	</p>
</div>

<div>
    <p>&#34;I didn&#39;t create Forth, I discovered it.&#34;
    </p><p>-- Chuck, apocryphally
</p></div>

<p>Making <code>nasmjf</code> gave me so many ideas, I <i>had</i> to try some
        experiments.
</p>

<p><img src="https://ratfactor.com/forth/talkimg/assembly-nights2.jpg" alt="my lenovo 11e thinkpad with assembly code waiting romantically on the bed with a candle. text reads &#39;Assembly Nights II&#39;"/>
</p>

<div>
    
	<p><img src="https://ratfactor.com/forth/talkimg/meow5.png" alt="meow5 cat logo"/></p><p>An exercise in extreme <b>concatenative</b> programming where
		<i>all code</i> is concatenated (inlined).
</p></div>

<div>
    
	<pre>: meow &#34;Meow. &#34; print ;
meow
<i>Meow.</i>

: meow5 meow meow meow meow meow ;
meow5
<i>Meow. Meow. Meow. Meow. Meow.</i>
	</pre>
</div>

<div>
    
    <p>Despite attempting to make something radically different,
        it&#39;s remarkable how many times Forth&#39;s solution was the
        path of least resistance.
    </p><p>&#34;Aha! <i>That&#39;s</i> why.&#34;
</p></div>

<div>
    <p>Example: string quoting
    </p><pre>        &#34; Hello World.&#34;
    </pre>
</div>

<div>
    <p>Meow5 has this quoting:
    </p><pre>        &#34;Hello World.&#34;
    </pre>
    <p>But the effects are cascading...and limit flexibility
</p></div>

<p>&#34;Aha! <i>That&#39;s</i> why.&#34;
</p>

<div>
    <p>This is why I titled this &#34;The programming language that writes itself&#34;
    </p><ul>
        <li>In the boostrapping sense
        </li><li>In the metaprogramming sense
        </li><li>In the &#34;mathematical truth&#34; sense
    </li></ul>
</div>

<p>
    Also in this sense...
</p>

<div>
    
    <p>Hand-written 1Kb binary
    <img src="https://ratfactor.com/forth/talkimg/planckforth.jpg" alt="binary layout of planckforth as taken from the repo"/>
    </p>
</div>

<div>
	<p>Forth is an <b>idea</b> that has taken form in countless applications, many
		of them custom and home-grown.
	</p><ul>
		<li>Power plants, robotics, missle tracking systems, industrial automation.
		</li><li>Embedded language in video games.
		</li><li>Microcontrollers.
		</li><li>Legacy: databases, accounting, word processors, graphics, and computation systems.
		</li><li>On the modern OpenFirmware boot loader.
	</li></ul>
	
</div>

<div>
    
	<p><img src="https://ratfactor.com/forth/talkimg/jupiter_ace.png" alt="drawing of the jupiter ace home computer"/></p><p>Operating system: Forth.
    </p><p>OS and library of routines in 8 KB of ROM.
    </p><p>&#34;Ten times faster than [interpreted] BASIC&#34; and less than half the memory requirements.
    </p>
</div>

<div>
    
	<p><img src="https://ratfactor.com/forth/talkimg/canon_cat.png" alt="drawing of the canon cat word processor home computer"/></p><p>Operating system: Forth.
    </p><p>OS and office suite in 256 KB of ROM.
    </p><p>Innovative interface by Jef Raskin.
    </p>
</div>

<div>
    <p><img src="https://ratfactor.com/forth/talkimg/forth_in_space.png" alt="title says Forth in Space and chuck is an astronaut on EVA who says May the Forth be with you."/></p><p>
		&#34;May the Forth be with you.&#34; is courtesy my daughter. :-)
	</p>
</div>

<div>
	
	<p><img src="https://ratfactor.com/forth/talkimg/nasa_list.jpg" alt="unreadable list of a ton of nasa projects using forth"/></p><p>The 2003 list by NASA&#39;s James Rash is too long to easily list.
	</p>
</div>

<div>
	
	<p><img src="https://ratfactor.com/forth/talkimg/nasa_ssbuv_patch.png" alt="nasa mission patch for ssbuv"/></p><p>&#34;There is always great concern about software reliability, especially with flight software.&#34;
	</p>
</div>

<div>
	
	<p><img src="https://ratfactor.com/forth/talkimg/nasa_robot_arm.png" alt="robot arm in space shuttle"/></p><p>Control of 50-foot long, six-joint arm for Space Shuttle simulator. Extensive math routines convert two three-axis joystick commands into required joint velocities in six different co-ordinate systems. Entire system developed by <b>one programmer in five weeks.</b>
	</p>
</div>

<div>
	
	<p><img src="https://ratfactor.com/forth/talkimg/nasa_shuttle.png" alt="drawing of the shuttle launching"/></p><p>Multitasking operating system, Forth language compiler, and libraries for UT69R000 radiation-hardened microprocessor used in Space Shuttle instrumentation.
	</p>
</div>

<div>
	<p><b>Harris RTX2010</b> used in a ton of space applications.
	<img src="https://ratfactor.com/forth/talkimg/harris_rtx.jpg" alt="block diagram of harris chip"/></p><ul>
		<li>Direct execution of Forth
		</li><li>Radiation hardened
		</li><li>8MHz clock, extremely low latency 
		</li><li>Two stacks, 256 words deep
	</li></ul>
	
</div>

<div>
	
	<p><img src="https://ratfactor.com/forth/talkimg/rosetta_spacecraft.png" alt="drawing of rosetta approaching comet"/></p><p>First mission to send a lander to a comet!
	</p><p>Forth used for the <b>Rosetta</b> Ion and Electron Sensor instrument, using Harris RTX2010 Forth microprocessor.
	</p><p>The <b>Philae</b> lander is powered by two 8MHz Harris RTX2010 16-bit stack processors...used by the Philae CDMS to control all aspects of the lander.
	</p><div>
		<p><a href="https://www.nasa.gov/rosetta">https://www.nasa.gov/rosetta</a>
		</p><p><a href="https://www.cpushack.com/2014/11/12/here-comes-philae-powered-by-an-rtx2010/">https://www.cpushack.com/2014/11/12/here-comes-philae-powered-by-an-rtx2010/</a>
		</p><p>&#34;Why was the RTX2010 chosen?  Simply put the RTX2010 is the lowest power budget processor available that is radiation hardened, and powerful enough to handle the complex landing procedure.  Philae runs on batteries for the first phase of its mission (later it will switch to solar/back up batteries) so the power budget is critical.  The RTX2010 is a Forth based stack processor which allows for very efficient coding, again useful for a low power budget.&#34;
	</p></div>
</div>

<div>
	<p><img src="https://ratfactor.com/forth/talkimg/rosetta_comet_67p.jpg" alt="photo of comet 67p taken by rosetta ("/></p>
</div>

<div>
    
    <p>Awesome talk by Jack Rusher
    <img src="https://ratfactor.com/forth/talkimg/stop_writing_dead_programs.jpg" alt="screenshot of jack&#39;s talk at the quoted position"/>
</p></div>

<div>
    
    <p><img src="https://ratfactor.com/forth/talkimg/jack_rusher.jpg" alt="crop of jack rusher from the previous screenshot"/></p><p>&#34;...Space probes written in Lisp and <b>Forth</b> have been
        debugged while off world...  If they had proven their programs
        correct by construction, shipped them into space, and then found out
        their spec was wrong, they would have just had some <b>dead junk on
            Mars</b>.  But what these guys had was the ability to fix things
        while they are running on space probes...  In addition, the spec is
        always wrong!&#34;
    </p><p>-- Jack Rusher, Stop Writing Dead Programs, 2022
    </p><div>
        <p>Check out Jack&#39;s <i>awesome</i> transcript here, which was
            super helpful when I wanted to re-find this quote.
            <a href="https://jackrusher.com/strange-loop-2022/">https://jackrusher.com/strange-loop-2022/</a>
        </p><p>&#34;Had I had more time, I would have done an entire series of slides on FORTH. It&#39;s a tiny language that combines interactive development, expressive metaprogramming, and tremendous machine sympathy. I&#39;ve shipped embedded systems, bootloaders, and other close-to-the-metal software in FORTH.&#34;
        </p><p>I finally found <i>a</i> story about Forth being updated in space, if
           not <i>the</i> story:
        </p><p>&#34;Also in 1993 I used MCL to help generate a code patch for the Gallileo magnetometer. The magnetometer had an RCA1802 processor, 2k each of RAM and ROM, and was programmed in Forth using a development system that ran on a long-since-decommissioned Apple II. The instrument had developed a bad memory byte right in the middle of the code. The code needed to be patched to not use this bad byte. The magnetometer team had originally estimated that resurrecting the development environment and generating the code patch would take so long that they were not even going to attempt it. Using Lisp I wrote from scratch a Forth development environment for the instrument (including a simulator for the hardware) and used it to generate the patch. The whole project took just under 3 months of part-time work.&#34;
        </p><p><a href="https://mecrisp-stellaris-folkdoc.sourceforge.io/lisp.html">https://mecrisp-stellaris-folkdoc.sourceforge.io/lisp.html</a>
    </p></div>
</div>

<p>When we defeat the alien kill-bots and reprogram them, it will
		surely be with a Forth of some sort.
	<img src="https://ratfactor.com/forth/talkimg/killbots_forth.png" alt="alien kill-bots being controlled by forth"/>
</p>

<div>
    
    <p><img src="https://ratfactor.com/forth/talkimg/forth_family_tree.jpg" alt="unreadably tiny diagram of lineage of various Forth implementations"/></p>
</div>

<div>
    
    <p>Charles H. Moore founded Forth, Inc in 1973. Has been porting Forth to various systems since.
    <img src="https://ratfactor.com/forth/talkimg/chuck_and_crt.png" alt="drawing of chuck at a desk programming on a pc with a crt. equipment looks 1990s era"/>
    </p>
</div>

<div>
    <p><span>color</span><span>Forth</span>
    <img src="https://ratfactor.com/forth/talkimg/colorforth.png" alt="screenshot of colorforth"/>
	</p>
</div>

<div>
    <p>Fighting the good fight against software complexity since the 1950s.
    </p><p>&#34;I am utterly frustrated with the software I have to deal with. Windows is beyond comprehension! UNIX is no better. DOS is no better. There is no reason for an OS. It is a non-thing. Maybe it was needed at one time.
    </p><p>-- Chuck Moore, 1997
	</p><p>
		Once again, from the compiled quotes at ultratechnology.com
	</p>
</div>

<div>
    <p>&#34;If they are starting from the OS they have made the first mistake. The OS isn&#39;t going to fit on a floppy disk and boot in ten seconds.&#34;
    </p><p>-- Chuck Moore, 1999
	</p><p>
		Once again, from the compiled quotes at ultratechnology.com
	</p>
</div>

<div>
    <p>Instead of being rewritten, software has features added. And becomes more complex. So complex that no one dares change it, or improve it, for fear of unintended consequences. But adding to it seems relatively safe. We need dedicated programmers who commit their careers to single applications. Rewriting them over and over until they&#39;re perfect. 
    </p><p>-- Chuck Moore, 2009
	</p><p>
		Once again, from the compiled quotes at ultratechnology.com
	</p>
</div>

<p>His <i>real</i> love seems to be hardware.
	Remember that <b>Harris RTX2010</b>? That&#39;s basically his design.
	<img src="https://ratfactor.com/forth/talkimg/chuck_chip_scientist.png" alt="chuck as a mad scientist chip creator"/>
</p>

<div>
    <p>Has been designing hardware since 1983 starting with the
        Novix N400 gate array and dev board.
    </p><p>(An improved processor sold to Harris to become the RTX* chips.)
    </p><p>Has been designing chips ever since.
    </p><p>With his own VLSI software, &#34;OKAD&#34;, written in 500 lines of Forth, of course.
	</p>
</div>

<div>
    <p><b>GreenArrays</b>. &#34;Programming a 144-computer chip to minimize power&#34; (2013)
	</p><p>144 asynchronous computers on a chip. Idle cores use 100 nW. Active ones use 4 mW, run at 666 Mips, then return to idle. All computers running flat out: 550mW (half a Watt).
	<img src="https://ratfactor.com/forth/talkimg/greenarrays_144_computers.jpg" alt="screenshot from Chuck&#39;s 2013 strange loop talk about 144 computer chip"/>
	</p><div>
		<p><a href="https://www.youtube.com/watch?v=0PclgBd6_Zs">youtube.com: &#34;Programming a 144-computer chip to minimize power&#34; - Chuck Moore (2013)</a>
		</p><p><a href="https://www.greenarraychips.com/">https://www.greenarraychips.com/</a>
		</p><p>&#34;COMPLETE SYSTEMS: We refer to our chips as Multi-Computer Systems because they are, in fact, complete systems. Supply one of our chips with power and a reset signal, and it is up and running. All of our chips can load their software at high speed using a single wire that can be daisy chained for multiple chips; if desired, most can be bootstrapped by a simple SPI flash memory.&#34;
		</p><p>&#34;Contrast this with a Multi-Core CPU, which is not a computing system until other devices such as crystals, memory controllers, memories, and bus controllers have been added.  All of these things consume energy, occupy space, cost money, add complexity, and create bottlenecks.&#34;
		</p><p>&#34;NO CLOCKS: Most computing devices have one or more clocks that synchronize all operations. When a conventional computer is powered up and waiting to respond quickly to stimuli, clock generation and distribution are consuming energy at a huge rate by our standards, yet accomplishing nothing.&#34;

<a href="https://www.greenarraychips.com/home/documents/greg/PB002-100822-GA-Arch.pdf">https://www.greenarraychips.com/home/documents/greg/PB002-100822-GA-Arch.pdf</a>
	</p></div>
</div>

<div>
    <p>&#34;If you talk about molecular computers that are circulating in your bloodstream, they aren&#39;t going to have very much power and they aren&#39;t going to have very much memory and they aren&#39;t going to be able to use much energy.
    </p><p>-- Chuck Moore, <i>Programming a 144-computer chip to minimize power</i>, 2013
    </p><div>
        <p>Totally, like, my opinion:
        </p><p>The complete domination of x86 PCs in practically all
            areas of computing until very recently is an accident of history.
            There is absolutely no reason to believe that this is how the
            majority of computing will continue to be done in the decades to
            come.
        </p><p>Even <i>relatively</i> low-energy devices like our
            smart phones require massive computing power to do most tasks,
            especially anything having to do with a web browser.
        </p><p>There are physical realities about how much computing <i>power</i>
            (and memory) you can have per unit of energy. There are plenty
            of applications where low energy computing is a hard requirement
            and I believe these applications will only increase.
        </p><p>Also, virtualization changes things, too. We went from single
            applications taking over the whole computer to running a bunch
            of things on the same computer, to virtualized computers or
            containers where we&#39;re back to applications thinking they&#39;re
            the only thing on the computer again. VMs tend to be constrained
            by both power and memory.
    </p></div>
</div>

<div>
    <p>I think Forth-likes have a strong future as we look towards:
    </p><ul>
        <li>Tiny, ubiquitious computers
        </li><li>Solar power
        </li><li>Heavily constrained VMs
    </li></ul>
</div>

<div>
    
    <p><img src="https://ratfactor.com/forth/talkimg/wizard_chuck.png" alt="chuck moore as an adorable wizard"/></p><p>Now, behold a new definition of the integer 4:
    </p><pre>    : 4 12 ;
    </pre>
    <p>Which results in:
    </p><pre>    .&#34; The value of 4 is &#34; 4 . CR
    The value of 4 is 12
    </pre><p>
    Tada!
</p></div>




</div>
  </body>
</html>
