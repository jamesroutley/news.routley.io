<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ratfactor.com/forth/the_programming_language_that_writes_itself.html">Original</a>
    <h1>Forth: The programming language that writes itself</h1>
    
    <div id="readability-page-1" class="page">

<div>
    <center>
        
        <h2><i>Charles H. Moore and the pursuit of simplicity.</i></h2>

        <img src="https://ratfactor.com/forth/talkimg/intro_chuck_web.png" alt="drawing of chuck moore with his real head - with a scroll that says The Web Page Edition"/>
    </center>

    <div>
        <p> <b>Author:</b> <a href="http://ratfactor.com">Dave Gauer</a></p><p><b>Note:</b> This page is my personal journey to discover Forth
            and put it in the context of computing history.
            It is adapted from my
            <a href="https://ratfactor.com/forth/forth_talk_2023.html">slides</a> for a short talk.
            I&#39;ve done everything in my power to make this page scale up and down
            for various screen sizes. I welcome suggestions and corrections for
            both the content and display of this page. 
            Here&#39;s my
            <a href="http://ratfactor.com/contact-me">contact page</a>.
        </p>
    </div>
</div>

<div>
    
    <p>When I was a wee programmer, I would sit around the virtual Usenet campfires listening
       to the tall tales and legends of the elders.
    <img src="https://ratfactor.com/forth/talkimg/usenet_campfires.png" alt="usenet campfires on a desert scene: comp.lang.forth comp.lang.lisp and alt.religion.kibology"/>
    </p><div>
        <p>In the 1990s, Usenet
        <a href="https://en.wikipedia.org/wiki/Usenet_newsgroup">newsgroups</a>
        (wikipedia.org)
        were where it was <em>at</em>.
        For example, Linus Torvalds&#39;s initial announcement of Linux was to
        comp.os.minix in 1991.
        </p><p>
        The <a href="https://en.wikipedia.org/wiki/Comp.*_hierarchy">comp.*</a>
        (wikipedia.org)
        groups and particularly comp.lang.* were great
        places to learn about and discuss programming.
        By the time I got there in the late 90s, Perl was a pretty hot topic,
        especially as it took a dominant role in the early Web as <em>the</em>
        dynamic page and form processing programming language via
        <a href="https://en.wikipedia.org/wiki/Common_Gateway_Interface">CGI</a>
        (wikipedia.org).
        </p><p>
        There were programming resources on the Web, but nothing like what&#39;s
        available now!
        To actually <em>learn to program</em>, I bought books,
        and still do.
        </p><p>
        Usenet was where the community and folklore lived.
        </p><p>
        (The &#34;Easter egg&#34; in this drawing is alt.religion.kibology, which should
        get a chuckle from old timers. The rest of you can look it up.)
    </p></div>
</div>

<div>
    <p>I learned about magical languages with lots of (((((parenthesis))))).
    <img src="https://ratfactor.com/forth/talkimg/ycombo.png" alt="third eye open to the y combinator"/>
    </p><div>
    <p>Sharp-eyed Lisp-lovers and other mutants will perhaps recognize this thing
    as the Y combinator expressed with lambdas.</p>
    <p>The only time I understood this was when I completed
    the book <i>The Little Schemer</i> by Friedman and Felliesen, which
    walks you through creating it for yourself. It is a magical book and
    I implore you to try it.</p>
    </div>
</div>

<div>
    <p>I listened, wide-eyed, to true tech tales like <i><a href="https://foldoc.org/The+Story+of+Mel">The Story of Mel</a></i> (foldoc.org).
    <img src="https://ratfactor.com/forth/talkimg/mel_rpc_4000.png" alt="Royal McBee RPC-4000 computer drawing"/>
    </p><div>
        <p>Mel was real and the Royal McBee RPC-4000 was real. Look at that teletype
        (aka &#34;teleprinter&#34;). If typewriters and &#34;Royal&#34; together make a little bell
        in your head go &#34;bing&#34; as your mental carriage hits the end of the page,
        then you&#39;re right: Royal McBee was a merger between the
        <a href="https://en.wikipedia.org/wiki/Royal_Typewriter_Company">Royal
            Typewriter Company</a> (wikipedia.org) and McBee, a manufacturer of accounting machines.</p>
        <p>For a while, Royal was owned by the Italian typewriter company, Olivetti,
        who also made some <a href="https://en.wikipedia.org/wiki/Olivetti_computers">really interesting computers</a> (wikipedia.org).</p>
        <p>And then...
    </p></div>
</div>

<p>I heard tell of a programming language so flexible that you could
    <em>change the values of integers</em>.
</p>

<center>
<img src="https://ratfactor.com/forth/talkimg/wizard_chuck.png" alt="chuck moore as an adorable wizard"/>
</center>

<p>They said that language was called <b>Forth</b> and it was created
       by a mad wizard called <b>Chuck Moore</b> who could write any program in
       a couple screens of code.
</p>

<div>
    <p>Years went by and I wrote a lot of PHP and JavaScript.
    I watched the Web evolve (and sometimes de-evolve).
    </p><p>But I never forgot about the legend of Forth.
</p></div>

<div>
    <p>The blog series
       <a href="https://prog21.dadgum.com/">&#34;programming in the twenty-first century&#34;</a>
       (prog21.dadgum.com)
    by game developer James Hague gave me the final push.
    </p><p>He made Forth a recurring theme and it just sounded so darned interesting.
</p></div>

<p>So I went on an adventure and now that I have returned, I think I have some
    answers.
    <img src="https://ratfactor.com/forth/talkimg/forthwarrior.png" alt="a tired warrior returns from forth mountain"/>
</p>

<div>
    <p>(Oh, and I <strong>confirmed the legend</strong>. I can make any integer
    equal anything I want.  Stick around &#39;til the end to see that Forth magic
    trick.)
    </p><center>
    <img src="https://ratfactor.com/forth/talkimg/wizard_chuck.png" alt="chuck moore as an adorable wizard"/>
    </center>
</div>

<center>
    &#34;Voilà!&#34;
</center>


<div>
	
    <p><img src="https://ratfactor.com/forth/talkimg/hp35.png" alt="hp-35 calculator with rpn syntax"/></p><p>At first, I thought this was what Forth was all about:
    </p><pre>3 4 +
<i>7</i>
    </pre>
    <div>
        <p>Now begins my quest to understand Forth.
        </p><p>Perhaps you&#39;ve seen postfix or
        <a href="https://en.wikipedia.org/wiki/Reverse_Polish_notation">Reverse Polish Notation (RPN)</a>
        (wikipedia.org)
        before? The principle is simple: Instead of the usual &#34;infix&#34; notation
        which puts operators between operands (<code>3 + 4</code>), RPN puts
        operators <em>after</em> the operands (<code> 3 4 +</code>).
        </p><p>RPN notation is one of the most <strong>visually obvious</strong>
        aspects of the Forth programming language.  But it turns out, RPN is
        not what Forth is <em>about</em> or the <em>reason</em> Forth exists.
        As we&#39;ll see, the situation is reversed.
        </p><p>In fact, as you&#39;ll see, my quest is mostly a series of incorrect
        assumptions I made by looking at the language <em>without the context
            of history</em>.
        </p><p>By the way, the <a href="https://en.wikipedia.org/wiki/HP-35">HP-35 calculator</a> (wikipedia.org) pictured here is really interesting.
        In the early 1970s, HP had powerful desktop calculators.
        Actually,
        what they had were really programmable computers, but they still
        <a href="https://en.wikipedia.org/wiki/Hewlett-Packard_9100A">called them calculators</a> (wikipedia.org) for sales reasons.
        But these were big desktop machines that ran off of wall current.
        </p><p>Putting all of that power into a &#34;shirt pocket&#34; calculator was
        an astounding accomplishment at the time.
        Legend has it that the
        size of the HP-35 was based on the dimensions of Bill Hewlett&#39;s
        actual shirt pocket.
        HP-35 calculators have been in space. They killed off the slide rule.
        </p><p>HP calculators are famous for using RPN syntax. If it weren&#39;t for
        these calculators, I suspect it&#39;s likely that RPN syntax would be
        virtually unknown outside of computer science.
        </p><p>RPN is considered to be highly efficient and,
        being somewhat inscrutable to outsiders, highly geeky.
        </p><p>Let&#39;s see a better example...
    </p></div>
</div>

<div>
    <p>Noob:
    </p><pre><i>$ bc
bc 1.07.1
Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006,
2008, 2012-2017 Free Software Foundation, Inc.
This is free software with ABSOLUTELY NO WARRANTY.
For details type `warranty&#39;.</i>
(3 * 4) + (5 * 6)
42
    </pre>
</div>

<div>
    <p>Pro:
    </p><pre><i>$ dc</i>
3 4 * 5 6 * + <i>p</i>
42
    </pre>

    <div>
        <p><i>I&#39;m being cheeky here. Users of <code>bc</code>, are hardly
            noobs.  But it is arguably even geekier to use the much
            older <code>dc</code> program.  <code>bc</code> was once just an
            infix expression translator for <code>dc</code> to make it more
            palatable for people who didn&#39;t want to use RPN. Thus the gentle
            teasing.</i>
        </p><p>Besides using RPN syntax,
        <a href="https://en.wikipedia.org/wiki/Dc_%28computer_program%29">the dc calculator</a>
        (wikipedia.org) is completely programmable. Oh and it also happens to
        be one of the very first Unix programs and pre-dates the C programming
        language!
        </p><p>Anyway, the <em>point</em> here is that RPN syntax lets you express
        nested expressions without requiring parenthesis to get the order of
        operations the way you want them. This is one of the reasons RPN fans
        (including those HP calculator fans I alluded to) are so enamoured with it.
        </p><p>In this example, we input 3, then 4. <code>*</code> multiplies them.
        Now we have the result (12) available. But first, we input 5 and 6 and
        multiply them with another <code>*</code> to also store that result (30).
        The final <code>+</code> adds both stored results (12 + 30) and
        stores <em>that</em> result (42).
        Unlike an HP calculator, <code>dc</code> doesn&#39;t show us any of the
        stored results, including the last one until we &#34;print&#34; it with the
        <code>p</code> command.
        </p><p>As <a href="https://www.gnu.org/fun/jokes/ed-msg.html">it is known about
            &#34;ed, the standard text editor&#34;</a> (gnu.org), <code>dc</code> doesn&#39;t
        waste your VALUABLE time (or teletype paper) with output you don&#39;t need!
        </p><p>So this relates to Forth how?
    </p></div>
</div>

<div>
    <p>Forth pro:
    </p><pre>3 4 * 5 6 * + .
42
    </pre>

    <div>
        <p>As you can see, someone sitting at a Forth interpreter
        can perform this calculation exactly the same as with the <code>dc</code>
        calculator (or an HP calculator).
        </p><p>Sharp-eyed readers will note that we print the result with a &#34;.&#34;
        command rather than &#34;p&#34;. But that&#39;s the only difference.
        </p><p>So Forth is like an RPN calculator? We input values and then
        operate on them?
        Well, that statement is not <em>wrong</em>
        </p><p>But does that mean we know what Forth is all about now?
        If we know how to enter things in postfix notation, we &#34;get&#34; Forth?
        No! Not even close...
    </p></div>
</div>

<div>
    <p>Forth absolutely uses postfix notation.
    </p><p>But then I learned some more:
</p></div>

<div>
    
    <p><img src="https://ratfactor.com/forth/talkimg/pushswapdup.png" alt="drawing of three stacks illustrating push swap and dup operations"/></p><div>
        <p>The use of a data stack is probably the second most visible thing
        about the Forth programming language.
        </p><p>A stack is a data structure often explained with a &#34;stack of
        plates&#34; analogy. You <b>PUSH</b> a plate on the stack and you <b>POP</b>
        a plate off the stack. The first item you put on the stack is
        the last item out of the stack.
        </p><p>Above, we have an illustration of <b>PUSH</b> and two other common
        stack operations:
        </p><ul>
            <li><b>SWAP</b> slides a plate out (very carefully) from the second
                position and puts it on top.
            </li><li><b>DUP</b> takes the top plate and <b>dup</b>licates it using
                kitchen magic and puts the replica on the top of the stack (in
                this metaphor, I guess an equal amount of matter is removed
                somewhere else in the Universe, but we try not to worry too
                much about that).
        </li></ul>
        <p>As you may have guessed, these four stack words (PUSH, POP,
        SWAP, DUP) also happen to be Forth words.
        </p><p><b>Historical note 1:</b> In the old days, people and computers just
        WENT ABOUT SHOUTING AT EACH OTHER ALL THE TIME IN ALL CAPS BECAUSE
        LOWERCASE LETTERS WERE TOO EXPENSIVE.
        </p><p><b>Historical note 2:</b> When a computer asks, &#34;SHALL WE PLAY A
        GAME?&#34; in all caps, you must answer NO, as we learned in 1983&#39;s
        <a href="https://en.wikipedia.org/wiki/WarGames">WarGames</a> (wikipedia.org)
        </p><p>Let&#39;s see a stack in action:
    </p></div>

</div>

<div>
    <pre>Op   The Stack
--   ---------
3     3
4     3  4
*     12
5     12 5
6     12 5  6
*     12 30
+     42
.
    </pre>

    <div>
        <p>Let&#39;s revisit our math problem from earlier. This is the
        Forth code on the left and the results on &#34;the stack&#34; on the right.
        </p><p>Rather than being concerned with the syntax or notation, we&#39;re
        now interested in what these operations are doing with our data
        stack.
        </p><p>As you can see, entering a number puts it on the stack.
        The math operators take two values from the stack, do something
        with them, and put a new value back on the stack.
        </p><p>The &#39;.&#39; (DOT) operator is different since it only takes one
        value (to print it) and does not put anything back on the stack.
        As far as the stack is concerned, it is equivalent to DROP.
        As far as humans are concerned, it has the useful side-effect
        of letting us see the number.
        </p><p>Now let&#39;s see something you probably <em>wouldn&#39;t</em> find
        on an HP calculator. Something non-numerical...
    </p></div>

</div>

<div>
    <p>This is valid Forth, assuming CAKE, HAVE, and EAT have been defined:
    </p><pre>CAKE DUP HAVE EAT 
    </pre>

    <div>
        <p>Getting the joke here will require knowing
        <a href="https://en.wikipedia.org/wiki/You_can%27t_have_your_cake_and_eat_it">this English idiom</a> (wikipedia.org).
        </p><p>Actually, this isn&#39;t <em>just</em> a silly example.
        Forth&#39;s use of the stack can lead to a natural, if somewhat
        backward use of nouns and verbs. (Kind of like Yoda&#39;s speech habits.
        &#34;Cake you will dup, yes? Have it and eat it you will, hmmm?&#34;)
        </p><p>There can, indeed, be some object named CAKE that we have
        placed on the stack (probably a memory reference) which
        can be DUPed, and then HAVEd and EATen.
        </p><p>It&#39;s up to the Forth developer to make harmonious
        word choices. It can get far more clever or poetic than my example.
        </p><p>Naming things is great.
        </p><p>But sometimes <em>not</em> naming things is even better.
    </p></div>
</div>

<div>
    <p>The stack frees us from being forced to create explicit names for
    intermediate values.
    </p><p>If I ask you to add these numbers:
    </p><pre>2 6 1 3 7
    </pre>
    <p>Do you feel a need to give a <i>name</i> to each sum pair...or even the running total?

    </p><div>
        <p>(Hopefully your answer is &#34;no&#34; or the rhetorical question doesn&#39;t work.)
        </p><p>But it&#39;s funny how our <em>programming languages</em> often require us
        to explicitly name intermediate results so that we can refer to them.
        On paper, we would never give these values names - we would just happily
        start working on the list.
        </p><p>Imagine, if you will, a factory assembly line in which
        each person working the line is a hateful fussbudget who refuses to
        work on the part in front of them until you name it. And each time the
        part has been worked on it must be given a new name. Furthermore, they
        refuse to let you re-use a name you&#39;ve already used.
        </p><p>A lot of imperative languages are like that factory. As your
        values go down the line, you&#39;ve got to come up with nonsense names
        like <code>result2</code>, or <code>matched_part3</code>.
        </p><p>Does <em>your</em> programming language make you do this?
        </p><p><i>(It&#39;s almost as bad as file names used as a versioning
            system: <code>my_doc_new_v5.4(copy)-final2</code>...)</i>
        </p><p>Working without names (also known as <em>implicit</em> or
        <em>tacit</em> or <em>point-free</em> programming) is sometimes a more
        natural and less irritating way to compute.  Getting rid of names can
        also lead to much more concise code. And less code is good code.
        </p><p>Great, so stacks can be a very elegant way to handle expressions.
        </p><p>Have we &#34;cracked&#34; Forth yet? Now we know two things:
        it uses RPN syntax and it is stack-based.
    </p></div>
</div>

<div>
    <p>Well, Forth certainly does use a stack. It is definitely a stack-based
    language.
    </p><p>But then I learned some more...
</p></div>

<div>
    
    <p><img src="https://ratfactor.com/forth/talkimg/computer_cat.png" alt="a confused cat working on an old pc"/></p><p>Ah, <i>this</i> must be it because it sounds fancy.

    </p><div>
        <p>On this journey of Forth discovery, you&#39;ll inevitably run into
        the term &#34;concatenative programming&#34;.
        </p><p>What&#39;s that?
        </p><p>An awesome resource for all things concatenative is
        <a href="https://concatenative.org/">The Concatenative Language Wiki</a>
        (concatenative.org).
            It lists many concatenative languages and has a page about Forth,
            of course.
        </p><p>For the term &#34;concatenative programming&#34; itself, the Factor
        programming language website has an excellent page defining the
        term:
        <a href="https://docs.factorcode.org/content/article-tour-concatenative.html">Factor documentation: Concatenative Languages</a>
        (factorcode.org).
        And, of course, there&#39;s the Wikipedia entry,
        <a href="https://en.wikipedia.org/wiki/Concatenative_programming_language">Concatenative programming language</a>
        (wikipedia.org).
        </p><p>I understand the explanations on these websites <em>now</em>, but
        it took me a while to get there. Your journey may be shorter or longer.
        Probably shorter.
        </p><p>Let&#39;s see if I can stumble through it...
    </p></div>
</div>

<div>
    <p>Contrast with <b>applicative</b> language:
    </p><pre>eat(bake(prove(mix(<b>ingredients</b>))))
    </pre>
    <p><b>Concatenative</b> language:
    </p><pre><b>ingredients</b> mix prove bake eat
    </pre>

    <div>
        <p>An applicative language has you apply a function to a value, which
        returns another value. Using familiar Algol-like (or &#34;C-like&#34;, or
        &#34;Java-like&#34;, or &#34;JavaScript-like&#34;) syntax, arguments are passed to
        functions within a pair of parenthesis. In the above example, the
        parenthesis end up deeply nested as we pass the output of one function
        to another.
        </p><p>Unlike the math examples, where the infix notation looks more
        natural to most of us than the postfix notation, the concatenative
        example of this baking program looks more natural (at least in a
        <i>human language</i> sense) than the <b>inside-out</b> function application
        example, right?
        </p><p><i>(Of course, if you&#39;re a programmer used to years of something like C
        or Java or JavaScript, the inside-out parenthetical form will probably
        seem pretty natural too. Well, guess what? Your mind has been
        warped. It&#39;s okay, mine has too.)</i>
        </p><p>The point here is that concatenative style has us &#34;composing&#34;
        functions (which you can think of as verbs) simply by putting them
        in sequence. Each function will be called in that sequence.
        The values that are produced at each step are passed along
        to be consumed as needed.
        </p><p>No names (unless we want them), just nouns and verbs.
        </p><p>But that&#39;s just the surface. It turns out this &#34;concatenative language&#34;
        concept goes way past that...
    </p></div>
</div>

<p>The canonical example of a concatenative language is Joy.
</p>

<div>
    
    <p><b>Manfred von Thun</b> inspired by Backus&#39;s 1977 ACM Turing Award lecture:
    <img src="https://ratfactor.com/forth/talkimg/backus.jpg" alt="top of the john backus paper Can Programming Be Liberated from the von Neumann Style? A Functional Style and Its Algebra of Programs"/>


    </p><div>
        <p><a href="http://worrydream.com/refs/Backus-CanProgrammingBeLiberated.pdf">Can Programming Be Liberated from the von Neumann Style? (PDF)</a> (worrydream.com)
            This paper is dense with notation and I haven&#39;t personally
            attempted to wade through it, <em>yet</em>. I&#39;m sure it contains
            <em>many</em> profound ideas.
        </p><p>I know just enough to believe I understand this paragraph from
        the paper&#39;s abstract:
            </p><blockquote>
                &#34;An alternative functional style of programming is
                founded on the use of combining forms for creating
                programs. Functional programs deal with structured
                data, are often nonrepetitive and nonrecursive, are
                hierarchically constructed, do not name their
                arguments, and do not require the complex machinery of
                procedure declarations to become generally applicable.
                Combining forms can use high level programs to build
                still higher level ones in a style not possible in
                conventional languages.&#34;
            </blockquote>
        <p>Perhaps you&#39;ve heard of &#34;functional programming?&#34; As you can
        see, that term was being used in 1977.
        </p><p>&#34;Concatenative programming&#34; came after. In fact,
        <b>Joy</b> is where the &#34;concatenative&#34; description comes from!
        (von Thun specifically credits Billy Tanksley for creating the term
        &#34;concatenative notation&#34;.)
    </p></div>
</div>

<div>
    <p><b>Joy</b> is kind of like starting with a Lisp
    </p><p>...without variables
    </p><p>...and without traditional control structures
    </p><p>...and all functions are unary (or an &#34;arity of 1&#34;).
    </p><p>Specifically, all functions take one stack as input and return
       one stack as output. The stack is not named, it is implied.
    </p><p>A program is simply a list of functions that is read
       from left to right.

    </p><div>
        <p>I can&#39;t describe Joy&#39;s genesis better than the man himself.
        Here is von Thun in an interview about Joy:
        </p><blockquote>&#34;Joy then evolved from this in an entirely haphazard way:
            First I restricted the binary relations to unary functions, and
            this of course was a dramatic change. Second, to allow the usual
            arithmetic operations with their two arguments, I needed a place
            from which the arguments were to come and where the result was to
            be put - and the obvious place was a stack with a few shuffling
            combinators, originally the four inspired by Quine. Third, it
            became obvious that all these combinators could be replaced by
            unary functions, with only function composition remaining. Finally
            the very different distinctively Joy combinators emerged, which
            take one or more quoted programs from the stack and execute them in
            a specific way. Along the way of course, lists had already been
            seen as just special cases of quoted programs. This meant that
            programs could be constructed using list operations and then passed
            on to a Joy combinator.&#34;</blockquote>
        <p>From <a href="http://www.nsl.com/papers/interview.htm">A Conversation with Manfred von Thun</a> (nsl.com), which is a really great read in its entirety.
        </p><p>As you can see, <b>combinators</b> are crucial in Joy.
        Let&#39;s take a moment to dive into those, because this is a pretty
        fascinating avenue of computer science...
    </p></div>
</div>

<div>
    
    <p>Combinators are any &#34;higher-order&#34; functions like <b>map</b>.

    </p><div>
        <p>&#34;Higher-order&#34; just means functions that take <em>other</em>
        functions as input and do things with them.
        </p><p>You can even have functions that take functions that take functions
        and so on to do powerful things. But you&#39;ll need to meditate on
        them every time you have to re-read that part of your code.
        </p><p><b>map</b> is one of the more common examples, so I&#39;ll use it
        as an example.
    </p></div>

    <p>JavaScript:</p>
    <pre>inc = function(n){ return n + 1; };

bigger = [1, 2, 3, 4].<b>map</b>(inc);

<i>Result: [2,3,4,5]</i>
    </pre>

    <p>JavaScript using an &#34;arrow function&#34;:</p>
    <pre>bigger = [1, 2, 3, 4].<b>map</b>(n =&gt; n + 1);

<i>Result: [2,3,4,5]</i>
    </pre>

    <div>
        <p><i>(The second example with the arrow function syntax works exactly
        the same way, but more compactly. I included it to make the comparison
        with Joy a little more even-handed. Feel free to pick a favorite
        and ignore the other one.)</i>
        </p><p>In the first example, we have familiar Algol-like
        syntax with functions that take arguments in parenthesis.
        </p><p>Perhaps
        <code>map()</code> is familiar to you. But if not, just know that 
        it takes two parameters like so: <code>map(array, function)</code>.
        The first parameter is implicit in these JavaScript examples, but it&#39;s
        there. The array object, <code>[1, 2, 3, 4]</code> calls its own
        <code>map()</code> method. The second parameter is a function
        (named <code>inc</code> in the first example and left anonymous in
        the second), which will be applied to every member of the list.
        </p><p>
        The output of <code>map()</code> is a <em>new</em> list containing the
        result of each application.
        </p><p>Notice how both JavaScript examples
        have variables such as the parameter <code>n</code> and the result
        <code>bigger</code>. This is an example of what I mentioned a moment
        ago when discussing the advantages of stacks: &#34;Traditional&#34;
        programming languages often make us name values before we can work with
        them.
    </p></div>

    <p>The same thing, but concatenatively in Joy:</p>
    <pre>[1 2 3 4] [1 +] <b>map</b>

<i>Result: [2 3 4 5]</i>
    </pre>

    <div>
       <p>
       The syntax here may require a little explanation.
       The square brackets (<code>[]</code>) are Joy&#39;s
       quote mechanism. Quotations are a lot like lists, but they can contain
       <em>programs</em> as well as data.
       </p><p>In this case, the first quotation is the number list,
           <code>[1 2 3 4]</code>.
       </p><p>The second quotation is a program, <code>[1 +]</code>.
       </p><p>As in the JavaScript examples, <code>map</code> takes two parameters.
       The first is the function (or &#34;program&#34; in Joy) to apply, and the second
       is the list to apply it to.
       </p><p>(It&#39;s kind of confusing to talk about &#34;first&#34; and &#34;second,&#34; though
       because that&#39;s the opposite order in which we <em>supply</em> those
       arguments on the stack...)
       </p><p>Note the lack of variables <code>bigger</code> or <code>n</code>.
       Intermediate values just exist.
       </p><p>It looks pretty nice and neat, right?
       </p><p>This &#34;point-free&#34; style can be a blessing...
       or curse. Unlike computers, human brains have a hard time juggling too
       many things on the stack.
       </p><p>There seems to be a happy medium between named and unnamed. Also,
       the point-free style seems to benefit greatly from short (even
       <i>very short</i>) definitions to avoid mental juggling and greater
       composibility.
       </p><p>If you have the slightest interest in <b>Joy</b>, I highly recommend
       reading or skimming this delightful tutorial by Manfred von Thun
       himself:
        <a href="https://hypercubed.github.io/joy/html/j01tut.html">An informal tutorial on Joy</a>
        (hypercubed.github.io).
       </p><p>Note: I had a bit of a time actually running Joy to test out these
       examples. Thankfully, I eventually ran into
       <a href="https://github.com/calroc/joypy">Joypy</a> (github.com),
       a Joy written in Python. My Linux distro comes with Python installed,
       so the whole process for me was:
       </p><pre>git clone https://github.com/calroc/joypy.git
cd joypy
python -m joy
...
joy? [1 2 3] [1 +] map
        </pre>
        <p>Okay, that&#39;s a glimpse.
        </p><p>But we&#39;ve barely touched the conceptual power of combinators with our
        <code>map</code> examples. Let&#39;s go a <em>little</em> deeper on
        this fascinating subject:
    </p></div>
</div>

<div>
    <p><img src="https://ratfactor.com/forth/talkimg/mock_a_mockingbird.jpg" alt="cover of the book"/></p><div>
        <p>Here&#39;s something from my bookshelf. It&#39;s <i>To Mock a Mockingbird</i>
        by mathematician and
        puzzle-maker Raymond Smullyan. It uses puzzles involving birds to solve
        logic problems and classify some well-known combinators.
        </p><p>It would be impossible to write a complete catalog of
        combinators just as it would be impossible to write a complete
        catalog of integers. They&#39;re both infinite lists.
        Nevertheless, some well-known combinators have been identified as
        having special properties. In the book above, many of these have
        been given the names of birds.
        </p><p>Remember, combinators are just &#34;higher-order&#34;
        functions that take functions as input.
        Well, it turns out these are
        all you need to perform <em>any</em> computation. They can replace logical
        operators and even variables.
        </p><p>What?!
        </p><p>Yeah, you can re-work any expression into a combinatorial expression
        and completely replace everything, including the variables, with
        combinators.
        </p><p>It&#39;s kind of hard to imagine at first. But you can see it happen
        right before your very eyes.
        The mind-blowing tool on this page by Ben Lynn:
        <a href="https://theory.stanford.edu/~blynn/lambda/cl.html">Combinatory Logic</a>
        (stanford.edu)
        takes a term expressed in lambda calculus and replaces <b>everything</b>
        with just two combinators, K and S.
        (We&#39;ll talk more about those two in just a moment because they
        are super special.)
        <img src="https://ratfactor.com/forth/talkimg/look_ma_no_variables.png" alt="screenshot from the aforementioned calculator with buttons &#39;Look ma, no names, no variables, and no variables K-optimized!"/>
        </p><p><em>(Ben Lynn&#39;s whole website is full of neat stuff like this.
            If you&#39;re looking to entertain yourself for any amount of time from
            an afternoon to the rest your life, Lynn has you covered.)</em>
        </p><p>So combinators share something in common with lambda calculus and
        Turing machines. These systems provide all of the building blocks
        you need to perform any
        possible computation in the sense of the
        <a href="https://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis">Church-Turing thesis</a> (wikipedia.org)
        or &#34;computability thesis&#34;. (We&#39;ve also discovered some problems
        that are <em>not</em> computable and <em>no</em> system can compute
        them like &#34;the halting problem,&#34; but these are pretty rare.)
        </p><p>It turns out that <strong>computation is a fundamental feature of
            the Universe</strong>.
        As far as we can tell, any universal system of computation is equally
        capable of solving any computational problem.  And once you realize how
        little is required, you can invent a universal computer yourself!
        </p><p>Electronically speaking, this is the same principle
        that allows a NAND gate to simulate all other gates. NAND gates are
        a fundamental computational building block. You can make an
        entire computer with nothing but NAND gates and that computer can
        (slowly) solve any computable problem you can imagine.
        </p><p>Anyway, when we use combinators, this particular flavor of universal
        computation is called 
        <a href="https://en.wikipedia.org/wiki/Combinatory_logic">combinatory logic</a> (wikipedia.org).
        </p><p>What do the building blocks of combinatory logic look like?
        </p><p>Let&#39;s start small:
    </p></div>
</div>

<div>
    <p>Identity
    </p><pre>(I x) = x
    </pre>

    <div>
        <p>The simplest of all combinators is I, the &#34;identity combinator&#34;.
        There are a ton of different ways to write this. In lambda calculus,
        it looks like this: <code>I = λx</code>.
        </p><p>The way to read <code>&#34;(I x) = x&#34;</code> is: &#34;<code>I</code> applied
        to some object <code>x</code> results in...<code>x</code>.&#34;
        </p><p>We say &#34;object x&#34; rather than &#34;value x&#34; because, being a
        combinator, <code>I</code> could take a function as input as well as a
        value. In fact, &#34;object&#34; is intentionally very abstract, so
        <code>x</code> could contain a scalar value, or
        list, or function, or another combinator, or <em>anything</em>.
        Whatever that object is, <code>I</code> returns it.
    </p></div>
</div>

<div>
    <p><b>K</b> and <b>S</b>
    </p><pre>(K x y) = x

(S x y z) = (x z (y z))
    </pre>

    <div>
        <p>Both of these take more than one parameter of input.
        But if you&#39;re used to Algol-like function syntax, the way this
        works may be surprising.
        </p><p>Since it&#39;s the simpler of the two, let&#39;s use the <code>K</code>
        combinator as an example:
        </p><p>The way to read &#34;<code>(K x y) = x</code>&#34; is:
        &#34;<code>K</code> applied to <code>x</code> <strong>yields
        a combinator</strong>, which, when applied to <code>y</code> always
        evaluates to <code>x</code>.&#34;
        </p><p>(Programmers familiar with the concept of <em>currying</em> will see
        that this is like the <em>partial application</em> of a function, where
        a new function is &#34;pre-baked&#34; with the argument <code>x</code>.  The
        term &#34;currying&#34; is named in honor of mathematician
        <a href="https://en.wikipedia.org/wiki/Haskell_Curry">Haskell Curry</a>
        (wikipedia.org),
        after whom the Haskell programming language is also named.)
        </p><p>The result is that <code>K</code> makes a combinator that
        <strong>throws away</strong> any input and just returns
        <code>x</code>. Weird, right? But it turns out to be useful.
        </p><p><code>K</code> is super easy to write in a language like
        JavaScript, which is also a nice choice because you can play with
        it right in the browser console like I just did:
        </p><pre>K = function(x){
  return function(y){
    return x;
  }
}

K(&#34;hello&#34;)(&#34;bye&#34;)

<i>&gt; &#34;hello&#34; </i>
        </pre>
        <p>See how the result of <code>K(&#34;hello&#34;)</code> is a function that
        returns &#34;hello&#34; no matter what you give it as input?
        </p><p>How about <code>S</code>? I&#39;ll leave implementing <em>that</em>
        in JavaScript as an exercise for the reader.
        It&#39;s clearly much more complicated since it has three levels of
        &#34;function that yields a combinator&#34; on the left and the <em>result</em>
        is an equally complicated combinator that <em>first</em> applies
        parameter <code>z</code> to combinator <code>y</code>.
        </p><p>(By the way, the <code>y</code> combinator above should not be
        confused with <strong>the</strong> <code>Y</code> combinator.
        Do you remember that arcane lambda calculus artifact projected
        over that head with the third eye way up near the beginning of this
        page?  That thing was the <code>Y</code> combinator! It turns out, it&#39;s
        all, like, <em>connected</em>, you know?)
        </p><p>But the real point is this: <code>S</code> and <code>K</code> are
        special for one very interesting reason.
        Together with <code>I</code>, they form the &#34;SKI calculus&#34; and just
        these three combinators are <strong>all you need</strong> to perform
        any computation in the known universe.
        </p><p>Actually, it&#39;s even crazier than that. You don&#39;t even need
        <code>I</code> because that, too, can be created with <code>S</code>
        and <code>K</code>.
        </p><p>That&#39;s right, the <code>S</code> and <code>K</code> definitions
        above are a complete system for universal computation.
    </p></div>
</div>

<div>
    <p><img src="https://ratfactor.com/forth/talkimg/wolfram_combinators.jpg" alt="cover of the book"/></p><div>
        <p>The book shown here is another from my bookshelf. It&#39;s
        <i>Combinators: A Centennial View</i> by Stephen Wolfram.
        </p><p>It starts with a (much too) terse introduction to the SKI combinator
        calculus and then launches into page after page of visualizations of S
        and K combinators being fed into each other. Like fractals or automata,
        simple inputs can produce patterns of surprising sophistication.
        </p><p>Wolfram demonstrates combinators that keep producing different
        output for a gazillion iterations and then get stuck in a loop. Some of
        them produce regular patterns for a while and then start producing
        different patterns.  Some just loop forever at the outset.
        As in other universal systems, there is no end to the complexity
        produced by these two simple constructs.  It is infinite.  And all of
        this is just S and K combinators taking combinators as input and
        returning combinators as output.
        </p><p>I think it is wild and fun to see someone play
        with a subject like Wolfram does in this book. Each page is saying,
        &#34;Look at what is possible!&#34;
        </p><p><i>Combinators</i> is also Wolfram&#39;s ode to the discoverer of
        combinatory logic,
        <a href="https://en.wikipedia.org/wiki/Moses_Sch%C3%B6nfinkel">Moses Schönfinkel</a> (wikipedia.org)
        who, like so many of the giants in the field of computer science,
        did his work on paper decades before the first digital electronic
        computers beeped their first boops.
        </p><p>Figuring out the output of the <code>S</code> combinator once
        was enough to keep me occupied for a while.  It boggles my mind to
        imagine feeding it another <code>S</code> as input on paper,
        let alone discovering these particular combinators in the first place.
        </p><p>Okay, we get it, combinators are a crazy way to compute.
        </p><p>But are they worth using in <em>&#34;real&#34;</em> programs? In limited
        doses, absolutely!
    </p></div>
</div>

<div>
    <p>Combinators let us factor out explicit loops. This:
    </p><pre>foo<b>.map</b>(bar)
    </pre><p>
    is the same as this much longer statement:
    </p><pre><b>temp = [];</b>
<b>for(i=0; i&lt;</b>foo<b>.length; i++){
    temp[i] = </b>bar(<b>foo[i]</b>)<b>;
}</b>
    </pre>

    <div>
        <p>Both of those pieces of JavaScript give us the result of applying
        the function <code>bar()</code> to an array <code>foo</code>.
        </p><p>I think <code>map()</code> is a great example of the power of
        combinators to clean up a program with abstraction.  Once you start
        using simple combinators like this to abstract away the boilerplate
        logic of <em>yet another</em> loop over a list of items, it&#39;s hard
        to go back.
        </p><p>My personal history with exploring higher order functions in
        a production setting is through the
        <a href="https://ramdajs.com/">Ramda</a> (ramdajs.com) JavaScript
        library, which I discovered from the talk
        <a href="https://www.youtube.com/watch?v=m3svKOdZijA">Hey Underscore, You&#39;re Doing It Wrong!</a>
        (youtube.com)
        by Brian Lonsdorf, which is fantastic.
        </p><p>Once I started discovering how combinators and curried functions
        could eliminate big old chunks of code, I was hooked!
        The old, dreary procedural code became a new fun puzzle!
        </p><p>Mind you, it&#39;s very easy to go overboard with this stuff and
        write something far <em>less</em> readable 
        than some simple procedural code. (Gee, ask me how I know this.)
        </p><p>But in limited doses, it&#39;s super powerful and compact.
    </p></div>
</div>

<div>
    <p><b>Joy</b> uses combinators to &#34;factor out&#34; all sorts of logic.
    </p><p>Even different forms of recursion can be completely handled
    for you by combinators in Joy thanks to the uniformly unary functions.
    </p><p>Here&#39;s a factorial definition:
    </p><pre>factorial == [null] [succ] [dup pred] [*] <b>linrec</b>
    </pre>
    <p>Let&#39;s try it:
    </p><pre>5 factorial
<i>120</i>
    </pre>

    <div>
        <p>Computing the factorial of a number is often used as an example of
        recursion. The final answer is the input number multiplied by the
        previous number multiplied by the previous number multiplied by...
        <em>the rest of the numbers</em> all the way down to 1.
        </p><p>Computing a factorial requires a cumulative result. Without
        recursion, you need an explicit variable to hold the intermediate
        result as you loop through the numbers.
        </p><p>As shown in the Joy <code>factorial</code> definition above,
        <code>linrec</code> is a &#34;linear recursion&#34; combinator. It takes takes
        4 parameters, each of which is a quoted program. <code>null</code> is a
        predicate which tests for zero. <code>dup</code> is the same as in
        Forth. <code>pred</code> is an operator which yields a number&#39;s
        predecessor (given 4, yields 3).  &#34;<code>*</code>&#34; multiplies two
        numbers, just like you&#39;d expect. Given these pieces, perhaps you can
        take a guess at how <code>linrec</code> works?
        </p><p>For comparison, here is a recursive JavaScript solution:
        </p><pre>function factorial(n) {
    if (n &lt;= 1) {
        return 1;
    }

    return n * factorial(n - 1);
 }
        </pre>
        <p>Note that the Joy example is not just shorter and has no
        variable names but it has <em>abstracted away the mechanics
           of recursion</em>. All we&#39;re left with is the
        logic specific to the factorial problem itself.
        </p><p>It&#39;s debatable which of these two are more <em>readable</em>
        because the measure of readability is in the eye of the beholder.
        But I think you can <em>imagine</em> getting good at reading the Joy
        example.
        </p><p>Okay, so we&#39;ve gone pretty deep into this concatenative
        programming and combinator thing. How does this actually
        relate to Forth?
        </p><p>First of all, Forth <em>does</em> have facilities for
        dealing with combinators:
    </p></div>
</div>

<div>
    <p>Forth supports higher order functions with &#34;execution tokens&#34;
    (function pointers) and the <code>EXECUTE</code> word.
    </p><p>This will run the word <em>returned by</em> the word <code>FOO</code>:
    </p><pre>FOO EXECUTE
    </pre>
    <p>With this, you can very compactly define combinatorial words such as
        <b>MAP</b>, <b>FOLD</b>, and
        <b>REDUCE</b>.

    </p><div>
        <p>First, let&#39;s see how <code>EXECUTE</code> works. The syntax will be
        alien to non-Forth programmers, but the concept will be no problem for
        anyone used to using first class functions.
        </p><p>First, let&#39;s make a new word:
        </p><pre>: hello .&#34; Hello&#34; ;
        </pre>
        <p>This is Forth for, &#34;Compile a word called <code>hello</code>
        that prints the string <em>Hello</em>.&#34;
        </p><p>(We&#39;ll learn how compiling words actually works later.
        For now, please just gracefully accept what you&#39;re seeing.)
        </p><p>Next:
        </p><pre> 
VARIABLE hello-token
        </pre>
        <p>This creates a new variable called <code>hello-token</code> which
        will store the &#34;execution token&#34; for the hello word.
        </p><p>This part will look super cryptic if you&#39;re new to Forth:
        </p><pre> 
&#39; hello hello-token !
        </pre>
        <p>Let&#39;s examine this one piece at a time:
        </p><ul>
            <li>&#34;<code>&#39;</code>&#34; gets the address of the word
                &#34;<code>hello</code>&#34; and puts it on the stack.
            </li><li>&#34;<code>hello-token</code>&#34; is a variable, which
                just leaves its address on the stack when called.
            </li><li>&#34;<code>!</code>&#34; stores a value from the stack
                (the address of <code>hello</code>) <em>at</em>
                an address from the stack (the address of
                variable <code>hello-token</code>).
        </li></ul>
        <p>So the code above simply reads, &#34;Store the address of
        <code>hello</code> in the variable <code>hello-token</code>.&#34;
        </p><p>Now let&#39;s use EXECUTE to call this &#34;execution token&#34;:
        </p><pre> 
hello-token @ EXECUTE
<i>Hello</i>
        </pre>
        <p>Behold, it printed the &#34;Hello&#34; string!
        </p><p>Remember, the variable <code>hello-token</code> leaves its
        address on the stack when it is called.
        </p><p>&#34;<code>@</code>&#34; is a standard Forth word that loads the value
        from the given address and puts that value on the stack.
        </p><p><code>EXECUTE</code> gets an address from the stack and runs
        whatever word is found at that address.
        </p><p>Perhaps it would be helpful to see that this silly statement:
        </p><pre>&#39; hello EXECUTE
        </pre><p>
        is equivalent to just calling <code>hello</code> directly:
        </p><pre>hello
        </pre>
        <p>Anyway, now we&#39;re armed with Forth&#39;s combinatorial ability:
        Treating functions (&#34;words&#34;) as values so other functions can
        take them as input. This allows us to define combinators in Forth.
        </p><p>For some compact higher-order function definitions
        in Forth, check out <a href="https://gist.github.com/adolfopa/64a1a59c28cbd77b71449d68f4c36dc0">this Gist by Adolfo Perez Alvarez</a> (github.com).
    </p></div>
</div>

<div>
    <p>So yes, Forth <strong>is</strong> concatenative. It implicitly passes values
    from one function invocation to the next. And it supports higher-order
    functions.
    </p><p>Nevertheless, I do <strong>not</strong> believe studying &#34;concatenative
    programming&#34; in general or Joy specifically is a good way to understand
    the history and genesis of Forth!
    </p><p>For example, this simple statement:
    </p><pre>2 3 +
    </pre>
    <p>can be read two different ways:
    </p><p><b>Forth:</b> &#34;Push 2 and then 3 on the stack; add them; push <b>result
        5</b> on the stack.&#34;
    </p><p><b>Joy:</b> &#34;The <i>composition</i> of the functions 2, 3, and +
    is identical to the <b>function 5</b>.&#34;
    </p><div>
        <p>While both languages share a cosmetically similar syntax, 
         and both produce the same result for <em>this</em>
         expression, there is a fundamental difference between how the two
         languages &#34;think&#34; about the expression because they arrived at
         this place in completely different ways.
        </p><p>Forth&#39;s only concern (as a language) is to process these three
        tokens and act upon them according to some simple rules.
        (If the token is in the dictionary, execute it. If it&#39;s a number, put
        it on the stack.)
        </p><p>To Joy, it may be the same mechanical process under the hood, but
        the language itself sees these tokens more like a mathematical
        expression. It&#39;s a much more abstract outlook.
        </p><p>The point I&#39;m making is that Forth may <em>accomodate</em> the
        abstract point of view, if the developer chooses to take it. But
        Forth is not <em>based</em> on abstract concatenative computing
        principles or combinatory logic.
        </p><p>Let&#39;s look at this from a historical perspective.
        First, the notions of postfix syntax (RPN) and a data stack for
        the basis of the language:
    </p></div>
</div>

<div>
    <p><img src="https://ratfactor.com/forth/talkimg/zuse_z3_computer.png" alt="drawing of konrad zuse&#39;s z3 computer"/></p><p><b>Postfix notation</b> was definitely in the air when Chuck Moore
    created Forth.
    </p><p><b>Stacks</b> were known and used in the time of Forth&#39;s origins,
    though they were generally limited to 2-4 items in registers.
    </p><p>So I think it&#39;s reasonable to assume that RPN syntax and use of
    stacks are a historically accurate way to examine Forth&#39;s &#34;origin story.&#34;

    </p><div>
        <p>Hold that thought, here&#39;s a fun aside:
        </p><p>The drawing of the computer labeled <b>&#34;Z3&#34;</b> on the right is of
        the
        <a href="https://en.wikipedia.org/wiki/Z3_(computer)">Z3 computer</a>
        (wikipedia.org)
        designed by engineer and computer scientist Konrad Zuse. This is widely
        considered to be the <strong>first programmable digital computer</strong>!
        It used electro-mechanical relays like the telegraph networks of the day.
        </p><p>(By the way, a certain amount of electro-mechanical logic is
        <em>still</em> used in modern nuclear reactor safety systems because
        the big mechanical components are not as vulnerable to nuclear
        radiation as semiconductors!)
        </p><p>The Z3 could do addition in less than a second and multiplication
        in three seconds. It had 64 words of 22 bits each and worked with
        the equivalent of modern floating-point numbers.
        </p><p>As mentioned above, it can be said to use RPN, though there are only
        two registers and nine instructions. Opcodes were encoded in eight
        bits.  The computer is programmable via punched paper tape (you can see
        the tape device to the right of the control console, though it&#39;s a bit
        of a scribble in my drawing).
        </p><p>It is <em>also</em> a stack machine. Again, this is with a mere
        two registers, which get juggled in a particular sequence as you
        load and store values.
        </p><p><b>Fun fact:</b> The control unit used special control
        <em>wheels</em> to encode microsequences. If the microsequence wasn&#39;t
        programmed correctly, it could short-circuit the machine and destroy
        the hardware!
        </p><p>I got most of this information from this excellent paper by
        Raul Rojas: 
        <a href="https://ed-thelen.org/comp-hist/Zuse_Z1_and_Z3.pdf">Konrad Zuse&#39;s Legacy: The Architecture of the Z1 and Z3 (PDF)</a> (ed-thelen.org).
        </p><p>Anyway, so the simple mechanics of RPN and stack-based
        operation are very natural for digital computing machines
        and their use goes back to the very beginning.
    </p></div>
</div>

<div>
    <p>But Joy and the term &#34;<b>concatenative programming</b>&#34; come from the
    1980s.

    </p><div>
        <p>Uh oh.
        </p><p>While the ideas of combinators and other types of
        universal computation were well known in certain mathematical
        and computational circles, I would argue they were not very amenable
        to existing computer hardware until much later when computers became
        fast enough to support &#34;functional programming&#34; styles and
        abstractions.
        </p><p>Until then, programming was &#34;close to the metal.&#34;
        Even the idea of &#34;structured programming&#34; with programming language
        concepts like <code>if/else</code> or <code>while/for</code> loops was
        once considered novel! Until then, everything was done with address
        jumps or <code>GOTO</code>.
        </p><p>It&#39;s important to remember that <em>&#34;coding&#34;</em>, the
        actual act of turning an abstract program into machine code,
        was long ago considered to be a mere secretarial skill, not far
        removed from <em>typing</em> and other forms of data entry.
        This is why some people (including myself) refer themselves as
        &#34;programmers&#34; rather than &#34;coders&#34;.
        </p><p>Concatenative programming, with its emphasis on combinators
        (and immutable data structures, which we haven&#39;t talked about),
        doesn&#39;t have the same historic grounding for Forth the way that RPN
        syntax and stack-based programming do.
        </p><p>So I must conclude that understanding concatenative programming
        is super cool, but it doesn&#39;t actually help us understand the
        true nature of Forth because it doesn&#39;t describe how Forth came to be.
        It is not part of Forth&#39;s &#34;origin story.&#34;
        </p><p>As we&#39;ll soon see, Forth <em>really is</em> about the &#34;nuts and
        bolts&#34;. You bring your own theories with you.
    </p></div>
</div>

<div>
    <p>So while all these descriptions of the Forth language are true
    (RPN, stack-based, concatenative), they all describe
    the language Forth from the vantage of <b>hindsight</b>.

    </p><div>
        <p>There&#39;s nothing wrong with thinking about Forth in these terms,
        but it doesn&#39;t answer the &#34;why&#34; questions:
        </p><p>&#34;<strong>Why</strong> does Forth have this syntax?&#34;
        </p><p>&#34;<strong>Why</strong> does Forth work this way?&#34;
        </p><p>I think the answers to the &#34;why&#34; questions are best answered by
        looking at <strong>when</strong>.
        </p><p>What is Forth&#39;s history, anyway?
    </p></div>
</div>


<div>
    
    <center>
    <img src="https://ratfactor.com/forth/talkimg/chuck_to_the_future.png" alt="chuck moore as marty in a drawing of the back to the future poster"/>
    </center>
</div>

<div>
    <p><em>If this image doesn&#39;t make any sense to you, citizen of
            the future, it&#39;s from the iconic movie poster by Drew Struzan for
            <a href="https://en.wikipedia.org/wiki/Back_to_the_Future">Back to the Future (1985)</a> (wikipedia.org).</em>
        </p>
</div>

<div>
    
    <p><img src="https://ratfactor.com/forth/talkimg/ibm_704.png" alt="chuck moore operating an IBM 704"/>
</p></div>

<div>
    <p>Chuck Moore is programming an IBM 704 with Fortran on punchards.
    </p><p>&#34;Compiling took 30 minutes...you got one shot per day&#34;
    </p><p>-- Chuck Moore, Forth, the Early years
    </p><div>
        <p>In <a href="http://worrydream.com/refs/Moore%20-%20Forth%20-%20The%20Early%20Years.pdf">Forth - The Early Years (PDF)</a> (worrydream.com), Chuck
        Moore recites a fairly terse history of Forth, from the earliest
        pre-Forths to the creation of the language standard.
        </p><p><i>(Note: Chuck mentions the Smithsonian Astrophysical Observatory
            (SAO) and the Massachusetts Institute of Technology (MIT) in
            roughly the same time period, and it&#39;s a bit difficult to be
            entirely sure which part is talking about which organization. But
            if you look at a map, SAO is at Harvard University. Harvard and MIT
            are about a mile apart in Cambridge, Massachusetts. It&#39;s basically a
            singular point if you zoom out a bit. So that helps explain the
            overlap.)</i>
        </p><p>The computer in question is the
        <a href="https://en.wikipedia.org/wiki/IBM_704">IBM 704</a>
        (wikipedia.org)
        It was one of those room-filling vacuum-tube computers with
        tape drives the size of refrigerators.
        </p><p>The 704 was a fully programmable &#34;modern&#34; computer with
        magnetic-core memory, multiple registers, a 36-bit instruction set, and
        36-bit words (&#34;word&#34; as in native memory size for the processor, not
        &#34;word&#34; as in Forth functions).
        </p><p>There were switches for each register on the control console, but
        programs could be written to and read from paper punch cards.
        </p><p>It was very modern for the time, but...
        </p><blockquote>&#34;In its day, the 704 was an exceptionally reliable machine.
        Being a vacuum-tube machine, however, the IBM 704 had very poor
        reliability by today&#39;s standards. On average, the machine failed around
        every 8 hours, which limited the program size that the first Fortran
        compilers could successfully translate because the machine would fail
        before a successful compilation of a large program.&#34;</blockquote>
        <p>It&#39;s difficult to imagine now, but changing parameters for a program,
        re-compiling it, and running it again could take a day (assuming you
        didn&#39;t make any mistakes).
        </p><p>So Chuck solved that irritation with an extremely clever solution:
    </p></div>
</div>

<div>
    <p>Moore made an interactive interpreter
    on a computer with nothing we would recognize today as an interactive
    terminal.
    </p><p>He accomplished this by making his program programmable.
    <img src="https://ratfactor.com/forth/talkimg/fortran_punchcard.png" alt="fortran on a punchcard"/>
    </p><div>
        <p>Here&#39;s a quote from <a href="https://www.forth.com/resources/forth-programming-language/">The Evolution of Forth</a> (forth.com):
        </p><blockquote>&#34;Moore&#39;s programming career began in the late 1950s at the
            Smithsonian Astrophysical Observatory with programs to compute
            ephemerides, orbital elements, satellite station positions, etc.
            His source code filled two card trays. To minimize recompiling this
            large program, he developed a simple interpreter to read cards
            controlling the program. This enabled him to compose different
            equations for several satellites without recompiling...&#34;</blockquote>
        <p>His free-form input format turned out, ironically, to be more
        <em>reliable</em> for human use than Fortran, which required formatted
        columns. (At the time, any mis-aligned columns in Fortran punchcard
        input would require a re-run of the program!)
        </p><p>It was also faster and more compact.
        </p><p>These &#34;programming the program&#34; statements in Moore&#39;s simple
        interpreter did not use keywords.
        They were statement <em>numbers</em> encoded on a punchcard.
    </p></div>
</div>

<div>
    <p>This is the origin of the system that would eventually be named
    <b>Forth</b>.
    </p><p>According to Moore, the interpreter&#39;s statement numbers would have been
    roughly equivalent to these Forth words:
    </p><pre>WORD NUMBER INTERPRET ABORT
    </pre>
    <p>Free-form input was unusual at the time. It&#39;s obviously a super nice
        alternative to recompiling your calculation program every time you want
        to change some numbers!

    </p><div>
        <p>So, at last, we have discovered <strong>the true origin of the Forth
        language</strong>: Moore wrote a simple interpreter to reduce waste
        and tedium.
        </p><p>Already, Moore has exhibited the defining combination of traits
        shared by great programmers around the world: Inventive and allergic to
        tedium.
        </p><p>If it had stopped there, it would have been a clever trick and
        perhaps worthy of a footnote in history.
        </p><p>But Chuck Moore did not stop there.
    </p></div>
</div>

<div>
    
    <p><img src="https://ratfactor.com/forth/talkimg/burroughs_b5500_computer.png" alt="drawing of chuck at the stanford burroughs b5500 system"/></p><div>
        <p>Now we head from Massachusetts to California where Moore found
        himself at Stanford University where he received his BA in Physics
        and started graduate school. He worked with Stanford&#39;s
        <b>Burroughs B5500</b>.
        </p><p>Let&#39;s talk about the computer first:
        </p><p>The B5500 (or &#34;B 5500&#34; - the official manual puts a space between
        the B and the number) was a solid-state computer. It was part of the 
        <a href="https://en.wikipedia.org/wiki/Transistor_computer">&#34;second-generation&#34; of computers</a>
        (wikipedia.org).
        These computers had discrete transistors on circuit boards.  By
        contrast, the <em>first generation</em> before them used vacuum tubes
        (like the aforementioned IBM 704) and the <em>third generation</em>
        after them used integrated circuits.
        </p><p>In fact, the 
        <a href="https://en.wikipedia.org/wiki/Burroughs_Large_Systems">Burroughs Large Systems</a>
        engineers were transistor computer pioneers.
        And the B5000 series was a pioneering system.
        </p><p>Here&#39;s some more resources:
        </p><ul>
            <li><a href="http://www.retrocomputingtasmania.com/home/projects/burroughs-b5500/b5000_b5500_gallery">Burroughs B5000 / B5500 / B5700 gallery</a>
                (retrocomputingtasmania.com)
                - an awesome illustrated guide including a picture of the
                actual Stanford B5500.
            </li><li><a href="http://www.bitsavers.org/pdf/burroughs/B5000_5500_5700/1021326_B5500_RefMan_May67.pdf">Burroughs B5500 Reference Manual (PDF)</a>
                (bitsavers.org)
                - The entire 224 page manual that came with the computer.
            </li><li><a href="http://infolab.stanford.edu/pub/voy/museum/computers19jan08.html">Early Computers at Stanford</a>
                (stanford.edu)
                - a description of the computer itself and a brief summary
               of its use at Stanford.
        </li></ul>
        <p>And what exactly did Chuck Moore do with that B5500 machine?
    </p></div>
</div>

<div>
    <p>Moore&#39;s CURVE was another mathematical application, written in
    Stanford&#39;s own Algol implementation.
    </p><p>It contained a much more sophisticated interpreter this time
    with a data stack and control flow operators.
    </p><p>Equivalent Forth words:
    </p><pre>IF ELSE DUP DROP SWAP + - * 
    </pre>

    <div>
        <p>(As we&#39;ll see, symbols like &#34;+&#34; and &#34;-&#34; are <i>words</i> in Forth.)
        </p><p>Moore worked on the Stanford Linear Accelerator
        as a programmer. His focus was on steering the beam of
        the electron accelerator.
        </p><p>The CURVE program was even more &#34;programmable&#34; than
        his Fortran program at SAO. He took those ideas and
        expanded them to include the idea of a parameter stack
        and the ability to define new procedures.
        </p><p>This made the interpreter much more flexible and capable.
        </p><p><b>Aside:</b> At this point, I also think it&#39;s interesting to
        compare Moore&#39;s budding interpreter language with another interpreter
        created specifically to be embedded in larger programs for controlling
        them:
        <a href="https://en.wikipedia.org/wiki/Tcl">The Tcl programming language</a>
        (wikipedia.org).
        27 years after Moore started his work, John Ousterhout created Tcl out
        of frustration with ad-hoc, half-baked solutions in 1988 at Berkeley. The
        name comes from &#34;Tool Command Language&#34;.  <strong>But the comparison
            goes deeper than just the shared motivation.</strong> Tcl and Forth
        have similar levels of syntactical purity and flexibility. Everything
        in Tcl is a string!  Both languages give the user the power to define
        fundamental parts of the system, such as new control structures, in the
        language itself.  If this sounds interesting, you owe it to yourself to
        play with Tcl for a while. It is extremely clever and extremely
        capable. The main implementation has been well cared-for and can be
        found on most Unix-like systems, often installed by default.
        </p><p>As Moore demonstrated with CURVE, a powerful, extensible interpreter
        is a huge time-saver (certainly when compared to re-compiling the
        program!) and allows the user of the program to add to the program&#39;s
        functionality on the fly. It&#39;s difficult to overstate how powerful this
        can be.
        </p><p>Truly, now we have the beginnings of a fully-fledged
        programming language. It&#39;s not named Forth yet, but
        we&#39;re getting closer.
    </p></div>
</div>

<div>
    
    <p><img src="https://ratfactor.com/forth/talkimg/teletype33.png" alt="a teletype 33 with paper tape reader and writer"/></p><p>&#34;With the TTY came paper-tape and some of the
        most un-friendly software imaginable - hours of editing and punching
        and loading and assembling and printing and loading and testing
        and repeating.&#34;
    </p><p>-- Chuck Moore, Forth, the Early years
    </p><div>
        <p>First, let&#39;s talk about what &#34;TTY&#34; means in 1965. 
        <a href="https://en.wikipedia.org/wiki/Teleprinter">Teleprinters</a>
        (wikipedia.org) or &#34;teletypewriters&#34; or just &#34;teletype&#34;
        were all printer devices. They printed to continuous sheets of paper
        fan-folded to fit into boxes.
        </p><p>The Latin &#34;tele-&#34; prefix means &#34;far&#34; or &#34;at a distance&#34;.  These
        machines trace a direct lineage from telegraphs and Morse code.
        </p><p>
        In the late 1800s, the concept of a typewriter which operated over
        telegraph lines had been explored and existed in a variety of forms.
        But the transmission code, paper tape, and typewriter system devised by
        <a href="https://oztypewriter.blogspot.com/2012/03/new-zealands-donald-murray-father-of.html">Donald Murray</a> (oztypewriter.blogspot.com)
        is the one that won out. And it was arguably Murray&#39;s
        choice of QWERTY keyboard that cemented it as the standard around
        the world.
        </p><p>The existing Baudot code (from which we also get the term &#34;baud&#34;)
        was modified by Murray into something that very much resembles what we
        still use today. Murray also introduced the concept of control
        characters, which still clearly retain their typewriter origins in the
        names:
        <code>CR</code> (carriage return) and <code>LF</code> (line feed). 
        </p><p>Teletype machines started as point-to-point text communication
        tools (like the telegraph), but they were later used over switched
        networks like the world-wide Telex system which used pulse dialing
        to automatically route a connection through the network.
        </p><p>
        The <a href="https://en.wikipedia.org/wiki/Teletype_Model_33">Teletype Model 33</a>
        (wikipedia.org)
        I drew above was one of the most popular teletypes used with computers.
        It was created by The Teletype Corporation in 1963, which means it
        shares a birth year with the ASCII standard!  It remained popular until
        the mid-1970s when video terminals finally came down in price enough to
        push printer teletypes aside. In fact, Teletype Co. made the Model 33
        until 1981, which is much later than I would have guessed!
        </p><p>As for
        <a href="https://en.wikipedia.org/wiki/Punched_tape">paper-tape</a>
        (wikipedia.org), I&#39;ll just quote Wikipedia directly:
        </p><blockquote>&#34;Punched tape was used as a way of storing messages for
            teletypewriters. Operators typed in the message to the paper tape,
            and then sent the message at the maximum line speed from the tape.
            This permitted the operator to prepare the message &#34;off-line&#34; at
            the operator&#39;s best typing speed, and permitted the operator to
            correct any error prior to transmission. An experienced operator
            could prepare a message at 135 words per minute (WPM) or more for
            short periods.&#34;
        </blockquote>
        <p>Donald Murray didn&#39;t invent the concept of perforated paper
        tape for data storage, but his system used it for the encoding of
        transmitted messages from the keyboard. It doesn&#39;t seem like a stretch
        to trace the origins of this storage method to Murray&#39;s system.
        </p><p>The computers of this era and earlier were paper manipulators.
        They were kind of like really complicated typewriters. They displayed
        their output on paper, they were programmed with paper, and they kept
        long-term storage on paper!
        </p><p>But as time went on, computer interactivity increased. They became
        less like typewriters and more like the machines we use today.
        </p><p>As each new ability emerged, Forth became increasingly interactive.
    </p></div>
</div>

<div>
    <p>Forth gains direct terminal input and output!
    </p><pre>KEY EMIT CR SPACE DIGIT
    </pre>
    <p>These new words turned Moore&#39;s system into a program editor.
    </p><p>Now you can edit the program within the program.
    </p><p>Moore&#39;s complete system is now kind of like an integrated development
    environment and kind of like an operating system.

    </p><div>
        <p>In the mid-1960s, &#34;mini-computers&#34; came out. They were 
        still huge by today&#39;s standards, but no longer required a
        large room of their own.
        </p><p>In addition to the reduction in size, the other emerging change was
        direct interactive use of a computer via teletype.
        </p><p>Specifically, the invention of
        <a href="https://web.stanford.edu/~learnest/nets/timesharing.htm">timesharing</a> (stanford.edu)
        was a huge shift away from the &#34;batch processing&#34; style of
        computing that had come before (like with input via punchcard).
        </p><p><i>(<b>Fun fact:</b> A &#34;second generation&#34; time-sharing operating system
        called <a href="https://www.multicians.org/history.html">Multics</a>
        (multicians.org)
        was the spiritual ancestor of and
        name from which Brian Kernighan made the joke name
        <strong>Unix</strong>: &#34;One of whatever Multics was many of&#34;.)</i>
        </p><p>Moore&#39;s evolving pre-Forth language also gained
        completely interactive editing and executing of programs.
        </p><p>This would have been right around the time
        that the original
        <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">LISP REPL (Read-eval-print loop)</a>
        (wikipedia.org)
        was created in 1964 on a PDP-1.
        </p><p>If not pre-saging, Moore was certainly on the bleeding edge
        of interactive computer usage!
        </p><p><b>Aside:</b> If you want to see an awesome demonstration of
        interactive computer usage on paper, check out this demonstration
        by Bob Spence:
        <a href="https://youtu.be/_DTpQ4Kk2wA">APL demonstration 1975</a>
        (youtube.com).
        <a href="https://en.wikipedia.org/wiki/Robert_Spence_(engineer)">Bob Spence</a>
        (wikipedia.org)
        is best known for his own contributions, including a number of early
        clever computer interaction ideas that are worth re-examining today.
        Bob&#39;s demo is extremely pleasant to watch and brilliantly presented
        in split screen. Notice how paper output lets you mark up stuff with
        a pen - pretty nice feature!
        And
        <a href="https://en.wikipedia.org/wiki/APL_(programming_language)">APL</a>
        (wikipedia.org)
        is a whole other rabbit hole which has interesting intersections with
        the point-free and higher-order function programming we&#39;ve encountered
        earlier.
        </p><p>Then this happens...
    </p></div>
</div>


<div>
    
    <p>IBM 1130 minicomputer at Mohasco, a textiles manufacturer in New York.
    <img src="https://ratfactor.com/forth/talkimg/ibm_1130.png" alt="drawing of chuck at an IBM 1130 minicomputer"/>
</p></div>

<div>
    <p>16 bit, 8 KB RAM.
    </p><p>Backup was via punch/reader.
    </p><p>With disks, now we can have file names!
    </p><p>File names limited to 5 characters...
    </p><p>Moore names his &#34;fourth generation&#34; system &#34;FORTH&#34;.

    </p><div>
        <p>Yup, this really is the origin of the name, &#34;Forth&#34;. Funny how
        temporary things tend to stick and last forever, isn&#39;t it?
        </p><p>The
        <a href="https://en.wikipedia.org/wiki/IBM_1130">IBM 1130</a>
        (wikipedia.org)
        is one of those new-fangled &#34;minicomputers&#34; we&#39;ve talked about.
        Gosh, it was so small, the CPU weighed less than a car!
        </p><p>
        And it was affordable! The base model was as low as $32,000.
        Compare that to $20,000, the median price for a house in the U.S.
        in 1965.
        Just think of that: If you could afford a house, you were well
        on your way to being able to afford a <em>computer</em>!
        </p><p>As noted, the unit Chuck Moore worked on had a disk drive,
        which would have bumped up the price an additional $9,000.
        That would be the equivalent of buying an above-average house
        and adding a couple brand-new 1965 cars in the driveway.
        </p><p>But, wow, imagine having disk drive cartridges with 512 KB of
        storage at your disposal.  What would you do with all that space?
        </p><p>As mentioned, at this time, we&#39;re still interacting with the
        computer (mostly) via paper, but these minis brought the idea of
        interactive computing to &#34;the masses&#34; because they were so much
        smaller, cheaper, and more reliable than the sorts of computers that
        had come before.
        </p><p>
        Quoting
        <a href="https://www.forth.com/resources/forth-programming-language/">The Evolution of Forth</a> (forth.com):
        </p><blockquote>
            &#34;Newly married and seeking a small town environment, Moore joined
            Mohasco Industries in Amsterdam, NY, in 1968. Here he developed
            computer graphics programs for an IBM 1130 minicomputer with a 2250
            graphic display. This computer had a 16-bit CPU, 8k RAM, his first
            disk, keyboard, printer, card reader/punch (used as disk backup!),
            and Fortran compiler. He added a cross-assembler to his program to
            generate code for the 2250, as well as a primitive editor and
            source-management tools. This system could draw animated 3-D
            images, at a time when IBM&#39;s software for that configuration
            drew only static 2-D images. For fun, he also wrote a version of
            Spacewar, an early video game, and converted his Algol Chess
            program into the new language, now (for the first time) called
            FORTH. He was impressed by how much simpler it became.&#34;
        </blockquote>
        <p>As you may have gathered by now, Chuck Moore is a pretty
        extraordinary computer programmer.
        </p><p>It turns out the IBM 1130 was hugely influential to a bunch of early
        big-name programmers in addition to Moore. Something was in
        the air.
        </p><p>In addition to its funny new name, Forth had also gained new
        abilities:
    </p></div>
</div>

<div>
    <p>Moore adds return call stack, allowing nested word definitions:
    </p><pre>: DOUBLE DUP + ;
: QUAD DOUBLE DOUBLE ;
    </pre>
    <p>And a <b>dictionary</b> of words.

    </p><div>
        <p>It&#39;s not just the name that makes this the first real Forth:
        A dictionary of named words which can be called interactively or
        recursively in the definitions of other words is one of the
        defining features of Forth. The ability to use words as building
        blocks is the Forth language&#39;s primary abstraction.
        </p><p>In the example above, we&#39;ve defined a word called <code>DOUBLE</code>
        which duplicates the number on the top of the stack and adds the
        two numbers together.
        </p><p>A second word called <code>QUAD</code> uses the previous definition
        by calling <code>DOUBLE</code> twice, quadrupling the number in a
        rather amusing way.
        </p><p>A return stack makes this possible. Without a return stack, we have
        no way of telling the computer how to &#34;get back&#34; to the place in
        <code>QUAD</code> where we left off after <code>DOUBLE</code> is done.
        </p><p>(We&#39;ll get to the specifics of the syntax soon. That&#39;s another
        vital part of understanding Forth.)
    </p></div>
</div>

<div>
    <p><img src="https://ratfactor.com/forth/talkimg/univac_1108.png" alt="drawing of chuck at a univac 1108 console"/></p>
    <p>Still at Mohasco. Programming a Univac 1108.
    </p><p>A new port of Forth written in assembler and could call COBOL modules
    because that&#39;s what the corporate suits wanted in 1970.
    </p><p>Moore <b>hates complexity</b>.

    </p><div>
        <p>First of all, the <a href="https://en.wikipedia.org/wiki/UNIVAC_1100/2200_series">UNIVAC 1108</a>
        (wikipedia.org)
        is a great example of the awesome &#34;retro-futuristic&#34; design of
        these old machines. Just look at the sweeping angles in my drawing
        of the console. That&#39;s a cool computer console!
        </p><p>When these computers cost more than a house, it makes perfect
        sense that they were constructed into beautiful custom furniture
        that made them look like space ships.
        </p><p>You have to wonder: Did the sci-fi art of the time drive
        the design of these computers or did the computers and industrial
        design of the time inform the art? Or, more likely, did they both
        feed off of each other in the classic cycle of, &#34;life imitates art
        imitates life?&#34;
        </p><p>That&#39;s a teletypewriter built into the desk of the console.
        I presume the tractor-feed paper would have spooled to and from
        containers behind the sleek facade.
        </p><p>Anyway, the UNIVAC 1108 is an even more modern computer than the IBM
        1130. Now we&#39;re moving into using integrated circuits for everything,
        including the register storage. (Speaking of registers, the 1108 had
        128 of them and must have been interesting to program!)
        </p><p>As was also the trend at the time, the CPU
        was constructed of discrete cards connected together by a wire-wrapped
        backplane.

        </p><p>If you&#39;re not familiar with the technique, you should know that
        <a href="https://en.wikipedia.org/wiki/Wire_wrap">wire-wrapped</a>
        (wikipedia.org)
        connections are extremely high quality. Wire is wrapped with
        great force around a post, making a gas-tight connection that will not
        corrode (corrosion can occur outside the connection, of course). A
        little bit of the insulation gets wrapped in the last turns, which
        provides flexibility and strain relief. There are NASA guidelines for
        making a perfect wire-wrap connection.
        </p><p>Anyway, the Univac was even more powerful and modern
        than Moore&#39;s previous computer and he took advantage of it.
        </p><p>You don&#39;t have to read between the lines to see Moore&#39;s obvious
        distaste of
        <a href="https://en.wikipedia.org/wiki/COBOL">COBOL</a>
        (wikipedia.org),
        the COmmon Business-Oriented Language.
        What&#39;s impressive is that he managed to still use Forth while
        also using the required COBOL modules.
        </p><p>When this project was abandoned by the employer, Moore was
        upset by the whole situation, particularly the way business software
        was increasing in complexity. This won&#39;t be the last time we
        see this theme crop up.
        </p><p>He also wrote a book (unpublished) at this time called
        <em>Programming a Problem-Oriented Language</em>.
        It&#39;s written in typical Moore fashion, without superfluous words or
        exposition. Feel free to contrast this with the article you&#39;re reading
        now.
        </p><p>(This book will be mentioned again later.)
    </p></div>
</div>

<div>
    
    <p>National Radio Astronomy Observatory
     - Computer control software for radio telescopes.
    <img src="https://ratfactor.com/forth/talkimg/nrao.png" alt="drawing of radio telescope dishes from NRAO"/>

    </p><div>
        <p>Radio telescopes are like visual telescopes, but they collect lower
        frequency waves. Thanks to the magic of computers, we can process these
        signals to see what the radio telescopes see.
        </p><p>Radio telescopes can work with everything from 1 kHz, which is just
        below the uses of &#34;radio&#34; as we think of it for navigation,
        communication, and entertainment, to 30 GHz, which is still well under
        the visible portion of the electromagnetic spectrum. Consumer microwave
        ovens operate at about 2.45 GHz.
        </p><p>(Speaking of Gigahertz, apparently Intel Core i9 processors can run
        at clock speeds up to 6 Ghz, but most CPU designs top out at around 4
        Ghz. This may be important for Forth for reasons I explain later.)
        </p><p>The visible part of the spectrum is very small by comparison. It
        starts at 420 THz (terahertz) and ends at 720 THz. The familiar
        rainbow of colors captured in the mnemonics &#34;Roy G. Biv&#34; or &#34;Richard of
        York Gave Battle in Vain&#34; (ROYGBIV) lists colors in order of lowest
        frequency (Red) to highest (Violet).
        </p><p>Here is the official website of the
        <a href="https://public.nrao.edu/">National Radio Astronomy Observatory</a>
        (nrao.edu).
        But for a better summary,
        <a href="https://en.wikipedia.org/wiki/National_Radio_Astronomy_Observatory">the Wikipedia entry</a> (wikipedia.org)
        is the way to go. Be sure to scroll down to the incredible image and
        description from 1988 of the collapsed 300ft radio telescope:
        </p><blockquote>
            &#34;The telescope stood at 240ft in height, wieghed 600-tons, had a
            2-min arc accuracy, and had a surface accuracy of ~1 inch. The
            collapse in 1988 was found to be due to unanticipated stresses
            which cracked a hidden, yet weight and stress-supporting steel
            connector plate, in the support structure of the massive telescope.
            A cascade failure of the structure occurred at 9:43pm causing the
            entire telescope to implode.&#34;
        </blockquote>
        <p>The 300ft dish had been the world&#39;s largest radio telescope when it
        went active in 1962 at the NRAO site in West Virginia.
        </p><p>My drawing above is of the
        <a href="https://en.wikipedia.org/wiki/Very_Large_Array">Very Large Array</a>
        (wikipedia.org)
        in New Mexico.
        NRAO is also a partner in a huge international array in Chile.
        </p><p>By using radio interferometry, arrays of telescopes can be treated
        as essentially one huge telescope with the diameter of the array
        (missing the <em>sensitivity</em> a dish of that size would have).
        </p><p>But the scope for which Moore wrote software was a single 36ft (11
        meter) dish at Kitt Peak in Arizona called <b>The 36-Foot Telescope</b>.
        It was constructed in 1967 and continued
        working until it was replaced with a slightly larger and more
        accurate dish in 2013.
        </p><p>The 36ft scope was used for millimeter-wavelength molecular astronomy.
        This is the range above &#34;microwaves&#34; and these telescopes pretty
        much have to be constructed at dry, high altitude sites because
        water vapor in the air can interfere with the radio waves.
        </p><p>(Note that Moore stayed at the NRAO headquarters in Virginia and
        was not on-site at Kitt Peak.)
        </p><p>NRAO had a policy of using Fortran on its minicomputers, but based
        on the success of his previous work, Moore was begrudgingly given
        permission to use Forth instead.
        I couldn&#39;t possibly do justice to summarizing it, so here&#39;s Chuck&#39;s
        own words describing the software he wrote for the NRAO (also from
        <i>Forth - The Early Years</i>):
        </p><blockquote>
            <p>&#34;There were two modes of observing, continuum and spectral-line.
            Spectral-line was the most fun, for I could display spectra as they
            were collected and fit line-shapes with least-squares.&#34;
            </p><p>It did advance the state-of-the-art in on-line data reduction.
            Astronomers used it to discover and map inter-stellar molecules
            just as that became hot research.&#34;
        </p></blockquote>
        <p>
        <a href="https://public.nrao.edu/gallery/the-36foot-molecule-hunter-at-work/">Here is a photo</a> (nrao.edu) of the 36-foot telescope.
        And
        <a href="https://www.nrao.edu/archives/items/show/35209">here is a photo of the control room in 1974</a>
        (nrao.edu)
        with what appears to be a PDP-11 in the background.
        </p><p>As you can see, the work itself was extremely interesting and
        cutting-edge. But how Moore went about it was also very interesting,
        which a series of computer drawings will demonstrate in a moment.
        </p><p>But on the Forth language front, there was another development...
    </p></div>
</div>
<div>
    <p>At this time, there are talks of patenting Forth.
    </p><p>Moore believes <b>ideas shouldn&#39;t be patented</b>.

    </p><div>
        <p>We take it for granted now that &#34;free&#34; or &#34;open&#34; software
        unencumbered by patents and restrictive corporate licenses is a good
        thing. But this was <em>absolutely not a mainstream position</em> in
        the early 1970s.
        </p><p>To put things in context, in the summer of 1970, 
        <a href="https://en.wikipedia.org/wiki/Richard_Stallman">Richard Stallman</a>
        (wikipedia.org) was just out of high school and was writing
        his first programs in Fortran (which he hated) and then APL.
        </p><p>It wasn&#39;t until 1980 that Stallman finally got fed up enough with
        the state of proprietary and legally encumbered software to start the
        &#34;free-as-in-freedom&#34; software revolution. Companies were increasingly
        using copyright to prevent modification, improvement, or duplication by
        the end user. Stallman, being a pretty incredible programmer, wrote free
        clones of such programs. He announced the
        <a href="https://en.wikipedia.org/wiki/GNU_Project">GNU project</a>
        (wikipedia.org)
        in 1983.
        </p><p><b>Aside:</b> I believe Stallman was right. There&#39;s absolutely
        nothing wrong with writing programs for money or selling software. But
        using the law to prevent people from truly owning that software
        by limiting how or where to run it, or even <em>preventing people from
            writing their own similar software, if they are capable</em>, is an
        abominable practice and should be countered at every step.
    </p></div>
</div>

<div>
    <p>Moore also rejects the standardization of Forth.
    </p><p>&#34;All of my fears of the standard and none of the advantages of the standard have come to pass. Any spirit of innovation has been thoroughly quelched.
    </p><p>-- Chuck Moore, 1997

    </p><div><p>
        Quote from the <b>ANSI Forth</b> section in 
        <a href="http://www.ultratechnology.com/moore4th.htm">this cool collection of Forth quotes</a>
        (ultratechnology.com) by Jeff Fox.

        </p><p>I think that when you get to the heart of what Forth is all
        about, Moore&#39;s displeasure with the ANSI standardization suddenly makes
        tons of sense. In short, the whole <em>point</em> of Forth is to create
        your own toolkit. Having an all-inclusive language standard is great
        for making sure Forths are interchangeable. Unfortunately, it&#39;s
        also antithetical to adapting the language to your specific hardware
        and software needs.
        </p><p>Alright, enough philosophizing. Let&#39;s get back to the computer
        stuff!
        </p><p>While Moore was at NRAO, he also wrote software to point the telescope.
        Elizabeth Rather (Moore credits her as Bess Rather in his paper) was
        hired for support and they worked together on at least one port.
        The Forth system migrated across multiple machines at NRAO which,
        as we&#39;ll see, highlights one of the <b>technological strengths</b> of the
        standard Forth implementation.
        </p><p>By the way, after her initial reaction of shock and horror, 
        Elizabeth Rather embraced Forth. From
        <a href="https://www.forth.com/resources/forth-programming-language/">The Evolution of Forth</a>
        (forth.com):
        </p><blockquote>
            &#34;After about two months, Rather began to realize that something
            extraordinary was happening: despite the incredibly primitive
            nature of the on-line computers, despite the weirdness of the
            language, despite the lack of any local experts or resources, she
            could accomplish more in the few hours she spent on the Forth
            computers once a week than the entire rest of the week when she had
            virtually unlimited access to several large mainframes.&#34;
        </blockquote>
        <p>Rather went on to write the first Forth manual in 1972 and
        write papers about it for the NRAO and other astronomical organizations.
        </p><p>Later, <a href="https://en.wikipedia.org/wiki/Elizabeth_Rather">Elizabeth &#34;Bess&#34; Rather</a>
        (wikipedia.org)
        became the co-founder of FORTH, Inc with Chuck and
        remained one of the leading experts and promoters of the Forth language
        until her retirement in 2006.
        <img src="https://ratfactor.com/forth/talkimg/forth_nrao_spectral_line_observing_ieee1973.jpg" alt="screenshot of the top half of the first page of the article"/>
        </p><p>There&#39;s a great overview paper of the whole NRAO system by
        Moore and Rather in a 1973 <i>Proceedings of the IEEE</i>:
        <a href="http://home.iae.nl/users/mhx/forth_NRAO.pdf">The FORTH Program for Spectral Line Observing (PDF)</a>
        (iae.nl).
        </p><p>It includes a high-level description of the system with examples of
        interactive Forth usage and a neat diagram on the first page, which you
        can see in the screenshot.
        </p><p>As mentioned, Forth was ported to a bunch of different computers
        at NRAO.
        </p><p>Let&#39;s take a look:
    </p></div>
</div>

<div>
    <p>Forth on the IBM 360/50
    <img src="https://ratfactor.com/forth/talkimg/ibm_360_50.png" alt="drawing of chuck using an ibm 360/50 computer"/>

    </p><div>
        <p>Moore mentions first having ported his Forth system to the
        <a href="https://en.wikipedia.org/wiki/IBM_System/360">IBM 360/50</a>
        (wikipedia.org).
        </p><p>The System/360 (or S/360) computers were extremely successful,
        largely because of availability, longevity, and compatibility.
        IBM claims to be the first company to use
        <a href="https://en.wikipedia.org/wiki/Microcode">microcode</a>
        (wikipedia.org)
        to provide a compatible instruction set across all S/360 computers
        despite the hardware differences between models.
        </p><p>The cheaper 360 computers used microcode while the more expensive
        and powerful machines had hard-wired logic. NASA even had some one-off
        models of IBM 360 made just for them.
        </p><p>Until microcode came along, if you bought a &#34;cheap&#34; computer to get
        started and then upgraded to a more powerful computer, you would have
        to re-write your programs in a new instruction set. (If you happen to
        have written your programs in a high-level language like Fortran, you
        would still have to re-compile your programs from punchcards, and you
        would need the Fortran compilers on both computers to be perfectly
        compatible!) It&#39;s easy to see why being able to upgrade without
        changing your software would have been appealing.
        </p><p>System/360 computers were
        a &#34;big bet&#34; (5 billion dollars according to IBM themselves:
        <a href="https://www.ibm.com/ibm/history/ibm100/us/en/icons/system360/">System 360: From Computers to Computer Systems</a>
        (ibm.com)) that nearly destroyed the company.
        The bet clearly paid off because they made these machines
        from 1964 to 1978.
        </p><p>Oh, and it wasn&#39;t just the instruction set that was compatible. The
        360 computers also had standardized peripheral interfaces, which were
        compatible between machines.
        There was a huge market for peripheral devices.  IBM
        themselves made 54 different devices such as memory, printers, card
        readers, etc. The 360 also spawned a whole third-party peripheral
        industry, much like the IBM PC-compatible era that started in 1981 and
        continues to the desktop computer I&#39;m typing on right now in 2023.
        </p><p>Moore wrote Forth from scratch in S/360 assembly.
        </p><p>Then...
    </p></div>
</div>

<div>
    <p>Forth ported to the Honeywell 316
    <img src="https://ratfactor.com/forth/talkimg/honeywell_316.png" alt="drawing of chuck using a honeywell 316computer"/>

    </p><div>
        <p>I drew Chuck behind the system in this one because I couldn&#39;t
        bring myself to obscure an inch of that glorious pedestal console.
        </p><p>You can see the
        <a href="https://en.wikipedia.org/wiki/Honeywell_316">Honeywell 316</a>
        (wikipedia.org)
        and <a href="https://commons.wikimedia.org/wiki/File:Honeywell316.jpg">the brochure</a>
        (wikimedia.org)
        image from which I made my drawing.
        </p><p>Just look at the space-age lines on that thing! It looks straight
        out of a Star Trek set. Sadly, there&#39;s basically no chance the one
        Moore actually worked on had this console. Less than 20 of them were
        sold. <strong>But thanks to my drawing, we can pretend.</strong>
        </p><p>Beyond just its appearance, this particular console has a really
        wild history. The extravagant gift company, Neiman Marcus, actually
        offered the Honeywell H316 with this pedestal as a &#34;kitchen computer&#34;.
        It cost $10,000 and would have come with a two-week course to learn
        how to input recipes and balance a checkbook using toggle switches and
        lights to indicate binary data! (As far as anyone knows, none of these
        were actually sold.)
        </p><p>The ad for the Honeywell Kitchen Computer was in full &#34;Mad Men&#34;
        mode and was extremely patronizing, as was unfortunately typical for
        the time. But if you can look past that, the whole thing is quite
        funny:
        </p><blockquote>
            &#34;Her souffles are supreme, her meal planning a challenge? She&#39;s
            what the Honeywell people had in mind when they devised our Kitchen
            Computer. She&#39;ll learn to program it with a cross-reference to her
            favorite recipes by N-M&#39;s own Helen Corbitt. Then by simply pushing
            a few buttons obtain a complete menu organized around the entree.
            And if she pales at reckoning her lunch tabs, she can program it to
            balance the family checkbook...&#34;
        </blockquote>
        <p>You can see a tiny scan of the original ad with a woman admiring
        her new Honeywell Kitchen Computer that barely fits in her kitchen
        <a href="https://en.wikipedia.org/wiki/File:Kitchen_computer_ad.jpg">here</a>
        (wikipedia.org).
        </p><p>But moving on from the pedestal...
        </p><p>The implementation of Forth on the H316 is considered to be the
        first complete, stand-alone implementation because it was actually
        programmed on the computer itself <em>and</em> was used to create other
        Forths. It is at this point that Moore has achieved a fully
        ascendant system.
        </p><p>But wait, there&#39;s <strong>moore</strong>...er,
        sorry, <strong>more</strong>!
        </p><p>As is typical for a Chuck Moore endeavor, this
        telescope application pushed other new boundaries:
        The system actually ran across two computers (we&#39;re about to see
        the second one) and gave real-time access to <em>multiple</em> astronomers.
        Because it spread the load the way it did, there were no issues with
        concurrency, which is something we programmers struggle with to this day.
        </p><p>This real-time control and analysis was basically a
        luxury available on no other system at the time.
        Even Honeywell, the creator of these computers, had only been able to
        achieve the most primitive concurrency for them and it was
        nothing like this.
        </p><p>As usual, Moore was right on the very crest of
        computing with his ultra-flexible Forth system.
    </p></div>
</div>

<div>
    <p>...And ported to the Honeywell DDP-116
    <img src="https://ratfactor.com/forth/talkimg/ddp_116.png" alt="drawing of chuck using a honeywell DDP-116 computer"/>

    </p><div>
        <p>As mentioned above, the Forth system was <em>also</em> ported to the
        <a href="https://t-lcarchive.org/honeywell-ddp-116/">DDP-116</a>
        (t-larchive.org).
        and used with its &#34;parent&#34; system on the H316 featured above.
        </p><p><i>(The DDP-116 was originally manufactured by
        <a href="https://en.wikipedia.org/wiki/Computer_Control_Company">Computer Control Company</a> in 1965, but CCC was sold to Honeywell in 1966 and
        became its Computer Controls division.)</i>
        </p><p>The DDP-116 was a 16-bit computer (the first available for
        purchase), but still part of that &#34;second generation&#34; of computers
        we&#39;ve mentioned before, with individual
        transistors and components wire-wrapped together on huge circuit
        boards. (Check out the pictures on the DDP-116 link above for all
        sorts of excellent views of the insides and outsides of an example
        machine and its peripheral devices!)
        It happens to have also been a pretty rare computer. It didn&#39;t sell
        in vast quantities like the IBM systems.
        </p><p>As you can see in the drawing, Chuck Moore began to grow in power as
        his system evolved and this manifested in <strong>additional
            arms</strong>!  Or maybe I started to get a little loopy while
        drawing old computers for these slides in the final evenings before I
        was due to give my talk?  I&#39;ll let <em>you</em> decide what is real.
        </p><p>But wait, there&#39;s one more!
    </p></div>
</div>

<div>
    <p>Forth on the DEC PDP-11
    </p><p>(Yes, <i>that</i> PDP-11.)
    <img src="https://ratfactor.com/forth/talkimg/dec_pdp_11.png" alt="drawing of chuck using a DEC PDP-11 computer"/>

    </p><div>
        <p>The
        <a href="https://en.wikipedia.org/wiki/PDP-11">PDP-11</a>
        (wikipedia.org) was by some measures the most popular minicomputer ever.
        </p><p>
        It was a 16-bit machine and had an orthogonal instruction set
        (meaning the same instruction could be used in multiple ways
        depending on the operand. This makes the mnemonics of the instruction
        set smaller and more logical and much easier to memorize).
        This was even more powerful because I/O was memory-mapped, so the
        same instructions used to move values around in memory and
        registers could <em>also</em> be used to transfer data to
        and from devices.
        </p><p>All told, these conveniences made the PDP-11 fun to program!
        Assembly language programmers rejoiced.  The ideas in the PDP-11 spread
        rapidly and are to be found in the most popular architectures in use
        today. Compared to what came before it, PDP-11 assembly language will
        look surprisingly familiar to modern assembly programmers.
        </p><p>The original machines were made starting in 1970 with
        wire-wrapped backplanes and discrete logic gates.
        Later models introduced &#34;large-scale integration,&#34; which is a term
        we&#39;ll see later, so hold that question!
        These later versions of the PDP-11 were still being
        made twenty years later in 1990! There are apparently still PDP-11s
        performing crucial tasks today, with nuclear power plants being one of
        the most prominent examples.
        </p><p>It&#39;s hard to see in my drawing, but the PDP-11 front panel is one
        of the most iconic computer interfaces ever made. Hobbyists make
        working models, including ridiculously cute and awesome miniature
        versions. Here are two model versions - click on them to go to the
        original wikipedia.org files, where you can admire their full beauty:
        </p><p><a href="https://en.wikipedia.org/wiki/File:Digital_PDP11-IMG_1498_cropped.jpg"><img src="https://ratfactor.com/forth/talkimg/Digital_PDP11-IMG_1498_cropped.jpg" alt="pdp11 panel1"/></a>
        <a href="https://en.wikipedia.org/wiki/File:Pdp-11-70-panel.jpg"><img src="https://ratfactor.com/forth/talkimg/Pdp-11-70-panel.jpg" alt="pdp11 panel2"/></a>
        <br/>
        </p><p>It would be difficult to overstate the impact of this machine.
        Probably the most famous piece of software released on the PDP-11
        was the first version of
        <a href="https://en.wikipedia.org/wiki/Unix">Unix</a>
        (wikipedia.org)
        that actually bore the name &#34;Unix&#34;.
        </p><p>It was also the birthplace of the
        <a href="https://en.wikipedia.org/wiki/C_(programming_language)">C</a>
        (wikipedia.org)
        programming language.
        Dennis Ritchie ported Ken Thompson&#39;s B language to the PDP-11 to
        take advantage of its abilities. Unix was then re-written in C
        starting with Version 4.
        So the Unix we know today and a large portion of the command line
        utilities that are standard with a Unix-like system were programmed
        on the PDP-11. (And you can thank Richard Stallman&#39;s GNU project for
        freeing those for the masses. GNU stands for &#34;GNU&#39;s Not Unix!&#34;)
        </p><p>You&#39;ll also note that Chuck Moore has gained his
        <strong>fourth and final arm</strong> in my drawing above
        (&#34;fourth,&#34; ha ha).
        <em>This may or may not reflect actual events.</em>
        Also, I&#39;m not sure if Moore would have been using a video terminal at
        that time. It&#39;s possible. DEC&#39;s first video terminal was the
        <a href="http://www.columbia.edu/cu/computinghistory/vt05.html">VT05</a>
        (columbia.edu),
        which came out in 1970.
    </p></div>
</div>

<div>
    
    <p>All of this porting of Forth to new machines is possible because of
    <b>indirect threaded code</b>.
    <img src="https://ratfactor.com/forth/talkimg/threaded_code_abstract.png" alt="an abstract drawing of boxes and arrows representing threaded code in memory"/>
</p></div>

<div>
    <p>&#34;Threaded code&#34; in this usage is <strong>not</strong>
    related to concurrency, i.e. &#34;multi-threaded programming&#34;.
    </p><p>It&#39;s code that is composed of subroutines addresses.
    </p><p>Threaded code can be machine code or interpreted.

    </p><div>
        <p>Wait, aren&#39;t <em>most</em> programs composed of calls to subroutines?
        </p><p>That&#39;s true. The big difference is that
        <a href="https://en.wikipedia.org/wiki/Threaded_code">threaded code</a>
        (wikipedia.org) in this sense
        doesn&#39;t actually contain the instructions to <em>call</em> the
        subroutines. It stores just the addresses.
        Therefore <em>another</em> routine is responsible for advancing
        a pointer over the address
        list and executing the subroutines.
        </p><p>Huh?
        </p><p>Yeah, there&#39;s no way around it, threaded code is complicated.
        </p><p>And <em>indirect</em> threaded code is even more complicated (and
        harder to explain).
        </p><p>&#34;Hey, wait!&#34; I hear you saying. &#34;If Chuck hates complexity so
        much, why did he use such a complex method for Forth?&#34;
        </p><p>That&#39;s completely fair.
        </p><p>But before we address that, I&#39;ll try to briefly explain how
        threaded code is stored and executed.
        </p><p>First, here&#39;s how <em>normal</em> machine code might be written:
    </p></div>
</div>

<div>
    <p>Direct calls (not threaded):
    </p><pre>jmp 0x0804000
jmp eax
    </pre>

    <div>
        <p>This is the simplest type of &#34;call&#34; to store in a program.
        We simply have the <code>jmp</code> (jump) instruction followed
        by the address to jump <em>to</em>.
        Here I show both a hard-coded address
        (<code>0x0804000</code>) and a register
        (<code>eax</code>).
        Both of these are &#34;direct&#34; for our purposes.
        </p><p><i>Alternatively, many processors have a more advanced <code>call</code>
        instruction. A call is more complicated because it has to do additional
        work behind the scenes. It must store a return address on &#34;the stack&#34;
        before jumping to the specified address. Then a <code>ret</code>
        (return) instruction at the end of the called routine can use the
        stored address to resume the execution just after the &#34;call site&#34; where
        the call was first made.  Why are return addresses stored on a stack?
        That&#39;s because you can nest calls. Pushing addresses as you jump and
        popping them in reverse order as you return keeps things nice and neat.
        This &#34;the stack&#34; is not what Forth refers to as &#34;the stack&#34;. Forth&#39;s
        main stack is better known as &#34;the parameter stack&#34;. Many Forth
        implementations <strong>also</strong> have a return stack!</i>
        </p><p>Anyway, this is direct and it&#39;s not threaded. Just jump to an address.
        </p><p>The first step of complication is adding indirection.
    </p></div>
</div>

<div>
    <p>Indirect calls (not threaded):
    </p><pre>jmp [eax]
    </pre>

    <div>
        <p>For this example to make sense, you need to know that the
        square brackets around the register (<code>[eax]</code>)
        is a common assembly language convention that means
        &#34;the value at the memory address that is stored in register eax&#34;.
        </p><p>So <code>jmp [eax]</code> means &#34;jump to the address
        stored at the address stored in register eax.&#34;
        </p><p>That&#39;s indirect.
        </p><p>So now we have the &#34;indirect&#34; part of &#34;indirect threaded
        code.&#34; But what&#39;s the &#34;threaded&#34; part?
    </p></div>
</div>

<div>
    <p>Storing threaded code:
    </p><pre>&lt;addr pointing to code&gt;
&lt;addr pointing to code&gt;
&lt;addr pointing to code&gt;
&lt;addr pointing to code&gt;
    </pre>

    <div>
        <p>Instead of containing the actual instructions to jump or
        call subroutines:
        </p><pre>jmp 0x0804000
jmp 0x080A816
jmp 0x08C8800
jmp 0x08C8DD0
        </pre>
        <p><strong>Threaded code</strong> stores just the list of
        addresses:
        </p><pre>0x0804000
0x080A816
0x08C8800
0x08C8DD0
        </pre>
        <p>There are two consequences of storing code like this:
        </p><ul>
            <li>The address list takes up less memory than the full code to
                make the jump. (In fact, it takes a <em>lot</em> less on some
                historic machines.) This is good.
            </li><li>Some sort of &#34;code interpreter&#34; will need to be written to
                execute this list. You can&#39;t just send a list of addresses
                to a processor and expect it to work. This could be good or bad.
        </li></ul>
        <p>Another way to look at the list of addresses above is that, 
        conceptually, threaded code is basically a list of subroutines.
        </p><p>To complete our definition of &#34;indirect threaded&#34; code, we just
        need to put both concepts together:
    </p></div>
</div>

<div>
    <p>Storing <b>indirect threaded</b> code:
    </p><pre>&lt;addr pointing to addr pointing to code&gt;
&lt;addr pointing to addr pointing to code&gt;
&lt;addr pointing to addr pointing to code&gt;
&lt;addr pointing to addr pointing to code&gt;
    </pre>

    <div>
        <p>This is where it gets pretty crazy. So now we&#39;ve got a second
        level of indirection. <strong>Why on Earth would we do this?</strong>
        </p><p>Well, this allows us to store a separate &#34;code interpreter&#34;
        (or &#34;inner interpreter&#34;) for different <em>kinds</em> of subroutines!
        </p><p>Instead of pointing directly at subroutines, these addresses point
        at interpreters.
        Talk about ultimate flexibility - every subroutine in an indirect
        threaded program can have its own custom interpreter for the rest
        of its instructions...each of which can also be threaded...or
        indirectly threaded!
        </p><p>But what calls all of these inner interpreters?
        An outer interpreter, of course! The outer interpreter is the
        part we actually interact with when we sit down to type
        at a Forth terminal.
        </p><p>In <b>Forth</b>, indirect threaded code is a list of
        addresses pointing to the &#34;inner interpreter&#34; portions of
        words, which execute the rest of the word.
        What types of inner interpreters could we have, anyway?
        Well, for example, we might have one kind of word that stores a string
        in memory and another that executes machine code. But the only
        limit is your imagination.
        </p><p>Make sense?
        </p><p>I personally would not have understood
        that explanation at all until much later in my journey (I know this
        because similar - probably better - explanations flew right over
        my head). No doubt you&#39;re faster than me at apprehending this stuff
        and are already halfway through implementing your own Forth based on
        these descriptions.
        </p><p>None of the rest of the material requires understanding any
        of the above, so please don&#39;t feel you need to fully
        <a href="https://en.wikipedia.org/wiki/Grok">grok</a>
        (wikipedia.org)
        it before continuing. Indirect threading is an important part of
        Forth&#39;s history, but there are plenty of Forths that do not use it.
    </p></div>
</div>

<div>
    <p><img src="https://ratfactor.com/forth/talkimg/16k_memory.png" alt="drawing of a minicomputer saying &#39;i have 16k of core!&#39;"/></p><p><b>Threaded code</b> was much more common in the days of yore.
    </p><p>It is very dense, compact on disk and in memory.

    </p><div>
        <p>In addition to its compact storage, threaded code
        would have been <em>even more</em> efficient on the contemporary
        machines during Forth&#39;s gestation because
        calling subroutines often wasn&#39;t as simple as the
        <code>call</code> instruction found on &#34;modern&#34; architectures.
        </p><p>
        <a href="https://people.computing.clemson.edu/~mark/subroutines.html">Subroutine and procedure call support</a>
        (clemson.edu) by Mark Smotherman explains:
        </p><blockquote>
            &#34;1963 - Burroughs B5000 - A stack-based computer with support for
            block-structured languages like Algol. Parameters and return address
            are stored on the stack, but subroutine entry is a fairly complex
            operation.&#34;
        </blockquote>
        <p>So the memory and performance improvements of this style of
        subroutine call were potentially
        very great indeed. This is one of the reasons for <strong>Forth&#39;s
            legendary reputation for high performance</strong>.
        </p><p>We&#39;ll revisit this topic from another angle soon. But if you&#39;re
        interested in these mechanics
        (and want to see the origin of the boxes and arrows
        drawings at the top of this section), check out this multi-part
        article series for The Computer Journal,
        <a href="https://www.bradrodriguez.com/papers/moving1.htm">MOVING FORTH Part 1: Design Decisions in the Forth Kernel</a>
        (bradrodriguez.com),
        by Brad Rodriguez.
        </p><p>The important thing is that we&#39;ve now fully traced the origins
        of Forth from a simple command interpreter to the full-blown
        <strong>interactive language, editor, operating system, and
            method of code storage and execution</strong> it became.
    </p></div>
</div>

<div>
    <p><img src="https://ratfactor.com/forth/talkimg/chuck_hero.png" alt="drawing of chuck moore as a superhero with a cape and bowtie"/></p><p>That&#39;s Forth&#39;s <b>origin story</b>.
    </p><ul>
        <li>Postfix notation (RPN)
        </li><li>Stack-oriented
        </li><li>Concatenative programming style
        </li><li>Interpreted
        </li><li>Highly adaptable to machine architectures
        </li><li>Extremely compact
    </li></ul>
    <p>This gives us the <i>why</i>.
    </p><div>
        <p>At last! Now we can put it all together:
        </p><p>Forth is <strong>postfix</strong> because that&#39;s a natural
        order for the computer and lends itself to an incredibly minimalistic
            interpreter implementation: get the values, operate on them;
        </p><p>Forth is <strong>stack oriented</strong> because that&#39;s a
            compact and convenient way to store
            values without needing to add variables or name things;
        </p><p>Forth is <strong>concatenative</strong> because building a
            language that can operate as a string of words is incredibly
            flexible and can adapt to just about any programming style without
            any help from the language itself. (And it turns out this is
            especially true when you throw in higher-order functions);
        </p><p>Forth is <strong>interpreted</strong> because that is
            interactive and allows the programmer to make fast changes on
            the fly or simply &#34;play&#34; with the system. This is part of
            Forth&#39;s adaptability and flexibility;
        </p><p>Forth is <strong>self-hosting</strong> because you can
            bootstrap a Forth implementation from a handful of words
            implemented in assembly and then write the rest in Forth;
        </p><p>Forth is <strong>extremely compact</strong> because machines at
            the time had limited memory and this gave Forth an edge on
            other interpreters (and even compiled languages!) on
            mainframes and mini-computers.
        </p><p>Now that we have everything in historical context, I think it&#39;s
            much clearer why Forth exists and why it takes the peculiar
            form that it does.
        </p><p><strong>None of this was planned. Chuck didn&#39;t sit down at a terminal
        in 1958 and conjure up Forth. Instead, he grew a system to
        serve his needs and to make use of new hardware as it was made
        available.</strong>
        </p><p>Reading about Forth&#39;s history is a wonderful way to understand
        what makes Forth special and what it&#39;s <i>about</i>.
        </p><p>But even knowing all of this, I was still a long way off from a true
        understanding of how this <strong>all comes together</strong> in an
        actual working system. I didn&#39;t really understand how it worked.
        And I didn&#39;t understand what Forth was actually like to <em>use</em>
        In other words, I still didn&#39;t understand Forth as a
        <em>programming language</em>.
    </p></div>
</div>

<div>
    
    <p>Somewhere along the way, I came across these quotes...
    </p><p>&#34;To understand Forth, you have to implement a Forth.&#34;
    </p><p>-- Somebody on the Internet
    </p><p>And</p>
    <p>&#34;Take a look at JonesForth.&#34;
    </p><p>-- Everybody on the Internet

    </p><div>
        <p>I&#39;ve mentioned it before, but I&#39;ll point it out again. Notice the
        phrasing &#34;implement <em>a</em> Forth.&#34;
        </p><p>As we&#39;ve established, Chuck Moore believes a Forth system is best
        when it is custom-tailored to the system and task at hand.  So it
        should come as little surprise that writing your own Forth or Forth-like is
        entirely &#34;par for the course&#34; in any would-be-Forther&#39;s quest to
        discover the True Meaning of the language and enter the mystical realm
        where All is Revealed.
        </p><p>Well, what else could I do?
        </p><p>Having no other clear course of study, I decided to heed the
            wisdom of the crowd.
        </p><p>Presenting...
    </p></div>
</div>


<div>
    
	<p><img src="https://ratfactor.com/forth/talkimg/assembly-nights.jpg" alt="My faithful Asus EeePC 701 waiting romantically on the bed. Text reads &#39;Assembly Nights&#39;"/>
    <i></i></p><div>
        <p>To really get to know it, I took Forth to bed with me.
        </p><p>I wrote
        <a href="https://ratfactor.com/assembly-nights">Assembly Nights</a>
        when I realized how much I was enjoying myself:
        </p><blockquote>
            &#34;Over the last three months, I&#39;ve developed an unusual
            little nighttime routine...&#34;
        </blockquote>
        <p>I prepared myself for dealing with the JonesForth source
        (i386 assembly language in the GNU GAS assembler)
        by learning some assembly and Linux ABI basics.
        JonesForth is 32-bit only and uses the Linux system call (&#34;syscall&#34;)
        ABI directly.
        </p><p>Then I spent roughly a year porting JonesForth into a complete
        working copy in NASM assembler. (Yes, that&#39;s a &#34;port&#34; from one flavor
        of i386 asm to another.)
        </p><p>I did a tiny bit almost every night.  A lot of it was debugging in
        GDB.
    </p></div>
</div>

<div>
	<p><img src="https://ratfactor.com/forth/talkimg/nasmjf.png" alt="my giant gold on gray logo for nasmjf"/></p><p>My NASM port of JonesForth: <code>nasmjf</code>
    </p><p>Opening the third eye by (re)implementing Forth.

    </p><div>
        <p>Here&#39;s the
        <a href="https://ratfactor.com/nasmjf/">nasmjf web page</a>
        </p><p>In the process of writing the port, I learned how a traditional
        indirect threaded Forth works.
        </p><p>And I learned that <em>it takes time</em> to absorb such a
        twisty-turny  method of code execution.
        </p><p>Especially if the x86 assembly language tricks are new to you like
        they were for me.
    </p></div>
</div>

<div>
    <p>JonesForth ascii art:
    <img src="https://ratfactor.com/forth/talkimg/jonesforth1.png" alt="jonesforth ascii art explaining flow of threaded code"/>

    </p><div>
        <p>One of the first things you encounter when you open up the
        <code>jonesforth.S</code> (a single file which contains the assembly
        language portion of JonesForth) are many ASCII art diagrams.
        </p><p>Richard W.M. Jones does an excellent job of walking you through
        the workings of the interpreter and explaining the i386 instruction
        set features he uses.
        </p><p>If the diagram above seems bewildering, I agree.
        </p><p>So, of course, I thought maybe I could do better...
    </p></div>
</div>

<div>
    <p>Here&#39;s my attempt (from the <code>nasmjf</code> source):
    <img src="https://ratfactor.com/forth/talkimg/nasmjf1.png" alt="my nasmjf ascii art explaining flow of threaded code"/>

    </p><div>
        <p>After I was done with my port, I tried to make an ASCII art diagram
        of my own to capture my new understanding.
        In fact, this is one of several.
        </p><p>With the benefit of the distance of time, it is clear to me that
        these things only make sense once you already understand them to
        some degree. But the act of <em>making them</em> is extremely useful
        for solidifying your understanding.
        </p><p>But wait, there&#39;s more!
        </p><p>Both ASCII art diagrams above are just <em>part</em> of the complete
        indirect threaded execution system. They&#39;re just showing how the &#34;inner
        interpreter&#34; works to execute Forth words.
        </p><p>Perhaps you recall from the section about indirect threaded code
        above that the second level of indirection allows different
        &#34;interpreter&#34; routines to execute different types of threaded
        subroutines?  Well, that&#39;s all those two ASCII diagrams are trying
        show.
        </p><p>But when we say that Forth is an <em>interpreted</em> language,
        this is not what we&#39;re talking about. There&#39;s also the &#34;outer interpreter&#34;
        that the programmer interacts with.
    </p></div>
</div>

<div>
    <p>The indirect threaded code is just the tip of the iceberg!
    </p><p><code>nasmjf</code> inner/outer interpreter diagram:
    <img src="https://ratfactor.com/forth/talkimg/forth-diagram.png" alt="my nasmjf diagram showing outer and inner interpreter"/>
    
    </p><div>
        <p>In the vector image I made above for nasmjf, I attempted to map out
        the <strong>whole thing</strong> in my own words.
        </p><p>If you take anything from this image, it&#39;s that
        <code>INTERPRET</code> looks up words (functions) by name and calls
        them by executing the interpreter routine whose address is stored in
        the word (again, this is the indirect threading part). In turn, there
        may be any number of interpreters, but the three main types used in
        JonesForth are:
        </p><ul>
            <li>Pure assembly language routines are their own interpreters.
            </li><li>&#34;Regular&#34; Forth words use the <code>DOCOL</code> interpreter.
                DOCOL executes the rest of the threaded code in the word,
                most of which is just a list of addresses, but some of
                which will be data. This is the &#34;normal&#34; kind of threaded
                subroutine.
            </li><li>Numeric literals have a tiny interpreter routine inline with
                the data that just pushes their value to the stack. Numeric
                literals don&#39;t have to be words, though, in JonesForth,
                they&#39;re just a bit of inlined machine code.
        </li></ul>
        <p>But even knowing this only helps to explain how code <em>starts</em>
        executing. How does this type of Forth know what to run after a word is
        complete?
        </p><p>Ah, for that we have this:
    </p></div>
</div>

<div>
    <p>To get from one <b>code word</b> to another requires a bit of
       assembly pasted at the end of each one. This is
       the <b>NEXT</b> macro. Here it is from <code>nasmjf</code>:
    </p><pre>%macro NEXT 0
    lodsd     ; NEXT: Load from memory into eax, inc esi to point to next word.
    jmp [eax] ; Jump to whatever code we&#39;re now pointing at.
%endmacro
    </pre>

    <div>
        <p>Notice the term &#34;code word&#34;. That&#39;s the Forth term for words
        written in pure assembly language.
        </p><p>Every code word has this macro at the end. (Some Forths actually
        call a subroutine for this. JonesForth uses this two-line macro
        because the action is so efficient in i386 machine code.)
        </p><p>Remember the list of addresses in the explanation of
        &#34;indirect threaded&#34; code? This is how we execute them sequentially.
        </p><p>This implementation uses the i386 <code>lodsd</code> instruction
        to take care of two operations in one: move a &#34;double word&#34;
        from memory into a register, and then update another register
        so that it points to the next &#34;double&#34; spot in memory.
        </p><p><em>(Rant: And a &#34;double&#34; is 32 bits on Intel chips for the really
            annoying reason that they kept the definition of &#34;word&#34; at 16 bits
            even as the platform moved to 32 and then 64-bit architecture. So
            &#34;word&#34; on Intel architectures is a completely meaningless thing
            that you just have to memorize as &#34;16 bits&#34; even though
            &#34;word&#34; is supposed to be the native data size of the architecture.
            And what&#39;s worse is that the tools for working with programs on
            Intel chips like GDB then refer to everything with the
            corresponding C names for everything, which naturally assumed that
            the architecture names would be based on reality. But they aren&#39;t.
            So terms like &#34;double&#34; and &#34;long&#34; are basically just absolutely
            worthless legacy garbage to memorize and useful only to C and Intel
            architecture veterans.)</em>
        </p><p>Okay, so now the <code>eax</code> register points to the next
        threaded subroutine address in memory. The <code>jmp</code> starts
        executing whatever that points to, which will be the &#34;inner interpreter&#34;
        for that subroutine.
        </p><p>Got that?
        </p><p>A lot of moving parts, right?
        </p><p>There&#39;s more:
    </p></div>
</div>

<div>
    <p>To get from one <b>colon word</b> to another uses a bit of
       assembly pasted at the end of each in a chunk called
       the <b>EXIT</b> macro. Here it is from <code>nasmjf</code>:
    </p><pre>DEFCODE &#34;EXIT&#34;,EXIT,0
    POPRSP esi            ; pop return stack into esi
NEXT
    </pre>

    <div>
        <p>Remember, there&#39;s two fundamental types of words in a
        traditional Forth like JonesForth:
        &#34;Code&#34; words and &#34;colon&#34; words.
        Code words are primitives written in  machine code.  Colon words are
        the &#34;regular&#34; words actually written in the Forth language.
        </p><p>These &#34;colon&#34; words (so-named because they are assembled
        via the &#34;COLON&#34; compiler, which we&#39;ll talk about in a moment),
        all end in the so-called <code>EXIT</code> macro.
        </p><p>The <code>EXIT</code> macro handles the return stack.  <em>Then</em>
        there will be a <code>NEXT</code> after that to conclude whatever code
        word primitive we were in (we&#39;re always in at least one because the
        &#34;outer-most&#34; interpreter is a code word primitive!), so the
        process we described above will automatically start where we left off
        at the &#34;call site&#34; of the word we
        just finished executing.
        </p><p>If you weren&#39;t lost before, surely this will do the trick?
        </p><p>I do have another attempt to explain how this all nests in
        a sort of indented pseudocode:
    </p></div>
</div>

<div>
    <p>My comment in <code>nasmjf</code> attempting to explain the
		execution of indirect threaded
        code as a nested
        sequence of <b>NEXT</b> and <b>EXIT</b> and <b>QUIT</b>:
    </p><pre>; QUIT (INTERPRET)
;     * regular word
;         DOCOL
;         NEXT
;         * regular word
;             DOCOL (codeword
;             NEXT
;             * code word
;                 &lt;machine code&gt;
;             NEXT
;             * code word
;                 &lt;machine code&gt;
;             NEXT
;         EXIT
;         NEXT
;    EXIT
;    NEXT
; QUIT (BRANCH -8 back to INTERPRET for more)
    </pre>

    <div>
        <p>This nested view of the process is as close as I&#39;ve ever been to
        explaining (to myself) what the <em>entire</em> execution flow
        looks like at a high level.
        </p><p>I&#39;m sure every Forth implementer has their own mental model.
        </p><p>You&#39;ll notice we didn&#39;t even talk about <code>QUIT</code>.
        Other than the name, that one&#39;s not nearly as bad - it&#39;s really
        just the end of the outer interpreter loop.
        </p><p>(So, yeah, we have <code>EXIT</code> and
        <code>QUIT</code>, neither of which leave Forth... Hey, it was the
        1960s. Things were different then.)
    </p></div>
</div>

<div>
    <p>Absolutely nothing else drives the flow of an indirect
		threaded Forth application: It&#39;s addresses stored in
		registers, a return stack, and a handful of assembly instructions
		at the end of each machine code word jumping to the next instruction.
    </p><p>It&#39;s like a delicate clockwork machine.
</p></div>

<div>
    <p><strong>Don&#39;t you see how simple it is?</strong>
    <img src="https://ratfactor.com/forth/talkimg/crazy_chuck.png" alt="drawing of chuck as crazy charlie explaining a theory with wild eyes and a wall covered in paper and strings"/>

    </p><div>
        <p>Historical note: The above &#34;Crazy Chuck&#34; drawing is a parody of
        a popular meme with actor Charlie Day&#39;s character in the episode
        &#34;Sweet Dee Has a Heart Attack&#34; from the show <i>It&#39;s Always Sunny
        in Philadelphia</i>:
        </p><blockquote>
            &#34;Every day Pepe&#39;s mail&#39;s getting sent back to me. Pepe Silvia, Pepe
            Silvia, I look in the mail, this whole box is Pepe Silvia!&#34;
        </blockquote>
        <p>You, citizen of the distant future, will not have recognized this
        parody, but at least now you can look it up.
    </p></div>
</div>

<div>
    <p>Forth <i>is</i> complex when taken as a whole. But it is made of tiny
        pieces, each of which is <i>very</i> simple. The concept was created
        over a period of years on very constrained systems.
        Each part created only as needed.
    <img src="https://ratfactor.com/forth/talkimg/threaded_code_abstract.png" alt="an abstract drawing of boxes and arrows representing threaded code in memory"/>

    </p><div>
        <p>I&#39;ll repeat your question from before so you don&#39;t have to:
        </p><p><strong>
        &#34;Hey, wait! But if Chuck hates complexity so
        much, why did he use such a complex method for Forth?&#34;</strong>
        </p><p>This is where the historical context is, once again, very revealing:
        </p><p>As we&#39;ve seen, Charles H. Moore did not create Forth all at once in a
        single lightning bolt of inspiration.
        It began as a simple command interpreter and executor and grew
        from there.
        It has always consisted of tiny little parts, working together.
        </p><p><strong>Each of these tiny parts is extremely simple on its own.</strong>
        </p><p>And each was added over a period of time as the need arose.
        </p><p>I think that&#39;s the genius of Forth: That all of these little
        pieces can work together to make a running system and yet <strong>still
        remain independent</strong>.
        You can learn each of these in isolation. You can replace them
        in isolation.
        </p><p><strong>Ultimate flexibility and simplicity at the lowest level of
            the implementation comes at the cost of easy understanding at
            higher levels.</strong>
        </p><p>When growing a system like this, most of us would have thought
        bigger, Moore thought smaller.
        </p><p>Let&#39;s do the same.
        I&#39;ve thrown the terms &#34;code word&#34; and &#34;colon word&#34; around a lot.
        I&#39;ve explained them a bit, but we&#39;ve never given a proper introduction.
        </p><p>Let&#39;s go small:
    </p></div>
</div>

<div>
    

    <div>
        <p>Again, <b>Code words</b> are primitives written in machine language
        supplied by the Forth implementation.
        </p><p>Let&#39;s see some <em>real</em> code words so we can de-mystify them
        once and for all. These are extremely simple
        and extremely concrete examples of actual NASM assembly language source
        from my <code>nasmjf</code> port of JonesForth:
    </p></div>
</div>


<div>
    <p>Small and simple:
    </p><pre>DEFCODE &#34;SWAP&#34;,SWAP,0
    pop eax
    pop ebx
    push eax
    push ebx
NEXT
    </pre>

    <div>
        <p>Is that really SWAP? Yes, it really is! We&#39;re just telling the
        CPU to pop the two most recent values from the stack and then push them
        back in the opposite order.
        </p><p>(JonesForth uses the i386 call/return stack as a Forth parameter
        stack so we can use the native &#34;pop&#34; and &#34;push&#34; to make these
        operations easy. In exchange, we lose the ability to use &#34;call&#34;
        and &#34;ret&#34; for subroutines.)
        </p><p>The <code>DEFCODE</code> macro is housekeeping - it creates the
        entry&#39;s header in the Forth word dictionary.
        </p><p>Notice the <code>NEXT</code> macro we talked about previously?
        Remember, that&#39;s just another two lines of assembly pasted at the
        end of this routine.
    </p></div>
</div>

<div>
    <p>Even Smaller:
    </p><pre>DEFCODE &#34;DUP&#34;,DUP,0
    mov eax, [esp]
    push eax
NEXT
    </pre>

    <div>
        <p>We&#39;re down to just two instructions now! We move the value pointed
        at by the <code>esp</code> register into eax and then push it onto the
        stack.  </p><p>To understand <em>why</em> this duplicates the top item on
        the stack, you need to know how the <code>esp</code> register is used.
        Here&#39;s the relevant comment from the JonesForth source:
        </p><blockquote>
            &#34;In this FORTH, we are using the normal stack pointer (%esp) for the
            parameter stack.  We will use the i386&#39;s &#34;other&#34; stack pointer (%ebp,
            usually called the &#34;frame pointer&#34;) for our return stack.&#34;
        </blockquote>
        <p>Which means that <code>esp</code> points to the current top of 
        the parameter stack. So pushing that value on the stack duplicates
        the top value. (This could also have been written more clearly with
        <em>three</em> instructions: one &#34;pop&#34; and two &#34;push&#34;es.)
    </p></div>
</div>

<div>
    <p>The Smallest:
    </p><pre>DEFCODE &#34;DROP&#34;,DROP,0
    pop eax
NEXT
    </pre>

    <div>
        <p>Now we have an entire Forth word defined as a <em>single</em>
        instruction! DROP just &#34;removes&#34; the top value from the stack. In this
        case, we pop it into the <code>eax</code> register and then don&#39;t do
        anything with it, essentially throwing it away. (Alternatively, we
        could have decremented the <code>esp</code> register, but in this case,
        the &#34;pop&#34; is both shorter <em>and</em> clearer.)
        </p><p>Now let&#39;s see these three words in action in a <em>real</em>
        Forth program that moves some <em>real</em> numbers around
        in memory...
    </p></div>
</div>

<div>
    
    <pre>8 7      <i>8 7</i>
SWAP     <i>7 8</i>
DROP     <i>7</i>
DUP      <i>7 7</i>
    </pre>

    <div>
        <p>The code word primitives we&#39;ve just defined are used by the
        rest of the Forth implementation to define colon words in the
        language itself. If you write Forth applications, your own
        colon words will probably use these heavily.
        </p><p>You can also call them interactively in the interpreter.
        </p><p>The above example shows what it might be like to use these
        three primitives right at the keyboard. The column on the right
        shows the state of the parameter stack after each line of input.
        </p><p>Apart from pushing the two numbers on the stack (<code>8 7</code>)
        , we&#39;ve now seen the assembly language code for the entire
        program shown above. That makes this pretty &#34;bare metal&#34; stuff, right?
        </p><p>Here&#39;s the walk-through:
        </p><ul>
            <li>We start with 8 and then 7 on the top of the stack.
            </li><li>SWAP reverses the order of the stack so 8 is now on the top.
            </li><li>DROP pops the 8 and throws it away. Now only 7 remains.
            </li><li>DUP pushes a second copy of 7 onto the top of the stack.
        </li></ul>
        <p>Again, these instructions could exist in the definition of a word or
        you could type them interactively in the running Forth interpreter.
        The result is the same.
        </p><p>I think there&#39;s something pretty magical about realizing that
        typing these instructions is running specific machine code
        sequences exactly as they were entered. In this implementation,
        there&#39;s no optimizing compiler or virtual machine acting as middle-man.
        You really are communicating directly with the processor.
    </p></div>
</div>

<div>
    <p><code>nasmjf</code> has 130 code words. Mostly for efficiency.

    </p><div>
        <p>If you weren&#39;t already wondering, perhaps you are now:
        How many Forth words need to be defined in machine code
        to have a &#34;bootstrappable&#34; Forth system?
        </p><p>There are some theoretical minimums. But as you get down to an
        absurdly small number of instructions, the Forth code written with the
        primitives (to implement the rest of the language) approaches absurdly
        large amounts of convolutions that test the limits of both programmer
        ergonomics and computational inefficiency.
        </p><p>Check out this amazing article by Frank Sergeant:
        <a href="https://pygmy.utoh.org/3ins4th.html">A 3-INSTRUCTION FORTH FOR EMBEDDED SYSTEMS WORK</a>
        (utoh.org).
        </p><blockquote>&#34;How many instructions does it take to make a Forth for
            target development work? Does memory grow on trees? Does the cost
            of the development system come out of your own pocket? A 3-
            instruction Forth makes Forth affordable for target systems with
            very limited memory. It can be brought up quickly on strange new
            hardware. You don&#39;t have to do without Forth because of memory or
            time limitations. It only takes 66 bytes for the Motorola MC68HC11.
            Full source is provided.&#34;
        </blockquote>
        <p>You read that right: <strong>66 bytes</strong>.
        </p><p>And later:
        </p><blockquote>&#34;The absolute minimum the target must do, it seems to me,
            is fetch a byte, store a byte, and call a subroutine. Everything
            else can be done in high-level Forth on the host.&#34;
        </blockquote>
        <p>Which reminds me, did you know there is such a thing as a
        <a href="https://en.wikipedia.org/wiki/One-instruction_set_computer">one-instruction set computer</a>
        (wikipedia.org)?
        And <em>of course</em> you can run Forth on them:
        <a href="https://github.com/howerj/subleq">16-bit SUBLEQ eForth</a>
        (github.com).
        </p><p>But that&#39;s nuts.
        </p><p>How about something a little more realistic?
    </p></div>
</div>

<div>
    <p><code>sectorforth</code> has 10 code words.

    </p><div>
        <p>Cesar Blum&#39;s
        <a href="https://github.com/cesarblum/sectorforth">sectorforth</a>
        (github.com)
        is:
        </p><blockquote>&#34;...a 16-bit x86 Forth that fits in a 512-byte
            boot sector. Inspiration to write sectorforth came from a
            1996 Usenet thread.&#34;
        </blockquote>
        <p>See? There&#39;s Usenet again. It wasn&#39;t just me reading all that lore.
        </p><p>The author&#39;s
        <a href="https://old.reddit.com/r/Forth/comments/j0lxgq/sectorforth_a_16bit_x86_forth_that_fits_in_a_boot/">posting of the project to the Forth sub-reddit</a>
        (reddit.com)
        has additional insight:
        </p><blockquote> &#34;I&#39;ve always been fascinated by the idea of having a
            minimal kernel of primitives from which &#34;everything&#34; can be built.
            Before Forth, I had only seen that in the form of Lisp&#39;s &#34;Maxwell
            equations of software&#34;, which is cool, but always left me a little
            disappointed because it is too abstract to build something that you
            can actually interact with - you can&#39;t break out of its esoteric
            nature...
            </blockquote>
        <p>Note: The statement about Maxwell&#39;s equations surely refers to
        Alan Kay&#39;s famous quote about LISP from
        <a href="https://queue.acm.org/detail.cfm?id=1039523">A Conversation with Alan Kay</a>
        (acm.org):
        </p><blockquote>
            &#34;Yes, that was the big revelation to me when I was in graduate
            school - when I finally understood that the half page of code on
            the bottom of page 13 of the Lisp 1.5 manual was Lisp in itself.
            These were &#34;Maxwell&#39;s Equations of Software!&#34; This is the whole
            world of programming in a few lines that I can put my hand over.&#34;
        </blockquote>
        <p>Okay, so we&#39;ve talked about <b>code words</b>
        that are just chunks of machine code that can be called upon
        at any time.
        </p><p>Now let&#39;s see what <b>colon words</b> are all about...
    </p></div>
</div>

<div>
    
    <p>Let&#39;s make one:
    </p><pre>: SDD SWAP DROP DUP ;
    </pre>

    <div>
        <p>A colon word is so-named because its definition begins with the
        &#34;<code>:</code>&#34; character.
        </p><p>The example colon word definition above creates a new word called
        <code>SDD</code> that is a composition of the three code words we
        defined earlier: <code>SWAP</code>, <code>DROP</code>, and
        <code>DUP</code>.
        Perhaps the word &#34;composition&#34; brings to mind the concatenative
        terminology we explored earlier in this quest?
        </p><p>As this example demonstrates, colon words are defined entirely
        by other words, which may be code words or other colon words.
        You can also have numeric values, e.g. 8 and 7, which
        are handled by the interpreter.
        </p><p>(You can also have strings, which looks like data...but those are
        just input that happens to follow one of the special words, e.g.
        <code>.&#34;</code> (dot quote), that knows how to handle the input!)
        </p><p>Let&#39;s see it in action:
    </p></div>
</div>

<div>
    <pre>8 7      <i>8 7</i>
SDD      <i>7 7</i>
    </pre>

    <div><p>
        The effect of calling our new <code>SDD</code> word is, of course,
        identical to calling the three separate words <code>SWAP</code>,
        <code>DROP</code>, and <code>DUP</code> in sequence.
        </p><p>In <b>indirect threaded code</b> terms,
        this colon word has been &#34;compiled&#34; into the addresses of
        the &#34;inner interpreters&#34; for each of the three code words.
        But feel free to ignore this detail!
        </p><p>Let&#39;s demystify this further because the Forth &#34;compiler&#34; is
        probably much, much simpler than you&#39;d think:
    </p></div>

<div>
    
    <p>Here&#39;s what really happens when we enter this:
    </p><pre>: SDD SWAP DROP DUP ;
    </pre>
	<p>Colon (<code>:</code>) fetches the word name (SDD) and sets &#34;compile mode&#34;.
	</p><p>Semicolon (<code>;</code>) completes the word&#39;s entry in the <b>dictionary</b> and unsets &#34;compile mode&#34;.
    
    </p><div>
        <p>It might still be surprising that &#34;:&#34; is a Forth word.
        </p><p>It looks like the sort of thing we would call &#34;syntax&#34; in other
        programming languages, but it really isn&#39;t. It&#39;s a word.
        </p><p>You can even <em>replace</em> &#34;:&#34; with your own definition
        to extend or alter Forth to do your bidding!
        </p><p>It may be hard to fully grasp for a while, but
        Forth&#39;s <em>only</em>
        syntax is the whitespace between tokens of input.
        </p><p><i>Tokens are tokenized by a word called &#34;WORD&#34;, which is an
            incredibly confusing overload of the term. Sorry.</i>
        </p><p>(You&#39;ll also notice I&#39;ve mentioned the term &#34;dictionary&#34; a couple
        times now. It&#39;s kind of obvious that a dictionary can hold words, but
        I haven&#39;t properly explained the Forth dictionary yet. Don&#39;t worry,
        we&#39;re almost there.)
        </p><p>Okay, so &#34;<code>:</code>&#34; switches the &#34;outer interpreter&#34; into
        compile mode and <code>;</code> switches it back. But what does
        <em>that</em> mean?
    </p></div>
</div>

<div>
    <p><b>&#34;Compiling&#34;</b> in Forth means putting one of two things into memory:
	</p><ul>
		<li>The address of a word, or
		</li><li>A value literal and a bit of code that pushes it on the stack
	</li></ul>
    <p>At its simplest, compiling is just like executing, but we&#39;re <em>storing</em>
	addresses instead of jumping to them.

    </p><div>
        <p>Actually, that&#39;s understating the elegance and simplicity of how this
        works, which is one of the most mind-blowing things in Forth.
        </p><p>Forth uses the <em>same</em> interpreter to both compile
        and execute code!
        </p><p>In a traditional Forth, the interpreter executes words as you
        enter them. Unless you&#39;re in &#34;compile mode&#34;, <em>then</em> it is
        compiling those words as addresses into memory <em>on the fly</em>
        as you enter them.
        </p><p>It&#39;s straight from the keyboard to memory.
        </p><p>To make this concrete, let&#39;s step through the example.
        </p><p>Here&#39;s our definition again:
        </p><pre>: SDD SWAP DROP DUP ;
        </pre>
        <p>In &#34;normal mode&#34;, the interpreter is executing everything as we enter it.
        </p><p>When the interpreter encouters the &#34;<code>:</code>&#34; word, we&#39;re
        still in &#34;normal mode&#34;, so it looks &#34;<code>:</code>&#34; up in the
        dictionary, finds it, and executes the word. The definiton of
        &#34;<code>:</code>&#34; will collect the name &#34;SDD&#34; and turn on the &#34;compile
        mode&#34; switch.
        </p><p>Now when the interpreter hits the &#34;<code>SWAP</code>&#34; word, it will
        look up its address in the dictionary as usual, find it, and
        store the address in the next available memory slot where we
        compile new words (a very important built-in variable called
        &#34;<code>HERE</code>&#34; keeps track of this memory position).
        </p><p>The same thing happens for &#34;<code>DROP</code>&#34; and &#34;<code>DUP</code>&#34;.
        We&#39;re compiling as fast as we can type!
        </p><p>Then a bunch of really interesting things happen when the interpreter
        gets to &#34;<code>;</code>&#34; (SEMICOLON).
        </p><p>First, &#34;<code>;</code>&#34; is looked up and found in the dictionary and
        then...Hey, wait!
        Why isn&#39;t the address of the &#34;<code>;</code>&#34; word
        <em>also</em> compiled into our new definition? <strong>That&#39;s a
            great question!</strong>
        </p><p>Time for another trick. One of the flags stored in a word&#39;s
        dictionary entry is the &#34;immediate&#34; flag. When this flag is turned on,
        the word is always executed immediately
        <em>even in compile mode</em>.
        The &#34;<code>;</code>&#34; word is an immediate word, so it executes instead
        of being compiled.
        </p><p>(Ready to have your head turned inside-out? There are <em>also</em>
        tricks for <em>compiling</em> immediate words into word definitions!
        It&#39;s simple enough, but still pretty mind-bending stuff when you first
        encounter it.)
        </p><p>The definition of &#34;<code>;</code>&#34; turns off compile mode. Then it
        does some housekeeping to complete the entry of the new
        <code>SDD</code> word in the dictionary.
        </p><p>As soon as &#34;<code>;</code>&#34; returns control to the outer
        interpreter, we&#39;re now sitting in normal mode again and our new
        <code>SDD</code> word is available to be called directly or compiled
        into <em>other</em> words.
        </p><p>See what I mean? It&#39;s all made of these tiny little parts.
        </p><p>Each part is incredibly simple, but trying to explain how the
        parts fit together takes paragraphs of text.
        </p><p>Speaking of simple...
    </p></div>
</div>

<div>
    
    <p>The tiny set of rules that govern the interpreter:
    </p><ul>
        <li>WORD gets a token.
        </li><li>Is it in the dictionary? <i>(And are we compiling?)</i>
        </li><li>Is it a numeric literal? <i>(And are we compiling?)</i>
        </li><li>Otherwise, error!
    </li></ul>
    <p>Let&#39;s look at our example code again. The first line
    runs, the second line compiles:
    </p><pre>8 7 SWAP DUP +

: SDP SWAP DUP + ; 8 7 SDP
    </pre>

    <div>
        <p>It would be annoyingly redundant to walk through the two lines of
        Forth above step-by-step because they are nearly identical. The only
        difference is that the first line simply executes each word as it is
        encountered (SWAP, DUP, +). The second line compiles those three words
        into a new word called SDP (for &#34;Swap Dup Plus&#34;). The result of both
        lines is the same.  (7 and 16 on the stack).
        </p><p>Only the numbers (8 and 7) and the spaces separating words have
        <em>any</em> special meaning to Forth&#39;s &#34;outer&#34; interpreter.
        Everything else is looked up in the dictionary.
        </p><p>Ah, but did you notice the order of the bullet points above?
        We check to see if a token is in the dictionary <em>before</em>
        we check to see if it is a numeric literal.  Yes, even numbers are
        looked up in the dictionary first! Does that perhaps give you any ideas
        about that <em>magic trick</em> I promised at the start of this article?
        Don&#39;t worry, the trick is forthcoming.
        </p><p>Furthermore, input is not returned to the main Forth &#34;outer&#34;
        interpreter until a dictionary word completes executing. So there is
        absolutely <strong>no limit</strong> to the types of
        <a href="https://en.wikipedia.org/wiki/Domain-specific_language">domain-specific language</a>
        (wikipedia.org)
        you can create.
        </p><p>And if that weren&#39;t enough, You can also replace every single piece
        of the Forth interpreter itself. Remember, they&#39;re all independent little
        cogs in the machine. Forth is the ultimate freedom.
        </p><p>I&#39;ve alluded to this in several different ways above, but I&#39;ll make
        a bold claim:
        <strong>Forth has the simplest syntax and therefore the simplest
        parser, interpreter, and compiler <em>ever</em> used in a &#34;mainstream&#34;
        general-purpose programming language.</strong>
        </p><p>Two other languages previously mentioned, Lisp and Tcl, are also
        famously syntactically minimalistic languages. People have
        written incredibly tiny implementations of each:
        </p><ul>
            <li>Lisp: <a href="https://github.com/jart/sectorlisp">sectorlisp, a 512-byte implementation of LISP</a> (github.com/jart)
            </li><li>Tcl: <a href="http://oldblog.antirez.com/post/picol.html">picol, a Tcl interpreter in 550 lines of C code</a> (antirez.com)
        </li></ul>
        <p>Mind you, both of these people (Justine &#34;jart&#34; Tunney and Salvatore
        &#34;antirez&#34; Sanfilippo) are incredible programmers, but these examples
        hint at what is possible.
        </p><p>But Forth surely takes the cake. Even a certified non-genius
        like myself can write an entire Forth interpreter in a
        couple hundred assembly instructions. (See &#34;Meow5&#34; below.)
        </p><p>Because of its extreme simplicity, tokenizing Forth can be done in
        a mere handful of assembly instructions on many processors.
        </p><p>And as mentioned, once you&#39;ve written a Forth interpreter, you&#39;re
        well on your way to a working Forth compiler.
        </p><p>I&#39;ve alluded to Forth&#39;s flexibility and extensibility on several
        different occasions now. But this is no mere party trick. Forth
        relies on the fact that you can do anything in Forth.
        </p><p>In the next example, we&#39;ll see how Forth implements control structures.
    </p></div>
</div>

<div>
    <p>The definition of <b>IF...THEN</b> from jonesforth.f:
    </p><pre>: IF IMMEDIATE &#39; 0BRANCH , HERE @ 0 , ;

: THEN IMMEDIATE DUP HERE @ SWAP - SWAP ! ;
    </pre>

    <div>
        <p>This right here is one of the most mind-blowing things about Forth,
        and a solid reason to title this, &#34;The programming language that writes
        itself.&#34;
        </p><p>Even something as fundamental as <code>IF</code> is defined in
        the language! Forth is not the only language that can do this, but
        few languages invite the programmer to participate so thoroughly
        in the inner workings as often or as joyfully as Forth.
        </p><p>Figuring out how the IF and THEN definitions above actually
        work is left as an exercise for the reader, but here&#39;s a brief
        explanation of the new words they use:
        </p><pre><b>&#39;</b>       - gets the address of the word that follows, put on stack
<b>0BRANCH</b> - branch to the next value if the top of the stack has 0
<b>,</b>       - &#39;compile&#39; the current stack value to the memory at HERE
<b>@</b>       - fetch value from address on stack, put value on stack
<b>!</b>       - store to memory (stack contains address, then value)
        </pre>
        <p>(By the way, I&#39;ll go on the record to say this: The
        early parts of bootstrapping Forth in Forth (at least
        the top 25% of jonesforth.f) is <em>significantly</em> more
        mind-bending than implementing the low-level code word definitions
        written in assembly language. In fact, any time I needed to return to
        the assembly, it was like a comforting blanket of simplicity compared
        to the logic puzzle of those Forth-in-Forth primitives!)
        </p><p>But, even seeing control structures like <code>IF..THEN</code>
        implemented in the language may not have prepared you for seeing this
        next trick.
        </p><p>This should drive home the fact that Forth has almost no native
        syntax:
    </p></div>
</div>

<div>
    <p>The definition of <b>( )</b> <i>nested comments</i> from jonesforth.f:
    </p><pre>: ( IMMEDIATE
    1
    BEGIN
        KEY DUP &#39;(&#39; = IF DROP 1+
        ELSE &#39;)&#39; = IF 1- THEN
        THEN
    DUP 0= UNTIL
    DROP
;

(
    From now on we can use ( ... ) for comments.
...
    </pre>

    <div>
        <p>Yeah, you read that right. Even <em>comments</em> are implemented
        in the language! And you can re-define them or add your own kind of
        comments!
        </p><p>Some of you are soiling yourselves in excitement right now.
        Some of you are soiling yourselves in fear.
        We&#39;re all just sitting here in our own filth now.
        </p><p>And now, at last, we are ready to discuss the power of the Forth
        dictionary.
    </p></div>
</div>

<div>
    
	<p>A Forth dictionary traditionally uses a linked list.
    </p><p>Word matching is done starting from the <em>end</em>
    (most recent entries) first, so:
	</p><ul>
		<li>You can redefine <i>any</i> word, even the ones originally
			defined in assembly!
		</li><li>Words depending on previous definitions of redefined words
            won&#39;t break because the compiled addresses still point to
            the original word, not the new definition!
		</li><li><i>You</i> are in complete control!
		</li><li>Again, Forth = freedom!
	</li></ul>

    <div>
        <p>It&#39;s not <em>just</em> minimalistic syntax. Arguably, the
        <em>real</em> reason Forth is so extensible is because of
        the dictionary.
        </p><p>As mentioned in the points above, more recent word definitions
        override older ones with the same name - the interpreter stops at the
        first match.
        </p><p>But as mentioned above, existing compiled words that use the
        <strong>old definitions</strong> are not affected because 
        <em>name</em> of the old word, they&#39;ve stored the <em>address</em>.
        The address of the old word still points to the old word.
        </p><p>You don&#39;t have to strictly replace. You can <em>extend</em>
        words by calling the original word from a new one with the same name!
        </p><p>You are perhaps wondering what happens if
        you attempt to make a <strong>recursive word</strong>. By
        default, &#39;:&#39; (COLON) marks the word currently being compiled into the
        dictionary as hidden or disabled so that previous definitions can be
        called, as mentioned.
        This is why we have a word called RECURSE which inserts a
        call to the current word within itself. Because all information
        in Forth is global (including the address of the current word being
        compiled, defining RECURSE is incredibly simple (just four words in the
        JonesForth definition).
        </p><p>Besides making new control structures or other types of extensions
        to the language, what else can we do with these abilities?
    </p></div>
</div>

<div>
	<p><img src="https://ratfactor.com/forth/talkimg/apple_bw.png" alt="grayscale apple"/></p><p>It&#39;s not just the language itself that is unusually malleable.
    <strong>Your program written in Forth can be flexible too.</strong>
	</p><p>Here is an example lifted and paraphrased from <i>Thinking Forth</i>
    by Leo Brodie.
    </p><p>Say we create a variable to hold a number of apples:
	</p><pre>VARIABLE APPLES
20 APPLES !
APPLES ? <i>20</i>
	</pre>
	<p>Forth variables put <i>addresses</i> on the stack.

	</p><div>
		<p>Note: I have a physical copy of <i>Thinking Forth</i> because
        I think it&#39;s great. But the publishers have kindly made it available
        for free online:
		<a href="https://www.forth.com/wp-content/uploads/2018/11/thinking-forth-color.pdf">Thinking Forth (PDF)</a>
        (forth.com)
        </p><p>Let&#39;s walk through the three lines above. Here&#39;s the first line:
        </p><pre>VARIABLE APPLES
        </pre>
        <p>The VARIABLE word creates a new spot in free memory. <em>Then</em>
        it creates a new word in the dictionary called APPLES that pushes that
        particular memory address on the stack when it is called.
        </p><p>(Note that like &#34;:&#34;, &#34;VARIABLE&#34; is grabbing the next token of input
        for use as a new dictionary name. This is possible because &#34;the little
        cogs in the Forth machine&#34; are available for any use you can think of.
        And one of those cogs is the word WORD, which gets the next token from
        the input stream. Both &#34;:&#34; and &#34;VARIABLE&#34; use WORD to do this, just like
        Forth&#39;s own outer interpreter!)
        </p><p>Okay, so we have a variable named APPLES now. The next line is:
        </p><pre>20 APPLES !
        </pre>
        <p>This puts the value 20 on the stack, then the address for APPLES.
        The &#34;!&#34; (STORE) word stores the value 20 at the APPLES address.
        (In other words, &#34;!&#34; takes <em>two</em> values as input: an address and
        a value.  It stores the value at that address.)
        </p><p>Conceptually, you can think of the above as <code>APPLES = 20</code>
        in &#34;normal&#34; programming syntax.
        </p><p>And now the third line:
        </p><pre>APPLES ?
        </pre>
        <p>This line prints the value stored at APPLES. The word &#34;?&#34; fetches a
        numeric value from an address and prints it (which pops the value off
        the stack again).  Again, APPLES puts its address on the stack. So &#34;?&#34;
        simply takes an address from the stack as input for printing.
        </p><p>By the way, here&#39;s the entire definition of &#34;?&#34; in JonesForth:
        </p><pre>: ? @ . ;</pre>
        <p>Look at how small that is! The only thing you need to know to
        understand this definition is that &#34;@&#34; (FETCH) pops an address from the
        stack and fetches the value stored at that address and puts the value
        on the stack.  &#34;.&#34; (DOT) pops a value from the stack and prints it as a
        number.
        </p><p>Okay, on with our example.
        </p><p>We&#39;re about to be dealt a terrible blow...
	</p></div>
</div>

<div>
	<p>We pepper our program with this <b>APPLES</b> variable.
    </p><p>The application works perfectly for a couple years.
	</p><p>Then we are told that we must now keep track of two different
		kinds of apples: red and green. What to do?
	</p><p><img src="https://ratfactor.com/forth/talkimg/apple_red.png" alt="red apple"/>
		<img src="https://ratfactor.com/forth/talkimg/apple_green.png" alt="green apple"/>
	</p>

    <div>
        <p>Unfortunately, this is exactly the sort of conundrum we see in real
        life software all the time.
        </p><p>You knowingly prepared for all sorts of different <em>quantities</em>
        of apples, but it never occurred to anyone that we would need to
        track different <em>types</em> of apples.
        </p><p>This problem seems very bad. Do we have to completely re-write our
        application?
        </p><p>(Well, <em>outside</em> of this example, the correct answer might be
        &#34;yes&#34;.  Maybe this changes the whole &#34;theory&#34; of the program, in the
        <a href="http://ratfactor.com/papers/naur1">Programming as Theory Building</a>
        (ratfactor.com)
        sense. In which case, a re-write or big refactor of our apple counting
        program is likely the right answer. But for this example, we&#39;re
        assuming that we have <strong>thousands of lines</strong> of
        apple-handling functionality that will <strong>not</strong> need to
        change. We&#39;ll say that grouping the apples by color here is just an
        essential surface detail.)
        </p><p>All right, <em>obviously</em> we can&#39;t store two values in one
        variable and expect all of the existing code to still work. So what
        could we possibly do?
        </p><p>Here&#39;s a very clever and very Forth solution:
    </p></div>
</div>

<div>
    <p>A new variable will store the current type of apples.
	</p><pre>VARIABLE COLOR
	</pre>

    <div>
        <p>As with &#34;APPLES&#34; above, VARIABLE creates a memory space and a new
        word called &#34;COLOR&#34; that puts the address of the memory space on the
        stack when it is called.
        </p><p>Next, we&#39;ll create a second new variable <em>and</em> a new colon word.
    </p></div>
</div>

<div>
	<p><img src="https://ratfactor.com/forth/talkimg/apple_red.png" alt="red apple"/></p><p>&#34;REDS&#34; will count red apples. 
    Colon word &#34;RED&#34; sets the current type of apple to red:
    COLOR = REDS:
	</p><pre>VARIABLE REDS
: RED REDS COLOR ! ;
	</pre>

    <div>
        <p>Remember, variables are also words in the dictionary, so we&#39;ve
        created three additional words so far: COLOR, REDS, and RED.
        </p><p>(Only one of these, RED, is <em>recognizably</em> a function.
        But really all three of them are.)
        </p><p>As you may recall from earlier, &#34;!&#34; (STORE) takes two parameters,
        a value and an address, and stores the value at that address.
        </p><ul>
            <li>COLOR is the address of memory holding the address of the current apple count variable
            </li><li>REDS is the address of memory holding the red apple count
            </li><li>RED sets COLOR to the address of REDS
        </li></ul><p>
        It might be helpful to see the C equivalent of the RED word:
        </p><pre>void RED(){
    COLOR = &amp;REDS
}
        </pre>
        <p>And then...
    </p></div>
</div>

<div>
	<p><img src="https://ratfactor.com/forth/talkimg/apple_green.png" alt="green apple"/></p><p>Same for green.
	</p><pre>VARIABLE GREENS
: GREEN GREENS COLOR ! ;
	</pre>

    <div>
        <p>We&#39;ve added a total of five new words. The two new green ones
        are identical to the red ones above:
        </p><ul>
            <li>GREENS is the address of memory holding the green apple count
            </li><li>GREEN sets COLOR to the address of GREENS
        </li></ul>
        <p>Here&#39;s the C equivalent of GREEN:
        </p><pre>void GREEN(){
    COLOR = &amp;GREENS
}
        </pre>
        <p>One more change...
    </p></div>
</div>

<div>
	<p>Lastly, we change <b>&#34;APPLES&#34;</b> from a variable to a word that gets
    the current count by color:
	</p><pre>: APPLES COLOR @ ;
	</pre>

    <div>
        <p>As you may recall from earlier, &#34;@&#34; (FETCH) fetches the value
        stored in a variable and puts it on the stack.
        </p><p>So &#34;APPLES&#34; gets the value stored in COLOR and puts that
        on the stack.
        </p><p>The value stored in COLOR <em>happens to be an address</em>.
        That address happens to be the memory pointed to by either REDS or
        GREENS.
        </p><p>It would look like this C code:
        </p><pre>int *APPLES(){
    return COLOR;
}
        </pre>
        <p>This &#34;get the address of the address&#34; stuff may sound super
        confusing. But working with memory addresses (aka &#34;pointers&#34;) is
        <em>how variables work</em> in Forth, so to the adept Forth programmer,
        the idea of passing addresses around will be deeply ingrained and
        <em>no big deal</em>.
        </p><p>Okay, so we&#39;ve got red and green apple counts. That much
        is clear. But surely there is still a lot of work ahead of us...
    </p></div>
</div>

<div>
    <p>Now we have to re-write any use of <b>APPLES</b>, right?
    </p><p>Wrong! The use of <b>APPLES</b> is <i>identical</i>. The syntax hasn&#39;t
        changed one bit for any existing code. We just need to make sure we&#39;ve
        set the right color.
    </p><p>Check it out:
	</p><pre>20 RED APPLES !
30 GREEN APPLES !

GREEN APPLES ? <i>30</i>
APPLES ? <i>30</i>

RED
APPLES ? <i>20</i>
	</pre>
	<p><img src="https://ratfactor.com/forth/talkimg/apple_bw.png" alt="grayscale apple"/>
		<img src="https://ratfactor.com/forth/talkimg/apple_red.png" alt="red apple"/>
		<img src="https://ratfactor.com/forth/talkimg/apple_green.png" alt="green apple"/>
	</p>

    <div>
        <p>All of the existing code that uses APPLES will still work 
        <em>exactly the same way</em> with absolutely no modifications.
        </p><p>Furthermore, look at how English-like it reads to store
        <code>&#34;20 RED APPLES !&#34;</code> or query <code>&#34;GREEN APPLES ?&#34;</code>.
        </p><p>The key to understanding why this works is to remember that
        &#34;APPLES&#34; was <em>already</em> a word that put an address on the stack
        because <em>that&#39;s how variables work</em> in Forth.
        So when we changed it to a colon word that puts an address on the
        stack, it&#39;s no change at all. It&#39;s still doing the exact same thing.
        It just happens that the address will change depending on the active
        apple color.
        </p><p>At every single opportunity, Forth has taken the simplest
        (you might even say, <em>laziest</em>) and most flexible method
        for implementing a feature.
        </p><p>Wait, I hear a distant screaming:
        </p><p><em>&#34;How could this possibly be okay?! You call this &#39;freedom&#39;, but
            I call it unchecked chaos material! This is not okay!&#34;</em>
        </p><p>Well, maybe.
        </p><p>But I think one reason this actually <em>is</em> okay, on a
        conceptual level, is that APPLES did <em>not</em> really change
        what it originally did.
        </p><p>Coming from the normal programming language world, we have clearly
        <strong>broken the abstraction</strong>:
        &#34;APPLES&#34; was a variable before, and now it&#39;s a function.
        </p><p>But you&#39;re not in the normal programming world anymore.
        Here, in Forth-land, a variable <em>is</em> a word that puts an
        address on the stack. And a function is <em>also</em> just a word.
        </p><p>&#34;APPLES&#34; is <em>still</em> a word that puts an
        address on the stack. There is no <em>conceptual</em> change at the
        language level. <strong>We did not break an abstraction because there
        was no abstraction to break.</strong>
        </p><p>Forth provides what you might call &#34;atomic units of computing&#34;
        at the language level.  It is a language where <em>you</em> make the
        abstractions.
    </p></div>
</div>

<div>
    <center>
    <img src="https://ratfactor.com/forth/talkimg/apple_bw.png" alt="grayscale apple"/>
    </center>
    <p>To Forth, it&#39;s all just words in a dictionary.
    &#34;VARIABLE&#34; is just another word
    <em>you could have written yourself</em>.

    </p><div>
        <p>Do you see now why Chuck Moore rejects the standardization
        of Forth? It ossifies concepts like VARIABLE so they lose their
        flexibility.
        </p><p>The example above is also another demonstration of the way
        the language Forth &#34;writes itself&#34;: a tiny handful of primitives can be
        used to bootstrap the rest of the language in the language itself.  The
        enormous flexibility of the primitives allows nearly unbounded freedom.
    </p></div>
</div>

<div>
    
    <p>I highly recommend implementing Forth (or porting it like I did) to understand
    how it works &#34;under the hood.&#34;

    </p><div>
        <p>By examining Forth from the ground floor at the assembly language level,
        I gained considerable confidence in my understanding of how all the moving
        parts fit together.
        </p><p>To be honest, it&#39;s difficult for me to imagine being to able to understand all the
        individual parts <em>without</em> going through this process. But everybody learns
        differently.
    </p></div>

    <h2>But be aware of what this will <em>not</em> teach you</h2>
    <p>Implementing an interpreter teaches you almost nothing about how
    to write programs with that interpreter.

    </p><div>
        <p>Knowing how a Forth system works is almost completely unrelated
        to knowing how to <em>write programs</em> in Forth.
        </p><p>You can know the spec for a language by heart, but still be clueless
        about writing good software in that language. It&#39;s like expecting a
        mastery of English grammar to make you a good novelist. They&#39;re entirely
        different skills.
        </p><p>Be also aware that most people on the Internet (including myself) are
        still complete newbies to actually creating software with Forth!
    </p></div>
</div>

<div>
    
    <p>&#34;I didn&#39;t create Forth, I discovered it.&#34;
    </p><p>-- Chuck, apocryphally

    </p><div>
        <p><em>(I have been unable to find a source for the quote above.
        It probably comes from an interview.)</em>
        </p><p>If Forth truly is a fundamental way to express computation, then
        it&#39;s sort of like 
        Gödel and Herbrand&#39;s general recursive functions, Church&#39;s lambda
        calculus, Turing&#39;s theoretical machines, Post&#39;s canonical systems, and
        Schönfinkel and Curry&#39;s combinators.
        (I can hear furious objections warming up from a thousand armchairs...)
        </p><p>In fact, that&#39;s true of <em>all</em> programming languages, even the
        big, messy ones. Right? Any language that can express universal
        computation is...universally powerful; it can express anything
        that is computable.
        </p><p>But I think Forth belongs to a more rarified group.  Forth is a
        fundamental <em>type</em> of programming language design.
        And I&#39;m not alone in thinking so. For example, check out
        <a href="https://madhadron.com/programming/seven_ur_languages.html">The seven programming ur-languages</a>
        (madhadron.com).
        </p><p>I&#39;ll let philosophers angrily split hairs over what I just said above,
        but I think the principle is true. And it&#39;s true all the way down
        to the (lack of) syntax in the language.
        </p><p>Why do I believe this? Well...
    </p></div>
</div>

<div>
    <p>Making <code>nasmjf</code> gave me so many ideas, I <i>had</i> to try some
        experiments.
    </p><p>Forth is an amazing playground for ideas.

    </p><div>
        <p>I was still keenly aware that my <code>nasmjf</code> project to
        port JonesForth to NASM was still just a (very detailed) examination of
        a <strong>final artifact</strong>. I was not re-tracing Moore&#39;s footsteps, but
        imitating his work. In fine art terms, I made a &#34;master copy&#34; (training myself by
        copying the work of a master artist). In other words, I brought
        my sketchbook to the museum.
        </p><p>But what would happen if I tried making a painting of my very own?
    </p></div>
</div>

<p><img src="https://ratfactor.com/forth/talkimg/assembly-nights2.jpg" alt="my lenovo 11e thinkpad with assembly code waiting romantically on the bed with a candle. text reads &#39;Assembly Nights II&#39;"/>
</p>

<div>
    
	<p><img src="https://ratfactor.com/forth/talkimg/meow5.png" alt="meow5 cat logo"/></p><p>An exercise in extreme <b>concatenative</b> programming where
		all code is concatenated (always inlined).

    </p><div>
        <p>We explored what it means to be a &#34;concatenative&#34; programming language
        at the beginning of my journey above. In short, in a concatenative
        language, data implicitly flows from one function to another like a
        factory assembly line.
        </p><p>Like Forth, Meow5 happens to be concatenative because it uses
        the same &#34;parameter stack&#34; concept.
        </p><p>Unlike Forth or most other sane languages, <strong>Meow5 is a thought
        experiment taken too far</strong>. Specifically, the thought,
        &#34;instead of threading function calls by storing their addresses, what
        if we just store a copy of the whole function?
        </p><p>In compiler parlance, this is &#34;inlining&#34;, short for
        <a href="https://en.wikipedia.org/wiki/Inline_expansion">inline expansion</a>
        (wikipedia.org).
        It is a common optimization technique
        for avoiding the overhead of a function call for small functions.
        </p><p>Let&#39;s use the word DROP for example.  Remember when we looked at the
        assembly language source of the DROP code word? It was just a single
        assembly instruction:
        </p><pre>pop eax
        </pre>
        <p>It would be incredibly silly to have several jumps to and from
        a single-instruction word!
        </p><p>(And, it comes as no surprise that
        &#34;real&#34; Forth implementations often inline small primitives such
        as DROP. Some even provide an INLINE word to allow the programmer
        to specify this explicitly.)
        </p><p>My question was: What if we do that for everything?
        At what point is this no longer a good idea?
        Obviously at <em>some</em> point, a function is too large to inline.
        But every code word in JonesForth 
        was quite tiny by modern standards. With today&#39;s CPUs and their
        relatively enormous caches it seemed to me that you could take
        this inlining concept pretty far before it got ridiculous.
        </p><p>And wouldn&#39;t the CPU just love seeing all of those instructions
        executing in one straight and continuous sequence with no jumps?
        If I were a CPU, I would love it.
        </p><p>Plus, it would make compiling a stand-alone executable almost
        trivial because <em>every word</em> in a 100% inlined language
        would contain <em>all</em> of the machine code needed for that
        word.
        </p><p>Here is the canonical example:
    </p></div>
</div>

<div>
	<pre>: meow &#34;Meow.&#34; print ;
meow
<i>Meow.</i>

: meow5 meow meow meow meow meow ;
meow5
<i>Meow.Meow.Meow.Meow.Meow.</i>
	</pre>

    <div>
        <p>The idea is that <code>meow5</code> compiles into five complete
        copies of <code>meow</code>!
        </p><p>This example seems to be obviously naughty and wasteful. But I&#39;m
        not a superscalar, out-of-order executing modern processor and neither
        are you. So the question remains: At what point does having a
        child function which includes a complete copy of every parent and
        grandparent and every ancestor function all the way back to the
        beginning spiral out of all sane proportions?  Well, you could spend an
        afternoon figuring it out on paper, or you could be like me and spend
        the better part of a year writing an assembly program.
        </p><p><i><b>Spoiler alert:</b> I consider Meow5 to be a
        delightful little failure. The problem isn&#39;t inlining machine code -
        that works great, and, indeed, the exported ELF executables from Meow5
        work exactly as I imagined. The problem is <b>data</b>, and most
        conspicuously, data in the form of strings.  Let&#39;s take the
        <code>meow</code> word for example: You either have to copy the string
        &#34;Meow.&#34; five times, once for each word that uses it, <b>or</b> go
        through some complicated hoops to track which word uses the string. And
        you have to do that two different ways: Its location in memory in the
        live interpreter and in it&#39;s destination in the stand-alone ELF memory
        layout. Either way, the purity and simplicity is lost, which was the
        whole point of the experiment. Also, it will come as no surprise that I
        later discovered that Forth implementations often have an INLINE word
        (as I mentioned above), which is a much better way to selectively
        instruct the compiler about which words you wish to copy entirely.  As a
        program, Meow5 is a failure. But as a project, it is a success
        because I learned a lot.</i>
        </p><p>Think of it as an art project.
        </p><p>Anyway, the <em>point</em> is...
    </p></div>
</div>

<div>
    <p>Despite attempting to go my own way,
        it&#39;s remarkable how many times Forth&#39;s solution was the
        path of least resistance.
    </p><p>Again and again I would say, &#34;Aha! <i>That&#39;s</i> why.&#34;

    </p><div>
        <p>First of all, you&#39;ll notice I ended up using &#34;:&#34; and &#34;;&#34; to
        define new functions.
        Forth makes liberal use of symbols and abbreviations, which
        can make it pretty hard to read. But I have to admit, &#34;: ... ;&#34;
        has grown on me. So I adopted that in Meow5. So that&#39;s probably
        the most visible thing. But that&#39;s just on the surface.
        </p><p>Secondly, using a postfix notation is <em>absolutely</em> the path
        of least resistance for a stack-based language - everything comes in
        the order expected by the language.  So your interpreter can be
        shockingly simple because it can execute statements in the exact order
        it gets them.
        </p><p>(Side note: This is also how the
        <a href="https://en.wikipedia.org/wiki/PostScript">PostScript</a>
        (wikipedia.org)
        printer and display language works. The printer can begin printing as
        soon as it recieves the document because everything is defined in the
        order it is needed and never depends on later information. This can
        also be a <em>disadvantage</em> of PostScript for viewing documents on
        screens: You can&#39;t just render a page mid-document because
        styling and formatting controls must be read in their entirety from the
        start of the document to the current page in order to ensure you&#39;ve
        got everything!)
        </p><p>I was determined to make things easy for myself,
        so I can say with some certainty that Forth is one of the
        most &#34;minimum effort&#34; languages you can imagine.
        If I could have thought of an easier (or lazier) way to do something, 
        I would have done it!
        </p><p>There was just <strong>one place</strong> I decided to deviate
        from Forth even though I knew it would make implementation harder.
    </p></div>
</div>

<div>
    <p>To make a string in Forth, you use the word <code>&#34;</code>, which
    needs a space after it to be seen as a word, which looks awkward:
    </p><pre>&#34; Hello World.&#34;
    </pre>

    <div>
        <p>This has always bothered me. Chuck Moore even admits this in
        his unpublished book, 
        <a href="http://forth.org/POL.pdf">Programming A Problem-Oriented Language (PDF)</a>
        (forth.org)
        in the section titled <i>6.3 Character strings</i>:
        </p><blockquote>
            &#34;What does a character string look like? Of all the ways you might
            choose, one is completely natural:
            <pre>    &#34;ABCDEF...XYZ&#34;
            </pre>
            A character string is enclosed in quotes. It can contain any character
            except a quote, specifically including spaces.&#34;
        </blockquote>
        <p>Right! So by golly, that&#39;s what I would do in Meow5, like
        every sensible language!
    </p></div>
</div>


<div>
    <p>Meow5 has this more natural quoting style:
    </p><pre>&#34;Hello World.&#34;
    </pre>
    <p>But the effects are cascading. And they limit flexibility.

    </p><div>
        <p>If we keep reading Chuck&#39;s words, he explains what will happen
        if you do this:
        </p><blockquote>
            &#34;We get in trouble immediately! How do you recognize a character
            string? By the leading quote, of course. But do you modify your word
            subroutine to recognize that quote? If you do so you may never use a
            leading quote for any other purpose. Much better that the quote is a
            word by itself, treated like any other dictionary entry, for it can then
            be re-defined. But words are terminated by spaces, and I still resist
            making quote an exception. So let&#39;s type character strings:
            <pre>    &#34; ABCDEF . . . XYZ&#34;
            </pre>
        </blockquote>
        <p>And he was right, of course.
        </p><p>I ended up having to put exceptions for the <code>&#34;</code> character in
        multiple places in the Meow5 interpreter, including my
        <code>get_token</code> function, which serves the same purpose as
        the &#34;WORD subroutine&#34; Moore mentioned above.
        </p><p>And now <em>all</em> additional interpreter features have to work
        around or duplicate the special <code>&#34;</code> character handling!
        </p><p>It seems one can either follow Moore&#39;s advice or re-discover
        it for oneself. As for me, I always enjoy re-discovering things for
        myself. The best part is that &#34;aha!&#34; moment when I realize why
        things are the way they are.
        </p><p>Though, to flip this whole thing on its head, I actually think it
        <em>was</em> worth the extra effort, trouble, and loss of purity to do
        this!  (I also included escape sequences, e.g. <code>\n</code> and
        <code>\&#34;</code>, while I was at it.)
    </p></div>
</div>

<div>
    <p>Another example of straying from Moore&#39;s advice
    and having to discover it for myself:
    </p><p>I decided to have some of my functions leave the stack alone after using
    the top value.

    </p><div>
        <p>Some functions are mostly used to examine a value, but they pop
        that value off the stack. To keep working with the value, you have
        to do a DUP to duplicate it first.
        </p><p>Since I was sure I would always want to keep the value after these
        particular functions, it seemed very wasteful to have to do a DUP each
        time. Why not just peek at it and leave it on the stack?
        </p><p>Moore recommends just popping everything so you
        don&#39;t have to remember.
        </p><p>But I thought that was silly. So I went ahead and made some functions
        that just peek at the value and leave it on the stack.
        </p><p>But as you may have guessed, he was absolutely right.
        </p><p>Having some words pop the stack and some words peek was a nightmare.
        I kept forgetting which words did or didn&#39;t alter the stack and it
        kept causing problems. <strong>I completely regretted it and ended up
        making them all pop like Moore advised.</strong>
        </p><p>(Another option that occurred to me after I changed them all would
        have been to have a special naming scheme for non-popping words, which
        probably would have been fine, expect then I would have had to remember
        the name... so hassle either way.)
    </p></div>
</div>

<div>
    <p>Now we have <em>yet another</em> reason for the title of this
    article.
    </p><p>Once you start down the Forth path... the rest just sort of
    &#34;writes itself&#34;.
    Chuck Moore already found the path of least resistance.
    </p><p>To sum up the ways in which &#34;Forth writes itself&#34; so far, we have:
    </p><ul>
        <li>Forth is boostrapping
        </li><li>Forth is metaprogramming
        </li><li>Forth can be your OS and your IDE/editor
        </li><li>Forth is the path of least resistance for writing a Forth
    </li></ul>

    <div>
        <p>If you set out to make the <em>simplest possible</em> interpreter
        for a brand new CPU architecture, <strong>you might end up writing
            a Forth whether you want to or not.</strong>
        </p><p>Forth lets you define <em>more Forth</em> in Forth so you
        can Forth while you Forth. And the Forth editor <em>is</em> Forth
        and can be extended with Forth, so can Forth Forth in Forth Forth Forth
        Forth. (I&#39;ll let you figure out which of those are nouns, adjectives,
        or verbs and whether or not I have the right number of them.)
        </p><p>And if that weren&#39;t enough, Forths often contain <em>assemblers</em>
        so you can define additional code words in Forth, too so you never
        need to leave Forth once you&#39;re in it.
        </p><p>JonesForth has the stub of an in-Forth assembler near the end so we
        can see how one might work. Here&#39;s the comment introducing it:
        </p><pre>(
    ASSEMBLER CODE --------------------------------------------

    This is just the outline of a simple assembler, allowing
    you to write FORTH primitives in assembly language.

    Assembly primitives begin &#39;: NAME&#39; in the normal way,
    but are ended with ;CODE.  ;CODE updates the header so that
    the codeword isn&#39;t DOCOL, but points instead to the
    assembled code (in the DFA part of the word).

    We provide a convenience macro NEXT (you guessed what it
    does).  However you don&#39;t need to use it because ;CODE will
    put a NEXT at the end of your word.

    The rest consists of some immediate words which expand
    into machine code appended to the definition of the word.
    Only a very tiny part of the i386 assembly space is covered,
    just enough to write a few assembler primitives below.
)
        </pre>
        <p>Just try not to go insane from the <strong>unlimited power</strong>.
        </p><p>And then there&#39;s this:
    </p></div>
</div>

<div>
    
    <p>Hand-written 1Kb binary
    <img src="https://ratfactor.com/forth/talkimg/planckforth.png" alt="binary layout of planckforth as taken from the repo"/>

    </p><div>
        <p>This image comes from the
        <a href="https://github.com/nineties/planckforth">PlanckForth repo</a>
        (github.com).
        It&#39;s one of the most
        beautiful pieces of code I&#39;ve ever seen. It&#39;s a complete ELF binary
        with a working Forth implementation that fits in less than 1Kb.
        As you can see, there&#39;s enough room left over for a description and
        copyright at the end.
        </p><p>The binary is stored as an ASCII hex represention that can be turned
        into a working binary using <code>xxd -r -c 8</code>.
        </p><p>But the best part is <code>bootstrap.fs</code>, written in
        line-noise-like operators and gradually becoming readable Forth
        after a couple hundred lines.
        </p><p>Thankfully, comments are one of the very first things implemented
        and it&#39;s almost like seeing bacteria spell out words in a petri dish:
        </p><pre>h@l@h@!h@C+h!k1k0-h@$k:k0-h@k1k0-+$h@C+h!ih@!h@C+h!kefh@!h@C+h!l!
h@l@h@!h@C+h!k1k0-h@$k h@k1k0-+$h@C+h!ih@!h@C+h!kefh@!h@C+h!l!

h@l@ h@!h@C+h! k1k0-h@$ k\h@k1k0-+$ h@C+h!
    i       h@!h@C+h!
    kkf     h@!h@C+h!
    kLf     h@!h@C+h!
    k:k0-   h@!h@C+h!
    k=f     h@!h@C+h!
    kJf     h@!h@C+h!
    k0k5-C* h@!h@C+h!
    kef     h@!h@C+h!
l!

\ **Now we can use single-line comments!**

\ planckforth -
\ Copyright (C) 2021 nineties
...
        </pre>
        <p>Incredible.
        </p><p>Another hand-written machine code Forth (in 1,000 bytes and with
        a Forth system in 1,000 lines!) is 
        <a href="https://dacvs.neocities.org/SF/">SmithForth</a>
        (neocities.org)
        by David Smith.
        You can see and hear Smith walk through SmithForth on YouTube:
        <a href="https://www.youtube.com/watch?v=9MSJGzYELBA">SmithForth workings</a>
        (youtube.com).
        </p><p>And as you may recall from earlier, Cesar Blum&#39;s
        <a href="https://github.com/cesarblum/sectorforth">sectorforth</a>
        (github.com)
        is a mere 512 bytes!
        </p><p>There are almost as many Forth implementations as there are
        stars in the night sky.
    </p></div>
</div>

<div>
    <p>Forth is an <b>idea</b> that has taken form in countless applications.
    </p><p>Many Forths are custom and home-grown.
    </p><p>But it has had great success in a huge variety of roles:
	</p><ul>
		<li>Power plants, robotics, missile tracking systems, industrial automation.
		</li><li>Embedded language in video games.
        </li><li>Databases, accounting, word processors, graphics, and computation
            systems. (You might say, &#34;legacy software.&#34; But I say, &#34;Elegant
            weapons for a more civilized age,&#34; to paraphrase a certain wise
            Jedi.)
		</li><li>In the modern Open Firmware boot loader.
		</li><li>Processors of all shapes and sizes.
		</li><li>Microcontrollers of all shapes and sizes.
	</li></ul>

	<div>
        <p>If it goes &#34;beep&#34; and &#34;boop&#34;, someone has written a Forth for it!
        </p><p>For some notable uses, here are some starting points:
        </p><ul>
            <li><a href="https://www.forth.com/resources/forth-apps/">Featured Forth Applications</a> (forth.com)
		    </li><li><a href="http://www.forth.org/successes.html">Forth Success Stories</a> (forth.org)
            </li><li><a href="https://en.wikipedia.org/wiki/Forth_(programming_language)">Forth</a> (wikipedia.org)
        </li></ul>
        <p>I think
        <a href="https://en.wikipedia.org/wiki/Open_Firmware">Open Firmware</a>
        (wikipedia.org)
        is particularly interesting. It came, like many things, from
        the fine engineering minds at Sun Microsystems.
        </p><blockquote>
            &#34;Being based upon an interactive programming language, Open
            Firmware can be used to efficiently test and bring up new hardware.
            It allows drivers to be written and tested interactively.&#34;
        </blockquote>
        <p>Perhaps one of the most exciting uses of Open Firmware was the
        <strong>Space Shuttle</strong>
        ESN, which ran on a radiation-hardened
        <a href="https://www.cpushack.com/2019/03/01/cpu-of-the-day-utmc-ut69r000-the-risc-with-a-trick/">UT69R000</a>
        (cpushack.com)
        processor!
        A paper on the ESN,
        <a href="https://zenodo.org/record/1267048/files/article.pdf">Developing plug-and-play spacecraft systems: NASA Goddard Space Flight Center&#39;s (GSFC) Essential Services Node (ESN) (PDF)</a> 
        (zenodo.org)
        notes that:
        </p><blockquote>
            &#34;Open Firmware can debug hardware,software, plug-in drivers, and
            even the firmware itself. Open Firmware provides interactive tools
            for debugging systems.&#34;
        </blockquote>
        <p>By the way, I hope this brief mention of space technology has wet
        your appetite for more, because we&#39;re almost there!
        </p><p>But first, I have a couple more drawings of cool computers you
        should see. Perhaps you are aware of the huge variety of 1980s home
        computers?
        </p><p>Check these out:
	</p></div>
</div>

<div>
    
	<p><img src="https://ratfactor.com/forth/talkimg/jupiter_ace.png" alt="drawing of the jupiter ace home computer"/></p><p>Operating system: Forth.
    </p><p>OS and library of routines in 8 KB of ROM.
    </p><p>The onboard Forth was &#34;Ten times faster than [interpreted] BASIC&#34; and
    less than half the memory requirements.&#34;

    </p><div>
        <p>(The quote above is from Popular Computing Weekly, 1982.)
        </p><p>The
        <a href="https://en.wikipedia.org/wiki/Jupiter_Ace">Jupiter Ace</a>
        (wikipedia.org)
        was a British home computer of the early 1980s.
        </p><p>It has a fan-made website, the Jupiter ACE Archive from which
        has the page,
        <a href="https://www.jupiter-ace.co.uk/whatisanace.html">What is a Jupiter ACE?</a>
        (jupiter-ace.co.uk):
        </p><blockquote>
            &#34;The major difference from the &#39;introductory computer&#39; that was the
            ZX81, however, was that the Jupiter ACE&#39;s designers, from the
            outset, intended the machine to be for programmers: the machine
            came with Forth as its default programming language.&#34;
        </blockquote>
        <p>That website has tons of resources. And if you&#39;re into that sort of
        thing, you also owe it to yourself to visit the &#34;What is...&#34; page
        linked above and then hover your mouse over the image of the ACE&#39;s
        circuit board. Every single IC, capacitor, and resistor is identified
        and explained in little tooltips!
        </p><p>It&#39;s not every day you see a <strong>programming language listed as
            an operating system</strong> for a computer. But you may recall
        that as early as the &#34;IBM 1130 minicomputer at a big textiles
        manufacturer&#34; era, Moore already had an editor and file management
        features. And you can certainly write hardware drivers in Forth if you
        have the right code word primitives. And as we&#39;ll see soon, there
        is absolutely <em>no limit</em> to how low-level Forth can go.
        </p><p><em>(There&#39;s also no limit to how high-level Forth can go. The book
        </em>Thinking Forth<em> by Leo Brodie, the same book from which
        we got the apples example above, is full of examples of applications
        written in very &#34;English like&#34; high-level words.)</em>
        </p><p>The ACE never sold very many units, but it is prized by collectors
        today. I would take one.
        </p><p>The
        <a href="https://www.jupiter-ace.co.uk/whatisforth.html">What is Forth?</a>
        (jupiter-ace.co.uk)
        page has an excellent explanation of Forth in general, but especially
        as an all-encompassing computing system:
        </p><blockquote>
            &#34;Classic Forth systems use no operating system. Instead of storing
            code in files, they store it as source-code in disk blocks written
            to physical disk addresses. This is more convenient than it sounds,
            because the numbers come to be familiar. Also, Forth programmers
            come to be intimately familiar with their disks&#39; data structures,
            just by editing the disk. Forth systems use a single word &#34;BLOCK&#34;
            to translate the number of a 1K block of disk space into the
            address of a buffer containing the data. The Forth system
            automatically manages the buffers.&#34;
        </blockquote>
        <p>Many of us fondly remember the boot-to-BASIC computers of the 1980s,
        but can you imagine growing up with the Jupiter ACE in your home and
        actually <em>understanding it</em>?
        </p><p>The ACE ran on the
        <a href="https://en.wikipedia.org/wiki/Zilog_Z80">Zilog Z80</a>
        (wikipedia.org)
        CPU, which was incredibly popular at the time for low-power computers
        and has had an amazingly long life. It was used in the higher-end TI
        graphing calculators such as the
        <a href="https://en.wikipedia.org/wiki/TI-85">TI-85</a>
        (wikipedia.org)
        I had in high school in 1996, which I spent many a happy afternoon
        programming in TI-BASIC.
    </p></div>
</div>

<div>
    
	<p><img src="https://ratfactor.com/forth/talkimg/canon_cat.png" alt="drawing of the canon cat word processor home computer"/></p><p>Operating system: Forth.
    </p><p>OS, office suite, and programming environment in 256 KB of ROM.
    </p><p>Innovative interface by Jef Raskin.

    </p><div>
        <p>Another computer with Forth as an operating system!
        </p><p>The <a href="https://en.wikipedia.org/wiki/Canon_Cat">Canon Cat</a>
        (wikipedia.org)
        is a particularly fascinating machine for a number of different
        reasons, the primary of which is the keyboard-driven interface
        by UI pioneer Jef Raskin.
        </p><p>Raskin wrote a book titled
        <a href="https://en.wikipedia.org/wiki/The_Humane_Interface">The Humane Interface</a>
        (wikipedia.org)
        with some provocative ideas that are probably
        very much worth re-visiting.
        For example, I like these two design rules:
        </p><blockquote>
            <ul>
                <li>Elimination of warning screens - modern software
                    applications often ask the user &#34;are you sure?&#34; before some
                    potentially harmful action; Raskin argues they are
                    unhelpful because users tend to ignore them out of habit,
                    and that having a <strong>universal undo</strong>
                    eliminates the need for them.
                </li><li>Universal use of text - Raskin argues that graphic icons in
                    software without any accompanying text are often cryptic to
                    users.
            </li></ul>
        </blockquote>
        <p>The Cat was the hardware and software incarnation of Raskin&#39;s
        design philosophies.
        </p><p>Also, you <em>have</em> to check out the picture of Jef with a
        little model of the Cat on his Wikipedia page:
        <a href="https://en.wikipedia.org/wiki/Jef_Raskin">Jef Raskin</a>
        (wikipedia.org).
        Direct link to the image: <a href="https://en.wikipedia.org/wiki/Jef_Raskin#/media/File:Jef_Raskin_holding_Canon_Cat_model.png">here</a>
        (wikipedia.org).
        </p><p>The Cat ran on a
        <a href="https://en.wikipedia.org/wiki/Motorola_68000">Motorola 68000</a>
        (wikipedia.org)
        CPU, which was also used in the Apple Macintosh and was one of the
        first 32-bit processors, featuring 32-bit instruction set, registers,
        and non-segmented memory addressing.
        </p><p>Getting to the Forth interface doesn&#39;t seem to have been a top
        priority on the Cat.
        </p><p>Quoting Dwight Elvey at the DigiBarn computer museum,
        <a href="https://www.digibarn.com/collections/systems/canon-cat/forthinside.html">Canon Cat: Enabling Forth</a>
        (digibarn.com),
        the process <em>sounds</em> a bit awkward:
        </p><blockquote>
            &#34;Highlight the string: <em>Enable Forth Language</em>.</blockquote>
        <p><em>(Note that &#34;USE FRONT&#34; is a dedicated key on the Canon Cat
            keyboard that lets you apply whatever function is printed on the
            front of another key on the keyboard. Clever, right?  All of the
            Cat&#39;s interactions are performed through the keyboard like
            this.)</em>
        </p><p>And if that process weren&#39;t enough to put you off, this warning
        seems particularly dire and, if anything, hilariously understated:
        </p><blockquote>
            &#34;Use care while in Forth mode as usefront shift : will
            format the disk (a good idea to make a backup or
            at least remove the disk while experimenting).&#34;
        </blockquote>
        <p>But all of that makes it sound worse than it is.
        Thanks to modern streaming video technology, you can
        <em>see</em> Dwight Elvey
        <a href="https://www.youtube.com/watch?v=jErqdRE5zpQ">boot up a cat and demonstrate it</a>
        (youtube.com).
        As you can see, getting to the Forth interface is really not a
        lengthy process at all once you know what to do. Just a couple keystrokes.
        And the Cat is a more compact computer than I imagined from the pictures.
        </p><p>If you like industrial design or interesting computer interfaces,
        you owe it to yourself to check out the amazing pictures of
        <a href="https://www.digibarn.com/friends/jef-raskin/slides/canon-cat/index.html">Jef Raskin&#39;s team designing the Canon Cat (1985)</a>!
        (digibarn.com)
        </p><p>If you want to see a bunch of pictures of a vintage Cat in
        amazing shape, check out Santo Nucifora&#39;s
        <a href="https://vintagecomputer.ca/canon-cat/">Canon Cat</a>
        (vintagecomputer.ca).
        </p><p>If nothing else, just let this fact marinate in your head for a
        little bit: <strong>The Canon Cat had an OS, office suite, and
            programming environment in 256 KB of ROM.</strong> This 
        document (not including the images) is almost exactly that
        size!
        </p><p>Okay, now we are ready for...
    </p></div>
</div>

<div>
    <p><img src="https://ratfactor.com/forth/talkimg/forth_in_space.png" alt="title says Forth in Space and chuck is an astronaut on EVA who says May the Forth be with you."/></p><div>
        <p>Easily one of the most exciting uses of Forth is space
        exploration because space is intrinsicly awesome.
        </p><p>We&#39;ve already seen how Chuck Moore was intimately
        involved in programming ground-based radio telescopes.
        But Forth has also found its way into tons (literally and idiomatically)
        of actual space craft in outer space!
        </p><p>NASA is famous for having stringent rules about software
        that runs on spacecraft. Which makes sense, given the cost of these
        machines and the difficulty or even impossibility of getting
        to them to make fixes.
	</p></div>
</div>

<div>
	
	<p><img src="https://ratfactor.com/forth/talkimg/nasa_list.jpg" alt="unreadable list of a ton of nasa projects using forth"/></p><p>The list of projects using Forth at NASA compiled by James Rash in 2003 is too long to easily list here.

	</p><div>
        <p>The image on the right is intentionally too small to read. As you
        can see, it&#39;s a big list.
        </p><p>The original NASA link has died, but the page was archived by
        the Wayback Machine at archive.org. There&#39;s a nice copy
        hosted here as well:
		<a href="https://www.forth.com/resources/space-applications/">Forth in Space Applications</a>
        (forth.com).
        </p><p>I haven&#39;t found a list like this for the ESA, but the Philae
        lander featured below would be one very prominent example.
        </p><p><i>(By the way, though Forth isn&#39;t featured here, there&#39;s a fun overview
        of some CPUs used in various space missions: 
        <a href="https://www.cpushack.com/space-craft-cpu.html">The CPUs of Spacecraft: Computers in Space</a>
        (cpushack.com).)</i>
        </p><p><i>(The image to the right is very tall. We need some more text for
            wider screens. So, while it&#39;s not about Forth,I won&#39;t miss this
            opportunity to mention one of my favorite computing-in-space books:
        <a href="http://web.mit.edu/digitalapollo/">Digital Apollo: Human and Machine in Spaceflight</a>
        (mit.edu)
        by David Mindell. It will change how you look at the Apollo missions,
        computers in general, and the role of astronauts in space craft!)</i>
	</p></div>
</div>

<div>
	
	<p><img src="https://ratfactor.com/forth/talkimg/nasa_ssbuv_patch.png" alt="nasa mission patch for ssbuv"/></p><p>&#34;There is always great concern about software reliability, especially with flight software.&#34;

	</p><div>
        <p>From the paper
        <a href="https://dl.acm.org/doi/pdf/10.1145/199200.316990">Forth in Space: Interfacing SSBUV, a Scientific Instrument, to the Space Shuttle (PDF)</a>
        (acm.org)
        by Robert T. Caffrey et al:
        </p><blockquote>
            &#34;There is always a great concern about software reliability,
            especially with flight software. The effects of a software error in
            flight could be dramatic. We were able to produce reliable software
            by writing a Forth routine on the PC, downloading the software, and
            testing it interactively. We varied the inputs to a routine and
            checked the ability of the routine to operate correctly under all
            conditions. As a result, during the STS-45 Shuttle mission, the
            SPAIM flight software worked perfectly and without any problems.&#34;
        </blockquote>
        <p>Forth systems can be multi-tasking and this allowed the system to
        monitor itself. Each task had its own stack and a watchdog task could,
        for example, check the health of another task by monitoring the
        other task&#39;s stack. (Stack depth was found to be a good indication of
        task health. In other words, malfunctions would often cause the stack
        depth to grow unchecked.)
        </p><blockquote>
            &#34;The ability of the Forth development system to debug hardware and
            software interfaces, model missing hardware, simulate system
            malfunctions, and support system integration dramatically helped in
            the quick generation of error-free software. The interactive,
            integrated and multitasking features of the Forth system proved to
            be the key elements in the success of the SPAIM systems
            development. Several techniques such as stack depth monitoring,
            address monitoring, cycle time monitoring, and error flag
            monitoring provided system checks during both the system
            integration process and the actual Shuttle mission.&#34;
        </blockquote>
        <p>The interactive nature of the Forth system is again found to be not
        just very convenient, but also a massive productivity boost for all
        phases of programming, debugging, and testing.
        </p><p>The SPAIM system used a 16-bit Intel 87C196KC16 microcontroller,
        which is a MIL-SPEC member of the
        <a href="https://en.wikipedia.org/wiki/Intel_MCS-96">Intel MCS-96</a>
        (wikipedia.org)
        family. These started out as controllers for Ford engines in the 1970s.
        They continued to be made in various incarnations until 2007 and were
        often used in common devices such as hard drives, modems, and printers.
        Unlike many chips headed to space long-term, this one wasn&#39;t &#34;rad-hard&#34;
        (hardened against the effects of radiation).
	</p></div>
</div>

<div>
	
	<p><img src="https://ratfactor.com/forth/talkimg/nasa_robot_arm.png" alt="robot arm in space shuttle"/></p><p>Given the input of three-axis joystick commands, control a
    50-foot long, six-joint arm with six different coordinate systems.
    </p><p>Entire system developed by <b>one programmer in five weeks.</b>

	</p><div>
        <p>The <a href="https://www.forth.com/space-shuttle-robot-arm/">Space Shuttle Robot Arm Simulator</a>
        (forth.com)
        was a complex machine with some challenging requirements.
        </p><p>It turns out that you can&#39;t just use the <em>same robot arm</em> on
        the ground for simulations as the one that will go into space.
        For one thing, contending with gravity changes the requirements to
        such a degree that it&#39;s a completely different robot!
        </p><blockquote>
            <p>&#34;The GSFC arm, for example, is designed to carry up to a thousand
            pound payload at its tip. In order to do this it uses a high
            pressure (4000 psi) hydraulic system rather than electric motors as
            on the RMS.
            </p><p>...
            </p><p>&#34;Because of the completely different nature of the joint controls,
            the original RMS software was not usable except as a source of
            algorithms.&#34;
        </p></blockquote>
        <p>So the simulator arm <strong>could not work the same way,
            but it had to pretend it did</strong>.
        </p><p>You can see in my drawing that the arm lived in a full-scale
        simulated shuttle bay and was accompanied by an enormous model
        satellite. (That satellite looks like the Hubble Space
        Telescope to me, which seems plausible, given the dates on this
        project.)
        </p><p>Just listen to these I/O requirements:
        </p><blockquote>
            &#34;The RMSS contains fourteen separate processes: one for each joint,
            one for each joystick, one for the digital display panel, a
            simulation process, a trending process, and several supervisory
            processes.&#34;
        </blockquote>
        <p>But, as seems to be a trend with Forth-based space software,
        the work was impeccable:
        </p><blockquote>
            &#34;Simulation testing was so thorough that when the arm software was
            installed on site, not a single change was made to the executive
            control algorithms.&#34;
        </blockquote>
        <p>Does Forth imply excellence, or does excellence imply Forth? Ha ha.
        </p><p>Seriously, though, writing a system like that in five weeks
        is pretty astounding.
	</p></div>
</div>

<div>
	
	<p><img src="https://ratfactor.com/forth/talkimg/nasa_shuttle.png" alt="drawing of the shuttle launching"/></p><p>JPL&#39;s ground-based control software for shuttle SIR-A and SIR-B
    radar imaging instruments.

	</p><div>
        <p>This section started off as an excuse to draw a Space Shuttle.  But
        it&#39;s actually a great example of how a &#34;live&#34; interactive system
        can save a mission, even if the software itself hasn&#39;t been deployed into
        space.
        </p><p>The paper:
        <a href="https://dl.forth.com:8443/jfar/vol3/no2/article2.pdf">Forth as the Basis for an Integrated Operations Environment for a Space Shuttle Scientific Experiment (PDF)</a>
        (forth.com)
        describes a number of hardware failures that had to be
        overcome.
        </p><blockquote>
           &#34;It was in the first day of data taking that we noticed
            the first problem...&#34;
        </blockquote>
        <p>The SIR-B&#39;s transmitting antenna had shorted, resulting in the
        expected 1000 watts of power being reduced to a faint 100 watts.
        </p><blockquote>
            &#34;Since the returned echo was negligible as received by the SIR-B
            antenna it was decided to increase the gain of the receiver.
            The problem was in not understanding what had happened to cause
            the failure. [It] was not immediately apparent what the
            appropriate gain should be...&#34;
        </blockquote><p>
        Forth-based, highly adaptable SMDOS to the rescue!
        </p><blockquote>
            &#34;No problem. With the advice of the radar engineers, the Forth
            module that was used to generate the display was quickly
            modified to produce a calibrated display. The gain of the
            receiver was increased until a perfect bell-shaped pattern
            again appeared on the display.&#34;
        </blockquote><p>
        Then a <strong>second</strong> hardware failure:
        </p><blockquote>
            &#34;This was only the start of our problems. A satellite on board
            failed to deploy properly. The shuttle had to remain in high orbit
            until the problem was resolved before it could fire its engines to
            descend to the orbit that had been planned for the SIR-B data
            taking. &#34;
        </blockquote><p>
        Now the shuttle would not be in the planned orbit for data-taking.
        A second SMDOS adaptation fixed that.
        </p><p>Then a <strong>third</strong> hardware problem with <em>another</em>
        antenna:
        </p><blockquote>
            &#34;A bolt had sheared in the antenna&#39;s pointing mechenism and the KU
            band antenna was trashing around, threatening to destroy itself. It
            was necessary for an astronaut to exit the shuttle (EVA) in a
            spacesuit to pin the antenna down.&#34;
        </blockquote>
        <p>Now the shuttle had to rotate to point at a relay satellite to
        gather data (to tape!) and then rotate towards Earth to transmit
        the recorded data, and repeat.
        </p><blockquote>
            &#34;Of course this meant an entirely new data-taking strategy. Again
            the SMDOS computers were put to work displaying new plans for the
            stringent new conditions.&#34;
        </blockquote>
        <p>They lost tons of data, of course, but at least they were able to
        salvage 20% of it by rotating and capturing and rotating and
        transmitting. None of which would have a been possible if they had not
        been able to modify the software on the spot.
        </p><p>Conclusion:
        </p><blockquote>
            &#34;When the antenna feed failed and we realized that the software had
            to adapt to that failure, it was relatively easy given the
            interactive Forth enviroment to change the required module to meet
            the new specifications. This is clearly beyond the capabilites of
            most languages.&#34;
        </blockquote>
        <p>Other systems are interactive, but Forth may be singularly unique in
        allowing <em>complete</em> freedom of modification in an interactive
        session.
        </p><p>Of course, this kind of freedom is double-edged sword if there ever
        was one. The implied danger of that powerful sword (plus the postfix
        notation) has been a hard sell in the corporate world.
        </p><p>So far, we&#39;ve just seen Forth <em>software</em> in space. But it
        is often accompanied by Forth <em>hardware</em>.
        </p><p>Yup, Forth hardware. Introducing:
	</p></div>
</div>

<div>
    
	<p><img src="https://ratfactor.com/forth/talkimg/harris_rtx.jpg" alt="block diagram of harris chip"/></p><p>The <b>Harris RTX2010</b> processor.  Used in a ton of space
    applications.
    </p><p>Featuring:
	</p><ul>
		<li>Direct execution of Forth
		</li><li>Two hardware stacks, 256 words deep
		</li><li>8MHz clock, extremely low latency 
		</li><li>Radiation hardened
	</li></ul>

	<div>
        <p>The
		<a href="https://en.wikipedia.org/wiki/RTX2010">RTX2010</a>
        (wikipedia.org)
        and its predecessor, the RTX2000
        account for a good portion of the use of Forth in the space industry.
        They run Forth natively.
        </p><p>The use of the RTX line in space may not be soley due to a particular
        love for Forth per se, but because of the specific attractive properties
        of these processors - very low latency and the ability to quickly
        process the floating point mathematical operations needed for neat space
        stuff like navigation and thruster control. Either way, the 
        <em>philosophy</em> of Forth embedded in this hardware is suitable
        for the extreme environments in which they operate.
        </p><p>Largely because of the stack-based design, the RTX 2000 and 2010
        have very compact machine code. <strong>Subroutines calls take only a
        single cycle and returns are free!</strong>  All branches take
        exactly one cycle as well.
        </p><p>They are also brilliantly minimalistic designs. The entire RTX2000
        instruction set fits on a single page. See the first PDF link below:
        </p><ul>
            <li><a href="https://vfxforth.com/flag/jfar/vol6/no1/article1.pdf">The Harris RTX 2000 Microcontroller (PDF)</a>
                (vfxforth.com)
                - The RTX2000 as described in The Journal of Forth Application
                and Research by Tom Hand.
            </li><li><a href="https://www.mouser.com/catalog/specsheets/intersil_fn3961.pdf">HS-RTX2010RH Data Sheet (PDF)</a>
                (mouser.com)
                - The RTX2010 is now sold by Intersil.
            </li><li><a href="https://rocelec.widen.net/view/pdf/wezkwfjd8w/INSLS11172-1.pdf?t.download=true&amp;u=5oefqw">RTX 2000 Data Sheet (PDF)</a>
                (widen.net) as originally sold by Harris.
            </li><li><a href="https://www.digikey.com/en/products/detail/rochester-electronics-llc/RTX2000JI-8/12131997">DigiKey evidently has 800+ RTX2000s in stock</a>
                (digikey.com)
                through Rochester Electronics for a reasonable $22, but you
                have to by them in quantities of 14.  (Maybe you can find
                14 friends to do a group buy?)
        </li></ul>
        <p>So what kind of spacecraft use these Forth-native processors?
        </p><p>Let&#39;s look at a specific pair of spacecraft:
	</p></div>
</div>

<div>
	
	<p><img src="https://ratfactor.com/forth/talkimg/rosetta_spacecraft.png" alt="drawing of rosetta approaching comet"/></p><p>First mission to send a spaceship to orbit a comet and then deliver a
    lander to the comet&#39;s surface!
	</p><p>The <b>Rosetta</b> spacecraft&#39;s Ion and Electron Sensor instrument used a Harris RTX2010.
	</p><p>The <b>Philae</b> lander used two Harris RTX2010s for complete system control (CDMS) and two more to control its landing system (ADS).

	</p><div>
        <p>The ESA&#39;s <a href="https://www.esa.int/Science_Exploration/Space_Science/Rosetta">Rosetta mission</a>
        (esa.int)
        was hugely ambitious: Send a spacecraft to
        rendezvous with and then follow a comet around the Sun, deploy
        the Philae lander to the surface by dropping it into the comet&#39;s
        gravity well, observe the lander as it shoots harpoons
        into the icy surface of the comet to keep from bouncing back out
        into space, then relay the lander&#39;s communication from the surface back to
        distant Earth, 28 minutes away at the speed of light.
        </p><p>Rosetta traveled in the Solar System for a full decade (2004 to
        2014) before meeting up with comet <b>67P/&#34;Churyumov-Gerasimenko&#34;</b>.
        (67P is 4km wide and orbits the sun every six and a half years.)
        </p><p>Rosetta orbited the comet for three months and then deployed
        the Philae lander to the surface of the comet.
        </p><p>Both craft contained a full laboratory of advanced scientific
        instruments (11 on Rosetta, 9 on Philae) including some that doubled
        as high-resolution cameras with images suitable for humans to view.
        <a href="https://en.wikipedia.org/wiki/Rosetta_(spacecraft)">The whole mission</a>
        (wikipedia.org)
        is worth reading about. There are some fantastic images
        and animations to be seen on the mission page and on the
        <a href="https://en.wikipedia.org/wiki/67P/Churyumov%E2%80%93Gerasimenko">comet&#39;s own page</a>
        (wikipedia.org).
        <img src="https://ratfactor.com/forth/talkimg/philae_from_rosetta_via_osiris.jpg" alt="the philae lander brightly illuminated by the sun against the black backdrop of space"/>
        </p><p>Often described as being &#34;the size of a washing machine,&#34; the
        <a href="https://en.wikipedia.org/wiki/Philae_(spacecraft)">Philae</a>
        (wikipedia.org)
        lander pushed away from Rosetta&#39;s orbit to drop to the surface of 67p.
        </p><p><em>The picture at the right was taken
        from Rosetta&#39;s OSIRIS imager as Philae fell slowly away from the
        orbiter.</em>
        </p><p>Because the comet&#39;s gravitational pull is so small (huge boulders
        have been observed moving around on its surface), a pair of harpoons
        were meant to fire into the surface of the comet and hold the lander
        down. These did not deploy (possibly a mechanical failure) and a
        landing thruster also failed, so Philae ended up having a long,
        low-gravity tumble on the surface.
        </p><p>It&#39;s been speculated that the harpoon failure actually
        <em>saved</em> Philae from an even more exciting trip because studies
        of the surface found it to be harder than expected. It might have
        launched itself away rather than anchoring! As it was, the lander
        bounced with a force that was <em>just shy</em> of escaping the comet&#39;s
        gravitational pull entirely. It rose a full kilometer above the surface
        before slowly returning for another two bounces to its final resting
        spot.
        </p><p>A pair of Harris RTX2010s controlled Philae&#39;s Active Descent System.
		Check out <a href="https://www.cpushack.com/2014/11/12/here-comes-philae-powered-by-an-rtx2010/">Here comes Philae! Powered by an RTX2010</a>
        (cpushack.com):
        </p><blockquote>
            &#34;Why was the RTX2010 chosen?  Simply put the RTX2010 is the lowest
            power budget processor available that is radiation hardened, and
            powerful enough to handle the complex landing procedure.  Philae
            runs on batteries for the first phase of its mission (later it will
            switch to solar/back up batteries) so the power budget is critical.
            The RTX2010 is a Forth based stack processor which allows for very
            efficient coding, again useful for a low power budget.&#34;
        </blockquote>
        <p>Here is more information (with pictures!) about the physical design
        and components in the Philae control system:
        <a href="http://www.sgf.hu/newsgfweb3_005.htm">Command and Data Management Subsystem (CDMS) of the Rosetta Lander (Philae)</a>
        (sgf.hu).
        </p><blockquote>
            &#34;Harris RTX2010 processor has been selected for the DPU boards
            because it is the lowest power consuming, space qualified,
            radiation hardened, 16-bit processor with features to provide so
            complicated functions as the CDMS has to perform. It is a stack
            based, Forth language oriented processor with an exotic and
            challenging instruction set. CDMS is a real-time control and data
            acquisition system, and it has to process tasks in parallel.
            Therefore, a real-time, pre-emptive multitasking operating system
            has been developed to run application tasks executing the required
            functions in parallel.&#34;
        </blockquote>
        <p>And here is the lander&#39;s
        <a href="https://www.spyr.ch/ps/ads/qm/">Active Descent System (ADS) QM User Manual</a>
        (spyr.ch)
        which has way more detail about this computer system, including a
        number of details about the Forth software:
        </p><blockquote>
             &#34;After resetting the subsystem (power-on reset), the bootstrap
             sets up the Forth environment, copies the firmware from PROM to
             RAM and disables the PROM for further access.  
             </blockquote>
        <p>Despite the unfortunate landing, which put Philae in too much
        shadow to get as much solar energy as hoped and at an angle that
        made communication with Rosetta difficult, Philae was still
        robust enough to perform &#34;80%&#34; of its scientific mission, which
        is pretty amazing.
	</p></div>
</div>

<div>
    <p>A picture taken by the Philae lander as it lay on its side, enjoying some sunlight on
    one of its feet:
    <img src="https://ratfactor.com/forth/talkimg/philae_civa1.jpg" alt="the outline of deeply fractured rock and ice, the darkness of space in the background, and a lander foot brightly lit by the sun."/>

    </p>
</div>

<div>
    <p>This is one of the final images taken by the Rosetta orbiter as it made the
           &#34;hard descent&#34; (controlled crash landing) to the surface of comet 67p:
	<img src="https://ratfactor.com/forth/talkimg/rosetta_comet_67p.jpg" alt="photo of comet 67p taken by rosetta ("/>

	</p><div>
        <p>The image and a description are here: <a href="https://www.nasa.gov/feature/jpl/final-descent-image-from-rosetta-spacecraft">Final Descent Images from Rosetta Spacecraft</a>
        (nasa.gov).
        </p><blockquote>
            &#34;The decision to end the mission on the surface is a result of
            Rosetta and the comet heading out beyond the orbit of Jupiter
            again. Farther from the sun than Rosetta had ever journeyed before,
            there would be little power to operate the craft. Mission operators
            were also faced with an imminent month-long period when the sun is
            close to the line-of-sight between Earth and Rosetta, meaning
            communications with the craft would have become increasingly more
            difficult.&#34;
        </blockquote>
        <p>By the way, the ESA has a nice summary of the computer hardware
        used by the OSIRIS camera on Rosetta which was used to take the surface
        image above and also the little picture of the descending lander further
        above.
        <a href="https://sci.esa.int/web/sci-fmi/-/35973-osiris">Optical, Spectroscopic, and Infrared Remote Imaging System</a>
        (esa.int).
        </p><p>After finishing the first draft of this article, I was so excited about
        the Rosetta mission that I ended up ordering and reading
        <i>Rosetta: The Remarkable Story of Europe&#39;s Comet Explorer</i> by Peter Bond.
        It&#39;s a bit of a dry read, but the subject matter is thrilling
        nonetheless and the coverage is thorough.  I recommend it if you want to
        know a lot more about this awesome engineering and scientific milestone.
        (It does not, sadly, mention Forth.)
        </p><hr/>
        <p><strong>Rabbit Hole Alert:</strong> This takes us away from
        Forth for a moment, but learning about the
        Virtuoso RTOS (real-time operating system) eventually leads to a deep,
        deep Wikipedia rabbit hole that takes you on a journey to the Inmos
        processors, Hoare&#39;s CSP, the occam programming language, the HeliOS
        parallel computing operating system, and the concept of the
        <b>&#34;transputer&#34;</b> microprocessors.
        </p><p>Transputers use whole processors as
        building blocks for a parallel computer in the same way transistors are
        used as the building blocks for processors. (Thus, transputer =
        &#34;transistor computer,&#34; you see?) They were mostly featured in
        supercomputers, but they also saw some industrial controller use
        and there was even an Atari Transputer Workstation,
        ATW-800.
        </p><p>(I&#39;ve intentionally not linked to any of these things here
        because you&#39;ll disappear into that hole and never see the end of this
        document, which would be very sad.  Also, I mention &#34;transputers&#34; again
        one more time below and you wouldn&#39;t want to miss that.)
        </p><hr/>
        <p>The Rosetta orbiter and Philae lander now rest silently on the
        surface of 67p, where they will no doubt stay for billions of
        years or until future comet tourists pick them up and put them
        in a trophy room, whichever comes first.
	</p></div>
</div>

<div>
    
    <p>
        <img src="https://ratfactor.com/forth/talkimg/jack_rusher.jpg" alt="crop of jack rusher from the previous screenshot"/>
        &#34;...Space probes written in Lisp and <b>Forth</b> have been
        debugged while off world...  If they had proven their programs
        correct by construction, shipped them into space, and then found out
        their spec was wrong, they would have just had some <b>dead junk on
            Mars</b>.  But what these guys had was the ability to fix things
        while they are running on space probes...  In addition, the spec is
        always wrong!&#34;
    </p><p>-- Jack Rusher, Stop Writing Dead Programs (talk given at Strange Loop 2022)

    </p><div>
        <p>Here&#39;s the talk:
        <a href="https://www.youtube.com/watch?v=8Ab3ArE8W3s">&#34;Stop Writing Dead Programs&#34; by Jack Rusher (Strange Loop 2022)</a>
        (youtube.com).
        </p><p>You&#39;ve got 43 minutes to watch it. I&#39;m timing you. Don&#39;t get
        distracted by other YouTube suggestions. Come back here. I&#39;m waiting.
        </p><p>Or better yet, check out Jack&#39;s <i>awesome</i> transcript,
            which was super helpful when I wanted to re-find the above quote:
        <a href="https://jackrusher.com/strange-loop-2022/">Stop Writing Dead Programs.</a>
        (jackrusher.com).
        </p><p>In his transcript, he notes:
        </p><blockquote>
            &#34;Had I had more time, I would have done an entire series of slides
            on FORTH. It&#39;s a tiny language that combines interactive
            development, expressive metaprogramming, and tremendous machine
            sympathy. I&#39;ve shipped embedded systems, bootloaders, and other
            close-to-the-metal software in FORTH.&#34;
        </blockquote>
        <p>I was extremely interested in hearing about Forth systems being
        updated in space, but had a heck of a time finding any.
        I finally found one on a page that is otherwise largely
        dedicated to Lisp&#39;s use at the Jet Propulsion Labs:
        <a href="https://mecrisp-stellaris-folkdoc.sourceforge.io/lisp.html">1992-1993 - Miscellaneous stories</a>
        (sourceforge.io)
        on the amazing, sprawling site for the Mecrisp-Stellaris Forth
        (which runs on various non-x86 CPUs):
        </p><blockquote>
           &#34;Also in 1993 I used MCL to help generate a code patch for the
           Gallileo magnetometer. The magnetometer had an RCA1802 processor, 2k
           each of RAM and ROM, and was programmed in Forth using a development
           system that ran on a long-since-decommissioned Apple II. The
           instrument had developed a bad memory byte right in the middle of
           the code. The code needed to be patched to not use this bad byte.
           The magnetometer team had originally estimated that resurrecting the
           development environment and generating the code patch would take so
           long that they were not even going to attempt it. Using Lisp I wrote
           from scratch a Forth development environment for the instrument
           (including a simulator for the hardware) and used it to generate the
           patch. The whole project took just under 3 months of part-time
           work.&#34;
        </blockquote>
        <p><i>(If anyone has any leads to other notable Forth uses in space, I&#39;d love to
            hear about them.)</i>
    </p></div>
</div>

<div>
    <p>When we defeat the alien kill-bots and reprogram them, it will
		surely be with a Forth of some sort.
	<img src="https://ratfactor.com/forth/talkimg/killbots_forth.png" alt="alien kill-bots being controlled by forth"/>

    </p><div>
        <p>In the background, one of the Invader machines lies crumpled and
        smoking amidst ruins. This was one of Earth&#39;s great cities.
        </p><p> Stomping towards us with its mechanical arms raised in victory, is
        another Invader.  But this one is different. The tell-tale giveaway is
        the opening in its protective head dome. And is that a flag? Why yes, it is!
        </p><p>At great cost, humans managed to trap one of the Invaders long
        enough penetrate its outer defenses, while otherwise leaving the
        machine unharmed and operable.
        </p><p>Working feverishly against a doomsday clock, they burrowed deep into
        the electrical heart of the machine, identifying and classifying its
        alien functions until they understood it well enough to attempt
        an interface.
        </p><p>A bus protocol was decoded. Programming work began.
        </p><p>It went poorly. The aliens had unthinkably bizarre notions of
        generalized computing that defied all known patterns of software.
        </p><p>Everything had to be done with agonizing labor, stringing
        sequences of raw bus messages together in hopes of getting a
        correct response.
        </p><p>But then someone had the bright idea to bootstrap a Forth
        from the known instruction sequences. With this, they could write
        a bare-bones interpreter. And, at last, they could experiment
        quickly and safely.
        </p><p>Days later, an arm moved. Then they crushed a barrel with a
        gripper claw:
        </p><pre>BARREL OBJECT-ID VISION TARGET
133 L-ARM-FWD 14 L-CLAW-OPEN
25 L-ARM FWD 14 L-CLAW CLOSE
        </pre>
        <p>Then a first four-legged step. Then 20 steps:
        </p><pre>PREP-QUAD-LEGS
20 STRIDE-LOOP
        </pre>
        <p>As ravaged fighters looked on in amazement, <b><i>&#34;Defender-1&#34;</i></b> burst
        from the old brick warehouse and, in a terrific crash, it toppled
        another Invader as it was passing by on patrol.
        </p><p>The machines grappled for a moment and it
        looked as if <i>Defender-1</i>&#39;s clumsy movements would be no match
        for the alien, even from a superior position.
        </p><p>But humans had decoded <em>all</em> of the weapon systems by then and a
        special word had been prepared for this moment:
        </p><pre>: KILL
    100 BEAM-LEVEL
    BOT OBJECT-ID VISION TARGET
    L-BEAM FIRE-FULL
    R-BEAM FIRE-FULL
;
        </pre>
        <p>Twin blinding beams of energy struck the enemy full in the torso
        and instantly turned its mechanical guts into sizzling plasma.
        After a moment of silence, a single cheer rose up from a doorway
        nearby and was soon joined by a hundred different voices from
        places of concealment in the ruined buildings.
        </p><p>Now the humans had the upper hand at last! Other Invader
        machines were disabled or captured. <i>Defender-1</i> was joined
        by <i>Defender-2,</i> and then <i>3</i>, <i>4</i>, <i>5</i>, and more!
        </p><p>Software was passed by sneaker-net and by shortwave packet radio.
        City by city, Earth took back control. And along with victory,
        word of the <b>One True Language</b> spread across the land. Flags
        were raised in honor of its original discoverer, Chuck Moore.
        </p><p>Where other abstractions had failed, the universal machine
        truth of Forth had succeeded.
    </p></div>
</div>

<div>
    
    <p>Here&#39;s a &#34;family tree&#34; of some notable Forths:
    <img src="https://ratfactor.com/forth/talkimg/forth_family_tree.jpg" alt="unreadably tiny diagram of lineage of various Forth implementations"/>

    </p><div>
        <p>Obviously the graphic is unreadably tiny. For the full-size
            original and the gForth program used to create it, check out:
        </p><p><a href="http://www.complang.tuwien.ac.at/forth/family-tree/">Forth Family Tree and Timeline</a>
        (complang.tuwien.ac.at).
        </p><p>One of the hardest things about trying to learn &#34;Forth&#34; is realizing
        that there is no single implementation that can lay sole claim to that name.
        As we&#39;ve seen, some of Chuck&#39;s first Forths pre-date the name entirely.
        </p><p>There are Forth standards dating back to the original ANS Forth
        document and continuing with the
        <a href="https://forth-standard.org/">Forth 2012 Standard and Forth200x committee</a>
        (forth-standard.org).
        </p><p>Forths have shared concepts. There are many common words, certainly, but purpose-built
        Forths will have their own special vocabularies.
        </p><p>Also, it is true that <em>making</em> Forths is at least as fun
            as using them.
        </p><p>The forest of computing is peppered with hobby Forths. They grow where nothing
        else can survive. They flourish in the sun and in the shade.
        Each one is a little glittering jewel.
    </p></div>
</div>

<div>
    
    <p>Charles H. Moore founded Forth, Inc in 1973. He&#39;s continued to port
    Forth to various systems ever since. But he&#39;s never stopped inventing.
    <img src="https://ratfactor.com/forth/talkimg/chuck_and_crt.png" alt="drawing of chuck at a desk programming on a pc with a crt. equipment looks 1990s era"/>

    </p><div>
        <p>I drew this image of Chuck from a photo in this amazing quote
        collection,
        <a href="http://www.ultratechnology.com/moore4th.htm">Moore Forth: Chuck Moore&#39;s Comments on Forth </a>
        (ultratechnology.com)
        compiled by Jeff Fox.
        </p><p>You&#39;ll notice I added some color to my drawing for this one, and
        that&#39;s because I&#39;m pretty sure that what we&#39;re seeing on Chuck&#39;s monitor
        is...
    </p></div>
</div>

<div>
    <p><span>color</span><span>Forth</span>
    <img src="https://ratfactor.com/forth/talkimg/colorforth.png" alt="screenshot of colorforth"/>

	</p><div>
        <p><em>The above screenshot is actually from
        <a href="http://www.etherforth.org/ef.html">a page about etherForth</a>,
        (etherforth.org),
        which is a
        <span>color</span><span>Forth</span> 
        written for GA144 chips. (Don&#39;t look up those chips yet unless you
        want a spoiler for what&#39;s coming in a moment below!)</em>
        </p><p>What the heck are we looking at here?
        </p><p>So,
		<a href="https://en.wikipedia.org/wiki/ColorForth">colorForth</a>
        (wikipedia.org)
        is:
        </p><blockquote>
            &#34;An idiosyncratic programming environment, the colors simplify
            Forth&#39;s semantics, speed compiling, and are said to aid Moore&#39;s own
            poor eyesight: colorForth uses different colors in its source code
            (replacing some of the punctuation in standard Forth) to determine
            how different words are treated.&#34;
        </blockquote>
        <p>And, of course:
        </p><blockquote>
            &#34;The language comes with its own tiny (63K) operating system.
            Practically everything is stored as source code and compiled when
            needed. The current colorForth environment is limited to running on
            Pentium grade PCs with limited support for
            lowest-common-denominator motherboards, AGP video, disk, and
            network hardware.&#34;
        </blockquote>
        <p>But the best description of
        <span>color</span><span>Forth</span>
        and its strengths come from Chuck Moore himself in an interview in
        2009, 
        <a href="https://www.red-gate.com/simple-talk/opinion/geek-of-the-week/chuck-moore-geek-of-the-week/">Chuck Moore: Geek of the Week</a>
        (red-gate.com):
        </p><blockquote>
            &#34;Forth has some ugly punctuation that colorForth replaces by
            coloring source code. Each word has a tag that indicates function;
            it also determines color. This seems a small point, but it
            encourages the use of functions, such as comments or compile-time
            execution, that would be inconvenient in Forth.&#34;
        </blockquote>
        <p>It should be noted that the colors can be replaced with symbols or
        notation, so using the language without the ability to
        distinguish color is not a barrier. Color is just <i>one way</i> to
        show this information.
        </p><p>There are a ton of other enhancements beyond the obvious color aspect,
        such as:
        </p><blockquote>
            &#34;By having words preparsed, the compiler is twice as fast. Another
            small point, since compiling is virtually instantaneous, but this
            encourages recompiling and overlaying the modules of an
            application. Smaller modules are easier to code, test and document
            than a large one.&#34;
        </blockquote>
        <p>That interview contains another Chuck Moore quote about software
        construction in general:
        </p><blockquote>
            &#34;Instead of being rewritten, software has features added. And
            becomes more complex. So complex that no one dares change it, or
            improve it, for fear of unintended consequences. But adding to it
            seems relatively safe. We need dedicated programmers who commit
            their careers to single applications. Rewriting them over and over
            until they&#39;re perfect.&#34;
        </blockquote>
        <p>This is something I&#39;ve seen repeated again and again by some of
        the most respected minds in software: You cannot just keep adding
        things to a program. You must continually re-work the program to match
        your needs as they change over time. Ideally, you re-write the program.
        Only time and deep consideration can yield the most elegant, correct,
        and <i>simple</i> program.
        </p><p>Which brings us to...
	</p></div>
</div>

<div>
    
    <p>Chuck Moore has been fighting against software complexity since the 1950s.
    </p><p>&#34;I am utterly frustrated with the software I have to deal with. Windows is beyond comprehension! UNIX is no better. DOS is no better. There is no reason for an OS. It is a non-thing. Maybe it was needed at one time.
    </p><p>-- Chuck Moore, 1997

</p></div>

<div>
    <p>&#34;If they are starting from the OS they have made the first mistake. The OS isn&#39;t going to fit on a floppy disk and boot in ten seconds.&#34;
    </p><p>-- Chuck Moore, 1999

	</p><div>
        <p><i>These quotes also come from Jeff Fox&#39;s quotes collection,
        <a href="http://www.ultratechnology.com/moore4th.htm">Moore Forth: Chuck Moore&#39;s Comments on Forth</a>
        (ultratechnology.com).</i>
        </p><p>As you&#39;ve no doubt gathered over the course of this page,
        Chuck is no fan of big, heavy, complicated software such as
        operating systems.
        </p><p>He believes in compact, <em>machine-sympathetic</em> programming.
        </p><p>&#34;Mechanical Sympathy&#34; is not Chuck&#39;s term, but I believe it
        accurately describes his philosophy. It comes from this
        (apocryphal?) quote by 
        Formula One race car driver
        <a href="https://en.wikipedia.org/wiki/Jackie_Stewart">Jackie Stewart</a>
        (wikipedia.org):
        </p><blockquote>
            &#34;You don&#39;t have to be an engineer to be a racing driver, but you
            do have to have <strong>mechanical sympathy</strong>.&#34;
        </blockquote>
        <p>The use of the term to describe <em>software</em> comes from Martin Thompson&#39;s
        blog of the same name.
        In <a href="https://mechanical-sympathy.blogspot.com/2011/07/why-mechanical-sympathy.html">Why Mechanical Sympathy?</a>
        (blogspot.com),
        he writes:
        </p><blockquote>
            &#34;Why does the software we use today not feel any faster than the
            DOS based applications we used 20 years ago???  It does not have to
            be this way.  As a software developer I want to try and produce
            software which does justice to the wonderful achievements of our
            hardware friends.&#34;
        </blockquote>
        <p>Again and again, you&#39;ll see this sentiment echoed by Chuck Moore
        and fans of Forth.
        </p><p>I think it&#39;s very interesting and telling that Forth tends to be
        popular with &#34;hardware people&#34; such as electrical engineers and embedded
        systems designers. By contrast, it seems that &#34;software people&#34;
        tend to idolize a more abstract, <em>high-level</em> beauty as found
        in languages such as Lisp or Scheme.
        Of course, this is a gross generalization and may have no basis in fact,
        but I know I&#39;m not the only person to notice this trend.
        </p><p>Maybe another way to describe this aspect of Forth is that it has a
        &#34;mechanical purity&#34; in the same way that Joy, with its combinators,
        has a &#34;mathematical purity.&#34;
        </p><p>And speaking of hardware...
	</p></div>
</div>

<div>
    
    <p>Chuck&#39;s <i>real</i> love seems to be processor design.
	Those Harris RTX2000 and RTX2010 chips used in so many space missions?
    <strong>That&#39;s basically his chip!</strong>
	<img src="https://ratfactor.com/forth/talkimg/chuck_chip_scientist.png" alt="chuck as a mad scientist chip creator"/>
</p></div>

<div>
    <p>No kidding.
    </p><p>Chuck, that brilliant rascal, has been designing hardware since 1983
    starting with the Novix N400 gate array. An improved design was
    sold to Harris to become the RTX chips.
    </p><p>Chuck designs processors with his own VLSI software, &#34;OKAD&#34;, written in
    <strong>500 lines of Forth</strong>, of course.

	</p><div>
        <p>Take a moment to pause on that last sentence.
        </p><p>Processor design software written in 500 lines?
        </p><p>You read that right.
        </p><p>OKAD is one of the <strong>Great Legends of Chuck Moore</strong>.
        But what, exactly, is it?
        </p><p>First off, VLSI stands for
        <a href="https://en.wikipedia.org/wiki/Very_Large_Scale_Integration">Very Large Scale Integration</a>
        (wikipedia.org):
        </p><blockquote>
            &#34;Very large-scale integration (VLSI) is the process of
            creating an integrated circuit (IC) by combining millions or
            billions of MOS transistors onto a single chip. VLSI began in the
            1970s when MOS integrated circuit (Metal Oxide Semiconductor) chips
            were developed and then widely adopted, enabling complex
            semiconductor and telecommunication technologies. The
            microprocessor and memory chips are VLSI devices.&#34;
        </blockquote>
        <p>The product of VLSI is what we think of when we imagine
        the modern image of &#34;computer chip&#34; in our minds.
        </p><p>&#34;Integration&#34; is simply the shrinking of computers from whole rooms to
        microscopic thinking dust:
        </p><ul>
            <li>Computers began with processors the size of rooms with
                discrete logic gates you can touch (relays to vacuum tubes to
                transistors).
            </li><li>Then, processors were shrunk down to the size of refrigerators
                with logic boards of <strong>integrated circuits</strong> (ICs).
            </li><li>Finally, entire processors shrunk down to fit on a single chip via
                Very Large Scale <strong>Integration</strong>.
        </li></ul>
        <p>(Also, in a parallel path from mainstream desktop computing,
            VLSI has also produced entire computers and, increasingly,
            <b>multiple computers on a single chip</b>, also
            known as 
            <a href="https://en.wikipedia.org/wiki/System_on_a_chip">&#34;system(s) on a chip&#34; (SoC)</a>
            (wikipedia.org).
            The lines around the various types are extremely blurry, but
            some familiar forms are microcontrollers, embedded systems,
            various &#34;mobile&#34; devices, etc.)
        </p><p>Anyway Moore&#39;s,
        <a href="https://colorforth.github.io/vlsi.html">VLSI Design Tools (OKAD)</a>
        (colorforth.github.io)
        system a complete processor workshop:
        </p><blockquote>
            &#34;In 500 lines of
            <span>color</span><span>Forth</span>,
		    these tools provide everything required to design a chip.&#34;
        </blockquote>
        <p>OKAD is really more of a collection of tools that work together to:
        </p><ul>
            <li>Describe the basic logic gates (constructed of transistors),
            </li><li>Design the layout of the entire circuit (the three-dimensional multi-layered network of connections between gates),
            </li><li>Simulate the circuit electrically (voltage, temperature, capacitance, etc.),
            </li><li>And export the finished design to the industry-standard
                <a href="https://en.wikipedia.org/wiki/GDSII">GDSII</a>
                (wikipedia.org)
                file format that is given to IC foundries (or &#34;chip fabs&#34;).
        </li></ul>
        <p>For more about OKAD, I highly recommend reading the
        excellent answers to
        <a href="https://retrocomputing.stackexchange.com/questions/25506/did-forths-inventor-charles-moore-really-write-a-cad-program-in-only-5-lines-of">Did Forth&#39;s inventor Charles Moore really write a CAD program in only 5 lines of code?</a>
        (retrocomputing.stackexchange.com).
        </p><p>Moving on from the software to Moore&#39;s chips themselves, Moore himself wrote
        a nice little summary of his designs. It is written in Moore&#39;s typical consise style,
        giving just a few key details about each chip:
        <a href="https://colorforth.github.io/chips.html">Forth Chips</a>
        (colorforth.github.io).
        </p><p>First, there was the <b>Novix NC4000</b>, which was designed
        for a CMOS gate array.
        </p><p>Here&#39;s a whole book about the NC4000 chip: <a href="http://forth.org/OffeteStore/4001-footstepsFinal.pdf">Footsteps in an Empty Valley: NC4000 Single Chip Forth Engine (8Mb PDF)</a> by Dr. Chen-Hanson Ting.
        </p><p>To quote Dr. Ting from Chapter 2:
        </p><blockquote>
            &#34;The Novix NC4000 is a super high-speed processing engine which is
            designed to directly execute high level Forth instructions. The
            single chip microprocessor, NC4000, gains its remarkable
            performance by eliminating both the ordinary assembly language and
            internal microcode which, in most conventional processors,
            intervene between the high level application and the hardware. The
            dual stack architecture greatly reduces the overhead of subroutine
            implementation and makes NC4000 especially suited to support high
            level languages other than Forth.&#34;
        </blockquote>
        <p>As you can see, this reads just like a description of the Harris RTX
        chips used in the <b>spacecraft</b> we explored above.
        </p><p>Sure enough, if we read the History section on the
        <a href="https://en.wikipedia.org/wiki/RTX2010">RTX2010 page</a>,
        (wikipedia.org)
        the lineage is made very clear:
        </p><blockquote>
            &#34;In 1983, Chuck Moore implemented a processor for his programming
            language Forth as a gate array. As Forth can be considered a dual
            stack virtual machine, he made the processor, Novix N4000 (later
            renamed NC4016), as a dual-stack machine. In 1988, an improved
            processor was sold to Harris Semiconductor, who marketed it for
            space applications as the RTX2000.&#34;
        </blockquote>
        <p>Another great article about Moore&#39;s early processor design work
        (and some more <b>spacecraft</b> mentions!), check out
        <a href="https://www.cpushack.com/2013/02/21/charles-moore-forth-stack-processors/ ">Charles Moore: From FORTH to Stack Processors and Beyond</a>
        (cpushack.com)
        which is part one of a two-part series.
        </p><p>After the Novix, came a variety of chip projects:
        </p><ul>
            <li><b>Sh-Boom</b> (32-bit, 20 Mips),
            </li><li><b>MuP20/MuP21</b> (21-bit, 100 Mips),
            </li><li><b>F21</b> (500 Mips - and be sure to check out
                <a href="http://www.ultratechnology.com/scope.htm">F21 in a Mouse</a>
               (ultratechnology.com), which is a complete F21 computer running a
               graphical environment that has been packed
               into a PC mouse...in the Pentium era!)
            </li><li><b>i21</b> (21-bit, 55 Mips)
            </li><li><b>X18</b> (18-bit, 2400 Mips)
        </li></ul>
        <p>These are all real systems that really worked. The hard part has always
        been finding customers.
        </p><p>Over the years, other people have also created Forth chips and FPGA
        implementations of hardware Forth-likes. Check out the links on
        <a href="http://forth.org/cores.html">Forth CPU Cores</a>
        (forth.org)
        and
        <a href="http://www.ultratechnology.com/chips.htm">Forth Chips</a>
        (ultratechnology.com).
        </p><p>In addition to
        <span>color</span><span>Forth</span>,
        Moore also developed <b>&#34;Machine Forth&#34;</b> as an even <em>more</em>
        machine-sympathetic language than traditional Forth. It&#39;s based on
        the machine code of the MuP21 microprocessor listed above.
        </p><p>I won&#39;t go into a lot of detail about Machine Forth, but
        here are some interesting links:
        </p><ul>
            <li><a href="http://www.ultratechnology.com/mfp21.htm">MuP21 Machine Forth Tutorial #1 </a>
                (ultratechnology.com)
            </li><li><a href="http://www.ultratechnology.com/p21intro.html">P21Forth 1.02 User&#39;s Manual</a>
                (ultratechnology.com)
            </li><li><a href="https://www.complang.tuwien.ac.at/anton/euroforth/ef99/thomas99a.pdf">Machine Forth for the ARM processor (PDF)</a>
                (tuwien.ac.at)
            </li><li><a href="https://github.com/CCurl/MachineForth">MachineForth - Inspired by Chuck Moore&#39;s &#34;Machine Forth&#34; and the MuP21 processor.</a>
                (github.com)
            </li><li><a href="https://jjn.one/forth/machine-forth/">Machine Forth (links and bibliography)</a>
                (jjn.one)
        </li></ul>
        <p>As you can see, Moore has always been looking for new ways to work
        with computers, a partnership between the machine and the programmer.
        </p><p>Which brings us to the current state of Chuck Moore&#39;s art...
	</p></div>
</div>

<div>
    
    <p>&#34;Programming a 144-computer chip to minimize power&#34; (2013)
	<img src="https://ratfactor.com/forth/talkimg/greenarrays_144_computers.jpg" alt="screenshot from Chuck&#39;s 2013 strange loop talk about 144 computer chip"/>
	</p><p>144 asynchronous computers on a chip. Idle cores use 100 nW. Active ones use 4 mW, run at 666 Mips, then return to idle. All computers running flat out: 550mW (half a Watt).

	</p><div>
        <p>Check out Chuck&#39;s talk at StrangeLoop:
		    <a href="https://www.youtube.com/watch?v=0PclgBd6_Zs">Programming a 144-computer chip to minimize power - Chuck Moore (2013)</a>
            (youtube.com)
		</p><p>And here&#39;s the official website:
        <a href="https://www.greenarraychips.com/">GreenArrays, Inc.</a>
        (greenarraychips.com)
        &#34;Ultra-low-powered multi-computer chips with integrated
            peripherals.&#34;
        </p><p>Probably the best summary comes from the architecture document,
<a href="https://www.greenarraychips.com/home/documents/greg/PB002-100822-GA-Arch.pdf">GreenArrays Architecture (PDF)</a>
        (greenarraychips.com):
        </p><blockquote>
            &#34;<b>COMPLETE SYSTEMS:</b> We refer to our chips as Multi-Computer Systems because they are, in fact, complete systems. Supply one of our chips with power and a reset signal, and it is up and running. All of our chips can load their software at high speed using a single wire that can be daisy chained for multiple chips; if desired, most can be bootstrapped by a simple SPI flash memory.
            <p>&#34;Contrast this with a Multi-Core CPU, which is not a computing system until other devices such as crystals, memory controllers, memories, and bus controllers have been added.  All of these things consume energy, occupy space, cost money, add complexity, and create bottlenecks.
            </p><p><b>&#34;NO CLOCKS:</b> Most computing devices have one or more clocks that synchronize all operations. When a conventional computer is powered up and waiting to respond quickly to stimuli, clock generation and distribution are consuming energy at a huge rate by our standards, yet accomplishing nothing.&#34;
        </p></blockquote>
        <p>It goes on to explain the fine-grained power usage, how each computer
        communicates with its neighbor, and similar statements high-level
        descriptions.
        </p><p>You can buy these chips right now for as little as $20 in quantities
        of 10. The only problem is that to easily make to use of one, you either
        need to buy the $495 development board or make your own. I&#39;ve found
        precious few examples of people who have done this online.
        </p><p>One rare example is
        <a href="https://web.archive.org/web/20121004044707/http://www.designspark.com/content/hands-144-core-processor">Hands on with a 144 core processor</a>
        (archive.org <i>of designspark.com</i>).
        Article author Andrew Back even has screenshots of the of the
        arrayForth environment (which is basically
        <span>color</span><span>Forth</span>)
        </p><p>The question, of course, is <em>what do you do with this thing?</em>
        </p><p>It may turn out that the answer can be found by looking back into
        computing history. You don&#39;t even have to go back very far.
        </p><p>If you read the &#34;Rabbit Hole Alert&#34; under the picture of the surface
        of comet 67p above, then you saw the term &#34;transputer&#34;.
        I think it would be very interesting to compare and contrast the
        GreenArrays GA144 chips to the Inmos transputer chips.
        It seems to me, at first glance, that anything those transputers would
        have been suited for ought to be a good fit for a GreenArrays multi-computer chip
        as well.
        </p><hr/>
        <p><b>Rabbit Hole Alert 2:</b> Another fun diversion into massively parallel
        computers is one of my favorites: Danny Hillis&#39;s
        <a href="https://en.wikipedia.org/wiki/Connection_Machine">Connection Machine</a>
        (wikipedia.org)
        computers featuring a &#34;12-dimensional hypercube&#34; routing design.
        </p><p>Hillis himself is a &#34;human rabbit hole&#34; of inventions, ideas, and
        writings. He&#39;s the author of one of my favorite non-fiction books, &#34;The
        Pattern on the Stone,&#34; and co-founder of The Long Now Foundation
        (along with some other &#34;human rabbit holes&#34; including the incredible
        writer and thinker, Steward Brand).
        </p><p>One of the projects of the Long Now
        Foundation is the design and creation of the 10,000 year giant
        mechanical <i>Clock of the Long Now</i> which is intended to tick once
        per year and have a cuckoo that comes out once every 1,000 years.
        </p><p>There is also a direct connection between the Long Now and the
        Rosetta spacecraft: Long Now created the &#34;Rosetta disc&#34;, an extremely
        clever physical object containing the micro-etched text of over
        a thousand human languages. The Rosetta spacecraft carried a nickel
        prototype of the disc. So that&#39;s now sitting on a comet.
        </p><p>As with the previous rabbit hole alert, I could link to all of these
        people and things, but each is part of an unfathomably deep fractal of
        fascinating stuff and I&#39;m afraid you might never come back to finish
        this. But do look them up later!
        </p><hr/>
        <p>At any rate, 
        </p><p>The only problem with parallel computers is that we&#39;re still
        not that great at programming them.
        </p><p>Heck, we&#39;re not even that great at serial programming yet.
	</p></div>
</div>

<div>
    
    <p>&#34;If you talk about molecular computers that are circulating in your bloodstream, they aren&#39;t going to have very much power and they aren&#39;t going to have very much memory and they aren&#39;t going to be able to use much energy.
    </p><p>-- Chuck Moore, <i>Programming a 144-computer chip to minimize power</i>, 2013

    </p><div>
        <p>The eventual complete domination of x86 PCs in practically all areas
        of computing, followed by the current rise of powerful ARM CPUs are
        historical computing fact.  Incredible feats of processor engineering
        have made it possible to run what can only be described as
        &#34;supercomputers&#34; on battery power and put them in our pockets.
        </p><p>Trends in both software and hardware have been towards
        ever-increasing layers of complexity.  The layers are very deep and
        very wide.
        </p><p>As I write this, certain popular avenues of computing threaten to
        make every current piece of inefficient software seem absolutely
        <em>frugal</em> by comparison.
        </p><p><i>(Incredibly, we&#39;re not even content with the
            supercomputers on our desks and in our hands. So we rely on
            services which work remotely over the Internet on powerful networks
            of computers in huge data centers. We think of this computing as
            cheap or even free because much of it is indirectly paid for with
            advertising dollars.  Paid for, that is, with our attention and
            personal data. Those data centers with their screaming cooling fans
            and backup generators are somewhere else, not in our living rooms.
            It&#39;s easy to simply forget how all of this is made possible.)</i>
        </p><p>Increasingly, we rely on massively complex software with that seems
        to have an unending appetite for computing power.
        </p><p><b>But do these trends have to continue?</b>
        </p><p>There is absolutely no reason we have to use increasingly
        inefficient and poorly-constructed software with steeper and steeper
        hardware requirements in the decades to come.
        </p><p>In fact, the reverse could be true.
        </p><p>There are plenty of applications where low energy computing is a
        categorical requirement and I believe these applications will only
        increase.
    </p></div>
</div>

<div>
    <p>Forth-likes could have a strong future as we look towards:
    </p><ul>
        <li>Tiny, ubiquitous computers
        </li><li>Solar power
        </li><li>Heavily constrained VMs
    </li></ul>

    <div>
        <p>There are physical realities (such as the speed of light) which
        ultimately govern the speed at which we can perform a calculation or
        the maximum number of calculations which can be done with a Watt of
        electricity using computers made out of atoms. These are hard limits.
        But there will surely be other plateaus along the way to reaching these
        limits.
        </p><p>Around the year 2006, we saw Dennard scaling
        slow to a crawl.
        <a href="https://en.wikipedia.org/wiki/Dennard_scaling">Dennard scaling</a>
        (wikipedia.org)
         describes the relationship between
        the shrinking size of transistors to the increase of computing speed.
        Simply put, smaller transistors can switch at higher speeds and take
        less voltage.  This scaling law held for many years.  But we reached a
        speed plateau at around 4 GHz because of current leakage and heat.
        </p><p>In
        <a href="http://www.gotw.ca/publications/concurrency-ddj.htm">The Free Lunch Is Over</a>
        (gotw.ca),
        published in Dr. Dobb&#39;s Journal in 2005, Herb Sutter writes,
        </p><blockquote>
            &#34;The major processor manufacturers and architectures, from Intel
            and AMD to Sparc and PowerPC, have run out of room with most of
            their traditional approaches to boosting CPU performance. Instead
            of driving clock speeds and straight-line instruction throughput
            ever higher, they are instead turning en masse to hyperthreading
            and multicore architectures.&#34;
        </blockquote>
        <p>Multicore processors and increasingly clever hardware architecture
        tricks have continued to provide increases in computing power...but it&#39;s
        not the same.
        </p><p>Near the end of the article, Sutter advises:
        </p><blockquote>
            <p>&#34;There are two ways to deal with this sea change toward
            concurrency. One is to redesign your applications for concurrency,
            as above. <b>The other is to be frugal, by writing code that is more
            efficient and less wasteful.</b> This leads to the third interesting
            consequence:
            </p><p>&#34;3. Efficiency and performance optimization will get more, not less, important.
            <b>Those languages that already lend themselves to heavy optimization will find new life</b>; those that don&#39;t will need to find ways to compete and become more efficient and optimizable. Expect long-term increased demand for performance-oriented languages and systems.&#34;
        </p></blockquote>
        <p>(Emphasis mine.)
        </p><p>For now, we&#39;re still eating the remains of that free lunch.
        </p><p>I&#39;m probably fairly rare among programmers in wishing it would end.
        I&#39;d like to see greater emphasis on the craft and art of software.
        I&#39;d like to see us make full and intentional use of the incredible
        power available to us now.
        </p><p>The
        <a href="https://en.wikipedia.org/wiki/Retrocomputing">retrocomputing</a>
        (wikipedia.org)
        hobby has continually shown how much more we could have done with the
        home computers of the 1980s if we had continued to use them.
        In many cases, they&#39;ve been shown to be able to run programs
        previously thought impossible.
        The things we could do with <em>current</em> hardware are surely
        even more amazing, but it will be perhaps decades before we find
        out.
        <img src="https://ratfactor.com/forth/talkimg/ibm_704.png" alt="chuck moore operating an IBM 704"/>
        </p><p>In 1958, Chuck Moore created a dirt-simple interpreter on an
        IBM 704. That computer filled a room and cost about 2 million dollars.
        </p><p>I can buy a more powerful computer (minus the awesome control panel
        with lights and switches) today for literal <em>pocket change</em>
        in the form of a &#34;microcontroller&#34;, a complete computer on a single
        silicon chip, and write a powerful Forth system for it. That computer
        can run on a coin cell battery or even a tiny solar panel, sipping power
        where the IBM 704 inhaled it.
        </p><p>There has never been a more incredible time for small-scale computing.
        Like the explosion of personal computers in the 1980s, the time is ripe
        for fun, creative, interesting, useful, and very <em>personal</em>
        computers and software.
        </p><p>These tools can do useful work and they can also teach and delight us.
        Ideas like Forth are ripe for rediscovery as we learn exciting new
        ways to compute with arrays of inexpensive, low-power computers.
        </p><p>We can pursue this line of thinking for pragmatic reasons, or just
        because it is beautiful and fun and worth doing for its own sake.
    </p></div>
</div>

<div>
    <p>Chuck Moore is basically retired now, programming and toying with
    software with no deadlines or clients.
    </p><p>It is now on us to take up the mantle of Forth, to champion the values
    of ingenuity, elegance, efficiency, and simplicity.
    
    </p><h2>Forth is...</h2>

    <div>
        <p><b>Simple</b>
        </p><p>To really understand the value of Forth (and <em>especially</em> Chuck Moore&#39;s
        later work on Machine Forth and the GreenArrays computers), we must consider the
        difference between <b>&#34;simple&#34;</b> and <b>&#34;easy&#34;</b>.
        </p><p>We were blessed with the ability to speak of this difference by
        Rich Hickey in his brilliant talk,
        <a href="https://www.youtube.com/watch?v=SxdOUGdseq4">&#34;Simple Made Easy&#34; (2011)</a>
        (youtube.com)
        which every developer should see at some time in their life.
        (Or read <a href="https://github.com/matthiasn/talk-transcripts/blob/master/Hickey_Rich/SimpleMadeEasy.md">the transcript of Simple Made Easy</a>
        (github.com)
        provided by Mattias Nehlsen.)
        </p><p>Forth is not easy. It may not always even be pleasant. But it is certainly simple.
        Forth is one of the <em>simplest</em> programming languages there has ever been.
        </p><p><b>A crafted language</b>
        </p><p>If the best software is truly crafted for problem at hand, then
        it makes sense that an idea programming language would also be
        crafted for the problem at hand.
        </p><p>An absolutely amazing talk about language design,
        Guy Steele&#39;s
        <a href="https://www.youtube.com/watch?v=_ahvzDzKdB0">Growing a Language (1998)</a>
        (youtube.com)
        demonstrates how languages are built up from primitives.
        The talk is a performance art and deeply insightful.
        </p><p>Steele helpfully also wrote up a transcript of the talk:
        <a href="https://www.cs.virginia.edu/~evans/cs655/readings/steele.pdf">Growing a Language (PDF)</a>
        (virginia.edu)
        Imagine Steele is saying &#34;Forth&#34; here in place of &#34;Lisp&#34; because
        the point is the same:
        </p><blockquote>
            &#34;Lisp was designed by one man, a smart man, and it works in a way
            that I think he did not plan for. In Lisp, new words defined by the
            user look like primitives and, what is more, all primitives look
            like words defined by the user! In other words, if a user has good
            taste in defining new words, what comes out is a larger language
            that has no seams.&#34;
        </blockquote>
        <p>Go <em>forth</em> and create the perfect
        programming language for <em>you</em>!
    </p></div>
</div>

<div>
    
    <p><img src="https://ratfactor.com/forth/talkimg/wizard_chuck.png" alt="chuck moore as an adorable wizard"/></p><p>I promised I would show you a magic trick at the end of this article.
    </p><p>Behold, a new definition for the integer 4:
    </p><pre>: 4 12 ;
    </pre>
    <p>Which I shall now use in a sentence:
    </p><pre>.&#34; The value of 4 is &#34; 4 . CR

<b>The value of 4 is 12</b>
    </pre>
    <p><b>Tada!</b>
</p></div>




</div></div>
  </body>
</html>
