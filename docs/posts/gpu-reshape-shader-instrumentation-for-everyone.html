<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gpuopen.com/learn/introducing-gpu-reshape-shader-instrumentation-toolset/">Original</a>
    <h1>GPU Reshape – shader instrumentation for everyone</h1>
    
    <div id="readability-page-1" class="page"><div data-id="3cfd864" data-element_type="widget" data-widget_type="theme-post-content.default">
				<div>
			<div role="main">
<section id="introducing-gpu-reshape-shader-instrumentation-for-everyone"><a href="https://avalanchestudios.com/"><img width="800" height="262" decoding="async" src="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20width=&#39;800&#39;%20height=&#39;262&#39;%20viewBox=&#39;0%200%20800%20262&#39;%3E%3C/svg%3E" alt="invert" data-src="https://gpuopen.com/wp-content/uploads/2023/10/Avalanche_Studios_Group_Hori_RGB_Black_800px.png"/></a>
<section id="introduction">
<h2 id="introduction">Introduction</h2>
<p>Modern APIs are rapidly growing in complexity, with each added feature introducing more responsibility and risk. Typically, the first tool we turn to is the standard set of validation layers, to ensure we write specification compliant code. However, what if the problem persists despite the lack of validation errors?</p>
<p>The error could be due to dynamic shader behaviour on the GPU that cannot be statically validated on the CPU timeline. If so, this can result in hours-long debugging sessions to find the one culprit among a heap of operations. Potential issues include indices getting out of bounds, propagated NaN values across multiple stages, or a missing initialization and the resulting access of invalid data.</p>
<p>Have you ever wished for a tool that helps you in finding these types of errors and validates dynamic shader behaviour on the GPU?</p>
<p>Meet <a href="https://gpuopen.com/gpu-reshape/">GPU Reshape</a>, a toolset that leverages on-the-fly instrumentation of GPU operations with instruction-level validation of potentially undefined behavior, supporting both DX12 and Vulkan. A standalone desktop application with no integration required, all open source (MIT), is now available in Beta.</p>
<p><img decoding="async" src="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20width=&#39;0&#39;%20height=&#39;0&#39;%20viewBox=&#39;0%200%200%200&#39;%3E%3C/svg%3E" alt="ArticleCover.png" data-src="/docs_images/gpu_reshape/gpu_reshape-html-_images-ArticleCover.png"/></p>
<p>My name is <a href="https://twitter.com/miguel_oenp" target="_blank" rel="noopener">Miguel Petersen</a>, Senior Rendering Engineer at Striking Distance Studios, author of GPU Reshape.</p>
<p>The toolset was developed in collaboration with AMD and Avalanche Studios Group, initially as a proof-of-concept Vulkan layer at Avalanche, after which development was continued externally. Development was supported by Lou Kramer, Jonas Gustavsson, Rys Sommefeldt, Mark Simpson, Marek Machliński, Daniel Isheden, and William Hjelm. Thank you all.</p>
</section>
<section id="making-the-gpu-a-first-class-citizen">
<h2 id="making-the-gpu-a-first-class-citizen">Making the GPU a first class citizen</h2>
<p>GPU Reshape brings powerful features typical of CPU tooling to the GPU, providing validation of dynamic behaviour, such as:</p>
<ul>
<li><strong>Resource Bounds</strong> Validation of resource read / write coordinates against its bounds.</li>
<li><strong>Export Stability</strong> Numeric stability validation of floating point exports (UAV writes, render targets, vertex exports), e.g. NaN / Inf.</li>
<li><strong>Descriptor Validation</strong> Validation of descriptors, potentially dynamically indexed. This includes undefined, mismatched (compile-time to runtime), out of bounds descriptor indexing, and missing table bindings.</li>
<li><strong>Concurrency Validation</strong> Validation of resource concurrency, i.e. single-producer or multiple-consumer, between queues and events.</li>
<li><strong>Resource Initialization</strong> Validation of resource initialization, ensures any read was preceded by a write. (*1)</li>
<li><strong>Infinite Loops</strong> Detection of infinite loops. <em>Experimental</em>.</li>
</ul>
<p>All at interactive frame rates.</p>
<p>Additionally, certain features, such as descriptor validation and loops, can safeguard a potentially erroneous operation, preventing undefined behaviour during instrumentation. This is especially useful if the error would result in a GPU crash, limiting the application’s ability to write out useful debug information of the issue.</p>
<p>Validation errors are reported on the exact line of source code, with, for example, the resource, dimensions, and coordinates accessed. GPU Reshape is agnostic to the front-end language, such as HLSL or GLSL, as it functions solely on the instructions and associated symbols.</p>
<p><img decoding="async" src="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20width=&#39;0&#39;%20height=&#39;0&#39;%20viewBox=&#39;0%200%200%200&#39;%3E%3C/svg%3E" alt="FirstClassSourceZoom.png" data-src="/docs_images/gpu_reshape/gpu_reshape-html-_images-FirstClassSourceZoom.png"/></p>
<p>In case symbols are not available, or are not desired, validation errors may be reported on the offending instruction instead. The instruction stream is that of the internal intermediate language, see <a href="#instrumentation-as-a-framework">Instrumentation as a Framework</a> for details.</p>
<p><img decoding="async" src="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20width=&#39;0&#39;%20height=&#39;0&#39;%20viewBox=&#39;0%200%200%200&#39;%3E%3C/svg%3E" alt="FirstClassILZoom.png" data-src="/docs_images/gpu_reshape/gpu_reshape-html-_images-FirstClassILZoom.png"/></p>
<p>Debugging symbols are supported for both SPIR-V and DXIL (DXBC planned), either embedded or through externally hosted PDBs. GPU Reshape does not require debugging symbols to produce useful information, however, symbols greatly improve the tools ability to track down issues.</p>
</section>
<section id="integration-free">
<h2 id="integration-free">Integration free</h2>
<p>Out of the box usage requires no integration, and can be done in a few clicks. Applications may be attached to after launching, or can be launched from the toolset with the desired workspace. Workspaces represent a graphics (API) device connection, and contain all instrumentation states, shaders, pipelines, and validation data.</p>
<p>Connecting to existing applications is an opt-in feature that greatly improves the ease of usability. Additionally, if configured, GPU Reshape can connect to running applications across network boundaries, allowing developers to instrument, for example, an artists machine as the corruption is happening. This is in contrast to spending, potentially, hours reproducing the issue.</p>
<p><img decoding="async" src="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20width=&#39;0&#39;%20height=&#39;0&#39;%20viewBox=&#39;0%200%200%200&#39;%3E%3C/svg%3E" alt="IntegrationLaunch.png" data-src="/docs_images/gpu_reshape/gpu_reshape-html-_images-IntegrationLaunch.png"/></p>
<p>After an application has been launched with the specified workspace, instrumentation occurs immediately. Any validation error can be inspected in further detail by double clicking it.</p>
<p><img decoding="async" src="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20width=&#39;0&#39;%20height=&#39;0&#39;%20viewBox=&#39;0%200%200%200&#39;%3E%3C/svg%3E" alt="IntegrationWorkspace.png" data-src="/docs_images/gpu_reshape/gpu_reshape-html-_images-IntegrationWorkspace.png"/></p>
<p>Instrumentation can be changed on the fly, and can be specialized on a per shader and pipeline basis, there are no restrictions on how a workspace may be configured. If the application is connected to after launching, this is a common pattern.</p>
<p>The toolset aims to bring you as much information as possible in order to investigate and resolve faults, with interactive instrumentation of applications in a matter of seconds. However, under the hood GPU Reshape is a little more than a fixed toolset.</p>
</section>
<section id="instrumentation-as-a-framework">
<h2 id="instrumentation-as-a-framework">Instrumentation as a framework</h2>
<p>GPU Reshape is, at its core, a modular API-agnostic instrumentation framework. Performing appropriate call hooking, instrumentation of shader code, and any additional state management CPU-side.</p>
<p>Shader instrumentation is done on a generalized <a href="https://en.wikipedia.org/wiki/Static_single-assignment_form" target="_blank" rel="noopener">SSA-based</a> intermediate language. It’s a custom intermediate language, specifically written for GPU Reshape and is bi-directionally translated to the backend language – namely SPIR-V and DXIL (DXBC experimental). Each feature, such as validation of out-of-bounds reads / writes, operates solely on the intermediate language and has no visibility on neither backend language nor API.</p>
<div>
<div>

<pre><code><span>// Emitters take care of creating instructions  </span>
<span>IL</span><span>::</span><span>Emitter</span> <span>emitter</span><span>(</span><span>program</span><span>,</span> <span>context</span><span>.</span><span>basicBlock</span><span>);</span>    

<span>// any(coordinates &gt; buffer.GetDimensions())  </span>
<span>IL</span><span>::</span><span>ID</span> <span>failureCondition</span> <span>=</span> <span>emitter</span><span>.</span><span>Any</span><span>(</span><span>emitter</span><span>.</span><span>GreaterThanEqual</span><span>(</span>  
    <span>loadBuffer</span><span>-&gt;</span><span>index</span><span>,</span>  
    <span>emitter</span><span>.</span><span>ResourceSize</span><span>(</span><span>loadBuffer</span><span>-&gt;</span><span>buffer</span><span>)</span>  
<span>));</span>    

<span>// Branch to error block if the condition failed, otherwise resume block  </span>
<span>emitter</span><span>.</span><span>BranchConditional</span><span>(</span>  
    <span>failureCondition</span><span>,</span>
    <span>errorBlock</span><span>,</span>
    <span>resumeBlock</span><span>,</span>
    <span>IL</span><span>::</span><span>ControlFlow</span><span>::</span><span>Selection</span><span>(</span><span>resumeBlock</span><span>)</span>  
<span>);</span>
</code></pre>
</div>
</div>
<p>Decoupling features from backends through a custom intermediate language has a number of benefits. It keeps permutations low, as features do not need an implementation per backend, and introducing backends does not require feature changes. As the number of features and backends grows, this becomes paramount. The intermediate language also allows for a standardized toolset across backends, significantly lowering the complexity of writing instrumentation code. On top of this, the bi-directional translation is single layered, meaning it’s translated to and from the backend binaries directly, without other intermediate languages. This greatly improves translation speeds. A typical shader is instrumented in just a few milliseconds, although this varies based on shader complexity.</p>
<p>Each feature can alter the program as it sees fit, such as adding, removing and modifying instructions. The feature is given a shader “program”, which act as the abstraction for the active backend, from which the user has access to all functions, instructions, constants, types, etc…, and is able to modify as necessary. After modification, the backend then performs just-in-time recompilation of the modified program back to the backend language.</p>
<p>Features do not need to concern themselves with backend specifics, such as vectorized versus scalarized execution, control-flow differences, and other implementation details. Given compliance, each feature will translate seamlessly to the backend language.</p>
</section>
<section id="an-open-collaboration">
<h2 id="an-open-collaboration">An open collaboration</h2>
<p><img decoding="async" src="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20width=&#39;0&#39;%20height=&#39;0&#39;%20viewBox=&#39;0%200%200%200&#39;%3E%3C/svg%3E" alt="CollaborationCover.png" data-src="/docs_images/gpu_reshape/gpu_reshape-html-_images-CollaborationCover.png"/></p>
<p>GPU Reshape aims to serve as a framework for instrumentation, acting as a modular base from which any number of tools, techniques, and optimizations can be implemented. With the standard validation layers, validating statically known behaviour, GPU Reshape acts as an entirely complimentary toolset covering dynamic behaviour on the GPU.</p>
<p>It is my hope, with time, it matures and evolves into a general purpose tool. In fact, there’s a number of potentially planned additions, such as:</p>
<ul>
<li>Shader debugging, providing the ability to inspect live data as the shader sees it.</li>
<li>Shader assertions, in source assertions typical of CPU code.</li>
<li>Branch hot spots, live hot spot profiling of all branches.</li>
<li>Branch coherence, live coherence analysis of all branches.</li>
<li>And more!</li>
</ul>
<p>Join us over at <a href="https://github.com/GPUOpen-Tools/GPU-Reshape" target="_blank" rel="noopener">Github</a>. Collaboration, discussion, and bug reporting is most welcome!</p>
</section>
<section id="requirements">
<h2 id="requirements">Requirements</h2>
<p><strong>Supported APIs</strong></p>
<ul>
<li>DirectX® 12</li>
<li>Vulkan®</li>
</ul>
<p><strong>Supported IRs</strong></p>
<ul>
<li>SPIR-V</li>
<li>DXIL</li>
<li>DXBC (*2)</li>
</ul>
<p><strong>Supported GPUs</strong></p>
<ul>
<li>All vendors supported</li>
</ul>
<p><strong>Required Driver</strong></p>
<ul>
<li>For AMD GPUs: Latest AMD Software: Adrenalin Edition™ application software driver (minimum version 23.10.2)</li>
</ul>
<p><strong>Supported OSs</strong></p>
<ul>
<li>Windows® 10</li>
<li>Windows® 11</li>
</ul>
<p>Linux® support is a planned addition.</p>
<p>*1 – May exhibit some false positives in large applications, in particular with aliasing. Will be fixed.</p>
<p>*2 – Experimental, converted to DXIL internally. Native support being considered.</p>
<p><em>Avalanche Studios Group and the Avalanche Studios Group logo are trademarks of the Avalanche Studios Group.</em></p>
</section>
</section>
</div>
		</div>
				</div></div>
  </body>
</html>
