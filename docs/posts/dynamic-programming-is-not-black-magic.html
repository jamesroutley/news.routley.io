<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://qsantos.fr/2024/01/04/dynamic-programming-is-not-black-magic/">Original</a>
    <h1>Dynamic programming is not black magic</h1>
    
    <div id="readability-page-1" class="page"><div>

		<div>

			
<p>This year’s <a href="https://en.wikipedia.org/wiki/Advent_of_Code">Advent of Code</a> has been brutal (compare the <a href="https://adventofcode.com/2023/stats">stats of 2023</a> with <a href="https://adventofcode.com/2022/stats">that of 2022</a>, especially day 1 part 1 vs. day 1 part 2). It included a problem to solve with dynamic programming as soon as day 12, which discouraged some people I know. This specific problem was particularly gnarly for Advent of Code, with multiple special cases to take into account, making it basically intractable if you are not already familiar with dynamic programming.</p>



<p>However, dynamic programming itself is mostly natural when you understand what it does. And <a href="https://en.wikipedia.org/wiki/Dynamic_programming#Algorithms_that_use_dynamic_programming">many common algorithms are actually just the application of dynamic programming to specific problems</a>, including omnipresent path-finding algorithms such as Dijkstra’s algorithm.</p>



<p>This motivated me to write a gentler introduction and a detailed explanation of solving Day 12.</p>



<p>Let me start with a rant. You can <a href="#basic-caching">skip to the following section</a> if you want to get to the meat of the article.</p>



<h2>The Rant</h2>



<p>Software engineering is terrible at naming things.</p>



<ul>
<li>“<strong>Bootstrap</strong>” is an <a href="https://en.wikipedia.org/wiki/Bootstrapping">imaged expression to point to the absurdity and impossibility of a task</a>, but it has become synonymous with “start” without providing any additional information, <a href="https://en.wiktionary.org/wiki/bootstrap#Verb">such as “boot a computer”</a>. The illusion that it is actually meaningful had lead to an <a href="https://en.wikipedia.org/wiki/Bootstrapping_(disambiguation)">absurd level of polysemy</a>.</li>



<li>“<strong>Daemon</strong>”, for a process that is detached from your terminal</li>



<li>“<strong>Cascading Style Sheets</strong>”, just to mean that properties can be overridden</li>



<li>“<strong>Cookie</strong>”, for a piece of data stored on the Web browser, which is automatically sent to the server</li>



<li>“<strong>Artificial Intelligence</strong>” which is so vague it refers just as well to <a href="https://en.wikipedia.org/wiki/Expert_system">if-conditions</a>, or to <a href="https://en.wikipedia.org/wiki/Artificial_general_intelligence">AGI</a></li>
</ul>



<p>Now, let’s take a look at “<strong>dynamic programming</strong>”. What can we learn from the name? “<strong>Programming</strong>” must refer to a style of programming, such as “functional <em>programming</em>”, or maybe “test-driven <em>development</em>”. Then, “<strong>dynamic</strong>” could mean:</p>



<ul>
<li>like in <strong>dynamic typing</strong>, maybe it could refer to the more general idea of handling objects of arbitrary types, with techniques such as <a href="https://en.wikipedia.org/wiki/Virtual_function">virtual classes</a>, <a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html">trait objects</a>, or a <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html">base Object type</a>.</li>



<li>maybe it could be the opposite of preferring <a href="https://en.wikipedia.org/wiki/Immutable_object">immutable state</a></li>



<li>if it’s not about data, maybe it could be about dynamic <em>code</em>, such as <a href="https://en.wikipedia.org/wiki/Self-modifying_code">self-modifying code</a>, or <a href="https://en.wikipedia.org/wiki/Just-in-time_compilation">JIT</a></li>



<li>maybe it could be yet another framework such as <a href="https://en.wikipedia.org/wiki/Agile_software_development">Agile</a>, <a href="https://en.wikipedia.org/wiki/Scrum_(software_development)">SCRUM</a>, <a href="https://en.wikipedia.org/wiki/Extreme_programming">XP</a>, <a href="https://en.wikipedia.org/wiki/V-model_(software_development)">V-model</a>, <a href="https://en.wikipedia.org/wiki/Round-trip_engineering">RTE</a>, <a href="https://en.wikipedia.org/wiki/Rapid_application_development">RAD</a></li>



<li>maybe it could be referring to using practices from <a href="https://en.wikipedia.org/wiki/Competitive_programming">competitive programming</a>? Yes, it’s a stretch, but that might make sense</li>
</ul>



<p>Guess what. It means nothing of that, and it has nothing to do with being “dynamic”. It <em>is</em> an idea that you can use to design an algorithm, so there is a link to “programming”; I will grant it that.</p>



<p><strong>Edit:</strong> There is a reason why it is named this way. When you look at the historical meaning of “programming”, the expression made sense. See <a href="https://qsantos.fr/2024/01/04/dynamic-programming-is-not-black-magic/#comment-1737">niconiconi’s comment</a>.</p>



<p>So, what <em>is</em> it?</p>



<h2 id="basic-caching">Basic Caching</h2>



<p>Let’s say we want to solve a problem by splitting it in smaller similar problems. Basically, a recursive function. Often, we end-up having to solve the same smaller problems many times.</p>



<p>The typical example is Fibonacci, where you want to evaluate <code>f(n)</code>, which is defined as <code>f(n - 1) + f(n - 2)</code>. If we implement it naively, we will end up evaluating f(1) many times:</p>



<figure><img fetchpriority="high" decoding="async" width="925" height="404" src="https://qsantos.fr/wp-content/uploads/2024/01/image.png" alt=""/><figcaption>Call tree for evaluating f(6), the 6-th Fibonacci number. To evaluate, f(6), we need to evaluate both f(5) and f(4). To evaluate f(5), we will need f(4) and f(3). Already, we see that we are going to need f(4) in two places. If we go further, we see that we will need f(1) 8 eight times, which happens to be f(6).</figcaption></figure>



<p>In fact, in this case, since only <code>f(1)</code> adds anything to the overall result, the number of times we will need <code>f(1)</code> is equal to <code>f(n)</code>. And <code>f(n)</code> grows very fast as <code>n</code> grows.</p>



<p>Of course, we can avoid doing this. We can just cache the results (or <a href="https://en.wikipedia.org/wiki/Memoization">memoize</a> <code>f</code>, in terrible academic vernacular).</p>



<p>In the example, once we have evaluated <code>f(4)</code> once, there is no need to evaluate it again, saving 3 evaluations of <code>f(1)</code>. By doing the same for <code>f(3)</code> and <code>f(2)</code>, we get down to 2 evaluations of <code>f(1)</code>. In total, <code>f(…)</code> is evaluated 7 times (<code>f(0)</code>, <code>f(1)</code>, <code>f(2)</code>, <code>f(3)</code>, <code>f(4)</code>, <code>f(5)</code>, <code>f(6)</code>), which is just f(n) + 1.</p>



<p>This is theoretically (<em>asymptotically</em>) optimal. But we can look at this in a different way.</p>



<h2>Optimized Caching</h2>



<p>With memoization, we keep the recursion: “to solve <code>f(6)</code>, I need <code>f(5)</code>, which will itself need <code>f(4)</code> […] and <code>f(3)</code> […], and <code>f(4)</code>, which will itself need <code>f(3)</code> […] and <code>f(2)</code> […].”. Basically, we figure out what we need just when we need them.</p>



<p>Instead, we can make the simple observation that we will need <em>f(0)</em> and <em>f(1)</em> for all other evaluations of <em>f(…)</em>. Once we have them, we can evaluate <em>f(2)</em>, which will need for all <em>other</em> evaluations of <em>f(…)</em>. </p>



<p>You can think of it as plucking the leaves (the nodes without descendants) from the call tree we saw before, and repeat until there are no more nodes. In other words, perform a <a href="https://en.wikipedia.org/wiki/Topological_sorting">topological sort</a>.</p>



<p>With the example, if we have some array F where we can store our partial results:</p>



<ul>
<li>F[0] = f(0) = 0</li>



<li>F[1] = f(1) = 1</li>



<li>F[2] = f(2) = f(1) + f(0) = F[1] + F[0] = 1 + 0 = 1</li>



<li>F[3] = f(3) = f(2) + f(1) = F[2] + F[1] = 1 + 1 = 2</li>



<li>F[4] = f(4) = f(3) + f(2) = F[3] + F[2] = 2 + 1 = 3</li>



<li>F[5] = f(5) = f(4) + f(3) = F[4] + F[3] = 3 + 2 = 5</li>



<li>F[6] = f(6) = f(5) + f(4) = F[5] + F[4] = 5 + 3 = 8</li>
</ul>



<p>With this approach, we do not have any recursive call anymore. And <em>that</em> is <strong>dynamic programming</strong>.</p>



<p>It also forces us to think clearly about what information we will be storing. In fact, in the case of Fibonacci we can notice that we only need the two last previous values. In other words:</p>



<ul>
<li>F[0] = f(0) = 0</li>



<li>F[1] = f(1) = 1</li>



<li>F[2] = f(2) = previous + previous_previous = 1 + 0 = 1</li>



<li>F[3] = f(3) = previous + previous_previous = 1 + 1 = 2</li>



<li>F[4] = f(4) = previous + previous_previous = 2 + 1 = 3</li>



<li>F[5] = f(5) = previous + previous_previous = 3 + 2 = 5</li>



<li>F[6] = f(6) = previous + previous_previous = 5 + 3 = 8</li>
</ul>



<p>So, we can discard other values and just keep two of them. Doing this in Python, we get:</p>



<pre><code lang="python">def fibo(n):
    if n == 0:
        return 0
    previous_previous = 0
    previous = 1
    for _ in range(n - 1):
        current = previous_previous + previous
        (previous, previous_previous) = (current, previous)
    return previous
</code></pre>



<p>I like that this gives us a natural and systematic progression from the mathematical definition of the Fibonacci function, to the iterative implementation (not the <a href="https://en.wikipedia.org/wiki/Fibonacci_sequence#Matrix_form">optimal one</a>, though).</p>



<p>Now, Fibonacci is more of a toy example. Let’s have a look at </p>



<h2>Edit Distance</h2>



<p>The edit distance between two strings is the smallest number of edits needed to transform one string into the other one.</p>



<p>There are actually several versions, depending on what you count as an “edit”. For instance, if you only allow replacing a character by another, you get <a href="https://en.wikipedia.org/wiki/Hamming_distance">Hamming distance</a>; evaluating the Hamming distance between two strings is algorithmically very simple.</p>



<p>Things become more interesting if you allow insertion and deletion of characters as well. This is the <a href="https://en.wikipedia.org/wiki/Levenshtein_distance">Levenstein distance</a>. Considering this title of the present article, this is of course something that can be solved efficiently using ✨ dynamic programming ✨.</p>



<p>To do that, we’ll need to find how we can derive a full solution from solutions to smaller-problems. Let’s say we have two strings: <code>A</code> and <code>B</code>. We’ll note <code>d(X, Y)</code> the edit distance between strings <code>X</code> and <code>Y</code>, and we’ll note <code>x</code> the length of string <code>X</code>. We need to formulate <code>d(A, B)</code> from any combination of d(X, Y) where <code>X</code> is a substring of <code>A</code> and <code>Y</code> a substring of <code>B</code><sup data-fn="4598dbdf-9a33-4bd6-976e-a06758eb4f07"><a href="#4598dbdf-9a33-4bd6-976e-a06758eb4f07" id="4598dbdf-9a33-4bd6-976e-a06758eb4f07-link">1</a></sup>.</p>



<p>We’re going to look at a single character. We’ll use the last one. The first one would work just as well but using a middle one would not be as convenient. So, let’s look at A[a – 1] and B[b – 1] (using zero-indexing). We have four cases:</p>



<ul>
<li><code>A[a - 1] == B[b - 1]</code>, then we can ignore that character and look at the rest, so <code>d(A, B) = d(A[0..a - 1], B[0..b - 1])</code></li>



<li><code>A[a - 1] != B[b - 1]</code>, then we could apply any of the three rules.  Since we want the smallest number of edits, we’ll need to select the smallest value given by applying each rule:
<ul>
<li><strong>substitute</strong> the last character of A by that of B, in which case <code>d(A, B) = d(A[0..a - 1], B[0..b - 1]) + 1</code></li>



<li><strong>delete</strong> the last character of <code>A</code>, in which case <code>d(A, B) = d(A[0..a - 1], B) + 1</code></li>



<li><strong>insert</strong> the last character of <code>B</code>, in which case <code>d(A, B) = d(A, B[0..b - 1]) + 1</code></li>
</ul>
</li>



<li>A is actually empty (<code>a = 0</code>), then we need to <strong>insert</strong> all characters from B<sup data-fn="fb0dcaf1-f2c3-4035-aa3e-9d14652cb2fa"><a href="#fb0dcaf1-f2c3-4035-aa3e-9d14652cb2fa" id="fb0dcaf1-f2c3-4035-aa3e-9d14652cb2fa-link">2</a></sup>, so <code>d(A, B) = b</code></li>



<li>B is actually empty (b = 0), then we need to <strong>delete</strong> all characters from A, so <code>d(A, B) = a</code></li>
</ul>



<p>By translating this directly to Python, we get:</p>



<pre><code lang="python">def levenstein(A: str, B: str) -&gt; int:
    a = len(A)
    b = len(B)
    if a == 0:
        return b
    elif b == 0:
        return a
    elif A[a - 1] == B[b - 1]:
        return levenstein(A[:a - 1], B[:b - 1])
    else:
        return min([
            levenstein(A[:a - 1], B[:b - 1]) + 1,
            levenstein(A[:a - 1], B) + 1,
            levenstein(A, B[:b - 1]) + 1,
        ])


assert levenstein(&#34;&#34;, &#34;puppy&#34;) == 5
assert levenstein(&#34;kitten&#34;, &#34;sitting&#34;) == 3
assert levenstein(&#34;uninformed&#34;, &#34;uniformed&#34;) == 1
# way too slow!
# assert levenstein(&#34;pneumonoultramicroscopicsilicovolcanoconiosis&#34;, &#34;sisoinoconaclovociliscipocsorcimartluonomuenp&#34;) == 36</code></pre>



<p>As hinted by the last test, this version becomes very slow when comparing long strings with lots of differences. In Fibonnacci, we were doubling the number of instances for each level in the call tree; here, we are tripling it!</p>



<p>In Python, we can easily apply memoization:</p>



<pre><code lang="python">from functools import cache

@cache
def levenstein(A: str, B: str) -&gt; int:
    a = len(A)
    b = len(B)
    if a == 0:
        return b
    elif b == 0:
        return a
    elif A[a - 1] == B[b - 1]:
        return levenstein(A[:a - 1], B[:b - 1])
    else:
        return min([
            levenstein(A[:a - 1], B[:b - 1]) + 1,
            levenstein(A[:a - 1], B) + 1,
            levenstein(A, B[:b - 1]) + 1,
        ])


assert levenstein(&#34;&#34;, &#34;puppy&#34;) == 5
assert levenstein(&#34;kitten&#34;, &#34;sitting&#34;) == 3
assert levenstein(&#34;uninformed&#34;, &#34;uniformed&#34;) == 1
# instantaneous!
assert levenstein(&#34;pneumonoultramicroscopicsilicovolcanoconiosis&#34;, &#34;sisoinoconaclovociliscipocsorcimartluonomuenp&#34;) == 36</code></pre>



<p>Now, there is something that makes the code nicer, and more performant, but it is not technically necessary. The trick is that we do not actually need to create new strings in our recursive functions. We can just pass arounds the lengths of the substrings, and always refer to the original strings <code>A</code> and <code>B</code>. Then, our code becomes:</p>



<pre><code lang="python">from functools import cache

def levenstein(A: str, B: str) -&gt; int:
    @cache
    def aux(a: int, b: int) -&gt; int:
        if a == 0:
            return b
        elif b == 0:
            return a
        elif A[a - 1] == B[b - 1]:
            return aux(a - 1, b - 1)
        else:
            return min([
                aux(a - 1, b - 1) + 1,
                aux(a - 1, b) + 1,
                aux(a, b - 1) + 1,
            ])
    return aux(len(A), len(B))


assert levenstein(&#34;&#34;, &#34;puppy&#34;) == 5
assert levenstein(&#34;kitten&#34;, &#34;sitting&#34;) == 3
assert levenstein(&#34;uninformed&#34;, &#34;uniformed&#34;) == 1
# instantaneous!
assert levenstein(&#34;pneumonoultramicroscopicsilicovolcanoconiosis&#34;, &#34;sisoinoconaclovociliscipocsorcimartluonomuenp&#34;) == 36</code></pre>



<p>The next step is to build the cache ourselves:</p>



<pre><code lang="python">def levenstein(A: str, B: str) -&gt; int:
    # cache[a][b] = levenstein(A[:a], B[:b])
    # note the + 1 so that we can actually do cache[len(A)][len(B)]
    # the list comprehension ensures we create independent rows, not references to the same one
    cache = [[None] * (len(B) + 1) for _ in range(len(A) + 1)]
    def aux(a: int, b: int) -&gt; int:
        if cache[a][b] == None:
            if a == 0:
                cache[a][b] = b
            elif b == 0:
                cache[a][b] = a
            elif A[a - 1] == B[b - 1]:
                cache[a][b] = aux(a - 1, b - 1)
            else:
                cache[a][b] = min([
                    aux(a - 1, b - 1) + 1,
                    aux(a - 1, b) + 1,
                    aux(a, b - 1) + 1,
                ])
        return cache[a][b]
    return aux(len(A), len(B))


assert levenstein(&#34;&#34;, &#34;puppy&#34;) == 5
assert levenstein(&#34;kitten&#34;, &#34;sitting&#34;) == 3
assert levenstein(&#34;uninformed&#34;, &#34;uniformed&#34;) == 1
# instantaneous!
assert levenstein(&#34;pneumonoultramicroscopicsilicovolcanoconiosis&#34;, &#34;sisoinoconaclovociliscipocsorcimartluonomuenp&#34;) == 36</code></pre>



<p>The last thing we need to do is to replace the recursion with iterations. The important thing is to make sure we do that in the right order<sup data-fn="1d71982a-5567-4481-b278-15d8251bcee6"><a href="#1d71982a-5567-4481-b278-15d8251bcee6" id="1d71982a-5567-4481-b278-15d8251bcee6-link">3</a></sup>:</p>



<pre><code lang="python">def levenstein(A: str, B: str) -&gt; int:
    # cache[a][b] = levenstein(A[:a], B[:b])
    # note the + 1 so that we can actually do cache[len(A)][len(B)]
    # the list comprehension ensures we create independent rows, not references to the same one
    cache = [[None] * (len(B) + 1) for _ in range(len(A) + 1)]
    for a in range(0, len(A) + 1):
        for b in range(0, len(B) + 1):
            if a == 0:
                cache[a][b] = b
            elif b == 0:
                cache[a][b] = a
            elif A[a - 1] == B[b - 1]:
                # since we are at row a, we have already filled in row a - 1
                cache[a][b] = cache[a - 1][b - 1]
            else:
                cache[a][b] = min([
                    # since we are at row a, we have already filled in row a - 1
                    cache[a - 1][b - 1] + 1,
                    # since we are at row a, we have already filled in row a - 1
                    cache[a - 1][b] + 1,
                    # since we are at column b, we have already filled column b - 1
                    cache[a][b - 1] + 1,
                ])
    return cache[len(A)][len(B)]


assert levenstein(&#34;&#34;, &#34;puppy&#34;) == 5
assert levenstein(&#34;kitten&#34;, &#34;sitting&#34;) == 3
assert levenstein(&#34;uninformed&#34;, &#34;uniformed&#34;) == 1
# instantaneous!
assert levenstein(&#34;pneumonoultramicroscopicsilicovolcanoconiosis&#34;, &#34;sisoinoconaclovociliscipocsorcimartluonomuenp&#34;) == 36
</code></pre>



<p>Now, if you really want to grok dynamic programming, I invite you to try it yourself on the following problems, preferrably in this order:</p>



<ol>
<li><a href="https://en.wikipedia.org/wiki/Longest_common_subsequence">longest common subsequence</a> (not to be confused with <a href="https://en.wikipedia.org/wiki/Longest_common_substring">longest common <em>substring</em></a>, but you can do that one too with dynamic programming)</li>



<li><a href="https://en.wikipedia.org/wiki/Line_wrap_and_word_wrap">line wrap</a></li>



<li><a href="https://en.wikipedia.org/wiki/Subset_sum_problem">subset sum</a></li>



<li><a href="https://en.wikipedia.org/wiki/Partition_problem">partition</a></li>



<li><a href="https://en.wikipedia.org/wiki/Knapsack_problem">knapsack</a></li>
</ol>



<p>Once you are comfortable with dynamic programming, Day 12 should become much less daunting!</p>



<h2>Advent of Code, Day 12</h2>



<p>In the <a href="https://adventofcode.com/2023/day/12">Advent of Code of December 12th, 2023</a>, you have to solve 1D <a href="https://en.wikipedia.org/wiki/Nonogram">nonograms</a>. Rather than rephrasing the problem, I will let you read the official description.</p>



<pre><code>.??..??...?##. 1,1,3</code></pre>



<p>This can be solved by brute-force. The proper technique for that is <a href="https://en.wikipedia.org/wiki/Backtracking">backtracking</a>, another terrible name. But the asymptotic complexity is exponential (for n question marks, we have to evaluate 2<sup>n</sup> potential solutions). Let’s see how it goes with this example:</p>



<ul>
<li><code>.??..??...?##. 1,1,3</code> the first question mark could be either a <code>.</code> or a <code>#</code>; in the second case, we “consume” the first group of size 1, and the second question mark has to be a <code>.</code>
<ol>
<li><code>..?..??...?##. 1,1,3</code> the next question mark could be either a . or a #; in the second case, we “consume” the first group of size 1, and the next character has to be a ., which is the case
<ol>
<li><code>.....??...?##. 1,1,3</code> the backtracking algorithm will continue to explore the 8 cases, but none of them is a valid solution</li>



<li><code>..#..??...?##. (1),1,3</code>
<ul>
<li>and so on…</li>
</ul>
</li>
</ol>
</li>



<li><code>.#...??...?##. (1),1,3</code>
<ul>
<li>and so on…</li>
</ul>
</li>
</ol>
</li>
</ul>



<p>There are 32 candidates, which would make 63 list items. I’ll spare you that. Instead, I want to draw your attention to the items 2.2 and 2:</p>



<ul>
<li>2.2. <code>..#..??...?##. <code>(1),</code>1,3</code></li>



<li>2. <code>.#...??...?##. <code>(1),</code>1,3</code></li>
</ul>



<p>They are extremely similar. In fact, if we discard the part that has already been accounted for, they are more like:</p>



<ul>
<li>2.2. <code>.??...?##. 1,3</code></li>



<li>2. <code>..??...?##. 1,3</code></li>
</ul>



<p>There is an extra <code>.</code> on the second one, but we can clearly see that it is actually the same problem, and has the same solutions.</p>



<p>In other words, just like with Fibonacci, the total number of cases is huge, but many of them will just be repeats of other ones. So we are going to apply memoization. And then, dynamic programming.</p>



<p>When we implement the “backtracking” algorithm we’ve overviewed above, we get something like this (<a href="https://github.com/Domyy95/Challenges/blob/02e9e5535b7ba027c11bb0e27fe3f2ce5dbd7d38/2023-12-Advent-of-code/12.py#L61-L79">not my code</a>):</p>



<pre><code lang="python">def count_arrangements(conditions, rules):
    if not rules:
        return 0 if &#34;#&#34; in conditions else 1
    if not conditions:
        return 1 if not rules else 0

    result = 0

    if conditions[0] in &#34;.?&#34;:
        result += count_arrangements(conditions[1:], rules)
    if conditions[0] in &#34;#?&#34;:
        if (
            rules[0] &lt;= len(conditions)
            and &#34;.&#34; not in conditions[: rules[0]]
            and (rules[0] == len(conditions) or conditions[rules[0]] != &#34;#&#34;)
        ):
            result += count_arrangements(conditions[rules[0] + 1 :], rules[1:])

    return result</code></pre>



<p>Note the program above handles <code>?</code> by treating it as both <code>.</code> and <code>#</code>. The first case is easy, but the second case need to check that it matches the next rules; and for that, it needs to check that there is a separator afterwards, or the end of the string.</p>



<p>Since it’s Python, to memoize, we just need to add <code>@cache</code>.</p>



<p>To make it dynamic programing, we use the same trick as in the example of the edit distance: we pass the offset in the string, and the offset in the rules as parameters in the recursion. This becomes:</p>



<pre><code lang="python">def count_arrangements(conditions, rules):
    @cache
    def aux(i, j):
        if not rules[j:]:
            return 0 if &#34;#&#34; in conditions[i:] else 1
        if not conditions[i:]:
            return 1 if not rules[j:] else 0

        result = 0

        if conditions[i] in &#34;.?&#34;:
            result += aux(i + 1, j)
        if conditions[i] in &#34;#?&#34;:
            if (
                rules[j] &lt;= len(conditions[i:])
                and &#34;.&#34; not in conditions[i:i + rules[j]]
                and (rules[j] == len(conditions[i:]) or conditions[i + rules[j]] != &#34;#&#34;)
            ):
                result += aux(i + rules[j] + 1, j + 1)

        return result
    return aux(0, 0)</code></pre>



<p>Then, we implement our own cache and fill it in the right order:</p>



<pre><code lang="python">def count_arrangements(conditions, rules):
    cache = [[0] * (len(rules) + 1) for _ in range(len(conditions) + 1)]
    # note that we are in the indices in reverse order here
    for i in reversed(range(0, len(conditions) + 1)):
        for j in reversed(range(0, len(rules) + 1)):
            if not rules[j:]:
                result = 0 if &#34;#&#34; in conditions[i:] else 1
            elif not conditions[i:]:
                result = 1 if not rules[j:] else 0
            else:
                result = 0
                if conditions[i] in &#34;.?&#34;:
                    # since we are at row i, we already filled in row i + 1
                    result += cache[i + 1][j]
                if conditions[i] in &#34;#?&#34;:
                    if (
                        rules[j] &lt;= len(conditions[i:])
                        and &#34;.&#34; not in conditions[i:i + rules[j]]
                    ):
                        if rules[j] == len(conditions[i:]):
                            # since we are at row i, we already filled in row i + rules[j] &gt; i
                            result += cache[i + rules[j]][j + 1]
                        elif conditions[i + rules[j]] != &#34;#&#34;:
                            # since we are at row i, we already filled in row i + rules[j] + 1 &gt; i
                            result += cache[i + rules[j] + 1][j + 1]
            cache[i][j] = result
    return cache[0][0]</code></pre>



<p>And, voilà! You can also have a look at a <a href="https://github.com/qsantos/advent-of-code/blob/master/2023/day12/src/main.rs#L6-L46">Rust implementation (my code, this time)</a>.</p>



<p><strong>Note:</strong> In this case, it looks like the dynamic programming version is slower than the memoized one. But that’s probably due to it being written in unoptimized Python.</p>



<p><strong>Note:</strong> Independently from using a faster language and micro-optimizations, the dynamic programming version allows us to see that we only need the previous column. Thus, we could replace the 2D array by two 1D arrays (one for the previous column, and one for the column being filled).</p>



<h2>Conclusion</h2>



<p>I’ll concede that dynamic programming is not trivial. But it is far from being unreachable for most programmers. Being able to understand how to split a problem in smaller problems will enable you to use memoization in various contexts, which is already a huge improvement above a naive implementation.</p>



<p>However, mastering dynamic programming will let us understand a whole class of algorithms, better understand trade-offs, and make other optimizations possible. So, if you have not already done them, I strongly encourage you to practice on these problems:</p>



<ol>
<li><a href="https://en.wikipedia.org/wiki/Longest_common_subsequence">longest common subsequence</a> (not to be confused with <a href="https://en.wikipedia.org/wiki/Longest_common_substring">longest common <em>substring</em></a>, but you can do that one too with dynamic programming)</li>



<li><a href="https://en.wikipedia.org/wiki/Line_wrap_and_word_wrap">line wrap</a></li>



<li><a href="https://en.wikipedia.org/wiki/Subset_sum_problem">subset sum</a></li>



<li><a href="https://en.wikipedia.org/wiki/Partition_problem">partition</a></li>



<li><a href="https://en.wikipedia.org/wiki/Knapsack_problem">knapsack</a></li>
</ol>



<p>And don’t forget to benchmark and profile your code!</p>



<hr/>


<ol><li id="4598dbdf-9a33-4bd6-976e-a06758eb4f07">Excluding, of course, <code>d(A, B)</code> itself <a href="#4598dbdf-9a33-4bd6-976e-a06758eb4f07-link" aria-label="Jump to footnote reference 1">↩︎</a></li><li id="fb0dcaf1-f2c3-4035-aa3e-9d14652cb2fa"><code>B</code> could be empty as well, in which case we need to insert 0 characters <a href="#fb0dcaf1-f2c3-4035-aa3e-9d14652cb2fa-link" aria-label="Jump to footnote reference 2">↩︎</a></li><li id="1d71982a-5567-4481-b278-15d8251bcee6">Note that we could permute the inner and outer loops as shown below. In this case, it works just as well:</li></ol>
		</div><!-- .entry-content -->

	</div></div>
  </body>
</html>
