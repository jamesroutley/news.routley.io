<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mattferraro.dev/posts/caustics-engineering">Original</a>
    <h1>The Physics of Magic Windows (2021)</h1>
    
    <div id="readability-page-1" class="page"><div><article><p><time datetime="2021-08-18">August 18, 2021</time></p><p>I recently made a physical object that defies all intuition. It&#39;s a square of acrylic, smooth on both sides, totally transparent. A tiny window.</p><div><p><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjEyIiBoZWlnaHQ9IjQxNy4xMjk2Mjk2Mjk2Mjk2IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIvPg=="/></p><p><img alt="Clear Acrylic" srcset="/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fwindow_clear.jpg&amp;w=640&amp;q=90 1x, /_next/image?url=%2Fimages%2Fcaustics-engineering%2Fwindow_clear.jpg&amp;w=1920&amp;q=90 2x" src="https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fwindow_clear.jpg&amp;w=1920&amp;q=90" decoding="async" data-nimg="intrinsic"/></p></div><p>But it has the magic property that if you shine a flashlight on it, it forms an image:</p><div><p><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjEyIiBoZWlnaHQ9IjQzOC40MDA4MjIxOTkzODMzNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiLz4="/></p><p><img alt="2D Image of Cat" srcset="/_next/image?url=%2Fimages%2Fcaustics-engineering%2F2D_image.jpg&amp;w=640&amp;q=90 1x, /_next/image?url=%2Fimages%2Fcaustics-engineering%2F2D_image.jpg&amp;w=1920&amp;q=90 2x" src="https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2F2D_image.jpg&amp;w=1920&amp;q=90" decoding="async" data-nimg="intrinsic"/></p></div><p>And if you take it out in the sun, it produces this 3D hologram:</p><video width="100%" height="auto" autoplay="" muted="" controls="" loop=""><source src="/images/caustics-engineering/3dcat.mp4" type="video/mp4"/></video><p>This post describes the math that went into making the object, and how you can create your own.</p><p>Let&#39;s focus on the 2D image before talking about the hologram.</p><p>The physical phenomenon we&#39;re looking at is called a <em>caustic</em>.</p><div><p><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjEyIiBoZWlnaHQ9IjQwOCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiLz4="/></p><p><img alt="Example Caustic" srcset="/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fglass_caustic_pd.jpg&amp;w=640&amp;q=90 1x, /_next/image?url=%2Fimages%2Fcaustics-engineering%2Fglass_caustic_pd.jpg&amp;w=1920&amp;q=90 2x" src="https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fglass_caustic_pd.jpg&amp;w=1920&amp;q=90" decoding="async" data-nimg="intrinsic"/></p></div><p>Caustics are the bright patches of light we see when illuminating a transparent object. All the photons that don&#39;t pass directly through the object are what form the object&#39;s shadow. All those photons still have to go somewhere; they contribute to the caustic pattern.</p><p>The most interesting aspect of caustics is that they arise from even the tiniest of variations in surface flatness. Even the gentlest waves on the surface of a pool form powerful lenses that cast intense caustics on the floor below.</p><div><p><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjEyIiBoZWlnaHQ9IjQ1OC4wNDI1NTMxOTE0ODkzMyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiLz4="/></p><p><img alt="Water Caustics" srcset="/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fwater_caustics_cc.jpg&amp;w=640&amp;q=90 1x, /_next/image?url=%2Fimages%2Fcaustics-engineering%2Fwater_caustics_cc.jpg&amp;w=1920&amp;q=90 2x" src="https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fwater_caustics_cc.jpg&amp;w=1920&amp;q=90" decoding="async" data-nimg="intrinsic"/></p></div><p>The reason my acrylic square can form an image is because I&#39;ve distributed just the right amount of concavity and convexity into the surface so that the refracted light forms a caustic image.</p><p>To gain some intuition for how it is done, consider a traditional convex lens:</p><div><p><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjEyIiBoZWlnaHQ9IjI3NS43NTQyMjk3NDE3NjMxNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiLz4="/></p><p><img alt="Parabolic Lens" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></p></div><p>This lens forms the simplest possible caustic. If all the incoming light is from a single, very distant light source like the Sun, this lens focuses all of its incoming light into a single point. The caustic image from this lens is dark everywhere with one very bright spot in the center.</p><p>Zooming in on one small section of the lens we notice a few properties:</p><ol><li>The overall thickness of the lens does not have a direct impact on the outgoing ray angle. We could add material to the left side of this lens and nothing would change. The first transition, from air to glass, can be entirely ignored.</li><li>The angle between the incoming light rays and the glass-air boundary has a strong effect on the refracted ray angle.</li><li>Whether two rays converge or diverge is controlled by how <em>curved</em> the lens is where the glass meets the air</li></ol><p>In other words, the height of the glass <span>h(x)</span> is not on its own important. But the slope of the glass, <span>\frac{\mathrm{d}h}{\mathrm{d}x}</span>, gives us the outgoing ray angle via Snell&#39;s law. Where rays converge the image is brighter than the light source. Where rays diverge the image is darker. Therefore the brightness of the image (at that point, where the rays fall) is related to <span>\frac{\mathrm{d}^2h}{\mathrm{d}x^2}</span>.</p><p>The thickness of my acrylic slab varies across the entire <span>xy</span> plane, so I&#39;ll call it <span>h(x,y)</span> and we&#39;ll think of it as a <strong>heightmap</strong>.</p><p>By controlling <span>\nabla h = (\frac{\partial h}{\partial x}, \frac{\partial h}{\partial y}</span>), and <span>\nabla ^2 h = (\frac{\partial ^2 h}{\partial x^2} + \frac{\partial ^2 h}{\partial y^2})</span>, we can steer all of our incoming light to the correct locations in the image, while contributing the right brightness to make it recognizable. By making some simplifying assumptions we can guarantee that the resulting heightmap will be smooth and continuous.</p><p>For the Magic Window shown above, the total height variation over the <span>10cm \times 10cm</span> surface is about <span>2.0mm</span>.</p><div><p><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjEyIiBoZWlnaHQ9IjQ1OSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiLz4="/></p><p><img alt="Slight Refraction" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></p></div><p>See how the slight variations in surface height distort the straight line of the floor moulding? Our Magic Window works like any other lens—by bending light.</p><ul><li><a href="#formulating-the-problem">Formulating the Problem</a></li><li><a href="#steps-to-a-solution">Steps to a Solution</a></li><li><a href="#morphing-the-cells">Morphing the Cells</a><ul><li><a href="#computing-the-loss">Computing the Loss</a></li><li><a href="#stepping-to-reduce-loss">Stepping to Reduce Loss</a></li></ul></li><li><a href="#snells-law-and-normal-vectors">Snell&#39;s Law and Normal Vectors</a></li><li><a href="#finding-the-heightmap">Finding the Heightmap</a></li><li><a href="#manufacturing">Manufacturing</a></li><li><a href="#acknowledgements">Acknowledgements</a></li><li><a href="#my-code">My Code</a></li><li><a href="#licensing">Licensing</a></li><li><a href="#contact-me">Contact me</a></li><li><a href="#one-last-thing">One Last Thing</a></li></ul><p>We want to find a heightmap <span>h(x,y)</span> whose caustic image has brightness <span>b(u,v)</span>, equal to some input image. To achieve this we can imagine a grid of cells, akin to pixels, on the surface of the acrylic lens. Here each &#34;pixel&#34; on the lens corresponds to a pixel in the image. Image pixels and their corresponding lens-space &#34;pixels&#34; are labeled with shared <span>(i, j)</span> coordinates.</p><div><p><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjEyIiBoZWlnaHQ9IjI5OC45NDkzMDg3NTU3NjAzNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiLz4="/></p><p><img alt="Diagram" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></p></div><p>Remember that <span>(i, j)</span> are integers labeling the column and row of the pixel, whereas <span>(x, y)</span> and <span>(u, v)</span> are real numbers measured in something like meters or inches.</p><p><strong>Step 1:</strong> We morph the cells on the lens, making them bigger or smaller, so that the area of lens cell <span>(i, j)</span> is proportional to the brightness of image cell <span>(i, j)</span>. The resulting lens grid is no longer square—lots of warping and skew have to be introduced to maintain continuity. This step is by far the hardest part and must be solved iteratively.</p><p><strong>Step 2:</strong> For each cell <span>(i, j)</span> we need to find the angle from the lens cell to image cell and use Snell&#39;s law to find the required surface normal. This step is straightforward geometry.</p><p><strong>Step 3:</strong> Integrate all the surface normals to find a continuous heightmap <span>h(x,y)</span>. We&#39;re back to iterative methods here, but if we apply certain contraints to how we solve step 1, this step is actually fast and easy.</p><p>For an image with <span>n \times n</span> pixels, the lens grid will need <span>(n+1) \times (n+1)</span> points, so that each cell in the lens grid is defined by four points. Technically we should adopt yet another coordinate system to label the <em>points</em> in the lens grid since they are distinct from the <em>cells</em> in the lens grid, but I think it&#39;s easier to just reuse <span>(i, j)</span> and we can say that for grid cell <span>(i, j)</span>, the point in the upper left is defined as grid point <span>(i, j)</span>.</p><div><p><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjEyIiBoZWlnaHQ9IjMxOS45MDkwOTA5MDkwOTA5IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIvPg=="/></p><p><img alt="Diagram 2" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></p></div><p>This leaves us with one row and one column of extra grid points along the bottom and right edges, but that will be trivial to deal with when it comes up.</p><p>Each <em>point</em> in the lens grid <span>(i,j)</span> has an <span>(x, y)</span> coordinate. A point&#39;s <span>(i, j)</span> coordinates never change but the <span>(x, y)</span> coordinates will change as we morph the cells more and more.</p><h2 id="computing-the-loss">Computing the Loss</h2><p>Given the <span>(x, y)</span> locations of all the lens grid points, simple geometry lets us calculate the area of each lens grid cell. Of course at first every cell has the same area, but that will change as soon as we start morphing things.</p><p>The condition we want is that every lens grid <em>cell</em> <span>(i, j)</span> has an <em>area</em> which scales with the <em>brightness</em> of image pixel <span>b(i, j)</span>.</p><p>Area and brightness are not compatible units so it is helpful to normalize cell area by the full window area, and pixel brightness by total image brightness, so that each is measured in a unitless &#34;percentage&#34;.</p><p>\tag{1.0}
\frac{A_{ij}}{\Sigma A} = \frac{b_{ij}}{\Sigma b}</p><p>Intuitively, this means:</p><blockquote><p>If a single pixel contributes <span>x\%</span> of the brightness of the entire image, the corresponding window cell should take up <span>x\%</span> of the area of the entire window.</p></blockquote><p>Equation <span>(1.0)</span> is the goal, but it will not be not be true until after we&#39;ve morphed the window grid. Until we&#39;ve done that, we need to compute a loss function which tells us how badly we&#39;re missing our target. Something like:</p><p>\tag{1.1}
L = \frac{b_{ij}}{\Sigma b} - \frac{A_{ij}}{\Sigma A}</p><p>In code:</p><pre><code>
img <span>=</span> read_image<span>(</span><span>&#34;cat.png&#34;</span><span>)</span>
brightness <span>=</span> convert_to_grayscale<span>(</span>img<span>)</span>
total_brightness <span>=</span> sum<span>(</span>brightness<span>)</span>
brightness <span>=</span> brightness <span>.</span><span>/</span> total_brightness

w <span>=</span> <span>.1</span> 
h <span>=</span> <span>.1</span> 
area_total <span>=</span> w <span>*</span> h
loss <span>=</span> compute_pixel_area<span>(</span>grid<span>)</span> <span>.</span><span>/</span> area_total <span>-</span> brightness
</code></pre><div><p><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjEyIiBoZWlnaHQ9IjMwNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiLz4="/></p><p><img alt="Image and Loss Function" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></p></div><p>Where I&#39;ve colorized the loss function so that red areas indicate regions where our grid cells need to grow and blue regions indicate where our grid cells need to shrink.</p><p>This image is the loss function <span>L</span> and I&#39;ll refer to it a lot. </p><h2 id="stepping-to-reduce-loss">Stepping to Reduce Loss</h2><p>The loss image can be thought of as a scalar field <span>L(x, y)</span>. The gradient of a scalar field yields a vector field, which we could call <span>\nabla L(x,y)</span>. We can step each grid point slowly in the direction of the gradient field, and in doing so the cells that are too small will get bigger and the cells that are too big will get smaller. Our loss will shrink, and we&#39;ll create our image!</p><p>The first thing to do is compute <span>\nabla L</span> and look at the vector field:</p><div><p><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjEyIiBoZWlnaHQ9IjQwMS4zOTU2ODM0NTMyMzc0NCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiLz4="/></p><p><img alt="Gradient of L as a vector field" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></p></div><p>Crap.</p><p><span>\nabla L</span> is a very poorly behaved vector field. It is noisy, discontinuous, and in many places equal to zero.</p><p>Almost everywhere, neighboring points need to step in drastically different directions. This creates a situation where improving one cell&#39;s loss will necessarily worsen its neighbor&#39;s losses, which means that in practice this method can never converge. It&#39;s a dead end.</p><hr/><p>Instead let&#39;s draw an analogy to Computational Fluid Dynamics. We need to dilate certain cells and shrink others according to a brightness function. This is similar to modeling compressible air flow where each cell has pressure defined as a pressure function.</p><p>If every cell in a 2D grid has some initial pressure, how does the system relax over time? The regions with high pressure expand and the regions of low pressure contract, with regions of middling pressure getting shoved around in a sort of global tug-of-war. Clearly, our problem is analogous.</p><p>So, how is this problem solved in CFD simulations? A standard approach is to define a <strong>Velocity Potential</strong> called <span>\Phi</span> (read: <em>phi</em>). The Velocity Potential <span>\Phi</span> is a scalar field defined at each cell. Its units are <span>meters^2 / second</span> which at first glance is not very easy to interpret. But the reason <span>\Phi</span> is convenient is that its spatial derivatives are measured in <span>meters/second</span>. In other words, the gradient of <span>\Phi</span> gives a vector whose units are velocity:</p><p>\tag{1.2}
\nabla \Phi = \left( \frac{\partial{\Phi}}{\partial{x}}, \frac{\partial{\Phi}}{\partial{y}} \right) = \vec{v}</p><div><p><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjEyIiBoZWlnaHQ9IjM3MS44MjU1ODEzOTUzNDg4IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIvPg=="/></p><p><img alt="Phi" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></p></div><p>Here is an example <span>\Phi</span>. It is just some scalar field best viewed as a heightmap.</p><div><p><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjEyIiBoZWlnaHQ9IjQwNi45NzIyOTIxOTE0MzU3IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIvPg=="/></p><p><img alt="Gradient of Phi" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></p></div><p>And here is the gradient of that same <span>\Phi</span>. These vectors are velocity vectors that point uphill. If we were performing Computational Fluid Dynamics, these vectors would indicate how fluid might flow from regions of high pressure to regions of low pressure. </p><p>Notice how well behaved this vector field is! There is gentle variation across the field but any two neighbors are very similar to each other. None of the arrows pierce the boundary.</p><p>In our case we don&#39;t have fluid pressure, we have light pressure. Regions in our image which are too bright have high light pressure, which is quantified in our loss function <span>L</span>.</p><p>If we can somehow use <span>L</span> to find a <span>\Phi</span> that describes our light pressure distribution, all we need to do is calculate <span>\vec{v} = \nabla \Phi</span> and we&#39;ll be able to morph all of our lens grid points according to <span>\vec{v}</span> to decrease our loss!</p><p>So how do we find a suitable <span>\Phi</span>? Well, the property we know about each cell is its loss, which encodes how much that cell needs to grow or shrink. </p><blockquote><p>This property, how much a cell grows or shrinks over time as it moves with a velocity field, is called the <strong>divergence</strong> of that field.</p></blockquote><p>Divergence is written as <span>\nabla \cdot</span>, so in our case, we know that we need to find a velocity field <span>\vec{v}</span> whose divergence equals the loss:</p><p>\tag{1.3}
\nabla \cdot \vec{v} = L(x, y)</p><p>Unfortunately there is no &#34;inverse divergence&#34; operator so we cannot easily invert this equation to find <span>\vec{v}</span> directly. But we <em>can</em> plug equation <span>(1.2)</span> in to equation <span>(1.3)</span> to yield:</p><p>\tag{1.4}
\nabla \cdot \nabla \Phi = L(x, y)</p><p>Which we read as <em>The divergence of the gradient of the potential field <span>\Phi</span> equals the loss</em>.</p><p>This equation comes up surprisingly frequently in many branches of physics and math. It is usually written in a more convenient shorthand:</p><p>\tag{1.5}
\nabla ^2 \Phi = L</p><p>Which you may recognize as <a href="https://mattferraro.dev/posts/poissons-equation">Poisson&#39;s Equation</a>!</p><p>This is fantastic news because Poisson&#39;s equation is <a href="https://mattferraro.dev/posts/poissons-equation#how-do-i-solve-it">extremely easy</a> to solve! If you aren&#39;t familiar with it, just think of this step like inverting a big matrix, or numerically integrating an ODE, or finding the square root of a real number. It&#39;s an intricate, tedious task that would be painful to do with a paper and pencil, but it&#39;s the kind of thing computers are <em>really</em> good at.</p><p>Now that we&#39;ve written down the problem as Poisson&#39;s Equation, it is as good as solved. We can use any off the shelf solver, plug in our known <span>L(x, y)</span> using Neumann boundary conditions and boom, and out pops <span>\Phi(x,y)</span> as if by magic.</p><div><p><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjEyIiBoZWlnaHQ9IjQxNC42MDE5NDE3NDc1NzI4IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIvPg=="/></p><p><img alt="Phi" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></p></div><p>Can you figure out why the cat appears so clearly in this 3D rendering of <span>\Phi</span>? What controls the brightness of each pixel in a render like this?</p><p>We plug <span>\Phi</span> in to Equation <span>(1.2)</span> to find <span>\vec{v}</span> and we take a look at the vector field:</p><div><p><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjEyIiBoZWlnaHQ9IjQwNi45NzIyOTIxOTE0MzU3IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIvPg=="/></p><p><img alt="Gradient of Phi" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></p></div><p>Disappointingly, it does not look like a kitty to me.</p><p>And technically we need to march our points in the direction of <em>negative</em> <span>\nabla L</span> if we want to <em>decrease</em> <span>L</span>. Here&#39;s <span>-\nabla L</span>:</p><div><p><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjEyIiBoZWlnaHQ9IjQwMy4yNzU3ODk0NzM2ODQyIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIvPg=="/></p><p><img alt="Negative Gradient of Phi" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></p></div><p>But the good news is that this vector field is smooth and well-behaved. We simply march the grid points along this vector field and we&#39;ll get exactly what we need. </p><p>If you squint you can almost see how the bright background will expand and the cat&#39;s dark fur will shrink.</p><div><p><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjEyIiBoZWlnaHQ9IjI3MS44IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIvPg=="/></p><p><img alt="Image and Vector Field" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></p></div><p>We step all the lens grid points forward some small amount in the direction of <span>-\vec{v}</span>. After morphing the grid a tiny amount we recompute the loss function <span>L</span>, find a new <span>\Phi</span> and new <span>-\vec{v}</span>, and take another small step.</p><pre><code>
image <span>=</span> read_image<span>(</span><span>&#34;cat.png&#34;</span><span>)</span>
gray <span>=</span> convert_to_grayscale<span>(</span>image<span>)</span>
grid <span>=</span> create_initial_grid<span>(</span>gray<span>.</span>size <span>+</span> <span>1</span><span>)</span>

L <span>=</span> compute_loss<span>(</span>gray<span>,</span> grid<span>)</span>

<span>while</span> max<span>(</span>L<span>)</span> <span>&gt;</span> <span>0.01</span>
    ϕ <span>=</span> poisson_solver<span>(</span>L<span>,</span> <span>&#34;neumann&#34;</span><span>,</span> <span>0</span><span>)</span>
    v <span>=</span> compute_gradient<span>(</span>ϕ<span>)</span>
    grid <span>=</span> step_grid<span>(</span>grid<span>,</span> <span>-</span>v<span>)</span>
    L <span>=</span> compute_loss<span>(</span>gray<span>,</span> grid<span>)</span>
<span>end</span>
</code></pre><p>After three or four iterations the loss gets very small and we&#39;ve got our morphed cells!</p><div><p><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjEyIiBoZWlnaHQ9IjMwNi42MDExNzg3ODE5MjUzNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiLz4="/></p><p><img alt="Grid After Warping" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></p></div><p>Look at how this cat&#39;s chin ballooned out but her nose and forehead shrunk. Her left ear is noticably longer and thinner because the bright background had to grow to take up more light. Her pupils went from oblong to sharp.</p><p>Note that image on the right is just a screenshot of Fusion360&#39;s default mesh rendering with the wireframe turned on:</p><div><p><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjEyIiBoZWlnaHQ9IjM4Mi41IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIvPg=="/></p><p><img alt="Screenshot of Fusion360" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></p></div><p>The reason it is darker in some areas is because the mesh is more tightly packed in those areas. Let&#39;s zoom in on the eye:</p><div><p><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjEyIiBoZWlnaHQ9IjQ3Mi41OTAyNTc4Nzk2NTYyIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIvPg=="/></p><p><img alt="Zoom in on the Eye" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></p></div><p>Look at how detailed that is! We&#39;ve managed to capture even the bright reflections in her eyes. Zooming in further to just the pupil:</p><div><p><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjEyIiBoZWlnaHQ9IjQxOS4zOTA4NjI5NDQxNjI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIvPg=="/></p><p><img alt="Zoom in on the Pupil" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></p></div><p>We can see the fine structure of the grid cells. Our formulation of the problem is only concerned with cells as quadralaterals. The triangles you see are just an artifact of converting our quadralateral grid into a triangle mesh more suitable for other software to deal with.</p><p>So again, in summary:</p><div><p><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjEyIiBoZWlnaHQ9IjM5MC4xMjIwNjU3Mjc2OTk1IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIvPg=="/></p><p><img alt="Overall Flow" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></p></div><p>If we follow these steps we will successfully morph our grid points. Now we&#39;ve got to do some geometry!</p><p>Snell&#39;s law tells us how light bends when passing from one material to another. </p><div><p><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjEyIiBoZWlnaHQ9IjQzMi43MDUyNTM3ODQ1MDU3NyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiLz4="/></p><p><img alt="Snell&#39;s Law" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></p></div><p>\tag{2.0}
\frac{\sin(\theta_2)}{\sin(\theta_1)} = \frac{n_1}{n_2}</p><p>Where <span>n_1 = 1.49</span> is the <a href="https://en.wikipedia.org/wiki/Refractive_index">Refractive Index</a> of acrylic and <span>n_2 = 1</span> is the refractive index of air. If we know <span>\theta_2</span>, Snell&#39;s Law gives us <span>\theta_1</span>.</p><p>Snell&#39;s law is not some arbitrary axiom of physics. It is a direct consequence of Fermat&#39;s <a href="https://en.wikipedia.org/wiki/Fermat%27s_principle">Principle of Least Time</a>, which is a fascinating and critical link between ray optics and wave optics. But that&#39;s a topic for another day.</p><p>In our case, each lens cell <span>(i, j)</span> has migrated to position <span>(x, y)</span>, and it needs to send its light to the image plane at <span>(u, v)</span>, which sits some distance away <span>d</span>.</p><p>We start by defining a 3D normal vector <span>\vec{N}(x, y)</span> which everywhere points normal to our heightmap <span>h(x, y)</span>.</p><div><p><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjEyIiBoZWlnaHQ9IjI0NS43NTc0OTY3NDA1NDc1NyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiLz4="/></p><p><img alt="Example Surface Normals" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></p></div><p>Normal vectors always point perpendicular to the surface they start on. They generally encode meaning in their direction, not their length, so we&#39;re free to scale them to any length that is convenient for our purposes. Very often people choose to make their Normal vectors of length <span>1</span>.</p><p>But if we normalize <span>\vec{N}</span> so that its <span>z</span> coordinate is <span>-1</span>, we can write it:</p><p>\tag{2.1}
\vec{N} = (\frac{\partial{h}}{\partial{x}}, \frac{\partial{h}}{\partial{y}}, -1)</p><p>If you consider just the <span>x</span> and <span>y</span> components, we recognize that</p><p>\tag{2.2}
\vec{N}_{xy} = \nabla h</p><p>Which is a property often used in computer graphics applications, as well as geospatial applications involving <a href="https://en.wikipedia.org/wiki/Digital_elevation_model">Digital Elevation Models</a>.</p><p>Using Snell&#39;s Law, a small angle approximation, and a lot of tedious geometry, we find the <span>x</span> and <span>y</span> components of the normal vector <span>\vec{N}</span>:</p><p>\tag{2.3}
N_x(i, j) = \tan \frac{\tan^{-1} \left( \frac{u - x} {d} \right)} {(n_1 - n_2)}</p><p>\tag{2.4}
N_y(i, j) = \tan \frac{\tan^{-1} \left( \frac{v - y} {d} \right)} {(n_1 - n_2)}</p><p>There is nothing interesting about this derivation so I&#39;ve skipped it here.</p><p>At this point we have our morphed grid cells and we&#39;ve found all our surface normals. All we have to do is find a heightmap <span>h(x,y)</span> that has the required surface normals.</p><p>Unfortunately, this is not a problem that is solvable in the general case.</p><p>We could try to integrate the normals manually, starting at one corner and working our way down the grid, but this method does not usually result in a physically realizable object. </p><p>If the integral of the normals running left to right pulls your surface up, but the integral of the normals running top to bottom pulls your surface down, there is just no solution that results in a solid, unbroken surface.</p><p>A much better approach is to reach back to equation <span>(2.2)</span>, repeated here:</p><p>\tag{2.2}
\vec{N}_{xy} = \nabla h</p><p>And to take the divergence of both sides:</p><p>\tag{2.5}
\nabla \cdot \vec{N}_{xy} = \nabla \cdot \nabla h</p><p>Do you recognize the form of this equation? Adopting shorthand and swapping sides:</p><p>\tag{2.6}
\nabla ^2 h = \nabla \cdot \vec{N}_{xy}</p><p>We arrive at yet another instance of <a href="https://mattferraro.dev/posts/poissons-equation">Poisson&#39;s Equation</a>! We found <span>\vec{N}_{xy}</span> in the previous section, and calculating the divergence of a known vector field is easy:</p><p>\tag{2.7}
\nabla \cdot \vec{N}_{xy} = \left( \frac{\partial}{\partial{x}}, \frac{\partial}{\partial{y}} \right) \cdot (\vec{N}_x, \vec{N}_y) = \frac{\partial{\vec{N}_x}}{\partial{x}} + \frac{\partial{\vec{N}_y}}{\partial{y}}</p><p>In code it looks like:</p><pre><code>δx <span>=</span> <span>(</span>Nx<span>[</span>i<span>+</span><span>1</span><span>,</span> j<span>]</span> <span>-</span> Nx<span>[</span>i<span>,</span> j<span>]</span><span>)</span>
δy <span>=</span> <span>(</span>Ny<span>[</span>i<span>,</span> j<span>+</span><span>1</span><span>]</span> <span>-</span> Ny<span>[</span>i<span>,</span> j<span>]</span><span>)</span>
divergence<span>[</span>i<span>,</span> j<span>]</span> <span>=</span> δx <span>+</span> δy
</code></pre><p>All that&#39;s left is to plug our known <span>\nabla \cdot \vec{N}_{xy}</span> in to a Poisson solver with Neumann boundary conditions and out pops <span>h(x, y)</span>, ready to use!</p><p>Well, there&#39;s one thing left to improve. By modifying the height of each point we&#39;ve actually changed the distance from each lens point to the image, so the lens-image distance is no longer a constant <span>d</span> it is actually a function <span>D(x,y)</span>. With our heightmap in hand we can easily calculate:</p><p>\tag{2.8}
D(x,y) = d - h(x,y)</p><p>And repeat the process by calculating new normals using <span>D(x,y)</span> instead of <span>d</span>, which lets us create a new heightmap.</p><p>We can loop this process and measure changes to ensure convergence, but in practice just 2 or 3 iterations is all you need:</p><pre><code>
d <span>=</span> <span>.2</span> 
D <span>=</span> d <span>.</span><span>*</span> array_of_ones<span>(</span>n<span>,</span> n<span>)</span>

<span>for</span> i <span>in</span> <span>1</span><span>:</span><span>3</span>
    Nx<span>,</span> Ny <span>=</span> compute_normals<span>(</span>grid<span>,</span> D<span>)</span>
    divergence <span>=</span> compute_divergence<span>(</span>Nx<span>,</span> Ny<span>)</span>
    h <span>=</span> poisson_solver<span>(</span>divergence<span>,</span> <span>&#34;neumann&#34;</span><span>,</span> <span>0</span><span>)</span>
    D <span>=</span> copy<span>(</span>h<span>)</span>
<span>end</span>
</code></pre><p>The resulting heightmap can be converted to a solid object by adopting a triangular grid and closing off the back surface.</p><div><p><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjEyIiBoZWlnaHQ9IjMzMi41NDIzNzI4ODEzNTU5IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIvPg=="/></p><p><img alt="Final Object" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></p></div><p>Note that the image looks mirrored when looking at it head on. That&#39;s because the heightmap forms the <em>back</em> surface of the Magic Window. The front surface is factory flat.</p><div><p><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjEyIiBoZWlnaHQ9IjMzOS40OTI1MzczMTM0MzI4IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIvPg=="/></p><p><img alt="Final Object" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></p></div><p>The height differences are subtle but certainly enough to get the job done.</p><div><p><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjEyIiBoZWlnaHQ9IjQ0Mi40NDA0NTEzMTYzMzkzNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiLz4="/></p><p><img alt="Finished Product" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></p></div><p>The process of manufacturing our Magic Window is identical to carving any other 2.5D object.</p><p>We bring our object into Fusion360 or any other CAM software. We set up a roughing toolpath left to right, and a finishing toolpath top to bottom just like you find in most tutorials.</p><p>Any old CNC router or mill will work. I designed and built my own router last year. If you want to do the same I recommend you start <a href="https://mattferraro.dev/posts/cnc-router">here</a>.</p><p>I used a <span>\frac{1}{4}</span> inch diameter, ball-nosed, carbide bit for both roughing and finishing passes, which took 10 minutes and 90 minutes respectively.</p><div><p><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjEyIiBoZWlnaHQ9IjQ1OSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiLz4="/></p><p><img alt="On the Router" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></p></div><p>After carving the surface finish is rough and transluscent. We need to wet sand using <span>200, 400, 600, 1000</span> and <span>1500</span> grit sandpapers, then finish with a soft rag and some automotive polish. Sanding and polishing takes about half an hour for a <span>10 cm \times 10 cm</span> Magic Window.</p><div><p><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjEyIiBoZWlnaHQ9IjQ1OSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiLz4="/></p><p><img alt="After Sanding" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></p></div><p>All of the math for this post came from <a href="http://nishitalab.org/user/egaku/tog14/yue-continuous-caustics-lens.pdf">Poisson-Based Continuous Surface Generation for Goal-Based Caustics</a>, a phenomenal 2014 paper by Yue et al. If you continue this work in some way, please cite them.</p><p>My source code is available <a href="https://github.com/MattFerraro/causticsEngineering">here</a>. I am a novice at programming in Julia so if you have suggestions for how to improve this code, please reach out or make a pull request!</p><p><strong>Caveats</strong>: There are a lot of issues with my code. I confuse <span>x</span> and <span>y</span> in several places. I have extra negative signs that I inserted that make the code work but I don&#39;t know why. My units and notation are inconsistent throughout. The original paper suggests a better way of calculating loss but I didn&#39;t implement it because the naive way was easier, yet I rolled my own mesh utilities and Poisson solver because I enjoyed the challenge.</p><p>In short: To me this code is a fun side project. If you want to build a business off of this code you should probably hire someone who knows how to program professionally in Julia.</p><p>I&#39;ve posted all my code under the MIT license. Please feel free to use this code for anything you want, including hobbyist, educational, and commercial uses. I only ask that if you make something, please show me!</p><p>Except where otherwise attributed, all images in this blog post and the blog post itself are my own work that I license as <a href="https://creativecommons.org/licenses/by/2.0/">CC-BY</a>.</p><p>The cat in this post is named Mitski and she approves of you using her image as the new standard reference image for image processing papers. It&#39;s time to let Lenna <a href="https://en.wikipedia.org/wiki/Lenna#Criticism">retire</a>.</p><p>If you use my code to make your own Magic Windows, I&#39;d love to see them! I&#39;m on Twitter at <a href="https://twitter.com/mferraro89">@mferraro89</a>. Email me at <a href="mailto:mattferraro.dev@gmail.com">mattferraro.dev@gmail.com</a> and I will gladly help if you get stuck!</p><p>I know what you&#39;re thinking. <em>What about the hologram?!</em></p><p>Does the math above imply that a hologram will always be created, or is this one cat hologram just an incredible coincidence?</p><p>Well you see, I&#39;ve discovered a truly marvelous proof of this, which this website&#39;s margin is unfortunately too narrow to contain :)</p></article></div></div>
  </body>
</html>
