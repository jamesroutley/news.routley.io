<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://planetscale.com/blog/one-million-queries-per-second-with-mysql">Original</a>
    <h1>One million queries per second with MySQL</h1>
    
    <div id="readability-page-1" class="page"><article><header></header><section><div><p>Knowing your database can scale provides great peace of mind. <a href="https://planetscale.com/blog/planetscale-on-vitess">We built PlanetScale on top of Vitess</a> so that we could harness its ability to massively scale. One of the core strengths in our ability to scale is horizontal sharding. To demonstrate the power of horizontal sharding, we decided to run some benchmarking.</p>
<p>We set up a PlanetScale database and started running some benchmarks with <a href="https://github.com/Percona-Lab/sysbench-tpcc">a common tpc-c <code>sysbench</code> workload</a>. We weren’t aiming for a rigorous academic benchmark here, but we wanted to use a well-known and realistic workload. We will have more benchmark posts coming and have partnered with an academic institution who will be releasing their work soon.</p>
<p>For this post, there are two goals. The first is to demonstrate PlanetScale’s ability to handle large query volumes. For this, we set a goal of a million queries per second. In Vitess terms, this is not a large cluster. There are many Vitess clusters running at much higher query volumes, but we think it’s a good baseline. The second is demonstrating predictable scalability through horizontal scaling. Increasing throughput capacity is a matter of adding more machines.</p>
<h2 id="scaling-up-by-adding-shards"><a href="#scaling-up-by-adding-shards">Scaling up by adding shards<span aria-label="Permalink to Scaling up by adding shards" role="complementary">#</span></a></h2>
<p>We started with an unsharded database, then created a <a href="https://vitess.io/docs/14.0/reference/features/vschema/">vschema</a> and began sharding. Because we like powers of 2, we started with 2 shards and began doubling our shard count for subsequent runs. For each level of sharding, we ran <code>sysbench</code> several times, with increasing numbers of threads. With each iteration, we found there was a point at which additional threads no longer resulted in additional throughput. Instead, query latency increased as we reached our throughput limits.</p>
<p>In the graphs below, which were run against a 16 shard database, you can see the increase in the number of <code>sysbench</code> threads reflected in the number of connections. As the number of threads increases, so does the throughput in queries per second.</p>
<p><span><img alt="Connections over time -- chart progressively going up as time increases" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></p>
<p><span><img alt="QPS over time -- chart progressively going up as time increases" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></p>
<h2 id="hitting-the-limits"><a href="#hitting-the-limits">Hitting the limits<span aria-label="Permalink to Hitting the limits" role="complementary">#</span></a></h2>
<p>However, we begin to see diminishing returns as we saturate the resources of each shard. This is noticeable above when the QPS increase was greater between 1024 threads and 2048 threads than it was between 2048 threads and 4096 threads. Similarly, in metrics from <a href="https://vitess.io/docs/14.0/overview/architecture/">vtgate</a> shown below, we see an increase in latency as we max out our throughput. This is particularly evident in our p99 latency.</p>
<p><span><img alt="p50 latency -- chart progressively going up as time increases" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></p>
<p><span><img alt="p99 latency -- chart progressively going up as time increases and spiking toward the end" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></p><p>
At this point, we know we need additional shards to get more throughput.</p>
<h2 id="adding-more-shards"><a href="#adding-more-shards">Adding more shards<span aria-label="Permalink to Adding more shards" role="complementary">#</span></a></h2>
<p>In the data below, you can see the approximate doubling of queries per second as we double the number of shards. With 16 shards we maxed out around 420k QPS. With 32 shards we got up to 840k QPS. While we could continue doubling the number of shards indefinitely, we had set for ourselves a target of one million queries per second.</p>
<p><span><img alt="Graph showing QPS by shard count where QPS increases at roughly the same rate shards increase" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></p>
<h2 id="achieving-one-million-queries-per-second"><a href="#achieving-one-million-queries-per-second">Achieving one million queries per second<span aria-label="Permalink to Achieving one million queries per second" role="complementary">#</span></a></h2>
<p>It’s important to note that, while we like powers of 2, this isn’t a limitation, and we can use other shard counts. Since we had just over 800k QPS with 32 shards, we calculated that 40 shards would satisfy our 1M QPS requirement. When we spun this database up and ran our parallel sysbench clients against it, these were the results: over one million queries per second sustained over our 5 minute run.</p>
<p><span><img alt="Graph showing queries per second peaking just over 1M req/s over a 5 minute period" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></p>
<p>If you’d like to experience this level of database power, <a href="https://planetscale.com/contact">get in touch with our sales team</a>. We ran this benchmark against a <a href="https://planetscale.com/docs/concepts/deployment-options">single-tenant environment</a>, with levels of resources that we reserve for our enterprise customers. We also made a few non-standard configuration tweaks, including raising some query and transaction timeouts to accommodate this sysbench workload.</p>
<p>This is the first in a series of PlanetScale benchmark posts. Stay tuned for more.</p>
</div></section></article></div>
  </body>
</html>
