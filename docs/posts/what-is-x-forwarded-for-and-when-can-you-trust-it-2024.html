<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://httptoolkit.com/blog/what-is-x-forwarded-for/">Original</a>
    <h1>What is X-Forwarded-For and when can you trust it? (2024)</h1>
    
    <div id="readability-page-1" class="page"><article><p data-text="true" font-size="m" color="darkGrey">The X-Forwarded-For (XFF) HTTP header provides crucial insight into the origin of web requests. The header works as a mechanism for conveying the original source IP addresses of clients, and not just across one hop, but through chains of multiple intermediaries. This list of IPv4 and IPv6 addresses is helpful to understand where requests have really come from in scenarios where they traverse several servers, proxies, or load balancers.</p>
<p data-text="true" font-size="m" color="darkGrey">A typical HTTP request goes on a bit of a journey, traversing multiple layers of infrastructure before reaching its destination. Without the <code data-text="true" font-size="m" color="white">X-Forwarded-For</code> header, the receiving server would only see the IP address of the last intermediary in the chain (the direct source of the request) rather than the true client origin.</p>
<!-- -->
<p data-text="true" font-size="m" color="darkGrey"><span><img alt="A connection flow from Client to CDN to Load Balancer to Backend app" loading="lazy" width="1024" height="768" decoding="async" data-nimg="1" srcset="/images/posts/http-toolkit-assets/x-forwarded-for-flow-opt-1080.WEBP 1x, /images/posts/http-toolkit-assets/x-forwarded-for-flow-opt-1920.WEBP 2x" src="https://httptoolkit.com/images/posts/http-toolkit-assets/x-forwarded-for-flow-opt-1920.WEBP"/></span></p>
<p data-text="true" font-size="m" color="darkGrey">In thie example, by the time the backend application is seeing an incoming request, the IP address of the original client is long forgotten. This is where the <code data-text="true" font-size="m" color="white">X-Forwarded-For</code> header can help out. It looks like this:</p>
<pre><div><p data-text="true" font-size="m" color="white" font-weight="bold">Code example</p><div><pre aria-labelledby="code-label" tabindex="0"><span id="code-label">Code example</span><code>X-Forwarded-For: 28.178.124.142, 198.40.10.101
</code></pre></div></div></pre>
<p data-text="true" font-size="m" color="darkGrey">The goal here is to give a proxy the chance to say &#34;Alright hang on, I&#39;m forwarding you a request, and this is the history of where it came from, as far as I know&#34;.</p>
<p data-text="true" font-size="m" color="darkGrey">Note that the last proxy will not add its own IP address to the list, because that&#39;s already available: if the receiver of the request cares about who is calling it directly, they can combine the <code data-text="true" font-size="m" color="white">X-Forwarded-For</code> with the request&#39;s source IP address from the incoming connection, e.g: <code data-text="true" font-size="m" color="white">req.connection.remoteAddress</code> in NodeJS.</p>
<p data-text="true" font-size="m" color="darkGrey">In this example above, the load balancer has said &#34;Hey backend app, I am forwarding you a request that came from this client, via the CDN&#34;, and it doesn&#39;t need to pop its own IP in there because the backend app can already tell if it&#39;s coming from the load balancer or not.</p>
<p data-text="true" font-size="m" color="darkGrey">And of course the backend app&#39;s own IP is also not included, as it&#39;s the one actually receiving the header.</p>
<h2 data-heading="true" font-size="m" color="lightGrey" id="what-is-x-forwarded-for-used-for">What is X-Forwarded-For used for?</h2>
<p data-text="true" font-size="m" color="darkGrey">Knowing the original source &amp; processing path of requests has a whole load of use cases depending on what you&#39;re building.</p>
<ul>
<li>
<p data-text="true" font-size="m" color="darkGrey"><strong>User Authentication:</strong> Use the header information to ensure that login attempts originate from recognized and authorized locations, and flag the login as suspect if not, triggering 2FA checks.</p>
</li>
<li>
<p data-text="true" font-size="m" color="darkGrey"><strong>Load Balancing:</strong> Evenly distribute incoming traffic across servers, to ensure optimal performance during busy periods.</p>
</li>
<li>
<p data-text="true" font-size="m" color="darkGrey"><strong>Data localization:</strong> European Union, Brazil, China and others have privacy laws about where data can be kept, and this can help identify those users who need special treatment.</p>
</li>
<li>
<p data-text="true" font-size="m" color="darkGrey"><strong>Geographic Content Delivery:</strong> CDNs use <code data-text="true" font-size="m" color="white">X-Forwarded-For</code> to determine the user&#39;s location and serve content from the nearest server to reduce latency.</p>
</li>
<li>
<p data-text="true" font-size="m" color="darkGrey"><strong>Access Control and Security:</strong> Websites use <code data-text="true" font-size="m" color="white">X-Forwarded-For</code> to verify the legitimacy of requests and implement access controls based on IP addresses, like a corporate intranet that only allows access to certain resources for employees coming from recognized office IP ranges.</p>
</li>
<li>
<p data-text="true" font-size="m" color="darkGrey"><strong>Web Application Firewalls (WAF):</strong> Filter incoming traffic, blocking suspicious requests from a known malicious IP address listed in <code data-text="true" font-size="m" color="white">X-Forwarded-For</code>.</p>
</li>
<li>
<p data-text="true" font-size="m" color="darkGrey"><strong>Fraud Prevention:</strong> Financial institutions use <code data-text="true" font-size="m" color="white">X-Forwarded-For</code> to detect and prevent fraudulent activities based on user location, e.g. identifying an unusual login attempt from a location that is inconsistent with the user&#39;s typical access patterns.</p>
</li>
<li>
<p data-text="true" font-size="m" color="darkGrey"><strong>API Rate Limiting:</strong> APIs use <code data-text="true" font-size="m" color="white">X-Forwarded-For</code> to enforce rate limiting on a per-client basis. An API provider limits the number of requests from a specific IP address within a given time frame to prevent abuse.</p>
</li>
<li>
<p data-text="true" font-size="m" color="darkGrey"><strong>Localized Advertising:</strong> Ad platforms use <code data-text="true" font-size="m" color="white">X-Forwarded-For</code> to customize and target ads based on the user&#39;s geographical location.</p>
</li>
<li>
<p data-text="true" font-size="m" color="darkGrey"><strong>Logging and Analytics:</strong> log to analyze user traffic patterns and behaviors for statistical purposes, like the geographical distribution of users over a specific time period.</p>
</li>
</ul>
<p data-text="true" font-size="m" color="darkGrey">We&#39;re talking about security here, but this is an HTTP Request header... so can it not just be completely faked? Is the whole Internet built on a lie?!</p>
<h2 data-heading="true" font-size="m" color="lightGrey" id="can-you-trust-x-forwarded-for">Can you trust X-Forwarded-For?</h2>
<p data-text="true" font-size="m" color="darkGrey">You should never fully trust anything in an HTTP request that is coming from the outside world, and that includes <code data-text="true" font-size="m" color="white">X-Forwarded-For</code> headers.</p>
<p data-text="true" font-size="m" color="darkGrey">Actors can be malicious or misconfigured, but either way the contents of an HTTP request can be completely made up, and somebody could use <code data-text="true" font-size="m" color="white">X-Forwarded-For</code> to pretend they&#39;re coming from inside your corporate VPN once they know the IP, pretend they&#39;re in the same geographic region as a user whose bank account they&#39;re trying to log into, or all sorts of other shenanigans.</p>
<p data-text="true" font-size="m" color="darkGrey">Here&#39;s an example of how that might look, if the incoming header is blindly trusted:</p>
<!-- -->
<p data-text="true" font-size="m" color="darkGrey"><span><img alt="An example where a spoofed XFF header value is provided and forwarded" loading="lazy" width="1024" height="768" decoding="async" data-nimg="1" srcset="/images/posts/http-toolkit-assets/x-forwarded-for-spoofed-opt-1080.WEBP 1x, /images/posts/http-toolkit-assets/x-forwarded-for-spoofed-opt-1920.WEBP 2x" src="https://httptoolkit.com/images/posts/http-toolkit-assets/x-forwarded-for-spoofed-opt-1920.WEBP"/></span></p>
<p data-text="true" font-size="m" color="darkGrey">In this case, the client is sending an initial request to us that already includes an <code data-text="true" font-size="m" color="white">X-Forwarded-For</code> header with a 1.1.1.1 value. This could be the client&#39;s real internal address that&#39;s been added by proxy related to the client, or it could be an attempt by the client to confuse the server about the client&#39;s IP. It&#39;s impossible for us to tell the difference, so we must ignore this, and treat the client address our infrastructure sees (28.178.124.142) as the real source IP.</p>
<p data-text="true" font-size="m" color="darkGrey">One way to gain some control over the <code data-text="true" font-size="m" color="white">X-Forwarded-For</code> header is to involve a trusted reverse proxy, and disable direct access at the network level to the backend server and other proxies/servers/load balancers except through that proxy. For API developers this is typically handled by an API Gateway, but it could also be a CDN like Fastly, Squid Proxy, Cloudflare, etc. If the request is coming through a trusted proxy, and that reverse proxy itself hasn&#39;t been hacked, you&#39;re probably ok to believe at least some of the IP chain you&#39;re seeing. But which parts?</p>
<p data-text="true" font-size="m" color="darkGrey">In general, the further left you look in the header the more room there is for mistakes, as there are more servers which could be misconfigured, and anything that&#39;s coming from beyond the left-most proxy you control should be treated with suspicion.</p>
<p data-text="true" font-size="m" color="darkGrey">To help with this, you can make decisions at the reverse proxy level that change how the header is constructed. For example, <a href="https://www.nginx.com/" target="_blank" rel="noopener noreferrer">nginx<span>opens in a new tab</span></a> can override the <code data-text="true" font-size="m" color="white">X-Forwarded-For</code> header completely, ditching whatever the client provides, and replacing it with the IP address it is seeing. If all requests come through nginx, this effectively draws a line around your infrastructure, and drops all untrusted values received from outside, allowing all other services within your infrastructure to trust the header.</p>
<p data-text="true" font-size="m" color="darkGrey">You can do that for nginx using the below config:</p>
<pre><code data-text="true" font-size="m" color="white">proxy_set_header X-Forwarded-For $remote_addr;
</code></pre>
<p data-text="true" font-size="m" color="darkGrey">This replaces the <code data-text="true" font-size="m" color="white">X-Forwarded-For</code> header with the client&#39;s real IP address, dropping anything else.</p>
<p data-text="true" font-size="m" color="darkGrey">This resolves the issue with the client above who appears to be trying to hide their IP address, or pretend to be somebody else, by sending a falsified <code data-text="true" font-size="m" color="white">X-Forwarded-For</code> header. This header would be ignored by the CDN, and the request value would be replaced with just the actual IP address as seen by that server rather than being blindly accepted, like so:</p>
<!-- -->
<p data-text="true" font-size="m" color="darkGrey"><span><img alt="An blocked attempt to spoof an incoming X-Forwarded-For header" loading="lazy" width="1024" height="768" decoding="async" data-nimg="1" srcset="/images/posts/http-toolkit-assets/x-forwarded-for-spoof-blocked-opt-1080.WEBP 1x, /images/posts/http-toolkit-assets/x-forwarded-for-spoof-blocked-opt-1920.WEBP 2x" src="https://httptoolkit.com/images/posts/http-toolkit-assets/x-forwarded-for-spoof-blocked-opt-1920.WEBP"/></span></p>
<p data-text="true" font-size="m" color="darkGrey">Dropping all external values like this is the safest approach when you&#39;re not sure how secure and reliable the rest of your call chain is going to be. If other proxies and backend apps are likely to blindly trust the incoming information, or generally make insecure choices (which we&#39;ll get into more later) then it&#39;s probably safest to completely replace the <code data-text="true" font-size="m" color="white">X-Forwarded-For</code> header at that outside-world facing reverse proxy, and ditch any untrustworthy data in the process.</p>
<p data-text="true" font-size="m" color="darkGrey">On the other hand, if you&#39;re confident the backend app is able to handle it, you can accept the incoming values, and simply append the IP address being seen by the server on the end of the chain. This can be helpful if your infrastructure doesn&#39;t necessarily have a single entry point, making it harder to guarantee this kind of header sanitization.</p>
<p data-text="true" font-size="m" color="darkGrey">To simply append the incoming address to the header, but preserve the original values too, you can use this nginx config:</p>
<pre><code data-text="true" font-size="m" color="white">proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
</code></pre>
<p data-text="true" font-size="m" color="darkGrey">This is a special bit of functionality in nginx, but most reverse proxies will have similar logic. It will build up the header to maintain whatever the client initially passed, and if they are connecting through any intermediary proxies, so long as those proxies support <code data-text="true" font-size="m" color="white">X-Forwarded-For</code>, then that information will be passed along too.</p>
<p data-text="true" font-size="m" color="darkGrey">With this approach, the backend server receives the full chain of everything reported through to them. This can be good or bad, and requires that everyone using this header knows that there can be a fair few problems with this data, and is prepared to handle it correctly.</p>
<h2 data-heading="true" font-size="m" color="lightGrey" id="which-ip-in-the-list-is-really-the-client">Which IP in the list is really the client?</h2>
<p data-text="true" font-size="m" color="darkGrey">In either of the above scenarios, your backend server will eventually end up with a header containing a list of IP addresses.</p>
<p data-text="true" font-size="m" color="darkGrey">You might be looking at that list of IPs wondering &#34;which is <em>the</em> client IP&#34; - for almost all the use cases discussed, this is the key value you&#39;re interested in. The answer: <strong>reading right to left, the first IP address that is not one of yours</strong>. Although there might be more IPs before this (which could be proxies local to the client, or their ISP) there&#39;s no way whatsoever to verify them, and so you have to ignore them entirely and use the first-from-right unknown address.</p>
<p data-text="true" font-size="m" color="darkGrey">Note that this logic assumes that your server is <em>not</em> directly accessible. If it is, you need to check the actual request source IP address is one of yours first - effectively treating that as an extra right-most address.</p>
<p data-text="true" font-size="m" color="darkGrey">When it comes to logging you want to log all of these IPs (escaped and limited to valid values) but when it comes to security-based use cases there is only one &#34;client IP&#34; you can trust: the one immediately to the left of the last known private/internal IP address. In other words: the last &#34;not one of ours&#34; server that&#39;s valid, and not internal.</p>
<p data-text="true" font-size="m" color="darkGrey">So, if we got a request like this, which one do we use for security checks or geolocation?</p>
<pre><div><p data-text="true" font-size="m" color="white" font-weight="bold">Code example</p><div><pre aria-labelledby="code-label" tabindex="0"><span id="code-label">Code example</span><code>X-Forwarded-For: 1.2.3.4, 172.16.1.101, 28.178.124.142, 198.40.10.101
</code></pre></div></div></pre>
<p data-text="true" font-size="m" color="darkGrey">There are two common approaches to actually implement this:</p>
<h3 data-heading="true" font-size="s" color="lightGrey" id="1-picking-by-trusted-proxy-list">1) Picking by Trusted Proxy List</h3>
<p data-text="true" font-size="m" color="darkGrey">One approach is to look at the specific IPs and see if they are recognized, going from the right until you see an IP you don&#39;t recognize. This requires maintaining a list of IPs (or at least IP ranges) for your internal infrastructure.</p>
<ul>
<li>Let&#39;s assume that <code data-text="true" font-size="m" color="white">198.40.10.101</code> is flagged as one of your own servers in your list.</li>
<li>Then you look at <code data-text="true" font-size="m" color="white">28.178.124.142</code>. Is that not one of yours? Not invalid? Not internal? Great - that&#39;s the client, and it looks like they&#39;re in Ohio, USA. Serve them content from the American servers, and no data protection required because they don&#39;t care about privacy laws.</li>
</ul>
<p data-text="true" font-size="m" color="darkGrey">One mistake here would be to look one to the left of the first-from-left internal IP. If you do so, that might notice <code data-text="true" font-size="m" color="white">172.16.1.101</code> which is an <a href="https://www.lifewire.com/what-is-a-private-ip-address-2625970" target="_blank" rel="noopener noreferrer">internal IP according to IANA<span>opens in a new tab</span></a>. Yes, it is internal, but it&#39;s not a known and trusted internal IP you control. That has been reported to you in the HTTP request, possibly for valid reasons (the client is using some sort of intermediary server), or possibly malicious reasons (the client is really <code data-text="true" font-size="m" color="white">28.178.124.142</code> but they want you to think their real IP address is <code data-text="true" font-size="m" color="white">1.2.3.4</code> and hoped this would trick you).</p>
<p data-text="true" font-size="m" color="darkGrey">That can be a pretty complicated approach and requires the backend to know quite a lot about the infrastructure involved, and might be even harder in a cloud environment where IPs might be changing a lot, but it&#39;s doable.</p>
<h3 data-heading="true" font-size="s" color="lightGrey" id="2-picking-by-trusted-proxy-count">2) Picking by Trusted Proxy Count</h3>
<p data-text="true" font-size="m" color="darkGrey">Instead of looking at the specific IPs, the number of trusted proxies between the internet and the backend server can be configured. This can be more flexible that tracking IP ranges, but requires careful maintainence whenever layers of intermediate infrastructure are changed, and can be very challenging if there are multiple paths to the same servers.</p>
<p data-text="true" font-size="m" color="darkGrey">To do this, the <code data-text="true" font-size="m" color="white">X-Forwarded-For</code> IP list is searched from the right, <strong>skipping the number of proxies minus one</strong>.</p>
<p data-text="true" font-size="m" color="darkGrey"><span><img alt="A request path, from Client to CDN to Load Balancer to Backend" loading="lazy" width="1024" height="768" decoding="async" data-nimg="1" srcset="/images/posts/http-toolkit-assets/x-forwarded-for-path-opt-1080.WEBP 1x, /images/posts/http-toolkit-assets/x-forwarded-for-path-opt-1920.WEBP 2x" src="https://httptoolkit.com/images/posts/http-toolkit-assets/x-forwarded-for-path-opt-1920.WEBP"/></span></p>
<p data-text="true" font-size="m" color="darkGrey">For example, in this infrastructure we know we have two intermediaries: the CDN &amp; the load balancer.</p>
<p data-text="true" font-size="m" color="darkGrey">Let&#39;s assume the server receives something like this:</p>
<pre><div><p data-text="true" font-size="m" color="white" font-weight="bold">Code example</p><div><pre aria-labelledby="code-label" tabindex="0"><span id="code-label">Code example</span><code>X-Forwarded-For: 1.2.3.4, 172.16.1.101, 28.178.124.142, 198.40.10.101
</code></pre></div></div></pre>
<p data-text="true" font-size="m" color="darkGrey">When reading this, remember that the backend is the one receiving this header, so it doesn&#39;t modify it or appear in it, and everybody else adds the <em>previous</em> step, so the load balancer isn&#39;t included either (this is why we minus one from our count).</p>
<p data-text="true" font-size="m" color="darkGrey">So, to understand this header we&#39;re going to count from the right, counting how many proxies are to the left before we get to the outside Internet. Remember that we could the number of intermediaries <em>minus one</em> - so in this case we just skip the one right-most value (<code data-text="true" font-size="m" color="white">198.40.10.101</code>). The logic is:</p>
<ol>
<li>Load Balancer - this IP is not shown in the header (but is available to the backend server anyway, because it&#39;s the direct source of the request connection).</li>
<li><code data-text="true" font-size="m" color="white">198.40.10.101</code> - CDN</li>
<li><code data-text="true" font-size="m" color="white">28.178.124.142</code> - Client IP</li>
</ol>
<p data-text="true" font-size="m" color="darkGrey">Code to do this for yourself could look something like this:</p>
<pre><div><p data-text="true" font-size="m" color="white" font-weight="bold">Code example</p><div><pre aria-labelledby="code-label" tabindex="0"><span id="code-label">Code example</span><code>const headers = {
  &#34;X-Forwarded-For&#34;: &#34;1.2.3.4,172.16.1.101,28.178.124.142,198.40.10.101&#34;
}

const config = {
  trusted_proxy_count: 2
}

const ips = headers[&#34;X-Forwarded-For&#34;]
  .split(&#39;,&#39;) // Get the separate IPs
  .reverse(); // Count from the right
const clientIp = ips[config.trusted_proxy_count - 1];

console.log(clientIp) // &#34;28.178.124.142&#34;
</code></pre></div></div></pre>
<p data-text="true" font-size="m" color="darkGrey"><em>(This is simplified for readability - note that this doesn&#39;t handle any of the broader security concerns we&#39;ll discuss below)</em></p>
<p data-text="true" font-size="m" color="darkGrey">Basically if there are three reverse proxies, the last two IP addresses will be internal.</p>
<p data-text="true" font-size="m" color="darkGrey">If your infrastructure is simple and there is only one reverse proxy, that proxy will add the client&#39;s IP address, so the rightmost address can be used directly (as long as you&#39;re sure that the backend server is <em>only</em> accessible via the proxy server or you always validate that the IP of the received request itself is the reverse proxy&#39;s IP).</p>

<p data-text="true" font-size="m" color="darkGrey">Above we&#39;ve talked about which parts of the data you read from the X-Forwarded-For header you can trust. But there are also some risks to manage in the parsing stage, before you even start looking through the values themselves.</p>
<p data-text="true" font-size="m" color="darkGrey">In most cases, this parsing should be handled for you by a library or your server framework, but it&#39;s important to understand how that works, and to test that this is handled correctly in your environment.</p>
<h3 data-heading="true" font-size="s" color="lightGrey" id="invalid-ip-addresses">Invalid IP Addresses</h3>
<p data-text="true" font-size="m" color="darkGrey">First of all, there&#39;s no reason to assume everything in there will always be a valid IP address.</p>
<p data-text="true" font-size="m" color="darkGrey">A client can include anything. If your code assumes valid data in a specific format, it can easily crash, typically resulting in 500 Internal Server Error for the client and potential other side effects server-side, and opening the door to all sorts of DDoS attacks.</p>
<p data-text="true" font-size="m" color="darkGrey">Even valid data can be challenging, as there&#39;s a few different possible formats here. The IPv4 address format is fairly simple, standard &amp; well recognized (IPv4 addresses should be 4 numbers, each from 0 to 255, separated by dots) and so this is generally not a huge problem, but with the rising use of IPv6 this gets quite a bit more complicated, and it&#39;s worth familiarizing yourself with the <a href="https://en.wikipedia.org/wiki/IPv6_address" target="_blank" rel="noopener noreferrer">IPv6 address format<span>opens in a new tab</span></a> if you&#39;re not already.</p>
<p data-text="true" font-size="m" color="darkGrey">In some scenarios, the header may also include a port on the addresses too (with a <code data-text="true" font-size="m" color="white">:$PORT</code> suffix) - typically you&#39;ll want to just ignore this, but it&#39;s worth testing that that is handled correctly.</p>
<p data-text="true" font-size="m" color="darkGrey">Wikipedia has some <a href="https://en.wikipedia.org/wiki/X-Forwarded-For#Format" target="_blank" rel="noopener noreferrer">useful examples<span>opens in a new tab</span></a> of common formats.</p>
<h3 data-heading="true" font-size="s" color="lightGrey" id="separator-parsing">Separator parsing</h3>
<p data-text="true" font-size="m" color="darkGrey">Between each IP address, a simple comma with optional whitespace is used as a separator.</p>
<p data-text="true" font-size="m" color="darkGrey">This too has some parsing gotchas. There&#39;s a few ways you could parse this wrong, and doing so would open doors to <a href="https://en.wikipedia.org/wiki/HTTP_request_smuggling" target="_blank" rel="noopener noreferrer">request smuggling<span>opens in a new tab</span></a>, where an intermediate server interprets data differently to the backend server, and shared assumptions break down.</p>
<p data-text="true" font-size="m" color="darkGrey">Blindly splitting on a simple <code data-text="true" font-size="m" color="white">,</code> character and sending the result off to various other services (like an API call) means all sorts of unexpected things could happen.</p>
<p data-text="true" font-size="m" color="darkGrey">You&#39;ll want to watch out for trailing or leading commas here, make sure you trim whitespace between values, and again reject any unexpected invalid data here aggressively to keep things clean &amp; under control.</p>

<p data-text="true" font-size="m" color="darkGrey">It&#39;s quite possible for a request to include multiple <code data-text="true" font-size="m" color="white">X-Forwarded-For</code> headers! There&#39;s rarely any good reason to do this, but similar to these other issues, you should make sure you handle it correctly.</p>
<p data-text="true" font-size="m" color="darkGrey">If this happens, the <a href="https://www.rfc-editor.org/rfc/rfc7230#section-3.2.2" target="_blank" rel="noopener noreferrer">HTTP spec<span>opens in a new tab</span></a> says:</p>
<blockquote>
<p data-text="true" font-size="m" color="darkGrey">A recipient MAY combine multiple header fields with the same field name into one &#34;field-name: field-value&#34; pair, without changing the semantics of the message, by appending each subsequent field value to the combined field value in order, separated by a comma.</p>
</blockquote>
<p data-text="true" font-size="m" color="darkGrey">I.e. it&#39;s technically correct to combine them together in order. That said, trusting that this is safe &amp; correct requires assuming that upstream proxies have done the same, or you&#39;re exposed to request smuggling here too.</p>
<p data-text="true" font-size="m" color="darkGrey">Up to you, but in practice this should be extremely rare in normal usage, so if you&#39;re not sure I&#39;d be inclined to drop all duplicated headers entirely.</p>
<h3 data-heading="true" font-size="s" color="lightGrey" id="arbitrary-code-execution">Arbitrary code execution?</h3>
<p data-text="true" font-size="m" color="darkGrey">Beyond invalid or faked addresses, it&#39;s technically possible to include literal malicious code in here!</p>
<p data-text="true" font-size="m" color="darkGrey">If a bad actor knew (or guessed) the programming language and logging frameworks being used, and if that logging system does not sanitize/escape input or has a bug that allows code to be executed in the logger, then somebody could be running random code on your server.</p>
<p data-text="true" font-size="m" color="darkGrey">This is particularly notable given vulnerabilities like <a href="https://blog.shiftleft.io/log4shell-apache-log4j-remote-code-execution-4f58ed7e74f9" target="_blank" rel="noopener noreferrer">CVE-2021-44228 a.k.a. &#34;Log4Shell”<span>opens in a new tab</span></a> where logging a string could indeed potentially run arbitrary code.</p>
<p data-text="true" font-size="m" color="darkGrey">Given a request like:</p>
<pre><div><p data-text="true" font-size="m" color="white" font-weight="bold">Code example</p><div><pre aria-labelledby="code-label" tabindex="0"><span id="code-label">Code example</span><code>X-Forwarded-For: 1.2.3.4,nonsense,${malicious()},2.2.2.2,28.178.124.142,198.40.10.101
</code></pre></div></div></pre>
<p data-text="true" font-size="m" color="darkGrey">If a service affected by this vulnerability attempted to log that via log4j, it could run arbitrary code, creating major problems.</p>
<p data-text="true" font-size="m" color="darkGrey">To protect against this, remember to validate inputs first - any logic using this field should ignore anything that is not a valid IP address. Beyond that, it&#39;s sensible to do some basic checks before logging this to a database, like checking the length of string so you&#39;re not filling up your DB with trash and potentially making other DDoS and resource management issues.</p>
<p data-text="true" font-size="m" color="darkGrey">See <a href="https://owasp.org/Top10/A03_2021-Injection/" target="_blank" rel="noopener noreferrer">OWASP A03:2021 – Injection<span>opens in a new tab</span></a> and <a href="https://owasp.org/API-Security/editions/2023/en/0xa4-unrestricted-resource-consumption/" target="_blank" rel="noopener noreferrer">OWASP API4:2023 - Unrestricted Resource Consumption<span>opens in a new tab</span></a> for more on what can go wrong there.</p>
<p data-text="true" font-size="m" color="darkGrey">Whichever approach you pick for the client-facing proxy, make sure every other server in the chain is not directly accessible, or you&#39;ll not ever be able to trust any of it.</p>
<h2 data-heading="true" font-size="m" color="lightGrey" id="alternatives-standards">Alternatives &amp; Standards</h2>

<p data-text="true" font-size="m" color="darkGrey"><code data-text="true" font-size="m" color="white">X-Forwarded-For</code> is very widely used, but it&#39;s not part of any current formal specification. It&#39;s a convention implemented by various bits of software and services in a similar way, but has not been standardized by anyone like the IETF.</p>
<p data-text="true" font-size="m" color="darkGrey">The IETF folks have been deprecating X- headers since <a href="https://datatracker.ietf.org/doc/html/rfc6648" target="_blank" rel="noopener noreferrer">RFC 6648: Deprecating the &#34;X-&#34; Prefix and Similar Constructs<span>opens in a new tab</span></a> in 2012 (if you&#39;re interested in why, Mark Nottingham gives great backstory on this in <a href="https://www.mnot.net/blog/2009/02/18/x-" target="_blank" rel="noopener noreferrer">Stop it with the X- Already!<span>opens in a new tab</span></a>). In part the effort to standardize common X- extensions is down to a single specification making implementations more reliable, but in practice its also because the convention that was first imagined is often overly simplistic, missing important use-cases not thought of when first conceived.</p>
<p data-text="true" font-size="m" color="darkGrey">Whilst the <code data-text="true" font-size="m" color="white">X-Forwarded-For</code> is popular, and generally doesn&#39;t suffer from compatibility issues, there&#39;s room for making it better, and that takes the form of the <code data-text="true" font-size="m" color="white">Forwarded</code> header defined by <a href="https://datatracker.ietf.org/doc/html/rfc7239" target="_blank" rel="noopener noreferrer">RFC 7239: Forwarded HTTP Extension<span>opens in a new tab</span></a> finalized in 2014:</p>
<pre><code data-text="true" font-size="m" color="white">Forwarded: for=192.0.2.60;proto=http;by=203.0.113.43
</code></pre>
<p data-text="true" font-size="m" color="darkGrey">It&#39;s really similar to <code data-text="true" font-size="m" color="white">X-Forwarded-For</code>, but also incorporates functionality from <code data-text="true" font-size="m" color="white">X-Forwarded-Proto</code>. By combining <code data-text="true" font-size="m" color="white">-For</code> and <code data-text="true" font-size="m" color="white">-Proto</code> into a single header there&#39;s less room for confusion stitching things together.</p>
<pre><code data-text="true" font-size="m" color="white">X-Forwarded-For: 192.0.2.172
Forwarded: for=192.0.2.172

X-Forwarded-For: 192.0.2.43, 2001:db8:cafe::17
Forwarded: for=192.0.2.43, for=&#34;[2001:db8:cafe::17]&#34;
</code></pre>
<p data-text="true" font-size="m" color="darkGrey"><em>(Examples from <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Forwarded" target="_blank" rel="noopener noreferrer">MDN Web Docs: HTTP &gt; HTTP headers &gt; Forwarded<span>opens in a new tab</span></a>)</em></p>
<p data-text="true" font-size="m" color="darkGrey">Whether you should use <code data-text="true" font-size="m" color="white">X-Forwarded-For</code> or <code data-text="true" font-size="m" color="white">Forwarded</code> version can be a tricky question, and typically depends on the tools and service providers you&#39;re using. Does all the tooling in your infrastructure support it?</p>
<p data-text="true" font-size="m" color="darkGrey">Does it matter for any practical reason when you can just use <code data-text="true" font-size="m" color="white">X-Forwarded-For</code>, or is this just vibes and &#34;being proper&#34;? There is has one major benefit that might make it worth the effort of checking compatibility: Forwarded has extensibility.</p>
<p data-text="true" font-size="m" color="darkGrey">With <code data-text="true" font-size="m" color="white">X-Forwarded-For</code>, you have to figure out which IP address is the client IP with hardcoded rules such as “take the 3rd last IP address”. Whether you&#39;re using lists or counts, it&#39;s not just a faff, it&#39;s subject to change as your infrastructure evolves.</p>
<p data-text="true" font-size="m" color="darkGrey">With <code data-text="true" font-size="m" color="white">Forwarded</code>, <a href="https://www.nginx.com/resources/wiki/start/topics/examples/forwarded/" target="_blank" rel="noopener noreferrer">as nginx suggest<span>opens in a new tab</span></a>, your trusted client-facing proxy could include a secret token to identify itself:</p>
<pre><code data-text="true" font-size="m" color="white">Forwarded: for=12.34.56.78, for=23.45.67.89;secret=egah2CGj55fSJFs, for=10.1.2.3
</code></pre>
<p data-text="true" font-size="m" color="darkGrey">Additionally, <code data-text="true" font-size="m" color="white">Forwarded</code> allows including other fields like <code data-text="true" font-size="m" color="white">proto=</code>, <code data-text="true" font-size="m" color="white">by=</code>, <code data-text="true" font-size="m" color="white">host=</code>, and potentially others in future.</p>
<p data-text="true" font-size="m" color="darkGrey">Really, the only true downside here is the existing much wider use &amp; support for <code data-text="true" font-size="m" color="white">X-Forwarded-For</code>, but there are solid reasons to aim to use <code data-text="true" font-size="m" color="white">Forwarded</code> where possible, and to plan to migrate tooling in that direction in future.</p>
<h3 data-heading="true" font-size="s" color="lightGrey" id="x-forwarded-host-proto">X-Forwarded-Host/Proto</h3>
<p data-text="true" font-size="m" color="darkGrey">There are actually two other headers in the XFF family:</p>
<ul>
<li><code data-text="true" font-size="m" color="white">X-Forwarded-Host</code>: this allows a proxy to forward the originally provided <code data-text="true" font-size="m" color="white">Host</code> header from an upstream client</li>
<li><code data-text="true" font-size="m" color="white">X-Forwarded-Proto</code>: this allows a proxy to forward the originally used protocol (<code data-text="true" font-size="m" color="white">http</code> or <code data-text="true" font-size="m" color="white">https</code>)</li>
</ul>
<p data-text="true" font-size="m" color="darkGrey">Neither is widely used, but it&#39;s worth being aware of these in case you do have a specific need for extra data about the original client request in future.</p>

<p data-text="true" font-size="m" color="darkGrey">There is another similar HTTP header: <code data-text="true" font-size="m" color="white">Via</code>, defined in RFC 9110 and finalized in 2022. This header exposes the data of the intermediaries on the request path themselves, rather than the client IPs they saw (i.e. each proxy will add its own address, not the address of the client from its perspective).</p>
<p data-text="true" font-size="m" color="darkGrey">This also has more of a focus on the protocol (HTTP or HTTPS) and the version (<code data-text="true" font-size="m" color="white">HTTP/1.1 proxy.example.re, 1.1 edge_1</code>). This information is intended to help figure out if connection has been downgraded at any point, whether that&#39;s from HTTP/2 to 1.1 or from HTTPS to HTTP, and to make backend servers aware of the capabilities of the full connection path.</p>
<p data-text="true" font-size="m" color="darkGrey">As it also adds the hostname of proxy, and some optional information about the specific product and version of the proxy, it may seem pretty similar for <code data-text="true" font-size="m" color="white">X-Forwarded-For</code> and <code data-text="true" font-size="m" color="white">Forwarded</code>, but the <code data-text="true" font-size="m" color="white">Via</code> header is more for information/debugging or identifying and working around buggy proxies.</p>
<h3 data-heading="true" font-size="s" color="lightGrey" id="and-others">And others...</h3>
<p data-text="true" font-size="m" color="darkGrey"><code data-text="true" font-size="m" color="white">X-Forwarded-For</code> is widely supported and easily the most popular solution to this problem, but it&#39;s definitely not the only one. In addition to the relatively standard options above, there&#39;s a few other non-standard headers available, which do similar things in certain contexts:</p>
<ul>
<li><code data-text="true" font-size="m" color="white">X-Real-IP</code>: how this is used varies quite a bit - some systems use it to forward just a single IP that they consider the &#39;real&#39; client, some use it just like XFF, and who knows what else. This is rarely supported, and generally not recommended unless you&#39;re sure you know what it means in your context.</li>
<li><code data-text="true" font-size="m" color="white">​​CF-Connecting-IP</code>: Cloudflare&#39;s version of the real IP header, listing the client IP specifically.</li>
<li><code data-text="true" font-size="m" color="white">Ali-CDN-Real-IP</code>: Alibaba Cloud CDN&#39;s own version of this, potentially with minor variations (hard to tell).</li>
<li><code data-text="true" font-size="m" color="white">X-NF-Client-Connection-IP</code>: this is Netlify&#39;s <a href="https://answers.netlify.com/t/is-the-client-ip-header-going-to-be-supported-long-term/11203" target="_blank" rel="noopener noreferrer">officially recommended<span>opens in a new tab</span></a> header to get the client IP (they do not support XFF or others, even though they might still appear in your request headers!)</li>
<li><code data-text="true" font-size="m" color="white">X-Vercel-Forwarded-For</code>: Vercel&#39;s version of XFF, with some additional (but unclear) extra validation</li>
<li><code data-text="true" font-size="m" color="white">X-Vercel-IP-{...}</code>: a set of Vercel headers for the client&#39;s country, city, timezone, and other details their edge servers automatically infer. More info in <a href="https://vercel.com/docs/edge-network/headers" target="_blank" rel="noopener noreferrer">their docs<span>opens in a new tab</span></a>.</li>
<li><code data-text="true" font-size="m" color="white">Cache-Status</code>, <code data-text="true" font-size="m" color="white">X-Cache-Status</code>, <code data-text="true" font-size="m" color="white">X-Served-By</code>, etc: this is the same concept in reverse. This header is included in responses, and provides response path information for clients, letting them know which caches processed the request, and whether the response came fresh directly from the backend server or from a cache en route. For more information, see <a href="https://httptoolkit.com/blog/status-targeted-caching-headers/" target="_blank" rel="noopener noreferrer">New HTTP Standards for Caching<span>opens in a new tab</span></a>.</li>
</ul>
<h2 data-heading="true" font-size="m" color="lightGrey" id="summary">Summary</h2>
<p data-text="true" font-size="m" color="darkGrey">Now you know what <code data-text="true" font-size="m" color="white">X-Forwarded-For</code> and <code data-text="true" font-size="m" color="white">Forwarded</code> are for, and can leverage that knowledge to deliver localized content, support rate limiting, flag likely fraud, or even serve content from the closest server to <a href="https://learn.greensoftware.foundation/introduction" target="_blank" rel="noopener noreferrer">reduce the carbon impact of your data transmission<span>opens in a new tab</span></a>.</p>
<p data-text="true" font-size="m" color="darkGrey">Use these powers wisely, and remember that this depends on close integration between backend &amp; deployment infrastructure development, so don&#39;t sneak them into changes without talking to the rest of your team first!</p>
<p data-text="true" font-size="m" color="darkGrey"><em>Want to inspect real clients&#39; headers for yourself right now, or try spoofing your own headers and see what happens? Fire up <strong><a href="https://httptoolkit.com/" target="_blank" rel="noopener noreferrer">HTTP Toolkit<span>opens in a new tab</span></a></strong>, intercept &amp; debug your Android/web/Docker/other traffic, set some breakpoint rules to modify it, and explore this up close.</em></p>
<h2 data-heading="true" font-size="m" color="lightGrey" id="further-reading">Further Reading</h2>
<ul>
<li><a href="https://datatracker.ietf.org/doc/html/rfc7239" target="_blank" rel="noopener noreferrer">RFC 7239: Forwarded HTTP Extension<span>opens in a new tab</span></a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For" target="_blank" rel="noopener noreferrer">MDN Web Docs: X-Forwarded-For<span>opens in a new tab</span></a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Forwarded" target="_blank" rel="noopener noreferrer">MDN Web Docs: Forwarded<span>opens in a new tab</span></a></li>
<li><a href="https://www.nginx.com/resources/wiki/start/topics/examples/forwarded/" target="_blank" rel="noopener noreferrer">Using Forwarded in NGINX<span>opens in a new tab</span></a></li>
<li><a href="https://developers.cloudflare.com/fundamentals/reference/http-request-headers/" target="_blank" rel="noopener noreferrer">Cloudflare Fundamentals: HTTP request headers<span>opens in a new tab</span></a></li>
</ul><p><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256"><path d="M227.31,73.37,182.63,28.68a16,16,0,0,0-22.63,0L36.69,152A15.86,15.86,0,0,0,32,163.31V208a16,16,0,0,0,16,16H92.69A15.86,15.86,0,0,0,104,219.31L227.31,96a16,16,0,0,0,0-22.63ZM92.69,208H48V163.31l88-88L180.69,120ZM192,108.68,147.31,64l24-24L216,84.68Z"></path></svg> Suggest changes to this page<a href="https://github.com/httptoolkit/httptoolkit-website/blob/main/src/content/posts/what-is-x-forwarded-for.mdx" target="_blank" rel="noopener noreferrer">on GitHub<span>opens in a new tab</span></a></p></article></div>
  </body>
</html>
