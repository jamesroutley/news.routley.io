<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pthorpe92.github.io/ocaml/ocaml-first-thoughts/">Original</a>
    <h1>OCaml: a Rust developer&#39;s first impressions</h1>
    
    <div id="readability-page-1" class="page"><div>
      



<div id="main" role="main">
  
  



  <div>
    
      
    
    <h3 id="ocaml-first-impressions">OCaml: First impressions</h3>

<h4 id="the-why">The Why</h4>

<p>Iâ€™m somewhat of a language nerd to begin with, and it was Rust that originally got me interested in the whole functional paradigm.
Not due to itâ€™s lineage, but the heavy use of chained iterator methods in favor over traditional loops. This is one of the more intimidating hurdles
for newcomers to the language, but after getting used to it, rarely will you see anyone write a <code>for</code> loop again.</p>

<p><strong>Rant:</strong> The argument can be made that what Iâ€™m talking about is more similar to Javascript-land where a bunch of pseudo-functional methods and terminology are 
used, but it in reality is as far away from functional programming as <code>useState()</code> would imply it is. 
At least Rust has a few things to back it up, as at least a language that will support you should you desire to write pure functional code. I would argue that for beginners, Rust will simply force you to write functional, immutable code, whether they really understand it or otherwise, as the amount of <code>.clone()</code>â€˜ing required for a newcomer to compile a non-trivial program will practically almost guarantee that nothing was actually <code>&amp;mut</code>ated*.</p>

<p>So this got me interested in watching some <em>GOTO</em>, <em>strangeloop</em>, and other conference talks about functional programming, and upon discovering @artemslab
(definitely go check it out, awesome content) on YouTube and watching some in-depth videos about Ocaml and itâ€™s runtime integer representations and memory
allocation, that really got me fascinated with the language.</p>

<p>In the past, I typically wouldnâ€™t hesitate to <code>sudo pacman -Sy </code> whatever compiler or interpreter I needed, to get started playing around with a new language I was interested in. However since getting full-time employment, on top of the existing OSS stuff,
as well as doing contracted gigs for the facility Iâ€™m in, I havenâ€™t had so much as a moment to spend on anything un-related to these things in quite some time.</p>

<p>Anyways, as usual Iâ€™m off track here. My point is that I <em>thought</em> I had a good introduction to the world of FP, and I <em>thought</em> since Iâ€™d heard that many of the
features and some of the syntax we love from Rust came directly from tha â€˜Caml itself, I thought I would be love it and picking it up would be second nature.</p>

<p>My plan was to do the entire Advent of Code in Ocaml, and I was also going to pick an ambitious project that I would otherwise use Rust for, and force myself
to use Ocaml. I find this is the best way to learn a language, is just take on a project that is significantly more ambitious than your current skill level, and by thetime you finish it, youâ€™ll have not only saved yourself a bunch of wasted time on tutorials, but youâ€™ll have made something cool (hopefully).</p>

<h3 id="i-have-two-gripes-with-the-language-so-far">I have two gripes with the language (so far)..</h3>

<h3 id="where-are-the-types-">Where are the types? ðŸ‘€</h3>

<p>I underestimated how much I would be thrown off by the fact that the types are <em>heavily</em> inferred, and are almost never explicitly declared, from what I can tell. I found that the combination of this and the strange syntax really screws me up, as now I am having problems inferring my <em>own</em> types at this pointâ€¦</p>

<p>When dealing with lots of recursive functions, you find yourself looking up often at the function signature to view the parameters, but the concise syntax makes it difficult to mentally parse quickly.</p>

<p>Example, random code snippet from ocaml.org:</p>
<pre><code>  let group list sizes =
    let initial = List.map (fun size -&gt; size, []) sizes in

  let prepend p list =
    let emit l acc = l :: acc in
    let rec aux emit acc = function
      | [] -&gt; emit [] acc
      | (n, l) as h :: t -&gt;
         let acc = if n &gt; 0 then emit ((n - 1, p :: l) :: t) acc
                   else acc in
         aux (fun l acc -&gt; emit (h :: l) acc) acc t
    in
    aux emit [] list
  in
  let rec aux = function
    | [] -&gt; [initial]
    | h :: t -&gt; List.concat_map (prepend h) (aux t)
  in
  let all = aux list in
  let complete = List.filter (List.for_all (fun (x, _) -&gt; x = 0)) all in
    List.map (List.map snd) complete;;
val group : &#39;a list -&gt; int list -&gt; &#39;a list list list = &lt;fun&gt;
;;
</code></pre>
<p>Even when you learn what it actually going on here, and it makes immediate sense to you.. It must take a while before it becomes easier to read.</p>

<h3 id="remember-recursion-how-about-linked-lists">Remember recursion? How about linked lists?</h3>

<p>Two things every Computer science student learns, and then are immediately told to never use again*â€¦</p>

<p>Anything that can be done recursively can be done iteratively (and most optimizing compilers will replace your recursion anyway), and linked lists are slow and inefficient with modern CPU caches, and you should almost never use them (and if youâ€™re a web dev, well, you just wouldnâ€™t anyway).</p>

<p>You could describe Ocaml as a language that relies <strong>heavily</strong> on <em>both</em> of these things. This feels even more strange that it might seem it would, and I have
found myself stumbling on absolutely remedial tasks.</p>

<p>Yes, there are libraries with other data structures, and there are in fact <code>for</code> loops (and even <code>while</code> loops), However I feel like I will end up learning more of the language and find that iterator methods will be used more so than any of these, much as in Rust.</p>



<ul>
  <li>
    <p>Thought provoking. If you donâ€™t believe there is anything to gain from being forced to think about something you do every day in a completely different wayâ€¦ well Iâ€™m surprised you made it this far into the post.</p>
  </li>
  <li>
    <p>Awesome mixture of !significant-whitespace and !brackets. And how cool is the comment syntax? (* doesnâ€™t it just feel like.. middle-eastern-ish *);;</p>
  </li>
  <li>
    <p>Tooling: is way better than it has any right to be, considering the size of itâ€™s user-base and community.</p>
  </li>
  <li>
    <p>Great conversation starter, really cool and helpful community.</p>
  </li>
</ul>

<p>Lots more to learn for sure but these were my initial thoughts anyway, I do really want to like it so we will see how much that helps. I just definitely did not get the head-start I was expecting, but I donâ€™t think thatâ€™s a negative thing it just means there is more to learn.</p>

<p>*obviously I know this isnâ€™t true and an extreme exaggeration, but I thought it was funny. Thereâ€™s always someone who will â€˜well ackshuallyâ€™ you when 
you think itâ€™s obvious.</p>


<ul>
  
  
    <li>
      <a href="#2023">
        <strong>2023</strong> <span>3</span>
      </a>
    </li>
  
</ul>




  <section id="2023">
    <h2>2023</h2>
    
    <a href="#page-title">Back to Top â†‘</a>
  </section>


  </div>
</div>
    </div></div>
  </body>
</html>
