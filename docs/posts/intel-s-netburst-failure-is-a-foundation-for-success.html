<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://chipsandcheese.com/2022/06/17/intels-netburst-failure-is-a-foundation-for-success/">Original</a>
    <h1>Intel’s Netburst: Failure Is a Foundation for Success</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>In the world of today’s high performance CPUs, major architectural changes don’t happen often. Iterating off a proven base is safer, cheaper, and faster than attempting to massively rework the basics of how a CPU fetches and executes instructions. But more than 20 years ago, things hadn’t settled down yet. Intel made two attempts to replace its solid but aging P6 microarchitecture with something completely different. One was Itanium, which avoided the complexity associated with out-of-order execution and variable length decode to deliver very wide in-order execution.</p>
<p>Pentium 4 was the other, and we’ll be taking a look at it in this article. Its microarchitecture, called Netburst, targeted very high clock speeds using a long pipeline. Alongside this key feature, it brought a wide range of innovative architectural features. As we all know, it didn’t quite pan out the way Intel would have liked. But this architecture was an important learning experience for Intel, and was arguably key to the company’s later success.</p>
<p>This article will mostly focus on the late variants of the Netburst architecture, implemented on the 90 nm (“Prescott”) and 65 nm (“Cedar Mill”) process nodes with 64-bit support. As another note, we understand this look into Netburst comes slightly late. The last of the Netburst architecture chips were discontinued 13 years ago, so this article may not necessarily fit the definition of a launch date review. To compensate for that, we’ll use period-correct graphs, created on Office XP….running on Windows 11. Enjoy.</p>
<h2>Block Diagram and Overview</h2>
<p>For its time, the Netburst architecture was a massive core. Next to its predecessor, the Pentium III, the Pentium 4 has more execution resources and much larger out of order structures. It’s also a large core compared to AMD’s competing Athlon 64, and even it’s successor, Merom. </p>
<div>
<figure><a href="https://chipsandcheese.com/?attachment_id=8011"><img data-attachment-id="8011" data-permalink="https://chipsandcheese.com/2022/06/17/intels-netburst-failure-is-a-foundation-for-success/pentium4_65nm-drawio-1/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/pentium4_65nm.drawio-1.png?fit=905%2C970&amp;ssl=1" data-orig-size="905,970" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="pentium4_65nm.drawio-1" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/pentium4_65nm.drawio-1.png?fit=905%2C970&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/pentium4_65nm.drawio-1.png?fit=688%2C737&amp;ssl=1" width="688" height="737" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/pentium4_65nm.drawio-1.png?resize=688%2C737&amp;ssl=1" alt="" srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/pentium4_65nm.drawio-1.png?w=905&amp;ssl=1 905w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/pentium4_65nm.drawio-1.png?resize=768%2C823&amp;ssl=1 768w" sizes="(max-width: 688px) 100vw, 688px" data-recalc-dims="1"/></a></figure></div>
<p>Compared to the Pentium III, based off Intel’s P6 architecture, Netburst is on a completely different scale. While both have pipelines that are three-wide, every key out of order structure on Netburst is several times larger. </p>
<div>
<figure><a href="https://chipsandcheese.com/2021/09/01/the-weird-and-wacky-world-of-via-the-3rd-player-in-the-modern-x86-market/piii/"><img data-attachment-id="2567" data-permalink="https://chipsandcheese.com/2021/09/01/the-weird-and-wacky-world-of-via-the-3rd-player-in-the-modern-x86-market/piii/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2021/08/piii.png?fit=895%2C971&amp;ssl=1" data-orig-size="895,971" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="piii" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2021/08/piii.png?fit=277%2C300&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2021/08/piii.png?fit=688%2C746&amp;ssl=1" loading="lazy" width="688" height="746" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2021/08/piii.png?resize=688%2C746&amp;ssl=1" alt="" srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2021/08/piii.png?w=895&amp;ssl=1 895w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2021/08/piii.png?resize=277%2C300&amp;ssl=1 277w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2021/08/piii.png?resize=768%2C833&amp;ssl=1 768w" sizes="(max-width: 688px) 100vw, 688px" data-recalc-dims="1"/></a></figure></div>
<h2>Frontend: Branch Prediction</h2>
<p>Branch prediction is extremely important for any CPU, and that especially applies to the Pentium 4. It needs very good branch prediction accuracy to take advantage of its huge (for the time) reordering capacity. On top of that, Netburst’s relatively long pipeline needs a lot of cycles to detect a mispredicted branch.</p>

<p>According to Agner Fog, the Pentium 4 uses a two-level adaptive predictor with a 16-bit global history buffer. In our testing, the Pentium Extreme Edition 965 seemed able to recognize a 24-long repeating pattern, so it’s possible this capability was expanded in Netburst’s 65nm revision. In any case, this branch prediction capability is very advanced for the time, and even exceeds that of its successor, Merom (also known as Core 2). There’s no doubt that the branch predictor was very high up on Intel’s priority list, in terms of both engineering effort and die area allocation.</p>
<figure><p><img loading="lazy" id="7810" src="https://i2.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_branchhist_oxp.png?ssl=1" alt="" width="1130" height="678"/><img loading="lazy" id="7811" src="https://i1.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/c2d_branchhist_oxp.png?ssl=1" alt="" width="1127" height="676"/></p></figure>
<p>To speed up taken branch handling, Intel has implemented very large branch target buffers. Combined with the trace cache, which we’ll discuss in more detail below, this provides tremendous zero-bubble taken branch capability. Netburst can track over 1024 branches and handle them without needing the frontend to stall while a branch target is looked up. If code is very branch-dense, this figure can exceed 2048 branches. Intel chips didn’t provide comparable zero-bubble capability until Gracemont in 2021, and AMD didn’t either until Zen 3 launched in 2020. </p>
<div>
<figure><a href="https://chipsandcheese.com/cedarmill_btb/"><img data-attachment-id="7982" data-permalink="https://chipsandcheese.com/cedarmill_btb/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_btb.png?fit=937%2C527&amp;ssl=1" data-orig-size="937,527" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="cedarmill_btb" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_btb.png?fit=937%2C527&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_btb.png?fit=688%2C387&amp;ssl=1" loading="lazy" width="688" height="387" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_btb.png?resize=688%2C387&amp;ssl=1" alt="" srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_btb.png?w=937&amp;ssl=1 937w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_btb.png?resize=768%2C432&amp;ssl=1 768w" sizes="(max-width: 688px) 100vw, 688px" data-recalc-dims="1"/></a></figure></div>
<p>But once Netburst’s zero-bubble tracking ability is exceeded, branch handling speed takes a nose dive. The architecture is probably using its 4096 entry BTB, and that path is extremely slow. We see over 13 cycles (12 pipeline bubbles) incurred for every taken branch. This is similar to what is referred to as a BTB miss penalties in other CPUs.</p>
<div>
<figure><a href="https://chipsandcheese.com/?attachment_id=7995"><img data-attachment-id="7995" data-permalink="https://chipsandcheese.com/2022/06/17/intels-netburst-failure-is-a-foundation-for-success/mainbtblatency_comp-1/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/mainbtblatency_comp-1.png?fit=822%2C418&amp;ssl=1" data-orig-size="822,418" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="mainbtblatency_comp-1" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/mainbtblatency_comp-1.png?fit=822%2C418&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/mainbtblatency_comp-1.png?fit=688%2C350&amp;ssl=1" loading="lazy" width="688" height="350" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/mainbtblatency_comp-1.png?resize=688%2C350&amp;ssl=1" alt="" srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/mainbtblatency_comp-1.png?w=822&amp;ssl=1 822w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/mainbtblatency_comp-1.png?resize=768%2C391&amp;ssl=1 768w" sizes="(max-width: 688px) 100vw, 688px" data-recalc-dims="1"/></a><figcaption>One of these is not like the others</figcaption></figure></div>
<p>Finally, after what looks like a BTB miss, taken branch latency goes through the roof, hitting an incredible 36 cycles per branch. This extreme penalty is likely why the CPU needs such a large 4096 entry main BTB. At this point, Netburst is probably fetching instructions from L2 and using a branch address calculator to resolve targets. </p>
<div>
<figure><a href="https://chipsandcheese.com/cedarmill_btb_comparison/"><img data-attachment-id="7981" data-permalink="https://chipsandcheese.com/cedarmill_btb_comparison/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_btb_comparison.png?fit=913%2C513&amp;ssl=1" data-orig-size="913,513" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="cedarmill_btb_comparison" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_btb_comparison.png?fit=913%2C513&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_btb_comparison.png?fit=688%2C387&amp;ssl=1" loading="lazy" width="688" height="387" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_btb_comparison.png?resize=688%2C387&amp;ssl=1" alt="" srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_btb_comparison.png?w=913&amp;ssl=1 913w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_btb_comparison.png?resize=768%2C432&amp;ssl=1 768w" sizes="(max-width: 688px) 100vw, 688px" data-recalc-dims="1"/></a><figcaption>Y axis clipped at 20 cycles taken branch latency because Netburst would otherwise mess up the scale and make other architectures hard to see</figcaption></figure></div>
<p>Merom and Westmere, which succeeded Netburst, cannot achieve the same speed for small branch footprints. After four or eight branches respectively, Merom and Westmere suffer a 1 cycle bubble after a taken branch. When their BTB capacity is exceeded, both newer CPUs can actually handle taken branches faster than Netburst can using its large 4096 entry BTB. </p>
<h2>Frontend: Fetch and Decode</h2>
<p>Netburst uses a radically different approach to instruction caching – one that hasn’t been seen before or repeated in mainstream processors. It replaces the traditional L1 instruction cache with a 12K entry trace cache. Instead of storing instruction bytes, this trace cache stores micro-ops corresponding to decoded instructions. And instead of having a simple one-to-many relationship between cache lines and cacheable memory addresses, the trace cache stores traces of sequentially executed instructions. Thus a single instruction can be cached in several places within the trace cache if it’s the target of several different branches. This is done to improve frontend bandwidth by turning taken branches into not-taken ones, from the instruction fetch logic’s perspective. </p>
<p>This is important because a micro-op cache or traditional L1i fetch and decode setup tends to lose a lot of frontend bandwidth around taken branches. Fetch or decode width that goes past a taken branch becomes useless, and getting the taken branch target requires a separate fetch request. Netburst’s trace cache tries to get rid of these penalties.</p>
<div>
<figure><a href="https://chipsandcheese.com/prescott_2m_fe/"><img data-attachment-id="7975" data-permalink="https://chipsandcheese.com/prescott_2m_fe/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_fe.jpg?fit=1920%2C2298&amp;ssl=1" data-orig-size="1920,2298" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;1654942133&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;1&#34;}" data-image-title="prescott_2m_fe" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_fe.jpg?fit=1203%2C1440&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_fe.jpg?fit=688%2C823&amp;ssl=1" loading="lazy" width="688" height="823" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_fe.jpg?resize=688%2C823&amp;ssl=1" alt="" srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_fe.jpg?resize=1805%2C2160&amp;ssl=1 1805w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_fe.jpg?resize=1203%2C1440&amp;ssl=1 1203w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_fe.jpg?resize=768%2C919&amp;ssl=1 768w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_fe.jpg?resize=1283%2C1536&amp;ssl=1 1283w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_fe.jpg?resize=1711%2C2048&amp;ssl=1 1711w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_fe.jpg?resize=1200%2C1436&amp;ssl=1 1200w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_fe.jpg?resize=1600%2C1915&amp;ssl=1 1600w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_fe.jpg?resize=1320%2C1580&amp;ssl=1 1320w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_fe.jpg?w=1920&amp;ssl=1 1920w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_fe.jpg?w=1376&amp;ssl=1 1376w" sizes="(max-width: 688px) 100vw, 688px" data-recalc-dims="1"/></a><figcaption>Instruction decoder block likely includes complex trace building logic, which has to balance between efficiently utilizing trace cache capacity, and improving throughput by removing taken branches</figcaption></figure></div>
<p>Storing decoded micro-ops means “instructions” fetched from the trace cache can be delivered with higher bandwidth, lower latency, and lower power. Testing instruction fetch bandwidth with 8-byte NOPs shows this advantage. If the average instruction length is too long, the L1i can’t feed the decoders fast enough. Hitting the trace cache bypasses this limitation.</p>
<div>
<figure><a href="https://chipsandcheese.com/cedarmill_ifetch_8b/"><img data-attachment-id="7936" data-permalink="https://chipsandcheese.com/cedarmill_ifetch_8b/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_ifetch_8B.png?fit=1113%2C597&amp;ssl=1" data-orig-size="1113,597" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="cedarmill_ifetch_8B" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_ifetch_8B.png?fit=1113%2C597&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_ifetch_8B.png?fit=688%2C369&amp;ssl=1" loading="lazy" width="688" height="369" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_ifetch_8B.png?resize=688%2C369&amp;ssl=1" alt="" srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_ifetch_8B.png?w=1113&amp;ssl=1 1113w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_ifetch_8B.png?resize=768%2C412&amp;ssl=1 768w" sizes="(max-width: 688px) 100vw, 688px" data-recalc-dims="1"/></a><figcaption>Goldmont Plus and Haswell (represented by the i7-4770) both have L1i caches that can deliver 16 bytes per cycle</figcaption></figure></div>
<p>Micro-op caches found in AMD, ARM, and Intel’s modern CPUs use the same technique to allow higher instruction bandwidth at lower latency and lower power. But Netburst’s technique of caching traces was dropped, because it makes the cache very area inefficient. Micro-ops already tend to be larger than ISA instructions and that’s especially the case for x86 where variable length encodings mean higher space efficiency. Caching the same instruction more than once only exacerbates the capacity problem. According to Agner Fog, 90 nm Pentium 4 variants (and presumably later ones) have 64-bit micro-ops. The 12K entry trace cache would thus be implemented with 96 KB of raw storage, even though Intel’s whitepaper claims it “has a similar hit rate to a 8K to 16K byte conventional instruction cache”. That’s a serious problem in programs with large instruction footprints. And Intel’s immediate competitor, AMD’s Athlon, is bouncing around with a 64 KB instruction cache.</p>
<p>When large instruction footprints cause trace cache misses, Netburst is in serious trouble. It has to fetch instruction bytes from L2, and pass them through a 1-wide decoder. A conventional wide decoder can maintain a reasonable level of instruction throughput in the face of L1i misses, since lower level caches can still provide enough bandwidth to hand the decoders multiple instructions per cycle. But Netburst does away with that setup. Instruction throughput therefore drops like a rock once the trace cache is missed.</p>
<div>
<figure><a href="https://chipsandcheese.com/cedarmill_ifetch_4b/"><img data-attachment-id="7935" data-permalink="https://chipsandcheese.com/cedarmill_ifetch_4b/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_ifetch_4B.png?fit=1107%2C590&amp;ssl=1" data-orig-size="1107,590" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="cedarmill_ifetch_4B" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_ifetch_4B.png?fit=1107%2C590&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_ifetch_4B.png?fit=688%2C367&amp;ssl=1" loading="lazy" width="688" height="367" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_ifetch_4B.png?resize=688%2C367&amp;ssl=1" alt="" srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_ifetch_4B.png?w=1107&amp;ssl=1 1107w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_ifetch_4B.png?resize=768%2C409&amp;ssl=1 768w" sizes="(max-width: 688px) 100vw, 688px" data-recalc-dims="1"/></a><figcaption>Goldmont Plus is an example of a 3-wide core with a conventional 32 KB L1 instruction cache</figcaption></figure></div>
<p>Along with being sent down the pipeline, micro-ops emitted by Netburst’s decoder are built into traces, which are filled into the trace cache. This trace building logic has to make a difficult tradeoff. It can more efficiently utilize trace cache capacity by breaking up traces to minimize duplicate instruction caching. Or, it can make longer traces to maximize trace cache fetch bandwidth. I’m guessing this logic block is complex and a nightmare to tune. </p>
<p>While flawed, Netburst’s instruction caching strategy had upsides. As mentioned before, skipping instruction decode has obvious latency, bandwidth, and power benefits. Starting with Sandy Bridge, Intel re-introduced micro-op caching to get those benefits for small code footprints. A much smaller micro-op cache is paired with a beefy conventional decoder and L1i cache. That setup gets the best of both worlds. Interestingly, Sandy Bridge’s micro-op cache remains 8-way set associative and uses 6 micro-op lines, just like Netburst’s trace cache. And unlike the micro-op cache found in AMD’s Zen CPUs, Intel’s modern micro-op caches are unable to cache micro-ops from the microcode sequencer. Instead, just like Netburst’s trace cache, a pointer to the microcode ROM is stored. These implementation detail similarities mean there’s a good chance Intel’s modern micro-op cache design retain a good chunk of Netburst trace cache DNA.</p>
<p>As a final note, imitation is most sincere form of flattery. AMD, ARM, and Samsung have all introduced some form of micro-op cache in their CPU architectures. Netburst’s trace cache led to Intel being a pioneer in this area.</p>
<h2>Rename and Allocate</h2>
<p>Once the CPU has an instruction’s corresponding micro-ops available, it’s time to allocate resources in the backend to track them.</p>
<div>
<figure><a href="https://chipsandcheese.com/prescott_2m_ren/"><img data-attachment-id="7978" data-permalink="https://chipsandcheese.com/prescott_2m_ren/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_ren.jpg?fit=1920%2C2298&amp;ssl=1" data-orig-size="1920,2298" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;1654942239&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;1&#34;}" data-image-title="prescott_2m_ren" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_ren.jpg?fit=1203%2C1440&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_ren.jpg?fit=688%2C823&amp;ssl=1" loading="lazy" width="688" height="823" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_ren.jpg?resize=688%2C823&amp;ssl=1" alt="" srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_ren.jpg?resize=1805%2C2160&amp;ssl=1 1805w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_ren.jpg?resize=1203%2C1440&amp;ssl=1 1203w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_ren.jpg?resize=768%2C919&amp;ssl=1 768w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_ren.jpg?resize=1283%2C1536&amp;ssl=1 1283w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_ren.jpg?resize=1711%2C2048&amp;ssl=1 1711w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_ren.jpg?resize=1200%2C1436&amp;ssl=1 1200w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_ren.jpg?resize=1600%2C1915&amp;ssl=1 1600w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_ren.jpg?resize=1320%2C1580&amp;ssl=1 1320w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_ren.jpg?w=1920&amp;ssl=1 1920w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_ren.jpg?w=1376&amp;ssl=1 1376w" sizes="(max-width: 688px) 100vw, 688px" data-recalc-dims="1"/></a><figcaption>Instructions likely flow from the trace cache across the microcode ROM block, to an adjacent block with a structure that looks like a set of register alias tables. That’s probably the renamer.</figcaption></figure></div>
<p>Netburst has a 3-wide rename and allocate stage. While Netburst introduces a physical register based out-of-order engine, it doesn’t seem capable of move elimination. However, it is able to recognize zeroing idioms and break dependencies. Strangely, some zeroing idioms perform better than others.</p>
<figure><table><tbody><tr><td></td><td>Netburst IPC</td><td>Westmere IPC</td></tr><tr><td>Independent MOV r,r</td><td>2.51</td><td>1.67</td></tr><tr><td>Dependent MOV r,r</td><td>0.99</td><td>1.01</td></tr><tr><td>xor r,r</td><td>1.73</td><td>2.76</td></tr><tr><td>mov r, 0</td><td>2.51</td><td>2.76</td></tr><tr><td>sub r, 0</td><td>2.46</td><td>2.76</td></tr></tbody></table></figure>
<p>Nehalem (and Westmere)’s lower throughput for independent register to register MOVs could be caused by a retired register file (RRF) bandwidth limitation. Intel’s P6 architecture handled register renaming by using result fields in the reorder buffer (ROB) as renamed registers, for instructions pending retirement. At retirement, instruction results are copied from the ROB to the RRF. </p>
<p>A peculiar feature of the P6’s out of order engine is that the scheduler holds input values for instructions waiting to be executed. The renamer therefore has to write input values into the scheduler if they won’t be forwarded from another in-flight instruction. If these input values come from an instruction that has already retired, the renamer has to read from the RRF. According to Agner Fog, the RRF in Nehalem (and Westmere) only has three read ports. Netburst eliminates this bottleneck by using separate register files that hold both speculative and architectural results.</p>
<h2>Out of Order Execution Engine</h2>
<p>With the Pentium 4, Intel completely re-architected the out of order engine. As mentioned above, it no longer uses a ROB+RRF scheme. Instead, the ROB holds pointers to register file entries. The same applies to the renamer, where the register alias table for architectural, known-good state also holds pointers to register files. This setup, which we’ll refer to as a PRF based scheme, allows less data movement. Pointers to register file entries can only be a few bits in size. For example, you’d only need seven bits to index into a 128 entry register file, while an integer register is 64 bits wide. This is especially important for SIMD registers, which can be much larger. Trying to move several 128-bit values at retirement would probably consume quite a bit of power.</p>
<div>
<figure><a href="https://chipsandcheese.com/prescott_2m_be/"><img data-attachment-id="7972" data-permalink="https://chipsandcheese.com/prescott_2m_be/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_be.jpg?fit=1920%2C2298&amp;ssl=1" data-orig-size="1920,2298" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;1654942356&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;1&#34;}" data-image-title="prescott_2m_be" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_be.jpg?fit=1203%2C1440&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_be.jpg?fit=688%2C823&amp;ssl=1" loading="lazy" width="688" height="823" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_be.jpg?resize=688%2C823&amp;ssl=1" alt="" srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_be.jpg?resize=1805%2C2160&amp;ssl=1 1805w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_be.jpg?resize=1203%2C1440&amp;ssl=1 1203w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_be.jpg?resize=768%2C919&amp;ssl=1 768w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_be.jpg?resize=1283%2C1536&amp;ssl=1 1283w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_be.jpg?resize=1711%2C2048&amp;ssl=1 1711w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_be.jpg?resize=1200%2C1436&amp;ssl=1 1200w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_be.jpg?resize=1600%2C1915&amp;ssl=1 1600w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_be.jpg?resize=1320%2C1580&amp;ssl=1 1320w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_be.jpg?w=1920&amp;ssl=1 1920w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_be.jpg?w=1376&amp;ssl=1 1376w" sizes="(max-width: 688px) 100vw, 688px" data-recalc-dims="1"/></a><figcaption>Separate register files are clearly visible</figcaption></figure></div>
<p>A PRF based scheme also lets engineers set register file and ROB sizes independently. Not every instruction will write a result to a register, with common examples being branches and stores. Using separate register files thus makes ROB size increases cheaper. Finally, the PRF-based scheme allows renamer tricks like move elimination, where instructions that copy values between registers can be “executed” within the renamer by manipulating the speculative register alias table’s pointers. </p>
<p>In general, Netburst’s out of order structures are massive and not matched in size until Nehalem debuted in 2008. But there’s a sinister reason behind this. Agner Fog found that Netburst can’t cancel erroneously fetched instructions until retirement, for example from a branch mispredict. Omitting the ability to squash bogus instructions probably let Intel simplify the pipeline, and achieve higher clocks in the process. But it means the out of order engine has to keep tracking bogus operations until they’re completed, reducing effective reordering capacity. Netburst’s structure sizes were likely increased to compensate. </p>
<p>This is especially obvious with scheduling capacity. Even compared to more modern designs, Netburst can track a monstrous number of instructions waiting for an execution unit.</p>
<div>
<figure><a href="https://chipsandcheese.com/?attachment_id=7840"><img data-attachment-id="7840" data-permalink="https://chipsandcheese.com/2022/06/17/intels-netburst-failure-is-a-foundation-for-success/image-7-14/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/image-7.png?fit=1362%2C748&amp;ssl=1" data-orig-size="1362,748" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-7" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/image-7.png?fit=1362%2C748&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/image-7.png?fit=688%2C378&amp;ssl=1" loading="lazy" width="688" height="378" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/image-7.png?resize=688%2C378&amp;ssl=1" alt="" srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/image-7.png?w=1362&amp;ssl=1 1362w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/image-7.png?resize=768%2C422&amp;ssl=1 768w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/image-7.png?resize=1200%2C659&amp;ssl=1 1200w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/image-7.png?resize=1320%2C725&amp;ssl=1 1320w" sizes="(max-width: 688px) 100vw, 688px" data-recalc-dims="1"/></a></figure></div>
<p>Netburst also differs from other Intel high performance designs in using a distributed scheduler for math operations. This distributed scheduler lets Intel keep port count low for each scheduling queue, reducing area and power requirements. Another unique feature is that multiple scheduling queues share a single dispatch port, and arbitrate for access.</p>
<div>
<figure><a href="https://chipsandcheese.com/?attachment_id=7851"><img data-attachment-id="7851" data-permalink="https://chipsandcheese.com/2022/06/17/intels-netburst-failure-is-a-foundation-for-success/image-8-14/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/image-8.png?fit=811%2C293&amp;ssl=1" data-orig-size="811,293" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-8" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/image-8.png?fit=811%2C293&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/image-8.png?fit=688%2C249&amp;ssl=1" loading="lazy" width="688" height="249" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/image-8.png?resize=688%2C249&amp;ssl=1" alt="" srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/image-8.png?w=811&amp;ssl=1 811w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/image-8.png?resize=768%2C277&amp;ssl=1 768w" sizes="(max-width: 688px) 100vw, 688px" data-recalc-dims="1"/></a><figcaption>The large scheduler sizes also hint at the possibility of non-scheduling queues, but due to time constraints, that wasn’t tested for</figcaption></figure></div>
<p>In terms of execution units, Netburst has a rather convoluted setup. There are four dispatch ports, but two of these are connected to hot-clocked integer ALUs that can execute two operations per core cycle. A 3-wide core that can do four ALU operations per cycle is strange, as the ALUs are guaranteed to be under-fed. But Netburst is not normal. Remember how it can’t cancel bogus micro-ops before retirement? That wastes execution resources too. The wastefulness doesn’t stop there because L1D misses are handled rather inefficiently. Netburst’s schedulers will send loads for execution assuming they hit L1D. If they miss L1D, they’re sent back into the schedulers to be repeatedly executed until the correct data arrives. This “instruction replay” extends to dependent instructions too. </p>
<p>This very high throughput ALU setup is thus dictated by Netburst’s inefficiencies. Having what’s basically four ALUs on a 3-wide core will not give you superior integer performance, but that’s not what they’re there for. They’re there to crunch through all the bogus work, while having enough throughput left over to handle real work. </p>
<h3>Store Forwarding, and Load/Store Unit Details</h3>
<p>A CPU’s load/store unit has to ensure that memory operations appear to be executed in-order. If a store instruction writes to a location, a future read to that location should give back what the store wrote. This may seem intuitively simple, but an out-of-order CPU can have a lot of memory operations in flight. A store instruction can’t write its data out to the memory hierarchy until it retires. Every load therefore has to determine whether it should get its data from a prior store, or from the memory hierarchy. The load/store unit has to compare in-flight load and store addresses to ensure this happens correctly. </p>

<p>Netburst’s memory dependency checking mechanism is pretty primitive. Store forwarding is only successful for exact address matches and no cacheline boundaries are crossed. This ‘happy path’ case is handled with 5-6 cycle latency, which is pretty typical. However, every other store forwarding case fails. These failure cases are astoundingly bad. If the load is contained within the store but addresses don’t match exactly, Netburst takes over 50 cycles to resolve the situation. That’s over twice the cycles typically seen with other CPUs, and it’s not even the worst. </p>
<p>If forwarding fails and the load is misaligned (crosses a cache line), latency increases to 89 cycles. If the store is misaligned it’s 125 cycles. If both are misaligned, Netburst suffers an absolutely disgusting 165 cycle penalty. These can be considered edge cases, but most other CPUs can handle them in a couple dozen cycles at most. The Intel Technology Journal’s paper on the Netburst architecture’s introduction noted that a “disallowed store-to-load forwarding case can be quite costly, in terms of performance loss.” They weren’t kidding.</p>
<div>
<figure><a href="https://chipsandcheese.com/goldmontplus_stlf/"><img data-attachment-id="7927" data-permalink="https://chipsandcheese.com/goldmontplus_stlf/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/goldmontplus_stlf.png?fit=2963%2C1319&amp;ssl=1" data-orig-size="2963,1319" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="goldmontplus_stlf" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/goldmontplus_stlf.png?fit=2560%2C1140&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/goldmontplus_stlf.png?fit=688%2C306&amp;ssl=1" loading="lazy" width="688" height="306" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/goldmontplus_stlf.png?resize=688%2C306&amp;ssl=1" alt="" srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/goldmontplus_stlf.png?w=2963&amp;ssl=1 2963w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/goldmontplus_stlf.png?resize=768%2C342&amp;ssl=1 768w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/goldmontplus_stlf.png?resize=1536%2C684&amp;ssl=1 1536w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/goldmontplus_stlf.png?resize=2048%2C912&amp;ssl=1 2048w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/goldmontplus_stlf.png?resize=1200%2C534&amp;ssl=1 1200w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/goldmontplus_stlf.png?resize=1600%2C712&amp;ssl=1 1600w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/goldmontplus_stlf.png?resize=1320%2C588&amp;ssl=1 1320w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/goldmontplus_stlf.png?w=1376&amp;ssl=1 1376w" sizes="(max-width: 688px) 100vw, 688px" data-recalc-dims="1"/></a><figcaption>Same test on Goldmont Plus. Pattern is similar (except for Goldmont Plus doing checks on 4-byte chunks), but penalties are far lower</figcaption></figure></div>
<p>Misaligned data accesses are unreasonably expensive on Netburst, even if there are no nearby instructions that could cause memory ordering issues. If an access crosses a cacheline boundary, it’s one thing it to take two cycles because it gets executed as two operations within the load/store unit. That’s a light penalty that will easily be hidden by out of order execution. It’s another to faceplant and take 23 cycles, which Netburst does for a misaligned load. And it’s yet another step in the wrong direction to die in a hole for around 105 cycles when a store crosses a cacheline boundary. But Netburst does exactly that.</p>
<h2>Caching and Memory Access</h2>
<p>Like its instruction side, Netburst’s L1 data caching setup is fine for programs with small data footprints, but suffers from low capacity for larger working sets. The 16 KB data cache that comes with later revisions of Netburst is definitely better than the laughably small 8 KB cache featured in Willamette (180 nm) and Northwood (130 nm) cores. But this L1D size increase also increased latency from two cycles to four. For perspective, AMD’s Athlon has a 64 KB L1D with three cycle latency.</p>
<div>
<figure><a href="https://chipsandcheese.com/prescott_2m_ls/"><img data-attachment-id="7977" data-permalink="https://chipsandcheese.com/prescott_2m_ls/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_ls.jpg?fit=1920%2C2298&amp;ssl=1" data-orig-size="1920,2298" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;1654942604&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;1&#34;}" data-image-title="prescott_2m_ls" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_ls.jpg?fit=1203%2C1440&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_ls.jpg?fit=688%2C823&amp;ssl=1" loading="lazy" width="688" height="823" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_ls.jpg?resize=688%2C823&amp;ssl=1" alt="" srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_ls.jpg?resize=1805%2C2160&amp;ssl=1 1805w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_ls.jpg?resize=1203%2C1440&amp;ssl=1 1203w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_ls.jpg?resize=768%2C919&amp;ssl=1 768w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_ls.jpg?resize=1283%2C1536&amp;ssl=1 1283w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_ls.jpg?resize=1711%2C2048&amp;ssl=1 1711w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_ls.jpg?resize=1200%2C1436&amp;ssl=1 1200w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_ls.jpg?resize=1600%2C1915&amp;ssl=1 1600w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_ls.jpg?resize=1320%2C1580&amp;ssl=1 1320w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_ls.jpg?w=1920&amp;ssl=1 1920w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_ls.jpg?w=1376&amp;ssl=1 1376w" sizes="(max-width: 688px) 100vw, 688px" data-recalc-dims="1"/></a></figure></div>
<p>That means Netburst’s L1D has worse latency than AMD’s. This applies to actual time latency as well, since the Pentium Extreme Edition 965 doesn’t have enough of a clock speed advantage over AMD’s Athlon X2 6000 to close the gap. Building such a large L1D cache and maintaining 3 cycle latency even for indexed addressing modes is quite an achievement, and AMD should be proud of that.</p>
<div>
<figure><a href="https://chipsandcheese.com/?attachment_id=7864"><img data-attachment-id="7864" data-permalink="https://chipsandcheese.com/2022/06/17/intels-netburst-failure-is-a-foundation-for-success/cedarmill_4k_memlat/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_4k_memlat.png?fit=1374%2C834&amp;ssl=1" data-orig-size="1374,834" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="cedarmill_4k_memlat" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_4k_memlat.png?fit=1374%2C834&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_4k_memlat.png?fit=688%2C418&amp;ssl=1" loading="lazy" width="688" height="418" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_4k_memlat.png?resize=688%2C418&amp;ssl=1" alt="" srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_4k_memlat.png?w=1374&amp;ssl=1 1374w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_4k_memlat.png?resize=768%2C466&amp;ssl=1 768w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_4k_memlat.png?resize=1200%2C728&amp;ssl=1 1200w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_4k_memlat.png?resize=1320%2C801&amp;ssl=1 1320w" sizes="(max-width: 688px) 100vw, 688px" data-recalc-dims="1"/></a></figure></div>
<p>The Pentium EE 965 has a 2 MB L2 for each core, with a latency of about 25 cycles. AMD’s L2 is smaller and takes fewer cycles to return data, but Netburst’s higher clocks close the latency gap. That gives Intel a larger L2 with similar latency. Intel’s later Core 2 architecture has L2 characteristics similar to AMD’s, but shares a single L2 cache between both cores.</p>
<div>
<figure><a href="https://chipsandcheese.com/?attachment_id=7868"><img data-attachment-id="7868" data-permalink="https://chipsandcheese.com/2022/06/17/intels-netburst-failure-is-a-foundation-for-success/cedarmill_4k_memlat_ns/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_4k_memlat_ns.png?fit=1374%2C901&amp;ssl=1" data-orig-size="1374,901" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="cedarmill_4k_memlat_ns" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_4k_memlat_ns.png?fit=1374%2C901&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_4k_memlat_ns.png?fit=688%2C451&amp;ssl=1" loading="lazy" width="688" height="451" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_4k_memlat_ns.png?resize=688%2C451&amp;ssl=1" alt="" srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_4k_memlat_ns.png?w=1374&amp;ssl=1 1374w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_4k_memlat_ns.png?resize=768%2C504&amp;ssl=1 768w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_4k_memlat_ns.png?resize=1200%2C787&amp;ssl=1 1200w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_4k_memlat_ns.png?resize=1320%2C866&amp;ssl=1 1320w" sizes="(max-width: 688px) 100vw, 688px" data-recalc-dims="1"/></a></figure></div>
<p>Consumer CPUs in the mid 2000s typically used simple, two-level caching setups. Netburst is no different. A L2 miss goes right out to memory. Intel’s designs of the area access memory by going through a front side bus to the chipset’s northbridge, where the memory controllers are located. This extra off-chip hop increases latency, and means that both the Pentium EE 965 and Core 2 suffer higher memory latency than AMD’s Athlon.</p>
<p>This latency can be exacerbated by TLB misses. If we use 2 MB pages, allowing each TLB entry to cover 2 MB instead of 4 KB, we can see how Netburst suffers from address translation penalties. At the 512 KB test size, we see a 18.35 clock cycle latency delta (4.92 ns) between 4 KB and 2 MB pages. This only grows as test size increases and page walks start missing cache.</p>
<div>
<figure><a href="https://chipsandcheese.com/?attachment_id=7866"><img data-attachment-id="7866" data-permalink="https://chipsandcheese.com/2022/06/17/intels-netburst-failure-is-a-foundation-for-success/image-12-14/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/image-12.png?fit=1374%2C890&amp;ssl=1" data-orig-size="1374,890" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-12" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/image-12.png?fit=1374%2C890&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/image-12.png?fit=688%2C446&amp;ssl=1" loading="lazy" width="688" height="446" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/image-12.png?resize=688%2C446&amp;ssl=1" alt="" srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/image-12.png?w=1374&amp;ssl=1 1374w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/image-12.png?resize=768%2C497&amp;ssl=1 768w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/image-12.png?resize=1200%2C777&amp;ssl=1 1200w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/image-12.png?resize=1320%2C855&amp;ssl=1 1320w" sizes="(max-width: 688px) 100vw, 688px" data-recalc-dims="1"/></a></figure></div>
<p>In an absolute time sense though, raw memory latency isn’t so bad. With 2 MB pages used to minimize address translation overhead, memory latency is somewhere around 90 ns. That’s roughly comparable to Tiger Lake (i7-11800H)’s memory latency, even though Tiger Lake benefits from an integrated memory controller.</p>
<h3>Bandwidth</h3>
<p>Netburst makes significant gains in bandwidth compared to previous generations of Intel CPUs. Versus the P6 based Pentium M, L1D load width has doubled. Alongside that, Netburst’s L2 cache bandwidth is dramatically better. Old P6 chips had the L2 attached off a backside bus, with some variants using external L2 SRAM chips. Netburst moves to a far more integrated L2 setup.</p>
<div>
<figure><a href="https://chipsandcheese.com/?attachment_id=7861"><img data-attachment-id="7861" data-permalink="https://chipsandcheese.com/2022/06/17/intels-netburst-failure-is-a-foundation-for-success/cedarmill_bytescycle/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_bytescycle.png?fit=1377%2C727&amp;ssl=1" data-orig-size="1377,727" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="cedarmill_bytescycle" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_bytescycle.png?fit=1377%2C727&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_bytescycle.png?fit=688%2C363&amp;ssl=1" loading="lazy" width="688" height="363" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_bytescycle.png?resize=688%2C363&amp;ssl=1" alt="" srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_bytescycle.png?w=1377&amp;ssl=1 1377w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_bytescycle.png?resize=768%2C405&amp;ssl=1 768w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_bytescycle.png?resize=1200%2C634&amp;ssl=1 1200w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_bytescycle.png?resize=1320%2C697&amp;ssl=1 1320w" sizes="(max-width: 688px) 100vw, 688px" data-recalc-dims="1"/></a></figure></div>
<p>Against Westmere, Netburst falls behind everywhere. Intel made huge advances in their caching strategy in the years after Netburst’s retirement. Westmere’s L3 is particularly impressive. Despite being several times larger than Netburst’s L2, it can provide roughly comparable bandwidth to a single thread. </p>
<p>The only bright spot for the Netburst is its 16 byte per cycle load capability combined with very high clock speeds. That lets the Pentium EE 965 deliver higher L1D bandwidth than Westmere. But that’s about it. Even against a Westmere server chip, Netburst’s clocks aren’t quite high enough to pull an advantage anywhere else. </p>
<div>
<figure><a href="https://chipsandcheese.com/?attachment_id=7863"><img data-attachment-id="7863" data-permalink="https://chipsandcheese.com/2022/06/17/intels-netburst-failure-is-a-foundation-for-success/cedarmill_st_membw/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_st_membw.png?fit=1377%2C727&amp;ssl=1" data-orig-size="1377,727" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="cedarmill_st_membw" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_st_membw.png?fit=1377%2C727&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_st_membw.png?fit=688%2C363&amp;ssl=1" loading="lazy" width="688" height="363" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_st_membw.png?resize=688%2C363&amp;ssl=1" alt="" srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_st_membw.png?w=1377&amp;ssl=1 1377w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_st_membw.png?resize=768%2C405&amp;ssl=1 768w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_st_membw.png?resize=1200%2C634&amp;ssl=1 1200w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_st_membw.png?resize=1320%2C697&amp;ssl=1 1320w" sizes="(max-width: 688px) 100vw, 688px" data-recalc-dims="1"/></a></figure></div>
<p>In terms of multithreaded bandwidth, we unfortunately don’t have data from contemporary chips to make anywhere close to a sensible comparison. So here’s a comparison between the dual core, quad thread Pentium Extreme Edition 965, and the quad core Pentium J4125. This Goldmont Plus chip has the same amount of total L2, but shares it across four cores instead of having a private L2 cache per core. And even with that setup, it achieves higher L2 bandwidth than Netburst does. </p>
<div>
<figure><a href="https://chipsandcheese.com/cedarmill_4t_bw/"><img data-attachment-id="7930" data-permalink="https://chipsandcheese.com/cedarmill_4t_bw/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_4t_bw.png?fit=950%2C507&amp;ssl=1" data-orig-size="950,507" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="cedarmill_4t_bw" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_4t_bw.png?fit=950%2C507&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_4t_bw.png?fit=688%2C367&amp;ssl=1" loading="lazy" width="688" height="367" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_4t_bw.png?resize=688%2C367&amp;ssl=1" alt="" srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_4t_bw.png?w=950&amp;ssl=1 950w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_4t_bw.png?resize=768%2C410&amp;ssl=1 768w" sizes="(max-width: 688px) 100vw, 688px" data-recalc-dims="1"/></a></figure></div>
<p>In DRAM sized regions, the Pentium EE 965 achieves about 6.8 GB/s of bandwidth. Using four threads actually lowers memory bandwidth. It drops to 5.86 GB/s, suggesting that contention between threads is not handled very well. The chip tested here was given dual channel DDR2-533, so we’re seeing about 80% bandwidth efficiency when a single thread is used, and 68.7% with all threads. With a single channel DDR4-2133 setup, the Celeron J4125 achieves 76.9% bandwidth efficiency when four cores are loaded, but just 38.8% with a single core. In that respect, it’s nice that Netburst can utilize all available bandwidth with a single thread, but that’s also because there’s not much memory bandwidth available to start with.</p>
<h3>Write Bandwidth</h3>
<p>For a few articles, we didn’t cover write bandwidth in depth to keep things short. But Netburst forces this, because it uses a write-through L1 data cache. </p>
<p>Most CPUs we use implement write-back L1D caches. When you write to such a cache, the modified data is held there and not written further down the memory hierarchy until it’s kicked out of the cache, either to make room for new data or to maintain cache coherency. With a write-through cache, a write is immediately written through to the next level down the memory hierarchy. As far as write bandwidth goes, a write-through cache may as well not exist. </p>
<div>
<figure><a href="https://chipsandcheese.com/cedarmill_writethrough/"><img data-attachment-id="7959" data-permalink="https://chipsandcheese.com/cedarmill_writethrough/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_writethrough.png?fit=969%2C513&amp;ssl=1" data-orig-size="969,513" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="cedarmill_writethrough" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_writethrough.png?fit=969%2C513&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_writethrough.png?fit=688%2C364&amp;ssl=1" loading="lazy" width="688" height="364" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_writethrough.png?resize=688%2C364&amp;ssl=1" alt="" srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_writethrough.png?w=969&amp;ssl=1 969w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/cedarmill_writethrough.png?resize=768%2C407&amp;ssl=1 768w" sizes="(max-width: 688px) 100vw, 688px" data-recalc-dims="1"/></a></figure></div>
<p>On Netburst, that means write bandwidth is less than a quarter of read bandwidth. Within L2 sized regions, we get under four bytes per cycle, or around 13.27 GB/s. That’s extremely poor because every write instruction will be subject to that bandwidth limitation. While most programs execute more memory reads than writes, the read-to-write bandwidth ratio here is more than a bit off. For example, when encoding video with libx264 (on Sandy Bridge), 28.6% of instructions were loads, while 11.86% were stores, for a 2.41:1 load to store ratio. The ratio of load to store bandwidth on Netburst is a staggering 4.46:1. The situation is made worse by the small L1D and capacity-inefficient trace cache. Both of those mean increased read traffic to L2, which will compete with write traffic. </p>
<div>
<figure><a href="https://chipsandcheese.com/sane_write_bw/"><img data-attachment-id="8001" data-permalink="https://chipsandcheese.com/sane_write_bw/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/sane_write_bw.png?fit=827%2C843&amp;ssl=1" data-orig-size="827,843" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="sane_write_bw" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/sane_write_bw.png?fit=827%2C843&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/sane_write_bw.png?fit=688%2C701&amp;ssl=1" loading="lazy" width="688" height="701" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/sane_write_bw.png?resize=688%2C701&amp;ssl=1" alt="" srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/sane_write_bw.png?w=827&amp;ssl=1 827w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/sane_write_bw.png?resize=768%2C783&amp;ssl=1 768w" sizes="(max-width: 688px) 100vw, 688px" data-recalc-dims="1"/></a><figcaption>This is what sanity looks like, just so we don’t lose track</figcaption></figure></div>
<p>Of course, there are justifications behind using a write-through cache. Much like skydiving without a parachute, a write-through cache removes extra steps, making the process simpler and easier. For example, you have to carefully fold a parachute, and bring a backup chute. Similarly, a write-back cache needs robust error correction because data corruption can screw up the only modified copy of something. A write-through cache never holds the only copy of modified data. If an error is detected, it can simply reload the affected data from the next level down. You also have to remember to open a parachute in conventional skydiving. Similarly, a write-back cache has to remember what data was modified, so that it knows whether to write-back cache lines when they’re evicted.</p>
<p>However, the results in both cases can be sub-optimal. Just as falling through the ground at terminal velocity can negatively impact your health, writing data through a cache can negatively impact performance. Netburst’s small, write-through L1D was not used again on Intel’s later architectures.</p>
<h2>Putting it Together</h2>
<p>Netburst was not successful. It’s an architecture characterized by excellent fast-path performance and horrifying penalties once code does something it doesn’t expect. Its pipeline was prone to doing excessive amounts of unnecessary work, thanks to handling cache misses via replay and its inability to cancel bogus operations. The result is an architecture that in many ways looks very impressive on paper, but ends up suffering a combination of very poor power efficiency and poor performance per clock. </p>
<p>Then, clock gains from new process nodes didn’t pan out as expected, and the architecture never reached the astronomically high clock speeds it was meant to hit. The architecture’s performance per clock was so bad that the higher clock speeds it actually achieved weren’t enough to cope, especially as AMD also gained clock speed from process node improvements.</p>
<div>
<figure><a href="https://chipsandcheese.com/prescott_2m_cnc/"><img data-attachment-id="7974" data-permalink="https://chipsandcheese.com/prescott_2m_cnc/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_cnc.jpg?fit=1920%2C2298&amp;ssl=1" data-orig-size="1920,2298" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;1654942701&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;1&#34;}" data-image-title="prescott_2m_cnc" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_cnc.jpg?fit=1203%2C1440&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_cnc.jpg?fit=688%2C823&amp;ssl=1" loading="lazy" width="688" height="823" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_cnc.jpg?resize=688%2C823&amp;ssl=1" alt="" srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_cnc.jpg?resize=1805%2C2160&amp;ssl=1 1805w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_cnc.jpg?resize=1203%2C1440&amp;ssl=1 1203w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_cnc.jpg?resize=768%2C919&amp;ssl=1 768w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_cnc.jpg?resize=1283%2C1536&amp;ssl=1 1283w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_cnc.jpg?resize=1711%2C2048&amp;ssl=1 1711w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_cnc.jpg?resize=1200%2C1436&amp;ssl=1 1200w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_cnc.jpg?resize=1600%2C1915&amp;ssl=1 1600w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_cnc.jpg?resize=1320%2C1580&amp;ssl=1 1320w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_cnc.jpg?w=1920&amp;ssl=1 1920w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/prescott_2m_cnc.jpg?w=1376&amp;ssl=1 1376w" sizes="(max-width: 688px) 100vw, 688px" data-recalc-dims="1"/></a><figcaption>As always, die annotations involve a lot of guesswork. Take everything with a grain of salt</figcaption></figure></div>
<p>In my opinion, this is the result of Intel biting off more than they could chew. Netburst debuted a mountain of new microarchitecture techniques. Some of these had been implemented by other companies, but were new to Intel. In general, the more you depart off the known path, the more risk you take. More changes mean more moving parts to tune and validate. Intel clearly took on way too much risk. Just to put down what Intel tried to bring into play:</p>
<figure><table><tbody><tr><td></td><td>Netburst (65nm)</td><td>P6 (Pentium II, III)</td></tr><tr><td>Branch Direction Prediction</td><td>Global history based</td><td>Local history based</td></tr><tr><td>Branch Target Caching</td><td>512 entry trace cache BTB</td><td>Single level 512 entry BTB</td></tr><tr><td>Instruction Fetch and Decode</td><td>12K entry trace cache, filled by 1-wide decode</td><td>Conventional 16 KB L1i, 3-wide decode</td></tr><tr><td>Out of Order Execution Strategy</td><td>PRF based scheme</td><td>ROB+RRF based scheme</td></tr><tr><td>OOO Structure Sizes</td><td>Giant</td><td>Tiny</td></tr><tr><td>On L1D cache miss…</td><td>Replay load until data arrives</td><td>Be sensible and wait</td></tr><tr><td>Scheduler Layout</td><td>Distributed scheduler</td><td>Unified scheduler</td></tr><tr><td>Integer execution units</td><td>Double-clocked ALUs</td><td>Conventional 2x ALU</td></tr><tr><td>L1D Cache</td><td>16 KB, write-through</td><td>16 KB, write-back</td></tr><tr><td>Failed Store Forwarding Penalty</td><td>51 cycle dumpster fire</td><td>7-8 cycles? (<a href="https://www.agner.org/optimize/microarchitecture.pdf">Agner Fog</a>)</td></tr><tr><td>L2 Cache</td><td>High latency, high bandwidth</td><td>Low latency, low bandwidth</td></tr><tr><td>Multithreading</td><td>2-way SMT implemented</td><td>Single thread per core</td></tr></tbody></table><figcaption>Netburst has no major components in common with Intel’s prior P6 architecture</figcaption></figure>
<p>With so many moving parts, I strongly suspect Intel didn’t have a good picture of how penalties caused by tradeoffs in different parts of the pipeline could exacerbate each other.</p>
<p>Some of these items are a lot more significant than what a row on a table would suggest. For example, moving from a P6 style ROB+RRF scheme to a PRF based one means you don’t get a register for free just by allocating a ROB entry. You need to keep separate freelists for your register files. I imagine that complicates exception handling – you can’t cancel a batch of bogus ops after a branch mispredict by implementing the ROB as a circular buffer and setting the “head” back to the mispredicted branch. Instead, every register allocated to a bogus operation has to be added back to the respective register file’s freelist. That may have driven the decision to not bother cancelling bogus operations after a branch mispredict, and just have the retirement unit deallocate registers allocated to bogus operations. That in turn forces larger out of order structures to handle the overhead created by tracking those bogus operations for longer than is strictly necessary.</p>
<p>But it’s wrong to write off Netburst as just a failure. Some of the fundamental ideas behind the architecture were definitely flawed. Emphasizing clock speed at the cost of extreme penalties for “corner cases” that aren’t actually uncommon turned out to be a pretty bad strategy. But Netburst served as a learning platform for Intel. The company implemented a variety of new microarchitecture techniques for the first time, and saw how they performed in practice. They figured out what worked and what didn’t. They took years to gather data and tune novel features like HyperThreading. </p>
<p>Going through Netburst’s architecture again, we can see how the good parts came back to enable Sandy Bridge’s success. </p>
<figure><table><tbody><tr><td></td><td>Netburst (65nm)</td><td>Sandy Bridge</td><td>Comments</td></tr><tr><td>Branch Direction Prediction</td><td>Global history based</td><td>Global history based</td><td>Experience from Netburst probably informed branch predictor design decisions</td></tr><tr><td>Branch Target Caching</td><td>512 entry trace cache BTB</td><td>8 entry L0 BTB</td><td>Intel learned how to make large BTBs with Netburst</td></tr><tr><td>Instruction Fetch and Decode</td><td>12K entry trace cache, filled by 1-wide decode</td><td>1.5K entry micro-op cache, filled by 4-wide decode and 32 KB L1i</td><td>Netburst TC details carried forward: micro-op caching, 6 micro-op cache lines, and having the micro-op cache store pointers to microcode for complex instructions</td></tr><tr><td>Out of Order Execution strategy</td><td>PRF based scheme</td><td>PRF based scheme</td><td>ROB+RRF scheme from P6 discarded</td></tr><tr><td>OOO structure sizes</td><td>Giant</td><td>Also market leading</td><td>Sandy Bridge actually enjoys the benefit of its large OOO engine because it’s not wasting it with bogus ops</td></tr><tr><td>Scheduler</td><td>Distributed</td><td>Unified</td><td>Reminiscent of P6’s layout, but future microarchitectures split the scheduler again, creating similarities to Netburst</td></tr><tr><td>On L1D cache miss…</td><td>Replay load until data arrives</td><td>Wait for the data</td><td>Netburst replay scheme (mostly) discarded</td></tr><tr><td>Failed store forwarding penalty</td><td>51 cycle dumpster fire</td><td>17-18 cycles</td><td>Likely a compromise to achieve high clock speeds without excessive penalties</td></tr><tr><td>Misaligned access penalty</td><td>&gt;22 cycle (load)</td><td>~5 cycle (load)</td><td>Netburst faceplant strategy not carried forward</td></tr><tr><td>L2 Cache</td><td>High latency, high bandwidth</td><td>Now a mid-level cache</td><td>Cache hierarchy reworked in Sandy Bridge, with L3 latency not far off Netburst’s L2 latency</td></tr><tr><td>Multithreading</td><td>2-way SMT</td><td>2-way SMT</td><td>Experience in tuning Netburst’s SMT implementation likely played a role in how successful it was in Sandy Bridge</td></tr></tbody></table></figure>
<p>Building off this Netburst experience meant Intel wasn’t internally reinventing the wheel when corresponding features were put into Sandy Bridge. Instead, Sandy Bridge hit the ground running. And that architecture was a massive hit, destroying AMD’s presence across every CPU market sector for years to come. Then, they hammered home that advantage by making conservative but steady progress, alternating between microarchitecture evolution and process node ports to keep risk low. And the foundation for this success was built by the infamous Netburst architecture. </p>
<p>If you like our articles and journalism and you want to support us in our endeavors then consider heading over to our <a href="https://www.patreon.com/ChipsandCheese">Patreon</a> or our <a href="https://www.paypal.com/donate/?hosted_button_id=4EMPH66SBGVSQ">PayPal</a> if you want to toss a few bucks our way or if you would like to talk with the Chips and Cheese staff and the people behind the scenes then consider joining our <a href="https://discord.gg/TwVnRhxgY2">Discord</a>.</p>
<h2>Credits and Setup Info</h2>
<p>Big thanks to cha0s for setting up the system and running tests. The Pentium Extreme Edition 965 was running on an Asus P5W64 WS Pro board (Intel i975X chipset) with a 1066 MT/s FSB. Dual channel DDR2-533 3-3-3-9 was used. </p>
<p>The Athlon 64 X2 6000+ (Brisbane, 65nm) latency test was run by catsay. That system had a dual channel DDR2-800 5-5-5-18 setup and an Asus M2N4-SLI board (Nvidia nForce4 SLI chipset).</p>
<h2>Extras</h2>
<p>Northwood uses an earlier version of the Netburst architecture, implemented on the 130 nm process. It’s notable for featuring a very small, but very fast 8 KB L1D with just two cycle latency. The L2 on Cedar Mill and Northwood have similar latency in cycle counts, but Cedar Mill’s L2 is larger.</p>
<figure><img data-attachment-id="8037" data-permalink="https://chipsandcheese.com/northwood_cedarmill_latency_cycles/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/northwood_cedarmill_latency_cycles.png?fit=924%2C507&amp;ssl=1" data-orig-size="924,507" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="northwood_cedarmill_latency_cycles" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/northwood_cedarmill_latency_cycles.png?fit=924%2C507&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/northwood_cedarmill_latency_cycles.png?fit=688%2C378&amp;ssl=1" loading="lazy" width="688" height="378" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/northwood_cedarmill_latency_cycles.png?resize=688%2C378&amp;ssl=1" alt="" srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/northwood_cedarmill_latency_cycles.png?w=924&amp;ssl=1 924w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/northwood_cedarmill_latency_cycles.png?resize=768%2C421&amp;ssl=1 768w" sizes="(max-width: 688px) 100vw, 688px" data-recalc-dims="1"/></figure>
<p>Cedar Mill also achieves higher clocks, which makes its L2 both larger and faster. The same doesn’t apply to the L1 cache, where Northwood delivers lower latency. </p>
<figure><img data-attachment-id="8036" data-permalink="https://chipsandcheese.com/northwood_cedarmill_latency/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/northwood_cedarmill_latency.png?fit=926%2C514&amp;ssl=1" data-orig-size="926,514" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="northwood_cedarmill_latency" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/northwood_cedarmill_latency.png?fit=926%2C514&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/northwood_cedarmill_latency.png?fit=688%2C382&amp;ssl=1" loading="lazy" width="688" height="382" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/northwood_cedarmill_latency.png?resize=688%2C382&amp;ssl=1" alt="" srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/northwood_cedarmill_latency.png?w=926&amp;ssl=1 926w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/06/northwood_cedarmill_latency.png?resize=768%2C426&amp;ssl=1 768w" sizes="(max-width: 688px) 100vw, 688px" data-recalc-dims="1"/></figure>
<p>Intel probably went from a 8 KB, 2 cycle L1D to a 16 KB, 4 cycle one because 8 KB is ridiculously small. Prescott and Cedar Mill feature 64-bit support, and 64-bit code tends to have larger memory footprints. That makes a 8 KB L1D even more nonsensical. Relaxing L1D timings may also have helped Prescott scale to higher clocks.</p>
<p>Results from the graphs above are from Ashley89. That system was equipped with DDR-400 3-4-4-8 and an Intel i865P chipset.</p>
<div>

<ul>
<li>
<p><img alt="" src="https://secure.gravatar.com/avatar/83de286347cdfc84e1bb10146350467e?s=80&amp;d=identicon&amp;r=g" height="80" width="80" loading="lazy" data-lazy-srcset="https://secure.gravatar.com/avatar/83de286347cdfc84e1bb10146350467e?s=160&amp;d=identicon&amp;r=g 2x" data-lazy-src="https://secure.gravatar.com/avatar/83de286347cdfc84e1bb10146350467e?s=80&amp;is-pending-load=1#038;d=identicon&amp;r=g" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/>
</p>

</li>
</ul>
</div>



</div></div>
  </body>
</html>
