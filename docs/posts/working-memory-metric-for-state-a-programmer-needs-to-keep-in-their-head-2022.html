<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sourcery.ai/blog/measuring_working_memory/">Original</a>
    <h1>Working memory: metric for state a programmer needs to keep in their head (2022)</h1>
    
    <div id="readability-page-1" class="page"><div><figure>
    <span>
      <span></span>
  <img alt="Counting limits" title="Photo by Crissy Jarvis on Unsplash" src="https://sourcery.ai/static/51d49403b1c17bb4be347452db819e3a/4b190/counting.jpg" srcset="/static/51d49403b1c17bb4be347452db819e3a/e07e9/counting.jpg 200w,
/static/51d49403b1c17bb4be347452db819e3a/066f9/counting.jpg 400w,
/static/51d49403b1c17bb4be347452db819e3a/4b190/counting.jpg 800w,
/static/51d49403b1c17bb4be347452db819e3a/e5166/counting.jpg 1200w,
/static/51d49403b1c17bb4be347452db819e3a/b17f8/counting.jpg 1600w,
/static/51d49403b1c17bb4be347452db819e3a/8bbf8/counting.jpg 2797w" sizes="(max-width: 800px) 100vw, 800px" loading="lazy" decoding="async"/>
    </span>
    <figcaption>Photo by Crissy Jarvis on Unsplash</figcaption>
  </figure>
<p>Typical measures of complexity in code are focused heavily on nesting and
logical complexity, which are critically important, but they’re not the only
factor we should be considering when we think about complexity and code quality.
Consider the two functions below:</p>
<div data-language="python"><pre><code><span>def</span> <span>payroll</span><span>(</span>employee_database<span>)</span><span>:</span>
    <span>for</span> name<span>,</span> employee <span>in</span> employee_database<span>.</span>items<span>(</span><span>)</span><span>:</span>
        <span>if</span> <span>(</span>
            has_passed_probation<span>(</span>employee<span>)</span>
            <span>and</span> <span>(</span>is_paid_monthly<span>(</span>employee<span>)</span> <span>and</span> is_end_of_month<span>)</span>
            <span>or</span> <span>(</span>is_paid_weekly<span>(</span>employee<span>)</span> <span>and</span> is_end_of_week<span>)</span>
        <span>)</span><span>:</span>
            run_payroll<span>(</span>name<span>,</span> employee<span>.</span>salary<span>)</span>
            letter <span>=</span> write_letter<span>(</span>name<span>)</span>
            send_to_printer<span>(</span>letter<span>)</span></code></pre></div>
<div data-language="python"><pre><code><span>def</span> <span>minimum_odd_number</span><span>(</span>numbers<span>)</span><span>:</span>
    min_value <span>=</span> <span>9999</span>
    <span>for</span> number <span>in</span> numbers<span>:</span>
        <span>if</span> number <span>&lt;</span> min_value<span>:</span>
            <span>if</span> number <span>%</span> <span>2</span> <span>!=</span> <span>0</span><span>:</span>
                min_value <span>=</span> number
    <span>return</span> min_value</code></pre></div>
<p>Both of these functions have a cognitive complexity score of 6, but the top
function is fairly obviously harder to understand than the bottom function. But
why is this the case?</p>
<p>In the second function, we can basically step our way through the function, only
checking one variable at a time:</p>
<ul>
<li>First, is the number we’re looking at less than the minimum value (dealing
with 2 variables)?</li>
<li>Second, is the number odd (dealing with 3 values - <code>number % 2</code>, <code>0</code>, and we
still need to track that <code>number &lt; min_value</code>)?</li>
<li>We iteratively update the <code>min_value</code> and ultimately return it.</li>
</ul>
<p>Compare that with the first function:</p>
<ul>
<li>First, we have to check multiple conditions - have they passed probation, and
if they are, are they paid monthly, and is it the end of the month (dealing
with 3 variables)?</li>
<li>If that’s true we can move ahead, but if it’s false we need to then check -
are they paid weekly and is it the end of the week and we need to remember
what we initially were tracking?</li>
<li>Then if both of those are true, we still need to bring in the employee’s name
&amp; salary to <code>run_payroll</code> (2 more variables).</li>
</ul>
<p>Looking at it this way suggests that a big piece of the reason that Function 1
is harder to understand than Function 2 is because of the number of different
variables, states, and values that we need to keep track of while we work our
way through the function. This sparked us to create a new metric - what we term
Working Memory - to account for the number of <strong>distinct pieces of program
state</strong> that a developer needs to keep in their head when analysing a function
and the impact this has on the understandability and maintainability of code.</p>
<p>Note: Sometimes we hear from developers that they think that the Working Memory
is directly related to the amount of computer memory a function takes up or is
directly related to the performance of the function. While there are cases where
a higher Working Memory will result in the function taking up more computer
memory or having worse performance, these are incidental, not the goal of the
metric. (If you have a suggestion for a better name for the metric - let us
know!)</p>
<h2>Calculating Your Code’s Peak Working Memory</h2>
<p>The Working Memory for your code changes from line to line. It increases with
complex lines and as you need to retain information from surrounding lines and
decreases as you reduce the amount of information you need to actively consider.
There are 5 rules behind the calculation of the Working Memory metric:</p>
<p><strong>Rule 1:</strong> Each variable, constant, and function call in a line increases the
Working Memory by 1.</p>
<p><strong>Rule 2:</strong> Any variables declared above the line that are used below the line
increase the Working Memory by 1 per variable. Even though these variables are
not used directly on the line, you need to remember what they are doing while
reading the line to understand the full code.</p>
<p><strong>Rule 3:</strong> If there are any conditional checks that impact the line of code in
question then the variables, constants, or function calls in that conditional
check each increment the Working Memory by 1.</p>
<p><strong>Rule 4:</strong> Complex variables which involve a base object as well as a variable,
such as <code>self.price</code> or <code>self.price.currency</code> add 2 to the Working Memory rather
than the standard 1 point increase for a variable. This is due to the fact that
we need to account for both the full variable and the base object.</p>
<p><strong>Rule 5:</strong> If we have a list of experssions such as arguments to a function,
creating a dictionary or list, we take the peak Working Memory from the list
rather than adding them all up.</p>
<p>We consider the Peak Working Memory within a method to determine the relevant
complexity for the method because it will determine whether the function is
overly complex or not.</p>
<p>Let’s take a quick look at an example function to see how we would calculate the
Working Memory line by line:</p>
<div data-language="python"><pre><code><span>def</span> <span>example_function</span><span>(</span>self<span>,</span> var<span>,</span> b<span>,</span> c<span>)</span><span>:</span>
    <span>if</span> condition_holds<span>(</span>var<span>)</span><span>:</span>
        a <span>=</span> b <span>+</span> c
    <span>else</span><span>:</span>
        self<span>.</span>alter_vars<span>(</span>b<span>,</span> c<span>)</span>
        a <span>=</span> b <span>-</span> c
    <span>return</span> a</code></pre></div>
<ol>
<li>Line 1 has a Working Memory value of 2. 1 for <code>condition_holds()</code> function
call and 1 for <code>var</code></li>
<li>Line 2 has a Working Memory of 5. 3 for each of <code>a</code>, <code>b</code> , and <code>c</code> as well as
the 2 from Line 1 that we must retain because of Rule 3.</li>
<li>Line 3 has a Working Memory of 2 for the same reasons as Line 1.</li>
<li>Line 4 has a Working Memory of 7. 2 for <code>self.alter_vars()</code> (Rule 4), 2 for
each <code>b</code> and <code>c</code>, 2 for the conditions from Line 1, and 1 more because <code>a</code> is
declared above the line and referenced again below (Rule 2)</li>
<li>Line 5 has a Working Memory of 5 for the same reasons as line 2.</li>
<li>Line 6 has a Working Memory of 1</li>
</ol>
<p>The max Working Memory for this function comes from line 4, giving the whole
function a Working Memory of 7.</p>
<p>If you’d like to see more examples of how to calculate Working Memory, you
should check out Nick’s previous blog post on the subject.</p>
<h2>Why is Working Memory an Actually Relevant Metric?</h2>
<p>So far, we’ve largely discussed the value of Working Memory in an intuitive
sense - that methods with fewer variables, constants, and function calls to keep
track of seem to be and should be easier to understand. But, why is this the
case?</p>
<p>To answer this question, let’s quickly turn to psychology &amp; neuroscience. George
Miller, Eugene Galanter, and Charles Pribram are credited with coining the term
Working Memory in the 1960s as a measure of human cognitive recall capacity.
Working Memory in this context is similar to what is often discussed as
short-term memory but similar to how we’ve used it for code, it directly relates
to the capacity to retain and manipulate information for a limited period of
time.</p>
<p>Experiments over the past 60 years have repeatedly shown that there is a clear
capacity limit to Working Memory and that beyond that capacity, humans are not
able to retain or manipulate additional data in a limited period of time. For
example - in one of Miller’s experiments he looked at how many digits a person
could remember and repeat back in order. Consistently he found that the limit
for this task (as well as many other tasks involving Working Memory) was 7 ± 2.
This consistent threshold of 7 ± 2 has been termed “the magical number seven,
plus or minus two” and represents a good average benchmark for the amount of
information that the average person can retain in a short window.</p>
<p>When it comes to software, Working Memory (both in the neuroscience sense and in
the code quality sense we discussed earlier) plays a crucial role in both the
speed and quality of future development. Complex code with a high Working Memory
score will push the limit of what a developer reading the code can easily
understand and forces them to frequently revisit or reassess the code to make
sure they know what it is doing. This leads to slowdowns in new development and
in code reviews, as reviewers also struggle with the increased burden of high
working memory.</p>
<h2>Improving High Working Memory Scores</h2>
<p>If we want to reduce the Working Memory for our code we need to reduce the
number of active contributors to Working Memory that we need to track throughout
the method. One of the simplest ways to do this is by grouping or chunking
together multiple pieces of state that would normally each contribute to the
code’s Working Memory so we only need to now track that chunk.</p>
<p>For example, if we return to the function that we started out with:</p>
<div data-language="python"><pre><code><span>def</span> <span>original_function</span><span>(</span>employee_database<span>)</span><span>:</span>
    <span>for</span> name<span>,</span> employee <span>in</span> employee_database<span>.</span>items<span>(</span><span>)</span><span>:</span>
        <span>if</span> <span>(</span>
            has_passed_probation<span>(</span>employee<span>)</span>
            <span>and</span> <span>(</span>is_paid_monthly<span>(</span>employee<span>)</span> <span>and</span> is_end_of_month<span>)</span>
            <span>or</span> <span>(</span>is_paid_weekly<span>(</span>employee<span>)</span> <span>and</span> is_end_of_week<span>)</span>
        <span>)</span><span>:</span>
            run_payroll<span>(</span>name<span>,</span> employee<span>.</span>salary<span>)</span>
            letter <span>=</span> write_letter<span>(</span>name<span>)</span>
            send_to_printer<span>(</span>letter<span>)</span></code></pre></div>
<p>We can group together that initial set of conditional checks into a single chunk
by introducing a variable <code>paid_today</code> :</p>
<div data-language="python"><pre><code><span>def</span> <span>introducing_variable_version</span><span>(</span>employee_database<span>)</span><span>:</span>
    <span>for</span> name<span>,</span> employee <span>in</span> employee_database<span>.</span>items<span>(</span><span>)</span><span>:</span>
        paid_today <span>=</span> <span>(</span>
            has_passed_probation<span>(</span>employee<span>)</span>
            <span>and</span> <span>(</span>is_paid_monthly<span>(</span>employee<span>)</span> <span>and</span> is_end_of_month<span>)</span>
            <span>or</span> <span>(</span>is_paid_weekly<span>(</span>employee<span>)</span> <span>and</span> is_end_of_week<span>)</span>
        <span>)</span>
        <span>if</span> paid_today<span>:</span>
            run_payroll<span>(</span>name<span>,</span> employee<span>.</span>salary<span>)</span>
            letter <span>=</span> write_letter<span>(</span>name<span>)</span>
            send_to_printer<span>(</span>letter<span>)</span></code></pre></div>
<p>Here we still need to handle the complexity of figuring out the value of
<code>paid_today</code> but once we do, we can just use the variable without having to
worry about the details of calculating it.</p>
<p>We can then separate out that complexity even further if we move the
determination of the value of <code>paid_today</code> into its own function.</p>
<div data-language="python"><pre><code><span>def</span> <span>extracted_function_version</span><span>(</span>employee_database<span>)</span><span>:</span>
    <span>for</span> name<span>,</span> employee <span>in</span> employee_database<span>.</span>items<span>(</span><span>)</span><span>:</span>
        <span>if</span> is_paid_today<span>(</span>employee<span>)</span><span>:</span>
            run_payroll<span>(</span>name<span>,</span> employee<span>.</span>salary<span>)</span>
            letter <span>=</span> write_letter<span>(</span>name<span>)</span>
            send_to_printer<span>(</span>letter<span>)</span>


<span>def</span> <span>is_paid_today</span><span>(</span>employee<span>)</span><span>:</span>
    <span>return</span> <span>(</span>
        has_passed_probation<span>(</span>employee<span>)</span>
        <span>and</span> <span>(</span>is_paid_monthly<span>(</span>employee<span>)</span> <span>and</span> is_end_of_month<span>)</span>
        <span>or</span> <span>(</span>is_paid_weekly<span>(</span>employee<span>)</span> <span>and</span> is_end_of_week<span>)</span>
    <span>)</span></code></pre></div>
<p>By breaking out complex analyses into their own methods, we can simplify the
Working Memory of our main function because we normally don’t need to worry
about what goes into <code>is_paid_today</code> when trying to understand the main
function. When we want to dive into those details we can look at the extracted
function separately - effectively splitting the cognitive load that the high
Working Memory function would have created into two discrete steps.</p>
<p>In general, the best way to reduce the Working Memory of your code is to
separate out the logic of your program so that each section deals with a
specific responsibility and they’re not intertwined.</p>
<h2>Conclusions</h2>
<p>We all have a capacity limitation to the amount of information we can store,
process, and manipulate in our heads in the short term. Looking at your code’s
Working Memory metric allows you to understand where in your code you are
creating an undue burden on this capacity, leading to slowdowns in new feature
development, code reviews, and increasing the risk of bugs and errors being
introduced to your code.</p>
<p><em>This is the second part of a seven-part series on code quality, technical debt,
and development velocity.
<strong><a href="https://sourcery.ai/team/">Check out how Sourcery</a></strong> can help to
automatically improve &amp; refactor your code to reduce tech debt, improve code
quality, and increase velocity.
<a href="https://sourcery.ai/blog/code_complexity/">Part 1</a> covered multiple measures of
complexity - cyclomatic vs cognitive complexity</em></p></div></div>
  </body>
</html>
