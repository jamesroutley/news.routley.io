<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://blog.namangoel.com/swift-is-the-more-convenient-rust">Original</a>
    <h1>Swift is a more convenient Rust</h1>
    
    <div id="readability-page-1" class="page"><section id="container">
  <article id="kf5pNR8Jwc8n6dk7svFLSk">
	<time datetime="2023-10-02">October  2, 2023</time>
  
	<p>I’ve been learning Rust lately. </p>

<p>Rust is one of the most loved languages out there, is fast, and has an amazing community. Rust invented the concept of ownership as a solution memory management issues without resorting to something slower like Garbage Collection or Reference Counting. But, when you don’t need to be quite as low level, it gives you utilities such as <code>Rc</code>, <code>Arc</code> and <code>Cow</code> to do reference counting and “clone-on-right” in your code. And, when you need to go lower-level still, you can use the <code>unsafe</code> system  and access raw C pointers.</p>

<p>Rust also has a bunch of awesome features from functional languages like tagged enums, match expressions, first class functions and a powerful type system with generics.</p>

<p>Rust has an LLVM-based compiler which lets it compile to native code and WASM.</p>

<p>I’ve also been doing a bit of Swift programming for a couple of years now. And the more I learn Rust, the more I see a reflection of Swift. (I know that Swift stole a lot of ideas from Rust, I’m talking about my own perspective here).</p>

<p>Swift, too, has awesome features from functional languages like tagged enums, match expressions and first-class functions. It too has a very powerful type system with generics.</p>

<p>Swift too gives you complete type-safety without a garbage collector. By default, everything is a value type with “copy-on-write” semantics. But when you need extra speed you can opt into an ownership system and “move” values to avoid copying. And if you need to go even lower level, you can use the unsafe system and access raw C pointers.</p>

<p>Swift has an LLVM-based compiler which lets it compile to native code and WASM.</p>
<h2 id="deja-vu_2">Deja Vu? <a href="#deja-vu_2">#</a></h2>
<p>You’re probably feeling like you just read the same paragraphs twice. This is no accident. Swift is extremely similar to Rust and has most of the same feature-set. But there is a very big difference is <em>perspective</em>. If you consider the default memory model, this will start to make a lot of sense.</p>
<h2 id="rust-is-bottomup-swift-is-topdown_2">Rust is bottom-up, Swift is top-down. <a href="#rust-is-bottomup-swift-is-topdown_2">#</a></h2>
<p>Rust is a low-level systems language at heart, but it gives you the tools to go higher level. Swift starts at a high level and gives you the ability to go low-level.</p>

<p>The most obvious example of this is the memory management model. Swift use value-types by default with <code>copy-on-write</code> semantics. This is the equivalent of using <code>Cow&lt;&gt;</code> for all your values in Rust. But defaults matter. Rust makes it easy to use “moved” and “borrowed” values but requires extra ceremony to use <code>Cow&lt;&gt;</code> values as you need to “unwrap” them <code>.as_mutable()</code> to actually use the value within. Swift makes these Copy-on-Write values easy to use and instead requires extra ceremony to use borrowing and moving instead. Rust is faster by default, Swift is simpler and easier by default.</p>
<h2 id="swift-takes-rust39s-ideas-and-hides-them-in-c_2">Swift takes Rust’s ideas and hides them in C-like syntax. <a href="#swift-takes-rust39s-ideas-and-hides-them-in-c_2">#</a></h2>
<p>Swift’s syntax is a masterclass in taking awesome functional language concepts and hiding them in C-like syntax to trick the developers into accepting them.</p>

<p>Consider <code>match</code> statements. This is what a match statement looks like in Rust:</p>

<pre><code>enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
</code></pre>

<p>Here’s how that same code would be written in Swift:</p>

<pre><code>enum Coin {
    case penny
    case nickel
    case dime
    case quarter
}
func valueInCents(coin: Coin) -&gt; Int {
    switch coin {
    case .penny: 1
    case .nickel: 5
    case .dime: 10
    case .quarter: 25
    }
}
</code></pre>

<p>Swift doesn’t have a <code>match</code> statement or expression. It has a <code>switch</code> statement that developers are already familiar with. Except this <code>switch</code> statement is actually not a <code>switch</code> statement at all. It’s an expression. It doesn’t “fallthrough”. It does pattern matching. It’s just a <code>match</code> expression with a different name and syntax.</p>

<p>In fact, Swift treats <code>enums</code> as more than <em>just</em> types and lets you put methods directly on it:</p>

<pre><code>enum Coin {
    case penny
    case nickel
    case dime
    case quarter

    func valueInCents() -&gt; Int {
        switch self {
        case .penny: 1
        case .nickel: 5
        case .dime: 10
        case .quarter: 25
        }
    }
}
</code></pre>
<h3 id="optional-types_3">Optional Types <a href="#optional-types_3">#</a></h3>
<p>Rust doesn’t have <code>null</code>, but it does have <code>None</code>. Swift has a <code>nil</code>, but it’s really just a <code>None</code> in hiding. Instead of an <code>Option&lt;T&gt;</code>, Swift let’s you use <code>T?</code>, but the compiler still forces you to check that the value is not <code>nil</code> before you can use it.</p>

<p>You get the same safety with more convenience since you can do this in Swift with an optional type:</p>

<pre><code>let val: T?

if let val {
  // val is now of type `T`.
}
</code></pre>

<p>Also, you’re not forced to wrap every value with a <code>Some(val)</code> before returning it. The Swift compiler takes care of that for you. A <code>T</code> will transparently be converted into a <code>T?</code> when needed.</p>
<h3 id="error-handling_3">Error Handling <a href="#error-handling_3">#</a></h3>
<p>Rust doesn’t have <code>try-catch</code>. Instead it has a <code>Result</code> type which contains the success and error types.</p>

<p>Swift doesn’t have a <code>try-catch</code> either, but it does have <code>do-catch</code> and you have to use <code>try</code> before calling a function that could throw. Again, this is just deception for those developers coming from C-like languages. Swift’s error handling works exactly like Rust’s behind the scenes, but it is hidden in a clever, familiar syntax. </p>

<pre><code>func usesErrorThrowingFunction() throws {
  let x = try thisFnCanThrow()
}

func handlesErrors() {
  do {
    let x = try thisFnCanThrow()
  } catch err {
    // handle the `err` here.
  }
}
</code></pre>

<p>This is very similar to how Rust let’s you use <code>?</code> at the end of statements to automatically forward errors, but you don’t have to wrap your success values in <code>Ok()</code>.</p>
<h2 id="rust39s-compiler-catches-problems-swift39s-co_2">Rust’s compiler catches problems. Swift’s compiler solves some of them <a href="#rust39s-compiler-catches-problems-swift39s-co_2">#</a></h2>
<p>There are many common problems that Rust’s compiler will catch at compile time and even suggest solutions for you. The example that portrays this well is self-referencing enums.</p>

<p>Consider an enum that represents a tree. Since, it is a recursive type, Rust will force you to use something like <code>Box&lt;&gt;</code> for referencing a type within itself.</p>

<pre><code>enum TreeNode&lt;T&gt; {
    Leaf(T),
    Branch(Vec&lt;Box&lt;TreeNode&lt;T&gt;&gt;&gt;),
}
</code></pre>

<p>(You could also us <code>Box&lt;Vec&lt;TreeNode&lt;T&gt;&gt;&gt;</code> instead)</p>

<p>This makes the problem explicit and forces you to deal with it directly. Swift is a little more, <em>automatic</em>.</p>

<pre><code>indirect enum TreeNode&lt;T&gt; {
    case leaf(T)
    case branch([TreeNode&lt;T&gt;])
}
</code></pre>

<p><strong>Note</strong>: that you still have to annotate this <code>enum</code> with the <code>indirect</code> keyword to indicate that it is recursive. But once you’ve done that, Swift’s compiler takes care of the rest. You don’t have to think about <code>Box&lt;&gt;</code> or <code>Rc&lt;&gt;</code>. The values just work normally.</p>
<h2 id="swift-is-less-quotpurequot_2">Swift is less “pure” <a href="#swift-is-less-quotpurequot_2">#</a></h2>
<p>Swift was designed to replace Objective-C and needed to be able to interface with existing code. So, it has made a lot of pragmatic choices that makes it a much less “pure” and “minimalist” language. Swift is a pretty big language compared to Rust and has many more features built-in. However, Swift is designed with “progressive disclosure” in mind which means that just as soon as you think you’ve learned the language a little more of the iceberg pops out of the water.</p>

<p>Here are just <em>some</em> of the language features:</p>

<ul>
<li>Classes / Inhertence</li>
<li>async-await</li>
<li>async-sequences</li>
<li>actors</li>
<li>getters and setters</li>
<li>lazy properties</li>
<li>property wrappers</li>
<li>Result Builders (for building tree-like structures. e.g. HTML / SwiftUI)</li>
</ul>
<h2 id="convenience-has-its-costs_2">Convenience has its costs <a href="#convenience-has-its-costs_2">#</a></h2>
<p>Swift is a far easier language to get started and productive with. The syntax is more familiar and a lot more is done for you automatically. But this really just makes Swift a higher-level language and it comes with the same tradeoffs.</p>

<p>By default, a Rust program is much faster than a Swift program. This is because Rust is fast by default, and <em>lets</em> you be slow, while Swift is easy by default and <em>lets</em> you be fast.</p>

<p>Based on this, I would say both languages have their uses. Rust is better for systems and embedded programming. It’s better for writing compilers and browser engines (Servo) and it’s better for writing entire operating systems.</p>

<p>Swift is better for writing UI and servers and some parts of compilers and operating systems. Over time I expect to see the overlap get bigger.</p>

  <figure id="kudo_kf5pNR8Jwc8n6dk7svFLSk">
    <a href="#kudo">
      
    </a>
    <p>174</p>
    <p>Kudos</p>
  </figure>
  <figure id="kudo_side_kf5pNR8Jwc8n6dk7svFLSk">
    <a href="#kudo">
      
    </a>
    <p>174</p>
    <p>Kudos</p>
  </figure>
</article>

</section></div>
  </body>
</html>
