<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://404wolf.com/posts/androidinthebrowser/">Original</a>
    <h1>Android in the Browser</h1>
    
    <div id="readability-page-1" class="page"><div><astro-slot> <div>  
<ul>
<li><a href="#notice">Notice</a></li>
<li><a href="#presentation">Presentation</a></li>
<li><a href="#inspiration">Inspiration</a>
<ul>
<li><a href="#android-development-on-linux">Android Development on Linux</a></li>
<li><a href="#android-cli-tooling">Android CLI Tooling</a>
<ul>
<li><a href="#a-working-flake">A working flake</a></li>
<li><a href="#an-emulator-in-4-lines-of-nix">An emulator, in 4 lines of Nix</a></li>
<li><a href="#robotnix">RobotNix</a></li>
<li><a href="#adb">ADB</a></li>
</ul>
</li>
<li><a href="#appetizeio">Appetize.io</a></li>
</ul>
</li>
<li><a href="#ideation">Ideation</a>
<ul>
<li><a href="#the-browser">The browser?</a>
<ul>
<li><a href="#streaming">Streaming</a>
<ul>
<li><a href="#scrcpy">Scrcpy</a></li>
<li><a href="#hijacking-scrcpy">Hijacking Scrcpy</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#webrtc">WebRTC?</a>
<ul>
<li><a href="#streaming-to-a-browser">Streaming to a browser</a></li>
</ul>
</li>
<li><a href="#janus-gateway">Janus Gateway</a>
<ul>
<li><a href="#configuring">Configuring</a></li>
</ul>
</li>
<li><a href="#browser-again">Browser again</a>
<ul>
<li><a href="#a-little-react">A Little React</a></li>
<li><a href="#video-encoding-transcoding">Video Encoding Transcoding</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#other-cool-things">Other Cool Things</a></li>
</ul>

<p>This is a long-term, very much in-progress project, so this post currently
serves primarily as a progress tracker and collection of notes on the project,
along with some information what I’ve accomplished so far.</p>

<p>A recreation of a 5 minute presentation I gave at
<a href="https://recurse.com">Recurse Center</a> for the project.</p>
<video controls="" width="100%"><source src="https://static.404wolf.com/5minuteDemo.webm" type="video/webm"/></video>

<p>So, earlier this year I was working on my first React Native application, which
was a small app to plan events. It was my first mobile project in general, and
at the time I got started with it on a Windows machine to avoid the pains that I
assumed may accompany mobile development package management.</p>
<p>It didn’t take long to realize that it’s very very hard to develop for IOS on
anything other than a mac, because tooling to “talk” to iPhones for development
relies on xCode. That means that I couldn’t use a physical iPhone, or even run
an emulator (a “fake” phone running on my computer).</p>
<p><img src="https://static.404wolf.com/https://static.404wolf.com/Post-20240807195159827.webp" alt="Android
studio"/></p>
<p>For Android development, Google is much nicer about it, and lets you run
emulators and bridge a physical phone over on all platforms. They recommend
using <a href="https://developer.android.com/studio">Android Studio</a>, which is <em>fine</em>,
but a pain in the neck. The process to create an emulator in android studio is
pretty straight forward, but requires a lot of clicking and is quite tedious and
magical. You can choose a “skin” and android image, sometimes you configure the
virtual device a bit further with their gui, and then run it from the app.</p>
<p>I used it for the project, and it worked well enough for my needs. Metro, a
bundler that creates and ships APKs based on your <code>react native</code> project works
well with Android studio’s emulator, and it was fine at the time, and was only
moderately annoying to work with.</p>
<h2 id="android-development-on-linux">Android Development on Linux</h2>
<p>Fast forward a few months, and I was returning to the project, but this time was
running NixOS. It was my first half of a <a href="https://recurse.com">Recurse Center</a>
batch, and I was still figuring a lot of things out. One of the things that
<code>nix</code> claims to be very good at is reproducible builds, meaning that I would
expect packages in the <code>nixpkgs</code> package registry to “just work.”</p>
<p>So, I tried adding <code>android-studio</code> to my developer environment, and then ran
it. It launched!</p>
<p>I browsed through the configuration options to go and set up an emulator again,
and, upon launching the emulator, it would say emulator booting, but fail to
actually start.</p>
<p>Debugging this, as a pretty new <code>nix</code> user at the time, was painful. I ran
<code>android studio</code> from the command line, and enabled debug logs. It looked like
there were a whole bunch of dependencies not for android studio, but for the
emulators it was spawning. Part of the issue is that android studio usually
pulls emulator images when you set up the emulators, not when you install
android studio, so while the build of android studio that I got was working just
fine, the emulators that it was pulling were broken, likely because of upstream
changes.</p>
<p>Android Studio is very heavy though; it’s an entire Jetbrains IDE. I find it
really clunky to use, and when things don’t work it’s a pain in the neck to
debug since it’s a massive GUI desktop app that does so many things under the
hood.</p>
<p>Plus, the licensing and codebase for it seems a bit sketchy and obstruce.</p>
<blockquote>
<p>The code is under Apache-2.0, but: If one selects Help -&gt; Licenses in Android
Studio, the dialog shows the following: “Android Studio includes proprietary
code subject to separate license, including JetBrains CLion(R)
(<a href="http://www.jetbrains.com/clion">www.jetbrains.com/clion</a>) and IntelliJ(R) IDEA Community Edition
(<a href="http://www.jetbrains.com/idea">www.jetbrains.com/idea</a>).” Also: For actual development the Android SDK is
required and the Google binaries are also distributed as proprietary software
(unlike the source-code itself).</p>
</blockquote>
<p>I like open source tooling, and I don’t like magic. So, I decided that it would
be productive to delve deeper and figure out how to do what it’s doing without
the entire desktop app.</p>

<p>The general breakdown is that there’s an android SDK toolkit that provides you
with a ton of command line utilities for android development and debugging. This
SDK is included in distributions of android studio, and they are what Android
studio uses internally under the hood. Furthermore, <code>nixpkgs</code> already has
packaged them under<code>android-tools</code> (source
<a href="https://github.com/NixOS/nixpkgs/blob/nixos-24.05/pkgs/tools/misc/android-tools/default.nix#L28">here</a>).
Because the android build system is so annoying to deal with, someone created
<a href="https://github.com/nmeum/android-tools">a project to build these cli tools with cmake</a>,
which is what the official <code>nixpkgs</code> package of them uses.</p>
<p>There’s a lot of CLI tools for dealing with android, but it turns out that
there’s a few critical ones for getting an emulator up and running, and having a
better conceptual understanding of the magic behind android studio.</p>
<p><img src="https://static.404wolf.com/https://static.404wolf.com/Post-20240807233545196.webp" alt="Our
tools"/></p>
<p>First things first. You need to set <code>ANDROID_SDK_ROOT</code> to the directory with the
various binary cli tools we were just talking about (so like, if they’re in your
PATH, you can figure out where to set <code>ANDROID_SDK_ROOT</code>to by doing
<code>which emulator</code>, where emulator is an example of one of the many android
tools). Since I’m using <code>nix</code> , can easily keep things simple and automated with
a devshell. Okay, now we want to</p>
<p>Then we do something along the lines of</p>
<pre tabindex="0" data-language="bash"><code><span><span>avdmanager</span><span> create</span><span> avd</span><span> -n</span><span> my_avd</span><span> -k</span><span> &#34;system-images;android-30;google_apis;x86&#34;</span><span> -d</span><span> &#34;pixel&#34;</span></span></code></pre>
<p>To create an “avd,” which is basically a configuration file that specifies the
details of some virtual android device that could be run as an emulator. AVD
stands for “android virtual device.”</p>
<p>We can check to make sure that our avd shows up by doing</p>
<pre tabindex="0" data-language="bash"><code><span><span>avdmanager</span><span> list</span><span> avd</span></span></code></pre>
<p>And then, to run it, use</p>
<pre tabindex="0" data-language="bash"><code><span><span>emulator</span><span> -avd</span><span> my_avd</span></span></code></pre>
<p>And then, if you’re on <code>nix</code>, you’ll be welcomed with a friendly message
informing you that there’s some dynamically linked dependency that you don’t
have, that you’ll have to wrap with <code>LD_LIBRARY_PATH</code>. And then again.</p>
<p>All of these android CLI tools are very powerful, and have a gagillion options
that you can fiddle with.</p>
<p>I spent almost a week trying to get all the packages and settings fine tuned for
<code>nix</code>, and ended up getting very close — I had a bash script that would create
an <code>avd</code>, create a virtual <code>sdcard</code> for “external” device storage, and then
actually run the emulator. But for some reason I was getting a segfault, and it
wouldn’t launch, or give me any more useful error messages.</p>
<p>At that point I decided to do further research on android emulators on Nix, and
found that Nix’s standard library itself has already solved the problem.</p>
<p>There’s <a href="https://nixos.wiki/wiki/Android">“documentation” here</a> that talks about
android development on Nix. Here, they talk about some helper functions that you
can use to create android SDKs with the exact binaries that you need, nicely
purely packaged with nix.</p>
<p>With the help of that guide and reading some source, I was able to scrap
together this flake, which gets you most of the lower level CLI tools you need
for android development. It’s not entirely trivial, and not every tool is
necessary for every task, but it’s quite good.</p>
<h3 id="a-working-flake">A working flake</h3>
<pre tabindex="0" data-language="nix"><code><span><span>{</span></span>
<span><span>  description</span><span> =</span><span> &#34;React native environment&#34;</span><span>;</span></span>
<span></span>
<span><span>  inputs</span><span> =</span><span> {</span></span>
<span><span>    nixpkgs</span><span>.</span><span>url</span><span> =</span><span> &#34;github:NixOS/nixpkgs&#34;</span><span>;</span></span>
<span><span>    flake-utils</span><span>.</span><span>url</span><span> =</span><span> &#34;github:numtide/flake-utils&#34;</span><span>;</span></span>
<span><span>  };</span></span>
<span></span>
<span><span>  outputs</span><span> =</span><span> { self</span><span>,</span><span> nixpkgs</span><span>,</span><span> flake-utils</span><span>,</span><span> ... </span><span>}@inputs:</span></span>
<span><span>    flake-utils</span><span>.</span><span>lib</span><span>.</span><span>eachDefaultSystem</span><span> (system:</span></span>
<span><span>      let</span></span>
<span><span>        pkgs</span><span> =</span><span> import</span><span> nixpkgs</span><span> {</span></span>
<span><span>          inherit</span><span> system</span><span>;</span></span>
<span><span>          config</span><span> =</span><span> {</span></span>
<span><span>            allowUnfree</span><span> =</span><span> true</span><span>;</span></span>
<span><span>            android_sdk</span><span>.</span><span>accept_license</span><span> =</span><span> true</span><span>;</span></span>
<span><span>          };</span></span>
<span><span>        };</span></span>
<span></span>
<span><span>        pinnedJDK</span><span> =</span><span> pkgs</span><span>.</span><span>jdk17</span><span>;</span></span>
<span><span>        buildToolsVersion</span><span> =</span><span> &#34;34.0.0&#34;</span><span>;</span></span>
<span><span>        ndkVersion</span><span> =</span><span> &#34;25.1.8937393&#34;</span><span>;</span></span>
<span><span>        androidComposition</span><span> =</span><span> pkgs</span><span>.</span><span>androidenv</span><span>.</span><span>composeAndroidPackages</span><span> {</span></span>
<span><span>          cmdLineToolsVersion</span><span> =</span><span> &#34;8.0&#34;</span><span>;</span></span>
<span><span>          toolsVersion</span><span> =</span><span> &#34;26.1.1&#34;</span><span>;</span></span>
<span><span>          platformToolsVersion</span><span> =</span><span> &#34;34.0.4&#34;</span><span>;</span></span>
<span><span>          buildToolsVersions</span><span> =</span><span> [ </span><span>buildToolsVersion</span><span> &#34;33.0.1&#34;</span><span> ];</span></span>
<span><span>          includeEmulator</span><span> =</span><span> false</span><span>;</span></span>
<span><span>          emulatorVersion</span><span> =</span><span> &#34;30.3.4&#34;</span><span>;</span></span>
<span><span>          platformVersions</span><span> =</span><span> [ </span><span>&#34;34&#34;</span><span> ];</span></span>
<span><span>          includeSources</span><span> =</span><span> false</span><span>;</span></span>
<span><span>          includeSystemImages</span><span> =</span><span> false</span><span>;</span></span>
<span><span>          systemImageTypes</span><span> =</span><span> [ </span><span>&#34;google_apis_playstore&#34;</span><span> ];</span></span>
<span><span>          abiVersions</span><span> =</span><span> [ </span><span>&#34;armeabi-v7a&#34;</span><span> &#34;arm64-v8a&#34;</span><span> ];</span></span>
<span><span>          cmakeVersions</span><span> =</span><span> [ </span><span>&#34;3.10.2&#34;</span><span> &#34;3.22.1&#34;</span><span> ];</span></span>
<span><span>          includeNDK</span><span> =</span><span> true</span><span>;</span></span>
<span><span>          ndkVersions</span><span> =</span><span> [ </span><span>ndkVersion</span><span> ];</span></span>
<span><span>          useGoogleAPIs</span><span> =</span><span> false</span><span>;</span></span>
<span><span>          useGoogleTVAddOns</span><span> =</span><span> false</span><span>;</span></span>
<span><span>          includeExtras</span><span> =</span><span> [ </span><span>&#34;extras;google;gcm&#34;</span><span> ];</span></span>
<span><span>        };</span></span>
<span><span>      in</span><span> {</span></span>
<span><span>        devShells</span><span>.</span><span>default</span><span> =</span><span> pkgs</span><span>.</span><span>mkShell</span><span> rec</span><span> {</span></span>
<span><span>          packages</span><span> =</span><span> [</span></span>
<span><span>            pkgs</span><span>.</span><span>android-tools</span></span>
<span><span>            pkgs</span><span>.</span><span>nodejs</span></span>
<span><span>            pkgs</span><span>.</span><span>corepack</span></span>
<span><span>            pkgs</span><span>.</span><span>zulu17</span></span>
<span><span>          ];</span></span>
<span></span>
<span><span>          JAVA_HOME</span><span> =</span><span> pinnedJDK</span><span>;</span></span>
<span><span>          ANDROID_SDK_ROOT</span><span> =</span><span> &#34;</span><span>${</span><span>androidComposition</span><span>.</span><span>androidsdk</span><span>}</span><span>/libexec/android-sdk&#34;</span><span>;</span></span>
<span><span>          ANDROID_NDK_ROOT</span><span> =</span><span> &#34;</span><span>${</span><span>ANDROID_SDK_ROOT</span><span>}</span><span>/ndk-bundle&#34;</span><span>;</span></span>
<span><span>          GRADLE_OPTS</span><span> =</span><span> &#34;-Dorg.gradle.project.android.aapt2FromMavenOverride=</span><span>${</span><span>ANDROID_SDK_ROOT</span><span>}</span><span>/build-tools/</span><span>${</span><span>buildToolsVersion</span><span>}</span><span>/aapt2&#34;</span><span>;</span></span>
<span><span>          shellHook</span><span> =</span><span> &#39;&#39;</span></span>
<span><span>            export PATH=$PATH:</span><span>${</span><span>androidComposition</span><span>.</span><span>androidSdk</span><span>}</span><span>/bin</span></span>
<span><span>            adb start-server</span></span>
<span><span>            adb devices</span></span>
<span><span>          &#39;&#39;</span><span>;</span></span>
<span><span>        };</span></span>
<span><span>      });</span></span>
<span><span>}</span></span></code></pre>
<h3 id="an-emulator-in-4-lines-of-nix">An emulator, in 4 lines of Nix</h3>
<p>After reading through all the source though, a super neat function caught my
eye:
<a href="https://github.com/NixOS/nixpkgs/blob/master/pkgs/development/mobile/androidenv/emulate-app.nix">emulate app</a>.
It wasn’t documented anywhere, but it was super promising. Here’s the entire
source code, which is definitely worth reading over. It’s very similar to what I
was doing, but they were able to figure out how to get all the flags just right.</p>
<pre tabindex="0" data-language="nix"><code><span><span>{ composeAndroidPackages</span><span>,</span><span> stdenv</span><span>,</span><span> lib</span><span>,</span><span> runtimeShell }:</span></span>
<span><span>{ name</span></span>
<span><span>,</span><span> app </span><span>?</span><span> null</span></span>
<span><span>,</span><span> platformVersion </span><span>?</span><span> &#34;33&#34;</span></span>
<span><span>,</span><span> abiVersion </span><span>?</span><span> &#34;armeabi-v7a&#34;</span></span>
<span><span>,</span><span> systemImageType </span><span>?</span><span> &#34;default&#34;</span></span>
<span><span>,</span><span> enableGPU </span><span>?</span><span> false</span><span> # Enable GPU acceleration. It&#39;s deprecated, instead use `configOptions` below.</span></span>
<span><span>,</span><span> configOptions </span><span>?</span><span> (</span></span>
<span><span>    # List of options to add in config.ini</span></span>
<span><span>    lib</span><span>.</span><span>optionalAttrs</span><span> enableGPU</span></span>
<span><span>      (</span><span>lib</span><span>.</span><span>warn</span></span>
<span><span>        &#34;enableGPU argument is deprecated and will be removed; use configOptions instead&#34;</span></span>
<span><span>        { </span><span>&#34;hw.gpu.enabled&#34;</span><span> =</span><span> &#34;yes&#34;</span><span>; }</span></span>
<span><span>      )</span></span>
<span><span>  )</span></span>
<span><span>,</span><span> extraAVDFiles </span><span>?</span><span> [ ]</span></span>
<span><span>,</span><span> package </span><span>?</span><span> null</span></span>
<span><span>,</span><span> activity </span><span>?</span><span> null</span></span>
<span><span>,</span><span> androidUserHome </span><span>?</span><span> null</span></span>
<span><span>,</span><span> avdHomeDir </span><span>?</span><span> null</span><span> # Support old variable with non-standard naming!</span></span>
<span><span>,</span><span> androidAvdHome </span><span>?</span><span> avdHomeDir</span></span>
<span><span>,</span><span> deviceName </span><span>?</span><span> &#34;device&#34;</span></span>
<span><span>,</span><span> sdkExtraArgs </span><span>?</span><span> { }</span></span>
<span><span>,</span><span> androidAvdFlags </span><span>?</span><span> null</span></span>
<span><span>,</span><span> androidEmulatorFlags </span><span>?</span><span> null</span></span>
<span><span>}:</span></span>
<span></span>
<span><span>let</span></span>
<span><span>  sdkArgs</span><span> =</span><span> {</span></span>
<span><span>    includeEmulator</span><span> =</span><span> true</span><span>;</span></span>
<span><span>    includeSystemImages</span><span> =</span><span> true</span><span>;</span></span>
<span><span>  } </span><span>//</span><span> sdkExtraArgs</span><span> //</span><span> {</span></span>
<span><span>    cmdLineToolsVersion</span><span> =</span><span> &#34;8.0&#34;</span><span>;</span></span>
<span><span>    platformVersions</span><span> =</span><span> [ </span><span>platformVersion</span><span> ];</span></span>
<span><span>    systemImageTypes</span><span> =</span><span> [ </span><span>systemImageType</span><span> ];</span></span>
<span><span>    abiVersions</span><span> =</span><span> [ </span><span>abiVersion</span><span> ];</span></span>
<span><span>  };</span></span>
<span></span>
<span><span>  sdk</span><span> =</span><span> (</span><span>composeAndroidPackages</span><span> sdkArgs</span><span>)</span><span>.</span><span>androidsdk</span><span>;</span></span>
<span><span>in</span></span>
<span><span>stdenv</span><span>.</span><span>mkDerivation</span><span> {</span></span>
<span><span>  inherit</span><span> name</span><span>;</span></span>
<span></span>
<span><span>  buildCommand</span><span> =</span><span> &#39;&#39;</span></span>
<span><span>    mkdir -p $out/bin</span></span>
<span></span>
<span><span>    cat &gt; $out/bin/run-test-emulator &lt;&lt; &#34;EOF&#34;</span></span>
<span><span>    #!</span><span>${</span><span>runtimeShell</span><span>}</span><span> -e</span></span>
<span></span>
<span><span>    # We need a TMPDIR</span></span>
<span><span>    if [ &#34;$TMPDIR&#34; = &#34;&#34; ]</span></span>
<span><span>    then</span></span>
<span><span>        export TMPDIR=/tmp</span></span>
<span><span>    fi</span></span>
<span></span>
<span><span>    ${if</span><span> androidUserHome</span><span> ==</span><span> null</span><span> then</span><span> &#39;&#39;</span></span>
<span><span>      # Store the virtual devices somewhere else, instead of polluting a user&#39;s HOME directory</span></span>
<span><span>      export ANDROID_USER_HOME=$(mktemp -d $TMPDIR/nix-android-user-home-XXXX)</span></span>
<span><span>    &#39;&#39;</span><span> else</span><span> &#39;&#39;</span></span>
<span><span>      mkdir -p &#34;</span><span>${</span><span>androidUserHome</span><span>}</span><span>&#34;</span></span>
<span><span>      export ANDROID_USER_HOME=&#34;</span><span>${</span><span>androidUserHome</span><span>}</span><span>&#34;</span></span>
<span><span>    &#39;&#39;</span><span>}</span></span>
<span></span>
<span><span>    ${if</span><span> androidAvdHome</span><span> ==</span><span> null</span><span> then</span><span> &#39;&#39;</span></span>
<span><span>      export ANDROID_AVD_HOME=$ANDROID_USER_HOME/avd</span></span>
<span><span>    &#39;&#39;</span><span> else</span><span> &#39;&#39;</span></span>
<span><span>      mkdir -p &#34;</span><span>${</span><span>androidAvdHome</span><span>}</span><span>&#34;</span></span>
<span><span>      export ANDROID_AVD_HOME=&#34;</span><span>${</span><span>androidAvdHome</span><span>}</span><span>&#34;</span></span>
<span><span>    &#39;&#39;</span><span>}</span></span>
<span></span>
<span><span>    # We need to specify the location of the Android SDK root folder</span></span>
<span><span>    export ANDROID_SDK_ROOT=</span><span>${</span><span>sdk</span><span>}</span><span>/libexec/android-sdk</span></span>
<span></span>
<span><span>    ${</span><span>lib</span><span>.</span><span>optionalString</span><span> (</span><span>androidAvdFlags</span><span> !=</span><span> null</span><span>) </span><span>&#39;&#39;</span></span>
<span><span>      # If NIX_ANDROID_AVD_FLAGS is empty</span></span>
<span><span>      if [[ -z &#34;$NIX_ANDROID_AVD_FLAGS&#34; ]]; then</span></span>
<span><span>        NIX_ANDROID_AVD_FLAGS=&#34;</span><span>${</span><span>androidAvdFlags</span><span>}</span><span>&#34;</span></span>
<span><span>      fi</span></span>
<span><span>    &#39;&#39;</span><span>}</span></span>
<span></span>
<span><span>    ${</span><span>lib</span><span>.</span><span>optionalString</span><span> (</span><span>androidEmulatorFlags</span><span> !=</span><span> null</span><span>) </span><span>&#39;&#39;</span></span>
<span><span>      # If NIX_ANDROID_EMULATOR_FLAGS is empty</span></span>
<span><span>      if [[ -z &#34;$NIX_ANDROID_EMULATOR_FLAGS&#34; ]]; then</span></span>
<span><span>        NIX_ANDROID_EMULATOR_FLAGS=&#34;</span><span>${</span><span>androidEmulatorFlags</span><span>}</span><span>&#34;</span></span>
<span><span>      fi</span></span>
<span><span>    &#39;&#39;</span><span>}</span></span>
<span></span>
<span><span>    # We have to look for a free TCP port</span></span>
<span></span>
<span><span>    echo &#34;Looking for a free TCP port in range 5554-5584&#34; &gt;&amp;2</span></span>
<span></span>
<span><span>    for i in $(seq 5554 2 5584)</span></span>
<span><span>    do</span></span>
<span><span>        if [ -z &#34;$(</span><span>${</span><span>sdk</span><span>}</span><span>/bin/adb devices | grep emulator-$i)&#34; ]</span></span>
<span><span>        then</span></span>
<span><span>            port=$i</span></span>
<span><span>            break</span></span>
<span><span>        fi</span></span>
<span><span>    done</span></span>
<span></span>
<span><span>    if [ -z &#34;$port&#34; ]</span></span>
<span><span>    then</span></span>
<span><span>        echo &#34;Unfortunately, the emulator port space is exhausted!&#34; &gt;&amp;2</span></span>
<span><span>        exit 1</span></span>
<span><span>    else</span></span>
<span><span>        echo &#34;We have a free TCP port: $port&#34; &gt;&amp;2</span></span>
<span><span>    fi</span></span>
<span></span>
<span><span>    export ANDROID_SERIAL=&#34;emulator-$port&#34;</span></span>
<span></span>
<span><span>    # Create a virtual android device for testing if it does not exist</span></span>
<span><span>    if [ &#34;$(</span><span>${</span><span>sdk</span><span>}</span><span>/bin/avdmanager list avd | grep &#39;Name: </span><span>${</span><span>deviceName</span><span>}</span><span>&#39;)&#34; = &#34;&#34; ]</span></span>
<span><span>    then</span></span>
<span><span>        # Create a virtual android device</span></span>
<span><span>        yes &#34;&#34; | </span><span>${</span><span>sdk</span><span>}</span><span>/bin/avdmanager create avd --force -n </span><span>${</span><span>deviceName</span><span>}</span><span> -k &#34;system-images;android-</span><span>${</span><span>platformVersion</span><span>}</span><span>;</span><span>${</span><span>systemImageType</span><span>}</span><span>;</span><span>${</span><span>abiVersion</span><span>}</span><span>&#34; -p $ANDROID_AVD_HOME/</span><span>${</span><span>deviceName</span><span>}</span><span>.avd $NIX_ANDROID_AVD_FLAGS</span></span>
<span></span>
<span><span>        ${</span><span>builtins</span><span>.</span><span>concatStringsSep</span><span> &#34;</span><span>\n</span><span>&#34;</span><span> (</span></span>
<span><span>          lib</span><span>.</span><span>mapAttrsToList</span><span> (</span><span>configKey</span><span>: </span><span>configValue</span><span>: </span><span>&#39;&#39;</span></span>
<span><span>            echo &#34;</span><span>${</span><span>configKey</span><span>}</span><span> = </span><span>${</span><span>configValue</span><span>}</span><span>&#34; &gt;&gt; $ANDROID_AVD_HOME/</span><span>${</span><span>deviceName</span><span>}</span><span>.avd/config.ini</span></span>
<span><span>          &#39;&#39;</span><span>) </span><span>configOptions</span></span>
<span><span>        )</span><span>}</span></span>
<span></span>
<span><span>        ${</span><span>lib</span><span>.</span><span>concatMapStrings</span><span> (</span><span>extraAVDFile</span><span>: </span><span>&#39;&#39;</span></span>
<span><span>          ln -sf </span><span>${</span><span>extraAVDFile</span><span>}</span><span> $ANDROID_AVD_HOME/</span><span>${</span><span>deviceName</span><span>}</span><span>.avd</span></span>
<span><span>        &#39;&#39;</span><span>) </span><span>extraAVDFiles</span><span>}</span></span>
<span><span>    fi</span></span>
<span></span>
<span><span>    # Launch the emulator</span></span>
<span><span>    echo &#34;\nLaunch the emulator&#34;</span></span>
<span><span>    $ANDROID_SDK_ROOT/emulator/emulator -avd </span><span>${</span><span>deviceName</span><span>}</span><span> -no-boot-anim -port $port $NIX_ANDROID_EMULATOR_FLAGS &amp;</span></span>
<span></span>
<span><span>    # Wait until the device has completely booted</span></span>
<span><span>    echo &#34;Waiting until the emulator has booted the </span><span>${</span><span>deviceName</span><span>}</span><span> and the package manager is ready...&#34; &gt;&amp;2</span></span>
<span></span>
<span><span>    ${</span><span>sdk</span><span>}</span><span>/libexec/android-sdk/platform-tools/adb -s emulator-$port wait-for-device</span></span>
<span></span>
<span><span>    echo &#34;Device state has been reached&#34; &gt;&amp;2</span></span>
<span></span>
<span><span>    while [ -z &#34;$(</span><span>${</span><span>sdk</span><span>}</span><span>/libexec/android-sdk/platform-tools/adb -s emulator-$port shell getprop dev.bootcomplete | grep 1)&#34; ]</span></span>
<span><span>    do</span></span>
<span><span>        sleep 5</span></span>
<span><span>    done</span></span>
<span></span>
<span><span>    echo &#34;dev.bootcomplete property is 1&#34; &gt;&amp;2</span></span>
<span></span>
<span><span>    #while [ -z &#34;$(</span><span>${</span><span>sdk</span><span>}</span><span>/libexec/android-sdk/platform-tools/adb -s emulator-$port shell getprop sys.boot_completed | grep 1)&#34; ]</span></span>
<span><span>    #do</span></span>
<span><span>        #sleep 5</span></span>
<span><span>    #done</span></span>
<span></span>
<span><span>    #echo &#34;sys.boot_completed property is 1&#34; &gt;&amp;2</span></span>
<span></span>
<span><span>    echo &#34;ready&#34; &gt;&amp;2</span></span>
<span></span>
<span><span>    ${</span><span>lib</span><span>.</span><span>optionalString</span><span> (</span><span>app</span><span> !=</span><span> null</span><span>) </span><span>&#39;&#39;</span></span>
<span><span>      # Install the App through the debugger, if it has not been installed yet</span></span>
<span></span>
<span><span>      if [ -z &#34;</span><span>${</span><span>package</span><span>}</span><span>&#34; ] || [ &#34;$(</span><span>${</span><span>sdk</span><span>}</span><span>/libexec/android-sdk/platform-tools/adb -s emulator-$port shell pm list packages | grep package:</span><span>${</span><span>package</span><span>}</span><span>)&#34; = &#34;&#34; ]</span></span>
<span><span>      then</span></span>
<span><span>          if [ -d &#34;</span><span>${</span><span>app</span><span>}</span><span>&#34; ]</span></span>
<span><span>          then</span></span>
<span><span>              appPath=&#34;$(echo </span><span>${</span><span>app</span><span>}</span><span>/*.apk)&#34;</span></span>
<span><span>          else</span></span>
<span><span>              appPath=&#34;</span><span>${</span><span>app</span><span>}</span><span>&#34;</span></span>
<span><span>          fi</span></span>
<span></span>
<span><span>          ${</span><span>sdk</span><span>}</span><span>/libexec/android-sdk/platform-tools/adb -s emulator-$port install &#34;$appPath&#34;</span></span>
<span><span>      fi</span></span>
<span></span>
<span><span>      # Start the application</span></span>
<span><span>      ${</span><span>lib</span><span>.</span><span>optionalString</span><span> (</span><span>package</span><span> !=</span><span> null</span><span> &amp;&amp;</span><span> activity</span><span> !=</span><span> null</span><span>) </span><span>&#39;&#39;</span></span>
<span><span>          ${</span><span>sdk</span><span>}</span><span>/libexec/android-sdk/platform-tools/adb -s emulator-$port shell am start -a android.intent.action.MAIN -n </span><span>${</span><span>package</span><span>}</span><span>/</span><span>${</span><span>activity</span><span>}</span></span>
<span><span>      &#39;&#39;</span><span>}</span></span>
<span><span>    &#39;&#39;</span><span>}</span></span>
<span><span>    EOF</span></span>
<span><span>    chmod +x $out/bin/run-test-emulator</span></span>
<span><span>  &#39;&#39;</span><span>;</span></span>
<span><span>}</span></span></code></pre>
<p>Basically, they generate a bash script that “hard codes” paths to the various
packages (things like <code>${pkgs.hello}</code> here evaluate to
<code>/nix/store/jfe...hash...jfei</code>), which are locations of specific, version locked
dependencies.</p>
<p>And it works! Using this function turns out to be extremely trivial. It’s
literally 4 lines of nix, since you don’t need to build an android composition
to use the function, even though you can.</p>
<p>So, here it is. Just a few lines of nix, and then <code>nix run</code>, and you have
yourself a full on, working, ready to go android emulator, running on your
computer.</p>
<pre tabindex="0" data-language="nix"><code><span><span>emulator</span><span> =</span><span> pkgs</span><span>.</span><span>androidenv</span><span>.</span><span>emulateApp</span><span> {</span></span>
<span><span>    name</span><span> =</span><span> &#34;AndroidEmulator&#34;</span><span>;</span></span>
<span><span>    platformVersion</span><span> =</span><span> &#34;30&#34;</span><span>;</span></span>
<span><span>    abiVersion</span><span> =</span><span> &#34;x86_64&#34;</span><span>; </span><span># armeabi-v7a, mips, x86_64</span></span>
<span><span>    systemImageType</span><span> =</span><span> &#34;google_apis_playstore&#34;</span><span>;</span></span>
<span><span>}</span><span>;</span></span></code></pre>
<p>It’s so crazy cool, it just works!</p>
<p>After all of the suffering to get a good working android emulator, and I had an
idea: what if I could solve this problem for everyone, on every OS, everywhere,
once and for all? What if I could offer android phones as a service, just using
nix builds?</p>
<h3 id="robotnix">RobotNix</h3>
<p>One of the massive pain points for Android development is actually building
Android itself. Google provides scattered documentation that helps with this
process, but it’s very disparate, and just about everyone uses prebuilt images
as a result.</p>
<p>In the process of tinkering, I
<a href="https://github.com/tadfisher/android-nixpkgs">came across a project that packaged all google android images with <code>nix</code></a>.
It seemed pretty neat and promising here, since it would solve the issue of
having images change over time in ways that break my setup because of differing
dependencies.</p>
<p><img src="https://static.404wolf.com/https://static.404wolf.com/Post-20240807144625586.webp" alt="Nixified android
builds"/></p>
<p>I spent a long time trying to get an emulator working using the images it
provided, and in the process I learned a ton about android cli tooling.</p>
<p>Tad Fisher’s project that I just mentioned also packages android sdk tools too,
and his are much finer grain.</p>
<pre tabindex="0" data-language="nix"><code><span><span> android-sdk</span><span>.</span><span>packages</span><span> =</span><span> sdk: </span><span>with</span><span> sdk</span><span>; [</span></span>
<span><span>    build-tools-34-0-0</span></span>
<span><span>    cmdline-tools-latest</span></span>
<span><span>    emulator</span></span>
<span><span>    platforms-android-34</span></span>
<span><span>    sources-android-34</span></span>
<span><span>]</span><span>;</span></span></code></pre>
<h3 id="adb">ADB</h3>
<p>One of the most important android <code>cli</code> tools is <code>adb</code>, or
<code>android debug bridge</code>. <code>adb</code> is a CLI tool (and has a socket interface) that is
used to communicate with android devices.</p>
<p>It automatically can pick up on all android devices plugged into your computer
over USB, running on the local network with wireless debugging enabled, and even
emulators (which will be important later).</p>
<p>It’s very powerful. It can do just about everything. To use <code>adb</code> for android
development, usually you begin by running</p>
<pre tabindex="0" data-language="bash"><code><span><span>adb</span><span> start-server</span></span></code></pre>
<p>Which starts a server running on a socket on your computer that lets you use the
<code>adb</code> cli client, or other community clients, to manipulate android devices.</p>
<p>What isn’t as commonly known is that there’s also a <code>tcp/ip</code> mode for <code>adb</code> with
<code>adb tcpip</code>. Once <code>adb</code> is running, you can then list out android devices with</p>
<pre tabindex="0" data-language="bash"><code><span><span>adb</span><span> devices</span></span></code></pre>
<p>And start issuing commands. You can do things like</p>
<ul>
<li><code>adb shell</code> to enter a shell on the android phone itself.</li>
<li><code>adb push</code> to push a file onto the device, and <code>adb pull</code> to yoink files off
it</li>
<li><code>adb (un)(in)stall</code> to un/install apks (android apps) to the device</li>
<li><code>adb input tap x y</code> to tap the screen at a specific spot</li>
</ul>
<p>and a ton of other manipulation commands to do things like entering text input,
capturing screenshots, recording audio, and more.</p>
<p>It’s super powerful, and will play an important role in this project, as I’ll
discuss a bit later.</p>
<p>What I’ve learned while researching these tools is that they are really horribly
documented.
<a href="https://source.android.com/docs/setup/create/coding-tasks">Google has docs</a>
that talk about the general processes, and, if you can figure out where to find
things, you can get the source code for the CLI programs too. But, it seems like
their main intent is to try to get people to use Android Studio as much as
possible.</p>
<h2 id="appetizeio"><a href="https://appetize.io">Appetize.io</a></h2>
<p><a href="https://appetize.io">Appetize.io</a> is a company that offers roughly just that. I
found out about them later on when reviewing the <code>react native</code> documentation —
all the little phone widgets that say “Expo” on them are powered by
<code>appetize.io</code> devices. They let you spin up android or IOS devices, and then
embed them in webpages with decently low latency. They also expose an API, so
that you can do CI/CD testing with proper phones.</p>
<p><img src="https://static.404wolf.com/https://static.404wolf.com/Post-20240807144243428.webp" alt="React native docs"/>
<img src="https://static.404wolf.com/https://static.404wolf.com/Post-20240807144458831.webp" alt="It&#39;s expensive"/>
<img src="https://static.404wolf.com/https://static.404wolf.com/Post-20240807144317000.webp" alt="Appetize.io"/>
<img src="https://static.404wolf.com/https://static.404wolf.com/Post-20240807144431237.webp" alt="It &#34;just works&#34;"/></p>
<p>But appetize comes at a cost. It’s very expensive, and very restrictive. It
isn’t open source, and definitely isn’t nixified.</p>
<p>It’s worth mentioning them here before going further though, since what they do
is genuinely really cool. Their main thing is automated testing, although they
may also be able to do android development with the regular SDK tools too.</p>

<p>So, I started brainstorming. My idea was to stream <code>nix</code> packaged android
emulators to web browsers.</p>
<p>One other super cool thing that <code>nix</code> rocks at is containerizing things. Nix’s
standard library provides
<a href="https://nix.dev/tutorials/nixos/building-and-running-docker-images.html">utilities to create docker base images</a>
that have all of the dependencies and transient dependencies of a nix derivation
(build).</p>
<p>This means that you can implicitly refer to libraries in the function nix
provides that creates docker images, and if they get mentioned then they get
“baked” into the container. Part of what’s so nice about dockering android
emulators is that the processes live and die with the containers, since the qemu
processes that the emulators create are kind of a pain to track and to kill.</p>
<p>I am still working on getting them working in a docker container, but what I
currently have, which is pretty close to what I expect to work, looks like this</p>
<pre tabindex="0" data-language="nix"><code><span><span>{</span></span>
<span><span>  pkgs</span><span>,</span></span>
<span><span>  android-tools</span><span>,</span></span>
<span><span>  system</span><span>,</span></span>
<span><span>  ...</span></span>
<span><span>}: </span><span>let</span></span>
<span><span>  run-android-emulator</span><span> =</span><span> import</span><span> ./emulator.nix</span><span> {</span><span>inherit</span><span> pkgs</span><span>;};</span></span>
<span><span>  android-sdk</span><span> =</span><span> import</span><span> ./android-sdk.nix</span><span> {</span><span>inherit</span><span> pkgs</span><span> system</span><span> android-tools</span><span>;};</span></span>
<span><span>in</span></span>
<span><span>  pkgs</span><span>.</span><span>dockerTools</span><span>.</span><span>buildImage</span><span> {</span></span>
<span><span>    name</span><span> =</span><span> &#34;android-emulator&#34;</span><span>;</span></span>
<span><span>    tag</span><span> =</span><span> &#34;latest&#34;</span><span>;</span></span>
<span></span>
<span><span>    copyToRoot</span><span> =</span><span> pkgs</span><span>.</span><span>buildEnv</span><span> {</span></span>
<span><span>      name</span><span> =</span><span> &#34;root&#34;</span><span>;</span></span>
<span><span>      pathsToLink</span><span> =</span><span> [</span><span>&#34;/bin&#34;</span><span>];</span></span>
<span><span>      paths</span><span> =</span><span> [</span></span>
<span><span>        pkgs</span><span>.</span><span>jdk</span></span>
<span><span>        pkgs</span><span>.</span><span>coreutils</span></span>
<span><span>        pkgs</span><span>.</span><span>bash</span></span>
<span><span>        pkgs</span><span>.</span><span>busybox</span></span>
<span><span>        pkgs</span><span>.</span><span>bun</span></span>
<span><span>        android-sdk</span></span>
<span><span>      ];</span></span>
<span><span>    };</span></span>
<span></span>
<span><span>    config</span><span> =</span><span> {</span></span>
<span><span>      Env</span><span> =</span><span> [</span></span>
<span><span>        &#34;JAVA_HOME=</span><span>${</span><span>pkgs</span><span>.</span><span>jdk</span><span>}</span><span>&#34;</span></span>
<span><span>      ];</span></span>
<span><span>      # has the script that uses the emulate-app function</span></span>
<span><span>      Cmd</span><span> =</span><span> [</span><span>&#34;./</span><span>${</span><span>run-android-emulator</span><span>}</span><span>/bin/android-emulator&#34;</span><span>];</span></span>
<span><span>    };</span></span>
<span></span>
<span><span>    extraCommands</span><span> =</span><span> &#39;&#39;</span></span>
<span><span>      mkdir -p tmp</span></span>
<span><span>    &#39;&#39;</span><span>;</span></span>
<span><span>  }</span></span></code></pre>
<p>Which does basically exactly what I just explained — although we do need some
dependencies that I didn’t reference directly off of a nix object, like
coreutils, and cli things like grep.</p>
<h2 id="the-browser">The browser?</h2>
<p>My goal was to have the easiest, most streamlined devex possible for the
project. So, ideally the final product for the end user could just be a react
component, or even an <code>iframe</code> eventually. Right now, the interface is this.</p>
<pre tabindex="0" data-language="typescript"><code><span><span>export</span><span> default</span><span> function</span><span> App</span><span>() </span><span>{</span></span>
<span><span>  return</span><span> &lt;</span><span>Android</span><span> ip</span><span>=</span><span>{[</span><span>&#34;ws://127.0.0.1:8188&#34;</span><span>]} </span><span>apiSecret</span><span>=</span><span>&#34;secret&#34;</span><span> /&gt;</span></span>
<span><span>}</span></span></code></pre>
<h3 id="streaming">Streaming</h3>
<p>The first step is to stream android at as low latency as possible out of the
phone. As close to literal 0 as possible (so in reality, ideally &lt;300ms). Doing
this, however, is actually pretty nontrivial.</p>
<p>The first step is figuring out how we can stream the screen out of the android
device. Obviously this is possible, because when you run android emulators
(without the <code>-no-window</code> flag) you get a window that shows the screen of the
android device and is interactive. Android studio also natively provides this
feature.</p>
<p><code>adb</code>, which we talked about earlier, does do this out of the box with a built
in android utility called screenrecord. More information about that can be found
<a href="https://android.stackexchange.com/questions/7686/is-there-a-way-to-see-the-devices-screen-live-on-pc-through-adb">here</a>.</p>
<p>To use it, it looks something like this…</p>
<pre tabindex="0" data-language="bash"><code><span><span>sudo</span><span> apt-get</span><span> install</span><span> adb</span><span> ffmpeg</span></span>
<span><span>adb</span><span> exec-out</span><span> screenrecord</span><span> --output-format=h264</span><span> -</span><span> |</span></span>
<span><span>   ffplay</span><span> -framerate</span><span> 60</span><span> -probesize</span><span> 32</span><span> -sync</span><span> video</span><span>  -</span></span></code></pre>
<p>It does work, but unfortunately the latency is pretty high. My tests got about 6
seconds of latency, although this stackoverflow post’s video seems to have
gotten about a second or less with some <code>ffmpeg</code> tuning. I may return to this
later, but for now I am using what I believe to be a better alternative,
<a href="https://github.com/Genymobile/scrcpy"><code>scrcpy</code></a>.</p>
<h4 id="scrcpy">Scrcpy</h4>
<p><img src="https://static.404wolf.com/https://static.404wolf.com/Post-20240807144813092.webp" alt="Scrcpy"/>
<img src="https://static.404wolf.com/https://static.404wolf.com/Post-20240807144914137.webp" alt="Scrpy in action"/></p>
<p>Scrcpy (“screen copy”) is a 3rd party utility that lets you stream an android
device to a window at extremely low latency (30ms or less!). It “just works,”
and is available on <code>nixpkgs</code> (nix package manager). Using it is literally as
simple as plugging in an android device, or running an emulator (headless or
headed, it doesn’t care), and then running</p>
<pre tabindex="0" data-language="bash"><code><span><span>scrcpy</span></span></code></pre>
<p>And a window will open up on your computer with <code>scrcpy</code>, which has a live
stream of the screen of the android phone. The window it opens up is interactive
and is very responsive, and audio works out of the box too.</p>
<p>The client (the window it opens up) has support for more advanced things too.</p>
<p>So, they seem to have solved the issue of <code>adb</code> having bad latency, but how?</p>
<p>To figure out how scrcpy works behind the scenes, they lay out a general
schematic in
<a href="https://github.com/Genymobile/scrcpy/blob/master/doc/develop.mdhttps://github.com/Genymobile/scrcpy/blob/master/doc/develop.md">their docs</a>
for contributors. I’m not going to reiterate everything they say there, but
there are a few important takeaways if I want to use scrcpy’s system of
streaming at low latency.</p>
<p>The general idea of how <code>scrcpy</code> works is that you run it, and it ships a <code>apk</code>
(android app) to the phone in its <code>/tmp</code> directory (which android phones have,
they are also <code>unix</code>!). This <code>apk</code> exposes a server on the android phone on a
<code>scrcpy</code> port on the phone, which then the <code>scrcpy</code> client can access and send
data through.</p>
<p><img src="https://static.404wolf.com/https://static.404wolf.com/Post-20240808142749751.webp" alt="Scrcpy server with
audio"/></p>
<p>This <code>scrcpy</code> server that runs on the phone is implemented in <code>java</code> (which most
android apps are), and acts as just a server running in the background.</p>
<p>It turns out that <code>scrcpy</code> streams out data over three “channels,” where the
first connection gets a connection to stream video, followed by audio, and
finally data (interactions like gestures, which scrcpy also handles itself with
a super low-latency custom binary interface).</p>
<p>Their client itself is very complex, and is implemented in raw C and uses some
very advanced frameworks to optimize for very high performance. That’s less
relevant here.</p>
<h4 id="hijacking-scrcpy">Hijacking Scrcpy</h4>
<p><img src="https://static.404wolf.com/https://static.404wolf.com/Post-20240808142957377.webp" alt="Standalone scrcpy
sever"/></p>
<p>Knowing that scrcpy is just using a server running on the phone was enticing
though.</p>
<p>At this point, I really just wanted to pipe the video into <code>ffmpeg</code> so that I
could do things with it, since I still didn’t know how I would stream it, but I
knew that pretty much no matter what <code>ffmpeg</code> should be able to do the necessary
forwarding.</p>
<p>I did a bit of googling, and it looks like it is possible to do. I found a
github issue, with a link to a VLC (the video viewing program) PR that fixes a
latency issue having to do with how VLC throttles video stream outputs.</p>
<p><img src="https://static.404wolf.com/Post-20240807145206166.webp" alt="Piping Scrcpy to
FFMPEG"/></p>
<p>I was able to follow their steps, and the main pain point was getting <code>adb</code> to
forward a tcp port.</p>
<p>To use <code>scrcpy</code> to stream video output, you need to put and then start <code>scrcpy</code>
on the phone, and then remap the port on the phone that scrcpy is using to a
different port on your computer.</p>
<p>They provide an example script that shows how to do this, which is this</p>
<pre tabindex="0" data-language="bash"><code><span><span>adb</span><span> push</span><span> scrcpy-server-v2.1</span><span> /data/local/tmp/scrcpy-server-manual.jar</span></span>
<span><span>adb</span><span> forward</span><span> tcp:1234</span><span> localabstract:scrcpy</span></span>
<span><span>adb</span><span> shell</span><span> CLASSPATH=/data/local/tmp/scrcpy-server-manual.jar</span><span> \</span></span>
<span><span>    app_process</span><span> /</span><span> com.genymobile.scrcpy.Server</span><span> 2.1</span><span> \</span></span>
<span><span>    tunnel_forward=</span><span>true</span><span> audio=</span><span>false</span><span> control=</span><span>false</span><span> cleanup=</span><span>false</span><span> \</span></span>
<span><span>    raw_stream=</span><span>true</span><span> max_size=</span><span>1920</span></span></code></pre>
<p>It’s not that bad. Another important thing here is that you need to set
<code>raw_stream</code> to <code>false</code>, since usually <code>scrcpy</code> sends some metadata at the start
of streams, which could stop <code>ffmpeg</code> from correctly interpreting the stream.</p>
<p>I found
<a href="https://pencilflip.medium.com/how-to-use-adb-forward-6a8cbfa04907">this great medium post</a>
that talks about how <code>adb forward</code> works, since it is horribly documented. They
mention
<a href="https://cs.android.com/android/platform/superproject/+/master:packages/modules/adb/SERVICES.TXT">SERVICES.txt</a>,
which has even more helpful docs.</p>
<p>I didn’t end up needing to fiddle around much with the default command that they
say to use to forward the port, but I like having an understanding of how it
works.</p>
<p>So, at this point I have a working script that can copy <code>scrcpy</code> over to an
android phone, run it on the phone, and then stream out the screen.</p>
<p>Now, what’s actually coming out of the port? Raw h264 video. Great! Viewing the
screen using the <code>vlc</code> command they say to try <strong>does</strong> work, but it is very
very laggy just like they say.</p>
<h2 id="webrtc">WebRTC?</h2>
<p>Okay, I now (kinda) have a working stream coming out of the android device. This
is pretty sick. Now comes the hard part… how do I take this output stream and
get it to a web browser, with as low latency as possible.</p>
<h3 id="streaming-to-a-browser">Streaming to a browser</h3>
<p><img src="https://static.404wolf.com/Post-20240807145608512.webp" alt="Enter WebRTC"/></p>
<p>I did some research here, and there’s a ton of different streaming protocols
that browsers support. A google search reveals many, like</p>
<ul>
<li>HLS</li>
<li>WebRTC</li>
<li>Real-time Messaging Protocol (Rtmp)</li>
<li>Secure Reliable Transport (Srt)</li>
<li>Real-time Streaming Protocol (Rtsp)</li>
<li>Microsoft Smooth Streaming</li>
<li>RTMP</li>
<li>RTSP</li>
</ul>
<p>HLS is really nice, it’s just relaying video live over http, and you can access
the media directly through a <code>&lt;video&gt;</code> element. Also, <code>ffmpeg</code> supports
streaming out <code>&lt;video&gt;</code> out of the box, which is nice. Unfortunately though, it
adds a lot of latency. To achieve the latency I want in this case, I really
don’t have any option other than WebRTC.</p>
<p>WebRTC is a peer to peer browser streaming protocol. It’s pretty simple to use
since browsers have a good unified API for it, where you essentially have a
signaling websocket server that tells clients when and whom to connect to, and
then they can stream things to each other from the browser itself, like video
camera output.</p>
<p>That’s great, but in my case I am doing a very centralized broadcast. I have
media streaming off of a server, and want to ship that media to browsers
directly. This is something that WebRTC isn’t really designed for.</p>
<p><img src="https://static.404wolf.com/Post-20240807145641902.webp" alt="Janus Gateway"/>
<img src="https://static.404wolf.com/Post-20240807145717463.webp" alt="Janus (the god)"/></p>
<p>There’s a few implementations of the WebRTC protocol, like Google’s official c++
one, or a community rewrite in rust (of course). To use them, there are projects
like <a href="https://github.com/node-webrtc/node-webrtc">node webrtc</a>, which expose a
javascript API to set up webrtc connections. The issue here is that I would have
to implement a lot of the handshake process myself, even if I didn’t need to
actual manage the packets and connection stuff myself, which is a lot of work
that I rather not get caught up in.</p>
<p><img src="https://static.404wolf.com/Post-20240807145750847.webp" alt="Ugh"/></p>
<p>It turns out that I’m not the first person who has wanted extremely low latency
server based WebRTC, and there’s tools that do roughly exactly what I was trying
to do. There’s a super cool project called
<a href="https://github.com/meetecho/janus-gateway">Janus Gateway</a> that is designed to
be a centralized WebRTC server.</p>
<p><img src="https://static.404wolf.com/Post-20240807145822398.webp" alt="Nix to the rescue!"/></p>
<p>It can do a ton of different things, and is a very large C project. The build
process is a huge pain in the neck, but thankfully it was already packaged with
<code>nix</code>, so I didn’t need to deal with it.</p>
<p>The important thing to know about Janus Gateway is that it has a whole bunch of
plugins to do common WebRtc media server tasks.</p>
<p>There are <a href="https://janus.conf.meetecho.com/docs/pluginslist.html">a whole bunch</a>
documented on their website here. Some fun ones:</p>
<ul>
<li><strong>VideoCall plugin</strong>: “Peer to peer” calling each other, but the data flows
through Janus gateway</li>
<li><strong>Sip Plugin</strong> is a plugin that abstracts authing into a SIP server and then
lets you do SIP calls through the browser over WebRTC</li>
<li><strong>VideoRoom</strong> is a plugin meant for many to many streaming, so like,
conference calls</li>
<li><strong>TextRoom</strong>, which is a plugin that deals only with WebRTC’s data channel to
stream raw data at very low latency over WebRTC.</li>
</ul>
<p><img src="https://static.404wolf.com/Post-20240807145842880.webp" alt="Jangouts"/></p>
<p>There’s a really neat project called
<a href="https://github.com/jangouts/jangouts">Jangouts</a> that lets you do google
hangouts style conference calling through an open source server running Janus
Gateway, which is a neat showcase of the capabilities of the plugins.</p>
<p>Finally, there’s an API to create plugins for Janus Gateway in <code>C</code>, <code>lua</code>, and
even <code>javascript</code>, if none of the preexisting plugins work. I think this is
really neat and may return to trying out their API, or once I learn <code>C</code> write a
native plugin, but for now I found what I needed: the <code>streaming</code> plugin.</p>
<p>The <code>streaming</code> Janus Gateway plugin lets you read prerecorded media or access
prerecorded media and broadcast it over WebRTC, but, more importantly, it also
lets you pass in media over
<a href="https://en.wikipedia.org/wiki/Real-time_Transport_Protocol">RTC</a>. Here’s how
they word it</p>
<blockquote>
<p>the plugin is configured to listen on a few ports for RTP: this means that the
plugin is implemented to receive RTP on those ports and relay them to all
peers attached to that stream. Any tool that can generate audio/video RTP
streams and specify a destination is good for the purpose: the examples
section contains samples that make use of GStreamer
(<a href="http://gstreamer.freedesktop.org/">http://gstreamer.freedesktop.org/</a>) but other tools like FFmpeg
(<a href="http://www.ffmpeg.org/">http://www.ffmpeg.org/</a>), LibAV (<a href="http://libav.org/">http://libav.org/</a>) or others are fine as
well. This makes it really easy to capture and encode whatever you want using
your favourite tool, and then have it transparently broadcasted via WebRTC
using Janus. Notice that we recently added the possibility to also add a
datachannel track to an RTP streaming mountpoint: this allows you to send, via
UDP, a text-based message to relay via datachannels (e.g., the title of the
current song, if this is a radio streaming channel). When using this feature,
though, beware that you’ll have to stay within the boundaries of the MTU, as
each message will have to stay within the size of an UDP packet.</p>
</blockquote>
<p>Literally just what I want! How convenient. But now, we have to configure it.</p>
<p>To say it briefly, Janus is a pain in the neck to configure. It’s a monster of a
project and there are a billion different options that all need to be configured
correctly.</p>
<h2 id="janus-gateway">Janus Gateway</h2>
<p>We talked about this a bit earlier, but Janus is a all in one WebRTC, so that
means that it both is a “peer” that is sharing media, but also is the signaling
server itself (the thing that tells clients to start getting content and from
who).</p>
<p>It does the signaling through an API that it exposes, which can either be in the
form of Websockets or HTTP (or both!). It also exposes a “admin api” that you
can use to query metadata about <code>janus</code>, like</p>
<h3 id="configuring">Configuring</h3>
<p>First things first, Janus has its own DSL for configuring it. It’s not that bad,
it’s mostly key pair stuff.</p>
<p>Janus provides a nice set of example configurations that have a ton of comments
<a href="https://github.com/meetecho/janus-gateway/blob/master/conf/janus.jcfg.sample.in">on their github</a>.
It’s very helpful, and I would have been totally lost (well, more totally lost
than the amount of totally lost that I was) had they not had example
configurations.</p>
<p>There’s a few different things we have to configure:</p>
<ul>
<li>The signaling server that <code>Janus</code> hosts and general configuration</li>
<li>The streaming plugin itself</li>
<li>The admin server, which is a separate server for managing janus itself
(getting information like what ports things are running on, statuses, etc)</li>
</ul>
<p>There were a few manual things I had to set up for the configuration. First, I
explicitly enabled the streaming plugin. I’m not entirely sure if this is
necessary, but I believe it would at least give me an error if it couldn’t find
it, which is good.</p>
<pre tabindex="0" data-language="plaintext"><code><span><span>plugins: {</span></span>
<span><span>  enable = &#34;janus.plugin.streaming&#34;</span></span>
<span><span>}</span></span></code></pre>
<p>Second, I set up an admin secret, but <code>janus</code> does have support for token auth
and eventually I’ll figure out how to use that. For auth, it’s not well
documented, but to pass the token when accessing you literally just add a
<code>apisecret: &#34;secret&#34;</code> header to the request.</p>
<pre tabindex="0" data-language="plaintext"><code><span><span>admin_secret = &#34;secret&#34;	# String that all Janus requests must contain</span></span></code></pre>
<p>There’s also a configuration section called <code>media</code>, which seems to be where you
put global media configuration settings.</p>
<p>I’ll be honest in saying I don’t totally understand every setting here, but I
did a lot of trial and error to figure things out. It seems pretty important to
do <code>nack_optimizations</code> for this project, which significantly helped with
stuttering.</p>
<pre tabindex="0" data-language="plaintext"><code><span><span>media: {</span></span>
<span><span>	#ipv6 = true</span></span>
<span><span>	#ipv6_linklocal = true</span></span>
<span><span>	min_nack_queue = 1200</span></span>
<span><span>	rtp_port_range = &#34;20000-40000&#34;</span></span>
<span><span>	dtls_mtu = 1500</span></span>
<span><span>	no_media_timer = 2</span></span>
<span><span>	slowlink_threshold = 4</span></span>
<span><span>	twcc_period = 100</span></span>
<span><span>	dtls_timeout = 500</span></span>
<span><span></span></span>
<span><span>	# Janus can do some optimizations on the NACK queue, specifically when</span></span>
<span><span>	# keyframes are involved. Namely, you can configure Janus so that any</span></span>
<span><span>	# time a keyframe is sent to a user, the NACK buffer for that connection</span></span>
<span><span>	# is emptied. This allows Janus to ignore NACK requests for packets</span></span>
<span><span>	# sent shortly before the keyframe was sent, since it can be assumed</span></span>
<span><span>	# that the keyframe will restore a complete working image for the user</span></span>
<span><span>	# anyway (which is the main reason why video retransmissions are typically</span></span>
<span><span>	# required). While this optimization is known to work fine in most cases,</span></span>
<span><span>	# it can backfire in some edge cases, and so is disabled by default.</span></span>
<span><span>	nack_optimizations = true</span></span>
<span><span></span></span>
<span><span>	# If you need DSCP packet marking and prioritization, you can configure</span></span>
<span><span>	# the &#39;dscp&#39; property to a specific values, and Janus will try to</span></span>
<span><span>	# set it on all outgoing packets using libnice. Normally, the specs</span></span>
<span><span>	# suggest to use different values depending on whether audio, video</span></span>
<span><span>	# or data are used, but since all PeerConnections in Janus are bundled,</span></span>
<span><span>	# we can only use one. You can refer to this document for more info:</span></span>
<span><span>	# https://tools.ietf.org/html/draft-ietf-tsvwg-rtcweb-qos-18#page-6</span></span>
<span><span>	# That said, DON&#39;T TOUCH THIS IF YOU DON&#39;T KNOW WHAT IT MEANS!</span></span>
<span><span>	dscp = 46</span></span>
<span><span>}</span></span></code></pre>
<p><img src="https://static.404wolf.com/Post-20240807145901202.webp" alt="Streaming plugin"/></p>
<p>Getting the streaming plugin working at first seemed really annoying since the
plugins are all <code>C</code> files that have to be built and then placed in a specific
folder on your system, which is not that portable. However, analyzing the
<code>janus</code> cli (the thing you use to launch <code>janus gateway</code>), I figured out that
you can set flags to specify where to look things up. Also, the <code>nix</code> build of
<code>janus</code> comes with all the plugins!</p>
<pre tabindex="0" data-language="bash"><code><span><span>$JANUS </span><span>\</span></span>
<span><span>    -P</span><span> &#34;</span><span>$JANUS_INSTALL</span><span>&#34;</span><span> \</span></span>
<span><span>    -F</span><span> &#34;</span><span>$JANUS_CONFIG_DIR</span><span>&#34;</span><span> \</span></span>
<span><span>    -C</span><span> &#34;</span><span>$JANUS_CONFIG</span><span>&#34;</span></span></code></pre>
<p>Now these official names are really confusing. TLDR: <code>$JANUS_INSTALL</code> is the
directory where the <code>janus</code> binary and plugin binaries live, <code>$JANUS_CONFIG_DIR</code>
is the location where plugin configuration files go, and <code>$JANUS_CONFIG</code> is
where the general configuration file goes.</p>
<p>Now, where is Janus installed? Well, I’ve installed it with nix, so the location
it’s installed will look something like
<code>/nix/store/jfieao...hash....fjeioa/bin/janus</code>, which could change and is bad
practice to directly reference. Eventually, I’ll generate a shell script using
<code>pkgs.writeShellScriptBin</code>, where I can then reference Janus’s root path in the
generator for the shell script as <code>pkgs.janus</code>. To get started though, I did
just do it in a janky way with <code>which</code>. I’ll clean it up eventually.</p>
<p>The directory where <code>janus</code> lives looks like</p>
<pre tabindex="0" data-language="plaintext"><code><span><span>/nix/store/46c284cqdgia0dxzmi8rs5vzwszxalwg-janus-gateway-1.2.3</span></span>
<span><span>├── bin</span></span>
<span><span>│   ├── janus</span></span>
<span><span>│   ├── janus-cfgconv</span></span>
<span><span>│   ├── janus-pp-rec</span></span>
<span><span>│   └── mjr2pcap</span></span>
<span><span>└── lib</span></span>
<span><span>    └── janus</span></span>
<span><span>        ├── events</span></span>
<span><span>        │   ├── libjanus_gelfevh.la</span></span>
<span><span>        │   ├── libjanus_gelfevh.so -&gt; libjanus_gelfevh.so.2.0.3</span></span>
<span><span>        │   ├── libjanus_gelfevh.so.2 -&gt; libjanus_gelfevh.so.2.0.3</span></span>
<span><span>        │   ├── libjanus_gelfevh.so.2.0.3</span></span>
<span><span>        │   ├── libjanus_sampleevh.la</span></span>
<span><span>        │   ├── libjanus_sampleevh.so -&gt; libjanus_sampleevh.so.2.0.3</span></span>
<span><span>        │   ├── libjanus_sampleevh.so.2 -&gt; libjanus_sampleevh.so.2.0.3</span></span>
<span><span>        │   ├── libjanus_sampleevh.so.2.0.3</span></span>
<span><span>        │   ├── libjanus_wsevh.la</span></span>
<span><span>        │   ├── libjanus_wsevh.so -&gt; libjanus_wsevh.so.2.0.3</span></span>
<span><span>        │   ├── libjanus_wsevh.so.2 -&gt; libjanus_wsevh.so.2.0.3</span></span>
<span><span>        │   └── libjanus_wsevh.so.2.0.3</span></span>
<span><span>        ├── loggers</span></span>
<span><span>        │   ├── libjanus_jsonlog.la</span></span>
<span><span>        │   ├── libjanus_jsonlog.so -&gt; libjanus_jsonlog.so.2.0.3</span></span>
<span><span>        │   ├── libjanus_jsonlog.so.2 -&gt; libjanus_jsonlog.so.2.0.3</span></span>
<span><span>        │   └── libjanus_jsonlog.so.2.0.3</span></span>
<span><span>        ├── plugins</span></span>
<span><span>        │   ├── libjanus_audiobridge.la</span></span>
<span><span>        │   ├── libjanus_audiobridge.so -&gt; libjanus_audiobridge.so.2.0.3</span></span>
<span><span>        │   ├── libjanus_audiobridge.so.2 -&gt; libjanus_audiobridge.so.2.0.3</span></span>
<span><span>        │   ├── libjanus_audiobridge.so.2.0.3</span></span>
<span><span>        │   ├── libjanus_echotest.la</span></span>
<span><span>        │   ├── libjanus_echotest.so -&gt; libjanus_echotest.so.2.0.3</span></span>
<span><span>        │   ├── libjanus_echotest.so.2 -&gt; libjanus_echotest.so.2.0.3</span></span>
<span><span>        │   ├── libjanus_echotest.so.2.0.3</span></span>
<span><span>        │   ├── libjanus_nosip.la</span></span>
<span><span>        │   ├── libjanus_nosip.so -&gt; libjanus_nosip.so.2.0.3</span></span>
<span><span>        │   ├── libjanus_nosip.so.2 -&gt; libjanus_nosip.so.2.0.3</span></span>
<span><span>        │   ├── libjanus_nosip.so.2.0.3</span></span>
<span><span>        │   ├── libjanus_recordplay.la</span></span>
<span><span>        │   ├── libjanus_recordplay.so -&gt; libjanus_recordplay.so.2.0.3</span></span>
<span><span>        │   ├── libjanus_recordplay.so.2 -&gt; libjanus_recordplay.so.2.0.3</span></span>
<span><span>        │   ├── libjanus_recordplay.so.2.0.3</span></span>
<span><span>        │   ├── libjanus_sip.la</span></span>
<span><span>        │   ├── libjanus_sip.so -&gt; libjanus_sip.so.2.0.3</span></span>
<span><span>        │   ├── libjanus_sip.so.2 -&gt; libjanus_sip.so.2.0.3</span></span>
<span><span>        │   ├── libjanus_sip.so.2.0.3</span></span>
<span><span>        │   ├── libjanus_streaming.la</span></span>
<span><span>        │   ├── libjanus_streaming.so -&gt; libjanus_streaming.so.2.0.3</span></span>
<span><span>        │   ├── libjanus_streaming.so.2 -&gt; libjanus_streaming.so.2.0.3</span></span>
<span><span>        │   ├── libjanus_streaming.so.2.0.3</span></span>
<span><span>        │   ├── libjanus_textroom.la</span></span>
<span><span>        │   ├── libjanus_textroom.so -&gt; libjanus_textroom.so.2.0.3</span></span>
<span><span>        │   ├── libjanus_textroom.so.2 -&gt; libjanus_textroom.so.2.0.3</span></span>
<span><span>        │   ├── libjanus_textroom.so.2.0.3</span></span>
<span><span>        │   ├── libjanus_videocall.la</span></span>
<span><span>        │   ├── libjanus_videocall.so -&gt; libjanus_videocall.so.2.0.3</span></span>
<span><span>        │   ├── libjanus_videocall.so.2 -&gt; libjanus_videocall.so.2.0.3</span></span>
<span><span>        │   ├── libjanus_videocall.so.2.0.3</span></span>
<span><span>        │   ├── libjanus_videoroom.la</span></span>
<span><span>        │   ├── libjanus_videoroom.so -&gt; libjanus_videoroom.so.2.0.3</span></span>
<span><span>        │   ├── libjanus_videoroom.so.2 -&gt; libjanus_videoroom.so.2.0.3</span></span>
<span><span>        │   └── libjanus_videoroom.so.2.0.3</span></span>
<span><span>        └── transports</span></span>
<span><span>            ├── libjanus_http.la</span></span>
<span><span>            ├── libjanus_http.so -&gt; libjanus_http.so.2.0.3</span></span>
<span><span>            ├── libjanus_http.so.2 -&gt; libjanus_http.so.2.0.3</span></span>
<span><span>            ├── libjanus_http.so.2.0.3</span></span>
<span><span>            ├── libjanus_pfunix.la</span></span>
<span><span>            ├── libjanus_pfunix.so -&gt; libjanus_pfunix.so.2.0.3</span></span>
<span><span>            ├── libjanus_pfunix.so.2 -&gt; libjanus_pfunix.so.2.0.3</span></span>
<span><span>            ├── libjanus_pfunix.so.2.0.3</span></span>
<span><span>            ├── libjanus_websockets.la</span></span>
<span><span>            ├── libjanus_websockets.so -&gt; libjanus_websockets.so.2.0.3</span></span>
<span><span>            ├── libjanus_websockets.so.2 -&gt; libjanus_websockets.so.2.0.3</span></span>
<span><span>            └── libjanus_websockets.so.2.0.3</span></span></code></pre>
<p>So to reference the plugins in the correct places I can write a bash script that
uses <code>janus</code> like this</p>
<pre tabindex="0" data-language="bash"><code><span><span>echo</span><span> &#34;Starting janus in </span><span>$PWD</span><span>&#34;</span></span>
<span><span>CONFIGS</span><span>=</span><span>./src/janus/configs</span></span>
<span><span>JANUS_INSTALL</span><span>=</span><span>$(</span><span>dirname</span><span> &#34;$(</span><span>dirname</span><span> &#34;$(</span><span>which</span><span> janus)&#34;)&#34;</span><span>)</span></span>
<span><span>echo</span><span> &#34;</span><span>$JANUS_INSTALL</span><span>&#34;</span></span>
<span><span>janus</span><span> -P</span><span> &#34;</span><span>$JANUS_INSTALL</span><span>/lib/janus/plugins&#34;</span><span> -F</span><span> &#34;</span><span>$CONFIGS</span><span>&#34;</span><span> -C</span><span> &#34;./src/janus/janus.jcfg&#34;</span></span></code></pre>
<p><code>dirname</code> just gets the directory something is located in, so I’m effectively
hopping two directories up.</p>
<p>Once I was able to load the <code>streaming</code> plugin, I then had to configure it. They
have this
<a href="https://github.com/meetecho/janus-gateway/blob/master/conf/janus.plugin.streaming.jcfg.sample.in">handy example</a>
of various streaming plugin setups for different use cases.</p>
<p>The first example that called out to me is this one:</p>
<pre tabindex="0" data-language="plaintext"><code><span><span># This is an example of an RTP source stream, which is what you&#39;ll need</span></span>
<span><span># in the vast majority of cases: here, the Streaming plugin will bind to</span></span>
<span><span># some ports, and expect media to be sent by an external source (e.g.,</span></span>
<span><span># FFmpeg or Gstreamer). This sample listens on 5002 for audio (Opus) and</span></span>
<span><span># 5004 for video (VP8), which is what the sample gstreamer script in the</span></span>
<span><span># plugins/streams folder sends to. Whatever is sent to those ports will</span></span>
<span><span># be the source of a WebRTC broadcast users can subscribe to.</span></span>
<span><span>#</span></span>
<span><span>rtp-sample: {</span></span>
<span><span>	type = &#34;rtp&#34;</span></span>
<span><span>	id = 1</span></span>
<span><span>	description = &#34;Opus/VP8 live stream coming from external source&#34;</span></span>
<span><span>	metadata = &#34;You can use this metadata section to put any info you want!&#34;</span></span>
<span><span>	audio = true</span></span>
<span><span>	video = true</span></span>
<span><span>	audioport = 5002</span></span>
<span><span>	audiopt = 111</span></span>
<span><span>	audiocodec = &#34;opus&#34;</span></span>
<span><span>	videoport = 5004</span></span>
<span><span>	videopt = 100</span></span>
<span><span>	videocodec = &#34;vp8&#34;</span></span>
<span><span>	secret = &#34;adminpwd&#34;</span></span>
<span><span>}</span></span></code></pre>
<p>Since it claims to do exactly what I want: stream media over RTP.</p>
<p>Okay, so now I just place all the <code>janus</code> configurations into the right spots,
run <code>janus</code> using my hacky <code>bash</code> script, and pray it works.</p>
<p>It didn’t at first, or for the first day of trying to get it to, but eventually
I got it to a functional state where janus would at least run.</p>
<p>Now what? I’m not streaming media, but now I <em>can</em> stream through RTP on
localhost.</p>
<p>The next step was to figure out how to <strong>connect</strong> to <code>janus</code>, which is totally
a pain in the neck and nontrivial.</p>
<h2 id="browser-again">Browser again</h2>
<p>Modern browsers are designed to support WebRTC connections. They provide an API
that you can use to create <code>PeerConnections</code>, do handshaking, set up media
streams, and all that fun stuff.</p>
<p>It looks something like this (signalingServer is a websocket server)</p>
<p>Note that this example is ai-written/modified, since it’s a very minimal short
example of what you’d do to get webrtc working.</p>
<p>ICE is a network technique to establish peer to peer connections while going
through some central server (google hosts a commonly used one).</p>
<pre tabindex="0" data-language="typescript"><code><span><span>// 1. Create peer connection</span></span>
<span><span>const</span><span> pc</span><span> =</span><span> new</span><span> RTCPeerConnection</span><span>()</span></span>
<span></span>
<span><span>// 2. Create and set local description</span></span>
<span><span>const</span><span> offer</span><span> =</span><span> await</span><span> pc.</span><span>createOffer</span><span>()</span></span>
<span><span>await</span><span> pc.</span><span>setLocalDescription</span><span>(offer)</span></span>
<span></span>
<span><span>// 3. Send offer to remote peer (via signaling server)</span></span>
<span><span>signalingServer.</span><span>send</span><span>(</span><span>JSON</span><span>.</span><span>stringify</span><span>(offer))</span></span>
<span></span>
<span><span>// 4. Receive answer from remote peer</span></span>
<span><span>signalingServer.</span><span>onmessage</span><span> =</span><span> async</span><span> (</span><span>event</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span><span>  const</span><span> answer</span><span> =</span><span> JSON</span><span>.</span><span>parse</span><span>(event.data)</span></span>
<span><span>  await</span><span> pc.</span><span>setRemoteDescription</span><span>(answer)</span></span>
<span><span>}</span></span>
<span></span>
<span><span>// 5. Exchange ICE candidates</span></span>
<span><span>pc.</span><span>onicecandidate</span><span> =</span><span> (</span><span>event</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span><span>  if</span><span> (event.candidate) {</span></span>
<span><span>    signalingServer.</span><span>send</span><span>(</span><span>JSON</span><span>.</span><span>stringify</span><span>(event.candidate))</span></span>
<span><span>  }</span></span>
<span><span>}</span></span>
<span></span>
<span><span>// 6. Handle incoming ICE candidates</span></span>
<span><span>signalingServer.</span><span>onmessage</span><span> =</span><span> async</span><span> (</span><span>event</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span><span>  const</span><span> iceCandidate</span><span> =</span><span> JSON</span><span>.</span><span>parse</span><span>(event.data)</span></span>
<span><span>  await</span><span> pc.</span><span>addIceCandidate</span><span>(iceCandidate)</span></span>
<span><span>}</span></span>
<span></span>
<span><span>// 7. Handle getting streams</span></span>
<span><span>pc.</span><span>ontrack</span><span> =</span><span> (</span><span>event</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span><span>  const</span><span> [</span><span>remoteStream</span><span>] </span><span>=</span><span> event.streams</span></span>
<span><span>  console.</span><span>log</span><span>(</span><span>&#39;Received remote stream&#39;</span><span>, remoteStream)</span></span>
<span><span>  // Use the remoteStream, e.g., attach it to a video element</span></span>
<span><span>  const</span><span> videoElement</span><span> =</span><span> document.</span><span>querySelector</span><span>(</span><span>&#39;#remoteVideo&#39;</span><span>)</span></span>
<span><span>  videoElement.srcObject </span><span>=</span><span> remoteStream</span></span>
<span><span>}</span></span>
<span></span>
<span><span>// 8. Connection established</span></span>
<span><span>pc.</span><span>onconnectionstatechange</span><span> =</span><span> (</span><span>event</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span><span>  if</span><span> (pc.connectionState </span><span>===</span><span> &#39;connected&#39;</span><span>) {</span></span>
<span><span>    console.</span><span>log</span><span>(</span><span>&#39;WebRTC connection established!&#39;</span><span>)</span></span>
<span><span>  }</span></span>
<span><span>}</span></span></code></pre>
<p>In this case though, I didn’t actually create the websocket server, and
<code>janus</code>’s is much more complicated than this. It isn’t a matter of just
accepting the first message received, but rather <code>janus</code> requires you actually
have a “conversation” and tell it what you want — you ask for a list of
streams, choose one by id, etc, all while sending heartbeats. It’s annoying to
work with, but they provide a
<a href="https://www.npmjs.com/package/janus-gateway"><code>javascript</code> sdk</a> with type
declarations.</p>
<h3 id="a-little-react">A Little React</h3>
<p>To procrastinate figuring out how to use their sdk, I started off by setting up
a super simple <code>vite</code> <code>react</code> app so that I could nicely abstract things.</p>
<p>I learned a bit about <code>vite</code> here, since I hadn’t used it before. It seems like
vite’s entrypoint is an <code>index.html</code> file that looks something like</p>
<pre tabindex="0" data-language="html"><code><span><span>&lt;</span><span>body</span><span>&gt;</span></span>
<span><span>  &lt;</span><span>div</span><span> id</span><span>=</span><span>&#34;root&#34;</span><span>&gt;&lt;/</span><span>div</span><span>&gt;</span></span>
<span><span>  &lt;</span><span>script</span><span> type</span><span>=</span><span>&#34;module&#34;</span><span> src</span><span>=</span><span>&#34;/src/main.tsx&#34;</span><span>&gt;&lt;/</span><span>script</span><span>&gt;</span></span>
<span><span>&lt;/</span><span>body</span><span>&gt;</span></span></code></pre>
<p>Where vite hosts a server, and then automatically intercepts requests for
<code>/src/main.tsx</code> and serves a <code>javascript</code> bundle (which it can prebuild or
dynamically generate).</p>
<p>I found this
<a href="https://github.com/LorisGiann/simple-janus-streaming-client/blob/master/streamingtest.js">random helpful example</a>
usage that was pretty helpful for figuring out how to interface with <code>janus</code>.</p>
<p>React <a href="https://react.dev/reference/react/hooks">hooks</a> are ways to move logic
away from your components so that you can reuse logic. The difference between
hooks and regular functions is that you can use <code>hooks</code> within <code>hooks</code>, so,
like, hooks can call <code>useState</code> to maintain their own states.</p>
<p>The way you define a hook is by placing it in a file with the <code>use</code> prefix, and
then provide a function as a default export. So like, in my case,
<code>useJanusStream.ts</code> and <code>export default function useJanusStream</code>.</p>
<p>In that function body we can use hooks like <code>useState</code>. Okay, so let’s start
writing the logic for connecting to <code>janus</code> and getting a stream into a
<code>&lt;video&gt;</code> element</p>
<p><a href="https://janus.conf.meetecho.com/docs/JS.html">There are docs</a> on their
javascript sdk, but it’s kinda awful to work with. It sends all the right <code>api</code>
requests and works well enough, but it was implemented before <code>const</code> and
<code>async/await</code>, so it’s full of callbacks and is awful to deal with.</p>
<p>To start, we <code>init</code> <code>Janus</code>, which is already kinda yucky — we’re setting a
global state of how <code>Janus</code> is to behave.</p>
<pre tabindex="0" data-language="typescript"><code><span><span>Janus.</span><span>init</span><span>({</span></span>
<span><span>  debug: </span><span>true</span><span>,</span></span>
<span><span>  dependencies: Janus.</span><span>useDefaultDependencies</span><span>({ adapter }),</span></span>
<span><span>  callback</span><span>: () </span><span>=&gt;</span><span> {</span></span></code></pre>
<p>We get the <code>adapter</code> with <code>import adapter from &#34;webrtc-adapter&#34;</code>, which is from
<a href="https://www.npmjs.com/package/webrtc-adapter">here</a>. It’s a common package that
exposes the <code>WebRTC</code> api in a browser agnostic way.</p>
<p>Okay, now we instantiate a new Janus (yes, init just set a global config state,
it didn’t actually create a connection or anything like that)</p>
<pre tabindex="0" data-language="typescript"><code><span><span>const</span><span> janus</span><span> =</span><span> new</span><span> Janus</span><span>({</span></span>
<span><span>    server: servers, </span><span>// a list of websocket/http server IPs (of janus servers)</span></span>
<span><span>    apisecret: </span><span>&#34;secret&#34;</span><span>,</span></span>
<span><span>    success</span><span>: () </span><span>=&gt;</span><span> {</span></span></code></pre>
<p>And, once the Janus gets created we handle the success with</p>
<pre tabindex="0" data-language="typescript"><code><span><span>janus.</span><span>attach</span><span>({</span></span>
<span><span>    plugin: </span><span>&#34;janus.plugin.streaming&#34;</span><span>,</span></span></code></pre>
<p>This attaches the streaming plugin, which makes an api request that asserts that
there is a streaming plugin running on the <code>janus</code> server, and then (as usual)
has a callback for once the assertion is done…</p>
<pre tabindex="0" data-language="typescript"><code><span><span>success</span><span>: (</span><span>receivedStreamingPluginHandle</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span><span>  console.</span><span>debug</span><span>(</span><span>&#34;Got streaming plugin information&#34;</span><span>);</span></span>
<span><span>  streamingPluginHandle </span><span>=</span><span> receivedStreamingPluginHandle;</span></span>
<span><span>  console.</span><span>debug</span><span>(</span><span>&#34;Requesting stream from plugin&#34;</span><span>);</span></span>
<span><span>  streamingPluginHandle.</span><span>send</span><span>({</span></span>
<span><span>    message: { request: </span><span>&#34;list&#34;</span><span> },</span></span>
<span><span>    success</span><span>: (</span><span>list</span><span>:</span><span> any</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span><span>      console.</span><span>debug</span><span>(</span><span>&#34;Listed!&#34;</span><span>, list);</span></span>
<span><span>    },</span></span>
<span><span>  });</span></span>
<span><span>  streamingPluginHandle.</span><span>send</span><span>({</span></span>
<span><span>    message: { request: </span><span>&#34;info&#34;</span><span>, id: </span><span>1</span><span> },</span></span>
<span><span>    success</span><span>: (</span><span>info</span><span>:</span><span> any</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span><span>      console.</span><span>debug</span><span>(</span><span>&#34;Got info&#34;</span><span>, info);</span></span>
<span><span>    },</span></span>
<span><span>  });</span></span>
<span><span>  streamingPluginHandle.</span><span>send</span><span>({</span></span>
<span><span>    message: { request: </span><span>&#34;watch&#34;</span><span>, id: </span><span>1</span><span> },</span></span>
<span><span>    success</span><span>: (</span><span>resp</span><span>:</span><span> any</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span><span>      console.</span><span>debug</span><span>(</span><span>&#34;Resp&#34;</span><span>, resp);</span></span>
<span><span>      console.</span><span>debug</span><span>(</span></span>
<span><span>        &#34;Watching stream success. Now waiting to start stream.&#34;</span><span>,</span></span>
<span><span>      );</span></span>
<span><span>    },</span></span>
<span><span>  });</span></span>
<span><span>},</span></span></code></pre>
<p>Once it is ready, we ask for a list of streams (to log, for debugging purposes
for now), we get information on the stream that should be the one we are going
to connect to, and then we ask to watch the stream.</p>
<p>That last step is the tricky part — in order to obtain a <code>MediaStreamTrack</code>,
which is just raw video/audio, which we can create a <code>MediaStream</code> from, which
can be slotted into a <code>&lt;video&gt;</code> element, we need to ask <code>janus</code> to send us the
stream, and define a callback for once it’s done so.</p>
<p>Before it can send the stream, it’ll ask to do an auth handshake, which</p>
<pre tabindex="0" data-language="typescript"><code><span><span>onmessage</span><span>: (</span><span>msg</span><span>, </span><span>jsep</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span><span>  console.</span><span>debug</span><span>(</span><span>&#34;Received msg from Janus server&#34;</span><span>, msg, jsep);</span></span>
<span><span>  if</span><span> (streamingPluginHandle </span><span>===</span><span> null</span><span>) </span><span>return</span><span>;</span></span>
<span><span>  if</span><span> (jsep </span><span>===</span><span> undefined</span><span>) </span><span>return</span><span>;</span></span>
<span><span>  console.</span><span>debug</span><span>(</span><span>&#34;Received JSEP!&#34;</span><span>, jsep);</span></span>
<span><span>  console.</span><span>debug</span><span>(</span><span>&#34;Answering the JSEP request.&#34;</span><span>);</span></span>
<span><span>  streamingPluginHandle.</span><span>createAnswer</span><span>({</span></span>
<span><span>    jsep: jsep,</span></span>
<span><span>    media: { audioSend: </span><span>false</span><span>, videoSend: </span><span>false</span><span> },</span></span>
<span><span>    success</span><span>: (</span><span>jsep</span><span>:</span><span> any</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span><span>      console.</span><span>debug</span><span>(</span><span>&#34;Successful SDP answer created&#34;</span><span>);</span></span>
<span><span>      let</span><span> body </span><span>=</span><span> { request: </span><span>&#34;start&#34;</span><span> };</span></span>
<span><span>      streamingPluginHandle.</span><span>send</span><span>({ message: body, jsep: jsep });</span></span>
<span><span>    },</span></span>
<span><span>    error</span><span>: (</span><span>error</span><span>:</span><span> any</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span><span>      console.</span><span>error</span><span>(</span><span>&#34;WebRTC Error:&#34;</span><span>, error);</span></span>
<span><span>    },</span></span>
<span><span>  });</span></span>
<span><span>},</span></span></code></pre>
<p>JSEP’s a complicated handshake that goes on to establish a <code>webrtc</code> connection.
It’s mostly abstracted away from us.</p>
<p>Once the handshake is done, we just define a <code>onRemoteTrack</code> function for when
the <code>MediaTrack</code> is ready.</p>
<pre tabindex="0" data-language="typescript"><code><span><span>onremotetrack</span><span>: (</span><span>track</span><span>:</span><span> MediaStreamTrack</span><span>) </span><span>=&gt;</span></span>
<span><span>    onReceivedMediaTrack</span><span>(track),</span></span></code></pre>
<p>Then we have a <code>MediaStreamTrack</code>, which is a “container” of sorts for the
inbound video stream. We can attach it to our <code>&lt;video&gt;</code> element by creating a
<code>MediaStream</code> with it. A <code>MediaStream</code> is a collection of tracks — so, like,
audio and video, for example.</p>
<p>It looks something like this…</p>
<pre tabindex="0" data-language="typescript"><code><span><span>const</span><span> setupStream</span><span> =</span><span> () </span><span>=&gt;</span><span> {</span></span>
<span><span>  if</span><span> (videoPlayer.current </span><span>&amp;&amp;</span><span> mediaStreamTrack.readyState </span><span>===</span><span> &#39;live&#39;</span><span>) {</span></span>
<span><span>    const</span><span> newMediaStream</span><span> =</span><span> new</span><span> MediaStream</span><span>()</span></span>
<span><span>    newMediaStream.</span><span>addTrack</span><span>(mediaStreamTrack)</span></span>
<span><span>    videoPlayer.current.srcObject </span><span>=</span><span> newMediaStream</span></span>
<span><span>  }</span></span>
<span><span>}</span></span></code></pre>
<p><code>MediaStreamTracks</code> have a enum for their readyState, so if it’s “live” (video
is streaming), then create a <code>MediaStream</code> with the track, and then set our
video element (which we can grab with a selector, or, in this case, a
<code>useRef</code>)‘s srcObject (what it’s playing) to the track we just received.</p>
<p>Okay, so I implemented all of this, and, to put it briefly, it did connect, but
no video would play.</p>
<h3 id="video-encoding-transcoding">Video Encoding Transcoding</h3>
<p>The next major obstacle</p>
<p><img src="https://static.404wolf.com/Post-20240807145930075.webp" alt="Your tab crashed!"/></p>
<p><img src="https://static.404wolf.com/Post-20240807145949240.webp" alt="NALUs"/></p>

<p><img src="https://static.404wolf.com/Post-20240807144559741.webp" alt="RobotNix"/></p>  </div> </astro-slot></div></div>
  </body>
</html>
