<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://antoine.vandecreme.net/blog/rust-closures/">Original</a>
    <h1>Understanding Rust Closures</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p>While reading the <a href="https://smallcultfollowing.com/babysteps/blog/2025/10/22/explicit-capture-clauses/">Explicit capture clauses</a>
blog post, I realized that my understanding of rust closures was very superficial.
This article is an attempt at explaining what I learned while reading and experimenting on the subject.
It starts from the very basics and then explore more complex topics.
Note that each title is a link to a rust playground where you can experiment
with the code in the section.</p>

<p>You probably already know that a closure in rust is a function written with the following syntax:</p>
<pre data-lang="rust"><code data-lang="rust"><span>let </span><span>double_closure </span><span>= </span><span>|x| x * </span><span>2</span><span>;
</span><span>assert_eq!(</span><span>4</span><span>, double_closure(</span><span>2</span><span>));
</span></code></pre>
<p>Written as a regular function it looks like:</p>
<pre data-lang="rust"><code data-lang="rust"><span>fn </span><span>double_function(x: </span><span>u32</span><span>) -&gt; </span><span>u32 </span><span>{
</span><span>    x * </span><span>2
</span><span>}
</span><span>assert_eq!(</span><span>4</span><span>, double_function(</span><span>2</span><span>));
</span></code></pre>
<p>Very similar. There is actually a small difference between the two, the <code>double_function</code> parameter and return type are <code>u32</code>.
On the other hand, because we did not specify any type in <code>double_closure</code>, the
<a href="https://github.com/rust-lang/rfcs/blob/master/text/0212-restore-int-fallback.md">default integer type</a> has been picked, namely <code>i32</code>.</p>
<p>We can fix that like this:</p>
<pre data-lang="rust"><code data-lang="rust"><span>let </span><span>double_typed_closure </span><span>= </span><span>|x: </span><span>u32</span><span>| -&gt; </span><span>u32 </span><span>{ x * </span><span>2 </span><span>};
</span><span>assert_eq!(</span><span>4</span><span>, double_typed_closure(</span><span>2</span><span>));
</span><span>assert_eq!(</span><span>4</span><span>, double_typed_closure(</span><span>2</span><span>u32</span><span>));
</span><span>// assert_eq!(4, double_typed_closure(2u16)); // This would be an error.
</span></code></pre>
<p>And for a classic example usage of closures, we can use the <code>Option::map</code> method:</p>
<pre data-lang="rust"><code data-lang="rust"><span>assert_eq!(Some(</span><span>4</span><span>), Some(</span><span>2</span><span>).map(|x| x * </span><span>2</span><span>));
</span><span>assert_eq!(Some(</span><span>4</span><span>), Some(</span><span>2</span><span>).map(double_closure)); </span><span>// double_closure from above
</span><span>assert_eq!(Some(</span><span>4</span><span>), Some(</span><span>2</span><span>).map(double_function)); </span><span>// Passing double_function works too!
</span></code></pre>
<p>So, it seems closures are just a shorter syntax for functions with type inference.</p>

<p>The main difference between closures and functions is that closures can capture
variables from their environment while functions can&#39;t:</p>
<pre data-lang="rust"><code data-lang="rust"><span>let</span><span> hello = </span><span>&#34;Hello &#34;</span><span>;
</span><span>let </span><span>greeter_closure </span><span>= </span><span>|x| String::new() + hello + x;
</span><span>
</span><span>assert_eq!(</span><span>&#34;Hello world&#34;</span><span>, greeter_closure(</span><span>&#34;world&#34;</span><span>));
</span><span>assert_eq!(
</span><span>    Some(</span><span>&#34;Hello world&#34;</span><span>.to_owned()),
</span><span>    Some(</span><span>&#34;world&#34;</span><span>).map(greeter_closure)
</span><span>);
</span></code></pre>
<p>Notice how the <code>hello</code> variable is used within the body of the <code>greeter_closure</code>.
Let&#39;s try that with a function:</p>
<pre data-lang="rust"><code data-lang="rust"><span>let</span><span> hello = </span><span>&#34;Hello &#34;</span><span>;
</span><span>
</span><span>fn </span><span>greeter_function(x: </span><span>&amp;str</span><span>) -&gt; String {
</span><span>    String::new() + hello + x
</span><span>}
</span></code></pre>
<pre><code><span>error[E0434]: can&#39;t capture dynamic environment in a fn item
</span><span> --&gt; src/main.rs:7:25
</span><span>  |
</span><span>7 |         String::new() + hello + x
</span><span>  |                         ^^^^^
</span><span>  |
</span><span>  = help: use the `|| { ... }` closure form instead
</span></code></pre>
<p>This does not work and the compiler helpfully suggest to use a closure instead.</p>

<p>In the <code>greeter_closure</code> example above, the <code>hello</code> variable was captured by
shared reference because the variable is only read.
As shown below, we can still use that variable after the closure declaration and usage:</p>
<pre data-lang="rust"><code data-lang="rust"><span>let</span><span> hello = </span><span>&#34;Hello &#34;</span><span>;
</span><span>let </span><span>greeter_closure </span><span>= </span><span>|x| String::new() + hello + x;
</span><span>
</span><span>// We can still use the `hello` variable here
</span><span>assert_eq!(</span><span>&#34;Hello &#34;</span><span>, hello);
</span><span>
</span><span>assert_eq!(</span><span>&#34;Hello world&#34;</span><span>, greeter_closure(</span><span>&#34;world&#34;</span><span>));
</span><span>
</span><span>// And here
</span><span>assert_eq!(</span><span>&#34;Hello &#34;</span><span>, hello);
</span></code></pre>
<h2 id="capture-by-mutable-reference"><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=76889d80d2162747eb4a341123e4ba86">Capture by mutable reference</a></h2>
<p>It is also possible to capture by mutable reference so that the closure can alter
the value of the captured variable. See this naive way to compute the sum of
integers from 1 to 10:</p>
<pre data-lang="rust"><code data-lang="rust"><span>let mut</span><span> total = </span><span>0</span><span>;
</span><span>let </span><span>add_mut_closure </span><span>= </span><span>|x| total += x;
</span><span>
</span><span>// We can&#39;t access total here:
</span><span>// assert_eq!(0, total);
</span><span>// error[E0502]: cannot borrow `total` as immutable because it is also borrowed as mutable
</span><span>
</span><span>(</span><span>1</span><span>..</span><span>=</span><span>10</span><span>).for_each(add_mut_closure);
</span><span>
</span><span>// But we can access total here, now that `add_mut_closure` is out of scope.
</span><span>assert_eq!(</span><span>55</span><span>, total);
</span></code></pre>
<h2 id="capture-by-value"><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=b3237a395181972495dc9e4c68aa12cb">Capture by value</a></h2>
<p>Finally, one can capture by value:</p>
<pre data-lang="rust"><code data-lang="rust"><span>let</span><span> last_word = </span><span>&#34;last word: &#34;</span><span>.to_owned();
</span><span>let </span><span>drop_closure </span><span>= </span><span>|sigh| {
</span><span>    </span><span>let</span><span> res = String::new() + </span><span>&amp;</span><span>last_word + sigh;
</span><span>    drop(last_word); </span><span>// Forcing the capture by value
</span><span>    res
</span><span>};
</span><span>
</span><span>// We can&#39;t access `last_word` here:
</span><span>// assert_eq!(&#34;last word: &#34;.to_owned(), last_word);
</span><span>// error[E0382]: borrow of moved value: `last_word`
</span><span>
</span><span>assert_eq!(</span><span>&#34;last word: sigh!&#34;</span><span>, drop_closure(</span><span>&#34;sigh!&#34;</span><span>));
</span><span>
</span><span>// We can&#39;t access `last_word` here either
</span><span>// assert_eq!(&#34;last word: &#34;.to_owned(), last_word);
</span><span>// error[E0382]: borrow of moved value: `last_word`
</span><span>
</span><span>// And we can&#39;t call drop_closure again
</span><span>// assert_eq!(&#34;last word: sigh!&#34;, drop_closure(&#34;sigh!&#34;));
</span><span>// error[E0382]: use of moved value: `drop_closure`
</span></code></pre>

<p>In the previous example, notice the last error when trying to call <code>drop_closure</code> twice.
Here is the full error:</p>
<pre><code><span>error[E0382]: use of moved value: `drop_closure`
</span><span>  --&gt; src/main.rs:18:32
</span><span>   |
</span><span>12 | assert_eq!(&#34;last word: sigh!&#34;, drop_closure(&#34;sigh!&#34;));
</span><span>   |                                --------------------- `drop_closure` moved due to this call
</span><span>...
</span><span>18 | assert_eq!(&#34;last word: sigh!&#34;, drop_closure(&#34;sigh!&#34;));
</span><span>   |                                ^^^^^^^^^^^^ value used here after move
</span><span>   |
</span><span>note: closure cannot be invoked more than once because it moves the variable `last_word` out of its environment
</span><span>  --&gt; src/main.rs:5:10
</span><span>   |
</span><span> 5 |     drop(last_word);
</span><span>   |          ^^^^^^^^^
</span><span>note: this value implements `FnOnce`, which causes it to be moved when called
</span><span>  --&gt; src/main.rs:12:32
</span><span>   |
</span><span>12 | assert_eq!(&#34;last word: sigh!&#34;, drop_closure(&#34;sigh!&#34;));
</span><span>   |                                ^^^^^^^^^^^^
</span></code></pre>
<p>The interesting note is:</p>
<pre><code><span>note: this value implements `FnOnce`, which causes it to be moved when called
</span></code></pre>
<p>What is that <code>FnOnce</code> implementation the compiler is talking about?</p>
<p>It is a trait automatically implemented by the compiler which state that the closure can be called at least once.</p>
<p>That trait is a bit special because it cannot be implemented manually in stable rust.</p>
<p>Let&#39;s try to desugar the <code>drop_closure</code> above.</p>
<p>First, make sure to <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html#rustup-and-the-role-of-rust-nightly">switch to the nightly channel</a> and to enable
the following features (for example by putting them at the top of your <code>main.rs</code>):</p>
<pre data-lang="rust"><code data-lang="rust"><span>#![feature(fn_traits)]
</span><span>#![feature(unboxed_closures)]
</span></code></pre>
<p>Next, we need to define a struct having the captured variables as fields:</p>
<pre data-lang="rust"><code data-lang="rust"><span>struct </span><span>DropStruct {
</span><span>    last_word: String,
</span><span>}
</span></code></pre>
<p>Simple enough, we are capturing only one variable so our struct has one field.</p>
<p>Now the <code>FnOnce</code> implementation:</p>
<pre data-lang="rust"><code data-lang="rust"><span>impl </span><span>FnOnce&lt;(</span><span>&amp;str</span><span>,)&gt; </span><span>for </span><span>DropStruct {
</span><span>    </span><span>type </span><span>Output </span><span>= String;
</span><span>    </span><span>extern </span><span>&#34;rust-call&#34; </span><span>fn </span><span>call_once(self, (sigh,): (</span><span>&amp;str</span><span>,)) -&gt; </span><span>Self::</span><span>Output {
</span><span>        </span><span>let</span><span> res = String::new() + </span><span>&amp;</span><span>self.last_word + sigh;
</span><span>        drop(self.last_word);
</span><span>        res
</span><span>    }
</span><span>}
</span></code></pre>
<p>That is some weird trait!</p>
<p>Let&#39;s go step by step.</p>
<p><code>for DropStruct</code> should not be too surprising.</p>
<p><code>type Output = String</code> specifies that our closure returns a <code>String</code>.</p>
<p><code>extern &#34;rust-call&#34;</code> is some magic which I won&#39;t explain mostly because I don&#39;t know exactly why it is required.</p>
<p>The rest of the implementation should be self explanatory. We just took the content
of the closure and replaced <code>last_word</code> by <code>self.last_word</code>.</p>
<p>Let&#39;s try it:</p>
<pre data-lang="rust"><code data-lang="rust"><span>let</span><span> last_word = </span><span>&#34;last word: &#34;</span><span>.to_owned();
</span><span>let</span><span> drop_struct = DropStruct { last_word };
</span><span>
</span><span>// We could call `call_once`:
</span><span>// assert_eq!(&#34;last word: sigh!&#34;, drop_struct.call_once((&#34;sigh!&#34;,)));
</span><span>
</span><span>// But more simply, we can use the function call syntax:
</span><span>assert_eq!(</span><span>&#34;last word: sigh!&#34;</span><span>, drop_struct(</span><span>&#34;sigh!&#34;</span><span>));
</span><span>
</span><span>// And we still can&#39;t call it twice
</span><span>// assert_eq!(&#34;last word: sigh!&#34;, drop_struct(&#34;sigh!&#34;));
</span><span>// error[E0382]: use of moved value: `drop_struct`
</span></code></pre>

<p>What about our <code>add_mut_closure</code> from before? We were able to call it
multiple times and even mutate the capture variables.</p>
<p>That kind of closure implements the <code>FnMut</code> trait.</p>
<p>Let&#39;s try to desugar the following closure which push elements in a vector:</p>
<pre data-lang="rust"><code data-lang="rust"><span>let mut</span><span> v = vec![];
</span><span>let </span><span>push_closure </span><span>= </span><span>|x| v.push(x);
</span><span>
</span><span>(</span><span>1</span><span>..</span><span>=</span><span>5</span><span>).for_each(push_closure);
</span><span>assert_eq!(vec![</span><span>1</span><span>, </span><span>2</span><span>, </span><span>3</span><span>, </span><span>4</span><span>, </span><span>5</span><span>], v);
</span></code></pre>
<p>First we need to define a struct:</p>
<pre data-lang="rust"><code data-lang="rust"><span>struct </span><span>PusherStruct&lt;</span><span>&#39;a</span><span>&gt; {
</span><span>    v: </span><span>&amp;&#39;a mut </span><span>Vec&lt;</span><span>i32</span><span>&gt;,
</span><span>}
</span></code></pre>
<p>Because we are capturing by reference, we need to introduce a lifetime.</p>
<p>Now the <code>FnMut</code> implementation:</p>
<pre data-lang="rust"><code data-lang="rust"><span>impl</span><span>&lt;</span><span>&#39;a</span><span>&gt; FnMut&lt;(</span><span>i32</span><span>,)&gt; </span><span>for </span><span>PusherStruct&lt;</span><span>&#39;a</span><span>&gt; {
</span><span>    </span><span>extern </span><span>&#34;rust-call&#34; </span><span>fn </span><span>call_mut(</span><span>&amp;mut </span><span>self, (x,): (</span><span>i32</span><span>,)) -&gt; </span><span>Self::</span><span>Output {
</span><span>        self.v.push(x)
</span><span>    }
</span><span>}
</span></code></pre>
<p>It is very similar to the <code>FnOnce</code> trait except that the function is called <code>call_mut</code> instead of <code>call_once</code> and that it takes <code>&amp;mut self</code> instead of <code>self</code>.</p>
<p>Let&#39;s try to compile that:</p>
<pre><code><span>error[E0277]: expected a `FnOnce(i32)` closure, found `PusherStruct&lt;&#39;a&gt;`
</span><span> --&gt; src/main.rs:8:5
</span><span>  |
</span><span>8 |     extern &#34;rust-call&#34; fn call_mut(&amp;mut self, args: (i32,)) -&gt; Self::Output {
</span><span>  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected an `FnOnce(i32)` closure, found `PusherStruct&lt;&#39;a&gt;`
</span><span>  |
</span><span>help: the trait `FnOnce(i32)` is not implemented for `PusherStruct&lt;&#39;a&gt;`
</span></code></pre>
<p>Turns out we need to implement <code>FnOnce</code> too. Remember that <code>FnOnce</code> defines functions which can be called <strong>at least</strong> once.
In the example above, we called our closure 5 times, so it can definitely be called at least once.</p>
<p>Let&#39;s implement it:</p>
<pre data-lang="rust"><code data-lang="rust"><span>impl</span><span>&lt;</span><span>&#39;a</span><span>&gt; FnOnce&lt;(</span><span>i32</span><span>,)&gt; </span><span>for </span><span>PusherStruct&lt;</span><span>&#39;a</span><span>&gt; {
</span><span>    </span><span>type </span><span>Output </span><span>= ();
</span><span>    </span><span>extern </span><span>&#34;rust-call&#34; </span><span>fn </span><span>call_once(</span><span>mut </span><span>self, args: (i32,)) -&gt; </span><span>Self::</span><span>Output {
</span><span>        self.call_mut(args)
</span><span>    }
</span><span>}
</span></code></pre>
<p>Our closure does not return anything so the <code>Output</code> is the unit.</p>
<p>This should compile and we can now use it like so:</p>
<pre data-lang="rust"><code data-lang="rust"><span>let mut</span><span> v = vec![];
</span><span>let</span><span> pusher_struct = PusherStruct { v: </span><span>&amp;mut</span><span> v };
</span><span>
</span><span>(</span><span>1</span><span>..</span><span>=</span><span>5</span><span>).for_each(pusher_struct);
</span><span>assert_eq!(vec![</span><span>1</span><span>, </span><span>2</span><span>, </span><span>3</span><span>, </span><span>4</span><span>, </span><span>5</span><span>], v);
</span></code></pre>

<p>Finally, there is a third trait implemented by closures which can be called multiple times and don&#39;t need a mutable reference; the <a href="https://doc.rust-lang.org/std/ops/trait.Fn.html">Fn trait</a>.</p>
<p>To see that let&#39;s try to desugar the <code>greeter_closure</code> from before:</p>
<pre data-lang="rust"><code data-lang="rust"><span>let</span><span> hello = </span><span>&#34;Hello &#34;</span><span>;
</span><span>let </span><span>greeter_closure </span><span>= </span><span>|x| String::new() + hello + x;
</span><span>
</span><span>assert_eq!(</span><span>&#34;Hello world&#34;</span><span>, greeter_closure(</span><span>&#34;world&#34;</span><span>));
</span><span>assert_eq!(</span><span>&#34;Hello rust&#34;</span><span>, greeter_closure(</span><span>&#34;rust&#34;</span><span>)); </span><span>// Can be called multiple times
</span></code></pre>
<p>As usual, we need to define our struct:</p>
<pre data-lang="rust"><code data-lang="rust"><span>struct </span><span>GreeterStruct&lt;</span><span>&#39;a</span><span>&gt; {
</span><span>    hello: </span><span>&amp;&#39;a str</span><span>,
</span><span>}
</span></code></pre>
<p>Let&#39;s not make the same mistake as before, and remember to implement <code>FnOnce</code> and <code>FnMut</code> first. The same way an <code>FnMut</code> closures are also <code>FnOnce</code> because they can be called <strong>at least</strong> once. <code>Fn</code> closures are also <code>FnMut</code> because if given a mutable reference, they can still perform their work which does not mutate the reference.</p>
<pre data-lang="rust"><code data-lang="rust"><span>impl</span><span>&lt;</span><span>&#39;a</span><span>, </span><span>&#39;b</span><span>&gt; FnOnce&lt;(</span><span>&amp;&#39;b str</span><span>,)&gt; </span><span>for </span><span>GreeterStruct&lt;</span><span>&#39;a</span><span>&gt; {
</span><span>    </span><span>type </span><span>Output </span><span>= String;
</span><span>    </span><span>extern </span><span>&#34;rust-call&#34; </span><span>fn </span><span>call_once(self, args: (&amp;&#39;b str,)) -&gt; </span><span>Self::</span><span>Output {
</span><span>        self.call(args)
</span><span>    }
</span><span>}
</span><span>
</span><span>impl</span><span>&lt;</span><span>&#39;a</span><span>, </span><span>&#39;b</span><span>&gt; FnMut&lt;(</span><span>&amp;&#39;b str</span><span>,)&gt; </span><span>for </span><span>GreeterStruct&lt;</span><span>&#39;a</span><span>&gt; {
</span><span>    </span><span>extern </span><span>&#34;rust-call&#34; </span><span>fn </span><span>call_mut(</span><span>&amp;mut </span><span>self, args: (&amp;&#39;b str,)) -&gt; </span><span>Self::</span><span>Output {
</span><span>        self.call(args)
</span><span>    }
</span><span>}
</span></code></pre>
<p>This should be pretty straightforward. <code>call_once</code> and <code>call_mut</code> are just calling <code>call</code> which is defined in <code>Fn</code>:</p>
<pre data-lang="rust"><code data-lang="rust"><span>impl</span><span>&lt;</span><span>&#39;a</span><span>, </span><span>&#39;b</span><span>&gt; Fn&lt;(</span><span>&amp;&#39;b str</span><span>,)&gt; </span><span>for </span><span>GreeterStruct&lt;</span><span>&#39;b</span><span>&gt; {
</span><span>    </span><span>extern </span><span>&#34;rust-call&#34; </span><span>fn </span><span>call(</span><span>&amp;</span><span>self, (x,): (</span><span>&amp;&#39;b str</span><span>,)) -&gt; </span><span>Self::</span><span>Output {
</span><span>        String::new() + </span><span>&amp;</span><span>self.hello + </span><span>&amp;</span><span>x
</span><span>    }
</span><span>}
</span></code></pre>
<p>And we can use it like this:</p>
<pre data-lang="rust"><code data-lang="rust"><span>let</span><span> hello = </span><span>&#34;Hello&#34;</span><span>;
</span><span>let</span><span> greeter_struct = GreeterStruct {
</span><span>    hello,
</span><span>};
</span><span>
</span><span>assert_eq!(</span><span>&#34;Hello world&#34;</span><span>, greeter_struct(</span><span>&#34;world&#34;</span><span>));
</span><span>assert_eq!(</span><span>&#34;Hello rust&#34;</span><span>, greeter_struct(</span><span>&#34;rust&#34;</span><span>)); </span><span>// Can be called multiple times
</span></code></pre>

<p>You may already know that one can add the <code>move</code> keyword in front of a closure to force the closure to take ownership of the capture variables even if the closure only need a reference to it.</p>
<pre data-lang="rust"><code data-lang="rust"><span>let</span><span> hello = </span><span>&#34;Hello &#34;</span><span>.to_owned();
</span><span>let</span><span> greeter_closure = </span><span>move |</span><span>x</span><span>| </span><span>String::new() + </span><span>&amp;</span><span>hello + x;
</span><span>
</span><span>// We can&#39;t access `hello` here
</span><span>// assert_eq!(&#34;Hello &#34;, hello);
</span><span>// error[E0382]: borrow of moved value: `hello`
</span><span>
</span><span>assert_eq!(</span><span>&#34;Hello world&#34;</span><span>, greeter_closure(</span><span>&#34;world&#34;</span><span>));
</span><span>
</span><span>// Nor here
</span><span>// assert_eq!(&#34;Hello &#34;, hello);
</span><span>// error[E0382]: borrow of moved value: `hello`
</span></code></pre>
<p>In order to clearly understand what we can do depending on whether the closure needs a shared reference, a mutable reference or a value and if there is <code>move</code> keyword or not, let&#39;s introduce those small dummy functions:</p>
<pre data-lang="rust"><code data-lang="rust"><span>fn </span><span>by_ref(_data: </span><span>&amp;</span><span>String) {}
</span><span>
</span><span>fn </span><span>by_mut(_data: </span><span>&amp;mut</span><span> String) {}
</span><span>
</span><span>fn </span><span>by_value(_data: String) {}
</span></code></pre>
<p>Now, let&#39;s see what we can do with different combination of move / not move and by_ref / by_mut / by_value:</p>
<pre data-lang="rust"><code data-lang="rust"><span>let</span><span> data = </span><span>&#34;by_ref&#34;</span><span>.to_owned();
</span><span>let </span><span>by_ref_closure </span><span>= </span><span>|| by_ref(</span><span>&amp;</span><span>data);
</span><span>
</span><span>// Access data while the closure is still in scope
</span><span>assert_eq!(</span><span>&#34;by_ref&#34;</span><span>, data);
</span><span>
</span><span>// Call the closure once
</span><span>by_ref_closure();
</span><span>
</span><span>// Call the closure multiple times
</span><span>by_ref_closure();
</span><span>
</span><span>// Access data once the closure is out of scope
</span><span>assert_eq!(</span><span>&#34;by_ref&#34;</span><span>, data);
</span></code></pre>
<p>Now with move:</p>
<pre data-lang="rust"><code data-lang="rust"><span>let</span><span> data = </span><span>&#34;move_by_ref&#34;</span><span>.to_owned();
</span><span>let</span><span> move_by_ref_closure = </span><span>move || </span><span>by_ref(</span><span>&amp;</span><span>data);
</span><span>
</span><span>// Access data while the closure is still in scope
</span><span>// assert_eq!(&#34;move_by_ref&#34;, data);
</span><span>// error[E0382]: borrow of moved value: `data`
</span><span>
</span><span>// Call the closure once
</span><span>move_by_ref_closure();
</span><span>
</span><span>// Call the closure multiple times
</span><span>move_by_ref_closure();
</span><span>
</span><span>// Access data once the closure is out of scope
</span><span>// assert_eq!(&#34;move_by_ref&#34;, data);
</span><span>// error[E0382]: borrow of moved value: `data`
</span></code></pre>
<p>This makes sense, since the closure took ownership of <code>data</code> we can&#39;t access it anymore from outside.</p>
<p>Similarly we can define the following closures:</p>
<pre data-lang="rust"><code data-lang="rust"><span>let mut</span><span> data = </span><span>&#34;by_mut&#34;</span><span>.to_owned();
</span><span>let </span><span>by_mut_closure </span><span>= </span><span>|| by_mut(</span><span>&amp;mut</span><span> data);
</span><span>
</span><span>let mut</span><span> data = </span><span>&#34;move_by_mut&#34;</span><span>.to_owned();
</span><span>let</span><span> move_by_mut_closure = </span><span>move || </span><span>by_mut(</span><span>&amp;mut</span><span> data);
</span><span>
</span><span>let</span><span> data = </span><span>&#34;by_value&#34;</span><span>.to_owned();
</span><span>let </span><span>by_value_closure </span><span>= </span><span>|| by_value(data);
</span><span>
</span><span>let</span><span> data = </span><span>&#34;move_by_value&#34;</span><span>.to_owned();
</span><span>let</span><span> move_by_value_closure = </span><span>move || </span><span>by_value(data);
</span></code></pre>
<p>I will let you play with them, here what you should see:</p>
<table>
    <thead>
        <tr>
            <th></th>
            <th>by_ref</th>
            <th>by_mut</th>
            <th>by_value</th>
            <th>move by_ref</th>
            <th>move by_mut</th>
            <th>move by_value</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <th scope="row">Access when in scope</th>
            <td>✅</td>
            <td>❌</td>
            <td>❌</td>
            <td>❌</td>
            <td>❌</td>
            <td>❌</td>
        </tr>
        <tr>
            <th scope="row">Call once</th>
            <td>✅</td>
            <td>✅</td>
            <td>✅</td>
            <td>✅</td>
            <td>✅</td>
            <td>✅</td>
        </tr>
        <tr>
            <th scope="row">Call multiple times</th>
            <td>✅</td>
            <td>✅</td>
            <td>❌</td>
            <td>✅</td>
            <td>✅</td>
            <td>❌</td>
        </tr>
        <tr>
            <th scope="row">Access when out of scope</th>
            <td>✅</td>
            <td>✅</td>
            <td>❌</td>
            <td>❌</td>
            <td>❌</td>
            <td>❌</td>
        </tr>
    </tbody>
</table>
<p>And the trait implemented by each closures:</p>
<table>
    <thead>
        <tr>
            <th></th>
            <th>by_ref</th>
            <th>by_mut</th>
            <th>by_value</th>
            <th>move by_ref</th>
            <th>move by_mut</th>
            <th>move by_value</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <th scope="row">FnOnce</th>
            <td>✅</td>
            <td>✅</td>
            <td>✅</td>
            <td>✅</td>
            <td>✅</td>
            <td>✅</td>
        </tr>
        <tr>
            <th scope="row">FnMut</th>
            <td>✅</td>
            <td>✅</td>
            <td>❌</td>
            <td>✅</td>
            <td>✅</td>
            <td>❌</td>
        </tr>
        <tr>
            <th scope="row">Fn</th>
            <td>✅</td>
            <td>❌</td>
            <td>❌</td>
            <td>✅</td>
            <td>❌</td>
            <td>❌</td>
        </tr>
    </tbody>
</table>
<p>We can see that the <code>move</code> keyword has no impact on the implemented trait. It only changes the capture to be from reference to value.</p>
<p>For example, the desugaring of <code>by_ref_closure</code> is:</p>
<pre data-lang="rust"><code data-lang="rust"><span>struct </span><span>ByRefStruct&lt;</span><span>&#39;a</span><span>&gt; {
</span><span>    data: </span><span>&amp;&#39;a</span><span> String,
</span><span>}
</span><span>
</span><span>impl</span><span>&lt;</span><span>&#39;a</span><span>&gt; FnOnce&lt;()&gt; </span><span>for </span><span>ByRefStruct&lt;</span><span>&#39;a</span><span>&gt; {
</span><span>    </span><span>type </span><span>Output </span><span>= ();
</span><span>    </span><span>extern </span><span>&#34;rust-call&#34; </span><span>fn </span><span>call_once(self, args: ()) -&gt; </span><span>Self::</span><span>Output {
</span><span>        self.call(args)
</span><span>    }
</span><span>}
</span><span>
</span><span>impl</span><span>&lt;</span><span>&#39;a</span><span>&gt; FnMut&lt;()&gt; </span><span>for </span><span>ByRefStruct&lt;</span><span>&#39;a</span><span>&gt; {
</span><span>    </span><span>extern </span><span>&#34;rust-call&#34; </span><span>fn </span><span>call_mut(</span><span>&amp;mut </span><span>self, args: ()) -&gt; </span><span>Self::</span><span>Output {
</span><span>        self.call(args)
</span><span>    }
</span><span>}
</span><span>
</span><span>impl</span><span>&lt;</span><span>&#39;a</span><span>&gt; Fn&lt;()&gt; </span><span>for </span><span>ByRefStruct&lt;</span><span>&#39;a</span><span>&gt; {
</span><span>    </span><span>extern </span><span>&#34;rust-call&#34; </span><span>fn </span><span>call(</span><span>&amp;</span><span>self, (): ()) -&gt; </span><span>Self::</span><span>Output {
</span><span>        by_ref(self.data)
</span><span>    }
</span><span>}
</span></code></pre>
<p>whereas for <code>move_by_ref_closure</code>:</p>
<pre data-lang="rust"><code data-lang="rust"><span>struct </span><span>MoveByRefStruct {
</span><span>    data: String,
</span><span>}
</span><span>
</span><span>impl </span><span>FnOnce&lt;()&gt; </span><span>for </span><span>MoveByRefStruct {
</span><span>    </span><span>type </span><span>Output </span><span>= ();
</span><span>    </span><span>extern </span><span>&#34;rust-call&#34; </span><span>fn </span><span>call_once(self, args: ()) -&gt; </span><span>Self::</span><span>Output {
</span><span>        self.call(args)
</span><span>    }
</span><span>}
</span><span>
</span><span>impl </span><span>FnMut&lt;()&gt; </span><span>for </span><span>MoveByRefStruct {
</span><span>    </span><span>extern </span><span>&#34;rust-call&#34; </span><span>fn </span><span>call_mut(</span><span>&amp;mut </span><span>self, args: ()) -&gt; </span><span>Self::</span><span>Output {
</span><span>        self.call(args)
</span><span>    }
</span><span>}
</span><span>
</span><span>impl </span><span>Fn&lt;()&gt; </span><span>for </span><span>MoveByRefStruct {
</span><span>    </span><span>extern </span><span>&#34;rust-call&#34; </span><span>fn </span><span>call(</span><span>&amp;</span><span>self, (): ()) -&gt; </span><span>Self::</span><span>Output {
</span><span>        by_ref(</span><span>&amp;</span><span>self.data)
</span><span>    }
</span><span>}
</span></code></pre>
<p>Notice how the <code>data</code> field changed from <code>&amp;&#39;a String</code> to <code>String</code> and the call to <code>by_ref</code> from <code>self.data</code> to <code>&amp;self.data</code> eventhough in the closure forms we had <code>by_ref(&amp;data)</code> in both cases.</p>
<p>So we now hopefully understand what the <code>move</code> keyword does but you might wonder why that can be useful? After all, the first table above shows that we only removed flexbility.</p>
<p>Spawning a thread:</p>
<pre data-lang="rust"><code data-lang="rust"><span>let</span><span> data = </span><span>&#34;by_ref&#34;</span><span>.to_owned();
</span><span>std::thread::spawn(|| by_ref(</span><span>&amp;</span><span>data)).join().unwrap();
</span></code></pre>
<p>Without <code>move</code>, we get the following compiler error which helpfully suggest adding <code>move</code>:</p>
<pre><code><span>error[E0373]: closure may outlive the current function, but it borrows `data`, which is owned by the current function
</span><span> --&gt; src/main.rs:9:20
</span><span>  |
</span><span>9 | std::thread::spawn(|| by_ref(&amp;data)).join().unwrap();
</span><span>  |                    ^^         ---- `data` is borrowed here
</span><span>  |                    |
</span><span>  |                    may outlive borrowed value `data`
</span><span>  |
</span><span>note: function requires argument type to outlive `&#39;static`
</span><span> --&gt; src/main.rs:9:1
</span><span>  |
</span><span>9 | std::thread::spawn(|| by_ref(&amp;data)).join().unwrap();
</span><span>  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span><span>help: to force the closure to take ownership of `data` (and any other referenced variables), use the `move` keyword
</span><span>  |
</span><span>9 | std::thread::spawn(move || by_ref(&amp;data)).join().unwrap();
</span><span>  |                    ++++
</span></code></pre>
<p>Creating a function returning a closure:</p>
<pre data-lang="rust"><code data-lang="rust"><span>fn </span><span>make_greeter(greeter: </span><span>&amp;str</span><span>) -&gt; impl Fn(</span><span>&amp;str</span><span>) -&gt; String {
</span><span>    </span><span>move |</span><span>name</span><span>| </span><span>format!(</span><span>&#34;</span><span>{greeter} {name}</span><span>&#34;</span><span>)
</span><span>}
</span><span>
</span><span>let</span><span> hello_greeter = make_greeter(</span><span>&#34;Hello&#34;</span><span>);
</span><span>let</span><span> hi_greeter = make_greeter(</span><span>&#34;Hi&#34;</span><span>);
</span><span>
</span><span>assert_eq!(hello_greeter(</span><span>&#34;rust&#34;</span><span>), </span><span>&#34;Hello rust&#34;</span><span>);
</span><span>assert_eq!(hi_greeter(</span><span>&#34;rust&#34;</span><span>), </span><span>&#34;Hi rust&#34;</span><span>);
</span></code></pre>
<p>Here too we need <code>move</code> otherwise we get the same borrow checker error.</p>

<p><del>Sigh</del></p>
<p>This article is long enough as is, so I am stopping here for now.
I plan to publish a follow up article for async closures later.
If you want to read more on the subject I recommend:</p>
<ol>
<li>The <a href="https://doc.rust-lang.org/book/ch13-01-closures.html">closure chapter in the rust book</a>.</li>
<li>The <a href="https://doc.rust-lang.org/reference/types/closure.html">closure chapter in the rust reference</a>.</li>
<li><a href="https://huonw.github.io/blog/2015/05/finding-closure-in-rust/">Finding Closure in Rust</a> by Huon Wilson.</li>
<li>The <a href="https://smallcultfollowing.com/babysteps/blog/2025/10/22/explicit-capture-clauses/">article from the baby steps blog about adding an explicit capture clause</a>.</li>
<li>The Rust Unstable book on <a href="https://doc.rust-lang.org/beta/unstable-book/library-features/fn-traits.html">fn_traits</a> and <a href="https://doc.rust-lang.org/beta/unstable-book/language-features/unboxed-closures.html">unboxed_closures</a>.</li>
</ol>
<p>And to discuss this article, you can head over to the <a href="https://news.ycombinator.com/item?id=46746266">Hacker News thread</a> or the <a href="https://www.reddit.com/r/rust/comments/1qluyre/understanding_rust_closures/">reddit thread</a>.</p>

  </div></div>
  </body>
</html>
