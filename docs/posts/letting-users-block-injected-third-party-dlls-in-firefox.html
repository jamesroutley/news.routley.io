<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hacks.mozilla.org/2023/03/letting-users-block-injected-third-party-dlls-in-firefox/">Original</a>
    <h1>Letting users block injected third-party DLLs in Firefox</h1>
    
    <div id="readability-page-1" class="page"><article role="article">
    <p>In Firefox 110, users now have the ability to <a href="https://support.mozilla.org/en-US/kb/identify-problems-third-party-modules-firefox-windows#w_block-modules-that-cause-firefox-to-crash">control which third-party DLLs are allowed to load into Firefox processes</a>.</p>
<p>Let’s talk about what this means and when it might be useful.</p>
<h2>What is third-party DLL injection?</h2>
<p>On Windows, third-party products have a variety of ways to inject their code into other running processes. This is done for a number of reasons; the most common is for antivirus software, but other uses include hardware drivers, screen readers, banking (in some countries) and, unfortunately, malware.</p>
<p>Having a DLL from a third-party product injected into a Firefox process is surprisingly common – according to our telemetry, over 70% of users on Windows have at least one such DLL! (to be clear, this means any DLL not digitally signed by Mozilla or part of the OS).</p>
<p>Most users are unaware when DLLs are injected into Firefox, as most of the time there’s no obvious indication this is happening, other than checking the <a href="https://support.mozilla.org/en-US/kb/identify-problems-third-party-modules-firefox-windows">about:third-party page</a>.</p>
<p>Unfortunately, having DLLs injected into Firefox can lead to performance, security, or stability problems. This is for a number of reasons:</p>
<ul>
<li aria-level="1">DLLs will often hook into internal Firefox functions, which are subject to change from release to release. We make no special effort to maintain the behavior of internal functions (of which there are thousands), so the publisher of the third-party product has to be diligent about testing with new versions of Firefox to avoid stability problems.</li>
<li aria-level="1">Firefox, being a web browser, loads and runs code from untrusted and potentially hostile websites. Knowing this, we go to a lot of effort to keep Firefox secure; see, for example, the <a href="https://hacks.mozilla.org/2021/05/introducing-firefox-new-site-isolation-security-architecture/">Site Isolation Security Architecture</a> and <a href="https://hacks.mozilla.org/2022/05/improved-process-isolation-in-firefox-100/">Improved Process Isolation</a>. Third-party products may not have the same focus on security.</li>
<li aria-level="1">We run an <a href="https://hacks.mozilla.org/2020/07/testing-firefox-more-efficiently-with-machine-learning/">extensive number of tests on Firefox</a>, and third-party products may not test to that extent since they’re probably not designed to work specifically with Firefox.</li>
</ul>
<p>Indeed, our data shows that just over 2% of <b>all</b> Firefox crash reports on Windows are in third-party code. This is despite the fact that Firefox already blocks a number of specific third-party DLLs that are known to cause a crash (see below for details).</p>
<p>This also undercounts crashes that are caused indirectly by third-party DLLs, since our metrics only look for third-party DLLs directly in the call stack. Additionally, third-party DLLs are a bit more likely to cause crashes at startup, which are much more serious for users.</p>
<p>Firefox has a <a href="https://www.mozilla.org/en-US/security/third-party-software-injection/">third-party injection policy</a>, and whenever possible we recommend third parties instead use <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions">extensions</a> to integrate into Firefox, as this is officially supported and much more stable.</p>
<h2>Why not block all DLL injection by default?</h2>
<p>For maximum stability and performance, Firefox could try to block all third-party DLLs from being injected into its processes. However, this would break some useful products like screen readers that users want to be able to use with Firefox. This would also be technically challenging and it would probably be impossible to block every third-party DLL, especially third-party products that run with higher privilege than Firefox.</p>
<p>Since 2010, Mozilla has had the ability to block specific third-party DLLs for all Windows users of Firefox. We do this only as a last resort, after trying to communicate with the vendor to get the underlying issue fixed, and we tailor it as tightly as we can to make Firefox users stop crashing. (We have the ability to only block specific versions of the DLL and only in specific Firefox processes where it’s causing problems). This is a helpful tool, but we only consider using it if a particular third-party DLL is causing lots of crashes such that it shows up on our list of top crashes in Firefox.</p>
<p>Even if we know a third-party DLL can cause a crash in Firefox, there are times when the functionality that the DLL provides is essential to the user, and the user would not want us to block the DLL on their behalf. If the user’s bank or government requires some software to access their accounts or file their taxes, we wouldn’t be doing them any favors by blocking it, even if blocking it would make Firefox more stable.</p>
<h2>Giving users the power to block injected DLLs</h2>
<p>With Firefox 110, users can block third-party DLLs from being loaded into Firefox. This can be done on the <a href="https://support.mozilla.org/en-US/kb/identify-problems-third-party-modules-firefox-windows">about:third-party page</a>, which already lists all loaded third-party modules. The about:third-party page also shows which third-party DLLs have been involved in previous Firefox crashes; along with the name of the publisher of the DLL, hopefully this will let users make an informed decision about whether or not to block a DLL. Here’s an example of a DLL that recently crashed Firefox; clicking the button with a dash on it will block it:</p>
<p><img decoding="async" src="https://hacks.mozilla.org/files/2023/03/aboutThirdParty-crasherFirefox-250x98.png" alt="Screenshot of the about:third-party page showing a module named &#34;CrashingInjectibleDll.dll&#34; with a yellow triangle indicating it has recently caused a crash, and a button with a dash on it that can be used to block it from loading into Firefox." width="482" height="189" srcset="https://hacks.mozilla.org/files/2023/03/aboutThirdParty-crasherFirefox-250x98.png 250w, https://hacks.mozilla.org/files/2023/03/aboutThirdParty-crasherFirefox-500x197.png 500w, https://hacks.mozilla.org/files/2023/03/aboutThirdParty-crasherFirefox-768x302.png 768w, https://hacks.mozilla.org/files/2023/03/aboutThirdParty-crasherFirefox.png 1475w" sizes="(max-width: 482px) 100vw, 482px"/></p>
<p>Here’s what it looks like after blocking the DLL and restarting Firefox:</p>
<p><img decoding="async" loading="lazy" src="https://hacks.mozilla.org/files/2023/03/aboutThirdParty-crasherBlockedFirefox-250x99.png" alt=" Screenshot of the about:third-party page showing a module named &#34;CrashingInjectibleDll.dll&#34; with a yellow triangle indicating it has recently caused a crash, and a red button with an X on it indicating that it is blocked from loading into Firefox." width="475" height="188" srcset="https://hacks.mozilla.org/files/2023/03/aboutThirdParty-crasherBlockedFirefox-250x99.png 250w, https://hacks.mozilla.org/files/2023/03/aboutThirdParty-crasherBlockedFirefox-500x197.png 500w, https://hacks.mozilla.org/files/2023/03/aboutThirdParty-crasherBlockedFirefox-768x303.png 768w, https://hacks.mozilla.org/files/2023/03/aboutThirdParty-crasherBlockedFirefox.png 1477w" sizes="(max-width: 475px) 100vw, 475px"/></p>
<p>If blocking a DLL causes a problem, launching Firefox in <a href="https://support.mozilla.org/en-US/kb/diagnose-firefox-issues-using-troubleshoot-mode">Troubleshoot Mode</a> will disable all third-party DLL blocking for that run of Firefox, and DLLs can be blocked or unblocked on the about:third-party page as usual.</p>
<h2>How it works</h2>
<p>Blocking DLLs from loading into a process is tricky business. In order to detect all DLLs loading into a Firefox process, the blocklist has to be set up very early during startup. For this purpose, we have the <a href="https://firefox-source-docs.mozilla.org/dom/ipc/process_model.html#launcher-process">launcher process</a>, which creates the main browser process in a suspended state. Then it sets up any sandboxing policies, loads the blocklist file from disk, and copies the entries into the browser process before starting that process.</p>
<p>The copying is done in an interesting way: the launcher process creates an OS-backed file mapping object with <a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-createfilemappingw"><code>CreateFileMapping()</code></a>, and, after populating that with blocklist entries, duplicates the handle and uses <a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory"><code>WriteProcessMemory()</code></a> to write that handle value into the browser process. Ironically, <code>WriteProcessMemory()</code> is often used as a way for third-party DLLs to inject themselves into other processes; here we’re using it to set a variable at a known location, since the launcher process and the browser process are run from the same .exe file!</p>
<p>Because everything happens so early during startup, well before the Firefox profile is loaded, the list of blocked DLLs is stored per Windows user instead of per Firefox profile. Specifically, the file is in <code>%AppData%\Mozilla\Firefox</code>, and the filename has the format <code>blocklist-{install hash}</code>, where the install hash is a <a href="https://github.com/google/cityhash">hash</a> of the location on disk of Firefox. This is an easy way of keeping the blocklist separate for different Firefox installations.</p>
<h3>Detecting and blocking DLLs from loading</h3>
<p>To detect when a DLL is trying to load, Firefox uses a technique known as function interception or hooking. This modifies an existing function in memory so another function can be called before the existing function begins to execute. This can be useful for many reasons; it allows changing the function’s behavior even if the function wasn’t designed to allow changes. <a href="https://github.com/microsoft/Detours">Microsoft Detours</a> is a tool commonly used to intercept functions.</p>
<p>In Firefox’s case, the function we’re interested in is <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-zwmapviewofsection"><code>NtMapViewOfSection()</code></a>, which gets called whenever a DLL loads. The goal is to get notified when this happens so we can check the blocklist and forbid a DLL from loading if it’s on the blocklist.</p>
<p>To do this, Firefox uses a <a href="https://searchfox.org/mozilla-central/source/toolkit/xre/dllservices/mozglue/nsWindowsDllInterceptor.h">homegrown function interceptor</a> to intercept calls to <code>NtMapViewOfSection()</code> and return that the mapping failed if the DLL is on the blocklist. To do this, the interceptor tries two different techniques:</p>
<ul>
<li aria-level="1">On the 32-bit x86 platform, <a href="https://devblogs.microsoft.com/oldnewthing/20110921-00/?p=9583">some functions exported from a DLL</a> will begin with a two-byte instruction that does nothing (<code>mov edi, edi</code>) and have five one-byte unused instructions before that. (either <code>nop</code> or <code>int 3</code>)  For example:
<pre>              nop
              nop
              nop
              nop
              nop
DLLFunction:  mov edi, edi
              (actual function code starts here)
</pre>
<p>If the interceptor <a href="https://searchfox.org/mozilla-central/source/toolkit/xre/dllservices/mozglue/interceptor/PatcherNopSpace.h#147">detects that this is the case</a>, it can replace the five bytes of unused instructions with a <code>jmp</code> to the address of the function to call instead. (since we’re on a 32-bit platform, we just need one byte to indicate a jump and four bytes for the address) So, this would look like</p>
<pre>             jmp &lt;address of Firefox patched function&gt;
DLLFunction: jmp $-5 # encodes in two bytes: EB F9
             (actual function code starts here)
</pre>
<p>When the patched function wants to call the unpatched version of <code>DLLFunction()</code>, it simply jumps 2 bytes past the address of <code>DLLFunction()</code> to start the actual function code.</p></li>
<li aria-level="1">Otherwise, things get a bit more complicated. Let’s consider the x64 case. The instructions to jump to our patched function require 13 bytes: 10 bytes for loading the address into a register, and 3 bytes to jump to that register’s location. So the interceptor needs to move at least the first 13 bytes worth of instructions, plus enough to finish the last instruction if needed, to a trampoline function. (it’s known as a trampoline because typically code jumps there, which causes a few instructions to run, and then jumps out to the rest of the target function). Let’s look at a real example. Here’s a simple function that we’re going to intercept, first the C source (<a href="https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:&#39;1&#39;,fontScale:14,fontUsePx:&#39;0&#39;,j:2,lang:c%2B%2B,selection:(endColumn:2,endLineNumber:8,positionColumn:1,positionLineNumber:3,selectionStartColumn:2,selectionStartLineNumber:8,startColumn:1,startLineNumber:3),source:&#39;%23include+%3Cstdio.h%3E%0A%0Aint+fn(int+aX,+int+aY)+%7B%0A++++if+(aX+%2B+1+%3E%3D+aY)+%7B%0A++++++++return+aX+*+3%3B%0A++++%7D%0A++++return+aY+%2B+5+-+aX%3B%0A%7D%0A&#39;),l:&#39;5&#39;,n:&#39;0&#39;,o:&#39;C%2B%2B+source+%232&#39;,t:&#39;0&#39;)),header:(),k:48.35219031041486,l:&#39;4&#39;,m:100,n:&#39;0&#39;,o:&#39;&#39;,s:0,t:&#39;0&#39;),(g:!((h:compiler,i:(compiler:clang1500,deviceViewOpen:&#39;1&#39;,filters:(b:&#39;0&#39;,binary:&#39;1&#39;,binaryObject:&#39;0&#39;,commentOnly:&#39;0&#39;,demangle:&#39;0&#39;,directives:&#39;0&#39;,execute:&#39;1&#39;,intel:&#39;0&#39;,libraryCode:&#39;0&#39;,trim:&#39;1&#39;),flagsViewOpen:&#39;1&#39;,fontScale:14,fontUsePx:&#39;0&#39;,j:2,lang:c%2B%2B,libs:!(),options:&#39;-O3&#39;,selection:(endColumn:16,endLineNumber:3,positionColumn:16,positionLineNumber:3,selectionStartColumn:16,selectionStartLineNumber:3,startColumn:16,startLineNumber:3),source:2),l:&#39;5&#39;,n:&#39;0&#39;,o:&#39;+x86-64+clang+15.0.0+(Editor+%232)&#39;,t:&#39;0&#39;)),header:(),k:51.64780968958515,l:&#39;4&#39;,m:100,n:&#39;0&#39;,o:&#39;&#39;,s:0,t:&#39;0&#39;)),l:&#39;2&#39;,n:&#39;0&#39;,o:&#39;&#39;,t:&#39;0&#39;)),version:4">Godbolt compiler explorer link</a>):
<pre>int fn(int aX, int aY) {
    if (aX + 1 &gt;= aY) {
        return aX * 3;
    }
    return aY + 5 - aX;
}
</pre>
<p>and the assembly, with corresponding raw instructions. Note that this was compiled with -O3, so it’s a little dense:</p>
<pre>fn(int,int):
   lea    eax,[rdi+0x1]   # 8d 47 01
   mov    ecx,esi         # 89 f1
   sub    ecx,edi         # 29 f9
   add    ecx,0x5         # 83 c1 05
   cmp    eax,esi         # 39 f0
   lea    eax,[rdi+rdi*2] # 8d 04 7f
   cmovl  eax,ecx         # 0f 4c c1
   ret                    # c3</pre>
<p>Now, counting 13 bytes from the beginning of <code>fn()</code> puts us in the middle of the <code>lea eax,[rdi+rdi*2]</code> instruction, so we’ll have to copy everything down to that point to the trampoline.</p>
<p>The end result looks like this:</p>
<pre>fn(int,int) (address 0x100000000):
   # overwritten code
   mov     r11, 0x600000000 # 49 bb 00 00 00 00 06 00 00 00
   jmp     r11              # 41 ff e3
   # leftover bytes from the last instruction
   # so the addresses of everything stays the same
   # We could also fill these with nop’s or int 3’s,
   # since they won’t be executed
   .byte 04
   .byte 7f
   # rest of fn() starts here
   cmovl  eax,ecx         # 0f 4c c1
   ret                    # c3
   

Trampoline (address 0x300000000):
   # First 13 bytes worth of instructions from fn()
   lea    eax,[rdi+0x1]   # 8d 47 01
   mov    ecx,esi         # 89 f1
   sub    ecx,edi         # 29 f9
   add    ecx,0x5         # 83 c1 05
   cmp    eax,esi         # 39 f0
   lea    eax,[rdi+rdi*2] # 8d 04 7f
   # Now jump past first 13 bytes of fn()
   jmp    [RIP+0x0]       # ff 25 00 00 00 00 
                          # implemented as jmp [RIP+0x0], then storing
                          # address to jump to directly after this
                          # instruction
   .qword 0x10000000f


Firefox patched function (address 0x600000000):
        &lt;whatever the patched function wants to do&gt;</pre>
<p>If the Firefox patched function wants to call the unpatched <code>fn()</code>, the patcher has stored the address of the trampoline (0x300000000 in this example). In C++ code we encapsulate this in the <a href="https://searchfox.org/mozilla-central/source/toolkit/xre/dllservices/mozglue/nsWindowsDllInterceptor.h#118"><code>FuncHook</code></a> class, and the patched function can just call the trampoline with the same syntax as a normal function call.</p>
<p>This whole setup is significantly more complicated than the first case; you can see that the <a href="https://searchfox.org/mozilla-central/source/toolkit/xre/dllservices/mozglue/interceptor/PatcherNopSpace.h">patcher for the first case</a> is only around 200 lines long while the <a href="https://searchfox.org/mozilla-central/source/toolkit/xre/dllservices/mozglue/interceptor/PatcherDetour.h">patcher that handles this case</a> is more than 1700 lines long! Some additional notes and complications:</p>
<ul>
<li aria-level="2">Not all instructions that get moved to the trampoline can necessarily stay exactly the same. One example is jumping to a relative address that didn’t get moved to the trampoline – since the instruction has moved in memory, the patcher needs to replace this with an absolute jump. The patcher doesn’t handle every kind of x64 instruction (otherwise it would have to be much longer!), but we have <a href="https://searchfox.org/mozilla-central/source/toolkit/xre/dllservices/tests/TestDllInterceptor.cpp">automated tests</a> to make sure we can successfully intercept the Windows functions that we know Firefox needs.</li>
<li aria-level="2">We specifically use r11 to load the address of the patched function into because according to the <a href="https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170">x64 calling convention</a>, r11 is a volatile register that is not required to be preserved by the callee.</li>
<li aria-level="2">Since we use <code>jmp</code> to get from <code>fn()</code> to the patched function instead of <code>ret</code>, and similarly to get from the trampoline back into the main code of <code>fn()</code>, this keeps the code stack-neutral. So calling other functions and returning from <code>fn()</code> all work correctly with respect to the position of the stack.</li>
<li aria-level="2">If there are any jumps from later in <code>fn()</code> into the first 13 bytes, these will now be jumping into the middle of the jump to the patched function and bad things will almost certainly happen. Luckily this is very rare; most functions are doing function prologue operations in their beginning, so this isn’t a problem for the functions that Firefox intercepts.</li>
<li aria-level="2">Similarly, in some cases <code>fn()</code> has some data stored in the first 13 bytes that are used by later instructions, and moving this data to the trampoline will result in the later instructions getting the wrong data. We have <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1489391">run into this</a>, and can work around it by using a shorter <code>mov</code> instruction if we can allocate space for a trampoline that’s within the first 2 GB of address space. This results in a 10 byte patch instead of a 13 byte patch, which in many cases is good enough to avoid problems.</li>
<li aria-level="2">Some other complications to quickly mention (not an exhaustive list!):
<ul>
<li aria-level="3">Firefox also has a way to do this interception across processes. Fun!</li>
<li aria-level="3">Trampolines are tricky for the <a href="https://learn.microsoft.com/en-us/windows/win32/secbp/control-flow-guard">Control Flow Guard</a> security measure: since they are legitimate indirect call targets that do not exist at compile time, it requires special care to allow Firefox patched functions to call into them.</li>
<li aria-level="3">Trampolines also involve some more fixing up for exception handling, as we must provide <a href="https://learn.microsoft.com/en-us/cpp/build/exception-handling-x64?view=msvc-170">unwind info</a> for them.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>If the DLL is on the blocklist, our patched version of <code>NtMapViewOfSection()</code> will return that the mapping fails, which causes the whole DLL load to fail. This will not work to block every kind of injection, but it does block most of them.</p>
<p>One added complication is that some DLLs will inject themselves by modifying firefox.exe’s <a href="https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#import-address-table">Import Address Table</a>, which is a list of external functions that firefox.exe calls into. If one of these functions fails to load, Windows will terminate the Firefox process. So if Firefox detects this sort of injection and wants to block the DLL, we will instead redirect the DLL’s <code>DllMain()</code> to a function that does nothing.</p>
<h2>Final words</h2>
<p>Principle 4 of the <a href="https://www.mozilla.org/en-US/about/manifesto/">Mozilla Manifesto</a> states that “Individuals’ security and privacy on the internet are fundamental and must not be treated as optional”, and we hope that this will give Firefox users the power to access the internet with more confidence. Instead of having to choose between uninstalling a useful third-party product and having stability problems with Firefox, now users have a third option of leaving the third-party product installed and blocking it from injecting into Firefox!</p>
<p>As this is a new feature, if you have problems with blocking third-party DLLs, please file <a href="https://bugzilla.mozilla.org/enter_bug.cgi?product=Core&amp;component=DLL%20Services">a bug</a>. If you have issues with a third-party product causing problems in Firefox, please don’t forget to file an issue with the vendor of that product – since you’re the user of that product, any report the vendor gets means more coming from you than it does coming from us!</p>
<h2>More information</h2>
<ul>
<li aria-level="1"><a href="https://firefox-source-docs.mozilla.org/widget/windows/blocklist.html">Technical documentation about DLL blocklisting</a></li>
<li aria-level="1"><a href="https://marco-c.github.io/publications/dll_injection-emse2019.pdf">An Empirical Study of DLL Injection Bugs in the Firefox Ecosystem</a> (.pdf)</li>
</ul>
<p>Special thanks to David Parks and Yannis Juglaret for reading and providing feedback on many drafts of this post and Toshihito Kikuchi for the initial prototype of the dynamic blocklist.</p>
    <section>
                                
                                <p><a href="https://hacks.mozilla.org/author/gstollmozilla-com/">More articles by Greg Stoll…</a></p>
                  </section>
  </article></div>
  </body>
</html>
