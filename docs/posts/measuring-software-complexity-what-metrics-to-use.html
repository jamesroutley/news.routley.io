<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://thevaluable.dev/complexity-metrics-software/">Original</a>
    
    <div id="readability-page-1" class="page"><div role="main"><article><section><picture>
<source srcset="https://thevaluable.dev/images/2021/measuring_complexity/complexity.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2021/measuring_complexity/complexity.jpg" alt="Should we rebuild everything too complex?"/></picture><p>“This part of the codebase doesn’t <em>feel</em> right!”</p><p>This was Dave, your colleague developer, arguing in another never-ending meeting to rewrite a part of your company’s codebase. His arguments? Technical debt, <a href="https://thevaluable.dev/fighting-software-entropy/" target="_blank" rel="noopener">high entropy</a>, and the fear of the <a href="https://thevaluable.dev/legacy-systems-software-code/" target="_blank" rel="noopener">legacy system</a>.</p><p>Our work, as developers, pushes us to take many decisions, from the architectural design to the code implementation. How do we make these decisions? Most of the time, we follow what “feel right”, that is, we rely on our intuition. It comes from our experience, an important source of information.
But the same intuition can the source of many problems too. We’re humans, and we are subjects to <a href="https://thevaluable.dev/cognitive-bias-software-development/" target="_blank" rel="noopener">many biases</a> leading to wrong assumptions.</p><p>That’s why, to take important decisions, like rewriting a whole chunk of a codebase, we need more <em>unbiased information</em>. Measuring complexity can bring the information we need to be sure we’re headed in the good direction. That’s the subject of this article: how do we measure this complexity? More precisely, we’ll see:</p><ul><li>How complexity metrics can be complementary to experience and experimentation.</li><li>What we’re aiming for when we’re measuring complexity.</li><li>What are the most common complexity metrics out there and their limitations.</li></ul><p>The goal of the article is to give you a broad introduction of the different complexity metrics you can use. As a result, I’m aiming for a general overview without going into too many details.</p><p>I’ll speak mostly about <em>modules</em> here, which can be seen as units of code. A function, a class, an object, a package, a service (or microservice) can be a module.</p><p>This article is also the first of a series about measuring complexity. In the following articles, we’ll see more concrete examples how to combine these metrics to get the information we want.</p><p>Now, prepare your favorite beverage, get your measuring tools, and let’s go!</p><h2 id="ask-your-questions-first">Ask Your Questions First</h2><p>All sort of data is widely available in our information-driven world. We can look at dashboards full of trendy metrics for everything and anything, all day long, if we want to. It seems that, with these metrics, we search something, but we’re often not really sure <em>what</em>. Maybe the pleasure to see that the cyclomatic complexity of our codebase is low? The thrill to see that more and more people are coming visiting our landing page?</p><p>Looking at metrics without having any question in mind is like searching in a massive haystack to see if there are some needles, somewhere, even if in reality we need plastic ducks. Instead, we should define the problems we want to solve, and only then try to find the information we need to solve them. In short, metrics should be used mainly to <em>inform our decisions</em>.</p><p>We, as beautiful humans, are very sensible to numbers. We like when they go up. It gives us a good feeling of accomplishment, even if the metrics doesn’t provide us useful information for making decisions. These metrics are commonly called <em>vanity metrics</em>. It’s very easy to fall in this trap; that’s another reason why it’s important to explore the problem space first, before deciding what metrics to look at.</p><p>So let’s ask: by measuring complexity in our codebase, what problem do we try to solve? Two things, mainly:</p><ol><li>Finding the complex parts of our codebase to make the code easier to understand and reason about.</li><li>Preventing the codebase to have new bugs.</li></ol><p>The first point is important: our brain didn’t evolve to create an accurate mental model of a codebase with hundreds of different states, processes, and loopholes. According to the <a href="https://www.cese.nsw.gov.au/images/stories/PDF/cognitive-load-theory-VR_AA3.pdf" target="_blank" rel="noopener">cognitive load theory</a>, our working memory can’t retain many pieces of information at once. That’s why reducing the complexity of our systems is essential.</p><p>According, to <a href="https://www.researchgate.net/profile/Norman-Fenton/publication/3188104_Ohlsson_N_Quantitative_analysis_of_faults_and_failures_in_a_complex_software_system_IEEE_Trans_Softw_Eng_268_797-814/links/0046351b05e69b04d6000000/Ohlsson-N-Quantitative-analysis-of-faults-and-failures-in-a-complex-software-system-IEEE-Trans-Softw-Eng-268-797-814.pdf" target="_blank" rel="noopener">this study</a> the defects in a codebase obey the <a href="https://en.wikipedia.org/wiki/Pareto_principle" target="_blank" rel="noopener">Pareto principle</a>; that is, most defects (80% to 100% of them) are often popping up from a few modules (10% to 20% of the codebase). Measuring the complexity of a codebase can help us isolate these problematic modules.</p><p>The second point is not easier to achieve. Predicting the future evolution of complex systems is far from being a solved problem. As such, the goal is not to acquire absolute certainty about the modules which could bring horrible bugs, but <em>to reduce this uncertainty</em>.</p><h2 id="reducing-the-uncertainty">Reducing the Uncertainty</h2><p><a href="https://thevaluable.dev/images/2021/measuring_complexity/reducing_uncertainty.jpg"><picture>
<source srcset="https://thevaluable.dev/images/2021/measuring_complexity/reducing_uncertainty.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2021/measuring_complexity/reducing_uncertainty.jpg" alt="Measuring is not to be 100% certain but to reduce uncertainty"/></picture></a></p><h3 id="measuring">Measuring</h3><p>The definition of measuring from the book <a href="https://www.goodreads.com/book/show/444653.How_to_Measure_Anything" target="_blank" rel="noopener">How to Measure Anything</a> is on point:</p><blockquote><p>A quantitively expressed reduction of uncertainty based on one or more observations.</p></blockquote><p>We often think of measuring as an action providing certainty, but it’s not the case. You can find certainty in the abstract world of Mathematics but, in our world, nothing is certain. Said differently, we don’t need perfect formulas, but imperfect <a href="https://en.wikipedia.org/wiki/Heuristic" target="_blank" rel="noopener">heuristics</a> to get the information we need. The goal is to get some clues about what to do next: what part of the codebase we need to refactor or, at least, to monitor more closely for future bugs.</p><p>Research about measuring complexity in codebases is ongoing since the 70s. It’s not a solved problem either. That’s partly why measuring is useful to isolate problematic code, but not enough to know what to do with it. We need to also use some past information we acquired through our own experience, the experience of others, past measurements, possibly past experimentations.</p><blockquote><p>The difficulty is, of course, that the ‘real world’ is not entirely formal, in the sense that we cannot model it with precise mathematical relationships. The best we can hope for is engineering approximations.</p></blockquote><h3 id="experimenting">Experimenting</h3><p>Another way to acquire more information and reduce our uncertainty is by experimenting. I advocate experimentation strongly in many articles in this blog, because it can give us immediate feedback on what work and what doesn’t. It can show us the wrong assumptions and cognitive biases we have.</p><p>Sometimes, experimenting doesn’t give us more information. It might be seen as a waste of time. But it’s also the most efficient way to see quickly if we’re heading in the good direction.</p><p>Experimenting can be trying something new you didn’t try before, like creating a small system to verify some assumptions. Don’t hesitate to throw the system away if it’s not useful anymore. We’re searching information here, we’re not trying to write the next unicorn.</p><h3 id="using-our-experience">Using Our Experience</h3><p>Our Experience can also be used to complete the lack of information we have and to reduce the uncertainty even further. If our reasoning was good enough, and our remembering not too fuzzy, it can help to take the good decisions.</p><p>This is an important piece of the puzzle of the decision process. Be careful with it, however: again, we’ve <a href="https://thevaluable.dev/cognitive-bias-software-development/" target="_blank" rel="noopener">many biases</a>. If we don’t keep in mind that our brain likes to take shortcuts, we might end up on the wrong reasoning path.</p><p>It’s also useful to keep in mind that your experience is not necessarily better than the other’s.</p><h2 id="measuring-complexity-with-code-metrics">Measuring Complexity With Code Metrics</h2><p>Let’s look now at the popular metrics used to measure complexity in our codebases and their limits.</p><h3 id="the-halstead-metrics">The Halstead Metrics</h3><p>If you search about code metrics, you’ll stumble on the Halstead Metrics. Even if they’re not always explicitly used in your favorite static analysis tools, they’re often used under the hood to calculate some sort of “maintainability index” or “complexity index”.</p><p>These metrics were invented in 1977 by Maurice Halstead, at a time when almost everything was procedural. Codebases were often written in COBOL in a couple of files. Functions (or, more precisely, procedures) were the main constructs used for <a href="https://thevaluable.dev/abstraction-type-software-example/" target="_blank" rel="noopener">abstraction</a>.</p><p>A codebase, for Halstead, was a sequence of two types of tokens: operators and operands. All his metrics are based on this simple idea. For example, in the operation <code>1 + 2</code>, <code>1</code> and <code>2</code> are operands, <code>+</code> is an operator.</p><p>From there, we can calculate the following metrics for a specific module:</p><ul><li>Length - Number of operators and operands</li><li>Vocabulary - Number of unique operators and unique operands</li><li>Difficulty - (unique operators / 2) * (operands / unique operands)</li></ul><p>These metrics are the bases for others, more meaningful ones:</p><ul><li>Halstead Volume - How much information the reader has to absorb to understand the code.</li><li>Halstead Effort - Amount of effort to rewrite a codebase (excluded all the work related, like understanding specifications).</li><li>Halstead Bugs - How many bugs there are in the system.</li><li>Halstead Time - How much time is needed to rewrite a codebase. This one is heavily criticized and never used in practice.</li></ul><p>Don’t take these metrics at face value. They’re not the best ones to measure complexity in my experience, mainly because it’s hard to find out what are the operators and operands in modern languages. Take the following code:</p><div><pre><code data-lang="php"><span>&lt;?php</span> <span>declare</span><span>(</span><span>strict_types</span><span>=</span><span>1</span><span>);</span>

<span>class</span> <span>Parser</span>
<span>{</span>
    <span>public</span> <span>function</span> <span>count</span><span>(</span><span>string</span> <span>$filepath</span><span>)</span> <span>{</span>
        <span>printf</span><span>(</span><span>&#34;I&#39;m counting lines of %s pretty hard!&#34;</span><span>,</span> <span>$filepath</span><span>);</span>
    <span>}</span>
<span>}</span>
</code></pre></div><p>What’s the token <code>;</code>? An operator? An operand? It has semantics, and therefore should contribute to the amount of information a reader has to absorb, for example. What about the token <code>&lt;?php</code>? <code>class</code>?</p><p>Halstead stays vague on the subject. According to him, the distinction between operators and operands should be “intuitively obvious”. This is surprising: as we saw, we shouldn’t use our intuition when we begin to measure something. The goal is to have unbiased information.</p><p>Because of this ambiguity, static analysis tools count these tokens in different ways. You can have two different results on the same codebase for the same metrics, depending on the tools you’re using.</p><p>That’s not all. The <em>interpretation</em> of the different results are often different from one tool to another, too. For some, the Halstead Length is a measure of complexity, for others it’s just the number of operators and operands.</p><p>I also wonder if there is more information emerging from the <em>combination</em> of these operators and operands, information which doesn’t appear when we only count the different tokens of the codebase. For example, a system “A” with 10 classes hardly coupled is not the same as system “B” with 10 independent classes. Yet, there are the same number of classes in both systems.</p><p>At the end, be wary when you see some complexity metrics using the Halstead metrics. They can indicate possible problems in a codebase, but, due to their limitations, further inspections is often necessary. Personally, I don’t rely on them at all.</p><h3 id="the-cyclomatic-complexity">The Cyclomatic Complexity</h3><p>Ah! The mythical cyclomatic complexity. You’ll see this one in every static analysis tool you can imagine.</p><p>It was developed by Thomas McCabe and popularized in 1976 thanks to the paper <a href="http://www.literateprogramming.com/mccabe.pdf" target="_blank" rel="noopener">A Complexity Measure</a>. McCabe’s goal was to propose a metric for complexity using the control graph flow of a module.</p><p>At that time, complexity was often measured by counting the lines of code (LOC). McCabe wanted to create something more accurate to replace this metric. The main goal was to inform when to modularize a piece of a system, for the resulting modules to be more maintainable and testable.</p><p>To understand how it works, let’s take this example:</p><div><pre><code data-lang="php"><span>&lt;?php</span>

<span>class</span> <span>Cyclo</span>
<span>{</span>
    <span>public</span> <span>function</span> <span>cyclo</span><span>()</span>
    <span>{</span>
        <span>for</span> <span>(</span><span>$i</span> <span>=</span> <span>0</span><span>;</span> <span>$i</span> <span>&lt;</span> <span>10</span><span>;</span> <span>$i</span><span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span><span>$i</span> <span>==</span> <span>2</span> <span>||</span> <span>$i</span> <span>==</span> <span>4</span><span>)</span> <span>{</span>
                <span>echo</span> <span>&#39;Hello!&#39;</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                <span>echo</span> <span>&#39;Bye!&#39;</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>echo</span> <span>&#39;this is the end&#39;</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><p>To find out the cyclomatic complexity of our method <code>cyclo</code>, we would need to draw its control flow graph, count the edges and the nodes, and use a formula to get your result. In short, to know how many branches we need to test, we count the possible paths the program can take at runtime.</p><p>But there’s an easier way:</p><ol><li>Count the number of branch points in the code (<code>if</code>, <code>while</code>, <code>for</code>, and boolean operators like <code>&amp;&amp;</code> or <code>||</code>).</li><li>Add 1.</li></ol><p>What are the branch points in this example?</p><ol><li>The <code>for</code> loop</li><li><code>$i == 2</code></li><li><code>$i == 4</code></li></ol><p>Add one to that and you get the fantastic cyclomatic complexity of 4. Wonderful. A question remain, however: what result do we need for our code to be considered <em>too</em> complex? According to McCabe, the “reasonable upper limit” is 10, without much more explanations.</p><p>This is where we begin to stumble in the drawbacks of the cyclomatic complexity: there is no empirical evidence that this upper bound is meaningful. More generally, there is no evidence that the number of paths of a codebase is correlated to its complexity.</p><p>Additionally, the cyclomatic complexity doesn’t take into account the nesting of the different branch points. In my experience, confusion can rise quickly when you have nested conditionals, much more than the number of conditionals by itself.</p><p>Other studies (like <a href="https://www.researchgate.net/publication/3407068_A_Critique_of_Cyclomatic_Complexity_as_a_Software_Metric" target="_blank" rel="noopener">this one</a>) also show that the cyclomatic complexity is not correlated with the number of defects. Additionally, even if McCabe wanted to stop counting lines of code to measure complexity, it has been showed that the counting LOC is correlated to the cyclomatic complexity. In some situation, measuring these lines of code is even better! What’s the point to measure the cyclomatic complexity in that case?</p><p>Here’s my advice: take the cyclomatic complexity into account when it’s really high (more than 20 or 30). In most cases, look at the LOC instead.</p><h3 id="counting-lines-of-code">Counting Lines of Code</h3><p>Counting the lines of code of a module is one of the easiest complexity metric you can compute. Modules with a high LOC are possible complex modules. It might indicate that they have <a href="https://thevaluable.dev/single-responsibility-principle-revisited/">too many responsibilities</a>, and that these responsibilities shouldn’t be entangled together (lack of cohesion).</p><p>Another advantage of the LOC metric: you can use the same tools to calculate it whatever the programming language you’re using, like <a href="https://github.com/AlDanial/cloc" target="_blank" rel="noopener">cloc</a>) for example.</p><p>Keep in mind, however, that this metric work best when you have modules which are really bigger than the others. Additionally, a codebase with small modules doesn’t mean that it’s a codebase without complexity.</p><h3 id="code-shape">Code Shape</h3><p>Are you afraid when the code you’re reading is unexpectedly attracted by the right side of your screen? You should. Lines containing many indentations often indicate, in many common programming languages, nested structures (like conditionals).</p><p>I like to think of complexity as many different modules intertwined with each others, forming a blurb of chaos. Nested constructs are definitely in this ballpark.</p><p>It’s pretty easy to measure, too: you just have to count the number of logical indentation (spaces or tab) of a module, line per line. You can then find out the maximum level of indentation in a file, the total count of indentations, and you can compare the information to other, more healthy modules.</p><p>Consider the following code:</p><div><pre><code data-lang="php"><span>&lt;?php</span>

<span>foreach</span> <span>(</span> <span>(</span><span>array</span><span>)</span> <span>$post_links</span> <span>as</span> <span>$url</span> <span>)</span> <span>{</span>
    <span>$url</span> <span>=</span> <span>strip_fragment_from_url</span><span>(</span> <span>$url</span> <span>);</span>

    <span>if</span> <span>(</span> <span>&#39;&#39;</span> <span>!==</span> <span>$url</span> <span>&amp;&amp;</span> <span>!</span> <span>$wpdb</span><span>-&gt;</span><span>get_var</span><span>(</span> <span>$wpdb</span><span>-&gt;</span><span>prepare</span><span>(</span> <span>&#34;SELECT post_id FROM </span><span>$wpdb-&gt;postmeta</span><span> WHERE post_id = %d AND meta_key = &#39;enclosure&#39; AND meta_value LIKE %s&#34;</span><span>,</span> <span>$post</span><span>-&gt;</span><span>ID</span><span>,</span> <span>$wpdb</span><span>-&gt;</span><span>esc_like</span><span>(</span> <span>$url</span> <span>)</span> <span>.</span> <span>&#39;%&#39;</span> <span>)</span> <span>)</span> <span>)</span> <span>{</span>

        <span>$headers</span> <span>=</span> <span>wp_get_http_headers</span><span>(</span> <span>$url</span> <span>);</span>
        <span>if</span> <span>(</span> <span>$headers</span> <span>)</span> <span>{</span>
            <span>$len</span>           <span>=</span> <span>isset</span><span>(</span> <span>$headers</span><span>[</span><span>&#39;content-length&#39;</span><span>]</span> <span>)</span> <span>?</span> <span>(</span><span>int</span><span>)</span> <span>$headers</span><span>[</span><span>&#39;content-length&#39;</span><span>]</span> <span>:</span> <span>0</span><span>;</span>
            <span>$type</span>          <span>=</span> <span>isset</span><span>(</span> <span>$headers</span><span>[</span><span>&#39;content-type&#39;</span><span>]</span> <span>)</span> <span>?</span> <span>$headers</span><span>[</span><span>&#39;content-type&#39;</span><span>]</span> <span>:</span> <span>&#39;&#39;</span><span>;</span>
            <span>$allowed_types</span> <span>=</span> <span>array</span><span>(</span> <span>&#39;video&#39;</span><span>,</span> <span>&#39;audio&#39;</span> <span>);</span>

            <span>// Check to see if we can figure out the mime type from the extension.
</span><span></span>            <span>$url_parts</span> <span>=</span> <span>parse_url</span><span>(</span> <span>$url</span> <span>);</span>
            <span>if</span> <span>(</span> <span>false</span> <span>!==</span> <span>$url_parts</span> <span>&amp;&amp;</span> <span>!</span> <span>empty</span><span>(</span> <span>$url_parts</span><span>[</span><span>&#39;path&#39;</span><span>]</span> <span>)</span> <span>)</span> <span>{</span>
                <span>$extension</span> <span>=</span> <span>pathinfo</span><span>(</span> <span>$url_parts</span><span>[</span><span>&#39;path&#39;</span><span>],</span> <span>PATHINFO_EXTENSION</span> <span>);</span>
                <span>if</span> <span>(</span> <span>!</span> <span>empty</span><span>(</span> <span>$extension</span> <span>)</span> <span>)</span> <span>{</span>
                    <span>foreach</span> <span>(</span> <span>wp_get_mime_types</span><span>()</span> <span>as</span> <span>$exts</span> <span>=&gt;</span> <span>$mime</span> <span>)</span> <span>{</span>
                        <span>if</span> <span>(</span> <span>preg_match</span><span>(</span> <span>&#39;!^(&#39;</span> <span>.</span> <span>$exts</span> <span>.</span> <span>&#39;)$!i&#39;</span><span>,</span> <span>$extension</span> <span>)</span> <span>)</span> <span>{</span>
                            <span>$type</span> <span>=</span> <span>$mime</span><span>;</span>
                            <span>break</span><span>;</span>
                        <span>}</span>
                    <span>}</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre></div><p>This is an extract from the <a href="https://github.com/WordPress/WordPress/blob/master/wp-includes/functions.php" target="_blank" rel="noopener">Wordpress source code</a>. Our assumptions are correct here: we can all agree that this code is quite complex. I’ve found it by:</p><ol><li>Looking at files with the highest LOC metric.</li><li>Looking at lines having more indentations than the others.</li></ol><p>Simple metrics like LOC and code shape can give you more information than more complex ones.</p><h3 id="coupling-and-cohesion">Coupling and Cohesion</h3><p><a href="https://thevaluable.dev/images/2021/measuring_complexity/cohesion_gandalf.jpg"><picture>
<source srcset="https://thevaluable.dev/images/2021/measuring_complexity/cohesion_gandalf.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2021/measuring_complexity/cohesion_gandalf.jpg" alt="Things which belong together should be together (cohesion), if not they should be independent (not coupled)"/></picture></a></p><p>We’re leaving now the nitty-gritty details of the implementation itself to zoom out a bit, and look at the architecture. As we already saw, complexity emerge from many elements intertwined with each others. The number of elements and their relationship makes the complexity; if everything was independent in our systems, we wouldn’t have a hard time to modify anything we want.</p><p>Modules should be independent of each other <em>as much as possible</em>. At the same time, we need to group the things which evolve together, to increase the <em>cohesion</em> of our code, inside the modules themselves. Analyzing the coupling in our codebase can show us where it could be avoided.</p><p><a href="https://fpalomba.github.io/pdf/Journals/J16.pdf" target="_blank" rel="noopener">This study</a> classify coupling in four different categories I find quite useful.</p><h4 id="structural-coupling-static-analysis-of-the-codebase">Structural Coupling: Static Analysis of the Codebase</h4><p>A coupling is structural when it can be directly found by analyzing the codebase (static analysis). In other words, you don’t need to run your code to find them.</p><p>The tools to calculate the different levels of coupling in codebases will be often language-dependent, unfortunately, contrary to other metrics like LOC or code shape.</p><p>Here are possible categories of coupling you can find:</p><ol><li>Content coupling - Modules accessing the content of each others.</li><li>Common coupling - Modules mutating common variables with bigger scope (like <a href="https://thevaluable.dev/global-variable-explained/" target="_blank" rel="noopener">global variables</a>).</li><li>Control coupling - Modules controlling the logic of other ones.</li><li>External coupling - Modules exchanging information to one another using an external mean, like a file.</li><li>Stamp coupling - Modules exchanging elements, but the receiving end doesn’t act on all elements. For example, an array passed to a module which doesn’t use all the array’s elements.</li><li>Data coupling - Modules exchanging elements, and the receiving end use all of them.</li></ol><p>These coupling are supposedly classed from worst to best, even if I <em>believe</em> that content coupling is better than common coupling, because it’s more difficult to know what is affected by global constructs.</p><p>These categories are useful while writing our code and while analyzing it, to understand what kind of coupling we’re creating.</p><p>What about OOP? Since the rise of the paradigm, many metrics are specifically designed around it. We’re not speaking about general “modules”, but more about classes and objects:</p><ul><li>CBO (Coupling Between Object) - How much objects acts upon another.</li><li>CBE (Coupling Between Element) - More precise variation of the CBO. It considers two (or more) elements coupled if there is any dependency between them, like access, or modification of implementation details to one another.</li><li>CTM (Coupling Through Message passing) - Measures the number of messages sent by a considered class to the other classes in the system.</li><li>IC (Inheritance Coupling) - Calculate the coupling due to inheritance. I’ve already written about coupling and inheritance in <a href="https://thevaluable.dev/guide-inheritance-oop/" target="_blank" rel="noopener">another article</a>.</li></ul><h4 id="dynamic-coupling-the-coupling-at-runtime">Dynamic coupling: The Coupling at Runtime</h4><p>Dynamic coupling concern every coupling happening at runtime, like dynamic binding or polymorphism. These metrics doesn’t differ much from the structural metrics seen above, except that they can’t be analyzed statically (with the code alone).</p><p>In my experience, you shouldn’t need these metrics very often, except if you tried to generalize everything in your codebase using polymorphism. It’s definitely something I wouldn’t advise.</p><h4 id="logical-coupling">Logical Coupling</h4><p>Modules coupled logically are modules changing together frequently, even if there is no structural coupling between them. To find out logical coupling, we need to look at historical information, like Git’s history for example.</p><p>A tool like <a href="https://github.com/adamtornhill/code-maat" target="_blank" rel="noopener">code-maat</a> can give you this logical coupling by analyzing files commited together. The assumption is that if the same files are part of multiple commits, changing one oblige you to change the others. As a result, they’re logically couled.</p><p>Like any other metric, this one has its flaws. You’re not sure that developers will put the files they often modify together in the same commit, for example. If the commits are squashed automatically each time they’re merged to the main branch, you’ll get wrong results, too. That said, it’s still a useful metrics if you keep these flaws in mind.</p><p>In my experience, this kind of coupling happens quite often. If you find some of them, the best is to merge the logically coupled modules, to increase their cohesion. It can help you detect violations of the <a href="https://thevaluable.dev/dry-principle-cost-benefit-example/">DRY principle</a> for example; that the same knowledge appears in multiple places of the codebase.</p><h4 id="semantic-coupling">Semantic Coupling</h4><p>Sometimes, some modules use the knowledge of other modules, increasing the coupling between them and decreasing their cohesion. They’re often logically coupled, but not always. This is called semantic coupling.</p><p>Analyzing shared semantics between modules is hard, but some techniques are being developed, like machine learning models which are able to analyze relations between comments or names, for example.</p><p>Here are some metrics used for semantic coupling:</p><ul><li>CCM - Conceptual Coupling Between Methods.</li><li>CCMC - Conceptual Coupling Between a Method and a Class.</li><li>CCBC - Conceptual Coupling Between two Classes, also called CSBC (Conceptual Similarity Between two Classes).</li></ul><p>I never measured the semantic coupling of my modules, the other metrics being good enough for my needs.</p><h2 id="measuring-complexity-is-only-the-beginning">Measuring Complexity is Only the Beginning</h2><p>If you only take one thing from this article, grab this one: complexity metrics are all flawed; they can give you false positive if you’re not careful. That said, they can be useful to isolate a part of your codebase which might be more prone to defect. But, at the end of the day, it’s a combination of metrics, your experience, and your experiments which will show you the potential problems in your codebase.</p><p>When I want to find where the complexity is hiding, I always try the simplest metrics first. In order of preference:</p><ol><li>LOC</li><li>Code shape</li><li>Structural coupling (common and content coupling)</li><li>Logical coupling</li></ol><p>The Halstead metrics (or the ones based on them) and the cyclomatic complexity can be useful too, but only if they’re abnormally large.</p><p>Looking at complexity metrics alone is however not enough. A codebase is like a living organism: some parts <em>change</em> more or less often, modified by different actors with different purposes, understanding, and styles. That’s what we’ll look at in the next article of the series: code metrics in the context of a social, ever-changing environment.</p></section></article></div></div>
  </body>
</html>
