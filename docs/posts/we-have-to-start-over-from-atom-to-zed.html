<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://zed.dev/blog/we-have-to-start-over">Original</a>
    <h1>We Have to Start Over: From Atom to Zed</h1>
    
    <div id="readability-page-1" class="page"><div><article><header></header><p><em>After the <a href="https://zed.dev/blog/why-the-big-rewrite">last conversation</a> with Nathan, Max, and Antonio—Zed&#39;s three co-founders—I still had quite a few questions to ask: why did you make the technological choices you did? How important is Rust to Zed? Did you consciously set out to own the technological stack the way you do now? How do you decide what to polish and build-once-and-for-all-time and what to ship faster?</em></p>
<p><em>Lucky for me, they sat down with me again and answered my questions again.</em></p>
<p><em>What follows is an editorialized transcript of an hour long conversation we had. I tried to preserve intent and meaning as much as possible, while getting rid of the uhms, the likes, the you-knows, and the pauses and course-corrections that make up an in-depth conversation.</em></p>
<p><em>(You can <a href="https://www.youtube.com/watch?v=w894KLbapLw">watch the full conversation on our YouTube channel</a>.)</em></p>
<p><strong>Thorsten: The three of you have been working together for, what? Has it been 10 years?</strong></p>
<p><strong>Nathan</strong>: Ungefähr. [German for: &#34;Something like that.&#34;]</p>
<p><strong>Max</strong>: Yeah, something like that.</p>
<p><strong>Antonio</strong>: I think 10 years sounds about right. 2014, yeah.</p>
<p><strong>Thorsten: <a href="https://en.wikipedia.org/wiki/Atom_(text_editor)">Atom</a> — that was 10 years ago. You worked together on Atom and then said &#34;we&#39;re building Zed.&#34; It&#39;s pretty clear that you have a vision for what you want to build. And you also made some really distinct technological choices. You use Rust, it&#39;s GPU-accelerated, CRDTs. I&#39;m wondering: how much are these technological choices are tied-in with the vision for Zed? How big of a role does the technology play?</strong></p>
<p><strong>Nathan</strong>: I mean, from my perspective, the vision for Zed is just a more refined and fleshed out version of the original vision for Atom, which just fell short due to the technical choices we made in my mind and the level of technical maturity that I think all of us had when we started Atom.</p>
<p>But the goal I&#39;ve always had is a lightweight editor that is minimal that I love using that feels like a text editor, but has the power of an IDE when needed, without all of the slowness in the experience and kind of heaviness in the UI, but still powerful. That was very early on what I wanted. And for it to be extensible.</p>
<p>You know, I remember using Emacs and thinking it was so cool that you could extend it, but you&#39;re sort of operating at the character level. So that was part of the original vision too and now Max has achieved that with <a href="https://tree-sitter.github.io/tree-sitter/">Tree-sitter</a>. You know, basically scriptability. We&#39;re not scriptable yet, but we&#39;ll get there. But when we are, we&#39;ll have access to a richer representation of the text than just looping over characters or whatever I was doing in Emacs. I mean, they probably have that now as well, right? Because Max wrote tree-sitter.</p>
<p><strong>Max</strong>: They do, I hear.</p>
<p><strong>Nathan</strong>: So that&#39;s cool. But anyway, that was all part of the vision. And it just didn&#39;t pan out with Atom. I mean, when Chris hired me to work on Atom, I almost didn&#39;t join [meaning: join GitHub to work on Atom] because I was afraid of using web tech and that it wouldn&#39;t be able to get there.</p>
<p>But to be honest, I don&#39;t know that whatever I had at my disposal at the time would have gotten us any better because Rust didn&#39;t exist back then. So it would have been C, C++. I don&#39;t know, it would have been really hard to do something native at the time we created Atom. And I don&#39;t think my skills were in place on just fundamental algorithms, et cetera, that are critical to text editing. And C++ would have really slowed me down in my learning there. So I think it happened how it needed to happen.</p>
<p>We got to a certain point with Atom. It was 2017 when we&#39;d shipped <a href="https://github.com/atom/teletype">Teletype</a> and it felt like, okay, it&#39;s no longer our own ignorance holding us back, it really is like the platform holding us back at this point. That&#39;s really how it was starting to feel.     Just the fact that in JavaScript, an array in JavaScript is... You think you have an array of objects, but you really have an array of pointers to objects. So every single time you&#39;re walking over that, you&#39;re chasing it down. You have no control over memory. There are garbage collector pauses that are just happening that you have no control over. You just look at the profile of the fricking thing.</p>
<p><strong>Thorsten: When you were working on Atom, was there a specific point at which you said &#34;oh, I wish we would have built it with X&#34;? Or was it an accumulation of paper cuts? Antonio was nodding right now.</strong></p>
<p><strong>Antonio</strong>: Speaking of 10 years of working on this thing: I remember one of my first projects in Atom — I don&#39;t know if you remember this, Nathan — was speeding up line layout. Basically, we were seeing line layout being very slow. And I remember trying rendering lines in an iframe. And I remember using Canvas, measured text, and all these APIs that were... I don&#39;t know, the Canvas API wasn&#39;t quite the same as the browser API, so you couldn&#39;t really measure text correctly. The iframe stuff had some other weird problem.</p>
<p>My experience in Atom always felt like bending over backwards to try to achieve something that in principle should have been simple. Lay out some lines and read
the position of the cursor at this spot in between these two characters. That seems fundamentally doable and yet it always felt like the tools were not at our disposal. They were very far away from what we wanted to do.</p>
<p><strong>Nathan</strong>: It was a nightmare. I mean, the ironic thing is that we created Electron to create Atom, but I can&#39;t imagine a worse application for Electron than a code editor, I don&#39;t know. For something simpler, it&#39;s probably fine, the memory footprint sucks, but it&#39;s fine. But for a code editor you just don&#39;t have the level of control I think you need to do these things in a straightforward way at the very least. It&#39;s always some... backflip.</p>
<p>So at some point in 2017, I remember sitting there, writing in Atom in my journal — that was the evening when I thought: we have to start over. We have to start over, this isn&#39;t working and we&#39;re never going to get this where we want it to go. VS Code has done an admirable job of getting it as far as it&#39;s gonna go. There&#39;ll be incremental improvements in the tech, I&#39;m sure, but I just wanted more.</p>
<p>So at that point it was: okay, what should we do? And I&#39;d been watching Rust, I&#39;d seen some of <a href="https://raphlinus.github.io/">Raph Levien</a>&#39;s writing about Rust. And at the time this seemed like the only viable path to kind of overcome some of these obstacles. And it started as: what if we just write the core of this thing in Rust and we keep Electron as the presentation layer?</p>
<p>So it was just inch-by-inch that we came to the technological decisions we chose. Even after building the UI framework, giving up on Electron, we were using <a href="https://github.com/servo/pathfinder">Pathfinder</a>, which is like this really cool project that could do arbitrary presentation of SVGs basically, but it was too slow. So then I thought: okay, what if we do our own shaders? And then went and learned about signed distance fields.</p>
<p>It was kind of funny. It was me not wanting to solve some more fundamental problem, but just being forced to do that by the unavailability of any other choice.</p>
<p>I shouldn&#39;t say it was only me, it wasn&#39;t only me. But this was from my perspective...</p>
<p><strong>Thorsten: It sounds like the goal was always to be as fast as possible, as lightweight as possible. You tried to get there, but you couldn&#39;t with the technology you had. But then Rust came along. And you didn&#39;t start saying &#34;we need a GPU-accelerated editor&#34;, but you started by saying you want the fastest possible editor and then GPU acceleration was one way to do that. Is that right?</strong></p>
<p><strong>Nathan</strong>:
Yeah, it was: we have this hardware in the computer and rather than negotiating what DOM nodes are in the DOM at a given moment, or all this nonsense, we could just literally be like, what color should this pixel be? Great. Okay, if we can program that hardware to decide what color every pixel on the screen should be in parallel, or as parallel as possible — we should probably use that if we want to be fast.</p>
<p>But you know, we came there kind of grudgingly because I didn&#39;t know how to do any of it.</p>
<p><strong>Thorsten: Now, this is kind of a loaded question, but I&#39;ve been on the side hacking with Rust for the last three years and my feelings about it are complicated. But two weeks someone on Hacker News said that find-all-matches in Zed takes a second but in Sublime Text it&#39;s really fast, closer to 200ms. So Antonio and I paired on that and he wrote code to optimize for this case of searching all the occurrences in a buffer. But the optimized code wasn&#39;t &#34;optimized&#34; code: it didn&#39;t use any dirty tricks, no SIMD, or something like that. It was high-level code, with the optimization being that it&#39;s assumption was different: instead of doing things in a loop, one by one, its assumption was to find all results. We made a release build of that and it went from 1s down to 4ms.</strong></p>
<p><strong>Antonio</strong>:
Hahaha</p>
<p><strong>Thorsten: And I sat there, looking at the 4ms, and... well, I thought: this is going to be a nice lunch break after this. But 4ms? With high-level code like that, that just called other internal APIs? Wow. So what I&#39;m trying to ask is: Rust has these zero-cost abstractions — so you can use high levels of abstraction to build a text editor, but it still gives you this kind of performance. Do you think this is a specific thing about Rust, or do you think if you had just been a better C++ or C programmer, you could&#39;ve done it in another language?</strong></p>
<p><strong>Antonio</strong>: You probably could have done it with C and C++. I don&#39;t know. I mean, tree-sitter is written in C, right, Max? So it is possible to write a complex library piece of software in C. Although I have to say anytime I look at the C code in tree sitter, I scream because it&#39;s just too much for me. I don&#39;t know.</p>
<p>Personally, yes, Rust is in a sweet spot. If it wasn&#39;t for the compile time being that slow — that&#39;s a thing that I really don&#39;t like about the language, but maybe it&#39;s our project that&#39;s too big, I don&#39;t know.</p>
<p>But yes it is pretty cool that you can build on top of these abstractions and just rely on them. I mean, I don&#39;t know about zero cost —  every abstraction has a cost, I guess.</p>
<p>But the thing with this project in general... With Atom it always felt like we didn&#39;t know where to look for performance. With this, with Zed, it&#39;s more: we could do this and we could do that and we could improve this. Just last week, Nathan and I were discussing how to improve the subtraction of the SumTree to perform batched insertion a lot faster.</p>
<p><strong>Nathan</strong>: And then you implemented it, right?</p>
<p><strong>Antonio</strong>: Yeah. But it&#39;s not shipped yet.</p>
<p><strong>Nathan</strong>: Great.</p>
<p><strong>Max</strong>: I&#39;ll say we did do a lot of C++ on Atom — we did a lot. We tried. And it worked, but it was just that there was a very meaningful distinction — obviously — where the boundary was between the JavaScript application code and the C++ library code. And people would talk about performance and say &#34;just do this on a background thread, just don&#39;t do it on the main thread&#34; and we&#39;d say &#34;okay, we can do that&#34; but that means this whole subsystem that is involved here needs to be dropped into C++ in order to share memory. Then build JavaScript APIs around that and figure out how it&#39;s going to still look like idiomatic JavaScript code and preserve all these properties that it had from when it was written in JavaScript.</p>
<p>And only then could we actually move this one task to the background thread.</p>
<p>It was such a difference between writing JavaScript code — that was scriptable and pluggable and overridable — and the C++ that had the core capability to have shared memory and multi-threading.</p>
<p><strong>Nathan</strong>: And Rust is designed to be multi-threaded. I remember when I tried to learn Rust and I wanted to implement this <a href="https://en.wikipedia.org/wiki/Splay_tree">splay tree</a> because the splay tree was a structure that we used a lot in Atom. Well, for a time — it had its era at least. I mean, it was actually pretty good for our needs, but it had parent pointers, it was very much a mutable structure.</p>
<p>And I tried to build that in Rust and the language fought me. And I thought: can you even build anything real in this language? I had serious doubts, actually.</p>
<p>So I gave up for a while, then I tried again. And this time around I built a copy-on-write B-tree. And when I built it that way, it used <code>Arc</code>s and that meant it was inherently multi-threading friendly.</p>
<p>And when I followed the dictates of the language and the borrower checker and did it the way Rust wanted me to do it, it was: oh, cool.</p>
<p>Now we have this way of representing <a href="https://en.wikipedia.org/wiki/Rope_(data_structure)">ropes</a> — which is the fundamental text storage structure in Zed — in a way where we can spawn a background thread, and it&#39;s O(1), it&#39;s just bumping an <code>Arc</code> to take that to a background thread and look at a snapshot, et cetera.</p>
<p>It&#39;s not just about being native. I also think Rust brings to the table innovations. The language is designed to be used the way we&#39;re using it on multiple threads and at a low level.</p>
<p>And frankly, I was just a little too much of a script kiddie I think to do well in C++. It always just annoyed me: these freaking files, jumping over here, all these arcane rules. And could a C++ master do what we did in Rust? Probably, but like I wasn&#39;t gonna become that person.</p>
<p><strong>Thorsten: So Antonio, you just mentioned that with JavaScript, you didn&#39;t know where to look for performance. Max, you said, when you were using C++ or JavaScript, you felt these boundaries when you want to make something async. And now we heard about Rust — you can suddenly do stuff async on a background thread, you have less restrictions, you can move freely around.</strong></p>
<p><strong>That reminds me of something you can actually see in the Zed code base: you own the whole stack. From tree-sitter doing the parsing to GPUI, the GPU-accelerated UI framework — there aren&#39;t a lot of third-party dependencies in the code base. Some libraries, but not big building blocks.</strong></p>
<p><strong>How important is that for you? We own the full stack, top to bottom, we understand it top to bottom. Is that a conscious choice or did this happen by accident because Max built tree-setter and then you did this and now look at us, we rebuilt the whole thing.</strong></p>
<p><strong>Max</strong>: I don&#39;t know. I think it has trade-offs, but I so far it&#39;s been pretty nice to be able to just... decide how we want things to work. Like right now: we want to have language extensions that use WASM. Tree-sitter didn&#39;t have that but we added that to it.</p>
<p>There&#39;s a million things like that. We don&#39;t want to be beholden to some UI framework that may not render text exactly the way we want, because we&#39;re a text editor and that matters a lot. But we can now go change that.</p>
<p>It doesn&#39;t feel like anything is sort off limits.</p>
<p><strong>Nathan</strong>: One thing I&#39;ll say: this was very informed by an experience earlier in my career with jQuery. jQuery was the hot thing and I learned jQuery. I remember <a href="https://yehudakatz.com">Yehuda</a> coming to <a href="https://en.wikipedia.org/wiki/Pivotal_Labs">Pivotal</a> and presenting on jQuery and I thought this is so cool. I was blown away by it. So early on, all the Atom code, believe it or not, was jQuery.</p>
<p>And the funny thing was though, having learned jQuery, because everybody told me, &#34;oh, the reason you use jQuery is it abstracts over all the differences in the browser APIs&#34;, et cetera. I never really questioned that. But then I remember the day that I just sat down and read the freaking DOM APIs. And I thought: you know what, this is actually fine. Maybe there were some missing features or something — and I don&#39;t want to shit on jQuery, I think it has its role — but what I came away with was that if I don&#39;t have an abstraction that&#39;s nailing almost 100% of my needs then I might not want to have that abstraction and go to the level below, understand the level below it fully, and do what I need to do.</p>
<p>That was kind of what happened with GPUI. There were some UI frameworks in flight when we started on a GPUI, in 2019, but none of them did what I knew we would need to do. And I didn&#39;t understand them.</p>
<p>But I knew I could come to understand quite easily the fundamental primitives that we&#39;re going to be relying on — the language, the graphics framework. I knew we could learn those things and I knew we&#39;ve written a lot of code. If I can build a system that I can understand and learn from, then I know that I can do what we need to do if it&#39;s fundamentally possible on the underlying system. And so really it was — at least for GPUI — a survival strategy: I need to understand this and the best way to understand it is to build it.</p>
<p><strong>Thorsten: What are the downsides of that? Max, you said there&#39;s trade-offs.</strong></p>
<p><strong>Nathan</strong>: Takes forever. It&#39;s slow.</p>
<p><strong>Antonio &amp; Max</strong>: [laughing]</p>
<p><strong>Antonio</strong>: It&#39;s also tricky to onboard people. You&#39;re not using the X framework out there that everybody knows, you have to teach this code base from scratch — you know, 300,000 lines of code. That&#39;s a downside.</p>
<p>But the cool thing is that while this is a downside, at the same time there&#39;s somebody else who has written that code and can explain it to the new person.</p>
<p>It might be slower, but again, you&#39;re retaining control.</p>
<p><strong>Nathan</strong>: I think it accumulates. The advantages accumulate, and the downsides depreciate. Someone just built <a href="https://github.com/MatthiasGrandl/loungy">another app on GPUI</a>, so now we have another stakeholder. The cost of having owned it, we&#39;re going to gradually write off over time, and the costs and the upsides of owning it are going to start to kick in.</p>
<p><strong>Thorsten: Sometimes people say: I only build it once and then I never have to touch it again. And the opposite of that might be: you can&#39;t predict the future, <a href="https://en.wikipedia.org/wiki/Worse_is_better">worse is better</a>, and so on.</strong></p>
<p><strong>And what you just said, that it&#39;s slower to build it all yourself, there&#39;s a ring of &#34;build it once and do it right for our use case&#34; to it: only the perfect abstraction for what we want to do. At the same time, there&#39;s this sense of urgency that you all have. I mean, I joined four weeks ago and I do feel like we&#39;re moving fast and we&#39;ve got so much to do.</strong></p>
<p><strong>How do you balance that? How do you have this huge vision for what you want to build, and balance that with saying &#34;I&#39;m gonna write shaders, I&#39;m gonna perfect how we render drop shadows or whatever&#34;?</strong></p>
<p><strong>Nathan</strong>: Build what you need, only what you need, no more, no less, and build that as well as you can within reason. And then when it turns out to not be quite what you needed, be willing to revisit it after you&#39;ve learned. But I think if you&#39;re laying down every brush stroke with intentionality and care,
and you&#39;re not wasting time speculating about what you might need, then... for me, that&#39;s always worked out. Sometimes it takes a little while though.</p>
<p><strong>Antonio</strong>: I would add on top of that: it&#39;s a gradient. It&#39;s not like everything needs to be built perfectly. Or at least that&#39;s how I feel about much of the code we write. If we&#39;re writing stuff in GPUI, well, the whole app depends on the GPUI, that better be perfect. Or the sum tree. It&#39;s this data structure that&#39;s used everywhere in the code base. That one we really wanna nail, because it has to be fast.</p>
<p>It has to work perfectly so that we can build on top of it, right? And that is reflected, also in the testing that we do on those things. The SumTree is randomized-tested because we want to make sure that all those edge cases work perfectly.</p>
<p>Now, as you move towards the edge— that performance improvement that you alluded to, Thorsten, we didn&#39;t spend three hours gold plating it, right? It was like: whatever gets the job done, it&#39;s pretty much at the edge. I mean, we should feel good about the code, we should always strive to write the code as best as we can, but we don&#39;t need to gold plate it.</p>
<p>It&#39;s a gradient. The more core something is, the more it deserves thought and quality.</p>
<p><strong>Nathan</strong>: And my favorite code to write is the code I&#39;ve earned myself the right to write. Whoa, that&#39;s a lot of homophones.</p>
<p>With GPUI I had so much fun writing it that I almost felt like guilty about it.
But I have earned the right to write this code because I wrote the first version, I lived with it, I pushed it forward, I made the compromises when I needed to make them to make things right.</p>
<p>But now is the moment where we can make this better. And it makes sense to make this better. And I&#39;m informed. I think a lot of times when people talk about like rewriting— if you&#39;re rewriting something someone else wrote, be doubly suspicious of yourself.</p>
<p>But if you wrote it and you&#39;ve lived with it and you&#39;ve put in the work... That&#39;s also something to be said: don&#39;t let perfectionism get in the way of learning.</p>
<p><strong>Thorsten: If I were to take the three of you and... I don&#39;t know what to throw at you that you couldn&#39;t build, but say you&#39;d have to build, I don&#39;t know what — a PID controller for an airplane. Airplane software, there you go. Something like that.</strong></p>
<p><strong>Nathan</strong>: Nuclear reactor control subsystem.</p>
<p><strong>Thorsten: You don&#39;t know the domain and you don&#39;t know yet how you&#39;re going to build it and you don&#39;t yet know which parts you&#39;re going to need. Is that where you would say you&#39;d need a different approach? Unlike in the editor, where you have a strong vision for what you want, you built a few before, so now you know which parts count. You know beforehand, GPUI is going to be important. So let&#39;s take our time with it and gold-plate it as Antonio said.</strong></p>
<p><strong>Max</strong>: I mean, I don&#39;t know if a nuclear reactor is a good example, but I do feel like if it was our first code editor, ... We <em>did</em> &#34;worse is better&#34;. It wasn&#39;t intentionally bad, but we took the kind of quicker, dirtier approach once and then kind of identified the things that were real pain points to build on top of, in their sort of worse-is-better form.</p>
<p>But I do think, if for some reason Antonio and me and Nathan had to build a...</p>
<p><strong>Nathan</strong>: Choose something less mission critical maybe?</p>
<p><strong>Max</strong>: ... a Shopify clone or something. We would probably have a different mindset about it. We wouldn&#39;t know which pieces needed to be really highly honed.</p>
<p><strong>Nathan</strong>: But if I <em>were</em> building a nuclear reactor control system, I would use a Byzantine fault-tolerant consensus algorithm and pit three teams against one another to compromise each other&#39;s security and then make them come to consensus on all of it. But I don&#39;t know how to do that.</p>
<p><strong>Antonio</strong>: There&#39;s another example that&#39;s less mission critical than a nuclear reactor, but where we didn&#39;t know the data structure and we kind of took the time to learn it. It wasn&#39;t always that the structure powering the buffers in Atom and in Zed today was a CRDT. There was a research period where Nathan and I read... I forget how many papers. A lot of them. And the approach we&#39;re using right now with the CRDT — we still rewrote it two or three times — but the approach is more or less the same.</p>
<p>So I think there&#39;s a part of it that comes with experience. I feel like you tend to develop a sense of what you need to spend time on and what is more frivolous, less important.</p>
<p>Now, that said, we did rewrite the CRDT two or three times, but the research part, was important. I don&#39;t know.</p>
<p><strong>Nathan</strong>: The funny thing is in the Atom that shipped, the buffer was an array of lines, a JavaScript array of strings. And in Zed, it&#39;s a multi-thread-friendly snapshot-able copy-on-write B-tree that indexes everything you can imagine. Or everything we&#39;ve needed. So we did worse is better.</p>
<p>But starting over, would it be an array of lines again? Probably not because look at the look at the time bounds on that. And put a little more thought into it, but that — again — I learned that by like doing worse-is-better and then having it be really slow or problematic in edge cases that ended up mattering.</p>
<p><strong>Thorsten: So what are the most gold-plated parts of Zed?</strong></p>
<p><strong>Nathan</strong>: GPUI is pretty gold-plated, I think, because we just rewrote the whole fricking thing.</p>
<p><strong>Antonio</strong>:
Good question.</p>
<p><strong>Max</strong>: I think what&#39;s in the <a href="https://github.com/zed-industries/zed/tree/main/crates/editor"><code>editor</code> crate</a>, where there&#39;s sort of the stack of different transforms that convert the raw text of the buffer into the lines that you see on screen, that expand the tabs and do the soft-wrapping and insert the block decorations and handle folds and stuff. All those layers have this uniform testing strategy where it&#39;s randomized-tested with property testing. So I think they&#39;re pretty gold-plated.</p>
<p>The multi-buffer too, where we sort of weave together the different excerpts of different buffers into one.</p>
<p><strong>Nathan</strong>: I would call them, um... I just wanted to suggest like an alternative substance for that part of the code base. I would say it was kind of plated and coated in blood.</p>
<p><strong>Antonio</strong>: Ha! Blood plated.</p>
<p><strong>Thorsten: You mean the editor and the multi-buffer?</strong></p>
<p><strong>Antonio</strong>: Yeah.</p>
<p><strong>Nathan</strong>: Yeah. It&#39;s randomized tests where we&#39;ve spent literally the entire day in 2021, many days in a row, just debugging failures in these randomized tests that would find some weird edge case of this ornate— I mean, I wouldn&#39;t say it&#39;s ornate, but it&#39;s complicated — stacking of different layers of transformation required to present things on screen. And so it&#39;s just elbow grease, right? Find the edge cases and then figure out why they&#39;re happening by reducing the log, which for a long time we just did manually.</p>
<p><strong>Thorsten: How did it feel when one of these bugs popped up? Did you have moments of panic when property testing threw a bug in our face and you thought &#34;maybe this whole thing doesn&#39;t work?&#34; Or was it rather &#34;well, it&#39;s just another thing to polish down and if not, we rewrite this&#34;?</strong></p>
<p><strong>Antonio</strong>: Never panic, that&#39;s the rule of randomized testing, never panic. I have a lot of faith in our capability as engineers, I really do, and maybe it might be that we have to rewrite the whole thing and the randomized test is telling us that, but it&#39;s fine, we just learned something, back to the drawing board and redo it.</p>
<p><strong>Nathan</strong>: What was scary was: how long is this going to take? I think Lee, our seed investor, was also asking us that at certain times. But he stuck with us and was patient because it took a while.</p>
<p>But that piece was written in  Rust. If we f this up, the program is panicking. Goodbye, poof. It&#39;s not just like a stack trace gets thrown in the corner of the editor or something, no, it&#39;s done.</p>
<p>So we knew how hard it was to get those layers right. And we knew that there was no other choice, but to get them right. But yeah, I remember, Antonio, remember working on soft wraps and that problem we came up against where we realized the primitive we needed was this ability to represent a patch and then to be able to compose these patches together — that was one moment where I was sweating a bit, thinking &#34;are we gonna freaking figure this out?&#34; and then Antonio figured it out.</p>
<p><strong>Antonio</strong>: Yeah. But powering it all — you know, in terms of gold-plating — is again the sum tree. And even with that, there are some ideas on how to make it better, if we were to rewrite it.</p>
<p><strong>Nathan</strong>: We were talking the other night about how dope it would be. And Antonio, you applied some of the ideas we talked about: being able to construct all these layers in a more streaming friendly way. And you did one optimization, which is gonna land on preview next week.</p>
<p><strong>Antonio</strong>: Yeah, I need to open the PR for it still...</p>
<p><strong>Nathan</strong>: To enable more streaming inputs so people don&#39;t get zero feedback when they open a big file, but start actually loading things in, more efficiently — does that necessitate a rewrite? Maybe. Maybe not. I don&#39;t know.</p>
<p><strong>Thorsten: Quite interesting how often this idea of rewriting or doing it again comes up. We talked about this <a href="https://zed.dev/blog/why-the-big-rewrite">the last time</a>. Learning continuously. It&#39;s not: learning and <em>then</em> fixing something and patching something. It&#39;s more: we learned something, so now let&#39;s redo it with that learning in mind, vs. just putting a band aid on. It came up multiple times and you see it in the product.</strong></p>
<p><strong>When we talk, Antonio, you say things like: before we did it like <em>this</em> and now we do it like that. Just yesterday, we basically rewrote the part that deals with macOS&#39; IME system, because Antonio said: we can&#39;t leave it like this, we don&#39;t want another person to fall into this rabbit hole, let&#39;s put a bridge on top of it.</strong></p>
<p><strong>Nathan</strong>: Nice. That&#39;s good to hear. I&#39;ve heard about that.</p>
<p><strong>Thorsten: I don&#39;t know if it makes sense, but my last question is this... With a lot of software, say, SaaS Enterprise Whatever, or the Shopify clone, I think most users do not care what technology is used, as long as it works for them. And I wonder: do you think this is different with developer tools or editors? Does the technology that&#39;s used shine through more or do the users care more about it?</strong></p>
<p><strong>Max</strong>: I do think it affects the type of contributions we can get. A lot of our users, so many of them are people who would be prepared to contribute something to the code base to fulfill their own needs.</p>
<p>I think it&#39;s important that it&#39;s easy to contribute to Zed. If we written it all in C++, I think that there would be a lot of people who would like wanna change something about Zed, but would not be as prepared to make the change themselves.</p>
<p>Whereas just from the contributions that we&#39;ve gotten so far since going open source a few weeks ago, it&#39;s a lot. I think people like that it&#39;s written in Rust. It&#39;s approachable. People can build the project easily. They don&#39;t have to go learn how to use CMake or whatever to build the project or Gyp. They can just use cargo.</p>
<p>But also the fact that the compiler has this strictness to it, allows us, as the receiving end of those contributions, to often merge with confidence. I think it&#39;s really helpful.</p>
<p><strong>Nathan</strong>: Rust is an absolutely beautiful tool. It&#39;s not perfect, but I love it. But does it matter to the people? I mean, I think people want a fast editor at the end of the day. We could write it in, what is it, brainfuck? They wouldn&#39;t care. But the contribution angle is super valid.</p>
<p><strong>Antonio</strong>: But I still would like to talk about the performance, I just think we are forced to do things a certain way because of performance. Why do we have this GPU accelerated UI framework? It&#39;s because the performance needs to be at a certain level. We want our frames to be below three milliseconds. We could rasterize everything on the CPU and we could have used something that did that, but, no.</p>
<p>To some extent, we&#39;re positioning ourselves to be a performance editor, because we want a performance editor. I want a performance editor. And so, the choice is almost... we have no choice almost.</p>
<p><strong>Nathan</strong>: But there&#39;s Zig now and I don&#39;t know a lot about Zig yet, I haven&#39;t had time, honestly, to learn about it, but people I respect are excited about it. It seems like it shares some of the same goals in terms of the output as Rust. I&#39;m unclear what it&#39;s sacrificing in terms of safety, or how they handle those things. There may be pragmatic workarounds that are sort of not as strict as Rust, but in practice work, et cetera.</p>
<p>So I&#39;m intrigued by that. I&#39;m intrigued, but then there&#39;s a lot to be said for like monolingualism, if that makes sense. The server&#39;s in Rust, the frontend&#39;s in Rust, but if I could get 99% of the benefits of Rust with a 10th of the compile time or something...</p>
<p><strong>Thorsten: Well, I can tell you about Zig that a person on Discord was saying they&#39;re writing an editor in Zig, but the perfect name for a text editor in Zig is already taken: Zed.</strong></p><hr/></article></div></div>
  </body>
</html>
