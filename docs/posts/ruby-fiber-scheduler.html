<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://brunosutic.com/blog/ruby-fiber-scheduler">Original</a>
    <h1>Ruby Fiber Scheduler</h1>
    
    <div id="readability-page-1" class="page"><div>
    <article>
      

      <time datetime="2022-02-25">February 25, 2022</time>

      

      <p>Fiber Scheduler enables asynchronous programming in Ruby. The feature was one of the big additions to Ruby 3.0, and is one of the core components of <a href="https://brunosutic.com/blog/async-ruby">the awesome async gem</a>.

      </p><p>The best part is that you don&#39;t need a whole framework to get started! <strong>It&#39;s possible to achieve the benefits of asynchronous programming using a standalone Fiber Scheduler with just a couple of <nobr>built-in</nobr> Ruby methods.</strong></p>

      <p>The Fiber Scheduler consists of two parts:</p>

      <dl>
        <dt>Fiber Scheduler interface</dt>
        <dd>A set of hooks for blocking operations built into the language. Hook implementations are delegated to the <code>Fiber.scheduler</code> object.</dd>
        <dt>Fiber Scheduler implementation</dt>
        <dd>Implements the asynchronous behavior. This is an object that needs to be explicitly set by the programmer, as Ruby does not provide a default Fiber Scheduler implementation.</dd>
      </dl>

      <p>Big thanks to Samuel Williams! He&#39;s a Ruby core developer who designed and implemented the Fiber Scheduler feature into the language.</p>

      <h2><a href="#fiber-scheduler-interface" id="fiber-scheduler-interface">Fiber Scheduler interface</a></h2>

      <p>Fiber Scheduler interface is a set of hooks for blocking operations. It allows for inserting asynchronous behavior when a blocking operation occurs. These hooks are documented with <a href="https://docs.ruby-lang.org/en/3.1/Fiber/SchedulerInterface.html">Fiber::SchedulerInterface class</a>.</p>

      <p>Some of the main ideas behind this Ruby feature are:</p>

      <ul>
        <li>Hooks are <nobr>low-level</nobr>. This results in a small number of hooks, with each hook handling the behavior of many <nobr>high-level</nobr> methods. For example, the <code>#address_resolve</code> hook is responsible for handling around 20 methods.</li>
        <li>Hooks work only if <code>Fiber.scheduler</code> object is set, and hooks&#39; implementation is delegated to that object.</li>
        <li>Hooks&#39; behavior should be asynchronous.</li>
      </ul>

      <h3><a href="#hook-implementation" id="hook-implementation">Hook implementation</a></h3>

      <p>Let&#39;s look at the example showing how <code>Kernel#sleep</code> hook could be implemented. In practice all hooks are coded in C, but for clarity Ruby pseudocode is used here.</p>

      <pre><code><span>module</span> <span>Kernel</span>
  <span>def</span> <span>sleep</span>(duration = <span>nil</span>)
    <span>if</span> <span>Fiber</span>.scheduler
      <span>Fiber</span>.scheduler.kernel_sleep(duration)
    <span>else</span>
      synchronous_sleep(duration)
    <span>end</span>
  <span>end</span>
<span>end</span></code></pre>

      <p>The above code reads as following:</p>

      <ul>
        <li>If a <code>Fiber.scheduler</code> object is set – run its <code>#kernel_sleep</code> method. <code>#kernel_sleep</code> should run <code>sleep</code> asynchronously.</li>
        <li>Otherwise, perform a regular <code>synchronous_sleep</code> that will block the current thread until <code>sleep</code> is done.</li>
      </ul>

      <p>Other hooks work in a similar manner.</p>

      <h3><a href="#blocking-operations" id="blocking-operations">Blocking operations</a></h3>

      <p>The concept &#34;blocking operation&#34; was mentioned a couple times already, but what does it really mean? <strong>A blocking operation is any operation where a Ruby process (more specifically: current thread) ends up waiting</strong>. A more descriptive name for blocking operations would be <nobr>&#34;waiting operations&#34;</nobr>.</p>

      <p>Some examples are:</p>

      <ul>
        <li><code>sleep</code> method.</li>
        <li><abbr title="input/output">I/O</abbr> operations like <code>URI.open(&#34;https://brunosutic.com&#34;)</code>.</li>
        <li>System commands, for example <code>`curl https://www.ruby-lang.org`</code>.</li>
        <li>Waiting on a thread to finish via <code>Thread#join</code>.</li>
      </ul>

      <p>As a counterexample, the following snippet takes a while to finish, but <em>does not</em> contain blocking operations:</p>

      <pre><code><span>def</span> <span>fibonacci</span>(n)
  <span>return</span> n <span>if</span> [<span>0</span>, <span>1</span>].include? n

  fibonacci(n - <span>1</span>) + fibonacci(n - <span>2</span>)
<span>end</span>

fibonacci(<span>100</span>)</code></pre>

      <p>Getting the result of <code>fibonacci(100)</code> requires a lot of waiting, but it&#39;s only a <em>programmer</em> that&#39;s waiting! The whole time Ruby interpreter is working, crunching the numbers in the background. A naive fibonacci implementation does not contain blocking operations.</p>

      <p>It pays off to develop an intuition on what a blocking operation is (and is not), as <strong>the whole point of asynchronous programming is to wait on multiple blocking operations at the same time</strong>.</p>

      <h2><a href="#fiber-scheduler-implementation" id="fiber-scheduler-implementation">Fiber Scheduler implementation</a></h2>

      <p>The implementation is the second big part of the Fiber Scheduler feature.</p>

      <p>If you want to enable the asynchronous behavior in Ruby, you need to set a Fiber Scheduler object for the current thread. That&#39;s done with the <code>Fiber.set_scheduler(scheduler)</code> method. The implementation is commonly a class with all the <a href="https://docs.ruby-lang.org/en/3.1/Fiber/SchedulerInterface.html">Fiber::SchedulerInterface</a> methods defined.</p>

      <p><strong>Ruby does not provide a default Fiber Scheduler class, nor an object that could be used for that purpose.</strong> It seems unusual, but not including the Fiber Scheduler implementation with the language is actually a good <nobr>long-term</nobr> decision. It&#39;s best to leave this relatively <nobr>fast-evolving</nobr> concern outside the core Ruby.</p>

      <p>Writing a Fiber Scheduler class from scratch is a complex task, so it&#39;s recommended to use an existing solution. The list of implementations can be found at <a href="https://github.com/bruno-/fiber_scheduler_list">Fiber Scheduler List project</a>.</p>

      <h2><a href="#examples" id="examples">Examples</a></h2>

      <p>Let&#39;s see what&#39;s possible with just a Fiber Scheduler.</p>

      <p>All examples use Ruby 3.1 and <code>FiberScheduler</code> class from the <a href="https://github.com/bruno-/fiber_scheduler">fiber_scheduler</a> gem, which is maintained by yours truly. This gem is <em>not a hard dependency</em> for the examples, as every snippet below should still work if references to <code>FiberScheduler</code> are replaced with another Fiber Scheduler class.</p>

      <h3><a href="#basic-example" id="basic-example">Basic example</a></h3>

      <p>Here&#39;s a simple example:</p>

      <pre><code><span>require</span> <span>&#34;</span><span>fiber_scheduler</span><span>&#34;</span>
<span>require</span> <span>&#34;</span><span>open-uri</span><span>&#34;</span>

<span>Fiber</span>.set_scheduler(<span>FiberScheduler</span>.new)

<span>Fiber</span>.schedule <span>do</span>
  <span>URI</span>.open(<span>&#34;</span><span>https://httpbin.org/delay/2</span><span>&#34;</span>)
<span>end</span>

<span>Fiber</span>.schedule <span>do</span>
  <span>URI</span>.open(<span>&#34;</span><span>https://httpbin.org/delay/2</span><span>&#34;</span>)
<span>end</span></code></pre>

      <p>The above code is creating two fibers, each making an HTTP request. The requests run in parallel and the whole program finishes in 2 seconds.</p>

      <dl>
        <dt><code>Fiber.set_scheduler(FiberScheduler.new)</code></dt>
        <dd>Sets a Fiber Scheduler in the current thread which enables <code>Fiber.schedule</code> method to work, and fibers to behave asynchronously.</dd>
        <dt><code>Fiber.schedule { ... }</code></dt>
        <dd>This is a <nobr>built-in</nobr> Ruby method that starts new async fibers.</dd>
      </dl>

      <p><strong>The example uses only standard Ruby methods – both <code>Fiber.set_scheduler</code> and <code>Fiber.schedule</code> have been available since Ruby 3.0.</strong></p>

      <h3><a href="#advanced-example" id="advanced-example">Advanced example</a></h3>

      <p>Let&#39;s see what running a multitude of different operations looks like:</p>

      <pre><code><span>require</span> <span>&#34;</span><span>fiber_scheduler</span><span>&#34;</span>
<span>require</span> <span>&#34;</span><span>httparty</span><span>&#34;</span>
<span>require</span> <span>&#34;</span><span>open-uri</span><span>&#34;</span>
<span>require</span> <span>&#34;</span><span>redis</span><span>&#34;</span>
<span>require</span> <span>&#34;</span><span>sequel</span><span>&#34;</span>

<span>DB</span> = <span>Sequel</span>.postgres
<span>Sequel</span>.extension(<span>:</span><span>fiber_concurrency</span>)

<span>Fiber</span>.set_scheduler(<span>FiberScheduler</span>.new)

<span>Fiber</span>.schedule <span>do</span>
  <span>URI</span>.open(<span>&#34;</span><span>https://httpbin.org/delay/2</span><span>&#34;</span>)
<span>end</span>

<span>Fiber</span>.schedule <span>do</span>
  
  <span>HTTParty</span>.get(<span>&#34;</span><span>https://httpbin.org/delay/2</span><span>&#34;</span>)
<span>end</span>

<span>Fiber</span>.schedule <span>do</span>
  
  <span>Redis</span>.new.blpop(<span>&#34;</span><span>abc123</span><span>&#34;</span>, <span>2</span>)
<span>end</span>

<span>Fiber</span>.schedule <span>do</span>
  
  <span>DB</span>.run(<span>&#34;</span><span>SELECT pg_sleep(2)</span><span>&#34;</span>)
<span>end</span>

<span>Fiber</span>.schedule <span>do</span>
  sleep <span>2</span>
<span>end</span>

<span>Fiber</span>.schedule <span>do</span>
  
  <span>`</span><span>sleep 2</span><span>`</span>
<span>end</span></code></pre>

      <p>If we ran this program sequentially it would take about 12 seconds to finish. But as the operations run in parallel, the total running time is just over 2 seconds.</p>

      <p>You&#39;re not constrained to making just HTTP requests. <strong>Any blocking operation that&#39;s built into Ruby or implemented by an external gem works!</strong></p>

      <h3><a href="#scaling-example" id="scaling-example">Scaling example</a></h3>

      <p>Here&#39;s a simple, although synthetic example running ten thousand operations at the same time.</p>

      <pre><code><span>require</span> <span>&#34;</span><span>fiber_scheduler</span><span>&#34;</span>

<span>Fiber</span>.set_scheduler(<span>FiberScheduler</span>.new)

<span>10_000</span>.times <span>do</span>
  <span>Fiber</span>.schedule <span>do</span>
    sleep <span>2</span>
  <span>end</span>
<span>end</span></code></pre>

      <p>The code above completes in slightly more than 2 seconds.</p>

      <p>The <code>sleep</code> method was chosen for the scaling example due to its low overhead. If we used network requests the execution time would be longer because of the overhead of setting up thousands of connections and performing SSL handshakes etc.</p>

      <p>One of the main benefits of asynchronous programming is waiting on many blocking operations at the same time. <strong>The benefits increase as the number of blocking operations grows. Luckily, it&#39;s super easy to run large numbers of fibers.</strong></p>

      <h2><a href="#conclusion" id="conclusion">Conclusion</a></h2>

      <p><strong>Ruby can work asynchronously with just a Fiber Scheduler and a couple <nobr>built-in</nobr> methods – no frameworks are required!</strong></p>

      <p>It&#39;s easy to make it work. Choose a <a href="https://github.com/bruno-/fiber_scheduler_list">Fiber Scheduler implementation</a>, and then use these methods:</p>

      <ul>
        <li><code>Fiber.set_scheduler(scheduler)</code> sets a Fiber Scheduler for the current thread, enables blocking operations to behave async.</li>
        <li><code>Fiber.schedule { ... }</code> starts a new fiber that runs concurrently with other fibers.</li>
      </ul>

      <p>Once you get it going, you can <strong>make any code asynchronous by wrapping it in a <code>Fiber.schedule</code> block</strong>.</p>

      <pre><code><span>Fiber</span>.schedule <span>do</span>
  <span>SynchronousCode</span>.run
<span>end</span></code></pre>

      <p>Whole libraries can easily be converted to async with this approach, and it rarely takes more effort than shown here.</p>

      <p><strong>The big benefit of asynchronous programming is parallelizing blocking/waiting operations to reduce the program running time.</strong> This often translates into running more operations on a single CPU, or even better, handling more requests with your web server.</p>

      <p>Happy hacking with Fiber Scheduler!</p>
    </article>
  </div></div>
  </body>
</html>
