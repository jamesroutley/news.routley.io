<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://abstract.properties/explicit-resource-management-is-great.html">Original</a>
    <h1>JavaScript&#39;s upcoming Explicit Resource Management is great!</h1>
    
    <div id="readability-page-1" class="page"><div>
                    <p>I&#39;ve been using the <a href="https://github.com/justjake/quickjs-emscripten">quickjs-emscripten</a> package a bit recently. It&#39;s a
Web Assembly compiled wrapper around <a href="https://bellard.org/quickjs/">Fabrice Bellard&#39;s QuickJS</a>, a small &amp; modern
JavaScript engine.</p>
<p>This allows me to execute sandboxed JavaScript in an environment that is completely controlled!</p>
<p>For example, here&#39;s some code showing how arbitrary JavaScript code can be evaluated safely. It isolates the code so it
doesn&#39;t have access to the outside environment with the exception of a special <code>location.search</code> global variable, which
reflects the browser&#39;s query string as a readonly value.</p>
<p>It also tracks reads to that query string in an <code>accessLog</code>:</p>
<div><p><code>safeEval.ts</code></p><pre><span>import</span> { getQuickJS } <span>from</span> <span>&#39;quickjs-emscripten&#39;</span>;

<span>async</span> <span>function</span> <span>safeEval</span>(<span><span>code</span>: <span>string</span></span>) {
    <span>const</span> <span>QuickJS</span> = <span>await</span> <span>getQuickJS</span>();
    <span>const</span> runtimeStart = <span>Date</span>.<span>now</span>();
    <span>const</span> runtime = <span>QuickJS</span>.<span>newRuntime</span>({
        <span>interruptHandler</span>: <span>() =&gt;</span> {
            
            <span>return</span> <span>Date</span>.<span>now</span>() - runtimeStart &gt; <span>100</span>;
        },
    });
    <span>const</span> ctx = runtime.<span>newContext</span>();

    
    <span>const</span> <span>accessLog</span>: <span>string</span>[] = [];

    
    
    
    <span>const</span> locationHandle = ctx.<span>newObject</span>();
    ctx.<span>setProp</span>(ctx.<span>global</span>, <span>&#39;location&#39;</span>, locationHandle);
    ctx.<span>defineProp</span>(locationHandle, <span>&#39;search&#39;</span>, {
        <span>configurable</span>: <span>false</span>,
        <span>enumerable</span>: <span>true</span>,
        <span>get</span>: <span>() =&gt;</span> {
            
            accessLog.<span>push</span>(<span>&#39;search&#39;</span>);
            
            <span>return</span> ctx.<span>newString</span>(<span>window</span>.<span>location</span>.<span>search</span>);
        },
    });

    
    <span>const</span> result = ctx.<span>evalCode</span>(code, <span>&#39;untrusted.js&#39;</span>);

    <span>if</span> (result.<span>error</span>) {
        
        result.<span>error</span>.<span>dispose</span>();
        locationHandle.<span>dispose</span>();
        ctx.<span>dispose</span>();
        runtime.<span>dispose</span>();

        <span>throw</span> <span>new</span> <span>Error</span>(<span>&#39;Error executing code&#39;</span>);
    }

    
    <span>const</span> evaluationResult = ctx.<span>dump</span>(result.<span>unwrap</span>());

    
    result.<span>dispose</span>();
    locationHandle.<span>dispose</span>();
    ctx.<span>dispose</span>();
    runtime.<span>dispose</span>();

    
    <span>return</span> { evaluationResult, accessLog };
}
</pre></div>
<p>While this works great, it&#39;s a bit awkward to use because it requires explicit disposal of &#34;handle&#34; objects that
reference values inside of the QuickJS engine.</p>
<p>See all those <code>.dispose()</code> calls? If one is missed, it causes a memory leak.</p>
<p>And to make matters worse, sometimes you need to exit early, or catch exceptions, or do all sorts of things which make
it complicated to keep track of all of the objects that need to be <code>.dispose()</code>d.</p>

<p>No need to fret, <a href="https://github.com/tc39/proposal-explicit-resource-management">Explicit Resource Management</a> makes
this <strong>much easier</strong>!</p>
<p><a href="https://github.com/tc39/proposal-explicit-resource-management">Explicit Resource Management</a> is an ECMAScript language
proposal that introduces a new keyword <code>using</code>, which is similar to <code>const</code>, but is used to define <em>resources</em> that need
to be disposed when they leave scope.</p>
<p>It means that the above code could be rewritten as:</p>
<div><p><code>safeEval.ts</code></p><pre><span>import</span> { getQuickJS } <span>from</span> <span>&#39;quickjs-emscripten&#39;</span>;

<span>async</span> <span>function</span> <span>safeEval</span>(<span><span>code</span>: <span>string</span></span>) {
    <span>const</span> <span>QuickJS</span> = <span>await</span> <span>getQuickJS</span>();
    <span>const</span> runtimeStart = <span>Date</span>.<span>now</span>();

    
    <span>using</span> runtime = <span>QuickJS</span>.<span>newRuntime</span>({
        <span>interruptHandler</span>: <span>() =&gt;</span> {
            
            <span>return</span> <span>Date</span>.<span>now</span>() - runtimeStart &gt; <span>100</span>;
        },
    });
    <span>using</span> ctx = runtime.<span>newContext</span>();

    
    <span>const</span> <span>accessLog</span>: <span>string</span>[] = [];

    
    
    
    <span>using</span> locationHandle = ctx.<span>newObject</span>();
    ctx.<span>setProp</span>(ctx.<span>global</span>, <span>&#39;location&#39;</span>, locationHandle);
    ctx.<span>defineProp</span>(locationHandle, <span>&#39;search&#39;</span>, {
        <span>configurable</span>: <span>false</span>,
        <span>enumerable</span>: <span>true</span>,
        <span>get</span>: <span>() =&gt;</span> {
            
            accessLog.<span>push</span>(<span>&#39;search&#39;</span>);
            
            <span>return</span> ctx.<span>newString</span>(<span>window</span>.<span>location</span>.<span>search</span>);
        },
    });

    
    <span>using</span> result = ctx.<span>evalCode</span>(code, <span>&#39;untrusted.js&#39;</span>);

    <span>if</span> (result.<span>error</span>) {
        
        <span>throw</span> <span>new</span> <span>Error</span>(<span>&#39;Error executing code&#39;</span>);
    }

    
    <span>const</span> evaluationResult = ctx.<span>dump</span>(result.<span>unwrap</span>());

    
    <span>return</span> { evaluationResult, accessLog };
}
</pre></div>
<p>See that? No more <code>.dispose()</code> calls!</p>
<p>Regardless of <em>how</em> scope is left (here, variables may go out of scope when an exception is thrown or we return), the
objects are automatically disposed when execution leaves the syntactic scope.</p>
<p>And because this feature has reached <a href="https://tc39.es/process-document/">Stage 3</a>, it&#39;s both very likely to be coming soon to the standard language and can
be used today if you build your JavaScript.</p>
<a id="using-it-today" href="#using-it-today"><h3>Using it today</h3></a>
<p>I use <code>TypeScript</code>, <code>prettier</code>, <code>eslint</code>, <code>esbuild</code>, <code>vite</code>, and <code>neovim</code> to develop and build my code. And all of them fully
support this proposal and esbuild can produce code that performs disposal correctly in JS engines that haven&#39;t yet
implemented the functionality.</p>
<p>Here&#39;s how to get them working:</p>
<p><strong>TypeScript</strong>:</p>
<p>You must use <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-2.html#using-declarations-and-explicit-resource-management">TypeScript
5.2</a> or above.</p>
<p>Your <code>tsconfig.json</code> must have:</p>
<ul>
<li><code>compilerOptions.lib</code> containing <code>&#34;ES2019&#34;</code> and <code>&#34;esnext.disposable&#34;</code></li>
<li><code>compilerOptions.target</code> set to something lower than <code>&#34;esnext&#34;</code>, I use <code>&#34;ES2019&#34;</code> since 5 years old is a reasonable
target for my projects.</li>
</ul>
<p>My <code>tsconfig.json</code> looks like this:</p>
<div><p><code>tsconfig.json</code></p><pre>{
  <span>&#34;compilerOptions&#34;</span>: {
    <span>&#34;lib&#34;</span>: [<span>&#34;ES2019&#34;</span>, <span>&#34;esnext.disposable&#34;</span>, <span>&#34;DOM&#34;</span>],
    <span>&#34;target&#34;</span>: <span>&#34;ES2019&#34;</span>,
  },
  
}
</pre></div>
<p><strong>prettier</strong>:</p>
<p>Supported out of the box in <a href="https://github.com/prettier/prettier/blob/main/CHANGELOG.md#303">prettier version 3.0.3</a> or
later.</p>
<p><strong>eslint</strong>:</p>
<p>I use <code>typescript-eslint/parser</code>, which got support in <a href="https://github.com/typescript-eslint/typescript-eslint/blob/main/CHANGELOG.md#7131-2024-06-17">typescript-eslint version
7.13.1</a>.</p>
<p><strong>esbuild</strong>:</p>
<p>Implemented in <a href="https://github.com/evanw/esbuild/blob/main/CHANGELOG-2023.md#0187">version 0.18.17</a>, bugfixes in
<a href="https://github.com/evanw/esbuild/blob/main/CHANGELOG-2023.md#0189">version 0.18.19</a>.</p>
<p>You must specify a <a href="https://esbuild.github.io/api/#target">target</a> of something lower than <code>esnext</code>. Same with
TypeScript, I use <code>es2019</code>.</p>
<p><strong>vite</strong>:</p>
<p>Since vite uses esbuild under the hood to bundle, you&#39;ll need to set a target of <code>es2019</code> (or whatever works best for
you) when building:</p>
<div><p><code>vite.config.js</code></p><pre><span>import</span> { defineConfig } <span>from</span> <span>&#39;vite&#39;</span>;


<span>export</span> <span>default</span> <span>defineConfig</span>({
    <span>base</span>: <span>&#39;./&#39;</span>,
    <span>build</span>: {
        <span>assetsDir</span>: <span>&#39;./&#39;</span>,
        <span>target</span>: <span>&#39;es2019&#39;</span>,
    },
    <span>esbuild</span>: {
        <span>target</span>: <span>&#39;es2019&#39;</span>,
    },
});
</pre></div>
<p><strong>vim/neovim</strong>:</p>
<p>To get the <code>using</code> keyword working correctly, you need to tell vim/neovim that <code>using</code> is a keyword.</p>
<p>There&#39;s probably a better way to do this, but what I ended up doing was adding two files (<code>~/.config/nvim/after/syntax/javascript.vim</code> and <code>~/.config/nvim/after/syntax/typescript.vim</code>) with the same contents:</p>
<div><p><code>javascript.vim</code></p><pre>syn keyword esNextKeyword using
<span>hi</span> def link esNextKeyword Keyword
</pre></div>
<p>This tells vim that <em>after</em> loading the syntax files for javascript/typescript (and javascriptreact/typescriptreact),
it should treat <code>using</code> as a new keyword in a class named <code>esNextKeyword</code>. And link that new class to the <code>Keyword</code>
definition.</p>

<p><strong>Note</strong>: Stage 3 is not a guarantee that it will ship as-is in browsers and other JavaScript engines.</p>
<p>I personally
think it <em>will</em> ship, since it will lead to standardizing a well-known pattern (RAII) found in other languages.</p>
<a id="resources-holding-resources" href="#resources-holding-resources"><h3>Resources holding resources</h3></a>
<p>The nice thing about this proposal is that it&#39;s <em>just enough</em> of a change to allow for new patterns to emerge.</p>
<p>Say you&#39;ve got a class which owns and manages a set of resources. The problem is now that class instances needs to
dispose of its resources when it&#39;s no longer used.</p>
<p>Now you can just add a <code>Symbol.dispose</code> method on your class, and it can be disposed in the same way as the resources it
manages.</p>
<p>This pattern looks like this:</p>
<div><pre><span>class</span> <span>ResourceManager</span> <span>implements</span> <span>Disposable</span> {
  

  <span>resource1</span>: <span>SomeResource</span>;
  <span>resource2</span>: <span>SomeOtherResource</span>;

  <span>constructor</span>(<span></span>) {
    
    <span>this</span>.<span>resource1</span> = <span>allocateSomeResource</span>();
    <span>this</span>.<span>resource2</span> = <span>allocateSomeOtherResource</span>();
  }

  [<span>Symbol</span>.<span>dispose</span>]() {
    <span>this</span>.<span>resource1</span>[<span>Symbol</span>.<span>dispose</span>]();
    <span>this</span>.<span>resource2</span>[<span>Symbol</span>.<span>dispose</span>]();
  }
}

<span>function</span> <span>doWork</span>(<span></span>) {
  <span>using</span> manager = <span>new</span> <span>ResourceManager</span>();
  
  <span>return</span>; 
}
</pre></div>
<p>This lets us do <a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">RAII</a> in JavaScript easily, which
can help avoid resource leaks and better standardize the structure of code that manages resources.</p>

                </div></div>
  </body>
</html>
