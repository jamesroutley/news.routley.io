<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://devblogs.microsoft.com/oldnewthing/20231103-00/?p=108966">Original</a>
    <h1>Why does unsafe multithreaded std:unordered_map crash more than std:map?</h1>
    
    <div id="readability-page-1" class="page"><div id="featured">

	<div>
                         <p>
            November 3rd, 2023</p><!-- .entry-meta -->
        <p>A customer had some code that used a <code>std::<wbr/>map</code>, and they found that when they switched to <code>std::<wbr/>unordered_<wbr/>map</code> it began to crash a lot more than it did before. Eventually, they traced the problem back to unsafe multithreaded access to the collection, but they wondered why the rate of crashes shot up when they used <code>std::<wbr/>unordered_<wbr/>map</code>. What makes <code>std::<wbr/>unordered_<wbr/>map</code> more susceptible to multithreading problems?</p>
<p>First, let’s reiterate that unsafe multithreaded access to C++ standard library containers is <i>undefined behavior</i>. Simultaneous read operations are safe for multithreading, but simultaneous writes or a read and write occurring simultaneously are unsafe for multithreading. The customer understood that their code was broken either way. They just were curious why <code>unordered_<wbr/>map</code> seems to demonstrate the problem more clearly.</p>
<p>Recall that <a title="Inside STL: The map, set, multimap, and multiset" href="https://devblogs.microsoft.com/oldnewthing/20230807-00/?p=108562"> <code>std::map</code> is typically implemented as a red-black tree</a>. Inserting or erasing an element from a red-black tree is a sequence of up to <var>O</var>(log <var>n</var>) tree operations. Each tree operation affects a small number of nodes, so concurrent modifications have a relatively low chance of modifying the same node at the same time. Even if they don’t modify the same node at the same time, they might still leave the tree in a bad state, but my gut tells me that the most likely consequence would be incorrect results, like failing to find an element that should be there, or having two entries with the same key.</p>
<p>On the other hand, <a title="Inside" href="https://devblogs.microsoft.com/oldnewthing/20230808-00/?p=108572"> <code>std::<wbr/>unordered_<wbr/>map</code> is typically implemented as a hash table with separate chaining</a>. Inserting or erasing an element from a hash table is usually <var>O</var>(1), and the operation affects only two nodes (the node being inserted/erased and its neighbor). Concurrent modifications have a relatively low chance of modifying the same node at the same time, with the note that concurrent modifications could still leave the hash table in a bad state.</p>
<p>I noted that inserting or erasing <code>std::<wbr/>unordered_<wbr/>map</code> is <i>usually</i> <var>O</var>(1). But sometimes it’s <var>O</var>(<var>n</var>). This happens when the hash table needs to be rehashed and the buckets rebuilt. In this case, every element of the hash table is moved to a new bucket, and any attempt to access the hash table during a rehash operation is going to see a hash table in disarray. This is the case that makes concurrent unsafe access <code>std::<wbr/>unordered_<wbr/>map</code> highly likely to crash.</p>
<p>In summary: The <code>std::<wbr/>map</code> has a uniformly low risk of crashing, whereas <code>std::<wbr/>unordered_map</code> has a generally low risk of crashing, but once in a while, it has a very high risk of crashing. And it’s probably that “once in a while” that is causing the crash rates to spike.</p>
<p><b>Bonus chatter</b>: I reiterate that the problem lies in the unsafe concurrent access, and that’s what needs to be fixed. A low risk of crashing is not the same as zero risk of crashing. Even the old code was crashing. It was just crashing at a relatively low rate, and the switch to <code>std::<wbr/>unordered_map</code> caused the crash rate to skyrocket. The customer understood this and was just curious why a change in data structure led to a very noticeable change in failure rates.</p>

        

		
        
	</div><!-- .entry-content -->

</div></div>
  </body>
</html>
