<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.jcoglan.com/2017/05/08/merging-with-diff3/">Original</a>
    <h1>Merging with diff3: the “three-way merge”</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p>If you enjoy this article, I have published a book explaining the
  internals of Git through implementation: <a href="https://shop.jcoglan.com/building-git/">Building Git</a>.</p>

<p>—</p>

<p>Over the course of the last few articles, we’ve investigated how <a href="https://git-scm.com/">Git</a> calculates
diffs between different versions of a file, first looking at the <a href="https://blog.jcoglan.com/2017/02/12/the-myers-diff-algorithm-part-1/">Myers diff
algorithm</a> and then its <a href="https://blog.jcoglan.com/2017/03/22/myers-diff-in-linear-space-theory/">linear space variant</a>. As a programmer, you are
probably most familiar with diffs as a way for you to see what’s changed; you
see them whenever you run the <code>git diff</code> or <code>git show</code> commands, or when you use
GitHub’s compare view or read a pull request. But diffs aren’t only for human
consumption, although their design is strongly influenced by human expectations.
They also form an ingredient in other computations that Git has to perform, the
most common one being merging.</p>

<p>Merging happens whenever two or more concurrent branches have modified the same
file, and we want to reconcile all those changes into a single final version.
Say Alice and Bob have both forked from the master branch of a project, where a
version of some file exists; we will call this version <code>v1</code>. Alice modifies the
file on their branch, producing version <code>v2</code> of the file, and Bob makes a
different change to their copy, producing yet another version <code>v3</code>.</p>

<div><div><pre><code>                     -------o [alice]
                   /       v2
                 /
      [master] o
              v1 \
                   \
                     -------o [bob]
                           v3
</code></pre></div></div>

<p>We now want to merge the branches back together, reconciling both Alice’s and
Bob’s changes to produce a final version, <code>v4</code>.</p>

<div><div><pre><code>                     -------o------
                   /       v2       \
                 /                    \
      [master] o                        o v4
              v1 \                    /
                   \                /
                     -------o------
                           v3
</code></pre></div></div>

<p>Merging is the process that takes <code>v2</code> and <code>v3</code> and combines them to find this
final version. When you use Git, you might not think much about how this process
works, because most of the time it does just what you expect. Multiple people
can change different sections of the same file and all their edits are
incorporated. But a moment’s thought suggests something more complex is going
on; it’s not sufficient to say something like “Alice added something on line 3
and Bob deleted line 5”, because Alice adding something on line 3 moves all the
lines following it. Deleting whatever is now at line 5 after applying that
change would not remove the content Bob intended, in fact it might even delete
something Alice added!</p>

<p>This problem reveals the core problem with merging: we don’t know what order to
apply changes in. If we apply the operation “delete line 5” first, then the
meaning of “insert something at line 3” is probably unchanged, whereas if we
perform the insertion first, then “delete line 5” probably needs adjusting
somehow to take the changed line offsets into account, and it may no longer make
sense as an operation any more. Merge conflicts arise because the commit graph
is <em>partially ordered</em>; when commits occur on concurrent branches we don’t know
which order they should be interpreted in. Nevertheless, this model of changes
is commonly used in applications like real-time collaborative editing, and goes
by the name <a href="https://en.wikipedia.org/wiki/Operational_transformation">operational transformation</a>. There are many different protocols
for it that depend on the type of data being modified and the interaction model
for collaboration.</p>

<p>Some version control systems use this model, and their primary means of storing
commits represents them as diffs or patches. But Git doesn’t use that model; it
stores commits as complete snapshots of your content, rather than storing the
differences between versions. If it doesn’t store changes, how can it merge
them? Well, another way to merge changes is to take the two versions you want to
merge, and compare them to the last version they had in common, effectively
reconstructing the set of changes from the texts themselves. These diffs are
then used to merge the two versions together relative to their common ancestor.</p>

<p>To perform this task, Git and many other version control systems use the <code>diff3</code>
algorithm. <a href="https://linux.die.net/man/1/diff3"><code>diff3</code></a> is a Unix utility originally created in 1988 by Randy
Smith, and described formally in a <a href="http://www.cis.upenn.edu/~bcpierce/papers/diff3-short.pdf">paper by Sanjeev Khanna, Keshav Kunal
and Benjamin C. Pierce</a>. The algorithm takes as input three texts: the two
versions to be merged, and the original version they both derive from, and
produces a single merged version, which may contain conflicts if some sections
have been edited by both parties. The use of three files means this process is
referred to as a <em>three-way merge</em>.</p>

<p>Let’s walk through an example to see how it works. This is adapted from the one
given in section 2 of the Khanna, Kunal and Pierce paper. Say Alice and Bob are
part of a team developing a recipe book. One of the recipes is for a fish soup
and includes the following list of ingredients:</p>

<div><div><pre><code>                          1. celery
                          2. garlic
                          3. onions
                          4. salmon
                          5. tomatoes
                          6. wine
</code></pre></div></div>

<p>Now, Alice and Bob are both going through the book and making edits. They each
get their own copy of the original version and make some changes to it. Alice
takes <code>garlic</code> and <code>onions</code> and moves them to appear after <code>tomatoes</code> in the
list, while Bob moves <code>salmon</code> to appear second.</p>

<div><div><pre><code>         Alice               Original            Bob

      1. celery           1. celery           1. celery
      2. salmon           2. garlic           2. salmon
      3. tomatoes         3. onions           3. garlic
      4. garlic           4. salmon           4. onions
      5. onions           5. tomatoes         5. tomatoes
      6. wine             6. wine             6. wine
</code></pre></div></div>

<p>To merge the changes made by Alice and Bob into a single document, the first
thing diff3 does is calculate a diff between the original copy and Alice’s
version, and between the original and Bob’s. The algorithm used to calculate the
diff can make a big difference to the result of the merge, as we’ll see later,
but for now let’s assume the diffs come out as follows. Here is Alice’s:</p>

<div><div><pre><code>         Alice               Original

      1. celery           1. celery
<span>-                         2. garlic                           
-                         3. onions                           
</span>      2. salmon           4. salmon
      3. tomatoes         5. tomatoes
<span>+     4. garlic                                               
+     5. onions                                               
</span>      6. wine             6. wine
</code></pre></div></div>

<p>And here is Bob’s:</p>

<div><div><pre><code>                             Original            Bob

                          1. celery           1. celery
<span>+                                             2. salmon       
</span>                          2. garlic           3. garlic
                          3. onions           4. onions
<span>-                         4. salmon                           
</span>                          5. tomatoes         5. tomatoes
                          6. wine             6. wine
</code></pre></div></div>

<p>Once we have these diffs, the next thing we do is find any lines that are
unchanged in both diffs. If you look at the diffs above you’ll see that they
both have matching line content for <code>celery</code> (line 1 in all versions),
<code>tomatoes</code> (line 3 in Alice’s version, line 5 in the others), and <code>wine</code> (line 6
in all versions). We align the lines of the documents into chunks, so that these
unchanged lines are matched up:</p>

<div><div><pre><code>         Alice               Original            Bob

      1. celery           1. celery           1. celery         A
      -----------------------------------------------------------
                          2. garlic           2. salmon         B
      2. salmon           3. onions           3. garlic
                          4. salmon           4. onions
      -----------------------------------------------------------
      3. tomatoes         5. tomatoes         5. tomatoes       C
      -----------------------------------------------------------
      4. garlic                                                 D
      5. onions
      -----------------------------------------------------------
      6. wine             6. wine             6. wine           E
</code></pre></div></div>

<p>Having done this, the merge result is generated by scanning through these
chunks. For chunks where all three versions agree – chunks A, C and E above –
we can just output the original text since neither Alice nor Bob changed it. For
chunks like B where both Alice and Bob differ from the original, we have a
conflict; the merge algorithm, having no understanding of the meaning of the
text, cannot decide how to resolve this and the conflict is emitted for the user
to resolve by hand. In contrast, in chunk D Bob’s version is equal to the
original (in this case it is empty) while Alice’s differs. In chunks like this
where only one new version differs from the original, we pick the version that
changed.</p>

<p>To summarise, for each block we emit the following:</p>

<ul>
  <li>A: all equal; emit <code>celery</code></li>
  <li>B: Both differ; emit all versions as a conflict</li>
  <li>C: all equal; emit <code>tomatoes</code></li>
  <li>D: Alice differs; emit <code>garlic</code>, <code>onions</code></li>
  <li>E: all equal: emit <code>wine</code></li>
</ul>

<p>When Git emits these results as into the target file, conflicts are denoted by a
<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> line, followed by Alice’s version, then <code>=======</code> followed by Bob’s
version, then a <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> line:</p>

<div><div><pre><code>      celery
      &lt;&lt;&lt;&lt;&lt;&lt;&lt; Alice
      salmon
      =======
      salmon
      garlic
      onions
      &gt;&gt;&gt;&gt;&gt;&gt;&gt; Bob
      tomatoes
      garlic
      onions
      wine
</code></pre></div></div>

<p>If you set <code>merge.conflictStyle = diff3</code> in your Git config, or use the
standalone <code>diff3</code> program, you’ll also see the original version of a conflicted
chunk, denoted by the <code>|||||||</code> line:</p>

<div><div><pre><code>      celery
      &lt;&lt;&lt;&lt;&lt;&lt;&lt; Alice
      salmon
      ||||||| Original
      garlic
      onions
      salmon
      =======
      salmon
      garlic
      onions
      &gt;&gt;&gt;&gt;&gt;&gt;&gt; Bob
      tomatoes
      garlic
      onions
      wine
</code></pre></div></div>

<p>Now that we understand at a high level how the algorithm works, let’s look at
implementing it. I’m going to create a class for doing this, since the
algorithm uses several bits of state that I’d rather store as instance
variables, rather than passing them between functions. We’ll start by creating a
<code>Diff3.merge</code> method that takes <code>o</code>, <code>a</code> and <code>b</code>; the original version and the
two copies to be merged. It also takes an optional argument called <code>differ</code> that
specifies the diff algorithm to use, this will default to our <a href="https://blog.jcoglan.com/2017/04/25/myers-diff-in-linear-space-implementation/">linear Myers diff
implementation</a>.</p>

<p>This class will take three <code>Merge::File</code> objects, each of which has a <code>name</code> and
a list of <code>Line</code> objects. We wrap the files up like this because if we need to
display a merge conflict, it’s useful to display the filename (or commit ID or
message) of each changed version in the final output. Let’s create that
structure and a helper function for creating one from a file path.</p>

<div><div><pre><code><span>module</span> <span>Merge</span>
  <span>File</span> <span>=</span> <span>Struct</span><span>.</span><span>new</span><span>(</span><span>:name</span><span>,</span> <span>:lines</span><span>)</span>

  <span>def</span> <span>self</span><span>.</span><span>file</span><span>(</span><span>path</span><span>)</span>
    <span>lines</span> <span>=</span> <span>Diff</span><span>.</span><span>lines</span><span>(</span><span>::</span><span>File</span><span>.</span><span>read</span><span>(</span><span>path</span><span>))</span>
    <span>File</span><span>.</span><span>new</span><span>(</span><span>path</span><span>,</span> <span>lines</span><span>)</span>
  <span>end</span>
<span>end</span>
</code></pre></div></div>

<p>After creating a new <code>Diff3</code> object we call <code>merge</code> on it, which is going to set
up some initial state, then generate the output chunks, and then return a new
<code>Merge</code> object containing those chunks. We’ll see the <code>Merge</code> class in more
detail later.</p>

<div><div><pre><code><span>class</span> <span>Diff3</span>
  <span>def</span> <span>self</span><span>.</span><span>merge</span><span>(</span><span>o</span><span>,</span> <span>a</span><span>,</span> <span>b</span><span>,</span> <span>differ: </span><span>MyersLinear</span><span>)</span>
    <span>new</span><span>(</span><span>o</span><span>,</span> <span>a</span><span>,</span> <span>b</span><span>,</span> <span>differ</span><span>).</span><span>merge</span>
  <span>end</span>

  <span>def</span> <span>initialize</span><span>(</span><span>o</span><span>,</span> <span>a</span><span>,</span> <span>b</span><span>,</span> <span>differ</span><span>)</span>
    <span>@o</span><span>,</span> <span>@a</span><span>,</span> <span>@b</span><span>,</span> <span>@differ</span> <span>=</span> <span>o</span><span>,</span> <span>a</span><span>,</span> <span>b</span><span>,</span> <span>differ</span>
  <span>end</span>

  <span>def</span> <span>merge</span>
    <span>setup</span>
    <span>generate_chunks</span>
    <span>Merge</span><span>.</span><span>new</span><span>(</span><span>@o</span><span>,</span> <span>@a</span><span>,</span> <span>@b</span><span>,</span> <span>@chunks</span><span>)</span>
  <span>end</span>
<span>end</span>
</code></pre></div></div>

<p>First, let’s look at the <code>setup</code> method, which initialises a few bits of state
needed to run the algorithm. It creates an empty list called <code>@chunks</code> that we
will append new chunks to as we discover them. Then it sets a <code>@line</code> variable
for each document <code>o</code>, <code>a</code> and <code>b</code> to record how far we have scanned through all
the documents; this begins at zero for all of them. Finally, we create two
“match sets” that record which lines in each version are equal to the original,
and identifies those matches by line number.</p>

<div><div><pre><code>  <span>def</span> <span>setup</span>
    <span>@chunks</span> <span>=</span> <span>[]</span>
    <span>@line_o</span> <span>=</span> <span>@line_a</span> <span>=</span> <span>@line_b</span> <span>=</span> <span>0</span>

    <span>@match_a</span> <span>=</span> <span>match_set</span><span>(</span><span>@a</span><span>)</span>
    <span>@match_b</span> <span>=</span> <span>match_set</span><span>(</span><span>@b</span><span>)</span>
  <span>end</span>

  <span>def</span> <span>match_set</span><span>(</span><span>file</span><span>)</span>
    <span>matches</span> <span>=</span> <span>{}</span>

    <span>@differ</span><span>.</span><span>diff</span><span>(</span><span>@o</span><span>.</span><span>lines</span><span>,</span> <span>file</span><span>.</span><span>lines</span><span>).</span><span>each</span> <span>do</span> <span>|</span><span>edit</span><span>|</span>
      <span>matches</span><span>[</span><span>edit</span><span>.</span><span>old_line</span><span>.</span><span>number</span><span>]</span> <span>=</span> <span>edit</span><span>.</span><span>new_line</span><span>.</span><span>number</span> <span>if</span> <span>edit</span><span>.</span><span>type</span> <span>==</span> <span>:eql</span>
    <span>end</span>

    <span>matches</span>
  <span>end</span>
</code></pre></div></div>

<p>For our ingredient list example above, the match sets will look like this: they
map line numbers in the original version to the line numbers that match them in
the <code>a</code> and <code>b</code> copies. We’ll use these to match up lines that are equal in all
versions as we scan through.</p>

<div><div><pre><code>    <span>@match_a</span> <span>=</span> <span>{</span> <span>1</span> <span>=&gt;</span> <span>1</span><span>,</span> <span>4</span> <span>=&gt;</span> <span>2</span><span>,</span> <span>5</span> <span>=&gt;</span> <span>3</span><span>,</span> <span>6</span> <span>=&gt;</span> <span>6</span> <span>}</span>
    <span>@match_b</span> <span>=</span> <span>{</span> <span>1</span> <span>=&gt;</span> <span>1</span><span>,</span> <span>2</span> <span>=&gt;</span> <span>3</span><span>,</span> <span>3</span> <span>=&gt;</span> <span>4</span><span>,</span> <span>5</span> <span>=&gt;</span> <span>5</span><span>,</span> <span>6</span> <span>=&gt;</span> <span>6</span> <span>}</span>
</code></pre></div></div>

<p>Now we come to the main body of the algorithm. The <code>generate_chunks</code> method
loops through a sequence of steps for finding and recording matching and
differing chunks until it’s reached the end of all the documents. Each turn of
the loop performs the following steps:</p>

<ul>
  <li>Find the start of the next non-matching chunk, returning <code>i</code> as the number
of lines away from our current position that is. (If we’re in a matching
chunk, then the end of that chunk will be the same number of lines away in
all three documents.)</li>
  <li>If <code>i</code> is 1, then we’re already in a non-matching chunk and we need to find
the start of the next matching one. We try to find the start of the next
matching chunk and record <code>o</code>, <code>a</code> and <code>b</code> as the line offset in each
document of the start of that chunk.
    <ul>
      <li>If we found a match and <code>a</code> and <code>b</code> are therefore set, we emit a chunk
up to the offsets we just found.</li>
      <li>Otherwise, there are no further matches and we emit the remainder of all
documents as the final chunk.</li>
    </ul>
  </li>
  <li>If <code>i</code> exists and is not 1, then we’ve found the start of the next non-match
and we can emit a chunk up to <code>i</code> steps from our current line offsets.</li>
  <li>If <code>i</code> does not exist, then we’ve searched to the end of all three documents
and we emit the remainder of all of them as the final chunk.</li>
</ul>

<p>Here is an implementation that draws that process out, leaving the
implementation of finding the next match or mismatch, and emitting chunks, to
other methods.</p>

<div><div><pre><code>  <span>def</span> <span>generate_chunks</span>
    <span>loop</span> <span>do</span>
      <span>i</span> <span>=</span> <span>find_next_mismatch</span>

      <span>if</span> <span>i</span> <span>==</span> <span>1</span>
        <span>o</span><span>,</span> <span>a</span><span>,</span> <span>b</span> <span>=</span> <span>find_next_match</span>

        <span>if</span> <span>a</span> <span>and</span> <span>b</span>
          <span>emit_chunk</span><span>(</span><span>o</span><span>,</span> <span>a</span><span>,</span> <span>b</span><span>)</span>
        <span>else</span>
          <span>emit_final_chunk</span>
          <span>return</span>
        <span>end</span>

      <span>elsif</span> <span>i</span>
        <span>emit_chunk</span><span>(</span><span>@line_o</span> <span>+</span> <span>i</span><span>,</span> <span>@line_a</span> <span>+</span> <span>i</span><span>,</span> <span>@line_b</span> <span>+</span> <span>i</span><span>)</span>

      <span>else</span>
        <span>emit_final_chunk</span>
        <span>return</span>
      <span>end</span>
    <span>end</span>
  <span>end</span>
</code></pre></div></div>

<p>Now we just need the methods for finding the next match or mismatch, and for
emitting chunks.</p>

<p>To find the start of the next mismatch, we start a counter <code>i</code> at 1, and step
through each document line-by-line from our current position. If <code>i</code> has not
counted past the end of all the documents, and if the current line in all the
documents match, we increment <code>i</code> and keep looping. Once the loop stops, if <code>i</code>
is still within the bounds of any of the documents then we return it, otherwise
we return nothing.</p>

<p>The <code>match?</code> method works by using the match sets we created at the start of the
process. Rather than scanning through and comparing the actual text of the
documents for equality, we use these match sets as an index. We know that line
<code>(@line_a + i)</code> in document <code>@a</code> matches line <code>(@line_o + i)</code> in the original,
if <code>@match_a</code> contains a mapping from the original line number to that in <code>@a</code>.</p>

<div><div><pre><code>  <span>def</span> <span>find_next_mismatch</span>
    <span>i</span> <span>=</span> <span>1</span>
    <span>while</span> <span>in_bounds?</span><span>(</span><span>i</span><span>)</span> <span>and</span>
          <span>match?</span><span>(</span><span>@match_a</span><span>,</span> <span>@line_a</span><span>,</span> <span>i</span><span>)</span> <span>and</span>
          <span>match?</span><span>(</span><span>@match_b</span><span>,</span> <span>@line_b</span><span>,</span> <span>i</span><span>)</span>
      <span>i</span> <span>+=</span> <span>1</span>
    <span>end</span>
    <span>in_bounds?</span><span>(</span><span>i</span><span>)</span> <span>?</span> <span>i</span> <span>:</span> <span>nil</span>
  <span>end</span>

  <span>def</span> <span>in_bounds?</span><span>(</span><span>i</span><span>)</span>
    <span>@line_o</span> <span>+</span> <span>i</span> <span>&lt;=</span> <span>@o</span><span>.</span><span>lines</span><span>.</span><span>size</span> <span>or</span>
    <span>@line_a</span> <span>+</span> <span>i</span> <span>&lt;=</span> <span>@a</span><span>.</span><span>lines</span><span>.</span><span>size</span> <span>or</span>
    <span>@line_b</span> <span>+</span> <span>i</span> <span>&lt;=</span> <span>@b</span><span>.</span><span>lines</span><span>.</span><span>size</span>
  <span>end</span>

  <span>def</span> <span>match?</span><span>(</span><span>matches</span><span>,</span> <span>offset</span><span>,</span> <span>i</span><span>)</span>
    <span>matches</span><span>[</span><span>@line_o</span> <span>+</span> <span>i</span><span>]</span> <span>==</span> <span>offset</span> <span>+</span> <span>i</span>
  <span>end</span>
</code></pre></div></div>

<p>For example, when we run this code at the beginning of our recipe example,
<code>@line_o</code>, <code>@line_a</code> and <code>@line_b</code> are all <code>0</code>. We run the loop with <code>i = 1</code>,
and checking the match sets we see that <code>@match_a[1] == 1</code> and <code>@match_b[1] ==
1</code>, so we try again with <code>i = 2</code>. On this turn, the value of <code>@match_b[2]</code> is
<code>3</code> and <code>@match_a</code> doesn’t even have an entry for <code>2</code>, so we’ve found the start
of a non-matching chunk. This value of <code>i</code> means the next non-matching chunk
begins on line 2 relative to our current position, so we can emit one line from
each document as a matching chunk. The <code>emit_chunk(@line_o + i, @line_a + i,
@line_b + i)</code> call in <code>generate_chunks</code> accomplishes this.</p>

<p>Finding the start of the next match is a little simpler. We start a counter <code>o</code>
at one more than our current <code>@line_o</code> offset, and we increment it until either
it exceeds the size of <code>@o</code> or until both match sets have an entry for that line
number, indicating that both diffs leave that line unchanged. We then return the
final value of <code>o</code>, and the corresponding line numbers from each match set. If
we didn’t find any matches, these latter two values will be <code>nil</code>.</p>

<div><div><pre><code>  <span>def</span> <span>find_next_match</span>
    <span>o</span> <span>=</span> <span>@line_o</span> <span>+</span> <span>1</span>
    <span>until</span> <span>o</span> <span>&gt;</span> <span>@o</span><span>.</span><span>lines</span><span>.</span><span>size</span> <span>or</span> <span>(</span><span>@match_a</span><span>.</span><span>has_key?</span><span>(</span><span>o</span><span>)</span> <span>and</span> <span>@match_b</span><span>.</span><span>has_key?</span><span>(</span><span>o</span><span>))</span>
      <span>o</span> <span>+=</span> <span>1</span>
    <span>end</span>
    <span>[</span><span>o</span><span>,</span> <span>@match_a</span><span>[</span><span>o</span><span>],</span> <span>@match_b</span><span>[</span><span>o</span><span>]]</span>
  <span>end</span>
</code></pre></div></div>

<p>Returning to our example, after emitting the first matching chunk, <code>@line_o</code>,
<code>@line_a</code> and <code>@line_b</code> are all <code>1</code>, and recall that the match sets are as
follows, the line numbers in <code>@o</code> appearing on the left-hand side of the arrows:</p>

<div><div><pre><code>    <span>@match_a</span> <span>=</span> <span>{</span> <span>1</span> <span>=&gt;</span> <span>1</span><span>,</span> <span>4</span> <span>=&gt;</span> <span>2</span><span>,</span> <span>5</span> <span>=&gt;</span> <span>3</span><span>,</span> <span>6</span> <span>=&gt;</span> <span>6</span> <span>}</span>
    <span>@match_b</span> <span>=</span> <span>{</span> <span>1</span> <span>=&gt;</span> <span>1</span><span>,</span> <span>2</span> <span>=&gt;</span> <span>3</span><span>,</span> <span>3</span> <span>=&gt;</span> <span>4</span><span>,</span> <span>5</span> <span>=&gt;</span> <span>5</span><span>,</span> <span>6</span> <span>=&gt;</span> <span>6</span> <span>}</span>
</code></pre></div></div>

<p>We start with <code>o = 2</code>. <code>@match_b</code> has an entry for <code>2</code> but <code>@match_a</code> does not,
so we try <code>o = 3</code>. Again, <code>@match_b</code> has an entry but <code>@match_a</code> does not, so we
try <code>o = 4</code>. This time, <code>@match_a</code> has an entry but <code>@match_b</code> does not. Finally
we try <code>o = 5</code> and see that both match sets contain an entry: <code>@match_a[5] = 3</code>
and <code>@match_b[5] = 5</code>. So, we return <code>[5, 3, 5]</code> in this instance and
<code>generate_chunks</code> calls <code>emit_chunk(5, 3, 5)</code>.</p>

<p>The methods for emitting chunks are what construct the output of the merge
algorithm, and keep the line offsets up to date, moving them to the end of the
chunk we just emitted in each document. <code>emit_chunk</code> creates a chunk from the
current line offsets up to a given index in each document, and then sets the
line offsets to the end of these ranges. We subtract one from all the offsets
we’re given because the diffs and the finder methods use 1-indexed line numbers,
but our <code>@line</code> variables are 0-indexed offsets from the start of each document.
<code>emit_final_chunk</code> just emits whatever is left from all the documents from their
current line offsets onwards.</p>

<div><div><pre><code>  <span>def</span> <span>emit_chunk</span><span>(</span><span>o</span><span>,</span> <span>a</span><span>,</span> <span>b</span><span>)</span>
    <span>write_chunk</span><span>(</span>
      <span>@line_o</span> <span>...</span> <span>o</span> <span>-</span> <span>1</span><span>,</span>
      <span>@line_a</span> <span>...</span> <span>a</span> <span>-</span> <span>1</span><span>,</span>
      <span>@line_b</span> <span>...</span> <span>b</span> <span>-</span> <span>1</span><span>)</span>

    <span>@line_o</span><span>,</span> <span>@line_a</span><span>,</span> <span>@line_b</span> <span>=</span> <span>o</span> <span>-</span> <span>1</span><span>,</span> <span>a</span> <span>-</span> <span>1</span><span>,</span> <span>b</span> <span>-</span> <span>1</span>
  <span>end</span>

  <span>def</span> <span>emit_final_chunk</span>
    <span>write_chunk</span><span>(</span>
      <span>@line_o</span> <span>..</span> <span>-</span><span>1</span><span>,</span>
      <span>@line_a</span> <span>..</span> <span>-</span><span>1</span><span>,</span>
      <span>@line_b</span> <span>..</span> <span>-</span><span>1</span><span>)</span>
  <span>end</span>
</code></pre></div></div>

<p>Finally, we reach the end of our chain of methods with <code>write_chunk</code>. This takes
a set of lines from each document and emits the appropriate kind of chunk
depending on their contents. If all three sets are equal, then we emit a <code>Clean</code>
chunk object containing the original version; if Alice’s chunk is equal to the
original then we emit Bob’s and vice versa; and if neither is equal then we emit
a <code>Conflict</code> chunk containing all three versions.</p>

<div><div><pre><code>  <span>def</span> <span>write_chunk</span><span>(</span><span>o_range</span><span>,</span> <span>a_range</span><span>,</span> <span>b_range</span><span>)</span>
    <span>o</span> <span>=</span> <span>@o</span><span>.</span><span>lines</span><span>[</span><span>o_range</span><span>].</span><span>map</span><span>(</span><span>&amp;</span><span>:text</span><span>)</span>
    <span>a</span> <span>=</span> <span>@a</span><span>.</span><span>lines</span><span>[</span><span>a_range</span><span>].</span><span>map</span><span>(</span><span>&amp;</span><span>:text</span><span>)</span>
    <span>b</span> <span>=</span> <span>@b</span><span>.</span><span>lines</span><span>[</span><span>b_range</span><span>].</span><span>map</span><span>(</span><span>&amp;</span><span>:text</span><span>)</span>

    <span>if</span> <span>o</span> <span>==</span> <span>a</span> <span>and</span> <span>o</span> <span>==</span> <span>b</span>
      <span>@chunks</span> <span>&lt;&lt;</span> <span>Clean</span><span>.</span><span>new</span><span>(</span><span>o</span><span>)</span>
    <span>elsif</span> <span>o</span> <span>==</span> <span>a</span>
      <span>@chunks</span> <span>&lt;&lt;</span> <span>Clean</span><span>.</span><span>new</span><span>(</span><span>b</span><span>)</span>
    <span>elsif</span> <span>o</span> <span>==</span> <span>b</span>
      <span>@chunks</span> <span>&lt;&lt;</span> <span>Clean</span><span>.</span><span>new</span><span>(</span><span>a</span><span>)</span>
    <span>else</span>
      <span>@chunks</span> <span>&lt;&lt;</span> <span>Conflict</span><span>.</span><span>new</span><span>(</span><span>o</span><span>,</span> <span>a</span><span>,</span> <span>b</span><span>)</span>
    <span>end</span>
  <span>end</span>
</code></pre></div></div>

<p>Once <code>generate_chunks</code> finishes looping, the <code>merge</code> method returns
<code>Merge.new(@o, @a, @b, @chunks)</code>, creating a data structure representing the
result of the whole process. That data structure comes with a <code>to_s</code> method for
turning the whole thing into a string that can be written back to a file, but
keeping it as a structure lets us inspect it, particularly to check whether the
merge was clean or not. While the <code>to_s</code> methods assume the original inputs were
a series of lines of text, exposing the merge result as a data structure allows
us to use this algorithm with other types of input.</p>

<p>We can also use these structures to generate the output text with added data
that isn’t necessary for the merge algorithm itself, for example the file or
commit names of the two versions being merged.</p>

<div><div><pre><code>  <span>Clean</span> <span>=</span> <span>Struct</span><span>.</span><span>new</span><span>(</span><span>:content</span><span>)</span> <span>do</span>
    <span>def</span> <span>to_s</span><span>(</span><span>*</span><span>)</span>
      <span>content</span><span>.</span><span>join</span><span>(</span><span>&#34;&#34;</span><span>)</span>
    <span>end</span>
  <span>end</span>

  <span>Conflict</span> <span>=</span> <span>Struct</span><span>.</span><span>new</span><span>(</span><span>:o</span><span>,</span> <span>:a</span><span>,</span> <span>:b</span><span>)</span> <span>do</span>
    <span>def</span> <span>to_s</span><span>(</span><span>a_name</span> <span>=</span> <span>&#34;&#34;</span><span>,</span> <span>b_name</span> <span>=</span> <span>&#34;&#34;</span><span>)</span>
      <span>text</span> <span>=</span> <span>&#34;&#34;</span>
      <span>separator</span><span>(</span><span>text</span><span>,</span> <span>&#34;&lt;&#34;</span><span>,</span> <span>a_name</span><span>)</span>
      <span>a</span><span>.</span><span>each</span> <span>{</span> <span>|</span><span>line</span><span>|</span> <span>text</span> <span>&lt;&lt;</span> <span>line</span> <span>}</span>
      <span>separator</span><span>(</span><span>text</span><span>,</span> <span>&#34;=&#34;</span><span>)</span>
      <span>b</span><span>.</span><span>each</span> <span>{</span> <span>|</span><span>line</span><span>|</span> <span>text</span> <span>&lt;&lt;</span> <span>line</span> <span>}</span>
      <span>separator</span><span>(</span><span>text</span><span>,</span> <span>&#34;&gt;&#34;</span><span>,</span> <span>b_name</span><span>)</span>
      <span>text</span>
    <span>end</span>

    <span>def</span> <span>separator</span><span>(</span><span>text</span><span>,</span> <span>char</span><span>,</span> <span>name</span> <span>=</span> <span>&#34;&#34;</span><span>)</span>
      <span>text</span> <span>&lt;&lt;</span> <span>char</span> <span>*</span> <span>7</span> <span>+</span> <span>&#34; &#34;</span> <span>+</span> <span>name</span> <span>+</span> <span>&#34;</span><span>\n</span><span>&#34;</span>
    <span>end</span>
  <span>end</span>

  <span>Merge</span> <span>=</span> <span>Struct</span><span>.</span><span>new</span><span>(</span><span>:o</span><span>,</span> <span>:a</span><span>,</span> <span>:b</span><span>,</span> <span>:chunks</span><span>)</span> <span>do</span>
    <span>def</span> <span>clean?</span>
      <span>chunks</span><span>.</span><span>grep</span><span>(</span><span>Conflict</span><span>).</span><span>empty?</span>
    <span>end</span>

    <span>def</span> <span>to_s</span>
      <span>chunks</span><span>.</span><span>map</span> <span>{</span> <span>|</span><span>chunk</span><span>|</span> <span>chunk</span><span>.</span><span>to_s</span><span>(</span><span>a</span><span>.</span><span>name</span><span>,</span> <span>b</span><span>.</span><span>name</span><span>)</span> <span>}.</span><span>join</span><span>(</span><span>&#34;&#34;</span><span>)</span>
    <span>end</span>
  <span>end</span>
</code></pre></div></div>

<p>We now have a complete implementation that we can use to merge data from
different sources, and print out the result:</p>

<div><div><pre><code><span>o</span> <span>=</span> <span>Merge</span><span>.</span><span>file</span><span>(</span><span>&#34;original.txt&#34;</span><span>)</span>
<span>a</span> <span>=</span> <span>Merge</span><span>.</span><span>file</span><span>(</span><span>&#34;alice.txt&#34;</span><span>)</span>
<span>b</span> <span>=</span> <span>Merge</span><span>.</span><span>file</span><span>(</span><span>&#34;bob.txt&#34;</span><span>)</span>

<span>merged</span> <span>=</span> <span>Diff3</span><span>.</span><span>merge</span><span>(</span><span>o</span><span>,</span> <span>a</span><span>,</span> <span>b</span><span>)</span>

<span>puts</span> <span>merged</span>

<span># =&gt;  celery</span>
<span>#     &lt;&lt;&lt;&lt;&lt;&lt;&lt; alice.txt</span>
<span>#     salmon</span>
<span>#     =======</span>
<span>#     salmon</span>
<span>#     garlic</span>
<span>#     onions</span>
<span>#     &gt;&gt;&gt;&gt;&gt;&gt;&gt; bob.txt</span>
<span>#     tomatoes</span>
<span>#     garlic</span>
<span>#     onions</span>
<span>#     wine</span>
</code></pre></div></div>

<p>While the <code>diff3</code> algorithm is relatively simple, it is highly sensitive to the
output of the underlying diff algorithm. The diffs calculated should not produce
different outcomes when the merge is clean, but they can lead to changes in the
conflicts you get, in some cases leading to conflicts that are deeply misleading
and surprising to the user. We’ll look at how this happens and what can be done
about it in future articles.</p>


  </div></div>
  </body>
</html>
