<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.yoshuawuyts.com/nesting-allocators/">Original</a>
    <h1>Nesting Arena Allocators in Rust</h1>
    
    <div id="readability-page-1" class="page"><article>
    <div itemprop="articleBody" id="markdown">
      
     
          <ol>
          
              <li>
                  <a href="https://blog.yoshuawuyts.com/nesting-allocators/#kinds-of-allocation">kinds of allocation</a>
                  
              </li>
          
              <li>
                  <a href="https://blog.yoshuawuyts.com/nesting-allocators/#nesting-allocators">nesting allocators</a>
                  
              </li>
          
              <li>
                  <a href="https://blog.yoshuawuyts.com/nesting-allocators/#passing-allocators">passing allocators</a>
                  
              </li>
          
              <li>
                  <a href="https://blog.yoshuawuyts.com/nesting-allocators/#scoped-allocators">scoped allocators</a>
                  
              </li>
          
              <li>
                  <a href="https://blog.yoshuawuyts.com/nesting-allocators/#conclusion">conclusion</a>
                  
              </li>
          
          </ol>
      
      <p>I regularly point people to Tmandry&#39;s 2021 post <a href="https://tmandry.gitlab.io/blog/posts/2021-12-21-context-capabilities"><em>&#34;Contexts and Capabilities in
Rust&#34;</em></a>.
While nobody is actively working on the design at the moment, it&#39;s more because
of prioritization than anything else. It seems like it could make certain usage
patterns a lot nicer in Rust, and one of those is probably working with custom
allocators.  I&#39;ve been working a lot with <a href="https://en.wikipedia.org/wiki/Slab_allocation">slab
allocators</a> recently, and I&#39;d
love it if they were easier to work with in Rust. So I wanted to take a moment
to talk about allocators, capabilities as a language feature, and why I believe
that would work well.</p>
<h2 id="kinds-of-allocation">Kinds of allocation</h2>
<p>Memory, at least semantically, is best thought of as a contiguous sequence of
bytes. Allocators manage these bytes and do the bookkeeping for who is using
what. Allocators can take any type of object (&#34;heterogenous types&#34;) and place
them in memory. And once we&#39;re done with an object, the allocator will reclaim
the memory. Because not all objects are the same size this can leave gaps in
memory, so occasionally the allocator spends some time reorganizing its
internals (think: defragmentation). In practical terms, every program wants to
have a single allocator to manage the <em>entire</em> program. This root allocator is
what we refer to as the <em>global allocator</em>.</p>
<p>But where global allocators are <em>great</em>, they are not <em>perfect</em>. Typically when
we write programs we&#39;ll see usage patterns in our main loop. For example: if
we&#39;re writing an HTTP server we will typically allocate data for the request
headers and body. And once that request is handled, we de-allocate it and
allocate a new request. We can use our knowledge of our usage patterns to handle
allocations in a more targeted way. The way we do this is by obtaining a
relatively large-ish chunk of memory from our <em>system allocator</em>, and then using
that as the heap space for our custom allocator. These custom allocators are
also known as <em>&#34;region-based allocators&#34;</em> or <em>&#34;arena allocators&#34;</em>. Their key
benefit is that their memory management strategies are very simple, which can
make allocations so cheap they might as well be free.</p>
<p>There are many different types of arena allocators, but these are the ones I use
the most:</p>
<ul>
<li><strong>slab allocators:</strong> For example the <a href="https://docs.rs/slab/latest/slab/">slab</a>
crate in Rust. This is ideal for when you perform many homogenous, short-lived
allocations over a longer period.</li>
<li><strong>bump allocators:</strong> For example the <a href="https://docs.rs/bumpalo/latest/bumpalo/">bumpalo</a> crate
in Rust. This is ideal for <em>phase-oriented allocations</em>, where you allocate a
number of heterogenous objects, say, on every iteration of a loop and then
de-allocate them at the end of it.</li>
</ul>
<p>While not every crate lends itself equally well to it, it&#39;s even possible to
combine arena allocators to further customize allocation behavior.</p>
<h2 id="nesting-allocators">Nesting Allocators</h2>
<p>The <a href="https://docs.rs/bumpalo/latest/bumpalo/">bumpalo</a> crate comes with an optional <a href="https://docs.rs/bumpalo/latest/bumpalo/collections/index.html"><code>collections</code>
feature</a> which
can be enabled to grant access to <code>String</code> and <code>Vec</code> types which are identical
to the stdlib&#39;s versions other than the fact that they allocate on the bump
allocator. Using it looks like this:</p>
<pre data-lang="rust"><code data-lang="rust"><span>use </span><span>bumpalo::{Bump, collections::Vec};
</span><span>
</span><span>let</span><span> b = Bump::new();                 </span><span>// Create a new bump allocator
</span><span>let</span><span> v: Vec&lt;</span><span>i32</span><span>&gt; = Vec::new_in(&amp;b);   </span><span>// Allocate on the bump allocator
</span></code></pre>
<p>This is an example of <em>nesting allocators</em>. The system allocator hosts the
bump allocator, and the bump allocator in turn hosts the vector. The main
downside of this is that we&#39;re not using <code>std::vec::Vec</code>, but have to use
bumpalo&#39;s custom vec implementation. That&#39;s not ideal, not just because we now
have a second <code>Vec</code> type, but because we also don&#39;t have other collection types
such as <code>HashMap</code>, <code>HashSet</code>, and every other type out there on crates.io.</p>
<h2 id="passing-allocators">Passing Allocators</h2>
<p>The plan is to solve this limitation via the nightly <code>allocator_api</code> feature in
the stdlib. This extends the stdlib with methods such as
<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.new_in"><code>Vec::new_in</code></a>
which can take a custom
<a href="https://doc.rust-lang.org/std/alloc/trait.Allocator.html"><code>Allocator</code></a> argument
to host the allocations in. I don&#39;t have any particular opinions about the exact
<code>Allocator</code> trait, but I do have opinions about the way this bubbles up to
collection types.</p>
<p>Roughly speaking, the current design adds a new allocator generic param to
collection types which defaults to the global allocator (<code>Vec&lt;T, A = GlobalAllocator&gt;</code>). In order to uniformly make use of this, every constructor
method for every collection type needs to provide new <code>_in</code> variants of their
existing collections. At first that seems reasonable; but it quickly runs into
issues.</p>
<p>The first issue is usage with macros, which we can probably overcome. Macros
like <code>vec!</code> perform allocations, and in order to work with custom allocators
they should probably take an optional third param for the allocator. The second
issue is a lot harder: traits can&#39;t take extra arguments. For example, if you
have an <code>&amp;str</code>, and you want to convert it to <code>String</code> but use a bump allocator
you can&#39;t keep using the existing <code>into</code> method. And because the <code>into</code> trait is
part of <code>core</code>, we can&#39;t just add a new <code>into_in</code> method to the <code>Into</code> trait
either. The only real option is probably a new trait in <code>alloc</code>:</p>
<pre data-lang="rust"><code data-lang="rust"><span>let</span><span> s = &#34;</span><span>hello</span><span>&#34;.</span><span>to_owned</span><span>();         </span><span>// 1. Uses the global allocator
</span><span>let</span><span> bump = Bump::new();
</span><span>let</span><span> s = &#34;</span><span>hello</span><span>&#34;.</span><span>to_owned_in</span><span>(&amp;bump); </span><span>// 2. Uses a bump allocator
</span><span>
</span><span>let</span><span> s: String = &#34;</span><span>hello</span><span>&#34;.</span><span>into</span><span>();     </span><span>// 1. Always uses the global allocator
</span><span>                                    </span><span>// 2. ❌ Unclear how to create a variant
</span><span>                                    </span><span>//    of this with a custom allocator
</span></code></pre>
<p>While the number of collection types and constructor methods are limited, things
can quickly spiral out of hand when we factor in <em>composition</em>. In order for
things to work uniformly across the ecosystem, every type which holds a <code>Vec</code>
internally would need a second <code>_in</code> variant for all of their constructors and
conversions. That kind of duplication is uncompelling, meaning it&#39;s likely we&#39;re
only going to see <em>some</em> types adopt support for custom allocation while the
majority doesn&#39;t. Not unlike how <code>#[no_std]</code> is not uniformly supported
throughout the crates ecosystem today.</p>
<h2 id="scoped-allocators">Scoped Allocators</h2>
<p>What we&#39;re really struggling with is that the global allocator acts, in a
capability-sense, as an <a href="https://github.com/sunfishcode/ambient-authority">ambient
authority</a>. Which is to say:
every function in Rust has access to the global allocator without functions
needing to take allocators explicitly as arguments. The allocator is just always
present. Except when we&#39;re in <code>#[no_std]</code> environments, where there is no
allocator. Or when we&#39;re trying to change which allocator we&#39;re trying to take.</p>
<p>The <code>_in</code> family of methods is an attempt to remedy the issue of having an ambient
allocator. But that has some drawbacks: most notably the bifurcation of APIs.
But also: it seems like that would be quite annoying to use. Manually having to
pass some form of <code>alloc</code> argument down to every function call doesn&#39;t exactly
seem ideal.</p>
<p>Instead <a href="https://tmandry.gitlab.io/blog/posts/2021-12-21-context-capabilities/">Tmandry&#39;s capabilities design</a> seems like a much more pleasant direction.
It acknowledges the existence of ambient capabilities, and instead just asks
that we express them at the signature level. Because they effectively function
as implicits, they just carry through to all argument in scope which need them:</p>
<pre data-lang="rust"><code data-lang="rust"><span>let</span><span> s = &#34;</span><span>hello</span><span>&#34;.</span><span>to_owned</span><span>();             </span><span>// 1. Uses the global allocator
</span><span>with alloc = Bump::new() {              
</span><span>    </span><span>let</span><span> s = &#34;</span><span>hello</span><span>&#34;.</span><span>to_owned_in</span><span>(&amp;bump); </span><span>// 2. Uses a bump allocator
</span><span>}
</span><span>
</span><span>let</span><span> s: String = &#34;</span><span>hello</span><span>&#34;.</span><span>into</span><span>();  </span><span>// 1. Always uses the global allocator
</span><span>with alloc = Bump::new() {
</span><span>    </span><span>let</span><span> s = &#34;</span><span>hello</span><span>&#34;.into;        </span><span>// 2. ✅ Uses a bump allocator       
</span><span>}
</span></code></pre>
<p>Compositions with functions and types would no longer require manually passing
allocators into arguments, but merely acknowledging the existence of an
allocator in the first place. That would mean we don&#39;t have to provide new <code>_in</code>
methods which take allocators, but instead we could keep using the existing
<code>new</code> methods with some minor modifications.</p>
<pre data-lang="rust"><code data-lang="rust"><span>// Vec&#39;s design on nightly today, providing both `new` and `new_in` methods
</span><span>impl </span><span>Vec&lt;T, A = Global&gt; {
</span><span>    </span><span>fn </span><span>new</span><span>() -&gt; </span><span>Self </span><span>{ ...  }
</span><span>}
</span><span>impl </span><span>Vec&lt;T, A&gt; {
</span><span>    </span><span>fn </span><span>new_in</span><span>(</span><span>alloc</span><span>: A) -&gt; </span><span>Self </span><span>{ ...  }
</span><span>}
</span><span>
</span><span>// A design of vec using capabilities, using just a single `new` method.
</span><span>impl </span><span>Vec&lt;T&gt;
</span><span>with alloc = Global,
</span><span>{
</span><span>    </span><span>fn </span><span>new</span><span>() -&gt; </span><span>Self </span><span>{}
</span><span>}
</span></code></pre>
<p>Obviously questions remain about how to exactly model capabilities. Many types
in the stdlib liberally make use of ambient capabilities (e.g. allocation,
filesystem, networking, etc.) which we&#39;d need to continue allowing to work as it
does today. But there is a question about how we can instead weave through
user-provided capabilities through the entire stdlib and crates.io ecosystem.
The answer requires having a way to continue relying on ambient capabilities,
but opt-out if you want to. Which is not entirely unlike <code>const</code>.</p>
<p>The final benefit to this is that this would solve one of the current blockers
we have for string-literals. The obvious design for that would be to allow the
<code>s</code> prefix on literals to create allocated strings. But because that would act
as a language built-in, there is an open question on how to make that work with
custom allocators. Using capabilities would provide a compelling solution for that:</p>
<pre data-lang="rust"><code data-lang="rust"><span>// Rust today
</span><span>let</span><span> s = String::from(&#34;</span><span>Chashu</span><span>&#34;);
</span><span>
</span><span>// With an `s` prefix, allocating on the global allocator
</span><span>let</span><span> s = s&#34;</span><span>Chashu</span><span>&#34;;
</span><span>
</span><span>// With an `s` prefix, allocating on a local allocator
</span><span>with alloc = Bump::new() {
</span><span>    </span><span>let</span><span> s = s&#34;</span><span>Chashu</span><span>&#34;;
</span><span>}
</span></code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>In this post we took a look at general allocation strategies, how allocations
can be nested today, which problems that approach has, and how we could simplify
that via the novel contexts/capabilities language-feature. The design of
contexts/capabilities is incomplete, so we intentionally didn&#39;t go too deep into
that. Instead we only touched on the top-level semantics, showing specifically
how it could be leveraged to overcome some of the problems we have with
allocation today.</p>
<p>Fundamentally capabilities don&#39;t provide anything <em>new</em>; they&#39;re just a fancy
way of passing arguments to functions. But I also believe that is their
strength. It is <em>just passing arguments to functions</em>. But with significantly
less code to write, no method duplication, the ability to play along with trait
impls, and a lot more clarity of <a href="https://blog.sunfishcode.online/no-ghosts/">what your function needs to function</a>.</p>
<p>I don&#39;t just think that capabilities could simplify the problem space for
allocators in Rust. I actually believe that it could be the canonical way in
which we solve the current <code>core</code>/<code>alloc</code>/<code>std</code> split in Rust. The <code>core</code>
library really is just <code>std</code> minus everything which relies on ambient
capabilities. If we could opt-out of relying on ambient capabilities in <code>std</code>,
the reason to have separate <code>core</code>, <code>alloc</code>, and <code>std</code> libraries should go away.</p>
<p>The other thought I want to share is that I believe capabilities such as
allocators are inherently <em>tree-structured</em>. I&#39;ve recently written about
<a href="https://blog.yoshuawuyts.com/tree-structured-concurrency/">tree-structured
concurrency</a>
explaining how concurrency is best thought of as a tree. But from the
operational semantics side of the language we now
<a href="https://www.ralfj.de/blog/2023/06/02/tree-borrows.html">tree-borrows</a> as well.
I feel like at a high-level thinking about program execution as a tree is
accurate, and we should be thinking of (nesting) capabilities such as allocators
as trees as well.</p>

    </div>
  </article></div>
  </body>
</html>
