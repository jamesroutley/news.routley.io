<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ahelwer.ca/post/2023-02-07-cpp-bugs-sanitized/">Original</a>
    <h1>Can sanitizers find the two bugs I wrote in C&#43;&#43;?</h1>
    
    <div id="readability-page-1" class="page"><div role="main">
  <div>
    <div>
      <article role="main">
        <p>A few days ago I published a short post about <a href="https://ahelwer.ca/post/2023-02-04-cpp-bugs">two bugs I wrote</a> while developing the C++ external scanner for <a href="https://ahelwer.ca/post/2023-01-11-tree-sitter-tlaplus">my TLA⁺ tree-sitter grammar</a>.
Reactions were mixed!
Many people were supportive, but there were of course the usual drive-by claims by developers that the bugs were trivial, they would’ve found &amp; fixed them inside of 20 minutes, and I was laughably incompetent for having written them in the first place.
Maybe so!
I’m a fan of formal methods primarily so I don’t <em>have</em> to be a genius to write correct code.
In that same vein of building tools to save us from ourselves, <a href="https://lobste.rs/s/ziwtjk/two_c_bugs_i_found#c_we0pip">one user suggested</a> building the tree-sitter grammar with the LLVM address &amp; undefined behavior sanitizers enabled.
I’d used valgrind a long time ago but had never played around with sanitizers.
I was also doing some closely-associated work to build the grammar for fuzzing with LLVM’s libFuzzer, so it seemed a fun detour to check whether those sanitizers would have saved me days of debugging pain!</p>
<h3 id="the-build-process">The build process</h3>
<p>Unless you want to enable this on your own tree-sitter grammar you can skip this section.
Usually tree-sitter grammars are built automatically when running <code>tree-sitter test</code> or <code>tree-sitter parse</code>.
However, the compilation flags <a href="https://github.com/tree-sitter/tree-sitter/issues/1246">are hardcoded in the CLI</a> so I needed to write a script to build it with the flags I wanted.
Thankfully tree-sitter grammars consist of only three relevant files: a gigantic generated <code>src/parser.c</code> file, a hand-written <code>src/scanner.cc</code> file, and a header file <code>src/tree_sitter/parser.h</code>.
These are all compiled into a shared library <code>tlaplus.so</code> which is loaded by the consuming program.
It was easy enough to compile <code>tlaplus.so</code> with clang, along with the <code>-fsanitize=address,undefined -fno-omit-frame-pointer</code> flags.</p>
<p><a href="https://github.com/tree-sitter/tree-sitter/issues/2017#issuecomment-1420812019">Supposedly</a> the environment variables <code>TREE_SITTER_DIR</code> or <code>TREE_SITTER_LIBDIR</code> can be used to set where tree-sitter CLI looks for the <code>tlaplus.so</code> file, but I couldn’t get those to work so just copied it to the default location <code>~/.cache/tree-sitter/lib/</code> (as a funny aside, while writing this up in the build script I managed to instead create a directory named <code>~</code> so had to figure out how to delete that without nuking home).</p>
<p>Time to let it rip!
I ran <code>node_modules/.bin/tree-sitter test</code>, and saw:</p>
<div><pre tabindex="0"><code data-lang="sh"><span><span>Error opening dynamic library <span>&#34;/home/ahelwer/.cache/tree-sitter/lib/tlaplus.so&#34;</span>
</span></span><span><span>
</span></span><span><span>Caused by:
</span></span><span><span>    /home/ahelwer/.cache/tree-sitter/lib/tlaplus.so: undefined symbol: __asan_report_store4
</span></span></code></pre></div><p>Alas! The tree-sitter CLI is a rust program that dynamically loads the <code>tlaplus.so</code> file, and it wasn’t loading ASAN.
I added the <a href="https://github.com/tree-sitter/tree-sitter">tree-sitter repo itself</a> as a submodule of my grammar and set to fixing it.
Unfortunately after bashing my head against it for over an hour I couldn’t figure out how to load ASAN from rust; if you know, please <a href="https://stackoverflow.com/q/75376231/2852699">answer this StackOverflow question</a>!
Instead, I whipped up a quick C++ program that links against the tree-sitter C library directly and is itself compiled with sanitizers.
This is unfortunate; the tree-sitter CLI contains some finicky logic for parsing &amp; running the test corpus, which I am not going to replicate in C++, so my program only reads a TLA⁺ file, parses it, and prints out the parse tree.
You can see the build script and C++ front end <a href="https://github.com/tlaplus-community/tree-sitter-tlaplus/tree/main/test/sanitize">here</a>.</p>
<h3 id="initial-cleanup">Initial cleanup</h3>
<p>Before I could get started replicating my bugs I had to fix all the other bugs the sanitizers found!
One class of issue came from this line in the <code>std::vector&lt;T&gt;::data()</code> <a href="https://en.cppreference.com/w/cpp/container/vector/data">docs</a>:</p>
<blockquote>
<p>Notes: If size() is 0, data() may or may not return a null pointer.</p>
</blockquote>
<p>Indeed my empty vector was returning a null pointer, which I then passed into <code>memcpy</code> as variously the source or the target.
This only happened when the number of bytes to copy was also zero, so no harm done I thought.
On the <code>memcpy</code> <a href="https://en.cppreference.com/w/cpp/string/byte/memcpy">docs page</a> though, we see:</p>
<blockquote>
<p>If either dest or src is an invalid or null pointer, the behavior is undefined, even if count is zero.</p>
</blockquote>
<p>Well thank goodness it didn’t decide the vector should contain the entire contents of my address space again.
Wrapping <code>memcpy</code> in an if-statement fixed the problems.</p>
<p>Surprisingly, that was the end of it!
I ran my program against the entire <a href="https://github.com/tlaplus/examples">tlaplus/examples</a> test corpus without any additional issues popping up.
Time to reproduce those bugs.</p>
<h3 id="bug-1-the-perils-of-null-terminated-strings">Bug #1: the perils of null-terminated strings</h3>
<p>Recall this one happened because I passed a <code>std::vector&lt;char&gt;.data()</code> pointer into <code>atoi()</code>, and <code>std::vector&lt;char&gt;</code> doesn’t null-terminate its data (why would it?).
My hypothesis was this would be easily detected even when adjacent memory was unused, because the null byte <code>atoi()</code> reads to terminate the “string” is itself uninitialized memory.
To fix this bug I had written my own version of <code>atoi()</code> to parse the <code>raw_level</code> char vector:</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span>level <span>=</span> <span>0</span>;
</span></span><span><span><span>int32_t</span> multiplier <span>=</span> <span>1</span>;
</span></span><span><span><span>for</span> (size_t i <span>=</span> <span>0</span>; i <span>&lt;</span> raw_level.size(); i<span>++</span>) {
</span></span><span><span>  <span>const</span> size_t index <span>=</span> raw_level.size() <span>-</span> i <span>-</span> <span>1</span>;
</span></span><span><span>  <span>const</span> <span>int8_t</span> digit_value <span>=</span> raw_level.at(index) <span>-</span> <span>48</span>;
</span></span><span><span>  level <span>+=</span> digit_value <span>*</span> multiplier;
</span></span><span><span>  multiplier <span>*=</span> <span>10</span>;
</span></span><span><span>}
</span></span></code></pre></div><p>At this point in the code the contents of <code>raw_level</code> were all guaranteed to be ASCII numbers from 0-9, so not too bad.
I replaced it with our cursed line of code:</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span>level <span>=</span> atoi(raw_level.data());
</span></span></code></pre></div><p>It’s worth looking at how this bug manifests; we can parse the following TLA⁺ proof:</p>
<div><pre tabindex="0"><code data-lang="pl"><span><span><span>----</span> MODULE Proof <span>----</span>
</span></span><span><span>THEOREM P <span>=&gt;</span> Q
</span></span><span><span>PROOF
</span></span><span><span>  <span>&lt;1&gt;</span> P
</span></span><span><span>  <span>&lt;1&gt;</span> Q
</span></span><span><span>    PROOF BY P
</span></span><span><span>  <span>&lt;1&gt;</span> QED
</span></span><span><span><span>======================</span>
</span></span></code></pre></div><p>Our buggy code is concerned with parsing the number in the <code>&lt;1&gt;</code> proof step IDs, which is the proof level.
Proofs in TLA⁺ are hierarchical with various steps themselves having sub-proofs to prove their correctness.
Ordinarily, this should give the following parse tree:</p>
<div><pre tabindex="0"><code data-lang="scm"><span><span>(<span>source_file</span> (<span>module</span> (<span>header_line</span>) (<span>identifier</span>) (<span>header_line</span>)
</span></span><span><span>  (<span>theorem</span> (<span>bound_infix_op</span> (<span>identifier_ref</span>) (<span>implies</span>) (<span>identifier_ref</span>))
</span></span><span><span>    (<span>non_terminal_proof</span>
</span></span><span><span>      (<span>proof_step</span> (<span>proof_step_id</span> (<span>level</span>) (<span>name</span>)) (<span>suffices_proof_step</span> (<span>identifier_ref</span>)))
</span></span><span><span>      (<span>proof_step</span> (<span>proof_step_id</span> (<span>level</span>) (<span>name</span>)) (<span>suffices_proof_step</span> (<span>identifier_ref</span>)
</span></span><span><span>        (<span>terminal_proof</span> (<span>use_body</span> (<span>use_body_expr</span> (<span>identifier_ref</span>))))
</span></span><span><span>      ))
</span></span><span><span>      (<span>qed_step</span> (<span>proof_step_id</span> (<span>level</span>) (<span>name</span>)))
</span></span><span><span>    )
</span></span><span><span>  )
</span></span><span><span>(<span>double_line</span>)))
</span></span></code></pre></div><p>However, about one in twenty times it generates a parse error as one of the proof steps is a completely different level.
At the time my initial thoughts were along two tracks: one, the logic in the newly-written proof step ID handler <a href="https://github.com/tlaplus-community/tree-sitter-tlaplus/blob/510eddb0be455463e5e571f06a93cc0c2d08fe9d/src/scanner.cc#L1349">was quite complicated</a> and an obvious source of possible bugs; two, the external scanner had previously exhibited nondeterministic behavior when incorrectly initializing its state during deserialization.
Unfortunately both of these hypotheses were way off the mark which led to a lot of frustration &amp; wasted time.
Could sanitizers have come to the rescue?
It should point us to line 275 in <code>src/scanner.cc</code>.
Let’s check!</p>
<div><pre tabindex="0"><code data-lang="sh"><span><span>$ test/sanitize/out/parse_tlaplus Test.tla
</span></span><span><span>
</span></span><span><span><span>==</span>929719<span>==</span>ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000031 at pc 0x55ba5836b6f4 bp 0x7ffdd637d2b0 sp 0x7ffdd637ca70
</span></span><span><span>READ of size <span>2</span> at 0x602000000031 thread T0
</span></span><span><span>    <span>#0 0x55ba5836b6f3 in StrtolFixAndCheck(void*, char const*, char**, char*, int) asan_interceptors.cpp.o</span>
</span></span><span><span>    <span>#1 0x55ba5836bbd4 in __interceptor_strtol (/home/ahelwer/src/tlaplus/tree-sitter-tlaplus/test/sanitize/out/parse_tlaplus+0xffbd4) (BuildId: 1061028f7f02d346004ffa4692ca74e9d92b5cad)</span>
</span></span><span><span>    <span>#2 0x55ba5845e1f2 in atoi /usr/include/stdlib.h:364:16</span>
</span></span><span><span>    <span>#3 0x55ba5845e1f2 in (anonymous namespace)::ProofStepId::ProofStepId(std::vector&lt;char, std::allocator&lt;char&gt;&gt; const&amp;) /home/ahelwer/src/tlaplus/tree-sitter-tlaplus/</span>
</span></span><span><span>src/scanner.cc:275:17
</span></span><span><span>...
</span></span></code></pre></div><p>Easy-peasy.
Sanitizers would have led me right to it!</p>
<h3 id="bug-2-undefined-behavior-creating-a-black-hole">Bug #2: undefined behavior creating a black hole</h3>
<p>Recall this one resulted from calling <code>std::vector&lt;T&gt;::pop_back()</code> on an empty vector, which is undefined behavior.
The undefined behavior was given a somewhat hilarious definition by declaring the vector to then include the entire computer address space.
The actual crash happened later on in a <code>memcpy</code> when I tried to serialize this impossibly-large vector, now part of the external scanner state.
The circumstances leading to calling <code>pop_back()</code> on an empty vector resulted from insufficiently-hardening my external scanner against invalid syntax.
Tree-sitter grammars are designed to be error-tolerant so they can keep functioning even while the user is in the middle of typing some code.
This extends to your external scanner code, so you have to be careful about making assumptions about parser state when you encounter a given keyword.
In this case the bug came from this function:</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span><span>bool</span> <span>handle_qed_keyword_token</span>(TSLexer<span>*</span> <span>const</span> lexer) {
</span></span><span><span>  last_proof_level <span>=</span> get_current_proof_level();
</span></span><span><span>  proofs.pop_back();
</span></span><span><span>  lexer<span>-&gt;</span>result_symbol <span>=</span> QED_KEYWORD;
</span></span><span><span>  lexer<span>-&gt;</span>mark_end(lexer);
</span></span><span><span>  <span>return</span> true;
</span></span><span><span>}
</span></span></code></pre></div><p>This would generate undefined behavior on this input file:</p>
<div><pre tabindex="0"><code data-lang="pl"><span><span><span>----</span> MODULE Test <span>----</span>
</span></span><span><span>op <span>==</span> [ ]
</span></span><span><span>THEOREM TRUE
</span></span><span><span><span>&lt;*&gt;</span> A
</span></span><span><span><span>&lt;*&gt;</span> QED
</span></span><span><span><span>====</span>
</span></span></code></pre></div><p>The invalid syntax of <code>op == [ ]</code> would lead to a desperate error-recovery attempt that ultimately sent the <code>QED</code> keyword careening into that function when the <code>proofs</code> vector was empty.
The fix was to check whether tree-sitter was expecting a <code>QED</code> keyword before taking any rash actions:</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span><span>bool</span> <span>handle_qed_keyword_token</span>(
</span></span><span><span>  TSLexer<span>*</span> <span>const</span> lexer,
</span></span><span><span>  <span>const</span> <span>bool</span><span>*</span> <span>const</span> valid_symbols
</span></span><span><span>) {
</span></span><span><span>  <span>if</span> (valid_symbols[QED_KEYWORD]) {
</span></span><span><span>    last_proof_level <span>=</span> get_current_proof_level();
</span></span><span><span>    proofs.pop_back();
</span></span><span><span>  }
</span></span><span><span>
</span></span><span><span>  lexer<span>-&gt;</span>result_symbol <span>=</span> QED_KEYWORD;
</span></span><span><span>  lexer<span>-&gt;</span>mark_end(lexer);
</span></span><span><span>  <span>return</span> true;
</span></span><span><span>}
</span></span></code></pre></div><p>This one didn’t take as long to find as the first one, because it was easy to see from parser debug output that the external scanner saw <code>QED</code> shortly before crashing.
A quick hop into this function with <code>gdb</code> led to an absurd sight (one can easily imagine that array including some nice private keys!):</p>
<div><pre tabindex="0"><code data-lang="sh"><span><span>$ gdb node_modules/tree-sitter-cli/tree-sitter
</span></span><span><span><span>(</span>gdb<span>)</span> break handle_qed_keyword_token
</span></span><span><span><span>(</span>gdb<span>)</span> run parse test/crash_regressions/QEDErrorRecovery.tla
</span></span><span><span>Thread <span>1</span> <span>&#34;tree-sitter&#34;</span> hit Breakpoint 1, <span>(</span>anonymous namespace<span>)</span>::Scanner::handle_qed_keyword_token <span>(</span>valid_symbols<span>=</span>0x7ffff7aafe84 &lt;ts_external_scanner_states+68&gt;, lexer<span>=</span>0x555556127210, this<span>=</span>0x555556120518<span>)</span> at /home/ahelwer/src/tlaplus/tree-sitter-tlaplus/src/scanner.cc:1539
</span></span><span><span>1539	       last_proof_level <span>=</span> get_current_proof_level<span>()</span>;
</span></span><span><span><span>(</span>gdb<span>)</span> next
</span></span><span><span><span>(</span>gdb<span>)</span> print proofs
</span></span><span><span>$1 <span>=</span> std::vector of length -1, capacity 1 <span>=</span> <span>{</span>0, 5, 0, 0, 7566700, 21845, 33, 0, 
</span></span><span><span>  1444139744, 21845, 14, 16, 7566700, 0, 129, 0, 55013537, 21840, -1925187476, 
</span></span><span><span>  1208781847, 0, 0, 97, 0, 1444025872, 21845, -134776064, 32767, 0, 0, 65, 0, 
</span></span><span><span>  1444025872, 21845, -134776064, 32767, 0, 0, 33, 0, 1444025872, 21845, 
</span></span><span><span>  -134776064, 32767, 144, 0, 65, 0, 1836017711, 1751199589, 1702325349, 
</span></span><span><span>  1663971186, 1701340001, 1701999663, 1769155941, 1919251572, 1651076143, 
</span></span><span><span>  1634497536, 1937075312, 7303982, -43521, 0, 353, 0, 55014209, 21840, 
</span></span><span><span>  -1925187476, 1208781847, 9, 0, 9, 0, 257, 0, 0, 0, 124, 0, 31, 0, 1444029712, 
</span></span><span><span>  21845, 6, 0, 22, 0, 1444035344, 21845, 28, 0, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
</span></span><span><span>  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
</span></span><span><span>  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 65, 0, 
</span></span><span><span>  1836017711, 1751199589, 1702325349, 1920151410, 1819553635, 1970040929, 
</span></span><span><span>  1920216947, 1932354917, 1702130793, 1819553138, 1970040929, 32627, 64, 0, 65, 
</span></span><span><span>  0, 1836017711, 1751199589, 1702325349, 1663971186, 1701340001, 1701999663, 
</span></span><span><span>  1769155941, 1919251572, 1651076143, 1634497583, 1937075312, 7303982, 
</span></span><span><span>  692846591, 0, 353, 0, 55014881, 21840, -1925187476, 1208781847, 5, 0, 5, 0, 
</span></span><span><span>  514, 0, 0, 0, 26, 0, 31, 0...<span>}</span>
</span></span></code></pre></div><p>As an aside to fledgling programmers who are reading this post - be nice to yourself, learn how to use the debugger for the language you’re working in.
Don’t do debug-by-print-statement.
I’ve been down that road and learned my lesson!
It takes a bit longer to set up your debugger than to write another print statement, but you should be optimizing for iteration time not setup time.
And you only have to pay the setup time once.
If you’re debugging, use the right tool for the job - a debugger!</p>
<p>On to the main event.
Will sanitizers catch this?
Confidence is high!
We’re looking for line 1540 of <code>src/scanner.cc</code>:</p>
<div><pre tabindex="0"><code data-lang="sh"><span><span>$ test/sanitize/out/parse_tlaplus test/crash_regressions/QEDErrorRecovery.tla
</span></span><span><span>
</span></span><span><span><span>==</span>932149<span>==</span>ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6020000000b4 at pc 0x560eb67428fe bp 0x7ffcd192f4d0 sp 0x7
</span></span><span><span>ffcd192ec90
</span></span><span><span>READ of size <span>4294967292</span> at 0x6020000000b4 thread T0
</span></span><span><span>    <span>#0 0x560eb67428fd in __asan_memcpy (/home/ahelwer/src/tlaplus/tree-sitter-tlaplus/test/sanitize/out/parse_tlaplus+0x1558fd)</span>
</span></span><span><span> <span>(</span>BuildId: e87ee56651ecec128eaaf4d960ff363fcf8aabdb<span>)</span>
</span></span><span><span>    <span>#1 0x560eb67de62a in (anonymous namespace)::Scanner::serialize(char*, bool) /home/ahelwer/src/tlaplus/tree-sitter-tlaplus/</span>
</span></span><span><span>src/scanner.cc:951:40
</span></span><span><span>...
</span></span></code></pre></div><p>Alas the error points us to the serialization function, not the undefined behavior.
I would have hoped <a href="https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html">UBSan</a> would catch that.
I was compiling with <code>-fsanitize=undefined</code>, which includes nearly all the checks; I tried adding some others but no change.
Oh well, one out of two ain’t bad.
If you know how to tweak the settings so it’s detected, please let me know!</p>
<p><strong>Update!!!</strong> someone did let me know - lobste.rs user Sam James <a href="https://lobste.rs/s/ieqvjt/can_sanitizers_find_two_bugs_i_wrote_c#c_owmefi">suggested</a> building with <code>-D_GLIBCXX_ASSERTIONS</code>, which Gentoo uses for their hardened profiles.
Re-running the above, we see (simplified):</p>
<div><pre tabindex="0"><code data-lang="sh"><span><span>$ test/sanitize/out/parse_tlaplus test/crash_regressions/QEDErrorRecovery.tla
</span></span><span><span>.../stl_vector.h:1319: void std::vector&lt;int&gt;::pop_back<span>()</span> <span>[</span>...<span>]</span>:
</span></span><span><span>Assertion <span>&#39;!this-&gt;empty()&#39;</span> failed.
</span></span><span><span>Aborted <span>(</span>core dumped<span>)</span>
</span></span></code></pre></div><p>We can get the stack trace with <code>gdb</code>:</p>
<div><pre tabindex="0"><code data-lang="sh"><span><span>$ gdb test/sanitize/out/parse_tlaplus
</span></span><span><span><span>(</span>gdb<span>)</span> run test/crash_regressions/QEDErrorRecovery.tla
</span></span><span><span>.../stl_vector.h:1319: void std::vector&lt;int&gt;::pop_back<span>()</span> <span>[</span>...<span>]</span>:
</span></span><span><span>Assertion <span>&#39;!this-&gt;empty()&#39;</span> failed.
</span></span><span><span><span>(</span>gdb<span>)</span> backtrace
</span></span><span><span>...
</span></span><span><span><span>#5 0x000055555574d9a7 in std::vector&lt;int, std::allocator &gt;::pop_back (this=this@entry=0x6070000000c0) at .../stl_vector.h:1319</span>
</span></span><span><span><span>#6 0x0000555555749a1e in (anonymous namespace)::Scanner::handle_qed_keyword_token (this=, lexer=lexer@entry=0x61b000000080, valid_symbols=) at</span>
</span></span><span><span>src/scanner.cc:1540
</span></span><span><span>...
</span></span></code></pre></div><p>There it is, line 1540 of <code>src/scanner.cc</code>!</p>
<h3 id="conclusion">Conclusion</h3>
<p>Bit of a mixed bag.
I certainly don’t feel as safe writing this code as I would in rust, even with these sanitizers enabled.
Hopefully tree-sitter will add support for writing external scanners in rust at some point, but primary maintainer Max Brunsfeld is mostly occupied with the <a href="https://zed.dev/">Zed</a> editor these days (I appreciate the name, as a Canadian!) so it’ll be up to us if we want it.
An easier short-term goal would be better support from the tree-sitter CLI for compiling with sanitizers or other sorts of warnings.
As mentioned in the introduction, this post is a digression from my current project of subjecting the grammar to fuzzing with <a href="https://llvm.org/docs/LibFuzzer.html">libFuzzer</a>.
This is my first time fuzzing anything, and it was surprisingly easy to set up - the most difficult part is figuring out what the heck is going on with the weird crashes it generates!</p>


        
          
        

        

        
      </article>

      
        
      


      

    </div>
  </div>
</div></div>
  </body>
</html>
