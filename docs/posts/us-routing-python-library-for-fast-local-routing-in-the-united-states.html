<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/ivanbelenky/us-routing">Original</a>
    <h1>Show HN: US Routing â€“ Python library for fast local routing in the United States</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">
  <a target="_blank" rel="noopener noreferrer" href="https://github.com/ivanbelenky/us-routing/blob/master/assets/usroutegraph.png?raw=true"><img src="https://github.com/ivanbelenky/us-routing/raw/master/assets/usroutegraph.png?raw=true" alt="US Routing Logo" width="600" height="300"/></a>
</p>
<p dir="auto">US Routing is a Python library for fast local routing in the United States. It&#39;s useful when approximations are acceptable. It bootstraps from the <a href="https://geodata.bts.gov/datasets/usdot::north-american-roads" rel="nofollow">North American Roads dataset</a>.</p>

<p dir="auto">You can install US Routing using pip:</p>

<p dir="auto">or using poetry:</p>
<div dir="auto" data-snippet-clipboard-copy-content="git clone https://github.com/ivanbelenky/us-routing.git
cd us-routing
poetry install"><pre>git clone https://github.com/ivanbelenky/us-routing.git
<span>cd</span> us-routing
poetry install</pre></div>

<p dir="auto">Here&#39;s a quick example of how to use US Routing:</p>
<div dir="auto" data-snippet-clipboard-copy-content="from us_routing import get_route

# Route between two cities
r = get_route(&#39;New York&#39;, &#39;Los Angeles&#39;, edge_distance=&#34;DURATION&#34;)
print(r.total_distance, r.duration)
# Output in km of course:
# 4434.759999999997 1 day, 20:46:24.499959

# Print route steps
print(r)
# Output: [
#POINT (-73.99811899964011 40.7508730002449) -&gt; POINT (-74.0013209995546 40.74648499998924) (0.5700000000000001 km) 9TH AV, SP_TH_MA, 72 km/h
#POINT (-74.0013209995546 40.74648499998924) -&gt; POINT (-74.0054249996425 40.74097199980971) (0.6799999999999999 km) 9TH AV, SP_TH_MA, 72 km/h
#POINT (-74.0054249996425 40.74097199980971) -&gt; POINT (-74.00819599956175 40.74211600011984) (0.27 km) W 14TH ST, SP_TH_MA, 72 km/h
#POINT (-74.00819599956175 40.74211600011984) -&gt; POINT (-74.0090509998795 40.74090099973697) (0.16 km) 10TH AV, SP_TH_MA, 72 km/h
# ...]

# Route between zip codes
r = get_route(&#39;10001&#39;, &#39;60007&#39;)
print(r.total_distance, r.duration)
# Output:
# 1315.910000000001 13:20:26.827392


# Route between coordinates, will raise ValueError if closest node in the graph is too far from the location
try:
    r = get_route((40.7128, -74.0060), (34.0522, -118.2437), d_threshold=0.00001)
    print(r.total_distance, r.duration)
except ValueError as e:
    print(e)
#  Node 2bd87209-d2fe-4f41-a89f-29104aeb5cf9 is too far from location point=&lt;POINT (40.713 -74.006)&gt; zip_code=None admin=None name=None

r = get_route((-74.0060, 40.7128), (-118.2437, 34.0522), d_threshold=10)

# and for sure you can mix stuff up
r = get_route((40.7128, -74.0060), &#34;seattle&#34;, d_threshold=15)
"><pre><span>from</span> <span>us_routing</span> <span>import</span> <span>get_route</span>

<span># Route between two cities</span>
<span>r</span> <span>=</span> <span>get_route</span>(<span>&#39;New York&#39;</span>, <span>&#39;Los Angeles&#39;</span>, <span>edge_distance</span><span>=</span><span>&#34;DURATION&#34;</span>)
<span>print</span>(<span>r</span>.<span>total_distance</span>, <span>r</span>.<span>duration</span>)
<span># Output in km of course:</span>
<span># 4434.759999999997 1 day, 20:46:24.499959</span>

<span># Print route steps</span>
<span>print</span>(<span>r</span>)
<span># Output: [</span>
<span>#POINT (-73.99811899964011 40.7508730002449) -&gt; POINT (-74.0013209995546 40.74648499998924) (0.5700000000000001 km) 9TH AV, SP_TH_MA, 72 km/h</span>
<span>#POINT (-74.0013209995546 40.74648499998924) -&gt; POINT (-74.0054249996425 40.74097199980971) (0.6799999999999999 km) 9TH AV, SP_TH_MA, 72 km/h</span>
<span>#POINT (-74.0054249996425 40.74097199980971) -&gt; POINT (-74.00819599956175 40.74211600011984) (0.27 km) W 14TH ST, SP_TH_MA, 72 km/h</span>
<span>#POINT (-74.00819599956175 40.74211600011984) -&gt; POINT (-74.0090509998795 40.74090099973697) (0.16 km) 10TH AV, SP_TH_MA, 72 km/h</span>
<span># ...]</span>

<span># Route between zip codes</span>
<span>r</span> <span>=</span> <span>get_route</span>(<span>&#39;10001&#39;</span>, <span>&#39;60007&#39;</span>)
<span>print</span>(<span>r</span>.<span>total_distance</span>, <span>r</span>.<span>duration</span>)
<span># Output:</span>
<span># 1315.910000000001 13:20:26.827392</span>


<span># Route between coordinates, will raise ValueError if closest node in the graph is too far from the location</span>
<span>try</span>:
    <span>r</span> <span>=</span> <span>get_route</span>((<span>40.7128</span>, <span>-</span><span>74.0060</span>), (<span>34.0522</span>, <span>-</span><span>118.2437</span>), <span>d_threshold</span><span>=</span><span>0.00001</span>)
    <span>print</span>(<span>r</span>.<span>total_distance</span>, <span>r</span>.<span>duration</span>)
<span>except</span> <span>ValueError</span> <span>as</span> <span>e</span>:
    <span>print</span>(<span>e</span>)
<span>#  Node 2bd87209-d2fe-4f41-a89f-29104aeb5cf9 is too far from location point=&lt;POINT (40.713 -74.006)&gt; zip_code=None admin=None name=None</span>

<span>r</span> <span>=</span> <span>get_route</span>((<span>-</span><span>74.0060</span>, <span>40.7128</span>), (<span>-</span><span>118.2437</span>, <span>34.0522</span>), <span>d_threshold</span><span>=</span><span>10</span>)

<span># and for sure you can mix stuff up</span>
<span>r</span> <span>=</span> <span>get_route</span>((<span>40.7128</span>, <span>-</span><span>74.0060</span>), <span>&#34;seattle&#34;</span>, <span>d_threshold</span><span>=</span><span>15</span>)</pre></div>

<ul dir="auto">
<li>Fast routing between US locations (cities, zip codes, or coordinates)</li>
<li>Multiple routing options by default (shortest distance, fastest time)</li>
<li>Detailed route information (distance, duration, states traversed)</li>
</ul>

<p dir="auto">The routing data is based on the North American Roads dataset. The library includes functionality to download and process this data:</p>
<div dir="auto" data-snippet-clipboard-copy-content="from us_routing import download_north_american_roads

download_north_american_roads()"><pre><span>from</span> <span>us_routing</span> <span>import</span> <span>download_north_american_roads</span>

<span>download_north_american_roads</span>()</pre></div>

<p dir="auto">To set up the development environment:</p>
<ol dir="auto">
<li>Clone the repository</li>
<li>Install Poetry: <code>pip install poetry</code></li>
<li>Install dependencies: <code>poetry install</code></li>
</ol>

<p dir="auto">This package provides a <code>BaseRouter</code> class that you can use to build your own custom routing graphs. It exposes a very simple API to create routers from shapefiles containing multiple geometries and optional attributes for those geometries. It looks something like this:</p>
<div dir="auto" data-snippet-clipboard-copy-content="geometries: Sequence[LineString | MultiLineString]
geometries_data: Optional[Sequence[Dict[str, Any]]] = None # should be serializable

# Optional arguments to define how attributes are compared and set to the edges of the graph
edge_attr_equal: Optional[Callable[[Any, Any], bool]] = ...
edge_attr_setter: Optional[Callable[[Any, Any], dict[str, Any]]] = ...

router = BaseRouter.from_geometries(geometries, geometries_data, edge_attr_equal, edge_attr_setter)
router.serialize(&#34;path_to_save&#34;)"><pre><span>geometries</span>: <span>Sequence</span>[<span>LineString</span> <span>|</span> <span>MultiLineString</span>]
<span>geometries_data</span>: <span>Optional</span>[<span>Sequence</span>[<span>Dict</span>[<span>str</span>, <span>Any</span>]]] <span>=</span> <span>None</span> <span># should be serializable</span>

<span># Optional arguments to define how attributes are compared and set to the edges of the graph</span>
<span>edge_attr_equal</span>: <span>Optional</span>[<span>Callable</span>[[<span>Any</span>, <span>Any</span>], <span>bool</span>]] <span>=</span> ...
<span>edge_attr_setter</span>: <span>Optional</span>[<span>Callable</span>[[<span>Any</span>, <span>Any</span>], <span>dict</span>[<span>str</span>, <span>Any</span>]]] <span>=</span> ...

<span>router</span> <span>=</span> <span>BaseRouter</span>.<span>from_geometries</span>(<span>geometries</span>, <span>geometries_data</span>, <span>edge_attr_equal</span>, <span>edge_attr_setter</span>)
<span>router</span>.<span>serialize</span>(<span>&#34;path_to_save&#34;</span>)</pre></div>

<p dir="auto">Contributions are welcome! Please feel free to submit a Pull Request.</p>
</article></div></div>
  </body>
</html>
