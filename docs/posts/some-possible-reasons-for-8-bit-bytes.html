<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jvns.ca/blog/2023/03/06/possible-reasons-8-bit-bytes/">Original</a>
    <h1>Some possible reasons for 8-bit bytes</h1>
    
    

<p>I&rsquo;ve been working on a zine about how computers represent thing in binary, and
one question I&rsquo;ve gotten a few times is &ndash; why does the x86 architecture use 8-bit bytes? Why not
some other size?</p>

<p>With any question like this, I think there are two options:</p>

<ol>
<li>It&rsquo;s a historical accident, another size (like 4 or 6 or 16 bits) would work just as well</li>
<li>8 bits is objectively the Best Option for some reason, even if history had played out differently we would still use 8-bit bytes</li>
<li>some mix of 1 &amp; 2</li>
</ol>

<p>I&rsquo;m not super into computer history (I like to use computers a lot more than I
like reading about them), but I am always curious if there&rsquo;s an essential
reason for why a computer thing is the way it is today, or whether it&rsquo;s mostly
a historical accident. So we&rsquo;re going to talk about some computer history.</p>

<p>As an example of a historical accident: DNS has a <code>class</code> field which has 5
possible values (&ldquo;internet&rdquo;, &ldquo;chaos&rdquo;, &ldquo;hesiod&rdquo;, &ldquo;none&rdquo;, and &ldquo;any&rdquo;). To me that&rsquo;s
a clear example of a historical accident &ndash; I can&rsquo;t imagine that we&rsquo;d define
the class field the same way if we could redesign DNS today without worrying about backwards compatibility. I&rsquo;m
not sure if we&rsquo;d use a class field at all!</p>

<p>There aren&rsquo;t any definitive answers in this post, but I asked <a href="https://social.jvns.ca/@b0rk/109976810279702728">on Mastodon</a> and
here are some potential reasons I found for the 8-bit byte. I think the answer
is some combination of these reasons.</p>

<h3 id="what-s-the-difference-between-a-byte-and-a-word">what&rsquo;s the difference between a byte and a word?</h3>

<p>First, this post talks about &ldquo;bytes&rdquo; and &ldquo;words&rdquo; a lot. What&rsquo;s the difference between a byte and a word? My understanding is:</p>

<ul>
<li>the <strong>byte size</strong> is the smallest unit you can address. For example in a program on my machine <code>0x20aa87c68</code> might be the address of one byte, then <code>0x20aa87c69</code> is the address of the next byte.</li>
<li>the <strong>word size</strong> is the size of your CPU&rsquo;s registers. For example my registers are 64 bits. Any number you do a calculation with needs to fit in a register, so this is also the typical size you&rsquo;ll see for integers / floating point numbers.</li>
</ul>

<p>On today&rsquo;s laptops / desktop computers / servers, bytes are basically always 8 bits and words are 64 bits.</p>

<p>I think this definition of word size might be technically incorrect for some
reason, but that&rsquo;s how I think about it and it hasn&rsquo;t led me too far astray
so far.</p>

<p>Now let&rsquo;s talk about some possible reasons that we use 8-bit bytes!</p>

<h3 id="reason-1-to-fit-the-english-alphabet-in-1-byte">reason 1: to fit the English alphabet in 1 byte</h3>

<p><a href="https://en.wikipedia.org/wiki/IBM_System/360">This Wikipedia article</a> says that the IBM System/360 introduced the 8-bit byte in 1964.</p>

<p>Here&rsquo;s a <a href="https://www.youtube.com/watch?v=9oOCrAePJMs&amp;t=140s">video interview with Fred Brooks (who managed the project)</a> talking about why. I&rsquo;ve transcribed some of it here:</p>

<blockquote>
<p>&hellip; the six bit bytes [are] really better for scientific computing and the 8-bit byte ones are really better for commercial computing and each one can be made to work for the other.
So it came down to an executive decision and I decided for the 8-bit byte, Jerry&rsquo;s proposal.</p>

<p>[&hellip;.]</p>

<p>My most important technical decision in my IBM career was to go with the 8-bit byte for the 360.
And on the basis of I believe character processing was going to become important as opposed to decimal digits.</p>
</blockquote>

<p>It makes sense that an 8-bit byte would be better for text processing: 2^6 is
64, so 6 bits wouldn&rsquo;t be enough for lowercase letters, uppercase letters, and symbols.</p>

<p>To go with the 8-bit byte, System/360 also introduced the <a href="https://en.wikipedia.org/wiki/EBCDIC">EBCDIC</a> encoding, which is an 8-bit character encoding.</p>

<p>It looks like the next important machine in 8-bit-byte history was the
<a href="https://en.wikipedia.org/wiki/Intel_8008">Intel 8008</a>, which was built to be
used in a computer terminal (the Datapoint 2200). Terminals need to be able to
represent letters as well as terminal control codes, so it makes sense for them
to use an 8-bit byte.
<a href="https://archive.computerhistory.org/resources/text/2009/102683240.05.02.acc.pdf">This Datapoint 2200 manual from the Computer History Museum</a>
says on page 7 that the Datapoint 2200 supported ASCII (7 bit) and EBCDIC (8 bit).</p>

<h3 id="why-was-the-6-bit-byte-better-for-scientific-computing">why was the 6-bit byte better for scientific computing?</h3>

<p>I was curious about this comment that the 6-bit byte would be better for scientific computing. Here&rsquo;s a quote from <a href="https://archive.computerhistory.org/resources/access/text/2013/05/102702492-05-01-acc.pdf">this interview from Gene Amdahl</a>:</p>

<blockquote>
<p>I wanted to make it 24 and 48 instead of 32 and 64, on the basis that this
would have given me a more rational floating point system, because in floating
point, with the 32-bit word, you had to keep the exponent to just 8 bits for
exponent sign, and to make that reasonable in terms of numeric range it could
span, you had to adjust by 4 bits instead of by a single bit. And so it caused
you to lose some of the information more rapidly than you would with binary
shifting</p>
</blockquote>

<p>I don&rsquo;t understand this comment at all &ndash; why does the exponent have to be 8 bits
if you use a 32-bit word size? Why couldn&rsquo;t you use 9 bits or 10 bits if you
wanted? But it&rsquo;s all I could find in a quick search.</p>

<h3 id="why-did-mainframes-use-36-bits">why did mainframes use 36 bits?</h3>

<p>Also related to the 6-bit byte: a lot of mainframes used a 36-bit word size. Why? Someone pointed out
that there&rsquo;s a great explanation in the Wikipedia article on <a href="https://en.wikipedia.org/wiki/36-bit_computing">36-bit computing</a>:</p>

<blockquote>
<p>Prior to the introduction of computers, the state of the art in precision
scientific and engineering calculation was the ten-digit, electrically powered,
mechanical calculator&hellip; These calculators had a column of keys for each digit,
and operators were trained to use all their fingers when entering numbers, so
while some specialized calculators had more columns, ten was a practical limit</p>

<p>Early binary computers aimed at the same market therefore often used a 36-bit
word length. This was long enough to represent positive and negative integers
to an accuracy of ten decimal digits (35 bits would have been the minimum)</p>
</blockquote>

<p>So this 36 bit thing seems to based on the fact that log_2(20000000000) is 34.2. Huh.</p>

<p>My guess is that the reason for this is in the 50s, computers were
extremely expensive. So if you wanted your computer to support ten decimal
digits, you&rsquo;d design so that it had exactly enough bits to do that, and no
more.</p>

<p>Today computers are way faster and cheaper, so if you want to represent ten
decimal digits for some reason you can just use 64 bits &ndash; wasting a little bit
of space is usually no big deal.</p>

<h3 id="reason-2-to-work-well-with-binary-coded-decimal">reason 2: to work well with binary-coded decimal</h3>

<p>In the 60s, there was a popular integer encoding called binary-coded decimal (or <a href="https://en.wikipedia.org/wiki/Binary-coded_decimal">BCD</a> for short) that
encoded every decimal digit in 4 bits.</p>

<p>For example, if you wanted to encode the number 1234, in BCD that would be something like:</p>

<pre><code>0001 0010 0011 0100
</code></pre>

<p>So if you want to be able to easily work with binary-coded decimal, your byte
size should be a multiple of 4 bits, like 8 bits!</p>

<h3 id="why-was-bcd-popular">why was BCD popular?</h3>

<p>This integer representation seemed really weird to me &ndash; why not just use
binary, which is a much more efficient way to store integers? Efficiency was really important in early computers!</p>

<p>My best guess about why is that early computers didn&rsquo;t have displays the same way we do
now, so the contents of a byte were mapped directly to on/off lights.</p>

<p>Here&rsquo;s a <a href="https://commons.wikimedia.org/wiki/File:IBM-650-panel.jpg">picture from Wikipedia of an IBM 650 with some lights on its display</a> (<a href="http://creativecommons.org/licenses/by-sa/3.0/">CC BY-SA 3.0</a>):</p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/a/ad/IBM-650-panel.jpg"></p>

<p>So if you want people to be relatively able to easily read off a decimal number
from its binary representation, this makes a lot more sense. I think today BCD
is obsolete because we have displays and our computers can convert numbers
represented in binary to decimal for us and display them.</p>

<p>Also, I wonder if BCD is where the term &ldquo;nibble&rdquo; for 4 bits comes from &ndash; in
the context of BCD, you end up referring to half bytes a lot (because every
digits is 4 bits). So it makes sense to have a word for &ldquo;4 bits&rdquo;, and people
called 4 bits a nibble. Today &ldquo;nibble&rdquo; feels to me like an archaic term though &ndash;
I&rsquo;ve definitely never used it except as a fun fact (it&rsquo;s such a fun word!). The Wikipedia article on <a href="https://en.wikipedia.org/wiki/Nibble">nibbles</a> supports this theory:</p>

<blockquote>
<p>The nibble is used to describe the amount of memory used to store a digit of
a number stored in packed decimal format (BCD) within an IBM mainframe.</p>
</blockquote>

<p>Another reason someone mentioned for BCD was <strong>financial calculations</strong>. Today
if you want to store a dollar amount, you&rsquo;ll typically just use an integer
amount of cents, and then divide by 100 if you want the dollar part. This is no
big deal, division is fast. But apparently in the 70s dividing an integer
represented in binary by 100 was very slow, so it was worth it to redesign how
you represent your integers to avoid having to divide by 100.</p>

<p>Okay, enough about BCD.</p>

<h3 id="reason-3-8-is-a-power-of-2">reason 3: 8 is a power of 2?</h3>

<p>A bunch of people said it&rsquo;s important for a CPU&rsquo;s byte size to be a power of 2.
I can&rsquo;t figure out whether this is true or not though, and I wasn&rsquo;t satisfied with the explanation that &ldquo;computers use binary so powers of 2 are good&rdquo;. That seems very plausible but I wanted to dig deeper.
And historically there have definitely been lots of machines that used byte sizes that weren&rsquo;t powers of 2, for example (from <a href="https://retrocomputing.stackexchange.com/questions/7937/last-computer-not-to-use-octets-8-bit-bytes">this retro computing stack exchange thread</a>):</p>

<ul>
<li>Cyber 180 mainframes used 6-bit bytes</li>
<li>the Univac 1100 / 2200 series used a 36-bit word size</li>
<li>the PDP-8 was a 12-bit machine</li>
</ul>

<p>Some reasons I heard for why powers of 2 are good that I haven&rsquo;t understood yet:</p>

<ul>
<li>every bit in a word needs a bus, and you want the number of buses to be a power of 2 (why?)</li>
<li>a lot of circuit logic is susceptible to divide-and-conquer techniques (I think I need an example to understand this)</li>
</ul>

<p>Reasons that made more sense to me:</p>

<ul>
<li>it makes it easier to design <strong>clock dividers</strong> that can measure &ldquo;8 bits were
sent on this wire&rdquo; that work based on halving &ndash; you can put 3 halving clock
dividers in series. <a href="https://poly.nomial.co.uk/">Graham Sutherland</a> told me about this and made this really cool
<a href="https://www.falstad.com/circuit/circuitjs.html?ctz=CQAgjCAMB0l3BWcMBMcUHYMGZIA4UA2ATmIxAUgpABZsKBTAWjDACgwEknsUQ08tQQKgU2AdxA8+I6eAyEoEqb3mK8VMAqWSNakHsx9Iywxj6Ea-c0oBKUy-xpUWYGc-D9kcftCQo-URgEZRQERSMnKkiTSTDFLQjw62NlMBorRP5krNjwDP58fMztE04kdKsRFBQqoqoQyUcRVhl6tLdCwVaonXBO2s0Cwb6UPGEPXmiPPLHhIrne2Y9q8a6lcpAp9edo+r7tkW3c5WPtOj4TyQv9G5jlO5saMAibPOeIoppm9oAPEEU2C0-EBaFoThAAHoUGx-mA8FYgfNESgIFUrNDYVtCBBttg8LiUPR0VCYWhyD0Wp0slYACIASQAamTIORFqtuucQAzGTQ2OTaD9BN8Soo6Uy8PzWQ46oImI4aSB6QA5ZTy9EuVQjPLq3q6kQmAD21Beome0qQMHgkDIhHCYVEfCQ9BVbGNRHAiio5vIltg8Ft9stXg99B5MPdFK9tDAFqg-rggcIDui1i23KZfPd3WjPuoVoDCiDjv4gjDErYQA">simulator of clock dividers</a> showing what these clock dividers look like. That site (Falstad) also has a bunch of other example circuits and it seems like a really cool way to make circuit simulators.</li>
<li>if you have an instruction that zeroes out a specific bit in a byte, then if
your byte size is 8 (2^3), you can use just 3 bits of your instruction to
indicate which bit. x86 doesn&rsquo;t seem to do this, but the <a href="http://www.chebucto.ns.ca/~af380/z-80-h.htm">Z80&rsquo;s bit testing instructions</a> do.</li>
<li>someone mentioned that some processors use <a href="https://en.wikipedia.org/wiki/Carry-lookahead_adder">Carry-lookahead adders</a>, and they work
in groups of 4 bits. From some quick Googling it seems like there are a wide
variety of adder circuits out there though.</li>
<li><strong>bitmaps</strong>: Your computer&rsquo;s memory is organized into pages (usually of size 2^n). It
needs to keep track of whether every page is free or not. Operating systems
use a bitmap to do this, where each bit corresponds to a page and is 0 or 1
depending on whether the page is free. If you had a 9-bit byte, you would
need to divide by 9 to find the page you&rsquo;re looking for in the bitmap.
Dividing by 9 is slower than dividing by 8, because dividing by powers of 2
is always the fastest thing.</li>
</ul>

<p>I probably mangled some of those explanations pretty badly: I&rsquo;m pretty far out
of my comfort zone here. Let&rsquo;s move on.</p>

<h3 id="reason-4-small-byte-sizes-are-good">reason 4: small byte sizes are good</h3>

<p>You might be wondering &ndash; well, if 8-bit bytes were better than 4-bit bytes,
why not keep increasing the byte size? We could have 16-bit bytes!</p>

<p>A couple of reasons to keep byte sizes small:</p>

<ol>
<li>It&rsquo;s a waste of space &ndash; a byte is the minimum unit you can address, and if
your computer is storing a lot of ASCII text (which only needs 7 bits), it
would be a pretty big waste to dedicate 12 or 16 bits to each character when
you could use 8 bits instead.</li>
<li>As bytes get bigger, your CPU needs to get more complex. For example you need one bus line per bit. So I guess simpler is better.</li>
</ol>

<p>My understanding of CPU architecture is extremely shaky so I&rsquo;ll leave it at
that. The &ldquo;it&rsquo;s a waste of space&rdquo; reason feels pretty compelling to me though.</p>

<h3 id="reason-5-compatibility">reason 5: compatibility</h3>

<p>The Intel 8008 (from 1972) was the precursor to the 8080 (from 1974), which was the precursor to the
8086 (from 1976) &ndash; the first x86 processor. It seems like the 8080 and the
8086 were really popular and that&rsquo;s where we get our modern x86 computers.</p>

<p>I think there&rsquo;s an &ldquo;if it ain&rsquo;t broke don&rsquo;t fix it&rdquo; thing going on here &ndash; I
assume that 8-bit bytes were working well, so Intel saw no need to change the
design. If you keep the same 8-bit byte, then you can reuse more of your
instruction set.</p>

<h3 id="that-s-all">that&rsquo;s all!</h3>

<p>It seems to me like the main reasons for the 8-bit byte are:</p>

<ol>
<li>a lot of early computer companies were American, the most commonly used language in the US is English</li>
<li>those people wanted computers to be good at text processing</li>
<li>smaller byte sizes are in general better</li>
<li>7 bits is the smallest size you can fit all English characters + punctuation in</li>
<li>8 is a better number than 7 (because it&rsquo;s a power of 2)</li>
<li>once you have popular 8-bit computers that are working well, you want to keep the same design for compatibility</li>
</ol>

<p>Someone pointed out that <a href="https://web.archive.org/web/20170403014651/http://archive.computerhistory.org/resources/text/IBM/Stretch/pdfs/Buchholz_102636426.pdf">page 65 of this book from 1962</a>
talking about IBM&rsquo;s reasons to choose an 8-bit byte basically says the same thing:</p>

<blockquote>
<ol>
<li>Its full capacity of 256 characters was considered to be sufficient for the great majority of applications.</li>
<li>Within the limits of this capacity, a single character is represented by a
single byte, so that the length of any particular record is not dependent on
the coincidence of characters in that record.</li>
<li>8-bit bytes are reasonably economical of storage space</li>
<li>For purely numerical work, a decimal digit can be represented by only 4
bits, and two such 4-bit bytes can be packed in an 8-bit byte. Although such
packing of numerical data is not essential, it is a common practice in
order to increase speed and storage efficiency. Strictly speaking, 4-bit
bytes belong to a different code, but the simplicity of the 4-and-8-bit
scheme, as compared with a combination 4-and-6-bit scheme, for example,
leads to simpler machine design and cleaner addressing logic.</li>
<li>Byte sizes of 4 and 8 bits, being powers of 2, permit the computer designer
to take advantage of powerful features of binary addressing and indexing to
the bit level (see Chaps. 4 and 5 ) .</li>
</ol>
</blockquote>

<p>Overall this makes me feel like an 8-bit byte is a pretty natural choice if
you&rsquo;re designing a binary computer in an English-speaking country.</p>

  </body>
</html>
