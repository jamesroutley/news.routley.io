<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.jonathancreamer.com/how-we-shrunk-our-git-repo-size-by-94-percent/">Original</a>
    <h1>Shrunked JavaScript monorepo Git size by 94%</h1>
    
    <div id="readability-page-1" class="page"><div>
              
              <p>This isn&#39;t click bait. We really did this! We work in a <em>very large</em> Javascript monorepo at Microsoft we colloquially call 1JS. It&#39;s large not only in terms of GB, but also in terms of sheer volume of code and contributions. We recently crossed the 1,000 monthly active users mark, about 2,500 packages, and ~20million lines of code! The most recent clone I did of the repo clocked in at an astonishing 178GB.</p><figure><img src="https://media.tenor.com/dgpjP5JreugAAAAC/look-at-the-size-of-that-thing-amazed.gif" alt="" loading="lazy" width="426" height="240"/></figure><p>For many reasons, that&#39;s just too big, we have folks in Europe that can&#39;t even clone the repo due to it&#39;s size.</p><p>The question is, how did this even happen?!</p><h2 id="lesson-1">Lesson #1 </h2><p>When I first joined the repo a few years ago, I noticed after a few months that it was growing, when I first cloned it was a gig or 2, but after a few months was already at around 4gb. It was hard to know exactly why.</p><p>Back then I ran a tool called <code>git-sizer</code> , and it told me a few things about some blobs that were large. Large blobs happens when someone accidentally checks in some binary, so, not much you can do there other than enforce size limits on check ins which is a feature of Azure DevOps. Retroactively, once the file is there though, it&#39;s semi stuck in history. </p><p>Secondly, it flagged me about our <a href="https://github.com/microsoft/beachball/?ref=jonathancreamer.com" rel="noreferrer">Beachball change files</a>, which we weren&#39;t deleting. We use them in the same way that <a href="https://github.com/changesets/changesets?ref=jonathancreamer.com" rel="noreferrer">Changesets</a> work, accomplishing similar goals as <a href="https://github.com/semantic-release/semantic-release?ref=jonathancreamer.com" rel="noreferrer">semantic-release</a> where we want to tell the packages how to automatically bump their semver ranges.</p><p>At times we&#39;d get to 40k of them in a single folder, which we found out causes a large tree object to be created every time you add a new file into that folder.</p><figure><img src="https://www.jonathancreamer.com/content/images/2024/10/image.png" alt="" loading="lazy" width="864" height="146" srcset="https://www.jonathancreamer.com/content/images/size/w600/2024/10/image.png 600w, https://www.jonathancreamer.com/content/images/2024/10/image.png 864w" sizes="(min-width: 720px) 720px"/></figure><p>So, lesson #1 we learned was...</p><blockquote>Don&#39;t keep thousands of things in a single folder.</blockquote><p>We ended up implementing two things to help here. One was a <a href="https://github.com/microsoft/beachball/pull/584?ref=jonathancreamer.com" rel="noreferrer">pull request into beachball</a> which did several changes in a single change file instead of one per package.</p><p>Second, we wrote a pipeline which runs and automatically cleans up that change folder periodically to stop it from getting so large.</p><p>Huzzah! We fixed git bloat!</p><h2 id="lesson-2">Lesson #2</h2><figure><img src="https://www.jonathancreamer.com/content/images/2024/10/image-6.png" alt="" loading="lazy" width="500" height="579"/><figcaption><span>we fixed git bloat! no we didn&#39;t</span></figcaption></figure><p>Our versioning flow at scale maintains a mirror of <code>main</code> called <code>versioned</code> which stores the actual versions of packages so we can keep <code>main</code> free of git conflicts, and have an accurate view of which git commits correspond to which semver versions we release via NPM packages. (this needs another blog post, but I digress...)</p><p>I noticed that the versioned branch seeming to get harder and harder to clone because it kept getting so huge. But, we&#39;d dealt with the change file issue, and the only thing going in that <code>versioned</code> branch in terms of commits was appends to <code>CHANGELOG.md</code> and <code>CHANGELOG.json</code> files.</p><figure><img src="https://media.tenor.com/VWbwqhXAS7gAAAAC/hmmm-thinking.gif" alt="" loading="lazy" width="498" height="343"/></figure><p>Time passed on, and our repo, while growing slightly slower, still grew and grew. However, it was sort of difficult to know whether this growth was now due to simply scale, or something else altogether. We were adding hundreds of thousands of lines of code, and hundreds of developers every year since 2021, so a case was to be made that natural growth was occurring. However, once we came to realize that we had surpassed the growth rate of the one of the biggest monorepos at Microsoft, the Office one, we realized, something else must be wrong!</p><p>That&#39;s when we called for backup...</p><figure><img src="https://www.jonathancreamer.com/content/images/2024/10/image-1.png" alt="" loading="lazy" width="498" height="266"/></figure><p>The author of such git features as <a href="https://github.blog/open-source/git/bring-your-monorepo-down-to-size-with-sparse-checkout/?ref=jonathancreamer.com" rel="noreferrer">git shallow checkout</a>, <a href="https://github.blog/open-source/git/make-your-monorepo-feel-small-with-gits-sparse-index/?ref=jonathancreamer.com" rel="noreferrer">git sparse index</a>, and all <a href="https://devblogs.microsoft.com/devops/exploring-new-frontiers-for-git-push-performance/?ref=jonathancreamer.com" rel="noreferrer">kinds of other</a> features created because of the size of our monorepos in Office, had just re-joined our organization after a stint at Github bringing those features to the <strong>world</strong>.</p><p>He took a look, and immediately realized something was definitely not right with this growth rate. When we pulled our versioned branches, those branches that only change CHANGELOG.md and CHANGELOG.json, we were fetching 125GB of <em>extra</em> git data?! HOW THO??</p><p>Welp, after some super deep git digging, it turned out that some <a href="https://github.com/git/git/commit/ce0bd64299ae148ef61a63edcac635de41254cb5?ref=jonathancreamer.com#diff-d3b31a15a4dfd94e1201658d9bfc496a8c606d1ae7083cdbbc05e55c615f89ddL495" rel="noreferrer">old packing code</a> checked in by Linux Torvalds (ever heard of him ü§∑‚Äç‚ôÇÔ∏è) was actually only checking the last 16 characters of a filename when it gets ready to do compression of a file before it pushes the diffs. For context, <em>usually</em> git just pushes the <em>diffs</em> of changed files, however, because of this packing issue, git was comparing CHANGELOG.md files from two different packages! </p><p>For example, if you changed <code>repo/packages/foo/CHANGELOG.md</code>, when git was getting ready to do the push, it was generating a diff against <code>repo/packages/bar/CHANGELOG.md</code>! This meant we were in many occasions just pushing the entire file again and again, which could be 10s of MBs per file in some cases, and you can imagine in a repo </p><p>We were then able to try repacking our repo with a larger window <code>git repack -adf --window=250</code> to have git do a better job compressing the pack files for our repo to reduce the size. This did definitely reduce the size of the repo significantly, however, we can do even better! </p><p>This PR <a href="https://github.com/git-for-windows/git/pull/5171?ref=jonathancreamer.com">https://github.com/git-for-windows/git/pull/5171</a> added a new way to pack the repo based upon walking git paths as opposed to the default of walking commits.</p><p>The results are staggering...</p><figure><img src="https://www.jonathancreamer.com/content/images/2024/10/image-2.png" alt="" loading="lazy" width="678" height="218" srcset="https://www.jonathancreamer.com/content/images/size/w600/2024/10/image-2.png 600w, https://www.jonathancreamer.com/content/images/2024/10/image-2.png 678w"/></figure><p>I ran a new git clone on my machine yesterday to try the new version of git in <a href="https://github.com/microsoft/git?ref=jonathancreamer.com" rel="noreferrer">Microsoft&#39;s git fork</a> (git version 2.47.0.vfs.0.2)...</p><figure><img src="https://www.jonathancreamer.com/content/images/2024/10/image-3.png" alt="" loading="lazy" width="785" height="65" srcset="https://www.jonathancreamer.com/content/images/size/w600/2024/10/image-3.png 600w, https://www.jonathancreamer.com/content/images/2024/10/image-3.png 785w" sizes="(min-width: 720px) 720px"/></figure><p>And after running the new <code>git repack -adf --path-walk</code> ...<br/></p><figure><img src="https://www.jonathancreamer.com/content/images/2024/10/image-4.png" alt="" loading="lazy" width="353" height="78"/></figure><p>Crazy. It went from 178GB to 5GB. üò±</p><figure><img src="https://media.tenor.com/9CJaHEmyKPAAAAAC/chris-pratt-andy-dwyer.gif" alt="" loading="lazy" width="498" height="347"/></figure><p>The other new configuration option being added will further ensure that the right types of deltas are generated at <code>git push</code>  time...</p><p><code>git¬†config¬†--global pack.usePathWalk true</code> </p><p>That will make sure your <code>git push</code> commands are performing the correct compression.</p><p>Any developer on the git version 2.47.0.vfs.0.2 can now repack the repo once cloned locally, as well as use the new <code>git push</code> path walk algorithm to stop the growth rate.</p><p>On Github, re-packing and git garbage collection happens periodically, but again, the type of packing which Github does will not correctly compute the deltas of these CHANGELOG.md and CHANGELOG.json files, or potentially any file that has the same 16+ character names which change a lot over time. Think i18n type of large string files and such.</p><p>Azure DevOps, which we&#39;re on, doesn&#39;t do any such re-packing, <em>yet</em>. So, we&#39;re working on getting that done as well so we can reduce the size of the repo on the server side as well.</p><p>Those changes will all make their way into the upstream of git as well! Hurray for OSS. </p><h2 id="wrap-up">Wrap Up</h2><p>If you work in a large-ish scale monorepo, and you have CHANGELOG.md or really any file that has a relatively long-ish name (&gt;16 characters) which repeatedly gets updated, you may want to keep your eyes on this path walk stuff.</p><p>You can also try out thew new <code>git survey</code> command to see all kinds of new heuristics such as Top Files By Disk Size, Top Directories By Inflated Size, or Top Files By Inflated Size.<br/></p><figure><img src="https://www.jonathancreamer.com/content/images/2024/10/image-5.png" alt="" loading="lazy" width="465" height="283"/></figure><p>These heuristics will help give you a sense of whether the path walk work will affect your repo size too.</p><p>Overall I am so impressed and excited about our commitment to trying to produce solutions that help us scale repositories at Microsoft, but also take those solutions to the rest of the world..</p>
                <section>
                  
                  <ul>
                      <li>
                        <a href="https://www.jonathancreamer.com/tag/git/" title="git">git</a>
                      </li>
                      <li>
                        <a href="https://www.jonathancreamer.com/tag/monorepo/" title="monorepo">monorepo</a>
                      </li>
                      <li>
                        <a href="https://www.jonathancreamer.com/tag/javascript/" title="javascript">javascript</a>
                      </li>
                  </ul>
                </section>
            </div></div>
  </body>
</html>
