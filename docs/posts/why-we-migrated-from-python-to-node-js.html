<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.yakkomajuri.com/blog/python-to-node">Original</a>
    <h1>Why we migrated from Python to Node.js</h1>
    
    <div id="readability-page-1" class="page"><div><section><p>November 3, 2025</p><article><p><a target="_blank" rel="noopener noreferrer" href="https://github.com/skaldlabs/skald"><img src="https://blog.yakkomajuri.com/images/python-to-node-pr.png" alt="Python to Node migration"/></a></p>
<p>We just did something crazy: we completely rewrote our backend from Python to Node just one week after our launch.</p>
<p>We did this so we can scale. Yes, scale. A week in.</p>
<p>In some ways, it&#39;s a good time right? The codebase is still small and we don&#39;t have too many users.</p>
<p>But on the other hand, it goes completely against the advice given to early-stage startups which is to just ship and sell, and worry about scale once you&#39;ve hit product-market-fit. <a target="_blank" rel="noopener noreferrer" href="https://paulgraham.com/ds.html">&#34;Do things that don&#39;t scale&#34;</a>, as PG put it.</p>
<p>You see, we didn&#39;t have a magical launch week that flooded us with users and force us to scale. And generally you can expect that any stack you pick should be able to scale reasonably well for a long time until you actually get to the point where you should consider changing frameworks or rewriting your backend in a different language (read: Rust).</p>
<p>So why do it?</p>
<h2 id="python-async-sucks"><a href="#python-async-sucks"></a>Python async sucks</h2>
<p>I&#39;m a big fan of Django. I was introduced to it at <a target="_blank" rel="noopener noreferrer" href="https://posthog.com">PostHog</a> and it&#39;s become my go-to backend for most projects since. It gets you off the ground really fast, has great tooling and abstractions, and is still flexible enough to tweak to your needs.</p>
<p>So naturally, when I started writing our backend at <a target="_blank" rel="noopener noreferrer" href="https://github.com/skaldlabs/skald">Skald</a>, I started us off with Django too.</p>
<p>Now, we make a lot of calls to LLM and embedding APIs at Skald, so we&#39;re generally doing a lot of network I/O that we&#39;d like to be async. Not only that, we often want to fire a lot of requests concurrently, such as when need to generate vector embeddings for the various chunks of a document.</p>
<p>And things quickly got really messy in Django.</p>
<p>I&#39;ll preface this by saying that neither of us has a lot of experience writing Python async code (I&#39;ve mostly <a href="https://blog.yakkomajuri.com/blog/thread-pool">worked on</a> async-heavy services in Node) but I think this is partly the point here: <strong>it&#39;s really hard and unintuitive to write solid and performant Python async code</strong>. You need to go deep into the foundations of everything in order to be able to do so.</p>
<p>I&#39;m actually really interested in spending proper time in becoming more knowledgeable with Python async, but in our context you a) lose precious time that you need to use to ship as an early-stage startup and b) can shoot yourself in the foot very easily in the process.</p>
<p>Nevertheless, I thought I was to blame. &#34;Bad programmer! Bad programmer!&#34; was what I was hearing in my head as I tried to grasp everything. But while more knowledgeable folks would certainly have a better time, we discovered that the foundations of Python async are actually a bit shaky too.</p>
<p>Unlike JavaScript, which had the event loop from the beginning, and Go, that created the concept of goroutines (both concurrency models that I quite like and have used in production), Python async support was patched on later, and that&#39;s where the difficulty lies.</p>
<p>Two blog posts that cover this really well are <a target="_blank" rel="noopener noreferrer" href="https://tonybaloney.github.io/posts/why-isnt-python-async-more-popular.html">&#34;Python has had async for 10 years -- why isn&#39;t it more popular?&#34;</a> and <a target="_blank" rel="noopener noreferrer" href="https://harshal.sheth.io/2025/09/12/python-async.html">&#34;Python concurrency: gevent had it right&#34;</a>, both conveniently published not long before I started digging into all this.</p>
<p>As for us, we learned a few things:</p>
<ul>
<li>Python doesn&#39;t have native async file I/O.</li>
<li>Django still doesn&#39;t have full async support. Async in the ORM is not done yet and the colored functions problem really shines here. You can technically use Django with async, but their <a target="_blank" rel="noopener noreferrer" href="https://docs.djangoproject.com/en/5.2/topics/async/">docs on this</a> have so many caveats that it should scare anyone.</li>
<li>You gotta write <code><span><span>sync_to_async</span></span></code> and <code><span><span>async_to_sync</span></span></code> <strong>everywhere</strong>.</li>
<li>All sorts of models have emerged to bring better async support to different parts of the Python ecosystem, but as they&#39;re not native they have their own caveats. For instance, <a target="_blank" rel="noopener noreferrer" href="https://pypi.org/project/aiofiles/">aiofiles</a> brings async API-compatible file operations but uses a thread pool under the hood, and <a target="_blank" rel="noopener noreferrer" href="https://www.gevent.org/">Gevent</a> with its greenlets is pretty cool but it literally patches the stdlib in order to work.</li>
<li>Due to a lot of async support in Python relying on layers that sit on top of the language rather than being native, you need to be careful about the async code you write as it will have different implications depending on e.g. the Gunicorn worker type you run (good luck learning much about those from the Gunicorn docs, btw).</li>
</ul>
<p>Overall, just getting an equivalent of <code><span><span>Promise</span><span>.</span><span>all</span></span></code> to work, while understanding all of its gotchas was not simple at all.</p>
<p>Faced with this, I went into the <a target="_blank" rel="noopener noreferrer" href="https://github.com/posthog/posthog">PostHog codebase</a>.</p>
<p>I worked at PostHog for three years and we had no async in the Django codebase back then but they&#39;re a massive company and they have AI features now so they must have figured this out!</p>
<p>And what I realized was that they&#39;re still running WSGI (not ASGI) with Gunicorn Gthread workers (where the max concurrent requests you&#39;re able to handle is usually max 4x CPU cores), thus not getting much benefit from running things async. The codebase also has a lot of utils to make async work properly, like their own implementation of <code><span><span>async_to_sync</span></span></code>. So I guess way they&#39;re handling a lot of load is probably just horizontal scaling.</p>
<p>There&#39;s simply no great way to run async in Django.</p>
<h2 id="ok-now-what"><a href="#ok-now-what"></a>Ok, now what?</h2>
<p>We essentially concluded that Django was going to hurt us really soon, not just when we started to have a lot of load.</p>
<p>Without too many users we&#39;d already need to start running multiple machines in order to not have terrible latency, plus we&#39;d be writing clunky code that would be hard to maintain.</p>
<p>We could of course just &#34;do things that don&#39;t scale&#34; for now and just solve the problem with money (or AWS credits), but it didn&#39;t feel right. And being so early would make the migration to another framework much easier.</p>
<p>At this point, some people are probably screaming at their screens going: &#34;just use FastAPI!&#34; -- and we did indeed consider it.</p>
<p>FastAPI does have proper async support and is quite a loved framework said to be performant. And if you want an ORM with it you could use SQLAlchemy which also supports async.</p>
<p>Migrating to FastAPI would have probably saved us a day or two (our migration took 3 days) due to being able to reuse a lot of code without translating it, but at this point we weren&#39;t feeling great about the Python async ecosystem overall, and we had actually already written our background worker service in Node, so we thought it would be a good opportunity to go all-in on one ecosystem.</p>
<p>And so migrate to Node we did. We took a little time picking the framework + ORM combo but settled on Express + MikroORM.</p>
<p>Yeah sure Express is old but it&#39;s battle-tested and feels familiar. Coming over to the JS event loop was the main point of all this anyway.</p>
<h2 id="what-we-gained-what-we-lost"><a href="#what-we-gained-what-we-lost"></a>What we gained, what we lost</h2>
<h3 id="gained-efficiency"><a href="#gained-efficiency"></a>Gained: Efficiency</h3>
<p>Our initial benchmarks show we&#39;ve gained ~3x throughput out of the box and that&#39;s just with us running what is mostly sequential code in an async context. Being over on Node now, we&#39;re planning on doing a lot concurrent processing when chunking, embedding, reranking, and so on. This means this change should have an even greater payoff over time.</p>
<h3 id="lost-django"><a href="#lost-django"></a>Lost: Django</h3>
<p>Losing Django hurts, and we&#39;ve already found ourselves building a lot more middleware and utilities ourselves on the Express side. <a target="_blank" rel="noopener noreferrer" href="https://adonisjs.com/">Adonis</a> exists, which is a more fully-featured Node framework, but moving to a whole new ecosystem felt like more work to us than just using something minimal.</p>
<p>What I&#39;m missing the most is the ORM, which in my opinion is really ergonomic. And while you always have to be careful with ORMs when looking to extract the best possible performance, the Django ORM does do some nice things under the hood in order to make it performant enough to write queries in Python, and I learned a bit more about this when migrating our Django models over to MikroORM entities.</p>
<h3 id="gained-mikroorm"><a href="#gained-mikroorm"></a>Gained: MikroORM</h3>
<p>MikroORM was a consolation prize in this whole migration. I still much prefer the Django ORM but at the same time different ecosystems call for different tooling.</p>
<p>I&#39;d never used it before and was positively surprised to find Django-like lazy loading, a migrations setup that felt much better than Prisma&#39;s, as well as a reasonably ergonomic API (once you manually set up the foundations right).</p>
<p>Overall, we&#39;re early into this change, but currently happy to have picked MikroORM over the incumbent Prisma.</p>
<h3 id="lost-the-python-ecosystem"><a href="#lost-the-python-ecosystem"></a>Lost: The Python ecosystem</h3>
<p>I think this is pretty self-explanatory. While most tools for building RAGs and agents have Python and TypeScript SDKs, Python still takes priority, and we&#39;re just talking about API wrappers here.</p>
<p>Once you want to actually get into ML stuff yourself, there&#39;s just no competition. I suspect that as we get more sophisticated we&#39;ll end up having a Python service, but for now we&#39;re ok.</p>
<h3 id="gained-unified-codebase"><a href="#gained-unified-codebase"></a>Gained: Unified codebase</h3>
<p>We&#39;d always realized that migrating to Node would mean we&#39;d have two Node services instead of a Python one and a Node one, but it didn&#39;t occur to us until a day in that we could actually merge the codebases and that that would be extremely helpful.</p>
<p>There was a lot of duplicate logic across the Node worker and the Django server, and now we&#39;ve unified the Express server and background worker into one codebase, which feels so much better. They can both use the ORM now (previously the worker was running raw SQL) and share a bunch of utils.</p>
<h3 id="gained-much-better-testing"><a href="#gained-much-better-testing"></a>Gained: Much better testing</h3>
<p>This is not a <code><span><span>pytest</span></span></code> vs <code><span><span>jest</span></span></code> thing, it&#39;s just that in order to make sure everything was working as expected after migrating, we just wrote a ton more tests. This and some refactoring were welcome side benefits.</p>
<h2 id="how-we-did-it"><a href="#how-we-did-it"></a>How we did it</h2>
<p>I think it&#39;s about time to wrap this post up, but here are some quick notes about the actual migration process.</p>
<ul>
<li>It took us three days.</li>
<li>We barely used AI code generation at all until the final bits -- it felt important to us to understand the foundations of our new setup really well, particularly the inner workings of the new ORM. Once we had the foundations of everything down Claude Code was quite helpful in generating code for some less important endpoints, and also helped us in scanning the codebase for issues.</li>
<li>We almost quit multiple times. We were getting customer requests for new features and had some bugs in the Django code and it felt like we were wasting time migrating instead of serving customers.</li>
</ul>
<h2 id="would-we-do-it-again"><a href="#would-we-do-it-again"></a>Would we do it again?</h2>
<p>Honestly, we&#39;re quite happy with our decision and would 100% do it again. Not only will this pay off in the long term but it&#39;s already paying off today.</p>
<p>We learned a lot of stuff in the process too, and if the whole point of this whole post is that someone comes to tell me that we&#39;re dumb and we should just have done X or Y, or comes to teach me about how Python async works, then that will honestly be great. For my part, I gladly recognize my inexperience with Python async and if I can learn more about it, that&#39;s a win.</p>
<p>And if you&#39;re interested in actually seeing the code, check out the following PRs:</p>
<ul>
<li><a target="_blank" rel="noopener noreferrer" href="https://github.com/skaldlabs/skald/pull/56">skaldlabs/skald#56: feat: move the whole backend to node :D #56</a></li>
<li><a target="_blank" rel="noopener noreferrer" href="https://github.com/skaldlabs/skald/pull/68">skaldlabs/skald#68: Nuke Python</a></li>
</ul>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/skaldlabs/skald">Skald</a> is an MIT-licensed RAG API platform, so if you have any thoughts or concerns, you can come yell at us on <a target="_blank" rel="noopener noreferrer" href="https://github.com/skaldlabs/skald">GitHub</a>, or open a PR to rewrite the backend to your framework of choice :D</p></article></section><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></div></div>
  </body>
</html>
