<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ayende.com/blog/198241-B/the-subtleties-of-proper-b-tree-implementation">Original</a>
    <h1>The subtleties of proper B&#43;Tree implementation</h1>
    
    <div id="readability-page-1" class="page"><div>
        <p>I mentioned earlier that <a href="https://ayende.com/blog/198209-C/reducing-complexity-with-a-shift-in-thinking?key=0bc5c1d0c15e4f709c2456abb13923d3">B+Trees are a gnarly beast</a> to implement properly. On the face of it, this is a really strange statement, because they are a pretty simple data structure. What is so complex about the implementation? You have a fixed size page, you add to it until it is full, then you split the page, and you are done. What’s the hassle?</p>
<p>Here is a simple scenario for page splits, the following page is completely full. We cannot fit another entry there:</p>
<p><a href="https://ayende.com/blog/Images/Open-Live-Writer/The-subtleties-of-proper-BTree-implement_FCA8/image_4.png"><img title="image" src="https://ayende.com/blog/Images/Open-Live-Writer/The-subtleties-of-proper-BTree-implement_FCA8/image_thumb_1.png" alt="image" width="155" height="183"/></a></p>
<p>Now, if we try to add another item to the tree, we’ll need to split the page, and the result will be something like this (we add an entry with a key: <em>users/050</em>):</p>
<p><a href="https://ayende.com/blog/Images/Open-Live-Writer/The-subtleties-of-proper-BTree-implement_FCA8/image_6.png"><img title="image" src="https://ayende.com/blog/Images/Open-Live-Writer/The-subtleties-of-proper-BTree-implement_FCA8/image_thumb_2.png" alt="image" width="386" height="436"/></a></p>
<p>How did we split the page? The code for that  is really simple:</p>
<blockquote>

</blockquote>
<p>As you can see, since the data is sorted, we can simply take the last half of the entries from the source, copy them to the new page and call it a day. This is simple, effective, and will usually work just fine. The key word here is <em>usually</em>.</p>
<p>Given a B+Tree that uses variable size keys, with a page size of 4KB and a maximum size of 1 KB for the keys. On the face of it, this looks like a pretty good setup. If we split the page, we can be sure that we’ll have enough space to accommodate any valid key, right? Well, just as long as the data distribution makes sense. It often does not. Let’s talk about a concrete scenario, shall we? We store in the B+Tree a list of public keys.</p>
<p>This looks like the image below, where we have a single page with 16 entries and 3,938 bytes in use, and 158 bytes that are free. Take a look at the data for a moment, and you’ll notice some interesting patterns.</p>
<p><a href="https://ayende.com/blog/Images/Open-Live-Writer/The-subtleties-of-proper-BTree-implement_FCA8/image_12.png"><img title="image" src="https://ayende.com/blog/Images/Open-Live-Writer/The-subtleties-of-proper-BTree-implement_FCA8/image_thumb_5.png" alt="image" width="606" height="488"/></a></p>
<p>The data is divided into two distinct types, EdDSA keys and RSA keys. Because they are prefixed with their type, all the EdDSA keys are first on the page, and the RSA keys are last. There is a <em>big</em> size difference between the two types of keys. And that turns out to be a real problem for us.</p>
<p>Consider what will happen when we want to insert a new key to this page. We still have room to a few more EdDSA keys, so that isn’t really that interesting, but what happens when we want to insert a new RSA key? There is not enough room here, so we split the page. Using the algorithm above, we get the following tree structure post split:</p>
<p><a href="https://ayende.com/blog/Images/Open-Live-Writer/The-subtleties-of-proper-BTree-implement_FCA8/image_14.png"><img title="image" src="https://ayende.com/blog/Images/Open-Live-Writer/The-subtleties-of-proper-BTree-implement_FCA8/image_thumb_6.png" alt="image" width="845" height="574"/></a></p>
<p>Remember, we need to add an RSA key, so we are now going to go to the bottom right page and try to add the value. But there is <em>not enough room</em> to add a bit more than 512 bytes to the page, is there?</p>
<p>What happens next depends on the exact implementation. It is possible that you’ll get an error, or another split, or the tree will attempt to proceed and do something completely bizarre.</p>
<p>The key here (pun intended) is that even though the situation looks relatively simple, a perfectly reasonable choice can hide a pretty subtle bug for a very long time. It is only when you hit the <em>exact</em> problematic circumstances that you’ll run into problems.</p>
<p>This has been a fairly simple problem, but there are many such edge cases that may be hiding in the weeds of B+Tree implementations. that is one of the reasons that working with production data is such a big issue. Real world data is <em>messy</em>, it has unpredictable patterns and stuff that you’ll likely never think of. It is also the best way I have found to smoke out those details.</p>
    </div></div>
  </body>
</html>
