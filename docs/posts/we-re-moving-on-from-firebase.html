<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://koptional.com/article/why-we%E2%80%99re-moving-away-from-firebase">Original</a>
    <h1>We&#39;re moving on from Firebase</h1>
    
    <div id="readability-page-1" class="page"><div id="grid-main"><article id="article"><section><nav><astro-root uid="ZiFTn6"><h2>On this page</h2><ul></ul></astro-root>
</nav><div><p>We’ve launched dozens of applications on Firebase, utilized nearly every facet of the platform, and designed a playbook for scaling gracefully. Suffice it to say, it’s proven an invaluable tool for K-Optional Software. As recently as March 2022, our developers <a href="https://github.com/FirebaseExtended/experimental-extensions/issues/74">were cheering innovations like Firebase Extensions.</a> Unfortunately, three major developments in the past few months have polluted the developer experience and consequently K-Optional will shift towards alternatives for green projects.</p><h2 id="firebase-the-good">Firebase: the good</h2><p>The Google-owned platform-as-a-service (PaaS) enables builders to punt on several infrastructural decisions: content-delivery networking, NoSQL database event handlers, and network topology to name a few. True, a bespoke bundle of native services built on AWS / Azure / GCP bests the Firebase suite in pure performance. But when we consider developer hours and maintenance costs, Firebase is often a logical play.</p><p>The original <a href="https://firebase.google.com/docs/database">Firebase Realtime Database</a> felt fairly revolutionary, especially before the mass acceptance of <a href="https://mailarchive.ietf.org/arch/msg/ietf-announce/7dYVwa6pABzztQO4gTIHx3MYRGo/">WebSockets</a> or the emergence of <a href="https://germano.dev/sse-websockets/">Server-Sent Events</a>. You could write applications in sync with real-time data without heaps of transmission logic. Those who have home-rolled messaging applications with long-polling requests sure appreciated it.</p><p>In fact, there are many aspects of Firebase we love:</p><ul><li>With Firestore, many client state-management challenges disappear, especially pertaining to data freshness.</li><li>You get real-time experiences for free.</li><li>Firestore’s document / collection architecture: it forces one to be deliberate with  data-modeling. It also mirrors an intuitive navigation scheme.</li><li>Ditto for relational data in Firestore. <a href="https://mongoosejs.com/docs/populate.html">Unlike MongoDB</a>, it is impossible to do anything remotely similar to a SQL join. Therefore, developers must embrace the ethos of NoSQL by distributing relational data ahead of time.</li><li>The Firebase suite is conducive to fast prototyping that can scale. Handle data connections from the client, harden security rules before releasing to production, and use Firebase Functions for sensitive logic.</li><li><a href="https://firebase.google.com/docs/firestore/security/get-started">Cloud Firestore Security Rules</a> are enjoyable to write and a solid model for how to think about client-server security.</li><li>Authentication out of the box is nice. (Built-in Firebase email-verification is, in our opinion, a poor experience though).</li><li>We’ve actually found Firebase Hosting more straightforward when it comes to CI/CD than AWS S3 + Cloudfront because there’s a simple command for setting this up for a repository.</li></ul><h2 id="firebase-the-not-so-good">Firebase: the not so good</h2><p>On the flip side, there are also quite a few pieces of Firebase that have given me pause:</p><ul><li><p>Firebase mandates Google / GSuite sign-in- <a href="https://koptional.com/articles/software-start-up-system-essentials#a-note-on-decentralization">we like to distribute our vendors and services</a>.</p></li><li><p>Firebase Hosting doesn’t expose granular file control; you can either deploy an entire application or nothing at all. Perhaps niche, but we’ve run into limitations with static page generation and debugging CDN issues.</p></li><li><p>Firestore index creation is slow and ungraceful, taking way longer than an equivalent Algolia index.</p></li><li><p>Being closed-source, you don’t have the implicit assurance that Firebase will always be around (like <a href="https://www.notion.so/Why-we-re-moving-away-from-Firebase-Draft-1-fc15033152dd484cb9f3c5d75d27954a">Parse</a>), nor can you reliably depend on a specific API version.</p></li><li><p>You also therefore can’t truly run Firebase locally. Sure, there are <a href="https://firebase.google.com/docs/emulator-suite">Firebase Emulators</a>, but these are slow, tough to debug, and generally lacking; random things often fail under sufficient load which you might expect a robust local environment to withstand.</p></li><li><p>The Firebase CLI is pretty gated:</p><ul><li>You can’t do simple things like enable Firestore, other than from the dashboard.</li><li><code>firebase login:ci</code> deliberately inhibits piping an auth key. I’d love to do <code>firebase login:ci | xargs -I {} gh secret set FIREBASE_TOKEN --body=&#34;{}&#34;</code>, but alas, we get extra lines before and after. (see below for an ugly workaround we used)</li></ul></li></ul><p><strong>Aside</strong>: Speaking of the gated Firebase CLI, here are two of our oft-used workarounds which you may find useful.</p><p>Yes, I’d like to pipe my CI token directly into my secret manager.</p><pre><code><span>citokenRaw</span><span>=</span><span><span>$(</span>firebase login:ci<span>)</span></span>
<span>citoken</span><span>=</span><span><span>$(</span><span>echo</span> <span>&#34;<span>$citokenRaw</span>&#34;</span> <span>|</span> <span>tail</span> -n <span>3</span> <span>|</span> <span>head</span> -n <span>1</span><span>)</span></span>
</code></pre><h3 id="web-configuration-into-env">Web configuration into .env</h3><p>This little number downloads a Firebase web snippet and transforms it into something fit for an <code>.env</code> file. The web snippet configures your site to use a particular Firebase Application, and using environment variables allows us to preserve scaffolding across projects.</p><pre><code>

<span>fbKeysObject</span><span>=</span><span><span>$(</span>    firebase apps:list  --project<span>=</span>$FB_PROJECT --non-interactive --json     <span>|</span> fx <span>&#39;.result[0].appId&#39;</span> <span>|</span> <span>xargs</span> -I <span>{</span><span>}</span> firebase apps:sdkconfig WEB <span>{</span><span>}</span>     <span>|</span>  <span>sed</span> <span>&#39;/{/,/}/!d &#39;</span>      <span>|</span> <span>sed</span> -r  <span>&#39;s/;|firebase.initializeApp|(|)//g&#39;</span>     <span>)</span></span>


<span>echo</span> <span>&#34;<span>$fbKeysObject</span>&#34;</span> <span>|</span> jq <span>&#39;.projectId&#39;</span> <span>|</span> <span>xargs</span> -I <span>{</span><span>}</span> <span>echo</span> <span>&#34;REACT_APP_FB_PROJECT_ID=&#34;</span>&#34;<span>{</span><span>}</span><span>&#34; &gt; .env
echo &#34;</span><span>$fbKeysObject</span><span>&#34; | jq &#39;.appId&#39; | xargs -I {} echo &#34;</span>REACT_APP_FB_APP_ID<span>=</span><span>&#34;&#34;</span><span>{</span><span>}</span><span>&#34; &gt;&gt; .env
echo &#34;</span><span>$fbKeysObject</span><span>&#34; | jq &#39;.storageBucket&#39; | xargs -I {} echo &#34;</span>REACT_APP_FB_STORAGE_BUCKET<span>=</span><span>&#34;&#34;</span><span>{</span><span>}</span><span>&#34; &gt;&gt; .env
echo &#34;</span><span>$fbKeysObject</span><span>&#34; | jq &#39;.locationId&#39; | xargs -I {} echo &#34;</span>REACT_APP_FB_LOCATION_ID<span>=</span><span>&#34;&#34;</span><span>{</span><span>}</span><span>&#34; &gt;&gt; .env
echo &#34;</span><span>$fbKeysObject</span><span>&#34; | jq &#39;.apiKey&#39; | xargs -I {} echo &#34;</span>REACT_APP_FB_API_KEY<span>=</span><span>&#34;&#34;</span><span>{</span><span>}</span><span>&#34; &gt;&gt; .env
echo &#34;</span><span>$fbKeysObject</span><span>&#34; | jq &#39;.authDomain&#39; | xargs -I {} echo &#34;</span>REACT_APP_FB_AUTH_DOMAIN<span>=</span><span>&#34;&#34;</span><span>{</span><span>}</span><span>&#34; &gt;&gt; .env
echo &#34;</span><span>$fbKeysObject</span><span>&#34; | jq &#39;.messagingSenderId&#39; | xargs -I {} echo &#34;</span>REACT_APP_FB_MESSAGE_SENDER_ID<span>=</span><span>&#34;&#34;</span><span>{</span><span>}</span>&#34; <span>&gt;&gt;</span> .env
</code></pre><p><strong>End aside.</strong></p><p>To summarize, most existing problems with Firebase spawn from Google’s ownership and primarily annoy me. It’s the recent developments that have been cause for reconsideration…</p><h2 id="the-writing-on-the-wall">The writing on the wall</h2><p>Three recent developments with Firebase have convinced us that the future is with tools like <a href="https://supabase.com/">Supabase</a>.</p><h3 id="forced-migration-to-gcp-via-removal-of-firebase-features">Forced migration to GCP via removal of Firebase features</h3><p>In the past few months, Firebase dropped Cloud Function logs from the dashboard. If you want these you can follow links to a Google Cloud Console dashboard.</p><p><img src="https://koptional.com/images/uploads/firebase-functions.png" alt="Well if it’s highly customizable, I suppose it’s a favor to me" title="Firebase functions dashboard"/></p><p>Well if it’s highly customizable, I suppose it’s a favor to me</p><p>I also noticed that on the Firebase Storage dashboard, you can’t download files; you must navigate over to the separate GCP platform.</p><p><img src="https://koptional.com/images/uploads/firebase-storage.png" alt="On the Firebase Dashboard, I can’t download this file. Counter intuitively, “Open” does not allow one to download." title="Firebase storage dashboard"/></p><p>On the Firebase Dashboard, I can’t download this file. Counter intuitively, “Open” does not allow one to download.</p><p><img src="https://koptional.com/images/uploads/firebase-transfer.png" alt="Downloading is straightforward on Google Cloud Console." title="Firebase Cloud Functions"/></p><p>Downloading is straightforward on Google Cloud Console.</p><p>It seems that GCP is cannibalizing the Firebase developer environment. From an ops perspective, that makes sense. But axing the simplified cloud experience of Firebase removes much of its value; our clients don’t want to make sense of GCP. On recent Firebase projects I wondered if we would be better off launching bespoke services instead. I’m sure Google wouldn’t mind developers abandoning Firebase for pure GCP.</p><h3 id="recent-cloud-function-deployment-rate-limits">Recent Cloud Function deployment rate limits</h3><p>Cloud Function CI/CD has degraded. <a href="https://firebase.google.com/docs/functions/quotas">Firebase enforces a quota for Cloud Function deployment of 80 writes per 100 seconds</a>. As far as I can tell, the quota has existed for a while.</p><p><a href="https://github.com/firebase/firebase-tools/issues/3919">But recently, Cloud Function deployments started failing silently upon hitting this quota.</a> That’s tricky because 80 endpoints aren’t all that many, and <a href="https://github.com/firebase/firebase-tools/issues/2606">Firebase has not exposed a clean way to deploy only Cloud Functions that changed.</a></p><p>K-Optional Software received multiple consultation requests for this issue on projects we don’t own at roughly the same time, pointing to a sudden and inconvenient API change.</p><p>I’ve considered two workarounds:</p><ol><li>Use a single Cloud Function which invokes conditional logic- say, with an event dispatcher- based upon an event name. That might look like a single function called <code>dispatcherFunction</code> which switches on <code>eventName</code>, calling internal functions accordingly.</li><li>Instill a convention where every Cloud Function corresponds to its own file. In the CI code, filter out files that have not changed and deploy functions corresponding to the files that have.</li></ol><p>Needless to say, both of these workarounds leave a lot to be desired. Cramming routing logic into an endpoint sacrifices readability and HTTP-level caching, and the scaffolding approach doesn’t help large existing projects.</p><h3 id="gcp-favoritism-part-2">GCP Favoritism Part 2</h3><p>Finally, Firebase increasingly shepherds users over to GCP for essential services. Intermittently over the past few months, <a href="https://github.com/FirebaseExtended/action-hosting-deploy/issues/203">developers reported failures on Firebase Hosting due to missing permissions</a>. <a href="https://www.notion.so/Github-Action-Firebase-Hosting-Deploy-Failure-Error-HTTP-Error-403-Permission-cloudfunctions-fu-515b11fa1004420eae2b758e819696db">Our team began reporting this issue last week</a>. Why Firebase Hosting requires Cloud Function <code>list</code> authorization confounds me. In any event, Google Cloud Console provides the sole means for adding this permission.</p><p>I’ve caught myself on this permissions dashboard a lot recently in spite of a down-tick in Firebase Development.</p><p><img src="https://koptional.com/images/uploads/firebase-caution.png" alt="From the Cloud Function Deployment docs: A Firebase error solved on Google Cloud only." title="Firebase Caution"/></p><p>From the <a href="https://firebase.google.com/docs/functions/manage-functions#deploy_functions">Cloud Function Deployment docs</a>: A Firebase error solved on Google Cloud only.</p><h2 id="supabase">Supabase</h2><p>We’ve developed a few small projects on Supabase recently as a part of our prospecting process. The developer experience has been delightful, particular <a href="https://supabase.com/docs/guides/auth/row-level-security">Row Level Security</a>, the more powerful analog to Firestore Rules. That Supabase is betting on <a href="https://deno.com/deploy">Deno</a> for their <a href="https://deno.com/blog/supabase-functions-on-deno-deploy">serverless function suite</a> indicates to us that they are serious about great technology.</p><p>We love <a href="https://www.postgresql.org/">PostgreSQL</a> which Supabase utilizes. We plan to do more research on scalability, since <del>column-based</del> * SQL databases can’t grow as big as their NoSQL counterparts. Nonetheless, Supabase came at the right time.</p><p>* <em>Edit: poor choice of words</em></p></div></section></article></div></div>
  </body>
</html>
