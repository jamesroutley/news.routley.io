<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.vidarholen.net/contents/blog/?p=479">Original</a>
    <h1>Useless Use of &#34;dd&#34; (2015)</h1>
    
    <div id="readability-page-1" class="page"><article id="post-479">
	<!-- .entry-header -->

	
	
	<div>
		<p>tl;dr: <code>dd</code> works for reading and writing disks, but it has no advantages and some disadvantages over just treating the disk as a regular file. In many commands it’s entirely pointless.</p>
<p>If you’ve ever used <code>dd</code>, you’ve probably used it to read or write disk images:</p>
<p><code># Write myfile.iso to a USB drive</code></p>
<p>Usage of <code>dd</code> in this context is so pervasive that it’s being hailed as the magic gatekeeper of raw devices. Want to read from a raw device? Use <code>dd</code>. Want to write to a raw device? Use <code>dd</code>.</p>
<p>This belief adds complexity to simple commands. How do you combine <code>dd</code> with <code>gzip</code>? How do you use <code>pv</code> if the source is raw device? How do you <code>dd</code> over <code>ssh</code>?</p>
<p>People cleverly find ways to insert <code>dd</code> at the front and end of pipelines. <code>dd if=/dev/sda | gzip &gt; image.gz</code>, they say. <code>dd if=/dev/sda | pv | dd of=/dev/sdb</code>. </p>
<p>In both these cases, <code>dd</code> serves no purpose. It’s purely a superstitious charm trying to ensure safe passage of the data. It’s like <code>cat /dev/sda | pv | cat &gt; /dev/sdb</code> except not as efficient.</p>
<p>The fact of the matter is, <code>dd</code> is not a disk writing tool. Neither “d” is for “disk”, “drive” or “device”. It does not support “low level” reading or writing. It has no special dominion over any kind of device whatsoever.</p>
<p><code>dd</code> just reads and writes file.</p>
<p>On UNIX, the adage goes, everything is a file. This includes raw disks. Since raw disks are files, and <code>dd</code> can be used to copy files, <code>dd</code> be used to copy raw disks.</p>
<p>But do you know what else can read and write files? Everything:</p>
<p><code># Write myfile.iso to a USB drive</code></p><p><code>
<p>    # Rip a cdrom to a .iso file</p>
</code></p><p><code>    # Create a gzipped image</code></p>
<p><code>dd</code> can even end up doing a worse job. By specification, its default 512 block size has had to remain unchanged for decades. Today, this tiny size makes it CPU bound by default. A script that doesn’t specify a block size is very inefficient, and any script that picks the current optimal value may slowly become obsolete — or start obsolete if it’s copied from </p>
<p>Meanwhile, <code>cat</code> is free to choose its buffer size that best serves a modern system, and the GNU cat buffer size has grown steadily over the years from 512 bytes in 1991 to 131072 bytes in 2014. <code>./src/ioblksize.h</code> in the coreutils source code has benchmarks backing up this decision.</p>
<p>However, this does not mean that <code>dd</code> should necessarily be categorically shunned! The reason why people started using it in the first place is that it does exactly what it’s told: no more and no less. </p>
<p>If an alias specifies <code>-a</code>, <code>cp</code> might try to create a new block device rather than a copy of the file data. If using <code>gzip</code> without redirection, it may try to be helpful and skip the file for not being regular. Neither of them will write out a reassuring status during or after a copy.</p>
<p><code>dd</code>, meanwhile, has one job*: copy data from one place to another. It doesn’t care about files, safeguards or user convenience. It will not try to second guess your intent, based on trailing slashes or types of files.</p>
<p>However, when this is no longer a convenience, like when combining it with other tools that already read and write files, one should not feel guilty for leaving <code>dd</code> out entirely.</p>
<p>This is not to say I think <code>dd</code> is overrated! Au contraire! It’s one of my favorite Unix tools!</p>
<p><code>dd</code> is the swiss army knife of the open, read, write and seek syscalls. It’s unique in its ability to issue seeks and reads of specific lengths, which enables a whole world of shell scripts that have no business being shell scripts. Want to simulate a lseek+execve? Use dd! Want to open a file with O_SYNC? Use dd! Want to read groups of three byte pixels from a PPM file? Use dd! </p>
<p>It’s a flexible, unique and useful tool, and I love it. My only issue is that, far too often, this great tool is being relegated to and inappropriately hailed for its most generic and least interesting capability: simply copying a file from start to finish. </p>
<hr/>
<p>* dd actually has two jobs: Convert and Copy. A post on <a href="https://groups.google.com/forum/#!topic/comp.unix.misc/LbLTa00Jnvg">comp.unix.misc</a> (incorrectly) claimed that the intended name “cc” was taken by the C compiler, so the letters were shifted in the same way we ended up with a <strong>W</strong>indow system called <strong>X</strong>. A more likely explanation is given in that thread as pointed out by Paweł and Bruce in the comments: the name, syntax and purpose is almost identical to the JCL “Dataset Definition” command found in 1960s IBM mainframes. </p>
	</div><!-- .entry-content -->

	<!-- .entry-footer -->
</article></div>
  </body>
</html>
