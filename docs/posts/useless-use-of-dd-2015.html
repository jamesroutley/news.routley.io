<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.vidarholen.net/contents/blog/?p=479">Original</a>
    <h1>Useless Use of &#34;dd&#34; (2015)</h1>
    
    <div id="readability-page-1" class="page"><div><p>tl;dr: <code>dd</code> works for reading and writing disks, but it has no &#34;low level I/O&#34; capabilities that make it more suited for this than any other shell utility. Like <code>cat</code> you should use it where it makes sense, e.g. to take advantage of its wide array of options, rather than try to ensure that all disk related commands begin and end with <code>dd</code> out of fear and superstition.</p>
<p>If you’ve ever used <code>dd</code>, you’ve probably used it to read or write disk images:</p>
<pre><code># Write myfile.iso to a USB drive
dd if=myfile.iso of=/dev/sdb bs=1M
</code></pre>
<p>Usage of <code>dd</code> in this context is so pervasive that it’s being hailed as the magic gatekeeper of raw devices. Want to read from a raw device? Use <code>dd</code>. Want to write to a raw device? Use <code>dd</code>.</p>
<p>This belief adds unnecessary complexity to simple commands. How do you combine <code>dd</code> with gzip? How do you use pv if the source is raw device? How do you <code>dd</code> over ssh?</p>
<p>People cleverly find ways to insert <code>dd</code> at the front and end of pipelines. <code>dd if=/dev/sda | gzip &gt; image.gz</code>, they say. <code>dd if=/dev/sda | pv | dd of=/dev/sdb</code>.</p>
<p>In both these cases, <code>dd</code> serves no real purpose. It’s purely a superstitious charm trying to ensure safe passage of the data. You can see how silly this is when you replace <code>dd</code> with the functionally equivalent <code>cat</code>: <code>cat /dev/sda | pv | cat &gt; /dev/sdb</code></p>
<p>The fact of the matter is, <code>dd</code> is not a disk writing tool. Neither “d” is for “disk”, “drive” or “device”. It does not support “low level” reading or writing. It has no special dominion over any kind of device whatsoever.</p>
<p><code>dd</code> just reads and writes file.</p>
<p>On UNIX, the adage goes, everything is a file. This includes raw disks. Since raw disks are files, and <code>dd</code> can be used to copy files, <code>dd</code> be used to copy raw disks.</p>
<p>But do you know what else can read and write files? Everything:</p>
<pre><code># Write myfile.iso to a USB drive
cp myfile.iso /dev/sdb

# Rip a cdrom to a .iso file
cat /dev/cdrom &gt; myfile.iso

# Create a gzipped image
gzip -9 &lt; /dev/sdb &gt; /tmp/myimage.gz
</code></pre>
<p><code>dd</code> uses the same interface these commands do, and is not any safer or more reliable.</p>
<p><code>dd</code> can even end up doing a worse job. By specification, its default 512 block size has had to remain unchanged for decades. Today, this tiny size makes it CPU bound by default. A script that doesn’t specify a block size is very inefficient, and any script that picks the current optimal value may slowly become obsolete — or start obsolete if it’s copied from</p>
<p>Meanwhile, <code>cat</code> is free to choose its buffer size that best serves a modern system, and the GNU <code>cat</code> buffer size has grown steadily over the years from 512 bytes in 1991 to 131072 bytes in 2014. <code>src/ioblksize.h</code> in the coreutils source code has benchmarks backing up this decision.</p>
<p>However, this does not mean that <code>dd</code> should be categorically shunned! The reason why people started using it in the first place is that it does exactly what it’s told: no more and no less.</p>
<p>If an alias specifies <code>-a</code>, <code>cp</code> might try to create a new block device instead of a copy of the file data. If using <code>gzip</code> without redirection, it may try to be helpful and skip the file for not being regular. Neither of them will write out a reassuring status during or after a copy.</p>
<p><code>dd</code>, meanwhile, has one job*: copy data from one place to another. It doesn’t care about files, safeguards or user convenience. It will not try to second guess your intent, based on trailing slashes or types of files.</p>
<p>However, when this is no longer a convenience, like when combining it with other tools that already read and write files, one should not feel guilty for leaving <code>dd</code> out entirely.</p>
<p>This is not to say I think <code>dd</code> is overrated! Au contraire! It’s one of my favorite Unix tools!</p>
<p><code>dd</code> is the swiss army knife of the open, read, write and seek syscalls. It’s unique in its ability to issue seeks and reads of specific lengths, which enables a whole world of shell scripts that have no business being shell scripts. Want to simulate a lseek+execve? Use <code>dd</code>! Want to open a file with <code>O_SYNC</code>? Use <code>dd</code>! Want to read groups of three byte pixels from a PPM file? Use <code>dd</code>!</p>
<p>It’s a flexible, unique and useful tool, and I love it. My only issue is that, far too often, this great tool is being relegated to, and inappropriately hailed for, its most generic and least interesting capability: simply copying a file from start to finish.</p>
<p>* <code>dd</code> actually has two jobs: Convert and Copy. A post on comp.unix.misc (incorrectly) claimed that the intended name “cc” was taken by the C compiler, so the letters were shifted in the same way we ended up with a Window system called X. A more likely explanation is given in that thread as pointed out by Paweł and Bruce in the comments: the name, syntax and purpose is almost identical to the JCL “Dataset Definition” command found in 1960s IBM mainframes.</p>
</div></div>
  </body>
</html>
