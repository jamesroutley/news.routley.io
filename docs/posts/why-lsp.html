<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://matklad.github.io//2022/04/25/why-lsp.html">Original</a>
    <h1>Why LSP?</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>I would say that the reason for such poor IDE support in the days of yore is different.
Rather than <code>M * N</code> being too big, it was too small, because <code>N</code> was zero and <code>M</code> just slightly more than that.</p>
<p>I’d start with <code>N</code> — the number of language servers, this is the side I am relatively familiar with.
Before LSP, there simply weren’t a lot of working language-server shaped things.
The main reason for that is that building a language server is hard.</p>
<p>The essential complexity for a server is pretty high.
It is known that compilers are complicated, and a language server is a compiler <em>and then some</em>.</p>
<p><em>First</em>, like a compiler, a language server needs to fully understand the language, it needs to be able to distinguish between valid and invalid programs.
However, while for invalid programs a batch compiler is allowed to emit an error message and exit promptly, a language server must analyze <em>any</em> invalid program as best as it can.
Working with incomplete and invalid programs is the first complication of a language server in comparison to a compiler.</p>
<p><em>Second</em>, while a batch compiler is a pure function which transforms source text into machine code, a language server has to work with a code base which is constantly being modified by the user.
It is a compiler with a time dimension, and evolution of state over time is one of the hardest problems in programming.</p>
<p><em>Third</em>, a batch compiler is optimized for maximum throughput, while a language server aims to minimize latency (while not completely forgoing throughput).
Adding a latency requirement doesn’t mean that you need to optimize harder.
Rather, it means that you generally need to turn the architecture on its head to have an acceptable latency at all.</p>
<p>And this brings us to a related cluster of accidental complexity surrounding language servers.
It is well understood how to write a batch compiler.
It’s common knowledge.
While not everyone have read the dragon book (I didn’t meaningfully get past the parsing chapters), everyone knows that that book contains all the answers.
So most existing compilers end up looking like a typical compiler.
And, when compiler authors start thinking about IDE support, the first thought is “well, IDE is kinda a compiler, and we have a compiler, so problem solved, right?”.
This is quite wrong — internally an IDE is very different from a compiler but, until very recently, this wasn’t common knowledge.</p>
<p>Language servers are a counter example to the <a href="https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/">“never rewrite”</a> rule.
Majority of well regarded language servers are rewrites or alternative implementations of batch compilers.</p>
<p>Both IntelliJ and Eclipse wrote their own compilers rather than re-using javac inside an IDE.
To provide an adequate IDE support for C#, Microsoft rewrote their C++ batch compiler into an interactive self-hosted one (project Roslyn).
Dart, despite being a from-scratch, relatively modern language, ended up with <em>three</em> implementations (host AOT compiler, host IDE compiler (dart-analyzer), on-device JIT compiler).
Rust tried both — incremental evolution of rustc (RLS) and from-scratch implementation (rust-analyzer), and rust-analyzer decisively won.</p>
<p>The two exceptions I know are C++ and OCaml.
Curiously, both require forward declarations and header files, and I don’t think this is a coincidence.
See the <a href="https://rust-analyzer.github.io/blog/2020/07/20/three-architectures-for-responsive-ide.html">Three Architectures for a Responsive IDE</a> post for details.</p>
<p>To sum up, on the language server’s side things were in a bad equilibrium.
It was totally possible to implement language servers, but that required a bit of an iconoclastic approach, and it’s hard to be a pioneering iconoclast.</p>
<p>I am less certain what was happening on the editor’s side.
Still, I do want to claim that we had no editors capable of being an IDE.</p>
<p>IDE experience consists of a host of semantic features.
The most notable example is, of course completion.
If one wants to implement custom completion for VS Code, one needs to implement
<a href="https://code.visualstudio.com/api/references/vscode-api#CompletionItemProvider">CompletionItemProvider</a> interface:</p>
<div>
<div>
<pre><code data-lang="TypeScript"><table><tbody><tr><td><pre>1
2
3
4
5
6
</pre></td><td><pre>interface CompletionItemProvider {
    provideCompletionItems(
        document: TextDocument,
        position: Position,
    ): CompletionItem[]
}
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>This means that, in VS Code, code completion (as well as dozens of other IDE related features) is an editor’s first-class concept, with uniform user UI and developer API.</p>
<p>Contrast this with Emacs and Vim.
They just don’t have proper completion as an editor’s extension point.
Rather, they expose low-level cursor and screen manipulation API, and then people implement competing completion frameworks on top of that!</p>
<p>And that’s just code completion!
What about parameter info, inlay hints, breadcrumbs, extend selection, assists, symbol search, find usages (I’ll stop here :) )?</p>
<p>To sum the above succinctly, the problem with decent IDE support was not of <code>N * M</code>, but rather of an inadequate equilibrium of a two-sided market.</p>
<p>Language vendors were reluctant to create language servers, because it was hard, the demand was low (= no competition from other languages), and, even if one creates a language server, one would find a dozen editors absolutely unprepared to serve as a host for a smart server.</p>
<p>On the editor’s side, there was little incentive for adding high-level APIs needed for IDEs, because there were no potential providers for those APIs.</p>
</div></div>
  </body>
</html>
