<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.kellybrazil.com/2021/12/03/tips-on-adding-json-output-to-your-cli-app/">Original</a>
    <h1>Tips on adding JSON output to your CLI app</h1>
    
    <div id="readability-page-1" class="page"><div>
		
<p>A couple of years ago I wrote a somewhat controversial article on the topic of <a href="https://blog.kellybrazil.com/2019/11/26/bringing-the-unix-philosophy-to-the-21st-century/" target="_blank" rel="noreferrer noopener">Bringing the Unix Philosophy to the 21st Century</a> by adding a JSON output option to CLI tools. This allows easier parsing in scripts by using JSON parsing tools like <code><a href="https://stedolan.github.io/jq/" target="_blank" rel="noreferrer noopener">jq</a></code>, <code><a href="https://github.com/kellyjonbrazil/jello" target="_blank" rel="noreferrer noopener">jello</a></code>, <code><a href="https://github.com/jmespath/jp" target="_blank" rel="noreferrer noopener">jp</a></code>, etc. without arcane <code>awk</code>, <code>sed</code>, <code>cut</code>, <code>tr</code>, <code>reverse</code>, etc. incantations.</p>



<p>It was controversial because there seem to be a lot of folks who don’t think writing bespoke parsers for each task is a big deal. Others think JSON is evil. There are strong feelings as can be seen in response to the article in the comments and also on <a href="https://news.ycombinator.com/item?id=28266193" target="_blank" rel="noreferrer noopener">Hacker News</a> and <a href="https://www.reddit.com/r/programming/comments/pa4cbb/bringing_the_unix_philosophy_to_the_21st_century/" target="_blank" rel="noreferrer noopener">Reddit</a>.</p>



<p>I’ll let the next generation of DevOps practitioners and developers come to their own conclusions on the basis of our arguments, but the tide is already turning. Something that was just wishful thinking a couple years ago is now becoming a reality! Now, more and more command line applications are offering JSON output as an option. And with <code><a href="https://github.com/kellyjonbrazil/jc" target="_blank" rel="noreferrer noopener">jc</a></code>, JSON output can even be coaxed out of older command line applications.</p>



<h2 id="structured-output-support-is-increasing">Structured Output Support is Increasing</h2>



<p>Now, there are many new command line applications that offer structured output as an option, and even some older ones are adding the option.  I find that more and more often when a parser is requested for <code>jc</code>, if I check the man page for the application, there is already a JSON or XML output option. Some examples include <code>nvidia-smi</code>, <code>ffprobe</code>, <code>docker</code> CLI, and <code>tree</code>. Even <code>ip</code> now supports JSON output with <code>ip route</code>, which wasn’t supported when I originally wrote about it in the article.</p>



<p>I recently developed standard and streaming parsers for the <code>iostat</code> command and found that versions 11 and above now have a JSON output option. Way to go!</p>



<p>But when looking at the JSON options for some of these commands, I found some things that could be improved.</p>



<h2 id="json-output-do-s-and-don-ts">JSON Output Do’s and Don’ts</h2>



<p>While developing over 80 parsers for the <code>jc</code> project, I stumbled upon some best practices. My first goal was to make getting the data easy when using <code>jq</code>, as that was the only CLI JSON processing tool I really used at the time. With that initial goal, and input from scores of users, this is how I try to make the highest quality JSON output:</p>



<blockquote><p><strong>Note:</strong> Many of these are completely subjective and are just my humble opinion. I’m willing to keep an open mind about these choices.</p></blockquote>



<ul><li>Do Make a Schema</li><li>Do Flatten the Structure</li><li>Do Output JSON Lines for Streaming Output</li><li>Do Use Predictable Key Names</li><li>Do Pretty Print with Two Spaces or Don’t Format at All</li><li>Don’t Use Special Characters in Key Names</li><li>Don’t Allow Duplicate Keys</li><li>Don’t Use Very Large Numbers</li><li>BONUS</li></ul>



<p>Let’s take a look at these in more detail.</p>



<h3 id="do">Do</h3>



<p>Here are some good practices when generating JSON output:</p>



<h4 id="make-a-schema">Make a Schema</h4>



<p>When possible, which is almost always the case, I document a schema for the JSON output. This allows the user to know where they can always find an attribute and which type they can expect. (string, integer, float, boolean, null, object, array) This also allows you to test the output to make sure it conforms to the schema and there are no bugs.</p>



<p>A schema doesn’t have to be complicated. It can be specified in the documentation, including the man page. I use this simple structure for <code>jc</code> documentation:</p>



<pre data-enlighter-language="python" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">[
  {
    &#34;foo&#34;:      string,
    &#34;bar&#34;:      float,   # null if blank
    &#34;baz&#34;: [
                integer
    ]
  }
]</pre>



<h4 id="flatten-the-structure">Flatten the Structure</h4>



<p>The best case is to output an object or an array of objects (most common) with no further nesting. Sometimes you can prefix an attribute name if nesting is not absolutely necessary. The idea is to make it as easy for the user to grab the value so they don’t need to traverse the data structure to get what they want.</p>



<p>Sometimes this:</p>



<pre data-enlighter-language="json" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">[
  {
    &#34;cpu&#34;: {
      &#34;speed&#34;: 5,
      &#34;temp&#34;: 33.2
    },
    &#34;ram&#34;: {
      &#34;speed&#34;: 11,
      &#34;mb&#34;: 1024
    }
  }
]</pre>



<p>Can be turned into this:</p>



<pre data-enlighter-language="json" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">[
  {
    &#34;cpu_speed&#34;: 5,
    &#34;cpu_temp&#34;: 33.2,
    &#34;ram_speed&#34;: 11,
    &#34;ram_mb&#34;: 1024
  }
]</pre>



<p>This way I can easily filter the data in <code>jq</code> or other tools without having to traverse levels. Of course, this is not always possible or desirable, but keeping a flat structure should be considered for user convenience.</p>



<p>This approach is also great for output that contains a long list of items. I’ll pick on <code>iostat</code> a bit here to make a point – <strong><em>but don’t take this the wrong way – I’m thrilled that the author of <code>iostat</code> has included a JSON output option and in no way want to discount the work put into that</em></strong>.</p>



<p>The <code>iostat</code> JSON output option deeply nests the output like so:</p>



<pre data-enlighter-language="json" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">{
  &#34;sysstat&#34;: {
    &#34;hosts&#34;: [
      {
        &#34;nodename&#34;: &#34;ubuntu&#34;,
        &#34;sysname&#34;: &#34;Linux&#34;,
        &#34;release&#34;: &#34;5.8.0-53-generic&#34;,
        &#34;machine&#34;: &#34;x86_64&#34;,
        &#34;number-of-cpus&#34;: 2,
        &#34;date&#34;: &#34;12/03/2021&#34;,
        &#34;statistics&#34;: [
          {
            &#34;avg-cpu&#34;: {
              &#34;user&#34;: 0.6,
              &#34;nice&#34;: 0.01,
              &#34;system&#34;: 1.68,
              &#34;iowait&#34;: 0.14,
              &#34;steal&#34;: 0,
              &#34;idle&#34;: 97.58
            },
            &#34;disk&#34;: [
              {
                &#34;disk_device&#34;: &#34;dm-0&#34;,
                &#34;tps&#34;: 29.07,
                &#34;kB_read/s&#34;: 502.25,
                &#34;kB_wrtn/s&#34;: 54.94,
                &#34;kB_dscd/s&#34;: 0,
                &#34;kB_read&#34;: 251601,
                &#34;kB_wrtn&#34;: 27524,
                &#34;kB_dscd&#34;: 0
              },
...</pre>



<p>This makes sense and is very logical when you look at the output as an entire JSON document, but when dealing with command output from certain commands like <code>iostat</code>, <code>vmstat</code>, <code>ping</code>, <code>ls</code>, etc. which can have huge – even unlimited – amounts of output, it might make more sense to build the JSON structure into a format that is more easily consumed by tools like <code>jq</code> to be used in a pipeline.</p>



<p>With this structure, the whole document needs to be loaded before the JSON is considered valid and searchable, though <code>iostat</code> output can actually go on indefinitely depending on how the command is run.</p>



<p>I took a different approach with the <code>jc</code> <code>iostat</code> parser by using a flat array of objects and simply using a <code>type</code> attribute to denote which type of object it is. This allows very easy filtering in <code>jq</code> or other tools and <em>also allows consistency with the streaming parser, which I’ll get to in another section</em>.</p>



<p>Here’s the <code>jc</code> version:</p>



<pre data-enlighter-language="json" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">[
  {
    &#34;percent_user&#34;: 0.31,
    &#34;percent_nice&#34;: 0.23,
    &#34;percent_system&#34;: 0.48,
    &#34;percent_iowait&#34;: 0.04,
    &#34;percent_steal&#34;: 0.0,
    &#34;percent_idle&#34;: 98.95,
    &#34;type&#34;: &#34;cpu&#34;
  },
  {
    &#34;device&#34;: &#34;dm-0&#34;,
    &#34;tps&#34;: 8.16,
    &#34;kb_read_s&#34;: 137.26,
    &#34;kb_wrtn_s&#34;: 129.0,
    &#34;kb_dscd_s&#34;: 0.0,
    &#34;kb_read&#34;: 395021,
    &#34;kb_wrtn&#34;: 371240,
    &#34;kb_dscd&#34;: 0,
    &#34;type&#34;: &#34;device&#34;
  },
  {
    &#34;device&#34;: &#34;loop0&#34;,
    &#34;tps&#34;: 0.01,
    &#34;kb_read_s&#34;: 0.12,
    &#34;kb_wrtn_s&#34;: 0.0,
    &#34;kb_dscd_s&#34;: 0.0,
    &#34;kb_read&#34;: 344,
    &#34;kb_wrtn&#34;: 0,
    &#34;kb_dscd&#34;: 0,
    &#34;type&#34;: &#34;device&#34;
  },
...
]</pre>



<p>You’ll notice that <code>jc</code> doesn’t bother with metadata around the source of the data that generated the output or even the host statistics. This is because including the source just makes the object nesting deeper without adding value, and the header information is available with other tools like <code>uname</code> and <code>date</code>, though I could add them in a future parser version as an object with its own <code>type</code> if users want that data.</p>



<p>Getting to the data in this structure is pretty easy: just loop over the array, filter by <code>type</code> (if needed), and pull attributes from the top-level of each object.</p>



<h4 id="output-json-lines-for-streaming-output">Output JSON Lines for Streaming Output</h4>



<p>There’s another advantage to the array of flat objects structure discussed above, and that’s for programs like <code>iostat</code> and others that can stream output forever until the user hits <code>&lt;ctrl-c&gt;</code>. In this case, it would be difficult to pipe the output to a JSON filter, like <code>jq</code>, since the output would not be valid JSON until the program ends.</p>



<p>For these cases, outputting <a href="https://jsonlines.org/" target="_blank" rel="noreferrer noopener">JSON Lines</a> (aka <a href="http://ndjson.org/" target="_blank" rel="noreferrer noopener">NDJSON</a>) is a good choice.</p>



<p>Unfortunately, this is what the <code>iostat</code> output looks like when running it indefinitely:</p>



<pre data-enlighter-language="json" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">$ iostat 1 -o JSON
{&#34;sysstat&#34;: {
  &#34;hosts&#34;: [
    {
      &#34;nodename&#34;: &#34;ubuntu&#34;,
      &#34;sysname&#34;: &#34;Linux&#34;,
      &#34;release&#34;: &#34;5.8.0-53-generic&#34;,
      &#34;machine&#34;: &#34;x86_64&#34;,
      &#34;number-of-cpus&#34;: 2,
      &#34;date&#34;: &#34;12/03/2021&#34;,
      &#34;statistics&#34;: [
        {
          &#34;avg-cpu&#34;:  {&#34;user&#34;: 1.23, &#34;nice&#34;: 0.86, &#34;system&#34;: 1.23, &#34;iowait&#34;: 0.06, &#34;steal&#34;: 0.00, &#34;idle&#34;: 96.62},
          &#34;disk&#34;: [
            {&#34;disk_device&#34;: &#34;dm-0&#34;, &#34;tps&#34;: 30.16, &#34;kB_read/s&#34;: 138.78, &#34;kB_wrtn/s&#34;: 476.19, &#34;kB_dscd/s&#34;: 0.00, &#34;kB_read&#34;: 654975, &#34;kB_wrtn&#34;: 2247452, &#34;kB_dscd&#34;: 0},
            {&#34;disk_device&#34;: &#34;sr0&#34;, &#34;tps&#34;: 0.13, &#34;kB_read/s&#34;: 4.89, &#34;kB_wrtn/s&#34;: 0.00, &#34;kB_dscd/s&#34;: 0.00, &#34;kB_read&#34;: 23067, &#34;kB_wrtn&#34;: 0, &#34;kB_dscd&#34;: 0}
          ]
        },
        {
          &#34;avg-cpu&#34;:  {&#34;user&#34;: 0.00, &#34;nice&#34;: 0.00, &#34;system&#34;: 0.00, &#34;iowait&#34;: 0.00, &#34;steal&#34;: 0.00, &#34;idle&#34;: 100.00},
          &#34;disk&#34;: [
            {&#34;disk_device&#34;: &#34;dm-0&#34;, &#34;tps&#34;: 0.00, &#34;kB_read/s&#34;: 0.00, &#34;kB_wrtn/s&#34;: 0.00, &#34;kB_dscd/s&#34;: 0.00, &#34;kB_read&#34;: 0, &#34;kB_wrtn&#34;: 0, &#34;kB_dscd&#34;: 0},
            {&#34;disk_device&#34;: &#34;sr0&#34;, &#34;tps&#34;: 0.00, &#34;kB_read/s&#34;: 0.00, &#34;kB_wrtn/s&#34;: 0.00, &#34;kB_dscd/s&#34;: 0.00, &#34;kB_read&#34;: 0, &#34;kB_wrtn&#34;: 0, &#34;kB_dscd&#34;: 0}
          ]
        },
        {
          &#34;avg-cpu&#34;:  {&#34;user&#34;: 0.00, &#34;nice&#34;: 0.00, &#34;system&#34;: 0.50, &#34;iowait&#34;: 0.00, &#34;steal&#34;: 0.00, &#34;idle&#34;: 99.50},
          &#34;disk&#34;: [
            {&#34;disk_device&#34;: &#34;dm-0&#34;, &#34;tps&#34;: 5.00, &#34;kB_read/s&#34;: 0.00, &#34;kB_wrtn/s&#34;: 20.00, &#34;kB_dscd/s&#34;: 0.00, &#34;kB_read&#34;: 0, &#34;kB_wrtn&#34;: 20, &#34;kB_dscd&#34;: 0},
            {&#34;disk_device&#34;: &#34;sr0&#34;, &#34;tps&#34;: 0.00, &#34;kB_read/s&#34;: 0.00, &#34;kB_wrtn/s&#34;: 0.00, &#34;kB_dscd/s&#34;: 0.00, &#34;kB_read&#34;: 0, &#34;kB_wrtn&#34;: 0, &#34;kB_dscd&#34;: 0}
          ]
        }
...</pre>



<p>This is not easily parsable downstream when used in a pipeline:</p>



<pre data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">$ iostat 1 -o JSON | jq
^C     # hangs forever until &lt;ctrl-c&gt; is entered and no JSON is filtered</pre>



<p>The author of <code>iostat</code> did do a cool thing, though, and correctly wrapped the output in the final end brackets when the <code>&lt;ctrl-c&gt;</code> sequence is caught. So it does finally create a valid JSON document, but I’m not sure all developers will have the forethought to do this. Still, this does not solve the pipelining problem.</p>



<p>Instead, the <a href="https://kellyjonbrazil.github.io/jc/docs/parsers/iostat_s" target="_blank" rel="noreferrer noopener">streaming <code>iostat</code> parser</a> in <code>jc</code> outputs JSON lines with the same schema as the <a href="https://kellyjonbrazil.github.io/jc/docs/parsers/iostat" target="_blank" rel="noreferrer noopener">standard parser</a>. Basically, the only difference is that there are no beginning and ending array brackets and each object is compact printed on its own line. This allows JSON processors like <code>jq</code> to work on each line immediately as they are emitted:</p>



<pre data-enlighter-language="json" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">$ iostat 1 | jc --iostat-s -u | jq -c
{&#34;percent_user&#34;:1.11,&#34;percent_nice&#34;:0.78,&#34;percent_system&#34;:1.12,&#34;percent_iowait&#34;:0.05,&#34;percent_steal&#34;:0.0,&#34;percent_idle&#34;:96.94,&#34;type&#34;:&#34;cpu&#34;}
{&#34;device&#34;:&#34;dm-0&#34;,&#34;tps&#34;:27.4,&#34;kb_read_s&#34;:125.07,&#34;kb_wrtn_s&#34;:430.11,&#34;kb_dscd_s&#34;:0.0,&#34;kb_read&#34;:654987,&#34;kb_wrtn&#34;:2252376,&#34;kb_dscd&#34;:0,&#34;type&#34;:&#34;device&#34;}
{&#34;device&#34;:&#34;loop0&#34;,&#34;tps&#34;:0.02,&#34;kb_read_s&#34;:0.16,&#34;kb_wrtn_s&#34;:0.0,&#34;kb_dscd_s&#34;:0.0,&#34;kb_read&#34;:862,&#34;kb_wrtn&#34;:0,&#34;kb_dscd&#34;:0,&#34;type&#34;:&#34;device&#34;}
{&#34;percent_user&#34;:2.53,&#34;percent_nice&#34;:0.0,&#34;percent_system&#34;:1.52,&#34;percent_iowait&#34;:0.0,&#34;percent_steal&#34;:0.0,&#34;percent_idle&#34;:95.96,&#34;type&#34;:&#34;cpu&#34;}
{&#34;device&#34;:&#34;dm-0&#34;,&#34;tps&#34;:19.0,&#34;kb_read_s&#34;:0.0,&#34;kb_wrtn_s&#34;:76.0,&#34;kb_dscd_s&#34;:0.0,&#34;kb_read&#34;:0,&#34;kb_wrtn&#34;:76,&#34;kb_dscd&#34;:0,&#34;type&#34;:&#34;device&#34;}
{&#34;device&#34;:&#34;loop0&#34;,&#34;tps&#34;:0.0,&#34;kb_read_s&#34;:0.0,&#34;kb_wrtn_s&#34;:0.0,&#34;kb_dscd_s&#34;:0.0,&#34;kb_read&#34;:0,&#34;kb_wrtn&#34;:0,&#34;kb_dscd&#34;:0,&#34;type&#34;:&#34;device&#34;}
{&#34;percent_user&#34;:1.01,&#34;percent_nice&#34;:0.0,&#34;percent_system&#34;:0.0,&#34;percent_iowait&#34;:0.0,&#34;percent_steal&#34;:0.0,&#34;percent_idle&#34;:98.99,&#34;type&#34;:&#34;cpu&#34;}
{&#34;device&#34;:&#34;dm-0&#34;,&#34;tps&#34;:0.0,&#34;kb_read_s&#34;:0.0,&#34;kb_wrtn_s&#34;:0.0,&#34;kb_dscd_s&#34;:0.0,&#34;kb_read&#34;:0,&#34;kb_wrtn&#34;:0,&#34;kb_dscd&#34;:0,&#34;type&#34;:&#34;device&#34;}
{&#34;device&#34;:&#34;loop0&#34;,&#34;tps&#34;:0.0,&#34;kb_read_s&#34;:0.0,&#34;kb_wrtn_s&#34;:0.0,&#34;kb_dscd_s&#34;:0.0,&#34;kb_read&#34;:0,&#34;kb_wrtn&#34;:0,&#34;kb_dscd&#34;:0,&#34;type&#34;:&#34;device&#34;}
...</pre>



<blockquote><p><strong>Tip:</strong> If you include a JSON Lines output option, you might also want to include an ‘unbuffer’ option.</p><p>When directly printing to the terminal, the OS will disable buffering, but when piping to other programs there will be a buffer typically around 4KB. If the emitted JSON is small, it will look like the terminal is hung. This is why <code>jc</code> offers the <code>-u</code>, or <a href="https://github.com/kellyjonbrazil/jc#unbuffering-output" target="_blank" rel="noreferrer noopener">‘unbuffer’ option</a> like many other filtering tools do.</p><p>Note, that there may be a performance impact to disabling the buffer, so it should only be disabled while troubleshooting the pipeline in the terminal.</p></blockquote>



<h4 id="use-predictable-key-names">Use Predictable Key Names</h4>



<p>This one basically comes down to “don’t dynamically generate key names”. If key names aren’t static and predictable, it makes it difficult to have a good Schema and also makes it difficult for users to find the data.</p>



<p>Instead of doing something like this:</p>



<pre data-enlighter-language="json" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">{
  &#34;Interface 1&#34;: [
    &#34;192.168.1.1&#34;,
    &#34;172.16.1.1&#34;
  ],
  &#34;Wifi Interface 1&#34;: [
    &#34;10.1.1.1&#34;
  ]
}</pre>



<p>Do this:</p>



<pre data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">[
  {
    &#34;interface&#34;: &#34;Interface 1&#34;,
    &#34;ip_addresses&#34;: [
      &#34;192.168.1.1&#34;,
      &#34;172.16.1.1&#34;
    ]
  },
  {
    &#34;interface&#34;: &#34;Wifi Interface 1&#34;,
    &#34;ip_addresses&#34;: [
      &#34;10.1.1.1&#34;
    ]
  }
]</pre>



<p>This is a self-documented structure and the user can simply iterate over all of the objects to get the interface names and IP addresses they want. They can still get it the other way, but it’s not as straightforward and it also doesn’t allow you to have a nicely documented Schema.</p>



<h4 id="pretty-print-with-two-spaces-or-don-t-format-at-all">Pretty Print with Two Spaces or Don’t Format at All</h4>



<p>Higher-level languages like Python allow very easy formatting of the JSON output, so I typically see the issue of ugly formatted JSON with programs written in C:</p>



<figure><img data-attachment-id="1738" data-permalink="https://blog.kellybrazil.com/2021/12/03/tips-on-adding-json-output-to-your-cli-app/iostat-json/" data-orig-file="https://i0.wp.com/blog.kellybrazil.com/wp-content/uploads/2021/12/iostat-json.png?fit=1480%2C2494&amp;ssl=1" data-orig-size="1480,2494" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="iostat-json" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/blog.kellybrazil.com/wp-content/uploads/2021/12/iostat-json.png?fit=178%2C300&amp;ssl=1" data-large-file="https://i0.wp.com/blog.kellybrazil.com/wp-content/uploads/2021/12/iostat-json.png?fit=608%2C1024&amp;ssl=1" loading="lazy" width="608" height="1024" src="https://i0.wp.com/blog.kellybrazil.com/wp-content/uploads/2021/12/iostat-json.png?resize=608%2C1024&amp;ssl=1" alt="iostat JSON output formatting is not optimized for terminal line wrapping." data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/blog.kellybrazil.com/wp-content/uploads/2021/12/iostat-json.png?resize=608%2C1024&amp;ssl=1 608w, https://i0.wp.com/blog.kellybrazil.com/wp-content/uploads/2021/12/iostat-json.png?resize=178%2C300&amp;ssl=1 178w, https://i0.wp.com/blog.kellybrazil.com/wp-content/uploads/2021/12/iostat-json.png?resize=768%2C1294&amp;ssl=1 768w, https://i0.wp.com/blog.kellybrazil.com/wp-content/uploads/2021/12/iostat-json.png?resize=911%2C1536&amp;ssl=1 911w, https://i0.wp.com/blog.kellybrazil.com/wp-content/uploads/2021/12/iostat-json.png?resize=1215%2C2048&amp;ssl=1 1215w, https://i0.wp.com/blog.kellybrazil.com/wp-content/uploads/2021/12/iostat-json.png?resize=1200%2C2022&amp;ssl=1 1200w, https://i0.wp.com/blog.kellybrazil.com/wp-content/uploads/2021/12/iostat-json.png?w=1480&amp;ssl=1 1480w" data-lazy-sizes="(max-width: 608px) 100vw, 608px" data-lazy-src="https://i0.wp.com/blog.kellybrazil.com/wp-content/uploads/2021/12/iostat-json.png?resize=608%2C1024&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></figure>



<p>What is going on here? Actually – I can see what the developer was doing – it does look quite nice outside of the terminal when pasted into a text editor, but while inside the terminal the line wrapping makes it very unreadable.</p>



<p>I like the look of two-space indentation with JSON – maybe because that’s the way <code>jq</code> formats it and I’m just used to it.</p>



<p>There’s really no need to format JSON output at all. If it makes your code simpler, just generate the JSON with no newlines or spaces. This is more compact and the user can just as easily pipe the output through <code>jq</code> or other tools to format it.</p>



<p>If you do choose to format the JSON, then take a cue from <code>jq</code> and use two spaces of indent and don’t coalesce brackets. Like so:</p>



<pre data-enlighter-language="json" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">$ iostat -o JSON | jq
{
  &#34;sysstat&#34;: {
    &#34;hosts&#34;: [
      {
        &#34;nodename&#34;: &#34;ubuntu&#34;,
        &#34;sysname&#34;: &#34;Linux&#34;,
        &#34;release&#34;: &#34;5.8.0-53-generic&#34;,
        &#34;machine&#34;: &#34;x86_64&#34;,
        &#34;number-of-cpus&#34;: 2,
        &#34;date&#34;: &#34;12/03/2021&#34;,
        &#34;statistics&#34;: [
          {
            &#34;avg-cpu&#34;: {
              &#34;user&#34;: 0.6,
              &#34;nice&#34;: 0.01,
              &#34;system&#34;: 1.68,
              &#34;iowait&#34;: 0.14,
              &#34;steal&#34;: 0,
              &#34;idle&#34;: 97.58
            },
            &#34;disk&#34;: [
              {
                &#34;disk_device&#34;: &#34;dm-0&#34;,
                &#34;tps&#34;: 29.07,
                &#34;kB_read/s&#34;: 502.25,
                &#34;kB_wrtn/s&#34;: 54.94,
                &#34;kB_dscd/s&#34;: 0,
                &#34;kB_read&#34;: 251601,
                &#34;kB_wrtn&#34;: 27524,
                &#34;kB_dscd&#34;: 0
              },
              &lt;SNIP&gt;
              {
                &#34;disk_device&#34;: &#34;sr0&#34;,
                &#34;tps&#34;: 0.19,
                &#34;kB_read/s&#34;: 6.27,
                &#34;kB_wrtn/s&#34;: 0,
                &#34;kB_dscd/s&#34;: 0,
                &#34;kB_read&#34;: 3139,
                &#34;kB_wrtn&#34;: 0,
                &#34;kB_dscd&#34;: 0
              }
            ]
          }
        ]
      }
    ]
  }
}</pre>



<p>Beggars can’t be choosers, so I’ll take ugly JSON over no JSON any day. But again, compact JSON with no spaces and newlines is perfectly fine. Anyone working with JSON knows to use <code>jq</code> or other tools to make it easy to read in the terminal.</p>



<h3 id="don-t">Don’t</h3>



<p>Try to avoid these JSON smells:</p>



<h4 id="don-t-use-special-characters-in-key-names">Don’t Use Special Characters in Key Names</h4>



<p>There’s nothing more annoying than having to encapsulate an attribute name in brackets because it has special characters or spaces in it.</p>



<pre data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">$ echo &#39;{&#34;Foo/ foo&#34;: &#34;bar&#34;}&#39; | jq &#39;.Foo/ foo&#39;
jq: error: foo/0 is not defined at &lt;top-level&gt;, line 1:
.Foo/ foo      
jq: 1 compile error

$ echo &#39;{&#34;Foo/ foo&#34;: &#34;bar&#34;}&#39; | jq &#39;.[&#34;Foo/ foo&#34;]&#39;
&#34;bar&#34;</pre>



<p>Don’t make your users do that! This can also be a consequence of dynamically generating your keys, as discussed in a section above. Instead, keep all key characters lower-case and convert special characters to underscores (‘<code>_</code>‘) to keep them alphanumeric.</p>



<p>Underscores are better than dashes because they allow you to select the entire key with a double-click in most IDEs and text editors. Dashes will typically only select a section of the key name.</p>



<h4 id="don-t-allow-duplicate-keys">Don’t Allow Duplicate Keys</h4>



<p>If you are dynamically generating key names it may be possible for duplicates to appear in an object. If there is a possibility of this, wrap those items in individual objects. Duplicate keys are undefined in JSON and may cause different behavior depending on the client.</p>



<h4 id="don-t-use-extremely-large-numbers">Don’t Use Extremely Large Numbers</h4>



<p>JSON has nice typing, but unfortunately the numeric data type is underspecified in the standard and may have different behavior with different clients. This can happen if you output a long UUID as a number – the UUID may actually not turn out to be the same on all clients! If you have a very large number, it’s probably best to just wrap it in a string so it doesn’t get mangled downstream.</p>



<h4 id="don-t-use-xml">Don’t Use XML</h4>



<p>Just joking! Any standard structured output is better than plain text in many cases, and sometimes (but not often) XML is a better choice than JSON. I prefer JSON for its readability, support ecosystem, and for its support for maps, arrays, and limited types. After developing JSON schemas for over 80 CLI parsers I’ve found that there’s not much JSON can’t do for this type of output.</p>



<h2 id="in-conclusion">In Conclusion</h2>



<p>Always think of the end-user and how they will interact with the data. By following these steps, you can keep the users from having to jump through extra hoops to get to the data they want:</p>



<ul><li>Make a Schema</li><li>Flatten the Structure</li><li>Output JSON Lines for Streaming Output</li><li>Use Predictable Key Names</li><li>Pretty Print with Two Spaces or Don’t Format at All</li><li>Don’t Use Special Characters in Key Names</li><li>Don’t Allow Duplicate Keys</li><li>Don’t Use Very Large Numbers</li></ul>



<p>This is clearly not an exhaustive list. Did I miss any of your pet peeves? Let me know in the comments!</p>
	</div></div>
  </body>
</html>
