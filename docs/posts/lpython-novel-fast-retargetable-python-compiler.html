<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lpython.org/blog/2023/07/lpython-novel-fast-retargetable-python-compiler/">Original</a>
    <h1>LPython: Novel, Fast, Retargetable Python Compiler</h1>
    
    <div id="readability-page-1" class="page"><div role="main">
  <div>
    <div>
      <article role="main">
        <h2 id="about">About</h2>
<p>LPython is a Python compiler that can compile type-annotated Python code to optimized machine code. LPython offers several backends such as LLVM, C, C++, WASM, Julia and x86. LPython features quick compilation and runtime performance, as we show in the benchmarks in this blog. LPython also offers Just-In-Time (JIT) compilation and seamless interoperability with CPython.</p>
<p>We are releasing an alpha version of LPython, meaning it is expected you
encounter bugs when you use it (please report them!). You can install it using
Conda (<code>conda install -c conda-forge lpython</code>), or build from
<a href="https://github.com/lcompilers/lpython">source</a>.</p>
<p>Based on the novel Abstract Semantic Representation (ASR) shared with LFortran, LPython’s intermediate optimizations are independent of the backends and frontends. The two compilers, LPython and LFortran, share all benefits of improvements at the ASR level. “Speed” is the chief tenet of the LPython project. Our objective is to produce a compiler that both runs exceptionally fast and generates exceptionally fast code.</p>
<p>In this blog, we describe features of LPython including Ahead-of-Time (AoT) compilation, JIT compilation, and interoperability with CPython. We also showcase LPython’s performance against its competitors such as Numba and C++ via several benchmarks.</p>
<p><img src="https://lpython.org/blog/images/lcompilers_diagram.png" alt="LCompilers-Diagram"/></p>
<h2 id="features-of-lpython">Features of LPython</h2>
<h3 id="backends">Backends</h3>
<p>LPython ships with the following backends, which emit final translations of the user’s input code:</p>
<ol>
<li>LLVM</li>
<li>C</li>
<li>C++</li>
<li>WASM</li>
</ol>
<p>LPython can simultaneously generate code into multiple backends from its Abstract Semantic Representation (ASR) of user code.</p>
<h3 id="phases-of-compilation">Phases of Compilation</h3>
<p>First, input code is transformed into an Abstract Syntax Tree (AST) using parsers. The AST is then transformed into an Abstract Semantic Representation (ASR), which preserves all semantic information present in the input code. ASR contains all information required by all backends in a form that is not specific to any particular backend. Then, this ASR enjoys several ASR-to-ASR passes, wherein abstract operations are transformed into concrete statements. For example, array addition in the input code denoted, <code>c = a + b</code>. The front end transforms <code>c = a + b</code> into the ASR <code>(Assign c (ArrayAdd a b))</code> via operator overloading. The <em>array_op</em> ASR-to-ASR pass transforms <code>(Assign c (ArrayAdd a b))</code> into loops:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>for</span> i0 <span>in</span> range(<span>0</span>, length_dim_0):
</span></span><span><span>    <span>for</span> i1 <span>in</span> range(<span>0</span>, length_dim_1):
</span></span><span><span>        <span>....</span>
</span></span><span><span>            <span>....</span>
</span></span><span><span>            c[i0, i1, <span>...</span>] <span>=</span> a[i0, i1, <span>...</span>] <span>+</span> b[i0, i1, <span>...</span>]
</span></span></code></pre></div><p>After applying all the ASR-to-ASR passes, LPython sends the final ASR to the backends selected by the user, via command-line arguments like, <code>--show-c</code> (generates C code), <code>--show-llvm</code> (generates LLVM code).</p>
<p>One can also see the generated C or LLVM code using the following</p>
<div><pre tabindex="0"><code data-lang="py"><span><span><span>from</span> lpython <span>import</span> i32
</span></span><span><span>
</span></span><span><span><span>def</span> <span>main</span>():
</span></span><span><span>    x: i32
</span></span><span><span>    x <span>=</span> (<span>2</span><span>+</span><span>3</span>)<span>*</span><span>5</span>
</span></span><span><span>    print(x)
</span></span><span><span>
</span></span><span><span>main()
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="c"><span><span><span>$</span> lpython examples<span>/</span>expr2.py <span>--</span>show<span>-</span>c
</span></span><span><span><span>#include</span> <span>&lt;inttypes.h&gt;</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span><span>#include</span> <span>&lt;stdlib.h&gt;</span><span>
</span></span></span><span><span><span>#include</span> <span>&lt;stdbool.h&gt;</span><span>
</span></span></span><span><span><span>#include</span> <span>&lt;stdio.h&gt;</span><span>
</span></span></span><span><span><span>#include</span> <span>&lt;string.h&gt;</span><span>
</span></span></span><span><span><span>#include</span> <span>&lt;lfortran_intrinsics.h&gt;</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span><span>void</span> <span>main0</span>();
</span></span><span><span><span>void</span> <span>__main____global_statements</span>();
</span></span><span><span>
</span></span><span><span><span>// Implementations
</span></span></span><span><span><span></span><span>void</span> <span>main0</span>()
</span></span><span><span>{
</span></span><span><span>    <span>int32_t</span> x;
</span></span><span><span>    x <span>=</span> (<span>2</span> <span>+</span> <span>3</span>)<span>*</span><span>5</span>;
</span></span><span><span>    <span>printf</span>(<span>&#34;%d</span><span>\n</span><span>&#34;</span>, x);
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>void</span> <span>__main____global_statements</span>()
</span></span><span><span>{
</span></span><span><span>    <span>main0</span>();
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>int</span> <span>main</span>(<span>int</span> argc, <span>char</span><span>*</span> argv[])
</span></span><span><span>{
</span></span><span><span>    <span>_lpython_set_argv</span>(argc, argv);
</span></span><span><span>    <span>__main____global_statements</span>();
</span></span><span><span>    <span>return</span> <span>0</span>;
</span></span><span><span>}
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="llvm"><span><span><span>$</span> <span>lpython</span> <span>examples/expr</span><span>2</span>.<span>py</span> <span>--show-llvm</span>
</span></span><span><span><span>; ModuleID = &#39;LFortran&#39;
</span></span></span><span><span><span></span><span>source_filename</span> = <span>&#34;LFortran&#34;</span>
</span></span><span><span>
</span></span><span><span>@0 = <span>private</span> <span>unnamed_addr</span> <span>constant</span> [<span>2</span> <span>x</span> <span>i8</span>] <span>c</span><span>&#34; \00&#34;</span>, <span>align</span> <span>1</span>
</span></span><span><span>@1 = <span>private</span> <span>unnamed_addr</span> <span>constant</span> [<span>2</span> <span>x</span> <span>i8</span>] <span>c</span><span>&#34;\0A\00&#34;</span>, <span>align</span> <span>1</span>
</span></span><span><span>@2 = <span>private</span> <span>unnamed_addr</span> <span>constant</span> [<span>5</span> <span>x</span> <span>i8</span>] <span>c</span><span>&#34;%d%s\00&#34;</span>, <span>align</span> <span>1</span>
</span></span><span><span>
</span></span><span><span><span>define</span> <span>void</span> @__module___main_____main____global_statements() {
</span></span><span><span>.entry:
</span></span><span><span>  <span>call</span> <span>void</span> @__module___main___main0()
</span></span><span><span>  <span>br</span> <span>label</span> %return
</span></span><span><span>
</span></span><span><span>return:                                           <span>; preds = %.entry
</span></span></span><span><span><span></span>  <span>ret</span> <span>void</span>
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>define</span> <span>void</span> @__module___main___main0() {
</span></span><span><span>.entry:
</span></span><span><span>  %x = <span>alloca</span> <span>i32</span>, <span>align</span> <span>4</span>
</span></span><span><span>  <span>store</span> <span>i32</span> <span>25</span>, <span>i32</span>* %x, <span>align</span> <span>4</span>
</span></span><span><span>  %0 = <span>load</span> <span>i32</span>, <span>i32</span>* %x, <span>align</span> <span>4</span>
</span></span><span><span>  <span>call</span> <span>void</span> (<span>i8</span>*, ...) @_lfortran_printf(<span>i8</span>* <span>getelementptr</span> <span>inbounds</span> ([<span>5</span> <span>x</span> <span>i8</span>], [<span>5</span> <span>x</span> <span>i8</span>]* @2, <span>i32</span> <span>0</span>, <span>i32</span> <span>0</span>), <span>i32</span> %0, <span>i8</span>* <span>getelementptr</span> <span>inbounds</span> ([<span>2</span> <span>x</span> <span>i8</span>], [<span>2</span> <span>x</span> <span>i8</span>]* @1, <span>i32</span> <span>0</span>, <span>i32</span> <span>0</span>))
</span></span><span><span>  <span>br</span> <span>label</span> %return
</span></span><span><span>
</span></span><span><span>return:                                           <span>; preds = %.entry
</span></span></span><span><span><span></span>  <span>ret</span> <span>void</span>
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>declare</span> <span>void</span> @_lfortran_printf(<span>i8</span>*, ...)
</span></span><span><span>
</span></span><span><span><span>define</span> <span>i32</span> @main(<span>i32</span> %0, <span>i8</span>** %1) {
</span></span><span><span>.entry:
</span></span><span><span>  <span>call</span> <span>void</span> @_lpython_set_argv(<span>i32</span> %0, <span>i8</span>** %1)
</span></span><span><span>  <span>call</span> <span>void</span> @__module___main_____main____global_statements()
</span></span><span><span>  <span>ret</span> <span>i32</span> <span>0</span>
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>declare</span> <span>void</span> @_lpython_set_argv(<span>i32</span>, <span>i8</span>**)
</span></span></code></pre></div><h3 id="machine-independent-code-optimisations">Machine Independent Code Optimisations</h3>
<p>LPython implements several machine-independent optimisations via ASR-to-ASR passes. Some of those are listed below,</p>
<ol>
<li>Loop unrolling</li>
<li>Loop vectorisation</li>
<li>Dead code removal</li>
<li>Function call inlining</li>
<li>Transforming division to multiplication operation</li>
<li>Fused multiplication and addition</li>
</ol>
<p>All optimizations are applied via one command-line argument, <code>--fast</code>. To select individual optimizations instead, write a command-line argument like the following:</p>
<p><code>--pass=inline_function_calls,loop_unroll</code></p>
<p>Following is an examples of ASR and transformed ASR after applying the optimisations</p>
<div><pre tabindex="0"><code data-lang="py"><span><span><span>from</span> lpython <span>import</span> i32
</span></span><span><span>
</span></span><span><span><span>def</span> <span>compute_x</span>() <span>-&gt;</span> i32:
</span></span><span><span>    <span>return</span> (<span>2</span> <span>*</span> <span>3</span>) <span>**</span> <span>1</span> <span>+</span> <span>2</span>
</span></span><span><span>
</span></span><span><span><span>def</span> <span>main</span>():
</span></span><span><span>    x: i32 <span>=</span> compute_x()
</span></span><span><span>    print(x)
</span></span><span><span>
</span></span><span><span>main()
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="clojure"><span><span>$ lpython examples/expr2.py --show-asr
</span></span><span><span>(<span>TranslationUnit</span>
</span></span><span><span>    (<span>SymbolTable</span>
</span></span><span><span>        <span>1</span>
</span></span><span><span>        {
</span></span><span><span>            __main__<span>:</span>
</span></span><span><span>                (<span>Module</span>
</span></span><span><span>                    (<span>SymbolTable</span>
</span></span><span><span>                        <span>2</span>
</span></span><span><span>                        {
</span></span><span><span>                            __main____global_statements<span>:</span>
</span></span><span><span>                                (<span>Function</span>
</span></span><span><span>                                    (<span>SymbolTable</span>
</span></span><span><span>                                        <span>5</span>
</span></span><span><span>                                        {
</span></span><span><span>
</span></span><span><span>                                        })
</span></span><span><span>                                    __main____global_statements
</span></span><span><span>                                    (<span>FunctionType</span>
</span></span><span><span>                                        []
</span></span><span><span>                                        ()
</span></span><span><span>                                        Source
</span></span><span><span>                                        Implementation
</span></span><span><span>                                        ()
</span></span><span><span>                                        .false.
</span></span><span><span>                                        .false.
</span></span><span><span>                                        .false.
</span></span><span><span>                                        .false.
</span></span><span><span>                                        .false.
</span></span><span><span>                                        []
</span></span><span><span>                                        []
</span></span><span><span>                                        .false.
</span></span><span><span>                                    )
</span></span><span><span>                                    [main]
</span></span><span><span>                                    []
</span></span><span><span>                                    [(<span>SubroutineCall</span>
</span></span><span><span>                                        <span>2</span> main
</span></span><span><span>                                        ()
</span></span><span><span>                                        []
</span></span><span><span>                                        ()
</span></span><span><span>                                    )]
</span></span><span><span>                                    ()
</span></span><span><span>                                    Public
</span></span><span><span>                                    .false.
</span></span><span><span>                                    .false.
</span></span><span><span>                                    ()
</span></span><span><span>                                ),
</span></span><span><span>                            compute_x<span>:</span>
</span></span><span><span>                                (<span>Function</span>
</span></span><span><span>                                    (<span>SymbolTable</span>
</span></span><span><span>                                        <span>3</span>
</span></span><span><span>                                        {
</span></span><span><span>                                            _lpython_return_variable<span>:</span>
</span></span><span><span>                                                (<span>Variable</span>
</span></span><span><span>                                                    <span>3</span>
</span></span><span><span>                                                    _lpython_return_variable
</span></span><span><span>                                                    []
</span></span><span><span>                                                    ReturnVar
</span></span><span><span>                                                    ()
</span></span><span><span>                                                    ()
</span></span><span><span>                                                    Default
</span></span><span><span>                                                    (<span>Integer</span> <span>4</span>)
</span></span><span><span>                                                    ()
</span></span><span><span>                                                    Source
</span></span><span><span>                                                    Public
</span></span><span><span>                                                    Required
</span></span><span><span>                                                    .false.
</span></span><span><span>                                                )
</span></span><span><span>                                        })
</span></span><span><span>                                    compute_x
</span></span><span><span>                                    (<span>FunctionType</span>
</span></span><span><span>                                        []
</span></span><span><span>                                        (<span>Integer</span> <span>4</span>)
</span></span><span><span>                                        Source
</span></span><span><span>                                        Implementation
</span></span><span><span>                                        ()
</span></span><span><span>                                        .false.
</span></span><span><span>                                        .false.
</span></span><span><span>                                        .false.
</span></span><span><span>                                        .false.
</span></span><span><span>                                        .false.
</span></span><span><span>                                        []
</span></span><span><span>                                        []
</span></span><span><span>                                        .false.
</span></span><span><span>                                    )
</span></span><span><span>                                    []
</span></span><span><span>                                    []
</span></span><span><span>                                    [(<span>=</span>
</span></span><span><span>                                        (<span>Var</span> <span>3</span> _lpython_return_variable)
</span></span><span><span>                                        (<span>IntegerBinOp</span>
</span></span><span><span>                                            (<span>IntegerBinOp</span>
</span></span><span><span>                                                (<span>IntegerBinOp</span>
</span></span><span><span>                                                    (<span>IntegerConstant</span> <span>2</span> (<span>Integer</span> <span>4</span>))
</span></span><span><span>                                                    Mul
</span></span><span><span>                                                    (<span>IntegerConstant</span> <span>3</span> (<span>Integer</span> <span>4</span>))
</span></span><span><span>                                                    (<span>Integer</span> <span>4</span>)
</span></span><span><span>                                                    (<span>IntegerConstant</span> <span>6</span> (<span>Integer</span> <span>4</span>))
</span></span><span><span>                                                )
</span></span><span><span>                                                Pow
</span></span><span><span>                                                (<span>IntegerConstant</span> <span>1</span> (<span>Integer</span> <span>4</span>))
</span></span><span><span>                                                (<span>Integer</span> <span>4</span>)
</span></span><span><span>                                                (<span>IntegerConstant</span> <span>6</span> (<span>Integer</span> <span>4</span>))
</span></span><span><span>                                            )
</span></span><span><span>                                            Add
</span></span><span><span>                                            (<span>IntegerConstant</span> <span>2</span> (<span>Integer</span> <span>4</span>))
</span></span><span><span>                                            (<span>Integer</span> <span>4</span>)
</span></span><span><span>                                            (<span>IntegerConstant</span> <span>8</span> (<span>Integer</span> <span>4</span>))
</span></span><span><span>                                        )
</span></span><span><span>                                        ()
</span></span><span><span>                                    )
</span></span><span><span>                                    (<span>Return</span>)]
</span></span><span><span>                                    (<span>Var</span> <span>3</span> _lpython_return_variable)
</span></span><span><span>                                    Public
</span></span><span><span>                                    .false.
</span></span><span><span>                                    .false.
</span></span><span><span>                                    ()
</span></span><span><span>                                ),
</span></span><span><span>                            main<span>:</span>
</span></span><span><span>                                (<span>Function</span>
</span></span><span><span>                                    (<span>SymbolTable</span>
</span></span><span><span>                                        <span>4</span>
</span></span><span><span>                                        {
</span></span><span><span>                                            x<span>:</span>
</span></span><span><span>                                                (<span>Variable</span>
</span></span><span><span>                                                    <span>4</span>
</span></span><span><span>                                                    x
</span></span><span><span>                                                    []
</span></span><span><span>                                                    Local
</span></span><span><span>                                                    ()
</span></span><span><span>                                                    ()
</span></span><span><span>                                                    Default
</span></span><span><span>                                                    (<span>Integer</span> <span>4</span>)
</span></span><span><span>                                                    ()
</span></span><span><span>                                                    Source
</span></span><span><span>                                                    Public
</span></span><span><span>                                                    Required
</span></span><span><span>                                                    .false.
</span></span><span><span>                                                )
</span></span><span><span>                                        })
</span></span><span><span>                                    main
</span></span><span><span>                                    (<span>FunctionType</span>
</span></span><span><span>                                        []
</span></span><span><span>                                        ()
</span></span><span><span>                                        Source
</span></span><span><span>                                        Implementation
</span></span><span><span>                                        ()
</span></span><span><span>                                        .false.
</span></span><span><span>                                        .false.
</span></span><span><span>                                        .false.
</span></span><span><span>                                        .false.
</span></span><span><span>                                        .false.
</span></span><span><span>                                        []
</span></span><span><span>                                        []
</span></span><span><span>                                        .false.
</span></span><span><span>                                    )
</span></span><span><span>                                    [compute_x]
</span></span><span><span>                                    []
</span></span><span><span>                                    [(<span>=</span>
</span></span><span><span>                                        (<span>Var</span> <span>4</span> x)
</span></span><span><span>                                        (<span>FunctionCall</span>
</span></span><span><span>                                            <span>2</span> compute_x
</span></span><span><span>                                            ()
</span></span><span><span>                                            []
</span></span><span><span>                                            (<span>Integer</span> <span>4</span>)
</span></span><span><span>                                            ()
</span></span><span><span>                                            ()
</span></span><span><span>                                        )
</span></span><span><span>                                        ()
</span></span><span><span>                                    )
</span></span><span><span>                                    (<span>Print</span>
</span></span><span><span>                                        ()
</span></span><span><span>                                        [(<span>Var</span> <span>4</span> x)]
</span></span><span><span>                                        ()
</span></span><span><span>                                        ()
</span></span><span><span>                                    )]
</span></span><span><span>                                    ()
</span></span><span><span>                                    Public
</span></span><span><span>                                    .false.
</span></span><span><span>                                    .false.
</span></span><span><span>                                    ()
</span></span><span><span>                                )
</span></span><span><span>                        })
</span></span><span><span>                    __main__
</span></span><span><span>                    []
</span></span><span><span>                    .false.
</span></span><span><span>                    .false.
</span></span><span><span>                ),
</span></span><span><span>            main_program<span>:</span>
</span></span><span><span>                (<span>Program</span>
</span></span><span><span>                    (<span>SymbolTable</span>
</span></span><span><span>                        <span>6</span>
</span></span><span><span>                        {
</span></span><span><span>                            __main____global_statements<span>:</span>
</span></span><span><span>                                (<span>ExternalSymbol</span>
</span></span><span><span>                                    <span>6</span>
</span></span><span><span>                                    __main____global_statements
</span></span><span><span>                                    <span>2</span> __main____global_statements
</span></span><span><span>                                    __main__
</span></span><span><span>                                    []
</span></span><span><span>                                    __main____global_statements
</span></span><span><span>                                    Public
</span></span><span><span>                                )
</span></span><span><span>                        })
</span></span><span><span>                    main_program
</span></span><span><span>                    [__main__]
</span></span><span><span>                    [(<span>SubroutineCall</span>
</span></span><span><span>                        <span>6</span> __main____global_statements
</span></span><span><span>                        <span>2</span> __main____global_statements
</span></span><span><span>                        []
</span></span><span><span>                        ()
</span></span><span><span>                    )]
</span></span><span><span>                )
</span></span><span><span>        })
</span></span><span><span>    []
</span></span><span><span>)
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="clojure"><span><span>$ lpython examples/expr2.py --show-asr --pass=inline_function_calls,unused_functions
</span></span><span><span>(<span>TranslationUnit</span>
</span></span><span><span>    (<span>SymbolTable</span>
</span></span><span><span>        <span>1</span>
</span></span><span><span>        {
</span></span><span><span>            __main__<span>:</span>
</span></span><span><span>                (<span>Module</span>
</span></span><span><span>                    (<span>SymbolTable</span>
</span></span><span><span>                        <span>2</span>
</span></span><span><span>                        {
</span></span><span><span>                            __main____global_statements<span>:</span>
</span></span><span><span>                                (<span>Function</span>
</span></span><span><span>                                    (<span>SymbolTable</span>
</span></span><span><span>                                        <span>5</span>
</span></span><span><span>                                        {
</span></span><span><span>
</span></span><span><span>                                        })
</span></span><span><span>                                    __main____global_statements
</span></span><span><span>                                    (<span>FunctionType</span>
</span></span><span><span>                                        []
</span></span><span><span>                                        ()
</span></span><span><span>                                        Source
</span></span><span><span>                                        Implementation
</span></span><span><span>                                        ()
</span></span><span><span>                                        .false.
</span></span><span><span>                                        .false.
</span></span><span><span>                                        .false.
</span></span><span><span>                                        .false.
</span></span><span><span>                                        .false.
</span></span><span><span>                                        []
</span></span><span><span>                                        []
</span></span><span><span>                                        .false.
</span></span><span><span>                                    )
</span></span><span><span>                                    [main]
</span></span><span><span>                                    []
</span></span><span><span>                                    [(<span>SubroutineCall</span>
</span></span><span><span>                                        <span>2</span> main
</span></span><span><span>                                        ()
</span></span><span><span>                                        []
</span></span><span><span>                                        ()
</span></span><span><span>                                    )]
</span></span><span><span>                                    ()
</span></span><span><span>                                    Public
</span></span><span><span>                                    .false.
</span></span><span><span>                                    .false.
</span></span><span><span>                                    ()
</span></span><span><span>                                ),
</span></span><span><span>                            main<span>:</span>
</span></span><span><span>                                (<span>Function</span>
</span></span><span><span>                                    (<span>SymbolTable</span>
</span></span><span><span>                                        <span>4</span>
</span></span><span><span>                                        {
</span></span><span><span>                                            _lpython_return_variable_compute_x<span>:</span>
</span></span><span><span>                                                (<span>Variable</span>
</span></span><span><span>                                                    <span>4</span>
</span></span><span><span>                                                    _lpython_return_variable_compute_x
</span></span><span><span>                                                    []
</span></span><span><span>                                                    Local
</span></span><span><span>                                                    ()
</span></span><span><span>                                                    ()
</span></span><span><span>                                                    Default
</span></span><span><span>                                                    (<span>Integer</span> <span>4</span>)
</span></span><span><span>                                                    ()
</span></span><span><span>                                                    Source
</span></span><span><span>                                                    Public
</span></span><span><span>                                                    Required
</span></span><span><span>                                                    .false.
</span></span><span><span>                                                ),
</span></span><span><span>                                            x<span>:</span>
</span></span><span><span>                                                (<span>Variable</span>
</span></span><span><span>                                                    <span>4</span>
</span></span><span><span>                                                    x
</span></span><span><span>                                                    []
</span></span><span><span>                                                    Local
</span></span><span><span>                                                    ()
</span></span><span><span>                                                    ()
</span></span><span><span>                                                    Default
</span></span><span><span>                                                    (<span>Integer</span> <span>4</span>)
</span></span><span><span>                                                    ()
</span></span><span><span>                                                    Source
</span></span><span><span>                                                    Public
</span></span><span><span>                                                    Required
</span></span><span><span>                                                    .false.
</span></span><span><span>                                                ),
</span></span><span><span>                                            <span>~</span>empty_block<span>:</span>
</span></span><span><span>                                                (<span>Block</span>
</span></span><span><span>                                                    (<span>SymbolTable</span>
</span></span><span><span>                                                        <span>7</span>
</span></span><span><span>                                                        {
</span></span><span><span>
</span></span><span><span>                                                        })
</span></span><span><span>                                                    <span>~</span>empty_block
</span></span><span><span>                                                    []
</span></span><span><span>                                                )
</span></span><span><span>                                        })
</span></span><span><span>                                    main
</span></span><span><span>                                    (<span>FunctionType</span>
</span></span><span><span>                                        []
</span></span><span><span>                                        ()
</span></span><span><span>                                        Source
</span></span><span><span>                                        Implementation
</span></span><span><span>                                        ()
</span></span><span><span>                                        .false.
</span></span><span><span>                                        .false.
</span></span><span><span>                                        .false.
</span></span><span><span>                                        .false.
</span></span><span><span>                                        .false.
</span></span><span><span>                                        []
</span></span><span><span>                                        []
</span></span><span><span>                                        .false.
</span></span><span><span>                                    )
</span></span><span><span>                                    []
</span></span><span><span>                                    []
</span></span><span><span>                                    [(<span>=</span>
</span></span><span><span>                                        (<span>Var</span> <span>4</span> _lpython_return_variable_compute_x)
</span></span><span><span>                                        (<span>IntegerBinOp</span>
</span></span><span><span>                                            (<span>IntegerBinOp</span>
</span></span><span><span>                                                (<span>IntegerBinOp</span>
</span></span><span><span>                                                    (<span>IntegerConstant</span> <span>2</span> (<span>Integer</span> <span>4</span>))
</span></span><span><span>                                                    Mul
</span></span><span><span>                                                    (<span>IntegerConstant</span> <span>3</span> (<span>Integer</span> <span>4</span>))
</span></span><span><span>                                                    (<span>Integer</span> <span>4</span>)
</span></span><span><span>                                                    (<span>IntegerConstant</span> <span>6</span> (<span>Integer</span> <span>4</span>))
</span></span><span><span>                                                )
</span></span><span><span>                                                Pow
</span></span><span><span>                                                (<span>IntegerConstant</span> <span>1</span> (<span>Integer</span> <span>4</span>))
</span></span><span><span>                                                (<span>Integer</span> <span>4</span>)
</span></span><span><span>                                                (<span>IntegerConstant</span> <span>6</span> (<span>Integer</span> <span>4</span>))
</span></span><span><span>                                            )
</span></span><span><span>                                            Add
</span></span><span><span>                                            (<span>IntegerConstant</span> <span>2</span> (<span>Integer</span> <span>4</span>))
</span></span><span><span>                                            (<span>Integer</span> <span>4</span>)
</span></span><span><span>                                            (<span>IntegerConstant</span> <span>8</span> (<span>Integer</span> <span>4</span>))
</span></span><span><span>                                        )
</span></span><span><span>                                        ()
</span></span><span><span>                                    )
</span></span><span><span>                                    (<span>GoTo</span>
</span></span><span><span>                                        <span>1</span>
</span></span><span><span>                                        __1
</span></span><span><span>                                    )
</span></span><span><span>                                    (<span>BlockCall</span>
</span></span><span><span>                                        <span>1</span>
</span></span><span><span>                                        <span>4</span> <span>~</span>empty_block
</span></span><span><span>                                    )
</span></span><span><span>                                    (<span>=</span>
</span></span><span><span>                                        (<span>Var</span> <span>4</span> x)
</span></span><span><span>                                        (<span>Var</span> <span>4</span> _lpython_return_variable_compute_x)
</span></span><span><span>                                        ()
</span></span><span><span>                                    )
</span></span><span><span>                                    (<span>Print</span>
</span></span><span><span>                                        ()
</span></span><span><span>                                        [(<span>Var</span> <span>4</span> x)]
</span></span><span><span>                                        ()
</span></span><span><span>                                        ()
</span></span><span><span>                                    )]
</span></span><span><span>                                    ()
</span></span><span><span>                                    Public
</span></span><span><span>                                    .false.
</span></span><span><span>                                    .false.
</span></span><span><span>                                    ()
</span></span><span><span>                                )
</span></span><span><span>                        })
</span></span><span><span>                    __main__
</span></span><span><span>                    []
</span></span><span><span>                    .false.
</span></span><span><span>                    .false.
</span></span><span><span>                ),
</span></span><span><span>            main_program<span>:</span>
</span></span><span><span>                (<span>Program</span>
</span></span><span><span>                    (<span>SymbolTable</span>
</span></span><span><span>                        <span>6</span>
</span></span><span><span>                        {
</span></span><span><span>                            __main____global_statements<span>:</span>
</span></span><span><span>                                (<span>ExternalSymbol</span>
</span></span><span><span>                                    <span>6</span>
</span></span><span><span>                                    __main____global_statements
</span></span><span><span>                                    <span>2</span> __main____global_statements
</span></span><span><span>                                    __main__
</span></span><span><span>                                    []
</span></span><span><span>                                    __main____global_statements
</span></span><span><span>                                    Public
</span></span><span><span>                                )
</span></span><span><span>                        })
</span></span><span><span>                    main_program
</span></span><span><span>                    [__main__]
</span></span><span><span>                    [(<span>SubroutineCall</span>
</span></span><span><span>                        <span>6</span> __main____global_statements
</span></span><span><span>                        <span>2</span> __main____global_statements
</span></span><span><span>                        []
</span></span><span><span>                        ()
</span></span><span><span>                    )]
</span></span><span><span>                )
</span></span><span><span>        })
</span></span><span><span>    []
</span></span><span><span>)
</span></span></code></pre></div><h3 id="ahead-of-time-aot-compilation">Ahead-of-Time (AoT) compilation</h3>
<p>LPython naturally acts as a Python compiler. By default, if no backend is provided it compiles type-annotated user input code to LLVM, which generates binary final output. Consider the following small example:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> lpython <span>import</span> i32, i64
</span></span><span><span>
</span></span><span><span><span>def</span> <span>list_bench</span>(n: i32) <span>-&gt;</span> i64:
</span></span><span><span>    x: list[i32]
</span></span><span><span>    x <span>=</span> []
</span></span><span><span>    i: i32
</span></span><span><span>
</span></span><span><span>    <span>for</span> i <span>in</span> range(n):
</span></span><span><span>        x<span>.</span>append(i)
</span></span><span><span>
</span></span><span><span>    s: i64 <span>=</span> i64(<span>0</span>)
</span></span><span><span>    <span>for</span> i <span>in</span> range(n):
</span></span><span><span>        s <span>+=</span> i64(x[i])
</span></span><span><span>    <span>return</span> s
</span></span><span><span>
</span></span><span><span>res: i64 <span>=</span> list_bench(<span>500_000</span>)
</span></span><span><span>print(res)
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="zsh"><span><span><span>(</span>lp<span>)</span> 18:58:29:~/lpython_project/lpython % lpython /Users/czgdp1807/lpython_project/debug.py -o a.out
</span></span><span><span><span>(</span>lp<span>)</span> 18:58:31:~/lpython_project/lpython % time ./a.out
</span></span><span><span><span>124999750000</span>
</span></span><span><span>./a.out  0.01s user 0.00s system 89% cpu 0.012 total
</span></span></code></pre></div><p>You can see that it’s very fast. It’s still plenty fast with the C backend via the command-line argument <code>--backend=c</code>:</p>
<div><pre tabindex="0"><code data-lang="zsh"><span><span>% time lpython /Users/czgdp1807/lpython_project/debug.py --backend<span>=</span>c
</span></span><span><span><span>124999750000</span>
</span></span><span><span>lpython /Users/czgdp1807/lpython_project/debug.py --backend<span>=</span>c  0.12s user 0.02s system 100% cpu 0.144 total
</span></span></code></pre></div><p>Note that time lpython <code>/Users/czgdp1807/lpython_project/debug.py --backend=c</code> includes both the compilation time of LPython and the execution time of the binary. The sum of both is so fast that one can afford to compile on every change to the input files. :D.</p>
<h3 id="just-in-time-compilation">Just-In-Time Compilation</h3>
<p>Just-in-time compilation in LPython requires only decorating Python function with <code>@lpython</code>. The decorator takes an option for specifying the desired backend, as in, <code>@lpython(backend=&#34;c&#34;)</code> or <code>@lpython(backend=&#34;llvm&#34;)</code>. Only C is supported at present; LLVM and others will be added in the near future. The decorator also propagates backend-specific options. For example</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>@lpython</span>(backend<span>=</span><span>&#34;c&#34;</span>,
</span></span><span><span>         backend_optimization_flags<span>=</span>[<span>&#34;-ffast-math&#34;</span>,
</span></span><span><span>                                     <span>&#34;-funroll-loops&#34;</span>,
</span></span><span><span>                                     <span>&#34;-O1&#34;</span>])
</span></span></code></pre></div><p>Note that by default C backend is used without any optimisation flags.</p>
<p>A small example of JIT compilation in LPython (notice the LPython type annotations with the variables),</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> lpython <span>import</span> i32, i64, lpython
</span></span><span><span>
</span></span><span><span><span>@lpython</span>(backend<span>=</span><span>&#34;c&#34;</span>, backend_optimisation_flags<span>=</span>[<span>&#34;-ffast-math&#34;</span>, <span>&#34;-funroll-loops&#34;</span>, <span>&#34;-O1&#34;</span>])
</span></span><span><span><span>def</span> <span>list_bench</span>(n: i32) <span>-&gt;</span> i64:
</span></span><span><span>    x: list[i32]
</span></span><span><span>    x <span>=</span> []
</span></span><span><span>    i: i32
</span></span><span><span>    <span>for</span> i <span>in</span> range(n):
</span></span><span><span>        x<span>.</span>append(i)
</span></span><span><span>    s: i64 <span>=</span> i64(<span>0</span>)
</span></span><span><span>    <span>for</span> i <span>in</span> range(n):
</span></span><span><span>        s <span>+=</span> i64(x[i])
</span></span><span><span>    <span>return</span> s
</span></span><span><span>
</span></span><span><span>res <span>=</span> list_bench(<span>1</span>) <span># compiles `list_bench` to a shared binary in the first call</span>
</span></span><span><span>res <span>=</span> list_bench(<span>500_000</span>) <span># calls the compiled `list_bench`</span>
</span></span><span><span>print(res)
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="zsh"><span><span><span>(</span>lp<span>)</span> 18:46:33:~/lpython_project/lpython % python /Users/czgdp1807/lpython_project/debug.py
</span></span><span><span><span>124999750000</span>
</span></span></code></pre></div><p>We show below in the benchmarks how LPython compares to Numba, which also has JIT compilation.</p>
<h3 id="inter-operability-with-cpython">Inter-operability with CPython</h3>
<p>Access any library implemented using CPython, via the <code>@pythoncall</code> decorator. For example,</p>
<p><strong>email_extractor.py</strong></p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span># get_email is implemented in email_extractor_util.py which is intimated to</span>
</span></span><span><span><span># LPython by specifiying the file as module in `@pythoncall` decorator</span>
</span></span><span><span><span>@pythoncall</span>(module<span>=</span><span>&#34;email_extractor_util&#34;</span>)
</span></span><span><span><span>def</span> <span>get_email</span>(text: str) <span>-&gt;</span> str:
</span></span><span><span>    <span>pass</span>
</span></span><span><span>
</span></span><span><span><span>def</span> <span>test</span>():
</span></span><span><span>    text: str <span>=</span> <span>&#34;Hello, my email id is lpython@lcompilers.org.&#34;</span>
</span></span><span><span>    print(get_email(text))
</span></span><span><span>
</span></span><span><span>test()
</span></span></code></pre></div><p><strong>email_extractor_util.py</strong></p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span># Implement `get_email` using `re` CPython library</span>
</span></span><span><span><span>def</span> <span>get_email</span>(text):
</span></span><span><span>    <span>import</span> re
</span></span><span><span>    <span># Regular expression patterns</span>
</span></span><span><span>    email_pattern <span>=</span> <span>r</span><span>&#34;\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b&#34;</span>
</span></span><span><span>
</span></span><span><span>    <span># Matching email addresses</span>
</span></span><span><span>    email_matches <span>=</span> re<span>.</span>findall(email_pattern, text)
</span></span><span><span>
</span></span><span><span>    <span>return</span> email_matches[<span>0</span>]
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="zsh"><span><span><span>(</span>lp<span>)</span> 18:54:13:~/lpython_project % lpython email_extractor.py --backend<span>=</span>c --enable-cpython
</span></span><span><span>lpython@lcompilers.org
</span></span></code></pre></div><p><em>Note</em>: The <code>@pythoncall</code> and <code>@lpython</code> decorators are presently supported with just the <code>C</code> backend but eventually will work with the LLVM backend and that’s work in progress.</p>
<h2 id="benchmarks-and-demos">Benchmarks and Demos</h2>
<p>In this section, we show how LPython performs compares to competitors on each feature LPython offers. We cover JIT compilation, Interoperability with CPython, and AoT compilation.</p>
<h3 id="just-in-time-jit-compilation">Just-In-Time (JIT) Compilation</h3>
<p>We compare JIT compilation of LPython to Numba on <strong>summation of all the elements of a 1-D array</strong>, <strong>pointwise multiplication of two 1-D arrays</strong>, <strong>insertion sort on lists</strong>, and <strong>quadratic-time implementation of the Dijkstra shortest-path algorithm on a fully connected graph</strong>.</p>
<p><strong>System Information</strong></p>
<table>
<thead>
<tr>
<th>Compiler</th>
<th>Version</th>
</tr>
</thead>
<tbody>
<tr>
<td>Numba</td>
<td>0.57.1</td>
</tr>
<tr>
<td>LPython</td>
<td>0.19.0</td>
</tr>
<tr>
<td>Python</td>
<td>3.10.4</td>
</tr>
</tbody>
</table>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><strong>Summation of all the elements of a 1-D array</strong></p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> numpy <span>import</span> float64, arange, empty
</span></span><span><span><span>from</span> lpython <span>import</span> i32, f64, lpython
</span></span><span><span><span>import</span> timeit
</span></span><span><span><span>from</span> numba <span>import</span> njit
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>@lpython</span>(backend<span>=</span><span>&#34;c&#34;</span>, backend_optimisation_flags<span>=</span>[<span>&#34;-ffast-math&#34;</span>, <span>&#34;-funroll-loops&#34;</span>, <span>&#34;-O3&#34;</span>])
</span></span><span><span><span>def</span> <span>fast_sum</span>(n: i32, x: f64[:], res: f64[:]) <span>-&gt;</span> f64:
</span></span><span><span>    s: f64 <span>=</span> <span>0.0</span>
</span></span><span><span>    res[<span>0</span>] <span>=</span> <span>0.0</span>
</span></span><span><span>    i: i32
</span></span><span><span>    <span>for</span> i <span>in</span> range(n):
</span></span><span><span>        s <span>+=</span> x[i]
</span></span><span><span>    res[<span>0</span>] <span>=</span> s
</span></span><span><span>    <span>return</span> s
</span></span><span><span>
</span></span><span><span><span>@njit</span>(fastmath<span>=</span><span>True</span>)
</span></span><span><span><span>def</span> <span>fast_sum_numba</span>(n, x, res):
</span></span><span><span>    s <span>=</span> <span>0.0</span>
</span></span><span><span>    res[<span>0</span>] <span>=</span> <span>0.0</span>
</span></span><span><span>    <span>for</span> i <span>in</span> range(n):
</span></span><span><span>        s <span>+=</span> x[i]
</span></span><span><span>    res[<span>0</span>] <span>=</span> s
</span></span><span><span>    <span>return</span> s
</span></span><span><span>
</span></span><span><span><span>def</span> <span>test</span>():
</span></span><span><span>    n <span>=</span> <span>100_000_000</span>
</span></span><span><span>    x <span>=</span> arange(n, dtype<span>=</span>float64)
</span></span><span><span>    x1 <span>=</span> arange(<span>0</span>, dtype<span>=</span>float64)
</span></span><span><span>    res <span>=</span> empty(<span>1</span>, dtype<span>=</span>float64)
</span></span><span><span>    res_numba <span>=</span> empty(<span>1</span>, dtype<span>=</span>float64)
</span></span><span><span>
</span></span><span><span>    print(<span>&#34;LPython compilation time:&#34;</span>, timeit<span>.</span>timeit(<span>lambda</span>: fast_sum(<span>0</span>, x1, res), number<span>=</span><span>1</span>))
</span></span><span><span>    print(<span>&#34;LPython execution time: &#34;</span>, min(timeit<span>.</span>repeat(<span>lambda</span>: fast_sum(n, x, res), repeat<span>=</span><span>10</span>, number<span>=</span><span>1</span>)))
</span></span><span><span>    <span>assert</span> res[<span>0</span>] <span>==</span> <span>4999999950000000.0</span>
</span></span><span><span>
</span></span><span><span>    print(<span>&#34;Numba compilation time:&#34;</span>, timeit<span>.</span>timeit(<span>lambda</span>: fast_sum_numba(<span>0</span>, x1, res_numba), number<span>=</span><span>1</span>))
</span></span><span><span>    print(<span>&#34;Numba execution time:&#34;</span>, min(timeit<span>.</span>repeat(<span>lambda</span>: fast_sum_numba(n, x, res_numba), repeat<span>=</span><span>10</span>, number<span>=</span><span>1</span>)))
</span></span><span><span>    <span>assert</span> res_numba[<span>0</span>] <span>==</span> <span>4999999950000000.0</span>
</span></span><span><span>
</span></span><span><span>test()
</span></span></code></pre></div><table>
<thead>
<tr>
<th>Compiler</th>
<th>Compilation Time (s)</th>
<th>System</th>
<th>Relative</th>
</tr>
</thead>
<tbody>
<tr>
<td>Numba</td>
<td>0.10</td>
<td>Apple M1 MBP 2020</td>
<td>1.00</td>
</tr>
<tr>
<td>LPython</td>
<td>0.20</td>
<td>Apple M1 MBP 2020</td>
<td>2.00</td>
</tr>
<tr>
<td>Numba</td>
<td>0.08</td>
<td>Apple M1 Pro MBP 2021</td>
<td>1.00</td>
</tr>
<tr>
<td>LPython</td>
<td>0.53</td>
<td>Apple M1 Pro MBP 2021</td>
<td>6.62</td>
</tr>
<tr>
<td>Numba</td>
<td>0.15</td>
<td>Apple M1 2020</td>
<td>1.00</td>
</tr>
<tr>
<td>LPython</td>
<td>0.40</td>
<td>Apple M1 2020</td>
<td>2.67</td>
</tr>
<tr>
<td>Numba</td>
<td>0.20</td>
<td>AMD Ryzen 5 2500U (Ubuntu 22.04)</td>
<td>1.00</td>
</tr>
<tr>
<td>LPython</td>
<td>0.32</td>
<td>AMD Ryzen 5 2500U (Ubuntu 22.04)</td>
<td>1.60</td>
</tr>
</tbody>
</table>
<!-- raw HTML omitted -->
<table>
<thead>
<tr>
<th>Compiler</th>
<th>Execution Time (s)</th>
<th>System</th>
<th>Relative</th>
</tr>
</thead>
<tbody>
<tr>
<td>LPython</td>
<td>0.013</td>
<td>Apple M1 MBP 2020</td>
<td>1.00</td>
</tr>
<tr>
<td>Numba</td>
<td>0.024</td>
<td>Apple M1 MBP 2020</td>
<td>1.84</td>
</tr>
<tr>
<td>LPython</td>
<td>0.013</td>
<td>Apple M1 Pro MBP 2021</td>
<td>1.00</td>
</tr>
<tr>
<td>Numba</td>
<td>0.023</td>
<td>Apple M1 Pro MBP 2021</td>
<td>1.77</td>
</tr>
<tr>
<td>LPython</td>
<td>0.014</td>
<td>Apple M1 2020</td>
<td>1.00</td>
</tr>
<tr>
<td>Numba</td>
<td>0.024</td>
<td>Apple M1 2020</td>
<td>1.71</td>
</tr>
<tr>
<td>LPython</td>
<td>0.048</td>
<td>AMD Ryzen 5 2500U (Ubuntu 22.04)</td>
<td>1.00</td>
</tr>
<tr>
<td>Numba</td>
<td>0.048</td>
<td>AMD Ryzen 5 2500U (Ubuntu 22.04)</td>
<td>1.00</td>
</tr>
</tbody>
</table>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><strong>Pointwise multiplication of two 1-D arrays</strong></p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> numpy <span>import</span> int64, arange, empty
</span></span><span><span><span>from</span> lpython <span>import</span> i32, i64, lpython
</span></span><span><span><span>import</span> timeit
</span></span><span><span><span>from</span> numba <span>import</span> njit
</span></span><span><span>
</span></span><span><span><span>@lpython</span>(backend<span>=</span><span>&#34;c&#34;</span>, backend_optimisation_flags<span>=</span>[<span>&#34;-ffast-math&#34;</span>, <span>&#34;-funroll-loops&#34;</span>, <span>&#34;-O3&#34;</span>])
</span></span><span><span><span>def</span> <span>multiply_arrays</span>(n: i32, x: i64[:], y: i64[:], z: i64[:]):
</span></span><span><span>    i: i32
</span></span><span><span>    <span>for</span> i <span>in</span> range(n):
</span></span><span><span>        z[i] <span>=</span> x[i] <span>*</span> y[i]
</span></span><span><span>
</span></span><span><span><span>@njit</span>(fastmath<span>=</span><span>True</span>)
</span></span><span><span><span>def</span> <span>multiply_arrays_numba</span>(n, x, y, z):
</span></span><span><span>    <span>for</span> i <span>in</span> range(n):
</span></span><span><span>        z[i] <span>=</span> x[i] <span>*</span> y[i]
</span></span><span><span>
</span></span><span><span><span>def</span> <span>test</span>():
</span></span><span><span>    n <span>=</span> <span>100_000_000</span>
</span></span><span><span>    x1 <span>=</span> arange(<span>0</span>, dtype<span>=</span>int64)
</span></span><span><span>    y1 <span>=</span> arange(<span>0</span>, dtype<span>=</span>int64)
</span></span><span><span>    res1 <span>=</span> arange(<span>0</span>, dtype<span>=</span>int64)
</span></span><span><span>    x <span>=</span> arange(n, dtype<span>=</span>int64)
</span></span><span><span>    y <span>=</span> arange(n, dtype<span>=</span>int64) <span>+</span> <span>2</span>
</span></span><span><span>    res <span>=</span> empty(n, dtype<span>=</span>int64)
</span></span><span><span>    res_numba <span>=</span> empty(n, dtype<span>=</span>int64)
</span></span><span><span>    print(<span>&#34;LPython compilation time:&#34;</span>, timeit<span>.</span>timeit(<span>lambda</span>: multiply_arrays(<span>0</span>, x1, y1, res1), number<span>=</span><span>1</span>))
</span></span><span><span>    print(<span>&#34;LPython execution time:&#34;</span>, min(timeit<span>.</span>repeat(<span>lambda</span>: multiply_arrays(n, x, y, res), repeat<span>=</span><span>10</span>, number<span>=</span><span>1</span>)))
</span></span><span><span>    <span>assert</span> sum(res <span>-</span> x <span>*</span> y) <span>==</span> <span>0</span>
</span></span><span><span>
</span></span><span><span>    print(<span>&#34;Numba compilation time:&#34;</span>, timeit<span>.</span>timeit(<span>lambda</span>: multiply_arrays_numba(<span>0</span>, x1, y1, res1), number<span>=</span><span>1</span>))
</span></span><span><span>    print(<span>&#34;Numba execution time:&#34;</span>, min(timeit<span>.</span>repeat(<span>lambda</span>: multiply_arrays_numba(n, x, y, res_numba), repeat<span>=</span><span>10</span>, number<span>=</span><span>1</span>)))
</span></span><span><span>    <span>assert</span> sum(res_numba <span>-</span> x <span>*</span> y) <span>==</span> <span>0</span>
</span></span><span><span>
</span></span><span><span>
</span></span><span><span>test()
</span></span></code></pre></div><table>
<thead>
<tr>
<th>Compiler</th>
<th>Compilation Time (s)</th>
<th>System</th>
<th>Relative</th>
</tr>
</thead>
<tbody>
<tr>
<td>Numba</td>
<td>0.11</td>
<td>Apple M1 MBP 2020</td>
<td>1.00</td>
</tr>
<tr>
<td>LPython</td>
<td>0.50</td>
<td>Apple M1 MBP 2020</td>
<td>4.54</td>
</tr>
<tr>
<td>Numba</td>
<td>0.09</td>
<td>Apple M1 Pro MBP 2021</td>
<td>1.00</td>
</tr>
<tr>
<td>LPython</td>
<td>0.60</td>
<td>Apple M1 Pro MBP 2021</td>
<td>6.67</td>
</tr>
<tr>
<td>Numba</td>
<td>0.11</td>
<td>Apple M1 2020</td>
<td>1.00</td>
</tr>
<tr>
<td>LPython</td>
<td>0.46</td>
<td>Apple M1 2020</td>
<td>4.18</td>
</tr>
<tr>
<td>Numba</td>
<td>0.21</td>
<td>AMD Ryzen 5 2500U (Ubuntu 22.04)</td>
<td>1.00</td>
</tr>
<tr>
<td>LPython</td>
<td>0.31</td>
<td>AMD Ryzen 5 2500U (Ubuntu 22.04)</td>
<td>1.48</td>
</tr>
</tbody>
</table>
<!-- raw HTML omitted -->
<table>
<thead>
<tr>
<th>Compiler</th>
<th>Execution Time (s)</th>
<th>System</th>
<th>Relative</th>
</tr>
</thead>
<tbody>
<tr>
<td>Numba</td>
<td>0.041</td>
<td>Apple M1 MBP 2020</td>
<td>1.00</td>
</tr>
<tr>
<td>LPython</td>
<td>0.042</td>
<td>Apple M1 MBP 2020</td>
<td>1.02</td>
</tr>
<tr>
<td>Numba</td>
<td>0.037</td>
<td>Apple M1 Pro MBP 2021</td>
<td>1.00</td>
</tr>
<tr>
<td>LPython</td>
<td>0.040</td>
<td>Apple M1 Pro MBP 2021</td>
<td>1.08</td>
</tr>
<tr>
<td>Numba</td>
<td>0.042</td>
<td>Apple M1 2020</td>
<td>1.00</td>
</tr>
<tr>
<td>LPython</td>
<td>0.042</td>
<td>Apple M1 2020</td>
<td>1.00</td>
</tr>
<tr>
<td>Numba</td>
<td>0.21</td>
<td>AMD Ryzen 5 2500U (Ubuntu 22.04)</td>
<td>1.00</td>
</tr>
<tr>
<td>LPython</td>
<td>0.21</td>
<td>AMD Ryzen 5 2500U (Ubuntu 22.04)</td>
<td>1.00</td>
</tr>
</tbody>
</table>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><strong>Insertion sort on lists</strong></p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> lpython <span>import</span> i32, lpython
</span></span><span><span><span>import</span> timeit
</span></span><span><span><span>from</span> numba <span>import</span> njit
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>@lpython</span>(backend<span>=</span><span>&#34;c&#34;</span>, backend_optimisation_flags<span>=</span>[<span>&#34;-ffast-math&#34;</span>, <span>&#34;-funroll-loops&#34;</span>, <span>&#34;-O3&#34;</span>])
</span></span><span><span><span>def</span> <span>test_list_sort</span>(size: i32):
</span></span><span><span>    i: i32
</span></span><span><span>    x: list[i32]
</span></span><span><span>    x <span>=</span> []
</span></span><span><span>    <span>for</span> i <span>in</span> range(size):
</span></span><span><span>        x<span>.</span>append(size <span>-</span> i)
</span></span><span><span>
</span></span><span><span>    <span>for</span> i <span>in</span> range(<span>1</span>, size):
</span></span><span><span>        key: i32 <span>=</span> x[i]
</span></span><span><span>        j: i32 <span>=</span> i <span>-</span> <span>1</span>
</span></span><span><span>        <span>while</span> j <span>&gt;=</span> <span>0</span> <span>and</span> key <span>&lt;</span> x[j] :
</span></span><span><span>            x[j <span>+</span> <span>1</span>] <span>=</span> x[j]
</span></span><span><span>            j <span>-=</span> <span>1</span>
</span></span><span><span>        x[j <span>+</span> <span>1</span>] <span>=</span> key
</span></span><span><span>
</span></span><span><span>    <span>for</span> i <span>in</span> range(<span>1</span>, size):
</span></span><span><span>        <span>assert</span> x[i <span>-</span> <span>1</span>] <span>&lt;</span> x[i]
</span></span><span><span>
</span></span><span><span><span>@njit</span>(fastmath<span>=</span><span>True</span>)
</span></span><span><span><span>def</span> <span>test_list_sort_numba</span>(size):
</span></span><span><span>    x <span>=</span> []
</span></span><span><span>    <span>for</span> i <span>in</span> range(size):
</span></span><span><span>        x<span>.</span>append(size <span>-</span> i)
</span></span><span><span>
</span></span><span><span>    <span>for</span> i <span>in</span> range(<span>1</span>, size):
</span></span><span><span>        key <span>=</span> x[i]
</span></span><span><span>        j <span>=</span> i <span>-</span> <span>1</span>
</span></span><span><span>        <span>while</span> j <span>&gt;=</span> <span>0</span> <span>and</span> key <span>&lt;</span> x[j] :
</span></span><span><span>            x[j <span>+</span> <span>1</span>] <span>=</span> x[j]
</span></span><span><span>            j <span>-=</span> <span>1</span>
</span></span><span><span>        x[j <span>+</span> <span>1</span>] <span>=</span> key
</span></span><span><span>
</span></span><span><span>    <span>for</span> i <span>in</span> range(<span>1</span>, size):
</span></span><span><span>        <span>assert</span> x[i <span>-</span> <span>1</span>] <span>&lt;</span> x[i]
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>def</span> <span>test</span>():
</span></span><span><span>    n <span>=</span> <span>25000</span>
</span></span><span><span>    print(<span>&#34;LPython compilation time:&#34;</span>, timeit<span>.</span>timeit(<span>lambda</span>: test_list_sort(<span>0</span>), number<span>=</span><span>1</span>))
</span></span><span><span>    print(<span>&#34;LPython execution time:&#34;</span>, min(timeit<span>.</span>repeat(<span>lambda</span>: test_list_sort(n), repeat<span>=</span><span>10</span>, number<span>=</span><span>1</span>)))
</span></span><span><span>
</span></span><span><span>    print(<span>&#34;Numba compilation time:&#34;</span>, timeit<span>.</span>timeit(<span>lambda</span>: test_list_sort_numba(<span>0</span>), number<span>=</span><span>1</span>))
</span></span><span><span>    print(<span>&#34;Numba execution time:&#34;</span>, min(timeit<span>.</span>repeat(<span>lambda</span>: test_list_sort_numba(n), repeat<span>=</span><span>10</span>, number<span>=</span><span>1</span>)))
</span></span><span><span>
</span></span><span><span>test()
</span></span></code></pre></div><table>
<thead>
<tr>
<th>Compiler</th>
<th>Compilation Time (s)</th>
<th>System</th>
<th>Relative</th>
</tr>
</thead>
<tbody>
<tr>
<td>Numba</td>
<td>0.13</td>
<td>Apple M1 MBP 2020</td>
<td>1.00</td>
</tr>
<tr>
<td>LPython</td>
<td>0.20</td>
<td>Apple M1 MBP 2020</td>
<td>1.54</td>
</tr>
<tr>
<td>Numba</td>
<td>0.13</td>
<td>Apple M1 Pro MBP 2021</td>
<td>1.00</td>
</tr>
<tr>
<td>LPython</td>
<td>0.60</td>
<td>Apple M1 Pro MBP 2021</td>
<td>4.62</td>
</tr>
<tr>
<td>Numba</td>
<td>0.13</td>
<td>Apple M1 2020</td>
<td>1.00</td>
</tr>
<tr>
<td>LPython</td>
<td>0.42</td>
<td>Apple M1 2020</td>
<td>3.23</td>
</tr>
<tr>
<td>Numba</td>
<td>0.35</td>
<td>AMD Ryzen 5 2500U (Ubuntu 22.04)</td>
<td>1.00</td>
</tr>
<tr>
<td>LPython</td>
<td>0.37</td>
<td>AMD Ryzen 5 2500U (Ubuntu 22.04)</td>
<td>1.06</td>
</tr>
</tbody>
</table>
<!-- raw HTML omitted -->
<table>
<thead>
<tr>
<th>Compiler</th>
<th>Execution Time (s)</th>
<th>System</th>
<th>Relative</th>
</tr>
</thead>
<tbody>
<tr>
<td>LPython</td>
<td>0.11</td>
<td>Apple M1 MBP 2020</td>
<td>1.00</td>
</tr>
<tr>
<td>Numba</td>
<td>0.39</td>
<td>Apple M1 MBP 2020</td>
<td>3.54</td>
</tr>
<tr>
<td>LPython</td>
<td>0.11</td>
<td>Apple M1 Pro MBP 2021</td>
<td>1.00</td>
</tr>
<tr>
<td>Numba</td>
<td>0.39</td>
<td>Apple M1 Pro MBP 2021</td>
<td>3.54</td>
</tr>
<tr>
<td>LPython</td>
<td>0.20</td>
<td>Apple M1 2020</td>
<td>1.00</td>
</tr>
<tr>
<td>Numba</td>
<td>0.39</td>
<td>Apple M1 2020</td>
<td>1.95</td>
</tr>
<tr>
<td>LPython</td>
<td>0.10</td>
<td>AMD Ryzen 5 2500U (Ubuntu 22.04)</td>
<td>1.00</td>
</tr>
<tr>
<td>Numba</td>
<td>0.36</td>
<td>AMD Ryzen 5 2500U (Ubuntu 22.04)</td>
<td>3.60</td>
</tr>
</tbody>
</table>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><strong>Quadratic-time implementation of the Dijkstra shortest-path algorithm on a fully connected graph</strong></p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> lpython <span>import</span> i32, lpython
</span></span><span><span><span>from</span> numpy <span>import</span> empty, int32
</span></span><span><span><span>from</span> numba <span>import</span> njit
</span></span><span><span><span>import</span> timeit
</span></span><span><span>
</span></span><span><span><span>@lpython</span>(backend<span>=</span><span>&#34;c&#34;</span>, backend_optimisation_flags<span>=</span>[<span>&#34;-ffast-math&#34;</span>, <span>&#34;-funroll-loops&#34;</span>, <span>&#34;-O1&#34;</span>])
</span></span><span><span><span>def</span> <span>dijkstra_shortest_path</span>(n: i32, source: i32, dist_sum: i32[:]):
</span></span><span><span>    i: i32; j: i32; v: i32; u: i32; mindist: i32; alt: i32; dummy: i32;
</span></span><span><span>    graph: dict[i32, i32] <span>=</span> {}
</span></span><span><span>    dist: dict[i32, i32] <span>=</span> {}
</span></span><span><span>    prev: dict[i32, i32] <span>=</span> {}
</span></span><span><span>    visited: dict[i32, bool] <span>=</span> {}
</span></span><span><span>    Q: list[i32] <span>=</span> []
</span></span><span><span>
</span></span><span><span>    <span>for</span> i <span>in</span> range(n):
</span></span><span><span>        <span>for</span> j <span>in</span> range(n):
</span></span><span><span>            graph[n <span>*</span> i <span>+</span> j] <span>=</span> abs(i <span>-</span> j)
</span></span><span><span>
</span></span><span><span>    <span>for</span> v <span>in</span> range(n):
</span></span><span><span>        dist[v] <span>=</span> <span>2147483647</span>
</span></span><span><span>        prev[v] <span>=</span> <span>-</span><span>1</span>
</span></span><span><span>        Q<span>.</span>append(v)
</span></span><span><span>        visited[v] <span>=</span> <span>False</span>
</span></span><span><span>    dist[source] <span>=</span> <span>0</span>
</span></span><span><span>
</span></span><span><span>    <span>while</span> len(Q) <span>&gt;</span> <span>0</span>:
</span></span><span><span>        u <span>=</span> <span>-</span><span>1</span>
</span></span><span><span>        mindist <span>=</span> <span>2147483647</span>
</span></span><span><span>        <span>for</span> i <span>in</span> range(len(Q)):
</span></span><span><span>            <span>if</span> mindist <span>&gt;</span> dist[Q[i]]:
</span></span><span><span>                mindist <span>=</span> dist[Q[i]]
</span></span><span><span>                u <span>=</span> Q[i]
</span></span><span><span>        Q<span>.</span>remove(u)
</span></span><span><span>        visited[u] <span>=</span> <span>True</span>
</span></span><span><span>
</span></span><span><span>        <span>for</span> v <span>in</span> range(n):
</span></span><span><span>            <span>if</span> v <span>!=</span> u <span>and</span> <span>not</span> visited[v]:
</span></span><span><span>                alt <span>=</span> dist[u] <span>+</span> graph[n <span>*</span> u <span>+</span> v]
</span></span><span><span>
</span></span><span><span>                <span>if</span> alt <span>&lt;</span> dist[v]:
</span></span><span><span>                    dist[v] <span>=</span> alt
</span></span><span><span>                    prev[v] <span>=</span> u
</span></span><span><span>
</span></span><span><span>    dist_sum[<span>0</span>] <span>=</span> <span>0</span>
</span></span><span><span>    <span>for</span> i <span>in</span> range(n):
</span></span><span><span>        dist_sum[<span>0</span>] <span>+=</span> dist[i]
</span></span><span><span>
</span></span><span><span><span>@njit</span>(fastmath<span>=</span><span>True</span>)
</span></span><span><span><span>def</span> <span>dijkstra_shortest_path_numba</span>(n, source, dist_sum):
</span></span><span><span>    graph <span>=</span> {}
</span></span><span><span>    dist <span>=</span> {}
</span></span><span><span>    prev <span>=</span> {}
</span></span><span><span>    visited <span>=</span> {}
</span></span><span><span>    Q <span>=</span> []
</span></span><span><span>
</span></span><span><span>    <span>for</span> i <span>in</span> range(n):
</span></span><span><span>        <span>for</span> j <span>in</span> range(n):
</span></span><span><span>            graph[n <span>*</span> i <span>+</span> j] <span>=</span> abs(i <span>-</span> j)
</span></span><span><span>
</span></span><span><span>    <span>for</span> v <span>in</span> range(n):
</span></span><span><span>        dist[v] <span>=</span> <span>2147483647</span>
</span></span><span><span>        prev[v] <span>=</span> <span>-</span><span>1</span>
</span></span><span><span>        Q<span>.</span>append(v)
</span></span><span><span>        visited[v] <span>=</span> <span>False</span>
</span></span><span><span>    dist[source] <span>=</span> <span>0</span>
</span></span><span><span>
</span></span><span><span>    <span>while</span> len(Q) <span>&gt;</span> <span>0</span>:
</span></span><span><span>        u <span>=</span> <span>-</span><span>1</span>
</span></span><span><span>        mindist <span>=</span> <span>2147483647</span>
</span></span><span><span>        <span>for</span> i <span>in</span> range(len(Q)):
</span></span><span><span>            <span>if</span> mindist <span>&gt;</span> dist[Q[i]]:
</span></span><span><span>                mindist <span>=</span> dist[Q[i]]
</span></span><span><span>                u <span>=</span> Q[i]
</span></span><span><span>        Q<span>.</span>remove(u)
</span></span><span><span>        visited[u] <span>=</span> <span>True</span>
</span></span><span><span>
</span></span><span><span>        <span>for</span> v <span>in</span> range(n):
</span></span><span><span>            <span>if</span> v <span>!=</span> u <span>and</span> <span>not</span> visited[v]:
</span></span><span><span>                alt <span>=</span> dist[u] <span>+</span> graph[n <span>*</span> u <span>+</span> v]
</span></span><span><span>
</span></span><span><span>                <span>if</span> alt <span>&lt;</span> dist[v]:
</span></span><span><span>                    dist[v] <span>=</span> alt
</span></span><span><span>                    prev[v] <span>=</span> u
</span></span><span><span>
</span></span><span><span>    dist_sum[<span>0</span>] <span>=</span> <span>0</span>
</span></span><span><span>    <span>for</span> i <span>in</span> range(n):
</span></span><span><span>        dist_sum[<span>0</span>] <span>+=</span> dist[i]
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>def</span> <span>test</span>():
</span></span><span><span>    n: i32 <span>=</span> <span>4000</span>
</span></span><span><span>    dist_sum_array_numba <span>=</span> empty(<span>1</span>, dtype<span>=</span>int32)
</span></span><span><span>    dist_sum_array <span>=</span> empty(<span>1</span>, dtype<span>=</span>int32)
</span></span><span><span>    print(<span>&#34;LPython compilation time: &#34;</span>, timeit<span>.</span>timeit(<span>lambda</span>: dijkstra_shortest_path(<span>0</span>, <span>0</span>, dist_sum_array), number<span>=</span><span>1</span>))
</span></span><span><span>    print(<span>&#34;LPython execution time: &#34;</span>, min(timeit<span>.</span>repeat(<span>lambda</span>: dijkstra_shortest_path(n, <span>0</span>, dist_sum_array), repeat<span>=</span><span>5</span>, number<span>=</span><span>1</span>)))
</span></span><span><span>    print(dist_sum_array[<span>0</span>])
</span></span><span><span>    <span>assert</span> dist_sum_array[<span>0</span>] <span>==</span> i32(n <span>*</span> (n <span>-</span> <span>1</span>)<span>/</span><span>2</span>)
</span></span><span><span>
</span></span><span><span>    print(<span>&#34;Numba compilation time: &#34;</span>, timeit<span>.</span>timeit(<span>lambda</span>: dijkstra_shortest_path_numba(<span>0</span>, <span>0</span>, dist_sum_array_numba), number<span>=</span><span>1</span>))
</span></span><span><span>    print(<span>&#34;Numba execution time: &#34;</span>, min(timeit<span>.</span>repeat(<span>lambda</span>: dijkstra_shortest_path_numba(n, <span>0</span>, dist_sum_array_numba), repeat<span>=</span><span>5</span>, number<span>=</span><span>1</span>)))
</span></span><span><span>    print(dist_sum_array_numba[<span>0</span>])
</span></span><span><span>    <span>assert</span> dist_sum_array_numba[<span>0</span>] <span>==</span> i32(n <span>*</span> (n <span>-</span> <span>1</span>)<span>/</span><span>2</span>)
</span></span><span><span>
</span></span><span><span>test()
</span></span></code></pre></div><table>
<thead>
<tr>
<th>Compiler</th>
<th>Compilation Time (s)</th>
<th>System</th>
<th>Relative</th>
</tr>
</thead>
<tbody>
<tr>
<td>LPython</td>
<td>0.35</td>
<td>Apple M1 MBP 2020</td>
<td>1.00</td>
</tr>
<tr>
<td>Numba</td>
<td>0.81</td>
<td>Apple M1 MBP 2020</td>
<td>2.31</td>
</tr>
<tr>
<td>LPython</td>
<td>0.69</td>
<td>Apple M1 Pro MBP 2021</td>
<td>1.00</td>
</tr>
<tr>
<td>Numba</td>
<td>0.73</td>
<td>Apple M1 Pro MBP 2021</td>
<td>1.05</td>
</tr>
<tr>
<td>LPython</td>
<td>0.21</td>
<td>Apple M1 2020</td>
<td>1.00</td>
</tr>
<tr>
<td>Numba</td>
<td>0.73</td>
<td>Apple M1 2020</td>
<td>3.47</td>
</tr>
<tr>
<td>LPython</td>
<td>1.08</td>
<td>AMD Ryzen 5 2500U (Ubuntu 22.04)</td>
<td>1.00</td>
</tr>
<tr>
<td>Numba</td>
<td>1.69</td>
<td>AMD Ryzen 5 2500U (Ubuntu 22.04)</td>
<td>1.56</td>
</tr>
</tbody>
</table>
<!-- raw HTML omitted -->
<table>
<thead>
<tr>
<th>Compiler</th>
<th>Execution Time (s)</th>
<th>System</th>
<th>Relative</th>
</tr>
</thead>
<tbody>
<tr>
<td>LPython</td>
<td>0.23</td>
<td>Apple M1 MBP 2020</td>
<td>1.00</td>
</tr>
<tr>
<td>Numba</td>
<td>1.01</td>
<td>Apple M1 MBP 2020</td>
<td>4.39</td>
</tr>
<tr>
<td>LPython</td>
<td>0.20</td>
<td>Apple M1 Pro MBP 2021</td>
<td>1.00</td>
</tr>
<tr>
<td>Numba</td>
<td>0.98</td>
<td>Apple M1 Pro MBP 2021</td>
<td>4.90</td>
</tr>
<tr>
<td>LPython</td>
<td>0.27</td>
<td>Apple M1 2020</td>
<td>1.00</td>
</tr>
<tr>
<td>Numba</td>
<td>0.98</td>
<td>Apple M1 2020</td>
<td>3.63</td>
</tr>
<tr>
<td>LPython</td>
<td>0.87</td>
<td>AMD Ryzen 5 2500U (Ubuntu 22.04)</td>
<td>1.00</td>
</tr>
<tr>
<td>Numba</td>
<td>1.95</td>
<td>AMD Ryzen 5 2500U (Ubuntu 22.04)</td>
<td>2.24</td>
</tr>
</tbody>
</table>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="ahead-of-time-aot-compilation-1">Ahead-of-Time (AoT) Compilation</h3>
<p>Next, we see how LPython compares to other AoT compilers and to the standard CPython interpreter. The tasks considered are <strong>quadratic-time implementation of the Dijkstra shortest-path algorithm on a fully connected graph</strong>, and <strong>Floyd-Warshall algorithm on array representation of graphs</strong>.</p>
<p><strong>System Information</strong></p>
<table>
<thead>
<tr>
<th>Compiler</th>
<th>Version</th>
</tr>
</thead>
<tbody>
<tr>
<td>clang++</td>
<td>14.0.3</td>
</tr>
<tr>
<td>g++</td>
<td>11.3.0</td>
</tr>
<tr>
<td>LPython</td>
<td>0.19.0</td>
</tr>
<tr>
<td>Python</td>
<td>3.10.4</td>
</tr>
</tbody>
</table>
<!-- raw HTML omitted -->
<p><strong>Quadratic-time implementation of the Dijkstra shortest-path algorithm on a fully connected graph</strong></p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> lpython <span>import</span> i32
</span></span><span><span>
</span></span><span><span><span>def</span> <span>dijkstra_shortest_path</span>(n: i32, source: i32) <span>-&gt;</span> i32:
</span></span><span><span>    i: i32; j: i32; v: i32; u: i32; mindist: i32; alt: i32; dummy: i32; uidx: i32
</span></span><span><span>    dist_sum: i32;
</span></span><span><span>    graph: dict[i32, i32] <span>=</span> {}
</span></span><span><span>    dist: dict[i32, i32] <span>=</span> {}
</span></span><span><span>    prev: dict[i32, i32] <span>=</span> {}
</span></span><span><span>    visited: dict[i32, bool] <span>=</span> {}
</span></span><span><span>    Q: list[i32] <span>=</span> []
</span></span><span><span>
</span></span><span><span>    <span>for</span> i <span>in</span> range(n):
</span></span><span><span>        <span>for</span> j <span>in</span> range(n):
</span></span><span><span>            graph[n <span>*</span> i <span>+</span> j] <span>=</span> abs(i <span>-</span> j)
</span></span><span><span>
</span></span><span><span>    <span>for</span> v <span>in</span> range(n):
</span></span><span><span>        dist[v] <span>=</span> <span>2147483647</span>
</span></span><span><span>        prev[v] <span>=</span> <span>-</span><span>1</span>
</span></span><span><span>        Q<span>.</span>append(v)
</span></span><span><span>        visited[v] <span>=</span> <span>False</span>
</span></span><span><span>    dist[source] <span>=</span> <span>0</span>
</span></span><span><span>
</span></span><span><span>    <span>while</span> len(Q) <span>&gt;</span> <span>0</span>:
</span></span><span><span>        u <span>=</span> <span>-</span><span>1</span>
</span></span><span><span>        mindist <span>=</span> <span>2147483647</span>
</span></span><span><span>        <span>for</span> i <span>in</span> range(len(Q)):
</span></span><span><span>            <span>if</span> mindist <span>&gt;</span> dist[Q[i]]:
</span></span><span><span>                mindist <span>=</span> dist[Q[i]]
</span></span><span><span>                u <span>=</span> Q[i]
</span></span><span><span>                uidx <span>=</span> i
</span></span><span><span>        dummy <span>=</span> Q<span>.</span>pop(uidx)
</span></span><span><span>        visited[u] <span>=</span> <span>True</span>
</span></span><span><span>
</span></span><span><span>        <span>for</span> v <span>in</span> range(n):
</span></span><span><span>            <span>if</span> v <span>!=</span> u <span>and</span> <span>not</span> visited[v]:
</span></span><span><span>                alt <span>=</span> dist[u] <span>+</span> graph[n <span>*</span> u <span>+</span> v]
</span></span><span><span>
</span></span><span><span>                <span>if</span> alt <span>&lt;</span> dist[v]:
</span></span><span><span>                    dist[v] <span>=</span> alt
</span></span><span><span>                    prev[v] <span>=</span> u
</span></span><span><span>
</span></span><span><span>    dist_sum <span>=</span> <span>0</span>
</span></span><span><span>    <span>for</span> i <span>in</span> range(n):
</span></span><span><span>        dist_sum <span>+=</span> dist[i]
</span></span><span><span>    <span>return</span> dist_sum
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>def</span> <span>test</span>():
</span></span><span><span>    n: i32 <span>=</span> <span>4000</span>
</span></span><span><span>    print(dijkstra_shortest_path(n, <span>0</span>))
</span></span><span><span>
</span></span><span><span>test()
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="cpp"><span><span><span>#include</span> <span>&lt;iostream&gt;</span><span>
</span></span></span><span><span><span>#include</span> <span>&lt;unordered_map&gt;</span><span>
</span></span></span><span><span><span>#include</span> <span>&lt;vector&gt;</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span><span>int32_t</span> <span>dijkstra_shortest_path</span>(<span>int32_t</span> n, <span>int32_t</span> source) {
</span></span><span><span>    <span>int32_t</span> i, j, v, u, mindist, alt, dummy, uidx;
</span></span><span><span>    std<span>::</span>unordered_map<span>&lt;</span><span>int32_t</span>, <span>int32_t</span><span>&gt;</span> graph, dist, prev;
</span></span><span><span>    std<span>::</span>unordered_map<span>&lt;</span><span>int32_t</span>, <span>bool</span><span>&gt;</span> visited;
</span></span><span><span>    std<span>::</span>vector<span>&lt;</span><span>int32_t</span><span>&gt;</span> Q;
</span></span><span><span>
</span></span><span><span>    <span>for</span>(i <span>=</span> <span>0</span>; i <span>&lt;</span> n; i<span>++</span>) {
</span></span><span><span>        <span>for</span>(j <span>=</span> <span>0</span>; j <span>&lt;</span> n; j<span>++</span>) {
</span></span><span><span>            graph[n <span>*</span> i <span>+</span> j] <span>=</span> std<span>::</span>abs(i <span>-</span> j);
</span></span><span><span>        }
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>for</span>(v <span>=</span> <span>0</span>; v <span>&lt;</span> n; v<span>++</span>) {
</span></span><span><span>        dist[v] <span>=</span> <span>2147483647</span>;
</span></span><span><span>        prev[v] <span>=</span> <span>-</span><span>1</span>;
</span></span><span><span>        Q.push_back(v);
</span></span><span><span>        visited[v] <span>=</span> false;
</span></span><span><span>    }
</span></span><span><span>    dist[source] <span>=</span> <span>0</span>;
</span></span><span><span>
</span></span><span><span>    <span>while</span>(Q.size() <span>&gt;</span> <span>0</span>) {
</span></span><span><span>        u <span>=</span> <span>-</span><span>1</span>;
</span></span><span><span>        mindist <span>=</span> <span>2147483647</span>;
</span></span><span><span>        <span>for</span>(i <span>=</span> <span>0</span>; i <span>&lt;</span> Q.size(); i<span>++</span>) {
</span></span><span><span>            <span>if</span>( mindist <span>&gt;</span> dist[Q[i]] ) {
</span></span><span><span>                mindist <span>=</span> dist[Q[i]];
</span></span><span><span>                u <span>=</span> Q[i];
</span></span><span><span>                uidx <span>=</span> i;
</span></span><span><span>            }
</span></span><span><span>        }
</span></span><span><span>        Q.erase(Q.begin() <span>+</span> uidx);
</span></span><span><span>        visited[u] <span>=</span> true;
</span></span><span><span>
</span></span><span><span>        <span>for</span>(v <span>=</span> <span>0</span>; v <span>&lt;</span> n; v<span>++</span>) {
</span></span><span><span>            <span>if</span>( v <span>!=</span> u and not visited[v] ) {
</span></span><span><span>                alt <span>=</span> dist[u] <span>+</span> graph[n <span>*</span> u <span>+</span> v];
</span></span><span><span>
</span></span><span><span>                <span>if</span>( alt <span>&lt;</span> dist[v] ) {
</span></span><span><span>                    dist[v] <span>=</span> alt;
</span></span><span><span>                    prev[v] <span>=</span> u;
</span></span><span><span>                }
</span></span><span><span>            }
</span></span><span><span>        }
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>int32_t</span> dist_sum <span>=</span> <span>0</span>;
</span></span><span><span>    <span>for</span>(i <span>=</span> <span>0</span>; i <span>&lt;</span> n; i<span>++</span>) {
</span></span><span><span>        dist_sum <span>+=</span> dist[i];
</span></span><span><span>    }
</span></span><span><span>    <span>return</span> dist_sum;
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>int</span> <span>main</span>() {
</span></span><span><span>    <span>int32_t</span> n <span>=</span> <span>4000</span>;
</span></span><span><span>    <span>int32_t</span> dist_sum <span>=</span> dijkstra_shortest_path(n, <span>0</span>);
</span></span><span><span>    std<span>::</span>cout<span>&lt;&lt;</span>dist_sum<span>&lt;&lt;</span>std<span>::</span>endl;
</span></span><span><span>    <span>return</span> <span>0</span>;
</span></span><span><span>}
</span></span></code></pre></div><table>
<thead>
<tr>
<th>Compiler/Interpreter</th>
<th>Execution Time (s)</th>
<th>System</th>
<th>Relative</th>
</tr>
</thead>
<tbody>
<tr>
<td>LPython</td>
<td>0.167</td>
<td>Apple M1 MBP 2020</td>
<td>1.00</td>
</tr>
<tr>
<td>Clang++</td>
<td>0.993</td>
<td>Apple M1 MBP 2020</td>
<td>5.95</td>
</tr>
<tr>
<td>Python</td>
<td>3.817</td>
<td>Apple M1 MBP 2020</td>
<td>22.86</td>
</tr>
<tr>
<td>LPython</td>
<td>0.155</td>
<td>Apple M1 Pro MBP 2021</td>
<td>1.00</td>
</tr>
<tr>
<td>Clang++</td>
<td>0.685</td>
<td>Apple M1 Pro MBP 2021</td>
<td>4.41</td>
</tr>
<tr>
<td>Python</td>
<td>3.437</td>
<td>Apple M1 Pro MBP 2021</td>
<td>22.17</td>
</tr>
<tr>
<td>LPython</td>
<td>0.324</td>
<td>Apple M1 2020</td>
<td>1.00</td>
</tr>
<tr>
<td>Clang++</td>
<td>0.709</td>
<td>Apple M1 2020</td>
<td>2.19</td>
</tr>
<tr>
<td>Python</td>
<td>3.486</td>
<td>Apple M1 2020</td>
<td>10.76</td>
</tr>
<tr>
<td>LPython</td>
<td>0.613</td>
<td>AMD Ryzen 5 2500U (Ubuntu 22.04)</td>
<td>1.00</td>
</tr>
<tr>
<td>g++</td>
<td>1.358</td>
<td>AMD Ryzen 5 2500U (Ubuntu 22.04)</td>
<td>2.21</td>
</tr>
<tr>
<td>Python</td>
<td>7.365</td>
<td>AMD Ryzen 5 2500U (Ubuntu 22.04)</td>
<td>12.01</td>
</tr>
</tbody>
</table>
<!-- raw HTML omitted -->
<p>Note the optimization flags furnished to each compiler.</p>
<table>
<thead>
<tr>
<th>Compiler/Interpreter</th>
<th>Optimization flags used</th>
</tr>
</thead>
<tbody>
<tr>
<td>LPython</td>
<td><code>--fast</code></td>
</tr>
<tr>
<td>Clang++</td>
<td><code>-ffast-math -funroll-loops -O3</code></td>
</tr>
<tr>
<td>g++</td>
<td><code>-ffast-math -funroll-loops -O3</code></td>
</tr>
<tr>
<td>Python</td>
<td>-</td>
</tr>
</tbody>
</table>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><strong>Floyd-Warshall algorithm on array representation of graphs</strong></p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> lpython <span>import</span> i64, i32
</span></span><span><span><span>from</span> numpy <span>import</span> empty, int64
</span></span><span><span>
</span></span><span><span><span>def</span> <span>floyd_warshall</span>(size: i32) <span>-&gt;</span> i64:
</span></span><span><span>    dist: i64[size, size] <span>=</span> empty((size, size), dtype<span>=</span>int64)
</span></span><span><span>    u: i32; v: i32
</span></span><span><span>    i: i32; j: i32; k: i32
</span></span><span><span>    update: i64 <span>=</span> i64(<span>0</span>)
</span></span><span><span>    <span>for</span> u <span>in</span> range(size):
</span></span><span><span>        <span>for</span> v <span>in</span> range(size):
</span></span><span><span>            dist[u, v] <span>=</span> i64(<span>2147483647</span>)
</span></span><span><span>    <span>for</span> u <span>in</span> range(size):
</span></span><span><span>        <span>for</span> v <span>in</span> range(size):
</span></span><span><span>            <span>if</span> u <span>!=</span> v <span>and</span> ((u<span>%</span><span>2</span> <span>==</span> <span>0</span> <span>and</span> v<span>%</span><span>2</span> <span>==</span> <span>1</span>)
</span></span><span><span>                           <span>or</span> (u<span>%</span><span>2</span> <span>==</span> <span>1</span> <span>and</span> v<span>%</span><span>2</span> <span>==</span> <span>0</span>)):
</span></span><span><span>                dist[u, v] <span>=</span> i64(u <span>+</span> v)
</span></span><span><span>    <span>for</span> v <span>in</span> range(size):
</span></span><span><span>        dist[v, v] <span>=</span> i64(<span>0</span>)
</span></span><span><span>
</span></span><span><span>    update <span>=</span> i64(<span>0</span>)
</span></span><span><span>    <span>for</span> k <span>in</span> range(size):
</span></span><span><span>        <span>for</span> i <span>in</span> range(size):
</span></span><span><span>            <span>for</span> j <span>in</span> range(size):
</span></span><span><span>                <span>if</span> dist[i, j] <span>&gt;</span> dist[i, k] <span>+</span> dist[k, j]:
</span></span><span><span>                    update <span>+=</span> dist[i, j] <span>-</span> dist[i, k] <span>-</span> dist[k, j]
</span></span><span><span>                    dist[i, j] <span>=</span> dist[i, k] <span>+</span> dist[k, j]
</span></span><span><span>
</span></span><span><span>    <span>return</span> update
</span></span><span><span>
</span></span><span><span>
</span></span><span><span>
</span></span><span><span>print(floyd_warshall(<span>1000</span>))
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="cpp"><span><span><span>#include</span> <span>&lt;iostream&gt;</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span><span>int64_t</span> <span>floyd_warshall</span>(<span>int32_t</span> size) {
</span></span><span><span>    <span>int64_t</span> dist[size][size];
</span></span><span><span>    <span>int32_t</span> u, v, i, j, k;
</span></span><span><span>    <span>int64_t</span> update;
</span></span><span><span>    <span>for</span>(u <span>=</span> <span>0</span>; u <span>&lt;</span> size; u<span>++</span>) {
</span></span><span><span>        <span>for</span>(v <span>=</span> <span>0</span>; v <span>&lt;</span> size; v<span>++</span>) {
</span></span><span><span>            dist[u][v] <span>=</span> <span>2147483647</span>;
</span></span><span><span>        }
</span></span><span><span>    }
</span></span><span><span>    <span>for</span>(u <span>=</span> <span>0</span>; u <span>&lt;</span> size; u<span>++</span>) {
</span></span><span><span>        <span>for</span>(v <span>=</span> <span>0</span>; v <span>&lt;</span> size; v<span>++</span>) {
</span></span><span><span>            <span>if</span>( u <span>!=</span> v <span>&amp;&amp;</span> ((u<span>%</span><span>2</span> <span>==</span> <span>0</span> and v<span>%</span><span>2</span> <span>==</span> <span>1</span>)
</span></span><span><span>                           <span>||</span> (u<span>%</span><span>2</span> <span>==</span> <span>1</span> and v<span>%</span><span>2</span> <span>==</span> <span>0</span>)) ) {
</span></span><span><span>                dist[u][v] <span>=</span> u <span>+</span> v;
</span></span><span><span>            }
</span></span><span><span>        }
</span></span><span><span>    }
</span></span><span><span>    <span>for</span>(v <span>=</span> <span>0</span>; v <span>&lt;</span> size; v<span>++</span>) {
</span></span><span><span>        dist[v][v] <span>=</span> <span>0</span>;
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    update <span>=</span> <span>0</span>;
</span></span><span><span>    <span>for</span>(k <span>=</span> <span>0</span>; k <span>&lt;</span> size; k<span>++</span>) {
</span></span><span><span>        <span>for</span>(i <span>=</span> <span>0</span>; i <span>&lt;</span> size; i<span>++</span>) {
</span></span><span><span>            <span>for</span>(j <span>=</span> <span>0</span>; j <span>&lt;</span> size; j<span>++</span>) {
</span></span><span><span>                <span>if</span>( dist[i][j] <span>&gt;</span> dist[i][k] <span>+</span> dist[k][j] ) {
</span></span><span><span>                    update <span>+=</span> dist[i][j] <span>-</span> dist[i][k] <span>-</span> dist[k][j];
</span></span><span><span>                    dist[i][j] <span>=</span> dist[i][k] <span>+</span> dist[k][j];
</span></span><span><span>                }
</span></span><span><span>            }
</span></span><span><span>        }
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>return</span> update;
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>int</span> <span>main</span>() {
</span></span><span><span>    std<span>::</span>cout<span>&lt;&lt;</span>(floyd_warshall(<span>1000</span>))<span>&lt;&lt;</span>std<span>::</span>endl;
</span></span><span><span>    <span>return</span> <span>0</span>;
</span></span><span><span>}
</span></span></code></pre></div><table>
<thead>
<tr>
<th>Compiler/Interpreter</th>
<th>Execution Time (s)</th>
<th>System</th>
<th>Relative</th>
</tr>
</thead>
<tbody>
<tr>
<td>Clang++</td>
<td>0.451</td>
<td>Apple M1 MBP 2020</td>
<td>1.00</td>
</tr>
<tr>
<td>LPython</td>
<td>0.767</td>
<td>Apple M1 MBP 2020</td>
<td>1.70</td>
</tr>
<tr>
<td>Python</td>
<td>&gt; 11</td>
<td>Apple M1 MBP 2020</td>
<td>&gt; 24.39</td>
</tr>
<tr>
<td>Clang++</td>
<td>0.435</td>
<td>Apple M1 Pro MBP 2021</td>
<td>1.00</td>
</tr>
<tr>
<td>LPython</td>
<td>0.785</td>
<td>Apple M1 Pro MBP 2021</td>
<td>1.80</td>
</tr>
<tr>
<td>Python</td>
<td>&gt; 11</td>
<td>Apple M1 Pro MBP 2021</td>
<td>&gt; 25.28</td>
</tr>
<tr>
<td>Clang++</td>
<td>0.460</td>
<td>Apple M1 2020</td>
<td>1.00</td>
</tr>
<tr>
<td>LPython</td>
<td>0.995</td>
<td>Apple M1 2020</td>
<td>2.16</td>
</tr>
<tr>
<td>Python</td>
<td>&gt; 11</td>
<td>Apple M1 2020</td>
<td>&gt; 23.91</td>
</tr>
<tr>
<td>g++</td>
<td>0.695</td>
<td>AMD Ryzen 5 2500U (Ubuntu 22.04)</td>
<td>1.00</td>
</tr>
<tr>
<td>LPython</td>
<td>2.933</td>
<td>AMD Ryzen 5 2500U (Ubuntu 22.04)</td>
<td>4.22</td>
</tr>
<tr>
<td>Python</td>
<td>440.588</td>
<td>AMD Ryzen 5 2500U (Ubuntu 22.04)</td>
<td>633.94</td>
</tr>
</tbody>
</table>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>Note the optimization flags furnished to each compiler.</p>
<table>
<thead>
<tr>
<th>Compiler/Interpreter</th>
<th>Optimization flags used</th>
</tr>
</thead>
<tbody>
<tr>
<td>LPython</td>
<td><code>--fast</code></td>
</tr>
<tr>
<td>Clang++</td>
<td><code>-ffast-math -funroll-loops -O3</code></td>
</tr>
<tr>
<td>g++</td>
<td><code>-ffast-math -funroll-loops -O3</code></td>
</tr>
<tr>
<td>Python</td>
<td>-</td>
</tr>
</tbody>
</table>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="interoperability-with-cpython">Interoperability with CPython</h3>
<p>Next we show that LPython can call functions in CPython libraries. This feature permits “break-out” to Numpy, TensorFlow, PyTorch, and even to matplotlib. The break-outs will run at ordinary (slow) Python speeds, but LPython accelerates the mathematical portions to near maximum speed.</p>
<p><strong>Calling NumPy functions via CPython</strong></p>
<p><strong>main.py</strong></p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> lpython <span>import</span> i32, f64, i64, pythoncall, Const, TypeVar
</span></span><span><span><span>from</span> numpy <span>import</span> empty, int32, float64
</span></span><span><span>
</span></span><span><span>n_1 <span>=</span> TypeVar(<span>&#34;n_1&#34;</span>)
</span></span><span><span>n_2 <span>=</span> TypeVar(<span>&#34;n_2&#34;</span>)
</span></span><span><span>n_3 <span>=</span> TypeVar(<span>&#34;n_3&#34;</span>)
</span></span><span><span>
</span></span><span><span><span>@pythoncall</span>(module <span>=</span> <span>&#34;util&#34;</span>)
</span></span><span><span><span>def</span> <span>cpython_add</span>(n_1: i32, a: i32[:], b: i32[:]) <span>-&gt;</span> i32[n_1]:
</span></span><span><span>    <span>pass</span>
</span></span><span><span>
</span></span><span><span><span>@pythoncall</span>(module <span>=</span> <span>&#34;util&#34;</span>)
</span></span><span><span><span>def</span> <span>cpython_multiply</span>(n_1: i32, n_2: i32, a: f64[:], b: f64[:]) <span>-&gt;</span> f64[n_1, n_2]:
</span></span><span><span>    <span>pass</span>
</span></span><span><span>
</span></span><span><span><span>def</span> <span>test_1D</span>():
</span></span><span><span>    n: Const[i32] <span>=</span> <span>500_000</span>
</span></span><span><span>    a: i32[n] <span>=</span> empty(n, dtype <span>=</span> int32)
</span></span><span><span>    b: i32[n] <span>=</span> empty(n, dtype <span>=</span> int32)
</span></span><span><span>    i: i32
</span></span><span><span>    <span>for</span> i <span>in</span> range(n):
</span></span><span><span>        a[i] <span>=</span> <span>2</span> <span>*</span> (i<span>+</span><span>1</span>) <span>*</span> <span>13</span>
</span></span><span><span>        b[i] <span>=</span> a[i] <span>+</span> <span>2</span>
</span></span><span><span>    sum: i32[n]
</span></span><span><span>    sum <span>=</span> cpython_add(<span>500_000</span>, a, b)
</span></span><span><span>    <span>for</span> i <span>in</span> range(n):
</span></span><span><span>        <span>assert</span> sum[i] <span>==</span> a[i] <span>+</span> b[i]
</span></span><span><span>
</span></span><span><span><span>def</span> <span>test_2D</span>():
</span></span><span><span>    n: Const[i32] <span>=</span> <span>1_000</span>
</span></span><span><span>    a: f64[n] <span>=</span> empty([n], dtype <span>=</span> float64)
</span></span><span><span>    b: f64[n] <span>=</span> empty([n], dtype <span>=</span> float64)
</span></span><span><span>    i: i32; j: i32
</span></span><span><span>    <span>for</span> i <span>in</span> range(n):
</span></span><span><span>        a[i] <span>=</span> f64(i <span>+</span> <span>13</span>)
</span></span><span><span>        b[i] <span>=</span> i <span>*</span> <span>2</span> <span>/</span> (i <span>+</span> <span>1</span>)
</span></span><span><span>    product: f64[n, n]
</span></span><span><span>    product <span>=</span> cpython_multiply(<span>1_000</span>, <span>1_000</span>, a, b)
</span></span><span><span>    <span>for</span> i <span>in</span> range(n):
</span></span><span><span>        <span>assert</span> product[i] <span>==</span> a[i] <span>*</span> b[i]
</span></span><span><span>
</span></span><span><span><span>def</span> <span>test</span>():
</span></span><span><span>    test_1D()
</span></span><span><span>    test_2D()
</span></span><span><span>
</span></span><span><span>test()
</span></span></code></pre></div><p><strong>util.py</strong></p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>import</span> numpy <span>as</span> np
</span></span><span><span>
</span></span><span><span><span>def</span> <span>cpython_add</span>(n, a, b):
</span></span><span><span>    <span>return</span> np<span>.</span>add(a, b)
</span></span><span><span>
</span></span><span><span><span>def</span> <span>cpython_multiply</span>(n, m, a, b):
</span></span><span><span>    <span>return</span> np<span>.</span>multiply(a, b)
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="zsh"><span><span><span>(</span>lp<span>)</span> 23:02:55:~/lpython_project % lpython main.py --backend<span>=</span>c --link-numpy
</span></span><span><span><span>(</span>lp<span>)</span> 23:03:10:~/lpython_project % <span># Works successfully without any asserts failing</span>
</span></span></code></pre></div><p><strong>Plotting graphs via Matplotlib</strong></p>
<p><strong>main.py</strong></p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> lpython <span>import</span> f64, i32, pythoncall, Const
</span></span><span><span><span>from</span> numpy <span>import</span> empty, float64
</span></span><span><span>
</span></span><span><span><span>@pythoncall</span>(module <span>=</span> <span>&#34;util&#34;</span>)
</span></span><span><span><span>def</span> <span>plot_graph</span>(x: f64[:], y1: f64[:], y2: f64[:], y3: f64[:]):
</span></span><span><span>    <span>pass</span>
</span></span><span><span>
</span></span><span><span><span>def</span> <span>f</span>(x: f64, i: f64) <span>-&gt;</span> f64:
</span></span><span><span>    <span>return</span> x <span>**</span> <span>.5</span> <span>/</span> i
</span></span><span><span>
</span></span><span><span><span>def</span> <span>test</span>():
</span></span><span><span>    n: Const[i32] <span>=</span> <span>100000</span>
</span></span><span><span>    x: f64[n] <span>=</span> empty(n, dtype<span>=</span>float64)
</span></span><span><span>    y1: f64[n] <span>=</span> empty(n, dtype<span>=</span>float64)
</span></span><span><span>    y2: f64[n] <span>=</span> empty(n, dtype<span>=</span>float64)
</span></span><span><span>    y3: f64[n] <span>=</span> empty(n, dtype<span>=</span>float64)
</span></span><span><span>
</span></span><span><span>    i: i32
</span></span><span><span>    <span>for</span> i <span>in</span> range(<span>1</span>, n):
</span></span><span><span>        x[i] <span>=</span> f64(i)
</span></span><span><span>
</span></span><span><span>    <span>for</span> i <span>in</span> range(<span>1</span>, n):
</span></span><span><span>        y1[i] <span>=</span> f(x[i], <span>1.</span>)
</span></span><span><span>        y2[i] <span>=</span> f(x[i], <span>2.</span>)
</span></span><span><span>        y3[i] <span>=</span> f(x[i], <span>3.</span>)
</span></span><span><span>
</span></span><span><span>    plot_graph(x, y1, y2, y3)
</span></span><span><span>
</span></span><span><span>test()
</span></span></code></pre></div><p><strong>util.py</strong></p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>import</span> matplotlib.pyplot <span>as</span> plt
</span></span><span><span>
</span></span><span><span><span>def</span> <span>plot_graph</span>(x, y1, y2, y3):
</span></span><span><span>    plt<span>.</span>figtext(<span>0.92</span>, <span>0.03</span>, <span>&#39;$x$&#39;</span>)
</span></span><span><span>    plt<span>.</span>figtext(<span>0.1</span>, <span>0.9</span>, <span>&#39;$y$&#39;</span>)
</span></span><span><span>    plt<span>.</span>plot(x, y1, label<span>=</span><span>&#34;y1&#34;</span>)
</span></span><span><span>    plt<span>.</span>plot(x, y2, label<span>=</span><span>&#34;y2&#34;</span>)
</span></span><span><span>    plt<span>.</span>plot(x, y3, label<span>=</span><span>&#34;y3&#34;</span>)
</span></span><span><span>    plt<span>.</span>legend()
</span></span><span><span>    plt<span>.</span>savefig(<span>&#39;graph.png&#39;</span>)
</span></span><span><span>    plt<span>.</span>show()
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="zsh"><span><span><span>(</span>lp<span>)</span> 23:09:08:~/lpython_project % lpython main.py --backend<span>=</span>c --link-numpy
</span></span><span><span><span>(</span>lp<span>)</span> 23:10:44:~/lpython_project % <span># Works see the graph below</span>
</span></span></code></pre></div><p><img src="https://lpython.org/blog/images/graph.png" alt="Output graph"/></p>
<p><strong>Visualization using Matplotlib: Mandelbrot Set</strong></p>
<p><strong>main.py</strong></p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> lpython <span>import</span> i32, f64, pythoncall, TypeVar
</span></span><span><span><span>from</span> numpy <span>import</span> empty, int32
</span></span><span><span>
</span></span><span><span>h <span>=</span> TypeVar(<span>&#34;h&#34;</span>)
</span></span><span><span>w <span>=</span> TypeVar(<span>&#34;w&#34;</span>)
</span></span><span><span>d <span>=</span> TypeVar(<span>&#34;d&#34;</span>)
</span></span><span><span>
</span></span><span><span><span>@pythoncall</span>(module<span>=</span><span>&#34;util&#34;</span>)
</span></span><span><span><span>def</span> <span>show_img_gray</span>(w: i32, h: i32, A: i32[h, w]):
</span></span><span><span>    <span>pass</span>
</span></span><span><span>
</span></span><span><span><span>@pythoncall</span>(module<span>=</span><span>&#34;util&#34;</span>)
</span></span><span><span><span>def</span> <span>show_img_color</span>(w: i32, h: i32, d: i32, A: i32[h, w, d]):
</span></span><span><span>    <span>pass</span>
</span></span><span><span>
</span></span><span><span><span>def</span> <span>main0</span>():
</span></span><span><span>    Nx: i32 <span>=</span> <span>600</span>; Ny: i32 <span>=</span> <span>450</span>; Nz: i32 <span>=</span> <span>4</span>; n_max: i32 <span>=</span> <span>255</span>
</span></span><span><span>
</span></span><span><span>    xcenter: f64 <span>=</span> f64(<span>-</span><span>0.5</span>); ycenter: f64 <span>=</span> f64(<span>0.0</span>)
</span></span><span><span>    width: f64 <span>=</span> f64(<span>4</span>); height: f64 <span>=</span> f64(<span>3</span>)
</span></span><span><span>    dx_di: f64 <span>=</span> width<span>/</span>f64(Nx); dy_dj: f64 <span>=</span> <span>-</span>height<span>/</span>f64(Ny)
</span></span><span><span>    x_offset: f64 <span>=</span> xcenter <span>-</span> f64(Nx<span>+</span><span>1</span>)<span>*</span>dx_di<span>/</span>f64(<span>2.0</span>)
</span></span><span><span>    y_offset: f64 <span>=</span> ycenter <span>-</span> f64(Ny<span>+</span><span>1</span>)<span>*</span>dy_dj<span>/</span>f64(<span>2.0</span>)
</span></span><span><span>
</span></span><span><span>    i: i32; j: i32; n: i32; idx: i32
</span></span><span><span>    x: f64; y: f64; x_0: f64; y_0: f64; x_sqr: f64; y_sqr: f64
</span></span><span><span>
</span></span><span><span>    image: i32[<span>450</span>, <span>600</span>] <span>=</span> empty([Ny, Nx], dtype<span>=</span>int32)
</span></span><span><span>    image_color: i32[<span>450</span>, <span>600</span>, <span>4</span>] <span>=</span> empty([Ny, Nx, Nz], dtype<span>=</span>int32)
</span></span><span><span>    palette: i32[<span>4</span>, <span>3</span>] <span>=</span> empty([<span>4</span>, <span>3</span>], dtype<span>=</span>int32)
</span></span><span><span>
</span></span><span><span>    <span>for</span> j <span>in</span> range(Ny):
</span></span><span><span>        y_0 <span>=</span> y_offset <span>+</span> dy_dj <span>*</span> f64(j <span>+</span> <span>1</span>)
</span></span><span><span>        <span>for</span> i <span>in</span> range(Nx):
</span></span><span><span>            x_0 <span>=</span> x_offset <span>+</span> dx_di <span>*</span> f64(i <span>+</span> <span>1</span>)
</span></span><span><span>            x <span>=</span> <span>0.0</span>; y <span>=</span> <span>0.0</span>; n <span>=</span> <span>0</span>
</span></span><span><span>            <span>while</span>(<span>True</span>):
</span></span><span><span>                x_sqr <span>=</span> x <span>**</span> <span>2.0</span>
</span></span><span><span>                y_sqr <span>=</span> y <span>**</span> <span>2.0</span>
</span></span><span><span>                <span>if</span> (x_sqr <span>+</span> y_sqr <span>&gt;</span> f64(<span>4</span>) <span>or</span> n <span>==</span> n_max):
</span></span><span><span>                    image[j,i] <span>=</span> <span>255</span> <span>-</span> n
</span></span><span><span>                    <span>break</span>
</span></span><span><span>                y <span>=</span> y_0 <span>+</span> f64(<span>2.0</span>) <span>*</span> x <span>*</span> y
</span></span><span><span>                x <span>=</span> x_0 <span>+</span> x_sqr <span>-</span> y_sqr
</span></span><span><span>                n <span>=</span> n <span>+</span> <span>1</span>
</span></span><span><span>
</span></span><span><span>    palette[<span>0</span>,<span>0</span>] <span>=</span>   <span>0</span>; palette[<span>0</span>,<span>1</span>] <span>=</span> <span>135</span>; palette[<span>0</span>,<span>2</span>] <span>=</span>  <span>68</span>
</span></span><span><span>    palette[<span>1</span>,<span>0</span>] <span>=</span>   <span>0</span>; palette[<span>1</span>,<span>1</span>] <span>=</span>  <span>87</span>; palette[<span>1</span>,<span>2</span>] <span>=</span> <span>231</span>
</span></span><span><span>    palette[<span>2</span>,<span>0</span>] <span>=</span> <span>214</span>; palette[<span>2</span>,<span>1</span>] <span>=</span>  <span>45</span>; palette[<span>2</span>,<span>2</span>] <span>=</span>  <span>32</span>
</span></span><span><span>    palette[<span>3</span>,<span>0</span>] <span>=</span> <span>255</span>; palette[<span>3</span>,<span>1</span>] <span>=</span> <span>167</span>; palette[<span>3</span>,<span>2</span>] <span>=</span>   <span>0</span>
</span></span><span><span>
</span></span><span><span>    <span>for</span> j <span>in</span> range(Ny):
</span></span><span><span>        <span>for</span> i <span>in</span> range(Nx):
</span></span><span><span>            idx <span>=</span> image[j,i] <span>-</span> i32(image[j,i]<span>/</span><span>4</span>)<span>*</span><span>4</span>
</span></span><span><span>            image_color[j,i,<span>0</span>] <span>=</span> palette[idx,<span>0</span>] <span># Red</span>
</span></span><span><span>            image_color[j,i,<span>1</span>] <span>=</span> palette[idx,<span>1</span>] <span># Green</span>
</span></span><span><span>            image_color[j,i,<span>2</span>] <span>=</span> palette[idx,<span>2</span>] <span># Blue</span>
</span></span><span><span>            image_color[j,i,<span>3</span>] <span>=</span> <span>255</span>            <span># Alpha</span>
</span></span><span><span>
</span></span><span><span>    show_img_gray(Nx, Ny, image)
</span></span><span><span>    show_img_color(Nx, Ny, Nz, image_color)
</span></span><span><span>    print(<span>&#34;Done.&#34;</span>)
</span></span><span><span>
</span></span><span><span>main0()
</span></span></code></pre></div><p><strong>util.py</strong></p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>def</span> <span>show_img_gray</span>(w, h, A):
</span></span><span><span>    <span>from</span> matplotlib <span>import</span> pyplot <span>as</span> plt
</span></span><span><span>    plt<span>.</span>imshow(A, cmap<span>=</span><span>&#39;gray&#39;</span>)
</span></span><span><span>    plt<span>.</span>show()
</span></span><span><span>    plt<span>.</span>close()
</span></span><span><span>
</span></span><span><span><span>def</span> <span>show_img_color</span>(w, h, d, A):
</span></span><span><span>    <span>from</span> matplotlib <span>import</span> pyplot <span>as</span> plt
</span></span><span><span>    plt<span>.</span>imshow(A)
</span></span><span><span>    plt<span>.</span>show()
</span></span><span><span>    plt<span>.</span>close()
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="zsh"><span><span>$ ls
</span></span><span><span>main.py util.py
</span></span><span><span>$ lpython main.py --backend<span>=</span>c --link-numpy
</span></span><span><span>Done.
</span></span></code></pre></div><p><img src="https://lpython.org/blog/images/gray.png" alt="mandelbrot-set-gray"/></p>
<p><img src="https://lpython.org/blog/images/color.png" alt="mandelbrot-set-color"/></p>
<h2 id="conclusion">Conclusion</h2>
<p>The benchmarks support the claim that LPython is competitive with its competitors in all features it offers. In JIT, the execution times of LPython-compiled functions are at least as short as equivalent Numba functions. The speed of JIT compilation, itself, is slow in some cases because it currently depends on a C compiler to generate optimal binary code. For algorithms with rich data structures like <code>dict</code> (hash maps) and <code>list</code>, LPython shows much faster speed than Numba. In AoT compilation for tasks like the Dijkstra algorithm, LPython beats equivalent C++ code very comfortably. For an array-based implementation of the Floyd-Warshall algorithm, LPython generates code almost as fast as C++ does.</p>
<p>The main takeaway is that LPython/LFortran generate fast code by default. Our benchmarks show that it’s straightforward to write high-speed LPython code. We hope to raise expectations that LPython output will be in general at least as fast as the equivalent C++ code. Users love Python because of its many productivity advantages: great tooling, easy syntax, and rich data structures like lists, dicts, sets, and arrays. Because any LPython program is also an ordinary Python program, all the tools – debuggers and profilers, for instance – just work. Then, LPython delivers run-time speeds, even with rich data structures at least as short as alternatives in most cases.</p>


        
          
        

        

        
      </article>

      
        
      


      

    </div>
  </div>
</div></div>
  </body>
</html>
