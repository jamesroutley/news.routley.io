<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.blog/2022-12-08-experiment-the-hidden-costs-of-waiting-on-slow-build-times/">Original</a>
    <h1>Experiment: The costs of slow build times</h1>
    
    <div id="readability-page-1" class="page"><div>
  <div>
    


<main role="main" id="post-69029">
  
<p>The cost of hardware is one of the most common objections to providing more powerful computing resources to development teams—and that’s regardless of whether you’re talking about physical hardware in racks, managed cloud providers, or a software-as-a-service based (SaaS) compute resource. Paying for compute resources is an easy cost to “feel” as a business, especially if it’s a recurring operating expense for a managed cloud provider or SaaS solution.</p>
<p>When you ask a developer whether they’d prefer more or less powerful hardware, the answer is almost always the same: they want more powerful hardware. That’s because more powerful hardware means less time waiting on builds—and that means more time to build the next feature or fix a bug.</p>
<p>But even if the upfront cost is higher for higher-powered hardware, what’s the actual cost when you consider the impact on developer productivity?</p>
<p>To find out, I set up an experiment using GitHub’s new, <a href="https://docs.github.com/en/actions/using-github-hosted-runners/using-larger-runners">larger hosted runners</a>, which offer powerful cloud-based compute resources, to execute a large build at each compute tier from 2 cores to 64 cores. I wanted to see what the cost of each build time would be, and then compare that with the average hourly cost of a United States-based developer to figure out the actual operational expense for a business.</p>
<p>The results might surprise you.</p>

<h2 id="testing-build-times-vs-cost-by-core-size-on-compute-resources">Testing build times vs. cost by core size on compute resources<a href="#testing-build-times-vs-cost-by-core-size-on-compute-resources" aria-label="Testing build times vs. cost by core size on compute resources"></a></h2>
<p>For my experiment, I used my own personal project where <a href="https://github.com/some-natalie/fedora-acs-override">I compile the Linux kernel</a> (seriously!) for Fedora 35 and Fedora 36. For background, I need a non-standard patch to play video games on my personal desktop without having to deal with dual booting.</p>
<p>Beyond being a fun project, it’s also a perfect case study for this experiment. As a software build, it takes a long time to run—and it’s a great proxy for more intensive software builds developers often navigate at work.</p>
<p>Now comes the fun part: our experiment. Like I said above, I’m going to initiate builds of this project at each compute tier from 2 cores to 64 cores, and then determine how long each build takes and its cost on GitHub’s larger runners. Last but not least: I’ll compare how much time we save during the build cycle and square that with how much more time developers would have to be productive to find the true business cost.</p>
<p>The logic here is that developers could either be waiting the entire time a build runs or end up context-switching to work on something else while a build runs. Both of these impact overall productivity (more on this below).</p>
<p>To simplify my calculations, I took the average runtimes of two builds per compute tier.</p>
<div><p><strong>Pro tip: </strong> You can find my full spreadsheet for these calculations <a href="https://docs.google.com/spreadsheets/d/1ostvpK8jmC13U25bdyekyBV9uS8xydLV14q2ZwaH24k">here</a> if you want to copy it and play with the numbers yourself using other costs, times for builds, developer salaries, etc.</p></div>
<h2 id="how-much-slow-build-times-cost-companies">How much slow build times cost companies<a href="#how-much-slow-build-times-cost-companies" aria-label="How much slow build times cost companies"></a></h2>
<p>In scenario number one of our experiment, we’ll assume that developers may just wait for a build to run and do nothing else during that time frame. That’s not a great outcome, but it happens.</p>
<p>So, what does this cost a business? <a href="https://survey.stackoverflow.co/2022/#salary-united-states">According to StackOverflow’s 2022 Developer Survey</a>, the average annual cost of a developer in the United States is approximately $150,000 per year including fringe benefits, taxes, and so on. That breaks down to around $75 (USD) an hour. In short, if a developer is waiting on a build to run for one hour and doing nothing in that timeframe, the business is still spending $75 on average for that developer’s time—and potentially losing out on time that developer could be focusing on building more code.</p>
<p>Now for the fun part: calculating the runtimes and cost to execute a build using each tier of compute power, plus the cost of a developer’s time spent waiting on the build. (And remember, I ran each of these twice at each tier and then averaged the results together.)</p>
<p>You end up with something like this:</p>
<div><table>
<tbody>
<tr>
<td><strong>Compute power</strong></td>
<td><strong>Fedora 35 build</strong></td>
<td><strong>Fedora 36 build</strong></td>
<td><strong>Average time</strong>
<p><strong>(minutes)</strong></p></td>
<td><strong>Cost/minute for compute</strong></td>
<td><strong>Total cost of 1 build</strong></td>
<td><strong>Developer cost</strong>
<p><strong>(1 dev)</strong></p></td>
<td><strong>Developer cost</strong>
<p><strong>(5 devs)</strong></p></td>
</tr>
<tr>
<td>2 core</td>
<td>5:24:27</td>
<td>4:54:02</td>
<td>310</td>
<td>$0.008</td>
<td>$2.48</td>
<td>$389.98</td>
<td>$1,939.98</td>
</tr>
<tr>
<td>4 core</td>
<td>2:46:33</td>
<td>2:57:47</td>
<td>173</td>
<td>$0.016</td>
<td>$2.77</td>
<td>$219.02</td>
<td>$1,084.02</td>
</tr>
<tr>
<td>8 core</td>
<td>1:32:13</td>
<td>1:30:41</td>
<td>92</td>
<td>$0.032</td>
<td>$2.94</td>
<td>$117.94</td>
<td>$577.94</td>
</tr>
<tr>
<td>16 core</td>
<td>0:54:31</td>
<td>0:54:14</td>
<td>55</td>
<td>$0.064</td>
<td>$3.52</td>
<td>$72.27</td>
<td>$347.27</td>
</tr>
<tr>
<td>32 core</td>
<td>0:36:21</td>
<td>0:32:21</td>
<td>35</td>
<td>$0.128</td>
<td>$4.48</td>
<td>$48.23</td>
<td>$223.23</td>
</tr>
<tr>
<td>64 core</td>
<td>0:29:25</td>
<td>0:24:24</td>
<td>27</td>
<td>$0.256</td>
<td>$6.91</td>
<td>$40.66</td>
<td>$175.66</td>
</tr>
</tbody>
</table></div>
<p>You can immediately see how much faster each build completes on more powerful hardware—and that’s hardly surprising. But it’s striking how much money, on average, a business would be paying their developers in the time it takes for a build to run.</p>
<p>When you plot this out, you end up with a pretty compelling case for spending more money on stronger hardware.</p>
<figure id="attachment_69031"><img decoding="async" src="https://github.blog/wp-content/uploads/2022/12/costofbuilds1.png?w=1024&amp;fit=1024%2C1024" alt="A chart showing the cost of a build on servers of varying CPU power." srcset="https://github.blog/wp-content/uploads/2022/12/costofbuilds1.png?w=1200 1200w, https://github.blog/wp-content/uploads/2022/12/costofbuilds1.png?w=300 300w, https://github.blog/wp-content/uploads/2022/12/costofbuilds1.png?w=768 768w, https://github.blog/wp-content/uploads/2022/12/costofbuilds1.png?w=1024&amp;fit=1024%2C1024 1024w, https://github.blog/wp-content/uploads/2022/12/costofbuilds1.png?w=512 512w, https://github.blog/wp-content/uploads/2022/12/costofbuilds1.png?w=288 288w" sizes="(max-width: 1000px) 100vw, 1000px" loading="lazy" data-recalc-dims="1"/><figcaption>A chart showing the cost of a build on servers of varying CPU power.</figcaption></figure>
<p><strong>The bottom line:</strong> The cost of hardware is much, much less than the total cost for developers, and giving your engineering teams more CPU power means they have more time to develop software instead of waiting on builds to complete. And the bigger the team you have in a given organization, the more upside you have to invest in more capable compute resources.</p>
<h2 id="how-much-context-switching-costs-companies">How much context switching costs companies<a href="#how-much-context-switching-costs-companies" aria-label="How much context switching costs companies"></a></h2>
<p>Now let’s change the scenario in our experiment: Instead of assuming that developers are sitting idly while waiting for a build to finish, let’s consider they instead start working on another task while a build runs.</p>
<p>This is a classic example of context switching, and it comes with a cost, too. Research has found that context switching is both distracting and an impediment to focused and productive work. In fact, Gloria Mark, a professor of informatics at the University of California, Irvine, has found <a href="https://www.ics.uci.edu/~gmark/chi08-mark.pdf">it takes about 23 minutes for someone to get back to their original task</a> after context switching—and that isn’t even specific to development work, which often entails deeply involved work.</p>
<p>Based on my own experience, switching from one focused task to another takes at least an hour so that’s what I used to run the numbers against. Now, let’s break down the data again:</p>
<div><table>
<tbody>
<tr>
<td><strong>Compute power</strong></td>
<td><strong>Minutes</strong></td>
<td><strong>Cost of 1 build</strong></td>
<td><strong>Partial developer cost</strong>
<p><strong>(1 dev)</strong></p></td>
<td><strong>Partial developer cost</strong>
<p><strong>(5 devs)</strong></p></td>
</tr>
<tr>
<td>2 core</td>
<td>310</td>
<td>$2.48</td>
<td>$77.48</td>
<td>$377.48</td>
</tr>
<tr>
<td>4 core</td>
<td>173</td>
<td>$2.77</td>
<td>$77.77</td>
<td>$377.77</td>
</tr>
<tr>
<td>8 core</td>
<td>92</td>
<td>$2.94</td>
<td>$77.94</td>
<td>$377.94</td>
</tr>
<tr>
<td>16 core</td>
<td>55</td>
<td>$3.52</td>
<td>$78.52</td>
<td>$378.52</td>
</tr>
<tr>
<td>32 core</td>
<td>35</td>
<td>$4.48</td>
<td>$79.48</td>
<td>$379.48</td>
</tr>
<tr>
<td>64 core</td>
<td>27</td>
<td>$6.91</td>
<td>$81.91</td>
<td>$381.91</td>
</tr>
</tbody>
</table></div>
<p>Here, the numbers tell a different story—that is, if you’re going to switch tasks anyways, the speed of build runs doesn’t significantly matter. Labor is much, much more expensive than compute resources. And that means spending a few more dollars to speed up the build is inconsequential in the long run.</p>
<p>Of course, this assumes it will take an hour for developers to get back on track after context switching. But according to the research we cited above, some people can get back on track in 23 minutes (and, additional research from Cornell found that <a href="https://assets.qatalog.com/language.work/qatalog-2021-workgeist-report.pdf">it sometimes takes as little as 10 minutes</a>).</p>
<p>To account for this, let’s try shortening the time frames to 30 minutes and 15 minutes:</p>
<div><table>
<tbody>
<tr>
<td><strong>Compute power</strong></td>
<td><strong>Minutes</strong></td>
<td><strong>Cost of 1 build</strong></td>
<td><strong>Partial dev cost</strong>
<p><strong>(1 dev, 30 mins)</strong></p></td>
<td><strong>Partial dev cost</strong>
<p><strong>(5 devs, 30 mins)</strong></p></td>
<td><strong>Partial dev cost</strong>
<p><strong>(1 dev, 15 mins)</strong></p></td>
<td><strong>Partial dev cost</strong>
<p><strong>(5 devs, 15 mins)</strong></p></td>
</tr>
<tr>
<td>2 core</td>
<td>310</td>
<td>$2.48</td>
<td>$39.98</td>
<td>$189.98</td>
<td>$21.23</td>
<td>$96.23</td>
</tr>
<tr>
<td>4 core</td>
<td>173</td>
<td>$2.77</td>
<td>$40.27</td>
<td>$190.27</td>
<td>$21.52</td>
<td>$96.52</td>
</tr>
<tr>
<td>8 core</td>
<td>92</td>
<td>$2.94</td>
<td>$40.44</td>
<td>$190.44</td>
<td>$21.69</td>
<td>$96.69</td>
</tr>
<tr>
<td>16 core</td>
<td>55</td>
<td>$3.52</td>
<td>$41.02</td>
<td>$191.02</td>
<td>$22.27</td>
<td>$97.27</td>
</tr>
<tr>
<td>32 core</td>
<td>35</td>
<td>$4.48</td>
<td>$41.98</td>
<td>$191.98</td>
<td>$23.23</td>
<td>$98.23</td>
</tr>
<tr>
<td>64 core</td>
<td>27</td>
<td>$6.91</td>
<td>$44.41</td>
<td>$194.41</td>
<td>$25.66</td>
<td>$100.66</td>
</tr>
</tbody>
</table></div>
<p>And when you visualize this data on a graph, the cost for a single developer waiting on a build or switching tasks looks like this:</p>
<figure id="attachment_69032"><img decoding="async" loading="lazy" src="https://github.blog/wp-content/uploads/2022/12/costofbuilds2.png?w=1024&amp;fit=1024%2C1024" alt="A chart showing how much it costs for developers to wait for a build to execute." srcset="https://github.blog/wp-content/uploads/2022/12/costofbuilds2.png?w=1476 1476w, https://github.blog/wp-content/uploads/2022/12/costofbuilds2.png?w=300 300w, https://github.blog/wp-content/uploads/2022/12/costofbuilds2.png?w=768 768w, https://github.blog/wp-content/uploads/2022/12/costofbuilds2.png?w=1024&amp;fit=1024%2C1024 1024w" sizes="(max-width: 1000px) 100vw, 1000px" data-recalc-dims="1"/><figcaption>A chart showing how much it costs for developers to wait for a build to execute.</figcaption></figure>
<p>When you assume the average hourly rate of a developer is $75 (USD), the graph above shows that it almost always makes sense to pay more for more compute power so your developers aren’t left waiting or context switching. Even the most expensive compute option—$15 an hour for 64 cores and 256GB of RAM—only accounts for a fifth of the hourly cost of a single developer’s time. As developer salaries increase, the cost of hardware decreases, or the time the job takes to run decreases—and this inverse ratio bolsters the case for buying better equipment.</p>
<p>That’s something to consider.</p>
<h2 id="the-bottom-line">The bottom line<a href="#the-bottom-line" aria-label="The bottom line"></a></h2>
<p>It’s cheaper—and less frustrating for your developers—to pay more for better hardware to keep your team on track.</p>
<p>In this case, spending an extra $4-5 on build compute saves about $40 per build for an individual developer, or a little over $200 per build for a team of five, <em>and</em> the frustration of switching tasks with a productivity cost of about an hour. That’s not nothing. Of course, spending that extra $4-5 at scale can quickly compound—but so can the cost of sunk productivity.</p>
<p>Even though we used GitHub’s larger runners as an example here, these findings are applicable to any type of hardware—whether self-hosted or in the cloud. So remember: The upfront cost for more CPU power pays off over time. And trust us: your developers will thank you.</p>
<div><p>Want to try our new high-performance GitHub-hosted runners? <a href="https://github.com/features/github-hosted-runners/signup">Sign up for the beta today</a>.</p>
</div>

      
  </main>


  </div>
</div></div>
  </body>
</html>
