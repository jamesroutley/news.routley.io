<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://cgit.freebsd.org/src/commit/?id=744bfb213144c63cbaf38d91a1c4f7aebb9b9fbc">Original</a>
    <h1>WireGuard has finally landed in FreeBSD</h1>
    
    <div id="readability-page-1" class="page"><p>Import the WireGuard driver from zx2c4.com.</p><p>This commit brings back the driver from FreeBSD commit
f187d6dfbf633665ba6740fe22742aec60ce02a2 plus subsequent fixes from
upstream.

Relative to upstream this commit includes a few other small fixes such
as additional INET and INET6 #ifdef&#39;s, #include cleanups, and updates
for recent API changes in main.

Reviewed by:	pauamma, gbe, kevans, emaste
Obtained from:	git@git.zx2c4.com:wireguard-freebsd @ 3cc22b2
Sponsored by:	The FreeBSD Foundation
Differential Revision:	<a href="https://reviews.freebsd.org/D36909">https://reviews.freebsd.org/D36909</a>
</p><div summary="diff"><tbody><tr><td><div><p>diff --git a/etc/mtree/BSD.include.dist b/etc/mtree/BSD.include.dist</p></div><p>@@ -136,6 +136,8 @@</p><p>         ..</p><p>         vkbd</p><p>         ..</p><p>+        wg</p><p>+        ..</p><p>         wi</p><p>         ..</p><p>     ..</p><div><p>diff --git a/include/Makefile b/include/Makefile</p></div><p>@@ -49,7 +49,7 @@ LSUBDIRS=	dev/acpica dev/agp dev/ciss dev/filemon dev/firewire \</p><p> 	dev/hwpmc dev/hyperv \</p><p> 	dev/ic dev/iicbus dev/io dev/mfi dev/mmc dev/nvme \</p><p> 	dev/ofw dev/pbio dev/pci ${_dev_powermac_nvram} dev/ppbus dev/pwm \</p><p>-	dev/smbus dev/speaker dev/tcp_log dev/veriexec dev/vkbd \</p><p>+	dev/smbus dev/speaker dev/tcp_log dev/veriexec dev/vkbd dev/wg \</p><p> 	fs/devfs fs/fdescfs fs/msdosfs fs/nfs fs/nullfs \</p><p> 	fs/procfs fs/smbfs fs/udf fs/unionfs \</p><p> 	geom/cache geom/concat geom/eli geom/gate geom/journal geom/label \</p><p>@@ -225,6 +225,10 @@ NVPAIRDIR=	${INCLUDEDIR}/sys</p><p> MLX5=		mlx5io.h</p><p> MLX5DIR=	${INCLUDEDIR}/dev/mlx5</p><p>+.PATH: ${SRCTOP}/sys/dev/wg</p><p>+WG=		if_wg.h</p><p>+WGDIR=		${INCLUDEDIR}/dev/wg</p><p>+</p><p> INCSGROUPS=	INCS \</p><p> 		ACPICA \</p><p> 		AGP \</p><p>@@ -244,7 +248,8 @@ INCSGROUPS=	INCS \</p><p> 		RPC \</p><p> 		SECAUDIT \</p><p> 		TEKEN \</p><p>-		VERIEXEC</p><p>+		VERIEXEC \</p><p>+		WG</p><p> .if ${MK_IPFILTER} != &#34;no&#34;</p><p> INCSGROUPS+=	IPFILTER</p><div><p>diff --git a/share/man/man4/Makefile b/share/man/man4/Makefile</p></div><p>@@ -584,6 +584,7 @@ MAN=	aac.4 \</p><p> 	vtnet.4 \</p><p> 	watchdog.4 \</p><p> 	${_wbwd.4} \</p><p>+	wg.4 \</p><p> 	witness.4 \</p><p> 	wlan.4 \</p><p> 	wlan_acl.4 \</p><p>@@ -761,6 +762,7 @@ MLINKS+=vr.4 if_vr.4</p><p> MLINKS+=vte.4 if_vte.4</p><p> MLINKS+=vtnet.4 if_vtnet.4</p><p> MLINKS+=watchdog.4 SW_WATCHDOG.4</p><p>+MLINKS+=wg.4 if_wg.4</p><p> MLINKS+=${_wpi.4} ${_if_wpi.4}</p><p> MLINKS+=xl.4 if_xl.4</p><div><p>diff --git a/share/man/man4/wg.4 b/share/man/man4/wg.4</p></div><p>@@ -0,0 +1,213 @@</p><p>+.\&#34; Copyright (c) 2020 Gordon Bergling &lt;gbe@FreeBSD.org&gt;</p><p>+.\&#34;</p><p>+.\&#34; Redistribution and use in source and binary forms, with or without</p><p>+.\&#34; modification, are permitted provided that the following conditions</p><p>+.\&#34; are met:</p><p>+.\&#34; 1. Redistributions of source code must retain the above copyright</p><p>+.\&#34;    notice, this list of conditions and the following disclaimer.</p><p>+.\&#34; 2. Redistributions in binary form must reproduce the above copyright</p><p>+.\&#34;    notice, this list of conditions and the following disclaimer in the</p><p>+.\&#34;    documentation and/or other materials provided with the distribution.</p><p>+.\&#34;</p><p>+.\&#34; THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&#39;&#39; AND</p><p>+.\&#34; ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</p><p>+.\&#34; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</p><p>+.\&#34; ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE</p><p>+.\&#34; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</p><p>+.\&#34; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</p><p>+.\&#34; OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</p><p>+.\&#34; HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</p><p>+.\&#34; LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</p><p>+.\&#34; OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</p><p>+.\&#34; SUCH DAMAGE.</p><p>+.\&#34;</p><p>+.\&#34; $FreeBSD$</p><p>+.\&#34;</p><p>+.Dd October 28, 2022</p><p>+.Dt WG 4</p><p>+.Os</p><p>+.Sh NAME</p><p>+.Nm wg</p><p>+.Nd &#34;WireGuard - pseudo-device&#34;</p><p>+.Sh SYNOPSIS</p><p>+To load the driver as a module at boot time, place the following line in</p><p>+.Xr loader.conf 5 :</p><p>+.Bd -literal -offset indent</p><p>+if_wg_load=&#34;YES&#34;</p><p>+.Ed</p><p>+.Sh DESCRIPTION</p><p>+The</p><p>+.Nm</p><p>+driver provides Virtual Private Network (VPN) interfaces for the secure</p><p>+exchange of layer 3 traffic with other WireGuard peers using the WireGuard</p><p>+protocol.</p><p>+.Pp</p><p>+A</p><p>+.Nm</p><p>+interface recognises one or more peers, establishes a secure tunnel with</p><p>+each on demand, and tracks each peer&#39;s UDP endpoint for exchanging encrypted</p><p>+traffic with.</p><p>+.Pp</p><p>+The interfaces can be created at runtime using the</p><p>+.Ic ifconfig Cm wg Ns Ar N Cm create</p><p>+command.</p><p>+The interface itself can be configured with</p><p>+.Xr wg 8 .</p><p>+.Pp</p><p>+The following glossary provides a brief overview of WireGuard</p><p>+terminology:</p><p>+.Bl -tag -width indent -offset 3n</p><p>+.It Peer</p><p>+Peers exchange IPv4 or IPv6 traffic over secure tunnels.</p><p>+Each</p><p>+.Nm</p><p>+interface may be configured to recognise one or more peers.</p><p>+.It Key</p><p>+Each peer uses its private key and corresponding public key to</p><p>+identify itself to others.</p><p>+A peer configures a</p><p>+.Nm</p><p>+interface with its own private key and with the public keys of its peers.</p><p>+.It Pre-shared key</p><p>+In addition to the public keys, each peer pair may be configured with a</p><p>+unique pre-shared symmetric key.</p><p>+This is used in their handshake to guard against future compromise of the</p><p>+peers&#39; encrypted tunnel if a quantum-computational attack on their</p><p>+Diffie-Hellman exchange becomes feasible.</p><p>+It is optional, but recommended.</p><p>+.It Allowed IPs</p><p>+A single</p><p>+.Nm</p><p>+interface may maintain concurrent tunnels connecting diverse networks.</p><p>+The interface therefore implements rudimentary routing and reverse-path</p><p>+filtering functions for its tunneled traffic.</p><p>+These functions reference a set of allowed IP ranges configured against</p><p>+each peer.</p><p>+.Pp</p><p>+The interface will route outbound tunneled traffic to the peer configured</p><p>+with the most specific matching allowed IP address range, or drop it</p><p>+if no such match exists.</p><p>+.Pp</p><p>+The interface will accept tunneled traffic only from the peer</p><p>+configured with the most specific matching allowed IP address range</p><p>+for the incoming traffic, or drop it if no such match exists.</p><p>+That is, tunneled traffic routed to a given peer cannot return through</p><p>+another peer of the same</p><p>+.Nm</p><p>+interface.</p><p>+This ensures that peers cannot spoof another&#39;s traffic.</p><p>+.It Handshake</p><p>+Two peers handshake to mutually authenticate each other and to</p><p>+establish a shared series of secret ephemeral encryption keys.</p><p>+Any peer may initiate a handshake.</p><p>+Handshakes occur only when there is traffic to send, and recur every</p><p>+two minutes during transfers.</p><p>+.It Connectionless</p><p>+Due to the handshake behavior, there is no connected or disconnected</p><p>+state.</p><p>+.El</p><p>+.Ss Keys</p><p>+Private keys for WireGuard can be generated from any sufficiently</p><p>+secure random source.</p><p>+The Curve25519 keys and the pre-shared keys are both 32 bytes</p><p>+long and are commonly encoded in base64 for ease of use.</p><p>+.Pp</p><p>+Keys can be generated with</p><p>+.Xr wg 8</p><p>+as follows:</p><p>+.Pp</p><p>+.Dl $ wg genkey</p><p>+.Pp</p><p>+Although a valid Curve25519 key must have 5 bits set to</p><p>+specific values, this is done by the interface and so it</p><p>+will accept any random 32-byte base64 string.</p><p>+.Sh EXAMPLES</p><p>+Create a</p><p>+.Nm</p><p>+interface and set random private key.</p><p>+.Bd -literal -offset indent</p><p>+# ifconfig wg0 create</p><p>+# wg genkey | wg set wg0 listen-port 54321 private-key /dev/stdin</p><p>+.Ed</p><p>+.Pp</p><p>+Retrieve the associated public key from a</p><p>+.Nm</p><p>+interface.</p><p>+.Bd -literal -offset indent</p><p>+$ wg show wg0 public-key</p><p>+.Ed</p><p>+.Pp</p><p>+Connect to a specific endpoint using its public-key and set the allowed IP address</p><p>+.Bd -literal -offset indent</p><p>+# wg set wg0 peer &#39;7lWtsDdqaGB3EY9WNxRN3hVaHMtu1zXw71+bOjNOVUw=&#39; endpoint 10.0.1.100:54321 allowed-ips 192.168.2.100/32</p><p>+.Ed</p><p>+.Pp</p><p>+Remove a peer</p><p>+.Bd -literal -offset indent</p><p>+# wg set wg0 peer &#39;7lWtsDdqaGB3EY9WNxRN3hVaHMtu1zXw71+bOjNOVUw=&#39; remove</p><p>+.Ed</p><p>+.Sh DIAGNOSTICS</p><p>+The</p><p>+.Nm</p><p>+interface supports runtime debugging, which can be enabled with:</p><p>+.Pp</p><p>+.D1 Ic ifconfig Cm wg Ns Ar N Cm debug</p><p>+.Pp</p><p>+Some common error messages include:</p><p>+.Bl -diag</p><p>+.It &#34;Handshake for peer X did not complete after 5 seconds, retrying&#34;</p><p>+Peer X did not reply to our initiation packet, for example because:</p><p>+.Bl -bullet</p><p>+.It</p><p>+The peer does not have the local interface configured as a peer.</p><p>+Peers must be able to mutually authenticate each other.</p><p>+.It</p><p>+The peer endpoint IP address is incorrectly configured.</p><p>+.It</p><p>+There are firewall rules preventing communication between hosts.</p><p>+.El</p><p>+.It &#34;Invalid handshake initiation&#34;</p><p>+The incoming handshake packet could not be processed.</p><p>+This is likely due to the local interface not containing</p><p>+the correct public key for the peer.</p><p>+.It &#34;Invalid initiation MAC&#34;</p><p>+The incoming handshake initiation packet had an invalid MAC.</p><p>+This is likely because the initiation sender has the wrong public key</p><p>+for the handshake receiver.</p><p>+.It &#34;Packet has unallowed src IP from peer X&#34;</p><p>+After decryption, an incoming data packet has a source IP address that</p><p>+is not assigned to the allowed IPs of Peer X.</p><p>+.El</p><p>+.Sh SEE ALSO</p><p>+.Xr inet 4 ,</p><p>+.Xr ip 4 ,</p><p>+.Xr netintro 4 ,</p><p>+.Xr ipf 5 ,</p><p>+.Xr pf.conf 5 ,</p><p>+.Xr ifconfig 8 ,</p><p>+.Xr ipfw 8 ,</p><p>+.Xr wg 8</p><p>+.Rs</p><p>+.%T WireGuard whitepaper</p><p>+.%U https://www.wireguard.com/papers/wireguard.pdf</p><p>+.Re</p><p>+.Sh HISTORY</p><p>+The</p><p>+.Nm</p><p>+device driver first appeared in</p><p>+.Fx 14.0 .</p><p>+.Sh AUTHORS</p><p>+The</p><p>+.Nm</p><p>+device driver written by</p><p>+.An Jason A. Donenfeld Aq Mt Jason@zx2c4.com ,</p><p>+.An Matt Dunwoodie Aq Mt ncon@nconroy.net ,</p><p>+and</p><p>+.An Kyle Evans Aq Mt kevans@FreeBSD.org .</p><p>+.Pp</p><p>+This manual page was written by</p><p>+.An Gordon Bergling Aq Mt gbe@FreeBSD.org</p><p>+and is based on the</p><p>+.Ox</p><p>+manual page written by</p><p>+.An David Gwynne Aq Mt dlg@openbsd.org .</p><div><p>diff --git a/sys/conf/NOTES b/sys/conf/NOTES</p></div><p>@@ -961,6 +961,9 @@ device		enc</p><p> # Link aggregation interface.</p><p> device		lagg</p><p>+# WireGuard interface.</p><p>+device		wg</p><p>+</p><p> #</p><p> # Internet family options:</p><p> #</p><div><p>diff --git a/sys/conf/files b/sys/conf/files</p></div><p>@@ -750,8 +750,8 @@ crypto/sha2/sha256c.c		optional crypto | ekcd | geom_bde | \</p><p> crypto/sha2/sha512c.c		optional crypto | geom_bde | zfs</p><p> crypto/skein/skein.c		optional crypto | zfs</p><p> crypto/skein/skein_block.c	optional crypto | zfs</p><p>-crypto/siphash/siphash.c	optional inet | inet6</p><p>-crypto/siphash/siphash_test.c	optional inet | inet6</p><p>+crypto/siphash/siphash.c	optional inet | inet6 | wg</p><p>+crypto/siphash/siphash_test.c	optional inet | inet6 | wg</p><p> ddb/db_access.c			optional ddb</p><p> ddb/db_break.c			optional ddb</p><p> ddb/db_capture.c		optional ddb</p><p>@@ -3480,6 +3480,14 @@ dev/vt/vt_font.c		optional vt</p><p> dev/vt/vt_sysmouse.c		optional vt</p><p> dev/vte/if_vte.c		optional vte pci</p><p> dev/watchdog/watchdog.c		standard</p><p>+dev/wg/if_wg.c			optional wg				\</p><p>+	compile-with &#34;${NORMAL_C} -include $S/dev/wg/compat.h&#34;</p><p>+dev/wg/wg_cookie.c		optional wg				\</p><p>+	compile-with &#34;${NORMAL_C} -include $S/dev/wg/compat.h&#34;</p><p>+dev/wg/wg_crypto.c		optional wg				\</p><p>+	compile-with &#34;${NORMAL_C} -include $S/dev/wg/compat.h&#34;</p><p>+dev/wg/wg_noise.c		optional wg				\</p><p>+	compile-with &#34;${NORMAL_C} -include $S/dev/wg/compat.h&#34;</p><p> dev/wpi/if_wpi.c		optional wpi pci</p><p> wpifw.c			optional wpifw					\</p><p> 	compile-with	&#34;${AWK} -f $S/tools/fw_stub.awk wpi.fw:wpifw:153229 -mwpi -c${.TARGET}&#34; \</p><div><p>diff --git a/sys/dev/wg/compat.h b/sys/dev/wg/compat.h</p></div><p>@@ -0,0 +1,118 @@</p><p>+/* SPDX-License-Identifier: MIT</p><p>+ *</p><p>+ * Copyright (C) 2021 Jason A. Donenfeld &lt;Jason@zx2c4.com&gt;. All Rights Reserved.</p><p>+ * Copyright (c) 2022 The FreeBSD Foundation</p><p>+ *</p><p>+ * compat.h contains code that is backported from FreeBSD&#39;s main branch.</p><p>+ * It is different from support.h, which is for code that is not _yet_ upstream.</p><p>+ */</p><p>+</p><p>+#include &lt;sys/param.h&gt;</p><p>+</p><p>+#if (__FreeBSD_version &lt; 1400036 &amp;&amp; __FreeBSD_version &gt;= 1400000) || __FreeBSD_version &lt; 1300519</p><p>+#define COMPAT_NEED_CHACHA20POLY1305_MBUF</p><p>+#endif</p><p>+</p><p>+#if __FreeBSD_version &lt; 1400048</p><p>+#define COMPAT_NEED_CHACHA20POLY1305</p><p>+#endif</p><p>+</p><p>+#if __FreeBSD_version &lt; 1400049</p><p>+#define COMPAT_NEED_CURVE25519</p><p>+#endif</p><p>+</p><p>+#if __FreeBSD_version &lt; 0x7fffffff /* TODO: update this when implemented */</p><p>+#define COMPAT_NEED_BLAKE2S</p><p>+#endif</p><p>+</p><p>+#if __FreeBSD_version &lt; 1400059</p><p>+#include &lt;sys/sockbuf.h&gt;</p><p>+#define sbcreatecontrol(a, b, c, d, e) sbcreatecontrol(a, b, c, d)</p><p>+#endif</p><p>+</p><p>+#if __FreeBSD_version &lt; 1300507</p><p>+#include &lt;sys/smp.h&gt;</p><p>+#include &lt;sys/gtaskqueue.h&gt;</p><p>+</p><p>+struct taskqgroup_cpu {</p><p>+	LIST_HEAD(, grouptask)  tgc_tasks;</p><p>+	struct gtaskqueue       *tgc_taskq;</p><p>+	int     tgc_cnt;</p><p>+	int     tgc_cpu;</p><p>+};</p><p>+</p><p>+struct taskqgroup {</p><p>+	struct taskqgroup_cpu tqg_queue[MAXCPU];</p><p>+	/* Other members trimmed from compat. */</p><p>+};</p><p>+</p><p>+static inline void taskqgroup_drain_all(struct taskqgroup *tqg)</p><p>+{</p><p>+	struct gtaskqueue *q;</p><p>+</p><p>+	for (int i = 0; i &lt; mp_ncpus; i++) {</p><p>+		q = tqg-&gt;tqg_queue[i].tgc_taskq;</p><p>+		if (q == NULL)</p><p>+			continue;</p><p>+		gtaskqueue_drain_all(q);</p><p>+	}</p><p>+}</p><p>+#endif</p><p>+</p><p>+#if __FreeBSD_version &lt; 1300000</p><p>+#define VIMAGE</p><p>+</p><p>+#include &lt;sys/types.h&gt;</p><p>+#include &lt;sys/limits.h&gt;</p><p>+#include &lt;sys/endian.h&gt;</p><p>+#include &lt;sys/socket.h&gt;</p><p>+#include &lt;sys/libkern.h&gt;</p><p>+#include &lt;sys/malloc.h&gt;</p><p>+#include &lt;sys/proc.h&gt;</p><p>+#include &lt;sys/lock.h&gt;</p><p>+#include &lt;sys/socketvar.h&gt;</p><p>+#include &lt;sys/protosw.h&gt;</p><p>+#include &lt;net/vnet.h&gt;</p><p>+#include &lt;net/if.h&gt;</p><p>+#include &lt;net/if_var.h&gt;</p><p>+#include &lt;vm/uma.h&gt;</p><p>+</p><p>+#define taskqgroup_attach(a, b, c, d, e, f) taskqgroup_attach((a), (b), (c), -1, (f))</p><p>+#define taskqgroup_attach_cpu(a, b, c, d, e, f, g) taskqgroup_attach_cpu((a), (b), (c), (d), -1, (g))</p><p>+</p><p>+#undef NET_EPOCH_ENTER</p><p>+#define NET_EPOCH_ENTER(et) NET_EPOCH_ENTER_ET(et)</p><p>+#undef NET_EPOCH_EXIT</p><p>+#define NET_EPOCH_EXIT(et) NET_EPOCH_EXIT_ET(et)</p><p>+#define NET_EPOCH_CALL(f, c) epoch_call(net_epoch_preempt, (c), (f))</p><p>+#define NET_EPOCH_ASSERT() MPASS(in_epoch(net_epoch_preempt))</p><p>+</p><p>+#undef atomic_load_ptr</p><p>+#define atomic_load_ptr(p) (*(volatile __typeof(*p) *)(p))</p><p>+</p><p>+#endif</p><p>+</p><p>+#if __FreeBSD_version &lt; 1202000</p><p>+static inline uint32_t arc4random_uniform(uint32_t bound)</p><p>+{</p><p>+	uint32_t ret, max_mod_bound;</p><p>+</p><p>+	if (bound &lt; 2)</p><p>+		return 0;</p><p>+</p><p>+	max_mod_bound = (1 + ~bound) % bound;</p><p>+</p><p>+	do {</p><p>+		ret = arc4random();</p><p>+	} while (ret &lt; max_mod_bound);</p><p>+</p><p>+	return ret % bound;</p><p>+}</p><p>+</p><p>+typedef void callout_func_t(void *);</p><p>+</p><p>+#ifndef CSUM_SND_TAG</p><p>+#define CSUM_SND_TAG 0x80000000</p><p>+#endif</p><p>+</p><p>+#endif</p><div><p>diff --git a/sys/dev/wg/crypto.h b/sys/dev/wg/crypto.h</p></div><p>@@ -0,0 +1,182 @@</p><p>+/* SPDX-License-Identifier: MIT</p><p>+ *</p><p>+ * Copyright (C) 2015-2021 Jason A. Donenfeld &lt;Jason@zx2c4.com&gt;. All Rights Reserved.</p><p>+ * Copyright (c) 2022 The FreeBSD Foundation</p><p>+ */</p><p>+</p><p>+#ifndef _WG_CRYPTO</p><p>+#define _WG_CRYPTO</p><p>+</p><p>+#include &lt;sys/param.h&gt;</p><p>+</p><p>+struct mbuf;</p><p>+</p><p>+int crypto_init(void);</p><p>+void crypto_deinit(void);</p><p>+</p><p>+enum chacha20poly1305_lengths {</p><p>+	XCHACHA20POLY1305_NONCE_SIZE = 24,</p><p>+	CHACHA20POLY1305_KEY_SIZE = 32,</p><p>+	CHACHA20POLY1305_AUTHTAG_SIZE = 16</p><p>+};</p><p>+</p><p>+#ifdef COMPAT_NEED_CHACHA20POLY1305</p><p>+void</p><p>+chacha20poly1305_encrypt(uint8_t *dst, const uint8_t *src, const size_t src_len,</p><p>+			 const uint8_t *ad, const size_t ad_len,</p><p>+			 const uint64_t nonce,</p><p>+			 const uint8_t key[CHACHA20POLY1305_KEY_SIZE]);</p><p>+</p><p>+bool</p><p>+chacha20poly1305_decrypt(uint8_t *dst, const uint8_t *src, const size_t src_len,</p><p>+			 const uint8_t *ad, const size_t ad_len,</p><p>+			 const uint64_t nonce,</p><p>+			 const uint8_t key[CHACHA20POLY1305_KEY_SIZE]);</p><p>+</p><p>+void</p><p>+xchacha20poly1305_encrypt(uint8_t *dst, const uint8_t *src,</p><p>+			  const size_t src_len, const uint8_t *ad,</p><p>+			  const size_t ad_len,</p><p>+			  const uint8_t nonce[XCHACHA20POLY1305_NONCE_SIZE],</p><p>+			  const uint8_t key[CHACHA20POLY1305_KEY_SIZE]);</p><p>+</p><p>+bool</p><p>+xchacha20poly1305_decrypt(uint8_t *dst, const uint8_t *src,</p><p>+			  const size_t src_len,  const uint8_t *ad,</p><p>+			  const size_t ad_len,</p><p>+			  const uint8_t nonce[XCHACHA20POLY1305_NONCE_SIZE],</p><p>+			  const uint8_t key[CHACHA20POLY1305_KEY_SIZE]);</p><p>+#else</p><p>+#include &lt;sys/endian.h&gt;</p><p>+#include &lt;crypto/chacha20_poly1305.h&gt;</p><p>+</p><p>+static inline void</p><p>+chacha20poly1305_encrypt(uint8_t *dst, const uint8_t *src, const size_t src_len,</p><p>+			 const uint8_t *ad, const size_t ad_len,</p><p>+			 const uint64_t nonce,</p><p>+			 const uint8_t key[CHACHA20POLY1305_KEY_SIZE])</p><p>+{</p><p>+	uint8_t nonce_bytes[8];</p><p>+</p><p>+	le64enc(nonce_bytes, nonce);</p><p>+	chacha20_poly1305_encrypt(dst, src, src_len, ad, ad_len,</p><p>+				  nonce_bytes, sizeof(nonce_bytes), key);</p><p>+}</p><p>+</p><p>+static inline bool</p><p>+chacha20poly1305_decrypt(uint8_t *dst, const uint8_t *src, const size_t src_len,</p><p>+			 const uint8_t *ad, const size_t ad_len,</p><p>+			 const uint64_t nonce,</p><p>+			 const uint8_t key[CHACHA20POLY1305_KEY_SIZE])</p><p>+{</p><p>+	uint8_t nonce_bytes[8];</p><p>+</p><p>+	le64enc(nonce_bytes, nonce);</p><p>+	return (chacha20_poly1305_decrypt(dst, src, src_len, ad, ad_len,</p><p>+					  nonce_bytes, sizeof(nonce_bytes), key));</p><p>+}</p><p>+</p><p>+static inline void</p><p>+xchacha20poly1305_encrypt(uint8_t *dst, const uint8_t *src,</p><p>+			  const size_t src_len, const uint8_t *ad,</p><p>+			  const size_t ad_len,</p><p>+			  const uint8_t nonce[XCHACHA20POLY1305_NONCE_SIZE],</p><p>+			  const uint8_t key[CHACHA20POLY1305_KEY_SIZE])</p><p>+{</p><p>+	xchacha20_poly1305_encrypt(dst, src, src_len, ad, ad_len, nonce, key);</p><p>+}</p><p>+</p><p>+static inline bool</p><p>+xchacha20poly1305_decrypt(uint8_t *dst, const uint8_t *src,</p><p>+			  const size_t src_len,  const uint8_t *ad,</p><p>+			  const size_t ad_len,</p><p>+			  const uint8_t nonce[XCHACHA20POLY1305_NONCE_SIZE],</p><p>+			  const uint8_t key[CHACHA20POLY1305_KEY_SIZE])</p><p>+{</p><p>+	return (xchacha20_poly1305_decrypt(dst, src, src_len, ad, ad_len, nonce, key));</p><p>+}</p><p>+#endif</p><p>+</p><p>+int</p><p>+chacha20poly1305_encrypt_mbuf(struct mbuf *, const uint64_t nonce,</p><p>+			      const uint8_t key[CHACHA20POLY1305_KEY_SIZE]);</p><p>+</p><p>+int</p><p>+chacha20poly1305_decrypt_mbuf(struct mbuf *, const uint64_t nonce,</p><p>+			      const uint8_t key[CHACHA20POLY1305_KEY_SIZE]);</p><p>+</p><p>+</p><p>+enum blake2s_lengths {</p><p>+	BLAKE2S_BLOCK_SIZE = 64,</p><p>+	BLAKE2S_HASH_SIZE = 32,</p><p>+	BLAKE2S_KEY_SIZE = 32</p><p>+};</p><p>+</p><p>+#ifdef COMPAT_NEED_BLAKE2S</p><p>+struct blake2s_state {</p><p>+	uint32_t h[8];</p><p>+	uint32_t t[2];</p><p>+	uint32_t f[2];</p><p>+	uint8_t buf[BLAKE2S_BLOCK_SIZE];</p><p>+	unsigned int buflen;</p><p>+	unsigned int outlen;</p><p>+};</p><p>+</p><p>+void blake2s_init(struct blake2s_state *state, const size_t outlen);</p><p>+</p><p>+void blake2s_init_key(struct blake2s_state *state, const size_t outlen,</p><p>+		      const uint8_t *key, const size_t keylen);</p><p>+</p><p>+void blake2s_update(struct blake2s_state *state, const uint8_t *in, size_t inlen);</p><p>+</p><p>+void blake2s_final(struct blake2s_state *state, uint8_t *out);</p><p>+</p><p>+static inline void blake2s(uint8_t *out, const uint8_t *in, const uint8_t *key,</p><p>+			   const size_t outlen, const size_t inlen, const size_t keylen)</p><p>+{</p><p>+	struct blake2s_state state;</p><p>+</p><p>+	if (keylen)</p><p>+		blake2s_init_key(&amp;state, outlen, key, keylen);</p><p>+	else</p><p>+		blake2s_init(&amp;state, outlen);</p><p>+</p><p>+	blake2s_update(&amp;state, in, inlen);</p><p>+	blake2s_final(&amp;state, out);</p><p>+}</p><p>+#endif</p><p>+</p><p>+#ifdef COMPAT_NEED_CURVE25519</p><p>+enum curve25519_lengths {</p><p>+        CURVE25519_KEY_SIZE = 32</p><p>+};</p><p>+</p><p>+bool curve25519(uint8_t mypublic[static CURVE25519_KEY_SIZE],</p><p>+		const uint8_t secret[static CURVE25519_KEY_SIZE],</p><p>+		const uint8_t basepoint[static CURVE25519_KEY_SIZE]);</p><p>+</p><p>+static inline bool</p><p>+curve25519_generate_public(uint8_t pub[static CURVE25519_KEY_SIZE],</p><p>+			   const uint8_t secret[static CURVE25519_KEY_SIZE])</p><p>+{</p><p>+	static const uint8_t basepoint[CURVE25519_KEY_SIZE] = { 9 };</p><p>+</p><p>+	return curve25519(pub, secret, basepoint);</p><p>+}</p><p>+</p><p>+static inline void curve25519_clamp_secret(uint8_t secret[static CURVE25519_KEY_SIZE])</p><p>+{</p><p>+        secret[0] &amp;= 248;</p><p>+        secret[31] = (secret[31] &amp; 127) | 64;</p><p>+}</p><p>+</p><p>+static inline void curve25519_generate_secret(uint8_t secret[CURVE25519_KEY_SIZE])</p><p>+{</p><p>+	arc4random_buf(secret, CURVE25519_KEY_SIZE);</p><p>+	curve25519_clamp_secret(secret);</p><p>+}</p><p>+#else</p><p>+#include &lt;crypto/curve25519.h&gt;</p><p>+#endif</p><p>+</p><p>+#endif</p><div><p>diff --git a/sys/dev/wg/if_wg.c b/sys/dev/wg/if_wg.c</p></div><p>@@ -0,0 +1,3055 @@</p><p>+/* SPDX-License-Identifier: ISC</p><p>+ *</p><p>+ * Copyright (C) 2015-2021 Jason A. Donenfeld &lt;Jason@zx2c4.com&gt;. All Rights Reserved.</p><p>+ * Copyright (C) 2019-2021 Matt Dunwoodie &lt;ncon@noconroy.net&gt;</p><p>+ * Copyright (c) 2019-2020 Rubicon Communications, LLC (Netgate)</p><p>+ * Copyright (c) 2021 Kyle Evans &lt;kevans@FreeBSD.org&gt;</p><p>+ * Copyright (c) 2022 The FreeBSD Foundation</p><p>+ */</p><p>+</p><p>+#include &#34;opt_inet.h&#34;</p><p>+#include &#34;opt_inet6.h&#34;</p><p>+</p><p>+#include &lt;sys/param.h&gt;</p><p>+#include &lt;sys/systm.h&gt;</p><p>+#include &lt;sys/counter.h&gt;</p><p>+#include &lt;sys/gtaskqueue.h&gt;</p><p>+#include &lt;sys/jail.h&gt;</p><p>+#include &lt;sys/kernel.h&gt;</p><p>+#include &lt;sys/lock.h&gt;</p><p>+#include &lt;sys/mbuf.h&gt;</p><p>+#include &lt;sys/module.h&gt;</p><p>+#include &lt;sys/nv.h&gt;</p><p>+#include &lt;sys/priv.h&gt;</p><p>+#include &lt;sys/protosw.h&gt;</p><p>+#include &lt;sys/rmlock.h&gt;</p><p>+#include &lt;sys/rwlock.h&gt;</p><p>+#include &lt;sys/smp.h&gt;</p><p>+#include &lt;sys/socket.h&gt;</p><p>+#include &lt;sys/socketvar.h&gt;</p><p>+#include &lt;sys/sockio.h&gt;</p><p>+#include &lt;sys/sysctl.h&gt;</p><p>+#include &lt;sys/sx.h&gt;</p><p>+#include &lt;machine/_inttypes.h&gt;</p><p>+#include &lt;net/bpf.h&gt;</p><p>+#include &lt;net/ethernet.h&gt;</p><p>+#include &lt;net/if.h&gt;</p><p>+#include &lt;net/if_clone.h&gt;</p><p>+#include &lt;net/if_types.h&gt;</p><p>+#include &lt;net/if_var.h&gt;</p><p>+#include &lt;net/netisr.h&gt;</p><p>+#include &lt;net/radix.h&gt;</p><p>+#include &lt;netinet/in.h&gt;</p><p>+#include &lt;netinet6/in6_var.h&gt;</p><p>+#include &lt;netinet/ip.h&gt;</p><p>+#include &lt;netinet/ip6.h&gt;</p><p>+#include &lt;netinet/ip_icmp.h&gt;</p><p>+#include &lt;netinet/icmp6.h&gt;</p><p>+#include &lt;netinet/udp_var.h&gt;</p><p>+#include &lt;netinet6/nd6.h&gt;</p><p>+</p><p>+#include &#34;support.h&#34;</p><p>+#include &#34;wg_noise.h&#34;</p><p>+#include &#34;wg_cookie.h&#34;</p><p>+#include &#34;version.h&#34;</p><p>+#include &#34;if_wg.h&#34;</p><p>+</p><p>+#define DEFAULT_MTU		(ETHERMTU - 80)</p><p>+#define MAX_MTU			(IF_MAXMTU - 80)</p><p>+</p><p>+#define MAX_STAGED_PKT		128</p><p>+#define MAX_QUEUED_PKT		1024</p><p>+#define MAX_QUEUED_PKT_MASK	(MAX_QUEUED_PKT - 1)</p><p>+</p><p>+#define MAX_QUEUED_HANDSHAKES	4096</p><p>+</p><p>+#define REKEY_TIMEOUT_JITTER	334 /* 1/3 sec, round for arc4random_uniform */</p><p>+#define MAX_TIMER_HANDSHAKES	(90 / REKEY_TIMEOUT)</p><p>+#define NEW_HANDSHAKE_TIMEOUT	(REKEY_TIMEOUT + KEEPALIVE_TIMEOUT)</p><p>+#define UNDERLOAD_TIMEOUT	1</p><p>+</p><p>+#define DPRINTF(sc, ...) if (sc-&gt;sc_ifp-&gt;if_flags &amp; IFF_DEBUG) if_printf(sc-&gt;sc_ifp, ##__VA_ARGS__)</p><p>+</p><p>+/* First byte indicating packet type on the wire */</p><p>+#define WG_PKT_INITIATION htole32(1)</p><p>+#define WG_PKT_RESPONSE htole32(2)</p><p>+#define WG_PKT_COOKIE htole32(3)</p><p>+#define WG_PKT_DATA htole32(4)</p><p>+</p><p>+#define WG_PKT_PADDING		16</p><p>+#define WG_KEY_SIZE		32</p><p>+</p><p>+struct wg_pkt_initiation {</p><p>+	uint32_t		t;</p><p>+	uint32_t		s_idx;</p><p>+	uint8_t			ue[NOISE_PUBLIC_KEY_LEN];</p><p>+	uint8_t			es[NOISE_PUBLIC_KEY_LEN + NOISE_AUTHTAG_LEN];</p><p>+	uint8_t			ets[NOISE_TIMESTAMP_LEN + NOISE_AUTHTAG_LEN];</p><p>+	struct cookie_macs	m;</p><p>+};</p><p>+</p><p>+struct wg_pkt_response {</p><p>+	uint32_t		t;</p><p>+	uint32_t		s_idx;</p><p>+	uint32_t		r_idx;</p><p>+	uint8_t			ue[NOISE_PUBLIC_KEY_LEN];</p><p>+	uint8_t			en[0 + NOISE_AUTHTAG_LEN];</p><p>+	struct cookie_macs	m;</p><p>+};</p><p>+</p><p>+struct wg_pkt_cookie {</p><p>+	uint32_t		t;</p><p>+	uint32_t		r_idx;</p><p>+	uint8_t			nonce[COOKIE_NONCE_SIZE];</p><p>+	uint8_t			ec[COOKIE_ENCRYPTED_SIZE];</p><p>+};</p><p>+</p><p>+struct wg_pkt_data {</p><p>+	uint32_t		t;</p><p>+	uint32_t		r_idx;</p><p>+	uint64_t		nonce;</p><p>+	uint8_t			buf[];</p><p>+};</p><p>+</p><p>+struct wg_endpoint {</p><p>+	union {</p><p>+		struct sockaddr		r_sa;</p><p>+		struct sockaddr_in	r_sin;</p><p>+#ifdef INET6</p><p>+		struct sockaddr_in6	r_sin6;</p><p>+#endif</p><p>+	} e_remote;</p><p>+	union {</p><p>+		struct in_addr		l_in;</p><p>+#ifdef INET6</p><p>+		struct in6_pktinfo	l_pktinfo6;</p><p>+#define l_in6 l_pktinfo6.ipi6_addr</p><p>+#endif</p><p>+	} e_local;</p><p>+};</p><p>+</p><p>+struct aip_addr {</p><p>+	uint8_t		length;</p><p>+	union {</p><p>+		uint8_t		bytes[16];</p><p>+		uint32_t	ip;</p><p>+		uint32_t	ip6[4];</p><p>+		struct in_addr	in;</p><p>+		struct in6_addr	in6;</p><p>+	};</p><p>+};</p><p>+</p><p>+struct wg_aip {</p><p>+	struct radix_node	 a_nodes[2];</p><p>+	LIST_ENTRY(wg_aip)	 a_entry;</p><p>+	struct aip_addr		 a_addr;</p><p>+	struct aip_addr		 a_mask;</p><p>+	struct wg_peer		*a_peer;</p><p>+	sa_family_t		 a_af;</p><p>+};</p><p>+</p><p>+struct wg_packet {</p><p>+	STAILQ_ENTRY(wg_packet)	 p_serial;</p><p>+	STAILQ_ENTRY(wg_packet)	 p_parallel;</p><p>+	struct wg_endpoint	 p_endpoint;</p><p>+	struct noise_keypair	*p_keypair;</p><p>+	uint64_t		 p_nonce;</p><p>+	struct mbuf		*p_mbuf;</p><p>+	int			 p_mtu;</p><p>+	sa_family_t		 p_af;</p><p>+	enum wg_ring_state {</p><p>+		WG_PACKET_UNCRYPTED,</p><p>+		WG_PACKET_CRYPTED,</p><p>+		WG_PACKET_DEAD,</p><p>+	}			 p_state;</p><p>+};</p><p>+</p><p>+STAILQ_HEAD(wg_packet_list, wg_packet);</p><p>+</p><p>+struct wg_queue {</p><p>+	struct mtx		 q_mtx;</p><p>+	struct wg_packet_list	 q_queue;</p><p>+	size_t			 q_len;</p><p>+};</p><p>+</p><p>+struct wg_peer {</p><p>+	TAILQ_ENTRY(wg_peer)		 p_entry;</p><p>+	uint64_t			 p_id;</p><p>+	struct wg_softc			*p_sc;</p><p>+</p><p>+	struct noise_remote		*p_remote;</p><p>+	struct cookie_maker		 p_cookie;</p><p>+</p><p>+	struct rwlock			 p_endpoint_lock;</p><p>+	struct wg_endpoint		 p_endpoint;</p><p>+</p><p>+	struct wg_queue	 		 p_stage_queue;</p><p>+	struct wg_queue	 		 p_encrypt_serial;</p><p>+	struct wg_queue	 		 p_decrypt_serial;</p><p>+</p><p>+	bool				 p_enabled;</p><p>+	bool				 p_need_another_keepalive;</p><p>+	uint16_t			 p_persistent_keepalive_interval;</p><p>+	struct callout			 p_new_handshake;</p><p>+	struct callout			 p_send_keepalive;</p><p>+	struct callout			 p_retry_handshake;</p><p>+	struct callout			 p_zero_key_material;</p><p>+	struct callout			 p_persistent_keepalive;</p><p>+</p><p>+	struct mtx			 p_handshake_mtx;</p><p>+	struct timespec			 p_handshake_complete;	/* nanotime */</p><p>+	int				 p_handshake_retries;</p><p>+</p><p>+	struct grouptask		 p_send;</p><p>+	struct grouptask		 p_recv;</p><p>+</p><p>+	counter_u64_t			 p_tx_bytes;</p><p>+	counter_u64_t			 p_rx_bytes;</p><p>+</p><p>+	LIST_HEAD(, wg_aip)		 p_aips;</p><p>+	size_t				 p_aips_num;</p><p>+};</p><p>+</p><p>+struct wg_socket {</p><p>+	struct socket	*so_so4;</p><p>+	struct socket	*so_so6;</p><p>+	uint32_t	 so_user_cookie;</p><p>+	int		 so_fibnum;</p><p>+	in_port_t	 so_port;</p><p>+};</p><p>+</p><p>+struct wg_softc {</p><p>+	LIST_ENTRY(wg_softc)	 sc_entry;</p><p>+	struct ifnet		*sc_ifp;</p><p>+	int			 sc_flags;</p><p>+</p><p>+	struct ucred		*sc_ucred;</p><p>+	struct wg_socket	 sc_socket;</p><p>+</p><p>+	TAILQ_HEAD(,wg_peer)	 sc_peers;</p><p>+	size_t			 sc_peers_num;</p><p>+</p><p>+	struct noise_local	*sc_local;</p><p>+	struct cookie_checker	 sc_cookie;</p><p>+</p><p>+	struct radix_node_head	*sc_aip4;</p><p>+	struct radix_node_head	*sc_aip6;</p><p>+</p><p>+	struct grouptask	 sc_handshake;</p><p>+	struct wg_queue		 sc_handshake_queue;</p><p>+</p><p>+	struct grouptask	*sc_encrypt;</p><p>+	struct grouptask	*sc_decrypt;</p><p>+	struct wg_queue		 sc_encrypt_parallel;</p><p>+	struct wg_queue		 sc_decrypt_parallel;</p><p>+	u_int			 sc_encrypt_last_cpu;</p><p>+	u_int			 sc_decrypt_last_cpu;</p><p>+</p><p>+	struct sx		 sc_lock;</p><p>+};</p><p>+</p><p>+#define	WGF_DYING	0x0001</p><p>+</p><p>+#define MAX_LOOPS	8</p><p>+#define MTAG_WGLOOP	0x77676c70 /* wglp */</p><p>+#ifndef ENOKEY</p><p>+#define	ENOKEY	ENOTCAPABLE</p><p>+#endif</p><p>+</p><p>+#define	GROUPTASK_DRAIN(gtask)			\</p><p>+	gtaskqueue_drain((gtask)-&gt;gt_taskqueue, &amp;(gtask)-&gt;gt_task)</p><p>+</p><p>+#define BPF_MTAP2_AF(ifp, m, af) do { \</p><p>+		uint32_t __bpf_tap_af = (af); \</p><p>+		BPF_MTAP2(ifp, &amp;__bpf_tap_af, sizeof(__bpf_tap_af), m); \</p><p>+	} while (0)</p><p>+</p><p>+static int clone_count;</p><p>+static uma_zone_t wg_packet_zone;</p><p>+static volatile unsigned long peer_counter = 0;</p><p>+static const char wgname[] = &#34;wg&#34;;</p><p>+static unsigned wg_osd_jail_slot;</p><p>+</p><p>+static struct sx wg_sx;</p><p>+SX_SYSINIT(wg_sx, &amp;wg_sx, &#34;wg_sx&#34;);</p><p>+</p><p>+static LIST_HEAD(, wg_softc) wg_list = LIST_HEAD_INITIALIZER(wg_list);</p><p>+</p><p>+static TASKQGROUP_DEFINE(wg_tqg, mp_ncpus, 1);</p><p>+</p><p>+MALLOC_DEFINE(M_WG, &#34;WG&#34;, &#34;wireguard&#34;);</p><p>+</p><p>+VNET_DEFINE_STATIC(struct if_clone *, wg_cloner);</p><p>+</p><p>+#define	V_wg_cloner	VNET(wg_cloner)</p><p>+#define	WG_CAPS		IFCAP_LINKSTATE</p><p>+</p><p>+struct wg_timespec64 {</p><p>+	uint64_t	tv_sec;</p><p>+	uint64_t	tv_nsec;</p><p>+};</p><p>+</p><p>+static int wg_socket_init(struct wg_softc *, in_port_t);</p><p>+static int wg_socket_bind(struct socket **, struct socket **, in_port_t *);</p><p>+static void wg_socket_set(struct wg_softc *, struct socket *, struct socket *);</p><p>+static void wg_socket_uninit(struct wg_softc *);</p><p>+static int wg_socket_set_sockopt(struct socket *, struct socket *, int, void *, size_t);</p><p>+static int wg_socket_set_cookie(struct wg_softc *, uint32_t);</p><p>+static int wg_socket_set_fibnum(struct wg_softc *, int);</p><p>+static int wg_send(struct wg_softc *, struct wg_endpoint *, struct mbuf *);</p><p>+static void wg_timers_enable(struct wg_peer *);</p><p>+static void wg_timers_disable(struct wg_peer *);</p><p>+static void wg_timers_set_persistent_keepalive(struct wg_peer *, uint16_t);</p><p>+static void wg_timers_get_last_handshake(struct wg_peer *, struct wg_timespec64 *);</p><p>+static void wg_timers_event_data_sent(struct wg_peer *);</p><p>+static void wg_timers_event_data_received(struct wg_peer *);</p><p>+static void wg_timers_event_any_authenticated_packet_sent(struct wg_peer *);</p><p>+static void wg_timers_event_any_authenticated_packet_received(struct wg_peer *);</p><p>+static void wg_timers_event_any_authenticated_packet_traversal(struct wg_peer *);</p><p>+static void wg_timers_event_handshake_initiated(struct wg_peer *);</p><p>+static void wg_timers_event_handshake_complete(struct wg_peer *);</p><p>+static void wg_timers_event_session_derived(struct wg_peer *);</p><p>+static void wg_timers_event_want_initiation(struct wg_peer *);</p><p>+static void wg_timers_run_send_initiation(struct wg_peer *, bool);</p><p>+static void wg_timers_run_retry_handshake(void *);</p><p>+static void wg_timers_run_send_keepalive(void *);</p><p>+static void wg_timers_run_new_handshake(void *);</p><p>+static void wg_timers_run_zero_key_material(void *);</p><p>+static void wg_timers_run_persistent_keepalive(void *);</p><p>+static int wg_aip_add(struct wg_softc *, struct wg_peer *, sa_family_t, const void *, uint8_t);</p><p>+static struct wg_peer *wg_aip_lookup(struct wg_softc *, sa_family_t, void *);</p><p>+static void wg_aip_remove_all(struct wg_softc *, struct wg_peer *);</p><p>+static struct wg_peer *wg_peer_alloc(struct wg_softc *, const uint8_t [WG_KEY_SIZE]);</p><p>+static void wg_peer_free_deferred(struct noise_remote *);</p><p>+static void wg_peer_destroy(struct wg_peer *);</p><p>+static void wg_peer_destroy_all(struct wg_softc *);</p><p>+static void wg_peer_send_buf(struct wg_peer *, uint8_t *, size_t);</p><p>+static void wg_send_initiation(struct wg_peer *);</p><p>+static void wg_send_response(struct wg_peer *);</p><p>+static void wg_send_cookie(struct wg_softc *, struct cookie_macs *, uint32_t, struct wg_endpoint *);</p><p>+static void wg_peer_set_endpoint(struct wg_peer *, struct wg_endpoint *);</p><p>+static void wg_peer_clear_src(struct wg_peer *);</p><p>+static void wg_peer_get_endpoint(struct wg_peer *, struct wg_endpoint *);</p><p>+static void wg_send_buf(struct wg_softc *, struct wg_endpoint *, uint8_t *, size_t);</p><p>+static void wg_send_keepalive(struct wg_peer *);</p><p>+static void wg_handshake(struct wg_softc *, struct wg_packet *);</p><p>+static void wg_encrypt(struct wg_softc *, struct wg_packet *);</p><p>+static void wg_decrypt(struct wg_softc *, struct wg_packet *);</p><p>+static void wg_softc_handshake_receive(struct wg_softc *);</p><p>+static void wg_softc_decrypt(struct wg_softc *);</p><p>+static void wg_softc_encrypt(struct wg_softc *);</p><p>+static void wg_encrypt_dispatch(struct wg_softc *);</p><p>+static void wg_decrypt_dispatch(struct wg_softc *);</p><p>+static void wg_deliver_out(struct wg_peer *);</p><p>+static void wg_deliver_in(struct wg_peer *);</p><p>+static struct wg_packet *wg_packet_alloc(struct mbuf *);</p><p>+static void wg_packet_free(struct wg_packet *);</p><p>+static void wg_queue_init(struct wg_queue *, const char *);</p><p>+static void wg_queue_deinit(struct wg_queue *);</p><p>+static size_t wg_queue_len(struct wg_queue *);</p><p>+static int wg_queue_enqueue_handshake(struct wg_queue *, struct wg_packet *);</p><p>+static struct wg_packet *wg_queue_dequeue_handshake(struct wg_queue *);</p><p>+static void wg_queue_push_staged(struct wg_queue *, struct wg_packet *);</p><p>+static void wg_queue_enlist_staged(struct wg_queue *, struct wg_packet_list *);</p><p>+static void wg_queue_delist_staged(struct wg_queue *, struct wg_packet_list *);</p><p>+static void wg_queue_purge(struct wg_queue *);</p><p>+static int wg_queue_both(struct wg_queue *, struct wg_queue *, struct wg_packet *);</p><p>+static struct wg_packet *wg_queue_dequeue_serial(struct wg_queue *);</p><p>+static struct wg_packet *wg_queue_dequeue_parallel(struct wg_queue *);</p><p>+static bool wg_input(struct mbuf *, int, struct inpcb *, const struct sockaddr *, void *);</p><p>+static void wg_peer_send_staged(struct wg_peer *);</p><p>+static int wg_clone_create(struct if_clone *, int, caddr_t);</p><p>+static void wg_qflush(struct ifnet *);</p><p>+static inline int determine_af_and_pullup(struct mbuf **m, sa_family_t *af);</p><p>+static int wg_xmit(struct ifnet *, struct mbuf *, sa_family_t, uint32_t);</p><p>+static int wg_transmit(struct ifnet *, struct mbuf *);</p><p>+static int wg_output(struct ifnet *, struct mbuf *, const struct sockaddr *, struct route *);</p><p>+static void wg_clone_destroy(struct ifnet *);</p><p>+static bool wgc_privileged(struct wg_softc *);</p><p>+static int wgc_get(struct wg_softc *, struct wg_data_io *);</p><p>+static int wgc_set(struct wg_softc *, struct wg_data_io *);</p><p>+static int wg_up(struct wg_softc *);</p><p>+static void wg_down(struct wg_softc *);</p><p>+static void wg_reassign(struct ifnet *, struct vnet *, char *unused);</p><p>+static void wg_init(void *);</p><p>+static int wg_ioctl(struct ifnet *, u_long, caddr_t);</p><p>+static void vnet_wg_init(const void *);</p><p>+static void vnet_wg_uninit(const void *);</p><p>+static int wg_module_init(void);</p><p>+static void wg_module_deinit(void);</p><p>+</p><p>+/* TODO Peer */</p><p>+static struct wg_peer *</p><p>+wg_peer_alloc(struct wg_softc *sc, const uint8_t pub_key[WG_KEY_SIZE])</p><p>+{</p><p>+	struct wg_peer *peer;</p><p>+</p><p>+	sx_assert(&amp;sc-&gt;sc_lock, SX_XLOCKED);</p><p>+</p><p>+	peer = malloc(sizeof(*peer), M_WG, M_WAITOK | M_ZERO);</p><p>+	peer-&gt;p_remote = noise_remote_alloc(sc-&gt;sc_local, peer, pub_key);</p><p>+	peer-&gt;p_tx_bytes = counter_u64_alloc(M_WAITOK);</p><p>+	peer-&gt;p_rx_bytes = counter_u64_alloc(M_WAITOK);</p><p>+	peer-&gt;p_id = peer_counter++;</p><p>+	peer-&gt;p_sc = sc;</p><p>+</p><p>+	cookie_maker_init(&amp;peer-&gt;p_cookie, pub_key);</p><p>+</p><p>+	rw_init(&amp;peer-&gt;p_endpoint_lock, &#34;wg_peer_endpoint&#34;);</p><p>+</p><p>+	wg_queue_init(&amp;peer-&gt;p_stage_queue, &#34;stageq&#34;);</p><p>+	wg_queue_init(&amp;peer-&gt;p_encrypt_serial, &#34;txq&#34;);</p><p>+	wg_queue_init(&amp;peer-&gt;p_decrypt_serial, &#34;rxq&#34;);</p><p>+</p><p>+	peer-&gt;p_enabled = false;</p><p>+	peer-&gt;p_need_another_keepalive = false;</p><p>+	peer-&gt;p_persistent_keepalive_interval = 0;</p><p>+	callout_init(&amp;peer-&gt;p_new_handshake, true);</p><p>+	callout_init(&amp;peer-&gt;p_send_keepalive, true);</p><p>+	callout_init(&amp;peer-&gt;p_retry_handshake, true);</p><p>+	callout_init(&amp;peer-&gt;p_persistent_keepalive, true);</p><p>+	callout_init(&amp;peer-&gt;p_zero_key_material, true);</p><p>+</p><p>+	mtx_init(&amp;peer-&gt;p_handshake_mtx, &#34;peer handshake&#34;, NULL, MTX_DEF);</p><p>+	bzero(&amp;peer-&gt;p_handshake_complete, sizeof(peer-&gt;p_handshake_complete));</p><p>+	peer-&gt;p_handshake_retries = 0;</p><p>+</p><p>+	GROUPTASK_INIT(&amp;peer-&gt;p_send, 0, (gtask_fn_t *)wg_deliver_out, peer);</p><p>+	taskqgroup_attach(qgroup_wg_tqg, &amp;peer-&gt;p_send, peer, NULL, NULL, &#34;wg send&#34;);</p><p>+	GROUPTASK_INIT(&amp;peer-&gt;p_recv, 0, (gtask_fn_t *)wg_deliver_in, peer);</p><p>+	taskqgroup_attach(qgroup_wg_tqg, &amp;peer-&gt;p_recv, peer, NULL, NULL, &#34;wg recv&#34;);</p><p>+</p><p>+	LIST_INIT(&amp;peer-&gt;p_aips);</p><p>+	peer-&gt;p_aips_num = 0;</p><p>+</p><p>+	return (peer);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_peer_free_deferred(struct noise_remote *r)</p><p>+{</p><p>+	struct wg_peer *peer = noise_remote_arg(r);</p><p>+</p><p>+	/* While there are no references remaining, we may still have</p><p>+	 * p_{send,recv} executing (think empty queue, but wg_deliver_{in,out}</p><p>+	 * needs to check the queue. We should wait for them and then free. */</p><p>+	GROUPTASK_DRAIN(&amp;peer-&gt;p_recv);</p><p>+	GROUPTASK_DRAIN(&amp;peer-&gt;p_send);</p><p>+	taskqgroup_detach(qgroup_wg_tqg, &amp;peer-&gt;p_recv);</p><p>+	taskqgroup_detach(qgroup_wg_tqg, &amp;peer-&gt;p_send);</p><p>+</p><p>+	wg_queue_deinit(&amp;peer-&gt;p_decrypt_serial);</p><p>+	wg_queue_deinit(&amp;peer-&gt;p_encrypt_serial);</p><p>+	wg_queue_deinit(&amp;peer-&gt;p_stage_queue);</p><p>+</p><p>+	counter_u64_free(peer-&gt;p_tx_bytes);</p><p>+	counter_u64_free(peer-&gt;p_rx_bytes);</p><p>+	rw_destroy(&amp;peer-&gt;p_endpoint_lock);</p><p>+	mtx_destroy(&amp;peer-&gt;p_handshake_mtx);</p><p>+</p><p>+	cookie_maker_free(&amp;peer-&gt;p_cookie);</p><p>+</p><p>+	free(peer, M_WG);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_peer_destroy(struct wg_peer *peer)</p><p>+{</p><p>+	struct wg_softc *sc = peer-&gt;p_sc;</p><p>+	sx_assert(&amp;sc-&gt;sc_lock, SX_XLOCKED);</p><p>+</p><p>+	/* Disable remote and timers. This will prevent any new handshakes</p><p>+	 * occuring. */</p><p>+	noise_remote_disable(peer-&gt;p_remote);</p><p>+	wg_timers_disable(peer);</p><p>+</p><p>+	/* Now we can remove all allowed IPs so no more packets will be routed</p><p>+	 * to the peer. */</p><p>+	wg_aip_remove_all(sc, peer);</p><p>+</p><p>+	/* Remove peer from the interface, then free. Some references may still</p><p>+	 * exist to p_remote, so noise_remote_free will wait until they&#39;re all</p><p>+	 * put to call wg_peer_free_deferred. */</p><p>+	sc-&gt;sc_peers_num--;</p><p>+	TAILQ_REMOVE(&amp;sc-&gt;sc_peers, peer, p_entry);</p><p>+	DPRINTF(sc, &#34;Peer %&#34; PRIu64 &#34; destroyed\n&#34;, peer-&gt;p_id);</p><p>+	noise_remote_free(peer-&gt;p_remote, wg_peer_free_deferred);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_peer_destroy_all(struct wg_softc *sc)</p><p>+{</p><p>+	struct wg_peer *peer, *tpeer;</p><p>+	TAILQ_FOREACH_SAFE(peer, &amp;sc-&gt;sc_peers, p_entry, tpeer)</p><p>+		wg_peer_destroy(peer);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_peer_set_endpoint(struct wg_peer *peer, struct wg_endpoint *e)</p><p>+{</p><p>+	MPASS(e-&gt;e_remote.r_sa.sa_family != 0);</p><p>+	if (memcmp(e, &amp;peer-&gt;p_endpoint, sizeof(*e)) == 0)</p><p>+		return;</p><p>+</p><p>+	rw_wlock(&amp;peer-&gt;p_endpoint_lock);</p><p>+	peer-&gt;p_endpoint = *e;</p><p>+	rw_wunlock(&amp;peer-&gt;p_endpoint_lock);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_peer_clear_src(struct wg_peer *peer)</p><p>+{</p><p>+	rw_wlock(&amp;peer-&gt;p_endpoint_lock);</p><p>+	bzero(&amp;peer-&gt;p_endpoint.e_local, sizeof(peer-&gt;p_endpoint.e_local));</p><p>+	rw_wunlock(&amp;peer-&gt;p_endpoint_lock);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_peer_get_endpoint(struct wg_peer *peer, struct wg_endpoint *e)</p><p>+{</p><p>+	rw_rlock(&amp;peer-&gt;p_endpoint_lock);</p><p>+	*e = peer-&gt;p_endpoint;</p><p>+	rw_runlock(&amp;peer-&gt;p_endpoint_lock);</p><p>+}</p><p>+</p><p>+/* Allowed IP */</p><p>+static int</p><p>+wg_aip_add(struct wg_softc *sc, struct wg_peer *peer, sa_family_t af, const void *addr, uint8_t cidr)</p><p>+{</p><p>+	struct radix_node_head	*root;</p><p>+	struct radix_node	*node;</p><p>+	struct wg_aip		*aip;</p><p>+	int			 ret = 0;</p><p>+</p><p>+	aip = malloc(sizeof(*aip), M_WG, M_WAITOK | M_ZERO);</p><p>+	aip-&gt;a_peer = peer;</p><p>+	aip-&gt;a_af = af;</p><p>+</p><p>+	switch (af) {</p><p>+#ifdef INET</p><p>+	case AF_INET:</p><p>+		if (cidr &gt; 32) cidr = 32;</p><p>+		root = sc-&gt;sc_aip4;</p><p>+		aip-&gt;a_addr.in = *(const struct in_addr *)addr;</p><p>+		aip-&gt;a_mask.ip = htonl(~((1LL &lt;&lt; (32 - cidr)) - 1) &amp; 0xffffffff);</p><p>+		aip-&gt;a_addr.ip &amp;= aip-&gt;a_mask.ip;</p><p>+		aip-&gt;a_addr.length = aip-&gt;a_mask.length = offsetof(struct aip_addr, in) + sizeof(struct in_addr);</p><p>+		break;</p><p>+#endif</p><p>+#ifdef INET6</p><p>+	case AF_INET6:</p><p>+		if (cidr &gt; 128) cidr = 128;</p><p>+		root = sc-&gt;sc_aip6;</p><p>+		aip-&gt;a_addr.in6 = *(const struct in6_addr *)addr;</p><p>+		in6_prefixlen2mask(&amp;aip-&gt;a_mask.in6, cidr);</p><p>+		for (int i = 0; i &lt; 4; i++)</p><p>+			aip-&gt;a_addr.ip6[i] &amp;= aip-&gt;a_mask.ip6[i];</p><p>+		aip-&gt;a_addr.length = aip-&gt;a_mask.length = offsetof(struct aip_addr, in6) + sizeof(struct in6_addr);</p><p>+		break;</p><p>+#endif</p><p>+	default:</p><p>+		free(aip, M_WG);</p><p>+		return (EAFNOSUPPORT);</p><p>+	}</p><p>+</p><p>+	RADIX_NODE_HEAD_LOCK(root);</p><p>+	node = root-&gt;rnh_addaddr(&amp;aip-&gt;a_addr, &amp;aip-&gt;a_mask, &amp;root-&gt;rh, aip-&gt;a_nodes);</p><p>+	if (node == aip-&gt;a_nodes) {</p><p>+		LIST_INSERT_HEAD(&amp;peer-&gt;p_aips, aip, a_entry);</p><p>+		peer-&gt;p_aips_num++;</p><p>+	} else if (!node)</p><p>+		node = root-&gt;rnh_lookup(&amp;aip-&gt;a_addr, &amp;aip-&gt;a_mask, &amp;root-&gt;rh);</p><p>+	if (!node) {</p><p>+		free(aip, M_WG);</p><p>+		return (ENOMEM);</p><p>+	} else if (node != aip-&gt;a_nodes) {</p><p>+		free(aip, M_WG);</p><p>+		aip = (struct wg_aip *)node;</p><p>+		if (aip-&gt;a_peer != peer) {</p><p>+			LIST_REMOVE(aip, a_entry);</p><p>+			aip-&gt;a_peer-&gt;p_aips_num--;</p><p>+			aip-&gt;a_peer = peer;</p><p>+			LIST_INSERT_HEAD(&amp;peer-&gt;p_aips, aip, a_entry);</p><p>+			aip-&gt;a_peer-&gt;p_aips_num++;</p><p>+		}</p><p>+	}</p><p>+	RADIX_NODE_HEAD_UNLOCK(root);</p><p>+	return (ret);</p><p>+}</p><p>+</p><p>+static struct wg_peer *</p><p>+wg_aip_lookup(struct wg_softc *sc, sa_family_t af, void *a)</p><p>+{</p><p>+	struct radix_node_head	*root;</p><p>+	struct radix_node	*node;</p><p>+	struct wg_peer		*peer;</p><p>+	struct aip_addr		 addr;</p><p>+	RADIX_NODE_HEAD_RLOCK_TRACKER;</p><p>+</p><p>+	switch (af) {</p><p>+	case AF_INET:</p><p>+		root = sc-&gt;sc_aip4;</p><p>+		memcpy(&amp;addr.in, a, sizeof(addr.in));</p><p>+		addr.length = offsetof(struct aip_addr, in) + sizeof(struct in_addr);</p><p>+		break;</p><p>+	case AF_INET6:</p><p>+		root = sc-&gt;sc_aip6;</p><p>+		memcpy(&amp;addr.in6, a, sizeof(addr.in6));</p><p>+		addr.length = offsetof(struct aip_addr, in6) + sizeof(struct in6_addr);</p><p>+		break;</p><p>+	default:</p><p>+		return NULL;</p><p>+	}</p><p>+</p><p>+	RADIX_NODE_HEAD_RLOCK(root);</p><p>+	node = root-&gt;rnh_matchaddr(&amp;addr, &amp;root-&gt;rh);</p><p>+	if (node != NULL) {</p><p>+		peer = ((struct wg_aip *)node)-&gt;a_peer;</p><p>+		noise_remote_ref(peer-&gt;p_remote);</p><p>+	} else {</p><p>+		peer = NULL;</p><p>+	}</p><p>+	RADIX_NODE_HEAD_RUNLOCK(root);</p><p>+</p><p>+	return (peer);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_aip_remove_all(struct wg_softc *sc, struct wg_peer *peer)</p><p>+{</p><p>+	struct wg_aip		*aip, *taip;</p><p>+</p><p>+	RADIX_NODE_HEAD_LOCK(sc-&gt;sc_aip4);</p><p>+	LIST_FOREACH_SAFE(aip, &amp;peer-&gt;p_aips, a_entry, taip) {</p><p>+		if (aip-&gt;a_af == AF_INET) {</p><p>+			if (sc-&gt;sc_aip4-&gt;rnh_deladdr(&amp;aip-&gt;a_addr, &amp;aip-&gt;a_mask, &amp;sc-&gt;sc_aip4-&gt;rh) == NULL)</p><p>+				panic(&#34;failed to delete aip %p&#34;, aip);</p><p>+			LIST_REMOVE(aip, a_entry);</p><p>+			peer-&gt;p_aips_num--;</p><p>+			free(aip, M_WG);</p><p>+		}</p><p>+	}</p><p>+	RADIX_NODE_HEAD_UNLOCK(sc-&gt;sc_aip4);</p><p>+</p><p>+	RADIX_NODE_HEAD_LOCK(sc-&gt;sc_aip6);</p><p>+	LIST_FOREACH_SAFE(aip, &amp;peer-&gt;p_aips, a_entry, taip) {</p><p>+		if (aip-&gt;a_af == AF_INET6) {</p><p>+			if (sc-&gt;sc_aip6-&gt;rnh_deladdr(&amp;aip-&gt;a_addr, &amp;aip-&gt;a_mask, &amp;sc-&gt;sc_aip6-&gt;rh) == NULL)</p><p>+				panic(&#34;failed to delete aip %p&#34;, aip);</p><p>+			LIST_REMOVE(aip, a_entry);</p><p>+			peer-&gt;p_aips_num--;</p><p>+			free(aip, M_WG);</p><p>+		}</p><p>+	}</p><p>+	RADIX_NODE_HEAD_UNLOCK(sc-&gt;sc_aip6);</p><p>+</p><p>+	if (!LIST_EMPTY(&amp;peer-&gt;p_aips) || peer-&gt;p_aips_num != 0)</p><p>+		panic(&#34;wg_aip_remove_all could not delete all %p&#34;, peer);</p><p>+}</p><p>+</p><p>+static int</p><p>+wg_socket_init(struct wg_softc *sc, in_port_t port)</p><p>+{</p><p>+	struct ucred *cred = sc-&gt;sc_ucred;</p><p>+	struct socket *so4 = NULL, *so6 = NULL;</p><p>+	int rc;</p><p>+</p><p>+	sx_assert(&amp;sc-&gt;sc_lock, SX_XLOCKED);</p><p>+</p><p>+	if (!cred)</p><p>+		return (EBUSY);</p><p>+</p><p>+	/*</p><p>+	 * For socket creation, we use the creds of the thread that created the</p><p>+	 * tunnel rather than the current thread to maintain the semantics that</p><p>+	 * WireGuard has on Linux with network namespaces -- that the sockets</p><p>+	 * are created in their home vnet so that they can be configured and</p><p>+	 * functionally attached to a foreign vnet as the jail&#39;s only interface</p><p>+	 * to the network.</p><p>+	 */</p><p>+#ifdef INET</p><p>+	rc = socreate(AF_INET, &amp;so4, SOCK_DGRAM, IPPROTO_UDP, cred, curthread);</p><p>+	if (rc)</p><p>+		goto out;</p><p>+</p><p>+	rc = udp_set_kernel_tunneling(so4, wg_input, NULL, sc);</p><p>+	/*</p><p>+	 * udp_set_kernel_tunneling can only fail if there is already a tunneling function set.</p><p>+	 * This should never happen with a new socket.</p><p>+	 */</p><p>+	MPASS(rc == 0);</p><p>+#endif</p><p>+</p><p>+#ifdef INET6</p><p>+	rc = socreate(AF_INET6, &amp;so6, SOCK_DGRAM, IPPROTO_UDP, cred, curthread);</p><p>+	if (rc)</p><p>+		goto out;</p><p>+	rc = udp_set_kernel_tunneling(so6, wg_input, NULL, sc);</p><p>+	MPASS(rc == 0);</p><p>+#endif</p><p>+</p><p>+	if (sc-&gt;sc_socket.so_user_cookie) {</p><p>+		rc = wg_socket_set_sockopt(so4, so6, SO_USER_COOKIE, &amp;sc-&gt;sc_socket.so_user_cookie, sizeof(sc-&gt;sc_socket.so_user_cookie));</p><p>+		if (rc)</p><p>+			goto out;</p><p>+	}</p><p>+	rc = wg_socket_set_sockopt(so4, so6, SO_SETFIB, &amp;sc-&gt;sc_socket.so_fibnum, sizeof(sc-&gt;sc_socket.so_fibnum));</p><p>+	if (rc)</p><p>+		goto out;</p><p>+</p><p>+	rc = wg_socket_bind(&amp;so4, &amp;so6, &amp;port);</p><p>+	if (!rc) {</p><p>+		sc-&gt;sc_socket.so_port = port;</p><p>+		wg_socket_set(sc, so4, so6);</p><p>+	}</p><p>+out:</p><p>+	if (rc) {</p><p>+		if (so4 != NULL)</p><p>+			soclose(so4);</p><p>+		if (so6 != NULL)</p><p>+			soclose(so6);</p><p>+	}</p><p>+	return (rc);</p><p>+}</p><p>+</p><p>+static int wg_socket_set_sockopt(struct socket *so4, struct socket *so6, int name, void *val, size_t len)</p><p>+{</p><p>+	int ret4 = 0, ret6 = 0;</p><p>+	struct sockopt sopt = {</p><p>+		.sopt_dir = SOPT_SET,</p><p>+		.sopt_level = SOL_SOCKET,</p><p>+		.sopt_name = name,</p><p>+		.sopt_val = val,</p><p>+		.sopt_valsize = len</p><p>+	};</p><p>+</p><p>+	if (so4)</p><p>+		ret4 = sosetopt(so4, &amp;sopt);</p><p>+	if (so6)</p><p>+		ret6 = sosetopt(so6, &amp;sopt);</p><p>+	return (ret4 ?: ret6);</p><p>+}</p><p>+</p><p>+static int wg_socket_set_cookie(struct wg_softc *sc, uint32_t user_cookie)</p><p>+{</p><p>+	struct wg_socket *so = &amp;sc-&gt;sc_socket;</p><p>+	int ret;</p><p>+</p><p>+	sx_assert(&amp;sc-&gt;sc_lock, SX_XLOCKED);</p><p>+	ret = wg_socket_set_sockopt(so-&gt;so_so4, so-&gt;so_so6, SO_USER_COOKIE, &amp;user_cookie, sizeof(user_cookie));</p><p>+	if (!ret)</p><p>+		so-&gt;so_user_cookie = user_cookie;</p><p>+	return (ret);</p><p>+}</p><p>+</p><p>+static int wg_socket_set_fibnum(struct wg_softc *sc, int fibnum)</p><p>+{</p><p>+	struct wg_socket *so = &amp;sc-&gt;sc_socket;</p><p>+	int ret;</p><p>+</p><p>+	sx_assert(&amp;sc-&gt;sc_lock, SX_XLOCKED);</p><p>+</p><p>+	ret = wg_socket_set_sockopt(so-&gt;so_so4, so-&gt;so_so6, SO_SETFIB, &amp;fibnum, sizeof(fibnum));</p><p>+	if (!ret)</p><p>+		so-&gt;so_fibnum = fibnum;</p><p>+	return (ret);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_socket_uninit(struct wg_softc *sc)</p><p>+{</p><p>+	wg_socket_set(sc, NULL, NULL);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_socket_set(struct wg_softc *sc, struct socket *new_so4, struct socket *new_so6)</p><p>+{</p><p>+	struct wg_socket *so = &amp;sc-&gt;sc_socket;</p><p>+	struct socket *so4, *so6;</p><p>+</p><p>+	sx_assert(&amp;sc-&gt;sc_lock, SX_XLOCKED);</p><p>+</p><p>+	so4 = ck_pr_load_ptr(&amp;so-&gt;so_so4);</p><p>+	so6 = ck_pr_load_ptr(&amp;so-&gt;so_so6);</p><p>+	ck_pr_store_ptr(&amp;so-&gt;so_so4, new_so4);</p><p>+	ck_pr_store_ptr(&amp;so-&gt;so_so6, new_so6);</p><p>+</p><p>+	if (!so4 &amp;&amp; !so6)</p><p>+		return;</p><p>+	NET_EPOCH_WAIT();</p><p>+	if (so4)</p><p>+		soclose(so4);</p><p>+	if (so6)</p><p>+		soclose(so6);</p><p>+}</p><p>+</p><p>+static int</p><p>+wg_socket_bind(struct socket **in_so4, struct socket **in_so6, in_port_t *requested_port)</p><p>+{</p><p>+	struct socket *so4 = *in_so4, *so6 = *in_so6;</p><p>+	int ret4 = 0, ret6 = 0;</p><p>+	in_port_t port = *requested_port;</p><p>+	struct sockaddr_in sin = {</p><p>+		.sin_len = sizeof(struct sockaddr_in),</p><p>+		.sin_family = AF_INET,</p><p>+		.sin_port = htons(port)</p><p>+	};</p><p>+	struct sockaddr_in6 sin6 = {</p><p>+		.sin6_len = sizeof(struct sockaddr_in6),</p><p>+		.sin6_family = AF_INET6,</p><p>+		.sin6_port = htons(port)</p><p>+	};</p><p>+</p><p>+	if (so4) {</p><p>+		ret4 = sobind(so4, (struct sockaddr *)&amp;sin, curthread);</p><p>+		if (ret4 &amp;&amp; ret4 != EADDRNOTAVAIL)</p><p>+			return (ret4);</p><p>+		if (!ret4 &amp;&amp; !sin.sin_port) {</p><p>+			struct sockaddr_in *bound_sin;</p><p>+			int ret = so4-&gt;so_proto-&gt;pr_sockaddr(so4,</p><p>+			    (struct sockaddr **)&amp;bound_sin);</p><p>+			if (ret)</p><p>+				return (ret);</p><p>+			port = ntohs(bound_sin-&gt;sin_port);</p><p>+			sin6.sin6_port = bound_sin-&gt;sin_port;</p><p>+			free(bound_sin, M_SONAME);</p><p>+		}</p><p>+	}</p><p>+</p><p>+	if (so6) {</p><p>+		ret6 = sobind(so6, (struct sockaddr *)&amp;sin6, curthread);</p><p>+		if (ret6 &amp;&amp; ret6 != EADDRNOTAVAIL)</p><p>+			return (ret6);</p><p>+		if (!ret6 &amp;&amp; !sin6.sin6_port) {</p><p>+			struct sockaddr_in6 *bound_sin6;</p><p>+			int ret = so6-&gt;so_proto-&gt;pr_sockaddr(so6,</p><p>+			    (struct sockaddr **)&amp;bound_sin6);</p><p>+			if (ret)</p><p>+				return (ret);</p><p>+			port = ntohs(bound_sin6-&gt;sin6_port);</p><p>+			free(bound_sin6, M_SONAME);</p><p>+		}</p><p>+	}</p><p>+</p><p>+	if (ret4 &amp;&amp; ret6)</p><p>+		return (ret4);</p><p>+	*requested_port = port;</p><p>+	if (ret4 &amp;&amp; !ret6 &amp;&amp; so4) {</p><p>+		soclose(so4);</p><p>+		*in_so4 = NULL;</p><p>+	} else if (ret6 &amp;&amp; !ret4 &amp;&amp; so6) {</p><p>+		soclose(so6);</p><p>+		*in_so6 = NULL;</p><p>+	}</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+static int</p><p>+wg_send(struct wg_softc *sc, struct wg_endpoint *e, struct mbuf *m)</p><p>+{</p><p>+	struct epoch_tracker et;</p><p>+	struct sockaddr *sa;</p><p>+	struct wg_socket *so = &amp;sc-&gt;sc_socket;</p><p>+	struct socket *so4, *so6;</p><p>+	struct mbuf *control = NULL;</p><p>+	int ret = 0;</p><p>+	size_t len = m-&gt;m_pkthdr.len;</p><p>+</p><p>+	/* Get local control address before locking */</p><p>+	if (e-&gt;e_remote.r_sa.sa_family == AF_INET) {</p><p>+		if (e-&gt;e_local.l_in.s_addr != INADDR_ANY)</p><p>+			control = sbcreatecontrol((caddr_t)&amp;e-&gt;e_local.l_in,</p><p>+			    sizeof(struct in_addr), IP_SENDSRCADDR,</p><p>+			    IPPROTO_IP, M_NOWAIT);</p><p>+#ifdef INET6</p><p>+	} else if (e-&gt;e_remote.r_sa.sa_family == AF_INET6) {</p><p>+		if (!IN6_IS_ADDR_UNSPECIFIED(&amp;e-&gt;e_local.l_in6))</p><p>+			control = sbcreatecontrol((caddr_t)&amp;e-&gt;e_local.l_pktinfo6,</p><p>+			    sizeof(struct in6_pktinfo), IPV6_PKTINFO,</p><p>+			    IPPROTO_IPV6, M_NOWAIT);</p><p>+#endif</p><p>+	} else {</p><p>+		m_freem(m);</p><p>+		return (EAFNOSUPPORT);</p><p>+	}</p><p>+</p><p>+	/* Get remote address */</p><p>+	sa = &amp;e-&gt;e_remote.r_sa;</p><p>+</p><p>+	NET_EPOCH_ENTER(et);</p><p>+	so4 = ck_pr_load_ptr(&amp;so-&gt;so_so4);</p><p>+	so6 = ck_pr_load_ptr(&amp;so-&gt;so_so6);</p><p>+	if (e-&gt;e_remote.r_sa.sa_family == AF_INET &amp;&amp; so4 != NULL)</p><p>+		ret = sosend(so4, sa, NULL, m, control, 0, curthread);</p><p>+	else if (e-&gt;e_remote.r_sa.sa_family == AF_INET6 &amp;&amp; so6 != NULL)</p><p>+		ret = sosend(so6, sa, NULL, m, control, 0, curthread);</p><p>+	else {</p><p>+		ret = ENOTCONN;</p><p>+		m_freem(control);</p><p>+		m_freem(m);</p><p>+	}</p><p>+	NET_EPOCH_EXIT(et);</p><p>+	if (ret == 0) {</p><p>+		if_inc_counter(sc-&gt;sc_ifp, IFCOUNTER_OPACKETS, 1);</p><p>+		if_inc_counter(sc-&gt;sc_ifp, IFCOUNTER_OBYTES, len);</p><p>+	}</p><p>+	return (ret);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_send_buf(struct wg_softc *sc, struct wg_endpoint *e, uint8_t *buf, size_t len)</p><p>+{</p><p>+	struct mbuf	*m;</p><p>+	int		 ret = 0;</p><p>+	bool		 retried = false;</p><p>+</p><p>+retry:</p><p>+	m = m_get2(len, M_NOWAIT, MT_DATA, M_PKTHDR);</p><p>+	if (!m) {</p><p>+		ret = ENOMEM;</p><p>+		goto out;</p><p>+	}</p><p>+	m_copyback(m, 0, len, buf);</p><p>+</p><p>+	if (ret == 0) {</p><p>+		ret = wg_send(sc, e, m);</p><p>+		/* Retry if we couldn&#39;t bind to e-&gt;e_local */</p><p>+		if (ret == EADDRNOTAVAIL &amp;&amp; !retried) {</p><p>+			bzero(&amp;e-&gt;e_local, sizeof(e-&gt;e_local));</p><p>+			retried = true;</p><p>+			goto retry;</p><p>+		}</p><p>+	} else {</p><p>+		ret = wg_send(sc, e, m);</p><p>+	}</p><p>+out:</p><p>+	if (ret)</p><p>+		DPRINTF(sc, &#34;Unable to send packet: %d\n&#34;, ret);</p><p>+}</p><p>+</p><p>+/* Timers */</p><p>+static void</p><p>+wg_timers_enable(struct wg_peer *peer)</p><p>+{</p><p>+	ck_pr_store_bool(&amp;peer-&gt;p_enabled, true);</p><p>+	wg_timers_run_persistent_keepalive(peer);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_timers_disable(struct wg_peer *peer)</p><p>+{</p><p>+	/* By setting p_enabled = false, then calling NET_EPOCH_WAIT, we can be</p><p>+	 * sure no new handshakes are created after the wait. This is because</p><p>+	 * all callout_resets (scheduling the callout) are guarded by</p><p>+	 * p_enabled. We can be sure all sections that read p_enabled and then</p><p>+	 * optionally call callout_reset are finished as they are surrounded by</p><p>+	 * NET_EPOCH_{ENTER,EXIT}.</p><p>+	 *</p><p>+	 * However, as new callouts may be scheduled during NET_EPOCH_WAIT (but</p><p>+	 * not after), we stop all callouts leaving no callouts active.</p><p>+	 *</p><p>+	 * We should also pull NET_EPOCH_WAIT out of the FOREACH(peer) loops, but the</p><p>+	 * performance impact is acceptable for the time being. */</p><p>+	ck_pr_store_bool(&amp;peer-&gt;p_enabled, false);</p><p>+	NET_EPOCH_WAIT();</p><p>+	ck_pr_store_bool(&amp;peer-&gt;p_need_another_keepalive, false);</p><p>+</p><p>+	callout_stop(&amp;peer-&gt;p_new_handshake);</p><p>+	callout_stop(&amp;peer-&gt;p_send_keepalive);</p><p>+	callout_stop(&amp;peer-&gt;p_retry_handshake);</p><p>+	callout_stop(&amp;peer-&gt;p_persistent_keepalive);</p><p>+	callout_stop(&amp;peer-&gt;p_zero_key_material);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_timers_set_persistent_keepalive(struct wg_peer *peer, uint16_t interval)</p><p>+{</p><p>+	struct epoch_tracker et;</p><p>+	if (interval != peer-&gt;p_persistent_keepalive_interval) {</p><p>+		ck_pr_store_16(&amp;peer-&gt;p_persistent_keepalive_interval, interval);</p><p>+		NET_EPOCH_ENTER(et);</p><p>+		if (ck_pr_load_bool(&amp;peer-&gt;p_enabled))</p><p>+			wg_timers_run_persistent_keepalive(peer);</p><p>+		NET_EPOCH_EXIT(et);</p><p>+	}</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_timers_get_last_handshake(struct wg_peer *peer, struct wg_timespec64 *time)</p><p>+{</p><p>+	mtx_lock(&amp;peer-&gt;p_handshake_mtx);</p><p>+	time-&gt;tv_sec = peer-&gt;p_handshake_complete.tv_sec;</p><p>+	time-&gt;tv_nsec = peer-&gt;p_handshake_complete.tv_nsec;</p><p>+	mtx_unlock(&amp;peer-&gt;p_handshake_mtx);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_timers_event_data_sent(struct wg_peer *peer)</p><p>+{</p><p>+	struct epoch_tracker et;</p><p>+	NET_EPOCH_ENTER(et);</p><p>+	if (ck_pr_load_bool(&amp;peer-&gt;p_enabled) &amp;&amp; !callout_pending(&amp;peer-&gt;p_new_handshake))</p><p>+		callout_reset(&amp;peer-&gt;p_new_handshake, MSEC_2_TICKS(</p><p>+		    NEW_HANDSHAKE_TIMEOUT * 1000 +</p><p>+		    arc4random_uniform(REKEY_TIMEOUT_JITTER)),</p><p>+		    wg_timers_run_new_handshake, peer);</p><p>+	NET_EPOCH_EXIT(et);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_timers_event_data_received(struct wg_peer *peer)</p><p>+{</p><p>+	struct epoch_tracker et;</p><p>+	NET_EPOCH_ENTER(et);</p><p>+	if (ck_pr_load_bool(&amp;peer-&gt;p_enabled)) {</p><p>+		if (!callout_pending(&amp;peer-&gt;p_send_keepalive))</p><p>+			callout_reset(&amp;peer-&gt;p_send_keepalive,</p><p>+			    MSEC_2_TICKS(KEEPALIVE_TIMEOUT * 1000),</p><p>+			    wg_timers_run_send_keepalive, peer);</p><p>+		else</p><p>+			ck_pr_store_bool(&amp;peer-&gt;p_need_another_keepalive, true);</p><p>+	}</p><p>+	NET_EPOCH_EXIT(et);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_timers_event_any_authenticated_packet_sent(struct wg_peer *peer)</p><p>+{</p><p>+	callout_stop(&amp;peer-&gt;p_send_keepalive);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_timers_event_any_authenticated_packet_received(struct wg_peer *peer)</p><p>+{</p><p>+	callout_stop(&amp;peer-&gt;p_new_handshake);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_timers_event_any_authenticated_packet_traversal(struct wg_peer *peer)</p><p>+{</p><p>+	struct epoch_tracker et;</p><p>+	uint16_t interval;</p><p>+	NET_EPOCH_ENTER(et);</p><p>+	interval = ck_pr_load_16(&amp;peer-&gt;p_persistent_keepalive_interval);</p><p>+	if (ck_pr_load_bool(&amp;peer-&gt;p_enabled) &amp;&amp; interval &gt; 0)</p><p>+		callout_reset(&amp;peer-&gt;p_persistent_keepalive,</p><p>+		     MSEC_2_TICKS(interval * 1000),</p><p>+		     wg_timers_run_persistent_keepalive, peer);</p><p>+	NET_EPOCH_EXIT(et);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_timers_event_handshake_initiated(struct wg_peer *peer)</p><p>+{</p><p>+	struct epoch_tracker et;</p><p>+	NET_EPOCH_ENTER(et);</p><p>+	if (ck_pr_load_bool(&amp;peer-&gt;p_enabled))</p><p>+		callout_reset(&amp;peer-&gt;p_retry_handshake, MSEC_2_TICKS(</p><p>+		    REKEY_TIMEOUT * 1000 +</p><p>+		    arc4random_uniform(REKEY_TIMEOUT_JITTER)),</p><p>+		    wg_timers_run_retry_handshake, peer);</p><p>+	NET_EPOCH_EXIT(et);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_timers_event_handshake_complete(struct wg_peer *peer)</p><p>+{</p><p>+	struct epoch_tracker et;</p><p>+	NET_EPOCH_ENTER(et);</p><p>+	if (ck_pr_load_bool(&amp;peer-&gt;p_enabled)) {</p><p>+		mtx_lock(&amp;peer-&gt;p_handshake_mtx);</p><p>+		callout_stop(&amp;peer-&gt;p_retry_handshake);</p><p>+		peer-&gt;p_handshake_retries = 0;</p><p>+		getnanotime(&amp;peer-&gt;p_handshake_complete);</p><p>+		mtx_unlock(&amp;peer-&gt;p_handshake_mtx);</p><p>+		wg_timers_run_send_keepalive(peer);</p><p>+	}</p><p>+	NET_EPOCH_EXIT(et);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_timers_event_session_derived(struct wg_peer *peer)</p><p>+{</p><p>+	struct epoch_tracker et;</p><p>+	NET_EPOCH_ENTER(et);</p><p>+	if (ck_pr_load_bool(&amp;peer-&gt;p_enabled))</p><p>+		callout_reset(&amp;peer-&gt;p_zero_key_material,</p><p>+		    MSEC_2_TICKS(REJECT_AFTER_TIME * 3 * 1000),</p><p>+		    wg_timers_run_zero_key_material, peer);</p><p>+	NET_EPOCH_EXIT(et);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_timers_event_want_initiation(struct wg_peer *peer)</p><p>+{</p><p>+	struct epoch_tracker et;</p><p>+	NET_EPOCH_ENTER(et);</p><p>+	if (ck_pr_load_bool(&amp;peer-&gt;p_enabled))</p><p>+		wg_timers_run_send_initiation(peer, false);</p><p>+	NET_EPOCH_EXIT(et);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_timers_run_send_initiation(struct wg_peer *peer, bool is_retry)</p><p>+{</p><p>+	if (!is_retry)</p><p>+		peer-&gt;p_handshake_retries = 0;</p><p>+	if (noise_remote_initiation_expired(peer-&gt;p_remote) == ETIMEDOUT)</p><p>+		wg_send_initiation(peer);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_timers_run_retry_handshake(void *_peer)</p><p>+{</p><p>+	struct epoch_tracker et;</p><p>+	struct wg_peer *peer = _peer;</p><p>+</p><p>+	mtx_lock(&amp;peer-&gt;p_handshake_mtx);</p><p>+	if (peer-&gt;p_handshake_retries &lt;= MAX_TIMER_HANDSHAKES) {</p><p>+		peer-&gt;p_handshake_retries++;</p><p>+		mtx_unlock(&amp;peer-&gt;p_handshake_mtx);</p><p>+</p><p>+		DPRINTF(peer-&gt;p_sc, &#34;Handshake for peer %&#34; PRIu64 &#34; did not complete &#34;</p><p>+		    &#34;after %d seconds, retrying (try %d)\n&#34;, peer-&gt;p_id,</p><p>+		    REKEY_TIMEOUT, peer-&gt;p_handshake_retries + 1);</p><p>+		wg_peer_clear_src(peer);</p><p>+		wg_timers_run_send_initiation(peer, true);</p><p>+	} else {</p><p>+		mtx_unlock(&amp;peer-&gt;p_handshake_mtx);</p><p>+</p><p>+		DPRINTF(peer-&gt;p_sc, &#34;Handshake for peer %&#34; PRIu64 &#34; did not complete &#34;</p><p>+		    &#34;after %d retries, giving up\n&#34;, peer-&gt;p_id,</p><p>+		    MAX_TIMER_HANDSHAKES + 2);</p><p>+</p><p>+		callout_stop(&amp;peer-&gt;p_send_keepalive);</p><p>+		wg_queue_purge(&amp;peer-&gt;p_stage_queue);</p><p>+		NET_EPOCH_ENTER(et);</p><p>+		if (ck_pr_load_bool(&amp;peer-&gt;p_enabled) &amp;&amp;</p><p>+		    !callout_pending(&amp;peer-&gt;p_zero_key_material))</p><p>+			callout_reset(&amp;peer-&gt;p_zero_key_material,</p><p>+			    MSEC_2_TICKS(REJECT_AFTER_TIME * 3 * 1000),</p><p>+			    wg_timers_run_zero_key_material, peer);</p><p>+		NET_EPOCH_EXIT(et);</p><p>+	}</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_timers_run_send_keepalive(void *_peer)</p><p>+{</p><p>+	struct epoch_tracker et;</p><p>+	struct wg_peer *peer = _peer;</p><p>+</p><p>+	wg_send_keepalive(peer);</p><p>+	NET_EPOCH_ENTER(et);</p><p>+	if (ck_pr_load_bool(&amp;peer-&gt;p_enabled) &amp;&amp;</p><p>+	    ck_pr_load_bool(&amp;peer-&gt;p_need_another_keepalive)) {</p><p>+		ck_pr_store_bool(&amp;peer-&gt;p_need_another_keepalive, false);</p><p>+		callout_reset(&amp;peer-&gt;p_send_keepalive,</p><p>+		    MSEC_2_TICKS(KEEPALIVE_TIMEOUT * 1000),</p><p>+		    wg_timers_run_send_keepalive, peer);</p><p>+	}</p><p>+	NET_EPOCH_EXIT(et);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_timers_run_new_handshake(void *_peer)</p><p>+{</p><p>+	struct wg_peer *peer = _peer;</p><p>+</p><p>+	DPRINTF(peer-&gt;p_sc, &#34;Retrying handshake with peer %&#34; PRIu64 &#34; because we &#34;</p><p>+	    &#34;stopped hearing back after %d seconds\n&#34;,</p><p>+	    peer-&gt;p_id, NEW_HANDSHAKE_TIMEOUT);</p><p>+</p><p>+	wg_peer_clear_src(peer);</p><p>+	wg_timers_run_send_initiation(peer, false);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_timers_run_zero_key_material(void *_peer)</p><p>+{</p><p>+	struct wg_peer *peer = _peer;</p><p>+</p><p>+	DPRINTF(peer-&gt;p_sc, &#34;Zeroing out keys for peer %&#34; PRIu64 &#34;, since we &#34;</p><p>+	    &#34;haven&#39;t received a new one in %d seconds\n&#34;,</p><p>+	    peer-&gt;p_id, REJECT_AFTER_TIME * 3);</p><p>+	noise_remote_keypairs_clear(peer-&gt;p_remote);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_timers_run_persistent_keepalive(void *_peer)</p><p>+{</p><p>+	struct wg_peer *peer = _peer;</p><p>+</p><p>+	if (ck_pr_load_16(&amp;peer-&gt;p_persistent_keepalive_interval) &gt; 0)</p><p>+		wg_send_keepalive(peer);</p><p>+}</p><p>+</p><p>+/* TODO Handshake */</p><p>+static void</p><p>+wg_peer_send_buf(struct wg_peer *peer, uint8_t *buf, size_t len)</p><p>+{</p><p>+	struct wg_endpoint endpoint;</p><p>+</p><p>+	counter_u64_add(peer-&gt;p_tx_bytes, len);</p><p>+	wg_timers_event_any_authenticated_packet_traversal(peer);</p><p>+	wg_timers_event_any_authenticated_packet_sent(peer);</p><p>+	wg_peer_get_endpoint(peer, &amp;endpoint);</p><p>+	wg_send_buf(peer-&gt;p_sc, &amp;endpoint, buf, len);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_send_initiation(struct wg_peer *peer)</p><p>+{</p><p>+	struct wg_pkt_initiation pkt;</p><p>+</p><p>+	if (noise_create_initiation(peer-&gt;p_remote, &amp;pkt.s_idx, pkt.ue,</p><p>+	    pkt.es, pkt.ets) != 0)</p><p>+		return;</p><p>+</p><p>+	DPRINTF(peer-&gt;p_sc, &#34;Sending handshake initiation to peer %&#34; PRIu64 &#34;\n&#34;, peer-&gt;p_id);</p><p>+</p><p>+	pkt.t = WG_PKT_INITIATION;</p><p>+	cookie_maker_mac(&amp;peer-&gt;p_cookie, &amp;pkt.m, &amp;pkt,</p><p>+	    sizeof(pkt) - sizeof(pkt.m));</p><p>+	wg_peer_send_buf(peer, (uint8_t *)&amp;pkt, sizeof(pkt));</p><p>+	wg_timers_event_handshake_initiated(peer);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_send_response(struct wg_peer *peer)</p><p>+{</p><p>+	struct wg_pkt_response pkt;</p><p>+</p><p>+	if (noise_create_response(peer-&gt;p_remote, &amp;pkt.s_idx, &amp;pkt.r_idx,</p><p>+	    pkt.ue, pkt.en) != 0)</p><p>+		return;</p><p>+</p><p>+	DPRINTF(peer-&gt;p_sc, &#34;Sending handshake response to peer %&#34; PRIu64 &#34;\n&#34;, peer-&gt;p_id);</p><p>+</p><p>+	wg_timers_event_session_derived(peer);</p><p>+	pkt.t = WG_PKT_RESPONSE;</p><p>+	cookie_maker_mac(&amp;peer-&gt;p_cookie, &amp;pkt.m, &amp;pkt,</p><p>+	     sizeof(pkt)-sizeof(pkt.m));</p><p>+	wg_peer_send_buf(peer, (uint8_t*)&amp;pkt, sizeof(pkt));</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_send_cookie(struct wg_softc *sc, struct cookie_macs *cm, uint32_t idx,</p><p>+    struct wg_endpoint *e)</p><p>+{</p><p>+	struct wg_pkt_cookie	pkt;</p><p>+</p><p>+	DPRINTF(sc, &#34;Sending cookie response for denied handshake message\n&#34;);</p><p>+</p><p>+	pkt.t = WG_PKT_COOKIE;</p><p>+	pkt.r_idx = idx;</p><p>+</p><p>+	cookie_checker_create_payload(&amp;sc-&gt;sc_cookie, cm, pkt.nonce,</p><p>+	    pkt.ec, &amp;e-&gt;e_remote.r_sa);</p><p>+	wg_send_buf(sc, e, (uint8_t *)&amp;pkt, sizeof(pkt));</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_send_keepalive(struct wg_peer *peer)</p><p>+{</p><p>+	struct wg_packet *pkt;</p><p>+	struct mbuf *m;</p><p>+</p><p>+	if (wg_queue_len(&amp;peer-&gt;p_stage_queue) &gt; 0)</p><p>+		goto send;</p><p>+	if ((m = m_gethdr(M_NOWAIT, MT_DATA)) == NULL)</p><p>+		return;</p><p>+	if ((pkt = wg_packet_alloc(m)) == NULL) {</p><p>+		m_freem(m);</p><p>+		return;</p><p>+	}</p><p>+	wg_queue_push_staged(&amp;peer-&gt;p_stage_queue, pkt);</p><p>+	DPRINTF(peer-&gt;p_sc, &#34;Sending keepalive packet to peer %&#34; PRIu64 &#34;\n&#34;, peer-&gt;p_id);</p><p>+send:</p><p>+	wg_peer_send_staged(peer);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_handshake(struct wg_softc *sc, struct wg_packet *pkt)</p><p>+{</p><p>+	struct wg_pkt_initiation	*init;</p><p>+	struct wg_pkt_response		*resp;</p><p>+	struct wg_pkt_cookie		*cook;</p><p>+	struct wg_endpoint		*e;</p><p>+	struct wg_peer			*peer;</p><p>+	struct mbuf			*m;</p><p>+	struct noise_remote		*remote = NULL;</p><p>+	int				 res;</p><p>+	bool				 underload = false;</p><p>+	static sbintime_t		 wg_last_underload; /* sbinuptime */</p><p>+</p><p>+	underload = wg_queue_len(&amp;sc-&gt;sc_handshake_queue) &gt;= MAX_QUEUED_HANDSHAKES / 8;</p><p>+	if (underload) {</p><p>+		wg_last_underload = getsbinuptime();</p><p>+	} else if (wg_last_underload) {</p><p>+		underload = wg_last_underload + UNDERLOAD_TIMEOUT * SBT_1S &gt; getsbinuptime();</p><p>+		if (!underload)</p><p>+			wg_last_underload = 0;</p><p>+	}</p><p>+</p><p>+	m = pkt-&gt;p_mbuf;</p><p>+	e = &amp;pkt-&gt;p_endpoint;</p><p>+</p><p>+	if ((pkt-&gt;p_mbuf = m = m_pullup(m, m-&gt;m_pkthdr.len)) == NULL)</p><p>+		goto error;</p><p>+</p><p>+	switch (*mtod(m, uint32_t *)) {</p><p>+	case WG_PKT_INITIATION:</p><p>+		init = mtod(m, struct wg_pkt_initiation *);</p><p>+</p><p>+		res = cookie_checker_validate_macs(&amp;sc-&gt;sc_cookie, &amp;init-&gt;m,</p><p>+				init, sizeof(*init) - sizeof(init-&gt;m),</p><p>+				underload, &amp;e-&gt;e_remote.r_sa,</p><p>+				sc-&gt;sc_ifp-&gt;if_vnet);</p><p>+</p><p>+		if (res == EINVAL) {</p><p>+			DPRINTF(sc, &#34;Invalid initiation MAC\n&#34;);</p><p>+			goto error;</p><p>+		} else if (res == ECONNREFUSED) {</p><p>+			DPRINTF(sc, &#34;Handshake ratelimited\n&#34;);</p><p>+			goto error;</p><p>+		} else if (res == EAGAIN) {</p><p>+			wg_send_cookie(sc, &amp;init-&gt;m, init-&gt;s_idx, e);</p><p>+			goto error;</p><p>+		} else if (res != 0) {</p><p>+			panic(&#34;unexpected response: %d\n&#34;, res);</p><p>+		}</p><p>+</p><p>+		if (noise_consume_initiation(sc-&gt;sc_local, &amp;remote,</p><p>+		    init-&gt;s_idx, init-&gt;ue, init-&gt;es, init-&gt;ets) != 0) {</p><p>+			DPRINTF(sc, &#34;Invalid handshake initiation\n&#34;);</p><p>+			goto error;</p><p>+		}</p><p>+</p><p>+		peer = noise_remote_arg(remote);</p><p>+</p><p>+		DPRINTF(sc, &#34;Receiving handshake initiation from peer %&#34; PRIu64 &#34;\n&#34;, peer-&gt;p_id);</p><p>+</p><p>+		wg_peer_set_endpoint(peer, e);</p><p>+		wg_send_response(peer);</p><p>+		break;</p><p>+	case WG_PKT_RESPONSE:</p><p>+		resp = mtod(m, struct wg_pkt_response *);</p><p>+</p><p>+		res = cookie_checker_validate_macs(&amp;sc-&gt;sc_cookie, &amp;resp-&gt;m,</p><p>+				resp, sizeof(*resp) - sizeof(resp-&gt;m),</p><p>+				underload, &amp;e-&gt;e_remote.r_sa,</p><p>+				sc-&gt;sc_ifp-&gt;if_vnet);</p><p>+</p><p>+		if (res == EINVAL) {</p><p>+			DPRINTF(sc, &#34;Invalid response MAC\n&#34;);</p><p>+			goto error;</p><p>+		} else if (res == ECONNREFUSED) {</p><p>+			DPRINTF(sc, &#34;Handshake ratelimited\n&#34;);</p><p>+			goto error;</p><p>+		} else if (res == EAGAIN) {</p><p>+			wg_send_cookie(sc, &amp;resp-&gt;m, resp-&gt;s_idx, e);</p><p>+			goto error;</p><p>+		} else if (res != 0) {</p><p>+			panic(&#34;unexpected response: %d\n&#34;, res);</p><p>+		}</p><p>+</p><p>+		if (noise_consume_response(sc-&gt;sc_local, &amp;remote,</p><p>+		    resp-&gt;s_idx, resp-&gt;r_idx, resp-&gt;ue, resp-&gt;en) != 0) {</p><p>+			DPRINTF(sc, &#34;Invalid handshake response\n&#34;);</p><p>+			goto error;</p><p>+		}</p><p>+</p><p>+		peer = noise_remote_arg(remote);</p><p>+		DPRINTF(sc, &#34;Receiving handshake response from peer %&#34; PRIu64 &#34;\n&#34;, peer-&gt;p_id);</p><p>+</p><p>+		wg_peer_set_endpoint(peer, e);</p><p>+		wg_timers_event_session_derived(peer);</p><p>+		wg_timers_event_handshake_complete(peer);</p><p>+		break;</p><p>+	case WG_PKT_COOKIE:</p><p>+		cook = mtod(m, struct wg_pkt_cookie *);</p><p>+</p><p>+		if ((remote = noise_remote_index(sc-&gt;sc_local, cook-&gt;r_idx)) == NULL) {</p><p>+			DPRINTF(sc, &#34;Unknown cookie index\n&#34;);</p><p>+			goto error;</p><p>+		}</p><p>+</p><p>+		peer = noise_remote_arg(remote);</p><p>+</p><p>+		if (cookie_maker_consume_payload(&amp;peer-&gt;p_cookie,</p><p>+		    cook-&gt;nonce, cook-&gt;ec) == 0) {</p><p>+			DPRINTF(sc, &#34;Receiving cookie response\n&#34;);</p><p>+		} else {</p><p>+			DPRINTF(sc, &#34;Could not decrypt cookie response\n&#34;);</p><p>+			goto error;</p><p>+		}</p><p>+</p><p>+		goto not_authenticated;</p><p>+	default:</p><p>+		panic(&#34;invalid packet in handshake queue&#34;);</p><p>+	}</p><p>+</p><p>+	wg_timers_event_any_authenticated_packet_received(peer);</p><p>+	wg_timers_event_any_authenticated_packet_traversal(peer);</p><p>+</p><p>+not_authenticated:</p><p>+	counter_u64_add(peer-&gt;p_rx_bytes, m-&gt;m_pkthdr.len);</p><p>+	if_inc_counter(sc-&gt;sc_ifp, IFCOUNTER_IPACKETS, 1);</p><p>+	if_inc_counter(sc-&gt;sc_ifp, IFCOUNTER_IBYTES, m-&gt;m_pkthdr.len);</p><p>+error:</p><p>+	if (remote != NULL)</p><p>+		noise_remote_put(remote);</p><p>+	wg_packet_free(pkt);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_softc_handshake_receive(struct wg_softc *sc)</p><p>+{</p><p>+	struct wg_packet *pkt;</p><p>+	while ((pkt = wg_queue_dequeue_handshake(&amp;sc-&gt;sc_handshake_queue)) != NULL)</p><p>+		wg_handshake(sc, pkt);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_mbuf_reset(struct mbuf *m)</p><p>+{</p><p>+</p><p>+	struct m_tag *t, *tmp;</p><p>+</p><p>+	/*</p><p>+	 * We want to reset the mbuf to a newly allocated state, containing</p><p>+	 * just the packet contents. Unfortunately FreeBSD doesn&#39;t seem to</p><p>+	 * offer this anywhere, so we have to make it up as we go. If we can</p><p>+	 * get this in kern/kern_mbuf.c, that would be best.</p><p>+	 *</p><p>+	 * Notice: this may break things unexpectedly but it is better to fail</p><p>+	 *         closed in the extreme case than leak informtion in every</p><p>+	 *         case.</p><p>+	 *</p><p>+	 * With that said, all this attempts to do is remove any extraneous</p><p>+	 * information that could be present.</p><p>+	 */</p><p>+</p><p>+	M_ASSERTPKTHDR(m);</p><p>+</p><p>+	m-&gt;m_flags &amp;= ~(M_BCAST|M_MCAST|M_VLANTAG|M_PROMISC|M_PROTOFLAGS);</p><p>+</p><p>+	M_HASHTYPE_CLEAR(m);</p><p>+#ifdef NUMA</p><p>+        m-&gt;m_pkthdr.numa_domain = M_NODOM;</p><p>+#endif</p><p>+	SLIST_FOREACH_SAFE(t, &amp;m-&gt;m_pkthdr.tags, m_tag_link, tmp) {</p><p>+		if ((t-&gt;m_tag_id != 0 || t-&gt;m_tag_cookie != MTAG_WGLOOP) &amp;&amp;</p><p>+		    t-&gt;m_tag_id != PACKET_TAG_MACLABEL)</p><p>+			m_tag_delete(m, t);</p><p>+	}</p><p>+</p><p>+	KASSERT((m-&gt;m_pkthdr.csum_flags &amp; CSUM_SND_TAG) == 0,</p><p>+	    (&#34;%s: mbuf %p has a send tag&#34;, __func__, m));</p><p>+</p><p>+	m-&gt;m_pkthdr.csum_flags = 0;</p><p>+	m-&gt;m_pkthdr.PH_per.sixtyfour[0] = 0;</p><p>+	m-&gt;m_pkthdr.PH_loc.sixtyfour[0] = 0;</p><p>+}</p><p>+</p><p>+static inline unsigned int</p><p>+calculate_padding(struct wg_packet *pkt)</p><p>+{</p><p>+	unsigned int padded_size, last_unit = pkt-&gt;p_mbuf-&gt;m_pkthdr.len;</p><p>+</p><p>+	if (__predict_false(!pkt-&gt;p_mtu))</p><p>+		return (last_unit + (WG_PKT_PADDING - 1)) &amp; ~(WG_PKT_PADDING - 1);</p><p>+</p><p>+	if (__predict_false(last_unit &gt; pkt-&gt;p_mtu))</p><p>+		last_unit %= pkt-&gt;p_mtu;</p><p>+</p><p>+	padded_size = (last_unit + (WG_PKT_PADDING - 1)) &amp; ~(WG_PKT_PADDING - 1);</p><p>+	if (pkt-&gt;p_mtu &lt; padded_size)</p><p>+		padded_size = pkt-&gt;p_mtu;</p><p>+	return padded_size - last_unit;</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_encrypt(struct wg_softc *sc, struct wg_packet *pkt)</p><p>+{</p><p>+	static const uint8_t	 padding[WG_PKT_PADDING] = { 0 };</p><p>+	struct wg_pkt_data	*data;</p><p>+	struct wg_peer		*peer;</p><p>+	struct noise_remote	*remote;</p><p>+	struct mbuf		*m;</p><p>+	uint32_t		 idx;</p><p>+	unsigned int		 padlen;</p><p>+	enum wg_ring_state	 state = WG_PACKET_DEAD;</p><p>+</p><p>+	remote = noise_keypair_remote(pkt-&gt;p_keypair);</p><p>+	peer = noise_remote_arg(remote);</p><p>+	m = pkt-&gt;p_mbuf;</p><p>+</p><p>+	/* Pad the packet */</p><p>+	padlen = calculate_padding(pkt);</p><p>+	if (padlen != 0 &amp;&amp; !m_append(m, padlen, padding))</p><p>+		goto out;</p><p>+</p><p>+	/* Do encryption */</p><p>+	if (noise_keypair_encrypt(pkt-&gt;p_keypair, &amp;idx, pkt-&gt;p_nonce, m) != 0)</p><p>+		goto out;</p><p>+</p><p>+	/* Put header into packet */</p><p>+	M_PREPEND(m, sizeof(struct wg_pkt_data), M_NOWAIT);</p><p>+	if (m == NULL)</p><p>+		goto out;</p><p>+	data = mtod(m, struct wg_pkt_data *);</p><p>+	data-&gt;t = WG_PKT_DATA;</p><p>+	data-&gt;r_idx = idx;</p><p>+	data-&gt;nonce = htole64(pkt-&gt;p_nonce);</p><p>+</p><p>+	wg_mbuf_reset(m);</p><p>+	state = WG_PACKET_CRYPTED;</p><p>+out:</p><p>+	pkt-&gt;p_mbuf = m;</p><p>+	wmb();</p><p>+	pkt-&gt;p_state = state;</p><p>+	GROUPTASK_ENQUEUE(&amp;peer-&gt;p_send);</p><p>+	noise_remote_put(remote);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_decrypt(struct wg_softc *sc, struct wg_packet *pkt)</p><p>+{</p><p>+	struct wg_peer		*peer, *allowed_peer;</p><p>+	struct noise_remote	*remote;</p><p>+	struct mbuf		*m;</p><p>+	int			 len;</p><p>+	enum wg_ring_state	 state = WG_PACKET_DEAD;</p><p>+</p><p>+	remote = noise_keypair_remote(pkt-&gt;p_keypair);</p><p>+	peer = noise_remote_arg(remote);</p><p>+	m = pkt-&gt;p_mbuf;</p><p>+</p><p>+	/* Read nonce and then adjust to remove the header. */</p><p>+	pkt-&gt;p_nonce = le64toh(mtod(m, struct wg_pkt_data *)-&gt;nonce);</p><p>+	m_adj(m, sizeof(struct wg_pkt_data));</p><p>+</p><p>+	if (noise_keypair_decrypt(pkt-&gt;p_keypair, pkt-&gt;p_nonce, m) != 0)</p><p>+		goto out;</p><p>+</p><p>+	/* A packet with length 0 is a keepalive packet */</p><p>+	if (__predict_false(m-&gt;m_pkthdr.len == 0)) {</p><p>+		DPRINTF(sc, &#34;Receiving keepalive packet from peer &#34;</p><p>+		    &#34;%&#34; PRIu64 &#34;\n&#34;, peer-&gt;p_id);</p><p>+		state = WG_PACKET_CRYPTED;</p><p>+		goto out;</p><p>+	}</p><p>+</p><p>+	/*</p><p>+	 * We can let the network stack handle the intricate validation of the</p><p>+	 * IP header, we just worry about the sizeof and the version, so we can</p><p>+	 * read the source address in wg_aip_lookup.</p><p>+	 */</p><p>+</p><p>+	if (determine_af_and_pullup(&amp;m, &amp;pkt-&gt;p_af) == 0) {</p><p>+		if (pkt-&gt;p_af == AF_INET) {</p><p>+			struct ip *ip = mtod(m, struct ip *);</p><p>+			allowed_peer = wg_aip_lookup(sc, AF_INET, &amp;ip-&gt;ip_src);</p><p>+			len = ntohs(ip-&gt;ip_len);</p><p>+			if (len &gt;= sizeof(struct ip) &amp;&amp; len &lt; m-&gt;m_pkthdr.len)</p><p>+				m_adj(m, len - m-&gt;m_pkthdr.len);</p><p>+		} else if (pkt-&gt;p_af == AF_INET6) {</p><p>+			struct ip6_hdr *ip6 = mtod(m, struct ip6_hdr *);</p><p>+			allowed_peer = wg_aip_lookup(sc, AF_INET6, &amp;ip6-&gt;ip6_src);</p><p>+			len = ntohs(ip6-&gt;ip6_plen) + sizeof(struct ip6_hdr);</p><p>+			if (len &lt; m-&gt;m_pkthdr.len)</p><p>+				m_adj(m, len - m-&gt;m_pkthdr.len);</p><p>+		} else</p><p>+			panic(&#34;determine_af_and_pullup returned unexpected value&#34;);</p><p>+	} else {</p><p>+		DPRINTF(sc, &#34;Packet is neither ipv4 nor ipv6 from peer %&#34; PRIu64 &#34;\n&#34;, peer-&gt;p_id);</p><p>+		goto out;</p><p>+	}</p><p>+</p><p>+	/* We only want to compare the address, not dereference, so drop the ref. */</p><p>+	if (allowed_peer != NULL)</p><p>+		noise_remote_put(allowed_peer-&gt;p_remote);</p><p>+</p><p>+	if (__predict_false(peer != allowed_peer)) {</p><p>+		DPRINTF(sc, &#34;Packet has unallowed src IP from peer %&#34; PRIu64 &#34;\n&#34;, peer-&gt;p_id);</p><p>+		goto out;</p><p>+	}</p><p>+</p><p>+	wg_mbuf_reset(m);</p><p>+	state = WG_PACKET_CRYPTED;</p><p>+out:</p><p>+	pkt-&gt;p_mbuf = m;</p><p>+	wmb();</p><p>+	pkt-&gt;p_state = state;</p><p>+	GROUPTASK_ENQUEUE(&amp;peer-&gt;p_recv);</p><p>+	noise_remote_put(remote);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_softc_decrypt(struct wg_softc *sc)</p><p>+{</p><p>+	struct wg_packet *pkt;</p><p>+</p><p>+	while ((pkt = wg_queue_dequeue_parallel(&amp;sc-&gt;sc_decrypt_parallel)) != NULL)</p><p>+		wg_decrypt(sc, pkt);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_softc_encrypt(struct wg_softc *sc)</p><p>+{</p><p>+	struct wg_packet *pkt;</p><p>+</p><p>+	while ((pkt = wg_queue_dequeue_parallel(&amp;sc-&gt;sc_encrypt_parallel)) != NULL)</p><p>+		wg_encrypt(sc, pkt);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_encrypt_dispatch(struct wg_softc *sc)</p><p>+{</p><p>+	/*</p><p>+	 * The update to encrypt_last_cpu is racey such that we may</p><p>+	 * reschedule the task for the same CPU multiple times, but</p><p>+	 * the race doesn&#39;t really matter.</p><p>+	 */</p><p>+	u_int cpu = (sc-&gt;sc_encrypt_last_cpu + 1) % mp_ncpus;</p><p>+	sc-&gt;sc_encrypt_last_cpu = cpu;</p><p>+	GROUPTASK_ENQUEUE(&amp;sc-&gt;sc_encrypt[cpu]);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_decrypt_dispatch(struct wg_softc *sc)</p><p>+{</p><p>+	u_int cpu = (sc-&gt;sc_decrypt_last_cpu + 1) % mp_ncpus;</p><p>+	sc-&gt;sc_decrypt_last_cpu = cpu;</p><p>+	GROUPTASK_ENQUEUE(&amp;sc-&gt;sc_decrypt[cpu]);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_deliver_out(struct wg_peer *peer)</p><p>+{</p><p>+	struct wg_endpoint	 endpoint;</p><p>+	struct wg_softc		*sc = peer-&gt;p_sc;</p><p>+	struct wg_packet	*pkt;</p><p>+	struct mbuf		*m;</p><p>+	int			 rc, len;</p><p>+</p><p>+	wg_peer_get_endpoint(peer, &amp;endpoint);</p><p>+</p><p>+	while ((pkt = wg_queue_dequeue_serial(&amp;peer-&gt;p_encrypt_serial)) != NULL) {</p><p>+		if (pkt-&gt;p_state != WG_PACKET_CRYPTED)</p><p>+			goto error;</p><p>+</p><p>+		m = pkt-&gt;p_mbuf;</p><p>+		pkt-&gt;p_mbuf = NULL;</p><p>+</p><p>+		len = m-&gt;m_pkthdr.len;</p><p>+</p><p>+		wg_timers_event_any_authenticated_packet_traversal(peer);</p><p>+		wg_timers_event_any_authenticated_packet_sent(peer);</p><p>+		rc = wg_send(sc, &amp;endpoint, m);</p><p>+		if (rc == 0) {</p><p>+			if (len &gt; (sizeof(struct wg_pkt_data) + NOISE_AUTHTAG_LEN))</p><p>+				wg_timers_event_data_sent(peer);</p><p>+			counter_u64_add(peer-&gt;p_tx_bytes, len);</p><p>+		} else if (rc == EADDRNOTAVAIL) {</p><p>+			wg_peer_clear_src(peer);</p><p>+			wg_peer_get_endpoint(peer, &amp;endpoint);</p><p>+			goto error;</p><p>+		} else {</p><p>+			goto error;</p><p>+		}</p><p>+		wg_packet_free(pkt);</p><p>+		if (noise_keep_key_fresh_send(peer-&gt;p_remote))</p><p>+			wg_timers_event_want_initiation(peer);</p><p>+		continue;</p><p>+error:</p><p>+		if_inc_counter(sc-&gt;sc_ifp, IFCOUNTER_OERRORS, 1);</p><p>+		wg_packet_free(pkt);</p><p>+	}</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_deliver_in(struct wg_peer *peer)</p><p>+{</p><p>+	struct wg_softc		*sc = peer-&gt;p_sc;</p><p>+	struct ifnet		*ifp = sc-&gt;sc_ifp;</p><p>+	struct wg_packet	*pkt;</p><p>+	struct mbuf		*m;</p><p>+	struct epoch_tracker	 et;</p><p>+</p><p>+	while ((pkt = wg_queue_dequeue_serial(&amp;peer-&gt;p_decrypt_serial)) != NULL) {</p><p>+		if (pkt-&gt;p_state != WG_PACKET_CRYPTED)</p><p>+			goto error;</p><p>+</p><p>+		m = pkt-&gt;p_mbuf;</p><p>+		if (noise_keypair_nonce_check(pkt-&gt;p_keypair, pkt-&gt;p_nonce) != 0)</p><p>+			goto error;</p><p>+</p><p>+		if (noise_keypair_received_with(pkt-&gt;p_keypair) == ECONNRESET)</p><p>+			wg_timers_event_handshake_complete(peer);</p><p>+</p><p>+		wg_timers_event_any_authenticated_packet_received(peer);</p><p>+		wg_timers_event_any_authenticated_packet_traversal(peer);</p><p>+		wg_peer_set_endpoint(peer, &amp;pkt-&gt;p_endpoint);</p><p>+</p><p>+		counter_u64_add(peer-&gt;p_rx_bytes, m-&gt;m_pkthdr.len +</p><p>+		    sizeof(struct wg_pkt_data) + NOISE_AUTHTAG_LEN);</p><p>+		if_inc_counter(sc-&gt;sc_ifp, IFCOUNTER_IPACKETS, 1);</p><p>+		if_inc_counter(sc-&gt;sc_ifp, IFCOUNTER_IBYTES, m-&gt;m_pkthdr.len +</p><p>+		    sizeof(struct wg_pkt_data) + NOISE_AUTHTAG_LEN);</p><p>+</p><p>+		if (m-&gt;m_pkthdr.len == 0)</p><p>+			goto done;</p><p>+</p><p>+		MPASS(pkt-&gt;p_af == AF_INET || pkt-&gt;p_af == AF_INET6);</p><p>+		pkt-&gt;p_mbuf = NULL;</p><p>+</p><p>+		m-&gt;m_pkthdr.rcvif = ifp;</p><p>+</p><p>+		NET_EPOCH_ENTER(et);</p><p>+		BPF_MTAP2_AF(ifp, m, pkt-&gt;p_af);</p><p>+</p><p>+		CURVNET_SET(ifp-&gt;if_vnet);</p><p>+		M_SETFIB(m, ifp-&gt;if_fib);</p><p>+		if (pkt-&gt;p_af == AF_INET)</p><p>+			netisr_dispatch(NETISR_IP, m);</p><p>+		if (pkt-&gt;p_af == AF_INET6)</p><p>+			netisr_dispatch(NETISR_IPV6, m);</p><p>+		CURVNET_RESTORE();</p><p>+		NET_EPOCH_EXIT(et);</p><p>+</p><p>+		wg_timers_event_data_received(peer);</p><p>+</p><p>+done:</p><p>+		if (noise_keep_key_fresh_recv(peer-&gt;p_remote))</p><p>+			wg_timers_event_want_initiation(peer);</p><p>+		wg_packet_free(pkt);</p><p>+		continue;</p><p>+error:</p><p>+		if_inc_counter(ifp, IFCOUNTER_IERRORS, 1);</p><p>+		wg_packet_free(pkt);</p><p>+	}</p><p>+}</p><p>+</p><p>+static struct wg_packet *</p><p>+wg_packet_alloc(struct mbuf *m)</p><p>+{</p><p>+	struct wg_packet *pkt;</p><p>+</p><p>+	if ((pkt = uma_zalloc(wg_packet_zone, M_NOWAIT | M_ZERO)) == NULL)</p><p>+		return (NULL);</p><p>+	pkt-&gt;p_mbuf = m;</p><p>+	return (pkt);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_packet_free(struct wg_packet *pkt)</p><p>+{</p><p>+	if (pkt-&gt;p_keypair != NULL)</p><p>+		noise_keypair_put(pkt-&gt;p_keypair);</p><p>+	if (pkt-&gt;p_mbuf != NULL)</p><p>+		m_freem(pkt-&gt;p_mbuf);</p><p>+	uma_zfree(wg_packet_zone, pkt);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_queue_init(struct wg_queue *queue, const char *name)</p><p>+{</p><p>+	mtx_init(&amp;queue-&gt;q_mtx, name, NULL, MTX_DEF);</p><p>+	STAILQ_INIT(&amp;queue-&gt;q_queue);</p><p>+	queue-&gt;q_len = 0;</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_queue_deinit(struct wg_queue *queue)</p><p>+{</p><p>+	wg_queue_purge(queue);</p><p>+	mtx_destroy(&amp;queue-&gt;q_mtx);</p><p>+}</p><p>+</p><p>+static size_t</p><p>+wg_queue_len(struct wg_queue *queue)</p><p>+{</p><p>+	return (queue-&gt;q_len);</p><p>+}</p><p>+</p><p>+static int</p><p>+wg_queue_enqueue_handshake(struct wg_queue *hs, struct wg_packet *pkt)</p><p>+{</p><p>+	int ret = 0;</p><p>+	mtx_lock(&amp;hs-&gt;q_mtx);</p><p>+	if (hs-&gt;q_len &lt; MAX_QUEUED_HANDSHAKES) {</p><p>+		STAILQ_INSERT_TAIL(&amp;hs-&gt;q_queue, pkt, p_parallel);</p><p>+		hs-&gt;q_len++;</p><p>+	} else {</p><p>+		ret = ENOBUFS;</p><p>+	}</p><p>+	mtx_unlock(&amp;hs-&gt;q_mtx);</p><p>+	if (ret != 0)</p><p>+		wg_packet_free(pkt);</p><p>+	return (ret);</p><p>+}</p><p>+</p><p>+static struct wg_packet *</p><p>+wg_queue_dequeue_handshake(struct wg_queue *hs)</p><p>+{</p><p>+	struct wg_packet *pkt;</p><p>+	mtx_lock(&amp;hs-&gt;q_mtx);</p><p>+	if ((pkt = STAILQ_FIRST(&amp;hs-&gt;q_queue)) != NULL) {</p><p>+		STAILQ_REMOVE_HEAD(&amp;hs-&gt;q_queue, p_parallel);</p><p>+		hs-&gt;q_len--;</p><p>+	}</p><p>+	mtx_unlock(&amp;hs-&gt;q_mtx);</p><p>+	return (pkt);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_queue_push_staged(struct wg_queue *staged, struct wg_packet *pkt)</p><p>+{</p><p>+	struct wg_packet *old = NULL;</p><p>+</p><p>+	mtx_lock(&amp;staged-&gt;q_mtx);</p><p>+	if (staged-&gt;q_len &gt;= MAX_STAGED_PKT) {</p><p>+		old = STAILQ_FIRST(&amp;staged-&gt;q_queue);</p><p>+		STAILQ_REMOVE_HEAD(&amp;staged-&gt;q_queue, p_parallel);</p><p>+		staged-&gt;q_len--;</p><p>+	}</p><p>+	STAILQ_INSERT_TAIL(&amp;staged-&gt;q_queue, pkt, p_parallel);</p><p>+	staged-&gt;q_len++;</p><p>+	mtx_unlock(&amp;staged-&gt;q_mtx);</p><p>+</p><p>+	if (old != NULL)</p><p>+		wg_packet_free(old);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_queue_enlist_staged(struct wg_queue *staged, struct wg_packet_list *list)</p><p>+{</p><p>+	struct wg_packet *pkt, *tpkt;</p><p>+	STAILQ_FOREACH_SAFE(pkt, list, p_parallel, tpkt)</p><p>+		wg_queue_push_staged(staged, pkt);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_queue_delist_staged(struct wg_queue *staged, struct wg_packet_list *list)</p><p>+{</p><p>+	STAILQ_INIT(list);</p><p>+	mtx_lock(&amp;staged-&gt;q_mtx);</p><p>+	STAILQ_CONCAT(list, &amp;staged-&gt;q_queue);</p><p>+	staged-&gt;q_len = 0;</p><p>+	mtx_unlock(&amp;staged-&gt;q_mtx);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_queue_purge(struct wg_queue *staged)</p><p>+{</p><p>+	struct wg_packet_list list;</p><p>+	struct wg_packet *pkt, *tpkt;</p><p>+	wg_queue_delist_staged(staged, &amp;list);</p><p>+	STAILQ_FOREACH_SAFE(pkt, &amp;list, p_parallel, tpkt)</p><p>+		wg_packet_free(pkt);</p><p>+}</p><p>+</p><p>+static int</p><p>+wg_queue_both(struct wg_queue *parallel, struct wg_queue *serial, struct wg_packet *pkt)</p><p>+{</p><p>+	pkt-&gt;p_state = WG_PACKET_UNCRYPTED;</p><p>+</p><p>+	mtx_lock(&amp;serial-&gt;q_mtx);</p><p>+	if (serial-&gt;q_len &lt; MAX_QUEUED_PKT) {</p><p>+		serial-&gt;q_len++;</p><p>+		STAILQ_INSERT_TAIL(&amp;serial-&gt;q_queue, pkt, p_serial);</p><p>+	} else {</p><p>+		mtx_unlock(&amp;serial-&gt;q_mtx);</p><p>+		wg_packet_free(pkt);</p><p>+		return (ENOBUFS);</p><p>+	}</p><p>+	mtx_unlock(&amp;serial-&gt;q_mtx);</p><p>+</p><p>+	mtx_lock(&amp;parallel-&gt;q_mtx);</p><p>+	if (parallel-&gt;q_len &lt; MAX_QUEUED_PKT) {</p><p>+		parallel-&gt;q_len++;</p><p>+		STAILQ_INSERT_TAIL(&amp;parallel-&gt;q_queue, pkt, p_parallel);</p><p>+	} else {</p><p>+		mtx_unlock(&amp;parallel-&gt;q_mtx);</p><p>+		pkt-&gt;p_state = WG_PACKET_DEAD;</p><p>+		return (ENOBUFS);</p><p>+	}</p><p>+	mtx_unlock(&amp;parallel-&gt;q_mtx);</p><p>+</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+static struct wg_packet *</p><p>+wg_queue_dequeue_serial(struct wg_queue *serial)</p><p>+{</p><p>+	struct wg_packet *pkt = NULL;</p><p>+	mtx_lock(&amp;serial-&gt;q_mtx);</p><p>+	if (serial-&gt;q_len &gt; 0 &amp;&amp; STAILQ_FIRST(&amp;serial-&gt;q_queue)-&gt;p_state != WG_PACKET_UNCRYPTED) {</p><p>+		serial-&gt;q_len--;</p><p>+		pkt = STAILQ_FIRST(&amp;serial-&gt;q_queue);</p><p>+		STAILQ_REMOVE_HEAD(&amp;serial-&gt;q_queue, p_serial);</p><p>+	}</p><p>+	mtx_unlock(&amp;serial-&gt;q_mtx);</p><p>+	return (pkt);</p><p>+}</p><p>+</p><p>+static struct wg_packet *</p><p>+wg_queue_dequeue_parallel(struct wg_queue *parallel)</p><p>+{</p><p>+	struct wg_packet *pkt = NULL;</p><p>+	mtx_lock(&amp;parallel-&gt;q_mtx);</p><p>+	if (parallel-&gt;q_len &gt; 0) {</p><p>+		parallel-&gt;q_len--;</p><p>+		pkt = STAILQ_FIRST(&amp;parallel-&gt;q_queue);</p><p>+		STAILQ_REMOVE_HEAD(&amp;parallel-&gt;q_queue, p_parallel);</p><p>+	}</p><p>+	mtx_unlock(&amp;parallel-&gt;q_mtx);</p><p>+	return (pkt);</p><p>+}</p><p>+</p><p>+static bool</p><p>+wg_input(struct mbuf *m, int offset, struct inpcb *inpcb,</p><p>+    const struct sockaddr *sa, void *_sc)</p><p>+{</p><p>+#ifdef INET</p><p>+	const struct sockaddr_in	*sin;</p><p>+#endif</p><p>+#ifdef INET6</p><p>+	const struct sockaddr_in6	*sin6;</p><p>+#endif</p><p>+	struct noise_remote		*remote;</p><p>+	struct wg_pkt_data		*data;</p><p>+	struct wg_packet		*pkt;</p><p>+	struct wg_peer			*peer;</p><p>+	struct wg_softc			*sc = _sc;</p><p>+	struct mbuf			*defragged;</p><p>+</p><p>+	defragged = m_defrag(m, M_NOWAIT);</p><p>+	if (defragged)</p><p>+		m = defragged;</p><p>+	m = m_unshare(m, M_NOWAIT);</p><p>+	if (!m) {</p><p>+		if_inc_counter(sc-&gt;sc_ifp, IFCOUNTER_IQDROPS, 1);</p><p>+		return true;</p><p>+	}</p><p>+</p><p>+	/* Caller provided us with `sa`, no need for this header. */</p><p>+	m_adj(m, offset + sizeof(struct udphdr));</p><p>+</p><p>+	/* Pullup enough to read packet type */</p><p>+	if ((m = m_pullup(m, sizeof(uint32_t))) == NULL) {</p><p>+		if_inc_counter(sc-&gt;sc_ifp, IFCOUNTER_IQDROPS, 1);</p><p>+		return true;</p><p>+	}</p><p>+</p><p>+	if ((pkt = wg_packet_alloc(m)) == NULL) {</p><p>+		if_inc_counter(sc-&gt;sc_ifp, IFCOUNTER_IQDROPS, 1);</p><p>+		m_freem(m);</p><p>+		return true;</p><p>+	}</p><p>+</p><p>+	/* Save send/recv address and port for later. */</p><p>+	switch (sa-&gt;sa_family) {</p><p>+#ifdef INET</p><p>+	case AF_INET:</p><p>+		sin = (const struct sockaddr_in *)sa;</p><p>+		pkt-&gt;p_endpoint.e_remote.r_sin = sin[0];</p><p>+		pkt-&gt;p_endpoint.e_local.l_in = sin[1].sin_addr;</p><p>+		break;</p><p>+#endif</p><p>+#ifdef INET6</p><p>+	case AF_INET6:</p><p>+		sin6 = (const struct sockaddr_in6 *)sa;</p><p>+		pkt-&gt;p_endpoint.e_remote.r_sin6 = sin6[0];</p><p>+		pkt-&gt;p_endpoint.e_local.l_in6 = sin6[1].sin6_addr;</p><p>+		break;</p><p>+#endif</p><p>+	default:</p><p>+		goto error;</p><p>+	}</p><p>+</p><p>+	if ((m-&gt;m_pkthdr.len == sizeof(struct wg_pkt_initiation) &amp;&amp;</p><p>+		*mtod(m, uint32_t *) == WG_PKT_INITIATION) ||</p><p>+	    (m-&gt;m_pkthdr.len == sizeof(struct wg_pkt_response) &amp;&amp;</p><p>+		*mtod(m, uint32_t *) == WG_PKT_RESPONSE) ||</p><p>+	    (m-&gt;m_pkthdr.len == sizeof(struct wg_pkt_cookie) &amp;&amp;</p><p>+		*mtod(m, uint32_t *) == WG_PKT_COOKIE)) {</p><p>+</p><p>+		if (wg_queue_enqueue_handshake(&amp;sc-&gt;sc_handshake_queue, pkt) != 0) {</p><p>+			if_inc_counter(sc-&gt;sc_ifp, IFCOUNTER_IQDROPS, 1);</p><p>+			DPRINTF(sc, &#34;Dropping handshake packet\n&#34;);</p><p>+		}</p><p>+		GROUPTASK_ENQUEUE(&amp;sc-&gt;sc_handshake);</p><p>+	} else if (m-&gt;m_pkthdr.len &gt;= sizeof(struct wg_pkt_data) +</p><p>+	    NOISE_AUTHTAG_LEN &amp;&amp; *mtod(m, uint32_t *) == WG_PKT_DATA) {</p><p>+</p><p>+		/* Pullup whole header to read r_idx below. */</p><p>+		if ((pkt-&gt;p_mbuf = m_pullup(m, sizeof(struct wg_pkt_data))) == NULL)</p><p>+			goto error;</p><p>+</p><p>+		data = mtod(pkt-&gt;p_mbuf, struct wg_pkt_data *);</p><p>+		if ((pkt-&gt;p_keypair = noise_keypair_lookup(sc-&gt;sc_local, data-&gt;r_idx)) == NULL)</p><p>+			goto error;</p><p>+</p><p>+		remote = noise_keypair_remote(pkt-&gt;p_keypair);</p><p>+		peer = noise_remote_arg(remote);</p><p>+		if (wg_queue_both(&amp;sc-&gt;sc_decrypt_parallel, &amp;peer-&gt;p_decrypt_serial, pkt) != 0)</p><p>+			if_inc_counter(sc-&gt;sc_ifp, IFCOUNTER_IQDROPS, 1);</p><p>+		wg_decrypt_dispatch(sc);</p><p>+		noise_remote_put(remote);</p><p>+	} else {</p><p>+		goto error;</p><p>+	}</p><p>+	return true;</p><p>+error:</p><p>+	if_inc_counter(sc-&gt;sc_ifp, IFCOUNTER_IERRORS, 1);</p><p>+	wg_packet_free(pkt);</p><p>+	return true;</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_peer_send_staged(struct wg_peer *peer)</p><p>+{</p><p>+	struct wg_packet_list	 list;</p><p>+	struct noise_keypair	*keypair;</p><p>+	struct wg_packet	*pkt, *tpkt;</p><p>+	struct wg_softc		*sc = peer-&gt;p_sc;</p><p>+</p><p>+	wg_queue_delist_staged(&amp;peer-&gt;p_stage_queue, &amp;list);</p><p>+</p><p>+	if (STAILQ_EMPTY(&amp;list))</p><p>+		return;</p><p>+</p><p>+	if ((keypair = noise_keypair_current(peer-&gt;p_remote)) == NULL)</p><p>+		goto error;</p><p>+</p><p>+	STAILQ_FOREACH(pkt, &amp;list, p_parallel) {</p><p>+		if (noise_keypair_nonce_next(keypair, &amp;pkt-&gt;p_nonce) != 0)</p><p>+			goto error_keypair;</p><p>+	}</p><p>+	STAILQ_FOREACH_SAFE(pkt, &amp;list, p_parallel, tpkt) {</p><p>+		pkt-&gt;p_keypair = noise_keypair_ref(keypair);</p><p>+		if (wg_queue_both(&amp;sc-&gt;sc_encrypt_parallel, &amp;peer-&gt;p_encrypt_serial, pkt) != 0)</p><p>+			if_inc_counter(sc-&gt;sc_ifp, IFCOUNTER_OQDROPS, 1);</p><p>+	}</p><p>+	wg_encrypt_dispatch(sc);</p><p>+	noise_keypair_put(keypair);</p><p>+	return;</p><p>+</p><p>+error_keypair:</p><p>+	noise_keypair_put(keypair);</p><p>+error:</p><p>+	wg_queue_enlist_staged(&amp;peer-&gt;p_stage_queue, &amp;list);</p><p>+	wg_timers_event_want_initiation(peer);</p><p>+}</p><p>+</p><p>+static inline void</p><p>+xmit_err(struct ifnet *ifp, struct mbuf *m, struct wg_packet *pkt, sa_family_t af)</p><p>+{</p><p>+	if_inc_counter(ifp, IFCOUNTER_OERRORS, 1);</p><p>+	switch (af) {</p><p>+#ifdef INET</p><p>+	case AF_INET:</p><p>+		icmp_error(m, ICMP_UNREACH, ICMP_UNREACH_HOST, 0, 0);</p><p>+		if (pkt)</p><p>+			pkt-&gt;p_mbuf = NULL;</p><p>+		m = NULL;</p><p>+		break;</p><p>+#endif</p><p>+#ifdef INET6</p><p>+	case AF_INET6:</p><p>+		icmp6_error(m, ICMP6_DST_UNREACH, 0, 0);</p><p>+		if (pkt)</p><p>+			pkt-&gt;p_mbuf = NULL;</p><p>+		m = NULL;</p><p>+		break;</p><p>+#endif</p><p>+	}</p><p>+	if (pkt)</p><p>+		wg_packet_free(pkt);</p><p>+	else if (m)</p><p>+		m_freem(m);</p><p>+}</p><p>+</p><p>+static int</p><p>+wg_xmit(struct ifnet *ifp, struct mbuf *m, sa_family_t af, uint32_t mtu)</p><p>+{</p><p>+	struct wg_packet	*pkt = NULL;</p><p>+	struct wg_softc		*sc = ifp-&gt;if_softc;</p><p>+	struct wg_peer		*peer;</p><p>+	int			 rc = 0;</p><p>+	sa_family_t		 peer_af;</p><p>+</p><p>+	/* Work around lifetime issue in the ipv6 mld code. */</p><p>+	if (__predict_false((ifp-&gt;if_flags &amp; IFF_DYING) || !sc)) {</p><p>+		rc = ENXIO;</p><p>+		goto err_xmit;</p><p>+	}</p><p>+</p><p>+	if ((pkt = wg_packet_alloc(m)) == NULL) {</p><p>+		rc = ENOBUFS;</p><p>+		goto err_xmit;</p><p>+	}</p><p>+	pkt-&gt;p_mtu = mtu;</p><p>+	pkt-&gt;p_af = af;</p><p>+</p><p>+	if (af == AF_INET) {</p><p>+		peer = wg_aip_lookup(sc, AF_INET, &amp;mtod(m, struct ip *)-&gt;ip_dst);</p><p>+	} else if (af == AF_INET6) {</p><p>+		peer = wg_aip_lookup(sc, AF_INET6, &amp;mtod(m, struct ip6_hdr *)-&gt;ip6_dst);</p><p>+	} else {</p><p>+		rc = EAFNOSUPPORT;</p><p>+		goto err_xmit;</p><p>+	}</p><p>+</p><p>+	BPF_MTAP2_AF(ifp, m, pkt-&gt;p_af);</p><p>+</p><p>+	if (__predict_false(peer == NULL)) {</p><p>+		rc = ENOKEY;</p><p>+		goto err_xmit;</p><p>+	}</p><p>+</p><p>+	if (__predict_false(if_tunnel_check_nesting(ifp, m, MTAG_WGLOOP, MAX_LOOPS))) {</p><p>+		DPRINTF(sc, &#34;Packet looped&#34;);</p><p>+		rc = ELOOP;</p><p>+		goto err_peer;</p><p>+	}</p><p>+</p><p>+	peer_af = peer-&gt;p_endpoint.e_remote.r_sa.sa_family;</p><p>+	if (__predict_false(peer_af != AF_INET &amp;&amp; peer_af != AF_INET6)) {</p><p>+		DPRINTF(sc, &#34;No valid endpoint has been configured or &#34;</p><p>+			    &#34;discovered for peer %&#34; PRIu64 &#34;\n&#34;, peer-&gt;p_id);</p><p>+		rc = EHOSTUNREACH;</p><p>+		goto err_peer;</p><p>+	}</p><p>+</p><p>+	wg_queue_push_staged(&amp;peer-&gt;p_stage_queue, pkt);</p><p>+	wg_peer_send_staged(peer);</p><p>+	noise_remote_put(peer-&gt;p_remote);</p><p>+	return (0);</p><p>+</p><p>+err_peer:</p><p>+	noise_remote_put(peer-&gt;p_remote);</p><p>+err_xmit:</p><p>+	xmit_err(ifp, m, pkt, af);</p><p>+	return (rc);</p><p>+}</p><p>+</p><p>+static inline int</p><p>+determine_af_and_pullup(struct mbuf **m, sa_family_t *af)</p><p>+{</p><p>+	u_char ipv;</p><p>+	if ((*m)-&gt;m_pkthdr.len &gt;= sizeof(struct ip6_hdr))</p><p>+		*m = m_pullup(*m, sizeof(struct ip6_hdr));</p><p>+	else if ((*m)-&gt;m_pkthdr.len &gt;= sizeof(struct ip))</p><p>+		*m = m_pullup(*m, sizeof(struct ip));</p><p>+	else</p><p>+		return (EAFNOSUPPORT);</p><p>+	if (*m == NULL)</p><p>+		return (ENOBUFS);</p><p>+	ipv = mtod(*m, struct ip *)-&gt;ip_v;</p><p>+	if (ipv == 4)</p><p>+		*af = AF_INET;</p><p>+	else if (ipv == 6 &amp;&amp; (*m)-&gt;m_pkthdr.len &gt;= sizeof(struct ip6_hdr))</p><p>+		*af = AF_INET6;</p><p>+	else</p><p>+		return (EAFNOSUPPORT);</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+static int</p><p>+wg_transmit(struct ifnet *ifp, struct mbuf *m)</p><p>+{</p><p>+	sa_family_t af;</p><p>+	int ret;</p><p>+	struct mbuf *defragged;</p><p>+</p><p>+	defragged = m_defrag(m, M_NOWAIT);</p><p>+	if (defragged)</p><p>+		m = defragged;</p><p>+	m = m_unshare(m, M_NOWAIT);</p><p>+	if (!m) {</p><p>+		xmit_err(ifp, m, NULL, AF_UNSPEC);</p><p>+		return (ENOBUFS);</p><p>+	}</p><p>+</p><p>+	ret = determine_af_and_pullup(&amp;m, &amp;af);</p><p>+	if (ret) {</p><p>+		xmit_err(ifp, m, NULL, AF_UNSPEC);</p><p>+		return (ret);</p><p>+	}</p><p>+	return (wg_xmit(ifp, m, af, ifp-&gt;if_mtu));</p><p>+}</p><p>+</p><p>+static int</p><p>+wg_output(struct ifnet *ifp, struct mbuf *m, const struct sockaddr *dst, struct route *ro)</p><p>+{</p><p>+	sa_family_t parsed_af;</p><p>+	uint32_t af, mtu;</p><p>+	int ret;</p><p>+	struct mbuf *defragged;</p><p>+</p><p>+	if (dst-&gt;sa_family == AF_UNSPEC)</p><p>+		memcpy(&amp;af, dst-&gt;sa_data, sizeof(af));</p><p>+	else</p><p>+		af = dst-&gt;sa_family;</p><p>+	if (af == AF_UNSPEC) {</p><p>+		xmit_err(ifp, m, NULL, af);</p><p>+		return (EAFNOSUPPORT);</p><p>+	}</p><p>+</p><p>+	defragged = m_defrag(m, M_NOWAIT);</p><p>+	if (defragged)</p><p>+		m = defragged;</p><p>+	m = m_unshare(m, M_NOWAIT);</p><p>+	if (!m) {</p><p>+		xmit_err(ifp, m, NULL, AF_UNSPEC);</p><p>+		return (ENOBUFS);</p><p>+	}</p><p>+</p><p>+	ret = determine_af_and_pullup(&amp;m, &amp;parsed_af);</p><p>+	if (ret) {</p><p>+		xmit_err(ifp, m, NULL, AF_UNSPEC);</p><p>+		return (ret);</p><p>+	}</p><p>+	if (parsed_af != af) {</p><p>+		xmit_err(ifp, m, NULL, AF_UNSPEC);</p><p>+		return (EAFNOSUPPORT);</p><p>+	}</p><p>+	mtu = (ro != NULL &amp;&amp; ro-&gt;ro_mtu &gt; 0) ? ro-&gt;ro_mtu : ifp-&gt;if_mtu;</p><p>+	return (wg_xmit(ifp, m, parsed_af, mtu));</p><p>+}</p><p>+</p><p>+static int</p><p>+wg_peer_add(struct wg_softc *sc, const nvlist_t *nvl)</p><p>+{</p><p>+	uint8_t			 public[WG_KEY_SIZE];</p><p>+	const void *pub_key, *preshared_key = NULL;</p><p>+	const struct sockaddr *endpoint;</p><p>+	int err;</p><p>+	size_t size;</p><p>+	struct noise_remote *remote;</p><p>+	struct wg_peer *peer = NULL;</p><p>+	bool need_insert = false;</p><p>+</p><p>+	sx_assert(&amp;sc-&gt;sc_lock, SX_XLOCKED);</p><p>+</p><p>+	if (!nvlist_exists_binary(nvl, &#34;public-key&#34;)) {</p><p>+		return (EINVAL);</p><p>+	}</p><p>+	pub_key = nvlist_get_binary(nvl, &#34;public-key&#34;, &amp;size);</p><p>+	if (size != WG_KEY_SIZE) {</p><p>+		return (EINVAL);</p><p>+	}</p><p>+	if (noise_local_keys(sc-&gt;sc_local, public, NULL) == 0 &amp;&amp;</p><p>+	    bcmp(public, pub_key, WG_KEY_SIZE) == 0) {</p><p>+		return (0); // Silently ignored; not actually a failure.</p><p>+	}</p><p>+	if ((remote = noise_remote_lookup(sc-&gt;sc_local, pub_key)) != NULL)</p><p>+		peer = noise_remote_arg(remote);</p><p>+	if (nvlist_exists_bool(nvl, &#34;remove&#34;) &amp;&amp;</p><p>+		nvlist_get_bool(nvl, &#34;remove&#34;)) {</p><p>+		if (remote != NULL) {</p><p>+			wg_peer_destroy(peer);</p><p>+			noise_remote_put(remote);</p><p>+		}</p><p>+		return (0);</p><p>+	}</p><p>+	if (nvlist_exists_bool(nvl, &#34;replace-allowedips&#34;) &amp;&amp;</p><p>+		nvlist_get_bool(nvl, &#34;replace-allowedips&#34;) &amp;&amp;</p><p>+	    peer != NULL) {</p><p>+</p><p>+		wg_aip_remove_all(sc, peer);</p><p>+	}</p><p>+	if (peer == NULL) {</p><p>+		peer = wg_peer_alloc(sc, pub_key);</p><p>+		need_insert = true;</p><p>+	}</p><p>+	if (nvlist_exists_binary(nvl, &#34;endpoint&#34;)) {</p><p>+		endpoint = nvlist_get_binary(nvl, &#34;endpoint&#34;, &amp;size);</p><p>+		if (size &gt; sizeof(peer-&gt;p_endpoint.e_remote)) {</p><p>+			err = EINVAL;</p><p>+			goto out;</p><p>+		}</p><p>+		memcpy(&amp;peer-&gt;p_endpoint.e_remote, endpoint, size);</p><p>+	}</p><p>+	if (nvlist_exists_binary(nvl, &#34;preshared-key&#34;)) {</p><p>+		preshared_key = nvlist_get_binary(nvl, &#34;preshared-key&#34;, &amp;size);</p><p>+		if (size != WG_KEY_SIZE) {</p><p>+			err = EINVAL;</p><p>+			goto out;</p><p>+		}</p><p>+		noise_remote_set_psk(peer-&gt;p_remote, preshared_key);</p><p>+	}</p><p>+	if (nvlist_exists_number(nvl, &#34;persistent-keepalive-interval&#34;)) {</p><p>+		uint64_t pki = nvlist_get_number(nvl, &#34;persistent-keepalive-interval&#34;);</p><p>+		if (pki &gt; UINT16_MAX) {</p><p>+			err = EINVAL;</p><p>+			goto out;</p><p>+		}</p><p>+		wg_timers_set_persistent_keepalive(peer, pki);</p><p>+	}</p><p>+	if (nvlist_exists_nvlist_array(nvl, &#34;allowed-ips&#34;)) {</p><p>+		const void *addr;</p><p>+		uint64_t cidr;</p><p>+		const nvlist_t * const * aipl;</p><p>+		size_t allowedip_count;</p><p>+</p><p>+		aipl = nvlist_get_nvlist_array(nvl, &#34;allowed-ips&#34;, &amp;allowedip_count);</p><p>+		for (size_t idx = 0; idx &lt; allowedip_count; idx++) {</p><p>+			if (!nvlist_exists_number(aipl[idx], &#34;cidr&#34;))</p><p>+				continue;</p><p>+			cidr = nvlist_get_number(aipl[idx], &#34;cidr&#34;);</p><p>+			if (nvlist_exists_binary(aipl[idx], &#34;ipv4&#34;)) {</p><p>+				addr = nvlist_get_binary(aipl[idx], &#34;ipv4&#34;, &amp;size);</p><p>+				if (addr == NULL || cidr &gt; 32 || size != sizeof(struct in_addr)) {</p><p>+					err = EINVAL;</p><p>+					goto out;</p><p>+				}</p><p>+				if ((err = wg_aip_add(sc, peer, AF_INET, addr, cidr)) != 0)</p><p>+					goto out;</p><p>+			} else if (nvlist_exists_binary(aipl[idx], &#34;ipv6&#34;)) {</p><p>+				addr = nvlist_get_binary(aipl[idx], &#34;ipv6&#34;, &amp;size);</p><p>+				if (addr == NULL || cidr &gt; 128 || size != sizeof(struct in6_addr)) {</p><p>+					err = EINVAL;</p><p>+					goto out;</p><p>+				}</p><p>+				if ((err = wg_aip_add(sc, peer, AF_INET6, addr, cidr)) != 0)</p><p>+					goto out;</p><p>+			} else {</p><p>+				continue;</p><p>+			}</p><p>+		}</p><p>+	}</p><p>+	if (need_insert) {</p><p>+		if ((err = noise_remote_enable(peer-&gt;p_remote)) != 0)</p><p>+			goto out;</p><p>+		TAILQ_INSERT_TAIL(&amp;sc-&gt;sc_peers, peer, p_entry);</p><p>+		sc-&gt;sc_peers_num++;</p><p>+		if (sc-&gt;sc_ifp-&gt;if_link_state == LINK_STATE_UP)</p><p>+			wg_timers_enable(peer);</p><p>+	}</p><p>+	if (remote != NULL)</p><p>+		noise_remote_put(remote);</p><p>+	return (0);</p><p>+out:</p><p>+	if (need_insert) /* If we fail, only destroy if it was new. */</p><p>+		wg_peer_destroy(peer);</p><p>+	if (remote != NULL)</p><p>+		noise_remote_put(remote);</p><p>+	return (err);</p><p>+}</p><p>+</p><p>+static int</p><p>+wgc_set(struct wg_softc *sc, struct wg_data_io *wgd)</p><p>+{</p><p>+	uint8_t public[WG_KEY_SIZE], private[WG_KEY_SIZE];</p><p>+	struct ifnet *ifp;</p><p>+	void *nvlpacked;</p><p>+	nvlist_t *nvl;</p><p>+	ssize_t size;</p><p>+	int err;</p><p>+</p><p>+	ifp = sc-&gt;sc_ifp;</p><p>+	if (wgd-&gt;wgd_size == 0 || wgd-&gt;wgd_data == NULL)</p><p>+		return (EFAULT);</p><p>+</p><p>+	/* Can nvlists be streamed in? It&#39;s not nice to impose arbitrary limits like that but</p><p>+	 * there needs to be _some_ limitation. */</p><p>+	if (wgd-&gt;wgd_size &gt;= UINT32_MAX / 2)</p><p>+		return (E2BIG);</p><p>+</p><p>+	nvlpacked = malloc(wgd-&gt;wgd_size, M_TEMP, M_WAITOK | M_ZERO);</p><p>+</p><p>+	err = copyin(wgd-&gt;wgd_data, nvlpacked, wgd-&gt;wgd_size);</p><p>+	if (err)</p><p>+		goto out;</p><p>+	nvl = nvlist_unpack(nvlpacked, wgd-&gt;wgd_size, 0);</p><p>+	if (nvl == NULL) {</p><p>+		err = EBADMSG;</p><p>+		goto out;</p><p>+	}</p><p>+	sx_xlock(&amp;sc-&gt;sc_lock);</p><p>+	if (nvlist_exists_bool(nvl, &#34;replace-peers&#34;) &amp;&amp;</p><p>+		nvlist_get_bool(nvl, &#34;replace-peers&#34;))</p><p>+		wg_peer_destroy_all(sc);</p><p>+	if (nvlist_exists_number(nvl, &#34;listen-port&#34;)) {</p><p>+		uint64_t new_port = nvlist_get_number(nvl, &#34;listen-port&#34;);</p><p>+		if (new_port &gt; UINT16_MAX) {</p><p>+			err = EINVAL;</p><p>+			goto out_locked;</p><p>+		}</p><p>+		if (new_port != sc-&gt;sc_socket.so_port) {</p><p>+			if ((ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING) != 0) {</p><p>+				if ((err = wg_socket_init(sc, new_port)) != 0)</p><p>+					goto out_locked;</p><p>+			} else</p><p>+				sc-&gt;sc_socket.so_port = new_port;</p><p>+		}</p><p>+	}</p><p>+	if (nvlist_exists_binary(nvl, &#34;private-key&#34;)) {</p><p>+		const void *key = nvlist_get_binary(nvl, &#34;private-key&#34;, &amp;size);</p><p>+		if (size != WG_KEY_SIZE) {</p><p>+			err = EINVAL;</p><p>+			goto out_locked;</p><p>+		}</p><p>+</p><p>+		if (noise_local_keys(sc-&gt;sc_local, NULL, private) != 0 ||</p><p>+		    timingsafe_bcmp(private, key, WG_KEY_SIZE) != 0) {</p><p>+			struct wg_peer *peer;</p><p>+</p><p>+			if (curve25519_generate_public(public, key)) {</p><p>+				/* Peer conflict: remove conflicting peer. */</p><p>+				struct noise_remote *remote;</p><p>+				if ((remote = noise_remote_lookup(sc-&gt;sc_local,</p><p>+				    public)) != NULL) {</p><p>+					peer = noise_remote_arg(remote);</p><p>+					wg_peer_destroy(peer);</p><p>+					noise_remote_put(remote);</p><p>+				}</p><p>+			}</p><p>+</p><p>+			/*</p><p>+			 * Set the private key and invalidate all existing</p><p>+			 * handshakes.</p><p>+			 */</p><p>+			/* Note: we might be removing the private key. */</p><p>+			noise_local_private(sc-&gt;sc_local, key);</p><p>+			if (noise_local_keys(sc-&gt;sc_local, NULL, NULL) == 0)</p><p>+				cookie_checker_update(&amp;sc-&gt;sc_cookie, public);</p><p>+			else</p><p>+				cookie_checker_update(&amp;sc-&gt;sc_cookie, NULL);</p><p>+		}</p><p>+	}</p><p>+	if (nvlist_exists_number(nvl, &#34;user-cookie&#34;)) {</p><p>+		uint64_t user_cookie = nvlist_get_number(nvl, &#34;user-cookie&#34;);</p><p>+		if (user_cookie &gt; UINT32_MAX) {</p><p>+			err = EINVAL;</p><p>+			goto out_locked;</p><p>+		}</p><p>+		err = wg_socket_set_cookie(sc, user_cookie);</p><p>+		if (err)</p><p>+			goto out_locked;</p><p>+	}</p><p>+	if (nvlist_exists_nvlist_array(nvl, &#34;peers&#34;)) {</p><p>+		size_t peercount;</p><p>+		const nvlist_t * const*nvl_peers;</p><p>+</p><p>+		nvl_peers = nvlist_get_nvlist_array(nvl, &#34;peers&#34;, &amp;peercount);</p><p>+		for (int i = 0; i &lt; peercount; i++) {</p><p>+			err = wg_peer_add(sc, nvl_peers[i]);</p><p>+			if (err != 0)</p><p>+				goto out_locked;</p><p>+		}</p><p>+	}</p><p>+</p><p>+out_locked:</p><p>+	sx_xunlock(&amp;sc-&gt;sc_lock);</p><p>+	nvlist_destroy(nvl);</p><p>+out:</p><p>+	explicit_bzero(nvlpacked, wgd-&gt;wgd_size);</p><p>+	free(nvlpacked, M_TEMP);</p><p>+	return (err);</p><p>+}</p><p>+</p><p>+static int</p><p>+wgc_get(struct wg_softc *sc, struct wg_data_io *wgd)</p><p>+{</p><p>+	uint8_t public_key[WG_KEY_SIZE] = { 0 };</p><p>+	uint8_t private_key[WG_KEY_SIZE] = { 0 };</p><p>+	uint8_t preshared_key[NOISE_SYMMETRIC_KEY_LEN] = { 0 };</p><p>+	nvlist_t *nvl, *nvl_peer, *nvl_aip, **nvl_peers, **nvl_aips;</p><p>+	size_t size, peer_count, aip_count, i, j;</p><p>+	struct wg_timespec64 ts64;</p><p>+	struct wg_peer *peer;</p><p>+	struct wg_aip *aip;</p><p>+	void *packed;</p><p>+	int err = 0;</p><p>+</p><p>+	nvl = nvlist_create(0);</p><p>+	if (!nvl)</p><p>+		return (ENOMEM);</p><p>+</p><p>+	sx_slock(&amp;sc-&gt;sc_lock);</p><p>+</p><p>+	if (sc-&gt;sc_socket.so_port != 0)</p><p>+		nvlist_add_number(nvl, &#34;listen-port&#34;, sc-&gt;sc_socket.so_port);</p><p>+	if (sc-&gt;sc_socket.so_user_cookie != 0)</p><p>+		nvlist_add_number(nvl, &#34;user-cookie&#34;, sc-&gt;sc_socket.so_user_cookie);</p><p>+	if (noise_local_keys(sc-&gt;sc_local, public_key, private_key) == 0) {</p><p>+		nvlist_add_binary(nvl, &#34;public-key&#34;, public_key, WG_KEY_SIZE);</p><p>+		if (wgc_privileged(sc))</p><p>+			nvlist_add_binary(nvl, &#34;private-key&#34;, private_key, WG_KEY_SIZE);</p><p>+		explicit_bzero(private_key, sizeof(private_key));</p><p>+	}</p><p>+	peer_count = sc-&gt;sc_peers_num;</p><p>+	if (peer_count) {</p><p>+		nvl_peers = mallocarray(peer_count, sizeof(void *), M_NVLIST, M_WAITOK | M_ZERO);</p><p>+		i = 0;</p><p>+		TAILQ_FOREACH(peer, &amp;sc-&gt;sc_peers, p_entry) {</p><p>+			if (i &gt;= peer_count)</p><p>+				panic(&#34;peers changed from under us&#34;);</p><p>+</p><p>+			nvl_peers[i++] = nvl_peer = nvlist_create(0);</p><p>+			if (!nvl_peer) {</p><p>+				err = ENOMEM;</p><p>+				goto err_peer;</p><p>+			}</p><p>+</p><p>+			(void)noise_remote_keys(peer-&gt;p_remote, public_key, preshared_key);</p><p>+			nvlist_add_binary(nvl_peer, &#34;public-key&#34;, public_key, sizeof(public_key));</p><p>+			if (wgc_privileged(sc))</p><p>+				nvlist_add_binary(nvl_peer, &#34;preshared-key&#34;, preshared_key, sizeof(preshared_key));</p><p>+			explicit_bzero(preshared_key, sizeof(preshared_key));</p><p>+			if (peer-&gt;p_endpoint.e_remote.r_sa.sa_family == AF_INET)</p><p>+				nvlist_add_binary(nvl_peer, &#34;endpoint&#34;, &amp;peer-&gt;p_endpoint.e_remote, sizeof(struct sockaddr_in));</p><p>+			else if (peer-&gt;p_endpoint.e_remote.r_sa.sa_family == AF_INET6)</p><p>+				nvlist_add_binary(nvl_peer, &#34;endpoint&#34;, &amp;peer-&gt;p_endpoint.e_remote, sizeof(struct sockaddr_in6));</p><p>+			wg_timers_get_last_handshake(peer, &amp;ts64);</p><p>+			nvlist_add_binary(nvl_peer, &#34;last-handshake-time&#34;, &amp;ts64, sizeof(ts64));</p><p>+			nvlist_add_number(nvl_peer, &#34;persistent-keepalive-interval&#34;, peer-&gt;p_persistent_keepalive_interval);</p><p>+			nvlist_add_number(nvl_peer, &#34;rx-bytes&#34;, counter_u64_fetch(peer-&gt;p_rx_bytes));</p><p>+			nvlist_add_number(nvl_peer, &#34;tx-bytes&#34;, counter_u64_fetch(peer-&gt;p_tx_bytes));</p><p>+</p><p>+			aip_count = peer-&gt;p_aips_num;</p><p>+			if (aip_count) {</p><p>+				nvl_aips = mallocarray(aip_count, sizeof(void *), M_NVLIST, M_WAITOK | M_ZERO);</p><p>+				j = 0;</p><p>+				LIST_FOREACH(aip, &amp;peer-&gt;p_aips, a_entry) {</p><p>+					if (j &gt;= aip_count)</p><p>+						panic(&#34;aips changed from under us&#34;);</p><p>+</p><p>+					nvl_aips[j++] = nvl_aip = nvlist_create(0);</p><p>+					if (!nvl_aip) {</p><p>+						err = ENOMEM;</p><p>+						goto err_aip;</p><p>+					}</p><p>+					if (aip-&gt;a_af == AF_INET) {</p><p>+						nvlist_add_binary(nvl_aip, &#34;ipv4&#34;, &amp;aip-&gt;a_addr.in, sizeof(aip-&gt;a_addr.in));</p><p>+						nvlist_add_number(nvl_aip, &#34;cidr&#34;, bitcount32(aip-&gt;a_mask.ip));</p><p>+					}</p><p>+#ifdef INET6</p><p>+					else if (aip-&gt;a_af == AF_INET6) {</p><p>+						nvlist_add_binary(nvl_aip, &#34;ipv6&#34;, &amp;aip-&gt;a_addr.in6, sizeof(aip-&gt;a_addr.in6));</p><p>+						nvlist_add_number(nvl_aip, &#34;cidr&#34;, in6_mask2len(&amp;aip-&gt;a_mask.in6, NULL));</p><p>+					}</p><p>+#endif</p><p>+				}</p><p>+				nvlist_add_nvlist_array(nvl_peer, &#34;allowed-ips&#34;, (const nvlist_t *const *)nvl_aips, aip_count);</p><p>+			err_aip:</p><p>+				for (j = 0; j &lt; aip_count; ++j)</p><p>+					nvlist_destroy(nvl_aips[j]);</p><p>+				free(nvl_aips, M_NVLIST);</p><p>+				if (err)</p><p>+					goto err_peer;</p><p>+			}</p><p>+		}</p><p>+		nvlist_add_nvlist_array(nvl, &#34;peers&#34;, (const nvlist_t * const *)nvl_peers, peer_count);</p><p>+	err_peer:</p><p>+		for (i = 0; i &lt; peer_count; ++i)</p><p>+			nvlist_destroy(nvl_peers[i]);</p><p>+		free(nvl_peers, M_NVLIST);</p><p>+		if (err) {</p><p>+			sx_sunlock(&amp;sc-&gt;sc_lock);</p><p>+			goto err;</p><p>+		}</p><p>+	}</p><p>+	sx_sunlock(&amp;sc-&gt;sc_lock);</p><p>+	packed = nvlist_pack(nvl, &amp;size);</p><p>+	if (!packed) {</p><p>+		err = ENOMEM;</p><p>+		goto err;</p><p>+	}</p><p>+	if (!wgd-&gt;wgd_size) {</p><p>+		wgd-&gt;wgd_size = size;</p><p>+		goto out;</p><p>+	}</p><p>+	if (wgd-&gt;wgd_size &lt; size) {</p><p>+		err = ENOSPC;</p><p>+		goto out;</p><p>+	}</p><p>+	err = copyout(packed, wgd-&gt;wgd_data, size);</p><p>+	wgd-&gt;wgd_size = size;</p><p>+</p><p>+out:</p><p>+	explicit_bzero(packed, size);</p><p>+	free(packed, M_NVLIST);</p><p>+err:</p><p>+	nvlist_destroy(nvl);</p><p>+	return (err);</p><p>+}</p><p>+</p><p>+static int</p><p>+wg_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)</p><p>+{</p><p>+	struct wg_data_io *wgd = (struct wg_data_io *)data;</p><p>+	struct ifreq *ifr = (struct ifreq *)data;</p><p>+	struct wg_softc *sc;</p><p>+	int ret = 0;</p><p>+</p><p>+	sx_slock(&amp;wg_sx);</p><p>+	sc = ifp-&gt;if_softc;</p><p>+	if (!sc) {</p><p>+		ret = ENXIO;</p><p>+		goto out;</p><p>+	}</p><p>+</p><p>+	switch (cmd) {</p><p>+	case SIOCSWG:</p><p>+		ret = priv_check(curthread, PRIV_NET_WG);</p><p>+		if (ret == 0)</p><p>+			ret = wgc_set(sc, wgd);</p><p>+		break;</p><p>+	case SIOCGWG:</p><p>+		ret = wgc_get(sc, wgd);</p><p>+		break;</p><p>+	/* Interface IOCTLs */</p><p>+	case SIOCSIFADDR:</p><p>+		/*</p><p>+		 * This differs from *BSD norms, but is more uniform with how</p><p>+		 * WireGuard behaves elsewhere.</p><p>+		 */</p><p>+		break;</p><p>+	case SIOCSIFFLAGS:</p><p>+		if (ifp-&gt;if_flags &amp; IFF_UP)</p><p>+			ret = wg_up(sc);</p><p>+		else</p><p>+			wg_down(sc);</p><p>+		break;</p><p>+	case SIOCSIFMTU:</p><p>+		if (ifr-&gt;ifr_mtu &lt;= 0 || ifr-&gt;ifr_mtu &gt; MAX_MTU)</p><p>+			ret = EINVAL;</p><p>+		else</p><p>+			ifp-&gt;if_mtu = ifr-&gt;ifr_mtu;</p><p>+		break;</p><p>+	case SIOCADDMULTI:</p><p>+	case SIOCDELMULTI:</p><p>+		break;</p><p>+	case SIOCGTUNFIB:</p><p>+		ifr-&gt;ifr_fib = sc-&gt;sc_socket.so_fibnum;</p><p>+		break;</p><p>+	case SIOCSTUNFIB:</p><p>+		ret = priv_check(curthread, PRIV_NET_WG);</p><p>+		if (ret)</p><p>+			break;</p><p>+		ret = priv_check(curthread, PRIV_NET_SETIFFIB);</p><p>+		if (ret)</p><p>+			break;</p><p>+		sx_xlock(&amp;sc-&gt;sc_lock);</p><p>+		ret = wg_socket_set_fibnum(sc, ifr-&gt;ifr_fib);</p><p>+		sx_xunlock(&amp;sc-&gt;sc_lock);</p><p>+		break;</p><p>+	default:</p><p>+		ret = ENOTTY;</p><p>+	}</p><p>+</p><p>+out:</p><p>+	sx_sunlock(&amp;wg_sx);</p><p>+	return (ret);</p><p>+}</p><p>+</p><p>+static int</p><p>+wg_up(struct wg_softc *sc)</p><p>+{</p><p>+	struct ifnet *ifp = sc-&gt;sc_ifp;</p><p>+	struct wg_peer *peer;</p><p>+	int rc = EBUSY;</p><p>+</p><p>+	sx_xlock(&amp;sc-&gt;sc_lock);</p><p>+	/* Jail&#39;s being removed, no more wg_up(). */</p><p>+	if ((sc-&gt;sc_flags &amp; WGF_DYING) != 0)</p><p>+		goto out;</p><p>+</p><p>+	/* Silent success if we&#39;re already running. */</p><p>+	rc = 0;</p><p>+	if (ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING)</p><p>+		goto out;</p><p>+	ifp-&gt;if_drv_flags |= IFF_DRV_RUNNING;</p><p>+</p><p>+	rc = wg_socket_init(sc, sc-&gt;sc_socket.so_port);</p><p>+	if (rc == 0) {</p><p>+		TAILQ_FOREACH(peer, &amp;sc-&gt;sc_peers, p_entry)</p><p>+			wg_timers_enable(peer);</p><p>+		if_link_state_change(sc-&gt;sc_ifp, LINK_STATE_UP);</p><p>+	} else {</p><p>+		ifp-&gt;if_drv_flags &amp;= ~IFF_DRV_RUNNING;</p><p>+		DPRINTF(sc, &#34;Unable to initialize sockets: %d\n&#34;, rc);</p><p>+	}</p><p>+out:</p><p>+	sx_xunlock(&amp;sc-&gt;sc_lock);</p><p>+	return (rc);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_down(struct wg_softc *sc)</p><p>+{</p><p>+	struct ifnet *ifp = sc-&gt;sc_ifp;</p><p>+	struct wg_peer *peer;</p><p>+</p><p>+	sx_xlock(&amp;sc-&gt;sc_lock);</p><p>+	if (!(ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING)) {</p><p>+		sx_xunlock(&amp;sc-&gt;sc_lock);</p><p>+		return;</p><p>+	}</p><p>+	ifp-&gt;if_drv_flags &amp;= ~IFF_DRV_RUNNING;</p><p>+</p><p>+	TAILQ_FOREACH(peer, &amp;sc-&gt;sc_peers, p_entry) {</p><p>+		wg_queue_purge(&amp;peer-&gt;p_stage_queue);</p><p>+		wg_timers_disable(peer);</p><p>+	}</p><p>+</p><p>+	wg_queue_purge(&amp;sc-&gt;sc_handshake_queue);</p><p>+</p><p>+	TAILQ_FOREACH(peer, &amp;sc-&gt;sc_peers, p_entry) {</p><p>+		noise_remote_handshake_clear(peer-&gt;p_remote);</p><p>+		noise_remote_keypairs_clear(peer-&gt;p_remote);</p><p>+	}</p><p>+</p><p>+	if_link_state_change(sc-&gt;sc_ifp, LINK_STATE_DOWN);</p><p>+	wg_socket_uninit(sc);</p><p>+</p><p>+	sx_xunlock(&amp;sc-&gt;sc_lock);</p><p>+}</p><p>+</p><p>+static int</p><p>+wg_clone_create(struct if_clone *ifc, int unit, caddr_t params)</p><p>+{</p><p>+	struct wg_softc *sc;</p><p>+	struct ifnet *ifp;</p><p>+</p><p>+	sc = malloc(sizeof(*sc), M_WG, M_WAITOK | M_ZERO);</p><p>+</p><p>+	sc-&gt;sc_local = noise_local_alloc(sc);</p><p>+</p><p>+	sc-&gt;sc_encrypt = mallocarray(sizeof(struct grouptask), mp_ncpus, M_WG, M_WAITOK | M_ZERO);</p><p>+</p><p>+	sc-&gt;sc_decrypt = mallocarray(sizeof(struct grouptask), mp_ncpus, M_WG, M_WAITOK | M_ZERO);</p><p>+</p><p>+	if (!rn_inithead((void **)&amp;sc-&gt;sc_aip4, offsetof(struct aip_addr, in) * NBBY))</p><p>+		goto free_decrypt;</p><p>+</p><p>+	if (!rn_inithead((void **)&amp;sc-&gt;sc_aip6, offsetof(struct aip_addr, in6) * NBBY))</p><p>+		goto free_aip4;</p><p>+</p><p>+	atomic_add_int(&amp;clone_count, 1);</p><p>+	ifp = sc-&gt;sc_ifp = if_alloc(IFT_WIREGUARD);</p><p>+</p><p>+	sc-&gt;sc_ucred = crhold(curthread-&gt;td_ucred);</p><p>+	sc-&gt;sc_socket.so_fibnum = curthread-&gt;td_proc-&gt;p_fibnum;</p><p>+	sc-&gt;sc_socket.so_port = 0;</p><p>+</p><p>+	TAILQ_INIT(&amp;sc-&gt;sc_peers);</p><p>+	sc-&gt;sc_peers_num = 0;</p><p>+</p><p>+	cookie_checker_init(&amp;sc-&gt;sc_cookie);</p><p>+</p><p>+	RADIX_NODE_HEAD_LOCK_INIT(sc-&gt;sc_aip4);</p><p>+	RADIX_NODE_HEAD_LOCK_INIT(sc-&gt;sc_aip6);</p><p>+</p><p>+	GROUPTASK_INIT(&amp;sc-&gt;sc_handshake, 0, (gtask_fn_t *)wg_softc_handshake_receive, sc);</p><p>+	taskqgroup_attach(qgroup_wg_tqg, &amp;sc-&gt;sc_handshake, sc, NULL, NULL, &#34;wg tx initiation&#34;);</p><p>+	wg_queue_init(&amp;sc-&gt;sc_handshake_queue, &#34;hsq&#34;);</p><p>+</p><p>+	for (int i = 0; i &lt; mp_ncpus; i++) {</p><p>+		GROUPTASK_INIT(&amp;sc-&gt;sc_encrypt[i], 0,</p><p>+		     (gtask_fn_t *)wg_softc_encrypt, sc);</p><p>+		taskqgroup_attach_cpu(qgroup_wg_tqg, &amp;sc-&gt;sc_encrypt[i], sc, i, NULL, NULL, &#34;wg encrypt&#34;);</p><p>+		GROUPTASK_INIT(&amp;sc-&gt;sc_decrypt[i], 0,</p><p>+		    (gtask_fn_t *)wg_softc_decrypt, sc);</p><p>+		taskqgroup_attach_cpu(qgroup_wg_tqg, &amp;sc-&gt;sc_decrypt[i], sc, i, NULL, NULL, &#34;wg decrypt&#34;);</p><p>+	}</p><p>+</p><p>+	wg_queue_init(&amp;sc-&gt;sc_encrypt_parallel, &#34;encp&#34;);</p><p>+	wg_queue_init(&amp;sc-&gt;sc_decrypt_parallel, &#34;decp&#34;);</p><p>+</p><p>+	sx_init(&amp;sc-&gt;sc_lock, &#34;wg softc lock&#34;);</p><p>+</p><p>+	ifp-&gt;if_softc = sc;</p><p>+	ifp-&gt;if_capabilities = ifp-&gt;if_capenable = WG_CAPS;</p><p>+	if_initname(ifp, wgname, unit);</p><p>+</p><p>+	if_setmtu(ifp, DEFAULT_MTU);</p><p>+	ifp-&gt;if_flags = IFF_NOARP | IFF_MULTICAST;</p><p>+	ifp-&gt;if_init = wg_init;</p><p>+	ifp-&gt;if_reassign = wg_reassign;</p><p>+	ifp-&gt;if_qflush = wg_qflush;</p><p>+	ifp-&gt;if_transmit = wg_transmit;</p><p>+	ifp-&gt;if_output = wg_output;</p><p>+	ifp-&gt;if_ioctl = wg_ioctl;</p><p>+	if_attach(ifp);</p><p>+	bpfattach(ifp, DLT_NULL, sizeof(uint32_t));</p><p>+#ifdef INET6</p><p>+	ND_IFINFO(ifp)-&gt;flags &amp;= ~ND6_IFF_AUTO_LINKLOCAL;</p><p>+	ND_IFINFO(ifp)-&gt;flags |= ND6_IFF_NO_DAD;</p><p>+#endif</p><p>+	sx_xlock(&amp;wg_sx);</p><p>+	LIST_INSERT_HEAD(&amp;wg_list, sc, sc_entry);</p><p>+	sx_xunlock(&amp;wg_sx);</p><p>+	return (0);</p><p>+free_aip4:</p><p>+	RADIX_NODE_HEAD_DESTROY(sc-&gt;sc_aip4);</p><p>+	free(sc-&gt;sc_aip4, M_RTABLE);</p><p>+free_decrypt:</p><p>+	free(sc-&gt;sc_decrypt, M_WG);</p><p>+	free(sc-&gt;sc_encrypt, M_WG);</p><p>+	noise_local_free(sc-&gt;sc_local, NULL);</p><p>+	free(sc, M_WG);</p><p>+	return (ENOMEM);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_clone_deferred_free(struct noise_local *l)</p><p>+{</p><p>+	struct wg_softc *sc = noise_local_arg(l);</p><p>+</p><p>+	free(sc, M_WG);</p><p>+	atomic_add_int(&amp;clone_count, -1);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_clone_destroy(struct ifnet *ifp)</p><p>+{</p><p>+	struct wg_softc *sc = ifp-&gt;if_softc;</p><p>+	struct ucred *cred;</p><p>+</p><p>+	sx_xlock(&amp;wg_sx);</p><p>+	ifp-&gt;if_softc = NULL;</p><p>+	sx_xlock(&amp;sc-&gt;sc_lock);</p><p>+	sc-&gt;sc_flags |= WGF_DYING;</p><p>+	cred = sc-&gt;sc_ucred;</p><p>+	sc-&gt;sc_ucred = NULL;</p><p>+	sx_xunlock(&amp;sc-&gt;sc_lock);</p><p>+	LIST_REMOVE(sc, sc_entry);</p><p>+	sx_xunlock(&amp;wg_sx);</p><p>+</p><p>+	if_link_state_change(sc-&gt;sc_ifp, LINK_STATE_DOWN);</p><p>+	CURVNET_SET(sc-&gt;sc_ifp-&gt;if_vnet);</p><p>+	if_purgeaddrs(sc-&gt;sc_ifp);</p><p>+	CURVNET_RESTORE();</p><p>+</p><p>+	sx_xlock(&amp;sc-&gt;sc_lock);</p><p>+	wg_socket_uninit(sc);</p><p>+	sx_xunlock(&amp;sc-&gt;sc_lock);</p><p>+</p><p>+	/*</p><p>+	 * No guarantees that all traffic have passed until the epoch has</p><p>+	 * elapsed with the socket closed.</p><p>+	 */</p><p>+	NET_EPOCH_WAIT();</p><p>+</p><p>+	taskqgroup_drain_all(qgroup_wg_tqg);</p><p>+	sx_xlock(&amp;sc-&gt;sc_lock);</p><p>+	wg_peer_destroy_all(sc);</p><p>+	epoch_drain_callbacks(net_epoch_preempt);</p><p>+	sx_xunlock(&amp;sc-&gt;sc_lock);</p><p>+	sx_destroy(&amp;sc-&gt;sc_lock);</p><p>+	taskqgroup_detach(qgroup_wg_tqg, &amp;sc-&gt;sc_handshake);</p><p>+	for (int i = 0; i &lt; mp_ncpus; i++) {</p><p>+		taskqgroup_detach(qgroup_wg_tqg, &amp;sc-&gt;sc_encrypt[i]);</p><p>+		taskqgroup_detach(qgroup_wg_tqg, &amp;sc-&gt;sc_decrypt[i]);</p><p>+	}</p><p>+	free(sc-&gt;sc_encrypt, M_WG);</p><p>+	free(sc-&gt;sc_decrypt, M_WG);</p><p>+	wg_queue_deinit(&amp;sc-&gt;sc_handshake_queue);</p><p>+	wg_queue_deinit(&amp;sc-&gt;sc_encrypt_parallel);</p><p>+	wg_queue_deinit(&amp;sc-&gt;sc_decrypt_parallel);</p><p>+</p><p>+	RADIX_NODE_HEAD_DESTROY(sc-&gt;sc_aip4);</p><p>+	RADIX_NODE_HEAD_DESTROY(sc-&gt;sc_aip6);</p><p>+	rn_detachhead((void **)&amp;sc-&gt;sc_aip4);</p><p>+	rn_detachhead((void **)&amp;sc-&gt;sc_aip6);</p><p>+</p><p>+	cookie_checker_free(&amp;sc-&gt;sc_cookie);</p><p>+</p><p>+	if (cred != NULL)</p><p>+		crfree(cred);</p><p>+	if_detach(sc-&gt;sc_ifp);</p><p>+	if_free(sc-&gt;sc_ifp);</p><p>+</p><p>+	noise_local_free(sc-&gt;sc_local, wg_clone_deferred_free);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_qflush(struct ifnet *ifp __unused)</p><p>+{</p><p>+}</p><p>+</p><p>+/*</p><p>+ * Privileged information (private-key, preshared-key) are only exported for</p><p>+ * root and jailed root by default.</p><p>+ */</p><p>+static bool</p><p>+wgc_privileged(struct wg_softc *sc)</p><p>+{</p><p>+	struct thread *td;</p><p>+</p><p>+	td = curthread;</p><p>+	return (priv_check(td, PRIV_NET_WG) == 0);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_reassign(struct ifnet *ifp, struct vnet *new_vnet __unused,</p><p>+    char *unused __unused)</p><p>+{</p><p>+	struct wg_softc *sc;</p><p>+</p><p>+	sc = ifp-&gt;if_softc;</p><p>+	wg_down(sc);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_init(void *xsc)</p><p>+{</p><p>+	struct wg_softc *sc;</p><p>+</p><p>+	sc = xsc;</p><p>+	wg_up(sc);</p><p>+}</p><p>+</p><p>+static void</p><p>+vnet_wg_init(const void *unused __unused)</p><p>+{</p><p>+	V_wg_cloner = if_clone_simple(wgname, wg_clone_create, wg_clone_destroy,</p><p>+				      0);</p><p>+}</p><p>+VNET_SYSINIT(vnet_wg_init, SI_SUB_PROTO_IFATTACHDOMAIN, SI_ORDER_ANY,</p><p>+	     vnet_wg_init, NULL);</p><p>+</p><p>+static void</p><p>+vnet_wg_uninit(const void *unused __unused)</p><p>+{</p><p>+	if (V_wg_cloner)</p><p>+		if_clone_detach(V_wg_cloner);</p><p>+}</p><p>+VNET_SYSUNINIT(vnet_wg_uninit, SI_SUB_PROTO_IFATTACHDOMAIN, SI_ORDER_ANY,</p><p>+	       vnet_wg_uninit, NULL);</p><p>+</p><p>+static int</p><p>+wg_prison_remove(void *obj, void *data __unused)</p><p>+{</p><p>+	const struct prison *pr = obj;</p><p>+	struct wg_softc *sc;</p><p>+</p><p>+	/*</p><p>+	 * Do a pass through all if_wg interfaces and release creds on any from</p><p>+	 * the jail that are supposed to be going away.  This will, in turn, let</p><p>+	 * the jail die so that we don&#39;t end up with Schrdinger&#39;s jail.</p><p>+	 */</p><p>+	sx_slock(&amp;wg_sx);</p><p>+	LIST_FOREACH(sc, &amp;wg_list, sc_entry) {</p><p>+		sx_xlock(&amp;sc-&gt;sc_lock);</p><p>+		if (!(sc-&gt;sc_flags &amp; WGF_DYING) &amp;&amp; sc-&gt;sc_ucred &amp;&amp; sc-&gt;sc_ucred-&gt;cr_prison == pr) {</p><p>+			struct ucred *cred = sc-&gt;sc_ucred;</p><p>+			DPRINTF(sc, &#34;Creating jail exiting\n&#34;);</p><p>+			if_link_state_change(sc-&gt;sc_ifp, LINK_STATE_DOWN);</p><p>+			wg_socket_uninit(sc);</p><p>+			sc-&gt;sc_ucred = NULL;</p><p>+			crfree(cred);</p><p>+			sc-&gt;sc_flags |= WGF_DYING;</p><p>+		}</p><p>+		sx_xunlock(&amp;sc-&gt;sc_lock);</p><p>+	}</p><p>+	sx_sunlock(&amp;wg_sx);</p><p>+</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+#ifdef SELFTESTS</p><p>+#include &#34;selftest/allowedips.c&#34;</p><p>+static bool wg_run_selftests(void)</p><p>+{</p><p>+	bool ret = true;</p><p>+	ret &amp;= wg_allowedips_selftest();</p><p>+	ret &amp;= noise_counter_selftest();</p><p>+	ret &amp;= cookie_selftest();</p><p>+	return ret;</p><p>+}</p><p>+#else</p><p>+static inline bool wg_run_selftests(void) { return true; }</p><p>+#endif</p><p>+</p><p>+static int</p><p>+wg_module_init(void)</p><p>+{</p><p>+	int ret = ENOMEM;</p><p>+</p><p>+	osd_method_t methods[PR_MAXMETHOD] = {</p><p>+		[PR_METHOD_REMOVE] = wg_prison_remove,</p><p>+	};</p><p>+</p><p>+	if ((wg_packet_zone = uma_zcreate(&#34;wg packet&#34;, sizeof(struct wg_packet),</p><p>+	     NULL, NULL, NULL, NULL, 0, 0)) == NULL)</p><p>+		goto free_none;</p><p>+	ret = crypto_init();</p><p>+	if (ret != 0)</p><p>+		goto free_zone;</p><p>+	if (cookie_init() != 0)</p><p>+		goto free_crypto;</p><p>+</p><p>+	wg_osd_jail_slot = osd_jail_register(NULL, methods);</p><p>+</p><p>+	ret = ENOTRECOVERABLE;</p><p>+	if (!wg_run_selftests())</p><p>+		goto free_all;</p><p>+</p><p>+	return (0);</p><p>+</p><p>+free_all:</p><p>+	osd_jail_deregister(wg_osd_jail_slot);</p><p>+	cookie_deinit();</p><p>+free_crypto:</p><p>+	crypto_deinit();</p><p>+free_zone:</p><p>+	uma_zdestroy(wg_packet_zone);</p><p>+free_none:</p><p>+	return (ret);</p><p>+}</p><p>+</p><p>+static void</p><p>+wg_module_deinit(void)</p><p>+{</p><p>+	VNET_ITERATOR_DECL(vnet_iter);</p><p>+	VNET_LIST_RLOCK();</p><p>+	VNET_FOREACH(vnet_iter) {</p><p>+		struct if_clone *clone = VNET_VNET(vnet_iter, wg_cloner);</p><p>+		if (clone) {</p><p>+			if_clone_detach(clone);</p><p>+			VNET_VNET(vnet_iter, wg_cloner) = NULL;</p><p>+		}</p><p>+	}</p><p>+	VNET_LIST_RUNLOCK();</p><p>+	NET_EPOCH_WAIT();</p><p>+	MPASS(LIST_EMPTY(&amp;wg_list));</p><p>+	osd_jail_deregister(wg_osd_jail_slot);</p><p>+	cookie_deinit();</p><p>+	crypto_deinit();</p><p>+	uma_zdestroy(wg_packet_zone);</p><p>+}</p><p>+</p><p>+static int</p><p>+wg_module_event_handler(module_t mod, int what, void *arg)</p><p>+{</p><p>+	switch (what) {</p><p>+		case MOD_LOAD:</p><p>+			return wg_module_init();</p><p>+		case MOD_UNLOAD:</p><p>+			wg_module_deinit();</p><p>+			break;</p><p>+		default:</p><p>+			return (EOPNOTSUPP);</p><p>+	}</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+static moduledata_t wg_moduledata = {</p><p>+	wgname,</p><p>+	wg_module_event_handler,</p><p>+	NULL</p><p>+};</p><p>+</p><p>+DECLARE_MODULE(wg, wg_moduledata, SI_SUB_PSEUDO, SI_ORDER_ANY);</p><p>+MODULE_VERSION(wg, WIREGUARD_VERSION);</p><p>+MODULE_DEPEND(wg, crypto, 1, 1, 1);</p><div><p>diff --git a/sys/dev/wg/if_wg.h b/sys/dev/wg/if_wg.h</p></div><p>@@ -0,0 +1,37 @@</p><p>+/* SPDX-License-Identifier: ISC</p><p>+ *</p><p>+ * Copyright (c) 2019 Matt Dunwoodie &lt;ncon@noconroy.net&gt;</p><p>+ *</p><p>+ * Permission to use, copy, modify, and distribute this software for any</p><p>+ * purpose with or without fee is hereby granted, provided that the above</p><p>+ * copyright notice and this permission notice appear in all copies.</p><p>+ *</p><p>+ * THE SOFTWARE IS PROVIDED &#34;AS IS&#34; AND THE AUTHOR DISCLAIMS ALL WARRANTIES</p><p>+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</p><p>+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR</p><p>+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</p><p>+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</p><p>+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</p><p>+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</p><p>+ *</p><p>+ * $FreeBSD$</p><p>+ */</p><p>+</p><p>+#ifndef __IF_WG_H__</p><p>+#define __IF_WG_H__</p><p>+</p><p>+#include &lt;net/if.h&gt;</p><p>+#include &lt;netinet/in.h&gt;</p><p>+</p><p>+struct wg_data_io {</p><p>+	char	 wgd_name[IFNAMSIZ];</p><p>+	void	*wgd_data;</p><p>+	size_t	 wgd_size;</p><p>+};</p><p>+</p><p>+#define WG_KEY_SIZE	32</p><p>+</p><p>+#define SIOCSWG _IOWR(&#39;i&#39;, 210, struct wg_data_io)</p><p>+#define SIOCGWG _IOWR(&#39;i&#39;, 211, struct wg_data_io)</p><p>+</p><p>+#endif /* __IF_WG_H__ */</p><div><p>diff --git a/sys/dev/wg/support.h b/sys/dev/wg/support.h</p></div><p>@@ -0,0 +1,21 @@</p><p>+/* SPDX-License-Identifier: ISC</p><p>+ *</p><p>+ * Copyright (C) 2021 Jason A. Donenfeld &lt;Jason@zx2c4.com&gt;. All Rights Reserved.</p><p>+ * Copyright (c) 2021 Kyle Evans &lt;kevans@FreeBSD.org&gt;</p><p>+ *</p><p>+ * support.h contains code that is not _yet_ upstream in FreeBSD&#39;s main branch.</p><p>+ * It is different from compat.h, which is strictly for backports.</p><p>+ */</p><p>+</p><p>+#ifndef _WG_SUPPORT</p><p>+#define _WG_SUPPORT</p><p>+</p><p>+#ifndef ck_pr_store_bool</p><p>+#define ck_pr_store_bool(dst, val) ck_pr_store_8((uint8_t *)(dst), (uint8_t)(val))</p><p>+#endif</p><p>+</p><p>+#ifndef ck_pr_load_bool</p><p>+#define ck_pr_load_bool(src) ((bool)ck_pr_load_8((uint8_t *)(src)))</p><p>+#endif</p><p>+</p><p>+#endif</p><div><p>diff --git a/sys/dev/wg/version.h b/sys/dev/wg/version.h</p></div><p>@@ -0,0 +1 @@</p><p>+#define WIREGUARD_VERSION 20220615</p><div><p>diff --git a/sys/dev/wg/wg_cookie.c b/sys/dev/wg/wg_cookie.c</p></div><p>@@ -0,0 +1,500 @@</p><p>+/* SPDX-License-Identifier: ISC</p><p>+ *</p><p>+ * Copyright (C) 2015-2021 Jason A. Donenfeld &lt;Jason@zx2c4.com&gt;. All Rights Reserved.</p><p>+ * Copyright (C) 2019-2021 Matt Dunwoodie &lt;ncon@noconroy.net&gt;</p><p>+ */</p><p>+</p><p>+#include &#34;opt_inet.h&#34;</p><p>+#include &#34;opt_inet6.h&#34;</p><p>+</p><p>+#include &lt;sys/param.h&gt;</p><p>+#include &lt;sys/systm.h&gt;</p><p>+#include &lt;sys/kernel.h&gt;</p><p>+#include &lt;sys/lock.h&gt;</p><p>+#include &lt;sys/mutex.h&gt;</p><p>+#include &lt;sys/rwlock.h&gt;</p><p>+#include &lt;sys/socket.h&gt;</p><p>+#include &lt;crypto/siphash/siphash.h&gt;</p><p>+#include &lt;netinet/in.h&gt;</p><p>+#include &lt;vm/uma.h&gt;</p><p>+</p><p>+#include &#34;wg_cookie.h&#34;</p><p>+</p><p>+#define COOKIE_MAC1_KEY_LABEL	&#34;mac1----&#34;</p><p>+#define COOKIE_COOKIE_KEY_LABEL	&#34;cookie--&#34;</p><p>+#define COOKIE_SECRET_MAX_AGE	120</p><p>+#define COOKIE_SECRET_LATENCY	5</p><p>+</p><p>+/* Constants for initiation rate limiting */</p><p>+#define RATELIMIT_SIZE		(1 &lt;&lt; 13)</p><p>+#define RATELIMIT_MASK		(RATELIMIT_SIZE - 1)</p><p>+#define RATELIMIT_SIZE_MAX	(RATELIMIT_SIZE * 8)</p><p>+#define INITIATIONS_PER_SECOND	20</p><p>+#define INITIATIONS_BURSTABLE	5</p><p>+#define INITIATION_COST		(SBT_1S / INITIATIONS_PER_SECOND)</p><p>+#define TOKEN_MAX		(INITIATION_COST * INITIATIONS_BURSTABLE)</p><p>+#define ELEMENT_TIMEOUT		1</p><p>+#define IPV4_MASK_SIZE		4 /* Use all 4 bytes of IPv4 address */</p><p>+#define IPV6_MASK_SIZE		8 /* Use top 8 bytes (/64) of IPv6 address */</p><p>+</p><p>+struct ratelimit_key {</p><p>+	struct vnet *vnet;</p><p>+	uint8_t ip[IPV6_MASK_SIZE];</p><p>+};</p><p>+</p><p>+struct ratelimit_entry {</p><p>+	LIST_ENTRY(ratelimit_entry)	r_entry;</p><p>+	struct ratelimit_key		r_key;</p><p>+	sbintime_t			r_last_time;	/* sbinuptime */</p><p>+	uint64_t			r_tokens;</p><p>+};</p><p>+</p><p>+struct ratelimit {</p><p>+	uint8_t				rl_secret[SIPHASH_KEY_LENGTH];</p><p>+	struct mtx			rl_mtx;</p><p>+	struct callout			rl_gc;</p><p>+	LIST_HEAD(, ratelimit_entry)	rl_table[RATELIMIT_SIZE];</p><p>+	size_t				rl_table_num;</p><p>+};</p><p>+</p><p>+static void	precompute_key(uint8_t *,</p><p>+			const uint8_t[COOKIE_INPUT_SIZE], const char *);</p><p>+static void	macs_mac1(struct cookie_macs *, const void *, size_t,</p><p>+			const uint8_t[COOKIE_KEY_SIZE]);</p><p>+static void	macs_mac2(struct cookie_macs *, const void *, size_t,</p><p>+			const uint8_t[COOKIE_COOKIE_SIZE]);</p><p>+static int	timer_expired(sbintime_t, uint32_t, uint32_t);</p><p>+static void	make_cookie(struct cookie_checker *,</p><p>+			uint8_t[COOKIE_COOKIE_SIZE], struct sockaddr *);</p><p>+static void	ratelimit_init(struct ratelimit *);</p><p>+static void	ratelimit_deinit(struct ratelimit *);</p><p>+static void	ratelimit_gc_callout(void *);</p><p>+static void	ratelimit_gc_schedule(struct ratelimit *);</p><p>+static void	ratelimit_gc(struct ratelimit *, bool);</p><p>+static int	ratelimit_allow(struct ratelimit *, struct sockaddr *, struct vnet *);</p><p>+static uint64_t siphash13(const uint8_t [SIPHASH_KEY_LENGTH], const void *, size_t);</p><p>+</p><p>+static struct ratelimit ratelimit_v4;</p><p>+#ifdef INET6</p><p>+static struct ratelimit ratelimit_v6;</p><p>+#endif</p><p>+static uma_zone_t ratelimit_zone;</p><p>+</p><p>+/* Public Functions */</p><p>+int</p><p>+cookie_init(void)</p><p>+{</p><p>+	if ((ratelimit_zone = uma_zcreate(&#34;wg ratelimit&#34;,</p><p>+	    sizeof(struct ratelimit_entry), NULL, NULL, NULL, NULL, 0, 0)) == NULL)</p><p>+		return ENOMEM;</p><p>+</p><p>+	ratelimit_init(&amp;ratelimit_v4);</p><p>+#ifdef INET6</p><p>+	ratelimit_init(&amp;ratelimit_v6);</p><p>+#endif</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+void</p><p>+cookie_deinit(void)</p><p>+{</p><p>+	ratelimit_deinit(&amp;ratelimit_v4);</p><p>+#ifdef INET6</p><p>+	ratelimit_deinit(&amp;ratelimit_v6);</p><p>+#endif</p><p>+	uma_zdestroy(ratelimit_zone);</p><p>+}</p><p>+</p><p>+void</p><p>+cookie_checker_init(struct cookie_checker *cc)</p><p>+{</p><p>+	bzero(cc, sizeof(*cc));</p><p>+</p><p>+	rw_init(&amp;cc-&gt;cc_key_lock, &#34;cookie_checker_key&#34;);</p><p>+	mtx_init(&amp;cc-&gt;cc_secret_mtx, &#34;cookie_checker_secret&#34;, NULL, MTX_DEF);</p><p>+}</p><p>+</p><p>+void</p><p>+cookie_checker_free(struct cookie_checker *cc)</p><p>+{</p><p>+	rw_destroy(&amp;cc-&gt;cc_key_lock);</p><p>+	mtx_destroy(&amp;cc-&gt;cc_secret_mtx);</p><p>+	explicit_bzero(cc, sizeof(*cc));</p><p>+}</p><p>+</p><p>+void</p><p>+cookie_checker_update(struct cookie_checker *cc,</p><p>+    const uint8_t key[COOKIE_INPUT_SIZE])</p><p>+{</p><p>+	rw_wlock(&amp;cc-&gt;cc_key_lock);</p><p>+	if (key) {</p><p>+		precompute_key(cc-&gt;cc_mac1_key, key, COOKIE_MAC1_KEY_LABEL);</p><p>+		precompute_key(cc-&gt;cc_cookie_key, key, COOKIE_COOKIE_KEY_LABEL);</p><p>+	} else {</p><p>+		bzero(cc-&gt;cc_mac1_key, sizeof(cc-&gt;cc_mac1_key));</p><p>+		bzero(cc-&gt;cc_cookie_key, sizeof(cc-&gt;cc_cookie_key));</p><p>+	}</p><p>+	rw_wunlock(&amp;cc-&gt;cc_key_lock);</p><p>+}</p><p>+</p><p>+void</p><p>+cookie_checker_create_payload(struct cookie_checker *cc,</p><p>+    struct cookie_macs *macs, uint8_t nonce[COOKIE_NONCE_SIZE],</p><p>+    uint8_t ecookie[COOKIE_ENCRYPTED_SIZE], struct sockaddr *sa)</p><p>+{</p><p>+	uint8_t cookie[COOKIE_COOKIE_SIZE];</p><p>+</p><p>+	make_cookie(cc, cookie, sa);</p><p>+	arc4random_buf(nonce, COOKIE_NONCE_SIZE);</p><p>+</p><p>+	rw_rlock(&amp;cc-&gt;cc_key_lock);</p><p>+	xchacha20poly1305_encrypt(ecookie, cookie, COOKIE_COOKIE_SIZE,</p><p>+	    macs-&gt;mac1, COOKIE_MAC_SIZE, nonce, cc-&gt;cc_cookie_key);</p><p>+	rw_runlock(&amp;cc-&gt;cc_key_lock);</p><p>+</p><p>+	explicit_bzero(cookie, sizeof(cookie));</p><p>+}</p><p>+</p><p>+void</p><p>+cookie_maker_init(struct cookie_maker *cm, const uint8_t key[COOKIE_INPUT_SIZE])</p><p>+{</p><p>+	bzero(cm, sizeof(*cm));</p><p>+	precompute_key(cm-&gt;cm_mac1_key, key, COOKIE_MAC1_KEY_LABEL);</p><p>+	precompute_key(cm-&gt;cm_cookie_key, key, COOKIE_COOKIE_KEY_LABEL);</p><p>+	rw_init(&amp;cm-&gt;cm_lock, &#34;cookie_maker&#34;);</p><p>+}</p><p>+</p><p>+void</p><p>+cookie_maker_free(struct cookie_maker *cm)</p><p>+{</p><p>+	rw_destroy(&amp;cm-&gt;cm_lock);</p><p>+	explicit_bzero(cm, sizeof(*cm));</p><p>+}</p><p>+</p><p>+int</p><p>+cookie_maker_consume_payload(struct cookie_maker *cm,</p><p>+    uint8_t nonce[COOKIE_NONCE_SIZE], uint8_t ecookie[COOKIE_ENCRYPTED_SIZE])</p><p>+{</p><p>+	uint8_t cookie[COOKIE_COOKIE_SIZE];</p><p>+	int ret;</p><p>+</p><p>+	rw_rlock(&amp;cm-&gt;cm_lock);</p><p>+	if (!cm-&gt;cm_mac1_sent) {</p><p>+		ret = ETIMEDOUT;</p><p>+		goto error;</p><p>+	}</p><p>+</p><p>+	if (!xchacha20poly1305_decrypt(cookie, ecookie, COOKIE_ENCRYPTED_SIZE,</p><p>+	    cm-&gt;cm_mac1_last, COOKIE_MAC_SIZE, nonce, cm-&gt;cm_cookie_key)) {</p><p>+		ret = EINVAL;</p><p>+		goto error;</p><p>+	}</p><p>+	rw_runlock(&amp;cm-&gt;cm_lock);</p><p>+</p><p>+	rw_wlock(&amp;cm-&gt;cm_lock);</p><p>+	memcpy(cm-&gt;cm_cookie, cookie, COOKIE_COOKIE_SIZE);</p><p>+	cm-&gt;cm_cookie_birthdate = getsbinuptime();</p><p>+	cm-&gt;cm_cookie_valid = true;</p><p>+	cm-&gt;cm_mac1_sent = false;</p><p>+	rw_wunlock(&amp;cm-&gt;cm_lock);</p><p>+</p><p>+	return 0;</p><p>+error:</p><p>+	rw_runlock(&amp;cm-&gt;cm_lock);</p><p>+	return ret;</p><p>+}</p><p>+</p><p>+void</p><p>+cookie_maker_mac(struct cookie_maker *cm, struct cookie_macs *macs, void *buf,</p><p>+    size_t len)</p><p>+{</p><p>+	rw_wlock(&amp;cm-&gt;cm_lock);</p><p>+	macs_mac1(macs, buf, len, cm-&gt;cm_mac1_key);</p><p>+	memcpy(cm-&gt;cm_mac1_last, macs-&gt;mac1, COOKIE_MAC_SIZE);</p><p>+	cm-&gt;cm_mac1_sent = true;</p><p>+</p><p>+	if (cm-&gt;cm_cookie_valid &amp;&amp;</p><p>+	    !timer_expired(cm-&gt;cm_cookie_birthdate,</p><p>+	    COOKIE_SECRET_MAX_AGE - COOKIE_SECRET_LATENCY, 0)) {</p><p>+		macs_mac2(macs, buf, len, cm-&gt;cm_cookie);</p><p>+	} else {</p><p>+		bzero(macs-&gt;mac2, COOKIE_MAC_SIZE);</p><p>+		cm-&gt;cm_cookie_valid = false;</p><p>+	}</p><p>+	rw_wunlock(&amp;cm-&gt;cm_lock);</p><p>+}</p><p>+</p><p>+int</p><p>+cookie_checker_validate_macs(struct cookie_checker *cc, struct cookie_macs *macs,</p><p>+    void *buf, size_t len, bool check_cookie, struct sockaddr *sa, struct vnet *vnet)</p><p>+{</p><p>+	struct cookie_macs our_macs;</p><p>+	uint8_t cookie[COOKIE_COOKIE_SIZE];</p><p>+</p><p>+	/* Validate incoming MACs */</p><p>+	rw_rlock(&amp;cc-&gt;cc_key_lock);</p><p>+	macs_mac1(&amp;our_macs, buf, len, cc-&gt;cc_mac1_key);</p><p>+	rw_runlock(&amp;cc-&gt;cc_key_lock);</p><p>+</p><p>+	/* If mac1 is invald, we want to drop the packet */</p><p>+	if (timingsafe_bcmp(our_macs.mac1, macs-&gt;mac1, COOKIE_MAC_SIZE) != 0)</p><p>+		return EINVAL;</p><p>+</p><p>+	if (check_cookie) {</p><p>+		make_cookie(cc, cookie, sa);</p><p>+		macs_mac2(&amp;our_macs, buf, len, cookie);</p><p>+</p><p>+		/* If the mac2 is invalid, we want to send a cookie response */</p><p>+		if (timingsafe_bcmp(our_macs.mac2, macs-&gt;mac2, COOKIE_MAC_SIZE) != 0)</p><p>+			return EAGAIN;</p><p>+</p><p>+		/* If the mac2 is valid, we may want rate limit the peer.</p><p>+		 * ratelimit_allow will return either 0 or ECONNREFUSED,</p><p>+		 * implying there is no ratelimiting, or we should ratelimit</p><p>+		 * (refuse) respectively. */</p><p>+		if (sa-&gt;sa_family == AF_INET)</p><p>+			return ratelimit_allow(&amp;ratelimit_v4, sa, vnet);</p><p>+#ifdef INET6</p><p>+		else if (sa-&gt;sa_family == AF_INET6)</p><p>+			return ratelimit_allow(&amp;ratelimit_v6, sa, vnet);</p><p>+#endif</p><p>+		else</p><p>+			return EAFNOSUPPORT;</p><p>+	}</p><p>+</p><p>+	return 0;</p><p>+}</p><p>+</p><p>+/* Private functions */</p><p>+static void</p><p>+precompute_key(uint8_t *key, const uint8_t input[COOKIE_INPUT_SIZE],</p><p>+    const char *label)</p><p>+{</p><p>+	struct blake2s_state blake;</p><p>+	blake2s_init(&amp;blake, COOKIE_KEY_SIZE);</p><p>+	blake2s_update(&amp;blake, label, strlen(label));</p><p>+	blake2s_update(&amp;blake, input, COOKIE_INPUT_SIZE);</p><p>+	blake2s_final(&amp;blake, key);</p><p>+}</p><p>+</p><p>+static void</p><p>+macs_mac1(struct cookie_macs *macs, const void *buf, size_t len,</p><p>+    const uint8_t key[COOKIE_KEY_SIZE])</p><p>+{</p><p>+	struct blake2s_state state;</p><p>+	blake2s_init_key(&amp;state, COOKIE_MAC_SIZE, key, COOKIE_KEY_SIZE);</p><p>+	blake2s_update(&amp;state, buf, len);</p><p>+	blake2s_final(&amp;state, macs-&gt;mac1);</p><p>+}</p><p>+</p><p>+static void</p><p>+macs_mac2(struct cookie_macs *macs, const void *buf, size_t len,</p><p>+    const uint8_t key[COOKIE_COOKIE_SIZE])</p><p>+{</p><p>+	struct blake2s_state state;</p><p>+	blake2s_init_key(&amp;state, COOKIE_MAC_SIZE, key, COOKIE_COOKIE_SIZE);</p><p>+	blake2s_update(&amp;state, buf, len);</p><p>+	blake2s_update(&amp;state, macs-&gt;mac1, COOKIE_MAC_SIZE);</p><p>+	blake2s_final(&amp;state, macs-&gt;mac2);</p><p>+}</p><p>+</p><p>+static __inline int</p><p>+timer_expired(sbintime_t timer, uint32_t sec, uint32_t nsec)</p><p>+{</p><p>+	sbintime_t now = getsbinuptime();</p><p>+	return (now &gt; (timer + sec * SBT_1S + nstosbt(nsec))) ? ETIMEDOUT : 0;</p><p>+}</p><p>+</p><p>+static void</p><p>+make_cookie(struct cookie_checker *cc, uint8_t cookie[COOKIE_COOKIE_SIZE],</p><p>+    struct sockaddr *sa)</p><p>+{</p><p>+	struct blake2s_state state;</p><p>+</p><p>+	mtx_lock(&amp;cc-&gt;cc_secret_mtx);</p><p>+	if (timer_expired(cc-&gt;cc_secret_birthdate,</p><p>+	    COOKIE_SECRET_MAX_AGE, 0)) {</p><p>+		arc4random_buf(cc-&gt;cc_secret, COOKIE_SECRET_SIZE);</p><p>+		cc-&gt;cc_secret_birthdate = getsbinuptime();</p><p>+	}</p><p>+	blake2s_init_key(&amp;state, COOKIE_COOKIE_SIZE, cc-&gt;cc_secret,</p><p>+	    COOKIE_SECRET_SIZE);</p><p>+	mtx_unlock(&amp;cc-&gt;cc_secret_mtx);</p><p>+</p><p>+	if (sa-&gt;sa_family == AF_INET) {</p><p>+		blake2s_update(&amp;state, (uint8_t *)&amp;satosin(sa)-&gt;sin_addr,</p><p>+				sizeof(struct in_addr));</p><p>+		blake2s_update(&amp;state, (uint8_t *)&amp;satosin(sa)-&gt;sin_port,</p><p>+				sizeof(in_port_t));</p><p>+		blake2s_final(&amp;state, cookie);</p><p>+#ifdef INET6</p><p>+	} else if (sa-&gt;sa_family == AF_INET6) {</p><p>+		blake2s_update(&amp;state, (uint8_t *)&amp;satosin6(sa)-&gt;sin6_addr,</p><p>+				sizeof(struct in6_addr));</p><p>+		blake2s_update(&amp;state, (uint8_t *)&amp;satosin6(sa)-&gt;sin6_port,</p><p>+				sizeof(in_port_t));</p><p>+		blake2s_final(&amp;state, cookie);</p><p>+#endif</p><p>+	} else {</p><p>+		arc4random_buf(cookie, COOKIE_COOKIE_SIZE);</p><p>+	}</p><p>+}</p><p>+</p><p>+static void</p><p>+ratelimit_init(struct ratelimit *rl)</p><p>+{</p><p>+	size_t i;</p><p>+	mtx_init(&amp;rl-&gt;rl_mtx, &#34;ratelimit_lock&#34;, NULL, MTX_DEF);</p><p>+	callout_init_mtx(&amp;rl-&gt;rl_gc, &amp;rl-&gt;rl_mtx, 0);</p><p>+	arc4random_buf(rl-&gt;rl_secret, sizeof(rl-&gt;rl_secret));</p><p>+	for (i = 0; i &lt; RATELIMIT_SIZE; i++)</p><p>+		LIST_INIT(&amp;rl-&gt;rl_table[i]);</p><p>+	rl-&gt;rl_table_num = 0;</p><p>+}</p><p>+</p><p>+static void</p><p>+ratelimit_deinit(struct ratelimit *rl)</p><p>+{</p><p>+	mtx_lock(&amp;rl-&gt;rl_mtx);</p><p>+	callout_stop(&amp;rl-&gt;rl_gc);</p><p>+	ratelimit_gc(rl, true);</p><p>+	mtx_unlock(&amp;rl-&gt;rl_mtx);</p><p>+	mtx_destroy(&amp;rl-&gt;rl_mtx);</p><p>+}</p><p>+</p><p>+static void</p><p>+ratelimit_gc_callout(void *_rl)</p><p>+{</p><p>+	/* callout will lock rl_mtx for us */</p><p>+	ratelimit_gc(_rl, false);</p><p>+}</p><p>+</p><p>+static void</p><p>+ratelimit_gc_schedule(struct ratelimit *rl)</p><p>+{</p><p>+	/* Trigger another GC if needed. There is no point calling GC if there</p><p>+	 * are no entries in the table. We also want to ensure that GC occurs</p><p>+	 * on a regular interval, so don&#39;t override a currently pending GC.</p><p>+	 *</p><p>+	 * In the case of a forced ratelimit_gc, there will be no entries left</p><p>+	 * so we will will not schedule another GC. */</p><p>+	if (rl-&gt;rl_table_num &gt; 0 &amp;&amp; !callout_pending(&amp;rl-&gt;rl_gc))</p><p>+		callout_reset(&amp;rl-&gt;rl_gc, ELEMENT_TIMEOUT * hz,</p><p>+		    ratelimit_gc_callout, rl);</p><p>+}</p><p>+</p><p>+static void</p><p>+ratelimit_gc(struct ratelimit *rl, bool force)</p><p>+{</p><p>+	size_t i;</p><p>+	struct ratelimit_entry *r, *tr;</p><p>+	sbintime_t expiry;</p><p>+</p><p>+	mtx_assert(&amp;rl-&gt;rl_mtx, MA_OWNED);</p><p>+</p><p>+	if (rl-&gt;rl_table_num == 0)</p><p>+		return;</p><p>+</p><p>+	expiry = getsbinuptime() - ELEMENT_TIMEOUT * SBT_1S;</p><p>+</p><p>+	for (i = 0; i &lt; RATELIMIT_SIZE; i++) {</p><p>+		LIST_FOREACH_SAFE(r, &amp;rl-&gt;rl_table[i], r_entry, tr) {</p><p>+			if (r-&gt;r_last_time &lt; expiry || force) {</p><p>+				rl-&gt;rl_table_num--;</p><p>+				LIST_REMOVE(r, r_entry);</p><p>+				uma_zfree(ratelimit_zone, r);</p><p>+			}</p><p>+		}</p><p>+	}</p><p>+</p><p>+	ratelimit_gc_schedule(rl);</p><p>+}</p><p>+</p><p>+static int</p><p>+ratelimit_allow(struct ratelimit *rl, struct sockaddr *sa, struct vnet *vnet)</p><p>+{</p><p>+	uint64_t bucket, tokens;</p><p>+	sbintime_t diff, now;</p><p>+	struct ratelimit_entry *r;</p><p>+	int ret = ECONNREFUSED;</p><p>+	struct ratelimit_key key = { .vnet = vnet };</p><p>+	size_t len = sizeof(key);</p><p>+</p><p>+	if (sa-&gt;sa_family == AF_INET) {</p><p>+		memcpy(key.ip, &amp;satosin(sa)-&gt;sin_addr, IPV4_MASK_SIZE);</p><p>+		len -= IPV6_MASK_SIZE - IPV4_MASK_SIZE;</p><p>+	}</p><p>+#ifdef INET6</p><p>+	else if (sa-&gt;sa_family == AF_INET6)</p><p>+		memcpy(key.ip, &amp;satosin6(sa)-&gt;sin6_addr, IPV6_MASK_SIZE);</p><p>+#endif</p><p>+	else</p><p>+		return ret;</p><p>+</p><p>+	bucket = siphash13(rl-&gt;rl_secret, &amp;key, len) &amp; RATELIMIT_MASK;</p><p>+	mtx_lock(&amp;rl-&gt;rl_mtx);</p><p>+</p><p>+	LIST_FOREACH(r, &amp;rl-&gt;rl_table[bucket], r_entry) {</p><p>+		if (bcmp(&amp;r-&gt;r_key, &amp;key, len) != 0)</p><p>+			continue;</p><p>+</p><p>+		/* If we get to here, we&#39;ve found an entry for the endpoint.</p><p>+		 * We apply standard token bucket, by calculating the time</p><p>+		 * lapsed since our last_time, adding that, ensuring that we</p><p>+		 * cap the tokens at TOKEN_MAX. If the endpoint has no tokens</p><p>+		 * left (that is tokens &lt;= INITIATION_COST) then we block the</p><p>+		 * request, otherwise we subtract the INITITIATION_COST and</p><p>+		 * return OK. */</p><p>+		now = getsbinuptime();</p><p>+		diff = now - r-&gt;r_last_time;</p><p>+		r-&gt;r_last_time = now;</p><p>+</p><p>+		tokens = r-&gt;r_tokens + diff;</p><p>+</p><p>+		if (tokens &gt; TOKEN_MAX)</p><p>+			tokens = TOKEN_MAX;</p><p>+</p><p>+		if (tokens &gt;= INITIATION_COST) {</p><p>+			r-&gt;r_tokens = tokens - INITIATION_COST;</p><p>+			goto ok;</p><p>+		} else {</p><p>+			r-&gt;r_tokens = tokens;</p><p>+			goto error;</p><p>+		}</p><p>+	}</p><p>+</p><p>+	/* If we get to here, we didn&#39;t have an entry for the endpoint, let&#39;s</p><p>+	 * add one if we have space. */</p><p>+	if (rl-&gt;rl_table_num &gt;= RATELIMIT_SIZE_MAX)</p><p>+		goto error;</p><p>+</p><p>+	/* Goto error if out of memory */</p><p>+	if ((r = uma_zalloc(ratelimit_zone, M_NOWAIT | M_ZERO)) == NULL)</p><p>+		goto error;</p><p>+</p><p>+	rl-&gt;rl_table_num++;</p><p>+</p><p>+	/* Insert entry into the hashtable and ensure it&#39;s initialised */</p><p>+	LIST_INSERT_HEAD(&amp;rl-&gt;rl_table[bucket], r, r_entry);</p><p>+	r-&gt;r_key = key;</p><p>+	r-&gt;r_last_time = getsbinuptime();</p><p>+	r-&gt;r_tokens = TOKEN_MAX - INITIATION_COST;</p><p>+</p><p>+	/* If we&#39;ve added a new entry, let&#39;s trigger GC. */</p><p>+	ratelimit_gc_schedule(rl);</p><p>+ok:</p><p>+	ret = 0;</p><p>+error:</p><p>+	mtx_unlock(&amp;rl-&gt;rl_mtx);</p><p>+	return ret;</p><p>+}</p><p>+</p><p>+static uint64_t siphash13(const uint8_t key[SIPHASH_KEY_LENGTH], const void *src, size_t len)</p><p>+{</p><p>+	SIPHASH_CTX ctx;</p><p>+	return (SipHashX(&amp;ctx, 1, 3, key, src, len));</p><p>+}</p><p>+</p><p>+#ifdef SELFTESTS</p><p>+#include &#34;selftest/cookie.c&#34;</p><p>+#endif /* SELFTESTS */</p><div><p>diff --git a/sys/dev/wg/wg_cookie.h b/sys/dev/wg/wg_cookie.h</p></div><p>@@ -0,0 +1,72 @@</p><p>+/* SPDX-License-Identifier: ISC</p><p>+ *</p><p>+ * Copyright (C) 2015-2021 Jason A. Donenfeld &lt;Jason@zx2c4.com&gt;. All Rights Reserved.</p><p>+ * Copyright (C) 2019-2021 Matt Dunwoodie &lt;ncon@noconroy.net&gt;</p><p>+ */</p><p>+</p><p>+#ifndef __COOKIE_H__</p><p>+#define __COOKIE_H__</p><p>+</p><p>+#include &#34;crypto.h&#34;</p><p>+</p><p>+#define COOKIE_MAC_SIZE		16</p><p>+#define COOKIE_KEY_SIZE		32</p><p>+#define COOKIE_NONCE_SIZE	XCHACHA20POLY1305_NONCE_SIZE</p><p>+#define COOKIE_COOKIE_SIZE	16</p><p>+#define COOKIE_SECRET_SIZE	32</p><p>+#define COOKIE_INPUT_SIZE	32</p><p>+#define COOKIE_ENCRYPTED_SIZE	(COOKIE_COOKIE_SIZE + COOKIE_MAC_SIZE)</p><p>+</p><p>+struct vnet;</p><p>+</p><p>+struct cookie_macs {</p><p>+	uint8_t	mac1[COOKIE_MAC_SIZE];</p><p>+	uint8_t	mac2[COOKIE_MAC_SIZE];</p><p>+};</p><p>+</p><p>+struct cookie_maker {</p><p>+	uint8_t		cm_mac1_key[COOKIE_KEY_SIZE];</p><p>+	uint8_t		cm_cookie_key[COOKIE_KEY_SIZE];</p><p>+</p><p>+	struct rwlock	cm_lock;</p><p>+	bool		cm_cookie_valid;</p><p>+	uint8_t		cm_cookie[COOKIE_COOKIE_SIZE];</p><p>+	sbintime_t	cm_cookie_birthdate;	/* sbinuptime */</p><p>+	bool		cm_mac1_sent;</p><p>+	uint8_t		cm_mac1_last[COOKIE_MAC_SIZE];</p><p>+};</p><p>+</p><p>+struct cookie_checker {</p><p>+	struct rwlock	cc_key_lock;</p><p>+	uint8_t		cc_mac1_key[COOKIE_KEY_SIZE];</p><p>+	uint8_t		cc_cookie_key[COOKIE_KEY_SIZE];</p><p>+</p><p>+	struct mtx	cc_secret_mtx;</p><p>+	sbintime_t	cc_secret_birthdate;	/* sbinuptime */</p><p>+	uint8_t		cc_secret[COOKIE_SECRET_SIZE];</p><p>+};</p><p>+</p><p>+int	cookie_init(void);</p><p>+void	cookie_deinit(void);</p><p>+void	cookie_checker_init(struct cookie_checker *);</p><p>+void	cookie_checker_free(struct cookie_checker *);</p><p>+void	cookie_checker_update(struct cookie_checker *,</p><p>+	    const uint8_t[COOKIE_INPUT_SIZE]);</p><p>+void	cookie_checker_create_payload(struct cookie_checker *,</p><p>+	    struct cookie_macs *cm, uint8_t[COOKIE_NONCE_SIZE],</p><p>+	    uint8_t [COOKIE_ENCRYPTED_SIZE], struct sockaddr *);</p><p>+void	cookie_maker_init(struct cookie_maker *, const uint8_t[COOKIE_INPUT_SIZE]);</p><p>+void	cookie_maker_free(struct cookie_maker *);</p><p>+int	cookie_maker_consume_payload(struct cookie_maker *,</p><p>+	    uint8_t[COOKIE_NONCE_SIZE], uint8_t[COOKIE_ENCRYPTED_SIZE]);</p><p>+void	cookie_maker_mac(struct cookie_maker *, struct cookie_macs *,</p><p>+	    void *, size_t);</p><p>+int	cookie_checker_validate_macs(struct cookie_checker *,</p><p>+	    struct cookie_macs *, void *, size_t, bool, struct sockaddr *,</p><p>+	    struct vnet *);</p><p>+</p><p>+#ifdef SELFTESTS</p><p>+bool	cookie_selftest(void);</p><p>+#endif /* SELFTESTS */</p><p>+</p><p>+#endif /* __COOKIE_H__ */</p><div><p>diff --git a/sys/dev/wg/wg_crypto.c b/sys/dev/wg/wg_crypto.c</p></div><p>@@ -0,0 +1,1830 @@</p><p>+/* SPDX-License-Identifier: MIT</p><p>+ *</p><p>+ * Copyright (C) 2015-2021 Jason A. Donenfeld &lt;Jason@zx2c4.com&gt;. All Rights Reserved.</p><p>+ * Copyright (c) 2022 The FreeBSD Foundation</p><p>+ */</p><p>+</p><p>+#include &lt;sys/types.h&gt;</p><p>+#include &lt;sys/systm.h&gt;</p><p>+#include &lt;sys/endian.h&gt;</p><p>+#include &lt;sys/mbuf.h&gt;</p><p>+#include &lt;opencrypto/cryptodev.h&gt;</p><p>+</p><p>+#include &#34;crypto.h&#34;</p><p>+</p><p>+#ifndef COMPAT_NEED_CHACHA20POLY1305_MBUF</p><p>+static crypto_session_t chacha20_poly1305_sid;</p><p>+#endif</p><p>+</p><p>+#ifndef ARRAY_SIZE</p><p>+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))</p><p>+#endif</p><p>+#ifndef noinline</p><p>+#define noinline __attribute__((noinline))</p><p>+#endif</p><p>+#ifndef __aligned</p><p>+#define __aligned(x) __attribute__((aligned(x)))</p><p>+#endif</p><p>+#ifndef DIV_ROUND_UP</p><p>+#define DIV_ROUND_UP(n,d) (((n) + (d) - 1) / (d))</p><p>+#endif</p><p>+</p><p>+#define le32_to_cpup(a) le32toh(*(a))</p><p>+#define le64_to_cpup(a) le64toh(*(a))</p><p>+#define cpu_to_le32(a) htole32(a)</p><p>+#define cpu_to_le64(a) htole64(a)</p><p>+</p><p>+static inline __unused uint32_t get_unaligned_le32(const uint8_t *a)</p><p>+{</p><p>+	uint32_t l;</p><p>+	__builtin_memcpy(&amp;l, a, sizeof(l));</p><p>+	return le32_to_cpup(&amp;l);</p><p>+}</p><p>+static inline __unused uint64_t get_unaligned_le64(const uint8_t *a)</p><p>+{</p><p>+	uint64_t l;</p><p>+	__builtin_memcpy(&amp;l, a, sizeof(l));</p><p>+	return le64_to_cpup(&amp;l);</p><p>+}</p><p>+static inline __unused void put_unaligned_le32(uint32_t s, uint8_t *d)</p><p>+{</p><p>+	uint32_t l = cpu_to_le32(s);</p><p>+	__builtin_memcpy(d, &amp;l, sizeof(l));</p><p>+}</p><p>+static inline __unused void cpu_to_le32_array(uint32_t *buf, unsigned int words)</p><p>+{</p><p>+        while (words--) {</p><p>+		*buf = cpu_to_le32(*buf);</p><p>+		++buf;</p><p>+	}</p><p>+}</p><p>+static inline __unused void le32_to_cpu_array(uint32_t *buf, unsigned int words)</p><p>+{</p><p>+        while (words--) {</p><p>+		*buf = le32_to_cpup(buf);</p><p>+		++buf;</p><p>+        }</p><p>+}</p><p>+static inline __unused uint32_t rol32(uint32_t word, unsigned int shift)</p><p>+{</p><p>+        return (word &lt;&lt; (shift &amp; 31)) | (word &gt;&gt; ((-shift) &amp; 31));</p><p>+}</p><p>+static inline __unused uint32_t ror32(uint32_t word, unsigned int shift)</p><p>+{</p><p>+	return (word &gt;&gt; (shift &amp; 31)) | (word &lt;&lt; ((-shift) &amp; 31));</p><p>+}</p><p>+</p><p>+#if defined(COMPAT_NEED_CHACHA20POLY1305) || defined(COMPAT_NEED_CHACHA20POLY1305_MBUF)</p><p>+static void xor_cpy(uint8_t *dst, const uint8_t *src1, const uint8_t *src2, size_t len)</p><p>+{</p><p>+	size_t i;</p><p>+</p><p>+	for (i = 0; i &lt; len; ++i)</p><p>+		dst[i] = src1[i] ^ src2[i];</p><p>+}</p><p>+</p><p>+#define QUARTER_ROUND(x, a, b, c, d) ( \</p><p>+	x[a] += x[b], \</p><p>+	x[d] = rol32((x[d] ^ x[a]), 16), \</p><p>+	x[c] += x[d], \</p><p>+	x[b] = rol32((x[b] ^ x[c]), 12), \</p><p>+	x[a] += x[b], \</p><p>+	x[d] = rol32((x[d] ^ x[a]), 8), \</p><p>+	x[c] += x[d], \</p><p>+	x[b] = rol32((x[b] ^ x[c]), 7) \</p><p>+)</p><p>+</p><p>+#define C(i, j) (i * 4 + j)</p><p>+</p><p>+#define DOUBLE_ROUND(x) ( \</p><p>+	/* Column Round */ \</p><p>+	QUARTER_ROUND(x, C(0, 0), C(1, 0), C(2, 0), C(3, 0)), \</p><p>+	QUARTER_ROUND(x, C(0, 1), C(1, 1), C(2, 1), C(3, 1)), \</p><p>+	QUARTER_ROUND(x, C(0, 2), C(1, 2), C(2, 2), C(3, 2)), \</p><p>+	QUARTER_ROUND(x, C(0, 3), C(1, 3), C(2, 3), C(3, 3)), \</p><p>+	/* Diagonal Round */ \</p><p>+	QUARTER_ROUND(x, C(0, 0), C(1, 1), C(2, 2), C(3, 3)), \</p><p>+	QUARTER_ROUND(x, C(0, 1), C(1, 2), C(2, 3), C(3, 0)), \</p><p>+	QUARTER_ROUND(x, C(0, 2), C(1, 3), C(2, 0), C(3, 1)), \</p><p>+	QUARTER_ROUND(x, C(0, 3), C(1, 0), C(2, 1), C(3, 2)) \</p><p>+)</p><p>+</p><p>+#define TWENTY_ROUNDS(x) ( \</p><p>+	DOUBLE_ROUND(x), \</p><p>+	DOUBLE_ROUND(x), \</p><p>+	DOUBLE_ROUND(x), \</p><p>+	DOUBLE_ROUND(x), \</p><p>+	DOUBLE_ROUND(x), \</p><p>+	DOUBLE_ROUND(x), \</p><p>+	DOUBLE_ROUND(x), \</p><p>+	DOUBLE_ROUND(x), \</p><p>+	DOUBLE_ROUND(x), \</p><p>+	DOUBLE_ROUND(x) \</p><p>+)</p><p>+</p><p>+enum chacha20_lengths {</p><p>+	CHACHA20_NONCE_SIZE = 16,</p><p>+	CHACHA20_KEY_SIZE = 32,</p><p>+	CHACHA20_KEY_WORDS = CHACHA20_KEY_SIZE / sizeof(uint32_t),</p><p>+	CHACHA20_BLOCK_SIZE = 64,</p><p>+	CHACHA20_BLOCK_WORDS = CHACHA20_BLOCK_SIZE / sizeof(uint32_t),</p><p>+	HCHACHA20_NONCE_SIZE = CHACHA20_NONCE_SIZE,</p><p>+	HCHACHA20_KEY_SIZE = CHACHA20_KEY_SIZE</p><p>+};</p><p>+</p><p>+enum chacha20_constants { /* expand 32-byte k */</p><p>+	CHACHA20_CONSTANT_EXPA = 0x61707865U,</p><p>+	CHACHA20_CONSTANT_ND_3 = 0x3320646eU,</p><p>+	CHACHA20_CONSTANT_2_BY = 0x79622d32U,</p><p>+	CHACHA20_CONSTANT_TE_K = 0x6b206574U</p><p>+};</p><p>+</p><p>+struct chacha20_ctx {</p><p>+	union {</p><p>+		uint32_t state[16];</p><p>+		struct {</p><p>+			uint32_t constant[4];</p><p>+			uint32_t key[8];</p><p>+			uint32_t counter[4];</p><p>+		};</p><p>+	};</p><p>+};</p><p>+</p><p>+static void chacha20_init(struct chacha20_ctx *ctx,</p><p>+			  const uint8_t key[CHACHA20_KEY_SIZE],</p><p>+			  const uint64_t nonce)</p><p>+{</p><p>+	ctx-&gt;constant[0] = CHACHA20_CONSTANT_EXPA;</p><p>+	ctx-&gt;constant[1] = CHACHA20_CONSTANT_ND_3;</p><p>+	ctx-&gt;constant[2] = CHACHA20_CONSTANT_2_BY;</p><p>+	ctx-&gt;constant[3] = CHACHA20_CONSTANT_TE_K;</p><p>+	ctx-&gt;key[0] = get_unaligned_le32(key + 0);</p><p>+	ctx-&gt;key[1] = get_unaligned_le32(key + 4);</p><p>+	ctx-&gt;key[2] = get_unaligned_le32(key + 8);</p><p>+	ctx-&gt;key[3] = get_unaligned_le32(key + 12);</p><p>+	ctx-&gt;key[4] = get_unaligned_le32(key + 16);</p><p>+	ctx-&gt;key[5] = get_unaligned_le32(key + 20);</p><p>+	ctx-&gt;key[6] = get_unaligned_le32(key + 24);</p><p>+	ctx-&gt;key[7] = get_unaligned_le32(key + 28);</p><p>+	ctx-&gt;counter[0] = 0;</p><p>+	ctx-&gt;counter[1] = 0;</p><p>+	ctx-&gt;counter[2] = nonce &amp; 0xffffffffU;</p><p>+	ctx-&gt;counter[3] = nonce &gt;&gt; 32;</p><p>+}</p><p>+</p><p>+static void chacha20_block(struct chacha20_ctx *ctx, uint32_t *stream)</p><p>+{</p><p>+	uint32_t x[CHACHA20_BLOCK_WORDS];</p><p>+	int i;</p><p>+</p><p>+	for (i = 0; i &lt; ARRAY_SIZE(x); ++i)</p><p>+		x[i] = ctx-&gt;state[i];</p><p>+</p><p>+	TWENTY_ROUNDS(x);</p><p>+</p><p>+	for (i = 0; i &lt; ARRAY_SIZE(x); ++i)</p><p>+		stream[i] = cpu_to_le32(x[i] + ctx-&gt;state[i]);</p><p>+</p><p>+	ctx-&gt;counter[0] += 1;</p><p>+}</p><p>+</p><p>+static void chacha20(struct chacha20_ctx *ctx, uint8_t *out, const uint8_t *in,</p><p>+		     uint32_t len)</p><p>+{</p><p>+	uint32_t buf[CHACHA20_BLOCK_WORDS];</p><p>+</p><p>+	while (len &gt;= CHACHA20_BLOCK_SIZE) {</p><p>+		chacha20_block(ctx, buf);</p><p>+		xor_cpy(out, in, (uint8_t *)buf, CHACHA20_BLOCK_SIZE);</p><p>+		len -= CHACHA20_BLOCK_SIZE;</p><p>+		out += CHACHA20_BLOCK_SIZE;</p><p>+		in += CHACHA20_BLOCK_SIZE;</p><p>+	}</p><p>+	if (len) {</p><p>+		chacha20_block(ctx, buf);</p><p>+		xor_cpy(out, in, (uint8_t *)buf, len);</p><p>+	}</p><p>+}</p><p>+</p><p>+static void hchacha20(uint32_t derived_key[CHACHA20_KEY_WORDS],</p><p>+		      const uint8_t nonce[HCHACHA20_NONCE_SIZE],</p><p>+		      const uint8_t key[HCHACHA20_KEY_SIZE])</p><p>+{</p><p>+	uint32_t x[] = { CHACHA20_CONSTANT_EXPA,</p><p>+		    CHACHA20_CONSTANT_ND_3,</p><p>+		    CHACHA20_CONSTANT_2_BY,</p><p>+		    CHACHA20_CONSTANT_TE_K,</p><p>+		    get_unaligned_le32(key +  0),</p><p>+		    get_unaligned_le32(key +  4),</p><p>+		    get_unaligned_le32(key +  8),</p><p>+		    get_unaligned_le32(key + 12),</p><p>+		    get_unaligned_le32(key + 16),</p><p>+		    get_unaligned_le32(key + 20),</p><p>+		    get_unaligned_le32(key + 24),</p><p>+		    get_unaligned_le32(key + 28),</p><p>+		    get_unaligned_le32(nonce +  0),</p><p>+		    get_unaligned_le32(nonce +  4),</p><p>+		    get_unaligned_le32(nonce +  8),</p><p>+		    get_unaligned_le32(nonce + 12)</p><p>+	};</p><p>+</p><p>+	TWENTY_ROUNDS(x);</p><p>+</p><p>+	memcpy(derived_key + 0, x +  0, sizeof(uint32_t) * 4);</p><p>+	memcpy(derived_key + 4, x + 12, sizeof(uint32_t) * 4);</p><p>+}</p><p>+</p><p>+enum poly1305_lengths {</p><p>+	POLY1305_BLOCK_SIZE = 16,</p><p>+	POLY1305_KEY_SIZE = 32,</p><p>+	POLY1305_MAC_SIZE = 16</p><p>+};</p><p>+</p><p>+struct poly1305_internal {</p><p>+	uint32_t h[5];</p><p>+	uint32_t r[5];</p><p>+	uint32_t s[4];</p><p>+};</p><p>+</p><p>+struct poly1305_ctx {</p><p>+	struct poly1305_internal state;</p><p>+	uint32_t nonce[4];</p><p>+	uint8_t data[POLY1305_BLOCK_SIZE];</p><p>+	size_t num;</p><p>+};</p><p>+</p><p>+static void poly1305_init_core(struct poly1305_internal *st,</p><p>+			       const uint8_t key[16])</p><p>+{</p><p>+	/* r &amp;= 0xffffffc0ffffffc0ffffffc0fffffff */</p><p>+	st-&gt;r[0] = (get_unaligned_le32(&amp;key[0])) &amp; 0x3ffffff;</p><p>+	st-&gt;r[1] = (get_unaligned_le32(&amp;key[3]) &gt;&gt; 2) &amp; 0x3ffff03;</p><p>+	st-&gt;r[2] = (get_unaligned_le32(&amp;key[6]) &gt;&gt; 4) &amp; 0x3ffc0ff;</p><p>+	st-&gt;r[3] = (get_unaligned_le32(&amp;key[9]) &gt;&gt; 6) &amp; 0x3f03fff;</p><p>+	st-&gt;r[4] = (get_unaligned_le32(&amp;key[12]) &gt;&gt; 8) &amp; 0x00fffff;</p><p>+</p><p>+	/* s = 5*r */</p><p>+	st-&gt;s[0] = st-&gt;r[1] * 5;</p><p>+	st-&gt;s[1] = st-&gt;r[2] * 5;</p><p>+	st-&gt;s[2] = st-&gt;r[3] * 5;</p><p>+	st-&gt;s[3] = st-&gt;r[4] * 5;</p><p>+</p><p>+	/* h = 0 */</p><p>+	st-&gt;h[0] = 0;</p><p>+	st-&gt;h[1] = 0;</p><p>+	st-&gt;h[2] = 0;</p><p>+	st-&gt;h[3] = 0;</p><p>+	st-&gt;h[4] = 0;</p><p>+}</p><p>+</p><p>+static void poly1305_blocks_core(struct poly1305_internal *st,</p><p>+				 const uint8_t *input, size_t len,</p><p>+				 const uint32_t padbit)</p><p>+{</p><p>+	const uint32_t hibit = padbit &lt;&lt; 24;</p><p>+	uint32_t r0, r1, r2, r3, r4;</p><p>+	uint32_t s1, s2, s3, s4;</p><p>+	uint32_t h0, h1, h2, h3, h4;</p><p>+	uint64_t d0, d1, d2, d3, d4;</p><p>+	uint32_t c;</p><p>+</p><p>+	r0 = st-&gt;r[0];</p><p>+	r1 = st-&gt;r[1];</p><p>+	r2 = st-&gt;r[2];</p><p>+	r3 = st-&gt;r[3];</p><p>+	r4 = st-&gt;r[4];</p><p>+</p><p>+	s1 = st-&gt;s[0];</p><p>+	s2 = st-&gt;s[1];</p><p>+	s3 = st-&gt;s[2];</p><p>+	s4 = st-&gt;s[3];</p><p>+</p><p>+	h0 = st-&gt;h[0];</p><p>+	h1 = st-&gt;h[1];</p><p>+	h2 = st-&gt;h[2];</p><p>+	h3 = st-&gt;h[3];</p><p>+	h4 = st-&gt;h[4];</p><p>+</p><p>+	while (len &gt;= POLY1305_BLOCK_SIZE) {</p><p>+		/* h += m[i] */</p><p>+		h0 += (get_unaligned_le32(&amp;input[0])) &amp; 0x3ffffff;</p><p>+		h1 += (get_unaligned_le32(&amp;input[3]) &gt;&gt; 2) &amp; 0x3ffffff;</p><p>+		h2 += (get_unaligned_le32(&amp;input[6]) &gt;&gt; 4) &amp; 0x3ffffff;</p><p>+		h3 += (get_unaligned_le32(&amp;input[9]) &gt;&gt; 6) &amp; 0x3ffffff;</p><p>+		h4 += (get_unaligned_le32(&amp;input[12]) &gt;&gt; 8) | hibit;</p><p>+</p><p>+		/* h *= r */</p><p>+		d0 = ((uint64_t)h0 * r0) + ((uint64_t)h1 * s4) +</p><p>+		     ((uint64_t)h2 * s3) + ((uint64_t)h3 * s2) +</p><p>+		     ((uint64_t)h4 * s1);</p><p>+		d1 = ((uint64_t)h0 * r1) + ((uint64_t)h1 * r0) +</p><p>+		     ((uint64_t)h2 * s4) + ((uint64_t)h3 * s3) +</p><p>+		     ((uint64_t)h4 * s2);</p><p>+		d2 = ((uint64_t)h0 * r2) + ((uint64_t)h1 * r1) +</p><p>+		     ((uint64_t)h2 * r0) + ((uint64_t)h3 * s4) +</p><p>+		     ((uint64_t)h4 * s3);</p><p>+		d3 = ((uint64_t)h0 * r3) + ((uint64_t)h1 * r2) +</p><p>+		     ((uint64_t)h2 * r1) + ((uint64_t)h3 * r0) +</p><p>+		     ((uint64_t)h4 * s4);</p><p>+		d4 = ((uint64_t)h0 * r4) + ((uint64_t)h1 * r3) +</p><p>+		     ((uint64_t)h2 * r2) + ((uint64_t)h3 * r1) +</p><p>+		     ((uint64_t)h4 * r0);</p><p>+</p><p>+		/* (partial) h %= p */</p><p>+		c = (uint32_t)(d0 &gt;&gt; 26);</p><p>+		h0 = (uint32_t)d0 &amp; 0x3ffffff;</p><p>+		d1 += c;</p><p>+		c = (uint32_t)(d1 &gt;&gt; 26);</p><p>+		h1 = (uint32_t)d1 &amp; 0x3ffffff;</p><p>+		d2 += c;</p><p>+		c = (uint32_t)(d2 &gt;&gt; 26);</p><p>+		h2 = (uint32_t)d2 &amp; 0x3ffffff;</p><p>+		d3 += c;</p><p>+		c = (uint32_t)(d3 &gt;&gt; 26);</p><p>+		h3 = (uint32_t)d3 &amp; 0x3ffffff;</p><p>+		d4 += c;</p><p>+		c = (uint32_t)(d4 &gt;&gt; 26);</p><p>+		h4 = (uint32_t)d4 &amp; 0x3ffffff;</p><p>+		h0 += c * 5;</p><p>+		c = (h0 &gt;&gt; 26);</p><p>+		h0 = h0 &amp; 0x3ffffff;</p><p>+		h1 += c;</p><p>+</p><p>+		input += POLY1305_BLOCK_SIZE;</p><p>+		len -= POLY1305_BLOCK_SIZE;</p><p>+	}</p><p>+</p><p>+	st-&gt;h[0] = h0;</p><p>+	st-&gt;h[1] = h1;</p><p>+	st-&gt;h[2] = h2;</p><p>+	st-&gt;h[3] = h3;</p><p>+	st-&gt;h[4] = h4;</p><p>+}</p><p>+</p><p>+static void poly1305_emit_core(struct poly1305_internal *st, uint8_t mac[16],</p><p>+			       const uint32_t nonce[4])</p><p>+{</p><p>+	uint32_t h0, h1, h2, h3, h4, c;</p><p>+	uint32_t g0, g1, g2, g3, g4;</p><p>+	uint64_t f;</p><p>+	uint32_t mask;</p><p>+</p><p>+	/* fully carry h */</p><p>+	h0 = st-&gt;h[0];</p><p>+	h1 = st-&gt;h[1];</p><p>+	h2 = st-&gt;h[2];</p><p>+	h3 = st-&gt;h[3];</p><p>+	h4 = st-&gt;h[4];</p><p>+</p><p>+	c = h1 &gt;&gt; 26;</p><p>+	h1 = h1 &amp; 0x3ffffff;</p><p>+	h2 += c;</p><p>+	c = h2 &gt;&gt; 26;</p><p>+	h2 = h2 &amp; 0x3ffffff;</p><p>+	h3 += c;</p><p>+	c = h3 &gt;&gt; 26;</p><p>+	h3 = h3 &amp; 0x3ffffff;</p><p>+	h4 += c;</p><p>+	c = h4 &gt;&gt; 26;</p><p>+	h4 = h4 &amp; 0x3ffffff;</p><p>+	h0 += c * 5;</p><p>+	c = h0 &gt;&gt; 26;</p><p>+	h0 = h0 &amp; 0x3ffffff;</p><p>+	h1 += c;</p><p>+</p><p>+	/* compute h + -p */</p><p>+	g0 = h0 + 5;</p><p>+	c = g0 &gt;&gt; 26;</p><p>+	g0 &amp;= 0x3ffffff;</p><p>+	g1 = h1 + c;</p><p>+	c = g1 &gt;&gt; 26;</p><p>+	g1 &amp;= 0x3ffffff;</p><p>+	g2 = h2 + c;</p><p>+	c = g2 &gt;&gt; 26;</p><p>+	g2 &amp;= 0x3ffffff;</p><p>+	g3 = h3 + c;</p><p>+	c = g3 &gt;&gt; 26;</p><p>+	g3 &amp;= 0x3ffffff;</p><p>+	g4 = h4 + c - (1UL &lt;&lt; 26);</p><p>+</p><p>+	/* select h if h &lt; p, or h + -p if h &gt;= p */</p><p>+	mask = (g4 &gt;&gt; ((sizeof(uint32_t) * 8) - 1)) - 1;</p><p>+	g0 &amp;= mask;</p><p>+	g1 &amp;= mask;</p><p>+	g2 &amp;= mask;</p><p>+	g3 &amp;= mask;</p><p>+	g4 &amp;= mask;</p><p>+	mask = ~mask;</p><p>+</p><p>+	h0 = (h0 &amp; mask) | g0;</p><p>+	h1 = (h1 &amp; mask) | g1;</p><p>+	h2 = (h2 &amp; mask) | g2;</p><p>+	h3 = (h3 &amp; mask) | g3;</p><p>+	h4 = (h4 &amp; mask) | g4;</p><p>+</p><p>+	/* h = h % (2^128) */</p><p>+	h0 = ((h0) | (h1 &lt;&lt; 26)) &amp; 0xffffffff;</p><p>+	h1 = ((h1 &gt;&gt; 6) | (h2 &lt;&lt; 20)) &amp; 0xffffffff;</p><p>+	h2 = ((h2 &gt;&gt; 12) | (h3 &lt;&lt; 14)) &amp; 0xffffffff;</p><p>+	h3 = ((h3 &gt;&gt; 18) | (h4 &lt;&lt; 8)) &amp; 0xffffffff;</p><p>+</p><p>+	/* mac = (h + nonce) % (2^128) */</p><p>+	f = (uint64_t)h0 + nonce[0];</p><p>+	h0 = (uint32_t)f;</p><p>+	f = (uint64_t)h1 + nonce[1] + (f &gt;&gt; 32);</p><p>+	h1 = (uint32_t)f;</p><p>+	f = (uint64_t)h2 + nonce[2] + (f &gt;&gt; 32);</p><p>+	h2 = (uint32_t)f;</p><p>+	f = (uint64_t)h3 + nonce[3] + (f &gt;&gt; 32);</p><p>+	h3 = (uint32_t)f;</p><p>+</p><p>+	put_unaligned_le32(h0, &amp;mac[0]);</p><p>+	put_unaligned_le32(h1, &amp;mac[4]);</p><p>+	put_unaligned_le32(h2, &amp;mac[8]);</p><p>+	put_unaligned_le32(h3, &amp;mac[12]);</p><p>+}</p><p>+</p><p>+static void poly1305_init(struct poly1305_ctx *ctx,</p><p>+			  const uint8_t key[POLY1305_KEY_SIZE])</p><p>+{</p><p>+	ctx-&gt;nonce[0] = get_unaligned_le32(&amp;key[16]);</p><p>+	ctx-&gt;nonce[1] = get_unaligned_le32(&amp;key[20]);</p><p>+	ctx-&gt;nonce[2] = get_unaligned_le32(&amp;key[24]);</p><p>+	ctx-&gt;nonce[3] = get_unaligned_le32(&amp;key[28]);</p><p>+</p><p>+	poly1305_init_core(&amp;ctx-&gt;state, key);</p><p>+</p><p>+	ctx-&gt;num = 0;</p><p>+}</p><p>+</p><p>+static void poly1305_update(struct poly1305_ctx *ctx, const uint8_t *input,</p><p>+			    size_t len)</p><p>+{</p><p>+	const size_t num = ctx-&gt;num;</p><p>+	size_t rem;</p><p>+</p><p>+	if (num) {</p><p>+		rem = POLY1305_BLOCK_SIZE - num;</p><p>+		if (len &lt; rem) {</p><p>+			memcpy(ctx-&gt;data + num, input, len);</p><p>+			ctx-&gt;num = num + len;</p><p>+			return;</p><p>+		}</p><p>+		memcpy(ctx-&gt;data + num, input, rem);</p><p>+		poly1305_blocks_core(&amp;ctx-&gt;state, ctx-&gt;data,</p><p>+				     POLY1305_BLOCK_SIZE, 1);</p><p>+		input += rem;</p><p>+		len -= rem;</p><p>+	}</p><p>+</p><p>+	rem = len % POLY1305_BLOCK_SIZE;</p><p>+	len -= rem;</p><p>+</p><p>+	if (len &gt;= POLY1305_BLOCK_SIZE) {</p><p>+		poly1305_blocks_core(&amp;ctx-&gt;state, input, len, 1);</p><p>+		input += len;</p><p>+	}</p><p>+</p><p>+	if (rem)</p><p>+		memcpy(ctx-&gt;data, input, rem);</p><p>+</p><p>+	ctx-&gt;num = rem;</p><p>+}</p><p>+</p><p>+static void poly1305_final(struct poly1305_ctx *ctx,</p><p>+			   uint8_t mac[POLY1305_MAC_SIZE])</p><p>+{</p><p>+	size_t num = ctx-&gt;num;</p><p>+</p><p>+	if (num) {</p><p>+		ctx-&gt;data[num++] = 1;</p><p>+		while (num &lt; POLY1305_BLOCK_SIZE)</p><p>+			ctx-&gt;data[num++] = 0;</p><p>+		poly1305_blocks_core(&amp;ctx-&gt;state, ctx-&gt;data,</p><p>+				     POLY1305_BLOCK_SIZE, 0);</p><p>+	}</p><p>+</p><p>+	poly1305_emit_core(&amp;ctx-&gt;state, mac, ctx-&gt;nonce);</p><p>+</p><p>+	explicit_bzero(ctx, sizeof(*ctx));</p><p>+}</p><p>+#endif</p><p>+</p><p>+#ifdef COMPAT_NEED_CHACHA20POLY1305</p><p>+static const uint8_t pad0[16] = { 0 };</p><p>+</p><p>+void</p><p>+chacha20poly1305_encrypt(uint8_t *dst, const uint8_t *src, const size_t src_len,</p><p>+			 const uint8_t *ad, const size_t ad_len,</p><p>+			 const uint64_t nonce,</p><p>+			 const uint8_t key[CHACHA20POLY1305_KEY_SIZE])</p><p>+{</p><p>+	struct poly1305_ctx poly1305_state;</p><p>+	struct chacha20_ctx chacha20_state;</p><p>+	union {</p><p>+		uint8_t block0[POLY1305_KEY_SIZE];</p><p>+		uint64_t lens[2];</p><p>+	} b = { { 0 } };</p><p>+</p><p>+	chacha20_init(&amp;chacha20_state, key, nonce);</p><p>+	chacha20(&amp;chacha20_state, b.block0, b.block0, sizeof(b.block0));</p><p>+	poly1305_init(&amp;poly1305_state, b.block0);</p><p>+</p><p>+	poly1305_update(&amp;poly1305_state, ad, ad_len);</p><p>+	poly1305_update(&amp;poly1305_state, pad0, (0x10 - ad_len) &amp; 0xf);</p><p>+</p><p>+	chacha20(&amp;chacha20_state, dst, src, src_len);</p><p>+</p><p>+	poly1305_update(&amp;poly1305_state, dst, src_len);</p><p>+	poly1305_update(&amp;poly1305_state, pad0, (0x10 - src_len) &amp; 0xf);</p><p>+</p><p>+	b.lens[0] = cpu_to_le64(ad_len);</p><p>+	b.lens[1] = cpu_to_le64(src_len);</p><p>+	poly1305_update(&amp;poly1305_state, (uint8_t *)b.lens, sizeof(b.lens));</p><p>+</p><p>+	poly1305_final(&amp;poly1305_state, dst + src_len);</p><p>+</p><p>+	explicit_bzero(&amp;chacha20_state, sizeof(chacha20_state));</p><p>+	explicit_bzero(&amp;b, sizeof(b));</p><p>+}</p><p>+</p><p>+bool</p><p>+chacha20poly1305_decrypt(uint8_t *dst, const uint8_t *src, const size_t src_len,</p><p>+			 const uint8_t *ad, const size_t ad_len,</p><p>+			 const uint64_t nonce,</p><p>+			 const uint8_t key[CHACHA20POLY1305_KEY_SIZE])</p><p>+{</p><p>+	struct poly1305_ctx poly1305_state;</p><p>+	struct chacha20_ctx chacha20_state;</p><p>+	bool ret;</p><p>+	size_t dst_len;</p><p>+	union {</p><p>+		uint8_t block0[POLY1305_KEY_SIZE];</p><p>+		uint8_t mac[POLY1305_MAC_SIZE];</p><p>+		uint64_t lens[2];</p><p>+	} b = { { 0 } };</p><p>+</p><p>+	if (src_len &lt; POLY1305_MAC_SIZE)</p><p>+		return false;</p><p>+</p><p>+	chacha20_init(&amp;chacha20_state, key, nonce);</p><p>+	chacha20(&amp;chacha20_state, b.block0, b.block0, sizeof(b.block0));</p><p>+	poly1305_init(&amp;poly1305_state, b.block0);</p><p>+</p><p>+	poly1305_update(&amp;poly1305_state, ad, ad_len);</p><p>+	poly1305_update(&amp;poly1305_state, pad0, (0x10 - ad_len) &amp; 0xf);</p><p>+</p><p>+	dst_len = src_len - POLY1305_MAC_SIZE;</p><p>+	poly1305_update(&amp;poly1305_state, src, dst_len);</p><p>+	poly1305_update(&amp;poly1305_state, pad0, (0x10 - dst_len) &amp; 0xf);</p><p>+</p><p>+	b.lens[0] = cpu_to_le64(ad_len);</p><p>+	b.lens[1] = cpu_to_le64(dst_len);</p><p>+	poly1305_update(&amp;poly1305_state, (uint8_t *)b.lens, sizeof(b.lens));</p><p>+</p><p>+	poly1305_final(&amp;poly1305_state, b.mac);</p><p>+</p><p>+	ret = timingsafe_bcmp(b.mac, src + dst_len, POLY1305_MAC_SIZE) == 0;</p><p>+	if (ret)</p><p>+		chacha20(&amp;chacha20_state, dst, src, dst_len);</p><p>+</p><p>+	explicit_bzero(&amp;chacha20_state, sizeof(chacha20_state));</p><p>+	explicit_bzero(&amp;b, sizeof(b));</p><p>+</p><p>+	return ret;</p><p>+}</p><p>+</p><p>+void</p><p>+xchacha20poly1305_encrypt(uint8_t *dst, const uint8_t *src,</p><p>+			  const size_t src_len, const uint8_t *ad,</p><p>+			  const size_t ad_len,</p><p>+			  const uint8_t nonce[XCHACHA20POLY1305_NONCE_SIZE],</p><p>+			  const uint8_t key[CHACHA20POLY1305_KEY_SIZE])</p><p>+{</p><p>+	uint32_t derived_key[CHACHA20_KEY_WORDS];</p><p>+</p><p>+	hchacha20(derived_key, nonce, key);</p><p>+	cpu_to_le32_array(derived_key, ARRAY_SIZE(derived_key));</p><p>+	chacha20poly1305_encrypt(dst, src, src_len, ad, ad_len,</p><p>+				 get_unaligned_le64(nonce + 16),</p><p>+				 (uint8_t *)derived_key);</p><p>+	explicit_bzero(derived_key, CHACHA20POLY1305_KEY_SIZE);</p><p>+}</p><p>+</p><p>+bool</p><p>+xchacha20poly1305_decrypt(uint8_t *dst, const uint8_t *src,</p><p>+			  const size_t src_len,  const uint8_t *ad,</p><p>+			  const size_t ad_len,</p><p>+			  const uint8_t nonce[XCHACHA20POLY1305_NONCE_SIZE],</p><p>+			  const uint8_t key[CHACHA20POLY1305_KEY_SIZE])</p><p>+{</p><p>+	bool ret;</p><p>+	uint32_t derived_key[CHACHA20_KEY_WORDS];</p><p>+</p><p>+	hchacha20(derived_key, nonce, key);</p><p>+	cpu_to_le32_array(derived_key, ARRAY_SIZE(derived_key));</p><p>+	ret = chacha20poly1305_decrypt(dst, src, src_len, ad, ad_len,</p><p>+				       get_unaligned_le64(nonce + 16),</p><p>+				       (uint8_t *)derived_key);</p><p>+	explicit_bzero(derived_key, CHACHA20POLY1305_KEY_SIZE);</p><p>+	return ret;</p><p>+}</p><p>+#endif</p><p>+</p><p>+#ifdef COMPAT_NEED_CHACHA20POLY1305_MBUF</p><p>+static inline int</p><p>+chacha20poly1305_crypt_mbuf(struct mbuf *m0, uint64_t nonce,</p><p>+			    const uint8_t key[CHACHA20POLY1305_KEY_SIZE], bool encrypt)</p><p>+{</p><p>+	struct poly1305_ctx poly1305_state;</p><p>+	struct chacha20_ctx chacha20_state;</p><p>+	uint8_t *buf, mbuf_mac[POLY1305_MAC_SIZE];</p><p>+	size_t len, leftover = 0;</p><p>+	struct mbuf *m;</p><p>+	int ret;</p><p>+	union {</p><p>+		uint32_t stream[CHACHA20_BLOCK_WORDS];</p><p>+		uint8_t block0[POLY1305_KEY_SIZE];</p><p>+		uint8_t mac[POLY1305_MAC_SIZE];</p><p>+		uint64_t lens[2];</p><p>+	} b = { { 0 } };</p><p>+</p><p>+	if (!encrypt) {</p><p>+		if (m0-&gt;m_pkthdr.len &lt; POLY1305_MAC_SIZE)</p><p>+			return EMSGSIZE;</p><p>+		m_copydata(m0, m0-&gt;m_pkthdr.len - POLY1305_MAC_SIZE, POLY1305_MAC_SIZE, mbuf_mac);</p><p>+		m_adj(m0, -POLY1305_MAC_SIZE);</p><p>+	}</p><p>+</p><p>+	chacha20_init(&amp;chacha20_state, key, nonce);</p><p>+	chacha20(&amp;chacha20_state, b.block0, b.block0, sizeof(b.block0));</p><p>+	poly1305_init(&amp;poly1305_state, b.block0);</p><p>+</p><p>+	for (m = m0; m; m = m-&gt;m_next) {</p><p>+		len = m-&gt;m_len;</p><p>+		buf = m-&gt;m_data;</p><p>+</p><p>+		if (!encrypt)</p><p>+			poly1305_update(&amp;poly1305_state, m-&gt;m_data, m-&gt;m_len);</p><p>+</p><p>+		if (leftover != 0) {</p><p>+			size_t l = min(len, leftover);</p><p>+			xor_cpy(buf, buf, ((uint8_t *)b.stream) + (CHACHA20_BLOCK_SIZE - leftover), l);</p><p>+			leftover -= l;</p><p>+			buf += l;</p><p>+			len -= l;</p><p>+		}</p><p>+</p><p>+		while (len &gt;= CHACHA20_BLOCK_SIZE) {</p><p>+			chacha20_block(&amp;chacha20_state, b.stream);</p><p>+			xor_cpy(buf, buf, (uint8_t *)b.stream, CHACHA20_BLOCK_SIZE);</p><p>+			buf += CHACHA20_BLOCK_SIZE;</p><p>+			len -= CHACHA20_BLOCK_SIZE;</p><p>+		}</p><p>+</p><p>+		if (len) {</p><p>+			chacha20_block(&amp;chacha20_state, b.stream);</p><p>+			xor_cpy(buf, buf, (uint8_t *)b.stream, len);</p><p>+			leftover = CHACHA20_BLOCK_SIZE - len;</p><p>+		}</p><p>+</p><p>+		if (encrypt)</p><p>+			poly1305_update(&amp;poly1305_state, m-&gt;m_data, m-&gt;m_len);</p><p>+	}</p><p>+	poly1305_update(&amp;poly1305_state, pad0, (0x10 - m0-&gt;m_pkthdr.len) &amp; 0xf);</p><p>+</p><p>+	b.lens[0] = 0;</p><p>+	b.lens[1] = cpu_to_le64(m0-&gt;m_pkthdr.len);</p><p>+	poly1305_update(&amp;poly1305_state, (uint8_t *)b.lens, sizeof(b.lens));</p><p>+</p><p>+	poly1305_final(&amp;poly1305_state, b.mac);</p><p>+</p><p>+	if (encrypt)</p><p>+		ret = m_append(m0, POLY1305_MAC_SIZE, b.mac) ? 0 : ENOMEM;</p><p>+	else</p><p>+		ret = timingsafe_bcmp(b.mac, mbuf_mac, POLY1305_MAC_SIZE) == 0 ? 0 : EBADMSG;</p><p>+</p><p>+	explicit_bzero(&amp;chacha20_state, sizeof(chacha20_state));</p><p>+	explicit_bzero(&amp;b, sizeof(b));</p><p>+</p><p>+	return ret;</p><p>+}</p><p>+</p><p>+int</p><p>+chacha20poly1305_encrypt_mbuf(struct mbuf *m, const uint64_t nonce,</p><p>+			      const uint8_t key[CHACHA20POLY1305_KEY_SIZE])</p><p>+{</p><p>+	return chacha20poly1305_crypt_mbuf(m, nonce, key, true);</p><p>+}</p><p>+</p><p>+int</p><p>+chacha20poly1305_decrypt_mbuf(struct mbuf *m, const uint64_t nonce,</p><p>+			      const uint8_t key[CHACHA20POLY1305_KEY_SIZE])</p><p>+{</p><p>+	return chacha20poly1305_crypt_mbuf(m, nonce, key, false);</p><p>+}</p><p>+#else</p><p>+static int</p><p>+crypto_callback(struct cryptop *crp)</p><p>+{</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+int</p><p>+chacha20poly1305_encrypt_mbuf(struct mbuf *m, const uint64_t nonce,</p><p>+			      const uint8_t key[CHACHA20POLY1305_KEY_SIZE])</p><p>+{</p><p>+	static const char blank_tag[POLY1305_HASH_LEN];</p><p>+	struct cryptop crp;</p><p>+	int ret;</p><p>+</p><p>+	if (!m_append(m, POLY1305_HASH_LEN, blank_tag))</p><p>+		return (ENOMEM);</p><p>+	crypto_initreq(&amp;crp, chacha20_poly1305_sid);</p><p>+	crp.crp_op = CRYPTO_OP_ENCRYPT | CRYPTO_OP_COMPUTE_DIGEST;</p><p>+	crp.crp_flags = CRYPTO_F_IV_SEPARATE | CRYPTO_F_CBIMM;</p><p>+	crypto_use_mbuf(&amp;crp, m);</p><p>+	crp.crp_payload_length = m-&gt;m_pkthdr.len - POLY1305_HASH_LEN;</p><p>+	crp.crp_digest_start = crp.crp_payload_length;</p><p>+	le64enc(crp.crp_iv, nonce);</p><p>+	crp.crp_cipher_key = key;</p><p>+	crp.crp_callback = crypto_callback;</p><p>+	ret = crypto_dispatch(&amp;crp);</p><p>+	crypto_destroyreq(&amp;crp);</p><p>+	return (ret);</p><p>+}</p><p>+</p><p>+int</p><p>+chacha20poly1305_decrypt_mbuf(struct mbuf *m, const uint64_t nonce,</p><p>+			      const uint8_t key[CHACHA20POLY1305_KEY_SIZE])</p><p>+{</p><p>+	struct cryptop crp;</p><p>+	int ret;</p><p>+</p><p>+	if (m-&gt;m_pkthdr.len &lt; POLY1305_HASH_LEN)</p><p>+		return (EMSGSIZE);</p><p>+	crypto_initreq(&amp;crp, chacha20_poly1305_sid);</p><p>+	crp.crp_op = CRYPTO_OP_DECRYPT | CRYPTO_OP_VERIFY_DIGEST;</p><p>+	crp.crp_flags = CRYPTO_F_IV_SEPARATE | CRYPTO_F_CBIMM;</p><p>+	crypto_use_mbuf(&amp;crp, m);</p><p>+	crp.crp_payload_length = m-&gt;m_pkthdr.len - POLY1305_HASH_LEN;</p><p>+	crp.crp_digest_start = crp.crp_payload_length;</p><p>+	le64enc(crp.crp_iv, nonce);</p><p>+	crp.crp_cipher_key = key;</p><p>+	crp.crp_callback = crypto_callback;</p><p>+	ret = crypto_dispatch(&amp;crp);</p><p>+	crypto_destroyreq(&amp;crp);</p><p>+	if (ret)</p><p>+		return (ret);</p><p>+	m_adj(m, -POLY1305_HASH_LEN);</p><p>+	return (0);</p><p>+}</p><p>+#endif</p><p>+</p><p>+#ifdef COMPAT_NEED_BLAKE2S</p><p>+static const uint32_t blake2s_iv[8] = {</p><p>+	0x6A09E667UL, 0xBB67AE85UL, 0x3C6EF372UL, 0xA54FF53AUL,</p><p>+	0x510E527FUL, 0x9B05688CUL, 0x1F83D9ABUL, 0x5BE0CD19UL</p><p>+};</p><p>+</p><p>+static const uint8_t blake2s_sigma[10][16] = {</p><p>+	{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 },</p><p>+	{ 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3 },</p><p>+	{ 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4 },</p><p>+	{ 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8 },</p><p>+	{ 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13 },</p><p>+	{ 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9 },</p><p>+	{ 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11 },</p><p>+	{ 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10 },</p><p>+	{ 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5 },</p><p>+	{ 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0 },</p><p>+};</p><p>+</p><p>+static inline void blake2s_set_lastblock(struct blake2s_state *state)</p><p>+{</p><p>+	state-&gt;f[0] = -1;</p><p>+}</p><p>+</p><p>+static inline void blake2s_increment_counter(struct blake2s_state *state,</p><p>+					     const uint32_t inc)</p><p>+{</p><p>+	state-&gt;t[0] += inc;</p><p>+	state-&gt;t[1] += (state-&gt;t[0] &lt; inc);</p><p>+}</p><p>+</p><p>+static inline void blake2s_init_param(struct blake2s_state *state,</p><p>+				      const uint32_t param)</p><p>+{</p><p>+	int i;</p><p>+</p><p>+	memset(state, 0, sizeof(*state));</p><p>+	for (i = 0; i &lt; 8; ++i)</p><p>+		state-&gt;h[i] = blake2s_iv[i];</p><p>+	state-&gt;h[0] ^= param;</p><p>+}</p><p>+</p><p>+void blake2s_init(struct blake2s_state *state, const size_t outlen)</p><p>+{</p><p>+	blake2s_init_param(state, 0x01010000 | outlen);</p><p>+	state-&gt;outlen = outlen;</p><p>+}</p><p>+</p><p>+void blake2s_init_key(struct blake2s_state *state, const size_t outlen,</p><p>+		      const uint8_t *key, const size_t keylen)</p><p>+{</p><p>+	uint8_t block[BLAKE2S_BLOCK_SIZE] = { 0 };</p><p>+</p><p>+	blake2s_init_param(state, 0x01010000 | keylen &lt;&lt; 8 | outlen);</p><p>+	state-&gt;outlen = outlen;</p><p>+	memcpy(block, key, keylen);</p><p>+	blake2s_update(state, block, BLAKE2S_BLOCK_SIZE);</p><p>+	explicit_bzero(block, BLAKE2S_BLOCK_SIZE);</p><p>+}</p><p>+</p><p>+static inline void blake2s_compress(struct blake2s_state *state,</p><p>+				    const uint8_t *block, size_t nblocks,</p><p>+				    const uint32_t inc)</p><p>+{</p><p>+	uint32_t m[16];</p><p>+	uint32_t v[16];</p><p>+	int i;</p><p>+</p><p>+	while (nblocks &gt; 0) {</p><p>+		blake2s_increment_counter(state, inc);</p><p>+		memcpy(m, block, BLAKE2S_BLOCK_SIZE);</p><p>+		le32_to_cpu_array(m, ARRAY_SIZE(m));</p><p>+		memcpy(v, state-&gt;h, 32);</p><p>+		v[ 8] = blake2s_iv[0];</p><p>+		v[ 9] = blake2s_iv[1];</p><p>+		v[10] = blake2s_iv[2];</p><p>+		v[11] = blake2s_iv[3];</p><p>+		v[12] = blake2s_iv[4] ^ state-&gt;t[0];</p><p>+		v[13] = blake2s_iv[5] ^ state-&gt;t[1];</p><p>+		v[14] = blake2s_iv[6] ^ state-&gt;f[0];</p><p>+		v[15] = blake2s_iv[7] ^ state-&gt;f[1];</p><p>+</p><p>+#define G(r, i, a, b, c, d) do { \</p><p>+	a += b + m[blake2s_sigma[r][2 * i + 0]]; \</p><p>+	d = ror32(d ^ a, 16); \</p><p>+	c += d; \</p><p>+	b = ror32(b ^ c, 12); \</p><p>+	a += b + m[blake2s_sigma[r][2 * i + 1]]; \</p><p>+	d = ror32(d ^ a, 8); \</p><p>+	c += d; \</p><p>+	b = ror32(b ^ c, 7); \</p><p>+} while (0)</p><p>+</p><p>+#define ROUND(r) do { \</p><p>+	G(r, 0, v[0], v[ 4], v[ 8], v[12]); \</p><p>+	G(r, 1, v[1], v[ 5], v[ 9], v[13]); \</p><p>+	G(r, 2, v[2], v[ 6], v[10], v[14]); \</p><p>+	G(r, 3, v[3], v[ 7], v[11], v[15]); \</p><p>+	G(r, 4, v[0], v[ 5], v[10], v[15]); \</p><p>+	G(r, 5, v[1], v[ 6], v[11], v[12]); \</p><p>+	G(r, 6, v[2], v[ 7], v[ 8], v[13]); \</p><p>+	G(r, 7, v[3], v[ 4], v[ 9], v[14]); \</p><p>+} while (0)</p><p>+		ROUND(0);</p><p>+		ROUND(1);</p><p>+		ROUND(2);</p><p>+		ROUND(3);</p><p>+		ROUND(4);</p><p>+		ROUND(5);</p><p>+		ROUND(6);</p><p>+		ROUND(7);</p><p>+		ROUND(8);</p><p>+		ROUND(9);</p><p>+</p><p>+#undef G</p><p>+#undef ROUND</p><p>+</p><p>+		for (i = 0; i &lt; 8; ++i)</p><p>+			state-&gt;h[i] ^= v[i] ^ v[i + 8];</p><p>+</p><p>+		block += BLAKE2S_BLOCK_SIZE;</p><p>+		--nblocks;</p><p>+	}</p><p>+}</p><p>+</p><p>+void blake2s_update(struct blake2s_state *state, const uint8_t *in, size_t inlen)</p><p>+{</p><p>+	const size_t fill = BLAKE2S_BLOCK_SIZE - state-&gt;buflen;</p><p>+</p><p>+	if (!inlen)</p><p>+		return;</p><p>+	if (inlen &gt; fill) {</p><p>+		memcpy(state-&gt;buf + state-&gt;buflen, in, fill);</p><p>+		blake2s_compress(state, state-&gt;buf, 1, BLAKE2S_BLOCK_SIZE);</p><p>+		state-&gt;buflen = 0;</p><p>+		in += fill;</p><p>+		inlen -= fill;</p><p>+	}</p><p>+	if (inlen &gt; BLAKE2S_BLOCK_SIZE) {</p><p>+		const size_t nblocks = DIV_ROUND_UP(inlen, BLAKE2S_BLOCK_SIZE);</p><p>+		/* Hash one less (full) block than strictly possible */</p><p>+		blake2s_compress(state, in, nblocks - 1, BLAKE2S_BLOCK_SIZE);</p><p>+		in += BLAKE2S_BLOCK_SIZE * (nblocks - 1);</p><p>+		inlen -= BLAKE2S_BLOCK_SIZE * (nblocks - 1);</p><p>+	}</p><p>+	memcpy(state-&gt;buf + state-&gt;buflen, in, inlen);</p><p>+	state-&gt;buflen += inlen;</p><p>+}</p><p>+</p><p>+void blake2s_final(struct blake2s_state *state, uint8_t *out)</p><p>+{</p><p>+	blake2s_set_lastblock(state);</p><p>+	memset(state-&gt;buf + state-&gt;buflen, 0,</p><p>+	       BLAKE2S_BLOCK_SIZE - state-&gt;buflen); /* Padding */</p><p>+	blake2s_compress(state, state-&gt;buf, 1, state-&gt;buflen);</p><p>+	cpu_to_le32_array(state-&gt;h, ARRAY_SIZE(state-&gt;h));</p><p>+	memcpy(out, state-&gt;h, state-&gt;outlen);</p><p>+	explicit_bzero(state, sizeof(*state));</p><p>+}</p><p>+#endif</p><p>+</p><p>+#ifdef COMPAT_NEED_CURVE25519</p><p>+/* Below here is fiat&#39;s implementation of x25519.</p><p>+ *</p><p>+ * Copyright (C) 2015-2016 The fiat-crypto Authors.</p><p>+ * Copyright (C) 2018-2021 Jason A. Donenfeld &lt;Jason@zx2c4.com&gt;. All Rights Reserved.</p><p>+ *</p><p>+ * This is a machine-generated formally verified implementation of Curve25519</p><p>+ * ECDH from: &lt;https://github.com/mit-plv/fiat-crypto&gt;. Though originally</p><p>+ * machine generated, it has been tweaked to be suitable for use in the kernel.</p><p>+ * It is optimized for 32-bit machines and machines that cannot work efficiently</p><p>+ * with 128-bit integer types.</p><p>+ */</p><p>+</p><p>+/* fe means field element. Here the field is \Z/(2^255-19). An element t,</p><p>+ * entries t[0]...t[9], represents the integer t[0]+2^26 t[1]+2^51 t[2]+2^77</p><p>+ * t[3]+2^102 t[4]+...+2^230 t[9].</p><p>+ * fe limbs are bounded by 1.125*2^26,1.125*2^25,1.125*2^26,1.125*2^25,etc.</p><p>+ * Multiplication and carrying produce fe from fe_loose.</p><p>+ */</p><p>+typedef struct fe { uint32_t v[10]; } fe;</p><p>+</p><p>+/* fe_loose limbs are bounded by 3.375*2^26,3.375*2^25,3.375*2^26,3.375*2^25,etc</p><p>+ * Addition and subtraction produce fe_loose from (fe, fe).</p><p>+ */</p><p>+typedef struct fe_loose { uint32_t v[10]; } fe_loose;</p><p>+</p><p>+static inline void fe_frombytes_impl(uint32_t h[10], const uint8_t *s)</p><p>+{</p><p>+	/* Ignores top bit of s. */</p><p>+	uint32_t a0 = get_unaligned_le32(s);</p><p>+	uint32_t a1 = get_unaligned_le32(s+4);</p><p>+	uint32_t a2 = get_unaligned_le32(s+8);</p><p>+	uint32_t a3 = get_unaligned_le32(s+12);</p><p>+	uint32_t a4 = get_unaligned_le32(s+16);</p><p>+	uint32_t a5 = get_unaligned_le32(s+20);</p><p>+	uint32_t a6 = get_unaligned_le32(s+24);</p><p>+	uint32_t a7 = get_unaligned_le32(s+28);</p><p>+	h[0] = a0&amp;((1&lt;&lt;26)-1);                    /* 26 used, 32-26 left.   26 */</p><p>+	h[1] = (a0&gt;&gt;26) | ((a1&amp;((1&lt;&lt;19)-1))&lt;&lt; 6); /* (32-26) + 19 =  6+19 = 25 */</p><p>+	h[2] = (a1&gt;&gt;19) | ((a2&amp;((1&lt;&lt;13)-1))&lt;&lt;13); /* (32-19) + 13 = 13+13 = 26 */</p><p>+	h[3] = (a2&gt;&gt;13) | ((a3&amp;((1&lt;&lt; 6)-1))&lt;&lt;19); /* (32-13) +  6 = 19+ 6 = 25 */</p><p>+	h[4] = (a3&gt;&gt; 6);                          /* (32- 6)              = 26 */</p><p>+	h[5] = a4&amp;((1&lt;&lt;25)-1);                    /*                        25 */</p><p>+	h[6] = (a4&gt;&gt;25) | ((a5&amp;((1&lt;&lt;19)-1))&lt;&lt; 7); /* (32-25) + 19 =  7+19 = 26 */</p><p>+	h[7] = (a5&gt;&gt;19) | ((a6&amp;((1&lt;&lt;12)-1))&lt;&lt;13); /* (32-19) + 12 = 13+12 = 25 */</p><p>+	h[8] = (a6&gt;&gt;12) | ((a7&amp;((1&lt;&lt; 6)-1))&lt;&lt;20); /* (32-12) +  6 = 20+ 6 = 26 */</p><p>+	h[9] = (a7&gt;&gt; 6)&amp;((1&lt;&lt;25)-1); /*                                     25 */</p><p>+}</p><p>+</p><p>+static inline void fe_frombytes(fe *h, const uint8_t *s)</p><p>+{</p><p>+	fe_frombytes_impl(h-&gt;v, s);</p><p>+}</p><p>+</p><p>+static inline uint8_t /*bool*/</p><p>+addcarryx_u25(uint8_t /*bool*/ c, uint32_t a, uint32_t b, uint32_t *low)</p><p>+{</p><p>+	/* This function extracts 25 bits of result and 1 bit of carry</p><p>+	 * (26 total), so a 32-bit intermediate is sufficient.</p><p>+	 */</p><p>+	uint32_t x = a + b + c;</p><p>+	*low = x &amp; ((1 &lt;&lt; 25) - 1);</p><p>+	return (x &gt;&gt; 25) &amp; 1;</p><p>+}</p><p>+</p><p>+static inline uint8_t /*bool*/</p><p>+addcarryx_u26(uint8_t /*bool*/ c, uint32_t a, uint32_t b, uint32_t *low)</p><p>+{</p><p>+	/* This function extracts 26 bits of result and 1 bit of carry</p><p>+	 * (27 total), so a 32-bit intermediate is sufficient.</p><p>+	 */</p><p>+	uint32_t x = a + b + c;</p><p>+	*low = x &amp; ((1 &lt;&lt; 26) - 1);</p><p>+	return (x &gt;&gt; 26) &amp; 1;</p><p>+}</p><p>+</p><p>+static inline uint8_t /*bool*/</p><p>+subborrow_u25(uint8_t /*bool*/ c, uint32_t a, uint32_t b, uint32_t *low)</p><p>+{</p><p>+	/* This function extracts 25 bits of result and 1 bit of borrow</p><p>+	 * (26 total), so a 32-bit intermediate is sufficient.</p><p>+	 */</p><p>+	uint32_t x = a - b - c;</p><p>+	*low = x &amp; ((1 &lt;&lt; 25) - 1);</p><p>+	return x &gt;&gt; 31;</p><p>+}</p><p>+</p><p>+static inline uint8_t /*bool*/</p><p>+subborrow_u26(uint8_t /*bool*/ c, uint32_t a, uint32_t b, uint32_t *low)</p><p>+{</p><p>+	/* This function extracts 26 bits of result and 1 bit of borrow</p><p>+	 *(27 total), so a 32-bit intermediate is sufficient.</p><p>+	 */</p><p>+	uint32_t x = a - b - c;</p><p>+	*low = x &amp; ((1 &lt;&lt; 26) - 1);</p><p>+	return x &gt;&gt; 31;</p><p>+}</p><p>+</p><p>+static inline uint32_t cmovznz32(uint32_t t, uint32_t z, uint32_t nz)</p><p>+{</p><p>+	t = -!!t; /* all set if nonzero, 0 if 0 */</p><p>+	return (t&amp;nz) | ((~t)&amp;z);</p><p>+}</p><p>+</p><p>+static inline void fe_freeze(uint32_t out[10], const uint32_t in1[10])</p><p>+{</p><p>+	const uint32_t x17 = in1[9];</p><p>+	const uint32_t x18 = in1[8];</p><p>+	const uint32_t x16 = in1[7];</p><p>+	const uint32_t x14 = in1[6];</p><p>+	const uint32_t x12 = in1[5];</p><p>+	const uint32_t x10 = in1[4];</p><p>+	const uint32_t x8 = in1[3];</p><p>+	const uint32_t x6 = in1[2];</p><p>+	const uint32_t x4 = in1[1];</p><p>+	const uint32_t x2 = in1[0];</p><p>+	uint32_t x20; uint8_t/*bool*/ x21 = subborrow_u26(0x0, x2, 0x3ffffed, &amp;x20);</p><p>+	uint32_t x23; uint8_t/*bool*/ x24 = subborrow_u25(x21, x4, 0x1ffffff, &amp;x23);</p><p>+	uint32_t x26; uint8_t/*bool*/ x27 = subborrow_u26(x24, x6, 0x3ffffff, &amp;x26);</p><p>+	uint32_t x29; uint8_t/*bool*/ x30 = subborrow_u25(x27, x8, 0x1ffffff, &amp;x29);</p><p>+	uint32_t x32; uint8_t/*bool*/ x33 = subborrow_u26(x30, x10, 0x3ffffff, &amp;x32);</p><p>+	uint32_t x35; uint8_t/*bool*/ x36 = subborrow_u25(x33, x12, 0x1ffffff, &amp;x35);</p><p>+	uint32_t x38; uint8_t/*bool*/ x39 = subborrow_u26(x36, x14, 0x3ffffff, &amp;x38);</p><p>+	uint32_t x41; uint8_t/*bool*/ x42 = subborrow_u25(x39, x16, 0x1ffffff, &amp;x41);</p><p>+	uint32_t x44; uint8_t/*bool*/ x45 = subborrow_u26(x42, x18, 0x3ffffff, &amp;x44);</p><p>+	uint32_t x47; uint8_t/*bool*/ x48 = subborrow_u25(x45, x17, 0x1ffffff, &amp;x47);</p><p>+	uint32_t x49 = cmovznz32(x48, 0x0, 0xffffffff);</p><p>+	uint32_t x50 = (x49 &amp; 0x3ffffed);</p><p>+	uint32_t x52; uint8_t/*bool*/ x53 = addcarryx_u26(0x0, x20, x50, &amp;x52);</p><p>+	uint32_t x54 = (x49 &amp; 0x1ffffff);</p><p>+	uint32_t x56; uint8_t/*bool*/ x57 = addcarryx_u25(x53, x23, x54, &amp;x56);</p><p>+	uint32_t x58 = (x49 &amp; 0x3ffffff);</p><p>+	uint32_t x60; uint8_t/*bool*/ x61 = addcarryx_u26(x57, x26, x58, &amp;x60);</p><p>+	uint32_t x62 = (x49 &amp; 0x1ffffff);</p><p>+	uint32_t x64; uint8_t/*bool*/ x65 = addcarryx_u25(x61, x29, x62, &amp;x64);</p><p>+	uint32_t x66 = (x49 &amp; 0x3ffffff);</p><p>+	uint32_t x68; uint8_t/*bool*/ x69 = addcarryx_u26(x65, x32, x66, &amp;x68);</p><p>+	uint32_t x70 = (x49 &amp; 0x1ffffff);</p><p>+	uint32_t x72; uint8_t/*bool*/ x73 = addcarryx_u25(x69, x35, x70, &amp;x72);</p><p>+	uint32_t x74 = (x49 &amp; 0x3ffffff);</p><p>+	uint32_t x76; uint8_t/*bool*/ x77 = addcarryx_u26(x73, x38, x74, &amp;x76);</p><p>+	uint32_t x78 = (x49 &amp; 0x1ffffff);</p><p>+	uint32_t x80; uint8_t/*bool*/ x81 = addcarryx_u25(x77, x41, x78, &amp;x80);</p><p>+	uint32_t x82 = (x49 &amp; 0x3ffffff);</p><p>+	uint32_t x84; uint8_t/*bool*/ x85 = addcarryx_u26(x81, x44, x82, &amp;x84);</p><p>+	uint32_t x86 = (x49 &amp; 0x1ffffff);</p><p>+	uint32_t x88; addcarryx_u25(x85, x47, x86, &amp;x88);</p><p>+	out[0] = x52;</p><p>+	out[1] = x56;</p><p>+	out[2] = x60;</p><p>+	out[3] = x64;</p><p>+	out[4] = x68;</p><p>+	out[5] = x72;</p><p>+	out[6] = x76;</p><p>+	out[7] = x80;</p><p>+	out[8] = x84;</p><p>+	out[9] = x88;</p><p>+}</p><p>+</p><p>+static inline void fe_tobytes(uint8_t s[32], const fe *f)</p><p>+{</p><p>+	uint32_t h[10];</p><p>+	fe_freeze(h, f-&gt;v);</p><p>+	s[0] = h[0] &gt;&gt; 0;</p><p>+	s[1] = h[0] &gt;&gt; 8;</p><p>+	s[2] = h[0] &gt;&gt; 16;</p><p>+	s[3] = (h[0] &gt;&gt; 24) | (h[1] &lt;&lt; 2);</p><p>+	s[4] = h[1] &gt;&gt; 6;</p><p>+	s[5] = h[1] &gt;&gt; 14;</p><p>+	s[6] = (h[1] &gt;&gt; 22) | (h[2] &lt;&lt; 3);</p><p>+	s[7] = h[2] &gt;&gt; 5;</p><p>+	s[8] = h[2] &gt;&gt; 13;</p><p>+	s[9] = (h[2] &gt;&gt; 21) | (h[3] &lt;&lt; 5);</p><p>+	s[10] = h[3] &gt;&gt; 3;</p><p>+	s[11] = h[3] &gt;&gt; 11;</p><p>+	s[12] = (h[3] &gt;&gt; 19) | (h[4] &lt;&lt; 6);</p><p>+	s[13] = h[4] &gt;&gt; 2;</p><p>+	s[14] = h[4] &gt;&gt; 10;</p><p>+	s[15] = h[4] &gt;&gt; 18;</p><p>+	s[16] = h[5] &gt;&gt; 0;</p><p>+	s[17] = h[5] &gt;&gt; 8;</p><p>+	s[18] = h[5] &gt;&gt; 16;</p><p>+	s[19] = (h[5] &gt;&gt; 24) | (h[6] &lt;&lt; 1);</p><p>+	s[20] = h[6] &gt;&gt; 7;</p><p>+	s[21] = h[6] &gt;&gt; 15;</p><p>+	s[22] = (h[6] &gt;&gt; 23) | (h[7] &lt;&lt; 3);</p><p>+	s[23] = h[7] &gt;&gt; 5;</p><p>+	s[24] = h[7] &gt;&gt; 13;</p><p>+	s[25] = (h[7] &gt;&gt; 21) | (h[8] &lt;&lt; 4);</p><p>+	s[26] = h[8] &gt;&gt; 4;</p><p>+	s[27] = h[8] &gt;&gt; 12;</p><p>+	s[28] = (h[8] &gt;&gt; 20) | (h[9] &lt;&lt; 6);</p><p>+	s[29] = h[9] &gt;&gt; 2;</p><p>+	s[30] = h[9] &gt;&gt; 10;</p><p>+	s[31] = h[9] &gt;&gt; 18;</p><p>+}</p><p>+</p><p>+/* h = f */</p><p>+static inline void fe_copy(fe *h, const fe *f)</p><p>+{</p><p>+	memmove(h, f, sizeof(uint32_t) * 10);</p><p>+}</p><p>+</p><p>+static inline void fe_copy_lt(fe_loose *h, const fe *f)</p><p>+{</p><p>+	memmove(h, f, sizeof(uint32_t) * 10);</p><p>+}</p><p>+</p><p>+/* h = 0 */</p><p>+static inline void fe_0(fe *h)</p><p>+{</p><p>+	memset(h, 0, sizeof(uint32_t) * 10);</p><p>+}</p><p>+</p><p>+/* h = 1 */</p><p>+static inline void fe_1(fe *h)</p><p>+{</p><p>+	memset(h, 0, sizeof(uint32_t) * 10);</p><p>+	h-&gt;v[0] = 1;</p><p>+}</p><p>+</p><p>+static void fe_add_impl(uint32_t out[10], const uint32_t in1[10], const uint32_t in2[10])</p><p>+{</p><p>+	const uint32_t x20 = in1[9];</p><p>+	const uint32_t x21 = in1[8];</p><p>+	const uint32_t x19 = in1[7];</p><p>+	const uint32_t x17 = in1[6];</p><p>+	const uint32_t x15 = in1[5];</p><p>+	const uint32_t x13 = in1[4];</p><p>+	const uint32_t x11 = in1[3];</p><p>+	const uint32_t x9 = in1[2];</p><p>+	const uint32_t x7 = in1[1];</p><p>+	const uint32_t x5 = in1[0];</p><p>+	const uint32_t x38 = in2[9];</p><p>+	const uint32_t x39 = in2[8];</p><p>+	const uint32_t x37 = in2[7];</p><p>+	const uint32_t x35 = in2[6];</p><p>+	const uint32_t x33 = in2[5];</p><p>+	const uint32_t x31 = in2[4];</p><p>+	const uint32_t x29 = in2[3];</p><p>+	const uint32_t x27 = in2[2];</p><p>+	const uint32_t x25 = in2[1];</p><p>+	const uint32_t x23 = in2[0];</p><p>+	out[0] = (x5 + x23);</p><p>+	out[1] = (x7 + x25);</p><p>+	out[2] = (x9 + x27);</p><p>+	out[3] = (x11 + x29);</p><p>+	out[4] = (x13 + x31);</p><p>+	out[5] = (x15 + x33);</p><p>+	out[6] = (x17 + x35);</p><p>+	out[7] = (x19 + x37);</p><p>+	out[8] = (x21 + x39);</p><p>+	out[9] = (x20 + x38);</p><p>+}</p><p>+</p><p>+/* h = f + g</p><p>+ * Can overlap h with f or g.</p><p>+ */</p><p>+static inline void fe_add(fe_loose *h, const fe *f, const fe *g)</p><p>+{</p><p>+	fe_add_impl(h-&gt;v, f-&gt;v, g-&gt;v);</p><p>+}</p><p>+</p><p>+static void fe_sub_impl(uint32_t out[10], const uint32_t in1[10], const uint32_t in2[10])</p><p>+{</p><p>+	const uint32_t x20 = in1[9];</p><p>+	const uint32_t x21 = in1[8];</p><p>+	const uint32_t x19 = in1[7];</p><p>+	const uint32_t x17 = in1[6];</p><p>+	const uint32_t x15 = in1[5];</p><p>+	const uint32_t x13 = in1[4];</p><p>+	const uint32_t x11 = in1[3];</p><p>+	const uint32_t x9 = in1[2];</p><p>+	const uint32_t x7 = in1[1];</p><p>+	const uint32_t x5 = in1[0];</p><p>+	const uint32_t x38 = in2[9];</p><p>+	const uint32_t x39 = in2[8];</p><p>+	const uint32_t x37 = in2[7];</p><p>+	const uint32_t x35 = in2[6];</p><p>+	const uint32_t x33 = in2[5];</p><p>+	const uint32_t x31 = in2[4];</p><p>+	const uint32_t x29 = in2[3];</p><p>+	const uint32_t x27 = in2[2];</p><p>+	const uint32_t x25 = in2[1];</p><p>+	const uint32_t x23 = in2[0];</p><p>+	out[0] = ((0x7ffffda + x5) - x23);</p><p>+	out[1] = ((0x3fffffe + x7) - x25);</p><p>+	out[2] = ((0x7fffffe + x9) - x27);</p><p>+	out[3] = ((0x3fffffe + x11) - x29);</p><p>+	out[4] = ((0x7fffffe + x13) - x31);</p><p>+	out[5] = ((0x3fffffe + x15) - x33);</p><p>+	out[6] = ((0x7fffffe + x17) - x35);</p><p>+	out[7] = ((0x3fffffe + x19) - x37);</p><p>+	out[8] = ((0x7fffffe + x21) - x39);</p><p>+	out[9] = ((0x3fffffe + x20) - x38);</p><p>+}</p><p>+</p><p>+/* h = f - g</p><p>+ * Can overlap h with f or g.</p><p>+ */</p><p>+static inline void fe_sub(fe_loose *h, const fe *f, const fe *g)</p><p>+{</p><p>+	fe_sub_impl(h-&gt;v, f-&gt;v, g-&gt;v);</p><p>+}</p><p>+</p><p>+static void fe_mul_impl(uint32_t out[10], const uint32_t in1[10], const uint32_t in2[10])</p><p>+{</p><p>+	const uint32_t x20 = in1[9];</p><p>+	const uint32_t x21 = in1[8];</p><p>+	const uint32_t x19 = in1[7];</p><p>+	const uint32_t x17 = in1[6];</p><p>+	const uint32_t x15 = in1[5];</p><p>+	const uint32_t x13 = in1[4];</p><p>+	const uint32_t x11 = in1[3];</p><p>+	const uint32_t x9 = in1[2];</p><p>+	const uint32_t x7 = in1[1];</p><p>+	const uint32_t x5 = in1[0];</p><p>+	const uint32_t x38 = in2[9];</p><p>+	const uint32_t x39 = in2[8];</p><p>+	const uint32_t x37 = in2[7];</p><p>+	const uint32_t x35 = in2[6];</p><p>+	const uint32_t x33 = in2[5];</p><p>+	const uint32_t x31 = in2[4];</p><p>+	const uint32_t x29 = in2[3];</p><p>+	const uint32_t x27 = in2[2];</p><p>+	const uint32_t x25 = in2[1];</p><p>+	const uint32_t x23 = in2[0];</p><p>+	uint64_t x40 = ((uint64_t)x23 * x5);</p><p>+	uint64_t x41 = (((uint64_t)x23 * x7) + ((uint64_t)x25 * x5));</p><p>+	uint64_t x42 = ((((uint64_t)(0x2 * x25) * x7) + ((uint64_t)x23 * x9)) + ((uint64_t)x27 * x5));</p><p>+	uint64_t x43 = (((((uint64_t)x25 * x9) + ((uint64_t)x27 * x7)) + ((uint64_t)x23 * x11)) + ((uint64_t)x29 * x5));</p><p>+	uint64_t x44 = (((((uint64_t)x27 * x9) + (0x2 * (((uint64_t)x25 * x11) + ((uint64_t)x29 * x7)))) + ((uint64_t)x23 * x13)) + ((uint64_t)x31 * x5));</p><p>+	uint64_t x45 = (((((((uint64_t)x27 * x11) + ((uint64_t)x29 * x9)) + ((uint64_t)x25 * x13)) + ((uint64_t)x31 * x7)) + ((uint64_t)x23 * x15)) + ((uint64_t)x33 * x5));</p><p>+	uint64_t x46 = (((((0x2 * ((((uint64_t)x29 * x11) + ((uint64_t)x25 * x15)) + ((uint64_t)x33 * x7))) + ((uint64_t)x27 * x13)) + ((uint64_t)x31 * x9)) + ((uint64_t)x23 * x17)) + ((uint64_t)x35 * x5));</p><p>+	uint64_t x47 = (((((((((uint64_t)x29 * x13) + ((uint64_t)x31 * x11)) + ((uint64_t)x27 * x15)) + ((uint64_t)x33 * x9)) + ((uint64_t)x25 * x17)) + ((uint64_t)x35 * x7)) + ((uint64_t)x23 * x19)) + ((uint64_t)x37 * x5));</p><p>+	uint64_t x48 = (((((((uint64_t)x31 * x13) + (0x2 * (((((uint64_t)x29 * x15) + ((uint64_t)x33 * x11)) + ((uint64_t)x25 * x19)) + ((uint64_t)x37 * x7)))) + ((uint64_t)x27 * x17)) + ((uint64_t)x35 * x9)) + ((uint64_t)x23 * x21)) + ((uint64_t)x39 * x5));</p><p>+	uint64_t x49 = (((((((((((uint64_t)x31 * x15) + ((uint64_t)x33 * x13)) + ((uint64_t)x29 * x17)) + ((uint64_t)x35 * x11)) + ((uint64_t)x27 * x19)) + ((uint64_t)x37 * x9)) + ((uint64_t)x25 * x21)) + ((uint64_t)x39 * x7)) + ((uint64_t)x23 * x20)) + ((uint64_t)x38 * x5));</p><p>+	uint64_t x50 = (((((0x2 * ((((((uint64_t)x33 * x15) + ((uint64_t)x29 * x19)) + ((uint64_t)x37 * x11)) + ((uint64_t)x25 * x20)) + ((uint64_t)x38 * x7))) + ((uint64_t)x31 * x17)) + ((uint64_t)x35 * x13)) + ((uint64_t)x27 * x21)) + ((uint64_t)x39 * x9));</p><p>+	uint64_t x51 = (((((((((uint64_t)x33 * x17) + ((uint64_t)x35 * x15)) + ((uint64_t)x31 * x19)) + ((uint64_t)x37 * x13)) + ((uint64_t)x29 * x21)) + ((uint64_t)x39 * x11)) + ((uint64_t)x27 * x20)) + ((uint64_t)x38 * x9));</p><p>+	uint64_t x52 = (((((uint64_t)x35 * x17) + (0x2 * (((((uint64_t)x33 * x19) + ((uint64_t)x37 * x15)) + ((uint64_t)x29 * x20)) + ((uint64_t)x38 * x11)))) + ((uint64_t)x31 * x21)) + ((uint64_t)x39 * x13));</p><p>+	uint64_t x53 = (((((((uint64_t)x35 * x19) + ((uint64_t)x37 * x17)) + ((uint64_t)x33 * x21)) + ((uint64_t)x39 * x15)) + ((uint64_t)x31 * x20)) + ((uint64_t)x38 * x13));</p><p>+	uint64_t x54 = (((0x2 * ((((uint64_t)x37 * x19) + ((uint64_t)x33 * x20)) + ((uint64_t)x38 * x15))) + ((uint64_t)x35 * x21)) + ((uint64_t)x39 * x17));</p><p>+	uint64_t x55 = (((((uint64_t)x37 * x21) + ((uint64_t)x39 * x19)) + ((uint64_t)x35 * x20)) + ((uint64_t)x38 * x17));</p><p>+	uint64_t x56 = (((uint64_t)x39 * x21) + (0x2 * (((uint64_t)x37 * x20) + ((uint64_t)x38 * x19))));</p><p>+	uint64_t x57 = (((uint64_t)x39 * x20) + ((uint64_t)x38 * x21));</p><p>+	uint64_t x58 = ((uint64_t)(0x2 * x38) * x20);</p><p>+	uint64_t x59 = (x48 + (x58 &lt;&lt; 0x4));</p><p>+	uint64_t x60 = (x59 + (x58 &lt;&lt; 0x1));</p><p>+	uint64_t x61 = (x60 + x58);</p><p>+	uint64_t x62 = (x47 + (x57 &lt;&lt; 0x4));</p><p>+	uint64_t x63 = (x62 + (x57 &lt;&lt; 0x1));</p><p>+	uint64_t x64 = (x63 + x57);</p><p>+	uint64_t x65 = (x46 + (x56 &lt;&lt; 0x4));</p><p>+	uint64_t x66 = (x65 + (x56 &lt;&lt; 0x1));</p><p>+	uint64_t x67 = (x66 + x56);</p><p>+	uint64_t x68 = (x45 + (x55 &lt;&lt; 0x4));</p><p>+	uint64_t x69 = (x68 + (x55 &lt;&lt; 0x1));</p><p>+	uint64_t x70 = (x69 + x55);</p><p>+	uint64_t x71 = (x44 + (x54 &lt;&lt; 0x4));</p><p>+	uint64_t x72 = (x71 + (x54 &lt;&lt; 0x1));</p><p>+	uint64_t x73 = (x72 + x54);</p><p>+	uint64_t x74 = (x43 + (x53 &lt;&lt; 0x4));</p><p>+	uint64_t x75 = (x74 + (x53 &lt;&lt; 0x1));</p><p>+	uint64_t x76 = (x75 + x53);</p><p>+	uint64_t x77 = (x42 + (x52 &lt;&lt; 0x4));</p><p>+	uint64_t x78 = (x77 + (x52 &lt;&lt; 0x1));</p><p>+	uint64_t x79 = (x78 + x52);</p><p>+	uint64_t x80 = (x41 + (x51 &lt;&lt; 0x4));</p><p>+	uint64_t x81 = (x80 + (x51 &lt;&lt; 0x1));</p><p>+	uint64_t x82 = (x81 + x51);</p><p>+	uint64_t x83 = (x40 + (x50 &lt;&lt; 0x4));</p><p>+	uint64_t x84 = (x83 + (x50 &lt;&lt; 0x1));</p><p>+	uint64_t x85 = (x84 + x50);</p><p>+	uint64_t x86 = (x85 &gt;&gt; 0x1a);</p><p>+	uint32_t x87 = ((uint32_t)x85 &amp; 0x3ffffff);</p><p>+	uint64_t x88 = (x86 + x82);</p><p>+	uint64_t x89 = (x88 &gt;&gt; 0x19);</p><p>+	uint32_t x90 = ((uint32_t)x88 &amp; 0x1ffffff);</p><p>+	uint64_t x91 = (x89 + x79);</p><p>+	uint64_t x92 = (x91 &gt;&gt; 0x1a);</p><p>+	uint32_t x93 = ((uint32_t)x91 &amp; 0x3ffffff);</p><p>+	uint64_t x94 = (x92 + x76);</p><p>+	uint64_t x95 = (x94 &gt;&gt; 0x19);</p><p>+	uint32_t x96 = ((uint32_t)x94 &amp; 0x1ffffff);</p><p>+	uint64_t x97 = (x95 + x73);</p><p>+	uint64_t x98 = (x97 &gt;&gt; 0x1a);</p><p>+	uint32_t x99 = ((uint32_t)x97 &amp; 0x3ffffff);</p><p>+	uint64_t x100 = (x98 + x70);</p><p>+	uint64_t x101 = (x100 &gt;&gt; 0x19);</p><p>+	uint32_t x102 = ((uint32_t)x100 &amp; 0x1ffffff);</p><p>+	uint64_t x103 = (x101 + x67);</p><p>+	uint64_t x104 = (x103 &gt;&gt; 0x1a);</p><p>+	uint32_t x105 = ((uint32_t)x103 &amp; 0x3ffffff);</p><p>+	uint64_t x106 = (x104 + x64);</p><p>+	uint64_t x107 = (x106 &gt;&gt; 0x19);</p><p>+	uint32_t x108 = ((uint32_t)x106 &amp; 0x1ffffff);</p><p>+	uint64_t x109 = (x107 + x61);</p><p>+	uint64_t x110 = (x109 &gt;&gt; 0x1a);</p><p>+	uint32_t x111 = ((uint32_t)x109 &amp; 0x3ffffff);</p><p>+	uint64_t x112 = (x110 + x49);</p><p>+	uint64_t x113 = (x112 &gt;&gt; 0x19);</p><p>+	uint32_t x114 = ((uint32_t)x112 &amp; 0x1ffffff);</p><p>+	uint64_t x115 = (x87 + (0x13 * x113));</p><p>+	uint32_t x116 = (uint32_t) (x115 &gt;&gt; 0x1a);</p><p>+	uint32_t x117 = ((uint32_t)x115 &amp; 0x3ffffff);</p><p>+	uint32_t x118 = (x116 + x90);</p><p>+	uint32_t x119 = (x118 &gt;&gt; 0x19);</p><p>+	uint32_t x120 = (x118 &amp; 0x1ffffff);</p><p>+	out[0] = x117;</p><p>+	out[1] = x120;</p><p>+	out[2] = (x119 + x93);</p><p>+	out[3] = x96;</p><p>+	out[4] = x99;</p><p>+	out[5] = x102;</p><p>+	out[6] = x105;</p><p>+	out[7] = x108;</p><p>+	out[8] = x111;</p><p>+	out[9] = x114;</p><p>+}</p><p>+</p><p>+static inline void fe_mul_ttt(fe *h, const fe *f, const fe *g)</p><p>+{</p><p>+	fe_mul_impl(h-&gt;v, f-&gt;v, g-&gt;v);</p><p>+}</p><p>+</p><p>+static inline void fe_mul_tlt(fe *h, const fe_loose *f, const fe *g)</p><p>+{</p><p>+	fe_mul_impl(h-&gt;v, f-&gt;v, g-&gt;v);</p><p>+}</p><p>+</p><p>+static inline void</p><p>+fe_mul_tll(fe *h, const fe_loose *f, const fe_loose *g)</p><p>+{</p><p>+	fe_mul_impl(h-&gt;v, f-&gt;v, g-&gt;v);</p><p>+}</p><p>+</p><p>+static void fe_sqr_impl(uint32_t out[10], const uint32_t in1[10])</p><p>+{</p><p>+	const uint32_t x17 = in1[9];</p><p>+	const uint32_t x18 = in1[8];</p><p>+	const uint32_t x16 = in1[7];</p><p>+	const uint32_t x14 = in1[6];</p><p>+	const uint32_t x12 = in1[5];</p><p>+	const uint32_t x10 = in1[4];</p><p>+	const uint32_t x8 = in1[3];</p><p>+	const uint32_t x6 = in1[2];</p><p>+	const uint32_t x4 = in1[1];</p><p>+	const uint32_t x2 = in1[0];</p><p>+	uint64_t x19 = ((uint64_t)x2 * x2);</p><p>+	uint64_t x20 = ((uint64_t)(0x2 * x2) * x4);</p><p>+	uint64_t x21 = (0x2 * (((uint64_t)x4 * x4) + ((uint64_t)x2 * x6)));</p><p>+	uint64_t x22 = (0x2 * (((uint64_t)x4 * x6) + ((uint64_t)x2 * x8)));</p><p>+	uint64_t x23 = ((((uint64_t)x6 * x6) + ((uint64_t)(0x4 * x4) * x8)) + ((uint64_t)(0x2 * x2) * x10));</p><p>+	uint64_t x24 = (0x2 * ((((uint64_t)x6 * x8) + ((uint64_t)x4 * x10)) + ((uint64_t)x2 * x12)));</p><p>+	uint64_t x25 = (0x2 * (((((uint64_t)x8 * x8) + ((uint64_t)x6 * x10)) + ((uint64_t)x2 * x14)) + ((uint64_t)(0x2 * x4) * x12)));</p><p>+	uint64_t x26 = (0x2 * (((((uint64_t)x8 * x10) + ((uint64_t)x6 * x12)) + ((uint64_t)x4 * x14)) + ((uint64_t)x2 * x16)));</p><p>+	uint64_t x27 = (((uint64_t)x10 * x10) + (0x2 * ((((uint64_t)x6 * x14) + ((uint64_t)x2 * x18)) + (0x2 * (((uint64_t)x4 * x16) + ((uint64_t)x8 * x12))))));</p><p>+	uint64_t x28 = (0x2 * ((((((uint64_t)x10 * x12) + ((uint64_t)x8 * x14)) + ((uint64_t)x6 * x16)) + ((uint64_t)x4 * x18)) + ((uint64_t)x2 * x17)));</p><p>+	uint64_t x29 = (0x2 * (((((uint64_t)x12 * x12) + ((uint64_t)x10 * x14)) + ((uint64_t)x6 * x18)) + (0x2 * (((uint64_t)x8 * x16) + ((uint64_t)x4 * x17)))));</p><p>+	uint64_t x30 = (0x2 * (((((uint64_t)x12 * x14) + ((uint64_t)x10 * x16)) + ((uint64_t)x8 * x18)) + ((uint64_t)x6 * x17)));</p><p>+	uint64_t x31 = (((uint64_t)x14 * x14) + (0x2 * (((uint64_t)x10 * x18) + (0x2 * (((uint64_t)x12 * x16) + ((uint64_t)x8 * x17))))));</p><p>+	uint64_t x32 = (0x2 * ((((uint64_t)x14 * x16) + ((uint64_t)x12 * x18)) + ((uint64_t)x10 * x17)));</p><p>+	uint64_t x33 = (0x2 * ((((uint64_t)x16 * x16) + ((uint64_t)x14 * x18)) + ((uint64_t)(0x2 * x12) * x17)));</p><p>+	uint64_t x34 = (0x2 * (((uint64_t)x16 * x18) + ((uint64_t)x14 * x17)));</p><p>+	uint64_t x35 = (((uint64_t)x18 * x18) + ((uint64_t)(0x4 * x16) * x17));</p><p>+	uint64_t x36 = ((uint64_t)(0x2 * x18) * x17);</p><p>+	uint64_t x37 = ((uint64_t)(0x2 * x17) * x17);</p><p>+	uint64_t x38 = (x27 + (x37 &lt;&lt; 0x4));</p><p>+	uint64_t x39 = (x38 + (x37 &lt;&lt; 0x1));</p><p>+	uint64_t x40 = (x39 + x37);</p><p>+	uint64_t x41 = (x26 + (x36 &lt;&lt; 0x4));</p><p>+	uint64_t x42 = (x41 + (x36 &lt;&lt; 0x1));</p><p>+	uint64_t x43 = (x42 + x36);</p><p>+	uint64_t x44 = (x25 + (x35 &lt;&lt; 0x4));</p><p>+	uint64_t x45 = (x44 + (x35 &lt;&lt; 0x1));</p><p>+	uint64_t x46 = (x45 + x35);</p><p>+	uint64_t x47 = (x24 + (x34 &lt;&lt; 0x4));</p><p>+	uint64_t x48 = (x47 + (x34 &lt;&lt; 0x1));</p><p>+	uint64_t x49 = (x48 + x34);</p><p>+	uint64_t x50 = (x23 + (x33 &lt;&lt; 0x4));</p><p>+	uint64_t x51 = (x50 + (x33 &lt;&lt; 0x1));</p><p>+	uint64_t x52 = (x51 + x33);</p><p>+	uint64_t x53 = (x22 + (x32 &lt;&lt; 0x4));</p><p>+	uint64_t x54 = (x53 + (x32 &lt;&lt; 0x1));</p><p>+	uint64_t x55 = (x54 + x32);</p><p>+	uint64_t x56 = (x21 + (x31 &lt;&lt; 0x4));</p><p>+	uint64_t x57 = (x56 + (x31 &lt;&lt; 0x1));</p><p>+	uint64_t x58 = (x57 + x31);</p><p>+	uint64_t x59 = (x20 + (x30 &lt;&lt; 0x4));</p><p>+	uint64_t x60 = (x59 + (x30 &lt;&lt; 0x1));</p><p>+	uint64_t x61 = (x60 + x30);</p><p>+	uint64_t x62 = (x19 + (x29 &lt;&lt; 0x4));</p><p>+	uint64_t x63 = (x62 + (x29 &lt;&lt; 0x1));</p><p>+	uint64_t x64 = (x63 + x29);</p><p>+	uint64_t x65 = (x64 &gt;&gt; 0x1a);</p><p>+	uint32_t x66 = ((uint32_t)x64 &amp; 0x3ffffff);</p><p>+	uint64_t x67 = (x65 + x61);</p><p>+	uint64_t x68 = (x67 &gt;&gt; 0x19);</p><p>+	uint32_t x69 = ((uint32_t)x67 &amp; 0x1ffffff);</p><p>+	uint64_t x70 = (x68 + x58);</p><p>+	uint64_t x71 = (x70 &gt;&gt; 0x1a);</p><p>+	uint32_t x72 = ((uint32_t)x70 &amp; 0x3ffffff);</p><p>+	uint64_t x73 = (x71 + x55);</p><p>+	uint64_t x74 = (x73 &gt;&gt; 0x19);</p><p>+	uint32_t x75 = ((uint32_t)x73 &amp; 0x1ffffff);</p><p>+	uint64_t x76 = (x74 + x52);</p><p>+	uint64_t x77 = (x76 &gt;&gt; 0x1a);</p><p>+	uint32_t x78 = ((uint32_t)x76 &amp; 0x3ffffff);</p><p>+	uint64_t x79 = (x77 + x49);</p><p>+	uint64_t x80 = (x79 &gt;&gt; 0x19);</p><p>+	uint32_t x81 = ((uint32_t)x79 &amp; 0x1ffffff);</p><p>+	uint64_t x82 = (x80 + x46);</p><p>+	uint64_t x83 = (x82 &gt;&gt; 0x1a);</p><p>+	uint32_t x84 = ((uint32_t)x82 &amp; 0x3ffffff);</p><p>+	uint64_t x85 = (x83 + x43);</p><p>+	uint64_t x86 = (x85 &gt;&gt; 0x19);</p><p>+	uint32_t x87 = ((uint32_t)x85 &amp; 0x1ffffff);</p><p>+	uint64_t x88 = (x86 + x40);</p><p>+	uint64_t x89 = (x88 &gt;&gt; 0x1a);</p><p>+	uint32_t x90 = ((uint32_t)x88 &amp; 0x3ffffff);</p><p>+	uint64_t x91 = (x89 + x28);</p><p>+	uint64_t x92 = (x91 &gt;&gt; 0x19);</p><p>+	uint32_t x93 = ((uint32_t)x91 &amp; 0x1ffffff);</p><p>+	uint64_t x94 = (x66 + (0x13 * x92));</p><p>+	uint32_t x95 = (uint32_t) (x94 &gt;&gt; 0x1a);</p><p>+	uint32_t x96 = ((uint32_t)x94 &amp; 0x3ffffff);</p><p>+	uint32_t x97 = (x95 + x69);</p><p>+	uint32_t x98 = (x97 &gt;&gt; 0x19);</p><p>+	uint32_t x99 = (x97 &amp; 0x1ffffff);</p><p>+	out[0] = x96;</p><p>+	out[1] = x99;</p><p>+	out[2] = (x98 + x72);</p><p>+	out[3] = x75;</p><p>+	out[4] = x78;</p><p>+	out[5] = x81;</p><p>+	out[6] = x84;</p><p>+	out[7] = x87;</p><p>+	out[8] = x90;</p><p>+	out[9] = x93;</p><p>+}</p><p>+</p><p>+static inline void fe_sq_tl(fe *h, const fe_loose *f)</p><p>+{</p><p>+	fe_sqr_impl(h-&gt;v, f-&gt;v);</p><p>+}</p><p>+</p><p>+static inline void fe_sq_tt(fe *h, const fe *f)</p><p>+{</p><p>+	fe_sqr_impl(h-&gt;v, f-&gt;v);</p><p>+}</p><p>+</p><p>+static inline void fe_loose_invert(fe *out, const fe_loose *z)</p><p>+{</p><p>+	fe t0;</p><p>+	fe t1;</p><p>+	fe t2;</p><p>+	fe t3;</p><p>+	int i;</p><p>+</p><p>+	fe_sq_tl(&amp;t0, z);</p><p>+	fe_sq_tt(&amp;t1, &amp;t0);</p><p>+	for (i = 1; i &lt; 2; ++i)</p><p>+		fe_sq_tt(&amp;t1, &amp;t1);</p><p>+	fe_mul_tlt(&amp;t1, z, &amp;t1);</p><p>+	fe_mul_ttt(&amp;t0, &amp;t0, &amp;t1);</p><p>+	fe_sq_tt(&amp;t2, &amp;t0);</p><p>+	fe_mul_ttt(&amp;t1, &amp;t1, &amp;t2);</p><p>+	fe_sq_tt(&amp;t2, &amp;t1);</p><p>+	for (i = 1; i &lt; 5; ++i)</p><p>+		fe_sq_tt(&amp;t2, &amp;t2);</p><p>+	fe_mul_ttt(&amp;t1, &amp;t2, &amp;t1);</p><p>+	fe_sq_tt(&amp;t2, &amp;t1);</p><p>+	for (i = 1; i &lt; 10; ++i)</p><p>+		fe_sq_tt(&amp;t2, &amp;t2);</p><p>+	fe_mul_ttt(&amp;t2, &amp;t2, &amp;t1);</p><p>+	fe_sq_tt(&amp;t3, &amp;t2);</p><p>+	for (i = 1; i &lt; 20; ++i)</p><p>+		fe_sq_tt(&amp;t3, &amp;t3);</p><p>+	fe_mul_ttt(&amp;t2, &amp;t3, &amp;t2);</p><p>+	fe_sq_tt(&amp;t2, &amp;t2);</p><p>+	for (i = 1; i &lt; 10; ++i)</p><p>+		fe_sq_tt(&amp;t2, &amp;t2);</p><p>+	fe_mul_ttt(&amp;t1, &amp;t2, &amp;t1);</p><p>+	fe_sq_tt(&amp;t2, &amp;t1);</p><p>+	for (i = 1; i &lt; 50; ++i)</p><p>+		fe_sq_tt(&amp;t2, &amp;t2);</p><p>+	fe_mul_ttt(&amp;t2, &amp;t2, &amp;t1);</p><p>+	fe_sq_tt(&amp;t3, &amp;t2);</p><p>+	for (i = 1; i &lt; 100; ++i)</p><p>+		fe_sq_tt(&amp;t3, &amp;t3);</p><p>+	fe_mul_ttt(&amp;t2, &amp;t3, &amp;t2);</p><p>+	fe_sq_tt(&amp;t2, &amp;t2);</p><p>+	for (i = 1; i &lt; 50; ++i)</p><p>+		fe_sq_tt(&amp;t2, &amp;t2);</p><p>+	fe_mul_ttt(&amp;t1, &amp;t2, &amp;t1);</p><p>+	fe_sq_tt(&amp;t1, &amp;t1);</p><p>+	for (i = 1; i &lt; 5; ++i)</p><p>+		fe_sq_tt(&amp;t1, &amp;t1);</p><p>+	fe_mul_ttt(out, &amp;t1, &amp;t0);</p><p>+}</p><p>+</p><p>+static inline void fe_invert(fe *out, const fe *z)</p><p>+{</p><p>+	fe_loose l;</p><p>+	fe_copy_lt(&amp;l, z);</p><p>+	fe_loose_invert(out, &amp;l);</p><p>+}</p><p>+</p><p>+/* Replace (f,g) with (g,f) if b == 1;</p><p>+ * replace (f,g) with (f,g) if b == 0.</p><p>+ *</p><p>+ * Preconditions: b in {0,1}</p><p>+ */</p><p>+static inline void fe_cswap(fe *f, fe *g, unsigned int b)</p><p>+{</p><p>+	unsigned i;</p><p>+	b = 0 - b;</p><p>+	for (i = 0; i &lt; 10; i++) {</p><p>+		uint32_t x = f-&gt;v[i] ^ g-&gt;v[i];</p><p>+		x &amp;= b;</p><p>+		f-&gt;v[i] ^= x;</p><p>+		g-&gt;v[i] ^= x;</p><p>+	}</p><p>+}</p><p>+</p><p>+/* NOTE: based on fiat-crypto fe_mul, edited for in2=121666, 0, 0.*/</p><p>+static inline void fe_mul_121666_impl(uint32_t out[10], const uint32_t in1[10])</p><p>+{</p><p>+	const uint32_t x20 = in1[9];</p><p>+	const uint32_t x21 = in1[8];</p><p>+	const uint32_t x19 = in1[7];</p><p>+	const uint32_t x17 = in1[6];</p><p>+	const uint32_t x15 = in1[5];</p><p>+	const uint32_t x13 = in1[4];</p><p>+	const uint32_t x11 = in1[3];</p><p>+	const uint32_t x9 = in1[2];</p><p>+	const uint32_t x7 = in1[1];</p><p>+	const uint32_t x5 = in1[0];</p><p>+	const uint32_t x38 = 0;</p><p>+	const uint32_t x39 = 0;</p><p>+	const uint32_t x37 = 0;</p><p>+	const uint32_t x35 = 0;</p><p>+	const uint32_t x33 = 0;</p><p>+	const uint32_t x31 = 0;</p><p>+	const uint32_t x29 = 0;</p><p>+	const uint32_t x27 = 0;</p><p>+	const uint32_t x25 = 0;</p><p>+	const uint32_t x23 = 121666;</p><p>+	uint64_t x40 = ((uint64_t)x23 * x5);</p><p>+	uint64_t x41 = (((uint64_t)x23 * x7) + ((uint64_t)x25 * x5));</p><p>+	uint64_t x42 = ((((uint64_t)(0x2 * x25) * x7) + ((uint64_t)x23 * x9)) + ((uint64_t)x27 * x5));</p><p>+	uint64_t x43 = (((((uint64_t)x25 * x9) + ((uint64_t)x27 * x7)) + ((uint64_t)x23 * x11)) + ((uint64_t)x29 * x5));</p><p>+	uint64_t x44 = (((((uint64_t)x27 * x9) + (0x2 * (((uint64_t)x25 * x11) + ((uint64_t)x29 * x7)))) + ((uint64_t)x23 * x13)) + ((uint64_t)x31 * x5));</p><p>+	uint64_t x45 = (((((((uint64_t)x27 * x11) + ((uint64_t)x29 * x9)) + ((uint64_t)x25 * x13)) + ((uint64_t)x31 * x7)) + ((uint64_t)x23 * x15)) + ((uint64_t)x33 * x5));</p><p>+	uint64_t x46 = (((((0x2 * ((((uint64_t)x29 * x11) + ((uint64_t)x25 * x15)) + ((uint64_t)x33 * x7))) + ((uint64_t)x27 * x13)) + ((uint64_t)x31 * x9)) + ((uint64_t)x23 * x17)) + ((uint64_t)x35 * x5));</p><p>+	uint64_t x47 = (((((((((uint64_t)x29 * x13) + ((uint64_t)x31 * x11)) + ((uint64_t)x27 * x15)) + ((uint64_t)x33 * x9)) + ((uint64_t)x25 * x17)) + ((uint64_t)x35 * x7)) + ((uint64_t)x23 * x19)) + ((uint64_t)x37 * x5));</p><p>+	uint64_t x48 = (((((((uint64_t)x31 * x13) + (0x2 * (((((uint64_t)x29 * x15) + ((uint64_t)x33 * x11)) + ((uint64_t)x25 * x19)) + ((uint64_t)x37 * x7)))) + ((uint64_t)x27 * x17)) + ((uint64_t)x35 * x9)) + ((uint64_t)x23 * x21)) + ((uint64_t)x39 * x5));</p><p>+	uint64_t x49 = (((((((((((uint64_t)x31 * x15) + ((uint64_t)x33 * x13)) + ((uint64_t)x29 * x17)) + ((uint64_t)x35 * x11)) + ((uint64_t)x27 * x19)) + ((uint64_t)x37 * x9)) + ((uint64_t)x25 * x21)) + ((uint64_t)x39 * x7)) + ((uint64_t)x23 * x20)) + ((uint64_t)x38 * x5));</p><p>+	uint64_t x50 = (((((0x2 * ((((((uint64_t)x33 * x15) + ((uint64_t)x29 * x19)) + ((uint64_t)x37 * x11)) + ((uint64_t)x25 * x20)) + ((uint64_t)x38 * x7))) + ((uint64_t)x31 * x17)) + ((uint64_t)x35 * x13)) + ((uint64_t)x27 * x21)) + ((uint64_t)x39 * x9));</p><p>+	uint64_t x51 = (((((((((uint64_t)x33 * x17) + ((uint64_t)x35 * x15)) + ((uint64_t)x31 * x19)) + ((uint64_t)x37 * x13)) + ((uint64_t)x29 * x21)) + ((uint64_t)x39 * x11)) + ((uint64_t)x27 * x20)) + ((uint64_t)x38 * x9));</p><p>+	uint64_t x52 = (((((uint64_t)x35 * x17) + (0x2 * (((((uint64_t)x33 * x19) + ((uint64_t)x37 * x15)) + ((uint64_t)x29 * x20)) + ((uint64_t)x38 * x11)))) + ((uint64_t)x31 * x21)) + ((uint64_t)x39 * x13));</p><p>+	uint64_t x53 = (((((((uint64_t)x35 * x19) + ((uint64_t)x37 * x17)) + ((uint64_t)x33 * x21)) + ((uint64_t)x39 * x15)) + ((uint64_t)x31 * x20)) + ((uint64_t)x38 * x13));</p><p>+	uint64_t x54 = (((0x2 * ((((uint64_t)x37 * x19) + ((uint64_t)x33 * x20)) + ((uint64_t)x38 * x15))) + ((uint64_t)x35 * x21)) + ((uint64_t)x39 * x17));</p><p>+	uint64_t x55 = (((((uint64_t)x37 * x21) + ((uint64_t)x39 * x19)) + ((uint64_t)x35 * x20)) + ((uint64_t)x38 * x17));</p><p>+	uint64_t x56 = (((uint64_t)x39 * x21) + (0x2 * (((uint64_t)x37 * x20) + ((uint64_t)x38 * x19))));</p><p>+	uint64_t x57 = (((uint64_t)x39 * x20) + ((uint64_t)x38 * x21));</p><p>+	uint64_t x58 = ((uint64_t)(0x2 * x38) * x20);</p><p>+	uint64_t x59 = (x48 + (x58 &lt;&lt; 0x4));</p><p>+	uint64_t x60 = (x59 + (x58 &lt;&lt; 0x1));</p><p>+	uint64_t x61 = (x60 + x58);</p><p>+	uint64_t x62 = (x47 + (x57 &lt;&lt; 0x4));</p><p>+	uint64_t x63 = (x62 + (x57 &lt;&lt; 0x1));</p><p>+	uint64_t x64 = (x63 + x57);</p><p>+	uint64_t x65 = (x46 + (x56 &lt;&lt; 0x4));</p><p>+	uint64_t x66 = (x65 + (x56 &lt;&lt; 0x1));</p><p>+	uint64_t x67 = (x66 + x56);</p><p>+	uint64_t x68 = (x45 + (x55 &lt;&lt; 0x4));</p><p>+	uint64_t x69 = (x68 + (x55 &lt;&lt; 0x1));</p><p>+	uint64_t x70 = (x69 + x55);</p><p>+	uint64_t x71 = (x44 + (x54 &lt;&lt; 0x4));</p><p>+	uint64_t x72 = (x71 + (x54 &lt;&lt; 0x1));</p><p>+	uint64_t x73 = (x72 + x54);</p><p>+	uint64_t x74 = (x43 + (x53 &lt;&lt; 0x4));</p><p>+	uint64_t x75 = (x74 + (x53 &lt;&lt; 0x1));</p><p>+	uint64_t x76 = (x75 + x53);</p><p>+	uint64_t x77 = (x42 + (x52 &lt;&lt; 0x4));</p><p>+	uint64_t x78 = (x77 + (x52 &lt;&lt; 0x1));</p><p>+	uint64_t x79 = (x78 + x52);</p><p>+	uint64_t x80 = (x41 + (x51 &lt;&lt; 0x4));</p><p>+	uint64_t x81 = (x80 + (x51 &lt;&lt; 0x1));</p><p>+	uint64_t x82 = (x81 + x51);</p><p>+	uint64_t x83 = (x40 + (x50 &lt;&lt; 0x4));</p><p>+	uint64_t x84 = (x83 + (x50 &lt;&lt; 0x1));</p><p>+	uint64_t x85 = (x84 + x50);</p><p>+	uint64_t x86 = (x85 &gt;&gt; 0x1a);</p><p>+	uint32_t x87 = ((uint32_t)x85 &amp; 0x3ffffff);</p><p>+	uint64_t x88 = (x86 + x82);</p><p>+	uint64_t x89 = (x88 &gt;&gt; 0x19);</p><p>+	uint32_t x90 = ((uint32_t)x88 &amp; 0x1ffffff);</p><p>+	uint64_t x91 = (x89 + x79);</p><p>+	uint64_t x92 = (x91 &gt;&gt; 0x1a);</p><p>+	uint32_t x93 = ((uint32_t)x91 &amp; 0x3ffffff);</p><p>+	uint64_t x94 = (x92 + x76);</p><p>+	uint64_t x95 = (x94 &gt;&gt; 0x19);</p><p>+	uint32_t x96 = ((uint32_t)x94 &amp; 0x1ffffff);</p><p>+	uint64_t x97 = (x95 + x73);</p><p>+	uint64_t x98 = (x97 &gt;&gt; 0x1a);</p><p>+	uint32_t x99 = ((uint32_t)x97 &amp; 0x3ffffff);</p><p>+	uint64_t x100 = (x98 + x70);</p><p>+	uint64_t x101 = (x100 &gt;&gt; 0x19);</p><p>+	uint32_t x102 = ((uint32_t)x100 &amp; 0x1ffffff);</p><p>+	uint64_t x103 = (x101 + x67);</p><p>+	uint64_t x104 = (x103 &gt;&gt; 0x1a);</p><p>+	uint32_t x105 = ((uint32_t)x103 &amp; 0x3ffffff);</p><p>+	uint64_t x106 = (x104 + x64);</p><p>+	uint64_t x107 = (x106 &gt;&gt; 0x19);</p><p>+	uint32_t x108 = ((uint32_t)x106 &amp; 0x1ffffff);</p><p>+	uint64_t x109 = (x107 + x61);</p><p>+	uint64_t x110 = (x109 &gt;&gt; 0x1a);</p><p>+	uint32_t x111 = ((uint32_t)x109 &amp; 0x3ffffff);</p><p>+	uint64_t x112 = (x110 + x49);</p><p>+	uint64_t x113 = (x112 &gt;&gt; 0x19);</p><p>+	uint32_t x114 = ((uint32_t)x112 &amp; 0x1ffffff);</p><p>+	uint64_t x115 = (x87 + (0x13 * x113));</p><p>+	uint32_t x116 = (uint32_t) (x115 &gt;&gt; 0x1a);</p><p>+	uint32_t x117 = ((uint32_t)x115 &amp; 0x3ffffff);</p><p>+	uint32_t x118 = (x116 + x90);</p><p>+	uint32_t x119 = (x118 &gt;&gt; 0x19);</p><p>+	uint32_t x120 = (x118 &amp; 0x1ffffff);</p><p>+	out[0] = x117;</p><p>+	out[1] = x120;</p><p>+	out[2] = (x119 + x93);</p><p>+	out[3] = x96;</p><p>+	out[4] = x99;</p><p>+	out[5] = x102;</p><p>+	out[6] = x105;</p><p>+	out[7] = x108;</p><p>+	out[8] = x111;</p><p>+	out[9] = x114;</p><p>+}</p><p>+</p><p>+static inline void fe_mul121666(fe *h, const fe_loose *f)</p><p>+{</p><p>+	fe_mul_121666_impl(h-&gt;v, f-&gt;v);</p><p>+}</p><p>+</p><p>+static const uint8_t curve25519_null_point[CURVE25519_KEY_SIZE];</p><p>+</p><p>+bool curve25519(uint8_t out[CURVE25519_KEY_SIZE],</p><p>+		const uint8_t scalar[CURVE25519_KEY_SIZE],</p><p>+		const uint8_t point[CURVE25519_KEY_SIZE])</p><p>+{</p><p>+	fe x1, x2, z2, x3, z3;</p><p>+	fe_loose x2l, z2l, x3l;</p><p>+	unsigned swap = 0;</p><p>+	int pos;</p><p>+	uint8_t e[32];</p><p>+</p><p>+	memcpy(e, scalar, 32);</p><p>+	curve25519_clamp_secret(e);</p><p>+</p><p>+	/* The following implementation was transcribed to Coq and proven to</p><p>+	 * correspond to unary scalar multiplication in affine coordinates given</p><p>+	 * that x1 != 0 is the x coordinate of some point on the curve. It was</p><p>+	 * also checked in Coq that doing a ladderstep with x1 = x3 = 0 gives</p><p>+	 * z2&#39; = z3&#39; = 0, and z2 = z3 = 0 gives z2&#39; = z3&#39; = 0. The statement was</p><p>+	 * quantified over the underlying field, so it applies to Curve25519</p><p>+	 * itself and the quadratic twist of Curve25519. It was not proven in</p><p>+	 * Coq that prime-field arithmetic correctly simulates extension-field</p><p>+	 * arithmetic on prime-field values. The decoding of the byte array</p><p>+	 * representation of e was not considered.</p><p>+	 *</p><p>+	 * Specification of Montgomery curves in affine coordinates:</p><p>+	 * &lt;https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Spec/MontgomeryCurve.v#L27&gt;</p><p>+	 *</p><p>+	 * Proof that these form a group that is isomorphic to a Weierstrass</p><p>+	 * curve:</p><p>+	 * &lt;https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Curves/Montgomery/AffineProofs.v#L35&gt;</p><p>+	 *</p><p>+	 * Coq transcription and correctness proof of the loop</p><p>+	 * (where scalarbits=255):</p><p>+	 * &lt;https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Curves/Montgomery/XZ.v#L118&gt;</p><p>+	 * &lt;https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Curves/Montgomery/XZProofs.v#L278&gt;</p><p>+	 * preconditions: 0 &lt;= e &lt; 2^255 (not necessarily e &lt; order),</p><p>+	 * fe_invert(0) = 0</p><p>+	 */</p><p>+	fe_frombytes(&amp;x1, point);</p><p>+	fe_1(&amp;x2);</p><p>+	fe_0(&amp;z2);</p><p>+	fe_copy(&amp;x3, &amp;x1);</p><p>+	fe_1(&amp;z3);</p><p>+</p><p>+	for (pos = 254; pos &gt;= 0; --pos) {</p><p>+		fe tmp0, tmp1;</p><p>+		fe_loose tmp0l, tmp1l;</p><p>+		/* loop invariant as of right before the test, for the case</p><p>+		 * where x1 != 0:</p><p>+		 *   pos &gt;= -1; if z2 = 0 then x2 is nonzero; if z3 = 0 then x3</p><p>+		 *   is nonzero</p><p>+		 *   let r := e &gt;&gt; (pos+1) in the following equalities of</p><p>+		 *   projective points:</p><p>+		 *   to_xz (r*P)     === if swap then (x3, z3) else (x2, z2)</p><p>+		 *   to_xz ((r+1)*P) === if swap then (x2, z2) else (x3, z3)</p><p>+		 *   x1 is the nonzero x coordinate of the nonzero</p><p>+		 *   point (r*P-(r+1)*P)</p><p>+		 */</p><p>+		unsigned b = 1 &amp; (e[pos / 8] &gt;&gt; (pos &amp; 7));</p><p>+		swap ^= b;</p><p>+		fe_cswap(&amp;x2, &amp;x3, swap);</p><p>+		fe_cswap(&amp;z2, &amp;z3, swap);</p><p>+		swap = b;</p><p>+		/* Coq transcription of ladderstep formula (called from</p><p>+		 * transcribed loop):</p><p>+		 * &lt;https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Curves/Montgomery/XZ.v#L89&gt;</p><p>+		 * &lt;https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Curves/Montgomery/XZProofs.v#L131&gt;</p><p>+		 * x1 != 0 &lt;https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Curves/Montgomery/XZProofs.v#L217&gt;</p><p>+		 * x1  = 0 &lt;https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Curves/Montgomery/XZProofs.v#L147&gt;</p><p>+		 */</p><p>+		fe_sub(&amp;tmp0l, &amp;x3, &amp;z3);</p><p>+		fe_sub(&amp;tmp1l, &amp;x2, &amp;z2);</p><p>+		fe_add(&amp;x2l, &amp;x2, &amp;z2);</p><p>+		fe_add(&amp;z2l, &amp;x3, &amp;z3);</p><p>+		fe_mul_tll(&amp;z3, &amp;tmp0l, &amp;x2l);</p><p>+		fe_mul_tll(&amp;z2, &amp;z2l, &amp;tmp1l);</p><p>+		fe_sq_tl(&amp;tmp0, &amp;tmp1l);</p><p>+		fe_sq_tl(&amp;tmp1, &amp;x2l);</p><p>+		fe_add(&amp;x3l, &amp;z3, &amp;z2);</p><p>+		fe_sub(&amp;z2l, &amp;z3, &amp;z2);</p><p>+		fe_mul_ttt(&amp;x2, &amp;tmp1, &amp;tmp0);</p><p>+		fe_sub(&amp;tmp1l, &amp;tmp1, &amp;tmp0);</p><p>+		fe_sq_tl(&amp;z2, &amp;z2l);</p><p>+		fe_mul121666(&amp;z3, &amp;tmp1l);</p><p>+		fe_sq_tl(&amp;x3, &amp;x3l);</p><p>+		fe_add(&amp;tmp0l, &amp;tmp0, &amp;z3);</p><p>+		fe_mul_ttt(&amp;z3, &amp;x1, &amp;z2);</p><p>+		fe_mul_tll(&amp;z2, &amp;tmp1l, &amp;tmp0l);</p><p>+	}</p><p>+	/* here pos=-1, so r=e, so to_xz (e*P) === if swap then (x3, z3)</p><p>+	 * else (x2, z2)</p><p>+	 */</p><p>+	fe_cswap(&amp;x2, &amp;x3, swap);</p><p>+	fe_cswap(&amp;z2, &amp;z3, swap);</p><p>+</p><p>+	fe_invert(&amp;z2, &amp;z2);</p><p>+	fe_mul_ttt(&amp;x2, &amp;x2, &amp;z2);</p><p>+	fe_tobytes(out, &amp;x2);</p><p>+</p><p>+	explicit_bzero(&amp;x1, sizeof(x1));</p><p>+	explicit_bzero(&amp;x2, sizeof(x2));</p><p>+	explicit_bzero(&amp;z2, sizeof(z2));</p><p>+	explicit_bzero(&amp;x3, sizeof(x3));</p><p>+	explicit_bzero(&amp;z3, sizeof(z3));</p><p>+	explicit_bzero(&amp;x2l, sizeof(x2l));</p><p>+	explicit_bzero(&amp;z2l, sizeof(z2l));</p><p>+	explicit_bzero(&amp;x3l, sizeof(x3l));</p><p>+	explicit_bzero(&amp;e, sizeof(e));</p><p>+</p><p>+	return timingsafe_bcmp(out, curve25519_null_point, CURVE25519_KEY_SIZE) != 0;</p><p>+}</p><p>+#endif</p><p>+</p><p>+int</p><p>+crypto_init(void)</p><p>+{</p><p>+#ifndef COMPAT_NEED_CHACHA20POLY1305_MBUF</p><p>+	struct crypto_session_params csp = {</p><p>+		.csp_mode = CSP_MODE_AEAD,</p><p>+		.csp_ivlen = sizeof(uint64_t),</p><p>+		.csp_cipher_alg = CRYPTO_CHACHA20_POLY1305,</p><p>+		.csp_cipher_klen = CHACHA20POLY1305_KEY_SIZE,</p><p>+		.csp_flags = CSP_F_SEPARATE_AAD | CSP_F_SEPARATE_OUTPUT</p><p>+	};</p><p>+	int ret = crypto_newsession(&amp;chacha20_poly1305_sid, &amp;csp, CRYPTOCAP_F_SOFTWARE);</p><p>+	if (ret != 0)</p><p>+		return (ret);</p><p>+#endif</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+void</p><p>+crypto_deinit(void)</p><p>+{</p><p>+#ifndef COMPAT_NEED_CHACHA20POLY1305_MBUF</p><p>+	crypto_freesession(chacha20_poly1305_sid);</p><p>+#endif</p><p>+}</p><div><p>diff --git a/sys/dev/wg/wg_noise.c b/sys/dev/wg/wg_noise.c</p></div><p>@@ -0,0 +1,1410 @@</p><p>+/* SPDX-License-Identifier: ISC</p><p>+ *</p><p>+ * Copyright (C) 2015-2021 Jason A. Donenfeld &lt;Jason@zx2c4.com&gt;. All Rights Reserved.</p><p>+ * Copyright (C) 2019-2021 Matt Dunwoodie &lt;ncon@noconroy.net&gt;</p><p>+ * Copyright (c) 2022 The FreeBSD Foundation</p><p>+ */</p><p>+</p><p>+#include &lt;sys/param.h&gt;</p><p>+#include &lt;sys/systm.h&gt;</p><p>+#include &lt;sys/ck.h&gt;</p><p>+#include &lt;sys/endian.h&gt;</p><p>+#include &lt;sys/epoch.h&gt;</p><p>+#include &lt;sys/kernel.h&gt;</p><p>+#include &lt;sys/lock.h&gt;</p><p>+#include &lt;sys/malloc.h&gt;</p><p>+#include &lt;sys/mutex.h&gt;</p><p>+#include &lt;sys/refcount.h&gt;</p><p>+#include &lt;sys/rwlock.h&gt;</p><p>+#include &lt;crypto/siphash/siphash.h&gt;</p><p>+</p><p>+#include &#34;crypto.h&#34;</p><p>+#include &#34;wg_noise.h&#34;</p><p>+#include &#34;support.h&#34;</p><p>+</p><p>+/* Protocol string constants */</p><p>+#define NOISE_HANDSHAKE_NAME	&#34;Noise_IKpsk2_25519_ChaChaPoly_BLAKE2s&#34;</p><p>+#define NOISE_IDENTIFIER_NAME	&#34;WireGuard v1 zx2c4 Jason@zx2c4.com&#34;</p><p>+</p><p>+/* Constants for the counter */</p><p>+#define COUNTER_BITS_TOTAL	8192</p><p>+#ifdef __LP64__</p><p>+#define COUNTER_ORDER		6</p><p>+#define COUNTER_BITS		64</p><p>+#else</p><p>+#define COUNTER_ORDER		5</p><p>+#define COUNTER_BITS		32</p><p>+#endif</p><p>+#define COUNTER_REDUNDANT_BITS	COUNTER_BITS</p><p>+#define COUNTER_WINDOW_SIZE	(COUNTER_BITS_TOTAL - COUNTER_REDUNDANT_BITS)</p><p>+</p><p>+/* Constants for the keypair */</p><p>+#define REKEY_AFTER_MESSAGES	(1ull &lt;&lt; 60)</p><p>+#define REJECT_AFTER_MESSAGES	(UINT64_MAX - COUNTER_WINDOW_SIZE - 1)</p><p>+#define REKEY_AFTER_TIME	120</p><p>+#define REKEY_AFTER_TIME_RECV	165</p><p>+#define REJECT_INTERVAL		(1000000000 / 50) /* fifty times per sec */</p><p>+/* 24 = floor(log2(REJECT_INTERVAL)) */</p><p>+#define REJECT_INTERVAL_MASK	(~((1ull&lt;&lt;24)-1))</p><p>+#define TIMER_RESET		(SBT_1S * -(REKEY_TIMEOUT+1))</p><p>+</p><p>+#define HT_INDEX_SIZE		(1 &lt;&lt; 13)</p><p>+#define HT_INDEX_MASK		(HT_INDEX_SIZE - 1)</p><p>+#define HT_REMOTE_SIZE		(1 &lt;&lt; 11)</p><p>+#define HT_REMOTE_MASK		(HT_REMOTE_SIZE - 1)</p><p>+#define MAX_REMOTE_PER_LOCAL	(1 &lt;&lt; 20)</p><p>+</p><p>+struct noise_index {</p><p>+	CK_LIST_ENTRY(noise_index)	 i_entry;</p><p>+	uint32_t			 i_local_index;</p><p>+	uint32_t			 i_remote_index;</p><p>+	int				 i_is_keypair;</p><p>+};</p><p>+</p><p>+struct noise_keypair {</p><p>+	struct noise_index		 kp_index;</p><p>+	u_int				 kp_refcnt;</p><p>+	bool				 kp_can_send;</p><p>+	bool				 kp_is_initiator;</p><p>+	sbintime_t			 kp_birthdate; /* sbinuptime */</p><p>+	struct noise_remote		*kp_remote;</p><p>+</p><p>+	uint8_t				 kp_send[NOISE_SYMMETRIC_KEY_LEN];</p><p>+	uint8_t				 kp_recv[NOISE_SYMMETRIC_KEY_LEN];</p><p>+</p><p>+	/* Counter elements */</p><p>+	struct rwlock			 kp_nonce_lock;</p><p>+	uint64_t			 kp_nonce_send;</p><p>+	uint64_t			 kp_nonce_recv;</p><p>+	unsigned long			 kp_backtrack[COUNTER_BITS_TOTAL / COUNTER_BITS];</p><p>+</p><p>+	struct epoch_context		 kp_smr;</p><p>+};</p><p>+</p><p>+struct noise_handshake {</p><p>+	uint8_t	 			 hs_e[NOISE_PUBLIC_KEY_LEN];</p><p>+	uint8_t	 			 hs_hash[NOISE_HASH_LEN];</p><p>+	uint8_t	 			 hs_ck[NOISE_HASH_LEN];</p><p>+};</p><p>+</p><p>+enum noise_handshake_state {</p><p>+	HANDSHAKE_DEAD,</p><p>+	HANDSHAKE_INITIATOR,</p><p>+	HANDSHAKE_RESPONDER,</p><p>+};</p><p>+</p><p>+struct noise_remote {</p><p>+	struct noise_index		 r_index;</p><p>+</p><p>+	CK_LIST_ENTRY(noise_remote) 	 r_entry;</p><p>+	bool				 r_entry_inserted;</p><p>+	uint8_t				 r_public[NOISE_PUBLIC_KEY_LEN];</p><p>+</p><p>+	struct rwlock			 r_handshake_lock;</p><p>+	struct noise_handshake		 r_handshake;</p><p>+	enum noise_handshake_state	 r_handshake_state;</p><p>+	sbintime_t			 r_last_sent; /* sbinuptime */</p><p>+	sbintime_t			 r_last_init_recv; /* sbinuptime */</p><p>+	uint8_t				 r_timestamp[NOISE_TIMESTAMP_LEN];</p><p>+	uint8_t				 r_psk[NOISE_SYMMETRIC_KEY_LEN];</p><p>+	uint8_t		 		 r_ss[NOISE_PUBLIC_KEY_LEN];</p><p>+</p><p>+	u_int				 r_refcnt;</p><p>+	struct noise_local		*r_local;</p><p>+	void				*r_arg;</p><p>+</p><p>+	struct mtx			 r_keypair_mtx;</p><p>+	struct noise_keypair		*r_next, *r_current, *r_previous;</p><p>+</p><p>+	struct epoch_context		 r_smr;</p><p>+	void				(*r_cleanup)(struct noise_remote *);</p><p>+};</p><p>+</p><p>+struct noise_local {</p><p>+	struct rwlock			 l_identity_lock;</p><p>+	bool				 l_has_identity;</p><p>+	uint8_t				 l_public[NOISE_PUBLIC_KEY_LEN];</p><p>+	uint8_t				 l_private[NOISE_PUBLIC_KEY_LEN];</p><p>+</p><p>+	u_int				 l_refcnt;</p><p>+	uint8_t				 l_hash_key[SIPHASH_KEY_LENGTH];</p><p>+	void				*l_arg;</p><p>+	void				(*l_cleanup)(struct noise_local *);</p><p>+</p><p>+	struct mtx			 l_remote_mtx;</p><p>+	size_t				 l_remote_num;</p><p>+	CK_LIST_HEAD(,noise_remote)	 l_remote_hash[HT_REMOTE_SIZE];</p><p>+</p><p>+	struct mtx			 l_index_mtx;</p><p>+	CK_LIST_HEAD(,noise_index)	 l_index_hash[HT_INDEX_SIZE];</p><p>+};</p><p>+</p><p>+static void	noise_precompute_ss(struct noise_local *, struct noise_remote *);</p><p>+</p><p>+static void	noise_remote_index_insert(struct noise_local *, struct noise_remote *);</p><p>+static struct noise_remote *</p><p>+		noise_remote_index_lookup(struct noise_local *, uint32_t, bool);</p><p>+static int	noise_remote_index_remove(struct noise_local *, struct noise_remote *);</p><p>+static void	noise_remote_expire_current(struct noise_remote *);</p><p>+</p><p>+static void	noise_add_new_keypair(struct noise_local *, struct noise_remote *, struct noise_keypair *);</p><p>+static int	noise_begin_session(struct noise_remote *);</p><p>+static void	noise_keypair_drop(struct noise_keypair *);</p><p>+</p><p>+static void	noise_kdf(uint8_t *, uint8_t *, uint8_t *, const uint8_t *,</p><p>+		    size_t, size_t, size_t, size_t,</p><p>+		    const uint8_t [NOISE_HASH_LEN]);</p><p>+static int	noise_mix_dh(uint8_t [NOISE_HASH_LEN], uint8_t [NOISE_SYMMETRIC_KEY_LEN],</p><p>+		    const uint8_t [NOISE_PUBLIC_KEY_LEN],</p><p>+		    const uint8_t [NOISE_PUBLIC_KEY_LEN]);</p><p>+static int	noise_mix_ss(uint8_t ck[NOISE_HASH_LEN], uint8_t [NOISE_SYMMETRIC_KEY_LEN],</p><p>+		    const uint8_t [NOISE_PUBLIC_KEY_LEN]);</p><p>+static void	noise_mix_hash(uint8_t [NOISE_HASH_LEN], const uint8_t *, size_t);</p><p>+static void	noise_mix_psk(uint8_t [NOISE_HASH_LEN], uint8_t [NOISE_HASH_LEN],</p><p>+		    uint8_t [NOISE_SYMMETRIC_KEY_LEN], const uint8_t [NOISE_SYMMETRIC_KEY_LEN]);</p><p>+static void	noise_param_init(uint8_t [NOISE_HASH_LEN], uint8_t [NOISE_HASH_LEN],</p><p>+		    const uint8_t [NOISE_PUBLIC_KEY_LEN]);</p><p>+static void	noise_msg_encrypt(uint8_t *, const uint8_t *, size_t,</p><p>+		    uint8_t [NOISE_SYMMETRIC_KEY_LEN], uint8_t [NOISE_HASH_LEN]);</p><p>+static int	noise_msg_decrypt(uint8_t *, const uint8_t *, size_t,</p><p>+		    uint8_t [NOISE_SYMMETRIC_KEY_LEN], uint8_t [NOISE_HASH_LEN]);</p><p>+static void	noise_msg_ephemeral(uint8_t [NOISE_HASH_LEN], uint8_t [NOISE_HASH_LEN],</p><p>+		    const uint8_t [NOISE_PUBLIC_KEY_LEN]);</p><p>+static void	noise_tai64n_now(uint8_t [NOISE_TIMESTAMP_LEN]);</p><p>+static int	noise_timer_expired(sbintime_t, uint32_t, uint32_t);</p><p>+static uint64_t siphash24(const uint8_t [SIPHASH_KEY_LENGTH], const void *, size_t);</p><p>+</p><p>+MALLOC_DEFINE(M_NOISE, &#34;NOISE&#34;, &#34;wgnoise&#34;);</p><p>+</p><p>+/* Local configuration */</p><p>+struct noise_local *</p><p>+noise_local_alloc(void *arg)</p><p>+{</p><p>+	struct noise_local *l;</p><p>+	size_t i;</p><p>+</p><p>+	l = malloc(sizeof(*l), M_NOISE, M_WAITOK | M_ZERO);</p><p>+</p><p>+	rw_init(&amp;l-&gt;l_identity_lock, &#34;noise_identity&#34;);</p><p>+	l-&gt;l_has_identity = false;</p><p>+	bzero(l-&gt;l_public, NOISE_PUBLIC_KEY_LEN);</p><p>+	bzero(l-&gt;l_private, NOISE_PUBLIC_KEY_LEN);</p><p>+</p><p>+	refcount_init(&amp;l-&gt;l_refcnt, 1);</p><p>+	arc4random_buf(l-&gt;l_hash_key, sizeof(l-&gt;l_hash_key));</p><p>+	l-&gt;l_arg = arg;</p><p>+	l-&gt;l_cleanup = NULL;</p><p>+</p><p>+	mtx_init(&amp;l-&gt;l_remote_mtx, &#34;noise_remote&#34;, NULL, MTX_DEF);</p><p>+	l-&gt;l_remote_num = 0;</p><p>+	for (i = 0; i &lt; HT_REMOTE_SIZE; i++)</p><p>+		CK_LIST_INIT(&amp;l-&gt;l_remote_hash[i]);</p><p>+</p><p>+	mtx_init(&amp;l-&gt;l_index_mtx, &#34;noise_index&#34;, NULL, MTX_DEF);</p><p>+	for (i = 0; i &lt; HT_INDEX_SIZE; i++)</p><p>+		CK_LIST_INIT(&amp;l-&gt;l_index_hash[i]);</p><p>+</p><p>+	return (l);</p><p>+}</p><p>+</p><p>+struct noise_local *</p><p>+noise_local_ref(struct noise_local *l)</p><p>+{</p><p>+	refcount_acquire(&amp;l-&gt;l_refcnt);</p><p>+	return (l);</p><p>+}</p><p>+</p><p>+void</p><p>+noise_local_put(struct noise_local *l)</p><p>+{</p><p>+	if (refcount_release(&amp;l-&gt;l_refcnt)) {</p><p>+		if (l-&gt;l_cleanup != NULL)</p><p>+			l-&gt;l_cleanup(l);</p><p>+		rw_destroy(&amp;l-&gt;l_identity_lock);</p><p>+		mtx_destroy(&amp;l-&gt;l_remote_mtx);</p><p>+		mtx_destroy(&amp;l-&gt;l_index_mtx);</p><p>+		explicit_bzero(l, sizeof(*l));</p><p>+		free(l, M_NOISE);</p><p>+	}</p><p>+}</p><p>+</p><p>+void</p><p>+noise_local_free(struct noise_local *l, void (*cleanup)(struct noise_local *))</p><p>+{</p><p>+	l-&gt;l_cleanup = cleanup;</p><p>+	noise_local_put(l);</p><p>+}</p><p>+</p><p>+void *</p><p>+noise_local_arg(struct noise_local *l)</p><p>+{</p><p>+	return (l-&gt;l_arg);</p><p>+}</p><p>+</p><p>+void</p><p>+noise_local_private(struct noise_local *l, const uint8_t private[NOISE_PUBLIC_KEY_LEN])</p><p>+{</p><p>+	struct epoch_tracker et;</p><p>+	struct noise_remote *r;</p><p>+	size_t i;</p><p>+</p><p>+	rw_wlock(&amp;l-&gt;l_identity_lock);</p><p>+	memcpy(l-&gt;l_private, private, NOISE_PUBLIC_KEY_LEN);</p><p>+	curve25519_clamp_secret(l-&gt;l_private);</p><p>+	l-&gt;l_has_identity = curve25519_generate_public(l-&gt;l_public, l-&gt;l_private);</p><p>+</p><p>+	NET_EPOCH_ENTER(et);</p><p>+	for (i = 0; i &lt; HT_REMOTE_SIZE; i++) {</p><p>+		CK_LIST_FOREACH(r, &amp;l-&gt;l_remote_hash[i], r_entry) {</p><p>+			noise_precompute_ss(l, r);</p><p>+			noise_remote_expire_current(r);</p><p>+		}</p><p>+	}</p><p>+	NET_EPOCH_EXIT(et);</p><p>+	rw_wunlock(&amp;l-&gt;l_identity_lock);</p><p>+}</p><p>+</p><p>+int</p><p>+noise_local_keys(struct noise_local *l, uint8_t public[NOISE_PUBLIC_KEY_LEN],</p><p>+    uint8_t private[NOISE_PUBLIC_KEY_LEN])</p><p>+{</p><p>+	int has_identity;</p><p>+	rw_rlock(&amp;l-&gt;l_identity_lock);</p><p>+	if ((has_identity = l-&gt;l_has_identity)) {</p><p>+		if (public != NULL)</p><p>+			memcpy(public, l-&gt;l_public, NOISE_PUBLIC_KEY_LEN);</p><p>+		if (private != NULL)</p><p>+			memcpy(private, l-&gt;l_private, NOISE_PUBLIC_KEY_LEN);</p><p>+	}</p><p>+	rw_runlock(&amp;l-&gt;l_identity_lock);</p><p>+	return (has_identity ? 0 : ENXIO);</p><p>+}</p><p>+</p><p>+static void</p><p>+noise_precompute_ss(struct noise_local *l, struct noise_remote *r)</p><p>+{</p><p>+	rw_wlock(&amp;r-&gt;r_handshake_lock);</p><p>+	if (!l-&gt;l_has_identity ||</p><p>+	    !curve25519(r-&gt;r_ss, l-&gt;l_private, r-&gt;r_public))</p><p>+		bzero(r-&gt;r_ss, NOISE_PUBLIC_KEY_LEN);</p><p>+	rw_wunlock(&amp;r-&gt;r_handshake_lock);</p><p>+}</p><p>+</p><p>+/* Remote configuration */</p><p>+struct noise_remote *</p><p>+noise_remote_alloc(struct noise_local *l, void *arg,</p><p>+    const uint8_t public[NOISE_PUBLIC_KEY_LEN])</p><p>+{</p><p>+	struct noise_remote *r;</p><p>+</p><p>+	r = malloc(sizeof(*r), M_NOISE, M_WAITOK | M_ZERO);</p><p>+	memcpy(r-&gt;r_public, public, NOISE_PUBLIC_KEY_LEN);</p><p>+</p><p>+	rw_init(&amp;r-&gt;r_handshake_lock, &#34;noise_handshake&#34;);</p><p>+	r-&gt;r_handshake_state = HANDSHAKE_DEAD;</p><p>+	r-&gt;r_last_sent = TIMER_RESET;</p><p>+	r-&gt;r_last_init_recv = TIMER_RESET;</p><p>+	noise_precompute_ss(l, r);</p><p>+</p><p>+	refcount_init(&amp;r-&gt;r_refcnt, 1);</p><p>+	r-&gt;r_local = noise_local_ref(l);</p><p>+	r-&gt;r_arg = arg;</p><p>+</p><p>+	mtx_init(&amp;r-&gt;r_keypair_mtx, &#34;noise_keypair&#34;, NULL, MTX_DEF);</p><p>+</p><p>+	return (r);</p><p>+}</p><p>+</p><p>+int</p><p>+noise_remote_enable(struct noise_remote *r)</p><p>+{</p><p>+	struct noise_local *l = r-&gt;r_local;</p><p>+	uint64_t idx;</p><p>+	int ret = 0;</p><p>+</p><p>+	/* Insert to hashtable */</p><p>+	idx = siphash24(l-&gt;l_hash_key, r-&gt;r_public, NOISE_PUBLIC_KEY_LEN) &amp; HT_REMOTE_MASK;</p><p>+</p><p>+	mtx_lock(&amp;l-&gt;l_remote_mtx);</p><p>+	if (!r-&gt;r_entry_inserted) {</p><p>+		if (l-&gt;l_remote_num &lt; MAX_REMOTE_PER_LOCAL) {</p><p>+			r-&gt;r_entry_inserted = true;</p><p>+			l-&gt;l_remote_num++;</p><p>+			CK_LIST_INSERT_HEAD(&amp;l-&gt;l_remote_hash[idx], r, r_entry);</p><p>+		} else {</p><p>+			ret = ENOSPC;</p><p>+		}</p><p>+	}</p><p>+	mtx_unlock(&amp;l-&gt;l_remote_mtx);</p><p>+</p><p>+	return ret;</p><p>+}</p><p>+</p><p>+void</p><p>+noise_remote_disable(struct noise_remote *r)</p><p>+{</p><p>+	struct noise_local *l = r-&gt;r_local;</p><p>+	/* remove from hashtable */</p><p>+	mtx_lock(&amp;l-&gt;l_remote_mtx);</p><p>+	if (r-&gt;r_entry_inserted) {</p><p>+		r-&gt;r_entry_inserted = false;</p><p>+		CK_LIST_REMOVE(r, r_entry);</p><p>+		l-&gt;l_remote_num--;</p><p>+	};</p><p>+	mtx_unlock(&amp;l-&gt;l_remote_mtx);</p><p>+}</p><p>+</p><p>+struct noise_remote *</p><p>+noise_remote_lookup(struct noise_local *l, const uint8_t public[NOISE_PUBLIC_KEY_LEN])</p><p>+{</p><p>+	struct epoch_tracker et;</p><p>+	struct noise_remote *r, *ret = NULL;</p><p>+	uint64_t idx;</p><p>+</p><p>+	idx = siphash24(l-&gt;l_hash_key, public, NOISE_PUBLIC_KEY_LEN) &amp; HT_REMOTE_MASK;</p><p>+</p><p>+	NET_EPOCH_ENTER(et);</p><p>+	CK_LIST_FOREACH(r, &amp;l-&gt;l_remote_hash[idx], r_entry) {</p><p>+		if (timingsafe_bcmp(r-&gt;r_public, public, NOISE_PUBLIC_KEY_LEN) == 0) {</p><p>+			if (refcount_acquire_if_not_zero(&amp;r-&gt;r_refcnt))</p><p>+				ret = r;</p><p>+			break;</p><p>+		}</p><p>+	}</p><p>+	NET_EPOCH_EXIT(et);</p><p>+	return (ret);</p><p>+}</p><p>+</p><p>+static void</p><p>+noise_remote_index_insert(struct noise_local *l, struct noise_remote *r)</p><p>+{</p><p>+	struct noise_index *i, *r_i = &amp;r-&gt;r_index;</p><p>+	struct epoch_tracker et;</p><p>+	uint32_t idx;</p><p>+</p><p>+	noise_remote_index_remove(l, r);</p><p>+</p><p>+	NET_EPOCH_ENTER(et);</p><p>+assign_id:</p><p>+	r_i-&gt;i_local_index = arc4random();</p><p>+	idx = r_i-&gt;i_local_index &amp; HT_INDEX_MASK;</p><p>+	CK_LIST_FOREACH(i, &amp;l-&gt;l_index_hash[idx], i_entry) {</p><p>+		if (i-&gt;i_local_index == r_i-&gt;i_local_index)</p><p>+			goto assign_id;</p><p>+	}</p><p>+</p><p>+	mtx_lock(&amp;l-&gt;l_index_mtx);</p><p>+	CK_LIST_FOREACH(i, &amp;l-&gt;l_index_hash[idx], i_entry) {</p><p>+		if (i-&gt;i_local_index == r_i-&gt;i_local_index) {</p><p>+			mtx_unlock(&amp;l-&gt;l_index_mtx);</p><p>+			goto assign_id;</p><p>+		}</p><p>+	}</p><p>+	CK_LIST_INSERT_HEAD(&amp;l-&gt;l_index_hash[idx], r_i, i_entry);</p><p>+	mtx_unlock(&amp;l-&gt;l_index_mtx);</p><p>+</p><p>+	NET_EPOCH_EXIT(et);</p><p>+}</p><p>+</p><p>+static struct noise_remote *</p><p>+noise_remote_index_lookup(struct noise_local *l, uint32_t idx0, bool lookup_keypair)</p><p>+{</p><p>+	struct epoch_tracker et;</p><p>+	struct noise_index *i;</p><p>+	struct noise_keypair *kp;</p><p>+	struct noise_remote *r, *ret = NULL;</p><p>+	uint32_t idx = idx0 &amp; HT_INDEX_MASK;</p><p>+</p><p>+	NET_EPOCH_ENTER(et);</p><p>+	CK_LIST_FOREACH(i, &amp;l-&gt;l_index_hash[idx], i_entry) {</p><p>+		if (i-&gt;i_local_index == idx0) {</p><p>+			if (!i-&gt;i_is_keypair) {</p><p>+				r = (struct noise_remote *) i;</p><p>+			} else if (lookup_keypair) {</p><p>+				kp = (struct noise_keypair *) i;</p><p>+				r = kp-&gt;kp_remote;</p><p>+			} else {</p><p>+				break;</p><p>+			}</p><p>+			if (refcount_acquire_if_not_zero(&amp;r-&gt;r_refcnt))</p><p>+				ret = r;</p><p>+			break;</p><p>+		}</p><p>+	}</p><p>+	NET_EPOCH_EXIT(et);</p><p>+	return (ret);</p><p>+}</p><p>+</p><p>+struct noise_remote *</p><p>+noise_remote_index(struct noise_local *l, uint32_t idx)</p><p>+{</p><p>+	return noise_remote_index_lookup(l, idx, true);</p><p>+}</p><p>+</p><p>+static int</p><p>+noise_remote_index_remove(struct noise_local *l, struct noise_remote *r)</p><p>+{</p><p>+	rw_assert(&amp;r-&gt;r_handshake_lock, RA_WLOCKED);</p><p>+	if (r-&gt;r_handshake_state != HANDSHAKE_DEAD) {</p><p>+		mtx_lock(&amp;l-&gt;l_index_mtx);</p><p>+		r-&gt;r_handshake_state = HANDSHAKE_DEAD;</p><p>+		CK_LIST_REMOVE(&amp;r-&gt;r_index, i_entry);</p><p>+		mtx_unlock(&amp;l-&gt;l_index_mtx);</p><p>+		return (1);</p><p>+	}</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+struct noise_remote *</p><p>+noise_remote_ref(struct noise_remote *r)</p><p>+{</p><p>+	refcount_acquire(&amp;r-&gt;r_refcnt);</p><p>+	return (r);</p><p>+}</p><p>+</p><p>+static void</p><p>+noise_remote_smr_free(struct epoch_context *smr)</p><p>+{</p><p>+	struct noise_remote *r;</p><p>+	r = __containerof(smr, struct noise_remote, r_smr);</p><p>+	if (r-&gt;r_cleanup != NULL)</p><p>+		r-&gt;r_cleanup(r);</p><p>+	noise_local_put(r-&gt;r_local);</p><p>+	rw_destroy(&amp;r-&gt;r_handshake_lock);</p><p>+	mtx_destroy(&amp;r-&gt;r_keypair_mtx);</p><p>+	explicit_bzero(r, sizeof(*r));</p><p>+	free(r, M_NOISE);</p><p>+}</p><p>+</p><p>+void</p><p>+noise_remote_put(struct noise_remote *r)</p><p>+{</p><p>+	if (refcount_release(&amp;r-&gt;r_refcnt))</p><p>+		NET_EPOCH_CALL(noise_remote_smr_free, &amp;r-&gt;r_smr);</p><p>+}</p><p>+</p><p>+void</p><p>+noise_remote_free(struct noise_remote *r, void (*cleanup)(struct noise_remote *))</p><p>+{</p><p>+	r-&gt;r_cleanup = cleanup;</p><p>+	noise_remote_disable(r);</p><p>+</p><p>+	/* now clear all keypairs and handshakes, then put this reference */</p><p>+	noise_remote_handshake_clear(r);</p><p>+	noise_remote_keypairs_clear(r);</p><p>+	noise_remote_put(r);</p><p>+}</p><p>+</p><p>+struct noise_local *</p><p>+noise_remote_local(struct noise_remote *r)</p><p>+{</p><p>+	return (noise_local_ref(r-&gt;r_local));</p><p>+}</p><p>+</p><p>+void *</p><p>+noise_remote_arg(struct noise_remote *r)</p><p>+{</p><p>+	return (r-&gt;r_arg);</p><p>+}</p><p>+</p><p>+void</p><p>+noise_remote_set_psk(struct noise_remote *r,</p><p>+    const uint8_t psk[NOISE_SYMMETRIC_KEY_LEN])</p><p>+{</p><p>+	rw_wlock(&amp;r-&gt;r_handshake_lock);</p><p>+	if (psk == NULL)</p><p>+		bzero(r-&gt;r_psk, NOISE_SYMMETRIC_KEY_LEN);</p><p>+	else</p><p>+		memcpy(r-&gt;r_psk, psk, NOISE_SYMMETRIC_KEY_LEN);</p><p>+	rw_wunlock(&amp;r-&gt;r_handshake_lock);</p><p>+}</p><p>+</p><p>+int</p><p>+noise_remote_keys(struct noise_remote *r, uint8_t public[NOISE_PUBLIC_KEY_LEN],</p><p>+    uint8_t psk[NOISE_SYMMETRIC_KEY_LEN])</p><p>+{</p><p>+	static uint8_t null_psk[NOISE_SYMMETRIC_KEY_LEN];</p><p>+	int ret;</p><p>+</p><p>+	if (public != NULL)</p><p>+		memcpy(public, r-&gt;r_public, NOISE_PUBLIC_KEY_LEN);</p><p>+</p><p>+	rw_rlock(&amp;r-&gt;r_handshake_lock);</p><p>+	if (psk != NULL)</p><p>+		memcpy(psk, r-&gt;r_psk, NOISE_SYMMETRIC_KEY_LEN);</p><p>+	ret = timingsafe_bcmp(r-&gt;r_psk, null_psk, NOISE_SYMMETRIC_KEY_LEN);</p><p>+	rw_runlock(&amp;r-&gt;r_handshake_lock);</p><p>+</p><p>+	return (ret ? 0 : ENOENT);</p><p>+}</p><p>+</p><p>+int</p><p>+noise_remote_initiation_expired(struct noise_remote *r)</p><p>+{</p><p>+	int expired;</p><p>+	rw_rlock(&amp;r-&gt;r_handshake_lock);</p><p>+	expired = noise_timer_expired(r-&gt;r_last_sent, REKEY_TIMEOUT, 0);</p><p>+	rw_runlock(&amp;r-&gt;r_handshake_lock);</p><p>+	return (expired);</p><p>+}</p><p>+</p><p>+void</p><p>+noise_remote_handshake_clear(struct noise_remote *r)</p><p>+{</p><p>+	rw_wlock(&amp;r-&gt;r_handshake_lock);</p><p>+	if (noise_remote_index_remove(r-&gt;r_local, r))</p><p>+		bzero(&amp;r-&gt;r_handshake, sizeof(r-&gt;r_handshake));</p><p>+	r-&gt;r_last_sent = TIMER_RESET;</p><p>+	rw_wunlock(&amp;r-&gt;r_handshake_lock);</p><p>+}</p><p>+</p><p>+void</p><p>+noise_remote_keypairs_clear(struct noise_remote *r)</p><p>+{</p><p>+	struct noise_keypair *kp;</p><p>+</p><p>+	mtx_lock(&amp;r-&gt;r_keypair_mtx);</p><p>+	kp = ck_pr_load_ptr(&amp;r-&gt;r_next);</p><p>+	ck_pr_store_ptr(&amp;r-&gt;r_next, NULL);</p><p>+	noise_keypair_drop(kp);</p><p>+</p><p>+	kp = ck_pr_load_ptr(&amp;r-&gt;r_current);</p><p>+	ck_pr_store_ptr(&amp;r-&gt;r_current, NULL);</p><p>+	noise_keypair_drop(kp);</p><p>+</p><p>+	kp = ck_pr_load_ptr(&amp;r-&gt;r_previous);</p><p>+	ck_pr_store_ptr(&amp;r-&gt;r_previous, NULL);</p><p>+	noise_keypair_drop(kp);</p><p>+	mtx_unlock(&amp;r-&gt;r_keypair_mtx);</p><p>+}</p><p>+</p><p>+static void</p><p>+noise_remote_expire_current(struct noise_remote *r)</p><p>+{</p><p>+	struct epoch_tracker et;</p><p>+	struct noise_keypair *kp;</p><p>+</p><p>+	noise_remote_handshake_clear(r);</p><p>+</p><p>+	NET_EPOCH_ENTER(et);</p><p>+	kp = ck_pr_load_ptr(&amp;r-&gt;r_next);</p><p>+	if (kp != NULL)</p><p>+		ck_pr_store_bool(&amp;kp-&gt;kp_can_send, false);</p><p>+	kp = ck_pr_load_ptr(&amp;r-&gt;r_current);</p><p>+	if (kp != NULL)</p><p>+		ck_pr_store_bool(&amp;kp-&gt;kp_can_send, false);</p><p>+	NET_EPOCH_EXIT(et);</p><p>+}</p><p>+</p><p>+/* Keypair functions */</p><p>+static void</p><p>+noise_add_new_keypair(struct noise_local *l, struct noise_remote *r,</p><p>+    struct noise_keypair *kp)</p><p>+{</p><p>+	struct noise_keypair *next, *current, *previous;</p><p>+	struct noise_index *r_i = &amp;r-&gt;r_index;</p><p>+</p><p>+	/* Insert into the keypair table */</p><p>+	mtx_lock(&amp;r-&gt;r_keypair_mtx);</p><p>+	next = ck_pr_load_ptr(&amp;r-&gt;r_next);</p><p>+	current = ck_pr_load_ptr(&amp;r-&gt;r_current);</p><p>+	previous = ck_pr_load_ptr(&amp;r-&gt;r_previous);</p><p>+</p><p>+	if (kp-&gt;kp_is_initiator) {</p><p>+		if (next != NULL) {</p><p>+			ck_pr_store_ptr(&amp;r-&gt;r_next, NULL);</p><p>+			ck_pr_store_ptr(&amp;r-&gt;r_previous, next);</p><p>+			noise_keypair_drop(current);</p><p>+		} else {</p><p>+			ck_pr_store_ptr(&amp;r-&gt;r_previous, current);</p><p>+		}</p><p>+		noise_keypair_drop(previous);</p><p>+		ck_pr_store_ptr(&amp;r-&gt;r_current, kp);</p><p>+	} else {</p><p>+		ck_pr_store_ptr(&amp;r-&gt;r_next, kp);</p><p>+		noise_keypair_drop(next);</p><p>+		ck_pr_store_ptr(&amp;r-&gt;r_previous, NULL);</p><p>+		noise_keypair_drop(previous);</p><p>+</p><p>+	}</p><p>+	mtx_unlock(&amp;r-&gt;r_keypair_mtx);</p><p>+</p><p>+	/* Insert into index table */</p><p>+	rw_assert(&amp;r-&gt;r_handshake_lock, RA_WLOCKED);</p><p>+</p><p>+	kp-&gt;kp_index.i_is_keypair = true;</p><p>+	kp-&gt;kp_index.i_local_index = r_i-&gt;i_local_index;</p><p>+	kp-&gt;kp_index.i_remote_index = r_i-&gt;i_remote_index;</p><p>+</p><p>+	mtx_lock(&amp;l-&gt;l_index_mtx);</p><p>+	CK_LIST_INSERT_BEFORE(r_i, &amp;kp-&gt;kp_index, i_entry);</p><p>+	r-&gt;r_handshake_state = HANDSHAKE_DEAD;</p><p>+	CK_LIST_REMOVE(r_i, i_entry);</p><p>+	mtx_unlock(&amp;l-&gt;l_index_mtx);</p><p>+</p><p>+	explicit_bzero(&amp;r-&gt;r_handshake, sizeof(r-&gt;r_handshake));</p><p>+}</p><p>+</p><p>+static int</p><p>+noise_begin_session(struct noise_remote *r)</p><p>+{</p><p>+	struct noise_keypair *kp;</p><p>+</p><p>+	rw_assert(&amp;r-&gt;r_handshake_lock, RA_WLOCKED);</p><p>+</p><p>+	if ((kp = malloc(sizeof(*kp), M_NOISE, M_NOWAIT | M_ZERO)) == NULL)</p><p>+		return (ENOSPC);</p><p>+</p><p>+	refcount_init(&amp;kp-&gt;kp_refcnt, 1);</p><p>+	kp-&gt;kp_can_send = true;</p><p>+	kp-&gt;kp_is_initiator = r-&gt;r_handshake_state == HANDSHAKE_INITIATOR;</p><p>+	kp-&gt;kp_birthdate = getsbinuptime();</p><p>+	kp-&gt;kp_remote = noise_remote_ref(r);</p><p>+</p><p>+	if (kp-&gt;kp_is_initiator)</p><p>+		noise_kdf(kp-&gt;kp_send, kp-&gt;kp_recv, NULL, NULL,</p><p>+		    NOISE_SYMMETRIC_KEY_LEN, NOISE_SYMMETRIC_KEY_LEN, 0, 0,</p><p>+		    r-&gt;r_handshake.hs_ck);</p><p>+	else</p><p>+		noise_kdf(kp-&gt;kp_recv, kp-&gt;kp_send, NULL, NULL,</p><p>+		    NOISE_SYMMETRIC_KEY_LEN, NOISE_SYMMETRIC_KEY_LEN, 0, 0,</p><p>+		    r-&gt;r_handshake.hs_ck);</p><p>+</p><p>+	rw_init(&amp;kp-&gt;kp_nonce_lock, &#34;noise_nonce&#34;);</p><p>+</p><p>+	noise_add_new_keypair(r-&gt;r_local, r, kp);</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+struct noise_keypair *</p><p>+noise_keypair_lookup(struct noise_local *l, uint32_t idx0)</p><p>+{</p><p>+	struct epoch_tracker et;</p><p>+	struct noise_index *i;</p><p>+	struct noise_keypair *kp, *ret = NULL;</p><p>+	uint32_t idx = idx0 &amp; HT_INDEX_MASK;</p><p>+</p><p>+	NET_EPOCH_ENTER(et);</p><p>+	CK_LIST_FOREACH(i, &amp;l-&gt;l_index_hash[idx], i_entry) {</p><p>+		if (i-&gt;i_local_index == idx0 &amp;&amp; i-&gt;i_is_keypair) {</p><p>+			kp = (struct noise_keypair *) i;</p><p>+			if (refcount_acquire_if_not_zero(&amp;kp-&gt;kp_refcnt))</p><p>+				ret = kp;</p><p>+			break;</p><p>+		}</p><p>+	}</p><p>+	NET_EPOCH_EXIT(et);</p><p>+	return (ret);</p><p>+}</p><p>+</p><p>+struct noise_keypair *</p><p>+noise_keypair_current(struct noise_remote *r)</p><p>+{</p><p>+	struct epoch_tracker et;</p><p>+	struct noise_keypair *kp, *ret = NULL;</p><p>+</p><p>+	NET_EPOCH_ENTER(et);</p><p>+	kp = ck_pr_load_ptr(&amp;r-&gt;r_current);</p><p>+	if (kp != NULL &amp;&amp; ck_pr_load_bool(&amp;kp-&gt;kp_can_send)) {</p><p>+		if (noise_timer_expired(kp-&gt;kp_birthdate, REJECT_AFTER_TIME, 0))</p><p>+			ck_pr_store_bool(&amp;kp-&gt;kp_can_send, false);</p><p>+		else if (refcount_acquire_if_not_zero(&amp;kp-&gt;kp_refcnt))</p><p>+			ret = kp;</p><p>+	}</p><p>+	NET_EPOCH_EXIT(et);</p><p>+	return (ret);</p><p>+}</p><p>+</p><p>+struct noise_keypair *</p><p>+noise_keypair_ref(struct noise_keypair *kp)</p><p>+{</p><p>+	refcount_acquire(&amp;kp-&gt;kp_refcnt);</p><p>+	return (kp);</p><p>+}</p><p>+</p><p>+int</p><p>+noise_keypair_received_with(struct noise_keypair *kp)</p><p>+{</p><p>+	struct noise_keypair *old;</p><p>+	struct noise_remote *r = kp-&gt;kp_remote;</p><p>+</p><p>+	if (kp != ck_pr_load_ptr(&amp;r-&gt;r_next))</p><p>+		return (0);</p><p>+</p><p>+	mtx_lock(&amp;r-&gt;r_keypair_mtx);</p><p>+	if (kp != ck_pr_load_ptr(&amp;r-&gt;r_next)) {</p><p>+		mtx_unlock(&amp;r-&gt;r_keypair_mtx);</p><p>+		return (0);</p><p>+	}</p><p>+</p><p>+	old = ck_pr_load_ptr(&amp;r-&gt;r_previous);</p><p>+	ck_pr_store_ptr(&amp;r-&gt;r_previous, ck_pr_load_ptr(&amp;r-&gt;r_current));</p><p>+	noise_keypair_drop(old);</p><p>+	ck_pr_store_ptr(&amp;r-&gt;r_current, kp);</p><p>+	ck_pr_store_ptr(&amp;r-&gt;r_next, NULL);</p><p>+	mtx_unlock(&amp;r-&gt;r_keypair_mtx);</p><p>+</p><p>+	return (ECONNRESET);</p><p>+}</p><p>+</p><p>+static void</p><p>+noise_keypair_smr_free(struct epoch_context *smr)</p><p>+{</p><p>+	struct noise_keypair *kp;</p><p>+	kp = __containerof(smr, struct noise_keypair, kp_smr);</p><p>+	noise_remote_put(kp-&gt;kp_remote);</p><p>+	rw_destroy(&amp;kp-&gt;kp_nonce_lock);</p><p>+	explicit_bzero(kp, sizeof(*kp));</p><p>+	free(kp, M_NOISE);</p><p>+}</p><p>+</p><p>+void</p><p>+noise_keypair_put(struct noise_keypair *kp)</p><p>+{</p><p>+	if (refcount_release(&amp;kp-&gt;kp_refcnt))</p><p>+		NET_EPOCH_CALL(noise_keypair_smr_free, &amp;kp-&gt;kp_smr);</p><p>+}</p><p>+</p><p>+static void</p><p>+noise_keypair_drop(struct noise_keypair *kp)</p><p>+{</p><p>+	struct noise_remote *r;</p><p>+	struct noise_local *l;</p><p>+</p><p>+	if (kp == NULL)</p><p>+		return;</p><p>+</p><p>+	r = kp-&gt;kp_remote;</p><p>+	l = r-&gt;r_local;</p><p>+</p><p>+	mtx_lock(&amp;l-&gt;l_index_mtx);</p><p>+	CK_LIST_REMOVE(&amp;kp-&gt;kp_index, i_entry);</p><p>+	mtx_unlock(&amp;l-&gt;l_index_mtx);</p><p>+</p><p>+	noise_keypair_put(kp);</p><p>+}</p><p>+</p><p>+struct noise_remote *</p><p>+noise_keypair_remote(struct noise_keypair *kp)</p><p>+{</p><p>+	return (noise_remote_ref(kp-&gt;kp_remote));</p><p>+}</p><p>+</p><p>+int</p><p>+noise_keypair_nonce_next(struct noise_keypair *kp, uint64_t *send)</p><p>+{</p><p>+	if (!ck_pr_load_bool(&amp;kp-&gt;kp_can_send))</p><p>+		return (EINVAL);</p><p>+</p><p>+#ifdef __LP64__</p><p>+	*send = ck_pr_faa_64(&amp;kp-&gt;kp_nonce_send, 1);</p><p>+#else</p><p>+	rw_wlock(&amp;kp-&gt;kp_nonce_lock);</p><p>+	*send = kp-&gt;kp_nonce_send++;</p><p>+	rw_wunlock(&amp;kp-&gt;kp_nonce_lock);</p><p>+#endif</p><p>+	if (*send &lt; REJECT_AFTER_MESSAGES)</p><p>+		return (0);</p><p>+	ck_pr_store_bool(&amp;kp-&gt;kp_can_send, false);</p><p>+	return (EINVAL);</p><p>+}</p><p>+</p><p>+int</p><p>+noise_keypair_nonce_check(struct noise_keypair *kp, uint64_t recv)</p><p>+{</p><p>+	unsigned long index, index_current, top, i, bit;</p><p>+	int ret = EEXIST;</p><p>+</p><p>+	rw_wlock(&amp;kp-&gt;kp_nonce_lock);</p><p>+</p><p>+	if (__predict_false(kp-&gt;kp_nonce_recv &gt;= REJECT_AFTER_MESSAGES + 1 ||</p><p>+			    recv &gt;= REJECT_AFTER_MESSAGES))</p><p>+		goto error;</p><p>+</p><p>+	++recv;</p><p>+</p><p>+	if (__predict_false(recv + COUNTER_WINDOW_SIZE &lt; kp-&gt;kp_nonce_recv))</p><p>+		goto error;</p><p>+</p><p>+	index = recv &gt;&gt; COUNTER_ORDER;</p><p>+</p><p>+	if (__predict_true(recv &gt; kp-&gt;kp_nonce_recv)) {</p><p>+		index_current = kp-&gt;kp_nonce_recv &gt;&gt; COUNTER_ORDER;</p><p>+		top = MIN(index - index_current, COUNTER_BITS_TOTAL / COUNTER_BITS);</p><p>+		for (i = 1; i &lt;= top; i++)</p><p>+			kp-&gt;kp_backtrack[</p><p>+			    (i + index_current) &amp;</p><p>+				((COUNTER_BITS_TOTAL / COUNTER_BITS) - 1)] = 0;</p><p>+#ifdef __LP64__</p><p>+		ck_pr_store_64(&amp;kp-&gt;kp_nonce_recv, recv);</p><p>+#else</p><p>+		kp-&gt;kp_nonce_recv = recv;</p><p>+#endif</p><p>+	}</p><p>+</p><p>+	index &amp;= (COUNTER_BITS_TOTAL / COUNTER_BITS) - 1;</p><p>+	bit = 1ul &lt;&lt; (recv &amp; (COUNTER_BITS - 1));</p><p>+	if (kp-&gt;kp_backtrack[index] &amp; bit)</p><p>+		goto error;</p><p>+</p><p>+	kp-&gt;kp_backtrack[index] |= bit;</p><p>+	ret = 0;</p><p>+error:</p><p>+	rw_wunlock(&amp;kp-&gt;kp_nonce_lock);</p><p>+	return (ret);</p><p>+}</p><p>+</p><p>+int</p><p>+noise_keep_key_fresh_send(struct noise_remote *r)</p><p>+{</p><p>+	struct epoch_tracker et;</p><p>+	struct noise_keypair *current;</p><p>+	int keep_key_fresh;</p><p>+	uint64_t nonce;</p><p>+</p><p>+	NET_EPOCH_ENTER(et);</p><p>+	current = ck_pr_load_ptr(&amp;r-&gt;r_current);</p><p>+	keep_key_fresh = current != NULL &amp;&amp; ck_pr_load_bool(&amp;current-&gt;kp_can_send);</p><p>+	if (!keep_key_fresh)</p><p>+		goto out;</p><p>+#ifdef __LP64__</p><p>+	nonce = ck_pr_load_64(&amp;current-&gt;kp_nonce_send);</p><p>+#else</p><p>+	rw_rlock(&amp;current-&gt;kp_nonce_lock);</p><p>+	nonce = current-&gt;kp_nonce_send;</p><p>+	rw_runlock(&amp;current-&gt;kp_nonce_lock);</p><p>+#endif</p><p>+	keep_key_fresh = nonce &gt; REKEY_AFTER_MESSAGES;</p><p>+	if (keep_key_fresh)</p><p>+		goto out;</p><p>+	keep_key_fresh = current-&gt;kp_is_initiator &amp;&amp; noise_timer_expired(current-&gt;kp_birthdate, REKEY_AFTER_TIME, 0);</p><p>+</p><p>+out:</p><p>+	NET_EPOCH_EXIT(et);</p><p>+	return (keep_key_fresh ? ESTALE : 0);</p><p>+}</p><p>+</p><p>+int</p><p>+noise_keep_key_fresh_recv(struct noise_remote *r)</p><p>+{</p><p>+	struct epoch_tracker et;</p><p>+	struct noise_keypair *current;</p><p>+	int keep_key_fresh;</p><p>+</p><p>+	NET_EPOCH_ENTER(et);</p><p>+	current = ck_pr_load_ptr(&amp;r-&gt;r_current);</p><p>+	keep_key_fresh = current != NULL &amp;&amp; ck_pr_load_bool(&amp;current-&gt;kp_can_send) &amp;&amp;</p><p>+	    current-&gt;kp_is_initiator &amp;&amp; noise_timer_expired(current-&gt;kp_birthdate,</p><p>+	    REJECT_AFTER_TIME - KEEPALIVE_TIMEOUT - REKEY_TIMEOUT, 0);</p><p>+	NET_EPOCH_EXIT(et);</p><p>+</p><p>+	return (keep_key_fresh ? ESTALE : 0);</p><p>+}</p><p>+</p><p>+int</p><p>+noise_keypair_encrypt(struct noise_keypair *kp, uint32_t *r_idx, uint64_t nonce, struct mbuf *m)</p><p>+{</p><p>+	int ret;</p><p>+</p><p>+	ret = chacha20poly1305_encrypt_mbuf(m, nonce, kp-&gt;kp_send);</p><p>+	if (ret)</p><p>+		return (ret);</p><p>+</p><p>+	*r_idx = kp-&gt;kp_index.i_remote_index;</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+int</p><p>+noise_keypair_decrypt(struct noise_keypair *kp, uint64_t nonce, struct mbuf *m)</p><p>+{</p><p>+	uint64_t cur_nonce;</p><p>+	int ret;</p><p>+</p><p>+#ifdef __LP64__</p><p>+	cur_nonce = ck_pr_load_64(&amp;kp-&gt;kp_nonce_recv);</p><p>+#else</p><p>+	rw_rlock(&amp;kp-&gt;kp_nonce_lock);</p><p>+	cur_nonce = kp-&gt;kp_nonce_recv;</p><p>+	rw_runlock(&amp;kp-&gt;kp_nonce_lock);</p><p>+#endif</p><p>+</p><p>+	if (cur_nonce &gt;= REJECT_AFTER_MESSAGES ||</p><p>+	    noise_timer_expired(kp-&gt;kp_birthdate, REJECT_AFTER_TIME, 0))</p><p>+		return (EINVAL);</p><p>+</p><p>+	ret = chacha20poly1305_decrypt_mbuf(m, nonce, kp-&gt;kp_recv);</p><p>+	if (ret)</p><p>+		return (ret);</p><p>+</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+/* Handshake functions */</p><p>+int</p><p>+noise_create_initiation(struct noise_remote *r,</p><p>+    uint32_t *s_idx,</p><p>+    uint8_t ue[NOISE_PUBLIC_KEY_LEN],</p><p>+    uint8_t es[NOISE_PUBLIC_KEY_LEN + NOISE_AUTHTAG_LEN],</p><p>+    uint8_t ets[NOISE_TIMESTAMP_LEN + NOISE_AUTHTAG_LEN])</p><p>+{</p><p>+	struct noise_handshake *hs = &amp;r-&gt;r_handshake;</p><p>+	struct noise_local *l = r-&gt;r_local;</p><p>+	uint8_t key[NOISE_SYMMETRIC_KEY_LEN];</p><p>+	int ret = EINVAL;</p><p>+</p><p>+	rw_rlock(&amp;l-&gt;l_identity_lock);</p><p>+	rw_wlock(&amp;r-&gt;r_handshake_lock);</p><p>+	if (!l-&gt;l_has_identity)</p><p>+		goto error;</p><p>+	if (!noise_timer_expired(r-&gt;r_last_sent, REKEY_TIMEOUT, 0))</p><p>+		goto error;</p><p>+	noise_param_init(hs-&gt;hs_ck, hs-&gt;hs_hash, r-&gt;r_public);</p><p>+</p><p>+	/* e */</p><p>+	curve25519_generate_secret(hs-&gt;hs_e);</p><p>+	if (curve25519_generate_public(ue, hs-&gt;hs_e) == 0)</p><p>+		goto error;</p><p>+	noise_msg_ephemeral(hs-&gt;hs_ck, hs-&gt;hs_hash, ue);</p><p>+</p><p>+	/* es */</p><p>+	if (noise_mix_dh(hs-&gt;hs_ck, key, hs-&gt;hs_e, r-&gt;r_public) != 0)</p><p>+		goto error;</p><p>+</p><p>+	/* s */</p><p>+	noise_msg_encrypt(es, l-&gt;l_public,</p><p>+	    NOISE_PUBLIC_KEY_LEN, key, hs-&gt;hs_hash);</p><p>+</p><p>+	/* ss */</p><p>+	if (noise_mix_ss(hs-&gt;hs_ck, key, r-&gt;r_ss) != 0)</p><p>+		goto error;</p><p>+</p><p>+	/* {t} */</p><p>+	noise_tai64n_now(ets);</p><p>+	noise_msg_encrypt(ets, ets,</p><p>+	    NOISE_TIMESTAMP_LEN, key, hs-&gt;hs_hash);</p><p>+</p><p>+	noise_remote_index_insert(l, r);</p><p>+	r-&gt;r_handshake_state = HANDSHAKE_INITIATOR;</p><p>+	r-&gt;r_last_sent = getsbinuptime();</p><p>+	*s_idx = r-&gt;r_index.i_local_index;</p><p>+	ret = 0;</p><p>+error:</p><p>+	rw_wunlock(&amp;r-&gt;r_handshake_lock);</p><p>+	rw_runlock(&amp;l-&gt;l_identity_lock);</p><p>+	explicit_bzero(key, NOISE_SYMMETRIC_KEY_LEN);</p><p>+	return (ret);</p><p>+}</p><p>+</p><p>+int</p><p>+noise_consume_initiation(struct noise_local *l, struct noise_remote **rp,</p><p>+    uint32_t s_idx,</p><p>+    uint8_t ue[NOISE_PUBLIC_KEY_LEN],</p><p>+    uint8_t es[NOISE_PUBLIC_KEY_LEN + NOISE_AUTHTAG_LEN],</p><p>+    uint8_t ets[NOISE_TIMESTAMP_LEN + NOISE_AUTHTAG_LEN])</p><p>+{</p><p>+	struct noise_remote *r;</p><p>+	struct noise_handshake hs;</p><p>+	uint8_t key[NOISE_SYMMETRIC_KEY_LEN];</p><p>+	uint8_t r_public[NOISE_PUBLIC_KEY_LEN];</p><p>+	uint8_t	timestamp[NOISE_TIMESTAMP_LEN];</p><p>+	int ret = EINVAL;</p><p>+</p><p>+	rw_rlock(&amp;l-&gt;l_identity_lock);</p><p>+	if (!l-&gt;l_has_identity)</p><p>+		goto error;</p><p>+	noise_param_init(hs.hs_ck, hs.hs_hash, l-&gt;l_public);</p><p>+</p><p>+	/* e */</p><p>+	noise_msg_ephemeral(hs.hs_ck, hs.hs_hash, ue);</p><p>+</p><p>+	/* es */</p><p>+	if (noise_mix_dh(hs.hs_ck, key, l-&gt;l_private, ue) != 0)</p><p>+		goto error;</p><p>+</p><p>+	/* s */</p><p>+	if (noise_msg_decrypt(r_public, es,</p><p>+	    NOISE_PUBLIC_KEY_LEN + NOISE_AUTHTAG_LEN, key, hs.hs_hash) != 0)</p><p>+		goto error;</p><p>+</p><p>+	/* Lookup the remote we received from */</p><p>+	if ((r = noise_remote_lookup(l, r_public)) == NULL)</p><p>+		goto error;</p><p>+</p><p>+	/* ss */</p><p>+	if (noise_mix_ss(hs.hs_ck, key, r-&gt;r_ss) != 0)</p><p>+		goto error_put;</p><p>+</p><p>+	/* {t} */</p><p>+	if (noise_msg_decrypt(timestamp, ets,</p><p>+	    NOISE_TIMESTAMP_LEN + NOISE_AUTHTAG_LEN, key, hs.hs_hash) != 0)</p><p>+		goto error_put;</p><p>+</p><p>+	memcpy(hs.hs_e, ue, NOISE_PUBLIC_KEY_LEN);</p><p>+</p><p>+	/* We have successfully computed the same results, now we ensure that</p><p>+	 * this is not an initiation replay, or a flood attack */</p><p>+	rw_wlock(&amp;r-&gt;r_handshake_lock);</p><p>+</p><p>+	/* Replay */</p><p>+	if (memcmp(timestamp, r-&gt;r_timestamp, NOISE_TIMESTAMP_LEN) &gt; 0)</p><p>+		memcpy(r-&gt;r_timestamp, timestamp, NOISE_TIMESTAMP_LEN);</p><p>+	else</p><p>+		goto error_set;</p><p>+	/* Flood attack */</p><p>+	if (noise_timer_expired(r-&gt;r_last_init_recv, 0, REJECT_INTERVAL))</p><p>+		r-&gt;r_last_init_recv = getsbinuptime();</p><p>+	else</p><p>+		goto error_set;</p><p>+</p><p>+	/* Ok, we&#39;re happy to accept this initiation now */</p><p>+	noise_remote_index_insert(l, r);</p><p>+	r-&gt;r_index.i_remote_index = s_idx;</p><p>+	r-&gt;r_handshake_state = HANDSHAKE_RESPONDER;</p><p>+	r-&gt;r_handshake = hs;</p><p>+	*rp = noise_remote_ref(r);</p><p>+	ret = 0;</p><p>+error_set:</p><p>+	rw_wunlock(&amp;r-&gt;r_handshake_lock);</p><p>+error_put:</p><p>+	noise_remote_put(r);</p><p>+error:</p><p>+	rw_runlock(&amp;l-&gt;l_identity_lock);</p><p>+	explicit_bzero(key, NOISE_SYMMETRIC_KEY_LEN);</p><p>+	explicit_bzero(&amp;hs, sizeof(hs));</p><p>+	return (ret);</p><p>+}</p><p>+</p><p>+int</p><p>+noise_create_response(struct noise_remote *r,</p><p>+    uint32_t *s_idx, uint32_t *r_idx,</p><p>+    uint8_t ue[NOISE_PUBLIC_KEY_LEN],</p><p>+    uint8_t en[0 + NOISE_AUTHTAG_LEN])</p><p>+{</p><p>+	struct noise_handshake *hs = &amp;r-&gt;r_handshake;</p><p>+	struct noise_local *l = r-&gt;r_local;</p><p>+	uint8_t key[NOISE_SYMMETRIC_KEY_LEN];</p><p>+	uint8_t e[NOISE_PUBLIC_KEY_LEN];</p><p>+	int ret = EINVAL;</p><p>+</p><p>+	rw_rlock(&amp;l-&gt;l_identity_lock);</p><p>+	rw_wlock(&amp;r-&gt;r_handshake_lock);</p><p>+</p><p>+	if (r-&gt;r_handshake_state != HANDSHAKE_RESPONDER)</p><p>+		goto error;</p><p>+</p><p>+	/* e */</p><p>+	curve25519_generate_secret(e);</p><p>+	if (curve25519_generate_public(ue, e) == 0)</p><p>+		goto error;</p><p>+	noise_msg_ephemeral(hs-&gt;hs_ck, hs-&gt;hs_hash, ue);</p><p>+</p><p>+	/* ee */</p><p>+	if (noise_mix_dh(hs-&gt;hs_ck, NULL, e, hs-&gt;hs_e) != 0)</p><p>+		goto error;</p><p>+</p><p>+	/* se */</p><p>+	if (noise_mix_dh(hs-&gt;hs_ck, NULL, e, r-&gt;r_public) != 0)</p><p>+		goto error;</p><p>+</p><p>+	/* psk */</p><p>+	noise_mix_psk(hs-&gt;hs_ck, hs-&gt;hs_hash, key, r-&gt;r_psk);</p><p>+</p><p>+	/* {} */</p><p>+	noise_msg_encrypt(en, NULL, 0, key, hs-&gt;hs_hash);</p><p>+</p><p>+	if ((ret = noise_begin_session(r)) == 0) {</p><p>+		r-&gt;r_last_sent = getsbinuptime();</p><p>+		*s_idx = r-&gt;r_index.i_local_index;</p><p>+		*r_idx = r-&gt;r_index.i_remote_index;</p><p>+	}</p><p>+error:</p><p>+	rw_wunlock(&amp;r-&gt;r_handshake_lock);</p><p>+	rw_runlock(&amp;l-&gt;l_identity_lock);</p><p>+	explicit_bzero(key, NOISE_SYMMETRIC_KEY_LEN);</p><p>+	explicit_bzero(e, NOISE_PUBLIC_KEY_LEN);</p><p>+	return (ret);</p><p>+}</p><p>+</p><p>+int</p><p>+noise_consume_response(struct noise_local *l, struct noise_remote **rp,</p><p>+    uint32_t s_idx, uint32_t r_idx,</p><p>+    uint8_t ue[NOISE_PUBLIC_KEY_LEN],</p><p>+    uint8_t en[0 + NOISE_AUTHTAG_LEN])</p><p>+{</p><p>+	uint8_t preshared_key[NOISE_SYMMETRIC_KEY_LEN];</p><p>+	uint8_t key[NOISE_SYMMETRIC_KEY_LEN];</p><p>+	struct noise_handshake hs;</p><p>+	struct noise_remote *r = NULL;</p><p>+	int ret = EINVAL;</p><p>+</p><p>+	if ((r = noise_remote_index_lookup(l, r_idx, false)) == NULL)</p><p>+		return (ret);</p><p>+</p><p>+	rw_rlock(&amp;l-&gt;l_identity_lock);</p><p>+	if (!l-&gt;l_has_identity)</p><p>+		goto error;</p><p>+</p><p>+	rw_rlock(&amp;r-&gt;r_handshake_lock);</p><p>+	if (r-&gt;r_handshake_state != HANDSHAKE_INITIATOR) {</p><p>+		rw_runlock(&amp;r-&gt;r_handshake_lock);</p><p>+		goto error;</p><p>+	}</p><p>+	memcpy(preshared_key, r-&gt;r_psk, NOISE_SYMMETRIC_KEY_LEN);</p><p>+	hs = r-&gt;r_handshake;</p><p>+	rw_runlock(&amp;r-&gt;r_handshake_lock);</p><p>+</p><p>+	/* e */</p><p>+	noise_msg_ephemeral(hs.hs_ck, hs.hs_hash, ue);</p><p>+</p><p>+	/* ee */</p><p>+	if (noise_mix_dh(hs.hs_ck, NULL, hs.hs_e, ue) != 0)</p><p>+		goto error_zero;</p><p>+</p><p>+	/* se */</p><p>+	if (noise_mix_dh(hs.hs_ck, NULL, l-&gt;l_private, ue) != 0)</p><p>+		goto error_zero;</p><p>+</p><p>+	/* psk */</p><p>+	noise_mix_psk(hs.hs_ck, hs.hs_hash, key, preshared_key);</p><p>+</p><p>+	/* {} */</p><p>+	if (noise_msg_decrypt(NULL, en,</p><p>+	    0 + NOISE_AUTHTAG_LEN, key, hs.hs_hash) != 0)</p><p>+		goto error_zero;</p><p>+</p><p>+	rw_wlock(&amp;r-&gt;r_handshake_lock);</p><p>+	if (r-&gt;r_handshake_state == HANDSHAKE_INITIATOR &amp;&amp;</p><p>+	    r-&gt;r_index.i_local_index == r_idx) {</p><p>+		r-&gt;r_handshake = hs;</p><p>+		r-&gt;r_index.i_remote_index = s_idx;</p><p>+		if ((ret = noise_begin_session(r)) == 0)</p><p>+			*rp = noise_remote_ref(r);</p><p>+	}</p><p>+	rw_wunlock(&amp;r-&gt;r_handshake_lock);</p><p>+error_zero:</p><p>+	explicit_bzero(preshared_key, NOISE_SYMMETRIC_KEY_LEN);</p><p>+	explicit_bzero(key, NOISE_SYMMETRIC_KEY_LEN);</p><p>+	explicit_bzero(&amp;hs, sizeof(hs));</p><p>+error:</p><p>+	rw_runlock(&amp;l-&gt;l_identity_lock);</p><p>+	noise_remote_put(r);</p><p>+	return (ret);</p><p>+}</p><p>+</p><p>+static void</p><p>+hmac(uint8_t *out, const uint8_t *in, const uint8_t *key, const size_t outlen,</p><p>+     const size_t inlen, const size_t keylen)</p><p>+{</p><p>+	struct blake2s_state state;</p><p>+	uint8_t x_key[BLAKE2S_BLOCK_SIZE] __aligned(sizeof(uint32_t)) = { 0 };</p><p>+	uint8_t i_hash[BLAKE2S_HASH_SIZE] __aligned(sizeof(uint32_t));</p><p>+	int i;</p><p>+</p><p>+	if (keylen &gt; BLAKE2S_BLOCK_SIZE) {</p><p>+		blake2s_init(&amp;state, BLAKE2S_HASH_SIZE);</p><p>+		blake2s_update(&amp;state, key, keylen);</p><p>+		blake2s_final(&amp;state, x_key);</p><p>+	} else</p><p>+		memcpy(x_key, key, keylen);</p><p>+</p><p>+	for (i = 0; i &lt; BLAKE2S_BLOCK_SIZE; ++i)</p><p>+		x_key[i] ^= 0x36;</p><p>+</p><p>+	blake2s_init(&amp;state, BLAKE2S_HASH_SIZE);</p><p>+	blake2s_update(&amp;state, x_key, BLAKE2S_BLOCK_SIZE);</p><p>+	blake2s_update(&amp;state, in, inlen);</p><p>+	blake2s_final(&amp;state, i_hash);</p><p>+</p><p>+	for (i = 0; i &lt; BLAKE2S_BLOCK_SIZE; ++i)</p><p>+		x_key[i] ^= 0x5c ^ 0x36;</p><p>+</p><p>+	blake2s_init(&amp;state, BLAKE2S_HASH_SIZE);</p><p>+	blake2s_update(&amp;state, x_key, BLAKE2S_BLOCK_SIZE);</p><p>+	blake2s_update(&amp;state, i_hash, BLAKE2S_HASH_SIZE);</p><p>+	blake2s_final(&amp;state, i_hash);</p><p>+</p><p>+	memcpy(out, i_hash, outlen);</p><p>+	explicit_bzero(x_key, BLAKE2S_BLOCK_SIZE);</p><p>+	explicit_bzero(i_hash, BLAKE2S_HASH_SIZE);</p><p>+}</p><p>+</p><p>+/* Handshake helper functions */</p><p>+static void</p><p>+noise_kdf(uint8_t *a, uint8_t *b, uint8_t *c, const uint8_t *x,</p><p>+    size_t a_len, size_t b_len, size_t c_len, size_t x_len,</p><p>+    const uint8_t ck[NOISE_HASH_LEN])</p><p>+{</p><p>+	uint8_t out[BLAKE2S_HASH_SIZE + 1];</p><p>+	uint8_t sec[BLAKE2S_HASH_SIZE];</p><p>+</p><p>+	/* Extract entropy from &#34;x&#34; into sec */</p><p>+	hmac(sec, x, ck, BLAKE2S_HASH_SIZE, x_len, NOISE_HASH_LEN);</p><p>+</p><p>+	if (a == NULL || a_len == 0)</p><p>+		goto out;</p><p>+</p><p>+	/* Expand first key: key = sec, data = 0x1 */</p><p>+	out[0] = 1;</p><p>+	hmac(out, out, sec, BLAKE2S_HASH_SIZE, 1, BLAKE2S_HASH_SIZE);</p><p>+	memcpy(a, out, a_len);</p><p>+</p><p>+	if (b == NULL || b_len == 0)</p><p>+		goto out;</p><p>+</p><p>+	/* Expand second key: key = sec, data = &#34;a&#34; || 0x2 */</p><p>+	out[BLAKE2S_HASH_SIZE] = 2;</p><p>+	hmac(out, out, sec, BLAKE2S_HASH_SIZE, BLAKE2S_HASH_SIZE + 1, BLAKE2S_HASH_SIZE);</p><p>+	memcpy(b, out, b_len);</p><p>+</p><p>+	if (c == NULL || c_len == 0)</p><p>+		goto out;</p><p>+</p><p>+	/* Expand third key: key = sec, data = &#34;b&#34; || 0x3 */</p><p>+	out[BLAKE2S_HASH_SIZE] = 3;</p><p>+	hmac(out, out, sec, BLAKE2S_HASH_SIZE, BLAKE2S_HASH_SIZE + 1, BLAKE2S_HASH_SIZE);</p><p>+	memcpy(c, out, c_len);</p><p>+</p><p>+out:</p><p>+	/* Clear sensitive data from stack */</p><p>+	explicit_bzero(sec, BLAKE2S_HASH_SIZE);</p><p>+	explicit_bzero(out, BLAKE2S_HASH_SIZE + 1);</p><p>+}</p><p>+</p><p>+static int</p><p>+noise_mix_dh(uint8_t ck[NOISE_HASH_LEN], uint8_t key[NOISE_SYMMETRIC_KEY_LEN],</p><p>+    const uint8_t private[NOISE_PUBLIC_KEY_LEN],</p><p>+    const uint8_t public[NOISE_PUBLIC_KEY_LEN])</p><p>+{</p><p>+	uint8_t dh[NOISE_PUBLIC_KEY_LEN];</p><p>+</p><p>+	if (!curve25519(dh, private, public))</p><p>+		return (EINVAL);</p><p>+	noise_kdf(ck, key, NULL, dh,</p><p>+	    NOISE_HASH_LEN, NOISE_SYMMETRIC_KEY_LEN, 0, NOISE_PUBLIC_KEY_LEN, ck);</p><p>+	explicit_bzero(dh, NOISE_PUBLIC_KEY_LEN);</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+static int</p><p>+noise_mix_ss(uint8_t ck[NOISE_HASH_LEN], uint8_t key[NOISE_SYMMETRIC_KEY_LEN],</p><p>+    const uint8_t ss[NOISE_PUBLIC_KEY_LEN])</p><p>+{</p><p>+	static uint8_t null_point[NOISE_PUBLIC_KEY_LEN];</p><p>+	if (timingsafe_bcmp(ss, null_point, NOISE_PUBLIC_KEY_LEN) == 0)</p><p>+		return (ENOENT);</p><p>+	noise_kdf(ck, key, NULL, ss,</p><p>+	    NOISE_HASH_LEN, NOISE_SYMMETRIC_KEY_LEN, 0, NOISE_PUBLIC_KEY_LEN, ck);</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+static void</p><p>+noise_mix_hash(uint8_t hash[NOISE_HASH_LEN], const uint8_t *src,</p><p>+    size_t src_len)</p><p>+{</p><p>+	struct blake2s_state blake;</p><p>+</p><p>+	blake2s_init(&amp;blake, NOISE_HASH_LEN);</p><p>+	blake2s_update(&amp;blake, hash, NOISE_HASH_LEN);</p><p>+	blake2s_update(&amp;blake, src, src_len);</p><p>+	blake2s_final(&amp;blake, hash);</p><p>+}</p><p>+</p><p>+static void</p><p>+noise_mix_psk(uint8_t ck[NOISE_HASH_LEN], uint8_t hash[NOISE_HASH_LEN],</p><p>+    uint8_t key[NOISE_SYMMETRIC_KEY_LEN],</p><p>+    const uint8_t psk[NOISE_SYMMETRIC_KEY_LEN])</p><p>+{</p><p>+	uint8_t tmp[NOISE_HASH_LEN];</p><p>+</p><p>+	noise_kdf(ck, tmp, key, psk,</p><p>+	    NOISE_HASH_LEN, NOISE_HASH_LEN, NOISE_SYMMETRIC_KEY_LEN,</p><p>+	    NOISE_SYMMETRIC_KEY_LEN, ck);</p><p>+	noise_mix_hash(hash, tmp, NOISE_HASH_LEN);</p><p>+	explicit_bzero(tmp, NOISE_HASH_LEN);</p><p>+}</p><p>+</p><p>+static void</p><p>+noise_param_init(uint8_t ck[NOISE_HASH_LEN], uint8_t hash[NOISE_HASH_LEN],</p><p>+    const uint8_t s[NOISE_PUBLIC_KEY_LEN])</p><p>+{</p><p>+	struct blake2s_state blake;</p><p>+</p><p>+	blake2s(ck, (uint8_t *)NOISE_HANDSHAKE_NAME, NULL,</p><p>+	    NOISE_HASH_LEN, strlen(NOISE_HANDSHAKE_NAME), 0);</p><p>+	blake2s_init(&amp;blake, NOISE_HASH_LEN);</p><p>+	blake2s_update(&amp;blake, ck, NOISE_HASH_LEN);</p><p>+	blake2s_update(&amp;blake, (uint8_t *)NOISE_IDENTIFIER_NAME,</p><p>+	    strlen(NOISE_IDENTIFIER_NAME));</p><p>+	blake2s_final(&amp;blake, hash);</p><p>+</p><p>+	noise_mix_hash(hash, s, NOISE_PUBLIC_KEY_LEN);</p><p>+}</p><p>+</p><p>+static void</p><p>+noise_msg_encrypt(uint8_t *dst, const uint8_t *src, size_t src_len,</p><p>+    uint8_t key[NOISE_SYMMETRIC_KEY_LEN], uint8_t hash[NOISE_HASH_LEN])</p><p>+{</p><p>+	/* Nonce always zero for Noise_IK */</p><p>+	chacha20poly1305_encrypt(dst, src, src_len,</p><p>+	    hash, NOISE_HASH_LEN, 0, key);</p><p>+	noise_mix_hash(hash, dst, src_len + NOISE_AUTHTAG_LEN);</p><p>+}</p><p>+</p><p>+static int</p><p>+noise_msg_decrypt(uint8_t *dst, const uint8_t *src, size_t src_len,</p><p>+    uint8_t key[NOISE_SYMMETRIC_KEY_LEN], uint8_t hash[NOISE_HASH_LEN])</p><p>+{</p><p>+	/* Nonce always zero for Noise_IK */</p><p>+	if (!chacha20poly1305_decrypt(dst, src, src_len,</p><p>+	    hash, NOISE_HASH_LEN, 0, key))</p><p>+		return (EINVAL);</p><p>+	noise_mix_hash(hash, src, src_len);</p><p>+	return (0);</p><p>+}</p><p>+</p><p>+static void</p><p>+noise_msg_ephemeral(uint8_t ck[NOISE_HASH_LEN], uint8_t hash[NOISE_HASH_LEN],</p><p>+    const uint8_t src[NOISE_PUBLIC_KEY_LEN])</p><p>+{</p><p>+	noise_mix_hash(hash, src, NOISE_PUBLIC_KEY_LEN);</p><p>+	noise_kdf(ck, NULL, NULL, src, NOISE_HASH_LEN, 0, 0,</p><p>+		  NOISE_PUBLIC_KEY_LEN, ck);</p><p>+}</p><p>+</p><p>+static void</p><p>+noise_tai64n_now(uint8_t output[NOISE_TIMESTAMP_LEN])</p><p>+{</p><p>+	struct timespec time;</p><p>+	uint64_t sec;</p><p>+	uint32_t nsec;</p><p>+</p><p>+	getnanotime(&amp;time);</p><p>+</p><p>+	/* Round down the nsec counter to limit precise timing leak. */</p><p>+	time.tv_nsec &amp;= REJECT_INTERVAL_MASK;</p><p>+</p><p>+	/* https://cr.yp.to/libtai/tai64.html */</p><p>+	sec = htobe64(0x400000000000000aULL + time.tv_sec);</p><p>+	nsec = htobe32(time.tv_nsec);</p><p>+</p><p>+	/* memcpy to output buffer, assuming output could be unaligned. */</p><p>+	memcpy(output, &amp;sec, sizeof(sec));</p><p>+	memcpy(output + sizeof(sec), &amp;nsec, sizeof(nsec));</p><p>+}</p><p>+</p><p>+static inline int</p><p>+noise_timer_expired(sbintime_t timer, uint32_t sec, uint32_t nsec)</p><p>+{</p><p>+	sbintime_t now = getsbinuptime();</p><p>+	return (now &gt; (timer + sec * SBT_1S + nstosbt(nsec))) ? ETIMEDOUT : 0;</p><p>+}</p><p>+</p><p>+static uint64_t siphash24(const uint8_t key[SIPHASH_KEY_LENGTH], const void *src, size_t len)</p><p>+{</p><p>+	SIPHASH_CTX ctx;</p><p>+	return (SipHashX(&amp;ctx, 2, 4, key, src, len));</p><p>+}</p><p>+</p><p>+#ifdef SELFTESTS</p><p>+#include &#34;selftest/counter.c&#34;</p><p>+#endif /* SELFTESTS */</p><div><p>diff --git a/sys/dev/wg/wg_noise.h b/sys/dev/wg/wg_noise.h</p></div><p>@@ -0,0 +1,131 @@</p><p>+/* SPDX-License-Identifier: ISC</p><p>+ *</p><p>+ * Copyright (C) 2015-2021 Jason A. Donenfeld &lt;Jason@zx2c4.com&gt;. All Rights Reserved.</p><p>+ * Copyright (C) 2019-2021 Matt Dunwoodie &lt;ncon@noconroy.net&gt;</p><p>+ */</p><p>+</p><p>+#ifndef __NOISE_H__</p><p>+#define __NOISE_H__</p><p>+</p><p>+#include &#34;crypto.h&#34;</p><p>+</p><p>+#define NOISE_PUBLIC_KEY_LEN	CURVE25519_KEY_SIZE</p><p>+#define NOISE_SYMMETRIC_KEY_LEN	CHACHA20POLY1305_KEY_SIZE</p><p>+#define NOISE_TIMESTAMP_LEN	(sizeof(uint64_t) + sizeof(uint32_t))</p><p>+#define NOISE_AUTHTAG_LEN	CHACHA20POLY1305_AUTHTAG_SIZE</p><p>+#define NOISE_HASH_LEN		BLAKE2S_HASH_SIZE</p><p>+</p><p>+#define REJECT_AFTER_TIME	180</p><p>+#define REKEY_TIMEOUT		5</p><p>+#define KEEPALIVE_TIMEOUT	10</p><p>+</p><p>+struct noise_local;</p><p>+struct noise_remote;</p><p>+struct noise_keypair;</p><p>+</p><p>+/* Local configuration */</p><p>+struct noise_local *</p><p>+	noise_local_alloc(void *);</p><p>+struct noise_local *</p><p>+	noise_local_ref(struct noise_local *);</p><p>+void	noise_local_put(struct noise_local *);</p><p>+void	noise_local_free(struct noise_local *, void (*)(struct noise_local *));</p><p>+void *	noise_local_arg(struct noise_local *);</p><p>+</p><p>+void	noise_local_private(struct noise_local *,</p><p>+	    const uint8_t[NOISE_PUBLIC_KEY_LEN]);</p><p>+int	noise_local_keys(struct noise_local *,</p><p>+	    uint8_t[NOISE_PUBLIC_KEY_LEN],</p><p>+	    uint8_t[NOISE_PUBLIC_KEY_LEN]);</p><p>+</p><p>+/* Remote configuration */</p><p>+struct noise_remote *</p><p>+	noise_remote_alloc(struct noise_local *, void *,</p><p>+	    const uint8_t[NOISE_PUBLIC_KEY_LEN]);</p><p>+int	noise_remote_enable(struct noise_remote *);</p><p>+void	noise_remote_disable(struct noise_remote *);</p><p>+struct noise_remote *</p><p>+	noise_remote_lookup(struct noise_local *, const uint8_t[NOISE_PUBLIC_KEY_LEN]);</p><p>+struct noise_remote *</p><p>+	noise_remote_index(struct noise_local *, uint32_t);</p><p>+struct noise_remote *</p><p>+	noise_remote_ref(struct noise_remote *);</p><p>+void	noise_remote_put(struct noise_remote *);</p><p>+void	noise_remote_free(struct noise_remote *, void (*)(struct noise_remote *));</p><p>+struct noise_local *</p><p>+	noise_remote_local(struct noise_remote *);</p><p>+void *	noise_remote_arg(struct noise_remote *);</p><p>+</p><p>+void	noise_remote_set_psk(struct noise_remote *,</p><p>+	    const uint8_t[NOISE_SYMMETRIC_KEY_LEN]);</p><p>+int	noise_remote_keys(struct noise_remote *,</p><p>+	    uint8_t[NOISE_PUBLIC_KEY_LEN],</p><p>+	    uint8_t[NOISE_SYMMETRIC_KEY_LEN]);</p><p>+int	noise_remote_initiation_expired(struct noise_remote *);</p><p>+void	noise_remote_handshake_clear(struct noise_remote *);</p><p>+void	noise_remote_keypairs_clear(struct noise_remote *);</p><p>+</p><p>+/* Keypair functions */</p><p>+struct noise_keypair *</p><p>+	noise_keypair_lookup(struct noise_local *, uint32_t);</p><p>+struct noise_keypair *</p><p>+	noise_keypair_current(struct noise_remote *);</p><p>+struct noise_keypair *</p><p>+	noise_keypair_ref(struct noise_keypair *);</p><p>+int	noise_keypair_received_with(struct noise_keypair *);</p><p>+void	noise_keypair_put(struct noise_keypair *);</p><p>+</p><p>+struct noise_remote *</p><p>+	noise_keypair_remote(struct noise_keypair *);</p><p>+</p><p>+int	noise_keypair_nonce_next(struct noise_keypair *, uint64_t *);</p><p>+int	noise_keypair_nonce_check(struct noise_keypair *, uint64_t);</p><p>+</p><p>+int	noise_keep_key_fresh_send(struct noise_remote *);</p><p>+int	noise_keep_key_fresh_recv(struct noise_remote *);</p><p>+int	noise_keypair_encrypt(</p><p>+	    struct noise_keypair *,</p><p>+	    uint32_t *r_idx,</p><p>+	    uint64_t nonce,</p><p>+	    struct mbuf *);</p><p>+int	noise_keypair_decrypt(</p><p>+	    struct noise_keypair *,</p><p>+	    uint64_t nonce,</p><p>+	    struct mbuf *);</p><p>+</p><p>+/* Handshake functions */</p><p>+int	noise_create_initiation(</p><p>+	    struct noise_remote *,</p><p>+	    uint32_t *s_idx,</p><p>+	    uint8_t ue[NOISE_PUBLIC_KEY_LEN],</p><p>+	    uint8_t es[NOISE_PUBLIC_KEY_LEN + NOISE_AUTHTAG_LEN],</p><p>+	    uint8_t ets[NOISE_TIMESTAMP_LEN + NOISE_AUTHTAG_LEN]);</p><p>+</p><p>+int	noise_consume_initiation(</p><p>+	    struct noise_local *,</p><p>+	    struct noise_remote **,</p><p>+	    uint32_t s_idx,</p><p>+	    uint8_t ue[NOISE_PUBLIC_KEY_LEN],</p><p>+	    uint8_t es[NOISE_PUBLIC_KEY_LEN + NOISE_AUTHTAG_LEN],</p><p>+	    uint8_t ets[NOISE_TIMESTAMP_LEN + NOISE_AUTHTAG_LEN]);</p><p>+</p><p>+int	noise_create_response(</p><p>+	    struct noise_remote *,</p><p>+	    uint32_t *s_idx,</p><p>+	    uint32_t *r_idx,</p><p>+	    uint8_t ue[NOISE_PUBLIC_KEY_LEN],</p><p>+	    uint8_t en[0 + NOISE_AUTHTAG_LEN]);</p><p>+</p><p>+int	noise_consume_response(</p><p>+	    struct noise_local *,</p><p>+	    struct noise_remote **,</p><p>+	    uint32_t s_idx,</p><p>+	    uint32_t r_idx,</p><p>+	    uint8_t ue[NOISE_PUBLIC_KEY_LEN],</p><p>+	    uint8_t en[0 + NOISE_AUTHTAG_LEN]);</p><p>+</p><p>+#ifdef SELFTESTS</p><p>+bool	noise_counter_selftest(void);</p><p>+#endif /* SELFTESTS */</p><p>+</p><p>+#endif /* __NOISE_H__ */</p><div><p>diff --git a/sys/kern/kern_jail.c b/sys/kern/kern_jail.c</p></div><p>@@ -3758,6 +3758,7 @@ prison_priv_check(struct ucred *cred, int priv)</p><p> 	case PRIV_NET_SETIFFIB:</p><p> 	case PRIV_NET_OVPN:</p><p> 	case PRIV_NET_ME:</p><p>+	case PRIV_NET_WG:</p><p> 		/*</p><p> 		 * 802.11-related privileges.</p><div><p>diff --git a/sys/modules/Makefile b/sys/modules/Makefile</p></div><p>@@ -164,6 +164,7 @@ SUBDIR=	\</p><p> 	if_tuntap \</p><p> 	if_vlan \</p><p> 	if_vxlan \</p><p>+	${_if_wg} \</p><p> 	iflib \</p><p> 	${_igc} \</p><p> 	imgact_binmisc \</p><p>@@ -449,6 +450,9 @@ _toecore=	toecore</p><p> _if_enc=	if_enc</p><p> _if_gif=	if_gif</p><p> _if_gre=	if_gre</p><p>+.if ${MK_CRYPT} != &#34;no&#34; || defined(ALL_MODULES)</p><p>+_if_wg=		if_wg</p><p>+.endif</p><p> _ipfw_pmod=	ipfw_pmod</p><p> .if ${KERN_OPTS:MIPSEC_SUPPORT} &amp;&amp; !${KERN_OPTS:MIPSEC}</p><p> _ipsec=		ipsec</p><div><p>diff --git a/sys/modules/if_wg/Makefile b/sys/modules/if_wg/Makefile</p></div><p>@@ -0,0 +1,10 @@</p><p>+.PATH: ${SRCTOP}/sys/dev/wg</p><p>+</p><p>+KMOD= if_wg</p><p>+</p><p>+SRCS= if_wg.c wg_cookie.c wg_crypto.c wg_noise.c</p><p>+SRCS+= opt_inet.h opt_inet6.h device_if.h bus_if.h</p><p>+</p><p>+.include &lt;bsd.kmod.mk&gt;</p><p>+</p><p>+CFLAGS+= -include ${SRCTOP}/sys/dev/wg/compat.h</p><div><p>diff --git a/sys/net/if_types.h b/sys/net/if_types.h</p></div><p>@@ -256,6 +256,7 @@ typedef enum {</p><p> 	IFT_ENC		= 0xf4,		/* Encapsulating interface */</p><p> 	IFT_PFLOG	= 0xf6,		/* PF packet filter logging */</p><p> 	IFT_PFSYNC	= 0xf7,		/* PF packet filter synchronization */</p><p>+	IFT_WIREGUARD	= 0xf8,		/* WireGuard tunnel */</p><p> } ifType;</p><p> /*</p><div><p>diff --git a/sys/netinet6/nd6.c b/sys/netinet6/nd6.c</p></div><p>@@ -284,8 +284,8 @@ nd6_ifattach(struct ifnet *ifp)</p><p> 	 * default regardless of the V_ip6_auto_linklocal configuration to</p><p> 	 * give a reasonable default behavior.</p><p> 	 */</p><p>-	if ((V_ip6_auto_linklocal &amp;&amp; ifp-&gt;if_type != IFT_BRIDGE) ||</p><p>-	    (ifp-&gt;if_flags &amp; IFF_LOOPBACK))</p><p>+	if ((V_ip6_auto_linklocal &amp;&amp; ifp-&gt;if_type != IFT_BRIDGE &amp;&amp;</p><p>+	    ifp-&gt;if_type != IFT_WIREGUARD) || (ifp-&gt;if_flags &amp; IFF_LOOPBACK))</p><p> 		nd-&gt;flags |= ND6_IFF_AUTO_LINKLOCAL;</p><p> 	/*</p><p> 	 * A loopback interface does not need to accept RTADV.</p><div><p>diff --git a/sys/sys/priv.h b/sys/sys/priv.h</p></div><p>@@ -350,6 +350,7 @@</p><p> #define	PRIV_NET_SETVLANPCP	PRIV_NET_SETLANPCP /* Alias Set VLAN priority */</p><p> #define	PRIV_NET_OVPN		422	/* Administer OpenVPN DCO. */</p><p> #define	PRIV_NET_ME		423	/* Administer ME interface. */</p><p>+#define	PRIV_NET_WG		424	/* Administer WireGuard interface. */</p><p> /*</p><p>  * 802.11-related privileges.</p></td></tr></tbody></div></div>
  </body>
</html>
