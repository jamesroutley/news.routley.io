<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.macarthur.me/posts/maps-for-dom-nodes">Original</a>
    <h1>Why I Like Using Maps (and WeakMaps) for Handling DOM Nodes</h1>
    
    <div id="readability-page-1" class="page"><p><h2>Breaking down some of the reasons Maps (and WeakMaps) are especially useful tools when working with a large number of DOM nodes.</h2></p><div><p>We use a lot of plain, old objects to store key/value data in JavaScript, and they&#39;re great at their job – clear and legible:</p><pre><code><span>const</span> person <span>=</span> <span>{</span>
	<span>firstName</span><span>:</span> <span>&#39;Alex&#39;</span><span>,</span> 
	<span>lastName</span><span>:</span> <span>&#39;MacArthur&#39;</span><span>,</span> 
	<span>isACommunist</span><span>:</span> <span>false</span>
<span>}</span><span>;</span></code></pre><p>But when you start dealing with larger entities whose properties are frequently being read, changed, and added, it&#39;s becoming more common to see people reach for Maps instead. And for good reason: in certain situations, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map?ref=alex-macarthur#objects_vs._maps" target="_blank" rel="noopener">t</a><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map?ref=alex-macarthur#objects_vs._maps" target="_blank" rel="noopener">here are multiple advantages a Map has over an object</a>, particularly those in which there are sensitive performance concerns or where the order of insertion really matters.</p><p>But as of late, I&#39;ve realized what I <em>especially</em> like to use them for: <strong>handling large sets of DOM nodes.</strong></p><p>This thought came up while reading <a href="https://calebporzio.com/reactive-switchboard?ref=alex-macarthur" target="_blank" rel="noopener">a recent blog post</a> from Caleb Porzio. In it, he&#39;s working with a contrived example of a table composed of 10,000 table rows, one of which can be &#34;active.&#34; To manage state as different rows are selected, an object is used as a key/value store. Here&#39;s an annotated version of one of his iterations. I also added semicolons because <a href="https://macarthur.me/jk?ref=alex-macarthur" target="_blank" rel="noopener">I&#39;m not a barbarian</a>.</p><pre><code><span>import</span> <span><span>{</span> ref<span>,</span> watchEffect <span>}</span></span> <span>from</span> <span>&#39;vue&#39;</span><span>;</span>

<span>let</span> rowStates <span>=</span> <span>{</span><span>}</span><span>;</span>
<span>let</span> activeRow<span>;</span>

<span>document</span><span>.</span><span>querySelectorAll</span><span>(</span><span>&#39;tr&#39;</span><span>)</span><span>.</span><span>forEach</span><span>(</span><span>(</span><span>row</span><span>)</span> <span>=&gt;</span> <span>{</span>
    
    rowStates<span>[</span>row<span>.</span><span>id</span><span>]</span> <span>=</span> <span>ref</span><span>(</span><span>false</span><span>)</span><span>;</span>

    row<span>.</span><span>addEventListener</span><span>(</span><span>&#39;click&#39;</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
        
        <span>if</span> <span>(</span>activeRow<span>)</span> rowStates<span>[</span>activeRow<span>]</span><span>.</span><span>value</span> <span>=</span> <span>false</span><span>;</span>

        activeRow <span>=</span> row<span>.</span><span>id</span><span>;</span>

        rowStates<span>[</span>row<span>.</span><span>id</span><span>]</span><span>.</span><span>value</span> <span>=</span> <span>true</span><span>;</span>
    <span>}</span><span>)</span><span>;</span>

    <span>watchEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
        
        <span>if</span> <span>(</span>rowStates<span>[</span>row<span>.</span><span>id</span><span>]</span><span>.</span><span>value</span><span>)</span> <span>{</span>
            row<span>.</span><span>classList</span><span>.</span><span>add</span><span>(</span><span>&#39;active&#39;</span><span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            row<span>.</span><span>classList</span><span>.</span><span>remove</span><span>(</span><span>&#39;active&#39;</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span></code></pre><p>That does the job just fine (and it had <em>nothing</em> to do with the post&#39;s point, so zero shade is being thrown here). But! It uses an object as a large hash-map-like table, so the keys used to associate values <em>must</em> be a string, thereby requiring a unique ID (or other string value) exist on each item. That carries with it a bit of added programmatic overhead to both generate and read those values when they&#39;re needed.</p><h2 id="any-object-can-be-a-key"><a href="#any-object-can-be-a-key" target="_blank" rel="noopener">Any object can be a key.</a></h2><p>Instead, a Map would allow us to <strong>use the HTML nodes as keys themselves</strong>. So, that snippet ends up looking like this:</p><pre><code>import { ref, watchEffect } from &#39;vue&#39;;

<span><span>-</span><span> let rowStates = {};
</span></span><span><span>+</span><span> let rowStates = new Map();
</span></span>let activeRow;

document.querySelectorAll(&#39;tr&#39;).forEach((row) =&gt; {
<span><span>-</span><span>	rowStates[row.id] = ref(false);
</span></span><span><span>+</span><span>   rowStates.set(row, ref(false));
</span></span>
<span><span> </span><span>   row.addEventListener(&#39;click&#39;, () =&gt; {
</span></span><span><span>-</span><span>       if (activeRow) rowStates[activeRow].value = false;
</span></span><span><span>+</span><span>       if (activeRow) rowStates.get(activeRow).value = false;
</span></span>
<span><span> </span><span>       activeRow = row;
</span></span>
<span><span>-</span><span>       rowStates[row.id].value = true;
</span></span><span><span>+</span><span>       rowStates.get(activeRow).value = true;
</span></span><span><span> </span><span>   });
</span></span>
<span><span> </span><span>   watchEffect(() =&gt; {
</span></span><span><span>-</span><span>       if (rowStates[row.id].value) {
</span></span><span><span>+</span><span>       if (rowStates.get(row).value) {
</span></span><span><span> </span><span>           row.classList.add(&#39;active&#39;);
</span><span> </span><span>       } else {
</span><span> </span><span>           row.classList.remove(&#39;active&#39;);
</span><span> </span><span>       }
</span><span> </span><span>   });
</span></span>});
</code></pre><p>The most obvious benefit here is that <strong>I don&#39;t need to worry about unique IDs existing on each row. </strong>The node references themselves – inherently unique – serve as the keys. Because of this, neither setting nor reading any attribute is necessary. It&#39;s simpler and more resilient.</p><h2 id="readwrite-operations-are-generally-more-performant"><a href="#readwrite-operations-are-generally-more-performant" target="_blank" rel="noopener">Read/write operations are <em>generally </em>more performant.</a></h2><p>I&#39;ve italicized &#34;generally&#34; because, in most cases, the difference is negligible. But when you&#39;re working with larger data sets, the operations are notably more performant. It&#39;s even in the specification – Maps must be built in a way that preserves performance as the number of items continues to grow:</p><blockquote>Maps must be implemented using either hash tables or other mechanisms that, on average, provide access times that are sublinear on the number of elements in the collection.</blockquote><p>&#34;Sublinear&#34; just means that performance won&#39;t degrade at a proportionate rate to the size of the Map. So, even big Maps should remain fairly snappy.</p><p>But even on top of that, again, there&#39;s no need to mess with DOM attributes or performing a look-up by a string-like ID. Each key is <em>itself</em> a reference, which means we can skip a step or two.</p><p>I did some rudimentary performance testing to confirm all of this. First, sticking with Caleb&#39;s scenario, I generated 10,000 <code>&lt;tr&gt;</code> elements on a page:</p><pre><code><span>const</span> table <span>=</span> <span>document</span><span>.</span><span>createElement</span><span>(</span><span>&#39;table&#39;</span><span>)</span><span>;</span>
<span>document</span><span>.</span><span>body</span><span>.</span><span>append</span><span>(</span>table<span>)</span><span>;</span>

<span>const</span> count <span>=</span> <span>10_000</span><span>;</span>
<span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> count<span>;</span> i<span>++</span><span>)</span> <span>{</span>
  <span>const</span> item <span>=</span> <span>document</span><span>.</span><span>createElement</span><span>(</span><span>&#39;tr&#39;</span><span>)</span><span>;</span>
  item<span>.</span><span>id</span> <span>=</span> i<span>;</span>
  item<span>.</span><span>textContent</span> <span>=</span> <span>&#39;item&#39;</span><span>;</span>
  table<span>.</span><span>append</span><span>(</span>item<span>)</span><span>;</span>
<span>}</span></code></pre><p>Next, I set up a template for measuring how long it would take to loop over <em>all</em> of those rows and store some associated state in either an object or Map. I&#39;m also running that same process inside a <code>for</code> loop a bunch of times, and then determining the average amount of time it took to write &amp; read.</p><pre><code><span>const</span> rows <span>=</span> <span>document</span><span>.</span><span>querySelectorAll</span><span>(</span><span>&#39;tr&#39;</span><span>)</span><span>;</span>
<span>const</span> times <span>=</span> <span>[</span><span>]</span><span>;</span>
<span>const</span> testMap <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>)</span><span>;</span>
<span>const</span> testObj <span>=</span> <span>{</span><span>}</span><span>;</span>

<span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>1000</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
  <span>const</span> start <span>=</span> <span>performance</span><span>.</span><span>now</span><span>(</span><span>)</span><span>;</span>

  rows<span>.</span><span>forEach</span><span>(</span><span>(</span><span>row<span>,</span> index</span><span>)</span> <span>=&gt;</span> <span>{</span>
    
	
	

	
	
	
  <span>}</span><span>)</span><span>;</span>

  times<span>.</span><span>push</span><span>(</span><span>performance</span><span>.</span><span>now</span><span>(</span><span>)</span> <span>-</span> start<span>)</span><span>;</span>
<span>}</span>

<span>const</span> average <span>=</span> times<span>.</span><span>reduce</span><span>(</span><span>(</span><span>acc<span>,</span> i</span><span>)</span> <span>=&gt;</span> acc <span>+</span> i<span>,</span> <span>0</span><span>)</span> <span>/</span> times<span>.</span><span>length</span><span>;</span>

<span>console</span><span>.</span><span>log</span><span>(</span>average<span>)</span><span>;</span></code></pre><p>I ran this test with a range different row sizes.</p><table><thead><tr><th></th><th>100 Items</th><th>10,000 Items</th><th>100,000 Items</th></tr></thead><tbody><tr><td>Object</td><td>0.023ms</td><td>3.45ms</td><td>89.9ms</td></tr><tr><td>Map</td><td>0.019ms</td><td>2.1ms</td><td>48.7ms</td></tr><tr><td>% Faster</td><td>17%</td><td>39%</td><td>46%</td></tr></tbody></table><p>Keep in mind these results would likely vary quite a bit in even slightly different circumstances, but on the whole, they generally met my expectations. When dealing with relatively small numbers of items, performance between a Map and object was comparable. But as the number of items increased, the Map started to pull away. That sublinear change in performance started to shine.</p><h2 id="weakmaps-steward-memory-more-effectively"><a href="#weakmaps-steward-memory-more-effectively" target="_blank" rel="noopener">WeakMaps steward memory more effectively.</a></h2><p>There&#39;s a special version of the <code>Map</code> interface that&#39;s designed to steward memory a bit better – a <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap?ref=alex-macarthur" target="_blank" rel="noopener">WeakMap</a></code>. It does so by holding a &#34;weak&#34; reference to its keys, so if any of those object-keys no longer have a reference bound to it elsewhere, it&#39;s eligible for garbage collection. So, when the key is no longer needed, the entire entry is automatically axed from the <code>WeakMap</code>, clearing up even more memory. It works for DOM nodes too.</p><p>To tinker with this, we&#39;ll be using the <code>FinalizationRegistry</code>, which <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry?ref=alex-macarthur" target="_blank" rel="noopener">triggers a callback</a> whenever a reference you&#39;re watching has been garbage collected (I never expected to find something like this handy, lol). We&#39;ll start with a few list items:</p><pre><code><span><span><span>&lt;</span>ul</span><span>&gt;</span></span>
  <span><span><span>&lt;</span>li</span> <span>id</span><span><span>=</span><span>&#34;</span>item1<span>&#34;</span></span><span>&gt;</span></span>first<span><span><span>&lt;/</span>li</span><span>&gt;</span></span>
  <span><span><span>&lt;</span>li</span> <span>id</span><span><span>=</span><span>&#34;</span>item2<span>&#34;</span></span><span>&gt;</span></span>second<span><span><span>&lt;/</span>li</span><span>&gt;</span></span>
  <span><span><span>&lt;</span>li</span> <span>id</span><span><span>=</span><span>&#34;</span>item3<span>&#34;</span></span><span>&gt;</span></span>third<span><span><span>&lt;/</span>li</span><span>&gt;</span></span>
<span><span><span>&lt;/</span>ul</span><span>&gt;</span></span></code></pre><p>Next, we&#39;ll stick those items in a WeakMap, and register <code>item2</code> to be watched by the registry. We&#39;ll remove it, and whenever it&#39;s been garbage collected, the callback will be triggered and we&#39;ll be able to see how the WeakMap has changed.</p><p>But... garbage collection is unpredictable and there&#39;s no official way to <em>make</em> it happen, so to <em>encourage</em> it, we&#39;ll periodically generate a bunch of objects and persist them in memory. Here&#39;s the entire script:</p><pre><code><span>(</span><span>async</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
	<span>const</span> listMap <span>=</span> <span>new</span> <span>WeakMap</span><span>(</span><span>)</span><span>;</span>

	
	<span>document</span><span>.</span><span>querySelectorAll</span><span>(</span><span>&#39;li&#39;</span><span>)</span><span>.</span><span>forEach</span><span>(</span><span>(</span><span>node</span><span>)</span> <span>=&gt;</span> <span>{</span>
		listMap<span>.</span><span>set</span><span>(</span>node<span>,</span> node<span>.</span><span>id</span><span>)</span><span>;</span>
	<span>}</span><span>)</span><span>;</span>

	<span>const</span> registry <span>=</span> <span>new</span> <span>FinalizationRegistry</span><span>(</span><span>(</span><span>heldValue</span><span>)</span> <span>=&gt;</span> <span>{</span>
		
		<span>console</span><span>.</span><span>log</span><span>(</span><span>&#39;After collection:&#39;</span><span>,</span> heldValue<span>)</span><span>;</span>
	<span>}</span><span>)</span><span>;</span>

	registry<span>.</span><span>register</span><span>(</span><span>document</span><span>.</span><span>getElementById</span><span>(</span><span>&#39;item2&#39;</span><span>)</span><span>,</span> listMap<span>)</span><span>;</span>
    
	<span>console</span><span>.</span><span>log</span><span>(</span><span>&#39;Before collection:&#39;</span><span>,</span> listMap<span>)</span><span>;</span>

	
	<span>document</span><span>.</span><span>getElementById</span><span>(</span><span>&#39;item2&#39;</span><span>)</span><span>.</span><span>remove</span><span>(</span><span>)</span><span>;</span>

 	
 	<span>const</span> objs <span>=</span> <span>[</span><span>]</span><span>;</span>
 	<span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
   		<span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>100</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
			objs<span>.</span><span>push</span><span>(</span><span>...</span><span>new</span> <span>Array</span><span>(</span><span>100</span><span>)</span><span>)</span><span>;</span>
		<span>}</span>

		<span>await</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve</span><span>)</span> <span>=&gt;</span> <span>setTimeout</span><span>(</span>resolve<span>,</span> <span>10</span><span>)</span><span>)</span><span>;</span>
	<span>}</span>
<span>}</span><span>)</span><span>(</span><span>)</span><span>;</span>
</code></pre><p>Before anything happens, the WeakMap holds three items, as expected. But after the second item is removed from the DOM and garbage collection occurs, it looks a little different:</p><figure><img alt="" height="287" loading="lazy" src="https://www.macarthur.me/proxy-image/content/images/2023/04/maps.jpeg" width="2000" sizes="(min-width: 720px) 720px" srcset="/proxy-image/content/images/size/w600/2023/04/maps.jpeg 600w, /proxy-image/content/images/size/w1000/2023/04/maps.jpeg 1000w, /proxy-image/content/images/size/w1600/2023/04/maps.jpeg 1600w, /proxy-image/content/images/2023/04/maps.jpeg 2087w"/></figure><p>Since the node reference no longer exists in the DOM, the entire entry was removed from the <code>WeakMap</code>, freeing up a smidge more memory. It&#39;s a feature I appreciate in helping to keep an environment&#39;s memory just a bit tidier.</p><h2 id="tldr"><a href="#tldr" target="_blank" rel="noopener">TL;DR</a></h2><p>I like using Maps for DOM nodes because:</p><ul><li>The nodes themselves can be used as keys. I don&#39;t need to mess with setting or reading unique attributes on each node first.</li><li>With large numbers of objects, they&#39;re (designed to be) more performant.</li><li>Using a <code>WeakMap</code> with nodes as keys means entries will be automatically garbage collected if a node is removed from the DOM.</li></ul><h2 id="other-use-cases"><a href="#other-use-cases" target="_blank" rel="noopener">Other Use Cases?</a></h2><p>I&#39;m interested in hearing of other interesting reasons to use &#34;newish&#34; objects like <code>Map</code> and <code>Set</code> in real-life scenarios. If you have &#39;em, share &#39;em!</p></div></div>
  </body>
</html>
