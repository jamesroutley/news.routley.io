<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://proclamations.nebcorp-hias.com/rnd/one-part-serialized-mystery/">Original</a>
    <h1>A One-Part Serialized Mystery</h1>
    
    <div id="readability-page-1" class="page"><div>
    <article>
        <div>
            
            
    <p>
        A One-Part Serialized Mystery<span>.</span>
    </p>


                <p>
                    
                        Posted on <time>2023-06-29</time>
                    

                    
                </p>
        </div>

        

        
        
            
                
                <ul>
                
                    <li>
                        <a href="https://proclamations.nebcorp-hias.com/rnd/one-part-serialized-mystery/#mise-en-scene">Mise en Scene</a>
                        
                    </li>
                
                    <li>
                        <a href="https://proclamations.nebcorp-hias.com/rnd/one-part-serialized-mystery/#keys-primarily">Keys, primarily</a>
                        
                            <ul>
                                
                                    <li>
                                        <a href="https://proclamations.nebcorp-hias.com/rnd/one-part-serialized-mystery/#uuids">UUIDs</a>
                                    </li>

                                    
                                
                                    <li>
                                        <a href="https://proclamations.nebcorp-hias.com/rnd/one-part-serialized-mystery/#indexes">Indexes?</a>
                                    </li>

                                    
                                
                            </ul>
                        
                    </li>
                
                    <li>
                        <a href="https://proclamations.nebcorp-hias.com/rnd/one-part-serialized-mystery/#serial-problems">Serial problems</a>
                        
                            <ul>
                                
                                    <li>
                                        <a href="https://proclamations.nebcorp-hias.com/rnd/one-part-serialized-mystery/#great-coders-steal">Great coders steal</a>
                                    </li>

                                    
                                
                                    <li>
                                        <a href="https://proclamations.nebcorp-hias.com/rnd/one-part-serialized-mystery/#a-puzzling-failure">A puzzling failure</a>
                                    </li>

                                    
                                
                            </ul>
                        
                    </li>
                
                    <li>
                        <a href="https://proclamations.nebcorp-hias.com/rnd/one-part-serialized-mystery/#when-in-doubt-change-many-things-at-once">When in doubt, change many things at once</a>
                        
                            <ul>
                                
                                    <li>
                                        <a href="https://proclamations.nebcorp-hias.com/rnd/one-part-serialized-mystery/#more-like-shmexicographic-amirite">More like shmexicographic, amirite</a>
                                    </li>

                                    
                                
                                    <li>
                                        <a href="https://proclamations.nebcorp-hias.com/rnd/one-part-serialized-mystery/#the-actual-problem">The actual problem</a>
                                    </li>

                                    
                                
                                    <li>
                                        <a href="https://proclamations.nebcorp-hias.com/rnd/one-part-serialized-mystery/#wait-why-isn-t-it-broken">Wait, why isn&#39;t it broken?</a>
                                    </li>

                                    
                                
                            </ul>
                        
                    </li>
                
                    <li>
                        <a href="https://proclamations.nebcorp-hias.com/rnd/one-part-serialized-mystery/#lessons-learned">Lessons learned</a>
                        
                    </li>
                
                </ul>
            
        

        <section>
            
<p>I recently spent a couple days moving from <a href="https://commons.apache.org/sandbox/commons-id/uuid.html">one type of universally unique
identifier</a> to a <a href="https://github.com/ulid/spec">different
one</a>, for an in-progress <a href="https://gitlab.com/nebkor/ww">database-backed
web-app</a>. The <a href="https://gitlab.com/nebkor/ww/-/commit/be96100237da56313a583be6da3dc27a4371e29d#f69082f7433f159d627269b207abdaf2ad52b24c">initial
work</a>
didn&#39;t take very long, but debugging the <a href="https://en.wikipedia.org/wiki/Serialization">serialization and
deserialization</a> of the new IDs took another day and a
half, and in the end, the alleged mystery of why it wasn&#39;t working was a red herring due to my own
stupidity. So come with me on an exciting voyage of discovery, and <a href="https://proclamations.nebcorp-hias.com/sundries/a-thoroughly-digital-artifact/">once again, learn from my
folly</a>!</p>

<p>Most large distributed programs that people interact with daily via HTTP are, in essence, a fancy
facade for some kind of database. Facebook? That&#39;s a database. Gmail? That&#39;s a database.</p>
<p><img src="https://proclamations.nebcorp-hias.com/rnd/one-part-serialized-mystery/./thats_a_database.png" alt="that&#39;s a database" title="simpsons that&#39;s-a-paddling guy"/></p>
<p>wikipedia? that&#39;s a database.</p>
<p>In most databases, each entry (&#34;row&#34;) has a field that acts as a <a href="https://en.wikipedia.org/wiki/Primary_key">primary
key</a>, used to uniquely identify that row inside the table
it&#39;s in. Since databases typically contain multiple tables, and primary keys have to be unique only
within their own table, you could just use a simple integer that&#39;s automatically incremented every
time you add a new record, and in many databases, if you create a table without specifying a primary
key, they will <a href="https://www.sqlite.org/lang_createtable.html#rowid">automatically and implicitly use a
mechanism</a> like that. You may also recognize the
idea of &#34;serial numbers&#34;, which is what these sorts of IDs are.</p>
<p>This is often totally fine! If you only ever have one copy of the database, and never have to worry
about inserting rows from a different instance of the database, then you can just use those simple
values and move on your merry way.</p>
<p>However, if you ever think you might want to have multiple instances of your database running, and
want to make sure they&#39;re eventually consistent with each other, then you might want to use a
fancier identifier for your primary keys, to avoid collisions between them.</p>
<h2 id="uuids">UUIDs</h2>
<p>A popular type for fancy keys is called a
<a href="https://datatracker.ietf.org/doc/html/rfc4122#page-14">v4 UUIDs</a>. These are 128-bit random
numbers<sup><a href="#uuidv4_random">1</a></sup>, and when turned into a string, usually look something like
<code>1c20104f-e04f-409e-9ad3-94455e5f4fea</code>; this is called the &#34;hyphenated&#34; form, for fairly obvious
reasons. Although sometimes they&#39;re stored in a DB in that form directly, that&#39;s using 36 bytes to
store 16 bytes&#39; worth of data, which is more than twice as many bytes as necessary. And if you&#39;re
a programmer, this sort of conspicuous waste is unconscionable.</p>
<p>You can cut that to 32 bytes by just dropping the dashes, but then that&#39;s still twice as many bytes
as the actual data requires. If you never have to actually display the ID inside the database, then
the simplest thing to do is just store it as a blob of 16 bytes<sup><a href="#blob-of-bytes">2</a></sup>. Finally, optimal
representation and efficiency!</p>
<h2 id="indexes">Indexes?</h2>
<p>And at first, that&#39;s what I did. The <a href="https://docs.rs/sqlx/latest/sqlx/">external library</a> I&#39;m using
to interface with my database automatically writes UUIDs as a sequence of sixteen bytes, if you
specified the type in the database<sup><a href="#sqlite-dataclasses">3</a></sup> as &#34;<a href="https://www.sqlite.org/datatype3.html">blob</a>&#34;, which <a href="https://gitlab.com/nebkor/ww/-/commit/65a32f1f20df6c572580d796e1044bce807fd3b6#f1043d50a0244c34e4d056fe96659145d03b549b_0_5">I
did</a>.</p>
<p>But then I saw a <a href="https://shopify.engineering/building-resilient-payment-systems">blog post</a> where
the following tidbit was mentioned:</p>
<blockquote>
<p>We prefer using an Universally Unique Lexicographically Sortable Identifier (ULID) for these
idempotency keys instead of a random version 4 UUID. ULIDs contain a 48-bit timestamp followed by
80 bits of random data. The timestamp allows ULIDs to be sorted, which works much better with the
b-tree data structure databases use for indexing. In one high-throughput system at Shopify weâ€™ve
seen a 50 percent decrease in INSERT statement duration by switching from UUIDv4 to ULID for
idempotency keys.</p>
</blockquote>
<p>Whoa, that sounds great! But <a href="https://www.youtube.com/watch?v=f53-Iw_5ucA&amp;t=590s">this youtube
video</a> tempered my expectations a bit, by
describing the implementation-dependent reasons for that dramatic
improvement. Still, switching from UUIDs to ULIDs couldn&#39;t <em>hurt</em><sup><a href="#no-stinkin-benches">4</a></sup>, right? Plus,
by encoding the time of creation (at least to the nearest millisecond), I could remove a &#34;created
at&#34; field from every table that used them as primary keys. Which, in my case, would be all of them,
and I&#39;m worried less about the speed of inserts than I am about keeping total on-disk size down
anyway.</p>
<p>I was actually already familiar with the idea of using time-based sortable IDs, from
<a href="https://github.com/segmentio/ksuid">KSUIDs</a>. It&#39;s an attractive concept to me, and I&#39;d considered
using them from the get-go, but discarded that for two main reasons:</p>
<ul>
<li>they&#39;re <strong>FOUR WHOLE BYTES!!!</strong> larger than UUIDs</li>
<li>I&#39;d have to manually implement serialization/deserialization, since SQLx doesn&#39;t
have native support for them</li>
</ul>
<p>In reality, neither of those are real show-stoppers; 20 vs. 16 bytes is probably not that
significant, and I&#39;d have to do the manual serialization stuff for anything besides a
less-than-8-bytes number or a normal UUID. Still, four bytes is four bytes, and all other things
being equal, I&#39;d rather go for the trimmer, 64-bit-aligned value.</p>
<p>Finally, I&#39;d recently finished with adding some ability to actually interact with data in a
meaningful way, and to add new records to the database, which meant that it was now or never for
standardizing on a type for the primary keys. I was ready to do this thing.</p>

<p>&#34;Deserilization&#34; is the act of converting a static, non-native representation of some kind of
datatype into a dynamic, native computer programming object, so that you can do the right computer
programming stuff to it. It can be as simple as when a program reads in a string of digit characters
and parses it into a real number, but of course the ceiling on complexity is limitless.</p>
<p>In my case, it was about getting those sixteen bytes out of the database and turning them into
ULIDs. Technically, I could have let Rust <a href="https://serde.rs/derive.html">handle that for me</a> by
automatically deriving that functionality. There were a couple snags with that course, though:</p>
<ul>
<li>the default serialized representation of a ULID in the library I was using to provide them <a href="https://docs.rs/ulid/latest/ulid/serde/index.html">is as
26-character strings</a>, and I wanted to use only
16 bytes in the database</li>
<li>you could tell it to serialize as a <a href="https://docs.rs/ulid/latest/ulid/serde/ulid_as_u128/index.html">128-bit
number</a>, but that merely kicked the
problem one step down the road since SQLite can only handle up to 64-bit numbers, as previously
discussed, so I&#39;d still have to manually do something for them</li>
</ul>
<p>This meant going all-in on fully custom serialization and deserialization, something I&#39;d never done
before, but how hard could it be? (spoiler: actually not that hard!)</p>
<h2 id="great-coders-steal">Great coders steal</h2>
<p>Something I appreciate about the <a href="https://www.rust-lang.org/">Rust programming language</a> is that
because of the way the compiler works<sup><a href="#rust-generics">5</a></sup>, the full source code almost always has to be
available to you, the end-user coder. The culture around it is also very biased toward open source,
and so all the extremely useful libraries are just sitting there, ready to be studied and copied. So
the first thing I did was take a look at how <a href="https://github.com/launchbadge/sqlx/blob/main/sqlx-sqlite/src/types/uuid.rs">SQLx handled
UUIDs</a>:</p>
<pre data-lang="rust"><code data-lang="rust"><span>impl </span><span>Type&lt;Sqlite&gt; </span><span>for </span><span>Uuid {
</span><span>    </span><span>fn </span><span>type_info</span><span>() -&gt; SqliteTypeInfo {
</span><span>        SqliteTypeInfo(DataType::Blob)
</span><span>    }
</span><span>
</span><span>    </span><span>fn </span><span>compatible</span><span>(</span><span>ty</span><span>: &amp;SqliteTypeInfo) -&gt; </span><span>bool </span><span>{
</span><span>        matches!(ty.</span><span>0</span><span>, DataType::Blob | DataType::Text)
</span><span>    }
</span><span>}
</span><span>
</span><span>impl</span><span>&lt;</span><span>&#39;q</span><span>&gt; Encode&lt;</span><span>&#39;q</span><span>, Sqlite&gt; </span><span>for </span><span>Uuid {
</span><span>    </span><span>fn </span><span>encode_by_ref</span><span>(&amp;</span><span>self</span><span>, </span><span>args</span><span>: &amp;</span><span>mut </span><span>Vec&lt;SqliteArgumentValue&lt;</span><span>&#39;q</span><span>&gt;&gt;) -&gt; IsNull {
</span><span>        args.</span><span>push</span><span>(SqliteArgumentValue::Blob(Cow::Owned(
</span><span>            </span><span>self</span><span>.</span><span>as_bytes</span><span>().</span><span>to_vec</span><span>(),
</span><span>        )));
</span><span>
</span><span>        IsNull::No
</span><span>    }
</span><span>}
</span><span>
</span><span>impl </span><span>Decode&lt;&#39;_, Sqlite&gt; </span><span>for </span><span>Uuid {
</span><span>    </span><span>fn </span><span>decode</span><span>(</span><span>value</span><span>: SqliteValueRef&lt;&#39;_&gt;) -&gt; Result&lt;</span><span>Self</span><span>, BoxDynError&gt; {
</span><span>        </span><span>// construct a Uuid from the returned bytes
</span><span>        Uuid::from_slice(value.</span><span>blob</span><span>()).</span><span>map_err</span><span>(Into::into)
</span><span>    }
</span><span>}
</span></code></pre>
<p>There&#39;s not a ton going on there, as you can see. To &#34;encode&#34; it just gets the bytes out of the
UUID, and to &#34;decode&#34; it just gets the bytes out of the database. I couldn&#39;t use that exactly as
done by the SQLx authors, as they were using datatypes that were private to their crate, but it was
close enough; here&#39;s mine:</p>
<pre data-lang="rust"><code data-lang="rust"><span>impl </span><span>sqlx::Type&lt;sqlx::Sqlite&gt; </span><span>for </span><span>DbId {
</span><span>    </span><span>fn </span><span>type_info</span><span>() -&gt; &lt;sqlx::Sqlite as sqlx::Database&gt;::TypeInfo {
</span><span>        &lt;&amp;[</span><span>u8</span><span>] as sqlx::Type&lt;sqlx::Sqlite&gt;&gt;::type_info()
</span><span>    }
</span><span>}
</span><span>
</span><span>impl</span><span>&lt;</span><span>&#39;q</span><span>&gt; Encode&lt;</span><span>&#39;q</span><span>, Sqlite&gt; </span><span>for </span><span>DbId {
</span><span>    </span><span>fn </span><span>encode_by_ref</span><span>(&amp;</span><span>self</span><span>, </span><span>args</span><span>: &amp;</span><span>mut </span><span>Vec&lt;SqliteArgumentValue&lt;</span><span>&#39;q</span><span>&gt;&gt;) -&gt; IsNull {
</span><span>        args.</span><span>push</span><span>(SqliteArgumentValue::Blob(Cow::Owned(</span><span>self</span><span>.</span><span>bytes</span><span>().</span><span>to_vec</span><span>())));
</span><span>        IsNull::No
</span><span>    }
</span><span>}
</span><span>
</span><span>impl </span><span>Decode&lt;&#39;_, Sqlite&gt; </span><span>for </span><span>DbId {
</span><span>    </span><span>fn </span><span>decode</span><span>(</span><span>value</span><span>: SqliteValueRef&lt;&#39;_&gt;) -&gt; Result&lt;</span><span>Self</span><span>, sqlx::error::BoxDynError&gt; {
</span><span>        </span><span>let</span><span> bytes = &lt;&amp;[</span><span>u8</span><span>] as Decode&lt;Sqlite&gt;&gt;::decode(value)?;
</span><span>        </span><span>let</span><span> bytes: [</span><span>u8</span><span>; </span><span>16</span><span>] = bytes.</span><span>try_into</span><span>().</span><span>unwrap_or_default</span><span>();
</span><span>        Ok(</span><span>u128</span><span>::from_ne_bytes(bytes).</span><span>into</span><span>())
</span><span>    }
</span><span>}
</span></code></pre>
<p>(In order to implement the required methods from SQLx, I had to wrap the ULID in a new, custom type,
which I called <code>DbId</code>, to comply with the <a href="https://github.com/Ixrec/rust-orphan-rules">orphan rules</a>.)</p>
<p>That&#39;s only half the story, though. If all I had to worry about was getting data in and out of the
database, that would be fine, but because I&#39;m building a web app, I need to be able to include my
new ID type in messages sent over a network or as part of a web page, and for that, it needed to
implement some functionality from a different library, called <a href="https://serde.rs/">Serde</a>. My
original implementation for <em>deserializing</em> looked like this:</p>
<pre data-lang="rust"><code data-lang="rust"><span>struct </span><span>DbIdVisitor;
</span><span>
</span><span>impl</span><span>&lt;</span><span>&#39;de</span><span>&gt; Visitor&lt;</span><span>&#39;de</span><span>&gt; </span><span>for </span><span>DbIdVisitor {
</span><span>    </span><span>type </span><span>Value = DbId;
</span><span>
</span><span>    </span><span>// make a DbId from a slice of bytes
</span><span>    </span><span>fn </span><span>visit_bytes</span><span>&lt;E&gt;(</span><span>self</span><span>, </span><span>v</span><span>: &amp;[</span><span>u8</span><span>]) -&gt; Result&lt;</span><span>Self::</span><span>Value, E&gt;
</span><span>    </span><span>where
</span><span>        E: serde::de::Error,
</span><span>    {
</span><span>        ...
</span><span>    }
</span><span>
</span><span>    </span><span>// make a DbId from a Vec of bytes
</span><span>    </span><span>fn </span><span>visit_byte_buf</span><span>&lt;E&gt;(</span><span>self</span><span>, </span><span>v</span><span>: Vec&lt;</span><span>u8</span><span>&gt;) -&gt; Result&lt;</span><span>Self::</span><span>Value, E&gt;
</span><span>    </span><span>where
</span><span>        E: serde::de::Error,
</span><span>    {
</span><span>        ...
</span><span>    }
</span><span>
</span><span>    </span><span>// you get the picture
</span><span>    </span><span>fn </span><span>visit_string</span><span>() ...
</span><span>    </span><span>fn </span><span>visit_u128</span><span>() ...
</span><span>    </span><span>fn </span><span>visit_i128</span><span>() ...
</span><span>}
</span></code></pre>
<p>In my mind, the only important pieces were the <code>visit_bytes()</code> and <code>visit_byte_buf()</code> methods,
which worked basically the same as the <code>decode()</code> function for SQLx. I mean, as far as I could tell,
the only time something would be encountering a serialized <code>DbId</code> would be in the form of raw bytes
from the database; no one else would be trying to serialize one as something else that I didn&#39;t
anticipate, right?</p>
<p>RIGHT???</p>
<p>(wrong)</p>
<h2 id="a-puzzling-failure">A puzzling failure</h2>
<p>As soon as my code compiled, I ran my tests. Everything passed... except for one, that tested
logging in.</p>
<p>This was very strange. All the other tests were passing, and basically every operation requires
getting one of these IDs into or out of the database. But at this point, it was late, and I set it
down until the next day.</p>

<p>The next day I sat back down to get back to work, and in the course of examining what was going on,
realized that I&#39;d missed something crucial: these things were supposed to be <em>sortable</em>. But the way
I was inserting them meant that they weren&#39;t, because of endianness.</p>
<h2 id="more-like-shmexicographic-amirite">More like shmexicographic, amirite</h2>
<p>&#34;ULID&#34; stands for &#34;Universally Unique Lexicographically Sortable
Identifier&#34;<sup><a href="#uulsid">6</a></sup>. &#34;<a href="https://en.wikipedia.org/wiki/Lexicographic_order">Lexicographic order</a>&#34;
basically means, &#34;like alphabetical, but for anything with a defined total order&#34;. Numbers have a
defined total order; bigger numbers always go after smaller.</p>
<p>But sometimes numbers get sorted out of order, if they&#39;re not treated as numbers. Like say you had a
directory with twelve files in it, called &#34;1.txt&#34; up through &#34;12.txt&#34;. If you were to ask to see
them listed out in lexicographic order, it would go like:</p>
<pre data-lang="text"><code data-lang="text"><span>$ ls
</span><span>10.txt
</span><span>11.txt
</span><span>12.txt
</span><span>1.txt
</span><span>2.txt
</span><span>3.txt
</span><span>4.txt
</span><span>5.txt
</span><span>6.txt
</span><span>7.txt
</span><span>8.txt
</span><span>9.txt
</span></code></pre>
<p>This is because &#39;10&#39; is &#34;less than&#34; &#39;2&#39; (and &#39;0&#39; is &#34;less than&#34; &#39;.&#39;, which is why &#34;10.txt&#34; is before &#34;1.txt&#34;). The solution, as all
data-entering people know, is to pad the number with leading &#39;0&#39;s:</p>
<pre data-lang="text"><code data-lang="text"><span>$ ls
</span><span>01.txt
</span><span>02.txt
</span><span>03.txt
</span><span>04.txt
</span><span>05.txt
</span><span>06.txt
</span><span>07.txt
</span><span>08.txt
</span><span>09.txt
</span><span>10.txt
</span><span>11.txt
</span><span>12.txt
</span></code></pre>
<p>Now the names are lexicographically sorted in the right numerical order<sup><a href="#confusing-yes">7</a></sup>.</p>
<p>So, now that we&#39;re all expert lexicographicographers, we understand that our IDs are just
supposed to naturally sort themselves in the correct order, based on when they were created; IDs
created later should sort after IDs created earlier.</p>
<p>The implementation for my ULIDs only guaranteed this property for the string form of them, but I was
not storing them in string from. Fundamentally, the ULID was a simple <a href="https://doc.rust-lang.org/std/primitive.u128.html">128-bit primitive
integer</a>, capable of holding values between 0 and
340,282,366,920,938,463,463,374,607,431,768,211,455.</p>
<p>But there&#39;s a problem: I was storing the ID in the database as a sequence of 16 bytes. I was asking
for those bytes in &#34;native endian&#34;, which in my case, meant &#34;little endian&#34;. If you&#39;re not familiar
with endianness, there are two varieties: big, and little. &#34;Big&#34; makes the most sense for a lot of
people; if you see a number like &#34;512&#34;, it&#39;s big-endian; the end is the part that&#39;s left-most, and
&#34;big&#34; means that it is the most-significant-digit. This is the same as what westerners think of as
&#34;normal&#34; numbers. In the number &#34;512&#34;, the &#34;most significant digit&#34; is <code>5</code>, which correspends to
<code>500</code>, which is added to the next-most-significant digit, <code>1</code>, corresponding to <code>10</code>, which is added
to the next-most-significant digit, which is also the least-most-significant-digit, which is <code>2</code>,
which is just <code>2</code>, giving us the full number <code>512</code>.</p>
<p>If we put the least-significant-digit first, we&#39;d write the number <code>512</code> as &#34;215&#34;; the order when
written out would be reversed. This means that the lexicographic sort of <code>512, 521</code> would have &#34;125&#34;
come before &#34;215&#34;, which is backwards.</p>
<p>Little-endianness is like that. If a multibyte numeric value is on a little-endian system, the
least-significant bytes will come first, and a lexicographic sorting of those bytes would be
non-numeric.</p>
<p>The solution, though, is simple: just write them out in big-endian order! This was literally a
one-line change in the code, to switch from <code>to_ne_bytes()</code> (&#34;ne&#34; for &#34;native endian&#34;) to
<code>to_be_bytes()</code>. I confirmed that the bytes written into were being written in the correct
lexicographic order:</p>
<pre data-lang="sql"><code data-lang="sql"><span>sqlite&gt; </span><span>select</span><span> hex(id), username </span><span>from</span><span> users </span><span>order by</span><span> id </span><span>asc</span><span>;
</span><span>018903CDDCAAB0C6872A4509F396D388|first_user
</span><span>018903D0E591525EA42202FF461AA5FA|second_user
</span></code></pre>
<p>Note the first six characters are the same, for these two users created some time apart<sup><a href="#ulid-timestamps">8</a></sup>.</p>
<p>Boom. &#34;Sorted&#34;.</p>
<h2 id="the-actual-problem">The actual problem</h2>
<p>Except that the logins were still broken; it wasn&#39;t just the test. What was even stranger is that
with advanced debugging techniques<sup><a href="#advanced-debugging">9</a></sup>, I confirmed that the login <em>was</em>
working. By which I mean, when the user submitted a login request, the function that handled the
request was:</p>
<ul>
<li>correctly confirming password match</li>
<li>retrieving the user from the database</li>
</ul>
<p>The second thing was required for the first. It was even creating a session in the session table:</p>
<pre data-lang="sql"><code data-lang="sql"><span>sqlite&gt; </span><span>select </span><span>* </span><span>from</span><span> async_sessions;
</span><span>..|..|{&#34;</span><span>id</span><span>&#34;:&#34;</span><span>ZY...</span><span>&#34;,&#34;</span><span>expiry</span><span>&#34;:&#34;</span><span>...</span><span>&#34;,&#34;</span><span>data</span><span>&#34;:{&#34;</span><span>_user_id</span><span>&#34;:&#34;</span><span>[1,137,3,205,220,170,176,198,135,42,69,9,243,150,211,136]</span><span>&#34;,&#34;</span><span>_auth_id</span><span>&#34;:&#34;</span><span>\</span><span>&#34;oM...&#34;</span><span>}}
</span></code></pre>
<p>I noticed that the ID was present in the session entry, but as what looked like an array of decimal
values. The less not-astute among you may have noticed that the session table seemed to be using
JSON to store information. This wasn&#39;t my code, but it was easy enough to find the
<a href="https://github.com/http-rs/async-session/blob/d28cef30c7da38f52639b3d60fc8cf4489c92830/src/session.rs#L214">culprit</a>:</p>
<pre data-lang="rust"><code data-lang="rust"><span>    </span><span>pub fn </span><span>insert</span><span>(&amp;</span><span>mut </span><span>self</span><span>, </span><span>key</span><span>: &amp;</span><span>str</span><span>, </span><span>value</span><span>: impl Serialize) -&gt; Result&lt;(), serde_json::Error&gt; {
</span><span>        </span><span>self</span><span>.</span><span>insert_raw</span><span>(key, serde_json::to_string(&amp;value)?);
</span><span>        Ok(())
</span><span>    }
</span></code></pre>
<p>This was in the <a href="https://docs.rs/async-session/latest/async_session/">external library</a> I was using
to provide cookie-based sessions for my web app, and was transitively invoked when I called the
<code>login()</code> method in my own code. Someone else was serializing my IDs, in a way I hadn&#39;t anticipated!</p>
<p>The way that Serde decides what code to call is based on its <a href="https://serde.rs/data-model.html">data
model</a>. And wouldn&#39;t you know it, the following words are right
there, hiding in plain sight, as they had been all along:</p>
<blockquote>
<p>When deserializing a data structure from some format, the Deserialize implementation for the data
structure is responsible for mapping the data structure into the Serde data model by passing to
the Deserializer a Visitor implementation that can receive the various types of the data model...</p>
<p>[...]</p>
<ul>
<li>seq
<ul>
<li>A variably sized heterogeneous sequence of values, for example Vec&lt;T&gt; or HashSet&lt;T&gt;. ...</li>
</ul>
</li>
</ul>
<p>[...]</p>
<p>The flexibility around mapping into the Serde data model is profound and powerful. When
implementing Serialize and Deserialize, be aware of the broader context of your type that may make
the most instinctive mapping not the best choice.</p>
</blockquote>
<p>Well, when you put it that way, I can&#39;t help but understand: I needed to implement a <code>visit_seq()</code>
method in my deserialization code.</p>
<p><img src="https://proclamations.nebcorp-hias.com/rnd/one-part-serialized-mystery/./seen_the_light.png" alt="fine, fine, I see the light" title="jake blues seeing the light"/></p>
<p>fine, fine, i see the light</p>
<p>You can see that
<a href="https://gitlab.com/nebkor/ww/-/blob/656e6dceedf0d86e2805e000c9821e931958a920/src/db_id.rs#L194-216">here</a>
if you&#39;d like, but I&#39;ll actually come back to it in a second. The important part was that my logins
were working again; time to party!</p>
<h2 id="wait-why-isn-t-it-broken">Wait, why <em>isn&#39;t</em> it broken?</h2>
<p>I&#39;d just spent the day banging my head against this problem, and so when everything worked again, I
committed and pushed the change and signed off. But something was still bothering me, and the next
day, I dove back into it.</p>
<p>All my serialization code was calling a method called
<a href="https://gitlab.com/nebkor/ww/-/blob/656e6dceedf0d86e2805e000c9821e931958a920/src/db_id.rs#L18"><code>bytes()</code></a>,
which simply called another method that would return an array of 16 bytes, in big-endian order, so
it could go into the database and be sortable, as discussed.</p>
<p>But all<sup><a href="#actually_not_all">10</a></sup> my <em>deserialization</em> code was constructing the IDs as <a href="https://gitlab.com/nebkor/ww/-/blob/656e6dceedf0d86e2805e000c9821e931958a920/src/db_id.rs#L212">though the bytes
were
<em>little</em>-endian</a>. Which
lead me to ask:</p>
<p>what the fuck?</p>
<p>Like, everything was <em>working</em>. Why did I need to construct from a different byte order? I felt like
I was losing my mind, so I reached out to the <a href="https://www.recurse.com">Recurse Center</a> community
and presented my case.</p>
<p>Basically, I showed that bytes were written correctly, resident in the DB in big-endian form, but
then were &#34;backwards&#34; coming out and &#34;had to be&#34; cast using little-endian constructors
(&#34;<code>from_ne_bytes()</code>&#34;).</p>
<p>What had actually happened is that as long as there was agreement about what order to use for reconstructing the
ID from the bytes, it didn&#39;t matter if it was big or little-endian, it just had to be the same on
both the
<a href="https://gitlab.com/nebkor/ww/-/commit/84d70336d39293294fd47b4cf115c70091552c11#ce34dd57be10530addc52a3273548f2b8d3b8a9b_106_105">SQLx</a>
side and on the
<a href="https://gitlab.com/nebkor/ww/-/commit/84d70336d39293294fd47b4cf115c70091552c11#ce34dd57be10530addc52a3273548f2b8d3b8a9b_210_209">Serde</a>
side. This is also irrespective of the order they were written out in, but again, the two sides must
agree on the convention used. Inside the Serde method, I had added some debug printing of the bytes
it was getting, and they were in little-endian order. What I had not realized is that that was
because they were first passing through the SQLx method which reversed them.</p>
<p>Mmmmm, delicious, delicous red herring.</p>
<p>Two people were especially helpful, Julia Evans and Nicole Tietz-Sokolskaya; Julia grabbed a copy of
my database file and poked it with Python, and could not replicate the behavior I was seeing, and
Nicole did the same but with a little Rust program she wrote. Huge thanks to both of them (but not
just them) for the extended <a href="https://en.wikipedia.org/wiki/Rubber_duck_debugging">rubber ducking</a>!
And apologies for the initial gas-lighting; Julia was quite patient and diplomatic when pushing back
against &#34;the bytes are coming out of the db backwards&#34;.</p>

<p>Welp, here we are, the end of the line; I hope this has been informative, or barring that, at least
entertaining. Or the other way around, I&#39;m not that fussy!</p>
<p>Obviously, the biggest mistake was to futz with being clever about endianness before understanding
why the login code was now failing. Had I gotten it working correctly first, I would have been able to
figure out the requirement for agreement on convention between the two different serialization
systems much sooner, and I would not have wasted mine and others&#39; time on misunderstanding.</p>
<p>On the other hand, it&#39;s hard to see these things on the first try, especially when you&#39;re on your
own, and are on your first fumbling steps in a new domain or ecosystem; for me, that was getting
into the nitty-gritty with Serde, and for that matter, dealing directly with serialization-specific
issues. Collaboration is a great technique for navigating these situations, and I definitely need to
focus a bit more on enabling that<sup><a href="#solo-yolo-dev">11</a></sup>.</p>
<p>In the course of debugging this issue, I tried to get more insight via
<a href="https://gitlab.com/nebkor/ww/-/commit/656e6dceedf0d86e2805e000c9821e931958a920#ce34dd57be10530addc52a3273548f2b8d3b8a9b_143_251">testing</a>,
and though that helped a little, it was not nearly enough; the problem was that I misunderstood how
something worked, not that I had mistakenly implemented something I was comfortable with. Tests
aren&#39;t a substitute for understanding!</p>
<p>And of course, I&#39;m now much more confident and comfortable with Serde; reading the Serde code for
other things, like <a href="https://github.com/uuid-rs/uuid/blob/main/src/external/serde_support.rs">UUIDs</a>,
is no longer an exercise in eye-glaze-control. Maybe this has helped you with that too?</p>
<hr/>
<div id="uuidv4_random"><p><sup>1</sup></p><p>Technically, most v4 UUIDs have only 122 random bits, as six out of 128 are
reserved for version information.</p>
</div>
<div id="blob-of-bytes"><p><sup>2</sup></p><p>Some databases have direct support for 128-bit primitive values (numbers). The
database I&#39;m using, SQLite, only supports up to 64-bit primitive values, but it does support
arbitrary-length sequences of bytes called &#34;blobs&#34;.</p>
</div>
<div id="sqlite-dataclasses"><p><sup>3</sup></p><p>I&#39;m using <a href="https://www.sqlite.org/index.html">SQLite</a> for reasons that I plan
to dive into in a different post, but &#34;blob&#34; is specific to it. In general, you&#39;ll probably want
to take advantage of implementation-specific features of whatever database you&#39;re using, which
means that your table definitions won&#39;t be fully portable to a different database. This is fine
and good, actually!</p>
</div>
<div id="no-stinkin-benches"><p><sup>4</sup></p><p>You may wonder: have I benchmarked this system with UUIDs vs. ULIDs? Ha ha,
you must have never met a programmer before! No, of course not. But, that&#39;s coming in a
follow-up.</p>
</div>
<div id="rust-generics"><p><sup>5</sup></p><p>If the code you&#39;re using has
<a href="https://doc.rust-lang.org/book/ch10-01-syntax.html">generics</a> in it, then the compiler needs to
generate specialized versions of that generic code based on how you use it; this is called
&#34;<a href="https://doc.rust-lang.org/book/ch10-01-syntax.html#performance-of-code-using-generics">monomorphization</a>&#34;,
and it requires the original generic source to work. That&#39;s also true in C++, which is why most
templated code is <a href="https://isocpp.org/wiki/faq/templates#templates-defn-vs-decl">header-only</a>,
but Rust doesn&#39;t have header files.</p>
</div>
<div id="uulsid"><p><sup>6</sup></p><p>I guess the extra &#39;U&#39; and &#39;S&#39; are invisible.</p>
</div>
<div id="confusing-yes"><p><sup>7</sup></p><p>Is this confusing? Yes, 100%, it is not just you. Don&#39;t get discouraged.</p>
</div>
<div id="ulid-timestamps"><p><sup>8</sup></p><p>The 6 most-significant bytes make up the timestamp in a ULID, which in the hex
dump form pasted there would be the first twelve characters, since each byte is two hex
digits.</p>
</div>
<div id="advanced-debugging"><p><sup>9</sup></p><p>&#34;adding <code>dbg!()</code> statements in the code&#34;</p>
</div>
<div id="actually_not_all"><p><sup>10</sup></p><p>Upon further review, I discovered that the only methods that were constructing
with little-endian order were the SQLx <code>decode()</code> method, and the Serde <code>visit_seq()</code> method,
which were also the only ones that were being called at all. The
<a href="https://gitlab.com/nebkor/ww/-/blob/656e6dceedf0d86e2805e000c9821e931958a920/src/db_id.rs#L152"><code>visit_bytes()</code></a>
and <code>visit_byte_buf()</code> methods, that I had thought were so important, were correctly treating
the bytes as big-endian, but were simply never actually used. I fixed <a href="https://gitlab.com/nebkor/ww/-/commit/84d70336d39293294fd47b4cf115c70091552c11#ce34dd57be10530addc52a3273548f2b8d3b8a9b">in the next
commit</a></p>
</div>
<div id="solo-yolo-dev"><p><sup>11</sup></p><p>I&#39;ve described my current practices as &#34;solo-yolo&#34;, which has its plusses and
minuses, as you may imagine.</p>
</div>

        </section>
            
    </article>
</div></div>
  </body>
</html>
