<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.johndcook.com/blog/2025/10/06/a-quiet-change-to-rsa/">Original</a>
    <h1>A Quiet Change to RSA</h1>
    
    <div id="readability-page-1" class="page"><div>
		<p>An RSA public key is a pair of numbers (<em>e</em>, <em>n</em>) where <em>e</em> is an exponent and <em>n</em> = <em>pq</em> where <em>p</em> and <em>q</em> are large prime numbers. The original RSA paper said choose a private key <em>d</em> and compute <em>e</em>. In practice now we choose <em>e</em> and compute <em>d</em>. Furthermore, <em>e</em> is now almost always 65537 for reasons given <a href="https://www.johndcook.com/blog/2018/12/12/rsa-exponent/">here</a>. So the public key is essentially just <em>n</em>.</p>
<h2>Euler’s totient function</h2>
<p>The relationship between the exponent and the private decryption key in the original RSA paper was</p>
<p><em>ed</em> = 1 mod φ(<em>n</em>).</p>
<p>It is easy to compute <em>e</em> given <em>d</em>, or <em>d</em> given <em>e</em>, when you know Euler’s totient function of <em>n</em>,</p>
<p>φ(<em>n</em>) = (<em>p</em> − 1)(<em>q</em> − 1).</p>
<p>The security of RSA encryption rests on the assumption that it is impractical to compute φ(<em>n</em>) unless you know <em>p</em> and <em>q</em>.</p>
<h2>Carmichael’s totient function</h2>
<p>Gradually over the course of several years, the private key <em>d</em> changed from being the solution to</p>
<p><em>ed</em> = 1 mod φ(<em>n</em>)</p>
<p>to being the solution to</p>
<p><em>ed</em> = 1 mod λ(<em>n</em>)</p>
<p>where <strong>Euler</strong>‘s totient function φ(<em>n</em>) was replaced with <strong>Carmichael</strong>‘s totient function λ(<em>n</em>).</p>
<p>The heart of the original RSA paper was Euler’s generalization of Fermat’s little theorem which says if <em>a</em> is relatively prime to <em>m</em>, then</p>
<p><em>a</em><sup>φ(<em>n</em>)</sup> = 1 (mod <em>n</em>)</p>
<p>Carmichael’s λ(<em>n</em>) is defined to be the smallest number that can replace φ(<em>n</em>) in the equation above. It follows that λ(<em>n</em>) divides φ(<em>n</em>).</p>
<h2>Why the change?</h2>
<p>Using Carmichael’s totient rather than Euler’s totient results in smaller private keys and thus faster decryption. When <em>n</em> = <em>pq</em> for odd primes <em>p</em> and <em>q</em>,</p>
<p>λ(<em>n</em>) = lcm( (<em>p</em> − 1), (<em>q</em> − 1) ) = (<em>p</em> − 1)(<em>q</em> − 1) / gcd( (<em>p</em> − 1), (<em>q</em> − 1) )</p>
<p>so λ(<em>n</em>) is smaller than φ(<em>n</em>) by a factor of gcd( (<em>p</em> − 1), (<em>q</em> − 1) ). At a minimum, this factor is at least 2 since <em>p</em> − 1 and <em>q</em> − 1 are even numbers.</p>
<p>However, an experiment suggests this was a trivial savings. When I generated ten RSA public keys the gcd was never more than 8.</p>
<pre>from sympy import randprime, gcd

for _ in range(10):
    p = randprime(2**1023, 2**1024)
    q = randprime(2**1023, 2**1024)
    print(gcd(p-1, q-1))
</pre>
<p>I repeated the experiment with 100 samples. The median of the gcd’s was 2, the mean was 35.44, and the maximum was 2370. So the while gcd <em>might</em> be moderately large, but it is usually just 2 or 4.</p>
<h2>Better efficiency</h2>
<p>The efficiency gained from using Carmichael’s totient is minimal. More efficiency can be gained by using <a href="https://www.johndcook.com/blog/2023/09/14/garners-algorithm/">Garner’s algorithm</a>.</p>
			</div></div>
  </body>
</html>
