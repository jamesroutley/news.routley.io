<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://buttondown.email/hillelwayne/archive/problems-harder-than-np-complete/">Original</a>
    <h1>Problems harder than NP-Complete</h1>
    
    <div id="readability-page-1" class="page"><div>

                

                
                    
                        <p>People always talk about “P vs NP” like P problems are easy and NP problems are hard. This is a useful day-to-day model but also an oversimplification.</p>
<p>Problems can get way, way harder than NP.</p>
<p>(If you want a brief refresher on P and NP, check out my post <a href="https://www.hillelwayne.com/post/np-hard/" target="_blank">NP-Complete isn’t (always) Hard</a>.) </p>
<h3>PSPACE-complete</h3>
<p>P is the set of all problems that can be solved in polynomial time, relative to the input. PSPACE is the set of all problems that can be solved with polynomial <em>space</em>. It’s assumed, but not proven, that PSPACE is strictly larger than NP. In other words, there are some problems that take polynomial space to solve but nonpolynomial time to verify.</p>
<p>The canonical NP problem is <strong>quantified satisfiability</strong>. The normal SAT problem, which is NP-complete, is finding assignments to variables that satisfy a set of boolean clauses: </p>
<div><pre><span></span><code>some ABCDEF:
  A | C
  !A | D | !E
  B | !D | E | F
  etc
</code></pre></div>

<p>The QSAT analog adds the <code>forall</code> and <code>some</code> quantifiers:</p>
<div><pre><span></span><code>forall A:
  some BCDEF:
    A | C
    !A | D | !E
    B | !D | E | F
    etc
</code></pre></div>

<p>In other words, can we solve the problem regardless of what I choose for <code>A</code>? If I instead write</p>
<div><pre><span></span><code>some BCDEF:
  forall A:
    ...
</code></pre></div>

<p>The problem is instead “is there a fixed assignment which works if A is true <em>and</em> if A is false?”</p>
<p>And, similarly to how many problems can be reduced to SAT, many problems can also be reduced to QSAT, such as finding optimal <a href="https://en.wikipedia.org/wiki/Sorting_network" target="_blank">sorting networks</a>. Many simple systems are model-checkable (showing a specification has a property) in PSPACE.</p>
<h3>EXPTIME-complete</h3>
<p>EXPTIME is the set of all problems that are solvable in exponential time, ie the difficult grows with O(2^n). It’s suspected that EXPTIME is strictly larger than PSPACE and NP, meaning there are problems that take more than polynomial space to solve and more than polynomial time to verify.</p>
<p>I looked around and most EXPTIME-complete examples fall in one of two categories. First, game problems. Given a configuration of an NxN Go/Chess/Checkers/Shogi board, does player 1 have a winning strategy?</p>
<p>The second, <strong>succinct circuits</strong>, are more interesting.<sup id="fnref:reference"><a href="#fn:reference">1</a></sup> An n-node simple graph can have up to <del>2^n</del> n^2 edges, <del>meaning it takes exponential space to encode</del>.<sup id="fnref:mistake"><a href="#fn:mistake">2</a></sup> Some graphs can be defined <em>algorithmically</em> by a boolean function <code>f(A, B)</code> which returns whether or not nodes A and B have an edge between them. If the function is small enough,<sup id="fnref:circuit"><a href="#fn:circuit">3</a></sup> then we can encode the graph in polynomial space! <em>However</em>, because determining if two nodes are connected is no longer a constant-time lookup, any P-complete graph problem becomes an EXPTIME-complete succinct graph problem. Similarly, NP-complete problems become <a href="https://en.wikipedia.org/wiki/NEXPTIME" target="_blank">NEXPTIME-complete</a>, which is its own complexity class.</p>
<p>I’ve not been able to find any industry use of succinct circuits. </p>
<h3>2-EXPTIME-complete</h3>
<p>2-EXPTIME is like EXPTIME except instead of the Big-O being O(2^n), it’s O(2^(2^n)).</p>
<p>A lot of very niche and weird stuff falls under 2-EXPTIME. The canonical example is deciding <strong>Presburger Arithmetic</strong> statements. Put roughly, that’s any mathematical statement that uses positive numbers, variables, addition, equality, <code>forall</code>, and <code>some</code>, but <em>not</em> multiplication. This is a statement in Presburger arithmetic:</p>
<div><pre><span></span><code>forall x:
  exists y:
    y + y = x 
    || y + y + 1 = x
</code></pre></div>

<p>Presburger arithmetic is decidable, so you can check the validity of any statement in at most doubly-exponential time. If you add multiplication, then statements become undecidable.</p>
<p>Some kinds of program synthesis (taking properties and generating a matching program) are <a href="https://www.semanticscholar.org/paper/Church&#39;s-Problem-Revisited-Kupferman-Vardi/4470e014837a60ede7678296d7ac2ff1dc35bdc4" target="_blank">2-EXPTIME-complete</a>.</p>
<p><a href="https://web.archive.org/web/20081031150433/http://www.informatik.uni-freiburg.de/~ki/papers/Rintanen03compl.pdf" target="_blank">This paper</a> finds that if “planning” is EXPTIME-complete, then “planning with partial observability” is 2-EXPTIME-complete. <em>I think</em> this means finding a series of steps that solves a task, where in some cases you have to take steps without knowing environmental state that affects you. Like <a href="https://www.youtube.com/watch?v=6gjsAA_5Agk" target="_blank">beating Pokemon while blind and deaf</a>.</p>
<p>Finally, <a href="https://arxiv.org/pdf/1402.0705.pdf" target="_blank">this paper</a> shows that checking certain formulae in “Relevance logic” is 2-EXPTIME-complete. RL seems to be a logic where A =&gt; B means that “A is relevant to proving B”, so you can’t do things like F =&gt; T, I think. Seems pretty neat.</p>
<h3>ELEMENTARY-complete</h3>
<p>ELEMENTARY is EXPTIME + 2-EXPTIME + 3-EXPTIME + (etc). If a problem is elementary, it means there is some <code>n</code> where the problem is strictly in n-EXPTIME.</p>
<p>There are provably no ELEMENTARY-complete problems. For every elementary problem, there is a harder elementary problem.</p>
<p>And there are problems harder than <em>every</em> elementary problem, like</p>
<h3>TOWER-complete</h3>
<p>Let’s define <strong>tetration</strong> <code>^^</code> as repeated exponentiation, so 3^^2 = 3^3, 3^^3 = 3^(3^3), etc. TOWER-complete, then, is O(2^^n). Notice that for each n, <code>2^^n</code> eventually resolves to some exponential “tower”. But it’s not ELEMENTARY because bigger instances of the same problem will require taller towers, where ELEMENTARY requires all instances of the problem to be part of the same tower.</p>
<p>We are now <em>deep</em> in the math weeds. <a href="https://web.archive.org/web/20170811095516/http://www.mathunion.org/ICM/ICM1974.2/Main/icm1974.2.0477.0482.ocr.pdf" target="_blank">This paper</a> (pg 3) finds a wide variety of TOWER-complete problems, the easiest of which to describe is (2): does a CS regular expression <em>without stars</em> have no matches? The rest of his examples are about proving statements in various theories.</p>
<p>Kinda rushing past TOWER-complete to get to the real fun one:</p>
<h3>Ackermann-complete</h3>
<p>Define (a variant of) the <a href="https://en.wikipedia.org/wiki/Ackermann_function" target="_blank">Ackermann function</a> like this:</p>
<div><pre><span></span><code>A(1) = 1*1
A(2) = 2^2
A(3) = 3^^3
A(4) = 4^^^4
etc
</code></pre></div>

<p>Ackermann-complete problems take time growing with O(A(n)). This is the most obscene concept I’ve seen this month. And, unlike 2-EXPTIME and TOWER, it has a shockingly simple example.</p>
<p>Define a <strong>Vector Addition System</strong> as follows: You have a starting vector S, like <code>(1, 12, 0, 3)</code>. You have a set of update vectors U, like <code>(1, -1, -1, 7)</code>, <code>(95, 0, 10, -2)</code>, etc. At every step, you can take any update vector U and add it to S, <em>as long as no element goes below 0</em>. So you couldn’t add the first vector but could add the second. You can do this any number of times and use each vector as many times as you want, etc.</p>
<p>From here, we can define the <strong>reachability problem</strong>: given a target vector T, like <code>(7, 7, 7, 6)</code>, is there <em>any</em> sequence of steps that reaches T? This was proven <a href="https://hal.science/hal-03436240/document" target="_blank">decidable in 1981</a> but nobody could prove the complexity, and for a long time it was assumed to be EXPSPACE-complete (where n is the vector dimension). Then, just last year, <a href="https://arxiv.org/pdf/2104.13866.pdf" target="_blank">it was proven to be Ackermann-complete</a>.</p>
<p>It is so <em>wild</em> to me that such an easily-explained problem has such a mindbogglingly high complexity class.</p>
<h3>Hyperackermann-complete</h3>
<p>The paper <a href="https://arxiv.org/abs/1312.5686" target="_blank">Complexity Hierarchies Beyond Elementary</a> introduces the HAck complexity class and gives examples of it. Both the definition and the examples are beyond my understanding.</p>
<h2>What did we learn</h2>
<p>Things can always get worse.</p>
<p>One interesting pattern I saw was “problem lifting”. People take a class of problems and apply an extra complication that consistently changes the complexity class. Like if you replace graphs with succinct circuits, you turn P-complete problems into EXPTIME-complete problems. Or if you take planning problems and add in partial observability, you turn EXPTIME problems into 2-EXPTIME problems. That’s neat.</p>
<hr/>
<h2>I’m speaking at <a href="https://gotochgo.com/2023" target="_blank">GOTO Chicago</a></h2>
<p>May 22nd-24th! I will finally, <em>finally</em> be publicly giving my talk <a href="https://www.hillelwayne.com/post/are-we-really-engineers/" target="_blank">on the crossover project</a>. You can see the talk page <a href="https://gotochgo.com/2023/sessions/2538/is-software-engineering-real-engineering" target="_blank">here</a>!</p>
<h3>Update for the Internets</h3>
<p>This was sent as part of an email newsletter; you can subscribe <a href="https://buttondown.email/hillelwayne/" target="_blank">here</a>. </p>

                    
                

                
            </div></div>
  </body>
</html>
