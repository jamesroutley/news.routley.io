<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://engineering.fb.com/2024/08/05/data-center-engineering/roce-network-distributed-ai-training-at-scale/">Original</a>
    <h1>A RoCE network for distributed AI training at scale</h1>
    
    <div id="readability-page-1" class="page"><div>

		<ul>
<li><span>AI networks play an important role in interconnecting tens of thousands of GPUs together, forming the foundational infrastructure for training, enabling large models with hundreds of billions of parameters such as </span><a href="https://ai.meta.com/blog/meta-llama-3-1/" target="_blank" rel="noopener"><span>LLAMA 3.1 405B</span></a><span>.</span></li>
<li><span>This week at </span><a href="https://conferences.sigcomm.org/sigcomm/2024/" target="_blank" rel="noopener"><span>ACM SIGCOMM 2024</span></a><span> in Sydney, Australia, we are sharing details on the network we have built at Meta over the past few years to support our large-scale distributed AI training workload. </span></li>
<li><span>Our paper, “</span><a href="https://dl.acm.org/doi/10.1145/3651890.3672233" target="_blank" rel="noopener"><span>RDMA over Ethernet for Distributed AI Training at Meta Scale</span></a><span>,” provides the details on how we design, implement, and operate one of the world’s largest AI networks at scale.</span></li>
</ul>
<p><span>The growing prevalence of AI has introduced a new era of communication demands. Distributed training, in particular, imposes the most significant strain on data center networking infrastructure. For instance, a typical generative AI (GenAI) job may necessitate tight coordination of </span><a href="https://engineering.fb.com/2024/03/12/data-center-engineering/building-metas-genai-infrastructure/"><span>tens of thousands of GPUs</span></a><span> over the course of several weeks. Constructing a reliable, high-performance network infrastructure capable of accommodating this burgeoning demand necessitates a reevaluation of data center network design.</span></p>
<p><span>When Meta introduced </span><a href="https://engineering.fb.com/2021/07/15/open-source/fsdp/"><span>distributed GPU-based training</span></a><span>, we decided to construct specialized data center networks tailored for these GPU clusters. We opted for RDMA Over Converged Ethernet version 2 (RoCEv2) as the inter-node communication transport for the majority of our AI capacity. </span></p>
<p><span>We have successfully expanded our RoCE networks, evolving from prototypes to the deployment of numerous clusters, each accommodating thousands of GPUs. These RoCE clusters support an extensive range of production distributed GPU training jobs, including ranking, content recommendation, content understanding, natural language processing, and GenAI model training, among other workloads.</span></p>
<h2><span>Topology</span></h2>
<p><span>We built a dedicated backend network specifically for distributed training. This allowed us to evolve, operate, and scale independently from the rest of the data center network. To support large language models (LLMs), we expanded the backend network towards the DC-scale, e.g., incorporating topology-awareness into the training job scheduler.</span></p>
<h3><span>The separation</span></h3>
<p><span>The training cluster relies on two independent networks: the frontend (FE) network for tasks such as data ingestion, checkpointing, and logging, and the backend (BE) network for training, as depicted below.</span><img decoding="async" src="https://engineering.fb.com/wp-content/uploads/2024/08/RoCE-AI-training_image-2.png?w=1024" alt="" width="1024" height="663" srcset="https://engineering.fb.com/wp-content/uploads/2024/08/RoCE-AI-training_image-2.png 1224w, https://engineering.fb.com/wp-content/uploads/2024/08/RoCE-AI-training_image-2.png?resize=916,593 916w, https://engineering.fb.com/wp-content/uploads/2024/08/RoCE-AI-training_image-2.png?resize=768,497 768w, https://engineering.fb.com/wp-content/uploads/2024/08/RoCE-AI-training_image-2.png?resize=1024,663 1024w, https://engineering.fb.com/wp-content/uploads/2024/08/RoCE-AI-training_image-2.png?resize=96,62 96w, https://engineering.fb.com/wp-content/uploads/2024/08/RoCE-AI-training_image-2.png?resize=192,124 192w" sizes="(max-width: 992px) 100vw, 62vw"/></p>
<p><span>A training rack is connected to both the FE and BE of the data center network. The FE has a hierarchy of network layers – rack switches (RSWs), fabric switches (FSWs), and higher – that houses the storage warehouse, which provides GPUs with the necessary input data for training workloads. We ensure that there is enough ingress bandwidth on the rack switch to not hinder the training workload.</span></p>
<p><span>The BE is a specialized fabric that connects all RDMA NICs in a non-blocking architecture, providing high bandwidth, low latency, and lossless transport between any two GPUs in the cluster, regardless of their physical location. This backend fabric utilizes the RoCEv2 protocol, which encapsulates the RDMA service in UDP packets for transport over the network.</span></p>
<h3><span>AI Zone</span></h3>
<p><span>Our BE networks have undergone several transformations. Initially, our GPU clusters used a simple star topology with a few AI racks connected to a central Ethernet switch running the non-routable RoCEv1 protocol. This setup had clear limitations in GPU scale and switch redundancy. Therefore, we swiftly transitioned to a fabric-based architecture for extended scalability and higher availability. </span></p>
<p><span>We designed a two-stage Clos topology for AI racks, known as an </span><i><span>AI Zone</span></i><span>. The rack training switch (RTSW), serving as the leaf switch, offers scale-up connectivity for GPUs within the rack using copper-based DAC cables. The spine tier, composed of modular cluster training switches (CTSW), provides scale-out connectivity among all racks in the cluster. The CTSW has deep buffers statically divided over the ports in the chassis. The RTSWs connect to CTSWs via single-mode fiber and 400G pluggable transceivers.</span></p>
<p><img decoding="async" src="https://engineering.fb.com/wp-content/uploads/2024/08/RoCE-AI-training_image-1.png?w=1024" alt="" width="1024" height="520" srcset="https://engineering.fb.com/wp-content/uploads/2024/08/RoCE-AI-training_image-1.png 1999w, https://engineering.fb.com/wp-content/uploads/2024/08/RoCE-AI-training_image-1.png?resize=916,465 916w, https://engineering.fb.com/wp-content/uploads/2024/08/RoCE-AI-training_image-1.png?resize=768,390 768w, https://engineering.fb.com/wp-content/uploads/2024/08/RoCE-AI-training_image-1.png?resize=1024,520 1024w, https://engineering.fb.com/wp-content/uploads/2024/08/RoCE-AI-training_image-1.png?resize=1536,780 1536w, https://engineering.fb.com/wp-content/uploads/2024/08/RoCE-AI-training_image-1.png?resize=96,49 96w, https://engineering.fb.com/wp-content/uploads/2024/08/RoCE-AI-training_image-1.png?resize=192,97 192w" sizes="(max-width: 992px) 100vw, 62vw"/></p>
<p><span>The AI Zones are designed to support a large number of interconnected GPUs in a non-blocking manner. </span><span>However, emerging AI advancements, such as LLMs like </span><a href="https://llama.meta.com/llama3/" target="_blank" rel="noopener"><span>Llama</span></a><span>, demand a GPU scale larger than what a single AI zone provides. To accommodate this, we designed an aggregator training switch (ATSW) layer that connects the CTSWs in a data center building, expanding the RoCE domain beyond a single AI Zone. </span></p>
<p><span>Note, the cross-AI Zone connectivity is oversubscribed by design, with network traffic balanced using ECMP. To mitigate the performance bottleneck for cross-AI Zone traffic, we enhanced the training job scheduler to find a “minimum cut” when dividing the training nodes into different AI Zones, reducing the cross-AI Zone traffic and thus collective completion time. The scheduler does this by learning the position of GPU servers in the logical topology to recommend a rank assignment. </span></p>
<h2><span>Routing</span></h2>
<p><span>The scaling of compute power and network topology discussed above led to the question of how to efficiently balance and route the massive training traffic. Specifically, the AI training workloads had several challenging characteristics: </span></p>
<ol>
<li><b>Low entropy</b><span>: Compared to traditional data center workloads, the number and the diversity of flows for AI workloads are much smaller and the flow patterns are usually repetitive and predictable. </span></li>
<li><b>Burstiness</b><span>: On the time dimension, the flows usually exhibit the “on and of”’ nature in the time granularity of milliseconds. </span></li>
<li><b>Elephant flows</b><span>: For each burst, the intensity of each flow could reach up to the line rate of NICs. </span></li>
</ol>
<h3><span>ECMP and path pinning</span></h3>
<p><span>We initially considered the widely adopted ECMP, which places flows randomly based on the hashes on the five-tuple: source and destination IPs, source and destination UDP ports, and protocol. However, and as expected, ECMP rendered poor performance for the training workload due to the low flow entropy. </span></p>
<p><span>Alternatively, we designed and deployed a path-pinning scheme in the initial years of our deployment. This scheme routed packets to specific paths based on the destination “slice” (the index of the RTSW downlink). This worked well if each rack was fully assigned to the same job and there was no failure in the network. However, this was seldom true. We saw that the rack can be partially allocated to a job, with only one of the two hosts in the rack using the uplink bandwidth. This fragmented job placement caused uneven traffic distribution and congestion on the uplinks of the particular RTSW and degraded the training performance up to more than 30%. Further, network failures on a uplink or a CTSW caused the affected flows to be unevenly reassigned to other CTSWs by ECMP. Those reassigned flows collided with other existing flows and slowed down the whole training job.</span></p>
<p><span>We mitigated the immediate impact of these flow collisions by upgrading the bandwidth of the RTSW uplinks bandwidth by 2x. Hence we allowed for the RTSW uplink capacity to be 1:2 under-subscribed compared to the RTSW downlink capacity. While this mitigated the immediate performance impact, this was an expensive solution as it required 2x network capacity. Thus, we recognized this as a short-term mitigation and proceeded to further stages of routing evolution. </span></p>
<h3><span>Queue pair scaling</span></h3>
<p><span>We next revisited ECMP with an intent to increase the number of flows for hierarchical collectives through the queue pair (QP) scaling software feature in the collective library. </span></p>
<p><span>To account for this, we configured switches to perform Enhanced ECMP (E-ECMP) to additionally hash on the destination QP field of a RoCE packet using the UDF capability of the switch ASIC. This increased entropy and, compared to baseline ECMP without QP scaling, we observed that E-ECMP along with QP scaling showed performance improvement of up to 40% for the AllReduce collective.</span></p>
<p><img loading="lazy" decoding="async" src="https://engineering.fb.com/wp-content/uploads/2024/08/RoCE-AI-training_image-3.png?w=1024" alt="" width="1024" height="615" srcset="https://engineering.fb.com/wp-content/uploads/2024/08/RoCE-AI-training_image-3.png 1999w, https://engineering.fb.com/wp-content/uploads/2024/08/RoCE-AI-training_image-3.png?resize=916,550 916w, https://engineering.fb.com/wp-content/uploads/2024/08/RoCE-AI-training_image-3.png?resize=768,461 768w, https://engineering.fb.com/wp-content/uploads/2024/08/RoCE-AI-training_image-3.png?resize=1024,615 1024w, https://engineering.fb.com/wp-content/uploads/2024/08/RoCE-AI-training_image-3.png?resize=1536,922 1536w, https://engineering.fb.com/wp-content/uploads/2024/08/RoCE-AI-training_image-3.png?resize=96,58 96w, https://engineering.fb.com/wp-content/uploads/2024/08/RoCE-AI-training_image-3.png?resize=192,115 192w" sizes="(max-width: 992px) 100vw, 62vw"/></p>
<p><span>We evaluated two QP scaling strategies. The first involved splitting each message meant to be posted over a single QP, instead onto multiple QPs resulting in multiple flows. But it also produced smaller message sizes on fabric as well as multiple ACKs. The second approach involved posting each message to a different queue, in a round-robin fashion. For the NIC message sizes demonstrated in our production with NCCL, we observed the latter to be performing well. This feature has been important for ECMP scalability by increasing the network flows for hierarchical collectives like AllReduce.</span></p>
<p><span>While we improved ECMP performance with QP scaling, the underlying probabilistic nature of hashing was a persistent downside of this routing scheme. Also, the need to customize the QP scaling factor and methodology based on the workload type, while workable in the short-term, presented long-term operational complexity.</span></p>
<h2><span>Congestion control</span></h2>
<p><span>As we transitioned to 400G deployments, we attempted to tune DCQCN to adapt to new network speeds and topology. However, with default DCQCN settings and doubled ECN thresholds compared to 200G networks, performance was degraded. Further investigation revealed that DCQCN implementation in firmware has changed, introducing bugs and reduced visibility with problems relating to correct CNP counting. </span></p>
<p><span>We proceeded without DCQCN for our 400G deployments. At this time, we have had over a year of experience with just PFC for flow control, without any other transport-level congestion control. We have observed stable performance and lack of persistent congestion for training collectives. </span></p>
<h3><span>Receiver-driven traffic admission</span></h3>
<p><span>To mitigate the congestion for 400G and beyond, we co-designed the collective library and RoCE transport to enforce receiver-driven traffic admission for better performance. The diagram below shows that the GPU-to-GPU communication architecture in our production training clusters predominantly uses two-stage copy and receiver-initiated communication via the NCCL collective library. Each GPU’s high bandwidth memory (HBM) maintains multiple channels for parallel transmission of chunked collective messages. The sender GPU threads first copy data from the compute buffer to an available channel buffer. The sender CPU proxy thread can only post an RDMA write request after receiving a clear-to-send (CTS) packet from the receiver, which includes the size and memory information. The receiver’s GPU threads then copy the channel buffer contents to the destination compute buffer. Finally, CPU proxy threads on both sides recycle the channel buffer, and the receiver CPU proxy sends another CTS packet once the channel buffer is ready.</span></p>
<p><img loading="lazy" decoding="async" src="https://engineering.fb.com/wp-content/uploads/2024/08/RoCE-AI-training_image-4.png?w=1024" alt="" width="1024" height="353" srcset="https://engineering.fb.com/wp-content/uploads/2024/08/RoCE-AI-training_image-4.png 1999w, https://engineering.fb.com/wp-content/uploads/2024/08/RoCE-AI-training_image-4.png?resize=916,316 916w, https://engineering.fb.com/wp-content/uploads/2024/08/RoCE-AI-training_image-4.png?resize=768,265 768w, https://engineering.fb.com/wp-content/uploads/2024/08/RoCE-AI-training_image-4.png?resize=1024,353 1024w, https://engineering.fb.com/wp-content/uploads/2024/08/RoCE-AI-training_image-4.png?resize=1536,530 1536w, https://engineering.fb.com/wp-content/uploads/2024/08/RoCE-AI-training_image-4.png?resize=96,33 96w, https://engineering.fb.com/wp-content/uploads/2024/08/RoCE-AI-training_image-4.png?resize=192,66 192w" sizes="(max-width: 992px) 100vw, 62vw"/></p>
<p><span>We effectively leverage this mechanism as a receiver-driven traffic admission to limit the amount of in-flight traffic on the network, especially when congestion starts to build up. However, configuring the right setting can be challenging as: </span></p>
<ol>
<li><span>The number of channels is limited due to the resource contention on GPU threads with concurrent compute operations; </span></li>
<li><span>Setting the channel buffer size requires a more careful balance between congestion spreading and bandwidth under-utilization than Infiniband due to RoCE’s more coarse-grained flow control and possible end-host slowness. </span></li>
</ol>
<p><span>Thus, we took two steps to improve the performance. First, we experimentally determined the right parameter settings for the number of channels and channel buffer size across various training job sizes and collective types. Second, we implemented high priority queuing at switches for CTS packets to expedite the notifications and mitigate potential bandwidth starvation.</span></p>
<p><span>Congestion control has been a focal point of research in RDMA networks. DCQCN has been the gold standard for storage-focused networks. However, our experience with distributed AI training workloads provides a different perspective on tailoring the congestion control algorithms. Despite turning off DCQCN and multiple instances of RTSW sending PFC to a deep-buffer CTSW, we have not encountered a scenario over the last four years where production AI training traffic causes the CTSW to send PFCs to RTSWs persistently. </span></p>
<p><span>Our current solution depends on careful coordination between the collective communication library and the network. It may depend on the relative throughput between GPU and network, which may not be applicable to all scenarios. We encourage the research community to put more focus on this topic.</span></p>
<h2><span>Moving forward</span></h2>
<p><span>The design and operation of large-scale RoCE networks for distributed AI training workloads have evolved to meet the increasing demands of computational density and scale. By segregating FE and BE networks, employing various routing schemes, and optimizing collective traffic patterns, we have been able to build a performant and reliable network infrastructure. These designs and insights underline the importance of deeply understanding the training workload and translating these implications into network component design, ultimately contributing to the advancement of distributed AI training infrastructure.</span></p>
<p><span>With the fast growing trend of GenAI workload, our network infrastructure will evolve rapidly. </span></p>
<h2><span>Read the paper</span></h2>
<p><a href="https://dl.acm.org/doi/10.1145/3651890.3672233" target="_blank" rel="noopener"><span>RDMA over Ethernet for Distributed AI Training at Meta Scale</span></a></p>
<h2><span>Acknowledgements</span></h2>
<p><i><span>We would like to thank all contributors to the paper, including </span></i><i><span data-rich-links="{&#34;per_n&#34;:&#34;Rui Miao&#34;,&#34;per_e&#34;:&#34;rmiao@meta.com&#34;,&#34;type&#34;:&#34;person&#34;}">Rui Miao</span></i><i><span>, </span></i><i><span data-rich-links="{&#34;per_n&#34;:&#34;Shengbao Zheng&#34;,&#34;per_e&#34;:&#34;shengbao@fb.com&#34;,&#34;type&#34;:&#34;person&#34;}">Shengbao</span></i><i><span data-rich-links="{&#34;per_n&#34;:&#34;Shengbao Zheng&#34;,&#34;per_e&#34;:&#34;shengbao@fb.com&#34;,&#34;type&#34;:&#34;person&#34;}"> Zheng</span></i><i><span>, </span></i><i><span data-rich-links="{&#34;per_n&#34;:&#34;Sai Jayesh Bondu&#34;,&#34;per_e&#34;:&#34;sai5@fb.com&#34;,&#34;type&#34;:&#34;person&#34;}">Sai Jayesh Bondu</span></i><i><span>, </span></i><i><span data-rich-links="{&#34;per_n&#34;:&#34;Guilherme Goes&#34;,&#34;per_e&#34;:&#34;glwgoes@meta.com&#34;,&#34;type&#34;:&#34;person&#34;}">Guilherme Goes</span></i><i><span>, </span></i><i><span data-rich-links="{&#34;per_n&#34;:&#34;Hany Morsy&#34;,&#34;per_e&#34;:&#34;hany@meta.com&#34;,&#34;type&#34;:&#34;person&#34;}">Hany Morsy</span></i><i><span>, </span></i><i><span data-rich-links="{&#34;per_n&#34;:&#34;Rohit Puri&#34;,&#34;per_e&#34;:&#34;rohitpuri@meta.com&#34;,&#34;type&#34;:&#34;person&#34;}">Rohit Puri</span></i><i><span>, </span></i><i><span data-rich-links="{&#34;per_n&#34;:&#34;Adi Mohammad Riftadi&#34;,&#34;per_e&#34;:&#34;riftadi@meta.com&#34;,&#34;type&#34;:&#34;person&#34;}">Adi Mohammad Riftadi</span></i><i><span>, </span></i><i><span data-rich-links="{&#34;per_n&#34;:&#34;Ashmitha Jeevaraj Shetty&#34;,&#34;per_e&#34;:&#34;ajshetty@meta.com&#34;,&#34;type&#34;:&#34;person&#34;}">Ashmitha Jeevaraj Shetty</span></i><i><span>, </span></i><i><span data-rich-links="{&#34;per_n&#34;:&#34;Jingyi Yang&#34;,&#34;per_e&#34;:&#34;girasoley@fb.com&#34;,&#34;type&#34;:&#34;person&#34;}">Jingyi Yang</span></i><i><span>, </span></i><i><span data-rich-links="{&#34;per_n&#34;:&#34;Shuqiang Zhang&#34;,&#34;per_e&#34;:&#34;sqzhang@fb.com&#34;,&#34;type&#34;:&#34;person&#34;}">Shuqiang Zhang</span></i><i><span>, </span></i><i><span data-rich-links="{&#34;per_n&#34;:&#34;Mikel Jimenez Fernandez&#34;,&#34;per_e&#34;:&#34;mikeljim@meta.com&#34;,&#34;type&#34;:&#34;person&#34;}">Mikel Jimenez Fernandez</span></i><i><span>, </span></i><i><span data-rich-links="{&#34;per_n&#34;:&#34;Shashi Gandham&#34;,&#34;per_e&#34;:&#34;gshashi@meta.com&#34;,&#34;type&#34;:&#34;person&#34;}">Shashi Gandham</span></i><i><span>, </span></i><i><span data-rich-links="{&#34;per_n&#34;:&#34;Omar Baldonado&#34;,&#34;per_e&#34;:&#34;ocb@fb.com&#34;,&#34;type&#34;:&#34;person&#34;}">Omar Baldonado</span></i><i><span>. Many current and former people in the Network Infrastructure team at Meta have contributed to productionizing RoCE networks for AI training over the years. In particular, we would like to acknowledge Srinivas Sridharan, Petr Lapukhov, Jose Leitao, and Brandon Taylor. This work is a close collaboration with our partners in Meta’s AI Production Engineering, AI and Systems Co-design, and AI Hardware Systems teams.</span></i></p>

		
	</div></div>
  </body>
</html>
