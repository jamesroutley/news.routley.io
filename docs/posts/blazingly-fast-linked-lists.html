<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dygalo.dev/blog/blazingly-fast-linked-lists/">Original</a>
    <h1>Blazingly fast linked lists</h1>
    
    <div id="readability-page-1" class="page"><div>
            
  <figure>
    <img src="https://dygalo.dev/blog/2048px-Rusty_chain_in_fishing_boat.jpg"/>
    
      <figcaption>© Tomas Castelazo, www.tomascastelazo.com / Wikimedia Commons / CC BY-SA 4.0</figcaption>
    
  </figure>

<p>Linked lists are <a href="https://rust-unofficial.github.io/too-many-lists/" target="_blank">taught</a> as fundamental data structures in programming courses, but they are more commonly encountered in tech interviews than in real-world projects.</p>
<p>In this post, I&#39;ll demonstrate a practical use case where a linked list significantly outperforms <code>Vec</code>. 
We will build a simple data validation library that shows the exact error location within invalid input, showcasing how a linked list can be used in graph traversals.</p>
<p>Starting with a naive approach, we’ll progressively implement various optimizations and observe their impact on performance. </p>
<p>Readers are expected to have a basic understanding of Rust, common data structures, and the concept of memory allocations (stack vs. heap).</p>
<blockquote>
<p>To follow along with the implementation steps and explore the code, check out the accompanying <a href="https://github.com/Stranger6667/article-linked-lists" target="_blank">repository</a></p>
</blockquote>
<h2 id="validation-api">Validation API</h2>
<p>Our library is fairly minimal, and follows <a href="https://json-schema.org/specification#specification-documents" target="_blank">JSON Schema</a> semantics:</p>
<pre data-lang="rust"><code data-lang="rust"><span>use </span><span>serde_json::json;
</span><span>
</span><span>fn </span><span>main</span><span>() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
</span><span>    jsonschema::validate(
</span><span>      </span><span>// JSON instance to validate
</span><span>      &amp;json!({
</span><span>          &#34;</span><span>name</span><span>&#34;: &#34;</span><span>John</span><span>&#34;,
</span><span>          &#34;</span><span>location</span><span>&#34;: {
</span><span>               &#34;</span><span>country</span><span>&#34;: </span><span>404
</span><span>          }
</span><span>      }),
</span><span>      </span><span>// JSON schema
</span><span>      &amp;json!({
</span><span>          &#34;</span><span>properties</span><span>&#34;: {
</span><span>              &#34;</span><span>name</span><span>&#34;: {
</span><span>                  &#34;</span><span>type</span><span>&#34;: &#34;</span><span>string</span><span>&#34;
</span><span>              },
</span><span>              &#34;</span><span>location</span><span>&#34;: {
</span><span>                  &#34;</span><span>properties</span><span>&#34;: {
</span><span>                      &#34;</span><span>country</span><span>&#34;: {
</span><span>                          &#34;</span><span>type</span><span>&#34;: &#34;</span><span>string</span><span>&#34;
</span><span>                      }
</span><span>                  }
</span><span>              }
</span><span>          }
</span><span>      }),
</span><span>    ).</span><span>expect_err</span><span>(&#34;</span><span>Should fail</span><span>&#34;);
</span><span>    Ok(())
</span><span>}
</span></code></pre>
<p>In this example, <code>404</code> is not a string and this code should result in an error like this:</p>
<pre><code><span>404 is not of type ‘string’ at /location/country
</span><span> |                             |               |
</span><span> |                              ---------------
</span><span> |                                     |
</span><span> |                                     Location within the JSON instance
</span><span> |
</span><span>  Failing value
</span></code></pre>
<blockquote>
<p>This library and optimization ideas are derived from my <a href="https://github.com/Stranger6667/jsonschema-rs" target="_blank">jsonschema</a> crate</p>
</blockquote>
<p>The validation process boils down to graph traversal. The input instance is traversed based on rules defined in the schema. At any traversal step, we should know the current location within the JSON instance to potentially report a meaningful error.</p>

  <p><img src="https://dygalo.dev/blog/validation-process.png"/></p><p>Our primary goal is to implement location tracking while minimizing its impact on the library&#39;s performance.</p>
<p>Without diving too deep into the <code>Validator</code> and <code>Node</code> implementations, let&#39;s see a simplified version of the validation process without location tracking:</p>
<pre data-lang="rust"><code data-lang="rust"><span>type </span><span>ValidationResult = Result&lt;(), ValidationError&gt;;
</span><span>
</span><span>fn </span><span>validate</span><span>(</span><span>instance</span><span>: &amp;Value, </span><span>schema</span><span>: &amp;Value) -&gt; ValidationResult {
</span><span>    Validator::new(schema)
</span><span>        .</span><span>expect</span><span>(&#34;</span><span>Invalid schema</span><span>&#34;)
</span><span>        .</span><span>validate</span><span>(instance)
</span><span>}
</span><span>
</span><span>struct </span><span>ValidationError {
</span><span>    </span><span>message</span><span>: String,
</span><span>}
</span><span>
</span><span>impl </span><span>Validator {
</span><span>    </span><span>/// Validate JSON instance against this validator.
</span><span>    </span><span>fn </span><span>validate</span><span>(&amp;</span><span>self</span><span>, </span><span>instance</span><span>: &amp;Value) -&gt; ValidationResult {
</span><span>        </span><span>self</span><span>.node.</span><span>validate</span><span>(instance)
</span><span>    }
</span><span>}
</span><span>
</span><span>trait </span><span>Node {
</span><span>    </span><span>fn </span><span>validate</span><span>(&amp;</span><span>self</span><span>, </span><span>instance</span><span>: &amp;Value) -&gt; ValidationResult;
</span><span>}
</span><span>
</span><span>impl </span><span>Node </span><span>for </span><span>Properties {
</span><span>    </span><span>fn </span><span>validate</span><span>(&amp;</span><span>self</span><span>, </span><span>instance</span><span>: &amp;Value) -&gt; ValidationResult {
</span><span>        </span><span>if let </span><span>Value::Object(object) = instance {
</span><span>            </span><span>// Iterate over properties and validate them if they are present.
</span><span>            </span><span>for </span><span>(key, value) in &amp;</span><span>self</span><span>.properties {
</span><span>                </span><span>if let </span><span>Some(instance) = object.</span><span>get</span><span>(key) {
</span><span>                    </span><span>// Delegate validation to the child validator.
</span><span>                    value.</span><span>validate</span><span>(instance)?;
</span><span>                }
</span><span>            }
</span><span>        }
</span><span>        Ok(())
</span><span>    }
</span><span>}
</span><span>
</span><span>impl </span><span>Node </span><span>for </span><span>Type {
</span><span>    </span><span>fn </span><span>validate</span><span>(&amp;</span><span>self</span><span>, </span><span>instance</span><span>: &amp;Value) -&gt; ValidationResult {
</span><span>        </span><span>// ... 
</span><span>    }
</span><span>}
</span></code></pre>
<p>The <code>validate</code> function creates a new <code>Validator</code> instance (that is also a graph) from the provided schema and then calls its <code>validate</code> method with the JSON instance.
The <code>Node</code> trait defines the <code>validate</code> method that each validation rule must implement.</p>
<p>While this version provides error messages without location tracking, it serves as an upper bound for subsequent optimizations within the <code>validate</code> function.</p>
<h2 id="benchmark-setup">Benchmark setup</h2>
<p>To ensure the optimizations are relevant to the library&#39;s typical usage scenarios, we select inputs from different groups - valid and invalid instances of varying sizes. </p>
<p>The <a href="https://github.com/Stranger6667/article-linked-lists/blob/main/benches/data.json#L2" target="_blank">schema</a> contains 10 levels of nesting and is deliberately restricted to only the <code>properties</code> and <code>type</code> keywords, which are sufficient to demonstrate the overhead of path-tracking behavior while simplifying benchmarking and keeping our focus on performance rather than JSON Schema semantics. It&#39;s worth noting that the path-tracking behavior will remain largely the same for other keywords as well.</p>
<pre data-lang="json"><code data-lang="json"><span>{
</span><span>    &#34;</span><span>properties</span><span>&#34;:{
</span><span>        &#34;</span><span>another</span><span>&#34;:{
</span><span>            &#34;</span><span>type</span><span>&#34;:&#34;</span><span>string</span><span>&#34;
</span><span>        },
</span><span>        &#34;</span><span>inner</span><span>&#34;:{
</span><span>            &#34;</span><span>properties</span><span>&#34;:{
</span><span>                &#34;</span><span>another</span><span>&#34;:{
</span><span>                    &#34;</span><span>type</span><span>&#34;:&#34;</span><span>string</span><span>&#34;
</span><span>                },
</span><span>                &#34;</span><span>inner</span><span>&#34;:{
</span><span>                    &#34;</span><span>properties</span><span>&#34;:{
</span><span>                        </span><span>// And so on for up to 10 levels
</span><span>                    }
</span><span>                }
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>The instances have 0, 5, or 10 levels of nesting, following the schema&#39;s structure. Valid instances have a string value for the &#34;another&#34; property at the deepest level, while invalid instances have an integer.</p>
<pre data-lang="json"><code data-lang="json"><span>// Valid - 5 levels
</span><span>{
</span><span>    &#34;</span><span>inner</span><span>&#34;:{
</span><span>        &#34;</span><span>inner</span><span>&#34;:{
</span><span>            &#34;</span><span>inner</span><span>&#34;:{
</span><span>                &#34;</span><span>inner</span><span>&#34;:{
</span><span>                    &#34;</span><span>another</span><span>&#34;:&#34;</span><span>hello</span><span>&#34;
</span><span>                }
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>}
</span><span>// Invalid - 5 levels
</span><span>{
</span><span>    &#34;</span><span>inner</span><span>&#34;:{
</span><span>        &#34;</span><span>inner</span><span>&#34;:{
</span><span>            &#34;</span><span>inner</span><span>&#34;:{
</span><span>                &#34;</span><span>inner</span><span>&#34;:{
</span><span>                    &#34;</span><span>another</span><span>&#34;:</span><span>1
</span><span>                }
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>To focus on the performance of the validation process itself, the schema is hardcoded in <code>Validator::new</code>, and <code>Validator</code> is built once and then reused.</p>
<p>Let’s measure performance with <a href="https://bheisler.github.io/criterion.rs/book/criterion_rs.html" target="_blank">criterion</a> by running the following validation routine:</p>
<pre data-lang="rust"><code data-lang="rust"><span>const </span><span>NUMBER_OF_ITERATIONS</span><span>: </span><span>usize </span><span>= </span><span>10000</span><span>;
</span><span>
</span><span>fn </span><span>benchmarks</span><span>(</span><span>c</span><span>: &amp;</span><span>mut</span><span> Criterion) {
</span><span>    </span><span>// snip ... 
</span><span>    </span><span>for</span><span> instance in &amp;benchmark.instances {
</span><span>        c.</span><span>bench_with_input</span><span>(
</span><span>            BenchmarkId::new(instance.kind, &amp;instance.name),
</span><span>            &amp;instance.value,
</span><span>            |</span><span>b</span><span>: &amp;</span><span>mut</span><span> Bencher, </span><span>value</span><span>| {
</span><span>                b.</span><span>iter</span><span>(|| {
</span><span>                    </span><span>for </span><span>_ in </span><span>0</span><span>..</span><span>NUMBER_OF_ITERATIONS </span><span>{
</span><span>                        </span><span>let </span><span>_ = validator.</span><span>validate</span><span>(value);
</span><span>                    }
</span><span>                });
</span><span>            },
</span><span>        );
</span><span>    }
</span><span>}
</span></code></pre>
<table>
  <thead>
    <tr>
      <th rowspan="2">Commit</th>
      <th colspan="3">Valid</th>
      <th colspan="3">Invalid</th>
    </tr>
    <tr>
      <th>0</th>
      <th>5</th>
      <th>10</th>
      <th>0</th>
      <th>5</th>
      <th>10</th>
    </tr>
  </thead>
  <tbody>
<tr>
  <td><a href="https://github.com/Stranger6667/article-linked-lists/commit/a030dcb18448555efa1a8f63f8b5ccebef7d2f59" target="_blank">a030dcb</a></td>
  <td>36.3 µs</td>
  <td>553.8 µs</td>
  <td>1.11 ms</td>
  <td>475.2 µs</td>
  <td>914.8 µs</td>
  <td>1.48 ms</td>
</tr>
  </tbody>
</table>
<blockquote>
<p>The numbers in these microbenchmarks are not absolute and may vary depending on the hardware and the environment. Generally, the observed changes could be explained by stack traces in flame graphs, but you always need to check the benchmarks yourself.</p>
</blockquote>
<h2 id="naive-approach">Naive approach</h2>
<p>Let&#39;s start from collecting traversed path segments in a vector adding a new segment each time validation goes one level deeper:</p>
<pre data-lang="rust"><code data-lang="rust"><span>fn </span><span>validate</span><span>(&amp;</span><span>self</span><span>, </span><span>instance</span><span>: &amp;Value) -&gt; ValidationResult {
</span><span>    </span><span>// Start with an empty vector
</span><span>    </span><span>self</span><span>.node.</span><span>validate</span><span>(instance, vec![])
</span><span>}
</span><span>
</span><span>trait </span><span>Node {
</span><span>    </span><span>// Add `path` parameter to track the current location in the JSON instance
</span><span>    </span><span>fn </span><span>validate</span><span>(&amp;</span><span>self</span><span>, </span><span>instance</span><span>: &amp;Value, </span><span>path</span><span>: Vec&lt;&amp;</span><span>str</span><span>&gt;) -&gt; ValidationResult;
</span><span>}
</span><span>
</span><span>impl </span><span>Node </span><span>for </span><span>Properties {
</span><span>    </span><span>fn </span><span>validate</span><span>(&amp;</span><span>self</span><span>, </span><span>instance</span><span>: &amp;Value, </span><span>path</span><span>: Vec&lt;&amp;</span><span>str</span><span>&gt;) -&gt; ValidationResult {
</span><span>        </span><span>if let </span><span>Value::Object(object) = instance {
</span><span>            </span><span>for </span><span>(key, value) in &amp;</span><span>self</span><span>.properties {
</span><span>                </span><span>if let </span><span>Some((key, instance)) = object.</span><span>get_key_value</span><span>(key) {
</span><span>                    </span><span>// Create a new path and pass it to the child node
</span><span>                    </span><span>let mut</span><span> path = path.</span><span>clone</span><span>();
</span><span>                    path.</span><span>push</span><span>(key);
</span><span>                    value.</span><span>validate</span><span>(instance, path)?;
</span><span>                }
</span><span>            }
</span><span>        }
</span><span>        Ok(())
</span><span>    }
</span><span>}
</span><span>
</span><span>impl </span><span>Node </span><span>for </span><span>Type {
</span><span>    </span><span>fn </span><span>validate</span><span>(&amp;</span><span>self</span><span>, </span><span>instance</span><span>: &amp;Value, </span><span>path</span><span>: Vec&lt;&amp;</span><span>str</span><span>&gt;) -&gt; ValidationResult {
</span><span>        </span><span>match </span><span>(</span><span>self</span><span>, instance) {
</span><span>            </span><span>// ... Compare `instance` type with expected type
</span><span>            _ =&gt; Err(ValidationError::new(
</span><span>                format!(&#34;</span><span>{instance}</span><span> is not of type &#39;</span><span>{self}</span><span>&#39;</span><span>&#34;),
</span><span>                </span><span>// Convert path to an iterator
</span><span>                path.</span><span>into_iter</span><span>(),
</span><span>            )),
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>The <code>ValidationError</code> struct now stores this path:</p>
<pre data-lang="rust"><code data-lang="rust"><span>struct </span><span>ValidationError {
</span><span>    </span><span>message</span><span>: String,
</span><span>    </span><span>/// Error location within the input instance.
</span><span>    </span><span>location</span><span>: Vec&lt;String&gt;,
</span><span>}
</span><span>
</span><span>impl </span><span>ValidationError {
</span><span>    </span><span>/// Create new validation error.
</span><span>    </span><span>fn </span><span>new</span><span>(
</span><span>        </span><span>message</span><span>: impl Into&lt;String&gt;,
</span><span>        </span><span>// Accept an iterator and convert it to `Vec&lt;String&gt;`
</span><span>        </span><span>location</span><span>: impl Iterator&lt;Item = impl Into&lt;String&gt;&gt;,
</span><span>    ) -&gt; </span><span>Self </span><span>{
</span><span>        </span><span>Self </span><span>{
</span><span>            message: message.</span><span>into</span><span>(),
</span><span>            location: location.</span><span>map</span><span>(Into::into).</span><span>collect</span><span>(),
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>If you&#39;ve been writing Rust for a while, you&#39;ll likely recognize the <code>clone()</code> call as a common &#34;solution&#34; to lifetime and mutability issues. While it is acceptable in certain situations, depending on your performance and maintainability constraints, it often signals an opportunity for optimization. Cloning a <code>Vec</code> can be costly, especially in performance-critical code.</p>
<table>
  <thead>
    <tr>
      <th rowspan="2">Commit</th>
      <th colspan="3">Valid</th>
      <th colspan="3">Invalid</th>
    </tr>
    <tr>
      <th>0</th>
      <th>5</th>
      <th>10</th>
      <th>0</th>
      <th>5</th>
      <th>10</th>
    </tr>
  </thead>
  <tbody>
<tr>
  <td><a href="https://github.com/Stranger6667/article-linked-lists/commit/9ef7b4c56c8ca2ba3dcd15681daff6951aa64c2c" target="_blank">9ef7b4c</a></td>
  <td>40.9 µs</td>
  <td>2.61 ms</td>
  <td>6.69 ms</td>
  <td>961.2 µs</td>
  <td>4.11 ms</td>
  <td>9.07 ms</td>
</tr>
  </tbody>
</table>
<p>This feature makes validation up to 6 times slower! </p>
<blockquote>
<p>You may note that <code>path</code> is only used when one of the validators returns an error. Can we leverage this observation for optimizations?</p>
</blockquote>
<p>Let’s visualize the slowest &#34;valid&#34; benchmark using <code>cargo flamegraph</code> to understand what is going on. As expected, the memory reallocations show up in the flame graph:</p>
<pre data-lang="shell"><code data-lang="shell"><span>cargo flamegraph --bench jsonschema -o naive-10.svg -- --bench &#34;^valid/10 levels&#34;
</span></code></pre>

  <p><img src="https://dygalo.dev/blog/naive-valid-10.png"/></p><blockquote>
<p>Flame graphs are amazing for visualizing stack traces, see more details <a href="https://github.com/flamegraph-rs/flamegraph" target="_blank">here</a> </p>
</blockquote>
<h2 id="idea-1-cheaper-clones">Idea 1: Cheaper clones</h2>
<p>There are a couple of ways to deal with clones. First, let&#39;s try a different data structure that offers cheaper clones. The <a href="https://docs.rs/imbl/latest/imbl/" target="_blank">imbl</a> crate provides the <code>Vector</code> type, which is based on the <a href="https://infoscience.epfl.ch/record/213452/files/rrbvector.pdf">Relaxed-Radix-Balanced tree</a>.</p>
<p>RRB trees are a type of immutable data structure that allows for efficient structural sharing. This concept allows most memory to be shared among multiple mostly identical data structures, and extra memory is only allocated when modifications occur, thus requiring memory only to record the difference. With most operations being O(log n), <code>Vector </code> offers decent performance in many scenarios.</p>
<pre data-lang="rust"><code data-lang="rust"><span>use </span><span>imbl::Vector;
</span><span>
</span><span>fn </span><span>validate</span><span>(&amp;</span><span>self</span><span>, </span><span>instance</span><span>: &amp;Value) -&gt; ValidationResult {
</span><span>    </span><span>self</span><span>.node.</span><span>validate</span><span>(instance, Vector::new())
</span><span>}
</span><span>
</span><span>trait </span><span>Node {
</span><span>    </span><span>// Replace `Vec` with `imbl::Vector`
</span><span>    </span><span>fn </span><span>validate</span><span>(&amp;</span><span>self</span><span>, </span><span>instance</span><span>: &amp;Value, </span><span>path</span><span>: Vector&lt;&amp;</span><span>str</span><span>&gt;) -&gt; ValidationResult;
</span><span>}
</span><span>
</span><span>impl </span><span>Node </span><span>for </span><span>Properties {
</span><span>    </span><span>fn </span><span>validate</span><span>(&amp;</span><span>self</span><span>, </span><span>instance</span><span>: &amp;Value, </span><span>path</span><span>: Vector&lt;&amp;</span><span>str</span><span>&gt;) -&gt; ValidationResult 
</span><span>        </span><span>// ...
</span><span>                    </span><span>let mut</span><span> path = path.</span><span>clone</span><span>();
</span><span>                    </span><span>// Use `push_back` instead of `push`
</span><span>                    path.</span><span>push_back</span><span>(key);
</span><span>                    value.</span><span>validate</span><span>(instance, path)?;
</span><span>        </span><span>// ...
</span><span>    }
</span><span>}
</span><span>
</span><span>impl </span><span>Node </span><span>for </span><span>Type {
</span><span>    </span><span>fn </span><span>validate</span><span>(&amp;</span><span>self</span><span>, </span><span>instance</span><span>: &amp;Value, </span><span>path</span><span>: Vector&lt;&amp;</span><span>str</span><span>&gt;) -&gt; ValidationResult 
</span><span>        </span><span>// ...
</span><span>    }
</span><span>}
</span></code></pre>
<table>
  <thead>
    <tr>
      <th rowspan="2">Commit</th>
      <th colspan="3">Valid</th>
      <th colspan="3">Invalid</th>
    </tr>
    <tr>
      <th>0</th>
      <th>5</th>
      <th>10</th>
      <th>0</th>
      <th>5</th>
      <th>10</th>
    </tr>
  </thead>
  <tbody>
<tr>
  <td><a href="https://github.com/Stranger6667/article-linked-lists/commit/77adb2c34ef95b978e90429c80bad59a422caa39" target="_blank">77adb2c</a></td>
  <td>47.1 µs</td>
  <td>2.25 ms</td>
  <td>6.49 ms</td>
  <td>904.3 µs</td>
  <td>4.09 ms</td>
  <td>9.77 ms</td>
</tr>
  </tbody>
</table>
<p>Interesting! In some cases, <code>Vector</code> outperforms the naive approach, while in others, it introduces slight overhead.  While <code>Vector</code> can be faster for certain data &amp; usage patterns due to structural sharing, it may introduce overhead for other patterns because of its more complex internal structure.</p>
<blockquote>
<p>In some scenarios, where modifications occur way less often than clones, you can consider using Arc as explained in this <a href="https://www.youtube.com/watch?v=A4cKi7PTJSs">video</a> . You may also try the <a href="https://docs.rs/rpds/latest/rpds/" target="_blank">rpds</a> crate which provides similar data structures with structural sharing.</p>
</blockquote>
<h2 id="idea-2-reuse-allocations">Idea 2: Reuse allocations</h2>
<p>However, you may note that we don&#39;t have to clone the data - what if we mutate the same vector, pushing and popping segments as we traverse?</p>
<pre data-lang="rust"><code data-lang="rust"><span>trait </span><span>Node {
</span><span>    </span><span>fn </span><span>validate</span><span>&lt;</span><span>&#39;a</span><span>&gt;(
</span><span>        &amp;</span><span>self</span><span>,
</span><span>        </span><span>instance</span><span>: &amp;</span><span>&#39;a</span><span> Value,
</span><span>        </span><span>path</span><span>: &amp;</span><span>mut </span><span>Vec&lt;&amp;</span><span>&#39;a str</span><span>&gt;,
</span><span>    ) -&gt; ValidationResult;
</span><span>}
</span><span>
</span><span>impl </span><span>Node </span><span>for </span><span>Properties {
</span><span>    </span><span>fn </span><span>validate</span><span>&lt;</span><span>&#39;a</span><span>&gt;(
</span><span>        &amp;</span><span>self</span><span>,
</span><span>        </span><span>instance</span><span>: &amp;</span><span>&#39;a</span><span> Value,
</span><span>        </span><span>path</span><span>: &amp;</span><span>mut </span><span>Vec&lt;&amp;</span><span>&#39;a str</span><span>&gt;,
</span><span>    ) -&gt; ValidationResult {
</span><span>        </span><span>// ...
</span><span>                    path.</span><span>push</span><span>(key);
</span><span>                    value.</span><span>validate</span><span>(instance, path)?;
</span><span>                    path.</span><span>pop</span><span>();
</span><span>        </span><span>// ...
</span><span>    }
</span><span>}
</span><span>
</span><span>impl </span><span>Node </span><span>for </span><span>Type {
</span><span>    </span><span>fn </span><span>validate</span><span>&lt;</span><span>&#39;a</span><span>&gt;(
</span><span>        &amp;</span><span>self</span><span>,
</span><span>        </span><span>instance</span><span>: &amp;</span><span>&#39;a</span><span> Value,
</span><span>        </span><span>path</span><span>: &amp;</span><span>mut </span><span>Vec&lt;&amp;</span><span>&#39;a str</span><span>&gt;,
</span><span>    ) -&gt; ValidationResult {
</span><span>        </span><span>match </span><span>(</span><span>self</span><span>, instance) {
</span><span>            </span><span>// ... Compare `instance` type with expected type
</span><span>            _ =&gt; Err(ValidationError::new(
</span><span>                format!(&#34;</span><span>{instance}</span><span> is not of type &#39;</span><span>{self}</span><span>&#39;</span><span>&#34;),
</span><span>                path.</span><span>iter</span><span>().</span><span>copied</span><span>(),
</span><span>            )),
</span><span>        }
</span><span>    }
</span></code></pre>
<p>The lifetime annotations (<code>&#39;a</code>) are needed here because the path parameter is a mutable reference to a <code>Vec</code> that contains references to the <code>instance</code> parameter. The lifetime <code>&#39;a</code> ensures that the references in <code>path</code> do not outlive the <code>instance</code> they refer to.</p>
<table>
  <thead>
    <tr>
      <th rowspan="2">Commit</th>
      <th colspan="3">Valid</th>
      <th colspan="3">Invalid</th>
    </tr>
    <tr>
      <th>0</th>
      <th>5</th>
      <th>10</th>
      <th>0</th>
      <th>5</th>
      <th>10</th>
    </tr>
  </thead>
  <tbody>
<tr>
  <td><a href="https://github.com/Stranger6667/article-linked-lists/commit/7c9473689bf24b90c8e0c45f700ad985b536a73e" target="_blank">7c94736</a></td>
  <td>40.2 µs</td>
  <td>1.24 ms</td>
  <td>2.46 ms</td>
  <td>951.7 µs</td>
  <td>2.39 ms</td>
  <td>4.16 ms</td>
</tr>
  </tbody>
</table>
<p>Indeed, using <code>&amp;mut Vec</code> can significantly improve performance compared to the naive approach, by reusing a single heap allocation instead of creating multiple clones. However, this approach requires more bookkeeping and somewhat more lifetime annotations, which can increase code complexity.</p>
<h2 id="idea-3-linked-list">Idea 3: Linked list</h2>
<p>However, is it even necessary to allocate heap memory for a vector during traversal? Consider this: for each traversed node in the input value, there&#39;s a corresponding <code>validate</code> function call with its own stack frame. As a result, path segments can be stored in these stack frames, eliminating the need for heap allocations completely.</p>

  <p><img src="https://dygalo.dev/blog/function-call-frames.png"/></p><blockquote>
<p>Taking a step back and looking from a different angle can uncover ideas that may not be apparent at a lower level.</p>
</blockquote>
<p>By storing all segments on the stack, when an error happens, the previous segments can be traced back. This approach involves connecting each segment to form a path and collecting them when necessary. This sounds like a linked list:</p>
<pre data-lang="rust"><code data-lang="rust"><span>/// A node in a linked list representing a JSON pointer.
</span><span>struct </span><span>JsonPointerNode&lt;</span><span>&#39;a</span><span>, </span><span>&#39;b</span><span>&gt; {
</span><span>    </span><span>segment</span><span>: Option&lt;&amp;</span><span>&#39;a str</span><span>&gt;,
</span><span>    </span><span>parent</span><span>: Option&lt;&amp;</span><span>&#39;b </span><span>JsonPointerNode&lt;</span><span>&#39;a</span><span>, </span><span>&#39;b</span><span>&gt;&gt;,
</span><span>}
</span><span>impl</span><span>&lt;</span><span>&#39;a</span><span>, </span><span>&#39;b</span><span>&gt; JsonPointerNode&lt;</span><span>&#39;a</span><span>, </span><span>&#39;b</span><span>&gt; {
</span><span>    </span><span>/// Create a root node of a JSON pointer.
</span><span>    </span><span>const fn </span><span>new</span><span>() -&gt; </span><span>Self </span><span>{
</span><span>        JsonPointerNode {
</span><span>            segment: None,
</span><span>            parent: None,
</span><span>        }
</span><span>    }
</span><span>    </span><span>/// Push a new segment to the JSON pointer.
</span><span>    </span><span>fn </span><span>push</span><span>(&amp;</span><span>&#39;a </span><span>self</span><span>, </span><span>segment</span><span>: &amp;</span><span>&#39;a str</span><span>) -&gt; JsonPointerNode&lt;</span><span>&#39;a</span><span>, </span><span>&#39;b</span><span>&gt; {
</span><span>        JsonPointerNode {
</span><span>            segment: Some(segment),
</span><span>            parent: Some(</span><span>self</span><span>),
</span><span>        }
</span><span>    }
</span><span>    </span><span>/// Convert the JSON pointer node to a vector of path segments.
</span><span>   </span><span>fn </span><span>to_vec</span><span>(&amp;</span><span>&#39;a </span><span>self</span><span>) -&gt; Vec&lt;&amp;</span><span>&#39;a str</span><span>&gt; {
</span><span>        </span><span>// Callect the segments from the head to the tail
</span><span>        </span><span>let mut</span><span> buffer = Vec::new();
</span><span>        </span><span>let mut</span><span> head = </span><span>self</span><span>;
</span><span>        </span><span>if let </span><span>Some(segment) = &amp;head.segment {
</span><span>            buffer.</span><span>push</span><span>(*segment);
</span><span>        }
</span><span>        </span><span>while let </span><span>Some(next) = head.parent {
</span><span>            head = next;
</span><span>            </span><span>if let </span><span>Some(segment) = &amp;head.segment {
</span><span>                buffer.</span><span>push</span><span>(*segment);
</span><span>            }
</span><span>        }
</span><span>        </span><span>// Reverse the buffer to get the segments in the correct order
</span><span>        buffer.</span><span>reverse</span><span>();
</span><span>        buffer
</span><span>    }
</span><span>}
</span></code></pre>
<p>Now we can replace <code>&amp;mut Vec</code>:</p>
<pre data-lang="rust"><code data-lang="rust"><span>fn </span><span>validate</span><span>(&amp;</span><span>self</span><span>, </span><span>instance</span><span>: &amp;Value) -&gt; ValidationResult {
</span><span>    </span><span>self</span><span>.node.</span><span>validate</span><span>(instance, JsonPointerNode::new())
</span><span>}
</span><span>
</span><span>trait </span><span>Node {
</span><span>    </span><span>fn </span><span>validate</span><span>&lt;</span><span>&#39;a</span><span>&gt;(
</span><span>        &amp;</span><span>self</span><span>,
</span><span>        </span><span>instance</span><span>: &amp;</span><span>&#39;a</span><span> Value,
</span><span>        </span><span>path</span><span>: JsonPointerNode&lt;</span><span>&#39;a</span><span>, &#39;_&gt;,
</span><span>    ) -&gt; ValidationResult;
</span><span>}
</span><span>
</span><span>impl </span><span>Node </span><span>for </span><span>Properties {
</span><span>    </span><span>fn </span><span>validate</span><span>&lt;</span><span>&#39;a</span><span>&gt;(
</span><span>        &amp;</span><span>self</span><span>,
</span><span>        </span><span>instance</span><span>: &amp;</span><span>&#39;a</span><span> Value,
</span><span>        </span><span>path</span><span>: JsonPointerNode&lt;</span><span>&#39;a</span><span>, &#39;_&gt;,
</span><span>    ) -&gt; ValidationResult {
</span><span>        </span><span>// ...
</span><span>                    value.</span><span>validate</span><span>(instance, path.</span><span>push</span><span>(key.</span><span>as_str</span><span>()))?;
</span><span>        </span><span>// ...
</span><span>}
</span><span>
</span><span>impl </span><span>Node </span><span>for </span><span>Type {
</span><span>    </span><span>fn </span><span>validate</span><span>&lt;</span><span>&#39;a</span><span>&gt;(
</span><span>        &amp;</span><span>self</span><span>,
</span><span>        </span><span>instance</span><span>: &amp;</span><span>&#39;a</span><span> Value,
</span><span>        </span><span>path</span><span>: JsonPointerNode&lt;</span><span>&#39;a</span><span>, &#39;_&gt;,
</span><span>    ) -&gt; ValidationResult {
</span><span>        </span><span>match </span><span>(</span><span>self</span><span>, instance) {
</span><span>            </span><span>// ... Compare `instance` type with expected type
</span><span>            _ =&gt; Err(ValidationError::new(
</span><span>                format!(&#34;</span><span>{instance}</span><span> is not of type &#39;</span><span>{self}</span><span>&#39;</span><span>&#34;),
</span><span>                path.</span><span>to_vec</span><span>().</span><span>into_iter</span><span>(),
</span><span>            )),
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>No heap allocations during traversal! Does it help?</p>
<table>
  <thead>
    <tr>
      <th rowspan="2">Commit</th>
      <th colspan="3">Valid</th>
      <th colspan="3">Invalid</th>
    </tr>
    <tr>
      <th>0</th>
      <th>5</th>
      <th>10</th>
      <th>0</th>
      <th>5</th>
      <th>10</th>
    </tr>
  </thead>
  <tbody>
<tr>
  <td><a href="https://github.com/Stranger6667/article-linked-lists/commit/91ec92c757d3948a2a032a55d035e6fadc63fdcf" target="_blank">91ec92c</a></td>
  <td>35.0 µs</td>
  <td>663.5 µs</td>
  <td>1.32 ms</td>
  <td>958.9 µs</td>
  <td>2.54 ms</td>
  <td>4.58 ms</td>
</tr>
  </tbody>
</table>
<p>Woah! That is significantly better for valid inputs! Invalid ones are roughly the same, however, we have not optimized the linked list implementation yet.</p>
<p>In our case, we are leveraging the fact, that the path is only needed when an error occurs. This allows us to avoid the overhead of maintaining the path during the entire traversal process and heap allocate only when necessary.</p>
<blockquote>
<p>Note that linked lists have worse cache locality compared to vectors, which can lead to slower performance in some scenarios.</p>
</blockquote>
<h2 id="idea-4-precise-memory-allocation">Idea 4: Precise memory allocation</h2>
<p>Let&#39;s find out why the linked list implementation is not as performant for invalid inputs by looking at <code>JsonPointerNode</code> first:</p>

  <p><img src="https://dygalo.dev/blog/linked-list-invalid-10.png"/></p><p>Apparently, the problem is in memory reallocations inside <code>JsonPointerNode::to_vec</code>. We can avoid them by allocating the exact amount of memory needed. This will require an extra linked list traversal to calculate the capacity, but the performance gain from avoiding reallocations outweighs the cost of the extra traversal:</p>
<pre data-lang="rust"><code data-lang="rust"><span>impl</span><span>&lt;</span><span>&#39;a</span><span>, </span><span>&#39;b</span><span>&gt; JsonPointerNode&lt;</span><span>&#39;a</span><span>, </span><span>&#39;b</span><span>&gt; {
</span><span>    </span><span>pub</span><span>(</span><span>crate</span><span>) </span><span>fn </span><span>to_vec</span><span>(&amp;</span><span>&#39;a </span><span>self</span><span>) -&gt; Vec&lt;&amp;</span><span>&#39;a str</span><span>&gt; {
</span><span>        </span><span>// Walk the linked list to calculate the capacity
</span><span>        </span><span>let mut</span><span> capacity = </span><span>0</span><span>;
</span><span>        </span><span>let mut</span><span> head = </span><span>self</span><span>;
</span><span>        </span><span>while let </span><span>Some(next) = head.parent {
</span><span>            head = next;
</span><span>            capacity += </span><span>1</span><span>;
</span><span>        }
</span><span>        </span><span>// Callect the segments from the head to the tail
</span><span>        </span><span>let mut</span><span> buffer = Vec::with_capacity(capacity);
</span><span>        </span><span>let mut</span><span> head = </span><span>self</span><span>;
</span><span>        </span><span>if let </span><span>Some(segment) = &amp;head.segment {
</span><span>            buffer.</span><span>push</span><span>(*segment);
</span><span>        }
</span><span>        </span><span>while let </span><span>Some(next) = head.parent {
</span><span>            head = next;
</span><span>            </span><span>if let </span><span>Some(segment) = &amp;head.segment {
</span><span>                buffer.</span><span>push</span><span>(*segment);
</span><span>            }
</span><span>        }
</span><span>        </span><span>// Reverse the buffer to get the segments in the correct order
</span><span>        buffer.</span><span>reverse</span><span>();
</span><span>        buffer
</span><span>    }
</span><span>}
</span></code></pre>
<table>
  <thead>
    <tr>
      <th rowspan="2">Commit</th>
      <th colspan="3">Valid</th>
      <th colspan="3">Invalid</th>
    </tr>
    <tr>
      <th>0</th>
      <th>5</th>
      <th>10</th>
      <th>0</th>
      <th>5</th>
      <th>10</th>
    </tr>
  </thead>
  <tbody>
<tr>
  <td><a href="https://github.com/Stranger6667/article-linked-lists/commit/10ae4f100935c757bb7707defcf122c179aee2dc" target="_blank">10ae4f1</a></td>
  <td>39.1 µs</td>
  <td>667.9 µs</td>
  <td>1.30 ms</td>
  <td>899.7 µs</td>
  <td>1.96 ms</td>
  <td>3.49 ms</td>
</tr>
  </tbody>
</table>
<p>Great! Precise memory allocation improves performance for invalid inputs, bringing it closer to the performance of valid ones.
Allocate exactly as needed, whenever possible, to avoid the overhead of memory reallocations.</p>
<h2 id="idea-5-avoid-temporary-vec">Idea 5: Avoid temporary <code>Vec</code></h2>
<p>At this point, the most significant slowdown is for invalid cases. If we take a closer look at the <code>ValidationError</code> implementation we’ll see the <code>collect</code> call, which means that first, we build <code>Vec&lt;&amp;str&gt;</code> in <code>JsonPointerNode::to_vec</code> and then almost immediately build <code>Vec&lt;String&gt;</code> from it, which means allocating <code>Vec</code> twice. Why don’t we just build <code>Vec&lt;String&gt;</code> in the first place:</p>
<pre data-lang="rust"><code data-lang="rust"><span>impl </span><span>ValidationError {
</span><span>    </span><span>fn </span><span>new</span><span>(</span><span>message</span><span>: impl Into&lt;String&gt;, </span><span>location</span><span>: Vec&lt;String&gt;) -&gt; </span><span>Self </span><span>{
</span><span>        </span><span>Self </span><span>{
</span><span>            message: message.</span><span>into</span><span>(),
</span><span>            location,
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span>impl </span><span>Node </span><span>for </span><span>Type {
</span><span>    </span><span>fn </span><span>validate</span><span>&lt;</span><span>&#39;a</span><span>&gt;(
</span><span>        &amp;</span><span>self</span><span>,
</span><span>        </span><span>instance</span><span>: &amp;</span><span>&#39;a</span><span> Value,
</span><span>        </span><span>path</span><span>: JsonPointerNode&lt;</span><span>&#39;a</span><span>, &#39;_&gt;,
</span><span>    ) -&gt; ValidationResult {
</span><span>        </span><span>match </span><span>(</span><span>self</span><span>, instance) {
</span><span>            </span><span>// ... Compare `instance` type with expected type
</span><span>            _ =&gt; Err(ValidationError::new(
</span><span>                format!(&#34;</span><span>{instance}</span><span> is not of type &#39;</span><span>{self}</span><span>&#39;</span><span>&#34;),
</span><span>                path.</span><span>to_vec</span><span>(),
</span><span>            )),
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span>impl</span><span>&lt;</span><span>&#39;a</span><span>, </span><span>&#39;b</span><span>&gt; JsonPointerNode&lt;</span><span>&#39;a</span><span>, </span><span>&#39;b</span><span>&gt; {
</span><span>    </span><span>pub</span><span>(</span><span>crate</span><span>) </span><span>fn </span><span>to_vec</span><span>(&amp;</span><span>self</span><span>) -&gt; Vec&lt;String&gt; {
</span><span>        </span><span>// ...
</span><span>        </span><span>if let </span><span>Some(segment) = &amp;head.segment {
</span><span>            buffer.</span><span>push</span><span>((*segment).</span><span>to_string</span><span>());
</span><span>        }
</span><span>        </span><span>while let </span><span>Some(next) = head.parent {
</span><span>            head = next;
</span><span>            </span><span>if let </span><span>Some(segment) = &amp;head.segment {
</span><span>                buffer.</span><span>push</span><span>((*segment).</span><span>to_string</span><span>());
</span><span>            }
</span><span>        }
</span><span>        </span><span>// ...
</span><span>    }
</span><span>}
</span></code></pre>
<p>This optimization leads to a visible performance improvement for invalid cases:</p>
<table>
  <thead>
    <tr>
      <th rowspan="2">Commit</th>
      <th colspan="3">Valid</th>
      <th colspan="3">Invalid</th>
    </tr>
    <tr>
      <th>0</th>
      <th>5</th>
      <th>10</th>
      <th>0</th>
      <th>5</th>
      <th>10</th>
    </tr>
  </thead>
  <tbody>
<tr>
  <td><a href="https://github.com/Stranger6667/article-linked-lists/commit/d3d2182e00aba996134475b90e87d565dfe47ac3" target="_blank">d3d2182</a></td>
  <td>39.7 µs</td>
  <td>652.3 µs</td>
  <td>1.35 ms</td>
  <td>765.1 µs</td>
  <td>1.83 ms</td>
  <td>3.33 ms</td>
</tr>
  </tbody>
</table>
<h2 id="idea-6-struct-size-optimization">Idea 6: Struct size optimization</h2>
<p>Sometimes it is worth trying to reduce struct sizes, especially when the struct is passed by value frequently. 
Smaller structs lead to less memory usage and faster function calls, as less data needs to be copied on the stack.</p>
<p>If we were to track not only keys in JSON objects but also indexes in arrays, we would need to use an enum like this:</p>
<pre data-lang="rust"><code data-lang="rust"><span>enum </span><span>Segment&lt;&#39;a&gt; {
</span><span>    </span><span>/// Property name within a JSON object.
</span><span>    Property(&amp;</span><span>&#39;a str</span><span>),
</span><span>    </span><span>/// Index within a JSON array.
</span><span>    Index(</span><span>usize</span><span>),
</span><span>}
</span><span>
</span><span>struct </span><span>JsonPointerNode&lt;</span><span>&#39;a</span><span>, </span><span>&#39;b</span><span>&gt; {
</span><span>    </span><span>segment</span><span>: Option&lt;Segment&lt;</span><span>&#39;a</span><span>&gt;&gt;,
</span><span>    </span><span>parent</span><span>: Option&lt;&amp;</span><span>&#39;b </span><span>JsonPointerNode&lt;</span><span>&#39;a</span><span>, </span><span>&#39;b</span><span>&gt;&gt;,
</span><span>}
</span></code></pre>
<p>Then, the <code>JsonPointerNode</code> struct would occupy 32 bytes:</p>
<pre data-lang="rust"><code data-lang="rust"><span>assert_eq!(std::mem::size_of::&lt;JsonPointerNode&gt;(), </span><span>32</span><span>);
</span></code></pre>
<p>However, by avoiding <code>Option</code> in the <code>segment</code> field, we can reduce its size to 24 bytes. The idea is to put some cheap value in the root node and never read it:</p>
<pre data-lang="rust"><code data-lang="rust"><span>struct </span><span>JsonPointerNode&lt;</span><span>&#39;a</span><span>, </span><span>&#39;b</span><span>&gt; {
</span><span>    </span><span>segment</span><span>: Segment&lt;</span><span>&#39;a</span><span>&gt;,
</span><span>    </span><span>parent</span><span>: Option&lt;&amp;</span><span>&#39;b </span><span>JsonPointerNode&lt;</span><span>&#39;a</span><span>, </span><span>&#39;b</span><span>&gt;&gt;,
</span><span>}
</span><span>impl</span><span>&lt;</span><span>&#39;a</span><span>, </span><span>&#39;b</span><span>&gt; JsonPointerNode&lt;</span><span>&#39;a</span><span>, </span><span>&#39;b</span><span>&gt; {
</span><span>    </span><span>/// Create a root node of a JSON pointer.
</span><span>    </span><span>const fn </span><span>new</span><span>() -&gt; </span><span>Self </span><span>{
</span><span>        JsonPointerNode {
</span><span>            </span><span>// The value does not matter, it will never be used
</span><span>            segment: Segment::Index(</span><span>0</span><span>),
</span><span>            parent: None,
</span><span>        }
</span><span>    }
</span><span>   </span><span>fn </span><span>push</span><span>(&amp;</span><span>&#39;a </span><span>self</span><span>, </span><span>segment</span><span>: Segment&lt;</span><span>&#39;a</span><span>&gt;) -&gt; JsonPointerNode&lt;</span><span>&#39;a</span><span>, </span><span>&#39;b</span><span>&gt; {
</span><span>        JsonPointerNode {
</span><span>            segment,
</span><span>            parent: Some(</span><span>self</span><span>),
</span><span>        }
</span><span>    }
</span><span>    </span><span>/// Convert the JSON pointer node to a vector of path segments.
</span><span>    </span><span>pub</span><span>(</span><span>crate</span><span>) </span><span>fn </span><span>to_vec</span><span>(&amp;</span><span>self</span><span>) -&gt; Vec&lt;String&gt; {
</span><span>        </span><span>// ...
</span><span>        </span><span>if</span><span> head.parent.</span><span>is_some</span><span>() {
</span><span>            buffer.</span><span>push</span><span>(head.segment.</span><span>to_string</span><span>())
</span><span>        }
</span><span>        </span><span>while let </span><span>Some(next) = head.parent {
</span><span>            head = next;
</span><span>            </span><span>if</span><span> head.parent.</span><span>is_some</span><span>() {
</span><span>                buffer.</span><span>push</span><span>(head.segment.</span><span>to_string</span><span>());
</span><span>            }
</span><span>        }
</span><span>        </span><span>// ...
</span><span>    }
</span><span>}
</span></code></pre>
<p>This technique is directly used in the <a href="https://github.com/Stranger6667/jsonschema-rs" target="_blank">jsonschema</a> crate to reduce the size of the <code>JsonPointerNode</code> struct, but not used here for simplicity.</p>
<h2 id="more-ideas-that-didn-t-make-it">More ideas that didn&#39;t make it</h2>
<p>I think that we can also gain a bit more performance by avoiding the <code>reverse</code> call in <code>JsonPointerNode::to_vec</code>, as it moves the data around. One way to achieve this is by assigning segments starting from the back of a vector filled with default values. However, the extra bookeeping needed for writing in the reverse order could outweigh the gains, so it&#39;s important to profile and benchmark any changes to ensure they provide measurable benefits for your use case.</p>
<p>Another idea is to store references to path segments inside <code>ValidationError</code> instead of cloning the strings:</p>
<pre data-lang="rust"><code data-lang="rust"><span>struct </span><span>ValidationError&lt;</span><span>&#39;a</span><span>&gt; {
</span><span>    </span><span>message</span><span>: String,
</span><span>    </span><span>location</span><span>: Vec&lt;&amp;</span><span>&#39;a str</span><span>&gt;,
</span><span>}
</span></code></pre>
<p>This way, we can avoid cloning the path segments and instead store references to them. This could lead to performance improvements, especially when dealing with long paths or large numbers of errors. However, this approach would make <code>ValidationError</code> less flexible, as it would be tied to the lifetime of the input JSON data.</p>
<h2 id="bonus-idea-maybe-you-don-t-need-a-linked-list">Bonus idea: Maybe you don&#39;t need a linked list?</h2>
<p>This idea was suggested by <a href="https://github.com/kobzol" target="_blank">@Kobzol</a>, who noted that the error path could be collected lazily from the call stack in the error propagation path. I&#39;ve implemented the idea based on the suggestion and the original code snippet:</p>
<pre data-lang="rust"><code data-lang="rust"><span>impl </span><span>ValidationError {
</span><span>    </span><span>pub</span><span>(</span><span>crate</span><span>) </span><span>fn </span><span>push_segment</span><span>(&amp;</span><span>mut </span><span>self</span><span>, </span><span>segment</span><span>: String) {
</span><span>        </span><span>self</span><span>.location.</span><span>push</span><span>(segment);
</span><span>    }
</span><span>    </span><span>pub</span><span>(</span><span>crate</span><span>) </span><span>fn </span><span>finish</span><span>(</span><span>mut </span><span>self</span><span>) -&gt; ValidationError {
</span><span>        </span><span>self</span><span>.location.</span><span>reverse</span><span>();
</span><span>        </span><span>self
</span><span>    }
</span><span>}
</span><span>fn </span><span>validate</span><span>(&amp;</span><span>self</span><span>, </span><span>instance</span><span>: &amp;Value) -&gt; ValidationResult {
</span><span>    </span><span>if let </span><span>Err(error) = </span><span>self</span><span>.node.</span><span>validate</span><span>(instance, </span><span>0</span><span>) {
</span><span>        </span><span>// Reverse the path segments in the `finish` method
</span><span>        Err(error.</span><span>finish</span><span>())
</span><span>    } </span><span>else </span><span>{
</span><span>        Ok(())
</span><span>    }
</span><span>}
</span><span>
</span><span>impl </span><span>Node </span><span>for </span><span>Properties {
</span><span>    </span><span>fn </span><span>validate</span><span>(&amp;</span><span>self</span><span>, </span><span>instance</span><span>: &amp;Value, </span><span>level</span><span>: </span><span>u32</span><span>) -&gt; ValidationResult {
</span><span>        </span><span>// ... 
</span><span>            </span><span>for </span><span>(key, value) in &amp;</span><span>self</span><span>.properties {
</span><span>                </span><span>if let </span><span>Some(instance) = object.</span><span>get</span><span>(key) {
</span><span>                    </span><span>if let </span><span>Err(</span><span>mut</span><span> error) = value.</span><span>validate</span><span>(instance, level + </span><span>1</span><span>) {
</span><span>                        error.</span><span>push_segment</span><span>(key.</span><span>to_string</span><span>());
</span><span>                        </span><span>return </span><span>Err(error);
</span><span>        </span><span>// ...
</span><span>    }
</span><span>}
</span><span>
</span><span>impl </span><span>Node </span><span>for </span><span>Type {
</span><span>    </span><span>fn </span><span>validate</span><span>(&amp;</span><span>self</span><span>, </span><span>instance</span><span>: &amp;</span><span>&#39;a</span><span> Value, </span><span>level</span><span>: </span><span>u32</span><span>) -&gt; ValidationResult {
</span><span>        </span><span>// ...
</span><span>            _ =&gt; Err(ValidationError::new(
</span><span>                format!(&#34;</span><span>{instance}</span><span> is not of type &#39;</span><span>{self}</span><span>&#39;</span><span>&#34;),
</span><span>                Vec::with_capacity(level as </span><span>usize</span><span>)
</span><span>        </span><span>// ...
</span><span>    }
</span><span>}
</span></code></pre>
<p>However, I was not able to get a stable improvement in benchmarks yet :(</p>
<blockquote>
<p>Small improvement may come from the fact that we no longer use the <code>?</code> operator as it involves the <code>From/Into</code> conversion, but we only have a single error type and don&#39;t need to convert it. This is the reason why <code>serde</code> has its own <code>tri!</code> <a href="https://github.com/serde-rs/serde/blob/3202a6858a2802b5aba2fa5cf3ec8f203408db74/serde/src/lib.rs#L287" target="_blank">macro</a> that is used instead of <code>?</code>;</p>
</blockquote>
<h2 id="conclusion">Conclusion</h2>
<p>In the end, we achieved ~4.5x / ~2.2x improvements from the naive implementation for valid / invalid scenarios. Overall this feature adds 18% / 95% on top of the path-less version!</p>

  <p><img src="https://dygalo.dev/blog/performance-comparison.png"/></p><p>Some optimizations in this article may not seem immediately beneficial, especially if you already know where the bottlenecks are. However, exploring simpler optimizations can sometimes reveal unexpected opportunities for improvement. Even if an optimization doesn&#39;t directly pay off or even makes your code slower in some cases, it may open up new possibilities for further optimizations.</p>
<p><strong>Takeaways</strong>:</p>
<ol>
<li>A naive approach could be good enough</li>
<li>Try alternative data structures such as immutable <code>Vector</code></li>
<li>Consider simpler stdlib variations like <code>Arc</code></li>
<li>Look at the problem at different scales</li>
<li>Search for a data structure that fits your problem</li>
<li>Allocate exactly as needed and when necessary</li>
<li>Reduce the size of values you pass around a lot</li>
</ol>
<p>If you have any more ideas to improve this use case or have any suggestions, please let me know!</p>
<p>In the next article, I will dive into HTML trees and why you should try to build your own data structure for it.</p>
<p>Thank you for your attention!</p>
<p>Dmitry</p>

        </div></div>
  </body>
</html>
