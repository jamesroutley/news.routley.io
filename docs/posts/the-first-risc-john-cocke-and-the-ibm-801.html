<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://thechipletter.substack.com/p/the-first-risc-john-cocke-and-the">Original</a>
    <h1>The First RISC: John Cocke and the IBM 801</h1>
    
    <div id="readability-page-1" class="page"><div><div><article><div class=""><div><div dir="auto"><blockquote><p>A designer knows he has achieved perfection not when there is nothing left to add, but when there is nothing left to take away.</p></blockquote><p><em>Antoine de Saint-Exupery</em></p><p><a href="https://riscv.org" rel="">RISC-V</a><span> is taking over the universe. Perhaps. Well it’s going into space, at least, as part of a new NASA </span><a href="https://www.sifive.com/press/nasa-selects-sifive-and-makes-risc-v-the-go-to-ecosystem" rel="">probe</a><span>. It’s also coming to your </span><a href="https://arstechnica.com/gadgets/2022/07/first-risc-v-laptop-expected-to-ship-in-september/" rel="">laptop</a><span>, your </span><a href="https://www.eetimes.com/sifive-unveils-64-bit-risc-v-server-core/" rel="">server</a><span> and maybe your </span><a href="https://semianalysis.substack.com/p/sifive-powers-google-tpu-nasa-tenstorrent" rel="">iPhone</a><span>.</span></p><p>RISC-V is built on a number of ideas. That a single instruction set can be used in machines with widely differing capabilities. That an instruction set can be shared between many different companies. The idea of an ‘Open Source’ instruction set. And finally the concept of the Reduced Instruction Set Computer (RISC) itself.</p><p>The RISC idea has now been around for around fifty years and it’s been the subject of debate and a degree of controversy for much of that period. We can eavesdrop on the debate as far back as 1986 via an episode of The Computer Chronicles. David Patterson, one of the developers of RISC-V, and already a professor at University of California at Berkeley, is quizzed by Gary Kildall, creator of the CP/M operating system.</p><div id="youtube2-DIccm7H3OA0" data-attrs="{&#34;videoId&#34;:&#34;DIccm7H3OA0&#34;,&#34;startTime&#34;:&#34;296&#34;,&#34;endTime&#34;:null}"><p><iframe src="https://www.youtube-nocookie.com/embed/DIccm7H3OA0?start=296&amp;rel=0&amp;autoplay=0&amp;showinfo=0&amp;enablejsapi=0" frameborder="0" loading="lazy" gesture="media" allow="autoplay; fullscreen" allowautoplay="true" allowfullscreen="true" width="728" height="409"></iframe></p></div><p>(As an aside, the idea that Instruction Set Architectures could be the subject of informed debate on a TV show is just a little jaw dropping.) </p><p>Kildall asks Patterson about what makes RISC different:</p><blockquote><p>The idea is going towards simplicity, kind of going back to a small is beautiful philosophy.</p></blockquote><p>Joel Birnbaum, then of HP, explains RISC to the audience:</p><blockquote><p>… the notion is that computers spend most of their time … doing a few simple things and don’t do the complex things very often. So the notion is that if you do the simplest things as well as possible, and the complex things as infrequently as possible, then you might come out with a machine … that is more effective than those that pay the penalty of complexity across all the things that it does each of the times that it does it.</p></blockquote><p>There is a degree of skepticism though from the panelists Jan Lewis and George Morrow:</p><blockquote><p>The commercial applications have yet to prove that RISC is actually going to give us true performance increases.</p></blockquote><blockquote><p>On the negative side, we just seem to keep making new instruction sets. It’s like inventing a new typeface every time you want to say something.</p></blockquote><blockquote><p>The machines that are out there do need extensions… We’ve sort of evolved from RISC in the purest sense to RISC like architectures.</p></blockquote><p>There is also degree of confusion over what RISC actually means and whether ‘RISC machines’ really are RISC in practice. Lewis comments that:</p><blockquote><p>The concept is that you have very few instructions, I say fifty or less, George says 8 or less, each one using very few clock cycles … in fact the machines that are out there do need other things.</p></blockquote><p>Some of the debate seems familiar even today when the effectiveness of RISC and what it really means continues to be the subject of debate.</p><p>But where did the RISC idea come from? Joel Birnbaum had previously managed the project to develop the first RISC machine. This machine would not only pioneer RISC but also some of the key ideas in hardware and software in the years that followed. And that machine would come from an unlikely source: the maker of some of the most complex machines in the universe.</p><p>In the early 1970s, IBM’s mainframes dominated the market for more powerful computers. IBM had invested $5 billion in the development of System/360. 1970 saw the announcement of its successor, the System/370.</p><p>The S/370 had some very complex instructions. For example a single ‘EDIT’ instruction could manipulate strings, inserting commas or decimal points, and suppress leading zeros.</p><p>This complexity was, in part, due to the need to avoid slow memory accesses (to fetch instructions) slowing down program execution. A single instruction specifying a lot of activity would save the work needed to fetch several instructions.</p><p>Customers could choose from a range of S/360 or S/370 systems with varying prices and performance. Cheaper machines were made possible, in part, by extensive use of ‘microcode’ where instructions were broken down into smaller ‘microinstructions’. But decoding and executing these microinstructions took time and so slowed program execution. A typical S/370 instruction might take 20 or 30 microinstructions. </p><p>This approach worked well for IBM’s business. Customers with lower budgets could buy cheaper a machine. They then had the option to upgrade to a more expensive, but still compatible, machine.</p><p>But all was not entirely rosy in IBM’s mainframe business. Competition, in the shape of ‘plug compatible’ machines was emerging from the likes of Amdahl, founded by the former chief architect of the S/360.</p><p>So IBM again set off to design the next generation of mainframes. Dubbed ‘Future Systems’ or ‘FS’ it would make all previous architectures obsolete. Developed with a considerable degree of secrecy, FS machines would have even more complex instruction sets with more functionality implemented in microcode. The direction of travel for IBM’s most powerful systems was clear.</p><p>Meanwhile, in 1971 IBM was approached by the L. M. Ericsson (better known now as just Ericsson) telephone company with a proposal for a joint venture to build telephony systems that would compete with IBM’s great rival AT&amp;T.</p><p>So IBM’s engineers started to look at approaches that would work for the telephony system. After three months of intensive work teams from the two companies met at Claridge’s Hotel in London. In a late-night meeting, IBM’s team presented their ideas. The core of the IBM system was a simple but fast machine specially built to handle call switching. The go-ahead was given. </p><p>But the following morning at breakfast Ericsson had second thoughts. If IBM’s ideas worked that spelt trouble for Ericsson’s core business. The joint venture was off.</p><p>But did IBM need Ericsson? IBM felt that it could go it alone and take on AT&amp;T single-handedly. So IBM started a new company to develop digital telephony systems to take on AT&amp;T.</p><p>Again amongst the core ideas was a fast machine with simple instructions built specially to handle and switch large numbers of calls.</p><p>But IBM management thought the project was too risky with too long a period before it generated a return on the investment needed. So in 1975, once again, the project was abandoned.</p><p>But some of IBM’s engineers were convinced of the benefits of a simple yet powerful computer. So members of the project returned to IBM Research and started work to turn the ideas into a general-purpose computer.</p><p>The project consisted of about twenty engineers, initially managed by Joel Birnbaum. They worked out of building 801 at the Thomas J. Watson Research Centre in Yorktown. The machine had previously been known as ‘the telephone machine’ but this was soon changed to the number of the building where they were working.</p><p>The leading figure in the group was IBM Fellow John Cocke. Born in North Carolina, and with a PhD in Maths from Duke University, Cocke joined IBM in 1956. By 1975 he had huge experience in developing leading edge computer systems. He’d been deeply involved in the development of Stretch which was one of IBM’s biggest development projects before the S/360. He was also an expert on compilers and wrote a textbook on compiler construction.</p><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fcbc726a2-c38e-4a3f-92c2-e61b859732b8_750x990.jpeg" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fcbc726a2-c38e-4a3f-92c2-e61b859732b8_750x990.jpeg 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fcbc726a2-c38e-4a3f-92c2-e61b859732b8_750x990.jpeg 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fcbc726a2-c38e-4a3f-92c2-e61b859732b8_750x990.jpeg 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fcbc726a2-c38e-4a3f-92c2-e61b859732b8_750x990.jpeg 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fcbc726a2-c38e-4a3f-92c2-e61b859732b8_750x990.jpeg" width="750" height="990" data-attrs="{&#34;src&#34;:&#34;https://bucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com/public/images/cbc726a2-c38e-4a3f-92c2-e61b859732b8_750x990.jpeg&#34;,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:990,&#34;width&#34;:750,&#34;resizeWidth&#34;:null,&#34;bytes&#34;:105677,&#34;alt&#34;:null,&#34;title&#34;:null,&#34;type&#34;:&#34;image/jpeg&#34;,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;internalRedirect&#34;:null}" alt="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fcbc726a2-c38e-4a3f-92c2-e61b859732b8_750x990.jpeg 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fcbc726a2-c38e-4a3f-92c2-e61b859732b8_750x990.jpeg 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fcbc726a2-c38e-4a3f-92c2-e61b859732b8_750x990.jpeg 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fcbc726a2-c38e-4a3f-92c2-e61b859732b8_750x990.jpeg 1456w" sizes="100vw" loading="lazy"/></picture></div></a><figcaption>John Cocke with the IBM 801</figcaption></figure></div><p>Not only did Cocke have the experience, he had the creativity that the team needed to develop a radically different system. Quoting Birnbaum:</p><blockquote><p>John Cocke was the genius behind the machine. The smartest man I’ve ever known. The most creative man I’ve ever known … Really this was John’s project.</p></blockquote><p>Another colleague at IBM said of Cocke:</p><blockquote><p>We shouldn&#39;t let him out without bodyguards to take notes. Ten minutes of small talk with Cocke can be worth billions of dollars.</p></blockquote><p>A life-long chain smoker Cocke had an unconventional approach to working at IBM’s offices. Quoting some of Cocke’s colleagues.</p><blockquote><p>He would sort of go from one room to another, and from one lab to another, you know, spreading ideas and trailing cigarette ashes as he went along.</p></blockquote><blockquote><p>You can&#39;t predict what John will come up with. It will always be original, and it will often be brilliant.</p></blockquote><p>Cocke’s involvement in earlier projects had started to sow the seeds of doubt in his mind about the approach that IBM was taking in the design of its systems. </p><p>His intuition was that adding more complexity into the hardware, making the hardware ‘higher level’ with the use of microcode, was hurting the performance of IBM’s systems.</p><p>Cocke had been part of the team that had brought together the proposals for the system that was rejected by Ericsson. He would now be able to apply his ideas to the development of a completely new general-purpose system.</p><p>Cocke gave the 801 another name: ‘America’. Some later said it was because IBM would never cancel ‘America’. Cocke himself said it referred to a response to Queen Victoria during the first America’s Cup race. ‘Who is first?’ asked the Queen. ‘America’ came the response. ‘And who is second?’. ‘Madam there is no second’.</p><p>The project’s goal was to create a system that was significantly better than IBM’s uninspiring System/3 minicomputer. The underpowered System/3 was struggling to compete with Digital Equipment Corporation’s VAX minicomputer series.</p><p>Crucially, the team had the benefit of having extensive details of the pattern of execution of programs on the S/360 (known as ‘instruction traces’). This showed which instructions were being executed most often. To quote one of the team:</p><blockquote><p>It came as a surprise … that load, store, branch and a few simple register operations completely dominated the mix of instructions.</p></blockquote><p>Analysis of the more complex instructions, such as ‘Move Character’, showed something else. Often the amount of data manipulated was so small that using a small number of simpler instructions was faster.</p><p>This all supported Cocke’s intuition. So armed with this data on the S/360 the team were able to start designing the new system in earnest.</p><p>To make their new design work needed several features that would soon become part of the RISC philosophy. Not all of these ideas were new but this was the first time they had been brought together.</p><p>From the Control Data 6600 (the first ‘Supercomputer’ designed by Seymour Cray) the new machine would use a ‘load-store’ architecture. Simple ‘load’ or ‘store’ instructions would be the only way of accessing or changing memory. Gone were the ‘memory to memory’ instructions of the S/360.</p><p>This in turn helped the machine to implement a simple form of pipelining, where one instruction can be executed at the same time that the next instruction is being loaded from memory.</p><p>Then there was the introduction of an instruction cache. This helped to remove the penalty incurred in other systems as a result of delays in accessing memory to read instructions. The team reasoned that the S/360’s fast access to microcode could be replaced by fast access to an instruction cache.</p><p>Initially, the team simulated the 801 by running software on a S/370 mainframe:</p><blockquote><p>… the simulator was designed to simply translate each 801 instruction into 32 bytes of System/370 code which would implement the 801 instruction.</p></blockquote><p>This simulator ran at about one-tenth of the speed of the eventual hardware, fast enough to simulate real-world programs.</p><p>With a simulator available the team could start to develop software for the 801 before the hardware was working. They wanted to avoid the need for assembly language programming and to optimise the compiler generated code to make the most of the new hardware.</p><p>So the team also built a compiler for a new language called PL 0.8. The name was chosen because it was initially intended to be a large subset of IBM’s PL/1 language. Later the decimal point was removed and it became known as PL/8.</p><p>The key to making good use of the 801’s hardware was efficient use of the machine’s registers. Decisions in the PL 0.8 compiler on how to use registers (or register allocation) used an approach developed by the team called ‘graph coloring’.  Graph-coloring has described in a paper published by members of the 801 team in 1981 and has since become the most popular approach to register allocation.</p><p>As the compiler matured the team discovered that its output was not that different to that generated by S/370 compilers. The code wasn&#39;t, as they had feared, excessively long compared to the S/370 code.</p><p>So what did the 801 look like?</p><p>The 801 was a minicomputer rather than a microprocessor. It was built using ‘off the shelf’ logic chips manufactured by Motorola mounted onto several circuit boards. The boards were arranged in a semi-circle with connections at the centre, reducing the distance between components. In the picture above, John Cocke is leaning on some of the 801’s boards pointing outwards from the centre of the machine. </p><p><span>There were actually two versions of the 801 architecture. The first version had around 7600 logic gates</span><a id="footnote-anchor-1" href="#footnote-1" rel="">1</a><span> making it a &#39;large minicomputer&#39; by the standards of the day. Let’s look at this first version of the 801.</span></p><p>As planned the instructions were kept simple. There were no memory to memory instructions. Also gone were instructions that combined loading or storing data from memory with another operation. All these simple instructions were implemented without having use microcode.</p><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F9f82986c-cfab-4b5d-a827-c172ce15b4af_990x1236.png" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F9f82986c-cfab-4b5d-a827-c172ce15b4af_990x1236.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F9f82986c-cfab-4b5d-a827-c172ce15b4af_990x1236.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F9f82986c-cfab-4b5d-a827-c172ce15b4af_990x1236.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F9f82986c-cfab-4b5d-a827-c172ce15b4af_990x1236.png 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F9f82986c-cfab-4b5d-a827-c172ce15b4af_990x1236.png" width="990" height="1236" data-attrs="{&#34;src&#34;:&#34;https://bucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com/public/images/9f82986c-cfab-4b5d-a827-c172ce15b4af_990x1236.png&#34;,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:1236,&#34;width&#34;:990,&#34;resizeWidth&#34;:null,&#34;bytes&#34;:328215,&#34;alt&#34;:null,&#34;title&#34;:null,&#34;type&#34;:&#34;image/png&#34;,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;internalRedirect&#34;:null}" alt="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F9f82986c-cfab-4b5d-a827-c172ce15b4af_990x1236.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F9f82986c-cfab-4b5d-a827-c172ce15b4af_990x1236.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F9f82986c-cfab-4b5d-a827-c172ce15b4af_990x1236.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F9f82986c-cfab-4b5d-a827-c172ce15b4af_990x1236.png 1456w" sizes="100vw" loading="lazy"/></picture></div></a><figcaption>ASCII art Used to Show the architecture or the original 801</figcaption></figure></div><p>The original 801 had sixteen 24-bit registers, plus three special purpose registers including the program counter and the condition codes register. The register size was chosen to fit in with the planned memory address size of 16 megabytes.</p><p>Instructions were either 16 or 32 bits long. Longer instructions allowed for the inclusion of a sixteen-bit constant that could be added to the contents of registers.</p><p>The simplicity of the instruction set meant that a simple pipelined operation could be implemented. </p><p>Branches, where the program jumps to another location, posed a problem for pipelining though. So the 801 introduced ‘execute branch’ instructions (these would later become known as ‘delayed branches’). These allowed for another instruction to execute in parallel with the branch whether or not the branch was taken.</p><p>The use of a distinct instruction cache created its own set of issues. What if code wrote to an instruction location that was held in the cache, thus invalidating the contents of the cache? The team decided that ‘self modifying’ code was sufficiently rare to be dealt with in software.</p><blockquote><p>At that time it was widely accepted that a running program would not modify itself at execution time. Therefore, no mechanisms were added to ensure that stores into the instruction stream were immediately reflected in the instruction cache. Instead, the ability to void cache lines was added to the instruction set.</p></blockquote><p>Most 801 instructions could execute, as planned, in a single clock cycle. On average the machine could execute an instruction every 1.1 or 1.2 clock cycles.  </p><p>Later in the project it became clear that the cost of memory was falling rapidly and so the 16-megabyte limit was increased. Virtual memory was now seen as a necessity. This provided the opportunity for a thorough revision of the machine based on the team’s experience. So much so that it almost seems odd to use the same name for the two machines. </p><p>The second 801 had a uniform 32-bit instruction length. This simplified the instruction decode mechanism. It also made it easier to accommodate more registers and so these were doubled to 32. This in turn made the compiler more effective:</p><blockquote><p>… the additional 16 registers avoided most of the register-spilling code (code to store and reload registers) which resulted when register allocation failed in its initial attempt with the limitation of only 16 registers. As long as no spill-code was introduced, the compiler could easily outperform hand-coding.</p></blockquote><p>The new machine added some new instructions. These included a ‘rotator’ instruction which rotated the contents of one register and combined it with the contents of another. This allowed for rapid software floating-point routines, with a floating-point add now possible in as little as 20 machine cycles.</p><p>The team completed the original 801 machine in 1978.</p><p>As predicted, the 801 offered significantly better performance than more complex machines. When running ‘real world’ tests and compared against the IBM System/3, the new machine was significantly faster. Cocke had been vindicated.</p><p>But once again IBM’s management passed on turning the 801 into a full-blown commercial project to take on the VAX as originally intended.</p><p>By now the FS project to supersede the S/370 had also been abandoned. Its complex instruction set had been regarded as &#39;incomprehensible’ by some IBM engineers. The 801 team still seemed to sense though that they were swimming against the tide at IBM. George Radin, who worked on the project, had commented in a paper earlier:</p><blockquote><p>In some sense the 801 appears to be rushing in the opposite direction to the conventional wisdom of this field. Namely, everyone else is busy moving software into hardware and we are clearly moving hardware into software. Rather than consuming the projected cheaper, faster hardware, we are engaged in an effort to save circuits, cut path lengths and reduce functions at every level of the normal system hierarchy.</p></blockquote><p>The idea of making a machine to compete with the VAX was shelved. The 801 design would be used to handle input and output for the IBM 3090, the mainframe successor to S/370, and some other auxiliary processing tasks. Work on other machines using the RISC concept did continue within IBM, but without huge urgency. It would be outside IBM that the philosophy would rise to prominence.</p><p>Neither John Cocke nor the IBM team coined the term ‘Reduced Instruction Set Computer’. Joel Birnbaum and others would protest that the philosophy was actually about a ‘Reduced Complexity Instruction Set Computer’. RISC could be read as implying that it was all about reducing the number of instructions, which might be a by-product, but wasn&#39;t the underlying rationale. (The original 801, in fact, had over 120 instructions). But the acronym has stuck, leading to significant confusion over the years.</p><p>The term RISC came to be used first in the RISC-1 project led by David Patterson at U.C. Berkeley. Along with John Hennessy at Stanford University, Patterson and his students would pick up the RISC concept and build the first microprocessors using RISC principles. And that’s where our series goes next.</p><p>I faced a small challenge when writing about the 801. John Cocke and his ideas were clearly at the heart of the project, but his fingerprints are sometimes hard to find. He co-wrote some papers on RISC computing at IBM but it’s often hard to trace specific innovations directly back to him.</p><p>So it seemed appropriate to provide some evidence of Cocke’s talents and contribution. For that we can turn to a series of recollections about John Cocke by his former colleagues at IBM there is great video on YouTube. A small sample of the quotes:</p><blockquote><p>I used to go around, sort of follow him around, taking notes and trying to capture his brilliant ideas as they were bubbling forth.</p></blockquote><blockquote><p>Most of the modern concepts of compiler technology were concepts that John was responsible for seeding throughout universities and IBM.</p></blockquote><p>The video also includes some discussion (from around 13:45 onwards) of the 801 project.</p><div id="youtube2-eYwd30iWVvw" data-attrs="{&#34;videoId&#34;:&#34;eYwd30iWVvw&#34;,&#34;startTime&#34;:null,&#34;endTime&#34;:null}"><p><iframe src="https://www.youtube-nocookie.com/embed/eYwd30iWVvw?rel=0&amp;autoplay=0&amp;showinfo=0&amp;enablejsapi=0" frameborder="0" loading="lazy" gesture="media" allow="autoplay; fullscreen" allowautoplay="true" allowfullscreen="true" width="728" height="409"></iframe></p></div><p>Cocke was also honoured extensively for his work. He won the ACM Turing Award, the National Medal of Technology and the National Medal of Science in 1994 amongst many others. </p><div data-attrs="{&#34;url&#34;:&#34;https://thechipletter.substack.com/p/the-first-risc-john-cocke-and-the?utm_source=substack&amp;utm_medium=email&amp;utm_content=share&amp;action=share&#34;,&#34;text&#34;:&#34;Share&#34;}"><p>Thank you for reading The Chip Letter. This post is public so feel free to share it.</p><p data-attrs="{&#34;url&#34;:&#34;https://thechipletter.substack.com/p/the-first-risc-john-cocke-and-the?utm_source=substack&amp;utm_medium=email&amp;utm_content=share&amp;action=share&#34;,&#34;text&#34;:&#34;Share&#34;}"><a href="https://thechipletter.substack.com/p/the-first-risc-john-cocke-and-the?utm_source=substack&amp;utm_medium=email&amp;utm_content=share&amp;action=share" rel=""><span>Share</span></a></p></div><p>John Cocke with the IBM 801 </p><p>Published under fair use as per:</p><p>https://en.wikipedia.org/wiki/John_Cocke_(computer_scientist)#/media/File:John_Cocke_(computer_scientist).jpg</p></div></div></div></article></div></div></div>
  </body>
</html>
