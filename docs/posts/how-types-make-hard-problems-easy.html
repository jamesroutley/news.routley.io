<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mayhul.com/posts/type-driven-design/">Original</a>
    <h1>How types make hard problems easy</h1>
    
    <div id="readability-page-1" class="page"><div>  <p>Over the last couple years, my programming brain has become increasingly warped around types, functional programming principles &amp; Typescript. Most of it is influenced by the inordinate amount of time I’ve spent working on the Heartbeat codebase, a 300k+ line Typescript full-stack application that includes a React web app, a React Native mobile app and a Node.js server. My experience in this codebase has shown me that the more I lean into relying on the type system, the more I benefit.</p>
<p>Writing code in a codebase that has fully bought into types feels like cheating. I can often implement 80% of a new feature without ever running the code. I’ll start working on a large refactor that requires breaking an assumption made throughout the code &amp; quickly discover that the type system makes the change trivial. Simple features practically code themselves because typos are caught instantly and half my code is autocompleted. Nuanced questions from the support team about how a certain feature works can be answered with a quick Ctrl+F in the code even when little written documentation exists. Entire <em>categories</em> of bugs that I used to deal with have vanished.</p>
<p>I’ve come to think of the style of coding that enables this as Type Driven Development. Below is a loose collection of thoughts &amp; links to resources that have heavily influenced what type driven development means to me.</p>
<h3 id="1-let-the-types-flow">1) Let the types flow</h3>
<p>Investing in type safety is much more effective when types are able to flow across every surface of our application. In a simple full-stack application, the data flow typically looks like: database -&gt; server -&gt; client. Changing our database schema should cause us to see errors in our frontend code. By achieving this level of type interconnectedness, we can make changes to one side of our codebase and feel confident that the type system will inform us about the implications of that change, even if those implications are happening on a completely different side of the codebase.</p>
<p>Enabling our types to flow through the system usually means:</p>
<ol>
<li>Using the same language everywhere. Naturally, if we want to share type information as much as possible, we need to be using the same language. While not perfect, React Native and Node.Js are powerful for allowing us to use Typescript on mobile &amp; server-side.</li>
<li>Making sure that type information is properly preserved across network boundaries. Using a well-typed ORM such as Prisma or Drizzle. Using a typed framework for API calls such as tRPC.</li>
<li>Using a monorepo. We want changes in one part of the system to alert us about changes that need to made in other parts of the system, which doesn’t work when those other parts are in a different repo.</li>
<li>Using <code>any</code> very rarely. Nothing breaks the flow of types more than <code>any</code></li>
</ol>
<p>This can often times be the hard part. Letting the types flow entails doing a lot of work architecting the system in a way that allows for a completely closed loop. At Heartbeat, we’ve gone to <a href="https://mayhul.com/posts/hacking-prisma" rel="nofollow, noopener, noreferrer" target="_blank">extensive lengths</a> to make this flow as robust as possible. And sometimes doing this work can feel pointless because I’m knee-deep in arcane Typescript errors instead of working on a new feature. But for any codebase that’s going to be sticking around for a while, setting up good base-level infrastructure is invaluable.</p>
<h3 id="2-start-with-the-types">2) Start with the types</h3>
<p>Given that types act as a glue that tie the system together, the natural starting place for any new feature is the type definitions. The first thing I do when implementing a new feature is map out what are all the entities involved, what is their relationship, what properties do they have and how should they be represented as a type.</p>
<p>This video is a great example of this concept: <a href="https://www.youtube.com/watch?v=2JB1_e5wZmU" rel="nofollow, noopener, noreferrer" target="_blank">https://www.youtube.com/watch?v=2JB1_e5wZmU</a></p>
<p>Some key takeaways from the video:</p>
<p>a) type definitions are a great way to make sure that my understanding of the domain is aligned with reality. The process of writing these type definitions forces me to map out &amp; wrangle the different components of the project in a comprehensive way. Usually this process results in me discovering gaps or ambiguities in the feature spec that I can then hash with the rest of the team. Often times, these gaps/ambiguities are things that would otherwise go undiscovered until I’m halfway through the project. At which point resolving them might involve throwing away most of the work I’ve already done. Type driven development brings these questions up to the beginning of the process, gets them answered, and serves as a blueprint for the rest of the project.</p>
<p>b) type definitions are human-readable. They’re a great way for someone new (or me in the future) to get a high level understanding of how a feature is structured without having to dive into any actual code tracing.</p>
<p>c) type definitions are both a documentation of the domain model AND real code that is directly used by our implementation. They are a living document that is <em>guaranteed</em> to be an accurate reflection of the codebase.</p>
<p>d) an entity’s conceptual idea is more important than its representation. For example, an email address and a customer id are both <em>represented</em> by strings, but conceptually they are independent things and should not be considered the same type. This distinction should be reflected in our types.</p>
<h3 id="3-make-illegal-states-unrepresentable">3) Make illegal states unrepresentable</h3>
<p>Another key takeaway from the video that deserves it’s own section. Making our types reflect the true nature of the data as closely as possible makes it almost impossible to mess up. Some concrete examples of what this can look like in Typescript:</p>
<ol>
<li>We have <code>Product</code> entity. Every product must have at least one price associated with it:</li>
</ol>
<pre tabindex="0"><code><span></span>
<span><span>type</span><span> NonEmptyArray</span><span>&lt;</span><span>T</span><span>&gt; </span><span>=</span><span> [</span><span>T</span><span>, </span><span>...</span><span>T</span><span>[]];</span></span>
<span></span>
<span><span>type</span><span> Price</span><span> =</span><span> //something</span></span>
<span></span>
<span><span>interface</span><span> Product</span><span> {</span></span>
<span><span>	//...</span></span>
<span><span>    prices</span><span>:</span><span> NonEmptyArray</span><span>&lt;</span><span>Price</span><span>&gt;;</span></span>
<span><span>    //...</span></span>
<span><span>}</span></span>
<span></span>
<span><span>function</span><span> createProduct</span><span>(</span><span>product</span><span>:</span><span> Product</span><span>) {</span></span>
<span><span>   //...</span></span>
<span><span>}</span></span>
<span></span>
<span><span>//If I try to create a product with no prices, I get a type error</span></span>
<span><span>createProduct</span><span>({</span></span>
<span><span>	prices</span><span>:</span><span> [],</span></span>
<span><span>})</span></span></code></pre>
<ol start="2">
<li>Our users can optionally choose to give us their address:</li>
</ol>
<pre tabindex="0"><code><span><span>//Bad implemenation</span></span>
<span><span>type</span><span> User</span><span> =</span><span> {</span></span>
<span><span>	//...</span></span>
<span><span>	addressLine1</span><span>?:</span><span> string</span><span>;</span></span>
<span><span>	addressLine2</span><span>?:</span><span> string</span><span>;</span></span>
<span><span>	city</span><span>?:</span><span> string</span><span>;</span></span>
<span><span>	state</span><span>?:</span><span> string</span><span>;</span></span>
<span><span>	country</span><span>?:</span><span> string</span><span>;</span></span>
<span><span>	//...</span></span>
<span><span>};</span></span>
<span></span>
<span><span>function</span><span> createUser</span><span>(</span><span>user</span><span>:</span><span> User</span><span>) {</span></span>
<span><span>	//...</span></span>
<span><span>}</span></span>
<span></span>
<span><span>//It&#39;s possible for me to create a user &amp; forget to include parts of their address</span></span>
<span><span>createUser</span><span>({</span></span>
<span><span>	//...</span></span>
<span><span>	addressLine1</span><span>:</span><span> &#34;</span><span>123 Example St</span><span>&#34;</span><span>,</span></span>
<span><span>	//...</span></span>
<span><span>});</span></span>
<span></span>
<span><span>/*-------------------------------------------*/</span></span>
<span></span>
<span><span>//Good implemenation</span></span>
<span><span>type</span><span> User</span><span> =</span><span> {</span></span>
<span><span>	//...</span></span>
<span><span>	address</span><span>:</span><span> {</span></span>
<span><span>		line1</span><span>:</span><span> string</span><span>;</span></span>
<span><span>		line2</span><span>:</span><span> string</span><span>;</span></span>
<span><span>		city</span><span>:</span><span> string</span><span>;</span></span>
<span><span>		state</span><span>:</span><span> string</span><span>;</span></span>
<span><span>		country</span><span>:</span><span> string</span><span>;</span></span>
<span><span>	} </span><span>|</span><span> null</span><span>;</span></span>
<span><span>	//...</span></span>
<span><span>};</span></span>
<span></span>
<span><span>//The type system makes sure that we provide everything if we choose to</span></span>
<span><span>createUser</span><span>({</span></span>
<span><span>	//...</span></span>
<span><span>	address</span><span>:</span><span> {</span></span>
<span><span>		line1</span><span>:</span><span> &#34;</span><span>123 Example St</span><span>&#34;</span><span>,</span></span>
<span><span>		line2</span><span>:</span><span> &#34;</span><span>Apt 1D</span><span>&#34;</span><span>,</span></span>
<span><span>		city</span><span>:</span><span> &#34;</span><span>Seattle</span><span>&#34;</span><span>,</span></span>
<span><span>		state</span><span>:</span><span> &#34;</span><span>Washington</span><span>&#34;</span><span>,</span></span>
<span><span>		country</span><span>:</span><span> &#34;</span><span>USA</span><span>&#34;</span><span>,</span></span>
<span><span>	},</span></span>
<span><span>	//...</span></span>
<span><span>});</span></span></code></pre>
<p>Structuring our types in this way removes a complete category of bugs from ever occurring. Every single state that we make illegal via our type system was a bug waiting to happen in an alternate universe. Additionally, the <em>process</em> of making illegal states unrepresentable is valuable too. Making our types represent the “truth” as closely as possible forces us to ask a lot of questions about what the truth is.</p>
<ul>
<li>Are there cases where it makes sense for a product to have no prices?</li>
<li>How many possible states are there? Are state X and Y actually different, or are they essentially the same thing?</li>
</ul>
<p>And those questions are vital to understanding the full expanse of the problem we’re trying to solve.</p>
<h3 id="4-parse-dont-validate">4) Parse, don’t validate</h3>
<p>Reading this article crystalized so many loose thoughts that I had into a clean slogan: <a href="https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/" rel="nofollow, noopener, noreferrer" target="_blank">https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/</a>.</p>
<p>The key insight of the article is that types can be interpreted as a vehicle to “store” validation. Having validation work encoded in our types means that:</p>
<ul>
<li>the rest of our code is allowed to make assumptions about data without having to constantly validate those assumptions</li>
<li>the type system enforces that validation happens when needed</li>
<li>changing these assumptions is much easier. We can change the types to reflect a new assumption &amp; the type system will point us to the implications of this change</li>
</ul>
<p>(The only reason this section is so short is that the article explains things perfectly. Definitely go read it!)</p>
<h3 id="5-be-honest">5) Be honest</h3>
<p>In many ways, I’ve come to think of programming as <em>finding the truth</em>. The goal is to find the purest, rawest, deepest essence of what an entity represents and express that as a type. And if my goal is truth, then I need to value <em>being honest</em> in my code. This can manifest itself via “make illegal states unrepresentable” — I don’t want to <em>lie</em> and say that something is possible when it isn’t. Or, if I dive down and discover that two things I thought were the same are actually different, I shouldn’t <em>lie</em> and refer to them with the same type. I should do the extra work to split them into different types because that would be a more <em>honest</em> representation of the truth.</p>
<p>To contrast that grandiose description, here’s a mundane example. We have a calendar app where users can create events &amp; see a list of their events:</p>
<pre tabindex="0"><code><span></span>
<span><span>type</span><span> Event</span><span> =</span><span> {</span></span>
<span><span>  id</span><span>:</span><span> EventId</span><span>;</span></span>
<span><span>  title</span><span>:</span><span> string</span><span>;</span></span>
<span><span>  description</span><span>:</span><span> string</span><span>;</span></span>
<span><span>  startTime</span><span>:</span><span> Date</span><span>;</span></span>
<span><span>  endTime</span><span>:</span><span> Date</span><span>;</span></span>
<span><span>  duration</span><span>:</span><span> number</span><span>;</span></span>
<span><span>}</span></span>
<span></span>
<span><span>function</span><span> EventList</span><span>(</span><span>props</span><span>:</span><span> { events</span><span>:</span><span> Event</span><span>[] }) {</span></span>
<span><span>  return</span><span> (</span></span>
<span><span>    &lt;</span><span>div</span><span>&gt;</span></span>
<span><span>      &lt;</span><span>h1</span><span>&gt;My Events</span><span>&lt;/</span><span>h1</span><span>&gt;</span></span>
<span><span>      {</span><span>props</span><span>.</span><span>events</span><span>.</span><span>map</span><span>((</span><span>ev</span><span>) </span><span>=&gt;</span><span> (</span></span>
<span><span>        &lt;</span><span>EventListItem event</span><span>=</span><span>{ev} </span><span>/&gt;</span></span>
<span><span>      ))}</span></span>
<span><span>    &lt;/</span><span>div</span><span>&gt;</span></span>
<span><span>  )</span></span>
<span><span>}</span></span>
<span></span>
<span><span>function</span><span> EventListItem</span><span>(</span><span>props</span><span>:</span><span> { event</span><span>:</span><span> Event</span><span> }) {</span></span>
<span><span>  return</span><span> (</span></span>
<span><span>    &lt;</span><span>div</span><span>&gt;</span></span>
<span><span>      &lt;</span><span>h3</span><span>&gt;{props.event.name}</span><span>&lt;/</span><span>h3</span><span>&gt;</span></span>
<span><span>      &lt;</span><span>p</span><span>&gt;{props.event.description}</span><span>&lt;/</span><span>p</span><span>&gt;</span></span>
<span><span>      &lt;</span><span>p</span><span>&gt;</span><span>Start</span><span>:</span><span> {</span><span>props</span><span>.</span><span>event</span><span>.startTime}&lt;/</span><span>p</span><span>&gt;</span></span>
<span><span>      &lt;</span><span>p</span><span>&gt;</span><span>End</span><span>:</span><span> {</span><span>props</span><span>.</span><span>event</span><span>.endTime}&lt;/</span><span>p</span><span>&gt;</span></span>
<span><span>    &lt;/</span><span>div</span><span>&gt;</span></span>
<span><span>  )</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>We decide to add a new feature. Users can now create recurring events! Users define a recurring event using a <a href="https://icalendar.org/iCalendar-RFC-5545/3-8-5-3-recurrence-rule.html" rel="nofollow, noopener, noreferrer" target="_blank">recurrence rule</a>, which specifies when &amp; how often the event repeats. We want our event list to show all instances of upcoming recurring events. To do this we create a <code>getExpandedEvent</code> function which takes in an event. If the event is recurring, the event gets expanded to include all of the instances. Otherwise we return the single event. Once we create this function, all we need to do is call it in our <code>EventList</code> component and then we can continue as usual.</p>
<pre tabindex="0"><code><span></span>
<span><span>type</span><span> Event</span><span> =</span><span> {</span></span>
<span><span>  id</span><span>:</span><span> EventId</span><span>;</span></span>
<span><span>  title</span><span>:</span><span> string</span><span>;</span></span>
<span><span>  description</span><span>:</span><span> string</span><span>;</span></span>
<span><span>  startTime</span><span>:</span><span> Date</span><span>;</span></span>
<span><span>  endTime</span><span>:</span><span> Date</span><span>;</span></span>
<span><span>  duration</span><span>:</span><span> number</span><span>;</span></span>
<span><span>  //New field added</span></span>
<span><span>  recurrenceRule</span><span>:</span><span> string</span><span> |</span><span> null</span><span>;</span></span>
<span><span>}</span></span>
<span></span>
<span><span>function</span><span> getRecurringDates</span><span>(</span><span>startTime</span><span>:</span><span> Date</span><span>, </span><span>recurrenceRule</span><span>:</span><span> string</span><span>)</span><span>:</span><span> Date</span><span>[] {</span></span>
<span><span>  //calculate all the recurring dates according to the recurrence rule</span></span>
<span><span>}</span></span>
<span></span>
<span><span>function</span><span> getExpandedEvent</span><span>(</span><span>event</span><span>:</span><span> Event</span><span>)</span><span>:</span><span> Event</span><span>[] {</span></span>
<span><span>  if</span><span> (event.recurrenceRule </span><span>!==</span><span> null</span><span>) {</span></span>
<span><span>    const</span><span> recurringDates </span><span>=</span><span> getRecurringDates</span><span>(</span></span>
<span><span>      event.startTime,</span></span>
<span><span>      event.recurrenceRule</span></span>
<span><span>    )</span></span>
<span><span>    return</span><span> recurringDates.</span><span>map</span><span>((</span><span>date</span><span>) </span><span>=&gt;</span><span> ({</span></span>
<span><span>      ...</span><span>event,</span></span>
<span><span>      startTime</span><span>:</span><span> date,</span></span>
<span><span>    }))</span></span>
<span><span>  } </span><span>else</span><span> {</span></span>
<span><span>    return</span><span> [event]</span></span>
<span><span>  }</span></span>
<span><span>}</span></span>
<span></span>
<span><span>function</span><span> EventList</span><span>(</span><span>props</span><span>:</span><span> { events</span><span>:</span><span> Event</span><span>[] }) {</span></span>
<span><span>  const</span><span> expandedEvents </span><span>=</span><span> getExpandedEvent</span><span>(props.events).</span><span>flat</span><span>()</span></span>
<span></span>
<span><span>  return</span><span> (</span></span>
<span><span>    &lt;</span><span>div</span><span>&gt;</span></span>
<span><span>      &lt;</span><span>h1</span><span>&gt;My Events</span><span>&lt;/</span><span>h1</span><span>&gt;</span></span>
<span><span>      {</span><span>expandedEvents</span><span>.</span><span>map</span><span>((</span><span>ev</span><span>) </span><span>=&gt;</span><span> (</span></span>
<span><span>        &lt;</span><span>EventListItem event</span><span>=</span><span>{ev} </span><span>/&gt;</span></span>
<span><span>      ))}</span></span>
<span><span>    &lt;/</span><span>div</span><span>&gt;</span></span>
<span><span>  )</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>This works great. Users can see all their recurring events with no issues. A month later, we decide to finally add a button for users to delete their events. So we do something like this:</p>
<pre tabindex="0"><code><span></span>
<span><span>function</span><span> EventListItem</span><span>(</span><span>props</span><span>:</span><span> { event</span><span>:</span><span> Event</span><span> }) {</span></span>
<span><span>  //If you aren&#39;t familiar with tRPC, all you need to know is that deleteEvent.mutateAsync is a function that makes an API request to our server. On the server, we delete the event</span></span>
<span><span>  const</span><span> deleteEvent </span><span>=</span><span> trpc.deleteEvent.</span><span>useMutation</span><span>()</span></span>
<span></span>
<span><span>  return</span><span> (</span></span>
<span><span>    &lt;</span><span>div</span><span>&gt;</span></span>
<span><span>      &lt;</span><span>h3</span><span>&gt;{props.event.name}</span><span>&lt;/</span><span>h3</span><span>&gt;</span></span>
<span><span>      &lt;</span><span>p</span><span>&gt;{props.event.description}</span><span>&lt;/</span><span>p</span><span>&gt;</span></span>
<span><span>      &lt;</span><span>p</span><span>&gt;</span><span>Start</span><span>:</span><span> {</span><span>props</span><span>.</span><span>event</span><span>.startTime}&lt;/</span><span>p</span><span>&gt;</span></span>
<span><span>      &lt;</span><span>p</span><span>&gt;</span><span>End</span><span>:</span><span> {</span><span>props</span><span>.</span><span>event</span><span>.endTime}&lt;/</span><span>p</span><span>&gt;</span></span>
<span><span>      &lt;</span><span>button onClick</span><span>=</span><span>{() =&gt; deleteEvent.mutateAsync(props.event.id)}</span><span>&gt;</span><span>Delete</span><span>&lt;/</span><span>button</span><span>&gt;</span></span>
<span><span>    &lt;/</span><span>div</span><span>&gt;</span></span>
<span><span>  )</span></span>
<span><span>}</span></span>
<span></span>
<span></span></code></pre>
<p>Seems pretty straightforward, so we go ahead and ship it. Soon, the customer bug reports come in: “I was trying to delete the May instance of my monthly event, but the whole thing disappeared!?!?!” As you may have noticed, the issue with this implementation is that clicking delete on an instance of a recurring event will delete the entire event. Probably not the behavior that we want. There’s a couple things that went wrong to get here:</p>
<ul>
<li>Whoever was speccing the delete event feature should have called out how it should work for non-recurring vs recurring events</li>
<li>We probably would have realized this was weird if we had more tests or QA before releasing</li>
</ul>
<p>And while those might be true, I’d argue that one of the underlying reasons we got here was because we weren’t fully honest when we implemented the <code>getExpandedEvent</code> function. At the time, it was convenient to continue using the <code>Event</code> type. All we needed to do is call the function and everything else would remain the same. But if we were honest, we would have recognized that while very similar, events &amp; event instances are different concepts.</p>
<p>An <code>Event</code> is the core object that gets stored in the database. When someone creates a recurring event - say a meeting every Monday for a year - we don’t store 52 different events in the database. Instead, we store a single <code>Event</code> with a recurrence rule. Then, whenever someone needs to see their upcoming events, we use that rule to generate the appropriate <code>EventInstance</code>s, each representing one occurrence of the meeting. Events are stored in the database, while event instances are ephemeral. Events can be created, while event instances cannot. Editing an <code>Event</code> (changing the meeting from Mondays at 2pm to Mondays at 3pm) is a completely different action from editing an <code>EventInstance</code> (rescheduling just one specific Monday’s meeting to Tuesday). A more honest representation might look like this:</p>
<pre tabindex="0"><code><span><span>type</span><span> EventInstance</span><span> =</span><span> Omit</span><span>&lt;</span><span>Event</span><span>, </span><span>&#34;</span><span>id</span><span>&#34;</span><span>&gt; </span><span>&amp;</span><span> {</span></span>
<span><span>	id</span><span>:</span><span> EventInstanceId</span><span>;</span></span>
<span><span>	eventId</span><span>:</span><span> EventId</span><span>;</span></span>
<span><span>};</span></span>
<span></span>
<span><span>function</span><span> getEventInstanceId</span><span>(</span><span>eventId</span><span>:</span><span> EventId</span><span>, </span><span>startTime</span><span>:</span><span> Date</span><span>) {</span></span>
<span><span>	return</span><span> `</span><span>${</span><span>eventId</span><span>}</span><span>-</span><span>${</span><span>startTime.</span><span>toISOString</span><span>()</span><span>}</span><span>`</span><span> as</span><span> EventInstanceId</span><span>;</span></span>
<span><span>}</span></span>
<span></span>
<span><span>function</span><span> getEventInstances</span><span>(</span><span>event</span><span>:</span><span> Event</span><span>)</span><span>:</span><span> EventInstance</span><span>[] {</span></span>
<span><span>	if</span><span> (event.recurrenceRule </span><span>!==</span><span> null</span><span>) {</span></span>
<span><span>		const</span><span> recurringDates </span><span>=</span><span> getRecurringDates</span><span>(event.startTime, event.recurrenceRule);</span></span>
<span><span>		return</span><span> recurringDates.</span><span>map</span><span>((</span><span>date</span><span>) </span><span>=&gt;</span><span> ({</span></span>
<span><span>			...</span><span>event,</span></span>
<span><span>			startTime</span><span>:</span><span> date,</span></span>
<span><span>			id</span><span>:</span><span> getEventInstanceId</span><span>(event.id, date),</span></span>
<span><span>			eventId</span><span>:</span><span> event.id,</span></span>
<span><span>		}));</span></span>
<span><span>	} </span><span>else</span><span> {</span></span>
<span><span>		return</span><span> [</span></span>
<span><span>			{</span></span>
<span><span>				...</span><span>event,</span></span>
<span><span>				id</span><span>:</span><span> getEventInstanceId</span><span>(event.id, event.startTime),</span></span>
<span><span>				eventId</span><span>:</span><span> event.id,</span></span>
<span><span>			},</span></span>
<span><span>		];</span></span>
<span><span>	}</span></span>
<span><span>}</span></span>
<span></span>
<span><span>function</span><span> EventListItem</span><span>(</span><span>props</span><span>:</span><span> { eventInstance</span><span>:</span><span> EventInstance</span><span> }) {</span></span>
<span><span>	//Render event instance</span></span>
<span><span>}</span></span></code></pre>
<p>The exact implementation of <code>EventInstance</code> would vary depending on what behavior we wanted. But the key point is differentiating event instances from events. If we had done this we never would have ran into the deletion issue because it would be clear that the <code>deleteEvent</code> endpoint is not applicable to event instances. In fact, going back to <em>Start with the types</em>, the <code>EventInstance</code> type in our codebase likely would have made us realize during the feature speccing phase that we needed to handle deleting events and deleting event instances separately.</p>
<p>It’s easy to see why we wouldn’t want to make this change. It’s more work for no immediate payoff. Adding the new type requires changing <code>EventListItem</code> as well. In a larger project, the new type might require even more refactoring across the codebase. But by being lazy the first time, we introduced a subtle lie into our type system that corrupted it, causing it to deviate slightly from being a true representation of the underlying domain. This prevented the types from helping us when we needed them later.</p>
<h3 id="6-be-specific">6) Be specific</h3>
<p>A companion to being honest is being specific. We don’t want to lie by omission. So as much as possible, we want our types to be the narrowest possible expression of the truth.</p>
<p><a href="https://egghead.io/blog/using-branded-types-in-typescript" rel="nofollow, noopener, noreferrer" target="_blank">Branded types</a> are a great example of this. We <em>could</em> use a <code>string</code> to represent the id of a user and it would be an honest representation. But by using a branded <code>UserID</code> type instead, we can be even more specific about what a user id truly represents. And the more specific we are, the more the type checker is able to help us out:</p>
<pre tabindex="0"><code><span><span>type</span><span> CommunityID</span><span> =</span><span> string</span><span> &amp;</span><span> { </span><span>readonly</span><span> _</span><span>:</span><span> &#34;</span><span>__CommunityID__</span><span>&#34;</span><span> };</span></span>
<span><span>type</span><span> UserID</span><span> =</span><span> string</span><span> &amp;</span><span> { </span><span>readonly</span><span> _</span><span>:</span><span> &#34;</span><span>__UserID__</span><span>&#34;</span><span> };</span></span>
<span><span>type</span><span> PostID</span><span> =</span><span> string</span><span> &amp;</span><span> { </span><span>readonly</span><span> _</span><span>:</span><span> &#34;</span><span>__PostID__</span><span>&#34;</span><span> };</span></span>
<span></span>
<span><span>interface</span><span> Post</span><span> {</span></span>
<span><span>	id</span><span>:</span><span> PostID</span><span>;</span></span>
<span><span>	createdBy</span><span>:</span><span> UserID</span><span>;</span></span>
<span><span>	communityID</span><span>:</span><span> CommunityID</span><span>;</span></span>
<span><span>	//...</span></span>
<span><span>}</span></span>
<span></span>
<span><span>function</span><span> getIsUserAdmin</span><span>(</span><span>userID</span><span>:</span><span> UserID</span><span>) {</span></span>
<span><span>	//...</span></span>
<span><span>}</span></span>
<span></span>
<span><span>function</span><span> getShouldShowPost</span><span>(</span><span>post</span><span>:</span><span> Post</span><span>) {</span></span>
<span><span>	//If we accidentally call this function with the wrong id, we get a type error</span></span>
<span><span>	const</span><span> isAdmin </span><span>=</span><span> getIsUserAdmin</span><span>(post.communityID);</span></span>
<span></span>
<span><span>	const</span><span> isAdmin </span><span>=</span><span> getIsUserAdmin</span><span>(post.createdBy);</span></span>
<span></span>
<span><span>	//...</span></span>
<span><span>}</span></span></code></pre>
<h3 id="7-pure-functions-as-a-type-bridge">7) Pure functions as a type bridge</h3>
<p>Once you start to see everything in your codebase through the lens of types, any action a user takes can be reduced down to a series of type jumps. Define the starting types. Define the ending type. Find a way to go from the starting types to the ending type. What’s the best way to convert one type to another with no distractions? <strong>A pure function</strong>. That’s quite literally what the mathematical definition of a function is.</p>
<p>Let’s say that we’re implementing a payment page. Our domain looks like this:</p>
<pre tabindex="0"><code><span><span>type</span><span> Price</span><span> =</span><span> {</span></span>
<span><span>	id</span><span>:</span><span> PriceId</span><span>;</span></span>
<span><span>	amount</span><span>:</span><span> number</span><span>;</span></span>
<span><span>	interval</span><span>:</span><span> &#34;</span><span>month</span><span>&#34;</span><span> |</span><span> &#34;</span><span>year</span><span>&#34;</span><span>;</span></span>
<span><span>};</span></span>
<span></span>
<span><span>type</span><span> Product</span><span> =</span><span> {</span></span>
<span><span>	id</span><span>:</span><span> ProductId</span><span>;</span></span>
<span><span>	name</span><span>:</span><span> string</span><span>;</span></span>
<span><span>	prices</span><span>:</span><span> NonEmptyArray</span><span>&lt;</span><span>Price</span><span>&gt;;</span></span>
<span><span>};</span></span>
<span></span>
<span><span>type</span><span> Subscription</span><span> =</span><span> {</span></span>
<span><span>	id</span><span>:</span><span> SubscriptionId</span><span>;</span></span>
<span><span>	status</span><span>:</span><span> &#34;</span><span>active</span><span>&#34;</span><span> |</span><span> &#34;</span><span>canceled</span><span>&#34;</span><span>;</span></span>
<span><span>	productId</span><span>:</span><span> ProductId</span><span>;</span></span>
<span><span>	priceId</span><span>:</span><span> PriceId</span><span>;</span></span>
<span><span>};</span></span>
<span></span>
<span><span>type</span><span> User</span><span> =</span><span> {</span></span>
<span><span>	id</span><span>:</span><span> UserId</span><span>;</span></span>
<span><span>	subscriptions</span><span>:</span><span> Subscription</span><span>[];</span></span>
<span><span>};</span></span></code></pre>
<p>Our payment page has 3 different possibilities:</p>
<ol>
<li>The user has not purchased the product yet, in which they can choose a price point &amp; make the purchase</li>
<li>The user is currently subscribed, in which case we show a Cancel Subscription button. When the user clicks on this button:
<ul>
<li>If they’ve been a subscriber for more than 12 months, offer them a 1% discount for each month they’ve been a subscriber (capped at 50%)</li>
<li>Otherwise, offer them a flat $5 discount</li>
</ul>
</li>
<li>The user has canceled their subscription, in which case we prompt them to restart their subscription</li>
</ol>
<p>Representing this as a type, we get:</p>
<pre tabindex="0"><code><span><span>type</span><span> Discount</span><span> =</span></span>
<span><span>	|</span><span> {</span></span>
<span><span>			type</span><span>:</span><span> &#34;</span><span>PERCENTAGE</span><span>&#34;</span><span>;</span></span>
<span><span>			percentage</span><span>:</span><span> number</span><span>;</span></span>
<span><span>	  }</span></span>
<span><span>	|</span><span> {</span></span>
<span><span>			type</span><span>:</span><span> &#34;</span><span>FLAT_AMOUNT</span><span>&#34;</span><span>;</span></span>
<span><span>			amount</span><span>:</span><span> number</span><span>;</span></span>
<span><span>	  };</span></span>
<span></span>
<span><span>type</span><span> CheckoutPageState</span><span> =</span></span>
<span><span>	|</span><span> {</span></span>
<span><span>			type</span><span>:</span><span> &#34;</span><span>INITIAL_PURCHASE</span><span>&#34;</span><span>;</span></span>
<span><span>			product</span><span>:</span><span> Product</span><span>;</span></span>
<span><span>	  }</span></span>
<span><span>	|</span><span> {</span></span>
<span><span>			type</span><span>:</span><span> &#34;</span><span>CANCELED</span><span>&#34;</span><span>;</span></span>
<span><span>			subscriptionId</span><span>:</span><span> SubscriptionId</span><span>;</span></span>
<span><span>	  }</span></span>
<span><span>	|</span><span> {</span></span>
<span><span>			type</span><span>:</span><span> &#34;</span><span>ALREADY_SUBSCRIBED</span><span>&#34;</span><span>;</span></span>
<span><span>			product</span><span>:</span><span> Product</span><span>;</span></span>
<span><span>			cancelationDiscount</span><span>:</span><span> Discount</span><span>;</span></span>
<span><span>	  };</span></span></code></pre>
<p>A user visits the payment page for a particular product. We need to render the page. How do we do this? Well, given that we have these types established, the task at hand is clear. We need to convert a <code>Product</code> and a <code>User</code> into a <code>CheckoutPageState</code>. If the user has an active subscription, we need to convert a <code>Subscription</code> to a <code>Discount</code>. So…we write two pure functions to do the conversion &amp; we’re done.</p>
<pre tabindex="0"><code><span><span>//We pass in now as a parameter to make the function fully pure</span></span>
<span><span>//This makes testing the function easy</span></span>
<span><span>function</span><span> getDiscount</span><span>(</span><span>subscription</span><span>:</span><span> Subscription</span><span>, </span><span>now</span><span>:</span><span> Date</span><span>)</span><span>:</span><span> Discount</span><span> {</span></span>
<span><span>	const</span><span> numMonths </span><span>=</span><span> differenceInMonths</span><span>(now, subscription.createdAt);</span></span>
<span></span>
<span><span>	if</span><span> (numMonths </span><span>&gt;</span><span> 12</span><span>) {</span></span>
<span><span>		return</span><span> {</span></span>
<span><span>			type</span><span>:</span><span> &#34;</span><span>PERCENTAGE</span><span>&#34;</span><span>,</span></span>
<span><span>			percentage</span><span>:</span><span> Math.</span><span>min</span><span>(</span><span>50</span><span>, numMonths),</span></span>
<span><span>		};</span></span>
<span><span>	} </span><span>else</span><span> {</span></span>
<span><span>		return</span><span> {</span></span>
<span><span>			type</span><span>:</span><span> &#34;</span><span>FLAT_AMOUNT</span><span>&#34;</span><span>,</span></span>
<span><span>			amount</span><span>:</span><span> 5</span><span>,</span></span>
<span><span>		};</span></span>
<span><span>	}</span></span>
<span><span>}</span></span>
<span></span>
<span><span>function</span><span> getCheckoutPageState</span><span>(</span><span>product</span><span>:</span><span> Product</span><span>, </span><span>user</span><span>:</span><span> User</span><span>, </span><span>now</span><span>:</span><span> Date</span><span>)</span><span>:</span><span> CheckoutPageState</span><span> {</span></span>
<span><span>	const</span><span> existingSubscription </span><span>=</span><span> user.subscriptions.</span><span>find</span><span>((</span><span>x</span><span>) </span><span>=&gt;</span><span> x.productId </span><span>===</span><span> product.id);</span></span>
<span><span>	if</span><span> (existingSubscription </span><span>!==</span><span> undefined</span><span>) {</span></span>
<span><span>		if</span><span> (existingSubscription.status </span><span>===</span><span> &#34;</span><span>canceled</span><span>&#34;</span><span>) {</span></span>
<span><span>			return</span><span> {</span></span>
<span><span>				type</span><span>:</span><span> &#34;</span><span>CANCELED</span><span>&#34;</span><span>,</span></span>
<span><span>				subscriptionId</span><span>:</span><span> existingSubscription.id,</span></span>
<span><span>			};</span></span>
<span><span>		} </span><span>else</span><span> if</span><span> (existingSubscription.status </span><span>===</span><span> &#34;</span><span>active</span><span>&#34;</span><span>) {</span></span>
<span><span>			const</span><span> discount </span><span>=</span><span> getDiscount</span><span>(existingSubscription, now);</span></span>
<span><span>			return</span><span> {</span></span>
<span><span>				type</span><span>:</span><span> &#34;</span><span>ALREADY_SUBSCRIBED</span><span>&#34;</span><span>,</span></span>
<span><span>				product</span><span>:</span><span> product,</span></span>
<span><span>				cancelationDiscount</span><span>:</span><span> discount,</span></span>
<span><span>			};</span></span>
<span><span>		} </span><span>else</span><span> {</span></span>
<span><span>			assertNever</span><span>(existingSubscription.status);</span></span>
<span><span>		}</span></span>
<span><span>	} </span><span>else</span><span> {</span></span>
<span><span>		return</span><span> {</span></span>
<span><span>			type</span><span>:</span><span> &#34;</span><span>INITIAL_PURCHASE</span><span>&#34;</span><span>,</span></span>
<span><span>			product</span><span>:</span><span> product,</span></span>
<span><span>		};</span></span>
<span><span>	}</span></span>
<span><span>}</span></span>
<span></span>
<span><span>//***** CheckoutPage.tsx *****\\</span></span>
<span></span>
<span><span>function</span><span> CheckoutPage</span><span>(</span><span>props</span><span>:</span><span> CheckoutPageState</span><span>) {</span></span>
<span><span>	if</span><span> (props.type </span><span>===</span><span> &#34;</span><span>INITIAL_PURCHASE</span><span>&#34;</span><span>) {</span></span>
<span><span>		//render initial purchase</span></span>
<span><span>	} </span><span>else</span><span> if</span><span> (props.type </span><span>===</span><span> &#34;</span><span>ALREADY_SUBSCRIBED</span><span>&#34;</span><span>) {</span></span>
<span><span>		//render already subscribed</span></span>
<span><span>	} </span><span>else</span><span> if</span><span> (props.type </span><span>===</span><span> &#34;</span><span>CANCELED</span><span>&#34;</span><span>) {</span></span>
<span><span>		//render canceled</span></span>
<span><span>	} </span><span>else</span><span> {</span></span>
<span><span>		safeAssertNever</span><span>(props.type);</span></span>
<span><span>		return</span><span> null</span><span>;</span></span>
<span><span>	}</span></span>
<span><span>}</span></span></code></pre>
<p>Hopefully, you can imagine how this small example could expand to a production application with dozens of types &amp; hundreds of business logic rules encoded in a network of pure functions. The magic of pure functions is that they turn something intimidating into something approachable. We could have the gnarliest, most complicated domain with tons of intersecting edge cases and unintuitive logic. But if we’ve broken it down into the constituent types, then at any given moment all I need to worry about is converting <code>IntermediateType5</code> to <code>IntermediateType6</code>. I don’t need to think about anything else. That level of clarity &amp; focus does wonders for easing my mental burden while working on large project.</p>
<p>For a full-stack application, the pattern is simple:</p>
<ol>
<li>Define types for my core entities, the ones that get stored in the database (<code>Product</code>, <code>Price</code>, <code>User</code>, <code>Subscription</code>)</li>
<li>Define my intermediate types (<code>Discount</code>, <code>CheckoutPageState</code>)</li>
<li>Fetch the relevant core entities from the database</li>
<li>Run my entities through a series of pure functions, jumping from type to type, until I have a UI to show</li>
</ol>
<p>Even React, the final piece of the puzzle in this example, is built on functional programming principles. Our <code>CheckoutPage</code> React component is one last pure function that converts the <code>CheckoutPageState</code> type to JSX that gets rendered on the screen.</p>
<h3 id="8-ask-and-you-shall-receive">8) Ask and you shall receive</h3>
<p>One of the most common changes required by a new feature is something that used to be simple gets just <em>slightly</em> more nuanced. Before the feature, we call a function and it does the thing. But now, that function needs a little bit more context. And based on that context, it does something a little bit different. For example, let’s say we have a <code>generateInvoice</code> function that takes in various values and uses them to generate an <code>Invoice</code> object. The details of the function itself are irrelevant.</p>
<pre tabindex="0"><code><span><span>function</span><span> generateInvoice</span><span>(</span><span>params</span><span>:</span><span> {</span></span>
<span><span>	customerId</span><span>:</span><span> string</span><span>;</span></span>
<span><span>	currency</span><span>:</span><span> string</span><span>;</span></span>
<span><span>	items</span><span>:</span><span> InvoiceItem</span><span>[];</span></span>
<span><span>	//...</span></span>
<span><span>})</span><span>:</span><span> Invoice</span><span> {</span></span>
<span><span>	//Generate the invoice</span></span>
<span><span>}</span></span></code></pre>
<p>But now the time has finally come for us to stop ignoring the IRS’ emails and start properly collecting tax from our users. To do so, our invoices will need to look different depending on what the tax rate is.</p>
<p>With types, my approach for a change like this is straightforward. I go to the function that needs the additional context and I edit the input type to include the new context that I need. And then I see what type errors I get. If the function that’s calling <code>generateInvoice</code> doesn’t know what the <code>taxRate</code> should be, then I add <code>taxRate</code> to the input for that function and continue up the call stack. Eventually, I reach a function that is able to either pull the necessary context from a stateful source (a database, endpoint, etc) OR I’m able to calculate the necessary value and pass it in.</p>
<p>So in this case, let’s say I add the <code>taxRate</code> field to <code>params</code> and see the following two errors:</p>
<ol>
<li>One that’s happening on the backend when we call <code>generateInvoice</code> from <code>generateInvoiceForCustomer</code>. To fix it, I call <code>calculateTaxRateForCustomer</code> inside <code>generateInvoiceForCustomer</code> and pass the result of that function into <code>generateInvoice</code>.</li>
<li>One that’s happening on the frontend when we call <code>generateInvoice</code> from <code>previewInvoice</code>. In this case, we’re generating a preview invoice for a sample customer, so there’s no tax rate to be calculated. Instead, I just pass in a static value of <code>0.1</code> to use as the example tax rate.</li>
</ol>
<p>This approach saves a lot of time and headache. In a larger application, it’s possible that <code>generateInvoice</code> is being called from 7 different contexts. Rather than proactively trying to map out all of these different cases, I just tell the type system that I need a certain value and let it guide to me where I need to go next.</p>
<h3 id="9-if-it-compiles-it-works">9) If it compiles, it works</h3>
<p>Haskell developers have a refrain that if the code compiles, it probably works. While Haskell is on the extreme side of the spectrum, I’ve found this to also be quite true for any system that relies heavily on types. Having types embedded in our codebase means the feedback loop for our code comes directly from the editor &amp; type errors. I don’t need to run the code to see if I messed up, because my editor lets me know as I type.</p>
<p>There’s an inverse relationship between the expressiveness of the types and the number of possible programs that type check successfully. So when our types are honest &amp; specific, it can be hard to write code that type checks <em>without</em> doing what we want it do.</p>
<p>The best example of this is how productive I’ve become on airplanes. Despite being a full-stack application that needs Internet to run locally, I can get on a flight with no wifi, pull out my laptop &amp; implement a new Heartbeat feature with zero distractions — just me and my type checker. When I eventually land and run the code, I’m usually good to go after some UI work &amp; maybe 2-3 quick bug fixes.</p>
<h3 id="10-types-as-an-introspection-tool">10) Types as an introspection tool</h3>
<p>One of the most underrated aspects of Typescript is how it can be used as a tool to understand your codebase. If I’m trying to understand how a certain feature works, I can play around with the types to help me learn about how parts of that feature interact with the rest of the codebase.</p>
<p>For instance, let’s say I’m working on an update where I want to standardize how we can display prices in the product. Right now the only currency that we support is USD, and all of our prices are displayed like this: $100.00. But we’re getting some confusion from people in Canada about whether we’re referring to USD or CAD, so we want to update the UI to clarify that we mean USD. We show prices on a lot of different components in various contexts, so tracking down everything will be difficult.</p>
<p>What can I do is temporarily delete the <code>amount</code> field from the <code>Price</code> type:</p>
<pre tabindex="0"><code><span><span>type</span><span> Price</span><span> =</span><span> {</span></span>
<span><span>	id</span><span>:</span><span> PriceId</span><span>;</span></span>
<span><span>	interval</span><span>:</span><span> &#34;</span><span>month</span><span>&#34;</span><span> |</span><span> &#34;</span><span>year</span><span>&#34;</span><span>;</span></span>
<span><span>};</span></span></code></pre>
<p>Now, anywhere that I attempt to reference the <code>amount</code> field, I’ll get a type error instead. So if I have 10 different components that display a price in some way, Typescript will point me towards each of those components. I can go to each of them, make the changes I need to and undo the change I made to the type.</p>
<p>Or, let’s say we have a <code>Button</code> component in our design system and we’re considering getting rid of the <code>success</code> variant because it feels unnecessary. To help us make the decision, we want to identify all the screens in our product where we use a <code>success</code> button.</p>
<pre tabindex="0"><code><span><span>interface</span><span> Props</span><span> {</span></span>
<span><span>	//...</span></span>
<span><span>	variant</span><span>?:</span><span> &#34;</span><span>primary</span><span>&#34;</span><span> |</span><span> &#34;</span><span>secondary</span><span>&#34;</span><span> |</span><span> &#34;</span><span>success</span><span>&#34;</span><span>;</span></span>
<span><span>	//...</span></span>
<span><span>}</span></span>
<span></span>
<span><span>function</span><span> Button</span><span>(</span><span>props</span><span>:</span><span> Props</span><span>) {</span></span>
<span><span>	//button</span></span>
<span><span>}</span></span></code></pre>
<p>I <em>could</em> do a Ctrl-F for <code>success</code> and try to find examples that way — but predictably it will lead to lots of unrelated results popping up. My approach in these situations is to just delete <code>success</code> as one of the options in <code>Props</code>. By doing this, I’ll immediately get type errors that point me to the exact location of every success button in the product. From there, I can click through the results and evaluate whether the <code>success</code> button is necessary or if it can be replaced with an alternative. The ability to quickly answer questions like “Where does every success button in our product live?” means that I can even use the codebase as a tool in design/product planning meetings.</p>
<h3 id="11-hard-mode-and-easy-mode">11) Hard mode and easy mode</h3>
<p>Using types extensively splits coding into 2 phases. A short period of intense &amp; difficult work followed by a longer period of straightforward work that’s hard to mess up.</p>
<p>The hard part is setting up the scaffolding &amp; defining the types. In Typescript, scaffolding can involve delving into arcane type-level programming or setting up complex frameworks to make sure that types are propagated robustly. As we’ve talked about above, defining types involves deep rumination to figure out what states are valid, how to be honest, where to draw the line between entities, etc. Figuring all of this out can be intimidating and cumbersome.</p>
<p>But, the hard work pays off because coding with types on is astoundingly EASY. The editor is constantly guiding me down the right path. Typos, misused variables, forgotten validation checks are all caught instantly. Autocomplete means I don’t even need to type that much. In the age of AI code completion, type definitions provide a valuable source of documentation to help the AI provide more accurate suggestions. And the type checker makes it harder for invalid AI-suggested code to go unnoticed.</p>
<p>This dichotomy gels really well with the way my brain works. I’m able to channel short bursts of creative energy into precisely mapping the domain or getting type scaffolding set up. And then I’m able to sustain long coding sessions to actually implement the feature because the scaffolding means I rarely have to think too hard.</p>
<h3 id="12-know-when-to-opt-out">12) Know when to opt out</h3>
<p>This one might be controversial for some — but I really like that Typescript allows us to cheat every now and then. Knowing when it’s ok to throw our hands up and use an <code>any</code> is important. If we’re thoughtful, we can maintain 99.9% of the benefits of the type system without wasting days trying to cover the last 0.1%.</p>
<p>Typically using <code>any</code> or type assertions such as <code>as string</code> are a bad idea because they’re a form of lying to the type system. But in situations where we genuinely know better than the type system and the scope of the assertion is small, a small lie is acceptable. A common time where we might know better than the type system is when dealing with external dependencies or legacy code. For example, this is the helper function we use for getting feature flags from Posthog:</p>
<pre tabindex="0"><code><span><span>export</span><span> const</span><span> POSTHOG_FLAGS </span><span>=</span><span> {</span></span>
<span><span>	&#34;</span><span>longer-free-trial</span><span>&#34;</span><span>:</span><span> [</span><span>&#34;</span><span>control</span><span>&#34;</span><span>, </span><span>&#34;</span><span>30-days</span><span>&#34;</span><span>],</span></span>
<span><span>	&#34;</span><span>checkout-page-design</span><span>&#34;</span><span>:</span><span> [</span><span>&#34;</span><span>control</span><span>&#34;</span><span>, </span><span>&#34;</span><span>variant-a</span><span>&#34;</span><span>, </span><span>&#34;</span><span>variant-b</span><span>&#34;</span><span>],</span></span>
<span><span>} </span><span>as</span><span> const</span><span>;</span></span>
<span></span>
<span><span>export</span><span> type</span><span> PosthogFlag</span><span> =</span><span> keyof</span><span> typeof</span><span> POSTHOG_FLAGS;</span></span>
<span></span>
<span><span>export</span><span> async</span><span> function</span><span> getPosthogFlagVariant</span><span>&lt;</span><span>T</span><span> extends</span><span> PosthogFlag</span><span>&gt;(</span><span>userID</span><span>:</span><span> UserID</span><span>, </span><span>flagName</span><span>:</span><span> T</span><span>) {</span></span>
<span><span>	const</span><span> variant </span><span>=</span><span> await</span><span> posthog.</span><span>getFeatureFlag</span><span>(flagName, userID);</span></span>
<span><span>	return</span><span> variant </span><span>as</span><span> (</span><span>typeof</span><span> POSTHOG_FLAGS)[</span><span>T</span><span>][</span><span>number</span><span>] </span><span>|</span><span> undefined</span><span>;</span></span>
<span><span>}</span></span></code></pre>
<p>The default return type for <code>posthog.getFeatureFlag</code> is <code>string | boolean | undefined</code>. But we have more precise knowledge. If we’re getting a value for <code>longer-free-trial</code> then the return type must be either <code>control</code> or <code>30-days</code>. So we can use the type assertion to assert our knowledge onto Typescript. And by doing so, anyone calling the <code>getPosthogFlagVariant</code> will have much more accurate &amp; specific types. Because <code>POSTHOG_FLAGS</code> is edited in a very controlled context (only when we’re adding or changing a feature flag), we can feel confident that unrelated changes to the codebase are unlikely to cause this lie to backfire.</p>
<p><em>Make illegal states unrepresentable</em> is another rule that’s helpful to know when to break. There are times when the work it would take to make an illegal state fully unrepresentable is just not worth it. And if I know that changes to what a legal state is are possible in the future, I might not want to cut off all our options too forcefully. Building an intuition for when to leave the door open is difficult and mostly comes from experience. A great example of this is <a href="https://www.swyx.io/preemptive-pluralization" rel="nofollow, noopener, noreferrer" target="_blank">preemptive pluralization</a>.</p>
<p>At the end of the day, it’s important to remember that all of these rules are in place to help us be more productive. We’re here to use the tool, not let the tool use us.</p>  </div></div>
  </body>
</html>
