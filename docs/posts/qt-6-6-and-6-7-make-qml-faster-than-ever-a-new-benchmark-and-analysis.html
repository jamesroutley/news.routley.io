<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.qt.io/blog/qt-6.6-and-6.7-make-qml-faster-than-ever-a-new-benchmark-and-analysis">Original</a>
    <h1>Qt 6.6 and 6.7 Make QML Faster Than Ever: A New Benchmark and Analysis</h1>
    
    <div id="readability-page-1" class="page"><div>
          

          

          <p>
            December 18, 2023 by <a href="https://www.qt.io/blog/author/ulf-hermann">Ulf Hermann</a>
            | <a href="#commento">Comments</a>
          </p>

          

          <p><span id="hs_cos_wrapper_post_body" data-hs-cos-general-type="meta_field" data-hs-cos-type="rich_text"><p>It has been a while since the <a href="https://www.qt.io/blog/compiling-qml-to-c-a-4x-speedup?hsLang=en">last time</a> I&#39;ve posted here and a lot has happened to the Qt Quick Compiler infrastructure. It&#39;s time to show some updated numbers. The benchmark discussed in my previous post was heavily focused on value types and lists of value types. It applied some rather complex tricks to eke out the maximum speedup between the interpreted and compiled versions of the same program.</p>
<!--more-->
<p>Today I&#39;m going to work with something more familiar to most people. I&#39;ve written a new benchmark that&#39;s mostly based on object types (and lists of those), and refrains from underhandedly instructing the compiler&#39;s type propagation using secret knowledge about the quirks of JavaScript operators. It also does something useful this time around. I&#39;ve re-implemented the DeltaBlue constraint solver found in the V8 benchmarks in typed QML.</p>
<p>In and of itself this is a somewhat foolish endeavour. Since I want to use object types, I use a separate QObject for each variable and each constraint. QObjects, as we all know, have a rather significant static overhead. Allocating a QObject just to store a few integers is quite a waste. The original implementation uses JavaScript objects. While still not ideal, those are somewhat more lightweight. Furthermore, in order to run the actual algorithm, we have to call a lot of functions, and calling functions in QML contexts is generally more expensive than doing the same in JavaScript contexts. This is because the context and scope hierarchy in QML is much more complex, and we often have to perform extra type conversions.</p>
<p>So, why did I do this? Most of you will want to deal with QObjects in a lot of places since all of Qt Quick is built on QObjects. You cannot avoid allocating a QObject if you need an Item. So, in a way the implementation using QObject as storage for everything, while slower, is also more realistic. You may argue that I should have written the benchmark with Qt Quick itself to get even more realistic. I decided not to do so because as soon as you add actual graphics to the mix, you have to deal with a lot more noisy data. Qt Quick itself often adds unpredictable overhead you don&#39;t want to deal with in a benchmark. For example, if you happen to have any text in your application, it has to create the font database at some point. Or, the scenegraph performs complex operations in the background to put the pixels on the screen. Those operations may or may not happen in a separate thread, and if so, there is still a synchronization phase for each frame. Finally, the graphics driver itself kicks in and performs its own calculations. This is all very interesing if you&#39;re benchmarking Qt Quick. However, I want to benchmark the QML language here. For me this is all just noise. Therefore, I&#39;ve written a non-graphical application built with QObjects. You can find the code in <a href="https://git.qt.io/ulherman/deltablue">this repository</a>.</p>
<p>And here is the good news: The performance numbers for dealing with QObjects and calling typed functions on them have improved massively in Qt 6.6 and Qt 6.7.</p>
<h3>Time taken to run the DeltaBlue benchmark with different versions of Qt</h3>
<a href="https://www.qt.io/hubfs/result.svg?hsLang=en" rel="noopener"><img src="https://www.qt.io/hubfs/result.svg" alt="result" width="800" height="400"/></a>
<p>On the Y axis you see the milliseconds it took to run one iteration of the benchmark. Lower is better. The benchmark was run with:</p>
<ul>
<li><strong>Qt 5.15</strong>, the last version of the Qt5 series. This is our baseline. In Qt 5.15 the Qt Quick Compiler didn&#39;t generate any C++ code for functions and bindings. It only produced byte code to be interpreted or JIT-compiled.</li>
<li><strong>Qt 6.2</strong>, since that is when the new Qt Quick Compiler was introduced as tech preview.</li>
<li><strong>Qt 6.5</strong>, the last LTS version.</li>
<li><strong>Qt 6.6</strong>, the most recent release, <strong>highlighted</strong> where appropriate.</li>
<li>A recent snapshot of <strong>Qt 6.7</strong>, <strong>highlighted</strong> where appropriate</li>
</ul>
<h2>The setup</h2>
<p>The benchmarked program takes as input a number of variables and constraints between them. The variables are effectively numbers and the constraints hold:</p>
<ol>
<li>An input variable</li>
<li>An output variable</li>
<li>A scale variable</li>
<li>An offset variable</li>
</ol>
<p>Either of these can be null. The constraint solver then manipulates the variable values, trying to achieve a state where for each constraint we get:</p>
<pre><code>output == input * scale + offset
</code></pre>
<p>There are more details to it, but this is the gist. Suffice to say, it&#39;s a somewhat demanding computational problem and as such well suited for our purposes.</p>
<p>We run this on two sets of inputs: 1. A chain of alternating variables and constraints, 100 variables long. 2. A projection where 100 inputs are scaled and offset into 100 outputs.</p>
<p>The split between those two inputs is not very interesting. I&#39;m giving them both together as a single data point in all the discussions below.</p>
<h3>Collected data points</h3>
<p>As mentioned before, there are two implementations of the actual algorithm:</p>
<ol>
<li>The JavaScript version, almost as found in the V8 benchmark suite.</li>
<li>The QML version I&#39;ve written.</li>
</ol>
<p>Finally, I&#39;ve split the execution into two phases for both implementations:</p>
<ol>
<li>A setup phase where all the objects are created that shall hold the variables and constraints.</li>
<li>The actual execution of the DeltaBlue algorithm.</li>
</ol>
<p>Combining all this, a single run of the benchmark produces 4 data points:</p>
<ol>
<li>The total time for the QML version</li>
<li>The object creation time for the QML version</li>
<li>The total time for the JavaScript version</li>
<li>The object creation time for the JavaScript version</li>
</ol>
<p>It has to be said that we cannot run the exact same code for all versions of Qt to be tested:</p>
<ul>
<li>Qt 6.2 and Qt 5.15 cannot declare and initialize list properties in one QML binding/declaration. So, those had to be split in two lines.</li>
<li>Qt 6.2 and Qt 5.15 do not know <a href="https://doc.qt.io/qt-6/qtqml-documents-definetypes.html#componentbehavior">pragma ComponentBehavior</a> so this had to be dropped, causing some IDs to become invisible to the compiler.</li>
<li>Qt 6.2 and Qt 5.15 do not know that &#39;:/qt/qml&#39; is a default import path. It&#39;s added manually.</li>
<li>Qt 6.2 and Qt 5.15 cannot construct a QQmlComponent <a href="https://doc.qt.io/qt-6/qqmlcomponent.html#QQmlComponent-6">from URI and name</a>. They have to load by URL instead.</li>
<li>Qt 5.15 has no proper build system API for QML modules. We build using qmake and <code>CONFIG+=qtquickcompiler</code> instead.</li>
<li>Qt 5.15 does not understand imports without versions. We add some versions to make it happy.</li>
</ul>
<p>I could have avoided some of those differences, but I intentionally used the new features. They lead to improved performance where they are available, and the improved performance is what we are after.</p>
<h3>No disk cache mode</h3>
<p>Now, since we don&#39;t have enough dimensions in our data, yet, we&#39;re adding another one. The benchmark by default uses Qt Quick Compiler to compile bindings and functions to C++. Comparing the numbers produced by the compiled code should give us the speedup caused by the compilation for each version of Qt, right? Well, unless the performance of the interpreter has also changed. In order to control for this, we also run the benchmark with <code>QML_DISABLE_DISK_CACHE=1</code> for each version of Qt. This makes it ignore the compiled artifacts and instead work with the QML source code.</p>
<p>Finally, the Qt Quick Compiler Extensions have an extra feature that comes in very handy here:</p>
<h3>Static mode</h3>
<p>Consider three files A.qml, B.qml, and C.qml:</p>
<pre><code>// A.qml
import QtQml
QtObject { property int v: 11 }

// B.qml
import QtQml
A { property string v: &#34;foos&#34; }

// C.qml
import QtQml
QtObject { 
    property A a: A {}
    function evil(b: B) { a = b }
    function bark() { console.log(a.v) }
}
</code></pre>
<p>If you instantiate <code>C</code> and play with the <code>evil</code> and <code>bark</code> functions a bit, you will discover a feature of the QML language you didn&#39;t want to know about. It&#39;s called property shadowing. For great many properties and methods we cannot know in advance what types they will have at run time. This is a nasty problem for the Qt Quick Compiler. In Qt 6.6 it has learned to deal with it by wrapping the affected values in QVariant and checking their types where necessary. This comes at a performance cost, though. <a href="https://doc.qt.io/qt-6/qtqml-qml-script-compiler.html">qmlsc</a> has an extra option <code>--static</code> that tells it to ignore any shadowing. You can use it at your own risk. There are some properties that are intentionally shadowed. For example we&#39;re moving the <a href="https://codereview.qt-project.org/c/qt/qtdeclarative/+/383968">focusReason</a> property to QQuickItem, leaving a property of the same name in QQuickControl for backwards compatibility. Most shadowing, however, is a mistake.</p>
<p>The <code>--static</code> option was not available in Qt 6.2 and only takes effect with Qt 6.5, 6.6, and 6.7.</p>
<p>In our benchmark, we know we haven&#39;t shadowed anything, and we don&#39;t want to pay the performance price of checking. Therefore, we add a third, <code>static</code>, mode to each benchmark run to see how much we can gain in comparison to the normal, <code>shadowable</code> mode.</p>
<h2>The results</h2>
<p>I&#39;ve tried very hard to produce stable, comparable, data. The benchmarks are run on a linux machine booted directly into a shell, without init system. For program run I first try to warm the caches by performing a dry run, and then run 1000 iterations of the benchmark. For each benchmark function the program is re-started from scratch so that they cannot interfer with each other. So let&#39;s go back to the graph above.</p>
<p>The first thing to note here is that I was not fully successful in my attempts to produce clean data. The JavaScript numbers should all be the same, especially within a single version of Qt. The way the QML code is compiled should not have any effect on the JavaScript execution. All the JavaScript at play here lives in a separate <code>deltablue.js</code> file that cannot be compiled to C++. Realizing this, I advise you to take all of the data with a roughly 5%-sized grain of salt.</p>
<p>Another thing you can immediately see is that the QML version of the algorithm is generally much slower than the JavaScript version. As noted above, this is due to it being built on QObjects rather than JavaScript objects.</p>
<p>On top of this, there is a noticable drop in performance between Qt 5.15 and Qt 6.2, for the QML version. If you look at the code you notice that there are a lot of <code>as</code> casts in there that tell the compiler what type to expect for some potentially shadowed value. In 5.15 <code>as</code> is a no-op. It was originally meant as a compile time only construct. Later, however, we noticed that this will lead to behavior differences between compiled and interpreted/JIT&#39;ed code. To avoid those, we introduced type checks for both the compiled code and the interpreter and JIT. So, the later versions of Qt do more work here, but for Qt 6.2 and 6.5 it does not pay off, yet. Qt 6.2 and 6.5 still have to interpret or JIT most of the code here since their compilers&#39; language coverage is rather limited.</p>
<p>With that out of the way, let&#39;s look at the happy side of things. I&#39;ve highlighted it in orange and red. Qt 6.6 takes about <strong>half</strong> the time Qt 6.5 takes to run the QML version of the benchmark, and Qt 6.7 improves on this some more. In static mode we get down to about <strong>a third</strong> of the 6.5 numbers. Here we get into a territory where the object creation overhead starts to dominate the benchmark. With Qt 6.7 in static mode, it took less time to run the whole benchmark than it took for the object creation alone with Qt 6.2.</p>
<p>Object creation also includes initial binding evaluation, which is why the object creation also benefits from compilation of bindings and expressions to C++. A complementary solution to object creation overhead will be <a href="https://doc.qt.io/qt-6/qtqml-qml-type-compiler.html">qmltc</a>, once it&#39;s ready.</p></span></p>

          

          
          <hr/>

          <h6>Blog Topics:</h6>
          
          


        </div></div>
  </body>
</html>
