<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/SubscriberLink/1025232/fbb2d90d084368e3/">Original</a>
    <h1>Rust in the Linux kernel: part 2</h1>
    
    <div id="readability-page-1" class="page"><div>

<p>
In 2023, Fujita Tomonori
<a href="https://lwn.net/ml/all/20231012125349.2702474-5-fujita.tomonori@gmail.com/">
wrote a Rust version</a> of the existing driver for the
Asix AX88796B embedded Ethernet controller. At slightly more than 100 lines,
it&#39;s about as simple as a driver can be, and therefore is a useful touchstone for
the differences between writing Rust and C in the kernel. Looking at the Rust
syntax, types, and APIs used by the driver and contrasting them with the C
version will help illustrate those differences.
</p>

<p>
Readers who are already conversant with Rust may find this article retreads some
basics, but it is my hope that it can still serve as a useful reference for
implementing simple drivers in Rust. The
<a href="https://elixir.bootlin.com/linux/v6.15.2/source/drivers/net/phy/ax88796b.c">
C version</a> and the
<a href="https://elixir.bootlin.com/linux/v6.15.2/source/drivers/net/phy/ax88796b_rust.rs">
Rust version</a> of the AX88796B driver are remarkably similar, but there are still some important
differences that could trip up a developer performing a naive rewrite from one to the other.
</p>

<h4>The setup</h4>

<p>
The least-different thing between the two versions is the legalities. The Rust
driver starts with an
<a href="https://docs.kernel.org/process/license-rules.html">
SPDX comment</a> asserting that the file is covered by the GPL,
as many files in the kernel do. Below that is a documentation comment:
</p>

<pre>    //! Rust Asix PHYs driver
    //!
    //! C version of this driver: [`drivers/net/phy/ax88796b.c`](./ax88796b.c)
</pre>

<p>
As mentioned in the
<a href="https://lwn.net/Articles/1024202/">
previous article</a>, comments starting with <tt>//!</tt> contain documentation that applies
to the
entire file. The next few lines are a <tt>use</tt> statement, the Rust analogue
of <tt>#include</tt>:
</p>

<pre>    use kernel::{
        c_str,
        net::phy::{self, reg::C22, DeviceId, Driver},
        prelude::*,
        uapi,
    };
</pre>

<p>
Like C, Rust modules are located starting from a search path and then continuing
down a directory tree. Unlike C, a <tt>use</tt> statement can selectively import
only some items defined in a module. For example, <tt>DeviceId</tt> is not a separate module,
but rather a specific item inside the
<a href="https://elixir.bootlin.com/linux/v6.15.2/source/rust/kernel/net/phy.rs">
<tt>kernel::net::phy</tt></a> module. By
importing both <tt>kernel::net::phy::DeviceId</tt> and <tt>kernel::net::phy</tt>
as a whole, the Rust module can refer to <tt>DeviceId</tt> directly, and
anything else from the PHY module as <tt>phy::name</tt>. These items can always
be referred to by their full paths; a <tt>use</tt> statement just introduces a
shorter local alias. If a name would be ambiguous, the compiler will complain.
</p>

<p>
All of these imported items come from the <tt>kernel</tt> crate (Rust library),
which contains the bindings between the main kernel and Rust code. In a
user-space Rust project, a program would usually also have some imports from
<tt>std</tt>, Rust&#39;s standard library, but that isn&#39;t possible in the kernel,
since the kernel needs more precise control over allocation and other details
that the standard library abstracts away. Kernel C developers can&#39;t use
functions from libc in the kernel for much the same reason. The
<a href="https://elixir.bootlin.com/linux/v6.15.2/source/rust/kernel/prelude.rs">
<tt>kernel::prelude</tt> module</a> contains kernel replacements for many common
standard-library functions; the remainder can be found in <tt>core</tt>, the
subset of <tt>std</tt> that doesn&#39;t allocate.
</p>

<p>
In the C version of the driver, the next step is to define some constants
representing the three different, but related, devices this driver supports: the
AX88772A, the AX88772C, and the AX88796B. In Rust, items do not have to be
declared before use — the entire file is considered at once. Therefore, Fujita
chose to reorder things slightly to keep the code for each board in its own
section; the types for each board (<tt>PhyAX88772A</tt> and so on) are defined
later.
The next part of the Rust driver is a macro invocation that sets up the
necessary symbols for a PHY driver:
</p>

<pre>    kernel::module_phy_driver! {
        drivers: [PhyAX88772A, PhyAX88772C, PhyAX88796B],
        device_table: [
            DeviceId::new_with_driver::&lt;PhyAX88772A&gt;(),
            DeviceId::new_with_driver::&lt;PhyAX88772C&gt;(),
            DeviceId::new_with_driver::&lt;PhyAX88796B&gt;()
        ],
        name: &#34;rust_asix_phy&#34;,
        authors: [&#34;FUJITA Tomonori &lt;fujita.tomonori@gmail.com&gt;&#34;],
        description: &#34;Rust Asix PHYs driver&#34;,
        license: &#34;GPL&#34;,
    }
</pre>

<p>
Rust macros come in two general kinds: attribute macros, which are written
<tt>#[macro_name]</tt> and modify the item that they appear before, and normal
macros, which are written <tt>macro_name!()</tt>. There is also a less common
variant of attribute macros written <tt>#![macro_name]</tt> which applies to the
definition that they appear within. Normal macros can use any
matching set of braces to enclose their arguments, but can always be recognized
by the mandatory exclamation mark between the name and the braces.
The convention is to use
parentheses for macros that return a value and braces for macros that are
invoked to define a structure (as is the case here), but that is not actually
required. Invoking the macro with parentheses would have the same result, but it
would make it less obvious to other Rust programmers what is happening.
</p>

<blockquote>
<b>Nobody covers the Linux kernel like LWN</b>; be in the know with
<a href="https://lwn.net/Promo/Kernel-2/claim">a one-month trial subscription</a>, no credit card needed.
</blockquote>


<p>
The <tt>drivers</tt> argument to the macro contains the names of the three board
types this driver covers. Each driver has to be associated with information such
as the name of the device and the PHY device ID that it should be active for. In
the C version of the driver, this is handled by a separate table:
</p>

<pre>    static struct phy_driver asix_driver[] = { ... };
</pre>

<p>
In the Rust code, this information is stored in the code for each board (see
below), since
all PHY drivers need to provide it. Overall, the
<tt>kernel::module_phy_driver!{}</tt> macro serves the same role as the
<a href="https://elixir.bootlin.com/linux/v6.15.2/source/include/linux/phy.h#L2126">
<tt>module_phy_driver()</tt></a> macro in C.
</p>

<p>
Next, the Rust driver defines two constants that the code uses later:
</p>

<pre>    const BMCR_SPEED100: u16 = uapi::BMCR_SPEED100 as u16;
    const BMCR_FULLDPLX: u16 = uapi::BMCR_FULLDPLX as u16;
</pre>

<p>
Every declaration of a value (as opposed to a data structure) in Rust starts
with either <tt>const</tt> or <tt>let</tt>. The former are compile-time
constants — like a simple <tt>#define</tt> in C. Types are mandatory for
<tt>const</tt> definitions, but optional for <tt>let</tt> ones. In either case,
the type always appears separated from the name by a colon.
So, in this case, both constants are
<tt>u16</tt> values, Rust&#39;s unsigned 16-bit integer type. The <tt>as u16</tt>
part at the end is a cast, since the original <tt>uapi::BMCR_*</tt> constants
being referenced are defined in C and assumed to be 32 or 64 bits by default,
depending on the platform.
</p>

<h4>An actual function</h4>

<p>
The final piece of code before the actual drivers is a shared function for
performing a soft reset on Asix PHYs:
</p>

<pre>    // Performs a software PHY reset using the standard
    // BMCR_RESET bit and poll for the reset bit to be cleared.
    // Toggle BMCR_RESET bit off to accommodate broken AX8796B
    // PHY implementation such as used on the Individual
    // Computers&#39; X-Surf 100 Zorro card.
    fn asix_soft_reset(dev: &amp;mut phy::Device) -&gt; Result {
        dev.write(C22::BMCR, 0)?;
        dev.genphy_soft_reset()
    }
</pre>

<p>
There&#39;s a few things to notice about this function. First of all, the comment
above it is not a documentation comment. This isn&#39;t a problem because this
function is also private — since it was declared with <tt>fn</tt> instead of
<tt>pub fn</tt>, it&#39;s not visible outside this one module. The C equivalent
would be a <tt>static</tt> function. In Rust, the default is the opposite way around,
with functions being private (static) unless declared otherwise.
</p>

<p>
The argument to the function is an <tt>&amp;mut phy::Device</tt> called <tt>dev</tt>.
References (written with an &amp;)
are in many ways Rust&#39;s most prominent feature; they are like
pointers, but with compile-time guarantees that certain classes of bugs (such as
concurrent mutable access without synchronization) can&#39;t happen. In this case,
<tt>asix_soft_reset()</tt> takes a mutable reference (<tt>&amp;mut</tt>). The
compiler guarantees that no other function can have a reference to the
same
<a href="https://rust.docs.kernel.org/kernel/net/phy/struct.Device.html">
<tt>phy::Device</tt></a> at the same time. This means that the body of the
function can clear the <tt>BMCR</tt> pin and trigger a soft reset without
worrying about concurrent interference.
</p>

<p>
The last part of the function to understand is the return type,
<a href="https://rust.docs.kernel.org/kernel/error/type.Result.html">
<tt>Result</tt></a>, and the &#34;try&#34; operator, <tt>?</tt>. In C, a function that could fail often
indicates this by returning a special sentinel value, typically a negative number.
In Rust, the same thing is true, but the sentinel value is called <tt>Err</tt>
instead, and is one possible value of the <tt>Result</tt> enumeration. The other
value is <tt>Ok</tt>, which indicates success. Both <tt>Err</tt> and <tt>Ok</tt>
can carry additional information, but the default in the kernel is for <tt>Err</tt> to carry an
<a href="https://rust.docs.kernel.org/kernel/error/struct.Error.html">
error number</a>, and for <tt>Ok</tt> to have no additional information.
</p>

<p>
The pattern of checking for an error and then immediately propagating it to a
function&#39;s caller is so common that Rust introduced the try operator as a
shortcut. Consider the same function from the C version of the driver:
</p>

<pre>    static int asix_soft_reset(struct phy_device *phydev)
    {
	    int ret;

	    /* Asix PHY won&#39;t reset unless reset bit toggles */
	    ret = phy_write(phydev, MII_BMCR, 0);
	    if (ret &lt; 0)
		    return ret;

	    return genphy_soft_reset(phydev);
    }
</pre>

<p>
It performs the same two potentially fallible library function calls, but needs
an extra statement to propagate the potential error. In the Rust version, if the
first call returns an <tt>Err</tt>, the try operator automatically returns it.
For the second call, note how the line does not end with a semicolon — this
means the value of the function call is also the return value of the function as
a whole, and therefore any errors will also be returned to the caller. The
missing semicolon is not easy to forget, however, because adding it in will make
the compiler complain that the function does not return a <tt>Result</tt>.
</p>


<h4>The main driver</h4>

<p>
The actual driver code differs slightly for the three different boards. The
simplest is the AX88786B, the implementation of which starts on
<a href="https://elixir.bootlin.com/linux/v6.15.2/source/drivers/net/phy/ax88796b_rust.rs#L124">
line 124</a>:
</p>

<pre>    struct PhyAX88796B;
</pre>

<p>
This is an empty structure. An actual instance of this type has no storage
associated with it — it doesn&#39;t take up space in other structures,
<a href="https://doc.rust-lang.org/std/mem/fn.size_of.html">
<tt>size_of()</tt></a> reports 0, and it has no padding — but there can still be
global data for the type as a whole (such as debugging information). In this
case, an empty structure is used to implement the <tt>Driver</tt> abstraction,
in order to bundle all of the needed data and functions for a PHY driver
together. When the compiler is asked to produce functions that apply to a
<tt>PhyAX88796B</tt> (which the <tt>module_phy_driver!{}</tt> macro does), it
will use this definition:
</p>

<pre>    #[vtable]
    impl Driver for PhyAX88796B {
        const NAME: &amp;&#39;static CStr = c_str!(&#34;Asix Electronics AX88796B&#34;);
        const PHY_DEVICE_ID: DeviceId =
            DeviceId::new_with_model_mask(0x003b1841);

        fn soft_reset(dev: &amp;mut phy::Device) -&gt; Result {
            asix_soft_reset(dev)
        }
    }
</pre>

<p>
The constant and function definitions work in the same way as above. The type of
<tt>NAME</tt> uses a static reference (&#34;<tt>&amp;&#39;static CStr</tt>&#34;), which is
a reference
that is valid for the entire lifetime of the program. The C equivalent is a
<tt>const</tt> pointer to the data section of the executable: it is never
allocated, freed, or modified, and is therefore fine to dereference anywhere in
the program.
</p>

<p>
The new
Rust feature in this part of the driver is the <tt>impl</tt> block, which is used to implement a
<a href="https://doc.rust-lang.org/book/ch10-02-traits.html#traits-defining-shared-behavior">
trait</a>. Often, a program will have multiple different parts that conform to
the same interface. For example, all PHY drivers need to provide a name,
associated device ID, and some functions implementing driver operations.
In Rust, this kind of common interface is represented by a
trait, which lets the compiler perform static type dispatch to select the right
implementation based on how the trait functions are called.
</p>

<p>
C, of course, does not work like this (although
<a href="https://en.cppreference.com/w/c/language/generic.html">
<tt>_Generic</tt></a> can sometimes
be used to implement type dispatch manually). In the kernel&#39;s C code, PHY drivers are
represented by
<a href="https://elixir.bootlin.com/linux/v6.15.2/source/include/linux/phy.h#L876">
a structure</a> that contains data and function pointers. The
<tt>#[vtable]</tt> macro converts a Rust trait into a singular C structure full of
function pointers. Up above, in the call to <tt>module_phy_driver!{}</tt>, the
reference to the <tt>PhyAX88796B</tt> type lets the compiler find the right
<tt>Driver</tt> implementation, and from there produce the correct C structure
to integrate with the C PHY driver infrastructure.
</p>

<p>
There are obviously more functions involved in implementing a complete PHY
driver. Luckily, these functions are often the same between different devices,
because there is a standard interface for PHY devices. The C PHY driver code
will fall back to a generic implementation if a more specific function isn&#39;t
present in the driver&#39;s definition, so the AX88796B code can leave them out.
The other two devices supported in this driver
specify more custom functions to work around hardware quirks, but those
functions are not much more complicated than what has already been shown.
</p>

<h4>Summary</h4>

<p>
Steps to implement a PHY driver ...
</p>

<table>
<tbody><tr><td>... in C:</td><td>... in Rust:</td></tr>
<tr>
<td>Write module boilerplate (licensing and authorship information,
<tt>#include</tt> statements, etc.).</td>
<td>Write module boilerplate (licensing and authorship information, <tt>use</tt>
statements, a call to <tt>module_phy_driver!{}</tt>).</td>
</tr>
<tr>
<td>Implement the needed functions for the driver, skipping functions that can
use the generic PHY code.
</td>
<td>Implement the needed functions for the driver, skipping functions that can
use the generic PHY code.
</td>
</tr>
<tr>
<td>Bundle the functions along with a name, optional flags, and PHY device ID
into a <tt>struct phy_driver</tt> and register it with the PHY subsystem.
</td>
<td>Bundle the functions along with a name, optional flags, and PHY device ID
into a trait; the <tt>#[vtable]</tt> macro converts it into the right form for
the PHY subsystem.
</td>
</tr>
</tbody></table>

<p>
Of course, many drivers have specific hardware concerns or other complications;
kernel software is distinguished by its complexity and concern with low-level
details. The next article in this series will look at the design of the interface
between the C and Rust code in the kernel, as well as the process of adding new
bindings when necessary.
</p></div></div>
  </body>
</html>
