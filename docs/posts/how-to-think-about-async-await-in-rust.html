<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://cliffle.com/blog/async-inversion/">Original</a>
    <h1>How to think about async/await in Rust</h1>
    
    <div id="readability-page-1" class="page"><div>
            
<div>
  <header>
    
    
  </header>
  
  <p><span>2023-06-30</span></p><ul>
    
      <li><a href="http://cliffle.com/blog/async-inversion/#async-fn-is-an-inversion-of-control">async fn is an inversion of control</a>
        
        </li>
    
      <li><a href="http://cliffle.com/blog/async-inversion/#hand-rolling-an-explicit-state-machine">Hand-rolling an explicit state machine</a>
        
        </li>
    
      <li><a href="http://cliffle.com/blog/async-inversion/#explicit-state-machines-mean-your-caller-has-control">Explicit state machines mean your caller has control</a>
        
        </li>
    
      <li><a href="http://cliffle.com/blog/async-inversion/#writing-state-machines-with-async-fn">Writing state machines with async fn</a>
        
        </li>
    
      <li><a href="http://cliffle.com/blog/async-inversion/#await-is-a-composition-operator">await is a composition operator</a>
        
        </li>
    
      <li><a href="http://cliffle.com/blog/async-inversion/#summary">Summary</a>
        
        </li>
    
  </ul>
  
  <p>(This is a section of the <a href="https://github.com/cbiffle/lilos/blob/main/doc/intro.adoc"><code>lilos</code> intro guide</a> that people seemed to like, so
to increase its visibility, I’m lifting it up into its own post and expanding it
a bit. I hope this is a useful companion piece to the <a href="http://cliffle.com/blog/lildb/">post on async
debugging</a> I posted this morning.))</p>
<p>Some documentation of Rust <code>async</code> and <code>await</code> has presented it as a seamless
alternative to threads. Just sprinkle these keywords through your code and get
concurrency that scales better! I think this is very misleading. An <code>async fn</code>
is a different thing from a normal Rust <code>fn</code>, and you need to think about
different things to write correct code in each case.</p>
<p>This post presents a different way of looking at <code>async</code> that I think is more
useful, and less likely to lead to cancellation-related bugs.</p>

<p>Here is how I think about <code>fn</code> vs <code>async fn</code>:</p>
<ul>
<li>
<p>A Rust <code>fn</code> is a function that will execute until it decides to stop executing
(ignoring things like threads being preempted), or until it’s interrupted by a
panic. In particular, its <em>caller</em> gives up control by calling it, and cannot
decide to “un-call” it halfway through. (And likewise, if your <code>fn</code> calls
another <code>fn</code>, you give up control to that <code>fn</code>, which can decide to enter an
infinite loop or <code>panic!</code>.)</p>
</li>
<li>
<p>A Rust <code>async fn</code> is an explicit state machine that you can manipulate and
pass around, that happens to be phrased using normal Rust syntax instead of
tables and <code>match</code> statements. It generates a hidden type implementing the
<code>Future</code> trait. The code that calls an <code>async fn</code> (or uses any <code>Future</code>, for
that matter) has ultimate control over that <code>Future</code>, and can decide when it
runs or doesn’t run, and can even discard it before it completes.</p>
</li>
</ul>
<p>This distinction is subtle but very important: an <code>async fn</code> represents an
<a href="https://en.wikipedia.org/wiki/Inversion_of_control"><em>inversion of control</em></a> compared to a normal <code>fn</code>.</p>
<p>You’ve probably run into inversion of control as a pattern before – it’s often
used in things that get referred to as “frameworks.” Have you written a request
handler that gets initialized and invoked by a webserver when appropriate to
handle events? Inversion of control. Done almost anything in React? Same deal.
The important part for our purposes is that, where normal code gets control of
the computer from its caller, here <em>the caller gets control of the code</em>
instead.</p>
<p>To illustrate the difference, let’s talk about state machines.</p>

<p>If you wrote an explicit state machine by hand, this distinction would be clear
in the code. For instance, here’s a simple one:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>#</span><span>[</span><span>derive</span><span><span><span>(</span></span></span><span><span>Default</span></span><span><span><span>)</span></span></span><span>]</span></span>
<span><span>enum</span> <span>State</span> <span><span>{</span>
    <span><span>#</span><span>[</span><span>default</span><span>]</span></span>
    Begin<span>,</span>
    PinHigh<span>,</span>
    PinLow<span>,</span>
    Done<span>,</span>
</span><span><span>}</span></span></span>

<span><span>impl</span> </span><span><span>State</span> </span><span><span><span>{</span>
        <span><span><span>fn</span> </span><span>step</span></span><span><span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>bool</span></span> </span><span><span><span>{</span>
        <span>match</span> <span>self</span> <span><span>{</span>
            <span>Self</span><span><span>::</span></span>Begin <span>=&gt;</span> <span><span>{</span>
                <span>set_pin_high</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
                <span>*</span><span>self</span> <span>=</span> <span>Self</span><span><span>::</span></span>PinHigh<span>;</span>
                <span>false</span>
            </span><span><span>}</span></span>
            <span>Self</span><span><span>::</span></span>PinHigh <span>=&gt;</span> <span><span>{</span>
                <span>set_pin_low</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
                <span>*</span><span>self</span> <span>=</span> <span>Self</span><span><span>::</span></span>PinLow<span>;</span>
                <span>false</span>
            </span><span><span>}</span></span>
            <span>Self</span><span><span>::</span></span>PinLow <span>=&gt;</span> <span><span>{</span>
                <span>tristate_pin</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
                <span>*</span><span>self</span> <span>=</span> <span>Self</span><span><span>::</span></span>Done<span>;</span>
                <span>false</span>
            </span><span><span>}</span></span>
                        <span>Self</span><span><span>::</span></span>Done <span>=&gt;</span> <span>true</span><span>,</span>
        </span><span><span>}</span></span>
    </span><span><span>}</span></span></span>
</span><span><span>}</span></span></span>
</span></code></pre>
<p>State machines like this are almost universal in embedded systems, whether
they’re phrased explicitly or left implicit. Drivers that have a combination of
API entry points and interrupt service routines, for instance, form this kind of
state machine. This toy version is written to be small enough to pick apart.</p>
<p>Each time the code that owns your <code>State</code> calls <code>step</code>, your code gets the
opportunity to do stuff. At the end of that stuff, it <em>returns,</em> and the calling
code regains control. It can then keep calling <code>step</code> until it gets <code>true</code>,
indicating completion; or it could do something else and never call <code>step</code>
again; or it could <code>drop</code> your state. (Note that it can also choose to <em>keep
calling <code>step</code></em> even after getting the <code>true</code> result! It’s very much in control
here.)</p>
<p>How long will the high and low periods on the pin last? Well, how often will the
caller call <code>step</code>? Sometimes this is defined by a contract (e.g. “this state
machine advances every 100 ms”), but in this code example, we haven’t done
anything to control timing. The caller could call <code>step</code> in a <code>loop</code> and make
the high/low periods as short as possible, or it could sleep for months in
between calls…or never call <code>step</code> again.</p>
<p>What will the final state of the pin we’re controlling be? Currently, we can’t
say. The caller could leave us paused forever without calling <code>step</code>, or could
drop us before we finish. So the final state of the pin could be high, low, or
tristate, depending on what the caller chooses. We could make this
better-defined by adding a <code>Drop</code> impl, so if the caller were to <code>drop</code> the
<code>State</code> before it finishes, the pin would do someting predictable:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>impl</span> </span><span>Drop <span>for</span></span><span> <span>State</span> </span><span><span><span>{</span>
    <span><span><span>fn</span> </span><span>drop</span></span><span><span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
        <span>if</span> <span>!</span><span>matches</span><span><span>(</span><span>self</span><span>,</span> <span>Self</span><span><span>::</span></span>Done</span><span><span>)</span></span> <span><span>{</span>
            <span>tristate_pin</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
            <span>*</span><span>self</span> <span>=</span> <span>Self</span><span><span>::</span></span>Done<span>;</span>
        </span><span><span>}</span></span>
    </span><span><span>}</span></span></span>
</span><span><span>}</span></span></span>
</span></code></pre>
<p>But if your caller decides to hang on to <code>State</code> and never call <code>step</code>, there’s
not really anything <code>State</code> itself can do about this.</p>
<p>And you want it this way. Really. Keep reading.</p>

<p>That might sound bad, but it’s <strong>really powerful.</strong> For instance, imagine that
your caller looks like this:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> <span>mut</span> state <span>=</span> <span>State<span>::</span></span>default<span><span>(</span></span><span><span>)</span></span><span>;</span>

<span>loop</span> <span><span>{</span>
    <span>wait_for_a_key_press</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
    <span>let</span> done <span>=</span> state<span>.</span><span>step</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
    <span>if</span> done <span><span>{</span> <span>break</span><span>;</span> </span><span><span>}</span></span>
</span><span><span>}</span></span>
</span></code></pre>
<p>If we want to <code>step</code> every time the user presses a key, then we have to accept
the possibility of never <code>step</code>-ping – because we can’t force the user to
press a key! Being able to create a state machine and have it sit around waiting
forever, at very low cost, is part of the power of writing explicit state
machines.</p>

<p>Writing explicit state machines in “long-hand” like this is error-prone
and complex. Let’s rewrite the running example as an <code>async fn</code>. (The <code>pending!</code>
macro is from the <code>futures</code> crate, and yields to the caller without waiting for
any particular event. It contains an <code>await</code>.)</p>
<pre data-lang="rust"><code data-lang="rust"><span>async <span><span><span>fn</span> </span><span>my_state_machine</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
    <span>set_pin_high</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
    <span>pending!</span><span><span>(</span></span><span><span>)</span></span><span>;</span>

    <span>set_pin_low</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
    <span>pending!</span><span><span>(</span></span><span><span>)</span></span><span>;</span>

    <span>tristate_pin</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</span><span><span>}</span></span></span>
</span></code></pre>
<p>That doesn’t reproduce the <code>Drop</code> behavior if we’re cancelled. To do this in an
<code>async fn</code> you need to have something in the body of the function that will
perform an action when destroyed. You can roll this by hand, but, I recommend
the <code>scopeguard</code> crate and its <code>defer!</code> macro:</p>
<pre data-lang="rust"><code data-lang="rust"><span>async <span><span><span>fn</span> </span><span>my_state_machine</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
    <span>set_pin_high</span><span><span>(</span></span><span><span>)</span></span><span>;</span>

                <span>defer!</span> <span><span>{</span> <span>tristate_pin</span><span><span>(</span></span><span><span>)</span></span><span>;</span> </span><span><span>}</span></span>
    <span>pending!</span><span><span>(</span></span><span><span>)</span></span><span>;</span>

    <span>set_pin_low</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
    <span>pending!</span><span><span>(</span></span><span><span>)</span></span><span>;</span>

    </span><span><span>}</span></span></span>
</span></code></pre>
<p>That’s dramatically less code. It’s also much easier to check for correctness:</p>
<ul>
<li>
<p>You can tell at a glance that there’s no way to return to an earlier state
from a later one, since doing so would require a <code>for</code>, <code>loop</code>, or <code>while</code>,
and there isn’t one here.</p>
</li>
<li>
<p>You can see (once you’ve read the docs for the <code>defer!</code> macro) that, as soon
as the pin gets set high and <em>before</em> we yield control back, the state machine
will ensure that the pin gets tristated at the end, no-matter-what. You don’t
have to go hunting for a separate <code>Drop</code> impl.</p>
</li>
</ul>

<p>Often, an application winds up requiring a <em>hierarchy</em> of state machines.
Imagine that you wanted to take the pin-toggling state machine from the previous
section, and ensure that it waits a certain minimum interval between changes. If
the OS provides a “sleep for a certain time period” state machine (as <code>lilos</code>
does) then the easiest way is to plug that into your state machine. Its states
effectively become <em>sub-states</em> within one of your states. This is
<em>composition.</em></p>
<p>In a hand-rolled state machine, this is hard enough to get right that I’m not
going to present a worked example. (Try it if you’re curious!)</p>
<p>But with a state machine expressed using <code>async fn</code>, it’s trivial, because we
have an operator for it: <code>await</code>. <code>await</code> is the most common state machine
composition operator (though not the only one!). It says, “take this other state
machine, and run it to completion as part of my state machine.”</p>
<p>And so, we can add sleeps to our pin-toggler by changing our <code>pending!()</code> to
instead <code>await</code> a reusable sleep-for-a-duration state machine:</p>
<pre data-lang="rust"><code data-lang="rust"><span>async <span><span><span>fn</span> </span><span>my_state_machine</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
    <span>set_pin_high</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
    <span>defer!</span> <span><span>{</span> <span>tristate_pin</span><span><span>(</span></span><span><span>)</span></span><span>;</span> </span><span><span>}</span></span>

    <span>sleep_for</span><span><span>(</span>Millis<span><span>(</span><span>100</span></span><span><span>)</span></span></span><span><span>)</span></span><span>.</span>await<span>;</span>

    <span>set_pin_low</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
    <span>sleep_for</span><span><span>(</span>Millis<span><span>(</span><span>100</span></span><span><span>)</span></span></span><span><span>)</span></span><span>.</span>await<span>;</span>

    </span><span><span>}</span></span></span>
</span></code></pre>
<p>This will ensure that a <em>minimum</em> of 100 ms elapses between our changes to the
pin. We can’t impose a <em>maximum</em> using this approach, because – as we saw above
– our caller could wait months between stepping our state machine, and that’s
part of what we’re signing up for by writing this state machine.</p>
<p>Composition and cancellation interact in wonderful ways. Let’s say you’re using
<code>some_state_machine</code> and you’re suspicious that it might take more than 200 ms.
You’d like to impose a <em>timeout</em> on it: it will have 200 ms to make progress,
but if it doesn’t complete by the end of that window, it will be cancelled
(<code>drop</code>-ped).</p>
<p>The easiest way to do this is to use the <code>select_biased!</code> macro from the
<code>futures</code> crate. (It’s called <code>biased</code> because it steps the state machines
inside it from first to last, and if any complete, all the rest are dropped.
This means it’s slightly <em>biased</em> toward completing the earlier ones.)</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>select_biased!</span> <span><span>{</span>
    <span>_</span> <span>=</span> <span>sleep_for</span><span><span>(</span>Millis<span><span>(</span><span>200</span></span><span><span>)</span></span></span><span><span>)</span></span> <span>=&gt;</span> <span><span>{</span>
                    </span><span><span>}</span></span>
    result <span>=</span> <span>some_state_machine</span><span><span>(</span></span><span><span>)</span></span> <span>=&gt;</span> <span><span>{</span>
                <span>print</span><span><span>(</span>result</span><span><span>)</span></span><span>;</span>
    </span><span><span>}</span></span>
</span><span><span>}</span></span>
</span></code></pre>
<p>This is the sort of power we get from the <code>async fn</code> ecosystem. Doing this with
hand-rolled state machines is probably <em>possible,</em> but would be complex – and
we haven’t even <em>talked about</em> borrowing and lifetimes. That’s a bigger topic
than will fit in this post, but the short version is: borrowing across <code>await</code>
points in an <code>async fn</code> pretty much Just Does What You’d Expect, but getting it
right in a hand-rolled state machine requires <code>unsafe</code> and gymnastics.</p>

<p>From my perspective, <em>this</em> is the fundamental promise of <code>async fn</code>: easier,
composable, explicit state machines.</p>
<p>If a chunk of code absolutely needs to run to completion without letting
anything else run, use a normal <code>fn</code>. If a chunk of code doesn’t need to call
any <code>async fn</code>s, use a normal <code>fn</code>. Basically, any function that can be
written as a normal <code>fn</code> without breaking something, should be. It’s easier.</p>
<p>But if you need to write a state machine, use <code>async fn</code>. It’s harder to
understand than normal <code>fn</code> because of the inversion of control and potential
for cancellation, but far easier to understand than the code you might write by
hand to do the same thing!</p>
<p><strong>CAUTION:</strong> There’s a proposal to make code generic on whether or not it’s
being used <code>async</code>, so that the same code could produce both a simple function
and a <code>Future</code>. In this case you’d have to make sure to think about correctness
in all possible ways your code could be used. I am suspicious, and I hope after
reading this section, you are too.</p>

  
    <p><span>
      
        <a href="http://cliffle.com/tags/design-patterns/">#design-patterns</a>
      
        <a href="http://cliffle.com/tags/rust/">#rust</a>
      
    </span>
  
</p></div>

        </div></div>
  </body>
</html>
