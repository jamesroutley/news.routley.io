<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ntietz.com/blog/whats-in-a-ring-buffer/?utm_source=atom&amp;utm_medium=feed">Original</a>
    <h1>What&#39;s in a ring buffer? And using them in Rust</h1>
    
    <div id="readability-page-1" class="page"><div><p>Working on my cursed MIDI project, I needed a way to store the most recent messages without risking an unbounded amount of memory usage.
I turned to the trusty ring buffer for this!
I started by writing a very simple one myself in Rust, then I looked and what do you know, of <em>course</em> the standard library has an implementation.</p>
<p>While I was working on this project, I was pairing with a friend.
She asked me about ring buffers, and that&#39;s where this post came from!</p>

<p>Ring buffers are known by a few names.
Circular queues and circular buffers are the other two I hear the most.
But this name just has a nice ring to it.</p>
<p>It&#39;s an array, basically: a buffer, or a queue, or a list of items stacked up against each other.
You can put things into it and take things out of it the same as any buffer.
But the front of it connects to the back, like any good ring.</p>
<p>Instead of adding on the end and popping from the end it, like a stack, you can add to one end and remove from the start, like a queue.
And as you add or remove things, where the start and end of the list <em>move around</em>.
Your data eats its own tail.</p>
<p>This lets us keep a fixed number of elements in the buffer without running into reallocation.
In a regular old buffer, if you use it as a queue—add to the end, remove from the front—then you&#39;ll eventually need to either reallocate the entire thing or shift all the elements over.
Instead, a ring buffer lets you just keep adding from either end and removing from either end and you never have to reallocate!</p>

<p>My MIDI program is one example of where you&#39;d want a ring buffer, to keep the most recent items.
There are some general situations where you&#39;ll run into this:</p>
<ul>
<li>You want a fixed number of the most recent things, like the last 50 items seen</li>
<li>You want a queue, especially with a fixed maximum number of queued elements</li>
<li>You want a buffer for data coming in with an upper bound, like with streaming audio, and you want to overwrite old data if the consumer can&#39;t keep up for a bit</li>
</ul>
<p>A lot of it comes down to performance, and streaming data.
Something is producing data, something else is consuming it, and you want to make sure insertions and removals are fast.
That was exactly my use: a MIDI device produces messages, my UI consumes them, but I don&#39;t want to fill up <em>all</em> my memory, forever, with more of them.</p>

<p>So how do they work?</p>
<p>This is a normal, non-circular buffer:</p>
<p><img src="https://www.ilograph.com/images/circular-buffer-1.png" alt=""/></p>
<p>When you add something, you put it on the end.
<img src="https://www.ilograph.com/images/circular-buffer-2.png" alt=""/></p>
<p>If you&#39;re using it as a stack, then you can pop things off the end.
<img src="https://www.ilograph.com/images/circular-buffer-3.png" alt=""/></p>
<p>But if you&#39;re using it as a queue, you pop things off the front...
<img src="https://www.ilograph.com/images/circular-buffer-4.png" alt=""/></p>
<p>And then you have to shuffle everything to the left.
<img src="https://www.ilograph.com/images/circular-buffer-5.png" alt=""/></p>
<p>That&#39;s why we have ring buffers!
I&#39;ll draw it as a straight line here, to show how it&#39;s laid out in memory.
But the end loops back to the front logically, and we&#39;ll see how it wraps around.</p>
<p>We start with an empty buffer, and <code>start</code> and <code>end</code> both point at the first element.
When <code>start == end</code>, we know the buffer is empty.
<img src="https://www.ilograph.com/images/circular-buffer-6.png" alt=""/></p>
<p>If we insert an element, we move <code>end</code> forward.
<img src="https://www.ilograph.com/images/circular-buffer-7.png" alt=""/></p>
<p>And it gets repeated as we insert multiple times.
<img src="https://www.ilograph.com/images/circular-buffer-8.png" alt=""/></p>
<p>If we remove an element, we move <code>start</code> forward.
<img src="https://www.ilograph.com/images/circular-buffer-9.png" alt=""/></p>
<p>We can also start the buffer at any point, and it crosses over the end gracefully.
<img src="https://www.ilograph.com/images/circular-buffer-10.png" alt=""/></p>
<p>Ring buffers are pretty simple when you get into their details, with just a few things to wrap your head around.
It&#39;s an incredibly useful data structure!</p>

<p>If you want to use one in Rust, what are your options?</p>
<p>There&#39;s the standard library, which includes <a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html">VecDeque</a>.
This implements a ring buffer, and the name comes from &#34;Vec&#34; (Rust&#39;s growable array type) combined with &#34;Deque&#34; (a double-ended queue).
As this is in the standard library, this is quite accessible from most code, and it&#39;s a <em>growable</em> ring buffer.
This means that the pop/push operations will always be efficient, but if your buffer is full it will result in a resize operation.
The amortized running time will still be O(1) for insertion, but you incur the cost all at once when a resize happens, rather than at each insertion.</p>
<p>You can enforce size limits in your code, if you want to avoid resize operations.
Here&#39;s an example of how you could do that.
You check if it&#39;s full first, and if so, you remove something to make space for the new element.</p>
<pre data-lang="rust"><code data-lang="rust"><span>let</span><span> buffer: VecDeque&lt;</span><span>u32</span><span>&gt; </span><span>= </span><span>VecDeque::with_capacity(</span><span>10</span><span>);
</span><span>
</span><span>for</span><span> thing </span><span>in </span><span>0</span><span>..</span><span>15 </span><span>{
</span><span>  </span><span>// if the buffer is already full, remove the first element to make space
</span><span>  </span><span>if</span><span> buffer.</span><span>len</span><span>() </span><span>== </span><span>10 </span><span>{
</span><span>    buffer.</span><span>pop_front</span><span>();
</span><span>  }
</span><span>
</span><span>  buffer.</span><span>push_back</span><span>(thing);
</span><span>}
</span></code></pre>
<p>There are also libraries that can enforce this for you!
For example, <a href="https://crates.io/crates/circular-buffer">circular-buffer</a> implements a ring buffer.
It has a fixed max capacity and won&#39;t resize on you, instead overwriting elements when you run out of space.
The size is set at compile time, though, which can be great or can be a constraint that&#39;s hard to meet.
There is also <a href="https://crates.io/crates/ringbuffer">ringbuffer</a>, which gives you a fixed size buffer that&#39;s heap allocated at runtime.
That buys you some flexibility, with the drawback of being heap-based instead of stack-based.</p>
<p>I&#39;m definitely reaching for a library when I need a non-growable ring buffer in Rust now.
There are some good choices, and it saves me the trouble of having to manually enforce size limits.</p>
<hr/>


</div><p>
    If this post was enjoyable or useful for you, <strong>please share it!</strong>
    If you have comments, questions, or feedback, you can email <a href="mailto:me@ntietz.com">my personal email</a>.
    To get new posts and support my work, subscribe to the <a href="https://www.ilograph.com/newsletter/">newsletter</a>. There is also an <a href="https://www.ilograph.com/atom.xml">RSS feed</a>.
  </p></div>
  </body>
</html>
