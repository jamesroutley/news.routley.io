<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://arunmani.in/articles/highest-two-power-to-divide-a-number/">Original</a>
    <h1>Why is x &amp; -x equal to the largest power of 2 that divides x?</h1>
    
    <div id="readability-page-1" class="page"><article><p>25 May 2024</p><figure><img src="https://arunmani.in/articles/highest-two-power-to-divide-a-number/cover.webp" alt="cover.webp"/></figure><p>I recently read in a book that <code>x &amp; -x</code> equals to the largest power of <code>2</code> that
divides <code>x</code>. For example, <code>13 &amp; -13</code> is <code>1</code> (<code>2^0</code>), <code>24 &amp; -24</code> is <code>8</code> (<code>2^3</code>),
<code>14 &amp; -14</code> is <code>2</code> (<code>2^1</code>). Here <code>&amp;</code> means <em>bitwise <code>AND</code></em>. May be this is just
me, but after reading it, I was not able to understand the <em>reasoning</em>.
Obviously, <code>&amp;</code> is a bitwise operator and <code>2</code> is the base, so there is a
connection. But what is the connection <em>actually</em>?</p><h2 id="representation-of-negative-numbers-in-binary">Representation of Negative Numbers in Binary</h2><p>We should actually start with how numbers are represented in binary. In binary,
we have only two digits; <code>0</code> and <code>1</code>. To represent a number, we break it up into
a sum of powers of <code>2</code>. But each power should occur only once. So <code>13</code> is
written as <code>13 = 8 + 4 + 1</code>. If we include all the <em>missing</em> powers, then it
will be written as <code>13 = 1*8 + 1*4 + 0*2 + 1</code>. Now pick out all those <code>0</code>s and
<code>1</code>s before every power and write them in the decreasing orders of their power.
Hence <code>13 = 1101</code> in base <code>2</code>. I agree, this is a terrible explanation, but if
you contrast with how we represent in base <code>10</code>, that is, decimal, then it
should make sense. For example, <code>13 = 1*10 + 3*1</code>. Or better, prefer <a href="https://en.wikipedia.org/wiki/Binary_number">Binary
number - Wikipedia</a>. Remember that
<code>2^0 = 10^0 = 1</code>.</p><p>Coming back to negative numbers, we have two ways to represent them, oneâ€™s
complement and twoâ€™s complement. Let us assume that all our numbers are going to
represented in size of <code>6</code> bits. So <code>13 = 001 101</code> (space for readability).</p><p>Generally, for negative numbers, you reserve the first bit for sign. So, if the
first bit is <code>0</code>, it means the number is positive, else, if it is <code>1</code>, then the
number is negative. Effectively, by this reservation, you are left with only
five bits for the magnitude of the number, so we can only represent numbers from
<code>-32</code> to <code>+31</code> (inclusive).</p><h3 id="ones-complement">Oneâ€™s Complement</h3><p>In oneâ€™s complement, to store a negative number, you invert all the bits in the
positive representation of the number.</p><p>Take <code>-13</code>. With six bits, binary-form of <code>13</code> is <code>001 101</code>. Inverting the bits
gives <code>110 010</code>.</p><h3 id="twos-complement">Twoâ€™s Complement</h3><p>In twoâ€™s complement, we invert all the bits of the number and then add <code>1</code>.</p><p>So for <code>13</code>, inverting all the bits gives <code>110 010</code>. Now add <code>1</code> to it.
Therefore <code>-13</code> in twoâ€™s complement is <code>110 011</code>.</p><p>Or in other words, we find the oneâ€™s complement and add <code>1</code> to it.</p><p>Coming back to our original concern, <code>x &amp; -x</code> gives you the largest power of <code>2</code>
that divides <code>x</code> only when <code>-x</code> is represented in twoâ€™s complement.</p><p>Thankfully, twoâ€™s complement is the most used format, at least in computers, as
per <a href="https://en.wikipedia.org/wiki/Signed_number_representations">Signed number representations -
Wikipedia</a>.</p><blockquote><p>There is no definitive criterion by which any of the representations is
universally superior. <em>For integers, the representation used in most current
computing devices is twoâ€™s complement</em>, although the Unisys ClearPath Dorado
series mainframes use onesâ€™ complement.</p></blockquote><h2 id="largest-power-of-2">Largest Power of 2</h2><p>We have a nice <em>mathemagical</em> property involving the largest power of <code>b</code> in
base <code>b</code> format.</p><p>In decimal, if a number is followed by <code>k</code> zeroes, then it is divisible by
<code>10^k</code>. For example, <code>1305200</code> is divisible by <code>100</code>, that is, <code>10^2</code>.</p><p>The same happens in binary too. <code>110 000</code> (<code>48</code>) is divisible by <code>10 000</code> (<code>16</code>),
that is, <code>2^4</code>.</p><h2 id="decoding-x---x">Decoding <code>x &amp; -x</code></h2><p>Having understood the above sections (you did right ðŸ˜¿?), we can now decode <code>x &amp; -x</code>.</p><p>From the previous section, we can say <code>x &amp; -x</code> gives you a number <code>y</code> whose
binary representation ends with <code>k</code> number of consecutive zeroes such that <code>y = 2^k</code> divides <code>x</code>.</p><p>Now we can rephrase our question as <em>why does <code>x &amp; -x</code> give you a number whose
binary representation ends with <code>k</code> number of consecutive zeroes?</em></p><p>Or more directly, we can say, <code>x</code> ends with <code>k</code> number of consecutive zeroes. So
we need to do some operation, which can give us a number whose binary form is
<code>100...{k number of zeroes}</code>.</p><p>The above statement is our ultimate clue and <code>-x</code> is the crux of the operation.</p><p>Say <code>x</code> ends with <code>k</code> zeroes. This means in binary, the number is like the
following.</p><pre tabindex="0"><code>x = VARIABLE_PART 1 CONSTANT_PART
</code></pre><p>Here <code>VARIABLE_PART</code> means a stream of <code>0</code>s and <code>1</code>s, we donâ€™t care about
actually. <code>CONSTANT_PART</code> is a group of <code>k</code> number of zeroes. <sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup></p><p>Now take <code>-x</code>. Remember how <code>-x</code> in twoâ€™s complement is equal to oneâ€™s
complement of <code>x</code> plus <code>1</code>?</p><pre tabindex="0"><code>-x = INVERT(VARIABLE_PART) INVERT(1) INVERT(CONSTANT_PART) + 1
</code></pre><p>Ignore <code>INVERT(VARIABLE_PART)</code>. It can be anything and is none of our concern.
But look at <code>INVERT(CONSTANT_PART)</code>. We know <code>CONSTANT_PART</code> is a collection of
<code>k</code> zeroes. So what happens when you invert them? They become a collection of
<code>k</code> ones!</p><p>Okay, so what happens when you add <code>1</code> to a collection of <code>k</code> ones? You will get
a number whose binary form has <code>1</code> followed by <code>k</code> zeroes.</p><pre tabindex="0"><code> 111...k 1s...111 
 +              1
-----------------
1000...k 0s...000
</code></pre><p>But in our case, as we have <code>INVERT(VARIABLE_PART) INVERT(1)</code> as the prefix, the
<em>carry</em> <code>1</code> generated by adding <code>1</code> to a <code>k</code> number of ones, will be added to
<code>INVERT(1)</code>.</p><p><code>INVERT(1)</code> is <code>0</code>, so <code>0 + 1</code> equals <code>1</code>. Effectively this means, <code>-x</code> is like
the following.</p><pre tabindex="0"><code>-x =
     INVERT(VARIABLE_PART) INVERT(1) INVERT(CONSTANT_PART) 
     +                                                   1
     -----------------------------------------------------
   = INVERT(VARIABLE_PART) INVERT(1) 111111...k 1s...11111
     +                                                   1
     -----------------------------------------------------
   = INVERT(VARIABLE_PART) INVERT(1) 000000...k 0s...00000
     +                            1 (from carry)
     -----------------------------------------------------
   = INVERT(VARIABLE_PART)        0  000000...k 0s...00000
     +                            1 (from carry)
     -----------------------------------------------------
   = INVERT(VARIABLE_PART)        1  000000...k 0s...00000
</code></pre><p>Phew that was quite long (at least to type out). Now we just need to bitwise
<code>AND</code> the result with <code>x</code>. So <code>x &amp; -x</code> is like the following.</p><pre tabindex="0"><code>x  = VARIABLE_PART                1         CONSTANT_PART
   = VARIABLE_PART                1  000000...k 0s...00000

-x = INVERT(VARIABLE_PART) INVERT(1) INVERT(CONSTANT_PART) + 1 
   = INVERT(VARIABLE_PART)        1  000000...k 0s...00000

 x = VARIABLE_PART         1 000000...k 0s...00000
-x = INVERT(VARIABLE_PART) 1 000000...k 0s...00000

x &amp; -x =
         VARIABLE_PART         1 000000...k 0s...00000
       &amp; INVERT(VARIABLE_PART) 1 000000...k 0s...00000
         ---------------------------------------------
       = 0000...zeroes...00000 1 000000...k 0s...00000
</code></pre><p>Observe how <code>VARIABLE_PART &amp; INVERT(VARIABLE_PART)</code> neatly cancels to a bunch of
zeroes. The remaining number we have got is a <code>1</code> followed by <code>k</code> number of
zeroes. That is, we got <code>2^k</code> ðŸ˜Ž.</p><h2 id="conclusion">Conclusion</h2><p>There are <em>numerous numeric</em> properties we take for granted but there are a few
which are like <em>wait, what?!</em>. I donâ€™t know about you, but when I first read
about <code>x &amp; -x</code>, my brain went through an infinite loop, wondering why. I was
able to understand the reasoning only after thinking about how twoâ€™s complement
forms the base of logic.</p><p>Do you know that twoâ€™s complement of <code>x</code> equals <code>2^N - x</code>, where <code>N</code> is the
number of bits for storage? Can you guess why <code>2^N - x</code> equals oneâ€™s complement
plus <code>1</code>?</p><p>Hope you enjoyed reading. Please let me know of your thoughts and my mistakes
via the links in the footer. Sorry if I went a bit off.</p><h2 id="notes">Notes</h2></article></div>
  </body>
</html>
