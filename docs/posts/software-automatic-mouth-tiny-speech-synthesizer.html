<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/s-macke/SAM">Original</a>
    <h1>Software Automatic Mouth â€“ Tiny Speech Synthesizer</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto">Software Automatic Mouth - Tiny Speech Synthesizer</p>

<p dir="auto">Sam is a very small Text-To-Speech (TTS) program written in C, that runs on most popular platforms.
It is an adaption to C of the speech software SAM (Software Automatic Mouth) for the Commodore C64 published
in the year 1982 by Don&#39;t Ask Software (now SoftVoice, Inc.). It includes a Text-To-Phoneme converter called reciter and a Phoneme-To-Speech routine for the
final output. It is so small that it will work also on embedded computers. On my computer it takes
less than 39KB (much smaller on embedded devices as the executable-overhead is not necessary) of disk space and is a fully stand alone program.
For immediate output it uses the SDL-library, otherwise it can save .wav files.</p>
<p dir="auto">An online version and executables for Windows can be found on the web site: <a href="http://simulationcorner.net/index.php?page=sam" rel="nofollow">http://simulationcorner.net/index.php?page=sam</a></p>

<p dir="auto">Simply type &#34;make&#34; in your command prompt.
In order to compile without SDL remove the SDL statements from the CFLAGS and LFLAGS variables in the file &#34;Makefile&#34;.</p>
<p dir="auto">It should compile on every UNIX-like operating system. For Windows you need Cygwin or MinGW( + libsdl).</p>

<p dir="auto">Take a look at <a href="https://github.com/vidarh/SAM">https://github.com/vidarh/SAM</a> for a more refactored and cleaner version of the code.</p>

<p dir="auto">type</p>

<p dir="auto">for the first output.</p>
<p dir="auto">If you have disabled SDL try</p>
<div data-snippet-clipboard-copy-content="./sam -wav i_am_sam.wav I am Sam"><pre><code>./sam -wav i_am_sam.wav I am Sam
</code></pre></div>
<p dir="auto">to get a wav file. This file can be played by many media players available for the PC.</p>
<p dir="auto">you can try other options like
-pitch number
-speed number
-throat number
-mouth number</p>
<p dir="auto">Some typical values written in the original manual are:</p>
<div data-snippet-clipboard-copy-content="DESCRIPTION          SPEED     PITCH     THROAT    MOUTH
Elf                   72        64        110       160
Little Robot          92        60        190       190
Stuffy Guy            82        72        110       105
Little Old Lady       82        32        145       145
Extra-Terrestrial    100        64        150       200
SAM                   72        64        128       128"><pre><code>DESCRIPTION          SPEED     PITCH     THROAT    MOUTH
Elf                   72        64        110       160
Little Robot          92        60        190       190
Stuffy Guy            82        72        110       105
Little Old Lady       82        32        145       145
Extra-Terrestrial    100        64        150       200
SAM                   72        64        128       128
</code></pre></div>
<p dir="auto">It can even sing
look at the file &#34;sing&#34;
for a small example.</p>
<p dir="auto">For the phoneme input table look in the Wiki.</p>
<p dir="auto">A description of additional features can be found in the original manual at
<a href="http://www.retrobits.net/atari/sam.shtml" rel="nofollow">http://www.retrobits.net/atari/sam.shtml</a>
or in the manual of the equivalent Apple II program
<a href="http://www.apple-iigs.info/newdoc/sam.pdf" rel="nofollow">http://www.apple-iigs.info/newdoc/sam.pdf</a></p>

<p dir="auto">This program (disassembly at <a href="http://hitmen.c02.at/html/tools_sam.html" rel="nofollow">http://hitmen.c02.at/html/tools_sam.html</a>) was converted semi-automatic into C by converting each assembler opcode.
e. g.</p>
<div data-snippet-clipboard-copy-content="lda 56		=&gt;	A = mem[56];
jmp 38018  	=&gt;	goto pos38018;
inc 38		=&gt;	mem[38]++;
.			.
.			."><pre><code>lda 56		=&gt;	A = mem[56];
jmp 38018  	=&gt;	goto pos38018;
inc 38		=&gt;	mem[38]++;
.			.
.			.
</code></pre></div>
<p dir="auto">Then it was manually rewritten to remove most of the
jumps and register variables in the code and rename the variables to proper names.
Most of the description below is a result of this rewriting process.</p>
<p dir="auto">Unfortunately it is still unreadable. But you should see from where I started :)</p>

<p dir="auto">First of all I will limit myself here to a very coarse description.
There are very many exceptions defined in the source code that I will not explain.
Also a lot of code is unknown for me e. g. Code47503.
For a complete understanding of the code I need more time and especially more eyes have a look on the code.</p>
<h2 dir="auto"><a id="user-content-reciter" aria-hidden="true" href="#reciter"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Reciter</h2>
<p dir="auto">It changes the english text to phonemes by a ruleset shown in the wiki.</p>
<p dir="auto">The rule
&#34; ANT(I)&#34;,	&#34;AY&#34;,
means that if he find an &#34;I&#34; with previous letters &#34; ANT&#34;, exchange the I by the phoneme &#34;AY&#34;.</p>
<p dir="auto">There are some special signs in this rules like
#
&amp;
@
^
+
:
%
which can mean e. g. that there must be a vocal or a consonant or something else.</p>
<p dir="auto">With the -debug option you will get the corresponding rules and the resulting phonemes.</p>
<h2 dir="auto"><a id="user-content-output" aria-hidden="true" href="#output"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Output</h2>
<p dir="auto">Here is the full tree of subroutine calls:</p>
<p dir="auto">SAMMain()
Parser1()
Parser2()
Insert()
CopyStress()
SetPhonemeLength()
Code48619()
Code41240()
Insert()
Code48431()
Insert()</p>
<div data-snippet-clipboard-copy-content="Code48547
	Code47574
		Special1
		Code47503
		Code48227"><pre><code>Code48547
	Code47574
		Special1
		Code47503
		Code48227
</code></pre></div>
<p dir="auto">SAMMain() is the entry routine and calls all further routines.
Parser1 transforms the phoneme input and transforms it to three tables
phonemeindex[]
stress[]
phonemelength[] (zero at this moment)</p>
<p dir="auto">This tables are now changed:</p>
<p dir="auto">Parser2 exchanges some phonemes by others and inserts new.
CopyStress adds 1 to the stress under some circumstances
SetPhonemeLength sets phoneme lengths.
Code48619 changes the phoneme lengths
Code41240 adds some additional phonemes
Code48431 has some extra rules</p>
<p dir="auto">The wiki shows all possible phonemes and some flag fields.</p>
<p dir="auto">In the function PrepareOutput() these tables are partly copied into the small tables:
phonemeindexOutput[]
stressOutput[]
phonemelengthOutput[]
for output.</p>
<h2 dir="auto"><a id="user-content-final-output" aria-hidden="true" href="#final-output"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Final Output</h2>
<p dir="auto">Except of some special phonemes the output is build by a linear combination:</p>
<div data-snippet-clipboard-copy-content="A =   A1 * sin ( f1 * t ) +
      A2 * sin ( f2 * t ) +
      A3 * rect( f3 * t )"><pre><code>A =   A1 * sin ( f1 * t ) +
      A2 * sin ( f2 * t ) +
      A3 * rect( f3 * t )
</code></pre></div>
<p dir="auto">where rect is a rectangular function with the same periodicity like sin.
It seems really strange, but this is really enough for most types of phonemes.</p>
<p dir="auto">Therefore the above phonemes are converted with some tables to
pitches[]
frequency1[]  =  f1
frequency2[]  =  f2
frequency3[]  =  f3
amplitude1[]  =  A1
amplitude2[]  =  A2
amplitude3[]  =  A3</p>
<p dir="auto">Above formula is calculated in one very good omptimized routine.
It only consist of 26 commands:</p>
<div data-snippet-clipboard-copy-content="48087: 	LDX 43		; get phase	
CLC		
LDA 42240,x	; load sine value (high 4 bits)
ORA TabAmpl1,y	; get amplitude (in low 4 bits)
TAX		
LDA 42752,x	; multiplication table
STA 56		; store 

LDX 42		; get phase
LDA 42240,x	; load sine value (high 4 bits)
ORA TabAmpl2,y	; get amplitude (in low 4 bits)
TAX		
LDA 42752,x	; multiplication table
ADC Var56	; add with previous values
STA 56		; and store

LDX 41		; get phase
LDA 42496,x	; load rect value (high 4 bits)
ORA TabAmpl3,y	; get amplitude (in low 4 bits)
TAX		
LDA 42752,x	; multiplication table
ADC 56		; add with previous values

ADC #136		
LSR A		; get highest 4 bits
LSR A		
LSR A		
LSR A		
STA 54296	;SID   main output command"><pre><code>48087: 	LDX 43		; get phase	
CLC		
LDA 42240,x	; load sine value (high 4 bits)
ORA TabAmpl1,y	; get amplitude (in low 4 bits)
TAX		
LDA 42752,x	; multiplication table
STA 56		; store 

LDX 42		; get phase
LDA 42240,x	; load sine value (high 4 bits)
ORA TabAmpl2,y	; get amplitude (in low 4 bits)
TAX		
LDA 42752,x	; multiplication table
ADC Var56	; add with previous values
STA 56		; and store

LDX 41		; get phase
LDA 42496,x	; load rect value (high 4 bits)
ORA TabAmpl3,y	; get amplitude (in low 4 bits)
TAX		
LDA 42752,x	; multiplication table
ADC 56		; add with previous values

ADC #136		
LSR A		; get highest 4 bits
LSR A		
LSR A		
LSR A		
STA 54296	;SID   main output command
</code></pre></div>
<p dir="auto">The rest is handled in a special way. At the moment I cannot figure out in which way.
But it seems that it uses some noise (e. g. for &#34;s&#34;) using a table with random values.</p>

<p dir="auto">The software is a reverse-engineered version of a software
published more than 34 years ago by &#34;Don&#39;t ask Software&#34;.</p>
<p dir="auto">The company no longer exists. Any attempt to contact the original
authors failed. Hence S.A.M. can be best described as Abandonware
(<a href="http://en.wikipedia.org/wiki/Abandonware" rel="nofollow">http://en.wikipedia.org/wiki/Abandonware</a>)</p>
<p dir="auto">As long this is the case I cannot put my code under any specific open
source software license. However the software might be used under the
&#34;Fair Use&#34; act (<a href="https://en.wikipedia.org/wiki/FAIR_USE_Act" rel="nofollow">https://en.wikipedia.org/wiki/FAIR_USE_Act</a>) in the USA.</p>

<p dir="auto">If you have questions don&#39; t hesitate to ask me.
If you discovered some new knowledge about the code please mail me.</p>
<p dir="auto">Sebastian Macke
Email: <a href="mailto:sebastian@macke.de">sebastian@macke.de</a></p>
</article>
          </div></div>
  </body>
</html>
