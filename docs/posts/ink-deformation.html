<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.inkandswitch.com/ink/notes/ink-deformation-review/">Original</a>
    <h1>Ink deformation</h1>
    
    <div id="readability-page-1" class="page"><div>
<dl>
<p><dt>title</dt><dd>Ink Deformation - a review</dd></p>
<p><dt>dated</dt><dd>Q3 2025</dd></p>
</dl>

<p>Freehand digital ink is an incredibly direct and fluid input method: It allows you to quickly jot down your ideas without any need for formalization.</p>
<p>One of the main benefits of using digital ink over traditional pen &amp; paper, is the ability change the properties of ink <em>after</em> you’ve drawn it, rather than needing to redraw from scratch. This ability also opens the door to end-user-programmability, as we can dynamically change properties based on computations.</p>
<p>There’s a number of different changes you might want to make such as changing the color or position of a drawing, which we understand pretty well.</p>
<p>But, once you’ve drawn a stroke you might also want to change its <em>shape</em>. That is, to <em>deform</em> it. This could be relatively minor manual tweaks, such as resizing a box to make more space inside, or changing where an arrow points. It could also be more complex dynamically driven behaviour, such as a parametric <a href="https://www.inkandswitch.com/ink/notes/sketchy-cad">sketchy CAD</a> model, or perhaps bending a characters’ arm.</p>

<p>Of course, if we were using a vector graphics tool, deforming shapes would be easy. Vector drawing tools provide a highly editable format that allows you to tweak positions exactly. Points, lines &amp; bezier curves make a good match for computational dynamic behaviour, and we’ve explored end-user-programming with these primitives extensively in <a href="https://www.inkandswitch.com/project/crosscut/">Crosscut</a>.</p>
<p>However, for the most part, vector graphics lack the directness and fluidity of hand-drawn ink, instead requiring a lot of detailed and finicky manipulation.</p>
<p>We can separate representations along two axis: the first is how <em>neat</em> a drawing is. A back-of-the-napkind sketch is less neat than an illustration in a textbook. The second, the extent to which it is <em>computational</em> or <em>dynamic</em>. A CAD model is more dynamic than a textbook. We’re looking for a solution in the top right quandrant. Informal, but dynamic.</p>
<figure>
<img src="https://www.inkandswitch.com/ink/notes/ink-deformation-review/neatness_dynamism.png"/>
</figure>
<p>Is there some way that we can maintain the directness and fluidity of hand-drawn ink, while adding the ability to manipulate shapes dynamically? Ideally, we’d do this by using <a href="https://www.inkandswitch.com/ink/notes/formality-on-demand">formality on demand</a>, allowing the user to add structure only when needed.</p>
<p>We believe that this is a crucial ingredient for programmable ink. But, it has so far proven tricky to get right. We want a model of freehand ink deformation that resolves this tension between <em>freehand sketches</em> and <em>formal geometry</em>. We want a system that allows the user to deform drawings both manually and programmatically, creating a smooth onramp between the two.</p>
<p>There’s a wide array of approaches to ink deformation, but, broadly speaking, we can break the problem down into three main steps:</p>
<ol>
<li>Finding some kind of control structure; Something that the user can manipulate more readily than messy, hand-drawn ink strokes.</li>
<li>Finding a <em>mapping</em> between the messy geometry and the simplified control structure.</li>
<li>When deforming the control structure, use the mapping to deform the original geometry.</li>
</ol>
<p>The big open questions in relation to programmable ink are:</p>
<ul>
<li>How to create the control structure, either automatically/manually.</li>
<li>How to make the control structure <i>match the underlying <em>meaning</em></i> of your sketch.
</li>
<li>Finding a mapping between control structure and geometry. Either automatically in way that correctly maps to the conceptual model, or, manually in a way that doesn’t require a lot of complex actions, or, some hybrid approach that allows the user to tweak the mapping.</li>
<li>Supporting a wide range of deformations from simple (formal) geometric shapes (lines, arcs, curves, rectangles etc), up to complex, higher level deformations like bending a character’s arm.</li>
</ul>
<p>Below is an overview of the different techniques ` considered so far. There is overlap between the different categories, so don’t take the categories too strictly.</p>

<p>The simplest, and perhaps most “obvious” way to deform ink is to turn ink-strokes into simplified vector geometry. The resulting splines can then be deformed like you would do in a vector-drawing application; by manipulating handles.</p>
<p>There’s significant overlap here with stroke simplification, and in fact, many vector drawing programs implement a ‘pencil’ tool that allows you to draw freely, and then manipulate the control points of the spline to deform the geometry.</p>
<p>Algorithms for curve fitting are readily available though they aren’t necessarily trivial to <em>get right</em>. Producing a simplified stroke that looks good, does not mean that the resulting control points are useful for deformation. Figuring out the right number of control points requires heuristics and parameter tuning.</p>
<figure>
<img src="https://www.inkandswitch.com/ink/notes/ink-deformation-review/pencil_tool.png"/>
<figcaption>
<p>Figma’s pencil tool allows you to draw bezier curves (right). Even though the shape was drawn with sharp corners, the tool creates rounded corners as a result of simplification. The resulting control points do not allow you to deform the shape asif it were a rectangle (left)</p>
</figcaption>
</figure>
<p>More importantly though, this approach really only works well for “clean” ink strokes, where the geometry is relatively simple and the number of resulting control points is low. In a sketchy environment, where the ink is messy and there is over-drawing, this approach can quickly become unwieldy. Because the mapping is per-stroke, it basically doesn’t work for higher level deformations like bending a character’s arm or twisting a shape.</p>
<ul>
<li>In the <a href="https://www.inkandswitch.com/project/habitat/">Habitat project</a> we explored <a href="https://www.inkandswitch.com/ink/notes/habitat-atelier">a slightly more sophisticated approach</a> which distinguishes between straight lines (with sharp corners) and curves. It also automatically joined separate strokes at the end-points. This more closely maps conceptual control points to drawn ink geometry.</li>
<li>One possible way to avoid stroke simplification entirely is to make a distinction between <a href="">formal and informal ink</a> Formal ink would effectively be what we consider to be vector graphics, while informal ink is purely freehand geometry.dy. Because the mapping is per-stroke, it basically doesn’t work for higher level deformations like bending a character’s arm or twisting a shape.</li>
</ul>

<p>A more direct way of deforming ink is to push and pull on it as if it were material, we’ve explored several approaches in this bucket. The main advantage of this approach is that it requires very little in the way of control structure (usually just the position of your finger).</p>
<p><strong>String</strong>: We’ve tried several times to explore the idea of deforming ink by <i>treating ink strokes as a piece of string</i>. By applying forces to the string (pushing &amp; pulling) you can then deform ink strokes.</p>

<ul>
<li>Szymon explored the idea of using an <a href="https://www.inkandswitch.com/ink/notes/nurbs-strings/#2019-04-12">IK-chain</a> to deform ink strokes.</li>
<li>Ivan, similarly, explored a <a href="https://www.inkandswitch.com/ink/notes/informal-ink-deformation/">variant</a> that feels more like a spider web.</li>
</ul>
<p><strong>Nudging</strong>: A nudge tool typically works by applying a force to the geometry with a distance falloff from the cursor or touch point, which creates a smooth deformation effect.
Nudging is useful for fixing small mistakes, but not really for large scale deformation.</p>
<ul>
<li>
<p>The Concepts app has a “Nudge” tool, which warps the ink by influencing the position of the ink. It’s also called “magnet tool”, or “falloff editing” in other software.</p>
</li>
<li>
<p>Early experiments by Szymon also explored <a href="https://www.inkandswitch.com/ink/notes/nurbs-strings/#2019-05-21">nudging NURBS and b-splines</a></p>
</li>
</ul>
<p><strong>Noodlify</strong>: Finally, Marcel came up with the idea of <a href="https://www.inkandswitch.com/ink/notes/playbook-material-studies/#2024-03-17">noodlification</a> which, rather than pulling on a single point, uses selection to <em>pick up</em> a whole chunk of ink. Any strokes that are sliced by the selection are then deformed by stretching them at the cutting point. This gives you much more control over which parts of the drawing stay stable, and which parts are deformed. Technically, this isn’t actually deforming strokes at all, as it’s just inserting new ink between to the stroke segments.</p>


<p>A very simple way to deform ink is to simply scale or stretch it along a single axis. This is perhaps the most straightforward and common way to deform shapes, though it has obvious limitations.</p>
<ul>
<li>Many tools give you a bounding box that you can use to scale and stretch shapes. Some programs like Procreate even allow you to rotate the bounding box <em>relative to the selection</em>, which means you can stretch your drawing along any arbitrary axis (pretty neat).</li>
<li>The <a href="https://www.inkandswitch.com/project/inkling/">Inkling</a> prototype simply stretched ink along a single axis, which was surprisingly effective. Though this only really works in limited cases, and we considered it a temporary ‘cop-out’ rather than a final solution.</li>
</ul>
<p>The most advanced version of this, often called <em>Warping</em>, or <em>Mesh Warp</em>, is a technique that allows you to deform shapes in a flexible way. It involves creating some kind of “cage” around the drawing, in most cases a rectangle.</p>
<ul>
<li>Tools like Procreate &amp; Photoshop have a tool called “Mesh Warp”, which allows you to warp using a 3x3 grid.</li>
<li>In 3D modeling tools this is also known as <em>Lattice deformation</em>.</li>
</ul>

<p>Skeletal deformation is the most common technique used in 2d and 3d graphics to deform shapes. It works by creating a skeleton using “bones”: simple geometry that is superimposed onto the actual geometry. Each point in the original geometry is then mapped to one-or-more bones, which are used to influence the position of the point. The bones can be moved and rotated, and the points in the geometry will deform accordingly.</p>
<p>Typically, the influence of each bone on a point is defined by a <em>weight</em>, which determines how much each bone affects a point.
Each point is transformed by each bone’s matrix, scaled by the points’s weight for that bone. The final position is the sum of those weighted transformed positions. This is called <em>linear-blend skinning</em>. It is a very efficient technique that allows you to create complex deformations, and so it is common in games.</p>
<p>Of course, in-and-of-itself this does not give us a full deformation system, as we still need a way to define the bones and their weights. In most software this is done almost entirely manually, which is effectively a skilled job. A lot of the nuance comes from how the bones are structured (rigging), and how the weights are assigned, a process which is called <em>weight painting</em>.</p>
<p>The big challenge for us then, is finding an approach that allows us to surface these things without requiring complex UI or a lot of manual work.</p>
<p>Automatically generating bones (rigging), or automatically assigning weights (weight painting) are both active research areas, and there are plenty of published papers on the topic.</p>
<p>For automatic weights, a common set of techniques is called <em>bone heat weighting</em>, <a href="https://www.wolfire.com/blog/2009/11/volumetric-heat-diffusion-skinning/">volumetric heat diffusion skinning</a>, or <a href="https://graphics.pixar.com/library/HarmonicCoordinates/paper.pdf">harmonic coordinates</a>.</p>
<ul>
<li>
<p>Blender3d implements bone heat weighting as a feature.</p>
</li>
<li>
<p>Marcel implemented a variant of <a href="https://www.inkandswitch.com/ink/notes/etui-studies/#23-07-2025">bone-heat weighting</a>, which is what we’re currently using in Playbook. The heat diffusion step is relatively expensive, but is a massively paralelizable operation, which makes it suitable for GPU implementation.</p>
</li>
<li>
<p>A different technique is described in <a href="https://igl.ethz.ch/projects/bbw/bounded-biharmonic-weights-siggraph-2011-jacobson-et-al.pdf">Bounded Biharmonic Weights for Real-Time Deformation</a>. This gives great, even somewhat physically plausible results, though it seems significantly more complex to implement.</p>
</li>
</ul>
<p>Automatic rigging seems the more difficult problem, and seems to rely much more on heuristics and <a href="https://zhan-xu.github.io/rig-net/">machine learning</a>. Any known techniques are also less obviously applicable to our context, and the more useful results are to be found in Sketch simplification. Some papers that might be relevant here are:</p>
<ul>
<li><a href="https://gaoxifeng.github.io/papers/2019/SketchSimplification.pdf">Sketch simplification guided by complex
agglomeration</a></li>
<li><a href="https://www.cs.ubc.ca/labs/imager/tr/2022/SketchConnectivity/SketchConnectivity_authorversion.pdf">Detecting Viewer-Perceived Intended Vector Sketch Connectivity</a></li>
</ul>


<p>A combination of skeletal deformation and mesh-warp, you can generalize your cage-shape to arbitrary closed polygons, which is sometimes called <em>free-form deformation</em>. There are many possible ways to compute mapping between geometry and cage, including: distance fields, barycentric coordinates, <a href="https://cgvr.informatik.uni-bremen.de/teaching/cg_literatur/barycentric_floater.pdf">mean value coordinates</a>, <a href="https://www.mn.uio.no/math/english/people/aca/michaelf/papers/wach_mv.pdf">wachspress coordinates</a>, <a href="https://www.wisdom.weizmann.ac.il/~ylipman/GC/gc_techrep.pdf">green coordinates</a>, <a href="https://graphics.pixar.com/library/HarmonicCoordinates/paper.pdf">harmonic coordinates</a>. It’s relatively straight forward to do this for convex hulls, though it’s significantly more complex for concave geometry.</p>
<ul>
<li>Marcel explored some of this in the <a href="">Etui study</a>.</li>
</ul>

<p>There are a number of different techniques that try to approximate physically accurate deformation of shapes, as if they were made of some sort of material. These techniques typically involve some kind of solver that computes the deformation based on the forces applied to the geometry.</p>
<p>The simplest way to implement this is as a mass-spring system, which is sometimes called <em>Soft-body dynamics</em>. The geometry is represented as a set of points connected by springs. When you apply a force, the solver computes how the points move based on the forces applied to them and the spring constants. This gives a squishy, bouncy effect which makes it popular in games and simulations.</p>
<ul>
<li>Marcel implemented a <a href="https://www.inkandswitch.com/ink/notes/informal-ink-deformation/">simple mass-spring</a> deformation system.</li>
</ul>
<p>Unfortunately, mass-spring systems are also very unstable, making them unsuitable for our purposes. Though there are techniques which improve stability such as <em>shape matching</em>. There are other approaches that are more stable, the most well known is described in <a href="https://www-ui.is.s.u-tokyo.ac.jp/~takeo/papers/rigid.pdf">As-rigid as possible deformation</a></p>
<ul>
<li>Tools such as Photoshop implement ARAP and typically call it <em>Puppet Warp</em>.</li>
</ul>
<p>You can push this further to get more realistic physics using techniques such as Position Based Dyanamics. Some examples <a href="https://yoharol.github.io/pages/control_pbd/final.pdf">here</a>, and <a href="https://mmacklin.com/neohookean.pdf">here</a></p>
<p>The main drawback of all these techniques is that they require running a solver, making them very computationally expensive, which is not ideal in a real-time environment. Especially compared to the other forms of deformation which are increadibly cheap in comparison. Secondly, it’s not uncommon to want deformations that go beyond “physically accurate”, in which case a lot of these techniques are prone to numerical instability.</p>
  </div></div>
  </body>
</html>
