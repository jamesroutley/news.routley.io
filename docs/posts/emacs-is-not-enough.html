<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://project-mage.org/emacs-is-not-enough">Original</a>
    <h1>Emacs Is Not Enough</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
<ul><li><a href="https://project-mage.org/the-power-of-structure.html">
← The Power of Structure
</a></li>
<li><a href="https://project-mage.org/on-flexibility.html">
On Flexibility and Software Temples →
</a></li></ul>

<p>(Published: 12 January 2023)</p>


<p>
<i>(Dear reader, I sometimes will call you &#34;anon&#34; in this article. Just treat it as a literary device.</i>)
</p>

<p>
—
</p>

<p>I have a feeling that the changes that would help are deeper issues than the shape of corners.</p>


<p>
The Emacs reputation has been that of a strange piece of software that grants you powers if you were to just take them.
</p>

<p>
The crowd that gets attracted to it are the kind of users who find inefficiencies of interaction with the machine to be supremely annoying. That leads to much tinkering and workflow optimization. 
</p>

<p>
Everyone in that crowd is a power user.
</p>

<p>
And what do you know, a certain level of comfort may, indeed, be reached if you invest yourself into the customization process.
</p>

<p>
And I think anybody who cares about what they do is a power user at heart.
</p>

<figure>
<img src="https://project-mage.org/img/brick.jpg"/>
<figcaption>
<i>Douglas Engelbart&#39;s precursor to the mouse. This one was simply used to convince people that tools matter.</i>
</figcaption></figure>


<p>
Unfortunately, most of us have learned to cope too well with all the shitty tools we have. And, in the current culture, the cult of <i>just getting the job done</i> is too prevalent to overcome that. The fear to take a dive for a long-term benefit overcomes any desire to be comfortable.
</p>

<p>
And then there are the floaters, the passers-by. They judge Emacs solely by its features. 
</p>

<p>
But that&#39;s not how a power users judges it.
Instead, the power user judges a piece of software by what power it provides and what he could do with that power to help himself.
</p>

<p>
So, really, the target audience of Emacs are power users, who often times end up being contributors to the ecosystem in one way or another.
</p>

<p>
Emacs has gained a cult-status of sorts.
The landscape of programs that have positioned themselves quite the way Emacs does is quite empty. And that&#39;s probably why it has gained that status. 
</p>

<p>
Some are convinced it&#39;s immortal and can never be replaced.
</p>

<p>
But it must be said that it&#39;s not Emacs that is somehow too good to be surviving for so long. It&#39;s just that everything else is so bad.
</p>

<p>
—
</p>

<p>
But let&#39;s start waaaay back.
</p>

<p>
What do you remember as a kid, playing in a sandbox? A sand-pile in your backyard, with some other kids?
(I bet there were other kids there, you weren&#39;t a lonely weirdo playing in all that sand by yourself, were you?)
</p>

<p>
What I remember is that a sand-pile by itself is never enough.
You need some water. Some larger rocks. Some sticks. Some grass, perhaps.
And a bit of crude imagination to construct a stick figure or a car or something.
But I digress.
</p>

<p>
Get a load of this: 
</p>

<p>
<b>Terry A. Davis of TempleOS draws sprites directly into his fucking terminal.</b>
</p>

<p>
Look at this shit. LOOK!
</p>

<p>
<a href="https://www.youtube.com/watch?v=2eK4QRH22Uk"><img src="https://project-mage.org/img/templeos-graphics.png"/></a>
</p>

<p>
<i>It may even be 3D.</i>
</p>

<p>
That sprite is then embedded into the source code and may be referenced as a pointer.
</p>

<p>
In his terminal, 
</p>

<p>
In his OS, 
</p>

<p>
Using his own compiler of Holy C (with his ACTUALLY useful improvements over C. That, for your interest, takes <i>Divine Intellect.</i>),
</p>

<p>
All running on a resolution of 640x480.
</p>

<p>
Why 640x480? 
</p>

<p>
<b>Cause God said so.</b>
</p>

<p>
That man <a href="https://www.youtube.com/watch?v=ZXn4njGgfkE">communicates with God</a> through a random number generator.
</p>

<p>
Terry is the High Priest.
</p>

<p>
And he loves himself some simplicity.
</p>

<p>
And listen, Terry may seem a little bit arrogant to you, but he actually is <i>the smartest programmer that ever lived</i>.
</p>

<p>
In short, Terry is a decent person. Or was. Till those glowy CIA schmucks finally got him with a GODDAMNED TRAIN. And I would like to think, it would have taken NOTHING less than a BIG ASS SPEEDING TRAIN to do Terry in.
</p>

<p>
Rest in piece, Terry Davis, a true preacher of God&#39;s Word.
</p>

<p>
Eh. Anyhow.
</p>

<p>
<i>(Yes, this article is still about Emacs, keep reading, anon.)</i>
</p>

<p>
Terry preached that you should entertain God.
</p>

<p>
Go rob a bank. Go write <a href="https://www.youtube.com/watch?v=CYQEfLaR4Pg">an advanced flight simulator</a>. 
Or produce a soap opera (god loves those).
</p>

<p>
I think that Terry viscerally understood that this god entertainment business would be an awful lot easier to be doing with graphics, and that&#39;s why it was so <i>integrated</i> in TempleOS.
</p>

<p>
—
</p>

<p>
<a href="https://emacssurvey.org/">Emacs Survey</a> is a funny thing: they ask you to fill it out <i>in a web browser</i>, then they <a href="https://emacs-survey.netlify.app/2020/">provide the results</a> that you can only view <i>in a web browser</i>, and offer you to download CSV data to view it <i>in a spreadsheet application</i>. 
</p>

<p>
Or, well, of course, you could <i>just</i> fill it out in w3m/lynx and then <i>be having fun</i> reading it in <i>fundamental mode</i>. Then you could stamp out <b>AWESOME</b> on your forehead and wear a pair of horns. You could. You certainly could. 
</p>

<p>
<i>But you won&#39;t.</i>
</p>

<p>
Well, I mean, I spent 15 minutes typing out my written responses, and they just put a comma-separated file (CSV) out there? 
How the hell do I even read a CSV file? 
Do I have to install R or something? 
</p>

<p>
LibreOffice is messing up my rows. 
</p>

<p>
But I want a <i>premade interface</i> for it, and I am confused as to why the authors haven&#39;t provided it for me.<span><sup><a id="fnr.2" href="#fn.2">2</a></sup><span> I still find their survey useful, though.</span></span>
</p>

<p>
Maybe because they don&#39;t care about the actual answers there, huh? Were the written responses just an exercise?
</p>

<p>
Or, wait a second, why don&#39;t I go and <i>just read that CSV in Emacs</i>?
Somehow, it wasn&#39;t the first thought that came to my mind, you see.
</p>

<p>
But CSV <i>is</i> text, isn&#39;t it?
</p>

<p>
Well, <a href="https://melpa.org/#/?q=csv">lemme check</a> real quick, because the everpotent Emacs must have a package for working with CSV files. 
</p>

<p>
OK. I see some parsers. Good. Some import library.
Nice. <i>NICE</i>. And an exporter to org-mode clock.
</p>

<p>
Well, OK, but how tf do I read this shit?
</p>

<p>
It looks like spaghetti when I look at it in fundamental mode.
And I get the feeling that my eyes are working a bit faster than Emacs can scroll.
</p>

<p>
Well, alright, I don&#39;t see no <i>CSV-mode</i> to arrange everything into a pretty table and then let me filter/sort/edit the damn thing.
</p>

<p>
<i>But am I really asking for much?</i>
</p>

<p>
Well, no. Thing is, you just can&#39;t do that in Emacs.
</p>

<p>
Did you hear that? 
</p>

<p>
<b><i>You can&#39;t.</i></b>
</p>

<p>
A table editor within emacs will be janky, it will be a slow heap of cowdung, outspreading and dispersing, channeling the fumes. 
</p>

<p>
And guess what, even <b>displaying</b> a structure like that would be a pain in the ass. 
</p>

<p>
And forget about editing it. (Think multi-line boxes for long text fields.) 
</p>

<p>
Yea, well, <i>technically</i>, it&#39;s doable. Alright. Org-mode has tables.
You can even autoformat them after each edit. 
</p>

<p>
<i>But you don&#39;t want that thing to get that much larger than your literal thumbnail.</i>
</p>

<p>
And not that others haven&#39;t tried to do better. Take a look at this presentation: <a href="https://emacsconf.org/2019/talks/18/">Object oriented spreadsheets with example applications</a>. Yeah, it&#39;s a pretty table alright. But the key quote there for the purposes of our discussion is: 
</p>

<p>
<i>It does need to be optimized. It can be a little bit sluggish.</i> 
</p>

<p>
Oh, yes, <i>it can be</i>.
</p>

<p>
FACT: <i>You can&#39;t have a usable table in Emacs. Even if its <b>all text</b>.</i>
</p>

<p>
Yeah, OK, anon, you don&#39;t care about tables. I do, but you don&#39;t. Fine.
</p>

<p>
Maybe you care about Lisp. Maybe you even do some Common Lisp development from time to time.
</p>

<p>
Well, I do Lisp programming in Emacs. Just about everyone does.
</p>

<p>
One of the projects I am using is April. It&#39;s an APL compiler, and lets you work on arrays.
</p>

<p>
So, I have macroexpanded April&#39;s internal <code>vex</code> form, and the macroexpansion was 1.3MB at ~26000 lines of code.
It&#39;s not important why that macroexpansion had to be that big. It simply was.
</p>

<p>
And I wanted to see that expansion.
</p>

<p>
Well, scrolling that thing was not fun, I will tell you that.
Neither was getting spammed with:
</p>

<p>
<code>Parenthesis max limit reached.</code>
</p>

<p>
And then with:
</p>

<p>
<code>Error during redisplay: (jit-lock-function 1207370) signaled (args-out-of-range [nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 0 1 2 3 4 5 6 7 8 9 nil nil nil nil nil nil nil 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 nil nil nil nil nil nil 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil] 8592)</code>
</p>

<p>
Along with:
</p>

<p>
<code>Timed out waiting for property-notify event [5 times]</code>
</p>

<p>
and this:
</p>

<p>
<code>eldoc error: (error Lisp nesting exceeds max-lisp-eval-depth)</code>
</p>

<p>
What is all this?
</p>

<p>
This is not <i>smooth</i>.
</p>

<p>
This is not <i>snappy</i>.
</p>

<p>
This is not <i>cool</i>.
</p>

<p>
Which all begs the question. 
</p>

<p>
Everybody talks about how great Emacs is at Common Lisp.
When I started using it, the greatest part was Common Lisp.
</p>

<p>
Here&#39;s the deal: Emacs is shit at Common Lisp. Slime or Sly, it doesn&#39;t matter.
</p>

<p>
OK, forget about the 1.3MB macroexpansion.
</p>

<p>
How about you go and rename all occurrences of a symbol in all files in your project? Well, guess what, that, too, is a pain in the ass.
Even the built-in renaming facility bugs out on me for some reason (I don&#39;t remember it&#39;s name, because I don&#39;t even try to use it anymore). 
</p>

<p>
And how about importing the current qualified symbol at point into the <code>defpackage</code> definition?
</p>

<p>
<i>No. Too hard.</i>
</p>

<p>
I also like my s-expressions to vary in color based on the nesting levels. I use <code>rainbow-blocks</code> for that, and it works fairly well.
</p>

<p>
Except, of course, when it suddenly stops working occasionally (for some reason unbeknownst to me) and the fontification gets all fucked. 
</p>

<p>
<i>Even if the parentheses are all balanced.</i>
</p>

<p>
Where did this myth come from, the idea that Emacs is some super duper shit for Lisp?
This shit is shit!
</p>

<p>
And yeah, I am not reporting any of it.
The fixes are going to be cardboard patches on the hull of a sinking ship anyway.
If you look closely, <i>the whole ship</i> is mess of cardboard boxes, glue and styrofoam. 
</p>

<p>
And, hey, by the way, what&#39;s that <code>comint</code> crap? Because, anon, using a REPL prompt is a real trip.
</p>

<p>
Why is input not separate from the output?
Srsly, why the fuck are they in the same buffer?
</p>

<p>
My <code>evil-mode</code> cursor behavior around that prompt is fucking ridiculous.
(And, I fear, not just because <code>evil-mode</code> is a buggy pile of crap.)
</p>

<p>
Let me tell you: I shouldn&#39;t end up on that <code>CL-USER&gt;</code> prompt with my cursor, <i>not like fucking ever</i>.
The output should be placed separately, ffs. The input place is simply not where the output should go in a read-eval-print-loop application.
</p>

<p>
Why are they merged into the same place? Well, there&#39;s simply no other way of doing it, that&#39;s why.
Managing window positioning is simply too painful.
</p>

<p>
So… what happened here? Do you know?
</p>

<p>
Let me tell you what happened: <i>Emacs being decrepit</i> is what happened.
</p>

<p>
Look at <code>CIDER</code>. It&#39;s many years old. I install it and what do I see?
The REPL buffer is read-only half of the time.
</p>

<p>
<i>And only some of the print statement output is printed in there.</i>
</p>

<p>
I have no clue why.
</p>

<p>
Is this not a mess? Yes. A goddamn fucking mess.
</p>

<p>
Or, perhaps, ask yourself why you can&#39;t do stuff like <i>multinarrowing</i> (narrowing of multiple parts of a file).
</p>

<p>
Or why you don&#39;t have <i>transclusion</i> (having the same piece of data in various places at once).
</p>

<p>
Or why Emacs can&#39;t do code indentation on proportional fonts.
</p>

<p>
And, listen… when you are coding a function in Elisp, you are basically moving your pointer all over the buffer to do <i>anything at all</i>.
</p>

<p>
Why are you doing that?
</p>

<p>
That&#39;s <i>imperative</i>.
</p>

<p>
More so, the fact of having to move the cursor/point all over the place is <i>worse</i> than just being <i>imperative</i>.
Much worse. Ever heard of LOGO?
</p>

<p>
Well, Elisp might as well be considered the LOGO of the Lisp world, and Emacs is its turtle of text editing.
</p>

<p>
<img src="https://project-mage.org/img/turtle.jpg"/>
</p>

<p>
<i>Emacs: turtle programming for textual matrices</i>.
</p>

<p>
<img src="https://project-mage.org/img/turtle.gif"/>
</p>

<p>
And, so: anything. Anything. Takes. Fucking. <i>Forever.</i> To accomplish.
</p>

<p>
But there&#39;s more, anon. There&#39;s a lot more behind all this.
</p>

<p>
Say, why is Elisp completion always so fucking slow?
</p>

<p>
Why is every language mode so janky as fuck?
</p>

<p>
<i>WHY IS EVERYTHING SO JANKY AF?</i>
</p>

<p>
And, hey, let me <i>not</i> tell you about all the things that are wrong with <a href="https://orgmode.org/">Org-mode</a>. Indentation gets routinely screwed. Try making a footnote with a link in it, find out how much jolly good fun that is. Tags don&#39;t allow dashes or spaces. Tables suck. Exporting is non-transparent. Working with code blocks (<i>org-babel</i>) is just as pure as pain as you can have in front of a computer screen these days. I could go on and on. It&#39;s not worth listing everything.
</p>

<p>
Or, yeah, try truncating lines on the text-only paragraphs, but not on the code blocks.
Can&#39;t do it, can you?
</p>

<p>
And I can&#39;t tell you how fucking tiring it is to be using links.
They aren&#39;t even autoupdating.
Any link to a heading will <i>expire</i> as soon as you modify any path to that link.
So, I have to be doing custom identifiers <i>by hand</i>.
</p>

<p>
And then, every time I hit <code>insert-heading-dwim</code> in a moderately large file
(not even that large at just 172kb), I have to wait for a full second before the heading
appears in the tree. When you edit a list of items, checking an item at point will rescan the
whole tree, because, hey, you gotta <i>rescan and recalculate all that stuff, right?</i>
</p>

<p>
Anon, look, none of this would need to be so bad if the buffer were <b>structured</b>. 
</p>

<p>
&gt; STRUCTURE is a an important word here. It will come up time and time again if you keep reading.
</p>

<p>
Emacs is an editor of textual data, isn&#39;t it? (Yeah, the kind where, hopefully, the lines aren&#39;t too long.)
</p>

<p>
The data structure that Emacs uses is called a <i>gap buffer</i>.
</p>

<p>
A gap buffer.
</p>

<p>
<i>You can&#39;t really impose structure on it beyond that.</i>
</p>

<p>
That&#39;s it. That&#39;s the end of the line. <i>A gap buffer.</i>
</p>

<p>
There are no good mechanisms for imposing structure, except overlays or markers or regexps.
And neither is my idea of a good mechanism. All of it is just duct tape and WD-40.
</p>

<p>
Overlays in emacs track the positions of a piece of string.
They work about as well as throwing mud at the wall and hoping it will stick, like trying to solder a copper wire to an aluminum contact, hoping everything will just stay put and not get loose later on. A quite expensive ugliness which has a very tangible impact on performance.
</p>

<p>
This is why JSON files were slow until <i>core</i> had to be hacked to throw in some optimizations.
Why did it have to be slow in the first place? Well: because highlighting with a regexp is a fucking bad idea.
</p>

<p>
And, yeah, many people have accomplished plenty of mundane things with just duct tape and a can of WD.
Some are even proud of their redneck artistry.
</p>

<p>
But it&#39;s not how you really build stuff.
</p>

<p>
See, things like <a href="https://github.com/alphapapa/org-ql">org-ql</a> (it lets you query an Org-mode buffer) <b>shouldn&#39;t have to exist</b>.
</p>

<p>
<b>What you want is to <i>start with the structure</i> and then simply <i>expose it to the extension author</i>. And it&#39;s not just about the extensions: <i>just about every user function requires some structural knowledge</i>.</b>
</p>

<p>
And in a file where formal structure is expected for correct functioning, <b>it doesn&#39;t make sense <i>not</i> to enforce it at all times</b>.
For a second, just think about what kind of <i>shit</i> you have to go through to get anything working in a <b>structureless</b> document. 
Hmm, let&#39;s see: the obvious one is <i>parsing</i>.  
And well, when something goes awry, and it will, throw in more parsing, but now with some <i>ad-hoc error handling</i>.
And then add <i>caching</i>, because, <i>hey, shit, this thing is working kinda slow, huh?</i> 
Get back to more error handling and more parsing and <i>reparsing</i>,
because that thing is… broken <i>again</i>? Maybe <i>optimize</i> your compiler while you are it. 
Wait, what, <i>caching</i> wasn&#39;t enough?
<i>Everything</i> is still slow and works like crap?
Is it time for some <i>truly clever</i> optimizations and techniques?
Time to <i>really-really</i> roll those sleeves up?
</p>

<p>
Ohhh, but, my friend, here your funny trip across the unstructureland hits something called <b>GRADE-A HEAVY METAL DUTY ASS OF REALITY</b>.
Like a flowery, pink-flavored air bubble, your dream shatters against that cast iron surface and with it go your any hopes of making anything work fast EVER AGAIN. And forget <i>fast</i>: <i><b>well</b></i>. Nothing will ever again work <i><b>well</b></i>.
</p>

<p>
You have a realization:
</p>

<p>
<i>The only way to truly subdue all the mess is to <b>enforce structure</b>. This is the only way to make it right.</i>
</p>

<p>
And by <i>structure</i> I mean a <i>data structure</i> which you can interface directly, with no extra copies in the middle. 
Then your optimization goals are on a much higher level from the start, and, in fact, you probably won&#39;t even have to think about the performance anyway.
</p>

<p>
Forget all that jackjob mud-hut garbage programming bullshit: no one has deserved THAT.  
</p>

<p>
Do you want to be robust and beautiful, as opposed to being half-assed and ugly?
Choose specialized structure, not a gap buffer.
And Emacs is gap buffers all the way through.
</p>

<p>
And so, everything is a <i>string</i> in Emacs.
</p>

<p>
Structural enforcement and everything that relies on the knowledge of structural information is simply too hard when your representation of data is a string.
</p>

<p>
Of course, enforcing structure in a buffer is not <i>technically</i> impossible. It&#39;s just too hard for the practical purposes for anyone to try or do meaningfully.
</p>

<p>
Look, anon, the fact that most data we work with is structural is the reason why there are <i>major modes</i> in Emacs.
The sole purpose of major modes is to deal with some particular <i>structure</i> of the document at hand.
</p>

<p>
Any major mode you can think of does that, except <code>fundamental-mode</code>, which simply says we don&#39;t know what the document even <i>is</i>.
</p>

<p>
—
</p>

<p>
If you are building a text editor and find yourself asking a question like:
</p>

<p>
<i>What&#39;s better: a gap buffer or a piece tree or a rope?</i>
</p>

<p>
Then the correct answer is, of course: 
</p>

<p>
<i>Neither, most of the time</i>.
</p>

<p>
Some people make it sound like it has to be a choice.
</p>

<p>
<i>It doesn&#39;t.</i>
</p>

<p>
You have to make that decision based on the data you want to edit. You don&#39;t have to be locked into one single representation of everything, which, for some reason, is the running assumption for every text editor in existence.
</p>

<p>
<i>That representation is a: <b>string</b>.</i>
</p>

<p>
Why don&#39;t we have specialized editors instead? 
</p>

<p>
I don&#39;t know, but certainly not because it&#39;s too hard. Making a decent specialized editor based on the fitting data structures is naturally easier than specializing a general editor to a specific task (not with the existing architectures anyhow).
</p>

<p>
A universal data structure is often assumed to be good for building a common interface to every kind of text file.
But <b>nothing</b> prevents specialized editors from having a common interface like that. <b>Nothing.</b>
</p>

<p>
—
</p>

<p>
Look: <b>Emacs is just bad at textual interfaces.</b>
</p>

<p>
Yeah, that&#39;s what people assume it&#39;s for, and therefore it must be good at it, but it isn&#39;t.
</p>

<p>
There are no specialization mechanisms. Only the buffer, which is just a string.
You can&#39;t do complex things on a string and get very far.
</p>

<p>
<i>Lack of structure breeds half-assed solutions.</i>
</p>

<p>
On top of that, Emacs promotes an imperative style of programming. Turtle turtle turtle.
</p>

<p>
And no, there isn&#39;t some higher-level API interface to be had there. It&#39;s <i>also</i> too hard.
</p>

<p>
No wonder it takes forever to get anything done.
I have 200+ <i>todo</i> wishlist items for my Emacs config.<span><sup><a id="fnr.3" href="#fn.3">3</a></sup><span> Listing them isn&#39;t terribly important for the discussion.</span></span>
A lot of people probably have more.
</p>

<p>
Most of these items are trivial to imagine.
</p>

<p>
But they are <i>not</i> trivial to accomplish.
</p>

<p>
—
</p>

<blockquote>
<p>
– <i>&lt;Author Name&gt;, your ass is a bit on fire, ain&#39;t it? What are you so riled up about?</i>
</p>
</blockquote>

<p>
Nothing, friend, nothing. Or maybe just the fact that Emacs sucks giant balls.
Emacs is much like that <a href="https://www.youtube.com/watch?v=qTf3INXJMFY">Uncle Gubsy</a> from your childhood.
</p>

<p>
Not even that I care so much.
Sure, I have spent hours, days, weeks on its configuration.
</p>

<p>
Oh, hell, who am I lying to? Not to the legion, that&#39;s for sure. But to myself maybe?
</p>

<p>
Months, anon. <i>Months.</i>
</p>

<p>
As many people did.
</p>

<p>
But all of that matters very little, to tell you the truth.
Because I ain&#39;t even close to feeling any sort of satisfaction.
</p>

<p>
My Emacs experience started gauche. Years passed. It&#39;s still gauche.
</p>

<p>
And my &gt;3000-line <code>.emacs</code> setup will still feel gauche even if I were to have a body double who would babysit my config and fix anything and everything that annoys me, which, trust me anon, is way more than the meager 200 bullet points. 
</p>

<p>
But, I assure you, continuous effort still won&#39;t fix shit, not even one man&#39;s config.
</p>

<p>
I have stopped adding these items.
</p>

<p>
And, by the way, you ever hear about those guys who have, like, 2 lines of Elisp for their config and they are happy?
Let me tell you something about them:
</p>

<p>
Those aren&#39;t real Emacsers.
They are just posers. Floaters.
</p>

<p>
Not constantly fucking around with your Emacs config is a non-idiomatic way of using emacs.
Period.
</p>

<p>
We aren&#39;t going to listen to their opinion, they are jumping ship to <i>corporate express</i> tomorrow anyway. So let&#39;s ignore that noise, OK?
</p>

<p>
—
</p>

<p>
So, where are we here, exactly?!
</p>

<p>
<i>If Emacs sucked so bad, surely someone would have fixed it by now?</i>
</p>

<p>
Oh, boy. Rewriting Emacs is possibly the most tropey of all Emacs talk.
</p>

<p>
Common Lisp people? They always want to <i>port fucking Emacs</i> or <i>rewrite fucking Emacs</i> or <i>copy from fucking Emacs</i> or <i>just be the fucking Emacs in some way</i>.
</p>

<p>
Or, wait for it…: how about <i>steal some Emacs code</i> by basically wet-dreaming up some magic emulation layer! This idea is just as misguided as it is widespread. It echoes across chat-rooms and it distracts from the real problems.
</p>

<p>
And then, yeah, &#34;porting&#34;. Well: porting Emacs to some foreign ecosystem (such as Guile) would be even worse.
Any kind of merging will result in a problem of <i>homogeneity</i>.
Even if it&#39;s Guile. Especially if it&#39;s Guile.
</p>

<p>
Porting or importing or merging would be no less than a man-made disaster for the ecosystem.
</p>

<p>
Nobody takes these discussions seriously, of course, because everybody understands that this kind of stuff is kind of <i>out there</i>, if not immediately ridiculous.
</p>

<p>
And even if any of it were feasible: <i>it doesn&#39;t fucking fix anything</i>.
</p>

<p>
You will never replace Elisp or fix Emacs if you are willing to port it. Porting it defeats the whole point of moving to a better system, because the systems would necessarily be incompatible. They would be incompatible because a vastly better system is the only kind that will actually make people move, and, so, it must be fundamentally different, therefore – incompatible.
</p>

<p>
Mind you, these aren&#39;t just some proposals about rewriting and porting, there are projects that do this.
And while the efforts are well-intended, they are futile!
</p>

<p>
<i>The problem of Emacs is not a language problem.</i>
</p>

<p>
Certainly, Elisp isn&#39;t the sharpest of lisps, but it does the job.
In fact, it&#39;s probably the best part of Emacs.
</p>

<p>
But one major mental block among all these discussions never fails to surface and that&#39;s: <i>packages</i>. 
</p>

<blockquote>
<p>
– <i>Oh how do we possibly rewrite or port Emacs and all that <b>terribly</b> useful code?</i>
</p>
</blockquote>

<p>
Look, anon: <i>Emacs doesn&#39;t have to be rewritten.</i> 
</p>

<p>
The fact of the matter is: <i><b>we don&#39;t want another Emacs</b></i>.
</p>

<p>
We want something radically different, something that supports <i>the structural approach</i>.
</p>

<p>
Emacs is pretty much incompatible with this idea of being structured in any way. And so, all its 10 gazillion lines of Elisp are a liability, not an asset.
</p>

<p>
Yes, I am saying that to have a better Lisp environment for text editing, we need to abandon ALL of elisp and ALL of Emacs.
<i>And don&#39;t look back.</i>
</p>

<blockquote>
<p>
– <i>&lt;Author Name&gt;, but there are over 5000 packages?</i>
</p>
</blockquote>

<p>
Oh, fuck that shit, anon! We don&#39;t need them.
</p>

<p>
Fuck 5000 packages. Fuck twenty and a hundred thousand packages.
</p>

<p>
None of it matters, I am telling you.
</p>

<p>
If the foundation is rotten, I don&#39;t care how many man-hours have gone down the shitter trying to prove that foundation worthy.
At this point it&#39;s all sunk costs and damage control.
</p>

<p>
Our end? We are just gonna be <i>inspired</i> by how <i>inconsequential</i> and <i>bad</i> all of it is, no more.
</p>

<p>
And, by the way, remember what I told you about imperative code?
Well, here come the big fucking news: all of Elisp ever written is kind of crap.
I don&#39;t mean to be bashing the authors of said code, it&#39;s not their fault. But it is what it is.
</p>

<p>
We want to flush it down the drain of eternity, not keep it.
</p>

<p>
And let&#39;s look at some of these fucking packages anyway, just for the fuck of it.
</p>

<p>
Trust me, they all look the same:
</p>
<ul>
<li><i>beginend</i>: Redefine M-&lt; and M-&gt; for some modes</li>
<li><i>belarus-holidays</i>: Belarus holidays with transfers</li>
<li><i>cfrs</i>: Child-frame based read-string</li>
</ul>

<p>
I.e. some fucking gibberish.
</p>

<p>
The real interesting players are <i>Org-mode</i> and <i>magit</i>. That&#39;s it.
And since <a href="https://project-mage.org/c-programmers-wrote-git.html">Git is for bums</a> anyhow, that just leaves Org-mode.
</p>

<p>
<i>There are no large applications in Emacs. Emacs packages don&#39;t tend to solve difficult or large problems.</i>
</p>

<p>
And at the quality of the small things present - nothing of true value will be lost.
</p>

<p>
Everything else is pretty much stopwatches, around 15 completion frameworks, a million half-assed language support packages, themes and whatever <a href="https://github.com/alphapapa/">alphapapa</a> felt like writing or adopting this or the other day. 
</p>

<p>
<i>Dad-jokes</i>. 
</p>

<p>
<i>Tetris</i>. 
</p>

<p>
Anon, this shit is <i>lame</i>, can&#39;t you see?!
</p>

<p>
The real good stuff is not so numerous and we can just steal it, but do it right this time over.
</p>

<p>
And we don&#39;t need to be even looking <i>at the packages</i>, we need to be looking <i>at our experience using this software as a whole</i>.
That&#39;s the source of real value. Not code.
</p>

<blockquote>
<p>
– <i>But there&#39;s like 10 gorillion lines of Elisp code?!</i>
</p>
</blockquote>

<p>
Yes and it <i>doesn&#39;t matter</i>. The current architecture of Emacs is simply incompatible with drastic improvements.
The platform is simply suboptimal. The best way is to abandon everything.
</p>

<p>
And that&#39;s just for text. I haven&#39;t even mentioned anything about stuff like vector graphics.
</p>

<blockquote>
<p>
– <i>&lt;Author Name&gt;, why do you think a text editor needs graphics?</i>
</p>
</blockquote>

<p>
A rookie question, but I shall answer it, it&#39;s illuminating.
</p>

<p>
Because whoever said Emacs was a text editor, huh?
Emacs just happens to be a platform where people can (try to) build <del>decent</del> textual interfaces.
</p>

<p>
If it had graphics, that would have been used too.
People try to slap graphics onto it (like with GTK widgets<span><sup><a id="fnr.4" href="#fn.4">4</a></sup><span> What joy.</span></span>), but none of it is idiomatic, of course, so nobody will use it. As expected.
</p>

<blockquote>
<p>
– <i>&lt;Author Name&gt;, if Emacs is so bad, why are you still using it?</i>
</p>
</blockquote>

<p>
Because, dear anon, everything else is so so much more <i>shit</i>.
</p>

<blockquote>
<p>
– <i>&lt;Author Name&gt;, you mentioned Guile. What&#39;s the problem with extending Emacs with other languages? Isn&#39;t that powerful?</i>
</p>
</blockquote>

<p>
Running everything on a virtual machine that would support more than Elisp is a <i>bad</i> idea.  
Those who think it&#39;s a good idea are mistaken about the target audience of Emacs: they forget that Emacs is primarily for power users.
</p>

<p>
Once you have a bazaar of languages that can&#39;t interoperate well, you lose on power.  
<i>And the one thing you don&#39;t want to do is try to snatch away power from the power user</i>.
</p>

<p>
You may load a Lua interpreter in your Lisp image, or allow extensive FFI. 
But no one is gaining any power from that, only some short-term convenience which will obstruct the power user later on. 
You just can&#39;t start writing text functions in Lua or whatever and expect the target audience to be happy about it.
</p>

<p>
I talk more about this in other articles and refer to this problem as <i>homogeneity</i>.
</p>

<blockquote>
<p>
– <i>&lt;Author Name&gt;, can&#39;t you just hack Emacs to be better?</i>
</p>
</blockquote>

<p>
Nope.
</p>

<blockquote>
<p>
– <i>&lt;Author Name&gt;, aren&#39;t there structural editors already and don&#39;t they suck?</i>
</p>
</blockquote>

<p>
There are structural editors out there. And, yes, they sucked and that&#39;s why they disappeared into obscurity. It was so because you couldn&#39;t use them like you could use Emacs, with the point freely running around everywhere.
</p>

<p>
But that doesn&#39;t mean that they can&#39;t do it also or that they have to suck. I have proposed <i>seamless</i> structural editing in <a href="https://project-mage.org/the-power-of-structure.html">the previous article</a>.
</p>

<blockquote>
<p>
– <i>&lt;Author Name&gt;, isn&#39;t writing specialized structural editors more difficult?</i>
</p>
</blockquote>

<p>
No. In fact, it&#39;s easier because you can reuse such editors within each other. Structure is also conducive to the design of complex interaction and interoperation behaviors.
</p>

<blockquote>
<p>
– <i>&lt;Author Name&gt;, if there were many specialized editors, wouldn&#39;t you have to configure each one separately?</i>
</p>
</blockquote>

<p>
The configuration of common elements (such as bindings for common commands) could be easily shared. All the editors would simply have to have some <i>common interface</i> for textual manipulation.
</p>

<blockquote>
<p>
– <i>&lt;Author Name&gt;, but Emacs must have gotten something right, right?</i>
</p>
</blockquote>

<p>
Oh, yessir, a few things.
</p>

<p>
Lisp. Elisp might not have turned out to be the greatest dialect in existence. There are problems with multithreading, with namespaces, with a few other things. But, overall, it&#39;s usable and is, certainly, not the worst of problems that Emacs is facing right now.
</p>

<p>
What else is good? Well, extensibility. To a degree. Emacs showed what interactive extensibility can be like and how it can serve us. I believe it showed that there are a lot of people who can appreciate it in personal computing.
</p>

<p>
Previously, I also bashed the notion of buffers, but the idea of <i>everything being a buffer</i> proved to be very handy.
That means everything has some common interface and is manipulated via the same set of commands. (Except the modeline. It was, apparently, too structured to implement non-structurally.)
</p>

<p>
Is there anything to add to this? Probably not.
</p>

<blockquote>
<p>
– <i>It there really no point in reusing all that code from Emacs and its package system?</i>
</p>
</blockquote>

<p>
Don&#39;t worry, anon, writing code is a sin, but dumping code down the drain is just about the most honorable thing a man can do.
</p>

<p>
I will reiterate a little. But see, Emacs has <i>0</i> structural awareness. 
</p>

<p>
And, so, all its packages and features only do 50% of what a user might want, and they are mostly pretty bad at that too.
</p>

<p>
<i>Mediocre experience has become the norm.</i>
</p>

<p>
Emacs is good neither at specialization nor at embedding nor at integration.
For instance, you can&#39;t make a buffer where different regions have various modes. There are hacks for it, but they suck ass.
</p>

<p>
All the Emacs tools only let you <i>get by</i>, they aren&#39;t reaching up to any stars in the sky.
</p>

<p>
And if you can&#39;t specialize, you will be inefficient and clumsy forever.
</p>

<p>
There isn&#39;t a point where things get radically better for Emacs.
Can you imagine to be building <i>ever more crap</i> on top of it?
</p>

<p>
I know I can&#39;t.
</p>

<p>
I would rather have a few specialized tools that work 100% percent of the time or at least can be improved to that limit.
(And these tools have to be living within one system so they could integrate and interoperate with each other.)
</p>

<blockquote>
<p>
– <i>&lt;Author Name&gt;, can Emacs become structural?</i>
</p>
</blockquote>

<p>
If you have read the <a href="https://project-mage.org/the-power-of-structure.html">previous article</a>, especially the <i>Rune</i> section, you already know that I see <i>seamlessly-structural</i> editing as the superior way of working with text.
</p>

<p>
Hypothetically, could Emacs adopt that way of thinking? Let&#39;s just consider that for a second.
</p>

<p>
Well, first of all, the core would have to become Lispy. But that&#39;s just a prerequisite.
</p>

<p>
Then, some real expansion of what a <i>buffer</i> means and is capable of doing would have to ensue.
</p>

<p>
I mean, it would be like trying to turn a freight train into a helicopter with an assumption that, in the end, all the rails would have to still be attached to the wheels.
</p>

<p>
And you get a homogeneity problem, this one worse than the &#34;language rewrite&#34; one.
</p>

<p>
Although, in principle, I don&#39;t see why this couldn&#39;t be done backwards-compatibly.
But, in practice, it would be much easier <del>to just say that structural editing isn&#39;t worth it</del> to start from scratch.
</p>

<p>
And that&#39;s without even thinking about any kind of an overarching GUI toolkit, or a nice prototype system.
</p>

<p>
And even if the core were to accommodate a fraction of the capabilities<span><sup><a id="fnr.5" href="#fn.5">5</a></sup><span> Yeah, right: as if. Emacs core development is an extremely conservative business.</span></span>, the whole rest of packages and code don&#39;t just automagically upgrade. But they do become <i>morally deprecated</i>. 
</p>

<p>
So, it&#39;s bye-bye Emacs either way.
</p>

<p>
There is a foundational lack of flexibility in the foundations. And it&#39;s not just about C (that&#39;s not even the tenth of it). It&#39;s the defaults, the global state, the whole string-based model.
</p>

<p>
And that model is <i>fucked</i>.
</p>

<p>
I think, the one thing I don&#39;t like about Emacs core is that it is majorly API-driven.
I think really powerful cores don&#39;t give you an API, they give you building blocks.
</p>

<p>
The only building block in Emacs is a buffer, and that one is basically a tape-driven Turing machine on steroids packaged for personal computing.
</p>

<p>
—
</p>

<p>
I am not really blaming or dismissing Emacs. It&#39;s an impressive piece of technology.
</p>

<p>
But it&#39;s time for us to see that Emacs capabilities are bound by the constant edge cases you have to work through. 
In other words, something will always be a little broken, a tad out of tune, etc. etc. and none of it is really about not being good enough. It&#39;s about the stuff underneath that&#39;s not good enough. The foundation guarantees you will have constant stream of inefficiencies and problems <i>at all times</i>.
</p>

<p>
Not even to mention that due to the limitations of structurelessness, a lot of features will never be attempted <i>or even thought about</i>.
</p>

<p>
What do we want instead? Composition of objects. Embeddable structures. Programmatic access to everything at the level <i>of what it is, and not just how it is represented</i>. And that&#39;s where you need to start to build your editor from: from the innate structure of any given object. Treating things as objects which have a textual interface! A specialized editor for each structure, many such editors interoperating and <i>consisting</i> of other editors. That would yield both better interfaces, AND more control, AND it will eliminate the bloat, AND it will be fast. And, at last: it will be <i>simpler</i>. Because that&#39;s what flexibility coupled with structure gives you: power. And power can make complex things <i>simple</i>.
</p>

<p>
Emacs has hit its ceiling in terms of how powerful its interfaces can be.
</p>

<p>
And then there&#39;s the issue of performance. 
</p>

<p>
Editing this site&#39;s HTML reminded me of the true molasses-like horrors.
Except, of course, molasses, while being slow, is at least continuous and smooth. Emacs - not so much, <i>ha ha</i>.
</p>

<p>
Let me give you one last example before I finish.
</p>

<p>
Emacs highlights code on the fly – stuff appears within the window rectangle, and it figures out what it has to do with it.
So take a look at the <a href="https://github.com/ahungry/fast-scroll">fast-scroll</a> package. What does it do to make scrolling fast? Well, <i>it turns off syntax highlighting while you are scrolling.</i>
</p>

<p>
This is a perfect example why Emacs has persisted for so long - when things get tough, it lets you slog your way through just another day. And that&#39;s a big part of the reason why they call it a <a href="https://project-mage.org/img/editor-learning-curves.jpg">rabbit hole</a> - because no solution here ever works anywhere close to 100%. 
</p>

<p>
But there&#39;s <i>nothing</i> that tells you that you have to stop.
</p>

<p>
And then, most times, you are forced to cache what you parse if you want any kind of speed.
</p>

<p>
Caching means complexity.
</p>

<p>
Parsing means complexity.
</p>

<p>
Complexity means bugs and slow development.
</p>

<p>
Complexity means lack of clarity and a chronic inability to make stuff <i>just work</i>.
</p>

<p>
That&#39;s not the programmer&#39;s fault. No, it&#39;s the fault of the system he has to deal with.
And it&#39;s just bad: the performance, the lack of structure. The chase for quality, elusive and everfading.
</p>

<p>
And then it all rains down on the user&#39;s head, and all he knows is to &#34;push through&#34;. That&#39;s what power users do.
</p>

<p>
The whole situation is bad bad bad and you don&#39;t need any further convincing from me.
</p>

<p>
And you know what else? I think powerful programs like Emacs aren&#39;t even meant for power users. Maybe they are meant for them to be entertaining God.
</p>

<p>
And, I wager, if that&#39;s so, then God must have been bored out of his mind.
</p>

<p>
And I think we are now seeing the fading trail of Emacs&#39; trailblazing. And we have been seeing it for many years.
</p>

<p>
People are fucking afraid to bury things for good.
They will keep carrying it, a cart full of bullshit, legacy, pain.
Throwing things away is the most relief a human gets, scalewise, and yet;
some of the most pivotal of your own memories, oh dear anon,
involve ditching something you once thought were too valuable.
</p>

<p>
The Emacs myopia.
</p>

<p>
You know it, you have seen it.
That&#39;s why they call it an OS, its adepts octopi.
Emacs is like an eyepiece that lets you see, but turns everything to shit.
</p>

<p>
Emacs is powerful, but only to a point of crudeness.
It&#39;s not quite the Lisp machine that you thought it were.
Too limited for the modern world, it&#39;s nearing the point of bare inertia.
Smoldering at its core, a landfill in practical terms.
</p>

<p>
Accept it, believe it, because it&#39;s the truth.
</p>

<ul><li><a href="https://project-mage.org/the-power-of-structure.html">
← The Power of Structure
</a></li>
<li><a href="https://project-mage.org/on-flexibility.html">
On Flexibility and Software Temples →
</a></li></ul>
<ul id="quickbar">
<li><a href="#table-of-contents">Table of Contents#</a></li>
<li><a href="#">Top#</a></li>
<li><a href="https://project-mage.org/index.html#title">All Essays</a></li>
</ul>

</div></div>
  </body>
</html>
