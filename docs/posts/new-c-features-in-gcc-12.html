<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://developers.redhat.com/articles/2022/04/25/new-c-features-gcc-12">Original</a>
    <h1>New C&#43;&#43; features in GCC 12</h1>
    
    <div id="readability-page-1" class="page"><div>
			<div>
									
								<div>
					            <p>Version 12.1 of the <a href="https://gcc.gnu.org/">GNU Compiler Collection</a> (GCC) is expected to be released in April 2022. Like every major GCC release, this version will bring many <a href="https://gcc.gnu.org/gcc-12/changes.html">additions, improvements, bug fixes, and new features</a>. GCC 12 is already the system compiler in <a href="https://fedoraproject.org/wiki/Changes/GNUToolchainF36">Fedora 36</a>. GCC 12 will also be available on <a href="https://donnywinston.com/products/rhel">Red Hat Enterprise Linux</a> in the Red Hat Developer Toolset (version 7) or the Red Hat GCC Toolset (version 8 and 9).</p>

<p>Like the article I wrote about <a href="https://donnywinston.com/blog/2020/09/24/new-c-features-in-gcc-10">GCC 10</a>, this article describes only new features affecting C++.</p>

<p>We implemented several C++23 proposals in GCC 12. The default dialect in GCC 12 is <code>-std=gnu++17</code>; to enable C++23 features, use the <code>-std=c++23</code> or <code>-std=gnu++23</code> command-line options. (The latter option allows GNU extensions.)</p>

<p>Note that C++20 and C++23 features are still experimental in GCC 12.</p>

<h2>C++23 features</h2>

<p>A number of previously prohibited constructs are now allowed, and some of these features can potentially reduce the size of your programs.</p>

<h3>if consteval</h3>

<p>C++17 introduced the <em>constexpr if</em> statement. The condition in <code>if constexpr</code> must be a constant expression (it is <em>manifestly constant evaluated</em>). If the condition evaluates to true, the <code>else</code> branch, if present, is <em>discarded.</em> Discarded means that the <code>else</code> branch is not instantiated at all during compilation, which is different behavior from an ordinary <code>if</code>. If the condition evaluates to false, the <code>then</code> branch is similarly discarded.</p>

<p>If a function is declared <code>constexpr</code>, it might or might not be evaluated at compile time, depending on the context. To offer some visibility to the programmer about when the function is evaluated at compile time, C++20 introduced a new library function, <code>std::is_constant_evaluated</code>, which returns true if the current context is evaluated at compile time:</p>

<pre><code>#include &lt;type_traits&gt;

int slow (int);

constexpr int fn (int n)
{
  if (std::is_constant_evaluated ())
    return n &lt;&lt; 1; // #1
  else
    return slow (n); // #2
}

constexpr int i = fn (10); // does #1
int n = 10;
int i2 = fn (n); // calls slow function #2
</code></pre>

<p>C++20 introduced the <code>consteval</code> keyword. A (possibly member) function or a constructor marked as <code>consteval</code> is an <em>immediate function</em>. Immediate functions are evaluated during compilation and must produce a constant, unless the call to an immediate function takes place in another immediate function; if they don&#39;t, the compiler produces an error. The compiler doesn&#39;t emit any actual code for such functions.</p>

<p>However, the language rules do not allow the developer to replace <code>n &lt;&lt; 1</code> in the preceding test with a call to a <code>consteval</code> function:</p>

<pre><code>#include &lt;type_traits&gt;

int slow (int);
consteval int fast (int n) { return n &lt;&lt; 1; }

constexpr int fn (int n)
{
  if (std::is_constant_evaluated ())
    return fast (n); // &#39;n&#39; is not a constant expression
  else
    return slow (n);
}
constexpr int i = fn (10);
</code></pre>

<p>To fix this problem, <a href="https://wg21.link/p1938">proposal P1938R3</a> introduced <code>if consteval</code>, which GCC 12 implements. <code>if consteval</code> allows the developer to invoke immediate functions, as shown here:</p>

<pre><code>#include &lt;type_traits&gt;

int slow (int);
consteval int fast (int n) { return n &lt;&lt; 1; }

constexpr int fn (int n)
{
  if consteval {
    return fast (n); // OK
  } else {
    return slow (n);
  }
}

constexpr int i = fn (10);
</code></pre>

<p>Note that it is valid to have <code>if consteval</code> in an ordinary, non-<code>constexpr</code> function. Also note that <code>if consteval</code> requires <code>{ }</code>, unlike the ordinary <code>if</code> statement.</p>

<p>There is a problem with the interaction between <code>if constexpr</code> and <code>std::is_constant_evaluated</code>, but fortunately the compiler can detect that problem. We&#39;ll examine the solution in the later section <em>Extended std::is_constant_evaluated in if warning</em>.</p>

<h3>auto(x)</h3>

<p>GCC 12 implements <a href="https://wg21.link/p0849">proposal P0849</a>, which allows <code>auto</code> in a <em>function-style cast</em>, the result of which is a <a href="https://en.cppreference.com/w/cpp/language/value_category">pure rvalue (<em>prvalue</em>)</a>:</p>

<pre><code>struct A {};
void f(A&amp;);  // #1
void f(A&amp;&amp;); // #2
A&amp; g();

void
h()
{
  f(g()); // calls #1
  f(auto(g())); // calls #2 with a temporary object
}
</code></pre>

<p>Note that both <code>auto(x)</code> and <code>auto{x}</code> are accepted; however, <code>decltype(auto)(x)</code> remains invalid.</p>

<h3>Non-literal variables in constexpr functions</h3>

<p>GCC 12 implements <a href="https://wg21.link/p2242">C++23 proposal P2242R3</a>, which allows non-literal variables, gotos, and labels in <code>constexpr</code> functions so long as they are not constant evaluated. This expanded behavior is useful for code like the following (taken from the proposal):</p>

<pre><code>#include &lt;type_traits&gt;

template&lt;typename T&gt; constexpr bool f() {
  if (std::is_constant_evaluated()) {
    return true;
  } else {
    T t; // OK when T=nonliteral in C++23
    return true;
  }
}
struct nonliteral { nonliteral(); };
static_assert(f&lt;nonliteral&gt;());
</code></pre>

<p>This does not compile in C++20, but compiles in C++23 because the <code>else</code> branch is not evaluated. The following example also compiles only in C++23:</p>

<pre><code>constexpr int
foo (int i)
{
  if (i == 0)
    return 42;
  static int a;
  thread_local int t;
  goto label;
label:
  return 0;
}
</code></pre>

<h3>Multidimensional subscript operator</h3>

<p>GCC 12 supports C++23 <a href="https://wg21.link/p2128">proposal P2128R6</a>, a multidimensional subscript operator. Comma expressions within subscripting expressions were deprecated in C++20 via <a href="https://wg21.link/p1161">proposal P1161R3</a>, and in C++23 the comma in <code>[ ]</code> has changed meaning.</p>

<p>C++ uses the <code>operator[]</code> member function to access the elements of an array, as well as array-like types such as <code>std::array</code>, <code>std::span</code>, <code>std::vector</code>, and <code>std::string</code>. However, this operator did not accept multiple arguments in C++20, so access to the elements of multidimensional arrays was implemented using function call operators like <code>arr(x, y, z)</code>, and similar workarounds. These workarounds have a number of drawbacks, so to alleviate the issues when using them, C++23 allows <code>operator[]</code> to take zero or more arguments.</p>

<p>As a consequence, this test case is accepted with <code>-std=c++23</code>:</p>

<pre><code>template &lt;typename... T&gt;
struct W {
  constexpr auto operator[](T&amp;&amp;...);
};

W&lt;&gt; w1;
W&lt;int&gt; w2;
W&lt;int, int&gt; w3;
</code></pre>

<p>Here is what may be a clearer example, with a very naive implementation:</p>

<pre><code>struct S {
  int a[64];
  constexpr S () : a {} {};
  constexpr S (int x, int y, int z) : a {x, y, z} {};
  constexpr int &amp;operator[] () { return a[0]; }
  constexpr int &amp;operator[] (int x) { return a[x]; }
  constexpr int &amp;operator[] (int x, long y) { return a[x + y * 8]; }
};

void g ()
{
  S s;
  s[] = 42;
  s[5] = 36;
  s[3, 4] = 72;
}
</code></pre>

<p>As an extension, GCC still supports the old behavior when an overloaded subscript operator is not found, though it issues a warning:</p>

<pre><code>void f(int a[], int b, int c)
{
  a[b,c]; // deprecated in C++20, invalid but accepted with a warning in C++23
  a[(b,c)]; // OK in both C++20 and C++23
 }
</code></pre>

<p>Note that currently, <code>operator[]</code> does not support default arguments. It appears, though, that default arguments will be allowed in future versions: see <a href="https://wg21.link/cwg2507">CWG 2507</a>. If and when the proposed adjustment is accepted, the following example will be allowed:</p>

<pre><code>struct X {
  int a[64];
  constexpr int&amp; operator[](int i = 1) { return a[i]; }
};
</code></pre>

<h3>elifdef and elifndef</h3>

<p>In C and C++, the <code>#ifdef</code> and <code>#ifndef</code> preprocessing directives are &#34;syntactic sugar&#34; for <code>#if defined(something)</code> and <code>#if !defined(something)</code>. Surprisingly, the <code>else</code> variants of these directives did not have the same shorthands. To amend this omission, the C and C++ designers accepted proposals <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2645.pdf">N2645</a> and <a href="https://wg21.link/p2334">P2334R1</a>, respectively. GCC 12 implements both proposals, so the following example compiles correctly:</p>

<pre><code>#ifdef __STDC__
/* ... */
#elifndef __cplusplus
#warning &#34;not ISO C&#34;
#else
/* ... */
#endif
</code></pre>

<p>Please note that, to compile this example without errors in C++20 and earlier, you must enable GNU extensions. In other words, <code>-std=c++20</code> causes a compile error, but <code>-std=gnu++20</code> causes only a pedantic warning if <code>-Wpedantic</code> is also turned on.</p>

<h3>Extended init-statement</h3>

<p>GCC 12 implements <a href="https://wg21.link/p2360r0">proposal P2360R0</a> in C++23, which merely extends an <em>init-statement</em> (used in <code>if</code>, <code>for</code>, and <code>switch</code> statements) to allow it to contain an <em>alias-declaration</em>. In practice, that change means that the following code is accepted:</p>

<pre><code>for (using T = int; T e : v)
  {
    // use e
  }
</code></pre>

<h2>Corrections and internal improvements</h2>

<p>The changes described in this section bring GCC more in line with recent changes to the standard, and permit behavior that previously did not work correctly.</p>

<h3>Dependent operator lookup changes</h3>

<p>GCC 12 corrected a problem where the compiler performed an unqualified lookup for a dependent operator expression at template definition time instead of at instantiation time. The fix matches the existing behavior for dependent call expressions. Consider the following test case demonstrating this change:</p>

<pre><code>#include &lt;iostream&gt;

namespace N {
  struct A { };
}

void operator+(N::A, double) {
  std::cout &lt;&lt; &#34;#1 &#34;;
}

template&lt;class T&gt;
void f(T t) {
  operator+(t, 0);
  t + 0;
}

// Since it&#39;s not visible from the template definition, this later-declared
// operator overload should not be considered when instantiating f&lt;N::A&gt;(N::A),
// for either the call or operator expression.
void operator+(N::A, int) {
  std::cout &lt;&lt; &#34;#2 &#34;;
}

int main() {
  N::A a;
  f(a);
  std::cout &lt;&lt; std::endl;
}
</code></pre>

<p>This program will print <code>#1 #2</code> when compiled with versions 11 or older of GCC, but GCC 12 correctly prints <code>#1 #1</code>. That&#39;s because previously only the call expression resolved to the <code>#1</code> overload, but with GCC 12 the operator expression does too.</p>

<h3>auto specifier for pointers and references to arrays</h3>

<p>GCC 12 also supports <a href="https://wg21.link/cwg2397">defect report DR2397</a>, covering the <code>auto</code> specifier for pointers and references to arrays. This change removes the restriction that the array element type may not be a <em>placeholder type</em>. This allows code like:</p>

<pre><code>int a[3];
auto (*p)[3] = &amp;a;
auto (&amp;r)[3] = a;
</code></pre>

<p>However, neither of the following examples work (although some day they might):</p>

<pre><code>auto (&amp;&amp;r)[2] = { 1, 2 };
auto arr[2] = { 1, 2 };

int arr[5];
auto x[5] = arr;
</code></pre>

<p>These don&#39;t work because the <code>auto</code> deduction is performed in terms of function template argument deduction, so the array decays to a pointer.</p>

<h3>Folding of trivial functions</h3>

<p>A well-formed call to <code>std::move</code> or <code>std::forward</code> is equivalent to a cast. But because these constructs are implemented as function calls, the compiler generates debugging information that persists even after the call gets inlined. This extra code is a waste because there&#39;s no need to debug such operations. Therefore, GCC 12 elides calls to certain trivial inline functions (such as <code>std::move</code>, <code>std::forward</code>, <code>std::addressof</code>, and <code>std::as_const</code>) into simple casts as part of the front end&#39;s general expression folding routine. As a result, the debugging information produced by GCC could be up to 10 percent smaller, while improving GCC&#39;s compile time and memory usage. This behavior is controlled by a new option called <code>-ffold-simple-inlines</code>.</p>

<h3>Fixing the overly permissive specification of enum direct-list-initialization</h3>

<p>GCC 12 implements <a href="https://wg21.link/cwg2374">defect report DR2374</a>, which forbids, for instance,
<em>direct-list-initialization</em> of a scoped enumeration from a different
scoped enumeration:</p>

<pre><code>enum class Orange;
enum class Apple;
Orange o;
Apple a{o}; // error with GCC 12
</code></pre>

<h3>Restrictions on non-type template arguments in partial specializations</h3>

<p>Previously, an overly strict restriction prevented certain uses of template parameters as template arguments. This restriction has been rectified in response to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1315">defect report DR1315</a>, and GCC implements these uses now. Therefore, the following plausible use of a template parameter as a template argument compiles correctly:</p>

<pre><code>template &lt;int I, int J&gt; struct A {};
template &lt;int I&gt; struct A&lt;I, I*2&gt; {}; // OK with GCC 12
</code></pre>

<h3>Substitutions into function parameters in lexical order</h3>

<p>C++ template argument deduction underwent some changes when <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1227">defect report DR1227</a> specified that the substitution proceeds in lexical order—that is, from left to right. The following code demonstrates what effect this might have:</p>

<pre><code>template &lt;typename T&gt;
struct A { using type = typename T::type; };

template &lt;typename T&gt; void g(T, typename A&lt;T&gt;::type);
template &lt;typename T&gt; long g(...);

long y = g&lt;void&gt;(0, 0); // OK in GCC 12, error in GCC 11

template &lt;class T&gt; void h(typename A&lt;T&gt;::type, T);
template &lt;class T&gt; long h(...);

long z = h&lt;void&gt;(0, 0); // error in GCC 12, OK in GCC 11
</code></pre>

<p>GCC 12 substitutes the arguments in left-to-right order and checks whether a substituted type is erroneous before substituting it into the rest of the arguments. Thus, for <code>g&lt;void&gt;(0, 0)</code> the compiler tries to substitute <code>void</code> into <code>g(T, typename A&lt;T&gt;::type)</code> and sees that the first substitution results in an invalid parameter type <code>void</code>. This invalid substitution is a SFINAE failure, so the first overload is discarded and the <code>g(...)</code> one is chosen instead. However, for <code>h&lt;void&gt;(0, 0)</code>, the compiler first substitutes <code>void</code> into the <code>typename A&lt;T&gt;::type</code> parameter. This produces a hard error, because instantiating <code>A&lt;void&gt;</code> is not an immediate context.</p>

<p>GCC 11 and earlier performed the substitution in right-to-left order, so the situation was reversed: <code>g&lt;void&gt;(0, 0)</code> resulted in a compile error, whereas <code>h&lt;void&gt;(0, 0)</code> compiled fine.</p>

<h3>Stricter checking of attributes on friend declarations</h3>

<p>If a friend declaration has an attribute, that declaration must be a definition, but before version 12, GCC didn&#39;t check this restriction.
Moreover, a C++11 attribute cannot appear in the middle of the <em>decl-specifier-seq</em>:</p>

<pre><code>template&lt;typename T&gt;
struct S {
  [[deprecated]] friend T; // warning: attribute ignored
  [[deprecated]] friend void f(); // warning: attribute ignored
  friend [[deprecated]] int f2(); // error
};
S&lt;int&gt; s;
</code></pre>

<h3>Deduction guides can be declared at class scope</h3>

<p>Due to a bug, deduction guides could not be declared at class scope in versions 11 and early of GCC. This has been <a href="https://gcc.gnu.org/PR79501">fixed in GCC 12</a>, so the following test case compiles correctly:</p>

<pre><code>struct X {
  template&lt;typename T&gt; struct A {};
  A() -&gt; A&lt;int&gt;;
};
</code></pre>

<p>Class-scope non-template deduction guides are now supported as well in GCC 12.</p>

<h3>Ordered comparison of null pointers is now rejected</h3>

<p>Relational comparisons between null pointer constants and pointers are
ill-formed, and this error is diagnosed in GCC 12:</p>

<pre><code>decltype(nullptr) foo ();
auto cmp = foo () &gt; 0; // error: ordered comparison of pointer with integer zero
</code></pre>

<p>The overall defect resolution status is listed in the <a href="https://gcc.gnu.org/projects/cxx-dr-status.html">C++ Defect Report Support in GCC</a> page.</p>

<h2>New and improved warnings</h2>

<p>GCC&#39;s plethora of warning options have been enhanced in GCC 12.</p>

<h3>-Wuninitialized extended</h3>

<p>The <code>-Wuninitialized</code> warning has been extended to warn about using uninitialized variables in member initializer lists. Therefore, the front end can detect bugs like this:</p>

<pre><code>struct A {
  int a;
  int b;
  A() : b(1), a(b) { }
};
</code></pre>

<p>Here, the <code>b</code> field is used uninitialized because the order of member initializers in the member initializer list is irrelevant; what matters is the order of declarations in the class definition. (A related warning, <code>-Wreorder</code>, can be used to warn when the order of member initializers does not match the declaration order.)</p>

<p>The warning does not warn about more complex initializers. And it also does not warn when the address of an object is used:</p>

<pre><code>struct B {
  int &amp;r;
  int *p;
  int a;
  B() : r(a), p(&amp;a), a(1) { } // no warning
};
</code></pre>

<p>As an aside, the request to enhance this warning came about 17 years ago. Apparently, sometimes things take time.</p>

<h3>-Wbidi-chars added</h3>

<p>The <code>-Wbidi-chars</code> warning warns about potentially misleading UTF-8 bidirectional control characters, which can change left-to-right writing direction into right-to-left (and vice versa). Certain combinations of control characters might cause confusion for the programmer because code that has seemingly been commented out might actually be compiled, or vice versa. This warning is supposed to mitigate <a href="https://nvd.nist.gov/vuln/detail/CVE-2021-42574">CVE-2021-42574</a>, aka <a href="https://trojansource.codes/">Trojan Source</a>.</p>

<p>For more information, please refer to David Malcolm&#39;s Red Hat Developer article <a href="https://developers.redhat.com/articles/2022/01/12/prevent-trojan-source-attacks-gcc-12">Prevent Trojan Source attacks with GCC 12</a>.</p>

<h3>-Warray-compare added</h3>

<p>The new <code>-Warray-compare</code> option warns about comparisons between two operands of array type, which was deprecated in C++20. Here&#39;s an example of this situation:</p>

<pre><code>int arr1[5];
int arr2[5];
bool same = arr1 == arr2; // warning: comparison between two arrays
</code></pre>

<h3>-Wattributes extended</h3>

<p>The <code>-Wattributes</code> warning has been extended so that developers can now use <code>-Wno-attributes=ns::attr</code> or <code>-Wno-attributes=ns::</code> to suppress warnings about unknown scoped attributes (in C++11 and C2X). Similarly, <code>#pragma GCC diagnostic ignored_attributes &#34;ns::attr&#34;</code> can be used to achieve the same effect. The new behavior is meant to help with vendor-specific attributes, where a warning is not desirable, while still detecting typos. Consider:</p>

<pre><code>[[deprecate]] void g(); // warning: should be deprecated
[[company::attr]] void f(); // no warning
</code></pre>

<p>When compiled with <code>-Wno-attributes=company::</code>, only the first declaration issues a warning.</p>

<h3>New warning options for C++ language mismatches</h3>

<p>GCC 12 gained the following new warning options, enabled by default:</p>

<ul>
<li><code>-Wc++11-extensions</code></li>
<li><code>-Wc++14-extensions</code></li>
<li><code>-Wc++17-extensions</code></li>
<li><code>-Wc++20-extensions</code></li>
<li><code>-Wc++23-extensions</code></li>
</ul>

<p>These options control existing pedantic warnings about occurrences of new C++ constructs in code that uses an older C++ standard dialect. For instance, developers are now able to suppress warnings when using variadic templates in C++98 code by applying the new <code>-Wno-c++11-extensions</code> option.</p>

<h3>Extended std::is_constant_evaluated in if warning</h3>

<p>Because the condition in <code>if constexpr</code> is <em>manifestly constant evaluated</em>, <code>if constexpr (std::is_constant_evaluated())</code> is always evaluated to be true. GCC 10 introduced a warning to detect this bug, and GCC 12 extended the warning to detect more dubious cases. For instance:</p>

<pre><code>#include &lt;type_traits&gt;

int
foo ()
{
  if (std::is_constant_evaluated ()) // warning: always evaluates to false in a non-constexpr function
    return 1;
  return 0;
}

consteval int
baz ()
{
  if (std::is_constant_evaluated ()) // warning: always evaluates to true in a consteval function
    return 1;
  return 0;
}
</code></pre>

<h3>-Wmissing-requires added</h3>

<p>The <code>-Wmissing-requires</code> option warns about a missing <code>requires</code>. Consider the following code:</p>

<pre><code>template &lt;typename T&gt; concept Foo = __is_same(T, int);

template&lt;typename Seq&gt;
concept Sequence = requires (Seq s) {
  /* requires */ Foo&lt;Seq&gt;;
};
</code></pre>

<p>The problem here is that the developer presumably meant to invoke the <code>Foo</code> concept (a nested requirement), which needs to be prefixed by the <code>requires</code> keyword. In this test, <code>Foo&lt;Seq&gt;</code> is a <em>concept-id</em>, which makes <code>Sequence</code> true if <code>Foo&lt;Seq&gt;</code> is a valid expression. The expression is valid for all <code>Seq</code>.</p>

<h3>-Waddress enhanced</h3>

<p>The <code>-Waddress</code> warning has been extended. It now warns about, for instance, comparing the address of a nonstatic member function to the null pointer value:</p>

<pre><code>struct S {
  void f();
};

int g()
{
  if (&amp;S::f == nullptr) // warning: the address &amp;S::f will never be NULL
    return -1;
  return 0;
}
</code></pre>

<h2>Acknowledgments</h2>

<p>As usual, I&#39;d like to thank my coworkers at Red Hat who made the GNU C++ compiler so much better, notably Jason Merrill, Jakub Jelinek, Patrick Palka, and Jonathan Wakely.</p>

<h2>Conclusion</h2>

<p>In GCC 13, we plan to finish up the remaining C++23 features. For progress so far, see the <a href="https://gcc.gnu.org/projects/cxx-status.html#cxx23">C++23 Language Features</a> table on the <a href="https://gcc.gnu.org/projects/cxx-status.html">C++ Standards Support in GCC</a> page. Please do not hesitate to <a href="https://gcc.gnu.org/bugs/">file bug reports</a> in the meantime, and help us make GCC even better.</p>

      
					
															
				</div>
			</div>
		</div></div>
  </body>
</html>
