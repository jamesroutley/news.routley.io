<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.vusec.net/projects/ghostrace/">Original</a>
    <h1>GhostRace: Exploiting and Mitigating Speculative Race Conditions</h1>
    
    <div id="readability-page-1" class="page"><div id="main-content">

	<div id="primary">
		<div id="content" role="main">

			
<article id="post-2940" class="page">
	<!-- .entry-header -->
	<div>
		
<p><strong>Exploiting and Mitigating Speculative Race Conditions</strong></p>



<h3><a href="https://www.cve.org/CVERecord?id=CVE-2024-2193" target="_blank" rel="noreferrer noopener">GhostRace: CVE-2024-2193</a></h3>



<p>Race conditions arise when multiple threads attempt to access a shared resource without proper synchronization, often leading to vulnerabilities such as concurrent use-after-free. To mitigate their occurrence, operating systems rely on synchronization primitives such as mutexes, spinlocks, etc.</p>



<p><strong>In this work, we present GhostRace, the first security analysis of these primitives on speculatively executed code paths.</strong></p>



<p><strong>Our key finding is that all the common synchronization primitives implemented using conditional branches (<a href="#mutex-lock">Figure 1</a>) can be microarchitecturally bypassed on speculative paths using a Spectre-v1 attack, turning all architecturally race-free critical regions into Speculative Race Conditions (SRCs), allowing attackers to leak information from the target software.</strong></p>


<div>
<figure id="mutex-lock"><img decoding="async" src="https://lh7-us.googleusercontent.com/A5mtFcjtk0myeLsZ-QqmBi7iFv_h_3wrIdzAVSwGwRiFe35KkzdgkIIiCjko7ORcEoCf7B8-PvbAlpf8nJ92oFNDS3uFdaVSm24VCzdK5dSBPSK-WUKDkXSRf-bWNxK6-Bru6g4W0iC8zA8x3UFcy9Q" alt="Figure 1: Top part: The core implementation of the mutex_lock synchronization primitive in the Linux x86-64 kernel, with the conditional branch that can be abused to craft SRCs in red. Bottom part: The branch ultimately checks the outcome of the lock cmpxchgq instruction, which does not serialize the execution." title="Figure 1"/><figcaption><em>Figure 1: Top part: The core implementation of the mutex_lock synchronization primitive in the Linux x86-64 kernel, with the conditional branch that can be abused to craft SRCs in red. Bottom part: The branch ultimately checks the outcome of the lock cmpxchgq instruction, which does not serialize the execution.</em></figcaption></figure></div>


<hr/>



<p><strong>Our <a href="http://download.vusec.net/papers/ghostrace_sec24.pdf" target="_blank" rel="noreferrer noopener">GhostRace Paper (PDF)</a> is accepted for publication at the 33rd USENIX Security Symposium 2024.</strong> <strong>This is a joint project with the <a href="https://ibm.github.io/system-security-research-updates/2024/03/12/ghostrace" target="_blank" rel="noreferrer noopener">Systems Security Research Group</a> at IBM Research Europe</strong>.</p>







<hr/>



<h2>Speculative Synchronization Primitives</h2>



<p><strong>Our analysis shows <em>all </em>the other common write-side synchronization primitives in the Linux kernel are ultimately implemented through a conditional branch and are therefore vulnerable to speculative race conditions. </strong></p>



<p>To experimentally confirm this intuition, we tested all such synchronization primitives under speculative execution after mistraining the vulnerable branch. <strong>In all cases, we confirmed transient execution of the guarded critical region despite another victim thread already architecturally executing in the region.</strong> To determine the transient window size, we measured the maximum number of speculative load instructions we could speculatively execute inside the critical region (<a href="#speculative-window">Figure 2</a>).</p>


<div>
<figure id="speculative-window"><img decoding="async" src="https://lh7-us.googleusercontent.com/W2JoafY-Chy0JQdu9ihuVmr0G2gq3U4P4RAjvjVbZXGSqvG6Qy2MDPB6SUWb1UnYEHwM0rWRbl33eND2PK9oIS0mGWPxvPy7KfOca9oGK5Ewfe8MFPMYkz2TM6rjmAX6x4pZA7O_aGcACISPdxgYo1U" alt="Figure 2: Transient window size for different write-side synchronization mechanisms, i.e., the number of speculative loads that leave an observable microarchitectural trace." title="Figure 2"/><figcaption><em>Figure 2: Speculative window size for different write-side synchronization mechanisms, i.e., the number of speculative loads that leave an observable microarchitectural trace.</em></figcaption></figure></div>


<h2>SCUAF Gadget Scanner</h2>



<p>To investigate the severity of SRCs, <strong>we concentrate on Speculative Concurrent Use-After-Free (SCUAF) and statically scan the Linux kernel with Coccinelle (<a href="#cocci-script">Figure 3</a>),</strong> <strong>discovering 1,283 potentially exploitable gadgets</strong>.</p>


<div>
<figure id="cocci-script"><img decoding="async" src="https://lh7-us.googleusercontent.com/k-oVgKvuKIRcC7XY9rj2RwuZKN54Dri-xlgnKnGXf5fDlNeptlXJI8F-yZSkpfi_1r3x2RnsCxjyAynYRgt_jCOBKOUskRZfC2Rxpy1ko3hWRSVZo_mr0JdMV34y235LlLOVpOQ9K01R_rckQ-0AFWE" alt="Figure 3: Simplified Cocci scripts (left Free and right Use) scanning for SCUAF gadgets in the Linux kernel." title="Figure 3"/><figcaption><em>Figure 3: Simplified Cocci scripts (left Free and right Use) scanning for SCUAF gadgets in the Linux kernel.</em></figcaption></figure></div>


<h3><a href="https://lore.kernel.org/lkml/2024022614-unhappily-python-2cd0@gregkh/" target="_blank" rel="noreferrer noopener">IPI Storming: CVE-2024-26602</a></h3>



<p>To win an SRC, we need to interrupt the execution of the victim process at the right point (i.e., when the dangling pointer is created), and keep the victim there forever so that the attacker can perform the SCUAF attack. In order to achieve this, we created a new exploitation technique called Inter-Process Interrupt (IPI) Storming, which consists of infinitely flooding the victim process’s CPU core with IPIs once interrupted so that it never finishes handling the incoming interrupts, <strong>resulting in creating an unbounded exploitation window that allows the attacker to execute an arbitrary number of SCUAF invocations to mount an end-to-end attack within a single race window.</strong> In <a href="#IPI-storming">Figure 4</a> we show how the increasing number of storming SMTs widens the UAF exploitation window.</p>


<div>
<figure id="IPI-storming"><img decoding="async" src="https://lh7-us.googleusercontent.com/MKaHNmZBeMuo9s0UQxTYuDHsvBHGF5ESIx38LAav9IXwcfpG_CG3UULkDrWFNzyjjrydVIHnFz6O172oktSAiegAkwsqeSHiv_NsTjtdFYM1SVsBsStW4TpdawvWe12sXRrIuhBoiBjINO969rMiI4k" alt="Figure 4: Size of the UAF exploitation window vs. number of IPI storming cores targeting the victim core." title="Figure 4"/><figcaption><em>Figure 4: Size of the UAF exploitation window vs. number of IPI storming cores targeting the victim core.</em> Our test CPU contains 16 cores and 24 SMTs.</figcaption></figure></div>


<h3>SCUAF Information Disclosure Attacks</h3>



<p>Furthermore, we show that SCUAF information disclosure attacks (<a href="#SCUAF-attack">Figure 5</a>) on the kernel are feasible and can match the reliability of typical Spectre attacks, with <strong>our proof of concept leaking kernel memory at 12 KB/s</strong>.</p>


<div>
<figure id="SCUAF-attack"><img decoding="async" src="https://lh7-us.googleusercontent.com/fwbNm1aDJw8BM6BTUTesMeblQ3_umrNPB86olhS8i8HDwionIkY1lXfnzn6DhPXp4SDQRjdYeqO1YK2ry_j-A5DPqYOrhlQRBbEEzVgq9P-OikA5ZBc6gTx0FKHoP86RgRCvlQ_q1MhE8PdPZE0lEbg" alt="Figure 5: Speculative information disclosure attack exploiting a speculative race condition. Steps 1-4 and 8-10 run in user mode, issuing syscalls to trigger the relevant kernel code. The other steps run in kernel mode. Our gadget scanner identified the nfc_hci_msg_tx_work function as a SCUAF gadget in the Linux kernel." title="Figure 5"/><figcaption><em>Figure 5: Speculative information disclosure attack exploiting a speculative race condition. Steps 1-4 and 8-10 run in user mode, issuing syscalls to trigger the relevant kernel code. The other steps run in kernel mode. Our gadget scanner identified the nfc_hci_msg_tx_work function as a SCUAF gadget in the Linux kernel.</em></figcaption></figure></div>


<h2 id="code">Code</h2>



<p>You can find a minimalistic PoC exemplifying the concept of SRC in a step-by-step single-threaded fashion, Coccinelle SCUAF-scanning scripts, and 1200+ SCUAF gadgets found in the Linux kernel at <a href="https://github.com/vusec/ghostrace" target="_blank" rel="noreferrer noopener">https://github.com/vusec/ghostrace</a></p>



<h2 id="affected-hw-sw">Affected Hardware &amp; Software</h2>



<p>While we have explicitly focused on x86 and Linux in the paper, SRCs also affect other hardware and software targets.</p>



<p><strong>Hardware</strong>: We have confirmed that all the major hardware vendors are affected by SRCs since, regardless of the particular compare-and-exchange instruction implementation, the conditional branch that follows is subject to branch (mis)prediction. In other words, all the microarchitectures affected by Spectre-v1 are also affected by SRCs.</p>



<p><strong>Software</strong>: Any target relying on conditional branches to determine whether to enter critical regions—a common design pattern that extends well beyond Linux—is vulnerable to SRCs.</p>



<p><strong>In summary, any software, e.g., operating system, hypervisor, etc., implementing synchronization primitives through conditional branches without any serializing instruction on that path and running on any microarchitecture (e.g., x86, ARM, RISC-V, etc.), which allows conditional branches to be speculatively executed, is vulnerable to SRCs. As in other speculative execution attacks, this allows leaking data from the target software.</strong></p>



<h2 id="mitigation">Mitigation</h2>



<p>To address the new attack surface,<strong> we also propose a generic SRC mitigation to serialize all the affected synchronization primitives on Linux </strong>(i.e., adding an <code>lfence</code> instruction after the <code>lock cmpxchq</code> in <a href="#mutex-lock">Figure 1</a>)<strong>.</strong> Our mitigation requires minimal kernel changes <strong>(i.e., 2 LoC)</strong> <strong>and incurs only ≈5% geomean performance overhead on LMBench.</strong></p>



<h2 id="disclosure">Disclosure</h2>



<p>We disclosed Speculative Race Conditions to the major hardware vendors (Intel, AMD, ARM, and IBM) and the Linux kernel in late 2023.</p>



<p>Hardware vendors have further notified other affected software (OS/hypervisors) vendors, and all parties have acknowledged the reported issue (<a href="https://www.cve.org/CVERecord?id=CVE-2024-2193" target="_blank" rel="noreferrer noopener"><strong>CVE-2024-2193</strong></a>). Specifically, AMD responded with an explicit impact statement (i.e., “existing [Spectre-v1] mitigations apply”), pointing to the attacks relying on conditional branch mis-speculation, like Spectre-v1.</p>



<p><strong>The Linux kernel developers have no immediate plans to implement our proposed serialization of synchronization primitives due to performance concerns</strong>. However, they confirmed the IPI storming issue (<a href="https://lore.kernel.org/lkml/2024022614-unhappily-python-2cd0@gregkh/" target="_blank" rel="noreferrer noopener"><strong>CVE-2024-26602</strong></a>) and <strong>implemented an </strong><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=944d5fe50f3f03daacfea16300e656a1691c4a23" target="_blank" rel="noreferrer noopener"><strong>IPI rate-limiting feature</strong></a> to address the CPU saturation issue by adding a synchronization mutex on the path of sys_membarrier and avoiding its concurrent execution on multiple cores. <strong>Unfortunately, as our experiments show (Figure 4), hindering IPI storming primitives (i.e., 0 storming cores) is insufficient to close the attack surface completely.</strong></p>



<h2>Acknowledgments</h2>



<p>We would like to thank the anonymous reviewers for their feedback, Andrew Cooper for his early comments on the paper, Julia Lawall for the Coccinelle clarifications, and Alessandro Sorniotti for the early discussions about the project. This work was partially supported by Intel Corporation through the “Allocamelus” project, by the Dutch Research Council (NWO) through project “INTERSECT”, and by the European Union’s Horizon Europe program under grant agreement No. 101120962 (“Rescale”).</p>
	</div><!-- .entry-content -->
</article><!-- #post-2940 -->

		</div><!-- #content -->
	</div><!-- #primary -->
	</div></div>
  </body>
</html>
