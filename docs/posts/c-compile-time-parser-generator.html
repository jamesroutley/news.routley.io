<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/peter-winter/ctpg">Original</a>
    <h1>C&#43;&#43; Compile Time Parser Generator</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
          <article itemprop="text">
<h2 dir="auto"><a id="user-content-c-compile-time-parser-generator" aria-hidden="true" href="#c-compile-time-parser-generator"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><em>C++ Compile Time Parser Generator</em></h2>
<p dir="auto">C++ <em><strong>single header</strong></em> library which takes a language description as a C++ code and turns it into a LR1 table parser with a deterministic finite automaton lexical analyzer, all in compile time.
What&#39;s more, the generated parser is actually itself capable of parsing in compile time.
All it needs is a C++17 compiler!</p>
<h3 dir="auto"><a id="user-content-contents" aria-hidden="true" href="#contents"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Contents</h3>
<ul dir="auto">
<li><a href="#usage">Usage</a></li>
<li><a href="#explanation">Explanation</a>
<ul dir="auto">
<li><a href="#header">Header</a></li>
<li><a href="#namespaces">Namespaces</a></li>
<li><a href="#terminal-symbols">Terminal symbols</a></li>
<li><a href="#nonterminal-symbols">Nonterminal symbols</a></li>
<li><a href="#parser-definition">Parser definition</a></li>
<li><a href="#parse-method-call">Parse method call</a></li>
</ul>
</li>
<li><a href="#compile-time-parsing">Compile Time Parsing</a></li>
<li><a href="#lr1-parser">LR(1) Parser</a>
<ul dir="auto">
<li><a href="#algorithm">Algorithm</a></li>
<li><a href="#conflicts">Conflicts</a></li>
<li><a href="#precedence-and-associativity">Precedence and associativity</a></li>
</ul>
</li>
<li><a href="#functors---advanced">Functors - advanced</a>
<ul dir="auto">
<li><a href="#functor-helpers">Functor helpers</a></li>
<li><a href="#default-functors">Default functors</a></li>
</ul>
</li>
<li><a href="#various-features">Various features</a>
<ul dir="auto">
<li><a href="#parse-options">Parse options</a></li>
<li><a href="#verbose-output">Verbose output</a></li>
<li><a href="#source-tracking">Source tracking</a></li>
<li><a href="#buffers">Buffers</a></li>
<li><a href="#typed-terms">Typed terms</a></li>
<li><a href="#error-recovery">Error recovery</a></li>
</ul>
</li>
<li><a href="#regular-expressions">Regular expressions</a></li>
<li><a href="#diagnostics">Diagnostics</a></li>
</ul>
<h2 dir="auto"><a id="user-content-usage" aria-hidden="true" href="#usage"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Usage</h2>
<p dir="auto">Following code demonstrates a simple parser which takes a comma separated list of integer numbers as argument and prints a sum of them.</p>
<p dir="auto"><strong><code>readme_example.cpp</code></strong></p>
<div data-snippet-clipboard-copy-content="#include &#34;ctpg.hpp&#34;
#include &lt;iostream&gt;
#include &lt;charconv&gt;

using namespace ctpg;
using namespace ctpg::buffers;

constexpr nterm&lt;int&gt; list(&#34;list&#34;);

constexpr char number_pattern[] = &#34;[1-9][0-9]*&#34;;
constexpr regex_term&lt;number_pattern&gt; number(&#34;number&#34;);

int to_int(const std::string_view&amp; sv)
{
    int i = 0;
    std::from_chars(sv.data(), sv.data() + sv.size(), i);
    return i;
}

constexpr parser p(
    list,
    terms(&#39;,&#39;, number),
    nterms(list),
    rules(
        list(number) &gt;=
            to_int,
        list(list, &#39;,&#39;, number) 
            &gt;= [](int sum, char, const auto&amp; n){ return sum + to_int(n); }
    )
);

int main(int argc, char* argv[])
{
    if (argc &lt; 2)
        return -1;
    auto res = p.parse(string_buffer(argv[1]), std::cerr);
    bool success = res.has_value();
    if (success)
        std::cout &lt;&lt; res.value() &lt;&lt; std::endl;
    return success ? 0 : -1;
}
"><pre>#<span>include</span> <span><span>&#34;</span>ctpg.hpp<span>&#34;</span></span>
#<span>include</span> <span><span>&lt;</span>iostream<span>&gt;</span></span>
#<span>include</span> <span><span>&lt;</span>charconv<span>&gt;</span></span>

<span>using</span> <span>namespace</span> <span>ctpg</span><span>;</span>
<span>using</span> <span>namespace</span> <span>ctpg</span>::buffers<span>;</span>

<span>constexpr</span> nterm&lt;<span>int</span>&gt; <span>list</span>(<span><span>&#34;</span>list<span>&#34;</span></span>);

<span>constexpr</span> <span>char</span> number_pattern[] = <span><span>&#34;</span>[1-9][0-9]*<span>&#34;</span></span>;
<span>constexpr</span> regex_term&lt;number_pattern&gt; <span>number</span>(<span><span>&#34;</span>number<span>&#34;</span></span>);

<span>int</span> <span>to_int</span>(<span>const</span> std::string_view&amp; sv)
{
    <span>int</span> i = <span>0</span>;
    <span>std::from_chars</span>(sv.<span>data</span>(), sv.<span>data</span>() + sv.<span>size</span>(), i);
    <span>return</span> i;
}

<span>constexpr</span> parser <span>p</span>(
    list,
    <span>terms</span>(<span><span>&#39;</span>,<span>&#39;</span></span>, number),
    nterms(list),
    rules(
        <span>list</span>(number) &gt;=
            to_int,
        list(list, <span><span>&#39;</span>,<span>&#39;</span></span>, number) 
            &gt;= [](<span>int</span> sum, <span>char</span>, <span>const</span> <span>auto</span>&amp; n){ <span>return</span> sum + <span>to_int</span>(n); }
    )
);

<span>int</span> <span>main</span>(<span>int</span> argc, <span>char</span>* argv[])
{
    <span>if</span> (argc &lt; <span>2</span>)
        <span>return</span> -<span>1</span>;
    <span>auto</span> res = p.<span>parse</span>(<span>string_buffer</span>(argv[<span>1</span>]), std::cerr);
    <span>bool</span> success = res.<span>has_value</span>();
    <span>if</span> (success)
        std::cout &lt;&lt; res.<span>value</span>() &lt;&lt; std::endl;
    <span>return</span> success ? <span>0</span> : -<span>1</span>;
}</pre></div>
<p dir="auto">Compile and run:</p>
<div data-snippet-clipboard-copy-content="g++ readme_example.cpp -std=c++17 -o example &amp;&amp; example &#34;10, 20, 30&#34;
"><pre>g++ readme_example.cpp -std=c++17 -o example <span>&amp;&amp;</span> example <span><span>&#34;</span>10, 20, 30<span>&#34;</span></span></pre></div>
<p dir="auto">You should see the output : 60. If incorrect text supplied as an argument:</p>
<div data-snippet-clipboard-copy-content="g++ readme_example.cpp -std=c++17 -o example &amp;&amp; example &#34;1, 2, 3x&#34;
"><pre>g++ readme_example.cpp -std=c++17 -o example <span>&amp;&amp;</span> example <span><span>&#34;</span>1, 2, 3x<span>&#34;</span></span></pre></div>
<p dir="auto">you should see:</p>
<div data-snippet-clipboard-copy-content="[1:8] PARSE: Unexpected character: x
"><pre><code>[1:8] PARSE: Unexpected character: x
</code></pre></div>
<h2 dir="auto"><a id="user-content-explanation" aria-hidden="true" href="#explanation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Explanation</h2>
<h3 dir="auto"><a id="user-content-header" aria-hidden="true" href="#header"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Header</h3>

<h3 dir="auto"><a id="user-content-namespaces" aria-hidden="true" href="#namespaces"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Namespaces</h3>
<p dir="auto">Namespace ctpg is the top namespace. There are couple of feature namespaces like <code>buffers</code></p>
<div data-snippet-clipboard-copy-content="using namespace ctpg;
using namespace ctpg::buffers;
"><pre><span>using</span> <span>namespace</span> <span>ctpg</span><span>;</span>
<span>using</span> <span>namespace</span> <span>ctpg</span>::buffers<span>;</span></pre></div>
<h3 dir="auto"><a id="user-content-terminal-symbols" aria-hidden="true" href="#terminal-symbols"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Terminal symbols</h3>
<p dir="auto">Terminal symbols (short: terms) are symbols used in grammar definition that are atomic blocks.
Examples of the terms from a C++ language are: identifier, &#39;+&#39; operator, various keywords etc.</p>
<p dir="auto">To define a term use the one of <code>char_term</code>, <code>string_term</code> and <code>regex_term</code> classes.</p>
<p dir="auto">Here is the example of a regex_term with a common integer number regex pattern.</p>
<div data-snippet-clipboard-copy-content="constexpr char number_pattern[] = &#34;[1-9][0-9]*&#34;;
constexpr regex_term&lt;number_pattern&gt; number(&#34;number&#34;);
"><pre><span>constexpr</span> <span>char</span> number_pattern[] = <span><span>&#34;</span>[1-9][0-9]*<span>&#34;</span></span>;
<span>constexpr</span> regex_term&lt;number_pattern&gt; <span>number</span>(<span><span>&#34;</span>number<span>&#34;</span></span>);</pre></div>
<p dir="auto">The constructor argument <code>(&#34;number&#34;)</code> indicates a debug name and can be omitted, however it is not advised.
Names are handy to diagnose problems with the grammar. If omitted, the name will be set to the pattern string.</p>
<blockquote>
<p dir="auto">Note: the pattern needs to have a static linkage to be allowed as a template parameter. This is C++17 limitation, and CTPG does not support C++20 features yet.</p>
</blockquote>
<p dir="auto"><strong>Other types of terms</strong></p>
<p dir="auto"><code>char_term</code> is used when we need to match things like a <code>+</code> or <code>,</code> operator.
<code>string_term</code> is used when we need to match a whole string, like a language keyword.</p>
<h3 dir="auto"><a id="user-content-nonterminal-symbols" aria-hidden="true" href="#nonterminal-symbols"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Nonterminal symbols</h3>
<p dir="auto">Nonterminal symbols (short: nonterms) are essentially all non atomic symbols in the grammar.
In C++ language these are things like: expression, class definition, function declaration etc.</p>
<p dir="auto">To define a nonterm use the <code>nterm</code> class.</p>
<div data-snippet-clipboard-copy-content="constexpr nterm&lt;int&gt; list(&#34;list&#34;);  
"><pre><span>constexpr</span> nterm&lt;<span>int</span>&gt; <span>list</span>(<span><span>&#34;</span>list<span>&#34;</span></span>);  </pre></div>
<p dir="auto">The constructor argument (&#34;list&#34;) is a debug name as well, like in the case of regex_term.
The difference is in nterms names are neccessary, because they serve as unique identifiers as well.
Therefore it is a requirement that nonterm names are unique.</p>
<p dir="auto">Template parameter <code>&lt;int&gt;</code> in this case is a <strong>value type</strong>. More on this concept later.</p>
<h3 dir="auto"><a id="user-content-parser-definition" aria-hidden="true" href="#parser-definition"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Parser definition</h3>
<p dir="auto">The <code>parser</code> class together with its template deduction guides allows to define parsers using 4 arguments:</p>
<ul dir="auto">
<li>Grammar root - symbol which is a top level nonterm for a grammar.</li>
<li>List of all terms</li>
<li>List of all nonterms</li>
<li>List of rules</li>
</ul>
<p dir="auto">The <code>parser</code> object should be declared as <code>constexpr</code>, which makes all the neccessary calculations of the LR(1) table parser done in compile time.</p>
<p dir="auto">Let&#39;s break down the arguments:</p>
<div data-snippet-clipboard-copy-content="constexpr parser p(
    list,
    terms(&#39;,&#39;, number),         
    nterms(list),  
"><pre><span>constexpr</span> parser <span>p</span>(
    list,
    <span>terms</span>(<span><span>&#39;</span>,<span>&#39;</span></span>, number),         
    nterms(list),  </pre></div>
<p dir="auto"><strong>Grammar root.</strong></p>
<p dir="auto">When the root symbol gets matched (in this case <code>list</code>) the parse is successful.</p>
<p dir="auto"><strong>Term list.</strong></p>
<p dir="auto">List of terms enclosed in a <code>terms</code> call. In our case there are two: <code>number</code> and a <code>,</code>.</p>
<blockquote>
<p dir="auto">Note: the <code>,</code> term is not defined earlier in the code.
It is an implicit <code>char_term</code>. The code implicitly converts the char to the <code>char_term</code> class.
Therefore <code>char_terms</code> (as well as <code>string_terms</code>) are allowed not to be defined in advance. Their debug names are assigned to
the them by default to a char (or a string) they represent.</p>
</blockquote>
<p dir="auto"><strong>Nonterm list.</strong></p>
<p dir="auto">List of terms enclosed in a <code>nterms</code> call. In our case, just a single <code>list</code> nonterm is enough.</p>
<p dir="auto"><strong>Rules</strong></p>
<p dir="auto">List of rules enclosed in a <code>rules</code> call.
Each rule is in the form of:
<code>nonterm(symbols...) &gt;= functor </code>
The <code>nonterm</code> part is what&#39;s called a <strong>left side</strong> of the rule. The symbols are called the <strong>right side</strong>.</p>
<p dir="auto">The right side can contain any number of <code>nterm</code> objects as well as terms (<code>regex_terms</code>, <code>char_terms</code> or <code>string_terms</code>).
Terms can be in their implicit form, like <code>,</code> in the example. Implicit <code>string_terms</code> are in form of &#34;strings&#34;.</p>
<div data-snippet-clipboard-copy-content="    rules(
        list(number)
            &gt;= to_int
        list(list, &#39;,&#39;, number)
            &gt;= [](int sum, char, const auto&amp; n)
            { return sum + to_int(n); }
    )
"><pre>    <span>rules</span>(
        <span>list</span>(number)
            &gt;= to_int
        list(list, <span><span>&#39;</span>,<span>&#39;</span></span>, number)
            &gt;= [](<span>int</span> sum, <span>char</span>, <span>const</span> <span>auto</span>&amp; n)
            { <span>return</span> sum + <span>to_int</span>(n); }
    )</pre></div>
<p dir="auto">The first rule <code>list(number)</code> indicates that the <code>list</code> nonterm can be parsed using a single <code>number</code> regex term.</p>
<p dir="auto">The second rule uses what&#39;s know as a left recurrence. In other words, a <code>list</code> can be parsed as a <code>list</code> followed by a <code>,</code> and a <code>number</code>.</p>
<p dir="auto"><strong>Functors</strong></p>
<p dir="auto">The functors are any callables that can accept the exact number of arguments as there are symbols on the right side and return a value type of the left side.
Each nth argument needs to accept a value of a <strong>value type</strong> of the nth right side symbol.</p>
<p dir="auto">So in the case of the first <code>to_int</code> functor, it is required to accept a value type of <code>regex_term</code> and return an <code>int</code>.</p>
<p dir="auto">The second functor is a lambda which accepts 3 arguments: an <code>int</code> for the <code>list</code>, a <code>char</code> for the <code>,</code> and auto for whatever is passed as
a value type for the <code>regex_term</code>.</p>
<blockquote>
<p dir="auto">Note: Functors are called in a way that allows taking advantage of move semantics, so defining it&#39;s arguments as a move reference is encouraged.</p>
</blockquote>
<p dir="auto"><strong>Value types for terms</strong></p>
<p dir="auto">Terms unlike nonterms (which have their value types defined as a template parameter to the nterm definition),
have their value types predefined to either a <code>term_value&lt;char&gt;</code> for a <code>char_term</code>, and a <code>term_value&lt;std::string_view&gt;</code>
for both <code>regex_term</code> and <code>string_term</code>.</p>
<p dir="auto">The <code>term_value</code> class template is a simple wrapper that is implicitly convertible to it&#39;s template parameter (either a <code>char</code> or <code>std::string_view</code>).
That&#39;s why when providing functors we can simply declare arguments as either a <code>char</code> or a <code>std::string_view</code>.
In our case the <code>to_int</code> functor has a <code>const std::string_view&amp;</code> argument, which accepts a <code>term_value&lt;std::string_view&gt;</code> just fine.
Of course an <code>auto</code> in case of lambda will always do the trick.</p>
<p dir="auto">The advantage of declaring functor arguments as <code>term_value</code> specialization is that we can access other features (like <a href="#source-tracking">source tracking</a>) using the <code>term_value</code> methods.</p>
<h3 dir="auto"><a id="user-content-parse-method-call" aria-hidden="true" href="#parse-method-call"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Parse method call</h3>
<p dir="auto">Use <code>parse</code> method with 2 argumets:</p>
<ul dir="auto">
<li>a buffer</li>
<li>an error stream</li>
</ul>
<p dir="auto"><strong>Buffers</strong></p>
<p dir="auto">Use a string_buffer from a <code>buffers</code> namespace to parse a null terminated string or a <code>std::string</code>.</p>
<p dir="auto"><strong>Error stream</strong></p>
<p dir="auto">Stream reference like <code>std::cerr</code> or any other <code>std::ostream</code> can be pased as a stream argument.
This is the place where the <code>parse</code> method is going to spit out error messages like a syntax error.</p>
<div data-snippet-clipboard-copy-content="auto res = p.parse(string_buffer(argv[1]), std::cerr);
"><pre><span>auto</span> res = p.parse(string_buffer(argv[<span>1</span>]), std::cerr);</pre></div>
<p dir="auto"><strong>Parse return value</strong></p>
<p dir="auto">The <code>parse</code> method returns an <code>std::optional&lt;T&gt;</code>, where <code>T</code> is a value type of the root symbol.
Use the <code>.has_value()</code> and the <code>.value()</code> to check and access the result of the parse.</p>
<blockquote>
<p dir="auto">Note: White space characters are skipped by default between consequent terms.</p>
</blockquote>
<h2 dir="auto"><a id="user-content-compile-time-parsing" aria-hidden="true" href="#compile-time-parsing"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Compile time parsing</h2>
<p dir="auto">Example code can be easily changed to create an actual constexpr parser.
First, all the functors need to be constexpr.
To achieve this change the <code>to_int</code> function to:</p>
<div data-snippet-clipboard-copy-content="constexpr int to_int(const std::string_view&amp; sv)
{
    int sum = 0;
    for (auto c : sv) { sum *= 10; sum += c - &#39;0&#39;; }
    return sum;
}
"><pre><span>constexpr</span> <span>int</span> <span>to_int</span>(<span>const</span> std::string_view&amp; sv)
{
    <span>int</span> sum = <span>0</span>;
    <span>for</span> (<span>auto</span> c : sv) { sum *= <span>10</span>; sum += c - <span><span>&#39;</span>0<span>&#39;</span></span>; }
    <span>return</span> sum;
}</pre></div>
<p dir="auto">The function is now <em>constexpr</em>. The <code>&lt;charconv&gt;</code> header is now unneccessary.</p>
<blockquote>
<p dir="auto">Note: To allow <em>constexpr</em> parsing all of the nonterm value types have to be <em>literal types</em>.</p>
</blockquote>
<p dir="auto">Also change the <em>main</em> to use <code>cstring_buffer</code> and declare a parse result <em>constexpr</em>.
The error stream argument is also unavailable in <em>constexpr</em> parsing.</p>
<div data-snippet-clipboard-copy-content="int main(int argc, char* argv[])
{
    if (argc &lt; 2)
    {
        constexpr char example_text[] = &#34;1, 20, 3&#34;;
        
        constexpr auto cres = p.parse(cstring_buffer(example_text)); // notice cstring_buffer and no std::err output
        std::cout &lt;&lt; cres.value() &lt;&lt; std::endl;
        return 0;
    }
        
    auto res = p.parse(string_buffer(argv[1]), std::cerr);
    bool success = res.has_value();
    if (success)
        std::cout &lt;&lt; res.value() &lt;&lt; std::endl;
    return success ? 0 : -1;
}
"><pre><span>int</span> <span>main</span>(<span>int</span> argc, <span>char</span>* argv[])
{
    <span>if</span> (argc &lt; <span>2</span>)
    {
        <span>constexpr</span> <span>char</span> example_text[] = <span><span>&#34;</span>1, 20, 3<span>&#34;</span></span>;
        
        <span>constexpr</span> <span>auto</span> cres = p.<span>parse</span>(<span>cstring_buffer</span>(example_text)); <span><span>//</span> notice cstring_buffer and no std::err output</span>
        std::cout &lt;&lt; cres.<span>value</span>() &lt;&lt; std::endl;
        <span>return</span> <span>0</span>;
    }
        
    <span>auto</span> res = p.<span>parse</span>(<span>string_buffer</span>(argv[<span>1</span>]), std::cerr);
    <span>bool</span> success = res.<span>has_value</span>();
    <span>if</span> (success)
        std::cout &lt;&lt; res.<span>value</span>() &lt;&lt; std::endl;
    <span>return</span> success ? <span>0</span> : -<span>1</span>;
}</pre></div>
<p dir="auto">Now when no argument is passed to the program, it prints the compile time result of parsing &#34;1, 20, 3&#34;.</p>
<div data-snippet-clipboard-copy-content="g++ readme_example.cpp -std=c++17 -o example &amp;&amp; example
"><pre>g++ readme_example.cpp -std=c++17 -o example <span>&amp;&amp;</span> example</pre></div>
<p dir="auto">should print the number 24.</p>
<h3 dir="auto"><a id="user-content-invalid-input-in-constexpr-parsing" aria-hidden="true" href="#invalid-input-in-constexpr-parsing"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Invalid input in <em>constexpr</em> parsing</h3>
<p dir="auto">If the <code>example_text</code> variable was an invalid input, the code <code>cres.value()</code>
would throw, because the <code>cres</code> is of type <code>std::optional&lt;int&gt;</code> with no value.</p>
<p dir="auto">Changing the <code>parse</code> call to:</p>
<div data-snippet-clipboard-copy-content="constexpr int cres = p.parse(cstring_buffer(example_text)).value();
"><pre><code>constexpr int cres = p.parse(cstring_buffer(example_text)).value();
</code></pre></div>
<p dir="auto">would cause compilation error, because throwing <code>std::bad_optional_access</code> is not <em>constexpr</em>.</p>
<h2 dir="auto"><a id="user-content-lr1-parser" aria-hidden="true" href="#lr1-parser"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>LR(1) parser</h2>
<p dir="auto">CTPG uses a LR(1) parser. This is short from left-to-right and 1 lookahead symbol.</p>
<h3 dir="auto"><a id="user-content-algorithm" aria-hidden="true" href="#algorithm"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Algorithm</h3>
<p dir="auto">The parser uses a parse table which is somewhat resembling a state machine.
Here is pseudo code for the algorithm:</p>
<div data-snippet-clipboard-copy-content="struct entry
   int next          // valid if shift
   int rule_length   // valid if reduce
   int nterm_nr      // valid if reduce   
   enum kind {success, shift, reduce, error }
   
bool parse(input, sr_table[states_count][terms_count], goto_table[states_count][nterms_count])
   state = 0
   states.push(state)
   needs_term = true;
   
   while (true)
      if (needs_term)
         term_nr = get_next_term(input)
      entry = sr_table[state, term_nr]
      kind = entry.kind
           
      if (kind == success)
         return true
         
      else if (kind == shift)
         needs_term = true;
         state = entry.next
         states.push(state)
         continue
         
      else if (kind == reduce)
         states.pop_n(entry.rule_length)
         state = states.top()
         state = goto_table[state, entry.nterm_nr]
         continue
         
      else
         return false
"><pre><code>struct entry
   int next          // valid if shift
   int rule_length   // valid if reduce
   int nterm_nr      // valid if reduce   
   enum kind {success, shift, reduce, error }
   
bool parse(input, sr_table[states_count][terms_count], goto_table[states_count][nterms_count])
   state = 0
   states.push(state)
   needs_term = true;
   
   while (true)
      if (needs_term)
         term_nr = get_next_term(input)
      entry = sr_table[state, term_nr]
      kind = entry.kind
           
      if (kind == success)
         return true
         
      else if (kind == shift)
         needs_term = true;
         state = entry.next
         states.push(state)
         continue
         
      else if (kind == reduce)
         states.pop_n(entry.rule_length)
         state = states.top()
         state = goto_table[state, entry.nterm_nr]
         continue
         
      else
         return false
</code></pre></div>
<p dir="auto">Parser contains a state stack, which grows when the algorithm encounters a <em>shift</em> operation and shrinks on <em>reduce</em> operation.</p>
<p dir="auto">Aside from a state stack, there is also a value stack for dedicated for parse result calculation.
Each <em>shift</em> pushes a value to the stack and each <em>reduce</em> calls an appropriate functor with values from a value stack, removing values from a stack and replacing them with a single value associated with a rule&#39;s left side.</p>
<p dir="auto"><strong>Table creation</strong></p>
<p dir="auto">This topic is out of scope of this manual. There is plenty of material online on LR parsers.
Recomended book on the topic: <a href="https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools" rel="nofollow">Compilers: Principles, Techniques and Tools</a></p>
<h3 dir="auto"><a id="user-content-conflicts" aria-hidden="true" href="#conflicts"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Conflicts</h3>
<p dir="auto">There are situations (parser states) in which when a particualr term is encountered on the input, there is an ambiguity regarding the operation a parser should perform.</p>
<p dir="auto">In other words a language grammar may be defined in such a way, that both <em>shift</em> and <em>reduce</em> can lead to a successfull parse result, however the result will be different in both cases.</p>
<p dir="auto"><strong>Example 1</strong></p>
<p dir="auto">Consider a classic expression parser (functors omitted for clarity):</p>
<div data-snippet-clipboard-copy-content="constexpr parser p(
    expr,
    terms(&#39;+&#39;, &#39;*&#39;, number),
    nterms(expr),
    rules(
        expr(number),
        expr(expr, &#39;+&#39;, expr),
        expr(expr, &#39;*&#39;, expr)
    )
);
"><pre><code>constexpr parser p(
    expr,
    terms(&#39;+&#39;, &#39;*&#39;, number),
    nterms(expr),
    rules(
        expr(number),
        expr(expr, &#39;+&#39;, expr),
        expr(expr, &#39;*&#39;, expr)
    )
);
</code></pre></div>
<p dir="auto">Consider <code>2 + 2 * 2</code> input being parsed and a parser in a state after successfully matching <code>2 + 2</code> and encountering <code>*</code> term.</p>
<p dir="auto">Both <em>shifting</em> a <code>*</code> term and <em>reducing</em> by the rule expr(expr, &#39;+&#39;, expr) would be valid, however would produce different results.
This is a classic operator <strong>precedence</strong> case, and this conflict needs to be resolved somehow. This is where precedence and associativity take place.</p>
<h3 dir="auto"><a id="user-content-precedence-and-associativity" aria-hidden="true" href="#precedence-and-associativity"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Precedence and associativity</h3>
<p dir="auto">CTPG parsers can resolve such conflict based on precedence and associativity rules defined in a grammar.</p>
<p dir="auto">Example above can be fixed by explicit term definitions.</p>
<p dir="auto">Normally, <code>char_terms</code> can be introduced by implicit definition in the <code>terms</code> call. However when in need to define a precedence, explicit definition is required.</p>
<p dir="auto">Simply change the code to:</p>
<div data-snippet-clipboard-copy-content="constexpr char_term o_plus(&#39;+&#39;, 1);  // precedence set to 1
constexpr char_term o_mul(&#39;*&#39;, 2);   // precedence set to 2

constexpr parser p(
    expr,
    terms(o_plus, o_mul, number),
    nterms(expr),
    rules(
        expr(number),
        expr(expr, &#39;+&#39;, expr),      // note: no need for o_plus and o_mul in the rules, however possible
        expr(expr, &#39;*&#39;, expr)
    )
);
"><pre><span>constexpr</span> char_term <span>o_plus</span>(<span><span>&#39;</span>+<span>&#39;</span></span>, <span>1</span>);  <span><span>//</span> precedence set to 1</span>
<span>constexpr</span> char_term <span>o_mul</span>(<span><span>&#39;</span>*<span>&#39;</span></span>, <span>2</span>);   <span><span>//</span> precedence set to 2</span>

<span>constexpr</span> parser <span>p</span>(
    expr,
    <span>terms</span>(o_plus, o_mul, number),
    nterms(expr),
    rules(
        <span>expr</span>(number),
        expr(expr, <span><span>&#39;</span>+<span>&#39;</span></span>, expr),      <span><span>//</span> note: no need for o_plus and o_mul in the rules, however possible</span>
        expr(expr, <span><span>&#39;</span>*<span>&#39;</span></span>, expr)
    )
);</pre></div>
<p dir="auto">The higher the precedence value set, the higher the term precedence. Default term precedence is equal to 0.</p>
<p dir="auto">This explicit precedence definition allows a <code>*</code> operator to have bigger precedence over <code>+</code>.</p>
<p dir="auto"><strong>Example 2</strong></p>
<div data-snippet-clipboard-copy-content="constexpr char_term o_plus(&#39;+&#39;, 1);  // precedence set to 1
constexpr char_term o_minus(&#39;-&#39;, 1);  // precedence set to 1
constexpr char_term o_mul(&#39;*&#39;, 2);   // precedence set to 2

constexpr parser p(
    expr,
    terms(o_plus, o_minus, o_mul, number),
    nterms(expr),
    rules(
        expr(number),
        expr(expr, &#39;+&#39;, expr),
        expr(expr, &#39;-&#39;, expr),   // extra rule allowing binary -
        expr(expr, &#39;*&#39;, expr),
        expr(&#39;-&#39;, expr)          // extra rule allowing unary -
    )
);
"><pre><span>constexpr</span> char_term <span>o_plus</span>(<span><span>&#39;</span>+<span>&#39;</span></span>, <span>1</span>);  <span><span>//</span> precedence set to 1</span>
<span>constexpr</span> char_term <span>o_minus</span>(<span><span>&#39;</span>-<span>&#39;</span></span>, <span>1</span>);  <span><span>//</span> precedence set to 1</span>
<span>constexpr</span> char_term <span>o_mul</span>(<span><span>&#39;</span>*<span>&#39;</span></span>, <span>2</span>);   <span><span>//</span> precedence set to 2</span>

<span>constexpr</span> parser <span>p</span>(
    expr,
    <span>terms</span>(o_plus, o_minus, o_mul, number),
    nterms(expr),
    rules(
        <span>expr</span>(number),
        expr(expr, <span><span>&#39;</span>+<span>&#39;</span></span>, expr),
        expr(expr, <span><span>&#39;</span>-<span>&#39;</span></span>, expr),   <span><span>//</span> extra rule allowing binary -</span>
        expr(expr, <span><span>&#39;</span>*<span>&#39;</span></span>, expr),
        expr(<span><span>&#39;</span>-<span>&#39;</span></span>, expr)          <span><span>//</span> extra rule allowing unary -</span>
    )
);</pre></div>
<p dir="auto">Binary <code>-</code> and <code>+</code> operators have the same precedence in pretty much all languages.
Unary <code>-</code> however almost always have a bigger precedence than all binary operators.
We can&#39;t achieve this by simply defining <code>-</code> precedence in <code>char_term</code> definition.
We need a way to tell that <code>expr(&#39;-&#39;, expr)</code> has a bigger precedence then all binary rules.</p>
<p dir="auto">To achieve this override the precedence in a term by a precedence in a rule changing:</p>
<p dir="auto"><code>expr(&#39;-&#39;, expr)</code>
to
<code>expr(&#39;-&#39;, expr)[3]</code></p>
<p dir="auto">The <code>[]</code> operator allows exactly this. It explicitly sets the rule precedence so the parser does not have to deduce rule precedence from a term.</p>
<p dir="auto">So the final code looks like this:</p>
<div data-snippet-clipboard-copy-content="constexpr char_term o_plus(&#39;+&#39;, 1);  // precedence set to 1
constexpr char_term o_minus(&#39;-&#39;, 1);  // precedence set to 1
constexpr char_term o_mul(&#39;*&#39;, 2);   // precedence set to 2

constexpr parser p(
    expr,
    terms(o_plus, o_minus, o_mul, number),
    nterms(expr),
    rules(
        expr(number),
        expr(expr, &#39;+&#39;, expr),
        expr(expr, &#39;-&#39;, expr),   // extra rule allowing binary -
        expr(expr, &#39;*&#39;, expr),
        expr(&#39;-&#39;, expr)[3]       // extra rule allowing unary -, with biggest precedence
    )
);
"><pre><span>constexpr</span> char_term <span>o_plus</span>(<span><span>&#39;</span>+<span>&#39;</span></span>, <span>1</span>);  <span><span>//</span> precedence set to 1</span>
<span>constexpr</span> char_term <span>o_minus</span>(<span><span>&#39;</span>-<span>&#39;</span></span>, <span>1</span>);  <span><span>//</span> precedence set to 1</span>
<span>constexpr</span> char_term <span>o_mul</span>(<span><span>&#39;</span>*<span>&#39;</span></span>, <span>2</span>);   <span><span>//</span> precedence set to 2</span>

<span>constexpr</span> parser <span>p</span>(
    expr,
    <span>terms</span>(o_plus, o_minus, o_mul, number),
    nterms(expr),
    rules(
        <span>expr</span>(number),
        expr(expr, <span><span>&#39;</span>+<span>&#39;</span></span>, expr),
        expr(expr, <span><span>&#39;</span>-<span>&#39;</span></span>, expr),   <span><span>//</span> extra rule allowing binary -</span>
        expr(expr, <span><span>&#39;</span>*<span>&#39;</span></span>, expr),
        expr(<span><span>&#39;</span>-<span>&#39;</span></span>, expr)[3]       <span><span>//</span> extra rule allowing unary -, with biggest precedence</span>
    )
);</pre></div>
<p dir="auto"><strong>Example 3</strong></p>
<p dir="auto">Consider the final code and let&#39;s say the input is <code>2 + 2 + 2</code>, parser has read <code>2 + 2</code> and is about to read the second <code>+</code>.
In this case what is the required behaviour? Should the first <code>2 + 2</code> be reduced or a second <code>+</code> should be shifted?
(This may not matter in case of integer calculations, but may have a big difference in situations like expression type deduction in c++ when operator overloading is involved.)</p>
<p dir="auto">This is the classic <strong>associativity</strong> case which can be solved by expicitly defining the term associativity.</p>
<p dir="auto">There are 3 types of associativity available: <em>left to right</em>, <em>right to left</em> and <em>not associative</em> as the default.</p>
<p dir="auto">To explicitly define a term associativity change the term definitions to:</p>
<div data-snippet-clipboard-copy-content="constexpr char_term o_plus(&#39;+&#39;, 1, associativity::ltor);
constexpr char_term o_minus(&#39;-&#39;, 1, associativity::ltor);
constexpr char_term o_mul(&#39;*&#39;, 2, associativity::ltor);
"><pre><span>constexpr</span> char_term <span>o_plus</span>(<span><span>&#39;</span>+<span>&#39;</span></span>, <span>1</span>, associativity::ltor);
<span>constexpr</span> char_term <span>o_minus</span>(<span><span>&#39;</span>-<span>&#39;</span></span>, <span>1</span>, associativity::ltor);
<span>constexpr</span> char_term <span>o_mul</span>(<span><span>&#39;</span>*<span>&#39;</span></span>, <span>2</span>, associativity::ltor);</pre></div>
<p dir="auto">Now all of these operators are left associative, meaning the <em>reduce</em> will be preferred over <em>shift</em>.</p>
<p dir="auto">Should the associativity be defined as <code>associativity::rtol</code>, <em>shift</em> would be preferred.</p>
<p dir="auto">No associativity prefers shift by default.</p>
<p dir="auto"><strong>Precedence and associativity summary</strong></p>
<p dir="auto">When a <em>shift</em> <em>reduce</em> conflict is encountered these rules apply in order:</p>
<p dir="auto">Let <strong>r</strong> be a rule which is a subject to reduce and <strong>t</strong> be a term that is encountered on input.</p>
<ol dir="auto">
<li>when explicit <strong>r</strong> precedence  from <code>[]</code> operator is bigger than <strong>t</strong> precedence, perform a <em>reduce</em></li>
<li>when precedence of <strong>last term</strong> in <strong>r</strong> is bigger than <strong>t</strong> precedence, perform a <em>reduce</em></li>
<li>when precedence of <strong>last term</strong> in <strong>r</strong> is equal to <strong>t</strong> precedence and
<strong>last term</strong> in <strong>r</strong> is left associative, perform a <em>reduce</em></li>
<li>otherwise, perform a <em>shift</em>.</li>
</ol>
<p dir="auto"><strong>Reduce - reduce conflicts</strong></p>
<p dir="auto">In some cases the language is ill formed and the parser contains a state in which there is an ambiguity between several <em>reduce</em> actions.</p>
<p dir="auto">Consider example:</p>
<div data-snippet-clipboard-copy-content="constexpr nterm&lt;char&gt; op(&#34;op&#34;);
constexpr nterm&lt;char&gt; special_op(&#34;op&#34;);

constexpr parser p(
    op,
    terms(&#39;!&#39;, &#39;*&#39;, &#39;+&#39;),
    nterms(special_op, op),
    rules(
        special_op(&#39;!&#39;),
        op(&#39;!&#39;), 
        op(&#39;*&#39;),
        op(&#39;+&#39;),
        op(special_op)
    )
);
"><pre><span>constexpr</span> nterm&lt;<span>char</span>&gt; <span>op</span>(<span><span>&#34;</span>op<span>&#34;</span></span>);
<span>constexpr</span> nterm&lt;<span>char</span>&gt; <span>special_op</span>(<span><span>&#34;</span>op<span>&#34;</span></span>);

<span>constexpr</span> parser <span>p</span>(
    op,
    <span>terms</span>(<span><span>&#39;</span>!<span>&#39;</span></span>, <span><span>&#39;</span>*<span>&#39;</span></span>, <span><span>&#39;</span>+<span>&#39;</span></span>),
    nterms(special_op, op),
    rules(
        <span>special_op</span>(<span><span>&#39;</span>!<span>&#39;</span></span>),
        op(<span><span>&#39;</span>!<span>&#39;</span></span>), 
        op(<span><span>&#39;</span>*<span>&#39;</span></span>),
        op(<span><span>&#39;</span>+<span>&#39;</span></span>),
        op(special_op)
    )
);</pre></div>
<p dir="auto">Let&#39;s say we parse an input <code>!</code>. The parser has no way of telling if it should reduce using rule <code>special_op(&#39;!&#39;)</code> or <code>op(&#39;!&#39;)</code>.</p>
<p dir="auto">This is an example of reduce/reduce conflict and such parser behaviour should be considered <em>undefined</em>.</p>
<p dir="auto">There is a diagnostic tool included in CTPG which detects such conflicts so they can be addressed.</p>
<h2 dir="auto"><a id="user-content-functors---advanced" aria-hidden="true" href="#functors---advanced"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Functors - advanced</h2>
<p dir="auto">Consider a parser matching white space separated names (strings).</p>
<div data-snippet-clipboard-copy-content="
constexpr char pattern[] = &#34;[a-zA-Z0-9_]+&#34;;
constexpr regex_term&lt;pattern&gt; name(&#34;name&#34;);
using name_type = std::string_view;
using list_type = std::vector&lt;name_type&gt;;
constexpr nterm&lt;list_type&gt; list(&#34;list&#34;);

constexpr parser p(
    list,
    terms(name),
    nterms(list),
    rules(
        list(),
        list(list, name)
    )
);
"><pre><span>constexpr</span> <span>char</span> pattern[] = <span><span>&#34;</span>[a-zA-Z0-9_]+<span>&#34;</span></span>;
<span>constexpr</span> regex_term&lt;pattern&gt; <span>name</span>(<span><span>&#34;</span>name<span>&#34;</span></span>);
<span>using</span> name_type = std::string_view;
<span>using</span> list_type = std::vector&lt;name_type&gt;;
<span>constexpr</span> nterm&lt;list_type&gt; <span>list</span>(<span><span>&#34;</span>list<span>&#34;</span></span>);

<span>constexpr</span> parser <span>p</span>(
    list,
    <span>terms</span>(name),
    nterms(list),
    rules(
        <span>list</span>(),
        list(list, name)
    )
);</pre></div>
<p dir="auto">How exactly would the functors look for this kind of parser?</p>
<p dir="auto">The first rule <code>list()</code> is an example of an empty rule. This means the list can be <em>reduced</em> from no input.</p>
<p dir="auto">Since the rule&#39;s left side is a <code>list</code> the functor needs to return its <strong>value type</strong>, which is a <code>list_type</code>.
The right side is empty so the functor needs to have no arguments.</p>
<p dir="auto">So let&#39;s return an empty vector: <code>[](){ return list_type{}; }</code></p>
<p dir="auto">The second rule reduces a list from a name and a list, therefore the functor needs to accept:</p>
<ul dir="auto">
<li><code>list_type</code> for the first argument: list</li>
<li><code>term_value&lt;std::string_view&gt;</code> for the second argument: name</li>
<li>return a <code>list_type</code></li>
</ul>
<p dir="auto">So let&#39;s create a functor:</p>
<p dir="auto"><code>[](auto&amp;&amp; list, auto&amp;&amp; name){ list.emplace_back(std::move(name)); return list; }</code></p>
<p dir="auto">The <code>name</code> argument will resolve to <code>term_value&lt;std::string_view&gt;&amp;&amp;</code>, which is convertible to <code>std::string_view&amp;&amp;</code>.</p>
<p dir="auto">Now the parser looks like this:</p>
<div data-snippet-clipboard-copy-content="constexpr char pattern[] = &#34;[a-zA-Z0-9_]+&#34;;
constexpr regex_term&lt;pattern&gt; name(&#34;name&#34;);
using name_type = std::string_view;
using list_type = std::vector&lt;name_type&gt;;
constexpr nterm&lt;list_type&gt; list(&#34;list&#34;);

constexpr parser p(
    list,
    terms(name),
    nterms(list),
    rules(
        list() 
            &gt;= [](){ return list_type{}; },
        list(list, name)
            &gt;= [](auto&amp;&amp; list, auto&amp;&amp; name){ list.push_back(name); return std::move(list); }
    )
);
"><pre><span>constexpr</span> <span>char</span> pattern[] = <span><span>&#34;</span>[a-zA-Z0-9_]+<span>&#34;</span></span>;
<span>constexpr</span> regex_term&lt;pattern&gt; <span>name</span>(<span><span>&#34;</span>name<span>&#34;</span></span>);
<span>using</span> name_type = std::string_view;
<span>using</span> list_type = std::vector&lt;name_type&gt;;
<span>constexpr</span> nterm&lt;list_type&gt; <span>list</span>(<span><span>&#34;</span>list<span>&#34;</span></span>);

<span>constexpr</span> parser <span>p</span>(
    list,
    <span>terms</span>(name),
    nterms(list),
    rules(
        <span>list</span>() 
            &gt;= [](){ <span>return</span> list_type{}; },
        <span>list</span>(list, name)
            &gt;= [](<span>auto</span>&amp;&amp; list, <span>auto</span>&amp;&amp; name){ list.<span>push_back</span>(name); <span>return</span> <span>std::move</span>(list); }
    )
);</pre></div>
<blockquote>
<p dir="auto">Note: Here we take advantage of move semantics which are supported in the functor calls. This way we are working with the same <code>std::vector</code> instance
we created as empty using the first rule.</p>
</blockquote>
<blockquote>
<p dir="auto"><strong>Important Note</strong>
It is possible for functors to have referrence (both const and not) argument types, however lifetime of the objects passed to functors ends immediately after the functor returns.
So it is better to avoid using referrence types as nterm value types.</p>
</blockquote>
<h3 dir="auto"><a id="user-content-functor-helpers" aria-hidden="true" href="#functor-helpers"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Functor helpers</h3>
<p dir="auto">There are a couple of handy ready to use functor templates:</p>
<p dir="auto"><strong>val</strong></p>
<p dir="auto">Use when a functor needs to return a value which doesn&#39;t depend on left side:</p>
<div data-snippet-clipboard-copy-content="using namespace ctpg::ftors;
constexpr nterm&lt;bool&gt; binary(&#34;binary&#34;);

constexpr parser p(
    binary,
    terms(&#39;0&#39;, &#39;1&#39;, &#39;&amp;&#39;, &#39;|&#39;),
    nterms(binary),
    rules(
        binary(&#39;0&#39;) 
            &gt;= val(false),
        binary(&#39;1&#39;) 
            &gt;= val(true),
        binary(binary, &#39;&amp;&#39;, binary) 
            &gt;= [](bool b1, auto, bool b2){ return b1 &amp; b2; },
        binary(binary, &#39;|&#39;, binary) 
            &gt;= [](bool b1, auto, bool b2){ return b1 | b2; },
    )
);   
"><pre><span>using</span> <span>namespace</span> <span>ctpg</span>::ftors<span>;</span>
<span>constexpr</span> nterm&lt;<span>bool</span>&gt; <span>binary</span>(<span><span>&#34;</span>binary<span>&#34;</span></span>);

<span>constexpr</span> parser <span>p</span>(
    binary,
    <span>terms</span>(<span><span>&#39;</span>0<span>&#39;</span></span>, <span><span>&#39;</span>1<span>&#39;</span></span>, <span><span>&#39;</span>&amp;<span>&#39;</span></span>, <span><span>&#39;</span>|<span>&#39;</span></span>),
    nterms(binary),
    rules(
        <span>binary</span>(<span><span>&#39;</span>0<span>&#39;</span></span>) 
            &gt;= val(<span>false</span>),
        binary(<span><span>&#39;</span>1<span>&#39;</span></span>) 
            &gt;= val(<span>true</span>),
        binary(binary, <span><span>&#39;</span>&amp;<span>&#39;</span></span>, binary) 
            &gt;= [](<span>bool</span> b1, <span>auto</span>, <span>bool</span> b2){ <span>return</span> b1 &amp; b2; },
        <span>binary</span>(binary, <span><span>&#39;</span>|<span>&#39;</span></span>, binary) 
            &gt;= [](<span>bool</span> b1, <span>auto</span>, <span>bool</span> b2){ <span>return</span> b1 | b2; },
    )
);   </pre></div>
<p dir="auto"><strong>create</strong></p>
<p dir="auto">Use when a functor needs to return a default value of a given type:</p>
<div data-snippet-clipboard-copy-content="
// word list parser from one of previous examples

using namespace ctpg::ftors;

constexpr parser p(
    list,
    terms(name),
    nterms(list),
    rules(
        list() 
            &gt;= create&lt;list_type&gt;{},    // use instead of a lambda
        list(list, name)
            &gt;= [](auto&amp;&amp; list, auto&amp;&amp; name){ list.push_back(name); return std::move(list); }
    )
);
"><pre><span><span>//</span> word list parser from one of previous examples</span>

<span>using</span> <span>namespace</span> <span>ctpg</span>::ftors<span>;</span>

<span>constexpr</span> parser <span>p</span>(
    list,
    <span>terms</span>(name),
    nterms(list),
    rules(
        <span>list</span>() 
            &gt;= create&lt;list_type&gt;{},    <span><span>//</span> use instead of a lambda</span>
        <span>list</span>(list, name)
            &gt;= [](<span>auto</span>&amp;&amp; list, <span>auto</span>&amp;&amp; name){ list.<span>push_back</span>(name); <span>return</span> <span>std::move</span>(list); }
    )
);</pre></div>
<p dir="auto"><strong>element placeholders</strong></p>
<p dir="auto">Use whenever a rule simply passes nth element from the right side:</p>
<div data-snippet-clipboard-copy-content="
using namespace ctpg::ftors;

constexpr char pattern[] = &#34;[1-9][0-9]*&#34;;
constexpr regex_term&lt;pattern&gt; number(&#34;number&#34;);

constexpr to_int(std::string_view x){ /*implement*/ }

constexpr nterm&lt;int&gt; expr(&#34;expr&#34;);

constexpr parser p(
    expr,
    terms(&#39;+&#39;, &#39;(&#39;, &#39;)&#39;, number),
    nterms(expr),
    rules(
        expr(number)
            &gt;= to_int,
        expr(expr, &#39;+&#39;, expr)
            &gt;= [](int i1, auto, int i2){ return i1 + i2; },
        expr(&#39;(&#39;, expr, &#39;)&#39;)
            &gt;= _e2      // here, just return the second element
    )
);
"><pre><span>using</span> <span>namespace</span> <span>ctpg</span>::ftors<span>;</span>

<span>constexpr</span> <span>char</span> pattern[] = <span><span>&#34;</span>[1-9][0-9]*<span>&#34;</span></span>;
<span>constexpr</span> regex_term&lt;pattern&gt; <span>number</span>(<span><span>&#34;</span>number<span>&#34;</span></span>);

<span>constexpr</span> <span>to_int</span>(std::string_view x){ <span><span>/*</span>implement<span>*/</span></span> }

<span>constexpr</span> nterm&lt;<span>int</span>&gt; <span>expr</span>(<span><span>&#34;</span>expr<span>&#34;</span></span>);

<span>constexpr</span> parser <span>p</span>(
    expr,
    <span>terms</span>(<span><span>&#39;</span>+<span>&#39;</span></span>, <span><span>&#39;</span>(<span>&#39;</span></span>, <span><span>&#39;</span>)<span>&#39;</span></span>, number),
    nterms(expr),
    rules(
        <span>expr</span>(number)
            &gt;= to_int,
        expr(expr, <span><span>&#39;</span>+<span>&#39;</span></span>, expr)
            &gt;= [](<span>int</span> i1, <span>auto</span>, <span>int</span> i2){ <span>return</span> i1 + i2; },
        <span>expr</span>(<span><span>&#39;</span>(<span>&#39;</span></span>, expr, <span><span>&#39;</span>)<span>&#39;</span></span>)
            &gt;= _e2      <span><span>//</span> here, just return the second element</span>
    )
);</pre></div>
<p dir="auto"><strong>list helpers</strong></p>
<p dir="auto">Use <code>push_back</code> or <code>emplace_back</code> when dealing with common list tasks.</p>
<p dir="auto">The <code>push_back</code> calls <code>push_back</code> on first element passing second element as argument:</p>
<div data-snippet-clipboard-copy-content="list(list, element) = push_back{}
"><pre><code>list(list, element) = push_back{}
</code></pre></div>
<p dir="auto">The <code>emplace</code> back works similarly but supports move semantics.</p>
<div data-snippet-clipboard-copy-content="
// word list parser from one of previous examples

using namespace ctpg::ftors;

constexpr parser p(
    list,
    terms(name),
    nterms(list),
    rules(
        list() 
            &gt;= create&lt;list_type&gt;{},
        list(list, name)
            &gt;= push_back{}
    )
);
"><pre><span><span>//</span> word list parser from one of previous examples</span>

<span>using</span> <span>namespace</span> <span>ctpg</span>::ftors<span>;</span>

<span>constexpr</span> parser <span>p</span>(
    list,
    <span>terms</span>(name),
    nterms(list),
    rules(
        <span>list</span>() 
            &gt;= create&lt;list_type&gt;{},
        <span>list</span>(list, name)
            &gt;= push_back{}
    )
);</pre></div>
<p dir="auto">Both <code>push_back</code> an <code>emplace_back</code> are class templates, which take two indexes (like in case of element placeholders one-indexed),
denoting element numbers for the list and the value to append.</p>
<p dir="auto">So in case of comma separeted numbers, we can simply use:</p>
<div data-snippet-clipboard-copy-content="rules(
    list() &gt;= create&lt;std::vector&lt;int&gt;&gt;{},
    list(list, &#39;,&#39;, number) &gt;= push_back&lt;1, 3&gt;{}  // 1 is the list, 3 is the number
)
"><pre><span>rules</span>(
    <span>list</span>() &gt;= create&lt;std::vector&lt;int&gt;&gt;{},
    <span>list</span>(list, <span><span>&#39;</span>,<span>&#39;</span></span>, number) &gt;= push_back&lt;1, 3&gt;{}  <span><span>//</span> 1 is the list, 3 is the number</span>
)</pre></div>
<h2 dir="auto"><a id="user-content-default-functors" aria-hidden="true" href="#default-functors"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Default functors</h2>
<p dir="auto">There is a situation where the functor can be entirely omitted, that is whenever a left side value type is <em>move constructible</em> from right side value types:</p>
<div data-snippet-clipboard-copy-content="// Example parser, accepts url addresses in for of a protocol and a list of words, like: https://www.example.com

constexpr char word_pattern[] = &#34;[0-9A-Za-z]+&#34;;
constexpr regex_term&lt;word_pattern&gt; word(&#34;word&#34;);
constexpr char protocol_pattern[] = &#34;http://|https://&#34;;
constexpr regex_term&lt;protocol_pattern&gt; protocol(&#34;protocol&#34;);

using list_type = std::vector&lt;std:string_view&gt;;
struct url_type
{
    constexpr url_type(std::string_view pr, list_type&amp;&amp; l):
         pr(pr), l(std::move(l))
    {}
    std::string_view pr;
    list_type l;
};

constexpr nterm&lt;url_type&gt; url;
constexpr nterm&lt;list_type&gt; list;

constexpr parser p(
    url,
    terms(word, &#39;.&#39;, protocol),
    nterms(url, list),
    rules(
        list(word)
            &gt;= [](auto w){ return list_type{w}; },
        list(list, &#39;.&#39;, word)
            &gt;= [](auto&amp;&amp; l, auto, auto w){ l.push_back(w); return std::move(l); },
        url(protocol, list)
            // skip functor entirely, url_type move constructible from right side value types
    )
);
"><pre><span><span>//</span> Example parser, accepts url addresses in for of a protocol and a list of words, like: https://www.example.com</span>

<span>constexpr</span> <span>char</span> word_pattern[] = <span><span>&#34;</span>[0-9A-Za-z]+<span>&#34;</span></span>;
<span>constexpr</span> regex_term&lt;word_pattern&gt; <span>word</span>(<span><span>&#34;</span>word<span>&#34;</span></span>);
<span>constexpr</span> <span>char</span> protocol_pattern[] = <span><span>&#34;</span>http://|https://<span>&#34;</span></span>;
<span>constexpr</span> regex_term&lt;protocol_pattern&gt; <span>protocol</span>(<span><span>&#34;</span>protocol<span>&#34;</span></span>);

<span>using</span> list_type = std::vector&lt;std:string_view&gt;;
<span>struct</span> <span>url_type</span>
{
    <span>constexpr</span> <span>url_type</span>(std::string_view pr, list_type&amp;&amp; l):
         pr(pr), l(std::move(l))
    {}
    std::string_view pr;
    list_type l;
};

<span>constexpr</span> nterm&lt;url_type&gt; url;
<span>constexpr</span> nterm&lt;list_type&gt; list;

<span>constexpr</span> parser <span>p</span>(
    url,
    <span>terms</span>(word, <span><span>&#39;</span>.<span>&#39;</span></span>, protocol),
    nterms(url, list),
    rules(
        <span>list</span>(word)
            &gt;= [](<span>auto</span> w){ <span>return</span> list_type{w}; },
        <span>list</span>(list, <span><span>&#39;</span>.<span>&#39;</span></span>, word)
            &gt;= [](<span>auto</span>&amp;&amp; l, <span>auto</span>, <span>auto</span> w){ l.<span>push_back</span>(w); <span>return</span> <span>std::move</span>(l); },
        <span>url</span>(protocol, list)
            <span><span>//</span> skip functor entirely, url_type move constructible from right side value types</span>
    )
);</pre></div>
<h2 dir="auto"><a id="user-content-various-features" aria-hidden="true" href="#various-features"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Various features</h2>
<h3 dir="auto"><a id="user-content-parse-options" aria-hidden="true" href="#parse-options"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Parse options</h3>
<p dir="auto">To change the parse options simply provide a <code>parse_options</code> instance to the <code>parse</code> call:</p>
<div data-snippet-clipboard-copy-content="p.parse(parse_options{}, cstring_buffer(&#34;abc&#34;), std::cerr);
"><pre>p.parse(parse_options{}, cstring_buffer(<span><span>&#34;</span>abc<span>&#34;</span></span>), std::cerr);</pre></div>
<p dir="auto">To set a particular option use on of the <code>set_xxx</code> methods:</p>
<div data-snippet-clipboard-copy-content="p.parse(parse_options{}.set_verbose(), cstring_buffer(&#34;abc&#34;), std::cerr);
"><pre>p.parse(parse_options{}.set_verbose(), cstring_buffer(<span><span>&#34;</span>abc<span>&#34;</span></span>), std::cerr);</pre></div>
<blockquote>
<p dir="auto">Note: The <code>set_xxx</code> methods return <code>parse_options</code> instance using <code>*this</code>, so they can be chained together.</p>
</blockquote>
<p dir="auto">The list of available parse options:</p>
<ul dir="auto">
<li>set_skip_whitespace(bool value)</li>
</ul>
<p dir="auto">By default parser skips the whitespace characters between the terms, this can be changed using this option.</p>
<ul dir="auto">
<li>set_verbose(bool value)</li>
</ul>
<p dir="auto">Sets the parser to verbose mode. More on this in the <a href="#verbose-output">Verbose output</a> section.</p>
<h3 dir="auto"><a id="user-content-verbose-output" aria-hidden="true" href="#verbose-output"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Verbose output</h3>
<p dir="auto">To allow verbose output for debugging purposes call <code>parse</code> method with such arguments:</p>
<div data-snippet-clipboard-copy-content="p.parse(parse_options{}.set_verbose(), cstring_buffer(&#34;abc&#34;), std::cerr);
"><pre>p.parse(parse_options{}.set_verbose(), cstring_buffer(<span><span>&#34;</span>abc<span>&#34;</span></span>), std::cerr);</pre></div>
<p dir="auto">The default <code>parse_options</code> is appended with the <code>set_verbose</code> call, thus changing the verbosity option.
The last argument can be anything convertible to <code>std::ostream</code> referrence.</p>
<p dir="auto">The verbose output stream contains alongside usual syntax errors, the detailed process of syntax and lexical analyze.
The shift and reduce actions are put to the output which is useful together with the <a href="#diagnostics">Diagnostics</a> information.
The lexical analyzer DFA actions are also printed, again useful during diagnostics.</p>
<h3 dir="auto"><a id="user-content-source-tracking" aria-hidden="true" href="#source-tracking"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Source tracking</h3>
<p dir="auto">Source tracking is a feature that makes the parser keep track of <strong>source point</strong> (that is line and column) it is currently in.
This feature is always available and source point information is attached to every <strong>term value</strong> that is passed to a functor.</p>
<p dir="auto">To use this information make the functor accept the <code>term_value</code> type arguments for each term.</p>
<p dir="auto">For <em>char_terms</em> the value type is <code>term_value&lt;char&gt;</code>, for both <em>string_term</em> and <em>regtex_term</em> the value type is <code>term_value&lt;std::string_view</code>.
Each of these types have the <code>source_point</code> member that can be accessed using <code>get_sp()</code> method.</p>
<p dir="auto">The <code>source_point</code> struct has a <code>line</code> and <code>column</code> public members and can be output to a stream using <code>&lt;&lt;</code> operator.</p>
<p dir="auto">This is an example of a parser that accepts a whitespace separated words and stores them in a collection together with their source points.</p>
<p dir="auto">Take a look on the functor that utilises both value and source point of a word using <code>const auto&amp; w</code> argument by calling <code>get_value()</code> and <code>get_sp()</code> respectively.</p>
<div data-snippet-clipboard-copy-content="#include &#34;ctpg.hpp&#34;
#include &lt;iostream&gt;

using namespace ctpg;
using namespace ctpg::ftors;
using namespace ctpg::buffers;

struct word_t
{
    std::string w;
    source_point sp;
};

using text_t = std::vector&lt;word_t&gt;;

auto&amp;&amp; add_word(text_t&amp;&amp; txt, std::string_view sv, source_point sp)
{
    txt.push_back(word_t{std::string(sv), sp});
    return std::move(txt);
}

constexpr char word_pattern[] = &#34;[A-Za-z]+&#34;;
constexpr regex_term&lt;word_pattern&gt; word(&#34;word&#34;);
constexpr nterm&lt;text_t&gt; text(&#34;text&#34;);

constexpr parser p(
    text,
    terms(word),
    nterms(text),
    rules(
        text() &gt;= create&lt;text_t&gt;{},
        text(text, word) &gt;= [](auto&amp;&amp; txt, const auto&amp; w) { return add_word(std::move(txt), w.get_value(), w.get_sp()); }
    )
);

int main(int argc, char* argv[])
{
    if (argc &lt; 2)
        return -1;
    auto res = p.parse(string_buffer(argv[1]), std::cout);
    if (res.has_value())
    {
        for (const auto&amp; w : res.value())
        {
            std::cout &lt;&lt; w.w &lt;&lt; &#34; at &#34; &lt;&lt; w.sp &lt;&lt; std::endl;
        }
    }
    return 0;
}
"><pre>#<span>include</span> <span><span>&#34;</span>ctpg.hpp<span>&#34;</span></span>
#<span>include</span> <span><span>&lt;</span>iostream<span>&gt;</span></span>

<span>using</span> <span>namespace</span> <span>ctpg</span><span>;</span>
<span>using</span> <span>namespace</span> <span>ctpg</span>::ftors<span>;</span>
<span>using</span> <span>namespace</span> <span>ctpg</span>::buffers<span>;</span>

<span>struct</span> <span>word_t</span>
{
    std::string w;
    source_point sp;
};

<span>using</span> <span>text_t</span> = std::vector&lt;<span>word_t</span>&gt;;

<span>auto</span>&amp;&amp; add_word(<span>text_t</span>&amp;&amp; txt, std::string_view sv, source_point sp)
{
    txt.<span>push_back</span>(<span>word_t</span>{<span>std::string</span>(sv), sp});
    <span>return</span> <span>std::move</span>(txt);
}

<span>constexpr</span> <span>char</span> word_pattern[] = <span><span>&#34;</span>[A-Za-z]+<span>&#34;</span></span>;
<span>constexpr</span> regex_term&lt;word_pattern&gt; <span>word</span>(<span><span>&#34;</span>word<span>&#34;</span></span>);
<span>constexpr</span> nterm&lt;<span>text_t</span>&gt; <span>text</span>(<span><span>&#34;</span>text<span>&#34;</span></span>);

<span>constexpr</span> parser <span>p</span>(
    text,
    <span>terms</span>(word),
    nterms(text),
    rules(
        <span>text</span>() &gt;= create&lt;text_t&gt;{},
        <span>text</span>(text, word) &gt;= [](<span>auto</span>&amp;&amp; txt, <span>const</span> <span>auto</span>&amp; w) { <span>return</span> <span>add_word</span>(<span>std::move</span>(txt), w.<span>get_value</span>(), w.<span>get_sp</span>()); }
    )
);

<span>int</span> <span>main</span>(<span>int</span> argc, <span>char</span>* argv[])
{
    <span>if</span> (argc &lt; <span>2</span>)
        <span>return</span> -<span>1</span>;
    <span>auto</span> res = p.<span>parse</span>(<span>string_buffer</span>(argv[<span>1</span>]), std::cout);
    <span>if</span> (res.<span>has_value</span>())
    {
        <span>for</span> (<span>const</span> <span>auto</span>&amp; w : res.<span>value</span>())
        {
            std::cout &lt;&lt; w.<span>w</span> &lt;&lt; <span><span>&#34;</span> at <span>&#34;</span></span> &lt;&lt; w.<span>sp</span> &lt;&lt; std::endl;
        }
    }
    <span>return</span> <span>0</span>;
}</pre></div>
<h3 dir="auto"><a id="user-content-buffers" aria-hidden="true" href="#buffers"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Buffers</h3>
<p dir="auto">There are currently two types of buffers available: <code>cstring_buffer</code>, useful for <em>constexpr</em> parsing static array like buffer, and <code>string_buffer</code> for runtime parsing.</p>
<p dir="auto">It is however easy to add custom types of buffers, there are just couple of requirements for the types to be eligible as buffers.</p>
<p dir="auto">The buffer needs to expose public <code>iterator</code> type which should be obtainable by <code>begin</code> and <code>end</code> methods and return iterators to the start and past the end of the buffer respectively.</p>
<p dir="auto">The <code>get_view</code> member should return a <code>std::string_view</code> given two iterators, one at the start of the view and the other past the end.</p>
<div data-snippet-clipboard-copy-content="iterator begin() const { return iterator{ data }; }
iterator end() const { return iterator{ data + N - 1 }; }
std::string_view get_view(iterator start, iterator end) const
"><pre>iterator <span>begin</span>() <span>const</span> { <span>return</span> iterator{ data }; }
iterator <span>end</span>() <span>const</span> { <span>return</span> iterator{ data + N - <span>1</span> }; }
std::string_view <span>get_view</span>(iterator start, iterator end) <span>const</span></pre></div>
<p dir="auto">The iterator type should expose following public member methods:</p>
<div data-snippet-clipboard-copy-content="char operator *() const;      // derefference to a pointed char
iterator&amp; operator ++();      // pre and post incrementation
iterator operator ++(int);
bool operator == (const iterator&amp; other) const;    // comparison operator
"><pre><span>char</span> <span>operator</span> *() <span>const</span>;      <span><span>//</span> derefference to a pointed char</span>
iterator&amp; <span>operator</span> ++();      <span><span>//</span> pre and post incrementation</span>
iterator <span>operator</span> ++(<span>int</span>);
<span>bool</span> <span>operator</span> == (<span>const</span> iterator&amp; other) <span>const</span>;    <span><span>//</span> comparison operator</span></pre></div>
<h3 dir="auto"><a id="user-content-typed-terms" aria-hidden="true" href="#typed-terms"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Typed terms</h3>
<p dir="auto">It is possible to define term value types as custom types, not limited to <code>char</code> or <code>std::string_view</code>.
It can be achieved using <code>typed_term</code> class template.</p>
<p dir="auto">Wrap the usual term definition:</p>

<p dir="auto">with <code>typed_term</code> like this:</p>
<div data-snippet-clipboard-copy-content="// a custom type for the plus term
struct plus_tag{};

typed_term plus(char_term(&#39;+&#39;), create&lt;plus_tag&gt;{});
"><pre><span><span>//</span> a custom type for the plus term</span>
<span>struct</span> <span>plus_tag</span>{};

typed_term <span>plus</span>(char_term(<span><span>&#39;</span>+<span>&#39;</span></span>), create&lt;plus_tag&gt;{});</pre></div>
<p dir="auto">The <code>create</code> is a functor available in the <code>ctpg::ftors</code> namespace, which simply creates an object of given type using a default constructor of that type.
In fact any callble object can be used instead of <code>create</code>, this is just an example.
The <code>plus</code> term has a value type identical to the return type of the functor, <code>plus_tag</code> in this case.</p>
<p dir="auto">Take a look at the <strong><code>typed_terms.cpp</code></strong> in the examples, it uses this feature to create a simple calculator, but instead of the
runtime switch statement on the char value like in the <strong><code>simple_expr_parser.cpp</code></strong>, the functor object has an overload for each arithmetic operator.</p>
<blockquote>
<p dir="auto">Note: Typed terms cannot use their implicit versions like the basic terms (<code>char_term</code>, <code>string_term</code>) in the rules. They have to be
referrenced by the typed_terms object.</p>
</blockquote>
<h3 dir="auto"><a id="user-content-error-recovery" aria-hidden="true" href="#error-recovery"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Error recovery</h3>
<p dir="auto">If a special <em><strong>error</strong></em> term in a rule is used, the parser tries to recover from syntax error.</p>
<p dir="auto">Consider the example from <strong>error_recovery.cpp</strong> example (here, simplified):</p>
<div data-snippet-clipboard-copy-content="constexpr parser p(
    exprs,
    terms(number, o_plus, &#39;;&#39;),
    nterms(exprs, expr),
    rules(
        exprs() &gt;= create&lt;exprs_type&gt;{},
        exprs(exprs, expr, &#39;;&#39;) &gt;= push_back&lt;1, 2&gt;{},
        exprs(exprs, error, &#39;;&#39;) &gt;= _e1,
        expr(expr, &#39;+&#39;, expr) &gt;= [](int x1, skip, int x2){ return x1 + x2; },
        expr(number) &gt;= [](const auto&amp; sv){ return get_int(sv); }
    )
);
"><pre><span>constexpr</span> parser <span>p</span>(
    exprs,
    <span>terms</span>(number, o_plus, <span><span>&#39;</span>;<span>&#39;</span></span>),
    nterms(exprs, expr),
    rules(
        <span>exprs</span>() &gt;= create&lt;exprs_type&gt;{},
        <span>exprs</span>(exprs, expr, <span><span>&#39;</span>;<span>&#39;</span></span>) &gt;= push_back&lt;1, 2&gt;{},
        <span>exprs</span>(exprs, error, <span><span>&#39;</span>;<span>&#39;</span></span>) &gt;= _e1,
        expr(expr, <span><span>&#39;</span>+<span>&#39;</span></span>, expr) &gt;= [](<span>int</span> x1, skip, <span>int</span> x2){ <span>return</span> x1 + x2; },
        <span>expr</span>(number) &gt;= [](<span>const</span> <span>auto</span>&amp; sv){ <span>return</span> <span>get_int</span>(sv); }
    )
);</pre></div>
<p dir="auto">This rule allows parser to recover from syntax error when the expression is ill formed, the <code>_e1</code> functor will simply pass expressions parsed to this point:</p>
<div data-snippet-clipboard-copy-content="exprs(exprs, error, &#39;;&#39;) &gt;= _e1,
"><pre><span>exprs</span>(exprs, error, <span><span>&#39;</span>;<span>&#39;</span></span>) &gt;= _e1,</pre></div>
<p dir="auto">Recovery follows the rules:</p>
<ul dir="auto">
<li>when syntax error occurs a special &lt;error_recovery_token&gt; is presented to the LR algorithm.</li>
<li>parser states are reverted (popped from a stack) until the state accepting the &lt;error_recovery_token&gt; is encountered.
<ul dir="auto">
<li>if at any point the is no more states to pop, algorithm fails.</li>
</ul>
</li>
<li>&lt;error_recovery_token&gt; is shifted, and shift action is performed.</li>
<li>terminals are consumed and ignored until the terminal which would not result in a syntax error is encountered.
<ul dir="auto">
<li>if at any point end of input is encountered, the algorithm fails.</li>
</ul>
</li>
</ul>
<p dir="auto">To see how <em><strong>error</strong></em> in rules affect the parse table generation take a look at the diagnostic output and look for the &lt;error_recovery_token&gt; occurrences.
See the <a href="#diagnostics">Diagnostics</a> section for details.</p>
<h2 dir="auto"><a id="user-content-regular-expressions" aria-hidden="true" href="#regular-expressions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Regular expressions</h2>
<p dir="auto">When defining a regex pattern for a regex term:</p>
<div data-snippet-clipboard-copy-content="constexpr char number_pattern[] = &#34;[1-9][0-9]*&#34;;
constexpr regex_term&lt;number_pattern&gt; number(&#34;number&#34;);
"><pre><span>constexpr</span> <span>char</span> number_pattern[] = <span><span>&#34;</span>[1-9][0-9]*<span>&#34;</span></span>;
<span>constexpr</span> regex_term&lt;number_pattern&gt; <span>number</span>(<span><span>&#34;</span>number<span>&#34;</span></span>);</pre></div>
<p dir="auto">use the following supported features (in precedence descending order):</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Example</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>Single char</td>
<td><code>a</code></td>
<td>character <code>a</code></td>
</tr>
<tr>
<td>Escaped char</td>
<td><code>\|</code></td>
<td>character ```</td>
</tr>
<tr>
<td>Escaped char (hex)</td>
<td><code>\\x20</code></td>
<td>space character</td>
</tr>
<tr>
<td>Any char</td>
<td><code>.</code></td>
<td>any character</td>
</tr>
<tr>
<td>Char range</td>
<td><code>[a-z]</code></td>
<td>lower case letter</td>
</tr>
<tr>
<td>Char set</td>
<td><code>[abc]</code></td>
<td><code>a</code>, <code>b</code>, or a <code>c</code> character</td>
</tr>
<tr>
<td>Inverted char range</td>
<td><code>[^a-z]</code></td>
<td>everything but lower case letter</td>
</tr>
<tr>
<td>Inverted char set</td>
<td><code>[^!]</code></td>
<td>everything but <code>!</code> character</td>
</tr>
<tr>
<td>Complex char set</td>
<td><code>[_a-zA-Z]</code></td>
<td>any letter or underscore character</td>
</tr>
<tr>
<td>Concatenation</td>
<td><code>ab</code></td>
<td>characters <code>a</code> and <code>b</code> in order</td>
</tr>
<tr>
<td>Repetition (zero or more)</td>
<td><code>a*</code></td>
<td>zero or more of <code>a</code> character</td>
</tr>
<tr>
<td>Repetition (one  or more)</td>
<td><code>a+</code></td>
<td>one or more of <code>a</code> character</td>
</tr>
<tr>
<td>Optional</td>
<td><code>a?</code></td>
<td>optional <code>a</code> character</td>
</tr>
<tr>
<td>Repetition (defined number)</td>
<td><code>a{4}</code></td>
<td>4 <code>a</code> characters</td>
</tr>
<tr>
<td>Alternative</td>
<td><code>a|b</code></td>
<td><code>a</code> character or <code>b</code> character</td>
</tr>
<tr>
<td>Grouping</td>
<td><code>(a|b)*</code></td>
<td>anu number of <code>a</code> or <code>b</code> characters</td>
</tr>
</tbody>
</table>
<h2 dir="auto"><a id="user-content-diagnostics" aria-hidden="true" href="#diagnostics"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Diagnostics</h2>
<p dir="auto">To diagnose broblems in the parser use the <code>write_diag_str</code> method which returns a string of output with the parser state machine details:</p>
<div data-snippet-clipboard-copy-content="p.write_diag_str(std::cerr)
"><pre>p.write_diag_str(std::cerr)</pre></div>
<p dir="auto">The output contains 2 sections: one for syntax analyzer starting with the word <strong>PARSER</strong> and the other for lexical analyzer starting with <strong>LEXICAL ANALYZER</strong>.</p>
<h3 dir="auto"><a id="user-content-parser-section" aria-hidden="true" href="#parser-section"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Parser section</h3>
<div data-snippet-clipboard-copy-content="Parser Object size: 51576
"><pre><code>Parser Object size: 51576
</code></pre></div>
<p dir="auto">First information in the secion is the size of the parser object. This may easily be couple of megabytes for some complex grammars, so consider declaring the parser as
a static object rather than on local stack.</p>
<p dir="auto">Next there is a state machine description in form of:</p>

<p dir="auto">followed by description of all possible situations in which the parser is when in this state.
Each of the situations refer to a single rule and are in form:</p>
<div data-snippet-clipboard-copy-content="nterm &lt;- s0 s1 s2 ... s(n) . s(n+1) ... s(rule_length) ==&gt; lookahead_term
"><pre><code>nterm &lt;- s0 s1 s2 ... s(n) . s(n+1) ... s(rule_length) ==&gt; lookahead_term
</code></pre></div>
<p dir="auto">The <em>nterm</em> is the name of the left side nonterm, <em>s0</em>, <em>s1</em> ... are right side symbols from the same rule.</p>
<p dir="auto">The <code>.</code> after the s(n) means the parser is done matching the part of the rule before the <code>.</code> (all the symbols before the <code>.</code>).</p>
<p dir="auto">The <em>lookahead_term</em> is the term expected after the whole rule is matched. If the parser encounters the lookahead term after the rule is matched, the <em>reduce</em> operation is performed.</p>
<p dir="auto">After the situations there is an action list (in order: goto actions, shift actions and reduce actions):</p>
<div data-snippet-clipboard-copy-content="On &lt;nterm&gt; goto &lt;state_nr&gt;
...
On &lt;term&gt; shift &lt;state_nr&gt;
...
On &lt;term&gt; reduce using (&lt;rule_nr&gt;)
...
"><pre><code>On &lt;nterm&gt; goto &lt;state_nr&gt;
...
On &lt;term&gt; shift &lt;state_nr&gt;
...
On &lt;term&gt; reduce using (&lt;rule_nr&gt;)
...
</code></pre></div>
<p dir="auto">Goto and shift actions are basically the same, only difference is goto action refers to a nonterm and shift to a term.</p>
<p dir="auto">They both refer to the <code>.</code> in the situation, that is, given the symbol after the <code>.</code> in this state, parser goes to a new state with a &lt;state_nr&gt;.</p>
<p dir="auto">Reduce actions occur when the whole rule is matched, hence the reduce actions are present only when the state contains a situation with <code>.</code> at the end.
What the action means is: given the  reduce using rule with a &lt;rule_nr&gt;.
Rules are numbered according to the apearance in the source code (in the <code>rules</code> call during the parser definition) starting from 0.</p>
<h3 dir="auto"><a id="user-content-conflicts-1" aria-hidden="true" href="#conflicts-1"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Conflicts</h3>
<p dir="auto">Shift/reduce conflicts are presented with lines:</p>
<div data-snippet-clipboard-copy-content="On &lt;term&gt; shift to &lt;state_nr&gt; S/R CONFLICT, prefer reduce(&lt;rule_nr&gt;) over shift
On &lt;term&gt; shift to &lt;state_nr&gt; S/R CONFLICT, prefer shift over reduce(&lt;rule_nr&gt;)
"><pre><code>On &lt;term&gt; shift to &lt;state_nr&gt; S/R CONFLICT, prefer reduce(&lt;rule_nr&gt;) over shift
On &lt;term&gt; shift to &lt;state_nr&gt; S/R CONFLICT, prefer shift over reduce(&lt;rule_nr&gt;)
</code></pre></div>
<p dir="auto">Reduce/reduce conflicts look like this:</p>
<div data-snippet-clipboard-copy-content="On &lt;term&gt; R/R CONFLICT - !!! FIX IT !!!
"><pre><code>On &lt;term&gt; R/R CONFLICT - !!! FIX IT !!!
</code></pre></div>
<h3 dir="auto"><a id="user-content-lexical-analyzer-section" aria-hidden="true" href="#lexical-analyzer-section"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Lexical analyzer section</h3>
<p dir="auto">Section contains deterministic finite automaton which corresponds to all of the terms used in a grammar.</p>
<p dir="auto">Each line represents a single machine state:</p>
<div data-snippet-clipboard-copy-content="STATE &lt;nr&gt; [recognized &lt;term&gt;] {&lt;char_descr&gt; -&gt; &lt;new_state&gt;} {&lt;char_descr&gt; -&gt; &lt;new_state&gt;}...
"><pre><code>STATE &lt;nr&gt; [recognized &lt;term&gt;] {&lt;char_descr&gt; -&gt; &lt;new_state&gt;} {&lt;char_descr&gt; -&gt; &lt;new_state&gt;}...
</code></pre></div>
<p dir="auto">The <code>[recognized &lt;term&gt;]</code> part is optional and means that the DFA in this state could return the recognized term, however it is trying to match longest possible input
so it continues consuming characters. When it reaches an error state (no new state for the character) the last recognized term is returned, or an &#39;unexpected character&#39; error occurs if no term recognized so far.</p>
<p dir="auto">The <code>&lt;char_descr&gt; -&gt; &lt;new_state&gt;</code> represents the DFA transition on a character described by character description &lt;char_descr&gt;.
Character descriptions are in form of a single printable character, or in case of non-printable it&#39;s hex representation like : 0x20 for space character.
Character descriptions can also contain character range in form: <code>[start-end]</code>.</p>
<p dir="auto">There will be unreachable states in the form:</p>

<p dir="auto">These are leftovers from the regular expression to DFA conversion, just ignore them.</p>
</article>
        </div></div>
  </body>
</html>
