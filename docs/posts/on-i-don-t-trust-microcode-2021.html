<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://patrick.georgi.family/2021/02/13/on-microcode/">Original</a>
    <h1>On “I don&#39;t trust microcode” (2021)</h1>
    
    <div id="readability-page-1" class="page"><div><p>There has been one too many <a href="https://www.reddit.com/r/coreboot/comments/liwe82/is_libreboot_worth_installing_on_a_t400_thinkpad/gn896qa">case</a> of „I don’t trust microcode, so I don’t want microcode blobs in coreboot“, so I felt the need for an answer. And since I don’t like stuff to end up in silos, here’s a copy.</p>
<h2 id="microcode-vs-microcode-updates">Microcode vs. microcode updates</h2>
<p>Let’s get this out of the door first: The blobs that ship with coreboot, Linux, Windows, macOS etc aren’t <em>microcode</em> but <em>microcode updates</em>. The CPU comes with microcode, so if you don’t want microcode, choose a different vendor (good luck).</p>
<p>The updates provide a way for the vendor to run a newer version of parts of the microcode on the CPU. Note that these updates aren’t persistent: They need to be installed after power-on or you’re back to the original state.</p>
<p>This article will next discuss what microcode is, why there are updates, and what you miss out on if you don’t install them.</p>
<h2 id="what-is-microcode">What is microcode</h2>
<p>CPUs have internal components for all kinds of operations that they support. But some parts of the (x86, but also most others) architecture are too complex to represent them directly as a distinct component.</p>
<p>For these complex parts, microcode is used (starting in the 60s or 70s, a _real_ long time ago! Home computers were a bit late but they always are): Small program snippets that represent a single instruction of the architecture as a whole bunch of instructions for the components that exist.</p>
<p>A bit like „if the instruction says to exponentiate a to the power of b, multiply a by itself b times“ (although CPUs generally don’t have exponentiation, that would be a great example for a microcoded instruction: some complex operation can be solved by repeating simpler operations several times)</p>
<p>Now, Intel (and the others) build both the internal components and everything that brings them together, some of them as real components, some of them microcoded.</p>
<h2 id="product-cycles-and-some-history">Product cycles and some history</h2>
<p>Like with all products, there isn’t perfection: the product is developed, there’s a quality bar that needs to be met, a time limit by which the product should be ready, and a budget that informs how many people can work on it. As soon as the chip is „good enough“, it can be produced.</p>
<p>Now, Intel had some really bad accidents with that strategy, the most famous and expensive being the <a href="https://en.wikipedia.org/wiki/Pentium_FDIV_bug" rel="noopener nofollow ugc">fdiv</a> bug: certain division operations miscalculated for certain values. Depending on who you ask, that one could have had the ability to take down Intel for good if they had to ship a replacement CPU to every customer (they didn’t).</p>
<p>With that experience, these days they provide some room in the CPU by which they can put on band-aids on certain parts of the operation. The details aren’t well-known, but some educated guesses would be that they can update microcode programs for existing instructions (for example, if the exponentiation example above forgot to account for a^0 == 1, they could provide an update that takes care of that); and that they might put multiple variants of a basic component in a chip and allow the update to disable the new (and experimental) version if it is less reliable than intended, using an older (and probably slower) version instead.</p>
<h2 id="the-impact">The impact</h2>
<p>When you don’t install updates you mostly forgo whatever development happened on the CPU after some cut-off point in time that was chosen more-or-less arbitrarily by its product manager to get the product out of the door.</p>
<p>Since that’s when the majority of developers move on to the next project, these updates will likely fix significant issues: significant enough that somebody was assigned to look into an old product instead of working on the Next Big Thing. Something that might have an impact like „we run out of money if customers can sue us over this“, something like failures in the CPU’s security architecture (I don’t expect there to be math problems anymore)</p>
<p>For all we people outside Intel know (and we don’t, really), any unpatched CPU for which there are updates has grave security issues that are trivially exploited. For all we know, there might be bad actors who know the issues in detail. Intel provides updates and even ensures that „typical“ platforms (e.g. Windows, macOS, popular Linux distros) install them, so they’re not liable anymore (like with the fdiv thing).</p>
</div></div>
  </body>
</html>
