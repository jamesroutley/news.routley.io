<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://timothya.com/blog/dns/">Original</a>
    <h1>Building a Recursive DNS Resolver</h1>
    
    <div id="readability-page-1" class="page"><div id="main">
      <main aria-role="main">
      
        <header>
          




        </header>
       
      
  
    

  

  
    <h2>
      Friday, 29
      <span>
        July
        2022
      </span>
    </h2>
  

  <p>Recently I’ve been thinking about how DNS really works under the hood. You ask a resolver for an IP, but how does the resolver know what IP maps to a domain? I figured the best way to learn was to build a resolver myself, and it turned out to be fairly simple and instructive.</p>
<p>But first, some background!</p>
<h2 id="the-domain-name-system">The Domain Name System</h2>
<p>The domain name system (or <strong>DNS</strong>) underpins the internet, converting the domain names you’d typically use to connect to a website, to IP addresses for the servers those websites are hosted on. Conceptually you can think of the entire domain name system as a distributed key-value store mapping domains (and sub-domains) to IP addresses:</p>
<table>
<thead>
<tr>
<th>Domain</th>
<th>IP Address</th>
</tr>
</thead>
<tbody>
<tr>
<td>news.ycombinator.com</td>
<td>50.112.136.166</td>
</tr>
<tr>
<td>wikipedia.org</td>
<td>91.198.174.192</td>
</tr>
<tr>
<td>en.wikipedia.org</td>
<td>91.198.174.192</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>When you type something like “google.com” into your browser and hit enter, your device must query a known <em>recursive resolver</em> to find <em>google.com</em>’s IP address. Recursive resolvers are provided by most ISPs, but resolvers like <a href="https://1.1.1.1/">1.1.1.1</a> or <a href="https://developers.google.com/speed/public-dns">8.8.8.8</a> exist as well.</p>
<p>You can query a resolver manually using something like <a href="https://linux.die.net/man/1/dig">dig</a> or <a href="https://github.com/ogham/dog">dog</a>:</p>
<div><pre tabindex="0"><code data-lang="bash">❯ dig @1.1.1.1 news.ycombinator.com

<span>;</span> &lt;&lt;&gt;&gt; DiG 9.18.4-2-Debian &lt;&lt;&gt;&gt; @1.1.1.1 news.ycombinator.com
<span>;</span> <span>(</span><span>1</span> server found<span>)</span>
<span>;;</span> global options: +cmd
<span>;;</span> Got answer:
<span>;;</span> -&gt;&gt;HEADER<span>&lt;&lt;- opco</span>de: QUERY, status: NOERROR, id: <span>9149</span>
<span>;;</span> flags: qr rd ra<span>;</span> QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: <span>1</span>

<span>;;</span> OPT PSEUDOSECTION:
<span>;</span> EDNS: version: 0, flags:<span>;</span> udp: <span>1232</span>
<span>;;</span> QUESTION SECTION:
<span>;</span>news.ycombinator.com.		IN	A

<span>;;</span> ANSWER SECTION:
news.ycombinator.com.	0	IN	A	50.112.136.166

<span>;;</span> Query time: <span>24</span> msec
<span>;;</span> SERVER: 1.1.1.1#53<span>(</span>1.1.1.1<span>)</span> <span>(</span>UDP<span>)</span>
<span>;;</span> WHEN: Thu Jul <span>28</span> 01:31:59 EDT <span>2022</span>
<span>;;</span> MSG SIZE  rcvd: <span>65</span>
</code></pre></div><p>The <code>ANSWER SECTION</code> contains an IP address for the domain we requested. How does this work? How does a recursive resolver know what IP a domain uses?</p>
<p>The short answer is that resolvers aren’t in charge of the domain-&gt;IP mapping at all. Resolvers are simply a querying interface to DNS&#39; distributed database, which is stored on <em>nameservers</em>. If you think of the entire DNS namespace as a tree, each nameserver is an <em>authority</em> for a given subtree, and each such subtree is called a <em>zone</em>.</p>
<p><a href="https://timothya.com/blog/dns/tree.png">

  <img src="https://timothya.com/blog/dns/tree.png"/>
</a></p>
<p>Any given domain has a single unique path through this tree, starting at any node and walking up to the root. Here’s <code>news.ycombinator.com</code>, for example:</p>
<p><a href="https://timothya.com/blog/dns/hn.png">

  <img src="https://timothya.com/blog/dns/hn.png"/>
</a></p>
<p>Note that the root node is denoted by a <code>.</code>, so the <em>fully-qualified</em> version (or <a href="https://en.wikipedia.org/wiki/Fully_qualified_domain_name">FQDN</a>) of a domain name ends with a <code>.</code> – the FQDN for “news.ycombinator.com” is actually <code>news.ycombinator.com.</code></p>
<p>Recursive resolvers must also walk this tree to resolve a given domain, but starting at the root node. 13 root nameservers exist (which have authority over the root zone <code>.</code>), and have <a href="https://www.iana.org/domains/root/servers">well-known IPs</a>:</p>
<table>
<thead>
<tr>
<th>Root Server</th>
<th>IP</th>
</tr>
</thead>
<tbody>
<tr>
<td>a.root-servers.net</td>
<td>198.41.0.4</td>
</tr>
<tr>
<td>b.root-servers.net</td>
<td>199.9.14.201</td>
</tr>
<tr>
<td>c.root-servers.net</td>
<td>192.33.4.12</td>
</tr>
<tr>
<td>d.root-servers.net</td>
<td>199.7.91.13</td>
</tr>
<tr>
<td>e.root-servers.net</td>
<td>192.203.230.10</td>
</tr>
<tr>
<td>f.root-servers.net</td>
<td>192.5.5.241</td>
</tr>
<tr>
<td>g.root-servers.net</td>
<td>192.112.36.4</td>
</tr>
<tr>
<td>h.root-servers.net</td>
<td>198.97.190.53</td>
</tr>
<tr>
<td>i.root-servers.net</td>
<td>192.36.148.17</td>
</tr>
<tr>
<td>j.root-servers.net</td>
<td>192.58.128.30</td>
</tr>
<tr>
<td>k.root-servers.net</td>
<td>193.0.14.129</td>
</tr>
<tr>
<td>l.root-servers.net</td>
<td>199.7.83.42</td>
</tr>
<tr>
<td>m.root-servers.net</td>
<td>202.12.27.33</td>
</tr>
</tbody>
</table>
<h2 id="recursive-resolution-by-hand">Recursive Resolution By Hand</h2>
<p>Let’s see if we can resolve <code>news.ycombinator.com</code> by walking this tree manually, starting at one of these root servers:</p>
<div><pre tabindex="0"><code data-lang="bash">❯ dig @192.36.148.17 news.ycombinator.com

<span>;</span> &lt;&lt;&gt;&gt; DiG 9.18.4-2-Debian &lt;&lt;&gt;&gt; @192.36.148.17 news.ycombinator.com
<span>;</span> <span>(</span><span>1</span> server found<span>)</span>
<span>;;</span> global options: +cmd
<span>;;</span> Got answer:
<span>;;</span> -&gt;&gt;HEADER<span>&lt;&lt;- opco</span>de: QUERY, status: NOERROR, id: <span>57339</span>
<span>;;</span> flags: qr rd<span>;</span> QUERY: 1, ANSWER: 0, AUTHORITY: 13, ADDITIONAL: <span>27</span>
<span>;;</span> WARNING: recursion requested but not available

<span>;;</span> OPT PSEUDOSECTION:
<span>;</span> EDNS: version: 0, flags:<span>;</span> udp: <span>1232</span>
<span>;</span> COOKIE: a4d4b6701afda21d0100000062e3db51b71dabe7bfe43d28 <span>(</span>good<span>)</span>
<span>;;</span> QUESTION SECTION:
<span>;</span>news.ycombinator.com.		IN	A

<span>;;</span> AUTHORITY SECTION:
com.			172800	IN	NS	f.gtld-servers.net.
com.			172800	IN	NS	g.gtld-servers.net.
com.			172800	IN	NS	e.gtld-servers.net.
com.			172800	IN	NS	k.gtld-servers.net.
com.			172800	IN	NS	j.gtld-servers.net.
com.			172800	IN	NS	b.gtld-servers.net.
com.			172800	IN	NS	a.gtld-servers.net.
com.			172800	IN	NS	m.gtld-servers.net.
com.			172800	IN	NS	d.gtld-servers.net.
com.			172800	IN	NS	i.gtld-servers.net.
com.			172800	IN	NS	h.gtld-servers.net.
com.			172800	IN	NS	c.gtld-servers.net.
com.			172800	IN	NS	l.gtld-servers.net.

<span>;;</span> ADDITIONAL SECTION:
m.gtld-servers.net.	172800	IN	A	192.55.83.30
l.gtld-servers.net.	172800	IN	A	192.41.162.30
k.gtld-servers.net.	172800	IN	A	192.52.178.30
j.gtld-servers.net.	172800	IN	A	192.48.79.30
i.gtld-servers.net.	172800	IN	A	192.43.172.30
h.gtld-servers.net.	172800	IN	A	192.54.112.30
g.gtld-servers.net.	172800	IN	A	192.42.93.30
f.gtld-servers.net.	172800	IN	A	192.35.51.30
e.gtld-servers.net.	172800	IN	A	192.12.94.30
d.gtld-servers.net.	172800	IN	A	192.31.80.30
c.gtld-servers.net.	172800	IN	A	192.26.92.30
b.gtld-servers.net.	172800	IN	A	192.33.14.30
a.gtld-servers.net.	172800	IN	A	192.5.6.30
m.gtld-servers.net.	172800	IN	AAAA	2001:501:b1f9::30
l.gtld-servers.net.	172800	IN	AAAA	2001:500:d937::30
k.gtld-servers.net.	172800	IN	AAAA	2001:503:d2d::30
j.gtld-servers.net.	172800	IN	AAAA	2001:502:7094::30
i.gtld-servers.net.	172800	IN	AAAA	2001:503:39c1::30
h.gtld-servers.net.	172800	IN	AAAA	2001:502:8cc::30
g.gtld-servers.net.	172800	IN	AAAA	2001:503:eea3::30
f.gtld-servers.net.	172800	IN	AAAA	2001:503:d414::30
e.gtld-servers.net.	172800	IN	AAAA	2001:502:1ca1::30
d.gtld-servers.net.	172800	IN	AAAA	2001:500:856e::30
c.gtld-servers.net.	172800	IN	AAAA	2001:503:83eb::30
b.gtld-servers.net.	172800	IN	AAAA	2001:503:231d::2:30
a.gtld-servers.net.	172800	IN	AAAA	2001:503:a83e::2:30

<span>;;</span> Query time: <span>28</span> msec
<span>;;</span> SERVER: 192.36.148.17#53<span>(</span>192.36.148.17<span>)</span> <span>(</span>UDP<span>)</span>
<span>;;</span> WHEN: Thu Jul <span>28</span> 02:22:47 EDT <span>2022</span>
<span>;;</span> MSG SIZE  rcvd: <span>876</span>
</code></pre></div><p>The root nameserver has <em>not</em> provided us with an answer (no <code>ANSWER SECTION</code>). We’re provided instead with the names and IPs of the nameservers in charge of the <code>com.</code> zone. Let’s see if one of these nameservers knows the IP for <code>news.ycombinator.com</code>:</p>
<div><pre tabindex="0"><code data-lang="bash">❯ dig @192.41.162.30 news.ycombinator.com

<span>;</span> &lt;&lt;&gt;&gt; DiG 9.18.4-2-Debian &lt;&lt;&gt;&gt; @192.41.162.30 news.ycombinator.com
<span>;</span> <span>(</span><span>1</span> server found<span>)</span>
<span>;;</span> global options: +cmd
<span>;;</span> Got answer:
<span>;;</span> -&gt;&gt;HEADER<span>&lt;&lt;- opco</span>de: QUERY, status: NOERROR, id: <span>52169</span>
<span>;;</span> flags: qr rd<span>;</span> QUERY: 1, ANSWER: 0, AUTHORITY: 4, ADDITIONAL: <span>2</span>
<span>;;</span> WARNING: recursion requested but not available

<span>;;</span> OPT PSEUDOSECTION:
<span>;</span> EDNS: version: 0, flags:<span>;</span> udp: <span>4096</span>
<span>;;</span> QUESTION SECTION:
<span>;</span>news.ycombinator.com.		IN	A

<span>;;</span> AUTHORITY SECTION:
ycombinator.com.	172800	IN	NS	ns-225.awsdns-28.com.
ycombinator.com.	172800	IN	NS	ns-556.awsdns-05.net.
ycombinator.com.	172800	IN	NS	ns-1914.awsdns-47.co.uk.
ycombinator.com.	172800	IN	NS	ns-1411.awsdns-48.org.

<span>;;</span> ADDITIONAL SECTION:
ns-225.awsdns-28.com.	172800	IN	A	205.251.192.225

<span>;;</span> Query time: <span>32</span> msec
<span>;;</span> SERVER: 192.41.162.30#53<span>(</span>192.41.162.30<span>)</span> <span>(</span>UDP<span>)</span>
<span>;;</span> WHEN: Thu Jul <span>28</span> 02:23:25 EDT <span>2022</span>
<span>;;</span> MSG SIZE  rcvd: <span>202</span>

</code></pre></div><p>Still no <code>ANSWER SECTION</code>, but we’re getting closer! An authoritative nameserver for the zone <code>com.</code> has given us the names and IPs of nameservers that have authority over the <code>ycombinator.com.</code> zone. Let’s recurse one level deeper:</p>
<div><pre tabindex="0"><code data-lang="bash">❯ dig @205.251.192.225 news.ycombinator.com

<span>;</span> &lt;&lt;&gt;&gt; DiG 9.18.4-2-Debian &lt;&lt;&gt;&gt; @205.251.192.225 news.ycombinator.com
<span>;</span> <span>(</span><span>1</span> server found<span>)</span>
<span>;;</span> global options: +cmd
<span>;;</span> Got answer:
<span>;;</span> -&gt;&gt;HEADER<span>&lt;&lt;- opco</span>de: QUERY, status: NOERROR, id: <span>17560</span>
<span>;;</span> flags: qr aa rd<span>;</span> QUERY: 1, ANSWER: 1, AUTHORITY: 4, ADDITIONAL: <span>1</span>
<span>;;</span> WARNING: recursion requested but not available

<span>;;</span> OPT PSEUDOSECTION:
<span>;</span> EDNS: version: 0, flags:<span>;</span> udp: <span>4096</span>
<span>;;</span> QUESTION SECTION:
<span>;</span>news.ycombinator.com.		IN	A

<span>;;</span> ANSWER SECTION:
news.ycombinator.com.	1	IN	A	50.112.136.166

<span>;;</span> AUTHORITY SECTION:
ycombinator.com.	172800	IN	NS	ns-1411.awsdns-48.org.
ycombinator.com.	172800	IN	NS	ns-1914.awsdns-47.co.uk.
ycombinator.com.	172800	IN	NS	ns-225.awsdns-28.com.
ycombinator.com.	172800	IN	NS	ns-556.awsdns-05.net.

<span>;;</span> Query time: <span>56</span> msec
<span>;;</span> SERVER: 205.251.192.225#53<span>(</span>205.251.192.225<span>)</span> <span>(</span>UDP<span>)</span>
<span>;;</span> WHEN: Thu Jul <span>28</span> 02:24:33 EDT <span>2022</span>
<span>;;</span> MSG SIZE  rcvd: <span>202</span>
</code></pre></div><p>We now finally have an <code>ANSWER SECTION</code>, which tells us that <code>50.112.136.166</code> is the IP address for <code>news.ycombinator.com.</code>. Let’s compare by asking a known recursive resolver:</p>
<div><pre tabindex="0"><code data-lang="bash">❯ dig +short @1.1.1.1 news.ycombinator.com
50.112.136.166
</code></pre></div><p>Here’s an illustration of what we just did:</p>
<p><a href="https://timothya.com/blog/dns/recursive.png">

  <img src="https://timothya.com/blog/dns/recursive.png"/>
</a></p>
<p>Assuming no prior caching, we only know the IPs of the root servers, so we start from there and recurse downwards until we get to a nameserver that’s an authority for the zone the target domain is in.</p>
<h2 id="writing-a-recursive-resolver">Writing a Recursive Resolver</h2>
<p>At its core, a recursive resolver does what we just did by hand: start at a root nameserver, and recurse downward until it receives an answer.</p>
<p>The best way to understand this properly is to actually build a simple recursive resolver; let’s do that using Go. We’ll use <a href="https://github.com/miekg/dns">the <code>dns</code> library</a> to serialize to/from the DNS wire format so we can focus on the actual recursive operation of the resolver.</p>
<p>To start, query a root nameserver, look in the response&#39; <code>ADDITIONAL SECTION</code> for the IP addresses of the nameservers one level lower in the tree, and repeat until we receive an <code>ANSWER SECTION</code>:</p>
<div><pre tabindex="0"><code data-lang="go"><span>func</span> <span>resolve</span><span>(</span><span>name</span> <span>string</span><span>)</span> <span>([]</span><span>dns</span><span>.</span><span>RR</span><span>,</span> <span>error</span><span>)</span> <span>{</span>
  <span>nameserver</span> <span>:=</span> <span>&#34;198.41.0.4&#34;</span>
  <span>c</span> <span>:=</span> <span>new</span><span>(</span><span>dns</span><span>.</span><span>Client</span><span>)</span>

  <span>for</span> <span>{</span>
    <span>// Prepare a message asking for an A record (an IP address) for `name`
</span><span></span>    <span>m</span> <span>:=</span> <span>new</span><span>(</span><span>dns</span><span>.</span><span>Msg</span><span>)</span>
    <span>m</span><span>.</span><span>SetQuestion</span><span>(</span><span>dns</span><span>.</span><span>Fqdn</span><span>(</span><span>name</span><span>),</span> <span>dns</span><span>.</span><span>TypeA</span><span>)</span>

    <span>// Send the DNS request to the IP in `nameserver`
</span><span></span>    <span>fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;Asking %s about %s\n&#34;</span><span>,</span> <span>nameserver</span><span>,</span> <span>name</span><span>)</span>
    <span>resp</span><span>,</span> <span>_</span><span>,</span> <span>err</span> <span>:=</span> <span>c</span><span>.</span><span>Exchange</span><span>(</span><span>m</span><span>,</span> <span>fmt</span><span>.</span><span>Sprintf</span><span>(</span><span>&#34;%s:53&#34;</span><span>,</span> <span>nameserver</span><span>))</span>
    <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
      <span>return</span> <span>nil</span><span>,</span> <span>err</span>
    <span>}</span>

    <span>// If an ANSWER SECTION exists, we&#39;re done
</span><span></span>    <span>if</span> <span>len</span><span>(</span><span>resp</span><span>.</span><span>Answer</span><span>)</span> <span>&gt;</span> <span>0</span> <span>{</span>
      <span>return</span> <span>resp</span><span>.</span><span>Answer</span><span>,</span> <span>nil</span>
    <span>}</span>

    <span>// If an ADDITIONAL SECTION exists, look in it for an A record for the
</span><span></span>    <span>// next-level nameserver. If one doesn&#39;t exist, we have to error out
</span><span></span>    <span>found</span> <span>:=</span> <span>false</span>
    <span>for</span> <span>_</span><span>,</span> <span>rr</span> <span>:=</span> <span>range</span> <span>resp</span><span>.</span><span>Extra</span> <span>{</span>
      <span>record</span><span>,</span> <span>ok</span> <span>:=</span> <span>rr</span><span>.(</span><span>*</span><span>dns</span><span>.</span><span>A</span><span>)</span>
      <span>if</span> <span>ok</span> <span>{</span>
        <span>nameserver</span> <span>=</span> <span>record</span><span>.</span><span>A</span><span>.</span><span>String</span><span>()</span>
        <span>found</span> <span>=</span> <span>true</span>
        <span>break</span>
      <span>}</span>
    <span>}</span>
    <span>if</span> <span>!</span><span>found</span> <span>{</span>
      <span>return</span> <span>nil</span><span>,</span> <span>fmt</span><span>.</span><span>Errorf</span><span>(</span><span>&#34;break in the chain&#34;</span><span>)</span>
    <span>}</span>

    <span>// ... and recurse!
</span><span></span>  <span>}</span>
<span>}</span>
</code></pre></div><p>And that’s pretty much it! There are some cases this doesn’t handle (which we’ll cover below), but this is all you need to recursively resolve basic DNS requests. Let’s wire this up by accepting CLI arguments:</p>
<div><pre tabindex="0"><code data-lang="go"><span>func</span> <span>main</span><span>()</span> <span>{</span>
  <span>if</span> <span>len</span><span>(</span><span>os</span><span>.</span><span>Args</span><span>)</span> <span>!=</span> <span>2</span> <span>{</span>
    <span>fmt</span><span>.</span><span>Fprintf</span><span>(</span><span>os</span><span>.</span><span>Stderr</span><span>,</span> <span>&#34;usage: dns &lt;name&gt;\n&#34;</span><span>)</span>
    <span>os</span><span>.</span><span>Exit</span><span>(</span><span>1</span><span>)</span>
  <span>}</span>

  <span>name</span> <span>:=</span> <span>os</span><span>.</span><span>Args</span><span>[</span><span>1</span><span>]</span>
  <span>answer</span><span>,</span> <span>err</span> <span>:=</span> <span>resolve</span><span>(</span><span>name</span><span>)</span>
  <span>if</span> <span>err</span> <span>==</span> <span>nil</span> <span>{</span>
    <span>for</span> <span>_</span><span>,</span> <span>record</span> <span>:=</span> <span>range</span> <span>answer</span> <span>{</span>
      <span>fmt</span><span>.</span><span>Println</span><span>(</span><span>record</span><span>)</span>
    <span>}</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>fmt</span><span>.</span><span>Fprintf</span><span>(</span><span>os</span><span>.</span><span>Stderr</span><span>,</span> <span>&#34;Failed to resolve %s\n&#34;</span><span>,</span> <span>name</span><span>)</span>
    <span>os</span><span>.</span><span>Exit</span><span>(</span><span>1</span><span>)</span>
  <span>}</span>
<span>}</span>

</code></pre></div><p>And give it a shot:</p>
<div><pre tabindex="0"><code data-lang="bash">❯ go run dns.go news.ycombinator.com
Asking 198.41.0.4 about news.ycombinator.com
Asking 192.12.94.30 about news.ycombinator.com
Asking 205.251.192.225 about news.ycombinator.com
news.ycombinator.com.	1	IN	A	50.112.136.166
</code></pre></div><p>It works! The resolver found the IP address for <code>news.ycombinator.com</code> with no prior knowledge except the addresses of the root nameservers. Let’s address a couple of edge cases next.</p>
<h2 id="additional-sections-and-cnames">Additional Sections and CNAMEs</h2>
<p>In the example above, each nameserver in the chain provided the IP addresses (A records) of all the nameservers in the next level of the tree. This isn’t always the case, though:</p>
<div><pre tabindex="0"><code data-lang="bash">❯ go run dns.go twitter.com
Asking 198.41.0.4 about twitter.com
Asking 192.12.94.30 about twitter.com
Failed to resolve twitter.com
<span>exit</span> status <span>1</span>
</code></pre></div><p>Running the final query manually:</p>
<div><pre tabindex="0"><code data-lang="bash">❯ dig @192.12.94.30 twitter.com

<span>;</span> &lt;&lt;&gt;&gt; DiG 9.18.4-2-Debian &lt;&lt;&gt;&gt; @192.12.94.30 twitter.com
<span>;</span> <span>(</span><span>1</span> server found<span>)</span>
<span>;;</span> global options: +cmd
<span>;;</span> Got answer:
<span>;;</span> -&gt;&gt;HEADER<span>&lt;&lt;- opco</span>de: QUERY, status: NOERROR, id: <span>27129</span>
<span>;;</span> flags: qr rd<span>;</span> QUERY: 1, ANSWER: 0, AUTHORITY: 8, ADDITIONAL: <span>1</span>
<span>;;</span> WARNING: recursion requested but not available

<span>;;</span> OPT PSEUDOSECTION:
<span>;</span> EDNS: version: 0, flags:<span>;</span> udp: <span>4096</span>
<span>;;</span> QUESTION SECTION:
<span>;</span>twitter.com.			IN	A

<span>;;</span> AUTHORITY SECTION:
twitter.com.		172800	IN	NS	ns3.p34.dynect.net.
twitter.com.		172800	IN	NS	ns4.p34.dynect.net.
twitter.com.		172800	IN	NS	d01-01.ns.twtrdns.net.
twitter.com.		172800	IN	NS	d01-02.ns.twtrdns.net.
twitter.com.		172800	IN	NS	a.r06.twtrdns.net.
twitter.com.		172800	IN	NS	b.r06.twtrdns.net.
twitter.com.		172800	IN	NS	c.r06.twtrdns.net.
twitter.com.		172800	IN	NS	d.r06.twtrdns.net.

<span>;;</span> Query time: <span>104</span> msec
<span>;;</span> SERVER: 192.12.94.30#53<span>(</span>192.12.94.30<span>)</span> <span>(</span>UDP<span>)</span>
<span>;;</span> WHEN: Thu Jul <span>28</span> 02:57:55 EDT <span>2022</span>
<span>;;</span> MSG SIZE  rcvd: <span>211</span>
</code></pre></div><p>This nameserver sent us a list of nameservers that are authoritative for <code>twitter.com.</code>, but didn’t include their IP addresses in an <code>ADDITIONAL SECTION</code>.</p>
<p>What do we do? Luckily, we just built a system to convert domain names to IP addresses! We can resolve one of these names to an IP address and use that as the next-level nameserver:</p>
<div><pre tabindex="0"><code data-lang="go"><span>// If the ADDITIONAL SECTION is empty and the AUTHORITY SECTION is not, resolve
</span><span>// one of the names in the AUTHORITY SECTION and have that be the nameserver
</span><span></span><span>if</span> <span>len</span><span>(</span><span>resp</span><span>.</span><span>Extra</span><span>)</span> <span>==</span> <span>0</span> <span>&amp;&amp;</span> <span>len</span><span>(</span><span>resp</span><span>.</span><span>Ns</span><span>)</span> <span>!=</span> <span>0</span> <span>{</span>
  <span>ns</span> <span>:=</span> <span>resp</span><span>.</span><span>Ns</span><span>[</span><span>0</span><span>].(</span><span>*</span><span>dns</span><span>.</span><span>NS</span><span>)</span>
  <span>nsIP</span><span>,</span> <span>err</span> <span>:=</span> <span>resolve</span><span>(</span><span>ns</span><span>.</span><span>Ns</span><span>)</span>
  <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
    <span>return</span> <span>nil</span><span>,</span> <span>fmt</span><span>.</span><span>Errorf</span><span>(</span><span>&#34;break in the chain&#34;</span><span>)</span>
  <span>}</span>
  <span>nameserver</span> <span>=</span> <span>nsIP</span><span>[</span><span>0</span><span>].(</span><span>*</span><span>dns</span><span>.</span><span>A</span><span>).</span><span>A</span><span>.</span><span>String</span><span>()</span>
<span>}</span>
</code></pre></div><p>Trying it out:</p>
<div><pre tabindex="0"><code data-lang="bash">❯ go run dns.go twitter.com
Asking 198.41.0.4 about twitter.com
Asking 192.12.94.30 about twitter.com
Asking 198.41.0.4 about ns3.p34.dynect.net.
Asking 192.12.94.30 about ns3.p34.dynect.net.
Asking 108.59.161.136 about ns3.p34.dynect.net.
Asking 108.59.163.34 about twitter.com
twitter.com.	1800	IN	A	104.244.42.129
twitter.com.	1800	IN	A	104.244.42.65
</code></pre></div><p>So far so good. But what about <code>CNAME</code>s? These DNS records allow aliasing one name to another name. Here <code>pages.github.com</code> is an alias for <code>github.github.io</code>:</p>
<div><pre tabindex="0"><code data-lang="bash">❯ go run dns.go pages.github.com
Asking 198.41.0.4 about pages.github.com
Asking 192.12.94.30 about pages.github.com
Asking 205.251.193.165 about pages.github.com
pages.github.com.	3600	IN	CNAME	github.github.io.
</code></pre></div><p>A recursive resolver should resolve the <code>CNAME</code> and provide <em>its</em> IP addresses, so let’s implement that:</p>
<div><pre tabindex="0"><code data-lang="go"><span>if</span> <span>len</span><span>(</span><span>resp</span><span>.</span><span>Answer</span><span>)</span> <span>&gt;</span> <span>0</span> <span>{</span>
  <span>// If an ANSWER SECTION exists and contains a CNAME, recurse
</span><span></span>  <span>if</span> <span>cname</span><span>,</span> <span>ok</span> <span>:=</span> <span>resp</span><span>.</span><span>Answer</span><span>[</span><span>0</span><span>].(</span><span>*</span><span>dns</span><span>.</span><span>CNAME</span><span>);</span> <span>ok</span> <span>{</span>
    <span>return</span> <span>resolve</span><span>(</span><span>cname</span><span>.</span><span>Target</span><span>)</span>
  <span>}</span>

  <span>// If an ANSWER SECTION exists, we&#39;re done
</span><span></span>  <span>return</span> <span>resp</span><span>.</span><span>Answer</span><span>,</span> <span>nil</span>
<span>}</span>
</code></pre></div><p>And now we can resolve CNAMEs:</p>
<div><pre tabindex="0"><code data-lang="bash">❯ go run dns.go pages.github.com
Asking 198.41.0.4 about pages.github.com
Asking 192.12.94.30 about pages.github.com
Asking 205.251.193.165 about pages.github.com
Asking 198.41.0.4 about github.github.io.
Asking 65.22.161.17 about github.github.io.
Asking 198.41.0.4 about dns1.p05.nsone.net.
Asking 192.12.94.30 about dns1.p05.nsone.net.
Asking 198.51.44.1 about dns1.p05.nsone.net.
Asking 198.51.44.5 about github.github.io.
github.github.io.	3600	IN	A	185.199.108.153
github.github.io.	3600	IN	A	185.199.109.153
github.github.io.	3600	IN	A	185.199.110.153
github.github.io.	3600	IN	A	185.199.111.153
</code></pre></div><h2 id="wrapping-up">Wrapping Up</h2>
<p>That’s it! This resolver isn’t anywhere near complete (error handling, caching, other record types, and IPv6, to name just a few omissions), but I hope it helps you understand how DNS resolution really works under the hood!</p>
<p>You can find the code for the entire resolver <a href="https://gist.github.com/timothyandrew/c5d13b5957f1323ea775705ff9374ff1">here</a>.</p>


      </main>
      </div></div>
  </body>
</html>
