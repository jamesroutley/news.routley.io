<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://veera.app/trait_selection_bug.html">Original</a>
    <h1>Understanding a Trait Selection Bug</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
<header>

<p>2024-Apr-21</p>
</header><p>
Recently, I ran into <a href="https://github.com/rust-lang/rust/issues/122595">rust-lang/issues/#24066</a> and spent some time analysing the underlying trait selection mechanism. In this blog post, I’ll briefly explain why this bug prevents the following snippet from compiling.
</p>

<div>
<pre>fn add&lt;T&gt;() where
    u32: std::ops::Add&lt;T, Output = T&gt;
{
    let _ = 1_u32 + 1_u32; // error[E0308]: mismatched types
}
</pre>
</div>

<p>
Inside the compiler, the <code>rustc_hir_typeck</code> crate handles lookup of methods for binary operations. When it encounters the expression <code>1_u32 + 1_u32</code>, it does something peculiar: instead of directly looking up for a method that adds an <code>u32</code> to another <code>u32</code>, it searches for a method that can add an <code>u32</code> to a type inference variable <code>$0</code>. This allows the compiler to either borrow or take ownership of the value on the RHS of the binary expression based on the available methods<sup><a id="fnr.1" href="#fn.1">1</a></sup>.
</p>

<p>
The request “find a method to add an <code>u32</code> with the type inference variable <code>$0</code>” is handled by the <code>rustc_trait_selection</code> crate, which selects an appropriate method from a collection of candidates. Here, traits specified in the where clause are given a higher precedence over other candidates<sup><a id="fnr.2" href="#fn.2">2</a></sup>. I believe this heuristic is followed as the programmer is expected to specify only the necessary traits in the where clause.
</p>

<p>
Thus, for the expression <code>1_u32 + 1_u32</code>, a method which adds an <code>u32</code> and a type variable <code>T</code> is chosen because it’s mentioned in the where clause and <code>T</code> unifies with the type inference variable <code>$0</code>. This attempts to unify the <code>u32</code> on the RHS with type variable <code>T</code>, resulting in a type mismatch error.
</p>

<p>
Guess, this is an other instance where a compiler leans towards soundness over completeness.
</p>
</div></div>
  </body>
</html>
