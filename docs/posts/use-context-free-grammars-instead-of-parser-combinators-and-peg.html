<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://safinaskar.writeas.com/">Original</a>
    <h1>Use context-free grammars instead of parser combinators and PEG</h1>
    
    <div id="readability-page-1" class="page"><div lang="en" dir="ltr"><p>This post is answer to Jesper Cockx&#39;s article “<a href="https://jesper.cx/posts/1001-syntax-representations.html">1001 Representations of Syntax with Binding</a>”, so you can read it first (but this is not required).</p>

<p>Note: I will be biased towards practical programs (compilers and interpreters), as opposed to developing metatheory.</p>

<p>Also note that I&#39;m not expert. I have little experience with de Bruijn indices and similar things.</p>

<p>Let me add some methods and comparison criteria to Jesper&#39;s article.</p>

<p>First of all, let me introduce one method not mentioned in the Jesper&#39;s article: randomly generated globally unique identifiers for all bound variables! I didn&#39;t find this method anywhere, so it is possible it has some disadvantages I am not aware of.</p>

<p>I will discuss pros and cons of this method later, but first let me share some criteria not mentioned in the article.</p>

<p>First, <strong>ability to perform capture-avoiding substitution for lambda-terms in more or less sane way</strong>. (Yes, I&#39;m aware this criteria is not so clearly formulated.) Naive approach (i. e. when you just use strings for variables) obviously fails to confirm to this criteria. On the other hand, de Bruijn indices do meet this criteria. In fact, nearly all existing methods meet this criteria (this is why they are created!). This criteria is so obvious that it is possibly not worth to be mentioned. Yet let me mention it anyway.</p>

<p>Next criteria: <strong>any variable is always encoded same</strong>. Good example of method, which fails to satisfy this criteria: de Bruijn indices. Let me explain. Consider this term:</p>

<p><code>λ x. λ y. λ z. (x y)</code></p>

<p>Let&#39;s assume for some reason we want to move subterm <code>x y</code> out of <code>λ z. (x y)</code> term (to get <code>λ x. λ y. (x y)</code>). Then we cannot just move the term as is. Because encoding of <code>x y</code> depends on <em>where</em> the term is located. So we need to change the term&#39;s representation. So, de Bruijn indices don&#39;t satisfy this criteria.</p>

<p>On the other hand, both naive encoding and unique identifiers do satisfy this criteria.</p>

<p>At this point some de Bruijn indices fan may say: “Wait! You just use de Bruijn indices wrong way! You should not try to change subterms located deeply inside other terms. You should use <em>locally nameless</em> representation (from “1001 Representations of Syntax with Binding”). Then when you want to mess with some deeply located subterm, you should first <em>open</em> your big term using <code>openT</code> from “1001 Representations of Syntax with Binding”, possibly multiple times, and then change that deeply located subterm needed way.</p>

<p>Well, yes, I agree. If we call <code>openT</code> repeatedly, then indeed this de Bruijn indices disadvantage disappears. But this means that every time we want to modify something inside a term, we need to open it!</p>

<p>Let&#39;s assume we are writing optimizing compiler. Job of optimizing compiler is to modify some small parts located inside of AST. With de Bruijn indices every time we want to change some small part of AST we will need first to call <code>openT</code> repeatedly, reach needed part, change it, and then <code>closeT</code> many times again. This is very artificial. And very slow. Our compiler will simply be too slow.</p>

<p>So, I still think that <em>“any variable is always encoded same”</em> is important property and that de Bruijn indices violate this property.</p>

<p>The other advantage of <em>“any variable is always encoded same”</em> is simple and natural equality function for subterms. Consider this term:</p>

<p><code>λ x. λ y. ((λ z. (x y)) (x y))</code></p>

<p>This term contains subterm <code>x y</code> two times, yet they are encoded differently with de Bruijn indices. And moreover, we simply cannot write function, which will compare them for alpha-equivalence based on terms alone. Because to compare them we must consider not only terms themselves, but also their location! So, with de Bruijn indices we either need some complicated alpha equality function, which deals with locations, either we again need to call <code>openT</code> many times! Let&#39;s again consider optimizer compiler use case. In optimizing compiler we often need to compare some subterms (located deeply inside of bigger term) to decide whether we need to apply some optimization. So, merely to determine whether we need an optimization, we need to call <code>openT</code> many times! And if we call <code>openT</code> <code>N</code> times and our big term has size <code>M</code>, then, as well as I understand, we need <code>O(NM)</code> operations for <code>openT</code> alone!</p>

<p>Next criteria: <strong>no need to came up with artificial numbering of variables</strong>. Consider this Rust source:</p>

<pre><code>fn f(x: i32, y: i32) {
  let z = 0;
  let [t, u] = [0, 0];
  match foo {
    None =&gt; {},
    Some(v) =&gt; println!(x), // &lt;-- how to encode &#34;x&#34; here?
  }
}
</code></pre>

<p>How to encode <code>x</code> in <code>println!(x)</code> with de Bruijn indices? To do this we need to specify how we assign order to all this bindings. Bindings can be introduced by various ways. In this example you can see these ways:
– As function argument
– As normal <code>let</code> binding
– As destructive <code>let</code> binding (<code>let [t, u]</code>)
– As binding in <code>match</code> (<code>Some(v) =&gt;</code>)</p>

<p>And we need to came up with methods for encoding all these using de Bruijn indices! So de Bruijn indices fail to satisfy this criteria. But naive approach and unique identifiers do satisfy it!</p>

<p>Next: <strong>ability to perform trivial copy of terms without restrictions</strong>. Programming languages, such as Haskell and Agda, have a feature: they allow us to copy values very easily. Implicit copying of values is so easy that we did not even think about it. Yet unrestricted copy of terms ruin one of methods, namely unique identifiers. Because if we copy terms with lambdas inside, then our unique identifiers become not so unique anymore. You may say: “So what? What problems this will cause?” Let me describe. Consider this term:</p>

<p><code>(λ y. y y) (λ x. λ z. x z)</code></p>

<p>Let&#39;s assume we use unique IDs. We will show these unique IDs in square brackets:</p>

<p><code>(λ y[2]. y[2] y[2]) (λ x[1]. λ z[3]. x[1] z[3])</code></p>

<p>Now let&#39;s do one beta reduction. Let&#39;s assume that our beta reduction algorithm is buggy: it blindly performs naive copy of terms. In this case we will get this:</p>

<p><code>(λ x[1]. λ z[3]. x[1] z[3]) (λ x[1]. λ z[3]. x[1] z[3])</code></p>

<p>As you can see our unique IDs are not so unique anymore: we have two different <code>x[1]</code> variables. But what is wrong with this? Well, let&#39;s continue our beta reductions to understand where the problem lies. So, let&#39;s do another beta reduction:</p>

<p><code>λ z[3]. (λ x[1]. λ z[3]. x[1] z*[3]) z[3]</code></p>

<p>Now, ask yourself: what means that <code>z*[3]</code>? (I marked it with <code>*</code> to easily refer to it.) It is located inside two lambda expressions, which both bind <code>z[3]</code>. Oops.</p>

<p>So, this means that if we use unique IDs, then we cannot copy our term using trivial copy (which is implicit in Haskell, Agda, etc). Instead we should use “smart” user-defined copy. I think this is one of the reasons why unique IDs are not popular among functional programmers. Yet there is no any problems in Rust, because Rust has support for affine types! Affine types are types, which are not copied implicitly! So, to implement this in Rust, we simply make our term non-<code>Copy</code> type and implement user-defined <code>clone</code>.</p>

<p>Update 16 May 2024. If we use de Bruijn indices, we have some problems with copy, too: if a term is located inside a bigger term, then we cannot simply copy it, we sometimes need to do <code>openT</code>, as discussed above. Yet, if this is a standalone term, then we can copy it without problems, as opposed to unique IDs method.</p>

<p>Next criteria: <strong>no need for external method for generating IDs</strong>. “Unique IDs” method fails to satisfy this criteria: you need some method for generating IDs. I. e. counter or random number generator. In both cases you cannot generate IDs from pure computation in pure functional language, such as Haskell or Agda. You need to live inside of some kind of random number generator monad. I think this is another reason why functional programmers don&#39;t like unique IDs. Yet this is not problem in imperative languages, such as Rust.</p>

<p>Next criteria: <strong>basic operations have no more than linear complexity</strong>. As I mentioned above, de Bruijn indices fail to satisfy this criteria: if want to modify (or even inspect) subterm, located deeply inside another term, you need to make <code>O(NM)</code> operations.</p>

<p>Now let me show you my comparison table.</p>

<p>“LoNa” – locally nameless de Bruijn indices
“Unique” – unique IDs</p>

<table>
<thead>
<tr>
<th></th>
<th>LoNa</th>
<th>Unique</th>
</tr>
</thead>

<tbody>
<tr>
<td>ability to perform capture-avoiding substitution for lambda-terms in more or less sane way</td>
<td>Yes</td>
<td>Yes</td>
</tr>

<tr>
<td>any variable is always encoded same</td>
<td>No</td>
<td>Yes</td>
</tr>

<tr>
<td>no need to came up with artificial numbering of variables</td>
<td>No</td>
<td>Yes</td>
</tr>

<tr>
<td>ability to perform trivial copy of terms without restrictions</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td>no need for external method for generating IDs</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td>basic operations have no more than linear complexity</td>
<td>No</td>
<td>Yes</td>
</tr>
</tbody>
</table>

<p>Okay, what we should choose? Well, as you probably guessed, I strongly believe one should always choose unique IDs, if they are creating practical program (compiler or interpreter, etc). No matter what is your implementation language (Rust, Haskell, Agda, etc), you should always choose unique IDs for practical programs. (Yes, unique IDs probably are not so good if you are developing metatheory.)</p>

<p>Why? Because unique IDs are easy to understand AND simple to implement AND fast. I described above, why I think so.</p>

<p>Unique IDs allow you to easily move subterm inside of larger term without need to re-encode it. Unique IDs allow you to inspect or modify subterm inside of larger term without need to repeatedly call <code>openT</code> (which is both annoying AND very slow, <code>O(NM)</code> slow). And unique IDs are easier to understand for humans than these strange de Bruijn indices.</p>

<p>Yes, in languages such as Haskell and Agda you need to be careful with copies, and you need to be inside of random number generator monad (or counter monad). So what? I think this is minor point. And you don&#39;t have these problems with monads and copies, if your implementation language is Rust.</p>

<p>Update 16 May 2024: Jesper&#39;s answer: <a href="https://agda.club/notice/AhvAH3SYkaU7vboRoO">https://agda.club/notice/AhvAH3SYkaU7vboRoO</a></p>

<p>This is my first post in this blog. Subscribe to this blog using button in the bottom of <a href="https://safinaskar.writeas.com/">https://safinaskar.writeas.com/</a> or at Mastodon ( <a href="https://types.pl/@safinaskar">https://types.pl/@safinaskar</a> ). I plan to write about formal methods, Rust and Linux.</p>

<p>You can reach me via email safinaskar@gmail.com</p>

<p>Discuss at:
<a href="https://lobste.rs/s/lbzg6m/this_is_why_you_should_never_use_de_bruijn">https://lobste.rs/s/lbzg6m/this_is_why_you_should_never_use_de_bruijn</a>
<a href="https://types.pl/@safinaskar/112442405322545975">https://types.pl/@safinaskar/112442405322545975</a> (Mastodon)
<a href="https://www.reddit.com/r/rust/comments/1cs8iq3/this_is_why_you_should_never_use_de_bruijn/">https://www.reddit.com/r/rust/comments/1cs8iq3/this_is_why_you_should_never_use_de_bruijn/</a></p>
</div></div>
  </body>
</html>
